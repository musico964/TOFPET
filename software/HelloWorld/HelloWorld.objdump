
HelloWorld.elf:     file format elf32-littlenios2
HelloWorld.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x090802b4

Program Header:
    LOAD off    0x00001000 vaddr 0x06020000 paddr 0x06020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001120 vaddr 0x09080120 paddr 0x09080120 align 2**12
         filesz 0x0000c51c memsz 0x0000c7fc flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  06020000  06020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000194  09080120  09080120  00001120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000a3b8  090802b4  090802b4  000012b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000318  0908a66c  0908a66c  0000b66c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001cb8  0908a984  0908a984  0000b984  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000002e0  0908c63c  0908c63c  0000d63c  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  0000d63c  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000ad0  00000000  00000000  0000d668  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00001631  00000000  00000000  0000e138  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0002435c  00000000  00000000  0000f769  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000067f4  00000000  00000000  00033ac5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00010f1e  00000000  00000000  0003a2b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001960  00000000  00000000  0004b1d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001dc4  00000000  00000000  0004cb38  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00005346  00000000  00000000  0004e8fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  00053c44  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000002d8  00000000  00000000  00053c98  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000572af  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  000572b2  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000572b5  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000572b6  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  000572b7  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  000572bb  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  000572bf  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  000572c3  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  000572cc  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  000572d5  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000e  00000000  00000000  000572de  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000054  00000000  00000000  000572ec  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000ab0e6  00000000  00000000  00057340  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
06020000 l    d  .entry	00000000 .entry
09080120 l    d  .exceptions	00000000 .exceptions
090802b4 l    d  .text	00000000 .text
0908a66c l    d  .rodata	00000000 .rodata
0908a984 l    d  .rwdata	00000000 .rwdata
0908c63c l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
090802f8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
090806d0 l     F .text	00000058 std
090807dc l     F .text	00000008 __fp_lock
090807e4 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
0908a984 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
0908226c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
090835d0 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_close.c
09083818 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
09083878 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
09083978 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
09083a98 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
09083be8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_open.c
09083cf4 l     F .text	000000dc alt_file_locked
09083f58 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_read.c
090840d8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0908c614 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
09084374 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0908b334 l     O .rwdata	000000d8 ext_flash
0908b40c l     O .rwdata	00001060 jtag_uart
0908c46c l     O .rwdata	00000120 lcd
0908c58c l     O .rwdata	00000030 sgdma_rx
0908c5bc l     O .rwdata	00000030 sgdma_tx
090844bc l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
09084590 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
09085390 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0908647c l     F .text	00000228 altera_avalon_jtag_uart_irq
090866a4 l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
0908c618 l     O .rwdata	00000004 colstart
09086d20 l     F .text	000000b8 lcd_write_command
09086dd8 l     F .text	000000d4 lcd_write_data
09086eac l     F .text	000000c4 lcd_clear_screen
09086f70 l     F .text	000001ec lcd_repaint_screen
0908715c l     F .text	000000c8 lcd_scroll_up
09087224 l     F .text	000002d0 lcd_handle_escape
090879f8 l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
09088340 l     F .text	00000060 alt_get_errno
090888e8 l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
09088a54 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
09088dd4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
09089504 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
09089c18 l     F .text	000000bc alt_write_word_amd
09089af4 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
09089ecc l     F .text	0000018c alt_unlock_block_intel
0908a058 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
0908a801 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0908a454 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0908a608 l     F .text	00000040 alt_sim_halt
09082adc g     F .text	00000070 _isatty_r
09083c48 g     F .text	0000006c alt_main
09081ff4 g     F .text	000000a0 _puts_r
09084e50 g     F .text	00000048 alt_read_query_entry_32bit
0908c68c g     O .bss	00000100 alt_irq
09082b4c g     F .text	00000078 _lseek_r
090845c8 g     F .text	000002c0 alt_flash_cfi_write
090825a0 g     F .text	000000a0 __sflags
0908c91c g       *ABS*	00000000 __alt_heap_start
09087dac g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
09082300 g     F .text	00000068 __sseek
09080738 g     F .text	000000a4 __sinit
09080838 g     F .text	00000068 __sfmoreglue
09083cd4 g     F .text	00000020 __malloc_unlock
09088500 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
09082d48 g     F .text	000000e0 memmove
09080828 g     F .text	00000010 _cleanup
00000000  w      *UND*	00000000 __errno
09084fdc g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
06020000 g     F .entry	00000000 __reset
09088014 g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
09081340 g     F .text	00000074 _fstat_r
09084ae4 g     F .text	000002e8 alt_flash_program_block
0908c63c g     O .bss	00000004 errno
0908c650 g     O .bss	00000004 alt_argv
090945ec g       *ABS*	00000000 _gp
09089824 g     F .text	00000030 usleep
0908b1b4 g     O .rwdata	00000180 alt_fd_list
09088efc g     F .text	00000094 alt_find_dev
09082ca8 g     F .text	000000a0 memcpy
0908081c g     F .text	0000000c _cleanup_r
090895c8 g     F .text	00000078 alt_io_redirect
0908a66c g       *ABS*	00000000 __DTOR_END__
09082094 g     F .text	00000014 puts
090880f8 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
090868bc g     F .text	00000224 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
0908370c g     F .text	00000008 __udivsi3
090839d8 g     F .text	000000c0 isatty
0908c640 g     O .bss	00000004 __malloc_top_pad
09082640 g     F .text	0000049c __sfvwrite_r
09088220 g     F .text	00000058 alt_avalon_sgdma_stop
09082288 g     F .text	00000070 _sbrk_r
09089cd4 g     F .text	00000084 alt_program_intel
09082e28 g     F .text	00000078 _read_r
09088ca8 g     F .text	00000078 alt_dcache_flush
0908c60c g     O .rwdata	00000004 alt_max_fd
09084dcc g     F .text	00000040 alt_read_query_entry_8bit
0908037c g     F .text	00000110 _fclose_r
09089d58 g     F .text	00000174 alt_erase_block_intel
0908069c g     F .text	00000034 fflush
0908c644 g     O .bss	00000004 __malloc_max_sbrked_mem
09083af8 g     F .text	000000f0 lseek
0908c5f0 g     O .rwdata	00000004 _global_impure_ptr
09082ea0 g     F .text	000005f4 _realloc_r
0908c91c g       *ABS*	00000000 __bss_end
0908940c g     F .text	000000f8 alt_iic_isr_register
09087c70 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
09089718 g     F .text	0000010c alt_tick
0908c638 g     O .rwdata	00000004 __ctype_ptr
09080804 g     F .text	00000018 __fp_lock_all
090893c4 g     F .text	00000048 alt_ic_irq_enabled
09089680 g     F .text	00000098 alt_alarm_stop
09100000 g       *ABS*	00000000 __alt_mem_descriptor_memory
0908c658 g     O .bss	00000004 alt_irq_active
090801ec g     F .exceptions	000000c8 alt_irq_handler
0908b18c g     O .rwdata	00000028 alt_dev_null
090852e4 g     F .text	000000ac alt_set_flash_algorithm_func
09088278 g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
09084e98 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
0908c604 g     O .rwdata	00000008 alt_dev_list
09084254 g     F .text	00000120 write
09088428 g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
090838a4 g     F .text	000000d4 fstat
09086198 g     F .text	000000dc alt_check_primary_table
09083714 g     F .text	00000008 __umodsi3
09084918 g     F .text	00000068 alt_flash_cfi_read
0908506c g     F .text	00000034 alt_write_native_8bit
09088084 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
0908817c g     F .text	00000050 alt_avalon_sgdma_register_callback
0908c91c g       *ABS*	00000000 end
09084ed4 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
090874f4 g     F .text	00000504 altera_avalon_lcd_16207_write
0908131c g     F .text	00000024 fseek
0908540c g     F .text	000005e0 alt_read_cfi_table
090863bc g     F .text	000000c0 altera_avalon_jtag_uart_init
0908a668 g       *ABS*	00000000 __CTOR_LIST__
09100000 g       *ABS*	00000000 __alt_stack_pointer
090884a4 g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
09088ac4 g     F .text	00000090 alt_avalon_timer_sc_init
09086ae0 g     F .text	00000240 altera_avalon_jtag_uart_write
09087ed0 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
090844f4 g     F .text	0000009c alt_flash_cfi_init
09080728 g     F .text	00000004 __sfp_lock_acquire
09082bc4 g     F .text	000000e4 memchr
09087fc0 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
09080bcc g     F .text	00000314 _free_r
0908a458 g     F .text	000001b0 __call_exitprocs
0908c5f8 g     O .rwdata	00000004 __malloc_sbrk_base
090802b4 g     F .text	00000048 _start
0908c65c g     O .bss	00000004 _alt_tick_rate
090882e8 g     F .text	00000058 alt_avalon_sgdma_open
0908c660 g     O .bss	00000004 _alt_nticks
09083fb8 g     F .text	00000120 read
09084408 g     F .text	000000b4 alt_sys_init
09081f7c g     F .text	00000078 _open_r
0908a320 g     F .text	00000134 __register_exitproc
09084e0c g     F .text	00000044 alt_read_query_entry_16bit
09089640 g     F .text	00000040 alt_remap_uncached
09086754 g     F .text	00000074 altera_avalon_jtag_uart_close
0908c664 g     O .bss	00000028 __malloc_current_mallinfo
09085104 g     F .text	000001e0 alt_set_flash_width_func
09086274 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
09089180 g     F .text	000000b8 alt_get_fd
0908a134 g     F .text	0000012c alt_busy_sleep
09082530 g     F .text	00000070 _close_r
090898dc g     F .text	00000218 alt_erase_block_amd
0908a2ac g     F .text	00000074 memcmp
09086324 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0908c91c g       *ABS*	00000000 __alt_stack_base
0908636c g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
09081534 g     F .text	0000009c _fwrite_r
09083494 g     F .text	0000013c __swsetup_r
090859ec g     F .text	000007ac alt_read_cfi_width
090808a0 g     F .text	000000f0 __sfp
0908ad84 g     O .rwdata	00000408 __malloc_av_
09080734 g     F .text	00000004 __sinit_lock_release
090823e4 g     F .text	00000060 __sread
09088f90 g     F .text	00000120 alt_find_file
09088d20 g     F .text	000000b4 alt_dev_llist_insert
09083cb4 g     F .text	00000020 __malloc_lock
09084198 g     F .text	000000bc sbrk
090881cc g     F .text	00000054 alt_avalon_sgdma_start
090804a0 g     F .text	000001fc _fflush_r
0908c624 g     O .rwdata	00000008 alt_flash_dev_list
09084f98 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
09080a84 g     F .text	0000001c fopen
0908c63c g       *ABS*	00000000 __bss_start
09081ee4 g     F .text	00000098 memset
090802fc g     F .text	00000080 main
0908c654 g     O .bss	00000004 alt_envp
0908c648 g     O .bss	00000004 __malloc_max_total_mem
090862cc g     F .text	00000058 altera_avalon_jtag_uart_write_fd
09087ac4 g     F .text	00000154 altera_avalon_lcd_16207_init
0908c61c g     O .rwdata	00000008 alt_sgdma_list
090822f8 g     F .text	00000008 __sclose
09100000 g       *ABS*	00000000 __alt_heap_limit
0908048c g     F .text	00000014 fclose
0908c78c g     O .bss	00000190 _atexit0
090817a4 g     F .text	00000740 _malloc_r
0908c610 g     O .rwdata	00000004 alt_errno
09085024 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
0908147c g     F .text	000000b8 _fwalk
09084980 g     F .text	00000164 alt_write_value_to_flash
090850a0 g     F .text	00000034 alt_write_native_16bit
09080000 g       *ABS*	00000000 __alt_mem_onchip_SRAM
0908364c g     F .text	00000060 __divsi3
09080aa0 g     F .text	0000012c _malloc_trim_r
0908a66c g       *ABS*	00000000 __CTOR_END__
0908a66c g       *ABS*	00000000 __DTOR_LIST__
090843d4 g     F .text	00000034 alt_irq_init
09084138 g     F .text	00000060 alt_release_fd
0908a260 g     F .text	00000014 atexit
090824b8 g     F .text	00000078 _write_r
0908c5ec g     O .rwdata	00000004 _impure_ptr
0908c64c g     O .bss	00000004 alt_argc
09088e98 g     F .text	00000064 _do_dtors
09080ee0 g     F .text	0000043c _fseek_r
090820a8 g     F .text	000001c4 __srefill_r
09080120 g       .exceptions	00000000 alt_irq_entry
090807ec g     F .text	00000018 __fp_unlock_all
09087c18 g     F .text	00000058 altera_avalon_lcd_16207_write_fd
0908c5fc g     O .rwdata	00000008 alt_fs_list
09084f50 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
09089238 g     F .text	00000050 alt_ic_isr_register
090815d0 g     F .text	00000040 fwrite
0908c63c g       *ABS*	00000000 _edata
0908c91c g       *ABS*	00000000 _end
090890b0 g     F .text	0000007c alt_flash_open_dev
090867c8 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
09089324 g     F .text	000000a0 alt_ic_irq_disable
090883a0 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
09082368 g     F .text	0000007c __swrite
0908c5f4 g     O .rwdata	00000004 __malloc_trim_threshold
09089854 g     F .text	00000020 altera_nios2_qsys_irq_init
0908a274 g     F .text	00000038 exit
090813b4 g     F .text	000000c8 _fwalk_reent
0908912c g     F .text	00000054 alt_flash_close_dev
090836ac g     F .text	00000060 __modsi3
09100000 g       *ABS*	00000000 __alt_data_end
09080120 g     F .exceptions	00000000 alt_exception
0908072c g     F .text	00000004 __sfp_lock_release
0908a700 g     O .rodata	00000101 _ctype_
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
09080990 g     F .text	000000f4 _fopen_r
0908a648 g     F .text	00000020 _exit
09088b54 g     F .text	00000154 alt_alarm_start
09081610 g     F .text	00000194 __smakebuf_r
090850d4 g     F .text	00000030 alt_write_native_32bit
09082444 g     F .text	00000074 strlen
09083dd0 g     F .text	00000188 open
09084888 g     F .text	00000090 alt_flash_cfi_get_info
0908c62c g     O .rwdata	00000004 alt_priority_mask
09089288 g     F .text	0000009c alt_ic_irq_enable
09087f40 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0908c630 g     O .rwdata	00000008 alt_alarm_list
09088e34 g     F .text	00000064 _do_ctors
0908371c g     F .text	000000fc close
09089874 g     F .text	00000068 alt_program_amd
090889a8 g     F .text	000000ac alt_avalon_sgdma_init
00000000  w      *UND*	00000000 free
09080730 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .exceptions:

09080120 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 9080120:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 9080124:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 9080128:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 908012c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 9080130:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 9080134:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 9080138:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 908013c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 9080140:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 9080144:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 9080148:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 908014c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 9080150:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 9080154:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 9080158:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 908015c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 9080160:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 9080164:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 9080168:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 908016c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 9080170:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 9080174:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 9080178:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 908017c:	10000326 	beq	r2,zero,908018c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 9080180:	20000226 	beq	r4,zero,908018c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 9080184:	90801ec0 	call	90801ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 9080188:	00000306 	br	9080198 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 908018c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 9080190:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 9080194:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 9080198:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 908019c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 90801a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 90801a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 90801a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 90801ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 90801b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 90801b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 90801b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 90801bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 90801c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 90801c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 90801c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 90801cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 90801d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 90801d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 90801d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 90801dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 90801e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 90801e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 90801e8:	ef80083a 	eret

090801ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 90801ec:	defff904 	addi	sp,sp,-28
 90801f0:	dfc00615 	stw	ra,24(sp)
 90801f4:	df000515 	stw	fp,20(sp)
 90801f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 90801fc:	0005313a 	rdctl	r2,ipending
 9080200:	e0bffc15 	stw	r2,-16(fp)

  return active;
 9080204:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 9080208:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 908020c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 9080210:	00800044 	movi	r2,1
 9080214:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 9080218:	e0ffff17 	ldw	r3,-4(fp)
 908021c:	e0bffe17 	ldw	r2,-8(fp)
 9080220:	1884703a 	and	r2,r3,r2
 9080224:	1005003a 	cmpeq	r2,r2,zero
 9080228:	1000161e 	bne	r2,zero,9080284 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 908022c:	e0bffd17 	ldw	r2,-12(fp)
 9080230:	00c24274 	movhi	r3,2313
 9080234:	18f1a304 	addi	r3,r3,-14708
 9080238:	100490fa 	slli	r2,r2,3
 908023c:	10c5883a 	add	r2,r2,r3
 9080240:	11400017 	ldw	r5,0(r2)
 9080244:	e0bffd17 	ldw	r2,-12(fp)
 9080248:	00c24274 	movhi	r3,2313
 908024c:	18f1a304 	addi	r3,r3,-14708
 9080250:	100490fa 	slli	r2,r2,3
 9080254:	10c5883a 	add	r2,r2,r3
 9080258:	10800104 	addi	r2,r2,4
 908025c:	11000017 	ldw	r4,0(r2)
 9080260:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 9080264:	0005313a 	rdctl	r2,ipending
 9080268:	e0bffb15 	stw	r2,-20(fp)

  return active;
 908026c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 9080270:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 9080274:	e0bfff17 	ldw	r2,-4(fp)
 9080278:	1004c03a 	cmpne	r2,r2,zero
 908027c:	103fe31e 	bne	r2,zero,908020c <alt_irq_handler+0x20>
 9080280:	00000706 	br	90802a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 9080284:	e0bffe17 	ldw	r2,-8(fp)
 9080288:	1085883a 	add	r2,r2,r2
 908028c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 9080290:	e0bffd17 	ldw	r2,-12(fp)
 9080294:	10800044 	addi	r2,r2,1
 9080298:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 908029c:	003fde06 	br	9080218 <alt_irq_handler+0x2c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 90802a0:	e037883a 	mov	sp,fp
 90802a4:	dfc00117 	ldw	ra,4(sp)
 90802a8:	df000017 	ldw	fp,0(sp)
 90802ac:	dec00204 	addi	sp,sp,8
 90802b0:	f800283a 	ret

Disassembly of section .text:

090802b4 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 90802b4:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 90802b8:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 90802bc:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 90802c0:	00bffd16 	blt	zero,r2,90802b8 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 90802c4:	06c24434 	movhi	sp,2320
    ori sp, sp, %lo(__alt_stack_pointer)
 90802c8:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 90802cc:	06824274 	movhi	gp,2313
    ori gp, gp, %lo(_gp)
 90802d0:	d6917b14 	ori	gp,gp,17900
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 90802d4:	00824234 	movhi	r2,2312
    ori r2, r2, %lo(__bss_start)
 90802d8:	10b18f14 	ori	r2,r2,50748

    movhi r3, %hi(__bss_end)
 90802dc:	00c24234 	movhi	r3,2312
    ori r3, r3, %lo(__bss_end)
 90802e0:	18f24714 	ori	r3,r3,51484

    beq r2, r3, 1f
 90802e4:	10c00326 	beq	r2,r3,90802f4 <_start+0x40>

0:
    stw zero, (r2)
 90802e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 90802ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 90802f0:	10fffd36 	bltu	r2,r3,90802e8 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 90802f4:	9083c480 	call	9083c48 <alt_main>

090802f8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 90802f8:	003fff06 	br	90802f8 <alt_after_alt_main>

090802fc <main>:

#include <stdio.h>


int main()
{
 90802fc:	defffb04 	addi	sp,sp,-20
 9080300:	dfc00415 	stw	ra,16(sp)
 9080304:	df000315 	stw	fp,12(sp)
 9080308:	df000304 	addi	fp,sp,12
	FILE *lcd_dev;
	char *lcd_static;
	int len;

	lcd_dev = fopen( "/dev/lcd", "w" );
 908030c:	01024274 	movhi	r4,2313
 9080310:	21299b04 	addi	r4,r4,-22932
 9080314:	01424274 	movhi	r5,2313
 9080318:	29699e04 	addi	r5,r5,-22920
 908031c:	9080a840 	call	9080a84 <fopen>
 9080320:	e0bfff15 	stw	r2,-4(fp)
	lcd_static = "Hello from Nios II!";
 9080324:	00824274 	movhi	r2,2313
 9080328:	10a99f04 	addi	r2,r2,-22916
 908032c:	e0bffe15 	stw	r2,-8(fp)
	len = strlen(lcd_static);
 9080330:	e13ffe17 	ldw	r4,-8(fp)
 9080334:	90824440 	call	9082444 <strlen>
 9080338:	e0bffd15 	stw	r2,-12(fp)
	fwrite( lcd_static, 1, len, lcd_dev );
 908033c:	e1bffd17 	ldw	r6,-12(fp)
 9080340:	e13ffe17 	ldw	r4,-8(fp)
 9080344:	01400044 	movi	r5,1
 9080348:	e1ffff17 	ldw	r7,-4(fp)
 908034c:	90815d00 	call	90815d0 <fwrite>
	fclose(lcd_dev);
 9080350:	e13fff17 	ldw	r4,-4(fp)
 9080354:	908048c0 	call	908048c <fclose>

	printf("Hello from Nios II!\n");
 9080358:	01024274 	movhi	r4,2313
 908035c:	21299f04 	addi	r4,r4,-22916
 9080360:	90820940 	call	9082094 <puts>

	return 0;
 9080364:	0005883a 	mov	r2,zero
}
 9080368:	e037883a 	mov	sp,fp
 908036c:	dfc00117 	ldw	ra,4(sp)
 9080370:	df000017 	ldw	fp,0(sp)
 9080374:	dec00204 	addi	sp,sp,8
 9080378:	f800283a 	ret

0908037c <_fclose_r>:
 908037c:	defffc04 	addi	sp,sp,-16
 9080380:	dc400115 	stw	r17,4(sp)
 9080384:	dc000015 	stw	r16,0(sp)
 9080388:	dfc00315 	stw	ra,12(sp)
 908038c:	dc800215 	stw	r18,8(sp)
 9080390:	2821883a 	mov	r16,r5
 9080394:	2023883a 	mov	r17,r4
 9080398:	28002926 	beq	r5,zero,9080440 <_fclose_r+0xc4>
 908039c:	90807280 	call	9080728 <__sfp_lock_acquire>
 90803a0:	88000226 	beq	r17,zero,90803ac <_fclose_r+0x30>
 90803a4:	88800e17 	ldw	r2,56(r17)
 90803a8:	10002d26 	beq	r2,zero,9080460 <_fclose_r+0xe4>
 90803ac:	8080030f 	ldh	r2,12(r16)
 90803b0:	10002226 	beq	r2,zero,908043c <_fclose_r+0xc0>
 90803b4:	8809883a 	mov	r4,r17
 90803b8:	800b883a 	mov	r5,r16
 90803bc:	90804a00 	call	90804a0 <_fflush_r>
 90803c0:	1025883a 	mov	r18,r2
 90803c4:	80800b17 	ldw	r2,44(r16)
 90803c8:	10000426 	beq	r2,zero,90803dc <_fclose_r+0x60>
 90803cc:	81400717 	ldw	r5,28(r16)
 90803d0:	8809883a 	mov	r4,r17
 90803d4:	103ee83a 	callr	r2
 90803d8:	10002a16 	blt	r2,zero,9080484 <_fclose_r+0x108>
 90803dc:	8080030b 	ldhu	r2,12(r16)
 90803e0:	1080200c 	andi	r2,r2,128
 90803e4:	1000231e 	bne	r2,zero,9080474 <_fclose_r+0xf8>
 90803e8:	81400c17 	ldw	r5,48(r16)
 90803ec:	28000526 	beq	r5,zero,9080404 <_fclose_r+0x88>
 90803f0:	80801004 	addi	r2,r16,64
 90803f4:	28800226 	beq	r5,r2,9080400 <_fclose_r+0x84>
 90803f8:	8809883a 	mov	r4,r17
 90803fc:	9080bcc0 	call	9080bcc <_free_r>
 9080400:	80000c15 	stw	zero,48(r16)
 9080404:	81401117 	ldw	r5,68(r16)
 9080408:	28000326 	beq	r5,zero,9080418 <_fclose_r+0x9c>
 908040c:	8809883a 	mov	r4,r17
 9080410:	9080bcc0 	call	9080bcc <_free_r>
 9080414:	80001115 	stw	zero,68(r16)
 9080418:	8000030d 	sth	zero,12(r16)
 908041c:	908072c0 	call	908072c <__sfp_lock_release>
 9080420:	9005883a 	mov	r2,r18
 9080424:	dfc00317 	ldw	ra,12(sp)
 9080428:	dc800217 	ldw	r18,8(sp)
 908042c:	dc400117 	ldw	r17,4(sp)
 9080430:	dc000017 	ldw	r16,0(sp)
 9080434:	dec00404 	addi	sp,sp,16
 9080438:	f800283a 	ret
 908043c:	908072c0 	call	908072c <__sfp_lock_release>
 9080440:	0025883a 	mov	r18,zero
 9080444:	9005883a 	mov	r2,r18
 9080448:	dfc00317 	ldw	ra,12(sp)
 908044c:	dc800217 	ldw	r18,8(sp)
 9080450:	dc400117 	ldw	r17,4(sp)
 9080454:	dc000017 	ldw	r16,0(sp)
 9080458:	dec00404 	addi	sp,sp,16
 908045c:	f800283a 	ret
 9080460:	8809883a 	mov	r4,r17
 9080464:	90807380 	call	9080738 <__sinit>
 9080468:	8080030f 	ldh	r2,12(r16)
 908046c:	103fd11e 	bne	r2,zero,90803b4 <_fclose_r+0x38>
 9080470:	003ff206 	br	908043c <_fclose_r+0xc0>
 9080474:	81400417 	ldw	r5,16(r16)
 9080478:	8809883a 	mov	r4,r17
 908047c:	9080bcc0 	call	9080bcc <_free_r>
 9080480:	003fd906 	br	90803e8 <_fclose_r+0x6c>
 9080484:	04bfffc4 	movi	r18,-1
 9080488:	003fd406 	br	90803dc <_fclose_r+0x60>

0908048c <fclose>:
 908048c:	00824274 	movhi	r2,2313
 9080490:	10b17b04 	addi	r2,r2,-14868
 9080494:	200b883a 	mov	r5,r4
 9080498:	11000017 	ldw	r4,0(r2)
 908049c:	908037c1 	jmpi	908037c <_fclose_r>

090804a0 <_fflush_r>:
 90804a0:	defffb04 	addi	sp,sp,-20
 90804a4:	dcc00315 	stw	r19,12(sp)
 90804a8:	dc800215 	stw	r18,8(sp)
 90804ac:	dfc00415 	stw	ra,16(sp)
 90804b0:	dc400115 	stw	r17,4(sp)
 90804b4:	dc000015 	stw	r16,0(sp)
 90804b8:	2027883a 	mov	r19,r4
 90804bc:	2825883a 	mov	r18,r5
 90804c0:	20000226 	beq	r4,zero,90804cc <_fflush_r+0x2c>
 90804c4:	20800e17 	ldw	r2,56(r4)
 90804c8:	10005626 	beq	r2,zero,9080624 <_fflush_r+0x184>
 90804cc:	9100030b 	ldhu	r4,12(r18)
 90804d0:	20ffffcc 	andi	r3,r4,65535
 90804d4:	18e0001c 	xori	r3,r3,32768
 90804d8:	18e00004 	addi	r3,r3,-32768
 90804dc:	1880020c 	andi	r2,r3,8
 90804e0:	1000261e 	bne	r2,zero,908057c <_fflush_r+0xdc>
 90804e4:	90c00117 	ldw	r3,4(r18)
 90804e8:	20820014 	ori	r2,r4,2048
 90804ec:	9080030d 	sth	r2,12(r18)
 90804f0:	1009883a 	mov	r4,r2
 90804f4:	00c0400e 	bge	zero,r3,90805f8 <_fflush_r+0x158>
 90804f8:	92000a17 	ldw	r8,40(r18)
 90804fc:	40004026 	beq	r8,zero,9080600 <_fflush_r+0x160>
 9080500:	2084000c 	andi	r2,r4,4096
 9080504:	10005326 	beq	r2,zero,9080654 <_fflush_r+0x1b4>
 9080508:	94001417 	ldw	r16,80(r18)
 908050c:	9080030b 	ldhu	r2,12(r18)
 9080510:	1080010c 	andi	r2,r2,4
 9080514:	1000481e 	bne	r2,zero,9080638 <_fflush_r+0x198>
 9080518:	91400717 	ldw	r5,28(r18)
 908051c:	9809883a 	mov	r4,r19
 9080520:	800d883a 	mov	r6,r16
 9080524:	000f883a 	mov	r7,zero
 9080528:	403ee83a 	callr	r8
 908052c:	8080261e 	bne	r16,r2,90805c8 <_fflush_r+0x128>
 9080530:	9080030b 	ldhu	r2,12(r18)
 9080534:	91000417 	ldw	r4,16(r18)
 9080538:	90000115 	stw	zero,4(r18)
 908053c:	10bdffcc 	andi	r2,r2,63487
 9080540:	10ffffcc 	andi	r3,r2,65535
 9080544:	18c4000c 	andi	r3,r3,4096
 9080548:	9080030d 	sth	r2,12(r18)
 908054c:	91000015 	stw	r4,0(r18)
 9080550:	18002b26 	beq	r3,zero,9080600 <_fflush_r+0x160>
 9080554:	0007883a 	mov	r3,zero
 9080558:	1805883a 	mov	r2,r3
 908055c:	94001415 	stw	r16,80(r18)
 9080560:	dfc00417 	ldw	ra,16(sp)
 9080564:	dcc00317 	ldw	r19,12(sp)
 9080568:	dc800217 	ldw	r18,8(sp)
 908056c:	dc400117 	ldw	r17,4(sp)
 9080570:	dc000017 	ldw	r16,0(sp)
 9080574:	dec00504 	addi	sp,sp,20
 9080578:	f800283a 	ret
 908057c:	94400417 	ldw	r17,16(r18)
 9080580:	88001f26 	beq	r17,zero,9080600 <_fflush_r+0x160>
 9080584:	90800017 	ldw	r2,0(r18)
 9080588:	18c000cc 	andi	r3,r3,3
 908058c:	94400015 	stw	r17,0(r18)
 9080590:	1461c83a 	sub	r16,r2,r17
 9080594:	18002526 	beq	r3,zero,908062c <_fflush_r+0x18c>
 9080598:	0005883a 	mov	r2,zero
 908059c:	90800215 	stw	r2,8(r18)
 90805a0:	0400170e 	bge	zero,r16,9080600 <_fflush_r+0x160>
 90805a4:	90c00917 	ldw	r3,36(r18)
 90805a8:	91400717 	ldw	r5,28(r18)
 90805ac:	880d883a 	mov	r6,r17
 90805b0:	800f883a 	mov	r7,r16
 90805b4:	9809883a 	mov	r4,r19
 90805b8:	183ee83a 	callr	r3
 90805bc:	88a3883a 	add	r17,r17,r2
 90805c0:	80a1c83a 	sub	r16,r16,r2
 90805c4:	00bff616 	blt	zero,r2,90805a0 <_fflush_r+0x100>
 90805c8:	9080030b 	ldhu	r2,12(r18)
 90805cc:	00ffffc4 	movi	r3,-1
 90805d0:	10801014 	ori	r2,r2,64
 90805d4:	9080030d 	sth	r2,12(r18)
 90805d8:	1805883a 	mov	r2,r3
 90805dc:	dfc00417 	ldw	ra,16(sp)
 90805e0:	dcc00317 	ldw	r19,12(sp)
 90805e4:	dc800217 	ldw	r18,8(sp)
 90805e8:	dc400117 	ldw	r17,4(sp)
 90805ec:	dc000017 	ldw	r16,0(sp)
 90805f0:	dec00504 	addi	sp,sp,20
 90805f4:	f800283a 	ret
 90805f8:	90800f17 	ldw	r2,60(r18)
 90805fc:	00bfbe16 	blt	zero,r2,90804f8 <_fflush_r+0x58>
 9080600:	0007883a 	mov	r3,zero
 9080604:	1805883a 	mov	r2,r3
 9080608:	dfc00417 	ldw	ra,16(sp)
 908060c:	dcc00317 	ldw	r19,12(sp)
 9080610:	dc800217 	ldw	r18,8(sp)
 9080614:	dc400117 	ldw	r17,4(sp)
 9080618:	dc000017 	ldw	r16,0(sp)
 908061c:	dec00504 	addi	sp,sp,20
 9080620:	f800283a 	ret
 9080624:	90807380 	call	9080738 <__sinit>
 9080628:	003fa806 	br	90804cc <_fflush_r+0x2c>
 908062c:	90800517 	ldw	r2,20(r18)
 9080630:	90800215 	stw	r2,8(r18)
 9080634:	003fda06 	br	90805a0 <_fflush_r+0x100>
 9080638:	90800117 	ldw	r2,4(r18)
 908063c:	90c00c17 	ldw	r3,48(r18)
 9080640:	80a1c83a 	sub	r16,r16,r2
 9080644:	183fb426 	beq	r3,zero,9080518 <_fflush_r+0x78>
 9080648:	90800f17 	ldw	r2,60(r18)
 908064c:	80a1c83a 	sub	r16,r16,r2
 9080650:	003fb106 	br	9080518 <_fflush_r+0x78>
 9080654:	91400717 	ldw	r5,28(r18)
 9080658:	9809883a 	mov	r4,r19
 908065c:	000d883a 	mov	r6,zero
 9080660:	01c00044 	movi	r7,1
 9080664:	403ee83a 	callr	r8
 9080668:	1021883a 	mov	r16,r2
 908066c:	00bfffc4 	movi	r2,-1
 9080670:	80800226 	beq	r16,r2,908067c <_fflush_r+0x1dc>
 9080674:	92000a17 	ldw	r8,40(r18)
 9080678:	003fa406 	br	908050c <_fflush_r+0x6c>
 908067c:	98c00017 	ldw	r3,0(r19)
 9080680:	00800744 	movi	r2,29
 9080684:	18bfde26 	beq	r3,r2,9080600 <_fflush_r+0x160>
 9080688:	9080030b 	ldhu	r2,12(r18)
 908068c:	8007883a 	mov	r3,r16
 9080690:	10801014 	ori	r2,r2,64
 9080694:	9080030d 	sth	r2,12(r18)
 9080698:	003fcf06 	br	90805d8 <_fflush_r+0x138>

0908069c <fflush>:
 908069c:	01424234 	movhi	r5,2312
 90806a0:	29412804 	addi	r5,r5,1184
 90806a4:	2007883a 	mov	r3,r4
 90806a8:	20000526 	beq	r4,zero,90806c0 <fflush+0x24>
 90806ac:	00824274 	movhi	r2,2313
 90806b0:	10b17b04 	addi	r2,r2,-14868
 90806b4:	11000017 	ldw	r4,0(r2)
 90806b8:	180b883a 	mov	r5,r3
 90806bc:	90804a01 	jmpi	90804a0 <_fflush_r>
 90806c0:	00824274 	movhi	r2,2313
 90806c4:	10b17c04 	addi	r2,r2,-14864
 90806c8:	11000017 	ldw	r4,0(r2)
 90806cc:	90813b41 	jmpi	90813b4 <_fwalk_reent>

090806d0 <std>:
 90806d0:	00824234 	movhi	r2,2312
 90806d4:	1088be04 	addi	r2,r2,8952
 90806d8:	20800b15 	stw	r2,44(r4)
 90806dc:	00824234 	movhi	r2,2312
 90806e0:	1088f904 	addi	r2,r2,9188
 90806e4:	20800815 	stw	r2,32(r4)
 90806e8:	00c24234 	movhi	r3,2312
 90806ec:	18c8da04 	addi	r3,r3,9064
 90806f0:	00824234 	movhi	r2,2312
 90806f4:	1088c004 	addi	r2,r2,8960
 90806f8:	2140030d 	sth	r5,12(r4)
 90806fc:	2180038d 	sth	r6,14(r4)
 9080700:	20c00915 	stw	r3,36(r4)
 9080704:	20800a15 	stw	r2,40(r4)
 9080708:	20000015 	stw	zero,0(r4)
 908070c:	20000115 	stw	zero,4(r4)
 9080710:	20000215 	stw	zero,8(r4)
 9080714:	20000415 	stw	zero,16(r4)
 9080718:	20000515 	stw	zero,20(r4)
 908071c:	20000615 	stw	zero,24(r4)
 9080720:	21000715 	stw	r4,28(r4)
 9080724:	f800283a 	ret

09080728 <__sfp_lock_acquire>:
 9080728:	f800283a 	ret

0908072c <__sfp_lock_release>:
 908072c:	f800283a 	ret

09080730 <__sinit_lock_acquire>:
 9080730:	f800283a 	ret

09080734 <__sinit_lock_release>:
 9080734:	f800283a 	ret

09080738 <__sinit>:
 9080738:	20800e17 	ldw	r2,56(r4)
 908073c:	defffd04 	addi	sp,sp,-12
 9080740:	dc400115 	stw	r17,4(sp)
 9080744:	dc000015 	stw	r16,0(sp)
 9080748:	dfc00215 	stw	ra,8(sp)
 908074c:	04400044 	movi	r17,1
 9080750:	01400104 	movi	r5,4
 9080754:	000d883a 	mov	r6,zero
 9080758:	2021883a 	mov	r16,r4
 908075c:	2200bb04 	addi	r8,r4,748
 9080760:	200f883a 	mov	r7,r4
 9080764:	10000526 	beq	r2,zero,908077c <__sinit+0x44>
 9080768:	dfc00217 	ldw	ra,8(sp)
 908076c:	dc400117 	ldw	r17,4(sp)
 9080770:	dc000017 	ldw	r16,0(sp)
 9080774:	dec00304 	addi	sp,sp,12
 9080778:	f800283a 	ret
 908077c:	21000117 	ldw	r4,4(r4)
 9080780:	00824234 	movhi	r2,2312
 9080784:	10820704 	addi	r2,r2,2076
 9080788:	00c000c4 	movi	r3,3
 908078c:	80800f15 	stw	r2,60(r16)
 9080790:	80c0b915 	stw	r3,740(r16)
 9080794:	8200ba15 	stw	r8,744(r16)
 9080798:	84400e15 	stw	r17,56(r16)
 908079c:	8000b815 	stw	zero,736(r16)
 90807a0:	90806d00 	call	90806d0 <std>
 90807a4:	81000217 	ldw	r4,8(r16)
 90807a8:	880d883a 	mov	r6,r17
 90807ac:	800f883a 	mov	r7,r16
 90807b0:	01400284 	movi	r5,10
 90807b4:	90806d00 	call	90806d0 <std>
 90807b8:	81000317 	ldw	r4,12(r16)
 90807bc:	800f883a 	mov	r7,r16
 90807c0:	01400484 	movi	r5,18
 90807c4:	01800084 	movi	r6,2
 90807c8:	dfc00217 	ldw	ra,8(sp)
 90807cc:	dc400117 	ldw	r17,4(sp)
 90807d0:	dc000017 	ldw	r16,0(sp)
 90807d4:	dec00304 	addi	sp,sp,12
 90807d8:	90806d01 	jmpi	90806d0 <std>

090807dc <__fp_lock>:
 90807dc:	0005883a 	mov	r2,zero
 90807e0:	f800283a 	ret

090807e4 <__fp_unlock>:
 90807e4:	0005883a 	mov	r2,zero
 90807e8:	f800283a 	ret

090807ec <__fp_unlock_all>:
 90807ec:	00824274 	movhi	r2,2313
 90807f0:	10b17b04 	addi	r2,r2,-14868
 90807f4:	11000017 	ldw	r4,0(r2)
 90807f8:	01424234 	movhi	r5,2312
 90807fc:	2941f904 	addi	r5,r5,2020
 9080800:	908147c1 	jmpi	908147c <_fwalk>

09080804 <__fp_lock_all>:
 9080804:	00824274 	movhi	r2,2313
 9080808:	10b17b04 	addi	r2,r2,-14868
 908080c:	11000017 	ldw	r4,0(r2)
 9080810:	01424234 	movhi	r5,2312
 9080814:	2941f704 	addi	r5,r5,2012
 9080818:	908147c1 	jmpi	908147c <_fwalk>

0908081c <_cleanup_r>:
 908081c:	01424234 	movhi	r5,2312
 9080820:	29412304 	addi	r5,r5,1164
 9080824:	908147c1 	jmpi	908147c <_fwalk>

09080828 <_cleanup>:
 9080828:	00824274 	movhi	r2,2313
 908082c:	10b17c04 	addi	r2,r2,-14864
 9080830:	11000017 	ldw	r4,0(r2)
 9080834:	908081c1 	jmpi	908081c <_cleanup_r>

09080838 <__sfmoreglue>:
 9080838:	defffc04 	addi	sp,sp,-16
 908083c:	dc400115 	stw	r17,4(sp)
 9080840:	2c401724 	muli	r17,r5,92
 9080844:	dc800215 	stw	r18,8(sp)
 9080848:	2825883a 	mov	r18,r5
 908084c:	89400304 	addi	r5,r17,12
 9080850:	dc000015 	stw	r16,0(sp)
 9080854:	dfc00315 	stw	ra,12(sp)
 9080858:	90817a40 	call	90817a4 <_malloc_r>
 908085c:	0021883a 	mov	r16,zero
 9080860:	880d883a 	mov	r6,r17
 9080864:	000b883a 	mov	r5,zero
 9080868:	10000626 	beq	r2,zero,9080884 <__sfmoreglue+0x4c>
 908086c:	11000304 	addi	r4,r2,12
 9080870:	14800115 	stw	r18,4(r2)
 9080874:	10000015 	stw	zero,0(r2)
 9080878:	11000215 	stw	r4,8(r2)
 908087c:	1021883a 	mov	r16,r2
 9080880:	9081ee40 	call	9081ee4 <memset>
 9080884:	8005883a 	mov	r2,r16
 9080888:	dfc00317 	ldw	ra,12(sp)
 908088c:	dc800217 	ldw	r18,8(sp)
 9080890:	dc400117 	ldw	r17,4(sp)
 9080894:	dc000017 	ldw	r16,0(sp)
 9080898:	dec00404 	addi	sp,sp,16
 908089c:	f800283a 	ret

090808a0 <__sfp>:
 90808a0:	defffd04 	addi	sp,sp,-12
 90808a4:	00824274 	movhi	r2,2313
 90808a8:	10b17c04 	addi	r2,r2,-14864
 90808ac:	dc000015 	stw	r16,0(sp)
 90808b0:	14000017 	ldw	r16,0(r2)
 90808b4:	dc400115 	stw	r17,4(sp)
 90808b8:	dfc00215 	stw	ra,8(sp)
 90808bc:	80800e17 	ldw	r2,56(r16)
 90808c0:	2023883a 	mov	r17,r4
 90808c4:	10002626 	beq	r2,zero,9080960 <__sfp+0xc0>
 90808c8:	8400b804 	addi	r16,r16,736
 90808cc:	80800117 	ldw	r2,4(r16)
 90808d0:	81000217 	ldw	r4,8(r16)
 90808d4:	10ffffc4 	addi	r3,r2,-1
 90808d8:	18000916 	blt	r3,zero,9080900 <__sfp+0x60>
 90808dc:	2080030f 	ldh	r2,12(r4)
 90808e0:	10000b26 	beq	r2,zero,9080910 <__sfp+0x70>
 90808e4:	017fffc4 	movi	r5,-1
 90808e8:	00000206 	br	90808f4 <__sfp+0x54>
 90808ec:	2080030f 	ldh	r2,12(r4)
 90808f0:	10000726 	beq	r2,zero,9080910 <__sfp+0x70>
 90808f4:	18ffffc4 	addi	r3,r3,-1
 90808f8:	21001704 	addi	r4,r4,92
 90808fc:	197ffb1e 	bne	r3,r5,90808ec <__sfp+0x4c>
 9080900:	80800017 	ldw	r2,0(r16)
 9080904:	10001926 	beq	r2,zero,908096c <__sfp+0xcc>
 9080908:	1021883a 	mov	r16,r2
 908090c:	003fef06 	br	90808cc <__sfp+0x2c>
 9080910:	00bfffc4 	movi	r2,-1
 9080914:	00c00044 	movi	r3,1
 9080918:	2080038d 	sth	r2,14(r4)
 908091c:	20c0030d 	sth	r3,12(r4)
 9080920:	20000015 	stw	zero,0(r4)
 9080924:	20000215 	stw	zero,8(r4)
 9080928:	20000115 	stw	zero,4(r4)
 908092c:	20000415 	stw	zero,16(r4)
 9080930:	20000515 	stw	zero,20(r4)
 9080934:	20000615 	stw	zero,24(r4)
 9080938:	20000c15 	stw	zero,48(r4)
 908093c:	20000d15 	stw	zero,52(r4)
 9080940:	20001115 	stw	zero,68(r4)
 9080944:	20001215 	stw	zero,72(r4)
 9080948:	2005883a 	mov	r2,r4
 908094c:	dfc00217 	ldw	ra,8(sp)
 9080950:	dc400117 	ldw	r17,4(sp)
 9080954:	dc000017 	ldw	r16,0(sp)
 9080958:	dec00304 	addi	sp,sp,12
 908095c:	f800283a 	ret
 9080960:	8009883a 	mov	r4,r16
 9080964:	90807380 	call	9080738 <__sinit>
 9080968:	003fd706 	br	90808c8 <__sfp+0x28>
 908096c:	8809883a 	mov	r4,r17
 9080970:	01400104 	movi	r5,4
 9080974:	90808380 	call	9080838 <__sfmoreglue>
 9080978:	80800015 	stw	r2,0(r16)
 908097c:	103fe21e 	bne	r2,zero,9080908 <__sfp+0x68>
 9080980:	00800304 	movi	r2,12
 9080984:	0009883a 	mov	r4,zero
 9080988:	88800015 	stw	r2,0(r17)
 908098c:	003fee06 	br	9080948 <__sfp+0xa8>

09080990 <_fopen_r>:
 9080990:	defffa04 	addi	sp,sp,-24
 9080994:	dcc00415 	stw	r19,16(sp)
 9080998:	2827883a 	mov	r19,r5
 908099c:	300b883a 	mov	r5,r6
 90809a0:	d80d883a 	mov	r6,sp
 90809a4:	dc800315 	stw	r18,12(sp)
 90809a8:	dc400215 	stw	r17,8(sp)
 90809ac:	dc000115 	stw	r16,4(sp)
 90809b0:	dfc00515 	stw	ra,20(sp)
 90809b4:	2021883a 	mov	r16,r4
 90809b8:	90825a00 	call	90825a0 <__sflags>
 90809bc:	1025883a 	mov	r18,r2
 90809c0:	8009883a 	mov	r4,r16
 90809c4:	0023883a 	mov	r17,zero
 90809c8:	1000081e 	bne	r2,zero,90809ec <_fopen_r+0x5c>
 90809cc:	8805883a 	mov	r2,r17
 90809d0:	dfc00517 	ldw	ra,20(sp)
 90809d4:	dcc00417 	ldw	r19,16(sp)
 90809d8:	dc800317 	ldw	r18,12(sp)
 90809dc:	dc400217 	ldw	r17,8(sp)
 90809e0:	dc000117 	ldw	r16,4(sp)
 90809e4:	dec00604 	addi	sp,sp,24
 90809e8:	f800283a 	ret
 90809ec:	90808a00 	call	90808a0 <__sfp>
 90809f0:	1023883a 	mov	r17,r2
 90809f4:	980b883a 	mov	r5,r19
 90809f8:	8009883a 	mov	r4,r16
 90809fc:	01c06d84 	movi	r7,438
 9080a00:	103ff226 	beq	r2,zero,90809cc <_fopen_r+0x3c>
 9080a04:	d9800017 	ldw	r6,0(sp)
 9080a08:	9081f7c0 	call	9081f7c <_open_r>
 9080a0c:	10001816 	blt	r2,zero,9080a70 <_fopen_r+0xe0>
 9080a10:	00c24234 	movhi	r3,2312
 9080a14:	18c8da04 	addi	r3,r3,9064
 9080a18:	923fffcc 	andi	r8,r18,65535
 9080a1c:	8880038d 	sth	r2,14(r17)
 9080a20:	00824234 	movhi	r2,2312
 9080a24:	1088f904 	addi	r2,r2,9188
 9080a28:	88800815 	stw	r2,32(r17)
 9080a2c:	88c00915 	stw	r3,36(r17)
 9080a30:	00824234 	movhi	r2,2312
 9080a34:	1088c004 	addi	r2,r2,8960
 9080a38:	00c24234 	movhi	r3,2312
 9080a3c:	18c8be04 	addi	r3,r3,8952
 9080a40:	4200400c 	andi	r8,r8,256
 9080a44:	8c80030d 	sth	r18,12(r17)
 9080a48:	8009883a 	mov	r4,r16
 9080a4c:	880b883a 	mov	r5,r17
 9080a50:	000d883a 	mov	r6,zero
 9080a54:	01c00084 	movi	r7,2
 9080a58:	88800a15 	stw	r2,40(r17)
 9080a5c:	88c00b15 	stw	r3,44(r17)
 9080a60:	8c400715 	stw	r17,28(r17)
 9080a64:	403fd926 	beq	r8,zero,90809cc <_fopen_r+0x3c>
 9080a68:	9080ee00 	call	9080ee0 <_fseek_r>
 9080a6c:	003fd706 	br	90809cc <_fopen_r+0x3c>
 9080a70:	90807280 	call	9080728 <__sfp_lock_acquire>
 9080a74:	8800030d 	sth	zero,12(r17)
 9080a78:	908072c0 	call	908072c <__sfp_lock_release>
 9080a7c:	0023883a 	mov	r17,zero
 9080a80:	003fd206 	br	90809cc <_fopen_r+0x3c>

09080a84 <fopen>:
 9080a84:	01824274 	movhi	r6,2313
 9080a88:	31b17b04 	addi	r6,r6,-14868
 9080a8c:	2007883a 	mov	r3,r4
 9080a90:	31000017 	ldw	r4,0(r6)
 9080a94:	280d883a 	mov	r6,r5
 9080a98:	180b883a 	mov	r5,r3
 9080a9c:	90809901 	jmpi	9080990 <_fopen_r>

09080aa0 <_malloc_trim_r>:
 9080aa0:	defffb04 	addi	sp,sp,-20
 9080aa4:	dcc00315 	stw	r19,12(sp)
 9080aa8:	04c24274 	movhi	r19,2313
 9080aac:	9ceb6104 	addi	r19,r19,-21116
 9080ab0:	dc800215 	stw	r18,8(sp)
 9080ab4:	dc400115 	stw	r17,4(sp)
 9080ab8:	dc000015 	stw	r16,0(sp)
 9080abc:	2823883a 	mov	r17,r5
 9080ac0:	2025883a 	mov	r18,r4
 9080ac4:	dfc00415 	stw	ra,16(sp)
 9080ac8:	9083cb40 	call	9083cb4 <__malloc_lock>
 9080acc:	98800217 	ldw	r2,8(r19)
 9080ad0:	9009883a 	mov	r4,r18
 9080ad4:	000b883a 	mov	r5,zero
 9080ad8:	10c00117 	ldw	r3,4(r2)
 9080adc:	00bfff04 	movi	r2,-4
 9080ae0:	18a0703a 	and	r16,r3,r2
 9080ae4:	8463c83a 	sub	r17,r16,r17
 9080ae8:	8c43fbc4 	addi	r17,r17,4079
 9080aec:	8822d33a 	srli	r17,r17,12
 9080af0:	0083ffc4 	movi	r2,4095
 9080af4:	8c7fffc4 	addi	r17,r17,-1
 9080af8:	8822933a 	slli	r17,r17,12
 9080afc:	1440060e 	bge	r2,r17,9080b18 <_malloc_trim_r+0x78>
 9080b00:	90822880 	call	9082288 <_sbrk_r>
 9080b04:	98c00217 	ldw	r3,8(r19)
 9080b08:	9009883a 	mov	r4,r18
 9080b0c:	044bc83a 	sub	r5,zero,r17
 9080b10:	80c7883a 	add	r3,r16,r3
 9080b14:	10c00926 	beq	r2,r3,9080b3c <_malloc_trim_r+0x9c>
 9080b18:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9080b1c:	0005883a 	mov	r2,zero
 9080b20:	dfc00417 	ldw	ra,16(sp)
 9080b24:	dcc00317 	ldw	r19,12(sp)
 9080b28:	dc800217 	ldw	r18,8(sp)
 9080b2c:	dc400117 	ldw	r17,4(sp)
 9080b30:	dc000017 	ldw	r16,0(sp)
 9080b34:	dec00504 	addi	sp,sp,20
 9080b38:	f800283a 	ret
 9080b3c:	9009883a 	mov	r4,r18
 9080b40:	90822880 	call	9082288 <_sbrk_r>
 9080b44:	844dc83a 	sub	r6,r16,r17
 9080b48:	00ffffc4 	movi	r3,-1
 9080b4c:	9009883a 	mov	r4,r18
 9080b50:	000b883a 	mov	r5,zero
 9080b54:	01c24274 	movhi	r7,2313
 9080b58:	39f19904 	addi	r7,r7,-14748
 9080b5c:	31800054 	ori	r6,r6,1
 9080b60:	10c00926 	beq	r2,r3,9080b88 <_malloc_trim_r+0xe8>
 9080b64:	38800017 	ldw	r2,0(r7)
 9080b68:	98c00217 	ldw	r3,8(r19)
 9080b6c:	9009883a 	mov	r4,r18
 9080b70:	1445c83a 	sub	r2,r2,r17
 9080b74:	38800015 	stw	r2,0(r7)
 9080b78:	19800115 	stw	r6,4(r3)
 9080b7c:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9080b80:	00800044 	movi	r2,1
 9080b84:	003fe606 	br	9080b20 <_malloc_trim_r+0x80>
 9080b88:	90822880 	call	9082288 <_sbrk_r>
 9080b8c:	99800217 	ldw	r6,8(r19)
 9080b90:	100f883a 	mov	r7,r2
 9080b94:	9009883a 	mov	r4,r18
 9080b98:	1187c83a 	sub	r3,r2,r6
 9080b9c:	008003c4 	movi	r2,15
 9080ba0:	19400054 	ori	r5,r3,1
 9080ba4:	10ffdc0e 	bge	r2,r3,9080b18 <_malloc_trim_r+0x78>
 9080ba8:	00824274 	movhi	r2,2313
 9080bac:	10b17e04 	addi	r2,r2,-14856
 9080bb0:	10c00017 	ldw	r3,0(r2)
 9080bb4:	00824274 	movhi	r2,2313
 9080bb8:	10b19904 	addi	r2,r2,-14748
 9080bbc:	31400115 	stw	r5,4(r6)
 9080bc0:	38c7c83a 	sub	r3,r7,r3
 9080bc4:	10c00015 	stw	r3,0(r2)
 9080bc8:	003fd306 	br	9080b18 <_malloc_trim_r+0x78>

09080bcc <_free_r>:
 9080bcc:	defffd04 	addi	sp,sp,-12
 9080bd0:	dc400115 	stw	r17,4(sp)
 9080bd4:	dc000015 	stw	r16,0(sp)
 9080bd8:	dfc00215 	stw	ra,8(sp)
 9080bdc:	2821883a 	mov	r16,r5
 9080be0:	2023883a 	mov	r17,r4
 9080be4:	28005a26 	beq	r5,zero,9080d50 <_free_r+0x184>
 9080be8:	9083cb40 	call	9083cb4 <__malloc_lock>
 9080bec:	823ffe04 	addi	r8,r16,-8
 9080bf0:	41400117 	ldw	r5,4(r8)
 9080bf4:	00bfff84 	movi	r2,-2
 9080bf8:	02824274 	movhi	r10,2313
 9080bfc:	52ab6104 	addi	r10,r10,-21116
 9080c00:	288e703a 	and	r7,r5,r2
 9080c04:	41cd883a 	add	r6,r8,r7
 9080c08:	30c00117 	ldw	r3,4(r6)
 9080c0c:	51000217 	ldw	r4,8(r10)
 9080c10:	00bfff04 	movi	r2,-4
 9080c14:	1892703a 	and	r9,r3,r2
 9080c18:	5017883a 	mov	r11,r10
 9080c1c:	31006726 	beq	r6,r4,9080dbc <_free_r+0x1f0>
 9080c20:	2880004c 	andi	r2,r5,1
 9080c24:	1005003a 	cmpeq	r2,r2,zero
 9080c28:	32400115 	stw	r9,4(r6)
 9080c2c:	10001a1e 	bne	r2,zero,9080c98 <_free_r+0xcc>
 9080c30:	000b883a 	mov	r5,zero
 9080c34:	3247883a 	add	r3,r6,r9
 9080c38:	18800117 	ldw	r2,4(r3)
 9080c3c:	1080004c 	andi	r2,r2,1
 9080c40:	1000231e 	bne	r2,zero,9080cd0 <_free_r+0x104>
 9080c44:	280ac03a 	cmpne	r5,r5,zero
 9080c48:	3a4f883a 	add	r7,r7,r9
 9080c4c:	2800451e 	bne	r5,zero,9080d64 <_free_r+0x198>
 9080c50:	31000217 	ldw	r4,8(r6)
 9080c54:	00824274 	movhi	r2,2313
 9080c58:	10ab6304 	addi	r2,r2,-21108
 9080c5c:	20807b26 	beq	r4,r2,9080e4c <_free_r+0x280>
 9080c60:	30800317 	ldw	r2,12(r6)
 9080c64:	3a07883a 	add	r3,r7,r8
 9080c68:	19c00015 	stw	r7,0(r3)
 9080c6c:	11000215 	stw	r4,8(r2)
 9080c70:	20800315 	stw	r2,12(r4)
 9080c74:	38800054 	ori	r2,r7,1
 9080c78:	40800115 	stw	r2,4(r8)
 9080c7c:	28001a26 	beq	r5,zero,9080ce8 <_free_r+0x11c>
 9080c80:	8809883a 	mov	r4,r17
 9080c84:	dfc00217 	ldw	ra,8(sp)
 9080c88:	dc400117 	ldw	r17,4(sp)
 9080c8c:	dc000017 	ldw	r16,0(sp)
 9080c90:	dec00304 	addi	sp,sp,12
 9080c94:	9083cd41 	jmpi	9083cd4 <__malloc_unlock>
 9080c98:	80bffe17 	ldw	r2,-8(r16)
 9080c9c:	50c00204 	addi	r3,r10,8
 9080ca0:	4091c83a 	sub	r8,r8,r2
 9080ca4:	41000217 	ldw	r4,8(r8)
 9080ca8:	388f883a 	add	r7,r7,r2
 9080cac:	20c06126 	beq	r4,r3,9080e34 <_free_r+0x268>
 9080cb0:	40800317 	ldw	r2,12(r8)
 9080cb4:	3247883a 	add	r3,r6,r9
 9080cb8:	000b883a 	mov	r5,zero
 9080cbc:	11000215 	stw	r4,8(r2)
 9080cc0:	20800315 	stw	r2,12(r4)
 9080cc4:	18800117 	ldw	r2,4(r3)
 9080cc8:	1080004c 	andi	r2,r2,1
 9080ccc:	103fdd26 	beq	r2,zero,9080c44 <_free_r+0x78>
 9080cd0:	38800054 	ori	r2,r7,1
 9080cd4:	3a07883a 	add	r3,r7,r8
 9080cd8:	280ac03a 	cmpne	r5,r5,zero
 9080cdc:	40800115 	stw	r2,4(r8)
 9080ce0:	19c00015 	stw	r7,0(r3)
 9080ce4:	283fe61e 	bne	r5,zero,9080c80 <_free_r+0xb4>
 9080ce8:	00807fc4 	movi	r2,511
 9080cec:	11c01f2e 	bgeu	r2,r7,9080d6c <_free_r+0x1a0>
 9080cf0:	3806d27a 	srli	r3,r7,9
 9080cf4:	1800481e 	bne	r3,zero,9080e18 <_free_r+0x24c>
 9080cf8:	3804d0fa 	srli	r2,r7,3
 9080cfc:	100690fa 	slli	r3,r2,3
 9080d00:	1acd883a 	add	r6,r3,r11
 9080d04:	31400217 	ldw	r5,8(r6)
 9080d08:	31405926 	beq	r6,r5,9080e70 <_free_r+0x2a4>
 9080d0c:	28800117 	ldw	r2,4(r5)
 9080d10:	00ffff04 	movi	r3,-4
 9080d14:	10c4703a 	and	r2,r2,r3
 9080d18:	3880022e 	bgeu	r7,r2,9080d24 <_free_r+0x158>
 9080d1c:	29400217 	ldw	r5,8(r5)
 9080d20:	317ffa1e 	bne	r6,r5,9080d0c <_free_r+0x140>
 9080d24:	29800317 	ldw	r6,12(r5)
 9080d28:	41800315 	stw	r6,12(r8)
 9080d2c:	41400215 	stw	r5,8(r8)
 9080d30:	8809883a 	mov	r4,r17
 9080d34:	2a000315 	stw	r8,12(r5)
 9080d38:	32000215 	stw	r8,8(r6)
 9080d3c:	dfc00217 	ldw	ra,8(sp)
 9080d40:	dc400117 	ldw	r17,4(sp)
 9080d44:	dc000017 	ldw	r16,0(sp)
 9080d48:	dec00304 	addi	sp,sp,12
 9080d4c:	9083cd41 	jmpi	9083cd4 <__malloc_unlock>
 9080d50:	dfc00217 	ldw	ra,8(sp)
 9080d54:	dc400117 	ldw	r17,4(sp)
 9080d58:	dc000017 	ldw	r16,0(sp)
 9080d5c:	dec00304 	addi	sp,sp,12
 9080d60:	f800283a 	ret
 9080d64:	31000217 	ldw	r4,8(r6)
 9080d68:	003fbd06 	br	9080c60 <_free_r+0x94>
 9080d6c:	3806d0fa 	srli	r3,r7,3
 9080d70:	00800044 	movi	r2,1
 9080d74:	51400117 	ldw	r5,4(r10)
 9080d78:	180890fa 	slli	r4,r3,3
 9080d7c:	1807d0ba 	srai	r3,r3,2
 9080d80:	22c9883a 	add	r4,r4,r11
 9080d84:	21800217 	ldw	r6,8(r4)
 9080d88:	10c4983a 	sll	r2,r2,r3
 9080d8c:	41000315 	stw	r4,12(r8)
 9080d90:	41800215 	stw	r6,8(r8)
 9080d94:	288ab03a 	or	r5,r5,r2
 9080d98:	22000215 	stw	r8,8(r4)
 9080d9c:	8809883a 	mov	r4,r17
 9080da0:	51400115 	stw	r5,4(r10)
 9080da4:	32000315 	stw	r8,12(r6)
 9080da8:	dfc00217 	ldw	ra,8(sp)
 9080dac:	dc400117 	ldw	r17,4(sp)
 9080db0:	dc000017 	ldw	r16,0(sp)
 9080db4:	dec00304 	addi	sp,sp,12
 9080db8:	9083cd41 	jmpi	9083cd4 <__malloc_unlock>
 9080dbc:	2880004c 	andi	r2,r5,1
 9080dc0:	3a4d883a 	add	r6,r7,r9
 9080dc4:	1000071e 	bne	r2,zero,9080de4 <_free_r+0x218>
 9080dc8:	80bffe17 	ldw	r2,-8(r16)
 9080dcc:	4091c83a 	sub	r8,r8,r2
 9080dd0:	41000317 	ldw	r4,12(r8)
 9080dd4:	40c00217 	ldw	r3,8(r8)
 9080dd8:	308d883a 	add	r6,r6,r2
 9080ddc:	20c00215 	stw	r3,8(r4)
 9080de0:	19000315 	stw	r4,12(r3)
 9080de4:	00824274 	movhi	r2,2313
 9080de8:	10b17d04 	addi	r2,r2,-14860
 9080dec:	11000017 	ldw	r4,0(r2)
 9080df0:	30c00054 	ori	r3,r6,1
 9080df4:	52000215 	stw	r8,8(r10)
 9080df8:	40c00115 	stw	r3,4(r8)
 9080dfc:	313fa036 	bltu	r6,r4,9080c80 <_free_r+0xb4>
 9080e00:	00824274 	movhi	r2,2313
 9080e04:	10b19004 	addi	r2,r2,-14784
 9080e08:	11400017 	ldw	r5,0(r2)
 9080e0c:	8809883a 	mov	r4,r17
 9080e10:	9080aa00 	call	9080aa0 <_malloc_trim_r>
 9080e14:	003f9a06 	br	9080c80 <_free_r+0xb4>
 9080e18:	00800104 	movi	r2,4
 9080e1c:	10c0072e 	bgeu	r2,r3,9080e3c <_free_r+0x270>
 9080e20:	00800504 	movi	r2,20
 9080e24:	10c01936 	bltu	r2,r3,9080e8c <_free_r+0x2c0>
 9080e28:	188016c4 	addi	r2,r3,91
 9080e2c:	100690fa 	slli	r3,r2,3
 9080e30:	003fb306 	br	9080d00 <_free_r+0x134>
 9080e34:	01400044 	movi	r5,1
 9080e38:	003f7e06 	br	9080c34 <_free_r+0x68>
 9080e3c:	3804d1ba 	srli	r2,r7,6
 9080e40:	10800e04 	addi	r2,r2,56
 9080e44:	100690fa 	slli	r3,r2,3
 9080e48:	003fad06 	br	9080d00 <_free_r+0x134>
 9080e4c:	22000315 	stw	r8,12(r4)
 9080e50:	22000215 	stw	r8,8(r4)
 9080e54:	3a05883a 	add	r2,r7,r8
 9080e58:	38c00054 	ori	r3,r7,1
 9080e5c:	11c00015 	stw	r7,0(r2)
 9080e60:	41000215 	stw	r4,8(r8)
 9080e64:	40c00115 	stw	r3,4(r8)
 9080e68:	41000315 	stw	r4,12(r8)
 9080e6c:	003f8406 	br	9080c80 <_free_r+0xb4>
 9080e70:	1005d0ba 	srai	r2,r2,2
 9080e74:	00c00044 	movi	r3,1
 9080e78:	51000117 	ldw	r4,4(r10)
 9080e7c:	1886983a 	sll	r3,r3,r2
 9080e80:	20c8b03a 	or	r4,r4,r3
 9080e84:	51000115 	stw	r4,4(r10)
 9080e88:	003fa706 	br	9080d28 <_free_r+0x15c>
 9080e8c:	00801504 	movi	r2,84
 9080e90:	10c00436 	bltu	r2,r3,9080ea4 <_free_r+0x2d8>
 9080e94:	3804d33a 	srli	r2,r7,12
 9080e98:	10801b84 	addi	r2,r2,110
 9080e9c:	100690fa 	slli	r3,r2,3
 9080ea0:	003f9706 	br	9080d00 <_free_r+0x134>
 9080ea4:	00805504 	movi	r2,340
 9080ea8:	10c00436 	bltu	r2,r3,9080ebc <_free_r+0x2f0>
 9080eac:	3804d3fa 	srli	r2,r7,15
 9080eb0:	10801dc4 	addi	r2,r2,119
 9080eb4:	100690fa 	slli	r3,r2,3
 9080eb8:	003f9106 	br	9080d00 <_free_r+0x134>
 9080ebc:	00815504 	movi	r2,1364
 9080ec0:	10c0032e 	bgeu	r2,r3,9080ed0 <_free_r+0x304>
 9080ec4:	00801f84 	movi	r2,126
 9080ec8:	00c0fc04 	movi	r3,1008
 9080ecc:	003f8c06 	br	9080d00 <_free_r+0x134>
 9080ed0:	3804d4ba 	srli	r2,r7,18
 9080ed4:	10801f04 	addi	r2,r2,124
 9080ed8:	100690fa 	slli	r3,r2,3
 9080edc:	003f8806 	br	9080d00 <_free_r+0x134>

09080ee0 <_fseek_r>:
 9080ee0:	deffe804 	addi	sp,sp,-96
 9080ee4:	dd801515 	stw	r22,84(sp)
 9080ee8:	dcc01215 	stw	r19,72(sp)
 9080eec:	dc801115 	stw	r18,68(sp)
 9080ef0:	dc000f15 	stw	r16,60(sp)
 9080ef4:	dfc01715 	stw	ra,92(sp)
 9080ef8:	ddc01615 	stw	r23,88(sp)
 9080efc:	dd401415 	stw	r21,80(sp)
 9080f00:	dd001315 	stw	r20,76(sp)
 9080f04:	dc401015 	stw	r17,64(sp)
 9080f08:	2025883a 	mov	r18,r4
 9080f0c:	2821883a 	mov	r16,r5
 9080f10:	302d883a 	mov	r22,r6
 9080f14:	3827883a 	mov	r19,r7
 9080f18:	20000226 	beq	r4,zero,9080f24 <_fseek_r+0x44>
 9080f1c:	20800e17 	ldw	r2,56(r4)
 9080f20:	10007826 	beq	r2,zero,9081104 <_fseek_r+0x224>
 9080f24:	8080030b 	ldhu	r2,12(r16)
 9080f28:	00c04204 	movi	r3,264
 9080f2c:	1080420c 	andi	r2,r2,264
 9080f30:	10c07926 	beq	r2,r3,9081118 <_fseek_r+0x238>
 9080f34:	85400a17 	ldw	r21,40(r16)
 9080f38:	a800ea26 	beq	r21,zero,90812e4 <_fseek_r+0x404>
 9080f3c:	00800044 	movi	r2,1
 9080f40:	98805f26 	beq	r19,r2,90810c0 <_fseek_r+0x1e0>
 9080f44:	00800084 	movi	r2,2
 9080f48:	98801026 	beq	r19,r2,9080f8c <_fseek_r+0xac>
 9080f4c:	98000f26 	beq	r19,zero,9080f8c <_fseek_r+0xac>
 9080f50:	00800584 	movi	r2,22
 9080f54:	013fffc4 	movi	r4,-1
 9080f58:	90800015 	stw	r2,0(r18)
 9080f5c:	2005883a 	mov	r2,r4
 9080f60:	dfc01717 	ldw	ra,92(sp)
 9080f64:	ddc01617 	ldw	r23,88(sp)
 9080f68:	dd801517 	ldw	r22,84(sp)
 9080f6c:	dd401417 	ldw	r21,80(sp)
 9080f70:	dd001317 	ldw	r20,76(sp)
 9080f74:	dcc01217 	ldw	r19,72(sp)
 9080f78:	dc801117 	ldw	r18,68(sp)
 9080f7c:	dc401017 	ldw	r17,64(sp)
 9080f80:	dc000f17 	ldw	r16,60(sp)
 9080f84:	dec01804 	addi	sp,sp,96
 9080f88:	f800283a 	ret
 9080f8c:	81800417 	ldw	r6,16(r16)
 9080f90:	0023883a 	mov	r17,zero
 9080f94:	002f883a 	mov	r23,zero
 9080f98:	3000a626 	beq	r6,zero,9081234 <_fseek_r+0x354>
 9080f9c:	8100030b 	ldhu	r4,12(r16)
 9080fa0:	2082068c 	andi	r2,r4,2074
 9080fa4:	1000081e 	bne	r2,zero,9080fc8 <_fseek_r+0xe8>
 9080fa8:	2081000c 	andi	r2,r4,1024
 9080fac:	10001b1e 	bne	r2,zero,908101c <_fseek_r+0x13c>
 9080fb0:	00824234 	movhi	r2,2312
 9080fb4:	1088c004 	addi	r2,r2,8960
 9080fb8:	a8800926 	beq	r21,r2,9080fe0 <_fseek_r+0x100>
 9080fbc:	8080030b 	ldhu	r2,12(r16)
 9080fc0:	10820014 	ori	r2,r2,2048
 9080fc4:	8080030d 	sth	r2,12(r16)
 9080fc8:	9009883a 	mov	r4,r18
 9080fcc:	800b883a 	mov	r5,r16
 9080fd0:	90804a00 	call	90804a0 <_fflush_r>
 9080fd4:	1000a326 	beq	r2,zero,9081264 <_fseek_r+0x384>
 9080fd8:	013fffc4 	movi	r4,-1
 9080fdc:	003fdf06 	br	9080f5c <_fseek_r+0x7c>
 9080fe0:	8140038f 	ldh	r5,14(r16)
 9080fe4:	283ff516 	blt	r5,zero,9080fbc <_fseek_r+0xdc>
 9080fe8:	9009883a 	mov	r4,r18
 9080fec:	d80d883a 	mov	r6,sp
 9080ff0:	90813400 	call	9081340 <_fstat_r>
 9080ff4:	103ff11e 	bne	r2,zero,9080fbc <_fseek_r+0xdc>
 9080ff8:	d8800117 	ldw	r2,4(sp)
 9080ffc:	00e00014 	movui	r3,32768
 9081000:	10bc000c 	andi	r2,r2,61440
 9081004:	10ffed1e 	bne	r2,r3,9080fbc <_fseek_r+0xdc>
 9081008:	80c0030b 	ldhu	r3,12(r16)
 908100c:	00810004 	movi	r2,1024
 9081010:	80801315 	stw	r2,76(r16)
 9081014:	1886b03a 	or	r3,r3,r2
 9081018:	80c0030d 	sth	r3,12(r16)
 908101c:	9800701e 	bne	r19,zero,90811e0 <_fseek_r+0x300>
 9081020:	b029883a 	mov	r20,r22
 9081024:	b804c03a 	cmpne	r2,r23,zero
 9081028:	10003f1e 	bne	r2,zero,9081128 <_fseek_r+0x248>
 908102c:	8100030b 	ldhu	r4,12(r16)
 9081030:	2084000c 	andi	r2,r4,4096
 9081034:	1000a126 	beq	r2,zero,90812bc <_fseek_r+0x3dc>
 9081038:	81801417 	ldw	r6,80(r16)
 908103c:	80c00117 	ldw	r3,4(r16)
 9081040:	81400c17 	ldw	r5,48(r16)
 9081044:	30e3c83a 	sub	r17,r6,r3
 9081048:	28008026 	beq	r5,zero,908124c <_fseek_r+0x36c>
 908104c:	81c00f17 	ldw	r7,60(r16)
 9081050:	89e3c83a 	sub	r17,r17,r7
 9081054:	80800e17 	ldw	r2,56(r16)
 9081058:	81800417 	ldw	r6,16(r16)
 908105c:	88c7883a 	add	r3,r17,r3
 9081060:	1185c83a 	sub	r2,r2,r6
 9081064:	11cf883a 	add	r7,r2,r7
 9081068:	1887c83a 	sub	r3,r3,r2
 908106c:	2088000c 	andi	r2,r4,8192
 9081070:	10003e1e 	bne	r2,zero,908116c <_fseek_r+0x28c>
 9081074:	a0c03d16 	blt	r20,r3,908116c <_fseek_r+0x28c>
 9081078:	38c5883a 	add	r2,r7,r3
 908107c:	a0803b2e 	bgeu	r20,r2,908116c <_fseek_r+0x28c>
 9081080:	a0c5c83a 	sub	r2,r20,r3
 9081084:	3887c83a 	sub	r3,r7,r2
 9081088:	3085883a 	add	r2,r6,r2
 908108c:	80800015 	stw	r2,0(r16)
 9081090:	80c00115 	stw	r3,4(r16)
 9081094:	28000526 	beq	r5,zero,90810ac <_fseek_r+0x1cc>
 9081098:	80801004 	addi	r2,r16,64
 908109c:	28800226 	beq	r5,r2,90810a8 <_fseek_r+0x1c8>
 90810a0:	9009883a 	mov	r4,r18
 90810a4:	9080bcc0 	call	9080bcc <_free_r>
 90810a8:	80000c15 	stw	zero,48(r16)
 90810ac:	8080030b 	ldhu	r2,12(r16)
 90810b0:	0009883a 	mov	r4,zero
 90810b4:	10bff7cc 	andi	r2,r2,65503
 90810b8:	8080030d 	sth	r2,12(r16)
 90810bc:	003fa706 	br	9080f5c <_fseek_r+0x7c>
 90810c0:	9009883a 	mov	r4,r18
 90810c4:	800b883a 	mov	r5,r16
 90810c8:	90804a00 	call	90804a0 <_fflush_r>
 90810cc:	8100030b 	ldhu	r4,12(r16)
 90810d0:	2084000c 	andi	r2,r4,4096
 90810d4:	10008726 	beq	r2,zero,90812f4 <_fseek_r+0x414>
 90810d8:	84401417 	ldw	r17,80(r16)
 90810dc:	2080010c 	andi	r2,r4,4
 90810e0:	1000171e 	bne	r2,zero,9081140 <_fseek_r+0x260>
 90810e4:	2080020c 	andi	r2,r4,8
 90810e8:	10003b26 	beq	r2,zero,90811d8 <_fseek_r+0x2f8>
 90810ec:	80800017 	ldw	r2,0(r16)
 90810f0:	10003926 	beq	r2,zero,90811d8 <_fseek_r+0x2f8>
 90810f4:	81800417 	ldw	r6,16(r16)
 90810f8:	1185c83a 	sub	r2,r2,r6
 90810fc:	88a3883a 	add	r17,r17,r2
 9081100:	00001606 	br	908115c <_fseek_r+0x27c>
 9081104:	90807380 	call	9080738 <__sinit>
 9081108:	8080030b 	ldhu	r2,12(r16)
 908110c:	00c04204 	movi	r3,264
 9081110:	1080420c 	andi	r2,r2,264
 9081114:	10ff871e 	bne	r2,r3,9080f34 <_fseek_r+0x54>
 9081118:	9009883a 	mov	r4,r18
 908111c:	800b883a 	mov	r5,r16
 9081120:	90804a00 	call	90804a0 <_fflush_r>
 9081124:	003f8306 	br	9080f34 <_fseek_r+0x54>
 9081128:	81400c17 	ldw	r5,48(r16)
 908112c:	28004526 	beq	r5,zero,9081244 <_fseek_r+0x364>
 9081130:	8100030b 	ldhu	r4,12(r16)
 9081134:	80c00117 	ldw	r3,4(r16)
 9081138:	81c00f17 	ldw	r7,60(r16)
 908113c:	003fc506 	br	9081054 <_fseek_r+0x174>
 9081140:	80c00117 	ldw	r3,4(r16)
 9081144:	80800c17 	ldw	r2,48(r16)
 9081148:	88e3c83a 	sub	r17,r17,r3
 908114c:	10002226 	beq	r2,zero,90811d8 <_fseek_r+0x2f8>
 9081150:	81c00f17 	ldw	r7,60(r16)
 9081154:	81800417 	ldw	r6,16(r16)
 9081158:	89e3c83a 	sub	r17,r17,r7
 908115c:	b46d883a 	add	r22,r22,r17
 9081160:	0027883a 	mov	r19,zero
 9081164:	05c00044 	movi	r23,1
 9081168:	003f8b06 	br	9080f98 <_fseek_r+0xb8>
 908116c:	80801317 	ldw	r2,76(r16)
 9081170:	81400717 	ldw	r5,28(r16)
 9081174:	9009883a 	mov	r4,r18
 9081178:	0085c83a 	sub	r2,zero,r2
 908117c:	a0a2703a 	and	r17,r20,r2
 9081180:	880d883a 	mov	r6,r17
 9081184:	000f883a 	mov	r7,zero
 9081188:	a83ee83a 	callr	r21
 908118c:	00ffffc4 	movi	r3,-1
 9081190:	10ff8d26 	beq	r2,r3,9080fc8 <_fseek_r+0xe8>
 9081194:	80800417 	ldw	r2,16(r16)
 9081198:	81400c17 	ldw	r5,48(r16)
 908119c:	80000115 	stw	zero,4(r16)
 90811a0:	80800015 	stw	r2,0(r16)
 90811a4:	28000526 	beq	r5,zero,90811bc <_fseek_r+0x2dc>
 90811a8:	80801004 	addi	r2,r16,64
 90811ac:	28800226 	beq	r5,r2,90811b8 <_fseek_r+0x2d8>
 90811b0:	9009883a 	mov	r4,r18
 90811b4:	9080bcc0 	call	9080bcc <_free_r>
 90811b8:	80000c15 	stw	zero,48(r16)
 90811bc:	8080030b 	ldhu	r2,12(r16)
 90811c0:	a463c83a 	sub	r17,r20,r17
 90811c4:	10bff7cc 	andi	r2,r2,65503
 90811c8:	8080030d 	sth	r2,12(r16)
 90811cc:	88000c1e 	bne	r17,zero,9081200 <_fseek_r+0x320>
 90811d0:	0009883a 	mov	r4,zero
 90811d4:	003f6106 	br	9080f5c <_fseek_r+0x7c>
 90811d8:	81800417 	ldw	r6,16(r16)
 90811dc:	003fdf06 	br	908115c <_fseek_r+0x27c>
 90811e0:	8140038f 	ldh	r5,14(r16)
 90811e4:	9009883a 	mov	r4,r18
 90811e8:	d80d883a 	mov	r6,sp
 90811ec:	90813400 	call	9081340 <_fstat_r>
 90811f0:	103f751e 	bne	r2,zero,9080fc8 <_fseek_r+0xe8>
 90811f4:	d8800417 	ldw	r2,16(sp)
 90811f8:	b0a9883a 	add	r20,r22,r2
 90811fc:	003f8906 	br	9081024 <_fseek_r+0x144>
 9081200:	9009883a 	mov	r4,r18
 9081204:	800b883a 	mov	r5,r16
 9081208:	90820a80 	call	90820a8 <__srefill_r>
 908120c:	103f6e1e 	bne	r2,zero,9080fc8 <_fseek_r+0xe8>
 9081210:	80c00117 	ldw	r3,4(r16)
 9081214:	1c7f6c36 	bltu	r3,r17,9080fc8 <_fseek_r+0xe8>
 9081218:	80800017 	ldw	r2,0(r16)
 908121c:	1c47c83a 	sub	r3,r3,r17
 9081220:	0009883a 	mov	r4,zero
 9081224:	1445883a 	add	r2,r2,r17
 9081228:	80c00115 	stw	r3,4(r16)
 908122c:	80800015 	stw	r2,0(r16)
 9081230:	003f4a06 	br	9080f5c <_fseek_r+0x7c>
 9081234:	9009883a 	mov	r4,r18
 9081238:	800b883a 	mov	r5,r16
 908123c:	90816100 	call	9081610 <__smakebuf_r>
 9081240:	003f5606 	br	9080f9c <_fseek_r+0xbc>
 9081244:	8100030b 	ldhu	r4,12(r16)
 9081248:	80c00117 	ldw	r3,4(r16)
 908124c:	80800017 	ldw	r2,0(r16)
 9081250:	81800417 	ldw	r6,16(r16)
 9081254:	1185c83a 	sub	r2,r2,r6
 9081258:	10cf883a 	add	r7,r2,r3
 908125c:	8887c83a 	sub	r3,r17,r2
 9081260:	003f8206 	br	908106c <_fseek_r+0x18c>
 9081264:	81400717 	ldw	r5,28(r16)
 9081268:	b00d883a 	mov	r6,r22
 908126c:	980f883a 	mov	r7,r19
 9081270:	9009883a 	mov	r4,r18
 9081274:	a83ee83a 	callr	r21
 9081278:	00ffffc4 	movi	r3,-1
 908127c:	10ff5626 	beq	r2,r3,9080fd8 <_fseek_r+0xf8>
 9081280:	81400c17 	ldw	r5,48(r16)
 9081284:	28000526 	beq	r5,zero,908129c <_fseek_r+0x3bc>
 9081288:	80801004 	addi	r2,r16,64
 908128c:	28800226 	beq	r5,r2,9081298 <_fseek_r+0x3b8>
 9081290:	9009883a 	mov	r4,r18
 9081294:	9080bcc0 	call	9080bcc <_free_r>
 9081298:	80000c15 	stw	zero,48(r16)
 908129c:	8080030b 	ldhu	r2,12(r16)
 90812a0:	80c00417 	ldw	r3,16(r16)
 90812a4:	0009883a 	mov	r4,zero
 90812a8:	10bdf7cc 	andi	r2,r2,63455
 90812ac:	8080030d 	sth	r2,12(r16)
 90812b0:	80c00015 	stw	r3,0(r16)
 90812b4:	80000115 	stw	zero,4(r16)
 90812b8:	003f2806 	br	9080f5c <_fseek_r+0x7c>
 90812bc:	81400717 	ldw	r5,28(r16)
 90812c0:	000d883a 	mov	r6,zero
 90812c4:	9009883a 	mov	r4,r18
 90812c8:	01c00044 	movi	r7,1
 90812cc:	a83ee83a 	callr	r21
 90812d0:	100d883a 	mov	r6,r2
 90812d4:	00bfffc4 	movi	r2,-1
 90812d8:	30bf3b26 	beq	r6,r2,9080fc8 <_fseek_r+0xe8>
 90812dc:	8100030b 	ldhu	r4,12(r16)
 90812e0:	003f5606 	br	908103c <_fseek_r+0x15c>
 90812e4:	00800744 	movi	r2,29
 90812e8:	013fffc4 	movi	r4,-1
 90812ec:	90800015 	stw	r2,0(r18)
 90812f0:	003f1a06 	br	9080f5c <_fseek_r+0x7c>
 90812f4:	81400717 	ldw	r5,28(r16)
 90812f8:	980f883a 	mov	r7,r19
 90812fc:	9009883a 	mov	r4,r18
 9081300:	000d883a 	mov	r6,zero
 9081304:	a83ee83a 	callr	r21
 9081308:	1023883a 	mov	r17,r2
 908130c:	00bfffc4 	movi	r2,-1
 9081310:	88bf3126 	beq	r17,r2,9080fd8 <_fseek_r+0xf8>
 9081314:	8100030b 	ldhu	r4,12(r16)
 9081318:	003f7006 	br	90810dc <_fseek_r+0x1fc>

0908131c <fseek>:
 908131c:	00824274 	movhi	r2,2313
 9081320:	10b17b04 	addi	r2,r2,-14868
 9081324:	2013883a 	mov	r9,r4
 9081328:	11000017 	ldw	r4,0(r2)
 908132c:	2805883a 	mov	r2,r5
 9081330:	300f883a 	mov	r7,r6
 9081334:	480b883a 	mov	r5,r9
 9081338:	100d883a 	mov	r6,r2
 908133c:	9080ee01 	jmpi	9080ee0 <_fseek_r>

09081340 <_fstat_r>:
 9081340:	defffd04 	addi	sp,sp,-12
 9081344:	dc000015 	stw	r16,0(sp)
 9081348:	04024274 	movhi	r16,2313
 908134c:	84318f04 	addi	r16,r16,-14788
 9081350:	dc400115 	stw	r17,4(sp)
 9081354:	80000015 	stw	zero,0(r16)
 9081358:	2023883a 	mov	r17,r4
 908135c:	2809883a 	mov	r4,r5
 9081360:	300b883a 	mov	r5,r6
 9081364:	dfc00215 	stw	ra,8(sp)
 9081368:	90838a40 	call	90838a4 <fstat>
 908136c:	1007883a 	mov	r3,r2
 9081370:	00bfffc4 	movi	r2,-1
 9081374:	18800626 	beq	r3,r2,9081390 <_fstat_r+0x50>
 9081378:	1805883a 	mov	r2,r3
 908137c:	dfc00217 	ldw	ra,8(sp)
 9081380:	dc400117 	ldw	r17,4(sp)
 9081384:	dc000017 	ldw	r16,0(sp)
 9081388:	dec00304 	addi	sp,sp,12
 908138c:	f800283a 	ret
 9081390:	80800017 	ldw	r2,0(r16)
 9081394:	103ff826 	beq	r2,zero,9081378 <_fstat_r+0x38>
 9081398:	88800015 	stw	r2,0(r17)
 908139c:	1805883a 	mov	r2,r3
 90813a0:	dfc00217 	ldw	ra,8(sp)
 90813a4:	dc400117 	ldw	r17,4(sp)
 90813a8:	dc000017 	ldw	r16,0(sp)
 90813ac:	dec00304 	addi	sp,sp,12
 90813b0:	f800283a 	ret

090813b4 <_fwalk_reent>:
 90813b4:	defff704 	addi	sp,sp,-36
 90813b8:	dcc00315 	stw	r19,12(sp)
 90813bc:	24c0b804 	addi	r19,r4,736
 90813c0:	dd800615 	stw	r22,24(sp)
 90813c4:	dd400515 	stw	r21,20(sp)
 90813c8:	dfc00815 	stw	ra,32(sp)
 90813cc:	ddc00715 	stw	r23,28(sp)
 90813d0:	dd000415 	stw	r20,16(sp)
 90813d4:	dc800215 	stw	r18,8(sp)
 90813d8:	dc400115 	stw	r17,4(sp)
 90813dc:	dc000015 	stw	r16,0(sp)
 90813e0:	202b883a 	mov	r21,r4
 90813e4:	282d883a 	mov	r22,r5
 90813e8:	90807280 	call	9080728 <__sfp_lock_acquire>
 90813ec:	98002126 	beq	r19,zero,9081474 <_fwalk_reent+0xc0>
 90813f0:	002f883a 	mov	r23,zero
 90813f4:	9c800117 	ldw	r18,4(r19)
 90813f8:	9c000217 	ldw	r16,8(r19)
 90813fc:	90bfffc4 	addi	r2,r18,-1
 9081400:	10000d16 	blt	r2,zero,9081438 <_fwalk_reent+0x84>
 9081404:	0023883a 	mov	r17,zero
 9081408:	053fffc4 	movi	r20,-1
 908140c:	8080030f 	ldh	r2,12(r16)
 9081410:	8c400044 	addi	r17,r17,1
 9081414:	10000626 	beq	r2,zero,9081430 <_fwalk_reent+0x7c>
 9081418:	8080038f 	ldh	r2,14(r16)
 908141c:	800b883a 	mov	r5,r16
 9081420:	a809883a 	mov	r4,r21
 9081424:	15000226 	beq	r2,r20,9081430 <_fwalk_reent+0x7c>
 9081428:	b03ee83a 	callr	r22
 908142c:	b8aeb03a 	or	r23,r23,r2
 9081430:	84001704 	addi	r16,r16,92
 9081434:	947ff51e 	bne	r18,r17,908140c <_fwalk_reent+0x58>
 9081438:	9cc00017 	ldw	r19,0(r19)
 908143c:	983fed1e 	bne	r19,zero,90813f4 <_fwalk_reent+0x40>
 9081440:	908072c0 	call	908072c <__sfp_lock_release>
 9081444:	b805883a 	mov	r2,r23
 9081448:	dfc00817 	ldw	ra,32(sp)
 908144c:	ddc00717 	ldw	r23,28(sp)
 9081450:	dd800617 	ldw	r22,24(sp)
 9081454:	dd400517 	ldw	r21,20(sp)
 9081458:	dd000417 	ldw	r20,16(sp)
 908145c:	dcc00317 	ldw	r19,12(sp)
 9081460:	dc800217 	ldw	r18,8(sp)
 9081464:	dc400117 	ldw	r17,4(sp)
 9081468:	dc000017 	ldw	r16,0(sp)
 908146c:	dec00904 	addi	sp,sp,36
 9081470:	f800283a 	ret
 9081474:	002f883a 	mov	r23,zero
 9081478:	003ff106 	br	9081440 <_fwalk_reent+0x8c>

0908147c <_fwalk>:
 908147c:	defff804 	addi	sp,sp,-32
 9081480:	dcc00315 	stw	r19,12(sp)
 9081484:	24c0b804 	addi	r19,r4,736
 9081488:	dd400515 	stw	r21,20(sp)
 908148c:	dfc00715 	stw	ra,28(sp)
 9081490:	dd800615 	stw	r22,24(sp)
 9081494:	dd000415 	stw	r20,16(sp)
 9081498:	dc800215 	stw	r18,8(sp)
 908149c:	dc400115 	stw	r17,4(sp)
 90814a0:	dc000015 	stw	r16,0(sp)
 90814a4:	282b883a 	mov	r21,r5
 90814a8:	90807280 	call	9080728 <__sfp_lock_acquire>
 90814ac:	98001f26 	beq	r19,zero,908152c <_fwalk+0xb0>
 90814b0:	002d883a 	mov	r22,zero
 90814b4:	9c800117 	ldw	r18,4(r19)
 90814b8:	9c000217 	ldw	r16,8(r19)
 90814bc:	90bfffc4 	addi	r2,r18,-1
 90814c0:	10000c16 	blt	r2,zero,90814f4 <_fwalk+0x78>
 90814c4:	0023883a 	mov	r17,zero
 90814c8:	053fffc4 	movi	r20,-1
 90814cc:	8080030f 	ldh	r2,12(r16)
 90814d0:	8c400044 	addi	r17,r17,1
 90814d4:	10000526 	beq	r2,zero,90814ec <_fwalk+0x70>
 90814d8:	8080038f 	ldh	r2,14(r16)
 90814dc:	8009883a 	mov	r4,r16
 90814e0:	15000226 	beq	r2,r20,90814ec <_fwalk+0x70>
 90814e4:	a83ee83a 	callr	r21
 90814e8:	b0acb03a 	or	r22,r22,r2
 90814ec:	84001704 	addi	r16,r16,92
 90814f0:	947ff61e 	bne	r18,r17,90814cc <_fwalk+0x50>
 90814f4:	9cc00017 	ldw	r19,0(r19)
 90814f8:	983fee1e 	bne	r19,zero,90814b4 <_fwalk+0x38>
 90814fc:	908072c0 	call	908072c <__sfp_lock_release>
 9081500:	b005883a 	mov	r2,r22
 9081504:	dfc00717 	ldw	ra,28(sp)
 9081508:	dd800617 	ldw	r22,24(sp)
 908150c:	dd400517 	ldw	r21,20(sp)
 9081510:	dd000417 	ldw	r20,16(sp)
 9081514:	dcc00317 	ldw	r19,12(sp)
 9081518:	dc800217 	ldw	r18,8(sp)
 908151c:	dc400117 	ldw	r17,4(sp)
 9081520:	dc000017 	ldw	r16,0(sp)
 9081524:	dec00804 	addi	sp,sp,32
 9081528:	f800283a 	ret
 908152c:	002d883a 	mov	r22,zero
 9081530:	003ff206 	br	90814fc <_fwalk+0x80>

09081534 <_fwrite_r>:
 9081534:	defff604 	addi	sp,sp,-40
 9081538:	dc400615 	stw	r17,24(sp)
 908153c:	39a3383a 	mul	r17,r7,r6
 9081540:	00800044 	movi	r2,1
 9081544:	dcc00815 	stw	r19,32(sp)
 9081548:	dc800715 	stw	r18,28(sp)
 908154c:	dc000515 	stw	r16,20(sp)
 9081550:	dfc00915 	stw	ra,36(sp)
 9081554:	3825883a 	mov	r18,r7
 9081558:	3027883a 	mov	r19,r6
 908155c:	2021883a 	mov	r16,r4
 9081560:	d9400015 	stw	r5,0(sp)
 9081564:	d8800315 	stw	r2,12(sp)
 9081568:	dc400115 	stw	r17,4(sp)
 908156c:	dc400415 	stw	r17,16(sp)
 9081570:	dec00215 	stw	sp,8(sp)
 9081574:	20000226 	beq	r4,zero,9081580 <_fwrite_r+0x4c>
 9081578:	20800e17 	ldw	r2,56(r4)
 908157c:	10001226 	beq	r2,zero,90815c8 <_fwrite_r+0x94>
 9081580:	d9400a17 	ldw	r5,40(sp)
 9081584:	8009883a 	mov	r4,r16
 9081588:	d9800204 	addi	r6,sp,8
 908158c:	90826400 	call	9082640 <__sfvwrite_r>
 9081590:	980b883a 	mov	r5,r19
 9081594:	10000426 	beq	r2,zero,90815a8 <_fwrite_r+0x74>
 9081598:	d9000417 	ldw	r4,16(sp)
 908159c:	8909c83a 	sub	r4,r17,r4
 90815a0:	908370c0 	call	908370c <__udivsi3>
 90815a4:	1025883a 	mov	r18,r2
 90815a8:	9005883a 	mov	r2,r18
 90815ac:	dfc00917 	ldw	ra,36(sp)
 90815b0:	dcc00817 	ldw	r19,32(sp)
 90815b4:	dc800717 	ldw	r18,28(sp)
 90815b8:	dc400617 	ldw	r17,24(sp)
 90815bc:	dc000517 	ldw	r16,20(sp)
 90815c0:	dec00a04 	addi	sp,sp,40
 90815c4:	f800283a 	ret
 90815c8:	90807380 	call	9080738 <__sinit>
 90815cc:	003fec06 	br	9081580 <_fwrite_r+0x4c>

090815d0 <fwrite>:
 90815d0:	00824274 	movhi	r2,2313
 90815d4:	10b17b04 	addi	r2,r2,-14868
 90815d8:	2017883a 	mov	r11,r4
 90815dc:	11000017 	ldw	r4,0(r2)
 90815e0:	defffe04 	addi	sp,sp,-8
 90815e4:	3013883a 	mov	r9,r6
 90815e8:	2805883a 	mov	r2,r5
 90815ec:	d9c00015 	stw	r7,0(sp)
 90815f0:	580b883a 	mov	r5,r11
 90815f4:	100d883a 	mov	r6,r2
 90815f8:	480f883a 	mov	r7,r9
 90815fc:	dfc00115 	stw	ra,4(sp)
 9081600:	90815340 	call	9081534 <_fwrite_r>
 9081604:	dfc00117 	ldw	ra,4(sp)
 9081608:	dec00204 	addi	sp,sp,8
 908160c:	f800283a 	ret

09081610 <__smakebuf_r>:
 9081610:	2880030b 	ldhu	r2,12(r5)
 9081614:	deffed04 	addi	sp,sp,-76
 9081618:	dc401015 	stw	r17,64(sp)
 908161c:	1080008c 	andi	r2,r2,2
 9081620:	dc000f15 	stw	r16,60(sp)
 9081624:	dfc01215 	stw	ra,72(sp)
 9081628:	dc801115 	stw	r18,68(sp)
 908162c:	2821883a 	mov	r16,r5
 9081630:	2023883a 	mov	r17,r4
 9081634:	10000b26 	beq	r2,zero,9081664 <__smakebuf_r+0x54>
 9081638:	28c010c4 	addi	r3,r5,67
 908163c:	00800044 	movi	r2,1
 9081640:	28800515 	stw	r2,20(r5)
 9081644:	28c00415 	stw	r3,16(r5)
 9081648:	28c00015 	stw	r3,0(r5)
 908164c:	dfc01217 	ldw	ra,72(sp)
 9081650:	dc801117 	ldw	r18,68(sp)
 9081654:	dc401017 	ldw	r17,64(sp)
 9081658:	dc000f17 	ldw	r16,60(sp)
 908165c:	dec01304 	addi	sp,sp,76
 9081660:	f800283a 	ret
 9081664:	2940038f 	ldh	r5,14(r5)
 9081668:	28002116 	blt	r5,zero,90816f0 <__smakebuf_r+0xe0>
 908166c:	d80d883a 	mov	r6,sp
 9081670:	90813400 	call	9081340 <_fstat_r>
 9081674:	10001e16 	blt	r2,zero,90816f0 <__smakebuf_r+0xe0>
 9081678:	d8800117 	ldw	r2,4(sp)
 908167c:	00e00014 	movui	r3,32768
 9081680:	113c000c 	andi	r4,r2,61440
 9081684:	20c03126 	beq	r4,r3,908174c <__smakebuf_r+0x13c>
 9081688:	8080030b 	ldhu	r2,12(r16)
 908168c:	00c80004 	movi	r3,8192
 9081690:	10820014 	ori	r2,r2,2048
 9081694:	8080030d 	sth	r2,12(r16)
 9081698:	20c01e26 	beq	r4,r3,9081714 <__smakebuf_r+0x104>
 908169c:	04810004 	movi	r18,1024
 90816a0:	8809883a 	mov	r4,r17
 90816a4:	900b883a 	mov	r5,r18
 90816a8:	90817a40 	call	90817a4 <_malloc_r>
 90816ac:	1009883a 	mov	r4,r2
 90816b0:	10003126 	beq	r2,zero,9081778 <__smakebuf_r+0x168>
 90816b4:	80c0030b 	ldhu	r3,12(r16)
 90816b8:	00824234 	movhi	r2,2312
 90816bc:	10820704 	addi	r2,r2,2076
 90816c0:	88800f15 	stw	r2,60(r17)
 90816c4:	18c02014 	ori	r3,r3,128
 90816c8:	84800515 	stw	r18,20(r16)
 90816cc:	80c0030d 	sth	r3,12(r16)
 90816d0:	81000415 	stw	r4,16(r16)
 90816d4:	81000015 	stw	r4,0(r16)
 90816d8:	dfc01217 	ldw	ra,72(sp)
 90816dc:	dc801117 	ldw	r18,68(sp)
 90816e0:	dc401017 	ldw	r17,64(sp)
 90816e4:	dc000f17 	ldw	r16,60(sp)
 90816e8:	dec01304 	addi	sp,sp,76
 90816ec:	f800283a 	ret
 90816f0:	80c0030b 	ldhu	r3,12(r16)
 90816f4:	1880200c 	andi	r2,r3,128
 90816f8:	10000426 	beq	r2,zero,908170c <__smakebuf_r+0xfc>
 90816fc:	04801004 	movi	r18,64
 9081700:	18820014 	ori	r2,r3,2048
 9081704:	8080030d 	sth	r2,12(r16)
 9081708:	003fe506 	br	90816a0 <__smakebuf_r+0x90>
 908170c:	04810004 	movi	r18,1024
 9081710:	003ffb06 	br	9081700 <__smakebuf_r+0xf0>
 9081714:	8140038f 	ldh	r5,14(r16)
 9081718:	8809883a 	mov	r4,r17
 908171c:	9082adc0 	call	9082adc <_isatty_r>
 9081720:	103fde26 	beq	r2,zero,908169c <__smakebuf_r+0x8c>
 9081724:	8080030b 	ldhu	r2,12(r16)
 9081728:	80c010c4 	addi	r3,r16,67
 908172c:	04810004 	movi	r18,1024
 9081730:	10800054 	ori	r2,r2,1
 9081734:	8080030d 	sth	r2,12(r16)
 9081738:	00800044 	movi	r2,1
 908173c:	80c00415 	stw	r3,16(r16)
 9081740:	80800515 	stw	r2,20(r16)
 9081744:	80c00015 	stw	r3,0(r16)
 9081748:	003fd506 	br	90816a0 <__smakebuf_r+0x90>
 908174c:	80c00a17 	ldw	r3,40(r16)
 9081750:	00824234 	movhi	r2,2312
 9081754:	1088c004 	addi	r2,r2,8960
 9081758:	18bfcb1e 	bne	r3,r2,9081688 <__smakebuf_r+0x78>
 908175c:	8080030b 	ldhu	r2,12(r16)
 9081760:	00c10004 	movi	r3,1024
 9081764:	1825883a 	mov	r18,r3
 9081768:	10c4b03a 	or	r2,r2,r3
 908176c:	8080030d 	sth	r2,12(r16)
 9081770:	80c01315 	stw	r3,76(r16)
 9081774:	003fca06 	br	90816a0 <__smakebuf_r+0x90>
 9081778:	8100030b 	ldhu	r4,12(r16)
 908177c:	2080800c 	andi	r2,r4,512
 9081780:	103fb21e 	bne	r2,zero,908164c <__smakebuf_r+0x3c>
 9081784:	80c010c4 	addi	r3,r16,67
 9081788:	21000094 	ori	r4,r4,2
 908178c:	00800044 	movi	r2,1
 9081790:	80800515 	stw	r2,20(r16)
 9081794:	8100030d 	sth	r4,12(r16)
 9081798:	80c00415 	stw	r3,16(r16)
 908179c:	80c00015 	stw	r3,0(r16)
 90817a0:	003faa06 	br	908164c <__smakebuf_r+0x3c>

090817a4 <_malloc_r>:
 90817a4:	defff604 	addi	sp,sp,-40
 90817a8:	28c002c4 	addi	r3,r5,11
 90817ac:	00800584 	movi	r2,22
 90817b0:	dc800215 	stw	r18,8(sp)
 90817b4:	dfc00915 	stw	ra,36(sp)
 90817b8:	df000815 	stw	fp,32(sp)
 90817bc:	ddc00715 	stw	r23,28(sp)
 90817c0:	dd800615 	stw	r22,24(sp)
 90817c4:	dd400515 	stw	r21,20(sp)
 90817c8:	dd000415 	stw	r20,16(sp)
 90817cc:	dcc00315 	stw	r19,12(sp)
 90817d0:	dc400115 	stw	r17,4(sp)
 90817d4:	dc000015 	stw	r16,0(sp)
 90817d8:	2025883a 	mov	r18,r4
 90817dc:	10c01236 	bltu	r2,r3,9081828 <_malloc_r+0x84>
 90817e0:	04400404 	movi	r17,16
 90817e4:	8940142e 	bgeu	r17,r5,9081838 <_malloc_r+0x94>
 90817e8:	00800304 	movi	r2,12
 90817ec:	0007883a 	mov	r3,zero
 90817f0:	90800015 	stw	r2,0(r18)
 90817f4:	1805883a 	mov	r2,r3
 90817f8:	dfc00917 	ldw	ra,36(sp)
 90817fc:	df000817 	ldw	fp,32(sp)
 9081800:	ddc00717 	ldw	r23,28(sp)
 9081804:	dd800617 	ldw	r22,24(sp)
 9081808:	dd400517 	ldw	r21,20(sp)
 908180c:	dd000417 	ldw	r20,16(sp)
 9081810:	dcc00317 	ldw	r19,12(sp)
 9081814:	dc800217 	ldw	r18,8(sp)
 9081818:	dc400117 	ldw	r17,4(sp)
 908181c:	dc000017 	ldw	r16,0(sp)
 9081820:	dec00a04 	addi	sp,sp,40
 9081824:	f800283a 	ret
 9081828:	00bffe04 	movi	r2,-8
 908182c:	18a2703a 	and	r17,r3,r2
 9081830:	883fed16 	blt	r17,zero,90817e8 <_malloc_r+0x44>
 9081834:	897fec36 	bltu	r17,r5,90817e8 <_malloc_r+0x44>
 9081838:	9009883a 	mov	r4,r18
 908183c:	9083cb40 	call	9083cb4 <__malloc_lock>
 9081840:	00807dc4 	movi	r2,503
 9081844:	14402b2e 	bgeu	r2,r17,90818f4 <_malloc_r+0x150>
 9081848:	8806d27a 	srli	r3,r17,9
 908184c:	18003f1e 	bne	r3,zero,908194c <_malloc_r+0x1a8>
 9081850:	880cd0fa 	srli	r6,r17,3
 9081854:	300490fa 	slli	r2,r6,3
 9081858:	02c24274 	movhi	r11,2313
 908185c:	5aeb6104 	addi	r11,r11,-21116
 9081860:	12cb883a 	add	r5,r2,r11
 9081864:	2c000317 	ldw	r16,12(r5)
 9081868:	580f883a 	mov	r7,r11
 908186c:	2c00041e 	bne	r5,r16,9081880 <_malloc_r+0xdc>
 9081870:	00000a06 	br	908189c <_malloc_r+0xf8>
 9081874:	1800860e 	bge	r3,zero,9081a90 <_malloc_r+0x2ec>
 9081878:	84000317 	ldw	r16,12(r16)
 908187c:	2c000726 	beq	r5,r16,908189c <_malloc_r+0xf8>
 9081880:	80800117 	ldw	r2,4(r16)
 9081884:	00ffff04 	movi	r3,-4
 9081888:	10c8703a 	and	r4,r2,r3
 908188c:	2447c83a 	sub	r3,r4,r17
 9081890:	008003c4 	movi	r2,15
 9081894:	10fff70e 	bge	r2,r3,9081874 <_malloc_r+0xd0>
 9081898:	31bfffc4 	addi	r6,r6,-1
 908189c:	32400044 	addi	r9,r6,1
 90818a0:	02824274 	movhi	r10,2313
 90818a4:	52ab6304 	addi	r10,r10,-21108
 90818a8:	54000217 	ldw	r16,8(r10)
 90818ac:	8280a026 	beq	r16,r10,9081b30 <_malloc_r+0x38c>
 90818b0:	80800117 	ldw	r2,4(r16)
 90818b4:	00ffff04 	movi	r3,-4
 90818b8:	10ca703a 	and	r5,r2,r3
 90818bc:	2c4dc83a 	sub	r6,r5,r17
 90818c0:	008003c4 	movi	r2,15
 90818c4:	11808316 	blt	r2,r6,9081ad4 <_malloc_r+0x330>
 90818c8:	52800315 	stw	r10,12(r10)
 90818cc:	52800215 	stw	r10,8(r10)
 90818d0:	30002916 	blt	r6,zero,9081978 <_malloc_r+0x1d4>
 90818d4:	8147883a 	add	r3,r16,r5
 90818d8:	18800117 	ldw	r2,4(r3)
 90818dc:	9009883a 	mov	r4,r18
 90818e0:	10800054 	ori	r2,r2,1
 90818e4:	18800115 	stw	r2,4(r3)
 90818e8:	9083cd40 	call	9083cd4 <__malloc_unlock>
 90818ec:	80c00204 	addi	r3,r16,8
 90818f0:	003fc006 	br	90817f4 <_malloc_r+0x50>
 90818f4:	02c24274 	movhi	r11,2313
 90818f8:	5aeb6104 	addi	r11,r11,-21116
 90818fc:	8ac5883a 	add	r2,r17,r11
 9081900:	14000317 	ldw	r16,12(r2)
 9081904:	580f883a 	mov	r7,r11
 9081908:	8806d0fa 	srli	r3,r17,3
 908190c:	14006c26 	beq	r2,r16,9081ac0 <_malloc_r+0x31c>
 9081910:	80c00117 	ldw	r3,4(r16)
 9081914:	00bfff04 	movi	r2,-4
 9081918:	81800317 	ldw	r6,12(r16)
 908191c:	1886703a 	and	r3,r3,r2
 9081920:	80c7883a 	add	r3,r16,r3
 9081924:	18800117 	ldw	r2,4(r3)
 9081928:	81400217 	ldw	r5,8(r16)
 908192c:	9009883a 	mov	r4,r18
 9081930:	10800054 	ori	r2,r2,1
 9081934:	18800115 	stw	r2,4(r3)
 9081938:	31400215 	stw	r5,8(r6)
 908193c:	29800315 	stw	r6,12(r5)
 9081940:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9081944:	80c00204 	addi	r3,r16,8
 9081948:	003faa06 	br	90817f4 <_malloc_r+0x50>
 908194c:	00800104 	movi	r2,4
 9081950:	10c0052e 	bgeu	r2,r3,9081968 <_malloc_r+0x1c4>
 9081954:	00800504 	movi	r2,20
 9081958:	10c07836 	bltu	r2,r3,9081b3c <_malloc_r+0x398>
 908195c:	198016c4 	addi	r6,r3,91
 9081960:	300490fa 	slli	r2,r6,3
 9081964:	003fbc06 	br	9081858 <_malloc_r+0xb4>
 9081968:	8804d1ba 	srli	r2,r17,6
 908196c:	11800e04 	addi	r6,r2,56
 9081970:	300490fa 	slli	r2,r6,3
 9081974:	003fb806 	br	9081858 <_malloc_r+0xb4>
 9081978:	00807fc4 	movi	r2,511
 908197c:	1140bb36 	bltu	r2,r5,9081c6c <_malloc_r+0x4c8>
 9081980:	2806d0fa 	srli	r3,r5,3
 9081984:	573ffe04 	addi	fp,r10,-8
 9081988:	00800044 	movi	r2,1
 908198c:	180890fa 	slli	r4,r3,3
 9081990:	1807d0ba 	srai	r3,r3,2
 9081994:	e1c00117 	ldw	r7,4(fp)
 9081998:	5909883a 	add	r4,r11,r4
 908199c:	21400217 	ldw	r5,8(r4)
 90819a0:	10c4983a 	sll	r2,r2,r3
 90819a4:	81000315 	stw	r4,12(r16)
 90819a8:	81400215 	stw	r5,8(r16)
 90819ac:	388eb03a 	or	r7,r7,r2
 90819b0:	2c000315 	stw	r16,12(r5)
 90819b4:	24000215 	stw	r16,8(r4)
 90819b8:	e1c00115 	stw	r7,4(fp)
 90819bc:	4807883a 	mov	r3,r9
 90819c0:	4800cd16 	blt	r9,zero,9081cf8 <_malloc_r+0x554>
 90819c4:	1807d0ba 	srai	r3,r3,2
 90819c8:	00800044 	movi	r2,1
 90819cc:	10c8983a 	sll	r4,r2,r3
 90819d0:	39004436 	bltu	r7,r4,9081ae4 <_malloc_r+0x340>
 90819d4:	21c4703a 	and	r2,r4,r7
 90819d8:	10000a1e 	bne	r2,zero,9081a04 <_malloc_r+0x260>
 90819dc:	2109883a 	add	r4,r4,r4
 90819e0:	00bfff04 	movi	r2,-4
 90819e4:	4884703a 	and	r2,r9,r2
 90819e8:	3906703a 	and	r3,r7,r4
 90819ec:	12400104 	addi	r9,r2,4
 90819f0:	1800041e 	bne	r3,zero,9081a04 <_malloc_r+0x260>
 90819f4:	2109883a 	add	r4,r4,r4
 90819f8:	3904703a 	and	r2,r7,r4
 90819fc:	4a400104 	addi	r9,r9,4
 9081a00:	103ffc26 	beq	r2,zero,90819f4 <_malloc_r+0x250>
 9081a04:	480490fa 	slli	r2,r9,3
 9081a08:	4819883a 	mov	r12,r9
 9081a0c:	023fff04 	movi	r8,-4
 9081a10:	589b883a 	add	r13,r11,r2
 9081a14:	6807883a 	mov	r3,r13
 9081a18:	014003c4 	movi	r5,15
 9081a1c:	1c000317 	ldw	r16,12(r3)
 9081a20:	1c00041e 	bne	r3,r16,9081a34 <_malloc_r+0x290>
 9081a24:	0000a706 	br	9081cc4 <_malloc_r+0x520>
 9081a28:	3000ab0e 	bge	r6,zero,9081cd8 <_malloc_r+0x534>
 9081a2c:	84000317 	ldw	r16,12(r16)
 9081a30:	1c00a426 	beq	r3,r16,9081cc4 <_malloc_r+0x520>
 9081a34:	80800117 	ldw	r2,4(r16)
 9081a38:	1204703a 	and	r2,r2,r8
 9081a3c:	144dc83a 	sub	r6,r2,r17
 9081a40:	29bff90e 	bge	r5,r6,9081a28 <_malloc_r+0x284>
 9081a44:	81000317 	ldw	r4,12(r16)
 9081a48:	80c00217 	ldw	r3,8(r16)
 9081a4c:	89400054 	ori	r5,r17,1
 9081a50:	8445883a 	add	r2,r16,r17
 9081a54:	20c00215 	stw	r3,8(r4)
 9081a58:	19000315 	stw	r4,12(r3)
 9081a5c:	81400115 	stw	r5,4(r16)
 9081a60:	1187883a 	add	r3,r2,r6
 9081a64:	31000054 	ori	r4,r6,1
 9081a68:	50800315 	stw	r2,12(r10)
 9081a6c:	50800215 	stw	r2,8(r10)
 9081a70:	19800015 	stw	r6,0(r3)
 9081a74:	11000115 	stw	r4,4(r2)
 9081a78:	12800215 	stw	r10,8(r2)
 9081a7c:	12800315 	stw	r10,12(r2)
 9081a80:	9009883a 	mov	r4,r18
 9081a84:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9081a88:	80c00204 	addi	r3,r16,8
 9081a8c:	003f5906 	br	90817f4 <_malloc_r+0x50>
 9081a90:	8109883a 	add	r4,r16,r4
 9081a94:	20800117 	ldw	r2,4(r4)
 9081a98:	80c00217 	ldw	r3,8(r16)
 9081a9c:	81400317 	ldw	r5,12(r16)
 9081aa0:	10800054 	ori	r2,r2,1
 9081aa4:	20800115 	stw	r2,4(r4)
 9081aa8:	28c00215 	stw	r3,8(r5)
 9081aac:	19400315 	stw	r5,12(r3)
 9081ab0:	9009883a 	mov	r4,r18
 9081ab4:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9081ab8:	80c00204 	addi	r3,r16,8
 9081abc:	003f4d06 	br	90817f4 <_malloc_r+0x50>
 9081ac0:	80800204 	addi	r2,r16,8
 9081ac4:	14000317 	ldw	r16,12(r2)
 9081ac8:	143f911e 	bne	r2,r16,9081910 <_malloc_r+0x16c>
 9081acc:	1a400084 	addi	r9,r3,2
 9081ad0:	003f7306 	br	90818a0 <_malloc_r+0xfc>
 9081ad4:	88c00054 	ori	r3,r17,1
 9081ad8:	8445883a 	add	r2,r16,r17
 9081adc:	80c00115 	stw	r3,4(r16)
 9081ae0:	003fdf06 	br	9081a60 <_malloc_r+0x2bc>
 9081ae4:	e4000217 	ldw	r16,8(fp)
 9081ae8:	00bfff04 	movi	r2,-4
 9081aec:	80c00117 	ldw	r3,4(r16)
 9081af0:	802d883a 	mov	r22,r16
 9081af4:	18aa703a 	and	r21,r3,r2
 9081af8:	ac401636 	bltu	r21,r17,9081b54 <_malloc_r+0x3b0>
 9081afc:	ac49c83a 	sub	r4,r21,r17
 9081b00:	008003c4 	movi	r2,15
 9081b04:	1100130e 	bge	r2,r4,9081b54 <_malloc_r+0x3b0>
 9081b08:	88800054 	ori	r2,r17,1
 9081b0c:	8447883a 	add	r3,r16,r17
 9081b10:	80800115 	stw	r2,4(r16)
 9081b14:	20800054 	ori	r2,r4,1
 9081b18:	18800115 	stw	r2,4(r3)
 9081b1c:	e0c00215 	stw	r3,8(fp)
 9081b20:	9009883a 	mov	r4,r18
 9081b24:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9081b28:	80c00204 	addi	r3,r16,8
 9081b2c:	003f3106 	br	90817f4 <_malloc_r+0x50>
 9081b30:	39c00117 	ldw	r7,4(r7)
 9081b34:	573ffe04 	addi	fp,r10,-8
 9081b38:	003fa006 	br	90819bc <_malloc_r+0x218>
 9081b3c:	00801504 	movi	r2,84
 9081b40:	10c06736 	bltu	r2,r3,9081ce0 <_malloc_r+0x53c>
 9081b44:	8804d33a 	srli	r2,r17,12
 9081b48:	11801b84 	addi	r6,r2,110
 9081b4c:	300490fa 	slli	r2,r6,3
 9081b50:	003f4106 	br	9081858 <_malloc_r+0xb4>
 9081b54:	d0a01517 	ldw	r2,-32684(gp)
 9081b58:	d0e00317 	ldw	r3,-32756(gp)
 9081b5c:	053fffc4 	movi	r20,-1
 9081b60:	10800404 	addi	r2,r2,16
 9081b64:	88a7883a 	add	r19,r17,r2
 9081b68:	1d000326 	beq	r3,r20,9081b78 <_malloc_r+0x3d4>
 9081b6c:	98c3ffc4 	addi	r3,r19,4095
 9081b70:	00bc0004 	movi	r2,-4096
 9081b74:	18a6703a 	and	r19,r3,r2
 9081b78:	9009883a 	mov	r4,r18
 9081b7c:	980b883a 	mov	r5,r19
 9081b80:	90822880 	call	9082288 <_sbrk_r>
 9081b84:	1009883a 	mov	r4,r2
 9081b88:	15000426 	beq	r2,r20,9081b9c <_malloc_r+0x3f8>
 9081b8c:	854b883a 	add	r5,r16,r21
 9081b90:	1029883a 	mov	r20,r2
 9081b94:	11405a2e 	bgeu	r2,r5,9081d00 <_malloc_r+0x55c>
 9081b98:	87000c26 	beq	r16,fp,9081bcc <_malloc_r+0x428>
 9081b9c:	e4000217 	ldw	r16,8(fp)
 9081ba0:	80c00117 	ldw	r3,4(r16)
 9081ba4:	00bfff04 	movi	r2,-4
 9081ba8:	1884703a 	and	r2,r3,r2
 9081bac:	14400336 	bltu	r2,r17,9081bbc <_malloc_r+0x418>
 9081bb0:	1449c83a 	sub	r4,r2,r17
 9081bb4:	008003c4 	movi	r2,15
 9081bb8:	113fd316 	blt	r2,r4,9081b08 <_malloc_r+0x364>
 9081bbc:	9009883a 	mov	r4,r18
 9081bc0:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9081bc4:	0007883a 	mov	r3,zero
 9081bc8:	003f0a06 	br	90817f4 <_malloc_r+0x50>
 9081bcc:	05c24274 	movhi	r23,2313
 9081bd0:	bdf19904 	addi	r23,r23,-14748
 9081bd4:	b8800017 	ldw	r2,0(r23)
 9081bd8:	988d883a 	add	r6,r19,r2
 9081bdc:	b9800015 	stw	r6,0(r23)
 9081be0:	d0e00317 	ldw	r3,-32756(gp)
 9081be4:	00bfffc4 	movi	r2,-1
 9081be8:	18808e26 	beq	r3,r2,9081e24 <_malloc_r+0x680>
 9081bec:	2145c83a 	sub	r2,r4,r5
 9081bf0:	3085883a 	add	r2,r6,r2
 9081bf4:	b8800015 	stw	r2,0(r23)
 9081bf8:	20c001cc 	andi	r3,r4,7
 9081bfc:	18005f1e 	bne	r3,zero,9081d7c <_malloc_r+0x5d8>
 9081c00:	000b883a 	mov	r5,zero
 9081c04:	a4c5883a 	add	r2,r20,r19
 9081c08:	1083ffcc 	andi	r2,r2,4095
 9081c0c:	00c40004 	movi	r3,4096
 9081c10:	1887c83a 	sub	r3,r3,r2
 9081c14:	28e7883a 	add	r19,r5,r3
 9081c18:	9009883a 	mov	r4,r18
 9081c1c:	980b883a 	mov	r5,r19
 9081c20:	90822880 	call	9082288 <_sbrk_r>
 9081c24:	1007883a 	mov	r3,r2
 9081c28:	00bfffc4 	movi	r2,-1
 9081c2c:	18807a26 	beq	r3,r2,9081e18 <_malloc_r+0x674>
 9081c30:	1d05c83a 	sub	r2,r3,r20
 9081c34:	9885883a 	add	r2,r19,r2
 9081c38:	10c00054 	ori	r3,r2,1
 9081c3c:	b8800017 	ldw	r2,0(r23)
 9081c40:	a021883a 	mov	r16,r20
 9081c44:	a0c00115 	stw	r3,4(r20)
 9081c48:	9885883a 	add	r2,r19,r2
 9081c4c:	b8800015 	stw	r2,0(r23)
 9081c50:	e5000215 	stw	r20,8(fp)
 9081c54:	b7003626 	beq	r22,fp,9081d30 <_malloc_r+0x58c>
 9081c58:	018003c4 	movi	r6,15
 9081c5c:	35404b36 	bltu	r6,r21,9081d8c <_malloc_r+0x5e8>
 9081c60:	00800044 	movi	r2,1
 9081c64:	a0800115 	stw	r2,4(r20)
 9081c68:	003fcd06 	br	9081ba0 <_malloc_r+0x3fc>
 9081c6c:	2808d27a 	srli	r4,r5,9
 9081c70:	2000371e 	bne	r4,zero,9081d50 <_malloc_r+0x5ac>
 9081c74:	2808d0fa 	srli	r4,r5,3
 9081c78:	200690fa 	slli	r3,r4,3
 9081c7c:	1ad1883a 	add	r8,r3,r11
 9081c80:	41800217 	ldw	r6,8(r8)
 9081c84:	41805b26 	beq	r8,r6,9081df4 <_malloc_r+0x650>
 9081c88:	30800117 	ldw	r2,4(r6)
 9081c8c:	00ffff04 	movi	r3,-4
 9081c90:	10c4703a 	and	r2,r2,r3
 9081c94:	2880022e 	bgeu	r5,r2,9081ca0 <_malloc_r+0x4fc>
 9081c98:	31800217 	ldw	r6,8(r6)
 9081c9c:	41bffa1e 	bne	r8,r6,9081c88 <_malloc_r+0x4e4>
 9081ca0:	32000317 	ldw	r8,12(r6)
 9081ca4:	39c00117 	ldw	r7,4(r7)
 9081ca8:	82000315 	stw	r8,12(r16)
 9081cac:	81800215 	stw	r6,8(r16)
 9081cb0:	07024274 	movhi	fp,2313
 9081cb4:	e72b6104 	addi	fp,fp,-21116
 9081cb8:	34000315 	stw	r16,12(r6)
 9081cbc:	44000215 	stw	r16,8(r8)
 9081cc0:	003f3e06 	br	90819bc <_malloc_r+0x218>
 9081cc4:	63000044 	addi	r12,r12,1
 9081cc8:	608000cc 	andi	r2,r12,3
 9081ccc:	10005d26 	beq	r2,zero,9081e44 <_malloc_r+0x6a0>
 9081cd0:	18c00204 	addi	r3,r3,8
 9081cd4:	003f5106 	br	9081a1c <_malloc_r+0x278>
 9081cd8:	8089883a 	add	r4,r16,r2
 9081cdc:	003f6d06 	br	9081a94 <_malloc_r+0x2f0>
 9081ce0:	00805504 	movi	r2,340
 9081ce4:	10c02036 	bltu	r2,r3,9081d68 <_malloc_r+0x5c4>
 9081ce8:	8804d3fa 	srli	r2,r17,15
 9081cec:	11801dc4 	addi	r6,r2,119
 9081cf0:	300490fa 	slli	r2,r6,3
 9081cf4:	003ed806 	br	9081858 <_malloc_r+0xb4>
 9081cf8:	48c000c4 	addi	r3,r9,3
 9081cfc:	003f3106 	br	90819c4 <_malloc_r+0x220>
 9081d00:	05c24274 	movhi	r23,2313
 9081d04:	bdf19904 	addi	r23,r23,-14748
 9081d08:	b8800017 	ldw	r2,0(r23)
 9081d0c:	988d883a 	add	r6,r19,r2
 9081d10:	b9800015 	stw	r6,0(r23)
 9081d14:	293fb21e 	bne	r5,r4,9081be0 <_malloc_r+0x43c>
 9081d18:	2083ffcc 	andi	r2,r4,4095
 9081d1c:	103fb01e 	bne	r2,zero,9081be0 <_malloc_r+0x43c>
 9081d20:	e4000217 	ldw	r16,8(fp)
 9081d24:	9d45883a 	add	r2,r19,r21
 9081d28:	10800054 	ori	r2,r2,1
 9081d2c:	80800115 	stw	r2,4(r16)
 9081d30:	b8c00017 	ldw	r3,0(r23)
 9081d34:	d0a01617 	ldw	r2,-32680(gp)
 9081d38:	10c0012e 	bgeu	r2,r3,9081d40 <_malloc_r+0x59c>
 9081d3c:	d0e01615 	stw	r3,-32680(gp)
 9081d40:	d0a01717 	ldw	r2,-32676(gp)
 9081d44:	10ff962e 	bgeu	r2,r3,9081ba0 <_malloc_r+0x3fc>
 9081d48:	d0e01715 	stw	r3,-32676(gp)
 9081d4c:	003f9406 	br	9081ba0 <_malloc_r+0x3fc>
 9081d50:	00800104 	movi	r2,4
 9081d54:	11001e36 	bltu	r2,r4,9081dd0 <_malloc_r+0x62c>
 9081d58:	2804d1ba 	srli	r2,r5,6
 9081d5c:	11000e04 	addi	r4,r2,56
 9081d60:	200690fa 	slli	r3,r4,3
 9081d64:	003fc506 	br	9081c7c <_malloc_r+0x4d8>
 9081d68:	00815504 	movi	r2,1364
 9081d6c:	10c01d2e 	bgeu	r2,r3,9081de4 <_malloc_r+0x640>
 9081d70:	01801f84 	movi	r6,126
 9081d74:	0080fc04 	movi	r2,1008
 9081d78:	003eb706 	br	9081858 <_malloc_r+0xb4>
 9081d7c:	00800204 	movi	r2,8
 9081d80:	10cbc83a 	sub	r5,r2,r3
 9081d84:	2169883a 	add	r20,r4,r5
 9081d88:	003f9e06 	br	9081c04 <_malloc_r+0x460>
 9081d8c:	00bffe04 	movi	r2,-8
 9081d90:	a93ffd04 	addi	r4,r21,-12
 9081d94:	2088703a 	and	r4,r4,r2
 9081d98:	b10b883a 	add	r5,r22,r4
 9081d9c:	00c00144 	movi	r3,5
 9081da0:	28c00215 	stw	r3,8(r5)
 9081da4:	28c00115 	stw	r3,4(r5)
 9081da8:	b0800117 	ldw	r2,4(r22)
 9081dac:	1080004c 	andi	r2,r2,1
 9081db0:	2084b03a 	or	r2,r4,r2
 9081db4:	b0800115 	stw	r2,4(r22)
 9081db8:	313fdd2e 	bgeu	r6,r4,9081d30 <_malloc_r+0x58c>
 9081dbc:	b1400204 	addi	r5,r22,8
 9081dc0:	9009883a 	mov	r4,r18
 9081dc4:	9080bcc0 	call	9080bcc <_free_r>
 9081dc8:	e4000217 	ldw	r16,8(fp)
 9081dcc:	003fd806 	br	9081d30 <_malloc_r+0x58c>
 9081dd0:	00800504 	movi	r2,20
 9081dd4:	11001536 	bltu	r2,r4,9081e2c <_malloc_r+0x688>
 9081dd8:	210016c4 	addi	r4,r4,91
 9081ddc:	200690fa 	slli	r3,r4,3
 9081de0:	003fa606 	br	9081c7c <_malloc_r+0x4d8>
 9081de4:	8804d4ba 	srli	r2,r17,18
 9081de8:	11801f04 	addi	r6,r2,124
 9081dec:	300490fa 	slli	r2,r6,3
 9081df0:	003e9906 	br	9081858 <_malloc_r+0xb4>
 9081df4:	2009d0ba 	srai	r4,r4,2
 9081df8:	01424274 	movhi	r5,2313
 9081dfc:	296b6104 	addi	r5,r5,-21116
 9081e00:	00c00044 	movi	r3,1
 9081e04:	28800117 	ldw	r2,4(r5)
 9081e08:	1906983a 	sll	r3,r3,r4
 9081e0c:	10c4b03a 	or	r2,r2,r3
 9081e10:	28800115 	stw	r2,4(r5)
 9081e14:	003fa306 	br	9081ca4 <_malloc_r+0x500>
 9081e18:	0027883a 	mov	r19,zero
 9081e1c:	00c00044 	movi	r3,1
 9081e20:	003f8606 	br	9081c3c <_malloc_r+0x498>
 9081e24:	d1200315 	stw	r4,-32756(gp)
 9081e28:	003f7306 	br	9081bf8 <_malloc_r+0x454>
 9081e2c:	00801504 	movi	r2,84
 9081e30:	11001936 	bltu	r2,r4,9081e98 <_malloc_r+0x6f4>
 9081e34:	2804d33a 	srli	r2,r5,12
 9081e38:	11001b84 	addi	r4,r2,110
 9081e3c:	200690fa 	slli	r3,r4,3
 9081e40:	003f8e06 	br	9081c7c <_malloc_r+0x4d8>
 9081e44:	480b883a 	mov	r5,r9
 9081e48:	6807883a 	mov	r3,r13
 9081e4c:	288000cc 	andi	r2,r5,3
 9081e50:	18fffe04 	addi	r3,r3,-8
 9081e54:	297fffc4 	addi	r5,r5,-1
 9081e58:	10001526 	beq	r2,zero,9081eb0 <_malloc_r+0x70c>
 9081e5c:	18800217 	ldw	r2,8(r3)
 9081e60:	10fffa26 	beq	r2,r3,9081e4c <_malloc_r+0x6a8>
 9081e64:	2109883a 	add	r4,r4,r4
 9081e68:	393f1e36 	bltu	r7,r4,9081ae4 <_malloc_r+0x340>
 9081e6c:	203f1d26 	beq	r4,zero,9081ae4 <_malloc_r+0x340>
 9081e70:	21c4703a 	and	r2,r4,r7
 9081e74:	10000226 	beq	r2,zero,9081e80 <_malloc_r+0x6dc>
 9081e78:	6013883a 	mov	r9,r12
 9081e7c:	003ee106 	br	9081a04 <_malloc_r+0x260>
 9081e80:	2109883a 	add	r4,r4,r4
 9081e84:	3904703a 	and	r2,r7,r4
 9081e88:	63000104 	addi	r12,r12,4
 9081e8c:	103ffc26 	beq	r2,zero,9081e80 <_malloc_r+0x6dc>
 9081e90:	6013883a 	mov	r9,r12
 9081e94:	003edb06 	br	9081a04 <_malloc_r+0x260>
 9081e98:	00805504 	movi	r2,340
 9081e9c:	11000836 	bltu	r2,r4,9081ec0 <_malloc_r+0x71c>
 9081ea0:	2804d3fa 	srli	r2,r5,15
 9081ea4:	11001dc4 	addi	r4,r2,119
 9081ea8:	200690fa 	slli	r3,r4,3
 9081eac:	003f7306 	br	9081c7c <_malloc_r+0x4d8>
 9081eb0:	0104303a 	nor	r2,zero,r4
 9081eb4:	388e703a 	and	r7,r7,r2
 9081eb8:	e1c00115 	stw	r7,4(fp)
 9081ebc:	003fe906 	br	9081e64 <_malloc_r+0x6c0>
 9081ec0:	00815504 	movi	r2,1364
 9081ec4:	1100032e 	bgeu	r2,r4,9081ed4 <_malloc_r+0x730>
 9081ec8:	01001f84 	movi	r4,126
 9081ecc:	00c0fc04 	movi	r3,1008
 9081ed0:	003f6a06 	br	9081c7c <_malloc_r+0x4d8>
 9081ed4:	2804d4ba 	srli	r2,r5,18
 9081ed8:	11001f04 	addi	r4,r2,124
 9081edc:	200690fa 	slli	r3,r4,3
 9081ee0:	003f6606 	br	9081c7c <_malloc_r+0x4d8>

09081ee4 <memset>:
 9081ee4:	008000c4 	movi	r2,3
 9081ee8:	29403fcc 	andi	r5,r5,255
 9081eec:	2007883a 	mov	r3,r4
 9081ef0:	1180022e 	bgeu	r2,r6,9081efc <memset+0x18>
 9081ef4:	2084703a 	and	r2,r4,r2
 9081ef8:	10000826 	beq	r2,zero,9081f1c <memset+0x38>
 9081efc:	30000526 	beq	r6,zero,9081f14 <memset+0x30>
 9081f00:	2805883a 	mov	r2,r5
 9081f04:	30cd883a 	add	r6,r6,r3
 9081f08:	18800005 	stb	r2,0(r3)
 9081f0c:	18c00044 	addi	r3,r3,1
 9081f10:	19bffd1e 	bne	r3,r6,9081f08 <memset+0x24>
 9081f14:	2005883a 	mov	r2,r4
 9081f18:	f800283a 	ret
 9081f1c:	2804923a 	slli	r2,r5,8
 9081f20:	020003c4 	movi	r8,15
 9081f24:	200f883a 	mov	r7,r4
 9081f28:	2884b03a 	or	r2,r5,r2
 9081f2c:	1006943a 	slli	r3,r2,16
 9081f30:	10c6b03a 	or	r3,r2,r3
 9081f34:	41800a2e 	bgeu	r8,r6,9081f60 <memset+0x7c>
 9081f38:	4005883a 	mov	r2,r8
 9081f3c:	31bffc04 	addi	r6,r6,-16
 9081f40:	38c00015 	stw	r3,0(r7)
 9081f44:	38c00115 	stw	r3,4(r7)
 9081f48:	38c00215 	stw	r3,8(r7)
 9081f4c:	38c00315 	stw	r3,12(r7)
 9081f50:	39c00404 	addi	r7,r7,16
 9081f54:	11bff936 	bltu	r2,r6,9081f3c <memset+0x58>
 9081f58:	008000c4 	movi	r2,3
 9081f5c:	1180052e 	bgeu	r2,r6,9081f74 <memset+0x90>
 9081f60:	31bfff04 	addi	r6,r6,-4
 9081f64:	008000c4 	movi	r2,3
 9081f68:	38c00015 	stw	r3,0(r7)
 9081f6c:	39c00104 	addi	r7,r7,4
 9081f70:	11bffb36 	bltu	r2,r6,9081f60 <memset+0x7c>
 9081f74:	3807883a 	mov	r3,r7
 9081f78:	003fe006 	br	9081efc <memset+0x18>

09081f7c <_open_r>:
 9081f7c:	defffd04 	addi	sp,sp,-12
 9081f80:	dc000015 	stw	r16,0(sp)
 9081f84:	04024274 	movhi	r16,2313
 9081f88:	84318f04 	addi	r16,r16,-14788
 9081f8c:	dc400115 	stw	r17,4(sp)
 9081f90:	80000015 	stw	zero,0(r16)
 9081f94:	2023883a 	mov	r17,r4
 9081f98:	2809883a 	mov	r4,r5
 9081f9c:	300b883a 	mov	r5,r6
 9081fa0:	380d883a 	mov	r6,r7
 9081fa4:	dfc00215 	stw	ra,8(sp)
 9081fa8:	9083dd00 	call	9083dd0 <open>
 9081fac:	1007883a 	mov	r3,r2
 9081fb0:	00bfffc4 	movi	r2,-1
 9081fb4:	18800626 	beq	r3,r2,9081fd0 <_open_r+0x54>
 9081fb8:	1805883a 	mov	r2,r3
 9081fbc:	dfc00217 	ldw	ra,8(sp)
 9081fc0:	dc400117 	ldw	r17,4(sp)
 9081fc4:	dc000017 	ldw	r16,0(sp)
 9081fc8:	dec00304 	addi	sp,sp,12
 9081fcc:	f800283a 	ret
 9081fd0:	80800017 	ldw	r2,0(r16)
 9081fd4:	103ff826 	beq	r2,zero,9081fb8 <_open_r+0x3c>
 9081fd8:	88800015 	stw	r2,0(r17)
 9081fdc:	1805883a 	mov	r2,r3
 9081fe0:	dfc00217 	ldw	ra,8(sp)
 9081fe4:	dc400117 	ldw	r17,4(sp)
 9081fe8:	dc000017 	ldw	r16,0(sp)
 9081fec:	dec00304 	addi	sp,sp,12
 9081ff0:	f800283a 	ret

09081ff4 <_puts_r>:
 9081ff4:	defff604 	addi	sp,sp,-40
 9081ff8:	dc400715 	stw	r17,28(sp)
 9081ffc:	2023883a 	mov	r17,r4
 9082000:	2809883a 	mov	r4,r5
 9082004:	dfc00915 	stw	ra,36(sp)
 9082008:	dcc00815 	stw	r19,32(sp)
 908200c:	2827883a 	mov	r19,r5
 9082010:	90824440 	call	9082444 <strlen>
 9082014:	89400217 	ldw	r5,8(r17)
 9082018:	00c24274 	movhi	r3,2313
 908201c:	18e9a504 	addi	r3,r3,-22892
 9082020:	01c00044 	movi	r7,1
 9082024:	12000044 	addi	r8,r2,1
 9082028:	d8c00515 	stw	r3,20(sp)
 908202c:	d9c00615 	stw	r7,24(sp)
 9082030:	d8c00304 	addi	r3,sp,12
 9082034:	01c00084 	movi	r7,2
 9082038:	8809883a 	mov	r4,r17
 908203c:	d80d883a 	mov	r6,sp
 9082040:	d8c00015 	stw	r3,0(sp)
 9082044:	dcc00315 	stw	r19,12(sp)
 9082048:	da000215 	stw	r8,8(sp)
 908204c:	d9c00115 	stw	r7,4(sp)
 9082050:	d8800415 	stw	r2,16(sp)
 9082054:	90826400 	call	9082640 <__sfvwrite_r>
 9082058:	00ffffc4 	movi	r3,-1
 908205c:	10000626 	beq	r2,zero,9082078 <_puts_r+0x84>
 9082060:	1805883a 	mov	r2,r3
 9082064:	dfc00917 	ldw	ra,36(sp)
 9082068:	dcc00817 	ldw	r19,32(sp)
 908206c:	dc400717 	ldw	r17,28(sp)
 9082070:	dec00a04 	addi	sp,sp,40
 9082074:	f800283a 	ret
 9082078:	00c00284 	movi	r3,10
 908207c:	1805883a 	mov	r2,r3
 9082080:	dfc00917 	ldw	ra,36(sp)
 9082084:	dcc00817 	ldw	r19,32(sp)
 9082088:	dc400717 	ldw	r17,28(sp)
 908208c:	dec00a04 	addi	sp,sp,40
 9082090:	f800283a 	ret

09082094 <puts>:
 9082094:	00824274 	movhi	r2,2313
 9082098:	10b17b04 	addi	r2,r2,-14868
 908209c:	200b883a 	mov	r5,r4
 90820a0:	11000017 	ldw	r4,0(r2)
 90820a4:	9081ff41 	jmpi	9081ff4 <_puts_r>

090820a8 <__srefill_r>:
 90820a8:	defffd04 	addi	sp,sp,-12
 90820ac:	dc400115 	stw	r17,4(sp)
 90820b0:	dc000015 	stw	r16,0(sp)
 90820b4:	dfc00215 	stw	ra,8(sp)
 90820b8:	2023883a 	mov	r17,r4
 90820bc:	2821883a 	mov	r16,r5
 90820c0:	20000226 	beq	r4,zero,90820cc <__srefill_r+0x24>
 90820c4:	20800e17 	ldw	r2,56(r4)
 90820c8:	10004126 	beq	r2,zero,90821d0 <__srefill_r+0x128>
 90820cc:	80c0030b 	ldhu	r3,12(r16)
 90820d0:	80000115 	stw	zero,4(r16)
 90820d4:	1880080c 	andi	r2,r3,32
 90820d8:	1000361e 	bne	r2,zero,90821b4 <__srefill_r+0x10c>
 90820dc:	1880010c 	andi	r2,r3,4
 90820e0:	1000211e 	bne	r2,zero,9082168 <__srefill_r+0xc0>
 90820e4:	1880040c 	andi	r2,r3,16
 90820e8:	10005026 	beq	r2,zero,908222c <__srefill_r+0x184>
 90820ec:	1880020c 	andi	r2,r3,8
 90820f0:	1000541e 	bne	r2,zero,9082244 <__srefill_r+0x19c>
 90820f4:	8080030b 	ldhu	r2,12(r16)
 90820f8:	10800114 	ori	r2,r2,4
 90820fc:	8080030d 	sth	r2,12(r16)
 9082100:	80800417 	ldw	r2,16(r16)
 9082104:	10004526 	beq	r2,zero,908221c <__srefill_r+0x174>
 9082108:	8080030b 	ldhu	r2,12(r16)
 908210c:	108000cc 	andi	r2,r2,3
 9082110:	1000361e 	bne	r2,zero,90821ec <__srefill_r+0x144>
 9082114:	81800417 	ldw	r6,16(r16)
 9082118:	80c00817 	ldw	r3,32(r16)
 908211c:	81400717 	ldw	r5,28(r16)
 9082120:	81c00517 	ldw	r7,20(r16)
 9082124:	8809883a 	mov	r4,r17
 9082128:	81800015 	stw	r6,0(r16)
 908212c:	183ee83a 	callr	r3
 9082130:	80c0030b 	ldhu	r3,12(r16)
 9082134:	1009883a 	mov	r4,r2
 9082138:	80800115 	stw	r2,4(r16)
 908213c:	00b7ffc4 	movi	r2,-8193
 9082140:	1884703a 	and	r2,r3,r2
 9082144:	8080030d 	sth	r2,12(r16)
 9082148:	0100230e 	bge	zero,r4,90821d8 <__srefill_r+0x130>
 908214c:	0009883a 	mov	r4,zero
 9082150:	2005883a 	mov	r2,r4
 9082154:	dfc00217 	ldw	ra,8(sp)
 9082158:	dc400117 	ldw	r17,4(sp)
 908215c:	dc000017 	ldw	r16,0(sp)
 9082160:	dec00304 	addi	sp,sp,12
 9082164:	f800283a 	ret
 9082168:	81400c17 	ldw	r5,48(r16)
 908216c:	283fe426 	beq	r5,zero,9082100 <__srefill_r+0x58>
 9082170:	80801004 	addi	r2,r16,64
 9082174:	28800226 	beq	r5,r2,9082180 <__srefill_r+0xd8>
 9082178:	8809883a 	mov	r4,r17
 908217c:	9080bcc0 	call	9080bcc <_free_r>
 9082180:	80800f17 	ldw	r2,60(r16)
 9082184:	80000c15 	stw	zero,48(r16)
 9082188:	80800115 	stw	r2,4(r16)
 908218c:	103fdc26 	beq	r2,zero,9082100 <__srefill_r+0x58>
 9082190:	80800e17 	ldw	r2,56(r16)
 9082194:	0009883a 	mov	r4,zero
 9082198:	80800015 	stw	r2,0(r16)
 908219c:	2005883a 	mov	r2,r4
 90821a0:	dfc00217 	ldw	ra,8(sp)
 90821a4:	dc400117 	ldw	r17,4(sp)
 90821a8:	dc000017 	ldw	r16,0(sp)
 90821ac:	dec00304 	addi	sp,sp,12
 90821b0:	f800283a 	ret
 90821b4:	013fffc4 	movi	r4,-1
 90821b8:	2005883a 	mov	r2,r4
 90821bc:	dfc00217 	ldw	ra,8(sp)
 90821c0:	dc400117 	ldw	r17,4(sp)
 90821c4:	dc000017 	ldw	r16,0(sp)
 90821c8:	dec00304 	addi	sp,sp,12
 90821cc:	f800283a 	ret
 90821d0:	90807380 	call	9080738 <__sinit>
 90821d4:	003fbd06 	br	90820cc <__srefill_r+0x24>
 90821d8:	20000b1e 	bne	r4,zero,9082208 <__srefill_r+0x160>
 90821dc:	10800814 	ori	r2,r2,32
 90821e0:	013fffc4 	movi	r4,-1
 90821e4:	8080030d 	sth	r2,12(r16)
 90821e8:	003fd906 	br	9082150 <__srefill_r+0xa8>
 90821ec:	00824274 	movhi	r2,2313
 90821f0:	10b17c04 	addi	r2,r2,-14864
 90821f4:	11000017 	ldw	r4,0(r2)
 90821f8:	01424234 	movhi	r5,2312
 90821fc:	29489b04 	addi	r5,r5,8812
 9082200:	908147c0 	call	908147c <_fwalk>
 9082204:	003fc306 	br	9082114 <__srefill_r+0x6c>
 9082208:	10801014 	ori	r2,r2,64
 908220c:	013fffc4 	movi	r4,-1
 9082210:	8080030d 	sth	r2,12(r16)
 9082214:	80000115 	stw	zero,4(r16)
 9082218:	003fcd06 	br	9082150 <__srefill_r+0xa8>
 908221c:	8809883a 	mov	r4,r17
 9082220:	800b883a 	mov	r5,r16
 9082224:	90816100 	call	9081610 <__smakebuf_r>
 9082228:	003fb706 	br	9082108 <__srefill_r+0x60>
 908222c:	18c01014 	ori	r3,r3,64
 9082230:	00800244 	movi	r2,9
 9082234:	013fffc4 	movi	r4,-1
 9082238:	88800015 	stw	r2,0(r17)
 908223c:	80c0030d 	sth	r3,12(r16)
 9082240:	003fc306 	br	9082150 <__srefill_r+0xa8>
 9082244:	8809883a 	mov	r4,r17
 9082248:	800b883a 	mov	r5,r16
 908224c:	90804a00 	call	90804a0 <_fflush_r>
 9082250:	103fd81e 	bne	r2,zero,90821b4 <__srefill_r+0x10c>
 9082254:	8080030b 	ldhu	r2,12(r16)
 9082258:	80000215 	stw	zero,8(r16)
 908225c:	80000615 	stw	zero,24(r16)
 9082260:	10bffdcc 	andi	r2,r2,65527
 9082264:	8080030d 	sth	r2,12(r16)
 9082268:	003fa206 	br	90820f4 <__srefill_r+0x4c>

0908226c <lflush>:
 908226c:	20c0030b 	ldhu	r3,12(r4)
 9082270:	01400244 	movi	r5,9
 9082274:	0005883a 	mov	r2,zero
 9082278:	18c0024c 	andi	r3,r3,9
 908227c:	19400126 	beq	r3,r5,9082284 <lflush+0x18>
 9082280:	f800283a 	ret
 9082284:	908069c1 	jmpi	908069c <fflush>

09082288 <_sbrk_r>:
 9082288:	defffd04 	addi	sp,sp,-12
 908228c:	dc000015 	stw	r16,0(sp)
 9082290:	04024274 	movhi	r16,2313
 9082294:	84318f04 	addi	r16,r16,-14788
 9082298:	dc400115 	stw	r17,4(sp)
 908229c:	80000015 	stw	zero,0(r16)
 90822a0:	2023883a 	mov	r17,r4
 90822a4:	2809883a 	mov	r4,r5
 90822a8:	dfc00215 	stw	ra,8(sp)
 90822ac:	90841980 	call	9084198 <sbrk>
 90822b0:	1007883a 	mov	r3,r2
 90822b4:	00bfffc4 	movi	r2,-1
 90822b8:	18800626 	beq	r3,r2,90822d4 <_sbrk_r+0x4c>
 90822bc:	1805883a 	mov	r2,r3
 90822c0:	dfc00217 	ldw	ra,8(sp)
 90822c4:	dc400117 	ldw	r17,4(sp)
 90822c8:	dc000017 	ldw	r16,0(sp)
 90822cc:	dec00304 	addi	sp,sp,12
 90822d0:	f800283a 	ret
 90822d4:	80800017 	ldw	r2,0(r16)
 90822d8:	103ff826 	beq	r2,zero,90822bc <_sbrk_r+0x34>
 90822dc:	88800015 	stw	r2,0(r17)
 90822e0:	1805883a 	mov	r2,r3
 90822e4:	dfc00217 	ldw	ra,8(sp)
 90822e8:	dc400117 	ldw	r17,4(sp)
 90822ec:	dc000017 	ldw	r16,0(sp)
 90822f0:	dec00304 	addi	sp,sp,12
 90822f4:	f800283a 	ret

090822f8 <__sclose>:
 90822f8:	2940038f 	ldh	r5,14(r5)
 90822fc:	90825301 	jmpi	9082530 <_close_r>

09082300 <__sseek>:
 9082300:	defffe04 	addi	sp,sp,-8
 9082304:	dc000015 	stw	r16,0(sp)
 9082308:	2821883a 	mov	r16,r5
 908230c:	2940038f 	ldh	r5,14(r5)
 9082310:	dfc00115 	stw	ra,4(sp)
 9082314:	9082b4c0 	call	9082b4c <_lseek_r>
 9082318:	1007883a 	mov	r3,r2
 908231c:	00bfffc4 	movi	r2,-1
 9082320:	18800926 	beq	r3,r2,9082348 <__sseek+0x48>
 9082324:	8080030b 	ldhu	r2,12(r16)
 9082328:	80c01415 	stw	r3,80(r16)
 908232c:	10840014 	ori	r2,r2,4096
 9082330:	8080030d 	sth	r2,12(r16)
 9082334:	1805883a 	mov	r2,r3
 9082338:	dfc00117 	ldw	ra,4(sp)
 908233c:	dc000017 	ldw	r16,0(sp)
 9082340:	dec00204 	addi	sp,sp,8
 9082344:	f800283a 	ret
 9082348:	8080030b 	ldhu	r2,12(r16)
 908234c:	10bbffcc 	andi	r2,r2,61439
 9082350:	8080030d 	sth	r2,12(r16)
 9082354:	1805883a 	mov	r2,r3
 9082358:	dfc00117 	ldw	ra,4(sp)
 908235c:	dc000017 	ldw	r16,0(sp)
 9082360:	dec00204 	addi	sp,sp,8
 9082364:	f800283a 	ret

09082368 <__swrite>:
 9082368:	2880030b 	ldhu	r2,12(r5)
 908236c:	defffb04 	addi	sp,sp,-20
 9082370:	dcc00315 	stw	r19,12(sp)
 9082374:	1080400c 	andi	r2,r2,256
 9082378:	dc800215 	stw	r18,8(sp)
 908237c:	dc400115 	stw	r17,4(sp)
 9082380:	dc000015 	stw	r16,0(sp)
 9082384:	3027883a 	mov	r19,r6
 9082388:	3825883a 	mov	r18,r7
 908238c:	dfc00415 	stw	ra,16(sp)
 9082390:	2821883a 	mov	r16,r5
 9082394:	000d883a 	mov	r6,zero
 9082398:	01c00084 	movi	r7,2
 908239c:	2023883a 	mov	r17,r4
 90823a0:	10000226 	beq	r2,zero,90823ac <__swrite+0x44>
 90823a4:	2940038f 	ldh	r5,14(r5)
 90823a8:	9082b4c0 	call	9082b4c <_lseek_r>
 90823ac:	8080030b 	ldhu	r2,12(r16)
 90823b0:	8140038f 	ldh	r5,14(r16)
 90823b4:	8809883a 	mov	r4,r17
 90823b8:	10bbffcc 	andi	r2,r2,61439
 90823bc:	980d883a 	mov	r6,r19
 90823c0:	900f883a 	mov	r7,r18
 90823c4:	8080030d 	sth	r2,12(r16)
 90823c8:	dfc00417 	ldw	ra,16(sp)
 90823cc:	dcc00317 	ldw	r19,12(sp)
 90823d0:	dc800217 	ldw	r18,8(sp)
 90823d4:	dc400117 	ldw	r17,4(sp)
 90823d8:	dc000017 	ldw	r16,0(sp)
 90823dc:	dec00504 	addi	sp,sp,20
 90823e0:	90824b81 	jmpi	90824b8 <_write_r>

090823e4 <__sread>:
 90823e4:	defffe04 	addi	sp,sp,-8
 90823e8:	dc000015 	stw	r16,0(sp)
 90823ec:	2821883a 	mov	r16,r5
 90823f0:	2940038f 	ldh	r5,14(r5)
 90823f4:	dfc00115 	stw	ra,4(sp)
 90823f8:	9082e280 	call	9082e28 <_read_r>
 90823fc:	1007883a 	mov	r3,r2
 9082400:	10000816 	blt	r2,zero,9082424 <__sread+0x40>
 9082404:	80801417 	ldw	r2,80(r16)
 9082408:	10c5883a 	add	r2,r2,r3
 908240c:	80801415 	stw	r2,80(r16)
 9082410:	1805883a 	mov	r2,r3
 9082414:	dfc00117 	ldw	ra,4(sp)
 9082418:	dc000017 	ldw	r16,0(sp)
 908241c:	dec00204 	addi	sp,sp,8
 9082420:	f800283a 	ret
 9082424:	8080030b 	ldhu	r2,12(r16)
 9082428:	10bbffcc 	andi	r2,r2,61439
 908242c:	8080030d 	sth	r2,12(r16)
 9082430:	1805883a 	mov	r2,r3
 9082434:	dfc00117 	ldw	ra,4(sp)
 9082438:	dc000017 	ldw	r16,0(sp)
 908243c:	dec00204 	addi	sp,sp,8
 9082440:	f800283a 	ret

09082444 <strlen>:
 9082444:	208000cc 	andi	r2,r4,3
 9082448:	2011883a 	mov	r8,r4
 908244c:	1000161e 	bne	r2,zero,90824a8 <strlen+0x64>
 9082450:	20c00017 	ldw	r3,0(r4)
 9082454:	017fbff4 	movhi	r5,65279
 9082458:	297fbfc4 	addi	r5,r5,-257
 908245c:	01e02074 	movhi	r7,32897
 9082460:	39e02004 	addi	r7,r7,-32640
 9082464:	1945883a 	add	r2,r3,r5
 9082468:	11c4703a 	and	r2,r2,r7
 908246c:	00c6303a 	nor	r3,zero,r3
 9082470:	1886703a 	and	r3,r3,r2
 9082474:	18000c1e 	bne	r3,zero,90824a8 <strlen+0x64>
 9082478:	280d883a 	mov	r6,r5
 908247c:	380b883a 	mov	r5,r7
 9082480:	21000104 	addi	r4,r4,4
 9082484:	20800017 	ldw	r2,0(r4)
 9082488:	1187883a 	add	r3,r2,r6
 908248c:	1946703a 	and	r3,r3,r5
 9082490:	0084303a 	nor	r2,zero,r2
 9082494:	10c4703a 	and	r2,r2,r3
 9082498:	103ff926 	beq	r2,zero,9082480 <strlen+0x3c>
 908249c:	20800007 	ldb	r2,0(r4)
 90824a0:	10000326 	beq	r2,zero,90824b0 <strlen+0x6c>
 90824a4:	21000044 	addi	r4,r4,1
 90824a8:	20800007 	ldb	r2,0(r4)
 90824ac:	103ffd1e 	bne	r2,zero,90824a4 <strlen+0x60>
 90824b0:	2205c83a 	sub	r2,r4,r8
 90824b4:	f800283a 	ret

090824b8 <_write_r>:
 90824b8:	defffd04 	addi	sp,sp,-12
 90824bc:	dc000015 	stw	r16,0(sp)
 90824c0:	04024274 	movhi	r16,2313
 90824c4:	84318f04 	addi	r16,r16,-14788
 90824c8:	dc400115 	stw	r17,4(sp)
 90824cc:	80000015 	stw	zero,0(r16)
 90824d0:	2023883a 	mov	r17,r4
 90824d4:	2809883a 	mov	r4,r5
 90824d8:	300b883a 	mov	r5,r6
 90824dc:	380d883a 	mov	r6,r7
 90824e0:	dfc00215 	stw	ra,8(sp)
 90824e4:	90842540 	call	9084254 <write>
 90824e8:	1007883a 	mov	r3,r2
 90824ec:	00bfffc4 	movi	r2,-1
 90824f0:	18800626 	beq	r3,r2,908250c <_write_r+0x54>
 90824f4:	1805883a 	mov	r2,r3
 90824f8:	dfc00217 	ldw	ra,8(sp)
 90824fc:	dc400117 	ldw	r17,4(sp)
 9082500:	dc000017 	ldw	r16,0(sp)
 9082504:	dec00304 	addi	sp,sp,12
 9082508:	f800283a 	ret
 908250c:	80800017 	ldw	r2,0(r16)
 9082510:	103ff826 	beq	r2,zero,90824f4 <_write_r+0x3c>
 9082514:	88800015 	stw	r2,0(r17)
 9082518:	1805883a 	mov	r2,r3
 908251c:	dfc00217 	ldw	ra,8(sp)
 9082520:	dc400117 	ldw	r17,4(sp)
 9082524:	dc000017 	ldw	r16,0(sp)
 9082528:	dec00304 	addi	sp,sp,12
 908252c:	f800283a 	ret

09082530 <_close_r>:
 9082530:	defffd04 	addi	sp,sp,-12
 9082534:	dc000015 	stw	r16,0(sp)
 9082538:	04024274 	movhi	r16,2313
 908253c:	84318f04 	addi	r16,r16,-14788
 9082540:	dc400115 	stw	r17,4(sp)
 9082544:	80000015 	stw	zero,0(r16)
 9082548:	2023883a 	mov	r17,r4
 908254c:	2809883a 	mov	r4,r5
 9082550:	dfc00215 	stw	ra,8(sp)
 9082554:	908371c0 	call	908371c <close>
 9082558:	1007883a 	mov	r3,r2
 908255c:	00bfffc4 	movi	r2,-1
 9082560:	18800626 	beq	r3,r2,908257c <_close_r+0x4c>
 9082564:	1805883a 	mov	r2,r3
 9082568:	dfc00217 	ldw	ra,8(sp)
 908256c:	dc400117 	ldw	r17,4(sp)
 9082570:	dc000017 	ldw	r16,0(sp)
 9082574:	dec00304 	addi	sp,sp,12
 9082578:	f800283a 	ret
 908257c:	80800017 	ldw	r2,0(r16)
 9082580:	103ff826 	beq	r2,zero,9082564 <_close_r+0x34>
 9082584:	88800015 	stw	r2,0(r17)
 9082588:	1805883a 	mov	r2,r3
 908258c:	dfc00217 	ldw	ra,8(sp)
 9082590:	dc400117 	ldw	r17,4(sp)
 9082594:	dc000017 	ldw	r16,0(sp)
 9082598:	dec00304 	addi	sp,sp,12
 908259c:	f800283a 	ret

090825a0 <__sflags>:
 90825a0:	28c00007 	ldb	r3,0(r5)
 90825a4:	00801c84 	movi	r2,114
 90825a8:	18800926 	beq	r3,r2,90825d0 <__sflags+0x30>
 90825ac:	00801dc4 	movi	r2,119
 90825b0:	18801426 	beq	r3,r2,9082604 <__sflags+0x64>
 90825b4:	00801844 	movi	r2,97
 90825b8:	18801626 	beq	r3,r2,9082614 <__sflags+0x74>
 90825bc:	0007883a 	mov	r3,zero
 90825c0:	00800584 	movi	r2,22
 90825c4:	20800015 	stw	r2,0(r4)
 90825c8:	1805883a 	mov	r2,r3
 90825cc:	f800283a 	ret
 90825d0:	000f883a 	mov	r7,zero
 90825d4:	0011883a 	mov	r8,zero
 90825d8:	00c00104 	movi	r3,4
 90825dc:	28800047 	ldb	r2,1(r5)
 90825e0:	10000426 	beq	r2,zero,90825f4 <__sflags+0x54>
 90825e4:	01000ac4 	movi	r4,43
 90825e8:	11000e26 	beq	r2,r4,9082624 <__sflags+0x84>
 90825ec:	28800087 	ldb	r2,2(r5)
 90825f0:	11000c26 	beq	r2,r4,9082624 <__sflags+0x84>
 90825f4:	3a04b03a 	or	r2,r7,r8
 90825f8:	30800015 	stw	r2,0(r6)
 90825fc:	1805883a 	mov	r2,r3
 9082600:	f800283a 	ret
 9082604:	01c00044 	movi	r7,1
 9082608:	02018004 	movi	r8,1536
 908260c:	00c00204 	movi	r3,8
 9082610:	003ff206 	br	90825dc <__sflags+0x3c>
 9082614:	01c00044 	movi	r7,1
 9082618:	02008204 	movi	r8,520
 908261c:	00c04204 	movi	r3,264
 9082620:	003fee06 	br	90825dc <__sflags+0x3c>
 9082624:	00bffcc4 	movi	r2,-13
 9082628:	1884703a 	and	r2,r3,r2
 908262c:	01c00084 	movi	r7,2
 9082630:	10c00414 	ori	r3,r2,16
 9082634:	3a04b03a 	or	r2,r7,r8
 9082638:	30800015 	stw	r2,0(r6)
 908263c:	003fef06 	br	90825fc <__sflags+0x5c>

09082640 <__sfvwrite_r>:
 9082640:	30800217 	ldw	r2,8(r6)
 9082644:	defff504 	addi	sp,sp,-44
 9082648:	df000915 	stw	fp,36(sp)
 908264c:	dd800715 	stw	r22,28(sp)
 9082650:	dc800315 	stw	r18,12(sp)
 9082654:	dfc00a15 	stw	ra,40(sp)
 9082658:	ddc00815 	stw	r23,32(sp)
 908265c:	dd400615 	stw	r21,24(sp)
 9082660:	dd000515 	stw	r20,20(sp)
 9082664:	dcc00415 	stw	r19,16(sp)
 9082668:	dc400215 	stw	r17,8(sp)
 908266c:	dc000115 	stw	r16,4(sp)
 9082670:	302d883a 	mov	r22,r6
 9082674:	2039883a 	mov	fp,r4
 9082678:	2825883a 	mov	r18,r5
 908267c:	10001c26 	beq	r2,zero,90826f0 <__sfvwrite_r+0xb0>
 9082680:	29c0030b 	ldhu	r7,12(r5)
 9082684:	3880020c 	andi	r2,r7,8
 9082688:	10002726 	beq	r2,zero,9082728 <__sfvwrite_r+0xe8>
 908268c:	28800417 	ldw	r2,16(r5)
 9082690:	10002526 	beq	r2,zero,9082728 <__sfvwrite_r+0xe8>
 9082694:	3880008c 	andi	r2,r7,2
 9082698:	b5400017 	ldw	r21,0(r22)
 908269c:	10002826 	beq	r2,zero,9082740 <__sfvwrite_r+0x100>
 90826a0:	0021883a 	mov	r16,zero
 90826a4:	0023883a 	mov	r17,zero
 90826a8:	880d883a 	mov	r6,r17
 90826ac:	e009883a 	mov	r4,fp
 90826b0:	00810004 	movi	r2,1024
 90826b4:	80006e26 	beq	r16,zero,9082870 <__sfvwrite_r+0x230>
 90826b8:	800f883a 	mov	r7,r16
 90826bc:	91400717 	ldw	r5,28(r18)
 90826c0:	1400012e 	bgeu	r2,r16,90826c8 <__sfvwrite_r+0x88>
 90826c4:	100f883a 	mov	r7,r2
 90826c8:	90c00917 	ldw	r3,36(r18)
 90826cc:	183ee83a 	callr	r3
 90826d0:	1007883a 	mov	r3,r2
 90826d4:	80a1c83a 	sub	r16,r16,r2
 90826d8:	88a3883a 	add	r17,r17,r2
 90826dc:	00806d0e 	bge	zero,r2,9082894 <__sfvwrite_r+0x254>
 90826e0:	b0800217 	ldw	r2,8(r22)
 90826e4:	10c5c83a 	sub	r2,r2,r3
 90826e8:	b0800215 	stw	r2,8(r22)
 90826ec:	103fee1e 	bne	r2,zero,90826a8 <__sfvwrite_r+0x68>
 90826f0:	0009883a 	mov	r4,zero
 90826f4:	2005883a 	mov	r2,r4
 90826f8:	dfc00a17 	ldw	ra,40(sp)
 90826fc:	df000917 	ldw	fp,36(sp)
 9082700:	ddc00817 	ldw	r23,32(sp)
 9082704:	dd800717 	ldw	r22,28(sp)
 9082708:	dd400617 	ldw	r21,24(sp)
 908270c:	dd000517 	ldw	r20,20(sp)
 9082710:	dcc00417 	ldw	r19,16(sp)
 9082714:	dc800317 	ldw	r18,12(sp)
 9082718:	dc400217 	ldw	r17,8(sp)
 908271c:	dc000117 	ldw	r16,4(sp)
 9082720:	dec00b04 	addi	sp,sp,44
 9082724:	f800283a 	ret
 9082728:	90834940 	call	9083494 <__swsetup_r>
 908272c:	1000e41e 	bne	r2,zero,9082ac0 <__sfvwrite_r+0x480>
 9082730:	91c0030b 	ldhu	r7,12(r18)
 9082734:	b5400017 	ldw	r21,0(r22)
 9082738:	3880008c 	andi	r2,r7,2
 908273c:	103fd81e 	bne	r2,zero,90826a0 <__sfvwrite_r+0x60>
 9082740:	3880004c 	andi	r2,r7,1
 9082744:	1005003a 	cmpeq	r2,r2,zero
 9082748:	10005726 	beq	r2,zero,90828a8 <__sfvwrite_r+0x268>
 908274c:	0029883a 	mov	r20,zero
 9082750:	002f883a 	mov	r23,zero
 9082754:	a0004226 	beq	r20,zero,9082860 <__sfvwrite_r+0x220>
 9082758:	3880800c 	andi	r2,r7,512
 908275c:	94000217 	ldw	r16,8(r18)
 9082760:	10008b26 	beq	r2,zero,9082990 <__sfvwrite_r+0x350>
 9082764:	800d883a 	mov	r6,r16
 9082768:	a400a536 	bltu	r20,r16,9082a00 <__sfvwrite_r+0x3c0>
 908276c:	3881200c 	andi	r2,r7,1152
 9082770:	10002726 	beq	r2,zero,9082810 <__sfvwrite_r+0x1d0>
 9082774:	90800517 	ldw	r2,20(r18)
 9082778:	92000417 	ldw	r8,16(r18)
 908277c:	91400017 	ldw	r5,0(r18)
 9082780:	1087883a 	add	r3,r2,r2
 9082784:	1887883a 	add	r3,r3,r2
 9082788:	1808d7fa 	srli	r4,r3,31
 908278c:	2a21c83a 	sub	r16,r5,r8
 9082790:	80800044 	addi	r2,r16,1
 9082794:	20c9883a 	add	r4,r4,r3
 9082798:	2027d07a 	srai	r19,r4,1
 908279c:	a085883a 	add	r2,r20,r2
 90827a0:	980d883a 	mov	r6,r19
 90827a4:	9880022e 	bgeu	r19,r2,90827b0 <__sfvwrite_r+0x170>
 90827a8:	1027883a 	mov	r19,r2
 90827ac:	100d883a 	mov	r6,r2
 90827b0:	3881000c 	andi	r2,r7,1024
 90827b4:	1000b826 	beq	r2,zero,9082a98 <__sfvwrite_r+0x458>
 90827b8:	300b883a 	mov	r5,r6
 90827bc:	e009883a 	mov	r4,fp
 90827c0:	90817a40 	call	90817a4 <_malloc_r>
 90827c4:	10003126 	beq	r2,zero,908288c <__sfvwrite_r+0x24c>
 90827c8:	91400417 	ldw	r5,16(r18)
 90827cc:	1009883a 	mov	r4,r2
 90827d0:	800d883a 	mov	r6,r16
 90827d4:	1023883a 	mov	r17,r2
 90827d8:	9082ca80 	call	9082ca8 <memcpy>
 90827dc:	90c0030b 	ldhu	r3,12(r18)
 90827e0:	00beffc4 	movi	r2,-1025
 90827e4:	1886703a 	and	r3,r3,r2
 90827e8:	18c02014 	ori	r3,r3,128
 90827ec:	90c0030d 	sth	r3,12(r18)
 90827f0:	9c07c83a 	sub	r3,r19,r16
 90827f4:	8c05883a 	add	r2,r17,r16
 90827f8:	a00d883a 	mov	r6,r20
 90827fc:	a021883a 	mov	r16,r20
 9082800:	90800015 	stw	r2,0(r18)
 9082804:	90c00215 	stw	r3,8(r18)
 9082808:	94400415 	stw	r17,16(r18)
 908280c:	94c00515 	stw	r19,20(r18)
 9082810:	91000017 	ldw	r4,0(r18)
 9082814:	b80b883a 	mov	r5,r23
 9082818:	a023883a 	mov	r17,r20
 908281c:	9082d480 	call	9082d48 <memmove>
 9082820:	90c00217 	ldw	r3,8(r18)
 9082824:	90800017 	ldw	r2,0(r18)
 9082828:	a027883a 	mov	r19,r20
 908282c:	1c07c83a 	sub	r3,r3,r16
 9082830:	1405883a 	add	r2,r2,r16
 9082834:	90c00215 	stw	r3,8(r18)
 9082838:	a021883a 	mov	r16,r20
 908283c:	90800015 	stw	r2,0(r18)
 9082840:	b0800217 	ldw	r2,8(r22)
 9082844:	1405c83a 	sub	r2,r2,r16
 9082848:	b0800215 	stw	r2,8(r22)
 908284c:	103fa826 	beq	r2,zero,90826f0 <__sfvwrite_r+0xb0>
 9082850:	a469c83a 	sub	r20,r20,r17
 9082854:	91c0030b 	ldhu	r7,12(r18)
 9082858:	bcef883a 	add	r23,r23,r19
 908285c:	a03fbe1e 	bne	r20,zero,9082758 <__sfvwrite_r+0x118>
 9082860:	adc00017 	ldw	r23,0(r21)
 9082864:	ad000117 	ldw	r20,4(r21)
 9082868:	ad400204 	addi	r21,r21,8
 908286c:	003fb906 	br	9082754 <__sfvwrite_r+0x114>
 9082870:	ac400017 	ldw	r17,0(r21)
 9082874:	ac000117 	ldw	r16,4(r21)
 9082878:	ad400204 	addi	r21,r21,8
 908287c:	003f8a06 	br	90826a8 <__sfvwrite_r+0x68>
 9082880:	91400417 	ldw	r5,16(r18)
 9082884:	e009883a 	mov	r4,fp
 9082888:	9080bcc0 	call	9080bcc <_free_r>
 908288c:	00800304 	movi	r2,12
 9082890:	e0800015 	stw	r2,0(fp)
 9082894:	9080030b 	ldhu	r2,12(r18)
 9082898:	013fffc4 	movi	r4,-1
 908289c:	10801014 	ori	r2,r2,64
 90828a0:	9080030d 	sth	r2,12(r18)
 90828a4:	003f9306 	br	90826f4 <__sfvwrite_r+0xb4>
 90828a8:	0027883a 	mov	r19,zero
 90828ac:	002f883a 	mov	r23,zero
 90828b0:	d8000015 	stw	zero,0(sp)
 90828b4:	0029883a 	mov	r20,zero
 90828b8:	98001e26 	beq	r19,zero,9082934 <__sfvwrite_r+0x2f4>
 90828bc:	d8c00017 	ldw	r3,0(sp)
 90828c0:	1804c03a 	cmpne	r2,r3,zero
 90828c4:	10005e26 	beq	r2,zero,9082a40 <__sfvwrite_r+0x400>
 90828c8:	9821883a 	mov	r16,r19
 90828cc:	a4c0012e 	bgeu	r20,r19,90828d4 <__sfvwrite_r+0x294>
 90828d0:	a021883a 	mov	r16,r20
 90828d4:	91000017 	ldw	r4,0(r18)
 90828d8:	90800417 	ldw	r2,16(r18)
 90828dc:	91800217 	ldw	r6,8(r18)
 90828e0:	91c00517 	ldw	r7,20(r18)
 90828e4:	1100022e 	bgeu	r2,r4,90828f0 <__sfvwrite_r+0x2b0>
 90828e8:	31e3883a 	add	r17,r6,r7
 90828ec:	8c001616 	blt	r17,r16,9082948 <__sfvwrite_r+0x308>
 90828f0:	81c03816 	blt	r16,r7,90829d4 <__sfvwrite_r+0x394>
 90828f4:	90c00917 	ldw	r3,36(r18)
 90828f8:	91400717 	ldw	r5,28(r18)
 90828fc:	e009883a 	mov	r4,fp
 9082900:	b80d883a 	mov	r6,r23
 9082904:	183ee83a 	callr	r3
 9082908:	1023883a 	mov	r17,r2
 908290c:	00bfe10e 	bge	zero,r2,9082894 <__sfvwrite_r+0x254>
 9082910:	a469c83a 	sub	r20,r20,r17
 9082914:	a0001826 	beq	r20,zero,9082978 <__sfvwrite_r+0x338>
 9082918:	b0800217 	ldw	r2,8(r22)
 908291c:	1445c83a 	sub	r2,r2,r17
 9082920:	b0800215 	stw	r2,8(r22)
 9082924:	103f7226 	beq	r2,zero,90826f0 <__sfvwrite_r+0xb0>
 9082928:	9c67c83a 	sub	r19,r19,r17
 908292c:	bc6f883a 	add	r23,r23,r17
 9082930:	983fe21e 	bne	r19,zero,90828bc <__sfvwrite_r+0x27c>
 9082934:	adc00017 	ldw	r23,0(r21)
 9082938:	acc00117 	ldw	r19,4(r21)
 908293c:	ad400204 	addi	r21,r21,8
 9082940:	d8000015 	stw	zero,0(sp)
 9082944:	003fdc06 	br	90828b8 <__sfvwrite_r+0x278>
 9082948:	b80b883a 	mov	r5,r23
 908294c:	880d883a 	mov	r6,r17
 9082950:	9082d480 	call	9082d48 <memmove>
 9082954:	90c00017 	ldw	r3,0(r18)
 9082958:	e009883a 	mov	r4,fp
 908295c:	900b883a 	mov	r5,r18
 9082960:	1c47883a 	add	r3,r3,r17
 9082964:	90c00015 	stw	r3,0(r18)
 9082968:	90804a00 	call	90804a0 <_fflush_r>
 908296c:	103fc91e 	bne	r2,zero,9082894 <__sfvwrite_r+0x254>
 9082970:	a469c83a 	sub	r20,r20,r17
 9082974:	a03fe81e 	bne	r20,zero,9082918 <__sfvwrite_r+0x2d8>
 9082978:	e009883a 	mov	r4,fp
 908297c:	900b883a 	mov	r5,r18
 9082980:	90804a00 	call	90804a0 <_fflush_r>
 9082984:	103fc31e 	bne	r2,zero,9082894 <__sfvwrite_r+0x254>
 9082988:	d8000015 	stw	zero,0(sp)
 908298c:	003fe206 	br	9082918 <__sfvwrite_r+0x2d8>
 9082990:	91000017 	ldw	r4,0(r18)
 9082994:	90800417 	ldw	r2,16(r18)
 9082998:	1100022e 	bgeu	r2,r4,90829a4 <__sfvwrite_r+0x364>
 908299c:	8023883a 	mov	r17,r16
 90829a0:	85003136 	bltu	r16,r20,9082a68 <__sfvwrite_r+0x428>
 90829a4:	91c00517 	ldw	r7,20(r18)
 90829a8:	a1c01836 	bltu	r20,r7,9082a0c <__sfvwrite_r+0x3cc>
 90829ac:	90c00917 	ldw	r3,36(r18)
 90829b0:	91400717 	ldw	r5,28(r18)
 90829b4:	e009883a 	mov	r4,fp
 90829b8:	b80d883a 	mov	r6,r23
 90829bc:	183ee83a 	callr	r3
 90829c0:	1021883a 	mov	r16,r2
 90829c4:	00bfb30e 	bge	zero,r2,9082894 <__sfvwrite_r+0x254>
 90829c8:	1023883a 	mov	r17,r2
 90829cc:	1027883a 	mov	r19,r2
 90829d0:	003f9b06 	br	9082840 <__sfvwrite_r+0x200>
 90829d4:	b80b883a 	mov	r5,r23
 90829d8:	800d883a 	mov	r6,r16
 90829dc:	9082d480 	call	9082d48 <memmove>
 90829e0:	90c00217 	ldw	r3,8(r18)
 90829e4:	90800017 	ldw	r2,0(r18)
 90829e8:	8023883a 	mov	r17,r16
 90829ec:	1c07c83a 	sub	r3,r3,r16
 90829f0:	1405883a 	add	r2,r2,r16
 90829f4:	90c00215 	stw	r3,8(r18)
 90829f8:	90800015 	stw	r2,0(r18)
 90829fc:	003fc406 	br	9082910 <__sfvwrite_r+0x2d0>
 9082a00:	a00d883a 	mov	r6,r20
 9082a04:	a021883a 	mov	r16,r20
 9082a08:	003f8106 	br	9082810 <__sfvwrite_r+0x1d0>
 9082a0c:	b80b883a 	mov	r5,r23
 9082a10:	a00d883a 	mov	r6,r20
 9082a14:	9082d480 	call	9082d48 <memmove>
 9082a18:	90c00217 	ldw	r3,8(r18)
 9082a1c:	90800017 	ldw	r2,0(r18)
 9082a20:	a021883a 	mov	r16,r20
 9082a24:	1d07c83a 	sub	r3,r3,r20
 9082a28:	1505883a 	add	r2,r2,r20
 9082a2c:	a023883a 	mov	r17,r20
 9082a30:	a027883a 	mov	r19,r20
 9082a34:	90c00215 	stw	r3,8(r18)
 9082a38:	90800015 	stw	r2,0(r18)
 9082a3c:	003f8006 	br	9082840 <__sfvwrite_r+0x200>
 9082a40:	b809883a 	mov	r4,r23
 9082a44:	01400284 	movi	r5,10
 9082a48:	980d883a 	mov	r6,r19
 9082a4c:	9082bc40 	call	9082bc4 <memchr>
 9082a50:	10001726 	beq	r2,zero,9082ab0 <__sfvwrite_r+0x470>
 9082a54:	15c5c83a 	sub	r2,r2,r23
 9082a58:	15000044 	addi	r20,r2,1
 9082a5c:	00800044 	movi	r2,1
 9082a60:	d8800015 	stw	r2,0(sp)
 9082a64:	003f9806 	br	90828c8 <__sfvwrite_r+0x288>
 9082a68:	b80b883a 	mov	r5,r23
 9082a6c:	800d883a 	mov	r6,r16
 9082a70:	9082d480 	call	9082d48 <memmove>
 9082a74:	90c00017 	ldw	r3,0(r18)
 9082a78:	e009883a 	mov	r4,fp
 9082a7c:	900b883a 	mov	r5,r18
 9082a80:	1c07883a 	add	r3,r3,r16
 9082a84:	90c00015 	stw	r3,0(r18)
 9082a88:	8027883a 	mov	r19,r16
 9082a8c:	90804a00 	call	90804a0 <_fflush_r>
 9082a90:	103f6b26 	beq	r2,zero,9082840 <__sfvwrite_r+0x200>
 9082a94:	003f7f06 	br	9082894 <__sfvwrite_r+0x254>
 9082a98:	400b883a 	mov	r5,r8
 9082a9c:	e009883a 	mov	r4,fp
 9082aa0:	9082ea00 	call	9082ea0 <_realloc_r>
 9082aa4:	103f7626 	beq	r2,zero,9082880 <__sfvwrite_r+0x240>
 9082aa8:	1023883a 	mov	r17,r2
 9082aac:	003f5006 	br	90827f0 <__sfvwrite_r+0x1b0>
 9082ab0:	00c00044 	movi	r3,1
 9082ab4:	9d000044 	addi	r20,r19,1
 9082ab8:	d8c00015 	stw	r3,0(sp)
 9082abc:	003f8206 	br	90828c8 <__sfvwrite_r+0x288>
 9082ac0:	9080030b 	ldhu	r2,12(r18)
 9082ac4:	00c00244 	movi	r3,9
 9082ac8:	013fffc4 	movi	r4,-1
 9082acc:	10801014 	ori	r2,r2,64
 9082ad0:	9080030d 	sth	r2,12(r18)
 9082ad4:	e0c00015 	stw	r3,0(fp)
 9082ad8:	003f0606 	br	90826f4 <__sfvwrite_r+0xb4>

09082adc <_isatty_r>:
 9082adc:	defffd04 	addi	sp,sp,-12
 9082ae0:	dc000015 	stw	r16,0(sp)
 9082ae4:	04024274 	movhi	r16,2313
 9082ae8:	84318f04 	addi	r16,r16,-14788
 9082aec:	dc400115 	stw	r17,4(sp)
 9082af0:	80000015 	stw	zero,0(r16)
 9082af4:	2023883a 	mov	r17,r4
 9082af8:	2809883a 	mov	r4,r5
 9082afc:	dfc00215 	stw	ra,8(sp)
 9082b00:	90839d80 	call	90839d8 <isatty>
 9082b04:	1007883a 	mov	r3,r2
 9082b08:	00bfffc4 	movi	r2,-1
 9082b0c:	18800626 	beq	r3,r2,9082b28 <_isatty_r+0x4c>
 9082b10:	1805883a 	mov	r2,r3
 9082b14:	dfc00217 	ldw	ra,8(sp)
 9082b18:	dc400117 	ldw	r17,4(sp)
 9082b1c:	dc000017 	ldw	r16,0(sp)
 9082b20:	dec00304 	addi	sp,sp,12
 9082b24:	f800283a 	ret
 9082b28:	80800017 	ldw	r2,0(r16)
 9082b2c:	103ff826 	beq	r2,zero,9082b10 <_isatty_r+0x34>
 9082b30:	88800015 	stw	r2,0(r17)
 9082b34:	1805883a 	mov	r2,r3
 9082b38:	dfc00217 	ldw	ra,8(sp)
 9082b3c:	dc400117 	ldw	r17,4(sp)
 9082b40:	dc000017 	ldw	r16,0(sp)
 9082b44:	dec00304 	addi	sp,sp,12
 9082b48:	f800283a 	ret

09082b4c <_lseek_r>:
 9082b4c:	defffd04 	addi	sp,sp,-12
 9082b50:	dc000015 	stw	r16,0(sp)
 9082b54:	04024274 	movhi	r16,2313
 9082b58:	84318f04 	addi	r16,r16,-14788
 9082b5c:	dc400115 	stw	r17,4(sp)
 9082b60:	80000015 	stw	zero,0(r16)
 9082b64:	2023883a 	mov	r17,r4
 9082b68:	2809883a 	mov	r4,r5
 9082b6c:	300b883a 	mov	r5,r6
 9082b70:	380d883a 	mov	r6,r7
 9082b74:	dfc00215 	stw	ra,8(sp)
 9082b78:	9083af80 	call	9083af8 <lseek>
 9082b7c:	1007883a 	mov	r3,r2
 9082b80:	00bfffc4 	movi	r2,-1
 9082b84:	18800626 	beq	r3,r2,9082ba0 <_lseek_r+0x54>
 9082b88:	1805883a 	mov	r2,r3
 9082b8c:	dfc00217 	ldw	ra,8(sp)
 9082b90:	dc400117 	ldw	r17,4(sp)
 9082b94:	dc000017 	ldw	r16,0(sp)
 9082b98:	dec00304 	addi	sp,sp,12
 9082b9c:	f800283a 	ret
 9082ba0:	80800017 	ldw	r2,0(r16)
 9082ba4:	103ff826 	beq	r2,zero,9082b88 <_lseek_r+0x3c>
 9082ba8:	88800015 	stw	r2,0(r17)
 9082bac:	1805883a 	mov	r2,r3
 9082bb0:	dfc00217 	ldw	ra,8(sp)
 9082bb4:	dc400117 	ldw	r17,4(sp)
 9082bb8:	dc000017 	ldw	r16,0(sp)
 9082bbc:	dec00304 	addi	sp,sp,12
 9082bc0:	f800283a 	ret

09082bc4 <memchr>:
 9082bc4:	008000c4 	movi	r2,3
 9082bc8:	29403fcc 	andi	r5,r5,255
 9082bcc:	2007883a 	mov	r3,r4
 9082bd0:	1180022e 	bgeu	r2,r6,9082bdc <memchr+0x18>
 9082bd4:	2084703a 	and	r2,r4,r2
 9082bd8:	10000b26 	beq	r2,zero,9082c08 <memchr+0x44>
 9082bdc:	313fffc4 	addi	r4,r6,-1
 9082be0:	3000051e 	bne	r6,zero,9082bf8 <memchr+0x34>
 9082be4:	00002c06 	br	9082c98 <memchr+0xd4>
 9082be8:	213fffc4 	addi	r4,r4,-1
 9082bec:	00bfffc4 	movi	r2,-1
 9082bf0:	18c00044 	addi	r3,r3,1
 9082bf4:	20802826 	beq	r4,r2,9082c98 <memchr+0xd4>
 9082bf8:	18800003 	ldbu	r2,0(r3)
 9082bfc:	28bffa1e 	bne	r5,r2,9082be8 <memchr+0x24>
 9082c00:	1805883a 	mov	r2,r3
 9082c04:	f800283a 	ret
 9082c08:	0011883a 	mov	r8,zero
 9082c0c:	0007883a 	mov	r3,zero
 9082c10:	01c00104 	movi	r7,4
 9082c14:	4004923a 	slli	r2,r8,8
 9082c18:	18c00044 	addi	r3,r3,1
 9082c1c:	1151883a 	add	r8,r2,r5
 9082c20:	19fffc1e 	bne	r3,r7,9082c14 <memchr+0x50>
 9082c24:	02bfbff4 	movhi	r10,65279
 9082c28:	52bfbfc4 	addi	r10,r10,-257
 9082c2c:	02602074 	movhi	r9,32897
 9082c30:	4a602004 	addi	r9,r9,-32640
 9082c34:	02c000c4 	movi	r11,3
 9082c38:	20800017 	ldw	r2,0(r4)
 9082c3c:	31bfff04 	addi	r6,r6,-4
 9082c40:	200f883a 	mov	r7,r4
 9082c44:	1204f03a 	xor	r2,r2,r8
 9082c48:	1287883a 	add	r3,r2,r10
 9082c4c:	1a46703a 	and	r3,r3,r9
 9082c50:	0084303a 	nor	r2,zero,r2
 9082c54:	10c4703a 	and	r2,r2,r3
 9082c58:	10000b26 	beq	r2,zero,9082c88 <memchr+0xc4>
 9082c5c:	20800003 	ldbu	r2,0(r4)
 9082c60:	28800f26 	beq	r5,r2,9082ca0 <memchr+0xdc>
 9082c64:	20800043 	ldbu	r2,1(r4)
 9082c68:	21c00044 	addi	r7,r4,1
 9082c6c:	28800c26 	beq	r5,r2,9082ca0 <memchr+0xdc>
 9082c70:	20800083 	ldbu	r2,2(r4)
 9082c74:	21c00084 	addi	r7,r4,2
 9082c78:	28800926 	beq	r5,r2,9082ca0 <memchr+0xdc>
 9082c7c:	208000c3 	ldbu	r2,3(r4)
 9082c80:	21c000c4 	addi	r7,r4,3
 9082c84:	28800626 	beq	r5,r2,9082ca0 <memchr+0xdc>
 9082c88:	21000104 	addi	r4,r4,4
 9082c8c:	59bfea36 	bltu	r11,r6,9082c38 <memchr+0x74>
 9082c90:	2007883a 	mov	r3,r4
 9082c94:	003fd106 	br	9082bdc <memchr+0x18>
 9082c98:	0005883a 	mov	r2,zero
 9082c9c:	f800283a 	ret
 9082ca0:	3805883a 	mov	r2,r7
 9082ca4:	f800283a 	ret

09082ca8 <memcpy>:
 9082ca8:	01c003c4 	movi	r7,15
 9082cac:	2007883a 	mov	r3,r4
 9082cb0:	3980032e 	bgeu	r7,r6,9082cc0 <memcpy+0x18>
 9082cb4:	2904b03a 	or	r2,r5,r4
 9082cb8:	108000cc 	andi	r2,r2,3
 9082cbc:	10000926 	beq	r2,zero,9082ce4 <memcpy+0x3c>
 9082cc0:	30000626 	beq	r6,zero,9082cdc <memcpy+0x34>
 9082cc4:	30cd883a 	add	r6,r6,r3
 9082cc8:	28800003 	ldbu	r2,0(r5)
 9082ccc:	29400044 	addi	r5,r5,1
 9082cd0:	18800005 	stb	r2,0(r3)
 9082cd4:	18c00044 	addi	r3,r3,1
 9082cd8:	30fffb1e 	bne	r6,r3,9082cc8 <memcpy+0x20>
 9082cdc:	2005883a 	mov	r2,r4
 9082ce0:	f800283a 	ret
 9082ce4:	3811883a 	mov	r8,r7
 9082ce8:	200f883a 	mov	r7,r4
 9082cec:	28c00017 	ldw	r3,0(r5)
 9082cf0:	31bffc04 	addi	r6,r6,-16
 9082cf4:	38c00015 	stw	r3,0(r7)
 9082cf8:	28800117 	ldw	r2,4(r5)
 9082cfc:	38800115 	stw	r2,4(r7)
 9082d00:	28c00217 	ldw	r3,8(r5)
 9082d04:	38c00215 	stw	r3,8(r7)
 9082d08:	28800317 	ldw	r2,12(r5)
 9082d0c:	29400404 	addi	r5,r5,16
 9082d10:	38800315 	stw	r2,12(r7)
 9082d14:	39c00404 	addi	r7,r7,16
 9082d18:	41bff436 	bltu	r8,r6,9082cec <memcpy+0x44>
 9082d1c:	008000c4 	movi	r2,3
 9082d20:	1180072e 	bgeu	r2,r6,9082d40 <memcpy+0x98>
 9082d24:	1007883a 	mov	r3,r2
 9082d28:	28800017 	ldw	r2,0(r5)
 9082d2c:	31bfff04 	addi	r6,r6,-4
 9082d30:	29400104 	addi	r5,r5,4
 9082d34:	38800015 	stw	r2,0(r7)
 9082d38:	39c00104 	addi	r7,r7,4
 9082d3c:	19bffa36 	bltu	r3,r6,9082d28 <memcpy+0x80>
 9082d40:	3807883a 	mov	r3,r7
 9082d44:	003fde06 	br	9082cc0 <memcpy+0x18>

09082d48 <memmove>:
 9082d48:	2807883a 	mov	r3,r5
 9082d4c:	2011883a 	mov	r8,r4
 9082d50:	29000c2e 	bgeu	r5,r4,9082d84 <memmove+0x3c>
 9082d54:	298f883a 	add	r7,r5,r6
 9082d58:	21c00a2e 	bgeu	r4,r7,9082d84 <memmove+0x3c>
 9082d5c:	30000726 	beq	r6,zero,9082d7c <memmove+0x34>
 9082d60:	2187883a 	add	r3,r4,r6
 9082d64:	198dc83a 	sub	r6,r3,r6
 9082d68:	39ffffc4 	addi	r7,r7,-1
 9082d6c:	38800003 	ldbu	r2,0(r7)
 9082d70:	18ffffc4 	addi	r3,r3,-1
 9082d74:	18800005 	stb	r2,0(r3)
 9082d78:	19bffb1e 	bne	r3,r6,9082d68 <memmove+0x20>
 9082d7c:	2005883a 	mov	r2,r4
 9082d80:	f800283a 	ret
 9082d84:	01c003c4 	movi	r7,15
 9082d88:	39800a36 	bltu	r7,r6,9082db4 <memmove+0x6c>
 9082d8c:	303ffb26 	beq	r6,zero,9082d7c <memmove+0x34>
 9082d90:	400f883a 	mov	r7,r8
 9082d94:	320d883a 	add	r6,r6,r8
 9082d98:	28800003 	ldbu	r2,0(r5)
 9082d9c:	29400044 	addi	r5,r5,1
 9082da0:	38800005 	stb	r2,0(r7)
 9082da4:	39c00044 	addi	r7,r7,1
 9082da8:	39bffb1e 	bne	r7,r6,9082d98 <memmove+0x50>
 9082dac:	2005883a 	mov	r2,r4
 9082db0:	f800283a 	ret
 9082db4:	1904b03a 	or	r2,r3,r4
 9082db8:	108000cc 	andi	r2,r2,3
 9082dbc:	103ff31e 	bne	r2,zero,9082d8c <memmove+0x44>
 9082dc0:	3811883a 	mov	r8,r7
 9082dc4:	180b883a 	mov	r5,r3
 9082dc8:	200f883a 	mov	r7,r4
 9082dcc:	28c00017 	ldw	r3,0(r5)
 9082dd0:	31bffc04 	addi	r6,r6,-16
 9082dd4:	38c00015 	stw	r3,0(r7)
 9082dd8:	28800117 	ldw	r2,4(r5)
 9082ddc:	38800115 	stw	r2,4(r7)
 9082de0:	28c00217 	ldw	r3,8(r5)
 9082de4:	38c00215 	stw	r3,8(r7)
 9082de8:	28800317 	ldw	r2,12(r5)
 9082dec:	29400404 	addi	r5,r5,16
 9082df0:	38800315 	stw	r2,12(r7)
 9082df4:	39c00404 	addi	r7,r7,16
 9082df8:	41bff436 	bltu	r8,r6,9082dcc <memmove+0x84>
 9082dfc:	008000c4 	movi	r2,3
 9082e00:	1180072e 	bgeu	r2,r6,9082e20 <memmove+0xd8>
 9082e04:	1007883a 	mov	r3,r2
 9082e08:	28800017 	ldw	r2,0(r5)
 9082e0c:	31bfff04 	addi	r6,r6,-4
 9082e10:	29400104 	addi	r5,r5,4
 9082e14:	38800015 	stw	r2,0(r7)
 9082e18:	39c00104 	addi	r7,r7,4
 9082e1c:	19bffa36 	bltu	r3,r6,9082e08 <memmove+0xc0>
 9082e20:	3811883a 	mov	r8,r7
 9082e24:	003fd906 	br	9082d8c <memmove+0x44>

09082e28 <_read_r>:
 9082e28:	defffd04 	addi	sp,sp,-12
 9082e2c:	dc000015 	stw	r16,0(sp)
 9082e30:	04024274 	movhi	r16,2313
 9082e34:	84318f04 	addi	r16,r16,-14788
 9082e38:	dc400115 	stw	r17,4(sp)
 9082e3c:	80000015 	stw	zero,0(r16)
 9082e40:	2023883a 	mov	r17,r4
 9082e44:	2809883a 	mov	r4,r5
 9082e48:	300b883a 	mov	r5,r6
 9082e4c:	380d883a 	mov	r6,r7
 9082e50:	dfc00215 	stw	ra,8(sp)
 9082e54:	9083fb80 	call	9083fb8 <read>
 9082e58:	1007883a 	mov	r3,r2
 9082e5c:	00bfffc4 	movi	r2,-1
 9082e60:	18800626 	beq	r3,r2,9082e7c <_read_r+0x54>
 9082e64:	1805883a 	mov	r2,r3
 9082e68:	dfc00217 	ldw	ra,8(sp)
 9082e6c:	dc400117 	ldw	r17,4(sp)
 9082e70:	dc000017 	ldw	r16,0(sp)
 9082e74:	dec00304 	addi	sp,sp,12
 9082e78:	f800283a 	ret
 9082e7c:	80800017 	ldw	r2,0(r16)
 9082e80:	103ff826 	beq	r2,zero,9082e64 <_read_r+0x3c>
 9082e84:	88800015 	stw	r2,0(r17)
 9082e88:	1805883a 	mov	r2,r3
 9082e8c:	dfc00217 	ldw	ra,8(sp)
 9082e90:	dc400117 	ldw	r17,4(sp)
 9082e94:	dc000017 	ldw	r16,0(sp)
 9082e98:	dec00304 	addi	sp,sp,12
 9082e9c:	f800283a 	ret

09082ea0 <_realloc_r>:
 9082ea0:	defff404 	addi	sp,sp,-48
 9082ea4:	dd800815 	stw	r22,32(sp)
 9082ea8:	dc800415 	stw	r18,16(sp)
 9082eac:	dc400315 	stw	r17,12(sp)
 9082eb0:	dfc00b15 	stw	ra,44(sp)
 9082eb4:	df000a15 	stw	fp,40(sp)
 9082eb8:	ddc00915 	stw	r23,36(sp)
 9082ebc:	dd400715 	stw	r21,28(sp)
 9082ec0:	dd000615 	stw	r20,24(sp)
 9082ec4:	dcc00515 	stw	r19,20(sp)
 9082ec8:	dc000215 	stw	r16,8(sp)
 9082ecc:	2825883a 	mov	r18,r5
 9082ed0:	3023883a 	mov	r17,r6
 9082ed4:	202d883a 	mov	r22,r4
 9082ed8:	2800c926 	beq	r5,zero,9083200 <_realloc_r+0x360>
 9082edc:	9083cb40 	call	9083cb4 <__malloc_lock>
 9082ee0:	943ffe04 	addi	r16,r18,-8
 9082ee4:	88c002c4 	addi	r3,r17,11
 9082ee8:	00800584 	movi	r2,22
 9082eec:	82000117 	ldw	r8,4(r16)
 9082ef0:	10c01b2e 	bgeu	r2,r3,9082f60 <_realloc_r+0xc0>
 9082ef4:	00bffe04 	movi	r2,-8
 9082ef8:	188e703a 	and	r7,r3,r2
 9082efc:	3839883a 	mov	fp,r7
 9082f00:	38001a16 	blt	r7,zero,9082f6c <_realloc_r+0xcc>
 9082f04:	e4401936 	bltu	fp,r17,9082f6c <_realloc_r+0xcc>
 9082f08:	013fff04 	movi	r4,-4
 9082f0c:	4126703a 	and	r19,r8,r4
 9082f10:	99c02616 	blt	r19,r7,9082fac <_realloc_r+0x10c>
 9082f14:	802b883a 	mov	r21,r16
 9082f18:	9829883a 	mov	r20,r19
 9082f1c:	84000204 	addi	r16,r16,8
 9082f20:	a80f883a 	mov	r7,r21
 9082f24:	a70dc83a 	sub	r6,r20,fp
 9082f28:	008003c4 	movi	r2,15
 9082f2c:	1180c136 	bltu	r2,r6,9083234 <_realloc_r+0x394>
 9082f30:	38800117 	ldw	r2,4(r7)
 9082f34:	a549883a 	add	r4,r20,r21
 9082f38:	1080004c 	andi	r2,r2,1
 9082f3c:	a084b03a 	or	r2,r20,r2
 9082f40:	38800115 	stw	r2,4(r7)
 9082f44:	20c00117 	ldw	r3,4(r4)
 9082f48:	18c00054 	ori	r3,r3,1
 9082f4c:	20c00115 	stw	r3,4(r4)
 9082f50:	b009883a 	mov	r4,r22
 9082f54:	9083cd40 	call	9083cd4 <__malloc_unlock>
 9082f58:	8023883a 	mov	r17,r16
 9082f5c:	00000606 	br	9082f78 <_realloc_r+0xd8>
 9082f60:	01c00404 	movi	r7,16
 9082f64:	3839883a 	mov	fp,r7
 9082f68:	e47fe72e 	bgeu	fp,r17,9082f08 <_realloc_r+0x68>
 9082f6c:	00800304 	movi	r2,12
 9082f70:	0023883a 	mov	r17,zero
 9082f74:	b0800015 	stw	r2,0(r22)
 9082f78:	8805883a 	mov	r2,r17
 9082f7c:	dfc00b17 	ldw	ra,44(sp)
 9082f80:	df000a17 	ldw	fp,40(sp)
 9082f84:	ddc00917 	ldw	r23,36(sp)
 9082f88:	dd800817 	ldw	r22,32(sp)
 9082f8c:	dd400717 	ldw	r21,28(sp)
 9082f90:	dd000617 	ldw	r20,24(sp)
 9082f94:	dcc00517 	ldw	r19,20(sp)
 9082f98:	dc800417 	ldw	r18,16(sp)
 9082f9c:	dc400317 	ldw	r17,12(sp)
 9082fa0:	dc000217 	ldw	r16,8(sp)
 9082fa4:	dec00c04 	addi	sp,sp,48
 9082fa8:	f800283a 	ret
 9082fac:	00824274 	movhi	r2,2313
 9082fb0:	10ab6104 	addi	r2,r2,-21116
 9082fb4:	12400217 	ldw	r9,8(r2)
 9082fb8:	84cd883a 	add	r6,r16,r19
 9082fbc:	802b883a 	mov	r21,r16
 9082fc0:	3240b926 	beq	r6,r9,90832a8 <_realloc_r+0x408>
 9082fc4:	31400117 	ldw	r5,4(r6)
 9082fc8:	00bfff84 	movi	r2,-2
 9082fcc:	2884703a 	and	r2,r5,r2
 9082fd0:	1185883a 	add	r2,r2,r6
 9082fd4:	10c00117 	ldw	r3,4(r2)
 9082fd8:	18c0004c 	andi	r3,r3,1
 9082fdc:	1807003a 	cmpeq	r3,r3,zero
 9082fe0:	1800a326 	beq	r3,zero,9083270 <_realloc_r+0x3d0>
 9082fe4:	2908703a 	and	r4,r5,r4
 9082fe8:	9929883a 	add	r20,r19,r4
 9082fec:	a1c0a30e 	bge	r20,r7,908327c <_realloc_r+0x3dc>
 9082ff0:	4080004c 	andi	r2,r8,1
 9082ff4:	1000551e 	bne	r2,zero,908314c <_realloc_r+0x2ac>
 9082ff8:	80800017 	ldw	r2,0(r16)
 9082ffc:	80afc83a 	sub	r23,r16,r2
 9083000:	b8c00117 	ldw	r3,4(r23)
 9083004:	00bfff04 	movi	r2,-4
 9083008:	1884703a 	and	r2,r3,r2
 908300c:	30002e26 	beq	r6,zero,90830c8 <_realloc_r+0x228>
 9083010:	3240b926 	beq	r6,r9,90832f8 <_realloc_r+0x458>
 9083014:	98a9883a 	add	r20,r19,r2
 9083018:	2509883a 	add	r4,r4,r20
 908301c:	d9000015 	stw	r4,0(sp)
 9083020:	21c02a16 	blt	r4,r7,90830cc <_realloc_r+0x22c>
 9083024:	30800317 	ldw	r2,12(r6)
 9083028:	30c00217 	ldw	r3,8(r6)
 908302c:	01400904 	movi	r5,36
 9083030:	99bfff04 	addi	r6,r19,-4
 9083034:	18800315 	stw	r2,12(r3)
 9083038:	10c00215 	stw	r3,8(r2)
 908303c:	b9000317 	ldw	r4,12(r23)
 9083040:	b8800217 	ldw	r2,8(r23)
 9083044:	b82b883a 	mov	r21,r23
 9083048:	bc000204 	addi	r16,r23,8
 908304c:	20800215 	stw	r2,8(r4)
 9083050:	11000315 	stw	r4,12(r2)
 9083054:	2980e436 	bltu	r5,r6,90833e8 <_realloc_r+0x548>
 9083058:	008004c4 	movi	r2,19
 908305c:	9009883a 	mov	r4,r18
 9083060:	8011883a 	mov	r8,r16
 9083064:	11800f2e 	bgeu	r2,r6,90830a4 <_realloc_r+0x204>
 9083068:	90800017 	ldw	r2,0(r18)
 908306c:	ba000404 	addi	r8,r23,16
 9083070:	91000204 	addi	r4,r18,8
 9083074:	b8800215 	stw	r2,8(r23)
 9083078:	90c00117 	ldw	r3,4(r18)
 908307c:	008006c4 	movi	r2,27
 9083080:	b8c00315 	stw	r3,12(r23)
 9083084:	1180072e 	bgeu	r2,r6,90830a4 <_realloc_r+0x204>
 9083088:	90c00217 	ldw	r3,8(r18)
 908308c:	ba000604 	addi	r8,r23,24
 9083090:	91000404 	addi	r4,r18,16
 9083094:	b8c00415 	stw	r3,16(r23)
 9083098:	90800317 	ldw	r2,12(r18)
 908309c:	b8800515 	stw	r2,20(r23)
 90830a0:	3140e726 	beq	r6,r5,9083440 <_realloc_r+0x5a0>
 90830a4:	20800017 	ldw	r2,0(r4)
 90830a8:	dd000017 	ldw	r20,0(sp)
 90830ac:	b80f883a 	mov	r7,r23
 90830b0:	40800015 	stw	r2,0(r8)
 90830b4:	20c00117 	ldw	r3,4(r4)
 90830b8:	40c00115 	stw	r3,4(r8)
 90830bc:	20800217 	ldw	r2,8(r4)
 90830c0:	40800215 	stw	r2,8(r8)
 90830c4:	003f9706 	br	9082f24 <_realloc_r+0x84>
 90830c8:	98a9883a 	add	r20,r19,r2
 90830cc:	a1c01f16 	blt	r20,r7,908314c <_realloc_r+0x2ac>
 90830d0:	b8c00317 	ldw	r3,12(r23)
 90830d4:	b8800217 	ldw	r2,8(r23)
 90830d8:	99bfff04 	addi	r6,r19,-4
 90830dc:	01400904 	movi	r5,36
 90830e0:	b82b883a 	mov	r21,r23
 90830e4:	18800215 	stw	r2,8(r3)
 90830e8:	10c00315 	stw	r3,12(r2)
 90830ec:	bc000204 	addi	r16,r23,8
 90830f0:	2980c336 	bltu	r5,r6,9083400 <_realloc_r+0x560>
 90830f4:	008004c4 	movi	r2,19
 90830f8:	9009883a 	mov	r4,r18
 90830fc:	8011883a 	mov	r8,r16
 9083100:	11800f2e 	bgeu	r2,r6,9083140 <_realloc_r+0x2a0>
 9083104:	90800017 	ldw	r2,0(r18)
 9083108:	ba000404 	addi	r8,r23,16
 908310c:	91000204 	addi	r4,r18,8
 9083110:	b8800215 	stw	r2,8(r23)
 9083114:	90c00117 	ldw	r3,4(r18)
 9083118:	008006c4 	movi	r2,27
 908311c:	b8c00315 	stw	r3,12(r23)
 9083120:	1180072e 	bgeu	r2,r6,9083140 <_realloc_r+0x2a0>
 9083124:	90c00217 	ldw	r3,8(r18)
 9083128:	ba000604 	addi	r8,r23,24
 908312c:	91000404 	addi	r4,r18,16
 9083130:	b8c00415 	stw	r3,16(r23)
 9083134:	90800317 	ldw	r2,12(r18)
 9083138:	b8800515 	stw	r2,20(r23)
 908313c:	3140c726 	beq	r6,r5,908345c <_realloc_r+0x5bc>
 9083140:	20800017 	ldw	r2,0(r4)
 9083144:	b80f883a 	mov	r7,r23
 9083148:	003fd906 	br	90830b0 <_realloc_r+0x210>
 908314c:	880b883a 	mov	r5,r17
 9083150:	b009883a 	mov	r4,r22
 9083154:	90817a40 	call	90817a4 <_malloc_r>
 9083158:	1023883a 	mov	r17,r2
 908315c:	10002526 	beq	r2,zero,90831f4 <_realloc_r+0x354>
 9083160:	80800117 	ldw	r2,4(r16)
 9083164:	00ffff84 	movi	r3,-2
 9083168:	893ffe04 	addi	r4,r17,-8
 908316c:	10c4703a 	and	r2,r2,r3
 9083170:	8085883a 	add	r2,r16,r2
 9083174:	20809526 	beq	r4,r2,90833cc <_realloc_r+0x52c>
 9083178:	99bfff04 	addi	r6,r19,-4
 908317c:	01c00904 	movi	r7,36
 9083180:	39804536 	bltu	r7,r6,9083298 <_realloc_r+0x3f8>
 9083184:	008004c4 	movi	r2,19
 9083188:	9009883a 	mov	r4,r18
 908318c:	880b883a 	mov	r5,r17
 9083190:	11800f2e 	bgeu	r2,r6,90831d0 <_realloc_r+0x330>
 9083194:	90800017 	ldw	r2,0(r18)
 9083198:	89400204 	addi	r5,r17,8
 908319c:	91000204 	addi	r4,r18,8
 90831a0:	88800015 	stw	r2,0(r17)
 90831a4:	90c00117 	ldw	r3,4(r18)
 90831a8:	008006c4 	movi	r2,27
 90831ac:	88c00115 	stw	r3,4(r17)
 90831b0:	1180072e 	bgeu	r2,r6,90831d0 <_realloc_r+0x330>
 90831b4:	90c00217 	ldw	r3,8(r18)
 90831b8:	89400404 	addi	r5,r17,16
 90831bc:	91000404 	addi	r4,r18,16
 90831c0:	88c00215 	stw	r3,8(r17)
 90831c4:	90800317 	ldw	r2,12(r18)
 90831c8:	88800315 	stw	r2,12(r17)
 90831cc:	31c09126 	beq	r6,r7,9083414 <_realloc_r+0x574>
 90831d0:	20800017 	ldw	r2,0(r4)
 90831d4:	28800015 	stw	r2,0(r5)
 90831d8:	20c00117 	ldw	r3,4(r4)
 90831dc:	28c00115 	stw	r3,4(r5)
 90831e0:	20800217 	ldw	r2,8(r4)
 90831e4:	28800215 	stw	r2,8(r5)
 90831e8:	900b883a 	mov	r5,r18
 90831ec:	b009883a 	mov	r4,r22
 90831f0:	9080bcc0 	call	9080bcc <_free_r>
 90831f4:	b009883a 	mov	r4,r22
 90831f8:	9083cd40 	call	9083cd4 <__malloc_unlock>
 90831fc:	003f5e06 	br	9082f78 <_realloc_r+0xd8>
 9083200:	300b883a 	mov	r5,r6
 9083204:	dfc00b17 	ldw	ra,44(sp)
 9083208:	df000a17 	ldw	fp,40(sp)
 908320c:	ddc00917 	ldw	r23,36(sp)
 9083210:	dd800817 	ldw	r22,32(sp)
 9083214:	dd400717 	ldw	r21,28(sp)
 9083218:	dd000617 	ldw	r20,24(sp)
 908321c:	dcc00517 	ldw	r19,20(sp)
 9083220:	dc800417 	ldw	r18,16(sp)
 9083224:	dc400317 	ldw	r17,12(sp)
 9083228:	dc000217 	ldw	r16,8(sp)
 908322c:	dec00c04 	addi	sp,sp,48
 9083230:	90817a41 	jmpi	90817a4 <_malloc_r>
 9083234:	38800117 	ldw	r2,4(r7)
 9083238:	e54b883a 	add	r5,fp,r21
 908323c:	31000054 	ori	r4,r6,1
 9083240:	1080004c 	andi	r2,r2,1
 9083244:	1704b03a 	or	r2,r2,fp
 9083248:	38800115 	stw	r2,4(r7)
 908324c:	29000115 	stw	r4,4(r5)
 9083250:	2987883a 	add	r3,r5,r6
 9083254:	18800117 	ldw	r2,4(r3)
 9083258:	29400204 	addi	r5,r5,8
 908325c:	b009883a 	mov	r4,r22
 9083260:	10800054 	ori	r2,r2,1
 9083264:	18800115 	stw	r2,4(r3)
 9083268:	9080bcc0 	call	9080bcc <_free_r>
 908326c:	003f3806 	br	9082f50 <_realloc_r+0xb0>
 9083270:	000d883a 	mov	r6,zero
 9083274:	0009883a 	mov	r4,zero
 9083278:	003f5d06 	br	9082ff0 <_realloc_r+0x150>
 908327c:	30c00217 	ldw	r3,8(r6)
 9083280:	30800317 	ldw	r2,12(r6)
 9083284:	800f883a 	mov	r7,r16
 9083288:	84000204 	addi	r16,r16,8
 908328c:	10c00215 	stw	r3,8(r2)
 9083290:	18800315 	stw	r2,12(r3)
 9083294:	003f2306 	br	9082f24 <_realloc_r+0x84>
 9083298:	8809883a 	mov	r4,r17
 908329c:	900b883a 	mov	r5,r18
 90832a0:	9082d480 	call	9082d48 <memmove>
 90832a4:	003fd006 	br	90831e8 <_realloc_r+0x348>
 90832a8:	30800117 	ldw	r2,4(r6)
 90832ac:	e0c00404 	addi	r3,fp,16
 90832b0:	1108703a 	and	r4,r2,r4
 90832b4:	9905883a 	add	r2,r19,r4
 90832b8:	10ff4d16 	blt	r2,r3,9082ff0 <_realloc_r+0x150>
 90832bc:	1705c83a 	sub	r2,r2,fp
 90832c0:	870b883a 	add	r5,r16,fp
 90832c4:	10800054 	ori	r2,r2,1
 90832c8:	28800115 	stw	r2,4(r5)
 90832cc:	80c00117 	ldw	r3,4(r16)
 90832d0:	00824274 	movhi	r2,2313
 90832d4:	10ab6104 	addi	r2,r2,-21116
 90832d8:	b009883a 	mov	r4,r22
 90832dc:	18c0004c 	andi	r3,r3,1
 90832e0:	e0c6b03a 	or	r3,fp,r3
 90832e4:	11400215 	stw	r5,8(r2)
 90832e8:	80c00115 	stw	r3,4(r16)
 90832ec:	9083cd40 	call	9083cd4 <__malloc_unlock>
 90832f0:	84400204 	addi	r17,r16,8
 90832f4:	003f2006 	br	9082f78 <_realloc_r+0xd8>
 90832f8:	98a9883a 	add	r20,r19,r2
 90832fc:	2509883a 	add	r4,r4,r20
 9083300:	e0800404 	addi	r2,fp,16
 9083304:	d9000115 	stw	r4,4(sp)
 9083308:	20bf7016 	blt	r4,r2,90830cc <_realloc_r+0x22c>
 908330c:	b8c00317 	ldw	r3,12(r23)
 9083310:	b8800217 	ldw	r2,8(r23)
 9083314:	99bfff04 	addi	r6,r19,-4
 9083318:	01400904 	movi	r5,36
 908331c:	18800215 	stw	r2,8(r3)
 9083320:	10c00315 	stw	r3,12(r2)
 9083324:	bc400204 	addi	r17,r23,8
 9083328:	29804136 	bltu	r5,r6,9083430 <_realloc_r+0x590>
 908332c:	008004c4 	movi	r2,19
 9083330:	9009883a 	mov	r4,r18
 9083334:	880f883a 	mov	r7,r17
 9083338:	11800f2e 	bgeu	r2,r6,9083378 <_realloc_r+0x4d8>
 908333c:	90800017 	ldw	r2,0(r18)
 9083340:	b9c00404 	addi	r7,r23,16
 9083344:	91000204 	addi	r4,r18,8
 9083348:	b8800215 	stw	r2,8(r23)
 908334c:	90c00117 	ldw	r3,4(r18)
 9083350:	008006c4 	movi	r2,27
 9083354:	b8c00315 	stw	r3,12(r23)
 9083358:	1180072e 	bgeu	r2,r6,9083378 <_realloc_r+0x4d8>
 908335c:	90c00217 	ldw	r3,8(r18)
 9083360:	b9c00604 	addi	r7,r23,24
 9083364:	91000404 	addi	r4,r18,16
 9083368:	b8c00415 	stw	r3,16(r23)
 908336c:	90800317 	ldw	r2,12(r18)
 9083370:	b8800515 	stw	r2,20(r23)
 9083374:	31404026 	beq	r6,r5,9083478 <_realloc_r+0x5d8>
 9083378:	20800017 	ldw	r2,0(r4)
 908337c:	38800015 	stw	r2,0(r7)
 9083380:	20c00117 	ldw	r3,4(r4)
 9083384:	38c00115 	stw	r3,4(r7)
 9083388:	20800217 	ldw	r2,8(r4)
 908338c:	38800215 	stw	r2,8(r7)
 9083390:	d8c00117 	ldw	r3,4(sp)
 9083394:	bf0b883a 	add	r5,r23,fp
 9083398:	b009883a 	mov	r4,r22
 908339c:	1f05c83a 	sub	r2,r3,fp
 90833a0:	10800054 	ori	r2,r2,1
 90833a4:	28800115 	stw	r2,4(r5)
 90833a8:	b8c00117 	ldw	r3,4(r23)
 90833ac:	00824274 	movhi	r2,2313
 90833b0:	10ab6104 	addi	r2,r2,-21116
 90833b4:	11400215 	stw	r5,8(r2)
 90833b8:	18c0004c 	andi	r3,r3,1
 90833bc:	e0c6b03a 	or	r3,fp,r3
 90833c0:	b8c00115 	stw	r3,4(r23)
 90833c4:	9083cd40 	call	9083cd4 <__malloc_unlock>
 90833c8:	003eeb06 	br	9082f78 <_realloc_r+0xd8>
 90833cc:	20800117 	ldw	r2,4(r4)
 90833d0:	00ffff04 	movi	r3,-4
 90833d4:	800f883a 	mov	r7,r16
 90833d8:	10c4703a 	and	r2,r2,r3
 90833dc:	98a9883a 	add	r20,r19,r2
 90833e0:	84000204 	addi	r16,r16,8
 90833e4:	003ecf06 	br	9082f24 <_realloc_r+0x84>
 90833e8:	900b883a 	mov	r5,r18
 90833ec:	8009883a 	mov	r4,r16
 90833f0:	9082d480 	call	9082d48 <memmove>
 90833f4:	dd000017 	ldw	r20,0(sp)
 90833f8:	b80f883a 	mov	r7,r23
 90833fc:	003ec906 	br	9082f24 <_realloc_r+0x84>
 9083400:	900b883a 	mov	r5,r18
 9083404:	8009883a 	mov	r4,r16
 9083408:	9082d480 	call	9082d48 <memmove>
 908340c:	b80f883a 	mov	r7,r23
 9083410:	003ec406 	br	9082f24 <_realloc_r+0x84>
 9083414:	90c00417 	ldw	r3,16(r18)
 9083418:	89400604 	addi	r5,r17,24
 908341c:	91000604 	addi	r4,r18,24
 9083420:	88c00415 	stw	r3,16(r17)
 9083424:	90800517 	ldw	r2,20(r18)
 9083428:	88800515 	stw	r2,20(r17)
 908342c:	003f6806 	br	90831d0 <_realloc_r+0x330>
 9083430:	900b883a 	mov	r5,r18
 9083434:	8809883a 	mov	r4,r17
 9083438:	9082d480 	call	9082d48 <memmove>
 908343c:	003fd406 	br	9083390 <_realloc_r+0x4f0>
 9083440:	90c00417 	ldw	r3,16(r18)
 9083444:	91000604 	addi	r4,r18,24
 9083448:	ba000804 	addi	r8,r23,32
 908344c:	b8c00615 	stw	r3,24(r23)
 9083450:	90800517 	ldw	r2,20(r18)
 9083454:	b8800715 	stw	r2,28(r23)
 9083458:	003f1206 	br	90830a4 <_realloc_r+0x204>
 908345c:	90c00417 	ldw	r3,16(r18)
 9083460:	91000604 	addi	r4,r18,24
 9083464:	ba000804 	addi	r8,r23,32
 9083468:	b8c00615 	stw	r3,24(r23)
 908346c:	90800517 	ldw	r2,20(r18)
 9083470:	b8800715 	stw	r2,28(r23)
 9083474:	003f3206 	br	9083140 <_realloc_r+0x2a0>
 9083478:	90c00417 	ldw	r3,16(r18)
 908347c:	91000604 	addi	r4,r18,24
 9083480:	b9c00804 	addi	r7,r23,32
 9083484:	b8c00615 	stw	r3,24(r23)
 9083488:	90800517 	ldw	r2,20(r18)
 908348c:	b8800715 	stw	r2,28(r23)
 9083490:	003fb906 	br	9083378 <_realloc_r+0x4d8>

09083494 <__swsetup_r>:
 9083494:	00824274 	movhi	r2,2313
 9083498:	10b17b04 	addi	r2,r2,-14868
 908349c:	10c00017 	ldw	r3,0(r2)
 90834a0:	defffd04 	addi	sp,sp,-12
 90834a4:	dc400115 	stw	r17,4(sp)
 90834a8:	dc000015 	stw	r16,0(sp)
 90834ac:	dfc00215 	stw	ra,8(sp)
 90834b0:	2023883a 	mov	r17,r4
 90834b4:	2821883a 	mov	r16,r5
 90834b8:	18000226 	beq	r3,zero,90834c4 <__swsetup_r+0x30>
 90834bc:	18800e17 	ldw	r2,56(r3)
 90834c0:	10001f26 	beq	r2,zero,9083540 <__swsetup_r+0xac>
 90834c4:	8100030b 	ldhu	r4,12(r16)
 90834c8:	2080020c 	andi	r2,r4,8
 90834cc:	10002826 	beq	r2,zero,9083570 <__swsetup_r+0xdc>
 90834d0:	81400417 	ldw	r5,16(r16)
 90834d4:	28001d26 	beq	r5,zero,908354c <__swsetup_r+0xb8>
 90834d8:	2080004c 	andi	r2,r4,1
 90834dc:	1005003a 	cmpeq	r2,r2,zero
 90834e0:	10000b26 	beq	r2,zero,9083510 <__swsetup_r+0x7c>
 90834e4:	2080008c 	andi	r2,r4,2
 90834e8:	10001226 	beq	r2,zero,9083534 <__swsetup_r+0xa0>
 90834ec:	0005883a 	mov	r2,zero
 90834f0:	80800215 	stw	r2,8(r16)
 90834f4:	28000b26 	beq	r5,zero,9083524 <__swsetup_r+0x90>
 90834f8:	0005883a 	mov	r2,zero
 90834fc:	dfc00217 	ldw	ra,8(sp)
 9083500:	dc400117 	ldw	r17,4(sp)
 9083504:	dc000017 	ldw	r16,0(sp)
 9083508:	dec00304 	addi	sp,sp,12
 908350c:	f800283a 	ret
 9083510:	80800517 	ldw	r2,20(r16)
 9083514:	80000215 	stw	zero,8(r16)
 9083518:	0085c83a 	sub	r2,zero,r2
 908351c:	80800615 	stw	r2,24(r16)
 9083520:	283ff51e 	bne	r5,zero,90834f8 <__swsetup_r+0x64>
 9083524:	2080200c 	andi	r2,r4,128
 9083528:	103ff326 	beq	r2,zero,90834f8 <__swsetup_r+0x64>
 908352c:	00bfffc4 	movi	r2,-1
 9083530:	003ff206 	br	90834fc <__swsetup_r+0x68>
 9083534:	80800517 	ldw	r2,20(r16)
 9083538:	80800215 	stw	r2,8(r16)
 908353c:	003fed06 	br	90834f4 <__swsetup_r+0x60>
 9083540:	1809883a 	mov	r4,r3
 9083544:	90807380 	call	9080738 <__sinit>
 9083548:	003fde06 	br	90834c4 <__swsetup_r+0x30>
 908354c:	20c0a00c 	andi	r3,r4,640
 9083550:	00808004 	movi	r2,512
 9083554:	18bfe026 	beq	r3,r2,90834d8 <__swsetup_r+0x44>
 9083558:	8809883a 	mov	r4,r17
 908355c:	800b883a 	mov	r5,r16
 9083560:	90816100 	call	9081610 <__smakebuf_r>
 9083564:	8100030b 	ldhu	r4,12(r16)
 9083568:	81400417 	ldw	r5,16(r16)
 908356c:	003fda06 	br	90834d8 <__swsetup_r+0x44>
 9083570:	2080040c 	andi	r2,r4,16
 9083574:	103fed26 	beq	r2,zero,908352c <__swsetup_r+0x98>
 9083578:	2080010c 	andi	r2,r4,4
 908357c:	10001226 	beq	r2,zero,90835c8 <__swsetup_r+0x134>
 9083580:	81400c17 	ldw	r5,48(r16)
 9083584:	28000526 	beq	r5,zero,908359c <__swsetup_r+0x108>
 9083588:	80801004 	addi	r2,r16,64
 908358c:	28800226 	beq	r5,r2,9083598 <__swsetup_r+0x104>
 9083590:	8809883a 	mov	r4,r17
 9083594:	9080bcc0 	call	9080bcc <_free_r>
 9083598:	80000c15 	stw	zero,48(r16)
 908359c:	8080030b 	ldhu	r2,12(r16)
 90835a0:	81400417 	ldw	r5,16(r16)
 90835a4:	80000115 	stw	zero,4(r16)
 90835a8:	10bff6cc 	andi	r2,r2,65499
 90835ac:	8080030d 	sth	r2,12(r16)
 90835b0:	81400015 	stw	r5,0(r16)
 90835b4:	8080030b 	ldhu	r2,12(r16)
 90835b8:	10800214 	ori	r2,r2,8
 90835bc:	113fffcc 	andi	r4,r2,65535
 90835c0:	8080030d 	sth	r2,12(r16)
 90835c4:	003fc306 	br	90834d4 <__swsetup_r+0x40>
 90835c8:	81400417 	ldw	r5,16(r16)
 90835cc:	003ff906 	br	90835b4 <__swsetup_r+0x120>

090835d0 <udivmodsi4>:
 90835d0:	29001b2e 	bgeu	r5,r4,9083640 <udivmodsi4+0x70>
 90835d4:	28001a16 	blt	r5,zero,9083640 <udivmodsi4+0x70>
 90835d8:	00800044 	movi	r2,1
 90835dc:	0007883a 	mov	r3,zero
 90835e0:	01c007c4 	movi	r7,31
 90835e4:	00000306 	br	90835f4 <udivmodsi4+0x24>
 90835e8:	19c01326 	beq	r3,r7,9083638 <udivmodsi4+0x68>
 90835ec:	18c00044 	addi	r3,r3,1
 90835f0:	28000416 	blt	r5,zero,9083604 <udivmodsi4+0x34>
 90835f4:	294b883a 	add	r5,r5,r5
 90835f8:	1085883a 	add	r2,r2,r2
 90835fc:	293ffa36 	bltu	r5,r4,90835e8 <udivmodsi4+0x18>
 9083600:	10000d26 	beq	r2,zero,9083638 <udivmodsi4+0x68>
 9083604:	0007883a 	mov	r3,zero
 9083608:	21400236 	bltu	r4,r5,9083614 <udivmodsi4+0x44>
 908360c:	2149c83a 	sub	r4,r4,r5
 9083610:	1886b03a 	or	r3,r3,r2
 9083614:	1004d07a 	srli	r2,r2,1
 9083618:	280ad07a 	srli	r5,r5,1
 908361c:	103ffa1e 	bne	r2,zero,9083608 <udivmodsi4+0x38>
 9083620:	30000226 	beq	r6,zero,908362c <udivmodsi4+0x5c>
 9083624:	2005883a 	mov	r2,r4
 9083628:	f800283a 	ret
 908362c:	1809883a 	mov	r4,r3
 9083630:	2005883a 	mov	r2,r4
 9083634:	f800283a 	ret
 9083638:	0007883a 	mov	r3,zero
 908363c:	003ff806 	br	9083620 <udivmodsi4+0x50>
 9083640:	00800044 	movi	r2,1
 9083644:	0007883a 	mov	r3,zero
 9083648:	003fef06 	br	9083608 <udivmodsi4+0x38>

0908364c <__divsi3>:
 908364c:	defffe04 	addi	sp,sp,-8
 9083650:	dc000015 	stw	r16,0(sp)
 9083654:	dfc00115 	stw	ra,4(sp)
 9083658:	0021883a 	mov	r16,zero
 908365c:	20000c16 	blt	r4,zero,9083690 <__divsi3+0x44>
 9083660:	000d883a 	mov	r6,zero
 9083664:	28000e16 	blt	r5,zero,90836a0 <__divsi3+0x54>
 9083668:	90835d00 	call	90835d0 <udivmodsi4>
 908366c:	1007883a 	mov	r3,r2
 9083670:	8005003a 	cmpeq	r2,r16,zero
 9083674:	1000011e 	bne	r2,zero,908367c <__divsi3+0x30>
 9083678:	00c7c83a 	sub	r3,zero,r3
 908367c:	1805883a 	mov	r2,r3
 9083680:	dfc00117 	ldw	ra,4(sp)
 9083684:	dc000017 	ldw	r16,0(sp)
 9083688:	dec00204 	addi	sp,sp,8
 908368c:	f800283a 	ret
 9083690:	0109c83a 	sub	r4,zero,r4
 9083694:	04000044 	movi	r16,1
 9083698:	000d883a 	mov	r6,zero
 908369c:	283ff20e 	bge	r5,zero,9083668 <__divsi3+0x1c>
 90836a0:	014bc83a 	sub	r5,zero,r5
 90836a4:	8021003a 	cmpeq	r16,r16,zero
 90836a8:	003fef06 	br	9083668 <__divsi3+0x1c>

090836ac <__modsi3>:
 90836ac:	deffff04 	addi	sp,sp,-4
 90836b0:	dfc00015 	stw	ra,0(sp)
 90836b4:	01800044 	movi	r6,1
 90836b8:	2807883a 	mov	r3,r5
 90836bc:	20000416 	blt	r4,zero,90836d0 <__modsi3+0x24>
 90836c0:	28000c16 	blt	r5,zero,90836f4 <__modsi3+0x48>
 90836c4:	dfc00017 	ldw	ra,0(sp)
 90836c8:	dec00104 	addi	sp,sp,4
 90836cc:	90835d01 	jmpi	90835d0 <udivmodsi4>
 90836d0:	0109c83a 	sub	r4,zero,r4
 90836d4:	28000b16 	blt	r5,zero,9083704 <__modsi3+0x58>
 90836d8:	180b883a 	mov	r5,r3
 90836dc:	01800044 	movi	r6,1
 90836e0:	90835d00 	call	90835d0 <udivmodsi4>
 90836e4:	0085c83a 	sub	r2,zero,r2
 90836e8:	dfc00017 	ldw	ra,0(sp)
 90836ec:	dec00104 	addi	sp,sp,4
 90836f0:	f800283a 	ret
 90836f4:	014bc83a 	sub	r5,zero,r5
 90836f8:	dfc00017 	ldw	ra,0(sp)
 90836fc:	dec00104 	addi	sp,sp,4
 9083700:	90835d01 	jmpi	90835d0 <udivmodsi4>
 9083704:	0147c83a 	sub	r3,zero,r5
 9083708:	003ff306 	br	90836d8 <__modsi3+0x2c>

0908370c <__udivsi3>:
 908370c:	000d883a 	mov	r6,zero
 9083710:	90835d01 	jmpi	90835d0 <udivmodsi4>

09083714 <__umodsi3>:
 9083714:	01800044 	movi	r6,1
 9083718:	90835d01 	jmpi	90835d0 <udivmodsi4>

0908371c <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 908371c:	defff804 	addi	sp,sp,-32
 9083720:	dfc00715 	stw	ra,28(sp)
 9083724:	df000615 	stw	fp,24(sp)
 9083728:	df000604 	addi	fp,sp,24
 908372c:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 9083730:	e0bffc17 	ldw	r2,-16(fp)
 9083734:	1004803a 	cmplt	r2,r2,zero
 9083738:	1000081e 	bne	r2,zero,908375c <close+0x40>
 908373c:	e0bffc17 	ldw	r2,-16(fp)
 9083740:	10800324 	muli	r2,r2,12
 9083744:	1007883a 	mov	r3,r2
 9083748:	00824274 	movhi	r2,2313
 908374c:	10ac6d04 	addi	r2,r2,-20044
 9083750:	1887883a 	add	r3,r3,r2
 9083754:	e0ffff15 	stw	r3,-4(fp)
 9083758:	00000106 	br	9083760 <close+0x44>
 908375c:	e03fff15 	stw	zero,-4(fp)
 9083760:	e0bfff17 	ldw	r2,-4(fp)
 9083764:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 9083768:	e0bffb17 	ldw	r2,-20(fp)
 908376c:	1005003a 	cmpeq	r2,r2,zero
 9083770:	10001d1e 	bne	r2,zero,90837e8 <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 9083774:	e0bffb17 	ldw	r2,-20(fp)
 9083778:	10800017 	ldw	r2,0(r2)
 908377c:	10800417 	ldw	r2,16(r2)
 9083780:	1005003a 	cmpeq	r2,r2,zero
 9083784:	1000071e 	bne	r2,zero,90837a4 <close+0x88>
 9083788:	e0bffb17 	ldw	r2,-20(fp)
 908378c:	10800017 	ldw	r2,0(r2)
 9083790:	10800417 	ldw	r2,16(r2)
 9083794:	e13ffb17 	ldw	r4,-20(fp)
 9083798:	103ee83a 	callr	r2
 908379c:	e0bffe15 	stw	r2,-8(fp)
 90837a0:	00000106 	br	90837a8 <close+0x8c>
 90837a4:	e03ffe15 	stw	zero,-8(fp)
 90837a8:	e0bffe17 	ldw	r2,-8(fp)
 90837ac:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 90837b0:	e13ffc17 	ldw	r4,-16(fp)
 90837b4:	90841380 	call	9084138 <alt_release_fd>
    if (rval < 0)
 90837b8:	e0bffa17 	ldw	r2,-24(fp)
 90837bc:	1004403a 	cmpge	r2,r2,zero
 90837c0:	1000071e 	bne	r2,zero,90837e0 <close+0xc4>
    {
      ALT_ERRNO = -rval;
 90837c4:	90838180 	call	9083818 <alt_get_errno>
 90837c8:	e0fffa17 	ldw	r3,-24(fp)
 90837cc:	00c7c83a 	sub	r3,zero,r3
 90837d0:	10c00015 	stw	r3,0(r2)
      return -1;
 90837d4:	00bfffc4 	movi	r2,-1
 90837d8:	e0bffd15 	stw	r2,-12(fp)
 90837dc:	00000806 	br	9083800 <close+0xe4>
    }
    return 0;
 90837e0:	e03ffd15 	stw	zero,-12(fp)
 90837e4:	00000606 	br	9083800 <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 90837e8:	90838180 	call	9083818 <alt_get_errno>
 90837ec:	1007883a 	mov	r3,r2
 90837f0:	00801444 	movi	r2,81
 90837f4:	18800015 	stw	r2,0(r3)
    return -1;
 90837f8:	00bfffc4 	movi	r2,-1
 90837fc:	e0bffd15 	stw	r2,-12(fp)
 9083800:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 9083804:	e037883a 	mov	sp,fp
 9083808:	dfc00117 	ldw	ra,4(sp)
 908380c:	df000017 	ldw	fp,0(sp)
 9083810:	dec00204 	addi	sp,sp,8
 9083814:	f800283a 	ret

09083818 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9083818:	defffd04 	addi	sp,sp,-12
 908381c:	dfc00215 	stw	ra,8(sp)
 9083820:	df000115 	stw	fp,4(sp)
 9083824:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9083828:	00824274 	movhi	r2,2313
 908382c:	10b18404 	addi	r2,r2,-14832
 9083830:	10800017 	ldw	r2,0(r2)
 9083834:	1005003a 	cmpeq	r2,r2,zero
 9083838:	1000061e 	bne	r2,zero,9083854 <alt_get_errno+0x3c>
 908383c:	00824274 	movhi	r2,2313
 9083840:	10b18404 	addi	r2,r2,-14832
 9083844:	10800017 	ldw	r2,0(r2)
 9083848:	103ee83a 	callr	r2
 908384c:	e0bfff15 	stw	r2,-4(fp)
 9083850:	00000306 	br	9083860 <alt_get_errno+0x48>
 9083854:	00824274 	movhi	r2,2313
 9083858:	10b18f04 	addi	r2,r2,-14788
 908385c:	e0bfff15 	stw	r2,-4(fp)
 9083860:	e0bfff17 	ldw	r2,-4(fp)
}
 9083864:	e037883a 	mov	sp,fp
 9083868:	dfc00117 	ldw	ra,4(sp)
 908386c:	df000017 	ldw	fp,0(sp)
 9083870:	dec00204 	addi	sp,sp,8
 9083874:	f800283a 	ret

09083878 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 9083878:	defffc04 	addi	sp,sp,-16
 908387c:	df000315 	stw	fp,12(sp)
 9083880:	df000304 	addi	fp,sp,12
 9083884:	e13ffd15 	stw	r4,-12(fp)
 9083888:	e17ffe15 	stw	r5,-8(fp)
 908388c:	e1bfff15 	stw	r6,-4(fp)
  return len;
 9083890:	e0bfff17 	ldw	r2,-4(fp)
}
 9083894:	e037883a 	mov	sp,fp
 9083898:	df000017 	ldw	fp,0(sp)
 908389c:	dec00104 	addi	sp,sp,4
 90838a0:	f800283a 	ret

090838a4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 90838a4:	defff904 	addi	sp,sp,-28
 90838a8:	dfc00615 	stw	ra,24(sp)
 90838ac:	df000515 	stw	fp,20(sp)
 90838b0:	df000504 	addi	fp,sp,20
 90838b4:	e13ffc15 	stw	r4,-16(fp)
 90838b8:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90838bc:	e0bffc17 	ldw	r2,-16(fp)
 90838c0:	1004803a 	cmplt	r2,r2,zero
 90838c4:	1000081e 	bne	r2,zero,90838e8 <fstat+0x44>
 90838c8:	e0bffc17 	ldw	r2,-16(fp)
 90838cc:	10800324 	muli	r2,r2,12
 90838d0:	1007883a 	mov	r3,r2
 90838d4:	00824274 	movhi	r2,2313
 90838d8:	10ac6d04 	addi	r2,r2,-20044
 90838dc:	1887883a 	add	r3,r3,r2
 90838e0:	e0ffff15 	stw	r3,-4(fp)
 90838e4:	00000106 	br	90838ec <fstat+0x48>
 90838e8:	e03fff15 	stw	zero,-4(fp)
 90838ec:	e0bfff17 	ldw	r2,-4(fp)
 90838f0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 90838f4:	e0bffb17 	ldw	r2,-20(fp)
 90838f8:	1005003a 	cmpeq	r2,r2,zero
 90838fc:	1000121e 	bne	r2,zero,9083948 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 9083900:	e0bffb17 	ldw	r2,-20(fp)
 9083904:	10800017 	ldw	r2,0(r2)
 9083908:	10800817 	ldw	r2,32(r2)
 908390c:	1005003a 	cmpeq	r2,r2,zero
 9083910:	1000081e 	bne	r2,zero,9083934 <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 9083914:	e0bffb17 	ldw	r2,-20(fp)
 9083918:	10800017 	ldw	r2,0(r2)
 908391c:	10800817 	ldw	r2,32(r2)
 9083920:	e13ffb17 	ldw	r4,-20(fp)
 9083924:	e17ffd17 	ldw	r5,-12(fp)
 9083928:	103ee83a 	callr	r2
 908392c:	e0bffe15 	stw	r2,-8(fp)
 9083930:	00000b06 	br	9083960 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 9083934:	e0fffd17 	ldw	r3,-12(fp)
 9083938:	00880004 	movi	r2,8192
 908393c:	18800115 	stw	r2,4(r3)
      return 0;
 9083940:	e03ffe15 	stw	zero,-8(fp)
 9083944:	00000606 	br	9083960 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 9083948:	90839780 	call	9083978 <alt_get_errno>
 908394c:	1007883a 	mov	r3,r2
 9083950:	00801444 	movi	r2,81
 9083954:	18800015 	stw	r2,0(r3)
    return -1;
 9083958:	00bfffc4 	movi	r2,-1
 908395c:	e0bffe15 	stw	r2,-8(fp)
 9083960:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 9083964:	e037883a 	mov	sp,fp
 9083968:	dfc00117 	ldw	ra,4(sp)
 908396c:	df000017 	ldw	fp,0(sp)
 9083970:	dec00204 	addi	sp,sp,8
 9083974:	f800283a 	ret

09083978 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9083978:	defffd04 	addi	sp,sp,-12
 908397c:	dfc00215 	stw	ra,8(sp)
 9083980:	df000115 	stw	fp,4(sp)
 9083984:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9083988:	00824274 	movhi	r2,2313
 908398c:	10b18404 	addi	r2,r2,-14832
 9083990:	10800017 	ldw	r2,0(r2)
 9083994:	1005003a 	cmpeq	r2,r2,zero
 9083998:	1000061e 	bne	r2,zero,90839b4 <alt_get_errno+0x3c>
 908399c:	00824274 	movhi	r2,2313
 90839a0:	10b18404 	addi	r2,r2,-14832
 90839a4:	10800017 	ldw	r2,0(r2)
 90839a8:	103ee83a 	callr	r2
 90839ac:	e0bfff15 	stw	r2,-4(fp)
 90839b0:	00000306 	br	90839c0 <alt_get_errno+0x48>
 90839b4:	00824274 	movhi	r2,2313
 90839b8:	10b18f04 	addi	r2,r2,-14788
 90839bc:	e0bfff15 	stw	r2,-4(fp)
 90839c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90839c4:	e037883a 	mov	sp,fp
 90839c8:	dfc00117 	ldw	ra,4(sp)
 90839cc:	df000017 	ldw	fp,0(sp)
 90839d0:	dec00204 	addi	sp,sp,8
 90839d4:	f800283a 	ret

090839d8 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 90839d8:	deffeb04 	addi	sp,sp,-84
 90839dc:	dfc01415 	stw	ra,80(sp)
 90839e0:	df001315 	stw	fp,76(sp)
 90839e4:	df001304 	addi	fp,sp,76
 90839e8:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90839ec:	e0bffd17 	ldw	r2,-12(fp)
 90839f0:	1004803a 	cmplt	r2,r2,zero
 90839f4:	1000081e 	bne	r2,zero,9083a18 <isatty+0x40>
 90839f8:	e0bffd17 	ldw	r2,-12(fp)
 90839fc:	10800324 	muli	r2,r2,12
 9083a00:	1007883a 	mov	r3,r2
 9083a04:	00824274 	movhi	r2,2313
 9083a08:	10ac6d04 	addi	r2,r2,-20044
 9083a0c:	1887883a 	add	r3,r3,r2
 9083a10:	e0ffff15 	stw	r3,-4(fp)
 9083a14:	00000106 	br	9083a1c <isatty+0x44>
 9083a18:	e03fff15 	stw	zero,-4(fp)
 9083a1c:	e0bfff17 	ldw	r2,-4(fp)
 9083a20:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 9083a24:	e0bfed17 	ldw	r2,-76(fp)
 9083a28:	1005003a 	cmpeq	r2,r2,zero
 9083a2c:	10000f1e 	bne	r2,zero,9083a6c <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 9083a30:	e0bfed17 	ldw	r2,-76(fp)
 9083a34:	10800017 	ldw	r2,0(r2)
 9083a38:	10800817 	ldw	r2,32(r2)
 9083a3c:	1004c03a 	cmpne	r2,r2,zero
 9083a40:	1000031e 	bne	r2,zero,9083a50 <isatty+0x78>
    {
      return 1;
 9083a44:	00800044 	movi	r2,1
 9083a48:	e0bffe15 	stw	r2,-8(fp)
 9083a4c:	00000c06 	br	9083a80 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 9083a50:	e17fee04 	addi	r5,fp,-72
 9083a54:	e13ffd17 	ldw	r4,-12(fp)
 9083a58:	90838a40 	call	90838a4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 9083a5c:	e0bfef17 	ldw	r2,-68(fp)
 9083a60:	10880020 	cmpeqi	r2,r2,8192
 9083a64:	e0bffe15 	stw	r2,-8(fp)
 9083a68:	00000506 	br	9083a80 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 9083a6c:	9083a980 	call	9083a98 <alt_get_errno>
 9083a70:	1007883a 	mov	r3,r2
 9083a74:	00801444 	movi	r2,81
 9083a78:	18800015 	stw	r2,0(r3)
    return 0;
 9083a7c:	e03ffe15 	stw	zero,-8(fp)
 9083a80:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 9083a84:	e037883a 	mov	sp,fp
 9083a88:	dfc00117 	ldw	ra,4(sp)
 9083a8c:	df000017 	ldw	fp,0(sp)
 9083a90:	dec00204 	addi	sp,sp,8
 9083a94:	f800283a 	ret

09083a98 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9083a98:	defffd04 	addi	sp,sp,-12
 9083a9c:	dfc00215 	stw	ra,8(sp)
 9083aa0:	df000115 	stw	fp,4(sp)
 9083aa4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9083aa8:	00824274 	movhi	r2,2313
 9083aac:	10b18404 	addi	r2,r2,-14832
 9083ab0:	10800017 	ldw	r2,0(r2)
 9083ab4:	1005003a 	cmpeq	r2,r2,zero
 9083ab8:	1000061e 	bne	r2,zero,9083ad4 <alt_get_errno+0x3c>
 9083abc:	00824274 	movhi	r2,2313
 9083ac0:	10b18404 	addi	r2,r2,-14832
 9083ac4:	10800017 	ldw	r2,0(r2)
 9083ac8:	103ee83a 	callr	r2
 9083acc:	e0bfff15 	stw	r2,-4(fp)
 9083ad0:	00000306 	br	9083ae0 <alt_get_errno+0x48>
 9083ad4:	00824274 	movhi	r2,2313
 9083ad8:	10b18f04 	addi	r2,r2,-14788
 9083adc:	e0bfff15 	stw	r2,-4(fp)
 9083ae0:	e0bfff17 	ldw	r2,-4(fp)
}
 9083ae4:	e037883a 	mov	sp,fp
 9083ae8:	dfc00117 	ldw	ra,4(sp)
 9083aec:	df000017 	ldw	fp,0(sp)
 9083af0:	dec00204 	addi	sp,sp,8
 9083af4:	f800283a 	ret

09083af8 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 9083af8:	defff804 	addi	sp,sp,-32
 9083afc:	dfc00715 	stw	ra,28(sp)
 9083b00:	df000615 	stw	fp,24(sp)
 9083b04:	df000604 	addi	fp,sp,24
 9083b08:	e13ffc15 	stw	r4,-16(fp)
 9083b0c:	e17ffd15 	stw	r5,-12(fp)
 9083b10:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 9083b14:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 9083b18:	e0bffc17 	ldw	r2,-16(fp)
 9083b1c:	1004803a 	cmplt	r2,r2,zero
 9083b20:	1000081e 	bne	r2,zero,9083b44 <lseek+0x4c>
 9083b24:	e0bffc17 	ldw	r2,-16(fp)
 9083b28:	10800324 	muli	r2,r2,12
 9083b2c:	1007883a 	mov	r3,r2
 9083b30:	00824274 	movhi	r2,2313
 9083b34:	10ac6d04 	addi	r2,r2,-20044
 9083b38:	1887883a 	add	r3,r3,r2
 9083b3c:	e0ffff15 	stw	r3,-4(fp)
 9083b40:	00000106 	br	9083b48 <lseek+0x50>
 9083b44:	e03fff15 	stw	zero,-4(fp)
 9083b48:	e0bfff17 	ldw	r2,-4(fp)
 9083b4c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 9083b50:	e0bffb17 	ldw	r2,-20(fp)
 9083b54:	1005003a 	cmpeq	r2,r2,zero
 9083b58:	1000111e 	bne	r2,zero,9083ba0 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 9083b5c:	e0bffb17 	ldw	r2,-20(fp)
 9083b60:	10800017 	ldw	r2,0(r2)
 9083b64:	10800717 	ldw	r2,28(r2)
 9083b68:	1005003a 	cmpeq	r2,r2,zero
 9083b6c:	1000091e 	bne	r2,zero,9083b94 <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 9083b70:	e0bffb17 	ldw	r2,-20(fp)
 9083b74:	10800017 	ldw	r2,0(r2)
 9083b78:	10800717 	ldw	r2,28(r2)
 9083b7c:	e13ffb17 	ldw	r4,-20(fp)
 9083b80:	e17ffd17 	ldw	r5,-12(fp)
 9083b84:	e1bffe17 	ldw	r6,-8(fp)
 9083b88:	103ee83a 	callr	r2
 9083b8c:	e0bffa15 	stw	r2,-24(fp)
 9083b90:	00000506 	br	9083ba8 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 9083b94:	00bfde84 	movi	r2,-134
 9083b98:	e0bffa15 	stw	r2,-24(fp)
 9083b9c:	00000206 	br	9083ba8 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 9083ba0:	00bfebc4 	movi	r2,-81
 9083ba4:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 9083ba8:	e0bffa17 	ldw	r2,-24(fp)
 9083bac:	1004403a 	cmpge	r2,r2,zero
 9083bb0:	1000071e 	bne	r2,zero,9083bd0 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 9083bb4:	9083be80 	call	9083be8 <alt_get_errno>
 9083bb8:	1007883a 	mov	r3,r2
 9083bbc:	e0bffa17 	ldw	r2,-24(fp)
 9083bc0:	0085c83a 	sub	r2,zero,r2
 9083bc4:	18800015 	stw	r2,0(r3)
    rc = -1;
 9083bc8:	00bfffc4 	movi	r2,-1
 9083bcc:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 9083bd0:	e0bffa17 	ldw	r2,-24(fp)
}
 9083bd4:	e037883a 	mov	sp,fp
 9083bd8:	dfc00117 	ldw	ra,4(sp)
 9083bdc:	df000017 	ldw	fp,0(sp)
 9083be0:	dec00204 	addi	sp,sp,8
 9083be4:	f800283a 	ret

09083be8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9083be8:	defffd04 	addi	sp,sp,-12
 9083bec:	dfc00215 	stw	ra,8(sp)
 9083bf0:	df000115 	stw	fp,4(sp)
 9083bf4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9083bf8:	00824274 	movhi	r2,2313
 9083bfc:	10b18404 	addi	r2,r2,-14832
 9083c00:	10800017 	ldw	r2,0(r2)
 9083c04:	1005003a 	cmpeq	r2,r2,zero
 9083c08:	1000061e 	bne	r2,zero,9083c24 <alt_get_errno+0x3c>
 9083c0c:	00824274 	movhi	r2,2313
 9083c10:	10b18404 	addi	r2,r2,-14832
 9083c14:	10800017 	ldw	r2,0(r2)
 9083c18:	103ee83a 	callr	r2
 9083c1c:	e0bfff15 	stw	r2,-4(fp)
 9083c20:	00000306 	br	9083c30 <alt_get_errno+0x48>
 9083c24:	00824274 	movhi	r2,2313
 9083c28:	10b18f04 	addi	r2,r2,-14788
 9083c2c:	e0bfff15 	stw	r2,-4(fp)
 9083c30:	e0bfff17 	ldw	r2,-4(fp)
}
 9083c34:	e037883a 	mov	sp,fp
 9083c38:	dfc00117 	ldw	ra,4(sp)
 9083c3c:	df000017 	ldw	fp,0(sp)
 9083c40:	dec00204 	addi	sp,sp,8
 9083c44:	f800283a 	ret

09083c48 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 9083c48:	defffd04 	addi	sp,sp,-12
 9083c4c:	dfc00215 	stw	ra,8(sp)
 9083c50:	df000115 	stw	fp,4(sp)
 9083c54:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 9083c58:	0009883a 	mov	r4,zero
 9083c5c:	90843d40 	call	90843d4 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 9083c60:	90844080 	call	9084408 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 9083c64:	01024274 	movhi	r4,2313
 9083c68:	2129a904 	addi	r4,r4,-22876
 9083c6c:	01424274 	movhi	r5,2313
 9083c70:	2969a904 	addi	r5,r5,-22876
 9083c74:	01824274 	movhi	r6,2313
 9083c78:	31a9a904 	addi	r6,r6,-22876
 9083c7c:	90895c80 	call	90895c8 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 9083c80:	9088e340 	call	9088e34 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 9083c84:	01024274 	movhi	r4,2313
 9083c88:	2123a604 	addi	r4,r4,-29032
 9083c8c:	908a2600 	call	908a260 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 9083c90:	d1201817 	ldw	r4,-32672(gp)
 9083c94:	d1601917 	ldw	r5,-32668(gp)
 9083c98:	d1a01a17 	ldw	r6,-32664(gp)
 9083c9c:	90802fc0 	call	90802fc <main>
 9083ca0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 9083ca4:	01000044 	movi	r4,1
 9083ca8:	908371c0 	call	908371c <close>
  exit (result);
 9083cac:	e13fff17 	ldw	r4,-4(fp)
 9083cb0:	908a2740 	call	908a274 <exit>

09083cb4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 9083cb4:	defffe04 	addi	sp,sp,-8
 9083cb8:	df000115 	stw	fp,4(sp)
 9083cbc:	df000104 	addi	fp,sp,4
 9083cc0:	e13fff15 	stw	r4,-4(fp)
}
 9083cc4:	e037883a 	mov	sp,fp
 9083cc8:	df000017 	ldw	fp,0(sp)
 9083ccc:	dec00104 	addi	sp,sp,4
 9083cd0:	f800283a 	ret

09083cd4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 9083cd4:	defffe04 	addi	sp,sp,-8
 9083cd8:	df000115 	stw	fp,4(sp)
 9083cdc:	df000104 	addi	fp,sp,4
 9083ce0:	e13fff15 	stw	r4,-4(fp)
}
 9083ce4:	e037883a 	mov	sp,fp
 9083ce8:	df000017 	ldw	fp,0(sp)
 9083cec:	dec00104 	addi	sp,sp,4
 9083cf0:	f800283a 	ret

09083cf4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 9083cf4:	defffc04 	addi	sp,sp,-16
 9083cf8:	df000315 	stw	fp,12(sp)
 9083cfc:	df000304 	addi	fp,sp,12
 9083d00:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 9083d04:	e0bffe17 	ldw	r2,-8(fp)
 9083d08:	10800217 	ldw	r2,8(r2)
 9083d0c:	10d00034 	orhi	r3,r2,16384
 9083d10:	e0bffe17 	ldw	r2,-8(fp)
 9083d14:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 9083d18:	e03ffd15 	stw	zero,-12(fp)
 9083d1c:	00002006 	br	9083da0 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 9083d20:	e0bffd17 	ldw	r2,-12(fp)
 9083d24:	00c24274 	movhi	r3,2313
 9083d28:	18ec6d04 	addi	r3,r3,-20044
 9083d2c:	10800324 	muli	r2,r2,12
 9083d30:	10c5883a 	add	r2,r2,r3
 9083d34:	10c00017 	ldw	r3,0(r2)
 9083d38:	e0bffe17 	ldw	r2,-8(fp)
 9083d3c:	10800017 	ldw	r2,0(r2)
 9083d40:	1880141e 	bne	r3,r2,9083d94 <alt_file_locked+0xa0>
 9083d44:	e0bffd17 	ldw	r2,-12(fp)
 9083d48:	00c24274 	movhi	r3,2313
 9083d4c:	18ec6d04 	addi	r3,r3,-20044
 9083d50:	10800324 	muli	r2,r2,12
 9083d54:	10c5883a 	add	r2,r2,r3
 9083d58:	10800204 	addi	r2,r2,8
 9083d5c:	10800017 	ldw	r2,0(r2)
 9083d60:	1004403a 	cmpge	r2,r2,zero
 9083d64:	10000b1e 	bne	r2,zero,9083d94 <alt_file_locked+0xa0>
 9083d68:	e0bffd17 	ldw	r2,-12(fp)
 9083d6c:	10800324 	muli	r2,r2,12
 9083d70:	1007883a 	mov	r3,r2
 9083d74:	00824274 	movhi	r2,2313
 9083d78:	10ac6d04 	addi	r2,r2,-20044
 9083d7c:	1887883a 	add	r3,r3,r2
 9083d80:	e0bffe17 	ldw	r2,-8(fp)
 9083d84:	18800326 	beq	r3,r2,9083d94 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 9083d88:	00bffcc4 	movi	r2,-13
 9083d8c:	e0bfff15 	stw	r2,-4(fp)
 9083d90:	00000a06 	br	9083dbc <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 9083d94:	e0bffd17 	ldw	r2,-12(fp)
 9083d98:	10800044 	addi	r2,r2,1
 9083d9c:	e0bffd15 	stw	r2,-12(fp)
 9083da0:	00824274 	movhi	r2,2313
 9083da4:	10b18304 	addi	r2,r2,-14836
 9083da8:	10800017 	ldw	r2,0(r2)
 9083dac:	1007883a 	mov	r3,r2
 9083db0:	e0bffd17 	ldw	r2,-12(fp)
 9083db4:	18bfda2e 	bgeu	r3,r2,9083d20 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 9083db8:	e03fff15 	stw	zero,-4(fp)
 9083dbc:	e0bfff17 	ldw	r2,-4(fp)
}
 9083dc0:	e037883a 	mov	sp,fp
 9083dc4:	df000017 	ldw	fp,0(sp)
 9083dc8:	dec00104 	addi	sp,sp,4
 9083dcc:	f800283a 	ret

09083dd0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 9083dd0:	defff404 	addi	sp,sp,-48
 9083dd4:	dfc00b15 	stw	ra,44(sp)
 9083dd8:	df000a15 	stw	fp,40(sp)
 9083ddc:	df000a04 	addi	fp,sp,40
 9083de0:	e13ffb15 	stw	r4,-20(fp)
 9083de4:	e17ffc15 	stw	r5,-16(fp)
 9083de8:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 9083dec:	00bfffc4 	movi	r2,-1
 9083df0:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 9083df4:	00bffb44 	movi	r2,-19
 9083df8:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 9083dfc:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 9083e00:	e13ffb17 	ldw	r4,-20(fp)
 9083e04:	01424274 	movhi	r5,2313
 9083e08:	29718104 	addi	r5,r5,-14844
 9083e0c:	9088efc0 	call	9088efc <alt_find_dev>
 9083e10:	e0bffa15 	stw	r2,-24(fp)
 9083e14:	e0bffa17 	ldw	r2,-24(fp)
 9083e18:	1004c03a 	cmpne	r2,r2,zero
 9083e1c:	1000051e 	bne	r2,zero,9083e34 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 9083e20:	e13ffb17 	ldw	r4,-20(fp)
 9083e24:	9088f900 	call	9088f90 <alt_find_file>
 9083e28:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 9083e2c:	00800044 	movi	r2,1
 9083e30:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 9083e34:	e0bffa17 	ldw	r2,-24(fp)
 9083e38:	1005003a 	cmpeq	r2,r2,zero
 9083e3c:	1000301e 	bne	r2,zero,9083f00 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 9083e40:	e13ffa17 	ldw	r4,-24(fp)
 9083e44:	90891800 	call	9089180 <alt_get_fd>
 9083e48:	e0bff815 	stw	r2,-32(fp)
 9083e4c:	e0bff817 	ldw	r2,-32(fp)
 9083e50:	1004403a 	cmpge	r2,r2,zero
 9083e54:	1000031e 	bne	r2,zero,9083e64 <open+0x94>
    {
      status = index;
 9083e58:	e0bff817 	ldw	r2,-32(fp)
 9083e5c:	e0bff715 	stw	r2,-36(fp)
 9083e60:	00002906 	br	9083f08 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 9083e64:	e0bff817 	ldw	r2,-32(fp)
 9083e68:	10800324 	muli	r2,r2,12
 9083e6c:	1007883a 	mov	r3,r2
 9083e70:	00824274 	movhi	r2,2313
 9083e74:	10ac6d04 	addi	r2,r2,-20044
 9083e78:	1885883a 	add	r2,r3,r2
 9083e7c:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 9083e80:	e0fffc17 	ldw	r3,-16(fp)
 9083e84:	00900034 	movhi	r2,16384
 9083e88:	10bfffc4 	addi	r2,r2,-1
 9083e8c:	1886703a 	and	r3,r3,r2
 9083e90:	e0bff917 	ldw	r2,-28(fp)
 9083e94:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 9083e98:	e0bff617 	ldw	r2,-40(fp)
 9083e9c:	1004c03a 	cmpne	r2,r2,zero
 9083ea0:	1000061e 	bne	r2,zero,9083ebc <open+0xec>
 9083ea4:	e13ff917 	ldw	r4,-28(fp)
 9083ea8:	9083cf40 	call	9083cf4 <alt_file_locked>
 9083eac:	e0bff715 	stw	r2,-36(fp)
 9083eb0:	e0bff717 	ldw	r2,-36(fp)
 9083eb4:	1004803a 	cmplt	r2,r2,zero
 9083eb8:	1000131e 	bne	r2,zero,9083f08 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 9083ebc:	e0bffa17 	ldw	r2,-24(fp)
 9083ec0:	10800317 	ldw	r2,12(r2)
 9083ec4:	1005003a 	cmpeq	r2,r2,zero
 9083ec8:	1000091e 	bne	r2,zero,9083ef0 <open+0x120>
 9083ecc:	e0bffa17 	ldw	r2,-24(fp)
 9083ed0:	10800317 	ldw	r2,12(r2)
 9083ed4:	e13ff917 	ldw	r4,-28(fp)
 9083ed8:	e17ffb17 	ldw	r5,-20(fp)
 9083edc:	e1bffc17 	ldw	r6,-16(fp)
 9083ee0:	e1fffd17 	ldw	r7,-12(fp)
 9083ee4:	103ee83a 	callr	r2
 9083ee8:	e0bfff15 	stw	r2,-4(fp)
 9083eec:	00000106 	br	9083ef4 <open+0x124>
 9083ef0:	e03fff15 	stw	zero,-4(fp)
 9083ef4:	e0bfff17 	ldw	r2,-4(fp)
 9083ef8:	e0bff715 	stw	r2,-36(fp)
 9083efc:	00000206 	br	9083f08 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 9083f00:	00bffb44 	movi	r2,-19
 9083f04:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 9083f08:	e0bff717 	ldw	r2,-36(fp)
 9083f0c:	1004403a 	cmpge	r2,r2,zero
 9083f10:	1000091e 	bne	r2,zero,9083f38 <open+0x168>
  {
    alt_release_fd (index);  
 9083f14:	e13ff817 	ldw	r4,-32(fp)
 9083f18:	90841380 	call	9084138 <alt_release_fd>
    ALT_ERRNO = -status;
 9083f1c:	9083f580 	call	9083f58 <alt_get_errno>
 9083f20:	e0fff717 	ldw	r3,-36(fp)
 9083f24:	00c7c83a 	sub	r3,zero,r3
 9083f28:	10c00015 	stw	r3,0(r2)
    return -1;
 9083f2c:	00bfffc4 	movi	r2,-1
 9083f30:	e0bffe15 	stw	r2,-8(fp)
 9083f34:	00000206 	br	9083f40 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 9083f38:	e0bff817 	ldw	r2,-32(fp)
 9083f3c:	e0bffe15 	stw	r2,-8(fp)
 9083f40:	e0bffe17 	ldw	r2,-8(fp)
}
 9083f44:	e037883a 	mov	sp,fp
 9083f48:	dfc00117 	ldw	ra,4(sp)
 9083f4c:	df000017 	ldw	fp,0(sp)
 9083f50:	dec00204 	addi	sp,sp,8
 9083f54:	f800283a 	ret

09083f58 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9083f58:	defffd04 	addi	sp,sp,-12
 9083f5c:	dfc00215 	stw	ra,8(sp)
 9083f60:	df000115 	stw	fp,4(sp)
 9083f64:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9083f68:	00824274 	movhi	r2,2313
 9083f6c:	10b18404 	addi	r2,r2,-14832
 9083f70:	10800017 	ldw	r2,0(r2)
 9083f74:	1005003a 	cmpeq	r2,r2,zero
 9083f78:	1000061e 	bne	r2,zero,9083f94 <alt_get_errno+0x3c>
 9083f7c:	00824274 	movhi	r2,2313
 9083f80:	10b18404 	addi	r2,r2,-14832
 9083f84:	10800017 	ldw	r2,0(r2)
 9083f88:	103ee83a 	callr	r2
 9083f8c:	e0bfff15 	stw	r2,-4(fp)
 9083f90:	00000306 	br	9083fa0 <alt_get_errno+0x48>
 9083f94:	00824274 	movhi	r2,2313
 9083f98:	10b18f04 	addi	r2,r2,-14788
 9083f9c:	e0bfff15 	stw	r2,-4(fp)
 9083fa0:	e0bfff17 	ldw	r2,-4(fp)
}
 9083fa4:	e037883a 	mov	sp,fp
 9083fa8:	dfc00117 	ldw	ra,4(sp)
 9083fac:	df000017 	ldw	fp,0(sp)
 9083fb0:	dec00204 	addi	sp,sp,8
 9083fb4:	f800283a 	ret

09083fb8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 9083fb8:	defff704 	addi	sp,sp,-36
 9083fbc:	dfc00815 	stw	ra,32(sp)
 9083fc0:	df000715 	stw	fp,28(sp)
 9083fc4:	df000704 	addi	fp,sp,28
 9083fc8:	e13ffb15 	stw	r4,-20(fp)
 9083fcc:	e17ffc15 	stw	r5,-16(fp)
 9083fd0:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 9083fd4:	e0bffb17 	ldw	r2,-20(fp)
 9083fd8:	1004803a 	cmplt	r2,r2,zero
 9083fdc:	1000081e 	bne	r2,zero,9084000 <read+0x48>
 9083fe0:	e0bffb17 	ldw	r2,-20(fp)
 9083fe4:	10800324 	muli	r2,r2,12
 9083fe8:	1007883a 	mov	r3,r2
 9083fec:	00824274 	movhi	r2,2313
 9083ff0:	10ac6d04 	addi	r2,r2,-20044
 9083ff4:	1887883a 	add	r3,r3,r2
 9083ff8:	e0ffff15 	stw	r3,-4(fp)
 9083ffc:	00000106 	br	9084004 <read+0x4c>
 9084000:	e03fff15 	stw	zero,-4(fp)
 9084004:	e0bfff17 	ldw	r2,-4(fp)
 9084008:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 908400c:	e0bffa17 	ldw	r2,-24(fp)
 9084010:	1005003a 	cmpeq	r2,r2,zero
 9084014:	1000241e 	bne	r2,zero,90840a8 <read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 9084018:	e0bffa17 	ldw	r2,-24(fp)
 908401c:	10800217 	ldw	r2,8(r2)
 9084020:	108000cc 	andi	r2,r2,3
 9084024:	10800060 	cmpeqi	r2,r2,1
 9084028:	10001a1e 	bne	r2,zero,9084094 <read+0xdc>
 908402c:	e0bffa17 	ldw	r2,-24(fp)
 9084030:	10800017 	ldw	r2,0(r2)
 9084034:	10800517 	ldw	r2,20(r2)
 9084038:	1005003a 	cmpeq	r2,r2,zero
 908403c:	1000151e 	bne	r2,zero,9084094 <read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 9084040:	e0bffa17 	ldw	r2,-24(fp)
 9084044:	10800017 	ldw	r2,0(r2)
 9084048:	10800517 	ldw	r2,20(r2)
 908404c:	e17ffc17 	ldw	r5,-16(fp)
 9084050:	e1bffd17 	ldw	r6,-12(fp)
 9084054:	e13ffa17 	ldw	r4,-24(fp)
 9084058:	103ee83a 	callr	r2
 908405c:	e0bff915 	stw	r2,-28(fp)
 9084060:	e0bff917 	ldw	r2,-28(fp)
 9084064:	1004403a 	cmpge	r2,r2,zero
 9084068:	1000071e 	bne	r2,zero,9084088 <read+0xd0>
        {
          ALT_ERRNO = -rval;
 908406c:	90840d80 	call	90840d8 <alt_get_errno>
 9084070:	e0fff917 	ldw	r3,-28(fp)
 9084074:	00c7c83a 	sub	r3,zero,r3
 9084078:	10c00015 	stw	r3,0(r2)
          return -1;
 908407c:	00bfffc4 	movi	r2,-1
 9084080:	e0bffe15 	stw	r2,-8(fp)
 9084084:	00000e06 	br	90840c0 <read+0x108>
        }
        return rval;
 9084088:	e0bff917 	ldw	r2,-28(fp)
 908408c:	e0bffe15 	stw	r2,-8(fp)
 9084090:	00000b06 	br	90840c0 <read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 9084094:	90840d80 	call	90840d8 <alt_get_errno>
 9084098:	1007883a 	mov	r3,r2
 908409c:	00800344 	movi	r2,13
 90840a0:	18800015 	stw	r2,0(r3)
 90840a4:	00000406 	br	90840b8 <read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 90840a8:	90840d80 	call	90840d8 <alt_get_errno>
 90840ac:	1007883a 	mov	r3,r2
 90840b0:	00801444 	movi	r2,81
 90840b4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 90840b8:	00bfffc4 	movi	r2,-1
 90840bc:	e0bffe15 	stw	r2,-8(fp)
 90840c0:	e0bffe17 	ldw	r2,-8(fp)
}
 90840c4:	e037883a 	mov	sp,fp
 90840c8:	dfc00117 	ldw	ra,4(sp)
 90840cc:	df000017 	ldw	fp,0(sp)
 90840d0:	dec00204 	addi	sp,sp,8
 90840d4:	f800283a 	ret

090840d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90840d8:	defffd04 	addi	sp,sp,-12
 90840dc:	dfc00215 	stw	ra,8(sp)
 90840e0:	df000115 	stw	fp,4(sp)
 90840e4:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90840e8:	00824274 	movhi	r2,2313
 90840ec:	10b18404 	addi	r2,r2,-14832
 90840f0:	10800017 	ldw	r2,0(r2)
 90840f4:	1005003a 	cmpeq	r2,r2,zero
 90840f8:	1000061e 	bne	r2,zero,9084114 <alt_get_errno+0x3c>
 90840fc:	00824274 	movhi	r2,2313
 9084100:	10b18404 	addi	r2,r2,-14832
 9084104:	10800017 	ldw	r2,0(r2)
 9084108:	103ee83a 	callr	r2
 908410c:	e0bfff15 	stw	r2,-4(fp)
 9084110:	00000306 	br	9084120 <alt_get_errno+0x48>
 9084114:	00824274 	movhi	r2,2313
 9084118:	10b18f04 	addi	r2,r2,-14788
 908411c:	e0bfff15 	stw	r2,-4(fp)
 9084120:	e0bfff17 	ldw	r2,-4(fp)
}
 9084124:	e037883a 	mov	sp,fp
 9084128:	dfc00117 	ldw	ra,4(sp)
 908412c:	df000017 	ldw	fp,0(sp)
 9084130:	dec00204 	addi	sp,sp,8
 9084134:	f800283a 	ret

09084138 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 9084138:	defffe04 	addi	sp,sp,-8
 908413c:	df000115 	stw	fp,4(sp)
 9084140:	df000104 	addi	fp,sp,4
 9084144:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 9084148:	e0bfff17 	ldw	r2,-4(fp)
 908414c:	108000d0 	cmplti	r2,r2,3
 9084150:	10000d1e 	bne	r2,zero,9084188 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 9084154:	e0bfff17 	ldw	r2,-4(fp)
 9084158:	00c24274 	movhi	r3,2313
 908415c:	18ec6d04 	addi	r3,r3,-20044
 9084160:	10800324 	muli	r2,r2,12
 9084164:	10c5883a 	add	r2,r2,r3
 9084168:	10800204 	addi	r2,r2,8
 908416c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 9084170:	e0bfff17 	ldw	r2,-4(fp)
 9084174:	00c24274 	movhi	r3,2313
 9084178:	18ec6d04 	addi	r3,r3,-20044
 908417c:	10800324 	muli	r2,r2,12
 9084180:	10c5883a 	add	r2,r2,r3
 9084184:	10000015 	stw	zero,0(r2)
  }
}
 9084188:	e037883a 	mov	sp,fp
 908418c:	df000017 	ldw	fp,0(sp)
 9084190:	dec00104 	addi	sp,sp,4
 9084194:	f800283a 	ret

09084198 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 9084198:	defff804 	addi	sp,sp,-32
 908419c:	df000715 	stw	fp,28(sp)
 90841a0:	df000704 	addi	fp,sp,28
 90841a4:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90841a8:	0005303a 	rdctl	r2,status
 90841ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90841b0:	e0fffb17 	ldw	r3,-20(fp)
 90841b4:	00bfff84 	movi	r2,-2
 90841b8:	1884703a 	and	r2,r3,r2
 90841bc:	1001703a 	wrctl	status,r2
  
  return context;
 90841c0:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 90841c4:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 90841c8:	d0a00a17 	ldw	r2,-32728(gp)
 90841cc:	10c000c4 	addi	r3,r2,3
 90841d0:	00bfff04 	movi	r2,-4
 90841d4:	1884703a 	and	r2,r3,r2
 90841d8:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 90841dc:	d0e00a17 	ldw	r3,-32728(gp)
 90841e0:	e0bffe17 	ldw	r2,-8(fp)
 90841e4:	1887883a 	add	r3,r3,r2
 90841e8:	00824434 	movhi	r2,2320
 90841ec:	10800004 	addi	r2,r2,0
 90841f0:	10c0072e 	bgeu	r2,r3,9084210 <sbrk+0x78>
 90841f4:	e0bffd17 	ldw	r2,-12(fp)
 90841f8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90841fc:	e0bffa17 	ldw	r2,-24(fp)
 9084200:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 9084204:	00bfffc4 	movi	r2,-1
 9084208:	e0bfff15 	stw	r2,-4(fp)
 908420c:	00000c06 	br	9084240 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 9084210:	d0a00a17 	ldw	r2,-32728(gp)
 9084214:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 9084218:	d0e00a17 	ldw	r3,-32728(gp)
 908421c:	e0bffe17 	ldw	r2,-8(fp)
 9084220:	1885883a 	add	r2,r3,r2
 9084224:	d0a00a15 	stw	r2,-32728(gp)
 9084228:	e0bffd17 	ldw	r2,-12(fp)
 908422c:	e0bff915 	stw	r2,-28(fp)
 9084230:	e0bff917 	ldw	r2,-28(fp)
 9084234:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 9084238:	e0bffc17 	ldw	r2,-16(fp)
 908423c:	e0bfff15 	stw	r2,-4(fp)
 9084240:	e0bfff17 	ldw	r2,-4(fp)
} 
 9084244:	e037883a 	mov	sp,fp
 9084248:	df000017 	ldw	fp,0(sp)
 908424c:	dec00104 	addi	sp,sp,4
 9084250:	f800283a 	ret

09084254 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 9084254:	defff704 	addi	sp,sp,-36
 9084258:	dfc00815 	stw	ra,32(sp)
 908425c:	df000715 	stw	fp,28(sp)
 9084260:	df000704 	addi	fp,sp,28
 9084264:	e13ffb15 	stw	r4,-20(fp)
 9084268:	e17ffc15 	stw	r5,-16(fp)
 908426c:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 9084270:	e0bffb17 	ldw	r2,-20(fp)
 9084274:	1004803a 	cmplt	r2,r2,zero
 9084278:	1000081e 	bne	r2,zero,908429c <write+0x48>
 908427c:	e0bffb17 	ldw	r2,-20(fp)
 9084280:	10800324 	muli	r2,r2,12
 9084284:	1007883a 	mov	r3,r2
 9084288:	00824274 	movhi	r2,2313
 908428c:	10ac6d04 	addi	r2,r2,-20044
 9084290:	1887883a 	add	r3,r3,r2
 9084294:	e0ffff15 	stw	r3,-4(fp)
 9084298:	00000106 	br	90842a0 <write+0x4c>
 908429c:	e03fff15 	stw	zero,-4(fp)
 90842a0:	e0bfff17 	ldw	r2,-4(fp)
 90842a4:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 90842a8:	e0bffa17 	ldw	r2,-24(fp)
 90842ac:	1005003a 	cmpeq	r2,r2,zero
 90842b0:	1000241e 	bne	r2,zero,9084344 <write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 90842b4:	e0bffa17 	ldw	r2,-24(fp)
 90842b8:	10800217 	ldw	r2,8(r2)
 90842bc:	108000cc 	andi	r2,r2,3
 90842c0:	1005003a 	cmpeq	r2,r2,zero
 90842c4:	10001a1e 	bne	r2,zero,9084330 <write+0xdc>
 90842c8:	e0bffa17 	ldw	r2,-24(fp)
 90842cc:	10800017 	ldw	r2,0(r2)
 90842d0:	10800617 	ldw	r2,24(r2)
 90842d4:	1005003a 	cmpeq	r2,r2,zero
 90842d8:	1000151e 	bne	r2,zero,9084330 <write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 90842dc:	e0bffa17 	ldw	r2,-24(fp)
 90842e0:	10800017 	ldw	r2,0(r2)
 90842e4:	10800617 	ldw	r2,24(r2)
 90842e8:	e17ffc17 	ldw	r5,-16(fp)
 90842ec:	e1bffd17 	ldw	r6,-12(fp)
 90842f0:	e13ffa17 	ldw	r4,-24(fp)
 90842f4:	103ee83a 	callr	r2
 90842f8:	e0bff915 	stw	r2,-28(fp)
 90842fc:	e0bff917 	ldw	r2,-28(fp)
 9084300:	1004403a 	cmpge	r2,r2,zero
 9084304:	1000071e 	bne	r2,zero,9084324 <write+0xd0>
      {
        ALT_ERRNO = -rval;
 9084308:	90843740 	call	9084374 <alt_get_errno>
 908430c:	e0fff917 	ldw	r3,-28(fp)
 9084310:	00c7c83a 	sub	r3,zero,r3
 9084314:	10c00015 	stw	r3,0(r2)
        return -1;
 9084318:	00bfffc4 	movi	r2,-1
 908431c:	e0bffe15 	stw	r2,-8(fp)
 9084320:	00000e06 	br	908435c <write+0x108>
      }
      return rval;
 9084324:	e0bff917 	ldw	r2,-28(fp)
 9084328:	e0bffe15 	stw	r2,-8(fp)
 908432c:	00000b06 	br	908435c <write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 9084330:	90843740 	call	9084374 <alt_get_errno>
 9084334:	1007883a 	mov	r3,r2
 9084338:	00800344 	movi	r2,13
 908433c:	18800015 	stw	r2,0(r3)
 9084340:	00000406 	br	9084354 <write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 9084344:	90843740 	call	9084374 <alt_get_errno>
 9084348:	1007883a 	mov	r3,r2
 908434c:	00801444 	movi	r2,81
 9084350:	18800015 	stw	r2,0(r3)
  }
  return -1;
 9084354:	00bfffc4 	movi	r2,-1
 9084358:	e0bffe15 	stw	r2,-8(fp)
 908435c:	e0bffe17 	ldw	r2,-8(fp)
}
 9084360:	e037883a 	mov	sp,fp
 9084364:	dfc00117 	ldw	ra,4(sp)
 9084368:	df000017 	ldw	fp,0(sp)
 908436c:	dec00204 	addi	sp,sp,8
 9084370:	f800283a 	ret

09084374 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9084374:	defffd04 	addi	sp,sp,-12
 9084378:	dfc00215 	stw	ra,8(sp)
 908437c:	df000115 	stw	fp,4(sp)
 9084380:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9084384:	00824274 	movhi	r2,2313
 9084388:	10b18404 	addi	r2,r2,-14832
 908438c:	10800017 	ldw	r2,0(r2)
 9084390:	1005003a 	cmpeq	r2,r2,zero
 9084394:	1000061e 	bne	r2,zero,90843b0 <alt_get_errno+0x3c>
 9084398:	00824274 	movhi	r2,2313
 908439c:	10b18404 	addi	r2,r2,-14832
 90843a0:	10800017 	ldw	r2,0(r2)
 90843a4:	103ee83a 	callr	r2
 90843a8:	e0bfff15 	stw	r2,-4(fp)
 90843ac:	00000306 	br	90843bc <alt_get_errno+0x48>
 90843b0:	00824274 	movhi	r2,2313
 90843b4:	10b18f04 	addi	r2,r2,-14788
 90843b8:	e0bfff15 	stw	r2,-4(fp)
 90843bc:	e0bfff17 	ldw	r2,-4(fp)
}
 90843c0:	e037883a 	mov	sp,fp
 90843c4:	dfc00117 	ldw	ra,4(sp)
 90843c8:	df000017 	ldw	fp,0(sp)
 90843cc:	dec00204 	addi	sp,sp,8
 90843d0:	f800283a 	ret

090843d4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 90843d4:	defffd04 	addi	sp,sp,-12
 90843d8:	dfc00215 	stw	ra,8(sp)
 90843dc:	df000115 	stw	fp,4(sp)
 90843e0:	df000104 	addi	fp,sp,4
 90843e4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 90843e8:	90898540 	call	9089854 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 90843ec:	00800044 	movi	r2,1
 90843f0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 90843f4:	e037883a 	mov	sp,fp
 90843f8:	dfc00117 	ldw	ra,4(sp)
 90843fc:	df000017 	ldw	fp,0(sp)
 9084400:	dec00204 	addi	sp,sp,8
 9084404:	f800283a 	ret

09084408 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 9084408:	defffe04 	addi	sp,sp,-8
 908440c:	dfc00115 	stw	ra,4(sp)
 9084410:	df000015 	stw	fp,0(sp)
 9084414:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 9084418:	01020034 	movhi	r4,2048
 908441c:	21001804 	addi	r4,r4,96
 9084420:	000b883a 	mov	r5,zero
 9084424:	000d883a 	mov	r6,zero
 9084428:	01c01904 	movi	r7,100
 908442c:	9088ac40 	call	9088ac4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 9084430:	01024274 	movhi	r4,2313
 9084434:	212ccd04 	addi	r4,r4,-19660
 9084438:	90844f40 	call	90844f4 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 908443c:	01024274 	movhi	r4,2313
 9084440:	212d0d04 	addi	r4,r4,-19404
 9084444:	000b883a 	mov	r5,zero
 9084448:	01800144 	movi	r6,5
 908444c:	90863bc0 	call	90863bc <altera_avalon_jtag_uart_init>
 9084450:	01024274 	movhi	r4,2313
 9084454:	212d0304 	addi	r4,r4,-19444
 9084458:	90844bc0 	call	90844bc <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 908445c:	01024274 	movhi	r4,2313
 9084460:	21312504 	addi	r4,r4,-15212
 9084464:	9087ac40 	call	9087ac4 <altera_avalon_lcd_16207_init>
 9084468:	01024274 	movhi	r4,2313
 908446c:	21311b04 	addi	r4,r4,-15252
 9084470:	90844bc0 	call	90844bc <alt_dev_reg>
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER, performance_counter);
 9084474:	00c20034 	movhi	r3,2048
 9084478:	00800044 	movi	r2,1
 908447c:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 9084480:	01024274 	movhi	r4,2313
 9084484:	21316304 	addi	r4,r4,-14964
 9084488:	000b883a 	mov	r5,zero
 908448c:	018000c4 	movi	r6,3
 9084490:	90889a80 	call	90889a8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 9084494:	01024274 	movhi	r4,2313
 9084498:	21316f04 	addi	r4,r4,-14916
 908449c:	000b883a 	mov	r5,zero
 90844a0:	01800084 	movi	r6,2
 90844a4:	90889a80 	call	90889a8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
}
 90844a8:	e037883a 	mov	sp,fp
 90844ac:	dfc00117 	ldw	ra,4(sp)
 90844b0:	df000017 	ldw	fp,0(sp)
 90844b4:	dec00204 	addi	sp,sp,8
 90844b8:	f800283a 	ret

090844bc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 90844bc:	defffd04 	addi	sp,sp,-12
 90844c0:	dfc00215 	stw	ra,8(sp)
 90844c4:	df000115 	stw	fp,4(sp)
 90844c8:	df000104 	addi	fp,sp,4
 90844cc:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 90844d0:	e13fff17 	ldw	r4,-4(fp)
 90844d4:	01424274 	movhi	r5,2313
 90844d8:	29718104 	addi	r5,r5,-14844
 90844dc:	9088d200 	call	9088d20 <alt_dev_llist_insert>
}
 90844e0:	e037883a 	mov	sp,fp
 90844e4:	dfc00117 	ldw	ra,4(sp)
 90844e8:	df000017 	ldw	fp,0(sp)
 90844ec:	dec00204 	addi	sp,sp,8
 90844f0:	f800283a 	ret

090844f4 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 90844f4:	defffc04 	addi	sp,sp,-16
 90844f8:	dfc00315 	stw	ra,12(sp)
 90844fc:	df000215 	stw	fp,8(sp)
 9084500:	df000204 	addi	fp,sp,8
 9084504:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 9084508:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 908450c:	e13fff17 	ldw	r4,-4(fp)
 9084510:	90859ec0 	call	90859ec <alt_read_cfi_width>
 9084514:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9084518:	e0bffe17 	ldw	r2,-8(fp)
 908451c:	1004c03a 	cmpne	r2,r2,zero
 9084520:	1000031e 	bne	r2,zero,9084530 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 9084524:	e13fff17 	ldw	r4,-4(fp)
 9084528:	90851040 	call	9085104 <alt_set_flash_width_func>
 908452c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9084530:	e0bffe17 	ldw	r2,-8(fp)
 9084534:	1004c03a 	cmpne	r2,r2,zero
 9084538:	1000031e 	bne	r2,zero,9084548 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 908453c:	e13fff17 	ldw	r4,-4(fp)
 9084540:	908540c0 	call	908540c <alt_read_cfi_table>
 9084544:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 9084548:	e0bffe17 	ldw	r2,-8(fp)
 908454c:	1004c03a 	cmpne	r2,r2,zero
 9084550:	1000031e 	bne	r2,zero,9084560 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 9084554:	e13fff17 	ldw	r4,-4(fp)
 9084558:	90852e40 	call	90852e4 <alt_set_flash_algorithm_func>
 908455c:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 9084560:	e0bffe17 	ldw	r2,-8(fp)
 9084564:	1004c03a 	cmpne	r2,r2,zero
 9084568:	1000031e 	bne	r2,zero,9084578 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 908456c:	e13fff17 	ldw	r4,-4(fp)
 9084570:	90845900 	call	9084590 <alt_flash_device_register>
 9084574:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 9084578:	e0bffe17 	ldw	r2,-8(fp)
}
 908457c:	e037883a 	mov	sp,fp
 9084580:	dfc00117 	ldw	ra,4(sp)
 9084584:	df000017 	ldw	fp,0(sp)
 9084588:	dec00204 	addi	sp,sp,8
 908458c:	f800283a 	ret

09084590 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 9084590:	defffd04 	addi	sp,sp,-12
 9084594:	dfc00215 	stw	ra,8(sp)
 9084598:	df000115 	stw	fp,4(sp)
 908459c:	df000104 	addi	fp,sp,4
 90845a0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 90845a4:	e13fff17 	ldw	r4,-4(fp)
 90845a8:	01424274 	movhi	r5,2313
 90845ac:	29718904 	addi	r5,r5,-14812
 90845b0:	9088d200 	call	9088d20 <alt_dev_llist_insert>
}
 90845b4:	e037883a 	mov	sp,fp
 90845b8:	dfc00117 	ldw	ra,4(sp)
 90845bc:	df000017 	ldw	fp,0(sp)
 90845c0:	dec00204 	addi	sp,sp,8
 90845c4:	f800283a 	ret

090845c8 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 90845c8:	deffef04 	addi	sp,sp,-68
 90845cc:	dfc01015 	stw	ra,64(sp)
 90845d0:	df000f15 	stw	fp,60(sp)
 90845d4:	df000f04 	addi	fp,sp,60
 90845d8:	e13ffa15 	stw	r4,-24(fp)
 90845dc:	e17ffb15 	stw	r5,-20(fp)
 90845e0:	e1bffc15 	stw	r6,-16(fp)
 90845e4:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 90845e8:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 90845ec:	e0bffd17 	ldw	r2,-12(fp)
 90845f0:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 90845f4:	e0bffb17 	ldw	r2,-20(fp)
 90845f8:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90845fc:	e0bffa17 	ldw	r2,-24(fp)
 9084600:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9084604:	e03ff815 	stw	zero,-32(fp)
 9084608:	00008e06 	br	9084844 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 908460c:	e0bff817 	ldw	r2,-32(fp)
 9084610:	e0fff217 	ldw	r3,-56(fp)
 9084614:	1004913a 	slli	r2,r2,4
 9084618:	10c5883a 	add	r2,r2,r3
 908461c:	10800d04 	addi	r2,r2,52
 9084620:	10c00017 	ldw	r3,0(r2)
 9084624:	e0bffb17 	ldw	r2,-20(fp)
 9084628:	10c08316 	blt	r2,r3,9084838 <alt_flash_cfi_write+0x270>
 908462c:	e0bff817 	ldw	r2,-32(fp)
 9084630:	e0fff217 	ldw	r3,-56(fp)
 9084634:	1004913a 	slli	r2,r2,4
 9084638:	10c5883a 	add	r2,r2,r3
 908463c:	10800d04 	addi	r2,r2,52
 9084640:	11000017 	ldw	r4,0(r2)
 9084644:	e0bff817 	ldw	r2,-32(fp)
 9084648:	e0fff217 	ldw	r3,-56(fp)
 908464c:	1004913a 	slli	r2,r2,4
 9084650:	10c5883a 	add	r2,r2,r3
 9084654:	10800e04 	addi	r2,r2,56
 9084658:	10800017 	ldw	r2,0(r2)
 908465c:	2087883a 	add	r3,r4,r2
 9084660:	e0bffb17 	ldw	r2,-20(fp)
 9084664:	10c0740e 	bge	r2,r3,9084838 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 9084668:	e0bff817 	ldw	r2,-32(fp)
 908466c:	e0fff217 	ldw	r3,-56(fp)
 9084670:	1004913a 	slli	r2,r2,4
 9084674:	10c5883a 	add	r2,r2,r3
 9084678:	10800d04 	addi	r2,r2,52
 908467c:	10800017 	ldw	r2,0(r2)
 9084680:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 9084684:	e03ff715 	stw	zero,-36(fp)
 9084688:	00006306 	br	9084818 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 908468c:	e0fffb17 	ldw	r3,-20(fp)
 9084690:	e0bff417 	ldw	r2,-48(fp)
 9084694:	18805416 	blt	r3,r2,90847e8 <alt_flash_cfi_write+0x220>
 9084698:	e0bff817 	ldw	r2,-32(fp)
 908469c:	e0fff217 	ldw	r3,-56(fp)
 90846a0:	1004913a 	slli	r2,r2,4
 90846a4:	10c5883a 	add	r2,r2,r3
 90846a8:	10801004 	addi	r2,r2,64
 90846ac:	10c00017 	ldw	r3,0(r2)
 90846b0:	e0bff417 	ldw	r2,-48(fp)
 90846b4:	1887883a 	add	r3,r3,r2
 90846b8:	e0bffb17 	ldw	r2,-20(fp)
 90846bc:	10c04a0e 	bge	r2,r3,90847e8 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 90846c0:	e0bff817 	ldw	r2,-32(fp)
 90846c4:	e0fff217 	ldw	r3,-56(fp)
 90846c8:	1004913a 	slli	r2,r2,4
 90846cc:	10c5883a 	add	r2,r2,r3
 90846d0:	10801004 	addi	r2,r2,64
 90846d4:	10c00017 	ldw	r3,0(r2)
 90846d8:	e0bff417 	ldw	r2,-48(fp)
 90846dc:	1887883a 	add	r3,r3,r2
 90846e0:	e0bffb17 	ldw	r2,-20(fp)
 90846e4:	1885c83a 	sub	r2,r3,r2
 90846e8:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 90846ec:	e0bff617 	ldw	r2,-40(fp)
 90846f0:	e0bfff15 	stw	r2,-4(fp)
 90846f4:	e0fffd17 	ldw	r3,-12(fp)
 90846f8:	e0fffe15 	stw	r3,-8(fp)
 90846fc:	e0bfff17 	ldw	r2,-4(fp)
 9084700:	e0fffe17 	ldw	r3,-8(fp)
 9084704:	10c0020e 	bge	r2,r3,9084710 <alt_flash_cfi_write+0x148>
 9084708:	e0bfff17 	ldw	r2,-4(fp)
 908470c:	e0bffe15 	stw	r2,-8(fp)
 9084710:	e0fffe17 	ldw	r3,-8(fp)
 9084714:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 9084718:	e0bff217 	ldw	r2,-56(fp)
 908471c:	10800a17 	ldw	r2,40(r2)
 9084720:	1007883a 	mov	r3,r2
 9084724:	e0bffb17 	ldw	r2,-20(fp)
 9084728:	188b883a 	add	r5,r3,r2
 908472c:	e1bff617 	ldw	r6,-40(fp)
 9084730:	e13ffc17 	ldw	r4,-16(fp)
 9084734:	908a2ac0 	call	908a2ac <memcmp>
 9084738:	1005003a 	cmpeq	r2,r2,zero
 908473c:	1000131e 	bne	r2,zero,908478c <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 9084740:	e0bff217 	ldw	r2,-56(fp)
 9084744:	10800817 	ldw	r2,32(r2)
 9084748:	e13ff217 	ldw	r4,-56(fp)
 908474c:	e17ff417 	ldw	r5,-48(fp)
 9084750:	103ee83a 	callr	r2
 9084754:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 9084758:	e0bff917 	ldw	r2,-28(fp)
 908475c:	1004c03a 	cmpne	r2,r2,zero
 9084760:	10000a1e 	bne	r2,zero,908478c <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 9084764:	e0bff217 	ldw	r2,-56(fp)
 9084768:	10c00917 	ldw	r3,36(r2)
 908476c:	e13ff217 	ldw	r4,-56(fp)
 9084770:	e0bff617 	ldw	r2,-40(fp)
 9084774:	d8800015 	stw	r2,0(sp)
 9084778:	e17ff417 	ldw	r5,-48(fp)
 908477c:	e1bffb17 	ldw	r6,-20(fp)
 9084780:	e1fffc17 	ldw	r7,-16(fp)
 9084784:	183ee83a 	callr	r3
 9084788:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 908478c:	e0fffd17 	ldw	r3,-12(fp)
 9084790:	e0bff617 	ldw	r2,-40(fp)
 9084794:	18802f26 	beq	r3,r2,9084854 <alt_flash_cfi_write+0x28c>
 9084798:	e0bff917 	ldw	r2,-28(fp)
 908479c:	1004c03a 	cmpne	r2,r2,zero
 90847a0:	10002c1e 	bne	r2,zero,9084854 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 90847a4:	e0fffd17 	ldw	r3,-12(fp)
 90847a8:	e0bff617 	ldw	r2,-40(fp)
 90847ac:	1885c83a 	sub	r2,r3,r2
 90847b0:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 90847b4:	e0bff817 	ldw	r2,-32(fp)
 90847b8:	e0fff217 	ldw	r3,-56(fp)
 90847bc:	1004913a 	slli	r2,r2,4
 90847c0:	10c5883a 	add	r2,r2,r3
 90847c4:	10801004 	addi	r2,r2,64
 90847c8:	10c00017 	ldw	r3,0(r2)
 90847cc:	e0bff417 	ldw	r2,-48(fp)
 90847d0:	1885883a 	add	r2,r3,r2
 90847d4:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 90847d8:	e0fffc17 	ldw	r3,-16(fp)
 90847dc:	e0bff617 	ldw	r2,-40(fp)
 90847e0:	1885883a 	add	r2,r3,r2
 90847e4:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 90847e8:	e0bff817 	ldw	r2,-32(fp)
 90847ec:	e0fff217 	ldw	r3,-56(fp)
 90847f0:	1004913a 	slli	r2,r2,4
 90847f4:	10c5883a 	add	r2,r2,r3
 90847f8:	10801004 	addi	r2,r2,64
 90847fc:	10c00017 	ldw	r3,0(r2)
 9084800:	e0bff417 	ldw	r2,-48(fp)
 9084804:	10c5883a 	add	r2,r2,r3
 9084808:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 908480c:	e0bff717 	ldw	r2,-36(fp)
 9084810:	10800044 	addi	r2,r2,1
 9084814:	e0bff715 	stw	r2,-36(fp)
 9084818:	e0bff817 	ldw	r2,-32(fp)
 908481c:	e0fff217 	ldw	r3,-56(fp)
 9084820:	1004913a 	slli	r2,r2,4
 9084824:	10c5883a 	add	r2,r2,r3
 9084828:	10800f04 	addi	r2,r2,60
 908482c:	10c00017 	ldw	r3,0(r2)
 9084830:	e0bff717 	ldw	r2,-36(fp)
 9084834:	10ff9516 	blt	r2,r3,908468c <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9084838:	e0bff817 	ldw	r2,-32(fp)
 908483c:	10800044 	addi	r2,r2,1
 9084840:	e0bff815 	stw	r2,-32(fp)
 9084844:	e0bff217 	ldw	r2,-56(fp)
 9084848:	10c00c17 	ldw	r3,48(r2)
 908484c:	e0bff817 	ldw	r2,-32(fp)
 9084850:	10ff6e16 	blt	r2,r3,908460c <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 9084854:	e0bff217 	ldw	r2,-56(fp)
 9084858:	10800a17 	ldw	r2,40(r2)
 908485c:	1007883a 	mov	r3,r2
 9084860:	e0bff317 	ldw	r2,-52(fp)
 9084864:	1889883a 	add	r4,r3,r2
 9084868:	e17ff517 	ldw	r5,-44(fp)
 908486c:	9088ca80 	call	9088ca8 <alt_dcache_flush>
  return ret_code;
 9084870:	e0bff917 	ldw	r2,-28(fp)
}
 9084874:	e037883a 	mov	sp,fp
 9084878:	dfc00117 	ldw	ra,4(sp)
 908487c:	df000017 	ldw	fp,0(sp)
 9084880:	dec00204 	addi	sp,sp,8
 9084884:	f800283a 	ret

09084888 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 9084888:	defffa04 	addi	sp,sp,-24
 908488c:	df000515 	stw	fp,20(sp)
 9084890:	df000504 	addi	fp,sp,20
 9084894:	e13ffd15 	stw	r4,-12(fp)
 9084898:	e17ffe15 	stw	r5,-8(fp)
 908489c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 90848a0:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 90848a4:	e0bffd17 	ldw	r2,-12(fp)
 90848a8:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 90848ac:	e0bffb17 	ldw	r2,-20(fp)
 90848b0:	10c00c17 	ldw	r3,48(r2)
 90848b4:	e0bfff17 	ldw	r2,-4(fp)
 90848b8:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 90848bc:	e0bffb17 	ldw	r2,-20(fp)
 90848c0:	10800c17 	ldw	r2,48(r2)
 90848c4:	1004c03a 	cmpne	r2,r2,zero
 90848c8:	1000031e 	bne	r2,zero,90848d8 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 90848cc:	00bffec4 	movi	r2,-5
 90848d0:	e0bffc15 	stw	r2,-16(fp)
 90848d4:	00000b06 	br	9084904 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 90848d8:	e0bffb17 	ldw	r2,-20(fp)
 90848dc:	10800c17 	ldw	r2,48(r2)
 90848e0:	10800250 	cmplti	r2,r2,9
 90848e4:	1000031e 	bne	r2,zero,90848f4 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 90848e8:	00bffd04 	movi	r2,-12
 90848ec:	e0bffc15 	stw	r2,-16(fp)
 90848f0:	00000406 	br	9084904 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 90848f4:	e0bffb17 	ldw	r2,-20(fp)
 90848f8:	10c00d04 	addi	r3,r2,52
 90848fc:	e0bffe17 	ldw	r2,-8(fp)
 9084900:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 9084904:	e0bffc17 	ldw	r2,-16(fp)
}
 9084908:	e037883a 	mov	sp,fp
 908490c:	df000017 	ldw	fp,0(sp)
 9084910:	dec00104 	addi	sp,sp,4
 9084914:	f800283a 	ret

09084918 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 9084918:	defff904 	addi	sp,sp,-28
 908491c:	dfc00615 	stw	ra,24(sp)
 9084920:	df000515 	stw	fp,20(sp)
 9084924:	df000504 	addi	fp,sp,20
 9084928:	e13ffc15 	stw	r4,-16(fp)
 908492c:	e17ffd15 	stw	r5,-12(fp)
 9084930:	e1bffe15 	stw	r6,-8(fp)
 9084934:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9084938:	e0bffc17 	ldw	r2,-16(fp)
 908493c:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 9084940:	e0bffb17 	ldw	r2,-20(fp)
 9084944:	10800a17 	ldw	r2,40(r2)
 9084948:	1007883a 	mov	r3,r2
 908494c:	e0bffd17 	ldw	r2,-12(fp)
 9084950:	1887883a 	add	r3,r3,r2
 9084954:	e1bfff17 	ldw	r6,-4(fp)
 9084958:	e0bffe17 	ldw	r2,-8(fp)
 908495c:	1009883a 	mov	r4,r2
 9084960:	180b883a 	mov	r5,r3
 9084964:	9082ca80 	call	9082ca8 <memcpy>
  return 0;
 9084968:	0005883a 	mov	r2,zero
}
 908496c:	e037883a 	mov	sp,fp
 9084970:	dfc00117 	ldw	ra,4(sp)
 9084974:	df000017 	ldw	fp,0(sp)
 9084978:	dec00204 	addi	sp,sp,8
 908497c:	f800283a 	ret

09084980 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 9084980:	defffa04 	addi	sp,sp,-24
 9084984:	df000515 	stw	fp,20(sp)
 9084988:	df000504 	addi	fp,sp,20
 908498c:	e13ffd15 	stw	r4,-12(fp)
 9084990:	e17ffe15 	stw	r5,-8(fp)
 9084994:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 9084998:	e0bffd17 	ldw	r2,-12(fp)
 908499c:	10802e17 	ldw	r2,184(r2)
 90849a0:	10800058 	cmpnei	r2,r2,1
 90849a4:	10000b1e 	bne	r2,zero,90849d4 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 90849a8:	e0bffd17 	ldw	r2,-12(fp)
 90849ac:	10800a17 	ldw	r2,40(r2)
 90849b0:	1007883a 	mov	r3,r2
 90849b4:	e0bffe17 	ldw	r2,-8(fp)
 90849b8:	1889883a 	add	r4,r3,r2
 90849bc:	e0bfff17 	ldw	r2,-4(fp)
 90849c0:	10800003 	ldbu	r2,0(r2)
 90849c4:	10c03fcc 	andi	r3,r2,255
 90849c8:	2005883a 	mov	r2,r4
 90849cc:	10c00025 	stbio	r3,0(r2)
 90849d0:	00004006 	br	9084ad4 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 90849d4:	e0bffd17 	ldw	r2,-12(fp)
 90849d8:	10802e17 	ldw	r2,184(r2)
 90849dc:	10800098 	cmpnei	r2,r2,2
 90849e0:	1000151e 	bne	r2,zero,9084a38 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 90849e4:	e0bfff17 	ldw	r2,-4(fp)
 90849e8:	10800003 	ldbu	r2,0(r2)
 90849ec:	10803fcc 	andi	r2,r2,255
 90849f0:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 90849f4:	e0bfff17 	ldw	r2,-4(fp)
 90849f8:	10800044 	addi	r2,r2,1
 90849fc:	10800003 	ldbu	r2,0(r2)
 9084a00:	10803fcc 	andi	r2,r2,255
 9084a04:	1004923a 	slli	r2,r2,8
 9084a08:	1007883a 	mov	r3,r2
 9084a0c:	e0bffc0b 	ldhu	r2,-16(fp)
 9084a10:	1884b03a 	or	r2,r3,r2
 9084a14:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 9084a18:	e0bffd17 	ldw	r2,-12(fp)
 9084a1c:	10800a17 	ldw	r2,40(r2)
 9084a20:	1007883a 	mov	r3,r2
 9084a24:	e0bffe17 	ldw	r2,-8(fp)
 9084a28:	1885883a 	add	r2,r3,r2
 9084a2c:	e0fffc0b 	ldhu	r3,-16(fp)
 9084a30:	10c0002d 	sthio	r3,0(r2)
 9084a34:	00002706 	br	9084ad4 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 9084a38:	e0bffd17 	ldw	r2,-12(fp)
 9084a3c:	10802e17 	ldw	r2,184(r2)
 9084a40:	10800118 	cmpnei	r2,r2,4
 9084a44:	1000231e 	bne	r2,zero,9084ad4 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 9084a48:	e0bfff17 	ldw	r2,-4(fp)
 9084a4c:	10800003 	ldbu	r2,0(r2)
 9084a50:	10803fcc 	andi	r2,r2,255
 9084a54:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 9084a58:	e0bfff17 	ldw	r2,-4(fp)
 9084a5c:	10800044 	addi	r2,r2,1
 9084a60:	10800003 	ldbu	r2,0(r2)
 9084a64:	10803fcc 	andi	r2,r2,255
 9084a68:	1006923a 	slli	r3,r2,8
 9084a6c:	e0bffb17 	ldw	r2,-20(fp)
 9084a70:	10c4b03a 	or	r2,r2,r3
 9084a74:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 9084a78:	e0bfff17 	ldw	r2,-4(fp)
 9084a7c:	10800084 	addi	r2,r2,2
 9084a80:	10800003 	ldbu	r2,0(r2)
 9084a84:	10803fcc 	andi	r2,r2,255
 9084a88:	1006943a 	slli	r3,r2,16
 9084a8c:	e0bffb17 	ldw	r2,-20(fp)
 9084a90:	10c4b03a 	or	r2,r2,r3
 9084a94:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 9084a98:	e0bfff17 	ldw	r2,-4(fp)
 9084a9c:	108000c4 	addi	r2,r2,3
 9084aa0:	10800003 	ldbu	r2,0(r2)
 9084aa4:	10803fcc 	andi	r2,r2,255
 9084aa8:	1006963a 	slli	r3,r2,24
 9084aac:	e0bffb17 	ldw	r2,-20(fp)
 9084ab0:	10c4b03a 	or	r2,r2,r3
 9084ab4:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 9084ab8:	e0bffd17 	ldw	r2,-12(fp)
 9084abc:	10800a17 	ldw	r2,40(r2)
 9084ac0:	1007883a 	mov	r3,r2
 9084ac4:	e0bffe17 	ldw	r2,-8(fp)
 9084ac8:	1885883a 	add	r2,r3,r2
 9084acc:	e0fffb17 	ldw	r3,-20(fp)
 9084ad0:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 9084ad4:	e037883a 	mov	sp,fp
 9084ad8:	df000017 	ldw	fp,0(sp)
 9084adc:	dec00104 	addi	sp,sp,4
 9084ae0:	f800283a 	ret

09084ae4 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 9084ae4:	defff304 	addi	sp,sp,-52
 9084ae8:	dfc00c15 	stw	ra,48(sp)
 9084aec:	df000b15 	stw	fp,44(sp)
 9084af0:	df000b04 	addi	fp,sp,44
 9084af4:	e13ffc15 	stw	r4,-16(fp)
 9084af8:	e17ffd15 	stw	r5,-12(fp)
 9084afc:	e1bffe15 	stw	r6,-8(fp)
 9084b00:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 9084b04:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 9084b08:	e0bffc17 	ldw	r2,-16(fp)
 9084b0c:	10800a17 	ldw	r2,40(r2)
 9084b10:	1007883a 	mov	r3,r2
 9084b14:	e0bffd17 	ldw	r2,-12(fp)
 9084b18:	1885883a 	add	r2,r3,r2
 9084b1c:	1009883a 	mov	r4,r2
 9084b20:	e0bffc17 	ldw	r2,-16(fp)
 9084b24:	10c02e17 	ldw	r3,184(r2)
 9084b28:	20c5283a 	div	r2,r4,r3
 9084b2c:	10c5383a 	mul	r2,r2,r3
 9084b30:	2085c83a 	sub	r2,r4,r2
 9084b34:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 9084b38:	e0bff917 	ldw	r2,-28(fp)
 9084b3c:	1005003a 	cmpeq	r2,r2,zero
 9084b40:	10003a1e 	bne	r2,zero,9084c2c <alt_flash_program_block+0x148>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 9084b44:	e0bffc17 	ldw	r2,-16(fp)
 9084b48:	10c02e17 	ldw	r3,184(r2)
 9084b4c:	e0bff917 	ldw	r2,-28(fp)
 9084b50:	1885c83a 	sub	r2,r3,r2
 9084b54:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9084b58:	e03ff615 	stw	zero,-40(fp)
 9084b5c:	00001206 	br	9084ba8 <alt_flash_program_block+0xc4>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 9084b60:	e17ff617 	ldw	r5,-40(fp)
 9084b64:	e0bffc17 	ldw	r2,-16(fp)
 9084b68:	10800a17 	ldw	r2,40(r2)
 9084b6c:	1009883a 	mov	r4,r2
 9084b70:	e0fffd17 	ldw	r3,-12(fp)
 9084b74:	e0bff917 	ldw	r2,-28(fp)
 9084b78:	1887c83a 	sub	r3,r3,r2
 9084b7c:	e0bff617 	ldw	r2,-40(fp)
 9084b80:	1885883a 	add	r2,r3,r2
 9084b84:	2085883a 	add	r2,r4,r2
 9084b88:	10800023 	ldbuio	r2,0(r2)
 9084b8c:	1007883a 	mov	r3,r2
 9084b90:	e0bffb04 	addi	r2,fp,-20
 9084b94:	1145883a 	add	r2,r2,r5
 9084b98:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9084b9c:	e0bff617 	ldw	r2,-40(fp)
 9084ba0:	10800044 	addi	r2,r2,1
 9084ba4:	e0bff615 	stw	r2,-40(fp)
 9084ba8:	e0fff617 	ldw	r3,-40(fp)
 9084bac:	e0bff917 	ldw	r2,-28(fp)
 9084bb0:	18bfeb16 	blt	r3,r2,9084b60 <alt_flash_program_block+0x7c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9084bb4:	e03ff615 	stw	zero,-40(fp)
 9084bb8:	00000e06 	br	9084bf4 <alt_flash_program_block+0x110>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 9084bbc:	e0fff917 	ldw	r3,-28(fp)
 9084bc0:	e0bff617 	ldw	r2,-40(fp)
 9084bc4:	1889883a 	add	r4,r3,r2
 9084bc8:	e0bff617 	ldw	r2,-40(fp)
 9084bcc:	1007883a 	mov	r3,r2
 9084bd0:	e0bffe17 	ldw	r2,-8(fp)
 9084bd4:	1885883a 	add	r2,r3,r2
 9084bd8:	10c00003 	ldbu	r3,0(r2)
 9084bdc:	e0bffb04 	addi	r2,fp,-20
 9084be0:	1105883a 	add	r2,r2,r4
 9084be4:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9084be8:	e0bff617 	ldw	r2,-40(fp)
 9084bec:	10800044 	addi	r2,r2,1
 9084bf0:	e0bff615 	stw	r2,-40(fp)
 9084bf4:	e0fff617 	ldw	r3,-40(fp)
 9084bf8:	e0bff817 	ldw	r2,-32(fp)
 9084bfc:	18bfef16 	blt	r3,r2,9084bbc <alt_flash_program_block+0xd8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 9084c00:	e0fffd17 	ldw	r3,-12(fp)
 9084c04:	e0bff917 	ldw	r2,-28(fp)
 9084c08:	188bc83a 	sub	r5,r3,r2
 9084c0c:	e1bffb04 	addi	r6,fp,-20
 9084c10:	e0800217 	ldw	r2,8(fp)
 9084c14:	e13ffc17 	ldw	r4,-16(fp)
 9084c18:	103ee83a 	callr	r2
 9084c1c:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 9084c20:	e0bff817 	ldw	r2,-32(fp)
 9084c24:	e0bff615 	stw	r2,-40(fp)
 9084c28:	00000106 	br	9084c30 <alt_flash_program_block+0x14c>
  }
  else
  {
    i = 0;
 9084c2c:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 9084c30:	e0fffd17 	ldw	r3,-12(fp)
 9084c34:	e0bfff17 	ldw	r2,-4(fp)
 9084c38:	1889883a 	add	r4,r3,r2
 9084c3c:	e0bffc17 	ldw	r2,-16(fp)
 9084c40:	10c02e17 	ldw	r3,184(r2)
 9084c44:	20c5283a 	div	r2,r4,r3
 9084c48:	10c5383a 	mul	r2,r2,r3
 9084c4c:	2085c83a 	sub	r2,r4,r2
 9084c50:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9084c54:	00001006 	br	9084c98 <alt_flash_program_block+0x1b4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 9084c58:	e0fffd17 	ldw	r3,-12(fp)
 9084c5c:	e0bff617 	ldw	r2,-40(fp)
 9084c60:	188b883a 	add	r5,r3,r2
 9084c64:	e0bff617 	ldw	r2,-40(fp)
 9084c68:	1007883a 	mov	r3,r2
 9084c6c:	e0bffe17 	ldw	r2,-8(fp)
 9084c70:	188d883a 	add	r6,r3,r2
 9084c74:	e0800217 	ldw	r2,8(fp)
 9084c78:	e13ffc17 	ldw	r4,-16(fp)
 9084c7c:	103ee83a 	callr	r2
 9084c80:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 9084c84:	e0bffc17 	ldw	r2,-16(fp)
 9084c88:	10c02e17 	ldw	r3,184(r2)
 9084c8c:	e0bff617 	ldw	r2,-40(fp)
 9084c90:	10c5883a 	add	r2,r2,r3
 9084c94:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9084c98:	e0bffa17 	ldw	r2,-24(fp)
 9084c9c:	1004c03a 	cmpne	r2,r2,zero
 9084ca0:	1000051e 	bne	r2,zero,9084cb8 <alt_flash_program_block+0x1d4>
 9084ca4:	e0ffff17 	ldw	r3,-4(fp)
 9084ca8:	e0bff717 	ldw	r2,-36(fp)
 9084cac:	1887c83a 	sub	r3,r3,r2
 9084cb0:	e0bff617 	ldw	r2,-40(fp)
 9084cb4:	10ffe816 	blt	r2,r3,9084c58 <alt_flash_program_block+0x174>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 9084cb8:	e0bff717 	ldw	r2,-36(fp)
 9084cbc:	1005003a 	cmpeq	r2,r2,zero
 9084cc0:	10003c1e 	bne	r2,zero,9084db4 <alt_flash_program_block+0x2d0>
 9084cc4:	e0bffa17 	ldw	r2,-24(fp)
 9084cc8:	1004c03a 	cmpne	r2,r2,zero
 9084ccc:	1000391e 	bne	r2,zero,9084db4 <alt_flash_program_block+0x2d0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 9084cd0:	e0bffc17 	ldw	r2,-16(fp)
 9084cd4:	10c02e17 	ldw	r3,184(r2)
 9084cd8:	e0bff717 	ldw	r2,-36(fp)
 9084cdc:	1885c83a 	sub	r2,r3,r2
 9084ce0:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 9084ce4:	e03ff515 	stw	zero,-44(fp)
 9084ce8:	00000e06 	br	9084d24 <alt_flash_program_block+0x240>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 9084cec:	e13ff517 	ldw	r4,-44(fp)
 9084cf0:	e0bff617 	ldw	r2,-40(fp)
 9084cf4:	1007883a 	mov	r3,r2
 9084cf8:	e0bffe17 	ldw	r2,-8(fp)
 9084cfc:	1887883a 	add	r3,r3,r2
 9084d00:	e0bff517 	ldw	r2,-44(fp)
 9084d04:	1885883a 	add	r2,r3,r2
 9084d08:	10c00003 	ldbu	r3,0(r2)
 9084d0c:	e0bffb04 	addi	r2,fp,-20
 9084d10:	1105883a 	add	r2,r2,r4
 9084d14:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 9084d18:	e0bff517 	ldw	r2,-44(fp)
 9084d1c:	10800044 	addi	r2,r2,1
 9084d20:	e0bff515 	stw	r2,-44(fp)
 9084d24:	e0fff517 	ldw	r3,-44(fp)
 9084d28:	e0bff717 	ldw	r2,-36(fp)
 9084d2c:	18bfef16 	blt	r3,r2,9084cec <alt_flash_program_block+0x208>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9084d30:	e03ff515 	stw	zero,-44(fp)
 9084d34:	00001406 	br	9084d88 <alt_flash_program_block+0x2a4>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 9084d38:	e0fff717 	ldw	r3,-36(fp)
 9084d3c:	e0bff517 	ldw	r2,-44(fp)
 9084d40:	188b883a 	add	r5,r3,r2
 9084d44:	e0bffc17 	ldw	r2,-16(fp)
 9084d48:	10800a17 	ldw	r2,40(r2)
 9084d4c:	1009883a 	mov	r4,r2
 9084d50:	e0fffd17 	ldw	r3,-12(fp)
 9084d54:	e0bfff17 	ldw	r2,-4(fp)
 9084d58:	1887883a 	add	r3,r3,r2
 9084d5c:	e0bff517 	ldw	r2,-44(fp)
 9084d60:	1885883a 	add	r2,r3,r2
 9084d64:	2085883a 	add	r2,r4,r2
 9084d68:	10800023 	ldbuio	r2,0(r2)
 9084d6c:	1007883a 	mov	r3,r2
 9084d70:	e0bffb04 	addi	r2,fp,-20
 9084d74:	1145883a 	add	r2,r2,r5
 9084d78:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9084d7c:	e0bff517 	ldw	r2,-44(fp)
 9084d80:	10800044 	addi	r2,r2,1
 9084d84:	e0bff515 	stw	r2,-44(fp)
 9084d88:	e0fff517 	ldw	r3,-44(fp)
 9084d8c:	e0bff917 	ldw	r2,-28(fp)
 9084d90:	18bfe916 	blt	r3,r2,9084d38 <alt_flash_program_block+0x254>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 9084d94:	e0fffd17 	ldw	r3,-12(fp)
 9084d98:	e0bff617 	ldw	r2,-40(fp)
 9084d9c:	188b883a 	add	r5,r3,r2
 9084da0:	e1bffb04 	addi	r6,fp,-20
 9084da4:	e0800217 	ldw	r2,8(fp)
 9084da8:	e13ffc17 	ldw	r4,-16(fp)
 9084dac:	103ee83a 	callr	r2
 9084db0:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 9084db4:	e0bffa17 	ldw	r2,-24(fp)
}
 9084db8:	e037883a 	mov	sp,fp
 9084dbc:	dfc00117 	ldw	ra,4(sp)
 9084dc0:	df000017 	ldw	fp,0(sp)
 9084dc4:	dec00204 	addi	sp,sp,8
 9084dc8:	f800283a 	ret

09084dcc <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 9084dcc:	defffd04 	addi	sp,sp,-12
 9084dd0:	df000215 	stw	fp,8(sp)
 9084dd4:	df000204 	addi	fp,sp,8
 9084dd8:	e13ffe15 	stw	r4,-8(fp)
 9084ddc:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 9084de0:	e0bffe17 	ldw	r2,-8(fp)
 9084de4:	10800a17 	ldw	r2,40(r2)
 9084de8:	1007883a 	mov	r3,r2
 9084dec:	e0bfff17 	ldw	r2,-4(fp)
 9084df0:	1885883a 	add	r2,r3,r2
 9084df4:	10800023 	ldbuio	r2,0(r2)
 9084df8:	10803fcc 	andi	r2,r2,255
}
 9084dfc:	e037883a 	mov	sp,fp
 9084e00:	df000017 	ldw	fp,0(sp)
 9084e04:	dec00104 	addi	sp,sp,4
 9084e08:	f800283a 	ret

09084e0c <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 9084e0c:	defffd04 	addi	sp,sp,-12
 9084e10:	df000215 	stw	fp,8(sp)
 9084e14:	df000204 	addi	fp,sp,8
 9084e18:	e13ffe15 	stw	r4,-8(fp)
 9084e1c:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 9084e20:	e0bffe17 	ldw	r2,-8(fp)
 9084e24:	10800a17 	ldw	r2,40(r2)
 9084e28:	1007883a 	mov	r3,r2
 9084e2c:	e0bfff17 	ldw	r2,-4(fp)
 9084e30:	1085883a 	add	r2,r2,r2
 9084e34:	1885883a 	add	r2,r3,r2
 9084e38:	1080002b 	ldhuio	r2,0(r2)
 9084e3c:	10803fcc 	andi	r2,r2,255
}
 9084e40:	e037883a 	mov	sp,fp
 9084e44:	df000017 	ldw	fp,0(sp)
 9084e48:	dec00104 	addi	sp,sp,4
 9084e4c:	f800283a 	ret

09084e50 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 9084e50:	defffd04 	addi	sp,sp,-12
 9084e54:	df000215 	stw	fp,8(sp)
 9084e58:	df000204 	addi	fp,sp,8
 9084e5c:	e13ffe15 	stw	r4,-8(fp)
 9084e60:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 9084e64:	e0bffe17 	ldw	r2,-8(fp)
 9084e68:	10800a17 	ldw	r2,40(r2)
 9084e6c:	1007883a 	mov	r3,r2
 9084e70:	e0bfff17 	ldw	r2,-4(fp)
 9084e74:	1085883a 	add	r2,r2,r2
 9084e78:	1085883a 	add	r2,r2,r2
 9084e7c:	1885883a 	add	r2,r3,r2
 9084e80:	10800037 	ldwio	r2,0(r2)
 9084e84:	10803fcc 	andi	r2,r2,255
}
 9084e88:	e037883a 	mov	sp,fp
 9084e8c:	df000017 	ldw	fp,0(sp)
 9084e90:	dec00104 	addi	sp,sp,4
 9084e94:	f800283a 	ret

09084e98 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9084e98:	defffc04 	addi	sp,sp,-16
 9084e9c:	df000315 	stw	fp,12(sp)
 9084ea0:	df000304 	addi	fp,sp,12
 9084ea4:	e13ffd15 	stw	r4,-12(fp)
 9084ea8:	e17ffe15 	stw	r5,-8(fp)
 9084eac:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 9084eb0:	e0fffd17 	ldw	r3,-12(fp)
 9084eb4:	e0bffe17 	ldw	r2,-8(fp)
 9084eb8:	1885883a 	add	r2,r3,r2
 9084ebc:	e0ffff03 	ldbu	r3,-4(fp)
 9084ec0:	10c00025 	stbio	r3,0(r2)
  return;
}
 9084ec4:	e037883a 	mov	sp,fp
 9084ec8:	df000017 	ldw	fp,0(sp)
 9084ecc:	dec00104 	addi	sp,sp,4
 9084ed0:	f800283a 	ret

09084ed4 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9084ed4:	defffc04 	addi	sp,sp,-16
 9084ed8:	df000315 	stw	fp,12(sp)
 9084edc:	df000304 	addi	fp,sp,12
 9084ee0:	e13ffd15 	stw	r4,-12(fp)
 9084ee4:	e17ffe15 	stw	r5,-8(fp)
 9084ee8:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 9084eec:	e0bffe17 	ldw	r2,-8(fp)
 9084ef0:	1080004c 	andi	r2,r2,1
 9084ef4:	10803fcc 	andi	r2,r2,255
 9084ef8:	1005003a 	cmpeq	r2,r2,zero
 9084efc:	1000081e 	bne	r2,zero,9084f20 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 9084f00:	e0bffe17 	ldw	r2,-8(fp)
 9084f04:	1085883a 	add	r2,r2,r2
 9084f08:	1007883a 	mov	r3,r2
 9084f0c:	e0bffd17 	ldw	r2,-12(fp)
 9084f10:	1885883a 	add	r2,r3,r2
 9084f14:	e0ffff03 	ldbu	r3,-4(fp)
 9084f18:	10c00025 	stbio	r3,0(r2)
 9084f1c:	00000806 	br	9084f40 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 9084f20:	e0bffe17 	ldw	r2,-8(fp)
 9084f24:	1085883a 	add	r2,r2,r2
 9084f28:	1007883a 	mov	r3,r2
 9084f2c:	e0bffd17 	ldw	r2,-12(fp)
 9084f30:	1885883a 	add	r2,r3,r2
 9084f34:	10800044 	addi	r2,r2,1
 9084f38:	e0ffff03 	ldbu	r3,-4(fp)
 9084f3c:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 9084f40:	e037883a 	mov	sp,fp
 9084f44:	df000017 	ldw	fp,0(sp)
 9084f48:	dec00104 	addi	sp,sp,4
 9084f4c:	f800283a 	ret

09084f50 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9084f50:	defffc04 	addi	sp,sp,-16
 9084f54:	df000315 	stw	fp,12(sp)
 9084f58:	df000304 	addi	fp,sp,12
 9084f5c:	e13ffd15 	stw	r4,-12(fp)
 9084f60:	e17ffe15 	stw	r5,-8(fp)
 9084f64:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 9084f68:	e0bffe17 	ldw	r2,-8(fp)
 9084f6c:	1085883a 	add	r2,r2,r2
 9084f70:	1085883a 	add	r2,r2,r2
 9084f74:	1007883a 	mov	r3,r2
 9084f78:	e0bffd17 	ldw	r2,-12(fp)
 9084f7c:	1885883a 	add	r2,r3,r2
 9084f80:	e0ffff03 	ldbu	r3,-4(fp)
 9084f84:	10c00025 	stbio	r3,0(r2)
  return;
}
 9084f88:	e037883a 	mov	sp,fp
 9084f8c:	df000017 	ldw	fp,0(sp)
 9084f90:	dec00104 	addi	sp,sp,4
 9084f94:	f800283a 	ret

09084f98 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9084f98:	defffc04 	addi	sp,sp,-16
 9084f9c:	df000315 	stw	fp,12(sp)
 9084fa0:	df000304 	addi	fp,sp,12
 9084fa4:	e13ffd15 	stw	r4,-12(fp)
 9084fa8:	e17ffe15 	stw	r5,-8(fp)
 9084fac:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 9084fb0:	e0bffe17 	ldw	r2,-8(fp)
 9084fb4:	1085883a 	add	r2,r2,r2
 9084fb8:	1007883a 	mov	r3,r2
 9084fbc:	e0bffd17 	ldw	r2,-12(fp)
 9084fc0:	1885883a 	add	r2,r3,r2
 9084fc4:	e0ffff03 	ldbu	r3,-4(fp)
 9084fc8:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9084fcc:	e037883a 	mov	sp,fp
 9084fd0:	df000017 	ldw	fp,0(sp)
 9084fd4:	dec00104 	addi	sp,sp,4
 9084fd8:	f800283a 	ret

09084fdc <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9084fdc:	defffc04 	addi	sp,sp,-16
 9084fe0:	df000315 	stw	fp,12(sp)
 9084fe4:	df000304 	addi	fp,sp,12
 9084fe8:	e13ffd15 	stw	r4,-12(fp)
 9084fec:	e17ffe15 	stw	r5,-8(fp)
 9084ff0:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 9084ff4:	e0bffe17 	ldw	r2,-8(fp)
 9084ff8:	1085883a 	add	r2,r2,r2
 9084ffc:	1085883a 	add	r2,r2,r2
 9085000:	1007883a 	mov	r3,r2
 9085004:	e0bffd17 	ldw	r2,-12(fp)
 9085008:	1885883a 	add	r2,r3,r2
 908500c:	e0ffff03 	ldbu	r3,-4(fp)
 9085010:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9085014:	e037883a 	mov	sp,fp
 9085018:	df000017 	ldw	fp,0(sp)
 908501c:	dec00104 	addi	sp,sp,4
 9085020:	f800283a 	ret

09085024 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9085024:	defffc04 	addi	sp,sp,-16
 9085028:	df000315 	stw	fp,12(sp)
 908502c:	df000304 	addi	fp,sp,12
 9085030:	e13ffd15 	stw	r4,-12(fp)
 9085034:	e17ffe15 	stw	r5,-8(fp)
 9085038:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 908503c:	e0bffe17 	ldw	r2,-8(fp)
 9085040:	1085883a 	add	r2,r2,r2
 9085044:	1085883a 	add	r2,r2,r2
 9085048:	1007883a 	mov	r3,r2
 908504c:	e0bffd17 	ldw	r2,-12(fp)
 9085050:	1885883a 	add	r2,r3,r2
 9085054:	e0ffff03 	ldbu	r3,-4(fp)
 9085058:	10c00035 	stwio	r3,0(r2)
  return;
}
 908505c:	e037883a 	mov	sp,fp
 9085060:	df000017 	ldw	fp,0(sp)
 9085064:	dec00104 	addi	sp,sp,4
 9085068:	f800283a 	ret

0908506c <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 908506c:	defffd04 	addi	sp,sp,-12
 9085070:	df000215 	stw	fp,8(sp)
 9085074:	df000204 	addi	fp,sp,8
 9085078:	e13ffe15 	stw	r4,-8(fp)
 908507c:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 9085080:	e0bfff17 	ldw	r2,-4(fp)
 9085084:	10c03fcc 	andi	r3,r2,255
 9085088:	e0bffe17 	ldw	r2,-8(fp)
 908508c:	10c00025 	stbio	r3,0(r2)
  return;
}
 9085090:	e037883a 	mov	sp,fp
 9085094:	df000017 	ldw	fp,0(sp)
 9085098:	dec00104 	addi	sp,sp,4
 908509c:	f800283a 	ret

090850a0 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 90850a0:	defffd04 	addi	sp,sp,-12
 90850a4:	df000215 	stw	fp,8(sp)
 90850a8:	df000204 	addi	fp,sp,8
 90850ac:	e13ffe15 	stw	r4,-8(fp)
 90850b0:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 90850b4:	e0bfff17 	ldw	r2,-4(fp)
 90850b8:	10ffffcc 	andi	r3,r2,65535
 90850bc:	e0bffe17 	ldw	r2,-8(fp)
 90850c0:	10c0002d 	sthio	r3,0(r2)
  return;
}
 90850c4:	e037883a 	mov	sp,fp
 90850c8:	df000017 	ldw	fp,0(sp)
 90850cc:	dec00104 	addi	sp,sp,4
 90850d0:	f800283a 	ret

090850d4 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 90850d4:	defffd04 	addi	sp,sp,-12
 90850d8:	df000215 	stw	fp,8(sp)
 90850dc:	df000204 	addi	fp,sp,8
 90850e0:	e13ffe15 	stw	r4,-8(fp)
 90850e4:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 90850e8:	e0ffff17 	ldw	r3,-4(fp)
 90850ec:	e0bffe17 	ldw	r2,-8(fp)
 90850f0:	10c00035 	stwio	r3,0(r2)
  return;
}
 90850f4:	e037883a 	mov	sp,fp
 90850f8:	df000017 	ldw	fp,0(sp)
 90850fc:	dec00104 	addi	sp,sp,4
 9085100:	f800283a 	ret

09085104 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 9085104:	defffb04 	addi	sp,sp,-20
 9085108:	df000415 	stw	fp,16(sp)
 908510c:	df000404 	addi	fp,sp,16
 9085110:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 9085114:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 9085118:	e0bffd17 	ldw	r2,-12(fp)
 908511c:	10802e17 	ldw	r2,184(r2)
 9085120:	e0bfff15 	stw	r2,-4(fp)
 9085124:	e0ffff17 	ldw	r3,-4(fp)
 9085128:	188000a0 	cmpeqi	r2,r3,2
 908512c:	1000261e 	bne	r2,zero,90851c8 <alt_set_flash_width_func+0xc4>
 9085130:	e0ffff17 	ldw	r3,-4(fp)
 9085134:	18800120 	cmpeqi	r2,r3,4
 9085138:	1000391e 	bne	r2,zero,9085220 <alt_set_flash_width_func+0x11c>
 908513c:	e0ffff17 	ldw	r3,-4(fp)
 9085140:	18800060 	cmpeqi	r2,r3,1
 9085144:	1000011e 	bne	r2,zero,908514c <alt_set_flash_width_func+0x48>
 9085148:	00003e06 	br	9085244 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 908514c:	e0fffd17 	ldw	r3,-12(fp)
 9085150:	00824234 	movhi	r2,2312
 9085154:	10941b04 	addi	r2,r2,20588
 9085158:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 908515c:	e0bffd17 	ldw	r2,-12(fp)
 9085160:	10802f17 	ldw	r2,188(r2)
 9085164:	10800058 	cmpnei	r2,r2,1
 9085168:	1000051e 	bne	r2,zero,9085180 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 908516c:	e0fffd17 	ldw	r3,-12(fp)
 9085170:	00824234 	movhi	r2,2312
 9085174:	1093a604 	addi	r2,r2,20120
 9085178:	18803315 	stw	r2,204(r3)
 908517c:	00003306 	br	908524c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 9085180:	e0bffd17 	ldw	r2,-12(fp)
 9085184:	10802f17 	ldw	r2,188(r2)
 9085188:	10800098 	cmpnei	r2,r2,2
 908518c:	1000051e 	bne	r2,zero,90851a4 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 9085190:	e0fffd17 	ldw	r3,-12(fp)
 9085194:	00824234 	movhi	r2,2312
 9085198:	1093b504 	addi	r2,r2,20180
 908519c:	18803315 	stw	r2,204(r3)
 90851a0:	00002a06 	br	908524c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 90851a4:	e0bffd17 	ldw	r2,-12(fp)
 90851a8:	10802f17 	ldw	r2,188(r2)
 90851ac:	10800118 	cmpnei	r2,r2,4
 90851b0:	1000261e 	bne	r2,zero,908524c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 90851b4:	e0fffd17 	ldw	r3,-12(fp)
 90851b8:	00824234 	movhi	r2,2312
 90851bc:	1093d404 	addi	r2,r2,20304
 90851c0:	18803315 	stw	r2,204(r3)
      }
      break;
 90851c4:	00002106 	br	908524c <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 90851c8:	e0fffd17 	ldw	r3,-12(fp)
 90851cc:	00824234 	movhi	r2,2312
 90851d0:	10942804 	addi	r2,r2,20640
 90851d4:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 90851d8:	e0bffd17 	ldw	r2,-12(fp)
 90851dc:	10802f17 	ldw	r2,188(r2)
 90851e0:	10800098 	cmpnei	r2,r2,2
 90851e4:	1000051e 	bne	r2,zero,90851fc <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 90851e8:	e0fffd17 	ldw	r3,-12(fp)
 90851ec:	00824234 	movhi	r2,2312
 90851f0:	1093e604 	addi	r2,r2,20376
 90851f4:	18803315 	stw	r2,204(r3)
 90851f8:	00001406 	br	908524c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 90851fc:	e0bffd17 	ldw	r2,-12(fp)
 9085200:	10802f17 	ldw	r2,188(r2)
 9085204:	10800118 	cmpnei	r2,r2,4
 9085208:	1000101e 	bne	r2,zero,908524c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 908520c:	e0fffd17 	ldw	r3,-12(fp)
 9085210:	00824234 	movhi	r2,2312
 9085214:	1093f704 	addi	r2,r2,20444
 9085218:	18803315 	stw	r2,204(r3)
      }

      break;
 908521c:	00000b06 	br	908524c <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 9085220:	e0fffd17 	ldw	r3,-12(fp)
 9085224:	00824234 	movhi	r2,2312
 9085228:	10943504 	addi	r2,r2,20692
 908522c:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 9085230:	e0fffd17 	ldw	r3,-12(fp)
 9085234:	00824234 	movhi	r2,2312
 9085238:	10940904 	addi	r2,r2,20516
 908523c:	18803315 	stw	r2,204(r3)
      break;
 9085240:	00000206 	br	908524c <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 9085244:	00bffcc4 	movi	r2,-13
 9085248:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 908524c:	e0bffc17 	ldw	r2,-16(fp)
 9085250:	1004c03a 	cmpne	r2,r2,zero
 9085254:	10001e1e 	bne	r2,zero,90852d0 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 9085258:	e0bffd17 	ldw	r2,-12(fp)
 908525c:	10802f17 	ldw	r2,188(r2)
 9085260:	e0bffe15 	stw	r2,-8(fp)
 9085264:	e0fffe17 	ldw	r3,-8(fp)
 9085268:	188000a0 	cmpeqi	r2,r3,2
 908526c:	10000c1e 	bne	r2,zero,90852a0 <alt_set_flash_width_func+0x19c>
 9085270:	e0fffe17 	ldw	r3,-8(fp)
 9085274:	18800120 	cmpeqi	r2,r3,4
 9085278:	10000e1e 	bne	r2,zero,90852b4 <alt_set_flash_width_func+0x1b0>
 908527c:	e0fffe17 	ldw	r3,-8(fp)
 9085280:	18800060 	cmpeqi	r2,r3,1
 9085284:	1000011e 	bne	r2,zero,908528c <alt_set_flash_width_func+0x188>
 9085288:	00000f06 	br	90852c8 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 908528c:	e0fffd17 	ldw	r3,-12(fp)
 9085290:	00824234 	movhi	r2,2312
 9085294:	10937304 	addi	r2,r2,19916
 9085298:	18803415 	stw	r2,208(r3)
        break;
 908529c:	00000c06 	br	90852d0 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 90852a0:	e0fffd17 	ldw	r3,-12(fp)
 90852a4:	00824234 	movhi	r2,2312
 90852a8:	10938304 	addi	r2,r2,19980
 90852ac:	18803415 	stw	r2,208(r3)
        break;
 90852b0:	00000706 	br	90852d0 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 90852b4:	e0fffd17 	ldw	r3,-12(fp)
 90852b8:	00824234 	movhi	r2,2312
 90852bc:	10939404 	addi	r2,r2,20048
 90852c0:	18803415 	stw	r2,208(r3)
        break;
 90852c4:	00000206 	br	90852d0 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 90852c8:	00bffcc4 	movi	r2,-13
 90852cc:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 90852d0:	e0bffc17 	ldw	r2,-16(fp)
}
 90852d4:	e037883a 	mov	sp,fp
 90852d8:	df000017 	ldw	fp,0(sp)
 90852dc:	dec00104 	addi	sp,sp,4
 90852e0:	f800283a 	ret

090852e4 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 90852e4:	defffc04 	addi	sp,sp,-16
 90852e8:	df000315 	stw	fp,12(sp)
 90852ec:	df000304 	addi	fp,sp,12
 90852f0:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 90852f4:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 90852f8:	e0bffe17 	ldw	r2,-8(fp)
 90852fc:	10802d17 	ldw	r2,180(r2)
 9085300:	e0bfff15 	stw	r2,-4(fp)
 9085304:	e0ffff17 	ldw	r3,-4(fp)
 9085308:	188000a0 	cmpeqi	r2,r3,2
 908530c:	1000071e 	bne	r2,zero,908532c <alt_set_flash_algorithm_func+0x48>
 9085310:	e0ffff17 	ldw	r3,-4(fp)
 9085314:	188000e0 	cmpeqi	r2,r3,3
 9085318:	10000d1e 	bne	r2,zero,9085350 <alt_set_flash_algorithm_func+0x6c>
 908531c:	e0ffff17 	ldw	r3,-4(fp)
 9085320:	18800060 	cmpeqi	r2,r3,1
 9085324:	10000a1e 	bne	r2,zero,9085350 <alt_set_flash_algorithm_func+0x6c>
 9085328:	00001206 	br	9085374 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 908532c:	e0fffe17 	ldw	r3,-8(fp)
 9085330:	00824274 	movhi	r2,2313
 9085334:	10a63704 	addi	r2,r2,-26404
 9085338:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 908533c:	e0fffe17 	ldw	r3,-8(fp)
 9085340:	00824274 	movhi	r2,2313
 9085344:	10a61d04 	addi	r2,r2,-26508
 9085348:	18800915 	stw	r2,36(r3)
      break;
 908534c:	00000b06 	br	908537c <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 9085350:	e0fffe17 	ldw	r3,-8(fp)
 9085354:	00824274 	movhi	r2,2313
 9085358:	10a75604 	addi	r2,r2,-25256
 908535c:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 9085360:	e0fffe17 	ldw	r3,-8(fp)
 9085364:	00824274 	movhi	r2,2313
 9085368:	10a73504 	addi	r2,r2,-25388
 908536c:	18800915 	stw	r2,36(r3)
      break;
 9085370:	00000206 	br	908537c <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 9085374:	00bffec4 	movi	r2,-5
 9085378:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 908537c:	e0bffd17 	ldw	r2,-12(fp)
}
 9085380:	e037883a 	mov	sp,fp
 9085384:	df000017 	ldw	fp,0(sp)
 9085388:	dec00104 	addi	sp,sp,4
 908538c:	f800283a 	ret

09085390 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 9085390:	defffb04 	addi	sp,sp,-20
 9085394:	dfc00415 	stw	ra,16(sp)
 9085398:	df000315 	stw	fp,12(sp)
 908539c:	df000304 	addi	fp,sp,12
 90853a0:	e13ffe15 	stw	r4,-8(fp)
 90853a4:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 90853a8:	e0bffe17 	ldw	r2,-8(fp)
 90853ac:	10803417 	ldw	r2,208(r2)
 90853b0:	e13ffe17 	ldw	r4,-8(fp)
 90853b4:	e17fff17 	ldw	r5,-4(fp)
 90853b8:	103ee83a 	callr	r2
 90853bc:	10803fcc 	andi	r2,r2,255
 90853c0:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 90853c4:	e0bffe17 	ldw	r2,-8(fp)
 90853c8:	10c03417 	ldw	r3,208(r2)
 90853cc:	e0bfff17 	ldw	r2,-4(fp)
 90853d0:	11400044 	addi	r5,r2,1
 90853d4:	e13ffe17 	ldw	r4,-8(fp)
 90853d8:	183ee83a 	callr	r3
 90853dc:	10803fcc 	andi	r2,r2,255
 90853e0:	1004923a 	slli	r2,r2,8
 90853e4:	1007883a 	mov	r3,r2
 90853e8:	e0bffd0b 	ldhu	r2,-12(fp)
 90853ec:	1884b03a 	or	r2,r3,r2
 90853f0:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 90853f4:	e0bffd0b 	ldhu	r2,-12(fp)
}
 90853f8:	e037883a 	mov	sp,fp
 90853fc:	dfc00117 	ldw	ra,4(sp)
 9085400:	df000017 	ldw	fp,0(sp)
 9085404:	dec00204 	addi	sp,sp,8
 9085408:	f800283a 	ret

0908540c <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 908540c:	defff104 	addi	sp,sp,-60
 9085410:	dfc00e15 	stw	ra,56(sp)
 9085414:	df000d15 	stw	fp,52(sp)
 9085418:	dc000c15 	stw	r16,48(sp)
 908541c:	df000c04 	addi	fp,sp,48
 9085420:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 9085424:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
 9085428:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 908542c:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 9085430:	e13ffe17 	ldw	r4,-8(fp)
 9085434:	90861980 	call	9086198 <alt_check_primary_table>
 9085438:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 908543c:	e0bffa17 	ldw	r2,-24(fp)
 9085440:	1004c03a 	cmpne	r2,r2,zero
 9085444:	1001621e 	bne	r2,zero,90859d0 <alt_read_cfi_table+0x5c4>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 9085448:	e0bffe17 	ldw	r2,-8(fp)
 908544c:	10803417 	ldw	r2,208(r2)
 9085450:	e13ffe17 	ldw	r4,-8(fp)
 9085454:	014004c4 	movi	r5,19
 9085458:	103ee83a 	callr	r2
 908545c:	10c03fcc 	andi	r3,r2,255
 9085460:	e0bffe17 	ldw	r2,-8(fp)
 9085464:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 9085468:	e0bffe17 	ldw	r2,-8(fp)
 908546c:	10803417 	ldw	r2,208(r2)
 9085470:	e13ffe17 	ldw	r4,-8(fp)
 9085474:	014007c4 	movi	r5,31
 9085478:	103ee83a 	callr	r2
 908547c:	10803fcc 	andi	r2,r2,255
 9085480:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 9085484:	e0bffe17 	ldw	r2,-8(fp)
 9085488:	10803417 	ldw	r2,208(r2)
 908548c:	e13ffe17 	ldw	r4,-8(fp)
 9085490:	014008c4 	movi	r5,35
 9085494:	103ee83a 	callr	r2
 9085498:	10803fcc 	andi	r2,r2,255
 908549c:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 90854a0:	e0bff717 	ldw	r2,-36(fp)
 90854a4:	1005003a 	cmpeq	r2,r2,zero
 90854a8:	1000031e 	bne	r2,zero,90854b8 <alt_read_cfi_table+0xac>
 90854ac:	e0bff617 	ldw	r2,-40(fp)
 90854b0:	1004c03a 	cmpne	r2,r2,zero
 90854b4:	1000041e 	bne	r2,zero,90854c8 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 90854b8:	e0fffe17 	ldw	r3,-8(fp)
 90854bc:	0080fa04 	movi	r2,1000
 90854c0:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 90854c4:	00000706 	br	90854e4 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 90854c8:	00c00044 	movi	r3,1
 90854cc:	e0bff717 	ldw	r2,-36(fp)
 90854d0:	1886983a 	sll	r3,r3,r2
 90854d4:	e0bff617 	ldw	r2,-40(fp)
 90854d8:	1886983a 	sll	r3,r3,r2
 90854dc:	e0bffe17 	ldw	r2,-8(fp)
 90854e0:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 90854e4:	e0bffe17 	ldw	r2,-8(fp)
 90854e8:	10803417 	ldw	r2,208(r2)
 90854ec:	e13ffe17 	ldw	r4,-8(fp)
 90854f0:	01400844 	movi	r5,33
 90854f4:	103ee83a 	callr	r2
 90854f8:	10803fcc 	andi	r2,r2,255
 90854fc:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 9085500:	e0bffe17 	ldw	r2,-8(fp)
 9085504:	10803417 	ldw	r2,208(r2)
 9085508:	e13ffe17 	ldw	r4,-8(fp)
 908550c:	01400944 	movi	r5,37
 9085510:	103ee83a 	callr	r2
 9085514:	10803fcc 	andi	r2,r2,255
 9085518:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 908551c:	e0bff717 	ldw	r2,-36(fp)
 9085520:	1005003a 	cmpeq	r2,r2,zero
 9085524:	1000031e 	bne	r2,zero,9085534 <alt_read_cfi_table+0x128>
 9085528:	e0bff617 	ldw	r2,-40(fp)
 908552c:	1004c03a 	cmpne	r2,r2,zero
 9085530:	1000051e 	bne	r2,zero,9085548 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 9085534:	e0fffe17 	ldw	r3,-8(fp)
 9085538:	00804c74 	movhi	r2,305
 908553c:	108b4004 	addi	r2,r2,11520
 9085540:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 9085544:	00000806 	br	9085568 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 9085548:	00c00044 	movi	r3,1
 908554c:	e0bff717 	ldw	r2,-36(fp)
 9085550:	1886983a 	sll	r3,r3,r2
 9085554:	e0bff617 	ldw	r2,-40(fp)
 9085558:	1884983a 	sll	r2,r3,r2
 908555c:	10c0fa24 	muli	r3,r2,1000
 9085560:	e0bffe17 	ldw	r2,-8(fp)
 9085564:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 9085568:	e0bffe17 	ldw	r2,-8(fp)
 908556c:	10803417 	ldw	r2,208(r2)
 9085570:	e13ffe17 	ldw	r4,-8(fp)
 9085574:	014009c4 	movi	r5,39
 9085578:	103ee83a 	callr	r2
 908557c:	10c03fcc 	andi	r3,r2,255
 9085580:	00800044 	movi	r2,1
 9085584:	10c4983a 	sll	r2,r2,r3
 9085588:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 908558c:	e0bffe17 	ldw	r2,-8(fp)
 9085590:	10803417 	ldw	r2,208(r2)
 9085594:	e13ffe17 	ldw	r4,-8(fp)
 9085598:	01400b04 	movi	r5,44
 908559c:	103ee83a 	callr	r2
 90855a0:	10c03fcc 	andi	r3,r2,255
 90855a4:	e0bffe17 	ldw	r2,-8(fp)
 90855a8:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 90855ac:	e0bffe17 	ldw	r2,-8(fp)
 90855b0:	10800c17 	ldw	r2,48(r2)
 90855b4:	10800250 	cmplti	r2,r2,9
 90855b8:	1000031e 	bne	r2,zero,90855c8 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 90855bc:	00bffd04 	movi	r2,-12
 90855c0:	e0bffa15 	stw	r2,-24(fp)
 90855c4:	00005e06 	br	9085740 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 90855c8:	e03ffd15 	stw	zero,-12(fp)
 90855cc:	00005306 	br	908571c <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 90855d0:	e43ffd17 	ldw	r16,-12(fp)
 90855d4:	e0bffd17 	ldw	r2,-12(fp)
 90855d8:	1085883a 	add	r2,r2,r2
 90855dc:	1085883a 	add	r2,r2,r2
 90855e0:	11400b44 	addi	r5,r2,45
 90855e4:	e13ffe17 	ldw	r4,-8(fp)
 90855e8:	90853900 	call	9085390 <alt_read_16bit_query_entry>
 90855ec:	113fffcc 	andi	r4,r2,65535
 90855f0:	e0fffe17 	ldw	r3,-8(fp)
 90855f4:	8004913a 	slli	r2,r16,4
 90855f8:	10c5883a 	add	r2,r2,r3
 90855fc:	10800f04 	addi	r2,r2,60
 9085600:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 9085604:	e17ffd17 	ldw	r5,-12(fp)
 9085608:	e0bffd17 	ldw	r2,-12(fp)
 908560c:	e0fffe17 	ldw	r3,-8(fp)
 9085610:	1004913a 	slli	r2,r2,4
 9085614:	10c5883a 	add	r2,r2,r3
 9085618:	10800f04 	addi	r2,r2,60
 908561c:	10800017 	ldw	r2,0(r2)
 9085620:	11000044 	addi	r4,r2,1
 9085624:	e0fffe17 	ldw	r3,-8(fp)
 9085628:	2804913a 	slli	r2,r5,4
 908562c:	10c5883a 	add	r2,r2,r3
 9085630:	10800f04 	addi	r2,r2,60
 9085634:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 9085638:	e43ffd17 	ldw	r16,-12(fp)
 908563c:	e0bffd17 	ldw	r2,-12(fp)
 9085640:	1085883a 	add	r2,r2,r2
 9085644:	1085883a 	add	r2,r2,r2
 9085648:	11400bc4 	addi	r5,r2,47
 908564c:	e13ffe17 	ldw	r4,-8(fp)
 9085650:	90853900 	call	9085390 <alt_read_16bit_query_entry>
 9085654:	113fffcc 	andi	r4,r2,65535
 9085658:	e0fffe17 	ldw	r3,-8(fp)
 908565c:	8004913a 	slli	r2,r16,4
 9085660:	10c5883a 	add	r2,r2,r3
 9085664:	10801004 	addi	r2,r2,64
 9085668:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 908566c:	e17ffd17 	ldw	r5,-12(fp)
 9085670:	e0bffd17 	ldw	r2,-12(fp)
 9085674:	e0fffe17 	ldw	r3,-8(fp)
 9085678:	1004913a 	slli	r2,r2,4
 908567c:	10c5883a 	add	r2,r2,r3
 9085680:	10801004 	addi	r2,r2,64
 9085684:	10800017 	ldw	r2,0(r2)
 9085688:	1008923a 	slli	r4,r2,8
 908568c:	e0fffe17 	ldw	r3,-8(fp)
 9085690:	2804913a 	slli	r2,r5,4
 9085694:	10c5883a 	add	r2,r2,r3
 9085698:	10801004 	addi	r2,r2,64
 908569c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 90856a0:	e17ffd17 	ldw	r5,-12(fp)
 90856a4:	e0bffd17 	ldw	r2,-12(fp)
 90856a8:	e0fffe17 	ldw	r3,-8(fp)
 90856ac:	1004913a 	slli	r2,r2,4
 90856b0:	10c5883a 	add	r2,r2,r3
 90856b4:	10800f04 	addi	r2,r2,60
 90856b8:	11000017 	ldw	r4,0(r2)
 90856bc:	e0bffd17 	ldw	r2,-12(fp)
 90856c0:	e0fffe17 	ldw	r3,-8(fp)
 90856c4:	1004913a 	slli	r2,r2,4
 90856c8:	10c5883a 	add	r2,r2,r3
 90856cc:	10801004 	addi	r2,r2,64
 90856d0:	10800017 	ldw	r2,0(r2)
 90856d4:	2089383a 	mul	r4,r4,r2
 90856d8:	e0fffe17 	ldw	r3,-8(fp)
 90856dc:	2804913a 	slli	r2,r5,4
 90856e0:	10c5883a 	add	r2,r2,r3
 90856e4:	10800e04 	addi	r2,r2,56
 90856e8:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 90856ec:	e0bffd17 	ldw	r2,-12(fp)
 90856f0:	e0fffe17 	ldw	r3,-8(fp)
 90856f4:	1004913a 	slli	r2,r2,4
 90856f8:	10c5883a 	add	r2,r2,r3
 90856fc:	10800e04 	addi	r2,r2,56
 9085700:	10c00017 	ldw	r3,0(r2)
 9085704:	e0bff917 	ldw	r2,-28(fp)
 9085708:	10c5883a 	add	r2,r2,r3
 908570c:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 9085710:	e0bffd17 	ldw	r2,-12(fp)
 9085714:	10800044 	addi	r2,r2,1
 9085718:	e0bffd15 	stw	r2,-12(fp)
 908571c:	e0bffe17 	ldw	r2,-8(fp)
 9085720:	10c00c17 	ldw	r3,48(r2)
 9085724:	e0bffd17 	ldw	r2,-12(fp)
 9085728:	10ffa916 	blt	r2,r3,90855d0 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 908572c:	e0fff917 	ldw	r3,-28(fp)
 9085730:	e0bffb17 	ldw	r2,-20(fp)
 9085734:	18800226 	beq	r3,r2,9085740 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 9085738:	00bffb44 	movi	r2,-19
 908573c:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 9085740:	e0bffe17 	ldw	r2,-8(fp)
 9085744:	10c03417 	ldw	r3,208(r2)
 9085748:	e0bffe17 	ldw	r2,-8(fp)
 908574c:	10803217 	ldw	r2,200(r2)
 9085750:	114003c4 	addi	r5,r2,15
 9085754:	e13ffe17 	ldw	r4,-8(fp)
 9085758:	183ee83a 	callr	r3
 908575c:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 9085760:	e0bffe17 	ldw	r2,-8(fp)
 9085764:	10802d17 	ldw	r2,180(r2)
 9085768:	10800098 	cmpnei	r2,r2,2
 908576c:	1000601e 	bne	r2,zero,90858f0 <alt_read_cfi_table+0x4e4>
 9085770:	e0bff403 	ldbu	r2,-48(fp)
 9085774:	108000d8 	cmpnei	r2,r2,3
 9085778:	10005d1e 	bne	r2,zero,90858f0 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 908577c:	e0bffe17 	ldw	r2,-8(fp)
 9085780:	10800c17 	ldw	r2,48(r2)
 9085784:	10bfffc4 	addi	r2,r2,-1
 9085788:	e0bffd15 	stw	r2,-12(fp)
 908578c:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
 9085790:	00005406 	br	90858e4 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 9085794:	e0bffd17 	ldw	r2,-12(fp)
 9085798:	e0fffe17 	ldw	r3,-8(fp)
 908579c:	1004913a 	slli	r2,r2,4
 90857a0:	10c5883a 	add	r2,r2,r3
 90857a4:	10800e04 	addi	r2,r2,56
 90857a8:	10800017 	ldw	r2,0(r2)
 90857ac:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
 90857b0:	e17ffd17 	ldw	r5,-12(fp)
 90857b4:	e0bffc17 	ldw	r2,-16(fp)
 90857b8:	e0fffe17 	ldw	r3,-8(fp)
 90857bc:	1004913a 	slli	r2,r2,4
 90857c0:	10c5883a 	add	r2,r2,r3
 90857c4:	10800e04 	addi	r2,r2,56
 90857c8:	11000017 	ldw	r4,0(r2)
 90857cc:	e0fffe17 	ldw	r3,-8(fp)
 90857d0:	2804913a 	slli	r2,r5,4
 90857d4:	10c5883a 	add	r2,r2,r3
 90857d8:	10800e04 	addi	r2,r2,56
 90857dc:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 90857e0:	e0bffc17 	ldw	r2,-16(fp)
 90857e4:	e0fffe17 	ldw	r3,-8(fp)
 90857e8:	1004913a 	slli	r2,r2,4
 90857ec:	10c5883a 	add	r2,r2,r3
 90857f0:	10c00e04 	addi	r3,r2,56
 90857f4:	e0bff817 	ldw	r2,-32(fp)
 90857f8:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 90857fc:	e0bffd17 	ldw	r2,-12(fp)
 9085800:	e0fffe17 	ldw	r3,-8(fp)
 9085804:	1004913a 	slli	r2,r2,4
 9085808:	10c5883a 	add	r2,r2,r3
 908580c:	10801004 	addi	r2,r2,64
 9085810:	10800017 	ldw	r2,0(r2)
 9085814:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
 9085818:	e17ffd17 	ldw	r5,-12(fp)
 908581c:	e0bffc17 	ldw	r2,-16(fp)
 9085820:	e0fffe17 	ldw	r3,-8(fp)
 9085824:	1004913a 	slli	r2,r2,4
 9085828:	10c5883a 	add	r2,r2,r3
 908582c:	10801004 	addi	r2,r2,64
 9085830:	11000017 	ldw	r4,0(r2)
 9085834:	e0fffe17 	ldw	r3,-8(fp)
 9085838:	2804913a 	slli	r2,r5,4
 908583c:	10c5883a 	add	r2,r2,r3
 9085840:	10801004 	addi	r2,r2,64
 9085844:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 9085848:	e0bffc17 	ldw	r2,-16(fp)
 908584c:	e0fffe17 	ldw	r3,-8(fp)
 9085850:	1004913a 	slli	r2,r2,4
 9085854:	10c5883a 	add	r2,r2,r3
 9085858:	10c01004 	addi	r3,r2,64
 908585c:	e0bff817 	ldw	r2,-32(fp)
 9085860:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 9085864:	e0bffd17 	ldw	r2,-12(fp)
 9085868:	e0fffe17 	ldw	r3,-8(fp)
 908586c:	1004913a 	slli	r2,r2,4
 9085870:	10c5883a 	add	r2,r2,r3
 9085874:	10800f04 	addi	r2,r2,60
 9085878:	10800017 	ldw	r2,0(r2)
 908587c:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
 9085880:	e17ffd17 	ldw	r5,-12(fp)
 9085884:	e0bffc17 	ldw	r2,-16(fp)
 9085888:	e0fffe17 	ldw	r3,-8(fp)
 908588c:	1004913a 	slli	r2,r2,4
 9085890:	10c5883a 	add	r2,r2,r3
 9085894:	10800f04 	addi	r2,r2,60
 9085898:	11000017 	ldw	r4,0(r2)
 908589c:	e0fffe17 	ldw	r3,-8(fp)
 90858a0:	2804913a 	slli	r2,r5,4
 90858a4:	10c5883a 	add	r2,r2,r3
 90858a8:	10800f04 	addi	r2,r2,60
 90858ac:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 90858b0:	e0bffc17 	ldw	r2,-16(fp)
 90858b4:	e0fffe17 	ldw	r3,-8(fp)
 90858b8:	1004913a 	slli	r2,r2,4
 90858bc:	10c5883a 	add	r2,r2,r3
 90858c0:	10c00f04 	addi	r3,r2,60
 90858c4:	e0bff817 	ldw	r2,-32(fp)
 90858c8:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 90858cc:	e0bffd17 	ldw	r2,-12(fp)
 90858d0:	10bfffc4 	addi	r2,r2,-1
 90858d4:	e0bffd15 	stw	r2,-12(fp)
 90858d8:	e0bffc17 	ldw	r2,-16(fp)
 90858dc:	10800044 	addi	r2,r2,1
 90858e0:	e0bffc15 	stw	r2,-16(fp)
 90858e4:	e0fffc17 	ldw	r3,-16(fp)
 90858e8:	e0bffd17 	ldw	r2,-12(fp)
 90858ec:	10ffa90e 	bge	r2,r3,9085794 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 90858f0:	e03ffd15 	stw	zero,-12(fp)
 90858f4:	00001306 	br	9085944 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 90858f8:	e0bffd17 	ldw	r2,-12(fp)
 90858fc:	e0fffe17 	ldw	r3,-8(fp)
 9085900:	1004913a 	slli	r2,r2,4
 9085904:	10c5883a 	add	r2,r2,r3
 9085908:	10c00d04 	addi	r3,r2,52
 908590c:	e0bff517 	ldw	r2,-44(fp)
 9085910:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 9085914:	e0bffd17 	ldw	r2,-12(fp)
 9085918:	e0fffe17 	ldw	r3,-8(fp)
 908591c:	1004913a 	slli	r2,r2,4
 9085920:	10c5883a 	add	r2,r2,r3
 9085924:	10800e04 	addi	r2,r2,56
 9085928:	10c00017 	ldw	r3,0(r2)
 908592c:	e0bff517 	ldw	r2,-44(fp)
 9085930:	10c5883a 	add	r2,r2,r3
 9085934:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 9085938:	e0bffd17 	ldw	r2,-12(fp)
 908593c:	10800044 	addi	r2,r2,1
 9085940:	e0bffd15 	stw	r2,-12(fp)
 9085944:	e0bffe17 	ldw	r2,-8(fp)
 9085948:	10c00c17 	ldw	r3,48(r2)
 908594c:	e0bffd17 	ldw	r2,-12(fp)
 9085950:	10ffe916 	blt	r2,r3,90858f8 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 9085954:	e0bffe17 	ldw	r2,-8(fp)
 9085958:	10802d17 	ldw	r2,180(r2)
 908595c:	e0bfff15 	stw	r2,-4(fp)
 9085960:	e0ffff17 	ldw	r3,-4(fp)
 9085964:	188000a0 	cmpeqi	r2,r3,2
 9085968:	1000071e 	bne	r2,zero,9085988 <alt_read_cfi_table+0x57c>
 908596c:	e0ffff17 	ldw	r3,-4(fp)
 9085970:	188000e0 	cmpeqi	r2,r3,3
 9085974:	10000c1e 	bne	r2,zero,90859a8 <alt_read_cfi_table+0x59c>
 9085978:	e0ffff17 	ldw	r3,-4(fp)
 908597c:	18800060 	cmpeqi	r2,r3,1
 9085980:	1000091e 	bne	r2,zero,90859a8 <alt_read_cfi_table+0x59c>
 9085984:	00001006 	br	90859c8 <alt_read_cfi_table+0x5bc>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 9085988:	e0bffe17 	ldw	r2,-8(fp)
 908598c:	10c03317 	ldw	r3,204(r2)
 9085990:	e0bffe17 	ldw	r2,-8(fp)
 9085994:	11000a17 	ldw	r4,40(r2)
 9085998:	01401544 	movi	r5,85
 908599c:	01803c04 	movi	r6,240
 90859a0:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 90859a4:	00000a06 	br	90859d0 <alt_read_cfi_table+0x5c4>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 90859a8:	e0bffe17 	ldw	r2,-8(fp)
 90859ac:	10c03317 	ldw	r3,204(r2)
 90859b0:	e0bffe17 	ldw	r2,-8(fp)
 90859b4:	11000a17 	ldw	r4,40(r2)
 90859b8:	01401544 	movi	r5,85
 90859bc:	01803fc4 	movi	r6,255
 90859c0:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 90859c4:	00000206 	br	90859d0 <alt_read_cfi_table+0x5c4>
      }
      default:
      {
        ret_code = -EIO;
 90859c8:	00bffec4 	movi	r2,-5
 90859cc:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
 90859d0:	e0bffa17 	ldw	r2,-24(fp)
}
 90859d4:	e037883a 	mov	sp,fp
 90859d8:	dfc00217 	ldw	ra,8(sp)
 90859dc:	df000117 	ldw	fp,4(sp)
 90859e0:	dc000017 	ldw	r16,0(sp)
 90859e4:	dec00304 	addi	sp,sp,12
 90859e8:	f800283a 	ret

090859ec <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 90859ec:	defff704 	addi	sp,sp,-36
 90859f0:	dfc00815 	stw	ra,32(sp)
 90859f4:	df000715 	stw	fp,28(sp)
 90859f8:	df000704 	addi	fp,sp,28
 90859fc:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 9085a00:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9085a04:	e0bfff17 	ldw	r2,-4(fp)
 9085a08:	11000a17 	ldw	r4,40(r2)
 9085a0c:	01401544 	movi	r5,85
 9085a10:	01802604 	movi	r6,152
 9085a14:	9084e980 	call	9084e98 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 9085a18:	e03ffb15 	stw	zero,-20(fp)
 9085a1c:	00000f06 	br	9085a5c <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 9085a20:	e13ffb17 	ldw	r4,-20(fp)
 9085a24:	e0bfff17 	ldw	r2,-4(fp)
 9085a28:	10800a17 	ldw	r2,40(r2)
 9085a2c:	1007883a 	mov	r3,r2
 9085a30:	e0bffb17 	ldw	r2,-20(fp)
 9085a34:	1885883a 	add	r2,r3,r2
 9085a38:	10800404 	addi	r2,r2,16
 9085a3c:	10800023 	ldbuio	r2,0(r2)
 9085a40:	1007883a 	mov	r3,r2
 9085a44:	e0bffc04 	addi	r2,fp,-16
 9085a48:	1105883a 	add	r2,r2,r4
 9085a4c:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 9085a50:	e0bffb17 	ldw	r2,-20(fp)
 9085a54:	10800044 	addi	r2,r2,1
 9085a58:	e0bffb15 	stw	r2,-20(fp)
 9085a5c:	e0bffb17 	ldw	r2,-20(fp)
 9085a60:	108000d0 	cmplti	r2,r2,3
 9085a64:	103fee1e 	bne	r2,zero,9085a20 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9085a68:	e0bffc03 	ldbu	r2,-16(fp)
 9085a6c:	10803fcc 	andi	r2,r2,255
 9085a70:	10801458 	cmpnei	r2,r2,81
 9085a74:	10001d1e 	bne	r2,zero,9085aec <alt_read_cfi_width+0x100>
 9085a78:	e0bffc43 	ldbu	r2,-15(fp)
 9085a7c:	10803fcc 	andi	r2,r2,255
 9085a80:	10801498 	cmpnei	r2,r2,82
 9085a84:	1000191e 	bne	r2,zero,9085aec <alt_read_cfi_width+0x100>
 9085a88:	e0bffc83 	ldbu	r2,-14(fp)
 9085a8c:	10803fcc 	andi	r2,r2,255
 9085a90:	10801658 	cmpnei	r2,r2,89
 9085a94:	1000151e 	bne	r2,zero,9085aec <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 9085a98:	e0ffff17 	ldw	r3,-4(fp)
 9085a9c:	00800044 	movi	r2,1
 9085aa0:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 9085aa4:	e0ffff17 	ldw	r3,-4(fp)
 9085aa8:	00800044 	movi	r2,1
 9085aac:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 9085ab0:	e0bfff17 	ldw	r2,-4(fp)
 9085ab4:	10800a17 	ldw	r2,40(r2)
 9085ab8:	10800a04 	addi	r2,r2,40
 9085abc:	1080002b 	ldhuio	r2,0(r2)
 9085ac0:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 9085ac4:	e0bffa0b 	ldhu	r2,-24(fp)
 9085ac8:	10800044 	addi	r2,r2,1
 9085acc:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 9085ad0:	e0bffa0b 	ldhu	r2,-24(fp)
 9085ad4:	1080004c 	andi	r2,r2,1
 9085ad8:	1004c03a 	cmpne	r2,r2,zero
 9085adc:	1001a81e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 9085ae0:	00bffb44 	movi	r2,-19
 9085ae4:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9085ae8:	0001a506 	br	9086180 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9085aec:	e0bfff17 	ldw	r2,-4(fp)
 9085af0:	11000a17 	ldw	r4,40(r2)
 9085af4:	01401544 	movi	r5,85
 9085af8:	01802604 	movi	r6,152
 9085afc:	9084ed40 	call	9084ed4 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 9085b00:	e03ffb15 	stw	zero,-20(fp)
 9085b04:	00000f06 	br	9085b44 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9085b08:	e13ffb17 	ldw	r4,-20(fp)
 9085b0c:	e0bfff17 	ldw	r2,-4(fp)
 9085b10:	10800a17 	ldw	r2,40(r2)
 9085b14:	1007883a 	mov	r3,r2
 9085b18:	e0bffb17 	ldw	r2,-20(fp)
 9085b1c:	1885883a 	add	r2,r3,r2
 9085b20:	10800804 	addi	r2,r2,32
 9085b24:	10800023 	ldbuio	r2,0(r2)
 9085b28:	1007883a 	mov	r3,r2
 9085b2c:	e0bffc04 	addi	r2,fp,-16
 9085b30:	1105883a 	add	r2,r2,r4
 9085b34:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 9085b38:	e0bffb17 	ldw	r2,-20(fp)
 9085b3c:	10800044 	addi	r2,r2,1
 9085b40:	e0bffb15 	stw	r2,-20(fp)
 9085b44:	e0bffb17 	ldw	r2,-20(fp)
 9085b48:	10800190 	cmplti	r2,r2,6
 9085b4c:	103fee1e 	bne	r2,zero,9085b08 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9085b50:	e0bffc03 	ldbu	r2,-16(fp)
 9085b54:	10803fcc 	andi	r2,r2,255
 9085b58:	10801458 	cmpnei	r2,r2,81
 9085b5c:	1000291e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
 9085b60:	e0bffc43 	ldbu	r2,-15(fp)
 9085b64:	10803fcc 	andi	r2,r2,255
 9085b68:	10801458 	cmpnei	r2,r2,81
 9085b6c:	1000251e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
 9085b70:	e0bffc83 	ldbu	r2,-14(fp)
 9085b74:	10803fcc 	andi	r2,r2,255
 9085b78:	10801498 	cmpnei	r2,r2,82
 9085b7c:	1000211e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
 9085b80:	e0bffcc3 	ldbu	r2,-13(fp)
 9085b84:	10803fcc 	andi	r2,r2,255
 9085b88:	10801498 	cmpnei	r2,r2,82
 9085b8c:	10001d1e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
 9085b90:	e0bffd03 	ldbu	r2,-12(fp)
 9085b94:	10803fcc 	andi	r2,r2,255
 9085b98:	10801658 	cmpnei	r2,r2,89
 9085b9c:	1000191e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
 9085ba0:	e0bffd43 	ldbu	r2,-11(fp)
 9085ba4:	10803fcc 	andi	r2,r2,255
 9085ba8:	10801658 	cmpnei	r2,r2,89
 9085bac:	1000151e 	bne	r2,zero,9085c04 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 9085bb0:	e0ffff17 	ldw	r3,-4(fp)
 9085bb4:	00800044 	movi	r2,1
 9085bb8:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 9085bbc:	e0ffff17 	ldw	r3,-4(fp)
 9085bc0:	00800084 	movi	r2,2
 9085bc4:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9085bc8:	e0bfff17 	ldw	r2,-4(fp)
 9085bcc:	10800a17 	ldw	r2,40(r2)
 9085bd0:	10801404 	addi	r2,r2,80
 9085bd4:	1080002b 	ldhuio	r2,0(r2)
 9085bd8:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 9085bdc:	e0bffa0b 	ldhu	r2,-24(fp)
 9085be0:	10800044 	addi	r2,r2,1
 9085be4:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 9085be8:	e0bffa0b 	ldhu	r2,-24(fp)
 9085bec:	1080004c 	andi	r2,r2,1
 9085bf0:	1004c03a 	cmpne	r2,r2,zero
 9085bf4:	1001621e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 9085bf8:	00bffb44 	movi	r2,-19
 9085bfc:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9085c00:	00015f06 	br	9086180 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9085c04:	e0bfff17 	ldw	r2,-4(fp)
 9085c08:	11000a17 	ldw	r4,40(r2)
 9085c0c:	01401544 	movi	r5,85
 9085c10:	01802604 	movi	r6,152
 9085c14:	9084f980 	call	9084f98 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 9085c18:	e03ffb15 	stw	zero,-20(fp)
 9085c1c:	00000f06 	br	9085c5c <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9085c20:	e13ffb17 	ldw	r4,-20(fp)
 9085c24:	e0bfff17 	ldw	r2,-4(fp)
 9085c28:	10800a17 	ldw	r2,40(r2)
 9085c2c:	1007883a 	mov	r3,r2
 9085c30:	e0bffb17 	ldw	r2,-20(fp)
 9085c34:	1885883a 	add	r2,r3,r2
 9085c38:	10800804 	addi	r2,r2,32
 9085c3c:	10800023 	ldbuio	r2,0(r2)
 9085c40:	1007883a 	mov	r3,r2
 9085c44:	e0bffc04 	addi	r2,fp,-16
 9085c48:	1105883a 	add	r2,r2,r4
 9085c4c:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 9085c50:	e0bffb17 	ldw	r2,-20(fp)
 9085c54:	10800044 	addi	r2,r2,1
 9085c58:	e0bffb15 	stw	r2,-20(fp)
 9085c5c:	e0bffb17 	ldw	r2,-20(fp)
 9085c60:	10800190 	cmplti	r2,r2,6
 9085c64:	103fee1e 	bne	r2,zero,9085c20 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9085c68:	e0bffc03 	ldbu	r2,-16(fp)
 9085c6c:	10803fcc 	andi	r2,r2,255
 9085c70:	10801458 	cmpnei	r2,r2,81
 9085c74:	1000291e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
 9085c78:	e0bffc43 	ldbu	r2,-15(fp)
 9085c7c:	10803fcc 	andi	r2,r2,255
 9085c80:	1004c03a 	cmpne	r2,r2,zero
 9085c84:	1000251e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
 9085c88:	e0bffc83 	ldbu	r2,-14(fp)
 9085c8c:	10803fcc 	andi	r2,r2,255
 9085c90:	10801498 	cmpnei	r2,r2,82
 9085c94:	1000211e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
 9085c98:	e0bffcc3 	ldbu	r2,-13(fp)
 9085c9c:	10803fcc 	andi	r2,r2,255
 9085ca0:	1004c03a 	cmpne	r2,r2,zero
 9085ca4:	10001d1e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
 9085ca8:	e0bffd03 	ldbu	r2,-12(fp)
 9085cac:	10803fcc 	andi	r2,r2,255
 9085cb0:	10801658 	cmpnei	r2,r2,89
 9085cb4:	1000191e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
 9085cb8:	e0bffd43 	ldbu	r2,-11(fp)
 9085cbc:	10803fcc 	andi	r2,r2,255
 9085cc0:	1004c03a 	cmpne	r2,r2,zero
 9085cc4:	1000151e 	bne	r2,zero,9085d1c <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 9085cc8:	e0ffff17 	ldw	r3,-4(fp)
 9085ccc:	00800084 	movi	r2,2
 9085cd0:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 9085cd4:	e0ffff17 	ldw	r3,-4(fp)
 9085cd8:	00800084 	movi	r2,2
 9085cdc:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9085ce0:	e0bfff17 	ldw	r2,-4(fp)
 9085ce4:	10800a17 	ldw	r2,40(r2)
 9085ce8:	10801404 	addi	r2,r2,80
 9085cec:	1080002b 	ldhuio	r2,0(r2)
 9085cf0:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 9085cf4:	e0bffa0b 	ldhu	r2,-24(fp)
 9085cf8:	10800044 	addi	r2,r2,1
 9085cfc:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 9085d00:	e0bffa0b 	ldhu	r2,-24(fp)
 9085d04:	1080008c 	andi	r2,r2,2
 9085d08:	1004c03a 	cmpne	r2,r2,zero
 9085d0c:	10011c1e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 9085d10:	00bffb44 	movi	r2,-19
 9085d14:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9085d18:	00011906 	br	9086180 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9085d1c:	e0bfff17 	ldw	r2,-4(fp)
 9085d20:	11000a17 	ldw	r4,40(r2)
 9085d24:	01401544 	movi	r5,85
 9085d28:	01802604 	movi	r6,152
 9085d2c:	90850240 	call	9085024 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 9085d30:	e03ffb15 	stw	zero,-20(fp)
 9085d34:	00000f06 	br	9085d74 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9085d38:	e13ffb17 	ldw	r4,-20(fp)
 9085d3c:	e0bfff17 	ldw	r2,-4(fp)
 9085d40:	10800a17 	ldw	r2,40(r2)
 9085d44:	1007883a 	mov	r3,r2
 9085d48:	e0bffb17 	ldw	r2,-20(fp)
 9085d4c:	1885883a 	add	r2,r3,r2
 9085d50:	10801004 	addi	r2,r2,64
 9085d54:	10800023 	ldbuio	r2,0(r2)
 9085d58:	1007883a 	mov	r3,r2
 9085d5c:	e0bffc04 	addi	r2,fp,-16
 9085d60:	1105883a 	add	r2,r2,r4
 9085d64:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 9085d68:	e0bffb17 	ldw	r2,-20(fp)
 9085d6c:	10800044 	addi	r2,r2,1
 9085d70:	e0bffb15 	stw	r2,-20(fp)
 9085d74:	e0bffb17 	ldw	r2,-20(fp)
 9085d78:	10800310 	cmplti	r2,r2,12
 9085d7c:	103fee1e 	bne	r2,zero,9085d38 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 9085d80:	e0bffc03 	ldbu	r2,-16(fp)
 9085d84:	10803fcc 	andi	r2,r2,255
 9085d88:	10801458 	cmpnei	r2,r2,81
 9085d8c:	1000411e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085d90:	e0bffc43 	ldbu	r2,-15(fp)
 9085d94:	10803fcc 	andi	r2,r2,255
 9085d98:	1004c03a 	cmpne	r2,r2,zero
 9085d9c:	10003d1e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085da0:	e0bffc83 	ldbu	r2,-14(fp)
 9085da4:	10803fcc 	andi	r2,r2,255
 9085da8:	1004c03a 	cmpne	r2,r2,zero
 9085dac:	1000391e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085db0:	e0bffcc3 	ldbu	r2,-13(fp)
 9085db4:	10803fcc 	andi	r2,r2,255
 9085db8:	1004c03a 	cmpne	r2,r2,zero
 9085dbc:	1000351e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085dc0:	e0bffd03 	ldbu	r2,-12(fp)
 9085dc4:	10803fcc 	andi	r2,r2,255
 9085dc8:	10801498 	cmpnei	r2,r2,82
 9085dcc:	1000311e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085dd0:	e0bffd43 	ldbu	r2,-11(fp)
 9085dd4:	10803fcc 	andi	r2,r2,255
 9085dd8:	1004c03a 	cmpne	r2,r2,zero
 9085ddc:	10002d1e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085de0:	e0bffd83 	ldbu	r2,-10(fp)
 9085de4:	10803fcc 	andi	r2,r2,255
 9085de8:	1004c03a 	cmpne	r2,r2,zero
 9085dec:	1000291e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085df0:	e0bffdc3 	ldbu	r2,-9(fp)
 9085df4:	10803fcc 	andi	r2,r2,255
 9085df8:	1004c03a 	cmpne	r2,r2,zero
 9085dfc:	1000251e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085e00:	e0bffe03 	ldbu	r2,-8(fp)
 9085e04:	10803fcc 	andi	r2,r2,255
 9085e08:	10801658 	cmpnei	r2,r2,89
 9085e0c:	1000211e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085e10:	e0bffe43 	ldbu	r2,-7(fp)
 9085e14:	10803fcc 	andi	r2,r2,255
 9085e18:	1004c03a 	cmpne	r2,r2,zero
 9085e1c:	10001d1e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085e20:	e0bffe83 	ldbu	r2,-6(fp)
 9085e24:	10803fcc 	andi	r2,r2,255
 9085e28:	1004c03a 	cmpne	r2,r2,zero
 9085e2c:	1000191e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
 9085e30:	e0bffec3 	ldbu	r2,-5(fp)
 9085e34:	10803fcc 	andi	r2,r2,255
 9085e38:	1004c03a 	cmpne	r2,r2,zero
 9085e3c:	1000151e 	bne	r2,zero,9085e94 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 9085e40:	e0ffff17 	ldw	r3,-4(fp)
 9085e44:	00800104 	movi	r2,4
 9085e48:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 9085e4c:	e0ffff17 	ldw	r3,-4(fp)
 9085e50:	00800104 	movi	r2,4
 9085e54:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9085e58:	e0bfff17 	ldw	r2,-4(fp)
 9085e5c:	10800a17 	ldw	r2,40(r2)
 9085e60:	10802804 	addi	r2,r2,160
 9085e64:	10800037 	ldwio	r2,0(r2)
 9085e68:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 9085e6c:	e0bffa0b 	ldhu	r2,-24(fp)
 9085e70:	10800044 	addi	r2,r2,1
 9085e74:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 9085e78:	e0bffa0b 	ldhu	r2,-24(fp)
 9085e7c:	1080010c 	andi	r2,r2,4
 9085e80:	1004c03a 	cmpne	r2,r2,zero
 9085e84:	1000be1e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 9085e88:	00bffb44 	movi	r2,-19
 9085e8c:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 9085e90:	0000bb06 	br	9086180 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9085e94:	e0bfff17 	ldw	r2,-4(fp)
 9085e98:	11000a17 	ldw	r4,40(r2)
 9085e9c:	01401544 	movi	r5,85
 9085ea0:	01802604 	movi	r6,152
 9085ea4:	9084fdc0 	call	9084fdc <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 9085ea8:	e03ffb15 	stw	zero,-20(fp)
 9085eac:	00000f06 	br	9085eec <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9085eb0:	e13ffb17 	ldw	r4,-20(fp)
 9085eb4:	e0bfff17 	ldw	r2,-4(fp)
 9085eb8:	10800a17 	ldw	r2,40(r2)
 9085ebc:	1007883a 	mov	r3,r2
 9085ec0:	e0bffb17 	ldw	r2,-20(fp)
 9085ec4:	1885883a 	add	r2,r3,r2
 9085ec8:	10801004 	addi	r2,r2,64
 9085ecc:	10800023 	ldbuio	r2,0(r2)
 9085ed0:	1007883a 	mov	r3,r2
 9085ed4:	e0bffc04 	addi	r2,fp,-16
 9085ed8:	1105883a 	add	r2,r2,r4
 9085edc:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 9085ee0:	e0bffb17 	ldw	r2,-20(fp)
 9085ee4:	10800044 	addi	r2,r2,1
 9085ee8:	e0bffb15 	stw	r2,-20(fp)
 9085eec:	e0bffb17 	ldw	r2,-20(fp)
 9085ef0:	10800310 	cmplti	r2,r2,12
 9085ef4:	103fee1e 	bne	r2,zero,9085eb0 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9085ef8:	e0bffc03 	ldbu	r2,-16(fp)
 9085efc:	10803fcc 	andi	r2,r2,255
 9085f00:	10801458 	cmpnei	r2,r2,81
 9085f04:	1000411e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f08:	e0bffc43 	ldbu	r2,-15(fp)
 9085f0c:	10803fcc 	andi	r2,r2,255
 9085f10:	1004c03a 	cmpne	r2,r2,zero
 9085f14:	10003d1e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f18:	e0bffc83 	ldbu	r2,-14(fp)
 9085f1c:	10803fcc 	andi	r2,r2,255
 9085f20:	10801458 	cmpnei	r2,r2,81
 9085f24:	1000391e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f28:	e0bffcc3 	ldbu	r2,-13(fp)
 9085f2c:	10803fcc 	andi	r2,r2,255
 9085f30:	1004c03a 	cmpne	r2,r2,zero
 9085f34:	1000351e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f38:	e0bffd03 	ldbu	r2,-12(fp)
 9085f3c:	10803fcc 	andi	r2,r2,255
 9085f40:	10801498 	cmpnei	r2,r2,82
 9085f44:	1000311e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f48:	e0bffd43 	ldbu	r2,-11(fp)
 9085f4c:	10803fcc 	andi	r2,r2,255
 9085f50:	1004c03a 	cmpne	r2,r2,zero
 9085f54:	10002d1e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f58:	e0bffd83 	ldbu	r2,-10(fp)
 9085f5c:	10803fcc 	andi	r2,r2,255
 9085f60:	10801498 	cmpnei	r2,r2,82
 9085f64:	1000291e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f68:	e0bffdc3 	ldbu	r2,-9(fp)
 9085f6c:	10803fcc 	andi	r2,r2,255
 9085f70:	1004c03a 	cmpne	r2,r2,zero
 9085f74:	1000251e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f78:	e0bffe03 	ldbu	r2,-8(fp)
 9085f7c:	10803fcc 	andi	r2,r2,255
 9085f80:	10801658 	cmpnei	r2,r2,89
 9085f84:	1000211e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f88:	e0bffe43 	ldbu	r2,-7(fp)
 9085f8c:	10803fcc 	andi	r2,r2,255
 9085f90:	1004c03a 	cmpne	r2,r2,zero
 9085f94:	10001d1e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085f98:	e0bffe83 	ldbu	r2,-6(fp)
 9085f9c:	10803fcc 	andi	r2,r2,255
 9085fa0:	10801658 	cmpnei	r2,r2,89
 9085fa4:	1000191e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
 9085fa8:	e0bffec3 	ldbu	r2,-5(fp)
 9085fac:	10803fcc 	andi	r2,r2,255
 9085fb0:	1004c03a 	cmpne	r2,r2,zero
 9085fb4:	1000151e 	bne	r2,zero,908600c <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 9085fb8:	e0ffff17 	ldw	r3,-4(fp)
 9085fbc:	00800084 	movi	r2,2
 9085fc0:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 9085fc4:	e0ffff17 	ldw	r3,-4(fp)
 9085fc8:	00800104 	movi	r2,4
 9085fcc:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9085fd0:	e0bfff17 	ldw	r2,-4(fp)
 9085fd4:	10800a17 	ldw	r2,40(r2)
 9085fd8:	10802804 	addi	r2,r2,160
 9085fdc:	10800037 	ldwio	r2,0(r2)
 9085fe0:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 9085fe4:	e0bffa0b 	ldhu	r2,-24(fp)
 9085fe8:	10800044 	addi	r2,r2,1
 9085fec:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 9085ff0:	e0bffa0b 	ldhu	r2,-24(fp)
 9085ff4:	1080010c 	andi	r2,r2,4
 9085ff8:	1004c03a 	cmpne	r2,r2,zero
 9085ffc:	1000601e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 9086000:	00bffb44 	movi	r2,-19
 9086004:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9086008:	00005d06 	br	9086180 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 908600c:	e0bfff17 	ldw	r2,-4(fp)
 9086010:	11000a17 	ldw	r4,40(r2)
 9086014:	01401544 	movi	r5,85
 9086018:	01802604 	movi	r6,152
 908601c:	9084f500 	call	9084f50 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 9086020:	e03ffb15 	stw	zero,-20(fp)
 9086024:	00000f06 	br	9086064 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9086028:	e13ffb17 	ldw	r4,-20(fp)
 908602c:	e0bfff17 	ldw	r2,-4(fp)
 9086030:	10800a17 	ldw	r2,40(r2)
 9086034:	1007883a 	mov	r3,r2
 9086038:	e0bffb17 	ldw	r2,-20(fp)
 908603c:	1885883a 	add	r2,r3,r2
 9086040:	10801004 	addi	r2,r2,64
 9086044:	10800023 	ldbuio	r2,0(r2)
 9086048:	1007883a 	mov	r3,r2
 908604c:	e0bffc04 	addi	r2,fp,-16
 9086050:	1105883a 	add	r2,r2,r4
 9086054:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 9086058:	e0bffb17 	ldw	r2,-20(fp)
 908605c:	10800044 	addi	r2,r2,1
 9086060:	e0bffb15 	stw	r2,-20(fp)
 9086064:	e0bffb17 	ldw	r2,-20(fp)
 9086068:	10800310 	cmplti	r2,r2,12
 908606c:	103fee1e 	bne	r2,zero,9086028 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 9086070:	e0bffc03 	ldbu	r2,-16(fp)
 9086074:	10803fcc 	andi	r2,r2,255
 9086078:	10801458 	cmpnei	r2,r2,81
 908607c:	1000401e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 9086080:	e0bffc43 	ldbu	r2,-15(fp)
 9086084:	10803fcc 	andi	r2,r2,255
 9086088:	10801458 	cmpnei	r2,r2,81
 908608c:	10003c1e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 9086090:	e0bffc83 	ldbu	r2,-14(fp)
 9086094:	10803fcc 	andi	r2,r2,255
 9086098:	10801458 	cmpnei	r2,r2,81
 908609c:	1000381e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860a0:	e0bffcc3 	ldbu	r2,-13(fp)
 90860a4:	10803fcc 	andi	r2,r2,255
 90860a8:	10801458 	cmpnei	r2,r2,81
 90860ac:	1000341e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860b0:	e0bffd03 	ldbu	r2,-12(fp)
 90860b4:	10803fcc 	andi	r2,r2,255
 90860b8:	10801498 	cmpnei	r2,r2,82
 90860bc:	1000301e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860c0:	e0bffd43 	ldbu	r2,-11(fp)
 90860c4:	10803fcc 	andi	r2,r2,255
 90860c8:	10801498 	cmpnei	r2,r2,82
 90860cc:	10002c1e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860d0:	e0bffd83 	ldbu	r2,-10(fp)
 90860d4:	10803fcc 	andi	r2,r2,255
 90860d8:	10801498 	cmpnei	r2,r2,82
 90860dc:	1000281e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860e0:	e0bffdc3 	ldbu	r2,-9(fp)
 90860e4:	10803fcc 	andi	r2,r2,255
 90860e8:	10801498 	cmpnei	r2,r2,82
 90860ec:	1000241e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 90860f0:	e0bffe03 	ldbu	r2,-8(fp)
 90860f4:	10803fcc 	andi	r2,r2,255
 90860f8:	10801658 	cmpnei	r2,r2,89
 90860fc:	1000201e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 9086100:	e0bffe43 	ldbu	r2,-7(fp)
 9086104:	10803fcc 	andi	r2,r2,255
 9086108:	10801658 	cmpnei	r2,r2,89
 908610c:	10001c1e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 9086110:	e0bffe83 	ldbu	r2,-6(fp)
 9086114:	10803fcc 	andi	r2,r2,255
 9086118:	10801658 	cmpnei	r2,r2,89
 908611c:	1000181e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
 9086120:	e0bffec3 	ldbu	r2,-5(fp)
 9086124:	10803fcc 	andi	r2,r2,255
 9086128:	10801658 	cmpnei	r2,r2,89
 908612c:	1000141e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 9086130:	e0ffff17 	ldw	r3,-4(fp)
 9086134:	00800044 	movi	r2,1
 9086138:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 908613c:	e0ffff17 	ldw	r3,-4(fp)
 9086140:	00800104 	movi	r2,4
 9086144:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9086148:	e0bfff17 	ldw	r2,-4(fp)
 908614c:	10800a17 	ldw	r2,40(r2)
 9086150:	10802804 	addi	r2,r2,160
 9086154:	10800037 	ldwio	r2,0(r2)
 9086158:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 908615c:	e0bffa0b 	ldhu	r2,-24(fp)
 9086160:	10800044 	addi	r2,r2,1
 9086164:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 9086168:	e0bffa0b 	ldhu	r2,-24(fp)
 908616c:	1080010c 	andi	r2,r2,4
 9086170:	1004c03a 	cmpne	r2,r2,zero
 9086174:	1000021e 	bne	r2,zero,9086180 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 9086178:	00bffb44 	movi	r2,-19
 908617c:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 9086180:	e0bff917 	ldw	r2,-28(fp)
}
 9086184:	e037883a 	mov	sp,fp
 9086188:	dfc00117 	ldw	ra,4(sp)
 908618c:	df000017 	ldw	fp,0(sp)
 9086190:	dec00204 	addi	sp,sp,8
 9086194:	f800283a 	ret

09086198 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 9086198:	defff904 	addi	sp,sp,-28
 908619c:	dfc00615 	stw	ra,24(sp)
 90861a0:	df000515 	stw	fp,20(sp)
 90861a4:	dc000415 	stw	r16,16(sp)
 90861a8:	df000404 	addi	fp,sp,16
 90861ac:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 90861b0:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 90861b4:	e13fff17 	ldw	r4,-4(fp)
 90861b8:	01400544 	movi	r5,21
 90861bc:	90853900 	call	9085390 <alt_read_16bit_query_entry>
 90861c0:	10ffffcc 	andi	r3,r2,65535
 90861c4:	e0bfff17 	ldw	r2,-4(fp)
 90861c8:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 90861cc:	e03ffd15 	stw	zero,-12(fp)
 90861d0:	00001006 	br	9086214 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 90861d4:	e43ffd17 	ldw	r16,-12(fp)
 90861d8:	e0bfff17 	ldw	r2,-4(fp)
 90861dc:	11803417 	ldw	r6,208(r2)
 90861e0:	e0bfff17 	ldw	r2,-4(fp)
 90861e4:	10c03217 	ldw	r3,200(r2)
 90861e8:	e0bffd17 	ldw	r2,-12(fp)
 90861ec:	188b883a 	add	r5,r3,r2
 90861f0:	e13fff17 	ldw	r4,-4(fp)
 90861f4:	303ee83a 	callr	r6
 90861f8:	1007883a 	mov	r3,r2
 90861fc:	e0bffe04 	addi	r2,fp,-8
 9086200:	1405883a 	add	r2,r2,r16
 9086204:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 9086208:	e0bffd17 	ldw	r2,-12(fp)
 908620c:	10800044 	addi	r2,r2,1
 9086210:	e0bffd15 	stw	r2,-12(fp)
 9086214:	e0bffd17 	ldw	r2,-12(fp)
 9086218:	108000d0 	cmplti	r2,r2,3
 908621c:	103fed1e 	bne	r2,zero,90861d4 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 9086220:	e0bffe03 	ldbu	r2,-8(fp)
 9086224:	10803fcc 	andi	r2,r2,255
 9086228:	10801418 	cmpnei	r2,r2,80
 908622c:	1000081e 	bne	r2,zero,9086250 <alt_check_primary_table+0xb8>
 9086230:	e0bffe43 	ldbu	r2,-7(fp)
 9086234:	10803fcc 	andi	r2,r2,255
 9086238:	10801498 	cmpnei	r2,r2,82
 908623c:	1000041e 	bne	r2,zero,9086250 <alt_check_primary_table+0xb8>
 9086240:	e0bffe83 	ldbu	r2,-6(fp)
 9086244:	10803fcc 	andi	r2,r2,255
 9086248:	10801260 	cmpeqi	r2,r2,73
 908624c:	1000021e 	bne	r2,zero,9086258 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 9086250:	00bffb44 	movi	r2,-19
 9086254:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 9086258:	e0bffc17 	ldw	r2,-16(fp)
}
 908625c:	e037883a 	mov	sp,fp
 9086260:	dfc00217 	ldw	ra,8(sp)
 9086264:	df000117 	ldw	fp,4(sp)
 9086268:	dc000017 	ldw	r16,0(sp)
 908626c:	dec00304 	addi	sp,sp,12
 9086270:	f800283a 	ret

09086274 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 9086274:	defffa04 	addi	sp,sp,-24
 9086278:	dfc00515 	stw	ra,20(sp)
 908627c:	df000415 	stw	fp,16(sp)
 9086280:	df000404 	addi	fp,sp,16
 9086284:	e13ffd15 	stw	r4,-12(fp)
 9086288:	e17ffe15 	stw	r5,-8(fp)
 908628c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9086290:	e0bffd17 	ldw	r2,-12(fp)
 9086294:	10800017 	ldw	r2,0(r2)
 9086298:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 908629c:	e0bffc17 	ldw	r2,-16(fp)
 90862a0:	11000a04 	addi	r4,r2,40
 90862a4:	e0bffd17 	ldw	r2,-12(fp)
 90862a8:	11c00217 	ldw	r7,8(r2)
 90862ac:	e17ffe17 	ldw	r5,-8(fp)
 90862b0:	e1bfff17 	ldw	r6,-4(fp)
 90862b4:	90868bc0 	call	90868bc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 90862b8:	e037883a 	mov	sp,fp
 90862bc:	dfc00117 	ldw	ra,4(sp)
 90862c0:	df000017 	ldw	fp,0(sp)
 90862c4:	dec00204 	addi	sp,sp,8
 90862c8:	f800283a 	ret

090862cc <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 90862cc:	defffa04 	addi	sp,sp,-24
 90862d0:	dfc00515 	stw	ra,20(sp)
 90862d4:	df000415 	stw	fp,16(sp)
 90862d8:	df000404 	addi	fp,sp,16
 90862dc:	e13ffd15 	stw	r4,-12(fp)
 90862e0:	e17ffe15 	stw	r5,-8(fp)
 90862e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 90862e8:	e0bffd17 	ldw	r2,-12(fp)
 90862ec:	10800017 	ldw	r2,0(r2)
 90862f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 90862f4:	e0bffc17 	ldw	r2,-16(fp)
 90862f8:	11000a04 	addi	r4,r2,40
 90862fc:	e0bffd17 	ldw	r2,-12(fp)
 9086300:	11c00217 	ldw	r7,8(r2)
 9086304:	e17ffe17 	ldw	r5,-8(fp)
 9086308:	e1bfff17 	ldw	r6,-4(fp)
 908630c:	9086ae00 	call	9086ae0 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 9086310:	e037883a 	mov	sp,fp
 9086314:	dfc00117 	ldw	ra,4(sp)
 9086318:	df000017 	ldw	fp,0(sp)
 908631c:	dec00204 	addi	sp,sp,8
 9086320:	f800283a 	ret

09086324 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 9086324:	defffc04 	addi	sp,sp,-16
 9086328:	dfc00315 	stw	ra,12(sp)
 908632c:	df000215 	stw	fp,8(sp)
 9086330:	df000204 	addi	fp,sp,8
 9086334:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9086338:	e0bfff17 	ldw	r2,-4(fp)
 908633c:	10800017 	ldw	r2,0(r2)
 9086340:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 9086344:	e0bffe17 	ldw	r2,-8(fp)
 9086348:	11000a04 	addi	r4,r2,40
 908634c:	e0bfff17 	ldw	r2,-4(fp)
 9086350:	11400217 	ldw	r5,8(r2)
 9086354:	90867540 	call	9086754 <altera_avalon_jtag_uart_close>
}
 9086358:	e037883a 	mov	sp,fp
 908635c:	dfc00117 	ldw	ra,4(sp)
 9086360:	df000017 	ldw	fp,0(sp)
 9086364:	dec00204 	addi	sp,sp,8
 9086368:	f800283a 	ret

0908636c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 908636c:	defffa04 	addi	sp,sp,-24
 9086370:	dfc00515 	stw	ra,20(sp)
 9086374:	df000415 	stw	fp,16(sp)
 9086378:	df000404 	addi	fp,sp,16
 908637c:	e13ffd15 	stw	r4,-12(fp)
 9086380:	e17ffe15 	stw	r5,-8(fp)
 9086384:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 9086388:	e0bffd17 	ldw	r2,-12(fp)
 908638c:	10800017 	ldw	r2,0(r2)
 9086390:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 9086394:	e0bffc17 	ldw	r2,-16(fp)
 9086398:	11000a04 	addi	r4,r2,40
 908639c:	e17ffe17 	ldw	r5,-8(fp)
 90863a0:	e1bfff17 	ldw	r6,-4(fp)
 90863a4:	90867c80 	call	90867c8 <altera_avalon_jtag_uart_ioctl>
}
 90863a8:	e037883a 	mov	sp,fp
 90863ac:	dfc00117 	ldw	ra,4(sp)
 90863b0:	df000017 	ldw	fp,0(sp)
 90863b4:	dec00204 	addi	sp,sp,8
 90863b8:	f800283a 	ret

090863bc <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 90863bc:	defffa04 	addi	sp,sp,-24
 90863c0:	dfc00515 	stw	ra,20(sp)
 90863c4:	df000415 	stw	fp,16(sp)
 90863c8:	df000404 	addi	fp,sp,16
 90863cc:	e13ffd15 	stw	r4,-12(fp)
 90863d0:	e17ffe15 	stw	r5,-8(fp)
 90863d4:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 90863d8:	e0fffd17 	ldw	r3,-12(fp)
 90863dc:	00800044 	movi	r2,1
 90863e0:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 90863e4:	e0bffd17 	ldw	r2,-12(fp)
 90863e8:	10800017 	ldw	r2,0(r2)
 90863ec:	11000104 	addi	r4,r2,4
 90863f0:	e0bffd17 	ldw	r2,-12(fp)
 90863f4:	10800817 	ldw	r2,32(r2)
 90863f8:	1007883a 	mov	r3,r2
 90863fc:	2005883a 	mov	r2,r4
 9086400:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 9086404:	e13ffe17 	ldw	r4,-8(fp)
 9086408:	e17fff17 	ldw	r5,-4(fp)
 908640c:	d8000015 	stw	zero,0(sp)
 9086410:	01824234 	movhi	r6,2312
 9086414:	31991f04 	addi	r6,r6,25724
 9086418:	e1fffd17 	ldw	r7,-12(fp)
 908641c:	90892380 	call	9089238 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 9086420:	e0bffd17 	ldw	r2,-12(fp)
 9086424:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 9086428:	e0bffd17 	ldw	r2,-12(fp)
 908642c:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 9086430:	00824274 	movhi	r2,2313
 9086434:	10b19704 	addi	r2,r2,-14756
 9086438:	10800017 	ldw	r2,0(r2)
 908643c:	100b883a 	mov	r5,r2
 9086440:	01824234 	movhi	r6,2312
 9086444:	3199a904 	addi	r6,r6,26276
 9086448:	e1fffd17 	ldw	r7,-12(fp)
 908644c:	9088b540 	call	9088b54 <alt_alarm_start>
 9086450:	1004403a 	cmpge	r2,r2,zero
 9086454:	1000041e 	bne	r2,zero,9086468 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 9086458:	e0fffd17 	ldw	r3,-12(fp)
 908645c:	00a00034 	movhi	r2,32768
 9086460:	10bfffc4 	addi	r2,r2,-1
 9086464:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 9086468:	e037883a 	mov	sp,fp
 908646c:	dfc00117 	ldw	ra,4(sp)
 9086470:	df000017 	ldw	fp,0(sp)
 9086474:	dec00204 	addi	sp,sp,8
 9086478:	f800283a 	ret

0908647c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 908647c:	defff804 	addi	sp,sp,-32
 9086480:	df000715 	stw	fp,28(sp)
 9086484:	df000704 	addi	fp,sp,28
 9086488:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 908648c:	e0bfff17 	ldw	r2,-4(fp)
 9086490:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
 9086494:	e0bffe17 	ldw	r2,-8(fp)
 9086498:	10800017 	ldw	r2,0(r2)
 908649c:	e0bffd15 	stw	r2,-12(fp)
 90864a0:	00000006 	br	90864a4 <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 90864a4:	e0bffd17 	ldw	r2,-12(fp)
 90864a8:	10800104 	addi	r2,r2,4
 90864ac:	10800037 	ldwio	r2,0(r2)
 90864b0:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 90864b4:	e0bffc17 	ldw	r2,-16(fp)
 90864b8:	1080c00c 	andi	r2,r2,768
 90864bc:	1005003a 	cmpeq	r2,r2,zero
 90864c0:	1000741e 	bne	r2,zero,9086694 <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 90864c4:	e0bffc17 	ldw	r2,-16(fp)
 90864c8:	1080400c 	andi	r2,r2,256
 90864cc:	1005003a 	cmpeq	r2,r2,zero
 90864d0:	1000351e 	bne	r2,zero,90865a8 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 90864d4:	00800074 	movhi	r2,1
 90864d8:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 90864dc:	e0bffe17 	ldw	r2,-8(fp)
 90864e0:	10800a17 	ldw	r2,40(r2)
 90864e4:	10800044 	addi	r2,r2,1
 90864e8:	1081ffcc 	andi	r2,r2,2047
 90864ec:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 90864f0:	e0bffe17 	ldw	r2,-8(fp)
 90864f4:	10c00b17 	ldw	r3,44(r2)
 90864f8:	e0bffa17 	ldw	r2,-24(fp)
 90864fc:	18801626 	beq	r3,r2,9086558 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 9086500:	e0bffd17 	ldw	r2,-12(fp)
 9086504:	10800037 	ldwio	r2,0(r2)
 9086508:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 908650c:	e0bffb17 	ldw	r2,-20(fp)
 9086510:	10a0000c 	andi	r2,r2,32768
 9086514:	1005003a 	cmpeq	r2,r2,zero
 9086518:	10000f1e 	bne	r2,zero,9086558 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 908651c:	e0bffe17 	ldw	r2,-8(fp)
 9086520:	10c00a17 	ldw	r3,40(r2)
 9086524:	e0bffb17 	ldw	r2,-20(fp)
 9086528:	1009883a 	mov	r4,r2
 908652c:	e0bffe17 	ldw	r2,-8(fp)
 9086530:	1885883a 	add	r2,r3,r2
 9086534:	10800e04 	addi	r2,r2,56
 9086538:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 908653c:	e0bffe17 	ldw	r2,-8(fp)
 9086540:	10800a17 	ldw	r2,40(r2)
 9086544:	10800044 	addi	r2,r2,1
 9086548:	10c1ffcc 	andi	r3,r2,2047
 908654c:	e0bffe17 	ldw	r2,-8(fp)
 9086550:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 9086554:	003fe106 	br	90864dc <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 9086558:	e0bffb17 	ldw	r2,-20(fp)
 908655c:	10bfffec 	andhi	r2,r2,65535
 9086560:	1005003a 	cmpeq	r2,r2,zero
 9086564:	1000101e 	bne	r2,zero,90865a8 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9086568:	e0bffe17 	ldw	r2,-8(fp)
 908656c:	10c00817 	ldw	r3,32(r2)
 9086570:	00bfff84 	movi	r2,-2
 9086574:	1886703a 	and	r3,r3,r2
 9086578:	e0bffe17 	ldw	r2,-8(fp)
 908657c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 9086580:	e0bffd17 	ldw	r2,-12(fp)
 9086584:	11000104 	addi	r4,r2,4
 9086588:	e0bffe17 	ldw	r2,-8(fp)
 908658c:	10800817 	ldw	r2,32(r2)
 9086590:	1007883a 	mov	r3,r2
 9086594:	2005883a 	mov	r2,r4
 9086598:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 908659c:	e0bffd17 	ldw	r2,-12(fp)
 90865a0:	10800104 	addi	r2,r2,4
 90865a4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 90865a8:	e0bffc17 	ldw	r2,-16(fp)
 90865ac:	1080800c 	andi	r2,r2,512
 90865b0:	1005003a 	cmpeq	r2,r2,zero
 90865b4:	103fbb1e 	bne	r2,zero,90864a4 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 90865b8:	e0bffc17 	ldw	r2,-16(fp)
 90865bc:	10bfffec 	andhi	r2,r2,65535
 90865c0:	1004d43a 	srli	r2,r2,16
 90865c4:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 90865c8:	00001506 	br	9086620 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 90865cc:	e13ffd17 	ldw	r4,-12(fp)
 90865d0:	e0bffe17 	ldw	r2,-8(fp)
 90865d4:	10c00d17 	ldw	r3,52(r2)
 90865d8:	e0bffe17 	ldw	r2,-8(fp)
 90865dc:	1885883a 	add	r2,r3,r2
 90865e0:	10820e04 	addi	r2,r2,2104
 90865e4:	10800003 	ldbu	r2,0(r2)
 90865e8:	10c03fcc 	andi	r3,r2,255
 90865ec:	18c0201c 	xori	r3,r3,128
 90865f0:	18ffe004 	addi	r3,r3,-128
 90865f4:	2005883a 	mov	r2,r4
 90865f8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 90865fc:	e0bffe17 	ldw	r2,-8(fp)
 9086600:	10800d17 	ldw	r2,52(r2)
 9086604:	10800044 	addi	r2,r2,1
 9086608:	10c1ffcc 	andi	r3,r2,2047
 908660c:	e0bffe17 	ldw	r2,-8(fp)
 9086610:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 9086614:	e0bff917 	ldw	r2,-28(fp)
 9086618:	10bfffc4 	addi	r2,r2,-1
 908661c:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 9086620:	e0bff917 	ldw	r2,-28(fp)
 9086624:	1005003a 	cmpeq	r2,r2,zero
 9086628:	1000051e 	bne	r2,zero,9086640 <altera_avalon_jtag_uart_irq+0x1c4>
 908662c:	e0bffe17 	ldw	r2,-8(fp)
 9086630:	10c00d17 	ldw	r3,52(r2)
 9086634:	e0bffe17 	ldw	r2,-8(fp)
 9086638:	10800c17 	ldw	r2,48(r2)
 908663c:	18bfe31e 	bne	r3,r2,90865cc <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 9086640:	e0bff917 	ldw	r2,-28(fp)
 9086644:	1005003a 	cmpeq	r2,r2,zero
 9086648:	103f961e 	bne	r2,zero,90864a4 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 908664c:	e0bffe17 	ldw	r2,-8(fp)
 9086650:	10c00817 	ldw	r3,32(r2)
 9086654:	00bfff44 	movi	r2,-3
 9086658:	1886703a 	and	r3,r3,r2
 908665c:	e0bffe17 	ldw	r2,-8(fp)
 9086660:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 9086664:	e0bffe17 	ldw	r2,-8(fp)
 9086668:	10800017 	ldw	r2,0(r2)
 908666c:	11000104 	addi	r4,r2,4
 9086670:	e0bffe17 	ldw	r2,-8(fp)
 9086674:	10800817 	ldw	r2,32(r2)
 9086678:	1007883a 	mov	r3,r2
 908667c:	2005883a 	mov	r2,r4
 9086680:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 9086684:	e0bffd17 	ldw	r2,-12(fp)
 9086688:	10800104 	addi	r2,r2,4
 908668c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 9086690:	003f8406 	br	90864a4 <altera_avalon_jtag_uart_irq+0x28>
}
 9086694:	e037883a 	mov	sp,fp
 9086698:	df000017 	ldw	fp,0(sp)
 908669c:	dec00104 	addi	sp,sp,4
 90866a0:	f800283a 	ret

090866a4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 90866a4:	defffc04 	addi	sp,sp,-16
 90866a8:	df000315 	stw	fp,12(sp)
 90866ac:	df000304 	addi	fp,sp,12
 90866b0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 90866b4:	e0bfff17 	ldw	r2,-4(fp)
 90866b8:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 90866bc:	e0bffe17 	ldw	r2,-8(fp)
 90866c0:	10800017 	ldw	r2,0(r2)
 90866c4:	10800104 	addi	r2,r2,4
 90866c8:	10800037 	ldwio	r2,0(r2)
 90866cc:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 90866d0:	e0bffd17 	ldw	r2,-12(fp)
 90866d4:	1081000c 	andi	r2,r2,1024
 90866d8:	1005003a 	cmpeq	r2,r2,zero
 90866dc:	10000c1e 	bne	r2,zero,9086710 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 90866e0:	e0bffe17 	ldw	r2,-8(fp)
 90866e4:	10800017 	ldw	r2,0(r2)
 90866e8:	11000104 	addi	r4,r2,4
 90866ec:	e0bffe17 	ldw	r2,-8(fp)
 90866f0:	10800817 	ldw	r2,32(r2)
 90866f4:	10810014 	ori	r2,r2,1024
 90866f8:	1007883a 	mov	r3,r2
 90866fc:	2005883a 	mov	r2,r4
 9086700:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 9086704:	e0bffe17 	ldw	r2,-8(fp)
 9086708:	10000915 	stw	zero,36(r2)
 908670c:	00000a06 	br	9086738 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 9086710:	e0bffe17 	ldw	r2,-8(fp)
 9086714:	10c00917 	ldw	r3,36(r2)
 9086718:	00a00034 	movhi	r2,32768
 908671c:	10bfff04 	addi	r2,r2,-4
 9086720:	10c00536 	bltu	r2,r3,9086738 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 9086724:	e0bffe17 	ldw	r2,-8(fp)
 9086728:	10800917 	ldw	r2,36(r2)
 908672c:	10c00044 	addi	r3,r2,1
 9086730:	e0bffe17 	ldw	r2,-8(fp)
 9086734:	10c00915 	stw	r3,36(r2)
 9086738:	00824274 	movhi	r2,2313
 908673c:	10b19704 	addi	r2,r2,-14756
 9086740:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 9086744:	e037883a 	mov	sp,fp
 9086748:	df000017 	ldw	fp,0(sp)
 908674c:	dec00104 	addi	sp,sp,4
 9086750:	f800283a 	ret

09086754 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 9086754:	defffc04 	addi	sp,sp,-16
 9086758:	df000315 	stw	fp,12(sp)
 908675c:	df000304 	addi	fp,sp,12
 9086760:	e13ffd15 	stw	r4,-12(fp)
 9086764:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9086768:	00000706 	br	9086788 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 908676c:	e0bffe17 	ldw	r2,-8(fp)
 9086770:	1090000c 	andi	r2,r2,16384
 9086774:	1005003a 	cmpeq	r2,r2,zero
 9086778:	1000031e 	bne	r2,zero,9086788 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 908677c:	00bffd44 	movi	r2,-11
 9086780:	e0bfff15 	stw	r2,-4(fp)
 9086784:	00000b06 	br	90867b4 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9086788:	e0bffd17 	ldw	r2,-12(fp)
 908678c:	10c00d17 	ldw	r3,52(r2)
 9086790:	e0bffd17 	ldw	r2,-12(fp)
 9086794:	10800c17 	ldw	r2,48(r2)
 9086798:	18800526 	beq	r3,r2,90867b0 <altera_avalon_jtag_uart_close+0x5c>
 908679c:	e0bffd17 	ldw	r2,-12(fp)
 90867a0:	10c00917 	ldw	r3,36(r2)
 90867a4:	e0bffd17 	ldw	r2,-12(fp)
 90867a8:	10800117 	ldw	r2,4(r2)
 90867ac:	18bfef36 	bltu	r3,r2,908676c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 90867b0:	e03fff15 	stw	zero,-4(fp)
 90867b4:	e0bfff17 	ldw	r2,-4(fp)
}
 90867b8:	e037883a 	mov	sp,fp
 90867bc:	df000017 	ldw	fp,0(sp)
 90867c0:	dec00104 	addi	sp,sp,4
 90867c4:	f800283a 	ret

090867c8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 90867c8:	defff804 	addi	sp,sp,-32
 90867cc:	df000715 	stw	fp,28(sp)
 90867d0:	df000704 	addi	fp,sp,28
 90867d4:	e13ffb15 	stw	r4,-20(fp)
 90867d8:	e17ffc15 	stw	r5,-16(fp)
 90867dc:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 90867e0:	00bff9c4 	movi	r2,-25
 90867e4:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 90867e8:	e0bffc17 	ldw	r2,-16(fp)
 90867ec:	e0bfff15 	stw	r2,-4(fp)
 90867f0:	e0ffff17 	ldw	r3,-4(fp)
 90867f4:	189a8060 	cmpeqi	r2,r3,27137
 90867f8:	1000041e 	bne	r2,zero,908680c <altera_avalon_jtag_uart_ioctl+0x44>
 90867fc:	e0ffff17 	ldw	r3,-4(fp)
 9086800:	189a80a0 	cmpeqi	r2,r3,27138
 9086804:	10001b1e 	bne	r2,zero,9086874 <altera_avalon_jtag_uart_ioctl+0xac>
 9086808:	00002706 	br	90868a8 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 908680c:	e0bffb17 	ldw	r2,-20(fp)
 9086810:	10c00117 	ldw	r3,4(r2)
 9086814:	00a00034 	movhi	r2,32768
 9086818:	10bfffc4 	addi	r2,r2,-1
 908681c:	18802226 	beq	r3,r2,90868a8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 9086820:	e0bffd17 	ldw	r2,-12(fp)
 9086824:	10800017 	ldw	r2,0(r2)
 9086828:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 908682c:	e0bff917 	ldw	r2,-28(fp)
 9086830:	10800090 	cmplti	r2,r2,2
 9086834:	1000071e 	bne	r2,zero,9086854 <altera_avalon_jtag_uart_ioctl+0x8c>
 9086838:	e0fff917 	ldw	r3,-28(fp)
 908683c:	00a00034 	movhi	r2,32768
 9086840:	10bfffc4 	addi	r2,r2,-1
 9086844:	18800326 	beq	r3,r2,9086854 <altera_avalon_jtag_uart_ioctl+0x8c>
 9086848:	e0bff917 	ldw	r2,-28(fp)
 908684c:	e0bffe15 	stw	r2,-8(fp)
 9086850:	00000306 	br	9086860 <altera_avalon_jtag_uart_ioctl+0x98>
 9086854:	00e00034 	movhi	r3,32768
 9086858:	18ffff84 	addi	r3,r3,-2
 908685c:	e0fffe15 	stw	r3,-8(fp)
 9086860:	e0bffb17 	ldw	r2,-20(fp)
 9086864:	e0fffe17 	ldw	r3,-8(fp)
 9086868:	10c00115 	stw	r3,4(r2)
      rc = 0;
 908686c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 9086870:	00000d06 	br	90868a8 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 9086874:	e0bffb17 	ldw	r2,-20(fp)
 9086878:	10c00117 	ldw	r3,4(r2)
 908687c:	00a00034 	movhi	r2,32768
 9086880:	10bfffc4 	addi	r2,r2,-1
 9086884:	18800826 	beq	r3,r2,90868a8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 9086888:	e13ffd17 	ldw	r4,-12(fp)
 908688c:	e0bffb17 	ldw	r2,-20(fp)
 9086890:	10c00917 	ldw	r3,36(r2)
 9086894:	e0bffb17 	ldw	r2,-20(fp)
 9086898:	10800117 	ldw	r2,4(r2)
 908689c:	1885803a 	cmpltu	r2,r3,r2
 90868a0:	20800015 	stw	r2,0(r4)
      rc = 0;
 90868a4:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 90868a8:	e0bffa17 	ldw	r2,-24(fp)
}
 90868ac:	e037883a 	mov	sp,fp
 90868b0:	df000017 	ldw	fp,0(sp)
 90868b4:	dec00104 	addi	sp,sp,4
 90868b8:	f800283a 	ret

090868bc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 90868bc:	defff204 	addi	sp,sp,-56
 90868c0:	dfc00d15 	stw	ra,52(sp)
 90868c4:	df000c15 	stw	fp,48(sp)
 90868c8:	df000c04 	addi	fp,sp,48
 90868cc:	e13ffb15 	stw	r4,-20(fp)
 90868d0:	e17ffc15 	stw	r5,-16(fp)
 90868d4:	e1bffd15 	stw	r6,-12(fp)
 90868d8:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 90868dc:	e0bffc17 	ldw	r2,-16(fp)
 90868e0:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 90868e4:	00004806 	br	9086a08 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 90868e8:	e0bffb17 	ldw	r2,-20(fp)
 90868ec:	10800a17 	ldw	r2,40(r2)
 90868f0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 90868f4:	e0bffb17 	ldw	r2,-20(fp)
 90868f8:	10800b17 	ldw	r2,44(r2)
 90868fc:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 9086900:	e0fff717 	ldw	r3,-36(fp)
 9086904:	e0bff617 	ldw	r2,-40(fp)
 9086908:	18800536 	bltu	r3,r2,9086920 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 908690c:	e0bff717 	ldw	r2,-36(fp)
 9086910:	e0fff617 	ldw	r3,-40(fp)
 9086914:	10c5c83a 	sub	r2,r2,r3
 9086918:	e0bff815 	stw	r2,-32(fp)
 908691c:	00000406 	br	9086930 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 9086920:	00820004 	movi	r2,2048
 9086924:	e0fff617 	ldw	r3,-40(fp)
 9086928:	10c5c83a 	sub	r2,r2,r3
 908692c:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 9086930:	e0bff817 	ldw	r2,-32(fp)
 9086934:	1005003a 	cmpeq	r2,r2,zero
 9086938:	10001f1e 	bne	r2,zero,90869b8 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
 908693c:	e0fffd17 	ldw	r3,-12(fp)
 9086940:	e0bff817 	ldw	r2,-32(fp)
 9086944:	1880022e 	bgeu	r3,r2,9086950 <altera_avalon_jtag_uart_read+0x94>
        n = space;
 9086948:	e0bffd17 	ldw	r2,-12(fp)
 908694c:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 9086950:	e0bffb17 	ldw	r2,-20(fp)
 9086954:	10c00e04 	addi	r3,r2,56
 9086958:	e0bff617 	ldw	r2,-40(fp)
 908695c:	1887883a 	add	r3,r3,r2
 9086960:	e0bffa17 	ldw	r2,-24(fp)
 9086964:	1009883a 	mov	r4,r2
 9086968:	180b883a 	mov	r5,r3
 908696c:	e1bff817 	ldw	r6,-32(fp)
 9086970:	9082ca80 	call	9082ca8 <memcpy>
      ptr   += n;
 9086974:	e0fff817 	ldw	r3,-32(fp)
 9086978:	e0bffa17 	ldw	r2,-24(fp)
 908697c:	10c5883a 	add	r2,r2,r3
 9086980:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
 9086984:	e0fffd17 	ldw	r3,-12(fp)
 9086988:	e0bff817 	ldw	r2,-32(fp)
 908698c:	1885c83a 	sub	r2,r3,r2
 9086990:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9086994:	e0fff617 	ldw	r3,-40(fp)
 9086998:	e0bff817 	ldw	r2,-32(fp)
 908699c:	1885883a 	add	r2,r3,r2
 90869a0:	10c1ffcc 	andi	r3,r2,2047
 90869a4:	e0bffb17 	ldw	r2,-20(fp)
 90869a8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 90869ac:	e0bffd17 	ldw	r2,-12(fp)
 90869b0:	10800048 	cmpgei	r2,r2,1
 90869b4:	103fcc1e 	bne	r2,zero,90868e8 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
 90869b8:	e0fffa17 	ldw	r3,-24(fp)
 90869bc:	e0bffc17 	ldw	r2,-16(fp)
 90869c0:	1880141e 	bne	r3,r2,9086a14 <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 90869c4:	e0bffe17 	ldw	r2,-8(fp)
 90869c8:	1090000c 	andi	r2,r2,16384
 90869cc:	1004c03a 	cmpne	r2,r2,zero
 90869d0:	1000101e 	bne	r2,zero,9086a14 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 90869d4:	e0bffb17 	ldw	r2,-20(fp)
 90869d8:	10c00a17 	ldw	r3,40(r2)
 90869dc:	e0bff717 	ldw	r2,-36(fp)
 90869e0:	1880051e 	bne	r3,r2,90869f8 <altera_avalon_jtag_uart_read+0x13c>
 90869e4:	e0bffb17 	ldw	r2,-20(fp)
 90869e8:	10c00917 	ldw	r3,36(r2)
 90869ec:	e0bffb17 	ldw	r2,-20(fp)
 90869f0:	10800117 	ldw	r2,4(r2)
 90869f4:	18bff736 	bltu	r3,r2,90869d4 <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 90869f8:	e0bffb17 	ldw	r2,-20(fp)
 90869fc:	10c00a17 	ldw	r3,40(r2)
 9086a00:	e0bff717 	ldw	r2,-36(fp)
 9086a04:	18800326 	beq	r3,r2,9086a14 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 9086a08:	e0bffd17 	ldw	r2,-12(fp)
 9086a0c:	10800048 	cmpgei	r2,r2,1
 9086a10:	103fb51e 	bne	r2,zero,90868e8 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 9086a14:	e0fffa17 	ldw	r3,-24(fp)
 9086a18:	e0bffc17 	ldw	r2,-16(fp)
 9086a1c:	18801926 	beq	r3,r2,9086a84 <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9086a20:	0005303a 	rdctl	r2,status
 9086a24:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9086a28:	e0fff517 	ldw	r3,-44(fp)
 9086a2c:	00bfff84 	movi	r2,-2
 9086a30:	1884703a 	and	r2,r3,r2
 9086a34:	1001703a 	wrctl	status,r2
  
  return context;
 9086a38:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 9086a3c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9086a40:	e0bffb17 	ldw	r2,-20(fp)
 9086a44:	10800817 	ldw	r2,32(r2)
 9086a48:	10c00054 	ori	r3,r2,1
 9086a4c:	e0bffb17 	ldw	r2,-20(fp)
 9086a50:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 9086a54:	e0bffb17 	ldw	r2,-20(fp)
 9086a58:	10800017 	ldw	r2,0(r2)
 9086a5c:	11000104 	addi	r4,r2,4
 9086a60:	e0bffb17 	ldw	r2,-20(fp)
 9086a64:	10800817 	ldw	r2,32(r2)
 9086a68:	1007883a 	mov	r3,r2
 9086a6c:	2005883a 	mov	r2,r4
 9086a70:	10c00035 	stwio	r3,0(r2)
 9086a74:	e0bff917 	ldw	r2,-28(fp)
 9086a78:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9086a7c:	e0bff417 	ldw	r2,-48(fp)
 9086a80:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 9086a84:	e0fffa17 	ldw	r3,-24(fp)
 9086a88:	e0bffc17 	ldw	r2,-16(fp)
 9086a8c:	18800526 	beq	r3,r2,9086aa4 <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
 9086a90:	e0fffa17 	ldw	r3,-24(fp)
 9086a94:	e0bffc17 	ldw	r2,-16(fp)
 9086a98:	1887c83a 	sub	r3,r3,r2
 9086a9c:	e0ffff15 	stw	r3,-4(fp)
 9086aa0:	00000906 	br	9086ac8 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 9086aa4:	e0bffe17 	ldw	r2,-8(fp)
 9086aa8:	1090000c 	andi	r2,r2,16384
 9086aac:	1005003a 	cmpeq	r2,r2,zero
 9086ab0:	1000031e 	bne	r2,zero,9086ac0 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 9086ab4:	00bffd44 	movi	r2,-11
 9086ab8:	e0bfff15 	stw	r2,-4(fp)
 9086abc:	00000206 	br	9086ac8 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 9086ac0:	00bffec4 	movi	r2,-5
 9086ac4:	e0bfff15 	stw	r2,-4(fp)
 9086ac8:	e0bfff17 	ldw	r2,-4(fp)
}
 9086acc:	e037883a 	mov	sp,fp
 9086ad0:	dfc00117 	ldw	ra,4(sp)
 9086ad4:	df000017 	ldw	fp,0(sp)
 9086ad8:	dec00204 	addi	sp,sp,8
 9086adc:	f800283a 	ret

09086ae0 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 9086ae0:	defff204 	addi	sp,sp,-56
 9086ae4:	dfc00d15 	stw	ra,52(sp)
 9086ae8:	df000c15 	stw	fp,48(sp)
 9086aec:	df000c04 	addi	fp,sp,48
 9086af0:	e13ffb15 	stw	r4,-20(fp)
 9086af4:	e17ffc15 	stw	r5,-16(fp)
 9086af8:	e1bffd15 	stw	r6,-12(fp)
 9086afc:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 9086b00:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 9086b04:	e0bffc17 	ldw	r2,-16(fp)
 9086b08:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 9086b0c:	00003a06 	br	9086bf8 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 9086b10:	e0bffb17 	ldw	r2,-20(fp)
 9086b14:	10800c17 	ldw	r2,48(r2)
 9086b18:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
 9086b1c:	e0bffb17 	ldw	r2,-20(fp)
 9086b20:	10800d17 	ldw	r2,52(r2)
 9086b24:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
 9086b28:	e0fffa17 	ldw	r3,-24(fp)
 9086b2c:	e0bff917 	ldw	r2,-28(fp)
 9086b30:	1880062e 	bgeu	r3,r2,9086b4c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 9086b34:	e0fff917 	ldw	r3,-28(fp)
 9086b38:	e0bffa17 	ldw	r2,-24(fp)
 9086b3c:	1885c83a 	sub	r2,r3,r2
 9086b40:	10bfffc4 	addi	r2,r2,-1
 9086b44:	e0bff815 	stw	r2,-32(fp)
 9086b48:	00000c06 	br	9086b7c <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
 9086b4c:	e0bff917 	ldw	r2,-28(fp)
 9086b50:	1005003a 	cmpeq	r2,r2,zero
 9086b54:	1000051e 	bne	r2,zero,9086b6c <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 9086b58:	00820004 	movi	r2,2048
 9086b5c:	e0fffa17 	ldw	r3,-24(fp)
 9086b60:	10c5c83a 	sub	r2,r2,r3
 9086b64:	e0bff815 	stw	r2,-32(fp)
 9086b68:	00000406 	br	9086b7c <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 9086b6c:	0081ffc4 	movi	r2,2047
 9086b70:	e0fffa17 	ldw	r3,-24(fp)
 9086b74:	10c5c83a 	sub	r2,r2,r3
 9086b78:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 9086b7c:	e0bff817 	ldw	r2,-32(fp)
 9086b80:	1005003a 	cmpeq	r2,r2,zero
 9086b84:	10001f1e 	bne	r2,zero,9086c04 <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
 9086b88:	e0fffd17 	ldw	r3,-12(fp)
 9086b8c:	e0bff817 	ldw	r2,-32(fp)
 9086b90:	1880022e 	bgeu	r3,r2,9086b9c <altera_avalon_jtag_uart_write+0xbc>
        n = count;
 9086b94:	e0bffd17 	ldw	r2,-12(fp)
 9086b98:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 9086b9c:	e0bffb17 	ldw	r2,-20(fp)
 9086ba0:	10c20e04 	addi	r3,r2,2104
 9086ba4:	e0bffa17 	ldw	r2,-24(fp)
 9086ba8:	1885883a 	add	r2,r3,r2
 9086bac:	e0fffc17 	ldw	r3,-16(fp)
 9086bb0:	1009883a 	mov	r4,r2
 9086bb4:	180b883a 	mov	r5,r3
 9086bb8:	e1bff817 	ldw	r6,-32(fp)
 9086bbc:	9082ca80 	call	9082ca8 <memcpy>
      ptr   += n;
 9086bc0:	e0fff817 	ldw	r3,-32(fp)
 9086bc4:	e0bffc17 	ldw	r2,-16(fp)
 9086bc8:	10c5883a 	add	r2,r2,r3
 9086bcc:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 9086bd0:	e0fffd17 	ldw	r3,-12(fp)
 9086bd4:	e0bff817 	ldw	r2,-32(fp)
 9086bd8:	1885c83a 	sub	r2,r3,r2
 9086bdc:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9086be0:	e0fffa17 	ldw	r3,-24(fp)
 9086be4:	e0bff817 	ldw	r2,-32(fp)
 9086be8:	1885883a 	add	r2,r3,r2
 9086bec:	10c1ffcc 	andi	r3,r2,2047
 9086bf0:	e0bffb17 	ldw	r2,-20(fp)
 9086bf4:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 9086bf8:	e0bffd17 	ldw	r2,-12(fp)
 9086bfc:	10800048 	cmpgei	r2,r2,1
 9086c00:	103fc31e 	bne	r2,zero,9086b10 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9086c04:	0005303a 	rdctl	r2,status
 9086c08:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9086c0c:	e0fff517 	ldw	r3,-44(fp)
 9086c10:	00bfff84 	movi	r2,-2
 9086c14:	1884703a 	and	r2,r3,r2
 9086c18:	1001703a 	wrctl	status,r2
  
  return context;
 9086c1c:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 9086c20:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 9086c24:	e0bffb17 	ldw	r2,-20(fp)
 9086c28:	10800817 	ldw	r2,32(r2)
 9086c2c:	10c00094 	ori	r3,r2,2
 9086c30:	e0bffb17 	ldw	r2,-20(fp)
 9086c34:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 9086c38:	e0bffb17 	ldw	r2,-20(fp)
 9086c3c:	10800017 	ldw	r2,0(r2)
 9086c40:	11000104 	addi	r4,r2,4
 9086c44:	e0bffb17 	ldw	r2,-20(fp)
 9086c48:	10800817 	ldw	r2,32(r2)
 9086c4c:	1007883a 	mov	r3,r2
 9086c50:	2005883a 	mov	r2,r4
 9086c54:	10c00035 	stwio	r3,0(r2)
 9086c58:	e0bff717 	ldw	r2,-36(fp)
 9086c5c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9086c60:	e0bff417 	ldw	r2,-48(fp)
 9086c64:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 9086c68:	e0bffd17 	ldw	r2,-12(fp)
 9086c6c:	10800050 	cmplti	r2,r2,1
 9086c70:	1000111e 	bne	r2,zero,9086cb8 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
 9086c74:	e0bffe17 	ldw	r2,-8(fp)
 9086c78:	1090000c 	andi	r2,r2,16384
 9086c7c:	1004c03a 	cmpne	r2,r2,zero
 9086c80:	1000101e 	bne	r2,zero,9086cc4 <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 9086c84:	e0bffb17 	ldw	r2,-20(fp)
 9086c88:	10c00d17 	ldw	r3,52(r2)
 9086c8c:	e0bff917 	ldw	r2,-28(fp)
 9086c90:	1880051e 	bne	r3,r2,9086ca8 <altera_avalon_jtag_uart_write+0x1c8>
 9086c94:	e0bffb17 	ldw	r2,-20(fp)
 9086c98:	10c00917 	ldw	r3,36(r2)
 9086c9c:	e0bffb17 	ldw	r2,-20(fp)
 9086ca0:	10800117 	ldw	r2,4(r2)
 9086ca4:	18bff736 	bltu	r3,r2,9086c84 <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 9086ca8:	e0bffb17 	ldw	r2,-20(fp)
 9086cac:	10c00d17 	ldw	r3,52(r2)
 9086cb0:	e0bff917 	ldw	r2,-28(fp)
 9086cb4:	18800326 	beq	r3,r2,9086cc4 <altera_avalon_jtag_uart_write+0x1e4>
         break;
    }
  }
  while (count > 0);
 9086cb8:	e0bffd17 	ldw	r2,-12(fp)
 9086cbc:	10800048 	cmpgei	r2,r2,1
 9086cc0:	103fcd1e 	bne	r2,zero,9086bf8 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 9086cc4:	e0fffc17 	ldw	r3,-16(fp)
 9086cc8:	e0bff617 	ldw	r2,-40(fp)
 9086ccc:	18800526 	beq	r3,r2,9086ce4 <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
 9086cd0:	e0fffc17 	ldw	r3,-16(fp)
 9086cd4:	e0bff617 	ldw	r2,-40(fp)
 9086cd8:	1887c83a 	sub	r3,r3,r2
 9086cdc:	e0ffff15 	stw	r3,-4(fp)
 9086ce0:	00000906 	br	9086d08 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
 9086ce4:	e0bffe17 	ldw	r2,-8(fp)
 9086ce8:	1090000c 	andi	r2,r2,16384
 9086cec:	1005003a 	cmpeq	r2,r2,zero
 9086cf0:	1000031e 	bne	r2,zero,9086d00 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
 9086cf4:	00bffd44 	movi	r2,-11
 9086cf8:	e0bfff15 	stw	r2,-4(fp)
 9086cfc:	00000206 	br	9086d08 <altera_avalon_jtag_uart_write+0x228>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 9086d00:	00bffec4 	movi	r2,-5
 9086d04:	e0bfff15 	stw	r2,-4(fp)
 9086d08:	e0bfff17 	ldw	r2,-4(fp)
}
 9086d0c:	e037883a 	mov	sp,fp
 9086d10:	dfc00117 	ldw	ra,4(sp)
 9086d14:	df000017 	ldw	fp,0(sp)
 9086d18:	dec00204 	addi	sp,sp,8
 9086d1c:	f800283a 	ret

09086d20 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 9086d20:	defffa04 	addi	sp,sp,-24
 9086d24:	dfc00515 	stw	ra,20(sp)
 9086d28:	df000415 	stw	fp,16(sp)
 9086d2c:	df000404 	addi	fp,sp,16
 9086d30:	e13ffe15 	stw	r4,-8(fp)
 9086d34:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 9086d38:	e0bffe17 	ldw	r2,-8(fp)
 9086d3c:	10800017 	ldw	r2,0(r2)
 9086d40:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 9086d44:	008003f4 	movhi	r2,15
 9086d48:	10909004 	addi	r2,r2,16960
 9086d4c:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9086d50:	e0bffe17 	ldw	r2,-8(fp)
 9086d54:	10800803 	ldbu	r2,32(r2)
 9086d58:	10803fcc 	andi	r2,r2,255
 9086d5c:	1080201c 	xori	r2,r2,128
 9086d60:	10bfe004 	addi	r2,r2,-128
 9086d64:	1004c03a 	cmpne	r2,r2,zero
 9086d68:	1000161e 	bne	r2,zero,9086dc4 <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9086d6c:	00000a06 	br	9086d98 <lcd_write_command+0x78>
    if (--i == 0)
 9086d70:	e0bffc17 	ldw	r2,-16(fp)
 9086d74:	10bfffc4 	addi	r2,r2,-1
 9086d78:	e0bffc15 	stw	r2,-16(fp)
 9086d7c:	e0bffc17 	ldw	r2,-16(fp)
 9086d80:	1004c03a 	cmpne	r2,r2,zero
 9086d84:	1000041e 	bne	r2,zero,9086d98 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 9086d88:	e0fffe17 	ldw	r3,-8(fp)
 9086d8c:	00800044 	movi	r2,1
 9086d90:	18800805 	stb	r2,32(r3)
      return;
 9086d94:	00000b06 	br	9086dc4 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9086d98:	e0bffd17 	ldw	r2,-12(fp)
 9086d9c:	10800104 	addi	r2,r2,4
 9086da0:	10800037 	ldwio	r2,0(r2)
 9086da4:	1080200c 	andi	r2,r2,128
 9086da8:	1004c03a 	cmpne	r2,r2,zero
 9086dac:	103ff01e 	bne	r2,zero,9086d70 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 9086db0:	01001904 	movi	r4,100
 9086db4:	90898240 	call	9089824 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 9086db8:	e0bffd17 	ldw	r2,-12(fp)
 9086dbc:	e0ffff03 	ldbu	r3,-4(fp)
 9086dc0:	10c00035 	stwio	r3,0(r2)
}
 9086dc4:	e037883a 	mov	sp,fp
 9086dc8:	dfc00117 	ldw	ra,4(sp)
 9086dcc:	df000017 	ldw	fp,0(sp)
 9086dd0:	dec00204 	addi	sp,sp,8
 9086dd4:	f800283a 	ret

09086dd8 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 9086dd8:	defffa04 	addi	sp,sp,-24
 9086ddc:	dfc00515 	stw	ra,20(sp)
 9086de0:	df000415 	stw	fp,16(sp)
 9086de4:	df000404 	addi	fp,sp,16
 9086de8:	e13ffe15 	stw	r4,-8(fp)
 9086dec:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 9086df0:	e0bffe17 	ldw	r2,-8(fp)
 9086df4:	10800017 	ldw	r2,0(r2)
 9086df8:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 9086dfc:	008003f4 	movhi	r2,15
 9086e00:	10909004 	addi	r2,r2,16960
 9086e04:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9086e08:	e0bffe17 	ldw	r2,-8(fp)
 9086e0c:	10800803 	ldbu	r2,32(r2)
 9086e10:	10803fcc 	andi	r2,r2,255
 9086e14:	1080201c 	xori	r2,r2,128
 9086e18:	10bfe004 	addi	r2,r2,-128
 9086e1c:	1004c03a 	cmpne	r2,r2,zero
 9086e20:	10001d1e 	bne	r2,zero,9086e98 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9086e24:	00000a06 	br	9086e50 <lcd_write_data+0x78>
    if (--i == 0)
 9086e28:	e0bffc17 	ldw	r2,-16(fp)
 9086e2c:	10bfffc4 	addi	r2,r2,-1
 9086e30:	e0bffc15 	stw	r2,-16(fp)
 9086e34:	e0bffc17 	ldw	r2,-16(fp)
 9086e38:	1004c03a 	cmpne	r2,r2,zero
 9086e3c:	1000041e 	bne	r2,zero,9086e50 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 9086e40:	e0fffe17 	ldw	r3,-8(fp)
 9086e44:	00800044 	movi	r2,1
 9086e48:	18800805 	stb	r2,32(r3)
      return;
 9086e4c:	00001206 	br	9086e98 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9086e50:	e0bffd17 	ldw	r2,-12(fp)
 9086e54:	10800104 	addi	r2,r2,4
 9086e58:	10800037 	ldwio	r2,0(r2)
 9086e5c:	1080200c 	andi	r2,r2,128
 9086e60:	1004c03a 	cmpne	r2,r2,zero
 9086e64:	103ff01e 	bne	r2,zero,9086e28 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 9086e68:	01001904 	movi	r4,100
 9086e6c:	90898240 	call	9089824 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 9086e70:	e0bffd17 	ldw	r2,-12(fp)
 9086e74:	10800204 	addi	r2,r2,8
 9086e78:	e0ffff03 	ldbu	r3,-4(fp)
 9086e7c:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 9086e80:	e0bffe17 	ldw	r2,-8(fp)
 9086e84:	108008c3 	ldbu	r2,35(r2)
 9086e88:	10800044 	addi	r2,r2,1
 9086e8c:	1007883a 	mov	r3,r2
 9086e90:	e0bffe17 	ldw	r2,-8(fp)
 9086e94:	10c008c5 	stb	r3,35(r2)
}
 9086e98:	e037883a 	mov	sp,fp
 9086e9c:	dfc00117 	ldw	ra,4(sp)
 9086ea0:	df000017 	ldw	fp,0(sp)
 9086ea4:	dec00204 	addi	sp,sp,8
 9086ea8:	f800283a 	ret

09086eac <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 9086eac:	defffc04 	addi	sp,sp,-16
 9086eb0:	dfc00315 	stw	ra,12(sp)
 9086eb4:	df000215 	stw	fp,8(sp)
 9086eb8:	df000204 	addi	fp,sp,8
 9086ebc:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 9086ec0:	e13fff17 	ldw	r4,-4(fp)
 9086ec4:	01400044 	movi	r5,1
 9086ec8:	9086d200 	call	9086d20 <lcd_write_command>

  sp->x = 0;
 9086ecc:	e0bfff17 	ldw	r2,-4(fp)
 9086ed0:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 9086ed4:	e0bfff17 	ldw	r2,-4(fp)
 9086ed8:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 9086edc:	e0bfff17 	ldw	r2,-4(fp)
 9086ee0:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9086ee4:	e03ffe15 	stw	zero,-8(fp)
 9086ee8:	00001906 	br	9086f50 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 9086eec:	e0bffe17 	ldw	r2,-8(fp)
 9086ef0:	108018e4 	muli	r2,r2,99
 9086ef4:	10c01004 	addi	r3,r2,64
 9086ef8:	e0bfff17 	ldw	r2,-4(fp)
 9086efc:	1889883a 	add	r4,r3,r2
 9086f00:	01400804 	movi	r5,32
 9086f04:	01801444 	movi	r6,81
 9086f08:	9081ee40 	call	9081ee4 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 9086f0c:	e0bffe17 	ldw	r2,-8(fp)
 9086f10:	108018e4 	muli	r2,r2,99
 9086f14:	10c00c04 	addi	r3,r2,48
 9086f18:	e0bfff17 	ldw	r2,-4(fp)
 9086f1c:	1889883a 	add	r4,r3,r2
 9086f20:	01400804 	movi	r5,32
 9086f24:	01800404 	movi	r6,16
 9086f28:	9081ee40 	call	9081ee4 <memset>
    sp->line[y].width = 0;
 9086f2c:	e0bffe17 	ldw	r2,-8(fp)
 9086f30:	e0ffff17 	ldw	r3,-4(fp)
 9086f34:	108018e4 	muli	r2,r2,99
 9086f38:	10c5883a 	add	r2,r2,r3
 9086f3c:	10802404 	addi	r2,r2,144
 9086f40:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9086f44:	e0bffe17 	ldw	r2,-8(fp)
 9086f48:	10800044 	addi	r2,r2,1
 9086f4c:	e0bffe15 	stw	r2,-8(fp)
 9086f50:	e0bffe17 	ldw	r2,-8(fp)
 9086f54:	10800090 	cmplti	r2,r2,2
 9086f58:	103fe41e 	bne	r2,zero,9086eec <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 9086f5c:	e037883a 	mov	sp,fp
 9086f60:	dfc00117 	ldw	ra,4(sp)
 9086f64:	df000017 	ldw	fp,0(sp)
 9086f68:	dec00204 	addi	sp,sp,8
 9086f6c:	f800283a 	ret

09086f70 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 9086f70:	defff704 	addi	sp,sp,-36
 9086f74:	dfc00815 	stw	ra,32(sp)
 9086f78:	df000715 	stw	fp,28(sp)
 9086f7c:	df000704 	addi	fp,sp,28
 9086f80:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 9086f84:	e0bfff17 	ldw	r2,-4(fp)
 9086f88:	10800943 	ldbu	r2,37(r2)
 9086f8c:	10803fcc 	andi	r2,r2,255
 9086f90:	1080201c 	xori	r2,r2,128
 9086f94:	10bfe004 	addi	r2,r2,-128
 9086f98:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9086f9c:	e03ffe15 	stw	zero,-8(fp)
 9086fa0:	00006606 	br	908713c <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
 9086fa4:	e0bffe17 	ldw	r2,-8(fp)
 9086fa8:	e0ffff17 	ldw	r3,-4(fp)
 9086fac:	108018e4 	muli	r2,r2,99
 9086fb0:	10c5883a 	add	r2,r2,r3
 9086fb4:	10802404 	addi	r2,r2,144
 9086fb8:	10800043 	ldbu	r2,1(r2)
 9086fbc:	10803fcc 	andi	r2,r2,255
 9086fc0:	1080201c 	xori	r2,r2,128
 9086fc4:	10bfe004 	addi	r2,r2,-128
 9086fc8:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 9086fcc:	e0bffe17 	ldw	r2,-8(fp)
 9086fd0:	e0ffff17 	ldw	r3,-4(fp)
 9086fd4:	108018e4 	muli	r2,r2,99
 9086fd8:	10c5883a 	add	r2,r2,r3
 9086fdc:	10802404 	addi	r2,r2,144
 9086fe0:	10800083 	ldbu	r2,2(r2)
 9086fe4:	10c03fcc 	andi	r3,r2,255
 9086fe8:	e0bffc17 	ldw	r2,-16(fp)
 9086fec:	1885383a 	mul	r2,r3,r2
 9086ff0:	1005d23a 	srai	r2,r2,8
 9086ff4:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 9086ff8:	e0fffa17 	ldw	r3,-24(fp)
 9086ffc:	e0bffb17 	ldw	r2,-20(fp)
 9087000:	18800116 	blt	r3,r2,9087008 <lcd_repaint_screen+0x98>
      offset = 0;
 9087004:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9087008:	e03ffd15 	stw	zero,-12(fp)
 908700c:	00004506 	br	9087124 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
 9087010:	e17ffe17 	ldw	r5,-8(fp)
 9087014:	e0fffd17 	ldw	r3,-12(fp)
 9087018:	e0bffa17 	ldw	r2,-24(fp)
 908701c:	1889883a 	add	r4,r3,r2
 9087020:	e0bffb17 	ldw	r2,-20(fp)
 9087024:	2087283a 	div	r3,r4,r2
 9087028:	e0bffb17 	ldw	r2,-20(fp)
 908702c:	1885383a 	mul	r2,r3,r2
 9087030:	2089c83a 	sub	r4,r4,r2
 9087034:	e0ffff17 	ldw	r3,-4(fp)
 9087038:	288018e4 	muli	r2,r5,99
 908703c:	10c5883a 	add	r2,r2,r3
 9087040:	1105883a 	add	r2,r2,r4
 9087044:	10801004 	addi	r2,r2,64
 9087048:	10800003 	ldbu	r2,0(r2)
 908704c:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 9087050:	e0bffe17 	ldw	r2,-8(fp)
 9087054:	e13ffd17 	ldw	r4,-12(fp)
 9087058:	e0ffff17 	ldw	r3,-4(fp)
 908705c:	108018e4 	muli	r2,r2,99
 9087060:	10c5883a 	add	r2,r2,r3
 9087064:	1105883a 	add	r2,r2,r4
 9087068:	10800c04 	addi	r2,r2,48
 908706c:	10800003 	ldbu	r2,0(r2)
 9087070:	10c03fcc 	andi	r3,r2,255
 9087074:	18c0201c 	xori	r3,r3,128
 9087078:	18ffe004 	addi	r3,r3,-128
 908707c:	e0bff947 	ldb	r2,-27(fp)
 9087080:	18802526 	beq	r3,r2,9087118 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
 9087084:	e0fffe17 	ldw	r3,-8(fp)
 9087088:	d0a00b04 	addi	r2,gp,-32724
 908708c:	1885883a 	add	r2,r3,r2
 9087090:	10800003 	ldbu	r2,0(r2)
 9087094:	1007883a 	mov	r3,r2
 9087098:	e0bffd17 	ldw	r2,-12(fp)
 908709c:	1885883a 	add	r2,r3,r2
 90870a0:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 90870a4:	e0fff903 	ldbu	r3,-28(fp)
 90870a8:	e0bfff17 	ldw	r2,-4(fp)
 90870ac:	108008c3 	ldbu	r2,35(r2)
 90870b0:	10803fcc 	andi	r2,r2,255
 90870b4:	1080201c 	xori	r2,r2,128
 90870b8:	10bfe004 	addi	r2,r2,-128
 90870bc:	18800926 	beq	r3,r2,90870e4 <lcd_repaint_screen+0x174>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 90870c0:	e0fff903 	ldbu	r3,-28(fp)
 90870c4:	00bfe004 	movi	r2,-128
 90870c8:	1884b03a 	or	r2,r3,r2
 90870cc:	11403fcc 	andi	r5,r2,255
 90870d0:	e13fff17 	ldw	r4,-4(fp)
 90870d4:	9086d200 	call	9086d20 <lcd_write_command>
          sp->address = address;
 90870d8:	e0fff903 	ldbu	r3,-28(fp)
 90870dc:	e0bfff17 	ldw	r2,-4(fp)
 90870e0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 90870e4:	e0bff943 	ldbu	r2,-27(fp)
 90870e8:	11403fcc 	andi	r5,r2,255
 90870ec:	e13fff17 	ldw	r4,-4(fp)
 90870f0:	9086dd80 	call	9086dd8 <lcd_write_data>
        sp->line[y].visible[x] = c;
 90870f4:	e0bffe17 	ldw	r2,-8(fp)
 90870f8:	e13ffd17 	ldw	r4,-12(fp)
 90870fc:	e0ffff17 	ldw	r3,-4(fp)
 9087100:	108018e4 	muli	r2,r2,99
 9087104:	10c5883a 	add	r2,r2,r3
 9087108:	1105883a 	add	r2,r2,r4
 908710c:	10c00c04 	addi	r3,r2,48
 9087110:	e0bff943 	ldbu	r2,-27(fp)
 9087114:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9087118:	e0bffd17 	ldw	r2,-12(fp)
 908711c:	10800044 	addi	r2,r2,1
 9087120:	e0bffd15 	stw	r2,-12(fp)
 9087124:	e0bffd17 	ldw	r2,-12(fp)
 9087128:	10800410 	cmplti	r2,r2,16
 908712c:	103fb81e 	bne	r2,zero,9087010 <lcd_repaint_screen+0xa0>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9087130:	e0bffe17 	ldw	r2,-8(fp)
 9087134:	10800044 	addi	r2,r2,1
 9087138:	e0bffe15 	stw	r2,-8(fp)
 908713c:	e0bffe17 	ldw	r2,-8(fp)
 9087140:	10800090 	cmplti	r2,r2,2
 9087144:	103f971e 	bne	r2,zero,9086fa4 <lcd_repaint_screen+0x34>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 9087148:	e037883a 	mov	sp,fp
 908714c:	dfc00117 	ldw	ra,4(sp)
 9087150:	df000017 	ldw	fp,0(sp)
 9087154:	dec00204 	addi	sp,sp,8
 9087158:	f800283a 	ret

0908715c <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 908715c:	defffc04 	addi	sp,sp,-16
 9087160:	dfc00315 	stw	ra,12(sp)
 9087164:	df000215 	stw	fp,8(sp)
 9087168:	df000204 	addi	fp,sp,8
 908716c:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9087170:	e03ffe15 	stw	zero,-8(fp)
 9087174:	00001d06 	br	90871ec <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 9087178:	e0bffe17 	ldw	r2,-8(fp)
 908717c:	10800048 	cmpgei	r2,r2,1
 9087180:	10000f1e 	bne	r2,zero,90871c0 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 9087184:	e0bffe17 	ldw	r2,-8(fp)
 9087188:	108018e4 	muli	r2,r2,99
 908718c:	10c01004 	addi	r3,r2,64
 9087190:	e0bfff17 	ldw	r2,-4(fp)
 9087194:	1889883a 	add	r4,r3,r2
 9087198:	e0bffe17 	ldw	r2,-8(fp)
 908719c:	10800044 	addi	r2,r2,1
 90871a0:	108018e4 	muli	r2,r2,99
 90871a4:	10c01004 	addi	r3,r2,64
 90871a8:	e0bfff17 	ldw	r2,-4(fp)
 90871ac:	1885883a 	add	r2,r3,r2
 90871b0:	100b883a 	mov	r5,r2
 90871b4:	01801404 	movi	r6,80
 90871b8:	9082ca80 	call	9082ca8 <memcpy>
 90871bc:	00000806 	br	90871e0 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 90871c0:	e0bffe17 	ldw	r2,-8(fp)
 90871c4:	108018e4 	muli	r2,r2,99
 90871c8:	10c01004 	addi	r3,r2,64
 90871cc:	e0bfff17 	ldw	r2,-4(fp)
 90871d0:	1889883a 	add	r4,r3,r2
 90871d4:	01400804 	movi	r5,32
 90871d8:	01801404 	movi	r6,80
 90871dc:	9081ee40 	call	9081ee4 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90871e0:	e0bffe17 	ldw	r2,-8(fp)
 90871e4:	10800044 	addi	r2,r2,1
 90871e8:	e0bffe15 	stw	r2,-8(fp)
 90871ec:	e0bffe17 	ldw	r2,-8(fp)
 90871f0:	10800090 	cmplti	r2,r2,2
 90871f4:	103fe01e 	bne	r2,zero,9087178 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 90871f8:	e0bfff17 	ldw	r2,-4(fp)
 90871fc:	10800883 	ldbu	r2,34(r2)
 9087200:	10bfffc4 	addi	r2,r2,-1
 9087204:	1007883a 	mov	r3,r2
 9087208:	e0bfff17 	ldw	r2,-4(fp)
 908720c:	10c00885 	stb	r3,34(r2)
}
 9087210:	e037883a 	mov	sp,fp
 9087214:	dfc00117 	ldw	ra,4(sp)
 9087218:	df000017 	ldw	fp,0(sp)
 908721c:	dec00204 	addi	sp,sp,8
 9087220:	f800283a 	ret

09087224 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 9087224:	defff804 	addi	sp,sp,-32
 9087228:	dfc00715 	stw	ra,28(sp)
 908722c:	df000615 	stw	fp,24(sp)
 9087230:	df000604 	addi	fp,sp,24
 9087234:	e13ffd15 	stw	r4,-12(fp)
 9087238:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 908723c:	e03ffc15 	stw	zero,-16(fp)
 9087240:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 9087244:	e0bffd17 	ldw	r2,-12(fp)
 9087248:	10800a03 	ldbu	r2,40(r2)
 908724c:	10803fcc 	andi	r2,r2,255
 9087250:	1080201c 	xori	r2,r2,128
 9087254:	10bfe004 	addi	r2,r2,-128
 9087258:	108016d8 	cmpnei	r2,r2,91
 908725c:	1000491e 	bne	r2,zero,9087384 <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 9087260:	e0bffd17 	ldw	r2,-12(fp)
 9087264:	10800a04 	addi	r2,r2,40
 9087268:	10800044 	addi	r2,r2,1
 908726c:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 9087270:	00000d06 	br	90872a8 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 9087274:	e0bffc17 	ldw	r2,-16(fp)
 9087278:	10c002a4 	muli	r3,r2,10
 908727c:	e0bffa17 	ldw	r2,-24(fp)
 9087280:	10800003 	ldbu	r2,0(r2)
 9087284:	10803fcc 	andi	r2,r2,255
 9087288:	1080201c 	xori	r2,r2,128
 908728c:	10bfe004 	addi	r2,r2,-128
 9087290:	1885883a 	add	r2,r3,r2
 9087294:	10bff404 	addi	r2,r2,-48
 9087298:	e0bffc15 	stw	r2,-16(fp)
 908729c:	e0bffa17 	ldw	r2,-24(fp)
 90872a0:	10800044 	addi	r2,r2,1
 90872a4:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 90872a8:	e0bffa17 	ldw	r2,-24(fp)
 90872ac:	10800003 	ldbu	r2,0(r2)
 90872b0:	10803fcc 	andi	r2,r2,255
 90872b4:	1080201c 	xori	r2,r2,128
 90872b8:	10bfe004 	addi	r2,r2,-128
 90872bc:	1007883a 	mov	r3,r2
 90872c0:	00824274 	movhi	r2,2313
 90872c4:	10b18e04 	addi	r2,r2,-14792
 90872c8:	10800017 	ldw	r2,0(r2)
 90872cc:	1885883a 	add	r2,r3,r2
 90872d0:	10800003 	ldbu	r2,0(r2)
 90872d4:	10803fcc 	andi	r2,r2,255
 90872d8:	1080010c 	andi	r2,r2,4
 90872dc:	1004c03a 	cmpne	r2,r2,zero
 90872e0:	103fe41e 	bne	r2,zero,9087274 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 90872e4:	e0bffa17 	ldw	r2,-24(fp)
 90872e8:	10800003 	ldbu	r2,0(r2)
 90872ec:	10803fcc 	andi	r2,r2,255
 90872f0:	1080201c 	xori	r2,r2,128
 90872f4:	10bfe004 	addi	r2,r2,-128
 90872f8:	10800ed8 	cmpnei	r2,r2,59
 90872fc:	1000231e 	bne	r2,zero,908738c <lcd_handle_escape+0x168>
    {
      ptr++;
 9087300:	e0bffa17 	ldw	r2,-24(fp)
 9087304:	10800044 	addi	r2,r2,1
 9087308:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 908730c:	00000d06 	br	9087344 <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 9087310:	e0bffb17 	ldw	r2,-20(fp)
 9087314:	10c002a4 	muli	r3,r2,10
 9087318:	e0bffa17 	ldw	r2,-24(fp)
 908731c:	10800003 	ldbu	r2,0(r2)
 9087320:	10803fcc 	andi	r2,r2,255
 9087324:	1080201c 	xori	r2,r2,128
 9087328:	10bfe004 	addi	r2,r2,-128
 908732c:	1885883a 	add	r2,r3,r2
 9087330:	10bff404 	addi	r2,r2,-48
 9087334:	e0bffb15 	stw	r2,-20(fp)
 9087338:	e0bffa17 	ldw	r2,-24(fp)
 908733c:	10800044 	addi	r2,r2,1
 9087340:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 9087344:	e0bffa17 	ldw	r2,-24(fp)
 9087348:	10800003 	ldbu	r2,0(r2)
 908734c:	10803fcc 	andi	r2,r2,255
 9087350:	1080201c 	xori	r2,r2,128
 9087354:	10bfe004 	addi	r2,r2,-128
 9087358:	1007883a 	mov	r3,r2
 908735c:	00824274 	movhi	r2,2313
 9087360:	10b18e04 	addi	r2,r2,-14792
 9087364:	10800017 	ldw	r2,0(r2)
 9087368:	1885883a 	add	r2,r3,r2
 908736c:	10800003 	ldbu	r2,0(r2)
 9087370:	10803fcc 	andi	r2,r2,255
 9087374:	1080010c 	andi	r2,r2,4
 9087378:	1004c03a 	cmpne	r2,r2,zero
 908737c:	103fe41e 	bne	r2,zero,9087310 <lcd_handle_escape+0xec>
 9087380:	00000206 	br	908738c <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 9087384:	00bfffc4 	movi	r2,-1
 9087388:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 908738c:	e0bffe07 	ldb	r2,-8(fp)
 9087390:	e0bfff15 	stw	r2,-4(fp)
 9087394:	e0ffff17 	ldw	r3,-4(fp)
 9087398:	188012a0 	cmpeqi	r2,r3,74
 908739c:	10002f1e 	bne	r2,zero,908745c <lcd_handle_escape+0x238>
 90873a0:	e0ffff17 	ldw	r3,-4(fp)
 90873a4:	188012c8 	cmpgei	r2,r3,75
 90873a8:	1000041e 	bne	r2,zero,90873bc <lcd_handle_escape+0x198>
 90873ac:	e0ffff17 	ldw	r3,-4(fp)
 90873b0:	18801220 	cmpeqi	r2,r3,72
 90873b4:	1000081e 	bne	r2,zero,90873d8 <lcd_handle_escape+0x1b4>
 90873b8:	00004906 	br	90874e0 <lcd_handle_escape+0x2bc>
 90873bc:	e0ffff17 	ldw	r3,-4(fp)
 90873c0:	188012e0 	cmpeqi	r2,r3,75
 90873c4:	10002b1e 	bne	r2,zero,9087474 <lcd_handle_escape+0x250>
 90873c8:	e0ffff17 	ldw	r3,-4(fp)
 90873cc:	188019a0 	cmpeqi	r2,r3,102
 90873d0:	1000011e 	bne	r2,zero,90873d8 <lcd_handle_escape+0x1b4>
 90873d4:	00004206 	br	90874e0 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 90873d8:	e0bffb17 	ldw	r2,-20(fp)
 90873dc:	10800050 	cmplti	r2,r2,1
 90873e0:	1000051e 	bne	r2,zero,90873f8 <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 90873e4:	e0bffb17 	ldw	r2,-20(fp)
 90873e8:	10bfffc4 	addi	r2,r2,-1
 90873ec:	1007883a 	mov	r3,r2
 90873f0:	e0bffd17 	ldw	r2,-12(fp)
 90873f4:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 90873f8:	e0bffc17 	ldw	r2,-16(fp)
 90873fc:	10800050 	cmplti	r2,r2,1
 9087400:	1000371e 	bne	r2,zero,90874e0 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 9087404:	e0bffc17 	ldw	r2,-16(fp)
 9087408:	10bfffc4 	addi	r2,r2,-1
 908740c:	1007883a 	mov	r3,r2
 9087410:	e0bffd17 	ldw	r2,-12(fp)
 9087414:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 9087418:	e0bffd17 	ldw	r2,-12(fp)
 908741c:	10800883 	ldbu	r2,34(r2)
 9087420:	10803fcc 	andi	r2,r2,255
 9087424:	10800170 	cmpltui	r2,r2,5
 9087428:	1000061e 	bne	r2,zero,9087444 <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 908742c:	e0fffd17 	ldw	r3,-12(fp)
 9087430:	00800104 	movi	r2,4
 9087434:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 9087438:	00000206 	br	9087444 <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 908743c:	e13ffd17 	ldw	r4,-12(fp)
 9087440:	908715c0 	call	908715c <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 9087444:	e0bffd17 	ldw	r2,-12(fp)
 9087448:	10800883 	ldbu	r2,34(r2)
 908744c:	10803fcc 	andi	r2,r2,255
 9087450:	108000e8 	cmpgeui	r2,r2,3
 9087454:	103ff91e 	bne	r2,zero,908743c <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 9087458:	00002106 	br	90874e0 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 908745c:	e0bffc17 	ldw	r2,-16(fp)
 9087460:	10800098 	cmpnei	r2,r2,2
 9087464:	10001e1e 	bne	r2,zero,90874e0 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 9087468:	e13ffd17 	ldw	r4,-12(fp)
 908746c:	9086eac0 	call	9086eac <lcd_clear_screen>
    break;
 9087470:	00001b06 	br	90874e0 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 9087474:	e0bffc17 	ldw	r2,-16(fp)
 9087478:	10800048 	cmpgei	r2,r2,1
 908747c:	1000181e 	bne	r2,zero,90874e0 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9087480:	e0bffd17 	ldw	r2,-12(fp)
 9087484:	10800843 	ldbu	r2,33(r2)
 9087488:	10803fcc 	andi	r2,r2,255
 908748c:	10801428 	cmpgeui	r2,r2,80
 9087490:	1000131e 	bne	r2,zero,90874e0 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 9087494:	e0bffd17 	ldw	r2,-12(fp)
 9087498:	10800883 	ldbu	r2,34(r2)
 908749c:	10803fcc 	andi	r2,r2,255
 90874a0:	108018e4 	muli	r2,r2,99
 90874a4:	10c01004 	addi	r3,r2,64
 90874a8:	e0bffd17 	ldw	r2,-12(fp)
 90874ac:	1887883a 	add	r3,r3,r2
 90874b0:	e0bffd17 	ldw	r2,-12(fp)
 90874b4:	10800843 	ldbu	r2,33(r2)
 90874b8:	10803fcc 	andi	r2,r2,255
 90874bc:	1889883a 	add	r4,r3,r2
 90874c0:	e0bffd17 	ldw	r2,-12(fp)
 90874c4:	10800843 	ldbu	r2,33(r2)
 90874c8:	10c03fcc 	andi	r3,r2,255
 90874cc:	00801404 	movi	r2,80
 90874d0:	10c5c83a 	sub	r2,r2,r3
 90874d4:	100d883a 	mov	r6,r2
 90874d8:	01400804 	movi	r5,32
 90874dc:	9081ee40 	call	9081ee4 <memset>
    }
    break;
  }
}
 90874e0:	e037883a 	mov	sp,fp
 90874e4:	dfc00117 	ldw	ra,4(sp)
 90874e8:	df000017 	ldw	fp,0(sp)
 90874ec:	dec00204 	addi	sp,sp,8
 90874f0:	f800283a 	ret

090874f4 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 90874f4:	defff304 	addi	sp,sp,-52
 90874f8:	dfc00c15 	stw	ra,48(sp)
 90874fc:	df000b15 	stw	fp,44(sp)
 9087500:	df000b04 	addi	fp,sp,44
 9087504:	e13ffc15 	stw	r4,-16(fp)
 9087508:	e17ffd15 	stw	r5,-12(fp)
 908750c:	e1bffe15 	stw	r6,-8(fp)
 9087510:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 9087514:	e0bffe17 	ldw	r2,-8(fp)
 9087518:	1007883a 	mov	r3,r2
 908751c:	e0bffd17 	ldw	r2,-12(fp)
 9087520:	10c5883a 	add	r2,r2,r3
 9087524:	e0bffb15 	stw	r2,-20(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 9087528:	e0fffc17 	ldw	r3,-16(fp)
 908752c:	00800044 	movi	r2,1
 9087530:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 9087534:	0000a206 	br	90877c0 <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 9087538:	e0bffd17 	ldw	r2,-12(fp)
 908753c:	10800003 	ldbu	r2,0(r2)
 9087540:	e0bff805 	stb	r2,-32(fp)

    if (sp->esccount >= 0)
 9087544:	e0bffc17 	ldw	r2,-16(fp)
 9087548:	10800903 	ldbu	r2,36(r2)
 908754c:	10803fcc 	andi	r2,r2,255
 9087550:	1080201c 	xori	r2,r2,128
 9087554:	10bfe004 	addi	r2,r2,-128
 9087558:	1004803a 	cmplt	r2,r2,zero
 908755c:	10003b1e 	bne	r2,zero,908764c <altera_avalon_lcd_16207_write+0x158>
    {
      unsigned int esccount = sp->esccount;
 9087560:	e0bffc17 	ldw	r2,-16(fp)
 9087564:	10800903 	ldbu	r2,36(r2)
 9087568:	10803fcc 	andi	r2,r2,255
 908756c:	1080201c 	xori	r2,r2,128
 9087570:	10bfe004 	addi	r2,r2,-128
 9087574:	e0bff715 	stw	r2,-36(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9087578:	e0bff717 	ldw	r2,-36(fp)
 908757c:	1004c03a 	cmpne	r2,r2,zero
 9087580:	1000031e 	bne	r2,zero,9087590 <altera_avalon_lcd_16207_write+0x9c>
 9087584:	e0bff807 	ldb	r2,-32(fp)
 9087588:	108016d8 	cmpnei	r2,r2,91
 908758c:	1000111e 	bne	r2,zero,90875d4 <altera_avalon_lcd_16207_write+0xe0>
 9087590:	e0bff717 	ldw	r2,-36(fp)
 9087594:	1005003a 	cmpeq	r2,r2,zero
 9087598:	10001a1e 	bne	r2,zero,9087604 <altera_avalon_lcd_16207_write+0x110>
 908759c:	e0bff807 	ldb	r2,-32(fp)
 90875a0:	1007883a 	mov	r3,r2
 90875a4:	00824274 	movhi	r2,2313
 90875a8:	10b18e04 	addi	r2,r2,-14792
 90875ac:	10800017 	ldw	r2,0(r2)
 90875b0:	1885883a 	add	r2,r3,r2
 90875b4:	10800003 	ldbu	r2,0(r2)
 90875b8:	10803fcc 	andi	r2,r2,255
 90875bc:	1080010c 	andi	r2,r2,4
 90875c0:	1004c03a 	cmpne	r2,r2,zero
 90875c4:	10000f1e 	bne	r2,zero,9087604 <altera_avalon_lcd_16207_write+0x110>
 90875c8:	e0bff807 	ldb	r2,-32(fp)
 90875cc:	10800ee0 	cmpeqi	r2,r2,59
 90875d0:	10000c1e 	bne	r2,zero,9087604 <altera_avalon_lcd_16207_write+0x110>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 90875d4:	e0fff717 	ldw	r3,-36(fp)
 90875d8:	e0bffc17 	ldw	r2,-16(fp)
 90875dc:	1885883a 	add	r2,r3,r2
 90875e0:	10800a04 	addi	r2,r2,40
 90875e4:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 90875e8:	e17ff807 	ldb	r5,-32(fp)
 90875ec:	e13ffc17 	ldw	r4,-16(fp)
 90875f0:	90872240 	call	9087224 <lcd_handle_escape>

        sp->esccount = -1;
 90875f4:	e0fffc17 	ldw	r3,-16(fp)
 90875f8:	00bfffc4 	movi	r2,-1
 90875fc:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9087600:	00006c06 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 9087604:	e0bffc17 	ldw	r2,-16(fp)
 9087608:	10800903 	ldbu	r2,36(r2)
 908760c:	10803fcc 	andi	r2,r2,255
 9087610:	108001e8 	cmpgeui	r2,r2,7
 9087614:	1000671e 	bne	r2,zero,90877b4 <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 9087618:	e0fff717 	ldw	r3,-36(fp)
 908761c:	e0bffc17 	ldw	r2,-16(fp)
 9087620:	1885883a 	add	r2,r3,r2
 9087624:	10c00a04 	addi	r3,r2,40
 9087628:	e0bff803 	ldbu	r2,-32(fp)
 908762c:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 9087630:	e0bffc17 	ldw	r2,-16(fp)
 9087634:	10800903 	ldbu	r2,36(r2)
 9087638:	10800044 	addi	r2,r2,1
 908763c:	1007883a 	mov	r3,r2
 9087640:	e0bffc17 	ldw	r2,-16(fp)
 9087644:	10c00905 	stb	r3,36(r2)
 9087648:	00005a06 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 908764c:	e0bff807 	ldb	r2,-32(fp)
 9087650:	108006d8 	cmpnei	r2,r2,27
 9087654:	1000031e 	bne	r2,zero,9087664 <altera_avalon_lcd_16207_write+0x170>
    {
      sp->esccount = 0;
 9087658:	e0bffc17 	ldw	r2,-16(fp)
 908765c:	10000905 	stb	zero,36(r2)
 9087660:	00005406 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 9087664:	e0bff807 	ldb	r2,-32(fp)
 9087668:	10800358 	cmpnei	r2,r2,13
 908766c:	1000031e 	bne	r2,zero,908767c <altera_avalon_lcd_16207_write+0x188>
    {
      sp->x = 0;
 9087670:	e0bffc17 	ldw	r2,-16(fp)
 9087674:	10000845 	stb	zero,33(r2)
 9087678:	00004e06 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 908767c:	e0bff807 	ldb	r2,-32(fp)
 9087680:	10800298 	cmpnei	r2,r2,10
 9087684:	1000101e 	bne	r2,zero,90876c8 <altera_avalon_lcd_16207_write+0x1d4>
    {
      sp->x = 0;
 9087688:	e0bffc17 	ldw	r2,-16(fp)
 908768c:	10000845 	stb	zero,33(r2)
      sp->y++;
 9087690:	e0bffc17 	ldw	r2,-16(fp)
 9087694:	10800883 	ldbu	r2,34(r2)
 9087698:	10800044 	addi	r2,r2,1
 908769c:	1007883a 	mov	r3,r2
 90876a0:	e0bffc17 	ldw	r2,-16(fp)
 90876a4:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 90876a8:	e0bffc17 	ldw	r2,-16(fp)
 90876ac:	10800883 	ldbu	r2,34(r2)
 90876b0:	10803fcc 	andi	r2,r2,255
 90876b4:	108000f0 	cmpltui	r2,r2,3
 90876b8:	10003e1e 	bne	r2,zero,90877b4 <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 90876bc:	e13ffc17 	ldw	r4,-16(fp)
 90876c0:	908715c0 	call	908715c <lcd_scroll_up>
 90876c4:	00003b06 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 90876c8:	e0bff807 	ldb	r2,-32(fp)
 90876cc:	10800218 	cmpnei	r2,r2,8
 90876d0:	10000c1e 	bne	r2,zero,9087704 <altera_avalon_lcd_16207_write+0x210>
    {
      if (sp->x > 0)
 90876d4:	e0bffc17 	ldw	r2,-16(fp)
 90876d8:	10800843 	ldbu	r2,33(r2)
 90876dc:	10803fcc 	andi	r2,r2,255
 90876e0:	1005003a 	cmpeq	r2,r2,zero
 90876e4:	1000331e 	bne	r2,zero,90877b4 <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 90876e8:	e0bffc17 	ldw	r2,-16(fp)
 90876ec:	10800843 	ldbu	r2,33(r2)
 90876f0:	10bfffc4 	addi	r2,r2,-1
 90876f4:	1007883a 	mov	r3,r2
 90876f8:	e0bffc17 	ldw	r2,-16(fp)
 90876fc:	10c00845 	stb	r3,33(r2)
 9087700:	00002c06 	br	90877b4 <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 9087704:	e0bff807 	ldb	r2,-32(fp)
 9087708:	1007883a 	mov	r3,r2
 908770c:	00824274 	movhi	r2,2313
 9087710:	10b18e04 	addi	r2,r2,-14792
 9087714:	10800017 	ldw	r2,0(r2)
 9087718:	1885883a 	add	r2,r3,r2
 908771c:	10800003 	ldbu	r2,0(r2)
 9087720:	10803fcc 	andi	r2,r2,255
 9087724:	1080201c 	xori	r2,r2,128
 9087728:	10bfe004 	addi	r2,r2,-128
 908772c:	108025cc 	andi	r2,r2,151
 9087730:	1005003a 	cmpeq	r2,r2,zero
 9087734:	10001f1e 	bne	r2,zero,90877b4 <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 9087738:	e0bffc17 	ldw	r2,-16(fp)
 908773c:	10800883 	ldbu	r2,34(r2)
 9087740:	10803fcc 	andi	r2,r2,255
 9087744:	108000b0 	cmpltui	r2,r2,2
 9087748:	1000021e 	bne	r2,zero,9087754 <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 908774c:	e13ffc17 	ldw	r4,-16(fp)
 9087750:	908715c0 	call	908715c <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9087754:	e0bffc17 	ldw	r2,-16(fp)
 9087758:	10800843 	ldbu	r2,33(r2)
 908775c:	10803fcc 	andi	r2,r2,255
 9087760:	10801428 	cmpgeui	r2,r2,80
 9087764:	10000d1e 	bne	r2,zero,908779c <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 9087768:	e0bffc17 	ldw	r2,-16(fp)
 908776c:	10800883 	ldbu	r2,34(r2)
 9087770:	11003fcc 	andi	r4,r2,255
 9087774:	e0bffc17 	ldw	r2,-16(fp)
 9087778:	10800843 	ldbu	r2,33(r2)
 908777c:	11403fcc 	andi	r5,r2,255
 9087780:	e0fffc17 	ldw	r3,-16(fp)
 9087784:	208018e4 	muli	r2,r4,99
 9087788:	10c5883a 	add	r2,r2,r3
 908778c:	1145883a 	add	r2,r2,r5
 9087790:	10c01004 	addi	r3,r2,64
 9087794:	e0bff803 	ldbu	r2,-32(fp)
 9087798:	18800005 	stb	r2,0(r3)

      sp->x++;
 908779c:	e0bffc17 	ldw	r2,-16(fp)
 90877a0:	10800843 	ldbu	r2,33(r2)
 90877a4:	10800044 	addi	r2,r2,1
 90877a8:	1007883a 	mov	r3,r2
 90877ac:	e0bffc17 	ldw	r2,-16(fp)
 90877b0:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 90877b4:	e0bffd17 	ldw	r2,-12(fp)
 90877b8:	10800044 	addi	r2,r2,1
 90877bc:	e0bffd15 	stw	r2,-12(fp)
 90877c0:	e0fffd17 	ldw	r3,-12(fp)
 90877c4:	e0bffb17 	ldw	r2,-20(fp)
 90877c8:	18bf5b36 	bltu	r3,r2,9087538 <altera_avalon_lcd_16207_write+0x44>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 90877cc:	00800404 	movi	r2,16
 90877d0:	e0bff915 	stw	r2,-28(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90877d4:	e03ffa15 	stw	zero,-24(fp)
 90877d8:	00003606 	br	90878b4 <altera_avalon_lcd_16207_write+0x3c0>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 90877dc:	00801404 	movi	r2,80
 90877e0:	e0bff615 	stw	r2,-40(fp)
 90877e4:	00001106 	br	908782c <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 90877e8:	e13ffa17 	ldw	r4,-24(fp)
 90877ec:	e0bff617 	ldw	r2,-40(fp)
 90877f0:	117fffc4 	addi	r5,r2,-1
 90877f4:	e0fffc17 	ldw	r3,-16(fp)
 90877f8:	208018e4 	muli	r2,r4,99
 90877fc:	10c5883a 	add	r2,r2,r3
 9087800:	1145883a 	add	r2,r2,r5
 9087804:	10801004 	addi	r2,r2,64
 9087808:	10800003 	ldbu	r2,0(r2)
 908780c:	10803fcc 	andi	r2,r2,255
 9087810:	1080201c 	xori	r2,r2,128
 9087814:	10bfe004 	addi	r2,r2,-128
 9087818:	10800818 	cmpnei	r2,r2,32
 908781c:	1000061e 	bne	r2,zero,9087838 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 9087820:	e0bff617 	ldw	r2,-40(fp)
 9087824:	10bfffc4 	addi	r2,r2,-1
 9087828:	e0bff615 	stw	r2,-40(fp)
 908782c:	e0bff617 	ldw	r2,-40(fp)
 9087830:	10800048 	cmpgei	r2,r2,1
 9087834:	103fec1e 	bne	r2,zero,90877e8 <altera_avalon_lcd_16207_write+0x2f4>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 9087838:	e0bff617 	ldw	r2,-40(fp)
 908783c:	10800448 	cmpgei	r2,r2,17
 9087840:	1000031e 	bne	r2,zero,9087850 <altera_avalon_lcd_16207_write+0x35c>
      width = ALT_LCD_WIDTH;
 9087844:	00800404 	movi	r2,16
 9087848:	e0bff615 	stw	r2,-40(fp)
 908784c:	00000306 	br	908785c <altera_avalon_lcd_16207_write+0x368>
    else
      width++;
 9087850:	e0bff617 	ldw	r2,-40(fp)
 9087854:	10800044 	addi	r2,r2,1
 9087858:	e0bff615 	stw	r2,-40(fp)

    sp->line[y].width = width;
 908785c:	e13ffa17 	ldw	r4,-24(fp)
 9087860:	e0bff617 	ldw	r2,-40(fp)
 9087864:	100b883a 	mov	r5,r2
 9087868:	e0fffc17 	ldw	r3,-16(fp)
 908786c:	208018e4 	muli	r2,r4,99
 9087870:	10c5883a 	add	r2,r2,r3
 9087874:	10802404 	addi	r2,r2,144
 9087878:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 908787c:	e0fff917 	ldw	r3,-28(fp)
 9087880:	e0bff617 	ldw	r2,-40(fp)
 9087884:	1880020e 	bge	r3,r2,9087890 <altera_avalon_lcd_16207_write+0x39c>
      widthmax = width;
 9087888:	e0bff617 	ldw	r2,-40(fp)
 908788c:	e0bff915 	stw	r2,-28(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 9087890:	e0bffa17 	ldw	r2,-24(fp)
 9087894:	e0fffc17 	ldw	r3,-16(fp)
 9087898:	108018e4 	muli	r2,r2,99
 908789c:	10c5883a 	add	r2,r2,r3
 90878a0:	10802404 	addi	r2,r2,144
 90878a4:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90878a8:	e0bffa17 	ldw	r2,-24(fp)
 90878ac:	10800044 	addi	r2,r2,1
 90878b0:	e0bffa15 	stw	r2,-24(fp)
 90878b4:	e0bffa17 	ldw	r2,-24(fp)
 90878b8:	10800090 	cmplti	r2,r2,2
 90878bc:	103fc71e 	bne	r2,zero,90877dc <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 90878c0:	e0bff917 	ldw	r2,-28(fp)
 90878c4:	10800448 	cmpgei	r2,r2,17
 90878c8:	1000031e 	bne	r2,zero,90878d8 <altera_avalon_lcd_16207_write+0x3e4>
    sp->scrollmax = 0;
 90878cc:	e0bffc17 	ldw	r2,-16(fp)
 90878d0:	10000985 	stb	zero,38(r2)
 90878d4:	00002d06 	br	908798c <altera_avalon_lcd_16207_write+0x498>
  else
  {
    widthmax *= 2;
 90878d8:	e0bff917 	ldw	r2,-28(fp)
 90878dc:	1085883a 	add	r2,r2,r2
 90878e0:	e0bff915 	stw	r2,-28(fp)
    sp->scrollmax = widthmax;
 90878e4:	e0bff917 	ldw	r2,-28(fp)
 90878e8:	1007883a 	mov	r3,r2
 90878ec:	e0bffc17 	ldw	r2,-16(fp)
 90878f0:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90878f4:	e03ffa15 	stw	zero,-24(fp)
 90878f8:	00002106 	br	9087980 <altera_avalon_lcd_16207_write+0x48c>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 90878fc:	e0bffa17 	ldw	r2,-24(fp)
 9087900:	e0fffc17 	ldw	r3,-16(fp)
 9087904:	108018e4 	muli	r2,r2,99
 9087908:	10c5883a 	add	r2,r2,r3
 908790c:	10802404 	addi	r2,r2,144
 9087910:	10800043 	ldbu	r2,1(r2)
 9087914:	10803fcc 	andi	r2,r2,255
 9087918:	1080201c 	xori	r2,r2,128
 908791c:	10bfe004 	addi	r2,r2,-128
 9087920:	10800450 	cmplti	r2,r2,17
 9087924:	1000131e 	bne	r2,zero,9087974 <altera_avalon_lcd_16207_write+0x480>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 9087928:	e17ffa17 	ldw	r5,-24(fp)
 908792c:	e0bffa17 	ldw	r2,-24(fp)
 9087930:	e0fffc17 	ldw	r3,-16(fp)
 9087934:	108018e4 	muli	r2,r2,99
 9087938:	10c5883a 	add	r2,r2,r3
 908793c:	10802404 	addi	r2,r2,144
 9087940:	10800043 	ldbu	r2,1(r2)
 9087944:	10803fcc 	andi	r2,r2,255
 9087948:	1080201c 	xori	r2,r2,128
 908794c:	10bfe004 	addi	r2,r2,-128
 9087950:	1006923a 	slli	r3,r2,8
 9087954:	e0bff917 	ldw	r2,-28(fp)
 9087958:	1885283a 	div	r2,r3,r2
 908795c:	1009883a 	mov	r4,r2
 9087960:	e0fffc17 	ldw	r3,-16(fp)
 9087964:	288018e4 	muli	r2,r5,99
 9087968:	10c5883a 	add	r2,r2,r3
 908796c:	10802404 	addi	r2,r2,144
 9087970:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9087974:	e0bffa17 	ldw	r2,-24(fp)
 9087978:	10800044 	addi	r2,r2,1
 908797c:	e0bffa15 	stw	r2,-24(fp)
 9087980:	e0bffa17 	ldw	r2,-24(fp)
 9087984:	10800090 	cmplti	r2,r2,2
 9087988:	103fdc1e 	bne	r2,zero,90878fc <altera_avalon_lcd_16207_write+0x408>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 908798c:	e0bffc17 	ldw	r2,-16(fp)
 9087990:	10800943 	ldbu	r2,37(r2)
 9087994:	10803fcc 	andi	r2,r2,255
 9087998:	1080201c 	xori	r2,r2,128
 908799c:	10bfe004 	addi	r2,r2,-128
 90879a0:	e0bff515 	stw	r2,-44(fp)

    lcd_repaint_screen(sp);
 90879a4:	e13ffc17 	ldw	r4,-16(fp)
 90879a8:	9086f700 	call	9086f70 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 90879ac:	e0bffc17 	ldw	r2,-16(fp)
 90879b0:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 90879b4:	e0bffc17 	ldw	r2,-16(fp)
 90879b8:	10800943 	ldbu	r2,37(r2)
 90879bc:	10c03fcc 	andi	r3,r2,255
 90879c0:	18c0201c 	xori	r3,r3,128
 90879c4:	18ffe004 	addi	r3,r3,-128
 90879c8:	e0bff517 	ldw	r2,-44(fp)
 90879cc:	18800426 	beq	r3,r2,90879e0 <altera_avalon_lcd_16207_write+0x4ec>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 90879d0:	e0fffc17 	ldw	r3,-16(fp)
 90879d4:	00800044 	movi	r2,1
 90879d8:	188009c5 	stb	r2,39(r3)
  }
 90879dc:	003feb06 	br	908798c <altera_avalon_lcd_16207_write+0x498>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
 90879e0:	e0bffe17 	ldw	r2,-8(fp)
}
 90879e4:	e037883a 	mov	sp,fp
 90879e8:	dfc00117 	ldw	ra,4(sp)
 90879ec:	df000017 	ldw	fp,0(sp)
 90879f0:	dec00204 	addi	sp,sp,8
 90879f4:	f800283a 	ret

090879f8 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 90879f8:	defffc04 	addi	sp,sp,-16
 90879fc:	dfc00315 	stw	ra,12(sp)
 9087a00:	df000215 	stw	fp,8(sp)
 9087a04:	df000204 	addi	fp,sp,8
 9087a08:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 9087a0c:	e0bfff17 	ldw	r2,-4(fp)
 9087a10:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 9087a14:	e0bffe17 	ldw	r2,-8(fp)
 9087a18:	10800943 	ldbu	r2,37(r2)
 9087a1c:	10803fcc 	andi	r2,r2,255
 9087a20:	1080201c 	xori	r2,r2,128
 9087a24:	10bfe004 	addi	r2,r2,-128
 9087a28:	10c00044 	addi	r3,r2,1
 9087a2c:	e0bffe17 	ldw	r2,-8(fp)
 9087a30:	10800983 	ldbu	r2,38(r2)
 9087a34:	10803fcc 	andi	r2,r2,255
 9087a38:	1080201c 	xori	r2,r2,128
 9087a3c:	10bfe004 	addi	r2,r2,-128
 9087a40:	18800316 	blt	r3,r2,9087a50 <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 9087a44:	e0bffe17 	ldw	r2,-8(fp)
 9087a48:	10000945 	stb	zero,37(r2)
 9087a4c:	00000606 	br	9087a68 <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 9087a50:	e0bffe17 	ldw	r2,-8(fp)
 9087a54:	10800943 	ldbu	r2,37(r2)
 9087a58:	10800044 	addi	r2,r2,1
 9087a5c:	1007883a 	mov	r3,r2
 9087a60:	e0bffe17 	ldw	r2,-8(fp)
 9087a64:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 9087a68:	e0bffe17 	ldw	r2,-8(fp)
 9087a6c:	10800983 	ldbu	r2,38(r2)
 9087a70:	10803fcc 	andi	r2,r2,255
 9087a74:	1080201c 	xori	r2,r2,128
 9087a78:	10bfe004 	addi	r2,r2,-128
 9087a7c:	10800050 	cmplti	r2,r2,1
 9087a80:	1000091e 	bne	r2,zero,9087aa8 <alt_lcd_16207_timeout+0xb0>
 9087a84:	e0bffe17 	ldw	r2,-8(fp)
 9087a88:	108009c3 	ldbu	r2,39(r2)
 9087a8c:	10803fcc 	andi	r2,r2,255
 9087a90:	1080201c 	xori	r2,r2,128
 9087a94:	10bfe004 	addi	r2,r2,-128
 9087a98:	1004c03a 	cmpne	r2,r2,zero
 9087a9c:	1000021e 	bne	r2,zero,9087aa8 <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 9087aa0:	e13ffe17 	ldw	r4,-8(fp)
 9087aa4:	9086f700 	call	9086f70 <lcd_repaint_screen>

  return sp->period;
 9087aa8:	e0bffe17 	ldw	r2,-8(fp)
 9087aac:	10800717 	ldw	r2,28(r2)
}
 9087ab0:	e037883a 	mov	sp,fp
 9087ab4:	dfc00117 	ldw	ra,4(sp)
 9087ab8:	df000017 	ldw	fp,0(sp)
 9087abc:	dec00204 	addi	sp,sp,8
 9087ac0:	f800283a 	ret

09087ac4 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 9087ac4:	defffa04 	addi	sp,sp,-24
 9087ac8:	dfc00515 	stw	ra,20(sp)
 9087acc:	df000415 	stw	fp,16(sp)
 9087ad0:	df000404 	addi	fp,sp,16
 9087ad4:	e13ffd15 	stw	r4,-12(fp)
  unsigned int base = sp->base;
 9087ad8:	e0bffd17 	ldw	r2,-12(fp)
 9087adc:	10800017 	ldw	r2,0(r2)
 9087ae0:	e0bffc15 	stw	r2,-16(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 9087ae4:	e0bffd17 	ldw	r2,-12(fp)
 9087ae8:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 9087aec:	010ea604 	movi	r4,15000
 9087af0:	90898240 	call	9089824 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9087af4:	e0bffc17 	ldw	r2,-16(fp)
 9087af8:	1007883a 	mov	r3,r2
 9087afc:	00800c04 	movi	r2,48
 9087b00:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 9087b04:	01040104 	movi	r4,4100
 9087b08:	90898240 	call	9089824 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9087b0c:	e0bffc17 	ldw	r2,-16(fp)
 9087b10:	1007883a 	mov	r3,r2
 9087b14:	00800c04 	movi	r2,48
 9087b18:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 9087b1c:	0100fa04 	movi	r4,1000
 9087b20:	90898240 	call	9089824 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9087b24:	e0bffc17 	ldw	r2,-16(fp)
 9087b28:	1007883a 	mov	r3,r2
 9087b2c:	00800c04 	movi	r2,48
 9087b30:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 9087b34:	e13ffd17 	ldw	r4,-12(fp)
 9087b38:	01400e04 	movi	r5,56
 9087b3c:	9086d200 	call	9086d20 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 9087b40:	e13ffd17 	ldw	r4,-12(fp)
 9087b44:	01400204 	movi	r5,8
 9087b48:	9086d200 	call	9086d20 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 9087b4c:	e13ffd17 	ldw	r4,-12(fp)
 9087b50:	9086eac0 	call	9086eac <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 9087b54:	e13ffd17 	ldw	r4,-12(fp)
 9087b58:	01400184 	movi	r5,6
 9087b5c:	9086d200 	call	9086d20 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 9087b60:	e13ffd17 	ldw	r4,-12(fp)
 9087b64:	01400304 	movi	r5,12
 9087b68:	9086d200 	call	9086d20 <lcd_write_command>

  sp->esccount = -1;
 9087b6c:	e0fffd17 	ldw	r3,-12(fp)
 9087b70:	00bfffc4 	movi	r2,-1
 9087b74:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 9087b78:	e0bffd17 	ldw	r2,-12(fp)
 9087b7c:	11000a04 	addi	r4,r2,40
 9087b80:	000b883a 	mov	r5,zero
 9087b84:	01800204 	movi	r6,8
 9087b88:	9081ee40 	call	9081ee4 <memset>

  sp->scrollpos = 0;
 9087b8c:	e0bffd17 	ldw	r2,-12(fp)
 9087b90:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 9087b94:	e0bffd17 	ldw	r2,-12(fp)
 9087b98:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 9087b9c:	e0bffd17 	ldw	r2,-12(fp)
 9087ba0:	100009c5 	stb	zero,39(r2)
 9087ba4:	00824274 	movhi	r2,2313
 9087ba8:	10b19704 	addi	r2,r2,-14756
 9087bac:	10800017 	ldw	r2,0(r2)
 9087bb0:	1007883a 	mov	r3,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 9087bb4:	00b33374 	movhi	r2,52429
 9087bb8:	10b33344 	addi	r2,r2,-13107
 9087bbc:	1889383a 	mul	r4,r3,r2
 9087bc0:	e13ffe15 	stw	r4,-8(fp)
 9087bc4:	1886383a 	mulxuu	r3,r3,r2
 9087bc8:	e0ffff15 	stw	r3,-4(fp)
 9087bcc:	e0ffff17 	ldw	r3,-4(fp)
 9087bd0:	1804d0fa 	srli	r2,r3,3
 9087bd4:	1007883a 	mov	r3,r2
 9087bd8:	e0bffd17 	ldw	r2,-12(fp)
 9087bdc:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 9087be0:	e0bffd17 	ldw	r2,-12(fp)
 9087be4:	11000104 	addi	r4,r2,4
 9087be8:	e0bffd17 	ldw	r2,-12(fp)
 9087bec:	10800717 	ldw	r2,28(r2)
 9087bf0:	100b883a 	mov	r5,r2
 9087bf4:	01824234 	movhi	r6,2312
 9087bf8:	319e7e04 	addi	r6,r6,31224
 9087bfc:	e1fffd17 	ldw	r7,-12(fp)
 9087c00:	9088b540 	call	9088b54 <alt_alarm_start>
}
 9087c04:	e037883a 	mov	sp,fp
 9087c08:	dfc00117 	ldw	ra,4(sp)
 9087c0c:	df000017 	ldw	fp,0(sp)
 9087c10:	dec00204 	addi	sp,sp,8
 9087c14:	f800283a 	ret

09087c18 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 9087c18:	defffa04 	addi	sp,sp,-24
 9087c1c:	dfc00515 	stw	ra,20(sp)
 9087c20:	df000415 	stw	fp,16(sp)
 9087c24:	df000404 	addi	fp,sp,16
 9087c28:	e13ffd15 	stw	r4,-12(fp)
 9087c2c:	e17ffe15 	stw	r5,-8(fp)
 9087c30:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 9087c34:	e0bffd17 	ldw	r2,-12(fp)
 9087c38:	10800017 	ldw	r2,0(r2)
 9087c3c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 9087c40:	e0bffc17 	ldw	r2,-16(fp)
 9087c44:	11000a04 	addi	r4,r2,40
 9087c48:	e0bffd17 	ldw	r2,-12(fp)
 9087c4c:	11c00217 	ldw	r7,8(r2)
 9087c50:	e17ffe17 	ldw	r5,-8(fp)
 9087c54:	e1bfff17 	ldw	r6,-4(fp)
 9087c58:	90874f40 	call	90874f4 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 9087c5c:	e037883a 	mov	sp,fp
 9087c60:	dfc00117 	ldw	ra,4(sp)
 9087c64:	df000017 	ldw	fp,0(sp)
 9087c68:	dec00204 	addi	sp,sp,8
 9087c6c:	f800283a 	ret

09087c70 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 9087c70:	defffb04 	addi	sp,sp,-20
 9087c74:	df000415 	stw	fp,16(sp)
 9087c78:	df000404 	addi	fp,sp,16
 9087c7c:	e13ffd15 	stw	r4,-12(fp)
 9087c80:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 9087c84:	e0bffd17 	ldw	r2,-12(fp)
 9087c88:	10800317 	ldw	r2,12(r2)
 9087c8c:	10800037 	ldwio	r2,0(r2)
 9087c90:	1080040c 	andi	r2,r2,16
 9087c94:	1005003a 	cmpeq	r2,r2,zero
 9087c98:	1000031e 	bne	r2,zero,9087ca8 <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 9087c9c:	00bffc04 	movi	r2,-16
 9087ca0:	e0bfff15 	stw	r2,-4(fp)
 9087ca4:	00003c06 	br	9087d98 <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9087ca8:	e0bffd17 	ldw	r2,-12(fp)
 9087cac:	10800317 	ldw	r2,12(r2)
 9087cb0:	11000404 	addi	r4,r2,16
 9087cb4:	e0bffd17 	ldw	r2,-12(fp)
 9087cb8:	10800317 	ldw	r2,12(r2)
 9087cbc:	10800404 	addi	r2,r2,16
 9087cc0:	10c00037 	ldwio	r3,0(r2)
 9087cc4:	00bff7c4 	movi	r2,-33
 9087cc8:	1886703a 	and	r3,r3,r2
 9087ccc:	2005883a 	mov	r2,r4
 9087cd0:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9087cd4:	e0bffd17 	ldw	r2,-12(fp)
 9087cd8:	10800317 	ldw	r2,12(r2)
 9087cdc:	1007883a 	mov	r3,r2
 9087ce0:	00803fc4 	movi	r2,255
 9087ce4:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 9087ce8:	e0bffd17 	ldw	r2,-12(fp)
 9087cec:	10800317 	ldw	r2,12(r2)
 9087cf0:	10800804 	addi	r2,r2,32
 9087cf4:	e0fffe17 	ldw	r3,-8(fp)
 9087cf8:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 9087cfc:	e0bffd17 	ldw	r2,-12(fp)
 9087d00:	10800917 	ldw	r2,36(r2)
 9087d04:	1005003a 	cmpeq	r2,r2,zero
 9087d08:	1000111e 	bne	r2,zero,9087d50 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9087d0c:	e0bffd17 	ldw	r2,-12(fp)
 9087d10:	10800317 	ldw	r2,12(r2)
 9087d14:	10800404 	addi	r2,r2,16
 9087d18:	10800037 	ldwio	r2,0(r2)
 9087d1c:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
 9087d20:	e0bffd17 	ldw	r2,-12(fp)
 9087d24:	10c00b17 	ldw	r3,44(r2)
 9087d28:	e0bffc17 	ldw	r2,-16(fp)
 9087d2c:	1884b03a 	or	r2,r3,r2
 9087d30:	10801814 	ori	r2,r2,96
 9087d34:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9087d38:	e0bffd17 	ldw	r2,-12(fp)
 9087d3c:	10800317 	ldw	r2,12(r2)
 9087d40:	10800404 	addi	r2,r2,16
 9087d44:	e0fffc17 	ldw	r3,-16(fp)
 9087d48:	10c00035 	stwio	r3,0(r2)
 9087d4c:	00001106 	br	9087d94 <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9087d50:	e0bffd17 	ldw	r2,-12(fp)
 9087d54:	10800317 	ldw	r2,12(r2)
 9087d58:	10800404 	addi	r2,r2,16
 9087d5c:	10800037 	ldwio	r2,0(r2)
 9087d60:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 9087d64:	e0bffc17 	ldw	r2,-16(fp)
 9087d68:	10801814 	ori	r2,r2,96
 9087d6c:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 9087d70:	e0fffc17 	ldw	r3,-16(fp)
 9087d74:	00bffbc4 	movi	r2,-17
 9087d78:	1884703a 	and	r2,r3,r2
 9087d7c:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9087d80:	e0bffd17 	ldw	r2,-12(fp)
 9087d84:	10800317 	ldw	r2,12(r2)
 9087d88:	10800404 	addi	r2,r2,16
 9087d8c:	e0fffc17 	ldw	r3,-16(fp)
 9087d90:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 9087d94:	e03fff15 	stw	zero,-4(fp)
 9087d98:	e0bfff17 	ldw	r2,-4(fp)
}
 9087d9c:	e037883a 	mov	sp,fp
 9087da0:	df000017 	ldw	fp,0(sp)
 9087da4:	dec00104 	addi	sp,sp,4
 9087da8:	f800283a 	ret

09087dac <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 9087dac:	defffc04 	addi	sp,sp,-16
 9087db0:	df000315 	stw	fp,12(sp)
 9087db4:	df000304 	addi	fp,sp,12
 9087db8:	e13ffe15 	stw	r4,-8(fp)
 9087dbc:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 9087dc0:	e0bffe17 	ldw	r2,-8(fp)
 9087dc4:	10800317 	ldw	r2,12(r2)
 9087dc8:	10800037 	ldwio	r2,0(r2)
 9087dcc:	1080040c 	andi	r2,r2,16
 9087dd0:	1004c03a 	cmpne	r2,r2,zero
 9087dd4:	103ffa1e 	bne	r2,zero,9087dc0 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9087dd8:	e0bffe17 	ldw	r2,-8(fp)
 9087ddc:	10800317 	ldw	r2,12(r2)
 9087de0:	11000404 	addi	r4,r2,16
 9087de4:	e0bffe17 	ldw	r2,-8(fp)
 9087de8:	10800317 	ldw	r2,12(r2)
 9087dec:	10800404 	addi	r2,r2,16
 9087df0:	10c00037 	ldwio	r3,0(r2)
 9087df4:	00bff7c4 	movi	r2,-33
 9087df8:	1886703a 	and	r3,r3,r2
 9087dfc:	2005883a 	mov	r2,r4
 9087e00:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9087e04:	e0bffe17 	ldw	r2,-8(fp)
 9087e08:	10800317 	ldw	r2,12(r2)
 9087e0c:	1007883a 	mov	r3,r2
 9087e10:	00803fc4 	movi	r2,255
 9087e14:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 9087e18:	e0bffe17 	ldw	r2,-8(fp)
 9087e1c:	10800317 	ldw	r2,12(r2)
 9087e20:	10800804 	addi	r2,r2,32
 9087e24:	e0ffff17 	ldw	r3,-4(fp)
 9087e28:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9087e2c:	e0bffe17 	ldw	r2,-8(fp)
 9087e30:	10800317 	ldw	r2,12(r2)
 9087e34:	11000404 	addi	r4,r2,16
 9087e38:	e0bffe17 	ldw	r2,-8(fp)
 9087e3c:	10800317 	ldw	r2,12(r2)
 9087e40:	10800404 	addi	r2,r2,16
 9087e44:	10800037 	ldwio	r2,0(r2)
 9087e48:	10c01814 	ori	r3,r2,96
 9087e4c:	2005883a 	mov	r2,r4
 9087e50:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 9087e54:	e0bffe17 	ldw	r2,-8(fp)
 9087e58:	10800317 	ldw	r2,12(r2)
 9087e5c:	10800037 	ldwio	r2,0(r2)
 9087e60:	1080040c 	andi	r2,r2,16
 9087e64:	1004c03a 	cmpne	r2,r2,zero
 9087e68:	103ffa1e 	bne	r2,zero,9087e54 <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 9087e6c:	e0bffe17 	ldw	r2,-8(fp)
 9087e70:	10800317 	ldw	r2,12(r2)
 9087e74:	11000404 	addi	r4,r2,16
 9087e78:	e0bffe17 	ldw	r2,-8(fp)
 9087e7c:	10800317 	ldw	r2,12(r2)
 9087e80:	10800404 	addi	r2,r2,16
 9087e84:	10c00037 	ldwio	r3,0(r2)
 9087e88:	00bff7c4 	movi	r2,-33
 9087e8c:	1886703a 	and	r3,r3,r2
 9087e90:	2005883a 	mov	r2,r4
 9087e94:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 9087e98:	e0bffe17 	ldw	r2,-8(fp)
 9087e9c:	10800317 	ldw	r2,12(r2)
 9087ea0:	10800037 	ldwio	r2,0(r2)
 9087ea4:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9087ea8:	e0bffe17 	ldw	r2,-8(fp)
 9087eac:	10800317 	ldw	r2,12(r2)
 9087eb0:	1007883a 	mov	r3,r2
 9087eb4:	00803fc4 	movi	r2,255
 9087eb8:	18800035 	stwio	r2,0(r3)

  return status;
 9087ebc:	e0bffd03 	ldbu	r2,-12(fp)
}
 9087ec0:	e037883a 	mov	sp,fp
 9087ec4:	df000017 	ldw	fp,0(sp)
 9087ec8:	dec00104 	addi	sp,sp,4
 9087ecc:	f800283a 	ret

09087ed0 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 9087ed0:	defff404 	addi	sp,sp,-48
 9087ed4:	dfc00b15 	stw	ra,44(sp)
 9087ed8:	df000a15 	stw	fp,40(sp)
 9087edc:	df000a04 	addi	fp,sp,40
 9087ee0:	e13ffb15 	stw	r4,-20(fp)
 9087ee4:	e17ffc15 	stw	r5,-16(fp)
 9087ee8:	e1bffd15 	stw	r6,-12(fp)
 9087eec:	e1fffe15 	stw	r7,-8(fp)
 9087ef0:	e0800217 	ldw	r2,8(fp)
 9087ef4:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 9087ef8:	e0bfff0b 	ldhu	r2,-4(fp)
 9087efc:	d8800015 	stw	r2,0(sp)
 9087f00:	e0800317 	ldw	r2,12(fp)
 9087f04:	d8800115 	stw	r2,4(sp)
 9087f08:	e0800417 	ldw	r2,16(fp)
 9087f0c:	d8800215 	stw	r2,8(sp)
 9087f10:	d8000315 	stw	zero,12(sp)
 9087f14:	d8000415 	stw	zero,16(sp)
 9087f18:	e13ffb17 	ldw	r4,-20(fp)
 9087f1c:	e17ffc17 	ldw	r5,-16(fp)
 9087f20:	e1bffd17 	ldw	r6,-12(fp)
 9087f24:	e1fffe17 	ldw	r7,-8(fp)
 9087f28:	9087f400 	call	9087f40 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 9087f2c:	e037883a 	mov	sp,fp
 9087f30:	dfc00117 	ldw	ra,4(sp)
 9087f34:	df000017 	ldw	fp,0(sp)
 9087f38:	dec00204 	addi	sp,sp,8
 9087f3c:	f800283a 	ret

09087f40 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 9087f40:	defff204 	addi	sp,sp,-56
 9087f44:	dfc00d15 	stw	ra,52(sp)
 9087f48:	df000c15 	stw	fp,48(sp)
 9087f4c:	df000c04 	addi	fp,sp,48
 9087f50:	e13ffb15 	stw	r4,-20(fp)
 9087f54:	e17ffc15 	stw	r5,-16(fp)
 9087f58:	e1bffd15 	stw	r6,-12(fp)
 9087f5c:	e1fffe15 	stw	r7,-8(fp)
 9087f60:	e0800217 	ldw	r2,8(fp)
 9087f64:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 9087f68:	e0bfff0b 	ldhu	r2,-4(fp)
 9087f6c:	d8800015 	stw	r2,0(sp)
 9087f70:	d8000115 	stw	zero,4(sp)
 9087f74:	e0800317 	ldw	r2,12(fp)
 9087f78:	d8800215 	stw	r2,8(sp)
 9087f7c:	e0800417 	ldw	r2,16(fp)
 9087f80:	d8800315 	stw	r2,12(sp)
 9087f84:	e0800517 	ldw	r2,20(fp)
 9087f88:	d8800415 	stw	r2,16(sp)
 9087f8c:	e0800617 	ldw	r2,24(fp)
 9087f90:	d8800515 	stw	r2,20(sp)
 9087f94:	d8000615 	stw	zero,24(sp)
 9087f98:	e13ffb17 	ldw	r4,-20(fp)
 9087f9c:	e17ffc17 	ldw	r5,-16(fp)
 9087fa0:	e1bffd17 	ldw	r6,-12(fp)
 9087fa4:	e1fffe17 	ldw	r7,-8(fp)
 9087fa8:	90885000 	call	9088500 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 9087fac:	e037883a 	mov	sp,fp
 9087fb0:	dfc00117 	ldw	ra,4(sp)
 9087fb4:	df000017 	ldw	fp,0(sp)
 9087fb8:	dec00204 	addi	sp,sp,8
 9087fbc:	f800283a 	ret

09087fc0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 9087fc0:	defff804 	addi	sp,sp,-32
 9087fc4:	dfc00715 	stw	ra,28(sp)
 9087fc8:	df000615 	stw	fp,24(sp)
 9087fcc:	df000604 	addi	fp,sp,24
 9087fd0:	e13ffc15 	stw	r4,-16(fp)
 9087fd4:	e17ffd15 	stw	r5,-12(fp)
 9087fd8:	e1bffe15 	stw	r6,-8(fp)
 9087fdc:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 9087fe0:	e1ffff0b 	ldhu	r7,-4(fp)
 9087fe4:	e0800217 	ldw	r2,8(fp)
 9087fe8:	d8800015 	stw	r2,0(sp)
 9087fec:	d8000115 	stw	zero,4(sp)
 9087ff0:	e13ffc17 	ldw	r4,-16(fp)
 9087ff4:	e17ffd17 	ldw	r5,-12(fp)
 9087ff8:	e1bffe17 	ldw	r6,-8(fp)
 9087ffc:	90880140 	call	9088014 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 9088000:	e037883a 	mov	sp,fp
 9088004:	dfc00117 	ldw	ra,4(sp)
 9088008:	df000017 	ldw	fp,0(sp)
 908800c:	dec00204 	addi	sp,sp,8
 9088010:	f800283a 	ret

09088014 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 9088014:	defff304 	addi	sp,sp,-52
 9088018:	dfc00c15 	stw	ra,48(sp)
 908801c:	df000b15 	stw	fp,44(sp)
 9088020:	df000b04 	addi	fp,sp,44
 9088024:	e13ffc15 	stw	r4,-16(fp)
 9088028:	e17ffd15 	stw	r5,-12(fp)
 908802c:	e1bffe15 	stw	r6,-8(fp)
 9088030:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 9088034:	e0bfff0b 	ldhu	r2,-4(fp)
 9088038:	d8800015 	stw	r2,0(sp)
 908803c:	d8000115 	stw	zero,4(sp)
 9088040:	d8000215 	stw	zero,8(sp)
 9088044:	e0800217 	ldw	r2,8(fp)
 9088048:	d8800315 	stw	r2,12(sp)
 908804c:	d8000415 	stw	zero,16(sp)
 9088050:	e0800317 	ldw	r2,12(fp)
 9088054:	d8800515 	stw	r2,20(sp)
 9088058:	d8000615 	stw	zero,24(sp)
 908805c:	e13ffc17 	ldw	r4,-16(fp)
 9088060:	e17ffd17 	ldw	r5,-12(fp)
 9088064:	000d883a 	mov	r6,zero
 9088068:	e1fffe17 	ldw	r7,-8(fp)
 908806c:	90885000 	call	9088500 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 9088070:	e037883a 	mov	sp,fp
 9088074:	dfc00117 	ldw	ra,4(sp)
 9088078:	df000017 	ldw	fp,0(sp)
 908807c:	dec00204 	addi	sp,sp,8
 9088080:	f800283a 	ret

09088084 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 9088084:	defff404 	addi	sp,sp,-48
 9088088:	dfc00b15 	stw	ra,44(sp)
 908808c:	df000a15 	stw	fp,40(sp)
 9088090:	df000a04 	addi	fp,sp,40
 9088094:	e13ffb15 	stw	r4,-20(fp)
 9088098:	e17ffc15 	stw	r5,-16(fp)
 908809c:	e1bffd15 	stw	r6,-12(fp)
 90880a0:	e0800517 	ldw	r2,20(fp)
 90880a4:	e1fffe0d 	sth	r7,-8(fp)
 90880a8:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 90880ac:	e1fffe0b 	ldhu	r7,-8(fp)
 90880b0:	e0ffff03 	ldbu	r3,-4(fp)
 90880b4:	e0800217 	ldw	r2,8(fp)
 90880b8:	d8800015 	stw	r2,0(sp)
 90880bc:	e0800317 	ldw	r2,12(fp)
 90880c0:	d8800115 	stw	r2,4(sp)
 90880c4:	e0800417 	ldw	r2,16(fp)
 90880c8:	d8800215 	stw	r2,8(sp)
 90880cc:	d8000315 	stw	zero,12(sp)
 90880d0:	d8c00415 	stw	r3,16(sp)
 90880d4:	e13ffb17 	ldw	r4,-20(fp)
 90880d8:	e17ffc17 	ldw	r5,-16(fp)
 90880dc:	e1bffd17 	ldw	r6,-12(fp)
 90880e0:	90880f80 	call	90880f8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 90880e4:	e037883a 	mov	sp,fp
 90880e8:	dfc00117 	ldw	ra,4(sp)
 90880ec:	df000017 	ldw	fp,0(sp)
 90880f0:	dec00204 	addi	sp,sp,8
 90880f4:	f800283a 	ret

090880f8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 90880f8:	defff204 	addi	sp,sp,-56
 90880fc:	dfc00d15 	stw	ra,52(sp)
 9088100:	df000c15 	stw	fp,48(sp)
 9088104:	df000c04 	addi	fp,sp,48
 9088108:	e13ffb15 	stw	r4,-20(fp)
 908810c:	e17ffc15 	stw	r5,-16(fp)
 9088110:	e1bffd15 	stw	r6,-12(fp)
 9088114:	e0800617 	ldw	r2,24(fp)
 9088118:	e1fffe0d 	sth	r7,-8(fp)
 908811c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 9088120:	e0bffe0b 	ldhu	r2,-8(fp)
 9088124:	e0ffff03 	ldbu	r3,-4(fp)
 9088128:	d8800015 	stw	r2,0(sp)
 908812c:	e0800417 	ldw	r2,16(fp)
 9088130:	d8800115 	stw	r2,4(sp)
 9088134:	e0800217 	ldw	r2,8(fp)
 9088138:	d8800215 	stw	r2,8(sp)
 908813c:	e0800317 	ldw	r2,12(fp)
 9088140:	d8800315 	stw	r2,12(sp)
 9088144:	e0800517 	ldw	r2,20(fp)
 9088148:	d8800415 	stw	r2,16(sp)
 908814c:	d8000515 	stw	zero,20(sp)
 9088150:	d8c00615 	stw	r3,24(sp)
 9088154:	e13ffb17 	ldw	r4,-20(fp)
 9088158:	e17ffc17 	ldw	r5,-16(fp)
 908815c:	e1bffd17 	ldw	r6,-12(fp)
 9088160:	000f883a 	mov	r7,zero
 9088164:	90885000 	call	9088500 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 9088168:	e037883a 	mov	sp,fp
 908816c:	dfc00117 	ldw	ra,4(sp)
 9088170:	df000017 	ldw	fp,0(sp)
 9088174:	dec00204 	addi	sp,sp,8
 9088178:	f800283a 	ret

0908817c <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 908817c:	defffb04 	addi	sp,sp,-20
 9088180:	df000415 	stw	fp,16(sp)
 9088184:	df000404 	addi	fp,sp,16
 9088188:	e13ffc15 	stw	r4,-16(fp)
 908818c:	e17ffd15 	stw	r5,-12(fp)
 9088190:	e1bffe15 	stw	r6,-8(fp)
 9088194:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 9088198:	e0fffc17 	ldw	r3,-16(fp)
 908819c:	e0bffd17 	ldw	r2,-12(fp)
 90881a0:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
 90881a4:	e0fffc17 	ldw	r3,-16(fp)
 90881a8:	e0bfff17 	ldw	r2,-4(fp)
 90881ac:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
 90881b0:	e0fffc17 	ldw	r3,-16(fp)
 90881b4:	e0bffe17 	ldw	r2,-8(fp)
 90881b8:	18800b15 	stw	r2,44(r3)
}
 90881bc:	e037883a 	mov	sp,fp
 90881c0:	df000017 	ldw	fp,0(sp)
 90881c4:	dec00104 	addi	sp,sp,4
 90881c8:	f800283a 	ret

090881cc <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 90881cc:	defffd04 	addi	sp,sp,-12
 90881d0:	df000215 	stw	fp,8(sp)
 90881d4:	df000204 	addi	fp,sp,8
 90881d8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 90881dc:	e0bfff17 	ldw	r2,-4(fp)
 90881e0:	10800317 	ldw	r2,12(r2)
 90881e4:	10800404 	addi	r2,r2,16
 90881e8:	10800037 	ldwio	r2,0(r2)
 90881ec:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 90881f0:	e0bffe17 	ldw	r2,-8(fp)
 90881f4:	10800814 	ori	r2,r2,32
 90881f8:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 90881fc:	e0bfff17 	ldw	r2,-4(fp)
 9088200:	10800317 	ldw	r2,12(r2)
 9088204:	10800404 	addi	r2,r2,16
 9088208:	e0fffe17 	ldw	r3,-8(fp)
 908820c:	10c00035 	stwio	r3,0(r2)
}
 9088210:	e037883a 	mov	sp,fp
 9088214:	df000017 	ldw	fp,0(sp)
 9088218:	dec00104 	addi	sp,sp,4
 908821c:	f800283a 	ret

09088220 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 9088220:	defffd04 	addi	sp,sp,-12
 9088224:	df000215 	stw	fp,8(sp)
 9088228:	df000204 	addi	fp,sp,8
 908822c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9088230:	e0bfff17 	ldw	r2,-4(fp)
 9088234:	10800317 	ldw	r2,12(r2)
 9088238:	10800404 	addi	r2,r2,16
 908823c:	10800037 	ldwio	r2,0(r2)
 9088240:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 9088244:	e0fffe17 	ldw	r3,-8(fp)
 9088248:	00bff7c4 	movi	r2,-33
 908824c:	1884703a 	and	r2,r3,r2
 9088250:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9088254:	e0bfff17 	ldw	r2,-4(fp)
 9088258:	10800317 	ldw	r2,12(r2)
 908825c:	10800404 	addi	r2,r2,16
 9088260:	e0fffe17 	ldw	r3,-8(fp)
 9088264:	10c00035 	stwio	r3,0(r2)
}
 9088268:	e037883a 	mov	sp,fp
 908826c:	df000017 	ldw	fp,0(sp)
 9088270:	dec00104 	addi	sp,sp,4
 9088274:	f800283a 	ret

09088278 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 9088278:	defffd04 	addi	sp,sp,-12
 908827c:	df000215 	stw	fp,8(sp)
 9088280:	df000204 	addi	fp,sp,8
 9088284:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 9088288:	e0bffe17 	ldw	r2,-8(fp)
 908828c:	10800784 	addi	r2,r2,30
 9088290:	10800023 	ldbuio	r2,0(r2)
 9088294:	10801fcc 	andi	r2,r2,127
 9088298:	1005003a 	cmpeq	r2,r2,zero
 908829c:	1000031e 	bne	r2,zero,90882ac <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 90882a0:	00bffec4 	movi	r2,-5
 90882a4:	e0bfff15 	stw	r2,-4(fp)
 90882a8:	00000a06 	br	90882d4 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 90882ac:	e0bffe17 	ldw	r2,-8(fp)
 90882b0:	108007c4 	addi	r2,r2,31
 90882b4:	10800023 	ldbuio	r2,0(r2)
 90882b8:	1080200c 	andi	r2,r2,128
 90882bc:	1005003a 	cmpeq	r2,r2,zero
 90882c0:	1000031e 	bne	r2,zero,90882d0 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 90882c4:	00bfe244 	movi	r2,-119
 90882c8:	e0bfff15 	stw	r2,-4(fp)
 90882cc:	00000106 	br	90882d4 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
 90882d0:	e03fff15 	stw	zero,-4(fp)
 90882d4:	e0bfff17 	ldw	r2,-4(fp)
}
 90882d8:	e037883a 	mov	sp,fp
 90882dc:	df000017 	ldw	fp,0(sp)
 90882e0:	dec00104 	addi	sp,sp,4
 90882e4:	f800283a 	ret

090882e8 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 90882e8:	defffc04 	addi	sp,sp,-16
 90882ec:	dfc00315 	stw	ra,12(sp)
 90882f0:	df000215 	stw	fp,8(sp)
 90882f4:	df000204 	addi	fp,sp,8
 90882f8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 90882fc:	e13fff17 	ldw	r4,-4(fp)
 9088300:	d1600c04 	addi	r5,gp,-32720
 9088304:	9088efc0 	call	9088efc <alt_find_dev>
 9088308:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 908830c:	e0bffe17 	ldw	r2,-8(fp)
 9088310:	1004c03a 	cmpne	r2,r2,zero
 9088314:	1000041e 	bne	r2,zero,9088328 <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
 9088318:	90883400 	call	9088340 <alt_get_errno>
 908831c:	1007883a 	mov	r3,r2
 9088320:	008004c4 	movi	r2,19
 9088324:	18800015 	stw	r2,0(r3)
  }

  return dev;
 9088328:	e0bffe17 	ldw	r2,-8(fp)
}
 908832c:	e037883a 	mov	sp,fp
 9088330:	dfc00117 	ldw	ra,4(sp)
 9088334:	df000017 	ldw	fp,0(sp)
 9088338:	dec00204 	addi	sp,sp,8
 908833c:	f800283a 	ret

09088340 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9088340:	defffd04 	addi	sp,sp,-12
 9088344:	dfc00215 	stw	ra,8(sp)
 9088348:	df000115 	stw	fp,4(sp)
 908834c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9088350:	00824274 	movhi	r2,2313
 9088354:	10b18404 	addi	r2,r2,-14832
 9088358:	10800017 	ldw	r2,0(r2)
 908835c:	1005003a 	cmpeq	r2,r2,zero
 9088360:	1000061e 	bne	r2,zero,908837c <alt_get_errno+0x3c>
 9088364:	00824274 	movhi	r2,2313
 9088368:	10b18404 	addi	r2,r2,-14832
 908836c:	10800017 	ldw	r2,0(r2)
 9088370:	103ee83a 	callr	r2
 9088374:	e0bfff15 	stw	r2,-4(fp)
 9088378:	00000306 	br	9088388 <alt_get_errno+0x48>
 908837c:	00824274 	movhi	r2,2313
 9088380:	10b18f04 	addi	r2,r2,-14788
 9088384:	e0bfff15 	stw	r2,-4(fp)
 9088388:	e0bfff17 	ldw	r2,-4(fp)
}
 908838c:	e037883a 	mov	sp,fp
 9088390:	dfc00117 	ldw	ra,4(sp)
 9088394:	df000017 	ldw	fp,0(sp)
 9088398:	dec00204 	addi	sp,sp,8
 908839c:	f800283a 	ret

090883a0 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 90883a0:	defff104 	addi	sp,sp,-60
 90883a4:	dfc00e15 	stw	ra,56(sp)
 90883a8:	df000d15 	stw	fp,52(sp)
 90883ac:	df000d04 	addi	fp,sp,52
 90883b0:	e13ffa15 	stw	r4,-24(fp)
 90883b4:	e17ffb15 	stw	r5,-20(fp)
 90883b8:	e1bffc15 	stw	r6,-16(fp)
 90883bc:	e1fffd15 	stw	r7,-12(fp)
 90883c0:	e0800217 	ldw	r2,8(fp)
 90883c4:	e0c00617 	ldw	r3,24(fp)
 90883c8:	e0bffe0d 	sth	r2,-8(fp)
 90883cc:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 90883d0:	e0bffe0b 	ldhu	r2,-8(fp)
 90883d4:	e0ffff03 	ldbu	r3,-4(fp)
 90883d8:	d8800015 	stw	r2,0(sp)
 90883dc:	e0800317 	ldw	r2,12(fp)
 90883e0:	d8800115 	stw	r2,4(sp)
 90883e4:	e0800417 	ldw	r2,16(fp)
 90883e8:	d8800215 	stw	r2,8(sp)
 90883ec:	e0800517 	ldw	r2,20(fp)
 90883f0:	d8800315 	stw	r2,12(sp)
 90883f4:	d8000415 	stw	zero,16(sp)
 90883f8:	d8000515 	stw	zero,20(sp)
 90883fc:	d8c00615 	stw	r3,24(sp)
 9088400:	e13ffa17 	ldw	r4,-24(fp)
 9088404:	e17ffb17 	ldw	r5,-20(fp)
 9088408:	e1bffc17 	ldw	r6,-16(fp)
 908840c:	e1fffd17 	ldw	r7,-12(fp)
 9088410:	90885000 	call	9088500 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 9088414:	e037883a 	mov	sp,fp
 9088418:	dfc00117 	ldw	ra,4(sp)
 908841c:	df000017 	ldw	fp,0(sp)
 9088420:	dec00204 	addi	sp,sp,8
 9088424:	f800283a 	ret

09088428 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 9088428:	defffc04 	addi	sp,sp,-16
 908842c:	df000315 	stw	fp,12(sp)
 9088430:	df000304 	addi	fp,sp,12
 9088434:	e13ffe15 	stw	r4,-8(fp)
 9088438:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 908843c:	e0bffe17 	ldw	r2,-8(fp)
 9088440:	10800317 	ldw	r2,12(r2)
 9088444:	10800404 	addi	r2,r2,16
 9088448:	10800037 	ldwio	r2,0(r2)
 908844c:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 9088450:	e0fffd17 	ldw	r3,-12(fp)
 9088454:	00a00434 	movhi	r2,32784
 9088458:	10bfffc4 	addi	r2,r2,-1
 908845c:	1884703a 	and	r2,r3,r2
 9088460:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 9088464:	e0bfff17 	ldw	r2,-4(fp)
 9088468:	1004953a 	slli	r2,r2,20
 908846c:	10dffc2c 	andhi	r3,r2,32752
 9088470:	e0bffd17 	ldw	r2,-12(fp)
 9088474:	1884b03a 	or	r2,r3,r2
 9088478:	10800134 	orhi	r2,r2,4
 908847c:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9088480:	e0bffe17 	ldw	r2,-8(fp)
 9088484:	10800317 	ldw	r2,12(r2)
 9088488:	10800404 	addi	r2,r2,16
 908848c:	e0fffd17 	ldw	r3,-12(fp)
 9088490:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 9088494:	e037883a 	mov	sp,fp
 9088498:	df000017 	ldw	fp,0(sp)
 908849c:	dec00104 	addi	sp,sp,4
 90884a0:	f800283a 	ret

090884a4 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 90884a4:	defffd04 	addi	sp,sp,-12
 90884a8:	df000215 	stw	fp,8(sp)
 90884ac:	df000204 	addi	fp,sp,8
 90884b0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 90884b4:	e0bfff17 	ldw	r2,-4(fp)
 90884b8:	10800317 	ldw	r2,12(r2)
 90884bc:	10800404 	addi	r2,r2,16
 90884c0:	10800037 	ldwio	r2,0(r2)
 90884c4:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 90884c8:	e0fffe17 	ldw	r3,-8(fp)
 90884cc:	00bfff34 	movhi	r2,65532
 90884d0:	10bfffc4 	addi	r2,r2,-1
 90884d4:	1884703a 	and	r2,r3,r2
 90884d8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 90884dc:	e0bfff17 	ldw	r2,-4(fp)
 90884e0:	10800317 	ldw	r2,12(r2)
 90884e4:	10800404 	addi	r2,r2,16
 90884e8:	e0fffe17 	ldw	r3,-8(fp)
 90884ec:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 90884f0:	e037883a 	mov	sp,fp
 90884f4:	df000017 	ldw	fp,0(sp)
 90884f8:	dec00104 	addi	sp,sp,4
 90884fc:	f800283a 	ret

09088500 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 9088500:	defff204 	addi	sp,sp,-56
 9088504:	dfc00d15 	stw	ra,52(sp)
 9088508:	df000c15 	stw	fp,48(sp)
 908850c:	df000c04 	addi	fp,sp,48
 9088510:	e13ff415 	stw	r4,-48(fp)
 9088514:	e17ff515 	stw	r5,-44(fp)
 9088518:	e1bff615 	stw	r6,-40(fp)
 908851c:	e1fff715 	stw	r7,-36(fp)
 9088520:	e0800217 	ldw	r2,8(fp)
 9088524:	e0c00817 	ldw	r3,32(fp)
 9088528:	e0bff80d 	sth	r2,-32(fp)
 908852c:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 9088530:	e0bff517 	ldw	r2,-44(fp)
 9088534:	110007c4 	addi	r4,r2,31
 9088538:	e0bff517 	ldw	r2,-44(fp)
 908853c:	108007c3 	ldbu	r2,31(r2)
 9088540:	10c03fcc 	andi	r3,r2,255
 9088544:	00bfdfc4 	movi	r2,-129
 9088548:	1886703a 	and	r3,r3,r2
 908854c:	2005883a 	mov	r2,r4
 9088550:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 9088554:	e13ff417 	ldw	r4,-48(fp)
 9088558:	e0bff617 	ldw	r2,-40(fp)
 908855c:	11403fcc 	andi	r5,r2,255
 9088560:	20800003 	ldbu	r2,0(r4)
 9088564:	1004703a 	and	r2,r2,zero
 9088568:	1007883a 	mov	r3,r2
 908856c:	2805883a 	mov	r2,r5
 9088570:	1884b03a 	or	r2,r3,r2
 9088574:	20800005 	stb	r2,0(r4)
 9088578:	e0bff617 	ldw	r2,-40(fp)
 908857c:	1004d23a 	srli	r2,r2,8
 9088580:	11403fcc 	andi	r5,r2,255
 9088584:	20800043 	ldbu	r2,1(r4)
 9088588:	1004703a 	and	r2,r2,zero
 908858c:	1007883a 	mov	r3,r2
 9088590:	2805883a 	mov	r2,r5
 9088594:	1884b03a 	or	r2,r3,r2
 9088598:	20800045 	stb	r2,1(r4)
 908859c:	e0bff617 	ldw	r2,-40(fp)
 90885a0:	1004d43a 	srli	r2,r2,16
 90885a4:	11403fcc 	andi	r5,r2,255
 90885a8:	20800083 	ldbu	r2,2(r4)
 90885ac:	1004703a 	and	r2,r2,zero
 90885b0:	1007883a 	mov	r3,r2
 90885b4:	2805883a 	mov	r2,r5
 90885b8:	1884b03a 	or	r2,r3,r2
 90885bc:	20800085 	stb	r2,2(r4)
 90885c0:	e0bff617 	ldw	r2,-40(fp)
 90885c4:	100ad63a 	srli	r5,r2,24
 90885c8:	208000c3 	ldbu	r2,3(r4)
 90885cc:	1004703a 	and	r2,r2,zero
 90885d0:	1007883a 	mov	r3,r2
 90885d4:	2805883a 	mov	r2,r5
 90885d8:	1884b03a 	or	r2,r3,r2
 90885dc:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
 90885e0:	e13ff417 	ldw	r4,-48(fp)
 90885e4:	e0bff717 	ldw	r2,-36(fp)
 90885e8:	11403fcc 	andi	r5,r2,255
 90885ec:	20800203 	ldbu	r2,8(r4)
 90885f0:	1004703a 	and	r2,r2,zero
 90885f4:	1007883a 	mov	r3,r2
 90885f8:	2805883a 	mov	r2,r5
 90885fc:	1884b03a 	or	r2,r3,r2
 9088600:	20800205 	stb	r2,8(r4)
 9088604:	e0bff717 	ldw	r2,-36(fp)
 9088608:	1004d23a 	srli	r2,r2,8
 908860c:	11403fcc 	andi	r5,r2,255
 9088610:	20800243 	ldbu	r2,9(r4)
 9088614:	1004703a 	and	r2,r2,zero
 9088618:	1007883a 	mov	r3,r2
 908861c:	2805883a 	mov	r2,r5
 9088620:	1884b03a 	or	r2,r3,r2
 9088624:	20800245 	stb	r2,9(r4)
 9088628:	e0bff717 	ldw	r2,-36(fp)
 908862c:	1004d43a 	srli	r2,r2,16
 9088630:	11403fcc 	andi	r5,r2,255
 9088634:	20800283 	ldbu	r2,10(r4)
 9088638:	1004703a 	and	r2,r2,zero
 908863c:	1007883a 	mov	r3,r2
 9088640:	2805883a 	mov	r2,r5
 9088644:	1884b03a 	or	r2,r3,r2
 9088648:	20800285 	stb	r2,10(r4)
 908864c:	e0bff717 	ldw	r2,-36(fp)
 9088650:	100ad63a 	srli	r5,r2,24
 9088654:	208002c3 	ldbu	r2,11(r4)
 9088658:	1004703a 	and	r2,r2,zero
 908865c:	1007883a 	mov	r3,r2
 9088660:	2805883a 	mov	r2,r5
 9088664:	1884b03a 	or	r2,r3,r2
 9088668:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
 908866c:	e1bff517 	ldw	r6,-44(fp)
 9088670:	e13ff417 	ldw	r4,-48(fp)
 9088674:	31403fcc 	andi	r5,r6,255
 9088678:	20800403 	ldbu	r2,16(r4)
 908867c:	1004703a 	and	r2,r2,zero
 9088680:	1007883a 	mov	r3,r2
 9088684:	2805883a 	mov	r2,r5
 9088688:	1884b03a 	or	r2,r3,r2
 908868c:	20800405 	stb	r2,16(r4)
 9088690:	3004d23a 	srli	r2,r6,8
 9088694:	11403fcc 	andi	r5,r2,255
 9088698:	20800443 	ldbu	r2,17(r4)
 908869c:	1004703a 	and	r2,r2,zero
 90886a0:	1007883a 	mov	r3,r2
 90886a4:	2805883a 	mov	r2,r5
 90886a8:	1884b03a 	or	r2,r3,r2
 90886ac:	20800445 	stb	r2,17(r4)
 90886b0:	3004d43a 	srli	r2,r6,16
 90886b4:	11403fcc 	andi	r5,r2,255
 90886b8:	20800483 	ldbu	r2,18(r4)
 90886bc:	1004703a 	and	r2,r2,zero
 90886c0:	1007883a 	mov	r3,r2
 90886c4:	2805883a 	mov	r2,r5
 90886c8:	1884b03a 	or	r2,r3,r2
 90886cc:	20800485 	stb	r2,18(r4)
 90886d0:	300ad63a 	srli	r5,r6,24
 90886d4:	208004c3 	ldbu	r2,19(r4)
 90886d8:	1004703a 	and	r2,r2,zero
 90886dc:	1007883a 	mov	r3,r2
 90886e0:	2805883a 	mov	r2,r5
 90886e4:	1884b03a 	or	r2,r3,r2
 90886e8:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
 90886ec:	e0fff417 	ldw	r3,-48(fp)
 90886f0:	18800103 	ldbu	r2,4(r3)
 90886f4:	1004703a 	and	r2,r2,zero
 90886f8:	18800105 	stb	r2,4(r3)
 90886fc:	18800143 	ldbu	r2,5(r3)
 9088700:	1004703a 	and	r2,r2,zero
 9088704:	18800145 	stb	r2,5(r3)
 9088708:	18800183 	ldbu	r2,6(r3)
 908870c:	1004703a 	and	r2,r2,zero
 9088710:	18800185 	stb	r2,6(r3)
 9088714:	188001c3 	ldbu	r2,7(r3)
 9088718:	1004703a 	and	r2,r2,zero
 908871c:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
 9088720:	e0fff417 	ldw	r3,-48(fp)
 9088724:	18800303 	ldbu	r2,12(r3)
 9088728:	1004703a 	and	r2,r2,zero
 908872c:	18800305 	stb	r2,12(r3)
 9088730:	18800343 	ldbu	r2,13(r3)
 9088734:	1004703a 	and	r2,r2,zero
 9088738:	18800345 	stb	r2,13(r3)
 908873c:	18800383 	ldbu	r2,14(r3)
 9088740:	1004703a 	and	r2,r2,zero
 9088744:	18800385 	stb	r2,14(r3)
 9088748:	188003c3 	ldbu	r2,15(r3)
 908874c:	1004703a 	and	r2,r2,zero
 9088750:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
 9088754:	e0fff417 	ldw	r3,-48(fp)
 9088758:	18800503 	ldbu	r2,20(r3)
 908875c:	1004703a 	and	r2,r2,zero
 9088760:	18800505 	stb	r2,20(r3)
 9088764:	18800543 	ldbu	r2,21(r3)
 9088768:	1004703a 	and	r2,r2,zero
 908876c:	18800545 	stb	r2,21(r3)
 9088770:	18800583 	ldbu	r2,22(r3)
 9088774:	1004703a 	and	r2,r2,zero
 9088778:	18800585 	stb	r2,22(r3)
 908877c:	188005c3 	ldbu	r2,23(r3)
 9088780:	1004703a 	and	r2,r2,zero
 9088784:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
 9088788:	e13ff417 	ldw	r4,-48(fp)
 908878c:	e0bff80b 	ldhu	r2,-32(fp)
 9088790:	11403fcc 	andi	r5,r2,255
 9088794:	20800603 	ldbu	r2,24(r4)
 9088798:	1004703a 	and	r2,r2,zero
 908879c:	1007883a 	mov	r3,r2
 90887a0:	2805883a 	mov	r2,r5
 90887a4:	1884b03a 	or	r2,r3,r2
 90887a8:	20800605 	stb	r2,24(r4)
 90887ac:	e0bff80b 	ldhu	r2,-32(fp)
 90887b0:	1004d23a 	srli	r2,r2,8
 90887b4:	117fffcc 	andi	r5,r2,65535
 90887b8:	20800643 	ldbu	r2,25(r4)
 90887bc:	1004703a 	and	r2,r2,zero
 90887c0:	1007883a 	mov	r3,r2
 90887c4:	2805883a 	mov	r2,r5
 90887c8:	1884b03a 	or	r2,r3,r2
 90887cc:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
 90887d0:	e0fff417 	ldw	r3,-48(fp)
 90887d4:	18800703 	ldbu	r2,28(r3)
 90887d8:	1004703a 	and	r2,r2,zero
 90887dc:	18800705 	stb	r2,28(r3)
 90887e0:	18800743 	ldbu	r2,29(r3)
 90887e4:	1004703a 	and	r2,r2,zero
 90887e8:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
 90887ec:	e0bff417 	ldw	r2,-48(fp)
 90887f0:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 90887f4:	e0800617 	ldw	r2,24(fp)
 90887f8:	1007883a 	mov	r3,r2
 90887fc:	e0bff417 	ldw	r2,-48(fp)
 9088800:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 9088804:	e0800717 	ldw	r2,28(fp)
 9088808:	1007883a 	mov	r3,r2
 908880c:	e0bff417 	ldw	r2,-48(fp)
 9088810:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 9088814:	e0800317 	ldw	r2,12(fp)
 9088818:	1005003a 	cmpeq	r2,r2,zero
 908881c:	1000031e 	bne	r2,zero,908882c <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 9088820:	00bfe044 	movi	r2,-127
 9088824:	e0bfff05 	stb	r2,-4(fp)
 9088828:	00000206 	br	9088834 <alt_avalon_sgdma_construct_descriptor_burst+0x334>
 908882c:	00bfe004 	movi	r2,-128
 9088830:	e0bfff05 	stb	r2,-4(fp)
 9088834:	e0800417 	ldw	r2,16(fp)
 9088838:	1005003a 	cmpeq	r2,r2,zero
 908883c:	1000031e 	bne	r2,zero,908884c <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
 9088840:	00800084 	movi	r2,2
 9088844:	e0bffe05 	stb	r2,-8(fp)
 9088848:	00000106 	br	9088850 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
 908884c:	e03ffe05 	stb	zero,-8(fp)
 9088850:	e0ffff03 	ldbu	r3,-4(fp)
 9088854:	e13ffe03 	ldbu	r4,-8(fp)
 9088858:	1904b03a 	or	r2,r3,r4
 908885c:	e0bffd05 	stb	r2,-12(fp)
 9088860:	e0800517 	ldw	r2,20(fp)
 9088864:	1005003a 	cmpeq	r2,r2,zero
 9088868:	1000031e 	bne	r2,zero,9088878 <alt_avalon_sgdma_construct_descriptor_burst+0x378>
 908886c:	00800104 	movi	r2,4
 9088870:	e0bffc05 	stb	r2,-16(fp)
 9088874:	00000106 	br	908887c <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
 9088878:	e03ffc05 	stb	zero,-16(fp)
 908887c:	e0fffd03 	ldbu	r3,-12(fp)
 9088880:	e13ffc03 	ldbu	r4,-16(fp)
 9088884:	1904b03a 	or	r2,r3,r4
 9088888:	e0bffb05 	stb	r2,-20(fp)
 908888c:	e0bff903 	ldbu	r2,-28(fp)
 9088890:	1005003a 	cmpeq	r2,r2,zero
 9088894:	1000051e 	bne	r2,zero,90888ac <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
 9088898:	e0bff903 	ldbu	r2,-28(fp)
 908889c:	108003cc 	andi	r2,r2,15
 90888a0:	100490fa 	slli	r2,r2,3
 90888a4:	e0bffa05 	stb	r2,-24(fp)
 90888a8:	00000106 	br	90888b0 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
 90888ac:	e03ffa05 	stb	zero,-24(fp)
 90888b0:	e0fffb03 	ldbu	r3,-20(fp)
 90888b4:	e13ffa03 	ldbu	r4,-24(fp)
 90888b8:	1904b03a 	or	r2,r3,r4
 90888bc:	1007883a 	mov	r3,r2
 90888c0:	e0bff417 	ldw	r2,-48(fp)
 90888c4:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 90888c8:	e13ff417 	ldw	r4,-48(fp)
 90888cc:	01400804 	movi	r5,32
 90888d0:	90896400 	call	9089640 <alt_remap_uncached>
}
 90888d4:	e037883a 	mov	sp,fp
 90888d8:	dfc00117 	ldw	ra,4(sp)
 90888dc:	df000017 	ldw	fp,0(sp)
 90888e0:	dec00204 	addi	sp,sp,8
 90888e4:	f800283a 	ret

090888e8 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 90888e8:	defff904 	addi	sp,sp,-28
 90888ec:	dfc00615 	stw	ra,24(sp)
 90888f0:	df000515 	stw	fp,20(sp)
 90888f4:	df000504 	addi	fp,sp,20
 90888f8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 90888fc:	e0bfff17 	ldw	r2,-4(fp)
 9088900:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 9088904:	e0bffe17 	ldw	r2,-8(fp)
 9088908:	10800317 	ldw	r2,12(r2)
 908890c:	11000404 	addi	r4,r2,16
 9088910:	e0bffe17 	ldw	r2,-8(fp)
 9088914:	10800317 	ldw	r2,12(r2)
 9088918:	10800404 	addi	r2,r2,16
 908891c:	10800037 	ldwio	r2,0(r2)
 9088920:	10a00034 	orhi	r2,r2,32768
 9088924:	1007883a 	mov	r3,r2
 9088928:	2005883a 	mov	r2,r4
 908892c:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9088930:	e0bffe17 	ldw	r2,-8(fp)
 9088934:	10800317 	ldw	r2,12(r2)
 9088938:	10800404 	addi	r2,r2,16
 908893c:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 9088940:	e0bffe17 	ldw	r2,-8(fp)
 9088944:	10800917 	ldw	r2,36(r2)
 9088948:	1005003a 	cmpeq	r2,r2,zero
 908894c:	1000111e 	bne	r2,zero,9088994 <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9088950:	0005303a 	rdctl	r2,status
 9088954:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9088958:	e0fffc17 	ldw	r3,-16(fp)
 908895c:	00bfff84 	movi	r2,-2
 9088960:	1884703a 	and	r2,r3,r2
 9088964:	1001703a 	wrctl	status,r2
  
  return context;
 9088968:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
 908896c:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
 9088970:	e0bffe17 	ldw	r2,-8(fp)
 9088974:	10c00917 	ldw	r3,36(r2)
 9088978:	e0bffe17 	ldw	r2,-8(fp)
 908897c:	11000a17 	ldw	r4,40(r2)
 9088980:	183ee83a 	callr	r3
 9088984:	e0bffd17 	ldw	r2,-12(fp)
 9088988:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908898c:	e0bffb17 	ldw	r2,-20(fp)
 9088990:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 9088994:	e037883a 	mov	sp,fp
 9088998:	dfc00117 	ldw	ra,4(sp)
 908899c:	df000017 	ldw	fp,0(sp)
 90889a0:	dec00204 	addi	sp,sp,8
 90889a4:	f800283a 	ret

090889a8 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 90889a8:	defffa04 	addi	sp,sp,-24
 90889ac:	dfc00515 	stw	ra,20(sp)
 90889b0:	df000415 	stw	fp,16(sp)
 90889b4:	df000404 	addi	fp,sp,16
 90889b8:	e13ffd15 	stw	r4,-12(fp)
 90889bc:	e17ffe15 	stw	r5,-8(fp)
 90889c0:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 90889c4:	e0bffd17 	ldw	r2,-12(fp)
 90889c8:	10800317 	ldw	r2,12(r2)
 90889cc:	10800404 	addi	r2,r2,16
 90889d0:	1007883a 	mov	r3,r2
 90889d4:	00800074 	movhi	r2,1
 90889d8:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 90889dc:	e0bffd17 	ldw	r2,-12(fp)
 90889e0:	10800317 	ldw	r2,12(r2)
 90889e4:	10800404 	addi	r2,r2,16
 90889e8:	1007883a 	mov	r3,r2
 90889ec:	00800074 	movhi	r2,1
 90889f0:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 90889f4:	e0bffd17 	ldw	r2,-12(fp)
 90889f8:	10800317 	ldw	r2,12(r2)
 90889fc:	10800404 	addi	r2,r2,16
 9088a00:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9088a04:	e0bffd17 	ldw	r2,-12(fp)
 9088a08:	10800317 	ldw	r2,12(r2)
 9088a0c:	1007883a 	mov	r3,r2
 9088a10:	00803fc4 	movi	r2,255
 9088a14:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 9088a18:	e13ffd17 	ldw	r4,-12(fp)
 9088a1c:	d1600c04 	addi	r5,gp,-32720
 9088a20:	9088d200 	call	9088d20 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 9088a24:	d8000015 	stw	zero,0(sp)
 9088a28:	e13ffe17 	ldw	r4,-8(fp)
 9088a2c:	e17fff17 	ldw	r5,-4(fp)
 9088a30:	01824274 	movhi	r6,2313
 9088a34:	31a23a04 	addi	r6,r6,-30488
 9088a38:	e1fffd17 	ldw	r7,-12(fp)
 9088a3c:	90892380 	call	9089238 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 9088a40:	e037883a 	mov	sp,fp
 9088a44:	dfc00117 	ldw	ra,4(sp)
 9088a48:	df000017 	ldw	fp,0(sp)
 9088a4c:	dec00204 	addi	sp,sp,8
 9088a50:	f800283a 	ret

09088a54 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 9088a54:	defffa04 	addi	sp,sp,-24
 9088a58:	dfc00515 	stw	ra,20(sp)
 9088a5c:	df000415 	stw	fp,16(sp)
 9088a60:	df000404 	addi	fp,sp,16
 9088a64:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 9088a68:	e0bfff17 	ldw	r2,-4(fp)
 9088a6c:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 9088a70:	e0bfff17 	ldw	r2,-4(fp)
 9088a74:	10800104 	addi	r2,r2,4
 9088a78:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9088a7c:	0005303a 	rdctl	r2,status
 9088a80:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9088a84:	e0fffd17 	ldw	r3,-12(fp)
 9088a88:	00bfff84 	movi	r2,-2
 9088a8c:	1884703a 	and	r2,r3,r2
 9088a90:	1001703a 	wrctl	status,r2
  
  return context;
 9088a94:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 9088a98:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 9088a9c:	90897180 	call	9089718 <alt_tick>
 9088aa0:	e0bffe17 	ldw	r2,-8(fp)
 9088aa4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9088aa8:	e0bffc17 	ldw	r2,-16(fp)
 9088aac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 9088ab0:	e037883a 	mov	sp,fp
 9088ab4:	dfc00117 	ldw	ra,4(sp)
 9088ab8:	df000017 	ldw	fp,0(sp)
 9088abc:	dec00204 	addi	sp,sp,8
 9088ac0:	f800283a 	ret

09088ac4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 9088ac4:	defff804 	addi	sp,sp,-32
 9088ac8:	dfc00715 	stw	ra,28(sp)
 9088acc:	df000615 	stw	fp,24(sp)
 9088ad0:	df000604 	addi	fp,sp,24
 9088ad4:	e13ffc15 	stw	r4,-16(fp)
 9088ad8:	e17ffd15 	stw	r5,-12(fp)
 9088adc:	e1bffe15 	stw	r6,-8(fp)
 9088ae0:	e1ffff15 	stw	r7,-4(fp)
 9088ae4:	e0bfff17 	ldw	r2,-4(fp)
 9088ae8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 9088aec:	00824274 	movhi	r2,2313
 9088af0:	10b19704 	addi	r2,r2,-14756
 9088af4:	10800017 	ldw	r2,0(r2)
 9088af8:	1004c03a 	cmpne	r2,r2,zero
 9088afc:	1000041e 	bne	r2,zero,9088b10 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 9088b00:	00c24274 	movhi	r3,2313
 9088b04:	18f19704 	addi	r3,r3,-14756
 9088b08:	e0bffb17 	ldw	r2,-20(fp)
 9088b0c:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 9088b10:	e0bffc17 	ldw	r2,-16(fp)
 9088b14:	10800104 	addi	r2,r2,4
 9088b18:	1007883a 	mov	r3,r2
 9088b1c:	008001c4 	movi	r2,7
 9088b20:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 9088b24:	d8000015 	stw	zero,0(sp)
 9088b28:	e13ffd17 	ldw	r4,-12(fp)
 9088b2c:	e17ffe17 	ldw	r5,-8(fp)
 9088b30:	01824274 	movhi	r6,2313
 9088b34:	31a29504 	addi	r6,r6,-30124
 9088b38:	e1fffc17 	ldw	r7,-16(fp)
 9088b3c:	90892380 	call	9089238 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 9088b40:	e037883a 	mov	sp,fp
 9088b44:	dfc00117 	ldw	ra,4(sp)
 9088b48:	df000017 	ldw	fp,0(sp)
 9088b4c:	dec00204 	addi	sp,sp,8
 9088b50:	f800283a 	ret

09088b54 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 9088b54:	defff404 	addi	sp,sp,-48
 9088b58:	df000b15 	stw	fp,44(sp)
 9088b5c:	df000b04 	addi	fp,sp,44
 9088b60:	e13ffb15 	stw	r4,-20(fp)
 9088b64:	e17ffc15 	stw	r5,-16(fp)
 9088b68:	e1bffd15 	stw	r6,-12(fp)
 9088b6c:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 9088b70:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 9088b74:	00824274 	movhi	r2,2313
 9088b78:	10b19704 	addi	r2,r2,-14756
 9088b7c:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 9088b80:	1005003a 	cmpeq	r2,r2,zero
 9088b84:	1000411e 	bne	r2,zero,9088c8c <alt_alarm_start+0x138>
  {
    if (alarm)
 9088b88:	e0bffb17 	ldw	r2,-20(fp)
 9088b8c:	1005003a 	cmpeq	r2,r2,zero
 9088b90:	10003b1e 	bne	r2,zero,9088c80 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 9088b94:	e0fffb17 	ldw	r3,-20(fp)
 9088b98:	e0bffd17 	ldw	r2,-12(fp)
 9088b9c:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 9088ba0:	e0fffb17 	ldw	r3,-20(fp)
 9088ba4:	e0bffe17 	ldw	r2,-8(fp)
 9088ba8:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9088bac:	0005303a 	rdctl	r2,status
 9088bb0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9088bb4:	e0fff817 	ldw	r3,-32(fp)
 9088bb8:	00bfff84 	movi	r2,-2
 9088bbc:	1884703a 	and	r2,r3,r2
 9088bc0:	1001703a 	wrctl	status,r2
  
  return context;
 9088bc4:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 9088bc8:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 9088bcc:	00824274 	movhi	r2,2313
 9088bd0:	10b19804 	addi	r2,r2,-14752
 9088bd4:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 9088bd8:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 9088bdc:	e0fffc17 	ldw	r3,-16(fp)
 9088be0:	e0bff917 	ldw	r2,-28(fp)
 9088be4:	1885883a 	add	r2,r3,r2
 9088be8:	10c00044 	addi	r3,r2,1
 9088bec:	e0bffb17 	ldw	r2,-20(fp)
 9088bf0:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 9088bf4:	e0bffb17 	ldw	r2,-20(fp)
 9088bf8:	10c00217 	ldw	r3,8(r2)
 9088bfc:	e0bff917 	ldw	r2,-28(fp)
 9088c00:	1880042e 	bgeu	r3,r2,9088c14 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 9088c04:	e0fffb17 	ldw	r3,-20(fp)
 9088c08:	00800044 	movi	r2,1
 9088c0c:	18800405 	stb	r2,16(r3)
 9088c10:	00000206 	br	9088c1c <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 9088c14:	e0bffb17 	ldw	r2,-20(fp)
 9088c18:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 9088c1c:	e0fffb17 	ldw	r3,-20(fp)
 9088c20:	00824274 	movhi	r2,2313
 9088c24:	10b18c04 	addi	r2,r2,-14800
 9088c28:	e0bff615 	stw	r2,-40(fp)
 9088c2c:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 9088c30:	e0fff717 	ldw	r3,-36(fp)
 9088c34:	e0bff617 	ldw	r2,-40(fp)
 9088c38:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 9088c3c:	e0bff617 	ldw	r2,-40(fp)
 9088c40:	10c00017 	ldw	r3,0(r2)
 9088c44:	e0bff717 	ldw	r2,-36(fp)
 9088c48:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 9088c4c:	e0bff617 	ldw	r2,-40(fp)
 9088c50:	10c00017 	ldw	r3,0(r2)
 9088c54:	e0bff717 	ldw	r2,-36(fp)
 9088c58:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 9088c5c:	e0fff617 	ldw	r3,-40(fp)
 9088c60:	e0bff717 	ldw	r2,-36(fp)
 9088c64:	18800015 	stw	r2,0(r3)
 9088c68:	e0bffa17 	ldw	r2,-24(fp)
 9088c6c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9088c70:	e0bff517 	ldw	r2,-44(fp)
 9088c74:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 9088c78:	e03fff15 	stw	zero,-4(fp)
 9088c7c:	00000506 	br	9088c94 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 9088c80:	00bffa84 	movi	r2,-22
 9088c84:	e0bfff15 	stw	r2,-4(fp)
 9088c88:	00000206 	br	9088c94 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 9088c8c:	00bfde84 	movi	r2,-134
 9088c90:	e0bfff15 	stw	r2,-4(fp)
 9088c94:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 9088c98:	e037883a 	mov	sp,fp
 9088c9c:	df000017 	ldw	fp,0(sp)
 9088ca0:	dec00104 	addi	sp,sp,4
 9088ca4:	f800283a 	ret

09088ca8 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 9088ca8:	defffb04 	addi	sp,sp,-20
 9088cac:	df000415 	stw	fp,16(sp)
 9088cb0:	df000404 	addi	fp,sp,16
 9088cb4:	e13ffe15 	stw	r4,-8(fp)
 9088cb8:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 9088cbc:	e0fffe17 	ldw	r3,-8(fp)
 9088cc0:	e0bfff17 	ldw	r2,-4(fp)
 9088cc4:	1885883a 	add	r2,r3,r2
 9088cc8:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 9088ccc:	e0bffe17 	ldw	r2,-8(fp)
 9088cd0:	e0bffd15 	stw	r2,-12(fp)
 9088cd4:	00000506 	br	9088cec <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 9088cd8:	e0bffd17 	ldw	r2,-12(fp)
 9088cdc:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 9088ce0:	e0bffd17 	ldw	r2,-12(fp)
 9088ce4:	10800804 	addi	r2,r2,32
 9088ce8:	e0bffd15 	stw	r2,-12(fp)
 9088cec:	e0fffd17 	ldw	r3,-12(fp)
 9088cf0:	e0bffc17 	ldw	r2,-16(fp)
 9088cf4:	18bff836 	bltu	r3,r2,9088cd8 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 9088cf8:	e0bffe17 	ldw	r2,-8(fp)
 9088cfc:	108007cc 	andi	r2,r2,31
 9088d00:	1005003a 	cmpeq	r2,r2,zero
 9088d04:	1000021e 	bne	r2,zero,9088d10 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 9088d08:	e0bffd17 	ldw	r2,-12(fp)
 9088d0c:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 9088d10:	e037883a 	mov	sp,fp
 9088d14:	df000017 	ldw	fp,0(sp)
 9088d18:	dec00104 	addi	sp,sp,4
 9088d1c:	f800283a 	ret

09088d20 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 9088d20:	defff904 	addi	sp,sp,-28
 9088d24:	dfc00615 	stw	ra,24(sp)
 9088d28:	df000515 	stw	fp,20(sp)
 9088d2c:	df000504 	addi	fp,sp,20
 9088d30:	e13ffd15 	stw	r4,-12(fp)
 9088d34:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 9088d38:	e0bffd17 	ldw	r2,-12(fp)
 9088d3c:	1005003a 	cmpeq	r2,r2,zero
 9088d40:	1000041e 	bne	r2,zero,9088d54 <alt_dev_llist_insert+0x34>
 9088d44:	e0bffd17 	ldw	r2,-12(fp)
 9088d48:	10800217 	ldw	r2,8(r2)
 9088d4c:	1004c03a 	cmpne	r2,r2,zero
 9088d50:	1000071e 	bne	r2,zero,9088d70 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 9088d54:	9088dd40 	call	9088dd4 <alt_get_errno>
 9088d58:	1007883a 	mov	r3,r2
 9088d5c:	00800584 	movi	r2,22
 9088d60:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 9088d64:	00bffa84 	movi	r2,-22
 9088d68:	e0bfff15 	stw	r2,-4(fp)
 9088d6c:	00001306 	br	9088dbc <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 9088d70:	e0fffd17 	ldw	r3,-12(fp)
 9088d74:	e0bffe17 	ldw	r2,-8(fp)
 9088d78:	e0bffb15 	stw	r2,-20(fp)
 9088d7c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 9088d80:	e0fffc17 	ldw	r3,-16(fp)
 9088d84:	e0bffb17 	ldw	r2,-20(fp)
 9088d88:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 9088d8c:	e0bffb17 	ldw	r2,-20(fp)
 9088d90:	10c00017 	ldw	r3,0(r2)
 9088d94:	e0bffc17 	ldw	r2,-16(fp)
 9088d98:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 9088d9c:	e0bffb17 	ldw	r2,-20(fp)
 9088da0:	10c00017 	ldw	r3,0(r2)
 9088da4:	e0bffc17 	ldw	r2,-16(fp)
 9088da8:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 9088dac:	e0fffb17 	ldw	r3,-20(fp)
 9088db0:	e0bffc17 	ldw	r2,-16(fp)
 9088db4:	18800015 	stw	r2,0(r3)

  return 0;  
 9088db8:	e03fff15 	stw	zero,-4(fp)
 9088dbc:	e0bfff17 	ldw	r2,-4(fp)
}
 9088dc0:	e037883a 	mov	sp,fp
 9088dc4:	dfc00117 	ldw	ra,4(sp)
 9088dc8:	df000017 	ldw	fp,0(sp)
 9088dcc:	dec00204 	addi	sp,sp,8
 9088dd0:	f800283a 	ret

09088dd4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 9088dd4:	defffd04 	addi	sp,sp,-12
 9088dd8:	dfc00215 	stw	ra,8(sp)
 9088ddc:	df000115 	stw	fp,4(sp)
 9088de0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 9088de4:	00824274 	movhi	r2,2313
 9088de8:	10b18404 	addi	r2,r2,-14832
 9088dec:	10800017 	ldw	r2,0(r2)
 9088df0:	1005003a 	cmpeq	r2,r2,zero
 9088df4:	1000061e 	bne	r2,zero,9088e10 <alt_get_errno+0x3c>
 9088df8:	00824274 	movhi	r2,2313
 9088dfc:	10b18404 	addi	r2,r2,-14832
 9088e00:	10800017 	ldw	r2,0(r2)
 9088e04:	103ee83a 	callr	r2
 9088e08:	e0bfff15 	stw	r2,-4(fp)
 9088e0c:	00000306 	br	9088e1c <alt_get_errno+0x48>
 9088e10:	00824274 	movhi	r2,2313
 9088e14:	10b18f04 	addi	r2,r2,-14788
 9088e18:	e0bfff15 	stw	r2,-4(fp)
 9088e1c:	e0bfff17 	ldw	r2,-4(fp)
}
 9088e20:	e037883a 	mov	sp,fp
 9088e24:	dfc00117 	ldw	ra,4(sp)
 9088e28:	df000017 	ldw	fp,0(sp)
 9088e2c:	dec00204 	addi	sp,sp,8
 9088e30:	f800283a 	ret

09088e34 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 9088e34:	defffd04 	addi	sp,sp,-12
 9088e38:	dfc00215 	stw	ra,8(sp)
 9088e3c:	df000115 	stw	fp,4(sp)
 9088e40:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 9088e44:	00bfff04 	movi	r2,-4
 9088e48:	00c24274 	movhi	r3,2313
 9088e4c:	18e99b04 	addi	r3,r3,-22932
 9088e50:	1885883a 	add	r2,r3,r2
 9088e54:	e0bfff15 	stw	r2,-4(fp)
 9088e58:	00000606 	br	9088e74 <_do_ctors+0x40>
        (*ctor) (); 
 9088e5c:	e0bfff17 	ldw	r2,-4(fp)
 9088e60:	10800017 	ldw	r2,0(r2)
 9088e64:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 9088e68:	e0bfff17 	ldw	r2,-4(fp)
 9088e6c:	10bfff04 	addi	r2,r2,-4
 9088e70:	e0bfff15 	stw	r2,-4(fp)
 9088e74:	e0ffff17 	ldw	r3,-4(fp)
 9088e78:	00824274 	movhi	r2,2313
 9088e7c:	10a99a04 	addi	r2,r2,-22936
 9088e80:	18bff62e 	bgeu	r3,r2,9088e5c <_do_ctors+0x28>
        (*ctor) (); 
}
 9088e84:	e037883a 	mov	sp,fp
 9088e88:	dfc00117 	ldw	ra,4(sp)
 9088e8c:	df000017 	ldw	fp,0(sp)
 9088e90:	dec00204 	addi	sp,sp,8
 9088e94:	f800283a 	ret

09088e98 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 9088e98:	defffd04 	addi	sp,sp,-12
 9088e9c:	dfc00215 	stw	ra,8(sp)
 9088ea0:	df000115 	stw	fp,4(sp)
 9088ea4:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 9088ea8:	00bfff04 	movi	r2,-4
 9088eac:	00c24274 	movhi	r3,2313
 9088eb0:	18e99b04 	addi	r3,r3,-22932
 9088eb4:	1885883a 	add	r2,r3,r2
 9088eb8:	e0bfff15 	stw	r2,-4(fp)
 9088ebc:	00000606 	br	9088ed8 <_do_dtors+0x40>
        (*dtor) (); 
 9088ec0:	e0bfff17 	ldw	r2,-4(fp)
 9088ec4:	10800017 	ldw	r2,0(r2)
 9088ec8:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 9088ecc:	e0bfff17 	ldw	r2,-4(fp)
 9088ed0:	10bfff04 	addi	r2,r2,-4
 9088ed4:	e0bfff15 	stw	r2,-4(fp)
 9088ed8:	e0ffff17 	ldw	r3,-4(fp)
 9088edc:	00824274 	movhi	r2,2313
 9088ee0:	10a99b04 	addi	r2,r2,-22932
 9088ee4:	18bff62e 	bgeu	r3,r2,9088ec0 <_do_dtors+0x28>
        (*dtor) (); 
}
 9088ee8:	e037883a 	mov	sp,fp
 9088eec:	dfc00117 	ldw	ra,4(sp)
 9088ef0:	df000017 	ldw	fp,0(sp)
 9088ef4:	dec00204 	addi	sp,sp,8
 9088ef8:	f800283a 	ret

09088efc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 9088efc:	defff904 	addi	sp,sp,-28
 9088f00:	dfc00615 	stw	ra,24(sp)
 9088f04:	df000515 	stw	fp,20(sp)
 9088f08:	df000504 	addi	fp,sp,20
 9088f0c:	e13ffd15 	stw	r4,-12(fp)
 9088f10:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 9088f14:	e0bffe17 	ldw	r2,-8(fp)
 9088f18:	10800017 	ldw	r2,0(r2)
 9088f1c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 9088f20:	e13ffd17 	ldw	r4,-12(fp)
 9088f24:	90824440 	call	9082444 <strlen>
 9088f28:	10800044 	addi	r2,r2,1
 9088f2c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 9088f30:	00000d06 	br	9088f68 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 9088f34:	e0bffc17 	ldw	r2,-16(fp)
 9088f38:	11000217 	ldw	r4,8(r2)
 9088f3c:	e1bffb17 	ldw	r6,-20(fp)
 9088f40:	e17ffd17 	ldw	r5,-12(fp)
 9088f44:	908a2ac0 	call	908a2ac <memcmp>
 9088f48:	1004c03a 	cmpne	r2,r2,zero
 9088f4c:	1000031e 	bne	r2,zero,9088f5c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 9088f50:	e0bffc17 	ldw	r2,-16(fp)
 9088f54:	e0bfff15 	stw	r2,-4(fp)
 9088f58:	00000706 	br	9088f78 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 9088f5c:	e0bffc17 	ldw	r2,-16(fp)
 9088f60:	10800017 	ldw	r2,0(r2)
 9088f64:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 9088f68:	e0fffe17 	ldw	r3,-8(fp)
 9088f6c:	e0bffc17 	ldw	r2,-16(fp)
 9088f70:	10fff01e 	bne	r2,r3,9088f34 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 9088f74:	e03fff15 	stw	zero,-4(fp)
 9088f78:	e0bfff17 	ldw	r2,-4(fp)
}
 9088f7c:	e037883a 	mov	sp,fp
 9088f80:	dfc00117 	ldw	ra,4(sp)
 9088f84:	df000017 	ldw	fp,0(sp)
 9088f88:	dec00204 	addi	sp,sp,8
 9088f8c:	f800283a 	ret

09088f90 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 9088f90:	defffa04 	addi	sp,sp,-24
 9088f94:	dfc00515 	stw	ra,20(sp)
 9088f98:	df000415 	stw	fp,16(sp)
 9088f9c:	df000404 	addi	fp,sp,16
 9088fa0:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 9088fa4:	00824274 	movhi	r2,2313
 9088fa8:	10b17f04 	addi	r2,r2,-14852
 9088fac:	10800017 	ldw	r2,0(r2)
 9088fb0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 9088fb4:	00003306 	br	9089084 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 9088fb8:	e0bffd17 	ldw	r2,-12(fp)
 9088fbc:	11000217 	ldw	r4,8(r2)
 9088fc0:	90824440 	call	9082444 <strlen>
 9088fc4:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 9088fc8:	e0bffd17 	ldw	r2,-12(fp)
 9088fcc:	10c00217 	ldw	r3,8(r2)
 9088fd0:	e0bffc17 	ldw	r2,-16(fp)
 9088fd4:	1885883a 	add	r2,r3,r2
 9088fd8:	10bfffc4 	addi	r2,r2,-1
 9088fdc:	10800003 	ldbu	r2,0(r2)
 9088fe0:	10803fcc 	andi	r2,r2,255
 9088fe4:	1080201c 	xori	r2,r2,128
 9088fe8:	10bfe004 	addi	r2,r2,-128
 9088fec:	10800bd8 	cmpnei	r2,r2,47
 9088ff0:	1000031e 	bne	r2,zero,9089000 <alt_find_file+0x70>
    {
      len -= 1;
 9088ff4:	e0bffc17 	ldw	r2,-16(fp)
 9088ff8:	10bfffc4 	addi	r2,r2,-1
 9088ffc:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 9089000:	e0bffc17 	ldw	r2,-16(fp)
 9089004:	1007883a 	mov	r3,r2
 9089008:	e0bffe17 	ldw	r2,-8(fp)
 908900c:	1885883a 	add	r2,r3,r2
 9089010:	10800003 	ldbu	r2,0(r2)
 9089014:	10803fcc 	andi	r2,r2,255
 9089018:	1080201c 	xori	r2,r2,128
 908901c:	10bfe004 	addi	r2,r2,-128
 9089020:	10800be0 	cmpeqi	r2,r2,47
 9089024:	10000a1e 	bne	r2,zero,9089050 <alt_find_file+0xc0>
 9089028:	e0bffc17 	ldw	r2,-16(fp)
 908902c:	1007883a 	mov	r3,r2
 9089030:	e0bffe17 	ldw	r2,-8(fp)
 9089034:	1885883a 	add	r2,r3,r2
 9089038:	10800003 	ldbu	r2,0(r2)
 908903c:	10803fcc 	andi	r2,r2,255
 9089040:	1080201c 	xori	r2,r2,128
 9089044:	10bfe004 	addi	r2,r2,-128
 9089048:	1004c03a 	cmpne	r2,r2,zero
 908904c:	10000a1e 	bne	r2,zero,9089078 <alt_find_file+0xe8>
 9089050:	e0bffd17 	ldw	r2,-12(fp)
 9089054:	11000217 	ldw	r4,8(r2)
 9089058:	e1bffc17 	ldw	r6,-16(fp)
 908905c:	e17ffe17 	ldw	r5,-8(fp)
 9089060:	908a2ac0 	call	908a2ac <memcmp>
 9089064:	1004c03a 	cmpne	r2,r2,zero
 9089068:	1000031e 	bne	r2,zero,9089078 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 908906c:	e0bffd17 	ldw	r2,-12(fp)
 9089070:	e0bfff15 	stw	r2,-4(fp)
 9089074:	00000806 	br	9089098 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 9089078:	e0bffd17 	ldw	r2,-12(fp)
 908907c:	10800017 	ldw	r2,0(r2)
 9089080:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 9089084:	00c24274 	movhi	r3,2313
 9089088:	18f17f04 	addi	r3,r3,-14852
 908908c:	e0bffd17 	ldw	r2,-12(fp)
 9089090:	10ffc91e 	bne	r2,r3,9088fb8 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 9089094:	e03fff15 	stw	zero,-4(fp)
 9089098:	e0bfff17 	ldw	r2,-4(fp)
}
 908909c:	e037883a 	mov	sp,fp
 90890a0:	dfc00117 	ldw	ra,4(sp)
 90890a4:	df000017 	ldw	fp,0(sp)
 90890a8:	dec00204 	addi	sp,sp,8
 90890ac:	f800283a 	ret

090890b0 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 90890b0:	defffb04 	addi	sp,sp,-20
 90890b4:	dfc00415 	stw	ra,16(sp)
 90890b8:	df000315 	stw	fp,12(sp)
 90890bc:	df000304 	addi	fp,sp,12
 90890c0:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 90890c4:	e13ffe17 	ldw	r4,-8(fp)
 90890c8:	d1600e04 	addi	r5,gp,-32712
 90890cc:	9088efc0 	call	9088efc <alt_find_dev>
 90890d0:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 90890d4:	e0bffd17 	ldw	r2,-12(fp)
 90890d8:	1005003a 	cmpeq	r2,r2,zero
 90890dc:	10000b1e 	bne	r2,zero,908910c <alt_flash_open_dev+0x5c>
 90890e0:	e0bffd17 	ldw	r2,-12(fp)
 90890e4:	10800317 	ldw	r2,12(r2)
 90890e8:	1005003a 	cmpeq	r2,r2,zero
 90890ec:	1000071e 	bne	r2,zero,908910c <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 90890f0:	e0bffd17 	ldw	r2,-12(fp)
 90890f4:	10800317 	ldw	r2,12(r2)
 90890f8:	e13ffd17 	ldw	r4,-12(fp)
 90890fc:	e17ffe17 	ldw	r5,-8(fp)
 9089100:	103ee83a 	callr	r2
 9089104:	e0bfff15 	stw	r2,-4(fp)
 9089108:	00000206 	br	9089114 <alt_flash_open_dev+0x64>
  }

  return dev;
 908910c:	e0bffd17 	ldw	r2,-12(fp)
 9089110:	e0bfff15 	stw	r2,-4(fp)
 9089114:	e0bfff17 	ldw	r2,-4(fp)
}
 9089118:	e037883a 	mov	sp,fp
 908911c:	dfc00117 	ldw	ra,4(sp)
 9089120:	df000017 	ldw	fp,0(sp)
 9089124:	dec00204 	addi	sp,sp,8
 9089128:	f800283a 	ret

0908912c <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 908912c:	defffd04 	addi	sp,sp,-12
 9089130:	dfc00215 	stw	ra,8(sp)
 9089134:	df000115 	stw	fp,4(sp)
 9089138:	df000104 	addi	fp,sp,4
 908913c:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 9089140:	e0bfff17 	ldw	r2,-4(fp)
 9089144:	1005003a 	cmpeq	r2,r2,zero
 9089148:	1000081e 	bne	r2,zero,908916c <alt_flash_close_dev+0x40>
 908914c:	e0bfff17 	ldw	r2,-4(fp)
 9089150:	10800417 	ldw	r2,16(r2)
 9089154:	1005003a 	cmpeq	r2,r2,zero
 9089158:	1000041e 	bne	r2,zero,908916c <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 908915c:	e0bfff17 	ldw	r2,-4(fp)
 9089160:	10800417 	ldw	r2,16(r2)
 9089164:	e13fff17 	ldw	r4,-4(fp)
 9089168:	103ee83a 	callr	r2
  }
  return;
}
 908916c:	e037883a 	mov	sp,fp
 9089170:	dfc00117 	ldw	ra,4(sp)
 9089174:	df000017 	ldw	fp,0(sp)
 9089178:	dec00204 	addi	sp,sp,8
 908917c:	f800283a 	ret

09089180 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 9089180:	defffc04 	addi	sp,sp,-16
 9089184:	df000315 	stw	fp,12(sp)
 9089188:	df000304 	addi	fp,sp,12
 908918c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 9089190:	00bffa04 	movi	r2,-24
 9089194:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 9089198:	e03ffe15 	stw	zero,-8(fp)
 908919c:	00001e06 	br	9089218 <alt_get_fd+0x98>
  {
    if (!alt_fd_list[i].dev)
 90891a0:	e0bffe17 	ldw	r2,-8(fp)
 90891a4:	00c24274 	movhi	r3,2313
 90891a8:	18ec6d04 	addi	r3,r3,-20044
 90891ac:	10800324 	muli	r2,r2,12
 90891b0:	10c5883a 	add	r2,r2,r3
 90891b4:	10800017 	ldw	r2,0(r2)
 90891b8:	1004c03a 	cmpne	r2,r2,zero
 90891bc:	1000131e 	bne	r2,zero,908920c <alt_get_fd+0x8c>
    {
      alt_fd_list[i].dev = dev;
 90891c0:	e0bffe17 	ldw	r2,-8(fp)
 90891c4:	00c24274 	movhi	r3,2313
 90891c8:	18ec6d04 	addi	r3,r3,-20044
 90891cc:	10800324 	muli	r2,r2,12
 90891d0:	10c7883a 	add	r3,r2,r3
 90891d4:	e0bfff17 	ldw	r2,-4(fp)
 90891d8:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 90891dc:	00824274 	movhi	r2,2313
 90891e0:	10b18304 	addi	r2,r2,-14836
 90891e4:	10c00017 	ldw	r3,0(r2)
 90891e8:	e0bffe17 	ldw	r2,-8(fp)
 90891ec:	1880040e 	bge	r3,r2,9089200 <alt_get_fd+0x80>
      {
        alt_max_fd = i;
 90891f0:	00c24274 	movhi	r3,2313
 90891f4:	18f18304 	addi	r3,r3,-14836
 90891f8:	e0bffe17 	ldw	r2,-8(fp)
 90891fc:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 9089200:	e0bffe17 	ldw	r2,-8(fp)
 9089204:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 9089208:	00000606 	br	9089224 <alt_get_fd+0xa4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 908920c:	e0bffe17 	ldw	r2,-8(fp)
 9089210:	10800044 	addi	r2,r2,1
 9089214:	e0bffe15 	stw	r2,-8(fp)
 9089218:	e0bffe17 	ldw	r2,-8(fp)
 908921c:	10800810 	cmplti	r2,r2,32
 9089220:	103fdf1e 	bne	r2,zero,90891a0 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 9089224:	e0bffd17 	ldw	r2,-12(fp)
}
 9089228:	e037883a 	mov	sp,fp
 908922c:	df000017 	ldw	fp,0(sp)
 9089230:	dec00104 	addi	sp,sp,4
 9089234:	f800283a 	ret

09089238 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 9089238:	defff904 	addi	sp,sp,-28
 908923c:	dfc00615 	stw	ra,24(sp)
 9089240:	df000515 	stw	fp,20(sp)
 9089244:	df000504 	addi	fp,sp,20
 9089248:	e13ffc15 	stw	r4,-16(fp)
 908924c:	e17ffd15 	stw	r5,-12(fp)
 9089250:	e1bffe15 	stw	r6,-8(fp)
 9089254:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 9089258:	e0800217 	ldw	r2,8(fp)
 908925c:	d8800015 	stw	r2,0(sp)
 9089260:	e13ffc17 	ldw	r4,-16(fp)
 9089264:	e17ffd17 	ldw	r5,-12(fp)
 9089268:	e1bffe17 	ldw	r6,-8(fp)
 908926c:	e1ffff17 	ldw	r7,-4(fp)
 9089270:	908940c0 	call	908940c <alt_iic_isr_register>
}  
 9089274:	e037883a 	mov	sp,fp
 9089278:	dfc00117 	ldw	ra,4(sp)
 908927c:	df000017 	ldw	fp,0(sp)
 9089280:	dec00204 	addi	sp,sp,8
 9089284:	f800283a 	ret

09089288 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 9089288:	defff904 	addi	sp,sp,-28
 908928c:	df000615 	stw	fp,24(sp)
 9089290:	df000604 	addi	fp,sp,24
 9089294:	e13ffe15 	stw	r4,-8(fp)
 9089298:	e17fff15 	stw	r5,-4(fp)
 908929c:	e0bfff17 	ldw	r2,-4(fp)
 90892a0:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90892a4:	0005303a 	rdctl	r2,status
 90892a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90892ac:	e0fffb17 	ldw	r3,-20(fp)
 90892b0:	00bfff84 	movi	r2,-2
 90892b4:	1884703a 	and	r2,r3,r2
 90892b8:	1001703a 	wrctl	status,r2
  
  return context;
 90892bc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 90892c0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 90892c4:	e0fffc17 	ldw	r3,-16(fp)
 90892c8:	00800044 	movi	r2,1
 90892cc:	10c4983a 	sll	r2,r2,r3
 90892d0:	1007883a 	mov	r3,r2
 90892d4:	00824274 	movhi	r2,2313
 90892d8:	10b19604 	addi	r2,r2,-14760
 90892dc:	10800017 	ldw	r2,0(r2)
 90892e0:	1886b03a 	or	r3,r3,r2
 90892e4:	00824274 	movhi	r2,2313
 90892e8:	10b19604 	addi	r2,r2,-14760
 90892ec:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 90892f0:	00824274 	movhi	r2,2313
 90892f4:	10b19604 	addi	r2,r2,-14760
 90892f8:	10800017 	ldw	r2,0(r2)
 90892fc:	100170fa 	wrctl	ienable,r2
 9089300:	e0bffd17 	ldw	r2,-12(fp)
 9089304:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9089308:	e0bffa17 	ldw	r2,-24(fp)
 908930c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 9089310:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 9089314:	e037883a 	mov	sp,fp
 9089318:	df000017 	ldw	fp,0(sp)
 908931c:	dec00104 	addi	sp,sp,4
 9089320:	f800283a 	ret

09089324 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 9089324:	defff904 	addi	sp,sp,-28
 9089328:	df000615 	stw	fp,24(sp)
 908932c:	df000604 	addi	fp,sp,24
 9089330:	e13ffe15 	stw	r4,-8(fp)
 9089334:	e17fff15 	stw	r5,-4(fp)
 9089338:	e0bfff17 	ldw	r2,-4(fp)
 908933c:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9089340:	0005303a 	rdctl	r2,status
 9089344:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9089348:	e0fffb17 	ldw	r3,-20(fp)
 908934c:	00bfff84 	movi	r2,-2
 9089350:	1884703a 	and	r2,r3,r2
 9089354:	1001703a 	wrctl	status,r2
  
  return context;
 9089358:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 908935c:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 9089360:	e0fffc17 	ldw	r3,-16(fp)
 9089364:	00800044 	movi	r2,1
 9089368:	10c4983a 	sll	r2,r2,r3
 908936c:	0084303a 	nor	r2,zero,r2
 9089370:	1007883a 	mov	r3,r2
 9089374:	00824274 	movhi	r2,2313
 9089378:	10b19604 	addi	r2,r2,-14760
 908937c:	10800017 	ldw	r2,0(r2)
 9089380:	1886703a 	and	r3,r3,r2
 9089384:	00824274 	movhi	r2,2313
 9089388:	10b19604 	addi	r2,r2,-14760
 908938c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 9089390:	00824274 	movhi	r2,2313
 9089394:	10b19604 	addi	r2,r2,-14760
 9089398:	10800017 	ldw	r2,0(r2)
 908939c:	100170fa 	wrctl	ienable,r2
 90893a0:	e0bffd17 	ldw	r2,-12(fp)
 90893a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90893a8:	e0bffa17 	ldw	r2,-24(fp)
 90893ac:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 90893b0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 90893b4:	e037883a 	mov	sp,fp
 90893b8:	df000017 	ldw	fp,0(sp)
 90893bc:	dec00104 	addi	sp,sp,4
 90893c0:	f800283a 	ret

090893c4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 90893c4:	defffc04 	addi	sp,sp,-16
 90893c8:	df000315 	stw	fp,12(sp)
 90893cc:	df000304 	addi	fp,sp,12
 90893d0:	e13ffe15 	stw	r4,-8(fp)
 90893d4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 90893d8:	000530fa 	rdctl	r2,ienable
 90893dc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 90893e0:	e0ffff17 	ldw	r3,-4(fp)
 90893e4:	00800044 	movi	r2,1
 90893e8:	10c4983a 	sll	r2,r2,r3
 90893ec:	1007883a 	mov	r3,r2
 90893f0:	e0bffd17 	ldw	r2,-12(fp)
 90893f4:	1884703a 	and	r2,r3,r2
 90893f8:	1004c03a 	cmpne	r2,r2,zero
}
 90893fc:	e037883a 	mov	sp,fp
 9089400:	df000017 	ldw	fp,0(sp)
 9089404:	dec00104 	addi	sp,sp,4
 9089408:	f800283a 	ret

0908940c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 908940c:	defff404 	addi	sp,sp,-48
 9089410:	dfc00b15 	stw	ra,44(sp)
 9089414:	df000a15 	stw	fp,40(sp)
 9089418:	df000a04 	addi	fp,sp,40
 908941c:	e13ffb15 	stw	r4,-20(fp)
 9089420:	e17ffc15 	stw	r5,-16(fp)
 9089424:	e1bffd15 	stw	r6,-12(fp)
 9089428:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 908942c:	00bffa84 	movi	r2,-22
 9089430:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 9089434:	e0bffc17 	ldw	r2,-16(fp)
 9089438:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 908943c:	e0bff917 	ldw	r2,-28(fp)
 9089440:	10800808 	cmpgei	r2,r2,32
 9089444:	1000291e 	bne	r2,zero,90894ec <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9089448:	0005303a 	rdctl	r2,status
 908944c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9089450:	e0fff717 	ldw	r3,-36(fp)
 9089454:	00bfff84 	movi	r2,-2
 9089458:	1884703a 	and	r2,r3,r2
 908945c:	1001703a 	wrctl	status,r2
  
  return context;
 9089460:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 9089464:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 9089468:	e0bff917 	ldw	r2,-28(fp)
 908946c:	00c24274 	movhi	r3,2313
 9089470:	18f1a304 	addi	r3,r3,-14708
 9089474:	100490fa 	slli	r2,r2,3
 9089478:	10c7883a 	add	r3,r2,r3
 908947c:	e0bffd17 	ldw	r2,-12(fp)
 9089480:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 9089484:	e0bff917 	ldw	r2,-28(fp)
 9089488:	00c24274 	movhi	r3,2313
 908948c:	18f1a304 	addi	r3,r3,-14708
 9089490:	100490fa 	slli	r2,r2,3
 9089494:	10c5883a 	add	r2,r2,r3
 9089498:	10c00104 	addi	r3,r2,4
 908949c:	e0bffe17 	ldw	r2,-8(fp)
 90894a0:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 90894a4:	e0bffd17 	ldw	r2,-12(fp)
 90894a8:	1005003a 	cmpeq	r2,r2,zero
 90894ac:	1000051e 	bne	r2,zero,90894c4 <alt_iic_isr_register+0xb8>
 90894b0:	e17ff917 	ldw	r5,-28(fp)
 90894b4:	e13ffb17 	ldw	r4,-20(fp)
 90894b8:	90892880 	call	9089288 <alt_ic_irq_enable>
 90894bc:	e0bfff15 	stw	r2,-4(fp)
 90894c0:	00000406 	br	90894d4 <alt_iic_isr_register+0xc8>
 90894c4:	e17ff917 	ldw	r5,-28(fp)
 90894c8:	e13ffb17 	ldw	r4,-20(fp)
 90894cc:	90893240 	call	9089324 <alt_ic_irq_disable>
 90894d0:	e0bfff15 	stw	r2,-4(fp)
 90894d4:	e0bfff17 	ldw	r2,-4(fp)
 90894d8:	e0bffa15 	stw	r2,-24(fp)
 90894dc:	e0bff817 	ldw	r2,-32(fp)
 90894e0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90894e4:	e0bff617 	ldw	r2,-40(fp)
 90894e8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 90894ec:	e0bffa17 	ldw	r2,-24(fp)
}
 90894f0:	e037883a 	mov	sp,fp
 90894f4:	dfc00117 	ldw	ra,4(sp)
 90894f8:	df000017 	ldw	fp,0(sp)
 90894fc:	dec00204 	addi	sp,sp,8
 9089500:	f800283a 	ret

09089504 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 9089504:	defff904 	addi	sp,sp,-28
 9089508:	dfc00615 	stw	ra,24(sp)
 908950c:	df000515 	stw	fp,20(sp)
 9089510:	df000504 	addi	fp,sp,20
 9089514:	e13ffc15 	stw	r4,-16(fp)
 9089518:	e17ffd15 	stw	r5,-12(fp)
 908951c:	e1bffe15 	stw	r6,-8(fp)
 9089520:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 9089524:	e13ffd17 	ldw	r4,-12(fp)
 9089528:	e17ffe17 	ldw	r5,-8(fp)
 908952c:	e1bfff17 	ldw	r6,-4(fp)
 9089530:	9083dd00 	call	9083dd0 <open>
 9089534:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 9089538:	e0bffb17 	ldw	r2,-20(fp)
 908953c:	1004803a 	cmplt	r2,r2,zero
 9089540:	10001c1e 	bne	r2,zero,90895b4 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 9089544:	e0bffb17 	ldw	r2,-20(fp)
 9089548:	00c24274 	movhi	r3,2313
 908954c:	18ec6d04 	addi	r3,r3,-20044
 9089550:	10800324 	muli	r2,r2,12
 9089554:	10c5883a 	add	r2,r2,r3
 9089558:	10c00017 	ldw	r3,0(r2)
 908955c:	e0bffc17 	ldw	r2,-16(fp)
 9089560:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 9089564:	e0bffb17 	ldw	r2,-20(fp)
 9089568:	00c24274 	movhi	r3,2313
 908956c:	18ec6d04 	addi	r3,r3,-20044
 9089570:	10800324 	muli	r2,r2,12
 9089574:	10c5883a 	add	r2,r2,r3
 9089578:	10800104 	addi	r2,r2,4
 908957c:	10c00017 	ldw	r3,0(r2)
 9089580:	e0bffc17 	ldw	r2,-16(fp)
 9089584:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 9089588:	e0bffb17 	ldw	r2,-20(fp)
 908958c:	00c24274 	movhi	r3,2313
 9089590:	18ec6d04 	addi	r3,r3,-20044
 9089594:	10800324 	muli	r2,r2,12
 9089598:	10c5883a 	add	r2,r2,r3
 908959c:	10800204 	addi	r2,r2,8
 90895a0:	10c00017 	ldw	r3,0(r2)
 90895a4:	e0bffc17 	ldw	r2,-16(fp)
 90895a8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 90895ac:	e13ffb17 	ldw	r4,-20(fp)
 90895b0:	90841380 	call	9084138 <alt_release_fd>
  }
} 
 90895b4:	e037883a 	mov	sp,fp
 90895b8:	dfc00117 	ldw	ra,4(sp)
 90895bc:	df000017 	ldw	fp,0(sp)
 90895c0:	dec00204 	addi	sp,sp,8
 90895c4:	f800283a 	ret

090895c8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 90895c8:	defffb04 	addi	sp,sp,-20
 90895cc:	dfc00415 	stw	ra,16(sp)
 90895d0:	df000315 	stw	fp,12(sp)
 90895d4:	df000304 	addi	fp,sp,12
 90895d8:	e13ffd15 	stw	r4,-12(fp)
 90895dc:	e17ffe15 	stw	r5,-8(fp)
 90895e0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 90895e4:	01024274 	movhi	r4,2313
 90895e8:	212c7004 	addi	r4,r4,-20032
 90895ec:	e17ffd17 	ldw	r5,-12(fp)
 90895f0:	01800044 	movi	r6,1
 90895f4:	01c07fc4 	movi	r7,511
 90895f8:	90895040 	call	9089504 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 90895fc:	01024274 	movhi	r4,2313
 9089600:	212c6d04 	addi	r4,r4,-20044
 9089604:	e17ffe17 	ldw	r5,-8(fp)
 9089608:	000d883a 	mov	r6,zero
 908960c:	01c07fc4 	movi	r7,511
 9089610:	90895040 	call	9089504 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 9089614:	01024274 	movhi	r4,2313
 9089618:	212c7304 	addi	r4,r4,-20020
 908961c:	e17fff17 	ldw	r5,-4(fp)
 9089620:	01800044 	movi	r6,1
 9089624:	01c07fc4 	movi	r7,511
 9089628:	90895040 	call	9089504 <alt_open_fd>
}  
 908962c:	e037883a 	mov	sp,fp
 9089630:	dfc00117 	ldw	ra,4(sp)
 9089634:	df000017 	ldw	fp,0(sp)
 9089638:	dec00204 	addi	sp,sp,8
 908963c:	f800283a 	ret

09089640 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 9089640:	defffc04 	addi	sp,sp,-16
 9089644:	dfc00315 	stw	ra,12(sp)
 9089648:	df000215 	stw	fp,8(sp)
 908964c:	df000204 	addi	fp,sp,8
 9089650:	e13ffe15 	stw	r4,-8(fp)
 9089654:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 9089658:	e13ffe17 	ldw	r4,-8(fp)
 908965c:	e17fff17 	ldw	r5,-4(fp)
 9089660:	9088ca80 	call	9088ca8 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 9089664:	e0bffe17 	ldw	r2,-8(fp)
 9089668:	10a00034 	orhi	r2,r2,32768
}
 908966c:	e037883a 	mov	sp,fp
 9089670:	dfc00117 	ldw	ra,4(sp)
 9089674:	df000017 	ldw	fp,0(sp)
 9089678:	dec00204 	addi	sp,sp,8
 908967c:	f800283a 	ret

09089680 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 9089680:	defffa04 	addi	sp,sp,-24
 9089684:	df000515 	stw	fp,20(sp)
 9089688:	df000504 	addi	fp,sp,20
 908968c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9089690:	0005303a 	rdctl	r2,status
 9089694:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9089698:	e0fffd17 	ldw	r3,-12(fp)
 908969c:	00bfff84 	movi	r2,-2
 90896a0:	1884703a 	and	r2,r3,r2
 90896a4:	1001703a 	wrctl	status,r2
  
  return context;
 90896a8:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 90896ac:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 90896b0:	e0bfff17 	ldw	r2,-4(fp)
 90896b4:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 90896b8:	e0bffc17 	ldw	r2,-16(fp)
 90896bc:	10c00017 	ldw	r3,0(r2)
 90896c0:	e0bffc17 	ldw	r2,-16(fp)
 90896c4:	10800117 	ldw	r2,4(r2)
 90896c8:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 90896cc:	e0bffc17 	ldw	r2,-16(fp)
 90896d0:	10c00117 	ldw	r3,4(r2)
 90896d4:	e0bffc17 	ldw	r2,-16(fp)
 90896d8:	10800017 	ldw	r2,0(r2)
 90896dc:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 90896e0:	e0fffc17 	ldw	r3,-16(fp)
 90896e4:	e0bffc17 	ldw	r2,-16(fp)
 90896e8:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 90896ec:	e0fffc17 	ldw	r3,-16(fp)
 90896f0:	e0bffc17 	ldw	r2,-16(fp)
 90896f4:	18800015 	stw	r2,0(r3)
 90896f8:	e0bffe17 	ldw	r2,-8(fp)
 90896fc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9089700:	e0bffb17 	ldw	r2,-20(fp)
 9089704:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 9089708:	e037883a 	mov	sp,fp
 908970c:	df000017 	ldw	fp,0(sp)
 9089710:	dec00104 	addi	sp,sp,4
 9089714:	f800283a 	ret

09089718 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 9089718:	defffb04 	addi	sp,sp,-20
 908971c:	dfc00415 	stw	ra,16(sp)
 9089720:	df000315 	stw	fp,12(sp)
 9089724:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 9089728:	d0a01117 	ldw	r2,-32700(gp)
 908972c:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 9089730:	d0a01d17 	ldw	r2,-32652(gp)
 9089734:	10800044 	addi	r2,r2,1
 9089738:	d0a01d15 	stw	r2,-32652(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 908973c:	00003106 	br	9089804 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 9089740:	e0bffe17 	ldw	r2,-8(fp)
 9089744:	10800017 	ldw	r2,0(r2)
 9089748:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 908974c:	e0bffe17 	ldw	r2,-8(fp)
 9089750:	10800403 	ldbu	r2,16(r2)
 9089754:	10803fcc 	andi	r2,r2,255
 9089758:	1005003a 	cmpeq	r2,r2,zero
 908975c:	1000051e 	bne	r2,zero,9089774 <alt_tick+0x5c>
 9089760:	d0a01d17 	ldw	r2,-32652(gp)
 9089764:	1004c03a 	cmpne	r2,r2,zero
 9089768:	1000021e 	bne	r2,zero,9089774 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 908976c:	e0bffe17 	ldw	r2,-8(fp)
 9089770:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 9089774:	e0bffe17 	ldw	r2,-8(fp)
 9089778:	10c00217 	ldw	r3,8(r2)
 908977c:	d0a01d17 	ldw	r2,-32652(gp)
 9089780:	10c01e36 	bltu	r2,r3,90897fc <alt_tick+0xe4>
 9089784:	e0bffe17 	ldw	r2,-8(fp)
 9089788:	10800403 	ldbu	r2,16(r2)
 908978c:	10803fcc 	andi	r2,r2,255
 9089790:	1004c03a 	cmpne	r2,r2,zero
 9089794:	1000191e 	bne	r2,zero,90897fc <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 9089798:	e0bffe17 	ldw	r2,-8(fp)
 908979c:	10c00317 	ldw	r3,12(r2)
 90897a0:	e0bffe17 	ldw	r2,-8(fp)
 90897a4:	11000517 	ldw	r4,20(r2)
 90897a8:	183ee83a 	callr	r3
 90897ac:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 90897b0:	e0bffd17 	ldw	r2,-12(fp)
 90897b4:	1004c03a 	cmpne	r2,r2,zero
 90897b8:	1000031e 	bne	r2,zero,90897c8 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 90897bc:	e13ffe17 	ldw	r4,-8(fp)
 90897c0:	90896800 	call	9089680 <alt_alarm_stop>
 90897c4:	00000d06 	br	90897fc <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 90897c8:	e0bffe17 	ldw	r2,-8(fp)
 90897cc:	10c00217 	ldw	r3,8(r2)
 90897d0:	e0bffd17 	ldw	r2,-12(fp)
 90897d4:	1887883a 	add	r3,r3,r2
 90897d8:	e0bffe17 	ldw	r2,-8(fp)
 90897dc:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 90897e0:	e0bffe17 	ldw	r2,-8(fp)
 90897e4:	10c00217 	ldw	r3,8(r2)
 90897e8:	d0a01d17 	ldw	r2,-32652(gp)
 90897ec:	1880032e 	bgeu	r3,r2,90897fc <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 90897f0:	e0fffe17 	ldw	r3,-8(fp)
 90897f4:	00800044 	movi	r2,1
 90897f8:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 90897fc:	e0bfff17 	ldw	r2,-4(fp)
 9089800:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 9089804:	d0e01104 	addi	r3,gp,-32700
 9089808:	e0bffe17 	ldw	r2,-8(fp)
 908980c:	10ffcc1e 	bne	r2,r3,9089740 <alt_tick+0x28>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 9089810:	e037883a 	mov	sp,fp
 9089814:	dfc00117 	ldw	ra,4(sp)
 9089818:	df000017 	ldw	fp,0(sp)
 908981c:	dec00204 	addi	sp,sp,8
 9089820:	f800283a 	ret

09089824 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 9089824:	defffd04 	addi	sp,sp,-12
 9089828:	dfc00215 	stw	ra,8(sp)
 908982c:	df000115 	stw	fp,4(sp)
 9089830:	df000104 	addi	fp,sp,4
 9089834:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 9089838:	e13fff17 	ldw	r4,-4(fp)
 908983c:	908a1340 	call	908a134 <alt_busy_sleep>
}
 9089840:	e037883a 	mov	sp,fp
 9089844:	dfc00117 	ldw	ra,4(sp)
 9089848:	df000017 	ldw	fp,0(sp)
 908984c:	dec00204 	addi	sp,sp,8
 9089850:	f800283a 	ret

09089854 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 9089854:	deffff04 	addi	sp,sp,-4
 9089858:	df000015 	stw	fp,0(sp)
 908985c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 9089860:	000170fa 	wrctl	ienable,zero
}
 9089864:	e037883a 	mov	sp,fp
 9089868:	df000017 	ldw	fp,0(sp)
 908986c:	dec00104 	addi	sp,sp,4
 9089870:	f800283a 	ret

09089874 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 9089874:	defff704 	addi	sp,sp,-36
 9089878:	dfc00815 	stw	ra,32(sp)
 908987c:	df000715 	stw	fp,28(sp)
 9089880:	df000704 	addi	fp,sp,28
 9089884:	e13ffc15 	stw	r4,-16(fp)
 9089888:	e17ffd15 	stw	r5,-12(fp)
 908988c:	e1bffe15 	stw	r6,-8(fp)
 9089890:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 9089894:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9089898:	e0bffc17 	ldw	r2,-16(fp)
 908989c:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 90898a0:	e1bfff17 	ldw	r6,-4(fp)
 90898a4:	00824274 	movhi	r2,2313
 90898a8:	10a70604 	addi	r2,r2,-25576
 90898ac:	d8800015 	stw	r2,0(sp)
 90898b0:	e13ffa17 	ldw	r4,-24(fp)
 90898b4:	e17ffe17 	ldw	r5,-8(fp)
 90898b8:	e1c00217 	ldw	r7,8(fp)
 90898bc:	9084ae40 	call	9084ae4 <alt_flash_program_block>
 90898c0:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 90898c4:	e0bffb17 	ldw	r2,-20(fp)
}
 90898c8:	e037883a 	mov	sp,fp
 90898cc:	dfc00117 	ldw	ra,4(sp)
 90898d0:	df000017 	ldw	fp,0(sp)
 90898d4:	dec00204 	addi	sp,sp,8
 90898d8:	f800283a 	ret

090898dc <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 90898dc:	defff804 	addi	sp,sp,-32
 90898e0:	dfc00715 	stw	ra,28(sp)
 90898e4:	df000615 	stw	fp,24(sp)
 90898e8:	df000604 	addi	fp,sp,24
 90898ec:	e13ffe15 	stw	r4,-8(fp)
 90898f0:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 90898f4:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90898f8:	e0bffe17 	ldw	r2,-8(fp)
 90898fc:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 9089900:	e0bffa17 	ldw	r2,-24(fp)
 9089904:	10c03317 	ldw	r3,204(r2)
 9089908:	e0bffa17 	ldw	r2,-24(fp)
 908990c:	11000a17 	ldw	r4,40(r2)
 9089910:	01415544 	movi	r5,1365
 9089914:	01802a84 	movi	r6,170
 9089918:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 908991c:	e0bffa17 	ldw	r2,-24(fp)
 9089920:	10c03317 	ldw	r3,204(r2)
 9089924:	e0bffa17 	ldw	r2,-24(fp)
 9089928:	11000a17 	ldw	r4,40(r2)
 908992c:	0140aa84 	movi	r5,682
 9089930:	01801544 	movi	r6,85
 9089934:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 9089938:	e0bffa17 	ldw	r2,-24(fp)
 908993c:	10c03317 	ldw	r3,204(r2)
 9089940:	e0bffa17 	ldw	r2,-24(fp)
 9089944:	11000a17 	ldw	r4,40(r2)
 9089948:	01415544 	movi	r5,1365
 908994c:	01802004 	movi	r6,128
 9089950:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 9089954:	e0bffa17 	ldw	r2,-24(fp)
 9089958:	10c03317 	ldw	r3,204(r2)
 908995c:	e0bffa17 	ldw	r2,-24(fp)
 9089960:	11000a17 	ldw	r4,40(r2)
 9089964:	01415544 	movi	r5,1365
 9089968:	01802a84 	movi	r6,170
 908996c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 9089970:	e0bffa17 	ldw	r2,-24(fp)
 9089974:	10c03317 	ldw	r3,204(r2)
 9089978:	e0bffa17 	ldw	r2,-24(fp)
 908997c:	11000a17 	ldw	r4,40(r2)
 9089980:	0140aa84 	movi	r5,682
 9089984:	01801544 	movi	r6,85
 9089988:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 908998c:	e0bffa17 	ldw	r2,-24(fp)
 9089990:	11803517 	ldw	r6,212(r2)
 9089994:	e0bffa17 	ldw	r2,-24(fp)
 9089998:	10800a17 	ldw	r2,40(r2)
 908999c:	1007883a 	mov	r3,r2
 90899a0:	e0bfff17 	ldw	r2,-4(fp)
 90899a4:	1889883a 	add	r4,r3,r2
 90899a8:	01400c04 	movi	r5,48
 90899ac:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 90899b0:	0109c404 	movi	r4,10000
 90899b4:	90898240 	call	9089824 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 90899b8:	00800c84 	movi	r2,50
 90899bc:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90899c0:	e0bffa17 	ldw	r2,-24(fp)
 90899c4:	10800a17 	ldw	r2,40(r2)
 90899c8:	1007883a 	mov	r3,r2
 90899cc:	e0bfff17 	ldw	r2,-4(fp)
 90899d0:	1885883a 	add	r2,r3,r2
 90899d4:	10800023 	ldbuio	r2,0(r2)
 90899d8:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 90899dc:	0100fa04 	movi	r4,1000
 90899e0:	90898240 	call	9089824 <usleep>
    timeout--;
 90899e4:	e0bffb17 	ldw	r2,-20(fp)
 90899e8:	10bfffc4 	addi	r2,r2,-1
 90899ec:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 90899f0:	e0bffd03 	ldbu	r2,-12(fp)
 90899f4:	10803fcc 	andi	r2,r2,255
 90899f8:	1080020c 	andi	r2,r2,8
 90899fc:	1004c03a 	cmpne	r2,r2,zero
 9089a00:	1000031e 	bne	r2,zero,9089a10 <alt_erase_block_amd+0x134>
 9089a04:	e0bffb17 	ldw	r2,-20(fp)
 9089a08:	10800048 	cmpgei	r2,r2,1
 9089a0c:	103fec1e 	bne	r2,zero,90899c0 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 9089a10:	e0bffa17 	ldw	r2,-24(fp)
 9089a14:	10803117 	ldw	r2,196(r2)
 9089a18:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 9089a1c:	00001706 	br	9089a7c <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 9089a20:	e0bffa17 	ldw	r2,-24(fp)
 9089a24:	10800a17 	ldw	r2,40(r2)
 9089a28:	1007883a 	mov	r3,r2
 9089a2c:	e0bfff17 	ldw	r2,-4(fp)
 9089a30:	1885883a 	add	r2,r3,r2
 9089a34:	10800023 	ldbuio	r2,0(r2)
 9089a38:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 9089a3c:	e0bffd03 	ldbu	r2,-12(fp)
 9089a40:	10803fcc 	andi	r2,r2,255
 9089a44:	1080201c 	xori	r2,r2,128
 9089a48:	10bfe004 	addi	r2,r2,-128
 9089a4c:	1004803a 	cmplt	r2,r2,zero
 9089a50:	10000d1e 	bne	r2,zero,9089a88 <alt_erase_block_amd+0x1ac>
 9089a54:	e0bffd03 	ldbu	r2,-12(fp)
 9089a58:	10803fcc 	andi	r2,r2,255
 9089a5c:	1080080c 	andi	r2,r2,32
 9089a60:	1004c03a 	cmpne	r2,r2,zero
 9089a64:	1000081e 	bne	r2,zero,9089a88 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 9089a68:	0100fa04 	movi	r4,1000
 9089a6c:	90898240 	call	9089824 <usleep>
    timeout -= 1000;
 9089a70:	e0bffb17 	ldw	r2,-20(fp)
 9089a74:	10bf0604 	addi	r2,r2,-1000
 9089a78:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 9089a7c:	e0bffb17 	ldw	r2,-20(fp)
 9089a80:	10800048 	cmpgei	r2,r2,1
 9089a84:	103fe61e 	bne	r2,zero,9089a20 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 9089a88:	e0bffb17 	ldw	r2,-20(fp)
 9089a8c:	10800048 	cmpgei	r2,r2,1
 9089a90:	1000031e 	bne	r2,zero,9089aa0 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 9089a94:	00bfe304 	movi	r2,-116
 9089a98:	e0bffc15 	stw	r2,-16(fp)
 9089a9c:	00000f06 	br	9089adc <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 9089aa0:	e0bffa17 	ldw	r2,-24(fp)
 9089aa4:	10800a17 	ldw	r2,40(r2)
 9089aa8:	1007883a 	mov	r3,r2
 9089aac:	e0bfff17 	ldw	r2,-4(fp)
 9089ab0:	1885883a 	add	r2,r3,r2
 9089ab4:	10800023 	ldbuio	r2,0(r2)
 9089ab8:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 9089abc:	e0bffd03 	ldbu	r2,-12(fp)
 9089ac0:	10803fcc 	andi	r2,r2,255
 9089ac4:	1080201c 	xori	r2,r2,128
 9089ac8:	10bfe004 	addi	r2,r2,-128
 9089acc:	1004803a 	cmplt	r2,r2,zero
 9089ad0:	1000021e 	bne	r2,zero,9089adc <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 9089ad4:	00bffec4 	movi	r2,-5
 9089ad8:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 9089adc:	e0bffc17 	ldw	r2,-16(fp)
}
 9089ae0:	e037883a 	mov	sp,fp
 9089ae4:	dfc00117 	ldw	ra,4(sp)
 9089ae8:	df000017 	ldw	fp,0(sp)
 9089aec:	dec00204 	addi	sp,sp,8
 9089af0:	f800283a 	ret

09089af4 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 9089af4:	defff804 	addi	sp,sp,-32
 9089af8:	dfc00715 	stw	ra,28(sp)
 9089afc:	df000615 	stw	fp,24(sp)
 9089b00:	df000604 	addi	fp,sp,24
 9089b04:	e13ffd15 	stw	r4,-12(fp)
 9089b08:	e17ffe15 	stw	r5,-8(fp)
 9089b0c:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 9089b10:	e0bffd17 	ldw	r2,-12(fp)
 9089b14:	10803017 	ldw	r2,192(r2)
 9089b18:	10801924 	muli	r2,r2,100
 9089b1c:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 9089b20:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 9089b24:	e0bffd17 	ldw	r2,-12(fp)
 9089b28:	10800a17 	ldw	r2,40(r2)
 9089b2c:	1007883a 	mov	r3,r2
 9089b30:	e0bffe17 	ldw	r2,-8(fp)
 9089b34:	1885883a 	add	r2,r3,r2
 9089b38:	10800023 	ldbuio	r2,0(r2)
 9089b3c:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 9089b40:	00001706 	br	9089ba0 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 9089b44:	e0bffc03 	ldbu	r2,-16(fp)
 9089b48:	10803fcc 	andi	r2,r2,255
 9089b4c:	10c0200c 	andi	r3,r2,128
 9089b50:	e0bfff03 	ldbu	r2,-4(fp)
 9089b54:	1080200c 	andi	r2,r2,128
 9089b58:	18801426 	beq	r3,r2,9089bac <alt_wait_for_command_to_complete_amd+0xb8>
 9089b5c:	e0bffc03 	ldbu	r2,-16(fp)
 9089b60:	10803fcc 	andi	r2,r2,255
 9089b64:	1080080c 	andi	r2,r2,32
 9089b68:	1004c03a 	cmpne	r2,r2,zero
 9089b6c:	10000f1e 	bne	r2,zero,9089bac <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 9089b70:	01000044 	movi	r4,1
 9089b74:	90898240 	call	9089824 <usleep>
    timeout--;
 9089b78:	e0bffb17 	ldw	r2,-20(fp)
 9089b7c:	10bfffc4 	addi	r2,r2,-1
 9089b80:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 9089b84:	e0bffd17 	ldw	r2,-12(fp)
 9089b88:	10800a17 	ldw	r2,40(r2)
 9089b8c:	1007883a 	mov	r3,r2
 9089b90:	e0bffe17 	ldw	r2,-8(fp)
 9089b94:	1885883a 	add	r2,r3,r2
 9089b98:	10800023 	ldbuio	r2,0(r2)
 9089b9c:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 9089ba0:	e0bffb17 	ldw	r2,-20(fp)
 9089ba4:	10800048 	cmpgei	r2,r2,1
 9089ba8:	103fe61e 	bne	r2,zero,9089b44 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 9089bac:	e0bffb17 	ldw	r2,-20(fp)
 9089bb0:	1004c03a 	cmpne	r2,r2,zero
 9089bb4:	1000031e 	bne	r2,zero,9089bc4 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 9089bb8:	00bfe304 	movi	r2,-116
 9089bbc:	e0bffa15 	stw	r2,-24(fp)
 9089bc0:	00000f06 	br	9089c00 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 9089bc4:	e0bffd17 	ldw	r2,-12(fp)
 9089bc8:	10800a17 	ldw	r2,40(r2)
 9089bcc:	1007883a 	mov	r3,r2
 9089bd0:	e0bffe17 	ldw	r2,-8(fp)
 9089bd4:	1885883a 	add	r2,r3,r2
 9089bd8:	10800023 	ldbuio	r2,0(r2)
 9089bdc:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 9089be0:	e0bffc03 	ldbu	r2,-16(fp)
 9089be4:	10803fcc 	andi	r2,r2,255
 9089be8:	10c0200c 	andi	r3,r2,128
 9089bec:	e0bfff03 	ldbu	r2,-4(fp)
 9089bf0:	1080200c 	andi	r2,r2,128
 9089bf4:	18800226 	beq	r3,r2,9089c00 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 9089bf8:	00bffec4 	movi	r2,-5
 9089bfc:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 9089c00:	e0bffa17 	ldw	r2,-24(fp)
}
 9089c04:	e037883a 	mov	sp,fp
 9089c08:	dfc00117 	ldw	ra,4(sp)
 9089c0c:	df000017 	ldw	fp,0(sp)
 9089c10:	dec00204 	addi	sp,sp,8
 9089c14:	f800283a 	ret

09089c18 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 9089c18:	defff904 	addi	sp,sp,-28
 9089c1c:	dfc00615 	stw	ra,24(sp)
 9089c20:	df000515 	stw	fp,20(sp)
 9089c24:	df000504 	addi	fp,sp,20
 9089c28:	e13ffd15 	stw	r4,-12(fp)
 9089c2c:	e17ffe15 	stw	r5,-8(fp)
 9089c30:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 9089c34:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 9089c38:	e0bffd17 	ldw	r2,-12(fp)
 9089c3c:	10c03317 	ldw	r3,204(r2)
 9089c40:	e0bffd17 	ldw	r2,-12(fp)
 9089c44:	11000a17 	ldw	r4,40(r2)
 9089c48:	01415544 	movi	r5,1365
 9089c4c:	01802a84 	movi	r6,170
 9089c50:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 9089c54:	e0bffd17 	ldw	r2,-12(fp)
 9089c58:	10c03317 	ldw	r3,204(r2)
 9089c5c:	e0bffd17 	ldw	r2,-12(fp)
 9089c60:	11000a17 	ldw	r4,40(r2)
 9089c64:	0140aa84 	movi	r5,682
 9089c68:	01801544 	movi	r6,85
 9089c6c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 9089c70:	e0bffd17 	ldw	r2,-12(fp)
 9089c74:	10c03317 	ldw	r3,204(r2)
 9089c78:	e0bffd17 	ldw	r2,-12(fp)
 9089c7c:	11000a17 	ldw	r4,40(r2)
 9089c80:	01415544 	movi	r5,1365
 9089c84:	01802804 	movi	r6,160
 9089c88:	183ee83a 	callr	r3
  
  value = *src_addr;
 9089c8c:	e0bfff17 	ldw	r2,-4(fp)
 9089c90:	10800003 	ldbu	r2,0(r2)
 9089c94:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 9089c98:	e13ffd17 	ldw	r4,-12(fp)
 9089c9c:	e17ffe17 	ldw	r5,-8(fp)
 9089ca0:	e1bfff17 	ldw	r6,-4(fp)
 9089ca4:	90849800 	call	9084980 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 9089ca8:	e1bffb03 	ldbu	r6,-20(fp)
 9089cac:	e13ffd17 	ldw	r4,-12(fp)
 9089cb0:	e17ffe17 	ldw	r5,-8(fp)
 9089cb4:	9089af40 	call	9089af4 <alt_wait_for_command_to_complete_amd>
 9089cb8:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 9089cbc:	e0bffc17 	ldw	r2,-16(fp)
  
}
 9089cc0:	e037883a 	mov	sp,fp
 9089cc4:	dfc00117 	ldw	ra,4(sp)
 9089cc8:	df000017 	ldw	fp,0(sp)
 9089ccc:	dec00204 	addi	sp,sp,8
 9089cd0:	f800283a 	ret

09089cd4 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 9089cd4:	defff704 	addi	sp,sp,-36
 9089cd8:	dfc00815 	stw	ra,32(sp)
 9089cdc:	df000715 	stw	fp,28(sp)
 9089ce0:	df000704 	addi	fp,sp,28
 9089ce4:	e13ffc15 	stw	r4,-16(fp)
 9089ce8:	e17ffd15 	stw	r5,-12(fp)
 9089cec:	e1bffe15 	stw	r6,-8(fp)
 9089cf0:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 9089cf4:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9089cf8:	e0bffc17 	ldw	r2,-16(fp)
 9089cfc:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 9089d00:	e13ffa17 	ldw	r4,-24(fp)
 9089d04:	e17ffd17 	ldw	r5,-12(fp)
 9089d08:	9089ecc0 	call	9089ecc <alt_unlock_block_intel>
 9089d0c:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 9089d10:	e0bffb17 	ldw	r2,-20(fp)
 9089d14:	1004c03a 	cmpne	r2,r2,zero
 9089d18:	1000091e 	bne	r2,zero,9089d40 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 9089d1c:	e1bfff17 	ldw	r6,-4(fp)
 9089d20:	00824274 	movhi	r2,2313
 9089d24:	10a81604 	addi	r2,r2,-24488
 9089d28:	d8800015 	stw	r2,0(sp)
 9089d2c:	e13ffa17 	ldw	r4,-24(fp)
 9089d30:	e17ffe17 	ldw	r5,-8(fp)
 9089d34:	e1c00217 	ldw	r7,8(fp)
 9089d38:	9084ae40 	call	9084ae4 <alt_flash_program_block>
 9089d3c:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 9089d40:	e0bffb17 	ldw	r2,-20(fp)
}
 9089d44:	e037883a 	mov	sp,fp
 9089d48:	dfc00117 	ldw	ra,4(sp)
 9089d4c:	df000017 	ldw	fp,0(sp)
 9089d50:	dec00204 	addi	sp,sp,8
 9089d54:	f800283a 	ret

09089d58 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 9089d58:	defff804 	addi	sp,sp,-32
 9089d5c:	dfc00715 	stw	ra,28(sp)
 9089d60:	df000615 	stw	fp,24(sp)
 9089d64:	df000604 	addi	fp,sp,24
 9089d68:	e13ffe15 	stw	r4,-8(fp)
 9089d6c:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 9089d70:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9089d74:	e0bffe17 	ldw	r2,-8(fp)
 9089d78:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 9089d7c:	e0bffb17 	ldw	r2,-20(fp)
 9089d80:	10803117 	ldw	r2,196(r2)
 9089d84:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 9089d88:	e13ffb17 	ldw	r4,-20(fp)
 9089d8c:	e17fff17 	ldw	r5,-4(fp)
 9089d90:	9089ecc0 	call	9089ecc <alt_unlock_block_intel>
 9089d94:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 9089d98:	e0bffc17 	ldw	r2,-16(fp)
 9089d9c:	1004c03a 	cmpne	r2,r2,zero
 9089da0:	1000441e 	bne	r2,zero,9089eb4 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 9089da4:	e0bffb17 	ldw	r2,-20(fp)
 9089da8:	11803517 	ldw	r6,212(r2)
 9089dac:	e0bffb17 	ldw	r2,-20(fp)
 9089db0:	10800a17 	ldw	r2,40(r2)
 9089db4:	1007883a 	mov	r3,r2
 9089db8:	e0bfff17 	ldw	r2,-4(fp)
 9089dbc:	1889883a 	add	r4,r3,r2
 9089dc0:	01400804 	movi	r5,32
 9089dc4:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 9089dc8:	e0bffb17 	ldw	r2,-20(fp)
 9089dcc:	11803517 	ldw	r6,212(r2)
 9089dd0:	e0bffb17 	ldw	r2,-20(fp)
 9089dd4:	10800a17 	ldw	r2,40(r2)
 9089dd8:	1007883a 	mov	r3,r2
 9089ddc:	e0bfff17 	ldw	r2,-4(fp)
 9089de0:	1889883a 	add	r4,r3,r2
 9089de4:	01403404 	movi	r5,208
 9089de8:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 9089dec:	e0bffb17 	ldw	r2,-20(fp)
 9089df0:	10800a17 	ldw	r2,40(r2)
 9089df4:	1007883a 	mov	r3,r2
 9089df8:	e0bfff17 	ldw	r2,-4(fp)
 9089dfc:	1885883a 	add	r2,r3,r2
 9089e00:	10800023 	ldbuio	r2,0(r2)
 9089e04:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 9089e08:	e0bffd03 	ldbu	r2,-12(fp)
 9089e0c:	10803fcc 	andi	r2,r2,255
 9089e10:	1080201c 	xori	r2,r2,128
 9089e14:	10bfe004 	addi	r2,r2,-128
 9089e18:	1004803a 	cmplt	r2,r2,zero
 9089e1c:	1000081e 	bne	r2,zero,9089e40 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 9089e20:	0100fa04 	movi	r4,1000
 9089e24:	90898240 	call	9089824 <usleep>
      timeout -= 1000;
 9089e28:	e0bffa17 	ldw	r2,-24(fp)
 9089e2c:	10bf0604 	addi	r2,r2,-1000
 9089e30:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 9089e34:	e0bffa17 	ldw	r2,-24(fp)
 9089e38:	10800048 	cmpgei	r2,r2,1
 9089e3c:	103feb1e 	bne	r2,zero,9089dec <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 9089e40:	e0bffa17 	ldw	r2,-24(fp)
 9089e44:	10800048 	cmpgei	r2,r2,1
 9089e48:	1000031e 	bne	r2,zero,9089e58 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 9089e4c:	00bfe304 	movi	r2,-116
 9089e50:	e0bffc15 	stw	r2,-16(fp)
 9089e54:	00000e06 	br	9089e90 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 9089e58:	e0bffd03 	ldbu	r2,-12(fp)
 9089e5c:	10803fcc 	andi	r2,r2,255
 9089e60:	10801fcc 	andi	r2,r2,127
 9089e64:	1005003a 	cmpeq	r2,r2,zero
 9089e68:	1000091e 	bne	r2,zero,9089e90 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 9089e6c:	00bffec4 	movi	r2,-5
 9089e70:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 9089e74:	e0bffb17 	ldw	r2,-20(fp)
 9089e78:	10800a17 	ldw	r2,40(r2)
 9089e7c:	1007883a 	mov	r3,r2
 9089e80:	e0bfff17 	ldw	r2,-4(fp)
 9089e84:	1885883a 	add	r2,r3,r2
 9089e88:	10800023 	ldbuio	r2,0(r2)
 9089e8c:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 9089e90:	e0bffb17 	ldw	r2,-20(fp)
 9089e94:	11803517 	ldw	r6,212(r2)
 9089e98:	e0bffb17 	ldw	r2,-20(fp)
 9089e9c:	10800a17 	ldw	r2,40(r2)
 9089ea0:	1007883a 	mov	r3,r2
 9089ea4:	e0bfff17 	ldw	r2,-4(fp)
 9089ea8:	1889883a 	add	r4,r3,r2
 9089eac:	01403fc4 	movi	r5,255
 9089eb0:	303ee83a 	callr	r6
  }
  
  return ret_code;
 9089eb4:	e0bffc17 	ldw	r2,-16(fp)
}
 9089eb8:	e037883a 	mov	sp,fp
 9089ebc:	dfc00117 	ldw	ra,4(sp)
 9089ec0:	df000017 	ldw	fp,0(sp)
 9089ec4:	dec00204 	addi	sp,sp,8
 9089ec8:	f800283a 	ret

09089ecc <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 9089ecc:	defff904 	addi	sp,sp,-28
 9089ed0:	dfc00615 	stw	ra,24(sp)
 9089ed4:	df000515 	stw	fp,20(sp)
 9089ed8:	df000504 	addi	fp,sp,20
 9089edc:	e13ffe15 	stw	r4,-8(fp)
 9089ee0:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 9089ee4:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 9089ee8:	e0bffe17 	ldw	r2,-8(fp)
 9089eec:	10803017 	ldw	r2,192(r2)
 9089ef0:	10801924 	muli	r2,r2,100
 9089ef4:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 9089ef8:	e0bffe17 	ldw	r2,-8(fp)
 9089efc:	11803517 	ldw	r6,212(r2)
 9089f00:	e0bffe17 	ldw	r2,-8(fp)
 9089f04:	10800a17 	ldw	r2,40(r2)
 9089f08:	1007883a 	mov	r3,r2
 9089f0c:	e0bfff17 	ldw	r2,-4(fp)
 9089f10:	1889883a 	add	r4,r3,r2
 9089f14:	01402404 	movi	r5,144
 9089f18:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 9089f1c:	e0bffe17 	ldw	r2,-8(fp)
 9089f20:	10800a17 	ldw	r2,40(r2)
 9089f24:	1007883a 	mov	r3,r2
 9089f28:	e0bfff17 	ldw	r2,-4(fp)
 9089f2c:	1885883a 	add	r2,r3,r2
 9089f30:	10800104 	addi	r2,r2,4
 9089f34:	10800023 	ldbuio	r2,0(r2)
 9089f38:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 9089f3c:	e0bffd43 	ldbu	r2,-11(fp)
 9089f40:	1080004c 	andi	r2,r2,1
 9089f44:	10803fcc 	andi	r2,r2,255
 9089f48:	1005003a 	cmpeq	r2,r2,zero
 9089f4c:	1000331e 	bne	r2,zero,908a01c <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 9089f50:	e0bffe17 	ldw	r2,-8(fp)
 9089f54:	11803517 	ldw	r6,212(r2)
 9089f58:	e0bffe17 	ldw	r2,-8(fp)
 9089f5c:	10800a17 	ldw	r2,40(r2)
 9089f60:	1007883a 	mov	r3,r2
 9089f64:	e0bfff17 	ldw	r2,-4(fp)
 9089f68:	1889883a 	add	r4,r3,r2
 9089f6c:	01401804 	movi	r5,96
 9089f70:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 9089f74:	e0bffe17 	ldw	r2,-8(fp)
 9089f78:	11803517 	ldw	r6,212(r2)
 9089f7c:	e0bffe17 	ldw	r2,-8(fp)
 9089f80:	10800a17 	ldw	r2,40(r2)
 9089f84:	1007883a 	mov	r3,r2
 9089f88:	e0bfff17 	ldw	r2,-4(fp)
 9089f8c:	1889883a 	add	r4,r3,r2
 9089f90:	01403404 	movi	r5,208
 9089f94:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 9089f98:	e0bffe17 	ldw	r2,-8(fp)
 9089f9c:	10800a17 	ldw	r2,40(r2)
 9089fa0:	1007883a 	mov	r3,r2
 9089fa4:	e0bfff17 	ldw	r2,-4(fp)
 9089fa8:	1885883a 	add	r2,r3,r2
 9089fac:	10800023 	ldbuio	r2,0(r2)
 9089fb0:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 9089fb4:	e0bffd03 	ldbu	r2,-12(fp)
 9089fb8:	10803fcc 	andi	r2,r2,255
 9089fbc:	1080201c 	xori	r2,r2,128
 9089fc0:	10bfe004 	addi	r2,r2,-128
 9089fc4:	1004803a 	cmplt	r2,r2,zero
 9089fc8:	1000081e 	bne	r2,zero,9089fec <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 9089fcc:	e0bffb17 	ldw	r2,-20(fp)
 9089fd0:	10bfffc4 	addi	r2,r2,-1
 9089fd4:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 9089fd8:	01000044 	movi	r4,1
 9089fdc:	90898240 	call	9089824 <usleep>
    }while(timeout > 0);
 9089fe0:	e0bffb17 	ldw	r2,-20(fp)
 9089fe4:	10800048 	cmpgei	r2,r2,1
 9089fe8:	103feb1e 	bne	r2,zero,9089f98 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 9089fec:	e0bffb17 	ldw	r2,-20(fp)
 9089ff0:	1004c03a 	cmpne	r2,r2,zero
 9089ff4:	1000031e 	bne	r2,zero,908a004 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 9089ff8:	00bfe304 	movi	r2,-116
 9089ffc:	e0bffc15 	stw	r2,-16(fp)
 908a000:	00000606 	br	908a01c <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 908a004:	e0bffd03 	ldbu	r2,-12(fp)
 908a008:	10801fcc 	andi	r2,r2,127
 908a00c:	1005003a 	cmpeq	r2,r2,zero
 908a010:	1000021e 	bne	r2,zero,908a01c <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 908a014:	00bffec4 	movi	r2,-5
 908a018:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 908a01c:	e0bffe17 	ldw	r2,-8(fp)
 908a020:	11803517 	ldw	r6,212(r2)
 908a024:	e0bffe17 	ldw	r2,-8(fp)
 908a028:	10800a17 	ldw	r2,40(r2)
 908a02c:	1007883a 	mov	r3,r2
 908a030:	e0bfff17 	ldw	r2,-4(fp)
 908a034:	1889883a 	add	r4,r3,r2
 908a038:	01403fc4 	movi	r5,255
 908a03c:	303ee83a 	callr	r6

  return ret_code;
 908a040:	e0bffc17 	ldw	r2,-16(fp)
}
 908a044:	e037883a 	mov	sp,fp
 908a048:	dfc00117 	ldw	ra,4(sp)
 908a04c:	df000017 	ldw	fp,0(sp)
 908a050:	dec00204 	addi	sp,sp,8
 908a054:	f800283a 	ret

0908a058 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 908a058:	defff904 	addi	sp,sp,-28
 908a05c:	dfc00615 	stw	ra,24(sp)
 908a060:	df000515 	stw	fp,20(sp)
 908a064:	df000504 	addi	fp,sp,20
 908a068:	e13ffd15 	stw	r4,-12(fp)
 908a06c:	e17ffe15 	stw	r5,-8(fp)
 908a070:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 908a074:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 908a078:	e0bffd17 	ldw	r2,-12(fp)
 908a07c:	11803517 	ldw	r6,212(r2)
 908a080:	e0bffd17 	ldw	r2,-12(fp)
 908a084:	10800a17 	ldw	r2,40(r2)
 908a088:	1007883a 	mov	r3,r2
 908a08c:	e0bffe17 	ldw	r2,-8(fp)
 908a090:	1889883a 	add	r4,r3,r2
 908a094:	01401004 	movi	r5,64
 908a098:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 908a09c:	e13ffd17 	ldw	r4,-12(fp)
 908a0a0:	e17ffe17 	ldw	r5,-8(fp)
 908a0a4:	e1bfff17 	ldw	r6,-4(fp)
 908a0a8:	90849800 	call	9084980 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 908a0ac:	e0bffd17 	ldw	r2,-12(fp)
 908a0b0:	10800a17 	ldw	r2,40(r2)
 908a0b4:	1007883a 	mov	r3,r2
 908a0b8:	e0bffe17 	ldw	r2,-8(fp)
 908a0bc:	1885883a 	add	r2,r3,r2
 908a0c0:	10800023 	ldbuio	r2,0(r2)
 908a0c4:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 908a0c8:	e0bffb03 	ldbu	r2,-20(fp)
 908a0cc:	10803fcc 	andi	r2,r2,255
 908a0d0:	1080201c 	xori	r2,r2,128
 908a0d4:	10bfe004 	addi	r2,r2,-128
 908a0d8:	1004403a 	cmpge	r2,r2,zero
 908a0dc:	103ff31e 	bne	r2,zero,908a0ac <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 908a0e0:	e0bffb03 	ldbu	r2,-20(fp)
 908a0e4:	10801fcc 	andi	r2,r2,127
 908a0e8:	1005003a 	cmpeq	r2,r2,zero
 908a0ec:	1000021e 	bne	r2,zero,908a0f8 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 908a0f0:	00bffec4 	movi	r2,-5
 908a0f4:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 908a0f8:	e0bffd17 	ldw	r2,-12(fp)
 908a0fc:	11803517 	ldw	r6,212(r2)
 908a100:	e0bffd17 	ldw	r2,-12(fp)
 908a104:	10800a17 	ldw	r2,40(r2)
 908a108:	1007883a 	mov	r3,r2
 908a10c:	e0bffe17 	ldw	r2,-8(fp)
 908a110:	1889883a 	add	r4,r3,r2
 908a114:	01403fc4 	movi	r5,255
 908a118:	303ee83a 	callr	r6
  
  return ret_code;
 908a11c:	e0bffc17 	ldw	r2,-16(fp)
}
 908a120:	e037883a 	mov	sp,fp
 908a124:	dfc00117 	ldw	ra,4(sp)
 908a128:	df000017 	ldw	fp,0(sp)
 908a12c:	dec00204 	addi	sp,sp,8
 908a130:	f800283a 	ret

0908a134 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 908a134:	defffb04 	addi	sp,sp,-20
 908a138:	df000415 	stw	fp,16(sp)
 908a13c:	df000404 	addi	fp,sp,16
 908a140:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 908a144:	008000c4 	movi	r2,3
 908a148:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 908a14c:	e0fffc17 	ldw	r3,-16(fp)
 908a150:	008003f4 	movhi	r2,15
 908a154:	10909004 	addi	r2,r2,16960
 908a158:	1887383a 	mul	r3,r3,r2
 908a15c:	00817db4 	movhi	r2,1526
 908a160:	10b84004 	addi	r2,r2,-7936
 908a164:	10c7203a 	divu	r3,r2,r3
 908a168:	00a00034 	movhi	r2,32768
 908a16c:	10bfffc4 	addi	r2,r2,-1
 908a170:	10c7203a 	divu	r3,r2,r3
 908a174:	e0bfff17 	ldw	r2,-4(fp)
 908a178:	10c5203a 	divu	r2,r2,r3
 908a17c:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 908a180:	e0bffd17 	ldw	r2,-12(fp)
 908a184:	1005003a 	cmpeq	r2,r2,zero
 908a188:	1000251e 	bne	r2,zero,908a220 <alt_busy_sleep+0xec>
  {
    for(i=0;i<big_loops;i++)
 908a18c:	e03ffe15 	stw	zero,-8(fp)
 908a190:	00001406 	br	908a1e4 <alt_busy_sleep+0xb0>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 908a194:	00a00034 	movhi	r2,32768
 908a198:	10bfffc4 	addi	r2,r2,-1
 908a19c:	10bfffc4 	addi	r2,r2,-1
 908a1a0:	103ffe1e 	bne	r2,zero,908a19c <alt_busy_sleep+0x68>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 908a1a4:	e0fffc17 	ldw	r3,-16(fp)
 908a1a8:	008003f4 	movhi	r2,15
 908a1ac:	10909004 	addi	r2,r2,16960
 908a1b0:	1887383a 	mul	r3,r3,r2
 908a1b4:	00817db4 	movhi	r2,1526
 908a1b8:	10b84004 	addi	r2,r2,-7936
 908a1bc:	10c7203a 	divu	r3,r2,r3
 908a1c0:	00a00034 	movhi	r2,32768
 908a1c4:	10bfffc4 	addi	r2,r2,-1
 908a1c8:	10c7203a 	divu	r3,r2,r3
 908a1cc:	e0bfff17 	ldw	r2,-4(fp)
 908a1d0:	10c5c83a 	sub	r2,r2,r3
 908a1d4:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 908a1d8:	e0bffe17 	ldw	r2,-8(fp)
 908a1dc:	10800044 	addi	r2,r2,1
 908a1e0:	e0bffe15 	stw	r2,-8(fp)
 908a1e4:	e0fffe17 	ldw	r3,-8(fp)
 908a1e8:	e0bffd17 	ldw	r2,-12(fp)
 908a1ec:	18bfe916 	blt	r3,r2,908a194 <alt_busy_sleep+0x60>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 908a1f0:	e0fffc17 	ldw	r3,-16(fp)
 908a1f4:	008003f4 	movhi	r2,15
 908a1f8:	10909004 	addi	r2,r2,16960
 908a1fc:	1887383a 	mul	r3,r3,r2
 908a200:	00817db4 	movhi	r2,1526
 908a204:	10b84004 	addi	r2,r2,-7936
 908a208:	10c7203a 	divu	r3,r2,r3
 908a20c:	e0bfff17 	ldw	r2,-4(fp)
 908a210:	1885383a 	mul	r2,r3,r2
 908a214:	10bfffc4 	addi	r2,r2,-1
 908a218:	103ffe1e 	bne	r2,zero,908a214 <alt_busy_sleep+0xe0>
 908a21c:	00000b06 	br	908a24c <alt_busy_sleep+0x118>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 908a220:	e0fffc17 	ldw	r3,-16(fp)
 908a224:	008003f4 	movhi	r2,15
 908a228:	10909004 	addi	r2,r2,16960
 908a22c:	1887383a 	mul	r3,r3,r2
 908a230:	00817db4 	movhi	r2,1526
 908a234:	10b84004 	addi	r2,r2,-7936
 908a238:	10c7203a 	divu	r3,r2,r3
 908a23c:	e0bfff17 	ldw	r2,-4(fp)
 908a240:	1885383a 	mul	r2,r3,r2
 908a244:	10bfffc4 	addi	r2,r2,-1
 908a248:	00bffe16 	blt	zero,r2,908a244 <alt_busy_sleep+0x110>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 908a24c:	0005883a 	mov	r2,zero
}
 908a250:	e037883a 	mov	sp,fp
 908a254:	df000017 	ldw	fp,0(sp)
 908a258:	dec00104 	addi	sp,sp,4
 908a25c:	f800283a 	ret

0908a260 <atexit>:
 908a260:	200b883a 	mov	r5,r4
 908a264:	000d883a 	mov	r6,zero
 908a268:	0009883a 	mov	r4,zero
 908a26c:	000f883a 	mov	r7,zero
 908a270:	908a3201 	jmpi	908a320 <__register_exitproc>

0908a274 <exit>:
 908a274:	defffe04 	addi	sp,sp,-8
 908a278:	000b883a 	mov	r5,zero
 908a27c:	dc000015 	stw	r16,0(sp)
 908a280:	dfc00115 	stw	ra,4(sp)
 908a284:	2021883a 	mov	r16,r4
 908a288:	908a4580 	call	908a458 <__call_exitprocs>
 908a28c:	00824274 	movhi	r2,2313
 908a290:	10b17c04 	addi	r2,r2,-14864
 908a294:	11000017 	ldw	r4,0(r2)
 908a298:	20800f17 	ldw	r2,60(r4)
 908a29c:	10000126 	beq	r2,zero,908a2a4 <exit+0x30>
 908a2a0:	103ee83a 	callr	r2
 908a2a4:	8009883a 	mov	r4,r16
 908a2a8:	908a6480 	call	908a648 <_exit>

0908a2ac <memcmp>:
 908a2ac:	00c000c4 	movi	r3,3
 908a2b0:	1980032e 	bgeu	r3,r6,908a2c0 <memcmp+0x14>
 908a2b4:	2144b03a 	or	r2,r4,r5
 908a2b8:	10c4703a 	and	r2,r2,r3
 908a2bc:	10000f26 	beq	r2,zero,908a2fc <memcmp+0x50>
 908a2c0:	31ffffc4 	addi	r7,r6,-1
 908a2c4:	3000061e 	bne	r6,zero,908a2e0 <memcmp+0x34>
 908a2c8:	00000a06 	br	908a2f4 <memcmp+0x48>
 908a2cc:	39ffffc4 	addi	r7,r7,-1
 908a2d0:	00bfffc4 	movi	r2,-1
 908a2d4:	21000044 	addi	r4,r4,1
 908a2d8:	29400044 	addi	r5,r5,1
 908a2dc:	38800526 	beq	r7,r2,908a2f4 <memcmp+0x48>
 908a2e0:	20c00003 	ldbu	r3,0(r4)
 908a2e4:	28800003 	ldbu	r2,0(r5)
 908a2e8:	18bff826 	beq	r3,r2,908a2cc <memcmp+0x20>
 908a2ec:	1885c83a 	sub	r2,r3,r2
 908a2f0:	f800283a 	ret
 908a2f4:	0005883a 	mov	r2,zero
 908a2f8:	f800283a 	ret
 908a2fc:	180f883a 	mov	r7,r3
 908a300:	20c00017 	ldw	r3,0(r4)
 908a304:	28800017 	ldw	r2,0(r5)
 908a308:	18bfed1e 	bne	r3,r2,908a2c0 <memcmp+0x14>
 908a30c:	31bfff04 	addi	r6,r6,-4
 908a310:	21000104 	addi	r4,r4,4
 908a314:	29400104 	addi	r5,r5,4
 908a318:	39bff936 	bltu	r7,r6,908a300 <memcmp+0x54>
 908a31c:	003fe806 	br	908a2c0 <memcmp+0x14>

0908a320 <__register_exitproc>:
 908a320:	defffa04 	addi	sp,sp,-24
 908a324:	00824274 	movhi	r2,2313
 908a328:	10b17c04 	addi	r2,r2,-14864
 908a32c:	dc000015 	stw	r16,0(sp)
 908a330:	14000017 	ldw	r16,0(r2)
 908a334:	dd000415 	stw	r20,16(sp)
 908a338:	2829883a 	mov	r20,r5
 908a33c:	81405217 	ldw	r5,328(r16)
 908a340:	dcc00315 	stw	r19,12(sp)
 908a344:	dc800215 	stw	r18,8(sp)
 908a348:	dc400115 	stw	r17,4(sp)
 908a34c:	dfc00515 	stw	ra,20(sp)
 908a350:	2023883a 	mov	r17,r4
 908a354:	3027883a 	mov	r19,r6
 908a358:	3825883a 	mov	r18,r7
 908a35c:	28002526 	beq	r5,zero,908a3f4 <__register_exitproc+0xd4>
 908a360:	29000117 	ldw	r4,4(r5)
 908a364:	008007c4 	movi	r2,31
 908a368:	11002716 	blt	r2,r4,908a408 <__register_exitproc+0xe8>
 908a36c:	8800101e 	bne	r17,zero,908a3b0 <__register_exitproc+0x90>
 908a370:	2105883a 	add	r2,r4,r4
 908a374:	1085883a 	add	r2,r2,r2
 908a378:	20c00044 	addi	r3,r4,1
 908a37c:	1145883a 	add	r2,r2,r5
 908a380:	0009883a 	mov	r4,zero
 908a384:	15000215 	stw	r20,8(r2)
 908a388:	28c00115 	stw	r3,4(r5)
 908a38c:	2005883a 	mov	r2,r4
 908a390:	dfc00517 	ldw	ra,20(sp)
 908a394:	dd000417 	ldw	r20,16(sp)
 908a398:	dcc00317 	ldw	r19,12(sp)
 908a39c:	dc800217 	ldw	r18,8(sp)
 908a3a0:	dc400117 	ldw	r17,4(sp)
 908a3a4:	dc000017 	ldw	r16,0(sp)
 908a3a8:	dec00604 	addi	sp,sp,24
 908a3ac:	f800283a 	ret
 908a3b0:	29802204 	addi	r6,r5,136
 908a3b4:	00800044 	movi	r2,1
 908a3b8:	110e983a 	sll	r7,r2,r4
 908a3bc:	30c04017 	ldw	r3,256(r6)
 908a3c0:	2105883a 	add	r2,r4,r4
 908a3c4:	1085883a 	add	r2,r2,r2
 908a3c8:	1185883a 	add	r2,r2,r6
 908a3cc:	19c6b03a 	or	r3,r3,r7
 908a3d0:	14802015 	stw	r18,128(r2)
 908a3d4:	14c00015 	stw	r19,0(r2)
 908a3d8:	00800084 	movi	r2,2
 908a3dc:	30c04015 	stw	r3,256(r6)
 908a3e0:	88bfe31e 	bne	r17,r2,908a370 <__register_exitproc+0x50>
 908a3e4:	30804117 	ldw	r2,260(r6)
 908a3e8:	11c4b03a 	or	r2,r2,r7
 908a3ec:	30804115 	stw	r2,260(r6)
 908a3f0:	003fdf06 	br	908a370 <__register_exitproc+0x50>
 908a3f4:	00824274 	movhi	r2,2313
 908a3f8:	10b1e304 	addi	r2,r2,-14452
 908a3fc:	100b883a 	mov	r5,r2
 908a400:	80805215 	stw	r2,328(r16)
 908a404:	003fd606 	br	908a360 <__register_exitproc+0x40>
 908a408:	00800034 	movhi	r2,0
 908a40c:	10800004 	addi	r2,r2,0
 908a410:	1000021e 	bne	r2,zero,908a41c <__register_exitproc+0xfc>
 908a414:	013fffc4 	movi	r4,-1
 908a418:	003fdc06 	br	908a38c <__register_exitproc+0x6c>
 908a41c:	01006404 	movi	r4,400
 908a420:	103ee83a 	callr	r2
 908a424:	1007883a 	mov	r3,r2
 908a428:	103ffa26 	beq	r2,zero,908a414 <__register_exitproc+0xf4>
 908a42c:	80805217 	ldw	r2,328(r16)
 908a430:	180b883a 	mov	r5,r3
 908a434:	18000115 	stw	zero,4(r3)
 908a438:	18800015 	stw	r2,0(r3)
 908a43c:	80c05215 	stw	r3,328(r16)
 908a440:	18006215 	stw	zero,392(r3)
 908a444:	18006315 	stw	zero,396(r3)
 908a448:	0009883a 	mov	r4,zero
 908a44c:	883fc826 	beq	r17,zero,908a370 <__register_exitproc+0x50>
 908a450:	003fd706 	br	908a3b0 <__register_exitproc+0x90>

0908a454 <register_fini>:
 908a454:	f800283a 	ret

0908a458 <__call_exitprocs>:
 908a458:	00824274 	movhi	r2,2313
 908a45c:	10b17c04 	addi	r2,r2,-14864
 908a460:	10800017 	ldw	r2,0(r2)
 908a464:	defff304 	addi	sp,sp,-52
 908a468:	df000b15 	stw	fp,44(sp)
 908a46c:	d8800115 	stw	r2,4(sp)
 908a470:	00800034 	movhi	r2,0
 908a474:	10800004 	addi	r2,r2,0
 908a478:	1005003a 	cmpeq	r2,r2,zero
 908a47c:	d8800215 	stw	r2,8(sp)
 908a480:	d8800117 	ldw	r2,4(sp)
 908a484:	dd400815 	stw	r21,32(sp)
 908a488:	dd000715 	stw	r20,28(sp)
 908a48c:	10805204 	addi	r2,r2,328
 908a490:	dfc00c15 	stw	ra,48(sp)
 908a494:	ddc00a15 	stw	r23,40(sp)
 908a498:	dd800915 	stw	r22,36(sp)
 908a49c:	dcc00615 	stw	r19,24(sp)
 908a4a0:	dc800515 	stw	r18,20(sp)
 908a4a4:	dc400415 	stw	r17,16(sp)
 908a4a8:	dc000315 	stw	r16,12(sp)
 908a4ac:	282b883a 	mov	r21,r5
 908a4b0:	2039883a 	mov	fp,r4
 908a4b4:	d8800015 	stw	r2,0(sp)
 908a4b8:	2829003a 	cmpeq	r20,r5,zero
 908a4bc:	d8800117 	ldw	r2,4(sp)
 908a4c0:	14405217 	ldw	r17,328(r2)
 908a4c4:	88001026 	beq	r17,zero,908a508 <__call_exitprocs+0xb0>
 908a4c8:	ddc00017 	ldw	r23,0(sp)
 908a4cc:	88800117 	ldw	r2,4(r17)
 908a4d0:	8c802204 	addi	r18,r17,136
 908a4d4:	143fffc4 	addi	r16,r2,-1
 908a4d8:	80000916 	blt	r16,zero,908a500 <__call_exitprocs+0xa8>
 908a4dc:	05bfffc4 	movi	r22,-1
 908a4e0:	a000151e 	bne	r20,zero,908a538 <__call_exitprocs+0xe0>
 908a4e4:	8409883a 	add	r4,r16,r16
 908a4e8:	2105883a 	add	r2,r4,r4
 908a4ec:	1485883a 	add	r2,r2,r18
 908a4f0:	10c02017 	ldw	r3,128(r2)
 908a4f4:	a8c01126 	beq	r21,r3,908a53c <__call_exitprocs+0xe4>
 908a4f8:	843fffc4 	addi	r16,r16,-1
 908a4fc:	85bff81e 	bne	r16,r22,908a4e0 <__call_exitprocs+0x88>
 908a500:	d8800217 	ldw	r2,8(sp)
 908a504:	10003126 	beq	r2,zero,908a5cc <__call_exitprocs+0x174>
 908a508:	dfc00c17 	ldw	ra,48(sp)
 908a50c:	df000b17 	ldw	fp,44(sp)
 908a510:	ddc00a17 	ldw	r23,40(sp)
 908a514:	dd800917 	ldw	r22,36(sp)
 908a518:	dd400817 	ldw	r21,32(sp)
 908a51c:	dd000717 	ldw	r20,28(sp)
 908a520:	dcc00617 	ldw	r19,24(sp)
 908a524:	dc800517 	ldw	r18,20(sp)
 908a528:	dc400417 	ldw	r17,16(sp)
 908a52c:	dc000317 	ldw	r16,12(sp)
 908a530:	dec00d04 	addi	sp,sp,52
 908a534:	f800283a 	ret
 908a538:	8409883a 	add	r4,r16,r16
 908a53c:	88c00117 	ldw	r3,4(r17)
 908a540:	2105883a 	add	r2,r4,r4
 908a544:	1445883a 	add	r2,r2,r17
 908a548:	18ffffc4 	addi	r3,r3,-1
 908a54c:	11800217 	ldw	r6,8(r2)
 908a550:	1c001526 	beq	r3,r16,908a5a8 <__call_exitprocs+0x150>
 908a554:	10000215 	stw	zero,8(r2)
 908a558:	303fe726 	beq	r6,zero,908a4f8 <__call_exitprocs+0xa0>
 908a55c:	00c00044 	movi	r3,1
 908a560:	1c06983a 	sll	r3,r3,r16
 908a564:	90804017 	ldw	r2,256(r18)
 908a568:	8cc00117 	ldw	r19,4(r17)
 908a56c:	1884703a 	and	r2,r3,r2
 908a570:	10001426 	beq	r2,zero,908a5c4 <__call_exitprocs+0x16c>
 908a574:	90804117 	ldw	r2,260(r18)
 908a578:	1884703a 	and	r2,r3,r2
 908a57c:	10000c1e 	bne	r2,zero,908a5b0 <__call_exitprocs+0x158>
 908a580:	2105883a 	add	r2,r4,r4
 908a584:	1485883a 	add	r2,r2,r18
 908a588:	11400017 	ldw	r5,0(r2)
 908a58c:	e009883a 	mov	r4,fp
 908a590:	303ee83a 	callr	r6
 908a594:	88800117 	ldw	r2,4(r17)
 908a598:	98bfc81e 	bne	r19,r2,908a4bc <__call_exitprocs+0x64>
 908a59c:	b8800017 	ldw	r2,0(r23)
 908a5a0:	147fd526 	beq	r2,r17,908a4f8 <__call_exitprocs+0xa0>
 908a5a4:	003fc506 	br	908a4bc <__call_exitprocs+0x64>
 908a5a8:	8c000115 	stw	r16,4(r17)
 908a5ac:	003fea06 	br	908a558 <__call_exitprocs+0x100>
 908a5b0:	2105883a 	add	r2,r4,r4
 908a5b4:	1485883a 	add	r2,r2,r18
 908a5b8:	11000017 	ldw	r4,0(r2)
 908a5bc:	303ee83a 	callr	r6
 908a5c0:	003ff406 	br	908a594 <__call_exitprocs+0x13c>
 908a5c4:	303ee83a 	callr	r6
 908a5c8:	003ff206 	br	908a594 <__call_exitprocs+0x13c>
 908a5cc:	88800117 	ldw	r2,4(r17)
 908a5d0:	1000081e 	bne	r2,zero,908a5f4 <__call_exitprocs+0x19c>
 908a5d4:	89000017 	ldw	r4,0(r17)
 908a5d8:	20000726 	beq	r4,zero,908a5f8 <__call_exitprocs+0x1a0>
 908a5dc:	b9000015 	stw	r4,0(r23)
 908a5e0:	8809883a 	mov	r4,r17
 908a5e4:	00000000 	call	0 <__alt_mem_ext_flash-0x4000000>
 908a5e8:	bc400017 	ldw	r17,0(r23)
 908a5ec:	883fb71e 	bne	r17,zero,908a4cc <__call_exitprocs+0x74>
 908a5f0:	003fc506 	br	908a508 <__call_exitprocs+0xb0>
 908a5f4:	89000017 	ldw	r4,0(r17)
 908a5f8:	882f883a 	mov	r23,r17
 908a5fc:	2023883a 	mov	r17,r4
 908a600:	883fb21e 	bne	r17,zero,908a4cc <__call_exitprocs+0x74>
 908a604:	003fc006 	br	908a508 <__call_exitprocs+0xb0>

0908a608 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 908a608:	defffd04 	addi	sp,sp,-12
 908a60c:	df000215 	stw	fp,8(sp)
 908a610:	df000204 	addi	fp,sp,8
 908a614:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 908a618:	e0bfff17 	ldw	r2,-4(fp)
 908a61c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 908a620:	e0bffe17 	ldw	r2,-8(fp)
 908a624:	1005003a 	cmpeq	r2,r2,zero
 908a628:	1000021e 	bne	r2,zero,908a634 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 908a62c:	002af070 	cmpltui	zero,zero,43969
 908a630:	00000106 	br	908a638 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 908a634:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 908a638:	e037883a 	mov	sp,fp
 908a63c:	df000017 	ldw	fp,0(sp)
 908a640:	dec00104 	addi	sp,sp,4
 908a644:	f800283a 	ret

0908a648 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 908a648:	defffd04 	addi	sp,sp,-12
 908a64c:	dfc00215 	stw	ra,8(sp)
 908a650:	df000115 	stw	fp,4(sp)
 908a654:	df000104 	addi	fp,sp,4
 908a658:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 908a65c:	e13fff17 	ldw	r4,-4(fp)
 908a660:	908a6080 	call	908a608 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 908a664:	003fff06 	br	908a664 <_exit+0x1c>
 908a668:	0908a454 	ori	r4,at,8849

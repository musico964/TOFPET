
SimpleSocketServer.elf:     file format elf32-littlenios2
SimpleSocketServer.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x090802bc

Program Header:
    LOAD off    0x00001000 vaddr 0x06020000 paddr 0x06020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001120 vaddr 0x09080120 paddr 0x09080120 align 2**12
         filesz 0x00052ea0 memsz 0x0005dae0 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  06020000  06020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  09080120  09080120  00001120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004ac3c  090802bc  090802bc  000012bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005f94  090caef8  090caef8  0004bef8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00002134  090d0e8c  090d0e8c  00051e8c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000ac40  090d2fc0  090d2fc0  00053fc0  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00053fc0  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001a70  00000000  00000000  00053fe8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000059b5  00000000  00000000  00055a58  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00081033  00000000  00000000  0005b40d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00011c4f  00000000  00000000  000dc440  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00042870  00000000  00000000  000ee08f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00006814  00000000  00000000  00130900  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003a00  00000000  00000000  00137114  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00013ef4  00000000  00000000  0013ab14  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  0014ea08  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000920  00000000  00000000  0014ea58  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  00159e5f  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  00159e65  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00159e68  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00159e69  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  00159e6a  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  00159e6e  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  00159e72  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  00159e76  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  00159e7f  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  00159e88  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000e  00000000  00000000  00159e91  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000054  00000000  00000000  00159e9f  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000ab0e6  00000000  00000000  00159ef3  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
06020000 l    d  .entry	00000000 .entry
09080120 l    d  .exceptions	00000000 .exceptions
090802bc l    d  .text	00000000 .text
090caef8 l    d  .rodata	00000000 .rodata
090d0e8c l    d  .rwdata	00000000 .rwdata
090d2fc0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
09080300 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
090d2fcc l     O .bss	00000004 SSSCommand.4583
090d31dc l     O .bss	000005f0 conn.4710
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 ctype_.c
090cc071 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
090d0fc4 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
09083150 l     F .text	00000058 __sprint_r
090cca12 l     O .rodata	00000010 blanks.3452
090cca02 l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
09085300 l     F .text	00000218 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
09086cfc l     F .text	00000058 std
09086e08 l     F .text	00000008 __fp_lock
09086e10 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
090d2e78 l     O .rwdata	00000004 charset
090cca44 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 mprec.c
090ccb8c l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
09089d8c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
0908b0b0 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0908c1cc l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0908c980 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0908caa0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
0908cbf0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
090d2e84 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
090d2e88 l     O .rwdata	00000004 lockid
090d3004 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
090d2e8c l     O .rwdata	00000004 lockid
090d300c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0908e7ac l     F .text	00000044 OS_InitMisc
0908e7f0 l     F .text	0000006c OS_InitRdyList
0908e954 l     F .text	000000e0 OS_InitTCBList
0908e6d0 l     F .text	000000dc OS_InitEventList
0908e85c l     F .text	0000007c OS_InitTaskIdle
0908e8d8 l     F .text	0000007c OS_InitTaskStat
0908ebc8 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
09090b00 l     F .text	00000110 OS_FlagTaskRdy
09090858 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
090d17d8 l     O .rwdata	000000d8 ext_flash
090d18b0 l     O .rwdata	0000106c jtag_uart
090d291c l     O .rwdata	00000124 lcd
090d2a40 l     O .rwdata	00000030 sgdma_rx
090d2a70 l     O .rwdata	00000030 sgdma_tx
0909571c l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
090957f0 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
090965f0 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
09097754 l     F .text	000002c4 altera_avalon_jtag_uart_irq
09097a18 l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
090d2f08 l     O .rwdata	00000004 colstart
09098230 l     F .text	000000b8 lcd_write_command
090982e8 l     F .text	000000d4 lcd_write_data
090983bc l     F .text	000000c4 lcd_clear_screen
09098480 l     F .text	000001ec lcd_repaint_screen
0909866c l     F .text	000000c8 lcd_scroll_up
09098734 l     F .text	000002d0 lcd_handle_escape
09098f34 l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
090998a4 l     F .text	00000060 alt_get_errno
09099e4c l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
09099fb8 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
090d3066 l     O .bss	00000001 tse_system_count.4487
090d3067 l     O .bss	00000001 is_init.4851
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
090d307c l     O .bss	00000004 nclosers
090d37f4 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
090d2f24 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
090d3830 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
090a7418 l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
090a9484 l       .text	00000000 done
090a9314 l       .text	00000000 asm1
090a9440 l       .text	00000000 loop0
090a933c l       .text	00000000 loop
090a945c l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
090d30dc l     O .bss	00000004 kbd_init.3746
090d30e8 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
090d311c l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
090adc00 l     F .text	00000098 sockargs
090ace3c l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
090b5fdc l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
090b8bec l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
090b8cc4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
090b8da4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
090b92fc l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
090b9438 l     F .text	000000dc alt_file_locked
090b969c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_read.c
090b981c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
090b9de4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
090ba6fc l     F .text	000000bc alt_write_word_amd
090ba5d8 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
090ba9b0 l     F .text	0000018c alt_unlock_block_intel
090bab3c l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 allports.c
090d3154 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
090bb1e0 l     F .text	00000198 check_interval_timers
090d3160 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
090d3164 l     O .bss	00000004 arp_timer
090d317c l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
090d2fa8 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
090d31ac l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
090d2fb0 l     O .rwdata	00000004 iCounter.4504
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
090d3848 l     O .bss	0000001e nearBuf.4182
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
090c8f18 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
090d2e50 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
090cac30 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_exit.c
090cae88 l     F .text	00000040 alt_sim_halt
09082774 g     F .text	0000001c putchar
090dd56c g     O .bss	00000014 soq
090889ec g     F .text	00000094 _mprec_log10
0909b38c g     F .text	000000e0 alt_tse_get_mac_info
090d2eda g     O .rwdata	00000002 OSTaskNameSize
09088ad8 g     F .text	00000088 __any_on
0908a3c4 g     F .text	00000070 _isatty_r
090ccb64 g     O .rodata	00000028 __mprec_tinytens
090bd21c g     F .text	00000780 ip_write_internal
0908cc50 g     F .text	000000c8 alt_main
090ca5b4 g     F .text	0000008c strcpy
090a8bd8 g     F .text	000000ac pk_free
09082798 g     F .text	000000a0 _puts_r
090960b0 g     F .text	00000048 alt_read_query_entry_32bit
090dd718 g     O .bss	00000100 alt_irq
090d2cf0 g     O .rwdata	00000009 rtp_priority
0908a434 g     F .text	00000078 _lseek_r
090ca110 g     F .text	00000334 icmp_timex
090aa5a4 g     F .text	00000044 m_freem
090c8750 g     F .text	00000048 vgetc
090a9600 g     F .text	0000001c clock_c
090d3134 g     O .bss	00000004 tcp_optionbuf
090bcce4 g     F .text	00000084 if_getbynum
090913f4 g     F .text	000000d0 OS_MemInit
090d30d4 g     O .bss	00000004 dsc_rlyerrs
090d30c4 g     O .bss	00000004 dsc_releases
09095828 g     F .text	000002c0 alt_flash_cfi_write
090a4fa8 g     F .text	00000074 TK_OSTaskQuery
090a92f4 g       .text	00000000 asm_cksum
0909f278 g     F .text	00000100 marvell_cfg_rgmii
09095404 g     F .text	00000064 OSTimeSet
090c8630 g     F .text	00000120 vgetc_locked
090a9e80 g     F .text	00000020 post_task_setup
090c0c54 g     F .text	00000380 ipr_stats
090b7948 g     F .text	00000134 tcp_attach
090d2f34 g     O .rwdata	00000004 reqlist_len
090aba50 g     F .text	000000bc tcp_tick
090a415c g     F .text	00000074 print_ipad
090a4ea4 g     F .text	00000104 tcp_wakeup
0908bbc0 g     F .text	00000088 __eqdf2
090d2fc4 g     O .bss	00000004 last_flash_sector_offset
090d3080 g     O .bss	00000004 igmp_timers_are_running
09080fa0 g     F .text	000000f0 led_bit_toggle
090b4834 g     F .text	0000012c tcp_pulloutofband
0909c8f8 g     F .text	000001f0 alt_tse_phy_print_profile
0908d328 g     F .text	000006b4 OSEventPendMulti
090ddc00 g       *ABS*	00000000 __alt_heap_start
090ba244 g     F .text	00000020 OSTaskCreateHook
090a83c4 g     F .text	00000074 dhc_ifacedone
0909efe8 g     F .text	000000a8 marvell_phy_cfg
090c1028 g     F .text	00000400 ip_rcv
090c8380 g     F .text	0000017c vfseek
090b0694 g     F .text	00000120 soqremque
090c2e78 g     F .text	00000858 udpdemux
090a0a98 g     F .text	00000104 tse_mac_close
09082510 g     F .text	00000044 printf
090d3180 g     O .bss	00000004 rt_mib
090d2eb2 g     O .rwdata	00000002 OSMboxEn
090a82d4 g     F .text	00000060 dhc_state_init
090caad8 g     F .text	00000024 vsprintf
09099310 g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
0908da30 g     F .text	0000007c OSIntEnter
09089e90 g     F .text	00000068 __sseek
09086d64 g     F .text	000000a4 __sinit
090c1fcc g     F .text	00000118 in_delmulti
09085078 g     F .text	00000130 __swbuf_r
090d3198 g     O .bss	00000004 so_evtmap_create
090d2ec2 g     O .rwdata	00000002 OSQEn
090c6900 g     F .text	00000094 in_pcballoc
090d2f50 g     O .rwdata	00000002 socket_defaults
09087b88 g     F .text	00000084 _setlocale_r
090bba14 g     F .text	00000498 send_arp
09086e64 g     F .text	00000068 __sfmoreglue
090c73ec g     F .text	00000368 vfopen_locked
090d2fd0 g     O .bss	00000004 SSSLEDCommandQ
0908cfe4 g     F .text	000000d0 __malloc_unlock
090ba2a0 g     F .text	0000001c OSTaskStatHook
090bb024 g     F .text	00000058 prep_modules
090a3630 g     F .text	000001b8 bsd_i_sockoptlen
090d3014 g     O .bss	00000001 OSLockNesting
090d2f2c g     O .rwdata	00000004 xids
09082a60 g     F .text	00000674 strerror
0909b5f0 g     F .text	00000e08 getPHYSpeed
090c794c g     F .text	00000040 vfclose
090dd60c g     O .bss	0000002c tcb
090d2f00 g     O .rwdata	00000002 OSDataSize
090b98dc g     F .text	00000038 alt_remap_cached
090d3015 g     O .bss	00000001 OSRunning
090bca18 g     F .text	000002cc grat_arp
09081338 g     F .text	0000005c get_ip_addr
090c6318 g     F .text	000000ac inet_pton
090bce48 g     F .text	0000009c reg_type
090dd110 g     O .bss	000000f0 dhc_states
090a2390 g     F .text	00000234 igmp_fasttimo
090c7b10 g     F .text	0000005c vunlink_flag_open_files
090a807c g     F .text	00000088 dhc_halt
09099a64 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
090d30b8 g     O .bss	00000004 dsc_acks
090dd638 g     O .bss	000000e0 tcpstat
090c04cc g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
090aab34 g     F .text	000000a8 dtom
090b5ee0 g     F .text	000000fc tcp_setpersist
090ad214 g     F .text	000001a4 t_getsockopt
09082318 g     F .text	000000e0 memmove
090d30c8 g     O .bss	00000004 dsc_naks
090aafd8 g     F .text	000005f8 ip_output
090ba2e4 g     F .text	0000001c OSInitHookBegin
090ca444 g     F .text	00000054 icmp_du
090d2f28 g     O .rwdata	00000004 num_net_tasks
090d31bc g     O .bss	00000004 vfiles
090d2ef8 g     O .rwdata	00000002 OSTmrSize
090c5a14 g     F .text	00000104 dhc_main_ipset
09086e54 g     F .text	00000010 _cleanup
090bf5c4 g     F .text	000002e0 ip_reasm_process_first_fragment
09088b60 g     F .text	000000bc _Balloc
090d3018 g     O .bss	00000004 OSIdleCtr
090d2fd4 g     O .bss	00000004 SSSLEDLightshowSem
0909e2ac g     F .text	00000194 alt_tse_phy_set_adv_1000
090d2f14 g     O .rwdata	00000001 max_mac_system
090c48ac g     F .text	000005f0 ip_setmoptions
0909a5f0 g     F .text	00000a14 alt_tse_system_add_sys
0908bcd0 g     F .text	00000088 __gtdf2
090c5dd8 g     F .text	0000002c md_fseek
090b9f10 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0908ef14 g     F .text	000002e0 OS_TCBInit
090bf8a4 g     F .text	000000a0 ip_reassm
090a8104 g     F .text	000001d0 dhc_reclaim
0909623c g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
090dd9f8 g     O .bss	00000010 udp_mib
06020000 g     F .entry	00000000 __reset
090ada4c g     F .text	000000e4 t_shutdown
09081c7c g     F .text	000001ec sss_handle_receive
090ad4a8 g     F .text	00000150 t_recvfrom
090d2efe g     O .rwdata	00000002 OSTmrWheelTblSize
090c5090 g     F .text	000006b8 u_mctest_run
09099578 g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
090c2154 g     F .text	00000094 prep_ifaces
090d309c g     O .bss	00000001 to_netmain
090a8844 g     F .text	000000dc pk_alloc
090d2e9e g     O .rwdata	00000002 OSEventSize
09080bc0 g     F .text	000002ec alt_SSSErrorHandler
090d301c g     O .bss	00000001 OSPrioHighRdy
0908a350 g     F .text	00000074 _fstat_r
090d0ea4 g     O .rwdata	00000120 tse_mac_device
090a4c1c g     F .text	0000004c tk_nettick
090ba264 g     F .text	00000020 OSTaskDelHook
09095d44 g     F .text	000002e8 alt_flash_program_block
090d2ff4 g     O .bss	00000004 errno
09082898 g     F .text	00000014 __srget
090b19c0 g     F .text	000000cc in_pcbnotify
090b9ef0 g       .text	00000000 OSStartHighRdy
090dd200 g     O .bss	00000014 lilfreeq
09080304 g     F .text	00000624 alt_uCOSIIErrorHandler
090c2210 g     F .text	00000028 evtmap_setup
09093b08 g     F .text	00000200 OSTaskCreateExt
090d30a0 g     O .bss	00000004 tcp_sleep_timeout
090b10c0 g     F .text	000001d0 sbdrop
090d3194 g     O .bss	00000004 net_system_exit
090dda08 g     O .bss	00000068 icmp_mib
090b6a34 g     F .text	00000078 tcp_getseq
090c2620 g     F .text	000000cc ip_raw_alloc
0909eb04 g     F .text	000004e4 alt_tse_phy_set_common_speed
09090374 g     F .text	00000068 OSFlagPendGetFlagsRdy
090d2ede g     O .rwdata	00000002 OSTaskStatStkSize
090dcbe4 g     O .bss	00000010 pmac_groups
090a6460 g     F .text	00000b3c dhc_request
090aed4c g     F .text	000007e4 soreceive
0908f380 g     F .text	00000334 OSFlagAccept
09091b2c g     F .text	000000c8 OSQFlush
090914c4 g     F .text	00000154 OSQAccept
090d2ffc g     O .bss	00000004 alt_argv
090dae68 g       *ABS*	00000000 _gp
090c0fd4 g     F .text	00000054 ip_reasm_send_icmp_timex
090b9b60 g     F .text	00000164 usleep
090c798c g     F .text	00000048 vfflush
090dd514 g     O .bss	00000040 resid_semaphore
090a4014 g     F .text	00000148 hexdump
090bf47c g     F .text	000000a8 ip_reasm_incr_mem_useage
090a9ed8 g     F .text	00000034 calloc2
090a2ae8 g     F .text	0000007c igmp_leavegroup
09093934 g     F .text	000001d4 OSTaskCreate
090933c0 g     F .text	00000574 OSTaskChangePrio
090d3010 g     O .bss	00000004 alt_heapsem
090b6880 g     F .text	000000e8 tcp_close
0908f1f4 g     F .text	0000018c OSDebugInit
09093d08 g     F .text	0000040c OSTaskDel
090c8bac g     F .text	0000006c vferror
090b9afc g     F .text	00000064 alt_uncached_malloc
0909a0e4 g     F .text	00000060 tse_mac_initTransInfo2
090c3b88 g     F .text	000000c0 udp_alloc
090d2b58 g     O .rwdata	00000180 alt_fd_list
090d98e0 g     O .bss	00000370 OSFlagTbl
090d3120 g     O .bss	00000008 mbstat
090821e8 g     F .text	00000090 _getc_r
09082150 g     F .text	00000098 getc
09082790 g     F .text	00000008 _putchar_r
0908e4ac g     F .text	000000b8 OS_EventTaskRemove
090c449c g     F .text	00000158 igmpv2_chk_set_timer
090a4c68 g     F .text	0000002c TK_OSTimeDly
090b8ecc g     F .text	00000094 alt_find_dev
09082278 g     F .text	000000a0 memcpy
0909a36c g     F .text	00000058 tse_mac_setMIImode
090d30d0 g     O .bss	00000004 dsc_rebind
090bb618 g     F .text	00000080 task_stats
090ac538 g     F .text	0000004c DOMAIN_CHECK
090ab5d0 g     F .text	00000040 in_broadcast
090d2ec8 g     O .rwdata	00000002 OSRdyTblSize
0909c3f8 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
090d31b8 g     O .bss	00000004 vfsystems
090c3ab8 g     F .text	000000d0 udp_socket
090d3070 g     O .bss	00000004 MaxMtu
090b1654 g     F .text	00000158 sock_selscan
09086e48 g     F .text	0000000c _cleanup_r
0908be68 g     F .text	000000f8 __floatsidf
090bf228 g     F .text	000000d0 ip_reasm_match_frag_with_ire
090b0804 g     F .text	00000050 socantrcvmore
0909a144 g     F .text	000000f0 tse_mac_sTxWrite
09081ad8 g     F .text	000001a4 sss_exec_command
090824fc g     F .text	00000014 perror
090b93c0 g     F .text	00000078 alt_io_redirect
0908bde0 g     F .text	00000088 __ltdf2
090d30fc g     O .bss	00000004 netq_intmask
090c62a8 g     F .text	00000070 hextoa
090caef8 g       *ABS*	00000000 __DTOR_END__
090ad824 g     F .text	00000228 t_send
090b8af0 g     F .text	000000fc alt_close
090d3128 g     O .bss	00000002 select_wait
09082838 g     F .text	00000014 puts
090a4738 g     F .text	00000044 std_out
090dcc04 g     O .bss	00000030 tse_iniche_dev_driver_data
090c8798 g     F .text	00000138 vfslookup_locked
090ae534 g     F .text	0000009c soaccept
0908d0b4 g     F .text	00000130 OSEventNameGet
090d2eac g     O .rwdata	00000002 OSFlagMax
090dd580 g     O .bss	0000003c tcpmib
090adc98 g     F .text	0000009c t_errno
090c2238 g     F .text	000000f0 ip_raw_open
090a7300 g     F .text	00000118 dhc_decline
0908893c g     F .text	000000b0 __ratio
0908daac g     F .text	00000100 OSIntExit
090d2fac g     O .rwdata	00000004 ipRoutes
090c7ab8 g     F .text	00000058 vfeof
090b6d4c g     F .text	0000005c tcp_canceltimers
090a5c10 g     F .text	0000021c dhc_buildheader
090d2ee6 g     O .rwdata	00000002 OSTCBSize
0909965c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
090d301d g     O .bss	00000001 OSPrioCur
09097c94 g     F .text	000002c0 altera_avalon_jtag_uart_read
090ca52c g     F .text	00000014 malloc
090d31b4 g     O .bss	00000004 inpcb_cachemiss
09082554 g     F .text	00000034 _printf_r
090c64b0 g     F .text	000000c4 inet46_addr
090d31b0 g     O .bss	00000004 inpcb_cachehits
0908c308 g     F .text	00000008 __udivsi3
090d2b18 g     O .rwdata	0000000b tcp_outflags
090dcc34 g     O .bss	00000130 tse
0908c9e0 g     F .text	000000c0 isatty
0909b004 g     F .text	00000178 alt_tse_sys_enable_mdio_sharing
090d2ecc g     O .rwdata	00000002 OSStkWidth
090cca74 g     O .rodata	000000c8 __mprec_tens
090c7248 g     F .text	0000007c vf_alloc_and_link_vop
090d2ec0 g     O .rwdata	00000002 OSPtrSize
090d3184 g     O .bss	00000004 ipr_curr_mem
090a1fdc g     F .text	0000006c exit_hook
090d3084 g     O .bss	00000004 igmp_cticks
0909b300 g     F .text	0000008c alt_tse_get_mac_info_index
090d3110 g     O .bss	00000004 mheap_sem_ptr
090b4c00 g     F .text	00000048 ip4_tcpmss
09087b64 g     F .text	00000008 __locale_charset
090d2ea0 g     O .rwdata	00000002 OSEventTblSize
090dd97c g     O .bss	00000014 netlist
090af530 g     F .text	000000a8 soshutdown
090cade4 g     F .text	000000a4 __fixunsdfsi
090b9e64 g       .text	00000000 OSCtxSw
090bafb4 g     F .text	0000004c packet_check
090a6f9c g     F .text	00000280 dhc_setip
090dd5bc g     O .bss	00000014 mbufq
090ae4e4 g     F .text	00000050 soabort
090d2fe8 g     O .bss	00000004 __malloc_top_pad
090d3020 g     O .bss	00000004 OSTCBList
090a8ec8 g     F .text	00000110 qdel
090bad9c g     F .text	00000188 station_state
090c2788 g     F .text	00000184 rt_lookup
090d3140 g     O .bss	00000004 alt_fd_list_lock
090d2e74 g     O .rwdata	00000004 __mb_cur_max
090a2b64 g     F .text	0000035c igmp_validate
09087b6c g     F .text	0000000c _localeconv_r
090a1cf8 g     F .text	000002e4 ip_startup
090ac874 g     F .text	00000298 t_accept
090b0284 g     F .text	0000008c soisdisconnecting
09089258 g     F .text	0000003c __i2b
09087548 g     F .text	0000049c __sfvwrite_r
09099784 g     F .text	00000058 alt_avalon_sgdma_stop
090a16b0 g     F .text	000003d4 pktdemux
090d9c50 g     O .bss	00000c30 OSMemTbl
090d3024 g     O .bss	00000001 OSTickStepState
0909c494 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
090a94b8 g     F .text	000000ac kbhit
090ad038 g     F .text	000001dc t_setsockopt
09089e18 g     F .text	00000070 _sbrk_r
090ba7b8 g     F .text	00000084 alt_program_intel
090d2cd8 g     O .rwdata	00000018 icmpdu_types
0909cae8 g     F .text	0000070c alt_tse_mac_group_init
090c7b6c g     F .text	00000220 vunlink
0909f7d8 g     F .text	00000ae8 tse_mac_init
090d2ec4 g     O .rwdata	00000002 OSQMax
090a3e54 g     F .text	000000b0 ccksum
090c72c4 g     F .text	000000d8 vf_alloc_buffer
090d31a8 g     O .bss	00000004 cachedRoute
090d2f38 g     O .rwdata	00000004 lilbufs
090da880 g     O .bss	00000800 OSTaskStatStk
090c5e04 g     F .text	00000024 md_ftell
090a3f04 g     F .text	00000068 cksum
09090fdc g     F .text	0000010c OSMemNameGet
090ae04c g     F .text	00000130 sofree
090d3078 g     O .bss	00000004 ifNumber
090d2ea4 g     O .rwdata	00000002 OSFlagEn
0908a4ac g     F .text	00000078 _read_r
090d2eea g     O .rwdata	00000002 OSTimeTickHookEn
090b8c4c g     F .text	00000078 alt_dcache_flush
09090c10 g     F .text	000000ac OS_FlagUnlink
09092090 g     F .text	00000180 OSQPost
090d13c4 g     O .rwdata	0000000c __lc_ctype
090d2f78 g     O .rwdata	00000004 alt_max_fd
0909602c g     F .text	00000040 alt_read_query_entry_8bit
0908ea88 g     F .text	0000006c OS_MemCopy
090d2f40 g     O .rwdata	00000004 bigbufs
090b7a7c g     F .text	000000d4 tcp_disconnect
0908eaf4 g     F .text	000000d4 OS_Sched
0908c6ac g     F .text	00000138 __unpack_d
0908a22c g     F .text	00000110 _fclose_r
09090ed8 g     F .text	00000104 OSMemGet
0909443c g     F .text	000001c4 OSTaskNameSet
090ba83c g     F .text	00000174 alt_erase_block_intel
09086cc8 g     F .text	00000034 fflush
090d2fec g     O .bss	00000004 __malloc_max_sbrked_mem
090d3028 g     O .bss	00000004 OSCtxSwCtr
090dd088 g     O .bss	00000064 igmpstats
090ba2bc g     F .text	00000028 OSTimeTickHook
090a635c g     F .text	00000104 dhc_rx_offer
090a37e8 g     F .text	00000120 bsd_getsockopt
090d2eae g     O .rwdata	00000002 OSFlagNameSize
090dd9e0 g     O .bss	00000018 ire_stats
09081104 g     F .text	000001e4 LEDManagementTask
090b7cec g     F .text	000001b8 udp_soinput
090a8e18 g     F .text	000000b0 putq
0908e564 g     F .text	00000104 OS_EventTaskRemoveMulti
090d3098 g     O .bss	00000004 iniche_net_ready
0908b540 g     F .text	00000074 __adddf3
0908e358 g     F .text	00000154 OS_EventTaskWaitMulti
090c8b64 g     F .text	00000048 isvfile
090af6d8 g     F .text	000004c0 sosetopt
090a4aa0 g     F .text	000000f4 netmain
090b4c48 g     F .text	0000011c tcp_mss
0908881c g     F .text	00000120 __b2d
090c5f24 g     F .text	0000031c parse_ipad
090c7228 g     F .text	00000020 get_vfopen_error
090d2ec6 g     O .rwdata	00000002 OSQSize
0908ab00 g     F .text	000005b0 __umoddi3
0908cb00 g     F .text	000000f0 lseek
090bb07c g     F .text	00000164 inet_timer
09092c6c g     F .text	0000027c OSSemPend
0909c680 g     F .text	00000278 alt_tse_phy_add_profile_default
0909dd6c g     F .text	00000540 alt_tse_phy_get_cap
09081888 g     F .text	00000190 sss_send_menu
090d2e70 g     O .rwdata	00000004 _global_impure_ptr
090a43d0 g     F .text	00000164 print_eth
090c7754 g     F .text	00000050 vfopen
090b96fc g     F .text	00000120 alt_read
090895d4 g     F .text	000005f4 _realloc_r
09080928 g     F .text	00000298 alt_NetworkErrorHandler
090d2eb0 g     O .rwdata	00000002 OSLowestPrio
090ddc00 g       *ABS*	00000000 __bss_end
090b9204 g     F .text	000000f8 alt_iic_isr_register
090991d4 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
090aa470 g     F .text	00000134 m_free
090ba338 g     F .text	00000020 OSTCBInitHook
090a0a58 g     F .text	00000040 tse_mac_stats
090a8920 g     F .text	000002b8 pk_validate
090d2ef6 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
090b99ec g     F .text	00000110 alt_tick
090c6fa4 g     F .text	0000025c in_pcblookup
090a84e8 g     F .text	000000cc find_opt
0908a524 g     F .text	000005dc __udivdi3
090aa2c8 g     F .text	000001a8 m_getnbuf
090a8ca4 g     F .text	000000ac dump_buf_estats
0909dc28 g     F .text	00000144 alt_tse_phy_check_link
090d3178 g     O .bss	00000004 arpRepsOut
090d2e98 g     O .rwdata	00000002 OSEventEn
090ccb3c g     O .rodata	00000028 __mprec_bigtens
090894b4 g     F .text	00000120 __s2b
090d2ef2 g     O .rwdata	00000002 OSTmrCfgNameSize
0908c038 g     F .text	00000194 __floatunsidf
090bac18 g     F .text	000000fc netmain_init
0909f184 g     F .text	000000f4 marvell_cfg_sgmii
0909da78 g     F .text	000001b0 alt_tse_phy_restart_an
0908873c g     F .text	00000060 __mcmp
090d30b4 g     O .bss	00000004 dsc_requests
090b6234 g     F .text	00000488 tcp_respond
090b8128 g     F .text	0000033c udp4_sockbind
090d2e68 g     O .rwdata	00000004 __ctype_ptr
090d3100 g     O .bss	00000004 old_mode
090a286c g     F .text	0000027c igmp_joingroup
090ab6f8 g     F .text	00000358 so_icmpdu
09086e30 g     F .text	00000018 __fp_lock_all
090d31c8 g     O .bss	00000004 vfs_dir_stale
090b91bc g     F .text	00000048 alt_ic_irq_enabled
090dcbf4 g     O .bss	00000010 pphy_profiles
090c0828 g     F .text	0000011c ip_reasm_process_timer_tick
090c8c18 g     F .text	0000005c vclearerr
090a3d68 g     F .text	000000ec bsd_setsockopt
090aaadc g     F .text	00000058 mbuf_len
09090a1c g     F .text	000000e4 OS_FlagInit
090b9954 g     F .text	00000098 alt_alarm_stop
090c8918 g     F .text	000001e8 strippath
090d2f30 g     O .rwdata	00000004 reqlist
090a4d04 g     F .text	000001a0 tcp_sleep
090caa30 g     F .text	00000024 strtol
090a53e0 g     F .text	00000830 dhc_upcall
090b7b50 g     F .text	000000e0 tcp_usrclosed
09100000 g       *ABS*	00000000 __alt_mem_descriptor_memory
090d30ec g     O .bss	00000004 cticks_factor
090d2ed4 g     O .rwdata	00000002 OSTaskIdleStkSize
090c69e8 g     F .text	00000254 in_pcbbind
090d3144 g     O .bss	00000004 alt_irq_active
090927f8 g     F .text	000000c0 OSSemAccept
09091208 g     F .text	000000f0 OSMemPut
09090cbc g     F .text	0000021c OSMemCreate
090d302c g     O .bss	00000004 OSIdleCtrMax
090801ec g     F .exceptions	000000d0 alt_irq_handler
090d2b30 g     O .rwdata	00000028 alt_dev_null
090d2f52 g     O .rwdata	00000001 tcprexmtthresh
090d2ee8 g     O .rwdata	00000002 OSTicksPerSec
090bcee4 g     F .text	00000098 if_killsocks
090bd99c g     F .text	00000248 ip_write
090c1428 g     F .text	0000060c ip_rcv_phase2
090acdf8 g     F .text	00000044 t_getsockname
090acb0c g     F .text	000002a8 t_connect
090d2f4c g     O .rwdata	00000004 TCPTV_MSL
090dd214 g     O .bss	00000010 memestats
0909d964 g     F .text	00000114 alt_tse_phy_init
090a9564 g     F .text	00000060 getch
09096544 g     F .text	000000ac alt_set_flash_algorithm_func
090d2dd0 g     O .rwdata	00000080 vfs_root_path
090acdb4 g     F .text	00000044 t_getpeername
090997dc g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
090bf524 g     F .text	000000a0 ip_reasm_decr_mem_useage
090b0990 g     F .text	00000080 soreserve
090b9e64 g       .text	00000000 OSIntCtxSw
090a9f0c g     F .text	000000f4 npalloc
09088608 g     F .text	00000070 __hi0bits
090d31a4 g     O .bss	00000004 ipraw_eps
090a85b4 g     F .text	00000290 pk_init
090c5bd8 g     F .text	00000180 md_fread
090ca4c4 g     F .text	0000001c calloc
090a02c0 g     F .text	000002f8 tse_mac_raw_send
0908bf60 g     F .text	000000d8 __fixdfsi
090dd818 g     O .bss	00000064 intimers
090b0a70 g     F .text	00000048 sbrelease
090b1af4 g     F .text	000000f0 ifd_clr
090b13a0 g     F .text	00000094 sbdroprecord
090a4534 g     F .text	00000080 uslash
090b9cc4 g     F .text	00000120 alt_write
090960f8 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
090d3174 g     O .bss	00000004 arpRepsIn
090a5250 g     F .text	00000090 dhc_get_srv_ipaddr
090bb378 g     F .text	000001d4 in_timerset
090d3030 g     O .bss	00000004 OSTCBFreeList
09092ee8 g     F .text	0000017c OSSemPendAbort
090b4d64 g     F .text	0000117c tcp_output
090d3150 g     O .bss	00000004 activehost
090d2f70 g     O .rwdata	00000008 alt_dev_list
090a4874 g     F .text	0000022c parse_args
090d3104 g     O .bss	00000004 global_TCPwakeup_setIndx
09087020 g     F .text	00000058 _fputc_r
090a0dac g     F .text	00000070 write
0909998c g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
090aa000 g     F .text	000000b8 npfree
0908268c g     F .text	000000e8 _putc_r
090bc1b4 g     F .text	00000294 arpReply
090a3f98 g     F .text	0000007c nextarg
090d2eec g     O .rwdata	00000002 OSVersionNbr
090bfed4 g     F .text	00000594 ip_reasm_process_subsequent_fragments
090d2fb8 g     O .rwdata	00000004 pton_error
090d30a8 g     O .bss	00000004 dsc_errors
090d3868 g     O .bss	00002000 SSSInitialTaskStk
090dcd64 g     O .bss	00000014 rcvdq
090b1a8c g     F .text	00000068 tcp_notify
0908c8ac g     F .text	000000d4 fstat
09082014 g     F .text	0000002c fprintf
090ae5d0 g     F .text	000000d4 soconnect
090c272c g     F .text	0000005c ip_raw_maxalloc
0909f378 g     F .text	00000080 DP83848C_link_status_read
090a5e2c g     F .text	00000530 dhc_discover
090973f8 g     F .text	000000dc alt_check_primary_table
090816ac g     F .text	000000a8 SSSCreateOSDataStructs
090c6f28 g     F .text	0000007c in_setpeeraddr
090d2e94 g     O .rwdata	00000004 OSEndiannessTest
090a95c4 g     F .text	0000003c clock_init
090c79d4 g     F .text	000000e4 vfgets
090bb79c g     F .text	0000017c et_send
09089394 g     F .text	00000120 __pow5mult
090d2fdc g     O .bss	00000004 __nlocale_changed
0908c310 g     F .text	00000008 __umodsi3
09095b78 g     F .text	00000068 alt_flash_cfi_read
090962cc g     F .text	00000034 alt_write_native_8bit
090c6240 g     F .text	00000068 inet_addr
090bf3e4 g     F .text	00000098 ip_reasm_check_mem_useage
090af5d8 g     F .text	00000100 sorflush
090caa68 g     F .text	00000020 vprintf
090dd328 g     O .bss	000000fc global_tcb_ext
090be06c g     F .text	00000488 ip_fragment_lc
090dcd78 g     O .bss	00000300 netstatic
090ac614 g     F .text	0000017c t_bind
090995e8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
090d2ea6 g     O .rwdata	00000002 OSFlagGrpSize
090a9210 g     F .text	000000e4 udp_close
090996e0 g     F .text	00000050 alt_avalon_sgdma_register_callback
090a9bf0 g     F .text	0000021c alt_iniche_init
090ddc00 g       *ABS*	00000000 end
090a9828 g     F .text	00000088 UNLOCK_NET_RESOURCE
0909f554 g     F .text	00000284 prep_tse_mac
090ad3b8 g     F .text	000000f0 t_recv
09096134 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
09098a04 g     F .text	00000530 altera_avalon_lcd_16207_write
090c7d8c g     F .text	000001ac vfread
090a15c8 g     F .text	000000e8 netclose
09081e68 g     F .text	000001ac SSSSimpleSocketServerTask
090ca4ac g     F .text	0000000c _atoi_r
0909a418 g     F .text	000001d8 alt_tse_phy_add_profile
0909666c g     F .text	000005e0 alt_read_cfi_table
090d2f5c g     O .rwdata	00000004 tcp_keepintvl
0909761c g     F .text	00000138 altera_avalon_jtag_uart_init
0908ed6c g     F .text	000000e0 OS_TaskStat
090d30ac g     O .bss	00000004 dsc_discovers
090d2f04 g     O .rwdata	00000004 tse_mac_name
090d2ad0 g     O .rwdata	00000018 tcp_protosw
090caef4 g       *ABS*	00000000 __CTOR_LIST__
090d31c4 g     O .bss	00000004 vfopen_error
09100000 g       *ABS*	00000000 __alt_stack_pointer
090d3138 g     O .bss	00000004 tcp_maxidle
090d30d8 g     O .bss	00000004 firstudp
09099a08 g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
0909a028 g     F .text	00000090 alt_avalon_timer_sc_init
0908c318 g     F .text	00000080 __clzsi2
09097f54 g     F .text	000002dc altera_avalon_jtag_uart_write
09099434 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
09095754 g     F .text	0000009c alt_flash_cfi_init
09086d54 g     F .text	00000004 __sfp_lock_acquire
090884fc g     F .text	000000e4 memchr
0908ea34 g     F .text	00000054 OS_MemClr
090831a8 g     F .text	00001eac ___vfprintf_internal_r
090b9f34 g     F .text	00000310 OSTaskStkInit
09082920 g     F .text	00000060 _sprintf_r
09099524 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
09087234 g     F .text	00000314 _free_r
090c45f4 g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
090adb30 g     F .text	000000d0 t_socketclose
090d5868 g     O .bss	00002000 LED7SegLightshowTaskStk
0908e0b4 g     F .text	00000194 OS_EventTaskRdy
090cac34 g     F .text	000001b0 __call_exitprocs
0908284c g     F .text	0000004c __srget_r
090a05b8 g     F .text	000000a8 tse_sgdmaRx_isr
090d3034 g     O .bss	00000001 OSCPUUsage
090dd078 g     O .bss	00000010 nets
090a9768 g     F .text	000000c0 LOCK_NET_RESOURCE
090a721c g     F .text	000000e4 dhc_resetip
090d2fe0 g     O .bss	00000004 __mlocale_changed
090a0808 g     F .text	00000250 tse_mac_rcv
090ac584 g     F .text	00000090 t_socket
090d2e80 g     O .rwdata	00000004 __malloc_sbrk_base
090802bc g     F .text	00000048 _start
090bb748 g     F .text	00000054 etainit
090d3148 g     O .bss	00000004 _alt_tick_rate
090bb000 g     F .text	00000024 mcastlist
09091bf4 g     F .text	00000320 OSQPend
090dd224 g     O .bss	000000f0 pktlog
090c4104 g     F .text	0000014c igmpv2_process_report
090b1c58 g     F .text	00000080 ifd_isset
090c2d34 g     F .text	00000144 del_route
0909984c g     F .text	00000058 alt_avalon_sgdma_open
09083148 g     F .text	00000008 _user_strerror
09094e00 g     F .text	0000014c OSTimeDly
090812e8 g     F .text	00000050 get_mac_addr
090adf5c g     F .text	000000f0 solisten
09088f24 g     F .text	0000014c __lshift
090d314c g     O .bss	00000004 _alt_nticks
0909c5bc g     F .text	000000c4 alt_tse_phy_rd_mdio_reg
090a0d34 g     F .text	00000078 read
0909549c g     F .text	00000280 alt_sys_init
090b6968 g     F .text	0000004c tcp_quench
090a45b4 g     F .text	00000184 ns_printf
090bcd68 g     F .text	000000e0 isbcast
090a98b0 g     F .text	00000214 TK_NEWTASK
090caafc g     F .text	00000134 __register_exitproc
090d3035 g     O .bss	00000001 OSTaskCtr
090bf2f8 g     F .text	000000ec ip_reasm_determine_type_of_frag
090d3064 g     O .bss	00000001 phy_profile_count
090ca640 g     F .text	000000f0 strncmp
0909b280 g     F .text	00000080 alt_tse_get_mac_group_index
0909606c g     F .text	00000044 alt_read_query_entry_16bit
09094f4c g     F .text	00000244 OSTimeDlyHMSM
090b9914 g     F .text	00000040 alt_remap_uncached
090c2328 g     F .text	000000c0 ip_raw_close
09089070 g     F .text	000001e8 __multiply
090d2d20 g     O .rwdata	000000b0 mdlist
09097b2c g     F .text	00000074 altera_avalon_jtag_uart_close
090a2298 g     F .text	000000f8 igmp_input
090bdf94 g     F .text	000000d8 ip_raw_write
090c7f38 g     F .text	000003e8 vfwrite_locked
090ca730 g     F .text	000000bc strncpy
090d30b0 g     O .bss	00000004 dsc_offers
090d37cc g     O .bss	00000028 __malloc_current_mallinfo
090d2e9a g     O .rwdata	00000002 OSEventMax
090c6574 g     F .text	00000074 inet_setport
09096364 g     F .text	000001e0 alt_set_flash_width_func
09088c1c g     F .text	0000017c __d2b
09093064 g     F .text	00000128 OSSemPost
090b46a4 g     F .text	00000190 tcp_dooptions
090d2fd8 g     O .bss	00000004 SSSLEDEventFlag
090b0188 g     F .text	000000fc soisconnected
0908dc38 g     F .text	000000e4 OSSchedUnlock
090c21e8 g     F .text	00000028 netexit
09081394 g     F .text	000001dc get_serial_number
090d3094 g     O .bss	00000004 nettick_wakes
0909c440 g     F .text	00000054 alt_tse_phy_wr_mdio_addr
090d312c g     O .bss	00000001 tcpprintfs
090bb54c g     F .text	000000a8 in_timerkill
090c3fa4 g     F .text	00000160 igmpv2_input
090d30c0 g     O .bss	00000004 dsc_declines
090974d4 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
090a3f6c g     F .text	0000002c do_trap
090c9098 g     F .text	000000f4 alt_get_fd
090a3908 g     F .text	00000104 bsd_ioctl
090d3038 g     O .bss	00000004 OSMemFreeList
0908dd8c g     F .text	000000ac OSStatInit
090aadec g     F .text	000001ec tcp_rcv
090a438c g     F .text	00000044 panic
090d31cc g     O .bss	00000004 vfs_open_files
090c8c98 g     F .text	0000012c alt_busy_sleep
090a1b54 g     F .text	000001a4 ip2mac
09090784 g     F .text	000000d4 OSFlagQuery
0908c7e4 g     F .text	000000c8 __fpcmp_parts_d
090b17ac g     F .text	00000214 sock_select
090c5748 g     F .text	000002cc dhc_setup
090b60c4 g     F .text	00000058 tcp_init
090d3108 g     O .bss	00000004 cticks
090d309d g     O .bss	00000001 to_nettick
090d2ed0 g     O .rwdata	00000002 OSTaskCreateExtEn
0908a1bc g     F .text	00000070 _close_r
090a0e1c g     F .text	0000064c Netinit
090a9ea0 g     F .text	00000038 prep_armintcp
090c1e64 g     F .text	00000168 in_addmulti
090b611c g     F .text	00000118 tcp_template
0909e7e8 g     F .text	0000031c alt_tse_phy_get_common_speed
090aabdc g     F .text	00000070 remque
090ba3c0 g     F .text	00000218 alt_erase_block_amd
090caa54 g     F .text	00000014 _vprintf_r
090b1d48 g     F .text	00000408 tcp_reass
090c6734 g     F .text	000001cc tcp_cksum
090b8464 g     F .text	000003dc udp4_socksend
090c77a4 g     F .text	000001a8 vfclose_locked
090b1be4 g     F .text	00000074 ifd_set
090ca540 g     F .text	00000074 memcmp
0908e098 g     F .text	0000001c OS_Dummy
09097584 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
090a8438 g     F .text	000000b0 dhc_set_state
090d3074 g     O .bss	00000004 NDEBUG
090ddc00 g       *ABS*	00000000 __alt_stack_base
090d2fc8 g     O .bss	00000004 last_flash_sector
090975cc g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
090b0a10 g     F .text	00000060 sbreserve
090d3065 g     O .bss	00000001 mac_group_count
090c23e8 g     F .text	00000238 ip_raw_input
09082074 g     F .text	0000009c _fwrite_r
090d2f3c g     O .rwdata	00000004 lilbufsiz
090b1cd8 g     F .text	00000070 ifd_get
090b08f4 g     F .text	0000009c sbwakeup
090851c4 g     F .text	0000013c __swsetup_r
09096c4c g     F .text	000007ac alt_read_cfi_width
0909f3f8 g     F .text	0000015c altera_eth_tse_init
090db080 g     O .bss	000001e0 OSQTbl
090b4960 g     F .text	000002a0 tcp_xmit_timer
090a0660 g     F .text	000001a8 tse_sgdma_read_init
0908b968 g     F .text	00000258 __divdf3
09086ecc g     F .text	000000f0 __sfp
09081570 g     F .text	0000013c generate_mac_addr
090bd078 g     F .text	000001a4 ip_bldhead
09088a80 g     F .text	00000058 __copybits
090b0ab8 g     F .text	000000a8 sbappend
090d13d0 g     O .rwdata	00000408 __malloc_av_
09086d60 g     F .text	00000004 __sinit_lock_release
090d303c g     O .bss	00000004 OSTCBHighRdy
0908b5b4 g     F .text	000003b4 __muldf3
090bdbe4 g     F .text	000003b0 ip_write2
09089f74 g     F .text	00000060 __sread
090d2fa4 g     O .rwdata	00000004 arp_ageout
090d3040 g     O .bss	00000004 OSQFreeList
0909d1f4 g     F .text	00000418 alt_tse_mac_get_phy
090bcf7c g     F .text	000000fc ip_init
090c8f78 g     F .text	00000120 alt_find_file
090c26ec g     F .text	00000040 ip_raw_free
090bc0a0 g     F .text	00000114 make_arp_entry
090b8cf0 g     F .text	000000b4 alt_dev_llist_insert
0908cedc g     F .text	00000108 __malloc_lock
09082040 g     F .text	00000034 _fprintf_r
0908cd18 g     F .text	000000bc sbrk
090b7c7c g     F .text	00000070 udp_lookup
09099730 g     F .text	00000054 alt_avalon_sgdma_start
0908d1e4 g     F .text	00000144 OSEventNameSet
09086acc g     F .text	000001fc _fflush_r
0909b558 g     F .text	00000098 alt_tse_mac_set_duplex
0908a108 g     F .text	000000b4 _calloc_r
090d3044 g     O .bss	00000001 OSRdyGrp
090c5b90 g     F .text	00000028 md_fopen
090d2ae8 g     O .rwdata	00000018 udp_protosw
090d2f80 g     O .rwdata	00000008 alt_flash_dev_list
090961f8 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
090c6eac g     F .text	0000007c in_setsockaddr
090d2fc0 g       *ABS*	00000000 __bss_start
09081090 g     F .text	00000074 LED7SegLightshowTask
090b0b60 g     F .text	000000e0 sbappendrecord
090dd990 g     O .bss	00000050 ip_mib
090823f8 g     F .text	00000098 memset
090ae6a4 g     F .text	000000a0 sodisconnect
09080f24 g     F .text	0000007c main
090d3000 g     O .bss	00000004 alt_envp
090d2ff0 g     O .bss	00000004 __malloc_max_total_mem
09081818 g     F .text	00000070 sss_reset_connection
090aa90c g     F .text	000001d0 m_adj
0909752c g     F .text	00000058 altera_avalon_jtag_uart_write_fd
090851a8 g     F .text	0000001c __swbuf
090c5e28 g     F .text	000000d8 md_fgetc
090cccbc g     O .rodata	00000100 OSUnMapTbl
090bebcc g     F .text	000002b8 ip_dump
090a5048 g     F .text	00000208 tk_stats
090d2f18 g     O .rwdata	00000008 alt_iniche_dev_list
090d7868 g     O .bss	00000078 SSSLEDCommandQTbl
09099000 g     F .text	0000017c altera_avalon_lcd_16207_init
090d2f0c g     O .rwdata	00000008 alt_sgdma_list
090d2eca g     O .rwdata	00000002 OSSemEn
090d30f0 g     O .bss	00000004 OS_TPS
090abd50 g     F .text	000007e8 rawip_usrreq
090903dc g     F .text	000003a8 OSFlagPost
09089e88 g     F .text	00000008 __sclose
090c6450 g     F .text	00000060 print46_addr
09100000 g       *ABS*	00000000 __alt_heap_limit
0908a33c g     F .text	00000014 fclose
0908e248 g     F .text	00000110 OS_EventTaskWait
090ca7ec g     F .text	00000244 _strtol_r
090a41d0 g     F .text	000001bc print_uptime
0908ee4c g     F .text	000000c8 OS_TaskStatStkChk
090dda70 g     O .bss	00000190 _atexit0
09094114 g     F .text	00000170 OSTaskDelReq
09085518 g     F .text	000015b4 _dtoa_r
09087dbc g     F .text	00000740 _malloc_r
090c5f00 g     F .text	00000024 md_unlink
0909a2d8 g     F .text	00000094 tse_mac_SwReset
090c6994 g     F .text	00000054 in_pcbdetach
090d2f7c g     O .rwdata	00000004 alt_errno
090d2fb4 g     O .rwdata	00000004 mdlist_size
0908dd1c g     F .text	00000070 OSStart
09096284 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
090c5060 g     F .text	00000030 u_mctest_init
0908ce80 g     F .text	0000005c __env_unlock
09087aac g     F .text	000000b8 _fwalk
09094600 g     F .text	00000218 OSTaskResume
090912f8 g     F .text	000000fc OSMemQuery
090c65e8 g     F .text	0000014c convert_ip
090bbeac g     F .text	000001f4 find_oldest_arp
090d2edc g     O .rwdata	00000002 OSTaskStatEn
090d316c g     O .bss	00000004 arpReqsIn
090c739c g     F .text	00000050 vf_free_buffer
09095be0 g     F .text	00000164 alt_write_value_to_flash
090c8dc4 g     F .text	00000154 alt_fcntl
090d2eb6 g     O .rwdata	00000002 OSMemMax
09092210 g     F .text	00000188 OSQPostFront
09096300 g     F .text	00000034 alt_write_native_16bit
090a9488 g     F .text	00000030 dtrap
090d2f48 g     O .rwdata	00000004 kb_last
09082588 g     F .text	00000104 putc
09080000 g       *ABS*	00000000 __alt_mem_onchip_SRAM
0908c248 g     F .text	00000060 __divsi3
0909b1bc g     F .text	00000048 alt_tse_mac_set_common_speed
090d3045 g     O .bss	00000003 OSRdyTbl
090d2e90 g     O .rwdata	00000002 OSDebugEn
090ccb98 g     O .rodata	00000014 __thenan_df
090a2048 g     F .text	000000d0 ip_exit
09087108 g     F .text	0000012c _malloc_trim_r
090caef8 g       *ABS*	00000000 __CTOR_END__
090d2ea8 g     O .rwdata	00000002 OSFlagNodeSize
090d30a4 g     O .bss	00000004 dhc_conn
090a961c g     F .text	000000ac cticks_hook
090d2ef0 g     O .rwdata	00000002 OSTmrCfgMax
090baf24 g     F .text	00000090 sysuptime
09089fd4 g     F .text	000000bc strcmp
090c0944 g     F .text	000001c8 ip_reasm_delete_ire
09091618 g     F .text	00000214 OSQCreate
090a96c8 g     F .text	0000005c irq_Mask
09094284 g     F .text	000001b8 OSTaskNameGet
090d3158 g     O .bss	00000004 nextppp
090d30e4 g     O .bss	00000004 irq_level
090a1468 g     F .text	00000160 fixup_subnet_mask
09092398 g     F .text	00000234 OSQPostOpt
0908de38 g     F .text	00000240 OSTimeTick
090bf0f0 g     F .text	00000138 ip_copypkt
090a8334 g     F .text	00000090 dhc_alldone
090d2ed8 g     O .rwdata	00000002 OSTaskMax
090caef8 g       *ABS*	00000000 __DTOR_LIST__
090928b8 g     F .text	00000114 OSSemCreate
090d3088 g     O .bss	00000004 igmp_all_hosts_group
090d2efc g     O .rwdata	00000002 OSTmrWheelSize
090b0854 g     F .text	00000038 sbselqueue
090d3090 g     O .bss	00000004 netmain_wakes
090bc448 g     F .text	00000260 arprcv
090a4c94 g     F .text	00000070 TK_OSTaskResume
090a2ec0 g     F .text	000003e0 igmp_print_stats
0908bc48 g     F .text	00000088 __nedf2
090aa158 g     F .text	000000a0 pffindtype
090d2ed2 g     O .rwdata	00000002 OSTaskDelEn
090d2f60 g     O .rwdata	00000004 tcp_sendspace
090c84fc g     F .text	00000134 vftell
090dd0ec g     O .bss	00000012 eth_prt_buf
0909318c g     F .text	00000130 OSSemQuery
0909182c g     F .text	00000300 OSQDel
09091f14 g     F .text	0000017c OSQPendAbort
09095468 g     F .text	00000034 alt_irq_init
0909b17c g     F .text	00000040 alt_tse_mac_get_common_speed
090dd554 g     O .bss	00000018 app_semaphore
090b987c g     F .text	00000060 alt_release_fd
090a9b78 g     F .text	00000078 post_app_sem
090a21a8 g     F .text	000000f0 igmp_init
090828ac g     F .text	00000074 sprintf
090ccbac g     O .rodata	00000100 __clz_tab
090d30cc g     O .bss	00000004 dsc_renew
090c5d58 g     F .text	00000080 md_fwrite
090d2fe4 g     O .bss	00000004 _PathLocale
090d30f4 g     O .bss	00000004 tcp_sleep_count
090aac4c g     F .text	0000007c insque
090ca498 g     F .text	00000014 atexit
090d31c0 g     O .bss	00000004 vfsfiles
0908a090 g     F .text	00000078 _write_r
090caa88 g     F .text	00000050 _vsprintf_r
090c36d0 g     F .text	000002b8 udp_send
0908dbac g     F .text	0000008c OSSchedLock
090a25c4 g     F .text	000002a8 igmp_send
09087c0c g     F .text	0000001c setlocale
0908f6b4 g     F .text	0000013c OSFlagCreate
090d78e0 g     O .bss	00002000 LEDManagementTaskStk
090a9724 g     F .text	00000044 irq_Unmask
090ac790 g     F .text	000000e4 t_listen
090d2e6c g     O .rwdata	00000004 _impure_ptr
090d0e8c g     O .rwdata	00000018 ssstask
090d2ff8 g     O .bss	00000004 alt_argc
090b7244 g     F .text	00000704 tcp_usrreq
090b7ea4 g     F .text	00000284 udp_usrreq
090aa0b8 g     F .text	00000054 ncpalloc
090b8e68 g     F .text	00000064 _do_dtors
090d2ea2 g     O .rwdata	00000002 OSEventMultiEn
090d2f9c g     O .rwdata	00000004 pingdelay
090bb9a0 g     F .text	00000074 arp_send_pending
090dcb04 g     O .bss	000000e0 tse_mac_if
090c3cb4 g     F .text	000002f0 igmpv1_input
09089bc8 g     F .text	000001c4 __srefill_r
090a9e0c g     F .text	00000074 pre_task_setup
090d3114 g     O .bss	00000004 rcvdq_sem_ptr
090a3504 g     F .text	0000012c bsd_getsockname
090c0b0c g     F .text	00000148 ip_reasm_mark_compact_rfq
0908f7f0 g     F .text	000002a8 OSFlagDel
090d3048 g     O .bss	00000004 OSEventFreeList
090a539c g     F .text	00000044 dhc_set_callback
09080120 g       .exceptions	00000000 alt_irq_entry
090d3168 g     O .bss	00000004 arpcache
090c9dc0 g     F .text	00000350 icmp_destun
090c20e4 g     F .text	00000070 lookup_mcast
090c88d0 g     F .text	00000048 vfslookup
090c1a34 g     F .text	00000430 ip_demux
0908879c g     F .text	00000080 __ulp
09089da8 g     F .text	00000040 __isinfd
090d30f8 g     O .bss	00000004 tcp_wakeup_count
0908fd30 g     F .text	00000644 OSFlagPend
090d2eee g     O .rwdata	00000002 OSTmrEn
09086e18 g     F .text	00000018 __fp_unlock_all
090a9ac4 g     F .text	000000b4 wait_app_sem
0909917c g     F .text	00000058 altera_avalon_lcd_16207_write_fd
09086fbc g     F .text	00000064 fputc
090d2f20 g     O .rwdata	00000004 ipmcfail_str
090d310c g     O .bss	00000004 memtrapsize
090aa5e8 g     F .text	00000324 m_copy
090d2f68 g     O .rwdata	00000008 alt_fs_list
090dd5d0 g     O .bss	00000014 mfreeq
0908ec38 g     F .text	00000080 OS_StrCopy
090adf00 g     F .text	0000005c sobind
090c5b18 g     F .text	00000078 init_memdev
090d2fc0 g     O .bss	00000001 to_ssstask
090961b0 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
090aacc8 g     F .text	00000124 nptcp_init
090d2eb8 g     O .rwdata	00000002 OSMemNameSize
090dd424 g     O .bss	000000f0 global_TCPwakeup_set
090ba300 g     F .text	0000001c OSInitHookEnd
090b0310 g     F .text	000000bc soisdisconnected
090bb918 g     F .text	00000088 arp_free_pending
090d2ee4 g     O .rwdata	00000002 OSTCBPrioTblMax
09087b78 g     F .text	00000010 localeconv
090ae17c g     F .text	00000368 soclose
090dd314 g     O .bss	00000014 bigfreeq
090d2ee0 g     O .rwdata	00000002 OSTaskStatStkChkEn
090d2f98 g     O .rwdata	00000004 prompt
090d2f58 g     O .rwdata	00000004 tcp_keepidle
0909e650 g     F .text	00000198 alt_tse_phy_set_adv_10
090abb7c g     F .text	000001d4 rawip_soinput
090b9030 g     F .text	00000050 alt_ic_isr_register
090c8320 g     F .text	00000060 vfwrite
090d2eb4 g     O .rwdata	00000002 OSMemEn
090b05e8 g     F .text	000000ac soqinsque
090d319c g     O .bss	00000004 so_evtmap_delete
09082110 g     F .text	00000040 fwrite
090d2ebe g     O .rwdata	00000002 OSMutexEn
090d3188 g     O .bss	00000004 h_ireq
090d2fc0 g       *ABS*	00000000 _edata
090be4f4 g     F .text	0000062c ip_fragment
090a0bf0 g     F .text	00000144 iniche_devices_init
090dd5e4 g     O .bss	00000028 tcp_saveti
090a477c g     F .text	000000f8 con_page
090ddc00 g       *ABS*	00000000 _end
090afb98 g     F .text	00000540 sogetopt
090b8f60 g     F .text	0000007c alt_flash_open_dev
090d304c g     O .bss	00000001 OSIntNesting
0909d60c g     F .text	00000238 alt_tse_mac_associate_phy
090d2aa0 g     O .rwdata	00000030 nettasks
090a8c84 g     F .text	00000020 pk_get_max_intrsafe_buf_len
090bee84 g     F .text	0000026c iproute
090ab610 g     F .text	000000e8 np_stripoptions
090d31a0 g     O .bss	00000001 so_evtmap
09097ba0 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
09087078 g     F .text	00000074 _fputs_r
09095190 g     F .text	00000210 OSTimeDlyResume
09081754 g     F .text	000000c4 SSSCreateTasks
090c290c g     F .text	00000428 add_route
0908fbdc g     F .text	00000154 OSFlagNameSet
090a1a84 g     F .text	000000d0 c_older
090b1030 g     F .text	00000090 sbflush
090c5bb8 g     F .text	00000020 md_fclose
090a501c g     F .text	0000002c tk_yield
09081a18 g     F .text	000000c0 sss_handle_accept
09094818 g     F .text	000001fc OSTaskStkChk
090b911c g     F .text	000000a0 alt_ic_irq_disable
090ae744 g     F .text	00000608 sosend
090d2eba g     O .rwdata	00000002 OSMemSize
090beb20 g     F .text	000000ac ip_mymach
09099904 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
09089ef8 g     F .text	0000007c __swrite
090d30e0 g     O .bss	00000004 cticks_initialized
090d2fa0 g     O .rwdata	00000004 deflength
090ad5f8 g     F .text	0000022c t_sendto
090d2e7c g     O .rwdata	00000004 __malloc_trim_threshold
09082490 g     F .text	0000006c _perror_r
090b9e44 g     F .text	00000020 altera_nios2_qsys_irq_init
090d3050 g     O .bss	00000004 OSTCBCur
090add34 g     F .text	000001cc socreate
090ca4e0 g     F .text	00000038 exit
090dd87c g     O .bss	00000100 arp_table
090d31d8 g     O .bss	00000004 icmpdu_hook
090d2ebc g     O .rwdata	00000002 OSMemTblSize
090879e4 g     F .text	000000c8 _fwalk_reent
090bb5f4 g     F .text	00000024 create_apptasks
090d2f54 g     O .rwdata	00000004 tcp_ttl
09088d98 g     F .text	0000018c __mdiff
090b8fdc g     F .text	00000054 alt_flash_close_dev
090aa10c g     F .text	0000004c ncpfree
0908c2a8 g     F .text	00000060 __modsi3
090d306c g     O .bss	00000004 MaxLnh
0909a3c4 g     F .text	00000054 tse_mac_setGMIImode
090c63c4 g     F .text	0000008c inet_ntop
090c3c48 g     F .text	0000002c udp_maxalloc
0909f090 g     F .text	000000f4 marvell_cfg_gmii
09100000 g       *ABS*	00000000 __alt_data_end
09080120 g     F .exceptions	00000000 alt_exception
09086d58 g     F .text	00000004 __sfp_lock_release
0908d9dc g     F .text	00000054 OSInit
0909d844 g     F .text	00000120 alt_tse_phy_cfg_pcs
09094c40 g     F .text	00000144 OSTaskQuery
090bad14 g     F .text	00000088 icmp_port_du
090d313c g     O .bss	00000004 tcp_iss
0909274c g     F .text	000000ac OS_QInit
090ca4b8 g     F .text	0000000c atoi
090d2f44 g     O .rwdata	00000004 bigbufsiz
0908ecb8 g     F .text	00000058 OS_StrLen
090b69b4 g     F .text	00000080 tcp_putseq
090910e8 g     F .text	00000120 OSMemNameSet
090cbf70 g     O .rodata	00000101 _ctype_
090b0c40 g     F .text	00000208 sbappendaddr
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
090d31d0 g     O .bss	00000004 vfs_total_rw_space
090c4e9c g     F .text	00000140 ip_getmoptions
090d2ed6 g     O .rwdata	00000002 OSTaskProfileEn
090c3988 g     F .text	00000130 udpswap
090d3054 g     O .bss	00000004 OSTime
090d3118 g     O .bss	00000004 nextslow
090b6aac g     F .text	000002a0 tcp_slowtimo
090b66bc g     F .text	00000118 tcp_newtcpcb
090bc6a8 g     F .text	000001cc send_via_arp
090a52e0 g     F .text	000000bc dhc_init
090c0468 g     F .text	00000064 ip_reasm_find_ire
090db260 g     O .bss	00000800 OSTaskIdleStk
090caec8 g     F .text	0000002c _exit
090c8b00 g     F .text	00000064 isvfile_locked
09089de8 g     F .text	00000030 __isnand
090a3b9c g     F .text	000001cc bsd_select
090b899c g     F .text	00000154 alt_alarm_start
0908fa98 g     F .text	00000144 OSFlagNameGet
090c3c74 g     F .text	00000040 udp_free
090a8d50 g     F .text	000000c8 getq
090c8c74 g     F .text	00000024 prep_vfs
090953a0 g     F .text	00000064 OSTimeGet
090d2f94 g     O .rwdata	00000004 name
090b1290 g     F .text	00000110 sbdropend
09087c28 g     F .text	00000194 __smakebuf_r
09096334 g     F .text	00000030 alt_write_native_32bit
090bc874 g     F .text	000001a4 cb_arpent_tmo
090830d4 g     F .text	00000074 strlen
090c4764 g     F .text	00000148 IPADDR_TO_NETP
090a3a0c g     F .text	00000030 bsd_inet_ntoa
090ba284 g     F .text	0000001c OSTaskSwHook
090b9514 g     F .text	00000188 open
090a8fd8 g     F .text	00000238 udp_open
090dba60 g     O .bss	00000b40 OSEventTbl
090b07b4 g     F .text	00000050 socantsendmore
090d31d4 g     O .bss	00000004 vfs_total_dyna_files
0908bd58 g     F .text	00000088 __gedf2
090dc5a0 g     O .bss	00000510 OSTCBTbl
090d3170 g     O .bss	00000004 arpReqsOut
090932bc g     F .text	00000104 OSSemSet
090d2fbc g     O .rwdata	00000004 http_root_path
090a74e4 g     F .text	000002bc dhc_extract_opts
090bf944 g     F .text	00000590 ip_reasm_compute_overlap
09095ae8 g     F .text	00000090 alt_flash_cfi_get_info
0909a234 g     F .text	000000a4 tse_mac_aRxRead
09082980 g     F .text	000000e0 strchr
090dd0fe g     O .bss	00000012 ipreturn
090d3190 g     O .bss	00000004 port_prep
090d2b23 g     O .rwdata	0000000d tcp_backoff
090b011c g     F .text	0000006c soisconnecting
09080eac g     F .text	00000078 SSSInitialTask
090870ec g     F .text	0000001c fputs
090d2f88 g     O .rwdata	00000004 alt_priority_mask
090c4250 g     F .text	0000024c igmpv2_process_query
090b1434 g     F .text	00000220 t_select
090929cc g     F .text	000002a0 OSSemDel
090b8840 g     F .text	0000015c udp4_sockaddr
090d3058 g     O .bss	00000004 OSFlagFreeList
090c6c3c g     F .text	00000210 in_pcbconnect
090d3130 g     O .bss	00000004 dropline
090d318c g     O .bss	00000004 ire_cticks
090b9080 g     F .text	0000009c alt_ic_irq_enable
090d2e9c g     O .rwdata	00000002 OSEventNameSize
09085054 g     F .text	00000024 __vfprintf_internal
090a4b94 g     F .text	00000088 tk_netmain
090c6e4c g     F .text	00000060 in_pcbdisconnect
090d305c g     O .bss	00000001 OSStatRdy
090dcab0 g     O .bss	00000054 OSTCBPrioTbl
0908cdd4 g     F .text	000000ac __env_lock
090d2ee2 g     O .rwdata	00000002 OSTaskSwHookEn
090d2cfc g     O .rwdata	00000024 mdio
0909b46c g     F .text	000000ec alt_tse_mac_set_speed
090994a4 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
090a32a0 g     F .text	00000138 bsd_accept
090d2f64 g     O .rwdata	00000004 tcp_recvspace
0908b4c0 g     F .text	00000080 __subdf3
090b7c30 g     F .text	0000004c tcpinit
090d308c g     O .bss	00000004 igmp_all_rtrs_group
090abb0c g     F .text	00000070 rawip_lookup
090bb698 g     F .text	000000b0 fcntl
09088678 g     F .text	000000c4 __lo0bits
090b0e48 g     F .text	000001e8 sbcompress
090d2f8c g     O .rwdata	00000008 alt_alarm_list
090b67d4 g     F .text	000000ac tcp_drop
090d2eaa g     O .rwdata	00000002 OSFlagWidth
090b8e04 g     F .text	00000064 _do_ctors
0909e440 g     F .text	00000210 alt_tse_phy_set_adv_100
090b6da8 g     F .text	0000049c tcp_timers
090a2118 g     F .text	00000090 if_netnumber
090c4fdc g     F .text	00000084 ip_freemoptions
090b00d8 g     F .text	00000044 sohasoutofband
090b2150 g     F .text	00002554 tcp_input
090a33d8 g     F .text	0000012c bsd_getpeername
090a3a3c g     F .text	00000160 bsd_recvfrom
090a0b9c g     F .text	00000054 close
090d30bc g     O .bss	00000004 dsc_bpreplys
090ba358 g     F .text	00000068 alt_program_amd
090d3008 g     O .bss	00000004 alt_envsem
090d3060 g     O .bss	00000004 OSIdleCtrRun
0908e078 g     F .text	00000020 OSVersion
090d2ef4 g     O .rwdata	00000002 OSTmrCfgWheelSize
09094d84 g     F .text	0000007c OS_TaskStkClr
090c7200 g     F .text	00000028 set_vfopen_error
0908c398 g     F .text	00000314 __pack_d
090d2ece g     O .rwdata	00000002 OSTaskCreateEn
0909b204 g     F .text	0000007c alt_tse_get_system_index
090d2b00 g     O .rwdata	00000018 rawip_protosw
090b088c g     F .text	00000068 sbwait
0908e668 g     F .text	00000068 OS_EventWaitListInit
090a77a0 g     F .text	000008dc dhc_second
09099f0c g     F .text	000000ac alt_avalon_sgdma_init
090d315c g     O .bss	00000004 port_1s_callout
090ba31c g     F .text	0000001c OSTaskIdleHook
090ca518 g     F .text	00000014 free
09086d5c g     F .text	00000004 __sinit_lock_acquire
090d3068 g     O .bss	00000001 number_of_tse_mac
09089294 g     F .text	00000100 __multadd
09094a14 g     F .text	0000022c OSTaskSuspend
090885e0 g     F .text	00000028 _Bfree
0909a0b8 g     F .text	0000002c no_printf
090b03cc g     F .text	0000021c sonewconn
090c918c g     F .text	00000c34 icmprcv
090aa1f8 g     F .text	000000d0 pffindproto
0908ed10 g     F .text	0000005c OS_TaskIdle
090d2efa g     O .rwdata	00000002 OSTmrTblSize
090925cc g     F .text	00000180 OSQQuery



Disassembly of section .exceptions:

09080120 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 9080120:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 9080124:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 9080128:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 908012c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 9080130:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 9080134:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 9080138:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 908013c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 9080140:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 9080144:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 9080148:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 908014c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 9080150:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 9080154:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 9080158:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 908015c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 9080160:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 9080164:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 9080168:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 908016c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 9080170:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 9080174:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 9080178:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 908017c:	10000326 	beq	r2,zero,908018c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 9080180:	20000226 	beq	r4,zero,908018c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 9080184:	90801ec0 	call	90801ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 9080188:	00000306 	br	9080198 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 908018c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 9080190:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 9080194:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 9080198:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 908019c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 90801a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 90801a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 90801a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 90801ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 90801b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 90801b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 90801b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 90801bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 90801c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 90801c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 90801c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 90801cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 90801d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 90801d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 90801d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 90801dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 90801e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 90801e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 90801e8:	ef80083a 	eret

090801ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 90801ec:	defff904 	addi	sp,sp,-28
 90801f0:	dfc00615 	stw	ra,24(sp)
 90801f4:	df000515 	stw	fp,20(sp)
 90801f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 90801fc:	908da300 	call	908da30 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 9080200:	0005313a 	rdctl	r2,ipending
 9080204:	e0bffc15 	stw	r2,-16(fp)

  return active;
 9080208:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 908020c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 9080210:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 9080214:	00800044 	movi	r2,1
 9080218:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 908021c:	e0ffff17 	ldw	r3,-4(fp)
 9080220:	e0bffe17 	ldw	r2,-8(fp)
 9080224:	1884703a 	and	r2,r3,r2
 9080228:	1005003a 	cmpeq	r2,r2,zero
 908022c:	1000161e 	bne	r2,zero,9080288 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 9080230:	e0bffd17 	ldw	r2,-12(fp)
 9080234:	00c243b4 	movhi	r3,2318
 9080238:	18f5c604 	addi	r3,r3,-10472
 908023c:	100490fa 	slli	r2,r2,3
 9080240:	10c5883a 	add	r2,r2,r3
 9080244:	11400017 	ldw	r5,0(r2)
 9080248:	e0bffd17 	ldw	r2,-12(fp)
 908024c:	00c243b4 	movhi	r3,2318
 9080250:	18f5c604 	addi	r3,r3,-10472
 9080254:	100490fa 	slli	r2,r2,3
 9080258:	10c5883a 	add	r2,r2,r3
 908025c:	10800104 	addi	r2,r2,4
 9080260:	11000017 	ldw	r4,0(r2)
 9080264:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 9080268:	0005313a 	rdctl	r2,ipending
 908026c:	e0bffb15 	stw	r2,-20(fp)

  return active;
 9080270:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 9080274:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 9080278:	e0bfff17 	ldw	r2,-4(fp)
 908027c:	1004c03a 	cmpne	r2,r2,zero
 9080280:	103fe31e 	bne	r2,zero,9080210 <alt_irq_handler+0x24>
 9080284:	00000706 	br	90802a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 9080288:	e0bffe17 	ldw	r2,-8(fp)
 908028c:	1085883a 	add	r2,r2,r2
 9080290:	e0bffe15 	stw	r2,-8(fp)
      i++;
 9080294:	e0bffd17 	ldw	r2,-12(fp)
 9080298:	10800044 	addi	r2,r2,1
 908029c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 90802a0:	003fde06 	br	908021c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 90802a4:	908daac0 	call	908daac <OSIntExit>
}
 90802a8:	e037883a 	mov	sp,fp
 90802ac:	dfc00117 	ldw	ra,4(sp)
 90802b0:	df000017 	ldw	fp,0(sp)
 90802b4:	dec00204 	addi	sp,sp,8
 90802b8:	f800283a 	ret

Disassembly of section .text:

090802bc <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 90802bc:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 90802c0:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 90802c4:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 90802c8:	00bffd16 	blt	zero,r2,90802c0 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 90802cc:	06c24434 	movhi	sp,2320
    ori sp, sp, %lo(__alt_stack_pointer)
 90802d0:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 90802d4:	06824374 	movhi	gp,2317
    ori gp, gp, %lo(_gp)
 90802d8:	d6ab9a14 	ori	gp,gp,44648
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 90802dc:	00824374 	movhi	r2,2317
    ori r2, r2, %lo(__bss_start)
 90802e0:	108bf014 	ori	r2,r2,12224

    movhi r3, %hi(__bss_end)
 90802e4:	00c24374 	movhi	r3,2317
    ori r3, r3, %lo(__bss_end)
 90802e8:	18f70014 	ori	r3,r3,56320

    beq r2, r3, 1f
 90802ec:	10c00326 	beq	r2,r3,90802fc <_start+0x40>

0:
    stw zero, (r2)
 90802f0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 90802f4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 90802f8:	10fffd36 	bltu	r2,r3,90802f0 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 90802fc:	908cc500 	call	908cc50 <alt_main>

09080300 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 9080300:	003fff06 	br	9080300 <alt_after_alt_main>

09080304 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 9080304:	defff904 	addi	sp,sp,-28
 9080308:	dfc00615 	stw	ra,24(sp)
 908030c:	df000515 	stw	fp,20(sp)
 9080310:	df000504 	addi	fp,sp,20
 9080314:	e17ffd15 	stw	r5,-12(fp)
 9080318:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 908031c:	e0bffc03 	ldbu	r2,-16(fp)
 9080320:	1005003a 	cmpeq	r2,r2,zero
 9080324:	10017b1e 	bne	r2,zero,9080914 <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 9080328:	00800084 	movi	r2,2
 908032c:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 9080330:	908dbac0 	call	908dbac <OSSchedLock>
      
   switch (error_code)
 9080334:	e0bffc03 	ldbu	r2,-16(fp)
 9080338:	e0bffe15 	stw	r2,-8(fp)
 908033c:	e0fffe17 	ldw	r3,-8(fp)
 9080340:	18800a20 	cmpeqi	r2,r3,40
 9080344:	1000371e 	bne	r2,zero,9080424 <alt_uCOSIIErrorHandler+0x120>
 9080348:	e0fffe17 	ldw	r3,-8(fp)
 908034c:	18800a48 	cmpgei	r2,r3,41
 9080350:	10001a1e 	bne	r2,zero,90803bc <alt_uCOSIIErrorHandler+0xb8>
 9080354:	e0fffe17 	ldw	r3,-8(fp)
 9080358:	18800120 	cmpeqi	r2,r3,4
 908035c:	1000761e 	bne	r2,zero,9080538 <alt_uCOSIIErrorHandler+0x234>
 9080360:	e0fffe17 	ldw	r3,-8(fp)
 9080364:	18800148 	cmpgei	r2,r3,5
 9080368:	10000a1e 	bne	r2,zero,9080394 <alt_uCOSIIErrorHandler+0x90>
 908036c:	e0fffe17 	ldw	r3,-8(fp)
 9080370:	188000a0 	cmpeqi	r2,r3,2
 9080374:	1000911e 	bne	r2,zero,90805bc <alt_uCOSIIErrorHandler+0x2b8>
 9080378:	e0fffe17 	ldw	r3,-8(fp)
 908037c:	188000c8 	cmpgei	r2,r3,3
 9080380:	1000771e 	bne	r2,zero,9080560 <alt_uCOSIIErrorHandler+0x25c>
 9080384:	e0fffe17 	ldw	r3,-8(fp)
 9080388:	18800060 	cmpeqi	r2,r3,1
 908038c:	10005e1e 	bne	r2,zero,9080508 <alt_uCOSIIErrorHandler+0x204>
 9080390:	0000d806 	br	90806f4 <alt_uCOSIIErrorHandler+0x3f0>
 9080394:	e0fffe17 	ldw	r3,-8(fp)
 9080398:	18800520 	cmpeqi	r2,r3,20
 908039c:	10004f1e 	bne	r2,zero,90804dc <alt_uCOSIIErrorHandler+0x1d8>
 90803a0:	e0fffe17 	ldw	r3,-8(fp)
 90803a4:	188007a0 	cmpeqi	r2,r3,30
 90803a8:	1000ad1e 	bne	r2,zero,9080660 <alt_uCOSIIErrorHandler+0x35c>
 90803ac:	e0fffe17 	ldw	r3,-8(fp)
 90803b0:	188002a0 	cmpeqi	r2,r3,10
 90803b4:	1000761e 	bne	r2,zero,9080590 <alt_uCOSIIErrorHandler+0x28c>
 90803b8:	0000ce06 	br	90806f4 <alt_uCOSIIErrorHandler+0x3f0>
 90803bc:	e0fffe17 	ldw	r3,-8(fp)
 90803c0:	18801020 	cmpeqi	r2,r3,64
 90803c4:	10009c1e 	bne	r2,zero,9080638 <alt_uCOSIIErrorHandler+0x334>
 90803c8:	e0fffe17 	ldw	r3,-8(fp)
 90803cc:	18801048 	cmpgei	r2,r3,65
 90803d0:	10000a1e 	bne	r2,zero,90803fc <alt_uCOSIIErrorHandler+0xf8>
 90803d4:	e0fffe17 	ldw	r3,-8(fp)
 90803d8:	18800f60 	cmpeqi	r2,r3,61
 90803dc:	10008b1e 	bne	r2,zero,908060c <alt_uCOSIIErrorHandler+0x308>
 90803e0:	e0fffe17 	ldw	r3,-8(fp)
 90803e4:	18800fa0 	cmpeqi	r2,r3,62
 90803e8:	10007e1e 	bne	r2,zero,90805e4 <alt_uCOSIIErrorHandler+0x2e0>
 90803ec:	e0fffe17 	ldw	r3,-8(fp)
 90803f0:	18800aa0 	cmpeqi	r2,r3,42
 90803f4:	1000151e 	bne	r2,zero,908044c <alt_uCOSIIErrorHandler+0x148>
 90803f8:	0000be06 	br	90806f4 <alt_uCOSIIErrorHandler+0x3f0>
 90803fc:	e0fffe17 	ldw	r3,-8(fp)
 9080400:	18801920 	cmpeqi	r2,r3,100
 9080404:	1000a11e 	bne	r2,zero,908068c <alt_uCOSIIErrorHandler+0x388>
 9080408:	e0fffe17 	ldw	r3,-8(fp)
 908040c:	18803fe0 	cmpeqi	r2,r3,255
 9080410:	1000aa1e 	bne	r2,zero,90806bc <alt_uCOSIIErrorHandler+0x3b8>
 9080414:	e0fffe17 	ldw	r3,-8(fp)
 9080418:	188010a0 	cmpeqi	r2,r3,66
 908041c:	10001d1e 	bne	r2,zero,9080494 <alt_uCOSIIErrorHandler+0x190>
 9080420:	0000b406 	br	90806f4 <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 9080424:	00824374 	movhi	r2,2317
 9080428:	108b9b04 	addi	r2,r2,11884
 908042c:	10800017 	ldw	r2,0(r2)
 9080430:	11c00317 	ldw	r7,12(r2)
 9080434:	01024374 	movhi	r4,2317
 9080438:	212bbe04 	addi	r4,r4,-20744
 908043c:	01400044 	movi	r5,1
 9080440:	01800c44 	movi	r6,49
 9080444:	90821100 	call	9082110 <fwrite>
         break;
 9080448:	0000c106 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 908044c:	00824374 	movhi	r2,2317
 9080450:	108b9b04 	addi	r2,r2,11884
 9080454:	10800017 	ldw	r2,0(r2)
 9080458:	11c00317 	ldw	r7,12(r2)
 908045c:	01024374 	movhi	r4,2317
 9080460:	212bcb04 	addi	r4,r4,-20692
 9080464:	01400044 	movi	r5,1
 9080468:	01800c44 	movi	r6,49
 908046c:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 9080470:	00824374 	movhi	r2,2317
 9080474:	108b9b04 	addi	r2,r2,11884
 9080478:	10800017 	ldw	r2,0(r2)
 908047c:	11000317 	ldw	r4,12(r2)
 9080480:	01424374 	movhi	r5,2317
 9080484:	296bd804 	addi	r5,r5,-20640
 9080488:	01800504 	movi	r6,20
 908048c:	90820140 	call	9082014 <fprintf>
            OS_LOWEST_PRIO);
         break;
 9080490:	0000af06 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 9080494:	00824374 	movhi	r2,2317
 9080498:	108b9b04 	addi	r2,r2,11884
 908049c:	10800017 	ldw	r2,0(r2)
 90804a0:	11c00317 	ldw	r7,12(r2)
 90804a4:	01024374 	movhi	r4,2317
 90804a8:	212be504 	addi	r4,r4,-20588
 90804ac:	01400044 	movi	r5,1
 90804b0:	01800a04 	movi	r6,40
 90804b4:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 90804b8:	00824374 	movhi	r2,2317
 90804bc:	108b9b04 	addi	r2,r2,11884
 90804c0:	10800017 	ldw	r2,0(r2)
 90804c4:	11000317 	ldw	r4,12(r2)
 90804c8:	01424374 	movhi	r5,2317
 90804cc:	296bf004 	addi	r5,r5,-20544
 90804d0:	01800284 	movi	r6,10
 90804d4:	90820140 	call	9082014 <fprintf>
         break;
 90804d8:	00009d06 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 90804dc:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 90804e0:	00824374 	movhi	r2,2317
 90804e4:	108b9b04 	addi	r2,r2,11884
 90804e8:	10800017 	ldw	r2,0(r2)
 90804ec:	11c00317 	ldw	r7,12(r2)
 90804f0:	01024374 	movhi	r4,2317
 90804f4:	212bf904 	addi	r4,r4,-20508
 90804f8:	01400044 	movi	r5,1
 90804fc:	01800c84 	movi	r6,50
 9080500:	90821100 	call	9082110 <fwrite>
         break;
 9080504:	00009206 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 9080508:	00800044 	movi	r2,1
 908050c:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 9080510:	00824374 	movhi	r2,2317
 9080514:	108b9b04 	addi	r2,r2,11884
 9080518:	10800017 	ldw	r2,0(r2)
 908051c:	11c00317 	ldw	r7,12(r2)
 9080520:	01024374 	movhi	r4,2317
 9080524:	212c0604 	addi	r4,r4,-20456
 9080528:	01400044 	movi	r5,1
 908052c:	01801244 	movi	r6,73
 9080530:	90821100 	call	9082110 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 9080534:	00008606 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 9080538:	00824374 	movhi	r2,2317
 908053c:	108b9b04 	addi	r2,r2,11884
 9080540:	10800017 	ldw	r2,0(r2)
 9080544:	11c00317 	ldw	r7,12(r2)
 9080548:	01024374 	movhi	r4,2317
 908054c:	212c1904 	addi	r4,r4,-20380
 9080550:	01400044 	movi	r5,1
 9080554:	01800c44 	movi	r6,49
 9080558:	90821100 	call	9082110 <fwrite>
         break;
 908055c:	00007c06 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 9080560:	00800044 	movi	r2,1
 9080564:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 9080568:	00824374 	movhi	r2,2317
 908056c:	108b9b04 	addi	r2,r2,11884
 9080570:	10800017 	ldw	r2,0(r2)
 9080574:	11c00317 	ldw	r7,12(r2)
 9080578:	01024374 	movhi	r4,2317
 908057c:	212c2604 	addi	r4,r4,-20328
 9080580:	01400044 	movi	r5,1
 9080584:	01800a44 	movi	r6,41
 9080588:	90821100 	call	9082110 <fwrite>
         break;
 908058c:	00007006 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 9080590:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 9080594:	00824374 	movhi	r2,2317
 9080598:	108b9b04 	addi	r2,r2,11884
 908059c:	10800017 	ldw	r2,0(r2)
 90805a0:	11c00317 	ldw	r7,12(r2)
 90805a4:	01024374 	movhi	r4,2317
 90805a8:	212c3104 	addi	r4,r4,-20284
 90805ac:	01400044 	movi	r5,1
 90805b0:	01800a04 	movi	r6,40
 90805b4:	90821100 	call	9082110 <fwrite>
         break;
 90805b8:	00006506 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 90805bc:	00824374 	movhi	r2,2317
 90805c0:	108b9b04 	addi	r2,r2,11884
 90805c4:	10800017 	ldw	r2,0(r2)
 90805c8:	11c00317 	ldw	r7,12(r2)
 90805cc:	01024374 	movhi	r4,2317
 90805d0:	212c3c04 	addi	r4,r4,-20240
 90805d4:	01400044 	movi	r5,1
 90805d8:	01800b04 	movi	r6,44
 90805dc:	90821100 	call	9082110 <fwrite>
         break;
 90805e0:	00005b06 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 90805e4:	00824374 	movhi	r2,2317
 90805e8:	108b9b04 	addi	r2,r2,11884
 90805ec:	10800017 	ldw	r2,0(r2)
 90805f0:	11c00317 	ldw	r7,12(r2)
 90805f4:	01024374 	movhi	r4,2317
 90805f8:	212c4804 	addi	r4,r4,-20192
 90805fc:	01400044 	movi	r5,1
 9080600:	01800884 	movi	r6,34
 9080604:	90821100 	call	9082110 <fwrite>
         break;
 9080608:	00005106 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 908060c:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 9080610:	00824374 	movhi	r2,2317
 9080614:	108b9b04 	addi	r2,r2,11884
 9080618:	10800017 	ldw	r2,0(r2)
 908061c:	11c00317 	ldw	r7,12(r2)
 9080620:	01024374 	movhi	r4,2317
 9080624:	212c5104 	addi	r4,r4,-20156
 9080628:	01400044 	movi	r5,1
 908062c:	01800bc4 	movi	r6,47
 9080630:	90821100 	call	9082110 <fwrite>
         break;
 9080634:	00004606 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 9080638:	00824374 	movhi	r2,2317
 908063c:	108b9b04 	addi	r2,r2,11884
 9080640:	10800017 	ldw	r2,0(r2)
 9080644:	11c00317 	ldw	r7,12(r2)
 9080648:	01024374 	movhi	r4,2317
 908064c:	212c5d04 	addi	r4,r4,-20108
 9080650:	01400044 	movi	r5,1
 9080654:	018009c4 	movi	r6,39
 9080658:	90821100 	call	9082110 <fwrite>
         break;
 908065c:	00003c06 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 9080660:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 9080664:	00824374 	movhi	r2,2317
 9080668:	108b9b04 	addi	r2,r2,11884
 908066c:	10800017 	ldw	r2,0(r2)
 9080670:	11c00317 	ldw	r7,12(r2)
 9080674:	01024374 	movhi	r4,2317
 9080678:	212c6704 	addi	r4,r4,-20068
 908067c:	01400044 	movi	r5,1
 9080680:	01800a84 	movi	r6,42
 9080684:	90821100 	call	9082110 <fwrite>
         break;
 9080688:	00003106 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 908068c:	00800044 	movi	r2,1
 9080690:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 9080694:	00824374 	movhi	r2,2317
 9080698:	108b9b04 	addi	r2,r2,11884
 908069c:	10800017 	ldw	r2,0(r2)
 90806a0:	11c00317 	ldw	r7,12(r2)
 90806a4:	01024374 	movhi	r4,2317
 90806a8:	212c7204 	addi	r4,r4,-20024
 90806ac:	01400044 	movi	r5,1
 90806b0:	01800c04 	movi	r6,48
 90806b4:	90821100 	call	9082110 <fwrite>
         break;
 90806b8:	00002506 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 90806bc:	00800084 	movi	r2,2
 90806c0:	e0bffb15 	stw	r2,-20(fp)
         printf(
 90806c4:	01024374 	movhi	r4,2317
 90806c8:	212c7f04 	addi	r4,r4,-19972
 90806cc:	90825100 	call	9082510 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 90806d0:	00824374 	movhi	r2,2317
 90806d4:	108b9b04 	addi	r2,r2,11884
 90806d8:	10800017 	ldw	r2,0(r2)
 90806dc:	11000317 	ldw	r4,12(r2)
 90806e0:	e1bffd17 	ldw	r6,-12(fp)
 90806e4:	01424374 	movhi	r5,2317
 90806e8:	296c8f04 	addi	r5,r5,-19908
 90806ec:	90820140 	call	9082014 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 90806f0:	00001706 	br	9080750 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 90806f4:	01024374 	movhi	r4,2317
 90806f8:	212c9a04 	addi	r4,r4,-19864
 90806fc:	90828380 	call	9082838 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 9080700:	00824374 	movhi	r2,2317
 9080704:	108b9b04 	addi	r2,r2,11884
 9080708:	10800017 	ldw	r2,0(r2)
 908070c:	11c00317 	ldw	r7,12(r2)
 9080710:	01024374 	movhi	r4,2317
 9080714:	212ca804 	addi	r4,r4,-19808
 9080718:	01400044 	movi	r5,1
 908071c:	01800404 	movi	r6,16
 9080720:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 9080724:	00824374 	movhi	r2,2317
 9080728:	108b9b04 	addi	r2,r2,11884
 908072c:	10800017 	ldw	r2,0(r2)
 9080730:	11000317 	ldw	r4,12(r2)
 9080734:	e1bffc03 	ldbu	r6,-16(fp)
 9080738:	01424374 	movhi	r5,2317
 908073c:	296cad04 	addi	r5,r5,-19788
 9080740:	90820140 	call	9082014 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 9080744:	01024374 	movhi	r4,2317
 9080748:	212cb204 	addi	r4,r4,-19768
 908074c:	90824fc0 	call	90824fc <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 9080750:	e0bffb17 	ldw	r2,-20(fp)
 9080754:	e0bfff15 	stw	r2,-4(fp)
 9080758:	e0ffff17 	ldw	r3,-4(fp)
 908075c:	18800060 	cmpeqi	r2,r3,1
 9080760:	1000071e 	bne	r2,zero,9080780 <alt_uCOSIIErrorHandler+0x47c>
 9080764:	e0ffff17 	ldw	r3,-4(fp)
 9080768:	18800070 	cmpltui	r2,r3,1
 908076c:	10003f1e 	bne	r2,zero,908086c <alt_uCOSIIErrorHandler+0x568>
 9080770:	e0ffff17 	ldw	r3,-4(fp)
 9080774:	188000a0 	cmpeqi	r2,r3,2
 9080778:	10001d1e 	bne	r2,zero,90807f0 <alt_uCOSIIErrorHandler+0x4ec>
 908077c:	00005806 	br	90808e0 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 9080780:	01024374 	movhi	r4,2317
 9080784:	212cc004 	addi	r4,r4,-19712
 9080788:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 908078c:	00824374 	movhi	r2,2317
 9080790:	108b9b04 	addi	r2,r2,11884
 9080794:	10800017 	ldw	r2,0(r2)
 9080798:	11c00317 	ldw	r7,12(r2)
 908079c:	01024374 	movhi	r4,2317
 90807a0:	212ccd04 	addi	r4,r4,-19660
 90807a4:	01400044 	movi	r5,1
 90807a8:	01800904 	movi	r6,36
 90807ac:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 90807b0:	00824374 	movhi	r2,2317
 90807b4:	108b9b04 	addi	r2,r2,11884
 90807b8:	10800017 	ldw	r2,0(r2)
 90807bc:	11c00317 	ldw	r7,12(r2)
 90807c0:	01024374 	movhi	r4,2317
 90807c4:	212cd704 	addi	r4,r4,-19620
 90807c8:	01400044 	movi	r5,1
 90807cc:	01800a04 	movi	r6,40
 90807d0:	90821100 	call	9082110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 90807d4:	908dc380 	call	908dc38 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 90807d8:	01003fc4 	movi	r4,255
 90807dc:	9093d080 	call	9093d08 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 90807e0:	e13ffc03 	ldbu	r4,-16(fp)
 90807e4:	000b883a 	mov	r5,zero
 90807e8:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
         break;
 90807ec:	00004806 	br	9080910 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 90807f0:	01024374 	movhi	r4,2317
 90807f4:	212ce204 	addi	r4,r4,-19576
 90807f8:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 90807fc:	00824374 	movhi	r2,2317
 9080800:	108b9b04 	addi	r2,r2,11884
 9080804:	10800017 	ldw	r2,0(r2)
 9080808:	11c00317 	ldw	r7,12(r2)
 908080c:	01024374 	movhi	r4,2317
 9080810:	212cf004 	addi	r4,r4,-19520
 9080814:	01400044 	movi	r5,1
 9080818:	01800984 	movi	r6,38
 908081c:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 9080820:	00824374 	movhi	r2,2317
 9080824:	108b9b04 	addi	r2,r2,11884
 9080828:	10800017 	ldw	r2,0(r2)
 908082c:	11c00317 	ldw	r7,12(r2)
 9080830:	01024374 	movhi	r4,2317
 9080834:	212cfa04 	addi	r4,r4,-19480
 9080838:	01400044 	movi	r5,1
 908083c:	01800bc4 	movi	r6,47
 9080840:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 9080844:	00824374 	movhi	r2,2317
 9080848:	108b9b04 	addi	r2,r2,11884
 908084c:	10800017 	ldw	r2,0(r2)
 9080850:	11c00317 	ldw	r7,12(r2)
 9080854:	01024374 	movhi	r4,2317
 9080858:	212d0604 	addi	r4,r4,-19432
 908085c:	01400044 	movi	r5,1
 9080860:	01800cc4 	movi	r6,51
 9080864:	90821100 	call	9082110 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 9080868:	003fff06 	br	9080868 <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 908086c:	00824374 	movhi	r2,2317
 9080870:	108b9b04 	addi	r2,r2,11884
 9080874:	10800017 	ldw	r2,0(r2)
 9080878:	11c00317 	ldw	r7,12(r2)
 908087c:	01024374 	movhi	r4,2317
 9080880:	212d1304 	addi	r4,r4,-19380
 9080884:	01400044 	movi	r5,1
 9080888:	01800904 	movi	r6,36
 908088c:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 9080890:	00824374 	movhi	r2,2317
 9080894:	108b9b04 	addi	r2,r2,11884
 9080898:	10800017 	ldw	r2,0(r2)
 908089c:	11c00317 	ldw	r7,12(r2)
 90808a0:	01024374 	movhi	r4,2317
 90808a4:	212d1d04 	addi	r4,r4,-19340
 90808a8:	01400044 	movi	r5,1
 90808ac:	01800c84 	movi	r6,50
 90808b0:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, 
 90808b4:	00824374 	movhi	r2,2317
 90808b8:	108b9b04 	addi	r2,r2,11884
 90808bc:	10800017 	ldw	r2,0(r2)
 90808c0:	11c00317 	ldw	r7,12(r2)
 90808c4:	01024374 	movhi	r4,2317
 90808c8:	212d2a04 	addi	r4,r4,-19288
 90808cc:	01400044 	movi	r5,1
 90808d0:	01800f84 	movi	r6,62
 90808d4:	90821100 	call	9082110 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 90808d8:	908dc380 	call	908dc38 <OSSchedUnlock>
         return;   
 90808dc:	00000d06 	br	9080914 <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 90808e0:	01024374 	movhi	r4,2317
 90808e4:	212d3a04 	addi	r4,r4,-19224
 90808e8:	90828380 	call	9082838 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 90808ec:	00824374 	movhi	r2,2317
 90808f0:	108b9b04 	addi	r2,r2,11884
 90808f4:	10800017 	ldw	r2,0(r2)
 90808f8:	11c00317 	ldw	r7,12(r2)
 90808fc:	01024374 	movhi	r4,2317
 9080900:	212d4804 	addi	r4,r4,-19168
 9080904:	01400044 	movi	r5,1
 9080908:	01800ac4 	movi	r6,43
 908090c:	90821100 	call	9082110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 9080910:	003fff06 	br	9080910 <alt_uCOSIIErrorHandler+0x60c>
}
 9080914:	e037883a 	mov	sp,fp
 9080918:	dfc00117 	ldw	ra,4(sp)
 908091c:	df000017 	ldw	fp,0(sp)
 9080920:	dec00204 	addi	sp,sp,8
 9080924:	f800283a 	ret

09080928 <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 9080928:	defffa04 	addi	sp,sp,-24
 908092c:	dfc00515 	stw	ra,20(sp)
 9080930:	df000415 	stw	fp,16(sp)
 9080934:	df000404 	addi	fp,sp,16
 9080938:	e17ffe15 	stw	r5,-8(fp)
 908093c:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 9080940:	e0bffd03 	ldbu	r2,-12(fp)
 9080944:	1005003a 	cmpeq	r2,r2,zero
 9080948:	1000981e 	bne	r2,zero,9080bac <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 908094c:	00800084 	movi	r2,2
 9080950:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 9080954:	908dbac0 	call	908dbac <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 9080958:	e0bffd03 	ldbu	r2,-12(fp)
 908095c:	10803fd8 	cmpnei	r2,r2,255
 9080960:	1000111e 	bne	r2,zero,90809a8 <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 9080964:	00800084 	movi	r2,2
 9080968:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 908096c:	01024374 	movhi	r4,2317
 9080970:	212d5304 	addi	r4,r4,-19124
 9080974:	90825100 	call	9082510 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 9080978:	00824374 	movhi	r2,2317
 908097c:	108b9b04 	addi	r2,r2,11884
 9080980:	10800017 	ldw	r2,0(r2)
 9080984:	11000317 	ldw	r4,12(r2)
 9080988:	e1bffe17 	ldw	r6,-8(fp)
 908098c:	01424374 	movhi	r5,2317
 9080990:	296d6204 	addi	r5,r5,-19064
 9080994:	90820140 	call	9082014 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 9080998:	01024374 	movhi	r4,2317
 908099c:	212d6604 	addi	r4,r4,-19048
 90809a0:	90824fc0 	call	90824fc <perror>
 90809a4:	00001006 	br	90809e8 <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 90809a8:	00800044 	movi	r2,1
 90809ac:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 90809b0:	01024374 	movhi	r4,2317
 90809b4:	212d6c04 	addi	r4,r4,-19024
 90809b8:	90828380 	call	9082838 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 90809bc:	00824374 	movhi	r2,2317
 90809c0:	108b9b04 	addi	r2,r2,11884
 90809c4:	10800017 	ldw	r2,0(r2)
 90809c8:	11000317 	ldw	r4,12(r2)
 90809cc:	e1bffd03 	ldbu	r6,-12(fp)
 90809d0:	01424374 	movhi	r5,2317
 90809d4:	296d7204 	addi	r5,r5,-19000
 90809d8:	90820140 	call	9082014 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 90809dc:	01024374 	movhi	r4,2317
 90809e0:	212d6604 	addi	r4,r4,-19048
 90809e4:	90824fc0 	call	90824fc <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 90809e8:	e0bffc17 	ldw	r2,-16(fp)
 90809ec:	e0bfff15 	stw	r2,-4(fp)
 90809f0:	e0ffff17 	ldw	r3,-4(fp)
 90809f4:	18800060 	cmpeqi	r2,r3,1
 90809f8:	1000071e 	bne	r2,zero,9080a18 <alt_NetworkErrorHandler+0xf0>
 90809fc:	e0ffff17 	ldw	r3,-4(fp)
 9080a00:	18800070 	cmpltui	r2,r3,1
 9080a04:	10003f1e 	bne	r2,zero,9080b04 <alt_NetworkErrorHandler+0x1dc>
 9080a08:	e0ffff17 	ldw	r3,-4(fp)
 9080a0c:	188000a0 	cmpeqi	r2,r3,2
 9080a10:	10001d1e 	bne	r2,zero,9080a88 <alt_NetworkErrorHandler+0x160>
 9080a14:	00005806 	br	9080b78 <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 9080a18:	01024374 	movhi	r4,2317
 9080a1c:	212d7904 	addi	r4,r4,-18972
 9080a20:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 9080a24:	00824374 	movhi	r2,2317
 9080a28:	108b9b04 	addi	r2,r2,11884
 9080a2c:	10800017 	ldw	r2,0(r2)
 9080a30:	11c00317 	ldw	r7,12(r2)
 9080a34:	01024374 	movhi	r4,2317
 9080a38:	212d8504 	addi	r4,r4,-18924
 9080a3c:	01400044 	movi	r5,1
 9080a40:	018007c4 	movi	r6,31
 9080a44:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 9080a48:	00824374 	movhi	r2,2317
 9080a4c:	108b9b04 	addi	r2,r2,11884
 9080a50:	10800017 	ldw	r2,0(r2)
 9080a54:	11c00317 	ldw	r7,12(r2)
 9080a58:	01024374 	movhi	r4,2317
 9080a5c:	212d8d04 	addi	r4,r4,-18892
 9080a60:	01400044 	movi	r5,1
 9080a64:	018008c4 	movi	r6,35
 9080a68:	90821100 	call	9082110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 9080a6c:	908dc380 	call	908dc38 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 9080a70:	01003fc4 	movi	r4,255
 9080a74:	9093d080 	call	9093d08 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 9080a78:	e13ffd03 	ldbu	r4,-12(fp)
 9080a7c:	000b883a 	mov	r5,zero
 9080a80:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
         break;
 9080a84:	00004806 	br	9080ba8 <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 9080a88:	01024374 	movhi	r4,2317
 9080a8c:	212d9604 	addi	r4,r4,-18856
 9080a90:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 9080a94:	00824374 	movhi	r2,2317
 9080a98:	108b9b04 	addi	r2,r2,11884
 9080a9c:	10800017 	ldw	r2,0(r2)
 9080aa0:	11c00317 	ldw	r7,12(r2)
 9080aa4:	01024374 	movhi	r4,2317
 9080aa8:	212da204 	addi	r4,r4,-18808
 9080aac:	01400044 	movi	r5,1
 9080ab0:	01800884 	movi	r6,34
 9080ab4:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 9080ab8:	00824374 	movhi	r2,2317
 9080abc:	108b9b04 	addi	r2,r2,11884
 9080ac0:	10800017 	ldw	r2,0(r2)
 9080ac4:	11c00317 	ldw	r7,12(r2)
 9080ac8:	01024374 	movhi	r4,2317
 9080acc:	212dab04 	addi	r4,r4,-18772
 9080ad0:	01400044 	movi	r5,1
 9080ad4:	01800a84 	movi	r6,42
 9080ad8:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 9080adc:	00824374 	movhi	r2,2317
 9080ae0:	108b9b04 	addi	r2,r2,11884
 9080ae4:	10800017 	ldw	r2,0(r2)
 9080ae8:	11c00317 	ldw	r7,12(r2)
 9080aec:	01024374 	movhi	r4,2317
 9080af0:	212db604 	addi	r4,r4,-18728
 9080af4:	01400044 	movi	r5,1
 9080af8:	01800b84 	movi	r6,46
 9080afc:	90821100 	call	9082110 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 9080b00:	003fff06 	br	9080b00 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 9080b04:	00824374 	movhi	r2,2317
 9080b08:	108b9b04 	addi	r2,r2,11884
 9080b0c:	10800017 	ldw	r2,0(r2)
 9080b10:	11c00317 	ldw	r7,12(r2)
 9080b14:	01024374 	movhi	r4,2317
 9080b18:	212dc204 	addi	r4,r4,-18680
 9080b1c:	01400044 	movi	r5,1
 9080b20:	01800804 	movi	r6,32
 9080b24:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 9080b28:	00824374 	movhi	r2,2317
 9080b2c:	108b9b04 	addi	r2,r2,11884
 9080b30:	10800017 	ldw	r2,0(r2)
 9080b34:	11c00317 	ldw	r7,12(r2)
 9080b38:	01024374 	movhi	r4,2317
 9080b3c:	212dcb04 	addi	r4,r4,-18644
 9080b40:	01400044 	movi	r5,1
 9080b44:	01800d84 	movi	r6,54
 9080b48:	90821100 	call	9082110 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 9080b4c:	00824374 	movhi	r2,2317
 9080b50:	108b9b04 	addi	r2,r2,11884
 9080b54:	10800017 	ldw	r2,0(r2)
 9080b58:	11c00317 	ldw	r7,12(r2)
 9080b5c:	01024374 	movhi	r4,2317
 9080b60:	212dd904 	addi	r4,r4,-18588
 9080b64:	01400044 	movi	r5,1
 9080b68:	01800e44 	movi	r6,57
 9080b6c:	90821100 	call	9082110 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 9080b70:	908dc380 	call	908dc38 <OSSchedUnlock>
         return;
 9080b74:	00000d06 	br	9080bac <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 9080b78:	01024374 	movhi	r4,2317
 9080b7c:	212de804 	addi	r4,r4,-18528
 9080b80:	90828380 	call	9082838 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 9080b84:	00824374 	movhi	r2,2317
 9080b88:	108b9b04 	addi	r2,r2,11884
 9080b8c:	10800017 	ldw	r2,0(r2)
 9080b90:	11c00317 	ldw	r7,12(r2)
 9080b94:	01024374 	movhi	r4,2317
 9080b98:	212df504 	addi	r4,r4,-18476
 9080b9c:	01400044 	movi	r5,1
 9080ba0:	01800984 	movi	r6,38
 9080ba4:	90821100 	call	9082110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 9080ba8:	003fff06 	br	9080ba8 <alt_NetworkErrorHandler+0x280>
}
 9080bac:	e037883a 	mov	sp,fp
 9080bb0:	dfc00117 	ldw	ra,4(sp)
 9080bb4:	df000017 	ldw	fp,0(sp)
 9080bb8:	dec00204 	addi	sp,sp,8
 9080bbc:	f800283a 	ret

09080bc0 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 9080bc0:	defff804 	addi	sp,sp,-32
 9080bc4:	dfc00715 	stw	ra,28(sp)
 9080bc8:	df000615 	stw	fp,24(sp)
 9080bcc:	df000604 	addi	fp,sp,24
 9080bd0:	e17ffc15 	stw	r5,-16(fp)
 9080bd4:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 9080bd8:	e0bffb03 	ldbu	r2,-20(fp)
 9080bdc:	1005003a 	cmpeq	r2,r2,zero
 9080be0:	1000ad1e 	bne	r2,zero,9080e98 <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 9080be4:	e0bffb03 	ldbu	r2,-20(fp)
 9080be8:	1004c03a 	cmpne	r2,r2,zero
 9080bec:	1000021e 	bne	r2,zero,9080bf8 <alt_SSSErrorHandler+0x38>
 9080bf0:	e03ffe15 	stw	zero,-8(fp)
 9080bf4:	00000206 	br	9080c00 <alt_SSSErrorHandler+0x40>
 9080bf8:	00800084 	movi	r2,2
 9080bfc:	e0bffe15 	stw	r2,-8(fp)
 9080c00:	e0fffe17 	ldw	r3,-8(fp)
 9080c04:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 9080c08:	908dbac0 	call	908dbac <OSSchedLock>
   switch (error_code)
 9080c0c:	e0bffb03 	ldbu	r2,-20(fp)
 9080c10:	e0bffd15 	stw	r2,-12(fp)
 9080c14:	e0fffd17 	ldw	r3,-12(fp)
 9080c18:	188007a0 	cmpeqi	r2,r3,30
 9080c1c:	1000121e 	bne	r2,zero,9080c68 <alt_SSSErrorHandler+0xa8>
 9080c20:	e0fffd17 	ldw	r3,-12(fp)
 9080c24:	18803fe0 	cmpeqi	r2,r3,255
 9080c28:	1000011e 	bne	r2,zero,9080c30 <alt_SSSErrorHandler+0x70>
 9080c2c:	00001906 	br	9080c94 <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 9080c30:	00800084 	movi	r2,2
 9080c34:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 9080c38:	01024374 	movhi	r4,2317
 9080c3c:	212dff04 	addi	r4,r4,-18436
 9080c40:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 9080c44:	00824374 	movhi	r2,2317
 9080c48:	108b9b04 	addi	r2,r2,11884
 9080c4c:	10800017 	ldw	r2,0(r2)
 9080c50:	11000317 	ldw	r4,12(r2)
 9080c54:	e1bffc17 	ldw	r6,-16(fp)
 9080c58:	01424374 	movhi	r5,2317
 9080c5c:	296e0d04 	addi	r5,r5,-18380
 9080c60:	90820140 	call	9082014 <fprintf>
         break;
 9080c64:	00001b06 	br	9080cd4 <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 9080c68:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 9080c6c:	00824374 	movhi	r2,2317
 9080c70:	108b9b04 	addi	r2,r2,11884
 9080c74:	10800017 	ldw	r2,0(r2)
 9080c78:	11c00317 	ldw	r7,12(r2)
 9080c7c:	01024374 	movhi	r4,2317
 9080c80:	212e1004 	addi	r4,r4,-18368
 9080c84:	01400044 	movi	r5,1
 9080c88:	01800c84 	movi	r6,50
 9080c8c:	90821100 	call	9082110 <fwrite>
         break;
 9080c90:	00001006 	br	9080cd4 <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 9080c94:	00800084 	movi	r2,2
 9080c98:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 9080c9c:	01024374 	movhi	r4,2317
 9080ca0:	212e1d04 	addi	r4,r4,-18316
 9080ca4:	90828380 	call	9082838 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 9080ca8:	00824374 	movhi	r2,2317
 9080cac:	108b9b04 	addi	r2,r2,11884
 9080cb0:	10800017 	ldw	r2,0(r2)
 9080cb4:	11000317 	ldw	r4,12(r2)
 9080cb8:	e1bffb03 	ldbu	r6,-20(fp)
 9080cbc:	01424374 	movhi	r5,2317
 9080cc0:	296e2204 	addi	r5,r5,-18296
 9080cc4:	90820140 	call	9082014 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 9080cc8:	01024374 	movhi	r4,2317
 9080ccc:	212e2804 	addi	r4,r4,-18272
 9080cd0:	90824fc0 	call	90824fc <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 9080cd4:	e0bffa17 	ldw	r2,-24(fp)
 9080cd8:	e0bfff15 	stw	r2,-4(fp)
 9080cdc:	e0ffff17 	ldw	r3,-4(fp)
 9080ce0:	18800060 	cmpeqi	r2,r3,1
 9080ce4:	1000071e 	bne	r2,zero,9080d04 <alt_SSSErrorHandler+0x144>
 9080ce8:	e0ffff17 	ldw	r3,-4(fp)
 9080cec:	18800070 	cmpltui	r2,r3,1
 9080cf0:	10003f1e 	bne	r2,zero,9080df0 <alt_SSSErrorHandler+0x230>
 9080cf4:	e0ffff17 	ldw	r3,-4(fp)
 9080cf8:	188000a0 	cmpeqi	r2,r3,2
 9080cfc:	10001d1e 	bne	r2,zero,9080d74 <alt_SSSErrorHandler+0x1b4>
 9080d00:	00005806 	br	9080e64 <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 9080d04:	01024374 	movhi	r4,2317
 9080d08:	212e2d04 	addi	r4,r4,-18252
 9080d0c:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 9080d10:	00824374 	movhi	r2,2317
 9080d14:	108b9b04 	addi	r2,r2,11884
 9080d18:	10800017 	ldw	r2,0(r2)
 9080d1c:	11c00317 	ldw	r7,12(r2)
 9080d20:	01024374 	movhi	r4,2317
 9080d24:	212e3804 	addi	r4,r4,-18208
 9080d28:	01400044 	movi	r5,1
 9080d2c:	018006c4 	movi	r6,27
 9080d30:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 9080d34:	00824374 	movhi	r2,2317
 9080d38:	108b9b04 	addi	r2,r2,11884
 9080d3c:	10800017 	ldw	r2,0(r2)
 9080d40:	11c00317 	ldw	r7,12(r2)
 9080d44:	01024374 	movhi	r4,2317
 9080d48:	212e3f04 	addi	r4,r4,-18180
 9080d4c:	01400044 	movi	r5,1
 9080d50:	018007c4 	movi	r6,31
 9080d54:	90821100 	call	9082110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 9080d58:	908dc380 	call	908dc38 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 9080d5c:	01003fc4 	movi	r4,255
 9080d60:	9093d080 	call	9093d08 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 9080d64:	e13ffb03 	ldbu	r4,-20(fp)
 9080d68:	000b883a 	mov	r5,zero
 9080d6c:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
         break;
 9080d70:	00004806 	br	9080e94 <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 9080d74:	01024374 	movhi	r4,2317
 9080d78:	212e4704 	addi	r4,r4,-18148
 9080d7c:	90825100 	call	9082510 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 9080d80:	00824374 	movhi	r2,2317
 9080d84:	108b9b04 	addi	r2,r2,11884
 9080d88:	10800017 	ldw	r2,0(r2)
 9080d8c:	11c00317 	ldw	r7,12(r2)
 9080d90:	01024374 	movhi	r4,2317
 9080d94:	212e5204 	addi	r4,r4,-18104
 9080d98:	01400044 	movi	r5,1
 9080d9c:	01800784 	movi	r6,30
 9080da0:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 9080da4:	00824374 	movhi	r2,2317
 9080da8:	108b9b04 	addi	r2,r2,11884
 9080dac:	10800017 	ldw	r2,0(r2)
 9080db0:	11c00317 	ldw	r7,12(r2)
 9080db4:	01024374 	movhi	r4,2317
 9080db8:	212e5a04 	addi	r4,r4,-18072
 9080dbc:	01400044 	movi	r5,1
 9080dc0:	01800984 	movi	r6,38
 9080dc4:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 9080dc8:	00824374 	movhi	r2,2317
 9080dcc:	108b9b04 	addi	r2,r2,11884
 9080dd0:	10800017 	ldw	r2,0(r2)
 9080dd4:	11c00317 	ldw	r7,12(r2)
 9080dd8:	01024374 	movhi	r4,2317
 9080ddc:	212e6404 	addi	r4,r4,-18032
 9080de0:	01400044 	movi	r5,1
 9080de4:	01800a84 	movi	r6,42
 9080de8:	90821100 	call	9082110 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 9080dec:	003fff06 	br	9080dec <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 9080df0:	00824374 	movhi	r2,2317
 9080df4:	108b9b04 	addi	r2,r2,11884
 9080df8:	10800017 	ldw	r2,0(r2)
 9080dfc:	11c00317 	ldw	r7,12(r2)
 9080e00:	01024374 	movhi	r4,2317
 9080e04:	212e6f04 	addi	r4,r4,-17988
 9080e08:	01400044 	movi	r5,1
 9080e0c:	018006c4 	movi	r6,27
 9080e10:	90821100 	call	9082110 <fwrite>
         fprintf(stderr, 
 9080e14:	00824374 	movhi	r2,2317
 9080e18:	108b9b04 	addi	r2,r2,11884
 9080e1c:	10800017 	ldw	r2,0(r2)
 9080e20:	11c00317 	ldw	r7,12(r2)
 9080e24:	01024374 	movhi	r4,2317
 9080e28:	212e7604 	addi	r4,r4,-17960
 9080e2c:	01400044 	movi	r5,1
 9080e30:	01800f44 	movi	r6,61
 9080e34:	90821100 	call	9082110 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 9080e38:	00824374 	movhi	r2,2317
 9080e3c:	108b9b04 	addi	r2,r2,11884
 9080e40:	10800017 	ldw	r2,0(r2)
 9080e44:	11c00317 	ldw	r7,12(r2)
 9080e48:	01024374 	movhi	r4,2317
 9080e4c:	212e8604 	addi	r4,r4,-17896
 9080e50:	01400044 	movi	r5,1
 9080e54:	01800b84 	movi	r6,46
 9080e58:	90821100 	call	9082110 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 9080e5c:	908dc380 	call	908dc38 <OSSchedUnlock>
         return;         
 9080e60:	00000d06 	br	9080e98 <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 9080e64:	01024374 	movhi	r4,2317
 9080e68:	212e9204 	addi	r4,r4,-17848
 9080e6c:	90828380 	call	9082838 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 9080e70:	00824374 	movhi	r2,2317
 9080e74:	108b9b04 	addi	r2,r2,11884
 9080e78:	10800017 	ldw	r2,0(r2)
 9080e7c:	11c00317 	ldw	r7,12(r2)
 9080e80:	01024374 	movhi	r4,2317
 9080e84:	212e9e04 	addi	r4,r4,-17800
 9080e88:	01400044 	movi	r5,1
 9080e8c:	01800844 	movi	r6,33
 9080e90:	90821100 	call	9082110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 9080e94:	003fff06 	br	9080e94 <alt_SSSErrorHandler+0x2d4>
}
 9080e98:	e037883a 	mov	sp,fp
 9080e9c:	dfc00117 	ldw	ra,4(sp)
 9080ea0:	df000017 	ldw	fp,0(sp)
 9080ea4:	dec00204 	addi	sp,sp,8
 9080ea8:	f800283a 	ret

09080eac <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 9080eac:	defffc04 	addi	sp,sp,-16
 9080eb0:	dfc00315 	stw	ra,12(sp)
 9080eb4:	df000215 	stw	fp,8(sp)
 9080eb8:	df000204 	addi	fp,sp,8
 9080ebc:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 9080ec0:	90a9bf00 	call	90a9bf0 <alt_iniche_init>
  netmain(); 
 9080ec4:	90a4aa00 	call	90a4aa0 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 9080ec8:	00000206 	br	9080ed4 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 9080ecc:	01000084 	movi	r4,2
 9080ed0:	9094e000 	call	9094e00 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 9080ed4:	00824374 	movhi	r2,2317
 9080ed8:	108c2604 	addi	r2,r2,12440
 9080edc:	10800017 	ldw	r2,0(r2)
 9080ee0:	1005003a 	cmpeq	r2,r2,zero
 9080ee4:	103ff91e 	bne	r2,zero,9080ecc <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 9080ee8:	01024374 	movhi	r4,2317
 9080eec:	212ead04 	addi	r4,r4,-17740
 9080ef0:	90828380 	call	9082838 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 9080ef4:	01024374 	movhi	r4,2317
 9080ef8:	2103a304 	addi	r4,r4,3724
 9080efc:	90a98b00 	call	90a98b0 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 9080f00:	90816ac0 	call	90816ac <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 9080f04:	90817540 	call	9081754 <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 9080f08:	01003fc4 	movi	r4,255
 9080f0c:	9093d080 	call	9093d08 <OSTaskDel>
 9080f10:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 9080f14:	e13ffe03 	ldbu	r4,-8(fp)
 9080f18:	000b883a 	mov	r5,zero
 9080f1c:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 9080f20:	003fff06 	br	9080f20 <SSSInitialTask+0x74>

09080f24 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 9080f24:	defff504 	addi	sp,sp,-44
 9080f28:	dfc00a15 	stw	ra,40(sp)
 9080f2c:	df000915 	stw	fp,36(sp)
 9080f30:	df000904 	addi	fp,sp,36
 9080f34:	e13ffd15 	stw	r4,-12(fp)
 9080f38:	e17ffe15 	stw	r5,-8(fp)
 9080f3c:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 9080f40:	0009883a 	mov	r4,zero
 9080f44:	90954040 	call	9095404 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 9080f48:	01824374 	movhi	r6,2317
 9080f4c:	31961a04 	addi	r6,r6,22632
 9080f50:	00800144 	movi	r2,5
 9080f54:	d8800015 	stw	r2,0(sp)
 9080f58:	00824374 	movhi	r2,2317
 9080f5c:	108e1a04 	addi	r2,r2,14440
 9080f60:	d8800115 	stw	r2,4(sp)
 9080f64:	00820004 	movi	r2,2048
 9080f68:	d8800215 	stw	r2,8(sp)
 9080f6c:	d8000315 	stw	zero,12(sp)
 9080f70:	d8000415 	stw	zero,16(sp)
 9080f74:	01024234 	movhi	r4,2312
 9080f78:	2103ab04 	addi	r4,r4,3756
 9080f7c:	000b883a 	mov	r5,zero
 9080f80:	01c00144 	movi	r7,5
 9080f84:	9093b080 	call	9093b08 <OSTaskCreateExt>
 9080f88:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 9080f8c:	e13ffc03 	ldbu	r4,-16(fp)
 9080f90:	000b883a 	mov	r5,zero
 9080f94:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 9080f98:	908dd1c0 	call	908dd1c <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 9080f9c:	003fff06 	br	9080f9c <main+0x78>

09080fa0 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 9080fa0:	defffc04 	addi	sp,sp,-16
 9080fa4:	dfc00315 	stw	ra,12(sp)
 9080fa8:	df000215 	stw	fp,8(sp)
 9080fac:	df000204 	addi	fp,sp,8
 9080fb0:	e13fff0d 	sth	r4,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 9080fb4:	00824374 	movhi	r2,2317
 9080fb8:	108bf604 	addi	r2,r2,12248
 9080fbc:	11000017 	ldw	r4,0(r2)
 9080fc0:	e17ffe84 	addi	r5,fp,-6
 9080fc4:	90907840 	call	9090784 <OSFlagQuery>
 9080fc8:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 9080fcc:	e0bffe83 	ldbu	r2,-6(fp)
 9080fd0:	11003fcc 	andi	r4,r2,255
 9080fd4:	000b883a 	mov	r5,zero
 9080fd8:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 9080fdc:	e0ffff0b 	ldhu	r3,-4(fp)
 9080fe0:	e0bffe0b 	ldhu	r2,-8(fp)
 9080fe4:	1884703a 	and	r2,r3,r2
 9080fe8:	10bfffcc 	andi	r2,r2,65535
 9080fec:	1005003a 	cmpeq	r2,r2,zero
 9080ff0:	10000d1e 	bne	r2,zero,9081028 <led_bit_toggle+0x88>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 9080ff4:	00824374 	movhi	r2,2317
 9080ff8:	108bf604 	addi	r2,r2,12248
 9080ffc:	11000017 	ldw	r4,0(r2)
 9081000:	e17fff0b 	ldhu	r5,-4(fp)
 9081004:	e1fffe84 	addi	r7,fp,-6
 9081008:	000d883a 	mov	r6,zero
 908100c:	90903dc0 	call	90903dc <OSFlagPost>
 9081010:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 9081014:	e0bffe83 	ldbu	r2,-6(fp)
 9081018:	11003fcc 	andi	r4,r2,255
 908101c:	000b883a 	mov	r5,zero
 9081020:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
 9081024:	00000c06 	br	9081058 <led_bit_toggle+0xb8>
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 9081028:	00824374 	movhi	r2,2317
 908102c:	108bf604 	addi	r2,r2,12248
 9081030:	11000017 	ldw	r4,0(r2)
 9081034:	e17fff0b 	ldhu	r5,-4(fp)
 9081038:	e1fffe84 	addi	r7,fp,-6
 908103c:	01800044 	movi	r6,1
 9081040:	90903dc0 	call	90903dc <OSFlagPost>
 9081044:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 9081048:	e0bffe83 	ldbu	r2,-6(fp)
 908104c:	11003fcc 	andi	r4,r2,255
 9081050:	000b883a 	mov	r5,zero
 9081054:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
    }
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
 9081058:	e0fffe0b 	ldhu	r3,-8(fp)
 908105c:	00820034 	movhi	r2,2048
 9081060:	10802404 	addi	r2,r2,144
 9081064:	10c00035 	stwio	r3,0(r2)
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
 9081068:	e0bffe0b 	ldhu	r2,-8(fp)
 908106c:	11403fcc 	andi	r5,r2,255
 9081070:	01024374 	movhi	r4,2317
 9081074:	212eb604 	addi	r4,r4,-17704
 9081078:	90825100 	call	9082510 <printf>
    #endif
      
    return;
}
 908107c:	e037883a 	mov	sp,fp
 9081080:	dfc00117 	ldw	ra,4(sp)
 9081084:	df000017 	ldw	fp,0(sp)
 9081088:	dec00204 	addi	sp,sp,8
 908108c:	f800283a 	ret

09081090 <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 9081090:	defffd04 	addi	sp,sp,-12
 9081094:	dfc00215 	stw	ra,8(sp)
 9081098:	df000115 	stw	fp,4(sp)
 908109c:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 90810a0:	0009883a 	mov	r4,zero
 90810a4:	000b883a 	mov	r5,zero
 90810a8:	000d883a 	mov	r6,zero
 90810ac:	01c00c84 	movi	r7,50
 90810b0:	9094f4c0 	call	9094f4c <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 90810b4:	00824374 	movhi	r2,2317
 90810b8:	108bf504 	addi	r2,r2,12244
 90810bc:	11000017 	ldw	r4,0(r2)
 90810c0:	e1bfff84 	addi	r6,fp,-2
 90810c4:	000b883a 	mov	r5,zero
 90810c8:	9092c6c0 	call	9092c6c <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 90810cc:	e0bfff83 	ldbu	r2,-2(fp)
 90810d0:	11003fcc 	andi	r4,r2,255
 90810d4:	000b883a 	mov	r5,zero
 90810d8:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 90810dc:	00824374 	movhi	r2,2317
 90810e0:	108bf504 	addi	r2,r2,12244
 90810e4:	11000017 	ldw	r4,0(r2)
 90810e8:	90930640 	call	9093064 <OSSemPost>
 90810ec:	e0bfff85 	stb	r2,-2(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 90810f0:	e0bfff83 	ldbu	r2,-2(fp)
 90810f4:	11003fcc 	andi	r4,r2,255
 90810f8:	000b883a 	mov	r5,zero
 90810fc:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
      
   }
 9081100:	003fe706 	br	90810a0 <LED7SegLightshowTask+0x10>

09081104 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 9081104:	defffa04 	addi	sp,sp,-24
 9081108:	dfc00515 	stw	ra,20(sp)
 908110c:	df000415 	stw	fp,16(sp)
 9081110:	df000404 	addi	fp,sp,16
  INT32U led_command; 
  INT16U led_7_seg_val;
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  led_7_seg_val = 0;
 9081114:	e03ffc8d 	sth	zero,-14(fp)
  SSSLEDLightshowActive = OS_TRUE;
 9081118:	00800044 	movi	r2,1
 908111c:	e0bffc05 	stb	r2,-16(fp)
 9081120:	00000006 	br	9081124 <LEDManagementTask+0x20>
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 9081124:	00824374 	movhi	r2,2317
 9081128:	108bf404 	addi	r2,r2,12240
 908112c:	11000017 	ldw	r4,0(r2)
 9081130:	e1bffe04 	addi	r6,fp,-8
 9081134:	000b883a 	mov	r5,zero
 9081138:	9091bf40 	call	9091bf4 <OSQPend>
 908113c:	e0bffd15 	stw	r2,-12(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 9081140:	e0bffe03 	ldbu	r2,-8(fp)
 9081144:	11003fcc 	andi	r4,r2,255
 9081148:	000b883a 	mov	r5,zero
 908114c:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 9081150:	e0bffd17 	ldw	r2,-12(fp)
 9081154:	10bff404 	addi	r2,r2,-48
 9081158:	e0bfff15 	stw	r2,-4(fp)
 908115c:	e0ffff17 	ldw	r3,-4(fp)
 9081160:	18800928 	cmpgeui	r2,r3,36
 9081164:	103fef1e 	bne	r2,zero,9081124 <LEDManagementTask+0x20>
 9081168:	e13fff17 	ldw	r4,-4(fp)
 908116c:	e13fff17 	ldw	r4,-4(fp)
 9081170:	2105883a 	add	r2,r4,r4
 9081174:	1087883a 	add	r3,r2,r2
 9081178:	00824234 	movhi	r2,2312
 908117c:	10846304 	addi	r2,r2,4492
 9081180:	1885883a 	add	r2,r3,r2
 9081184:	10800017 	ldw	r2,0(r2)
 9081188:	1000683a 	jmp	r2
 908118c:	0908121c 	xori	r4,at,8264
 9081190:	09081228 	cmpgeui	r4,at,8264
 9081194:	09081234 	orhi	r4,at,8264
 9081198:	09081240 	call	908124 <OSCtxSw_SWITCH_PC+0x9080e4>
 908119c:	0908124c 	andi	r4,at,8265
 90811a0:	09081258 	cmpnei	r4,at,8265
 90811a4:	09081264 	muli	r4,at,8265
 90811a8:	09081270 	cmpltui	r4,at,8265
 90811ac:	09081124 	muli	r4,at,8260
 90811b0:	09081124 	muli	r4,at,8260
 90811b4:	09081124 	muli	r4,at,8260
 90811b8:	09081124 	muli	r4,at,8260
 90811bc:	09081124 	muli	r4,at,8260
 90811c0:	09081124 	muli	r4,at,8260
 90811c4:	09081124 	muli	r4,at,8260
 90811c8:	09081124 	muli	r4,at,8260
 90811cc:	09081124 	muli	r4,at,8260
 90811d0:	09081124 	muli	r4,at,8260
 90811d4:	09081124 	muli	r4,at,8260
 90811d8:	09081124 	muli	r4,at,8260
 90811dc:	09081124 	muli	r4,at,8260
 90811e0:	09081124 	muli	r4,at,8260
 90811e4:	09081124 	muli	r4,at,8260
 90811e8:	09081124 	muli	r4,at,8260
 90811ec:	09081124 	muli	r4,at,8260
 90811f0:	09081124 	muli	r4,at,8260
 90811f4:	09081124 	muli	r4,at,8260
 90811f8:	09081124 	muli	r4,at,8260
 90811fc:	09081124 	muli	r4,at,8260
 9081200:	09081124 	muli	r4,at,8260
 9081204:	09081124 	muli	r4,at,8260
 9081208:	09081124 	muli	r4,at,8260
 908120c:	09081124 	muli	r4,at,8260
 9081210:	09081124 	muli	r4,at,8260
 9081214:	09081124 	muli	r4,at,8260
 9081218:	0908127c 	xorhi	r4,at,8265
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 908121c:	01000044 	movi	r4,1
 9081220:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 9081224:	003fbf06 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 9081228:	01000084 	movi	r4,2
 908122c:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;   
 9081230:	003fbc06 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 9081234:	01000104 	movi	r4,4
 9081238:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 908123c:	003fb906 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 9081240:	01000204 	movi	r4,8
 9081244:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 9081248:	003fb606 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 908124c:	01000404 	movi	r4,16
 9081250:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 9081254:	003fb306 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 9081258:	01000804 	movi	r4,32
 908125c:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 9081260:	003fb006 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 9081264:	01001004 	movi	r4,64
 9081268:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 908126c:	003fad06 	br	9081124 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 9081270:	01002004 	movi	r4,128
 9081274:	9080fa00 	call	9080fa0 <led_bit_toggle>
         break;
 9081278:	003faa06 	br	9081124 <LEDManagementTask+0x20>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 908127c:	e0bffc03 	ldbu	r2,-16(fp)
 9081280:	1004c03a 	cmpne	r2,r2,zero
 9081284:	10000c1e 	bne	r2,zero,90812b8 <LEDManagementTask+0x1b4>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 9081288:	00824374 	movhi	r2,2317
 908128c:	108bf504 	addi	r2,r2,12244
 9081290:	11000017 	ldw	r4,0(r2)
 9081294:	90930640 	call	9093064 <OSSemPost>
 9081298:	e0bffe05 	stb	r2,-8(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 908129c:	e0bffe03 	ldbu	r2,-8(fp)
 90812a0:	11003fcc 	andi	r4,r2,255
 90812a4:	000b883a 	mov	r5,zero
 90812a8:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 90812ac:	00800044 	movi	r2,1
 90812b0:	e0bffc05 	stb	r2,-16(fp)
 90812b4:	003f9b06 	br	9081124 <LEDManagementTask+0x20>
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 90812b8:	00824374 	movhi	r2,2317
 90812bc:	108bf504 	addi	r2,r2,12244
 90812c0:	11000017 	ldw	r4,0(r2)
 90812c4:	e1bffe04 	addi	r6,fp,-8
 90812c8:	000b883a 	mov	r5,zero
 90812cc:	9092c6c0 	call	9092c6c <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 90812d0:	e0bffe03 	ldbu	r2,-8(fp)
 90812d4:	11003fcc 	andi	r4,r2,255
 90812d8:	000b883a 	mov	r5,zero
 90812dc:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 90812e0:	e03ffc05 	stb	zero,-16(fp)
         break;
      default:     
        /* Discard unknown LED commands. */
        break;
    } /* switch led_command */
  } /* while(1) */
 90812e4:	003f8f06 	br	9081124 <LEDManagementTask+0x20>

090812e8 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 90812e8:	defffb04 	addi	sp,sp,-20
 90812ec:	dfc00415 	stw	ra,16(sp)
 90812f0:	df000315 	stw	fp,12(sp)
 90812f4:	df000304 	addi	fp,sp,12
 90812f8:	e13ffe15 	stw	r4,-8(fp)
 90812fc:	e17fff15 	stw	r5,-4(fp)
    error_t error = 1;
 9081300:	00800044 	movi	r2,1
 9081304:	e0bffd15 	stw	r2,-12(fp)
    
//    error = get_board_mac_addr(mac_addr);
    
    if(error)
 9081308:	e0bffd17 	ldw	r2,-12(fp)
 908130c:	1005003a 	cmpeq	r2,r2,zero
 9081310:	1000031e 	bne	r2,zero,9081320 <get_mac_addr+0x38>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 9081314:	e13fff17 	ldw	r4,-4(fp)
 9081318:	90815700 	call	9081570 <generate_mac_addr>
 908131c:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 9081320:	e0bffd17 	ldw	r2,-12(fp)
}
 9081324:	e037883a 	mov	sp,fp
 9081328:	dfc00117 	ldw	ra,4(sp)
 908132c:	df000017 	ldw	fp,0(sp)
 9081330:	dec00204 	addi	sp,sp,8
 9081334:	f800283a 	ret

09081338 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 9081338:	defffb04 	addi	sp,sp,-20
 908133c:	df000415 	stw	fp,16(sp)
 9081340:	df000404 	addi	fp,sp,16
 9081344:	e13ffc15 	stw	r4,-16(fp)
 9081348:	e17ffd15 	stw	r5,-12(fp)
 908134c:	e1bffe15 	stw	r6,-8(fp)
 9081350:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 9081354:	e0bffd17 	ldw	r2,-12(fp)
 9081358:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 908135c:	e0bfff17 	ldw	r2,-4(fp)
 9081360:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 9081364:	e0fffe17 	ldw	r3,-8(fp)
 9081368:	00804034 	movhi	r2,256
 908136c:	10bfffc4 	addi	r2,r2,-1
 9081370:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 9081374:	e0c00117 	ldw	r3,4(fp)
 9081378:	00800044 	movi	r2,1
 908137c:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 9081380:	00800044 	movi	r2,1
}
 9081384:	e037883a 	mov	sp,fp
 9081388:	df000017 	ldw	fp,0(sp)
 908138c:	dec00104 	addi	sp,sp,4
 9081390:	f800283a 	ret

09081394 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 9081394:	defff804 	addi	sp,sp,-32
 9081398:	dfc00715 	stw	ra,28(sp)
 908139c:	df000615 	stw	fp,24(sp)
 90813a0:	dc000515 	stw	r16,20(sp)
 90813a4:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 90813a8:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 90813ac:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 90813b0:	00006506 	br	9081548 <get_serial_number+0x1b4>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 90813b4:	01024374 	movhi	r4,2317
 90813b8:	212ebf04 	addi	r4,r4,-17668
 90813bc:	90828380 	call	9082838 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 90813c0:	01024374 	movhi	r4,2317
 90813c4:	212ecf04 	addi	r4,r4,-17604
 90813c8:	90828380 	call	9082838 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 90813cc:	01024374 	movhi	r4,2317
 90813d0:	212edf04 	addi	r4,r4,-17540
 90813d4:	90825100 	call	9082510 <printf>
        
        for(i=0; i<9; i++)
 90813d8:	e03ffb15 	stw	zero,-20(fp)
 90813dc:	00002806 	br	9081480 <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 90813e0:	e43ffb17 	ldw	r16,-20(fp)
 90813e4:	00824374 	movhi	r2,2317
 90813e8:	108b9b04 	addi	r2,r2,11884
 90813ec:	10800017 	ldw	r2,0(r2)
 90813f0:	11000117 	ldw	r4,4(r2)
 90813f4:	90821500 	call	9082150 <getc>
 90813f8:	1007883a 	mov	r3,r2
 90813fc:	e0bffd04 	addi	r2,fp,-12
 9081400:	1405883a 	add	r2,r2,r16
 9081404:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 9081408:	e0fffb17 	ldw	r3,-20(fp)
 908140c:	e0bffd04 	addi	r2,fp,-12
 9081410:	10c5883a 	add	r2,r2,r3
 9081414:	10800003 	ldbu	r2,0(r2)
 9081418:	11003fcc 	andi	r4,r2,255
 908141c:	2100201c 	xori	r4,r4,128
 9081420:	213fe004 	addi	r4,r4,-128
 9081424:	00824374 	movhi	r2,2317
 9081428:	108b9b04 	addi	r2,r2,11884
 908142c:	10800017 	ldw	r2,0(r2)
 9081430:	11400217 	ldw	r5,8(r2)
 9081434:	90825880 	call	9082588 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 9081438:	e0fffb17 	ldw	r3,-20(fp)
 908143c:	e0bffd04 	addi	r2,fp,-12
 9081440:	10c5883a 	add	r2,r2,r3
 9081444:	10800003 	ldbu	r2,0(r2)
 9081448:	10803fcc 	andi	r2,r2,255
 908144c:	1080201c 	xori	r2,r2,128
 9081450:	10bfe004 	addi	r2,r2,-128
 9081454:	10800218 	cmpnei	r2,r2,8
 9081458:	1000061e 	bne	r2,zero,9081474 <get_serial_number+0xe0>
 908145c:	e0bffb17 	ldw	r2,-20(fp)
 9081460:	1004803a 	cmplt	r2,r2,zero
 9081464:	1000031e 	bne	r2,zero,9081474 <get_serial_number+0xe0>
            {
                i--;
 9081468:	e0bffb17 	ldw	r2,-20(fp)
 908146c:	10bfffc4 	addi	r2,r2,-1
 9081470:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 9081474:	e0bffb17 	ldw	r2,-20(fp)
 9081478:	10800044 	addi	r2,r2,1
 908147c:	e0bffb15 	stw	r2,-20(fp)
 9081480:	e0bffb17 	ldw	r2,-20(fp)
 9081484:	10800250 	cmplti	r2,r2,9
 9081488:	103fd51e 	bne	r2,zero,90813e0 <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 908148c:	01000284 	movi	r4,10
 9081490:	90827740 	call	9082774 <putchar>
                
        for(i=0; i<9; i++)
 9081494:	e03ffb15 	stw	zero,-20(fp)
 9081498:	00002806 	br	908153c <get_serial_number+0x1a8>
        {
            if (isdigit(serial_number[i]))
 908149c:	e0fffb17 	ldw	r3,-20(fp)
 90814a0:	e0bffd04 	addi	r2,fp,-12
 90814a4:	10c5883a 	add	r2,r2,r3
 90814a8:	10800003 	ldbu	r2,0(r2)
 90814ac:	10803fcc 	andi	r2,r2,255
 90814b0:	1080201c 	xori	r2,r2,128
 90814b4:	10bfe004 	addi	r2,r2,-128
 90814b8:	1007883a 	mov	r3,r2
 90814bc:	00824374 	movhi	r2,2317
 90814c0:	108b9a04 	addi	r2,r2,11880
 90814c4:	10800017 	ldw	r2,0(r2)
 90814c8:	1885883a 	add	r2,r3,r2
 90814cc:	10800003 	ldbu	r2,0(r2)
 90814d0:	10803fcc 	andi	r2,r2,255
 90814d4:	1080010c 	andi	r2,r2,4
 90814d8:	1005003a 	cmpeq	r2,r2,zero
 90814dc:	1000121e 	bne	r2,zero,9081528 <get_serial_number+0x194>
            {
                ser_num *= 10;
 90814e0:	e0bffc17 	ldw	r2,-16(fp)
 90814e4:	108002a4 	muli	r2,r2,10
 90814e8:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 90814ec:	e0fffb17 	ldw	r3,-20(fp)
 90814f0:	e0bffd04 	addi	r2,fp,-12
 90814f4:	10c5883a 	add	r2,r2,r3
 90814f8:	10800003 	ldbu	r2,0(r2)
 90814fc:	10c03fcc 	andi	r3,r2,255
 9081500:	18c0201c 	xori	r3,r3,128
 9081504:	18ffe004 	addi	r3,r3,-128
 9081508:	e0bffc17 	ldw	r2,-16(fp)
 908150c:	1885883a 	add	r2,r3,r2
 9081510:	10bff404 	addi	r2,r2,-48
 9081514:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 9081518:	e0bffb17 	ldw	r2,-20(fp)
 908151c:	10800044 	addi	r2,r2,1
 9081520:	e0bffb15 	stw	r2,-20(fp)
 9081524:	00000506 	br	908153c <get_serial_number+0x1a8>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 9081528:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 908152c:	01024374 	movhi	r4,2317
 9081530:	212eed04 	addi	r4,r4,-17484
 9081534:	90828380 	call	9082838 <puts>
                break;
 9081538:	00000306 	br	9081548 <get_serial_number+0x1b4>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 908153c:	e0bffb17 	ldw	r2,-20(fp)
 9081540:	10800250 	cmplti	r2,r2,9
 9081544:	103fd51e 	bne	r2,zero,908149c <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 9081548:	e0bffc17 	ldw	r2,-16(fp)
 908154c:	1005003a 	cmpeq	r2,r2,zero
 9081550:	103f981e 	bne	r2,zero,90813b4 <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 9081554:	e0bffc17 	ldw	r2,-16(fp)
}
 9081558:	e037883a 	mov	sp,fp
 908155c:	dfc00217 	ldw	ra,8(sp)
 9081560:	df000117 	ldw	fp,4(sp)
 9081564:	dc000017 	ldw	r16,0(sp)
 9081568:	dec00304 	addi	sp,sp,12
 908156c:	f800283a 	ret

09081570 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 9081570:	defff804 	addi	sp,sp,-32
 9081574:	dfc00715 	stw	ra,28(sp)
 9081578:	df000615 	stw	fp,24(sp)
 908157c:	df000604 	addi	fp,sp,24
 9081580:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 9081584:	00bfffc4 	movi	r2,-1
 9081588:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 908158c:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 9081590:	01024374 	movhi	r4,2317
 9081594:	212efc04 	addi	r4,r4,-17424
 9081598:	90828380 	call	9082838 <puts>
    printf("a MAC address.\n\n");
 908159c:	01024374 	movhi	r4,2317
 90815a0:	212f0c04 	addi	r4,r4,-17360
 90815a4:	90828380 	call	9082838 <puts>
    
//    ser_num = get_serial_number();
    ser_num = 0x096D;
 90815a8:	00825b44 	movi	r2,2413
 90815ac:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 90815b0:	e0bffd17 	ldw	r2,-12(fp)
 90815b4:	1005003a 	cmpeq	r2,r2,zero
 90815b8:	1000361e 	bne	r2,zero,9081694 <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 90815bc:	e0bfff17 	ldw	r2,-4(fp)
 90815c0:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 90815c4:	e0bfff17 	ldw	r2,-4(fp)
 90815c8:	10c00044 	addi	r3,r2,1
 90815cc:	008001c4 	movi	r2,7
 90815d0:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 90815d4:	e0bfff17 	ldw	r2,-4(fp)
 90815d8:	10c00084 	addi	r3,r2,2
 90815dc:	00bffb44 	movi	r2,-19
 90815e0:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
//        mac_addr[3] = 0xFF;
        mac_addr[3] = 0x15;
 90815e4:	e0bfff17 	ldw	r2,-4(fp)
 90815e8:	10c000c4 	addi	r3,r2,3
 90815ec:	00800544 	movi	r2,21
 90815f0:	18800005 	stb	r2,0(r3)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 90815f4:	e0bfff17 	ldw	r2,-4(fp)
 90815f8:	10c00104 	addi	r3,r2,4
 90815fc:	e0bffd17 	ldw	r2,-12(fp)
 9081600:	10bfc00c 	andi	r2,r2,65280
 9081604:	1004d23a 	srli	r2,r2,8
 9081608:	18800005 	stb	r2,0(r3)
        mac_addr[5] = ser_num & 0xff;
 908160c:	e0bfff17 	ldw	r2,-4(fp)
 9081610:	10c00144 	addi	r3,r2,5
 9081614:	e0bffd17 	ldw	r2,-12(fp)
 9081618:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 908161c:	e0bfff17 	ldw	r2,-4(fp)
 9081620:	10800003 	ldbu	r2,0(r2)
 9081624:	11403fcc 	andi	r5,r2,255
 9081628:	e0bfff17 	ldw	r2,-4(fp)
 908162c:	10800044 	addi	r2,r2,1
 9081630:	10800003 	ldbu	r2,0(r2)
 9081634:	11803fcc 	andi	r6,r2,255
 9081638:	e0bfff17 	ldw	r2,-4(fp)
 908163c:	10800084 	addi	r2,r2,2
 9081640:	10800003 	ldbu	r2,0(r2)
 9081644:	11c03fcc 	andi	r7,r2,255
 9081648:	e0bfff17 	ldw	r2,-4(fp)
 908164c:	108000c4 	addi	r2,r2,3
 9081650:	10800003 	ldbu	r2,0(r2)
 9081654:	10c03fcc 	andi	r3,r2,255
 9081658:	e0bfff17 	ldw	r2,-4(fp)
 908165c:	10800104 	addi	r2,r2,4
 9081660:	10800003 	ldbu	r2,0(r2)
 9081664:	11003fcc 	andi	r4,r2,255
 9081668:	e0bfff17 	ldw	r2,-4(fp)
 908166c:	10800144 	addi	r2,r2,5
 9081670:	10800003 	ldbu	r2,0(r2)
 9081674:	10803fcc 	andi	r2,r2,255
 9081678:	d8c00015 	stw	r3,0(sp)
 908167c:	d9000115 	stw	r4,4(sp)
 9081680:	d8800215 	stw	r2,8(sp)
 9081684:	01024374 	movhi	r4,2317
 9081688:	212f1004 	addi	r4,r4,-17344
 908168c:	90825100 	call	9082510 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 9081690:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 9081694:	e0bffe17 	ldw	r2,-8(fp)
}
 9081698:	e037883a 	mov	sp,fp
 908169c:	dfc00117 	ldw	ra,4(sp)
 90816a0:	df000017 	ldw	fp,0(sp)
 90816a4:	dec00204 	addi	sp,sp,8
 90816a8:	f800283a 	ret

090816ac <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 90816ac:	defffd04 	addi	sp,sp,-12
 90816b0:	dfc00215 	stw	ra,8(sp)
 90816b4:	df000115 	stw	fp,4(sp)
 90816b8:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 90816bc:	01024374 	movhi	r4,2317
 90816c0:	211e1a04 	addi	r4,r4,30824
 90816c4:	01400784 	movi	r5,30
 90816c8:	90916180 	call	9091618 <OSQCreate>
 90816cc:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 90816d0:	d0a05a17 	ldw	r2,-32408(gp)
 90816d4:	1004c03a 	cmpne	r2,r2,zero
 90816d8:	1000041e 	bne	r2,zero,90816ec <SSSCreateOSDataStructs+0x40>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 90816dc:	01003fc4 	movi	r4,255
 90816e0:	01424374 	movhi	r5,2317
 90816e4:	296f1f04 	addi	r5,r5,-17284
 90816e8:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 90816ec:	01000044 	movi	r4,1
 90816f0:	90928b80 	call	90928b8 <OSSemCreate>
 90816f4:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 90816f8:	d0a05b17 	ldw	r2,-32404(gp)
 90816fc:	1004c03a 	cmpne	r2,r2,zero
 9081700:	1000041e 	bne	r2,zero,9081714 <SSSCreateOSDataStructs+0x68>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 9081704:	01003fc4 	movi	r4,255
 9081708:	01424374 	movhi	r5,2317
 908170c:	296f2804 	addi	r5,r5,-17248
 9081710:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 9081714:	0009883a 	mov	r4,zero
 9081718:	e17fff04 	addi	r5,fp,-4
 908171c:	908f6b40 	call	908f6b4 <OSFlagCreate>
 9081720:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 9081724:	d0a05c17 	ldw	r2,-32400(gp)
 9081728:	1004c03a 	cmpne	r2,r2,zero
 908172c:	1000041e 	bne	r2,zero,9081740 <SSSCreateOSDataStructs+0x94>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 9081730:	e0bfff03 	ldbu	r2,-4(fp)
 9081734:	11003fcc 	andi	r4,r2,255
 9081738:	000b883a 	mov	r5,zero
 908173c:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
  }
}
 9081740:	e037883a 	mov	sp,fp
 9081744:	dfc00117 	ldw	ra,4(sp)
 9081748:	df000017 	ldw	fp,0(sp)
 908174c:	dec00204 	addi	sp,sp,8
 9081750:	f800283a 	ret

09081754 <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 9081754:	defff804 	addi	sp,sp,-32
 9081758:	dfc00715 	stw	ra,28(sp)
 908175c:	df000615 	stw	fp,24(sp)
 9081760:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 9081764:	01824374 	movhi	r6,2317
 9081768:	319e1904 	addi	r6,r6,30820
 908176c:	00800484 	movi	r2,18
 9081770:	d8800015 	stw	r2,0(sp)
 9081774:	00824374 	movhi	r2,2317
 9081778:	10961a04 	addi	r2,r2,22632
 908177c:	d8800115 	stw	r2,4(sp)
 9081780:	00820004 	movi	r2,2048
 9081784:	d8800215 	stw	r2,8(sp)
 9081788:	d8000315 	stw	zero,12(sp)
 908178c:	d8000415 	stw	zero,16(sp)
 9081790:	01024234 	movhi	r4,2312
 9081794:	21042404 	addi	r4,r4,4240
 9081798:	000b883a 	mov	r5,zero
 908179c:	01c00484 	movi	r7,18
 90817a0:	9093b080 	call	9093b08 <OSTaskCreateExt>
 90817a4:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 90817a8:	e13fff03 	ldbu	r4,-4(fp)
 90817ac:	000b883a 	mov	r5,zero
 90817b0:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 90817b4:	018243b4 	movhi	r6,2318
 90817b8:	31a63704 	addi	r6,r6,-26404
 90817bc:	008001c4 	movi	r2,7
 90817c0:	d8800015 	stw	r2,0(sp)
 90817c4:	00824374 	movhi	r2,2317
 90817c8:	109e3804 	addi	r2,r2,30944
 90817cc:	d8800115 	stw	r2,4(sp)
 90817d0:	00820004 	movi	r2,2048
 90817d4:	d8800215 	stw	r2,8(sp)
 90817d8:	d8000315 	stw	zero,12(sp)
 90817dc:	d8000415 	stw	zero,16(sp)
 90817e0:	01024234 	movhi	r4,2312
 90817e4:	21044104 	addi	r4,r4,4356
 90817e8:	000b883a 	mov	r5,zero
 90817ec:	01c001c4 	movi	r7,7
 90817f0:	9093b080 	call	9093b08 <OSTaskCreateExt>
 90817f4:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 90817f8:	e13fff03 	ldbu	r4,-4(fp)
 90817fc:	000b883a 	mov	r5,zero
 9081800:	90803040 	call	9080304 <alt_uCOSIIErrorHandler>

}
 9081804:	e037883a 	mov	sp,fp
 9081808:	dfc00117 	ldw	ra,4(sp)
 908180c:	df000017 	ldw	fp,0(sp)
 9081810:	dec00204 	addi	sp,sp,8
 9081814:	f800283a 	ret

09081818 <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 9081818:	defffd04 	addi	sp,sp,-12
 908181c:	dfc00215 	stw	ra,8(sp)
 9081820:	df000115 	stw	fp,4(sp)
 9081824:	df000104 	addi	fp,sp,4
 9081828:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 908182c:	e0bfff17 	ldw	r2,-4(fp)
 9081830:	1009883a 	mov	r4,r2
 9081834:	01817c04 	movi	r6,1520
 9081838:	000b883a 	mov	r5,zero
 908183c:	90823f80 	call	90823f8 <memset>

  conn->fd = -1;
 9081840:	e0ffff17 	ldw	r3,-4(fp)
 9081844:	00bfffc4 	movi	r2,-1
 9081848:	18800115 	stw	r2,4(r3)
  conn->state = READY;
 908184c:	e0bfff17 	ldw	r2,-4(fp)
 9081850:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 9081854:	e0bfff17 	ldw	r2,-4(fp)
 9081858:	10c00304 	addi	r3,r2,12
 908185c:	e0bfff17 	ldw	r2,-4(fp)
 9081860:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 9081864:	e0bfff17 	ldw	r2,-4(fp)
 9081868:	10c00304 	addi	r3,r2,12
 908186c:	e0bfff17 	ldw	r2,-4(fp)
 9081870:	10c17a15 	stw	r3,1512(r2)
  return;
}
 9081874:	e037883a 	mov	sp,fp
 9081878:	dfc00117 	ldw	ra,4(sp)
 908187c:	df000017 	ldw	fp,0(sp)
 9081880:	dec00204 	addi	sp,sp,8
 9081884:	f800283a 	ret

09081888 <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 9081888:	defe8504 	addi	sp,sp,-1516
 908188c:	dfc17a15 	stw	ra,1512(sp)
 9081890:	df017915 	stw	fp,1508(sp)
 9081894:	df017904 	addi	fp,sp,1508
 9081898:	e13fff15 	stw	r4,-4(fp)
  alt_u8  tx_buf[SSS_TX_BUF_SIZE];
  alt_u8 *tx_wr_pos = tx_buf;
 908189c:	e0be8804 	addi	r2,fp,-1504
 90818a0:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 90818a4:	e0be8717 	ldw	r2,-1508(fp)
 90818a8:	00c24374 	movhi	r3,2317
 90818ac:	18ef3204 	addi	r3,r3,-17208
 90818b0:	1009883a 	mov	r4,r2
 90818b4:	180b883a 	mov	r5,r3
 90818b8:	01800904 	movi	r6,36
 90818bc:	90822780 	call	9082278 <memcpy>
 90818c0:	e0be8717 	ldw	r2,-1508(fp)
 90818c4:	108008c4 	addi	r2,r2,35
 90818c8:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Nios II Simple Socket Server Menu\n\r");
 90818cc:	e0be8717 	ldw	r2,-1508(fp)
 90818d0:	00c24374 	movhi	r3,2317
 90818d4:	18ef3b04 	addi	r3,r3,-17172
 90818d8:	1009883a 	mov	r4,r2
 90818dc:	180b883a 	mov	r5,r3
 90818e0:	01800904 	movi	r6,36
 90818e4:	90822780 	call	9082278 <memcpy>
 90818e8:	e0be8717 	ldw	r2,-1508(fp)
 90818ec:	108008c4 	addi	r2,r2,35
 90818f0:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 90818f4:	e0be8717 	ldw	r2,-1508(fp)
 90818f8:	00c24374 	movhi	r3,2317
 90818fc:	18ef3204 	addi	r3,r3,-17208
 9081900:	1009883a 	mov	r4,r2
 9081904:	180b883a 	mov	r5,r3
 9081908:	01800904 	movi	r6,36
 908190c:	90822780 	call	9082278 <memcpy>
 9081910:	e0be8717 	ldw	r2,-1508(fp)
 9081914:	108008c4 	addi	r2,r2,35
 9081918:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"0-7: Toggle board LEDs D0 - D7\n\r");
 908191c:	e0be8717 	ldw	r2,-1508(fp)
 9081920:	00c24374 	movhi	r3,2317
 9081924:	18ef4404 	addi	r3,r3,-17136
 9081928:	1009883a 	mov	r4,r2
 908192c:	180b883a 	mov	r5,r3
 9081930:	01800844 	movi	r6,33
 9081934:	90822780 	call	9082278 <memcpy>
 9081938:	e0be8717 	ldw	r2,-1508(fp)
 908193c:	10800804 	addi	r2,r2,32
 9081940:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"S: 7-Segment LED Light Show\n\r");
 9081944:	e0be8717 	ldw	r2,-1508(fp)
 9081948:	00c24374 	movhi	r3,2317
 908194c:	18ef4d04 	addi	r3,r3,-17100
 9081950:	1009883a 	mov	r4,r2
 9081954:	180b883a 	mov	r5,r3
 9081958:	01800784 	movi	r6,30
 908195c:	90822780 	call	9082278 <memcpy>
 9081960:	e0be8717 	ldw	r2,-1508(fp)
 9081964:	10800744 	addi	r2,r2,29
 9081968:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Q: Terminate session\n\r");
 908196c:	e0be8717 	ldw	r2,-1508(fp)
 9081970:	00c24374 	movhi	r3,2317
 9081974:	18ef5504 	addi	r3,r3,-17068
 9081978:	1009883a 	mov	r4,r2
 908197c:	180b883a 	mov	r5,r3
 9081980:	018005c4 	movi	r6,23
 9081984:	90822780 	call	9082278 <memcpy>
 9081988:	e0be8717 	ldw	r2,-1508(fp)
 908198c:	10800584 	addi	r2,r2,22
 9081990:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 9081994:	e0be8717 	ldw	r2,-1508(fp)
 9081998:	00c24374 	movhi	r3,2317
 908199c:	18ef3204 	addi	r3,r3,-17208
 90819a0:	1009883a 	mov	r4,r2
 90819a4:	180b883a 	mov	r5,r3
 90819a8:	01800904 	movi	r6,36
 90819ac:	90822780 	call	9082278 <memcpy>
 90819b0:	e0be8717 	ldw	r2,-1508(fp)
 90819b4:	108008c4 	addi	r2,r2,35
 90819b8:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 90819bc:	e0be8717 	ldw	r2,-1508(fp)
 90819c0:	00c24374 	movhi	r3,2317
 90819c4:	18ef5b04 	addi	r3,r3,-17044
 90819c8:	1009883a 	mov	r4,r2
 90819cc:	180b883a 	mov	r5,r3
 90819d0:	01800904 	movi	r6,36
 90819d4:	90822780 	call	9082278 <memcpy>
 90819d8:	e0be8717 	ldw	r2,-1508(fp)
 90819dc:	108008c4 	addi	r2,r2,35
 90819e0:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 90819e4:	e0bfff17 	ldw	r2,-4(fp)
 90819e8:	11000117 	ldw	r4,4(r2)
 90819ec:	e17e8804 	addi	r5,fp,-1504
 90819f0:	e0fe8717 	ldw	r3,-1508(fp)
 90819f4:	e0be8804 	addi	r2,fp,-1504
 90819f8:	188dc83a 	sub	r6,r3,r2
 90819fc:	000f883a 	mov	r7,zero
 9081a00:	90ad8240 	call	90ad824 <t_send>
  
  return;
}
 9081a04:	e037883a 	mov	sp,fp
 9081a08:	dfc00117 	ldw	ra,4(sp)
 9081a0c:	df000017 	ldw	fp,0(sp)
 9081a10:	dec00204 	addi	sp,sp,8
 9081a14:	f800283a 	ret

09081a18 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 9081a18:	defff604 	addi	sp,sp,-40
 9081a1c:	dfc00915 	stw	ra,36(sp)
 9081a20:	df000815 	stw	fp,32(sp)
 9081a24:	df000804 	addi	fp,sp,32
 9081a28:	e13ffe15 	stw	r4,-8(fp)
 9081a2c:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 9081a30:	00800404 	movi	r2,16
 9081a34:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 9081a38:	e0bfff17 	ldw	r2,-4(fp)
 9081a3c:	10800117 	ldw	r2,4(r2)
 9081a40:	10bfffd8 	cmpnei	r2,r2,-1
 9081a44:	1000191e 	bne	r2,zero,9081aac <sss_handle_accept+0x94>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 9081a48:	e17ffa04 	addi	r5,fp,-24
 9081a4c:	e1bff904 	addi	r6,fp,-28
 9081a50:	e13ffe17 	ldw	r4,-8(fp)
 9081a54:	90a32a00 	call	90a32a0 <bsd_accept>
 9081a58:	e0bff815 	stw	r2,-32(fp)
 9081a5c:	e0bff817 	ldw	r2,-32(fp)
 9081a60:	1004403a 	cmpge	r2,r2,zero
 9081a64:	1000051e 	bne	r2,zero,9081a7c <sss_handle_accept+0x64>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 9081a68:	01003fc4 	movi	r4,255
 9081a6c:	01424374 	movhi	r5,2317
 9081a70:	296f6404 	addi	r5,r5,-17008
 9081a74:	90809280 	call	9080928 <alt_NetworkErrorHandler>
 9081a78:	00001206 	br	9081ac4 <sss_handle_accept+0xac>
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 9081a7c:	e0bfff17 	ldw	r2,-4(fp)
 9081a80:	e0fff817 	ldw	r3,-32(fp)
 9081a84:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 9081a88:	e13fff17 	ldw	r4,-4(fp)
 9081a8c:	90818880 	call	9081888 <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 9081a90:	e13ffb17 	ldw	r4,-20(fp)
 9081a94:	90a3a0c0 	call	90a3a0c <bsd_inet_ntoa>
 9081a98:	100b883a 	mov	r5,r2
 9081a9c:	01024374 	movhi	r4,2317
 9081aa0:	212f6d04 	addi	r4,r4,-16972
 9081aa4:	90825100 	call	9082510 <printf>
 9081aa8:	00000606 	br	9081ac4 <sss_handle_accept+0xac>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 9081aac:	e13ffb17 	ldw	r4,-20(fp)
 9081ab0:	90a3a0c0 	call	90a3a0c <bsd_inet_ntoa>
 9081ab4:	100b883a 	mov	r5,r2
 9081ab8:	01024374 	movhi	r4,2317
 9081abc:	212f7c04 	addi	r4,r4,-16912
 9081ac0:	90825100 	call	9082510 <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
}
 9081ac4:	e037883a 	mov	sp,fp
 9081ac8:	dfc00117 	ldw	ra,4(sp)
 9081acc:	df000017 	ldw	fp,0(sp)
 9081ad0:	dec00204 	addi	sp,sp,8
 9081ad4:	f800283a 	ret

09081ad8 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 9081ad8:	defe8104 	addi	sp,sp,-1532
 9081adc:	dfc17e15 	stw	ra,1528(sp)
 9081ae0:	df017d15 	stw	fp,1524(sp)
 9081ae4:	df017d04 	addi	fp,sp,1524
 9081ae8:	e13ffe15 	stw	r4,-8(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 9081aec:	e0bffe17 	ldw	r2,-8(fp)
 9081af0:	10817b17 	ldw	r2,1516(r2)
 9081af4:	1007883a 	mov	r3,r2
 9081af8:	e0bffe17 	ldw	r2,-8(fp)
 9081afc:	10817a17 	ldw	r2,1512(r2)
 9081b00:	1885c83a 	sub	r2,r3,r2
 9081b04:	e0be8615 	stw	r2,-1512(fp)
   INT8U tx_buf[SSS_TX_BUF_SIZE];
   INT8U *tx_wr_pos = tx_buf;
 9081b08:	e0be8704 	addi	r2,fp,-1508
 9081b0c:	e0be8515 	stw	r2,-1516(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 9081b10:	00800c04 	movi	r2,48
 9081b14:	d0a05915 	stw	r2,-32412(gp)

   while(bytes_to_process--)
 9081b18:	00004506 	br	9081c30 <sss_exec_command+0x158>
   {
      SSSCommand = toupper(*(conn->rx_rd_pos++));
 9081b1c:	e0bffe17 	ldw	r2,-8(fp)
 9081b20:	10c17a17 	ldw	r3,1512(r2)
 9081b24:	18800003 	ldbu	r2,0(r3)
 9081b28:	10803fcc 	andi	r2,r2,255
 9081b2c:	e0be8315 	stw	r2,-1524(fp)
 9081b30:	18c00044 	addi	r3,r3,1
 9081b34:	e0bffe17 	ldw	r2,-8(fp)
 9081b38:	10c17a15 	stw	r3,1512(r2)
 9081b3c:	00824374 	movhi	r2,2317
 9081b40:	108b9a04 	addi	r2,r2,11880
 9081b44:	10c00017 	ldw	r3,0(r2)
 9081b48:	e0be8317 	ldw	r2,-1524(fp)
 9081b4c:	1885883a 	add	r2,r3,r2
 9081b50:	10800003 	ldbu	r2,0(r2)
 9081b54:	10803fcc 	andi	r2,r2,255
 9081b58:	1080008c 	andi	r2,r2,2
 9081b5c:	1005003a 	cmpeq	r2,r2,zero
 9081b60:	1000041e 	bne	r2,zero,9081b74 <sss_exec_command+0x9c>
 9081b64:	e0be8317 	ldw	r2,-1524(fp)
 9081b68:	10bff804 	addi	r2,r2,-32
 9081b6c:	e0bfff15 	stw	r2,-4(fp)
 9081b70:	00000206 	br	9081b7c <sss_exec_command+0xa4>
 9081b74:	e0be8317 	ldw	r2,-1524(fp)
 9081b78:	e0bfff15 	stw	r2,-4(fp)
 9081b7c:	e0bfff17 	ldw	r2,-4(fp)
 9081b80:	d0a05915 	stw	r2,-32412(gp)
    
      if(SSSCommand >= ' ' && SSSCommand <= '~')
 9081b84:	d0a05917 	ldw	r2,-32412(gp)
 9081b88:	10800830 	cmpltui	r2,r2,32
 9081b8c:	1000281e 	bne	r2,zero,9081c30 <sss_exec_command+0x158>
 9081b90:	d0a05917 	ldw	r2,-32412(gp)
 9081b94:	10801fe8 	cmpgeui	r2,r2,127
 9081b98:	1000251e 	bne	r2,zero,9081c30 <sss_exec_command+0x158>
      {
         tx_wr_pos += sprintf(tx_wr_pos,
 9081b9c:	e13e8517 	ldw	r4,-1516(fp)
 9081ba0:	d0a05917 	ldw	r2,-32412(gp)
 9081ba4:	11803fcc 	andi	r6,r2,255
 9081ba8:	3180201c 	xori	r6,r6,128
 9081bac:	31bfe004 	addi	r6,r6,-128
 9081bb0:	01424374 	movhi	r5,2317
 9081bb4:	296f8b04 	addi	r5,r5,-16852
 9081bb8:	90828ac0 	call	90828ac <sprintf>
 9081bbc:	1007883a 	mov	r3,r2
 9081bc0:	e0be8517 	ldw	r2,-1516(fp)
 9081bc4:	10c5883a 	add	r2,r2,r3
 9081bc8:	e0be8515 	stw	r2,-1516(fp)
                              "--> Simple Socket Server Command %c.\n",
                              (char)SSSCommand);
         if (SSSCommand == CMD_QUIT)
 9081bcc:	d0a05917 	ldw	r2,-32412(gp)
 9081bd0:	10801458 	cmpnei	r2,r2,81
 9081bd4:	10000e1e 	bne	r2,zero,9081c10 <sss_exec_command+0x138>
         {
            tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 9081bd8:	e0be8517 	ldw	r2,-1516(fp)
 9081bdc:	00c24374 	movhi	r3,2317
 9081be0:	18ef9504 	addi	r3,r3,-16812
 9081be4:	1009883a 	mov	r4,r2
 9081be8:	180b883a 	mov	r5,r3
 9081bec:	018006c4 	movi	r6,27
 9081bf0:	90822780 	call	9082278 <memcpy>
 9081bf4:	e0be8517 	ldw	r2,-1516(fp)
 9081bf8:	10800684 	addi	r2,r2,26
 9081bfc:	e0be8515 	stw	r2,-1516(fp)
            conn->close = 1;
 9081c00:	e0fffe17 	ldw	r3,-8(fp)
 9081c04:	00800044 	movi	r2,1
 9081c08:	18800215 	stw	r2,8(r3)
 9081c0c:	00000806 	br	9081c30 <sss_exec_command+0x158>
         }
         else
         {
            error_code = OSQPost(SSSLEDCommandQ, (void *)SSSCommand);    
 9081c10:	d1205a17 	ldw	r4,-32408(gp)
 9081c14:	d0a05917 	ldw	r2,-32412(gp)
 9081c18:	100b883a 	mov	r5,r2
 9081c1c:	90920900 	call	9092090 <OSQPost>
 9081c20:	e0be8405 	stb	r2,-1520(fp)

            alt_SSSErrorHandler(error_code, 0);
 9081c24:	e13e8403 	ldbu	r4,-1520(fp)
 9081c28:	000b883a 	mov	r5,zero
 9081c2c:	9080bc00 	call	9080bc0 <alt_SSSErrorHandler>
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--)
 9081c30:	e0be8617 	ldw	r2,-1512(fp)
 9081c34:	10bfffc4 	addi	r2,r2,-1
 9081c38:	e0be8615 	stw	r2,-1512(fp)
 9081c3c:	e0be8617 	ldw	r2,-1512(fp)
 9081c40:	10bfffd8 	cmpnei	r2,r2,-1
 9081c44:	103fb51e 	bne	r2,zero,9081b1c <sss_exec_command+0x44>
            alt_SSSErrorHandler(error_code, 0);
         }
      }
   }             

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 9081c48:	e0bffe17 	ldw	r2,-8(fp)
 9081c4c:	11000117 	ldw	r4,4(r2)
 9081c50:	e17e8704 	addi	r5,fp,-1508
 9081c54:	e0fe8517 	ldw	r3,-1516(fp)
 9081c58:	e0be8704 	addi	r2,fp,-1508
 9081c5c:	188dc83a 	sub	r6,r3,r2
 9081c60:	000f883a 	mov	r7,zero
 9081c64:	90ad8240 	call	90ad824 <t_send>
  
  return;
}
 9081c68:	e037883a 	mov	sp,fp
 9081c6c:	dfc00117 	ldw	ra,4(sp)
 9081c70:	df000017 	ldw	fp,0(sp)
 9081c74:	dec00204 	addi	sp,sp,8
 9081c78:	f800283a 	ret

09081c7c <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 9081c7c:	defff904 	addi	sp,sp,-28
 9081c80:	dfc00615 	stw	ra,24(sp)
 9081c84:	df000515 	stw	fp,20(sp)
 9081c88:	df000504 	addi	fp,sp,20
 9081c8c:	e13ffe15 	stw	r4,-8(fp)
  int data_used = 0, rx_code = 0;
 9081c90:	e03ffd15 	stw	zero,-12(fp)
 9081c94:	e03ffc15 	stw	zero,-16(fp)
  INT8U *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 9081c98:	e0bffe17 	ldw	r2,-8(fp)
 9081c9c:	10c00304 	addi	r3,r2,12
 9081ca0:	e0bffe17 	ldw	r2,-8(fp)
 9081ca4:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 9081ca8:	e0bffe17 	ldw	r2,-8(fp)
 9081cac:	10c00304 	addi	r3,r2,12
 9081cb0:	e0bffe17 	ldw	r2,-8(fp)
 9081cb4:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 9081cb8:	01024374 	movhi	r4,2317
 9081cbc:	212f9c04 	addi	r4,r4,-16784
 9081cc0:	90828380 	call	9082838 <puts>
  
  while(conn->state != CLOSE)
 9081cc4:	00005706 	br	9081e24 <sss_handle_receive+0x1a8>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr(conn->rx_buffer, '\n');
 9081cc8:	e0bffe17 	ldw	r2,-8(fp)
 9081ccc:	10800304 	addi	r2,r2,12
 9081cd0:	1009883a 	mov	r4,r2
 9081cd4:	01400284 	movi	r5,10
 9081cd8:	90829800 	call	9082980 <strchr>
 9081cdc:	e0bffb15 	stw	r2,-20(fp)
      
    if(lf_addr)
 9081ce0:	e0bffb17 	ldw	r2,-20(fp)
 9081ce4:	1005003a 	cmpeq	r2,r2,zero
 9081ce8:	1000031e 	bne	r2,zero,9081cf8 <sss_handle_receive+0x7c>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 9081cec:	e13ffe17 	ldw	r4,-8(fp)
 9081cf0:	9081ad80 	call	9081ad8 <sss_exec_command>
 9081cf4:	00001c06 	br	9081d68 <sss_handle_receive+0xec>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, conn->rx_wr_pos, 
 9081cf8:	e0bffe17 	ldw	r2,-8(fp)
 9081cfc:	11000117 	ldw	r4,4(r2)
 9081d00:	e0bffe17 	ldw	r2,-8(fp)
 9081d04:	10817b17 	ldw	r2,1516(r2)
 9081d08:	100b883a 	mov	r5,r2
 9081d0c:	e0bffe17 	ldw	r2,-8(fp)
 9081d10:	10800304 	addi	r2,r2,12
 9081d14:	1007883a 	mov	r3,r2
 9081d18:	e0bffe17 	ldw	r2,-8(fp)
 9081d1c:	10817b17 	ldw	r2,1516(r2)
 9081d20:	1885c83a 	sub	r2,r3,r2
 9081d24:	118176c4 	addi	r6,r2,1499
 9081d28:	000f883a 	mov	r7,zero
 9081d2c:	90ad3b80 	call	90ad3b8 <t_recv>
 9081d30:	e0bffc15 	stw	r2,-16(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 9081d34:	e0bffc17 	ldw	r2,-16(fp)
 9081d38:	10800050 	cmplti	r2,r2,1
 9081d3c:	10000a1e 	bne	r2,zero,9081d68 <sss_handle_receive+0xec>
      {
        conn->rx_wr_pos += rx_code;
 9081d40:	e0bffe17 	ldw	r2,-8(fp)
 9081d44:	10c17b17 	ldw	r3,1516(r2)
 9081d48:	e0bffc17 	ldw	r2,-16(fp)
 9081d4c:	1887883a 	add	r3,r3,r2
 9081d50:	e0bffe17 	ldw	r2,-8(fp)
 9081d54:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 9081d58:	e0bffe17 	ldw	r2,-8(fp)
 9081d5c:	10817b17 	ldw	r2,1516(r2)
 9081d60:	10800044 	addi	r2,r2,1
 9081d64:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 9081d68:	e0bffe17 	ldw	r2,-8(fp)
 9081d6c:	10800217 	ldw	r2,8(r2)
 9081d70:	1005003a 	cmpeq	r2,r2,zero
 9081d74:	1000031e 	bne	r2,zero,9081d84 <sss_handle_receive+0x108>
 9081d78:	00800084 	movi	r2,2
 9081d7c:	e0bfff15 	stw	r2,-4(fp)
 9081d80:	00000106 	br	9081d88 <sss_handle_receive+0x10c>
 9081d84:	e03fff15 	stw	zero,-4(fp)
 9081d88:	e0bffe17 	ldw	r2,-8(fp)
 9081d8c:	e0ffff17 	ldw	r3,-4(fp)
 9081d90:	10c00015 	stw	r3,0(r2)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 9081d94:	e0bffe17 	ldw	r2,-8(fp)
 9081d98:	10817a17 	ldw	r2,1512(r2)
 9081d9c:	1007883a 	mov	r3,r2
 9081da0:	e0bffe17 	ldw	r2,-8(fp)
 9081da4:	10800304 	addi	r2,r2,12
 9081da8:	1885c83a 	sub	r2,r3,r2
 9081dac:	e0bffd15 	stw	r2,-12(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 9081db0:	e0bffe17 	ldw	r2,-8(fp)
 9081db4:	11000304 	addi	r4,r2,12
 9081db8:	e0bffe17 	ldw	r2,-8(fp)
 9081dbc:	11417a17 	ldw	r5,1512(r2)
 9081dc0:	e0bffe17 	ldw	r2,-8(fp)
 9081dc4:	10817b17 	ldw	r2,1516(r2)
 9081dc8:	1007883a 	mov	r3,r2
 9081dcc:	e0bffe17 	ldw	r2,-8(fp)
 9081dd0:	10817a17 	ldw	r2,1512(r2)
 9081dd4:	1885c83a 	sub	r2,r3,r2
 9081dd8:	100d883a 	mov	r6,r2
 9081ddc:	90823180 	call	9082318 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 9081de0:	e0bffe17 	ldw	r2,-8(fp)
 9081de4:	10c00304 	addi	r3,r2,12
 9081de8:	e0bffe17 	ldw	r2,-8(fp)
 9081dec:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 9081df0:	e0bffe17 	ldw	r2,-8(fp)
 9081df4:	10c17b17 	ldw	r3,1516(r2)
 9081df8:	e0bffd17 	ldw	r2,-12(fp)
 9081dfc:	1887c83a 	sub	r3,r3,r2
 9081e00:	e0bffe17 	ldw	r2,-8(fp)
 9081e04:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 9081e08:	e0bffe17 	ldw	r2,-8(fp)
 9081e0c:	10817b17 	ldw	r2,1516(r2)
 9081e10:	e0fffd17 	ldw	r3,-12(fp)
 9081e14:	1009883a 	mov	r4,r2
 9081e18:	180d883a 	mov	r6,r3
 9081e1c:	000b883a 	mov	r5,zero
 9081e20:	90823f80 	call	90823f8 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 9081e24:	e0bffe17 	ldw	r2,-8(fp)
 9081e28:	10800017 	ldw	r2,0(r2)
 9081e2c:	10800098 	cmpnei	r2,r2,2
 9081e30:	103fa51e 	bne	r2,zero,9081cc8 <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 9081e34:	01024374 	movhi	r4,2317
 9081e38:	212fa604 	addi	r4,r4,-16744
 9081e3c:	90828380 	call	9082838 <puts>
  close(conn->fd);
 9081e40:	e0bffe17 	ldw	r2,-8(fp)
 9081e44:	11000117 	ldw	r4,4(r2)
 9081e48:	90a0b9c0 	call	90a0b9c <close>
  sss_reset_connection(conn);
 9081e4c:	e13ffe17 	ldw	r4,-8(fp)
 9081e50:	90818180 	call	9081818 <sss_reset_connection>
  
  return;
}
 9081e54:	e037883a 	mov	sp,fp
 9081e58:	dfc00117 	ldw	ra,4(sp)
 9081e5c:	df000017 	ldw	fp,0(sp)
 9081e60:	dec00204 	addi	sp,sp,8
 9081e64:	f800283a 	ret

09081e68 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 9081e68:	deffb604 	addi	sp,sp,-296
 9081e6c:	dfc04915 	stw	ra,292(sp)
 9081e70:	df004815 	stw	fp,288(sp)
 9081e74:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 9081e78:	01000084 	movi	r4,2
 9081e7c:	01400044 	movi	r5,1
 9081e80:	000d883a 	mov	r6,zero
 9081e84:	90ac5840 	call	90ac584 <t_socket>
 9081e88:	e0bfba15 	stw	r2,-280(fp)
 9081e8c:	e0bfba17 	ldw	r2,-280(fp)
 9081e90:	1004403a 	cmpge	r2,r2,zero
 9081e94:	1000041e 	bne	r2,zero,9081ea8 <SSSSimpleSocketServerTask+0x40>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 9081e98:	01003fc4 	movi	r4,255
 9081e9c:	01424374 	movhi	r5,2317
 9081ea0:	296fb004 	addi	r5,r5,-16704
 9081ea4:	90809280 	call	9080928 <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 9081ea8:	00800084 	movi	r2,2
 9081eac:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 9081eb0:	00878004 	movi	r2,7680
 9081eb4:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 9081eb8:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 9081ebc:	e17fbb04 	addi	r5,fp,-276
 9081ec0:	e13fba17 	ldw	r4,-280(fp)
 9081ec4:	01800404 	movi	r6,16
 9081ec8:	90ac6140 	call	90ac614 <t_bind>
 9081ecc:	1004403a 	cmpge	r2,r2,zero
 9081ed0:	1000041e 	bne	r2,zero,9081ee4 <SSSSimpleSocketServerTask+0x7c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 9081ed4:	01003fc4 	movi	r4,255
 9081ed8:	01424374 	movhi	r5,2317
 9081edc:	296fb904 	addi	r5,r5,-16668
 9081ee0:	90809280 	call	9080928 <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 9081ee4:	e13fba17 	ldw	r4,-280(fp)
 9081ee8:	01400044 	movi	r5,1
 9081eec:	90ac7900 	call	90ac790 <t_listen>
 9081ef0:	1004403a 	cmpge	r2,r2,zero
 9081ef4:	1000041e 	bne	r2,zero,9081f08 <SSSSimpleSocketServerTask+0xa0>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 9081ef8:	01003fc4 	movi	r4,255
 9081efc:	01424374 	movhi	r5,2317
 9081f00:	296fbf04 	addi	r5,r5,-16644
 9081f04:	90809280 	call	9080928 <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 9081f08:	01024374 	movhi	r4,2317
 9081f0c:	210c7704 	addi	r4,r4,12764
 9081f10:	90818180 	call	9081818 <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 9081f14:	01024374 	movhi	r4,2317
 9081f18:	212fc604 	addi	r4,r4,-16616
 9081f1c:	01400784 	movi	r5,30
 9081f20:	90825100 	call	9082510 <printf>
 9081f24:	00000006 	br	9081f28 <SSSSimpleSocketServerTask+0xc0>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 9081f28:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 9081f2c:	e17fbf04 	addi	r5,fp,-260
 9081f30:	e13fba17 	ldw	r4,-280(fp)
 9081f34:	90b1be40 	call	90b1be4 <ifd_set>
    max_socket = fd_listen+1;
 9081f38:	e0bfba17 	ldw	r2,-280(fp)
 9081f3c:	10800044 	addi	r2,r2,1
 9081f40:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 9081f44:	00824374 	movhi	r2,2317
 9081f48:	108c7704 	addi	r2,r2,12764
 9081f4c:	10800117 	ldw	r2,4(r2)
 9081f50:	10bfffe0 	cmpeqi	r2,r2,-1
 9081f54:	10000f1e 	bne	r2,zero,9081f94 <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 9081f58:	00824374 	movhi	r2,2317
 9081f5c:	108c7704 	addi	r2,r2,12764
 9081f60:	11000117 	ldw	r4,4(r2)
 9081f64:	e17fbf04 	addi	r5,fp,-260
 9081f68:	90b1be40 	call	90b1be4 <ifd_set>
      if (max_socket <= conn.fd)
 9081f6c:	00824374 	movhi	r2,2317
 9081f70:	108c7704 	addi	r2,r2,12764
 9081f74:	10c00117 	ldw	r3,4(r2)
 9081f78:	e0bfb917 	ldw	r2,-284(fp)
 9081f7c:	18800516 	blt	r3,r2,9081f94 <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 9081f80:	00824374 	movhi	r2,2317
 9081f84:	108c7704 	addi	r2,r2,12764
 9081f88:	10800117 	ldw	r2,4(r2)
 9081f8c:	10800044 	addi	r2,r2,1
 9081f90:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 9081f94:	e17fbf04 	addi	r5,fp,-260
 9081f98:	d8000015 	stw	zero,0(sp)
 9081f9c:	e13fb917 	ldw	r4,-284(fp)
 9081fa0:	000d883a 	mov	r6,zero
 9081fa4:	000f883a 	mov	r7,zero
 9081fa8:	90a3b9c0 	call	90a3b9c <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 9081fac:	e17fbf04 	addi	r5,fp,-260
 9081fb0:	e13fba17 	ldw	r4,-280(fp)
 9081fb4:	90b1c580 	call	90b1c58 <ifd_isset>
 9081fb8:	1005003a 	cmpeq	r2,r2,zero
 9081fbc:	1000051e 	bne	r2,zero,9081fd4 <SSSSimpleSocketServerTask+0x16c>
    {
      sss_handle_accept(fd_listen, &conn);
 9081fc0:	e13fba17 	ldw	r4,-280(fp)
 9081fc4:	01424374 	movhi	r5,2317
 9081fc8:	294c7704 	addi	r5,r5,12764
 9081fcc:	9081a180 	call	9081a18 <sss_handle_accept>
 9081fd0:	003fd506 	br	9081f28 <SSSSimpleSocketServerTask+0xc0>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 9081fd4:	00824374 	movhi	r2,2317
 9081fd8:	108c7704 	addi	r2,r2,12764
 9081fdc:	10800117 	ldw	r2,4(r2)
 9081fe0:	10bfffe0 	cmpeqi	r2,r2,-1
 9081fe4:	103fd01e 	bne	r2,zero,9081f28 <SSSSimpleSocketServerTask+0xc0>
 9081fe8:	00824374 	movhi	r2,2317
 9081fec:	108c7704 	addi	r2,r2,12764
 9081ff0:	11000117 	ldw	r4,4(r2)
 9081ff4:	e17fbf04 	addi	r5,fp,-260
 9081ff8:	90b1c580 	call	90b1c58 <ifd_isset>
 9081ffc:	1005003a 	cmpeq	r2,r2,zero
 9082000:	103fc91e 	bne	r2,zero,9081f28 <SSSSimpleSocketServerTask+0xc0>
      {
        sss_handle_receive(&conn);
 9082004:	01024374 	movhi	r4,2317
 9082008:	210c7704 	addi	r4,r4,12764
 908200c:	9081c7c0 	call	9081c7c <sss_handle_receive>
      }
    }
  } /* while(1) */
 9082010:	003fc506 	br	9081f28 <SSSSimpleSocketServerTask+0xc0>

09082014 <fprintf>:
 9082014:	defffc04 	addi	sp,sp,-16
 9082018:	dfc00115 	stw	ra,4(sp)
 908201c:	d9800215 	stw	r6,8(sp)
 9082020:	d9c00315 	stw	r7,12(sp)
 9082024:	d8800204 	addi	r2,sp,8
 9082028:	100d883a 	mov	r6,r2
 908202c:	d8800015 	stw	r2,0(sp)
 9082030:	90850540 	call	9085054 <__vfprintf_internal>
 9082034:	dfc00117 	ldw	ra,4(sp)
 9082038:	dec00404 	addi	sp,sp,16
 908203c:	f800283a 	ret

09082040 <_fprintf_r>:
 9082040:	defffd04 	addi	sp,sp,-12
 9082044:	2807883a 	mov	r3,r5
 9082048:	dfc00115 	stw	ra,4(sp)
 908204c:	d9c00215 	stw	r7,8(sp)
 9082050:	d8800204 	addi	r2,sp,8
 9082054:	300b883a 	mov	r5,r6
 9082058:	1809883a 	mov	r4,r3
 908205c:	100d883a 	mov	r6,r2
 9082060:	d8800015 	stw	r2,0(sp)
 9082064:	90850540 	call	9085054 <__vfprintf_internal>
 9082068:	dfc00117 	ldw	ra,4(sp)
 908206c:	dec00304 	addi	sp,sp,12
 9082070:	f800283a 	ret

09082074 <_fwrite_r>:
 9082074:	defff604 	addi	sp,sp,-40
 9082078:	dc400615 	stw	r17,24(sp)
 908207c:	39a3383a 	mul	r17,r7,r6
 9082080:	00800044 	movi	r2,1
 9082084:	dcc00815 	stw	r19,32(sp)
 9082088:	dc800715 	stw	r18,28(sp)
 908208c:	dc000515 	stw	r16,20(sp)
 9082090:	dfc00915 	stw	ra,36(sp)
 9082094:	3825883a 	mov	r18,r7
 9082098:	3027883a 	mov	r19,r6
 908209c:	2021883a 	mov	r16,r4
 90820a0:	d9400015 	stw	r5,0(sp)
 90820a4:	d8800315 	stw	r2,12(sp)
 90820a8:	dc400115 	stw	r17,4(sp)
 90820ac:	dc400415 	stw	r17,16(sp)
 90820b0:	dec00215 	stw	sp,8(sp)
 90820b4:	20000226 	beq	r4,zero,90820c0 <_fwrite_r+0x4c>
 90820b8:	20800e17 	ldw	r2,56(r4)
 90820bc:	10001226 	beq	r2,zero,9082108 <_fwrite_r+0x94>
 90820c0:	d9400a17 	ldw	r5,40(sp)
 90820c4:	8009883a 	mov	r4,r16
 90820c8:	d9800204 	addi	r6,sp,8
 90820cc:	90875480 	call	9087548 <__sfvwrite_r>
 90820d0:	980b883a 	mov	r5,r19
 90820d4:	10000426 	beq	r2,zero,90820e8 <_fwrite_r+0x74>
 90820d8:	d9000417 	ldw	r4,16(sp)
 90820dc:	8909c83a 	sub	r4,r17,r4
 90820e0:	908c3080 	call	908c308 <__udivsi3>
 90820e4:	1025883a 	mov	r18,r2
 90820e8:	9005883a 	mov	r2,r18
 90820ec:	dfc00917 	ldw	ra,36(sp)
 90820f0:	dcc00817 	ldw	r19,32(sp)
 90820f4:	dc800717 	ldw	r18,28(sp)
 90820f8:	dc400617 	ldw	r17,24(sp)
 90820fc:	dc000517 	ldw	r16,20(sp)
 9082100:	dec00a04 	addi	sp,sp,40
 9082104:	f800283a 	ret
 9082108:	9086d640 	call	9086d64 <__sinit>
 908210c:	003fec06 	br	90820c0 <_fwrite_r+0x4c>

09082110 <fwrite>:
 9082110:	00824374 	movhi	r2,2317
 9082114:	108b9b04 	addi	r2,r2,11884
 9082118:	2017883a 	mov	r11,r4
 908211c:	11000017 	ldw	r4,0(r2)
 9082120:	defffe04 	addi	sp,sp,-8
 9082124:	3013883a 	mov	r9,r6
 9082128:	2805883a 	mov	r2,r5
 908212c:	d9c00015 	stw	r7,0(sp)
 9082130:	580b883a 	mov	r5,r11
 9082134:	100d883a 	mov	r6,r2
 9082138:	480f883a 	mov	r7,r9
 908213c:	dfc00115 	stw	ra,4(sp)
 9082140:	90820740 	call	9082074 <_fwrite_r>
 9082144:	dfc00117 	ldw	ra,4(sp)
 9082148:	dec00204 	addi	sp,sp,8
 908214c:	f800283a 	ret

09082150 <getc>:
 9082150:	defffd04 	addi	sp,sp,-12
 9082154:	dc400115 	stw	r17,4(sp)
 9082158:	04424374 	movhi	r17,2317
 908215c:	8c4b9b04 	addi	r17,r17,11884
 9082160:	88c00017 	ldw	r3,0(r17)
 9082164:	dc000015 	stw	r16,0(sp)
 9082168:	dfc00215 	stw	ra,8(sp)
 908216c:	2021883a 	mov	r16,r4
 9082170:	18000326 	beq	r3,zero,9082180 <getc+0x30>
 9082174:	18800e17 	ldw	r2,56(r3)
 9082178:	1809883a 	mov	r4,r3
 908217c:	10000e26 	beq	r2,zero,90821b8 <getc+0x68>
 9082180:	80800117 	ldw	r2,4(r16)
 9082184:	800b883a 	mov	r5,r16
 9082188:	10bfffc4 	addi	r2,r2,-1
 908218c:	80800115 	stw	r2,4(r16)
 9082190:	10000f16 	blt	r2,zero,90821d0 <getc+0x80>
 9082194:	80c00017 	ldw	r3,0(r16)
 9082198:	18800003 	ldbu	r2,0(r3)
 908219c:	18c00044 	addi	r3,r3,1
 90821a0:	80c00015 	stw	r3,0(r16)
 90821a4:	dfc00217 	ldw	ra,8(sp)
 90821a8:	dc400117 	ldw	r17,4(sp)
 90821ac:	dc000017 	ldw	r16,0(sp)
 90821b0:	dec00304 	addi	sp,sp,12
 90821b4:	f800283a 	ret
 90821b8:	9086d640 	call	9086d64 <__sinit>
 90821bc:	80800117 	ldw	r2,4(r16)
 90821c0:	800b883a 	mov	r5,r16
 90821c4:	10bfffc4 	addi	r2,r2,-1
 90821c8:	80800115 	stw	r2,4(r16)
 90821cc:	103ff10e 	bge	r2,zero,9082194 <getc+0x44>
 90821d0:	89000017 	ldw	r4,0(r17)
 90821d4:	dfc00217 	ldw	ra,8(sp)
 90821d8:	dc400117 	ldw	r17,4(sp)
 90821dc:	dc000017 	ldw	r16,0(sp)
 90821e0:	dec00304 	addi	sp,sp,12
 90821e4:	908284c1 	jmpi	908284c <__srget_r>

090821e8 <_getc_r>:
 90821e8:	defffd04 	addi	sp,sp,-12
 90821ec:	dc400115 	stw	r17,4(sp)
 90821f0:	dc000015 	stw	r16,0(sp)
 90821f4:	dfc00215 	stw	ra,8(sp)
 90821f8:	2021883a 	mov	r16,r4
 90821fc:	2823883a 	mov	r17,r5
 9082200:	20000226 	beq	r4,zero,908220c <_getc_r+0x24>
 9082204:	20800e17 	ldw	r2,56(r4)
 9082208:	10000f26 	beq	r2,zero,9082248 <_getc_r+0x60>
 908220c:	88800117 	ldw	r2,4(r17)
 9082210:	8009883a 	mov	r4,r16
 9082214:	880b883a 	mov	r5,r17
 9082218:	10bfffc4 	addi	r2,r2,-1
 908221c:	88800115 	stw	r2,4(r17)
 9082220:	10001016 	blt	r2,zero,9082264 <_getc_r+0x7c>
 9082224:	88c00017 	ldw	r3,0(r17)
 9082228:	18800003 	ldbu	r2,0(r3)
 908222c:	18c00044 	addi	r3,r3,1
 9082230:	88c00015 	stw	r3,0(r17)
 9082234:	dfc00217 	ldw	ra,8(sp)
 9082238:	dc400117 	ldw	r17,4(sp)
 908223c:	dc000017 	ldw	r16,0(sp)
 9082240:	dec00304 	addi	sp,sp,12
 9082244:	f800283a 	ret
 9082248:	9086d640 	call	9086d64 <__sinit>
 908224c:	88800117 	ldw	r2,4(r17)
 9082250:	8009883a 	mov	r4,r16
 9082254:	880b883a 	mov	r5,r17
 9082258:	10bfffc4 	addi	r2,r2,-1
 908225c:	88800115 	stw	r2,4(r17)
 9082260:	103ff00e 	bge	r2,zero,9082224 <_getc_r+0x3c>
 9082264:	dfc00217 	ldw	ra,8(sp)
 9082268:	dc400117 	ldw	r17,4(sp)
 908226c:	dc000017 	ldw	r16,0(sp)
 9082270:	dec00304 	addi	sp,sp,12
 9082274:	908284c1 	jmpi	908284c <__srget_r>

09082278 <memcpy>:
 9082278:	01c003c4 	movi	r7,15
 908227c:	2007883a 	mov	r3,r4
 9082280:	3980032e 	bgeu	r7,r6,9082290 <memcpy+0x18>
 9082284:	2904b03a 	or	r2,r5,r4
 9082288:	108000cc 	andi	r2,r2,3
 908228c:	10000926 	beq	r2,zero,90822b4 <memcpy+0x3c>
 9082290:	30000626 	beq	r6,zero,90822ac <memcpy+0x34>
 9082294:	30cd883a 	add	r6,r6,r3
 9082298:	28800003 	ldbu	r2,0(r5)
 908229c:	29400044 	addi	r5,r5,1
 90822a0:	18800005 	stb	r2,0(r3)
 90822a4:	18c00044 	addi	r3,r3,1
 90822a8:	30fffb1e 	bne	r6,r3,9082298 <memcpy+0x20>
 90822ac:	2005883a 	mov	r2,r4
 90822b0:	f800283a 	ret
 90822b4:	3811883a 	mov	r8,r7
 90822b8:	200f883a 	mov	r7,r4
 90822bc:	28c00017 	ldw	r3,0(r5)
 90822c0:	31bffc04 	addi	r6,r6,-16
 90822c4:	38c00015 	stw	r3,0(r7)
 90822c8:	28800117 	ldw	r2,4(r5)
 90822cc:	38800115 	stw	r2,4(r7)
 90822d0:	28c00217 	ldw	r3,8(r5)
 90822d4:	38c00215 	stw	r3,8(r7)
 90822d8:	28800317 	ldw	r2,12(r5)
 90822dc:	29400404 	addi	r5,r5,16
 90822e0:	38800315 	stw	r2,12(r7)
 90822e4:	39c00404 	addi	r7,r7,16
 90822e8:	41bff436 	bltu	r8,r6,90822bc <memcpy+0x44>
 90822ec:	008000c4 	movi	r2,3
 90822f0:	1180072e 	bgeu	r2,r6,9082310 <memcpy+0x98>
 90822f4:	1007883a 	mov	r3,r2
 90822f8:	28800017 	ldw	r2,0(r5)
 90822fc:	31bfff04 	addi	r6,r6,-4
 9082300:	29400104 	addi	r5,r5,4
 9082304:	38800015 	stw	r2,0(r7)
 9082308:	39c00104 	addi	r7,r7,4
 908230c:	19bffa36 	bltu	r3,r6,90822f8 <memcpy+0x80>
 9082310:	3807883a 	mov	r3,r7
 9082314:	003fde06 	br	9082290 <memcpy+0x18>

09082318 <memmove>:
 9082318:	2807883a 	mov	r3,r5
 908231c:	2011883a 	mov	r8,r4
 9082320:	29000c2e 	bgeu	r5,r4,9082354 <memmove+0x3c>
 9082324:	298f883a 	add	r7,r5,r6
 9082328:	21c00a2e 	bgeu	r4,r7,9082354 <memmove+0x3c>
 908232c:	30000726 	beq	r6,zero,908234c <memmove+0x34>
 9082330:	2187883a 	add	r3,r4,r6
 9082334:	198dc83a 	sub	r6,r3,r6
 9082338:	39ffffc4 	addi	r7,r7,-1
 908233c:	38800003 	ldbu	r2,0(r7)
 9082340:	18ffffc4 	addi	r3,r3,-1
 9082344:	18800005 	stb	r2,0(r3)
 9082348:	19bffb1e 	bne	r3,r6,9082338 <memmove+0x20>
 908234c:	2005883a 	mov	r2,r4
 9082350:	f800283a 	ret
 9082354:	01c003c4 	movi	r7,15
 9082358:	39800a36 	bltu	r7,r6,9082384 <memmove+0x6c>
 908235c:	303ffb26 	beq	r6,zero,908234c <memmove+0x34>
 9082360:	400f883a 	mov	r7,r8
 9082364:	320d883a 	add	r6,r6,r8
 9082368:	28800003 	ldbu	r2,0(r5)
 908236c:	29400044 	addi	r5,r5,1
 9082370:	38800005 	stb	r2,0(r7)
 9082374:	39c00044 	addi	r7,r7,1
 9082378:	39bffb1e 	bne	r7,r6,9082368 <memmove+0x50>
 908237c:	2005883a 	mov	r2,r4
 9082380:	f800283a 	ret
 9082384:	1904b03a 	or	r2,r3,r4
 9082388:	108000cc 	andi	r2,r2,3
 908238c:	103ff31e 	bne	r2,zero,908235c <memmove+0x44>
 9082390:	3811883a 	mov	r8,r7
 9082394:	180b883a 	mov	r5,r3
 9082398:	200f883a 	mov	r7,r4
 908239c:	28c00017 	ldw	r3,0(r5)
 90823a0:	31bffc04 	addi	r6,r6,-16
 90823a4:	38c00015 	stw	r3,0(r7)
 90823a8:	28800117 	ldw	r2,4(r5)
 90823ac:	38800115 	stw	r2,4(r7)
 90823b0:	28c00217 	ldw	r3,8(r5)
 90823b4:	38c00215 	stw	r3,8(r7)
 90823b8:	28800317 	ldw	r2,12(r5)
 90823bc:	29400404 	addi	r5,r5,16
 90823c0:	38800315 	stw	r2,12(r7)
 90823c4:	39c00404 	addi	r7,r7,16
 90823c8:	41bff436 	bltu	r8,r6,908239c <memmove+0x84>
 90823cc:	008000c4 	movi	r2,3
 90823d0:	1180072e 	bgeu	r2,r6,90823f0 <memmove+0xd8>
 90823d4:	1007883a 	mov	r3,r2
 90823d8:	28800017 	ldw	r2,0(r5)
 90823dc:	31bfff04 	addi	r6,r6,-4
 90823e0:	29400104 	addi	r5,r5,4
 90823e4:	38800015 	stw	r2,0(r7)
 90823e8:	39c00104 	addi	r7,r7,4
 90823ec:	19bffa36 	bltu	r3,r6,90823d8 <memmove+0xc0>
 90823f0:	3811883a 	mov	r8,r7
 90823f4:	003fd906 	br	908235c <memmove+0x44>

090823f8 <memset>:
 90823f8:	008000c4 	movi	r2,3
 90823fc:	29403fcc 	andi	r5,r5,255
 9082400:	2007883a 	mov	r3,r4
 9082404:	1180022e 	bgeu	r2,r6,9082410 <memset+0x18>
 9082408:	2084703a 	and	r2,r4,r2
 908240c:	10000826 	beq	r2,zero,9082430 <memset+0x38>
 9082410:	30000526 	beq	r6,zero,9082428 <memset+0x30>
 9082414:	2805883a 	mov	r2,r5
 9082418:	30cd883a 	add	r6,r6,r3
 908241c:	18800005 	stb	r2,0(r3)
 9082420:	18c00044 	addi	r3,r3,1
 9082424:	19bffd1e 	bne	r3,r6,908241c <memset+0x24>
 9082428:	2005883a 	mov	r2,r4
 908242c:	f800283a 	ret
 9082430:	2804923a 	slli	r2,r5,8
 9082434:	020003c4 	movi	r8,15
 9082438:	200f883a 	mov	r7,r4
 908243c:	2884b03a 	or	r2,r5,r2
 9082440:	1006943a 	slli	r3,r2,16
 9082444:	10c6b03a 	or	r3,r2,r3
 9082448:	41800a2e 	bgeu	r8,r6,9082474 <memset+0x7c>
 908244c:	4005883a 	mov	r2,r8
 9082450:	31bffc04 	addi	r6,r6,-16
 9082454:	38c00015 	stw	r3,0(r7)
 9082458:	38c00115 	stw	r3,4(r7)
 908245c:	38c00215 	stw	r3,8(r7)
 9082460:	38c00315 	stw	r3,12(r7)
 9082464:	39c00404 	addi	r7,r7,16
 9082468:	11bff936 	bltu	r2,r6,9082450 <memset+0x58>
 908246c:	008000c4 	movi	r2,3
 9082470:	1180052e 	bgeu	r2,r6,9082488 <memset+0x90>
 9082474:	31bfff04 	addi	r6,r6,-4
 9082478:	008000c4 	movi	r2,3
 908247c:	38c00015 	stw	r3,0(r7)
 9082480:	39c00104 	addi	r7,r7,4
 9082484:	11bffb36 	bltu	r2,r6,9082474 <memset+0x7c>
 9082488:	3807883a 	mov	r3,r7
 908248c:	003fe006 	br	9082410 <memset+0x18>

09082490 <_perror_r>:
 9082490:	defffe04 	addi	sp,sp,-8
 9082494:	dc000015 	stw	r16,0(sp)
 9082498:	dfc00115 	stw	ra,4(sp)
 908249c:	2021883a 	mov	r16,r4
 90824a0:	28000326 	beq	r5,zero,90824b0 <_perror_r+0x20>
 90824a4:	28800007 	ldb	r2,0(r5)
 90824a8:	2809883a 	mov	r4,r5
 90824ac:	10000c1e 	bne	r2,zero,90824e0 <_perror_r+0x50>
 90824b0:	81000017 	ldw	r4,0(r16)
 90824b4:	9082a600 	call	9082a60 <strerror>
 90824b8:	1009883a 	mov	r4,r2
 90824bc:	10000226 	beq	r2,zero,90824c8 <_perror_r+0x38>
 90824c0:	81400317 	ldw	r5,12(r16)
 90824c4:	90870ec0 	call	90870ec <fputs>
 90824c8:	81400317 	ldw	r5,12(r16)
 90824cc:	01000284 	movi	r4,10
 90824d0:	dfc00117 	ldw	ra,4(sp)
 90824d4:	dc000017 	ldw	r16,0(sp)
 90824d8:	dec00204 	addi	sp,sp,8
 90824dc:	9086fbc1 	jmpi	9086fbc <fputc>
 90824e0:	81400317 	ldw	r5,12(r16)
 90824e4:	90870ec0 	call	90870ec <fputs>
 90824e8:	81400317 	ldw	r5,12(r16)
 90824ec:	01024374 	movhi	r4,2317
 90824f0:	21307e04 	addi	r4,r4,-15880
 90824f4:	90870ec0 	call	90870ec <fputs>
 90824f8:	003fed06 	br	90824b0 <_perror_r+0x20>

090824fc <perror>:
 90824fc:	00824374 	movhi	r2,2317
 9082500:	108b9b04 	addi	r2,r2,11884
 9082504:	200b883a 	mov	r5,r4
 9082508:	11000017 	ldw	r4,0(r2)
 908250c:	90824901 	jmpi	9082490 <_perror_r>

09082510 <printf>:
 9082510:	defffb04 	addi	sp,sp,-20
 9082514:	dfc00115 	stw	ra,4(sp)
 9082518:	d9400215 	stw	r5,8(sp)
 908251c:	d9800315 	stw	r6,12(sp)
 9082520:	d9c00415 	stw	r7,16(sp)
 9082524:	00824374 	movhi	r2,2317
 9082528:	108b9b04 	addi	r2,r2,11884
 908252c:	10c00017 	ldw	r3,0(r2)
 9082530:	200b883a 	mov	r5,r4
 9082534:	d8800204 	addi	r2,sp,8
 9082538:	19000217 	ldw	r4,8(r3)
 908253c:	100d883a 	mov	r6,r2
 9082540:	d8800015 	stw	r2,0(sp)
 9082544:	90850540 	call	9085054 <__vfprintf_internal>
 9082548:	dfc00117 	ldw	ra,4(sp)
 908254c:	dec00504 	addi	sp,sp,20
 9082550:	f800283a 	ret

09082554 <_printf_r>:
 9082554:	defffc04 	addi	sp,sp,-16
 9082558:	dfc00115 	stw	ra,4(sp)
 908255c:	d9800215 	stw	r6,8(sp)
 9082560:	d9c00315 	stw	r7,12(sp)
 9082564:	280d883a 	mov	r6,r5
 9082568:	21400217 	ldw	r5,8(r4)
 908256c:	d8c00204 	addi	r3,sp,8
 9082570:	180f883a 	mov	r7,r3
 9082574:	d8c00015 	stw	r3,0(sp)
 9082578:	90831a80 	call	90831a8 <___vfprintf_internal_r>
 908257c:	dfc00117 	ldw	ra,4(sp)
 9082580:	dec00404 	addi	sp,sp,16
 9082584:	f800283a 	ret

09082588 <putc>:
 9082588:	defffc04 	addi	sp,sp,-16
 908258c:	dc800215 	stw	r18,8(sp)
 9082590:	04824374 	movhi	r18,2317
 9082594:	948b9b04 	addi	r18,r18,11884
 9082598:	90c00017 	ldw	r3,0(r18)
 908259c:	dc400115 	stw	r17,4(sp)
 90825a0:	dc000015 	stw	r16,0(sp)
 90825a4:	dfc00315 	stw	ra,12(sp)
 90825a8:	2023883a 	mov	r17,r4
 90825ac:	2821883a 	mov	r16,r5
 90825b0:	18000226 	beq	r3,zero,90825bc <putc+0x34>
 90825b4:	18800e17 	ldw	r2,56(r3)
 90825b8:	10001126 	beq	r2,zero,9082600 <putc+0x78>
 90825bc:	80800217 	ldw	r2,8(r16)
 90825c0:	10ffffc4 	addi	r3,r2,-1
 90825c4:	80c00215 	stw	r3,8(r16)
 90825c8:	18001316 	blt	r3,zero,9082618 <putc+0x90>
 90825cc:	80800017 	ldw	r2,0(r16)
 90825d0:	14400005 	stb	r17,0(r2)
 90825d4:	80c00017 	ldw	r3,0(r16)
 90825d8:	18800044 	addi	r2,r3,1
 90825dc:	18c00003 	ldbu	r3,0(r3)
 90825e0:	80800015 	stw	r2,0(r16)
 90825e4:	1805883a 	mov	r2,r3
 90825e8:	dfc00317 	ldw	ra,12(sp)
 90825ec:	dc800217 	ldw	r18,8(sp)
 90825f0:	dc400117 	ldw	r17,4(sp)
 90825f4:	dc000017 	ldw	r16,0(sp)
 90825f8:	dec00404 	addi	sp,sp,16
 90825fc:	f800283a 	ret
 9082600:	1809883a 	mov	r4,r3
 9082604:	9086d640 	call	9086d64 <__sinit>
 9082608:	80800217 	ldw	r2,8(r16)
 908260c:	10ffffc4 	addi	r3,r2,-1
 9082610:	80c00215 	stw	r3,8(r16)
 9082614:	183fed0e 	bge	r3,zero,90825cc <putc+0x44>
 9082618:	80800617 	ldw	r2,24(r16)
 908261c:	18800f16 	blt	r3,r2,908265c <putc+0xd4>
 9082620:	80800017 	ldw	r2,0(r16)
 9082624:	14400005 	stb	r17,0(r2)
 9082628:	81000017 	ldw	r4,0(r16)
 908262c:	00800284 	movi	r2,10
 9082630:	20c00003 	ldbu	r3,0(r4)
 9082634:	18801226 	beq	r3,r2,9082680 <putc+0xf8>
 9082638:	20800044 	addi	r2,r4,1
 908263c:	80800015 	stw	r2,0(r16)
 9082640:	1805883a 	mov	r2,r3
 9082644:	dfc00317 	ldw	ra,12(sp)
 9082648:	dc800217 	ldw	r18,8(sp)
 908264c:	dc400117 	ldw	r17,4(sp)
 9082650:	dc000017 	ldw	r16,0(sp)
 9082654:	dec00404 	addi	sp,sp,16
 9082658:	f800283a 	ret
 908265c:	91000017 	ldw	r4,0(r18)
 9082660:	880b883a 	mov	r5,r17
 9082664:	800d883a 	mov	r6,r16
 9082668:	dfc00317 	ldw	ra,12(sp)
 908266c:	dc800217 	ldw	r18,8(sp)
 9082670:	dc400117 	ldw	r17,4(sp)
 9082674:	dc000017 	ldw	r16,0(sp)
 9082678:	dec00404 	addi	sp,sp,16
 908267c:	90850781 	jmpi	9085078 <__swbuf_r>
 9082680:	91000017 	ldw	r4,0(r18)
 9082684:	180b883a 	mov	r5,r3
 9082688:	003ff606 	br	9082664 <putc+0xdc>

0908268c <_putc_r>:
 908268c:	defffc04 	addi	sp,sp,-16
 9082690:	dc400215 	stw	r17,8(sp)
 9082694:	dc000115 	stw	r16,4(sp)
 9082698:	dfc00315 	stw	ra,12(sp)
 908269c:	2021883a 	mov	r16,r4
 90826a0:	2823883a 	mov	r17,r5
 90826a4:	20000226 	beq	r4,zero,90826b0 <_putc_r+0x24>
 90826a8:	20800e17 	ldw	r2,56(r4)
 90826ac:	10001026 	beq	r2,zero,90826f0 <_putc_r+0x64>
 90826b0:	30800217 	ldw	r2,8(r6)
 90826b4:	10ffffc4 	addi	r3,r2,-1
 90826b8:	30c00215 	stw	r3,8(r6)
 90826bc:	18001316 	blt	r3,zero,908270c <_putc_r+0x80>
 90826c0:	30800017 	ldw	r2,0(r6)
 90826c4:	14400005 	stb	r17,0(r2)
 90826c8:	30c00017 	ldw	r3,0(r6)
 90826cc:	18800044 	addi	r2,r3,1
 90826d0:	18c00003 	ldbu	r3,0(r3)
 90826d4:	30800015 	stw	r2,0(r6)
 90826d8:	1805883a 	mov	r2,r3
 90826dc:	dfc00317 	ldw	ra,12(sp)
 90826e0:	dc400217 	ldw	r17,8(sp)
 90826e4:	dc000117 	ldw	r16,4(sp)
 90826e8:	dec00404 	addi	sp,sp,16
 90826ec:	f800283a 	ret
 90826f0:	d9800015 	stw	r6,0(sp)
 90826f4:	9086d640 	call	9086d64 <__sinit>
 90826f8:	d9800017 	ldw	r6,0(sp)
 90826fc:	30800217 	ldw	r2,8(r6)
 9082700:	10ffffc4 	addi	r3,r2,-1
 9082704:	30c00215 	stw	r3,8(r6)
 9082708:	183fed0e 	bge	r3,zero,90826c0 <_putc_r+0x34>
 908270c:	30800617 	ldw	r2,24(r6)
 9082710:	18800e16 	blt	r3,r2,908274c <_putc_r+0xc0>
 9082714:	30800017 	ldw	r2,0(r6)
 9082718:	14400005 	stb	r17,0(r2)
 908271c:	31000017 	ldw	r4,0(r6)
 9082720:	00800284 	movi	r2,10
 9082724:	20c00003 	ldbu	r3,0(r4)
 9082728:	18800f26 	beq	r3,r2,9082768 <_putc_r+0xdc>
 908272c:	20800044 	addi	r2,r4,1
 9082730:	30800015 	stw	r2,0(r6)
 9082734:	1805883a 	mov	r2,r3
 9082738:	dfc00317 	ldw	ra,12(sp)
 908273c:	dc400217 	ldw	r17,8(sp)
 9082740:	dc000117 	ldw	r16,4(sp)
 9082744:	dec00404 	addi	sp,sp,16
 9082748:	f800283a 	ret
 908274c:	8009883a 	mov	r4,r16
 9082750:	880b883a 	mov	r5,r17
 9082754:	dfc00317 	ldw	ra,12(sp)
 9082758:	dc400217 	ldw	r17,8(sp)
 908275c:	dc000117 	ldw	r16,4(sp)
 9082760:	dec00404 	addi	sp,sp,16
 9082764:	90850781 	jmpi	9085078 <__swbuf_r>
 9082768:	8009883a 	mov	r4,r16
 908276c:	180b883a 	mov	r5,r3
 9082770:	003ff806 	br	9082754 <_putc_r+0xc8>

09082774 <putchar>:
 9082774:	00824374 	movhi	r2,2317
 9082778:	108b9b04 	addi	r2,r2,11884
 908277c:	11800017 	ldw	r6,0(r2)
 9082780:	200b883a 	mov	r5,r4
 9082784:	3009883a 	mov	r4,r6
 9082788:	31800217 	ldw	r6,8(r6)
 908278c:	908268c1 	jmpi	908268c <_putc_r>

09082790 <_putchar_r>:
 9082790:	21800217 	ldw	r6,8(r4)
 9082794:	908268c1 	jmpi	908268c <_putc_r>

09082798 <_puts_r>:
 9082798:	defff604 	addi	sp,sp,-40
 908279c:	dc400715 	stw	r17,28(sp)
 90827a0:	2023883a 	mov	r17,r4
 90827a4:	2809883a 	mov	r4,r5
 90827a8:	dfc00915 	stw	ra,36(sp)
 90827ac:	dcc00815 	stw	r19,32(sp)
 90827b0:	2827883a 	mov	r19,r5
 90827b4:	90830d40 	call	90830d4 <strlen>
 90827b8:	89400217 	ldw	r5,8(r17)
 90827bc:	00c24374 	movhi	r3,2317
 90827c0:	18f07f04 	addi	r3,r3,-15876
 90827c4:	01c00044 	movi	r7,1
 90827c8:	12000044 	addi	r8,r2,1
 90827cc:	d8c00515 	stw	r3,20(sp)
 90827d0:	d9c00615 	stw	r7,24(sp)
 90827d4:	d8c00304 	addi	r3,sp,12
 90827d8:	01c00084 	movi	r7,2
 90827dc:	8809883a 	mov	r4,r17
 90827e0:	d80d883a 	mov	r6,sp
 90827e4:	d8c00015 	stw	r3,0(sp)
 90827e8:	dcc00315 	stw	r19,12(sp)
 90827ec:	da000215 	stw	r8,8(sp)
 90827f0:	d9c00115 	stw	r7,4(sp)
 90827f4:	d8800415 	stw	r2,16(sp)
 90827f8:	90875480 	call	9087548 <__sfvwrite_r>
 90827fc:	00ffffc4 	movi	r3,-1
 9082800:	10000626 	beq	r2,zero,908281c <_puts_r+0x84>
 9082804:	1805883a 	mov	r2,r3
 9082808:	dfc00917 	ldw	ra,36(sp)
 908280c:	dcc00817 	ldw	r19,32(sp)
 9082810:	dc400717 	ldw	r17,28(sp)
 9082814:	dec00a04 	addi	sp,sp,40
 9082818:	f800283a 	ret
 908281c:	00c00284 	movi	r3,10
 9082820:	1805883a 	mov	r2,r3
 9082824:	dfc00917 	ldw	ra,36(sp)
 9082828:	dcc00817 	ldw	r19,32(sp)
 908282c:	dc400717 	ldw	r17,28(sp)
 9082830:	dec00a04 	addi	sp,sp,40
 9082834:	f800283a 	ret

09082838 <puts>:
 9082838:	00824374 	movhi	r2,2317
 908283c:	108b9b04 	addi	r2,r2,11884
 9082840:	200b883a 	mov	r5,r4
 9082844:	11000017 	ldw	r4,0(r2)
 9082848:	90827981 	jmpi	9082798 <_puts_r>

0908284c <__srget_r>:
 908284c:	defffe04 	addi	sp,sp,-8
 9082850:	dc000015 	stw	r16,0(sp)
 9082854:	dfc00115 	stw	ra,4(sp)
 9082858:	2821883a 	mov	r16,r5
 908285c:	9089bc80 	call	9089bc8 <__srefill_r>
 9082860:	013fffc4 	movi	r4,-1
 9082864:	1000071e 	bne	r2,zero,9082884 <__srget_r+0x38>
 9082868:	80800117 	ldw	r2,4(r16)
 908286c:	81000017 	ldw	r4,0(r16)
 9082870:	10bfffc4 	addi	r2,r2,-1
 9082874:	20c00044 	addi	r3,r4,1
 9082878:	80800115 	stw	r2,4(r16)
 908287c:	21000003 	ldbu	r4,0(r4)
 9082880:	80c00015 	stw	r3,0(r16)
 9082884:	2005883a 	mov	r2,r4
 9082888:	dfc00117 	ldw	ra,4(sp)
 908288c:	dc000017 	ldw	r16,0(sp)
 9082890:	dec00204 	addi	sp,sp,8
 9082894:	f800283a 	ret

09082898 <__srget>:
 9082898:	00824374 	movhi	r2,2317
 908289c:	108b9b04 	addi	r2,r2,11884
 90828a0:	200b883a 	mov	r5,r4
 90828a4:	11000017 	ldw	r4,0(r2)
 90828a8:	908284c1 	jmpi	908284c <__srget_r>

090828ac <sprintf>:
 90828ac:	deffe504 	addi	sp,sp,-108
 90828b0:	2013883a 	mov	r9,r4
 90828b4:	dfc01815 	stw	ra,96(sp)
 90828b8:	d9801915 	stw	r6,100(sp)
 90828bc:	d9c01a15 	stw	r7,104(sp)
 90828c0:	d8801904 	addi	r2,sp,100
 90828c4:	d8800015 	stw	r2,0(sp)
 90828c8:	00824374 	movhi	r2,2317
 90828cc:	108b9b04 	addi	r2,r2,11884
 90828d0:	11000017 	ldw	r4,0(r2)
 90828d4:	d9c00017 	ldw	r7,0(sp)
 90828d8:	00808204 	movi	r2,520
 90828dc:	00e00034 	movhi	r3,32768
 90828e0:	18ffffc4 	addi	r3,r3,-1
 90828e4:	280d883a 	mov	r6,r5
 90828e8:	d880040d 	sth	r2,16(sp)
 90828ec:	d9400104 	addi	r5,sp,4
 90828f0:	00bfffc4 	movi	r2,-1
 90828f4:	d8c00615 	stw	r3,24(sp)
 90828f8:	d8c00315 	stw	r3,12(sp)
 90828fc:	da400515 	stw	r9,20(sp)
 9082900:	d880048d 	sth	r2,18(sp)
 9082904:	da400115 	stw	r9,4(sp)
 9082908:	90831a80 	call	90831a8 <___vfprintf_internal_r>
 908290c:	d8c00117 	ldw	r3,4(sp)
 9082910:	18000005 	stb	zero,0(r3)
 9082914:	dfc01817 	ldw	ra,96(sp)
 9082918:	dec01b04 	addi	sp,sp,108
 908291c:	f800283a 	ret

09082920 <_sprintf_r>:
 9082920:	deffe604 	addi	sp,sp,-104
 9082924:	2813883a 	mov	r9,r5
 9082928:	dfc01815 	stw	ra,96(sp)
 908292c:	d9c01915 	stw	r7,100(sp)
 9082930:	d8801904 	addi	r2,sp,100
 9082934:	d8800015 	stw	r2,0(sp)
 9082938:	100f883a 	mov	r7,r2
 908293c:	00808204 	movi	r2,520
 9082940:	00e00034 	movhi	r3,32768
 9082944:	18ffffc4 	addi	r3,r3,-1
 9082948:	d880040d 	sth	r2,16(sp)
 908294c:	d9400104 	addi	r5,sp,4
 9082950:	00bfffc4 	movi	r2,-1
 9082954:	d8c00615 	stw	r3,24(sp)
 9082958:	d8c00315 	stw	r3,12(sp)
 908295c:	da400515 	stw	r9,20(sp)
 9082960:	d880048d 	sth	r2,18(sp)
 9082964:	da400115 	stw	r9,4(sp)
 9082968:	90831a80 	call	90831a8 <___vfprintf_internal_r>
 908296c:	d8c00117 	ldw	r3,4(sp)
 9082970:	18000005 	stb	zero,0(r3)
 9082974:	dfc01817 	ldw	ra,96(sp)
 9082978:	dec01a04 	addi	sp,sp,104
 908297c:	f800283a 	ret

09082980 <strchr>:
 9082980:	208000cc 	andi	r2,r4,3
 9082984:	2007883a 	mov	r3,r4
 9082988:	1000311e 	bne	r2,zero,9082a50 <strchr+0xd0>
 908298c:	29c03fcc 	andi	r7,r5,255
 9082990:	0015883a 	mov	r10,zero
 9082994:	0007883a 	mov	r3,zero
 9082998:	01400104 	movi	r5,4
 908299c:	5004923a 	slli	r2,r10,8
 90829a0:	18c00044 	addi	r3,r3,1
 90829a4:	3894b03a 	or	r10,r7,r2
 90829a8:	197ffc1e 	bne	r3,r5,908299c <strchr+0x1c>
 90829ac:	200d883a 	mov	r6,r4
 90829b0:	21000017 	ldw	r4,0(r4)
 90829b4:	017fbff4 	movhi	r5,65279
 90829b8:	297fbfc4 	addi	r5,r5,-257
 90829bc:	02202074 	movhi	r8,32897
 90829c0:	42202004 	addi	r8,r8,-32640
 90829c4:	2145883a 	add	r2,r4,r5
 90829c8:	1204703a 	and	r2,r2,r8
 90829cc:	0106303a 	nor	r3,zero,r4
 90829d0:	10c4703a 	and	r2,r2,r3
 90829d4:	1000151e 	bne	r2,zero,9082a2c <strchr+0xac>
 90829d8:	2284f03a 	xor	r2,r4,r10
 90829dc:	1147883a 	add	r3,r2,r5
 90829e0:	1a06703a 	and	r3,r3,r8
 90829e4:	0084303a 	nor	r2,zero,r2
 90829e8:	10c4703a 	and	r2,r2,r3
 90829ec:	10000f1e 	bne	r2,zero,9082a2c <strchr+0xac>
 90829f0:	2813883a 	mov	r9,r5
 90829f4:	00000106 	br	90829fc <strchr+0x7c>
 90829f8:	18000c1e 	bne	r3,zero,9082a2c <strchr+0xac>
 90829fc:	31800104 	addi	r6,r6,4
 9082a00:	30800017 	ldw	r2,0(r6)
 9082a04:	1286f03a 	xor	r3,r2,r10
 9082a08:	124b883a 	add	r5,r2,r9
 9082a0c:	1a49883a 	add	r4,r3,r9
 9082a10:	2a0a703a 	and	r5,r5,r8
 9082a14:	0084303a 	nor	r2,zero,r2
 9082a18:	2208703a 	and	r4,r4,r8
 9082a1c:	00c6303a 	nor	r3,zero,r3
 9082a20:	1144703a 	and	r2,r2,r5
 9082a24:	1906703a 	and	r3,r3,r4
 9082a28:	103ff326 	beq	r2,zero,90829f8 <strchr+0x78>
 9082a2c:	3007883a 	mov	r3,r6
 9082a30:	00000206 	br	9082a3c <strchr+0xbc>
 9082a34:	38800426 	beq	r7,r2,9082a48 <strchr+0xc8>
 9082a38:	18c00044 	addi	r3,r3,1
 9082a3c:	18800003 	ldbu	r2,0(r3)
 9082a40:	103ffc1e 	bne	r2,zero,9082a34 <strchr+0xb4>
 9082a44:	3800041e 	bne	r7,zero,9082a58 <strchr+0xd8>
 9082a48:	1805883a 	mov	r2,r3
 9082a4c:	f800283a 	ret
 9082a50:	29c03fcc 	andi	r7,r5,255
 9082a54:	003ff906 	br	9082a3c <strchr+0xbc>
 9082a58:	0005883a 	mov	r2,zero
 9082a5c:	f800283a 	ret

09082a60 <strerror>:
 9082a60:	deffff04 	addi	sp,sp,-4
 9082a64:	00802184 	movi	r2,134
 9082a68:	dfc00015 	stw	ra,0(sp)
 9082a6c:	200b883a 	mov	r5,r4
 9082a70:	11008e36 	bltu	r2,r4,9082cac <strerror+0x24c>
 9082a74:	2105883a 	add	r2,r4,r4
 9082a78:	1085883a 	add	r2,r2,r2
 9082a7c:	00c24234 	movhi	r3,2312
 9082a80:	18caa404 	addi	r3,r3,10896
 9082a84:	10c5883a 	add	r2,r2,r3
 9082a88:	11000017 	ldw	r4,0(r2)
 9082a8c:	2000683a 	jmp	r4
 9082a90:	09082cac 	andhi	r4,at,8370
 9082a94:	09082ce4 	muli	r4,at,8371
 9082a98:	09082cf0 	cmpltui	r4,at,8371
 9082a9c:	09082cfc 	xorhi	r4,at,8371
 9082aa0:	09082d08 	cmpgei	r4,at,8372
 9082aa4:	09082d14 	ori	r4,at,8372
 9082aa8:	09082d20 	cmpeqi	r4,at,8372
 9082aac:	09082d2c 	andhi	r4,at,8372
 9082ab0:	09082d38 	rdprs	r4,at,8372
 9082ab4:	09082d44 	addi	r4,at,8373
 9082ab8:	09082d50 	cmplti	r4,at,8373
 9082abc:	09082d5c 	xori	r4,at,8373
 9082ac0:	09082d68 	cmpgeui	r4,at,8373
 9082ac4:	09082d74 	orhi	r4,at,8373
 9082ac8:	09082d80 	call	9082d8 <OSCtxSw_SWITCH_PC+0x908298>
 9082acc:	09082d8c 	andi	r4,at,8374
 9082ad0:	09082d98 	cmpnei	r4,at,8374
 9082ad4:	09082da4 	muli	r4,at,8374
 9082ad8:	09082db0 	cmpltui	r4,at,8374
 9082adc:	09082dbc 	xorhi	r4,at,8374
 9082ae0:	09082dc8 	cmpgei	r4,at,8375
 9082ae4:	09082dd4 	ori	r4,at,8375
 9082ae8:	09082de0 	cmpeqi	r4,at,8375
 9082aec:	09082dec 	andhi	r4,at,8375
 9082af0:	09082df8 	rdprs	r4,at,8375
 9082af4:	09082e04 	addi	r4,at,8376
 9082af8:	09082e10 	cmplti	r4,at,8376
 9082afc:	09082e1c 	xori	r4,at,8376
 9082b00:	09082e28 	cmpgeui	r4,at,8376
 9082b04:	09082e34 	orhi	r4,at,8376
 9082b08:	09082e40 	call	9082e4 <OSCtxSw_SWITCH_PC+0x9082a4>
 9082b0c:	09082e4c 	andi	r4,at,8377
 9082b10:	09082e58 	cmpnei	r4,at,8377
 9082b14:	09082e64 	muli	r4,at,8377
 9082b18:	09082e70 	cmpltui	r4,at,8377
 9082b1c:	09082e7c 	xorhi	r4,at,8377
 9082b20:	09082e88 	cmpgei	r4,at,8378
 9082b24:	09082cac 	andhi	r4,at,8370
 9082b28:	09082cac 	andhi	r4,at,8370
 9082b2c:	09082cac 	andhi	r4,at,8370
 9082b30:	09082cac 	andhi	r4,at,8370
 9082b34:	09082cac 	andhi	r4,at,8370
 9082b38:	09082cac 	andhi	r4,at,8370
 9082b3c:	09082cac 	andhi	r4,at,8370
 9082b40:	09082cac 	andhi	r4,at,8370
 9082b44:	09082e94 	ori	r4,at,8378
 9082b48:	09082ea0 	cmpeqi	r4,at,8378
 9082b4c:	09082cac 	andhi	r4,at,8370
 9082b50:	09082cac 	andhi	r4,at,8370
 9082b54:	09082cac 	andhi	r4,at,8370
 9082b58:	09082cac 	andhi	r4,at,8370
 9082b5c:	09082cac 	andhi	r4,at,8370
 9082b60:	09082cac 	andhi	r4,at,8370
 9082b64:	09082cac 	andhi	r4,at,8370
 9082b68:	09082cac 	andhi	r4,at,8370
 9082b6c:	09082cac 	andhi	r4,at,8370
 9082b70:	09082cac 	andhi	r4,at,8370
 9082b74:	09082cac 	andhi	r4,at,8370
 9082b78:	09082cac 	andhi	r4,at,8370
 9082b7c:	09082cac 	andhi	r4,at,8370
 9082b80:	09082eac 	andhi	r4,at,8378
 9082b84:	09082cac 	andhi	r4,at,8370
 9082b88:	09082eb8 	rdprs	r4,at,8378
 9082b8c:	09082ec4 	addi	r4,at,8379
 9082b90:	09082ed0 	cmplti	r4,at,8379
 9082b94:	09082edc 	xori	r4,at,8379
 9082b98:	09082ee8 	cmpgeui	r4,at,8379
 9082b9c:	09082ef4 	orhi	r4,at,8379
 9082ba0:	09082f00 	call	9082f0 <OSCtxSw_SWITCH_PC+0x9082b0>
 9082ba4:	09082f0c 	andi	r4,at,8380
 9082ba8:	09082f18 	cmpnei	r4,at,8380
 9082bac:	09082f24 	muli	r4,at,8380
 9082bb0:	09082cac 	andhi	r4,at,8370
 9082bb4:	09082cac 	andhi	r4,at,8370
 9082bb8:	09082f30 	cmpltui	r4,at,8380
 9082bbc:	09082cac 	andhi	r4,at,8370
 9082bc0:	09082cac 	andhi	r4,at,8370
 9082bc4:	09082f3c 	xorhi	r4,at,8380
 9082bc8:	09082cac 	andhi	r4,at,8370
 9082bcc:	09082cac 	andhi	r4,at,8370
 9082bd0:	09082cac 	andhi	r4,at,8370
 9082bd4:	09082cac 	andhi	r4,at,8370
 9082bd8:	09082cac 	andhi	r4,at,8370
 9082bdc:	09082f48 	cmpgei	r4,at,8381
 9082be0:	09082f54 	ori	r4,at,8381
 9082be4:	09082f60 	cmpeqi	r4,at,8381
 9082be8:	09082f6c 	andhi	r4,at,8381
 9082bec:	09082f78 	rdprs	r4,at,8381
 9082bf0:	09082f84 	addi	r4,at,8382
 9082bf4:	09082f90 	cmplti	r4,at,8382
 9082bf8:	09082f9c 	xori	r4,at,8382
 9082bfc:	09082fa8 	cmpgeui	r4,at,8382
 9082c00:	09082fb4 	orhi	r4,at,8382
 9082c04:	09082cac 	andhi	r4,at,8370
 9082c08:	09082cac 	andhi	r4,at,8370
 9082c0c:	09082fc0 	call	9082fc <OSCtxSw_SWITCH_PC+0x9082bc>
 9082c10:	09082cac 	andhi	r4,at,8370
 9082c14:	09082cac 	andhi	r4,at,8370
 9082c18:	09082cac 	andhi	r4,at,8370
 9082c1c:	09082cac 	andhi	r4,at,8370
 9082c20:	09082cac 	andhi	r4,at,8370
 9082c24:	09082cac 	andhi	r4,at,8370
 9082c28:	09082cac 	andhi	r4,at,8370
 9082c2c:	09082cac 	andhi	r4,at,8370
 9082c30:	09082cac 	andhi	r4,at,8370
 9082c34:	09082fcc 	andi	r4,at,8383
 9082c38:	09082fd8 	cmpnei	r4,at,8383
 9082c3c:	09082fe4 	muli	r4,at,8383
 9082c40:	09082ff0 	cmpltui	r4,at,8383
 9082c44:	09082ffc 	xorhi	r4,at,8383
 9082c48:	09083008 	cmpgei	r4,at,8384
 9082c4c:	09083014 	ori	r4,at,8384
 9082c50:	09083020 	cmpeqi	r4,at,8384
 9082c54:	0908302c 	andhi	r4,at,8384
 9082c58:	09083038 	rdprs	r4,at,8384
 9082c5c:	09083044 	addi	r4,at,8385
 9082c60:	09083050 	cmplti	r4,at,8385
 9082c64:	0908305c 	xori	r4,at,8385
 9082c68:	09083068 	cmpgeui	r4,at,8385
 9082c6c:	09083074 	orhi	r4,at,8385
 9082c70:	09083080 	call	908308 <OSCtxSw_SWITCH_PC+0x9082c8>
 9082c74:	0908308c 	andi	r4,at,8386
 9082c78:	09083098 	cmpnei	r4,at,8386
 9082c7c:	090830a4 	muli	r4,at,8386
 9082c80:	090830b0 	cmpltui	r4,at,8386
 9082c84:	09082cac 	andhi	r4,at,8370
 9082c88:	09082cac 	andhi	r4,at,8370
 9082c8c:	090830bc 	xorhi	r4,at,8386
 9082c90:	090830c8 	cmpgei	r4,at,8387
 9082c94:	09082cac 	andhi	r4,at,8370
 9082c98:	09082cac 	andhi	r4,at,8370
 9082c9c:	09082cac 	andhi	r4,at,8370
 9082ca0:	09082cac 	andhi	r4,at,8370
 9082ca4:	09082cac 	andhi	r4,at,8370
 9082ca8:	09082cd8 	cmpnei	r4,at,8371
 9082cac:	2809883a 	mov	r4,r5
 9082cb0:	90831480 	call	9083148 <_user_strerror>
 9082cb4:	10000326 	beq	r2,zero,9082cc4 <strerror+0x264>
 9082cb8:	dfc00017 	ldw	ra,0(sp)
 9082cbc:	dec00104 	addi	sp,sp,4
 9082cc0:	f800283a 	ret
 9082cc4:	00824374 	movhi	r2,2317
 9082cc8:	10b27804 	addi	r2,r2,-13856
 9082ccc:	dfc00017 	ldw	ra,0(sp)
 9082cd0:	dec00104 	addi	sp,sp,4
 9082cd4:	f800283a 	ret
 9082cd8:	00824374 	movhi	r2,2317
 9082cdc:	10b13b04 	addi	r2,r2,-15124
 9082ce0:	003ff506 	br	9082cb8 <strerror+0x258>
 9082ce4:	00824374 	movhi	r2,2317
 9082ce8:	10b08b04 	addi	r2,r2,-15828
 9082cec:	003ff206 	br	9082cb8 <strerror+0x258>
 9082cf0:	00824374 	movhi	r2,2317
 9082cf4:	10b08e04 	addi	r2,r2,-15816
 9082cf8:	003fef06 	br	9082cb8 <strerror+0x258>
 9082cfc:	00824374 	movhi	r2,2317
 9082d00:	10b09504 	addi	r2,r2,-15788
 9082d04:	003fec06 	br	9082cb8 <strerror+0x258>
 9082d08:	00824374 	movhi	r2,2317
 9082d0c:	10b09904 	addi	r2,r2,-15772
 9082d10:	003fe906 	br	9082cb8 <strerror+0x258>
 9082d14:	00824374 	movhi	r2,2317
 9082d18:	10b09f04 	addi	r2,r2,-15748
 9082d1c:	003fe606 	br	9082cb8 <strerror+0x258>
 9082d20:	00824374 	movhi	r2,2317
 9082d24:	10b0a204 	addi	r2,r2,-15736
 9082d28:	003fe306 	br	9082cb8 <strerror+0x258>
 9082d2c:	00824374 	movhi	r2,2317
 9082d30:	10b0a904 	addi	r2,r2,-15708
 9082d34:	003fe006 	br	9082cb8 <strerror+0x258>
 9082d38:	00824374 	movhi	r2,2317
 9082d3c:	10b0ae04 	addi	r2,r2,-15688
 9082d40:	003fdd06 	br	9082cb8 <strerror+0x258>
 9082d44:	00824374 	movhi	r2,2317
 9082d48:	10b0ba04 	addi	r2,r2,-15640
 9082d4c:	003fda06 	br	9082cb8 <strerror+0x258>
 9082d50:	00824374 	movhi	r2,2317
 9082d54:	10b0be04 	addi	r2,r2,-15624
 9082d58:	003fd706 	br	9082cb8 <strerror+0x258>
 9082d5c:	00824374 	movhi	r2,2317
 9082d60:	10b0c904 	addi	r2,r2,-15580
 9082d64:	003fd406 	br	9082cb8 <strerror+0x258>
 9082d68:	00824374 	movhi	r2,2317
 9082d6c:	10b0ce04 	addi	r2,r2,-15560
 9082d70:	003fd106 	br	9082cb8 <strerror+0x258>
 9082d74:	00824374 	movhi	r2,2317
 9082d78:	10b0d304 	addi	r2,r2,-15540
 9082d7c:	003fce06 	br	9082cb8 <strerror+0x258>
 9082d80:	00824374 	movhi	r2,2317
 9082d84:	10b0d804 	addi	r2,r2,-15520
 9082d88:	003fcb06 	br	9082cb8 <strerror+0x258>
 9082d8c:	00824374 	movhi	r2,2317
 9082d90:	10b0db04 	addi	r2,r2,-15508
 9082d94:	003fc806 	br	9082cb8 <strerror+0x258>
 9082d98:	00824374 	movhi	r2,2317
 9082d9c:	10b0e104 	addi	r2,r2,-15484
 9082da0:	003fc506 	br	9082cb8 <strerror+0x258>
 9082da4:	00824374 	movhi	r2,2317
 9082da8:	10b0e704 	addi	r2,r2,-15460
 9082dac:	003fc206 	br	9082cb8 <strerror+0x258>
 9082db0:	00824374 	movhi	r2,2317
 9082db4:	10b0ea04 	addi	r2,r2,-15448
 9082db8:	003fbf06 	br	9082cb8 <strerror+0x258>
 9082dbc:	00824374 	movhi	r2,2317
 9082dc0:	10b0ef04 	addi	r2,r2,-15428
 9082dc4:	003fbc06 	br	9082cb8 <strerror+0x258>
 9082dc8:	00824374 	movhi	r2,2317
 9082dcc:	10b0f304 	addi	r2,r2,-15412
 9082dd0:	003fb906 	br	9082cb8 <strerror+0x258>
 9082dd4:	00824374 	movhi	r2,2317
 9082dd8:	10b10304 	addi	r2,r2,-15348
 9082ddc:	003fb606 	br	9082cb8 <strerror+0x258>
 9082de0:	00824374 	movhi	r2,2317
 9082de4:	10b10704 	addi	r2,r2,-15332
 9082de8:	003fb306 	br	9082cb8 <strerror+0x258>
 9082dec:	00824374 	movhi	r2,2317
 9082df0:	10b11504 	addi	r2,r2,-15276
 9082df4:	003fb006 	br	9082cb8 <strerror+0x258>
 9082df8:	00824374 	movhi	r2,2317
 9082dfc:	10b11d04 	addi	r2,r2,-15244
 9082e00:	003fad06 	br	9082cb8 <strerror+0x258>
 9082e04:	00824374 	movhi	r2,2317
 9082e08:	10b12204 	addi	r2,r2,-15224
 9082e0c:	003faa06 	br	9082cb8 <strerror+0x258>
 9082e10:	00824374 	movhi	r2,2317
 9082e14:	10b12804 	addi	r2,r2,-15200
 9082e18:	003fa706 	br	9082cb8 <strerror+0x258>
 9082e1c:	00824374 	movhi	r2,2317
 9082e20:	10b12c04 	addi	r2,r2,-15184
 9082e24:	003fa406 	br	9082cb8 <strerror+0x258>
 9082e28:	00824374 	movhi	r2,2317
 9082e2c:	10b13504 	addi	r2,r2,-15148
 9082e30:	003fa106 	br	9082cb8 <strerror+0x258>
 9082e34:	00824374 	movhi	r2,2317
 9082e38:	10b13f04 	addi	r2,r2,-15108
 9082e3c:	003f9e06 	br	9082cb8 <strerror+0x258>
 9082e40:	00824374 	movhi	r2,2317
 9082e44:	10b14304 	addi	r2,r2,-15092
 9082e48:	003f9b06 	br	9082cb8 <strerror+0x258>
 9082e4c:	00824374 	movhi	r2,2317
 9082e50:	10b14904 	addi	r2,r2,-15068
 9082e54:	003f9806 	br	9082cb8 <strerror+0x258>
 9082e58:	00824374 	movhi	r2,2317
 9082e5c:	10b14d04 	addi	r2,r2,-15052
 9082e60:	003f9506 	br	9082cb8 <strerror+0x258>
 9082e64:	00824374 	movhi	r2,2317
 9082e68:	10b15004 	addi	r2,r2,-15040
 9082e6c:	003f9206 	br	9082cb8 <strerror+0x258>
 9082e70:	00824374 	movhi	r2,2317
 9082e74:	10b15404 	addi	r2,r2,-15024
 9082e78:	003f8f06 	br	9082cb8 <strerror+0x258>
 9082e7c:	00824374 	movhi	r2,2317
 9082e80:	10b15904 	addi	r2,r2,-15004
 9082e84:	003f8c06 	br	9082cb8 <strerror+0x258>
 9082e88:	00824374 	movhi	r2,2317
 9082e8c:	10b16004 	addi	r2,r2,-14976
 9082e90:	003f8906 	br	9082cb8 <strerror+0x258>
 9082e94:	00824374 	movhi	r2,2317
 9082e98:	10b16504 	addi	r2,r2,-14956
 9082e9c:	003f8606 	br	9082cb8 <strerror+0x258>
 9082ea0:	00824374 	movhi	r2,2317
 9082ea4:	10b16e04 	addi	r2,r2,-14920
 9082ea8:	003f8306 	br	9082cb8 <strerror+0x258>
 9082eac:	00824374 	movhi	r2,2317
 9082eb0:	10b17004 	addi	r2,r2,-14912
 9082eb4:	003f8006 	br	9082cb8 <strerror+0x258>
 9082eb8:	00824374 	movhi	r2,2317
 9082ebc:	10b17404 	addi	r2,r2,-14896
 9082ec0:	003f7d06 	br	9082cb8 <strerror+0x258>
 9082ec4:	00824374 	movhi	r2,2317
 9082ec8:	10b17a04 	addi	r2,r2,-14872
 9082ecc:	003f7a06 	br	9082cb8 <strerror+0x258>
 9082ed0:	00824374 	movhi	r2,2317
 9082ed4:	10b17f04 	addi	r2,r2,-14852
 9082ed8:	003f7706 	br	9082cb8 <strerror+0x258>
 9082edc:	00824374 	movhi	r2,2317
 9082ee0:	10b18704 	addi	r2,r2,-14820
 9082ee4:	003f7406 	br	9082cb8 <strerror+0x258>
 9082ee8:	00824374 	movhi	r2,2317
 9082eec:	10b18a04 	addi	r2,r2,-14808
 9082ef0:	003f7106 	br	9082cb8 <strerror+0x258>
 9082ef4:	00824374 	movhi	r2,2317
 9082ef8:	10b18f04 	addi	r2,r2,-14788
 9082efc:	003f6e06 	br	9082cb8 <strerror+0x258>
 9082f00:	00824374 	movhi	r2,2317
 9082f04:	10b19504 	addi	r2,r2,-14764
 9082f08:	003f6b06 	br	9082cb8 <strerror+0x258>
 9082f0c:	00824374 	movhi	r2,2317
 9082f10:	10b19904 	addi	r2,r2,-14748
 9082f14:	003f6806 	br	9082cb8 <strerror+0x258>
 9082f18:	00824374 	movhi	r2,2317
 9082f1c:	10b19d04 	addi	r2,r2,-14732
 9082f20:	003f6506 	br	9082cb8 <strerror+0x258>
 9082f24:	00824374 	movhi	r2,2317
 9082f28:	10b1a204 	addi	r2,r2,-14712
 9082f2c:	003f6206 	br	9082cb8 <strerror+0x258>
 9082f30:	00824374 	movhi	r2,2317
 9082f34:	10b1ab04 	addi	r2,r2,-14676
 9082f38:	003f5f06 	br	9082cb8 <strerror+0x258>
 9082f3c:	00824374 	movhi	r2,2317
 9082f40:	10b1b004 	addi	r2,r2,-14656
 9082f44:	003f5c06 	br	9082cb8 <strerror+0x258>
 9082f48:	00824374 	movhi	r2,2317
 9082f4c:	10b1b304 	addi	r2,r2,-14644
 9082f50:	003f5906 	br	9082cb8 <strerror+0x258>
 9082f54:	00824374 	movhi	r2,2317
 9082f58:	10b1bd04 	addi	r2,r2,-14604
 9082f5c:	003f5606 	br	9082cb8 <strerror+0x258>
 9082f60:	00824374 	movhi	r2,2317
 9082f64:	10b1c704 	addi	r2,r2,-14564
 9082f68:	003f5306 	br	9082cb8 <strerror+0x258>
 9082f6c:	00824374 	movhi	r2,2317
 9082f70:	10b1cf04 	addi	r2,r2,-14532
 9082f74:	003f5006 	br	9082cb8 <strerror+0x258>
 9082f78:	00824374 	movhi	r2,2317
 9082f7c:	10b1df04 	addi	r2,r2,-14468
 9082f80:	003f4d06 	br	9082cb8 <strerror+0x258>
 9082f84:	00824374 	movhi	r2,2317
 9082f88:	10b1e904 	addi	r2,r2,-14428
 9082f8c:	003f4a06 	br	9082cb8 <strerror+0x258>
 9082f90:	00824374 	movhi	r2,2317
 9082f94:	10b1f004 	addi	r2,r2,-14400
 9082f98:	003f4706 	br	9082cb8 <strerror+0x258>
 9082f9c:	00824374 	movhi	r2,2317
 9082fa0:	10b1f404 	addi	r2,r2,-14384
 9082fa4:	003f4406 	br	9082cb8 <strerror+0x258>
 9082fa8:	00824374 	movhi	r2,2317
 9082fac:	10b1f904 	addi	r2,r2,-14364
 9082fb0:	003f4106 	br	9082cb8 <strerror+0x258>
 9082fb4:	00824374 	movhi	r2,2317
 9082fb8:	10b20004 	addi	r2,r2,-14336
 9082fbc:	003f3e06 	br	9082cb8 <strerror+0x258>
 9082fc0:	00824374 	movhi	r2,2317
 9082fc4:	10b26004 	addi	r2,r2,-13952
 9082fc8:	003f3b06 	br	9082cb8 <strerror+0x258>
 9082fcc:	00824374 	movhi	r2,2317
 9082fd0:	10b20604 	addi	r2,r2,-14312
 9082fd4:	003f3806 	br	9082cb8 <strerror+0x258>
 9082fd8:	00824374 	movhi	r2,2317
 9082fdc:	10b20d04 	addi	r2,r2,-14284
 9082fe0:	003f3506 	br	9082cb8 <strerror+0x258>
 9082fe4:	00824374 	movhi	r2,2317
 9082fe8:	10b21904 	addi	r2,r2,-14236
 9082fec:	003f3206 	br	9082cb8 <strerror+0x258>
 9082ff0:	00824374 	movhi	r2,2317
 9082ff4:	10b22104 	addi	r2,r2,-14204
 9082ff8:	003f2f06 	br	9082cb8 <strerror+0x258>
 9082ffc:	00824374 	movhi	r2,2317
 9083000:	10b22904 	addi	r2,r2,-14172
 9083004:	003f2c06 	br	9082cb8 <strerror+0x258>
 9083008:	00824374 	movhi	r2,2317
 908300c:	10b22f04 	addi	r2,r2,-14148
 9083010:	003f2906 	br	9082cb8 <strerror+0x258>
 9083014:	00824374 	movhi	r2,2317
 9083018:	10b23804 	addi	r2,r2,-14112
 908301c:	003f2606 	br	9082cb8 <strerror+0x258>
 9083020:	00824374 	movhi	r2,2317
 9083024:	10b23d04 	addi	r2,r2,-14092
 9083028:	003f2306 	br	9082cb8 <strerror+0x258>
 908302c:	00824374 	movhi	r2,2317
 9083030:	10b24304 	addi	r2,r2,-14068
 9083034:	003f2006 	br	9082cb8 <strerror+0x258>
 9083038:	00824374 	movhi	r2,2317
 908303c:	10b16804 	addi	r2,r2,-14944
 9083040:	003f1d06 	br	9082cb8 <strerror+0x258>
 9083044:	00824374 	movhi	r2,2317
 9083048:	10b10c04 	addi	r2,r2,-15312
 908304c:	003f1a06 	br	9082cb8 <strerror+0x258>
 9083050:	00824374 	movhi	r2,2317
 9083054:	10b08504 	addi	r2,r2,-15852
 9083058:	003f1706 	br	9082cb8 <strerror+0x258>
 908305c:	00824374 	movhi	r2,2317
 9083060:	10b0f704 	addi	r2,r2,-15396
 9083064:	003f1406 	br	9082cb8 <strerror+0x258>
 9083068:	00824374 	movhi	r2,2317
 908306c:	10b13004 	addi	r2,r2,-15168
 9083070:	003f1106 	br	9082cb8 <strerror+0x258>
 9083074:	00824374 	movhi	r2,2317
 9083078:	10b0fb04 	addi	r2,r2,-15380
 908307c:	003f0e06 	br	9082cb8 <strerror+0x258>
 9083080:	00824374 	movhi	r2,2317
 9083084:	10b0b304 	addi	r2,r2,-15668
 9083088:	003f0b06 	br	9082cb8 <strerror+0x258>
 908308c:	00824374 	movhi	r2,2317
 9083090:	10b0c104 	addi	r2,r2,-15612
 9083094:	003f0806 	br	9082cb8 <strerror+0x258>
 9083098:	00824374 	movhi	r2,2317
 908309c:	10b08004 	addi	r2,r2,-15872
 90830a0:	003f0506 	br	9082cb8 <strerror+0x258>
 90830a4:	00824374 	movhi	r2,2317
 90830a8:	10b1a604 	addi	r2,r2,-14696
 90830ac:	003f0206 	br	9082cb8 <strerror+0x258>
 90830b0:	00824374 	movhi	r2,2317
 90830b4:	10b25204 	addi	r2,r2,-14008
 90830b8:	003eff06 	br	9082cb8 <strerror+0x258>
 90830bc:	00824374 	movhi	r2,2317
 90830c0:	10b25904 	addi	r2,r2,-13980
 90830c4:	003efc06 	br	9082cb8 <strerror+0x258>
 90830c8:	00824374 	movhi	r2,2317
 90830cc:	10b24c04 	addi	r2,r2,-14032
 90830d0:	003ef906 	br	9082cb8 <strerror+0x258>

090830d4 <strlen>:
 90830d4:	208000cc 	andi	r2,r4,3
 90830d8:	2011883a 	mov	r8,r4
 90830dc:	1000161e 	bne	r2,zero,9083138 <strlen+0x64>
 90830e0:	20c00017 	ldw	r3,0(r4)
 90830e4:	017fbff4 	movhi	r5,65279
 90830e8:	297fbfc4 	addi	r5,r5,-257
 90830ec:	01e02074 	movhi	r7,32897
 90830f0:	39e02004 	addi	r7,r7,-32640
 90830f4:	1945883a 	add	r2,r3,r5
 90830f8:	11c4703a 	and	r2,r2,r7
 90830fc:	00c6303a 	nor	r3,zero,r3
 9083100:	1886703a 	and	r3,r3,r2
 9083104:	18000c1e 	bne	r3,zero,9083138 <strlen+0x64>
 9083108:	280d883a 	mov	r6,r5
 908310c:	380b883a 	mov	r5,r7
 9083110:	21000104 	addi	r4,r4,4
 9083114:	20800017 	ldw	r2,0(r4)
 9083118:	1187883a 	add	r3,r2,r6
 908311c:	1946703a 	and	r3,r3,r5
 9083120:	0084303a 	nor	r2,zero,r2
 9083124:	10c4703a 	and	r2,r2,r3
 9083128:	103ff926 	beq	r2,zero,9083110 <strlen+0x3c>
 908312c:	20800007 	ldb	r2,0(r4)
 9083130:	10000326 	beq	r2,zero,9083140 <strlen+0x6c>
 9083134:	21000044 	addi	r4,r4,1
 9083138:	20800007 	ldb	r2,0(r4)
 908313c:	103ffd1e 	bne	r2,zero,9083134 <strlen+0x60>
 9083140:	2205c83a 	sub	r2,r4,r8
 9083144:	f800283a 	ret

09083148 <_user_strerror>:
 9083148:	0005883a 	mov	r2,zero
 908314c:	f800283a 	ret

09083150 <__sprint_r>:
 9083150:	30800217 	ldw	r2,8(r6)
 9083154:	defffe04 	addi	sp,sp,-8
 9083158:	dc000015 	stw	r16,0(sp)
 908315c:	dfc00115 	stw	ra,4(sp)
 9083160:	3021883a 	mov	r16,r6
 9083164:	0007883a 	mov	r3,zero
 9083168:	1000061e 	bne	r2,zero,9083184 <__sprint_r+0x34>
 908316c:	1805883a 	mov	r2,r3
 9083170:	30000115 	stw	zero,4(r6)
 9083174:	dfc00117 	ldw	ra,4(sp)
 9083178:	dc000017 	ldw	r16,0(sp)
 908317c:	dec00204 	addi	sp,sp,8
 9083180:	f800283a 	ret
 9083184:	90875480 	call	9087548 <__sfvwrite_r>
 9083188:	1007883a 	mov	r3,r2
 908318c:	1805883a 	mov	r2,r3
 9083190:	80000115 	stw	zero,4(r16)
 9083194:	80000215 	stw	zero,8(r16)
 9083198:	dfc00117 	ldw	ra,4(sp)
 908319c:	dc000017 	ldw	r16,0(sp)
 90831a0:	dec00204 	addi	sp,sp,8
 90831a4:	f800283a 	ret

090831a8 <___vfprintf_internal_r>:
 90831a8:	defea404 	addi	sp,sp,-1392
 90831ac:	dd815815 	stw	r22,1376(sp)
 90831b0:	dc015215 	stw	r16,1352(sp)
 90831b4:	d9c15115 	stw	r7,1348(sp)
 90831b8:	dfc15b15 	stw	ra,1388(sp)
 90831bc:	df015a15 	stw	fp,1384(sp)
 90831c0:	ddc15915 	stw	r23,1380(sp)
 90831c4:	dd415715 	stw	r21,1372(sp)
 90831c8:	dd015615 	stw	r20,1368(sp)
 90831cc:	dcc15515 	stw	r19,1364(sp)
 90831d0:	dc815415 	stw	r18,1360(sp)
 90831d4:	dc415315 	stw	r17,1356(sp)
 90831d8:	282d883a 	mov	r22,r5
 90831dc:	3021883a 	mov	r16,r6
 90831e0:	d9014f15 	stw	r4,1340(sp)
 90831e4:	9087b6c0 	call	9087b6c <_localeconv_r>
 90831e8:	10800017 	ldw	r2,0(r2)
 90831ec:	d9c15117 	ldw	r7,1348(sp)
 90831f0:	d8814915 	stw	r2,1316(sp)
 90831f4:	d8814f17 	ldw	r2,1340(sp)
 90831f8:	10000226 	beq	r2,zero,9083204 <___vfprintf_internal_r+0x5c>
 90831fc:	10800e17 	ldw	r2,56(r2)
 9083200:	10020d26 	beq	r2,zero,9083a38 <___vfprintf_internal_r+0x890>
 9083204:	b080030b 	ldhu	r2,12(r22)
 9083208:	1080020c 	andi	r2,r2,8
 908320c:	10020e26 	beq	r2,zero,9083a48 <___vfprintf_internal_r+0x8a0>
 9083210:	b0800417 	ldw	r2,16(r22)
 9083214:	10020c26 	beq	r2,zero,9083a48 <___vfprintf_internal_r+0x8a0>
 9083218:	b200030b 	ldhu	r8,12(r22)
 908321c:	00800284 	movi	r2,10
 9083220:	40c0068c 	andi	r3,r8,26
 9083224:	18802f1e 	bne	r3,r2,90832e4 <___vfprintf_internal_r+0x13c>
 9083228:	b080038f 	ldh	r2,14(r22)
 908322c:	10002d16 	blt	r2,zero,90832e4 <___vfprintf_internal_r+0x13c>
 9083230:	b240038b 	ldhu	r9,14(r22)
 9083234:	b2800717 	ldw	r10,28(r22)
 9083238:	b2c00917 	ldw	r11,36(r22)
 908323c:	d9014f17 	ldw	r4,1340(sp)
 9083240:	dc402904 	addi	r17,sp,164
 9083244:	d8804004 	addi	r2,sp,256
 9083248:	00c10004 	movi	r3,1024
 908324c:	423fff4c 	andi	r8,r8,65533
 9083250:	800d883a 	mov	r6,r16
 9083254:	880b883a 	mov	r5,r17
 9083258:	da002c0d 	sth	r8,176(sp)
 908325c:	da402c8d 	sth	r9,178(sp)
 9083260:	da803015 	stw	r10,192(sp)
 9083264:	dac03215 	stw	r11,200(sp)
 9083268:	d8802d15 	stw	r2,180(sp)
 908326c:	d8c02e15 	stw	r3,184(sp)
 9083270:	d8802915 	stw	r2,164(sp)
 9083274:	d8c02b15 	stw	r3,172(sp)
 9083278:	d8002f15 	stw	zero,188(sp)
 908327c:	90831a80 	call	90831a8 <___vfprintf_internal_r>
 9083280:	d8814b15 	stw	r2,1324(sp)
 9083284:	10000416 	blt	r2,zero,9083298 <___vfprintf_internal_r+0xf0>
 9083288:	d9014f17 	ldw	r4,1340(sp)
 908328c:	880b883a 	mov	r5,r17
 9083290:	9086acc0 	call	9086acc <_fflush_r>
 9083294:	1002321e 	bne	r2,zero,9083b60 <___vfprintf_internal_r+0x9b8>
 9083298:	d8802c0b 	ldhu	r2,176(sp)
 908329c:	1080100c 	andi	r2,r2,64
 90832a0:	10000326 	beq	r2,zero,90832b0 <___vfprintf_internal_r+0x108>
 90832a4:	b080030b 	ldhu	r2,12(r22)
 90832a8:	10801014 	ori	r2,r2,64
 90832ac:	b080030d 	sth	r2,12(r22)
 90832b0:	d8814b17 	ldw	r2,1324(sp)
 90832b4:	dfc15b17 	ldw	ra,1388(sp)
 90832b8:	df015a17 	ldw	fp,1384(sp)
 90832bc:	ddc15917 	ldw	r23,1380(sp)
 90832c0:	dd815817 	ldw	r22,1376(sp)
 90832c4:	dd415717 	ldw	r21,1372(sp)
 90832c8:	dd015617 	ldw	r20,1368(sp)
 90832cc:	dcc15517 	ldw	r19,1364(sp)
 90832d0:	dc815417 	ldw	r18,1360(sp)
 90832d4:	dc415317 	ldw	r17,1356(sp)
 90832d8:	dc015217 	ldw	r16,1352(sp)
 90832dc:	dec15c04 	addi	sp,sp,1392
 90832e0:	f800283a 	ret
 90832e4:	0005883a 	mov	r2,zero
 90832e8:	0007883a 	mov	r3,zero
 90832ec:	dd401904 	addi	r21,sp,100
 90832f0:	d8814215 	stw	r2,1288(sp)
 90832f4:	802f883a 	mov	r23,r16
 90832f8:	d8c14315 	stw	r3,1292(sp)
 90832fc:	d8014b15 	stw	zero,1324(sp)
 9083300:	d8014815 	stw	zero,1312(sp)
 9083304:	d8014415 	stw	zero,1296(sp)
 9083308:	d8014715 	stw	zero,1308(sp)
 908330c:	dd400c15 	stw	r21,48(sp)
 9083310:	d8000e15 	stw	zero,56(sp)
 9083314:	d8000d15 	stw	zero,52(sp)
 9083318:	b8800007 	ldb	r2,0(r23)
 908331c:	10001926 	beq	r2,zero,9083384 <___vfprintf_internal_r+0x1dc>
 9083320:	00c00944 	movi	r3,37
 9083324:	10c01726 	beq	r2,r3,9083384 <___vfprintf_internal_r+0x1dc>
 9083328:	b821883a 	mov	r16,r23
 908332c:	00000106 	br	9083334 <___vfprintf_internal_r+0x18c>
 9083330:	10c00326 	beq	r2,r3,9083340 <___vfprintf_internal_r+0x198>
 9083334:	84000044 	addi	r16,r16,1
 9083338:	80800007 	ldb	r2,0(r16)
 908333c:	103ffc1e 	bne	r2,zero,9083330 <___vfprintf_internal_r+0x188>
 9083340:	85e7c83a 	sub	r19,r16,r23
 9083344:	98000e26 	beq	r19,zero,9083380 <___vfprintf_internal_r+0x1d8>
 9083348:	dc800e17 	ldw	r18,56(sp)
 908334c:	dc400d17 	ldw	r17,52(sp)
 9083350:	008001c4 	movi	r2,7
 9083354:	94e5883a 	add	r18,r18,r19
 9083358:	8c400044 	addi	r17,r17,1
 908335c:	adc00015 	stw	r23,0(r21)
 9083360:	dc800e15 	stw	r18,56(sp)
 9083364:	acc00115 	stw	r19,4(r21)
 9083368:	dc400d15 	stw	r17,52(sp)
 908336c:	14428b16 	blt	r2,r17,9083d9c <___vfprintf_internal_r+0xbf4>
 9083370:	ad400204 	addi	r21,r21,8
 9083374:	d9014b17 	ldw	r4,1324(sp)
 9083378:	24c9883a 	add	r4,r4,r19
 908337c:	d9014b15 	stw	r4,1324(sp)
 9083380:	802f883a 	mov	r23,r16
 9083384:	b8800007 	ldb	r2,0(r23)
 9083388:	10013c26 	beq	r2,zero,908387c <___vfprintf_internal_r+0x6d4>
 908338c:	bdc00044 	addi	r23,r23,1
 9083390:	d8000405 	stb	zero,16(sp)
 9083394:	b8c00007 	ldb	r3,0(r23)
 9083398:	04ffffc4 	movi	r19,-1
 908339c:	d8014c15 	stw	zero,1328(sp)
 90833a0:	d8014a15 	stw	zero,1320(sp)
 90833a4:	d8c14d15 	stw	r3,1332(sp)
 90833a8:	bdc00044 	addi	r23,r23,1
 90833ac:	d9414d17 	ldw	r5,1332(sp)
 90833b0:	00801604 	movi	r2,88
 90833b4:	28fff804 	addi	r3,r5,-32
 90833b8:	10c06036 	bltu	r2,r3,908353c <___vfprintf_internal_r+0x394>
 90833bc:	18c5883a 	add	r2,r3,r3
 90833c0:	1085883a 	add	r2,r2,r2
 90833c4:	00c24234 	movhi	r3,2312
 90833c8:	18ccf604 	addi	r3,r3,13272
 90833cc:	10c5883a 	add	r2,r2,r3
 90833d0:	11000017 	ldw	r4,0(r2)
 90833d4:	2000683a 	jmp	r4
 90833d8:	0908434c 	andi	r4,at,8461
 90833dc:	0908353c 	xorhi	r4,at,8404
 90833e0:	0908353c 	xorhi	r4,at,8404
 90833e4:	09084338 	rdprs	r4,at,8460
 90833e8:	0908353c 	xorhi	r4,at,8404
 90833ec:	0908353c 	xorhi	r4,at,8404
 90833f0:	0908353c 	xorhi	r4,at,8404
 90833f4:	0908353c 	xorhi	r4,at,8404
 90833f8:	0908353c 	xorhi	r4,at,8404
 90833fc:	0908353c 	xorhi	r4,at,8404
 9083400:	09084118 	cmpnei	r4,at,8452
 9083404:	09084328 	cmpgeui	r4,at,8460
 9083408:	0908353c 	xorhi	r4,at,8404
 908340c:	09084130 	cmpltui	r4,at,8452
 9083410:	090843c4 	addi	r4,at,8463
 9083414:	0908353c 	xorhi	r4,at,8404
 9083418:	090843b0 	cmpltui	r4,at,8462
 908341c:	09084378 	rdprs	r4,at,8461
 9083420:	09084378 	rdprs	r4,at,8461
 9083424:	09084378 	rdprs	r4,at,8461
 9083428:	09084378 	rdprs	r4,at,8461
 908342c:	09084378 	rdprs	r4,at,8461
 9083430:	09084378 	rdprs	r4,at,8461
 9083434:	09084378 	rdprs	r4,at,8461
 9083438:	09084378 	rdprs	r4,at,8461
 908343c:	09084378 	rdprs	r4,at,8461
 9083440:	0908353c 	xorhi	r4,at,8404
 9083444:	0908353c 	xorhi	r4,at,8404
 9083448:	0908353c 	xorhi	r4,at,8404
 908344c:	0908353c 	xorhi	r4,at,8404
 9083450:	0908353c 	xorhi	r4,at,8404
 9083454:	0908353c 	xorhi	r4,at,8404
 9083458:	0908353c 	xorhi	r4,at,8404
 908345c:	0908353c 	xorhi	r4,at,8404
 9083460:	0908353c 	xorhi	r4,at,8404
 9083464:	0908353c 	xorhi	r4,at,8404
 9083468:	09083b94 	ori	r4,at,8430
 908346c:	09084200 	call	908420 <OSCtxSw_SWITCH_PC+0x9083e0>
 9083470:	0908353c 	xorhi	r4,at,8404
 9083474:	09084200 	call	908420 <OSCtxSw_SWITCH_PC+0x9083e0>
 9083478:	0908353c 	xorhi	r4,at,8404
 908347c:	0908353c 	xorhi	r4,at,8404
 9083480:	0908353c 	xorhi	r4,at,8404
 9083484:	0908353c 	xorhi	r4,at,8404
 9083488:	09084364 	muli	r4,at,8461
 908348c:	0908353c 	xorhi	r4,at,8404
 9083490:	0908353c 	xorhi	r4,at,8404
 9083494:	09083c48 	cmpgei	r4,at,8433
 9083498:	0908353c 	xorhi	r4,at,8404
 908349c:	0908353c 	xorhi	r4,at,8404
 90834a0:	0908353c 	xorhi	r4,at,8404
 90834a4:	0908353c 	xorhi	r4,at,8404
 90834a8:	0908353c 	xorhi	r4,at,8404
 90834ac:	09083c94 	ori	r4,at,8434
 90834b0:	0908353c 	xorhi	r4,at,8404
 90834b4:	0908353c 	xorhi	r4,at,8404
 90834b8:	090842b4 	orhi	r4,at,8458
 90834bc:	0908353c 	xorhi	r4,at,8404
 90834c0:	0908353c 	xorhi	r4,at,8404
 90834c4:	0908353c 	xorhi	r4,at,8404
 90834c8:	0908353c 	xorhi	r4,at,8404
 90834cc:	0908353c 	xorhi	r4,at,8404
 90834d0:	0908353c 	xorhi	r4,at,8404
 90834d4:	0908353c 	xorhi	r4,at,8404
 90834d8:	0908353c 	xorhi	r4,at,8404
 90834dc:	0908353c 	xorhi	r4,at,8404
 90834e0:	0908353c 	xorhi	r4,at,8404
 90834e4:	09084288 	cmpgei	r4,at,8458
 90834e8:	09083ba0 	cmpeqi	r4,at,8430
 90834ec:	09084200 	call	908420 <OSCtxSw_SWITCH_PC+0x9083e0>
 90834f0:	09084200 	call	908420 <OSCtxSw_SWITCH_PC+0x9083e0>
 90834f4:	09084200 	call	908420 <OSCtxSw_SWITCH_PC+0x9083e0>
 90834f8:	090841ec 	andhi	r4,at,8455
 90834fc:	09083ba0 	cmpeqi	r4,at,8430
 9083500:	0908353c 	xorhi	r4,at,8404
 9083504:	0908353c 	xorhi	r4,at,8404
 9083508:	09084174 	orhi	r4,at,8453
 908350c:	0908353c 	xorhi	r4,at,8404
 9083510:	09084144 	addi	r4,at,8453
 9083514:	09083c54 	ori	r4,at,8433
 9083518:	090841a4 	muli	r4,at,8454
 908351c:	09084190 	cmplti	r4,at,8454
 9083520:	0908353c 	xorhi	r4,at,8404
 9083524:	09084420 	cmpeqi	r4,at,8464
 9083528:	0908353c 	xorhi	r4,at,8404
 908352c:	09083ca0 	cmpeqi	r4,at,8434
 9083530:	0908353c 	xorhi	r4,at,8404
 9083534:	0908353c 	xorhi	r4,at,8404
 9083538:	09084318 	cmpnei	r4,at,8460
 908353c:	d9014d17 	ldw	r4,1332(sp)
 9083540:	2000ce26 	beq	r4,zero,908387c <___vfprintf_internal_r+0x6d4>
 9083544:	01400044 	movi	r5,1
 9083548:	d9800f04 	addi	r6,sp,60
 908354c:	d9c14015 	stw	r7,1280(sp)
 9083550:	d9414515 	stw	r5,1300(sp)
 9083554:	d9814115 	stw	r6,1284(sp)
 9083558:	280f883a 	mov	r7,r5
 908355c:	d9000f05 	stb	r4,60(sp)
 9083560:	d8000405 	stb	zero,16(sp)
 9083564:	d8014615 	stw	zero,1304(sp)
 9083568:	d8c14c17 	ldw	r3,1328(sp)
 908356c:	1880008c 	andi	r2,r3,2
 9083570:	1005003a 	cmpeq	r2,r2,zero
 9083574:	d8815015 	stw	r2,1344(sp)
 9083578:	1000031e 	bne	r2,zero,9083588 <___vfprintf_internal_r+0x3e0>
 908357c:	d9014517 	ldw	r4,1300(sp)
 9083580:	21000084 	addi	r4,r4,2
 9083584:	d9014515 	stw	r4,1300(sp)
 9083588:	d9414c17 	ldw	r5,1328(sp)
 908358c:	2940210c 	andi	r5,r5,132
 9083590:	d9414e15 	stw	r5,1336(sp)
 9083594:	28002d1e 	bne	r5,zero,908364c <___vfprintf_internal_r+0x4a4>
 9083598:	d9814a17 	ldw	r6,1320(sp)
 908359c:	d8814517 	ldw	r2,1300(sp)
 90835a0:	30a1c83a 	sub	r16,r6,r2
 90835a4:	0400290e 	bge	zero,r16,908364c <___vfprintf_internal_r+0x4a4>
 90835a8:	00800404 	movi	r2,16
 90835ac:	1404580e 	bge	r2,r16,9084710 <___vfprintf_internal_r+0x1568>
 90835b0:	dc800e17 	ldw	r18,56(sp)
 90835b4:	dc400d17 	ldw	r17,52(sp)
 90835b8:	1027883a 	mov	r19,r2
 90835bc:	07024374 	movhi	fp,2317
 90835c0:	e7328484 	addi	fp,fp,-13806
 90835c4:	050001c4 	movi	r20,7
 90835c8:	00000306 	br	90835d8 <___vfprintf_internal_r+0x430>
 90835cc:	843ffc04 	addi	r16,r16,-16
 90835d0:	ad400204 	addi	r21,r21,8
 90835d4:	9c00130e 	bge	r19,r16,9083624 <___vfprintf_internal_r+0x47c>
 90835d8:	94800404 	addi	r18,r18,16
 90835dc:	8c400044 	addi	r17,r17,1
 90835e0:	af000015 	stw	fp,0(r21)
 90835e4:	acc00115 	stw	r19,4(r21)
 90835e8:	dc800e15 	stw	r18,56(sp)
 90835ec:	dc400d15 	stw	r17,52(sp)
 90835f0:	a47ff60e 	bge	r20,r17,90835cc <___vfprintf_internal_r+0x424>
 90835f4:	d9014f17 	ldw	r4,1340(sp)
 90835f8:	b00b883a 	mov	r5,r22
 90835fc:	d9800c04 	addi	r6,sp,48
 9083600:	d9c15115 	stw	r7,1348(sp)
 9083604:	90831500 	call	9083150 <__sprint_r>
 9083608:	d9c15117 	ldw	r7,1348(sp)
 908360c:	10009e1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083610:	843ffc04 	addi	r16,r16,-16
 9083614:	dc800e17 	ldw	r18,56(sp)
 9083618:	dc400d17 	ldw	r17,52(sp)
 908361c:	dd401904 	addi	r21,sp,100
 9083620:	9c3fed16 	blt	r19,r16,90835d8 <___vfprintf_internal_r+0x430>
 9083624:	9425883a 	add	r18,r18,r16
 9083628:	8c400044 	addi	r17,r17,1
 908362c:	008001c4 	movi	r2,7
 9083630:	af000015 	stw	fp,0(r21)
 9083634:	ac000115 	stw	r16,4(r21)
 9083638:	dc800e15 	stw	r18,56(sp)
 908363c:	dc400d15 	stw	r17,52(sp)
 9083640:	1441f516 	blt	r2,r17,9083e18 <___vfprintf_internal_r+0xc70>
 9083644:	ad400204 	addi	r21,r21,8
 9083648:	00000206 	br	9083654 <___vfprintf_internal_r+0x4ac>
 908364c:	dc800e17 	ldw	r18,56(sp)
 9083650:	dc400d17 	ldw	r17,52(sp)
 9083654:	d8800407 	ldb	r2,16(sp)
 9083658:	10000b26 	beq	r2,zero,9083688 <___vfprintf_internal_r+0x4e0>
 908365c:	00800044 	movi	r2,1
 9083660:	94800044 	addi	r18,r18,1
 9083664:	8c400044 	addi	r17,r17,1
 9083668:	a8800115 	stw	r2,4(r21)
 908366c:	d8c00404 	addi	r3,sp,16
 9083670:	008001c4 	movi	r2,7
 9083674:	a8c00015 	stw	r3,0(r21)
 9083678:	dc800e15 	stw	r18,56(sp)
 908367c:	dc400d15 	stw	r17,52(sp)
 9083680:	1441da16 	blt	r2,r17,9083dec <___vfprintf_internal_r+0xc44>
 9083684:	ad400204 	addi	r21,r21,8
 9083688:	d9015017 	ldw	r4,1344(sp)
 908368c:	20000b1e 	bne	r4,zero,90836bc <___vfprintf_internal_r+0x514>
 9083690:	d8800444 	addi	r2,sp,17
 9083694:	94800084 	addi	r18,r18,2
 9083698:	8c400044 	addi	r17,r17,1
 908369c:	a8800015 	stw	r2,0(r21)
 90836a0:	00c00084 	movi	r3,2
 90836a4:	008001c4 	movi	r2,7
 90836a8:	a8c00115 	stw	r3,4(r21)
 90836ac:	dc800e15 	stw	r18,56(sp)
 90836b0:	dc400d15 	stw	r17,52(sp)
 90836b4:	1441c216 	blt	r2,r17,9083dc0 <___vfprintf_internal_r+0xc18>
 90836b8:	ad400204 	addi	r21,r21,8
 90836bc:	d9414e17 	ldw	r5,1336(sp)
 90836c0:	00802004 	movi	r2,128
 90836c4:	2880b126 	beq	r5,r2,908398c <___vfprintf_internal_r+0x7e4>
 90836c8:	d8c14617 	ldw	r3,1304(sp)
 90836cc:	19e1c83a 	sub	r16,r3,r7
 90836d0:	0400260e 	bge	zero,r16,908376c <___vfprintf_internal_r+0x5c4>
 90836d4:	00800404 	movi	r2,16
 90836d8:	1403c90e 	bge	r2,r16,9084600 <___vfprintf_internal_r+0x1458>
 90836dc:	1027883a 	mov	r19,r2
 90836e0:	07024374 	movhi	fp,2317
 90836e4:	e7328084 	addi	fp,fp,-13822
 90836e8:	050001c4 	movi	r20,7
 90836ec:	00000306 	br	90836fc <___vfprintf_internal_r+0x554>
 90836f0:	843ffc04 	addi	r16,r16,-16
 90836f4:	ad400204 	addi	r21,r21,8
 90836f8:	9c00130e 	bge	r19,r16,9083748 <___vfprintf_internal_r+0x5a0>
 90836fc:	94800404 	addi	r18,r18,16
 9083700:	8c400044 	addi	r17,r17,1
 9083704:	af000015 	stw	fp,0(r21)
 9083708:	acc00115 	stw	r19,4(r21)
 908370c:	dc800e15 	stw	r18,56(sp)
 9083710:	dc400d15 	stw	r17,52(sp)
 9083714:	a47ff60e 	bge	r20,r17,90836f0 <___vfprintf_internal_r+0x548>
 9083718:	d9014f17 	ldw	r4,1340(sp)
 908371c:	b00b883a 	mov	r5,r22
 9083720:	d9800c04 	addi	r6,sp,48
 9083724:	d9c15115 	stw	r7,1348(sp)
 9083728:	90831500 	call	9083150 <__sprint_r>
 908372c:	d9c15117 	ldw	r7,1348(sp)
 9083730:	1000551e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083734:	843ffc04 	addi	r16,r16,-16
 9083738:	dc800e17 	ldw	r18,56(sp)
 908373c:	dc400d17 	ldw	r17,52(sp)
 9083740:	dd401904 	addi	r21,sp,100
 9083744:	9c3fed16 	blt	r19,r16,90836fc <___vfprintf_internal_r+0x554>
 9083748:	9425883a 	add	r18,r18,r16
 908374c:	8c400044 	addi	r17,r17,1
 9083750:	008001c4 	movi	r2,7
 9083754:	af000015 	stw	fp,0(r21)
 9083758:	ac000115 	stw	r16,4(r21)
 908375c:	dc800e15 	stw	r18,56(sp)
 9083760:	dc400d15 	stw	r17,52(sp)
 9083764:	14418216 	blt	r2,r17,9083d70 <___vfprintf_internal_r+0xbc8>
 9083768:	ad400204 	addi	r21,r21,8
 908376c:	d9014c17 	ldw	r4,1328(sp)
 9083770:	2080400c 	andi	r2,r4,256
 9083774:	10004a1e 	bne	r2,zero,90838a0 <___vfprintf_internal_r+0x6f8>
 9083778:	d9414117 	ldw	r5,1284(sp)
 908377c:	91e5883a 	add	r18,r18,r7
 9083780:	8c400044 	addi	r17,r17,1
 9083784:	008001c4 	movi	r2,7
 9083788:	a9400015 	stw	r5,0(r21)
 908378c:	a9c00115 	stw	r7,4(r21)
 9083790:	dc800e15 	stw	r18,56(sp)
 9083794:	dc400d15 	stw	r17,52(sp)
 9083798:	14416716 	blt	r2,r17,9083d38 <___vfprintf_internal_r+0xb90>
 908379c:	a8c00204 	addi	r3,r21,8
 90837a0:	d9814c17 	ldw	r6,1328(sp)
 90837a4:	3080010c 	andi	r2,r6,4
 90837a8:	10002826 	beq	r2,zero,908384c <___vfprintf_internal_r+0x6a4>
 90837ac:	d8814a17 	ldw	r2,1320(sp)
 90837b0:	d9014517 	ldw	r4,1300(sp)
 90837b4:	1121c83a 	sub	r16,r2,r4
 90837b8:	0400240e 	bge	zero,r16,908384c <___vfprintf_internal_r+0x6a4>
 90837bc:	00800404 	movi	r2,16
 90837c0:	14044f0e 	bge	r2,r16,9084900 <___vfprintf_internal_r+0x1758>
 90837c4:	dc400d17 	ldw	r17,52(sp)
 90837c8:	1027883a 	mov	r19,r2
 90837cc:	07024374 	movhi	fp,2317
 90837d0:	e7328484 	addi	fp,fp,-13806
 90837d4:	050001c4 	movi	r20,7
 90837d8:	00000306 	br	90837e8 <___vfprintf_internal_r+0x640>
 90837dc:	843ffc04 	addi	r16,r16,-16
 90837e0:	18c00204 	addi	r3,r3,8
 90837e4:	9c00110e 	bge	r19,r16,908382c <___vfprintf_internal_r+0x684>
 90837e8:	94800404 	addi	r18,r18,16
 90837ec:	8c400044 	addi	r17,r17,1
 90837f0:	1f000015 	stw	fp,0(r3)
 90837f4:	1cc00115 	stw	r19,4(r3)
 90837f8:	dc800e15 	stw	r18,56(sp)
 90837fc:	dc400d15 	stw	r17,52(sp)
 9083800:	a47ff60e 	bge	r20,r17,90837dc <___vfprintf_internal_r+0x634>
 9083804:	d9014f17 	ldw	r4,1340(sp)
 9083808:	b00b883a 	mov	r5,r22
 908380c:	d9800c04 	addi	r6,sp,48
 9083810:	90831500 	call	9083150 <__sprint_r>
 9083814:	10001c1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083818:	843ffc04 	addi	r16,r16,-16
 908381c:	dc800e17 	ldw	r18,56(sp)
 9083820:	dc400d17 	ldw	r17,52(sp)
 9083824:	d8c01904 	addi	r3,sp,100
 9083828:	9c3fef16 	blt	r19,r16,90837e8 <___vfprintf_internal_r+0x640>
 908382c:	9425883a 	add	r18,r18,r16
 9083830:	8c400044 	addi	r17,r17,1
 9083834:	008001c4 	movi	r2,7
 9083838:	1f000015 	stw	fp,0(r3)
 908383c:	1c000115 	stw	r16,4(r3)
 9083840:	dc800e15 	stw	r18,56(sp)
 9083844:	dc400d15 	stw	r17,52(sp)
 9083848:	1440cb16 	blt	r2,r17,9083b78 <___vfprintf_internal_r+0x9d0>
 908384c:	d8814a17 	ldw	r2,1320(sp)
 9083850:	d9414517 	ldw	r5,1300(sp)
 9083854:	1140010e 	bge	r2,r5,908385c <___vfprintf_internal_r+0x6b4>
 9083858:	2805883a 	mov	r2,r5
 908385c:	d9814b17 	ldw	r6,1324(sp)
 9083860:	308d883a 	add	r6,r6,r2
 9083864:	d9814b15 	stw	r6,1324(sp)
 9083868:	90013b1e 	bne	r18,zero,9083d58 <___vfprintf_internal_r+0xbb0>
 908386c:	d9c14017 	ldw	r7,1280(sp)
 9083870:	dd401904 	addi	r21,sp,100
 9083874:	d8000d15 	stw	zero,52(sp)
 9083878:	003ea706 	br	9083318 <___vfprintf_internal_r+0x170>
 908387c:	d8800e17 	ldw	r2,56(sp)
 9083880:	10053f1e 	bne	r2,zero,9084d80 <___vfprintf_internal_r+0x1bd8>
 9083884:	d8000d15 	stw	zero,52(sp)
 9083888:	b080030b 	ldhu	r2,12(r22)
 908388c:	1080100c 	andi	r2,r2,64
 9083890:	103e8726 	beq	r2,zero,90832b0 <___vfprintf_internal_r+0x108>
 9083894:	00bfffc4 	movi	r2,-1
 9083898:	d8814b15 	stw	r2,1324(sp)
 908389c:	003e8406 	br	90832b0 <___vfprintf_internal_r+0x108>
 90838a0:	d9814d17 	ldw	r6,1332(sp)
 90838a4:	00801944 	movi	r2,101
 90838a8:	11806e16 	blt	r2,r6,9083a64 <___vfprintf_internal_r+0x8bc>
 90838ac:	d9414717 	ldw	r5,1308(sp)
 90838b0:	00c00044 	movi	r3,1
 90838b4:	1943430e 	bge	r3,r5,90845c4 <___vfprintf_internal_r+0x141c>
 90838b8:	d8814117 	ldw	r2,1284(sp)
 90838bc:	94800044 	addi	r18,r18,1
 90838c0:	8c400044 	addi	r17,r17,1
 90838c4:	a8800015 	stw	r2,0(r21)
 90838c8:	008001c4 	movi	r2,7
 90838cc:	a8c00115 	stw	r3,4(r21)
 90838d0:	dc800e15 	stw	r18,56(sp)
 90838d4:	dc400d15 	stw	r17,52(sp)
 90838d8:	1441ca16 	blt	r2,r17,9084004 <___vfprintf_internal_r+0xe5c>
 90838dc:	a8c00204 	addi	r3,r21,8
 90838e0:	d9014917 	ldw	r4,1316(sp)
 90838e4:	00800044 	movi	r2,1
 90838e8:	94800044 	addi	r18,r18,1
 90838ec:	8c400044 	addi	r17,r17,1
 90838f0:	18800115 	stw	r2,4(r3)
 90838f4:	008001c4 	movi	r2,7
 90838f8:	19000015 	stw	r4,0(r3)
 90838fc:	dc800e15 	stw	r18,56(sp)
 9083900:	dc400d15 	stw	r17,52(sp)
 9083904:	1441b616 	blt	r2,r17,9083fe0 <___vfprintf_internal_r+0xe38>
 9083908:	1cc00204 	addi	r19,r3,8
 908390c:	d9014217 	ldw	r4,1288(sp)
 9083910:	d9414317 	ldw	r5,1292(sp)
 9083914:	000d883a 	mov	r6,zero
 9083918:	000f883a 	mov	r7,zero
 908391c:	908bc480 	call	908bc48 <__nedf2>
 9083920:	10017426 	beq	r2,zero,9083ef4 <___vfprintf_internal_r+0xd4c>
 9083924:	d9414717 	ldw	r5,1308(sp)
 9083928:	d9814117 	ldw	r6,1284(sp)
 908392c:	8c400044 	addi	r17,r17,1
 9083930:	2c85883a 	add	r2,r5,r18
 9083934:	14bfffc4 	addi	r18,r2,-1
 9083938:	28bfffc4 	addi	r2,r5,-1
 908393c:	30c00044 	addi	r3,r6,1
 9083940:	98800115 	stw	r2,4(r19)
 9083944:	008001c4 	movi	r2,7
 9083948:	98c00015 	stw	r3,0(r19)
 908394c:	dc800e15 	stw	r18,56(sp)
 9083950:	dc400d15 	stw	r17,52(sp)
 9083954:	14418e16 	blt	r2,r17,9083f90 <___vfprintf_internal_r+0xde8>
 9083958:	9cc00204 	addi	r19,r19,8
 908395c:	d9414817 	ldw	r5,1312(sp)
 9083960:	d8800804 	addi	r2,sp,32
 9083964:	8c400044 	addi	r17,r17,1
 9083968:	9165883a 	add	r18,r18,r5
 908396c:	98800015 	stw	r2,0(r19)
 9083970:	008001c4 	movi	r2,7
 9083974:	99400115 	stw	r5,4(r19)
 9083978:	dc800e15 	stw	r18,56(sp)
 908397c:	dc400d15 	stw	r17,52(sp)
 9083980:	1440ed16 	blt	r2,r17,9083d38 <___vfprintf_internal_r+0xb90>
 9083984:	98c00204 	addi	r3,r19,8
 9083988:	003f8506 	br	90837a0 <___vfprintf_internal_r+0x5f8>
 908398c:	d9814a17 	ldw	r6,1320(sp)
 9083990:	d8814517 	ldw	r2,1300(sp)
 9083994:	30a1c83a 	sub	r16,r6,r2
 9083998:	043f4b0e 	bge	zero,r16,90836c8 <___vfprintf_internal_r+0x520>
 908399c:	00800404 	movi	r2,16
 90839a0:	1404340e 	bge	r2,r16,9084a74 <___vfprintf_internal_r+0x18cc>
 90839a4:	1027883a 	mov	r19,r2
 90839a8:	07024374 	movhi	fp,2317
 90839ac:	e7328084 	addi	fp,fp,-13822
 90839b0:	050001c4 	movi	r20,7
 90839b4:	00000306 	br	90839c4 <___vfprintf_internal_r+0x81c>
 90839b8:	843ffc04 	addi	r16,r16,-16
 90839bc:	ad400204 	addi	r21,r21,8
 90839c0:	9c00130e 	bge	r19,r16,9083a10 <___vfprintf_internal_r+0x868>
 90839c4:	94800404 	addi	r18,r18,16
 90839c8:	8c400044 	addi	r17,r17,1
 90839cc:	af000015 	stw	fp,0(r21)
 90839d0:	acc00115 	stw	r19,4(r21)
 90839d4:	dc800e15 	stw	r18,56(sp)
 90839d8:	dc400d15 	stw	r17,52(sp)
 90839dc:	a47ff60e 	bge	r20,r17,90839b8 <___vfprintf_internal_r+0x810>
 90839e0:	d9014f17 	ldw	r4,1340(sp)
 90839e4:	b00b883a 	mov	r5,r22
 90839e8:	d9800c04 	addi	r6,sp,48
 90839ec:	d9c15115 	stw	r7,1348(sp)
 90839f0:	90831500 	call	9083150 <__sprint_r>
 90839f4:	d9c15117 	ldw	r7,1348(sp)
 90839f8:	103fa31e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 90839fc:	843ffc04 	addi	r16,r16,-16
 9083a00:	dc800e17 	ldw	r18,56(sp)
 9083a04:	dc400d17 	ldw	r17,52(sp)
 9083a08:	dd401904 	addi	r21,sp,100
 9083a0c:	9c3fed16 	blt	r19,r16,90839c4 <___vfprintf_internal_r+0x81c>
 9083a10:	9425883a 	add	r18,r18,r16
 9083a14:	8c400044 	addi	r17,r17,1
 9083a18:	008001c4 	movi	r2,7
 9083a1c:	af000015 	stw	fp,0(r21)
 9083a20:	ac000115 	stw	r16,4(r21)
 9083a24:	dc800e15 	stw	r18,56(sp)
 9083a28:	dc400d15 	stw	r17,52(sp)
 9083a2c:	14416116 	blt	r2,r17,9083fb4 <___vfprintf_internal_r+0xe0c>
 9083a30:	ad400204 	addi	r21,r21,8
 9083a34:	003f2406 	br	90836c8 <___vfprintf_internal_r+0x520>
 9083a38:	d9014f17 	ldw	r4,1340(sp)
 9083a3c:	9086d640 	call	9086d64 <__sinit>
 9083a40:	d9c15117 	ldw	r7,1348(sp)
 9083a44:	003def06 	br	9083204 <___vfprintf_internal_r+0x5c>
 9083a48:	d9014f17 	ldw	r4,1340(sp)
 9083a4c:	b00b883a 	mov	r5,r22
 9083a50:	d9c15115 	stw	r7,1348(sp)
 9083a54:	90851c40 	call	90851c4 <__swsetup_r>
 9083a58:	d9c15117 	ldw	r7,1348(sp)
 9083a5c:	103dee26 	beq	r2,zero,9083218 <___vfprintf_internal_r+0x70>
 9083a60:	003f8c06 	br	9083894 <___vfprintf_internal_r+0x6ec>
 9083a64:	d9014217 	ldw	r4,1288(sp)
 9083a68:	d9414317 	ldw	r5,1292(sp)
 9083a6c:	000d883a 	mov	r6,zero
 9083a70:	000f883a 	mov	r7,zero
 9083a74:	908bbc00 	call	908bbc0 <__eqdf2>
 9083a78:	1000f21e 	bne	r2,zero,9083e44 <___vfprintf_internal_r+0xc9c>
 9083a7c:	00824374 	movhi	r2,2317
 9083a80:	10b28004 	addi	r2,r2,-13824
 9083a84:	94800044 	addi	r18,r18,1
 9083a88:	8c400044 	addi	r17,r17,1
 9083a8c:	a8800015 	stw	r2,0(r21)
 9083a90:	00c00044 	movi	r3,1
 9083a94:	008001c4 	movi	r2,7
 9083a98:	a8c00115 	stw	r3,4(r21)
 9083a9c:	dc800e15 	stw	r18,56(sp)
 9083aa0:	dc400d15 	stw	r17,52(sp)
 9083aa4:	1442fa16 	blt	r2,r17,9084690 <___vfprintf_internal_r+0x14e8>
 9083aa8:	a8c00204 	addi	r3,r21,8
 9083aac:	d8800517 	ldw	r2,20(sp)
 9083ab0:	d9014717 	ldw	r4,1308(sp)
 9083ab4:	11015c0e 	bge	r2,r4,9084028 <___vfprintf_internal_r+0xe80>
 9083ab8:	dc400d17 	ldw	r17,52(sp)
 9083abc:	d9814917 	ldw	r6,1316(sp)
 9083ac0:	00800044 	movi	r2,1
 9083ac4:	94800044 	addi	r18,r18,1
 9083ac8:	8c400044 	addi	r17,r17,1
 9083acc:	18800115 	stw	r2,4(r3)
 9083ad0:	008001c4 	movi	r2,7
 9083ad4:	19800015 	stw	r6,0(r3)
 9083ad8:	dc800e15 	stw	r18,56(sp)
 9083adc:	dc400d15 	stw	r17,52(sp)
 9083ae0:	14431016 	blt	r2,r17,9084724 <___vfprintf_internal_r+0x157c>
 9083ae4:	18c00204 	addi	r3,r3,8
 9083ae8:	d8814717 	ldw	r2,1308(sp)
 9083aec:	143fffc4 	addi	r16,r2,-1
 9083af0:	043f2b0e 	bge	zero,r16,90837a0 <___vfprintf_internal_r+0x5f8>
 9083af4:	00800404 	movi	r2,16
 9083af8:	1402a20e 	bge	r2,r16,9084584 <___vfprintf_internal_r+0x13dc>
 9083afc:	dc400d17 	ldw	r17,52(sp)
 9083b00:	1027883a 	mov	r19,r2
 9083b04:	07024374 	movhi	fp,2317
 9083b08:	e7328084 	addi	fp,fp,-13822
 9083b0c:	050001c4 	movi	r20,7
 9083b10:	00000306 	br	9083b20 <___vfprintf_internal_r+0x978>
 9083b14:	18c00204 	addi	r3,r3,8
 9083b18:	843ffc04 	addi	r16,r16,-16
 9083b1c:	9c029c0e 	bge	r19,r16,9084590 <___vfprintf_internal_r+0x13e8>
 9083b20:	94800404 	addi	r18,r18,16
 9083b24:	8c400044 	addi	r17,r17,1
 9083b28:	1f000015 	stw	fp,0(r3)
 9083b2c:	1cc00115 	stw	r19,4(r3)
 9083b30:	dc800e15 	stw	r18,56(sp)
 9083b34:	dc400d15 	stw	r17,52(sp)
 9083b38:	a47ff60e 	bge	r20,r17,9083b14 <___vfprintf_internal_r+0x96c>
 9083b3c:	d9014f17 	ldw	r4,1340(sp)
 9083b40:	b00b883a 	mov	r5,r22
 9083b44:	d9800c04 	addi	r6,sp,48
 9083b48:	90831500 	call	9083150 <__sprint_r>
 9083b4c:	103f4e1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083b50:	dc800e17 	ldw	r18,56(sp)
 9083b54:	dc400d17 	ldw	r17,52(sp)
 9083b58:	d8c01904 	addi	r3,sp,100
 9083b5c:	003fee06 	br	9083b18 <___vfprintf_internal_r+0x970>
 9083b60:	d8802c0b 	ldhu	r2,176(sp)
 9083b64:	00ffffc4 	movi	r3,-1
 9083b68:	d8c14b15 	stw	r3,1324(sp)
 9083b6c:	1080100c 	andi	r2,r2,64
 9083b70:	103dcc1e 	bne	r2,zero,90832a4 <___vfprintf_internal_r+0xfc>
 9083b74:	003dce06 	br	90832b0 <___vfprintf_internal_r+0x108>
 9083b78:	d9014f17 	ldw	r4,1340(sp)
 9083b7c:	b00b883a 	mov	r5,r22
 9083b80:	d9800c04 	addi	r6,sp,48
 9083b84:	90831500 	call	9083150 <__sprint_r>
 9083b88:	103f3f1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083b8c:	dc800e17 	ldw	r18,56(sp)
 9083b90:	003f2e06 	br	908384c <___vfprintf_internal_r+0x6a4>
 9083b94:	d9414c17 	ldw	r5,1328(sp)
 9083b98:	29400414 	ori	r5,r5,16
 9083b9c:	d9414c15 	stw	r5,1328(sp)
 9083ba0:	d9814c17 	ldw	r6,1328(sp)
 9083ba4:	3080080c 	andi	r2,r6,32
 9083ba8:	10014f1e 	bne	r2,zero,90840e8 <___vfprintf_internal_r+0xf40>
 9083bac:	d8c14c17 	ldw	r3,1328(sp)
 9083bb0:	1880040c 	andi	r2,r3,16
 9083bb4:	1002ea1e 	bne	r2,zero,9084760 <___vfprintf_internal_r+0x15b8>
 9083bb8:	d9014c17 	ldw	r4,1328(sp)
 9083bbc:	2080100c 	andi	r2,r4,64
 9083bc0:	1002e726 	beq	r2,zero,9084760 <___vfprintf_internal_r+0x15b8>
 9083bc4:	3880000f 	ldh	r2,0(r7)
 9083bc8:	39c00104 	addi	r7,r7,4
 9083bcc:	d9c14015 	stw	r7,1280(sp)
 9083bd0:	1023d7fa 	srai	r17,r2,31
 9083bd4:	1021883a 	mov	r16,r2
 9083bd8:	88037216 	blt	r17,zero,90849a4 <___vfprintf_internal_r+0x17fc>
 9083bdc:	01000044 	movi	r4,1
 9083be0:	98000416 	blt	r19,zero,9083bf4 <___vfprintf_internal_r+0xa4c>
 9083be4:	d8c14c17 	ldw	r3,1328(sp)
 9083be8:	00bfdfc4 	movi	r2,-129
 9083bec:	1886703a 	and	r3,r3,r2
 9083bf0:	d8c14c15 	stw	r3,1328(sp)
 9083bf4:	8444b03a 	or	r2,r16,r17
 9083bf8:	1002261e 	bne	r2,zero,9084494 <___vfprintf_internal_r+0x12ec>
 9083bfc:	9802251e 	bne	r19,zero,9084494 <___vfprintf_internal_r+0x12ec>
 9083c00:	20803fcc 	andi	r2,r4,255
 9083c04:	10029b26 	beq	r2,zero,9084674 <___vfprintf_internal_r+0x14cc>
 9083c08:	d8c01904 	addi	r3,sp,100
 9083c0c:	dd000f04 	addi	r20,sp,60
 9083c10:	d8c14115 	stw	r3,1284(sp)
 9083c14:	d8c14117 	ldw	r3,1284(sp)
 9083c18:	dcc14515 	stw	r19,1300(sp)
 9083c1c:	a0c5c83a 	sub	r2,r20,r3
 9083c20:	11c00a04 	addi	r7,r2,40
 9083c24:	99c0010e 	bge	r19,r7,9083c2c <___vfprintf_internal_r+0xa84>
 9083c28:	d9c14515 	stw	r7,1300(sp)
 9083c2c:	dcc14615 	stw	r19,1304(sp)
 9083c30:	d8800407 	ldb	r2,16(sp)
 9083c34:	103e4c26 	beq	r2,zero,9083568 <___vfprintf_internal_r+0x3c0>
 9083c38:	d8814517 	ldw	r2,1300(sp)
 9083c3c:	10800044 	addi	r2,r2,1
 9083c40:	d8814515 	stw	r2,1300(sp)
 9083c44:	003e4806 	br	9083568 <___vfprintf_internal_r+0x3c0>
 9083c48:	d9814c17 	ldw	r6,1328(sp)
 9083c4c:	31800414 	ori	r6,r6,16
 9083c50:	d9814c15 	stw	r6,1328(sp)
 9083c54:	d8c14c17 	ldw	r3,1328(sp)
 9083c58:	1880080c 	andi	r2,r3,32
 9083c5c:	1001271e 	bne	r2,zero,90840fc <___vfprintf_internal_r+0xf54>
 9083c60:	d9414c17 	ldw	r5,1328(sp)
 9083c64:	2880040c 	andi	r2,r5,16
 9083c68:	1002b61e 	bne	r2,zero,9084744 <___vfprintf_internal_r+0x159c>
 9083c6c:	d9814c17 	ldw	r6,1328(sp)
 9083c70:	3080100c 	andi	r2,r6,64
 9083c74:	1002b326 	beq	r2,zero,9084744 <___vfprintf_internal_r+0x159c>
 9083c78:	3c00000b 	ldhu	r16,0(r7)
 9083c7c:	0009883a 	mov	r4,zero
 9083c80:	39c00104 	addi	r7,r7,4
 9083c84:	0023883a 	mov	r17,zero
 9083c88:	d9c14015 	stw	r7,1280(sp)
 9083c8c:	d8000405 	stb	zero,16(sp)
 9083c90:	003fd306 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9083c94:	d9014c17 	ldw	r4,1328(sp)
 9083c98:	21000414 	ori	r4,r4,16
 9083c9c:	d9014c15 	stw	r4,1328(sp)
 9083ca0:	d9414c17 	ldw	r5,1328(sp)
 9083ca4:	2880080c 	andi	r2,r5,32
 9083ca8:	1001081e 	bne	r2,zero,90840cc <___vfprintf_internal_r+0xf24>
 9083cac:	d8c14c17 	ldw	r3,1328(sp)
 9083cb0:	1880040c 	andi	r2,r3,16
 9083cb4:	1002b01e 	bne	r2,zero,9084778 <___vfprintf_internal_r+0x15d0>
 9083cb8:	d9014c17 	ldw	r4,1328(sp)
 9083cbc:	2080100c 	andi	r2,r4,64
 9083cc0:	1002ad26 	beq	r2,zero,9084778 <___vfprintf_internal_r+0x15d0>
 9083cc4:	3c00000b 	ldhu	r16,0(r7)
 9083cc8:	01000044 	movi	r4,1
 9083ccc:	39c00104 	addi	r7,r7,4
 9083cd0:	0023883a 	mov	r17,zero
 9083cd4:	d9c14015 	stw	r7,1280(sp)
 9083cd8:	d8000405 	stb	zero,16(sp)
 9083cdc:	003fc006 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9083ce0:	d9014f17 	ldw	r4,1340(sp)
 9083ce4:	b00b883a 	mov	r5,r22
 9083ce8:	d9800c04 	addi	r6,sp,48
 9083cec:	90831500 	call	9083150 <__sprint_r>
 9083cf0:	103ee51e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083cf4:	dc800e17 	ldw	r18,56(sp)
 9083cf8:	d8c01904 	addi	r3,sp,100
 9083cfc:	d9814c17 	ldw	r6,1328(sp)
 9083d00:	3080004c 	andi	r2,r6,1
 9083d04:	1005003a 	cmpeq	r2,r2,zero
 9083d08:	103ea51e 	bne	r2,zero,90837a0 <___vfprintf_internal_r+0x5f8>
 9083d0c:	00800044 	movi	r2,1
 9083d10:	dc400d17 	ldw	r17,52(sp)
 9083d14:	18800115 	stw	r2,4(r3)
 9083d18:	d8814917 	ldw	r2,1316(sp)
 9083d1c:	94800044 	addi	r18,r18,1
 9083d20:	8c400044 	addi	r17,r17,1
 9083d24:	18800015 	stw	r2,0(r3)
 9083d28:	008001c4 	movi	r2,7
 9083d2c:	dc800e15 	stw	r18,56(sp)
 9083d30:	dc400d15 	stw	r17,52(sp)
 9083d34:	14421e0e 	bge	r2,r17,90845b0 <___vfprintf_internal_r+0x1408>
 9083d38:	d9014f17 	ldw	r4,1340(sp)
 9083d3c:	b00b883a 	mov	r5,r22
 9083d40:	d9800c04 	addi	r6,sp,48
 9083d44:	90831500 	call	9083150 <__sprint_r>
 9083d48:	103ecf1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083d4c:	dc800e17 	ldw	r18,56(sp)
 9083d50:	d8c01904 	addi	r3,sp,100
 9083d54:	003e9206 	br	90837a0 <___vfprintf_internal_r+0x5f8>
 9083d58:	d9014f17 	ldw	r4,1340(sp)
 9083d5c:	b00b883a 	mov	r5,r22
 9083d60:	d9800c04 	addi	r6,sp,48
 9083d64:	90831500 	call	9083150 <__sprint_r>
 9083d68:	103ec026 	beq	r2,zero,908386c <___vfprintf_internal_r+0x6c4>
 9083d6c:	003ec606 	br	9083888 <___vfprintf_internal_r+0x6e0>
 9083d70:	d9014f17 	ldw	r4,1340(sp)
 9083d74:	b00b883a 	mov	r5,r22
 9083d78:	d9800c04 	addi	r6,sp,48
 9083d7c:	d9c15115 	stw	r7,1348(sp)
 9083d80:	90831500 	call	9083150 <__sprint_r>
 9083d84:	d9c15117 	ldw	r7,1348(sp)
 9083d88:	103ebf1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083d8c:	dc800e17 	ldw	r18,56(sp)
 9083d90:	dc400d17 	ldw	r17,52(sp)
 9083d94:	dd401904 	addi	r21,sp,100
 9083d98:	003e7406 	br	908376c <___vfprintf_internal_r+0x5c4>
 9083d9c:	d9014f17 	ldw	r4,1340(sp)
 9083da0:	b00b883a 	mov	r5,r22
 9083da4:	d9800c04 	addi	r6,sp,48
 9083da8:	d9c15115 	stw	r7,1348(sp)
 9083dac:	90831500 	call	9083150 <__sprint_r>
 9083db0:	d9c15117 	ldw	r7,1348(sp)
 9083db4:	103eb41e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083db8:	dd401904 	addi	r21,sp,100
 9083dbc:	003d6d06 	br	9083374 <___vfprintf_internal_r+0x1cc>
 9083dc0:	d9014f17 	ldw	r4,1340(sp)
 9083dc4:	b00b883a 	mov	r5,r22
 9083dc8:	d9800c04 	addi	r6,sp,48
 9083dcc:	d9c15115 	stw	r7,1348(sp)
 9083dd0:	90831500 	call	9083150 <__sprint_r>
 9083dd4:	d9c15117 	ldw	r7,1348(sp)
 9083dd8:	103eab1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083ddc:	dc800e17 	ldw	r18,56(sp)
 9083de0:	dc400d17 	ldw	r17,52(sp)
 9083de4:	dd401904 	addi	r21,sp,100
 9083de8:	003e3406 	br	90836bc <___vfprintf_internal_r+0x514>
 9083dec:	d9014f17 	ldw	r4,1340(sp)
 9083df0:	b00b883a 	mov	r5,r22
 9083df4:	d9800c04 	addi	r6,sp,48
 9083df8:	d9c15115 	stw	r7,1348(sp)
 9083dfc:	90831500 	call	9083150 <__sprint_r>
 9083e00:	d9c15117 	ldw	r7,1348(sp)
 9083e04:	103ea01e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083e08:	dc800e17 	ldw	r18,56(sp)
 9083e0c:	dc400d17 	ldw	r17,52(sp)
 9083e10:	dd401904 	addi	r21,sp,100
 9083e14:	003e1c06 	br	9083688 <___vfprintf_internal_r+0x4e0>
 9083e18:	d9014f17 	ldw	r4,1340(sp)
 9083e1c:	b00b883a 	mov	r5,r22
 9083e20:	d9800c04 	addi	r6,sp,48
 9083e24:	d9c15115 	stw	r7,1348(sp)
 9083e28:	90831500 	call	9083150 <__sprint_r>
 9083e2c:	d9c15117 	ldw	r7,1348(sp)
 9083e30:	103e951e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083e34:	dc800e17 	ldw	r18,56(sp)
 9083e38:	dc400d17 	ldw	r17,52(sp)
 9083e3c:	dd401904 	addi	r21,sp,100
 9083e40:	003e0406 	br	9083654 <___vfprintf_internal_r+0x4ac>
 9083e44:	d9000517 	ldw	r4,20(sp)
 9083e48:	0102520e 	bge	zero,r4,9084794 <___vfprintf_internal_r+0x15ec>
 9083e4c:	d9814717 	ldw	r6,1308(sp)
 9083e50:	21807a16 	blt	r4,r6,908403c <___vfprintf_internal_r+0xe94>
 9083e54:	d8814117 	ldw	r2,1284(sp)
 9083e58:	91a5883a 	add	r18,r18,r6
 9083e5c:	8c400044 	addi	r17,r17,1
 9083e60:	a8800015 	stw	r2,0(r21)
 9083e64:	008001c4 	movi	r2,7
 9083e68:	a9800115 	stw	r6,4(r21)
 9083e6c:	dc800e15 	stw	r18,56(sp)
 9083e70:	dc400d15 	stw	r17,52(sp)
 9083e74:	1442f616 	blt	r2,r17,9084a50 <___vfprintf_internal_r+0x18a8>
 9083e78:	a8c00204 	addi	r3,r21,8
 9083e7c:	d9414717 	ldw	r5,1308(sp)
 9083e80:	2161c83a 	sub	r16,r4,r5
 9083e84:	043f9d0e 	bge	zero,r16,9083cfc <___vfprintf_internal_r+0xb54>
 9083e88:	00800404 	movi	r2,16
 9083e8c:	1402130e 	bge	r2,r16,90846dc <___vfprintf_internal_r+0x1534>
 9083e90:	dc400d17 	ldw	r17,52(sp)
 9083e94:	1027883a 	mov	r19,r2
 9083e98:	07024374 	movhi	fp,2317
 9083e9c:	e7328084 	addi	fp,fp,-13822
 9083ea0:	050001c4 	movi	r20,7
 9083ea4:	00000306 	br	9083eb4 <___vfprintf_internal_r+0xd0c>
 9083ea8:	18c00204 	addi	r3,r3,8
 9083eac:	843ffc04 	addi	r16,r16,-16
 9083eb0:	9c020d0e 	bge	r19,r16,90846e8 <___vfprintf_internal_r+0x1540>
 9083eb4:	94800404 	addi	r18,r18,16
 9083eb8:	8c400044 	addi	r17,r17,1
 9083ebc:	1f000015 	stw	fp,0(r3)
 9083ec0:	1cc00115 	stw	r19,4(r3)
 9083ec4:	dc800e15 	stw	r18,56(sp)
 9083ec8:	dc400d15 	stw	r17,52(sp)
 9083ecc:	a47ff60e 	bge	r20,r17,9083ea8 <___vfprintf_internal_r+0xd00>
 9083ed0:	d9014f17 	ldw	r4,1340(sp)
 9083ed4:	b00b883a 	mov	r5,r22
 9083ed8:	d9800c04 	addi	r6,sp,48
 9083edc:	90831500 	call	9083150 <__sprint_r>
 9083ee0:	103e691e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083ee4:	dc800e17 	ldw	r18,56(sp)
 9083ee8:	dc400d17 	ldw	r17,52(sp)
 9083eec:	d8c01904 	addi	r3,sp,100
 9083ef0:	003fee06 	br	9083eac <___vfprintf_internal_r+0xd04>
 9083ef4:	d8814717 	ldw	r2,1308(sp)
 9083ef8:	143fffc4 	addi	r16,r2,-1
 9083efc:	043e970e 	bge	zero,r16,908395c <___vfprintf_internal_r+0x7b4>
 9083f00:	00800404 	movi	r2,16
 9083f04:	1400180e 	bge	r2,r16,9083f68 <___vfprintf_internal_r+0xdc0>
 9083f08:	1029883a 	mov	r20,r2
 9083f0c:	07024374 	movhi	fp,2317
 9083f10:	e7328084 	addi	fp,fp,-13822
 9083f14:	054001c4 	movi	r21,7
 9083f18:	00000306 	br	9083f28 <___vfprintf_internal_r+0xd80>
 9083f1c:	9cc00204 	addi	r19,r19,8
 9083f20:	843ffc04 	addi	r16,r16,-16
 9083f24:	a400120e 	bge	r20,r16,9083f70 <___vfprintf_internal_r+0xdc8>
 9083f28:	94800404 	addi	r18,r18,16
 9083f2c:	8c400044 	addi	r17,r17,1
 9083f30:	9f000015 	stw	fp,0(r19)
 9083f34:	9d000115 	stw	r20,4(r19)
 9083f38:	dc800e15 	stw	r18,56(sp)
 9083f3c:	dc400d15 	stw	r17,52(sp)
 9083f40:	ac7ff60e 	bge	r21,r17,9083f1c <___vfprintf_internal_r+0xd74>
 9083f44:	d9014f17 	ldw	r4,1340(sp)
 9083f48:	b00b883a 	mov	r5,r22
 9083f4c:	d9800c04 	addi	r6,sp,48
 9083f50:	90831500 	call	9083150 <__sprint_r>
 9083f54:	103e4c1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083f58:	dc800e17 	ldw	r18,56(sp)
 9083f5c:	dc400d17 	ldw	r17,52(sp)
 9083f60:	dcc01904 	addi	r19,sp,100
 9083f64:	003fee06 	br	9083f20 <___vfprintf_internal_r+0xd78>
 9083f68:	07024374 	movhi	fp,2317
 9083f6c:	e7328084 	addi	fp,fp,-13822
 9083f70:	9425883a 	add	r18,r18,r16
 9083f74:	8c400044 	addi	r17,r17,1
 9083f78:	008001c4 	movi	r2,7
 9083f7c:	9f000015 	stw	fp,0(r19)
 9083f80:	9c000115 	stw	r16,4(r19)
 9083f84:	dc800e15 	stw	r18,56(sp)
 9083f88:	dc400d15 	stw	r17,52(sp)
 9083f8c:	147e720e 	bge	r2,r17,9083958 <___vfprintf_internal_r+0x7b0>
 9083f90:	d9014f17 	ldw	r4,1340(sp)
 9083f94:	b00b883a 	mov	r5,r22
 9083f98:	d9800c04 	addi	r6,sp,48
 9083f9c:	90831500 	call	9083150 <__sprint_r>
 9083fa0:	103e391e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083fa4:	dc800e17 	ldw	r18,56(sp)
 9083fa8:	dc400d17 	ldw	r17,52(sp)
 9083fac:	dcc01904 	addi	r19,sp,100
 9083fb0:	003e6a06 	br	908395c <___vfprintf_internal_r+0x7b4>
 9083fb4:	d9014f17 	ldw	r4,1340(sp)
 9083fb8:	b00b883a 	mov	r5,r22
 9083fbc:	d9800c04 	addi	r6,sp,48
 9083fc0:	d9c15115 	stw	r7,1348(sp)
 9083fc4:	90831500 	call	9083150 <__sprint_r>
 9083fc8:	d9c15117 	ldw	r7,1348(sp)
 9083fcc:	103e2e1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083fd0:	dc800e17 	ldw	r18,56(sp)
 9083fd4:	dc400d17 	ldw	r17,52(sp)
 9083fd8:	dd401904 	addi	r21,sp,100
 9083fdc:	003dba06 	br	90836c8 <___vfprintf_internal_r+0x520>
 9083fe0:	d9014f17 	ldw	r4,1340(sp)
 9083fe4:	b00b883a 	mov	r5,r22
 9083fe8:	d9800c04 	addi	r6,sp,48
 9083fec:	90831500 	call	9083150 <__sprint_r>
 9083ff0:	103e251e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9083ff4:	dc800e17 	ldw	r18,56(sp)
 9083ff8:	dc400d17 	ldw	r17,52(sp)
 9083ffc:	dcc01904 	addi	r19,sp,100
 9084000:	003e4206 	br	908390c <___vfprintf_internal_r+0x764>
 9084004:	d9014f17 	ldw	r4,1340(sp)
 9084008:	b00b883a 	mov	r5,r22
 908400c:	d9800c04 	addi	r6,sp,48
 9084010:	90831500 	call	9083150 <__sprint_r>
 9084014:	103e1c1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084018:	dc800e17 	ldw	r18,56(sp)
 908401c:	dc400d17 	ldw	r17,52(sp)
 9084020:	d8c01904 	addi	r3,sp,100
 9084024:	003e2e06 	br	90838e0 <___vfprintf_internal_r+0x738>
 9084028:	d9414c17 	ldw	r5,1328(sp)
 908402c:	2880004c 	andi	r2,r5,1
 9084030:	1005003a 	cmpeq	r2,r2,zero
 9084034:	103dda1e 	bne	r2,zero,90837a0 <___vfprintf_internal_r+0x5f8>
 9084038:	003e9f06 	br	9083ab8 <___vfprintf_internal_r+0x910>
 908403c:	d8c14117 	ldw	r3,1284(sp)
 9084040:	9125883a 	add	r18,r18,r4
 9084044:	8c400044 	addi	r17,r17,1
 9084048:	008001c4 	movi	r2,7
 908404c:	a8c00015 	stw	r3,0(r21)
 9084050:	a9000115 	stw	r4,4(r21)
 9084054:	dc800e15 	stw	r18,56(sp)
 9084058:	dc400d15 	stw	r17,52(sp)
 908405c:	14426616 	blt	r2,r17,90849f8 <___vfprintf_internal_r+0x1850>
 9084060:	a8c00204 	addi	r3,r21,8
 9084064:	d9414917 	ldw	r5,1316(sp)
 9084068:	00800044 	movi	r2,1
 908406c:	94800044 	addi	r18,r18,1
 9084070:	8c400044 	addi	r17,r17,1
 9084074:	18800115 	stw	r2,4(r3)
 9084078:	008001c4 	movi	r2,7
 908407c:	19400015 	stw	r5,0(r3)
 9084080:	dc800e15 	stw	r18,56(sp)
 9084084:	dc400d15 	stw	r17,52(sp)
 9084088:	2021883a 	mov	r16,r4
 908408c:	14425016 	blt	r2,r17,90849d0 <___vfprintf_internal_r+0x1828>
 9084090:	19400204 	addi	r5,r3,8
 9084094:	d9814717 	ldw	r6,1308(sp)
 9084098:	8c400044 	addi	r17,r17,1
 908409c:	dc400d15 	stw	r17,52(sp)
 90840a0:	3107c83a 	sub	r3,r6,r4
 90840a4:	d9014117 	ldw	r4,1284(sp)
 90840a8:	90e5883a 	add	r18,r18,r3
 90840ac:	28c00115 	stw	r3,4(r5)
 90840b0:	8105883a 	add	r2,r16,r4
 90840b4:	28800015 	stw	r2,0(r5)
 90840b8:	008001c4 	movi	r2,7
 90840bc:	dc800e15 	stw	r18,56(sp)
 90840c0:	147f1d16 	blt	r2,r17,9083d38 <___vfprintf_internal_r+0xb90>
 90840c4:	28c00204 	addi	r3,r5,8
 90840c8:	003db506 	br	90837a0 <___vfprintf_internal_r+0x5f8>
 90840cc:	3c000017 	ldw	r16,0(r7)
 90840d0:	3c400117 	ldw	r17,4(r7)
 90840d4:	39800204 	addi	r6,r7,8
 90840d8:	01000044 	movi	r4,1
 90840dc:	d9814015 	stw	r6,1280(sp)
 90840e0:	d8000405 	stb	zero,16(sp)
 90840e4:	003ebe06 	br	9083be0 <___vfprintf_internal_r+0xa38>
 90840e8:	3c000017 	ldw	r16,0(r7)
 90840ec:	3c400117 	ldw	r17,4(r7)
 90840f0:	38800204 	addi	r2,r7,8
 90840f4:	d8814015 	stw	r2,1280(sp)
 90840f8:	003eb706 	br	9083bd8 <___vfprintf_internal_r+0xa30>
 90840fc:	3c000017 	ldw	r16,0(r7)
 9084100:	3c400117 	ldw	r17,4(r7)
 9084104:	39000204 	addi	r4,r7,8
 9084108:	d9014015 	stw	r4,1280(sp)
 908410c:	0009883a 	mov	r4,zero
 9084110:	d8000405 	stb	zero,16(sp)
 9084114:	003eb206 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9084118:	38c00017 	ldw	r3,0(r7)
 908411c:	39c00104 	addi	r7,r7,4
 9084120:	d8c14a15 	stw	r3,1320(sp)
 9084124:	1800d10e 	bge	r3,zero,908446c <___vfprintf_internal_r+0x12c4>
 9084128:	00c7c83a 	sub	r3,zero,r3
 908412c:	d8c14a15 	stw	r3,1320(sp)
 9084130:	d9014c17 	ldw	r4,1328(sp)
 9084134:	b8c00007 	ldb	r3,0(r23)
 9084138:	21000114 	ori	r4,r4,4
 908413c:	d9014c15 	stw	r4,1328(sp)
 9084140:	003c9806 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084144:	d9814c17 	ldw	r6,1328(sp)
 9084148:	3080080c 	andi	r2,r6,32
 908414c:	1001f026 	beq	r2,zero,9084910 <___vfprintf_internal_r+0x1768>
 9084150:	d9014b17 	ldw	r4,1324(sp)
 9084154:	38800017 	ldw	r2,0(r7)
 9084158:	39c00104 	addi	r7,r7,4
 908415c:	d9c14015 	stw	r7,1280(sp)
 9084160:	2007d7fa 	srai	r3,r4,31
 9084164:	d9c14017 	ldw	r7,1280(sp)
 9084168:	11000015 	stw	r4,0(r2)
 908416c:	10c00115 	stw	r3,4(r2)
 9084170:	003c6906 	br	9083318 <___vfprintf_internal_r+0x170>
 9084174:	b8c00007 	ldb	r3,0(r23)
 9084178:	00801b04 	movi	r2,108
 908417c:	18824f26 	beq	r3,r2,9084abc <___vfprintf_internal_r+0x1914>
 9084180:	d9414c17 	ldw	r5,1328(sp)
 9084184:	29400414 	ori	r5,r5,16
 9084188:	d9414c15 	stw	r5,1328(sp)
 908418c:	003c8506 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084190:	d9814c17 	ldw	r6,1328(sp)
 9084194:	b8c00007 	ldb	r3,0(r23)
 9084198:	31800814 	ori	r6,r6,32
 908419c:	d9814c15 	stw	r6,1328(sp)
 90841a0:	003c8006 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 90841a4:	d8814c17 	ldw	r2,1328(sp)
 90841a8:	3c000017 	ldw	r16,0(r7)
 90841ac:	00c01e04 	movi	r3,120
 90841b0:	10800094 	ori	r2,r2,2
 90841b4:	d8814c15 	stw	r2,1328(sp)
 90841b8:	39c00104 	addi	r7,r7,4
 90841bc:	01424374 	movhi	r5,2317
 90841c0:	29726904 	addi	r5,r5,-13916
 90841c4:	00800c04 	movi	r2,48
 90841c8:	0023883a 	mov	r17,zero
 90841cc:	01000084 	movi	r4,2
 90841d0:	d9c14015 	stw	r7,1280(sp)
 90841d4:	d8c14d15 	stw	r3,1332(sp)
 90841d8:	d9414415 	stw	r5,1296(sp)
 90841dc:	d8800445 	stb	r2,17(sp)
 90841e0:	d8c00485 	stb	r3,18(sp)
 90841e4:	d8000405 	stb	zero,16(sp)
 90841e8:	003e7d06 	br	9083be0 <___vfprintf_internal_r+0xa38>
 90841ec:	d8814c17 	ldw	r2,1328(sp)
 90841f0:	b8c00007 	ldb	r3,0(r23)
 90841f4:	10801014 	ori	r2,r2,64
 90841f8:	d8814c15 	stw	r2,1328(sp)
 90841fc:	003c6906 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084200:	d9414c17 	ldw	r5,1328(sp)
 9084204:	2880020c 	andi	r2,r5,8
 9084208:	1001df26 	beq	r2,zero,9084988 <___vfprintf_internal_r+0x17e0>
 908420c:	39800017 	ldw	r6,0(r7)
 9084210:	38800204 	addi	r2,r7,8
 9084214:	d8814015 	stw	r2,1280(sp)
 9084218:	d9814215 	stw	r6,1288(sp)
 908421c:	39c00117 	ldw	r7,4(r7)
 9084220:	d9c14315 	stw	r7,1292(sp)
 9084224:	d9014217 	ldw	r4,1288(sp)
 9084228:	d9414317 	ldw	r5,1292(sp)
 908422c:	9089da80 	call	9089da8 <__isinfd>
 9084230:	10021726 	beq	r2,zero,9084a90 <___vfprintf_internal_r+0x18e8>
 9084234:	d9014217 	ldw	r4,1288(sp)
 9084238:	d9414317 	ldw	r5,1292(sp)
 908423c:	000d883a 	mov	r6,zero
 9084240:	000f883a 	mov	r7,zero
 9084244:	908bde00 	call	908bde0 <__ltdf2>
 9084248:	1002ca16 	blt	r2,zero,9084d74 <___vfprintf_internal_r+0x1bcc>
 908424c:	d9414d17 	ldw	r5,1332(sp)
 9084250:	008011c4 	movi	r2,71
 9084254:	11420a16 	blt	r2,r5,9084a80 <___vfprintf_internal_r+0x18d8>
 9084258:	01824374 	movhi	r6,2317
 908425c:	31b26e04 	addi	r6,r6,-13896
 9084260:	d9814115 	stw	r6,1284(sp)
 9084264:	d9014c17 	ldw	r4,1328(sp)
 9084268:	00c000c4 	movi	r3,3
 908426c:	00bfdfc4 	movi	r2,-129
 9084270:	2088703a 	and	r4,r4,r2
 9084274:	180f883a 	mov	r7,r3
 9084278:	d8c14515 	stw	r3,1300(sp)
 908427c:	d9014c15 	stw	r4,1328(sp)
 9084280:	d8014615 	stw	zero,1304(sp)
 9084284:	003e6a06 	br	9083c30 <___vfprintf_internal_r+0xa88>
 9084288:	38800017 	ldw	r2,0(r7)
 908428c:	00c00044 	movi	r3,1
 9084290:	39c00104 	addi	r7,r7,4
 9084294:	d9c14015 	stw	r7,1280(sp)
 9084298:	d9000f04 	addi	r4,sp,60
 908429c:	180f883a 	mov	r7,r3
 90842a0:	d8c14515 	stw	r3,1300(sp)
 90842a4:	d9014115 	stw	r4,1284(sp)
 90842a8:	d8800f05 	stb	r2,60(sp)
 90842ac:	d8000405 	stb	zero,16(sp)
 90842b0:	003cac06 	br	9083564 <___vfprintf_internal_r+0x3bc>
 90842b4:	01424374 	movhi	r5,2317
 90842b8:	29727404 	addi	r5,r5,-13872
 90842bc:	d9414415 	stw	r5,1296(sp)
 90842c0:	d9814c17 	ldw	r6,1328(sp)
 90842c4:	3080080c 	andi	r2,r6,32
 90842c8:	1000f926 	beq	r2,zero,90846b0 <___vfprintf_internal_r+0x1508>
 90842cc:	3c000017 	ldw	r16,0(r7)
 90842d0:	3c400117 	ldw	r17,4(r7)
 90842d4:	38800204 	addi	r2,r7,8
 90842d8:	d8814015 	stw	r2,1280(sp)
 90842dc:	d9414c17 	ldw	r5,1328(sp)
 90842e0:	2880004c 	andi	r2,r5,1
 90842e4:	1005003a 	cmpeq	r2,r2,zero
 90842e8:	1000b31e 	bne	r2,zero,90845b8 <___vfprintf_internal_r+0x1410>
 90842ec:	8444b03a 	or	r2,r16,r17
 90842f0:	1000b126 	beq	r2,zero,90845b8 <___vfprintf_internal_r+0x1410>
 90842f4:	d9814d17 	ldw	r6,1332(sp)
 90842f8:	29400094 	ori	r5,r5,2
 90842fc:	00800c04 	movi	r2,48
 9084300:	01000084 	movi	r4,2
 9084304:	d9414c15 	stw	r5,1328(sp)
 9084308:	d8800445 	stb	r2,17(sp)
 908430c:	d9800485 	stb	r6,18(sp)
 9084310:	d8000405 	stb	zero,16(sp)
 9084314:	003e3206 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9084318:	01824374 	movhi	r6,2317
 908431c:	31b26904 	addi	r6,r6,-13916
 9084320:	d9814415 	stw	r6,1296(sp)
 9084324:	003fe606 	br	90842c0 <___vfprintf_internal_r+0x1118>
 9084328:	00800ac4 	movi	r2,43
 908432c:	d8800405 	stb	r2,16(sp)
 9084330:	b8c00007 	ldb	r3,0(r23)
 9084334:	003c1b06 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084338:	d8814c17 	ldw	r2,1328(sp)
 908433c:	b8c00007 	ldb	r3,0(r23)
 9084340:	10800054 	ori	r2,r2,1
 9084344:	d8814c15 	stw	r2,1328(sp)
 9084348:	003c1606 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 908434c:	d8800407 	ldb	r2,16(sp)
 9084350:	1000461e 	bne	r2,zero,908446c <___vfprintf_internal_r+0x12c4>
 9084354:	00800804 	movi	r2,32
 9084358:	d8800405 	stb	r2,16(sp)
 908435c:	b8c00007 	ldb	r3,0(r23)
 9084360:	003c1006 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084364:	d9814c17 	ldw	r6,1328(sp)
 9084368:	b8c00007 	ldb	r3,0(r23)
 908436c:	31800214 	ori	r6,r6,8
 9084370:	d9814c15 	stw	r6,1328(sp)
 9084374:	003c0b06 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084378:	0007883a 	mov	r3,zero
 908437c:	01000244 	movi	r4,9
 9084380:	188002a4 	muli	r2,r3,10
 9084384:	b8c00007 	ldb	r3,0(r23)
 9084388:	d9814d17 	ldw	r6,1332(sp)
 908438c:	bdc00044 	addi	r23,r23,1
 9084390:	d8c14d15 	stw	r3,1332(sp)
 9084394:	d9414d17 	ldw	r5,1332(sp)
 9084398:	3085883a 	add	r2,r6,r2
 908439c:	10fff404 	addi	r3,r2,-48
 90843a0:	28bff404 	addi	r2,r5,-48
 90843a4:	20bff62e 	bgeu	r4,r2,9084380 <___vfprintf_internal_r+0x11d8>
 90843a8:	d8c14a15 	stw	r3,1320(sp)
 90843ac:	003bff06 	br	90833ac <___vfprintf_internal_r+0x204>
 90843b0:	d9414c17 	ldw	r5,1328(sp)
 90843b4:	b8c00007 	ldb	r3,0(r23)
 90843b8:	29402014 	ori	r5,r5,128
 90843bc:	d9414c15 	stw	r5,1328(sp)
 90843c0:	003bf806 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 90843c4:	b8c00007 	ldb	r3,0(r23)
 90843c8:	00800a84 	movi	r2,42
 90843cc:	bdc00044 	addi	r23,r23,1
 90843d0:	18831526 	beq	r3,r2,9085028 <___vfprintf_internal_r+0x1e80>
 90843d4:	d8c14d15 	stw	r3,1332(sp)
 90843d8:	18bff404 	addi	r2,r3,-48
 90843dc:	00c00244 	movi	r3,9
 90843e0:	18827836 	bltu	r3,r2,9084dc4 <___vfprintf_internal_r+0x1c1c>
 90843e4:	000d883a 	mov	r6,zero
 90843e8:	308002a4 	muli	r2,r6,10
 90843ec:	b9800007 	ldb	r6,0(r23)
 90843f0:	d9414d17 	ldw	r5,1332(sp)
 90843f4:	bdc00044 	addi	r23,r23,1
 90843f8:	d9814d15 	stw	r6,1332(sp)
 90843fc:	d9014d17 	ldw	r4,1332(sp)
 9084400:	1145883a 	add	r2,r2,r5
 9084404:	11bff404 	addi	r6,r2,-48
 9084408:	20bff404 	addi	r2,r4,-48
 908440c:	18bff62e 	bgeu	r3,r2,90843e8 <___vfprintf_internal_r+0x1240>
 9084410:	3027883a 	mov	r19,r6
 9084414:	303be50e 	bge	r6,zero,90833ac <___vfprintf_internal_r+0x204>
 9084418:	04ffffc4 	movi	r19,-1
 908441c:	003be306 	br	90833ac <___vfprintf_internal_r+0x204>
 9084420:	d8000405 	stb	zero,16(sp)
 9084424:	39800017 	ldw	r6,0(r7)
 9084428:	39c00104 	addi	r7,r7,4
 908442c:	d9c14015 	stw	r7,1280(sp)
 9084430:	d9814115 	stw	r6,1284(sp)
 9084434:	3001c926 	beq	r6,zero,9084b5c <___vfprintf_internal_r+0x19b4>
 9084438:	98000e16 	blt	r19,zero,9084474 <___vfprintf_internal_r+0x12cc>
 908443c:	d9014117 	ldw	r4,1284(sp)
 9084440:	000b883a 	mov	r5,zero
 9084444:	980d883a 	mov	r6,r19
 9084448:	90884fc0 	call	90884fc <memchr>
 908444c:	10025926 	beq	r2,zero,9084db4 <___vfprintf_internal_r+0x1c0c>
 9084450:	d8c14117 	ldw	r3,1284(sp)
 9084454:	10cfc83a 	sub	r7,r2,r3
 9084458:	99c19e16 	blt	r19,r7,9084ad4 <___vfprintf_internal_r+0x192c>
 908445c:	d9c14515 	stw	r7,1300(sp)
 9084460:	38000916 	blt	r7,zero,9084488 <___vfprintf_internal_r+0x12e0>
 9084464:	d8014615 	stw	zero,1304(sp)
 9084468:	003df106 	br	9083c30 <___vfprintf_internal_r+0xa88>
 908446c:	b8c00007 	ldb	r3,0(r23)
 9084470:	003bcc06 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084474:	d9014117 	ldw	r4,1284(sp)
 9084478:	90830d40 	call	90830d4 <strlen>
 908447c:	d8814515 	stw	r2,1300(sp)
 9084480:	100f883a 	mov	r7,r2
 9084484:	103ff70e 	bge	r2,zero,9084464 <___vfprintf_internal_r+0x12bc>
 9084488:	d8014515 	stw	zero,1300(sp)
 908448c:	d8014615 	stw	zero,1304(sp)
 9084490:	003de706 	br	9083c30 <___vfprintf_internal_r+0xa88>
 9084494:	20c03fcc 	andi	r3,r4,255
 9084498:	00800044 	movi	r2,1
 908449c:	18802d26 	beq	r3,r2,9084554 <___vfprintf_internal_r+0x13ac>
 90844a0:	18800e36 	bltu	r3,r2,90844dc <___vfprintf_internal_r+0x1334>
 90844a4:	00800084 	movi	r2,2
 90844a8:	1880fa26 	beq	r3,r2,9084894 <___vfprintf_internal_r+0x16ec>
 90844ac:	01024374 	movhi	r4,2317
 90844b0:	21327904 	addi	r4,r4,-13852
 90844b4:	90830d40 	call	90830d4 <strlen>
 90844b8:	100f883a 	mov	r7,r2
 90844bc:	dcc14515 	stw	r19,1300(sp)
 90844c0:	9880010e 	bge	r19,r2,90844c8 <___vfprintf_internal_r+0x1320>
 90844c4:	d8814515 	stw	r2,1300(sp)
 90844c8:	00824374 	movhi	r2,2317
 90844cc:	10b27904 	addi	r2,r2,-13852
 90844d0:	dcc14615 	stw	r19,1304(sp)
 90844d4:	d8814115 	stw	r2,1284(sp)
 90844d8:	003dd506 	br	9083c30 <___vfprintf_internal_r+0xa88>
 90844dc:	d9401904 	addi	r5,sp,100
 90844e0:	dd000f04 	addi	r20,sp,60
 90844e4:	d9414115 	stw	r5,1284(sp)
 90844e8:	880a977a 	slli	r5,r17,29
 90844ec:	d9814117 	ldw	r6,1284(sp)
 90844f0:	8004d0fa 	srli	r2,r16,3
 90844f4:	8806d0fa 	srli	r3,r17,3
 90844f8:	810001cc 	andi	r4,r16,7
 90844fc:	2884b03a 	or	r2,r5,r2
 9084500:	31bfffc4 	addi	r6,r6,-1
 9084504:	21000c04 	addi	r4,r4,48
 9084508:	d9814115 	stw	r6,1284(sp)
 908450c:	10cab03a 	or	r5,r2,r3
 9084510:	31000005 	stb	r4,0(r6)
 9084514:	1021883a 	mov	r16,r2
 9084518:	1823883a 	mov	r17,r3
 908451c:	283ff21e 	bne	r5,zero,90844e8 <___vfprintf_internal_r+0x1340>
 9084520:	d8c14c17 	ldw	r3,1328(sp)
 9084524:	1880004c 	andi	r2,r3,1
 9084528:	1005003a 	cmpeq	r2,r2,zero
 908452c:	103db91e 	bne	r2,zero,9083c14 <___vfprintf_internal_r+0xa6c>
 9084530:	20803fcc 	andi	r2,r4,255
 9084534:	1080201c 	xori	r2,r2,128
 9084538:	10bfe004 	addi	r2,r2,-128
 908453c:	00c00c04 	movi	r3,48
 9084540:	10fdb426 	beq	r2,r3,9083c14 <___vfprintf_internal_r+0xa6c>
 9084544:	31bfffc4 	addi	r6,r6,-1
 9084548:	d9814115 	stw	r6,1284(sp)
 908454c:	30c00005 	stb	r3,0(r6)
 9084550:	003db006 	br	9083c14 <___vfprintf_internal_r+0xa6c>
 9084554:	88800068 	cmpgeui	r2,r17,1
 9084558:	10002c1e 	bne	r2,zero,908460c <___vfprintf_internal_r+0x1464>
 908455c:	8800021e 	bne	r17,zero,9084568 <___vfprintf_internal_r+0x13c0>
 9084560:	00800244 	movi	r2,9
 9084564:	14002936 	bltu	r2,r16,908460c <___vfprintf_internal_r+0x1464>
 9084568:	d90018c4 	addi	r4,sp,99
 908456c:	dd000f04 	addi	r20,sp,60
 9084570:	d9014115 	stw	r4,1284(sp)
 9084574:	d9014117 	ldw	r4,1284(sp)
 9084578:	80800c04 	addi	r2,r16,48
 908457c:	20800005 	stb	r2,0(r4)
 9084580:	003da406 	br	9083c14 <___vfprintf_internal_r+0xa6c>
 9084584:	dc400d17 	ldw	r17,52(sp)
 9084588:	07024374 	movhi	fp,2317
 908458c:	e7328084 	addi	fp,fp,-13822
 9084590:	9425883a 	add	r18,r18,r16
 9084594:	8c400044 	addi	r17,r17,1
 9084598:	008001c4 	movi	r2,7
 908459c:	1f000015 	stw	fp,0(r3)
 90845a0:	1c000115 	stw	r16,4(r3)
 90845a4:	dc800e15 	stw	r18,56(sp)
 90845a8:	dc400d15 	stw	r17,52(sp)
 90845ac:	147de216 	blt	r2,r17,9083d38 <___vfprintf_internal_r+0xb90>
 90845b0:	18c00204 	addi	r3,r3,8
 90845b4:	003c7a06 	br	90837a0 <___vfprintf_internal_r+0x5f8>
 90845b8:	01000084 	movi	r4,2
 90845bc:	d8000405 	stb	zero,16(sp)
 90845c0:	003d8706 	br	9083be0 <___vfprintf_internal_r+0xa38>
 90845c4:	d9814c17 	ldw	r6,1328(sp)
 90845c8:	30c4703a 	and	r2,r6,r3
 90845cc:	1005003a 	cmpeq	r2,r2,zero
 90845d0:	103cb926 	beq	r2,zero,90838b8 <___vfprintf_internal_r+0x710>
 90845d4:	d9014117 	ldw	r4,1284(sp)
 90845d8:	94800044 	addi	r18,r18,1
 90845dc:	8c400044 	addi	r17,r17,1
 90845e0:	008001c4 	movi	r2,7
 90845e4:	a9000015 	stw	r4,0(r21)
 90845e8:	a8c00115 	stw	r3,4(r21)
 90845ec:	dc800e15 	stw	r18,56(sp)
 90845f0:	dc400d15 	stw	r17,52(sp)
 90845f4:	147e6616 	blt	r2,r17,9083f90 <___vfprintf_internal_r+0xde8>
 90845f8:	acc00204 	addi	r19,r21,8
 90845fc:	003cd706 	br	908395c <___vfprintf_internal_r+0x7b4>
 9084600:	07024374 	movhi	fp,2317
 9084604:	e7328084 	addi	fp,fp,-13822
 9084608:	003c4f06 	br	9083748 <___vfprintf_internal_r+0x5a0>
 908460c:	dd000f04 	addi	r20,sp,60
 9084610:	dc801904 	addi	r18,sp,100
 9084614:	8009883a 	mov	r4,r16
 9084618:	880b883a 	mov	r5,r17
 908461c:	01800284 	movi	r6,10
 9084620:	000f883a 	mov	r7,zero
 9084624:	908ab000 	call	908ab00 <__umoddi3>
 9084628:	12000c04 	addi	r8,r2,48
 908462c:	94bfffc4 	addi	r18,r18,-1
 9084630:	8009883a 	mov	r4,r16
 9084634:	880b883a 	mov	r5,r17
 9084638:	01800284 	movi	r6,10
 908463c:	000f883a 	mov	r7,zero
 9084640:	92000005 	stb	r8,0(r18)
 9084644:	908a5240 	call	908a524 <__udivdi3>
 9084648:	1009883a 	mov	r4,r2
 908464c:	1021883a 	mov	r16,r2
 9084650:	18800068 	cmpgeui	r2,r3,1
 9084654:	1823883a 	mov	r17,r3
 9084658:	103fee1e 	bne	r2,zero,9084614 <___vfprintf_internal_r+0x146c>
 908465c:	1800021e 	bne	r3,zero,9084668 <___vfprintf_internal_r+0x14c0>
 9084660:	00800244 	movi	r2,9
 9084664:	113feb36 	bltu	r2,r4,9084614 <___vfprintf_internal_r+0x146c>
 9084668:	94bfffc4 	addi	r18,r18,-1
 908466c:	dc814115 	stw	r18,1284(sp)
 9084670:	003fc006 	br	9084574 <___vfprintf_internal_r+0x13cc>
 9084674:	d9014c17 	ldw	r4,1328(sp)
 9084678:	2080004c 	andi	r2,r4,1
 908467c:	10009a1e 	bne	r2,zero,90848e8 <___vfprintf_internal_r+0x1740>
 9084680:	d9401904 	addi	r5,sp,100
 9084684:	dd000f04 	addi	r20,sp,60
 9084688:	d9414115 	stw	r5,1284(sp)
 908468c:	003d6106 	br	9083c14 <___vfprintf_internal_r+0xa6c>
 9084690:	d9014f17 	ldw	r4,1340(sp)
 9084694:	b00b883a 	mov	r5,r22
 9084698:	d9800c04 	addi	r6,sp,48
 908469c:	90831500 	call	9083150 <__sprint_r>
 90846a0:	103c791e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 90846a4:	dc800e17 	ldw	r18,56(sp)
 90846a8:	d8c01904 	addi	r3,sp,100
 90846ac:	003cff06 	br	9083aac <___vfprintf_internal_r+0x904>
 90846b0:	d8c14c17 	ldw	r3,1328(sp)
 90846b4:	1880040c 	andi	r2,r3,16
 90846b8:	1000711e 	bne	r2,zero,9084880 <___vfprintf_internal_r+0x16d8>
 90846bc:	d9014c17 	ldw	r4,1328(sp)
 90846c0:	2080100c 	andi	r2,r4,64
 90846c4:	10006e26 	beq	r2,zero,9084880 <___vfprintf_internal_r+0x16d8>
 90846c8:	3c00000b 	ldhu	r16,0(r7)
 90846cc:	0023883a 	mov	r17,zero
 90846d0:	39c00104 	addi	r7,r7,4
 90846d4:	d9c14015 	stw	r7,1280(sp)
 90846d8:	003f0006 	br	90842dc <___vfprintf_internal_r+0x1134>
 90846dc:	dc400d17 	ldw	r17,52(sp)
 90846e0:	07024374 	movhi	fp,2317
 90846e4:	e7328084 	addi	fp,fp,-13822
 90846e8:	9425883a 	add	r18,r18,r16
 90846ec:	8c400044 	addi	r17,r17,1
 90846f0:	008001c4 	movi	r2,7
 90846f4:	1f000015 	stw	fp,0(r3)
 90846f8:	1c000115 	stw	r16,4(r3)
 90846fc:	dc800e15 	stw	r18,56(sp)
 9084700:	dc400d15 	stw	r17,52(sp)
 9084704:	147d7616 	blt	r2,r17,9083ce0 <___vfprintf_internal_r+0xb38>
 9084708:	18c00204 	addi	r3,r3,8
 908470c:	003d7b06 	br	9083cfc <___vfprintf_internal_r+0xb54>
 9084710:	dc800e17 	ldw	r18,56(sp)
 9084714:	dc400d17 	ldw	r17,52(sp)
 9084718:	07024374 	movhi	fp,2317
 908471c:	e7328484 	addi	fp,fp,-13806
 9084720:	003bc006 	br	9083624 <___vfprintf_internal_r+0x47c>
 9084724:	d9014f17 	ldw	r4,1340(sp)
 9084728:	b00b883a 	mov	r5,r22
 908472c:	d9800c04 	addi	r6,sp,48
 9084730:	90831500 	call	9083150 <__sprint_r>
 9084734:	103c541e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084738:	dc800e17 	ldw	r18,56(sp)
 908473c:	d8c01904 	addi	r3,sp,100
 9084740:	003ce906 	br	9083ae8 <___vfprintf_internal_r+0x940>
 9084744:	3c000017 	ldw	r16,0(r7)
 9084748:	0009883a 	mov	r4,zero
 908474c:	39c00104 	addi	r7,r7,4
 9084750:	0023883a 	mov	r17,zero
 9084754:	d9c14015 	stw	r7,1280(sp)
 9084758:	d8000405 	stb	zero,16(sp)
 908475c:	003d2006 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9084760:	38800017 	ldw	r2,0(r7)
 9084764:	39c00104 	addi	r7,r7,4
 9084768:	d9c14015 	stw	r7,1280(sp)
 908476c:	1023d7fa 	srai	r17,r2,31
 9084770:	1021883a 	mov	r16,r2
 9084774:	003d1806 	br	9083bd8 <___vfprintf_internal_r+0xa30>
 9084778:	3c000017 	ldw	r16,0(r7)
 908477c:	01000044 	movi	r4,1
 9084780:	39c00104 	addi	r7,r7,4
 9084784:	0023883a 	mov	r17,zero
 9084788:	d9c14015 	stw	r7,1280(sp)
 908478c:	d8000405 	stb	zero,16(sp)
 9084790:	003d1306 	br	9083be0 <___vfprintf_internal_r+0xa38>
 9084794:	00824374 	movhi	r2,2317
 9084798:	10b28004 	addi	r2,r2,-13824
 908479c:	94800044 	addi	r18,r18,1
 90847a0:	8c400044 	addi	r17,r17,1
 90847a4:	a8800015 	stw	r2,0(r21)
 90847a8:	00c00044 	movi	r3,1
 90847ac:	008001c4 	movi	r2,7
 90847b0:	a8c00115 	stw	r3,4(r21)
 90847b4:	dc800e15 	stw	r18,56(sp)
 90847b8:	dc400d15 	stw	r17,52(sp)
 90847bc:	1440ca16 	blt	r2,r17,9084ae8 <___vfprintf_internal_r+0x1940>
 90847c0:	a8c00204 	addi	r3,r21,8
 90847c4:	2000061e 	bne	r4,zero,90847e0 <___vfprintf_internal_r+0x1638>
 90847c8:	d9414717 	ldw	r5,1308(sp)
 90847cc:	2800041e 	bne	r5,zero,90847e0 <___vfprintf_internal_r+0x1638>
 90847d0:	d9814c17 	ldw	r6,1328(sp)
 90847d4:	3080004c 	andi	r2,r6,1
 90847d8:	1005003a 	cmpeq	r2,r2,zero
 90847dc:	103bf01e 	bne	r2,zero,90837a0 <___vfprintf_internal_r+0x5f8>
 90847e0:	00800044 	movi	r2,1
 90847e4:	dc400d17 	ldw	r17,52(sp)
 90847e8:	18800115 	stw	r2,4(r3)
 90847ec:	d8814917 	ldw	r2,1316(sp)
 90847f0:	94800044 	addi	r18,r18,1
 90847f4:	8c400044 	addi	r17,r17,1
 90847f8:	18800015 	stw	r2,0(r3)
 90847fc:	008001c4 	movi	r2,7
 9084800:	dc800e15 	stw	r18,56(sp)
 9084804:	dc400d15 	stw	r17,52(sp)
 9084808:	1440ca16 	blt	r2,r17,9084b34 <___vfprintf_internal_r+0x198c>
 908480c:	18c00204 	addi	r3,r3,8
 9084810:	0121c83a 	sub	r16,zero,r4
 9084814:	0400500e 	bge	zero,r16,9084958 <___vfprintf_internal_r+0x17b0>
 9084818:	00800404 	movi	r2,16
 908481c:	1400800e 	bge	r2,r16,9084a20 <___vfprintf_internal_r+0x1878>
 9084820:	1027883a 	mov	r19,r2
 9084824:	07024374 	movhi	fp,2317
 9084828:	e7328084 	addi	fp,fp,-13822
 908482c:	050001c4 	movi	r20,7
 9084830:	00000306 	br	9084840 <___vfprintf_internal_r+0x1698>
 9084834:	18c00204 	addi	r3,r3,8
 9084838:	843ffc04 	addi	r16,r16,-16
 908483c:	9c007a0e 	bge	r19,r16,9084a28 <___vfprintf_internal_r+0x1880>
 9084840:	94800404 	addi	r18,r18,16
 9084844:	8c400044 	addi	r17,r17,1
 9084848:	1f000015 	stw	fp,0(r3)
 908484c:	1cc00115 	stw	r19,4(r3)
 9084850:	dc800e15 	stw	r18,56(sp)
 9084854:	dc400d15 	stw	r17,52(sp)
 9084858:	a47ff60e 	bge	r20,r17,9084834 <___vfprintf_internal_r+0x168c>
 908485c:	d9014f17 	ldw	r4,1340(sp)
 9084860:	b00b883a 	mov	r5,r22
 9084864:	d9800c04 	addi	r6,sp,48
 9084868:	90831500 	call	9083150 <__sprint_r>
 908486c:	103c061e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084870:	dc800e17 	ldw	r18,56(sp)
 9084874:	dc400d17 	ldw	r17,52(sp)
 9084878:	d8c01904 	addi	r3,sp,100
 908487c:	003fee06 	br	9084838 <___vfprintf_internal_r+0x1690>
 9084880:	3c000017 	ldw	r16,0(r7)
 9084884:	0023883a 	mov	r17,zero
 9084888:	39c00104 	addi	r7,r7,4
 908488c:	d9c14015 	stw	r7,1280(sp)
 9084890:	003e9206 	br	90842dc <___vfprintf_internal_r+0x1134>
 9084894:	d9401904 	addi	r5,sp,100
 9084898:	dd000f04 	addi	r20,sp,60
 908489c:	d9414115 	stw	r5,1284(sp)
 90848a0:	d9814417 	ldw	r6,1296(sp)
 90848a4:	880a973a 	slli	r5,r17,28
 90848a8:	8004d13a 	srli	r2,r16,4
 90848ac:	810003cc 	andi	r4,r16,15
 90848b0:	3109883a 	add	r4,r6,r4
 90848b4:	2884b03a 	or	r2,r5,r2
 90848b8:	21400003 	ldbu	r5,0(r4)
 90848bc:	d9014117 	ldw	r4,1284(sp)
 90848c0:	8806d13a 	srli	r3,r17,4
 90848c4:	1021883a 	mov	r16,r2
 90848c8:	213fffc4 	addi	r4,r4,-1
 90848cc:	d9014115 	stw	r4,1284(sp)
 90848d0:	d9814117 	ldw	r6,1284(sp)
 90848d4:	10c8b03a 	or	r4,r2,r3
 90848d8:	1823883a 	mov	r17,r3
 90848dc:	31400005 	stb	r5,0(r6)
 90848e0:	203fef1e 	bne	r4,zero,90848a0 <___vfprintf_internal_r+0x16f8>
 90848e4:	003ccb06 	br	9083c14 <___vfprintf_internal_r+0xa6c>
 90848e8:	00800c04 	movi	r2,48
 90848ec:	d98018c4 	addi	r6,sp,99
 90848f0:	dd000f04 	addi	r20,sp,60
 90848f4:	d88018c5 	stb	r2,99(sp)
 90848f8:	d9814115 	stw	r6,1284(sp)
 90848fc:	003cc506 	br	9083c14 <___vfprintf_internal_r+0xa6c>
 9084900:	dc400d17 	ldw	r17,52(sp)
 9084904:	07024374 	movhi	fp,2317
 9084908:	e7328484 	addi	fp,fp,-13806
 908490c:	003bc706 	br	908382c <___vfprintf_internal_r+0x684>
 9084910:	d9414c17 	ldw	r5,1328(sp)
 9084914:	2880040c 	andi	r2,r5,16
 9084918:	10007c26 	beq	r2,zero,9084b0c <___vfprintf_internal_r+0x1964>
 908491c:	38800017 	ldw	r2,0(r7)
 9084920:	39c00104 	addi	r7,r7,4
 9084924:	d9c14015 	stw	r7,1280(sp)
 9084928:	d9814b17 	ldw	r6,1324(sp)
 908492c:	d9c14017 	ldw	r7,1280(sp)
 9084930:	11800015 	stw	r6,0(r2)
 9084934:	003a7806 	br	9083318 <___vfprintf_internal_r+0x170>
 9084938:	d9014f17 	ldw	r4,1340(sp)
 908493c:	b00b883a 	mov	r5,r22
 9084940:	d9800c04 	addi	r6,sp,48
 9084944:	90831500 	call	9083150 <__sprint_r>
 9084948:	103bcf1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 908494c:	dc800e17 	ldw	r18,56(sp)
 9084950:	dc400d17 	ldw	r17,52(sp)
 9084954:	d8c01904 	addi	r3,sp,100
 9084958:	d9014717 	ldw	r4,1308(sp)
 908495c:	d9414117 	ldw	r5,1284(sp)
 9084960:	8c400044 	addi	r17,r17,1
 9084964:	9125883a 	add	r18,r18,r4
 9084968:	008001c4 	movi	r2,7
 908496c:	19400015 	stw	r5,0(r3)
 9084970:	19000115 	stw	r4,4(r3)
 9084974:	dc800e15 	stw	r18,56(sp)
 9084978:	dc400d15 	stw	r17,52(sp)
 908497c:	147cee16 	blt	r2,r17,9083d38 <___vfprintf_internal_r+0xb90>
 9084980:	18c00204 	addi	r3,r3,8
 9084984:	003b8606 	br	90837a0 <___vfprintf_internal_r+0x5f8>
 9084988:	38c00017 	ldw	r3,0(r7)
 908498c:	39000204 	addi	r4,r7,8
 9084990:	d9014015 	stw	r4,1280(sp)
 9084994:	d8c14215 	stw	r3,1288(sp)
 9084998:	39c00117 	ldw	r7,4(r7)
 908499c:	d9c14315 	stw	r7,1292(sp)
 90849a0:	003e2006 	br	9084224 <___vfprintf_internal_r+0x107c>
 90849a4:	0005883a 	mov	r2,zero
 90849a8:	1409c83a 	sub	r4,r2,r16
 90849ac:	1105803a 	cmpltu	r2,r2,r4
 90849b0:	044bc83a 	sub	r5,zero,r17
 90849b4:	2885c83a 	sub	r2,r5,r2
 90849b8:	2021883a 	mov	r16,r4
 90849bc:	1023883a 	mov	r17,r2
 90849c0:	01000044 	movi	r4,1
 90849c4:	00800b44 	movi	r2,45
 90849c8:	d8800405 	stb	r2,16(sp)
 90849cc:	003c8406 	br	9083be0 <___vfprintf_internal_r+0xa38>
 90849d0:	d9014f17 	ldw	r4,1340(sp)
 90849d4:	b00b883a 	mov	r5,r22
 90849d8:	d9800c04 	addi	r6,sp,48
 90849dc:	90831500 	call	9083150 <__sprint_r>
 90849e0:	103ba91e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 90849e4:	dc800e17 	ldw	r18,56(sp)
 90849e8:	dc400d17 	ldw	r17,52(sp)
 90849ec:	d9000517 	ldw	r4,20(sp)
 90849f0:	d9401904 	addi	r5,sp,100
 90849f4:	003da706 	br	9084094 <___vfprintf_internal_r+0xeec>
 90849f8:	d9014f17 	ldw	r4,1340(sp)
 90849fc:	b00b883a 	mov	r5,r22
 9084a00:	d9800c04 	addi	r6,sp,48
 9084a04:	90831500 	call	9083150 <__sprint_r>
 9084a08:	103b9f1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084a0c:	dc800e17 	ldw	r18,56(sp)
 9084a10:	dc400d17 	ldw	r17,52(sp)
 9084a14:	d9000517 	ldw	r4,20(sp)
 9084a18:	d8c01904 	addi	r3,sp,100
 9084a1c:	003d9106 	br	9084064 <___vfprintf_internal_r+0xebc>
 9084a20:	07024374 	movhi	fp,2317
 9084a24:	e7328084 	addi	fp,fp,-13822
 9084a28:	9425883a 	add	r18,r18,r16
 9084a2c:	8c400044 	addi	r17,r17,1
 9084a30:	008001c4 	movi	r2,7
 9084a34:	1f000015 	stw	fp,0(r3)
 9084a38:	1c000115 	stw	r16,4(r3)
 9084a3c:	dc800e15 	stw	r18,56(sp)
 9084a40:	dc400d15 	stw	r17,52(sp)
 9084a44:	147fbc16 	blt	r2,r17,9084938 <___vfprintf_internal_r+0x1790>
 9084a48:	18c00204 	addi	r3,r3,8
 9084a4c:	003fc206 	br	9084958 <___vfprintf_internal_r+0x17b0>
 9084a50:	d9014f17 	ldw	r4,1340(sp)
 9084a54:	b00b883a 	mov	r5,r22
 9084a58:	d9800c04 	addi	r6,sp,48
 9084a5c:	90831500 	call	9083150 <__sprint_r>
 9084a60:	103b891e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084a64:	dc800e17 	ldw	r18,56(sp)
 9084a68:	d9000517 	ldw	r4,20(sp)
 9084a6c:	d8c01904 	addi	r3,sp,100
 9084a70:	003d0206 	br	9083e7c <___vfprintf_internal_r+0xcd4>
 9084a74:	07024374 	movhi	fp,2317
 9084a78:	e7328084 	addi	fp,fp,-13822
 9084a7c:	003be406 	br	9083a10 <___vfprintf_internal_r+0x868>
 9084a80:	00824374 	movhi	r2,2317
 9084a84:	10b26f04 	addi	r2,r2,-13892
 9084a88:	d8814115 	stw	r2,1284(sp)
 9084a8c:	003df506 	br	9084264 <___vfprintf_internal_r+0x10bc>
 9084a90:	d9014217 	ldw	r4,1288(sp)
 9084a94:	d9414317 	ldw	r5,1292(sp)
 9084a98:	9089de80 	call	9089de8 <__isnand>
 9084a9c:	10003926 	beq	r2,zero,9084b84 <___vfprintf_internal_r+0x19dc>
 9084aa0:	d9414d17 	ldw	r5,1332(sp)
 9084aa4:	008011c4 	movi	r2,71
 9084aa8:	1140ce16 	blt	r2,r5,9084de4 <___vfprintf_internal_r+0x1c3c>
 9084aac:	01824374 	movhi	r6,2317
 9084ab0:	31b27004 	addi	r6,r6,-13888
 9084ab4:	d9814115 	stw	r6,1284(sp)
 9084ab8:	003dea06 	br	9084264 <___vfprintf_internal_r+0x10bc>
 9084abc:	d9014c17 	ldw	r4,1328(sp)
 9084ac0:	bdc00044 	addi	r23,r23,1
 9084ac4:	b8c00007 	ldb	r3,0(r23)
 9084ac8:	21000814 	ori	r4,r4,32
 9084acc:	d9014c15 	stw	r4,1328(sp)
 9084ad0:	003a3406 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9084ad4:	dcc14515 	stw	r19,1300(sp)
 9084ad8:	98011016 	blt	r19,zero,9084f1c <___vfprintf_internal_r+0x1d74>
 9084adc:	980f883a 	mov	r7,r19
 9084ae0:	d8014615 	stw	zero,1304(sp)
 9084ae4:	003c5206 	br	9083c30 <___vfprintf_internal_r+0xa88>
 9084ae8:	d9014f17 	ldw	r4,1340(sp)
 9084aec:	b00b883a 	mov	r5,r22
 9084af0:	d9800c04 	addi	r6,sp,48
 9084af4:	90831500 	call	9083150 <__sprint_r>
 9084af8:	103b631e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084afc:	dc800e17 	ldw	r18,56(sp)
 9084b00:	d9000517 	ldw	r4,20(sp)
 9084b04:	d8c01904 	addi	r3,sp,100
 9084b08:	003f2e06 	br	90847c4 <___vfprintf_internal_r+0x161c>
 9084b0c:	d8c14c17 	ldw	r3,1328(sp)
 9084b10:	1880100c 	andi	r2,r3,64
 9084b14:	1000a026 	beq	r2,zero,9084d98 <___vfprintf_internal_r+0x1bf0>
 9084b18:	38800017 	ldw	r2,0(r7)
 9084b1c:	39c00104 	addi	r7,r7,4
 9084b20:	d9c14015 	stw	r7,1280(sp)
 9084b24:	d9014b17 	ldw	r4,1324(sp)
 9084b28:	d9c14017 	ldw	r7,1280(sp)
 9084b2c:	1100000d 	sth	r4,0(r2)
 9084b30:	0039f906 	br	9083318 <___vfprintf_internal_r+0x170>
 9084b34:	d9014f17 	ldw	r4,1340(sp)
 9084b38:	b00b883a 	mov	r5,r22
 9084b3c:	d9800c04 	addi	r6,sp,48
 9084b40:	90831500 	call	9083150 <__sprint_r>
 9084b44:	103b501e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084b48:	dc800e17 	ldw	r18,56(sp)
 9084b4c:	dc400d17 	ldw	r17,52(sp)
 9084b50:	d9000517 	ldw	r4,20(sp)
 9084b54:	d8c01904 	addi	r3,sp,100
 9084b58:	003f2d06 	br	9084810 <___vfprintf_internal_r+0x1668>
 9084b5c:	00800184 	movi	r2,6
 9084b60:	14c09a36 	bltu	r2,r19,9084dcc <___vfprintf_internal_r+0x1c24>
 9084b64:	dcc14515 	stw	r19,1300(sp)
 9084b68:	9800010e 	bge	r19,zero,9084b70 <___vfprintf_internal_r+0x19c8>
 9084b6c:	d8014515 	stw	zero,1300(sp)
 9084b70:	00824374 	movhi	r2,2317
 9084b74:	10b27204 	addi	r2,r2,-13880
 9084b78:	980f883a 	mov	r7,r19
 9084b7c:	d8814115 	stw	r2,1284(sp)
 9084b80:	003a7806 	br	9083564 <___vfprintf_internal_r+0x3bc>
 9084b84:	00bfffc4 	movi	r2,-1
 9084b88:	9880e226 	beq	r19,r2,9084f14 <___vfprintf_internal_r+0x1d6c>
 9084b8c:	d9414d17 	ldw	r5,1332(sp)
 9084b90:	008019c4 	movi	r2,103
 9084b94:	2880dc26 	beq	r5,r2,9084f08 <___vfprintf_internal_r+0x1d60>
 9084b98:	008011c4 	movi	r2,71
 9084b9c:	2880da26 	beq	r5,r2,9084f08 <___vfprintf_internal_r+0x1d60>
 9084ba0:	d9414c17 	ldw	r5,1328(sp)
 9084ba4:	d9014317 	ldw	r4,1292(sp)
 9084ba8:	d9814217 	ldw	r6,1288(sp)
 9084bac:	29404014 	ori	r5,r5,256
 9084bb0:	d9414c15 	stw	r5,1328(sp)
 9084bb4:	2000cc16 	blt	r4,zero,9084ee8 <___vfprintf_internal_r+0x1d40>
 9084bb8:	3021883a 	mov	r16,r6
 9084bbc:	2023883a 	mov	r17,r4
 9084bc0:	0039883a 	mov	fp,zero
 9084bc4:	d9414d17 	ldw	r5,1332(sp)
 9084bc8:	00801984 	movi	r2,102
 9084bcc:	2880b726 	beq	r5,r2,9084eac <___vfprintf_internal_r+0x1d04>
 9084bd0:	00801184 	movi	r2,70
 9084bd4:	2880b526 	beq	r5,r2,9084eac <___vfprintf_internal_r+0x1d04>
 9084bd8:	00801944 	movi	r2,101
 9084bdc:	2880c826 	beq	r5,r2,9084f00 <___vfprintf_internal_r+0x1d58>
 9084be0:	00801144 	movi	r2,69
 9084be4:	2880c626 	beq	r5,r2,9084f00 <___vfprintf_internal_r+0x1d58>
 9084be8:	9829883a 	mov	r20,r19
 9084bec:	d9014f17 	ldw	r4,1340(sp)
 9084bf0:	d8800504 	addi	r2,sp,20
 9084bf4:	880d883a 	mov	r6,r17
 9084bf8:	d8800115 	stw	r2,4(sp)
 9084bfc:	d8c00604 	addi	r3,sp,24
 9084c00:	d8800704 	addi	r2,sp,28
 9084c04:	800b883a 	mov	r5,r16
 9084c08:	01c00084 	movi	r7,2
 9084c0c:	d8c00215 	stw	r3,8(sp)
 9084c10:	d8800315 	stw	r2,12(sp)
 9084c14:	dd000015 	stw	r20,0(sp)
 9084c18:	90855180 	call	9085518 <_dtoa_r>
 9084c1c:	d9814d17 	ldw	r6,1332(sp)
 9084c20:	d8814115 	stw	r2,1284(sp)
 9084c24:	008019c4 	movi	r2,103
 9084c28:	30809526 	beq	r6,r2,9084e80 <___vfprintf_internal_r+0x1cd8>
 9084c2c:	d8c14d17 	ldw	r3,1332(sp)
 9084c30:	008011c4 	movi	r2,71
 9084c34:	18809226 	beq	r3,r2,9084e80 <___vfprintf_internal_r+0x1cd8>
 9084c38:	d9414117 	ldw	r5,1284(sp)
 9084c3c:	d9814d17 	ldw	r6,1332(sp)
 9084c40:	00801984 	movi	r2,102
 9084c44:	2d25883a 	add	r18,r5,r20
 9084c48:	30808626 	beq	r6,r2,9084e64 <___vfprintf_internal_r+0x1cbc>
 9084c4c:	00801184 	movi	r2,70
 9084c50:	30808426 	beq	r6,r2,9084e64 <___vfprintf_internal_r+0x1cbc>
 9084c54:	000d883a 	mov	r6,zero
 9084c58:	000f883a 	mov	r7,zero
 9084c5c:	880b883a 	mov	r5,r17
 9084c60:	8009883a 	mov	r4,r16
 9084c64:	908bbc00 	call	908bbc0 <__eqdf2>
 9084c68:	1000751e 	bne	r2,zero,9084e40 <___vfprintf_internal_r+0x1c98>
 9084c6c:	9005883a 	mov	r2,r18
 9084c70:	dc800715 	stw	r18,28(sp)
 9084c74:	d9014117 	ldw	r4,1284(sp)
 9084c78:	d9414d17 	ldw	r5,1332(sp)
 9084c7c:	00c019c4 	movi	r3,103
 9084c80:	1125c83a 	sub	r18,r2,r4
 9084c84:	28c06826 	beq	r5,r3,9084e28 <___vfprintf_internal_r+0x1c80>
 9084c88:	008011c4 	movi	r2,71
 9084c8c:	28806626 	beq	r5,r2,9084e28 <___vfprintf_internal_r+0x1c80>
 9084c90:	d9000517 	ldw	r4,20(sp)
 9084c94:	d8c14d17 	ldw	r3,1332(sp)
 9084c98:	00801944 	movi	r2,101
 9084c9c:	10c05516 	blt	r2,r3,9084df4 <___vfprintf_internal_r+0x1c4c>
 9084ca0:	213fffc4 	addi	r4,r4,-1
 9084ca4:	d9000515 	stw	r4,20(sp)
 9084ca8:	d8c00805 	stb	r3,32(sp)
 9084cac:	2021883a 	mov	r16,r4
 9084cb0:	2000c116 	blt	r4,zero,9084fb8 <___vfprintf_internal_r+0x1e10>
 9084cb4:	00800ac4 	movi	r2,43
 9084cb8:	d8800845 	stb	r2,33(sp)
 9084cbc:	00800244 	movi	r2,9
 9084cc0:	1400af0e 	bge	r2,r16,9084f80 <___vfprintf_internal_r+0x1dd8>
 9084cc4:	1027883a 	mov	r19,r2
 9084cc8:	dc400b84 	addi	r17,sp,46
 9084ccc:	8009883a 	mov	r4,r16
 9084cd0:	01400284 	movi	r5,10
 9084cd4:	908c2a80 	call	908c2a8 <__modsi3>
 9084cd8:	10800c04 	addi	r2,r2,48
 9084cdc:	8c7fffc4 	addi	r17,r17,-1
 9084ce0:	8009883a 	mov	r4,r16
 9084ce4:	01400284 	movi	r5,10
 9084ce8:	88800005 	stb	r2,0(r17)
 9084cec:	908c2480 	call	908c248 <__divsi3>
 9084cf0:	1021883a 	mov	r16,r2
 9084cf4:	98bff516 	blt	r19,r2,9084ccc <___vfprintf_internal_r+0x1b24>
 9084cf8:	10c00c04 	addi	r3,r2,48
 9084cfc:	d88009c4 	addi	r2,sp,39
 9084d00:	108001c4 	addi	r2,r2,7
 9084d04:	897fffc4 	addi	r5,r17,-1
 9084d08:	88ffffc5 	stb	r3,-1(r17)
 9084d0c:	2880a72e 	bgeu	r5,r2,9084fac <___vfprintf_internal_r+0x1e04>
 9084d10:	1009883a 	mov	r4,r2
 9084d14:	d9800804 	addi	r6,sp,32
 9084d18:	d8c00884 	addi	r3,sp,34
 9084d1c:	28800003 	ldbu	r2,0(r5)
 9084d20:	29400044 	addi	r5,r5,1
 9084d24:	18800005 	stb	r2,0(r3)
 9084d28:	18c00044 	addi	r3,r3,1
 9084d2c:	293ffb36 	bltu	r5,r4,9084d1c <___vfprintf_internal_r+0x1b74>
 9084d30:	1987c83a 	sub	r3,r3,r6
 9084d34:	00800044 	movi	r2,1
 9084d38:	d8c14815 	stw	r3,1312(sp)
 9084d3c:	90cf883a 	add	r7,r18,r3
 9084d40:	1480960e 	bge	r2,r18,9084f9c <___vfprintf_internal_r+0x1df4>
 9084d44:	39c00044 	addi	r7,r7,1
 9084d48:	d9c14515 	stw	r7,1300(sp)
 9084d4c:	38003416 	blt	r7,zero,9084e20 <___vfprintf_internal_r+0x1c78>
 9084d50:	e0803fcc 	andi	r2,fp,255
 9084d54:	1080201c 	xori	r2,r2,128
 9084d58:	10bfe004 	addi	r2,r2,-128
 9084d5c:	10004e26 	beq	r2,zero,9084e98 <___vfprintf_internal_r+0x1cf0>
 9084d60:	00800b44 	movi	r2,45
 9084d64:	dc814715 	stw	r18,1308(sp)
 9084d68:	d8014615 	stw	zero,1304(sp)
 9084d6c:	d8800405 	stb	r2,16(sp)
 9084d70:	003bb106 	br	9083c38 <___vfprintf_internal_r+0xa90>
 9084d74:	00800b44 	movi	r2,45
 9084d78:	d8800405 	stb	r2,16(sp)
 9084d7c:	003d3306 	br	908424c <___vfprintf_internal_r+0x10a4>
 9084d80:	d9014f17 	ldw	r4,1340(sp)
 9084d84:	b00b883a 	mov	r5,r22
 9084d88:	d9800c04 	addi	r6,sp,48
 9084d8c:	90831500 	call	9083150 <__sprint_r>
 9084d90:	103abd1e 	bne	r2,zero,9083888 <___vfprintf_internal_r+0x6e0>
 9084d94:	003abb06 	br	9083884 <___vfprintf_internal_r+0x6dc>
 9084d98:	38800017 	ldw	r2,0(r7)
 9084d9c:	39c00104 	addi	r7,r7,4
 9084da0:	d9c14015 	stw	r7,1280(sp)
 9084da4:	d9414b17 	ldw	r5,1324(sp)
 9084da8:	d9c14017 	ldw	r7,1280(sp)
 9084dac:	11400015 	stw	r5,0(r2)
 9084db0:	00395906 	br	9083318 <___vfprintf_internal_r+0x170>
 9084db4:	980f883a 	mov	r7,r19
 9084db8:	dcc14515 	stw	r19,1300(sp)
 9084dbc:	d8014615 	stw	zero,1304(sp)
 9084dc0:	003b9b06 	br	9083c30 <___vfprintf_internal_r+0xa88>
 9084dc4:	0027883a 	mov	r19,zero
 9084dc8:	00397806 	br	90833ac <___vfprintf_internal_r+0x204>
 9084dcc:	00c24374 	movhi	r3,2317
 9084dd0:	18f27204 	addi	r3,r3,-13880
 9084dd4:	100f883a 	mov	r7,r2
 9084dd8:	d8814515 	stw	r2,1300(sp)
 9084ddc:	d8c14115 	stw	r3,1284(sp)
 9084de0:	0039e006 	br	9083564 <___vfprintf_internal_r+0x3bc>
 9084de4:	00824374 	movhi	r2,2317
 9084de8:	10b27104 	addi	r2,r2,-13884
 9084dec:	d8814115 	stw	r2,1284(sp)
 9084df0:	003d1c06 	br	9084264 <___vfprintf_internal_r+0x10bc>
 9084df4:	d9414d17 	ldw	r5,1332(sp)
 9084df8:	00801984 	movi	r2,102
 9084dfc:	28804926 	beq	r5,r2,9084f24 <___vfprintf_internal_r+0x1d7c>
 9084e00:	200f883a 	mov	r7,r4
 9084e04:	24805716 	blt	r4,r18,9084f64 <___vfprintf_internal_r+0x1dbc>
 9084e08:	d9414c17 	ldw	r5,1328(sp)
 9084e0c:	2880004c 	andi	r2,r5,1
 9084e10:	10000126 	beq	r2,zero,9084e18 <___vfprintf_internal_r+0x1c70>
 9084e14:	21c00044 	addi	r7,r4,1
 9084e18:	d9c14515 	stw	r7,1300(sp)
 9084e1c:	383fcc0e 	bge	r7,zero,9084d50 <___vfprintf_internal_r+0x1ba8>
 9084e20:	d8014515 	stw	zero,1300(sp)
 9084e24:	003fca06 	br	9084d50 <___vfprintf_internal_r+0x1ba8>
 9084e28:	d9000517 	ldw	r4,20(sp)
 9084e2c:	00bfff04 	movi	r2,-4
 9084e30:	1100480e 	bge	r2,r4,9084f54 <___vfprintf_internal_r+0x1dac>
 9084e34:	99004716 	blt	r19,r4,9084f54 <___vfprintf_internal_r+0x1dac>
 9084e38:	d8c14d15 	stw	r3,1332(sp)
 9084e3c:	003ff006 	br	9084e00 <___vfprintf_internal_r+0x1c58>
 9084e40:	d8800717 	ldw	r2,28(sp)
 9084e44:	14bf8b2e 	bgeu	r2,r18,9084c74 <___vfprintf_internal_r+0x1acc>
 9084e48:	9007883a 	mov	r3,r18
 9084e4c:	01000c04 	movi	r4,48
 9084e50:	11000005 	stb	r4,0(r2)
 9084e54:	10800044 	addi	r2,r2,1
 9084e58:	d8800715 	stw	r2,28(sp)
 9084e5c:	18bffc1e 	bne	r3,r2,9084e50 <___vfprintf_internal_r+0x1ca8>
 9084e60:	003f8406 	br	9084c74 <___vfprintf_internal_r+0x1acc>
 9084e64:	d8814117 	ldw	r2,1284(sp)
 9084e68:	10c00007 	ldb	r3,0(r2)
 9084e6c:	00800c04 	movi	r2,48
 9084e70:	18805b26 	beq	r3,r2,9084fe0 <___vfprintf_internal_r+0x1e38>
 9084e74:	d9000517 	ldw	r4,20(sp)
 9084e78:	9125883a 	add	r18,r18,r4
 9084e7c:	003f7506 	br	9084c54 <___vfprintf_internal_r+0x1aac>
 9084e80:	d9014c17 	ldw	r4,1328(sp)
 9084e84:	2080004c 	andi	r2,r4,1
 9084e88:	1005003a 	cmpeq	r2,r2,zero
 9084e8c:	103f6a26 	beq	r2,zero,9084c38 <___vfprintf_internal_r+0x1a90>
 9084e90:	d8800717 	ldw	r2,28(sp)
 9084e94:	003f7706 	br	9084c74 <___vfprintf_internal_r+0x1acc>
 9084e98:	d9c14515 	stw	r7,1300(sp)
 9084e9c:	38004d16 	blt	r7,zero,9084fd4 <___vfprintf_internal_r+0x1e2c>
 9084ea0:	dc814715 	stw	r18,1308(sp)
 9084ea4:	d8014615 	stw	zero,1304(sp)
 9084ea8:	003b6106 	br	9083c30 <___vfprintf_internal_r+0xa88>
 9084eac:	d9014f17 	ldw	r4,1340(sp)
 9084eb0:	d8800504 	addi	r2,sp,20
 9084eb4:	d8800115 	stw	r2,4(sp)
 9084eb8:	d8c00604 	addi	r3,sp,24
 9084ebc:	d8800704 	addi	r2,sp,28
 9084ec0:	800b883a 	mov	r5,r16
 9084ec4:	880d883a 	mov	r6,r17
 9084ec8:	01c000c4 	movi	r7,3
 9084ecc:	d8c00215 	stw	r3,8(sp)
 9084ed0:	d8800315 	stw	r2,12(sp)
 9084ed4:	dcc00015 	stw	r19,0(sp)
 9084ed8:	9829883a 	mov	r20,r19
 9084edc:	90855180 	call	9085518 <_dtoa_r>
 9084ee0:	d8814115 	stw	r2,1284(sp)
 9084ee4:	003f5106 	br	9084c2c <___vfprintf_internal_r+0x1a84>
 9084ee8:	d8c14217 	ldw	r3,1288(sp)
 9084eec:	d9014317 	ldw	r4,1292(sp)
 9084ef0:	07000b44 	movi	fp,45
 9084ef4:	1821883a 	mov	r16,r3
 9084ef8:	2460003c 	xorhi	r17,r4,32768
 9084efc:	003f3106 	br	9084bc4 <___vfprintf_internal_r+0x1a1c>
 9084f00:	9d000044 	addi	r20,r19,1
 9084f04:	003f3906 	br	9084bec <___vfprintf_internal_r+0x1a44>
 9084f08:	983f251e 	bne	r19,zero,9084ba0 <___vfprintf_internal_r+0x19f8>
 9084f0c:	04c00044 	movi	r19,1
 9084f10:	003f2306 	br	9084ba0 <___vfprintf_internal_r+0x19f8>
 9084f14:	04c00184 	movi	r19,6
 9084f18:	003f2106 	br	9084ba0 <___vfprintf_internal_r+0x19f8>
 9084f1c:	d8014515 	stw	zero,1300(sp)
 9084f20:	003eee06 	br	9084adc <___vfprintf_internal_r+0x1934>
 9084f24:	200f883a 	mov	r7,r4
 9084f28:	0100370e 	bge	zero,r4,9085008 <___vfprintf_internal_r+0x1e60>
 9084f2c:	9800031e 	bne	r19,zero,9084f3c <___vfprintf_internal_r+0x1d94>
 9084f30:	d9814c17 	ldw	r6,1328(sp)
 9084f34:	3080004c 	andi	r2,r6,1
 9084f38:	103fb726 	beq	r2,zero,9084e18 <___vfprintf_internal_r+0x1c70>
 9084f3c:	20800044 	addi	r2,r4,1
 9084f40:	98a7883a 	add	r19,r19,r2
 9084f44:	dcc14515 	stw	r19,1300(sp)
 9084f48:	980f883a 	mov	r7,r19
 9084f4c:	983f800e 	bge	r19,zero,9084d50 <___vfprintf_internal_r+0x1ba8>
 9084f50:	003fb306 	br	9084e20 <___vfprintf_internal_r+0x1c78>
 9084f54:	d9814d17 	ldw	r6,1332(sp)
 9084f58:	31bfff84 	addi	r6,r6,-2
 9084f5c:	d9814d15 	stw	r6,1332(sp)
 9084f60:	003f4c06 	br	9084c94 <___vfprintf_internal_r+0x1aec>
 9084f64:	0100180e 	bge	zero,r4,9084fc8 <___vfprintf_internal_r+0x1e20>
 9084f68:	00800044 	movi	r2,1
 9084f6c:	1485883a 	add	r2,r2,r18
 9084f70:	d8814515 	stw	r2,1300(sp)
 9084f74:	100f883a 	mov	r7,r2
 9084f78:	103f750e 	bge	r2,zero,9084d50 <___vfprintf_internal_r+0x1ba8>
 9084f7c:	003fa806 	br	9084e20 <___vfprintf_internal_r+0x1c78>
 9084f80:	80c00c04 	addi	r3,r16,48
 9084f84:	00800c04 	movi	r2,48
 9084f88:	d8c008c5 	stb	r3,35(sp)
 9084f8c:	d9800804 	addi	r6,sp,32
 9084f90:	d8c00904 	addi	r3,sp,36
 9084f94:	d8800885 	stb	r2,34(sp)
 9084f98:	003f6506 	br	9084d30 <___vfprintf_internal_r+0x1b88>
 9084f9c:	d9014c17 	ldw	r4,1328(sp)
 9084fa0:	2084703a 	and	r2,r4,r2
 9084fa4:	103f9c26 	beq	r2,zero,9084e18 <___vfprintf_internal_r+0x1c70>
 9084fa8:	003f6606 	br	9084d44 <___vfprintf_internal_r+0x1b9c>
 9084fac:	d9800804 	addi	r6,sp,32
 9084fb0:	d8c00884 	addi	r3,sp,34
 9084fb4:	003f5e06 	br	9084d30 <___vfprintf_internal_r+0x1b88>
 9084fb8:	00800b44 	movi	r2,45
 9084fbc:	0121c83a 	sub	r16,zero,r4
 9084fc0:	d8800845 	stb	r2,33(sp)
 9084fc4:	003f3d06 	br	9084cbc <___vfprintf_internal_r+0x1b14>
 9084fc8:	00800084 	movi	r2,2
 9084fcc:	1105c83a 	sub	r2,r2,r4
 9084fd0:	003fe606 	br	9084f6c <___vfprintf_internal_r+0x1dc4>
 9084fd4:	d8014515 	stw	zero,1300(sp)
 9084fd8:	dc814715 	stw	r18,1308(sp)
 9084fdc:	003fb106 	br	9084ea4 <___vfprintf_internal_r+0x1cfc>
 9084fe0:	000d883a 	mov	r6,zero
 9084fe4:	000f883a 	mov	r7,zero
 9084fe8:	8009883a 	mov	r4,r16
 9084fec:	880b883a 	mov	r5,r17
 9084ff0:	908bc480 	call	908bc48 <__nedf2>
 9084ff4:	103f9f26 	beq	r2,zero,9084e74 <___vfprintf_internal_r+0x1ccc>
 9084ff8:	00800044 	movi	r2,1
 9084ffc:	1509c83a 	sub	r4,r2,r20
 9085000:	d9000515 	stw	r4,20(sp)
 9085004:	003f9b06 	br	9084e74 <___vfprintf_internal_r+0x1ccc>
 9085008:	98000d1e 	bne	r19,zero,9085040 <___vfprintf_internal_r+0x1e98>
 908500c:	d8c14c17 	ldw	r3,1328(sp)
 9085010:	1880004c 	andi	r2,r3,1
 9085014:	10000a1e 	bne	r2,zero,9085040 <___vfprintf_internal_r+0x1e98>
 9085018:	01000044 	movi	r4,1
 908501c:	200f883a 	mov	r7,r4
 9085020:	d9014515 	stw	r4,1300(sp)
 9085024:	003f4a06 	br	9084d50 <___vfprintf_internal_r+0x1ba8>
 9085028:	3cc00017 	ldw	r19,0(r7)
 908502c:	39c00104 	addi	r7,r7,4
 9085030:	983d0e0e 	bge	r19,zero,908446c <___vfprintf_internal_r+0x12c4>
 9085034:	b8c00007 	ldb	r3,0(r23)
 9085038:	04ffffc4 	movi	r19,-1
 908503c:	0038d906 	br	90833a4 <___vfprintf_internal_r+0x1fc>
 9085040:	9cc00084 	addi	r19,r19,2
 9085044:	dcc14515 	stw	r19,1300(sp)
 9085048:	980f883a 	mov	r7,r19
 908504c:	983f400e 	bge	r19,zero,9084d50 <___vfprintf_internal_r+0x1ba8>
 9085050:	003f7306 	br	9084e20 <___vfprintf_internal_r+0x1c78>

09085054 <__vfprintf_internal>:
 9085054:	00824374 	movhi	r2,2317
 9085058:	108b9b04 	addi	r2,r2,11884
 908505c:	2013883a 	mov	r9,r4
 9085060:	11000017 	ldw	r4,0(r2)
 9085064:	2805883a 	mov	r2,r5
 9085068:	300f883a 	mov	r7,r6
 908506c:	480b883a 	mov	r5,r9
 9085070:	100d883a 	mov	r6,r2
 9085074:	90831a81 	jmpi	90831a8 <___vfprintf_internal_r>

09085078 <__swbuf_r>:
 9085078:	defffc04 	addi	sp,sp,-16
 908507c:	dc400215 	stw	r17,8(sp)
 9085080:	dc000115 	stw	r16,4(sp)
 9085084:	dfc00315 	stw	ra,12(sp)
 9085088:	2023883a 	mov	r17,r4
 908508c:	2821883a 	mov	r16,r5
 9085090:	20000226 	beq	r4,zero,908509c <__swbuf_r+0x24>
 9085094:	20800e17 	ldw	r2,56(r4)
 9085098:	10002f26 	beq	r2,zero,9085158 <__swbuf_r+0xe0>
 908509c:	3080030b 	ldhu	r2,12(r6)
 90850a0:	30c00617 	ldw	r3,24(r6)
 90850a4:	1080020c 	andi	r2,r2,8
 90850a8:	30c00215 	stw	r3,8(r6)
 90850ac:	10002226 	beq	r2,zero,9085138 <__swbuf_r+0xc0>
 90850b0:	30c00417 	ldw	r3,16(r6)
 90850b4:	18002026 	beq	r3,zero,9085138 <__swbuf_r+0xc0>
 90850b8:	31000017 	ldw	r4,0(r6)
 90850bc:	30800517 	ldw	r2,20(r6)
 90850c0:	20c7c83a 	sub	r3,r4,r3
 90850c4:	18802f0e 	bge	r3,r2,9085184 <__swbuf_r+0x10c>
 90850c8:	19400044 	addi	r5,r3,1
 90850cc:	30800217 	ldw	r2,8(r6)
 90850d0:	84003fcc 	andi	r16,r16,255
 90850d4:	20c00044 	addi	r3,r4,1
 90850d8:	10bfffc4 	addi	r2,r2,-1
 90850dc:	30800215 	stw	r2,8(r6)
 90850e0:	24000005 	stb	r16,0(r4)
 90850e4:	30800517 	ldw	r2,20(r6)
 90850e8:	30c00015 	stw	r3,0(r6)
 90850ec:	11400c26 	beq	r2,r5,9085120 <__swbuf_r+0xa8>
 90850f0:	3080030b 	ldhu	r2,12(r6)
 90850f4:	1080004c 	andi	r2,r2,1
 90850f8:	1005003a 	cmpeq	r2,r2,zero
 90850fc:	10000626 	beq	r2,zero,9085118 <__swbuf_r+0xa0>
 9085100:	8005883a 	mov	r2,r16
 9085104:	dfc00317 	ldw	ra,12(sp)
 9085108:	dc400217 	ldw	r17,8(sp)
 908510c:	dc000117 	ldw	r16,4(sp)
 9085110:	dec00404 	addi	sp,sp,16
 9085114:	f800283a 	ret
 9085118:	00800284 	movi	r2,10
 908511c:	80bff81e 	bne	r16,r2,9085100 <__swbuf_r+0x88>
 9085120:	8809883a 	mov	r4,r17
 9085124:	300b883a 	mov	r5,r6
 9085128:	9086acc0 	call	9086acc <_fflush_r>
 908512c:	103ff426 	beq	r2,zero,9085100 <__swbuf_r+0x88>
 9085130:	043fffc4 	movi	r16,-1
 9085134:	003ff206 	br	9085100 <__swbuf_r+0x88>
 9085138:	300b883a 	mov	r5,r6
 908513c:	8809883a 	mov	r4,r17
 9085140:	d9800015 	stw	r6,0(sp)
 9085144:	90851c40 	call	90851c4 <__swsetup_r>
 9085148:	d9800017 	ldw	r6,0(sp)
 908514c:	1000061e 	bne	r2,zero,9085168 <__swbuf_r+0xf0>
 9085150:	30c00417 	ldw	r3,16(r6)
 9085154:	003fd806 	br	90850b8 <__swbuf_r+0x40>
 9085158:	d9800015 	stw	r6,0(sp)
 908515c:	9086d640 	call	9086d64 <__sinit>
 9085160:	d9800017 	ldw	r6,0(sp)
 9085164:	003fcd06 	br	908509c <__swbuf_r+0x24>
 9085168:	3080030b 	ldhu	r2,12(r6)
 908516c:	00c00244 	movi	r3,9
 9085170:	043fffc4 	movi	r16,-1
 9085174:	10801014 	ori	r2,r2,64
 9085178:	3080030d 	sth	r2,12(r6)
 908517c:	88c00015 	stw	r3,0(r17)
 9085180:	003fdf06 	br	9085100 <__swbuf_r+0x88>
 9085184:	300b883a 	mov	r5,r6
 9085188:	8809883a 	mov	r4,r17
 908518c:	d9800015 	stw	r6,0(sp)
 9085190:	9086acc0 	call	9086acc <_fflush_r>
 9085194:	d9800017 	ldw	r6,0(sp)
 9085198:	103fe51e 	bne	r2,zero,9085130 <__swbuf_r+0xb8>
 908519c:	31000017 	ldw	r4,0(r6)
 90851a0:	01400044 	movi	r5,1
 90851a4:	003fc906 	br	90850cc <__swbuf_r+0x54>

090851a8 <__swbuf>:
 90851a8:	01824374 	movhi	r6,2317
 90851ac:	318b9b04 	addi	r6,r6,11884
 90851b0:	2007883a 	mov	r3,r4
 90851b4:	31000017 	ldw	r4,0(r6)
 90851b8:	280d883a 	mov	r6,r5
 90851bc:	180b883a 	mov	r5,r3
 90851c0:	90850781 	jmpi	9085078 <__swbuf_r>

090851c4 <__swsetup_r>:
 90851c4:	00824374 	movhi	r2,2317
 90851c8:	108b9b04 	addi	r2,r2,11884
 90851cc:	10c00017 	ldw	r3,0(r2)
 90851d0:	defffd04 	addi	sp,sp,-12
 90851d4:	dc400115 	stw	r17,4(sp)
 90851d8:	dc000015 	stw	r16,0(sp)
 90851dc:	dfc00215 	stw	ra,8(sp)
 90851e0:	2023883a 	mov	r17,r4
 90851e4:	2821883a 	mov	r16,r5
 90851e8:	18000226 	beq	r3,zero,90851f4 <__swsetup_r+0x30>
 90851ec:	18800e17 	ldw	r2,56(r3)
 90851f0:	10001f26 	beq	r2,zero,9085270 <__swsetup_r+0xac>
 90851f4:	8100030b 	ldhu	r4,12(r16)
 90851f8:	2080020c 	andi	r2,r4,8
 90851fc:	10002826 	beq	r2,zero,90852a0 <__swsetup_r+0xdc>
 9085200:	81400417 	ldw	r5,16(r16)
 9085204:	28001d26 	beq	r5,zero,908527c <__swsetup_r+0xb8>
 9085208:	2080004c 	andi	r2,r4,1
 908520c:	1005003a 	cmpeq	r2,r2,zero
 9085210:	10000b26 	beq	r2,zero,9085240 <__swsetup_r+0x7c>
 9085214:	2080008c 	andi	r2,r4,2
 9085218:	10001226 	beq	r2,zero,9085264 <__swsetup_r+0xa0>
 908521c:	0005883a 	mov	r2,zero
 9085220:	80800215 	stw	r2,8(r16)
 9085224:	28000b26 	beq	r5,zero,9085254 <__swsetup_r+0x90>
 9085228:	0005883a 	mov	r2,zero
 908522c:	dfc00217 	ldw	ra,8(sp)
 9085230:	dc400117 	ldw	r17,4(sp)
 9085234:	dc000017 	ldw	r16,0(sp)
 9085238:	dec00304 	addi	sp,sp,12
 908523c:	f800283a 	ret
 9085240:	80800517 	ldw	r2,20(r16)
 9085244:	80000215 	stw	zero,8(r16)
 9085248:	0085c83a 	sub	r2,zero,r2
 908524c:	80800615 	stw	r2,24(r16)
 9085250:	283ff51e 	bne	r5,zero,9085228 <__swsetup_r+0x64>
 9085254:	2080200c 	andi	r2,r4,128
 9085258:	103ff326 	beq	r2,zero,9085228 <__swsetup_r+0x64>
 908525c:	00bfffc4 	movi	r2,-1
 9085260:	003ff206 	br	908522c <__swsetup_r+0x68>
 9085264:	80800517 	ldw	r2,20(r16)
 9085268:	80800215 	stw	r2,8(r16)
 908526c:	003fed06 	br	9085224 <__swsetup_r+0x60>
 9085270:	1809883a 	mov	r4,r3
 9085274:	9086d640 	call	9086d64 <__sinit>
 9085278:	003fde06 	br	90851f4 <__swsetup_r+0x30>
 908527c:	20c0a00c 	andi	r3,r4,640
 9085280:	00808004 	movi	r2,512
 9085284:	18bfe026 	beq	r3,r2,9085208 <__swsetup_r+0x44>
 9085288:	8809883a 	mov	r4,r17
 908528c:	800b883a 	mov	r5,r16
 9085290:	9087c280 	call	9087c28 <__smakebuf_r>
 9085294:	8100030b 	ldhu	r4,12(r16)
 9085298:	81400417 	ldw	r5,16(r16)
 908529c:	003fda06 	br	9085208 <__swsetup_r+0x44>
 90852a0:	2080040c 	andi	r2,r4,16
 90852a4:	103fed26 	beq	r2,zero,908525c <__swsetup_r+0x98>
 90852a8:	2080010c 	andi	r2,r4,4
 90852ac:	10001226 	beq	r2,zero,90852f8 <__swsetup_r+0x134>
 90852b0:	81400c17 	ldw	r5,48(r16)
 90852b4:	28000526 	beq	r5,zero,90852cc <__swsetup_r+0x108>
 90852b8:	80801004 	addi	r2,r16,64
 90852bc:	28800226 	beq	r5,r2,90852c8 <__swsetup_r+0x104>
 90852c0:	8809883a 	mov	r4,r17
 90852c4:	90872340 	call	9087234 <_free_r>
 90852c8:	80000c15 	stw	zero,48(r16)
 90852cc:	8080030b 	ldhu	r2,12(r16)
 90852d0:	81400417 	ldw	r5,16(r16)
 90852d4:	80000115 	stw	zero,4(r16)
 90852d8:	10bff6cc 	andi	r2,r2,65499
 90852dc:	8080030d 	sth	r2,12(r16)
 90852e0:	81400015 	stw	r5,0(r16)
 90852e4:	8080030b 	ldhu	r2,12(r16)
 90852e8:	10800214 	ori	r2,r2,8
 90852ec:	113fffcc 	andi	r4,r2,65535
 90852f0:	8080030d 	sth	r2,12(r16)
 90852f4:	003fc306 	br	9085204 <__swsetup_r+0x40>
 90852f8:	81400417 	ldw	r5,16(r16)
 90852fc:	003ff906 	br	90852e4 <__swsetup_r+0x120>

09085300 <quorem>:
 9085300:	28c00417 	ldw	r3,16(r5)
 9085304:	20800417 	ldw	r2,16(r4)
 9085308:	defff604 	addi	sp,sp,-40
 908530c:	ddc00715 	stw	r23,28(sp)
 9085310:	dd400515 	stw	r21,20(sp)
 9085314:	dfc00915 	stw	ra,36(sp)
 9085318:	df000815 	stw	fp,32(sp)
 908531c:	dd800615 	stw	r22,24(sp)
 9085320:	dd000415 	stw	r20,16(sp)
 9085324:	dcc00315 	stw	r19,12(sp)
 9085328:	dc800215 	stw	r18,8(sp)
 908532c:	dc400115 	stw	r17,4(sp)
 9085330:	dc000015 	stw	r16,0(sp)
 9085334:	202f883a 	mov	r23,r4
 9085338:	282b883a 	mov	r21,r5
 908533c:	10c07416 	blt	r2,r3,9085510 <quorem+0x210>
 9085340:	1c7fffc4 	addi	r17,r3,-1
 9085344:	8c45883a 	add	r2,r17,r17
 9085348:	1085883a 	add	r2,r2,r2
 908534c:	2c000504 	addi	r16,r5,20
 9085350:	24c00504 	addi	r19,r4,20
 9085354:	14ed883a 	add	r22,r2,r19
 9085358:	80a5883a 	add	r18,r16,r2
 908535c:	b7000017 	ldw	fp,0(r22)
 9085360:	91400017 	ldw	r5,0(r18)
 9085364:	e009883a 	mov	r4,fp
 9085368:	29400044 	addi	r5,r5,1
 908536c:	908c3080 	call	908c308 <__udivsi3>
 9085370:	1029883a 	mov	r20,r2
 9085374:	10003c1e 	bne	r2,zero,9085468 <quorem+0x168>
 9085378:	a80b883a 	mov	r5,r21
 908537c:	b809883a 	mov	r4,r23
 9085380:	908873c0 	call	908873c <__mcmp>
 9085384:	10002b16 	blt	r2,zero,9085434 <quorem+0x134>
 9085388:	a5000044 	addi	r20,r20,1
 908538c:	980f883a 	mov	r7,r19
 9085390:	0011883a 	mov	r8,zero
 9085394:	0009883a 	mov	r4,zero
 9085398:	81400017 	ldw	r5,0(r16)
 908539c:	38c00017 	ldw	r3,0(r7)
 90853a0:	84000104 	addi	r16,r16,4
 90853a4:	28bfffcc 	andi	r2,r5,65535
 90853a8:	2085883a 	add	r2,r4,r2
 90853ac:	11bfffcc 	andi	r6,r2,65535
 90853b0:	193fffcc 	andi	r4,r3,65535
 90853b4:	1004d43a 	srli	r2,r2,16
 90853b8:	280ad43a 	srli	r5,r5,16
 90853bc:	2189c83a 	sub	r4,r4,r6
 90853c0:	2209883a 	add	r4,r4,r8
 90853c4:	1806d43a 	srli	r3,r3,16
 90853c8:	288b883a 	add	r5,r5,r2
 90853cc:	200dd43a 	srai	r6,r4,16
 90853d0:	28bfffcc 	andi	r2,r5,65535
 90853d4:	1887c83a 	sub	r3,r3,r2
 90853d8:	1987883a 	add	r3,r3,r6
 90853dc:	3900000d 	sth	r4,0(r7)
 90853e0:	38c0008d 	sth	r3,2(r7)
 90853e4:	2808d43a 	srli	r4,r5,16
 90853e8:	39c00104 	addi	r7,r7,4
 90853ec:	1811d43a 	srai	r8,r3,16
 90853f0:	943fe92e 	bgeu	r18,r16,9085398 <quorem+0x98>
 90853f4:	8c45883a 	add	r2,r17,r17
 90853f8:	1085883a 	add	r2,r2,r2
 90853fc:	9885883a 	add	r2,r19,r2
 9085400:	10c00017 	ldw	r3,0(r2)
 9085404:	18000b1e 	bne	r3,zero,9085434 <quorem+0x134>
 9085408:	113fff04 	addi	r4,r2,-4
 908540c:	9900082e 	bgeu	r19,r4,9085430 <quorem+0x130>
 9085410:	10bfff17 	ldw	r2,-4(r2)
 9085414:	10000326 	beq	r2,zero,9085424 <quorem+0x124>
 9085418:	00000506 	br	9085430 <quorem+0x130>
 908541c:	20800017 	ldw	r2,0(r4)
 9085420:	1000031e 	bne	r2,zero,9085430 <quorem+0x130>
 9085424:	213fff04 	addi	r4,r4,-4
 9085428:	8c7fffc4 	addi	r17,r17,-1
 908542c:	993ffb36 	bltu	r19,r4,908541c <quorem+0x11c>
 9085430:	bc400415 	stw	r17,16(r23)
 9085434:	a005883a 	mov	r2,r20
 9085438:	dfc00917 	ldw	ra,36(sp)
 908543c:	df000817 	ldw	fp,32(sp)
 9085440:	ddc00717 	ldw	r23,28(sp)
 9085444:	dd800617 	ldw	r22,24(sp)
 9085448:	dd400517 	ldw	r21,20(sp)
 908544c:	dd000417 	ldw	r20,16(sp)
 9085450:	dcc00317 	ldw	r19,12(sp)
 9085454:	dc800217 	ldw	r18,8(sp)
 9085458:	dc400117 	ldw	r17,4(sp)
 908545c:	dc000017 	ldw	r16,0(sp)
 9085460:	dec00a04 	addi	sp,sp,40
 9085464:	f800283a 	ret
 9085468:	980f883a 	mov	r7,r19
 908546c:	8011883a 	mov	r8,r16
 9085470:	0013883a 	mov	r9,zero
 9085474:	000d883a 	mov	r6,zero
 9085478:	40c00017 	ldw	r3,0(r8)
 908547c:	39000017 	ldw	r4,0(r7)
 9085480:	42000104 	addi	r8,r8,4
 9085484:	18bfffcc 	andi	r2,r3,65535
 9085488:	a085383a 	mul	r2,r20,r2
 908548c:	1806d43a 	srli	r3,r3,16
 9085490:	217fffcc 	andi	r5,r4,65535
 9085494:	3085883a 	add	r2,r6,r2
 9085498:	11bfffcc 	andi	r6,r2,65535
 908549c:	a0c7383a 	mul	r3,r20,r3
 90854a0:	1004d43a 	srli	r2,r2,16
 90854a4:	298bc83a 	sub	r5,r5,r6
 90854a8:	2a4b883a 	add	r5,r5,r9
 90854ac:	2008d43a 	srli	r4,r4,16
 90854b0:	1887883a 	add	r3,r3,r2
 90854b4:	280dd43a 	srai	r6,r5,16
 90854b8:	18bfffcc 	andi	r2,r3,65535
 90854bc:	2089c83a 	sub	r4,r4,r2
 90854c0:	2189883a 	add	r4,r4,r6
 90854c4:	3900008d 	sth	r4,2(r7)
 90854c8:	3940000d 	sth	r5,0(r7)
 90854cc:	180cd43a 	srli	r6,r3,16
 90854d0:	39c00104 	addi	r7,r7,4
 90854d4:	2013d43a 	srai	r9,r4,16
 90854d8:	923fe72e 	bgeu	r18,r8,9085478 <quorem+0x178>
 90854dc:	e03fa61e 	bne	fp,zero,9085378 <quorem+0x78>
 90854e0:	b0ffff04 	addi	r3,r22,-4
 90854e4:	98c0082e 	bgeu	r19,r3,9085508 <quorem+0x208>
 90854e8:	b0bfff17 	ldw	r2,-4(r22)
 90854ec:	10000326 	beq	r2,zero,90854fc <quorem+0x1fc>
 90854f0:	00000506 	br	9085508 <quorem+0x208>
 90854f4:	18800017 	ldw	r2,0(r3)
 90854f8:	1000031e 	bne	r2,zero,9085508 <quorem+0x208>
 90854fc:	18ffff04 	addi	r3,r3,-4
 9085500:	8c7fffc4 	addi	r17,r17,-1
 9085504:	98fffb36 	bltu	r19,r3,90854f4 <quorem+0x1f4>
 9085508:	bc400415 	stw	r17,16(r23)
 908550c:	003f9a06 	br	9085378 <quorem+0x78>
 9085510:	0005883a 	mov	r2,zero
 9085514:	003fc806 	br	9085438 <quorem+0x138>

09085518 <_dtoa_r>:
 9085518:	22001017 	ldw	r8,64(r4)
 908551c:	deffda04 	addi	sp,sp,-152
 9085520:	dd402115 	stw	r21,132(sp)
 9085524:	dd002015 	stw	r20,128(sp)
 9085528:	dc801e15 	stw	r18,120(sp)
 908552c:	dc401d15 	stw	r17,116(sp)
 9085530:	dfc02515 	stw	ra,148(sp)
 9085534:	df002415 	stw	fp,144(sp)
 9085538:	ddc02315 	stw	r23,140(sp)
 908553c:	dd802215 	stw	r22,136(sp)
 9085540:	dcc01f15 	stw	r19,124(sp)
 9085544:	dc001c15 	stw	r16,112(sp)
 9085548:	d9001615 	stw	r4,88(sp)
 908554c:	3023883a 	mov	r17,r6
 9085550:	2829883a 	mov	r20,r5
 9085554:	d9c01715 	stw	r7,92(sp)
 9085558:	dc802817 	ldw	r18,160(sp)
 908555c:	302b883a 	mov	r21,r6
 9085560:	40000a26 	beq	r8,zero,908558c <_dtoa_r+0x74>
 9085564:	20801117 	ldw	r2,68(r4)
 9085568:	400b883a 	mov	r5,r8
 908556c:	40800115 	stw	r2,4(r8)
 9085570:	20c01117 	ldw	r3,68(r4)
 9085574:	00800044 	movi	r2,1
 9085578:	10c4983a 	sll	r2,r2,r3
 908557c:	40800215 	stw	r2,8(r8)
 9085580:	90885e00 	call	90885e0 <_Bfree>
 9085584:	d8c01617 	ldw	r3,88(sp)
 9085588:	18001015 	stw	zero,64(r3)
 908558c:	8800a316 	blt	r17,zero,908581c <_dtoa_r+0x304>
 9085590:	90000015 	stw	zero,0(r18)
 9085594:	a8dffc2c 	andhi	r3,r21,32752
 9085598:	009ffc34 	movhi	r2,32752
 908559c:	18809126 	beq	r3,r2,90857e4 <_dtoa_r+0x2cc>
 90855a0:	000d883a 	mov	r6,zero
 90855a4:	000f883a 	mov	r7,zero
 90855a8:	a009883a 	mov	r4,r20
 90855ac:	a80b883a 	mov	r5,r21
 90855b0:	dd001215 	stw	r20,72(sp)
 90855b4:	dd401315 	stw	r21,76(sp)
 90855b8:	908bc480 	call	908bc48 <__nedf2>
 90855bc:	1000171e 	bne	r2,zero,908561c <_dtoa_r+0x104>
 90855c0:	d9802717 	ldw	r6,156(sp)
 90855c4:	00800044 	movi	r2,1
 90855c8:	30800015 	stw	r2,0(r6)
 90855cc:	d8802917 	ldw	r2,164(sp)
 90855d0:	10029b26 	beq	r2,zero,9086040 <_dtoa_r+0xb28>
 90855d4:	d9002917 	ldw	r4,164(sp)
 90855d8:	00824374 	movhi	r2,2317
 90855dc:	10b28044 	addi	r2,r2,-13823
 90855e0:	10ffffc4 	addi	r3,r2,-1
 90855e4:	20800015 	stw	r2,0(r4)
 90855e8:	1805883a 	mov	r2,r3
 90855ec:	dfc02517 	ldw	ra,148(sp)
 90855f0:	df002417 	ldw	fp,144(sp)
 90855f4:	ddc02317 	ldw	r23,140(sp)
 90855f8:	dd802217 	ldw	r22,136(sp)
 90855fc:	dd402117 	ldw	r21,132(sp)
 9085600:	dd002017 	ldw	r20,128(sp)
 9085604:	dcc01f17 	ldw	r19,124(sp)
 9085608:	dc801e17 	ldw	r18,120(sp)
 908560c:	dc401d17 	ldw	r17,116(sp)
 9085610:	dc001c17 	ldw	r16,112(sp)
 9085614:	dec02604 	addi	sp,sp,152
 9085618:	f800283a 	ret
 908561c:	d9001617 	ldw	r4,88(sp)
 9085620:	d9401217 	ldw	r5,72(sp)
 9085624:	d8800104 	addi	r2,sp,4
 9085628:	a80d883a 	mov	r6,r21
 908562c:	d9c00204 	addi	r7,sp,8
 9085630:	d8800015 	stw	r2,0(sp)
 9085634:	9088c1c0 	call	9088c1c <__d2b>
 9085638:	d8800715 	stw	r2,28(sp)
 908563c:	a804d53a 	srli	r2,r21,20
 9085640:	1101ffcc 	andi	r4,r2,2047
 9085644:	20008626 	beq	r4,zero,9085860 <_dtoa_r+0x348>
 9085648:	d8c01217 	ldw	r3,72(sp)
 908564c:	00800434 	movhi	r2,16
 9085650:	10bfffc4 	addi	r2,r2,-1
 9085654:	ddc00117 	ldw	r23,4(sp)
 9085658:	a884703a 	and	r2,r21,r2
 908565c:	1811883a 	mov	r8,r3
 9085660:	124ffc34 	orhi	r9,r2,16368
 9085664:	25bf0044 	addi	r22,r4,-1023
 9085668:	d8000815 	stw	zero,32(sp)
 908566c:	0005883a 	mov	r2,zero
 9085670:	00cffe34 	movhi	r3,16376
 9085674:	480b883a 	mov	r5,r9
 9085678:	4009883a 	mov	r4,r8
 908567c:	180f883a 	mov	r7,r3
 9085680:	100d883a 	mov	r6,r2
 9085684:	908b4c00 	call	908b4c0 <__subdf3>
 9085688:	0218dbf4 	movhi	r8,25455
 908568c:	4210d844 	addi	r8,r8,17249
 9085690:	024ff4f4 	movhi	r9,16339
 9085694:	4a61e9c4 	addi	r9,r9,-30809
 9085698:	480f883a 	mov	r7,r9
 908569c:	400d883a 	mov	r6,r8
 90856a0:	180b883a 	mov	r5,r3
 90856a4:	1009883a 	mov	r4,r2
 90856a8:	908b5b40 	call	908b5b4 <__muldf3>
 90856ac:	0222d874 	movhi	r8,35681
 90856b0:	42322cc4 	addi	r8,r8,-14157
 90856b4:	024ff1f4 	movhi	r9,16327
 90856b8:	4a628a04 	addi	r9,r9,-30168
 90856bc:	480f883a 	mov	r7,r9
 90856c0:	400d883a 	mov	r6,r8
 90856c4:	180b883a 	mov	r5,r3
 90856c8:	1009883a 	mov	r4,r2
 90856cc:	908b5400 	call	908b540 <__adddf3>
 90856d0:	b009883a 	mov	r4,r22
 90856d4:	1021883a 	mov	r16,r2
 90856d8:	1823883a 	mov	r17,r3
 90856dc:	908be680 	call	908be68 <__floatsidf>
 90856e0:	021427f4 	movhi	r8,20639
 90856e4:	421e7ec4 	addi	r8,r8,31227
 90856e8:	024ff4f4 	movhi	r9,16339
 90856ec:	4a5104c4 	addi	r9,r9,17427
 90856f0:	480f883a 	mov	r7,r9
 90856f4:	400d883a 	mov	r6,r8
 90856f8:	180b883a 	mov	r5,r3
 90856fc:	1009883a 	mov	r4,r2
 9085700:	908b5b40 	call	908b5b4 <__muldf3>
 9085704:	180f883a 	mov	r7,r3
 9085708:	880b883a 	mov	r5,r17
 908570c:	100d883a 	mov	r6,r2
 9085710:	8009883a 	mov	r4,r16
 9085714:	908b5400 	call	908b540 <__adddf3>
 9085718:	1009883a 	mov	r4,r2
 908571c:	180b883a 	mov	r5,r3
 9085720:	1021883a 	mov	r16,r2
 9085724:	1823883a 	mov	r17,r3
 9085728:	908bf600 	call	908bf60 <__fixdfsi>
 908572c:	000d883a 	mov	r6,zero
 9085730:	000f883a 	mov	r7,zero
 9085734:	8009883a 	mov	r4,r16
 9085738:	880b883a 	mov	r5,r17
 908573c:	d8800d15 	stw	r2,52(sp)
 9085740:	908bde00 	call	908bde0 <__ltdf2>
 9085744:	10031716 	blt	r2,zero,90863a4 <_dtoa_r+0xe8c>
 9085748:	d8c00d17 	ldw	r3,52(sp)
 908574c:	00800584 	movi	r2,22
 9085750:	10c1482e 	bgeu	r2,r3,9085c74 <_dtoa_r+0x75c>
 9085754:	01000044 	movi	r4,1
 9085758:	d9000c15 	stw	r4,48(sp)
 908575c:	bd85c83a 	sub	r2,r23,r22
 9085760:	11bfffc4 	addi	r6,r2,-1
 9085764:	30030b16 	blt	r6,zero,9086394 <_dtoa_r+0xe7c>
 9085768:	d9800a15 	stw	r6,40(sp)
 908576c:	d8001115 	stw	zero,68(sp)
 9085770:	d8c00d17 	ldw	r3,52(sp)
 9085774:	1802ff16 	blt	r3,zero,9086374 <_dtoa_r+0xe5c>
 9085778:	d9000a17 	ldw	r4,40(sp)
 908577c:	d8c00915 	stw	r3,36(sp)
 9085780:	d8001015 	stw	zero,64(sp)
 9085784:	20c9883a 	add	r4,r4,r3
 9085788:	d9000a15 	stw	r4,40(sp)
 908578c:	d9001717 	ldw	r4,92(sp)
 9085790:	00800244 	movi	r2,9
 9085794:	11004636 	bltu	r2,r4,90858b0 <_dtoa_r+0x398>
 9085798:	00800144 	movi	r2,5
 908579c:	11020416 	blt	r2,r4,9085fb0 <_dtoa_r+0xa98>
 90857a0:	04400044 	movi	r17,1
 90857a4:	d8c01717 	ldw	r3,92(sp)
 90857a8:	00800144 	movi	r2,5
 90857ac:	10c1ed36 	bltu	r2,r3,9085f64 <_dtoa_r+0xa4c>
 90857b0:	18c5883a 	add	r2,r3,r3
 90857b4:	1085883a 	add	r2,r2,r2
 90857b8:	00c24234 	movhi	r3,2312
 90857bc:	18d5f304 	addi	r3,r3,22476
 90857c0:	10c5883a 	add	r2,r2,r3
 90857c4:	11000017 	ldw	r4,0(r2)
 90857c8:	2000683a 	jmp	r4
 90857cc:	090858b8 	rdprs	r4,at,8546
 90857d0:	090858b8 	rdprs	r4,at,8546
 90857d4:	090862b8 	rdprs	r4,at,8586
 90857d8:	09086290 	cmplti	r4,at,8586
 90857dc:	090862d4 	ori	r4,at,8587
 90857e0:	090862e0 	cmpeqi	r4,at,8587
 90857e4:	d9002717 	ldw	r4,156(sp)
 90857e8:	0089c3c4 	movi	r2,9999
 90857ec:	20800015 	stw	r2,0(r4)
 90857f0:	a0001026 	beq	r20,zero,9085834 <_dtoa_r+0x31c>
 90857f4:	00c24374 	movhi	r3,2317
 90857f8:	18f28c04 	addi	r3,r3,-13776
 90857fc:	d9802917 	ldw	r6,164(sp)
 9085800:	303f7926 	beq	r6,zero,90855e8 <_dtoa_r+0xd0>
 9085804:	188000c7 	ldb	r2,3(r3)
 9085808:	190000c4 	addi	r4,r3,3
 908580c:	1000101e 	bne	r2,zero,9085850 <_dtoa_r+0x338>
 9085810:	d8802917 	ldw	r2,164(sp)
 9085814:	11000015 	stw	r4,0(r2)
 9085818:	003f7306 	br	90855e8 <_dtoa_r+0xd0>
 908581c:	00a00034 	movhi	r2,32768
 9085820:	10bfffc4 	addi	r2,r2,-1
 9085824:	00c00044 	movi	r3,1
 9085828:	88aa703a 	and	r21,r17,r2
 908582c:	90c00015 	stw	r3,0(r18)
 9085830:	003f5806 	br	9085594 <_dtoa_r+0x7c>
 9085834:	00800434 	movhi	r2,16
 9085838:	10bfffc4 	addi	r2,r2,-1
 908583c:	a884703a 	and	r2,r21,r2
 9085840:	103fec1e 	bne	r2,zero,90857f4 <_dtoa_r+0x2dc>
 9085844:	00c24374 	movhi	r3,2317
 9085848:	18f28904 	addi	r3,r3,-13788
 908584c:	003feb06 	br	90857fc <_dtoa_r+0x2e4>
 9085850:	d8802917 	ldw	r2,164(sp)
 9085854:	19000204 	addi	r4,r3,8
 9085858:	11000015 	stw	r4,0(r2)
 908585c:	003f6206 	br	90855e8 <_dtoa_r+0xd0>
 9085860:	ddc00117 	ldw	r23,4(sp)
 9085864:	d8800217 	ldw	r2,8(sp)
 9085868:	01000804 	movi	r4,32
 908586c:	b8c10c84 	addi	r3,r23,1074
 9085870:	18a3883a 	add	r17,r3,r2
 9085874:	2441b80e 	bge	r4,r17,9085f58 <_dtoa_r+0xa40>
 9085878:	00c01004 	movi	r3,64
 908587c:	1c47c83a 	sub	r3,r3,r17
 9085880:	88bff804 	addi	r2,r17,-32
 9085884:	a8c6983a 	sll	r3,r21,r3
 9085888:	a084d83a 	srl	r2,r20,r2
 908588c:	1888b03a 	or	r4,r3,r2
 9085890:	908c0380 	call	908c038 <__floatunsidf>
 9085894:	1011883a 	mov	r8,r2
 9085898:	00bf8434 	movhi	r2,65040
 908589c:	01000044 	movi	r4,1
 90858a0:	10d3883a 	add	r9,r2,r3
 90858a4:	8dbef344 	addi	r22,r17,-1075
 90858a8:	d9000815 	stw	r4,32(sp)
 90858ac:	003f6f06 	br	908566c <_dtoa_r+0x154>
 90858b0:	d8001715 	stw	zero,92(sp)
 90858b4:	04400044 	movi	r17,1
 90858b8:	00bfffc4 	movi	r2,-1
 90858bc:	00c00044 	movi	r3,1
 90858c0:	d8800e15 	stw	r2,56(sp)
 90858c4:	d8002615 	stw	zero,152(sp)
 90858c8:	d8800f15 	stw	r2,60(sp)
 90858cc:	d8c00b15 	stw	r3,44(sp)
 90858d0:	1021883a 	mov	r16,r2
 90858d4:	d8801617 	ldw	r2,88(sp)
 90858d8:	10001115 	stw	zero,68(r2)
 90858dc:	d8801617 	ldw	r2,88(sp)
 90858e0:	11401117 	ldw	r5,68(r2)
 90858e4:	1009883a 	mov	r4,r2
 90858e8:	9088b600 	call	9088b60 <_Balloc>
 90858ec:	d8c01617 	ldw	r3,88(sp)
 90858f0:	d8800515 	stw	r2,20(sp)
 90858f4:	18801015 	stw	r2,64(r3)
 90858f8:	00800384 	movi	r2,14
 90858fc:	14006836 	bltu	r2,r16,9085aa0 <_dtoa_r+0x588>
 9085900:	8805003a 	cmpeq	r2,r17,zero
 9085904:	1000661e 	bne	r2,zero,9085aa0 <_dtoa_r+0x588>
 9085908:	d9000d17 	ldw	r4,52(sp)
 908590c:	0102300e 	bge	zero,r4,90861d0 <_dtoa_r+0xcb8>
 9085910:	208003cc 	andi	r2,r4,15
 9085914:	100490fa 	slli	r2,r2,3
 9085918:	2025d13a 	srai	r18,r4,4
 908591c:	00c24374 	movhi	r3,2317
 9085920:	18f29d04 	addi	r3,r3,-13708
 9085924:	10c5883a 	add	r2,r2,r3
 9085928:	90c0040c 	andi	r3,r18,16
 908592c:	14000017 	ldw	r16,0(r2)
 9085930:	14400117 	ldw	r17,4(r2)
 9085934:	18036a1e 	bne	r3,zero,90866e0 <_dtoa_r+0x11c8>
 9085938:	05800084 	movi	r22,2
 908593c:	90001026 	beq	r18,zero,9085980 <_dtoa_r+0x468>
 9085940:	04c24374 	movhi	r19,2317
 9085944:	9cf2cf04 	addi	r19,r19,-13508
 9085948:	9080004c 	andi	r2,r18,1
 908594c:	1005003a 	cmpeq	r2,r2,zero
 9085950:	1000081e 	bne	r2,zero,9085974 <_dtoa_r+0x45c>
 9085954:	99800017 	ldw	r6,0(r19)
 9085958:	99c00117 	ldw	r7,4(r19)
 908595c:	880b883a 	mov	r5,r17
 9085960:	8009883a 	mov	r4,r16
 9085964:	908b5b40 	call	908b5b4 <__muldf3>
 9085968:	1021883a 	mov	r16,r2
 908596c:	b5800044 	addi	r22,r22,1
 9085970:	1823883a 	mov	r17,r3
 9085974:	9025d07a 	srai	r18,r18,1
 9085978:	9cc00204 	addi	r19,r19,8
 908597c:	903ff21e 	bne	r18,zero,9085948 <_dtoa_r+0x430>
 9085980:	a80b883a 	mov	r5,r21
 9085984:	a009883a 	mov	r4,r20
 9085988:	880f883a 	mov	r7,r17
 908598c:	800d883a 	mov	r6,r16
 9085990:	908b9680 	call	908b968 <__divdf3>
 9085994:	1029883a 	mov	r20,r2
 9085998:	182b883a 	mov	r21,r3
 908599c:	d8c00c17 	ldw	r3,48(sp)
 90859a0:	1805003a 	cmpeq	r2,r3,zero
 90859a4:	1000081e 	bne	r2,zero,90859c8 <_dtoa_r+0x4b0>
 90859a8:	0005883a 	mov	r2,zero
 90859ac:	00cffc34 	movhi	r3,16368
 90859b0:	180f883a 	mov	r7,r3
 90859b4:	a009883a 	mov	r4,r20
 90859b8:	a80b883a 	mov	r5,r21
 90859bc:	100d883a 	mov	r6,r2
 90859c0:	908bde00 	call	908bde0 <__ltdf2>
 90859c4:	1003fe16 	blt	r2,zero,90869c0 <_dtoa_r+0x14a8>
 90859c8:	b009883a 	mov	r4,r22
 90859cc:	908be680 	call	908be68 <__floatsidf>
 90859d0:	180b883a 	mov	r5,r3
 90859d4:	1009883a 	mov	r4,r2
 90859d8:	a00d883a 	mov	r6,r20
 90859dc:	a80f883a 	mov	r7,r21
 90859e0:	908b5b40 	call	908b5b4 <__muldf3>
 90859e4:	0011883a 	mov	r8,zero
 90859e8:	02500734 	movhi	r9,16412
 90859ec:	1009883a 	mov	r4,r2
 90859f0:	180b883a 	mov	r5,r3
 90859f4:	480f883a 	mov	r7,r9
 90859f8:	400d883a 	mov	r6,r8
 90859fc:	908b5400 	call	908b540 <__adddf3>
 9085a00:	d9000f17 	ldw	r4,60(sp)
 9085a04:	102d883a 	mov	r22,r2
 9085a08:	00bf3034 	movhi	r2,64704
 9085a0c:	18b9883a 	add	fp,r3,r2
 9085a10:	e02f883a 	mov	r23,fp
 9085a14:	20028f1e 	bne	r4,zero,9086454 <_dtoa_r+0xf3c>
 9085a18:	0005883a 	mov	r2,zero
 9085a1c:	00d00534 	movhi	r3,16404
 9085a20:	a009883a 	mov	r4,r20
 9085a24:	a80b883a 	mov	r5,r21
 9085a28:	180f883a 	mov	r7,r3
 9085a2c:	100d883a 	mov	r6,r2
 9085a30:	908b4c00 	call	908b4c0 <__subdf3>
 9085a34:	1009883a 	mov	r4,r2
 9085a38:	e00f883a 	mov	r7,fp
 9085a3c:	180b883a 	mov	r5,r3
 9085a40:	b00d883a 	mov	r6,r22
 9085a44:	1025883a 	mov	r18,r2
 9085a48:	1827883a 	mov	r19,r3
 9085a4c:	908bcd00 	call	908bcd0 <__gtdf2>
 9085a50:	00834f16 	blt	zero,r2,9086790 <_dtoa_r+0x1278>
 9085a54:	e0e0003c 	xorhi	r3,fp,32768
 9085a58:	9009883a 	mov	r4,r18
 9085a5c:	980b883a 	mov	r5,r19
 9085a60:	180f883a 	mov	r7,r3
 9085a64:	b00d883a 	mov	r6,r22
 9085a68:	908bde00 	call	908bde0 <__ltdf2>
 9085a6c:	1000080e 	bge	r2,zero,9085a90 <_dtoa_r+0x578>
 9085a70:	0027883a 	mov	r19,zero
 9085a74:	0025883a 	mov	r18,zero
 9085a78:	d8802617 	ldw	r2,152(sp)
 9085a7c:	df000517 	ldw	fp,20(sp)
 9085a80:	d8000615 	stw	zero,24(sp)
 9085a84:	0084303a 	nor	r2,zero,r2
 9085a88:	d8800d15 	stw	r2,52(sp)
 9085a8c:	00019b06 	br	90860fc <_dtoa_r+0xbe4>
 9085a90:	d9801217 	ldw	r6,72(sp)
 9085a94:	d8801317 	ldw	r2,76(sp)
 9085a98:	3029883a 	mov	r20,r6
 9085a9c:	102b883a 	mov	r21,r2
 9085aa0:	d8c00217 	ldw	r3,8(sp)
 9085aa4:	18008516 	blt	r3,zero,9085cbc <_dtoa_r+0x7a4>
 9085aa8:	d9000d17 	ldw	r4,52(sp)
 9085aac:	00800384 	movi	r2,14
 9085ab0:	11008216 	blt	r2,r4,9085cbc <_dtoa_r+0x7a4>
 9085ab4:	200490fa 	slli	r2,r4,3
 9085ab8:	d9802617 	ldw	r6,152(sp)
 9085abc:	00c24374 	movhi	r3,2317
 9085ac0:	18f29d04 	addi	r3,r3,-13708
 9085ac4:	10c5883a 	add	r2,r2,r3
 9085ac8:	14800017 	ldw	r18,0(r2)
 9085acc:	14c00117 	ldw	r19,4(r2)
 9085ad0:	30031e16 	blt	r6,zero,908674c <_dtoa_r+0x1234>
 9085ad4:	d9000517 	ldw	r4,20(sp)
 9085ad8:	d8c00f17 	ldw	r3,60(sp)
 9085adc:	a823883a 	mov	r17,r21
 9085ae0:	a021883a 	mov	r16,r20
 9085ae4:	192b883a 	add	r21,r3,r4
 9085ae8:	2039883a 	mov	fp,r4
 9085aec:	00000f06 	br	9085b2c <_dtoa_r+0x614>
 9085af0:	0005883a 	mov	r2,zero
 9085af4:	00d00934 	movhi	r3,16420
 9085af8:	5009883a 	mov	r4,r10
 9085afc:	580b883a 	mov	r5,r11
 9085b00:	180f883a 	mov	r7,r3
 9085b04:	100d883a 	mov	r6,r2
 9085b08:	908b5b40 	call	908b5b4 <__muldf3>
 9085b0c:	180b883a 	mov	r5,r3
 9085b10:	000d883a 	mov	r6,zero
 9085b14:	000f883a 	mov	r7,zero
 9085b18:	1009883a 	mov	r4,r2
 9085b1c:	1021883a 	mov	r16,r2
 9085b20:	1823883a 	mov	r17,r3
 9085b24:	908bc480 	call	908bc48 <__nedf2>
 9085b28:	10004526 	beq	r2,zero,9085c40 <_dtoa_r+0x728>
 9085b2c:	900d883a 	mov	r6,r18
 9085b30:	980f883a 	mov	r7,r19
 9085b34:	8009883a 	mov	r4,r16
 9085b38:	880b883a 	mov	r5,r17
 9085b3c:	908b9680 	call	908b968 <__divdf3>
 9085b40:	180b883a 	mov	r5,r3
 9085b44:	1009883a 	mov	r4,r2
 9085b48:	908bf600 	call	908bf60 <__fixdfsi>
 9085b4c:	1009883a 	mov	r4,r2
 9085b50:	1029883a 	mov	r20,r2
 9085b54:	908be680 	call	908be68 <__floatsidf>
 9085b58:	180f883a 	mov	r7,r3
 9085b5c:	9009883a 	mov	r4,r18
 9085b60:	980b883a 	mov	r5,r19
 9085b64:	100d883a 	mov	r6,r2
 9085b68:	908b5b40 	call	908b5b4 <__muldf3>
 9085b6c:	180f883a 	mov	r7,r3
 9085b70:	880b883a 	mov	r5,r17
 9085b74:	8009883a 	mov	r4,r16
 9085b78:	100d883a 	mov	r6,r2
 9085b7c:	908b4c00 	call	908b4c0 <__subdf3>
 9085b80:	1015883a 	mov	r10,r2
 9085b84:	a0800c04 	addi	r2,r20,48
 9085b88:	e0800005 	stb	r2,0(fp)
 9085b8c:	e7000044 	addi	fp,fp,1
 9085b90:	1817883a 	mov	r11,r3
 9085b94:	e57fd61e 	bne	fp,r21,9085af0 <_dtoa_r+0x5d8>
 9085b98:	500d883a 	mov	r6,r10
 9085b9c:	180f883a 	mov	r7,r3
 9085ba0:	5009883a 	mov	r4,r10
 9085ba4:	180b883a 	mov	r5,r3
 9085ba8:	908b5400 	call	908b540 <__adddf3>
 9085bac:	100d883a 	mov	r6,r2
 9085bb0:	9009883a 	mov	r4,r18
 9085bb4:	980b883a 	mov	r5,r19
 9085bb8:	180f883a 	mov	r7,r3
 9085bbc:	1021883a 	mov	r16,r2
 9085bc0:	1823883a 	mov	r17,r3
 9085bc4:	908bde00 	call	908bde0 <__ltdf2>
 9085bc8:	10000816 	blt	r2,zero,9085bec <_dtoa_r+0x6d4>
 9085bcc:	980b883a 	mov	r5,r19
 9085bd0:	800d883a 	mov	r6,r16
 9085bd4:	880f883a 	mov	r7,r17
 9085bd8:	9009883a 	mov	r4,r18
 9085bdc:	908bbc00 	call	908bbc0 <__eqdf2>
 9085be0:	1000171e 	bne	r2,zero,9085c40 <_dtoa_r+0x728>
 9085be4:	a080004c 	andi	r2,r20,1
 9085be8:	10001526 	beq	r2,zero,9085c40 <_dtoa_r+0x728>
 9085bec:	d8800d17 	ldw	r2,52(sp)
 9085bf0:	d8800415 	stw	r2,16(sp)
 9085bf4:	e009883a 	mov	r4,fp
 9085bf8:	213fffc4 	addi	r4,r4,-1
 9085bfc:	20c00007 	ldb	r3,0(r4)
 9085c00:	00800e44 	movi	r2,57
 9085c04:	1880081e 	bne	r3,r2,9085c28 <_dtoa_r+0x710>
 9085c08:	d8800517 	ldw	r2,20(sp)
 9085c0c:	113ffa1e 	bne	r2,r4,9085bf8 <_dtoa_r+0x6e0>
 9085c10:	d8c00417 	ldw	r3,16(sp)
 9085c14:	d9800517 	ldw	r6,20(sp)
 9085c18:	00800c04 	movi	r2,48
 9085c1c:	18c00044 	addi	r3,r3,1
 9085c20:	d8c00415 	stw	r3,16(sp)
 9085c24:	30800005 	stb	r2,0(r6)
 9085c28:	20800003 	ldbu	r2,0(r4)
 9085c2c:	d8c00417 	ldw	r3,16(sp)
 9085c30:	27000044 	addi	fp,r4,1
 9085c34:	10800044 	addi	r2,r2,1
 9085c38:	d8c00d15 	stw	r3,52(sp)
 9085c3c:	20800005 	stb	r2,0(r4)
 9085c40:	d9001617 	ldw	r4,88(sp)
 9085c44:	d9400717 	ldw	r5,28(sp)
 9085c48:	90885e00 	call	90885e0 <_Bfree>
 9085c4c:	e0000005 	stb	zero,0(fp)
 9085c50:	d9800d17 	ldw	r6,52(sp)
 9085c54:	d8c02717 	ldw	r3,156(sp)
 9085c58:	d9002917 	ldw	r4,164(sp)
 9085c5c:	30800044 	addi	r2,r6,1
 9085c60:	18800015 	stw	r2,0(r3)
 9085c64:	20029c26 	beq	r4,zero,90866d8 <_dtoa_r+0x11c0>
 9085c68:	d8c00517 	ldw	r3,20(sp)
 9085c6c:	27000015 	stw	fp,0(r4)
 9085c70:	003e5d06 	br	90855e8 <_dtoa_r+0xd0>
 9085c74:	d9800d17 	ldw	r6,52(sp)
 9085c78:	00c24374 	movhi	r3,2317
 9085c7c:	18f29d04 	addi	r3,r3,-13708
 9085c80:	d9001217 	ldw	r4,72(sp)
 9085c84:	300490fa 	slli	r2,r6,3
 9085c88:	d9401317 	ldw	r5,76(sp)
 9085c8c:	10c5883a 	add	r2,r2,r3
 9085c90:	12000017 	ldw	r8,0(r2)
 9085c94:	12400117 	ldw	r9,4(r2)
 9085c98:	400d883a 	mov	r6,r8
 9085c9c:	480f883a 	mov	r7,r9
 9085ca0:	908bde00 	call	908bde0 <__ltdf2>
 9085ca4:	1000030e 	bge	r2,zero,9085cb4 <_dtoa_r+0x79c>
 9085ca8:	d8800d17 	ldw	r2,52(sp)
 9085cac:	10bfffc4 	addi	r2,r2,-1
 9085cb0:	d8800d15 	stw	r2,52(sp)
 9085cb4:	d8000c15 	stw	zero,48(sp)
 9085cb8:	003ea806 	br	908575c <_dtoa_r+0x244>
 9085cbc:	d9000b17 	ldw	r4,44(sp)
 9085cc0:	202cc03a 	cmpne	r22,r4,zero
 9085cc4:	b000c71e 	bne	r22,zero,9085fe4 <_dtoa_r+0xacc>
 9085cc8:	dc001117 	ldw	r16,68(sp)
 9085ccc:	dc801017 	ldw	r18,64(sp)
 9085cd0:	0027883a 	mov	r19,zero
 9085cd4:	04000b0e 	bge	zero,r16,9085d04 <_dtoa_r+0x7ec>
 9085cd8:	d8c00a17 	ldw	r3,40(sp)
 9085cdc:	00c0090e 	bge	zero,r3,9085d04 <_dtoa_r+0x7ec>
 9085ce0:	8005883a 	mov	r2,r16
 9085ce4:	1c011316 	blt	r3,r16,9086134 <_dtoa_r+0xc1c>
 9085ce8:	d9000a17 	ldw	r4,40(sp)
 9085cec:	d9801117 	ldw	r6,68(sp)
 9085cf0:	80a1c83a 	sub	r16,r16,r2
 9085cf4:	2089c83a 	sub	r4,r4,r2
 9085cf8:	308dc83a 	sub	r6,r6,r2
 9085cfc:	d9000a15 	stw	r4,40(sp)
 9085d00:	d9801115 	stw	r6,68(sp)
 9085d04:	d8801017 	ldw	r2,64(sp)
 9085d08:	0080150e 	bge	zero,r2,9085d60 <_dtoa_r+0x848>
 9085d0c:	d8c00b17 	ldw	r3,44(sp)
 9085d10:	1805003a 	cmpeq	r2,r3,zero
 9085d14:	1001c91e 	bne	r2,zero,908643c <_dtoa_r+0xf24>
 9085d18:	04800e0e 	bge	zero,r18,9085d54 <_dtoa_r+0x83c>
 9085d1c:	d9001617 	ldw	r4,88(sp)
 9085d20:	980b883a 	mov	r5,r19
 9085d24:	900d883a 	mov	r6,r18
 9085d28:	90893940 	call	9089394 <__pow5mult>
 9085d2c:	d9001617 	ldw	r4,88(sp)
 9085d30:	d9800717 	ldw	r6,28(sp)
 9085d34:	100b883a 	mov	r5,r2
 9085d38:	1027883a 	mov	r19,r2
 9085d3c:	90890700 	call	9089070 <__multiply>
 9085d40:	d9001617 	ldw	r4,88(sp)
 9085d44:	d9400717 	ldw	r5,28(sp)
 9085d48:	1023883a 	mov	r17,r2
 9085d4c:	90885e00 	call	90885e0 <_Bfree>
 9085d50:	dc400715 	stw	r17,28(sp)
 9085d54:	d9001017 	ldw	r4,64(sp)
 9085d58:	248dc83a 	sub	r6,r4,r18
 9085d5c:	30010e1e 	bne	r6,zero,9086198 <_dtoa_r+0xc80>
 9085d60:	d9001617 	ldw	r4,88(sp)
 9085d64:	04400044 	movi	r17,1
 9085d68:	880b883a 	mov	r5,r17
 9085d6c:	90892580 	call	9089258 <__i2b>
 9085d70:	d9800917 	ldw	r6,36(sp)
 9085d74:	1025883a 	mov	r18,r2
 9085d78:	0180040e 	bge	zero,r6,9085d8c <_dtoa_r+0x874>
 9085d7c:	d9001617 	ldw	r4,88(sp)
 9085d80:	100b883a 	mov	r5,r2
 9085d84:	90893940 	call	9089394 <__pow5mult>
 9085d88:	1025883a 	mov	r18,r2
 9085d8c:	d8801717 	ldw	r2,92(sp)
 9085d90:	8880f30e 	bge	r17,r2,9086160 <_dtoa_r+0xc48>
 9085d94:	0023883a 	mov	r17,zero
 9085d98:	d9800917 	ldw	r6,36(sp)
 9085d9c:	30019e1e 	bne	r6,zero,9086418 <_dtoa_r+0xf00>
 9085da0:	00c00044 	movi	r3,1
 9085da4:	d9000a17 	ldw	r4,40(sp)
 9085da8:	20c5883a 	add	r2,r4,r3
 9085dac:	10c007cc 	andi	r3,r2,31
 9085db0:	1800841e 	bne	r3,zero,9085fc4 <_dtoa_r+0xaac>
 9085db4:	00800704 	movi	r2,28
 9085db8:	d9000a17 	ldw	r4,40(sp)
 9085dbc:	d9801117 	ldw	r6,68(sp)
 9085dc0:	80a1883a 	add	r16,r16,r2
 9085dc4:	2089883a 	add	r4,r4,r2
 9085dc8:	308d883a 	add	r6,r6,r2
 9085dcc:	d9000a15 	stw	r4,40(sp)
 9085dd0:	d9801115 	stw	r6,68(sp)
 9085dd4:	d8801117 	ldw	r2,68(sp)
 9085dd8:	0080050e 	bge	zero,r2,9085df0 <_dtoa_r+0x8d8>
 9085ddc:	d9400717 	ldw	r5,28(sp)
 9085de0:	d9001617 	ldw	r4,88(sp)
 9085de4:	100d883a 	mov	r6,r2
 9085de8:	9088f240 	call	9088f24 <__lshift>
 9085dec:	d8800715 	stw	r2,28(sp)
 9085df0:	d8c00a17 	ldw	r3,40(sp)
 9085df4:	00c0050e 	bge	zero,r3,9085e0c <_dtoa_r+0x8f4>
 9085df8:	d9001617 	ldw	r4,88(sp)
 9085dfc:	900b883a 	mov	r5,r18
 9085e00:	180d883a 	mov	r6,r3
 9085e04:	9088f240 	call	9088f24 <__lshift>
 9085e08:	1025883a 	mov	r18,r2
 9085e0c:	d9000c17 	ldw	r4,48(sp)
 9085e10:	2005003a 	cmpeq	r2,r4,zero
 9085e14:	10016f26 	beq	r2,zero,90863d4 <_dtoa_r+0xebc>
 9085e18:	d9000f17 	ldw	r4,60(sp)
 9085e1c:	0102170e 	bge	zero,r4,908667c <_dtoa_r+0x1164>
 9085e20:	d9800b17 	ldw	r6,44(sp)
 9085e24:	3005003a 	cmpeq	r2,r6,zero
 9085e28:	1000881e 	bne	r2,zero,908604c <_dtoa_r+0xb34>
 9085e2c:	0400050e 	bge	zero,r16,9085e44 <_dtoa_r+0x92c>
 9085e30:	d9001617 	ldw	r4,88(sp)
 9085e34:	980b883a 	mov	r5,r19
 9085e38:	800d883a 	mov	r6,r16
 9085e3c:	9088f240 	call	9088f24 <__lshift>
 9085e40:	1027883a 	mov	r19,r2
 9085e44:	8804c03a 	cmpne	r2,r17,zero
 9085e48:	1002541e 	bne	r2,zero,908679c <_dtoa_r+0x1284>
 9085e4c:	980b883a 	mov	r5,r19
 9085e50:	dd800517 	ldw	r22,20(sp)
 9085e54:	dcc00615 	stw	r19,24(sp)
 9085e58:	a700004c 	andi	fp,r20,1
 9085e5c:	2827883a 	mov	r19,r5
 9085e60:	d9000717 	ldw	r4,28(sp)
 9085e64:	900b883a 	mov	r5,r18
 9085e68:	90853000 	call	9085300 <quorem>
 9085e6c:	d9000717 	ldw	r4,28(sp)
 9085e70:	d9400617 	ldw	r5,24(sp)
 9085e74:	1023883a 	mov	r17,r2
 9085e78:	8dc00c04 	addi	r23,r17,48
 9085e7c:	908873c0 	call	908873c <__mcmp>
 9085e80:	d9001617 	ldw	r4,88(sp)
 9085e84:	900b883a 	mov	r5,r18
 9085e88:	980d883a 	mov	r6,r19
 9085e8c:	1029883a 	mov	r20,r2
 9085e90:	9088d980 	call	9088d98 <__mdiff>
 9085e94:	102b883a 	mov	r21,r2
 9085e98:	10800317 	ldw	r2,12(r2)
 9085e9c:	1001281e 	bne	r2,zero,9086340 <_dtoa_r+0xe28>
 9085ea0:	d9000717 	ldw	r4,28(sp)
 9085ea4:	a80b883a 	mov	r5,r21
 9085ea8:	908873c0 	call	908873c <__mcmp>
 9085eac:	d9001617 	ldw	r4,88(sp)
 9085eb0:	1021883a 	mov	r16,r2
 9085eb4:	a80b883a 	mov	r5,r21
 9085eb8:	90885e00 	call	90885e0 <_Bfree>
 9085ebc:	8000041e 	bne	r16,zero,9085ed0 <_dtoa_r+0x9b8>
 9085ec0:	d8801717 	ldw	r2,92(sp)
 9085ec4:	1000021e 	bne	r2,zero,9085ed0 <_dtoa_r+0x9b8>
 9085ec8:	e004c03a 	cmpne	r2,fp,zero
 9085ecc:	10011726 	beq	r2,zero,908632c <_dtoa_r+0xe14>
 9085ed0:	a0010616 	blt	r20,zero,90862ec <_dtoa_r+0xdd4>
 9085ed4:	a000041e 	bne	r20,zero,9085ee8 <_dtoa_r+0x9d0>
 9085ed8:	d8c01717 	ldw	r3,92(sp)
 9085edc:	1800021e 	bne	r3,zero,9085ee8 <_dtoa_r+0x9d0>
 9085ee0:	e004c03a 	cmpne	r2,fp,zero
 9085ee4:	10010126 	beq	r2,zero,90862ec <_dtoa_r+0xdd4>
 9085ee8:	04023d16 	blt	zero,r16,90867e0 <_dtoa_r+0x12c8>
 9085eec:	b5c00005 	stb	r23,0(r22)
 9085ef0:	d9800517 	ldw	r6,20(sp)
 9085ef4:	d9000f17 	ldw	r4,60(sp)
 9085ef8:	b5800044 	addi	r22,r22,1
 9085efc:	3105883a 	add	r2,r6,r4
 9085f00:	b0806526 	beq	r22,r2,9086098 <_dtoa_r+0xb80>
 9085f04:	d9400717 	ldw	r5,28(sp)
 9085f08:	d9001617 	ldw	r4,88(sp)
 9085f0c:	01800284 	movi	r6,10
 9085f10:	000f883a 	mov	r7,zero
 9085f14:	90892940 	call	9089294 <__multadd>
 9085f18:	d8800715 	stw	r2,28(sp)
 9085f1c:	d8800617 	ldw	r2,24(sp)
 9085f20:	14c10c26 	beq	r2,r19,9086354 <_dtoa_r+0xe3c>
 9085f24:	d9400617 	ldw	r5,24(sp)
 9085f28:	d9001617 	ldw	r4,88(sp)
 9085f2c:	01800284 	movi	r6,10
 9085f30:	000f883a 	mov	r7,zero
 9085f34:	90892940 	call	9089294 <__multadd>
 9085f38:	d9001617 	ldw	r4,88(sp)
 9085f3c:	980b883a 	mov	r5,r19
 9085f40:	01800284 	movi	r6,10
 9085f44:	000f883a 	mov	r7,zero
 9085f48:	d8800615 	stw	r2,24(sp)
 9085f4c:	90892940 	call	9089294 <__multadd>
 9085f50:	1027883a 	mov	r19,r2
 9085f54:	003fc206 	br	9085e60 <_dtoa_r+0x948>
 9085f58:	2445c83a 	sub	r2,r4,r17
 9085f5c:	a088983a 	sll	r4,r20,r2
 9085f60:	003e4b06 	br	9085890 <_dtoa_r+0x378>
 9085f64:	01bfffc4 	movi	r6,-1
 9085f68:	00800044 	movi	r2,1
 9085f6c:	d9800e15 	stw	r6,56(sp)
 9085f70:	d9800f15 	stw	r6,60(sp)
 9085f74:	d8800b15 	stw	r2,44(sp)
 9085f78:	d8c01617 	ldw	r3,88(sp)
 9085f7c:	008005c4 	movi	r2,23
 9085f80:	18001115 	stw	zero,68(r3)
 9085f84:	1580082e 	bgeu	r2,r22,9085fa8 <_dtoa_r+0xa90>
 9085f88:	00c00104 	movi	r3,4
 9085f8c:	0009883a 	mov	r4,zero
 9085f90:	18c7883a 	add	r3,r3,r3
 9085f94:	18800504 	addi	r2,r3,20
 9085f98:	21000044 	addi	r4,r4,1
 9085f9c:	b0bffc2e 	bgeu	r22,r2,9085f90 <_dtoa_r+0xa78>
 9085fa0:	d9801617 	ldw	r6,88(sp)
 9085fa4:	31001115 	stw	r4,68(r6)
 9085fa8:	dc000f17 	ldw	r16,60(sp)
 9085fac:	003e4b06 	br	90858dc <_dtoa_r+0x3c4>
 9085fb0:	d9801717 	ldw	r6,92(sp)
 9085fb4:	0023883a 	mov	r17,zero
 9085fb8:	31bfff04 	addi	r6,r6,-4
 9085fbc:	d9801715 	stw	r6,92(sp)
 9085fc0:	003df806 	br	90857a4 <_dtoa_r+0x28c>
 9085fc4:	00800804 	movi	r2,32
 9085fc8:	10c9c83a 	sub	r4,r2,r3
 9085fcc:	00c00104 	movi	r3,4
 9085fd0:	19005a16 	blt	r3,r4,908613c <_dtoa_r+0xc24>
 9085fd4:	008000c4 	movi	r2,3
 9085fd8:	113f7e16 	blt	r2,r4,9085dd4 <_dtoa_r+0x8bc>
 9085fdc:	20800704 	addi	r2,r4,28
 9085fe0:	003f7506 	br	9085db8 <_dtoa_r+0x8a0>
 9085fe4:	d9801717 	ldw	r6,92(sp)
 9085fe8:	00800044 	movi	r2,1
 9085fec:	1180a10e 	bge	r2,r6,9086274 <_dtoa_r+0xd5c>
 9085ff0:	d9800f17 	ldw	r6,60(sp)
 9085ff4:	d8c01017 	ldw	r3,64(sp)
 9085ff8:	30bfffc4 	addi	r2,r6,-1
 9085ffc:	1881c616 	blt	r3,r2,9086718 <_dtoa_r+0x1200>
 9086000:	18a5c83a 	sub	r18,r3,r2
 9086004:	d8800f17 	ldw	r2,60(sp)
 9086008:	10026216 	blt	r2,zero,9086994 <_dtoa_r+0x147c>
 908600c:	dc001117 	ldw	r16,68(sp)
 9086010:	1007883a 	mov	r3,r2
 9086014:	d9800a17 	ldw	r6,40(sp)
 9086018:	d8801117 	ldw	r2,68(sp)
 908601c:	d9001617 	ldw	r4,88(sp)
 9086020:	30cd883a 	add	r6,r6,r3
 9086024:	10c5883a 	add	r2,r2,r3
 9086028:	01400044 	movi	r5,1
 908602c:	d9800a15 	stw	r6,40(sp)
 9086030:	d8801115 	stw	r2,68(sp)
 9086034:	90892580 	call	9089258 <__i2b>
 9086038:	1027883a 	mov	r19,r2
 908603c:	003f2506 	br	9085cd4 <_dtoa_r+0x7bc>
 9086040:	00c24374 	movhi	r3,2317
 9086044:	18f28004 	addi	r3,r3,-13824
 9086048:	003d6706 	br	90855e8 <_dtoa_r+0xd0>
 908604c:	dd800517 	ldw	r22,20(sp)
 9086050:	04000044 	movi	r16,1
 9086054:	00000706 	br	9086074 <_dtoa_r+0xb5c>
 9086058:	d9400717 	ldw	r5,28(sp)
 908605c:	d9001617 	ldw	r4,88(sp)
 9086060:	01800284 	movi	r6,10
 9086064:	000f883a 	mov	r7,zero
 9086068:	90892940 	call	9089294 <__multadd>
 908606c:	d8800715 	stw	r2,28(sp)
 9086070:	84000044 	addi	r16,r16,1
 9086074:	d9000717 	ldw	r4,28(sp)
 9086078:	900b883a 	mov	r5,r18
 908607c:	90853000 	call	9085300 <quorem>
 9086080:	15c00c04 	addi	r23,r2,48
 9086084:	b5c00005 	stb	r23,0(r22)
 9086088:	d8c00f17 	ldw	r3,60(sp)
 908608c:	b5800044 	addi	r22,r22,1
 9086090:	80fff116 	blt	r16,r3,9086058 <_dtoa_r+0xb40>
 9086094:	d8000615 	stw	zero,24(sp)
 9086098:	d9400717 	ldw	r5,28(sp)
 908609c:	d9001617 	ldw	r4,88(sp)
 90860a0:	01800044 	movi	r6,1
 90860a4:	9088f240 	call	9088f24 <__lshift>
 90860a8:	1009883a 	mov	r4,r2
 90860ac:	900b883a 	mov	r5,r18
 90860b0:	d8800715 	stw	r2,28(sp)
 90860b4:	908873c0 	call	908873c <__mcmp>
 90860b8:	00803c0e 	bge	zero,r2,90861ac <_dtoa_r+0xc94>
 90860bc:	b009883a 	mov	r4,r22
 90860c0:	213fffc4 	addi	r4,r4,-1
 90860c4:	21400003 	ldbu	r5,0(r4)
 90860c8:	00800e44 	movi	r2,57
 90860cc:	28c03fcc 	andi	r3,r5,255
 90860d0:	18c0201c 	xori	r3,r3,128
 90860d4:	18ffe004 	addi	r3,r3,-128
 90860d8:	1881981e 	bne	r3,r2,908673c <_dtoa_r+0x1224>
 90860dc:	d9800517 	ldw	r6,20(sp)
 90860e0:	21bff71e 	bne	r4,r6,90860c0 <_dtoa_r+0xba8>
 90860e4:	d8800d17 	ldw	r2,52(sp)
 90860e8:	37000044 	addi	fp,r6,1
 90860ec:	10800044 	addi	r2,r2,1
 90860f0:	d8800d15 	stw	r2,52(sp)
 90860f4:	00800c44 	movi	r2,49
 90860f8:	30800005 	stb	r2,0(r6)
 90860fc:	d9001617 	ldw	r4,88(sp)
 9086100:	900b883a 	mov	r5,r18
 9086104:	90885e00 	call	90885e0 <_Bfree>
 9086108:	983ecd26 	beq	r19,zero,9085c40 <_dtoa_r+0x728>
 908610c:	d8c00617 	ldw	r3,24(sp)
 9086110:	18000426 	beq	r3,zero,9086124 <_dtoa_r+0xc0c>
 9086114:	1cc00326 	beq	r3,r19,9086124 <_dtoa_r+0xc0c>
 9086118:	d9001617 	ldw	r4,88(sp)
 908611c:	180b883a 	mov	r5,r3
 9086120:	90885e00 	call	90885e0 <_Bfree>
 9086124:	d9001617 	ldw	r4,88(sp)
 9086128:	980b883a 	mov	r5,r19
 908612c:	90885e00 	call	90885e0 <_Bfree>
 9086130:	003ec306 	br	9085c40 <_dtoa_r+0x728>
 9086134:	1805883a 	mov	r2,r3
 9086138:	003eeb06 	br	9085ce8 <_dtoa_r+0x7d0>
 908613c:	d9800a17 	ldw	r6,40(sp)
 9086140:	d8c01117 	ldw	r3,68(sp)
 9086144:	20bfff04 	addi	r2,r4,-4
 9086148:	308d883a 	add	r6,r6,r2
 908614c:	1887883a 	add	r3,r3,r2
 9086150:	80a1883a 	add	r16,r16,r2
 9086154:	d9800a15 	stw	r6,40(sp)
 9086158:	d8c01115 	stw	r3,68(sp)
 908615c:	003f1d06 	br	9085dd4 <_dtoa_r+0x8bc>
 9086160:	a03f0c1e 	bne	r20,zero,9085d94 <_dtoa_r+0x87c>
 9086164:	00800434 	movhi	r2,16
 9086168:	10bfffc4 	addi	r2,r2,-1
 908616c:	a884703a 	and	r2,r21,r2
 9086170:	103f081e 	bne	r2,zero,9085d94 <_dtoa_r+0x87c>
 9086174:	a89ffc2c 	andhi	r2,r21,32752
 9086178:	103f0626 	beq	r2,zero,9085d94 <_dtoa_r+0x87c>
 908617c:	d8c01117 	ldw	r3,68(sp)
 9086180:	d9000a17 	ldw	r4,40(sp)
 9086184:	18c00044 	addi	r3,r3,1
 9086188:	21000044 	addi	r4,r4,1
 908618c:	d8c01115 	stw	r3,68(sp)
 9086190:	d9000a15 	stw	r4,40(sp)
 9086194:	003f0006 	br	9085d98 <_dtoa_r+0x880>
 9086198:	d9400717 	ldw	r5,28(sp)
 908619c:	d9001617 	ldw	r4,88(sp)
 90861a0:	90893940 	call	9089394 <__pow5mult>
 90861a4:	d8800715 	stw	r2,28(sp)
 90861a8:	003eed06 	br	9085d60 <_dtoa_r+0x848>
 90861ac:	1000021e 	bne	r2,zero,90861b8 <_dtoa_r+0xca0>
 90861b0:	b880004c 	andi	r2,r23,1
 90861b4:	103fc11e 	bne	r2,zero,90860bc <_dtoa_r+0xba4>
 90861b8:	b5bfffc4 	addi	r22,r22,-1
 90861bc:	b0c00007 	ldb	r3,0(r22)
 90861c0:	00800c04 	movi	r2,48
 90861c4:	18bffc26 	beq	r3,r2,90861b8 <_dtoa_r+0xca0>
 90861c8:	b7000044 	addi	fp,r22,1
 90861cc:	003fcb06 	br	90860fc <_dtoa_r+0xbe4>
 90861d0:	d9800d17 	ldw	r6,52(sp)
 90861d4:	018fc83a 	sub	r7,zero,r6
 90861d8:	3801f726 	beq	r7,zero,90869b8 <_dtoa_r+0x14a0>
 90861dc:	398003cc 	andi	r6,r7,15
 90861e0:	300c90fa 	slli	r6,r6,3
 90861e4:	01424374 	movhi	r5,2317
 90861e8:	29729d04 	addi	r5,r5,-13708
 90861ec:	d9001217 	ldw	r4,72(sp)
 90861f0:	314d883a 	add	r6,r6,r5
 90861f4:	30c00117 	ldw	r3,4(r6)
 90861f8:	30800017 	ldw	r2,0(r6)
 90861fc:	d9401317 	ldw	r5,76(sp)
 9086200:	3821d13a 	srai	r16,r7,4
 9086204:	100d883a 	mov	r6,r2
 9086208:	180f883a 	mov	r7,r3
 908620c:	908b5b40 	call	908b5b4 <__muldf3>
 9086210:	1011883a 	mov	r8,r2
 9086214:	1813883a 	mov	r9,r3
 9086218:	1029883a 	mov	r20,r2
 908621c:	182b883a 	mov	r21,r3
 9086220:	8001e526 	beq	r16,zero,90869b8 <_dtoa_r+0x14a0>
 9086224:	05800084 	movi	r22,2
 9086228:	04424374 	movhi	r17,2317
 908622c:	8c72cf04 	addi	r17,r17,-13508
 9086230:	8080004c 	andi	r2,r16,1
 9086234:	1005003a 	cmpeq	r2,r2,zero
 9086238:	1000081e 	bne	r2,zero,908625c <_dtoa_r+0xd44>
 908623c:	89800017 	ldw	r6,0(r17)
 9086240:	89c00117 	ldw	r7,4(r17)
 9086244:	480b883a 	mov	r5,r9
 9086248:	4009883a 	mov	r4,r8
 908624c:	908b5b40 	call	908b5b4 <__muldf3>
 9086250:	1011883a 	mov	r8,r2
 9086254:	b5800044 	addi	r22,r22,1
 9086258:	1813883a 	mov	r9,r3
 908625c:	8021d07a 	srai	r16,r16,1
 9086260:	8c400204 	addi	r17,r17,8
 9086264:	803ff21e 	bne	r16,zero,9086230 <_dtoa_r+0xd18>
 9086268:	4029883a 	mov	r20,r8
 908626c:	482b883a 	mov	r21,r9
 9086270:	003dca06 	br	908599c <_dtoa_r+0x484>
 9086274:	d9000817 	ldw	r4,32(sp)
 9086278:	2005003a 	cmpeq	r2,r4,zero
 908627c:	1001f61e 	bne	r2,zero,9086a58 <_dtoa_r+0x1540>
 9086280:	dc001117 	ldw	r16,68(sp)
 9086284:	dc801017 	ldw	r18,64(sp)
 9086288:	18c10cc4 	addi	r3,r3,1075
 908628c:	003f6106 	br	9086014 <_dtoa_r+0xafc>
 9086290:	d8000b15 	stw	zero,44(sp)
 9086294:	d9802617 	ldw	r6,152(sp)
 9086298:	d8c00d17 	ldw	r3,52(sp)
 908629c:	30800044 	addi	r2,r6,1
 90862a0:	18ad883a 	add	r22,r3,r2
 90862a4:	b13fffc4 	addi	r4,r22,-1
 90862a8:	d9000e15 	stw	r4,56(sp)
 90862ac:	0581f60e 	bge	zero,r22,9086a88 <_dtoa_r+0x1570>
 90862b0:	dd800f15 	stw	r22,60(sp)
 90862b4:	003f3006 	br	9085f78 <_dtoa_r+0xa60>
 90862b8:	d8000b15 	stw	zero,44(sp)
 90862bc:	d9002617 	ldw	r4,152(sp)
 90862c0:	0101eb0e 	bge	zero,r4,9086a70 <_dtoa_r+0x1558>
 90862c4:	202d883a 	mov	r22,r4
 90862c8:	d9000e15 	stw	r4,56(sp)
 90862cc:	d9000f15 	stw	r4,60(sp)
 90862d0:	003f2906 	br	9085f78 <_dtoa_r+0xa60>
 90862d4:	01800044 	movi	r6,1
 90862d8:	d9800b15 	stw	r6,44(sp)
 90862dc:	003ff706 	br	90862bc <_dtoa_r+0xda4>
 90862e0:	01000044 	movi	r4,1
 90862e4:	d9000b15 	stw	r4,44(sp)
 90862e8:	003fea06 	br	9086294 <_dtoa_r+0xd7c>
 90862ec:	04000c0e 	bge	zero,r16,9086320 <_dtoa_r+0xe08>
 90862f0:	d9400717 	ldw	r5,28(sp)
 90862f4:	d9001617 	ldw	r4,88(sp)
 90862f8:	01800044 	movi	r6,1
 90862fc:	9088f240 	call	9088f24 <__lshift>
 9086300:	1009883a 	mov	r4,r2
 9086304:	900b883a 	mov	r5,r18
 9086308:	d8800715 	stw	r2,28(sp)
 908630c:	908873c0 	call	908873c <__mcmp>
 9086310:	0081e00e 	bge	zero,r2,9086a94 <_dtoa_r+0x157c>
 9086314:	bdc00044 	addi	r23,r23,1
 9086318:	00800e84 	movi	r2,58
 908631c:	b881a226 	beq	r23,r2,90869a8 <_dtoa_r+0x1490>
 9086320:	b7000044 	addi	fp,r22,1
 9086324:	b5c00005 	stb	r23,0(r22)
 9086328:	003f7406 	br	90860fc <_dtoa_r+0xbe4>
 908632c:	00800e44 	movi	r2,57
 9086330:	b8819d26 	beq	r23,r2,90869a8 <_dtoa_r+0x1490>
 9086334:	053ffa0e 	bge	zero,r20,9086320 <_dtoa_r+0xe08>
 9086338:	8dc00c44 	addi	r23,r17,49
 908633c:	003ff806 	br	9086320 <_dtoa_r+0xe08>
 9086340:	d9001617 	ldw	r4,88(sp)
 9086344:	a80b883a 	mov	r5,r21
 9086348:	04000044 	movi	r16,1
 908634c:	90885e00 	call	90885e0 <_Bfree>
 9086350:	003edf06 	br	9085ed0 <_dtoa_r+0x9b8>
 9086354:	d9001617 	ldw	r4,88(sp)
 9086358:	980b883a 	mov	r5,r19
 908635c:	01800284 	movi	r6,10
 9086360:	000f883a 	mov	r7,zero
 9086364:	90892940 	call	9089294 <__multadd>
 9086368:	1027883a 	mov	r19,r2
 908636c:	d8800615 	stw	r2,24(sp)
 9086370:	003ebb06 	br	9085e60 <_dtoa_r+0x948>
 9086374:	d9801117 	ldw	r6,68(sp)
 9086378:	d8800d17 	ldw	r2,52(sp)
 908637c:	d8000915 	stw	zero,36(sp)
 9086380:	308dc83a 	sub	r6,r6,r2
 9086384:	0087c83a 	sub	r3,zero,r2
 9086388:	d9801115 	stw	r6,68(sp)
 908638c:	d8c01015 	stw	r3,64(sp)
 9086390:	003cfe06 	br	908578c <_dtoa_r+0x274>
 9086394:	018dc83a 	sub	r6,zero,r6
 9086398:	d9801115 	stw	r6,68(sp)
 908639c:	d8000a15 	stw	zero,40(sp)
 90863a0:	003cf306 	br	9085770 <_dtoa_r+0x258>
 90863a4:	d9000d17 	ldw	r4,52(sp)
 90863a8:	908be680 	call	908be68 <__floatsidf>
 90863ac:	880b883a 	mov	r5,r17
 90863b0:	8009883a 	mov	r4,r16
 90863b4:	180f883a 	mov	r7,r3
 90863b8:	100d883a 	mov	r6,r2
 90863bc:	908bc480 	call	908bc48 <__nedf2>
 90863c0:	103ce126 	beq	r2,zero,9085748 <_dtoa_r+0x230>
 90863c4:	d9800d17 	ldw	r6,52(sp)
 90863c8:	31bfffc4 	addi	r6,r6,-1
 90863cc:	d9800d15 	stw	r6,52(sp)
 90863d0:	003cdd06 	br	9085748 <_dtoa_r+0x230>
 90863d4:	d9000717 	ldw	r4,28(sp)
 90863d8:	900b883a 	mov	r5,r18
 90863dc:	908873c0 	call	908873c <__mcmp>
 90863e0:	103e8d0e 	bge	r2,zero,9085e18 <_dtoa_r+0x900>
 90863e4:	d9400717 	ldw	r5,28(sp)
 90863e8:	d9001617 	ldw	r4,88(sp)
 90863ec:	01800284 	movi	r6,10
 90863f0:	000f883a 	mov	r7,zero
 90863f4:	90892940 	call	9089294 <__multadd>
 90863f8:	d9800d17 	ldw	r6,52(sp)
 90863fc:	d8800715 	stw	r2,28(sp)
 9086400:	31bfffc4 	addi	r6,r6,-1
 9086404:	d9800d15 	stw	r6,52(sp)
 9086408:	b001a71e 	bne	r22,zero,9086aa8 <_dtoa_r+0x1590>
 908640c:	d8800e17 	ldw	r2,56(sp)
 9086410:	d8800f15 	stw	r2,60(sp)
 9086414:	003e8006 	br	9085e18 <_dtoa_r+0x900>
 9086418:	90800417 	ldw	r2,16(r18)
 908641c:	1085883a 	add	r2,r2,r2
 9086420:	1085883a 	add	r2,r2,r2
 9086424:	1485883a 	add	r2,r2,r18
 9086428:	11000417 	ldw	r4,16(r2)
 908642c:	90886080 	call	9088608 <__hi0bits>
 9086430:	00c00804 	movi	r3,32
 9086434:	1887c83a 	sub	r3,r3,r2
 9086438:	003e5a06 	br	9085da4 <_dtoa_r+0x88c>
 908643c:	d9400717 	ldw	r5,28(sp)
 9086440:	d9801017 	ldw	r6,64(sp)
 9086444:	d9001617 	ldw	r4,88(sp)
 9086448:	90893940 	call	9089394 <__pow5mult>
 908644c:	d8800715 	stw	r2,28(sp)
 9086450:	003e4306 	br	9085d60 <_dtoa_r+0x848>
 9086454:	d9800f17 	ldw	r6,60(sp)
 9086458:	d8800d17 	ldw	r2,52(sp)
 908645c:	d9800315 	stw	r6,12(sp)
 9086460:	d8800415 	stw	r2,16(sp)
 9086464:	d8c00b17 	ldw	r3,44(sp)
 9086468:	1805003a 	cmpeq	r2,r3,zero
 908646c:	1000e21e 	bne	r2,zero,90867f8 <_dtoa_r+0x12e0>
 9086470:	d9000317 	ldw	r4,12(sp)
 9086474:	0005883a 	mov	r2,zero
 9086478:	00cff834 	movhi	r3,16352
 908647c:	200c90fa 	slli	r6,r4,3
 9086480:	01024374 	movhi	r4,2317
 9086484:	21329d04 	addi	r4,r4,-13708
 9086488:	180b883a 	mov	r5,r3
 908648c:	310d883a 	add	r6,r6,r4
 9086490:	327fff17 	ldw	r9,-4(r6)
 9086494:	323ffe17 	ldw	r8,-8(r6)
 9086498:	1009883a 	mov	r4,r2
 908649c:	480f883a 	mov	r7,r9
 90864a0:	400d883a 	mov	r6,r8
 90864a4:	908b9680 	call	908b968 <__divdf3>
 90864a8:	180b883a 	mov	r5,r3
 90864ac:	b00d883a 	mov	r6,r22
 90864b0:	b80f883a 	mov	r7,r23
 90864b4:	1009883a 	mov	r4,r2
 90864b8:	908b4c00 	call	908b4c0 <__subdf3>
 90864bc:	a80b883a 	mov	r5,r21
 90864c0:	a009883a 	mov	r4,r20
 90864c4:	d8c01915 	stw	r3,100(sp)
 90864c8:	d8801815 	stw	r2,96(sp)
 90864cc:	908bf600 	call	908bf60 <__fixdfsi>
 90864d0:	1009883a 	mov	r4,r2
 90864d4:	1027883a 	mov	r19,r2
 90864d8:	908be680 	call	908be68 <__floatsidf>
 90864dc:	a80b883a 	mov	r5,r21
 90864e0:	a009883a 	mov	r4,r20
 90864e4:	180f883a 	mov	r7,r3
 90864e8:	100d883a 	mov	r6,r2
 90864ec:	908b4c00 	call	908b4c0 <__subdf3>
 90864f0:	d9801817 	ldw	r6,96(sp)
 90864f4:	1823883a 	mov	r17,r3
 90864f8:	d8801415 	stw	r2,80(sp)
 90864fc:	302d883a 	mov	r22,r6
 9086500:	d9800517 	ldw	r6,20(sp)
 9086504:	9cc00c04 	addi	r19,r19,48
 9086508:	dc401515 	stw	r17,84(sp)
 908650c:	d8c01917 	ldw	r3,100(sp)
 9086510:	34c00005 	stb	r19,0(r6)
 9086514:	d8800517 	ldw	r2,20(sp)
 9086518:	d9401917 	ldw	r5,100(sp)
 908651c:	d9801417 	ldw	r6,80(sp)
 9086520:	b009883a 	mov	r4,r22
 9086524:	880f883a 	mov	r7,r17
 9086528:	182f883a 	mov	r23,r3
 908652c:	17000044 	addi	fp,r2,1
 9086530:	908bcd00 	call	908bcd0 <__gtdf2>
 9086534:	00804e16 	blt	zero,r2,9086670 <_dtoa_r+0x1158>
 9086538:	d9801417 	ldw	r6,80(sp)
 908653c:	0005883a 	mov	r2,zero
 9086540:	00cffc34 	movhi	r3,16368
 9086544:	180b883a 	mov	r5,r3
 9086548:	880f883a 	mov	r7,r17
 908654c:	1009883a 	mov	r4,r2
 9086550:	908b4c00 	call	908b4c0 <__subdf3>
 9086554:	d9401917 	ldw	r5,100(sp)
 9086558:	180f883a 	mov	r7,r3
 908655c:	b009883a 	mov	r4,r22
 9086560:	100d883a 	mov	r6,r2
 9086564:	908bcd00 	call	908bcd0 <__gtdf2>
 9086568:	00bda216 	blt	zero,r2,9085bf4 <_dtoa_r+0x6dc>
 908656c:	d8c00317 	ldw	r3,12(sp)
 9086570:	00800044 	movi	r2,1
 9086574:	10c01216 	blt	r2,r3,90865c0 <_dtoa_r+0x10a8>
 9086578:	003d4506 	br	9085a90 <_dtoa_r+0x578>
 908657c:	d9801417 	ldw	r6,80(sp)
 9086580:	0005883a 	mov	r2,zero
 9086584:	00cffc34 	movhi	r3,16368
 9086588:	180b883a 	mov	r5,r3
 908658c:	880f883a 	mov	r7,r17
 9086590:	1009883a 	mov	r4,r2
 9086594:	908b4c00 	call	908b4c0 <__subdf3>
 9086598:	d9c01b17 	ldw	r7,108(sp)
 908659c:	180b883a 	mov	r5,r3
 90865a0:	1009883a 	mov	r4,r2
 90865a4:	b00d883a 	mov	r6,r22
 90865a8:	908bde00 	call	908bde0 <__ltdf2>
 90865ac:	103d9116 	blt	r2,zero,9085bf4 <_dtoa_r+0x6dc>
 90865b0:	d9800517 	ldw	r6,20(sp)
 90865b4:	d9000317 	ldw	r4,12(sp)
 90865b8:	3105883a 	add	r2,r6,r4
 90865bc:	e0bd3426 	beq	fp,r2,9085a90 <_dtoa_r+0x578>
 90865c0:	04500934 	movhi	r17,16420
 90865c4:	0021883a 	mov	r16,zero
 90865c8:	b80b883a 	mov	r5,r23
 90865cc:	b009883a 	mov	r4,r22
 90865d0:	800d883a 	mov	r6,r16
 90865d4:	880f883a 	mov	r7,r17
 90865d8:	908b5b40 	call	908b5b4 <__muldf3>
 90865dc:	d9401517 	ldw	r5,84(sp)
 90865e0:	d9001417 	ldw	r4,80(sp)
 90865e4:	880f883a 	mov	r7,r17
 90865e8:	000d883a 	mov	r6,zero
 90865ec:	d8801a15 	stw	r2,104(sp)
 90865f0:	d8c01b15 	stw	r3,108(sp)
 90865f4:	908b5b40 	call	908b5b4 <__muldf3>
 90865f8:	180b883a 	mov	r5,r3
 90865fc:	1009883a 	mov	r4,r2
 9086600:	1823883a 	mov	r17,r3
 9086604:	1021883a 	mov	r16,r2
 9086608:	908bf600 	call	908bf60 <__fixdfsi>
 908660c:	1009883a 	mov	r4,r2
 9086610:	102b883a 	mov	r21,r2
 9086614:	908be680 	call	908be68 <__floatsidf>
 9086618:	880b883a 	mov	r5,r17
 908661c:	8009883a 	mov	r4,r16
 9086620:	180f883a 	mov	r7,r3
 9086624:	100d883a 	mov	r6,r2
 9086628:	908b4c00 	call	908b4c0 <__subdf3>
 908662c:	1021883a 	mov	r16,r2
 9086630:	d9001b17 	ldw	r4,108(sp)
 9086634:	1823883a 	mov	r17,r3
 9086638:	dc001415 	stw	r16,80(sp)
 908663c:	ad400c04 	addi	r21,r21,48
 9086640:	dc401515 	stw	r17,84(sp)
 9086644:	d8801a17 	ldw	r2,104(sp)
 9086648:	e5400005 	stb	r21,0(fp)
 908664c:	202f883a 	mov	r23,r4
 9086650:	d9c01b17 	ldw	r7,108(sp)
 9086654:	d9001417 	ldw	r4,80(sp)
 9086658:	880b883a 	mov	r5,r17
 908665c:	100d883a 	mov	r6,r2
 9086660:	102d883a 	mov	r22,r2
 9086664:	e7000044 	addi	fp,fp,1
 9086668:	908bde00 	call	908bde0 <__ltdf2>
 908666c:	103fc30e 	bge	r2,zero,908657c <_dtoa_r+0x1064>
 9086670:	d9000417 	ldw	r4,16(sp)
 9086674:	d9000d15 	stw	r4,52(sp)
 9086678:	003d7106 	br	9085c40 <_dtoa_r+0x728>
 908667c:	d9801717 	ldw	r6,92(sp)
 9086680:	00800084 	movi	r2,2
 9086684:	11bde60e 	bge	r2,r6,9085e20 <_dtoa_r+0x908>
 9086688:	203cfb1e 	bne	r4,zero,9085a78 <_dtoa_r+0x560>
 908668c:	d9001617 	ldw	r4,88(sp)
 9086690:	900b883a 	mov	r5,r18
 9086694:	01800144 	movi	r6,5
 9086698:	000f883a 	mov	r7,zero
 908669c:	90892940 	call	9089294 <__multadd>
 90866a0:	d9000717 	ldw	r4,28(sp)
 90866a4:	100b883a 	mov	r5,r2
 90866a8:	1025883a 	mov	r18,r2
 90866ac:	908873c0 	call	908873c <__mcmp>
 90866b0:	00bcf10e 	bge	zero,r2,9085a78 <_dtoa_r+0x560>
 90866b4:	d8c00d17 	ldw	r3,52(sp)
 90866b8:	d9000517 	ldw	r4,20(sp)
 90866bc:	d8000615 	stw	zero,24(sp)
 90866c0:	18c00044 	addi	r3,r3,1
 90866c4:	d8c00d15 	stw	r3,52(sp)
 90866c8:	00800c44 	movi	r2,49
 90866cc:	27000044 	addi	fp,r4,1
 90866d0:	20800005 	stb	r2,0(r4)
 90866d4:	003e8906 	br	90860fc <_dtoa_r+0xbe4>
 90866d8:	d8c00517 	ldw	r3,20(sp)
 90866dc:	003bc206 	br	90855e8 <_dtoa_r+0xd0>
 90866e0:	01824374 	movhi	r6,2317
 90866e4:	31b2cf04 	addi	r6,r6,-13508
 90866e8:	30c00917 	ldw	r3,36(r6)
 90866ec:	30800817 	ldw	r2,32(r6)
 90866f0:	d9001217 	ldw	r4,72(sp)
 90866f4:	d9401317 	ldw	r5,76(sp)
 90866f8:	180f883a 	mov	r7,r3
 90866fc:	100d883a 	mov	r6,r2
 9086700:	908b9680 	call	908b968 <__divdf3>
 9086704:	948003cc 	andi	r18,r18,15
 9086708:	058000c4 	movi	r22,3
 908670c:	1029883a 	mov	r20,r2
 9086710:	182b883a 	mov	r21,r3
 9086714:	003c8906 	br	908593c <_dtoa_r+0x424>
 9086718:	d9001017 	ldw	r4,64(sp)
 908671c:	d9800917 	ldw	r6,36(sp)
 9086720:	0025883a 	mov	r18,zero
 9086724:	1105c83a 	sub	r2,r2,r4
 9086728:	2089883a 	add	r4,r4,r2
 908672c:	308d883a 	add	r6,r6,r2
 9086730:	d9001015 	stw	r4,64(sp)
 9086734:	d9800915 	stw	r6,36(sp)
 9086738:	003e3206 	br	9086004 <_dtoa_r+0xaec>
 908673c:	28800044 	addi	r2,r5,1
 9086740:	27000044 	addi	fp,r4,1
 9086744:	20800005 	stb	r2,0(r4)
 9086748:	003e6c06 	br	90860fc <_dtoa_r+0xbe4>
 908674c:	d8800f17 	ldw	r2,60(sp)
 9086750:	00bce016 	blt	zero,r2,9085ad4 <_dtoa_r+0x5bc>
 9086754:	d9800f17 	ldw	r6,60(sp)
 9086758:	303cc51e 	bne	r6,zero,9085a70 <_dtoa_r+0x558>
 908675c:	0005883a 	mov	r2,zero
 9086760:	00d00534 	movhi	r3,16404
 9086764:	980b883a 	mov	r5,r19
 9086768:	180f883a 	mov	r7,r3
 908676c:	9009883a 	mov	r4,r18
 9086770:	100d883a 	mov	r6,r2
 9086774:	908b5b40 	call	908b5b4 <__muldf3>
 9086778:	180b883a 	mov	r5,r3
 908677c:	a80f883a 	mov	r7,r21
 9086780:	1009883a 	mov	r4,r2
 9086784:	a00d883a 	mov	r6,r20
 9086788:	908bd580 	call	908bd58 <__gedf2>
 908678c:	103cb80e 	bge	r2,zero,9085a70 <_dtoa_r+0x558>
 9086790:	0027883a 	mov	r19,zero
 9086794:	0025883a 	mov	r18,zero
 9086798:	003fc606 	br	90866b4 <_dtoa_r+0x119c>
 908679c:	99400117 	ldw	r5,4(r19)
 90867a0:	d9001617 	ldw	r4,88(sp)
 90867a4:	9088b600 	call	9088b60 <_Balloc>
 90867a8:	99800417 	ldw	r6,16(r19)
 90867ac:	11000304 	addi	r4,r2,12
 90867b0:	99400304 	addi	r5,r19,12
 90867b4:	318d883a 	add	r6,r6,r6
 90867b8:	318d883a 	add	r6,r6,r6
 90867bc:	31800204 	addi	r6,r6,8
 90867c0:	1023883a 	mov	r17,r2
 90867c4:	90822780 	call	9082278 <memcpy>
 90867c8:	d9001617 	ldw	r4,88(sp)
 90867cc:	880b883a 	mov	r5,r17
 90867d0:	01800044 	movi	r6,1
 90867d4:	9088f240 	call	9088f24 <__lshift>
 90867d8:	100b883a 	mov	r5,r2
 90867dc:	003d9c06 	br	9085e50 <_dtoa_r+0x938>
 90867e0:	00800e44 	movi	r2,57
 90867e4:	b8807026 	beq	r23,r2,90869a8 <_dtoa_r+0x1490>
 90867e8:	b8800044 	addi	r2,r23,1
 90867ec:	b7000044 	addi	fp,r22,1
 90867f0:	b0800005 	stb	r2,0(r22)
 90867f4:	003e4106 	br	90860fc <_dtoa_r+0xbe4>
 90867f8:	d8800317 	ldw	r2,12(sp)
 90867fc:	01824374 	movhi	r6,2317
 9086800:	31b29d04 	addi	r6,r6,-13708
 9086804:	b009883a 	mov	r4,r22
 9086808:	100e90fa 	slli	r7,r2,3
 908680c:	b80b883a 	mov	r5,r23
 9086810:	398f883a 	add	r7,r7,r6
 9086814:	38bffe17 	ldw	r2,-8(r7)
 9086818:	d9800517 	ldw	r6,20(sp)
 908681c:	38ffff17 	ldw	r3,-4(r7)
 9086820:	37000044 	addi	fp,r6,1
 9086824:	180f883a 	mov	r7,r3
 9086828:	100d883a 	mov	r6,r2
 908682c:	908b5b40 	call	908b5b4 <__muldf3>
 9086830:	a80b883a 	mov	r5,r21
 9086834:	a009883a 	mov	r4,r20
 9086838:	182f883a 	mov	r23,r3
 908683c:	102d883a 	mov	r22,r2
 9086840:	908bf600 	call	908bf60 <__fixdfsi>
 9086844:	1009883a 	mov	r4,r2
 9086848:	1027883a 	mov	r19,r2
 908684c:	908be680 	call	908be68 <__floatsidf>
 9086850:	a80b883a 	mov	r5,r21
 9086854:	a009883a 	mov	r4,r20
 9086858:	180f883a 	mov	r7,r3
 908685c:	100d883a 	mov	r6,r2
 9086860:	908b4c00 	call	908b4c0 <__subdf3>
 9086864:	180b883a 	mov	r5,r3
 9086868:	d8c00517 	ldw	r3,20(sp)
 908686c:	9cc00c04 	addi	r19,r19,48
 9086870:	1009883a 	mov	r4,r2
 9086874:	1cc00005 	stb	r19,0(r3)
 9086878:	2021883a 	mov	r16,r4
 908687c:	d9000317 	ldw	r4,12(sp)
 9086880:	00800044 	movi	r2,1
 9086884:	2823883a 	mov	r17,r5
 9086888:	20802226 	beq	r4,r2,9086914 <_dtoa_r+0x13fc>
 908688c:	1029883a 	mov	r20,r2
 9086890:	0005883a 	mov	r2,zero
 9086894:	00d00934 	movhi	r3,16420
 9086898:	180f883a 	mov	r7,r3
 908689c:	100d883a 	mov	r6,r2
 90868a0:	880b883a 	mov	r5,r17
 90868a4:	8009883a 	mov	r4,r16
 90868a8:	908b5b40 	call	908b5b4 <__muldf3>
 90868ac:	180b883a 	mov	r5,r3
 90868b0:	1009883a 	mov	r4,r2
 90868b4:	1823883a 	mov	r17,r3
 90868b8:	1021883a 	mov	r16,r2
 90868bc:	908bf600 	call	908bf60 <__fixdfsi>
 90868c0:	1009883a 	mov	r4,r2
 90868c4:	102b883a 	mov	r21,r2
 90868c8:	908be680 	call	908be68 <__floatsidf>
 90868cc:	880b883a 	mov	r5,r17
 90868d0:	8009883a 	mov	r4,r16
 90868d4:	180f883a 	mov	r7,r3
 90868d8:	100d883a 	mov	r6,r2
 90868dc:	908b4c00 	call	908b4c0 <__subdf3>
 90868e0:	180b883a 	mov	r5,r3
 90868e4:	d8c00517 	ldw	r3,20(sp)
 90868e8:	1009883a 	mov	r4,r2
 90868ec:	ad400c04 	addi	r21,r21,48
 90868f0:	1d05883a 	add	r2,r3,r20
 90868f4:	15400005 	stb	r21,0(r2)
 90868f8:	2021883a 	mov	r16,r4
 90868fc:	d9000317 	ldw	r4,12(sp)
 9086900:	a5000044 	addi	r20,r20,1
 9086904:	2823883a 	mov	r17,r5
 9086908:	a13fe11e 	bne	r20,r4,9086890 <_dtoa_r+0x1378>
 908690c:	e505883a 	add	r2,fp,r20
 9086910:	173fffc4 	addi	fp,r2,-1
 9086914:	0025883a 	mov	r18,zero
 9086918:	04cff834 	movhi	r19,16352
 908691c:	b009883a 	mov	r4,r22
 9086920:	b80b883a 	mov	r5,r23
 9086924:	900d883a 	mov	r6,r18
 9086928:	980f883a 	mov	r7,r19
 908692c:	908b5400 	call	908b540 <__adddf3>
 9086930:	180b883a 	mov	r5,r3
 9086934:	1009883a 	mov	r4,r2
 9086938:	800d883a 	mov	r6,r16
 908693c:	880f883a 	mov	r7,r17
 9086940:	908bde00 	call	908bde0 <__ltdf2>
 9086944:	103cab16 	blt	r2,zero,9085bf4 <_dtoa_r+0x6dc>
 9086948:	0009883a 	mov	r4,zero
 908694c:	980b883a 	mov	r5,r19
 9086950:	b80f883a 	mov	r7,r23
 9086954:	b00d883a 	mov	r6,r22
 9086958:	908b4c00 	call	908b4c0 <__subdf3>
 908695c:	180b883a 	mov	r5,r3
 9086960:	880f883a 	mov	r7,r17
 9086964:	1009883a 	mov	r4,r2
 9086968:	800d883a 	mov	r6,r16
 908696c:	908bcd00 	call	908bcd0 <__gtdf2>
 9086970:	00bc470e 	bge	zero,r2,9085a90 <_dtoa_r+0x578>
 9086974:	00c00c04 	movi	r3,48
 9086978:	e73fffc4 	addi	fp,fp,-1
 908697c:	e0800007 	ldb	r2,0(fp)
 9086980:	10fffd26 	beq	r2,r3,9086978 <_dtoa_r+0x1460>
 9086984:	d9800417 	ldw	r6,16(sp)
 9086988:	e7000044 	addi	fp,fp,1
 908698c:	d9800d15 	stw	r6,52(sp)
 9086990:	003cab06 	br	9085c40 <_dtoa_r+0x728>
 9086994:	d8c00f17 	ldw	r3,60(sp)
 9086998:	d9001117 	ldw	r4,68(sp)
 908699c:	20e1c83a 	sub	r16,r4,r3
 90869a0:	0007883a 	mov	r3,zero
 90869a4:	003d9b06 	br	9086014 <_dtoa_r+0xafc>
 90869a8:	00800e44 	movi	r2,57
 90869ac:	b0800005 	stb	r2,0(r22)
 90869b0:	b5800044 	addi	r22,r22,1
 90869b4:	003dc106 	br	90860bc <_dtoa_r+0xba4>
 90869b8:	05800084 	movi	r22,2
 90869bc:	003bf706 	br	908599c <_dtoa_r+0x484>
 90869c0:	d9000f17 	ldw	r4,60(sp)
 90869c4:	013c000e 	bge	zero,r4,90859c8 <_dtoa_r+0x4b0>
 90869c8:	d9800e17 	ldw	r6,56(sp)
 90869cc:	01bc300e 	bge	zero,r6,9085a90 <_dtoa_r+0x578>
 90869d0:	0005883a 	mov	r2,zero
 90869d4:	00d00934 	movhi	r3,16420
 90869d8:	a80b883a 	mov	r5,r21
 90869dc:	180f883a 	mov	r7,r3
 90869e0:	a009883a 	mov	r4,r20
 90869e4:	100d883a 	mov	r6,r2
 90869e8:	908b5b40 	call	908b5b4 <__muldf3>
 90869ec:	b1000044 	addi	r4,r22,1
 90869f0:	1021883a 	mov	r16,r2
 90869f4:	1823883a 	mov	r17,r3
 90869f8:	908be680 	call	908be68 <__floatsidf>
 90869fc:	880b883a 	mov	r5,r17
 9086a00:	8009883a 	mov	r4,r16
 9086a04:	180f883a 	mov	r7,r3
 9086a08:	100d883a 	mov	r6,r2
 9086a0c:	908b5b40 	call	908b5b4 <__muldf3>
 9086a10:	0011883a 	mov	r8,zero
 9086a14:	02500734 	movhi	r9,16412
 9086a18:	180b883a 	mov	r5,r3
 9086a1c:	480f883a 	mov	r7,r9
 9086a20:	1009883a 	mov	r4,r2
 9086a24:	400d883a 	mov	r6,r8
 9086a28:	908b5400 	call	908b540 <__adddf3>
 9086a2c:	102d883a 	mov	r22,r2
 9086a30:	00bf3034 	movhi	r2,64704
 9086a34:	10ef883a 	add	r23,r2,r3
 9086a38:	d8800d17 	ldw	r2,52(sp)
 9086a3c:	d8c00e17 	ldw	r3,56(sp)
 9086a40:	8029883a 	mov	r20,r16
 9086a44:	10bfffc4 	addi	r2,r2,-1
 9086a48:	882b883a 	mov	r21,r17
 9086a4c:	d8800415 	stw	r2,16(sp)
 9086a50:	d8c00315 	stw	r3,12(sp)
 9086a54:	003e8306 	br	9086464 <_dtoa_r+0xf4c>
 9086a58:	d8800117 	ldw	r2,4(sp)
 9086a5c:	dc001117 	ldw	r16,68(sp)
 9086a60:	dc801017 	ldw	r18,64(sp)
 9086a64:	00c00d84 	movi	r3,54
 9086a68:	1887c83a 	sub	r3,r3,r2
 9086a6c:	003d6906 	br	9086014 <_dtoa_r+0xafc>
 9086a70:	01800044 	movi	r6,1
 9086a74:	3021883a 	mov	r16,r6
 9086a78:	d9800f15 	stw	r6,60(sp)
 9086a7c:	d9802615 	stw	r6,152(sp)
 9086a80:	d9800e15 	stw	r6,56(sp)
 9086a84:	003b9306 	br	90858d4 <_dtoa_r+0x3bc>
 9086a88:	b021883a 	mov	r16,r22
 9086a8c:	dd800f15 	stw	r22,60(sp)
 9086a90:	003b9006 	br	90858d4 <_dtoa_r+0x3bc>
 9086a94:	103e221e 	bne	r2,zero,9086320 <_dtoa_r+0xe08>
 9086a98:	b880004c 	andi	r2,r23,1
 9086a9c:	1005003a 	cmpeq	r2,r2,zero
 9086aa0:	103e1f1e 	bne	r2,zero,9086320 <_dtoa_r+0xe08>
 9086aa4:	003e1b06 	br	9086314 <_dtoa_r+0xdfc>
 9086aa8:	d9001617 	ldw	r4,88(sp)
 9086aac:	980b883a 	mov	r5,r19
 9086ab0:	01800284 	movi	r6,10
 9086ab4:	000f883a 	mov	r7,zero
 9086ab8:	90892940 	call	9089294 <__multadd>
 9086abc:	d8c00e17 	ldw	r3,56(sp)
 9086ac0:	1027883a 	mov	r19,r2
 9086ac4:	d8c00f15 	stw	r3,60(sp)
 9086ac8:	003cd306 	br	9085e18 <_dtoa_r+0x900>

09086acc <_fflush_r>:
 9086acc:	defffb04 	addi	sp,sp,-20
 9086ad0:	dcc00315 	stw	r19,12(sp)
 9086ad4:	dc800215 	stw	r18,8(sp)
 9086ad8:	dfc00415 	stw	ra,16(sp)
 9086adc:	dc400115 	stw	r17,4(sp)
 9086ae0:	dc000015 	stw	r16,0(sp)
 9086ae4:	2027883a 	mov	r19,r4
 9086ae8:	2825883a 	mov	r18,r5
 9086aec:	20000226 	beq	r4,zero,9086af8 <_fflush_r+0x2c>
 9086af0:	20800e17 	ldw	r2,56(r4)
 9086af4:	10005626 	beq	r2,zero,9086c50 <_fflush_r+0x184>
 9086af8:	9100030b 	ldhu	r4,12(r18)
 9086afc:	20ffffcc 	andi	r3,r4,65535
 9086b00:	18e0001c 	xori	r3,r3,32768
 9086b04:	18e00004 	addi	r3,r3,-32768
 9086b08:	1880020c 	andi	r2,r3,8
 9086b0c:	1000261e 	bne	r2,zero,9086ba8 <_fflush_r+0xdc>
 9086b10:	90c00117 	ldw	r3,4(r18)
 9086b14:	20820014 	ori	r2,r4,2048
 9086b18:	9080030d 	sth	r2,12(r18)
 9086b1c:	1009883a 	mov	r4,r2
 9086b20:	00c0400e 	bge	zero,r3,9086c24 <_fflush_r+0x158>
 9086b24:	92000a17 	ldw	r8,40(r18)
 9086b28:	40004026 	beq	r8,zero,9086c2c <_fflush_r+0x160>
 9086b2c:	2084000c 	andi	r2,r4,4096
 9086b30:	10005326 	beq	r2,zero,9086c80 <_fflush_r+0x1b4>
 9086b34:	94001417 	ldw	r16,80(r18)
 9086b38:	9080030b 	ldhu	r2,12(r18)
 9086b3c:	1080010c 	andi	r2,r2,4
 9086b40:	1000481e 	bne	r2,zero,9086c64 <_fflush_r+0x198>
 9086b44:	91400717 	ldw	r5,28(r18)
 9086b48:	9809883a 	mov	r4,r19
 9086b4c:	800d883a 	mov	r6,r16
 9086b50:	000f883a 	mov	r7,zero
 9086b54:	403ee83a 	callr	r8
 9086b58:	8080261e 	bne	r16,r2,9086bf4 <_fflush_r+0x128>
 9086b5c:	9080030b 	ldhu	r2,12(r18)
 9086b60:	91000417 	ldw	r4,16(r18)
 9086b64:	90000115 	stw	zero,4(r18)
 9086b68:	10bdffcc 	andi	r2,r2,63487
 9086b6c:	10ffffcc 	andi	r3,r2,65535
 9086b70:	18c4000c 	andi	r3,r3,4096
 9086b74:	9080030d 	sth	r2,12(r18)
 9086b78:	91000015 	stw	r4,0(r18)
 9086b7c:	18002b26 	beq	r3,zero,9086c2c <_fflush_r+0x160>
 9086b80:	0007883a 	mov	r3,zero
 9086b84:	1805883a 	mov	r2,r3
 9086b88:	94001415 	stw	r16,80(r18)
 9086b8c:	dfc00417 	ldw	ra,16(sp)
 9086b90:	dcc00317 	ldw	r19,12(sp)
 9086b94:	dc800217 	ldw	r18,8(sp)
 9086b98:	dc400117 	ldw	r17,4(sp)
 9086b9c:	dc000017 	ldw	r16,0(sp)
 9086ba0:	dec00504 	addi	sp,sp,20
 9086ba4:	f800283a 	ret
 9086ba8:	94400417 	ldw	r17,16(r18)
 9086bac:	88001f26 	beq	r17,zero,9086c2c <_fflush_r+0x160>
 9086bb0:	90800017 	ldw	r2,0(r18)
 9086bb4:	18c000cc 	andi	r3,r3,3
 9086bb8:	94400015 	stw	r17,0(r18)
 9086bbc:	1461c83a 	sub	r16,r2,r17
 9086bc0:	18002526 	beq	r3,zero,9086c58 <_fflush_r+0x18c>
 9086bc4:	0005883a 	mov	r2,zero
 9086bc8:	90800215 	stw	r2,8(r18)
 9086bcc:	0400170e 	bge	zero,r16,9086c2c <_fflush_r+0x160>
 9086bd0:	90c00917 	ldw	r3,36(r18)
 9086bd4:	91400717 	ldw	r5,28(r18)
 9086bd8:	880d883a 	mov	r6,r17
 9086bdc:	800f883a 	mov	r7,r16
 9086be0:	9809883a 	mov	r4,r19
 9086be4:	183ee83a 	callr	r3
 9086be8:	88a3883a 	add	r17,r17,r2
 9086bec:	80a1c83a 	sub	r16,r16,r2
 9086bf0:	00bff616 	blt	zero,r2,9086bcc <_fflush_r+0x100>
 9086bf4:	9080030b 	ldhu	r2,12(r18)
 9086bf8:	00ffffc4 	movi	r3,-1
 9086bfc:	10801014 	ori	r2,r2,64
 9086c00:	9080030d 	sth	r2,12(r18)
 9086c04:	1805883a 	mov	r2,r3
 9086c08:	dfc00417 	ldw	ra,16(sp)
 9086c0c:	dcc00317 	ldw	r19,12(sp)
 9086c10:	dc800217 	ldw	r18,8(sp)
 9086c14:	dc400117 	ldw	r17,4(sp)
 9086c18:	dc000017 	ldw	r16,0(sp)
 9086c1c:	dec00504 	addi	sp,sp,20
 9086c20:	f800283a 	ret
 9086c24:	90800f17 	ldw	r2,60(r18)
 9086c28:	00bfbe16 	blt	zero,r2,9086b24 <_fflush_r+0x58>
 9086c2c:	0007883a 	mov	r3,zero
 9086c30:	1805883a 	mov	r2,r3
 9086c34:	dfc00417 	ldw	ra,16(sp)
 9086c38:	dcc00317 	ldw	r19,12(sp)
 9086c3c:	dc800217 	ldw	r18,8(sp)
 9086c40:	dc400117 	ldw	r17,4(sp)
 9086c44:	dc000017 	ldw	r16,0(sp)
 9086c48:	dec00504 	addi	sp,sp,20
 9086c4c:	f800283a 	ret
 9086c50:	9086d640 	call	9086d64 <__sinit>
 9086c54:	003fa806 	br	9086af8 <_fflush_r+0x2c>
 9086c58:	90800517 	ldw	r2,20(r18)
 9086c5c:	90800215 	stw	r2,8(r18)
 9086c60:	003fda06 	br	9086bcc <_fflush_r+0x100>
 9086c64:	90800117 	ldw	r2,4(r18)
 9086c68:	90c00c17 	ldw	r3,48(r18)
 9086c6c:	80a1c83a 	sub	r16,r16,r2
 9086c70:	183fb426 	beq	r3,zero,9086b44 <_fflush_r+0x78>
 9086c74:	90800f17 	ldw	r2,60(r18)
 9086c78:	80a1c83a 	sub	r16,r16,r2
 9086c7c:	003fb106 	br	9086b44 <_fflush_r+0x78>
 9086c80:	91400717 	ldw	r5,28(r18)
 9086c84:	9809883a 	mov	r4,r19
 9086c88:	000d883a 	mov	r6,zero
 9086c8c:	01c00044 	movi	r7,1
 9086c90:	403ee83a 	callr	r8
 9086c94:	1021883a 	mov	r16,r2
 9086c98:	00bfffc4 	movi	r2,-1
 9086c9c:	80800226 	beq	r16,r2,9086ca8 <_fflush_r+0x1dc>
 9086ca0:	92000a17 	ldw	r8,40(r18)
 9086ca4:	003fa406 	br	9086b38 <_fflush_r+0x6c>
 9086ca8:	98c00017 	ldw	r3,0(r19)
 9086cac:	00800744 	movi	r2,29
 9086cb0:	18bfde26 	beq	r3,r2,9086c2c <_fflush_r+0x160>
 9086cb4:	9080030b 	ldhu	r2,12(r18)
 9086cb8:	8007883a 	mov	r3,r16
 9086cbc:	10801014 	ori	r2,r2,64
 9086cc0:	9080030d 	sth	r2,12(r18)
 9086cc4:	003fcf06 	br	9086c04 <_fflush_r+0x138>

09086cc8 <fflush>:
 9086cc8:	01424234 	movhi	r5,2312
 9086ccc:	295ab304 	addi	r5,r5,27340
 9086cd0:	2007883a 	mov	r3,r4
 9086cd4:	20000526 	beq	r4,zero,9086cec <fflush+0x24>
 9086cd8:	00824374 	movhi	r2,2317
 9086cdc:	108b9b04 	addi	r2,r2,11884
 9086ce0:	11000017 	ldw	r4,0(r2)
 9086ce4:	180b883a 	mov	r5,r3
 9086ce8:	9086acc1 	jmpi	9086acc <_fflush_r>
 9086cec:	00824374 	movhi	r2,2317
 9086cf0:	108b9c04 	addi	r2,r2,11888
 9086cf4:	11000017 	ldw	r4,0(r2)
 9086cf8:	90879e41 	jmpi	90879e4 <_fwalk_reent>

09086cfc <std>:
 9086cfc:	00824274 	movhi	r2,2313
 9086d00:	10a7a204 	addi	r2,r2,-24952
 9086d04:	20800b15 	stw	r2,44(r4)
 9086d08:	00824274 	movhi	r2,2313
 9086d0c:	10a7dd04 	addi	r2,r2,-24716
 9086d10:	20800815 	stw	r2,32(r4)
 9086d14:	00c24274 	movhi	r3,2313
 9086d18:	18e7be04 	addi	r3,r3,-24840
 9086d1c:	00824274 	movhi	r2,2313
 9086d20:	10a7a404 	addi	r2,r2,-24944
 9086d24:	2140030d 	sth	r5,12(r4)
 9086d28:	2180038d 	sth	r6,14(r4)
 9086d2c:	20c00915 	stw	r3,36(r4)
 9086d30:	20800a15 	stw	r2,40(r4)
 9086d34:	20000015 	stw	zero,0(r4)
 9086d38:	20000115 	stw	zero,4(r4)
 9086d3c:	20000215 	stw	zero,8(r4)
 9086d40:	20000415 	stw	zero,16(r4)
 9086d44:	20000515 	stw	zero,20(r4)
 9086d48:	20000615 	stw	zero,24(r4)
 9086d4c:	21000715 	stw	r4,28(r4)
 9086d50:	f800283a 	ret

09086d54 <__sfp_lock_acquire>:
 9086d54:	f800283a 	ret

09086d58 <__sfp_lock_release>:
 9086d58:	f800283a 	ret

09086d5c <__sinit_lock_acquire>:
 9086d5c:	f800283a 	ret

09086d60 <__sinit_lock_release>:
 9086d60:	f800283a 	ret

09086d64 <__sinit>:
 9086d64:	20800e17 	ldw	r2,56(r4)
 9086d68:	defffd04 	addi	sp,sp,-12
 9086d6c:	dc400115 	stw	r17,4(sp)
 9086d70:	dc000015 	stw	r16,0(sp)
 9086d74:	dfc00215 	stw	ra,8(sp)
 9086d78:	04400044 	movi	r17,1
 9086d7c:	01400104 	movi	r5,4
 9086d80:	000d883a 	mov	r6,zero
 9086d84:	2021883a 	mov	r16,r4
 9086d88:	2200bb04 	addi	r8,r4,748
 9086d8c:	200f883a 	mov	r7,r4
 9086d90:	10000526 	beq	r2,zero,9086da8 <__sinit+0x44>
 9086d94:	dfc00217 	ldw	ra,8(sp)
 9086d98:	dc400117 	ldw	r17,4(sp)
 9086d9c:	dc000017 	ldw	r16,0(sp)
 9086da0:	dec00304 	addi	sp,sp,12
 9086da4:	f800283a 	ret
 9086da8:	21000117 	ldw	r4,4(r4)
 9086dac:	00824234 	movhi	r2,2312
 9086db0:	109b9204 	addi	r2,r2,28232
 9086db4:	00c000c4 	movi	r3,3
 9086db8:	80800f15 	stw	r2,60(r16)
 9086dbc:	80c0b915 	stw	r3,740(r16)
 9086dc0:	8200ba15 	stw	r8,744(r16)
 9086dc4:	84400e15 	stw	r17,56(r16)
 9086dc8:	8000b815 	stw	zero,736(r16)
 9086dcc:	9086cfc0 	call	9086cfc <std>
 9086dd0:	81000217 	ldw	r4,8(r16)
 9086dd4:	880d883a 	mov	r6,r17
 9086dd8:	800f883a 	mov	r7,r16
 9086ddc:	01400284 	movi	r5,10
 9086de0:	9086cfc0 	call	9086cfc <std>
 9086de4:	81000317 	ldw	r4,12(r16)
 9086de8:	800f883a 	mov	r7,r16
 9086dec:	01400484 	movi	r5,18
 9086df0:	01800084 	movi	r6,2
 9086df4:	dfc00217 	ldw	ra,8(sp)
 9086df8:	dc400117 	ldw	r17,4(sp)
 9086dfc:	dc000017 	ldw	r16,0(sp)
 9086e00:	dec00304 	addi	sp,sp,12
 9086e04:	9086cfc1 	jmpi	9086cfc <std>

09086e08 <__fp_lock>:
 9086e08:	0005883a 	mov	r2,zero
 9086e0c:	f800283a 	ret

09086e10 <__fp_unlock>:
 9086e10:	0005883a 	mov	r2,zero
 9086e14:	f800283a 	ret

09086e18 <__fp_unlock_all>:
 9086e18:	00824374 	movhi	r2,2317
 9086e1c:	108b9b04 	addi	r2,r2,11884
 9086e20:	11000017 	ldw	r4,0(r2)
 9086e24:	01424234 	movhi	r5,2312
 9086e28:	295b8404 	addi	r5,r5,28176
 9086e2c:	9087aac1 	jmpi	9087aac <_fwalk>

09086e30 <__fp_lock_all>:
 9086e30:	00824374 	movhi	r2,2317
 9086e34:	108b9b04 	addi	r2,r2,11884
 9086e38:	11000017 	ldw	r4,0(r2)
 9086e3c:	01424234 	movhi	r5,2312
 9086e40:	295b8204 	addi	r5,r5,28168
 9086e44:	9087aac1 	jmpi	9087aac <_fwalk>

09086e48 <_cleanup_r>:
 9086e48:	01424274 	movhi	r5,2313
 9086e4c:	2968cf04 	addi	r5,r5,-23748
 9086e50:	9087aac1 	jmpi	9087aac <_fwalk>

09086e54 <_cleanup>:
 9086e54:	00824374 	movhi	r2,2317
 9086e58:	108b9c04 	addi	r2,r2,11888
 9086e5c:	11000017 	ldw	r4,0(r2)
 9086e60:	9086e481 	jmpi	9086e48 <_cleanup_r>

09086e64 <__sfmoreglue>:
 9086e64:	defffc04 	addi	sp,sp,-16
 9086e68:	dc400115 	stw	r17,4(sp)
 9086e6c:	2c401724 	muli	r17,r5,92
 9086e70:	dc800215 	stw	r18,8(sp)
 9086e74:	2825883a 	mov	r18,r5
 9086e78:	89400304 	addi	r5,r17,12
 9086e7c:	dc000015 	stw	r16,0(sp)
 9086e80:	dfc00315 	stw	ra,12(sp)
 9086e84:	9087dbc0 	call	9087dbc <_malloc_r>
 9086e88:	0021883a 	mov	r16,zero
 9086e8c:	880d883a 	mov	r6,r17
 9086e90:	000b883a 	mov	r5,zero
 9086e94:	10000626 	beq	r2,zero,9086eb0 <__sfmoreglue+0x4c>
 9086e98:	11000304 	addi	r4,r2,12
 9086e9c:	14800115 	stw	r18,4(r2)
 9086ea0:	10000015 	stw	zero,0(r2)
 9086ea4:	11000215 	stw	r4,8(r2)
 9086ea8:	1021883a 	mov	r16,r2
 9086eac:	90823f80 	call	90823f8 <memset>
 9086eb0:	8005883a 	mov	r2,r16
 9086eb4:	dfc00317 	ldw	ra,12(sp)
 9086eb8:	dc800217 	ldw	r18,8(sp)
 9086ebc:	dc400117 	ldw	r17,4(sp)
 9086ec0:	dc000017 	ldw	r16,0(sp)
 9086ec4:	dec00404 	addi	sp,sp,16
 9086ec8:	f800283a 	ret

09086ecc <__sfp>:
 9086ecc:	defffd04 	addi	sp,sp,-12
 9086ed0:	00824374 	movhi	r2,2317
 9086ed4:	108b9c04 	addi	r2,r2,11888
 9086ed8:	dc000015 	stw	r16,0(sp)
 9086edc:	14000017 	ldw	r16,0(r2)
 9086ee0:	dc400115 	stw	r17,4(sp)
 9086ee4:	dfc00215 	stw	ra,8(sp)
 9086ee8:	80800e17 	ldw	r2,56(r16)
 9086eec:	2023883a 	mov	r17,r4
 9086ef0:	10002626 	beq	r2,zero,9086f8c <__sfp+0xc0>
 9086ef4:	8400b804 	addi	r16,r16,736
 9086ef8:	80800117 	ldw	r2,4(r16)
 9086efc:	81000217 	ldw	r4,8(r16)
 9086f00:	10ffffc4 	addi	r3,r2,-1
 9086f04:	18000916 	blt	r3,zero,9086f2c <__sfp+0x60>
 9086f08:	2080030f 	ldh	r2,12(r4)
 9086f0c:	10000b26 	beq	r2,zero,9086f3c <__sfp+0x70>
 9086f10:	017fffc4 	movi	r5,-1
 9086f14:	00000206 	br	9086f20 <__sfp+0x54>
 9086f18:	2080030f 	ldh	r2,12(r4)
 9086f1c:	10000726 	beq	r2,zero,9086f3c <__sfp+0x70>
 9086f20:	18ffffc4 	addi	r3,r3,-1
 9086f24:	21001704 	addi	r4,r4,92
 9086f28:	197ffb1e 	bne	r3,r5,9086f18 <__sfp+0x4c>
 9086f2c:	80800017 	ldw	r2,0(r16)
 9086f30:	10001926 	beq	r2,zero,9086f98 <__sfp+0xcc>
 9086f34:	1021883a 	mov	r16,r2
 9086f38:	003fef06 	br	9086ef8 <__sfp+0x2c>
 9086f3c:	00bfffc4 	movi	r2,-1
 9086f40:	00c00044 	movi	r3,1
 9086f44:	2080038d 	sth	r2,14(r4)
 9086f48:	20c0030d 	sth	r3,12(r4)
 9086f4c:	20000015 	stw	zero,0(r4)
 9086f50:	20000215 	stw	zero,8(r4)
 9086f54:	20000115 	stw	zero,4(r4)
 9086f58:	20000415 	stw	zero,16(r4)
 9086f5c:	20000515 	stw	zero,20(r4)
 9086f60:	20000615 	stw	zero,24(r4)
 9086f64:	20000c15 	stw	zero,48(r4)
 9086f68:	20000d15 	stw	zero,52(r4)
 9086f6c:	20001115 	stw	zero,68(r4)
 9086f70:	20001215 	stw	zero,72(r4)
 9086f74:	2005883a 	mov	r2,r4
 9086f78:	dfc00217 	ldw	ra,8(sp)
 9086f7c:	dc400117 	ldw	r17,4(sp)
 9086f80:	dc000017 	ldw	r16,0(sp)
 9086f84:	dec00304 	addi	sp,sp,12
 9086f88:	f800283a 	ret
 9086f8c:	8009883a 	mov	r4,r16
 9086f90:	9086d640 	call	9086d64 <__sinit>
 9086f94:	003fd706 	br	9086ef4 <__sfp+0x28>
 9086f98:	8809883a 	mov	r4,r17
 9086f9c:	01400104 	movi	r5,4
 9086fa0:	9086e640 	call	9086e64 <__sfmoreglue>
 9086fa4:	80800015 	stw	r2,0(r16)
 9086fa8:	103fe21e 	bne	r2,zero,9086f34 <__sfp+0x68>
 9086fac:	00800304 	movi	r2,12
 9086fb0:	0009883a 	mov	r4,zero
 9086fb4:	88800015 	stw	r2,0(r17)
 9086fb8:	003fee06 	br	9086f74 <__sfp+0xa8>

09086fbc <fputc>:
 9086fbc:	defffc04 	addi	sp,sp,-16
 9086fc0:	dc800215 	stw	r18,8(sp)
 9086fc4:	04824374 	movhi	r18,2317
 9086fc8:	948b9b04 	addi	r18,r18,11884
 9086fcc:	90c00017 	ldw	r3,0(r18)
 9086fd0:	dc400115 	stw	r17,4(sp)
 9086fd4:	dc000015 	stw	r16,0(sp)
 9086fd8:	dfc00315 	stw	ra,12(sp)
 9086fdc:	2021883a 	mov	r16,r4
 9086fe0:	2823883a 	mov	r17,r5
 9086fe4:	18000326 	beq	r3,zero,9086ff4 <fputc+0x38>
 9086fe8:	18800e17 	ldw	r2,56(r3)
 9086fec:	1809883a 	mov	r4,r3
 9086ff0:	10000926 	beq	r2,zero,9087018 <fputc+0x5c>
 9086ff4:	91000017 	ldw	r4,0(r18)
 9086ff8:	800b883a 	mov	r5,r16
 9086ffc:	880d883a 	mov	r6,r17
 9087000:	dfc00317 	ldw	ra,12(sp)
 9087004:	dc800217 	ldw	r18,8(sp)
 9087008:	dc400117 	ldw	r17,4(sp)
 908700c:	dc000017 	ldw	r16,0(sp)
 9087010:	dec00404 	addi	sp,sp,16
 9087014:	908268c1 	jmpi	908268c <_putc_r>
 9087018:	9086d640 	call	9086d64 <__sinit>
 908701c:	003ff506 	br	9086ff4 <fputc+0x38>

09087020 <_fputc_r>:
 9087020:	defffc04 	addi	sp,sp,-16
 9087024:	dc800215 	stw	r18,8(sp)
 9087028:	dc400115 	stw	r17,4(sp)
 908702c:	dc000015 	stw	r16,0(sp)
 9087030:	dfc00315 	stw	ra,12(sp)
 9087034:	2021883a 	mov	r16,r4
 9087038:	2823883a 	mov	r17,r5
 908703c:	3025883a 	mov	r18,r6
 9087040:	20000226 	beq	r4,zero,908704c <_fputc_r+0x2c>
 9087044:	20800e17 	ldw	r2,56(r4)
 9087048:	10000926 	beq	r2,zero,9087070 <_fputc_r+0x50>
 908704c:	8009883a 	mov	r4,r16
 9087050:	880b883a 	mov	r5,r17
 9087054:	900d883a 	mov	r6,r18
 9087058:	dfc00317 	ldw	ra,12(sp)
 908705c:	dc800217 	ldw	r18,8(sp)
 9087060:	dc400117 	ldw	r17,4(sp)
 9087064:	dc000017 	ldw	r16,0(sp)
 9087068:	dec00404 	addi	sp,sp,16
 908706c:	908268c1 	jmpi	908268c <_putc_r>
 9087070:	9086d640 	call	9086d64 <__sinit>
 9087074:	003ff506 	br	908704c <_fputc_r+0x2c>

09087078 <_fputs_r>:
 9087078:	defff804 	addi	sp,sp,-32
 908707c:	dc000515 	stw	r16,20(sp)
 9087080:	2021883a 	mov	r16,r4
 9087084:	2809883a 	mov	r4,r5
 9087088:	dc400615 	stw	r17,24(sp)
 908708c:	dfc00715 	stw	ra,28(sp)
 9087090:	3023883a 	mov	r17,r6
 9087094:	d9400015 	stw	r5,0(sp)
 9087098:	90830d40 	call	90830d4 <strlen>
 908709c:	00c00044 	movi	r3,1
 90870a0:	d8800115 	stw	r2,4(sp)
 90870a4:	d8c00315 	stw	r3,12(sp)
 90870a8:	d8800415 	stw	r2,16(sp)
 90870ac:	dec00215 	stw	sp,8(sp)
 90870b0:	80000326 	beq	r16,zero,90870c0 <_fputs_r+0x48>
 90870b4:	80800e17 	ldw	r2,56(r16)
 90870b8:	8009883a 	mov	r4,r16
 90870bc:	10000926 	beq	r2,zero,90870e4 <_fputs_r+0x6c>
 90870c0:	8009883a 	mov	r4,r16
 90870c4:	880b883a 	mov	r5,r17
 90870c8:	d9800204 	addi	r6,sp,8
 90870cc:	90875480 	call	9087548 <__sfvwrite_r>
 90870d0:	dfc00717 	ldw	ra,28(sp)
 90870d4:	dc400617 	ldw	r17,24(sp)
 90870d8:	dc000517 	ldw	r16,20(sp)
 90870dc:	dec00804 	addi	sp,sp,32
 90870e0:	f800283a 	ret
 90870e4:	9086d640 	call	9086d64 <__sinit>
 90870e8:	003ff506 	br	90870c0 <_fputs_r+0x48>

090870ec <fputs>:
 90870ec:	01824374 	movhi	r6,2317
 90870f0:	318b9b04 	addi	r6,r6,11884
 90870f4:	2007883a 	mov	r3,r4
 90870f8:	31000017 	ldw	r4,0(r6)
 90870fc:	280d883a 	mov	r6,r5
 9087100:	180b883a 	mov	r5,r3
 9087104:	90870781 	jmpi	9087078 <_fputs_r>

09087108 <_malloc_trim_r>:
 9087108:	defffb04 	addi	sp,sp,-20
 908710c:	dcc00315 	stw	r19,12(sp)
 9087110:	04c24374 	movhi	r19,2317
 9087114:	9cc4f404 	addi	r19,r19,5072
 9087118:	dc800215 	stw	r18,8(sp)
 908711c:	dc400115 	stw	r17,4(sp)
 9087120:	dc000015 	stw	r16,0(sp)
 9087124:	2823883a 	mov	r17,r5
 9087128:	2025883a 	mov	r18,r4
 908712c:	dfc00415 	stw	ra,16(sp)
 9087130:	908cedc0 	call	908cedc <__malloc_lock>
 9087134:	98800217 	ldw	r2,8(r19)
 9087138:	9009883a 	mov	r4,r18
 908713c:	000b883a 	mov	r5,zero
 9087140:	10c00117 	ldw	r3,4(r2)
 9087144:	00bfff04 	movi	r2,-4
 9087148:	18a0703a 	and	r16,r3,r2
 908714c:	8463c83a 	sub	r17,r16,r17
 9087150:	8c43fbc4 	addi	r17,r17,4079
 9087154:	8822d33a 	srli	r17,r17,12
 9087158:	0083ffc4 	movi	r2,4095
 908715c:	8c7fffc4 	addi	r17,r17,-1
 9087160:	8822933a 	slli	r17,r17,12
 9087164:	1440060e 	bge	r2,r17,9087180 <_malloc_trim_r+0x78>
 9087168:	9089e180 	call	9089e18 <_sbrk_r>
 908716c:	98c00217 	ldw	r3,8(r19)
 9087170:	9009883a 	mov	r4,r18
 9087174:	044bc83a 	sub	r5,zero,r17
 9087178:	80c7883a 	add	r3,r16,r3
 908717c:	10c00926 	beq	r2,r3,90871a4 <_malloc_trim_r+0x9c>
 9087180:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9087184:	0005883a 	mov	r2,zero
 9087188:	dfc00417 	ldw	ra,16(sp)
 908718c:	dcc00317 	ldw	r19,12(sp)
 9087190:	dc800217 	ldw	r18,8(sp)
 9087194:	dc400117 	ldw	r17,4(sp)
 9087198:	dc000017 	ldw	r16,0(sp)
 908719c:	dec00504 	addi	sp,sp,20
 90871a0:	f800283a 	ret
 90871a4:	9009883a 	mov	r4,r18
 90871a8:	9089e180 	call	9089e18 <_sbrk_r>
 90871ac:	844dc83a 	sub	r6,r16,r17
 90871b0:	00ffffc4 	movi	r3,-1
 90871b4:	9009883a 	mov	r4,r18
 90871b8:	000b883a 	mov	r5,zero
 90871bc:	01c24374 	movhi	r7,2317
 90871c0:	39cdf304 	addi	r7,r7,14284
 90871c4:	31800054 	ori	r6,r6,1
 90871c8:	10c00926 	beq	r2,r3,90871f0 <_malloc_trim_r+0xe8>
 90871cc:	38800017 	ldw	r2,0(r7)
 90871d0:	98c00217 	ldw	r3,8(r19)
 90871d4:	9009883a 	mov	r4,r18
 90871d8:	1445c83a 	sub	r2,r2,r17
 90871dc:	38800015 	stw	r2,0(r7)
 90871e0:	19800115 	stw	r6,4(r3)
 90871e4:	908cfe40 	call	908cfe4 <__malloc_unlock>
 90871e8:	00800044 	movi	r2,1
 90871ec:	003fe606 	br	9087188 <_malloc_trim_r+0x80>
 90871f0:	9089e180 	call	9089e18 <_sbrk_r>
 90871f4:	99800217 	ldw	r6,8(r19)
 90871f8:	100f883a 	mov	r7,r2
 90871fc:	9009883a 	mov	r4,r18
 9087200:	1187c83a 	sub	r3,r2,r6
 9087204:	008003c4 	movi	r2,15
 9087208:	19400054 	ori	r5,r3,1
 908720c:	10ffdc0e 	bge	r2,r3,9087180 <_malloc_trim_r+0x78>
 9087210:	00824374 	movhi	r2,2317
 9087214:	108ba004 	addi	r2,r2,11904
 9087218:	10c00017 	ldw	r3,0(r2)
 908721c:	00824374 	movhi	r2,2317
 9087220:	108df304 	addi	r2,r2,14284
 9087224:	31400115 	stw	r5,4(r6)
 9087228:	38c7c83a 	sub	r3,r7,r3
 908722c:	10c00015 	stw	r3,0(r2)
 9087230:	003fd306 	br	9087180 <_malloc_trim_r+0x78>

09087234 <_free_r>:
 9087234:	defffd04 	addi	sp,sp,-12
 9087238:	dc400115 	stw	r17,4(sp)
 908723c:	dc000015 	stw	r16,0(sp)
 9087240:	dfc00215 	stw	ra,8(sp)
 9087244:	2821883a 	mov	r16,r5
 9087248:	2023883a 	mov	r17,r4
 908724c:	28005a26 	beq	r5,zero,90873b8 <_free_r+0x184>
 9087250:	908cedc0 	call	908cedc <__malloc_lock>
 9087254:	823ffe04 	addi	r8,r16,-8
 9087258:	41400117 	ldw	r5,4(r8)
 908725c:	00bfff84 	movi	r2,-2
 9087260:	02824374 	movhi	r10,2317
 9087264:	5284f404 	addi	r10,r10,5072
 9087268:	288e703a 	and	r7,r5,r2
 908726c:	41cd883a 	add	r6,r8,r7
 9087270:	30c00117 	ldw	r3,4(r6)
 9087274:	51000217 	ldw	r4,8(r10)
 9087278:	00bfff04 	movi	r2,-4
 908727c:	1892703a 	and	r9,r3,r2
 9087280:	5017883a 	mov	r11,r10
 9087284:	31006726 	beq	r6,r4,9087424 <_free_r+0x1f0>
 9087288:	2880004c 	andi	r2,r5,1
 908728c:	1005003a 	cmpeq	r2,r2,zero
 9087290:	32400115 	stw	r9,4(r6)
 9087294:	10001a1e 	bne	r2,zero,9087300 <_free_r+0xcc>
 9087298:	000b883a 	mov	r5,zero
 908729c:	3247883a 	add	r3,r6,r9
 90872a0:	18800117 	ldw	r2,4(r3)
 90872a4:	1080004c 	andi	r2,r2,1
 90872a8:	1000231e 	bne	r2,zero,9087338 <_free_r+0x104>
 90872ac:	280ac03a 	cmpne	r5,r5,zero
 90872b0:	3a4f883a 	add	r7,r7,r9
 90872b4:	2800451e 	bne	r5,zero,90873cc <_free_r+0x198>
 90872b8:	31000217 	ldw	r4,8(r6)
 90872bc:	00824374 	movhi	r2,2317
 90872c0:	1084f604 	addi	r2,r2,5080
 90872c4:	20807b26 	beq	r4,r2,90874b4 <_free_r+0x280>
 90872c8:	30800317 	ldw	r2,12(r6)
 90872cc:	3a07883a 	add	r3,r7,r8
 90872d0:	19c00015 	stw	r7,0(r3)
 90872d4:	11000215 	stw	r4,8(r2)
 90872d8:	20800315 	stw	r2,12(r4)
 90872dc:	38800054 	ori	r2,r7,1
 90872e0:	40800115 	stw	r2,4(r8)
 90872e4:	28001a26 	beq	r5,zero,9087350 <_free_r+0x11c>
 90872e8:	8809883a 	mov	r4,r17
 90872ec:	dfc00217 	ldw	ra,8(sp)
 90872f0:	dc400117 	ldw	r17,4(sp)
 90872f4:	dc000017 	ldw	r16,0(sp)
 90872f8:	dec00304 	addi	sp,sp,12
 90872fc:	908cfe41 	jmpi	908cfe4 <__malloc_unlock>
 9087300:	80bffe17 	ldw	r2,-8(r16)
 9087304:	50c00204 	addi	r3,r10,8
 9087308:	4091c83a 	sub	r8,r8,r2
 908730c:	41000217 	ldw	r4,8(r8)
 9087310:	388f883a 	add	r7,r7,r2
 9087314:	20c06126 	beq	r4,r3,908749c <_free_r+0x268>
 9087318:	40800317 	ldw	r2,12(r8)
 908731c:	3247883a 	add	r3,r6,r9
 9087320:	000b883a 	mov	r5,zero
 9087324:	11000215 	stw	r4,8(r2)
 9087328:	20800315 	stw	r2,12(r4)
 908732c:	18800117 	ldw	r2,4(r3)
 9087330:	1080004c 	andi	r2,r2,1
 9087334:	103fdd26 	beq	r2,zero,90872ac <_free_r+0x78>
 9087338:	38800054 	ori	r2,r7,1
 908733c:	3a07883a 	add	r3,r7,r8
 9087340:	280ac03a 	cmpne	r5,r5,zero
 9087344:	40800115 	stw	r2,4(r8)
 9087348:	19c00015 	stw	r7,0(r3)
 908734c:	283fe61e 	bne	r5,zero,90872e8 <_free_r+0xb4>
 9087350:	00807fc4 	movi	r2,511
 9087354:	11c01f2e 	bgeu	r2,r7,90873d4 <_free_r+0x1a0>
 9087358:	3806d27a 	srli	r3,r7,9
 908735c:	1800481e 	bne	r3,zero,9087480 <_free_r+0x24c>
 9087360:	3804d0fa 	srli	r2,r7,3
 9087364:	100690fa 	slli	r3,r2,3
 9087368:	1acd883a 	add	r6,r3,r11
 908736c:	31400217 	ldw	r5,8(r6)
 9087370:	31405926 	beq	r6,r5,90874d8 <_free_r+0x2a4>
 9087374:	28800117 	ldw	r2,4(r5)
 9087378:	00ffff04 	movi	r3,-4
 908737c:	10c4703a 	and	r2,r2,r3
 9087380:	3880022e 	bgeu	r7,r2,908738c <_free_r+0x158>
 9087384:	29400217 	ldw	r5,8(r5)
 9087388:	317ffa1e 	bne	r6,r5,9087374 <_free_r+0x140>
 908738c:	29800317 	ldw	r6,12(r5)
 9087390:	41800315 	stw	r6,12(r8)
 9087394:	41400215 	stw	r5,8(r8)
 9087398:	8809883a 	mov	r4,r17
 908739c:	2a000315 	stw	r8,12(r5)
 90873a0:	32000215 	stw	r8,8(r6)
 90873a4:	dfc00217 	ldw	ra,8(sp)
 90873a8:	dc400117 	ldw	r17,4(sp)
 90873ac:	dc000017 	ldw	r16,0(sp)
 90873b0:	dec00304 	addi	sp,sp,12
 90873b4:	908cfe41 	jmpi	908cfe4 <__malloc_unlock>
 90873b8:	dfc00217 	ldw	ra,8(sp)
 90873bc:	dc400117 	ldw	r17,4(sp)
 90873c0:	dc000017 	ldw	r16,0(sp)
 90873c4:	dec00304 	addi	sp,sp,12
 90873c8:	f800283a 	ret
 90873cc:	31000217 	ldw	r4,8(r6)
 90873d0:	003fbd06 	br	90872c8 <_free_r+0x94>
 90873d4:	3806d0fa 	srli	r3,r7,3
 90873d8:	00800044 	movi	r2,1
 90873dc:	51400117 	ldw	r5,4(r10)
 90873e0:	180890fa 	slli	r4,r3,3
 90873e4:	1807d0ba 	srai	r3,r3,2
 90873e8:	22c9883a 	add	r4,r4,r11
 90873ec:	21800217 	ldw	r6,8(r4)
 90873f0:	10c4983a 	sll	r2,r2,r3
 90873f4:	41000315 	stw	r4,12(r8)
 90873f8:	41800215 	stw	r6,8(r8)
 90873fc:	288ab03a 	or	r5,r5,r2
 9087400:	22000215 	stw	r8,8(r4)
 9087404:	8809883a 	mov	r4,r17
 9087408:	51400115 	stw	r5,4(r10)
 908740c:	32000315 	stw	r8,12(r6)
 9087410:	dfc00217 	ldw	ra,8(sp)
 9087414:	dc400117 	ldw	r17,4(sp)
 9087418:	dc000017 	ldw	r16,0(sp)
 908741c:	dec00304 	addi	sp,sp,12
 9087420:	908cfe41 	jmpi	908cfe4 <__malloc_unlock>
 9087424:	2880004c 	andi	r2,r5,1
 9087428:	3a4d883a 	add	r6,r7,r9
 908742c:	1000071e 	bne	r2,zero,908744c <_free_r+0x218>
 9087430:	80bffe17 	ldw	r2,-8(r16)
 9087434:	4091c83a 	sub	r8,r8,r2
 9087438:	41000317 	ldw	r4,12(r8)
 908743c:	40c00217 	ldw	r3,8(r8)
 9087440:	308d883a 	add	r6,r6,r2
 9087444:	20c00215 	stw	r3,8(r4)
 9087448:	19000315 	stw	r4,12(r3)
 908744c:	00824374 	movhi	r2,2317
 9087450:	108b9f04 	addi	r2,r2,11900
 9087454:	11000017 	ldw	r4,0(r2)
 9087458:	30c00054 	ori	r3,r6,1
 908745c:	52000215 	stw	r8,8(r10)
 9087460:	40c00115 	stw	r3,4(r8)
 9087464:	313fa036 	bltu	r6,r4,90872e8 <_free_r+0xb4>
 9087468:	00824374 	movhi	r2,2317
 908746c:	108bfa04 	addi	r2,r2,12264
 9087470:	11400017 	ldw	r5,0(r2)
 9087474:	8809883a 	mov	r4,r17
 9087478:	90871080 	call	9087108 <_malloc_trim_r>
 908747c:	003f9a06 	br	90872e8 <_free_r+0xb4>
 9087480:	00800104 	movi	r2,4
 9087484:	10c0072e 	bgeu	r2,r3,90874a4 <_free_r+0x270>
 9087488:	00800504 	movi	r2,20
 908748c:	10c01936 	bltu	r2,r3,90874f4 <_free_r+0x2c0>
 9087490:	188016c4 	addi	r2,r3,91
 9087494:	100690fa 	slli	r3,r2,3
 9087498:	003fb306 	br	9087368 <_free_r+0x134>
 908749c:	01400044 	movi	r5,1
 90874a0:	003f7e06 	br	908729c <_free_r+0x68>
 90874a4:	3804d1ba 	srli	r2,r7,6
 90874a8:	10800e04 	addi	r2,r2,56
 90874ac:	100690fa 	slli	r3,r2,3
 90874b0:	003fad06 	br	9087368 <_free_r+0x134>
 90874b4:	22000315 	stw	r8,12(r4)
 90874b8:	22000215 	stw	r8,8(r4)
 90874bc:	3a05883a 	add	r2,r7,r8
 90874c0:	38c00054 	ori	r3,r7,1
 90874c4:	11c00015 	stw	r7,0(r2)
 90874c8:	41000215 	stw	r4,8(r8)
 90874cc:	40c00115 	stw	r3,4(r8)
 90874d0:	41000315 	stw	r4,12(r8)
 90874d4:	003f8406 	br	90872e8 <_free_r+0xb4>
 90874d8:	1005d0ba 	srai	r2,r2,2
 90874dc:	00c00044 	movi	r3,1
 90874e0:	51000117 	ldw	r4,4(r10)
 90874e4:	1886983a 	sll	r3,r3,r2
 90874e8:	20c8b03a 	or	r4,r4,r3
 90874ec:	51000115 	stw	r4,4(r10)
 90874f0:	003fa706 	br	9087390 <_free_r+0x15c>
 90874f4:	00801504 	movi	r2,84
 90874f8:	10c00436 	bltu	r2,r3,908750c <_free_r+0x2d8>
 90874fc:	3804d33a 	srli	r2,r7,12
 9087500:	10801b84 	addi	r2,r2,110
 9087504:	100690fa 	slli	r3,r2,3
 9087508:	003f9706 	br	9087368 <_free_r+0x134>
 908750c:	00805504 	movi	r2,340
 9087510:	10c00436 	bltu	r2,r3,9087524 <_free_r+0x2f0>
 9087514:	3804d3fa 	srli	r2,r7,15
 9087518:	10801dc4 	addi	r2,r2,119
 908751c:	100690fa 	slli	r3,r2,3
 9087520:	003f9106 	br	9087368 <_free_r+0x134>
 9087524:	00815504 	movi	r2,1364
 9087528:	10c0032e 	bgeu	r2,r3,9087538 <_free_r+0x304>
 908752c:	00801f84 	movi	r2,126
 9087530:	00c0fc04 	movi	r3,1008
 9087534:	003f8c06 	br	9087368 <_free_r+0x134>
 9087538:	3804d4ba 	srli	r2,r7,18
 908753c:	10801f04 	addi	r2,r2,124
 9087540:	100690fa 	slli	r3,r2,3
 9087544:	003f8806 	br	9087368 <_free_r+0x134>

09087548 <__sfvwrite_r>:
 9087548:	30800217 	ldw	r2,8(r6)
 908754c:	defff504 	addi	sp,sp,-44
 9087550:	df000915 	stw	fp,36(sp)
 9087554:	dd800715 	stw	r22,28(sp)
 9087558:	dc800315 	stw	r18,12(sp)
 908755c:	dfc00a15 	stw	ra,40(sp)
 9087560:	ddc00815 	stw	r23,32(sp)
 9087564:	dd400615 	stw	r21,24(sp)
 9087568:	dd000515 	stw	r20,20(sp)
 908756c:	dcc00415 	stw	r19,16(sp)
 9087570:	dc400215 	stw	r17,8(sp)
 9087574:	dc000115 	stw	r16,4(sp)
 9087578:	302d883a 	mov	r22,r6
 908757c:	2039883a 	mov	fp,r4
 9087580:	2825883a 	mov	r18,r5
 9087584:	10001c26 	beq	r2,zero,90875f8 <__sfvwrite_r+0xb0>
 9087588:	29c0030b 	ldhu	r7,12(r5)
 908758c:	3880020c 	andi	r2,r7,8
 9087590:	10002726 	beq	r2,zero,9087630 <__sfvwrite_r+0xe8>
 9087594:	28800417 	ldw	r2,16(r5)
 9087598:	10002526 	beq	r2,zero,9087630 <__sfvwrite_r+0xe8>
 908759c:	3880008c 	andi	r2,r7,2
 90875a0:	b5400017 	ldw	r21,0(r22)
 90875a4:	10002826 	beq	r2,zero,9087648 <__sfvwrite_r+0x100>
 90875a8:	0021883a 	mov	r16,zero
 90875ac:	0023883a 	mov	r17,zero
 90875b0:	880d883a 	mov	r6,r17
 90875b4:	e009883a 	mov	r4,fp
 90875b8:	00810004 	movi	r2,1024
 90875bc:	80006e26 	beq	r16,zero,9087778 <__sfvwrite_r+0x230>
 90875c0:	800f883a 	mov	r7,r16
 90875c4:	91400717 	ldw	r5,28(r18)
 90875c8:	1400012e 	bgeu	r2,r16,90875d0 <__sfvwrite_r+0x88>
 90875cc:	100f883a 	mov	r7,r2
 90875d0:	90c00917 	ldw	r3,36(r18)
 90875d4:	183ee83a 	callr	r3
 90875d8:	1007883a 	mov	r3,r2
 90875dc:	80a1c83a 	sub	r16,r16,r2
 90875e0:	88a3883a 	add	r17,r17,r2
 90875e4:	00806d0e 	bge	zero,r2,908779c <__sfvwrite_r+0x254>
 90875e8:	b0800217 	ldw	r2,8(r22)
 90875ec:	10c5c83a 	sub	r2,r2,r3
 90875f0:	b0800215 	stw	r2,8(r22)
 90875f4:	103fee1e 	bne	r2,zero,90875b0 <__sfvwrite_r+0x68>
 90875f8:	0009883a 	mov	r4,zero
 90875fc:	2005883a 	mov	r2,r4
 9087600:	dfc00a17 	ldw	ra,40(sp)
 9087604:	df000917 	ldw	fp,36(sp)
 9087608:	ddc00817 	ldw	r23,32(sp)
 908760c:	dd800717 	ldw	r22,28(sp)
 9087610:	dd400617 	ldw	r21,24(sp)
 9087614:	dd000517 	ldw	r20,20(sp)
 9087618:	dcc00417 	ldw	r19,16(sp)
 908761c:	dc800317 	ldw	r18,12(sp)
 9087620:	dc400217 	ldw	r17,8(sp)
 9087624:	dc000117 	ldw	r16,4(sp)
 9087628:	dec00b04 	addi	sp,sp,44
 908762c:	f800283a 	ret
 9087630:	90851c40 	call	90851c4 <__swsetup_r>
 9087634:	1000e41e 	bne	r2,zero,90879c8 <__sfvwrite_r+0x480>
 9087638:	91c0030b 	ldhu	r7,12(r18)
 908763c:	b5400017 	ldw	r21,0(r22)
 9087640:	3880008c 	andi	r2,r7,2
 9087644:	103fd81e 	bne	r2,zero,90875a8 <__sfvwrite_r+0x60>
 9087648:	3880004c 	andi	r2,r7,1
 908764c:	1005003a 	cmpeq	r2,r2,zero
 9087650:	10005726 	beq	r2,zero,90877b0 <__sfvwrite_r+0x268>
 9087654:	0029883a 	mov	r20,zero
 9087658:	002f883a 	mov	r23,zero
 908765c:	a0004226 	beq	r20,zero,9087768 <__sfvwrite_r+0x220>
 9087660:	3880800c 	andi	r2,r7,512
 9087664:	94000217 	ldw	r16,8(r18)
 9087668:	10008b26 	beq	r2,zero,9087898 <__sfvwrite_r+0x350>
 908766c:	800d883a 	mov	r6,r16
 9087670:	a400a536 	bltu	r20,r16,9087908 <__sfvwrite_r+0x3c0>
 9087674:	3881200c 	andi	r2,r7,1152
 9087678:	10002726 	beq	r2,zero,9087718 <__sfvwrite_r+0x1d0>
 908767c:	90800517 	ldw	r2,20(r18)
 9087680:	92000417 	ldw	r8,16(r18)
 9087684:	91400017 	ldw	r5,0(r18)
 9087688:	1087883a 	add	r3,r2,r2
 908768c:	1887883a 	add	r3,r3,r2
 9087690:	1808d7fa 	srli	r4,r3,31
 9087694:	2a21c83a 	sub	r16,r5,r8
 9087698:	80800044 	addi	r2,r16,1
 908769c:	20c9883a 	add	r4,r4,r3
 90876a0:	2027d07a 	srai	r19,r4,1
 90876a4:	a085883a 	add	r2,r20,r2
 90876a8:	980d883a 	mov	r6,r19
 90876ac:	9880022e 	bgeu	r19,r2,90876b8 <__sfvwrite_r+0x170>
 90876b0:	1027883a 	mov	r19,r2
 90876b4:	100d883a 	mov	r6,r2
 90876b8:	3881000c 	andi	r2,r7,1024
 90876bc:	1000b826 	beq	r2,zero,90879a0 <__sfvwrite_r+0x458>
 90876c0:	300b883a 	mov	r5,r6
 90876c4:	e009883a 	mov	r4,fp
 90876c8:	9087dbc0 	call	9087dbc <_malloc_r>
 90876cc:	10003126 	beq	r2,zero,9087794 <__sfvwrite_r+0x24c>
 90876d0:	91400417 	ldw	r5,16(r18)
 90876d4:	1009883a 	mov	r4,r2
 90876d8:	800d883a 	mov	r6,r16
 90876dc:	1023883a 	mov	r17,r2
 90876e0:	90822780 	call	9082278 <memcpy>
 90876e4:	90c0030b 	ldhu	r3,12(r18)
 90876e8:	00beffc4 	movi	r2,-1025
 90876ec:	1886703a 	and	r3,r3,r2
 90876f0:	18c02014 	ori	r3,r3,128
 90876f4:	90c0030d 	sth	r3,12(r18)
 90876f8:	9c07c83a 	sub	r3,r19,r16
 90876fc:	8c05883a 	add	r2,r17,r16
 9087700:	a00d883a 	mov	r6,r20
 9087704:	a021883a 	mov	r16,r20
 9087708:	90800015 	stw	r2,0(r18)
 908770c:	90c00215 	stw	r3,8(r18)
 9087710:	94400415 	stw	r17,16(r18)
 9087714:	94c00515 	stw	r19,20(r18)
 9087718:	91000017 	ldw	r4,0(r18)
 908771c:	b80b883a 	mov	r5,r23
 9087720:	a023883a 	mov	r17,r20
 9087724:	90823180 	call	9082318 <memmove>
 9087728:	90c00217 	ldw	r3,8(r18)
 908772c:	90800017 	ldw	r2,0(r18)
 9087730:	a027883a 	mov	r19,r20
 9087734:	1c07c83a 	sub	r3,r3,r16
 9087738:	1405883a 	add	r2,r2,r16
 908773c:	90c00215 	stw	r3,8(r18)
 9087740:	a021883a 	mov	r16,r20
 9087744:	90800015 	stw	r2,0(r18)
 9087748:	b0800217 	ldw	r2,8(r22)
 908774c:	1405c83a 	sub	r2,r2,r16
 9087750:	b0800215 	stw	r2,8(r22)
 9087754:	103fa826 	beq	r2,zero,90875f8 <__sfvwrite_r+0xb0>
 9087758:	a469c83a 	sub	r20,r20,r17
 908775c:	91c0030b 	ldhu	r7,12(r18)
 9087760:	bcef883a 	add	r23,r23,r19
 9087764:	a03fbe1e 	bne	r20,zero,9087660 <__sfvwrite_r+0x118>
 9087768:	adc00017 	ldw	r23,0(r21)
 908776c:	ad000117 	ldw	r20,4(r21)
 9087770:	ad400204 	addi	r21,r21,8
 9087774:	003fb906 	br	908765c <__sfvwrite_r+0x114>
 9087778:	ac400017 	ldw	r17,0(r21)
 908777c:	ac000117 	ldw	r16,4(r21)
 9087780:	ad400204 	addi	r21,r21,8
 9087784:	003f8a06 	br	90875b0 <__sfvwrite_r+0x68>
 9087788:	91400417 	ldw	r5,16(r18)
 908778c:	e009883a 	mov	r4,fp
 9087790:	90872340 	call	9087234 <_free_r>
 9087794:	00800304 	movi	r2,12
 9087798:	e0800015 	stw	r2,0(fp)
 908779c:	9080030b 	ldhu	r2,12(r18)
 90877a0:	013fffc4 	movi	r4,-1
 90877a4:	10801014 	ori	r2,r2,64
 90877a8:	9080030d 	sth	r2,12(r18)
 90877ac:	003f9306 	br	90875fc <__sfvwrite_r+0xb4>
 90877b0:	0027883a 	mov	r19,zero
 90877b4:	002f883a 	mov	r23,zero
 90877b8:	d8000015 	stw	zero,0(sp)
 90877bc:	0029883a 	mov	r20,zero
 90877c0:	98001e26 	beq	r19,zero,908783c <__sfvwrite_r+0x2f4>
 90877c4:	d8c00017 	ldw	r3,0(sp)
 90877c8:	1804c03a 	cmpne	r2,r3,zero
 90877cc:	10005e26 	beq	r2,zero,9087948 <__sfvwrite_r+0x400>
 90877d0:	9821883a 	mov	r16,r19
 90877d4:	a4c0012e 	bgeu	r20,r19,90877dc <__sfvwrite_r+0x294>
 90877d8:	a021883a 	mov	r16,r20
 90877dc:	91000017 	ldw	r4,0(r18)
 90877e0:	90800417 	ldw	r2,16(r18)
 90877e4:	91800217 	ldw	r6,8(r18)
 90877e8:	91c00517 	ldw	r7,20(r18)
 90877ec:	1100022e 	bgeu	r2,r4,90877f8 <__sfvwrite_r+0x2b0>
 90877f0:	31e3883a 	add	r17,r6,r7
 90877f4:	8c001616 	blt	r17,r16,9087850 <__sfvwrite_r+0x308>
 90877f8:	81c03816 	blt	r16,r7,90878dc <__sfvwrite_r+0x394>
 90877fc:	90c00917 	ldw	r3,36(r18)
 9087800:	91400717 	ldw	r5,28(r18)
 9087804:	e009883a 	mov	r4,fp
 9087808:	b80d883a 	mov	r6,r23
 908780c:	183ee83a 	callr	r3
 9087810:	1023883a 	mov	r17,r2
 9087814:	00bfe10e 	bge	zero,r2,908779c <__sfvwrite_r+0x254>
 9087818:	a469c83a 	sub	r20,r20,r17
 908781c:	a0001826 	beq	r20,zero,9087880 <__sfvwrite_r+0x338>
 9087820:	b0800217 	ldw	r2,8(r22)
 9087824:	1445c83a 	sub	r2,r2,r17
 9087828:	b0800215 	stw	r2,8(r22)
 908782c:	103f7226 	beq	r2,zero,90875f8 <__sfvwrite_r+0xb0>
 9087830:	9c67c83a 	sub	r19,r19,r17
 9087834:	bc6f883a 	add	r23,r23,r17
 9087838:	983fe21e 	bne	r19,zero,90877c4 <__sfvwrite_r+0x27c>
 908783c:	adc00017 	ldw	r23,0(r21)
 9087840:	acc00117 	ldw	r19,4(r21)
 9087844:	ad400204 	addi	r21,r21,8
 9087848:	d8000015 	stw	zero,0(sp)
 908784c:	003fdc06 	br	90877c0 <__sfvwrite_r+0x278>
 9087850:	b80b883a 	mov	r5,r23
 9087854:	880d883a 	mov	r6,r17
 9087858:	90823180 	call	9082318 <memmove>
 908785c:	90c00017 	ldw	r3,0(r18)
 9087860:	e009883a 	mov	r4,fp
 9087864:	900b883a 	mov	r5,r18
 9087868:	1c47883a 	add	r3,r3,r17
 908786c:	90c00015 	stw	r3,0(r18)
 9087870:	9086acc0 	call	9086acc <_fflush_r>
 9087874:	103fc91e 	bne	r2,zero,908779c <__sfvwrite_r+0x254>
 9087878:	a469c83a 	sub	r20,r20,r17
 908787c:	a03fe81e 	bne	r20,zero,9087820 <__sfvwrite_r+0x2d8>
 9087880:	e009883a 	mov	r4,fp
 9087884:	900b883a 	mov	r5,r18
 9087888:	9086acc0 	call	9086acc <_fflush_r>
 908788c:	103fc31e 	bne	r2,zero,908779c <__sfvwrite_r+0x254>
 9087890:	d8000015 	stw	zero,0(sp)
 9087894:	003fe206 	br	9087820 <__sfvwrite_r+0x2d8>
 9087898:	91000017 	ldw	r4,0(r18)
 908789c:	90800417 	ldw	r2,16(r18)
 90878a0:	1100022e 	bgeu	r2,r4,90878ac <__sfvwrite_r+0x364>
 90878a4:	8023883a 	mov	r17,r16
 90878a8:	85003136 	bltu	r16,r20,9087970 <__sfvwrite_r+0x428>
 90878ac:	91c00517 	ldw	r7,20(r18)
 90878b0:	a1c01836 	bltu	r20,r7,9087914 <__sfvwrite_r+0x3cc>
 90878b4:	90c00917 	ldw	r3,36(r18)
 90878b8:	91400717 	ldw	r5,28(r18)
 90878bc:	e009883a 	mov	r4,fp
 90878c0:	b80d883a 	mov	r6,r23
 90878c4:	183ee83a 	callr	r3
 90878c8:	1021883a 	mov	r16,r2
 90878cc:	00bfb30e 	bge	zero,r2,908779c <__sfvwrite_r+0x254>
 90878d0:	1023883a 	mov	r17,r2
 90878d4:	1027883a 	mov	r19,r2
 90878d8:	003f9b06 	br	9087748 <__sfvwrite_r+0x200>
 90878dc:	b80b883a 	mov	r5,r23
 90878e0:	800d883a 	mov	r6,r16
 90878e4:	90823180 	call	9082318 <memmove>
 90878e8:	90c00217 	ldw	r3,8(r18)
 90878ec:	90800017 	ldw	r2,0(r18)
 90878f0:	8023883a 	mov	r17,r16
 90878f4:	1c07c83a 	sub	r3,r3,r16
 90878f8:	1405883a 	add	r2,r2,r16
 90878fc:	90c00215 	stw	r3,8(r18)
 9087900:	90800015 	stw	r2,0(r18)
 9087904:	003fc406 	br	9087818 <__sfvwrite_r+0x2d0>
 9087908:	a00d883a 	mov	r6,r20
 908790c:	a021883a 	mov	r16,r20
 9087910:	003f8106 	br	9087718 <__sfvwrite_r+0x1d0>
 9087914:	b80b883a 	mov	r5,r23
 9087918:	a00d883a 	mov	r6,r20
 908791c:	90823180 	call	9082318 <memmove>
 9087920:	90c00217 	ldw	r3,8(r18)
 9087924:	90800017 	ldw	r2,0(r18)
 9087928:	a021883a 	mov	r16,r20
 908792c:	1d07c83a 	sub	r3,r3,r20
 9087930:	1505883a 	add	r2,r2,r20
 9087934:	a023883a 	mov	r17,r20
 9087938:	a027883a 	mov	r19,r20
 908793c:	90c00215 	stw	r3,8(r18)
 9087940:	90800015 	stw	r2,0(r18)
 9087944:	003f8006 	br	9087748 <__sfvwrite_r+0x200>
 9087948:	b809883a 	mov	r4,r23
 908794c:	01400284 	movi	r5,10
 9087950:	980d883a 	mov	r6,r19
 9087954:	90884fc0 	call	90884fc <memchr>
 9087958:	10001726 	beq	r2,zero,90879b8 <__sfvwrite_r+0x470>
 908795c:	15c5c83a 	sub	r2,r2,r23
 9087960:	15000044 	addi	r20,r2,1
 9087964:	00800044 	movi	r2,1
 9087968:	d8800015 	stw	r2,0(sp)
 908796c:	003f9806 	br	90877d0 <__sfvwrite_r+0x288>
 9087970:	b80b883a 	mov	r5,r23
 9087974:	800d883a 	mov	r6,r16
 9087978:	90823180 	call	9082318 <memmove>
 908797c:	90c00017 	ldw	r3,0(r18)
 9087980:	e009883a 	mov	r4,fp
 9087984:	900b883a 	mov	r5,r18
 9087988:	1c07883a 	add	r3,r3,r16
 908798c:	90c00015 	stw	r3,0(r18)
 9087990:	8027883a 	mov	r19,r16
 9087994:	9086acc0 	call	9086acc <_fflush_r>
 9087998:	103f6b26 	beq	r2,zero,9087748 <__sfvwrite_r+0x200>
 908799c:	003f7f06 	br	908779c <__sfvwrite_r+0x254>
 90879a0:	400b883a 	mov	r5,r8
 90879a4:	e009883a 	mov	r4,fp
 90879a8:	90895d40 	call	90895d4 <_realloc_r>
 90879ac:	103f7626 	beq	r2,zero,9087788 <__sfvwrite_r+0x240>
 90879b0:	1023883a 	mov	r17,r2
 90879b4:	003f5006 	br	90876f8 <__sfvwrite_r+0x1b0>
 90879b8:	00c00044 	movi	r3,1
 90879bc:	9d000044 	addi	r20,r19,1
 90879c0:	d8c00015 	stw	r3,0(sp)
 90879c4:	003f8206 	br	90877d0 <__sfvwrite_r+0x288>
 90879c8:	9080030b 	ldhu	r2,12(r18)
 90879cc:	00c00244 	movi	r3,9
 90879d0:	013fffc4 	movi	r4,-1
 90879d4:	10801014 	ori	r2,r2,64
 90879d8:	9080030d 	sth	r2,12(r18)
 90879dc:	e0c00015 	stw	r3,0(fp)
 90879e0:	003f0606 	br	90875fc <__sfvwrite_r+0xb4>

090879e4 <_fwalk_reent>:
 90879e4:	defff704 	addi	sp,sp,-36
 90879e8:	dcc00315 	stw	r19,12(sp)
 90879ec:	24c0b804 	addi	r19,r4,736
 90879f0:	dd800615 	stw	r22,24(sp)
 90879f4:	dd400515 	stw	r21,20(sp)
 90879f8:	dfc00815 	stw	ra,32(sp)
 90879fc:	ddc00715 	stw	r23,28(sp)
 9087a00:	dd000415 	stw	r20,16(sp)
 9087a04:	dc800215 	stw	r18,8(sp)
 9087a08:	dc400115 	stw	r17,4(sp)
 9087a0c:	dc000015 	stw	r16,0(sp)
 9087a10:	202b883a 	mov	r21,r4
 9087a14:	282d883a 	mov	r22,r5
 9087a18:	9086d540 	call	9086d54 <__sfp_lock_acquire>
 9087a1c:	98002126 	beq	r19,zero,9087aa4 <_fwalk_reent+0xc0>
 9087a20:	002f883a 	mov	r23,zero
 9087a24:	9c800117 	ldw	r18,4(r19)
 9087a28:	9c000217 	ldw	r16,8(r19)
 9087a2c:	90bfffc4 	addi	r2,r18,-1
 9087a30:	10000d16 	blt	r2,zero,9087a68 <_fwalk_reent+0x84>
 9087a34:	0023883a 	mov	r17,zero
 9087a38:	053fffc4 	movi	r20,-1
 9087a3c:	8080030f 	ldh	r2,12(r16)
 9087a40:	8c400044 	addi	r17,r17,1
 9087a44:	10000626 	beq	r2,zero,9087a60 <_fwalk_reent+0x7c>
 9087a48:	8080038f 	ldh	r2,14(r16)
 9087a4c:	800b883a 	mov	r5,r16
 9087a50:	a809883a 	mov	r4,r21
 9087a54:	15000226 	beq	r2,r20,9087a60 <_fwalk_reent+0x7c>
 9087a58:	b03ee83a 	callr	r22
 9087a5c:	b8aeb03a 	or	r23,r23,r2
 9087a60:	84001704 	addi	r16,r16,92
 9087a64:	947ff51e 	bne	r18,r17,9087a3c <_fwalk_reent+0x58>
 9087a68:	9cc00017 	ldw	r19,0(r19)
 9087a6c:	983fed1e 	bne	r19,zero,9087a24 <_fwalk_reent+0x40>
 9087a70:	9086d580 	call	9086d58 <__sfp_lock_release>
 9087a74:	b805883a 	mov	r2,r23
 9087a78:	dfc00817 	ldw	ra,32(sp)
 9087a7c:	ddc00717 	ldw	r23,28(sp)
 9087a80:	dd800617 	ldw	r22,24(sp)
 9087a84:	dd400517 	ldw	r21,20(sp)
 9087a88:	dd000417 	ldw	r20,16(sp)
 9087a8c:	dcc00317 	ldw	r19,12(sp)
 9087a90:	dc800217 	ldw	r18,8(sp)
 9087a94:	dc400117 	ldw	r17,4(sp)
 9087a98:	dc000017 	ldw	r16,0(sp)
 9087a9c:	dec00904 	addi	sp,sp,36
 9087aa0:	f800283a 	ret
 9087aa4:	002f883a 	mov	r23,zero
 9087aa8:	003ff106 	br	9087a70 <_fwalk_reent+0x8c>

09087aac <_fwalk>:
 9087aac:	defff804 	addi	sp,sp,-32
 9087ab0:	dcc00315 	stw	r19,12(sp)
 9087ab4:	24c0b804 	addi	r19,r4,736
 9087ab8:	dd400515 	stw	r21,20(sp)
 9087abc:	dfc00715 	stw	ra,28(sp)
 9087ac0:	dd800615 	stw	r22,24(sp)
 9087ac4:	dd000415 	stw	r20,16(sp)
 9087ac8:	dc800215 	stw	r18,8(sp)
 9087acc:	dc400115 	stw	r17,4(sp)
 9087ad0:	dc000015 	stw	r16,0(sp)
 9087ad4:	282b883a 	mov	r21,r5
 9087ad8:	9086d540 	call	9086d54 <__sfp_lock_acquire>
 9087adc:	98001f26 	beq	r19,zero,9087b5c <_fwalk+0xb0>
 9087ae0:	002d883a 	mov	r22,zero
 9087ae4:	9c800117 	ldw	r18,4(r19)
 9087ae8:	9c000217 	ldw	r16,8(r19)
 9087aec:	90bfffc4 	addi	r2,r18,-1
 9087af0:	10000c16 	blt	r2,zero,9087b24 <_fwalk+0x78>
 9087af4:	0023883a 	mov	r17,zero
 9087af8:	053fffc4 	movi	r20,-1
 9087afc:	8080030f 	ldh	r2,12(r16)
 9087b00:	8c400044 	addi	r17,r17,1
 9087b04:	10000526 	beq	r2,zero,9087b1c <_fwalk+0x70>
 9087b08:	8080038f 	ldh	r2,14(r16)
 9087b0c:	8009883a 	mov	r4,r16
 9087b10:	15000226 	beq	r2,r20,9087b1c <_fwalk+0x70>
 9087b14:	a83ee83a 	callr	r21
 9087b18:	b0acb03a 	or	r22,r22,r2
 9087b1c:	84001704 	addi	r16,r16,92
 9087b20:	947ff61e 	bne	r18,r17,9087afc <_fwalk+0x50>
 9087b24:	9cc00017 	ldw	r19,0(r19)
 9087b28:	983fee1e 	bne	r19,zero,9087ae4 <_fwalk+0x38>
 9087b2c:	9086d580 	call	9086d58 <__sfp_lock_release>
 9087b30:	b005883a 	mov	r2,r22
 9087b34:	dfc00717 	ldw	ra,28(sp)
 9087b38:	dd800617 	ldw	r22,24(sp)
 9087b3c:	dd400517 	ldw	r21,20(sp)
 9087b40:	dd000417 	ldw	r20,16(sp)
 9087b44:	dcc00317 	ldw	r19,12(sp)
 9087b48:	dc800217 	ldw	r18,8(sp)
 9087b4c:	dc400117 	ldw	r17,4(sp)
 9087b50:	dc000017 	ldw	r16,0(sp)
 9087b54:	dec00804 	addi	sp,sp,32
 9087b58:	f800283a 	ret
 9087b5c:	002d883a 	mov	r22,zero
 9087b60:	003ff206 	br	9087b2c <_fwalk+0x80>

09087b64 <__locale_charset>:
 9087b64:	d0a00417 	ldw	r2,-32752(gp)
 9087b68:	f800283a 	ret

09087b6c <_localeconv_r>:
 9087b6c:	00824374 	movhi	r2,2317
 9087b70:	10b29104 	addi	r2,r2,-13756
 9087b74:	f800283a 	ret

09087b78 <localeconv>:
 9087b78:	00824374 	movhi	r2,2317
 9087b7c:	108b9b04 	addi	r2,r2,11884
 9087b80:	11000017 	ldw	r4,0(r2)
 9087b84:	9087b6c1 	jmpi	9087b6c <_localeconv_r>

09087b88 <_setlocale_r>:
 9087b88:	defffc04 	addi	sp,sp,-16
 9087b8c:	00c24374 	movhi	r3,2317
 9087b90:	18f07d04 	addi	r3,r3,-15884
 9087b94:	dc800215 	stw	r18,8(sp)
 9087b98:	dc400115 	stw	r17,4(sp)
 9087b9c:	dc000015 	stw	r16,0(sp)
 9087ba0:	2023883a 	mov	r17,r4
 9087ba4:	2825883a 	mov	r18,r5
 9087ba8:	dfc00315 	stw	ra,12(sp)
 9087bac:	3021883a 	mov	r16,r6
 9087bb0:	3009883a 	mov	r4,r6
 9087bb4:	180b883a 	mov	r5,r3
 9087bb8:	30000926 	beq	r6,zero,9087be0 <_setlocale_r+0x58>
 9087bbc:	9089fd40 	call	9089fd4 <strcmp>
 9087bc0:	8009883a 	mov	r4,r16
 9087bc4:	01424374 	movhi	r5,2317
 9087bc8:	29727804 	addi	r5,r5,-13856
 9087bcc:	10000b1e 	bne	r2,zero,9087bfc <_setlocale_r+0x74>
 9087bd0:	8c000d15 	stw	r16,52(r17)
 9087bd4:	8c800c15 	stw	r18,48(r17)
 9087bd8:	00c24374 	movhi	r3,2317
 9087bdc:	18f07d04 	addi	r3,r3,-15884
 9087be0:	1805883a 	mov	r2,r3
 9087be4:	dfc00317 	ldw	ra,12(sp)
 9087be8:	dc800217 	ldw	r18,8(sp)
 9087bec:	dc400117 	ldw	r17,4(sp)
 9087bf0:	dc000017 	ldw	r16,0(sp)
 9087bf4:	dec00404 	addi	sp,sp,16
 9087bf8:	f800283a 	ret
 9087bfc:	9089fd40 	call	9089fd4 <strcmp>
 9087c00:	0007883a 	mov	r3,zero
 9087c04:	103ff226 	beq	r2,zero,9087bd0 <_setlocale_r+0x48>
 9087c08:	003ff506 	br	9087be0 <_setlocale_r+0x58>

09087c0c <setlocale>:
 9087c0c:	01824374 	movhi	r6,2317
 9087c10:	318b9b04 	addi	r6,r6,11884
 9087c14:	2007883a 	mov	r3,r4
 9087c18:	31000017 	ldw	r4,0(r6)
 9087c1c:	280d883a 	mov	r6,r5
 9087c20:	180b883a 	mov	r5,r3
 9087c24:	9087b881 	jmpi	9087b88 <_setlocale_r>

09087c28 <__smakebuf_r>:
 9087c28:	2880030b 	ldhu	r2,12(r5)
 9087c2c:	deffed04 	addi	sp,sp,-76
 9087c30:	dc401015 	stw	r17,64(sp)
 9087c34:	1080008c 	andi	r2,r2,2
 9087c38:	dc000f15 	stw	r16,60(sp)
 9087c3c:	dfc01215 	stw	ra,72(sp)
 9087c40:	dc801115 	stw	r18,68(sp)
 9087c44:	2821883a 	mov	r16,r5
 9087c48:	2023883a 	mov	r17,r4
 9087c4c:	10000b26 	beq	r2,zero,9087c7c <__smakebuf_r+0x54>
 9087c50:	28c010c4 	addi	r3,r5,67
 9087c54:	00800044 	movi	r2,1
 9087c58:	28800515 	stw	r2,20(r5)
 9087c5c:	28c00415 	stw	r3,16(r5)
 9087c60:	28c00015 	stw	r3,0(r5)
 9087c64:	dfc01217 	ldw	ra,72(sp)
 9087c68:	dc801117 	ldw	r18,68(sp)
 9087c6c:	dc401017 	ldw	r17,64(sp)
 9087c70:	dc000f17 	ldw	r16,60(sp)
 9087c74:	dec01304 	addi	sp,sp,76
 9087c78:	f800283a 	ret
 9087c7c:	2940038f 	ldh	r5,14(r5)
 9087c80:	28002116 	blt	r5,zero,9087d08 <__smakebuf_r+0xe0>
 9087c84:	d80d883a 	mov	r6,sp
 9087c88:	908a3500 	call	908a350 <_fstat_r>
 9087c8c:	10001e16 	blt	r2,zero,9087d08 <__smakebuf_r+0xe0>
 9087c90:	d8800117 	ldw	r2,4(sp)
 9087c94:	00e00014 	movui	r3,32768
 9087c98:	113c000c 	andi	r4,r2,61440
 9087c9c:	20c03126 	beq	r4,r3,9087d64 <__smakebuf_r+0x13c>
 9087ca0:	8080030b 	ldhu	r2,12(r16)
 9087ca4:	00c80004 	movi	r3,8192
 9087ca8:	10820014 	ori	r2,r2,2048
 9087cac:	8080030d 	sth	r2,12(r16)
 9087cb0:	20c01e26 	beq	r4,r3,9087d2c <__smakebuf_r+0x104>
 9087cb4:	04810004 	movi	r18,1024
 9087cb8:	8809883a 	mov	r4,r17
 9087cbc:	900b883a 	mov	r5,r18
 9087cc0:	9087dbc0 	call	9087dbc <_malloc_r>
 9087cc4:	1009883a 	mov	r4,r2
 9087cc8:	10003126 	beq	r2,zero,9087d90 <__smakebuf_r+0x168>
 9087ccc:	80c0030b 	ldhu	r3,12(r16)
 9087cd0:	00824234 	movhi	r2,2312
 9087cd4:	109b9204 	addi	r2,r2,28232
 9087cd8:	88800f15 	stw	r2,60(r17)
 9087cdc:	18c02014 	ori	r3,r3,128
 9087ce0:	84800515 	stw	r18,20(r16)
 9087ce4:	80c0030d 	sth	r3,12(r16)
 9087ce8:	81000415 	stw	r4,16(r16)
 9087cec:	81000015 	stw	r4,0(r16)
 9087cf0:	dfc01217 	ldw	ra,72(sp)
 9087cf4:	dc801117 	ldw	r18,68(sp)
 9087cf8:	dc401017 	ldw	r17,64(sp)
 9087cfc:	dc000f17 	ldw	r16,60(sp)
 9087d00:	dec01304 	addi	sp,sp,76
 9087d04:	f800283a 	ret
 9087d08:	80c0030b 	ldhu	r3,12(r16)
 9087d0c:	1880200c 	andi	r2,r3,128
 9087d10:	10000426 	beq	r2,zero,9087d24 <__smakebuf_r+0xfc>
 9087d14:	04801004 	movi	r18,64
 9087d18:	18820014 	ori	r2,r3,2048
 9087d1c:	8080030d 	sth	r2,12(r16)
 9087d20:	003fe506 	br	9087cb8 <__smakebuf_r+0x90>
 9087d24:	04810004 	movi	r18,1024
 9087d28:	003ffb06 	br	9087d18 <__smakebuf_r+0xf0>
 9087d2c:	8140038f 	ldh	r5,14(r16)
 9087d30:	8809883a 	mov	r4,r17
 9087d34:	908a3c40 	call	908a3c4 <_isatty_r>
 9087d38:	103fde26 	beq	r2,zero,9087cb4 <__smakebuf_r+0x8c>
 9087d3c:	8080030b 	ldhu	r2,12(r16)
 9087d40:	80c010c4 	addi	r3,r16,67
 9087d44:	04810004 	movi	r18,1024
 9087d48:	10800054 	ori	r2,r2,1
 9087d4c:	8080030d 	sth	r2,12(r16)
 9087d50:	00800044 	movi	r2,1
 9087d54:	80c00415 	stw	r3,16(r16)
 9087d58:	80800515 	stw	r2,20(r16)
 9087d5c:	80c00015 	stw	r3,0(r16)
 9087d60:	003fd506 	br	9087cb8 <__smakebuf_r+0x90>
 9087d64:	80c00a17 	ldw	r3,40(r16)
 9087d68:	00824274 	movhi	r2,2313
 9087d6c:	10a7a404 	addi	r2,r2,-24944
 9087d70:	18bfcb1e 	bne	r3,r2,9087ca0 <__smakebuf_r+0x78>
 9087d74:	8080030b 	ldhu	r2,12(r16)
 9087d78:	00c10004 	movi	r3,1024
 9087d7c:	1825883a 	mov	r18,r3
 9087d80:	10c4b03a 	or	r2,r2,r3
 9087d84:	8080030d 	sth	r2,12(r16)
 9087d88:	80c01315 	stw	r3,76(r16)
 9087d8c:	003fca06 	br	9087cb8 <__smakebuf_r+0x90>
 9087d90:	8100030b 	ldhu	r4,12(r16)
 9087d94:	2080800c 	andi	r2,r4,512
 9087d98:	103fb21e 	bne	r2,zero,9087c64 <__smakebuf_r+0x3c>
 9087d9c:	80c010c4 	addi	r3,r16,67
 9087da0:	21000094 	ori	r4,r4,2
 9087da4:	00800044 	movi	r2,1
 9087da8:	80800515 	stw	r2,20(r16)
 9087dac:	8100030d 	sth	r4,12(r16)
 9087db0:	80c00415 	stw	r3,16(r16)
 9087db4:	80c00015 	stw	r3,0(r16)
 9087db8:	003faa06 	br	9087c64 <__smakebuf_r+0x3c>

09087dbc <_malloc_r>:
 9087dbc:	defff604 	addi	sp,sp,-40
 9087dc0:	28c002c4 	addi	r3,r5,11
 9087dc4:	00800584 	movi	r2,22
 9087dc8:	dc800215 	stw	r18,8(sp)
 9087dcc:	dfc00915 	stw	ra,36(sp)
 9087dd0:	df000815 	stw	fp,32(sp)
 9087dd4:	ddc00715 	stw	r23,28(sp)
 9087dd8:	dd800615 	stw	r22,24(sp)
 9087ddc:	dd400515 	stw	r21,20(sp)
 9087de0:	dd000415 	stw	r20,16(sp)
 9087de4:	dcc00315 	stw	r19,12(sp)
 9087de8:	dc400115 	stw	r17,4(sp)
 9087dec:	dc000015 	stw	r16,0(sp)
 9087df0:	2025883a 	mov	r18,r4
 9087df4:	10c01236 	bltu	r2,r3,9087e40 <_malloc_r+0x84>
 9087df8:	04400404 	movi	r17,16
 9087dfc:	8940142e 	bgeu	r17,r5,9087e50 <_malloc_r+0x94>
 9087e00:	00800304 	movi	r2,12
 9087e04:	0007883a 	mov	r3,zero
 9087e08:	90800015 	stw	r2,0(r18)
 9087e0c:	1805883a 	mov	r2,r3
 9087e10:	dfc00917 	ldw	ra,36(sp)
 9087e14:	df000817 	ldw	fp,32(sp)
 9087e18:	ddc00717 	ldw	r23,28(sp)
 9087e1c:	dd800617 	ldw	r22,24(sp)
 9087e20:	dd400517 	ldw	r21,20(sp)
 9087e24:	dd000417 	ldw	r20,16(sp)
 9087e28:	dcc00317 	ldw	r19,12(sp)
 9087e2c:	dc800217 	ldw	r18,8(sp)
 9087e30:	dc400117 	ldw	r17,4(sp)
 9087e34:	dc000017 	ldw	r16,0(sp)
 9087e38:	dec00a04 	addi	sp,sp,40
 9087e3c:	f800283a 	ret
 9087e40:	00bffe04 	movi	r2,-8
 9087e44:	18a2703a 	and	r17,r3,r2
 9087e48:	883fed16 	blt	r17,zero,9087e00 <_malloc_r+0x44>
 9087e4c:	897fec36 	bltu	r17,r5,9087e00 <_malloc_r+0x44>
 9087e50:	9009883a 	mov	r4,r18
 9087e54:	908cedc0 	call	908cedc <__malloc_lock>
 9087e58:	00807dc4 	movi	r2,503
 9087e5c:	14402b2e 	bgeu	r2,r17,9087f0c <_malloc_r+0x150>
 9087e60:	8806d27a 	srli	r3,r17,9
 9087e64:	18003f1e 	bne	r3,zero,9087f64 <_malloc_r+0x1a8>
 9087e68:	880cd0fa 	srli	r6,r17,3
 9087e6c:	300490fa 	slli	r2,r6,3
 9087e70:	02c24374 	movhi	r11,2317
 9087e74:	5ac4f404 	addi	r11,r11,5072
 9087e78:	12cb883a 	add	r5,r2,r11
 9087e7c:	2c000317 	ldw	r16,12(r5)
 9087e80:	580f883a 	mov	r7,r11
 9087e84:	2c00041e 	bne	r5,r16,9087e98 <_malloc_r+0xdc>
 9087e88:	00000a06 	br	9087eb4 <_malloc_r+0xf8>
 9087e8c:	1800860e 	bge	r3,zero,90880a8 <_malloc_r+0x2ec>
 9087e90:	84000317 	ldw	r16,12(r16)
 9087e94:	2c000726 	beq	r5,r16,9087eb4 <_malloc_r+0xf8>
 9087e98:	80800117 	ldw	r2,4(r16)
 9087e9c:	00ffff04 	movi	r3,-4
 9087ea0:	10c8703a 	and	r4,r2,r3
 9087ea4:	2447c83a 	sub	r3,r4,r17
 9087ea8:	008003c4 	movi	r2,15
 9087eac:	10fff70e 	bge	r2,r3,9087e8c <_malloc_r+0xd0>
 9087eb0:	31bfffc4 	addi	r6,r6,-1
 9087eb4:	32400044 	addi	r9,r6,1
 9087eb8:	02824374 	movhi	r10,2317
 9087ebc:	5284f604 	addi	r10,r10,5080
 9087ec0:	54000217 	ldw	r16,8(r10)
 9087ec4:	8280a026 	beq	r16,r10,9088148 <_malloc_r+0x38c>
 9087ec8:	80800117 	ldw	r2,4(r16)
 9087ecc:	00ffff04 	movi	r3,-4
 9087ed0:	10ca703a 	and	r5,r2,r3
 9087ed4:	2c4dc83a 	sub	r6,r5,r17
 9087ed8:	008003c4 	movi	r2,15
 9087edc:	11808316 	blt	r2,r6,90880ec <_malloc_r+0x330>
 9087ee0:	52800315 	stw	r10,12(r10)
 9087ee4:	52800215 	stw	r10,8(r10)
 9087ee8:	30002916 	blt	r6,zero,9087f90 <_malloc_r+0x1d4>
 9087eec:	8147883a 	add	r3,r16,r5
 9087ef0:	18800117 	ldw	r2,4(r3)
 9087ef4:	9009883a 	mov	r4,r18
 9087ef8:	10800054 	ori	r2,r2,1
 9087efc:	18800115 	stw	r2,4(r3)
 9087f00:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9087f04:	80c00204 	addi	r3,r16,8
 9087f08:	003fc006 	br	9087e0c <_malloc_r+0x50>
 9087f0c:	02c24374 	movhi	r11,2317
 9087f10:	5ac4f404 	addi	r11,r11,5072
 9087f14:	8ac5883a 	add	r2,r17,r11
 9087f18:	14000317 	ldw	r16,12(r2)
 9087f1c:	580f883a 	mov	r7,r11
 9087f20:	8806d0fa 	srli	r3,r17,3
 9087f24:	14006c26 	beq	r2,r16,90880d8 <_malloc_r+0x31c>
 9087f28:	80c00117 	ldw	r3,4(r16)
 9087f2c:	00bfff04 	movi	r2,-4
 9087f30:	81800317 	ldw	r6,12(r16)
 9087f34:	1886703a 	and	r3,r3,r2
 9087f38:	80c7883a 	add	r3,r16,r3
 9087f3c:	18800117 	ldw	r2,4(r3)
 9087f40:	81400217 	ldw	r5,8(r16)
 9087f44:	9009883a 	mov	r4,r18
 9087f48:	10800054 	ori	r2,r2,1
 9087f4c:	18800115 	stw	r2,4(r3)
 9087f50:	31400215 	stw	r5,8(r6)
 9087f54:	29800315 	stw	r6,12(r5)
 9087f58:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9087f5c:	80c00204 	addi	r3,r16,8
 9087f60:	003faa06 	br	9087e0c <_malloc_r+0x50>
 9087f64:	00800104 	movi	r2,4
 9087f68:	10c0052e 	bgeu	r2,r3,9087f80 <_malloc_r+0x1c4>
 9087f6c:	00800504 	movi	r2,20
 9087f70:	10c07836 	bltu	r2,r3,9088154 <_malloc_r+0x398>
 9087f74:	198016c4 	addi	r6,r3,91
 9087f78:	300490fa 	slli	r2,r6,3
 9087f7c:	003fbc06 	br	9087e70 <_malloc_r+0xb4>
 9087f80:	8804d1ba 	srli	r2,r17,6
 9087f84:	11800e04 	addi	r6,r2,56
 9087f88:	300490fa 	slli	r2,r6,3
 9087f8c:	003fb806 	br	9087e70 <_malloc_r+0xb4>
 9087f90:	00807fc4 	movi	r2,511
 9087f94:	1140bb36 	bltu	r2,r5,9088284 <_malloc_r+0x4c8>
 9087f98:	2806d0fa 	srli	r3,r5,3
 9087f9c:	573ffe04 	addi	fp,r10,-8
 9087fa0:	00800044 	movi	r2,1
 9087fa4:	180890fa 	slli	r4,r3,3
 9087fa8:	1807d0ba 	srai	r3,r3,2
 9087fac:	e1c00117 	ldw	r7,4(fp)
 9087fb0:	5909883a 	add	r4,r11,r4
 9087fb4:	21400217 	ldw	r5,8(r4)
 9087fb8:	10c4983a 	sll	r2,r2,r3
 9087fbc:	81000315 	stw	r4,12(r16)
 9087fc0:	81400215 	stw	r5,8(r16)
 9087fc4:	388eb03a 	or	r7,r7,r2
 9087fc8:	2c000315 	stw	r16,12(r5)
 9087fcc:	24000215 	stw	r16,8(r4)
 9087fd0:	e1c00115 	stw	r7,4(fp)
 9087fd4:	4807883a 	mov	r3,r9
 9087fd8:	4800cd16 	blt	r9,zero,9088310 <_malloc_r+0x554>
 9087fdc:	1807d0ba 	srai	r3,r3,2
 9087fe0:	00800044 	movi	r2,1
 9087fe4:	10c8983a 	sll	r4,r2,r3
 9087fe8:	39004436 	bltu	r7,r4,90880fc <_malloc_r+0x340>
 9087fec:	21c4703a 	and	r2,r4,r7
 9087ff0:	10000a1e 	bne	r2,zero,908801c <_malloc_r+0x260>
 9087ff4:	2109883a 	add	r4,r4,r4
 9087ff8:	00bfff04 	movi	r2,-4
 9087ffc:	4884703a 	and	r2,r9,r2
 9088000:	3906703a 	and	r3,r7,r4
 9088004:	12400104 	addi	r9,r2,4
 9088008:	1800041e 	bne	r3,zero,908801c <_malloc_r+0x260>
 908800c:	2109883a 	add	r4,r4,r4
 9088010:	3904703a 	and	r2,r7,r4
 9088014:	4a400104 	addi	r9,r9,4
 9088018:	103ffc26 	beq	r2,zero,908800c <_malloc_r+0x250>
 908801c:	480490fa 	slli	r2,r9,3
 9088020:	4819883a 	mov	r12,r9
 9088024:	023fff04 	movi	r8,-4
 9088028:	589b883a 	add	r13,r11,r2
 908802c:	6807883a 	mov	r3,r13
 9088030:	014003c4 	movi	r5,15
 9088034:	1c000317 	ldw	r16,12(r3)
 9088038:	1c00041e 	bne	r3,r16,908804c <_malloc_r+0x290>
 908803c:	0000a706 	br	90882dc <_malloc_r+0x520>
 9088040:	3000ab0e 	bge	r6,zero,90882f0 <_malloc_r+0x534>
 9088044:	84000317 	ldw	r16,12(r16)
 9088048:	1c00a426 	beq	r3,r16,90882dc <_malloc_r+0x520>
 908804c:	80800117 	ldw	r2,4(r16)
 9088050:	1204703a 	and	r2,r2,r8
 9088054:	144dc83a 	sub	r6,r2,r17
 9088058:	29bff90e 	bge	r5,r6,9088040 <_malloc_r+0x284>
 908805c:	81000317 	ldw	r4,12(r16)
 9088060:	80c00217 	ldw	r3,8(r16)
 9088064:	89400054 	ori	r5,r17,1
 9088068:	8445883a 	add	r2,r16,r17
 908806c:	20c00215 	stw	r3,8(r4)
 9088070:	19000315 	stw	r4,12(r3)
 9088074:	81400115 	stw	r5,4(r16)
 9088078:	1187883a 	add	r3,r2,r6
 908807c:	31000054 	ori	r4,r6,1
 9088080:	50800315 	stw	r2,12(r10)
 9088084:	50800215 	stw	r2,8(r10)
 9088088:	19800015 	stw	r6,0(r3)
 908808c:	11000115 	stw	r4,4(r2)
 9088090:	12800215 	stw	r10,8(r2)
 9088094:	12800315 	stw	r10,12(r2)
 9088098:	9009883a 	mov	r4,r18
 908809c:	908cfe40 	call	908cfe4 <__malloc_unlock>
 90880a0:	80c00204 	addi	r3,r16,8
 90880a4:	003f5906 	br	9087e0c <_malloc_r+0x50>
 90880a8:	8109883a 	add	r4,r16,r4
 90880ac:	20800117 	ldw	r2,4(r4)
 90880b0:	80c00217 	ldw	r3,8(r16)
 90880b4:	81400317 	ldw	r5,12(r16)
 90880b8:	10800054 	ori	r2,r2,1
 90880bc:	20800115 	stw	r2,4(r4)
 90880c0:	28c00215 	stw	r3,8(r5)
 90880c4:	19400315 	stw	r5,12(r3)
 90880c8:	9009883a 	mov	r4,r18
 90880cc:	908cfe40 	call	908cfe4 <__malloc_unlock>
 90880d0:	80c00204 	addi	r3,r16,8
 90880d4:	003f4d06 	br	9087e0c <_malloc_r+0x50>
 90880d8:	80800204 	addi	r2,r16,8
 90880dc:	14000317 	ldw	r16,12(r2)
 90880e0:	143f911e 	bne	r2,r16,9087f28 <_malloc_r+0x16c>
 90880e4:	1a400084 	addi	r9,r3,2
 90880e8:	003f7306 	br	9087eb8 <_malloc_r+0xfc>
 90880ec:	88c00054 	ori	r3,r17,1
 90880f0:	8445883a 	add	r2,r16,r17
 90880f4:	80c00115 	stw	r3,4(r16)
 90880f8:	003fdf06 	br	9088078 <_malloc_r+0x2bc>
 90880fc:	e4000217 	ldw	r16,8(fp)
 9088100:	00bfff04 	movi	r2,-4
 9088104:	80c00117 	ldw	r3,4(r16)
 9088108:	802d883a 	mov	r22,r16
 908810c:	18aa703a 	and	r21,r3,r2
 9088110:	ac401636 	bltu	r21,r17,908816c <_malloc_r+0x3b0>
 9088114:	ac49c83a 	sub	r4,r21,r17
 9088118:	008003c4 	movi	r2,15
 908811c:	1100130e 	bge	r2,r4,908816c <_malloc_r+0x3b0>
 9088120:	88800054 	ori	r2,r17,1
 9088124:	8447883a 	add	r3,r16,r17
 9088128:	80800115 	stw	r2,4(r16)
 908812c:	20800054 	ori	r2,r4,1
 9088130:	18800115 	stw	r2,4(r3)
 9088134:	e0c00215 	stw	r3,8(fp)
 9088138:	9009883a 	mov	r4,r18
 908813c:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9088140:	80c00204 	addi	r3,r16,8
 9088144:	003f3106 	br	9087e0c <_malloc_r+0x50>
 9088148:	39c00117 	ldw	r7,4(r7)
 908814c:	573ffe04 	addi	fp,r10,-8
 9088150:	003fa006 	br	9087fd4 <_malloc_r+0x218>
 9088154:	00801504 	movi	r2,84
 9088158:	10c06736 	bltu	r2,r3,90882f8 <_malloc_r+0x53c>
 908815c:	8804d33a 	srli	r2,r17,12
 9088160:	11801b84 	addi	r6,r2,110
 9088164:	300490fa 	slli	r2,r6,3
 9088168:	003f4106 	br	9087e70 <_malloc_r+0xb4>
 908816c:	d0a06017 	ldw	r2,-32384(gp)
 9088170:	d0e00617 	ldw	r3,-32744(gp)
 9088174:	053fffc4 	movi	r20,-1
 9088178:	10800404 	addi	r2,r2,16
 908817c:	88a7883a 	add	r19,r17,r2
 9088180:	1d000326 	beq	r3,r20,9088190 <_malloc_r+0x3d4>
 9088184:	98c3ffc4 	addi	r3,r19,4095
 9088188:	00bc0004 	movi	r2,-4096
 908818c:	18a6703a 	and	r19,r3,r2
 9088190:	9009883a 	mov	r4,r18
 9088194:	980b883a 	mov	r5,r19
 9088198:	9089e180 	call	9089e18 <_sbrk_r>
 908819c:	1009883a 	mov	r4,r2
 90881a0:	15000426 	beq	r2,r20,90881b4 <_malloc_r+0x3f8>
 90881a4:	854b883a 	add	r5,r16,r21
 90881a8:	1029883a 	mov	r20,r2
 90881ac:	11405a2e 	bgeu	r2,r5,9088318 <_malloc_r+0x55c>
 90881b0:	87000c26 	beq	r16,fp,90881e4 <_malloc_r+0x428>
 90881b4:	e4000217 	ldw	r16,8(fp)
 90881b8:	80c00117 	ldw	r3,4(r16)
 90881bc:	00bfff04 	movi	r2,-4
 90881c0:	1884703a 	and	r2,r3,r2
 90881c4:	14400336 	bltu	r2,r17,90881d4 <_malloc_r+0x418>
 90881c8:	1449c83a 	sub	r4,r2,r17
 90881cc:	008003c4 	movi	r2,15
 90881d0:	113fd316 	blt	r2,r4,9088120 <_malloc_r+0x364>
 90881d4:	9009883a 	mov	r4,r18
 90881d8:	908cfe40 	call	908cfe4 <__malloc_unlock>
 90881dc:	0007883a 	mov	r3,zero
 90881e0:	003f0a06 	br	9087e0c <_malloc_r+0x50>
 90881e4:	05c24374 	movhi	r23,2317
 90881e8:	bdcdf304 	addi	r23,r23,14284
 90881ec:	b8800017 	ldw	r2,0(r23)
 90881f0:	988d883a 	add	r6,r19,r2
 90881f4:	b9800015 	stw	r6,0(r23)
 90881f8:	d0e00617 	ldw	r3,-32744(gp)
 90881fc:	00bfffc4 	movi	r2,-1
 9088200:	18808e26 	beq	r3,r2,908843c <_malloc_r+0x680>
 9088204:	2145c83a 	sub	r2,r4,r5
 9088208:	3085883a 	add	r2,r6,r2
 908820c:	b8800015 	stw	r2,0(r23)
 9088210:	20c001cc 	andi	r3,r4,7
 9088214:	18005f1e 	bne	r3,zero,9088394 <_malloc_r+0x5d8>
 9088218:	000b883a 	mov	r5,zero
 908821c:	a4c5883a 	add	r2,r20,r19
 9088220:	1083ffcc 	andi	r2,r2,4095
 9088224:	00c40004 	movi	r3,4096
 9088228:	1887c83a 	sub	r3,r3,r2
 908822c:	28e7883a 	add	r19,r5,r3
 9088230:	9009883a 	mov	r4,r18
 9088234:	980b883a 	mov	r5,r19
 9088238:	9089e180 	call	9089e18 <_sbrk_r>
 908823c:	1007883a 	mov	r3,r2
 9088240:	00bfffc4 	movi	r2,-1
 9088244:	18807a26 	beq	r3,r2,9088430 <_malloc_r+0x674>
 9088248:	1d05c83a 	sub	r2,r3,r20
 908824c:	9885883a 	add	r2,r19,r2
 9088250:	10c00054 	ori	r3,r2,1
 9088254:	b8800017 	ldw	r2,0(r23)
 9088258:	a021883a 	mov	r16,r20
 908825c:	a0c00115 	stw	r3,4(r20)
 9088260:	9885883a 	add	r2,r19,r2
 9088264:	b8800015 	stw	r2,0(r23)
 9088268:	e5000215 	stw	r20,8(fp)
 908826c:	b7003626 	beq	r22,fp,9088348 <_malloc_r+0x58c>
 9088270:	018003c4 	movi	r6,15
 9088274:	35404b36 	bltu	r6,r21,90883a4 <_malloc_r+0x5e8>
 9088278:	00800044 	movi	r2,1
 908827c:	a0800115 	stw	r2,4(r20)
 9088280:	003fcd06 	br	90881b8 <_malloc_r+0x3fc>
 9088284:	2808d27a 	srli	r4,r5,9
 9088288:	2000371e 	bne	r4,zero,9088368 <_malloc_r+0x5ac>
 908828c:	2808d0fa 	srli	r4,r5,3
 9088290:	200690fa 	slli	r3,r4,3
 9088294:	1ad1883a 	add	r8,r3,r11
 9088298:	41800217 	ldw	r6,8(r8)
 908829c:	41805b26 	beq	r8,r6,908840c <_malloc_r+0x650>
 90882a0:	30800117 	ldw	r2,4(r6)
 90882a4:	00ffff04 	movi	r3,-4
 90882a8:	10c4703a 	and	r2,r2,r3
 90882ac:	2880022e 	bgeu	r5,r2,90882b8 <_malloc_r+0x4fc>
 90882b0:	31800217 	ldw	r6,8(r6)
 90882b4:	41bffa1e 	bne	r8,r6,90882a0 <_malloc_r+0x4e4>
 90882b8:	32000317 	ldw	r8,12(r6)
 90882bc:	39c00117 	ldw	r7,4(r7)
 90882c0:	82000315 	stw	r8,12(r16)
 90882c4:	81800215 	stw	r6,8(r16)
 90882c8:	07024374 	movhi	fp,2317
 90882cc:	e704f404 	addi	fp,fp,5072
 90882d0:	34000315 	stw	r16,12(r6)
 90882d4:	44000215 	stw	r16,8(r8)
 90882d8:	003f3e06 	br	9087fd4 <_malloc_r+0x218>
 90882dc:	63000044 	addi	r12,r12,1
 90882e0:	608000cc 	andi	r2,r12,3
 90882e4:	10005d26 	beq	r2,zero,908845c <_malloc_r+0x6a0>
 90882e8:	18c00204 	addi	r3,r3,8
 90882ec:	003f5106 	br	9088034 <_malloc_r+0x278>
 90882f0:	8089883a 	add	r4,r16,r2
 90882f4:	003f6d06 	br	90880ac <_malloc_r+0x2f0>
 90882f8:	00805504 	movi	r2,340
 90882fc:	10c02036 	bltu	r2,r3,9088380 <_malloc_r+0x5c4>
 9088300:	8804d3fa 	srli	r2,r17,15
 9088304:	11801dc4 	addi	r6,r2,119
 9088308:	300490fa 	slli	r2,r6,3
 908830c:	003ed806 	br	9087e70 <_malloc_r+0xb4>
 9088310:	48c000c4 	addi	r3,r9,3
 9088314:	003f3106 	br	9087fdc <_malloc_r+0x220>
 9088318:	05c24374 	movhi	r23,2317
 908831c:	bdcdf304 	addi	r23,r23,14284
 9088320:	b8800017 	ldw	r2,0(r23)
 9088324:	988d883a 	add	r6,r19,r2
 9088328:	b9800015 	stw	r6,0(r23)
 908832c:	293fb21e 	bne	r5,r4,90881f8 <_malloc_r+0x43c>
 9088330:	2083ffcc 	andi	r2,r4,4095
 9088334:	103fb01e 	bne	r2,zero,90881f8 <_malloc_r+0x43c>
 9088338:	e4000217 	ldw	r16,8(fp)
 908833c:	9d45883a 	add	r2,r19,r21
 9088340:	10800054 	ori	r2,r2,1
 9088344:	80800115 	stw	r2,4(r16)
 9088348:	b8c00017 	ldw	r3,0(r23)
 908834c:	d0a06117 	ldw	r2,-32380(gp)
 9088350:	10c0012e 	bgeu	r2,r3,9088358 <_malloc_r+0x59c>
 9088354:	d0e06115 	stw	r3,-32380(gp)
 9088358:	d0a06217 	ldw	r2,-32376(gp)
 908835c:	10ff962e 	bgeu	r2,r3,90881b8 <_malloc_r+0x3fc>
 9088360:	d0e06215 	stw	r3,-32376(gp)
 9088364:	003f9406 	br	90881b8 <_malloc_r+0x3fc>
 9088368:	00800104 	movi	r2,4
 908836c:	11001e36 	bltu	r2,r4,90883e8 <_malloc_r+0x62c>
 9088370:	2804d1ba 	srli	r2,r5,6
 9088374:	11000e04 	addi	r4,r2,56
 9088378:	200690fa 	slli	r3,r4,3
 908837c:	003fc506 	br	9088294 <_malloc_r+0x4d8>
 9088380:	00815504 	movi	r2,1364
 9088384:	10c01d2e 	bgeu	r2,r3,90883fc <_malloc_r+0x640>
 9088388:	01801f84 	movi	r6,126
 908838c:	0080fc04 	movi	r2,1008
 9088390:	003eb706 	br	9087e70 <_malloc_r+0xb4>
 9088394:	00800204 	movi	r2,8
 9088398:	10cbc83a 	sub	r5,r2,r3
 908839c:	2169883a 	add	r20,r4,r5
 90883a0:	003f9e06 	br	908821c <_malloc_r+0x460>
 90883a4:	00bffe04 	movi	r2,-8
 90883a8:	a93ffd04 	addi	r4,r21,-12
 90883ac:	2088703a 	and	r4,r4,r2
 90883b0:	b10b883a 	add	r5,r22,r4
 90883b4:	00c00144 	movi	r3,5
 90883b8:	28c00215 	stw	r3,8(r5)
 90883bc:	28c00115 	stw	r3,4(r5)
 90883c0:	b0800117 	ldw	r2,4(r22)
 90883c4:	1080004c 	andi	r2,r2,1
 90883c8:	2084b03a 	or	r2,r4,r2
 90883cc:	b0800115 	stw	r2,4(r22)
 90883d0:	313fdd2e 	bgeu	r6,r4,9088348 <_malloc_r+0x58c>
 90883d4:	b1400204 	addi	r5,r22,8
 90883d8:	9009883a 	mov	r4,r18
 90883dc:	90872340 	call	9087234 <_free_r>
 90883e0:	e4000217 	ldw	r16,8(fp)
 90883e4:	003fd806 	br	9088348 <_malloc_r+0x58c>
 90883e8:	00800504 	movi	r2,20
 90883ec:	11001536 	bltu	r2,r4,9088444 <_malloc_r+0x688>
 90883f0:	210016c4 	addi	r4,r4,91
 90883f4:	200690fa 	slli	r3,r4,3
 90883f8:	003fa606 	br	9088294 <_malloc_r+0x4d8>
 90883fc:	8804d4ba 	srli	r2,r17,18
 9088400:	11801f04 	addi	r6,r2,124
 9088404:	300490fa 	slli	r2,r6,3
 9088408:	003e9906 	br	9087e70 <_malloc_r+0xb4>
 908840c:	2009d0ba 	srai	r4,r4,2
 9088410:	01424374 	movhi	r5,2317
 9088414:	2944f404 	addi	r5,r5,5072
 9088418:	00c00044 	movi	r3,1
 908841c:	28800117 	ldw	r2,4(r5)
 9088420:	1906983a 	sll	r3,r3,r4
 9088424:	10c4b03a 	or	r2,r2,r3
 9088428:	28800115 	stw	r2,4(r5)
 908842c:	003fa306 	br	90882bc <_malloc_r+0x500>
 9088430:	0027883a 	mov	r19,zero
 9088434:	00c00044 	movi	r3,1
 9088438:	003f8606 	br	9088254 <_malloc_r+0x498>
 908843c:	d1200615 	stw	r4,-32744(gp)
 9088440:	003f7306 	br	9088210 <_malloc_r+0x454>
 9088444:	00801504 	movi	r2,84
 9088448:	11001936 	bltu	r2,r4,90884b0 <_malloc_r+0x6f4>
 908844c:	2804d33a 	srli	r2,r5,12
 9088450:	11001b84 	addi	r4,r2,110
 9088454:	200690fa 	slli	r3,r4,3
 9088458:	003f8e06 	br	9088294 <_malloc_r+0x4d8>
 908845c:	480b883a 	mov	r5,r9
 9088460:	6807883a 	mov	r3,r13
 9088464:	288000cc 	andi	r2,r5,3
 9088468:	18fffe04 	addi	r3,r3,-8
 908846c:	297fffc4 	addi	r5,r5,-1
 9088470:	10001526 	beq	r2,zero,90884c8 <_malloc_r+0x70c>
 9088474:	18800217 	ldw	r2,8(r3)
 9088478:	10fffa26 	beq	r2,r3,9088464 <_malloc_r+0x6a8>
 908847c:	2109883a 	add	r4,r4,r4
 9088480:	393f1e36 	bltu	r7,r4,90880fc <_malloc_r+0x340>
 9088484:	203f1d26 	beq	r4,zero,90880fc <_malloc_r+0x340>
 9088488:	21c4703a 	and	r2,r4,r7
 908848c:	10000226 	beq	r2,zero,9088498 <_malloc_r+0x6dc>
 9088490:	6013883a 	mov	r9,r12
 9088494:	003ee106 	br	908801c <_malloc_r+0x260>
 9088498:	2109883a 	add	r4,r4,r4
 908849c:	3904703a 	and	r2,r7,r4
 90884a0:	63000104 	addi	r12,r12,4
 90884a4:	103ffc26 	beq	r2,zero,9088498 <_malloc_r+0x6dc>
 90884a8:	6013883a 	mov	r9,r12
 90884ac:	003edb06 	br	908801c <_malloc_r+0x260>
 90884b0:	00805504 	movi	r2,340
 90884b4:	11000836 	bltu	r2,r4,90884d8 <_malloc_r+0x71c>
 90884b8:	2804d3fa 	srli	r2,r5,15
 90884bc:	11001dc4 	addi	r4,r2,119
 90884c0:	200690fa 	slli	r3,r4,3
 90884c4:	003f7306 	br	9088294 <_malloc_r+0x4d8>
 90884c8:	0104303a 	nor	r2,zero,r4
 90884cc:	388e703a 	and	r7,r7,r2
 90884d0:	e1c00115 	stw	r7,4(fp)
 90884d4:	003fe906 	br	908847c <_malloc_r+0x6c0>
 90884d8:	00815504 	movi	r2,1364
 90884dc:	1100032e 	bgeu	r2,r4,90884ec <_malloc_r+0x730>
 90884e0:	01001f84 	movi	r4,126
 90884e4:	00c0fc04 	movi	r3,1008
 90884e8:	003f6a06 	br	9088294 <_malloc_r+0x4d8>
 90884ec:	2804d4ba 	srli	r2,r5,18
 90884f0:	11001f04 	addi	r4,r2,124
 90884f4:	200690fa 	slli	r3,r4,3
 90884f8:	003f6606 	br	9088294 <_malloc_r+0x4d8>

090884fc <memchr>:
 90884fc:	008000c4 	movi	r2,3
 9088500:	29403fcc 	andi	r5,r5,255
 9088504:	2007883a 	mov	r3,r4
 9088508:	1180022e 	bgeu	r2,r6,9088514 <memchr+0x18>
 908850c:	2084703a 	and	r2,r4,r2
 9088510:	10000b26 	beq	r2,zero,9088540 <memchr+0x44>
 9088514:	313fffc4 	addi	r4,r6,-1
 9088518:	3000051e 	bne	r6,zero,9088530 <memchr+0x34>
 908851c:	00002c06 	br	90885d0 <memchr+0xd4>
 9088520:	213fffc4 	addi	r4,r4,-1
 9088524:	00bfffc4 	movi	r2,-1
 9088528:	18c00044 	addi	r3,r3,1
 908852c:	20802826 	beq	r4,r2,90885d0 <memchr+0xd4>
 9088530:	18800003 	ldbu	r2,0(r3)
 9088534:	28bffa1e 	bne	r5,r2,9088520 <memchr+0x24>
 9088538:	1805883a 	mov	r2,r3
 908853c:	f800283a 	ret
 9088540:	0011883a 	mov	r8,zero
 9088544:	0007883a 	mov	r3,zero
 9088548:	01c00104 	movi	r7,4
 908854c:	4004923a 	slli	r2,r8,8
 9088550:	18c00044 	addi	r3,r3,1
 9088554:	1151883a 	add	r8,r2,r5
 9088558:	19fffc1e 	bne	r3,r7,908854c <memchr+0x50>
 908855c:	02bfbff4 	movhi	r10,65279
 9088560:	52bfbfc4 	addi	r10,r10,-257
 9088564:	02602074 	movhi	r9,32897
 9088568:	4a602004 	addi	r9,r9,-32640
 908856c:	02c000c4 	movi	r11,3
 9088570:	20800017 	ldw	r2,0(r4)
 9088574:	31bfff04 	addi	r6,r6,-4
 9088578:	200f883a 	mov	r7,r4
 908857c:	1204f03a 	xor	r2,r2,r8
 9088580:	1287883a 	add	r3,r2,r10
 9088584:	1a46703a 	and	r3,r3,r9
 9088588:	0084303a 	nor	r2,zero,r2
 908858c:	10c4703a 	and	r2,r2,r3
 9088590:	10000b26 	beq	r2,zero,90885c0 <memchr+0xc4>
 9088594:	20800003 	ldbu	r2,0(r4)
 9088598:	28800f26 	beq	r5,r2,90885d8 <memchr+0xdc>
 908859c:	20800043 	ldbu	r2,1(r4)
 90885a0:	21c00044 	addi	r7,r4,1
 90885a4:	28800c26 	beq	r5,r2,90885d8 <memchr+0xdc>
 90885a8:	20800083 	ldbu	r2,2(r4)
 90885ac:	21c00084 	addi	r7,r4,2
 90885b0:	28800926 	beq	r5,r2,90885d8 <memchr+0xdc>
 90885b4:	208000c3 	ldbu	r2,3(r4)
 90885b8:	21c000c4 	addi	r7,r4,3
 90885bc:	28800626 	beq	r5,r2,90885d8 <memchr+0xdc>
 90885c0:	21000104 	addi	r4,r4,4
 90885c4:	59bfea36 	bltu	r11,r6,9088570 <memchr+0x74>
 90885c8:	2007883a 	mov	r3,r4
 90885cc:	003fd106 	br	9088514 <memchr+0x18>
 90885d0:	0005883a 	mov	r2,zero
 90885d4:	f800283a 	ret
 90885d8:	3805883a 	mov	r2,r7
 90885dc:	f800283a 	ret

090885e0 <_Bfree>:
 90885e0:	28000826 	beq	r5,zero,9088604 <_Bfree+0x24>
 90885e4:	28800117 	ldw	r2,4(r5)
 90885e8:	21001317 	ldw	r4,76(r4)
 90885ec:	1085883a 	add	r2,r2,r2
 90885f0:	1085883a 	add	r2,r2,r2
 90885f4:	1105883a 	add	r2,r2,r4
 90885f8:	10c00017 	ldw	r3,0(r2)
 90885fc:	28c00015 	stw	r3,0(r5)
 9088600:	11400015 	stw	r5,0(r2)
 9088604:	f800283a 	ret

09088608 <__hi0bits>:
 9088608:	20bfffec 	andhi	r2,r4,65535
 908860c:	10001426 	beq	r2,zero,9088660 <__hi0bits+0x58>
 9088610:	0007883a 	mov	r3,zero
 9088614:	20bfc02c 	andhi	r2,r4,65280
 9088618:	1000021e 	bne	r2,zero,9088624 <__hi0bits+0x1c>
 908861c:	2008923a 	slli	r4,r4,8
 9088620:	18c00204 	addi	r3,r3,8
 9088624:	20bc002c 	andhi	r2,r4,61440
 9088628:	1000021e 	bne	r2,zero,9088634 <__hi0bits+0x2c>
 908862c:	2008913a 	slli	r4,r4,4
 9088630:	18c00104 	addi	r3,r3,4
 9088634:	20b0002c 	andhi	r2,r4,49152
 9088638:	1000031e 	bne	r2,zero,9088648 <__hi0bits+0x40>
 908863c:	2105883a 	add	r2,r4,r4
 9088640:	18c00084 	addi	r3,r3,2
 9088644:	1089883a 	add	r4,r2,r2
 9088648:	20000316 	blt	r4,zero,9088658 <__hi0bits+0x50>
 908864c:	2090002c 	andhi	r2,r4,16384
 9088650:	10000626 	beq	r2,zero,908866c <__hi0bits+0x64>
 9088654:	18c00044 	addi	r3,r3,1
 9088658:	1805883a 	mov	r2,r3
 908865c:	f800283a 	ret
 9088660:	2008943a 	slli	r4,r4,16
 9088664:	00c00404 	movi	r3,16
 9088668:	003fea06 	br	9088614 <__hi0bits+0xc>
 908866c:	00c00804 	movi	r3,32
 9088670:	1805883a 	mov	r2,r3
 9088674:	f800283a 	ret

09088678 <__lo0bits>:
 9088678:	20c00017 	ldw	r3,0(r4)
 908867c:	188001cc 	andi	r2,r3,7
 9088680:	10000a26 	beq	r2,zero,90886ac <__lo0bits+0x34>
 9088684:	1880004c 	andi	r2,r3,1
 9088688:	1005003a 	cmpeq	r2,r2,zero
 908868c:	10002126 	beq	r2,zero,9088714 <__lo0bits+0x9c>
 9088690:	1880008c 	andi	r2,r3,2
 9088694:	1000251e 	bne	r2,zero,908872c <__lo0bits+0xb4>
 9088698:	1804d0ba 	srli	r2,r3,2
 908869c:	01400084 	movi	r5,2
 90886a0:	20800015 	stw	r2,0(r4)
 90886a4:	2805883a 	mov	r2,r5
 90886a8:	f800283a 	ret
 90886ac:	18bfffcc 	andi	r2,r3,65535
 90886b0:	10001526 	beq	r2,zero,9088708 <__lo0bits+0x90>
 90886b4:	000b883a 	mov	r5,zero
 90886b8:	18803fcc 	andi	r2,r3,255
 90886bc:	1000021e 	bne	r2,zero,90886c8 <__lo0bits+0x50>
 90886c0:	1806d23a 	srli	r3,r3,8
 90886c4:	29400204 	addi	r5,r5,8
 90886c8:	188003cc 	andi	r2,r3,15
 90886cc:	1000021e 	bne	r2,zero,90886d8 <__lo0bits+0x60>
 90886d0:	1806d13a 	srli	r3,r3,4
 90886d4:	29400104 	addi	r5,r5,4
 90886d8:	188000cc 	andi	r2,r3,3
 90886dc:	1000021e 	bne	r2,zero,90886e8 <__lo0bits+0x70>
 90886e0:	1806d0ba 	srli	r3,r3,2
 90886e4:	29400084 	addi	r5,r5,2
 90886e8:	1880004c 	andi	r2,r3,1
 90886ec:	1000031e 	bne	r2,zero,90886fc <__lo0bits+0x84>
 90886f0:	1806d07a 	srli	r3,r3,1
 90886f4:	18000a26 	beq	r3,zero,9088720 <__lo0bits+0xa8>
 90886f8:	29400044 	addi	r5,r5,1
 90886fc:	2805883a 	mov	r2,r5
 9088700:	20c00015 	stw	r3,0(r4)
 9088704:	f800283a 	ret
 9088708:	1806d43a 	srli	r3,r3,16
 908870c:	01400404 	movi	r5,16
 9088710:	003fe906 	br	90886b8 <__lo0bits+0x40>
 9088714:	000b883a 	mov	r5,zero
 9088718:	2805883a 	mov	r2,r5
 908871c:	f800283a 	ret
 9088720:	01400804 	movi	r5,32
 9088724:	2805883a 	mov	r2,r5
 9088728:	f800283a 	ret
 908872c:	1804d07a 	srli	r2,r3,1
 9088730:	01400044 	movi	r5,1
 9088734:	20800015 	stw	r2,0(r4)
 9088738:	003fda06 	br	90886a4 <__lo0bits+0x2c>

0908873c <__mcmp>:
 908873c:	20800417 	ldw	r2,16(r4)
 9088740:	28c00417 	ldw	r3,16(r5)
 9088744:	10cfc83a 	sub	r7,r2,r3
 9088748:	38000c1e 	bne	r7,zero,908877c <__mcmp+0x40>
 908874c:	18c5883a 	add	r2,r3,r3
 9088750:	1085883a 	add	r2,r2,r2
 9088754:	10c00504 	addi	r3,r2,20
 9088758:	21000504 	addi	r4,r4,20
 908875c:	28cb883a 	add	r5,r5,r3
 9088760:	2085883a 	add	r2,r4,r2
 9088764:	10bfff04 	addi	r2,r2,-4
 9088768:	297fff04 	addi	r5,r5,-4
 908876c:	11800017 	ldw	r6,0(r2)
 9088770:	28c00017 	ldw	r3,0(r5)
 9088774:	30c0031e 	bne	r6,r3,9088784 <__mcmp+0x48>
 9088778:	20bffa36 	bltu	r4,r2,9088764 <__mcmp+0x28>
 908877c:	3805883a 	mov	r2,r7
 9088780:	f800283a 	ret
 9088784:	30c00336 	bltu	r6,r3,9088794 <__mcmp+0x58>
 9088788:	01c00044 	movi	r7,1
 908878c:	3805883a 	mov	r2,r7
 9088790:	f800283a 	ret
 9088794:	01ffffc4 	movi	r7,-1
 9088798:	003ff806 	br	908877c <__mcmp+0x40>

0908879c <__ulp>:
 908879c:	295ffc2c 	andhi	r5,r5,32752
 90887a0:	013f3034 	movhi	r4,64704
 90887a4:	290b883a 	add	r5,r5,r4
 90887a8:	0145c83a 	sub	r2,zero,r5
 90887ac:	1007d53a 	srai	r3,r2,20
 90887b0:	000d883a 	mov	r6,zero
 90887b4:	0140040e 	bge	zero,r5,90887c8 <__ulp+0x2c>
 90887b8:	280f883a 	mov	r7,r5
 90887bc:	3807883a 	mov	r3,r7
 90887c0:	3005883a 	mov	r2,r6
 90887c4:	f800283a 	ret
 90887c8:	008004c4 	movi	r2,19
 90887cc:	193ffb04 	addi	r4,r3,-20
 90887d0:	10c00c0e 	bge	r2,r3,9088804 <__ulp+0x68>
 90887d4:	008007c4 	movi	r2,31
 90887d8:	1107c83a 	sub	r3,r2,r4
 90887dc:	00800784 	movi	r2,30
 90887e0:	01400044 	movi	r5,1
 90887e4:	11000216 	blt	r2,r4,90887f0 <__ulp+0x54>
 90887e8:	00800044 	movi	r2,1
 90887ec:	10ca983a 	sll	r5,r2,r3
 90887f0:	000f883a 	mov	r7,zero
 90887f4:	280d883a 	mov	r6,r5
 90887f8:	3807883a 	mov	r3,r7
 90887fc:	3005883a 	mov	r2,r6
 9088800:	f800283a 	ret
 9088804:	00800234 	movhi	r2,8
 9088808:	10cfd83a 	sra	r7,r2,r3
 908880c:	000d883a 	mov	r6,zero
 9088810:	3005883a 	mov	r2,r6
 9088814:	3807883a 	mov	r3,r7
 9088818:	f800283a 	ret

0908881c <__b2d>:
 908881c:	20800417 	ldw	r2,16(r4)
 9088820:	defff904 	addi	sp,sp,-28
 9088824:	dd000415 	stw	r20,16(sp)
 9088828:	1085883a 	add	r2,r2,r2
 908882c:	25000504 	addi	r20,r4,20
 9088830:	1085883a 	add	r2,r2,r2
 9088834:	dc000015 	stw	r16,0(sp)
 9088838:	a0a1883a 	add	r16,r20,r2
 908883c:	dd400515 	stw	r21,20(sp)
 9088840:	857fff17 	ldw	r21,-4(r16)
 9088844:	dc400115 	stw	r17,4(sp)
 9088848:	dfc00615 	stw	ra,24(sp)
 908884c:	a809883a 	mov	r4,r21
 9088850:	2823883a 	mov	r17,r5
 9088854:	dcc00315 	stw	r19,12(sp)
 9088858:	dc800215 	stw	r18,8(sp)
 908885c:	90886080 	call	9088608 <__hi0bits>
 9088860:	100b883a 	mov	r5,r2
 9088864:	00800804 	movi	r2,32
 9088868:	1145c83a 	sub	r2,r2,r5
 908886c:	88800015 	stw	r2,0(r17)
 9088870:	00800284 	movi	r2,10
 9088874:	80ffff04 	addi	r3,r16,-4
 9088878:	11401416 	blt	r2,r5,90888cc <__b2d+0xb0>
 908887c:	008002c4 	movi	r2,11
 9088880:	1149c83a 	sub	r4,r2,r5
 9088884:	a0c02736 	bltu	r20,r3,9088924 <__b2d+0x108>
 9088888:	000d883a 	mov	r6,zero
 908888c:	28800544 	addi	r2,r5,21
 9088890:	a906d83a 	srl	r3,r21,r4
 9088894:	a884983a 	sll	r2,r21,r2
 9088898:	1ccffc34 	orhi	r19,r3,16368
 908889c:	11a4b03a 	or	r18,r2,r6
 90888a0:	9005883a 	mov	r2,r18
 90888a4:	9807883a 	mov	r3,r19
 90888a8:	dfc00617 	ldw	ra,24(sp)
 90888ac:	dd400517 	ldw	r21,20(sp)
 90888b0:	dd000417 	ldw	r20,16(sp)
 90888b4:	dcc00317 	ldw	r19,12(sp)
 90888b8:	dc800217 	ldw	r18,8(sp)
 90888bc:	dc400117 	ldw	r17,4(sp)
 90888c0:	dc000017 	ldw	r16,0(sp)
 90888c4:	dec00704 	addi	sp,sp,28
 90888c8:	f800283a 	ret
 90888cc:	a0c00e36 	bltu	r20,r3,9088908 <__b2d+0xec>
 90888d0:	293ffd44 	addi	r4,r5,-11
 90888d4:	000d883a 	mov	r6,zero
 90888d8:	20000f26 	beq	r4,zero,9088918 <__b2d+0xfc>
 90888dc:	00800804 	movi	r2,32
 90888e0:	110bc83a 	sub	r5,r2,r4
 90888e4:	a0c01236 	bltu	r20,r3,9088930 <__b2d+0x114>
 90888e8:	000f883a 	mov	r7,zero
 90888ec:	a904983a 	sll	r2,r21,r4
 90888f0:	3146d83a 	srl	r3,r6,r5
 90888f4:	3108983a 	sll	r4,r6,r4
 90888f8:	108ffc34 	orhi	r2,r2,16368
 90888fc:	18a6b03a 	or	r19,r3,r2
 9088900:	3924b03a 	or	r18,r7,r4
 9088904:	003fe606 	br	90888a0 <__b2d+0x84>
 9088908:	293ffd44 	addi	r4,r5,-11
 908890c:	81bffe17 	ldw	r6,-8(r16)
 9088910:	80fffe04 	addi	r3,r16,-8
 9088914:	203ff11e 	bne	r4,zero,90888dc <__b2d+0xc0>
 9088918:	accffc34 	orhi	r19,r21,16368
 908891c:	3025883a 	mov	r18,r6
 9088920:	003fdf06 	br	90888a0 <__b2d+0x84>
 9088924:	18bfff17 	ldw	r2,-4(r3)
 9088928:	110cd83a 	srl	r6,r2,r4
 908892c:	003fd706 	br	908888c <__b2d+0x70>
 9088930:	18bfff17 	ldw	r2,-4(r3)
 9088934:	114ed83a 	srl	r7,r2,r5
 9088938:	003fec06 	br	90888ec <__b2d+0xd0>

0908893c <__ratio>:
 908893c:	defff904 	addi	sp,sp,-28
 9088940:	dc400215 	stw	r17,8(sp)
 9088944:	2823883a 	mov	r17,r5
 9088948:	d80b883a 	mov	r5,sp
 908894c:	dfc00615 	stw	ra,24(sp)
 9088950:	dd000515 	stw	r20,20(sp)
 9088954:	dcc00415 	stw	r19,16(sp)
 9088958:	dc800315 	stw	r18,12(sp)
 908895c:	2025883a 	mov	r18,r4
 9088960:	908881c0 	call	908881c <__b2d>
 9088964:	8809883a 	mov	r4,r17
 9088968:	d9400104 	addi	r5,sp,4
 908896c:	1027883a 	mov	r19,r2
 9088970:	1829883a 	mov	r20,r3
 9088974:	908881c0 	call	908881c <__b2d>
 9088978:	89000417 	ldw	r4,16(r17)
 908897c:	91c00417 	ldw	r7,16(r18)
 9088980:	d9800117 	ldw	r6,4(sp)
 9088984:	180b883a 	mov	r5,r3
 9088988:	390fc83a 	sub	r7,r7,r4
 908898c:	1009883a 	mov	r4,r2
 9088990:	d8800017 	ldw	r2,0(sp)
 9088994:	380e917a 	slli	r7,r7,5
 9088998:	2011883a 	mov	r8,r4
 908899c:	1185c83a 	sub	r2,r2,r6
 90889a0:	11c5883a 	add	r2,r2,r7
 90889a4:	1006953a 	slli	r3,r2,20
 90889a8:	2813883a 	mov	r9,r5
 90889ac:	00800d0e 	bge	zero,r2,90889e4 <__ratio+0xa8>
 90889b0:	1d29883a 	add	r20,r3,r20
 90889b4:	a00b883a 	mov	r5,r20
 90889b8:	480f883a 	mov	r7,r9
 90889bc:	9809883a 	mov	r4,r19
 90889c0:	400d883a 	mov	r6,r8
 90889c4:	908b9680 	call	908b968 <__divdf3>
 90889c8:	dfc00617 	ldw	ra,24(sp)
 90889cc:	dd000517 	ldw	r20,20(sp)
 90889d0:	dcc00417 	ldw	r19,16(sp)
 90889d4:	dc800317 	ldw	r18,12(sp)
 90889d8:	dc400217 	ldw	r17,8(sp)
 90889dc:	dec00704 	addi	sp,sp,28
 90889e0:	f800283a 	ret
 90889e4:	28d3c83a 	sub	r9,r5,r3
 90889e8:	003ff206 	br	90889b4 <__ratio+0x78>

090889ec <_mprec_log10>:
 90889ec:	defffe04 	addi	sp,sp,-8
 90889f0:	008005c4 	movi	r2,23
 90889f4:	dc000015 	stw	r16,0(sp)
 90889f8:	dfc00115 	stw	ra,4(sp)
 90889fc:	2021883a 	mov	r16,r4
 9088a00:	11000c16 	blt	r2,r4,9088a34 <_mprec_log10+0x48>
 9088a04:	200490fa 	slli	r2,r4,3
 9088a08:	00c24374 	movhi	r3,2317
 9088a0c:	18f29d04 	addi	r3,r3,-13708
 9088a10:	10c5883a 	add	r2,r2,r3
 9088a14:	12400117 	ldw	r9,4(r2)
 9088a18:	12000017 	ldw	r8,0(r2)
 9088a1c:	4807883a 	mov	r3,r9
 9088a20:	4005883a 	mov	r2,r8
 9088a24:	dfc00117 	ldw	ra,4(sp)
 9088a28:	dc000017 	ldw	r16,0(sp)
 9088a2c:	dec00204 	addi	sp,sp,8
 9088a30:	f800283a 	ret
 9088a34:	0011883a 	mov	r8,zero
 9088a38:	024ffc34 	movhi	r9,16368
 9088a3c:	0005883a 	mov	r2,zero
 9088a40:	00d00934 	movhi	r3,16420
 9088a44:	480b883a 	mov	r5,r9
 9088a48:	4009883a 	mov	r4,r8
 9088a4c:	180f883a 	mov	r7,r3
 9088a50:	100d883a 	mov	r6,r2
 9088a54:	908b5b40 	call	908b5b4 <__muldf3>
 9088a58:	843fffc4 	addi	r16,r16,-1
 9088a5c:	1011883a 	mov	r8,r2
 9088a60:	1813883a 	mov	r9,r3
 9088a64:	803ff51e 	bne	r16,zero,9088a3c <_mprec_log10+0x50>
 9088a68:	4005883a 	mov	r2,r8
 9088a6c:	4807883a 	mov	r3,r9
 9088a70:	dfc00117 	ldw	ra,4(sp)
 9088a74:	dc000017 	ldw	r16,0(sp)
 9088a78:	dec00204 	addi	sp,sp,8
 9088a7c:	f800283a 	ret

09088a80 <__copybits>:
 9088a80:	297fffc4 	addi	r5,r5,-1
 9088a84:	30800417 	ldw	r2,16(r6)
 9088a88:	280bd17a 	srai	r5,r5,5
 9088a8c:	31800504 	addi	r6,r6,20
 9088a90:	1085883a 	add	r2,r2,r2
 9088a94:	294b883a 	add	r5,r5,r5
 9088a98:	294b883a 	add	r5,r5,r5
 9088a9c:	1085883a 	add	r2,r2,r2
 9088aa0:	290b883a 	add	r5,r5,r4
 9088aa4:	3087883a 	add	r3,r6,r2
 9088aa8:	29400104 	addi	r5,r5,4
 9088aac:	30c0052e 	bgeu	r6,r3,9088ac4 <__copybits+0x44>
 9088ab0:	30800017 	ldw	r2,0(r6)
 9088ab4:	31800104 	addi	r6,r6,4
 9088ab8:	20800015 	stw	r2,0(r4)
 9088abc:	21000104 	addi	r4,r4,4
 9088ac0:	30fffb36 	bltu	r6,r3,9088ab0 <__copybits+0x30>
 9088ac4:	2140032e 	bgeu	r4,r5,9088ad4 <__copybits+0x54>
 9088ac8:	20000015 	stw	zero,0(r4)
 9088acc:	21000104 	addi	r4,r4,4
 9088ad0:	217ffd36 	bltu	r4,r5,9088ac8 <__copybits+0x48>
 9088ad4:	f800283a 	ret

09088ad8 <__any_on>:
 9088ad8:	20800417 	ldw	r2,16(r4)
 9088adc:	2807d17a 	srai	r3,r5,5
 9088ae0:	21000504 	addi	r4,r4,20
 9088ae4:	10c00d0e 	bge	r2,r3,9088b1c <__any_on+0x44>
 9088ae8:	1085883a 	add	r2,r2,r2
 9088aec:	1085883a 	add	r2,r2,r2
 9088af0:	208d883a 	add	r6,r4,r2
 9088af4:	2180182e 	bgeu	r4,r6,9088b58 <__any_on+0x80>
 9088af8:	30bfff17 	ldw	r2,-4(r6)
 9088afc:	30ffff04 	addi	r3,r6,-4
 9088b00:	1000041e 	bne	r2,zero,9088b14 <__any_on+0x3c>
 9088b04:	20c0142e 	bgeu	r4,r3,9088b58 <__any_on+0x80>
 9088b08:	18ffff04 	addi	r3,r3,-4
 9088b0c:	18800017 	ldw	r2,0(r3)
 9088b10:	103ffc26 	beq	r2,zero,9088b04 <__any_on+0x2c>
 9088b14:	00800044 	movi	r2,1
 9088b18:	f800283a 	ret
 9088b1c:	18800a0e 	bge	r3,r2,9088b48 <__any_on+0x70>
 9088b20:	294007cc 	andi	r5,r5,31
 9088b24:	28000826 	beq	r5,zero,9088b48 <__any_on+0x70>
 9088b28:	18c5883a 	add	r2,r3,r3
 9088b2c:	1085883a 	add	r2,r2,r2
 9088b30:	208d883a 	add	r6,r4,r2
 9088b34:	30c00017 	ldw	r3,0(r6)
 9088b38:	1944d83a 	srl	r2,r3,r5
 9088b3c:	1144983a 	sll	r2,r2,r5
 9088b40:	18bff41e 	bne	r3,r2,9088b14 <__any_on+0x3c>
 9088b44:	003feb06 	br	9088af4 <__any_on+0x1c>
 9088b48:	18c5883a 	add	r2,r3,r3
 9088b4c:	1085883a 	add	r2,r2,r2
 9088b50:	208d883a 	add	r6,r4,r2
 9088b54:	003fe706 	br	9088af4 <__any_on+0x1c>
 9088b58:	0005883a 	mov	r2,zero
 9088b5c:	f800283a 	ret

09088b60 <_Balloc>:
 9088b60:	20c01317 	ldw	r3,76(r4)
 9088b64:	defffb04 	addi	sp,sp,-20
 9088b68:	dcc00315 	stw	r19,12(sp)
 9088b6c:	dc800215 	stw	r18,8(sp)
 9088b70:	dfc00415 	stw	ra,16(sp)
 9088b74:	2825883a 	mov	r18,r5
 9088b78:	dc400115 	stw	r17,4(sp)
 9088b7c:	dc000015 	stw	r16,0(sp)
 9088b80:	2027883a 	mov	r19,r4
 9088b84:	01800404 	movi	r6,16
 9088b88:	01400104 	movi	r5,4
 9088b8c:	18001726 	beq	r3,zero,9088bec <_Balloc+0x8c>
 9088b90:	01400044 	movi	r5,1
 9088b94:	9485883a 	add	r2,r18,r18
 9088b98:	2ca2983a 	sll	r17,r5,r18
 9088b9c:	1085883a 	add	r2,r2,r2
 9088ba0:	10c7883a 	add	r3,r2,r3
 9088ba4:	1c000017 	ldw	r16,0(r3)
 9088ba8:	8c4d883a 	add	r6,r17,r17
 9088bac:	318d883a 	add	r6,r6,r6
 9088bb0:	9809883a 	mov	r4,r19
 9088bb4:	31800504 	addi	r6,r6,20
 9088bb8:	80001226 	beq	r16,zero,9088c04 <_Balloc+0xa4>
 9088bbc:	80800017 	ldw	r2,0(r16)
 9088bc0:	18800015 	stw	r2,0(r3)
 9088bc4:	80000415 	stw	zero,16(r16)
 9088bc8:	80000315 	stw	zero,12(r16)
 9088bcc:	8005883a 	mov	r2,r16
 9088bd0:	dfc00417 	ldw	ra,16(sp)
 9088bd4:	dcc00317 	ldw	r19,12(sp)
 9088bd8:	dc800217 	ldw	r18,8(sp)
 9088bdc:	dc400117 	ldw	r17,4(sp)
 9088be0:	dc000017 	ldw	r16,0(sp)
 9088be4:	dec00504 	addi	sp,sp,20
 9088be8:	f800283a 	ret
 9088bec:	908a1080 	call	908a108 <_calloc_r>
 9088bf0:	1007883a 	mov	r3,r2
 9088bf4:	0021883a 	mov	r16,zero
 9088bf8:	98801315 	stw	r2,76(r19)
 9088bfc:	103fe41e 	bne	r2,zero,9088b90 <_Balloc+0x30>
 9088c00:	003ff206 	br	9088bcc <_Balloc+0x6c>
 9088c04:	908a1080 	call	908a108 <_calloc_r>
 9088c08:	103ff026 	beq	r2,zero,9088bcc <_Balloc+0x6c>
 9088c0c:	1021883a 	mov	r16,r2
 9088c10:	14800115 	stw	r18,4(r2)
 9088c14:	14400215 	stw	r17,8(r2)
 9088c18:	003fea06 	br	9088bc4 <_Balloc+0x64>

09088c1c <__d2b>:
 9088c1c:	defff504 	addi	sp,sp,-44
 9088c20:	dcc00515 	stw	r19,20(sp)
 9088c24:	04c00044 	movi	r19,1
 9088c28:	dc000215 	stw	r16,8(sp)
 9088c2c:	2821883a 	mov	r16,r5
 9088c30:	980b883a 	mov	r5,r19
 9088c34:	ddc00915 	stw	r23,36(sp)
 9088c38:	dd800815 	stw	r22,32(sp)
 9088c3c:	dd400715 	stw	r21,28(sp)
 9088c40:	dd000615 	stw	r20,24(sp)
 9088c44:	dc800415 	stw	r18,16(sp)
 9088c48:	dc400315 	stw	r17,12(sp)
 9088c4c:	dfc00a15 	stw	ra,40(sp)
 9088c50:	3023883a 	mov	r17,r6
 9088c54:	382d883a 	mov	r22,r7
 9088c58:	ddc00b17 	ldw	r23,44(sp)
 9088c5c:	9088b600 	call	9088b60 <_Balloc>
 9088c60:	1025883a 	mov	r18,r2
 9088c64:	00a00034 	movhi	r2,32768
 9088c68:	10bfffc4 	addi	r2,r2,-1
 9088c6c:	8888703a 	and	r4,r17,r2
 9088c70:	202ad53a 	srli	r21,r4,20
 9088c74:	00800434 	movhi	r2,16
 9088c78:	10bfffc4 	addi	r2,r2,-1
 9088c7c:	8886703a 	and	r3,r17,r2
 9088c80:	a829003a 	cmpeq	r20,r21,zero
 9088c84:	800b883a 	mov	r5,r16
 9088c88:	d8c00115 	stw	r3,4(sp)
 9088c8c:	94000504 	addi	r16,r18,20
 9088c90:	a000021e 	bne	r20,zero,9088c9c <__d2b+0x80>
 9088c94:	18c00434 	orhi	r3,r3,16
 9088c98:	d8c00115 	stw	r3,4(sp)
 9088c9c:	28002726 	beq	r5,zero,9088d3c <__d2b+0x120>
 9088ca0:	d809883a 	mov	r4,sp
 9088ca4:	d9400015 	stw	r5,0(sp)
 9088ca8:	90886780 	call	9088678 <__lo0bits>
 9088cac:	100d883a 	mov	r6,r2
 9088cb0:	10003526 	beq	r2,zero,9088d88 <__d2b+0x16c>
 9088cb4:	d8c00117 	ldw	r3,4(sp)
 9088cb8:	00800804 	movi	r2,32
 9088cbc:	1185c83a 	sub	r2,r2,r6
 9088cc0:	d9000017 	ldw	r4,0(sp)
 9088cc4:	1886983a 	sll	r3,r3,r2
 9088cc8:	1906b03a 	or	r3,r3,r4
 9088ccc:	90c00515 	stw	r3,20(r18)
 9088cd0:	d8c00117 	ldw	r3,4(sp)
 9088cd4:	1986d83a 	srl	r3,r3,r6
 9088cd8:	d8c00115 	stw	r3,4(sp)
 9088cdc:	180b003a 	cmpeq	r5,r3,zero
 9088ce0:	00800084 	movi	r2,2
 9088ce4:	114bc83a 	sub	r5,r2,r5
 9088ce8:	80c00115 	stw	r3,4(r16)
 9088cec:	91400415 	stw	r5,16(r18)
 9088cf0:	a0001a1e 	bne	r20,zero,9088d5c <__d2b+0x140>
 9088cf4:	3545883a 	add	r2,r6,r21
 9088cf8:	10bef344 	addi	r2,r2,-1075
 9088cfc:	00c00d44 	movi	r3,53
 9088d00:	b0800015 	stw	r2,0(r22)
 9088d04:	1987c83a 	sub	r3,r3,r6
 9088d08:	b8c00015 	stw	r3,0(r23)
 9088d0c:	9005883a 	mov	r2,r18
 9088d10:	dfc00a17 	ldw	ra,40(sp)
 9088d14:	ddc00917 	ldw	r23,36(sp)
 9088d18:	dd800817 	ldw	r22,32(sp)
 9088d1c:	dd400717 	ldw	r21,28(sp)
 9088d20:	dd000617 	ldw	r20,24(sp)
 9088d24:	dcc00517 	ldw	r19,20(sp)
 9088d28:	dc800417 	ldw	r18,16(sp)
 9088d2c:	dc400317 	ldw	r17,12(sp)
 9088d30:	dc000217 	ldw	r16,8(sp)
 9088d34:	dec00b04 	addi	sp,sp,44
 9088d38:	f800283a 	ret
 9088d3c:	d9000104 	addi	r4,sp,4
 9088d40:	90886780 	call	9088678 <__lo0bits>
 9088d44:	11800804 	addi	r6,r2,32
 9088d48:	d8800117 	ldw	r2,4(sp)
 9088d4c:	94c00415 	stw	r19,16(r18)
 9088d50:	980b883a 	mov	r5,r19
 9088d54:	90800515 	stw	r2,20(r18)
 9088d58:	a03fe626 	beq	r20,zero,9088cf4 <__d2b+0xd8>
 9088d5c:	2945883a 	add	r2,r5,r5
 9088d60:	1085883a 	add	r2,r2,r2
 9088d64:	1405883a 	add	r2,r2,r16
 9088d68:	113fff17 	ldw	r4,-4(r2)
 9088d6c:	30fef384 	addi	r3,r6,-1074
 9088d70:	2820917a 	slli	r16,r5,5
 9088d74:	b0c00015 	stw	r3,0(r22)
 9088d78:	90886080 	call	9088608 <__hi0bits>
 9088d7c:	80a1c83a 	sub	r16,r16,r2
 9088d80:	bc000015 	stw	r16,0(r23)
 9088d84:	003fe106 	br	9088d0c <__d2b+0xf0>
 9088d88:	d8800017 	ldw	r2,0(sp)
 9088d8c:	90800515 	stw	r2,20(r18)
 9088d90:	d8c00117 	ldw	r3,4(sp)
 9088d94:	003fd106 	br	9088cdc <__d2b+0xc0>

09088d98 <__mdiff>:
 9088d98:	defffb04 	addi	sp,sp,-20
 9088d9c:	dc000015 	stw	r16,0(sp)
 9088da0:	2821883a 	mov	r16,r5
 9088da4:	dc800215 	stw	r18,8(sp)
 9088da8:	300b883a 	mov	r5,r6
 9088dac:	2025883a 	mov	r18,r4
 9088db0:	8009883a 	mov	r4,r16
 9088db4:	dc400115 	stw	r17,4(sp)
 9088db8:	dfc00415 	stw	ra,16(sp)
 9088dbc:	dcc00315 	stw	r19,12(sp)
 9088dc0:	3023883a 	mov	r17,r6
 9088dc4:	908873c0 	call	908873c <__mcmp>
 9088dc8:	10004226 	beq	r2,zero,9088ed4 <__mdiff+0x13c>
 9088dcc:	10005016 	blt	r2,zero,9088f10 <__mdiff+0x178>
 9088dd0:	0027883a 	mov	r19,zero
 9088dd4:	81400117 	ldw	r5,4(r16)
 9088dd8:	9009883a 	mov	r4,r18
 9088ddc:	9088b600 	call	9088b60 <_Balloc>
 9088de0:	1019883a 	mov	r12,r2
 9088de4:	82800417 	ldw	r10,16(r16)
 9088de8:	88800417 	ldw	r2,16(r17)
 9088dec:	81800504 	addi	r6,r16,20
 9088df0:	5287883a 	add	r3,r10,r10
 9088df4:	1085883a 	add	r2,r2,r2
 9088df8:	18c7883a 	add	r3,r3,r3
 9088dfc:	1085883a 	add	r2,r2,r2
 9088e00:	8a000504 	addi	r8,r17,20
 9088e04:	64c00315 	stw	r19,12(r12)
 9088e08:	30db883a 	add	r13,r6,r3
 9088e0c:	4097883a 	add	r11,r8,r2
 9088e10:	61c00504 	addi	r7,r12,20
 9088e14:	0013883a 	mov	r9,zero
 9088e18:	31000017 	ldw	r4,0(r6)
 9088e1c:	41400017 	ldw	r5,0(r8)
 9088e20:	42000104 	addi	r8,r8,4
 9088e24:	20bfffcc 	andi	r2,r4,65535
 9088e28:	28ffffcc 	andi	r3,r5,65535
 9088e2c:	10c5c83a 	sub	r2,r2,r3
 9088e30:	1245883a 	add	r2,r2,r9
 9088e34:	2008d43a 	srli	r4,r4,16
 9088e38:	280ad43a 	srli	r5,r5,16
 9088e3c:	1007d43a 	srai	r3,r2,16
 9088e40:	3880000d 	sth	r2,0(r7)
 9088e44:	2149c83a 	sub	r4,r4,r5
 9088e48:	20c9883a 	add	r4,r4,r3
 9088e4c:	3900008d 	sth	r4,2(r7)
 9088e50:	31800104 	addi	r6,r6,4
 9088e54:	39c00104 	addi	r7,r7,4
 9088e58:	2013d43a 	srai	r9,r4,16
 9088e5c:	42ffee36 	bltu	r8,r11,9088e18 <__mdiff+0x80>
 9088e60:	33400c2e 	bgeu	r6,r13,9088e94 <__mdiff+0xfc>
 9088e64:	30800017 	ldw	r2,0(r6)
 9088e68:	31800104 	addi	r6,r6,4
 9088e6c:	10ffffcc 	andi	r3,r2,65535
 9088e70:	1a47883a 	add	r3,r3,r9
 9088e74:	1004d43a 	srli	r2,r2,16
 9088e78:	1809d43a 	srai	r4,r3,16
 9088e7c:	38c0000d 	sth	r3,0(r7)
 9088e80:	1105883a 	add	r2,r2,r4
 9088e84:	3880008d 	sth	r2,2(r7)
 9088e88:	1013d43a 	srai	r9,r2,16
 9088e8c:	39c00104 	addi	r7,r7,4
 9088e90:	337ff436 	bltu	r6,r13,9088e64 <__mdiff+0xcc>
 9088e94:	38bfff17 	ldw	r2,-4(r7)
 9088e98:	38ffff04 	addi	r3,r7,-4
 9088e9c:	1000041e 	bne	r2,zero,9088eb0 <__mdiff+0x118>
 9088ea0:	18ffff04 	addi	r3,r3,-4
 9088ea4:	18800017 	ldw	r2,0(r3)
 9088ea8:	52bfffc4 	addi	r10,r10,-1
 9088eac:	103ffc26 	beq	r2,zero,9088ea0 <__mdiff+0x108>
 9088eb0:	6005883a 	mov	r2,r12
 9088eb4:	62800415 	stw	r10,16(r12)
 9088eb8:	dfc00417 	ldw	ra,16(sp)
 9088ebc:	dcc00317 	ldw	r19,12(sp)
 9088ec0:	dc800217 	ldw	r18,8(sp)
 9088ec4:	dc400117 	ldw	r17,4(sp)
 9088ec8:	dc000017 	ldw	r16,0(sp)
 9088ecc:	dec00504 	addi	sp,sp,20
 9088ed0:	f800283a 	ret
 9088ed4:	9009883a 	mov	r4,r18
 9088ed8:	000b883a 	mov	r5,zero
 9088edc:	9088b600 	call	9088b60 <_Balloc>
 9088ee0:	1019883a 	mov	r12,r2
 9088ee4:	00800044 	movi	r2,1
 9088ee8:	60800415 	stw	r2,16(r12)
 9088eec:	6005883a 	mov	r2,r12
 9088ef0:	60000515 	stw	zero,20(r12)
 9088ef4:	dfc00417 	ldw	ra,16(sp)
 9088ef8:	dcc00317 	ldw	r19,12(sp)
 9088efc:	dc800217 	ldw	r18,8(sp)
 9088f00:	dc400117 	ldw	r17,4(sp)
 9088f04:	dc000017 	ldw	r16,0(sp)
 9088f08:	dec00504 	addi	sp,sp,20
 9088f0c:	f800283a 	ret
 9088f10:	880d883a 	mov	r6,r17
 9088f14:	04c00044 	movi	r19,1
 9088f18:	8023883a 	mov	r17,r16
 9088f1c:	3021883a 	mov	r16,r6
 9088f20:	003fac06 	br	9088dd4 <__mdiff+0x3c>

09088f24 <__lshift>:
 9088f24:	defff904 	addi	sp,sp,-28
 9088f28:	28800417 	ldw	r2,16(r5)
 9088f2c:	dc000015 	stw	r16,0(sp)
 9088f30:	3021d17a 	srai	r16,r6,5
 9088f34:	28c00217 	ldw	r3,8(r5)
 9088f38:	10800044 	addi	r2,r2,1
 9088f3c:	dc400115 	stw	r17,4(sp)
 9088f40:	80a3883a 	add	r17,r16,r2
 9088f44:	dd400515 	stw	r21,20(sp)
 9088f48:	dd000415 	stw	r20,16(sp)
 9088f4c:	dc800215 	stw	r18,8(sp)
 9088f50:	dfc00615 	stw	ra,24(sp)
 9088f54:	2825883a 	mov	r18,r5
 9088f58:	dcc00315 	stw	r19,12(sp)
 9088f5c:	3029883a 	mov	r20,r6
 9088f60:	202b883a 	mov	r21,r4
 9088f64:	29400117 	ldw	r5,4(r5)
 9088f68:	1c40030e 	bge	r3,r17,9088f78 <__lshift+0x54>
 9088f6c:	18c7883a 	add	r3,r3,r3
 9088f70:	29400044 	addi	r5,r5,1
 9088f74:	1c7ffd16 	blt	r3,r17,9088f6c <__lshift+0x48>
 9088f78:	a809883a 	mov	r4,r21
 9088f7c:	9088b600 	call	9088b60 <_Balloc>
 9088f80:	1027883a 	mov	r19,r2
 9088f84:	11400504 	addi	r5,r2,20
 9088f88:	0400090e 	bge	zero,r16,9088fb0 <__lshift+0x8c>
 9088f8c:	2805883a 	mov	r2,r5
 9088f90:	0007883a 	mov	r3,zero
 9088f94:	18c00044 	addi	r3,r3,1
 9088f98:	10000015 	stw	zero,0(r2)
 9088f9c:	10800104 	addi	r2,r2,4
 9088fa0:	80fffc1e 	bne	r16,r3,9088f94 <__lshift+0x70>
 9088fa4:	8405883a 	add	r2,r16,r16
 9088fa8:	1085883a 	add	r2,r2,r2
 9088fac:	288b883a 	add	r5,r5,r2
 9088fb0:	90800417 	ldw	r2,16(r18)
 9088fb4:	91000504 	addi	r4,r18,20
 9088fb8:	a18007cc 	andi	r6,r20,31
 9088fbc:	1085883a 	add	r2,r2,r2
 9088fc0:	1085883a 	add	r2,r2,r2
 9088fc4:	208f883a 	add	r7,r4,r2
 9088fc8:	30001e26 	beq	r6,zero,9089044 <__lshift+0x120>
 9088fcc:	00800804 	movi	r2,32
 9088fd0:	1191c83a 	sub	r8,r2,r6
 9088fd4:	0007883a 	mov	r3,zero
 9088fd8:	20800017 	ldw	r2,0(r4)
 9088fdc:	1184983a 	sll	r2,r2,r6
 9088fe0:	1884b03a 	or	r2,r3,r2
 9088fe4:	28800015 	stw	r2,0(r5)
 9088fe8:	20c00017 	ldw	r3,0(r4)
 9088fec:	21000104 	addi	r4,r4,4
 9088ff0:	29400104 	addi	r5,r5,4
 9088ff4:	1a06d83a 	srl	r3,r3,r8
 9088ff8:	21fff736 	bltu	r4,r7,9088fd8 <__lshift+0xb4>
 9088ffc:	28c00015 	stw	r3,0(r5)
 9089000:	18000126 	beq	r3,zero,9089008 <__lshift+0xe4>
 9089004:	8c400044 	addi	r17,r17,1
 9089008:	88bfffc4 	addi	r2,r17,-1
 908900c:	98800415 	stw	r2,16(r19)
 9089010:	a809883a 	mov	r4,r21
 9089014:	900b883a 	mov	r5,r18
 9089018:	90885e00 	call	90885e0 <_Bfree>
 908901c:	9805883a 	mov	r2,r19
 9089020:	dfc00617 	ldw	ra,24(sp)
 9089024:	dd400517 	ldw	r21,20(sp)
 9089028:	dd000417 	ldw	r20,16(sp)
 908902c:	dcc00317 	ldw	r19,12(sp)
 9089030:	dc800217 	ldw	r18,8(sp)
 9089034:	dc400117 	ldw	r17,4(sp)
 9089038:	dc000017 	ldw	r16,0(sp)
 908903c:	dec00704 	addi	sp,sp,28
 9089040:	f800283a 	ret
 9089044:	20800017 	ldw	r2,0(r4)
 9089048:	21000104 	addi	r4,r4,4
 908904c:	28800015 	stw	r2,0(r5)
 9089050:	29400104 	addi	r5,r5,4
 9089054:	21ffec2e 	bgeu	r4,r7,9089008 <__lshift+0xe4>
 9089058:	20800017 	ldw	r2,0(r4)
 908905c:	21000104 	addi	r4,r4,4
 9089060:	28800015 	stw	r2,0(r5)
 9089064:	29400104 	addi	r5,r5,4
 9089068:	21fff636 	bltu	r4,r7,9089044 <__lshift+0x120>
 908906c:	003fe606 	br	9089008 <__lshift+0xe4>

09089070 <__multiply>:
 9089070:	defff904 	addi	sp,sp,-28
 9089074:	dcc00315 	stw	r19,12(sp)
 9089078:	dc800215 	stw	r18,8(sp)
 908907c:	2cc00417 	ldw	r19,16(r5)
 9089080:	34800417 	ldw	r18,16(r6)
 9089084:	dd000415 	stw	r20,16(sp)
 9089088:	dc400115 	stw	r17,4(sp)
 908908c:	dfc00615 	stw	ra,24(sp)
 9089090:	dd400515 	stw	r21,20(sp)
 9089094:	dc000015 	stw	r16,0(sp)
 9089098:	2823883a 	mov	r17,r5
 908909c:	3029883a 	mov	r20,r6
 90890a0:	9c80040e 	bge	r19,r18,90890b4 <__multiply+0x44>
 90890a4:	9027883a 	mov	r19,r18
 90890a8:	2c800417 	ldw	r18,16(r5)
 90890ac:	2829883a 	mov	r20,r5
 90890b0:	3023883a 	mov	r17,r6
 90890b4:	88800217 	ldw	r2,8(r17)
 90890b8:	9ca1883a 	add	r16,r19,r18
 90890bc:	89400117 	ldw	r5,4(r17)
 90890c0:	1400010e 	bge	r2,r16,90890c8 <__multiply+0x58>
 90890c4:	29400044 	addi	r5,r5,1
 90890c8:	9088b600 	call	9088b60 <_Balloc>
 90890cc:	102b883a 	mov	r21,r2
 90890d0:	8405883a 	add	r2,r16,r16
 90890d4:	1085883a 	add	r2,r2,r2
 90890d8:	a9000504 	addi	r4,r21,20
 90890dc:	209d883a 	add	r14,r4,r2
 90890e0:	2380042e 	bgeu	r4,r14,90890f4 <__multiply+0x84>
 90890e4:	2005883a 	mov	r2,r4
 90890e8:	10000015 	stw	zero,0(r2)
 90890ec:	10800104 	addi	r2,r2,4
 90890f0:	13bffd36 	bltu	r2,r14,90890e8 <__multiply+0x78>
 90890f4:	9485883a 	add	r2,r18,r18
 90890f8:	9cc7883a 	add	r3,r19,r19
 90890fc:	a1800504 	addi	r6,r20,20
 9089100:	1085883a 	add	r2,r2,r2
 9089104:	8b400504 	addi	r13,r17,20
 9089108:	18c7883a 	add	r3,r3,r3
 908910c:	309f883a 	add	r15,r6,r2
 9089110:	68d7883a 	add	r11,r13,r3
 9089114:	33c03b2e 	bgeu	r6,r15,9089204 <__multiply+0x194>
 9089118:	2019883a 	mov	r12,r4
 908911c:	30800017 	ldw	r2,0(r6)
 9089120:	127fffcc 	andi	r9,r2,65535
 9089124:	48001826 	beq	r9,zero,9089188 <__multiply+0x118>
 9089128:	6811883a 	mov	r8,r13
 908912c:	600f883a 	mov	r7,r12
 9089130:	0015883a 	mov	r10,zero
 9089134:	40c00017 	ldw	r3,0(r8)
 9089138:	39400017 	ldw	r5,0(r7)
 908913c:	42000104 	addi	r8,r8,4
 9089140:	193fffcc 	andi	r4,r3,65535
 9089144:	4909383a 	mul	r4,r9,r4
 9089148:	1806d43a 	srli	r3,r3,16
 908914c:	28bfffcc 	andi	r2,r5,65535
 9089150:	5085883a 	add	r2,r10,r2
 9089154:	2089883a 	add	r4,r4,r2
 9089158:	48c7383a 	mul	r3,r9,r3
 908915c:	280ad43a 	srli	r5,r5,16
 9089160:	2004d43a 	srli	r2,r4,16
 9089164:	3900000d 	sth	r4,0(r7)
 9089168:	1947883a 	add	r3,r3,r5
 908916c:	10c5883a 	add	r2,r2,r3
 9089170:	3880008d 	sth	r2,2(r7)
 9089174:	1014d43a 	srli	r10,r2,16
 9089178:	39c00104 	addi	r7,r7,4
 908917c:	42ffed36 	bltu	r8,r11,9089134 <__multiply+0xc4>
 9089180:	3a800015 	stw	r10,0(r7)
 9089184:	30800017 	ldw	r2,0(r6)
 9089188:	1012d43a 	srli	r9,r2,16
 908918c:	48001926 	beq	r9,zero,90891f4 <__multiply+0x184>
 9089190:	60800017 	ldw	r2,0(r12)
 9089194:	6811883a 	mov	r8,r13
 9089198:	600f883a 	mov	r7,r12
 908919c:	0015883a 	mov	r10,zero
 90891a0:	100b883a 	mov	r5,r2
 90891a4:	41000017 	ldw	r4,0(r8)
 90891a8:	2806d43a 	srli	r3,r5,16
 90891ac:	3880000d 	sth	r2,0(r7)
 90891b0:	20bfffcc 	andi	r2,r4,65535
 90891b4:	4885383a 	mul	r2,r9,r2
 90891b8:	50c7883a 	add	r3,r10,r3
 90891bc:	2008d43a 	srli	r4,r4,16
 90891c0:	10c5883a 	add	r2,r2,r3
 90891c4:	3880008d 	sth	r2,2(r7)
 90891c8:	39c00104 	addi	r7,r7,4
 90891cc:	39400017 	ldw	r5,0(r7)
 90891d0:	4909383a 	mul	r4,r9,r4
 90891d4:	1004d43a 	srli	r2,r2,16
 90891d8:	28ffffcc 	andi	r3,r5,65535
 90891dc:	20c9883a 	add	r4,r4,r3
 90891e0:	1105883a 	add	r2,r2,r4
 90891e4:	42000104 	addi	r8,r8,4
 90891e8:	1014d43a 	srli	r10,r2,16
 90891ec:	42ffed36 	bltu	r8,r11,90891a4 <__multiply+0x134>
 90891f0:	38800015 	stw	r2,0(r7)
 90891f4:	31800104 	addi	r6,r6,4
 90891f8:	33c0022e 	bgeu	r6,r15,9089204 <__multiply+0x194>
 90891fc:	63000104 	addi	r12,r12,4
 9089200:	003fc606 	br	908911c <__multiply+0xac>
 9089204:	0400090e 	bge	zero,r16,908922c <__multiply+0x1bc>
 9089208:	70bfff17 	ldw	r2,-4(r14)
 908920c:	70ffff04 	addi	r3,r14,-4
 9089210:	10000326 	beq	r2,zero,9089220 <__multiply+0x1b0>
 9089214:	00000506 	br	908922c <__multiply+0x1bc>
 9089218:	18800017 	ldw	r2,0(r3)
 908921c:	1000031e 	bne	r2,zero,908922c <__multiply+0x1bc>
 9089220:	843fffc4 	addi	r16,r16,-1
 9089224:	18ffff04 	addi	r3,r3,-4
 9089228:	803ffb1e 	bne	r16,zero,9089218 <__multiply+0x1a8>
 908922c:	a805883a 	mov	r2,r21
 9089230:	ac000415 	stw	r16,16(r21)
 9089234:	dfc00617 	ldw	ra,24(sp)
 9089238:	dd400517 	ldw	r21,20(sp)
 908923c:	dd000417 	ldw	r20,16(sp)
 9089240:	dcc00317 	ldw	r19,12(sp)
 9089244:	dc800217 	ldw	r18,8(sp)
 9089248:	dc400117 	ldw	r17,4(sp)
 908924c:	dc000017 	ldw	r16,0(sp)
 9089250:	dec00704 	addi	sp,sp,28
 9089254:	f800283a 	ret

09089258 <__i2b>:
 9089258:	defffd04 	addi	sp,sp,-12
 908925c:	dc000015 	stw	r16,0(sp)
 9089260:	04000044 	movi	r16,1
 9089264:	dc800115 	stw	r18,4(sp)
 9089268:	2825883a 	mov	r18,r5
 908926c:	800b883a 	mov	r5,r16
 9089270:	dfc00215 	stw	ra,8(sp)
 9089274:	9088b600 	call	9088b60 <_Balloc>
 9089278:	14000415 	stw	r16,16(r2)
 908927c:	14800515 	stw	r18,20(r2)
 9089280:	dfc00217 	ldw	ra,8(sp)
 9089284:	dc800117 	ldw	r18,4(sp)
 9089288:	dc000017 	ldw	r16,0(sp)
 908928c:	dec00304 	addi	sp,sp,12
 9089290:	f800283a 	ret

09089294 <__multadd>:
 9089294:	defffa04 	addi	sp,sp,-24
 9089298:	dc800215 	stw	r18,8(sp)
 908929c:	2c800417 	ldw	r18,16(r5)
 90892a0:	dd000415 	stw	r20,16(sp)
 90892a4:	dcc00315 	stw	r19,12(sp)
 90892a8:	dc000015 	stw	r16,0(sp)
 90892ac:	dfc00515 	stw	ra,20(sp)
 90892b0:	3821883a 	mov	r16,r7
 90892b4:	dc400115 	stw	r17,4(sp)
 90892b8:	2827883a 	mov	r19,r5
 90892bc:	2029883a 	mov	r20,r4
 90892c0:	2a000504 	addi	r8,r5,20
 90892c4:	000f883a 	mov	r7,zero
 90892c8:	40800017 	ldw	r2,0(r8)
 90892cc:	39c00044 	addi	r7,r7,1
 90892d0:	10ffffcc 	andi	r3,r2,65535
 90892d4:	1987383a 	mul	r3,r3,r6
 90892d8:	1004d43a 	srli	r2,r2,16
 90892dc:	1c07883a 	add	r3,r3,r16
 90892e0:	180ad43a 	srli	r5,r3,16
 90892e4:	1185383a 	mul	r2,r2,r6
 90892e8:	18ffffcc 	andi	r3,r3,65535
 90892ec:	1145883a 	add	r2,r2,r5
 90892f0:	1008943a 	slli	r4,r2,16
 90892f4:	1020d43a 	srli	r16,r2,16
 90892f8:	20c9883a 	add	r4,r4,r3
 90892fc:	41000015 	stw	r4,0(r8)
 9089300:	42000104 	addi	r8,r8,4
 9089304:	3cbff016 	blt	r7,r18,90892c8 <__multadd+0x34>
 9089308:	80000826 	beq	r16,zero,908932c <__multadd+0x98>
 908930c:	98800217 	ldw	r2,8(r19)
 9089310:	90800f0e 	bge	r18,r2,9089350 <__multadd+0xbc>
 9089314:	9485883a 	add	r2,r18,r18
 9089318:	1085883a 	add	r2,r2,r2
 908931c:	14c5883a 	add	r2,r2,r19
 9089320:	90c00044 	addi	r3,r18,1
 9089324:	14000515 	stw	r16,20(r2)
 9089328:	98c00415 	stw	r3,16(r19)
 908932c:	9805883a 	mov	r2,r19
 9089330:	dfc00517 	ldw	ra,20(sp)
 9089334:	dd000417 	ldw	r20,16(sp)
 9089338:	dcc00317 	ldw	r19,12(sp)
 908933c:	dc800217 	ldw	r18,8(sp)
 9089340:	dc400117 	ldw	r17,4(sp)
 9089344:	dc000017 	ldw	r16,0(sp)
 9089348:	dec00604 	addi	sp,sp,24
 908934c:	f800283a 	ret
 9089350:	99400117 	ldw	r5,4(r19)
 9089354:	a009883a 	mov	r4,r20
 9089358:	29400044 	addi	r5,r5,1
 908935c:	9088b600 	call	9088b60 <_Balloc>
 9089360:	99800417 	ldw	r6,16(r19)
 9089364:	99400304 	addi	r5,r19,12
 9089368:	11000304 	addi	r4,r2,12
 908936c:	318d883a 	add	r6,r6,r6
 9089370:	318d883a 	add	r6,r6,r6
 9089374:	31800204 	addi	r6,r6,8
 9089378:	1023883a 	mov	r17,r2
 908937c:	90822780 	call	9082278 <memcpy>
 9089380:	980b883a 	mov	r5,r19
 9089384:	a009883a 	mov	r4,r20
 9089388:	90885e00 	call	90885e0 <_Bfree>
 908938c:	8827883a 	mov	r19,r17
 9089390:	003fe006 	br	9089314 <__multadd+0x80>

09089394 <__pow5mult>:
 9089394:	defffa04 	addi	sp,sp,-24
 9089398:	308000cc 	andi	r2,r6,3
 908939c:	dd000415 	stw	r20,16(sp)
 90893a0:	dcc00315 	stw	r19,12(sp)
 90893a4:	dc000015 	stw	r16,0(sp)
 90893a8:	dfc00515 	stw	ra,20(sp)
 90893ac:	dc800215 	stw	r18,8(sp)
 90893b0:	dc400115 	stw	r17,4(sp)
 90893b4:	3021883a 	mov	r16,r6
 90893b8:	2027883a 	mov	r19,r4
 90893bc:	2829883a 	mov	r20,r5
 90893c0:	10002b1e 	bne	r2,zero,9089470 <__pow5mult+0xdc>
 90893c4:	8025d0ba 	srai	r18,r16,2
 90893c8:	90001b26 	beq	r18,zero,9089438 <__pow5mult+0xa4>
 90893cc:	9c001217 	ldw	r16,72(r19)
 90893d0:	8000081e 	bne	r16,zero,90893f4 <__pow5mult+0x60>
 90893d4:	00003006 	br	9089498 <__pow5mult+0x104>
 90893d8:	800b883a 	mov	r5,r16
 90893dc:	800d883a 	mov	r6,r16
 90893e0:	9809883a 	mov	r4,r19
 90893e4:	90001426 	beq	r18,zero,9089438 <__pow5mult+0xa4>
 90893e8:	80800017 	ldw	r2,0(r16)
 90893ec:	10001b26 	beq	r2,zero,908945c <__pow5mult+0xc8>
 90893f0:	1021883a 	mov	r16,r2
 90893f4:	9080004c 	andi	r2,r18,1
 90893f8:	1005003a 	cmpeq	r2,r2,zero
 90893fc:	9025d07a 	srai	r18,r18,1
 9089400:	800d883a 	mov	r6,r16
 9089404:	9809883a 	mov	r4,r19
 9089408:	a00b883a 	mov	r5,r20
 908940c:	103ff21e 	bne	r2,zero,90893d8 <__pow5mult+0x44>
 9089410:	90890700 	call	9089070 <__multiply>
 9089414:	a00b883a 	mov	r5,r20
 9089418:	9809883a 	mov	r4,r19
 908941c:	1023883a 	mov	r17,r2
 9089420:	90885e00 	call	90885e0 <_Bfree>
 9089424:	8829883a 	mov	r20,r17
 9089428:	800b883a 	mov	r5,r16
 908942c:	800d883a 	mov	r6,r16
 9089430:	9809883a 	mov	r4,r19
 9089434:	903fec1e 	bne	r18,zero,90893e8 <__pow5mult+0x54>
 9089438:	a005883a 	mov	r2,r20
 908943c:	dfc00517 	ldw	ra,20(sp)
 9089440:	dd000417 	ldw	r20,16(sp)
 9089444:	dcc00317 	ldw	r19,12(sp)
 9089448:	dc800217 	ldw	r18,8(sp)
 908944c:	dc400117 	ldw	r17,4(sp)
 9089450:	dc000017 	ldw	r16,0(sp)
 9089454:	dec00604 	addi	sp,sp,24
 9089458:	f800283a 	ret
 908945c:	90890700 	call	9089070 <__multiply>
 9089460:	80800015 	stw	r2,0(r16)
 9089464:	1021883a 	mov	r16,r2
 9089468:	10000015 	stw	zero,0(r2)
 908946c:	003fe106 	br	90893f4 <__pow5mult+0x60>
 9089470:	1085883a 	add	r2,r2,r2
 9089474:	00c24374 	movhi	r3,2317
 9089478:	18f2e304 	addi	r3,r3,-13428
 908947c:	1085883a 	add	r2,r2,r2
 9089480:	10c5883a 	add	r2,r2,r3
 9089484:	11bfff17 	ldw	r6,-4(r2)
 9089488:	000f883a 	mov	r7,zero
 908948c:	90892940 	call	9089294 <__multadd>
 9089490:	1029883a 	mov	r20,r2
 9089494:	003fcb06 	br	90893c4 <__pow5mult+0x30>
 9089498:	9809883a 	mov	r4,r19
 908949c:	01409c44 	movi	r5,625
 90894a0:	90892580 	call	9089258 <__i2b>
 90894a4:	98801215 	stw	r2,72(r19)
 90894a8:	1021883a 	mov	r16,r2
 90894ac:	10000015 	stw	zero,0(r2)
 90894b0:	003fd006 	br	90893f4 <__pow5mult+0x60>

090894b4 <__s2b>:
 90894b4:	defff904 	addi	sp,sp,-28
 90894b8:	dcc00315 	stw	r19,12(sp)
 90894bc:	dc800215 	stw	r18,8(sp)
 90894c0:	2827883a 	mov	r19,r5
 90894c4:	2025883a 	mov	r18,r4
 90894c8:	01400244 	movi	r5,9
 90894cc:	39000204 	addi	r4,r7,8
 90894d0:	dd000415 	stw	r20,16(sp)
 90894d4:	dc400115 	stw	r17,4(sp)
 90894d8:	dfc00615 	stw	ra,24(sp)
 90894dc:	dd400515 	stw	r21,20(sp)
 90894e0:	dc000015 	stw	r16,0(sp)
 90894e4:	3829883a 	mov	r20,r7
 90894e8:	3023883a 	mov	r17,r6
 90894ec:	908c2480 	call	908c248 <__divsi3>
 90894f0:	00c00044 	movi	r3,1
 90894f4:	1880350e 	bge	r3,r2,90895cc <__s2b+0x118>
 90894f8:	000b883a 	mov	r5,zero
 90894fc:	18c7883a 	add	r3,r3,r3
 9089500:	29400044 	addi	r5,r5,1
 9089504:	18bffd16 	blt	r3,r2,90894fc <__s2b+0x48>
 9089508:	9009883a 	mov	r4,r18
 908950c:	9088b600 	call	9088b60 <_Balloc>
 9089510:	1011883a 	mov	r8,r2
 9089514:	d8800717 	ldw	r2,28(sp)
 9089518:	00c00044 	movi	r3,1
 908951c:	01800244 	movi	r6,9
 9089520:	40800515 	stw	r2,20(r8)
 9089524:	40c00415 	stw	r3,16(r8)
 9089528:	3440260e 	bge	r6,r17,90895c4 <__s2b+0x110>
 908952c:	3021883a 	mov	r16,r6
 9089530:	99ab883a 	add	r21,r19,r6
 9089534:	9c05883a 	add	r2,r19,r16
 9089538:	11c00007 	ldb	r7,0(r2)
 908953c:	400b883a 	mov	r5,r8
 9089540:	9009883a 	mov	r4,r18
 9089544:	39fff404 	addi	r7,r7,-48
 9089548:	01800284 	movi	r6,10
 908954c:	90892940 	call	9089294 <__multadd>
 9089550:	84000044 	addi	r16,r16,1
 9089554:	1011883a 	mov	r8,r2
 9089558:	8c3ff61e 	bne	r17,r16,9089534 <__s2b+0x80>
 908955c:	ac45883a 	add	r2,r21,r17
 9089560:	117ffe04 	addi	r5,r2,-8
 9089564:	880d883a 	mov	r6,r17
 9089568:	35000c0e 	bge	r6,r20,908959c <__s2b+0xe8>
 908956c:	a185c83a 	sub	r2,r20,r6
 9089570:	2821883a 	mov	r16,r5
 9089574:	28a3883a 	add	r17,r5,r2
 9089578:	81c00007 	ldb	r7,0(r16)
 908957c:	400b883a 	mov	r5,r8
 9089580:	9009883a 	mov	r4,r18
 9089584:	39fff404 	addi	r7,r7,-48
 9089588:	01800284 	movi	r6,10
 908958c:	90892940 	call	9089294 <__multadd>
 9089590:	84000044 	addi	r16,r16,1
 9089594:	1011883a 	mov	r8,r2
 9089598:	847ff71e 	bne	r16,r17,9089578 <__s2b+0xc4>
 908959c:	4005883a 	mov	r2,r8
 90895a0:	dfc00617 	ldw	ra,24(sp)
 90895a4:	dd400517 	ldw	r21,20(sp)
 90895a8:	dd000417 	ldw	r20,16(sp)
 90895ac:	dcc00317 	ldw	r19,12(sp)
 90895b0:	dc800217 	ldw	r18,8(sp)
 90895b4:	dc400117 	ldw	r17,4(sp)
 90895b8:	dc000017 	ldw	r16,0(sp)
 90895bc:	dec00704 	addi	sp,sp,28
 90895c0:	f800283a 	ret
 90895c4:	99400284 	addi	r5,r19,10
 90895c8:	003fe706 	br	9089568 <__s2b+0xb4>
 90895cc:	000b883a 	mov	r5,zero
 90895d0:	003fcd06 	br	9089508 <__s2b+0x54>

090895d4 <_realloc_r>:
 90895d4:	defff404 	addi	sp,sp,-48
 90895d8:	dd800815 	stw	r22,32(sp)
 90895dc:	dc800415 	stw	r18,16(sp)
 90895e0:	dc400315 	stw	r17,12(sp)
 90895e4:	dfc00b15 	stw	ra,44(sp)
 90895e8:	df000a15 	stw	fp,40(sp)
 90895ec:	ddc00915 	stw	r23,36(sp)
 90895f0:	dd400715 	stw	r21,28(sp)
 90895f4:	dd000615 	stw	r20,24(sp)
 90895f8:	dcc00515 	stw	r19,20(sp)
 90895fc:	dc000215 	stw	r16,8(sp)
 9089600:	2825883a 	mov	r18,r5
 9089604:	3023883a 	mov	r17,r6
 9089608:	202d883a 	mov	r22,r4
 908960c:	2800c926 	beq	r5,zero,9089934 <_realloc_r+0x360>
 9089610:	908cedc0 	call	908cedc <__malloc_lock>
 9089614:	943ffe04 	addi	r16,r18,-8
 9089618:	88c002c4 	addi	r3,r17,11
 908961c:	00800584 	movi	r2,22
 9089620:	82000117 	ldw	r8,4(r16)
 9089624:	10c01b2e 	bgeu	r2,r3,9089694 <_realloc_r+0xc0>
 9089628:	00bffe04 	movi	r2,-8
 908962c:	188e703a 	and	r7,r3,r2
 9089630:	3839883a 	mov	fp,r7
 9089634:	38001a16 	blt	r7,zero,90896a0 <_realloc_r+0xcc>
 9089638:	e4401936 	bltu	fp,r17,90896a0 <_realloc_r+0xcc>
 908963c:	013fff04 	movi	r4,-4
 9089640:	4126703a 	and	r19,r8,r4
 9089644:	99c02616 	blt	r19,r7,90896e0 <_realloc_r+0x10c>
 9089648:	802b883a 	mov	r21,r16
 908964c:	9829883a 	mov	r20,r19
 9089650:	84000204 	addi	r16,r16,8
 9089654:	a80f883a 	mov	r7,r21
 9089658:	a70dc83a 	sub	r6,r20,fp
 908965c:	008003c4 	movi	r2,15
 9089660:	1180c136 	bltu	r2,r6,9089968 <_realloc_r+0x394>
 9089664:	38800117 	ldw	r2,4(r7)
 9089668:	a549883a 	add	r4,r20,r21
 908966c:	1080004c 	andi	r2,r2,1
 9089670:	a084b03a 	or	r2,r20,r2
 9089674:	38800115 	stw	r2,4(r7)
 9089678:	20c00117 	ldw	r3,4(r4)
 908967c:	18c00054 	ori	r3,r3,1
 9089680:	20c00115 	stw	r3,4(r4)
 9089684:	b009883a 	mov	r4,r22
 9089688:	908cfe40 	call	908cfe4 <__malloc_unlock>
 908968c:	8023883a 	mov	r17,r16
 9089690:	00000606 	br	90896ac <_realloc_r+0xd8>
 9089694:	01c00404 	movi	r7,16
 9089698:	3839883a 	mov	fp,r7
 908969c:	e47fe72e 	bgeu	fp,r17,908963c <_realloc_r+0x68>
 90896a0:	00800304 	movi	r2,12
 90896a4:	0023883a 	mov	r17,zero
 90896a8:	b0800015 	stw	r2,0(r22)
 90896ac:	8805883a 	mov	r2,r17
 90896b0:	dfc00b17 	ldw	ra,44(sp)
 90896b4:	df000a17 	ldw	fp,40(sp)
 90896b8:	ddc00917 	ldw	r23,36(sp)
 90896bc:	dd800817 	ldw	r22,32(sp)
 90896c0:	dd400717 	ldw	r21,28(sp)
 90896c4:	dd000617 	ldw	r20,24(sp)
 90896c8:	dcc00517 	ldw	r19,20(sp)
 90896cc:	dc800417 	ldw	r18,16(sp)
 90896d0:	dc400317 	ldw	r17,12(sp)
 90896d4:	dc000217 	ldw	r16,8(sp)
 90896d8:	dec00c04 	addi	sp,sp,48
 90896dc:	f800283a 	ret
 90896e0:	00824374 	movhi	r2,2317
 90896e4:	1084f404 	addi	r2,r2,5072
 90896e8:	12400217 	ldw	r9,8(r2)
 90896ec:	84cd883a 	add	r6,r16,r19
 90896f0:	802b883a 	mov	r21,r16
 90896f4:	3240b926 	beq	r6,r9,90899dc <_realloc_r+0x408>
 90896f8:	31400117 	ldw	r5,4(r6)
 90896fc:	00bfff84 	movi	r2,-2
 9089700:	2884703a 	and	r2,r5,r2
 9089704:	1185883a 	add	r2,r2,r6
 9089708:	10c00117 	ldw	r3,4(r2)
 908970c:	18c0004c 	andi	r3,r3,1
 9089710:	1807003a 	cmpeq	r3,r3,zero
 9089714:	1800a326 	beq	r3,zero,90899a4 <_realloc_r+0x3d0>
 9089718:	2908703a 	and	r4,r5,r4
 908971c:	9929883a 	add	r20,r19,r4
 9089720:	a1c0a30e 	bge	r20,r7,90899b0 <_realloc_r+0x3dc>
 9089724:	4080004c 	andi	r2,r8,1
 9089728:	1000551e 	bne	r2,zero,9089880 <_realloc_r+0x2ac>
 908972c:	80800017 	ldw	r2,0(r16)
 9089730:	80afc83a 	sub	r23,r16,r2
 9089734:	b8c00117 	ldw	r3,4(r23)
 9089738:	00bfff04 	movi	r2,-4
 908973c:	1884703a 	and	r2,r3,r2
 9089740:	30002e26 	beq	r6,zero,90897fc <_realloc_r+0x228>
 9089744:	3240b926 	beq	r6,r9,9089a2c <_realloc_r+0x458>
 9089748:	98a9883a 	add	r20,r19,r2
 908974c:	2509883a 	add	r4,r4,r20
 9089750:	d9000015 	stw	r4,0(sp)
 9089754:	21c02a16 	blt	r4,r7,9089800 <_realloc_r+0x22c>
 9089758:	30800317 	ldw	r2,12(r6)
 908975c:	30c00217 	ldw	r3,8(r6)
 9089760:	01400904 	movi	r5,36
 9089764:	99bfff04 	addi	r6,r19,-4
 9089768:	18800315 	stw	r2,12(r3)
 908976c:	10c00215 	stw	r3,8(r2)
 9089770:	b9000317 	ldw	r4,12(r23)
 9089774:	b8800217 	ldw	r2,8(r23)
 9089778:	b82b883a 	mov	r21,r23
 908977c:	bc000204 	addi	r16,r23,8
 9089780:	20800215 	stw	r2,8(r4)
 9089784:	11000315 	stw	r4,12(r2)
 9089788:	2980e436 	bltu	r5,r6,9089b1c <_realloc_r+0x548>
 908978c:	008004c4 	movi	r2,19
 9089790:	9009883a 	mov	r4,r18
 9089794:	8011883a 	mov	r8,r16
 9089798:	11800f2e 	bgeu	r2,r6,90897d8 <_realloc_r+0x204>
 908979c:	90800017 	ldw	r2,0(r18)
 90897a0:	ba000404 	addi	r8,r23,16
 90897a4:	91000204 	addi	r4,r18,8
 90897a8:	b8800215 	stw	r2,8(r23)
 90897ac:	90c00117 	ldw	r3,4(r18)
 90897b0:	008006c4 	movi	r2,27
 90897b4:	b8c00315 	stw	r3,12(r23)
 90897b8:	1180072e 	bgeu	r2,r6,90897d8 <_realloc_r+0x204>
 90897bc:	90c00217 	ldw	r3,8(r18)
 90897c0:	ba000604 	addi	r8,r23,24
 90897c4:	91000404 	addi	r4,r18,16
 90897c8:	b8c00415 	stw	r3,16(r23)
 90897cc:	90800317 	ldw	r2,12(r18)
 90897d0:	b8800515 	stw	r2,20(r23)
 90897d4:	3140e726 	beq	r6,r5,9089b74 <_realloc_r+0x5a0>
 90897d8:	20800017 	ldw	r2,0(r4)
 90897dc:	dd000017 	ldw	r20,0(sp)
 90897e0:	b80f883a 	mov	r7,r23
 90897e4:	40800015 	stw	r2,0(r8)
 90897e8:	20c00117 	ldw	r3,4(r4)
 90897ec:	40c00115 	stw	r3,4(r8)
 90897f0:	20800217 	ldw	r2,8(r4)
 90897f4:	40800215 	stw	r2,8(r8)
 90897f8:	003f9706 	br	9089658 <_realloc_r+0x84>
 90897fc:	98a9883a 	add	r20,r19,r2
 9089800:	a1c01f16 	blt	r20,r7,9089880 <_realloc_r+0x2ac>
 9089804:	b8c00317 	ldw	r3,12(r23)
 9089808:	b8800217 	ldw	r2,8(r23)
 908980c:	99bfff04 	addi	r6,r19,-4
 9089810:	01400904 	movi	r5,36
 9089814:	b82b883a 	mov	r21,r23
 9089818:	18800215 	stw	r2,8(r3)
 908981c:	10c00315 	stw	r3,12(r2)
 9089820:	bc000204 	addi	r16,r23,8
 9089824:	2980c336 	bltu	r5,r6,9089b34 <_realloc_r+0x560>
 9089828:	008004c4 	movi	r2,19
 908982c:	9009883a 	mov	r4,r18
 9089830:	8011883a 	mov	r8,r16
 9089834:	11800f2e 	bgeu	r2,r6,9089874 <_realloc_r+0x2a0>
 9089838:	90800017 	ldw	r2,0(r18)
 908983c:	ba000404 	addi	r8,r23,16
 9089840:	91000204 	addi	r4,r18,8
 9089844:	b8800215 	stw	r2,8(r23)
 9089848:	90c00117 	ldw	r3,4(r18)
 908984c:	008006c4 	movi	r2,27
 9089850:	b8c00315 	stw	r3,12(r23)
 9089854:	1180072e 	bgeu	r2,r6,9089874 <_realloc_r+0x2a0>
 9089858:	90c00217 	ldw	r3,8(r18)
 908985c:	ba000604 	addi	r8,r23,24
 9089860:	91000404 	addi	r4,r18,16
 9089864:	b8c00415 	stw	r3,16(r23)
 9089868:	90800317 	ldw	r2,12(r18)
 908986c:	b8800515 	stw	r2,20(r23)
 9089870:	3140c726 	beq	r6,r5,9089b90 <_realloc_r+0x5bc>
 9089874:	20800017 	ldw	r2,0(r4)
 9089878:	b80f883a 	mov	r7,r23
 908987c:	003fd906 	br	90897e4 <_realloc_r+0x210>
 9089880:	880b883a 	mov	r5,r17
 9089884:	b009883a 	mov	r4,r22
 9089888:	9087dbc0 	call	9087dbc <_malloc_r>
 908988c:	1023883a 	mov	r17,r2
 9089890:	10002526 	beq	r2,zero,9089928 <_realloc_r+0x354>
 9089894:	80800117 	ldw	r2,4(r16)
 9089898:	00ffff84 	movi	r3,-2
 908989c:	893ffe04 	addi	r4,r17,-8
 90898a0:	10c4703a 	and	r2,r2,r3
 90898a4:	8085883a 	add	r2,r16,r2
 90898a8:	20809526 	beq	r4,r2,9089b00 <_realloc_r+0x52c>
 90898ac:	99bfff04 	addi	r6,r19,-4
 90898b0:	01c00904 	movi	r7,36
 90898b4:	39804536 	bltu	r7,r6,90899cc <_realloc_r+0x3f8>
 90898b8:	008004c4 	movi	r2,19
 90898bc:	9009883a 	mov	r4,r18
 90898c0:	880b883a 	mov	r5,r17
 90898c4:	11800f2e 	bgeu	r2,r6,9089904 <_realloc_r+0x330>
 90898c8:	90800017 	ldw	r2,0(r18)
 90898cc:	89400204 	addi	r5,r17,8
 90898d0:	91000204 	addi	r4,r18,8
 90898d4:	88800015 	stw	r2,0(r17)
 90898d8:	90c00117 	ldw	r3,4(r18)
 90898dc:	008006c4 	movi	r2,27
 90898e0:	88c00115 	stw	r3,4(r17)
 90898e4:	1180072e 	bgeu	r2,r6,9089904 <_realloc_r+0x330>
 90898e8:	90c00217 	ldw	r3,8(r18)
 90898ec:	89400404 	addi	r5,r17,16
 90898f0:	91000404 	addi	r4,r18,16
 90898f4:	88c00215 	stw	r3,8(r17)
 90898f8:	90800317 	ldw	r2,12(r18)
 90898fc:	88800315 	stw	r2,12(r17)
 9089900:	31c09126 	beq	r6,r7,9089b48 <_realloc_r+0x574>
 9089904:	20800017 	ldw	r2,0(r4)
 9089908:	28800015 	stw	r2,0(r5)
 908990c:	20c00117 	ldw	r3,4(r4)
 9089910:	28c00115 	stw	r3,4(r5)
 9089914:	20800217 	ldw	r2,8(r4)
 9089918:	28800215 	stw	r2,8(r5)
 908991c:	900b883a 	mov	r5,r18
 9089920:	b009883a 	mov	r4,r22
 9089924:	90872340 	call	9087234 <_free_r>
 9089928:	b009883a 	mov	r4,r22
 908992c:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9089930:	003f5e06 	br	90896ac <_realloc_r+0xd8>
 9089934:	300b883a 	mov	r5,r6
 9089938:	dfc00b17 	ldw	ra,44(sp)
 908993c:	df000a17 	ldw	fp,40(sp)
 9089940:	ddc00917 	ldw	r23,36(sp)
 9089944:	dd800817 	ldw	r22,32(sp)
 9089948:	dd400717 	ldw	r21,28(sp)
 908994c:	dd000617 	ldw	r20,24(sp)
 9089950:	dcc00517 	ldw	r19,20(sp)
 9089954:	dc800417 	ldw	r18,16(sp)
 9089958:	dc400317 	ldw	r17,12(sp)
 908995c:	dc000217 	ldw	r16,8(sp)
 9089960:	dec00c04 	addi	sp,sp,48
 9089964:	9087dbc1 	jmpi	9087dbc <_malloc_r>
 9089968:	38800117 	ldw	r2,4(r7)
 908996c:	e54b883a 	add	r5,fp,r21
 9089970:	31000054 	ori	r4,r6,1
 9089974:	1080004c 	andi	r2,r2,1
 9089978:	1704b03a 	or	r2,r2,fp
 908997c:	38800115 	stw	r2,4(r7)
 9089980:	29000115 	stw	r4,4(r5)
 9089984:	2987883a 	add	r3,r5,r6
 9089988:	18800117 	ldw	r2,4(r3)
 908998c:	29400204 	addi	r5,r5,8
 9089990:	b009883a 	mov	r4,r22
 9089994:	10800054 	ori	r2,r2,1
 9089998:	18800115 	stw	r2,4(r3)
 908999c:	90872340 	call	9087234 <_free_r>
 90899a0:	003f3806 	br	9089684 <_realloc_r+0xb0>
 90899a4:	000d883a 	mov	r6,zero
 90899a8:	0009883a 	mov	r4,zero
 90899ac:	003f5d06 	br	9089724 <_realloc_r+0x150>
 90899b0:	30c00217 	ldw	r3,8(r6)
 90899b4:	30800317 	ldw	r2,12(r6)
 90899b8:	800f883a 	mov	r7,r16
 90899bc:	84000204 	addi	r16,r16,8
 90899c0:	10c00215 	stw	r3,8(r2)
 90899c4:	18800315 	stw	r2,12(r3)
 90899c8:	003f2306 	br	9089658 <_realloc_r+0x84>
 90899cc:	8809883a 	mov	r4,r17
 90899d0:	900b883a 	mov	r5,r18
 90899d4:	90823180 	call	9082318 <memmove>
 90899d8:	003fd006 	br	908991c <_realloc_r+0x348>
 90899dc:	30800117 	ldw	r2,4(r6)
 90899e0:	e0c00404 	addi	r3,fp,16
 90899e4:	1108703a 	and	r4,r2,r4
 90899e8:	9905883a 	add	r2,r19,r4
 90899ec:	10ff4d16 	blt	r2,r3,9089724 <_realloc_r+0x150>
 90899f0:	1705c83a 	sub	r2,r2,fp
 90899f4:	870b883a 	add	r5,r16,fp
 90899f8:	10800054 	ori	r2,r2,1
 90899fc:	28800115 	stw	r2,4(r5)
 9089a00:	80c00117 	ldw	r3,4(r16)
 9089a04:	00824374 	movhi	r2,2317
 9089a08:	1084f404 	addi	r2,r2,5072
 9089a0c:	b009883a 	mov	r4,r22
 9089a10:	18c0004c 	andi	r3,r3,1
 9089a14:	e0c6b03a 	or	r3,fp,r3
 9089a18:	11400215 	stw	r5,8(r2)
 9089a1c:	80c00115 	stw	r3,4(r16)
 9089a20:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9089a24:	84400204 	addi	r17,r16,8
 9089a28:	003f2006 	br	90896ac <_realloc_r+0xd8>
 9089a2c:	98a9883a 	add	r20,r19,r2
 9089a30:	2509883a 	add	r4,r4,r20
 9089a34:	e0800404 	addi	r2,fp,16
 9089a38:	d9000115 	stw	r4,4(sp)
 9089a3c:	20bf7016 	blt	r4,r2,9089800 <_realloc_r+0x22c>
 9089a40:	b8c00317 	ldw	r3,12(r23)
 9089a44:	b8800217 	ldw	r2,8(r23)
 9089a48:	99bfff04 	addi	r6,r19,-4
 9089a4c:	01400904 	movi	r5,36
 9089a50:	18800215 	stw	r2,8(r3)
 9089a54:	10c00315 	stw	r3,12(r2)
 9089a58:	bc400204 	addi	r17,r23,8
 9089a5c:	29804136 	bltu	r5,r6,9089b64 <_realloc_r+0x590>
 9089a60:	008004c4 	movi	r2,19
 9089a64:	9009883a 	mov	r4,r18
 9089a68:	880f883a 	mov	r7,r17
 9089a6c:	11800f2e 	bgeu	r2,r6,9089aac <_realloc_r+0x4d8>
 9089a70:	90800017 	ldw	r2,0(r18)
 9089a74:	b9c00404 	addi	r7,r23,16
 9089a78:	91000204 	addi	r4,r18,8
 9089a7c:	b8800215 	stw	r2,8(r23)
 9089a80:	90c00117 	ldw	r3,4(r18)
 9089a84:	008006c4 	movi	r2,27
 9089a88:	b8c00315 	stw	r3,12(r23)
 9089a8c:	1180072e 	bgeu	r2,r6,9089aac <_realloc_r+0x4d8>
 9089a90:	90c00217 	ldw	r3,8(r18)
 9089a94:	b9c00604 	addi	r7,r23,24
 9089a98:	91000404 	addi	r4,r18,16
 9089a9c:	b8c00415 	stw	r3,16(r23)
 9089aa0:	90800317 	ldw	r2,12(r18)
 9089aa4:	b8800515 	stw	r2,20(r23)
 9089aa8:	31404026 	beq	r6,r5,9089bac <_realloc_r+0x5d8>
 9089aac:	20800017 	ldw	r2,0(r4)
 9089ab0:	38800015 	stw	r2,0(r7)
 9089ab4:	20c00117 	ldw	r3,4(r4)
 9089ab8:	38c00115 	stw	r3,4(r7)
 9089abc:	20800217 	ldw	r2,8(r4)
 9089ac0:	38800215 	stw	r2,8(r7)
 9089ac4:	d8c00117 	ldw	r3,4(sp)
 9089ac8:	bf0b883a 	add	r5,r23,fp
 9089acc:	b009883a 	mov	r4,r22
 9089ad0:	1f05c83a 	sub	r2,r3,fp
 9089ad4:	10800054 	ori	r2,r2,1
 9089ad8:	28800115 	stw	r2,4(r5)
 9089adc:	b8c00117 	ldw	r3,4(r23)
 9089ae0:	00824374 	movhi	r2,2317
 9089ae4:	1084f404 	addi	r2,r2,5072
 9089ae8:	11400215 	stw	r5,8(r2)
 9089aec:	18c0004c 	andi	r3,r3,1
 9089af0:	e0c6b03a 	or	r3,fp,r3
 9089af4:	b8c00115 	stw	r3,4(r23)
 9089af8:	908cfe40 	call	908cfe4 <__malloc_unlock>
 9089afc:	003eeb06 	br	90896ac <_realloc_r+0xd8>
 9089b00:	20800117 	ldw	r2,4(r4)
 9089b04:	00ffff04 	movi	r3,-4
 9089b08:	800f883a 	mov	r7,r16
 9089b0c:	10c4703a 	and	r2,r2,r3
 9089b10:	98a9883a 	add	r20,r19,r2
 9089b14:	84000204 	addi	r16,r16,8
 9089b18:	003ecf06 	br	9089658 <_realloc_r+0x84>
 9089b1c:	900b883a 	mov	r5,r18
 9089b20:	8009883a 	mov	r4,r16
 9089b24:	90823180 	call	9082318 <memmove>
 9089b28:	dd000017 	ldw	r20,0(sp)
 9089b2c:	b80f883a 	mov	r7,r23
 9089b30:	003ec906 	br	9089658 <_realloc_r+0x84>
 9089b34:	900b883a 	mov	r5,r18
 9089b38:	8009883a 	mov	r4,r16
 9089b3c:	90823180 	call	9082318 <memmove>
 9089b40:	b80f883a 	mov	r7,r23
 9089b44:	003ec406 	br	9089658 <_realloc_r+0x84>
 9089b48:	90c00417 	ldw	r3,16(r18)
 9089b4c:	89400604 	addi	r5,r17,24
 9089b50:	91000604 	addi	r4,r18,24
 9089b54:	88c00415 	stw	r3,16(r17)
 9089b58:	90800517 	ldw	r2,20(r18)
 9089b5c:	88800515 	stw	r2,20(r17)
 9089b60:	003f6806 	br	9089904 <_realloc_r+0x330>
 9089b64:	900b883a 	mov	r5,r18
 9089b68:	8809883a 	mov	r4,r17
 9089b6c:	90823180 	call	9082318 <memmove>
 9089b70:	003fd406 	br	9089ac4 <_realloc_r+0x4f0>
 9089b74:	90c00417 	ldw	r3,16(r18)
 9089b78:	91000604 	addi	r4,r18,24
 9089b7c:	ba000804 	addi	r8,r23,32
 9089b80:	b8c00615 	stw	r3,24(r23)
 9089b84:	90800517 	ldw	r2,20(r18)
 9089b88:	b8800715 	stw	r2,28(r23)
 9089b8c:	003f1206 	br	90897d8 <_realloc_r+0x204>
 9089b90:	90c00417 	ldw	r3,16(r18)
 9089b94:	91000604 	addi	r4,r18,24
 9089b98:	ba000804 	addi	r8,r23,32
 9089b9c:	b8c00615 	stw	r3,24(r23)
 9089ba0:	90800517 	ldw	r2,20(r18)
 9089ba4:	b8800715 	stw	r2,28(r23)
 9089ba8:	003f3206 	br	9089874 <_realloc_r+0x2a0>
 9089bac:	90c00417 	ldw	r3,16(r18)
 9089bb0:	91000604 	addi	r4,r18,24
 9089bb4:	b9c00804 	addi	r7,r23,32
 9089bb8:	b8c00615 	stw	r3,24(r23)
 9089bbc:	90800517 	ldw	r2,20(r18)
 9089bc0:	b8800715 	stw	r2,28(r23)
 9089bc4:	003fb906 	br	9089aac <_realloc_r+0x4d8>

09089bc8 <__srefill_r>:
 9089bc8:	defffd04 	addi	sp,sp,-12
 9089bcc:	dc400115 	stw	r17,4(sp)
 9089bd0:	dc000015 	stw	r16,0(sp)
 9089bd4:	dfc00215 	stw	ra,8(sp)
 9089bd8:	2023883a 	mov	r17,r4
 9089bdc:	2821883a 	mov	r16,r5
 9089be0:	20000226 	beq	r4,zero,9089bec <__srefill_r+0x24>
 9089be4:	20800e17 	ldw	r2,56(r4)
 9089be8:	10004126 	beq	r2,zero,9089cf0 <__srefill_r+0x128>
 9089bec:	80c0030b 	ldhu	r3,12(r16)
 9089bf0:	80000115 	stw	zero,4(r16)
 9089bf4:	1880080c 	andi	r2,r3,32
 9089bf8:	1000361e 	bne	r2,zero,9089cd4 <__srefill_r+0x10c>
 9089bfc:	1880010c 	andi	r2,r3,4
 9089c00:	1000211e 	bne	r2,zero,9089c88 <__srefill_r+0xc0>
 9089c04:	1880040c 	andi	r2,r3,16
 9089c08:	10005026 	beq	r2,zero,9089d4c <__srefill_r+0x184>
 9089c0c:	1880020c 	andi	r2,r3,8
 9089c10:	1000541e 	bne	r2,zero,9089d64 <__srefill_r+0x19c>
 9089c14:	8080030b 	ldhu	r2,12(r16)
 9089c18:	10800114 	ori	r2,r2,4
 9089c1c:	8080030d 	sth	r2,12(r16)
 9089c20:	80800417 	ldw	r2,16(r16)
 9089c24:	10004526 	beq	r2,zero,9089d3c <__srefill_r+0x174>
 9089c28:	8080030b 	ldhu	r2,12(r16)
 9089c2c:	108000cc 	andi	r2,r2,3
 9089c30:	1000361e 	bne	r2,zero,9089d0c <__srefill_r+0x144>
 9089c34:	81800417 	ldw	r6,16(r16)
 9089c38:	80c00817 	ldw	r3,32(r16)
 9089c3c:	81400717 	ldw	r5,28(r16)
 9089c40:	81c00517 	ldw	r7,20(r16)
 9089c44:	8809883a 	mov	r4,r17
 9089c48:	81800015 	stw	r6,0(r16)
 9089c4c:	183ee83a 	callr	r3
 9089c50:	80c0030b 	ldhu	r3,12(r16)
 9089c54:	1009883a 	mov	r4,r2
 9089c58:	80800115 	stw	r2,4(r16)
 9089c5c:	00b7ffc4 	movi	r2,-8193
 9089c60:	1884703a 	and	r2,r3,r2
 9089c64:	8080030d 	sth	r2,12(r16)
 9089c68:	0100230e 	bge	zero,r4,9089cf8 <__srefill_r+0x130>
 9089c6c:	0009883a 	mov	r4,zero
 9089c70:	2005883a 	mov	r2,r4
 9089c74:	dfc00217 	ldw	ra,8(sp)
 9089c78:	dc400117 	ldw	r17,4(sp)
 9089c7c:	dc000017 	ldw	r16,0(sp)
 9089c80:	dec00304 	addi	sp,sp,12
 9089c84:	f800283a 	ret
 9089c88:	81400c17 	ldw	r5,48(r16)
 9089c8c:	283fe426 	beq	r5,zero,9089c20 <__srefill_r+0x58>
 9089c90:	80801004 	addi	r2,r16,64
 9089c94:	28800226 	beq	r5,r2,9089ca0 <__srefill_r+0xd8>
 9089c98:	8809883a 	mov	r4,r17
 9089c9c:	90872340 	call	9087234 <_free_r>
 9089ca0:	80800f17 	ldw	r2,60(r16)
 9089ca4:	80000c15 	stw	zero,48(r16)
 9089ca8:	80800115 	stw	r2,4(r16)
 9089cac:	103fdc26 	beq	r2,zero,9089c20 <__srefill_r+0x58>
 9089cb0:	80800e17 	ldw	r2,56(r16)
 9089cb4:	0009883a 	mov	r4,zero
 9089cb8:	80800015 	stw	r2,0(r16)
 9089cbc:	2005883a 	mov	r2,r4
 9089cc0:	dfc00217 	ldw	ra,8(sp)
 9089cc4:	dc400117 	ldw	r17,4(sp)
 9089cc8:	dc000017 	ldw	r16,0(sp)
 9089ccc:	dec00304 	addi	sp,sp,12
 9089cd0:	f800283a 	ret
 9089cd4:	013fffc4 	movi	r4,-1
 9089cd8:	2005883a 	mov	r2,r4
 9089cdc:	dfc00217 	ldw	ra,8(sp)
 9089ce0:	dc400117 	ldw	r17,4(sp)
 9089ce4:	dc000017 	ldw	r16,0(sp)
 9089ce8:	dec00304 	addi	sp,sp,12
 9089cec:	f800283a 	ret
 9089cf0:	9086d640 	call	9086d64 <__sinit>
 9089cf4:	003fbd06 	br	9089bec <__srefill_r+0x24>
 9089cf8:	20000b1e 	bne	r4,zero,9089d28 <__srefill_r+0x160>
 9089cfc:	10800814 	ori	r2,r2,32
 9089d00:	013fffc4 	movi	r4,-1
 9089d04:	8080030d 	sth	r2,12(r16)
 9089d08:	003fd906 	br	9089c70 <__srefill_r+0xa8>
 9089d0c:	00824374 	movhi	r2,2317
 9089d10:	108b9c04 	addi	r2,r2,11888
 9089d14:	11000017 	ldw	r4,0(r2)
 9089d18:	01424274 	movhi	r5,2313
 9089d1c:	29676304 	addi	r5,r5,-25204
 9089d20:	9087aac0 	call	9087aac <_fwalk>
 9089d24:	003fc306 	br	9089c34 <__srefill_r+0x6c>
 9089d28:	10801014 	ori	r2,r2,64
 9089d2c:	013fffc4 	movi	r4,-1
 9089d30:	8080030d 	sth	r2,12(r16)
 9089d34:	80000115 	stw	zero,4(r16)
 9089d38:	003fcd06 	br	9089c70 <__srefill_r+0xa8>
 9089d3c:	8809883a 	mov	r4,r17
 9089d40:	800b883a 	mov	r5,r16
 9089d44:	9087c280 	call	9087c28 <__smakebuf_r>
 9089d48:	003fb706 	br	9089c28 <__srefill_r+0x60>
 9089d4c:	18c01014 	ori	r3,r3,64
 9089d50:	00800244 	movi	r2,9
 9089d54:	013fffc4 	movi	r4,-1
 9089d58:	88800015 	stw	r2,0(r17)
 9089d5c:	80c0030d 	sth	r3,12(r16)
 9089d60:	003fc306 	br	9089c70 <__srefill_r+0xa8>
 9089d64:	8809883a 	mov	r4,r17
 9089d68:	800b883a 	mov	r5,r16
 9089d6c:	9086acc0 	call	9086acc <_fflush_r>
 9089d70:	103fd81e 	bne	r2,zero,9089cd4 <__srefill_r+0x10c>
 9089d74:	8080030b 	ldhu	r2,12(r16)
 9089d78:	80000215 	stw	zero,8(r16)
 9089d7c:	80000615 	stw	zero,24(r16)
 9089d80:	10bffdcc 	andi	r2,r2,65527
 9089d84:	8080030d 	sth	r2,12(r16)
 9089d88:	003fa206 	br	9089c14 <__srefill_r+0x4c>

09089d8c <lflush>:
 9089d8c:	20c0030b 	ldhu	r3,12(r4)
 9089d90:	01400244 	movi	r5,9
 9089d94:	0005883a 	mov	r2,zero
 9089d98:	18c0024c 	andi	r3,r3,9
 9089d9c:	19400126 	beq	r3,r5,9089da4 <lflush+0x18>
 9089da0:	f800283a 	ret
 9089da4:	9086cc81 	jmpi	9086cc8 <fflush>

09089da8 <__isinfd>:
 9089da8:	200d883a 	mov	r6,r4
 9089dac:	0109c83a 	sub	r4,zero,r4
 9089db0:	2188b03a 	or	r4,r4,r6
 9089db4:	2008d7fa 	srli	r4,r4,31
 9089db8:	00a00034 	movhi	r2,32768
 9089dbc:	10bfffc4 	addi	r2,r2,-1
 9089dc0:	1144703a 	and	r2,r2,r5
 9089dc4:	2088b03a 	or	r4,r4,r2
 9089dc8:	009ffc34 	movhi	r2,32752
 9089dcc:	1105c83a 	sub	r2,r2,r4
 9089dd0:	0087c83a 	sub	r3,zero,r2
 9089dd4:	10c4b03a 	or	r2,r2,r3
 9089dd8:	1004d7fa 	srli	r2,r2,31
 9089ddc:	00c00044 	movi	r3,1
 9089de0:	1885c83a 	sub	r2,r3,r2
 9089de4:	f800283a 	ret

09089de8 <__isnand>:
 9089de8:	200d883a 	mov	r6,r4
 9089dec:	0109c83a 	sub	r4,zero,r4
 9089df0:	2188b03a 	or	r4,r4,r6
 9089df4:	2008d7fa 	srli	r4,r4,31
 9089df8:	00a00034 	movhi	r2,32768
 9089dfc:	10bfffc4 	addi	r2,r2,-1
 9089e00:	1144703a 	and	r2,r2,r5
 9089e04:	2088b03a 	or	r4,r4,r2
 9089e08:	009ffc34 	movhi	r2,32752
 9089e0c:	1105c83a 	sub	r2,r2,r4
 9089e10:	1004d7fa 	srli	r2,r2,31
 9089e14:	f800283a 	ret

09089e18 <_sbrk_r>:
 9089e18:	defffd04 	addi	sp,sp,-12
 9089e1c:	dc000015 	stw	r16,0(sp)
 9089e20:	04024374 	movhi	r16,2317
 9089e24:	840bfd04 	addi	r16,r16,12276
 9089e28:	dc400115 	stw	r17,4(sp)
 9089e2c:	80000015 	stw	zero,0(r16)
 9089e30:	2023883a 	mov	r17,r4
 9089e34:	2809883a 	mov	r4,r5
 9089e38:	dfc00215 	stw	ra,8(sp)
 9089e3c:	908cd180 	call	908cd18 <sbrk>
 9089e40:	1007883a 	mov	r3,r2
 9089e44:	00bfffc4 	movi	r2,-1
 9089e48:	18800626 	beq	r3,r2,9089e64 <_sbrk_r+0x4c>
 9089e4c:	1805883a 	mov	r2,r3
 9089e50:	dfc00217 	ldw	ra,8(sp)
 9089e54:	dc400117 	ldw	r17,4(sp)
 9089e58:	dc000017 	ldw	r16,0(sp)
 9089e5c:	dec00304 	addi	sp,sp,12
 9089e60:	f800283a 	ret
 9089e64:	80800017 	ldw	r2,0(r16)
 9089e68:	103ff826 	beq	r2,zero,9089e4c <_sbrk_r+0x34>
 9089e6c:	88800015 	stw	r2,0(r17)
 9089e70:	1805883a 	mov	r2,r3
 9089e74:	dfc00217 	ldw	ra,8(sp)
 9089e78:	dc400117 	ldw	r17,4(sp)
 9089e7c:	dc000017 	ldw	r16,0(sp)
 9089e80:	dec00304 	addi	sp,sp,12
 9089e84:	f800283a 	ret

09089e88 <__sclose>:
 9089e88:	2940038f 	ldh	r5,14(r5)
 9089e8c:	908a1bc1 	jmpi	908a1bc <_close_r>

09089e90 <__sseek>:
 9089e90:	defffe04 	addi	sp,sp,-8
 9089e94:	dc000015 	stw	r16,0(sp)
 9089e98:	2821883a 	mov	r16,r5
 9089e9c:	2940038f 	ldh	r5,14(r5)
 9089ea0:	dfc00115 	stw	ra,4(sp)
 9089ea4:	908a4340 	call	908a434 <_lseek_r>
 9089ea8:	1007883a 	mov	r3,r2
 9089eac:	00bfffc4 	movi	r2,-1
 9089eb0:	18800926 	beq	r3,r2,9089ed8 <__sseek+0x48>
 9089eb4:	8080030b 	ldhu	r2,12(r16)
 9089eb8:	80c01415 	stw	r3,80(r16)
 9089ebc:	10840014 	ori	r2,r2,4096
 9089ec0:	8080030d 	sth	r2,12(r16)
 9089ec4:	1805883a 	mov	r2,r3
 9089ec8:	dfc00117 	ldw	ra,4(sp)
 9089ecc:	dc000017 	ldw	r16,0(sp)
 9089ed0:	dec00204 	addi	sp,sp,8
 9089ed4:	f800283a 	ret
 9089ed8:	8080030b 	ldhu	r2,12(r16)
 9089edc:	10bbffcc 	andi	r2,r2,61439
 9089ee0:	8080030d 	sth	r2,12(r16)
 9089ee4:	1805883a 	mov	r2,r3
 9089ee8:	dfc00117 	ldw	ra,4(sp)
 9089eec:	dc000017 	ldw	r16,0(sp)
 9089ef0:	dec00204 	addi	sp,sp,8
 9089ef4:	f800283a 	ret

09089ef8 <__swrite>:
 9089ef8:	2880030b 	ldhu	r2,12(r5)
 9089efc:	defffb04 	addi	sp,sp,-20
 9089f00:	dcc00315 	stw	r19,12(sp)
 9089f04:	1080400c 	andi	r2,r2,256
 9089f08:	dc800215 	stw	r18,8(sp)
 9089f0c:	dc400115 	stw	r17,4(sp)
 9089f10:	dc000015 	stw	r16,0(sp)
 9089f14:	3027883a 	mov	r19,r6
 9089f18:	3825883a 	mov	r18,r7
 9089f1c:	dfc00415 	stw	ra,16(sp)
 9089f20:	2821883a 	mov	r16,r5
 9089f24:	000d883a 	mov	r6,zero
 9089f28:	01c00084 	movi	r7,2
 9089f2c:	2023883a 	mov	r17,r4
 9089f30:	10000226 	beq	r2,zero,9089f3c <__swrite+0x44>
 9089f34:	2940038f 	ldh	r5,14(r5)
 9089f38:	908a4340 	call	908a434 <_lseek_r>
 9089f3c:	8080030b 	ldhu	r2,12(r16)
 9089f40:	8140038f 	ldh	r5,14(r16)
 9089f44:	8809883a 	mov	r4,r17
 9089f48:	10bbffcc 	andi	r2,r2,61439
 9089f4c:	980d883a 	mov	r6,r19
 9089f50:	900f883a 	mov	r7,r18
 9089f54:	8080030d 	sth	r2,12(r16)
 9089f58:	dfc00417 	ldw	ra,16(sp)
 9089f5c:	dcc00317 	ldw	r19,12(sp)
 9089f60:	dc800217 	ldw	r18,8(sp)
 9089f64:	dc400117 	ldw	r17,4(sp)
 9089f68:	dc000017 	ldw	r16,0(sp)
 9089f6c:	dec00504 	addi	sp,sp,20
 9089f70:	908a0901 	jmpi	908a090 <_write_r>

09089f74 <__sread>:
 9089f74:	defffe04 	addi	sp,sp,-8
 9089f78:	dc000015 	stw	r16,0(sp)
 9089f7c:	2821883a 	mov	r16,r5
 9089f80:	2940038f 	ldh	r5,14(r5)
 9089f84:	dfc00115 	stw	ra,4(sp)
 9089f88:	908a4ac0 	call	908a4ac <_read_r>
 9089f8c:	1007883a 	mov	r3,r2
 9089f90:	10000816 	blt	r2,zero,9089fb4 <__sread+0x40>
 9089f94:	80801417 	ldw	r2,80(r16)
 9089f98:	10c5883a 	add	r2,r2,r3
 9089f9c:	80801415 	stw	r2,80(r16)
 9089fa0:	1805883a 	mov	r2,r3
 9089fa4:	dfc00117 	ldw	ra,4(sp)
 9089fa8:	dc000017 	ldw	r16,0(sp)
 9089fac:	dec00204 	addi	sp,sp,8
 9089fb0:	f800283a 	ret
 9089fb4:	8080030b 	ldhu	r2,12(r16)
 9089fb8:	10bbffcc 	andi	r2,r2,61439
 9089fbc:	8080030d 	sth	r2,12(r16)
 9089fc0:	1805883a 	mov	r2,r3
 9089fc4:	dfc00117 	ldw	ra,4(sp)
 9089fc8:	dc000017 	ldw	r16,0(sp)
 9089fcc:	dec00204 	addi	sp,sp,8
 9089fd0:	f800283a 	ret

09089fd4 <strcmp>:
 9089fd4:	2144b03a 	or	r2,r4,r5
 9089fd8:	108000cc 	andi	r2,r2,3
 9089fdc:	10001d1e 	bne	r2,zero,908a054 <strcmp+0x80>
 9089fe0:	200f883a 	mov	r7,r4
 9089fe4:	28800017 	ldw	r2,0(r5)
 9089fe8:	21000017 	ldw	r4,0(r4)
 9089fec:	280d883a 	mov	r6,r5
 9089ff0:	2080161e 	bne	r4,r2,908a04c <strcmp+0x78>
 9089ff4:	023fbff4 	movhi	r8,65279
 9089ff8:	423fbfc4 	addi	r8,r8,-257
 9089ffc:	2207883a 	add	r3,r4,r8
 908a000:	01602074 	movhi	r5,32897
 908a004:	29602004 	addi	r5,r5,-32640
 908a008:	1946703a 	and	r3,r3,r5
 908a00c:	0104303a 	nor	r2,zero,r4
 908a010:	10c4703a 	and	r2,r2,r3
 908a014:	10001c1e 	bne	r2,zero,908a088 <strcmp+0xb4>
 908a018:	4013883a 	mov	r9,r8
 908a01c:	2811883a 	mov	r8,r5
 908a020:	00000106 	br	908a028 <strcmp+0x54>
 908a024:	1800181e 	bne	r3,zero,908a088 <strcmp+0xb4>
 908a028:	39c00104 	addi	r7,r7,4
 908a02c:	39000017 	ldw	r4,0(r7)
 908a030:	31800104 	addi	r6,r6,4
 908a034:	31400017 	ldw	r5,0(r6)
 908a038:	2245883a 	add	r2,r4,r9
 908a03c:	1204703a 	and	r2,r2,r8
 908a040:	0106303a 	nor	r3,zero,r4
 908a044:	1886703a 	and	r3,r3,r2
 908a048:	217ff626 	beq	r4,r5,908a024 <strcmp+0x50>
 908a04c:	3809883a 	mov	r4,r7
 908a050:	300b883a 	mov	r5,r6
 908a054:	20c00007 	ldb	r3,0(r4)
 908a058:	1800051e 	bne	r3,zero,908a070 <strcmp+0x9c>
 908a05c:	00000606 	br	908a078 <strcmp+0xa4>
 908a060:	21000044 	addi	r4,r4,1
 908a064:	20c00007 	ldb	r3,0(r4)
 908a068:	29400044 	addi	r5,r5,1
 908a06c:	18000226 	beq	r3,zero,908a078 <strcmp+0xa4>
 908a070:	28800007 	ldb	r2,0(r5)
 908a074:	18bffa26 	beq	r3,r2,908a060 <strcmp+0x8c>
 908a078:	20c00003 	ldbu	r3,0(r4)
 908a07c:	28800003 	ldbu	r2,0(r5)
 908a080:	1885c83a 	sub	r2,r3,r2
 908a084:	f800283a 	ret
 908a088:	0005883a 	mov	r2,zero
 908a08c:	f800283a 	ret

0908a090 <_write_r>:
 908a090:	defffd04 	addi	sp,sp,-12
 908a094:	dc000015 	stw	r16,0(sp)
 908a098:	04024374 	movhi	r16,2317
 908a09c:	840bfd04 	addi	r16,r16,12276
 908a0a0:	dc400115 	stw	r17,4(sp)
 908a0a4:	80000015 	stw	zero,0(r16)
 908a0a8:	2023883a 	mov	r17,r4
 908a0ac:	2809883a 	mov	r4,r5
 908a0b0:	300b883a 	mov	r5,r6
 908a0b4:	380d883a 	mov	r6,r7
 908a0b8:	dfc00215 	stw	ra,8(sp)
 908a0bc:	90a0dac0 	call	90a0dac <write>
 908a0c0:	1007883a 	mov	r3,r2
 908a0c4:	00bfffc4 	movi	r2,-1
 908a0c8:	18800626 	beq	r3,r2,908a0e4 <_write_r+0x54>
 908a0cc:	1805883a 	mov	r2,r3
 908a0d0:	dfc00217 	ldw	ra,8(sp)
 908a0d4:	dc400117 	ldw	r17,4(sp)
 908a0d8:	dc000017 	ldw	r16,0(sp)
 908a0dc:	dec00304 	addi	sp,sp,12
 908a0e0:	f800283a 	ret
 908a0e4:	80800017 	ldw	r2,0(r16)
 908a0e8:	103ff826 	beq	r2,zero,908a0cc <_write_r+0x3c>
 908a0ec:	88800015 	stw	r2,0(r17)
 908a0f0:	1805883a 	mov	r2,r3
 908a0f4:	dfc00217 	ldw	ra,8(sp)
 908a0f8:	dc400117 	ldw	r17,4(sp)
 908a0fc:	dc000017 	ldw	r16,0(sp)
 908a100:	dec00304 	addi	sp,sp,12
 908a104:	f800283a 	ret

0908a108 <_calloc_r>:
 908a108:	298b383a 	mul	r5,r5,r6
 908a10c:	defffe04 	addi	sp,sp,-8
 908a110:	dc000015 	stw	r16,0(sp)
 908a114:	dfc00115 	stw	ra,4(sp)
 908a118:	9087dbc0 	call	9087dbc <_malloc_r>
 908a11c:	1021883a 	mov	r16,r2
 908a120:	01c00904 	movi	r7,36
 908a124:	10000d26 	beq	r2,zero,908a15c <_calloc_r+0x54>
 908a128:	10ffff17 	ldw	r3,-4(r2)
 908a12c:	1009883a 	mov	r4,r2
 908a130:	00bfff04 	movi	r2,-4
 908a134:	1886703a 	and	r3,r3,r2
 908a138:	1887883a 	add	r3,r3,r2
 908a13c:	180d883a 	mov	r6,r3
 908a140:	000b883a 	mov	r5,zero
 908a144:	38c01736 	bltu	r7,r3,908a1a4 <_calloc_r+0x9c>
 908a148:	008004c4 	movi	r2,19
 908a14c:	10c00836 	bltu	r2,r3,908a170 <_calloc_r+0x68>
 908a150:	20000215 	stw	zero,8(r4)
 908a154:	20000015 	stw	zero,0(r4)
 908a158:	20000115 	stw	zero,4(r4)
 908a15c:	8005883a 	mov	r2,r16
 908a160:	dfc00117 	ldw	ra,4(sp)
 908a164:	dc000017 	ldw	r16,0(sp)
 908a168:	dec00204 	addi	sp,sp,8
 908a16c:	f800283a 	ret
 908a170:	008006c4 	movi	r2,27
 908a174:	80000015 	stw	zero,0(r16)
 908a178:	80000115 	stw	zero,4(r16)
 908a17c:	81000204 	addi	r4,r16,8
 908a180:	10fff32e 	bgeu	r2,r3,908a150 <_calloc_r+0x48>
 908a184:	80000215 	stw	zero,8(r16)
 908a188:	80000315 	stw	zero,12(r16)
 908a18c:	81000404 	addi	r4,r16,16
 908a190:	19ffef1e 	bne	r3,r7,908a150 <_calloc_r+0x48>
 908a194:	81000604 	addi	r4,r16,24
 908a198:	80000415 	stw	zero,16(r16)
 908a19c:	80000515 	stw	zero,20(r16)
 908a1a0:	003feb06 	br	908a150 <_calloc_r+0x48>
 908a1a4:	90823f80 	call	90823f8 <memset>
 908a1a8:	8005883a 	mov	r2,r16
 908a1ac:	dfc00117 	ldw	ra,4(sp)
 908a1b0:	dc000017 	ldw	r16,0(sp)
 908a1b4:	dec00204 	addi	sp,sp,8
 908a1b8:	f800283a 	ret

0908a1bc <_close_r>:
 908a1bc:	defffd04 	addi	sp,sp,-12
 908a1c0:	dc000015 	stw	r16,0(sp)
 908a1c4:	04024374 	movhi	r16,2317
 908a1c8:	840bfd04 	addi	r16,r16,12276
 908a1cc:	dc400115 	stw	r17,4(sp)
 908a1d0:	80000015 	stw	zero,0(r16)
 908a1d4:	2023883a 	mov	r17,r4
 908a1d8:	2809883a 	mov	r4,r5
 908a1dc:	dfc00215 	stw	ra,8(sp)
 908a1e0:	90a0b9c0 	call	90a0b9c <close>
 908a1e4:	1007883a 	mov	r3,r2
 908a1e8:	00bfffc4 	movi	r2,-1
 908a1ec:	18800626 	beq	r3,r2,908a208 <_close_r+0x4c>
 908a1f0:	1805883a 	mov	r2,r3
 908a1f4:	dfc00217 	ldw	ra,8(sp)
 908a1f8:	dc400117 	ldw	r17,4(sp)
 908a1fc:	dc000017 	ldw	r16,0(sp)
 908a200:	dec00304 	addi	sp,sp,12
 908a204:	f800283a 	ret
 908a208:	80800017 	ldw	r2,0(r16)
 908a20c:	103ff826 	beq	r2,zero,908a1f0 <_close_r+0x34>
 908a210:	88800015 	stw	r2,0(r17)
 908a214:	1805883a 	mov	r2,r3
 908a218:	dfc00217 	ldw	ra,8(sp)
 908a21c:	dc400117 	ldw	r17,4(sp)
 908a220:	dc000017 	ldw	r16,0(sp)
 908a224:	dec00304 	addi	sp,sp,12
 908a228:	f800283a 	ret

0908a22c <_fclose_r>:
 908a22c:	defffc04 	addi	sp,sp,-16
 908a230:	dc400115 	stw	r17,4(sp)
 908a234:	dc000015 	stw	r16,0(sp)
 908a238:	dfc00315 	stw	ra,12(sp)
 908a23c:	dc800215 	stw	r18,8(sp)
 908a240:	2821883a 	mov	r16,r5
 908a244:	2023883a 	mov	r17,r4
 908a248:	28002926 	beq	r5,zero,908a2f0 <_fclose_r+0xc4>
 908a24c:	9086d540 	call	9086d54 <__sfp_lock_acquire>
 908a250:	88000226 	beq	r17,zero,908a25c <_fclose_r+0x30>
 908a254:	88800e17 	ldw	r2,56(r17)
 908a258:	10002d26 	beq	r2,zero,908a310 <_fclose_r+0xe4>
 908a25c:	8080030f 	ldh	r2,12(r16)
 908a260:	10002226 	beq	r2,zero,908a2ec <_fclose_r+0xc0>
 908a264:	8809883a 	mov	r4,r17
 908a268:	800b883a 	mov	r5,r16
 908a26c:	9086acc0 	call	9086acc <_fflush_r>
 908a270:	1025883a 	mov	r18,r2
 908a274:	80800b17 	ldw	r2,44(r16)
 908a278:	10000426 	beq	r2,zero,908a28c <_fclose_r+0x60>
 908a27c:	81400717 	ldw	r5,28(r16)
 908a280:	8809883a 	mov	r4,r17
 908a284:	103ee83a 	callr	r2
 908a288:	10002a16 	blt	r2,zero,908a334 <_fclose_r+0x108>
 908a28c:	8080030b 	ldhu	r2,12(r16)
 908a290:	1080200c 	andi	r2,r2,128
 908a294:	1000231e 	bne	r2,zero,908a324 <_fclose_r+0xf8>
 908a298:	81400c17 	ldw	r5,48(r16)
 908a29c:	28000526 	beq	r5,zero,908a2b4 <_fclose_r+0x88>
 908a2a0:	80801004 	addi	r2,r16,64
 908a2a4:	28800226 	beq	r5,r2,908a2b0 <_fclose_r+0x84>
 908a2a8:	8809883a 	mov	r4,r17
 908a2ac:	90872340 	call	9087234 <_free_r>
 908a2b0:	80000c15 	stw	zero,48(r16)
 908a2b4:	81401117 	ldw	r5,68(r16)
 908a2b8:	28000326 	beq	r5,zero,908a2c8 <_fclose_r+0x9c>
 908a2bc:	8809883a 	mov	r4,r17
 908a2c0:	90872340 	call	9087234 <_free_r>
 908a2c4:	80001115 	stw	zero,68(r16)
 908a2c8:	8000030d 	sth	zero,12(r16)
 908a2cc:	9086d580 	call	9086d58 <__sfp_lock_release>
 908a2d0:	9005883a 	mov	r2,r18
 908a2d4:	dfc00317 	ldw	ra,12(sp)
 908a2d8:	dc800217 	ldw	r18,8(sp)
 908a2dc:	dc400117 	ldw	r17,4(sp)
 908a2e0:	dc000017 	ldw	r16,0(sp)
 908a2e4:	dec00404 	addi	sp,sp,16
 908a2e8:	f800283a 	ret
 908a2ec:	9086d580 	call	9086d58 <__sfp_lock_release>
 908a2f0:	0025883a 	mov	r18,zero
 908a2f4:	9005883a 	mov	r2,r18
 908a2f8:	dfc00317 	ldw	ra,12(sp)
 908a2fc:	dc800217 	ldw	r18,8(sp)
 908a300:	dc400117 	ldw	r17,4(sp)
 908a304:	dc000017 	ldw	r16,0(sp)
 908a308:	dec00404 	addi	sp,sp,16
 908a30c:	f800283a 	ret
 908a310:	8809883a 	mov	r4,r17
 908a314:	9086d640 	call	9086d64 <__sinit>
 908a318:	8080030f 	ldh	r2,12(r16)
 908a31c:	103fd11e 	bne	r2,zero,908a264 <_fclose_r+0x38>
 908a320:	003ff206 	br	908a2ec <_fclose_r+0xc0>
 908a324:	81400417 	ldw	r5,16(r16)
 908a328:	8809883a 	mov	r4,r17
 908a32c:	90872340 	call	9087234 <_free_r>
 908a330:	003fd906 	br	908a298 <_fclose_r+0x6c>
 908a334:	04bfffc4 	movi	r18,-1
 908a338:	003fd406 	br	908a28c <_fclose_r+0x60>

0908a33c <fclose>:
 908a33c:	00824374 	movhi	r2,2317
 908a340:	108b9b04 	addi	r2,r2,11884
 908a344:	200b883a 	mov	r5,r4
 908a348:	11000017 	ldw	r4,0(r2)
 908a34c:	908a22c1 	jmpi	908a22c <_fclose_r>

0908a350 <_fstat_r>:
 908a350:	defffd04 	addi	sp,sp,-12
 908a354:	dc000015 	stw	r16,0(sp)
 908a358:	04024374 	movhi	r16,2317
 908a35c:	840bfd04 	addi	r16,r16,12276
 908a360:	dc400115 	stw	r17,4(sp)
 908a364:	80000015 	stw	zero,0(r16)
 908a368:	2023883a 	mov	r17,r4
 908a36c:	2809883a 	mov	r4,r5
 908a370:	300b883a 	mov	r5,r6
 908a374:	dfc00215 	stw	ra,8(sp)
 908a378:	908c8ac0 	call	908c8ac <fstat>
 908a37c:	1007883a 	mov	r3,r2
 908a380:	00bfffc4 	movi	r2,-1
 908a384:	18800626 	beq	r3,r2,908a3a0 <_fstat_r+0x50>
 908a388:	1805883a 	mov	r2,r3
 908a38c:	dfc00217 	ldw	ra,8(sp)
 908a390:	dc400117 	ldw	r17,4(sp)
 908a394:	dc000017 	ldw	r16,0(sp)
 908a398:	dec00304 	addi	sp,sp,12
 908a39c:	f800283a 	ret
 908a3a0:	80800017 	ldw	r2,0(r16)
 908a3a4:	103ff826 	beq	r2,zero,908a388 <_fstat_r+0x38>
 908a3a8:	88800015 	stw	r2,0(r17)
 908a3ac:	1805883a 	mov	r2,r3
 908a3b0:	dfc00217 	ldw	ra,8(sp)
 908a3b4:	dc400117 	ldw	r17,4(sp)
 908a3b8:	dc000017 	ldw	r16,0(sp)
 908a3bc:	dec00304 	addi	sp,sp,12
 908a3c0:	f800283a 	ret

0908a3c4 <_isatty_r>:
 908a3c4:	defffd04 	addi	sp,sp,-12
 908a3c8:	dc000015 	stw	r16,0(sp)
 908a3cc:	04024374 	movhi	r16,2317
 908a3d0:	840bfd04 	addi	r16,r16,12276
 908a3d4:	dc400115 	stw	r17,4(sp)
 908a3d8:	80000015 	stw	zero,0(r16)
 908a3dc:	2023883a 	mov	r17,r4
 908a3e0:	2809883a 	mov	r4,r5
 908a3e4:	dfc00215 	stw	ra,8(sp)
 908a3e8:	908c9e00 	call	908c9e0 <isatty>
 908a3ec:	1007883a 	mov	r3,r2
 908a3f0:	00bfffc4 	movi	r2,-1
 908a3f4:	18800626 	beq	r3,r2,908a410 <_isatty_r+0x4c>
 908a3f8:	1805883a 	mov	r2,r3
 908a3fc:	dfc00217 	ldw	ra,8(sp)
 908a400:	dc400117 	ldw	r17,4(sp)
 908a404:	dc000017 	ldw	r16,0(sp)
 908a408:	dec00304 	addi	sp,sp,12
 908a40c:	f800283a 	ret
 908a410:	80800017 	ldw	r2,0(r16)
 908a414:	103ff826 	beq	r2,zero,908a3f8 <_isatty_r+0x34>
 908a418:	88800015 	stw	r2,0(r17)
 908a41c:	1805883a 	mov	r2,r3
 908a420:	dfc00217 	ldw	ra,8(sp)
 908a424:	dc400117 	ldw	r17,4(sp)
 908a428:	dc000017 	ldw	r16,0(sp)
 908a42c:	dec00304 	addi	sp,sp,12
 908a430:	f800283a 	ret

0908a434 <_lseek_r>:
 908a434:	defffd04 	addi	sp,sp,-12
 908a438:	dc000015 	stw	r16,0(sp)
 908a43c:	04024374 	movhi	r16,2317
 908a440:	840bfd04 	addi	r16,r16,12276
 908a444:	dc400115 	stw	r17,4(sp)
 908a448:	80000015 	stw	zero,0(r16)
 908a44c:	2023883a 	mov	r17,r4
 908a450:	2809883a 	mov	r4,r5
 908a454:	300b883a 	mov	r5,r6
 908a458:	380d883a 	mov	r6,r7
 908a45c:	dfc00215 	stw	ra,8(sp)
 908a460:	908cb000 	call	908cb00 <lseek>
 908a464:	1007883a 	mov	r3,r2
 908a468:	00bfffc4 	movi	r2,-1
 908a46c:	18800626 	beq	r3,r2,908a488 <_lseek_r+0x54>
 908a470:	1805883a 	mov	r2,r3
 908a474:	dfc00217 	ldw	ra,8(sp)
 908a478:	dc400117 	ldw	r17,4(sp)
 908a47c:	dc000017 	ldw	r16,0(sp)
 908a480:	dec00304 	addi	sp,sp,12
 908a484:	f800283a 	ret
 908a488:	80800017 	ldw	r2,0(r16)
 908a48c:	103ff826 	beq	r2,zero,908a470 <_lseek_r+0x3c>
 908a490:	88800015 	stw	r2,0(r17)
 908a494:	1805883a 	mov	r2,r3
 908a498:	dfc00217 	ldw	ra,8(sp)
 908a49c:	dc400117 	ldw	r17,4(sp)
 908a4a0:	dc000017 	ldw	r16,0(sp)
 908a4a4:	dec00304 	addi	sp,sp,12
 908a4a8:	f800283a 	ret

0908a4ac <_read_r>:
 908a4ac:	defffd04 	addi	sp,sp,-12
 908a4b0:	dc000015 	stw	r16,0(sp)
 908a4b4:	04024374 	movhi	r16,2317
 908a4b8:	840bfd04 	addi	r16,r16,12276
 908a4bc:	dc400115 	stw	r17,4(sp)
 908a4c0:	80000015 	stw	zero,0(r16)
 908a4c4:	2023883a 	mov	r17,r4
 908a4c8:	2809883a 	mov	r4,r5
 908a4cc:	300b883a 	mov	r5,r6
 908a4d0:	380d883a 	mov	r6,r7
 908a4d4:	dfc00215 	stw	ra,8(sp)
 908a4d8:	90a0d340 	call	90a0d34 <read>
 908a4dc:	1007883a 	mov	r3,r2
 908a4e0:	00bfffc4 	movi	r2,-1
 908a4e4:	18800626 	beq	r3,r2,908a500 <_read_r+0x54>
 908a4e8:	1805883a 	mov	r2,r3
 908a4ec:	dfc00217 	ldw	ra,8(sp)
 908a4f0:	dc400117 	ldw	r17,4(sp)
 908a4f4:	dc000017 	ldw	r16,0(sp)
 908a4f8:	dec00304 	addi	sp,sp,12
 908a4fc:	f800283a 	ret
 908a500:	80800017 	ldw	r2,0(r16)
 908a504:	103ff826 	beq	r2,zero,908a4e8 <_read_r+0x3c>
 908a508:	88800015 	stw	r2,0(r17)
 908a50c:	1805883a 	mov	r2,r3
 908a510:	dfc00217 	ldw	ra,8(sp)
 908a514:	dc400117 	ldw	r17,4(sp)
 908a518:	dc000017 	ldw	r16,0(sp)
 908a51c:	dec00304 	addi	sp,sp,12
 908a520:	f800283a 	ret

0908a524 <__udivdi3>:
 908a524:	defff004 	addi	sp,sp,-64
 908a528:	2005883a 	mov	r2,r4
 908a52c:	3011883a 	mov	r8,r6
 908a530:	df000e15 	stw	fp,56(sp)
 908a534:	dd000a15 	stw	r20,40(sp)
 908a538:	dc000615 	stw	r16,24(sp)
 908a53c:	dfc00f15 	stw	ra,60(sp)
 908a540:	ddc00d15 	stw	r23,52(sp)
 908a544:	dd800c15 	stw	r22,48(sp)
 908a548:	dd400b15 	stw	r21,44(sp)
 908a54c:	dcc00915 	stw	r19,36(sp)
 908a550:	dc800815 	stw	r18,32(sp)
 908a554:	dc400715 	stw	r17,28(sp)
 908a558:	4021883a 	mov	r16,r8
 908a55c:	1039883a 	mov	fp,r2
 908a560:	2829883a 	mov	r20,r5
 908a564:	38003b1e 	bne	r7,zero,908a654 <__udivdi3+0x130>
 908a568:	2a005c36 	bltu	r5,r8,908a6dc <__udivdi3+0x1b8>
 908a56c:	4000a626 	beq	r8,zero,908a808 <__udivdi3+0x2e4>
 908a570:	00bfffd4 	movui	r2,65535
 908a574:	14009e36 	bltu	r2,r16,908a7f0 <__udivdi3+0x2cc>
 908a578:	00803fc4 	movi	r2,255
 908a57c:	14013d36 	bltu	r2,r16,908aa74 <__udivdi3+0x550>
 908a580:	000b883a 	mov	r5,zero
 908a584:	0005883a 	mov	r2,zero
 908a588:	8084d83a 	srl	r2,r16,r2
 908a58c:	01024374 	movhi	r4,2317
 908a590:	2132eb04 	addi	r4,r4,-13396
 908a594:	01800804 	movi	r6,32
 908a598:	1105883a 	add	r2,r2,r4
 908a59c:	10c00003 	ldbu	r3,0(r2)
 908a5a0:	28c7883a 	add	r3,r5,r3
 908a5a4:	30edc83a 	sub	r22,r6,r3
 908a5a8:	b000ee1e 	bne	r22,zero,908a964 <__udivdi3+0x440>
 908a5ac:	802ad43a 	srli	r21,r16,16
 908a5b0:	00800044 	movi	r2,1
 908a5b4:	a423c83a 	sub	r17,r20,r16
 908a5b8:	85ffffcc 	andi	r23,r16,65535
 908a5bc:	d8800315 	stw	r2,12(sp)
 908a5c0:	8809883a 	mov	r4,r17
 908a5c4:	a80b883a 	mov	r5,r21
 908a5c8:	908c3080 	call	908c308 <__udivsi3>
 908a5cc:	8809883a 	mov	r4,r17
 908a5d0:	a80b883a 	mov	r5,r21
 908a5d4:	102d883a 	mov	r22,r2
 908a5d8:	908c3100 	call	908c310 <__umodsi3>
 908a5dc:	1004943a 	slli	r2,r2,16
 908a5e0:	e006d43a 	srli	r3,fp,16
 908a5e4:	bda3383a 	mul	r17,r23,r22
 908a5e8:	10c4b03a 	or	r2,r2,r3
 908a5ec:	1440042e 	bgeu	r2,r17,908a600 <__udivdi3+0xdc>
 908a5f0:	1405883a 	add	r2,r2,r16
 908a5f4:	b5bfffc4 	addi	r22,r22,-1
 908a5f8:	14000136 	bltu	r2,r16,908a600 <__udivdi3+0xdc>
 908a5fc:	14413d36 	bltu	r2,r17,908aaf4 <__udivdi3+0x5d0>
 908a600:	1463c83a 	sub	r17,r2,r17
 908a604:	8809883a 	mov	r4,r17
 908a608:	a80b883a 	mov	r5,r21
 908a60c:	908c3080 	call	908c308 <__udivsi3>
 908a610:	8809883a 	mov	r4,r17
 908a614:	a80b883a 	mov	r5,r21
 908a618:	1029883a 	mov	r20,r2
 908a61c:	908c3100 	call	908c310 <__umodsi3>
 908a620:	1004943a 	slli	r2,r2,16
 908a624:	bd09383a 	mul	r4,r23,r20
 908a628:	e0ffffcc 	andi	r3,fp,65535
 908a62c:	10c4b03a 	or	r2,r2,r3
 908a630:	1100042e 	bgeu	r2,r4,908a644 <__udivdi3+0x120>
 908a634:	8085883a 	add	r2,r16,r2
 908a638:	a53fffc4 	addi	r20,r20,-1
 908a63c:	14000136 	bltu	r2,r16,908a644 <__udivdi3+0x120>
 908a640:	11012036 	bltu	r2,r4,908aac4 <__udivdi3+0x5a0>
 908a644:	b004943a 	slli	r2,r22,16
 908a648:	d9000317 	ldw	r4,12(sp)
 908a64c:	a084b03a 	or	r2,r20,r2
 908a650:	00001506 	br	908a6a8 <__udivdi3+0x184>
 908a654:	380d883a 	mov	r6,r7
 908a658:	29c06236 	bltu	r5,r7,908a7e4 <__udivdi3+0x2c0>
 908a65c:	00bfffd4 	movui	r2,65535
 908a660:	11c05a36 	bltu	r2,r7,908a7cc <__udivdi3+0x2a8>
 908a664:	00803fc4 	movi	r2,255
 908a668:	11c0fc36 	bltu	r2,r7,908aa5c <__udivdi3+0x538>
 908a66c:	000b883a 	mov	r5,zero
 908a670:	0005883a 	mov	r2,zero
 908a674:	3084d83a 	srl	r2,r6,r2
 908a678:	01024374 	movhi	r4,2317
 908a67c:	2132eb04 	addi	r4,r4,-13396
 908a680:	01c00804 	movi	r7,32
 908a684:	1105883a 	add	r2,r2,r4
 908a688:	10c00003 	ldbu	r3,0(r2)
 908a68c:	28c7883a 	add	r3,r5,r3
 908a690:	38efc83a 	sub	r23,r7,r3
 908a694:	b800691e 	bne	r23,zero,908a83c <__udivdi3+0x318>
 908a698:	35000136 	bltu	r6,r20,908a6a0 <__udivdi3+0x17c>
 908a69c:	e4005136 	bltu	fp,r16,908a7e4 <__udivdi3+0x2c0>
 908a6a0:	00800044 	movi	r2,1
 908a6a4:	0009883a 	mov	r4,zero
 908a6a8:	2007883a 	mov	r3,r4
 908a6ac:	dfc00f17 	ldw	ra,60(sp)
 908a6b0:	df000e17 	ldw	fp,56(sp)
 908a6b4:	ddc00d17 	ldw	r23,52(sp)
 908a6b8:	dd800c17 	ldw	r22,48(sp)
 908a6bc:	dd400b17 	ldw	r21,44(sp)
 908a6c0:	dd000a17 	ldw	r20,40(sp)
 908a6c4:	dcc00917 	ldw	r19,36(sp)
 908a6c8:	dc800817 	ldw	r18,32(sp)
 908a6cc:	dc400717 	ldw	r17,28(sp)
 908a6d0:	dc000617 	ldw	r16,24(sp)
 908a6d4:	dec01004 	addi	sp,sp,64
 908a6d8:	f800283a 	ret
 908a6dc:	00bfffd4 	movui	r2,65535
 908a6e0:	12005036 	bltu	r2,r8,908a824 <__udivdi3+0x300>
 908a6e4:	00803fc4 	movi	r2,255
 908a6e8:	1200e836 	bltu	r2,r8,908aa8c <__udivdi3+0x568>
 908a6ec:	000b883a 	mov	r5,zero
 908a6f0:	0005883a 	mov	r2,zero
 908a6f4:	8084d83a 	srl	r2,r16,r2
 908a6f8:	01024374 	movhi	r4,2317
 908a6fc:	2132eb04 	addi	r4,r4,-13396
 908a700:	01800804 	movi	r6,32
 908a704:	1105883a 	add	r2,r2,r4
 908a708:	10c00003 	ldbu	r3,0(r2)
 908a70c:	28c7883a 	add	r3,r5,r3
 908a710:	30cbc83a 	sub	r5,r6,r3
 908a714:	28000626 	beq	r5,zero,908a730 <__udivdi3+0x20c>
 908a718:	3145c83a 	sub	r2,r6,r5
 908a71c:	e084d83a 	srl	r2,fp,r2
 908a720:	a146983a 	sll	r3,r20,r5
 908a724:	e178983a 	sll	fp,fp,r5
 908a728:	8160983a 	sll	r16,r16,r5
 908a72c:	18a8b03a 	or	r20,r3,r2
 908a730:	802ad43a 	srli	r21,r16,16
 908a734:	a009883a 	mov	r4,r20
 908a738:	85ffffcc 	andi	r23,r16,65535
 908a73c:	a80b883a 	mov	r5,r21
 908a740:	908c3080 	call	908c308 <__udivsi3>
 908a744:	a009883a 	mov	r4,r20
 908a748:	a80b883a 	mov	r5,r21
 908a74c:	102d883a 	mov	r22,r2
 908a750:	908c3100 	call	908c310 <__umodsi3>
 908a754:	1004943a 	slli	r2,r2,16
 908a758:	e006d43a 	srli	r3,fp,16
 908a75c:	bda3383a 	mul	r17,r23,r22
 908a760:	10c4b03a 	or	r2,r2,r3
 908a764:	1440042e 	bgeu	r2,r17,908a778 <__udivdi3+0x254>
 908a768:	1405883a 	add	r2,r2,r16
 908a76c:	b5bfffc4 	addi	r22,r22,-1
 908a770:	14000136 	bltu	r2,r16,908a778 <__udivdi3+0x254>
 908a774:	1440d536 	bltu	r2,r17,908aacc <__udivdi3+0x5a8>
 908a778:	1463c83a 	sub	r17,r2,r17
 908a77c:	8809883a 	mov	r4,r17
 908a780:	a80b883a 	mov	r5,r21
 908a784:	908c3080 	call	908c308 <__udivsi3>
 908a788:	8809883a 	mov	r4,r17
 908a78c:	a80b883a 	mov	r5,r21
 908a790:	1029883a 	mov	r20,r2
 908a794:	908c3100 	call	908c310 <__umodsi3>
 908a798:	1004943a 	slli	r2,r2,16
 908a79c:	bd09383a 	mul	r4,r23,r20
 908a7a0:	e0ffffcc 	andi	r3,fp,65535
 908a7a4:	10c4b03a 	or	r2,r2,r3
 908a7a8:	1100042e 	bgeu	r2,r4,908a7bc <__udivdi3+0x298>
 908a7ac:	8085883a 	add	r2,r16,r2
 908a7b0:	a53fffc4 	addi	r20,r20,-1
 908a7b4:	14000136 	bltu	r2,r16,908a7bc <__udivdi3+0x298>
 908a7b8:	1100c736 	bltu	r2,r4,908aad8 <__udivdi3+0x5b4>
 908a7bc:	b004943a 	slli	r2,r22,16
 908a7c0:	0009883a 	mov	r4,zero
 908a7c4:	a084b03a 	or	r2,r20,r2
 908a7c8:	003fb706 	br	908a6a8 <__udivdi3+0x184>
 908a7cc:	00804034 	movhi	r2,256
 908a7d0:	10bfffc4 	addi	r2,r2,-1
 908a7d4:	11c0a436 	bltu	r2,r7,908aa68 <__udivdi3+0x544>
 908a7d8:	01400404 	movi	r5,16
 908a7dc:	2805883a 	mov	r2,r5
 908a7e0:	003fa406 	br	908a674 <__udivdi3+0x150>
 908a7e4:	0005883a 	mov	r2,zero
 908a7e8:	0009883a 	mov	r4,zero
 908a7ec:	003fae06 	br	908a6a8 <__udivdi3+0x184>
 908a7f0:	00804034 	movhi	r2,256
 908a7f4:	10bfffc4 	addi	r2,r2,-1
 908a7f8:	1400a136 	bltu	r2,r16,908aa80 <__udivdi3+0x55c>
 908a7fc:	01400404 	movi	r5,16
 908a800:	2805883a 	mov	r2,r5
 908a804:	003f6006 	br	908a588 <__udivdi3+0x64>
 908a808:	01000044 	movi	r4,1
 908a80c:	000b883a 	mov	r5,zero
 908a810:	908c3080 	call	908c308 <__udivsi3>
 908a814:	1021883a 	mov	r16,r2
 908a818:	00bfffd4 	movui	r2,65535
 908a81c:	143ff436 	bltu	r2,r16,908a7f0 <__udivdi3+0x2cc>
 908a820:	003f5506 	br	908a578 <__udivdi3+0x54>
 908a824:	00804034 	movhi	r2,256
 908a828:	10bfffc4 	addi	r2,r2,-1
 908a82c:	12009a36 	bltu	r2,r8,908aa98 <__udivdi3+0x574>
 908a830:	01400404 	movi	r5,16
 908a834:	2805883a 	mov	r2,r5
 908a838:	003fae06 	br	908a6f4 <__udivdi3+0x1d0>
 908a83c:	3dc5c83a 	sub	r2,r7,r23
 908a840:	35c8983a 	sll	r4,r6,r23
 908a844:	8086d83a 	srl	r3,r16,r2
 908a848:	a0a2d83a 	srl	r17,r20,r2
 908a84c:	e084d83a 	srl	r2,fp,r2
 908a850:	20eab03a 	or	r21,r4,r3
 908a854:	a82cd43a 	srli	r22,r21,16
 908a858:	a5c6983a 	sll	r3,r20,r23
 908a85c:	8809883a 	mov	r4,r17
 908a860:	b00b883a 	mov	r5,r22
 908a864:	1886b03a 	or	r3,r3,r2
 908a868:	d8c00215 	stw	r3,8(sp)
 908a86c:	908c3080 	call	908c308 <__udivsi3>
 908a870:	8809883a 	mov	r4,r17
 908a874:	b00b883a 	mov	r5,r22
 908a878:	1029883a 	mov	r20,r2
 908a87c:	908c3100 	call	908c310 <__umodsi3>
 908a880:	a8ffffcc 	andi	r3,r21,65535
 908a884:	d8c00515 	stw	r3,20(sp)
 908a888:	d9000217 	ldw	r4,8(sp)
 908a88c:	d9400517 	ldw	r5,20(sp)
 908a890:	1004943a 	slli	r2,r2,16
 908a894:	2006d43a 	srli	r3,r4,16
 908a898:	85e0983a 	sll	r16,r16,r23
 908a89c:	2d23383a 	mul	r17,r5,r20
 908a8a0:	10c4b03a 	or	r2,r2,r3
 908a8a4:	dc000015 	stw	r16,0(sp)
 908a8a8:	1440032e 	bgeu	r2,r17,908a8b8 <__udivdi3+0x394>
 908a8ac:	1545883a 	add	r2,r2,r21
 908a8b0:	a53fffc4 	addi	r20,r20,-1
 908a8b4:	15407f2e 	bgeu	r2,r21,908aab4 <__udivdi3+0x590>
 908a8b8:	1463c83a 	sub	r17,r2,r17
 908a8bc:	8809883a 	mov	r4,r17
 908a8c0:	b00b883a 	mov	r5,r22
 908a8c4:	908c3080 	call	908c308 <__udivsi3>
 908a8c8:	8809883a 	mov	r4,r17
 908a8cc:	b00b883a 	mov	r5,r22
 908a8d0:	1021883a 	mov	r16,r2
 908a8d4:	908c3100 	call	908c310 <__umodsi3>
 908a8d8:	d8c00517 	ldw	r3,20(sp)
 908a8dc:	d9000217 	ldw	r4,8(sp)
 908a8e0:	1004943a 	slli	r2,r2,16
 908a8e4:	1c0f383a 	mul	r7,r3,r16
 908a8e8:	20ffffcc 	andi	r3,r4,65535
 908a8ec:	10e2b03a 	or	r17,r2,r3
 908a8f0:	89c0032e 	bgeu	r17,r7,908a900 <__udivdi3+0x3dc>
 908a8f4:	8d63883a 	add	r17,r17,r21
 908a8f8:	843fffc4 	addi	r16,r16,-1
 908a8fc:	8d40692e 	bgeu	r17,r21,908aaa4 <__udivdi3+0x580>
 908a900:	a008943a 	slli	r4,r20,16
 908a904:	d9400017 	ldw	r5,0(sp)
 908a908:	89e3c83a 	sub	r17,r17,r7
 908a90c:	8110b03a 	or	r8,r16,r4
 908a910:	280cd43a 	srli	r6,r5,16
 908a914:	28ffffcc 	andi	r3,r5,65535
 908a918:	40bfffcc 	andi	r2,r8,65535
 908a91c:	400ad43a 	srli	r5,r8,16
 908a920:	10d3383a 	mul	r9,r2,r3
 908a924:	1185383a 	mul	r2,r2,r6
 908a928:	28c7383a 	mul	r3,r5,r3
 908a92c:	4808d43a 	srli	r4,r9,16
 908a930:	298b383a 	mul	r5,r5,r6
 908a934:	10c5883a 	add	r2,r2,r3
 908a938:	2089883a 	add	r4,r4,r2
 908a93c:	20c0022e 	bgeu	r4,r3,908a948 <__udivdi3+0x424>
 908a940:	00800074 	movhi	r2,1
 908a944:	288b883a 	add	r5,r5,r2
 908a948:	2004d43a 	srli	r2,r4,16
 908a94c:	288b883a 	add	r5,r5,r2
 908a950:	89403f36 	bltu	r17,r5,908aa50 <__udivdi3+0x52c>
 908a954:	89403926 	beq	r17,r5,908aa3c <__udivdi3+0x518>
 908a958:	4005883a 	mov	r2,r8
 908a95c:	0009883a 	mov	r4,zero
 908a960:	003f5106 	br	908a6a8 <__udivdi3+0x184>
 908a964:	85a0983a 	sll	r16,r16,r22
 908a968:	3585c83a 	sub	r2,r6,r22
 908a96c:	a0a2d83a 	srl	r17,r20,r2
 908a970:	802ad43a 	srli	r21,r16,16
 908a974:	e084d83a 	srl	r2,fp,r2
 908a978:	a586983a 	sll	r3,r20,r22
 908a97c:	8809883a 	mov	r4,r17
 908a980:	a80b883a 	mov	r5,r21
 908a984:	1886b03a 	or	r3,r3,r2
 908a988:	d8c00115 	stw	r3,4(sp)
 908a98c:	908c3080 	call	908c308 <__udivsi3>
 908a990:	8809883a 	mov	r4,r17
 908a994:	a80b883a 	mov	r5,r21
 908a998:	d8800415 	stw	r2,16(sp)
 908a99c:	908c3100 	call	908c310 <__umodsi3>
 908a9a0:	d9000117 	ldw	r4,4(sp)
 908a9a4:	d9400417 	ldw	r5,16(sp)
 908a9a8:	1004943a 	slli	r2,r2,16
 908a9ac:	85ffffcc 	andi	r23,r16,65535
 908a9b0:	2006d43a 	srli	r3,r4,16
 908a9b4:	b963383a 	mul	r17,r23,r5
 908a9b8:	10c4b03a 	or	r2,r2,r3
 908a9bc:	1440042e 	bgeu	r2,r17,908a9d0 <__udivdi3+0x4ac>
 908a9c0:	297fffc4 	addi	r5,r5,-1
 908a9c4:	1405883a 	add	r2,r2,r16
 908a9c8:	d9400415 	stw	r5,16(sp)
 908a9cc:	1400442e 	bgeu	r2,r16,908aae0 <__udivdi3+0x5bc>
 908a9d0:	1463c83a 	sub	r17,r2,r17
 908a9d4:	8809883a 	mov	r4,r17
 908a9d8:	a80b883a 	mov	r5,r21
 908a9dc:	908c3080 	call	908c308 <__udivsi3>
 908a9e0:	8809883a 	mov	r4,r17
 908a9e4:	a80b883a 	mov	r5,r21
 908a9e8:	1029883a 	mov	r20,r2
 908a9ec:	908c3100 	call	908c310 <__umodsi3>
 908a9f0:	d9400117 	ldw	r5,4(sp)
 908a9f4:	1004943a 	slli	r2,r2,16
 908a9f8:	bd09383a 	mul	r4,r23,r20
 908a9fc:	28ffffcc 	andi	r3,r5,65535
 908aa00:	10c6b03a 	or	r3,r2,r3
 908aa04:	1900062e 	bgeu	r3,r4,908aa20 <__udivdi3+0x4fc>
 908aa08:	1c07883a 	add	r3,r3,r16
 908aa0c:	a53fffc4 	addi	r20,r20,-1
 908aa10:	1c000336 	bltu	r3,r16,908aa20 <__udivdi3+0x4fc>
 908aa14:	1900022e 	bgeu	r3,r4,908aa20 <__udivdi3+0x4fc>
 908aa18:	a53fffc4 	addi	r20,r20,-1
 908aa1c:	1c07883a 	add	r3,r3,r16
 908aa20:	d9400417 	ldw	r5,16(sp)
 908aa24:	e5b8983a 	sll	fp,fp,r22
 908aa28:	1923c83a 	sub	r17,r3,r4
 908aa2c:	2804943a 	slli	r2,r5,16
 908aa30:	a0a8b03a 	or	r20,r20,r2
 908aa34:	dd000315 	stw	r20,12(sp)
 908aa38:	003ee106 	br	908a5c0 <__udivdi3+0x9c>
 908aa3c:	2004943a 	slli	r2,r4,16
 908aa40:	e5c8983a 	sll	r4,fp,r23
 908aa44:	48ffffcc 	andi	r3,r9,65535
 908aa48:	10c5883a 	add	r2,r2,r3
 908aa4c:	20bfc22e 	bgeu	r4,r2,908a958 <__udivdi3+0x434>
 908aa50:	40bfffc4 	addi	r2,r8,-1
 908aa54:	0009883a 	mov	r4,zero
 908aa58:	003f1306 	br	908a6a8 <__udivdi3+0x184>
 908aa5c:	01400204 	movi	r5,8
 908aa60:	2805883a 	mov	r2,r5
 908aa64:	003f0306 	br	908a674 <__udivdi3+0x150>
 908aa68:	01400604 	movi	r5,24
 908aa6c:	2805883a 	mov	r2,r5
 908aa70:	003f0006 	br	908a674 <__udivdi3+0x150>
 908aa74:	01400204 	movi	r5,8
 908aa78:	2805883a 	mov	r2,r5
 908aa7c:	003ec206 	br	908a588 <__udivdi3+0x64>
 908aa80:	01400604 	movi	r5,24
 908aa84:	2805883a 	mov	r2,r5
 908aa88:	003ebf06 	br	908a588 <__udivdi3+0x64>
 908aa8c:	01400204 	movi	r5,8
 908aa90:	2805883a 	mov	r2,r5
 908aa94:	003f1706 	br	908a6f4 <__udivdi3+0x1d0>
 908aa98:	01400604 	movi	r5,24
 908aa9c:	2805883a 	mov	r2,r5
 908aaa0:	003f1406 	br	908a6f4 <__udivdi3+0x1d0>
 908aaa4:	89ff962e 	bgeu	r17,r7,908a900 <__udivdi3+0x3dc>
 908aaa8:	8d63883a 	add	r17,r17,r21
 908aaac:	843fffc4 	addi	r16,r16,-1
 908aab0:	003f9306 	br	908a900 <__udivdi3+0x3dc>
 908aab4:	147f802e 	bgeu	r2,r17,908a8b8 <__udivdi3+0x394>
 908aab8:	a53fffc4 	addi	r20,r20,-1
 908aabc:	1545883a 	add	r2,r2,r21
 908aac0:	003f7d06 	br	908a8b8 <__udivdi3+0x394>
 908aac4:	a53fffc4 	addi	r20,r20,-1
 908aac8:	003ede06 	br	908a644 <__udivdi3+0x120>
 908aacc:	b5bfffc4 	addi	r22,r22,-1
 908aad0:	1405883a 	add	r2,r2,r16
 908aad4:	003f2806 	br	908a778 <__udivdi3+0x254>
 908aad8:	a53fffc4 	addi	r20,r20,-1
 908aadc:	003f3706 	br	908a7bc <__udivdi3+0x298>
 908aae0:	147fbb2e 	bgeu	r2,r17,908a9d0 <__udivdi3+0x4ac>
 908aae4:	297fffc4 	addi	r5,r5,-1
 908aae8:	1405883a 	add	r2,r2,r16
 908aaec:	d9400415 	stw	r5,16(sp)
 908aaf0:	003fb706 	br	908a9d0 <__udivdi3+0x4ac>
 908aaf4:	b5bfffc4 	addi	r22,r22,-1
 908aaf8:	1405883a 	add	r2,r2,r16
 908aafc:	003ec006 	br	908a600 <__udivdi3+0xdc>

0908ab00 <__umoddi3>:
 908ab00:	defff104 	addi	sp,sp,-60
 908ab04:	dd800b15 	stw	r22,44(sp)
 908ab08:	dd000915 	stw	r20,36(sp)
 908ab0c:	dc000515 	stw	r16,20(sp)
 908ab10:	dfc00e15 	stw	ra,56(sp)
 908ab14:	df000d15 	stw	fp,52(sp)
 908ab18:	ddc00c15 	stw	r23,48(sp)
 908ab1c:	dd400a15 	stw	r21,40(sp)
 908ab20:	dcc00815 	stw	r19,32(sp)
 908ab24:	dc800715 	stw	r18,28(sp)
 908ab28:	dc400615 	stw	r17,24(sp)
 908ab2c:	3021883a 	mov	r16,r6
 908ab30:	202d883a 	mov	r22,r4
 908ab34:	2829883a 	mov	r20,r5
 908ab38:	38002b1e 	bne	r7,zero,908abe8 <__umoddi3+0xe8>
 908ab3c:	29805036 	bltu	r5,r6,908ac80 <__umoddi3+0x180>
 908ab40:	30008a26 	beq	r6,zero,908ad6c <__umoddi3+0x26c>
 908ab44:	00bfffd4 	movui	r2,65535
 908ab48:	14008236 	bltu	r2,r16,908ad54 <__umoddi3+0x254>
 908ab4c:	00803fc4 	movi	r2,255
 908ab50:	14013636 	bltu	r2,r16,908b02c <__umoddi3+0x52c>
 908ab54:	000b883a 	mov	r5,zero
 908ab58:	0005883a 	mov	r2,zero
 908ab5c:	8084d83a 	srl	r2,r16,r2
 908ab60:	01024374 	movhi	r4,2317
 908ab64:	2132eb04 	addi	r4,r4,-13396
 908ab68:	01800804 	movi	r6,32
 908ab6c:	1105883a 	add	r2,r2,r4
 908ab70:	10c00003 	ldbu	r3,0(r2)
 908ab74:	28c7883a 	add	r3,r5,r3
 908ab78:	30efc83a 	sub	r23,r6,r3
 908ab7c:	b800941e 	bne	r23,zero,908add0 <__umoddi3+0x2d0>
 908ab80:	802ad43a 	srli	r21,r16,16
 908ab84:	a423c83a 	sub	r17,r20,r16
 908ab88:	0039883a 	mov	fp,zero
 908ab8c:	853fffcc 	andi	r20,r16,65535
 908ab90:	8809883a 	mov	r4,r17
 908ab94:	a80b883a 	mov	r5,r21
 908ab98:	908c3080 	call	908c308 <__udivsi3>
 908ab9c:	8809883a 	mov	r4,r17
 908aba0:	a80b883a 	mov	r5,r21
 908aba4:	a0a3383a 	mul	r17,r20,r2
 908aba8:	908c3100 	call	908c310 <__umodsi3>
 908abac:	1004943a 	slli	r2,r2,16
 908abb0:	b006d43a 	srli	r3,r22,16
 908abb4:	10c4b03a 	or	r2,r2,r3
 908abb8:	1440032e 	bgeu	r2,r17,908abc8 <__umoddi3+0xc8>
 908abbc:	1405883a 	add	r2,r2,r16
 908abc0:	14000136 	bltu	r2,r16,908abc8 <__umoddi3+0xc8>
 908abc4:	14413536 	bltu	r2,r17,908b09c <__umoddi3+0x59c>
 908abc8:	1463c83a 	sub	r17,r2,r17
 908abcc:	8809883a 	mov	r4,r17
 908abd0:	a80b883a 	mov	r5,r21
 908abd4:	908c3080 	call	908c308 <__udivsi3>
 908abd8:	8809883a 	mov	r4,r17
 908abdc:	a0a3383a 	mul	r17,r20,r2
 908abe0:	a80b883a 	mov	r5,r21
 908abe4:	00004d06 	br	908ad1c <__umoddi3+0x21c>
 908abe8:	380d883a 	mov	r6,r7
 908abec:	29c0102e 	bgeu	r5,r7,908ac30 <__umoddi3+0x130>
 908abf0:	2011883a 	mov	r8,r4
 908abf4:	2813883a 	mov	r9,r5
 908abf8:	4005883a 	mov	r2,r8
 908abfc:	4807883a 	mov	r3,r9
 908ac00:	dfc00e17 	ldw	ra,56(sp)
 908ac04:	df000d17 	ldw	fp,52(sp)
 908ac08:	ddc00c17 	ldw	r23,48(sp)
 908ac0c:	dd800b17 	ldw	r22,44(sp)
 908ac10:	dd400a17 	ldw	r21,40(sp)
 908ac14:	dd000917 	ldw	r20,36(sp)
 908ac18:	dcc00817 	ldw	r19,32(sp)
 908ac1c:	dc800717 	ldw	r18,28(sp)
 908ac20:	dc400617 	ldw	r17,24(sp)
 908ac24:	dc000517 	ldw	r16,20(sp)
 908ac28:	dec00f04 	addi	sp,sp,60
 908ac2c:	f800283a 	ret
 908ac30:	00bfffd4 	movui	r2,65535
 908ac34:	11c05a36 	bltu	r2,r7,908ada0 <__umoddi3+0x2a0>
 908ac38:	00803fc4 	movi	r2,255
 908ac3c:	11c0fe36 	bltu	r2,r7,908b038 <__umoddi3+0x538>
 908ac40:	000b883a 	mov	r5,zero
 908ac44:	0005883a 	mov	r2,zero
 908ac48:	3084d83a 	srl	r2,r6,r2
 908ac4c:	01024374 	movhi	r4,2317
 908ac50:	2132eb04 	addi	r4,r4,-13396
 908ac54:	01c00804 	movi	r7,32
 908ac58:	1105883a 	add	r2,r2,r4
 908ac5c:	10c00003 	ldbu	r3,0(r2)
 908ac60:	28c7883a 	add	r3,r5,r3
 908ac64:	38ebc83a 	sub	r21,r7,r3
 908ac68:	a800851e 	bne	r21,zero,908ae80 <__umoddi3+0x380>
 908ac6c:	35005236 	bltu	r6,r20,908adb8 <__umoddi3+0x2b8>
 908ac70:	b400512e 	bgeu	r22,r16,908adb8 <__umoddi3+0x2b8>
 908ac74:	b011883a 	mov	r8,r22
 908ac78:	a013883a 	mov	r9,r20
 908ac7c:	003fde06 	br	908abf8 <__umoddi3+0xf8>
 908ac80:	00bfffd4 	movui	r2,65535
 908ac84:	11804036 	bltu	r2,r6,908ad88 <__umoddi3+0x288>
 908ac88:	00803fc4 	movi	r2,255
 908ac8c:	1180ed36 	bltu	r2,r6,908b044 <__umoddi3+0x544>
 908ac90:	000b883a 	mov	r5,zero
 908ac94:	0005883a 	mov	r2,zero
 908ac98:	8084d83a 	srl	r2,r16,r2
 908ac9c:	01024374 	movhi	r4,2317
 908aca0:	2132eb04 	addi	r4,r4,-13396
 908aca4:	01800804 	movi	r6,32
 908aca8:	1105883a 	add	r2,r2,r4
 908acac:	10c00003 	ldbu	r3,0(r2)
 908acb0:	28c7883a 	add	r3,r5,r3
 908acb4:	30c7c83a 	sub	r3,r6,r3
 908acb8:	1800bf1e 	bne	r3,zero,908afb8 <__umoddi3+0x4b8>
 908acbc:	0039883a 	mov	fp,zero
 908acc0:	802ad43a 	srli	r21,r16,16
 908acc4:	a009883a 	mov	r4,r20
 908acc8:	85ffffcc 	andi	r23,r16,65535
 908accc:	a80b883a 	mov	r5,r21
 908acd0:	908c3080 	call	908c308 <__udivsi3>
 908acd4:	a009883a 	mov	r4,r20
 908acd8:	a80b883a 	mov	r5,r21
 908acdc:	b8a3383a 	mul	r17,r23,r2
 908ace0:	908c3100 	call	908c310 <__umodsi3>
 908ace4:	1004943a 	slli	r2,r2,16
 908ace8:	b006d43a 	srli	r3,r22,16
 908acec:	10c4b03a 	or	r2,r2,r3
 908acf0:	1440032e 	bgeu	r2,r17,908ad00 <__umoddi3+0x200>
 908acf4:	1405883a 	add	r2,r2,r16
 908acf8:	14000136 	bltu	r2,r16,908ad00 <__umoddi3+0x200>
 908acfc:	1440e536 	bltu	r2,r17,908b094 <__umoddi3+0x594>
 908ad00:	1463c83a 	sub	r17,r2,r17
 908ad04:	8809883a 	mov	r4,r17
 908ad08:	a80b883a 	mov	r5,r21
 908ad0c:	908c3080 	call	908c308 <__udivsi3>
 908ad10:	8809883a 	mov	r4,r17
 908ad14:	b8a3383a 	mul	r17,r23,r2
 908ad18:	a80b883a 	mov	r5,r21
 908ad1c:	908c3100 	call	908c310 <__umodsi3>
 908ad20:	1004943a 	slli	r2,r2,16
 908ad24:	b0ffffcc 	andi	r3,r22,65535
 908ad28:	10c4b03a 	or	r2,r2,r3
 908ad2c:	1440042e 	bgeu	r2,r17,908ad40 <__umoddi3+0x240>
 908ad30:	1405883a 	add	r2,r2,r16
 908ad34:	14000236 	bltu	r2,r16,908ad40 <__umoddi3+0x240>
 908ad38:	1440012e 	bgeu	r2,r17,908ad40 <__umoddi3+0x240>
 908ad3c:	1405883a 	add	r2,r2,r16
 908ad40:	1445c83a 	sub	r2,r2,r17
 908ad44:	1724d83a 	srl	r18,r2,fp
 908ad48:	0013883a 	mov	r9,zero
 908ad4c:	9011883a 	mov	r8,r18
 908ad50:	003fa906 	br	908abf8 <__umoddi3+0xf8>
 908ad54:	00804034 	movhi	r2,256
 908ad58:	10bfffc4 	addi	r2,r2,-1
 908ad5c:	1400b036 	bltu	r2,r16,908b020 <__umoddi3+0x520>
 908ad60:	01400404 	movi	r5,16
 908ad64:	2805883a 	mov	r2,r5
 908ad68:	003f7c06 	br	908ab5c <__umoddi3+0x5c>
 908ad6c:	01000044 	movi	r4,1
 908ad70:	000b883a 	mov	r5,zero
 908ad74:	908c3080 	call	908c308 <__udivsi3>
 908ad78:	1021883a 	mov	r16,r2
 908ad7c:	00bfffd4 	movui	r2,65535
 908ad80:	143ff436 	bltu	r2,r16,908ad54 <__umoddi3+0x254>
 908ad84:	003f7106 	br	908ab4c <__umoddi3+0x4c>
 908ad88:	00804034 	movhi	r2,256
 908ad8c:	10bfffc4 	addi	r2,r2,-1
 908ad90:	1180af36 	bltu	r2,r6,908b050 <__umoddi3+0x550>
 908ad94:	01400404 	movi	r5,16
 908ad98:	2805883a 	mov	r2,r5
 908ad9c:	003fbe06 	br	908ac98 <__umoddi3+0x198>
 908ada0:	00804034 	movhi	r2,256
 908ada4:	10bfffc4 	addi	r2,r2,-1
 908ada8:	11c0ac36 	bltu	r2,r7,908b05c <__umoddi3+0x55c>
 908adac:	01400404 	movi	r5,16
 908adb0:	2805883a 	mov	r2,r5
 908adb4:	003fa406 	br	908ac48 <__umoddi3+0x148>
 908adb8:	b409c83a 	sub	r4,r22,r16
 908adbc:	b105803a 	cmpltu	r2,r22,r4
 908adc0:	a187c83a 	sub	r3,r20,r6
 908adc4:	18a9c83a 	sub	r20,r3,r2
 908adc8:	202d883a 	mov	r22,r4
 908adcc:	003fa906 	br	908ac74 <__umoddi3+0x174>
 908add0:	85e0983a 	sll	r16,r16,r23
 908add4:	35c5c83a 	sub	r2,r6,r23
 908add8:	a0a2d83a 	srl	r17,r20,r2
 908addc:	802ad43a 	srli	r21,r16,16
 908ade0:	b084d83a 	srl	r2,r22,r2
 908ade4:	a5c6983a 	sll	r3,r20,r23
 908ade8:	8809883a 	mov	r4,r17
 908adec:	a80b883a 	mov	r5,r21
 908adf0:	1886b03a 	or	r3,r3,r2
 908adf4:	d8c00115 	stw	r3,4(sp)
 908adf8:	853fffcc 	andi	r20,r16,65535
 908adfc:	908c3080 	call	908c308 <__udivsi3>
 908ae00:	8809883a 	mov	r4,r17
 908ae04:	a80b883a 	mov	r5,r21
 908ae08:	a0a3383a 	mul	r17,r20,r2
 908ae0c:	908c3100 	call	908c310 <__umodsi3>
 908ae10:	d9000117 	ldw	r4,4(sp)
 908ae14:	1004943a 	slli	r2,r2,16
 908ae18:	b839883a 	mov	fp,r23
 908ae1c:	2006d43a 	srli	r3,r4,16
 908ae20:	10c4b03a 	or	r2,r2,r3
 908ae24:	1440022e 	bgeu	r2,r17,908ae30 <__umoddi3+0x330>
 908ae28:	1405883a 	add	r2,r2,r16
 908ae2c:	1400962e 	bgeu	r2,r16,908b088 <__umoddi3+0x588>
 908ae30:	1463c83a 	sub	r17,r2,r17
 908ae34:	8809883a 	mov	r4,r17
 908ae38:	a80b883a 	mov	r5,r21
 908ae3c:	908c3080 	call	908c308 <__udivsi3>
 908ae40:	8809883a 	mov	r4,r17
 908ae44:	a80b883a 	mov	r5,r21
 908ae48:	a0a3383a 	mul	r17,r20,r2
 908ae4c:	908c3100 	call	908c310 <__umodsi3>
 908ae50:	d9400117 	ldw	r5,4(sp)
 908ae54:	1004943a 	slli	r2,r2,16
 908ae58:	28ffffcc 	andi	r3,r5,65535
 908ae5c:	10c4b03a 	or	r2,r2,r3
 908ae60:	1440042e 	bgeu	r2,r17,908ae74 <__umoddi3+0x374>
 908ae64:	1405883a 	add	r2,r2,r16
 908ae68:	14000236 	bltu	r2,r16,908ae74 <__umoddi3+0x374>
 908ae6c:	1440012e 	bgeu	r2,r17,908ae74 <__umoddi3+0x374>
 908ae70:	1405883a 	add	r2,r2,r16
 908ae74:	b5ec983a 	sll	r22,r22,r23
 908ae78:	1463c83a 	sub	r17,r2,r17
 908ae7c:	003f4406 	br	908ab90 <__umoddi3+0x90>
 908ae80:	3d4fc83a 	sub	r7,r7,r21
 908ae84:	3546983a 	sll	r3,r6,r21
 908ae88:	81c4d83a 	srl	r2,r16,r7
 908ae8c:	a1e2d83a 	srl	r17,r20,r7
 908ae90:	a54c983a 	sll	r6,r20,r21
 908ae94:	18aeb03a 	or	r23,r3,r2
 908ae98:	b828d43a 	srli	r20,r23,16
 908ae9c:	b1c4d83a 	srl	r2,r22,r7
 908aea0:	8809883a 	mov	r4,r17
 908aea4:	a00b883a 	mov	r5,r20
 908aea8:	308cb03a 	or	r6,r6,r2
 908aeac:	d9c00315 	stw	r7,12(sp)
 908aeb0:	d9800215 	stw	r6,8(sp)
 908aeb4:	908c3080 	call	908c308 <__udivsi3>
 908aeb8:	8809883a 	mov	r4,r17
 908aebc:	a00b883a 	mov	r5,r20
 908aec0:	1039883a 	mov	fp,r2
 908aec4:	908c3100 	call	908c310 <__umodsi3>
 908aec8:	b8ffffcc 	andi	r3,r23,65535
 908aecc:	d8c00415 	stw	r3,16(sp)
 908aed0:	d9000217 	ldw	r4,8(sp)
 908aed4:	d9400417 	ldw	r5,16(sp)
 908aed8:	1004943a 	slli	r2,r2,16
 908aedc:	2006d43a 	srli	r3,r4,16
 908aee0:	8560983a 	sll	r16,r16,r21
 908aee4:	2f23383a 	mul	r17,r5,fp
 908aee8:	10c4b03a 	or	r2,r2,r3
 908aeec:	dc000015 	stw	r16,0(sp)
 908aef0:	b56c983a 	sll	r22,r22,r21
 908aef4:	1440032e 	bgeu	r2,r17,908af04 <__umoddi3+0x404>
 908aef8:	15c5883a 	add	r2,r2,r23
 908aefc:	e73fffc4 	addi	fp,fp,-1
 908af00:	15c05d2e 	bgeu	r2,r23,908b078 <__umoddi3+0x578>
 908af04:	1463c83a 	sub	r17,r2,r17
 908af08:	8809883a 	mov	r4,r17
 908af0c:	a00b883a 	mov	r5,r20
 908af10:	908c3080 	call	908c308 <__udivsi3>
 908af14:	8809883a 	mov	r4,r17
 908af18:	a00b883a 	mov	r5,r20
 908af1c:	1021883a 	mov	r16,r2
 908af20:	908c3100 	call	908c310 <__umodsi3>
 908af24:	d8c00417 	ldw	r3,16(sp)
 908af28:	d9000217 	ldw	r4,8(sp)
 908af2c:	1004943a 	slli	r2,r2,16
 908af30:	1c23383a 	mul	r17,r3,r16
 908af34:	20ffffcc 	andi	r3,r4,65535
 908af38:	10ceb03a 	or	r7,r2,r3
 908af3c:	3c40032e 	bgeu	r7,r17,908af4c <__umoddi3+0x44c>
 908af40:	3dcf883a 	add	r7,r7,r23
 908af44:	843fffc4 	addi	r16,r16,-1
 908af48:	3dc0472e 	bgeu	r7,r23,908b068 <__umoddi3+0x568>
 908af4c:	e004943a 	slli	r2,fp,16
 908af50:	d9400017 	ldw	r5,0(sp)
 908af54:	3c4fc83a 	sub	r7,r7,r17
 908af58:	8084b03a 	or	r2,r16,r2
 908af5c:	28ffffcc 	andi	r3,r5,65535
 908af60:	280cd43a 	srli	r6,r5,16
 908af64:	100ad43a 	srli	r5,r2,16
 908af68:	10bfffcc 	andi	r2,r2,65535
 908af6c:	10d1383a 	mul	r8,r2,r3
 908af70:	28c7383a 	mul	r3,r5,r3
 908af74:	1185383a 	mul	r2,r2,r6
 908af78:	4008d43a 	srli	r4,r8,16
 908af7c:	298b383a 	mul	r5,r5,r6
 908af80:	10c5883a 	add	r2,r2,r3
 908af84:	2089883a 	add	r4,r4,r2
 908af88:	20c0022e 	bgeu	r4,r3,908af94 <__umoddi3+0x494>
 908af8c:	00800074 	movhi	r2,1
 908af90:	288b883a 	add	r5,r5,r2
 908af94:	2004d43a 	srli	r2,r4,16
 908af98:	2008943a 	slli	r4,r4,16
 908af9c:	40ffffcc 	andi	r3,r8,65535
 908afa0:	288b883a 	add	r5,r5,r2
 908afa4:	20c9883a 	add	r4,r4,r3
 908afa8:	39400b36 	bltu	r7,r5,908afd8 <__umoddi3+0x4d8>
 908afac:	39403d26 	beq	r7,r5,908b0a4 <__umoddi3+0x5a4>
 908afb0:	394bc83a 	sub	r5,r7,r5
 908afb4:	00000f06 	br	908aff4 <__umoddi3+0x4f4>
 908afb8:	30c5c83a 	sub	r2,r6,r3
 908afbc:	1839883a 	mov	fp,r3
 908afc0:	b084d83a 	srl	r2,r22,r2
 908afc4:	a0c6983a 	sll	r3,r20,r3
 908afc8:	8720983a 	sll	r16,r16,fp
 908afcc:	b72c983a 	sll	r22,r22,fp
 908afd0:	18a8b03a 	or	r20,r3,r2
 908afd4:	003f3a06 	br	908acc0 <__umoddi3+0x1c0>
 908afd8:	d8c00017 	ldw	r3,0(sp)
 908afdc:	20c5c83a 	sub	r2,r4,r3
 908afe0:	2089803a 	cmpltu	r4,r4,r2
 908afe4:	2dc7c83a 	sub	r3,r5,r23
 908afe8:	1907c83a 	sub	r3,r3,r4
 908afec:	38cbc83a 	sub	r5,r7,r3
 908aff0:	1009883a 	mov	r4,r2
 908aff4:	b105c83a 	sub	r2,r22,r4
 908aff8:	b087803a 	cmpltu	r3,r22,r2
 908affc:	28c7c83a 	sub	r3,r5,r3
 908b000:	d9400317 	ldw	r5,12(sp)
 908b004:	1544d83a 	srl	r2,r2,r21
 908b008:	1948983a 	sll	r4,r3,r5
 908b00c:	1d46d83a 	srl	r3,r3,r21
 908b010:	20a4b03a 	or	r18,r4,r2
 908b014:	9011883a 	mov	r8,r18
 908b018:	1813883a 	mov	r9,r3
 908b01c:	003ef606 	br	908abf8 <__umoddi3+0xf8>
 908b020:	01400604 	movi	r5,24
 908b024:	2805883a 	mov	r2,r5
 908b028:	003ecc06 	br	908ab5c <__umoddi3+0x5c>
 908b02c:	01400204 	movi	r5,8
 908b030:	2805883a 	mov	r2,r5
 908b034:	003ec906 	br	908ab5c <__umoddi3+0x5c>
 908b038:	01400204 	movi	r5,8
 908b03c:	2805883a 	mov	r2,r5
 908b040:	003f0106 	br	908ac48 <__umoddi3+0x148>
 908b044:	01400204 	movi	r5,8
 908b048:	2805883a 	mov	r2,r5
 908b04c:	003f1206 	br	908ac98 <__umoddi3+0x198>
 908b050:	01400604 	movi	r5,24
 908b054:	2805883a 	mov	r2,r5
 908b058:	003f0f06 	br	908ac98 <__umoddi3+0x198>
 908b05c:	01400604 	movi	r5,24
 908b060:	2805883a 	mov	r2,r5
 908b064:	003ef806 	br	908ac48 <__umoddi3+0x148>
 908b068:	3c7fb82e 	bgeu	r7,r17,908af4c <__umoddi3+0x44c>
 908b06c:	843fffc4 	addi	r16,r16,-1
 908b070:	3dcf883a 	add	r7,r7,r23
 908b074:	003fb506 	br	908af4c <__umoddi3+0x44c>
 908b078:	147fa22e 	bgeu	r2,r17,908af04 <__umoddi3+0x404>
 908b07c:	e73fffc4 	addi	fp,fp,-1
 908b080:	15c5883a 	add	r2,r2,r23
 908b084:	003f9f06 	br	908af04 <__umoddi3+0x404>
 908b088:	147f692e 	bgeu	r2,r17,908ae30 <__umoddi3+0x330>
 908b08c:	1405883a 	add	r2,r2,r16
 908b090:	003f6706 	br	908ae30 <__umoddi3+0x330>
 908b094:	1405883a 	add	r2,r2,r16
 908b098:	003f1906 	br	908ad00 <__umoddi3+0x200>
 908b09c:	1405883a 	add	r2,r2,r16
 908b0a0:	003ec906 	br	908abc8 <__umoddi3+0xc8>
 908b0a4:	b13fcc36 	bltu	r22,r4,908afd8 <__umoddi3+0x4d8>
 908b0a8:	000b883a 	mov	r5,zero
 908b0ac:	003fd106 	br	908aff4 <__umoddi3+0x4f4>

0908b0b0 <_fpadd_parts>:
 908b0b0:	defff804 	addi	sp,sp,-32
 908b0b4:	dcc00315 	stw	r19,12(sp)
 908b0b8:	2027883a 	mov	r19,r4
 908b0bc:	21000017 	ldw	r4,0(r4)
 908b0c0:	00c00044 	movi	r3,1
 908b0c4:	dd400515 	stw	r21,20(sp)
 908b0c8:	dd000415 	stw	r20,16(sp)
 908b0cc:	ddc00715 	stw	r23,28(sp)
 908b0d0:	dd800615 	stw	r22,24(sp)
 908b0d4:	dc800215 	stw	r18,8(sp)
 908b0d8:	dc400115 	stw	r17,4(sp)
 908b0dc:	dc000015 	stw	r16,0(sp)
 908b0e0:	282b883a 	mov	r21,r5
 908b0e4:	3029883a 	mov	r20,r6
 908b0e8:	1900632e 	bgeu	r3,r4,908b278 <_fpadd_parts+0x1c8>
 908b0ec:	28800017 	ldw	r2,0(r5)
 908b0f0:	1880812e 	bgeu	r3,r2,908b2f8 <_fpadd_parts+0x248>
 908b0f4:	00c00104 	movi	r3,4
 908b0f8:	20c0dc26 	beq	r4,r3,908b46c <_fpadd_parts+0x3bc>
 908b0fc:	10c07e26 	beq	r2,r3,908b2f8 <_fpadd_parts+0x248>
 908b100:	00c00084 	movi	r3,2
 908b104:	10c06726 	beq	r2,r3,908b2a4 <_fpadd_parts+0x1f4>
 908b108:	20c07b26 	beq	r4,r3,908b2f8 <_fpadd_parts+0x248>
 908b10c:	9dc00217 	ldw	r23,8(r19)
 908b110:	28c00217 	ldw	r3,8(r5)
 908b114:	9c400317 	ldw	r17,12(r19)
 908b118:	2bc00317 	ldw	r15,12(r5)
 908b11c:	b8cdc83a 	sub	r6,r23,r3
 908b120:	9c800417 	ldw	r18,16(r19)
 908b124:	2c000417 	ldw	r16,16(r5)
 908b128:	3009883a 	mov	r4,r6
 908b12c:	30009716 	blt	r6,zero,908b38c <_fpadd_parts+0x2dc>
 908b130:	00800fc4 	movi	r2,63
 908b134:	11806b16 	blt	r2,r6,908b2e4 <_fpadd_parts+0x234>
 908b138:	0100a40e 	bge	zero,r4,908b3cc <_fpadd_parts+0x31c>
 908b13c:	35bff804 	addi	r22,r6,-32
 908b140:	b000bc16 	blt	r22,zero,908b434 <_fpadd_parts+0x384>
 908b144:	8596d83a 	srl	r11,r16,r22
 908b148:	0019883a 	mov	r12,zero
 908b14c:	0013883a 	mov	r9,zero
 908b150:	01000044 	movi	r4,1
 908b154:	0015883a 	mov	r10,zero
 908b158:	b000be16 	blt	r22,zero,908b454 <_fpadd_parts+0x3a4>
 908b15c:	2590983a 	sll	r8,r4,r22
 908b160:	000f883a 	mov	r7,zero
 908b164:	00bfffc4 	movi	r2,-1
 908b168:	3889883a 	add	r4,r7,r2
 908b16c:	408b883a 	add	r5,r8,r2
 908b170:	21cd803a 	cmpltu	r6,r4,r7
 908b174:	314b883a 	add	r5,r6,r5
 908b178:	7904703a 	and	r2,r15,r4
 908b17c:	8146703a 	and	r3,r16,r5
 908b180:	10c4b03a 	or	r2,r2,r3
 908b184:	10000226 	beq	r2,zero,908b190 <_fpadd_parts+0xe0>
 908b188:	02400044 	movi	r9,1
 908b18c:	0015883a 	mov	r10,zero
 908b190:	5a5eb03a 	or	r15,r11,r9
 908b194:	62a0b03a 	or	r16,r12,r10
 908b198:	99400117 	ldw	r5,4(r19)
 908b19c:	a8800117 	ldw	r2,4(r21)
 908b1a0:	28806e26 	beq	r5,r2,908b35c <_fpadd_parts+0x2ac>
 908b1a4:	28006626 	beq	r5,zero,908b340 <_fpadd_parts+0x290>
 908b1a8:	7c45c83a 	sub	r2,r15,r17
 908b1ac:	7889803a 	cmpltu	r4,r15,r2
 908b1b0:	8487c83a 	sub	r3,r16,r18
 908b1b4:	1909c83a 	sub	r4,r3,r4
 908b1b8:	100d883a 	mov	r6,r2
 908b1bc:	200f883a 	mov	r7,r4
 908b1c0:	38007716 	blt	r7,zero,908b3a0 <_fpadd_parts+0x2f0>
 908b1c4:	a5c00215 	stw	r23,8(r20)
 908b1c8:	a1c00415 	stw	r7,16(r20)
 908b1cc:	a0000115 	stw	zero,4(r20)
 908b1d0:	a1800315 	stw	r6,12(r20)
 908b1d4:	a2000317 	ldw	r8,12(r20)
 908b1d8:	a2400417 	ldw	r9,16(r20)
 908b1dc:	00bfffc4 	movi	r2,-1
 908b1e0:	408b883a 	add	r5,r8,r2
 908b1e4:	2a09803a 	cmpltu	r4,r5,r8
 908b1e8:	488d883a 	add	r6,r9,r2
 908b1ec:	01c40034 	movhi	r7,4096
 908b1f0:	39ffffc4 	addi	r7,r7,-1
 908b1f4:	218d883a 	add	r6,r4,r6
 908b1f8:	39801736 	bltu	r7,r6,908b258 <_fpadd_parts+0x1a8>
 908b1fc:	31c06526 	beq	r6,r7,908b394 <_fpadd_parts+0x2e4>
 908b200:	a3000217 	ldw	r12,8(r20)
 908b204:	4209883a 	add	r4,r8,r8
 908b208:	00bfffc4 	movi	r2,-1
 908b20c:	220f803a 	cmpltu	r7,r4,r8
 908b210:	4a4b883a 	add	r5,r9,r9
 908b214:	394f883a 	add	r7,r7,r5
 908b218:	2095883a 	add	r10,r4,r2
 908b21c:	3897883a 	add	r11,r7,r2
 908b220:	510d803a 	cmpltu	r6,r10,r4
 908b224:	6099883a 	add	r12,r12,r2
 908b228:	32d7883a 	add	r11,r6,r11
 908b22c:	00840034 	movhi	r2,4096
 908b230:	10bfffc4 	addi	r2,r2,-1
 908b234:	2011883a 	mov	r8,r4
 908b238:	3813883a 	mov	r9,r7
 908b23c:	a1000315 	stw	r4,12(r20)
 908b240:	a1c00415 	stw	r7,16(r20)
 908b244:	a3000215 	stw	r12,8(r20)
 908b248:	12c00336 	bltu	r2,r11,908b258 <_fpadd_parts+0x1a8>
 908b24c:	58bfed1e 	bne	r11,r2,908b204 <_fpadd_parts+0x154>
 908b250:	00bfff84 	movi	r2,-2
 908b254:	12bfeb2e 	bgeu	r2,r10,908b204 <_fpadd_parts+0x154>
 908b258:	a2800417 	ldw	r10,16(r20)
 908b25c:	008000c4 	movi	r2,3
 908b260:	00c80034 	movhi	r3,8192
 908b264:	18ffffc4 	addi	r3,r3,-1
 908b268:	a2400317 	ldw	r9,12(r20)
 908b26c:	a0800015 	stw	r2,0(r20)
 908b270:	1a802336 	bltu	r3,r10,908b300 <_fpadd_parts+0x250>
 908b274:	a027883a 	mov	r19,r20
 908b278:	9805883a 	mov	r2,r19
 908b27c:	ddc00717 	ldw	r23,28(sp)
 908b280:	dd800617 	ldw	r22,24(sp)
 908b284:	dd400517 	ldw	r21,20(sp)
 908b288:	dd000417 	ldw	r20,16(sp)
 908b28c:	dcc00317 	ldw	r19,12(sp)
 908b290:	dc800217 	ldw	r18,8(sp)
 908b294:	dc400117 	ldw	r17,4(sp)
 908b298:	dc000017 	ldw	r16,0(sp)
 908b29c:	dec00804 	addi	sp,sp,32
 908b2a0:	f800283a 	ret
 908b2a4:	20fff41e 	bne	r4,r3,908b278 <_fpadd_parts+0x1c8>
 908b2a8:	31000015 	stw	r4,0(r6)
 908b2ac:	98800117 	ldw	r2,4(r19)
 908b2b0:	30800115 	stw	r2,4(r6)
 908b2b4:	98c00217 	ldw	r3,8(r19)
 908b2b8:	30c00215 	stw	r3,8(r6)
 908b2bc:	98800317 	ldw	r2,12(r19)
 908b2c0:	30800315 	stw	r2,12(r6)
 908b2c4:	98c00417 	ldw	r3,16(r19)
 908b2c8:	30c00415 	stw	r3,16(r6)
 908b2cc:	98800117 	ldw	r2,4(r19)
 908b2d0:	28c00117 	ldw	r3,4(r5)
 908b2d4:	3027883a 	mov	r19,r6
 908b2d8:	10c4703a 	and	r2,r2,r3
 908b2dc:	30800115 	stw	r2,4(r6)
 908b2e0:	003fe506 	br	908b278 <_fpadd_parts+0x1c8>
 908b2e4:	1dc02616 	blt	r3,r23,908b380 <_fpadd_parts+0x2d0>
 908b2e8:	0023883a 	mov	r17,zero
 908b2ec:	182f883a 	mov	r23,r3
 908b2f0:	0025883a 	mov	r18,zero
 908b2f4:	003fa806 	br	908b198 <_fpadd_parts+0xe8>
 908b2f8:	a827883a 	mov	r19,r21
 908b2fc:	003fde06 	br	908b278 <_fpadd_parts+0x1c8>
 908b300:	01800044 	movi	r6,1
 908b304:	500497fa 	slli	r2,r10,31
 908b308:	4808d07a 	srli	r4,r9,1
 908b30c:	518ad83a 	srl	r5,r10,r6
 908b310:	a2000217 	ldw	r8,8(r20)
 908b314:	1108b03a 	or	r4,r2,r4
 908b318:	0007883a 	mov	r3,zero
 908b31c:	4984703a 	and	r2,r9,r6
 908b320:	208cb03a 	or	r6,r4,r2
 908b324:	28ceb03a 	or	r7,r5,r3
 908b328:	42000044 	addi	r8,r8,1
 908b32c:	a027883a 	mov	r19,r20
 908b330:	a1c00415 	stw	r7,16(r20)
 908b334:	a2000215 	stw	r8,8(r20)
 908b338:	a1800315 	stw	r6,12(r20)
 908b33c:	003fce06 	br	908b278 <_fpadd_parts+0x1c8>
 908b340:	8bc5c83a 	sub	r2,r17,r15
 908b344:	8889803a 	cmpltu	r4,r17,r2
 908b348:	9407c83a 	sub	r3,r18,r16
 908b34c:	1909c83a 	sub	r4,r3,r4
 908b350:	100d883a 	mov	r6,r2
 908b354:	200f883a 	mov	r7,r4
 908b358:	003f9906 	br	908b1c0 <_fpadd_parts+0x110>
 908b35c:	7c45883a 	add	r2,r15,r17
 908b360:	13c9803a 	cmpltu	r4,r2,r15
 908b364:	8487883a 	add	r3,r16,r18
 908b368:	20c9883a 	add	r4,r4,r3
 908b36c:	a1400115 	stw	r5,4(r20)
 908b370:	a5c00215 	stw	r23,8(r20)
 908b374:	a0800315 	stw	r2,12(r20)
 908b378:	a1000415 	stw	r4,16(r20)
 908b37c:	003fb606 	br	908b258 <_fpadd_parts+0x1a8>
 908b380:	001f883a 	mov	r15,zero
 908b384:	0021883a 	mov	r16,zero
 908b388:	003f8306 	br	908b198 <_fpadd_parts+0xe8>
 908b38c:	018dc83a 	sub	r6,zero,r6
 908b390:	003f6706 	br	908b130 <_fpadd_parts+0x80>
 908b394:	00bfff84 	movi	r2,-2
 908b398:	117faf36 	bltu	r2,r5,908b258 <_fpadd_parts+0x1a8>
 908b39c:	003f9806 	br	908b200 <_fpadd_parts+0x150>
 908b3a0:	0005883a 	mov	r2,zero
 908b3a4:	1189c83a 	sub	r4,r2,r6
 908b3a8:	1105803a 	cmpltu	r2,r2,r4
 908b3ac:	01cbc83a 	sub	r5,zero,r7
 908b3b0:	2885c83a 	sub	r2,r5,r2
 908b3b4:	01800044 	movi	r6,1
 908b3b8:	a1800115 	stw	r6,4(r20)
 908b3bc:	a5c00215 	stw	r23,8(r20)
 908b3c0:	a1000315 	stw	r4,12(r20)
 908b3c4:	a0800415 	stw	r2,16(r20)
 908b3c8:	003f8206 	br	908b1d4 <_fpadd_parts+0x124>
 908b3cc:	203f7226 	beq	r4,zero,908b198 <_fpadd_parts+0xe8>
 908b3d0:	35bff804 	addi	r22,r6,-32
 908b3d4:	b9af883a 	add	r23,r23,r6
 908b3d8:	b0003116 	blt	r22,zero,908b4a0 <_fpadd_parts+0x3f0>
 908b3dc:	959ad83a 	srl	r13,r18,r22
 908b3e0:	001d883a 	mov	r14,zero
 908b3e4:	000f883a 	mov	r7,zero
 908b3e8:	01000044 	movi	r4,1
 908b3ec:	0011883a 	mov	r8,zero
 908b3f0:	b0002516 	blt	r22,zero,908b488 <_fpadd_parts+0x3d8>
 908b3f4:	2594983a 	sll	r10,r4,r22
 908b3f8:	0013883a 	mov	r9,zero
 908b3fc:	00bfffc4 	movi	r2,-1
 908b400:	4889883a 	add	r4,r9,r2
 908b404:	508b883a 	add	r5,r10,r2
 908b408:	224d803a 	cmpltu	r6,r4,r9
 908b40c:	314b883a 	add	r5,r6,r5
 908b410:	8904703a 	and	r2,r17,r4
 908b414:	9146703a 	and	r3,r18,r5
 908b418:	10c4b03a 	or	r2,r2,r3
 908b41c:	10000226 	beq	r2,zero,908b428 <_fpadd_parts+0x378>
 908b420:	01c00044 	movi	r7,1
 908b424:	0011883a 	mov	r8,zero
 908b428:	69e2b03a 	or	r17,r13,r7
 908b42c:	7224b03a 	or	r18,r14,r8
 908b430:	003f5906 	br	908b198 <_fpadd_parts+0xe8>
 908b434:	8407883a 	add	r3,r16,r16
 908b438:	008007c4 	movi	r2,31
 908b43c:	1185c83a 	sub	r2,r2,r6
 908b440:	1886983a 	sll	r3,r3,r2
 908b444:	7996d83a 	srl	r11,r15,r6
 908b448:	8198d83a 	srl	r12,r16,r6
 908b44c:	1ad6b03a 	or	r11,r3,r11
 908b450:	003f3e06 	br	908b14c <_fpadd_parts+0x9c>
 908b454:	2006d07a 	srli	r3,r4,1
 908b458:	008007c4 	movi	r2,31
 908b45c:	1185c83a 	sub	r2,r2,r6
 908b460:	1890d83a 	srl	r8,r3,r2
 908b464:	218e983a 	sll	r7,r4,r6
 908b468:	003f3e06 	br	908b164 <_fpadd_parts+0xb4>
 908b46c:	113f821e 	bne	r2,r4,908b278 <_fpadd_parts+0x1c8>
 908b470:	28c00117 	ldw	r3,4(r5)
 908b474:	98800117 	ldw	r2,4(r19)
 908b478:	10ff7f26 	beq	r2,r3,908b278 <_fpadd_parts+0x1c8>
 908b47c:	04c24374 	movhi	r19,2317
 908b480:	9cf2e604 	addi	r19,r19,-13416
 908b484:	003f7c06 	br	908b278 <_fpadd_parts+0x1c8>
 908b488:	2006d07a 	srli	r3,r4,1
 908b48c:	008007c4 	movi	r2,31
 908b490:	1185c83a 	sub	r2,r2,r6
 908b494:	1894d83a 	srl	r10,r3,r2
 908b498:	2192983a 	sll	r9,r4,r6
 908b49c:	003fd706 	br	908b3fc <_fpadd_parts+0x34c>
 908b4a0:	9487883a 	add	r3,r18,r18
 908b4a4:	008007c4 	movi	r2,31
 908b4a8:	1185c83a 	sub	r2,r2,r6
 908b4ac:	1886983a 	sll	r3,r3,r2
 908b4b0:	899ad83a 	srl	r13,r17,r6
 908b4b4:	919cd83a 	srl	r14,r18,r6
 908b4b8:	1b5ab03a 	or	r13,r3,r13
 908b4bc:	003fc906 	br	908b3e4 <_fpadd_parts+0x334>

0908b4c0 <__subdf3>:
 908b4c0:	deffea04 	addi	sp,sp,-88
 908b4c4:	dcc01415 	stw	r19,80(sp)
 908b4c8:	dcc00404 	addi	r19,sp,16
 908b4cc:	2011883a 	mov	r8,r4
 908b4d0:	2813883a 	mov	r9,r5
 908b4d4:	dc401315 	stw	r17,76(sp)
 908b4d8:	d809883a 	mov	r4,sp
 908b4dc:	980b883a 	mov	r5,r19
 908b4e0:	dc400904 	addi	r17,sp,36
 908b4e4:	dfc01515 	stw	ra,84(sp)
 908b4e8:	da400115 	stw	r9,4(sp)
 908b4ec:	d9c00315 	stw	r7,12(sp)
 908b4f0:	da000015 	stw	r8,0(sp)
 908b4f4:	d9800215 	stw	r6,8(sp)
 908b4f8:	908c6ac0 	call	908c6ac <__unpack_d>
 908b4fc:	d9000204 	addi	r4,sp,8
 908b500:	880b883a 	mov	r5,r17
 908b504:	908c6ac0 	call	908c6ac <__unpack_d>
 908b508:	d8800a17 	ldw	r2,40(sp)
 908b50c:	880b883a 	mov	r5,r17
 908b510:	9809883a 	mov	r4,r19
 908b514:	d9800e04 	addi	r6,sp,56
 908b518:	1080005c 	xori	r2,r2,1
 908b51c:	d8800a15 	stw	r2,40(sp)
 908b520:	908b0b00 	call	908b0b0 <_fpadd_parts>
 908b524:	1009883a 	mov	r4,r2
 908b528:	908c3980 	call	908c398 <__pack_d>
 908b52c:	dfc01517 	ldw	ra,84(sp)
 908b530:	dcc01417 	ldw	r19,80(sp)
 908b534:	dc401317 	ldw	r17,76(sp)
 908b538:	dec01604 	addi	sp,sp,88
 908b53c:	f800283a 	ret

0908b540 <__adddf3>:
 908b540:	deffea04 	addi	sp,sp,-88
 908b544:	dcc01415 	stw	r19,80(sp)
 908b548:	dcc00404 	addi	r19,sp,16
 908b54c:	2011883a 	mov	r8,r4
 908b550:	2813883a 	mov	r9,r5
 908b554:	dc401315 	stw	r17,76(sp)
 908b558:	d809883a 	mov	r4,sp
 908b55c:	980b883a 	mov	r5,r19
 908b560:	dc400904 	addi	r17,sp,36
 908b564:	dfc01515 	stw	ra,84(sp)
 908b568:	da400115 	stw	r9,4(sp)
 908b56c:	d9c00315 	stw	r7,12(sp)
 908b570:	da000015 	stw	r8,0(sp)
 908b574:	d9800215 	stw	r6,8(sp)
 908b578:	908c6ac0 	call	908c6ac <__unpack_d>
 908b57c:	d9000204 	addi	r4,sp,8
 908b580:	880b883a 	mov	r5,r17
 908b584:	908c6ac0 	call	908c6ac <__unpack_d>
 908b588:	d9800e04 	addi	r6,sp,56
 908b58c:	9809883a 	mov	r4,r19
 908b590:	880b883a 	mov	r5,r17
 908b594:	908b0b00 	call	908b0b0 <_fpadd_parts>
 908b598:	1009883a 	mov	r4,r2
 908b59c:	908c3980 	call	908c398 <__pack_d>
 908b5a0:	dfc01517 	ldw	ra,84(sp)
 908b5a4:	dcc01417 	ldw	r19,80(sp)
 908b5a8:	dc401317 	ldw	r17,76(sp)
 908b5ac:	dec01604 	addi	sp,sp,88
 908b5b0:	f800283a 	ret

0908b5b4 <__muldf3>:
 908b5b4:	deffdd04 	addi	sp,sp,-140
 908b5b8:	df002115 	stw	fp,132(sp)
 908b5bc:	df000404 	addi	fp,sp,16
 908b5c0:	2011883a 	mov	r8,r4
 908b5c4:	2813883a 	mov	r9,r5
 908b5c8:	d809883a 	mov	r4,sp
 908b5cc:	e00b883a 	mov	r5,fp
 908b5d0:	dfc02215 	stw	ra,136(sp)
 908b5d4:	da400115 	stw	r9,4(sp)
 908b5d8:	d9c00315 	stw	r7,12(sp)
 908b5dc:	da000015 	stw	r8,0(sp)
 908b5e0:	d9800215 	stw	r6,8(sp)
 908b5e4:	ddc02015 	stw	r23,128(sp)
 908b5e8:	dd801f15 	stw	r22,124(sp)
 908b5ec:	dd401e15 	stw	r21,120(sp)
 908b5f0:	dd001d15 	stw	r20,116(sp)
 908b5f4:	dcc01c15 	stw	r19,112(sp)
 908b5f8:	dc801b15 	stw	r18,108(sp)
 908b5fc:	dc401a15 	stw	r17,104(sp)
 908b600:	dc001915 	stw	r16,100(sp)
 908b604:	908c6ac0 	call	908c6ac <__unpack_d>
 908b608:	d9000204 	addi	r4,sp,8
 908b60c:	d9400904 	addi	r5,sp,36
 908b610:	908c6ac0 	call	908c6ac <__unpack_d>
 908b614:	d9000417 	ldw	r4,16(sp)
 908b618:	00800044 	movi	r2,1
 908b61c:	1100102e 	bgeu	r2,r4,908b660 <__muldf3+0xac>
 908b620:	d8c00917 	ldw	r3,36(sp)
 908b624:	10c0062e 	bgeu	r2,r3,908b640 <__muldf3+0x8c>
 908b628:	00800104 	movi	r2,4
 908b62c:	20800a26 	beq	r4,r2,908b658 <__muldf3+0xa4>
 908b630:	1880c826 	beq	r3,r2,908b954 <__muldf3+0x3a0>
 908b634:	00800084 	movi	r2,2
 908b638:	20800926 	beq	r4,r2,908b660 <__muldf3+0xac>
 908b63c:	18801a1e 	bne	r3,r2,908b6a8 <__muldf3+0xf4>
 908b640:	d8c00a17 	ldw	r3,40(sp)
 908b644:	d8800517 	ldw	r2,20(sp)
 908b648:	d9000904 	addi	r4,sp,36
 908b64c:	10c4c03a 	cmpne	r2,r2,r3
 908b650:	d8800a15 	stw	r2,40(sp)
 908b654:	00000706 	br	908b674 <__muldf3+0xc0>
 908b658:	00800084 	movi	r2,2
 908b65c:	1880bf26 	beq	r3,r2,908b95c <__muldf3+0x3a8>
 908b660:	d8800517 	ldw	r2,20(sp)
 908b664:	d8c00a17 	ldw	r3,40(sp)
 908b668:	e009883a 	mov	r4,fp
 908b66c:	10c4c03a 	cmpne	r2,r2,r3
 908b670:	d8800515 	stw	r2,20(sp)
 908b674:	908c3980 	call	908c398 <__pack_d>
 908b678:	dfc02217 	ldw	ra,136(sp)
 908b67c:	df002117 	ldw	fp,132(sp)
 908b680:	ddc02017 	ldw	r23,128(sp)
 908b684:	dd801f17 	ldw	r22,124(sp)
 908b688:	dd401e17 	ldw	r21,120(sp)
 908b68c:	dd001d17 	ldw	r20,116(sp)
 908b690:	dcc01c17 	ldw	r19,112(sp)
 908b694:	dc801b17 	ldw	r18,108(sp)
 908b698:	dc401a17 	ldw	r17,104(sp)
 908b69c:	dc001917 	ldw	r16,100(sp)
 908b6a0:	dec02304 	addi	sp,sp,140
 908b6a4:	f800283a 	ret
 908b6a8:	db000c17 	ldw	r12,48(sp)
 908b6ac:	db800717 	ldw	r14,28(sp)
 908b6b0:	dbc00817 	ldw	r15,32(sp)
 908b6b4:	db400d17 	ldw	r13,52(sp)
 908b6b8:	6009883a 	mov	r4,r12
 908b6bc:	000d883a 	mov	r6,zero
 908b6c0:	0011883a 	mov	r8,zero
 908b6c4:	000b883a 	mov	r5,zero
 908b6c8:	0007883a 	mov	r3,zero
 908b6cc:	0019883a 	mov	r12,zero
 908b6d0:	4393383a 	mul	r9,r8,r14
 908b6d4:	d9801415 	stw	r6,80(sp)
 908b6d8:	6111383a 	mul	r8,r12,r4
 908b6dc:	d9801615 	stw	r6,88(sp)
 908b6e0:	1b4f383a 	mul	r7,r3,r13
 908b6e4:	2bcd383a 	mul	r6,r5,r15
 908b6e8:	7361383a 	mul	r16,r14,r13
 908b6ec:	23e5383a 	mul	r18,r4,r15
 908b6f0:	7362383a 	mulxuu	r17,r14,r13
 908b6f4:	23e6383a 	mulxuu	r19,r4,r15
 908b6f8:	3a4f883a 	add	r7,r7,r9
 908b6fc:	320d883a 	add	r6,r6,r8
 908b700:	3c63883a 	add	r17,r7,r17
 908b704:	34e7883a 	add	r19,r6,r19
 908b708:	8495883a 	add	r10,r16,r18
 908b70c:	23aa383a 	mulxuu	r21,r4,r14
 908b710:	540f803a 	cmpltu	r7,r10,r16
 908b714:	8cd7883a 	add	r11,r17,r19
 908b718:	3acf883a 	add	r7,r7,r11
 908b71c:	4a0d883a 	add	r6,r9,r8
 908b720:	db401315 	stw	r13,76(sp)
 908b724:	dbc01515 	stw	r15,84(sp)
 908b728:	23a9383a 	mul	r20,r4,r14
 908b72c:	da801715 	stw	r10,92(sp)
 908b730:	d9c01815 	stw	r7,96(sp)
 908b734:	356b883a 	add	r21,r6,r21
 908b738:	3c40682e 	bgeu	r7,r17,908b8dc <__muldf3+0x328>
 908b73c:	000f883a 	mov	r7,zero
 908b740:	02000044 	movi	r8,1
 908b744:	d9401717 	ldw	r5,92(sp)
 908b748:	0009883a 	mov	r4,zero
 908b74c:	a105883a 	add	r2,r20,r4
 908b750:	150d803a 	cmpltu	r6,r2,r20
 908b754:	a947883a 	add	r3,r21,r5
 908b758:	30cd883a 	add	r6,r6,r3
 908b75c:	101f883a 	mov	r15,r2
 908b760:	3021883a 	mov	r16,r6
 908b764:	35406236 	bltu	r6,r21,908b8f0 <__muldf3+0x33c>
 908b768:	a9806026 	beq	r21,r6,908b8ec <__muldf3+0x338>
 908b76c:	d9801317 	ldw	r6,76(sp)
 908b770:	db001517 	ldw	r12,84(sp)
 908b774:	d8c01417 	ldw	r3,80(sp)
 908b778:	d9401617 	ldw	r5,88(sp)
 908b77c:	6009883a 	mov	r4,r12
 908b780:	1b05383a 	mul	r2,r3,r12
 908b784:	2987383a 	mul	r3,r5,r6
 908b788:	332d383a 	mul	r22,r6,r12
 908b78c:	312e383a 	mulxuu	r23,r6,r4
 908b790:	d9801817 	ldw	r6,96(sp)
 908b794:	10c5883a 	add	r2,r2,r3
 908b798:	15ef883a 	add	r23,r2,r23
 908b79c:	000b883a 	mov	r5,zero
 908b7a0:	b185883a 	add	r2,r22,r6
 908b7a4:	158d803a 	cmpltu	r6,r2,r22
 908b7a8:	b947883a 	add	r3,r23,r5
 908b7ac:	30c7883a 	add	r3,r6,r3
 908b7b0:	40cb883a 	add	r5,r8,r3
 908b7b4:	d8c00617 	ldw	r3,24(sp)
 908b7b8:	3889883a 	add	r4,r7,r2
 908b7bc:	d8800b17 	ldw	r2,44(sp)
 908b7c0:	18c00104 	addi	r3,r3,4
 908b7c4:	21cd803a 	cmpltu	r6,r4,r7
 908b7c8:	10c7883a 	add	r3,r2,r3
 908b7cc:	2013883a 	mov	r9,r4
 908b7d0:	d8800a17 	ldw	r2,40(sp)
 908b7d4:	d9000517 	ldw	r4,20(sp)
 908b7d8:	314d883a 	add	r6,r6,r5
 908b7dc:	3015883a 	mov	r10,r6
 908b7e0:	2088c03a 	cmpne	r4,r4,r2
 908b7e4:	00880034 	movhi	r2,8192
 908b7e8:	10bfffc4 	addi	r2,r2,-1
 908b7ec:	d9000f15 	stw	r4,60(sp)
 908b7f0:	d8c01015 	stw	r3,64(sp)
 908b7f4:	1180162e 	bgeu	r2,r6,908b850 <__muldf3+0x29c>
 908b7f8:	1811883a 	mov	r8,r3
 908b7fc:	1023883a 	mov	r17,r2
 908b800:	800497fa 	slli	r2,r16,31
 908b804:	7816d07a 	srli	r11,r15,1
 908b808:	500697fa 	slli	r3,r10,31
 908b80c:	480cd07a 	srli	r6,r9,1
 908b810:	500ed07a 	srli	r7,r10,1
 908b814:	12d6b03a 	or	r11,r2,r11
 908b818:	00800044 	movi	r2,1
 908b81c:	198cb03a 	or	r6,r3,r6
 908b820:	4888703a 	and	r4,r9,r2
 908b824:	8018d07a 	srli	r12,r16,1
 908b828:	001b883a 	mov	r13,zero
 908b82c:	03a00034 	movhi	r14,32768
 908b830:	3013883a 	mov	r9,r6
 908b834:	3815883a 	mov	r10,r7
 908b838:	4091883a 	add	r8,r8,r2
 908b83c:	20000226 	beq	r4,zero,908b848 <__muldf3+0x294>
 908b840:	5b5eb03a 	or	r15,r11,r13
 908b844:	63a0b03a 	or	r16,r12,r14
 908b848:	8abfed36 	bltu	r17,r10,908b800 <__muldf3+0x24c>
 908b84c:	da001015 	stw	r8,64(sp)
 908b850:	00840034 	movhi	r2,4096
 908b854:	10bfffc4 	addi	r2,r2,-1
 908b858:	12801436 	bltu	r2,r10,908b8ac <__muldf3+0x2f8>
 908b85c:	da001017 	ldw	r8,64(sp)
 908b860:	1023883a 	mov	r17,r2
 908b864:	4a45883a 	add	r2,r9,r9
 908b868:	124d803a 	cmpltu	r6,r2,r9
 908b86c:	5287883a 	add	r3,r10,r10
 908b870:	7bd7883a 	add	r11,r15,r15
 908b874:	5bcf803a 	cmpltu	r7,r11,r15
 908b878:	8419883a 	add	r12,r16,r16
 908b87c:	01000044 	movi	r4,1
 908b880:	30cd883a 	add	r6,r6,r3
 908b884:	3b0f883a 	add	r7,r7,r12
 908b888:	423fffc4 	addi	r8,r8,-1
 908b88c:	1013883a 	mov	r9,r2
 908b890:	3015883a 	mov	r10,r6
 908b894:	111ab03a 	or	r13,r2,r4
 908b898:	80002a16 	blt	r16,zero,908b944 <__muldf3+0x390>
 908b89c:	581f883a 	mov	r15,r11
 908b8a0:	3821883a 	mov	r16,r7
 908b8a4:	8abfef2e 	bgeu	r17,r10,908b864 <__muldf3+0x2b0>
 908b8a8:	da001015 	stw	r8,64(sp)
 908b8ac:	00803fc4 	movi	r2,255
 908b8b0:	488e703a 	and	r7,r9,r2
 908b8b4:	00802004 	movi	r2,128
 908b8b8:	0007883a 	mov	r3,zero
 908b8bc:	0011883a 	mov	r8,zero
 908b8c0:	38801226 	beq	r7,r2,908b90c <__muldf3+0x358>
 908b8c4:	008000c4 	movi	r2,3
 908b8c8:	d9000e04 	addi	r4,sp,56
 908b8cc:	da801215 	stw	r10,72(sp)
 908b8d0:	d8800e15 	stw	r2,56(sp)
 908b8d4:	da401115 	stw	r9,68(sp)
 908b8d8:	003f6606 	br	908b674 <__muldf3+0xc0>
 908b8dc:	89c01b26 	beq	r17,r7,908b94c <__muldf3+0x398>
 908b8e0:	000f883a 	mov	r7,zero
 908b8e4:	0011883a 	mov	r8,zero
 908b8e8:	003f9606 	br	908b744 <__muldf3+0x190>
 908b8ec:	153f9f2e 	bgeu	r2,r20,908b76c <__muldf3+0x1b8>
 908b8f0:	00800044 	movi	r2,1
 908b8f4:	3889883a 	add	r4,r7,r2
 908b8f8:	21cd803a 	cmpltu	r6,r4,r7
 908b8fc:	320d883a 	add	r6,r6,r8
 908b900:	200f883a 	mov	r7,r4
 908b904:	3011883a 	mov	r8,r6
 908b908:	003f9806 	br	908b76c <__muldf3+0x1b8>
 908b90c:	403fed1e 	bne	r8,zero,908b8c4 <__muldf3+0x310>
 908b910:	01004004 	movi	r4,256
 908b914:	4904703a 	and	r2,r9,r4
 908b918:	10c4b03a 	or	r2,r2,r3
 908b91c:	103fe91e 	bne	r2,zero,908b8c4 <__muldf3+0x310>
 908b920:	7c04b03a 	or	r2,r15,r16
 908b924:	103fe726 	beq	r2,zero,908b8c4 <__muldf3+0x310>
 908b928:	49c5883a 	add	r2,r9,r7
 908b92c:	1251803a 	cmpltu	r8,r2,r9
 908b930:	4291883a 	add	r8,r8,r10
 908b934:	013fc004 	movi	r4,-256
 908b938:	1112703a 	and	r9,r2,r4
 908b93c:	4015883a 	mov	r10,r8
 908b940:	003fe006 	br	908b8c4 <__muldf3+0x310>
 908b944:	6813883a 	mov	r9,r13
 908b948:	003fd406 	br	908b89c <__muldf3+0x2e8>
 908b94c:	543f7b36 	bltu	r10,r16,908b73c <__muldf3+0x188>
 908b950:	003fe306 	br	908b8e0 <__muldf3+0x32c>
 908b954:	00800084 	movi	r2,2
 908b958:	20bf391e 	bne	r4,r2,908b640 <__muldf3+0x8c>
 908b95c:	01024374 	movhi	r4,2317
 908b960:	2132e604 	addi	r4,r4,-13416
 908b964:	003f4306 	br	908b674 <__muldf3+0xc0>

0908b968 <__divdf3>:
 908b968:	deffed04 	addi	sp,sp,-76
 908b96c:	dcc01115 	stw	r19,68(sp)
 908b970:	dcc00404 	addi	r19,sp,16
 908b974:	2011883a 	mov	r8,r4
 908b978:	2813883a 	mov	r9,r5
 908b97c:	dc000e15 	stw	r16,56(sp)
 908b980:	d809883a 	mov	r4,sp
 908b984:	980b883a 	mov	r5,r19
 908b988:	dc000904 	addi	r16,sp,36
 908b98c:	dfc01215 	stw	ra,72(sp)
 908b990:	da400115 	stw	r9,4(sp)
 908b994:	d9c00315 	stw	r7,12(sp)
 908b998:	da000015 	stw	r8,0(sp)
 908b99c:	d9800215 	stw	r6,8(sp)
 908b9a0:	dc801015 	stw	r18,64(sp)
 908b9a4:	dc400f15 	stw	r17,60(sp)
 908b9a8:	908c6ac0 	call	908c6ac <__unpack_d>
 908b9ac:	d9000204 	addi	r4,sp,8
 908b9b0:	800b883a 	mov	r5,r16
 908b9b4:	908c6ac0 	call	908c6ac <__unpack_d>
 908b9b8:	d9000417 	ldw	r4,16(sp)
 908b9bc:	00800044 	movi	r2,1
 908b9c0:	11000b2e 	bgeu	r2,r4,908b9f0 <__divdf3+0x88>
 908b9c4:	d9400917 	ldw	r5,36(sp)
 908b9c8:	1140762e 	bgeu	r2,r5,908bba4 <__divdf3+0x23c>
 908b9cc:	d8800517 	ldw	r2,20(sp)
 908b9d0:	d8c00a17 	ldw	r3,40(sp)
 908b9d4:	01800104 	movi	r6,4
 908b9d8:	10c4f03a 	xor	r2,r2,r3
 908b9dc:	d8800515 	stw	r2,20(sp)
 908b9e0:	21800226 	beq	r4,r6,908b9ec <__divdf3+0x84>
 908b9e4:	00800084 	movi	r2,2
 908b9e8:	2080141e 	bne	r4,r2,908ba3c <__divdf3+0xd4>
 908b9ec:	29000926 	beq	r5,r4,908ba14 <__divdf3+0xac>
 908b9f0:	9809883a 	mov	r4,r19
 908b9f4:	908c3980 	call	908c398 <__pack_d>
 908b9f8:	dfc01217 	ldw	ra,72(sp)
 908b9fc:	dcc01117 	ldw	r19,68(sp)
 908ba00:	dc801017 	ldw	r18,64(sp)
 908ba04:	dc400f17 	ldw	r17,60(sp)
 908ba08:	dc000e17 	ldw	r16,56(sp)
 908ba0c:	dec01304 	addi	sp,sp,76
 908ba10:	f800283a 	ret
 908ba14:	01024374 	movhi	r4,2317
 908ba18:	2132e604 	addi	r4,r4,-13416
 908ba1c:	908c3980 	call	908c398 <__pack_d>
 908ba20:	dfc01217 	ldw	ra,72(sp)
 908ba24:	dcc01117 	ldw	r19,68(sp)
 908ba28:	dc801017 	ldw	r18,64(sp)
 908ba2c:	dc400f17 	ldw	r17,60(sp)
 908ba30:	dc000e17 	ldw	r16,56(sp)
 908ba34:	dec01304 	addi	sp,sp,76
 908ba38:	f800283a 	ret
 908ba3c:	29805b26 	beq	r5,r6,908bbac <__divdf3+0x244>
 908ba40:	28802d26 	beq	r5,r2,908baf8 <__divdf3+0x190>
 908ba44:	d8c00617 	ldw	r3,24(sp)
 908ba48:	d8800b17 	ldw	r2,44(sp)
 908ba4c:	d9c00817 	ldw	r7,32(sp)
 908ba50:	dc400d17 	ldw	r17,52(sp)
 908ba54:	188bc83a 	sub	r5,r3,r2
 908ba58:	d9800717 	ldw	r6,28(sp)
 908ba5c:	dc000c17 	ldw	r16,48(sp)
 908ba60:	d9400615 	stw	r5,24(sp)
 908ba64:	3c403836 	bltu	r7,r17,908bb48 <__divdf3+0x1e0>
 908ba68:	89c03626 	beq	r17,r7,908bb44 <__divdf3+0x1dc>
 908ba6c:	0015883a 	mov	r10,zero
 908ba70:	001d883a 	mov	r14,zero
 908ba74:	02c40034 	movhi	r11,4096
 908ba78:	001f883a 	mov	r15,zero
 908ba7c:	003f883a 	mov	ra,zero
 908ba80:	04800f44 	movi	r18,61
 908ba84:	00000f06 	br	908bac4 <__divdf3+0x15c>
 908ba88:	601d883a 	mov	r14,r12
 908ba8c:	681f883a 	mov	r15,r13
 908ba90:	400d883a 	mov	r6,r8
 908ba94:	100f883a 	mov	r7,r2
 908ba98:	3191883a 	add	r8,r6,r6
 908ba9c:	5808d07a 	srli	r4,r11,1
 908baa0:	4185803a 	cmpltu	r2,r8,r6
 908baa4:	39d3883a 	add	r9,r7,r7
 908baa8:	28c6b03a 	or	r3,r5,r3
 908baac:	1245883a 	add	r2,r2,r9
 908bab0:	1815883a 	mov	r10,r3
 908bab4:	2017883a 	mov	r11,r4
 908bab8:	400d883a 	mov	r6,r8
 908babc:	100f883a 	mov	r7,r2
 908bac0:	fc801726 	beq	ra,r18,908bb20 <__divdf3+0x1b8>
 908bac4:	580a97fa 	slli	r5,r11,31
 908bac8:	5006d07a 	srli	r3,r10,1
 908bacc:	ffc00044 	addi	ra,ra,1
 908bad0:	3c7ff136 	bltu	r7,r17,908ba98 <__divdf3+0x130>
 908bad4:	3411c83a 	sub	r8,r6,r16
 908bad8:	3205803a 	cmpltu	r2,r6,r8
 908badc:	3c53c83a 	sub	r9,r7,r17
 908bae0:	7298b03a 	or	r12,r14,r10
 908bae4:	7adab03a 	or	r13,r15,r11
 908bae8:	4885c83a 	sub	r2,r9,r2
 908baec:	89ffe61e 	bne	r17,r7,908ba88 <__divdf3+0x120>
 908baf0:	343fe936 	bltu	r6,r16,908ba98 <__divdf3+0x130>
 908baf4:	003fe406 	br	908ba88 <__divdf3+0x120>
 908baf8:	9809883a 	mov	r4,r19
 908bafc:	d9800415 	stw	r6,16(sp)
 908bb00:	908c3980 	call	908c398 <__pack_d>
 908bb04:	dfc01217 	ldw	ra,72(sp)
 908bb08:	dcc01117 	ldw	r19,68(sp)
 908bb0c:	dc801017 	ldw	r18,64(sp)
 908bb10:	dc400f17 	ldw	r17,60(sp)
 908bb14:	dc000e17 	ldw	r16,56(sp)
 908bb18:	dec01304 	addi	sp,sp,76
 908bb1c:	f800283a 	ret
 908bb20:	00803fc4 	movi	r2,255
 908bb24:	7090703a 	and	r8,r14,r2
 908bb28:	00802004 	movi	r2,128
 908bb2c:	0007883a 	mov	r3,zero
 908bb30:	0013883a 	mov	r9,zero
 908bb34:	40800d26 	beq	r8,r2,908bb6c <__divdf3+0x204>
 908bb38:	dbc00815 	stw	r15,32(sp)
 908bb3c:	db800715 	stw	r14,28(sp)
 908bb40:	003fab06 	br	908b9f0 <__divdf3+0x88>
 908bb44:	343fc92e 	bgeu	r6,r16,908ba6c <__divdf3+0x104>
 908bb48:	3185883a 	add	r2,r6,r6
 908bb4c:	1189803a 	cmpltu	r4,r2,r6
 908bb50:	39c7883a 	add	r3,r7,r7
 908bb54:	20c9883a 	add	r4,r4,r3
 908bb58:	297fffc4 	addi	r5,r5,-1
 908bb5c:	100d883a 	mov	r6,r2
 908bb60:	200f883a 	mov	r7,r4
 908bb64:	d9400615 	stw	r5,24(sp)
 908bb68:	003fc006 	br	908ba6c <__divdf3+0x104>
 908bb6c:	483ff21e 	bne	r9,zero,908bb38 <__divdf3+0x1d0>
 908bb70:	01004004 	movi	r4,256
 908bb74:	7104703a 	and	r2,r14,r4
 908bb78:	10c4b03a 	or	r2,r2,r3
 908bb7c:	103fee1e 	bne	r2,zero,908bb38 <__divdf3+0x1d0>
 908bb80:	31c4b03a 	or	r2,r6,r7
 908bb84:	103fec26 	beq	r2,zero,908bb38 <__divdf3+0x1d0>
 908bb88:	7205883a 	add	r2,r14,r8
 908bb8c:	1391803a 	cmpltu	r8,r2,r14
 908bb90:	43d1883a 	add	r8,r8,r15
 908bb94:	013fc004 	movi	r4,-256
 908bb98:	111c703a 	and	r14,r2,r4
 908bb9c:	401f883a 	mov	r15,r8
 908bba0:	003fe506 	br	908bb38 <__divdf3+0x1d0>
 908bba4:	8009883a 	mov	r4,r16
 908bba8:	003f9206 	br	908b9f4 <__divdf3+0x8c>
 908bbac:	9809883a 	mov	r4,r19
 908bbb0:	d8000715 	stw	zero,28(sp)
 908bbb4:	d8000815 	stw	zero,32(sp)
 908bbb8:	d8000615 	stw	zero,24(sp)
 908bbbc:	003f8d06 	br	908b9f4 <__divdf3+0x8c>

0908bbc0 <__eqdf2>:
 908bbc0:	deffef04 	addi	sp,sp,-68
 908bbc4:	dc400f15 	stw	r17,60(sp)
 908bbc8:	dc400404 	addi	r17,sp,16
 908bbcc:	2005883a 	mov	r2,r4
 908bbd0:	2807883a 	mov	r3,r5
 908bbd4:	dc000e15 	stw	r16,56(sp)
 908bbd8:	d809883a 	mov	r4,sp
 908bbdc:	880b883a 	mov	r5,r17
 908bbe0:	dc000904 	addi	r16,sp,36
 908bbe4:	d8c00115 	stw	r3,4(sp)
 908bbe8:	d8800015 	stw	r2,0(sp)
 908bbec:	d9800215 	stw	r6,8(sp)
 908bbf0:	dfc01015 	stw	ra,64(sp)
 908bbf4:	d9c00315 	stw	r7,12(sp)
 908bbf8:	908c6ac0 	call	908c6ac <__unpack_d>
 908bbfc:	d9000204 	addi	r4,sp,8
 908bc00:	800b883a 	mov	r5,r16
 908bc04:	908c6ac0 	call	908c6ac <__unpack_d>
 908bc08:	d8800417 	ldw	r2,16(sp)
 908bc0c:	00c00044 	movi	r3,1
 908bc10:	180d883a 	mov	r6,r3
 908bc14:	1880062e 	bgeu	r3,r2,908bc30 <__eqdf2+0x70>
 908bc18:	d8800917 	ldw	r2,36(sp)
 908bc1c:	8809883a 	mov	r4,r17
 908bc20:	800b883a 	mov	r5,r16
 908bc24:	1880022e 	bgeu	r3,r2,908bc30 <__eqdf2+0x70>
 908bc28:	908c7e40 	call	908c7e4 <__fpcmp_parts_d>
 908bc2c:	100d883a 	mov	r6,r2
 908bc30:	3005883a 	mov	r2,r6
 908bc34:	dfc01017 	ldw	ra,64(sp)
 908bc38:	dc400f17 	ldw	r17,60(sp)
 908bc3c:	dc000e17 	ldw	r16,56(sp)
 908bc40:	dec01104 	addi	sp,sp,68
 908bc44:	f800283a 	ret

0908bc48 <__nedf2>:
 908bc48:	deffef04 	addi	sp,sp,-68
 908bc4c:	dc400f15 	stw	r17,60(sp)
 908bc50:	dc400404 	addi	r17,sp,16
 908bc54:	2005883a 	mov	r2,r4
 908bc58:	2807883a 	mov	r3,r5
 908bc5c:	dc000e15 	stw	r16,56(sp)
 908bc60:	d809883a 	mov	r4,sp
 908bc64:	880b883a 	mov	r5,r17
 908bc68:	dc000904 	addi	r16,sp,36
 908bc6c:	d8c00115 	stw	r3,4(sp)
 908bc70:	d8800015 	stw	r2,0(sp)
 908bc74:	d9800215 	stw	r6,8(sp)
 908bc78:	dfc01015 	stw	ra,64(sp)
 908bc7c:	d9c00315 	stw	r7,12(sp)
 908bc80:	908c6ac0 	call	908c6ac <__unpack_d>
 908bc84:	d9000204 	addi	r4,sp,8
 908bc88:	800b883a 	mov	r5,r16
 908bc8c:	908c6ac0 	call	908c6ac <__unpack_d>
 908bc90:	d8800417 	ldw	r2,16(sp)
 908bc94:	00c00044 	movi	r3,1
 908bc98:	180d883a 	mov	r6,r3
 908bc9c:	1880062e 	bgeu	r3,r2,908bcb8 <__nedf2+0x70>
 908bca0:	d8800917 	ldw	r2,36(sp)
 908bca4:	8809883a 	mov	r4,r17
 908bca8:	800b883a 	mov	r5,r16
 908bcac:	1880022e 	bgeu	r3,r2,908bcb8 <__nedf2+0x70>
 908bcb0:	908c7e40 	call	908c7e4 <__fpcmp_parts_d>
 908bcb4:	100d883a 	mov	r6,r2
 908bcb8:	3005883a 	mov	r2,r6
 908bcbc:	dfc01017 	ldw	ra,64(sp)
 908bcc0:	dc400f17 	ldw	r17,60(sp)
 908bcc4:	dc000e17 	ldw	r16,56(sp)
 908bcc8:	dec01104 	addi	sp,sp,68
 908bccc:	f800283a 	ret

0908bcd0 <__gtdf2>:
 908bcd0:	deffef04 	addi	sp,sp,-68
 908bcd4:	dc400f15 	stw	r17,60(sp)
 908bcd8:	dc400404 	addi	r17,sp,16
 908bcdc:	2005883a 	mov	r2,r4
 908bce0:	2807883a 	mov	r3,r5
 908bce4:	dc000e15 	stw	r16,56(sp)
 908bce8:	d809883a 	mov	r4,sp
 908bcec:	880b883a 	mov	r5,r17
 908bcf0:	dc000904 	addi	r16,sp,36
 908bcf4:	d8c00115 	stw	r3,4(sp)
 908bcf8:	d8800015 	stw	r2,0(sp)
 908bcfc:	d9800215 	stw	r6,8(sp)
 908bd00:	dfc01015 	stw	ra,64(sp)
 908bd04:	d9c00315 	stw	r7,12(sp)
 908bd08:	908c6ac0 	call	908c6ac <__unpack_d>
 908bd0c:	d9000204 	addi	r4,sp,8
 908bd10:	800b883a 	mov	r5,r16
 908bd14:	908c6ac0 	call	908c6ac <__unpack_d>
 908bd18:	d8800417 	ldw	r2,16(sp)
 908bd1c:	00c00044 	movi	r3,1
 908bd20:	01bfffc4 	movi	r6,-1
 908bd24:	1880062e 	bgeu	r3,r2,908bd40 <__gtdf2+0x70>
 908bd28:	d8800917 	ldw	r2,36(sp)
 908bd2c:	8809883a 	mov	r4,r17
 908bd30:	800b883a 	mov	r5,r16
 908bd34:	1880022e 	bgeu	r3,r2,908bd40 <__gtdf2+0x70>
 908bd38:	908c7e40 	call	908c7e4 <__fpcmp_parts_d>
 908bd3c:	100d883a 	mov	r6,r2
 908bd40:	3005883a 	mov	r2,r6
 908bd44:	dfc01017 	ldw	ra,64(sp)
 908bd48:	dc400f17 	ldw	r17,60(sp)
 908bd4c:	dc000e17 	ldw	r16,56(sp)
 908bd50:	dec01104 	addi	sp,sp,68
 908bd54:	f800283a 	ret

0908bd58 <__gedf2>:
 908bd58:	deffef04 	addi	sp,sp,-68
 908bd5c:	dc400f15 	stw	r17,60(sp)
 908bd60:	dc400404 	addi	r17,sp,16
 908bd64:	2005883a 	mov	r2,r4
 908bd68:	2807883a 	mov	r3,r5
 908bd6c:	dc000e15 	stw	r16,56(sp)
 908bd70:	d809883a 	mov	r4,sp
 908bd74:	880b883a 	mov	r5,r17
 908bd78:	dc000904 	addi	r16,sp,36
 908bd7c:	d8c00115 	stw	r3,4(sp)
 908bd80:	d8800015 	stw	r2,0(sp)
 908bd84:	d9800215 	stw	r6,8(sp)
 908bd88:	dfc01015 	stw	ra,64(sp)
 908bd8c:	d9c00315 	stw	r7,12(sp)
 908bd90:	908c6ac0 	call	908c6ac <__unpack_d>
 908bd94:	d9000204 	addi	r4,sp,8
 908bd98:	800b883a 	mov	r5,r16
 908bd9c:	908c6ac0 	call	908c6ac <__unpack_d>
 908bda0:	d8800417 	ldw	r2,16(sp)
 908bda4:	00c00044 	movi	r3,1
 908bda8:	01bfffc4 	movi	r6,-1
 908bdac:	1880062e 	bgeu	r3,r2,908bdc8 <__gedf2+0x70>
 908bdb0:	d8800917 	ldw	r2,36(sp)
 908bdb4:	8809883a 	mov	r4,r17
 908bdb8:	800b883a 	mov	r5,r16
 908bdbc:	1880022e 	bgeu	r3,r2,908bdc8 <__gedf2+0x70>
 908bdc0:	908c7e40 	call	908c7e4 <__fpcmp_parts_d>
 908bdc4:	100d883a 	mov	r6,r2
 908bdc8:	3005883a 	mov	r2,r6
 908bdcc:	dfc01017 	ldw	ra,64(sp)
 908bdd0:	dc400f17 	ldw	r17,60(sp)
 908bdd4:	dc000e17 	ldw	r16,56(sp)
 908bdd8:	dec01104 	addi	sp,sp,68
 908bddc:	f800283a 	ret

0908bde0 <__ltdf2>:
 908bde0:	deffef04 	addi	sp,sp,-68
 908bde4:	dc400f15 	stw	r17,60(sp)
 908bde8:	dc400404 	addi	r17,sp,16
 908bdec:	2005883a 	mov	r2,r4
 908bdf0:	2807883a 	mov	r3,r5
 908bdf4:	dc000e15 	stw	r16,56(sp)
 908bdf8:	d809883a 	mov	r4,sp
 908bdfc:	880b883a 	mov	r5,r17
 908be00:	dc000904 	addi	r16,sp,36
 908be04:	d8c00115 	stw	r3,4(sp)
 908be08:	d8800015 	stw	r2,0(sp)
 908be0c:	d9800215 	stw	r6,8(sp)
 908be10:	dfc01015 	stw	ra,64(sp)
 908be14:	d9c00315 	stw	r7,12(sp)
 908be18:	908c6ac0 	call	908c6ac <__unpack_d>
 908be1c:	d9000204 	addi	r4,sp,8
 908be20:	800b883a 	mov	r5,r16
 908be24:	908c6ac0 	call	908c6ac <__unpack_d>
 908be28:	d8800417 	ldw	r2,16(sp)
 908be2c:	00c00044 	movi	r3,1
 908be30:	180d883a 	mov	r6,r3
 908be34:	1880062e 	bgeu	r3,r2,908be50 <__ltdf2+0x70>
 908be38:	d8800917 	ldw	r2,36(sp)
 908be3c:	8809883a 	mov	r4,r17
 908be40:	800b883a 	mov	r5,r16
 908be44:	1880022e 	bgeu	r3,r2,908be50 <__ltdf2+0x70>
 908be48:	908c7e40 	call	908c7e4 <__fpcmp_parts_d>
 908be4c:	100d883a 	mov	r6,r2
 908be50:	3005883a 	mov	r2,r6
 908be54:	dfc01017 	ldw	ra,64(sp)
 908be58:	dc400f17 	ldw	r17,60(sp)
 908be5c:	dc000e17 	ldw	r16,56(sp)
 908be60:	dec01104 	addi	sp,sp,68
 908be64:	f800283a 	ret

0908be68 <__floatsidf>:
 908be68:	2006d7fa 	srli	r3,r4,31
 908be6c:	defff604 	addi	sp,sp,-40
 908be70:	008000c4 	movi	r2,3
 908be74:	dfc00915 	stw	ra,36(sp)
 908be78:	dcc00815 	stw	r19,32(sp)
 908be7c:	dc800715 	stw	r18,28(sp)
 908be80:	dc400615 	stw	r17,24(sp)
 908be84:	dc000515 	stw	r16,20(sp)
 908be88:	d8800015 	stw	r2,0(sp)
 908be8c:	d8c00115 	stw	r3,4(sp)
 908be90:	20000f1e 	bne	r4,zero,908bed0 <__floatsidf+0x68>
 908be94:	00800084 	movi	r2,2
 908be98:	d8800015 	stw	r2,0(sp)
 908be9c:	d809883a 	mov	r4,sp
 908bea0:	908c3980 	call	908c398 <__pack_d>
 908bea4:	1009883a 	mov	r4,r2
 908bea8:	180b883a 	mov	r5,r3
 908beac:	2005883a 	mov	r2,r4
 908beb0:	2807883a 	mov	r3,r5
 908beb4:	dfc00917 	ldw	ra,36(sp)
 908beb8:	dcc00817 	ldw	r19,32(sp)
 908bebc:	dc800717 	ldw	r18,28(sp)
 908bec0:	dc400617 	ldw	r17,24(sp)
 908bec4:	dc000517 	ldw	r16,20(sp)
 908bec8:	dec00a04 	addi	sp,sp,40
 908becc:	f800283a 	ret
 908bed0:	00800f04 	movi	r2,60
 908bed4:	1807003a 	cmpeq	r3,r3,zero
 908bed8:	d8800215 	stw	r2,8(sp)
 908bedc:	18001126 	beq	r3,zero,908bf24 <__floatsidf+0xbc>
 908bee0:	0027883a 	mov	r19,zero
 908bee4:	2025883a 	mov	r18,r4
 908bee8:	d9000315 	stw	r4,12(sp)
 908beec:	dcc00415 	stw	r19,16(sp)
 908bef0:	908c3180 	call	908c318 <__clzsi2>
 908bef4:	11000744 	addi	r4,r2,29
 908bef8:	013fe80e 	bge	zero,r4,908be9c <__floatsidf+0x34>
 908befc:	10bfff44 	addi	r2,r2,-3
 908bf00:	10000c16 	blt	r2,zero,908bf34 <__floatsidf+0xcc>
 908bf04:	90a2983a 	sll	r17,r18,r2
 908bf08:	0021883a 	mov	r16,zero
 908bf0c:	d8800217 	ldw	r2,8(sp)
 908bf10:	dc400415 	stw	r17,16(sp)
 908bf14:	dc000315 	stw	r16,12(sp)
 908bf18:	1105c83a 	sub	r2,r2,r4
 908bf1c:	d8800215 	stw	r2,8(sp)
 908bf20:	003fde06 	br	908be9c <__floatsidf+0x34>
 908bf24:	00a00034 	movhi	r2,32768
 908bf28:	20800a26 	beq	r4,r2,908bf54 <__floatsidf+0xec>
 908bf2c:	0109c83a 	sub	r4,zero,r4
 908bf30:	003feb06 	br	908bee0 <__floatsidf+0x78>
 908bf34:	9006d07a 	srli	r3,r18,1
 908bf38:	008007c4 	movi	r2,31
 908bf3c:	1105c83a 	sub	r2,r2,r4
 908bf40:	1886d83a 	srl	r3,r3,r2
 908bf44:	9922983a 	sll	r17,r19,r4
 908bf48:	9120983a 	sll	r16,r18,r4
 908bf4c:	1c62b03a 	or	r17,r3,r17
 908bf50:	003fee06 	br	908bf0c <__floatsidf+0xa4>
 908bf54:	0009883a 	mov	r4,zero
 908bf58:	01707834 	movhi	r5,49632
 908bf5c:	003fd306 	br	908beac <__floatsidf+0x44>

0908bf60 <__fixdfsi>:
 908bf60:	defff804 	addi	sp,sp,-32
 908bf64:	2005883a 	mov	r2,r4
 908bf68:	2807883a 	mov	r3,r5
 908bf6c:	d809883a 	mov	r4,sp
 908bf70:	d9400204 	addi	r5,sp,8
 908bf74:	d8c00115 	stw	r3,4(sp)
 908bf78:	d8800015 	stw	r2,0(sp)
 908bf7c:	dfc00715 	stw	ra,28(sp)
 908bf80:	908c6ac0 	call	908c6ac <__unpack_d>
 908bf84:	d8c00217 	ldw	r3,8(sp)
 908bf88:	00800084 	movi	r2,2
 908bf8c:	1880051e 	bne	r3,r2,908bfa4 <__fixdfsi+0x44>
 908bf90:	0007883a 	mov	r3,zero
 908bf94:	1805883a 	mov	r2,r3
 908bf98:	dfc00717 	ldw	ra,28(sp)
 908bf9c:	dec00804 	addi	sp,sp,32
 908bfa0:	f800283a 	ret
 908bfa4:	00800044 	movi	r2,1
 908bfa8:	10fff92e 	bgeu	r2,r3,908bf90 <__fixdfsi+0x30>
 908bfac:	00800104 	movi	r2,4
 908bfb0:	18800426 	beq	r3,r2,908bfc4 <__fixdfsi+0x64>
 908bfb4:	d8c00417 	ldw	r3,16(sp)
 908bfb8:	183ff516 	blt	r3,zero,908bf90 <__fixdfsi+0x30>
 908bfbc:	00800784 	movi	r2,30
 908bfc0:	10c0080e 	bge	r2,r3,908bfe4 <__fixdfsi+0x84>
 908bfc4:	d8800317 	ldw	r2,12(sp)
 908bfc8:	1000121e 	bne	r2,zero,908c014 <__fixdfsi+0xb4>
 908bfcc:	00e00034 	movhi	r3,32768
 908bfd0:	18ffffc4 	addi	r3,r3,-1
 908bfd4:	1805883a 	mov	r2,r3
 908bfd8:	dfc00717 	ldw	ra,28(sp)
 908bfdc:	dec00804 	addi	sp,sp,32
 908bfe0:	f800283a 	ret
 908bfe4:	00800f04 	movi	r2,60
 908bfe8:	10d1c83a 	sub	r8,r2,r3
 908bfec:	40bff804 	addi	r2,r8,-32
 908bff0:	d9800517 	ldw	r6,20(sp)
 908bff4:	d9c00617 	ldw	r7,24(sp)
 908bff8:	10000816 	blt	r2,zero,908c01c <__fixdfsi+0xbc>
 908bffc:	3888d83a 	srl	r4,r7,r2
 908c000:	d8800317 	ldw	r2,12(sp)
 908c004:	2007883a 	mov	r3,r4
 908c008:	103fe226 	beq	r2,zero,908bf94 <__fixdfsi+0x34>
 908c00c:	0107c83a 	sub	r3,zero,r4
 908c010:	003fe006 	br	908bf94 <__fixdfsi+0x34>
 908c014:	00e00034 	movhi	r3,32768
 908c018:	003fde06 	br	908bf94 <__fixdfsi+0x34>
 908c01c:	39c7883a 	add	r3,r7,r7
 908c020:	008007c4 	movi	r2,31
 908c024:	1205c83a 	sub	r2,r2,r8
 908c028:	1886983a 	sll	r3,r3,r2
 908c02c:	3208d83a 	srl	r4,r6,r8
 908c030:	1908b03a 	or	r4,r3,r4
 908c034:	003ff206 	br	908c000 <__fixdfsi+0xa0>

0908c038 <__floatunsidf>:
 908c038:	defff204 	addi	sp,sp,-56
 908c03c:	dfc00d15 	stw	ra,52(sp)
 908c040:	ddc00c15 	stw	r23,48(sp)
 908c044:	dd800b15 	stw	r22,44(sp)
 908c048:	dd400a15 	stw	r21,40(sp)
 908c04c:	dd000915 	stw	r20,36(sp)
 908c050:	dcc00815 	stw	r19,32(sp)
 908c054:	dc800715 	stw	r18,28(sp)
 908c058:	dc400615 	stw	r17,24(sp)
 908c05c:	dc000515 	stw	r16,20(sp)
 908c060:	d8000115 	stw	zero,4(sp)
 908c064:	20000f1e 	bne	r4,zero,908c0a4 <__floatunsidf+0x6c>
 908c068:	00800084 	movi	r2,2
 908c06c:	d8800015 	stw	r2,0(sp)
 908c070:	d809883a 	mov	r4,sp
 908c074:	908c3980 	call	908c398 <__pack_d>
 908c078:	dfc00d17 	ldw	ra,52(sp)
 908c07c:	ddc00c17 	ldw	r23,48(sp)
 908c080:	dd800b17 	ldw	r22,44(sp)
 908c084:	dd400a17 	ldw	r21,40(sp)
 908c088:	dd000917 	ldw	r20,36(sp)
 908c08c:	dcc00817 	ldw	r19,32(sp)
 908c090:	dc800717 	ldw	r18,28(sp)
 908c094:	dc400617 	ldw	r17,24(sp)
 908c098:	dc000517 	ldw	r16,20(sp)
 908c09c:	dec00e04 	addi	sp,sp,56
 908c0a0:	f800283a 	ret
 908c0a4:	008000c4 	movi	r2,3
 908c0a8:	00c00f04 	movi	r3,60
 908c0ac:	002f883a 	mov	r23,zero
 908c0b0:	202d883a 	mov	r22,r4
 908c0b4:	d8800015 	stw	r2,0(sp)
 908c0b8:	d8c00215 	stw	r3,8(sp)
 908c0bc:	d9000315 	stw	r4,12(sp)
 908c0c0:	ddc00415 	stw	r23,16(sp)
 908c0c4:	908c3180 	call	908c318 <__clzsi2>
 908c0c8:	12400744 	addi	r9,r2,29
 908c0cc:	48000b16 	blt	r9,zero,908c0fc <__floatunsidf+0xc4>
 908c0d0:	483fe726 	beq	r9,zero,908c070 <__floatunsidf+0x38>
 908c0d4:	10bfff44 	addi	r2,r2,-3
 908c0d8:	10002e16 	blt	r2,zero,908c194 <__floatunsidf+0x15c>
 908c0dc:	b0a2983a 	sll	r17,r22,r2
 908c0e0:	0021883a 	mov	r16,zero
 908c0e4:	d8800217 	ldw	r2,8(sp)
 908c0e8:	dc400415 	stw	r17,16(sp)
 908c0ec:	dc000315 	stw	r16,12(sp)
 908c0f0:	1245c83a 	sub	r2,r2,r9
 908c0f4:	d8800215 	stw	r2,8(sp)
 908c0f8:	003fdd06 	br	908c070 <__floatunsidf+0x38>
 908c0fc:	0255c83a 	sub	r10,zero,r9
 908c100:	51bff804 	addi	r6,r10,-32
 908c104:	30001b16 	blt	r6,zero,908c174 <__floatunsidf+0x13c>
 908c108:	b9a8d83a 	srl	r20,r23,r6
 908c10c:	002b883a 	mov	r21,zero
 908c110:	000f883a 	mov	r7,zero
 908c114:	01000044 	movi	r4,1
 908c118:	0011883a 	mov	r8,zero
 908c11c:	30002516 	blt	r6,zero,908c1b4 <__floatunsidf+0x17c>
 908c120:	21a6983a 	sll	r19,r4,r6
 908c124:	0025883a 	mov	r18,zero
 908c128:	00bfffc4 	movi	r2,-1
 908c12c:	9089883a 	add	r4,r18,r2
 908c130:	988b883a 	add	r5,r19,r2
 908c134:	248d803a 	cmpltu	r6,r4,r18
 908c138:	314b883a 	add	r5,r6,r5
 908c13c:	b104703a 	and	r2,r22,r4
 908c140:	b946703a 	and	r3,r23,r5
 908c144:	10c4b03a 	or	r2,r2,r3
 908c148:	10000226 	beq	r2,zero,908c154 <__floatunsidf+0x11c>
 908c14c:	01c00044 	movi	r7,1
 908c150:	0011883a 	mov	r8,zero
 908c154:	d9000217 	ldw	r4,8(sp)
 908c158:	a1c4b03a 	or	r2,r20,r7
 908c15c:	aa06b03a 	or	r3,r21,r8
 908c160:	2249c83a 	sub	r4,r4,r9
 908c164:	d8c00415 	stw	r3,16(sp)
 908c168:	d9000215 	stw	r4,8(sp)
 908c16c:	d8800315 	stw	r2,12(sp)
 908c170:	003fbf06 	br	908c070 <__floatunsidf+0x38>
 908c174:	bdc7883a 	add	r3,r23,r23
 908c178:	008007c4 	movi	r2,31
 908c17c:	1285c83a 	sub	r2,r2,r10
 908c180:	1886983a 	sll	r3,r3,r2
 908c184:	b2a8d83a 	srl	r20,r22,r10
 908c188:	baaad83a 	srl	r21,r23,r10
 908c18c:	1d28b03a 	or	r20,r3,r20
 908c190:	003fdf06 	br	908c110 <__floatunsidf+0xd8>
 908c194:	b006d07a 	srli	r3,r22,1
 908c198:	008007c4 	movi	r2,31
 908c19c:	1245c83a 	sub	r2,r2,r9
 908c1a0:	1886d83a 	srl	r3,r3,r2
 908c1a4:	ba62983a 	sll	r17,r23,r9
 908c1a8:	b260983a 	sll	r16,r22,r9
 908c1ac:	1c62b03a 	or	r17,r3,r17
 908c1b0:	003fcc06 	br	908c0e4 <__floatunsidf+0xac>
 908c1b4:	2006d07a 	srli	r3,r4,1
 908c1b8:	008007c4 	movi	r2,31
 908c1bc:	1285c83a 	sub	r2,r2,r10
 908c1c0:	18a6d83a 	srl	r19,r3,r2
 908c1c4:	22a4983a 	sll	r18,r4,r10
 908c1c8:	003fd706 	br	908c128 <__floatunsidf+0xf0>

0908c1cc <udivmodsi4>:
 908c1cc:	29001b2e 	bgeu	r5,r4,908c23c <udivmodsi4+0x70>
 908c1d0:	28001a16 	blt	r5,zero,908c23c <udivmodsi4+0x70>
 908c1d4:	00800044 	movi	r2,1
 908c1d8:	0007883a 	mov	r3,zero
 908c1dc:	01c007c4 	movi	r7,31
 908c1e0:	00000306 	br	908c1f0 <udivmodsi4+0x24>
 908c1e4:	19c01326 	beq	r3,r7,908c234 <udivmodsi4+0x68>
 908c1e8:	18c00044 	addi	r3,r3,1
 908c1ec:	28000416 	blt	r5,zero,908c200 <udivmodsi4+0x34>
 908c1f0:	294b883a 	add	r5,r5,r5
 908c1f4:	1085883a 	add	r2,r2,r2
 908c1f8:	293ffa36 	bltu	r5,r4,908c1e4 <udivmodsi4+0x18>
 908c1fc:	10000d26 	beq	r2,zero,908c234 <udivmodsi4+0x68>
 908c200:	0007883a 	mov	r3,zero
 908c204:	21400236 	bltu	r4,r5,908c210 <udivmodsi4+0x44>
 908c208:	2149c83a 	sub	r4,r4,r5
 908c20c:	1886b03a 	or	r3,r3,r2
 908c210:	1004d07a 	srli	r2,r2,1
 908c214:	280ad07a 	srli	r5,r5,1
 908c218:	103ffa1e 	bne	r2,zero,908c204 <udivmodsi4+0x38>
 908c21c:	30000226 	beq	r6,zero,908c228 <udivmodsi4+0x5c>
 908c220:	2005883a 	mov	r2,r4
 908c224:	f800283a 	ret
 908c228:	1809883a 	mov	r4,r3
 908c22c:	2005883a 	mov	r2,r4
 908c230:	f800283a 	ret
 908c234:	0007883a 	mov	r3,zero
 908c238:	003ff806 	br	908c21c <udivmodsi4+0x50>
 908c23c:	00800044 	movi	r2,1
 908c240:	0007883a 	mov	r3,zero
 908c244:	003fef06 	br	908c204 <udivmodsi4+0x38>

0908c248 <__divsi3>:
 908c248:	defffe04 	addi	sp,sp,-8
 908c24c:	dc000015 	stw	r16,0(sp)
 908c250:	dfc00115 	stw	ra,4(sp)
 908c254:	0021883a 	mov	r16,zero
 908c258:	20000c16 	blt	r4,zero,908c28c <__divsi3+0x44>
 908c25c:	000d883a 	mov	r6,zero
 908c260:	28000e16 	blt	r5,zero,908c29c <__divsi3+0x54>
 908c264:	908c1cc0 	call	908c1cc <udivmodsi4>
 908c268:	1007883a 	mov	r3,r2
 908c26c:	8005003a 	cmpeq	r2,r16,zero
 908c270:	1000011e 	bne	r2,zero,908c278 <__divsi3+0x30>
 908c274:	00c7c83a 	sub	r3,zero,r3
 908c278:	1805883a 	mov	r2,r3
 908c27c:	dfc00117 	ldw	ra,4(sp)
 908c280:	dc000017 	ldw	r16,0(sp)
 908c284:	dec00204 	addi	sp,sp,8
 908c288:	f800283a 	ret
 908c28c:	0109c83a 	sub	r4,zero,r4
 908c290:	04000044 	movi	r16,1
 908c294:	000d883a 	mov	r6,zero
 908c298:	283ff20e 	bge	r5,zero,908c264 <__divsi3+0x1c>
 908c29c:	014bc83a 	sub	r5,zero,r5
 908c2a0:	8021003a 	cmpeq	r16,r16,zero
 908c2a4:	003fef06 	br	908c264 <__divsi3+0x1c>

0908c2a8 <__modsi3>:
 908c2a8:	deffff04 	addi	sp,sp,-4
 908c2ac:	dfc00015 	stw	ra,0(sp)
 908c2b0:	01800044 	movi	r6,1
 908c2b4:	2807883a 	mov	r3,r5
 908c2b8:	20000416 	blt	r4,zero,908c2cc <__modsi3+0x24>
 908c2bc:	28000c16 	blt	r5,zero,908c2f0 <__modsi3+0x48>
 908c2c0:	dfc00017 	ldw	ra,0(sp)
 908c2c4:	dec00104 	addi	sp,sp,4
 908c2c8:	908c1cc1 	jmpi	908c1cc <udivmodsi4>
 908c2cc:	0109c83a 	sub	r4,zero,r4
 908c2d0:	28000b16 	blt	r5,zero,908c300 <__modsi3+0x58>
 908c2d4:	180b883a 	mov	r5,r3
 908c2d8:	01800044 	movi	r6,1
 908c2dc:	908c1cc0 	call	908c1cc <udivmodsi4>
 908c2e0:	0085c83a 	sub	r2,zero,r2
 908c2e4:	dfc00017 	ldw	ra,0(sp)
 908c2e8:	dec00104 	addi	sp,sp,4
 908c2ec:	f800283a 	ret
 908c2f0:	014bc83a 	sub	r5,zero,r5
 908c2f4:	dfc00017 	ldw	ra,0(sp)
 908c2f8:	dec00104 	addi	sp,sp,4
 908c2fc:	908c1cc1 	jmpi	908c1cc <udivmodsi4>
 908c300:	0147c83a 	sub	r3,zero,r5
 908c304:	003ff306 	br	908c2d4 <__modsi3+0x2c>

0908c308 <__udivsi3>:
 908c308:	000d883a 	mov	r6,zero
 908c30c:	908c1cc1 	jmpi	908c1cc <udivmodsi4>

0908c310 <__umodsi3>:
 908c310:	01800044 	movi	r6,1
 908c314:	908c1cc1 	jmpi	908c1cc <udivmodsi4>

0908c318 <__clzsi2>:
 908c318:	00bfffd4 	movui	r2,65535
 908c31c:	11000e36 	bltu	r2,r4,908c358 <__clzsi2+0x40>
 908c320:	00803fc4 	movi	r2,255
 908c324:	01400204 	movi	r5,8
 908c328:	0007883a 	mov	r3,zero
 908c32c:	11001036 	bltu	r2,r4,908c370 <__clzsi2+0x58>
 908c330:	000b883a 	mov	r5,zero
 908c334:	20c6d83a 	srl	r3,r4,r3
 908c338:	00824374 	movhi	r2,2317
 908c33c:	10b2eb04 	addi	r2,r2,-13396
 908c340:	1887883a 	add	r3,r3,r2
 908c344:	18800003 	ldbu	r2,0(r3)
 908c348:	00c00804 	movi	r3,32
 908c34c:	2885883a 	add	r2,r5,r2
 908c350:	1885c83a 	sub	r2,r3,r2
 908c354:	f800283a 	ret
 908c358:	01400404 	movi	r5,16
 908c35c:	00804034 	movhi	r2,256
 908c360:	10bfffc4 	addi	r2,r2,-1
 908c364:	2807883a 	mov	r3,r5
 908c368:	113ff22e 	bgeu	r2,r4,908c334 <__clzsi2+0x1c>
 908c36c:	01400604 	movi	r5,24
 908c370:	2807883a 	mov	r3,r5
 908c374:	20c6d83a 	srl	r3,r4,r3
 908c378:	00824374 	movhi	r2,2317
 908c37c:	10b2eb04 	addi	r2,r2,-13396
 908c380:	1887883a 	add	r3,r3,r2
 908c384:	18800003 	ldbu	r2,0(r3)
 908c388:	00c00804 	movi	r3,32
 908c38c:	2885883a 	add	r2,r5,r2
 908c390:	1885c83a 	sub	r2,r3,r2
 908c394:	f800283a 	ret

0908c398 <__pack_d>:
 908c398:	20c00017 	ldw	r3,0(r4)
 908c39c:	defffd04 	addi	sp,sp,-12
 908c3a0:	dc000015 	stw	r16,0(sp)
 908c3a4:	dc800215 	stw	r18,8(sp)
 908c3a8:	dc400115 	stw	r17,4(sp)
 908c3ac:	00800044 	movi	r2,1
 908c3b0:	22000317 	ldw	r8,12(r4)
 908c3b4:	001f883a 	mov	r15,zero
 908c3b8:	22400417 	ldw	r9,16(r4)
 908c3bc:	24000117 	ldw	r16,4(r4)
 908c3c0:	10c0552e 	bgeu	r2,r3,908c518 <__pack_d+0x180>
 908c3c4:	00800104 	movi	r2,4
 908c3c8:	18804f26 	beq	r3,r2,908c508 <__pack_d+0x170>
 908c3cc:	00800084 	movi	r2,2
 908c3d0:	18800226 	beq	r3,r2,908c3dc <__pack_d+0x44>
 908c3d4:	4244b03a 	or	r2,r8,r9
 908c3d8:	10001a1e 	bne	r2,zero,908c444 <__pack_d+0xac>
 908c3dc:	000d883a 	mov	r6,zero
 908c3e0:	000f883a 	mov	r7,zero
 908c3e4:	0011883a 	mov	r8,zero
 908c3e8:	00800434 	movhi	r2,16
 908c3ec:	10bfffc4 	addi	r2,r2,-1
 908c3f0:	301d883a 	mov	r14,r6
 908c3f4:	3884703a 	and	r2,r7,r2
 908c3f8:	400a953a 	slli	r5,r8,20
 908c3fc:	79bffc2c 	andhi	r6,r15,65520
 908c400:	308cb03a 	or	r6,r6,r2
 908c404:	00e00434 	movhi	r3,32784
 908c408:	18ffffc4 	addi	r3,r3,-1
 908c40c:	800497fa 	slli	r2,r16,31
 908c410:	30c6703a 	and	r3,r6,r3
 908c414:	1946b03a 	or	r3,r3,r5
 908c418:	01600034 	movhi	r5,32768
 908c41c:	297fffc4 	addi	r5,r5,-1
 908c420:	194a703a 	and	r5,r3,r5
 908c424:	288ab03a 	or	r5,r5,r2
 908c428:	2807883a 	mov	r3,r5
 908c42c:	7005883a 	mov	r2,r14
 908c430:	dc800217 	ldw	r18,8(sp)
 908c434:	dc400117 	ldw	r17,4(sp)
 908c438:	dc000017 	ldw	r16,0(sp)
 908c43c:	dec00304 	addi	sp,sp,12
 908c440:	f800283a 	ret
 908c444:	21000217 	ldw	r4,8(r4)
 908c448:	00bf0084 	movi	r2,-1022
 908c44c:	20803f16 	blt	r4,r2,908c54c <__pack_d+0x1b4>
 908c450:	0080ffc4 	movi	r2,1023
 908c454:	11002c16 	blt	r2,r4,908c508 <__pack_d+0x170>
 908c458:	00803fc4 	movi	r2,255
 908c45c:	408c703a 	and	r6,r8,r2
 908c460:	00802004 	movi	r2,128
 908c464:	0007883a 	mov	r3,zero
 908c468:	000f883a 	mov	r7,zero
 908c46c:	2280ffc4 	addi	r10,r4,1023
 908c470:	30801e26 	beq	r6,r2,908c4ec <__pack_d+0x154>
 908c474:	00801fc4 	movi	r2,127
 908c478:	4089883a 	add	r4,r8,r2
 908c47c:	220d803a 	cmpltu	r6,r4,r8
 908c480:	324d883a 	add	r6,r6,r9
 908c484:	2011883a 	mov	r8,r4
 908c488:	3013883a 	mov	r9,r6
 908c48c:	00880034 	movhi	r2,8192
 908c490:	10bfffc4 	addi	r2,r2,-1
 908c494:	12400d36 	bltu	r2,r9,908c4cc <__pack_d+0x134>
 908c498:	4804963a 	slli	r2,r9,24
 908c49c:	400cd23a 	srli	r6,r8,8
 908c4a0:	480ed23a 	srli	r7,r9,8
 908c4a4:	013fffc4 	movi	r4,-1
 908c4a8:	118cb03a 	or	r6,r2,r6
 908c4ac:	01400434 	movhi	r5,16
 908c4b0:	297fffc4 	addi	r5,r5,-1
 908c4b4:	3104703a 	and	r2,r6,r4
 908c4b8:	3946703a 	and	r3,r7,r5
 908c4bc:	5201ffcc 	andi	r8,r10,2047
 908c4c0:	100d883a 	mov	r6,r2
 908c4c4:	180f883a 	mov	r7,r3
 908c4c8:	003fc706 	br	908c3e8 <__pack_d+0x50>
 908c4cc:	480897fa 	slli	r4,r9,31
 908c4d0:	4004d07a 	srli	r2,r8,1
 908c4d4:	4806d07a 	srli	r3,r9,1
 908c4d8:	52800044 	addi	r10,r10,1
 908c4dc:	2084b03a 	or	r2,r4,r2
 908c4e0:	1011883a 	mov	r8,r2
 908c4e4:	1813883a 	mov	r9,r3
 908c4e8:	003feb06 	br	908c498 <__pack_d+0x100>
 908c4ec:	383fe11e 	bne	r7,zero,908c474 <__pack_d+0xdc>
 908c4f0:	01004004 	movi	r4,256
 908c4f4:	4104703a 	and	r2,r8,r4
 908c4f8:	10c4b03a 	or	r2,r2,r3
 908c4fc:	103fe326 	beq	r2,zero,908c48c <__pack_d+0xf4>
 908c500:	3005883a 	mov	r2,r6
 908c504:	003fdc06 	br	908c478 <__pack_d+0xe0>
 908c508:	000d883a 	mov	r6,zero
 908c50c:	000f883a 	mov	r7,zero
 908c510:	0201ffc4 	movi	r8,2047
 908c514:	003fb406 	br	908c3e8 <__pack_d+0x50>
 908c518:	0005883a 	mov	r2,zero
 908c51c:	00c00234 	movhi	r3,8
 908c520:	408cb03a 	or	r6,r8,r2
 908c524:	48ceb03a 	or	r7,r9,r3
 908c528:	013fffc4 	movi	r4,-1
 908c52c:	01400434 	movhi	r5,16
 908c530:	297fffc4 	addi	r5,r5,-1
 908c534:	3104703a 	and	r2,r6,r4
 908c538:	3946703a 	and	r3,r7,r5
 908c53c:	100d883a 	mov	r6,r2
 908c540:	180f883a 	mov	r7,r3
 908c544:	0201ffc4 	movi	r8,2047
 908c548:	003fa706 	br	908c3e8 <__pack_d+0x50>
 908c54c:	1109c83a 	sub	r4,r2,r4
 908c550:	00800e04 	movi	r2,56
 908c554:	11004316 	blt	r2,r4,908c664 <__pack_d+0x2cc>
 908c558:	21fff804 	addi	r7,r4,-32
 908c55c:	38004516 	blt	r7,zero,908c674 <__pack_d+0x2dc>
 908c560:	49d8d83a 	srl	r12,r9,r7
 908c564:	001b883a 	mov	r13,zero
 908c568:	0023883a 	mov	r17,zero
 908c56c:	01400044 	movi	r5,1
 908c570:	0025883a 	mov	r18,zero
 908c574:	38004716 	blt	r7,zero,908c694 <__pack_d+0x2fc>
 908c578:	29d6983a 	sll	r11,r5,r7
 908c57c:	0015883a 	mov	r10,zero
 908c580:	00bfffc4 	movi	r2,-1
 908c584:	5089883a 	add	r4,r10,r2
 908c588:	588b883a 	add	r5,r11,r2
 908c58c:	228d803a 	cmpltu	r6,r4,r10
 908c590:	314b883a 	add	r5,r6,r5
 908c594:	4104703a 	and	r2,r8,r4
 908c598:	4946703a 	and	r3,r9,r5
 908c59c:	10c4b03a 	or	r2,r2,r3
 908c5a0:	10000226 	beq	r2,zero,908c5ac <__pack_d+0x214>
 908c5a4:	04400044 	movi	r17,1
 908c5a8:	0025883a 	mov	r18,zero
 908c5ac:	00803fc4 	movi	r2,255
 908c5b0:	644eb03a 	or	r7,r12,r17
 908c5b4:	3892703a 	and	r9,r7,r2
 908c5b8:	00802004 	movi	r2,128
 908c5bc:	6c90b03a 	or	r8,r13,r18
 908c5c0:	0015883a 	mov	r10,zero
 908c5c4:	48801626 	beq	r9,r2,908c620 <__pack_d+0x288>
 908c5c8:	01001fc4 	movi	r4,127
 908c5cc:	3905883a 	add	r2,r7,r4
 908c5d0:	11cd803a 	cmpltu	r6,r2,r7
 908c5d4:	320d883a 	add	r6,r6,r8
 908c5d8:	100f883a 	mov	r7,r2
 908c5dc:	00840034 	movhi	r2,4096
 908c5e0:	10bfffc4 	addi	r2,r2,-1
 908c5e4:	3011883a 	mov	r8,r6
 908c5e8:	0007883a 	mov	r3,zero
 908c5ec:	11801b36 	bltu	r2,r6,908c65c <__pack_d+0x2c4>
 908c5f0:	4004963a 	slli	r2,r8,24
 908c5f4:	3808d23a 	srli	r4,r7,8
 908c5f8:	400ad23a 	srli	r5,r8,8
 908c5fc:	1813883a 	mov	r9,r3
 908c600:	1108b03a 	or	r4,r2,r4
 908c604:	00bfffc4 	movi	r2,-1
 908c608:	00c00434 	movhi	r3,16
 908c60c:	18ffffc4 	addi	r3,r3,-1
 908c610:	208c703a 	and	r6,r4,r2
 908c614:	28ce703a 	and	r7,r5,r3
 908c618:	4a01ffcc 	andi	r8,r9,2047
 908c61c:	003f7206 	br	908c3e8 <__pack_d+0x50>
 908c620:	503fe91e 	bne	r10,zero,908c5c8 <__pack_d+0x230>
 908c624:	01004004 	movi	r4,256
 908c628:	3904703a 	and	r2,r7,r4
 908c62c:	0007883a 	mov	r3,zero
 908c630:	10c4b03a 	or	r2,r2,r3
 908c634:	10000626 	beq	r2,zero,908c650 <__pack_d+0x2b8>
 908c638:	3a45883a 	add	r2,r7,r9
 908c63c:	11cd803a 	cmpltu	r6,r2,r7
 908c640:	320d883a 	add	r6,r6,r8
 908c644:	100f883a 	mov	r7,r2
 908c648:	3011883a 	mov	r8,r6
 908c64c:	0007883a 	mov	r3,zero
 908c650:	00840034 	movhi	r2,4096
 908c654:	10bfffc4 	addi	r2,r2,-1
 908c658:	123fe52e 	bgeu	r2,r8,908c5f0 <__pack_d+0x258>
 908c65c:	00c00044 	movi	r3,1
 908c660:	003fe306 	br	908c5f0 <__pack_d+0x258>
 908c664:	0009883a 	mov	r4,zero
 908c668:	0013883a 	mov	r9,zero
 908c66c:	000b883a 	mov	r5,zero
 908c670:	003fe406 	br	908c604 <__pack_d+0x26c>
 908c674:	4a47883a 	add	r3,r9,r9
 908c678:	008007c4 	movi	r2,31
 908c67c:	1105c83a 	sub	r2,r2,r4
 908c680:	1886983a 	sll	r3,r3,r2
 908c684:	4118d83a 	srl	r12,r8,r4
 908c688:	491ad83a 	srl	r13,r9,r4
 908c68c:	1b18b03a 	or	r12,r3,r12
 908c690:	003fb506 	br	908c568 <__pack_d+0x1d0>
 908c694:	2806d07a 	srli	r3,r5,1
 908c698:	008007c4 	movi	r2,31
 908c69c:	1105c83a 	sub	r2,r2,r4
 908c6a0:	1896d83a 	srl	r11,r3,r2
 908c6a4:	2914983a 	sll	r10,r5,r4
 908c6a8:	003fb506 	br	908c580 <__pack_d+0x1e8>

0908c6ac <__unpack_d>:
 908c6ac:	20c00117 	ldw	r3,4(r4)
 908c6b0:	22400017 	ldw	r9,0(r4)
 908c6b4:	00800434 	movhi	r2,16
 908c6b8:	10bfffc4 	addi	r2,r2,-1
 908c6bc:	1808d53a 	srli	r4,r3,20
 908c6c0:	180cd7fa 	srli	r6,r3,31
 908c6c4:	1894703a 	and	r10,r3,r2
 908c6c8:	2201ffcc 	andi	r8,r4,2047
 908c6cc:	281b883a 	mov	r13,r5
 908c6d0:	4817883a 	mov	r11,r9
 908c6d4:	29800115 	stw	r6,4(r5)
 908c6d8:	5019883a 	mov	r12,r10
 908c6dc:	40001e1e 	bne	r8,zero,908c758 <__unpack_d+0xac>
 908c6e0:	4a84b03a 	or	r2,r9,r10
 908c6e4:	10001926 	beq	r2,zero,908c74c <__unpack_d+0xa0>
 908c6e8:	4804d63a 	srli	r2,r9,24
 908c6ec:	500c923a 	slli	r6,r10,8
 908c6f0:	013f0084 	movi	r4,-1022
 908c6f4:	00c40034 	movhi	r3,4096
 908c6f8:	18ffffc4 	addi	r3,r3,-1
 908c6fc:	118cb03a 	or	r6,r2,r6
 908c700:	008000c4 	movi	r2,3
 908c704:	480a923a 	slli	r5,r9,8
 908c708:	68800015 	stw	r2,0(r13)
 908c70c:	69000215 	stw	r4,8(r13)
 908c710:	19800b36 	bltu	r3,r6,908c740 <__unpack_d+0x94>
 908c714:	200f883a 	mov	r7,r4
 908c718:	1811883a 	mov	r8,r3
 908c71c:	2945883a 	add	r2,r5,r5
 908c720:	1149803a 	cmpltu	r4,r2,r5
 908c724:	3187883a 	add	r3,r6,r6
 908c728:	20c9883a 	add	r4,r4,r3
 908c72c:	100b883a 	mov	r5,r2
 908c730:	200d883a 	mov	r6,r4
 908c734:	39ffffc4 	addi	r7,r7,-1
 908c738:	413ff82e 	bgeu	r8,r4,908c71c <__unpack_d+0x70>
 908c73c:	69c00215 	stw	r7,8(r13)
 908c740:	69800415 	stw	r6,16(r13)
 908c744:	69400315 	stw	r5,12(r13)
 908c748:	f800283a 	ret
 908c74c:	00800084 	movi	r2,2
 908c750:	28800015 	stw	r2,0(r5)
 908c754:	f800283a 	ret
 908c758:	0081ffc4 	movi	r2,2047
 908c75c:	40800f26 	beq	r8,r2,908c79c <__unpack_d+0xf0>
 908c760:	480cd63a 	srli	r6,r9,24
 908c764:	5006923a 	slli	r3,r10,8
 908c768:	4804923a 	slli	r2,r9,8
 908c76c:	0009883a 	mov	r4,zero
 908c770:	30c6b03a 	or	r3,r6,r3
 908c774:	01440034 	movhi	r5,4096
 908c778:	110cb03a 	or	r6,r2,r4
 908c77c:	423f0044 	addi	r8,r8,-1023
 908c780:	194eb03a 	or	r7,r3,r5
 908c784:	008000c4 	movi	r2,3
 908c788:	69c00415 	stw	r7,16(r13)
 908c78c:	6a000215 	stw	r8,8(r13)
 908c790:	68800015 	stw	r2,0(r13)
 908c794:	69800315 	stw	r6,12(r13)
 908c798:	f800283a 	ret
 908c79c:	4a84b03a 	or	r2,r9,r10
 908c7a0:	1000031e 	bne	r2,zero,908c7b0 <__unpack_d+0x104>
 908c7a4:	00800104 	movi	r2,4
 908c7a8:	28800015 	stw	r2,0(r5)
 908c7ac:	f800283a 	ret
 908c7b0:	0009883a 	mov	r4,zero
 908c7b4:	01400234 	movhi	r5,8
 908c7b8:	4904703a 	and	r2,r9,r4
 908c7bc:	5146703a 	and	r3,r10,r5
 908c7c0:	10c4b03a 	or	r2,r2,r3
 908c7c4:	10000526 	beq	r2,zero,908c7dc <__unpack_d+0x130>
 908c7c8:	00800044 	movi	r2,1
 908c7cc:	68800015 	stw	r2,0(r13)
 908c7d0:	6b000415 	stw	r12,16(r13)
 908c7d4:	6ac00315 	stw	r11,12(r13)
 908c7d8:	f800283a 	ret
 908c7dc:	68000015 	stw	zero,0(r13)
 908c7e0:	003ffb06 	br	908c7d0 <__unpack_d+0x124>

0908c7e4 <__fpcmp_parts_d>:
 908c7e4:	21800017 	ldw	r6,0(r4)
 908c7e8:	00c00044 	movi	r3,1
 908c7ec:	19800a2e 	bgeu	r3,r6,908c818 <__fpcmp_parts_d+0x34>
 908c7f0:	28800017 	ldw	r2,0(r5)
 908c7f4:	1880082e 	bgeu	r3,r2,908c818 <__fpcmp_parts_d+0x34>
 908c7f8:	00c00104 	movi	r3,4
 908c7fc:	30c02626 	beq	r6,r3,908c898 <__fpcmp_parts_d+0xb4>
 908c800:	10c02226 	beq	r2,r3,908c88c <__fpcmp_parts_d+0xa8>
 908c804:	00c00084 	movi	r3,2
 908c808:	30c00526 	beq	r6,r3,908c820 <__fpcmp_parts_d+0x3c>
 908c80c:	10c0071e 	bne	r2,r3,908c82c <__fpcmp_parts_d+0x48>
 908c810:	20800117 	ldw	r2,4(r4)
 908c814:	1000091e 	bne	r2,zero,908c83c <__fpcmp_parts_d+0x58>
 908c818:	00800044 	movi	r2,1
 908c81c:	f800283a 	ret
 908c820:	10c01a1e 	bne	r2,r3,908c88c <__fpcmp_parts_d+0xa8>
 908c824:	0005883a 	mov	r2,zero
 908c828:	f800283a 	ret
 908c82c:	22000117 	ldw	r8,4(r4)
 908c830:	28800117 	ldw	r2,4(r5)
 908c834:	40800326 	beq	r8,r2,908c844 <__fpcmp_parts_d+0x60>
 908c838:	403ff726 	beq	r8,zero,908c818 <__fpcmp_parts_d+0x34>
 908c83c:	00bfffc4 	movi	r2,-1
 908c840:	f800283a 	ret
 908c844:	20c00217 	ldw	r3,8(r4)
 908c848:	28800217 	ldw	r2,8(r5)
 908c84c:	10fffa16 	blt	r2,r3,908c838 <__fpcmp_parts_d+0x54>
 908c850:	18800916 	blt	r3,r2,908c878 <__fpcmp_parts_d+0x94>
 908c854:	21c00417 	ldw	r7,16(r4)
 908c858:	28c00417 	ldw	r3,16(r5)
 908c85c:	21800317 	ldw	r6,12(r4)
 908c860:	28800317 	ldw	r2,12(r5)
 908c864:	19fff436 	bltu	r3,r7,908c838 <__fpcmp_parts_d+0x54>
 908c868:	38c00526 	beq	r7,r3,908c880 <__fpcmp_parts_d+0x9c>
 908c86c:	38c00236 	bltu	r7,r3,908c878 <__fpcmp_parts_d+0x94>
 908c870:	19ffec1e 	bne	r3,r7,908c824 <__fpcmp_parts_d+0x40>
 908c874:	30bfeb2e 	bgeu	r6,r2,908c824 <__fpcmp_parts_d+0x40>
 908c878:	403fe71e 	bne	r8,zero,908c818 <__fpcmp_parts_d+0x34>
 908c87c:	003fef06 	br	908c83c <__fpcmp_parts_d+0x58>
 908c880:	11bffa2e 	bgeu	r2,r6,908c86c <__fpcmp_parts_d+0x88>
 908c884:	403fe426 	beq	r8,zero,908c818 <__fpcmp_parts_d+0x34>
 908c888:	003fec06 	br	908c83c <__fpcmp_parts_d+0x58>
 908c88c:	28800117 	ldw	r2,4(r5)
 908c890:	103fe11e 	bne	r2,zero,908c818 <__fpcmp_parts_d+0x34>
 908c894:	003fe906 	br	908c83c <__fpcmp_parts_d+0x58>
 908c898:	11bfdd1e 	bne	r2,r6,908c810 <__fpcmp_parts_d+0x2c>
 908c89c:	28c00117 	ldw	r3,4(r5)
 908c8a0:	20800117 	ldw	r2,4(r4)
 908c8a4:	1885c83a 	sub	r2,r3,r2
 908c8a8:	f800283a 	ret

0908c8ac <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 908c8ac:	defff904 	addi	sp,sp,-28
 908c8b0:	dfc00615 	stw	ra,24(sp)
 908c8b4:	df000515 	stw	fp,20(sp)
 908c8b8:	df000504 	addi	fp,sp,20
 908c8bc:	e13ffc15 	stw	r4,-16(fp)
 908c8c0:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908c8c4:	e0bffc17 	ldw	r2,-16(fp)
 908c8c8:	1004803a 	cmplt	r2,r2,zero
 908c8cc:	1000081e 	bne	r2,zero,908c8f0 <fstat+0x44>
 908c8d0:	e0bffc17 	ldw	r2,-16(fp)
 908c8d4:	10800324 	muli	r2,r2,12
 908c8d8:	1007883a 	mov	r3,r2
 908c8dc:	00824374 	movhi	r2,2317
 908c8e0:	108ad604 	addi	r2,r2,11096
 908c8e4:	1887883a 	add	r3,r3,r2
 908c8e8:	e0ffff15 	stw	r3,-4(fp)
 908c8ec:	00000106 	br	908c8f4 <fstat+0x48>
 908c8f0:	e03fff15 	stw	zero,-4(fp)
 908c8f4:	e0bfff17 	ldw	r2,-4(fp)
 908c8f8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 908c8fc:	e0bffb17 	ldw	r2,-20(fp)
 908c900:	1005003a 	cmpeq	r2,r2,zero
 908c904:	1000121e 	bne	r2,zero,908c950 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 908c908:	e0bffb17 	ldw	r2,-20(fp)
 908c90c:	10800017 	ldw	r2,0(r2)
 908c910:	10800817 	ldw	r2,32(r2)
 908c914:	1005003a 	cmpeq	r2,r2,zero
 908c918:	1000081e 	bne	r2,zero,908c93c <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 908c91c:	e0bffb17 	ldw	r2,-20(fp)
 908c920:	10800017 	ldw	r2,0(r2)
 908c924:	10800817 	ldw	r2,32(r2)
 908c928:	e13ffb17 	ldw	r4,-20(fp)
 908c92c:	e17ffd17 	ldw	r5,-12(fp)
 908c930:	103ee83a 	callr	r2
 908c934:	e0bffe15 	stw	r2,-8(fp)
 908c938:	00000b06 	br	908c968 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 908c93c:	e0fffd17 	ldw	r3,-12(fp)
 908c940:	00880004 	movi	r2,8192
 908c944:	18800115 	stw	r2,4(r3)
      return 0;
 908c948:	e03ffe15 	stw	zero,-8(fp)
 908c94c:	00000606 	br	908c968 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 908c950:	908c9800 	call	908c980 <alt_get_errno>
 908c954:	1007883a 	mov	r3,r2
 908c958:	00801444 	movi	r2,81
 908c95c:	18800015 	stw	r2,0(r3)
    return -1;
 908c960:	00bfffc4 	movi	r2,-1
 908c964:	e0bffe15 	stw	r2,-8(fp)
 908c968:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 908c96c:	e037883a 	mov	sp,fp
 908c970:	dfc00117 	ldw	ra,4(sp)
 908c974:	df000017 	ldw	fp,0(sp)
 908c978:	dec00204 	addi	sp,sp,8
 908c97c:	f800283a 	ret

0908c980 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908c980:	defffd04 	addi	sp,sp,-12
 908c984:	dfc00215 	stw	ra,8(sp)
 908c988:	df000115 	stw	fp,4(sp)
 908c98c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908c990:	00824374 	movhi	r2,2317
 908c994:	108bdf04 	addi	r2,r2,12156
 908c998:	10800017 	ldw	r2,0(r2)
 908c99c:	1005003a 	cmpeq	r2,r2,zero
 908c9a0:	1000061e 	bne	r2,zero,908c9bc <alt_get_errno+0x3c>
 908c9a4:	00824374 	movhi	r2,2317
 908c9a8:	108bdf04 	addi	r2,r2,12156
 908c9ac:	10800017 	ldw	r2,0(r2)
 908c9b0:	103ee83a 	callr	r2
 908c9b4:	e0bfff15 	stw	r2,-4(fp)
 908c9b8:	00000306 	br	908c9c8 <alt_get_errno+0x48>
 908c9bc:	00824374 	movhi	r2,2317
 908c9c0:	108bfd04 	addi	r2,r2,12276
 908c9c4:	e0bfff15 	stw	r2,-4(fp)
 908c9c8:	e0bfff17 	ldw	r2,-4(fp)
}
 908c9cc:	e037883a 	mov	sp,fp
 908c9d0:	dfc00117 	ldw	ra,4(sp)
 908c9d4:	df000017 	ldw	fp,0(sp)
 908c9d8:	dec00204 	addi	sp,sp,8
 908c9dc:	f800283a 	ret

0908c9e0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 908c9e0:	deffeb04 	addi	sp,sp,-84
 908c9e4:	dfc01415 	stw	ra,80(sp)
 908c9e8:	df001315 	stw	fp,76(sp)
 908c9ec:	df001304 	addi	fp,sp,76
 908c9f0:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908c9f4:	e0bffd17 	ldw	r2,-12(fp)
 908c9f8:	1004803a 	cmplt	r2,r2,zero
 908c9fc:	1000081e 	bne	r2,zero,908ca20 <isatty+0x40>
 908ca00:	e0bffd17 	ldw	r2,-12(fp)
 908ca04:	10800324 	muli	r2,r2,12
 908ca08:	1007883a 	mov	r3,r2
 908ca0c:	00824374 	movhi	r2,2317
 908ca10:	108ad604 	addi	r2,r2,11096
 908ca14:	1887883a 	add	r3,r3,r2
 908ca18:	e0ffff15 	stw	r3,-4(fp)
 908ca1c:	00000106 	br	908ca24 <isatty+0x44>
 908ca20:	e03fff15 	stw	zero,-4(fp)
 908ca24:	e0bfff17 	ldw	r2,-4(fp)
 908ca28:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 908ca2c:	e0bfed17 	ldw	r2,-76(fp)
 908ca30:	1005003a 	cmpeq	r2,r2,zero
 908ca34:	10000f1e 	bne	r2,zero,908ca74 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 908ca38:	e0bfed17 	ldw	r2,-76(fp)
 908ca3c:	10800017 	ldw	r2,0(r2)
 908ca40:	10800817 	ldw	r2,32(r2)
 908ca44:	1004c03a 	cmpne	r2,r2,zero
 908ca48:	1000031e 	bne	r2,zero,908ca58 <isatty+0x78>
    {
      return 1;
 908ca4c:	00800044 	movi	r2,1
 908ca50:	e0bffe15 	stw	r2,-8(fp)
 908ca54:	00000c06 	br	908ca88 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 908ca58:	e17fee04 	addi	r5,fp,-72
 908ca5c:	e13ffd17 	ldw	r4,-12(fp)
 908ca60:	908c8ac0 	call	908c8ac <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 908ca64:	e0bfef17 	ldw	r2,-68(fp)
 908ca68:	10880020 	cmpeqi	r2,r2,8192
 908ca6c:	e0bffe15 	stw	r2,-8(fp)
 908ca70:	00000506 	br	908ca88 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 908ca74:	908caa00 	call	908caa0 <alt_get_errno>
 908ca78:	1007883a 	mov	r3,r2
 908ca7c:	00801444 	movi	r2,81
 908ca80:	18800015 	stw	r2,0(r3)
    return 0;
 908ca84:	e03ffe15 	stw	zero,-8(fp)
 908ca88:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 908ca8c:	e037883a 	mov	sp,fp
 908ca90:	dfc00117 	ldw	ra,4(sp)
 908ca94:	df000017 	ldw	fp,0(sp)
 908ca98:	dec00204 	addi	sp,sp,8
 908ca9c:	f800283a 	ret

0908caa0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908caa0:	defffd04 	addi	sp,sp,-12
 908caa4:	dfc00215 	stw	ra,8(sp)
 908caa8:	df000115 	stw	fp,4(sp)
 908caac:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908cab0:	00824374 	movhi	r2,2317
 908cab4:	108bdf04 	addi	r2,r2,12156
 908cab8:	10800017 	ldw	r2,0(r2)
 908cabc:	1005003a 	cmpeq	r2,r2,zero
 908cac0:	1000061e 	bne	r2,zero,908cadc <alt_get_errno+0x3c>
 908cac4:	00824374 	movhi	r2,2317
 908cac8:	108bdf04 	addi	r2,r2,12156
 908cacc:	10800017 	ldw	r2,0(r2)
 908cad0:	103ee83a 	callr	r2
 908cad4:	e0bfff15 	stw	r2,-4(fp)
 908cad8:	00000306 	br	908cae8 <alt_get_errno+0x48>
 908cadc:	00824374 	movhi	r2,2317
 908cae0:	108bfd04 	addi	r2,r2,12276
 908cae4:	e0bfff15 	stw	r2,-4(fp)
 908cae8:	e0bfff17 	ldw	r2,-4(fp)
}
 908caec:	e037883a 	mov	sp,fp
 908caf0:	dfc00117 	ldw	ra,4(sp)
 908caf4:	df000017 	ldw	fp,0(sp)
 908caf8:	dec00204 	addi	sp,sp,8
 908cafc:	f800283a 	ret

0908cb00 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 908cb00:	defff804 	addi	sp,sp,-32
 908cb04:	dfc00715 	stw	ra,28(sp)
 908cb08:	df000615 	stw	fp,24(sp)
 908cb0c:	df000604 	addi	fp,sp,24
 908cb10:	e13ffc15 	stw	r4,-16(fp)
 908cb14:	e17ffd15 	stw	r5,-12(fp)
 908cb18:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 908cb1c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908cb20:	e0bffc17 	ldw	r2,-16(fp)
 908cb24:	1004803a 	cmplt	r2,r2,zero
 908cb28:	1000081e 	bne	r2,zero,908cb4c <lseek+0x4c>
 908cb2c:	e0bffc17 	ldw	r2,-16(fp)
 908cb30:	10800324 	muli	r2,r2,12
 908cb34:	1007883a 	mov	r3,r2
 908cb38:	00824374 	movhi	r2,2317
 908cb3c:	108ad604 	addi	r2,r2,11096
 908cb40:	1887883a 	add	r3,r3,r2
 908cb44:	e0ffff15 	stw	r3,-4(fp)
 908cb48:	00000106 	br	908cb50 <lseek+0x50>
 908cb4c:	e03fff15 	stw	zero,-4(fp)
 908cb50:	e0bfff17 	ldw	r2,-4(fp)
 908cb54:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 908cb58:	e0bffb17 	ldw	r2,-20(fp)
 908cb5c:	1005003a 	cmpeq	r2,r2,zero
 908cb60:	1000111e 	bne	r2,zero,908cba8 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 908cb64:	e0bffb17 	ldw	r2,-20(fp)
 908cb68:	10800017 	ldw	r2,0(r2)
 908cb6c:	10800717 	ldw	r2,28(r2)
 908cb70:	1005003a 	cmpeq	r2,r2,zero
 908cb74:	1000091e 	bne	r2,zero,908cb9c <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 908cb78:	e0bffb17 	ldw	r2,-20(fp)
 908cb7c:	10800017 	ldw	r2,0(r2)
 908cb80:	10800717 	ldw	r2,28(r2)
 908cb84:	e13ffb17 	ldw	r4,-20(fp)
 908cb88:	e17ffd17 	ldw	r5,-12(fp)
 908cb8c:	e1bffe17 	ldw	r6,-8(fp)
 908cb90:	103ee83a 	callr	r2
 908cb94:	e0bffa15 	stw	r2,-24(fp)
 908cb98:	00000506 	br	908cbb0 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 908cb9c:	00bfde84 	movi	r2,-134
 908cba0:	e0bffa15 	stw	r2,-24(fp)
 908cba4:	00000206 	br	908cbb0 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 908cba8:	00bfebc4 	movi	r2,-81
 908cbac:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 908cbb0:	e0bffa17 	ldw	r2,-24(fp)
 908cbb4:	1004403a 	cmpge	r2,r2,zero
 908cbb8:	1000071e 	bne	r2,zero,908cbd8 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 908cbbc:	908cbf00 	call	908cbf0 <alt_get_errno>
 908cbc0:	1007883a 	mov	r3,r2
 908cbc4:	e0bffa17 	ldw	r2,-24(fp)
 908cbc8:	0085c83a 	sub	r2,zero,r2
 908cbcc:	18800015 	stw	r2,0(r3)
    rc = -1;
 908cbd0:	00bfffc4 	movi	r2,-1
 908cbd4:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 908cbd8:	e0bffa17 	ldw	r2,-24(fp)
}
 908cbdc:	e037883a 	mov	sp,fp
 908cbe0:	dfc00117 	ldw	ra,4(sp)
 908cbe4:	df000017 	ldw	fp,0(sp)
 908cbe8:	dec00204 	addi	sp,sp,8
 908cbec:	f800283a 	ret

0908cbf0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908cbf0:	defffd04 	addi	sp,sp,-12
 908cbf4:	dfc00215 	stw	ra,8(sp)
 908cbf8:	df000115 	stw	fp,4(sp)
 908cbfc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908cc00:	00824374 	movhi	r2,2317
 908cc04:	108bdf04 	addi	r2,r2,12156
 908cc08:	10800017 	ldw	r2,0(r2)
 908cc0c:	1005003a 	cmpeq	r2,r2,zero
 908cc10:	1000061e 	bne	r2,zero,908cc2c <alt_get_errno+0x3c>
 908cc14:	00824374 	movhi	r2,2317
 908cc18:	108bdf04 	addi	r2,r2,12156
 908cc1c:	10800017 	ldw	r2,0(r2)
 908cc20:	103ee83a 	callr	r2
 908cc24:	e0bfff15 	stw	r2,-4(fp)
 908cc28:	00000306 	br	908cc38 <alt_get_errno+0x48>
 908cc2c:	00824374 	movhi	r2,2317
 908cc30:	108bfd04 	addi	r2,r2,12276
 908cc34:	e0bfff15 	stw	r2,-4(fp)
 908cc38:	e0bfff17 	ldw	r2,-4(fp)
}
 908cc3c:	e037883a 	mov	sp,fp
 908cc40:	dfc00117 	ldw	ra,4(sp)
 908cc44:	df000017 	ldw	fp,0(sp)
 908cc48:	dec00204 	addi	sp,sp,8
 908cc4c:	f800283a 	ret

0908cc50 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 908cc50:	defffb04 	addi	sp,sp,-20
 908cc54:	dfc00415 	stw	ra,16(sp)
 908cc58:	df000315 	stw	fp,12(sp)
 908cc5c:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 908cc60:	0009883a 	mov	r4,zero
 908cc64:	90954680 	call	9095468 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 908cc68:	908d9dc0 	call	908d9dc <OSInit>
 908cc6c:	01000044 	movi	r4,1
 908cc70:	90928b80 	call	90928b8 <OSSemCreate>
 908cc74:	1007883a 	mov	r3,r2
 908cc78:	00824374 	movhi	r2,2317
 908cc7c:	108c0204 	addi	r2,r2,12296
 908cc80:	10c00015 	stw	r3,0(r2)
 908cc84:	01000044 	movi	r4,1
 908cc88:	90928b80 	call	90928b8 <OSSemCreate>
 908cc8c:	1007883a 	mov	r3,r2
 908cc90:	00824374 	movhi	r2,2317
 908cc94:	108c0404 	addi	r2,r2,12304
 908cc98:	10c00015 	stw	r3,0(r2)
 908cc9c:	00824374 	movhi	r2,2317
 908cca0:	108c5004 	addi	r2,r2,12608
 908cca4:	e0bffd15 	stw	r2,-12(fp)
 908cca8:	00800044 	movi	r2,1
 908ccac:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 908ccb0:	e13ffe0b 	ldhu	r4,-8(fp)
 908ccb4:	90928b80 	call	90928b8 <OSSemCreate>
 908ccb8:	1007883a 	mov	r3,r2
 908ccbc:	e0bffd17 	ldw	r2,-12(fp)
 908ccc0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 908ccc4:	909549c0 	call	909549c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 908ccc8:	01024374 	movhi	r4,2317
 908cccc:	21332b04 	addi	r4,r4,-13140
 908ccd0:	01424374 	movhi	r5,2317
 908ccd4:	29732b04 	addi	r5,r5,-13140
 908ccd8:	01824374 	movhi	r6,2317
 908ccdc:	31b32b04 	addi	r6,r6,-13140
 908cce0:	90b93c00 	call	90b93c0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 908cce4:	90b8e040 	call	90b8e04 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 908cce8:	01024334 	movhi	r4,2316
 908ccec:	21239a04 	addi	r4,r4,-29080
 908ccf0:	90ca4980 	call	90ca498 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 908ccf4:	d1206417 	ldw	r4,-32368(gp)
 908ccf8:	d1606517 	ldw	r5,-32364(gp)
 908ccfc:	d1a06617 	ldw	r6,-32360(gp)
 908cd00:	9080f240 	call	9080f24 <main>
 908cd04:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 908cd08:	01000044 	movi	r4,1
 908cd0c:	90a0b9c0 	call	90a0b9c <close>
  exit (result);
 908cd10:	e13fff17 	ldw	r4,-4(fp)
 908cd14:	90ca4e00 	call	90ca4e0 <exit>

0908cd18 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 908cd18:	defff804 	addi	sp,sp,-32
 908cd1c:	df000715 	stw	fp,28(sp)
 908cd20:	df000704 	addi	fp,sp,28
 908cd24:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908cd28:	0005303a 	rdctl	r2,status
 908cd2c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908cd30:	e0fffb17 	ldw	r3,-20(fp)
 908cd34:	00bfff84 	movi	r2,-2
 908cd38:	1884703a 	and	r2,r3,r2
 908cd3c:	1001703a 	wrctl	status,r2
  
  return context;
 908cd40:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 908cd44:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 908cd48:	d0a00717 	ldw	r2,-32740(gp)
 908cd4c:	10c000c4 	addi	r3,r2,3
 908cd50:	00bfff04 	movi	r2,-4
 908cd54:	1884703a 	and	r2,r3,r2
 908cd58:	d0a00715 	stw	r2,-32740(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 908cd5c:	d0e00717 	ldw	r3,-32740(gp)
 908cd60:	e0bffe17 	ldw	r2,-8(fp)
 908cd64:	1887883a 	add	r3,r3,r2
 908cd68:	00824434 	movhi	r2,2320
 908cd6c:	10800004 	addi	r2,r2,0
 908cd70:	10c0072e 	bgeu	r2,r3,908cd90 <sbrk+0x78>
 908cd74:	e0bffd17 	ldw	r2,-12(fp)
 908cd78:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908cd7c:	e0bffa17 	ldw	r2,-24(fp)
 908cd80:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 908cd84:	00bfffc4 	movi	r2,-1
 908cd88:	e0bfff15 	stw	r2,-4(fp)
 908cd8c:	00000c06 	br	908cdc0 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 908cd90:	d0a00717 	ldw	r2,-32740(gp)
 908cd94:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 908cd98:	d0e00717 	ldw	r3,-32740(gp)
 908cd9c:	e0bffe17 	ldw	r2,-8(fp)
 908cda0:	1885883a 	add	r2,r3,r2
 908cda4:	d0a00715 	stw	r2,-32740(gp)
 908cda8:	e0bffd17 	ldw	r2,-12(fp)
 908cdac:	e0bff915 	stw	r2,-28(fp)
 908cdb0:	e0bff917 	ldw	r2,-28(fp)
 908cdb4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 908cdb8:	e0bffc17 	ldw	r2,-16(fp)
 908cdbc:	e0bfff15 	stw	r2,-4(fp)
 908cdc0:	e0bfff17 	ldw	r2,-4(fp)
} 
 908cdc4:	e037883a 	mov	sp,fp
 908cdc8:	df000017 	ldw	fp,0(sp)
 908cdcc:	dec00104 	addi	sp,sp,4
 908cdd0:	f800283a 	ret

0908cdd4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 908cdd4:	deffdf04 	addi	sp,sp,-132
 908cdd8:	dfc02015 	stw	ra,128(sp)
 908cddc:	df001f15 	stw	fp,124(sp)
 908cde0:	df001f04 	addi	fp,sp,124
 908cde4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 908cde8:	e17fe204 	addi	r5,fp,-120
 908cdec:	01003fc4 	movi	r4,255
 908cdf0:	9094c400 	call	9094c40 <OSTaskQuery>
 908cdf4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 908cdf8:	e0bffe83 	ldbu	r2,-6(fp)
 908cdfc:	10803fcc 	andi	r2,r2,255
 908ce00:	1004c03a 	cmpne	r2,r2,zero
 908ce04:	1000191e 	bne	r2,zero,908ce6c <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 908ce08:	e0bfee83 	ldbu	r2,-70(fp)
 908ce0c:	10803fcc 	andi	r2,r2,255
 908ce10:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 908ce14:	d1206817 	ldw	r4,-32352(gp)
 908ce18:	e17ffd04 	addi	r5,fp,-12
 908ce1c:	909318c0 	call	909318c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 908ce20:	e0bffe43 	ldbu	r2,-7(fp)
 908ce24:	10803fcc 	andi	r2,r2,255
 908ce28:	1005003a 	cmpeq	r2,r2,zero
 908ce2c:	1000071e 	bne	r2,zero,908ce4c <__env_lock+0x78>
 908ce30:	d0e00817 	ldw	r3,-32736(gp)
 908ce34:	e0bfe117 	ldw	r2,-124(fp)
 908ce38:	10c0041e 	bne	r2,r3,908ce4c <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 908ce3c:	d0a06717 	ldw	r2,-32356(gp)
 908ce40:	10800044 	addi	r2,r2,1
 908ce44:	d0a06715 	stw	r2,-32356(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 908ce48:	00000806 	br	908ce6c <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 908ce4c:	d1206817 	ldw	r4,-32352(gp)
 908ce50:	e1bffe84 	addi	r6,fp,-6
 908ce54:	000b883a 	mov	r5,zero
 908ce58:	9092c6c0 	call	9092c6c <OSSemPend>
    locks  = 1;
 908ce5c:	00800044 	movi	r2,1
 908ce60:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 908ce64:	e0bfe117 	ldw	r2,-124(fp)
 908ce68:	d0a00815 	stw	r2,-32736(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 908ce6c:	e037883a 	mov	sp,fp
 908ce70:	dfc00117 	ldw	ra,4(sp)
 908ce74:	df000017 	ldw	fp,0(sp)
 908ce78:	dec00204 	addi	sp,sp,8
 908ce7c:	f800283a 	ret

0908ce80 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 908ce80:	defffd04 	addi	sp,sp,-12
 908ce84:	dfc00215 	stw	ra,8(sp)
 908ce88:	df000115 	stw	fp,4(sp)
 908ce8c:	df000104 	addi	fp,sp,4
 908ce90:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 908ce94:	d0a06717 	ldw	r2,-32356(gp)
 908ce98:	1005003a 	cmpeq	r2,r2,zero
 908ce9c:	10000a1e 	bne	r2,zero,908cec8 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 908cea0:	d0a06717 	ldw	r2,-32356(gp)
 908cea4:	10bfffc4 	addi	r2,r2,-1
 908cea8:	d0a06715 	stw	r2,-32356(gp)
 908ceac:	d0a06717 	ldw	r2,-32356(gp)
 908ceb0:	1004c03a 	cmpne	r2,r2,zero
 908ceb4:	1000041e 	bne	r2,zero,908cec8 <__env_unlock+0x48>
  {
    lockid = -1;
 908ceb8:	00bfffc4 	movi	r2,-1
 908cebc:	d0a00815 	stw	r2,-32736(gp)
    OSSemPost( alt_envsem );
 908cec0:	d1206817 	ldw	r4,-32352(gp)
 908cec4:	90930640 	call	9093064 <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 908cec8:	e037883a 	mov	sp,fp
 908cecc:	dfc00117 	ldw	ra,4(sp)
 908ced0:	df000017 	ldw	fp,0(sp)
 908ced4:	dec00204 	addi	sp,sp,8
 908ced8:	f800283a 	ret

0908cedc <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 908cedc:	deffdb04 	addi	sp,sp,-148
 908cee0:	dfc02415 	stw	ra,144(sp)
 908cee4:	df002315 	stw	fp,140(sp)
 908cee8:	df002304 	addi	fp,sp,140
 908ceec:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908cef0:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 908cef4:	00824374 	movhi	r2,2317
 908cef8:	108c0544 	addi	r2,r2,12309
 908cefc:	10800003 	ldbu	r2,0(r2)
 908cf00:	10803fcc 	andi	r2,r2,255
 908cf04:	10800058 	cmpnei	r2,r2,1
 908cf08:	1000311e 	bne	r2,zero,908cfd0 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 908cf0c:	e17fe204 	addi	r5,fp,-120
 908cf10:	01003fc4 	movi	r4,255
 908cf14:	9094c400 	call	9094c40 <OSTaskQuery>
 908cf18:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 908cf1c:	e0bffe83 	ldbu	r2,-6(fp)
 908cf20:	10803fcc 	andi	r2,r2,255
 908cf24:	1004c03a 	cmpne	r2,r2,zero
 908cf28:	1000291e 	bne	r2,zero,908cfd0 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 908cf2c:	e0bfee83 	ldbu	r2,-70(fp)
 908cf30:	10803fcc 	andi	r2,r2,255
 908cf34:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 908cf38:	d1206a17 	ldw	r4,-32344(gp)
 908cf3c:	e17ffd04 	addi	r5,fp,-12
 908cf40:	909318c0 	call	909318c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908cf44:	0005303a 	rdctl	r2,status
 908cf48:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908cf4c:	e0ffdf17 	ldw	r3,-132(fp)
 908cf50:	00bfff84 	movi	r2,-2
 908cf54:	1884703a 	and	r2,r3,r2
 908cf58:	1001703a 	wrctl	status,r2
  
  return context;
 908cf5c:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 908cf60:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 908cf64:	e0bffd0b 	ldhu	r2,-12(fp)
 908cf68:	10bfffcc 	andi	r2,r2,65535
 908cf6c:	1004c03a 	cmpne	r2,r2,zero
 908cf70:	10000b1e 	bne	r2,zero,908cfa0 <__malloc_lock+0xc4>
 908cf74:	d0e00917 	ldw	r3,-32732(gp)
 908cf78:	e0bfe117 	ldw	r2,-124(fp)
 908cf7c:	10c0081e 	bne	r2,r3,908cfa0 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 908cf80:	d0a06917 	ldw	r2,-32348(gp)
 908cf84:	10800044 	addi	r2,r2,1
 908cf88:	d0a06915 	stw	r2,-32348(gp)
 908cf8c:	e0bfe017 	ldw	r2,-128(fp)
 908cf90:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908cf94:	e0bfde17 	ldw	r2,-136(fp)
 908cf98:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 908cf9c:	00000c06 	br	908cfd0 <__malloc_lock+0xf4>
 908cfa0:	e0bfe017 	ldw	r2,-128(fp)
 908cfa4:	e0bfdd15 	stw	r2,-140(fp)
 908cfa8:	e0bfdd17 	ldw	r2,-140(fp)
 908cfac:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 908cfb0:	d1206a17 	ldw	r4,-32344(gp)
 908cfb4:	e1bffe84 	addi	r6,fp,-6
 908cfb8:	000b883a 	mov	r5,zero
 908cfbc:	9092c6c0 	call	9092c6c <OSSemPend>
    locks  = 1;
 908cfc0:	00800044 	movi	r2,1
 908cfc4:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 908cfc8:	e0bfe117 	ldw	r2,-124(fp)
 908cfcc:	d0a00915 	stw	r2,-32732(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 908cfd0:	e037883a 	mov	sp,fp
 908cfd4:	dfc00117 	ldw	ra,4(sp)
 908cfd8:	df000017 	ldw	fp,0(sp)
 908cfdc:	dec00204 	addi	sp,sp,8
 908cfe0:	f800283a 	ret

0908cfe4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 908cfe4:	defff804 	addi	sp,sp,-32
 908cfe8:	dfc00715 	stw	ra,28(sp)
 908cfec:	df000615 	stw	fp,24(sp)
 908cff0:	df000604 	addi	fp,sp,24
 908cff4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908cff8:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 908cffc:	00824374 	movhi	r2,2317
 908d000:	108c0544 	addi	r2,r2,12309
 908d004:	10800003 	ldbu	r2,0(r2)
 908d008:	10803fcc 	andi	r2,r2,255
 908d00c:	10800058 	cmpnei	r2,r2,1
 908d010:	1000231e 	bne	r2,zero,908d0a0 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908d014:	0005303a 	rdctl	r2,status
 908d018:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908d01c:	e0fffd17 	ldw	r3,-12(fp)
 908d020:	00bfff84 	movi	r2,-2
 908d024:	1884703a 	and	r2,r3,r2
 908d028:	1001703a 	wrctl	status,r2
  
  return context;
 908d02c:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 908d030:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 908d034:	d0a06917 	ldw	r2,-32348(gp)
 908d038:	1004c03a 	cmpne	r2,r2,zero
 908d03c:	1000051e 	bne	r2,zero,908d054 <__malloc_unlock+0x70>
 908d040:	e0bffe17 	ldw	r2,-8(fp)
 908d044:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908d048:	e0bffc17 	ldw	r2,-16(fp)
 908d04c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 908d050:	00001306 	br	908d0a0 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 908d054:	d0a06917 	ldw	r2,-32348(gp)
 908d058:	10bfffc4 	addi	r2,r2,-1
 908d05c:	d0a06915 	stw	r2,-32348(gp)
 908d060:	d0a06917 	ldw	r2,-32348(gp)
 908d064:	1004c03a 	cmpne	r2,r2,zero
 908d068:	1000091e 	bne	r2,zero,908d090 <__malloc_unlock+0xac>
  {
    lockid = -1;
 908d06c:	00bfffc4 	movi	r2,-1
 908d070:	d0a00915 	stw	r2,-32732(gp)
 908d074:	e0bffe17 	ldw	r2,-8(fp)
 908d078:	e0bffb15 	stw	r2,-20(fp)
 908d07c:	e0bffb17 	ldw	r2,-20(fp)
 908d080:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 908d084:	d1206a17 	ldw	r4,-32344(gp)
 908d088:	90930640 	call	9093064 <OSSemPost>
 908d08c:	00000406 	br	908d0a0 <__malloc_unlock+0xbc>
 908d090:	e0bffe17 	ldw	r2,-8(fp)
 908d094:	e0bffa15 	stw	r2,-24(fp)
 908d098:	e0bffa17 	ldw	r2,-24(fp)
 908d09c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 908d0a0:	e037883a 	mov	sp,fp
 908d0a4:	dfc00117 	ldw	ra,4(sp)
 908d0a8:	df000017 	ldw	fp,0(sp)
 908d0ac:	dec00204 	addi	sp,sp,8
 908d0b0:	f800283a 	ret

0908d0b4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 908d0b4:	defff604 	addi	sp,sp,-40
 908d0b8:	dfc00915 	stw	ra,36(sp)
 908d0bc:	df000815 	stw	fp,32(sp)
 908d0c0:	df000804 	addi	fp,sp,32
 908d0c4:	e13ffc15 	stw	r4,-16(fp)
 908d0c8:	e17ffd15 	stw	r5,-12(fp)
 908d0cc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908d0d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908d0d4:	e0bffe17 	ldw	r2,-8(fp)
 908d0d8:	1004c03a 	cmpne	r2,r2,zero
 908d0dc:	1000021e 	bne	r2,zero,908d0e8 <OSEventNameGet+0x34>
        return (0);
 908d0e0:	e03fff15 	stw	zero,-4(fp)
 908d0e4:	00003906 	br	908d1cc <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 908d0e8:	e0bffc17 	ldw	r2,-16(fp)
 908d0ec:	1004c03a 	cmpne	r2,r2,zero
 908d0f0:	1000051e 	bne	r2,zero,908d108 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 908d0f4:	e0fffe17 	ldw	r3,-8(fp)
 908d0f8:	00800104 	movi	r2,4
 908d0fc:	18800005 	stb	r2,0(r3)
        return (0);
 908d100:	e03fff15 	stw	zero,-4(fp)
 908d104:	00003106 	br	908d1cc <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908d108:	e0bffd17 	ldw	r2,-12(fp)
 908d10c:	1004c03a 	cmpne	r2,r2,zero
 908d110:	1000051e 	bne	r2,zero,908d128 <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 908d114:	e0fffe17 	ldw	r3,-8(fp)
 908d118:	00800304 	movi	r2,12
 908d11c:	18800005 	stb	r2,0(r3)
        return (0);
 908d120:	e03fff15 	stw	zero,-4(fp)
 908d124:	00002906 	br	908d1cc <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908d128:	d0a07903 	ldbu	r2,-32284(gp)
 908d12c:	10803fcc 	andi	r2,r2,255
 908d130:	1005003a 	cmpeq	r2,r2,zero
 908d134:	1000051e 	bne	r2,zero,908d14c <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 908d138:	e0fffe17 	ldw	r3,-8(fp)
 908d13c:	00800444 	movi	r2,17
 908d140:	18800005 	stb	r2,0(r3)
        return (0);
 908d144:	e03fff15 	stw	zero,-4(fp)
 908d148:	00002006 	br	908d1cc <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 908d14c:	e0bffc17 	ldw	r2,-16(fp)
 908d150:	10800003 	ldbu	r2,0(r2)
 908d154:	10803fcc 	andi	r2,r2,255
 908d158:	10bfffc4 	addi	r2,r2,-1
 908d15c:	10800128 	cmpgeui	r2,r2,4
 908d160:	1000161e 	bne	r2,zero,908d1bc <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908d164:	0005303a 	rdctl	r2,status
 908d168:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908d16c:	e0fff917 	ldw	r3,-28(fp)
 908d170:	00bfff84 	movi	r2,-2
 908d174:	1884703a 	and	r2,r3,r2
 908d178:	1001703a 	wrctl	status,r2
  
  return context;
 908d17c:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 908d180:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 908d184:	e0bffc17 	ldw	r2,-16(fp)
 908d188:	11400384 	addi	r5,r2,14
 908d18c:	e13ffd17 	ldw	r4,-12(fp)
 908d190:	908ec380 	call	908ec38 <OS_StrCopy>
 908d194:	e0bffb05 	stb	r2,-20(fp)
 908d198:	e0bffa17 	ldw	r2,-24(fp)
 908d19c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908d1a0:	e0bff817 	ldw	r2,-32(fp)
 908d1a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908d1a8:	e0bffe17 	ldw	r2,-8(fp)
 908d1ac:	10000005 	stb	zero,0(r2)
    return (len);
 908d1b0:	e0bffb03 	ldbu	r2,-20(fp)
 908d1b4:	e0bfff15 	stw	r2,-4(fp)
 908d1b8:	00000406 	br	908d1cc <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 908d1bc:	e0fffe17 	ldw	r3,-8(fp)
 908d1c0:	00800044 	movi	r2,1
 908d1c4:	18800005 	stb	r2,0(r3)
             return (0);
 908d1c8:	e03fff15 	stw	zero,-4(fp)
 908d1cc:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 908d1d0:	e037883a 	mov	sp,fp
 908d1d4:	dfc00117 	ldw	ra,4(sp)
 908d1d8:	df000017 	ldw	fp,0(sp)
 908d1dc:	dec00204 	addi	sp,sp,8
 908d1e0:	f800283a 	ret

0908d1e4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 908d1e4:	defff604 	addi	sp,sp,-40
 908d1e8:	dfc00915 	stw	ra,36(sp)
 908d1ec:	df000815 	stw	fp,32(sp)
 908d1f0:	df000804 	addi	fp,sp,32
 908d1f4:	e13ffd15 	stw	r4,-12(fp)
 908d1f8:	e17ffe15 	stw	r5,-8(fp)
 908d1fc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908d200:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908d204:	e0bfff17 	ldw	r2,-4(fp)
 908d208:	1005003a 	cmpeq	r2,r2,zero
 908d20c:	1000411e 	bne	r2,zero,908d314 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 908d210:	e0bffd17 	ldw	r2,-12(fp)
 908d214:	1004c03a 	cmpne	r2,r2,zero
 908d218:	1000041e 	bne	r2,zero,908d22c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 908d21c:	e0ffff17 	ldw	r3,-4(fp)
 908d220:	00800104 	movi	r2,4
 908d224:	18800005 	stb	r2,0(r3)
        return;
 908d228:	00003a06 	br	908d314 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908d22c:	e0bffe17 	ldw	r2,-8(fp)
 908d230:	1004c03a 	cmpne	r2,r2,zero
 908d234:	1000041e 	bne	r2,zero,908d248 <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 908d238:	e0ffff17 	ldw	r3,-4(fp)
 908d23c:	00800304 	movi	r2,12
 908d240:	18800005 	stb	r2,0(r3)
        return;
 908d244:	00003306 	br	908d314 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908d248:	d0a07903 	ldbu	r2,-32284(gp)
 908d24c:	10803fcc 	andi	r2,r2,255
 908d250:	1005003a 	cmpeq	r2,r2,zero
 908d254:	1000041e 	bne	r2,zero,908d268 <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 908d258:	e0ffff17 	ldw	r3,-4(fp)
 908d25c:	00800484 	movi	r2,18
 908d260:	18800005 	stb	r2,0(r3)
        return;
 908d264:	00002b06 	br	908d314 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 908d268:	e0bffd17 	ldw	r2,-12(fp)
 908d26c:	10800003 	ldbu	r2,0(r2)
 908d270:	10803fcc 	andi	r2,r2,255
 908d274:	10bfffc4 	addi	r2,r2,-1
 908d278:	10800128 	cmpgeui	r2,r2,4
 908d27c:	10000f1e 	bne	r2,zero,908d2bc <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908d280:	0005303a 	rdctl	r2,status
 908d284:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908d288:	e0fffa17 	ldw	r3,-24(fp)
 908d28c:	00bfff84 	movi	r2,-2
 908d290:	1884703a 	and	r2,r3,r2
 908d294:	1001703a 	wrctl	status,r2
  
  return context;
 908d298:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 908d29c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 908d2a0:	e13ffe17 	ldw	r4,-8(fp)
 908d2a4:	908ecb80 	call	908ecb8 <OS_StrLen>
 908d2a8:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 908d2ac:	e0bffc03 	ldbu	r2,-16(fp)
 908d2b0:	10800828 	cmpgeui	r2,r2,32
 908d2b4:	1000051e 	bne	r2,zero,908d2cc <OSEventNameSet+0xe8>
 908d2b8:	00000c06 	br	908d2ec <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 908d2bc:	e0ffff17 	ldw	r3,-4(fp)
 908d2c0:	00800044 	movi	r2,1
 908d2c4:	18800005 	stb	r2,0(r3)
             return;
 908d2c8:	00001206 	br	908d314 <OSEventNameSet+0x130>
 908d2cc:	e0bffb17 	ldw	r2,-20(fp)
 908d2d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908d2d4:	e0bff917 	ldw	r2,-28(fp)
 908d2d8:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 908d2dc:	e0ffff17 	ldw	r3,-4(fp)
 908d2e0:	008002c4 	movi	r2,11
 908d2e4:	18800005 	stb	r2,0(r3)
        return;
 908d2e8:	00000a06 	br	908d314 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 908d2ec:	e0bffd17 	ldw	r2,-12(fp)
 908d2f0:	11000384 	addi	r4,r2,14
 908d2f4:	e17ffe17 	ldw	r5,-8(fp)
 908d2f8:	908ec380 	call	908ec38 <OS_StrCopy>
 908d2fc:	e0bffb17 	ldw	r2,-20(fp)
 908d300:	e0bff815 	stw	r2,-32(fp)
 908d304:	e0bff817 	ldw	r2,-32(fp)
 908d308:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908d30c:	e0bfff17 	ldw	r2,-4(fp)
 908d310:	10000005 	stb	zero,0(r2)
}
 908d314:	e037883a 	mov	sp,fp
 908d318:	dfc00117 	ldw	ra,4(sp)
 908d31c:	df000017 	ldw	fp,0(sp)
 908d320:	dec00204 	addi	sp,sp,8
 908d324:	f800283a 	ret

0908d328 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 908d328:	deffe704 	addi	sp,sp,-100
 908d32c:	dfc01815 	stw	ra,96(sp)
 908d330:	df001715 	stw	fp,92(sp)
 908d334:	df001704 	addi	fp,sp,92
 908d338:	e13ff615 	stw	r4,-40(fp)
 908d33c:	e17ff715 	stw	r5,-36(fp)
 908d340:	e1bff815 	stw	r6,-32(fp)
 908d344:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 908d348:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 908d34c:	e0800217 	ldw	r2,8(fp)
 908d350:	1004c03a 	cmpne	r2,r2,zero
 908d354:	1000021e 	bne	r2,zero,908d360 <OSEventPendMulti+0x38>
        return (0);
 908d358:	e03fff15 	stw	zero,-4(fp)
 908d35c:	00019906 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 908d360:	e0bff617 	ldw	r2,-40(fp)
 908d364:	1004c03a 	cmpne	r2,r2,zero
 908d368:	1000051e 	bne	r2,zero,908d380 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 908d36c:	e0c00217 	ldw	r3,8(fp)
 908d370:	00800104 	movi	r2,4
 908d374:	18800005 	stb	r2,0(r3)
        return (0);
 908d378:	e03fff15 	stw	zero,-4(fp)
 908d37c:	00019106 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 908d380:	e0bff717 	ldw	r2,-36(fp)
 908d384:	1004c03a 	cmpne	r2,r2,zero
 908d388:	1000051e 	bne	r2,zero,908d3a0 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 908d38c:	e0c00217 	ldw	r3,8(fp)
 908d390:	00800104 	movi	r2,4
 908d394:	18800005 	stb	r2,0(r3)
        return (0);
 908d398:	e03fff15 	stw	zero,-4(fp)
 908d39c:	00018906 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 908d3a0:	e0bff817 	ldw	r2,-32(fp)
 908d3a4:	1004c03a 	cmpne	r2,r2,zero
 908d3a8:	1000051e 	bne	r2,zero,908d3c0 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 908d3ac:	e0c00217 	ldw	r3,8(fp)
 908d3b0:	00800104 	movi	r2,4
 908d3b4:	18800005 	stb	r2,0(r3)
        return (0);
 908d3b8:	e03fff15 	stw	zero,-4(fp)
 908d3bc:	00018106 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 908d3c0:	e0bff717 	ldw	r2,-36(fp)
 908d3c4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 908d3c8:	e0bff617 	ldw	r2,-40(fp)
 908d3cc:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 908d3d0:	e0bff517 	ldw	r2,-44(fp)
 908d3d4:	10800017 	ldw	r2,0(r2)
 908d3d8:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 908d3dc:	00001806 	br	908d440 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 908d3e0:	e0bff417 	ldw	r2,-48(fp)
 908d3e4:	10800003 	ldbu	r2,0(r2)
 908d3e8:	10803fcc 	andi	r2,r2,255
 908d3ec:	e0bffe15 	stw	r2,-8(fp)
 908d3f0:	e0fffe17 	ldw	r3,-8(fp)
 908d3f4:	188000a0 	cmpeqi	r2,r3,2
 908d3f8:	10000b1e 	bne	r2,zero,908d428 <OSEventPendMulti+0x100>
 908d3fc:	e0fffe17 	ldw	r3,-8(fp)
 908d400:	188000e0 	cmpeqi	r2,r3,3
 908d404:	1000081e 	bne	r2,zero,908d428 <OSEventPendMulti+0x100>
 908d408:	e0fffe17 	ldw	r3,-8(fp)
 908d40c:	18800060 	cmpeqi	r2,r3,1
 908d410:	1000051e 	bne	r2,zero,908d428 <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 908d414:	e0c00217 	ldw	r3,8(fp)
 908d418:	00800044 	movi	r2,1
 908d41c:	18800005 	stb	r2,0(r3)
                 return (0);
 908d420:	e03fff15 	stw	zero,-4(fp)
 908d424:	00016706 	br	908d9c4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 908d428:	e0bff517 	ldw	r2,-44(fp)
 908d42c:	10800104 	addi	r2,r2,4
 908d430:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 908d434:	e0bff517 	ldw	r2,-44(fp)
 908d438:	10800017 	ldw	r2,0(r2)
 908d43c:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 908d440:	e0bff417 	ldw	r2,-48(fp)
 908d444:	1004c03a 	cmpne	r2,r2,zero
 908d448:	103fe51e 	bne	r2,zero,908d3e0 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 908d44c:	d0a07903 	ldbu	r2,-32284(gp)
 908d450:	10803fcc 	andi	r2,r2,255
 908d454:	1005003a 	cmpeq	r2,r2,zero
 908d458:	1000051e 	bne	r2,zero,908d470 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 908d45c:	e0c00217 	ldw	r3,8(fp)
 908d460:	00800084 	movi	r2,2
 908d464:	18800005 	stb	r2,0(r3)
        return (0);
 908d468:	e03fff15 	stw	zero,-4(fp)
 908d46c:	00015506 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 908d470:	d0a06b03 	ldbu	r2,-32340(gp)
 908d474:	10803fcc 	andi	r2,r2,255
 908d478:	1005003a 	cmpeq	r2,r2,zero
 908d47c:	1000051e 	bne	r2,zero,908d494 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 908d480:	e0c00217 	ldw	r3,8(fp)
 908d484:	00800344 	movi	r2,13
 908d488:	18800005 	stb	r2,0(r3)
        return (0);
 908d48c:	e03fff15 	stw	zero,-4(fp)
 908d490:	00014c06 	br	908d9c4 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908d494:	0005303a 	rdctl	r2,status
 908d498:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908d49c:	e0ffef17 	ldw	r3,-68(fp)
 908d4a0:	00bfff84 	movi	r2,-2
 908d4a4:	1884703a 	and	r2,r3,r2
 908d4a8:	1001703a 	wrctl	status,r2
  
  return context;
 908d4ac:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 908d4b0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 908d4b4:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 908d4b8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 908d4bc:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 908d4c0:	e0bff617 	ldw	r2,-40(fp)
 908d4c4:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 908d4c8:	e0bff517 	ldw	r2,-44(fp)
 908d4cc:	10800017 	ldw	r2,0(r2)
 908d4d0:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 908d4d4:	00008f06 	br	908d714 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 908d4d8:	e0bff417 	ldw	r2,-48(fp)
 908d4dc:	10800003 	ldbu	r2,0(r2)
 908d4e0:	10803fcc 	andi	r2,r2,255
 908d4e4:	e0bffd15 	stw	r2,-12(fp)
 908d4e8:	e0fffd17 	ldw	r3,-12(fp)
 908d4ec:	188000a0 	cmpeqi	r2,r3,2
 908d4f0:	1000441e 	bne	r2,zero,908d604 <OSEventPendMulti+0x2dc>
 908d4f4:	e0fffd17 	ldw	r3,-12(fp)
 908d4f8:	188000e0 	cmpeqi	r2,r3,3
 908d4fc:	1000041e 	bne	r2,zero,908d510 <OSEventPendMulti+0x1e8>
 908d500:	e0fffd17 	ldw	r3,-12(fp)
 908d504:	18800060 	cmpeqi	r2,r3,1
 908d508:	1000211e 	bne	r2,zero,908d590 <OSEventPendMulti+0x268>
 908d50c:	00006f06 	br	908d6cc <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 908d510:	e0bff417 	ldw	r2,-48(fp)
 908d514:	1080020b 	ldhu	r2,8(r2)
 908d518:	10bfffcc 	andi	r2,r2,65535
 908d51c:	1005003a 	cmpeq	r2,r2,zero
 908d520:	1000171e 	bne	r2,zero,908d580 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 908d524:	e0bff417 	ldw	r2,-48(fp)
 908d528:	1080020b 	ldhu	r2,8(r2)
 908d52c:	10bfffc4 	addi	r2,r2,-1
 908d530:	1007883a 	mov	r3,r2
 908d534:	e0bff417 	ldw	r2,-48(fp)
 908d538:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 908d53c:	e0fff717 	ldw	r3,-36(fp)
 908d540:	e0bff417 	ldw	r2,-48(fp)
 908d544:	18800015 	stw	r2,0(r3)
 908d548:	e0bff717 	ldw	r2,-36(fp)
 908d54c:	10800104 	addi	r2,r2,4
 908d550:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 908d554:	00800044 	movi	r2,1
 908d558:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 908d55c:	e0bff817 	ldw	r2,-32(fp)
 908d560:	10000015 	stw	zero,0(r2)
 908d564:	e0bff817 	ldw	r2,-32(fp)
 908d568:	10800104 	addi	r2,r2,4
 908d56c:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 908d570:	e0bff18b 	ldhu	r2,-58(fp)
 908d574:	10800044 	addi	r2,r2,1
 908d578:	e0bff18d 	sth	r2,-58(fp)
 908d57c:	00005f06 	br	908d6fc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 908d580:	e0bff103 	ldbu	r2,-60(fp)
 908d584:	10800054 	ori	r2,r2,1
 908d588:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908d58c:	00005b06 	br	908d6fc <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 908d590:	e0bff417 	ldw	r2,-48(fp)
 908d594:	10800117 	ldw	r2,4(r2)
 908d598:	1005003a 	cmpeq	r2,r2,zero
 908d59c:	1000151e 	bne	r2,zero,908d5f4 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 908d5a0:	e0bff417 	ldw	r2,-48(fp)
 908d5a4:	10c00117 	ldw	r3,4(r2)
 908d5a8:	e0bff817 	ldw	r2,-32(fp)
 908d5ac:	10c00015 	stw	r3,0(r2)
 908d5b0:	e0bff817 	ldw	r2,-32(fp)
 908d5b4:	10800104 	addi	r2,r2,4
 908d5b8:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 908d5bc:	e0bff417 	ldw	r2,-48(fp)
 908d5c0:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 908d5c4:	e0fff717 	ldw	r3,-36(fp)
 908d5c8:	e0bff417 	ldw	r2,-48(fp)
 908d5cc:	18800015 	stw	r2,0(r3)
 908d5d0:	e0bff717 	ldw	r2,-36(fp)
 908d5d4:	10800104 	addi	r2,r2,4
 908d5d8:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 908d5dc:	00800044 	movi	r2,1
 908d5e0:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 908d5e4:	e0bff18b 	ldhu	r2,-58(fp)
 908d5e8:	10800044 	addi	r2,r2,1
 908d5ec:	e0bff18d 	sth	r2,-58(fp)
 908d5f0:	00004206 	br	908d6fc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 908d5f4:	e0bff103 	ldbu	r2,-60(fp)
 908d5f8:	10800094 	ori	r2,r2,2
 908d5fc:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908d600:	00003e06 	br	908d6fc <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 908d604:	e0bff417 	ldw	r2,-48(fp)
 908d608:	10800117 	ldw	r2,4(r2)
 908d60c:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 908d610:	e0bff317 	ldw	r2,-52(fp)
 908d614:	1080058b 	ldhu	r2,22(r2)
 908d618:	10bfffcc 	andi	r2,r2,65535
 908d61c:	1005003a 	cmpeq	r2,r2,zero
 908d620:	1000261e 	bne	r2,zero,908d6bc <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 908d624:	e0bff317 	ldw	r2,-52(fp)
 908d628:	11000417 	ldw	r4,16(r2)
 908d62c:	20c00017 	ldw	r3,0(r4)
 908d630:	e0bff817 	ldw	r2,-32(fp)
 908d634:	10c00015 	stw	r3,0(r2)
 908d638:	e0bff817 	ldw	r2,-32(fp)
 908d63c:	10800104 	addi	r2,r2,4
 908d640:	e0bff815 	stw	r2,-32(fp)
 908d644:	20c00104 	addi	r3,r4,4
 908d648:	e0bff317 	ldw	r2,-52(fp)
 908d64c:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 908d650:	e0bff317 	ldw	r2,-52(fp)
 908d654:	10c00417 	ldw	r3,16(r2)
 908d658:	e0bff317 	ldw	r2,-52(fp)
 908d65c:	10800217 	ldw	r2,8(r2)
 908d660:	1880041e 	bne	r3,r2,908d674 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 908d664:	e0bff317 	ldw	r2,-52(fp)
 908d668:	10c00117 	ldw	r3,4(r2)
 908d66c:	e0bff317 	ldw	r2,-52(fp)
 908d670:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 908d674:	e0bff317 	ldw	r2,-52(fp)
 908d678:	1080058b 	ldhu	r2,22(r2)
 908d67c:	10bfffc4 	addi	r2,r2,-1
 908d680:	1007883a 	mov	r3,r2
 908d684:	e0bff317 	ldw	r2,-52(fp)
 908d688:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 908d68c:	e0fff717 	ldw	r3,-36(fp)
 908d690:	e0bff417 	ldw	r2,-48(fp)
 908d694:	18800015 	stw	r2,0(r3)
 908d698:	e0bff717 	ldw	r2,-36(fp)
 908d69c:	10800104 	addi	r2,r2,4
 908d6a0:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 908d6a4:	00800044 	movi	r2,1
 908d6a8:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 908d6ac:	e0bff18b 	ldhu	r2,-58(fp)
 908d6b0:	10800044 	addi	r2,r2,1
 908d6b4:	e0bff18d 	sth	r2,-58(fp)
 908d6b8:	00001006 	br	908d6fc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 908d6bc:	e0bff103 	ldbu	r2,-60(fp)
 908d6c0:	10800114 	ori	r2,r2,4
 908d6c4:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908d6c8:	00000c06 	br	908d6fc <OSEventPendMulti+0x3d4>
 908d6cc:	e0bff017 	ldw	r2,-64(fp)
 908d6d0:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908d6d4:	e0bfee17 	ldw	r2,-72(fp)
 908d6d8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 908d6dc:	e0bff717 	ldw	r2,-36(fp)
 908d6e0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 908d6e4:	e0c00217 	ldw	r3,8(fp)
 908d6e8:	00800044 	movi	r2,1
 908d6ec:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 908d6f0:	e0bff18b 	ldhu	r2,-58(fp)
 908d6f4:	e0bfff15 	stw	r2,-4(fp)
 908d6f8:	0000b206 	br	908d9c4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 908d6fc:	e0bff517 	ldw	r2,-44(fp)
 908d700:	10800104 	addi	r2,r2,4
 908d704:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 908d708:	e0bff517 	ldw	r2,-44(fp)
 908d70c:	10800017 	ldw	r2,0(r2)
 908d710:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 908d714:	e0bff417 	ldw	r2,-48(fp)
 908d718:	1004c03a 	cmpne	r2,r2,zero
 908d71c:	103f6e1e 	bne	r2,zero,908d4d8 <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 908d720:	e0bff203 	ldbu	r2,-56(fp)
 908d724:	10800058 	cmpnei	r2,r2,1
 908d728:	10000b1e 	bne	r2,zero,908d758 <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 908d72c:	e0bff717 	ldw	r2,-36(fp)
 908d730:	10000015 	stw	zero,0(r2)
 908d734:	e0bff017 	ldw	r2,-64(fp)
 908d738:	e0bfed15 	stw	r2,-76(fp)
 908d73c:	e0bfed17 	ldw	r2,-76(fp)
 908d740:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 908d744:	e0800217 	ldw	r2,8(fp)
 908d748:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 908d74c:	e0fff18b 	ldhu	r3,-58(fp)
 908d750:	e0ffff15 	stw	r3,-4(fp)
 908d754:	00009b06 	br	908d9c4 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 908d758:	d1207a17 	ldw	r4,-32280(gp)
 908d75c:	d0a07a17 	ldw	r2,-32280(gp)
 908d760:	10c00c03 	ldbu	r3,48(r2)
 908d764:	e0bff103 	ldbu	r2,-60(fp)
 908d768:	1884b03a 	or	r2,r3,r2
 908d76c:	1007883a 	mov	r3,r2
 908d770:	00bfe004 	movi	r2,-128
 908d774:	1884b03a 	or	r2,r3,r2
 908d778:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 908d77c:	d0a07a17 	ldw	r2,-32280(gp)
 908d780:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 908d784:	d0e07a17 	ldw	r3,-32280(gp)
 908d788:	e0bff90b 	ldhu	r2,-28(fp)
 908d78c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 908d790:	e13ff617 	ldw	r4,-40(fp)
 908d794:	908e3580 	call	908e358 <OS_EventTaskWaitMulti>
 908d798:	e0bff017 	ldw	r2,-64(fp)
 908d79c:	e0bfec15 	stw	r2,-80(fp)
 908d7a0:	e0bfec17 	ldw	r2,-80(fp)
 908d7a4:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 908d7a8:	908eaf40 	call	908eaf4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908d7ac:	0005303a 	rdctl	r2,status
 908d7b0:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908d7b4:	e0ffeb17 	ldw	r3,-84(fp)
 908d7b8:	00bfff84 	movi	r2,-2
 908d7bc:	1884703a 	and	r2,r3,r2
 908d7c0:	1001703a 	wrctl	status,r2
  
  return context;
 908d7c4:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 908d7c8:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 908d7cc:	d0a07a17 	ldw	r2,-32280(gp)
 908d7d0:	10800c43 	ldbu	r2,49(r2)
 908d7d4:	10803fcc 	andi	r2,r2,255
 908d7d8:	e0bffc15 	stw	r2,-16(fp)
 908d7dc:	e0fffc17 	ldw	r3,-16(fp)
 908d7e0:	1805003a 	cmpeq	r2,r3,zero
 908d7e4:	1000041e 	bne	r2,zero,908d7f8 <OSEventPendMulti+0x4d0>
 908d7e8:	e0fffc17 	ldw	r3,-16(fp)
 908d7ec:	188000a0 	cmpeqi	r2,r3,2
 908d7f0:	1000011e 	bne	r2,zero,908d7f8 <OSEventPendMulti+0x4d0>
 908d7f4:	00001906 	br	908d85c <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 908d7f8:	d0a07a17 	ldw	r2,-32280(gp)
 908d7fc:	10800717 	ldw	r2,28(r2)
 908d800:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 908d804:	e0bff417 	ldw	r2,-48(fp)
 908d808:	1005003a 	cmpeq	r2,r2,zero
 908d80c:	10000c1e 	bne	r2,zero,908d840 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 908d810:	e0fff717 	ldw	r3,-36(fp)
 908d814:	e0bff417 	ldw	r2,-48(fp)
 908d818:	18800015 	stw	r2,0(r3)
 908d81c:	e0bff717 	ldw	r2,-36(fp)
 908d820:	10800104 	addi	r2,r2,4
 908d824:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 908d828:	e0bff717 	ldw	r2,-36(fp)
 908d82c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 908d830:	e0bff18b 	ldhu	r2,-58(fp)
 908d834:	10800044 	addi	r2,r2,1
 908d838:	e0bff18d 	sth	r2,-58(fp)
 908d83c:	00000a06 	br	908d868 <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 908d840:	d0a07a17 	ldw	r2,-32280(gp)
 908d844:	00c00044 	movi	r3,1
 908d848:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 908d84c:	d1207a17 	ldw	r4,-32280(gp)
 908d850:	e17ff617 	ldw	r5,-40(fp)
 908d854:	908e5640 	call	908e564 <OS_EventTaskRemoveMulti>
             }
			 break;
 908d858:	00000306 	br	908d868 <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 908d85c:	d1207a17 	ldw	r4,-32280(gp)
 908d860:	e17ff617 	ldw	r5,-40(fp)
 908d864:	908e5640 	call	908e564 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 908d868:	d0a07a17 	ldw	r2,-32280(gp)
 908d86c:	10800c43 	ldbu	r2,49(r2)
 908d870:	10803fcc 	andi	r2,r2,255
 908d874:	e0bffb15 	stw	r2,-20(fp)
 908d878:	e0fffb17 	ldw	r3,-20(fp)
 908d87c:	1805003a 	cmpeq	r2,r3,zero
 908d880:	1000041e 	bne	r2,zero,908d894 <OSEventPendMulti+0x56c>
 908d884:	e0fffb17 	ldw	r3,-20(fp)
 908d888:	188000a0 	cmpeqi	r2,r3,2
 908d88c:	10002c1e 	bne	r2,zero,908d940 <OSEventPendMulti+0x618>
 908d890:	00003406 	br	908d964 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 908d894:	e0bff417 	ldw	r2,-48(fp)
 908d898:	10800003 	ldbu	r2,0(r2)
 908d89c:	10803fcc 	andi	r2,r2,255
 908d8a0:	e0bffa15 	stw	r2,-24(fp)
 908d8a4:	e0fffa17 	ldw	r3,-24(fp)
 908d8a8:	18800050 	cmplti	r2,r3,1
 908d8ac:	1000151e 	bne	r2,zero,908d904 <OSEventPendMulti+0x5dc>
 908d8b0:	e0fffa17 	ldw	r3,-24(fp)
 908d8b4:	188000d0 	cmplti	r2,r3,3
 908d8b8:	10000a1e 	bne	r2,zero,908d8e4 <OSEventPendMulti+0x5bc>
 908d8bc:	e0fffa17 	ldw	r3,-24(fp)
 908d8c0:	188000e0 	cmpeqi	r2,r3,3
 908d8c4:	1000011e 	bne	r2,zero,908d8cc <OSEventPendMulti+0x5a4>
 908d8c8:	00000e06 	br	908d904 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 908d8cc:	e0bff817 	ldw	r2,-32(fp)
 908d8d0:	10000015 	stw	zero,0(r2)
 908d8d4:	e0bff817 	ldw	r2,-32(fp)
 908d8d8:	10800104 	addi	r2,r2,4
 908d8dc:	e0bff815 	stw	r2,-32(fp)
                      break;
 908d8e0:	00001406 	br	908d934 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 908d8e4:	d0a07a17 	ldw	r2,-32280(gp)
 908d8e8:	10c00917 	ldw	r3,36(r2)
 908d8ec:	e0bff817 	ldw	r2,-32(fp)
 908d8f0:	10c00015 	stw	r3,0(r2)
 908d8f4:	e0bff817 	ldw	r2,-32(fp)
 908d8f8:	10800104 	addi	r2,r2,4
 908d8fc:	e0bff815 	stw	r2,-32(fp)
                      break;
 908d900:	00000c06 	br	908d934 <OSEventPendMulti+0x60c>
 908d904:	e0bff017 	ldw	r2,-64(fp)
 908d908:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908d90c:	e0bfea17 	ldw	r2,-88(fp)
 908d910:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 908d914:	e0bff717 	ldw	r2,-36(fp)
 908d918:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 908d91c:	e0c00217 	ldw	r3,8(fp)
 908d920:	00800044 	movi	r2,1
 908d924:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 908d928:	e0bff18b 	ldhu	r2,-58(fp)
 908d92c:	e0bfff15 	stw	r2,-4(fp)
 908d930:	00002406 	br	908d9c4 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 908d934:	e0800217 	ldw	r2,8(fp)
 908d938:	10000005 	stb	zero,0(r2)
             break;
 908d93c:	00001106 	br	908d984 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 908d940:	e0bff817 	ldw	r2,-32(fp)
 908d944:	10000015 	stw	zero,0(r2)
 908d948:	e0bff817 	ldw	r2,-32(fp)
 908d94c:	10800104 	addi	r2,r2,4
 908d950:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 908d954:	e0c00217 	ldw	r3,8(fp)
 908d958:	00800384 	movi	r2,14
 908d95c:	18800005 	stb	r2,0(r3)
             break;
 908d960:	00000806 	br	908d984 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 908d964:	e0bff817 	ldw	r2,-32(fp)
 908d968:	10000015 	stw	zero,0(r2)
 908d96c:	e0bff817 	ldw	r2,-32(fp)
 908d970:	10800104 	addi	r2,r2,4
 908d974:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 908d978:	e0c00217 	ldw	r3,8(fp)
 908d97c:	00800284 	movi	r2,10
 908d980:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 908d984:	d0a07a17 	ldw	r2,-32280(gp)
 908d988:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 908d98c:	d0a07a17 	ldw	r2,-32280(gp)
 908d990:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 908d994:	d0a07a17 	ldw	r2,-32280(gp)
 908d998:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 908d99c:	d0a07a17 	ldw	r2,-32280(gp)
 908d9a0:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 908d9a4:	d0a07a17 	ldw	r2,-32280(gp)
 908d9a8:	10000915 	stw	zero,36(r2)
 908d9ac:	e0bff017 	ldw	r2,-64(fp)
 908d9b0:	e0bfe915 	stw	r2,-92(fp)
 908d9b4:	e0bfe917 	ldw	r2,-92(fp)
 908d9b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 908d9bc:	e0fff18b 	ldhu	r3,-58(fp)
 908d9c0:	e0ffff15 	stw	r3,-4(fp)
 908d9c4:	e0bfff17 	ldw	r2,-4(fp)
}
 908d9c8:	e037883a 	mov	sp,fp
 908d9cc:	dfc00117 	ldw	ra,4(sp)
 908d9d0:	df000017 	ldw	fp,0(sp)
 908d9d4:	dec00204 	addi	sp,sp,8
 908d9d8:	f800283a 	ret

0908d9dc <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 908d9dc:	defffe04 	addi	sp,sp,-8
 908d9e0:	dfc00115 	stw	ra,4(sp)
 908d9e4:	df000015 	stw	fp,0(sp)
 908d9e8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 908d9ec:	90ba2e40 	call	90ba2e4 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 908d9f0:	908e7ac0 	call	908e7ac <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 908d9f4:	908e7f00 	call	908e7f0 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 908d9f8:	908e9540 	call	908e954 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 908d9fc:	908e6d00 	call	908e6d0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 908da00:	9090a1c0 	call	9090a1c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 908da04:	90913f40 	call	90913f4 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 908da08:	909274c0 	call	909274c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 908da0c:	908e85c0 	call	908e85c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 908da10:	908e8d80 	call	908e8d8 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 908da14:	90ba3000 	call	90ba300 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 908da18:	908f1f40 	call	908f1f4 <OSDebugInit>
#endif
}
 908da1c:	e037883a 	mov	sp,fp
 908da20:	dfc00117 	ldw	ra,4(sp)
 908da24:	df000017 	ldw	fp,0(sp)
 908da28:	dec00204 	addi	sp,sp,8
 908da2c:	f800283a 	ret

0908da30 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 908da30:	defffc04 	addi	sp,sp,-16
 908da34:	df000315 	stw	fp,12(sp)
 908da38:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908da3c:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 908da40:	d0a06b43 	ldbu	r2,-32339(gp)
 908da44:	10803fcc 	andi	r2,r2,255
 908da48:	10800058 	cmpnei	r2,r2,1
 908da4c:	1000131e 	bne	r2,zero,908da9c <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908da50:	0005303a 	rdctl	r2,status
 908da54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908da58:	e0fffe17 	ldw	r3,-8(fp)
 908da5c:	00bfff84 	movi	r2,-2
 908da60:	1884703a 	and	r2,r3,r2
 908da64:	1001703a 	wrctl	status,r2
  
  return context;
 908da68:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908da6c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 908da70:	d0a07903 	ldbu	r2,-32284(gp)
 908da74:	10803fcc 	andi	r2,r2,255
 908da78:	10803fe0 	cmpeqi	r2,r2,255
 908da7c:	1000031e 	bne	r2,zero,908da8c <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 908da80:	d0a07903 	ldbu	r2,-32284(gp)
 908da84:	10800044 	addi	r2,r2,1
 908da88:	d0a07905 	stb	r2,-32284(gp)
 908da8c:	e0bfff17 	ldw	r2,-4(fp)
 908da90:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908da94:	e0bffd17 	ldw	r2,-12(fp)
 908da98:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 908da9c:	e037883a 	mov	sp,fp
 908daa0:	df000017 	ldw	fp,0(sp)
 908daa4:	dec00104 	addi	sp,sp,4
 908daa8:	f800283a 	ret

0908daac <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 908daac:	defffb04 	addi	sp,sp,-20
 908dab0:	dfc00415 	stw	ra,16(sp)
 908dab4:	df000315 	stw	fp,12(sp)
 908dab8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908dabc:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 908dac0:	d0a06b43 	ldbu	r2,-32339(gp)
 908dac4:	10803fcc 	andi	r2,r2,255
 908dac8:	10800058 	cmpnei	r2,r2,1
 908dacc:	1000321e 	bne	r2,zero,908db98 <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dad0:	0005303a 	rdctl	r2,status
 908dad4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908dad8:	e0fffe17 	ldw	r3,-8(fp)
 908dadc:	00bfff84 	movi	r2,-2
 908dae0:	1884703a 	and	r2,r3,r2
 908dae4:	1001703a 	wrctl	status,r2
  
  return context;
 908dae8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908daec:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 908daf0:	d0a07903 	ldbu	r2,-32284(gp)
 908daf4:	10803fcc 	andi	r2,r2,255
 908daf8:	1005003a 	cmpeq	r2,r2,zero
 908dafc:	1000031e 	bne	r2,zero,908db0c <OSIntExit+0x60>
            OSIntNesting--;
 908db00:	d0a07903 	ldbu	r2,-32284(gp)
 908db04:	10bfffc4 	addi	r2,r2,-1
 908db08:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 908db0c:	d0a07903 	ldbu	r2,-32284(gp)
 908db10:	10803fcc 	andi	r2,r2,255
 908db14:	1004c03a 	cmpne	r2,r2,zero
 908db18:	10001b1e 	bne	r2,zero,908db88 <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 908db1c:	d0a06b03 	ldbu	r2,-32340(gp)
 908db20:	10803fcc 	andi	r2,r2,255
 908db24:	1004c03a 	cmpne	r2,r2,zero
 908db28:	1000171e 	bne	r2,zero,908db88 <OSIntExit+0xdc>
                OS_SchedNew();
 908db2c:	908ebc80 	call	908ebc8 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 908db30:	d0a06d03 	ldbu	r2,-32332(gp)
 908db34:	d0e06d43 	ldbu	r3,-32331(gp)
 908db38:	11003fcc 	andi	r4,r2,255
 908db3c:	18803fcc 	andi	r2,r3,255
 908db40:	20801126 	beq	r4,r2,908db88 <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 908db44:	d0a06d03 	ldbu	r2,-32332(gp)
 908db48:	10803fcc 	andi	r2,r2,255
 908db4c:	00c243b4 	movhi	r3,2318
 908db50:	18f2ac04 	addi	r3,r3,-13648
 908db54:	1085883a 	add	r2,r2,r2
 908db58:	1085883a 	add	r2,r2,r2
 908db5c:	10c5883a 	add	r2,r2,r3
 908db60:	10800017 	ldw	r2,0(r2)
 908db64:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 908db68:	d0e07517 	ldw	r3,-32300(gp)
 908db6c:	18800e17 	ldw	r2,56(r3)
 908db70:	10800044 	addi	r2,r2,1
 908db74:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 908db78:	d0a07017 	ldw	r2,-32320(gp)
 908db7c:	10800044 	addi	r2,r2,1
 908db80:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 908db84:	90b9e640 	call	90b9e64 <OSCtxSw>
 908db88:	e0bfff17 	ldw	r2,-4(fp)
 908db8c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908db90:	e0bffd17 	ldw	r2,-12(fp)
 908db94:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 908db98:	e037883a 	mov	sp,fp
 908db9c:	dfc00117 	ldw	ra,4(sp)
 908dba0:	df000017 	ldw	fp,0(sp)
 908dba4:	dec00204 	addi	sp,sp,8
 908dba8:	f800283a 	ret

0908dbac <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 908dbac:	defffc04 	addi	sp,sp,-16
 908dbb0:	df000315 	stw	fp,12(sp)
 908dbb4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908dbb8:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 908dbbc:	d0a06b43 	ldbu	r2,-32339(gp)
 908dbc0:	10803fcc 	andi	r2,r2,255
 908dbc4:	10800058 	cmpnei	r2,r2,1
 908dbc8:	1000171e 	bne	r2,zero,908dc28 <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dbcc:	0005303a 	rdctl	r2,status
 908dbd0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908dbd4:	e0fffe17 	ldw	r3,-8(fp)
 908dbd8:	00bfff84 	movi	r2,-2
 908dbdc:	1884703a 	and	r2,r3,r2
 908dbe0:	1001703a 	wrctl	status,r2
  
  return context;
 908dbe4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908dbe8:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 908dbec:	d0a07903 	ldbu	r2,-32284(gp)
 908dbf0:	10803fcc 	andi	r2,r2,255
 908dbf4:	1004c03a 	cmpne	r2,r2,zero
 908dbf8:	1000071e 	bne	r2,zero,908dc18 <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 908dbfc:	d0a06b03 	ldbu	r2,-32340(gp)
 908dc00:	10803fcc 	andi	r2,r2,255
 908dc04:	10803fe0 	cmpeqi	r2,r2,255
 908dc08:	1000031e 	bne	r2,zero,908dc18 <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 908dc0c:	d0a06b03 	ldbu	r2,-32340(gp)
 908dc10:	10800044 	addi	r2,r2,1
 908dc14:	d0a06b05 	stb	r2,-32340(gp)
 908dc18:	e0bfff17 	ldw	r2,-4(fp)
 908dc1c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908dc20:	e0bffd17 	ldw	r2,-12(fp)
 908dc24:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 908dc28:	e037883a 	mov	sp,fp
 908dc2c:	df000017 	ldw	fp,0(sp)
 908dc30:	dec00104 	addi	sp,sp,4
 908dc34:	f800283a 	ret

0908dc38 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 908dc38:	defff804 	addi	sp,sp,-32
 908dc3c:	dfc00715 	stw	ra,28(sp)
 908dc40:	df000615 	stw	fp,24(sp)
 908dc44:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908dc48:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 908dc4c:	d0a06b43 	ldbu	r2,-32339(gp)
 908dc50:	10803fcc 	andi	r2,r2,255
 908dc54:	10800058 	cmpnei	r2,r2,1
 908dc58:	10002b1e 	bne	r2,zero,908dd08 <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dc5c:	0005303a 	rdctl	r2,status
 908dc60:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908dc64:	e0fffe17 	ldw	r3,-8(fp)
 908dc68:	00bfff84 	movi	r2,-2
 908dc6c:	1884703a 	and	r2,r3,r2
 908dc70:	1001703a 	wrctl	status,r2
  
  return context;
 908dc74:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908dc78:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 908dc7c:	d0a06b03 	ldbu	r2,-32340(gp)
 908dc80:	10803fcc 	andi	r2,r2,255
 908dc84:	1005003a 	cmpeq	r2,r2,zero
 908dc88:	10001b1e 	bne	r2,zero,908dcf8 <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 908dc8c:	d0a06b03 	ldbu	r2,-32340(gp)
 908dc90:	10bfffc4 	addi	r2,r2,-1
 908dc94:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 908dc98:	d0a06b03 	ldbu	r2,-32340(gp)
 908dc9c:	10803fcc 	andi	r2,r2,255
 908dca0:	1004c03a 	cmpne	r2,r2,zero
 908dca4:	10000f1e 	bne	r2,zero,908dce4 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 908dca8:	d0a07903 	ldbu	r2,-32284(gp)
 908dcac:	10803fcc 	andi	r2,r2,255
 908dcb0:	1004c03a 	cmpne	r2,r2,zero
 908dcb4:	1000061e 	bne	r2,zero,908dcd0 <OSSchedUnlock+0x98>
 908dcb8:	e0bfff17 	ldw	r2,-4(fp)
 908dcbc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908dcc0:	e0bffd17 	ldw	r2,-12(fp)
 908dcc4:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 908dcc8:	908eaf40 	call	908eaf4 <OS_Sched>
 908dccc:	00000e06 	br	908dd08 <OSSchedUnlock+0xd0>
 908dcd0:	e0bfff17 	ldw	r2,-4(fp)
 908dcd4:	e0bffc15 	stw	r2,-16(fp)
 908dcd8:	e0bffc17 	ldw	r2,-16(fp)
 908dcdc:	1001703a 	wrctl	status,r2
 908dce0:	00000906 	br	908dd08 <OSSchedUnlock+0xd0>
 908dce4:	e0bfff17 	ldw	r2,-4(fp)
 908dce8:	e0bffb15 	stw	r2,-20(fp)
 908dcec:	e0bffb17 	ldw	r2,-20(fp)
 908dcf0:	1001703a 	wrctl	status,r2
 908dcf4:	00000406 	br	908dd08 <OSSchedUnlock+0xd0>
 908dcf8:	e0bfff17 	ldw	r2,-4(fp)
 908dcfc:	e0bffa15 	stw	r2,-24(fp)
 908dd00:	e0bffa17 	ldw	r2,-24(fp)
 908dd04:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 908dd08:	e037883a 	mov	sp,fp
 908dd0c:	dfc00117 	ldw	ra,4(sp)
 908dd10:	df000017 	ldw	fp,0(sp)
 908dd14:	dec00204 	addi	sp,sp,8
 908dd18:	f800283a 	ret

0908dd1c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 908dd1c:	defffe04 	addi	sp,sp,-8
 908dd20:	dfc00115 	stw	ra,4(sp)
 908dd24:	df000015 	stw	fp,0(sp)
 908dd28:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 908dd2c:	d0a06b43 	ldbu	r2,-32339(gp)
 908dd30:	10803fcc 	andi	r2,r2,255
 908dd34:	1004c03a 	cmpne	r2,r2,zero
 908dd38:	10000f1e 	bne	r2,zero,908dd78 <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 908dd3c:	908ebc80 	call	908ebc8 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 908dd40:	d0a06d03 	ldbu	r2,-32332(gp)
 908dd44:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 908dd48:	d0a06d03 	ldbu	r2,-32332(gp)
 908dd4c:	10803fcc 	andi	r2,r2,255
 908dd50:	00c243b4 	movhi	r3,2318
 908dd54:	18f2ac04 	addi	r3,r3,-13648
 908dd58:	1085883a 	add	r2,r2,r2
 908dd5c:	1085883a 	add	r2,r2,r2
 908dd60:	10c5883a 	add	r2,r2,r3
 908dd64:	10800017 	ldw	r2,0(r2)
 908dd68:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 908dd6c:	d0a07517 	ldw	r2,-32300(gp)
 908dd70:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 908dd74:	90b9ef00 	call	90b9ef0 <OSStartHighRdy>
    }
}
 908dd78:	e037883a 	mov	sp,fp
 908dd7c:	dfc00117 	ldw	ra,4(sp)
 908dd80:	df000017 	ldw	fp,0(sp)
 908dd84:	dec00204 	addi	sp,sp,8
 908dd88:	f800283a 	ret

0908dd8c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 908dd8c:	defff904 	addi	sp,sp,-28
 908dd90:	dfc00615 	stw	ra,24(sp)
 908dd94:	df000515 	stw	fp,20(sp)
 908dd98:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908dd9c:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 908dda0:	01000084 	movi	r4,2
 908dda4:	9094e000 	call	9094e00 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dda8:	0005303a 	rdctl	r2,status
 908ddac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ddb0:	e0fffe17 	ldw	r3,-8(fp)
 908ddb4:	00bfff84 	movi	r2,-2
 908ddb8:	1884703a 	and	r2,r3,r2
 908ddbc:	1001703a 	wrctl	status,r2
  
  return context;
 908ddc0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 908ddc4:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 908ddc8:	d0206c15 	stw	zero,-32336(gp)
 908ddcc:	e0bfff17 	ldw	r2,-4(fp)
 908ddd0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ddd4:	e0bffd17 	ldw	r2,-12(fp)
 908ddd8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 908dddc:	01000284 	movi	r4,10
 908dde0:	9094e000 	call	9094e00 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dde4:	0005303a 	rdctl	r2,status
 908dde8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ddec:	e0fffc17 	ldw	r3,-16(fp)
 908ddf0:	00bfff84 	movi	r2,-2
 908ddf4:	1884703a 	and	r2,r3,r2
 908ddf8:	1001703a 	wrctl	status,r2
  
  return context;
 908ddfc:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 908de00:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 908de04:	d0a06c17 	ldw	r2,-32336(gp)
 908de08:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 908de0c:	00800044 	movi	r2,1
 908de10:	d0a07d05 	stb	r2,-32268(gp)
 908de14:	e0bfff17 	ldw	r2,-4(fp)
 908de18:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908de1c:	e0bffb17 	ldw	r2,-20(fp)
 908de20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 908de24:	e037883a 	mov	sp,fp
 908de28:	dfc00117 	ldw	ra,4(sp)
 908de2c:	df000017 	ldw	fp,0(sp)
 908de30:	dec00204 	addi	sp,sp,8
 908de34:	f800283a 	ret

0908de38 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 908de38:	defff604 	addi	sp,sp,-40
 908de3c:	dfc00915 	stw	ra,36(sp)
 908de40:	df000815 	stw	fp,32(sp)
 908de44:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 908de48:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 908de4c:	90ba2bc0 	call	90ba2bc <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908de50:	0005303a 	rdctl	r2,status
 908de54:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908de58:	e0fffb17 	ldw	r3,-20(fp)
 908de5c:	00bfff84 	movi	r2,-2
 908de60:	1884703a 	and	r2,r3,r2
 908de64:	1001703a 	wrctl	status,r2
  
  return context;
 908de68:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 908de6c:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 908de70:	d0a07b17 	ldw	r2,-32276(gp)
 908de74:	10800044 	addi	r2,r2,1
 908de78:	d0a07b15 	stw	r2,-32276(gp)
 908de7c:	e0bffc17 	ldw	r2,-16(fp)
 908de80:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908de84:	e0bffa17 	ldw	r2,-24(fp)
 908de88:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 908de8c:	d0a06b43 	ldbu	r2,-32339(gp)
 908de90:	10803fcc 	andi	r2,r2,255
 908de94:	10800058 	cmpnei	r2,r2,1
 908de98:	1000721e 	bne	r2,zero,908e064 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 908de9c:	d0a06f03 	ldbu	r2,-32324(gp)
 908dea0:	10803fcc 	andi	r2,r2,255
 908dea4:	e0bfff15 	stw	r2,-4(fp)
 908dea8:	e0ffff17 	ldw	r3,-4(fp)
 908deac:	18800060 	cmpeqi	r2,r3,1
 908deb0:	10000a1e 	bne	r2,zero,908dedc <OSTimeTick+0xa4>
 908deb4:	e0ffff17 	ldw	r3,-4(fp)
 908deb8:	188000a0 	cmpeqi	r2,r3,2
 908debc:	1000091e 	bne	r2,zero,908dee4 <OSTimeTick+0xac>
 908dec0:	e0ffff17 	ldw	r3,-4(fp)
 908dec4:	1805003a 	cmpeq	r2,r3,zero
 908dec8:	1000011e 	bne	r2,zero,908ded0 <OSTimeTick+0x98>
 908decc:	00000a06 	br	908def8 <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 908ded0:	00800044 	movi	r2,1
 908ded4:	e0bffd05 	stb	r2,-12(fp)
                 break;
 908ded8:	00000a06 	br	908df04 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 908dedc:	e03ffd05 	stb	zero,-12(fp)
                 break;
 908dee0:	00000806 	br	908df04 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 908dee4:	00800044 	movi	r2,1
 908dee8:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 908deec:	00800044 	movi	r2,1
 908def0:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 908def4:	00000306 	br	908df04 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 908def8:	00800044 	movi	r2,1
 908defc:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 908df00:	d0206f05 	stb	zero,-32324(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 908df04:	e0bffd03 	ldbu	r2,-12(fp)
 908df08:	1005003a 	cmpeq	r2,r2,zero
 908df0c:	1000551e 	bne	r2,zero,908e064 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 908df10:	d0a06e17 	ldw	r2,-32328(gp)
 908df14:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 908df18:	00004d06 	br	908e050 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908df1c:	0005303a 	rdctl	r2,status
 908df20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908df24:	e0fff917 	ldw	r3,-28(fp)
 908df28:	00bfff84 	movi	r2,-2
 908df2c:	1884703a 	and	r2,r3,r2
 908df30:	1001703a 	wrctl	status,r2
  
  return context;
 908df34:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 908df38:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 908df3c:	e0bffe17 	ldw	r2,-8(fp)
 908df40:	10800b8b 	ldhu	r2,46(r2)
 908df44:	10bfffcc 	andi	r2,r2,65535
 908df48:	1005003a 	cmpeq	r2,r2,zero
 908df4c:	1000391e 	bne	r2,zero,908e034 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 908df50:	e0bffe17 	ldw	r2,-8(fp)
 908df54:	10800b8b 	ldhu	r2,46(r2)
 908df58:	10bfffc4 	addi	r2,r2,-1
 908df5c:	1007883a 	mov	r3,r2
 908df60:	e0bffe17 	ldw	r2,-8(fp)
 908df64:	10c00b8d 	sth	r3,46(r2)
 908df68:	e0bffe17 	ldw	r2,-8(fp)
 908df6c:	10800b8b 	ldhu	r2,46(r2)
 908df70:	10bfffcc 	andi	r2,r2,65535
 908df74:	1004c03a 	cmpne	r2,r2,zero
 908df78:	10002e1e 	bne	r2,zero,908e034 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 908df7c:	e0bffe17 	ldw	r2,-8(fp)
 908df80:	10800c03 	ldbu	r2,48(r2)
 908df84:	10803fcc 	andi	r2,r2,255
 908df88:	10800dcc 	andi	r2,r2,55
 908df8c:	1005003a 	cmpeq	r2,r2,zero
 908df90:	10000b1e 	bne	r2,zero,908dfc0 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 908df94:	e0bffe17 	ldw	r2,-8(fp)
 908df98:	10c00c03 	ldbu	r3,48(r2)
 908df9c:	00bff204 	movi	r2,-56
 908dfa0:	1884703a 	and	r2,r3,r2
 908dfa4:	1007883a 	mov	r3,r2
 908dfa8:	e0bffe17 	ldw	r2,-8(fp)
 908dfac:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 908dfb0:	e0fffe17 	ldw	r3,-8(fp)
 908dfb4:	00800044 	movi	r2,1
 908dfb8:	18800c45 	stb	r2,49(r3)
 908dfbc:	00000206 	br	908dfc8 <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 908dfc0:	e0bffe17 	ldw	r2,-8(fp)
 908dfc4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 908dfc8:	e0bffe17 	ldw	r2,-8(fp)
 908dfcc:	10800c03 	ldbu	r2,48(r2)
 908dfd0:	10803fcc 	andi	r2,r2,255
 908dfd4:	1080020c 	andi	r2,r2,8
 908dfd8:	1004c03a 	cmpne	r2,r2,zero
 908dfdc:	1000151e 	bne	r2,zero,908e034 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 908dfe0:	e0bffe17 	ldw	r2,-8(fp)
 908dfe4:	10c00d83 	ldbu	r3,54(r2)
 908dfe8:	d0a07703 	ldbu	r2,-32292(gp)
 908dfec:	1884b03a 	or	r2,r3,r2
 908dff0:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 908dff4:	e0bffe17 	ldw	r2,-8(fp)
 908dff8:	10800d03 	ldbu	r2,52(r2)
 908dffc:	11003fcc 	andi	r4,r2,255
 908e000:	e0bffe17 	ldw	r2,-8(fp)
 908e004:	10800d03 	ldbu	r2,52(r2)
 908e008:	10c03fcc 	andi	r3,r2,255
 908e00c:	d0a07744 	addi	r2,gp,-32291
 908e010:	1885883a 	add	r2,r3,r2
 908e014:	10c00003 	ldbu	r3,0(r2)
 908e018:	e0bffe17 	ldw	r2,-8(fp)
 908e01c:	10800d43 	ldbu	r2,53(r2)
 908e020:	1884b03a 	or	r2,r3,r2
 908e024:	1007883a 	mov	r3,r2
 908e028:	d0a07744 	addi	r2,gp,-32291
 908e02c:	2085883a 	add	r2,r4,r2
 908e030:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 908e034:	e0bffe17 	ldw	r2,-8(fp)
 908e038:	10800517 	ldw	r2,20(r2)
 908e03c:	e0bffe15 	stw	r2,-8(fp)
 908e040:	e0bffc17 	ldw	r2,-16(fp)
 908e044:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e048:	e0bff817 	ldw	r2,-32(fp)
 908e04c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 908e050:	e0bffe17 	ldw	r2,-8(fp)
 908e054:	10800c83 	ldbu	r2,50(r2)
 908e058:	10803fcc 	andi	r2,r2,255
 908e05c:	10800518 	cmpnei	r2,r2,20
 908e060:	103fae1e 	bne	r2,zero,908df1c <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 908e064:	e037883a 	mov	sp,fp
 908e068:	dfc00117 	ldw	ra,4(sp)
 908e06c:	df000017 	ldw	fp,0(sp)
 908e070:	dec00204 	addi	sp,sp,8
 908e074:	f800283a 	ret

0908e078 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 908e078:	deffff04 	addi	sp,sp,-4
 908e07c:	df000015 	stw	fp,0(sp)
 908e080:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 908e084:	00804784 	movi	r2,286
}
 908e088:	e037883a 	mov	sp,fp
 908e08c:	df000017 	ldw	fp,0(sp)
 908e090:	dec00104 	addi	sp,sp,4
 908e094:	f800283a 	ret

0908e098 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 908e098:	deffff04 	addi	sp,sp,-4
 908e09c:	df000015 	stw	fp,0(sp)
 908e0a0:	d839883a 	mov	fp,sp
}
 908e0a4:	e037883a 	mov	sp,fp
 908e0a8:	df000017 	ldw	fp,0(sp)
 908e0ac:	dec00104 	addi	sp,sp,4
 908e0b0:	f800283a 	ret

0908e0b4 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 908e0b4:	defff804 	addi	sp,sp,-32
 908e0b8:	dfc00715 	stw	ra,28(sp)
 908e0bc:	df000615 	stw	fp,24(sp)
 908e0c0:	df000604 	addi	fp,sp,24
 908e0c4:	e13ffc15 	stw	r4,-16(fp)
 908e0c8:	e17ffd15 	stw	r5,-12(fp)
 908e0cc:	e1bffe05 	stb	r6,-8(fp)
 908e0d0:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 908e0d4:	e0bffc17 	ldw	r2,-16(fp)
 908e0d8:	10800283 	ldbu	r2,10(r2)
 908e0dc:	10c03fcc 	andi	r3,r2,255
 908e0e0:	00824374 	movhi	r2,2317
 908e0e4:	10b32f04 	addi	r2,r2,-13124
 908e0e8:	10c5883a 	add	r2,r2,r3
 908e0ec:	10800003 	ldbu	r2,0(r2)
 908e0f0:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 908e0f4:	e0fffa83 	ldbu	r3,-22(fp)
 908e0f8:	e0bffc17 	ldw	r2,-16(fp)
 908e0fc:	1885883a 	add	r2,r3,r2
 908e100:	10800204 	addi	r2,r2,8
 908e104:	108000c3 	ldbu	r2,3(r2)
 908e108:	10c03fcc 	andi	r3,r2,255
 908e10c:	00824374 	movhi	r2,2317
 908e110:	10b32f04 	addi	r2,r2,-13124
 908e114:	10c5883a 	add	r2,r2,r3
 908e118:	10800003 	ldbu	r2,0(r2)
 908e11c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 908e120:	e0bffa83 	ldbu	r2,-22(fp)
 908e124:	100490fa 	slli	r2,r2,3
 908e128:	1007883a 	mov	r3,r2
 908e12c:	e0bffa43 	ldbu	r2,-23(fp)
 908e130:	1885883a 	add	r2,r3,r2
 908e134:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 908e138:	e0bffa03 	ldbu	r2,-24(fp)
 908e13c:	00c243b4 	movhi	r3,2318
 908e140:	18f2ac04 	addi	r3,r3,-13648
 908e144:	1085883a 	add	r2,r2,r2
 908e148:	1085883a 	add	r2,r2,r2
 908e14c:	10c5883a 	add	r2,r2,r3
 908e150:	10800017 	ldw	r2,0(r2)
 908e154:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 908e158:	e0bffb17 	ldw	r2,-20(fp)
 908e15c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 908e160:	e0fffb17 	ldw	r3,-20(fp)
 908e164:	e0bffd17 	ldw	r2,-12(fp)
 908e168:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 908e16c:	e0bffb17 	ldw	r2,-20(fp)
 908e170:	10800c03 	ldbu	r2,48(r2)
 908e174:	1007883a 	mov	r3,r2
 908e178:	e0bffe03 	ldbu	r2,-8(fp)
 908e17c:	0084303a 	nor	r2,zero,r2
 908e180:	1884703a 	and	r2,r3,r2
 908e184:	1007883a 	mov	r3,r2
 908e188:	e0bffb17 	ldw	r2,-20(fp)
 908e18c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 908e190:	e0fffb17 	ldw	r3,-20(fp)
 908e194:	e0bfff03 	ldbu	r2,-4(fp)
 908e198:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 908e19c:	e0bffb17 	ldw	r2,-20(fp)
 908e1a0:	10800c03 	ldbu	r2,48(r2)
 908e1a4:	10803fcc 	andi	r2,r2,255
 908e1a8:	1080020c 	andi	r2,r2,8
 908e1ac:	1004c03a 	cmpne	r2,r2,zero
 908e1b0:	1000111e 	bne	r2,zero,908e1f8 <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 908e1b4:	e0bffb17 	ldw	r2,-20(fp)
 908e1b8:	10c00d83 	ldbu	r3,54(r2)
 908e1bc:	d0a07703 	ldbu	r2,-32292(gp)
 908e1c0:	1884b03a 	or	r2,r3,r2
 908e1c4:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 908e1c8:	e13ffa83 	ldbu	r4,-22(fp)
 908e1cc:	e0fffa83 	ldbu	r3,-22(fp)
 908e1d0:	d0a07744 	addi	r2,gp,-32291
 908e1d4:	1885883a 	add	r2,r3,r2
 908e1d8:	10c00003 	ldbu	r3,0(r2)
 908e1dc:	e0bffb17 	ldw	r2,-20(fp)
 908e1e0:	10800d43 	ldbu	r2,53(r2)
 908e1e4:	1884b03a 	or	r2,r3,r2
 908e1e8:	1007883a 	mov	r3,r2
 908e1ec:	d0a07744 	addi	r2,gp,-32291
 908e1f0:	2085883a 	add	r2,r4,r2
 908e1f4:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 908e1f8:	e13ffb17 	ldw	r4,-20(fp)
 908e1fc:	e17ffc17 	ldw	r5,-16(fp)
 908e200:	908e4ac0 	call	908e4ac <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 908e204:	e0bffb17 	ldw	r2,-20(fp)
 908e208:	10800817 	ldw	r2,32(r2)
 908e20c:	1005003a 	cmpeq	r2,r2,zero
 908e210:	1000071e 	bne	r2,zero,908e230 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 908e214:	e0bffb17 	ldw	r2,-20(fp)
 908e218:	11400817 	ldw	r5,32(r2)
 908e21c:	e13ffb17 	ldw	r4,-20(fp)
 908e220:	908e5640 	call	908e564 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 908e224:	e0fffb17 	ldw	r3,-20(fp)
 908e228:	e0bffc17 	ldw	r2,-16(fp)
 908e22c:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 908e230:	e0bffa03 	ldbu	r2,-24(fp)
}
 908e234:	e037883a 	mov	sp,fp
 908e238:	dfc00117 	ldw	ra,4(sp)
 908e23c:	df000017 	ldw	fp,0(sp)
 908e240:	dec00204 	addi	sp,sp,8
 908e244:	f800283a 	ret

0908e248 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 908e248:	defffd04 	addi	sp,sp,-12
 908e24c:	df000215 	stw	fp,8(sp)
 908e250:	df000204 	addi	fp,sp,8
 908e254:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 908e258:	d0e07a17 	ldw	r3,-32280(gp)
 908e25c:	e0bfff17 	ldw	r2,-4(fp)
 908e260:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 908e264:	d0a07a17 	ldw	r2,-32280(gp)
 908e268:	10800d03 	ldbu	r2,52(r2)
 908e26c:	11003fcc 	andi	r4,r2,255
 908e270:	d0a07a17 	ldw	r2,-32280(gp)
 908e274:	10800d03 	ldbu	r2,52(r2)
 908e278:	10c03fcc 	andi	r3,r2,255
 908e27c:	e0bfff17 	ldw	r2,-4(fp)
 908e280:	1885883a 	add	r2,r3,r2
 908e284:	10800204 	addi	r2,r2,8
 908e288:	10c000c3 	ldbu	r3,3(r2)
 908e28c:	d0a07a17 	ldw	r2,-32280(gp)
 908e290:	10800d43 	ldbu	r2,53(r2)
 908e294:	1884b03a 	or	r2,r3,r2
 908e298:	1007883a 	mov	r3,r2
 908e29c:	e0bfff17 	ldw	r2,-4(fp)
 908e2a0:	2085883a 	add	r2,r4,r2
 908e2a4:	10800204 	addi	r2,r2,8
 908e2a8:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 908e2ac:	e0bfff17 	ldw	r2,-4(fp)
 908e2b0:	10c00283 	ldbu	r3,10(r2)
 908e2b4:	d0a07a17 	ldw	r2,-32280(gp)
 908e2b8:	10800d83 	ldbu	r2,54(r2)
 908e2bc:	1884b03a 	or	r2,r3,r2
 908e2c0:	1007883a 	mov	r3,r2
 908e2c4:	e0bfff17 	ldw	r2,-4(fp)
 908e2c8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 908e2cc:	d0a07a17 	ldw	r2,-32280(gp)
 908e2d0:	10800d03 	ldbu	r2,52(r2)
 908e2d4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 908e2d8:	e13ffe03 	ldbu	r4,-8(fp)
 908e2dc:	e0fffe03 	ldbu	r3,-8(fp)
 908e2e0:	d0a07744 	addi	r2,gp,-32291
 908e2e4:	1885883a 	add	r2,r3,r2
 908e2e8:	10800003 	ldbu	r2,0(r2)
 908e2ec:	1007883a 	mov	r3,r2
 908e2f0:	d0a07a17 	ldw	r2,-32280(gp)
 908e2f4:	10800d43 	ldbu	r2,53(r2)
 908e2f8:	0084303a 	nor	r2,zero,r2
 908e2fc:	1884703a 	and	r2,r3,r2
 908e300:	1007883a 	mov	r3,r2
 908e304:	d0a07744 	addi	r2,gp,-32291
 908e308:	2085883a 	add	r2,r4,r2
 908e30c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 908e310:	e0fffe03 	ldbu	r3,-8(fp)
 908e314:	d0a07744 	addi	r2,gp,-32291
 908e318:	1885883a 	add	r2,r3,r2
 908e31c:	10800003 	ldbu	r2,0(r2)
 908e320:	10803fcc 	andi	r2,r2,255
 908e324:	1004c03a 	cmpne	r2,r2,zero
 908e328:	1000071e 	bne	r2,zero,908e348 <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 908e32c:	d0a07a17 	ldw	r2,-32280(gp)
 908e330:	10800d83 	ldbu	r2,54(r2)
 908e334:	0084303a 	nor	r2,zero,r2
 908e338:	1007883a 	mov	r3,r2
 908e33c:	d0a07703 	ldbu	r2,-32292(gp)
 908e340:	1884703a 	and	r2,r3,r2
 908e344:	d0a07705 	stb	r2,-32292(gp)
    }
}
 908e348:	e037883a 	mov	sp,fp
 908e34c:	df000017 	ldw	fp,0(sp)
 908e350:	dec00104 	addi	sp,sp,4
 908e354:	f800283a 	ret

0908e358 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 908e358:	defffb04 	addi	sp,sp,-20
 908e35c:	df000415 	stw	fp,16(sp)
 908e360:	df000404 	addi	fp,sp,16
 908e364:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 908e368:	d0a07a17 	ldw	r2,-32280(gp)
 908e36c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 908e370:	d0e07a17 	ldw	r3,-32280(gp)
 908e374:	e0bfff17 	ldw	r2,-4(fp)
 908e378:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 908e37c:	e0bfff17 	ldw	r2,-4(fp)
 908e380:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 908e384:	e0bffe17 	ldw	r2,-8(fp)
 908e388:	10800017 	ldw	r2,0(r2)
 908e38c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 908e390:	00002006 	br	908e414 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 908e394:	d0a07a17 	ldw	r2,-32280(gp)
 908e398:	10800d03 	ldbu	r2,52(r2)
 908e39c:	11003fcc 	andi	r4,r2,255
 908e3a0:	d0a07a17 	ldw	r2,-32280(gp)
 908e3a4:	10800d03 	ldbu	r2,52(r2)
 908e3a8:	10c03fcc 	andi	r3,r2,255
 908e3ac:	e0bffd17 	ldw	r2,-12(fp)
 908e3b0:	1885883a 	add	r2,r3,r2
 908e3b4:	10800204 	addi	r2,r2,8
 908e3b8:	10c000c3 	ldbu	r3,3(r2)
 908e3bc:	d0a07a17 	ldw	r2,-32280(gp)
 908e3c0:	10800d43 	ldbu	r2,53(r2)
 908e3c4:	1884b03a 	or	r2,r3,r2
 908e3c8:	1007883a 	mov	r3,r2
 908e3cc:	e0bffd17 	ldw	r2,-12(fp)
 908e3d0:	2085883a 	add	r2,r4,r2
 908e3d4:	10800204 	addi	r2,r2,8
 908e3d8:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 908e3dc:	e0bffd17 	ldw	r2,-12(fp)
 908e3e0:	10c00283 	ldbu	r3,10(r2)
 908e3e4:	d0a07a17 	ldw	r2,-32280(gp)
 908e3e8:	10800d83 	ldbu	r2,54(r2)
 908e3ec:	1884b03a 	or	r2,r3,r2
 908e3f0:	1007883a 	mov	r3,r2
 908e3f4:	e0bffd17 	ldw	r2,-12(fp)
 908e3f8:	10c00285 	stb	r3,10(r2)
        pevents++;
 908e3fc:	e0bffe17 	ldw	r2,-8(fp)
 908e400:	10800104 	addi	r2,r2,4
 908e404:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 908e408:	e0bffe17 	ldw	r2,-8(fp)
 908e40c:	10800017 	ldw	r2,0(r2)
 908e410:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 908e414:	e0bffd17 	ldw	r2,-12(fp)
 908e418:	1004c03a 	cmpne	r2,r2,zero
 908e41c:	103fdd1e 	bne	r2,zero,908e394 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 908e420:	d0a07a17 	ldw	r2,-32280(gp)
 908e424:	10800d03 	ldbu	r2,52(r2)
 908e428:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 908e42c:	e13ffc03 	ldbu	r4,-16(fp)
 908e430:	e0fffc03 	ldbu	r3,-16(fp)
 908e434:	d0a07744 	addi	r2,gp,-32291
 908e438:	1885883a 	add	r2,r3,r2
 908e43c:	10800003 	ldbu	r2,0(r2)
 908e440:	1007883a 	mov	r3,r2
 908e444:	d0a07a17 	ldw	r2,-32280(gp)
 908e448:	10800d43 	ldbu	r2,53(r2)
 908e44c:	0084303a 	nor	r2,zero,r2
 908e450:	1884703a 	and	r2,r3,r2
 908e454:	1007883a 	mov	r3,r2
 908e458:	d0a07744 	addi	r2,gp,-32291
 908e45c:	2085883a 	add	r2,r4,r2
 908e460:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 908e464:	e0fffc03 	ldbu	r3,-16(fp)
 908e468:	d0a07744 	addi	r2,gp,-32291
 908e46c:	1885883a 	add	r2,r3,r2
 908e470:	10800003 	ldbu	r2,0(r2)
 908e474:	10803fcc 	andi	r2,r2,255
 908e478:	1004c03a 	cmpne	r2,r2,zero
 908e47c:	1000071e 	bne	r2,zero,908e49c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 908e480:	d0a07a17 	ldw	r2,-32280(gp)
 908e484:	10800d83 	ldbu	r2,54(r2)
 908e488:	0084303a 	nor	r2,zero,r2
 908e48c:	1007883a 	mov	r3,r2
 908e490:	d0a07703 	ldbu	r2,-32292(gp)
 908e494:	1884703a 	and	r2,r3,r2
 908e498:	d0a07705 	stb	r2,-32292(gp)
    }
}
 908e49c:	e037883a 	mov	sp,fp
 908e4a0:	df000017 	ldw	fp,0(sp)
 908e4a4:	dec00104 	addi	sp,sp,4
 908e4a8:	f800283a 	ret

0908e4ac <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 908e4ac:	defffc04 	addi	sp,sp,-16
 908e4b0:	df000315 	stw	fp,12(sp)
 908e4b4:	df000304 	addi	fp,sp,12
 908e4b8:	e13ffe15 	stw	r4,-8(fp)
 908e4bc:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 908e4c0:	e0bffe17 	ldw	r2,-8(fp)
 908e4c4:	10800d03 	ldbu	r2,52(r2)
 908e4c8:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 908e4cc:	e13ffd03 	ldbu	r4,-12(fp)
 908e4d0:	e0fffd03 	ldbu	r3,-12(fp)
 908e4d4:	e0bfff17 	ldw	r2,-4(fp)
 908e4d8:	1885883a 	add	r2,r3,r2
 908e4dc:	10800204 	addi	r2,r2,8
 908e4e0:	108000c3 	ldbu	r2,3(r2)
 908e4e4:	1007883a 	mov	r3,r2
 908e4e8:	e0bffe17 	ldw	r2,-8(fp)
 908e4ec:	10800d43 	ldbu	r2,53(r2)
 908e4f0:	0084303a 	nor	r2,zero,r2
 908e4f4:	1884703a 	and	r2,r3,r2
 908e4f8:	1007883a 	mov	r3,r2
 908e4fc:	e0bfff17 	ldw	r2,-4(fp)
 908e500:	2085883a 	add	r2,r4,r2
 908e504:	10800204 	addi	r2,r2,8
 908e508:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 908e50c:	e0fffd03 	ldbu	r3,-12(fp)
 908e510:	e0bfff17 	ldw	r2,-4(fp)
 908e514:	1885883a 	add	r2,r3,r2
 908e518:	10800204 	addi	r2,r2,8
 908e51c:	108000c3 	ldbu	r2,3(r2)
 908e520:	10803fcc 	andi	r2,r2,255
 908e524:	1004c03a 	cmpne	r2,r2,zero
 908e528:	10000a1e 	bne	r2,zero,908e554 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 908e52c:	e0bfff17 	ldw	r2,-4(fp)
 908e530:	10800283 	ldbu	r2,10(r2)
 908e534:	1007883a 	mov	r3,r2
 908e538:	e0bffe17 	ldw	r2,-8(fp)
 908e53c:	10800d83 	ldbu	r2,54(r2)
 908e540:	0084303a 	nor	r2,zero,r2
 908e544:	1884703a 	and	r2,r3,r2
 908e548:	1007883a 	mov	r3,r2
 908e54c:	e0bfff17 	ldw	r2,-4(fp)
 908e550:	10c00285 	stb	r3,10(r2)
    }
}
 908e554:	e037883a 	mov	sp,fp
 908e558:	df000017 	ldw	fp,0(sp)
 908e55c:	dec00104 	addi	sp,sp,4
 908e560:	f800283a 	ret

0908e564 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 908e564:	defffa04 	addi	sp,sp,-24
 908e568:	df000515 	stw	fp,20(sp)
 908e56c:	df000504 	addi	fp,sp,20
 908e570:	e13ffe15 	stw	r4,-8(fp)
 908e574:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 908e578:	e0bffe17 	ldw	r2,-8(fp)
 908e57c:	10800d03 	ldbu	r2,52(r2)
 908e580:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 908e584:	e0bffe17 	ldw	r2,-8(fp)
 908e588:	10800d83 	ldbu	r2,54(r2)
 908e58c:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 908e590:	e0bffe17 	ldw	r2,-8(fp)
 908e594:	10800d43 	ldbu	r2,53(r2)
 908e598:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 908e59c:	e0bfff17 	ldw	r2,-4(fp)
 908e5a0:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 908e5a4:	e0bffd17 	ldw	r2,-12(fp)
 908e5a8:	10800017 	ldw	r2,0(r2)
 908e5ac:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 908e5b0:	00002606 	br	908e64c <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 908e5b4:	e13ffb83 	ldbu	r4,-18(fp)
 908e5b8:	e0fffb83 	ldbu	r3,-18(fp)
 908e5bc:	e0bffc17 	ldw	r2,-16(fp)
 908e5c0:	1885883a 	add	r2,r3,r2
 908e5c4:	10800204 	addi	r2,r2,8
 908e5c8:	108000c3 	ldbu	r2,3(r2)
 908e5cc:	1007883a 	mov	r3,r2
 908e5d0:	e0bffb03 	ldbu	r2,-20(fp)
 908e5d4:	0084303a 	nor	r2,zero,r2
 908e5d8:	1884703a 	and	r2,r3,r2
 908e5dc:	1007883a 	mov	r3,r2
 908e5e0:	e0bffc17 	ldw	r2,-16(fp)
 908e5e4:	2085883a 	add	r2,r4,r2
 908e5e8:	10800204 	addi	r2,r2,8
 908e5ec:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 908e5f0:	e0fffb83 	ldbu	r3,-18(fp)
 908e5f4:	e0bffc17 	ldw	r2,-16(fp)
 908e5f8:	1885883a 	add	r2,r3,r2
 908e5fc:	10800204 	addi	r2,r2,8
 908e600:	108000c3 	ldbu	r2,3(r2)
 908e604:	10803fcc 	andi	r2,r2,255
 908e608:	1004c03a 	cmpne	r2,r2,zero
 908e60c:	1000091e 	bne	r2,zero,908e634 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 908e610:	e0bffc17 	ldw	r2,-16(fp)
 908e614:	10800283 	ldbu	r2,10(r2)
 908e618:	1007883a 	mov	r3,r2
 908e61c:	e0bffb43 	ldbu	r2,-19(fp)
 908e620:	0084303a 	nor	r2,zero,r2
 908e624:	1884703a 	and	r2,r3,r2
 908e628:	1007883a 	mov	r3,r2
 908e62c:	e0bffc17 	ldw	r2,-16(fp)
 908e630:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 908e634:	e0bffd17 	ldw	r2,-12(fp)
 908e638:	10800104 	addi	r2,r2,4
 908e63c:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 908e640:	e0bffd17 	ldw	r2,-12(fp)
 908e644:	10800017 	ldw	r2,0(r2)
 908e648:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 908e64c:	e0bffc17 	ldw	r2,-16(fp)
 908e650:	1004c03a 	cmpne	r2,r2,zero
 908e654:	103fd71e 	bne	r2,zero,908e5b4 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 908e658:	e037883a 	mov	sp,fp
 908e65c:	df000017 	ldw	fp,0(sp)
 908e660:	dec00104 	addi	sp,sp,4
 908e664:	f800283a 	ret

0908e668 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 908e668:	defffc04 	addi	sp,sp,-16
 908e66c:	df000315 	stw	fp,12(sp)
 908e670:	df000304 	addi	fp,sp,12
 908e674:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 908e678:	e0bfff17 	ldw	r2,-4(fp)
 908e67c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 908e680:	e0bfff17 	ldw	r2,-4(fp)
 908e684:	108002c4 	addi	r2,r2,11
 908e688:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 908e68c:	e03ffd05 	stb	zero,-12(fp)
 908e690:	00000806 	br	908e6b4 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 908e694:	e0bffe17 	ldw	r2,-8(fp)
 908e698:	10000005 	stb	zero,0(r2)
 908e69c:	e0bffe17 	ldw	r2,-8(fp)
 908e6a0:	10800044 	addi	r2,r2,1
 908e6a4:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 908e6a8:	e0bffd03 	ldbu	r2,-12(fp)
 908e6ac:	10800044 	addi	r2,r2,1
 908e6b0:	e0bffd05 	stb	r2,-12(fp)
 908e6b4:	e0bffd03 	ldbu	r2,-12(fp)
 908e6b8:	108000f0 	cmpltui	r2,r2,3
 908e6bc:	103ff51e 	bne	r2,zero,908e694 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 908e6c0:	e037883a 	mov	sp,fp
 908e6c4:	df000017 	ldw	fp,0(sp)
 908e6c8:	dec00104 	addi	sp,sp,4
 908e6cc:	f800283a 	ret

0908e6d0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 908e6d0:	defffb04 	addi	sp,sp,-20
 908e6d4:	dfc00415 	stw	ra,16(sp)
 908e6d8:	df000315 	stw	fp,12(sp)
 908e6dc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 908e6e0:	010243b4 	movhi	r4,2318
 908e6e4:	212e9804 	addi	r4,r4,-17824
 908e6e8:	0142d004 	movi	r5,2880
 908e6ec:	908ea340 	call	908ea34 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 908e6f0:	008243b4 	movhi	r2,2318
 908e6f4:	10ae9804 	addi	r2,r2,-17824
 908e6f8:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 908e6fc:	008243b4 	movhi	r2,2318
 908e700:	10aea404 	addi	r2,r2,-17776
 908e704:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 908e708:	e03fff0d 	sth	zero,-4(fp)
 908e70c:	00001306 	br	908e75c <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 908e710:	e0bffe17 	ldw	r2,-8(fp)
 908e714:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 908e718:	e0fffe17 	ldw	r3,-8(fp)
 908e71c:	e0bffd17 	ldw	r2,-12(fp)
 908e720:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 908e724:	e0fffe17 	ldw	r3,-8(fp)
 908e728:	00800fc4 	movi	r2,63
 908e72c:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 908e730:	e0bffe17 	ldw	r2,-8(fp)
 908e734:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 908e738:	e0bffe17 	ldw	r2,-8(fp)
 908e73c:	10800c04 	addi	r2,r2,48
 908e740:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 908e744:	e0bffd17 	ldw	r2,-12(fp)
 908e748:	10800c04 	addi	r2,r2,48
 908e74c:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 908e750:	e0bfff0b 	ldhu	r2,-4(fp)
 908e754:	10800044 	addi	r2,r2,1
 908e758:	e0bfff0d 	sth	r2,-4(fp)
 908e75c:	e0bfff0b 	ldhu	r2,-4(fp)
 908e760:	10800ef0 	cmpltui	r2,r2,59
 908e764:	103fea1e 	bne	r2,zero,908e710 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 908e768:	e0bffe17 	ldw	r2,-8(fp)
 908e76c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 908e770:	e0bffe17 	ldw	r2,-8(fp)
 908e774:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 908e778:	e0fffe17 	ldw	r3,-8(fp)
 908e77c:	00800fc4 	movi	r2,63
 908e780:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 908e784:	e0bffe17 	ldw	r2,-8(fp)
 908e788:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 908e78c:	008243b4 	movhi	r2,2318
 908e790:	10ae9804 	addi	r2,r2,-17824
 908e794:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 908e798:	e037883a 	mov	sp,fp
 908e79c:	dfc00117 	ldw	ra,4(sp)
 908e7a0:	df000017 	ldw	fp,0(sp)
 908e7a4:	dec00204 	addi	sp,sp,8
 908e7a8:	f800283a 	ret

0908e7ac <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 908e7ac:	deffff04 	addi	sp,sp,-4
 908e7b0:	df000015 	stw	fp,0(sp)
 908e7b4:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 908e7b8:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 908e7bc:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 908e7c0:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 908e7c4:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 908e7c8:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 908e7cc:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 908e7d0:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 908e7d4:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 908e7d8:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 908e7dc:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 908e7e0:	e037883a 	mov	sp,fp
 908e7e4:	df000017 	ldw	fp,0(sp)
 908e7e8:	dec00104 	addi	sp,sp,4
 908e7ec:	f800283a 	ret

0908e7f0 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 908e7f0:	defffd04 	addi	sp,sp,-12
 908e7f4:	df000215 	stw	fp,8(sp)
 908e7f8:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 908e7fc:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 908e800:	d0a07744 	addi	r2,gp,-32291
 908e804:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 908e808:	e03fff05 	stb	zero,-4(fp)
 908e80c:	00000806 	br	908e830 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 908e810:	e0bffe17 	ldw	r2,-8(fp)
 908e814:	10000005 	stb	zero,0(r2)
 908e818:	e0bffe17 	ldw	r2,-8(fp)
 908e81c:	10800044 	addi	r2,r2,1
 908e820:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 908e824:	e0bfff03 	ldbu	r2,-4(fp)
 908e828:	10800044 	addi	r2,r2,1
 908e82c:	e0bfff05 	stb	r2,-4(fp)
 908e830:	e0bfff03 	ldbu	r2,-4(fp)
 908e834:	108000f0 	cmpltui	r2,r2,3
 908e838:	103ff51e 	bne	r2,zero,908e810 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 908e83c:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 908e840:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 908e844:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 908e848:	d0207a15 	stw	zero,-32280(gp)
}
 908e84c:	e037883a 	mov	sp,fp
 908e850:	df000017 	ldw	fp,0(sp)
 908e854:	dec00104 	addi	sp,sp,4
 908e858:	f800283a 	ret

0908e85c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 908e85c:	defff804 	addi	sp,sp,-32
 908e860:	dfc00715 	stw	ra,28(sp)
 908e864:	df000615 	stw	fp,24(sp)
 908e868:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 908e86c:	018243b4 	movhi	r6,2318
 908e870:	31ae9704 	addi	r6,r6,-17828
 908e874:	00bfffd4 	movui	r2,65535
 908e878:	d8800015 	stw	r2,0(sp)
 908e87c:	008243b4 	movhi	r2,2318
 908e880:	10ac9804 	addi	r2,r2,-19872
 908e884:	d8800115 	stw	r2,4(sp)
 908e888:	00808004 	movi	r2,512
 908e88c:	d8800215 	stw	r2,8(sp)
 908e890:	d8000315 	stw	zero,12(sp)
 908e894:	008000c4 	movi	r2,3
 908e898:	d8800415 	stw	r2,16(sp)
 908e89c:	01024274 	movhi	r4,2313
 908e8a0:	213b4404 	addi	r4,r4,-4848
 908e8a4:	000b883a 	mov	r5,zero
 908e8a8:	01c00504 	movi	r7,20
 908e8ac:	9093b080 	call	9093b08 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 908e8b0:	01424374 	movhi	r5,2317
 908e8b4:	29736f04 	addi	r5,r5,-12868
 908e8b8:	01000504 	movi	r4,20
 908e8bc:	e1bfff04 	addi	r6,fp,-4
 908e8c0:	909443c0 	call	909443c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 908e8c4:	e037883a 	mov	sp,fp
 908e8c8:	dfc00117 	ldw	ra,4(sp)
 908e8cc:	df000017 	ldw	fp,0(sp)
 908e8d0:	dec00204 	addi	sp,sp,8
 908e8d4:	f800283a 	ret

0908e8d8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 908e8d8:	defff804 	addi	sp,sp,-32
 908e8dc:	dfc00715 	stw	ra,28(sp)
 908e8e0:	df000615 	stw	fp,24(sp)
 908e8e4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 908e8e8:	018243b4 	movhi	r6,2318
 908e8ec:	31ac1f04 	addi	r6,r6,-20356
 908e8f0:	00bfff94 	movui	r2,65534
 908e8f4:	d8800015 	stw	r2,0(sp)
 908e8f8:	008243b4 	movhi	r2,2318
 908e8fc:	10aa2004 	addi	r2,r2,-22400
 908e900:	d8800115 	stw	r2,4(sp)
 908e904:	00808004 	movi	r2,512
 908e908:	d8800215 	stw	r2,8(sp)
 908e90c:	d8000315 	stw	zero,12(sp)
 908e910:	008000c4 	movi	r2,3
 908e914:	d8800415 	stw	r2,16(sp)
 908e918:	01024274 	movhi	r4,2313
 908e91c:	213b5b04 	addi	r4,r4,-4756
 908e920:	000b883a 	mov	r5,zero
 908e924:	01c004c4 	movi	r7,19
 908e928:	9093b080 	call	9093b08 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 908e92c:	01424374 	movhi	r5,2317
 908e930:	29737304 	addi	r5,r5,-12852
 908e934:	010004c4 	movi	r4,19
 908e938:	e1bfff04 	addi	r6,fp,-4
 908e93c:	909443c0 	call	909443c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 908e940:	e037883a 	mov	sp,fp
 908e944:	dfc00117 	ldw	ra,4(sp)
 908e948:	df000017 	ldw	fp,0(sp)
 908e94c:	dec00204 	addi	sp,sp,8
 908e950:	f800283a 	ret

0908e954 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 908e954:	defffb04 	addi	sp,sp,-20
 908e958:	dfc00415 	stw	ra,16(sp)
 908e95c:	df000315 	stw	fp,12(sp)
 908e960:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 908e964:	010243b4 	movhi	r4,2318
 908e968:	21316804 	addi	r4,r4,-14944
 908e96c:	01414404 	movi	r5,1296
 908e970:	908ea340 	call	908ea34 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 908e974:	010243b4 	movhi	r4,2318
 908e978:	2132ac04 	addi	r4,r4,-13648
 908e97c:	01401504 	movi	r5,84
 908e980:	908ea340 	call	908ea34 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 908e984:	008243b4 	movhi	r2,2318
 908e988:	10b16804 	addi	r2,r2,-14944
 908e98c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 908e990:	008243b4 	movhi	r2,2318
 908e994:	10b18304 	addi	r2,r2,-14836
 908e998:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 908e99c:	e03fff05 	stb	zero,-4(fp)
 908e9a0:	00001106 	br	908e9e8 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 908e9a4:	e0fffe17 	ldw	r3,-8(fp)
 908e9a8:	e0bffd17 	ldw	r2,-12(fp)
 908e9ac:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 908e9b0:	e0fffe17 	ldw	r3,-8(fp)
 908e9b4:	00800fc4 	movi	r2,63
 908e9b8:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 908e9bc:	e0bffe17 	ldw	r2,-8(fp)
 908e9c0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 908e9c4:	e0bffe17 	ldw	r2,-8(fp)
 908e9c8:	10801b04 	addi	r2,r2,108
 908e9cc:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 908e9d0:	e0bffd17 	ldw	r2,-12(fp)
 908e9d4:	10801b04 	addi	r2,r2,108
 908e9d8:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 908e9dc:	e0bfff03 	ldbu	r2,-4(fp)
 908e9e0:	10800044 	addi	r2,r2,1
 908e9e4:	e0bfff05 	stb	r2,-4(fp)
 908e9e8:	e0bfff03 	ldbu	r2,-4(fp)
 908e9ec:	108002f0 	cmpltui	r2,r2,11
 908e9f0:	103fec1e 	bne	r2,zero,908e9a4 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 908e9f4:	e0bffe17 	ldw	r2,-8(fp)
 908e9f8:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 908e9fc:	e0fffe17 	ldw	r3,-8(fp)
 908ea00:	00800fc4 	movi	r2,63
 908ea04:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 908ea08:	e0bffe17 	ldw	r2,-8(fp)
 908ea0c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 908ea10:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 908ea14:	008243b4 	movhi	r2,2318
 908ea18:	10b16804 	addi	r2,r2,-14944
 908ea1c:	d0a07215 	stw	r2,-32312(gp)
}
 908ea20:	e037883a 	mov	sp,fp
 908ea24:	dfc00117 	ldw	ra,4(sp)
 908ea28:	df000017 	ldw	fp,0(sp)
 908ea2c:	dec00204 	addi	sp,sp,8
 908ea30:	f800283a 	ret

0908ea34 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 908ea34:	defffd04 	addi	sp,sp,-12
 908ea38:	df000215 	stw	fp,8(sp)
 908ea3c:	df000204 	addi	fp,sp,8
 908ea40:	e13ffe15 	stw	r4,-8(fp)
 908ea44:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 908ea48:	00000806 	br	908ea6c <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 908ea4c:	e0bffe17 	ldw	r2,-8(fp)
 908ea50:	10000005 	stb	zero,0(r2)
 908ea54:	e0bffe17 	ldw	r2,-8(fp)
 908ea58:	10800044 	addi	r2,r2,1
 908ea5c:	e0bffe15 	stw	r2,-8(fp)
        size--;
 908ea60:	e0bfff0b 	ldhu	r2,-4(fp)
 908ea64:	10bfffc4 	addi	r2,r2,-1
 908ea68:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 908ea6c:	e0bfff0b 	ldhu	r2,-4(fp)
 908ea70:	1004c03a 	cmpne	r2,r2,zero
 908ea74:	103ff51e 	bne	r2,zero,908ea4c <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 908ea78:	e037883a 	mov	sp,fp
 908ea7c:	df000017 	ldw	fp,0(sp)
 908ea80:	dec00104 	addi	sp,sp,4
 908ea84:	f800283a 	ret

0908ea88 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 908ea88:	defffc04 	addi	sp,sp,-16
 908ea8c:	df000315 	stw	fp,12(sp)
 908ea90:	df000304 	addi	fp,sp,12
 908ea94:	e13ffd15 	stw	r4,-12(fp)
 908ea98:	e17ffe15 	stw	r5,-8(fp)
 908ea9c:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 908eaa0:	00000d06 	br	908ead8 <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 908eaa4:	e0bffe17 	ldw	r2,-8(fp)
 908eaa8:	10c00003 	ldbu	r3,0(r2)
 908eaac:	e0bffd17 	ldw	r2,-12(fp)
 908eab0:	10c00005 	stb	r3,0(r2)
 908eab4:	e0bffd17 	ldw	r2,-12(fp)
 908eab8:	10800044 	addi	r2,r2,1
 908eabc:	e0bffd15 	stw	r2,-12(fp)
 908eac0:	e0bffe17 	ldw	r2,-8(fp)
 908eac4:	10800044 	addi	r2,r2,1
 908eac8:	e0bffe15 	stw	r2,-8(fp)
        size--;
 908eacc:	e0bfff0b 	ldhu	r2,-4(fp)
 908ead0:	10bfffc4 	addi	r2,r2,-1
 908ead4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 908ead8:	e0bfff0b 	ldhu	r2,-4(fp)
 908eadc:	1004c03a 	cmpne	r2,r2,zero
 908eae0:	103ff01e 	bne	r2,zero,908eaa4 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 908eae4:	e037883a 	mov	sp,fp
 908eae8:	df000017 	ldw	fp,0(sp)
 908eaec:	dec00104 	addi	sp,sp,4
 908eaf0:	f800283a 	ret

0908eaf4 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 908eaf4:	defffb04 	addi	sp,sp,-20
 908eaf8:	dfc00415 	stw	ra,16(sp)
 908eafc:	df000315 	stw	fp,12(sp)
 908eb00:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 908eb04:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908eb08:	0005303a 	rdctl	r2,status
 908eb0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908eb10:	e0fffe17 	ldw	r3,-8(fp)
 908eb14:	00bfff84 	movi	r2,-2
 908eb18:	1884703a 	and	r2,r3,r2
 908eb1c:	1001703a 	wrctl	status,r2
  
  return context;
 908eb20:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 908eb24:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 908eb28:	d0a07903 	ldbu	r2,-32284(gp)
 908eb2c:	10803fcc 	andi	r2,r2,255
 908eb30:	1004c03a 	cmpne	r2,r2,zero
 908eb34:	10001b1e 	bne	r2,zero,908eba4 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 908eb38:	d0a06b03 	ldbu	r2,-32340(gp)
 908eb3c:	10803fcc 	andi	r2,r2,255
 908eb40:	1004c03a 	cmpne	r2,r2,zero
 908eb44:	1000171e 	bne	r2,zero,908eba4 <OS_Sched+0xb0>
            OS_SchedNew();
 908eb48:	908ebc80 	call	908ebc8 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 908eb4c:	d0a06d03 	ldbu	r2,-32332(gp)
 908eb50:	d0e06d43 	ldbu	r3,-32331(gp)
 908eb54:	11003fcc 	andi	r4,r2,255
 908eb58:	18803fcc 	andi	r2,r3,255
 908eb5c:	20801126 	beq	r4,r2,908eba4 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 908eb60:	d0a06d03 	ldbu	r2,-32332(gp)
 908eb64:	10803fcc 	andi	r2,r2,255
 908eb68:	00c243b4 	movhi	r3,2318
 908eb6c:	18f2ac04 	addi	r3,r3,-13648
 908eb70:	1085883a 	add	r2,r2,r2
 908eb74:	1085883a 	add	r2,r2,r2
 908eb78:	10c5883a 	add	r2,r2,r3
 908eb7c:	10800017 	ldw	r2,0(r2)
 908eb80:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 908eb84:	d0e07517 	ldw	r3,-32300(gp)
 908eb88:	18800e17 	ldw	r2,56(r3)
 908eb8c:	10800044 	addi	r2,r2,1
 908eb90:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 908eb94:	d0a07017 	ldw	r2,-32320(gp)
 908eb98:	10800044 	addi	r2,r2,1
 908eb9c:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 908eba0:	90b9e640 	call	90b9e64 <OSCtxSw>
 908eba4:	e0bfff17 	ldw	r2,-4(fp)
 908eba8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ebac:	e0bffd17 	ldw	r2,-12(fp)
 908ebb0:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 908ebb4:	e037883a 	mov	sp,fp
 908ebb8:	dfc00117 	ldw	ra,4(sp)
 908ebbc:	df000017 	ldw	fp,0(sp)
 908ebc0:	dec00204 	addi	sp,sp,8
 908ebc4:	f800283a 	ret

0908ebc8 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 908ebc8:	defffe04 	addi	sp,sp,-8
 908ebcc:	df000115 	stw	fp,4(sp)
 908ebd0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 908ebd4:	d0a07703 	ldbu	r2,-32292(gp)
 908ebd8:	10c03fcc 	andi	r3,r2,255
 908ebdc:	00824374 	movhi	r2,2317
 908ebe0:	10b32f04 	addi	r2,r2,-13124
 908ebe4:	10c5883a 	add	r2,r2,r3
 908ebe8:	10800003 	ldbu	r2,0(r2)
 908ebec:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 908ebf0:	e0bfff03 	ldbu	r2,-4(fp)
 908ebf4:	100490fa 	slli	r2,r2,3
 908ebf8:	1009883a 	mov	r4,r2
 908ebfc:	e0ffff03 	ldbu	r3,-4(fp)
 908ec00:	d0a07744 	addi	r2,gp,-32291
 908ec04:	1885883a 	add	r2,r3,r2
 908ec08:	10800003 	ldbu	r2,0(r2)
 908ec0c:	10c03fcc 	andi	r3,r2,255
 908ec10:	00824374 	movhi	r2,2317
 908ec14:	10b32f04 	addi	r2,r2,-13124
 908ec18:	10c5883a 	add	r2,r2,r3
 908ec1c:	10800003 	ldbu	r2,0(r2)
 908ec20:	2085883a 	add	r2,r4,r2
 908ec24:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 908ec28:	e037883a 	mov	sp,fp
 908ec2c:	df000017 	ldw	fp,0(sp)
 908ec30:	dec00104 	addi	sp,sp,4
 908ec34:	f800283a 	ret

0908ec38 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 908ec38:	defffc04 	addi	sp,sp,-16
 908ec3c:	df000315 	stw	fp,12(sp)
 908ec40:	df000304 	addi	fp,sp,12
 908ec44:	e13ffe15 	stw	r4,-8(fp)
 908ec48:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 908ec4c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 908ec50:	00000d06 	br	908ec88 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 908ec54:	e0bfff17 	ldw	r2,-4(fp)
 908ec58:	10c00003 	ldbu	r3,0(r2)
 908ec5c:	e0bffe17 	ldw	r2,-8(fp)
 908ec60:	10c00005 	stb	r3,0(r2)
 908ec64:	e0bffe17 	ldw	r2,-8(fp)
 908ec68:	10800044 	addi	r2,r2,1
 908ec6c:	e0bffe15 	stw	r2,-8(fp)
 908ec70:	e0bfff17 	ldw	r2,-4(fp)
 908ec74:	10800044 	addi	r2,r2,1
 908ec78:	e0bfff15 	stw	r2,-4(fp)
        len++;
 908ec7c:	e0bffd03 	ldbu	r2,-12(fp)
 908ec80:	10800044 	addi	r2,r2,1
 908ec84:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 908ec88:	e0bfff17 	ldw	r2,-4(fp)
 908ec8c:	10800003 	ldbu	r2,0(r2)
 908ec90:	10803fcc 	andi	r2,r2,255
 908ec94:	1004c03a 	cmpne	r2,r2,zero
 908ec98:	103fee1e 	bne	r2,zero,908ec54 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 908ec9c:	e0bffe17 	ldw	r2,-8(fp)
 908eca0:	10000005 	stb	zero,0(r2)
    return (len);
 908eca4:	e0bffd03 	ldbu	r2,-12(fp)
}
 908eca8:	e037883a 	mov	sp,fp
 908ecac:	df000017 	ldw	fp,0(sp)
 908ecb0:	dec00104 	addi	sp,sp,4
 908ecb4:	f800283a 	ret

0908ecb8 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 908ecb8:	defffd04 	addi	sp,sp,-12
 908ecbc:	df000215 	stw	fp,8(sp)
 908ecc0:	df000204 	addi	fp,sp,8
 908ecc4:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 908ecc8:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 908eccc:	00000606 	br	908ece8 <OS_StrLen+0x30>
        psrc++;
 908ecd0:	e0bfff17 	ldw	r2,-4(fp)
 908ecd4:	10800044 	addi	r2,r2,1
 908ecd8:	e0bfff15 	stw	r2,-4(fp)
        len++;
 908ecdc:	e0bffe03 	ldbu	r2,-8(fp)
 908ece0:	10800044 	addi	r2,r2,1
 908ece4:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 908ece8:	e0bfff17 	ldw	r2,-4(fp)
 908ecec:	10800003 	ldbu	r2,0(r2)
 908ecf0:	10803fcc 	andi	r2,r2,255
 908ecf4:	1004c03a 	cmpne	r2,r2,zero
 908ecf8:	103ff51e 	bne	r2,zero,908ecd0 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 908ecfc:	e0bffe03 	ldbu	r2,-8(fp)
}
 908ed00:	e037883a 	mov	sp,fp
 908ed04:	df000017 	ldw	fp,0(sp)
 908ed08:	dec00104 	addi	sp,sp,4
 908ed0c:	f800283a 	ret

0908ed10 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 908ed10:	defffa04 	addi	sp,sp,-24
 908ed14:	dfc00515 	stw	ra,20(sp)
 908ed18:	df000415 	stw	fp,16(sp)
 908ed1c:	df000404 	addi	fp,sp,16
 908ed20:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908ed24:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ed28:	0005303a 	rdctl	r2,status
 908ed2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ed30:	e0fffd17 	ldw	r3,-12(fp)
 908ed34:	00bfff84 	movi	r2,-2
 908ed38:	1884703a 	and	r2,r3,r2
 908ed3c:	1001703a 	wrctl	status,r2
  
  return context;
 908ed40:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 908ed44:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 908ed48:	d0a06c17 	ldw	r2,-32336(gp)
 908ed4c:	10800044 	addi	r2,r2,1
 908ed50:	d0a06c15 	stw	r2,-32336(gp)
 908ed54:	e0bffe17 	ldw	r2,-8(fp)
 908ed58:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ed5c:	e0bffc17 	ldw	r2,-16(fp)
 908ed60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 908ed64:	90ba31c0 	call	90ba31c <OSTaskIdleHook>
    }
 908ed68:	003fef06 	br	908ed28 <OS_TaskIdle+0x18>

0908ed6c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 908ed6c:	defff804 	addi	sp,sp,-32
 908ed70:	dfc00715 	stw	ra,28(sp)
 908ed74:	df000615 	stw	fp,24(sp)
 908ed78:	df000604 	addi	fp,sp,24
 908ed7c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908ed80:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 908ed84:	00000206 	br	908ed90 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 908ed88:	01000504 	movi	r4,20
 908ed8c:	9094e000 	call	9094e00 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 908ed90:	d0a07d03 	ldbu	r2,-32268(gp)
 908ed94:	10803fcc 	andi	r2,r2,255
 908ed98:	1005003a 	cmpeq	r2,r2,zero
 908ed9c:	103ffa1e 	bne	r2,zero,908ed88 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 908eda0:	d0e07117 	ldw	r3,-32316(gp)
 908eda4:	00947b34 	movhi	r2,20972
 908eda8:	10a147c4 	addi	r2,r2,-31457
 908edac:	1889383a 	mul	r4,r3,r2
 908edb0:	e13ffe15 	stw	r4,-8(fp)
 908edb4:	1886383a 	mulxuu	r3,r3,r2
 908edb8:	e0ffff15 	stw	r3,-4(fp)
 908edbc:	e0ffff17 	ldw	r3,-4(fp)
 908edc0:	1804d17a 	srli	r2,r3,5
 908edc4:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 908edc8:	d0a07117 	ldw	r2,-32316(gp)
 908edcc:	1004c03a 	cmpne	r2,r2,zero
 908edd0:	1000031e 	bne	r2,zero,908ede0 <OS_TaskStat+0x74>
        OSCPUUsage = 0;
 908edd4:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 908edd8:	01003fc4 	movi	r4,255
 908eddc:	9094a140 	call	9094a14 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ede0:	0005303a 	rdctl	r2,status
 908ede4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ede8:	e0fffb17 	ldw	r3,-20(fp)
 908edec:	00bfff84 	movi	r2,-2
 908edf0:	1884703a 	and	r2,r3,r2
 908edf4:	1001703a 	wrctl	status,r2
  
  return context;
 908edf8:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 908edfc:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 908ee00:	d0a06c17 	ldw	r2,-32336(gp)
 908ee04:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 908ee08:	d0206c15 	stw	zero,-32336(gp)
 908ee0c:	e0bffc17 	ldw	r2,-16(fp)
 908ee10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ee14:	e0bffa17 	ldw	r2,-24(fp)
 908ee18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 908ee1c:	d0e07e17 	ldw	r3,-32264(gp)
 908ee20:	d0a07117 	ldw	r2,-32316(gp)
 908ee24:	1885203a 	divu	r2,r3,r2
 908ee28:	1007883a 	mov	r3,r2
 908ee2c:	00801904 	movi	r2,100
 908ee30:	10c5c83a 	sub	r2,r2,r3
 908ee34:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 908ee38:	90ba2a00 	call	90ba2a0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 908ee3c:	908ee4c0 	call	908ee4c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 908ee40:	01000284 	movi	r4,10
 908ee44:	9094e000 	call	9094e00 <OSTimeDly>
    }
 908ee48:	003fe506 	br	908ede0 <OS_TaskStat+0x74>

0908ee4c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 908ee4c:	defffa04 	addi	sp,sp,-24
 908ee50:	dfc00515 	stw	ra,20(sp)
 908ee54:	df000415 	stw	fp,16(sp)
 908ee58:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 908ee5c:	e03ffc05 	stb	zero,-16(fp)
 908ee60:	00002406 	br	908eef4 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 908ee64:	e13ffc03 	ldbu	r4,-16(fp)
 908ee68:	e17ffe04 	addi	r5,fp,-8
 908ee6c:	90948180 	call	9094818 <OSTaskStkChk>
 908ee70:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 908ee74:	e0bffc43 	ldbu	r2,-15(fp)
 908ee78:	1004c03a 	cmpne	r2,r2,zero
 908ee7c:	10001a1e 	bne	r2,zero,908eee8 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 908ee80:	e0bffc03 	ldbu	r2,-16(fp)
 908ee84:	00c243b4 	movhi	r3,2318
 908ee88:	18f2ac04 	addi	r3,r3,-13648
 908ee8c:	1085883a 	add	r2,r2,r2
 908ee90:	1085883a 	add	r2,r2,r2
 908ee94:	10c5883a 	add	r2,r2,r3
 908ee98:	10800017 	ldw	r2,0(r2)
 908ee9c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 908eea0:	e0bffd17 	ldw	r2,-12(fp)
 908eea4:	1005003a 	cmpeq	r2,r2,zero
 908eea8:	10000f1e 	bne	r2,zero,908eee8 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 908eeac:	e0bffd17 	ldw	r2,-12(fp)
 908eeb0:	10800060 	cmpeqi	r2,r2,1
 908eeb4:	10000c1e 	bne	r2,zero,908eee8 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 908eeb8:	e0bffd17 	ldw	r2,-12(fp)
 908eebc:	10c00217 	ldw	r3,8(r2)
 908eec0:	e0bffd17 	ldw	r2,-12(fp)
 908eec4:	10800317 	ldw	r2,12(r2)
 908eec8:	1085883a 	add	r2,r2,r2
 908eecc:	1085883a 	add	r2,r2,r2
 908eed0:	1887883a 	add	r3,r3,r2
 908eed4:	e0bffd17 	ldw	r2,-12(fp)
 908eed8:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 908eedc:	e0ffff17 	ldw	r3,-4(fp)
 908eee0:	e0bffd17 	ldw	r2,-12(fp)
 908eee4:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 908eee8:	e0bffc03 	ldbu	r2,-16(fp)
 908eeec:	10800044 	addi	r2,r2,1
 908eef0:	e0bffc05 	stb	r2,-16(fp)
 908eef4:	e0bffc03 	ldbu	r2,-16(fp)
 908eef8:	10800570 	cmpltui	r2,r2,21
 908eefc:	103fd91e 	bne	r2,zero,908ee64 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 908ef00:	e037883a 	mov	sp,fp
 908ef04:	dfc00117 	ldw	ra,4(sp)
 908ef08:	df000017 	ldw	fp,0(sp)
 908ef0c:	dec00204 	addi	sp,sp,8
 908ef10:	f800283a 	ret

0908ef14 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 908ef14:	defff104 	addi	sp,sp,-60
 908ef18:	dfc00e15 	stw	ra,56(sp)
 908ef1c:	df000d15 	stw	fp,52(sp)
 908ef20:	df000d04 	addi	fp,sp,52
 908ef24:	e17ffb15 	stw	r5,-20(fp)
 908ef28:	e1bffc15 	stw	r6,-16(fp)
 908ef2c:	e0800417 	ldw	r2,16(fp)
 908ef30:	e13ffa05 	stb	r4,-24(fp)
 908ef34:	e1fffd0d 	sth	r7,-12(fp)
 908ef38:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908ef3c:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ef40:	0005303a 	rdctl	r2,status
 908ef44:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ef48:	e0fff717 	ldw	r3,-36(fp)
 908ef4c:	00bfff84 	movi	r2,-2
 908ef50:	1884703a 	and	r2,r3,r2
 908ef54:	1001703a 	wrctl	status,r2
  
  return context;
 908ef58:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 908ef5c:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 908ef60:	d0a07217 	ldw	r2,-32312(gp)
 908ef64:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 908ef68:	e0bff917 	ldw	r2,-28(fp)
 908ef6c:	1005003a 	cmpeq	r2,r2,zero
 908ef70:	1000941e 	bne	r2,zero,908f1c4 <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 908ef74:	e0bff917 	ldw	r2,-28(fp)
 908ef78:	10800517 	ldw	r2,20(r2)
 908ef7c:	d0a07215 	stw	r2,-32312(gp)
 908ef80:	e0bff817 	ldw	r2,-32(fp)
 908ef84:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ef88:	e0bff617 	ldw	r2,-40(fp)
 908ef8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 908ef90:	e0fff917 	ldw	r3,-28(fp)
 908ef94:	e0bffb17 	ldw	r2,-20(fp)
 908ef98:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 908ef9c:	e0fff917 	ldw	r3,-28(fp)
 908efa0:	e0bffa03 	ldbu	r2,-24(fp)
 908efa4:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 908efa8:	e0bff917 	ldw	r2,-28(fp)
 908efac:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 908efb0:	e0bff917 	ldw	r2,-28(fp)
 908efb4:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 908efb8:	e0bff917 	ldw	r2,-28(fp)
 908efbc:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 908efc0:	e0fff917 	ldw	r3,-28(fp)
 908efc4:	e0800317 	ldw	r2,12(fp)
 908efc8:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 908efcc:	e0fff917 	ldw	r3,-28(fp)
 908efd0:	e0800217 	ldw	r2,8(fp)
 908efd4:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 908efd8:	e0fff917 	ldw	r3,-28(fp)
 908efdc:	e0bffc17 	ldw	r2,-16(fp)
 908efe0:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 908efe4:	e0fff917 	ldw	r3,-28(fp)
 908efe8:	e0bffe0b 	ldhu	r2,-8(fp)
 908efec:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 908eff0:	e0fff917 	ldw	r3,-28(fp)
 908eff4:	e0bffd0b 	ldhu	r2,-12(fp)
 908eff8:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 908effc:	e0bff917 	ldw	r2,-28(fp)
 908f000:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 908f004:	e0bffa03 	ldbu	r2,-24(fp)
 908f008:	1004d0fa 	srli	r2,r2,3
 908f00c:	1007883a 	mov	r3,r2
 908f010:	e0bff917 	ldw	r2,-28(fp)
 908f014:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 908f018:	e0bffa03 	ldbu	r2,-24(fp)
 908f01c:	108001cc 	andi	r2,r2,7
 908f020:	1007883a 	mov	r3,r2
 908f024:	e0bff917 	ldw	r2,-28(fp)
 908f028:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 908f02c:	e0bff917 	ldw	r2,-28(fp)
 908f030:	10800d03 	ldbu	r2,52(r2)
 908f034:	10c03fcc 	andi	r3,r2,255
 908f038:	00800044 	movi	r2,1
 908f03c:	10c4983a 	sll	r2,r2,r3
 908f040:	1007883a 	mov	r3,r2
 908f044:	e0bff917 	ldw	r2,-28(fp)
 908f048:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 908f04c:	e0bff917 	ldw	r2,-28(fp)
 908f050:	10800cc3 	ldbu	r2,51(r2)
 908f054:	10c03fcc 	andi	r3,r2,255
 908f058:	00800044 	movi	r2,1
 908f05c:	10c4983a 	sll	r2,r2,r3
 908f060:	1007883a 	mov	r3,r2
 908f064:	e0bff917 	ldw	r2,-28(fp)
 908f068:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 908f06c:	e0bff917 	ldw	r2,-28(fp)
 908f070:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 908f074:	e0bff917 	ldw	r2,-28(fp)
 908f078:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 908f07c:	e0bff917 	ldw	r2,-28(fp)
 908f080:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 908f084:	e0bff917 	ldw	r2,-28(fp)
 908f088:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 908f08c:	e0bff917 	ldw	r2,-28(fp)
 908f090:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 908f094:	e0bff917 	ldw	r2,-28(fp)
 908f098:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 908f09c:	e0bff917 	ldw	r2,-28(fp)
 908f0a0:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 908f0a4:	e0bff917 	ldw	r2,-28(fp)
 908f0a8:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 908f0ac:	e0bff917 	ldw	r2,-28(fp)
 908f0b0:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 908f0b4:	e0fff917 	ldw	r3,-28(fp)
 908f0b8:	00800fc4 	movi	r2,63
 908f0bc:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 908f0c0:	e0bff917 	ldw	r2,-28(fp)
 908f0c4:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 908f0c8:	e13ff917 	ldw	r4,-28(fp)
 908f0cc:	90ba3380 	call	90ba338 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 908f0d0:	e13ff917 	ldw	r4,-28(fp)
 908f0d4:	90ba2440 	call	90ba244 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908f0d8:	0005303a 	rdctl	r2,status
 908f0dc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908f0e0:	e0fff517 	ldw	r3,-44(fp)
 908f0e4:	00bfff84 	movi	r2,-2
 908f0e8:	1884703a 	and	r2,r3,r2
 908f0ec:	1001703a 	wrctl	status,r2
  
  return context;
 908f0f0:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 908f0f4:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 908f0f8:	e0bffa03 	ldbu	r2,-24(fp)
 908f0fc:	00c243b4 	movhi	r3,2318
 908f100:	18f2ac04 	addi	r3,r3,-13648
 908f104:	1085883a 	add	r2,r2,r2
 908f108:	1085883a 	add	r2,r2,r2
 908f10c:	10c7883a 	add	r3,r2,r3
 908f110:	e0bff917 	ldw	r2,-28(fp)
 908f114:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 908f118:	d0e06e17 	ldw	r3,-32328(gp)
 908f11c:	e0bff917 	ldw	r2,-28(fp)
 908f120:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 908f124:	e0bff917 	ldw	r2,-28(fp)
 908f128:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 908f12c:	d0a06e17 	ldw	r2,-32328(gp)
 908f130:	1005003a 	cmpeq	r2,r2,zero
 908f134:	1000031e 	bne	r2,zero,908f144 <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 908f138:	d0e06e17 	ldw	r3,-32328(gp)
 908f13c:	e0bff917 	ldw	r2,-28(fp)
 908f140:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 908f144:	e0bff917 	ldw	r2,-28(fp)
 908f148:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 908f14c:	e0bff917 	ldw	r2,-28(fp)
 908f150:	10c00d83 	ldbu	r3,54(r2)
 908f154:	d0a07703 	ldbu	r2,-32292(gp)
 908f158:	1884b03a 	or	r2,r3,r2
 908f15c:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 908f160:	e0bff917 	ldw	r2,-28(fp)
 908f164:	10800d03 	ldbu	r2,52(r2)
 908f168:	11003fcc 	andi	r4,r2,255
 908f16c:	e0bff917 	ldw	r2,-28(fp)
 908f170:	10800d03 	ldbu	r2,52(r2)
 908f174:	10c03fcc 	andi	r3,r2,255
 908f178:	d0a07744 	addi	r2,gp,-32291
 908f17c:	1885883a 	add	r2,r3,r2
 908f180:	10c00003 	ldbu	r3,0(r2)
 908f184:	e0bff917 	ldw	r2,-28(fp)
 908f188:	10800d43 	ldbu	r2,53(r2)
 908f18c:	1884b03a 	or	r2,r3,r2
 908f190:	1007883a 	mov	r3,r2
 908f194:	d0a07744 	addi	r2,gp,-32291
 908f198:	2085883a 	add	r2,r4,r2
 908f19c:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 908f1a0:	d0a07343 	ldbu	r2,-32307(gp)
 908f1a4:	10800044 	addi	r2,r2,1
 908f1a8:	d0a07345 	stb	r2,-32307(gp)
 908f1ac:	e0bff817 	ldw	r2,-32(fp)
 908f1b0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908f1b4:	e0bff417 	ldw	r2,-48(fp)
 908f1b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 908f1bc:	e03fff15 	stw	zero,-4(fp)
 908f1c0:	00000606 	br	908f1dc <OS_TCBInit+0x2c8>
 908f1c4:	e0bff817 	ldw	r2,-32(fp)
 908f1c8:	e0bff315 	stw	r2,-52(fp)
 908f1cc:	e0bff317 	ldw	r2,-52(fp)
 908f1d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 908f1d4:	00801084 	movi	r2,66
 908f1d8:	e0bfff15 	stw	r2,-4(fp)
 908f1dc:	e0bfff17 	ldw	r2,-4(fp)
}
 908f1e0:	e037883a 	mov	sp,fp
 908f1e4:	dfc00117 	ldw	ra,4(sp)
 908f1e8:	df000017 	ldw	fp,0(sp)
 908f1ec:	dec00204 	addi	sp,sp,8
 908f1f0:	f800283a 	ret

0908f1f4 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 908f1f4:	defffe04 	addi	sp,sp,-8
 908f1f8:	df000115 	stw	fp,4(sp)
 908f1fc:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 908f200:	d0a00a04 	addi	r2,gp,-32728
 908f204:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 908f208:	d0a00b04 	addi	r2,gp,-32724
 908f20c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 908f210:	d0a00c84 	addi	r2,gp,-32718
 908f214:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 908f218:	d0a00d04 	addi	r2,gp,-32716
 908f21c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 908f220:	d0a00c04 	addi	r2,gp,-32720
 908f224:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 908f228:	d0a00d84 	addi	r2,gp,-32714
 908f22c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 908f230:	d0a00e04 	addi	r2,gp,-32712
 908f234:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 908f238:	d0a00e84 	addi	r2,gp,-32710
 908f23c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 908f240:	d0a00f04 	addi	r2,gp,-32708
 908f244:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 908f248:	d0a00f84 	addi	r2,gp,-32706
 908f24c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 908f250:	d0a01004 	addi	r2,gp,-32704
 908f254:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 908f258:	d0a01084 	addi	r2,gp,-32702
 908f25c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 908f260:	d0a01104 	addi	r2,gp,-32700
 908f264:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 908f268:	d0a01184 	addi	r2,gp,-32698
 908f26c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 908f270:	d0a01204 	addi	r2,gp,-32696
 908f274:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 908f278:	d0a01284 	addi	r2,gp,-32694
 908f27c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 908f280:	d0a01304 	addi	r2,gp,-32692
 908f284:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 908f288:	d0a01384 	addi	r2,gp,-32690
 908f28c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 908f290:	d0a01404 	addi	r2,gp,-32688
 908f294:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 908f298:	d0a01484 	addi	r2,gp,-32686
 908f29c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 908f2a0:	d0a01504 	addi	r2,gp,-32684
 908f2a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 908f2a8:	d0a01584 	addi	r2,gp,-32682
 908f2ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 908f2b0:	d0a01604 	addi	r2,gp,-32680
 908f2b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 908f2b8:	d0a01684 	addi	r2,gp,-32678
 908f2bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 908f2c0:	d0a01704 	addi	r2,gp,-32676
 908f2c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 908f2c8:	d0a01784 	addi	r2,gp,-32674
 908f2cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 908f2d0:	d0a01804 	addi	r2,gp,-32672
 908f2d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 908f2d8:	d0a01884 	addi	r2,gp,-32670
 908f2dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 908f2e0:	d0a01904 	addi	r2,gp,-32668
 908f2e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 908f2e8:	d0a01984 	addi	r2,gp,-32666
 908f2ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 908f2f0:	d0a01a04 	addi	r2,gp,-32664
 908f2f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 908f2f8:	d0a01a84 	addi	r2,gp,-32662
 908f2fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 908f300:	d0a01b04 	addi	r2,gp,-32660
 908f304:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 908f308:	d0a01b84 	addi	r2,gp,-32658
 908f30c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 908f310:	d0a01c04 	addi	r2,gp,-32656
 908f314:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 908f318:	d0a01c84 	addi	r2,gp,-32654
 908f31c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 908f320:	d0a01d04 	addi	r2,gp,-32652
 908f324:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 908f328:	d0a01d84 	addi	r2,gp,-32650
 908f32c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 908f330:	d0a01e04 	addi	r2,gp,-32648
 908f334:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 908f338:	d0a01e84 	addi	r2,gp,-32646
 908f33c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 908f340:	d0a01f04 	addi	r2,gp,-32644
 908f344:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 908f348:	d0a01f84 	addi	r2,gp,-32642
 908f34c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 908f350:	d0a02004 	addi	r2,gp,-32640
 908f354:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 908f358:	d0a02084 	addi	r2,gp,-32638
 908f35c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 908f360:	d0a02104 	addi	r2,gp,-32636
 908f364:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 908f368:	d0a02604 	addi	r2,gp,-32616
 908f36c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 908f370:	e037883a 	mov	sp,fp
 908f374:	df000017 	ldw	fp,0(sp)
 908f378:	dec00104 	addi	sp,sp,4
 908f37c:	f800283a 	ret

0908f380 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 908f380:	defff104 	addi	sp,sp,-60
 908f384:	df000e15 	stw	fp,56(sp)
 908f388:	df000e04 	addi	fp,sp,56
 908f38c:	e13ffa15 	stw	r4,-24(fp)
 908f390:	e1fffd15 	stw	r7,-12(fp)
 908f394:	e17ffb0d 	sth	r5,-20(fp)
 908f398:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 908f39c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 908f3a0:	e0bffd17 	ldw	r2,-12(fp)
 908f3a4:	1004c03a 	cmpne	r2,r2,zero
 908f3a8:	1000021e 	bne	r2,zero,908f3b4 <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 908f3ac:	e03fff15 	stw	zero,-4(fp)
 908f3b0:	0000bb06 	br	908f6a0 <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 908f3b4:	e0bffa17 	ldw	r2,-24(fp)
 908f3b8:	1004c03a 	cmpne	r2,r2,zero
 908f3bc:	1000051e 	bne	r2,zero,908f3d4 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 908f3c0:	e0fffd17 	ldw	r3,-12(fp)
 908f3c4:	00801b84 	movi	r2,110
 908f3c8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908f3cc:	e03fff15 	stw	zero,-4(fp)
 908f3d0:	0000b306 	br	908f6a0 <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 908f3d4:	e0bffa17 	ldw	r2,-24(fp)
 908f3d8:	10800003 	ldbu	r2,0(r2)
 908f3dc:	10803fcc 	andi	r2,r2,255
 908f3e0:	10800160 	cmpeqi	r2,r2,5
 908f3e4:	1000051e 	bne	r2,zero,908f3fc <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 908f3e8:	e0fffd17 	ldw	r3,-12(fp)
 908f3ec:	00800044 	movi	r2,1
 908f3f0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908f3f4:	e03fff15 	stw	zero,-4(fp)
 908f3f8:	0000a906 	br	908f6a0 <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 908f3fc:	e0fffc03 	ldbu	r3,-16(fp)
 908f400:	00bfe004 	movi	r2,-128
 908f404:	1884703a 	and	r2,r3,r2
 908f408:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 908f40c:	e0bff943 	ldbu	r2,-27(fp)
 908f410:	1005003a 	cmpeq	r2,r2,zero
 908f414:	1000061e 	bne	r2,zero,908f430 <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 908f418:	e0bffc03 	ldbu	r2,-16(fp)
 908f41c:	10801fcc 	andi	r2,r2,127
 908f420:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 908f424:	00800044 	movi	r2,1
 908f428:	e0bff905 	stb	r2,-28(fp)
 908f42c:	00000106 	br	908f434 <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 908f430:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 908f434:	e0bffd17 	ldw	r2,-12(fp)
 908f438:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908f43c:	0005303a 	rdctl	r2,status
 908f440:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908f444:	e0fff717 	ldw	r3,-36(fp)
 908f448:	00bfff84 	movi	r2,-2
 908f44c:	1884703a 	and	r2,r3,r2
 908f450:	1001703a 	wrctl	status,r2
  
  return context;
 908f454:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 908f458:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 908f45c:	e0bffc03 	ldbu	r2,-16(fp)
 908f460:	e0bffe15 	stw	r2,-8(fp)
 908f464:	e0fffe17 	ldw	r3,-8(fp)
 908f468:	18800060 	cmpeqi	r2,r3,1
 908f46c:	1000651e 	bne	r2,zero,908f604 <OSFlagAccept+0x284>
 908f470:	e0fffe17 	ldw	r3,-8(fp)
 908f474:	18800088 	cmpgei	r2,r3,2
 908f478:	1000041e 	bne	r2,zero,908f48c <OSFlagAccept+0x10c>
 908f47c:	e0fffe17 	ldw	r3,-8(fp)
 908f480:	1805003a 	cmpeq	r2,r3,zero
 908f484:	1000421e 	bne	r2,zero,908f590 <OSFlagAccept+0x210>
 908f488:	00007b06 	br	908f678 <OSFlagAccept+0x2f8>
 908f48c:	e0fffe17 	ldw	r3,-8(fp)
 908f490:	188000a0 	cmpeqi	r2,r3,2
 908f494:	1000041e 	bne	r2,zero,908f4a8 <OSFlagAccept+0x128>
 908f498:	e0fffe17 	ldw	r3,-8(fp)
 908f49c:	188000e0 	cmpeqi	r2,r3,3
 908f4a0:	10001e1e 	bne	r2,zero,908f51c <OSFlagAccept+0x19c>
 908f4a4:	00007406 	br	908f678 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 908f4a8:	e0bffa17 	ldw	r2,-24(fp)
 908f4ac:	10c0020b 	ldhu	r3,8(r2)
 908f4b0:	e0bffb0b 	ldhu	r2,-20(fp)
 908f4b4:	1884703a 	and	r2,r3,r2
 908f4b8:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 908f4bc:	e0fff98b 	ldhu	r3,-26(fp)
 908f4c0:	e0bffb0b 	ldhu	r2,-20(fp)
 908f4c4:	18800d1e 	bne	r3,r2,908f4fc <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908f4c8:	e0bff903 	ldbu	r2,-28(fp)
 908f4cc:	10800058 	cmpnei	r2,r2,1
 908f4d0:	10000d1e 	bne	r2,zero,908f508 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 908f4d4:	e0bffa17 	ldw	r2,-24(fp)
 908f4d8:	1080020b 	ldhu	r2,8(r2)
 908f4dc:	1007883a 	mov	r3,r2
 908f4e0:	e0bff98b 	ldhu	r2,-26(fp)
 908f4e4:	0084303a 	nor	r2,zero,r2
 908f4e8:	1884703a 	and	r2,r3,r2
 908f4ec:	1007883a 	mov	r3,r2
 908f4f0:	e0bffa17 	ldw	r2,-24(fp)
 908f4f4:	10c0020d 	sth	r3,8(r2)
 908f4f8:	00000306 	br	908f508 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 908f4fc:	e0fffd17 	ldw	r3,-12(fp)
 908f500:	00801c04 	movi	r2,112
 908f504:	18800005 	stb	r2,0(r3)
 908f508:	e0bff817 	ldw	r2,-32(fp)
 908f50c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908f510:	e0bff617 	ldw	r2,-40(fp)
 908f514:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 908f518:	00005f06 	br	908f698 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 908f51c:	e0bffa17 	ldw	r2,-24(fp)
 908f520:	10c0020b 	ldhu	r3,8(r2)
 908f524:	e0bffb0b 	ldhu	r2,-20(fp)
 908f528:	1884703a 	and	r2,r3,r2
 908f52c:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 908f530:	e0bff98b 	ldhu	r2,-26(fp)
 908f534:	1005003a 	cmpeq	r2,r2,zero
 908f538:	10000d1e 	bne	r2,zero,908f570 <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908f53c:	e0bff903 	ldbu	r2,-28(fp)
 908f540:	10800058 	cmpnei	r2,r2,1
 908f544:	10000d1e 	bne	r2,zero,908f57c <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 908f548:	e0bffa17 	ldw	r2,-24(fp)
 908f54c:	1080020b 	ldhu	r2,8(r2)
 908f550:	1007883a 	mov	r3,r2
 908f554:	e0bff98b 	ldhu	r2,-26(fp)
 908f558:	0084303a 	nor	r2,zero,r2
 908f55c:	1884703a 	and	r2,r3,r2
 908f560:	1007883a 	mov	r3,r2
 908f564:	e0bffa17 	ldw	r2,-24(fp)
 908f568:	10c0020d 	sth	r3,8(r2)
 908f56c:	00000306 	br	908f57c <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 908f570:	e0fffd17 	ldw	r3,-12(fp)
 908f574:	00801c04 	movi	r2,112
 908f578:	18800005 	stb	r2,0(r3)
 908f57c:	e0bff817 	ldw	r2,-32(fp)
 908f580:	e0bff515 	stw	r2,-44(fp)
 908f584:	e0bff517 	ldw	r2,-44(fp)
 908f588:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 908f58c:	00004206 	br	908f698 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 908f590:	e0bffa17 	ldw	r2,-24(fp)
 908f594:	1080020b 	ldhu	r2,8(r2)
 908f598:	0084303a 	nor	r2,zero,r2
 908f59c:	1007883a 	mov	r3,r2
 908f5a0:	e0bffb0b 	ldhu	r2,-20(fp)
 908f5a4:	1884703a 	and	r2,r3,r2
 908f5a8:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 908f5ac:	e0fff98b 	ldhu	r3,-26(fp)
 908f5b0:	e0bffb0b 	ldhu	r2,-20(fp)
 908f5b4:	18800b1e 	bne	r3,r2,908f5e4 <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908f5b8:	e0bff903 	ldbu	r2,-28(fp)
 908f5bc:	10800058 	cmpnei	r2,r2,1
 908f5c0:	10000b1e 	bne	r2,zero,908f5f0 <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 908f5c4:	e0bffa17 	ldw	r2,-24(fp)
 908f5c8:	10c0020b 	ldhu	r3,8(r2)
 908f5cc:	e0bff98b 	ldhu	r2,-26(fp)
 908f5d0:	1884b03a 	or	r2,r3,r2
 908f5d4:	1007883a 	mov	r3,r2
 908f5d8:	e0bffa17 	ldw	r2,-24(fp)
 908f5dc:	10c0020d 	sth	r3,8(r2)
 908f5e0:	00000306 	br	908f5f0 <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 908f5e4:	e0fffd17 	ldw	r3,-12(fp)
 908f5e8:	00801c04 	movi	r2,112
 908f5ec:	18800005 	stb	r2,0(r3)
 908f5f0:	e0bff817 	ldw	r2,-32(fp)
 908f5f4:	e0bff415 	stw	r2,-48(fp)
 908f5f8:	e0bff417 	ldw	r2,-48(fp)
 908f5fc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 908f600:	00002506 	br	908f698 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 908f604:	e0bffa17 	ldw	r2,-24(fp)
 908f608:	1080020b 	ldhu	r2,8(r2)
 908f60c:	0084303a 	nor	r2,zero,r2
 908f610:	1007883a 	mov	r3,r2
 908f614:	e0bffb0b 	ldhu	r2,-20(fp)
 908f618:	1884703a 	and	r2,r3,r2
 908f61c:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 908f620:	e0bff98b 	ldhu	r2,-26(fp)
 908f624:	1005003a 	cmpeq	r2,r2,zero
 908f628:	10000b1e 	bne	r2,zero,908f658 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908f62c:	e0bff903 	ldbu	r2,-28(fp)
 908f630:	10800058 	cmpnei	r2,r2,1
 908f634:	10000b1e 	bne	r2,zero,908f664 <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 908f638:	e0bffa17 	ldw	r2,-24(fp)
 908f63c:	10c0020b 	ldhu	r3,8(r2)
 908f640:	e0bff98b 	ldhu	r2,-26(fp)
 908f644:	1884b03a 	or	r2,r3,r2
 908f648:	1007883a 	mov	r3,r2
 908f64c:	e0bffa17 	ldw	r2,-24(fp)
 908f650:	10c0020d 	sth	r3,8(r2)
 908f654:	00000306 	br	908f664 <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 908f658:	e0fffd17 	ldw	r3,-12(fp)
 908f65c:	00801c04 	movi	r2,112
 908f660:	18800005 	stb	r2,0(r3)
 908f664:	e0bff817 	ldw	r2,-32(fp)
 908f668:	e0bff315 	stw	r2,-52(fp)
 908f66c:	e0bff317 	ldw	r2,-52(fp)
 908f670:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 908f674:	00000806 	br	908f698 <OSFlagAccept+0x318>
 908f678:	e0bff817 	ldw	r2,-32(fp)
 908f67c:	e0bff215 	stw	r2,-56(fp)
 908f680:	e0bff217 	ldw	r2,-56(fp)
 908f684:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 908f688:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 908f68c:	e0fffd17 	ldw	r3,-12(fp)
 908f690:	00801bc4 	movi	r2,111
 908f694:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 908f698:	e0bff98b 	ldhu	r2,-26(fp)
 908f69c:	e0bfff15 	stw	r2,-4(fp)
 908f6a0:	e0bfff17 	ldw	r2,-4(fp)
}
 908f6a4:	e037883a 	mov	sp,fp
 908f6a8:	df000017 	ldw	fp,0(sp)
 908f6ac:	dec00104 	addi	sp,sp,4
 908f6b0:	f800283a 	ret

0908f6b4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 908f6b4:	defff704 	addi	sp,sp,-36
 908f6b8:	df000815 	stw	fp,32(sp)
 908f6bc:	df000804 	addi	fp,sp,32
 908f6c0:	e17ffe15 	stw	r5,-8(fp)
 908f6c4:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 908f6c8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 908f6cc:	e0bffe17 	ldw	r2,-8(fp)
 908f6d0:	1004c03a 	cmpne	r2,r2,zero
 908f6d4:	1000021e 	bne	r2,zero,908f6e0 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 908f6d8:	e03fff15 	stw	zero,-4(fp)
 908f6dc:	00003f06 	br	908f7dc <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 908f6e0:	00824374 	movhi	r2,2317
 908f6e4:	108c1304 	addi	r2,r2,12364
 908f6e8:	10800003 	ldbu	r2,0(r2)
 908f6ec:	10803fcc 	andi	r2,r2,255
 908f6f0:	1005003a 	cmpeq	r2,r2,zero
 908f6f4:	1000051e 	bne	r2,zero,908f70c <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 908f6f8:	e0fffe17 	ldw	r3,-8(fp)
 908f6fc:	00800404 	movi	r2,16
 908f700:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 908f704:	e03fff15 	stw	zero,-4(fp)
 908f708:	00003406 	br	908f7dc <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908f70c:	0005303a 	rdctl	r2,status
 908f710:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908f714:	e0fffa17 	ldw	r3,-24(fp)
 908f718:	00bfff84 	movi	r2,-2
 908f71c:	1884703a 	and	r2,r3,r2
 908f720:	1001703a 	wrctl	status,r2
  
  return context;
 908f724:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 908f728:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 908f72c:	00824374 	movhi	r2,2317
 908f730:	108c1604 	addi	r2,r2,12376
 908f734:	10800017 	ldw	r2,0(r2)
 908f738:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 908f73c:	e0bffc17 	ldw	r2,-16(fp)
 908f740:	1005003a 	cmpeq	r2,r2,zero
 908f744:	10001c1e 	bne	r2,zero,908f7b8 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 908f748:	00824374 	movhi	r2,2317
 908f74c:	108c1604 	addi	r2,r2,12376
 908f750:	10800017 	ldw	r2,0(r2)
 908f754:	10800117 	ldw	r2,4(r2)
 908f758:	1007883a 	mov	r3,r2
 908f75c:	00824374 	movhi	r2,2317
 908f760:	108c1604 	addi	r2,r2,12376
 908f764:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 908f768:	e0fffc17 	ldw	r3,-16(fp)
 908f76c:	00800144 	movi	r2,5
 908f770:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 908f774:	e0fffc17 	ldw	r3,-16(fp)
 908f778:	e0bffd0b 	ldhu	r2,-12(fp)
 908f77c:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 908f780:	e0bffc17 	ldw	r2,-16(fp)
 908f784:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 908f788:	e0fffc17 	ldw	r3,-16(fp)
 908f78c:	00800fc4 	movi	r2,63
 908f790:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 908f794:	e0bffc17 	ldw	r2,-16(fp)
 908f798:	100002c5 	stb	zero,11(r2)
 908f79c:	e0bffb17 	ldw	r2,-20(fp)
 908f7a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908f7a4:	e0bff917 	ldw	r2,-28(fp)
 908f7a8:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 908f7ac:	e0bffe17 	ldw	r2,-8(fp)
 908f7b0:	10000005 	stb	zero,0(r2)
 908f7b4:	00000706 	br	908f7d4 <OSFlagCreate+0x120>
 908f7b8:	e0bffb17 	ldw	r2,-20(fp)
 908f7bc:	e0bff815 	stw	r2,-32(fp)
 908f7c0:	e0bff817 	ldw	r2,-32(fp)
 908f7c4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 908f7c8:	e0fffe17 	ldw	r3,-8(fp)
 908f7cc:	00801c84 	movi	r2,114
 908f7d0:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 908f7d4:	e0bffc17 	ldw	r2,-16(fp)
 908f7d8:	e0bfff15 	stw	r2,-4(fp)
 908f7dc:	e0bfff17 	ldw	r2,-4(fp)
}
 908f7e0:	e037883a 	mov	sp,fp
 908f7e4:	df000017 	ldw	fp,0(sp)
 908f7e8:	dec00104 	addi	sp,sp,4
 908f7ec:	f800283a 	ret

0908f7f0 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 908f7f0:	defff004 	addi	sp,sp,-64
 908f7f4:	dfc00f15 	stw	ra,60(sp)
 908f7f8:	df000e15 	stw	fp,56(sp)
 908f7fc:	df000e04 	addi	fp,sp,56
 908f800:	e13ffb15 	stw	r4,-20(fp)
 908f804:	e1bffd15 	stw	r6,-12(fp)
 908f808:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 908f80c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 908f810:	e0bffd17 	ldw	r2,-12(fp)
 908f814:	1004c03a 	cmpne	r2,r2,zero
 908f818:	1000031e 	bne	r2,zero,908f828 <OSFlagDel+0x38>
        return (pgrp);
 908f81c:	e0bffb17 	ldw	r2,-20(fp)
 908f820:	e0bfff15 	stw	r2,-4(fp)
 908f824:	00009606 	br	908fa80 <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 908f828:	e0bffb17 	ldw	r2,-20(fp)
 908f82c:	1004c03a 	cmpne	r2,r2,zero
 908f830:	1000061e 	bne	r2,zero,908f84c <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 908f834:	e0fffd17 	ldw	r3,-12(fp)
 908f838:	00801b84 	movi	r2,110
 908f83c:	18800005 	stb	r2,0(r3)
        return (pgrp);
 908f840:	e0fffb17 	ldw	r3,-20(fp)
 908f844:	e0ffff15 	stw	r3,-4(fp)
 908f848:	00008d06 	br	908fa80 <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 908f84c:	00824374 	movhi	r2,2317
 908f850:	108c1304 	addi	r2,r2,12364
 908f854:	10800003 	ldbu	r2,0(r2)
 908f858:	10803fcc 	andi	r2,r2,255
 908f85c:	1005003a 	cmpeq	r2,r2,zero
 908f860:	1000061e 	bne	r2,zero,908f87c <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 908f864:	e0fffd17 	ldw	r3,-12(fp)
 908f868:	008003c4 	movi	r2,15
 908f86c:	18800005 	stb	r2,0(r3)
        return (pgrp);
 908f870:	e0bffb17 	ldw	r2,-20(fp)
 908f874:	e0bfff15 	stw	r2,-4(fp)
 908f878:	00008106 	br	908fa80 <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 908f87c:	e0bffb17 	ldw	r2,-20(fp)
 908f880:	10800003 	ldbu	r2,0(r2)
 908f884:	10803fcc 	andi	r2,r2,255
 908f888:	10800160 	cmpeqi	r2,r2,5
 908f88c:	1000061e 	bne	r2,zero,908f8a8 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 908f890:	e0fffd17 	ldw	r3,-12(fp)
 908f894:	00800044 	movi	r2,1
 908f898:	18800005 	stb	r2,0(r3)
        return (pgrp);
 908f89c:	e0fffb17 	ldw	r3,-20(fp)
 908f8a0:	e0ffff15 	stw	r3,-4(fp)
 908f8a4:	00007606 	br	908fa80 <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908f8a8:	0005303a 	rdctl	r2,status
 908f8ac:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908f8b0:	e0fff617 	ldw	r3,-40(fp)
 908f8b4:	00bfff84 	movi	r2,-2
 908f8b8:	1884703a 	and	r2,r3,r2
 908f8bc:	1001703a 	wrctl	status,r2
  
  return context;
 908f8c0:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 908f8c4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 908f8c8:	e0bffb17 	ldw	r2,-20(fp)
 908f8cc:	10800117 	ldw	r2,4(r2)
 908f8d0:	1005003a 	cmpeq	r2,r2,zero
 908f8d4:	1000031e 	bne	r2,zero,908f8e4 <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 908f8d8:	00800044 	movi	r2,1
 908f8dc:	e0bffa05 	stb	r2,-24(fp)
 908f8e0:	00000106 	br	908f8e8 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 908f8e4:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 908f8e8:	e0bffc03 	ldbu	r2,-16(fp)
 908f8ec:	e0bffe15 	stw	r2,-8(fp)
 908f8f0:	e0fffe17 	ldw	r3,-8(fp)
 908f8f4:	1805003a 	cmpeq	r2,r3,zero
 908f8f8:	1000041e 	bne	r2,zero,908f90c <OSFlagDel+0x11c>
 908f8fc:	e0fffe17 	ldw	r3,-8(fp)
 908f900:	18800060 	cmpeqi	r2,r3,1
 908f904:	1000281e 	bne	r2,zero,908f9a8 <OSFlagDel+0x1b8>
 908f908:	00005206 	br	908fa54 <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 908f90c:	e0bffa03 	ldbu	r2,-24(fp)
 908f910:	1004c03a 	cmpne	r2,r2,zero
 908f914:	10001a1e 	bne	r2,zero,908f980 <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 908f918:	e0fffb17 	ldw	r3,-20(fp)
 908f91c:	00800fc4 	movi	r2,63
 908f920:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 908f924:	e0bffb17 	ldw	r2,-20(fp)
 908f928:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 908f92c:	e0bffb17 	ldw	r2,-20(fp)
 908f930:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 908f934:	00824374 	movhi	r2,2317
 908f938:	108c1604 	addi	r2,r2,12376
 908f93c:	10c00017 	ldw	r3,0(r2)
 908f940:	e0bffb17 	ldw	r2,-20(fp)
 908f944:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 908f948:	e0bffb17 	ldw	r2,-20(fp)
 908f94c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 908f950:	00c24374 	movhi	r3,2317
 908f954:	18cc1604 	addi	r3,r3,12376
 908f958:	e0bffb17 	ldw	r2,-20(fp)
 908f95c:	18800015 	stw	r2,0(r3)
 908f960:	e0bff717 	ldw	r2,-36(fp)
 908f964:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908f968:	e0bff517 	ldw	r2,-44(fp)
 908f96c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 908f970:	e0bffd17 	ldw	r2,-12(fp)
 908f974:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 908f978:	e03ff815 	stw	zero,-32(fp)
 908f97c:	00003e06 	br	908fa78 <OSFlagDel+0x288>
 908f980:	e0bff717 	ldw	r2,-36(fp)
 908f984:	e0bff415 	stw	r2,-48(fp)
 908f988:	e0bff417 	ldw	r2,-48(fp)
 908f98c:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 908f990:	e0fffd17 	ldw	r3,-12(fp)
 908f994:	00801244 	movi	r2,73
 908f998:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 908f99c:	e0bffb17 	ldw	r2,-20(fp)
 908f9a0:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 908f9a4:	00003406 	br	908fa78 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 908f9a8:	e0bffb17 	ldw	r2,-20(fp)
 908f9ac:	10800117 	ldw	r2,4(r2)
 908f9b0:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 908f9b4:	00000606 	br	908f9d0 <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 908f9b8:	e13ff917 	ldw	r4,-28(fp)
 908f9bc:	000b883a 	mov	r5,zero
 908f9c0:	9090b000 	call	9090b00 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 908f9c4:	e0bff917 	ldw	r2,-28(fp)
 908f9c8:	10800017 	ldw	r2,0(r2)
 908f9cc:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 908f9d0:	e0bff917 	ldw	r2,-28(fp)
 908f9d4:	1004c03a 	cmpne	r2,r2,zero
 908f9d8:	103ff71e 	bne	r2,zero,908f9b8 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 908f9dc:	e0fffb17 	ldw	r3,-20(fp)
 908f9e0:	00800fc4 	movi	r2,63
 908f9e4:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 908f9e8:	e0bffb17 	ldw	r2,-20(fp)
 908f9ec:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 908f9f0:	e0bffb17 	ldw	r2,-20(fp)
 908f9f4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 908f9f8:	00824374 	movhi	r2,2317
 908f9fc:	108c1604 	addi	r2,r2,12376
 908fa00:	10c00017 	ldw	r3,0(r2)
 908fa04:	e0bffb17 	ldw	r2,-20(fp)
 908fa08:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 908fa0c:	e0bffb17 	ldw	r2,-20(fp)
 908fa10:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 908fa14:	00c24374 	movhi	r3,2317
 908fa18:	18cc1604 	addi	r3,r3,12376
 908fa1c:	e0bffb17 	ldw	r2,-20(fp)
 908fa20:	18800015 	stw	r2,0(r3)
 908fa24:	e0bff717 	ldw	r2,-36(fp)
 908fa28:	e0bff315 	stw	r2,-52(fp)
 908fa2c:	e0bff317 	ldw	r2,-52(fp)
 908fa30:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 908fa34:	e0bffa03 	ldbu	r2,-24(fp)
 908fa38:	10800058 	cmpnei	r2,r2,1
 908fa3c:	1000011e 	bne	r2,zero,908fa44 <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 908fa40:	908eaf40 	call	908eaf4 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 908fa44:	e0bffd17 	ldw	r2,-12(fp)
 908fa48:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 908fa4c:	e03ff815 	stw	zero,-32(fp)
             break;
 908fa50:	00000906 	br	908fa78 <OSFlagDel+0x288>
 908fa54:	e0bff717 	ldw	r2,-36(fp)
 908fa58:	e0bff215 	stw	r2,-56(fp)
 908fa5c:	e0bff217 	ldw	r2,-56(fp)
 908fa60:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 908fa64:	e0fffd17 	ldw	r3,-12(fp)
 908fa68:	008001c4 	movi	r2,7
 908fa6c:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 908fa70:	e0bffb17 	ldw	r2,-20(fp)
 908fa74:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 908fa78:	e0bff817 	ldw	r2,-32(fp)
 908fa7c:	e0bfff15 	stw	r2,-4(fp)
 908fa80:	e0bfff17 	ldw	r2,-4(fp)
}
 908fa84:	e037883a 	mov	sp,fp
 908fa88:	dfc00117 	ldw	ra,4(sp)
 908fa8c:	df000017 	ldw	fp,0(sp)
 908fa90:	dec00204 	addi	sp,sp,8
 908fa94:	f800283a 	ret

0908fa98 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 908fa98:	defff504 	addi	sp,sp,-44
 908fa9c:	dfc00a15 	stw	ra,40(sp)
 908faa0:	df000915 	stw	fp,36(sp)
 908faa4:	df000904 	addi	fp,sp,36
 908faa8:	e13ffc15 	stw	r4,-16(fp)
 908faac:	e17ffd15 	stw	r5,-12(fp)
 908fab0:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908fab4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908fab8:	e0bffe17 	ldw	r2,-8(fp)
 908fabc:	1004c03a 	cmpne	r2,r2,zero
 908fac0:	1000021e 	bne	r2,zero,908facc <OSFlagNameGet+0x34>
        return (0);
 908fac4:	e03fff15 	stw	zero,-4(fp)
 908fac8:	00003e06 	br	908fbc4 <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 908facc:	e0bffc17 	ldw	r2,-16(fp)
 908fad0:	1004c03a 	cmpne	r2,r2,zero
 908fad4:	1000051e 	bne	r2,zero,908faec <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 908fad8:	e0fffe17 	ldw	r3,-8(fp)
 908fadc:	00801b84 	movi	r2,110
 908fae0:	18800005 	stb	r2,0(r3)
        return (0);
 908fae4:	e03fff15 	stw	zero,-4(fp)
 908fae8:	00003606 	br	908fbc4 <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908faec:	e0bffd17 	ldw	r2,-12(fp)
 908faf0:	1004c03a 	cmpne	r2,r2,zero
 908faf4:	1000051e 	bne	r2,zero,908fb0c <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 908faf8:	e0fffe17 	ldw	r3,-8(fp)
 908fafc:	00800304 	movi	r2,12
 908fb00:	18800005 	stb	r2,0(r3)
        return (0);
 908fb04:	e03fff15 	stw	zero,-4(fp)
 908fb08:	00002e06 	br	908fbc4 <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908fb0c:	00824374 	movhi	r2,2317
 908fb10:	108c1304 	addi	r2,r2,12364
 908fb14:	10800003 	ldbu	r2,0(r2)
 908fb18:	10803fcc 	andi	r2,r2,255
 908fb1c:	1005003a 	cmpeq	r2,r2,zero
 908fb20:	1000051e 	bne	r2,zero,908fb38 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 908fb24:	e0fffe17 	ldw	r3,-8(fp)
 908fb28:	00800444 	movi	r2,17
 908fb2c:	18800005 	stb	r2,0(r3)
        return (0);
 908fb30:	e03fff15 	stw	zero,-4(fp)
 908fb34:	00002306 	br	908fbc4 <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908fb38:	0005303a 	rdctl	r2,status
 908fb3c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fb40:	e0fff917 	ldw	r3,-28(fp)
 908fb44:	00bfff84 	movi	r2,-2
 908fb48:	1884703a 	and	r2,r3,r2
 908fb4c:	1001703a 	wrctl	status,r2
  
  return context;
 908fb50:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 908fb54:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 908fb58:	e0bffc17 	ldw	r2,-16(fp)
 908fb5c:	10800003 	ldbu	r2,0(r2)
 908fb60:	10803fcc 	andi	r2,r2,255
 908fb64:	10800160 	cmpeqi	r2,r2,5
 908fb68:	1000091e 	bne	r2,zero,908fb90 <OSFlagNameGet+0xf8>
 908fb6c:	e0bffa17 	ldw	r2,-24(fp)
 908fb70:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908fb74:	e0bff817 	ldw	r2,-32(fp)
 908fb78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 908fb7c:	e0fffe17 	ldw	r3,-8(fp)
 908fb80:	00800044 	movi	r2,1
 908fb84:	18800005 	stb	r2,0(r3)
        return (0);
 908fb88:	e03fff15 	stw	zero,-4(fp)
 908fb8c:	00000d06 	br	908fbc4 <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 908fb90:	e0bffc17 	ldw	r2,-16(fp)
 908fb94:	11400284 	addi	r5,r2,10
 908fb98:	e13ffd17 	ldw	r4,-12(fp)
 908fb9c:	908ec380 	call	908ec38 <OS_StrCopy>
 908fba0:	e0bffb05 	stb	r2,-20(fp)
 908fba4:	e0bffa17 	ldw	r2,-24(fp)
 908fba8:	e0bff715 	stw	r2,-36(fp)
 908fbac:	e0bff717 	ldw	r2,-36(fp)
 908fbb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908fbb4:	e0bffe17 	ldw	r2,-8(fp)
 908fbb8:	10000005 	stb	zero,0(r2)
    return (len);
 908fbbc:	e0bffb03 	ldbu	r2,-20(fp)
 908fbc0:	e0bfff15 	stw	r2,-4(fp)
 908fbc4:	e0bfff17 	ldw	r2,-4(fp)
}
 908fbc8:	e037883a 	mov	sp,fp
 908fbcc:	dfc00117 	ldw	ra,4(sp)
 908fbd0:	df000017 	ldw	fp,0(sp)
 908fbd4:	dec00204 	addi	sp,sp,8
 908fbd8:	f800283a 	ret

0908fbdc <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 908fbdc:	defff504 	addi	sp,sp,-44
 908fbe0:	dfc00a15 	stw	ra,40(sp)
 908fbe4:	df000915 	stw	fp,36(sp)
 908fbe8:	df000904 	addi	fp,sp,36
 908fbec:	e13ffd15 	stw	r4,-12(fp)
 908fbf0:	e17ffe15 	stw	r5,-8(fp)
 908fbf4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908fbf8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908fbfc:	e0bfff17 	ldw	r2,-4(fp)
 908fc00:	1005003a 	cmpeq	r2,r2,zero
 908fc04:	1000451e 	bne	r2,zero,908fd1c <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 908fc08:	e0bffd17 	ldw	r2,-12(fp)
 908fc0c:	1004c03a 	cmpne	r2,r2,zero
 908fc10:	1000041e 	bne	r2,zero,908fc24 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 908fc14:	e0ffff17 	ldw	r3,-4(fp)
 908fc18:	00801b84 	movi	r2,110
 908fc1c:	18800005 	stb	r2,0(r3)
        return;
 908fc20:	00003e06 	br	908fd1c <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908fc24:	e0bffe17 	ldw	r2,-8(fp)
 908fc28:	1004c03a 	cmpne	r2,r2,zero
 908fc2c:	1000041e 	bne	r2,zero,908fc40 <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 908fc30:	e0ffff17 	ldw	r3,-4(fp)
 908fc34:	00800304 	movi	r2,12
 908fc38:	18800005 	stb	r2,0(r3)
        return;
 908fc3c:	00003706 	br	908fd1c <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908fc40:	00824374 	movhi	r2,2317
 908fc44:	108c1304 	addi	r2,r2,12364
 908fc48:	10800003 	ldbu	r2,0(r2)
 908fc4c:	10803fcc 	andi	r2,r2,255
 908fc50:	1005003a 	cmpeq	r2,r2,zero
 908fc54:	1000041e 	bne	r2,zero,908fc68 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 908fc58:	e0ffff17 	ldw	r3,-4(fp)
 908fc5c:	00800484 	movi	r2,18
 908fc60:	18800005 	stb	r2,0(r3)
        return;
 908fc64:	00002d06 	br	908fd1c <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908fc68:	0005303a 	rdctl	r2,status
 908fc6c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fc70:	e0fffa17 	ldw	r3,-24(fp)
 908fc74:	00bfff84 	movi	r2,-2
 908fc78:	1884703a 	and	r2,r3,r2
 908fc7c:	1001703a 	wrctl	status,r2
  
  return context;
 908fc80:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 908fc84:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 908fc88:	e0bffd17 	ldw	r2,-12(fp)
 908fc8c:	10800003 	ldbu	r2,0(r2)
 908fc90:	10803fcc 	andi	r2,r2,255
 908fc94:	10800160 	cmpeqi	r2,r2,5
 908fc98:	1000081e 	bne	r2,zero,908fcbc <OSFlagNameSet+0xe0>
 908fc9c:	e0bffb17 	ldw	r2,-20(fp)
 908fca0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908fca4:	e0bff917 	ldw	r2,-28(fp)
 908fca8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 908fcac:	e0ffff17 	ldw	r3,-4(fp)
 908fcb0:	00800044 	movi	r2,1
 908fcb4:	18800005 	stb	r2,0(r3)
        return;
 908fcb8:	00001806 	br	908fd1c <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 908fcbc:	e13ffe17 	ldw	r4,-8(fp)
 908fcc0:	908ecb80 	call	908ecb8 <OS_StrLen>
 908fcc4:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 908fcc8:	e0bffc03 	ldbu	r2,-16(fp)
 908fccc:	10800830 	cmpltui	r2,r2,32
 908fcd0:	1000081e 	bne	r2,zero,908fcf4 <OSFlagNameSet+0x118>
 908fcd4:	e0bffb17 	ldw	r2,-20(fp)
 908fcd8:	e0bff815 	stw	r2,-32(fp)
 908fcdc:	e0bff817 	ldw	r2,-32(fp)
 908fce0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 908fce4:	e0ffff17 	ldw	r3,-4(fp)
 908fce8:	00801cc4 	movi	r2,115
 908fcec:	18800005 	stb	r2,0(r3)
        return;
 908fcf0:	00000a06 	br	908fd1c <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 908fcf4:	e0bffd17 	ldw	r2,-12(fp)
 908fcf8:	11000284 	addi	r4,r2,10
 908fcfc:	e17ffe17 	ldw	r5,-8(fp)
 908fd00:	908ec380 	call	908ec38 <OS_StrCopy>
 908fd04:	e0bffb17 	ldw	r2,-20(fp)
 908fd08:	e0bff715 	stw	r2,-36(fp)
 908fd0c:	e0bff717 	ldw	r2,-36(fp)
 908fd10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908fd14:	e0bfff17 	ldw	r2,-4(fp)
 908fd18:	10000005 	stb	zero,0(r2)
    return;
}
 908fd1c:	e037883a 	mov	sp,fp
 908fd20:	dfc00117 	ldw	ra,4(sp)
 908fd24:	df000017 	ldw	fp,0(sp)
 908fd28:	dec00204 	addi	sp,sp,8
 908fd2c:	f800283a 	ret

0908fd30 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 908fd30:	deffe004 	addi	sp,sp,-128
 908fd34:	dfc01f15 	stw	ra,124(sp)
 908fd38:	df001e15 	stw	fp,120(sp)
 908fd3c:	df001e04 	addi	fp,sp,120
 908fd40:	e13ff915 	stw	r4,-28(fp)
 908fd44:	e17ffa0d 	sth	r5,-24(fp)
 908fd48:	e1bffb05 	stb	r6,-20(fp)
 908fd4c:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 908fd50:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 908fd54:	e0800217 	ldw	r2,8(fp)
 908fd58:	1004c03a 	cmpne	r2,r2,zero
 908fd5c:	1000021e 	bne	r2,zero,908fd68 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 908fd60:	e03fff15 	stw	zero,-4(fp)
 908fd64:	00017d06 	br	909035c <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 908fd68:	e0bff917 	ldw	r2,-28(fp)
 908fd6c:	1004c03a 	cmpne	r2,r2,zero
 908fd70:	1000051e 	bne	r2,zero,908fd88 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 908fd74:	e0c00217 	ldw	r3,8(fp)
 908fd78:	00801b84 	movi	r2,110
 908fd7c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908fd80:	e03fff15 	stw	zero,-4(fp)
 908fd84:	00017506 	br	909035c <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 908fd88:	00824374 	movhi	r2,2317
 908fd8c:	108c1304 	addi	r2,r2,12364
 908fd90:	10800003 	ldbu	r2,0(r2)
 908fd94:	10803fcc 	andi	r2,r2,255
 908fd98:	1005003a 	cmpeq	r2,r2,zero
 908fd9c:	1000051e 	bne	r2,zero,908fdb4 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 908fda0:	e0c00217 	ldw	r3,8(fp)
 908fda4:	00800084 	movi	r2,2
 908fda8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908fdac:	e03fff15 	stw	zero,-4(fp)
 908fdb0:	00016a06 	br	909035c <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 908fdb4:	00824374 	movhi	r2,2317
 908fdb8:	108c0504 	addi	r2,r2,12308
 908fdbc:	10800003 	ldbu	r2,0(r2)
 908fdc0:	10803fcc 	andi	r2,r2,255
 908fdc4:	1005003a 	cmpeq	r2,r2,zero
 908fdc8:	1000051e 	bne	r2,zero,908fde0 <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 908fdcc:	e0c00217 	ldw	r3,8(fp)
 908fdd0:	00800344 	movi	r2,13
 908fdd4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908fdd8:	e03fff15 	stw	zero,-4(fp)
 908fddc:	00015f06 	br	909035c <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 908fde0:	e0bff917 	ldw	r2,-28(fp)
 908fde4:	10800003 	ldbu	r2,0(r2)
 908fde8:	10803fcc 	andi	r2,r2,255
 908fdec:	10800160 	cmpeqi	r2,r2,5
 908fdf0:	1000051e 	bne	r2,zero,908fe08 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 908fdf4:	e0c00217 	ldw	r3,8(fp)
 908fdf8:	00800044 	movi	r2,1
 908fdfc:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 908fe00:	e03fff15 	stw	zero,-4(fp)
 908fe04:	00015506 	br	909035c <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 908fe08:	e0fffb03 	ldbu	r3,-20(fp)
 908fe0c:	00bfe004 	movi	r2,-128
 908fe10:	1884703a 	and	r2,r3,r2
 908fe14:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 908fe18:	e0bff283 	ldbu	r2,-54(fp)
 908fe1c:	1005003a 	cmpeq	r2,r2,zero
 908fe20:	1000071e 	bne	r2,zero,908fe40 <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 908fe24:	00c01fc4 	movi	r3,127
 908fe28:	e0bffb03 	ldbu	r2,-20(fp)
 908fe2c:	10c4703a 	and	r2,r2,r3
 908fe30:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 908fe34:	00800044 	movi	r2,1
 908fe38:	e0bff205 	stb	r2,-56(fp)
 908fe3c:	00000106 	br	908fe44 <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 908fe40:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908fe44:	0005303a 	rdctl	r2,status
 908fe48:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fe4c:	e0fff017 	ldw	r3,-64(fp)
 908fe50:	00bfff84 	movi	r2,-2
 908fe54:	1884703a 	and	r2,r3,r2
 908fe58:	1001703a 	wrctl	status,r2
  
  return context;
 908fe5c:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 908fe60:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 908fe64:	e0bffb03 	ldbu	r2,-20(fp)
 908fe68:	e0bffe15 	stw	r2,-8(fp)
 908fe6c:	e0fffe17 	ldw	r3,-8(fp)
 908fe70:	18800060 	cmpeqi	r2,r3,1
 908fe74:	1000981e 	bne	r2,zero,90900d8 <OSFlagPend+0x3a8>
 908fe78:	e0fffe17 	ldw	r3,-8(fp)
 908fe7c:	18800088 	cmpgei	r2,r3,2
 908fe80:	1000041e 	bne	r2,zero,908fe94 <OSFlagPend+0x164>
 908fe84:	e0fffe17 	ldw	r3,-8(fp)
 908fe88:	1805003a 	cmpeq	r2,r3,zero
 908fe8c:	1000641e 	bne	r2,zero,9090020 <OSFlagPend+0x2f0>
 908fe90:	0000bf06 	br	9090190 <OSFlagPend+0x460>
 908fe94:	e0fffe17 	ldw	r3,-8(fp)
 908fe98:	188000a0 	cmpeqi	r2,r3,2
 908fe9c:	1000041e 	bne	r2,zero,908feb0 <OSFlagPend+0x180>
 908fea0:	e0fffe17 	ldw	r3,-8(fp)
 908fea4:	188000e0 	cmpeqi	r2,r3,3
 908fea8:	10002f1e 	bne	r2,zero,908ff68 <OSFlagPend+0x238>
 908feac:	0000b806 	br	9090190 <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 908feb0:	e0bff917 	ldw	r2,-28(fp)
 908feb4:	10c0020b 	ldhu	r3,8(r2)
 908feb8:	e0bffa0b 	ldhu	r2,-24(fp)
 908febc:	1884703a 	and	r2,r3,r2
 908fec0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 908fec4:	e0fff30b 	ldhu	r3,-52(fp)
 908fec8:	e0bffa0b 	ldhu	r2,-24(fp)
 908fecc:	18801a1e 	bne	r3,r2,908ff38 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908fed0:	e0bff203 	ldbu	r2,-56(fp)
 908fed4:	10800058 	cmpnei	r2,r2,1
 908fed8:	1000091e 	bne	r2,zero,908ff00 <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 908fedc:	e0bff917 	ldw	r2,-28(fp)
 908fee0:	1080020b 	ldhu	r2,8(r2)
 908fee4:	1007883a 	mov	r3,r2
 908fee8:	e0bff30b 	ldhu	r2,-52(fp)
 908feec:	0084303a 	nor	r2,zero,r2
 908fef0:	1884703a 	and	r2,r3,r2
 908fef4:	1007883a 	mov	r3,r2
 908fef8:	e0bff917 	ldw	r2,-28(fp)
 908fefc:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 908ff00:	00824374 	movhi	r2,2317
 908ff04:	108c1404 	addi	r2,r2,12368
 908ff08:	10c00017 	ldw	r3,0(r2)
 908ff0c:	e0bff30b 	ldhu	r2,-52(fp)
 908ff10:	18800b0d 	sth	r2,44(r3)
 908ff14:	e0bff117 	ldw	r2,-60(fp)
 908ff18:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ff1c:	e0bfef17 	ldw	r2,-68(fp)
 908ff20:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 908ff24:	e0800217 	ldw	r2,8(fp)
 908ff28:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 908ff2c:	e0bff30b 	ldhu	r2,-52(fp)
 908ff30:	e0bfff15 	stw	r2,-4(fp)
 908ff34:	00010906 	br	909035c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 908ff38:	e1bffa0b 	ldhu	r6,-24(fp)
 908ff3c:	e1fffb03 	ldbu	r7,-20(fp)
 908ff40:	e0bffc0b 	ldhu	r2,-16(fp)
 908ff44:	e17ff404 	addi	r5,fp,-48
 908ff48:	d8800015 	stw	r2,0(sp)
 908ff4c:	e13ff917 	ldw	r4,-28(fp)
 908ff50:	90908580 	call	9090858 <OS_FlagBlock>
 908ff54:	e0bff117 	ldw	r2,-60(fp)
 908ff58:	e0bfee15 	stw	r2,-72(fp)
 908ff5c:	e0bfee17 	ldw	r2,-72(fp)
 908ff60:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 908ff64:	00009506 	br	90901bc <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 908ff68:	e0bff917 	ldw	r2,-28(fp)
 908ff6c:	10c0020b 	ldhu	r3,8(r2)
 908ff70:	e0bffa0b 	ldhu	r2,-24(fp)
 908ff74:	1884703a 	and	r2,r3,r2
 908ff78:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 908ff7c:	e0bff30b 	ldhu	r2,-52(fp)
 908ff80:	1005003a 	cmpeq	r2,r2,zero
 908ff84:	10001a1e 	bne	r2,zero,908fff0 <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 908ff88:	e0bff203 	ldbu	r2,-56(fp)
 908ff8c:	10800058 	cmpnei	r2,r2,1
 908ff90:	1000091e 	bne	r2,zero,908ffb8 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 908ff94:	e0bff917 	ldw	r2,-28(fp)
 908ff98:	1080020b 	ldhu	r2,8(r2)
 908ff9c:	1007883a 	mov	r3,r2
 908ffa0:	e0bff30b 	ldhu	r2,-52(fp)
 908ffa4:	0084303a 	nor	r2,zero,r2
 908ffa8:	1884703a 	and	r2,r3,r2
 908ffac:	1007883a 	mov	r3,r2
 908ffb0:	e0bff917 	ldw	r2,-28(fp)
 908ffb4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 908ffb8:	00824374 	movhi	r2,2317
 908ffbc:	108c1404 	addi	r2,r2,12368
 908ffc0:	10c00017 	ldw	r3,0(r2)
 908ffc4:	e0bff30b 	ldhu	r2,-52(fp)
 908ffc8:	18800b0d 	sth	r2,44(r3)
 908ffcc:	e0bff117 	ldw	r2,-60(fp)
 908ffd0:	e0bfed15 	stw	r2,-76(fp)
 908ffd4:	e0bfed17 	ldw	r2,-76(fp)
 908ffd8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 908ffdc:	e0800217 	ldw	r2,8(fp)
 908ffe0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 908ffe4:	e0fff30b 	ldhu	r3,-52(fp)
 908ffe8:	e0ffff15 	stw	r3,-4(fp)
 908ffec:	0000db06 	br	909035c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 908fff0:	e1bffa0b 	ldhu	r6,-24(fp)
 908fff4:	e1fffb03 	ldbu	r7,-20(fp)
 908fff8:	e0bffc0b 	ldhu	r2,-16(fp)
 908fffc:	e17ff404 	addi	r5,fp,-48
 9090000:	d8800015 	stw	r2,0(sp)
 9090004:	e13ff917 	ldw	r4,-28(fp)
 9090008:	90908580 	call	9090858 <OS_FlagBlock>
 909000c:	e0bff117 	ldw	r2,-60(fp)
 9090010:	e0bfec15 	stw	r2,-80(fp)
 9090014:	e0bfec17 	ldw	r2,-80(fp)
 9090018:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 909001c:	00006706 	br	90901bc <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 9090020:	e0bff917 	ldw	r2,-28(fp)
 9090024:	1080020b 	ldhu	r2,8(r2)
 9090028:	0084303a 	nor	r2,zero,r2
 909002c:	1007883a 	mov	r3,r2
 9090030:	e0bffa0b 	ldhu	r2,-24(fp)
 9090034:	1884703a 	and	r2,r3,r2
 9090038:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 909003c:	e0fff30b 	ldhu	r3,-52(fp)
 9090040:	e0bffa0b 	ldhu	r2,-24(fp)
 9090044:	1880181e 	bne	r3,r2,90900a8 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 9090048:	e0bff203 	ldbu	r2,-56(fp)
 909004c:	10800058 	cmpnei	r2,r2,1
 9090050:	1000071e 	bne	r2,zero,9090070 <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 9090054:	e0bff917 	ldw	r2,-28(fp)
 9090058:	10c0020b 	ldhu	r3,8(r2)
 909005c:	e0bff30b 	ldhu	r2,-52(fp)
 9090060:	1884b03a 	or	r2,r3,r2
 9090064:	1007883a 	mov	r3,r2
 9090068:	e0bff917 	ldw	r2,-28(fp)
 909006c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9090070:	00824374 	movhi	r2,2317
 9090074:	108c1404 	addi	r2,r2,12368
 9090078:	10c00017 	ldw	r3,0(r2)
 909007c:	e0bff30b 	ldhu	r2,-52(fp)
 9090080:	18800b0d 	sth	r2,44(r3)
 9090084:	e0bff117 	ldw	r2,-60(fp)
 9090088:	e0bfeb15 	stw	r2,-84(fp)
 909008c:	e0bfeb17 	ldw	r2,-84(fp)
 9090090:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 9090094:	e0800217 	ldw	r2,8(fp)
 9090098:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 909009c:	e0bff30b 	ldhu	r2,-52(fp)
 90900a0:	e0bfff15 	stw	r2,-4(fp)
 90900a4:	0000ad06 	br	909035c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 90900a8:	e1bffa0b 	ldhu	r6,-24(fp)
 90900ac:	e1fffb03 	ldbu	r7,-20(fp)
 90900b0:	e0bffc0b 	ldhu	r2,-16(fp)
 90900b4:	e17ff404 	addi	r5,fp,-48
 90900b8:	d8800015 	stw	r2,0(sp)
 90900bc:	e13ff917 	ldw	r4,-28(fp)
 90900c0:	90908580 	call	9090858 <OS_FlagBlock>
 90900c4:	e0bff117 	ldw	r2,-60(fp)
 90900c8:	e0bfea15 	stw	r2,-88(fp)
 90900cc:	e0bfea17 	ldw	r2,-88(fp)
 90900d0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 90900d4:	00003906 	br	90901bc <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 90900d8:	e0bff917 	ldw	r2,-28(fp)
 90900dc:	1080020b 	ldhu	r2,8(r2)
 90900e0:	0084303a 	nor	r2,zero,r2
 90900e4:	1007883a 	mov	r3,r2
 90900e8:	e0bffa0b 	ldhu	r2,-24(fp)
 90900ec:	1884703a 	and	r2,r3,r2
 90900f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 90900f4:	e0bff30b 	ldhu	r2,-52(fp)
 90900f8:	1005003a 	cmpeq	r2,r2,zero
 90900fc:	1000181e 	bne	r2,zero,9090160 <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 9090100:	e0bff203 	ldbu	r2,-56(fp)
 9090104:	10800058 	cmpnei	r2,r2,1
 9090108:	1000071e 	bne	r2,zero,9090128 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 909010c:	e0bff917 	ldw	r2,-28(fp)
 9090110:	10c0020b 	ldhu	r3,8(r2)
 9090114:	e0bff30b 	ldhu	r2,-52(fp)
 9090118:	1884b03a 	or	r2,r3,r2
 909011c:	1007883a 	mov	r3,r2
 9090120:	e0bff917 	ldw	r2,-28(fp)
 9090124:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9090128:	00824374 	movhi	r2,2317
 909012c:	108c1404 	addi	r2,r2,12368
 9090130:	10c00017 	ldw	r3,0(r2)
 9090134:	e0bff30b 	ldhu	r2,-52(fp)
 9090138:	18800b0d 	sth	r2,44(r3)
 909013c:	e0bff117 	ldw	r2,-60(fp)
 9090140:	e0bfe915 	stw	r2,-92(fp)
 9090144:	e0bfe917 	ldw	r2,-92(fp)
 9090148:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 909014c:	e0800217 	ldw	r2,8(fp)
 9090150:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 9090154:	e0fff30b 	ldhu	r3,-52(fp)
 9090158:	e0ffff15 	stw	r3,-4(fp)
 909015c:	00007f06 	br	909035c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 9090160:	e1bffa0b 	ldhu	r6,-24(fp)
 9090164:	e1fffb03 	ldbu	r7,-20(fp)
 9090168:	e0bffc0b 	ldhu	r2,-16(fp)
 909016c:	e17ff404 	addi	r5,fp,-48
 9090170:	d8800015 	stw	r2,0(sp)
 9090174:	e13ff917 	ldw	r4,-28(fp)
 9090178:	90908580 	call	9090858 <OS_FlagBlock>
 909017c:	e0bff117 	ldw	r2,-60(fp)
 9090180:	e0bfe815 	stw	r2,-96(fp)
 9090184:	e0bfe817 	ldw	r2,-96(fp)
 9090188:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 909018c:	00000b06 	br	90901bc <OSFlagPend+0x48c>
 9090190:	e0bff117 	ldw	r2,-60(fp)
 9090194:	e0bfe715 	stw	r2,-100(fp)
 9090198:	e0bfe717 	ldw	r2,-100(fp)
 909019c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 90901a0:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 90901a4:	e0c00217 	ldw	r3,8(fp)
 90901a8:	00801bc4 	movi	r2,111
 90901ac:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 90901b0:	e0bff30b 	ldhu	r2,-52(fp)
 90901b4:	e0bfff15 	stw	r2,-4(fp)
 90901b8:	00006806 	br	909035c <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 90901bc:	908eaf40 	call	908eaf4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90901c0:	0005303a 	rdctl	r2,status
 90901c4:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90901c8:	e0ffe617 	ldw	r3,-104(fp)
 90901cc:	00bfff84 	movi	r2,-2
 90901d0:	1884703a 	and	r2,r3,r2
 90901d4:	1001703a 	wrctl	status,r2
  
  return context;
 90901d8:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 90901dc:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 90901e0:	00824374 	movhi	r2,2317
 90901e4:	108c1404 	addi	r2,r2,12368
 90901e8:	10800017 	ldw	r2,0(r2)
 90901ec:	10800c43 	ldbu	r2,49(r2)
 90901f0:	10803fcc 	andi	r2,r2,255
 90901f4:	1005003a 	cmpeq	r2,r2,zero
 90901f8:	1000221e 	bne	r2,zero,9090284 <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 90901fc:	00824374 	movhi	r2,2317
 9090200:	108c1404 	addi	r2,r2,12368
 9090204:	10800017 	ldw	r2,0(r2)
 9090208:	10800c43 	ldbu	r2,49(r2)
 909020c:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9090210:	00824374 	movhi	r2,2317
 9090214:	108c1404 	addi	r2,r2,12368
 9090218:	10800017 	ldw	r2,0(r2)
 909021c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 9090220:	e13ff404 	addi	r4,fp,-48
 9090224:	9090c100 	call	9090c10 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 9090228:	00824374 	movhi	r2,2317
 909022c:	108c1404 	addi	r2,r2,12368
 9090230:	10800017 	ldw	r2,0(r2)
 9090234:	10000c05 	stb	zero,48(r2)
 9090238:	e0bff117 	ldw	r2,-60(fp)
 909023c:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090240:	e0bfe517 	ldw	r2,-108(fp)
 9090244:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 9090248:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 909024c:	e0bff243 	ldbu	r2,-55(fp)
 9090250:	108000a0 	cmpeqi	r2,r2,2
 9090254:	1000011e 	bne	r2,zero,909025c <OSFlagPend+0x52c>
 9090258:	00000406 	br	909026c <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 909025c:	e0c00217 	ldw	r3,8(fp)
 9090260:	00800384 	movi	r2,14
 9090264:	18800005 	stb	r2,0(r3)
                 break;
 9090268:	00000306 	br	9090278 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 909026c:	e0c00217 	ldw	r3,8(fp)
 9090270:	00800284 	movi	r2,10
 9090274:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 9090278:	e0fff30b 	ldhu	r3,-52(fp)
 909027c:	e0ffff15 	stw	r3,-4(fp)
 9090280:	00003606 	br	909035c <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 9090284:	00824374 	movhi	r2,2317
 9090288:	108c1404 	addi	r2,r2,12368
 909028c:	10800017 	ldw	r2,0(r2)
 9090290:	10800b0b 	ldhu	r2,44(r2)
 9090294:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 9090298:	e0bff203 	ldbu	r2,-56(fp)
 909029c:	10800058 	cmpnei	r2,r2,1
 90902a0:	1000261e 	bne	r2,zero,909033c <OSFlagPend+0x60c>
        switch (wait_type) {
 90902a4:	e0bffb03 	ldbu	r2,-20(fp)
 90902a8:	e0bffd15 	stw	r2,-12(fp)
 90902ac:	e0fffd17 	ldw	r3,-12(fp)
 90902b0:	1804803a 	cmplt	r2,r3,zero
 90902b4:	1000181e 	bne	r2,zero,9090318 <OSFlagPend+0x5e8>
 90902b8:	e0fffd17 	ldw	r3,-12(fp)
 90902bc:	18800090 	cmplti	r2,r3,2
 90902c0:	10000d1e 	bne	r2,zero,90902f8 <OSFlagPend+0x5c8>
 90902c4:	e0fffd17 	ldw	r3,-12(fp)
 90902c8:	18800108 	cmpgei	r2,r3,4
 90902cc:	1000121e 	bne	r2,zero,9090318 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 90902d0:	e0bff917 	ldw	r2,-28(fp)
 90902d4:	1080020b 	ldhu	r2,8(r2)
 90902d8:	1007883a 	mov	r3,r2
 90902dc:	e0bff30b 	ldhu	r2,-52(fp)
 90902e0:	0084303a 	nor	r2,zero,r2
 90902e4:	1884703a 	and	r2,r3,r2
 90902e8:	1007883a 	mov	r3,r2
 90902ec:	e0bff917 	ldw	r2,-28(fp)
 90902f0:	10c0020d 	sth	r3,8(r2)
                 break;
 90902f4:	00001106 	br	909033c <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 90902f8:	e0bff917 	ldw	r2,-28(fp)
 90902fc:	10c0020b 	ldhu	r3,8(r2)
 9090300:	e0bff30b 	ldhu	r2,-52(fp)
 9090304:	1884b03a 	or	r2,r3,r2
 9090308:	1007883a 	mov	r3,r2
 909030c:	e0bff917 	ldw	r2,-28(fp)
 9090310:	10c0020d 	sth	r3,8(r2)
                 break;
 9090314:	00000906 	br	909033c <OSFlagPend+0x60c>
 9090318:	e0bff117 	ldw	r2,-60(fp)
 909031c:	e0bfe415 	stw	r2,-112(fp)
 9090320:	e0bfe417 	ldw	r2,-112(fp)
 9090324:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 9090328:	e0c00217 	ldw	r3,8(fp)
 909032c:	00801bc4 	movi	r2,111
 9090330:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 9090334:	e03fff15 	stw	zero,-4(fp)
 9090338:	00000806 	br	909035c <OSFlagPend+0x62c>
 909033c:	e0bff117 	ldw	r2,-60(fp)
 9090340:	e0bfe315 	stw	r2,-116(fp)
 9090344:	e0bfe317 	ldw	r2,-116(fp)
 9090348:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 909034c:	e0800217 	ldw	r2,8(fp)
 9090350:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 9090354:	e0bff30b 	ldhu	r2,-52(fp)
 9090358:	e0bfff15 	stw	r2,-4(fp)
 909035c:	e0bfff17 	ldw	r2,-4(fp)
}
 9090360:	e037883a 	mov	sp,fp
 9090364:	dfc00117 	ldw	ra,4(sp)
 9090368:	df000017 	ldw	fp,0(sp)
 909036c:	dec00204 	addi	sp,sp,8
 9090370:	f800283a 	ret

09090374 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 9090374:	defffb04 	addi	sp,sp,-20
 9090378:	df000415 	stw	fp,16(sp)
 909037c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 9090380:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090384:	0005303a 	rdctl	r2,status
 9090388:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909038c:	e0fffd17 	ldw	r3,-12(fp)
 9090390:	00bfff84 	movi	r2,-2
 9090394:	1884703a 	and	r2,r3,r2
 9090398:	1001703a 	wrctl	status,r2
  
  return context;
 909039c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 90903a0:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 90903a4:	00824374 	movhi	r2,2317
 90903a8:	108c1404 	addi	r2,r2,12368
 90903ac:	10800017 	ldw	r2,0(r2)
 90903b0:	10800b0b 	ldhu	r2,44(r2)
 90903b4:	e0bfff0d 	sth	r2,-4(fp)
 90903b8:	e0bffe17 	ldw	r2,-8(fp)
 90903bc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90903c0:	e0bffc17 	ldw	r2,-16(fp)
 90903c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 90903c8:	e0bfff0b 	ldhu	r2,-4(fp)
}
 90903cc:	e037883a 	mov	sp,fp
 90903d0:	df000017 	ldw	fp,0(sp)
 90903d4:	dec00104 	addi	sp,sp,4
 90903d8:	f800283a 	ret

090903dc <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 90903dc:	deffed04 	addi	sp,sp,-76
 90903e0:	dfc01215 	stw	ra,72(sp)
 90903e4:	df001115 	stw	fp,68(sp)
 90903e8:	df001104 	addi	fp,sp,68
 90903ec:	e13ff915 	stw	r4,-28(fp)
 90903f0:	e1fffc15 	stw	r7,-16(fp)
 90903f4:	e17ffa0d 	sth	r5,-24(fp)
 90903f8:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 90903fc:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 9090400:	e0bffc17 	ldw	r2,-16(fp)
 9090404:	1004c03a 	cmpne	r2,r2,zero
 9090408:	1000021e 	bne	r2,zero,9090414 <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 909040c:	e03fff15 	stw	zero,-4(fp)
 9090410:	0000d606 	br	909076c <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 9090414:	e0bff917 	ldw	r2,-28(fp)
 9090418:	1004c03a 	cmpne	r2,r2,zero
 909041c:	1000051e 	bne	r2,zero,9090434 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9090420:	e0fffc17 	ldw	r3,-16(fp)
 9090424:	00801b84 	movi	r2,110
 9090428:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 909042c:	e03fff15 	stw	zero,-4(fp)
 9090430:	0000ce06 	br	909076c <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 9090434:	e0bff917 	ldw	r2,-28(fp)
 9090438:	10800003 	ldbu	r2,0(r2)
 909043c:	10803fcc 	andi	r2,r2,255
 9090440:	10800160 	cmpeqi	r2,r2,5
 9090444:	1000051e 	bne	r2,zero,909045c <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 9090448:	e0fffc17 	ldw	r3,-16(fp)
 909044c:	00800044 	movi	r2,1
 9090450:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9090454:	e03fff15 	stw	zero,-4(fp)
 9090458:	0000c406 	br	909076c <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909045c:	0005303a 	rdctl	r2,status
 9090460:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090464:	e0fff417 	ldw	r3,-48(fp)
 9090468:	00bfff84 	movi	r2,-2
 909046c:	1884703a 	and	r2,r3,r2
 9090470:	1001703a 	wrctl	status,r2
  
  return context;
 9090474:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 9090478:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 909047c:	e0bffb03 	ldbu	r2,-20(fp)
 9090480:	e0bffe15 	stw	r2,-8(fp)
 9090484:	e0fffe17 	ldw	r3,-8(fp)
 9090488:	1805003a 	cmpeq	r2,r3,zero
 909048c:	1000041e 	bne	r2,zero,90904a0 <OSFlagPost+0xc4>
 9090490:	e0fffe17 	ldw	r3,-8(fp)
 9090494:	18800060 	cmpeqi	r2,r3,1
 9090498:	10000b1e 	bne	r2,zero,90904c8 <OSFlagPost+0xec>
 909049c:	00001206 	br	90904e8 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 90904a0:	e0bff917 	ldw	r2,-28(fp)
 90904a4:	1080020b 	ldhu	r2,8(r2)
 90904a8:	1007883a 	mov	r3,r2
 90904ac:	e0bffa0b 	ldhu	r2,-24(fp)
 90904b0:	0084303a 	nor	r2,zero,r2
 90904b4:	1884703a 	and	r2,r3,r2
 90904b8:	1007883a 	mov	r3,r2
 90904bc:	e0bff917 	ldw	r2,-28(fp)
 90904c0:	10c0020d 	sth	r3,8(r2)
             break;
 90904c4:	00001106 	br	909050c <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 90904c8:	e0bff917 	ldw	r2,-28(fp)
 90904cc:	10c0020b 	ldhu	r3,8(r2)
 90904d0:	e0bffa0b 	ldhu	r2,-24(fp)
 90904d4:	1884b03a 	or	r2,r3,r2
 90904d8:	1007883a 	mov	r3,r2
 90904dc:	e0bff917 	ldw	r2,-28(fp)
 90904e0:	10c0020d 	sth	r3,8(r2)
             break;
 90904e4:	00000906 	br	909050c <OSFlagPost+0x130>
 90904e8:	e0bff517 	ldw	r2,-44(fp)
 90904ec:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90904f0:	e0bff317 	ldw	r2,-52(fp)
 90904f4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 90904f8:	e0fffc17 	ldw	r3,-16(fp)
 90904fc:	00801c44 	movi	r2,113
 9090500:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 9090504:	e03fff15 	stw	zero,-4(fp)
 9090508:	00009806 	br	909076c <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 909050c:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 9090510:	e0bff917 	ldw	r2,-28(fp)
 9090514:	10800117 	ldw	r2,4(r2)
 9090518:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 909051c:	00007506 	br	90906f4 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 9090520:	e0bff817 	ldw	r2,-32(fp)
 9090524:	10800483 	ldbu	r2,18(r2)
 9090528:	10803fcc 	andi	r2,r2,255
 909052c:	e0bffd15 	stw	r2,-12(fp)
 9090530:	e0fffd17 	ldw	r3,-12(fp)
 9090534:	18800060 	cmpeqi	r2,r3,1
 9090538:	10004d1e 	bne	r2,zero,9090670 <OSFlagPost+0x294>
 909053c:	e0fffd17 	ldw	r3,-12(fp)
 9090540:	18800088 	cmpgei	r2,r3,2
 9090544:	1000041e 	bne	r2,zero,9090558 <OSFlagPost+0x17c>
 9090548:	e0fffd17 	ldw	r3,-12(fp)
 909054c:	1805003a 	cmpeq	r2,r3,zero
 9090550:	1000301e 	bne	r2,zero,9090614 <OSFlagPost+0x238>
 9090554:	00005b06 	br	90906c4 <OSFlagPost+0x2e8>
 9090558:	e0fffd17 	ldw	r3,-12(fp)
 909055c:	188000a0 	cmpeqi	r2,r3,2
 9090560:	1000041e 	bne	r2,zero,9090574 <OSFlagPost+0x198>
 9090564:	e0fffd17 	ldw	r3,-12(fp)
 9090568:	188000e0 	cmpeqi	r2,r3,3
 909056c:	1000161e 	bne	r2,zero,90905c8 <OSFlagPost+0x1ec>
 9090570:	00005406 	br	90906c4 <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9090574:	e0bff917 	ldw	r2,-28(fp)
 9090578:	10c0020b 	ldhu	r3,8(r2)
 909057c:	e0bff817 	ldw	r2,-32(fp)
 9090580:	1080040b 	ldhu	r2,16(r2)
 9090584:	1884703a 	and	r2,r3,r2
 9090588:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 909058c:	e0bff817 	ldw	r2,-32(fp)
 9090590:	1080040b 	ldhu	r2,16(r2)
 9090594:	10ffffcc 	andi	r3,r2,65535
 9090598:	e0bff68b 	ldhu	r2,-38(fp)
 909059c:	1880521e 	bne	r3,r2,90906e8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 90905a0:	e17ff68b 	ldhu	r5,-38(fp)
 90905a4:	e13ff817 	ldw	r4,-32(fp)
 90905a8:	9090b000 	call	9090b00 <OS_FlagTaskRdy>
 90905ac:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 90905b0:	e0bff603 	ldbu	r2,-40(fp)
 90905b4:	10800058 	cmpnei	r2,r2,1
 90905b8:	10004b1e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 90905bc:	00800044 	movi	r2,1
 90905c0:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 90905c4:	00004806 	br	90906e8 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 90905c8:	e0bff917 	ldw	r2,-28(fp)
 90905cc:	10c0020b 	ldhu	r3,8(r2)
 90905d0:	e0bff817 	ldw	r2,-32(fp)
 90905d4:	1080040b 	ldhu	r2,16(r2)
 90905d8:	1884703a 	and	r2,r3,r2
 90905dc:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 90905e0:	e0bff68b 	ldhu	r2,-38(fp)
 90905e4:	1005003a 	cmpeq	r2,r2,zero
 90905e8:	10003f1e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 90905ec:	e17ff68b 	ldhu	r5,-38(fp)
 90905f0:	e13ff817 	ldw	r4,-32(fp)
 90905f4:	9090b000 	call	9090b00 <OS_FlagTaskRdy>
 90905f8:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 90905fc:	e0bff603 	ldbu	r2,-40(fp)
 9090600:	10800058 	cmpnei	r2,r2,1
 9090604:	1000381e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 9090608:	00800044 	movi	r2,1
 909060c:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 9090610:	00003506 	br	90906e8 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9090614:	e0bff917 	ldw	r2,-28(fp)
 9090618:	1080020b 	ldhu	r2,8(r2)
 909061c:	0084303a 	nor	r2,zero,r2
 9090620:	1007883a 	mov	r3,r2
 9090624:	e0bff817 	ldw	r2,-32(fp)
 9090628:	1080040b 	ldhu	r2,16(r2)
 909062c:	1884703a 	and	r2,r3,r2
 9090630:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 9090634:	e0bff817 	ldw	r2,-32(fp)
 9090638:	1080040b 	ldhu	r2,16(r2)
 909063c:	10ffffcc 	andi	r3,r2,65535
 9090640:	e0bff68b 	ldhu	r2,-38(fp)
 9090644:	1880281e 	bne	r3,r2,90906e8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 9090648:	e17ff68b 	ldhu	r5,-38(fp)
 909064c:	e13ff817 	ldw	r4,-32(fp)
 9090650:	9090b000 	call	9090b00 <OS_FlagTaskRdy>
 9090654:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 9090658:	e0bff603 	ldbu	r2,-40(fp)
 909065c:	10800058 	cmpnei	r2,r2,1
 9090660:	1000211e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 9090664:	00800044 	movi	r2,1
 9090668:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 909066c:	00001e06 	br	90906e8 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9090670:	e0bff917 	ldw	r2,-28(fp)
 9090674:	1080020b 	ldhu	r2,8(r2)
 9090678:	0084303a 	nor	r2,zero,r2
 909067c:	1007883a 	mov	r3,r2
 9090680:	e0bff817 	ldw	r2,-32(fp)
 9090684:	1080040b 	ldhu	r2,16(r2)
 9090688:	1884703a 	and	r2,r3,r2
 909068c:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 9090690:	e0bff68b 	ldhu	r2,-38(fp)
 9090694:	1005003a 	cmpeq	r2,r2,zero
 9090698:	1000131e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 909069c:	e17ff68b 	ldhu	r5,-38(fp)
 90906a0:	e13ff817 	ldw	r4,-32(fp)
 90906a4:	9090b000 	call	9090b00 <OS_FlagTaskRdy>
 90906a8:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 90906ac:	e0bff603 	ldbu	r2,-40(fp)
 90906b0:	10800058 	cmpnei	r2,r2,1
 90906b4:	10000c1e 	bne	r2,zero,90906e8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 90906b8:	00800044 	movi	r2,1
 90906bc:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 90906c0:	00000906 	br	90906e8 <OSFlagPost+0x30c>
 90906c4:	e0bff517 	ldw	r2,-44(fp)
 90906c8:	e0bff215 	stw	r2,-56(fp)
 90906cc:	e0bff217 	ldw	r2,-56(fp)
 90906d0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 90906d4:	e0fffc17 	ldw	r3,-16(fp)
 90906d8:	00801bc4 	movi	r2,111
 90906dc:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 90906e0:	e03fff15 	stw	zero,-4(fp)
 90906e4:	00002106 	br	909076c <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 90906e8:	e0bff817 	ldw	r2,-32(fp)
 90906ec:	10800017 	ldw	r2,0(r2)
 90906f0:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 90906f4:	e0bff817 	ldw	r2,-32(fp)
 90906f8:	1004c03a 	cmpne	r2,r2,zero
 90906fc:	103f881e 	bne	r2,zero,9090520 <OSFlagPost+0x144>
 9090700:	e0bff517 	ldw	r2,-44(fp)
 9090704:	e0bff115 	stw	r2,-60(fp)
 9090708:	e0bff117 	ldw	r2,-60(fp)
 909070c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 9090710:	e0bff783 	ldbu	r2,-34(fp)
 9090714:	10800058 	cmpnei	r2,r2,1
 9090718:	1000011e 	bne	r2,zero,9090720 <OSFlagPost+0x344>
        OS_Sched();
 909071c:	908eaf40 	call	908eaf4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090720:	0005303a 	rdctl	r2,status
 9090724:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090728:	e0fff017 	ldw	r3,-64(fp)
 909072c:	00bfff84 	movi	r2,-2
 9090730:	1884703a 	and	r2,r3,r2
 9090734:	1001703a 	wrctl	status,r2
  
  return context;
 9090738:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 909073c:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 9090740:	e0bff917 	ldw	r2,-28(fp)
 9090744:	1080020b 	ldhu	r2,8(r2)
 9090748:	e0bff70d 	sth	r2,-36(fp)
 909074c:	e0bff517 	ldw	r2,-44(fp)
 9090750:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090754:	e0bfef17 	ldw	r2,-68(fp)
 9090758:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 909075c:	e0bffc17 	ldw	r2,-16(fp)
 9090760:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 9090764:	e0bff70b 	ldhu	r2,-36(fp)
 9090768:	e0bfff15 	stw	r2,-4(fp)
 909076c:	e0bfff17 	ldw	r2,-4(fp)
}
 9090770:	e037883a 	mov	sp,fp
 9090774:	dfc00117 	ldw	ra,4(sp)
 9090778:	df000017 	ldw	fp,0(sp)
 909077c:	dec00204 	addi	sp,sp,8
 9090780:	f800283a 	ret

09090784 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 9090784:	defff804 	addi	sp,sp,-32
 9090788:	df000715 	stw	fp,28(sp)
 909078c:	df000704 	addi	fp,sp,28
 9090790:	e13ffd15 	stw	r4,-12(fp)
 9090794:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 9090798:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 909079c:	e0bffe17 	ldw	r2,-8(fp)
 90907a0:	1004c03a 	cmpne	r2,r2,zero
 90907a4:	1000021e 	bne	r2,zero,90907b0 <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 90907a8:	e03fff15 	stw	zero,-4(fp)
 90907ac:	00002506 	br	9090844 <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 90907b0:	e0bffd17 	ldw	r2,-12(fp)
 90907b4:	1004c03a 	cmpne	r2,r2,zero
 90907b8:	1000051e 	bne	r2,zero,90907d0 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 90907bc:	e0fffe17 	ldw	r3,-8(fp)
 90907c0:	00801b84 	movi	r2,110
 90907c4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90907c8:	e03fff15 	stw	zero,-4(fp)
 90907cc:	00001d06 	br	9090844 <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 90907d0:	e0bffd17 	ldw	r2,-12(fp)
 90907d4:	10800003 	ldbu	r2,0(r2)
 90907d8:	10803fcc 	andi	r2,r2,255
 90907dc:	10800160 	cmpeqi	r2,r2,5
 90907e0:	1000051e 	bne	r2,zero,90907f8 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 90907e4:	e0fffe17 	ldw	r3,-8(fp)
 90907e8:	00800044 	movi	r2,1
 90907ec:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90907f0:	e03fff15 	stw	zero,-4(fp)
 90907f4:	00001306 	br	9090844 <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90907f8:	0005303a 	rdctl	r2,status
 90907fc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090800:	e0fffa17 	ldw	r3,-24(fp)
 9090804:	00bfff84 	movi	r2,-2
 9090808:	1884703a 	and	r2,r3,r2
 909080c:	1001703a 	wrctl	status,r2
  
  return context;
 9090810:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9090814:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 9090818:	e0bffd17 	ldw	r2,-12(fp)
 909081c:	1080020b 	ldhu	r2,8(r2)
 9090820:	e0bffc0d 	sth	r2,-16(fp)
 9090824:	e0bffb17 	ldw	r2,-20(fp)
 9090828:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909082c:	e0bff917 	ldw	r2,-28(fp)
 9090830:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9090834:	e0bffe17 	ldw	r2,-8(fp)
 9090838:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 909083c:	e0bffc0b 	ldhu	r2,-16(fp)
 9090840:	e0bfff15 	stw	r2,-4(fp)
 9090844:	e0bfff17 	ldw	r2,-4(fp)
}
 9090848:	e037883a 	mov	sp,fp
 909084c:	df000017 	ldw	fp,0(sp)
 9090850:	dec00104 	addi	sp,sp,4
 9090854:	f800283a 	ret

09090858 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 9090858:	defff804 	addi	sp,sp,-32
 909085c:	df000715 	stw	fp,28(sp)
 9090860:	df000704 	addi	fp,sp,28
 9090864:	e13ffb15 	stw	r4,-20(fp)
 9090868:	e17ffc15 	stw	r5,-16(fp)
 909086c:	e0800117 	ldw	r2,4(fp)
 9090870:	e1bffd0d 	sth	r6,-12(fp)
 9090874:	e1fffe05 	stb	r7,-8(fp)
 9090878:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 909087c:	00824374 	movhi	r2,2317
 9090880:	108c1404 	addi	r2,r2,12368
 9090884:	10c00017 	ldw	r3,0(r2)
 9090888:	00824374 	movhi	r2,2317
 909088c:	108c1404 	addi	r2,r2,12368
 9090890:	10800017 	ldw	r2,0(r2)
 9090894:	10800c03 	ldbu	r2,48(r2)
 9090898:	10800814 	ori	r2,r2,32
 909089c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 90908a0:	00824374 	movhi	r2,2317
 90908a4:	108c1404 	addi	r2,r2,12368
 90908a8:	10800017 	ldw	r2,0(r2)
 90908ac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 90908b0:	00824374 	movhi	r2,2317
 90908b4:	108c1404 	addi	r2,r2,12368
 90908b8:	10c00017 	ldw	r3,0(r2)
 90908bc:	e0bfff0b 	ldhu	r2,-4(fp)
 90908c0:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 90908c4:	00824374 	movhi	r2,2317
 90908c8:	108c1404 	addi	r2,r2,12368
 90908cc:	10c00017 	ldw	r3,0(r2)
 90908d0:	e0bffc17 	ldw	r2,-16(fp)
 90908d4:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 90908d8:	e0fffc17 	ldw	r3,-16(fp)
 90908dc:	e0bffd0b 	ldhu	r2,-12(fp)
 90908e0:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 90908e4:	e0fffc17 	ldw	r3,-16(fp)
 90908e8:	e0bffe03 	ldbu	r2,-8(fp)
 90908ec:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 90908f0:	00824374 	movhi	r2,2317
 90908f4:	108c1404 	addi	r2,r2,12368
 90908f8:	10c00017 	ldw	r3,0(r2)
 90908fc:	e0bffc17 	ldw	r2,-16(fp)
 9090900:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 9090904:	e0bffb17 	ldw	r2,-20(fp)
 9090908:	10c00117 	ldw	r3,4(r2)
 909090c:	e0bffc17 	ldw	r2,-16(fp)
 9090910:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 9090914:	e0bffc17 	ldw	r2,-16(fp)
 9090918:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 909091c:	e0fffc17 	ldw	r3,-16(fp)
 9090920:	e0bffb17 	ldw	r2,-20(fp)
 9090924:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 9090928:	e0bffb17 	ldw	r2,-20(fp)
 909092c:	10800117 	ldw	r2,4(r2)
 9090930:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 9090934:	e0bffa17 	ldw	r2,-24(fp)
 9090938:	1005003a 	cmpeq	r2,r2,zero
 909093c:	1000031e 	bne	r2,zero,909094c <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 9090940:	e0fffa17 	ldw	r3,-24(fp)
 9090944:	e0bffc17 	ldw	r2,-16(fp)
 9090948:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 909094c:	e0fffb17 	ldw	r3,-20(fp)
 9090950:	e0bffc17 	ldw	r2,-16(fp)
 9090954:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 9090958:	00824374 	movhi	r2,2317
 909095c:	108c1404 	addi	r2,r2,12368
 9090960:	10800017 	ldw	r2,0(r2)
 9090964:	10800d03 	ldbu	r2,52(r2)
 9090968:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 909096c:	e13ff903 	ldbu	r4,-28(fp)
 9090970:	e0fff903 	ldbu	r3,-28(fp)
 9090974:	00824374 	movhi	r2,2317
 9090978:	108c1144 	addi	r2,r2,12357
 909097c:	10c5883a 	add	r2,r2,r3
 9090980:	10800003 	ldbu	r2,0(r2)
 9090984:	1007883a 	mov	r3,r2
 9090988:	00824374 	movhi	r2,2317
 909098c:	108c1404 	addi	r2,r2,12368
 9090990:	10800017 	ldw	r2,0(r2)
 9090994:	10800d43 	ldbu	r2,53(r2)
 9090998:	0084303a 	nor	r2,zero,r2
 909099c:	1884703a 	and	r2,r3,r2
 90909a0:	1007883a 	mov	r3,r2
 90909a4:	00824374 	movhi	r2,2317
 90909a8:	108c1144 	addi	r2,r2,12357
 90909ac:	1105883a 	add	r2,r2,r4
 90909b0:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 90909b4:	e0fff903 	ldbu	r3,-28(fp)
 90909b8:	00824374 	movhi	r2,2317
 90909bc:	108c1144 	addi	r2,r2,12357
 90909c0:	10c5883a 	add	r2,r2,r3
 90909c4:	10800003 	ldbu	r2,0(r2)
 90909c8:	10803fcc 	andi	r2,r2,255
 90909cc:	1004c03a 	cmpne	r2,r2,zero
 90909d0:	10000e1e 	bne	r2,zero,9090a0c <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 90909d4:	00824374 	movhi	r2,2317
 90909d8:	108c1404 	addi	r2,r2,12368
 90909dc:	10800017 	ldw	r2,0(r2)
 90909e0:	10800d83 	ldbu	r2,54(r2)
 90909e4:	0084303a 	nor	r2,zero,r2
 90909e8:	1007883a 	mov	r3,r2
 90909ec:	00824374 	movhi	r2,2317
 90909f0:	108c1104 	addi	r2,r2,12356
 90909f4:	10800003 	ldbu	r2,0(r2)
 90909f8:	1884703a 	and	r2,r3,r2
 90909fc:	1007883a 	mov	r3,r2
 9090a00:	00824374 	movhi	r2,2317
 9090a04:	108c1104 	addi	r2,r2,12356
 9090a08:	10c00005 	stb	r3,0(r2)
    }
}
 9090a0c:	e037883a 	mov	sp,fp
 9090a10:	df000017 	ldw	fp,0(sp)
 9090a14:	dec00104 	addi	sp,sp,4
 9090a18:	f800283a 	ret

09090a1c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 9090a1c:	defffb04 	addi	sp,sp,-20
 9090a20:	dfc00415 	stw	ra,16(sp)
 9090a24:	df000315 	stw	fp,12(sp)
 9090a28:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 9090a2c:	010243b4 	movhi	r4,2318
 9090a30:	21263804 	addi	r4,r4,-26400
 9090a34:	0140dc04 	movi	r5,880
 9090a38:	908ea340 	call	908ea34 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 9090a3c:	008243b4 	movhi	r2,2318
 9090a40:	10a63804 	addi	r2,r2,-26400
 9090a44:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 9090a48:	008243b4 	movhi	r2,2318
 9090a4c:	10a64304 	addi	r2,r2,-26356
 9090a50:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 9090a54:	e03fff0d 	sth	zero,-4(fp)
 9090a58:	00001306 	br	9090aa8 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 9090a5c:	e0bffe17 	ldw	r2,-8(fp)
 9090a60:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 9090a64:	e0fffe17 	ldw	r3,-8(fp)
 9090a68:	e0bffd17 	ldw	r2,-12(fp)
 9090a6c:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 9090a70:	e0fffe17 	ldw	r3,-8(fp)
 9090a74:	00800fc4 	movi	r2,63
 9090a78:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 9090a7c:	e0bffe17 	ldw	r2,-8(fp)
 9090a80:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 9090a84:	e0bffe17 	ldw	r2,-8(fp)
 9090a88:	10800b04 	addi	r2,r2,44
 9090a8c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 9090a90:	e0bffd17 	ldw	r2,-12(fp)
 9090a94:	10800b04 	addi	r2,r2,44
 9090a98:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 9090a9c:	e0bfff0b 	ldhu	r2,-4(fp)
 9090aa0:	10800044 	addi	r2,r2,1
 9090aa4:	e0bfff0d 	sth	r2,-4(fp)
 9090aa8:	e0bfff0b 	ldhu	r2,-4(fp)
 9090aac:	108004f0 	cmpltui	r2,r2,19
 9090ab0:	103fea1e 	bne	r2,zero,9090a5c <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 9090ab4:	e0bffe17 	ldw	r2,-8(fp)
 9090ab8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 9090abc:	e0bffe17 	ldw	r2,-8(fp)
 9090ac0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 9090ac4:	e0fffe17 	ldw	r3,-8(fp)
 9090ac8:	00800fc4 	movi	r2,63
 9090acc:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 9090ad0:	e0bffe17 	ldw	r2,-8(fp)
 9090ad4:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 9090ad8:	00c24374 	movhi	r3,2317
 9090adc:	18cc1604 	addi	r3,r3,12376
 9090ae0:	008243b4 	movhi	r2,2318
 9090ae4:	10a63804 	addi	r2,r2,-26400
 9090ae8:	18800015 	stw	r2,0(r3)
#endif
}
 9090aec:	e037883a 	mov	sp,fp
 9090af0:	dfc00117 	ldw	ra,4(sp)
 9090af4:	df000017 	ldw	fp,0(sp)
 9090af8:	dec00204 	addi	sp,sp,8
 9090afc:	f800283a 	ret

09090b00 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 9090b00:	defffa04 	addi	sp,sp,-24
 9090b04:	dfc00515 	stw	ra,20(sp)
 9090b08:	df000415 	stw	fp,16(sp)
 9090b0c:	df000404 	addi	fp,sp,16
 9090b10:	e13ffe15 	stw	r4,-8(fp)
 9090b14:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 9090b18:	e0bffe17 	ldw	r2,-8(fp)
 9090b1c:	10800217 	ldw	r2,8(r2)
 9090b20:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 9090b24:	e0bffd17 	ldw	r2,-12(fp)
 9090b28:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 9090b2c:	e0fffd17 	ldw	r3,-12(fp)
 9090b30:	e0bfff0b 	ldhu	r2,-4(fp)
 9090b34:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 9090b38:	e0bffd17 	ldw	r2,-12(fp)
 9090b3c:	10c00c03 	ldbu	r3,48(r2)
 9090b40:	00bff7c4 	movi	r2,-33
 9090b44:	1884703a 	and	r2,r3,r2
 9090b48:	1007883a 	mov	r3,r2
 9090b4c:	e0bffd17 	ldw	r2,-12(fp)
 9090b50:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 9090b54:	e0bffd17 	ldw	r2,-12(fp)
 9090b58:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 9090b5c:	e0bffd17 	ldw	r2,-12(fp)
 9090b60:	10800c03 	ldbu	r2,48(r2)
 9090b64:	10803fcc 	andi	r2,r2,255
 9090b68:	1004c03a 	cmpne	r2,r2,zero
 9090b6c:	10001f1e 	bne	r2,zero,9090bec <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 9090b70:	e0bffd17 	ldw	r2,-12(fp)
 9090b74:	10c00d83 	ldbu	r3,54(r2)
 9090b78:	00824374 	movhi	r2,2317
 9090b7c:	108c1104 	addi	r2,r2,12356
 9090b80:	10800003 	ldbu	r2,0(r2)
 9090b84:	1884b03a 	or	r2,r3,r2
 9090b88:	1007883a 	mov	r3,r2
 9090b8c:	00824374 	movhi	r2,2317
 9090b90:	108c1104 	addi	r2,r2,12356
 9090b94:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9090b98:	e0bffd17 	ldw	r2,-12(fp)
 9090b9c:	10800d03 	ldbu	r2,52(r2)
 9090ba0:	11003fcc 	andi	r4,r2,255
 9090ba4:	e0bffd17 	ldw	r2,-12(fp)
 9090ba8:	10800d03 	ldbu	r2,52(r2)
 9090bac:	10c03fcc 	andi	r3,r2,255
 9090bb0:	00824374 	movhi	r2,2317
 9090bb4:	108c1144 	addi	r2,r2,12357
 9090bb8:	10c5883a 	add	r2,r2,r3
 9090bbc:	10c00003 	ldbu	r3,0(r2)
 9090bc0:	e0bffd17 	ldw	r2,-12(fp)
 9090bc4:	10800d43 	ldbu	r2,53(r2)
 9090bc8:	1884b03a 	or	r2,r3,r2
 9090bcc:	1007883a 	mov	r3,r2
 9090bd0:	00824374 	movhi	r2,2317
 9090bd4:	108c1144 	addi	r2,r2,12357
 9090bd8:	1105883a 	add	r2,r2,r4
 9090bdc:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 9090be0:	00800044 	movi	r2,1
 9090be4:	e0bffc05 	stb	r2,-16(fp)
 9090be8:	00000106 	br	9090bf0 <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 9090bec:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 9090bf0:	e13ffe17 	ldw	r4,-8(fp)
 9090bf4:	9090c100 	call	9090c10 <OS_FlagUnlink>
    return (sched);
 9090bf8:	e0bffc03 	ldbu	r2,-16(fp)
}
 9090bfc:	e037883a 	mov	sp,fp
 9090c00:	dfc00117 	ldw	ra,4(sp)
 9090c04:	df000017 	ldw	fp,0(sp)
 9090c08:	dec00204 	addi	sp,sp,8
 9090c0c:	f800283a 	ret

09090c10 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 9090c10:	defffa04 	addi	sp,sp,-24
 9090c14:	df000515 	stw	fp,20(sp)
 9090c18:	df000504 	addi	fp,sp,20
 9090c1c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 9090c20:	e0bfff17 	ldw	r2,-4(fp)
 9090c24:	10800117 	ldw	r2,4(r2)
 9090c28:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 9090c2c:	e0bfff17 	ldw	r2,-4(fp)
 9090c30:	10800017 	ldw	r2,0(r2)
 9090c34:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 9090c38:	e0bffc17 	ldw	r2,-16(fp)
 9090c3c:	1004c03a 	cmpne	r2,r2,zero
 9090c40:	10000c1e 	bne	r2,zero,9090c74 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 9090c44:	e0bfff17 	ldw	r2,-4(fp)
 9090c48:	10800317 	ldw	r2,12(r2)
 9090c4c:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 9090c50:	e0fffd17 	ldw	r3,-12(fp)
 9090c54:	e0bffb17 	ldw	r2,-20(fp)
 9090c58:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 9090c5c:	e0bffb17 	ldw	r2,-20(fp)
 9090c60:	1005003a 	cmpeq	r2,r2,zero
 9090c64:	10000c1e 	bne	r2,zero,9090c98 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 9090c68:	e0bffb17 	ldw	r2,-20(fp)
 9090c6c:	10000115 	stw	zero,4(r2)
 9090c70:	00000906 	br	9090c98 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 9090c74:	e0fffc17 	ldw	r3,-16(fp)
 9090c78:	e0bffb17 	ldw	r2,-20(fp)
 9090c7c:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 9090c80:	e0bffb17 	ldw	r2,-20(fp)
 9090c84:	1005003a 	cmpeq	r2,r2,zero
 9090c88:	1000031e 	bne	r2,zero,9090c98 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 9090c8c:	e0fffb17 	ldw	r3,-20(fp)
 9090c90:	e0bffc17 	ldw	r2,-16(fp)
 9090c94:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 9090c98:	e0bfff17 	ldw	r2,-4(fp)
 9090c9c:	10800217 	ldw	r2,8(r2)
 9090ca0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 9090ca4:	e0bffe17 	ldw	r2,-8(fp)
 9090ca8:	10000a15 	stw	zero,40(r2)
#endif
}
 9090cac:	e037883a 	mov	sp,fp
 9090cb0:	df000017 	ldw	fp,0(sp)
 9090cb4:	dec00104 	addi	sp,sp,4
 9090cb8:	f800283a 	ret

09090cbc <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 9090cbc:	defff304 	addi	sp,sp,-52
 9090cc0:	df000c15 	stw	fp,48(sp)
 9090cc4:	df000c04 	addi	fp,sp,48
 9090cc8:	e13ffb15 	stw	r4,-20(fp)
 9090ccc:	e17ffc15 	stw	r5,-16(fp)
 9090cd0:	e1bffd15 	stw	r6,-12(fp)
 9090cd4:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9090cd8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9090cdc:	e0bffe17 	ldw	r2,-8(fp)
 9090ce0:	1004c03a 	cmpne	r2,r2,zero
 9090ce4:	1000021e 	bne	r2,zero,9090cf0 <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 9090ce8:	e03fff15 	stw	zero,-4(fp)
 9090cec:	00007506 	br	9090ec4 <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 9090cf0:	e0bffb17 	ldw	r2,-20(fp)
 9090cf4:	1004c03a 	cmpne	r2,r2,zero
 9090cf8:	1000051e 	bne	r2,zero,9090d10 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 9090cfc:	e0fffe17 	ldw	r3,-8(fp)
 9090d00:	00801884 	movi	r2,98
 9090d04:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9090d08:	e03fff15 	stw	zero,-4(fp)
 9090d0c:	00006d06 	br	9090ec4 <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 9090d10:	e0bffb17 	ldw	r2,-20(fp)
 9090d14:	108000cc 	andi	r2,r2,3
 9090d18:	1005003a 	cmpeq	r2,r2,zero
 9090d1c:	1000051e 	bne	r2,zero,9090d34 <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 9090d20:	e0fffe17 	ldw	r3,-8(fp)
 9090d24:	00801884 	movi	r2,98
 9090d28:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9090d2c:	e03fff15 	stw	zero,-4(fp)
 9090d30:	00006406 	br	9090ec4 <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 9090d34:	e0bffc17 	ldw	r2,-16(fp)
 9090d38:	108000a8 	cmpgeui	r2,r2,2
 9090d3c:	1000051e 	bne	r2,zero,9090d54 <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 9090d40:	e0fffe17 	ldw	r3,-8(fp)
 9090d44:	008016c4 	movi	r2,91
 9090d48:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9090d4c:	e03fff15 	stw	zero,-4(fp)
 9090d50:	00005c06 	br	9090ec4 <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 9090d54:	e0bffd17 	ldw	r2,-12(fp)
 9090d58:	10800128 	cmpgeui	r2,r2,4
 9090d5c:	1000051e 	bne	r2,zero,9090d74 <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 9090d60:	e0fffe17 	ldw	r3,-8(fp)
 9090d64:	00801704 	movi	r2,92
 9090d68:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9090d6c:	e03fff15 	stw	zero,-4(fp)
 9090d70:	00005406 	br	9090ec4 <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090d74:	0005303a 	rdctl	r2,status
 9090d78:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090d7c:	e0fff517 	ldw	r3,-44(fp)
 9090d80:	00bfff84 	movi	r2,-2
 9090d84:	1884703a 	and	r2,r3,r2
 9090d88:	1001703a 	wrctl	status,r2
  
  return context;
 9090d8c:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9090d90:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 9090d94:	00824374 	movhi	r2,2317
 9090d98:	108c0e04 	addi	r2,r2,12344
 9090d9c:	10800017 	ldw	r2,0(r2)
 9090da0:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 9090da4:	00824374 	movhi	r2,2317
 9090da8:	108c0e04 	addi	r2,r2,12344
 9090dac:	10800017 	ldw	r2,0(r2)
 9090db0:	1005003a 	cmpeq	r2,r2,zero
 9090db4:	1000081e 	bne	r2,zero,9090dd8 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 9090db8:	00824374 	movhi	r2,2317
 9090dbc:	108c0e04 	addi	r2,r2,12344
 9090dc0:	10800017 	ldw	r2,0(r2)
 9090dc4:	10800117 	ldw	r2,4(r2)
 9090dc8:	1007883a 	mov	r3,r2
 9090dcc:	00824374 	movhi	r2,2317
 9090dd0:	108c0e04 	addi	r2,r2,12344
 9090dd4:	10c00015 	stw	r3,0(r2)
 9090dd8:	e0bff617 	ldw	r2,-40(fp)
 9090ddc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090de0:	e0bff417 	ldw	r2,-48(fp)
 9090de4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 9090de8:	e0bffa17 	ldw	r2,-24(fp)
 9090dec:	1004c03a 	cmpne	r2,r2,zero
 9090df0:	1000051e 	bne	r2,zero,9090e08 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 9090df4:	e0fffe17 	ldw	r3,-8(fp)
 9090df8:	00801684 	movi	r2,90
 9090dfc:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9090e00:	e03fff15 	stw	zero,-4(fp)
 9090e04:	00002f06 	br	9090ec4 <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 9090e08:	e0bffb17 	ldw	r2,-20(fp)
 9090e0c:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 9090e10:	e0bffb17 	ldw	r2,-20(fp)
 9090e14:	1007883a 	mov	r3,r2
 9090e18:	e0bffd17 	ldw	r2,-12(fp)
 9090e1c:	1885883a 	add	r2,r3,r2
 9090e20:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 9090e24:	e03ff715 	stw	zero,-36(fp)
 9090e28:	00000d06 	br	9090e60 <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 9090e2c:	e0fff817 	ldw	r3,-32(fp)
 9090e30:	e0bff917 	ldw	r2,-28(fp)
 9090e34:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 9090e38:	e0bff917 	ldw	r2,-28(fp)
 9090e3c:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 9090e40:	e0bff917 	ldw	r2,-28(fp)
 9090e44:	1007883a 	mov	r3,r2
 9090e48:	e0bffd17 	ldw	r2,-12(fp)
 9090e4c:	1885883a 	add	r2,r3,r2
 9090e50:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 9090e54:	e0bff717 	ldw	r2,-36(fp)
 9090e58:	10800044 	addi	r2,r2,1
 9090e5c:	e0bff715 	stw	r2,-36(fp)
 9090e60:	e0bffc17 	ldw	r2,-16(fp)
 9090e64:	10ffffc4 	addi	r3,r2,-1
 9090e68:	e0bff717 	ldw	r2,-36(fp)
 9090e6c:	10ffef36 	bltu	r2,r3,9090e2c <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 9090e70:	e0bff817 	ldw	r2,-32(fp)
 9090e74:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 9090e78:	e0fffa17 	ldw	r3,-24(fp)
 9090e7c:	e0bffb17 	ldw	r2,-20(fp)
 9090e80:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 9090e84:	e0fffa17 	ldw	r3,-24(fp)
 9090e88:	e0bffb17 	ldw	r2,-20(fp)
 9090e8c:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 9090e90:	e0fffa17 	ldw	r3,-24(fp)
 9090e94:	e0bffc17 	ldw	r2,-16(fp)
 9090e98:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 9090e9c:	e0fffa17 	ldw	r3,-24(fp)
 9090ea0:	e0bffc17 	ldw	r2,-16(fp)
 9090ea4:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 9090ea8:	e0fffa17 	ldw	r3,-24(fp)
 9090eac:	e0bffd17 	ldw	r2,-12(fp)
 9090eb0:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 9090eb4:	e0bffe17 	ldw	r2,-8(fp)
 9090eb8:	10000005 	stb	zero,0(r2)
    return (pmem);
 9090ebc:	e0bffa17 	ldw	r2,-24(fp)
 9090ec0:	e0bfff15 	stw	r2,-4(fp)
 9090ec4:	e0bfff17 	ldw	r2,-4(fp)
}
 9090ec8:	e037883a 	mov	sp,fp
 9090ecc:	df000017 	ldw	fp,0(sp)
 9090ed0:	dec00104 	addi	sp,sp,4
 9090ed4:	f800283a 	ret

09090ed8 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 9090ed8:	defff704 	addi	sp,sp,-36
 9090edc:	df000815 	stw	fp,32(sp)
 9090ee0:	df000804 	addi	fp,sp,32
 9090ee4:	e13ffd15 	stw	r4,-12(fp)
 9090ee8:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9090eec:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9090ef0:	e0bffe17 	ldw	r2,-8(fp)
 9090ef4:	1004c03a 	cmpne	r2,r2,zero
 9090ef8:	1000021e 	bne	r2,zero,9090f04 <OSMemGet+0x2c>
        return ((void *)0);
 9090efc:	e03fff15 	stw	zero,-4(fp)
 9090f00:	00003106 	br	9090fc8 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 9090f04:	e0bffd17 	ldw	r2,-12(fp)
 9090f08:	1004c03a 	cmpne	r2,r2,zero
 9090f0c:	1000051e 	bne	r2,zero,9090f24 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 9090f10:	e0fffe17 	ldw	r3,-8(fp)
 9090f14:	00801804 	movi	r2,96
 9090f18:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9090f1c:	e03fff15 	stw	zero,-4(fp)
 9090f20:	00002906 	br	9090fc8 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090f24:	0005303a 	rdctl	r2,status
 9090f28:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090f2c:	e0fffa17 	ldw	r3,-24(fp)
 9090f30:	00bfff84 	movi	r2,-2
 9090f34:	1884703a 	and	r2,r3,r2
 9090f38:	1001703a 	wrctl	status,r2
  
  return context;
 9090f3c:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9090f40:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 9090f44:	e0bffd17 	ldw	r2,-12(fp)
 9090f48:	10800417 	ldw	r2,16(r2)
 9090f4c:	1005003a 	cmpeq	r2,r2,zero
 9090f50:	1000151e 	bne	r2,zero,9090fa8 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 9090f54:	e0bffd17 	ldw	r2,-12(fp)
 9090f58:	10800117 	ldw	r2,4(r2)
 9090f5c:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 9090f60:	e0bffc17 	ldw	r2,-16(fp)
 9090f64:	10c00017 	ldw	r3,0(r2)
 9090f68:	e0bffd17 	ldw	r2,-12(fp)
 9090f6c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 9090f70:	e0bffd17 	ldw	r2,-12(fp)
 9090f74:	10800417 	ldw	r2,16(r2)
 9090f78:	10ffffc4 	addi	r3,r2,-1
 9090f7c:	e0bffd17 	ldw	r2,-12(fp)
 9090f80:	10c00415 	stw	r3,16(r2)
 9090f84:	e0bffb17 	ldw	r2,-20(fp)
 9090f88:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090f8c:	e0bff917 	ldw	r2,-28(fp)
 9090f90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 9090f94:	e0bffe17 	ldw	r2,-8(fp)
 9090f98:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 9090f9c:	e0bffc17 	ldw	r2,-16(fp)
 9090fa0:	e0bfff15 	stw	r2,-4(fp)
 9090fa4:	00000806 	br	9090fc8 <OSMemGet+0xf0>
 9090fa8:	e0bffb17 	ldw	r2,-20(fp)
 9090fac:	e0bff815 	stw	r2,-32(fp)
 9090fb0:	e0bff817 	ldw	r2,-32(fp)
 9090fb4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 9090fb8:	e0fffe17 	ldw	r3,-8(fp)
 9090fbc:	00801744 	movi	r2,93
 9090fc0:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 9090fc4:	e03fff15 	stw	zero,-4(fp)
 9090fc8:	e0bfff17 	ldw	r2,-4(fp)
}
 9090fcc:	e037883a 	mov	sp,fp
 9090fd0:	df000017 	ldw	fp,0(sp)
 9090fd4:	dec00104 	addi	sp,sp,4
 9090fd8:	f800283a 	ret

09090fdc <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 9090fdc:	defff604 	addi	sp,sp,-40
 9090fe0:	dfc00915 	stw	ra,36(sp)
 9090fe4:	df000815 	stw	fp,32(sp)
 9090fe8:	df000804 	addi	fp,sp,32
 9090fec:	e13ffc15 	stw	r4,-16(fp)
 9090ff0:	e17ffd15 	stw	r5,-12(fp)
 9090ff4:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9090ff8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9090ffc:	e0bffe17 	ldw	r2,-8(fp)
 9091000:	1004c03a 	cmpne	r2,r2,zero
 9091004:	1000021e 	bne	r2,zero,9091010 <OSMemNameGet+0x34>
        return (0);
 9091008:	e03fff15 	stw	zero,-4(fp)
 909100c:	00003006 	br	90910d0 <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 9091010:	e0bffc17 	ldw	r2,-16(fp)
 9091014:	1004c03a 	cmpne	r2,r2,zero
 9091018:	1000051e 	bne	r2,zero,9091030 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 909101c:	e0fffe17 	ldw	r3,-8(fp)
 9091020:	00801804 	movi	r2,96
 9091024:	18800005 	stb	r2,0(r3)
        return (0);
 9091028:	e03fff15 	stw	zero,-4(fp)
 909102c:	00002806 	br	90910d0 <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9091030:	e0bffd17 	ldw	r2,-12(fp)
 9091034:	1004c03a 	cmpne	r2,r2,zero
 9091038:	1000051e 	bne	r2,zero,9091050 <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 909103c:	e0fffe17 	ldw	r3,-8(fp)
 9091040:	00800304 	movi	r2,12
 9091044:	18800005 	stb	r2,0(r3)
        return (0);
 9091048:	e03fff15 	stw	zero,-4(fp)
 909104c:	00002006 	br	90910d0 <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9091050:	00824374 	movhi	r2,2317
 9091054:	108c1304 	addi	r2,r2,12364
 9091058:	10800003 	ldbu	r2,0(r2)
 909105c:	10803fcc 	andi	r2,r2,255
 9091060:	1005003a 	cmpeq	r2,r2,zero
 9091064:	1000051e 	bne	r2,zero,909107c <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 9091068:	e0fffe17 	ldw	r3,-8(fp)
 909106c:	00800444 	movi	r2,17
 9091070:	18800005 	stb	r2,0(r3)
        return (0);
 9091074:	e03fff15 	stw	zero,-4(fp)
 9091078:	00001506 	br	90910d0 <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909107c:	0005303a 	rdctl	r2,status
 9091080:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091084:	e0fff917 	ldw	r3,-28(fp)
 9091088:	00bfff84 	movi	r2,-2
 909108c:	1884703a 	and	r2,r3,r2
 9091090:	1001703a 	wrctl	status,r2
  
  return context;
 9091094:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9091098:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 909109c:	e0bffc17 	ldw	r2,-16(fp)
 90910a0:	11400504 	addi	r5,r2,20
 90910a4:	e13ffd17 	ldw	r4,-12(fp)
 90910a8:	908ec380 	call	908ec38 <OS_StrCopy>
 90910ac:	e0bffb05 	stb	r2,-20(fp)
 90910b0:	e0bffa17 	ldw	r2,-24(fp)
 90910b4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90910b8:	e0bff817 	ldw	r2,-32(fp)
 90910bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90910c0:	e0bffe17 	ldw	r2,-8(fp)
 90910c4:	10000005 	stb	zero,0(r2)
    return (len);
 90910c8:	e0bffb03 	ldbu	r2,-20(fp)
 90910cc:	e0bfff15 	stw	r2,-4(fp)
 90910d0:	e0bfff17 	ldw	r2,-4(fp)
}
 90910d4:	e037883a 	mov	sp,fp
 90910d8:	dfc00117 	ldw	ra,4(sp)
 90910dc:	df000017 	ldw	fp,0(sp)
 90910e0:	dec00204 	addi	sp,sp,8
 90910e4:	f800283a 	ret

090910e8 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 90910e8:	defff604 	addi	sp,sp,-40
 90910ec:	dfc00915 	stw	ra,36(sp)
 90910f0:	df000815 	stw	fp,32(sp)
 90910f4:	df000804 	addi	fp,sp,32
 90910f8:	e13ffd15 	stw	r4,-12(fp)
 90910fc:	e17ffe15 	stw	r5,-8(fp)
 9091100:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9091104:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9091108:	e0bfff17 	ldw	r2,-4(fp)
 909110c:	1005003a 	cmpeq	r2,r2,zero
 9091110:	1000381e 	bne	r2,zero,90911f4 <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 9091114:	e0bffd17 	ldw	r2,-12(fp)
 9091118:	1004c03a 	cmpne	r2,r2,zero
 909111c:	1000041e 	bne	r2,zero,9091130 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 9091120:	e0ffff17 	ldw	r3,-4(fp)
 9091124:	00801804 	movi	r2,96
 9091128:	18800005 	stb	r2,0(r3)
        return;
 909112c:	00003106 	br	90911f4 <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9091130:	e0bffe17 	ldw	r2,-8(fp)
 9091134:	1004c03a 	cmpne	r2,r2,zero
 9091138:	1000041e 	bne	r2,zero,909114c <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 909113c:	e0ffff17 	ldw	r3,-4(fp)
 9091140:	00800304 	movi	r2,12
 9091144:	18800005 	stb	r2,0(r3)
        return;
 9091148:	00002a06 	br	90911f4 <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 909114c:	00824374 	movhi	r2,2317
 9091150:	108c1304 	addi	r2,r2,12364
 9091154:	10800003 	ldbu	r2,0(r2)
 9091158:	10803fcc 	andi	r2,r2,255
 909115c:	1005003a 	cmpeq	r2,r2,zero
 9091160:	1000041e 	bne	r2,zero,9091174 <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 9091164:	e0ffff17 	ldw	r3,-4(fp)
 9091168:	00800484 	movi	r2,18
 909116c:	18800005 	stb	r2,0(r3)
        return;
 9091170:	00002006 	br	90911f4 <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091174:	0005303a 	rdctl	r2,status
 9091178:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909117c:	e0fffa17 	ldw	r3,-24(fp)
 9091180:	00bfff84 	movi	r2,-2
 9091184:	1884703a 	and	r2,r3,r2
 9091188:	1001703a 	wrctl	status,r2
  
  return context;
 909118c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9091190:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 9091194:	e13ffe17 	ldw	r4,-8(fp)
 9091198:	908ecb80 	call	908ecb8 <OS_StrLen>
 909119c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 90911a0:	e0bffc03 	ldbu	r2,-16(fp)
 90911a4:	10800830 	cmpltui	r2,r2,32
 90911a8:	1000081e 	bne	r2,zero,90911cc <OSMemNameSet+0xe4>
 90911ac:	e0bffb17 	ldw	r2,-20(fp)
 90911b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90911b4:	e0bff917 	ldw	r2,-28(fp)
 90911b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 90911bc:	e0ffff17 	ldw	r3,-4(fp)
 90911c0:	008018c4 	movi	r2,99
 90911c4:	18800005 	stb	r2,0(r3)
        return;
 90911c8:	00000a06 	br	90911f4 <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 90911cc:	e0bffd17 	ldw	r2,-12(fp)
 90911d0:	11000504 	addi	r4,r2,20
 90911d4:	e17ffe17 	ldw	r5,-8(fp)
 90911d8:	908ec380 	call	908ec38 <OS_StrCopy>
 90911dc:	e0bffb17 	ldw	r2,-20(fp)
 90911e0:	e0bff815 	stw	r2,-32(fp)
 90911e4:	e0bff817 	ldw	r2,-32(fp)
 90911e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90911ec:	e0bfff17 	ldw	r2,-4(fp)
 90911f0:	10000005 	stb	zero,0(r2)
}
 90911f4:	e037883a 	mov	sp,fp
 90911f8:	dfc00117 	ldw	ra,4(sp)
 90911fc:	df000017 	ldw	fp,0(sp)
 9091200:	dec00204 	addi	sp,sp,8
 9091204:	f800283a 	ret

09091208 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 9091208:	defff804 	addi	sp,sp,-32
 909120c:	df000715 	stw	fp,28(sp)
 9091210:	df000704 	addi	fp,sp,28
 9091214:	e13ffd15 	stw	r4,-12(fp)
 9091218:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 909121c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 9091220:	e0bffd17 	ldw	r2,-12(fp)
 9091224:	1004c03a 	cmpne	r2,r2,zero
 9091228:	1000031e 	bne	r2,zero,9091238 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 909122c:	00801804 	movi	r2,96
 9091230:	e0bfff15 	stw	r2,-4(fp)
 9091234:	00002b06 	br	90912e4 <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 9091238:	e0bffe17 	ldw	r2,-8(fp)
 909123c:	1004c03a 	cmpne	r2,r2,zero
 9091240:	1000031e 	bne	r2,zero,9091250 <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 9091244:	008017c4 	movi	r2,95
 9091248:	e0bfff15 	stw	r2,-4(fp)
 909124c:	00002506 	br	90912e4 <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091250:	0005303a 	rdctl	r2,status
 9091254:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091258:	e0fffb17 	ldw	r3,-20(fp)
 909125c:	00bfff84 	movi	r2,-2
 9091260:	1884703a 	and	r2,r3,r2
 9091264:	1001703a 	wrctl	status,r2
  
  return context;
 9091268:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909126c:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 9091270:	e0bffd17 	ldw	r2,-12(fp)
 9091274:	10c00417 	ldw	r3,16(r2)
 9091278:	e0bffd17 	ldw	r2,-12(fp)
 909127c:	10800317 	ldw	r2,12(r2)
 9091280:	18800736 	bltu	r3,r2,90912a0 <OSMemPut+0x98>
 9091284:	e0bffc17 	ldw	r2,-16(fp)
 9091288:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909128c:	e0bffa17 	ldw	r2,-24(fp)
 9091290:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 9091294:	00801784 	movi	r2,94
 9091298:	e0bfff15 	stw	r2,-4(fp)
 909129c:	00001106 	br	90912e4 <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 90912a0:	e0fffe17 	ldw	r3,-8(fp)
 90912a4:	e0bffd17 	ldw	r2,-12(fp)
 90912a8:	10800117 	ldw	r2,4(r2)
 90912ac:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 90912b0:	e0fffd17 	ldw	r3,-12(fp)
 90912b4:	e0bffe17 	ldw	r2,-8(fp)
 90912b8:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 90912bc:	e0bffd17 	ldw	r2,-12(fp)
 90912c0:	10800417 	ldw	r2,16(r2)
 90912c4:	10c00044 	addi	r3,r2,1
 90912c8:	e0bffd17 	ldw	r2,-12(fp)
 90912cc:	10c00415 	stw	r3,16(r2)
 90912d0:	e0bffc17 	ldw	r2,-16(fp)
 90912d4:	e0bff915 	stw	r2,-28(fp)
 90912d8:	e0bff917 	ldw	r2,-28(fp)
 90912dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 90912e0:	e03fff15 	stw	zero,-4(fp)
 90912e4:	e0bfff17 	ldw	r2,-4(fp)
}
 90912e8:	e037883a 	mov	sp,fp
 90912ec:	df000017 	ldw	fp,0(sp)
 90912f0:	dec00104 	addi	sp,sp,4
 90912f4:	f800283a 	ret

090912f8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 90912f8:	defff904 	addi	sp,sp,-28
 90912fc:	df000615 	stw	fp,24(sp)
 9091300:	df000604 	addi	fp,sp,24
 9091304:	e13ffd15 	stw	r4,-12(fp)
 9091308:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 909130c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 9091310:	e0bffd17 	ldw	r2,-12(fp)
 9091314:	1004c03a 	cmpne	r2,r2,zero
 9091318:	1000031e 	bne	r2,zero,9091328 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 909131c:	00801804 	movi	r2,96
 9091320:	e0bfff15 	stw	r2,-4(fp)
 9091324:	00002e06 	br	90913e0 <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 9091328:	e0bffe17 	ldw	r2,-8(fp)
 909132c:	1004c03a 	cmpne	r2,r2,zero
 9091330:	1000031e 	bne	r2,zero,9091340 <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 9091334:	00801844 	movi	r2,97
 9091338:	e0bfff15 	stw	r2,-4(fp)
 909133c:	00002806 	br	90913e0 <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091340:	0005303a 	rdctl	r2,status
 9091344:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091348:	e0fffb17 	ldw	r3,-20(fp)
 909134c:	00bfff84 	movi	r2,-2
 9091350:	1884703a 	and	r2,r3,r2
 9091354:	1001703a 	wrctl	status,r2
  
  return context;
 9091358:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909135c:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 9091360:	e0bffd17 	ldw	r2,-12(fp)
 9091364:	10c00017 	ldw	r3,0(r2)
 9091368:	e0bffe17 	ldw	r2,-8(fp)
 909136c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 9091370:	e0bffd17 	ldw	r2,-12(fp)
 9091374:	10c00117 	ldw	r3,4(r2)
 9091378:	e0bffe17 	ldw	r2,-8(fp)
 909137c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 9091380:	e0bffd17 	ldw	r2,-12(fp)
 9091384:	10c00217 	ldw	r3,8(r2)
 9091388:	e0bffe17 	ldw	r2,-8(fp)
 909138c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 9091390:	e0bffd17 	ldw	r2,-12(fp)
 9091394:	10c00317 	ldw	r3,12(r2)
 9091398:	e0bffe17 	ldw	r2,-8(fp)
 909139c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 90913a0:	e0bffd17 	ldw	r2,-12(fp)
 90913a4:	10c00417 	ldw	r3,16(r2)
 90913a8:	e0bffe17 	ldw	r2,-8(fp)
 90913ac:	10c00415 	stw	r3,16(r2)
 90913b0:	e0bffc17 	ldw	r2,-16(fp)
 90913b4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90913b8:	e0bffa17 	ldw	r2,-24(fp)
 90913bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 90913c0:	e0bffe17 	ldw	r2,-8(fp)
 90913c4:	10c00317 	ldw	r3,12(r2)
 90913c8:	e0bffe17 	ldw	r2,-8(fp)
 90913cc:	10800417 	ldw	r2,16(r2)
 90913d0:	1887c83a 	sub	r3,r3,r2
 90913d4:	e0bffe17 	ldw	r2,-8(fp)
 90913d8:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 90913dc:	e03fff15 	stw	zero,-4(fp)
 90913e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90913e4:	e037883a 	mov	sp,fp
 90913e8:	df000017 	ldw	fp,0(sp)
 90913ec:	dec00104 	addi	sp,sp,4
 90913f0:	f800283a 	ret

090913f4 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 90913f4:	defffc04 	addi	sp,sp,-16
 90913f8:	dfc00315 	stw	ra,12(sp)
 90913fc:	df000215 	stw	fp,8(sp)
 9091400:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 9091404:	010243b4 	movhi	r4,2318
 9091408:	21271404 	addi	r4,r4,-25520
 909140c:	01430c04 	movi	r5,3120
 9091410:	908ea340 	call	908ea34 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 9091414:	008243b4 	movhi	r2,2318
 9091418:	10a71404 	addi	r2,r2,-25520
 909141c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 9091420:	e03ffe0d 	sth	zero,-8(fp)
 9091424:	00001306 	br	9091474 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 9091428:	e0bffe0b 	ldhu	r2,-8(fp)
 909142c:	10800d24 	muli	r2,r2,52
 9091430:	1007883a 	mov	r3,r2
 9091434:	008243b4 	movhi	r2,2318
 9091438:	10a72104 	addi	r2,r2,-25468
 909143c:	1887883a 	add	r3,r3,r2
 9091440:	e0bfff17 	ldw	r2,-4(fp)
 9091444:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 9091448:	e0ffff17 	ldw	r3,-4(fp)
 909144c:	00800fc4 	movi	r2,63
 9091450:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 9091454:	e0bfff17 	ldw	r2,-4(fp)
 9091458:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 909145c:	e0bfff17 	ldw	r2,-4(fp)
 9091460:	10800d04 	addi	r2,r2,52
 9091464:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 9091468:	e0bffe0b 	ldhu	r2,-8(fp)
 909146c:	10800044 	addi	r2,r2,1
 9091470:	e0bffe0d 	sth	r2,-8(fp)
 9091474:	e0bffe0b 	ldhu	r2,-8(fp)
 9091478:	10800ef0 	cmpltui	r2,r2,59
 909147c:	103fea1e 	bne	r2,zero,9091428 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 9091480:	e0bfff17 	ldw	r2,-4(fp)
 9091484:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 9091488:	e0ffff17 	ldw	r3,-4(fp)
 909148c:	00800fc4 	movi	r2,63
 9091490:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 9091494:	e0bfff17 	ldw	r2,-4(fp)
 9091498:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 909149c:	00c24374 	movhi	r3,2317
 90914a0:	18cc0e04 	addi	r3,r3,12344
 90914a4:	008243b4 	movhi	r2,2318
 90914a8:	10a71404 	addi	r2,r2,-25520
 90914ac:	18800015 	stw	r2,0(r3)
#endif
}
 90914b0:	e037883a 	mov	sp,fp
 90914b4:	dfc00117 	ldw	ra,4(sp)
 90914b8:	df000017 	ldw	fp,0(sp)
 90914bc:	dec00204 	addi	sp,sp,8
 90914c0:	f800283a 	ret

090914c4 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 90914c4:	defff704 	addi	sp,sp,-36
 90914c8:	df000815 	stw	fp,32(sp)
 90914cc:	df000804 	addi	fp,sp,32
 90914d0:	e13ffd15 	stw	r4,-12(fp)
 90914d4:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 90914d8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 90914dc:	e0bffe17 	ldw	r2,-8(fp)
 90914e0:	1004c03a 	cmpne	r2,r2,zero
 90914e4:	1000021e 	bne	r2,zero,90914f0 <OSQAccept+0x2c>
        return ((void *)0);
 90914e8:	e03fff15 	stw	zero,-4(fp)
 90914ec:	00004506 	br	9091604 <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 90914f0:	e0bffd17 	ldw	r2,-12(fp)
 90914f4:	1004c03a 	cmpne	r2,r2,zero
 90914f8:	1000051e 	bne	r2,zero,9091510 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 90914fc:	e0fffe17 	ldw	r3,-8(fp)
 9091500:	00800104 	movi	r2,4
 9091504:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091508:	e03fff15 	stw	zero,-4(fp)
 909150c:	00003d06 	br	9091604 <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 9091510:	e0bffd17 	ldw	r2,-12(fp)
 9091514:	10800003 	ldbu	r2,0(r2)
 9091518:	10803fcc 	andi	r2,r2,255
 909151c:	108000a0 	cmpeqi	r2,r2,2
 9091520:	1000051e 	bne	r2,zero,9091538 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 9091524:	e0fffe17 	ldw	r3,-8(fp)
 9091528:	00800044 	movi	r2,1
 909152c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091530:	e03fff15 	stw	zero,-4(fp)
 9091534:	00003306 	br	9091604 <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091538:	0005303a 	rdctl	r2,status
 909153c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091540:	e0fff917 	ldw	r3,-28(fp)
 9091544:	00bfff84 	movi	r2,-2
 9091548:	1884703a 	and	r2,r3,r2
 909154c:	1001703a 	wrctl	status,r2
  
  return context;
 9091550:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9091554:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 9091558:	e0bffd17 	ldw	r2,-12(fp)
 909155c:	10800117 	ldw	r2,4(r2)
 9091560:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 9091564:	e0bffb17 	ldw	r2,-20(fp)
 9091568:	1080058b 	ldhu	r2,22(r2)
 909156c:	10bfffcc 	andi	r2,r2,65535
 9091570:	1005003a 	cmpeq	r2,r2,zero
 9091574:	1000191e 	bne	r2,zero,90915dc <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 9091578:	e0bffb17 	ldw	r2,-20(fp)
 909157c:	10c00417 	ldw	r3,16(r2)
 9091580:	18800017 	ldw	r2,0(r3)
 9091584:	e0bffc15 	stw	r2,-16(fp)
 9091588:	18c00104 	addi	r3,r3,4
 909158c:	e0bffb17 	ldw	r2,-20(fp)
 9091590:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 9091594:	e0bffb17 	ldw	r2,-20(fp)
 9091598:	1080058b 	ldhu	r2,22(r2)
 909159c:	10bfffc4 	addi	r2,r2,-1
 90915a0:	1007883a 	mov	r3,r2
 90915a4:	e0bffb17 	ldw	r2,-20(fp)
 90915a8:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 90915ac:	e0bffb17 	ldw	r2,-20(fp)
 90915b0:	10c00417 	ldw	r3,16(r2)
 90915b4:	e0bffb17 	ldw	r2,-20(fp)
 90915b8:	10800217 	ldw	r2,8(r2)
 90915bc:	1880041e 	bne	r3,r2,90915d0 <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 90915c0:	e0bffb17 	ldw	r2,-20(fp)
 90915c4:	10c00117 	ldw	r3,4(r2)
 90915c8:	e0bffb17 	ldw	r2,-20(fp)
 90915cc:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 90915d0:	e0bffe17 	ldw	r2,-8(fp)
 90915d4:	10000005 	stb	zero,0(r2)
 90915d8:	00000406 	br	90915ec <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 90915dc:	e0fffe17 	ldw	r3,-8(fp)
 90915e0:	008007c4 	movi	r2,31
 90915e4:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 90915e8:	e03ffc15 	stw	zero,-16(fp)
 90915ec:	e0bffa17 	ldw	r2,-24(fp)
 90915f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90915f4:	e0bff817 	ldw	r2,-32(fp)
 90915f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 90915fc:	e0bffc17 	ldw	r2,-16(fp)
 9091600:	e0bfff15 	stw	r2,-4(fp)
 9091604:	e0bfff17 	ldw	r2,-4(fp)
}
 9091608:	e037883a 	mov	sp,fp
 909160c:	df000017 	ldw	fp,0(sp)
 9091610:	dec00104 	addi	sp,sp,4
 9091614:	f800283a 	ret

09091618 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 9091618:	defff304 	addi	sp,sp,-52
 909161c:	dfc00c15 	stw	ra,48(sp)
 9091620:	df000b15 	stw	fp,44(sp)
 9091624:	df000b04 	addi	fp,sp,44
 9091628:	e13ffd15 	stw	r4,-12(fp)
 909162c:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9091630:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 9091634:	00824374 	movhi	r2,2317
 9091638:	108c1304 	addi	r2,r2,12364
 909163c:	10800003 	ldbu	r2,0(r2)
 9091640:	10803fcc 	andi	r2,r2,255
 9091644:	1005003a 	cmpeq	r2,r2,zero
 9091648:	1000021e 	bne	r2,zero,9091654 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 909164c:	e03fff15 	stw	zero,-4(fp)
 9091650:	00007006 	br	9091814 <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091654:	0005303a 	rdctl	r2,status
 9091658:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909165c:	e0fff917 	ldw	r3,-28(fp)
 9091660:	00bfff84 	movi	r2,-2
 9091664:	1884703a 	and	r2,r3,r2
 9091668:	1001703a 	wrctl	status,r2
  
  return context;
 909166c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9091670:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 9091674:	00824374 	movhi	r2,2317
 9091678:	108c1204 	addi	r2,r2,12360
 909167c:	10800017 	ldw	r2,0(r2)
 9091680:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 9091684:	00824374 	movhi	r2,2317
 9091688:	108c1204 	addi	r2,r2,12360
 909168c:	10800017 	ldw	r2,0(r2)
 9091690:	1005003a 	cmpeq	r2,r2,zero
 9091694:	1000081e 	bne	r2,zero,90916b8 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 9091698:	00824374 	movhi	r2,2317
 909169c:	108c1204 	addi	r2,r2,12360
 90916a0:	10800017 	ldw	r2,0(r2)
 90916a4:	10800117 	ldw	r2,4(r2)
 90916a8:	1007883a 	mov	r3,r2
 90916ac:	00824374 	movhi	r2,2317
 90916b0:	108c1204 	addi	r2,r2,12360
 90916b4:	10c00015 	stw	r3,0(r2)
 90916b8:	e0bffa17 	ldw	r2,-24(fp)
 90916bc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90916c0:	e0bff817 	ldw	r2,-32(fp)
 90916c4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 90916c8:	e0bffc17 	ldw	r2,-16(fp)
 90916cc:	1005003a 	cmpeq	r2,r2,zero
 90916d0:	10004e1e 	bne	r2,zero,909180c <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90916d4:	0005303a 	rdctl	r2,status
 90916d8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90916dc:	e0fff717 	ldw	r3,-36(fp)
 90916e0:	00bfff84 	movi	r2,-2
 90916e4:	1884703a 	and	r2,r3,r2
 90916e8:	1001703a 	wrctl	status,r2
  
  return context;
 90916ec:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 90916f0:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 90916f4:	00824374 	movhi	r2,2317
 90916f8:	108c1004 	addi	r2,r2,12352
 90916fc:	10800017 	ldw	r2,0(r2)
 9091700:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 9091704:	e0bffb17 	ldw	r2,-20(fp)
 9091708:	1005003a 	cmpeq	r2,r2,zero
 909170c:	1000311e 	bne	r2,zero,90917d4 <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 9091710:	00824374 	movhi	r2,2317
 9091714:	108c1004 	addi	r2,r2,12352
 9091718:	10800017 	ldw	r2,0(r2)
 909171c:	10c00017 	ldw	r3,0(r2)
 9091720:	00824374 	movhi	r2,2317
 9091724:	108c1004 	addi	r2,r2,12352
 9091728:	10c00015 	stw	r3,0(r2)
 909172c:	e0bffa17 	ldw	r2,-24(fp)
 9091730:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091734:	e0bff617 	ldw	r2,-40(fp)
 9091738:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 909173c:	e0fffb17 	ldw	r3,-20(fp)
 9091740:	e0bffd17 	ldw	r2,-12(fp)
 9091744:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 9091748:	e0bffe0b 	ldhu	r2,-8(fp)
 909174c:	1085883a 	add	r2,r2,r2
 9091750:	1085883a 	add	r2,r2,r2
 9091754:	1007883a 	mov	r3,r2
 9091758:	e0bffd17 	ldw	r2,-12(fp)
 909175c:	1887883a 	add	r3,r3,r2
 9091760:	e0bffb17 	ldw	r2,-20(fp)
 9091764:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 9091768:	e0fffb17 	ldw	r3,-20(fp)
 909176c:	e0bffd17 	ldw	r2,-12(fp)
 9091770:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 9091774:	e0fffb17 	ldw	r3,-20(fp)
 9091778:	e0bffd17 	ldw	r2,-12(fp)
 909177c:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 9091780:	e0fffb17 	ldw	r3,-20(fp)
 9091784:	e0bffe0b 	ldhu	r2,-8(fp)
 9091788:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 909178c:	e0bffb17 	ldw	r2,-20(fp)
 9091790:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 9091794:	e0fffc17 	ldw	r3,-16(fp)
 9091798:	00800084 	movi	r2,2
 909179c:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 90917a0:	e0bffc17 	ldw	r2,-16(fp)
 90917a4:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 90917a8:	e0fffc17 	ldw	r3,-16(fp)
 90917ac:	e0bffb17 	ldw	r2,-20(fp)
 90917b0:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 90917b4:	e0fffc17 	ldw	r3,-16(fp)
 90917b8:	00800fc4 	movi	r2,63
 90917bc:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 90917c0:	e0bffc17 	ldw	r2,-16(fp)
 90917c4:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 90917c8:	e13ffc17 	ldw	r4,-16(fp)
 90917cc:	908e6680 	call	908e668 <OS_EventWaitListInit>
 90917d0:	00000e06 	br	909180c <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 90917d4:	00824374 	movhi	r2,2317
 90917d8:	108c1204 	addi	r2,r2,12360
 90917dc:	10c00017 	ldw	r3,0(r2)
 90917e0:	e0bffc17 	ldw	r2,-16(fp)
 90917e4:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 90917e8:	00c24374 	movhi	r3,2317
 90917ec:	18cc1204 	addi	r3,r3,12360
 90917f0:	e0bffc17 	ldw	r2,-16(fp)
 90917f4:	18800015 	stw	r2,0(r3)
 90917f8:	e0bffa17 	ldw	r2,-24(fp)
 90917fc:	e0bff515 	stw	r2,-44(fp)
 9091800:	e0bff517 	ldw	r2,-44(fp)
 9091804:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 9091808:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 909180c:	e0bffc17 	ldw	r2,-16(fp)
 9091810:	e0bfff15 	stw	r2,-4(fp)
 9091814:	e0bfff17 	ldw	r2,-4(fp)
}
 9091818:	e037883a 	mov	sp,fp
 909181c:	dfc00117 	ldw	ra,4(sp)
 9091820:	df000017 	ldw	fp,0(sp)
 9091824:	dec00204 	addi	sp,sp,8
 9091828:	f800283a 	ret

0909182c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 909182c:	defff004 	addi	sp,sp,-64
 9091830:	dfc00f15 	stw	ra,60(sp)
 9091834:	df000e15 	stw	fp,56(sp)
 9091838:	df000e04 	addi	fp,sp,56
 909183c:	e13ffb15 	stw	r4,-20(fp)
 9091840:	e1bffd15 	stw	r6,-12(fp)
 9091844:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 9091848:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 909184c:	e0bffd17 	ldw	r2,-12(fp)
 9091850:	1004c03a 	cmpne	r2,r2,zero
 9091854:	1000031e 	bne	r2,zero,9091864 <OSQDel+0x38>
        return (pevent);
 9091858:	e0bffb17 	ldw	r2,-20(fp)
 909185c:	e0bfff15 	stw	r2,-4(fp)
 9091860:	0000ac06 	br	9091b14 <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9091864:	e0bffb17 	ldw	r2,-20(fp)
 9091868:	1004c03a 	cmpne	r2,r2,zero
 909186c:	1000061e 	bne	r2,zero,9091888 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 9091870:	e0fffd17 	ldw	r3,-12(fp)
 9091874:	00800104 	movi	r2,4
 9091878:	18800005 	stb	r2,0(r3)
        return (pevent);
 909187c:	e0fffb17 	ldw	r3,-20(fp)
 9091880:	e0ffff15 	stw	r3,-4(fp)
 9091884:	0000a306 	br	9091b14 <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 9091888:	e0bffb17 	ldw	r2,-20(fp)
 909188c:	10800003 	ldbu	r2,0(r2)
 9091890:	10803fcc 	andi	r2,r2,255
 9091894:	108000a0 	cmpeqi	r2,r2,2
 9091898:	1000061e 	bne	r2,zero,90918b4 <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 909189c:	e0fffd17 	ldw	r3,-12(fp)
 90918a0:	00800044 	movi	r2,1
 90918a4:	18800005 	stb	r2,0(r3)
        return (pevent);
 90918a8:	e0bffb17 	ldw	r2,-20(fp)
 90918ac:	e0bfff15 	stw	r2,-4(fp)
 90918b0:	00009806 	br	9091b14 <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 90918b4:	00824374 	movhi	r2,2317
 90918b8:	108c1304 	addi	r2,r2,12364
 90918bc:	10800003 	ldbu	r2,0(r2)
 90918c0:	10803fcc 	andi	r2,r2,255
 90918c4:	1005003a 	cmpeq	r2,r2,zero
 90918c8:	1000061e 	bne	r2,zero,90918e4 <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 90918cc:	e0fffd17 	ldw	r3,-12(fp)
 90918d0:	008003c4 	movi	r2,15
 90918d4:	18800005 	stb	r2,0(r3)
        return (pevent);
 90918d8:	e0fffb17 	ldw	r3,-20(fp)
 90918dc:	e0ffff15 	stw	r3,-4(fp)
 90918e0:	00008c06 	br	9091b14 <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90918e4:	0005303a 	rdctl	r2,status
 90918e8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90918ec:	e0fff617 	ldw	r3,-40(fp)
 90918f0:	00bfff84 	movi	r2,-2
 90918f4:	1884703a 	and	r2,r3,r2
 90918f8:	1001703a 	wrctl	status,r2
  
  return context;
 90918fc:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 9091900:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 9091904:	e0bffb17 	ldw	r2,-20(fp)
 9091908:	10800283 	ldbu	r2,10(r2)
 909190c:	10803fcc 	andi	r2,r2,255
 9091910:	1005003a 	cmpeq	r2,r2,zero
 9091914:	1000031e 	bne	r2,zero,9091924 <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 9091918:	00800044 	movi	r2,1
 909191c:	e0bffa05 	stb	r2,-24(fp)
 9091920:	00000106 	br	9091928 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 9091924:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 9091928:	e0bffc03 	ldbu	r2,-16(fp)
 909192c:	e0bffe15 	stw	r2,-8(fp)
 9091930:	e0fffe17 	ldw	r3,-8(fp)
 9091934:	1805003a 	cmpeq	r2,r3,zero
 9091938:	1000041e 	bne	r2,zero,909194c <OSQDel+0x120>
 909193c:	e0fffe17 	ldw	r3,-8(fp)
 9091940:	18800060 	cmpeqi	r2,r3,1
 9091944:	1000391e 	bne	r2,zero,9091a2c <OSQDel+0x200>
 9091948:	00006706 	br	9091ae8 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 909194c:	e0bffa03 	ldbu	r2,-24(fp)
 9091950:	1004c03a 	cmpne	r2,r2,zero
 9091954:	1000261e 	bne	r2,zero,90919f0 <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 9091958:	e0fffb17 	ldw	r3,-20(fp)
 909195c:	00800fc4 	movi	r2,63
 9091960:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 9091964:	e0bffb17 	ldw	r2,-20(fp)
 9091968:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 909196c:	e0bffb17 	ldw	r2,-20(fp)
 9091970:	10800117 	ldw	r2,4(r2)
 9091974:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 9091978:	00824374 	movhi	r2,2317
 909197c:	108c1004 	addi	r2,r2,12352
 9091980:	10c00017 	ldw	r3,0(r2)
 9091984:	e0bff817 	ldw	r2,-32(fp)
 9091988:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 909198c:	00c24374 	movhi	r3,2317
 9091990:	18cc1004 	addi	r3,r3,12352
 9091994:	e0bff817 	ldw	r2,-32(fp)
 9091998:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 909199c:	e0bffb17 	ldw	r2,-20(fp)
 90919a0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 90919a4:	00824374 	movhi	r2,2317
 90919a8:	108c1204 	addi	r2,r2,12360
 90919ac:	10c00017 	ldw	r3,0(r2)
 90919b0:	e0bffb17 	ldw	r2,-20(fp)
 90919b4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 90919b8:	e0bffb17 	ldw	r2,-20(fp)
 90919bc:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 90919c0:	00c24374 	movhi	r3,2317
 90919c4:	18cc1204 	addi	r3,r3,12360
 90919c8:	e0bffb17 	ldw	r2,-20(fp)
 90919cc:	18800015 	stw	r2,0(r3)
 90919d0:	e0bff717 	ldw	r2,-36(fp)
 90919d4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90919d8:	e0bff517 	ldw	r2,-44(fp)
 90919dc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 90919e0:	e0bffd17 	ldw	r2,-12(fp)
 90919e4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 90919e8:	e03ff915 	stw	zero,-28(fp)
 90919ec:	00004706 	br	9091b0c <OSQDel+0x2e0>
 90919f0:	e0bff717 	ldw	r2,-36(fp)
 90919f4:	e0bff415 	stw	r2,-48(fp)
 90919f8:	e0bff417 	ldw	r2,-48(fp)
 90919fc:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 9091a00:	e0fffd17 	ldw	r3,-12(fp)
 9091a04:	00801244 	movi	r2,73
 9091a08:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 9091a0c:	e0bffb17 	ldw	r2,-20(fp)
 9091a10:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 9091a14:	00003d06 	br	9091b0c <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 9091a18:	e13ffb17 	ldw	r4,-20(fp)
 9091a1c:	000b883a 	mov	r5,zero
 9091a20:	01800104 	movi	r6,4
 9091a24:	000f883a 	mov	r7,zero
 9091a28:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 9091a2c:	e0bffb17 	ldw	r2,-20(fp)
 9091a30:	10800283 	ldbu	r2,10(r2)
 9091a34:	10803fcc 	andi	r2,r2,255
 9091a38:	1004c03a 	cmpne	r2,r2,zero
 9091a3c:	103ff61e 	bne	r2,zero,9091a18 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 9091a40:	e0fffb17 	ldw	r3,-20(fp)
 9091a44:	00800fc4 	movi	r2,63
 9091a48:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 9091a4c:	e0bffb17 	ldw	r2,-20(fp)
 9091a50:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 9091a54:	e0bffb17 	ldw	r2,-20(fp)
 9091a58:	10800117 	ldw	r2,4(r2)
 9091a5c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 9091a60:	00824374 	movhi	r2,2317
 9091a64:	108c1004 	addi	r2,r2,12352
 9091a68:	10c00017 	ldw	r3,0(r2)
 9091a6c:	e0bff817 	ldw	r2,-32(fp)
 9091a70:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 9091a74:	00c24374 	movhi	r3,2317
 9091a78:	18cc1004 	addi	r3,r3,12352
 9091a7c:	e0bff817 	ldw	r2,-32(fp)
 9091a80:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9091a84:	e0bffb17 	ldw	r2,-20(fp)
 9091a88:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 9091a8c:	00824374 	movhi	r2,2317
 9091a90:	108c1204 	addi	r2,r2,12360
 9091a94:	10c00017 	ldw	r3,0(r2)
 9091a98:	e0bffb17 	ldw	r2,-20(fp)
 9091a9c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 9091aa0:	e0bffb17 	ldw	r2,-20(fp)
 9091aa4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 9091aa8:	00c24374 	movhi	r3,2317
 9091aac:	18cc1204 	addi	r3,r3,12360
 9091ab0:	e0bffb17 	ldw	r2,-20(fp)
 9091ab4:	18800015 	stw	r2,0(r3)
 9091ab8:	e0bff717 	ldw	r2,-36(fp)
 9091abc:	e0bff315 	stw	r2,-52(fp)
 9091ac0:	e0bff317 	ldw	r2,-52(fp)
 9091ac4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 9091ac8:	e0bffa03 	ldbu	r2,-24(fp)
 9091acc:	10800058 	cmpnei	r2,r2,1
 9091ad0:	1000011e 	bne	r2,zero,9091ad8 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 9091ad4:	908eaf40 	call	908eaf4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 9091ad8:	e0bffd17 	ldw	r2,-12(fp)
 9091adc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 9091ae0:	e03ff915 	stw	zero,-28(fp)
             break;
 9091ae4:	00000906 	br	9091b0c <OSQDel+0x2e0>
 9091ae8:	e0bff717 	ldw	r2,-36(fp)
 9091aec:	e0bff215 	stw	r2,-56(fp)
 9091af0:	e0bff217 	ldw	r2,-56(fp)
 9091af4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 9091af8:	e0fffd17 	ldw	r3,-12(fp)
 9091afc:	008001c4 	movi	r2,7
 9091b00:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 9091b04:	e0bffb17 	ldw	r2,-20(fp)
 9091b08:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 9091b0c:	e0bff917 	ldw	r2,-28(fp)
 9091b10:	e0bfff15 	stw	r2,-4(fp)
 9091b14:	e0bfff17 	ldw	r2,-4(fp)
}
 9091b18:	e037883a 	mov	sp,fp
 9091b1c:	dfc00117 	ldw	ra,4(sp)
 9091b20:	df000017 	ldw	fp,0(sp)
 9091b24:	dec00204 	addi	sp,sp,8
 9091b28:	f800283a 	ret

09091b2c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 9091b2c:	defff904 	addi	sp,sp,-28
 9091b30:	df000615 	stw	fp,24(sp)
 9091b34:	df000604 	addi	fp,sp,24
 9091b38:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9091b3c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9091b40:	e0bffe17 	ldw	r2,-8(fp)
 9091b44:	1004c03a 	cmpne	r2,r2,zero
 9091b48:	1000031e 	bne	r2,zero,9091b58 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 9091b4c:	00800104 	movi	r2,4
 9091b50:	e0bfff15 	stw	r2,-4(fp)
 9091b54:	00002206 	br	9091be0 <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 9091b58:	e0bffe17 	ldw	r2,-8(fp)
 9091b5c:	10800003 	ldbu	r2,0(r2)
 9091b60:	10803fcc 	andi	r2,r2,255
 9091b64:	108000a0 	cmpeqi	r2,r2,2
 9091b68:	1000031e 	bne	r2,zero,9091b78 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 9091b6c:	00800044 	movi	r2,1
 9091b70:	e0bfff15 	stw	r2,-4(fp)
 9091b74:	00001a06 	br	9091be0 <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091b78:	0005303a 	rdctl	r2,status
 9091b7c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091b80:	e0fffb17 	ldw	r3,-20(fp)
 9091b84:	00bfff84 	movi	r2,-2
 9091b88:	1884703a 	and	r2,r3,r2
 9091b8c:	1001703a 	wrctl	status,r2
  
  return context;
 9091b90:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9091b94:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 9091b98:	e0bffe17 	ldw	r2,-8(fp)
 9091b9c:	10800117 	ldw	r2,4(r2)
 9091ba0:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 9091ba4:	e0bffd17 	ldw	r2,-12(fp)
 9091ba8:	10c00117 	ldw	r3,4(r2)
 9091bac:	e0bffd17 	ldw	r2,-12(fp)
 9091bb0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 9091bb4:	e0bffd17 	ldw	r2,-12(fp)
 9091bb8:	10c00117 	ldw	r3,4(r2)
 9091bbc:	e0bffd17 	ldw	r2,-12(fp)
 9091bc0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 9091bc4:	e0bffd17 	ldw	r2,-12(fp)
 9091bc8:	1000058d 	sth	zero,22(r2)
 9091bcc:	e0bffc17 	ldw	r2,-16(fp)
 9091bd0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091bd4:	e0bffa17 	ldw	r2,-24(fp)
 9091bd8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9091bdc:	e03fff15 	stw	zero,-4(fp)
 9091be0:	e0bfff17 	ldw	r2,-4(fp)
}
 9091be4:	e037883a 	mov	sp,fp
 9091be8:	df000017 	ldw	fp,0(sp)
 9091bec:	dec00104 	addi	sp,sp,4
 9091bf0:	f800283a 	ret

09091bf4 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 9091bf4:	defff104 	addi	sp,sp,-60
 9091bf8:	dfc00e15 	stw	ra,56(sp)
 9091bfc:	df000d15 	stw	fp,52(sp)
 9091c00:	df000d04 	addi	fp,sp,52
 9091c04:	e13ffb15 	stw	r4,-20(fp)
 9091c08:	e1bffd15 	stw	r6,-12(fp)
 9091c0c:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9091c10:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9091c14:	e0bffd17 	ldw	r2,-12(fp)
 9091c18:	1004c03a 	cmpne	r2,r2,zero
 9091c1c:	1000021e 	bne	r2,zero,9091c28 <OSQPend+0x34>
        return ((void *)0);
 9091c20:	e03fff15 	stw	zero,-4(fp)
 9091c24:	0000b506 	br	9091efc <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 9091c28:	e0bffb17 	ldw	r2,-20(fp)
 9091c2c:	1004c03a 	cmpne	r2,r2,zero
 9091c30:	1000051e 	bne	r2,zero,9091c48 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9091c34:	e0fffd17 	ldw	r3,-12(fp)
 9091c38:	00800104 	movi	r2,4
 9091c3c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091c40:	e03fff15 	stw	zero,-4(fp)
 9091c44:	0000ad06 	br	9091efc <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 9091c48:	e0bffb17 	ldw	r2,-20(fp)
 9091c4c:	10800003 	ldbu	r2,0(r2)
 9091c50:	10803fcc 	andi	r2,r2,255
 9091c54:	108000a0 	cmpeqi	r2,r2,2
 9091c58:	1000051e 	bne	r2,zero,9091c70 <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9091c5c:	e0fffd17 	ldw	r3,-12(fp)
 9091c60:	00800044 	movi	r2,1
 9091c64:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091c68:	e03fff15 	stw	zero,-4(fp)
 9091c6c:	0000a306 	br	9091efc <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 9091c70:	00824374 	movhi	r2,2317
 9091c74:	108c1304 	addi	r2,r2,12364
 9091c78:	10800003 	ldbu	r2,0(r2)
 9091c7c:	10803fcc 	andi	r2,r2,255
 9091c80:	1005003a 	cmpeq	r2,r2,zero
 9091c84:	1000051e 	bne	r2,zero,9091c9c <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 9091c88:	e0fffd17 	ldw	r3,-12(fp)
 9091c8c:	00800084 	movi	r2,2
 9091c90:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091c94:	e03fff15 	stw	zero,-4(fp)
 9091c98:	00009806 	br	9091efc <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 9091c9c:	00824374 	movhi	r2,2317
 9091ca0:	108c0504 	addi	r2,r2,12308
 9091ca4:	10800003 	ldbu	r2,0(r2)
 9091ca8:	10803fcc 	andi	r2,r2,255
 9091cac:	1005003a 	cmpeq	r2,r2,zero
 9091cb0:	1000051e 	bne	r2,zero,9091cc8 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 9091cb4:	e0fffd17 	ldw	r3,-12(fp)
 9091cb8:	00800344 	movi	r2,13
 9091cbc:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091cc0:	e03fff15 	stw	zero,-4(fp)
 9091cc4:	00008d06 	br	9091efc <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091cc8:	0005303a 	rdctl	r2,status
 9091ccc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091cd0:	e0fff717 	ldw	r3,-36(fp)
 9091cd4:	00bfff84 	movi	r2,-2
 9091cd8:	1884703a 	and	r2,r3,r2
 9091cdc:	1001703a 	wrctl	status,r2
  
  return context;
 9091ce0:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9091ce4:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 9091ce8:	e0bffb17 	ldw	r2,-20(fp)
 9091cec:	10800117 	ldw	r2,4(r2)
 9091cf0:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 9091cf4:	e0bff917 	ldw	r2,-28(fp)
 9091cf8:	1080058b 	ldhu	r2,22(r2)
 9091cfc:	10bfffcc 	andi	r2,r2,65535
 9091d00:	1005003a 	cmpeq	r2,r2,zero
 9091d04:	10001f1e 	bne	r2,zero,9091d84 <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 9091d08:	e0bff917 	ldw	r2,-28(fp)
 9091d0c:	10c00417 	ldw	r3,16(r2)
 9091d10:	18800017 	ldw	r2,0(r3)
 9091d14:	e0bffa15 	stw	r2,-24(fp)
 9091d18:	18c00104 	addi	r3,r3,4
 9091d1c:	e0bff917 	ldw	r2,-28(fp)
 9091d20:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 9091d24:	e0bff917 	ldw	r2,-28(fp)
 9091d28:	1080058b 	ldhu	r2,22(r2)
 9091d2c:	10bfffc4 	addi	r2,r2,-1
 9091d30:	1007883a 	mov	r3,r2
 9091d34:	e0bff917 	ldw	r2,-28(fp)
 9091d38:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 9091d3c:	e0bff917 	ldw	r2,-28(fp)
 9091d40:	10c00417 	ldw	r3,16(r2)
 9091d44:	e0bff917 	ldw	r2,-28(fp)
 9091d48:	10800217 	ldw	r2,8(r2)
 9091d4c:	1880041e 	bne	r3,r2,9091d60 <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 9091d50:	e0bff917 	ldw	r2,-28(fp)
 9091d54:	10c00117 	ldw	r3,4(r2)
 9091d58:	e0bff917 	ldw	r2,-28(fp)
 9091d5c:	10c00415 	stw	r3,16(r2)
 9091d60:	e0bff817 	ldw	r2,-32(fp)
 9091d64:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091d68:	e0bff617 	ldw	r2,-40(fp)
 9091d6c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 9091d70:	e0bffd17 	ldw	r2,-12(fp)
 9091d74:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 9091d78:	e0bffa17 	ldw	r2,-24(fp)
 9091d7c:	e0bfff15 	stw	r2,-4(fp)
 9091d80:	00005e06 	br	9091efc <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 9091d84:	00824374 	movhi	r2,2317
 9091d88:	108c1404 	addi	r2,r2,12368
 9091d8c:	10c00017 	ldw	r3,0(r2)
 9091d90:	00824374 	movhi	r2,2317
 9091d94:	108c1404 	addi	r2,r2,12368
 9091d98:	10800017 	ldw	r2,0(r2)
 9091d9c:	10800c03 	ldbu	r2,48(r2)
 9091da0:	10800114 	ori	r2,r2,4
 9091da4:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9091da8:	00824374 	movhi	r2,2317
 9091dac:	108c1404 	addi	r2,r2,12368
 9091db0:	10800017 	ldw	r2,0(r2)
 9091db4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 9091db8:	00824374 	movhi	r2,2317
 9091dbc:	108c1404 	addi	r2,r2,12368
 9091dc0:	10c00017 	ldw	r3,0(r2)
 9091dc4:	e0bffc0b 	ldhu	r2,-16(fp)
 9091dc8:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 9091dcc:	e13ffb17 	ldw	r4,-20(fp)
 9091dd0:	908e2480 	call	908e248 <OS_EventTaskWait>
 9091dd4:	e0bff817 	ldw	r2,-32(fp)
 9091dd8:	e0bff515 	stw	r2,-44(fp)
 9091ddc:	e0bff517 	ldw	r2,-44(fp)
 9091de0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 9091de4:	908eaf40 	call	908eaf4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091de8:	0005303a 	rdctl	r2,status
 9091dec:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091df0:	e0fff417 	ldw	r3,-48(fp)
 9091df4:	00bfff84 	movi	r2,-2
 9091df8:	1884703a 	and	r2,r3,r2
 9091dfc:	1001703a 	wrctl	status,r2
  
  return context;
 9091e00:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 9091e04:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 9091e08:	00824374 	movhi	r2,2317
 9091e0c:	108c1404 	addi	r2,r2,12368
 9091e10:	10800017 	ldw	r2,0(r2)
 9091e14:	10800c43 	ldbu	r2,49(r2)
 9091e18:	10803fcc 	andi	r2,r2,255
 9091e1c:	e0bffe15 	stw	r2,-8(fp)
 9091e20:	e0fffe17 	ldw	r3,-8(fp)
 9091e24:	1805003a 	cmpeq	r2,r3,zero
 9091e28:	1000041e 	bne	r2,zero,9091e3c <OSQPend+0x248>
 9091e2c:	e0fffe17 	ldw	r3,-8(fp)
 9091e30:	188000a0 	cmpeqi	r2,r3,2
 9091e34:	1000091e 	bne	r2,zero,9091e5c <OSQPend+0x268>
 9091e38:	00000d06 	br	9091e70 <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 9091e3c:	00824374 	movhi	r2,2317
 9091e40:	108c1404 	addi	r2,r2,12368
 9091e44:	10800017 	ldw	r2,0(r2)
 9091e48:	10800917 	ldw	r2,36(r2)
 9091e4c:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 9091e50:	e0bffd17 	ldw	r2,-12(fp)
 9091e54:	10000005 	stb	zero,0(r2)
             break;
 9091e58:	00000e06 	br	9091e94 <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 9091e5c:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 9091e60:	e0fffd17 	ldw	r3,-12(fp)
 9091e64:	00800384 	movi	r2,14
 9091e68:	18800005 	stb	r2,0(r3)
             break;
 9091e6c:	00000906 	br	9091e94 <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 9091e70:	00824374 	movhi	r2,2317
 9091e74:	108c1404 	addi	r2,r2,12368
 9091e78:	11000017 	ldw	r4,0(r2)
 9091e7c:	e17ffb17 	ldw	r5,-20(fp)
 9091e80:	908e4ac0 	call	908e4ac <OS_EventTaskRemove>
             pmsg = (void *)0;
 9091e84:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 9091e88:	e0fffd17 	ldw	r3,-12(fp)
 9091e8c:	00800284 	movi	r2,10
 9091e90:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 9091e94:	00824374 	movhi	r2,2317
 9091e98:	108c1404 	addi	r2,r2,12368
 9091e9c:	10800017 	ldw	r2,0(r2)
 9091ea0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 9091ea4:	00824374 	movhi	r2,2317
 9091ea8:	108c1404 	addi	r2,r2,12368
 9091eac:	10800017 	ldw	r2,0(r2)
 9091eb0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 9091eb4:	00824374 	movhi	r2,2317
 9091eb8:	108c1404 	addi	r2,r2,12368
 9091ebc:	10800017 	ldw	r2,0(r2)
 9091ec0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 9091ec4:	00824374 	movhi	r2,2317
 9091ec8:	108c1404 	addi	r2,r2,12368
 9091ecc:	10800017 	ldw	r2,0(r2)
 9091ed0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 9091ed4:	00824374 	movhi	r2,2317
 9091ed8:	108c1404 	addi	r2,r2,12368
 9091edc:	10800017 	ldw	r2,0(r2)
 9091ee0:	10000915 	stw	zero,36(r2)
 9091ee4:	e0bff817 	ldw	r2,-32(fp)
 9091ee8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091eec:	e0bff317 	ldw	r2,-52(fp)
 9091ef0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 9091ef4:	e0bffa17 	ldw	r2,-24(fp)
 9091ef8:	e0bfff15 	stw	r2,-4(fp)
 9091efc:	e0bfff17 	ldw	r2,-4(fp)
}
 9091f00:	e037883a 	mov	sp,fp
 9091f04:	dfc00117 	ldw	ra,4(sp)
 9091f08:	df000017 	ldw	fp,0(sp)
 9091f0c:	dec00204 	addi	sp,sp,8
 9091f10:	f800283a 	ret

09091f14 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 9091f14:	defff504 	addi	sp,sp,-44
 9091f18:	dfc00a15 	stw	ra,40(sp)
 9091f1c:	df000915 	stw	fp,36(sp)
 9091f20:	df000904 	addi	fp,sp,36
 9091f24:	e13ffc15 	stw	r4,-16(fp)
 9091f28:	e1bffe15 	stw	r6,-8(fp)
 9091f2c:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 9091f30:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 9091f34:	e0bffe17 	ldw	r2,-8(fp)
 9091f38:	1004c03a 	cmpne	r2,r2,zero
 9091f3c:	1000021e 	bne	r2,zero,9091f48 <OSQPendAbort+0x34>
        return (0);
 9091f40:	e03fff15 	stw	zero,-4(fp)
 9091f44:	00004c06 	br	9092078 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9091f48:	e0bffc17 	ldw	r2,-16(fp)
 9091f4c:	1004c03a 	cmpne	r2,r2,zero
 9091f50:	1000051e 	bne	r2,zero,9091f68 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9091f54:	e0fffe17 	ldw	r3,-8(fp)
 9091f58:	00800104 	movi	r2,4
 9091f5c:	18800005 	stb	r2,0(r3)
        return (0);
 9091f60:	e03fff15 	stw	zero,-4(fp)
 9091f64:	00004406 	br	9092078 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 9091f68:	e0bffc17 	ldw	r2,-16(fp)
 9091f6c:	10800003 	ldbu	r2,0(r2)
 9091f70:	10803fcc 	andi	r2,r2,255
 9091f74:	108000a0 	cmpeqi	r2,r2,2
 9091f78:	1000051e 	bne	r2,zero,9091f90 <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9091f7c:	e0fffe17 	ldw	r3,-8(fp)
 9091f80:	00800044 	movi	r2,1
 9091f84:	18800005 	stb	r2,0(r3)
        return (0);
 9091f88:	e03fff15 	stw	zero,-4(fp)
 9091f8c:	00003a06 	br	9092078 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091f90:	0005303a 	rdctl	r2,status
 9091f94:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091f98:	e0fff917 	ldw	r3,-28(fp)
 9091f9c:	00bfff84 	movi	r2,-2
 9091fa0:	1884703a 	and	r2,r3,r2
 9091fa4:	1001703a 	wrctl	status,r2
  
  return context;
 9091fa8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9091fac:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 9091fb0:	e0bffc17 	ldw	r2,-16(fp)
 9091fb4:	10800283 	ldbu	r2,10(r2)
 9091fb8:	10803fcc 	andi	r2,r2,255
 9091fbc:	1005003a 	cmpeq	r2,r2,zero
 9091fc0:	1000261e 	bne	r2,zero,909205c <OSQPendAbort+0x148>
        nbr_tasks = 0;
 9091fc4:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 9091fc8:	e0bffd03 	ldbu	r2,-12(fp)
 9091fcc:	10800060 	cmpeqi	r2,r2,1
 9091fd0:	1000091e 	bne	r2,zero,9091ff8 <OSQPendAbort+0xe4>
 9091fd4:	00000e06 	br	9092010 <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 9091fd8:	e13ffc17 	ldw	r4,-16(fp)
 9091fdc:	000b883a 	mov	r5,zero
 9091fe0:	01800104 	movi	r6,4
 9091fe4:	01c00084 	movi	r7,2
 9091fe8:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                     nbr_tasks++;
 9091fec:	e0bffb03 	ldbu	r2,-20(fp)
 9091ff0:	10800044 	addi	r2,r2,1
 9091ff4:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 9091ff8:	e0bffc17 	ldw	r2,-16(fp)
 9091ffc:	10800283 	ldbu	r2,10(r2)
 9092000:	10803fcc 	andi	r2,r2,255
 9092004:	1004c03a 	cmpne	r2,r2,zero
 9092008:	103ff31e 	bne	r2,zero,9091fd8 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 909200c:	00000806 	br	9092030 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 9092010:	e13ffc17 	ldw	r4,-16(fp)
 9092014:	000b883a 	mov	r5,zero
 9092018:	01800104 	movi	r6,4
 909201c:	01c00084 	movi	r7,2
 9092020:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                 nbr_tasks++;
 9092024:	e0bffb03 	ldbu	r2,-20(fp)
 9092028:	10800044 	addi	r2,r2,1
 909202c:	e0bffb05 	stb	r2,-20(fp)
 9092030:	e0bffa17 	ldw	r2,-24(fp)
 9092034:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092038:	e0bff817 	ldw	r2,-32(fp)
 909203c:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 9092040:	908eaf40 	call	908eaf4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 9092044:	e0fffe17 	ldw	r3,-8(fp)
 9092048:	00800384 	movi	r2,14
 909204c:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 9092050:	e0bffb03 	ldbu	r2,-20(fp)
 9092054:	e0bfff15 	stw	r2,-4(fp)
 9092058:	00000706 	br	9092078 <OSQPendAbort+0x164>
 909205c:	e0bffa17 	ldw	r2,-24(fp)
 9092060:	e0bff715 	stw	r2,-36(fp)
 9092064:	e0bff717 	ldw	r2,-36(fp)
 9092068:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 909206c:	e0bffe17 	ldw	r2,-8(fp)
 9092070:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 9092074:	e03fff15 	stw	zero,-4(fp)
 9092078:	e0bfff17 	ldw	r2,-4(fp)
}
 909207c:	e037883a 	mov	sp,fp
 9092080:	dfc00117 	ldw	ra,4(sp)
 9092084:	df000017 	ldw	fp,0(sp)
 9092088:	dec00204 	addi	sp,sp,8
 909208c:	f800283a 	ret

09092090 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 9092090:	defff504 	addi	sp,sp,-44
 9092094:	dfc00a15 	stw	ra,40(sp)
 9092098:	df000915 	stw	fp,36(sp)
 909209c:	df000904 	addi	fp,sp,36
 90920a0:	e13ffd15 	stw	r4,-12(fp)
 90920a4:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 90920a8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 90920ac:	e0bffd17 	ldw	r2,-12(fp)
 90920b0:	1004c03a 	cmpne	r2,r2,zero
 90920b4:	1000031e 	bne	r2,zero,90920c4 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 90920b8:	00800104 	movi	r2,4
 90920bc:	e0bfff15 	stw	r2,-4(fp)
 90920c0:	00004d06 	br	90921f8 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 90920c4:	e0bffd17 	ldw	r2,-12(fp)
 90920c8:	10800003 	ldbu	r2,0(r2)
 90920cc:	10803fcc 	andi	r2,r2,255
 90920d0:	108000a0 	cmpeqi	r2,r2,2
 90920d4:	1000031e 	bne	r2,zero,90920e4 <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 90920d8:	00800044 	movi	r2,1
 90920dc:	e0bfff15 	stw	r2,-4(fp)
 90920e0:	00004506 	br	90921f8 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90920e4:	0005303a 	rdctl	r2,status
 90920e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90920ec:	e0fffa17 	ldw	r3,-24(fp)
 90920f0:	00bfff84 	movi	r2,-2
 90920f4:	1884703a 	and	r2,r3,r2
 90920f8:	1001703a 	wrctl	status,r2
  
  return context;
 90920fc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9092100:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 9092104:	e0bffd17 	ldw	r2,-12(fp)
 9092108:	10800283 	ldbu	r2,10(r2)
 909210c:	10803fcc 	andi	r2,r2,255
 9092110:	1005003a 	cmpeq	r2,r2,zero
 9092114:	10000c1e 	bne	r2,zero,9092148 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9092118:	e13ffd17 	ldw	r4,-12(fp)
 909211c:	e17ffe17 	ldw	r5,-8(fp)
 9092120:	01800104 	movi	r6,4
 9092124:	000f883a 	mov	r7,zero
 9092128:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
 909212c:	e0bffb17 	ldw	r2,-20(fp)
 9092130:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092134:	e0bff917 	ldw	r2,-28(fp)
 9092138:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 909213c:	908eaf40 	call	908eaf4 <OS_Sched>
        return (OS_ERR_NONE);
 9092140:	e03fff15 	stw	zero,-4(fp)
 9092144:	00002c06 	br	90921f8 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 9092148:	e0bffd17 	ldw	r2,-12(fp)
 909214c:	10800117 	ldw	r2,4(r2)
 9092150:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 9092154:	e0bffc17 	ldw	r2,-16(fp)
 9092158:	10c0058b 	ldhu	r3,22(r2)
 909215c:	e0bffc17 	ldw	r2,-16(fp)
 9092160:	1080050b 	ldhu	r2,20(r2)
 9092164:	18ffffcc 	andi	r3,r3,65535
 9092168:	10bfffcc 	andi	r2,r2,65535
 909216c:	18800736 	bltu	r3,r2,909218c <OSQPost+0xfc>
 9092170:	e0bffb17 	ldw	r2,-20(fp)
 9092174:	e0bff815 	stw	r2,-32(fp)
 9092178:	e0bff817 	ldw	r2,-32(fp)
 909217c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 9092180:	00800784 	movi	r2,30
 9092184:	e0bfff15 	stw	r2,-4(fp)
 9092188:	00001b06 	br	90921f8 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 909218c:	e0bffc17 	ldw	r2,-16(fp)
 9092190:	10c00317 	ldw	r3,12(r2)
 9092194:	e0bffe17 	ldw	r2,-8(fp)
 9092198:	18800015 	stw	r2,0(r3)
 909219c:	18c00104 	addi	r3,r3,4
 90921a0:	e0bffc17 	ldw	r2,-16(fp)
 90921a4:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 90921a8:	e0bffc17 	ldw	r2,-16(fp)
 90921ac:	1080058b 	ldhu	r2,22(r2)
 90921b0:	10800044 	addi	r2,r2,1
 90921b4:	1007883a 	mov	r3,r2
 90921b8:	e0bffc17 	ldw	r2,-16(fp)
 90921bc:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 90921c0:	e0bffc17 	ldw	r2,-16(fp)
 90921c4:	10c00317 	ldw	r3,12(r2)
 90921c8:	e0bffc17 	ldw	r2,-16(fp)
 90921cc:	10800217 	ldw	r2,8(r2)
 90921d0:	1880041e 	bne	r3,r2,90921e4 <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 90921d4:	e0bffc17 	ldw	r2,-16(fp)
 90921d8:	10c00117 	ldw	r3,4(r2)
 90921dc:	e0bffc17 	ldw	r2,-16(fp)
 90921e0:	10c00315 	stw	r3,12(r2)
 90921e4:	e0bffb17 	ldw	r2,-20(fp)
 90921e8:	e0bff715 	stw	r2,-36(fp)
 90921ec:	e0bff717 	ldw	r2,-36(fp)
 90921f0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 90921f4:	e03fff15 	stw	zero,-4(fp)
 90921f8:	e0bfff17 	ldw	r2,-4(fp)
}
 90921fc:	e037883a 	mov	sp,fp
 9092200:	dfc00117 	ldw	ra,4(sp)
 9092204:	df000017 	ldw	fp,0(sp)
 9092208:	dec00204 	addi	sp,sp,8
 909220c:	f800283a 	ret

09092210 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 9092210:	defff504 	addi	sp,sp,-44
 9092214:	dfc00a15 	stw	ra,40(sp)
 9092218:	df000915 	stw	fp,36(sp)
 909221c:	df000904 	addi	fp,sp,36
 9092220:	e13ffd15 	stw	r4,-12(fp)
 9092224:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9092228:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 909222c:	e0bffd17 	ldw	r2,-12(fp)
 9092230:	1004c03a 	cmpne	r2,r2,zero
 9092234:	1000031e 	bne	r2,zero,9092244 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 9092238:	00800104 	movi	r2,4
 909223c:	e0bfff15 	stw	r2,-4(fp)
 9092240:	00004f06 	br	9092380 <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 9092244:	e0bffd17 	ldw	r2,-12(fp)
 9092248:	10800003 	ldbu	r2,0(r2)
 909224c:	10803fcc 	andi	r2,r2,255
 9092250:	108000a0 	cmpeqi	r2,r2,2
 9092254:	1000031e 	bne	r2,zero,9092264 <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 9092258:	00800044 	movi	r2,1
 909225c:	e0bfff15 	stw	r2,-4(fp)
 9092260:	00004706 	br	9092380 <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092264:	0005303a 	rdctl	r2,status
 9092268:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909226c:	e0fffa17 	ldw	r3,-24(fp)
 9092270:	00bfff84 	movi	r2,-2
 9092274:	1884703a 	and	r2,r3,r2
 9092278:	1001703a 	wrctl	status,r2
  
  return context;
 909227c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9092280:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 9092284:	e0bffd17 	ldw	r2,-12(fp)
 9092288:	10800283 	ldbu	r2,10(r2)
 909228c:	10803fcc 	andi	r2,r2,255
 9092290:	1005003a 	cmpeq	r2,r2,zero
 9092294:	10000c1e 	bne	r2,zero,90922c8 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9092298:	e13ffd17 	ldw	r4,-12(fp)
 909229c:	e17ffe17 	ldw	r5,-8(fp)
 90922a0:	01800104 	movi	r6,4
 90922a4:	000f883a 	mov	r7,zero
 90922a8:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
 90922ac:	e0bffb17 	ldw	r2,-20(fp)
 90922b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90922b4:	e0bff917 	ldw	r2,-28(fp)
 90922b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 90922bc:	908eaf40 	call	908eaf4 <OS_Sched>
        return (OS_ERR_NONE);
 90922c0:	e03fff15 	stw	zero,-4(fp)
 90922c4:	00002e06 	br	9092380 <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 90922c8:	e0bffd17 	ldw	r2,-12(fp)
 90922cc:	10800117 	ldw	r2,4(r2)
 90922d0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 90922d4:	e0bffc17 	ldw	r2,-16(fp)
 90922d8:	10c0058b 	ldhu	r3,22(r2)
 90922dc:	e0bffc17 	ldw	r2,-16(fp)
 90922e0:	1080050b 	ldhu	r2,20(r2)
 90922e4:	18ffffcc 	andi	r3,r3,65535
 90922e8:	10bfffcc 	andi	r2,r2,65535
 90922ec:	18800736 	bltu	r3,r2,909230c <OSQPostFront+0xfc>
 90922f0:	e0bffb17 	ldw	r2,-20(fp)
 90922f4:	e0bff815 	stw	r2,-32(fp)
 90922f8:	e0bff817 	ldw	r2,-32(fp)
 90922fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 9092300:	00800784 	movi	r2,30
 9092304:	e0bfff15 	stw	r2,-4(fp)
 9092308:	00001d06 	br	9092380 <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 909230c:	e0bffc17 	ldw	r2,-16(fp)
 9092310:	10c00417 	ldw	r3,16(r2)
 9092314:	e0bffc17 	ldw	r2,-16(fp)
 9092318:	10800117 	ldw	r2,4(r2)
 909231c:	1880041e 	bne	r3,r2,9092330 <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 9092320:	e0bffc17 	ldw	r2,-16(fp)
 9092324:	10c00217 	ldw	r3,8(r2)
 9092328:	e0bffc17 	ldw	r2,-16(fp)
 909232c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 9092330:	e0bffc17 	ldw	r2,-16(fp)
 9092334:	10800417 	ldw	r2,16(r2)
 9092338:	10ffff04 	addi	r3,r2,-4
 909233c:	e0bffc17 	ldw	r2,-16(fp)
 9092340:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 9092344:	e0bffc17 	ldw	r2,-16(fp)
 9092348:	10c00417 	ldw	r3,16(r2)
 909234c:	e0bffe17 	ldw	r2,-8(fp)
 9092350:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 9092354:	e0bffc17 	ldw	r2,-16(fp)
 9092358:	1080058b 	ldhu	r2,22(r2)
 909235c:	10800044 	addi	r2,r2,1
 9092360:	1007883a 	mov	r3,r2
 9092364:	e0bffc17 	ldw	r2,-16(fp)
 9092368:	10c0058d 	sth	r3,22(r2)
 909236c:	e0bffb17 	ldw	r2,-20(fp)
 9092370:	e0bff715 	stw	r2,-36(fp)
 9092374:	e0bff717 	ldw	r2,-36(fp)
 9092378:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 909237c:	e03fff15 	stw	zero,-4(fp)
 9092380:	e0bfff17 	ldw	r2,-4(fp)
}
 9092384:	e037883a 	mov	sp,fp
 9092388:	dfc00117 	ldw	ra,4(sp)
 909238c:	df000017 	ldw	fp,0(sp)
 9092390:	dec00204 	addi	sp,sp,8
 9092394:	f800283a 	ret

09092398 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 9092398:	defff404 	addi	sp,sp,-48
 909239c:	dfc00b15 	stw	ra,44(sp)
 90923a0:	df000a15 	stw	fp,40(sp)
 90923a4:	df000a04 	addi	fp,sp,40
 90923a8:	e13ffc15 	stw	r4,-16(fp)
 90923ac:	e17ffd15 	stw	r5,-12(fp)
 90923b0:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90923b4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 90923b8:	e0bffc17 	ldw	r2,-16(fp)
 90923bc:	1004c03a 	cmpne	r2,r2,zero
 90923c0:	1000031e 	bne	r2,zero,90923d0 <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 90923c4:	00800104 	movi	r2,4
 90923c8:	e0bfff15 	stw	r2,-4(fp)
 90923cc:	00007906 	br	90925b4 <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 90923d0:	e0bffc17 	ldw	r2,-16(fp)
 90923d4:	10800003 	ldbu	r2,0(r2)
 90923d8:	10803fcc 	andi	r2,r2,255
 90923dc:	108000a0 	cmpeqi	r2,r2,2
 90923e0:	1000031e 	bne	r2,zero,90923f0 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 90923e4:	00800044 	movi	r2,1
 90923e8:	e0bfff15 	stw	r2,-4(fp)
 90923ec:	00007106 	br	90925b4 <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90923f0:	0005303a 	rdctl	r2,status
 90923f4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90923f8:	e0fff917 	ldw	r3,-28(fp)
 90923fc:	00bfff84 	movi	r2,-2
 9092400:	1884703a 	and	r2,r3,r2
 9092404:	1001703a 	wrctl	status,r2
  
  return context;
 9092408:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 909240c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 9092410:	e0bffc17 	ldw	r2,-16(fp)
 9092414:	10800283 	ldbu	r2,10(r2)
 9092418:	10803fcc 	andi	r2,r2,255
 909241c:	1005003a 	cmpeq	r2,r2,zero
 9092420:	1000211e 	bne	r2,zero,90924a8 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 9092424:	e0bffe03 	ldbu	r2,-8(fp)
 9092428:	1080004c 	andi	r2,r2,1
 909242c:	10803fcc 	andi	r2,r2,255
 9092430:	1005003a 	cmpeq	r2,r2,zero
 9092434:	10000c1e 	bne	r2,zero,9092468 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 9092438:	00000506 	br	9092450 <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 909243c:	e13ffc17 	ldw	r4,-16(fp)
 9092440:	e17ffd17 	ldw	r5,-12(fp)
 9092444:	01800104 	movi	r6,4
 9092448:	000f883a 	mov	r7,zero
 909244c:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 9092450:	e0bffc17 	ldw	r2,-16(fp)
 9092454:	10800283 	ldbu	r2,10(r2)
 9092458:	10803fcc 	andi	r2,r2,255
 909245c:	1004c03a 	cmpne	r2,r2,zero
 9092460:	103ff61e 	bne	r2,zero,909243c <OSQPostOpt+0xa4>
 9092464:	00000506 	br	909247c <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9092468:	e13ffc17 	ldw	r4,-16(fp)
 909246c:	e17ffd17 	ldw	r5,-12(fp)
 9092470:	01800104 	movi	r6,4
 9092474:	000f883a 	mov	r7,zero
 9092478:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
 909247c:	e0bffa17 	ldw	r2,-24(fp)
 9092480:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092484:	e0bff817 	ldw	r2,-32(fp)
 9092488:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 909248c:	e0bffe03 	ldbu	r2,-8(fp)
 9092490:	1080010c 	andi	r2,r2,4
 9092494:	1004c03a 	cmpne	r2,r2,zero
 9092498:	1000011e 	bne	r2,zero,90924a0 <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 909249c:	908eaf40 	call	908eaf4 <OS_Sched>
        }
        return (OS_ERR_NONE);
 90924a0:	e03fff15 	stw	zero,-4(fp)
 90924a4:	00004306 	br	90925b4 <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 90924a8:	e0bffc17 	ldw	r2,-16(fp)
 90924ac:	10800117 	ldw	r2,4(r2)
 90924b0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 90924b4:	e0bffb17 	ldw	r2,-20(fp)
 90924b8:	10c0058b 	ldhu	r3,22(r2)
 90924bc:	e0bffb17 	ldw	r2,-20(fp)
 90924c0:	1080050b 	ldhu	r2,20(r2)
 90924c4:	18ffffcc 	andi	r3,r3,65535
 90924c8:	10bfffcc 	andi	r2,r2,65535
 90924cc:	18800736 	bltu	r3,r2,90924ec <OSQPostOpt+0x154>
 90924d0:	e0bffa17 	ldw	r2,-24(fp)
 90924d4:	e0bff715 	stw	r2,-36(fp)
 90924d8:	e0bff717 	ldw	r2,-36(fp)
 90924dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 90924e0:	00800784 	movi	r2,30
 90924e4:	e0bfff15 	stw	r2,-4(fp)
 90924e8:	00003206 	br	90925b4 <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 90924ec:	e0bffe03 	ldbu	r2,-8(fp)
 90924f0:	1080008c 	andi	r2,r2,2
 90924f4:	1005003a 	cmpeq	r2,r2,zero
 90924f8:	1000131e 	bne	r2,zero,9092548 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 90924fc:	e0bffb17 	ldw	r2,-20(fp)
 9092500:	10c00417 	ldw	r3,16(r2)
 9092504:	e0bffb17 	ldw	r2,-20(fp)
 9092508:	10800117 	ldw	r2,4(r2)
 909250c:	1880041e 	bne	r3,r2,9092520 <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 9092510:	e0bffb17 	ldw	r2,-20(fp)
 9092514:	10c00217 	ldw	r3,8(r2)
 9092518:	e0bffb17 	ldw	r2,-20(fp)
 909251c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 9092520:	e0bffb17 	ldw	r2,-20(fp)
 9092524:	10800417 	ldw	r2,16(r2)
 9092528:	10ffff04 	addi	r3,r2,-4
 909252c:	e0bffb17 	ldw	r2,-20(fp)
 9092530:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 9092534:	e0bffb17 	ldw	r2,-20(fp)
 9092538:	10c00417 	ldw	r3,16(r2)
 909253c:	e0bffd17 	ldw	r2,-12(fp)
 9092540:	18800015 	stw	r2,0(r3)
 9092544:	00001006 	br	9092588 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 9092548:	e0bffb17 	ldw	r2,-20(fp)
 909254c:	10c00317 	ldw	r3,12(r2)
 9092550:	e0bffd17 	ldw	r2,-12(fp)
 9092554:	18800015 	stw	r2,0(r3)
 9092558:	18c00104 	addi	r3,r3,4
 909255c:	e0bffb17 	ldw	r2,-20(fp)
 9092560:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 9092564:	e0bffb17 	ldw	r2,-20(fp)
 9092568:	10c00317 	ldw	r3,12(r2)
 909256c:	e0bffb17 	ldw	r2,-20(fp)
 9092570:	10800217 	ldw	r2,8(r2)
 9092574:	1880041e 	bne	r3,r2,9092588 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 9092578:	e0bffb17 	ldw	r2,-20(fp)
 909257c:	10c00117 	ldw	r3,4(r2)
 9092580:	e0bffb17 	ldw	r2,-20(fp)
 9092584:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 9092588:	e0bffb17 	ldw	r2,-20(fp)
 909258c:	1080058b 	ldhu	r2,22(r2)
 9092590:	10800044 	addi	r2,r2,1
 9092594:	1007883a 	mov	r3,r2
 9092598:	e0bffb17 	ldw	r2,-20(fp)
 909259c:	10c0058d 	sth	r3,22(r2)
 90925a0:	e0bffa17 	ldw	r2,-24(fp)
 90925a4:	e0bff615 	stw	r2,-40(fp)
 90925a8:	e0bff617 	ldw	r2,-40(fp)
 90925ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 90925b0:	e03fff15 	stw	zero,-4(fp)
 90925b4:	e0bfff17 	ldw	r2,-4(fp)
}
 90925b8:	e037883a 	mov	sp,fp
 90925bc:	dfc00117 	ldw	ra,4(sp)
 90925c0:	df000017 	ldw	fp,0(sp)
 90925c4:	dec00204 	addi	sp,sp,8
 90925c8:	f800283a 	ret

090925cc <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 90925cc:	defff504 	addi	sp,sp,-44
 90925d0:	df000a15 	stw	fp,40(sp)
 90925d4:	df000a04 	addi	fp,sp,40
 90925d8:	e13ffd15 	stw	r4,-12(fp)
 90925dc:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 90925e0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 90925e4:	e0bffd17 	ldw	r2,-12(fp)
 90925e8:	1004c03a 	cmpne	r2,r2,zero
 90925ec:	1000031e 	bne	r2,zero,90925fc <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 90925f0:	00800104 	movi	r2,4
 90925f4:	e0bfff15 	stw	r2,-4(fp)
 90925f8:	00004f06 	br	9092738 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 90925fc:	e0bffe17 	ldw	r2,-8(fp)
 9092600:	1004c03a 	cmpne	r2,r2,zero
 9092604:	1000031e 	bne	r2,zero,9092614 <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 9092608:	00800244 	movi	r2,9
 909260c:	e0bfff15 	stw	r2,-4(fp)
 9092610:	00004906 	br	9092738 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 9092614:	e0bffd17 	ldw	r2,-12(fp)
 9092618:	10800003 	ldbu	r2,0(r2)
 909261c:	10803fcc 	andi	r2,r2,255
 9092620:	108000a0 	cmpeqi	r2,r2,2
 9092624:	1000031e 	bne	r2,zero,9092634 <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 9092628:	00800044 	movi	r2,1
 909262c:	e0bfff15 	stw	r2,-4(fp)
 9092630:	00004106 	br	9092738 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092634:	0005303a 	rdctl	r2,status
 9092638:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909263c:	e0fff717 	ldw	r3,-36(fp)
 9092640:	00bfff84 	movi	r2,-2
 9092644:	1884703a 	and	r2,r3,r2
 9092648:	1001703a 	wrctl	status,r2
  
  return context;
 909264c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9092650:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 9092654:	e0bffd17 	ldw	r2,-12(fp)
 9092658:	10c00283 	ldbu	r3,10(r2)
 909265c:	e0bffe17 	ldw	r2,-8(fp)
 9092660:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 9092664:	e0bffd17 	ldw	r2,-12(fp)
 9092668:	108002c4 	addi	r2,r2,11
 909266c:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 9092670:	e0bffe17 	ldw	r2,-8(fp)
 9092674:	10800204 	addi	r2,r2,8
 9092678:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909267c:	e03ffb05 	stb	zero,-20(fp)
 9092680:	00000d06 	br	90926b8 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 9092684:	e0bffa17 	ldw	r2,-24(fp)
 9092688:	10c00003 	ldbu	r3,0(r2)
 909268c:	e0bff917 	ldw	r2,-28(fp)
 9092690:	10c00005 	stb	r3,0(r2)
 9092694:	e0bff917 	ldw	r2,-28(fp)
 9092698:	10800044 	addi	r2,r2,1
 909269c:	e0bff915 	stw	r2,-28(fp)
 90926a0:	e0bffa17 	ldw	r2,-24(fp)
 90926a4:	10800044 	addi	r2,r2,1
 90926a8:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 90926ac:	e0bffb03 	ldbu	r2,-20(fp)
 90926b0:	10800044 	addi	r2,r2,1
 90926b4:	e0bffb05 	stb	r2,-20(fp)
 90926b8:	e0bffb03 	ldbu	r2,-20(fp)
 90926bc:	108000f0 	cmpltui	r2,r2,3
 90926c0:	103ff01e 	bne	r2,zero,9092684 <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 90926c4:	e0bffd17 	ldw	r2,-12(fp)
 90926c8:	10800117 	ldw	r2,4(r2)
 90926cc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 90926d0:	e0bffc17 	ldw	r2,-16(fp)
 90926d4:	1080058b 	ldhu	r2,22(r2)
 90926d8:	10bfffcc 	andi	r2,r2,65535
 90926dc:	1005003a 	cmpeq	r2,r2,zero
 90926e0:	1000061e 	bne	r2,zero,90926fc <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 90926e4:	e0bffc17 	ldw	r2,-16(fp)
 90926e8:	10800417 	ldw	r2,16(r2)
 90926ec:	10c00017 	ldw	r3,0(r2)
 90926f0:	e0bffe17 	ldw	r2,-8(fp)
 90926f4:	10c00015 	stw	r3,0(r2)
 90926f8:	00000206 	br	9092704 <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 90926fc:	e0bffe17 	ldw	r2,-8(fp)
 9092700:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 9092704:	e0bffc17 	ldw	r2,-16(fp)
 9092708:	10c0058b 	ldhu	r3,22(r2)
 909270c:	e0bffe17 	ldw	r2,-8(fp)
 9092710:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 9092714:	e0bffc17 	ldw	r2,-16(fp)
 9092718:	10c0050b 	ldhu	r3,20(r2)
 909271c:	e0bffe17 	ldw	r2,-8(fp)
 9092720:	10c0018d 	sth	r3,6(r2)
 9092724:	e0bff817 	ldw	r2,-32(fp)
 9092728:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909272c:	e0bff617 	ldw	r2,-40(fp)
 9092730:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9092734:	e03fff15 	stw	zero,-4(fp)
 9092738:	e0bfff17 	ldw	r2,-4(fp)
}
 909273c:	e037883a 	mov	sp,fp
 9092740:	df000017 	ldw	fp,0(sp)
 9092744:	dec00104 	addi	sp,sp,4
 9092748:	f800283a 	ret

0909274c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 909274c:	defffb04 	addi	sp,sp,-20
 9092750:	dfc00415 	stw	ra,16(sp)
 9092754:	df000315 	stw	fp,12(sp)
 9092758:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 909275c:	010243b4 	movhi	r4,2318
 9092760:	212c2004 	addi	r4,r4,-20352
 9092764:	01407804 	movi	r5,480
 9092768:	908ea340 	call	908ea34 <OS_MemClr>
    pq1 = &OSQTbl[0];
 909276c:	008243b4 	movhi	r2,2318
 9092770:	10ac2004 	addi	r2,r2,-20352
 9092774:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 9092778:	008243b4 	movhi	r2,2318
 909277c:	10ac2604 	addi	r2,r2,-20328
 9092780:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 9092784:	e03fff0d 	sth	zero,-4(fp)
 9092788:	00000c06 	br	90927bc <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 909278c:	e0fffe17 	ldw	r3,-8(fp)
 9092790:	e0bffd17 	ldw	r2,-12(fp)
 9092794:	18800015 	stw	r2,0(r3)
        pq1++;
 9092798:	e0bffe17 	ldw	r2,-8(fp)
 909279c:	10800604 	addi	r2,r2,24
 90927a0:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 90927a4:	e0bffd17 	ldw	r2,-12(fp)
 90927a8:	10800604 	addi	r2,r2,24
 90927ac:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 90927b0:	e0bfff0b 	ldhu	r2,-4(fp)
 90927b4:	10800044 	addi	r2,r2,1
 90927b8:	e0bfff0d 	sth	r2,-4(fp)
 90927bc:	e0bfff0b 	ldhu	r2,-4(fp)
 90927c0:	108004f0 	cmpltui	r2,r2,19
 90927c4:	103ff11e 	bne	r2,zero,909278c <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 90927c8:	e0bffe17 	ldw	r2,-8(fp)
 90927cc:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 90927d0:	00c24374 	movhi	r3,2317
 90927d4:	18cc1004 	addi	r3,r3,12352
 90927d8:	008243b4 	movhi	r2,2318
 90927dc:	10ac2004 	addi	r2,r2,-20352
 90927e0:	18800015 	stw	r2,0(r3)
#endif
}
 90927e4:	e037883a 	mov	sp,fp
 90927e8:	dfc00117 	ldw	ra,4(sp)
 90927ec:	df000017 	ldw	fp,0(sp)
 90927f0:	dec00204 	addi	sp,sp,8
 90927f4:	f800283a 	ret

090927f8 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 90927f8:	defff904 	addi	sp,sp,-28
 90927fc:	df000615 	stw	fp,24(sp)
 9092800:	df000604 	addi	fp,sp,24
 9092804:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9092808:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 909280c:	e0bffe17 	ldw	r2,-8(fp)
 9092810:	1004c03a 	cmpne	r2,r2,zero
 9092814:	1000021e 	bne	r2,zero,9092820 <OSSemAccept+0x28>
        return (0);
 9092818:	e03fff15 	stw	zero,-4(fp)
 909281c:	00002106 	br	90928a4 <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9092820:	e0bffe17 	ldw	r2,-8(fp)
 9092824:	10800003 	ldbu	r2,0(r2)
 9092828:	10803fcc 	andi	r2,r2,255
 909282c:	108000e0 	cmpeqi	r2,r2,3
 9092830:	1000021e 	bne	r2,zero,909283c <OSSemAccept+0x44>
        return (0);
 9092834:	e03fff15 	stw	zero,-4(fp)
 9092838:	00001a06 	br	90928a4 <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909283c:	0005303a 	rdctl	r2,status
 9092840:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092844:	e0fffb17 	ldw	r3,-20(fp)
 9092848:	00bfff84 	movi	r2,-2
 909284c:	1884703a 	and	r2,r3,r2
 9092850:	1001703a 	wrctl	status,r2
  
  return context;
 9092854:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 9092858:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 909285c:	e0bffe17 	ldw	r2,-8(fp)
 9092860:	1080020b 	ldhu	r2,8(r2)
 9092864:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 9092868:	e0bffd0b 	ldhu	r2,-12(fp)
 909286c:	1005003a 	cmpeq	r2,r2,zero
 9092870:	1000061e 	bne	r2,zero,909288c <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 9092874:	e0bffe17 	ldw	r2,-8(fp)
 9092878:	1080020b 	ldhu	r2,8(r2)
 909287c:	10bfffc4 	addi	r2,r2,-1
 9092880:	1007883a 	mov	r3,r2
 9092884:	e0bffe17 	ldw	r2,-8(fp)
 9092888:	10c0020d 	sth	r3,8(r2)
 909288c:	e0bffc17 	ldw	r2,-16(fp)
 9092890:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092894:	e0bffa17 	ldw	r2,-24(fp)
 9092898:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 909289c:	e0bffd0b 	ldhu	r2,-12(fp)
 90928a0:	e0bfff15 	stw	r2,-4(fp)
 90928a4:	e0bfff17 	ldw	r2,-4(fp)
}
 90928a8:	e037883a 	mov	sp,fp
 90928ac:	df000017 	ldw	fp,0(sp)
 90928b0:	dec00104 	addi	sp,sp,4
 90928b4:	f800283a 	ret

090928b8 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 90928b8:	defff804 	addi	sp,sp,-32
 90928bc:	dfc00715 	stw	ra,28(sp)
 90928c0:	df000615 	stw	fp,24(sp)
 90928c4:	df000604 	addi	fp,sp,24
 90928c8:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 90928cc:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 90928d0:	00824374 	movhi	r2,2317
 90928d4:	108c1304 	addi	r2,r2,12364
 90928d8:	10800003 	ldbu	r2,0(r2)
 90928dc:	10803fcc 	andi	r2,r2,255
 90928e0:	1005003a 	cmpeq	r2,r2,zero
 90928e4:	1000021e 	bne	r2,zero,90928f0 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 90928e8:	e03fff15 	stw	zero,-4(fp)
 90928ec:	00003106 	br	90929b4 <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90928f0:	0005303a 	rdctl	r2,status
 90928f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90928f8:	e0fffb17 	ldw	r3,-20(fp)
 90928fc:	00bfff84 	movi	r2,-2
 9092900:	1884703a 	and	r2,r3,r2
 9092904:	1001703a 	wrctl	status,r2
  
  return context;
 9092908:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 909290c:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 9092910:	00824374 	movhi	r2,2317
 9092914:	108c1204 	addi	r2,r2,12360
 9092918:	10800017 	ldw	r2,0(r2)
 909291c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 9092920:	00824374 	movhi	r2,2317
 9092924:	108c1204 	addi	r2,r2,12360
 9092928:	10800017 	ldw	r2,0(r2)
 909292c:	1005003a 	cmpeq	r2,r2,zero
 9092930:	1000081e 	bne	r2,zero,9092954 <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 9092934:	00824374 	movhi	r2,2317
 9092938:	108c1204 	addi	r2,r2,12360
 909293c:	10800017 	ldw	r2,0(r2)
 9092940:	10800117 	ldw	r2,4(r2)
 9092944:	1007883a 	mov	r3,r2
 9092948:	00824374 	movhi	r2,2317
 909294c:	108c1204 	addi	r2,r2,12360
 9092950:	10c00015 	stw	r3,0(r2)
 9092954:	e0bffc17 	ldw	r2,-16(fp)
 9092958:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909295c:	e0bffa17 	ldw	r2,-24(fp)
 9092960:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 9092964:	e0bffd17 	ldw	r2,-12(fp)
 9092968:	1005003a 	cmpeq	r2,r2,zero
 909296c:	10000f1e 	bne	r2,zero,90929ac <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 9092970:	e0fffd17 	ldw	r3,-12(fp)
 9092974:	008000c4 	movi	r2,3
 9092978:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 909297c:	e0fffd17 	ldw	r3,-12(fp)
 9092980:	e0bffe0b 	ldhu	r2,-8(fp)
 9092984:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 9092988:	e0bffd17 	ldw	r2,-12(fp)
 909298c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 9092990:	e0fffd17 	ldw	r3,-12(fp)
 9092994:	00800fc4 	movi	r2,63
 9092998:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 909299c:	e0bffd17 	ldw	r2,-12(fp)
 90929a0:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 90929a4:	e13ffd17 	ldw	r4,-12(fp)
 90929a8:	908e6680 	call	908e668 <OS_EventWaitListInit>
    }
    return (pevent);
 90929ac:	e0bffd17 	ldw	r2,-12(fp)
 90929b0:	e0bfff15 	stw	r2,-4(fp)
 90929b4:	e0bfff17 	ldw	r2,-4(fp)
}
 90929b8:	e037883a 	mov	sp,fp
 90929bc:	dfc00117 	ldw	ra,4(sp)
 90929c0:	df000017 	ldw	fp,0(sp)
 90929c4:	dec00204 	addi	sp,sp,8
 90929c8:	f800283a 	ret

090929cc <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 90929cc:	defff104 	addi	sp,sp,-60
 90929d0:	dfc00e15 	stw	ra,56(sp)
 90929d4:	df000d15 	stw	fp,52(sp)
 90929d8:	df000d04 	addi	fp,sp,52
 90929dc:	e13ffb15 	stw	r4,-20(fp)
 90929e0:	e1bffd15 	stw	r6,-12(fp)
 90929e4:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 90929e8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 90929ec:	e0bffd17 	ldw	r2,-12(fp)
 90929f0:	1004c03a 	cmpne	r2,r2,zero
 90929f4:	1000031e 	bne	r2,zero,9092a04 <OSSemDel+0x38>
        return (pevent);
 90929f8:	e0bffb17 	ldw	r2,-20(fp)
 90929fc:	e0bfff15 	stw	r2,-4(fp)
 9092a00:	00009406 	br	9092c54 <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9092a04:	e0bffb17 	ldw	r2,-20(fp)
 9092a08:	1004c03a 	cmpne	r2,r2,zero
 9092a0c:	1000061e 	bne	r2,zero,9092a28 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 9092a10:	e0fffd17 	ldw	r3,-12(fp)
 9092a14:	00800104 	movi	r2,4
 9092a18:	18800005 	stb	r2,0(r3)
        return (pevent);
 9092a1c:	e0fffb17 	ldw	r3,-20(fp)
 9092a20:	e0ffff15 	stw	r3,-4(fp)
 9092a24:	00008b06 	br	9092c54 <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 9092a28:	e0bffb17 	ldw	r2,-20(fp)
 9092a2c:	10800003 	ldbu	r2,0(r2)
 9092a30:	10803fcc 	andi	r2,r2,255
 9092a34:	108000e0 	cmpeqi	r2,r2,3
 9092a38:	1000061e 	bne	r2,zero,9092a54 <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 9092a3c:	e0fffd17 	ldw	r3,-12(fp)
 9092a40:	00800044 	movi	r2,1
 9092a44:	18800005 	stb	r2,0(r3)
        return (pevent);
 9092a48:	e0bffb17 	ldw	r2,-20(fp)
 9092a4c:	e0bfff15 	stw	r2,-4(fp)
 9092a50:	00008006 	br	9092c54 <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 9092a54:	00824374 	movhi	r2,2317
 9092a58:	108c1304 	addi	r2,r2,12364
 9092a5c:	10800003 	ldbu	r2,0(r2)
 9092a60:	10803fcc 	andi	r2,r2,255
 9092a64:	1005003a 	cmpeq	r2,r2,zero
 9092a68:	1000061e 	bne	r2,zero,9092a84 <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 9092a6c:	e0fffd17 	ldw	r3,-12(fp)
 9092a70:	008003c4 	movi	r2,15
 9092a74:	18800005 	stb	r2,0(r3)
        return (pevent);
 9092a78:	e0fffb17 	ldw	r3,-20(fp)
 9092a7c:	e0ffff15 	stw	r3,-4(fp)
 9092a80:	00007406 	br	9092c54 <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092a84:	0005303a 	rdctl	r2,status
 9092a88:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092a8c:	e0fff717 	ldw	r3,-36(fp)
 9092a90:	00bfff84 	movi	r2,-2
 9092a94:	1884703a 	and	r2,r3,r2
 9092a98:	1001703a 	wrctl	status,r2
  
  return context;
 9092a9c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9092aa0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 9092aa4:	e0bffb17 	ldw	r2,-20(fp)
 9092aa8:	10800283 	ldbu	r2,10(r2)
 9092aac:	10803fcc 	andi	r2,r2,255
 9092ab0:	1005003a 	cmpeq	r2,r2,zero
 9092ab4:	1000031e 	bne	r2,zero,9092ac4 <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 9092ab8:	00800044 	movi	r2,1
 9092abc:	e0bffa05 	stb	r2,-24(fp)
 9092ac0:	00000106 	br	9092ac8 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 9092ac4:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 9092ac8:	e0bffc03 	ldbu	r2,-16(fp)
 9092acc:	e0bffe15 	stw	r2,-8(fp)
 9092ad0:	e0fffe17 	ldw	r3,-8(fp)
 9092ad4:	1805003a 	cmpeq	r2,r3,zero
 9092ad8:	1000041e 	bne	r2,zero,9092aec <OSSemDel+0x120>
 9092adc:	e0fffe17 	ldw	r3,-8(fp)
 9092ae0:	18800060 	cmpeqi	r2,r3,1
 9092ae4:	10002d1e 	bne	r2,zero,9092b9c <OSSemDel+0x1d0>
 9092ae8:	00004f06 	br	9092c28 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 9092aec:	e0bffa03 	ldbu	r2,-24(fp)
 9092af0:	1004c03a 	cmpne	r2,r2,zero
 9092af4:	10001a1e 	bne	r2,zero,9092b60 <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 9092af8:	e0fffb17 	ldw	r3,-20(fp)
 9092afc:	00800fc4 	movi	r2,63
 9092b00:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 9092b04:	e0bffb17 	ldw	r2,-20(fp)
 9092b08:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9092b0c:	e0bffb17 	ldw	r2,-20(fp)
 9092b10:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 9092b14:	00824374 	movhi	r2,2317
 9092b18:	108c1204 	addi	r2,r2,12360
 9092b1c:	10c00017 	ldw	r3,0(r2)
 9092b20:	e0bffb17 	ldw	r2,-20(fp)
 9092b24:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 9092b28:	e0bffb17 	ldw	r2,-20(fp)
 9092b2c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 9092b30:	00c24374 	movhi	r3,2317
 9092b34:	18cc1204 	addi	r3,r3,12360
 9092b38:	e0bffb17 	ldw	r2,-20(fp)
 9092b3c:	18800015 	stw	r2,0(r3)
 9092b40:	e0bff817 	ldw	r2,-32(fp)
 9092b44:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092b48:	e0bff617 	ldw	r2,-40(fp)
 9092b4c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 9092b50:	e0bffd17 	ldw	r2,-12(fp)
 9092b54:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 9092b58:	e03ff915 	stw	zero,-28(fp)
 9092b5c:	00003b06 	br	9092c4c <OSSemDel+0x280>
 9092b60:	e0bff817 	ldw	r2,-32(fp)
 9092b64:	e0bff515 	stw	r2,-44(fp)
 9092b68:	e0bff517 	ldw	r2,-44(fp)
 9092b6c:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 9092b70:	e0fffd17 	ldw	r3,-12(fp)
 9092b74:	00801244 	movi	r2,73
 9092b78:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 9092b7c:	e0bffb17 	ldw	r2,-20(fp)
 9092b80:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 9092b84:	00003106 	br	9092c4c <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 9092b88:	e13ffb17 	ldw	r4,-20(fp)
 9092b8c:	000b883a 	mov	r5,zero
 9092b90:	01800044 	movi	r6,1
 9092b94:	000f883a 	mov	r7,zero
 9092b98:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 9092b9c:	e0bffb17 	ldw	r2,-20(fp)
 9092ba0:	10800283 	ldbu	r2,10(r2)
 9092ba4:	10803fcc 	andi	r2,r2,255
 9092ba8:	1004c03a 	cmpne	r2,r2,zero
 9092bac:	103ff61e 	bne	r2,zero,9092b88 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 9092bb0:	e0fffb17 	ldw	r3,-20(fp)
 9092bb4:	00800fc4 	movi	r2,63
 9092bb8:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 9092bbc:	e0bffb17 	ldw	r2,-20(fp)
 9092bc0:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9092bc4:	e0bffb17 	ldw	r2,-20(fp)
 9092bc8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 9092bcc:	00824374 	movhi	r2,2317
 9092bd0:	108c1204 	addi	r2,r2,12360
 9092bd4:	10c00017 	ldw	r3,0(r2)
 9092bd8:	e0bffb17 	ldw	r2,-20(fp)
 9092bdc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 9092be0:	e0bffb17 	ldw	r2,-20(fp)
 9092be4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 9092be8:	00c24374 	movhi	r3,2317
 9092bec:	18cc1204 	addi	r3,r3,12360
 9092bf0:	e0bffb17 	ldw	r2,-20(fp)
 9092bf4:	18800015 	stw	r2,0(r3)
 9092bf8:	e0bff817 	ldw	r2,-32(fp)
 9092bfc:	e0bff415 	stw	r2,-48(fp)
 9092c00:	e0bff417 	ldw	r2,-48(fp)
 9092c04:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 9092c08:	e0bffa03 	ldbu	r2,-24(fp)
 9092c0c:	10800058 	cmpnei	r2,r2,1
 9092c10:	1000011e 	bne	r2,zero,9092c18 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 9092c14:	908eaf40 	call	908eaf4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 9092c18:	e0bffd17 	ldw	r2,-12(fp)
 9092c1c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 9092c20:	e03ff915 	stw	zero,-28(fp)
             break;
 9092c24:	00000906 	br	9092c4c <OSSemDel+0x280>
 9092c28:	e0bff817 	ldw	r2,-32(fp)
 9092c2c:	e0bff315 	stw	r2,-52(fp)
 9092c30:	e0bff317 	ldw	r2,-52(fp)
 9092c34:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 9092c38:	e0fffd17 	ldw	r3,-12(fp)
 9092c3c:	008001c4 	movi	r2,7
 9092c40:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 9092c44:	e0bffb17 	ldw	r2,-20(fp)
 9092c48:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 9092c4c:	e0bff917 	ldw	r2,-28(fp)
 9092c50:	e0bfff15 	stw	r2,-4(fp)
 9092c54:	e0bfff17 	ldw	r2,-4(fp)
}
 9092c58:	e037883a 	mov	sp,fp
 9092c5c:	dfc00117 	ldw	ra,4(sp)
 9092c60:	df000017 	ldw	fp,0(sp)
 9092c64:	dec00204 	addi	sp,sp,8
 9092c68:	f800283a 	ret

09092c6c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 9092c6c:	defff404 	addi	sp,sp,-48
 9092c70:	dfc00b15 	stw	ra,44(sp)
 9092c74:	df000a15 	stw	fp,40(sp)
 9092c78:	df000a04 	addi	fp,sp,40
 9092c7c:	e13ffc15 	stw	r4,-16(fp)
 9092c80:	e1bffe15 	stw	r6,-8(fp)
 9092c84:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9092c88:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9092c8c:	e0bffe17 	ldw	r2,-8(fp)
 9092c90:	1005003a 	cmpeq	r2,r2,zero
 9092c94:	10008f1e 	bne	r2,zero,9092ed4 <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9092c98:	e0bffc17 	ldw	r2,-16(fp)
 9092c9c:	1004c03a 	cmpne	r2,r2,zero
 9092ca0:	1000041e 	bne	r2,zero,9092cb4 <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 9092ca4:	e0fffe17 	ldw	r3,-8(fp)
 9092ca8:	00800104 	movi	r2,4
 9092cac:	18800005 	stb	r2,0(r3)
        return;
 9092cb0:	00008806 	br	9092ed4 <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9092cb4:	e0bffc17 	ldw	r2,-16(fp)
 9092cb8:	10800003 	ldbu	r2,0(r2)
 9092cbc:	10803fcc 	andi	r2,r2,255
 9092cc0:	108000e0 	cmpeqi	r2,r2,3
 9092cc4:	1000041e 	bne	r2,zero,9092cd8 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 9092cc8:	e0fffe17 	ldw	r3,-8(fp)
 9092ccc:	00800044 	movi	r2,1
 9092cd0:	18800005 	stb	r2,0(r3)
        return;
 9092cd4:	00007f06 	br	9092ed4 <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 9092cd8:	00824374 	movhi	r2,2317
 9092cdc:	108c1304 	addi	r2,r2,12364
 9092ce0:	10800003 	ldbu	r2,0(r2)
 9092ce4:	10803fcc 	andi	r2,r2,255
 9092ce8:	1005003a 	cmpeq	r2,r2,zero
 9092cec:	1000041e 	bne	r2,zero,9092d00 <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 9092cf0:	e0fffe17 	ldw	r3,-8(fp)
 9092cf4:	00800084 	movi	r2,2
 9092cf8:	18800005 	stb	r2,0(r3)
        return;
 9092cfc:	00007506 	br	9092ed4 <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 9092d00:	00824374 	movhi	r2,2317
 9092d04:	108c0504 	addi	r2,r2,12308
 9092d08:	10800003 	ldbu	r2,0(r2)
 9092d0c:	10803fcc 	andi	r2,r2,255
 9092d10:	1005003a 	cmpeq	r2,r2,zero
 9092d14:	1000041e 	bne	r2,zero,9092d28 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 9092d18:	e0fffe17 	ldw	r3,-8(fp)
 9092d1c:	00800344 	movi	r2,13
 9092d20:	18800005 	stb	r2,0(r3)
        return;
 9092d24:	00006b06 	br	9092ed4 <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092d28:	0005303a 	rdctl	r2,status
 9092d2c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092d30:	e0fffa17 	ldw	r3,-24(fp)
 9092d34:	00bfff84 	movi	r2,-2
 9092d38:	1884703a 	and	r2,r3,r2
 9092d3c:	1001703a 	wrctl	status,r2
  
  return context;
 9092d40:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9092d44:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 9092d48:	e0bffc17 	ldw	r2,-16(fp)
 9092d4c:	1080020b 	ldhu	r2,8(r2)
 9092d50:	10bfffcc 	andi	r2,r2,65535
 9092d54:	1005003a 	cmpeq	r2,r2,zero
 9092d58:	10000d1e 	bne	r2,zero,9092d90 <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 9092d5c:	e0bffc17 	ldw	r2,-16(fp)
 9092d60:	1080020b 	ldhu	r2,8(r2)
 9092d64:	10bfffc4 	addi	r2,r2,-1
 9092d68:	1007883a 	mov	r3,r2
 9092d6c:	e0bffc17 	ldw	r2,-16(fp)
 9092d70:	10c0020d 	sth	r3,8(r2)
 9092d74:	e0bffb17 	ldw	r2,-20(fp)
 9092d78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092d7c:	e0bff917 	ldw	r2,-28(fp)
 9092d80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 9092d84:	e0bffe17 	ldw	r2,-8(fp)
 9092d88:	10000005 	stb	zero,0(r2)
        return;
 9092d8c:	00005106 	br	9092ed4 <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 9092d90:	00824374 	movhi	r2,2317
 9092d94:	108c1404 	addi	r2,r2,12368
 9092d98:	10c00017 	ldw	r3,0(r2)
 9092d9c:	00824374 	movhi	r2,2317
 9092da0:	108c1404 	addi	r2,r2,12368
 9092da4:	10800017 	ldw	r2,0(r2)
 9092da8:	10800c03 	ldbu	r2,48(r2)
 9092dac:	10800054 	ori	r2,r2,1
 9092db0:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9092db4:	00824374 	movhi	r2,2317
 9092db8:	108c1404 	addi	r2,r2,12368
 9092dbc:	10800017 	ldw	r2,0(r2)
 9092dc0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 9092dc4:	00824374 	movhi	r2,2317
 9092dc8:	108c1404 	addi	r2,r2,12368
 9092dcc:	10c00017 	ldw	r3,0(r2)
 9092dd0:	e0bffd0b 	ldhu	r2,-12(fp)
 9092dd4:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 9092dd8:	e13ffc17 	ldw	r4,-16(fp)
 9092ddc:	908e2480 	call	908e248 <OS_EventTaskWait>
 9092de0:	e0bffb17 	ldw	r2,-20(fp)
 9092de4:	e0bff815 	stw	r2,-32(fp)
 9092de8:	e0bff817 	ldw	r2,-32(fp)
 9092dec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 9092df0:	908eaf40 	call	908eaf4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092df4:	0005303a 	rdctl	r2,status
 9092df8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092dfc:	e0fff717 	ldw	r3,-36(fp)
 9092e00:	00bfff84 	movi	r2,-2
 9092e04:	1884703a 	and	r2,r3,r2
 9092e08:	1001703a 	wrctl	status,r2
  
  return context;
 9092e0c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 9092e10:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 9092e14:	00824374 	movhi	r2,2317
 9092e18:	108c1404 	addi	r2,r2,12368
 9092e1c:	10800017 	ldw	r2,0(r2)
 9092e20:	10800c43 	ldbu	r2,49(r2)
 9092e24:	10803fcc 	andi	r2,r2,255
 9092e28:	e0bfff15 	stw	r2,-4(fp)
 9092e2c:	e0ffff17 	ldw	r3,-4(fp)
 9092e30:	1805003a 	cmpeq	r2,r3,zero
 9092e34:	1000041e 	bne	r2,zero,9092e48 <OSSemPend+0x1dc>
 9092e38:	e0ffff17 	ldw	r3,-4(fp)
 9092e3c:	188000a0 	cmpeqi	r2,r3,2
 9092e40:	1000041e 	bne	r2,zero,9092e54 <OSSemPend+0x1e8>
 9092e44:	00000706 	br	9092e64 <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 9092e48:	e0bffe17 	ldw	r2,-8(fp)
 9092e4c:	10000005 	stb	zero,0(r2)
             break;
 9092e50:	00000c06 	br	9092e84 <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 9092e54:	e0fffe17 	ldw	r3,-8(fp)
 9092e58:	00800384 	movi	r2,14
 9092e5c:	18800005 	stb	r2,0(r3)
             break;
 9092e60:	00000806 	br	9092e84 <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 9092e64:	00824374 	movhi	r2,2317
 9092e68:	108c1404 	addi	r2,r2,12368
 9092e6c:	11000017 	ldw	r4,0(r2)
 9092e70:	e17ffc17 	ldw	r5,-16(fp)
 9092e74:	908e4ac0 	call	908e4ac <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 9092e78:	e0fffe17 	ldw	r3,-8(fp)
 9092e7c:	00800284 	movi	r2,10
 9092e80:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 9092e84:	00824374 	movhi	r2,2317
 9092e88:	108c1404 	addi	r2,r2,12368
 9092e8c:	10800017 	ldw	r2,0(r2)
 9092e90:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 9092e94:	00824374 	movhi	r2,2317
 9092e98:	108c1404 	addi	r2,r2,12368
 9092e9c:	10800017 	ldw	r2,0(r2)
 9092ea0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 9092ea4:	00824374 	movhi	r2,2317
 9092ea8:	108c1404 	addi	r2,r2,12368
 9092eac:	10800017 	ldw	r2,0(r2)
 9092eb0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 9092eb4:	00824374 	movhi	r2,2317
 9092eb8:	108c1404 	addi	r2,r2,12368
 9092ebc:	10800017 	ldw	r2,0(r2)
 9092ec0:	10000815 	stw	zero,32(r2)
 9092ec4:	e0bffb17 	ldw	r2,-20(fp)
 9092ec8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092ecc:	e0bff617 	ldw	r2,-40(fp)
 9092ed0:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 9092ed4:	e037883a 	mov	sp,fp
 9092ed8:	dfc00117 	ldw	ra,4(sp)
 9092edc:	df000017 	ldw	fp,0(sp)
 9092ee0:	dec00204 	addi	sp,sp,8
 9092ee4:	f800283a 	ret

09092ee8 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 9092ee8:	defff504 	addi	sp,sp,-44
 9092eec:	dfc00a15 	stw	ra,40(sp)
 9092ef0:	df000915 	stw	fp,36(sp)
 9092ef4:	df000904 	addi	fp,sp,36
 9092ef8:	e13ffc15 	stw	r4,-16(fp)
 9092efc:	e1bffe15 	stw	r6,-8(fp)
 9092f00:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9092f04:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9092f08:	e0bffe17 	ldw	r2,-8(fp)
 9092f0c:	1004c03a 	cmpne	r2,r2,zero
 9092f10:	1000021e 	bne	r2,zero,9092f1c <OSSemPendAbort+0x34>
        return (0);
 9092f14:	e03fff15 	stw	zero,-4(fp)
 9092f18:	00004c06 	br	909304c <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9092f1c:	e0bffc17 	ldw	r2,-16(fp)
 9092f20:	1004c03a 	cmpne	r2,r2,zero
 9092f24:	1000051e 	bne	r2,zero,9092f3c <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9092f28:	e0fffe17 	ldw	r3,-8(fp)
 9092f2c:	00800104 	movi	r2,4
 9092f30:	18800005 	stb	r2,0(r3)
        return (0);
 9092f34:	e03fff15 	stw	zero,-4(fp)
 9092f38:	00004406 	br	909304c <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9092f3c:	e0bffc17 	ldw	r2,-16(fp)
 9092f40:	10800003 	ldbu	r2,0(r2)
 9092f44:	10803fcc 	andi	r2,r2,255
 9092f48:	108000e0 	cmpeqi	r2,r2,3
 9092f4c:	1000051e 	bne	r2,zero,9092f64 <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9092f50:	e0fffe17 	ldw	r3,-8(fp)
 9092f54:	00800044 	movi	r2,1
 9092f58:	18800005 	stb	r2,0(r3)
        return (0);
 9092f5c:	e03fff15 	stw	zero,-4(fp)
 9092f60:	00003a06 	br	909304c <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092f64:	0005303a 	rdctl	r2,status
 9092f68:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092f6c:	e0fff917 	ldw	r3,-28(fp)
 9092f70:	00bfff84 	movi	r2,-2
 9092f74:	1884703a 	and	r2,r3,r2
 9092f78:	1001703a 	wrctl	status,r2
  
  return context;
 9092f7c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9092f80:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 9092f84:	e0bffc17 	ldw	r2,-16(fp)
 9092f88:	10800283 	ldbu	r2,10(r2)
 9092f8c:	10803fcc 	andi	r2,r2,255
 9092f90:	1005003a 	cmpeq	r2,r2,zero
 9092f94:	1000261e 	bne	r2,zero,9093030 <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 9092f98:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 9092f9c:	e0bffd03 	ldbu	r2,-12(fp)
 9092fa0:	10800060 	cmpeqi	r2,r2,1
 9092fa4:	1000091e 	bne	r2,zero,9092fcc <OSSemPendAbort+0xe4>
 9092fa8:	00000e06 	br	9092fe4 <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 9092fac:	e13ffc17 	ldw	r4,-16(fp)
 9092fb0:	000b883a 	mov	r5,zero
 9092fb4:	01800044 	movi	r6,1
 9092fb8:	01c00084 	movi	r7,2
 9092fbc:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                     nbr_tasks++;
 9092fc0:	e0bffb03 	ldbu	r2,-20(fp)
 9092fc4:	10800044 	addi	r2,r2,1
 9092fc8:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 9092fcc:	e0bffc17 	ldw	r2,-16(fp)
 9092fd0:	10800283 	ldbu	r2,10(r2)
 9092fd4:	10803fcc 	andi	r2,r2,255
 9092fd8:	1004c03a 	cmpne	r2,r2,zero
 9092fdc:	103ff31e 	bne	r2,zero,9092fac <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 9092fe0:	00000806 	br	9093004 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 9092fe4:	e13ffc17 	ldw	r4,-16(fp)
 9092fe8:	000b883a 	mov	r5,zero
 9092fec:	01800044 	movi	r6,1
 9092ff0:	01c00084 	movi	r7,2
 9092ff4:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
                 nbr_tasks++;
 9092ff8:	e0bffb03 	ldbu	r2,-20(fp)
 9092ffc:	10800044 	addi	r2,r2,1
 9093000:	e0bffb05 	stb	r2,-20(fp)
 9093004:	e0bffa17 	ldw	r2,-24(fp)
 9093008:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909300c:	e0bff817 	ldw	r2,-32(fp)
 9093010:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 9093014:	908eaf40 	call	908eaf4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 9093018:	e0fffe17 	ldw	r3,-8(fp)
 909301c:	00800384 	movi	r2,14
 9093020:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 9093024:	e0bffb03 	ldbu	r2,-20(fp)
 9093028:	e0bfff15 	stw	r2,-4(fp)
 909302c:	00000706 	br	909304c <OSSemPendAbort+0x164>
 9093030:	e0bffa17 	ldw	r2,-24(fp)
 9093034:	e0bff715 	stw	r2,-36(fp)
 9093038:	e0bff717 	ldw	r2,-36(fp)
 909303c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9093040:	e0bffe17 	ldw	r2,-8(fp)
 9093044:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 9093048:	e03fff15 	stw	zero,-4(fp)
 909304c:	e0bfff17 	ldw	r2,-4(fp)
}
 9093050:	e037883a 	mov	sp,fp
 9093054:	dfc00117 	ldw	ra,4(sp)
 9093058:	df000017 	ldw	fp,0(sp)
 909305c:	dec00204 	addi	sp,sp,8
 9093060:	f800283a 	ret

09093064 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 9093064:	defff704 	addi	sp,sp,-36
 9093068:	dfc00815 	stw	ra,32(sp)
 909306c:	df000715 	stw	fp,28(sp)
 9093070:	df000704 	addi	fp,sp,28
 9093074:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9093078:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 909307c:	e0bffe17 	ldw	r2,-8(fp)
 9093080:	1004c03a 	cmpne	r2,r2,zero
 9093084:	1000031e 	bne	r2,zero,9093094 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 9093088:	00800104 	movi	r2,4
 909308c:	e0bfff15 	stw	r2,-4(fp)
 9093090:	00003806 	br	9093174 <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9093094:	e0bffe17 	ldw	r2,-8(fp)
 9093098:	10800003 	ldbu	r2,0(r2)
 909309c:	10803fcc 	andi	r2,r2,255
 90930a0:	108000e0 	cmpeqi	r2,r2,3
 90930a4:	1000031e 	bne	r2,zero,90930b4 <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 90930a8:	00800044 	movi	r2,1
 90930ac:	e0bfff15 	stw	r2,-4(fp)
 90930b0:	00003006 	br	9093174 <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90930b4:	0005303a 	rdctl	r2,status
 90930b8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90930bc:	e0fffc17 	ldw	r3,-16(fp)
 90930c0:	00bfff84 	movi	r2,-2
 90930c4:	1884703a 	and	r2,r3,r2
 90930c8:	1001703a 	wrctl	status,r2
  
  return context;
 90930cc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 90930d0:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 90930d4:	e0bffe17 	ldw	r2,-8(fp)
 90930d8:	10800283 	ldbu	r2,10(r2)
 90930dc:	10803fcc 	andi	r2,r2,255
 90930e0:	1005003a 	cmpeq	r2,r2,zero
 90930e4:	10000c1e 	bne	r2,zero,9093118 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 90930e8:	e13ffe17 	ldw	r4,-8(fp)
 90930ec:	000b883a 	mov	r5,zero
 90930f0:	01800044 	movi	r6,1
 90930f4:	000f883a 	mov	r7,zero
 90930f8:	908e0b40 	call	908e0b4 <OS_EventTaskRdy>
 90930fc:	e0bffd17 	ldw	r2,-12(fp)
 9093100:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093104:	e0bffb17 	ldw	r2,-20(fp)
 9093108:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 909310c:	908eaf40 	call	908eaf4 <OS_Sched>
        return (OS_ERR_NONE);
 9093110:	e03fff15 	stw	zero,-4(fp)
 9093114:	00001706 	br	9093174 <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 9093118:	e0bffe17 	ldw	r2,-8(fp)
 909311c:	1080020b 	ldhu	r2,8(r2)
 9093120:	10ffffcc 	andi	r3,r2,65535
 9093124:	00bfffd4 	movui	r2,65535
 9093128:	18800c26 	beq	r3,r2,909315c <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 909312c:	e0bffe17 	ldw	r2,-8(fp)
 9093130:	1080020b 	ldhu	r2,8(r2)
 9093134:	10800044 	addi	r2,r2,1
 9093138:	1007883a 	mov	r3,r2
 909313c:	e0bffe17 	ldw	r2,-8(fp)
 9093140:	10c0020d 	sth	r3,8(r2)
 9093144:	e0bffd17 	ldw	r2,-12(fp)
 9093148:	e0bffa15 	stw	r2,-24(fp)
 909314c:	e0bffa17 	ldw	r2,-24(fp)
 9093150:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 9093154:	e03fff15 	stw	zero,-4(fp)
 9093158:	00000606 	br	9093174 <OSSemPost+0x110>
 909315c:	e0bffd17 	ldw	r2,-12(fp)
 9093160:	e0bff915 	stw	r2,-28(fp)
 9093164:	e0bff917 	ldw	r2,-28(fp)
 9093168:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 909316c:	00800c84 	movi	r2,50
 9093170:	e0bfff15 	stw	r2,-4(fp)
 9093174:	e0bfff17 	ldw	r2,-4(fp)
}
 9093178:	e037883a 	mov	sp,fp
 909317c:	dfc00117 	ldw	ra,4(sp)
 9093180:	df000017 	ldw	fp,0(sp)
 9093184:	dec00204 	addi	sp,sp,8
 9093188:	f800283a 	ret

0909318c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 909318c:	defff604 	addi	sp,sp,-40
 9093190:	df000915 	stw	fp,36(sp)
 9093194:	df000904 	addi	fp,sp,36
 9093198:	e13ffd15 	stw	r4,-12(fp)
 909319c:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 90931a0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 90931a4:	e0bffd17 	ldw	r2,-12(fp)
 90931a8:	1004c03a 	cmpne	r2,r2,zero
 90931ac:	1000031e 	bne	r2,zero,90931bc <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 90931b0:	00800104 	movi	r2,4
 90931b4:	e0bfff15 	stw	r2,-4(fp)
 90931b8:	00003b06 	br	90932a8 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 90931bc:	e0bffe17 	ldw	r2,-8(fp)
 90931c0:	1004c03a 	cmpne	r2,r2,zero
 90931c4:	1000031e 	bne	r2,zero,90931d4 <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 90931c8:	00800244 	movi	r2,9
 90931cc:	e0bfff15 	stw	r2,-4(fp)
 90931d0:	00003506 	br	90932a8 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 90931d4:	e0bffd17 	ldw	r2,-12(fp)
 90931d8:	10800003 	ldbu	r2,0(r2)
 90931dc:	10803fcc 	andi	r2,r2,255
 90931e0:	108000e0 	cmpeqi	r2,r2,3
 90931e4:	1000031e 	bne	r2,zero,90931f4 <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 90931e8:	00800044 	movi	r2,1
 90931ec:	e0bfff15 	stw	r2,-4(fp)
 90931f0:	00002d06 	br	90932a8 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90931f4:	0005303a 	rdctl	r2,status
 90931f8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90931fc:	e0fff817 	ldw	r3,-32(fp)
 9093200:	00bfff84 	movi	r2,-2
 9093204:	1884703a 	and	r2,r3,r2
 9093208:	1001703a 	wrctl	status,r2
  
  return context;
 909320c:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 9093210:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 9093214:	e0bffd17 	ldw	r2,-12(fp)
 9093218:	10c00283 	ldbu	r3,10(r2)
 909321c:	e0bffe17 	ldw	r2,-8(fp)
 9093220:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 9093224:	e0bffd17 	ldw	r2,-12(fp)
 9093228:	108002c4 	addi	r2,r2,11
 909322c:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 9093230:	e0bffe17 	ldw	r2,-8(fp)
 9093234:	10800084 	addi	r2,r2,2
 9093238:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909323c:	e03ffa05 	stb	zero,-24(fp)
 9093240:	00000d06 	br	9093278 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 9093244:	e0bffc17 	ldw	r2,-16(fp)
 9093248:	10c00003 	ldbu	r3,0(r2)
 909324c:	e0bffb17 	ldw	r2,-20(fp)
 9093250:	10c00005 	stb	r3,0(r2)
 9093254:	e0bffb17 	ldw	r2,-20(fp)
 9093258:	10800044 	addi	r2,r2,1
 909325c:	e0bffb15 	stw	r2,-20(fp)
 9093260:	e0bffc17 	ldw	r2,-16(fp)
 9093264:	10800044 	addi	r2,r2,1
 9093268:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909326c:	e0bffa03 	ldbu	r2,-24(fp)
 9093270:	10800044 	addi	r2,r2,1
 9093274:	e0bffa05 	stb	r2,-24(fp)
 9093278:	e0bffa03 	ldbu	r2,-24(fp)
 909327c:	108000f0 	cmpltui	r2,r2,3
 9093280:	103ff01e 	bne	r2,zero,9093244 <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 9093284:	e0bffd17 	ldw	r2,-12(fp)
 9093288:	10c0020b 	ldhu	r3,8(r2)
 909328c:	e0bffe17 	ldw	r2,-8(fp)
 9093290:	10c0000d 	sth	r3,0(r2)
 9093294:	e0bff917 	ldw	r2,-28(fp)
 9093298:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909329c:	e0bff717 	ldw	r2,-36(fp)
 90932a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 90932a4:	e03fff15 	stw	zero,-4(fp)
 90932a8:	e0bfff17 	ldw	r2,-4(fp)
}
 90932ac:	e037883a 	mov	sp,fp
 90932b0:	df000017 	ldw	fp,0(sp)
 90932b4:	dec00104 	addi	sp,sp,4
 90932b8:	f800283a 	ret

090932bc <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 90932bc:	defff904 	addi	sp,sp,-28
 90932c0:	df000615 	stw	fp,24(sp)
 90932c4:	df000604 	addi	fp,sp,24
 90932c8:	e13ffd15 	stw	r4,-12(fp)
 90932cc:	e1bfff15 	stw	r6,-4(fp)
 90932d0:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90932d4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 90932d8:	e0bfff17 	ldw	r2,-4(fp)
 90932dc:	1005003a 	cmpeq	r2,r2,zero
 90932e0:	1000331e 	bne	r2,zero,90933b0 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 90932e4:	e0bffd17 	ldw	r2,-12(fp)
 90932e8:	1004c03a 	cmpne	r2,r2,zero
 90932ec:	1000041e 	bne	r2,zero,9093300 <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 90932f0:	e0ffff17 	ldw	r3,-4(fp)
 90932f4:	00800104 	movi	r2,4
 90932f8:	18800005 	stb	r2,0(r3)
        return;
 90932fc:	00002c06 	br	90933b0 <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9093300:	e0bffd17 	ldw	r2,-12(fp)
 9093304:	10800003 	ldbu	r2,0(r2)
 9093308:	10803fcc 	andi	r2,r2,255
 909330c:	108000e0 	cmpeqi	r2,r2,3
 9093310:	1000041e 	bne	r2,zero,9093324 <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 9093314:	e0ffff17 	ldw	r3,-4(fp)
 9093318:	00800044 	movi	r2,1
 909331c:	18800005 	stb	r2,0(r3)
        return;
 9093320:	00002306 	br	90933b0 <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093324:	0005303a 	rdctl	r2,status
 9093328:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909332c:	e0fffb17 	ldw	r3,-20(fp)
 9093330:	00bfff84 	movi	r2,-2
 9093334:	1884703a 	and	r2,r3,r2
 9093338:	1001703a 	wrctl	status,r2
  
  return context;
 909333c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 9093340:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 9093344:	e0bfff17 	ldw	r2,-4(fp)
 9093348:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 909334c:	e0bffd17 	ldw	r2,-12(fp)
 9093350:	1080020b 	ldhu	r2,8(r2)
 9093354:	10bfffcc 	andi	r2,r2,65535
 9093358:	1005003a 	cmpeq	r2,r2,zero
 909335c:	1000041e 	bne	r2,zero,9093370 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 9093360:	e0fffd17 	ldw	r3,-12(fp)
 9093364:	e0bffe0b 	ldhu	r2,-8(fp)
 9093368:	1880020d 	sth	r2,8(r3)
 909336c:	00000c06 	br	90933a0 <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 9093370:	e0bffd17 	ldw	r2,-12(fp)
 9093374:	10800283 	ldbu	r2,10(r2)
 9093378:	10803fcc 	andi	r2,r2,255
 909337c:	1004c03a 	cmpne	r2,r2,zero
 9093380:	1000041e 	bne	r2,zero,9093394 <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 9093384:	e0fffd17 	ldw	r3,-12(fp)
 9093388:	e0bffe0b 	ldhu	r2,-8(fp)
 909338c:	1880020d 	sth	r2,8(r3)
 9093390:	00000306 	br	90933a0 <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 9093394:	e0ffff17 	ldw	r3,-4(fp)
 9093398:	00801244 	movi	r2,73
 909339c:	18800005 	stb	r2,0(r3)
 90933a0:	e0bffc17 	ldw	r2,-16(fp)
 90933a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90933a8:	e0bffa17 	ldw	r2,-24(fp)
 90933ac:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 90933b0:	e037883a 	mov	sp,fp
 90933b4:	df000017 	ldw	fp,0(sp)
 90933b8:	dec00104 	addi	sp,sp,4
 90933bc:	f800283a 	ret

090933c0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 90933c0:	defff004 	addi	sp,sp,-64
 90933c4:	dfc00f15 	stw	ra,60(sp)
 90933c8:	df000e15 	stw	fp,56(sp)
 90933cc:	df000e04 	addi	fp,sp,56
 90933d0:	e13ffd05 	stb	r4,-12(fp)
 90933d4:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 90933d8:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 90933dc:	e0bffd03 	ldbu	r2,-12(fp)
 90933e0:	10800530 	cmpltui	r2,r2,20
 90933e4:	1000061e 	bne	r2,zero,9093400 <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 90933e8:	e0bffd03 	ldbu	r2,-12(fp)
 90933ec:	10803fe0 	cmpeqi	r2,r2,255
 90933f0:	1000031e 	bne	r2,zero,9093400 <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 90933f4:	00800a84 	movi	r2,42
 90933f8:	e0bfff15 	stw	r2,-4(fp)
 90933fc:	00014706 	br	909391c <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 9093400:	e0bffe03 	ldbu	r2,-8(fp)
 9093404:	10800530 	cmpltui	r2,r2,20
 9093408:	1000031e 	bne	r2,zero,9093418 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 909340c:	00800a84 	movi	r2,42
 9093410:	e0bfff15 	stw	r2,-4(fp)
 9093414:	00014106 	br	909391c <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093418:	0005303a 	rdctl	r2,status
 909341c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093420:	e0fff617 	ldw	r3,-40(fp)
 9093424:	00bfff84 	movi	r2,-2
 9093428:	1884703a 	and	r2,r3,r2
 909342c:	1001703a 	wrctl	status,r2
  
  return context;
 9093430:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9093434:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 9093438:	e0bffe03 	ldbu	r2,-8(fp)
 909343c:	00c243b4 	movhi	r3,2318
 9093440:	18f2ac04 	addi	r3,r3,-13648
 9093444:	1085883a 	add	r2,r2,r2
 9093448:	1085883a 	add	r2,r2,r2
 909344c:	10c5883a 	add	r2,r2,r3
 9093450:	10800017 	ldw	r2,0(r2)
 9093454:	1005003a 	cmpeq	r2,r2,zero
 9093458:	1000071e 	bne	r2,zero,9093478 <OSTaskChangePrio+0xb8>
 909345c:	e0bff717 	ldw	r2,-36(fp)
 9093460:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093464:	e0bff517 	ldw	r2,-44(fp)
 9093468:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 909346c:	00800a04 	movi	r2,40
 9093470:	e0bfff15 	stw	r2,-4(fp)
 9093474:	00012906 	br	909391c <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 9093478:	e0bffd03 	ldbu	r2,-12(fp)
 909347c:	10803fd8 	cmpnei	r2,r2,255
 9093480:	1000051e 	bne	r2,zero,9093498 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 9093484:	00824374 	movhi	r2,2317
 9093488:	108c1404 	addi	r2,r2,12368
 909348c:	10800017 	ldw	r2,0(r2)
 9093490:	10800c83 	ldbu	r2,50(r2)
 9093494:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 9093498:	e0bffd03 	ldbu	r2,-12(fp)
 909349c:	00c243b4 	movhi	r3,2318
 90934a0:	18f2ac04 	addi	r3,r3,-13648
 90934a4:	1085883a 	add	r2,r2,r2
 90934a8:	1085883a 	add	r2,r2,r2
 90934ac:	10c5883a 	add	r2,r2,r3
 90934b0:	10800017 	ldw	r2,0(r2)
 90934b4:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 90934b8:	e0bffa17 	ldw	r2,-24(fp)
 90934bc:	1004c03a 	cmpne	r2,r2,zero
 90934c0:	1000071e 	bne	r2,zero,90934e0 <OSTaskChangePrio+0x120>
 90934c4:	e0bff717 	ldw	r2,-36(fp)
 90934c8:	e0bff415 	stw	r2,-48(fp)
 90934cc:	e0bff417 	ldw	r2,-48(fp)
 90934d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 90934d4:	00800a44 	movi	r2,41
 90934d8:	e0bfff15 	stw	r2,-4(fp)
 90934dc:	00010f06 	br	909391c <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 90934e0:	e0bffa17 	ldw	r2,-24(fp)
 90934e4:	10800058 	cmpnei	r2,r2,1
 90934e8:	1000071e 	bne	r2,zero,9093508 <OSTaskChangePrio+0x148>
 90934ec:	e0bff717 	ldw	r2,-36(fp)
 90934f0:	e0bff315 	stw	r2,-52(fp)
 90934f4:	e0bff317 	ldw	r2,-52(fp)
 90934f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 90934fc:	008010c4 	movi	r2,67
 9093500:	e0bfff15 	stw	r2,-4(fp)
 9093504:	00010506 	br	909391c <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 9093508:	e0bffe03 	ldbu	r2,-8(fp)
 909350c:	1004d0fa 	srli	r2,r2,3
 9093510:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 9093514:	e0bffe03 	ldbu	r2,-8(fp)
 9093518:	108001cc 	andi	r2,r2,7
 909351c:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 9093520:	e0fff983 	ldbu	r3,-26(fp)
 9093524:	00800044 	movi	r2,1
 9093528:	10c4983a 	sll	r2,r2,r3
 909352c:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 9093530:	e0fff943 	ldbu	r3,-27(fp)
 9093534:	00800044 	movi	r2,1
 9093538:	10c4983a 	sll	r2,r2,r3
 909353c:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 9093540:	e0bffd03 	ldbu	r2,-12(fp)
 9093544:	00c243b4 	movhi	r3,2318
 9093548:	18f2ac04 	addi	r3,r3,-13648
 909354c:	1085883a 	add	r2,r2,r2
 9093550:	1085883a 	add	r2,r2,r2
 9093554:	10c5883a 	add	r2,r2,r3
 9093558:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 909355c:	e0bffe03 	ldbu	r2,-8(fp)
 9093560:	00c243b4 	movhi	r3,2318
 9093564:	18f2ac04 	addi	r3,r3,-13648
 9093568:	1085883a 	add	r2,r2,r2
 909356c:	1085883a 	add	r2,r2,r2
 9093570:	10c7883a 	add	r3,r2,r3
 9093574:	e0bffa17 	ldw	r2,-24(fp)
 9093578:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 909357c:	e0bffa17 	ldw	r2,-24(fp)
 9093580:	10800d03 	ldbu	r2,52(r2)
 9093584:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 9093588:	e0bffa17 	ldw	r2,-24(fp)
 909358c:	10800d83 	ldbu	r2,54(r2)
 9093590:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 9093594:	e0bffa17 	ldw	r2,-24(fp)
 9093598:	10800d43 	ldbu	r2,53(r2)
 909359c:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 90935a0:	e0fff903 	ldbu	r3,-28(fp)
 90935a4:	00824374 	movhi	r2,2317
 90935a8:	108c1144 	addi	r2,r2,12357
 90935ac:	10c5883a 	add	r2,r2,r3
 90935b0:	10c00003 	ldbu	r3,0(r2)
 90935b4:	e0bff803 	ldbu	r2,-32(fp)
 90935b8:	1884703a 	and	r2,r3,r2
 90935bc:	10803fcc 	andi	r2,r2,255
 90935c0:	1005003a 	cmpeq	r2,r2,zero
 90935c4:	1000381e 	bne	r2,zero,90936a8 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 90935c8:	e13ff903 	ldbu	r4,-28(fp)
 90935cc:	e0fff903 	ldbu	r3,-28(fp)
 90935d0:	00824374 	movhi	r2,2317
 90935d4:	108c1144 	addi	r2,r2,12357
 90935d8:	10c5883a 	add	r2,r2,r3
 90935dc:	10800003 	ldbu	r2,0(r2)
 90935e0:	1007883a 	mov	r3,r2
 90935e4:	e0bff803 	ldbu	r2,-32(fp)
 90935e8:	0084303a 	nor	r2,zero,r2
 90935ec:	1884703a 	and	r2,r3,r2
 90935f0:	1007883a 	mov	r3,r2
 90935f4:	00824374 	movhi	r2,2317
 90935f8:	108c1144 	addi	r2,r2,12357
 90935fc:	1105883a 	add	r2,r2,r4
 9093600:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 9093604:	e0fff903 	ldbu	r3,-28(fp)
 9093608:	00824374 	movhi	r2,2317
 909360c:	108c1144 	addi	r2,r2,12357
 9093610:	10c5883a 	add	r2,r2,r3
 9093614:	10800003 	ldbu	r2,0(r2)
 9093618:	10803fcc 	andi	r2,r2,255
 909361c:	1004c03a 	cmpne	r2,r2,zero
 9093620:	10000b1e 	bne	r2,zero,9093650 <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 9093624:	e0bff843 	ldbu	r2,-31(fp)
 9093628:	0084303a 	nor	r2,zero,r2
 909362c:	1007883a 	mov	r3,r2
 9093630:	00824374 	movhi	r2,2317
 9093634:	108c1104 	addi	r2,r2,12356
 9093638:	10800003 	ldbu	r2,0(r2)
 909363c:	1884703a 	and	r2,r3,r2
 9093640:	1007883a 	mov	r3,r2
 9093644:	00824374 	movhi	r2,2317
 9093648:	108c1104 	addi	r2,r2,12356
 909364c:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 9093650:	00824374 	movhi	r2,2317
 9093654:	108c1104 	addi	r2,r2,12356
 9093658:	10c00003 	ldbu	r3,0(r2)
 909365c:	e0bff8c3 	ldbu	r2,-29(fp)
 9093660:	1884b03a 	or	r2,r3,r2
 9093664:	1007883a 	mov	r3,r2
 9093668:	00824374 	movhi	r2,2317
 909366c:	108c1104 	addi	r2,r2,12356
 9093670:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 9093674:	e13ff983 	ldbu	r4,-26(fp)
 9093678:	e0fff983 	ldbu	r3,-26(fp)
 909367c:	00824374 	movhi	r2,2317
 9093680:	108c1144 	addi	r2,r2,12357
 9093684:	10c5883a 	add	r2,r2,r3
 9093688:	10c00003 	ldbu	r3,0(r2)
 909368c:	e0bff883 	ldbu	r2,-30(fp)
 9093690:	1884b03a 	or	r2,r3,r2
 9093694:	1007883a 	mov	r3,r2
 9093698:	00824374 	movhi	r2,2317
 909369c:	108c1144 	addi	r2,r2,12357
 90936a0:	1105883a 	add	r2,r2,r4
 90936a4:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 90936a8:	e0bffa17 	ldw	r2,-24(fp)
 90936ac:	10800717 	ldw	r2,28(r2)
 90936b0:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 90936b4:	e0bffc17 	ldw	r2,-16(fp)
 90936b8:	1005003a 	cmpeq	r2,r2,zero
 90936bc:	1000341e 	bne	r2,zero,9093790 <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 90936c0:	e13ff903 	ldbu	r4,-28(fp)
 90936c4:	e0fff903 	ldbu	r3,-28(fp)
 90936c8:	e0bffc17 	ldw	r2,-16(fp)
 90936cc:	1885883a 	add	r2,r3,r2
 90936d0:	10800204 	addi	r2,r2,8
 90936d4:	108000c3 	ldbu	r2,3(r2)
 90936d8:	1007883a 	mov	r3,r2
 90936dc:	e0bff803 	ldbu	r2,-32(fp)
 90936e0:	0084303a 	nor	r2,zero,r2
 90936e4:	1884703a 	and	r2,r3,r2
 90936e8:	1007883a 	mov	r3,r2
 90936ec:	e0bffc17 	ldw	r2,-16(fp)
 90936f0:	2085883a 	add	r2,r4,r2
 90936f4:	10800204 	addi	r2,r2,8
 90936f8:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 90936fc:	e0fff903 	ldbu	r3,-28(fp)
 9093700:	e0bffc17 	ldw	r2,-16(fp)
 9093704:	1885883a 	add	r2,r3,r2
 9093708:	10800204 	addi	r2,r2,8
 909370c:	108000c3 	ldbu	r2,3(r2)
 9093710:	10803fcc 	andi	r2,r2,255
 9093714:	1004c03a 	cmpne	r2,r2,zero
 9093718:	1000091e 	bne	r2,zero,9093740 <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 909371c:	e0bffc17 	ldw	r2,-16(fp)
 9093720:	10800283 	ldbu	r2,10(r2)
 9093724:	1007883a 	mov	r3,r2
 9093728:	e0bff843 	ldbu	r2,-31(fp)
 909372c:	0084303a 	nor	r2,zero,r2
 9093730:	1884703a 	and	r2,r3,r2
 9093734:	1007883a 	mov	r3,r2
 9093738:	e0bffc17 	ldw	r2,-16(fp)
 909373c:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 9093740:	e0bffc17 	ldw	r2,-16(fp)
 9093744:	10c00283 	ldbu	r3,10(r2)
 9093748:	e0bff8c3 	ldbu	r2,-29(fp)
 909374c:	1884b03a 	or	r2,r3,r2
 9093750:	1007883a 	mov	r3,r2
 9093754:	e0bffc17 	ldw	r2,-16(fp)
 9093758:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 909375c:	e13ff983 	ldbu	r4,-26(fp)
 9093760:	e0fff983 	ldbu	r3,-26(fp)
 9093764:	e0bffc17 	ldw	r2,-16(fp)
 9093768:	1885883a 	add	r2,r3,r2
 909376c:	10800204 	addi	r2,r2,8
 9093770:	10c000c3 	ldbu	r3,3(r2)
 9093774:	e0bff883 	ldbu	r2,-30(fp)
 9093778:	1884b03a 	or	r2,r3,r2
 909377c:	1007883a 	mov	r3,r2
 9093780:	e0bffc17 	ldw	r2,-16(fp)
 9093784:	2085883a 	add	r2,r4,r2
 9093788:	10800204 	addi	r2,r2,8
 909378c:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 9093790:	e0bffa17 	ldw	r2,-24(fp)
 9093794:	10800817 	ldw	r2,32(r2)
 9093798:	1005003a 	cmpeq	r2,r2,zero
 909379c:	1000441e 	bne	r2,zero,90938b0 <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 90937a0:	e0bffa17 	ldw	r2,-24(fp)
 90937a4:	10800817 	ldw	r2,32(r2)
 90937a8:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 90937ac:	e0bffb17 	ldw	r2,-20(fp)
 90937b0:	10800017 	ldw	r2,0(r2)
 90937b4:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 90937b8:	00003a06 	br	90938a4 <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 90937bc:	e13ff903 	ldbu	r4,-28(fp)
 90937c0:	e0fff903 	ldbu	r3,-28(fp)
 90937c4:	e0bffc17 	ldw	r2,-16(fp)
 90937c8:	1885883a 	add	r2,r3,r2
 90937cc:	10800204 	addi	r2,r2,8
 90937d0:	108000c3 	ldbu	r2,3(r2)
 90937d4:	1007883a 	mov	r3,r2
 90937d8:	e0bff803 	ldbu	r2,-32(fp)
 90937dc:	0084303a 	nor	r2,zero,r2
 90937e0:	1884703a 	and	r2,r3,r2
 90937e4:	1007883a 	mov	r3,r2
 90937e8:	e0bffc17 	ldw	r2,-16(fp)
 90937ec:	2085883a 	add	r2,r4,r2
 90937f0:	10800204 	addi	r2,r2,8
 90937f4:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 90937f8:	e0fff903 	ldbu	r3,-28(fp)
 90937fc:	e0bffc17 	ldw	r2,-16(fp)
 9093800:	1885883a 	add	r2,r3,r2
 9093804:	10800204 	addi	r2,r2,8
 9093808:	108000c3 	ldbu	r2,3(r2)
 909380c:	10803fcc 	andi	r2,r2,255
 9093810:	1004c03a 	cmpne	r2,r2,zero
 9093814:	1000091e 	bne	r2,zero,909383c <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 9093818:	e0bffc17 	ldw	r2,-16(fp)
 909381c:	10800283 	ldbu	r2,10(r2)
 9093820:	1007883a 	mov	r3,r2
 9093824:	e0bff843 	ldbu	r2,-31(fp)
 9093828:	0084303a 	nor	r2,zero,r2
 909382c:	1884703a 	and	r2,r3,r2
 9093830:	1007883a 	mov	r3,r2
 9093834:	e0bffc17 	ldw	r2,-16(fp)
 9093838:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 909383c:	e0bffc17 	ldw	r2,-16(fp)
 9093840:	10c00283 	ldbu	r3,10(r2)
 9093844:	e0bff8c3 	ldbu	r2,-29(fp)
 9093848:	1884b03a 	or	r2,r3,r2
 909384c:	1007883a 	mov	r3,r2
 9093850:	e0bffc17 	ldw	r2,-16(fp)
 9093854:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 9093858:	e13ff983 	ldbu	r4,-26(fp)
 909385c:	e0fff983 	ldbu	r3,-26(fp)
 9093860:	e0bffc17 	ldw	r2,-16(fp)
 9093864:	1885883a 	add	r2,r3,r2
 9093868:	10800204 	addi	r2,r2,8
 909386c:	10c000c3 	ldbu	r3,3(r2)
 9093870:	e0bff883 	ldbu	r2,-30(fp)
 9093874:	1884b03a 	or	r2,r3,r2
 9093878:	1007883a 	mov	r3,r2
 909387c:	e0bffc17 	ldw	r2,-16(fp)
 9093880:	2085883a 	add	r2,r4,r2
 9093884:	10800204 	addi	r2,r2,8
 9093888:	10c000c5 	stb	r3,3(r2)
            pevents++;
 909388c:	e0bffb17 	ldw	r2,-20(fp)
 9093890:	10800104 	addi	r2,r2,4
 9093894:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 9093898:	e0bffb17 	ldw	r2,-20(fp)
 909389c:	10800017 	ldw	r2,0(r2)
 90938a0:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 90938a4:	e0bffc17 	ldw	r2,-16(fp)
 90938a8:	1004c03a 	cmpne	r2,r2,zero
 90938ac:	103fc31e 	bne	r2,zero,90937bc <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 90938b0:	e0fffa17 	ldw	r3,-24(fp)
 90938b4:	e0bffe03 	ldbu	r2,-8(fp)
 90938b8:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 90938bc:	e0fffa17 	ldw	r3,-24(fp)
 90938c0:	e0bff983 	ldbu	r2,-26(fp)
 90938c4:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 90938c8:	e0fffa17 	ldw	r3,-24(fp)
 90938cc:	e0bff943 	ldbu	r2,-27(fp)
 90938d0:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 90938d4:	e0fffa17 	ldw	r3,-24(fp)
 90938d8:	e0bff8c3 	ldbu	r2,-29(fp)
 90938dc:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 90938e0:	e0fffa17 	ldw	r3,-24(fp)
 90938e4:	e0bff883 	ldbu	r2,-30(fp)
 90938e8:	18800d45 	stb	r2,53(r3)
 90938ec:	e0bff717 	ldw	r2,-36(fp)
 90938f0:	e0bff215 	stw	r2,-56(fp)
 90938f4:	e0bff217 	ldw	r2,-56(fp)
 90938f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 90938fc:	00824374 	movhi	r2,2317
 9093900:	108c0544 	addi	r2,r2,12309
 9093904:	10800003 	ldbu	r2,0(r2)
 9093908:	10803fcc 	andi	r2,r2,255
 909390c:	10800058 	cmpnei	r2,r2,1
 9093910:	1000011e 	bne	r2,zero,9093918 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 9093914:	908eaf40 	call	908eaf4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 9093918:	e03fff15 	stw	zero,-4(fp)
 909391c:	e0bfff17 	ldw	r2,-4(fp)
}
 9093920:	e037883a 	mov	sp,fp
 9093924:	dfc00117 	ldw	ra,4(sp)
 9093928:	df000017 	ldw	fp,0(sp)
 909392c:	dec00204 	addi	sp,sp,8
 9093930:	f800283a 	ret

09093934 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 9093934:	deffed04 	addi	sp,sp,-76
 9093938:	dfc01215 	stw	ra,72(sp)
 909393c:	df001115 	stw	fp,68(sp)
 9093940:	df001104 	addi	fp,sp,68
 9093944:	e13ffb15 	stw	r4,-20(fp)
 9093948:	e17ffc15 	stw	r5,-16(fp)
 909394c:	e1bffd15 	stw	r6,-12(fp)
 9093950:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 9093954:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 9093958:	e0bffe03 	ldbu	r2,-8(fp)
 909395c:	10800570 	cmpltui	r2,r2,21
 9093960:	1000031e 	bne	r2,zero,9093970 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 9093964:	00800a84 	movi	r2,42
 9093968:	e0bfff15 	stw	r2,-4(fp)
 909396c:	00006006 	br	9093af0 <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093970:	0005303a 	rdctl	r2,status
 9093974:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093978:	e0fff717 	ldw	r3,-36(fp)
 909397c:	00bfff84 	movi	r2,-2
 9093980:	1884703a 	and	r2,r3,r2
 9093984:	1001703a 	wrctl	status,r2
  
  return context;
 9093988:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909398c:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 9093990:	00824374 	movhi	r2,2317
 9093994:	108c1304 	addi	r2,r2,12364
 9093998:	10800003 	ldbu	r2,0(r2)
 909399c:	10803fcc 	andi	r2,r2,255
 90939a0:	1005003a 	cmpeq	r2,r2,zero
 90939a4:	1000071e 	bne	r2,zero,90939c4 <OSTaskCreate+0x90>
 90939a8:	e0bff817 	ldw	r2,-32(fp)
 90939ac:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90939b0:	e0bff617 	ldw	r2,-40(fp)
 90939b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 90939b8:	00800f04 	movi	r2,60
 90939bc:	e0bfff15 	stw	r2,-4(fp)
 90939c0:	00004b06 	br	9093af0 <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 90939c4:	e0bffe03 	ldbu	r2,-8(fp)
 90939c8:	00c243b4 	movhi	r3,2318
 90939cc:	18f2ac04 	addi	r3,r3,-13648
 90939d0:	1085883a 	add	r2,r2,r2
 90939d4:	1085883a 	add	r2,r2,r2
 90939d8:	10c5883a 	add	r2,r2,r3
 90939dc:	10800017 	ldw	r2,0(r2)
 90939e0:	1004c03a 	cmpne	r2,r2,zero
 90939e4:	10003c1e 	bne	r2,zero,9093ad8 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 90939e8:	e0bffe03 	ldbu	r2,-8(fp)
 90939ec:	00c243b4 	movhi	r3,2318
 90939f0:	18f2ac04 	addi	r3,r3,-13648
 90939f4:	1085883a 	add	r2,r2,r2
 90939f8:	1085883a 	add	r2,r2,r2
 90939fc:	10c7883a 	add	r3,r2,r3
 9093a00:	00800044 	movi	r2,1
 9093a04:	18800015 	stw	r2,0(r3)
 9093a08:	e0bff817 	ldw	r2,-32(fp)
 9093a0c:	e0bff515 	stw	r2,-44(fp)
 9093a10:	e0bff517 	ldw	r2,-44(fp)
 9093a14:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 9093a18:	e13ffb17 	ldw	r4,-20(fp)
 9093a1c:	e17ffc17 	ldw	r5,-16(fp)
 9093a20:	e1bffd17 	ldw	r6,-12(fp)
 9093a24:	000f883a 	mov	r7,zero
 9093a28:	90b9f340 	call	90b9f34 <OSTaskStkInit>
 9093a2c:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 9093a30:	e13ffe03 	ldbu	r4,-8(fp)
 9093a34:	d8000015 	stw	zero,0(sp)
 9093a38:	d8000115 	stw	zero,4(sp)
 9093a3c:	d8000215 	stw	zero,8(sp)
 9093a40:	e17ffa17 	ldw	r5,-24(fp)
 9093a44:	000d883a 	mov	r6,zero
 9093a48:	000f883a 	mov	r7,zero
 9093a4c:	908ef140 	call	908ef14 <OS_TCBInit>
 9093a50:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 9093a54:	e0bff903 	ldbu	r2,-28(fp)
 9093a58:	1004c03a 	cmpne	r2,r2,zero
 9093a5c:	1000081e 	bne	r2,zero,9093a80 <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 9093a60:	00824374 	movhi	r2,2317
 9093a64:	108c0544 	addi	r2,r2,12309
 9093a68:	10800003 	ldbu	r2,0(r2)
 9093a6c:	10803fcc 	andi	r2,r2,255
 9093a70:	10800058 	cmpnei	r2,r2,1
 9093a74:	1000151e 	bne	r2,zero,9093acc <OSTaskCreate+0x198>
                OS_Sched();
 9093a78:	908eaf40 	call	908eaf4 <OS_Sched>
 9093a7c:	00001306 	br	9093acc <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093a80:	0005303a 	rdctl	r2,status
 9093a84:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093a88:	e0fff417 	ldw	r3,-48(fp)
 9093a8c:	00bfff84 	movi	r2,-2
 9093a90:	1884703a 	and	r2,r3,r2
 9093a94:	1001703a 	wrctl	status,r2
  
  return context;
 9093a98:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 9093a9c:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 9093aa0:	e0bffe03 	ldbu	r2,-8(fp)
 9093aa4:	00c243b4 	movhi	r3,2318
 9093aa8:	18f2ac04 	addi	r3,r3,-13648
 9093aac:	1085883a 	add	r2,r2,r2
 9093ab0:	1085883a 	add	r2,r2,r2
 9093ab4:	10c5883a 	add	r2,r2,r3
 9093ab8:	10000015 	stw	zero,0(r2)
 9093abc:	e0bff817 	ldw	r2,-32(fp)
 9093ac0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093ac4:	e0bff317 	ldw	r2,-52(fp)
 9093ac8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 9093acc:	e0bff903 	ldbu	r2,-28(fp)
 9093ad0:	e0bfff15 	stw	r2,-4(fp)
 9093ad4:	00000606 	br	9093af0 <OSTaskCreate+0x1bc>
 9093ad8:	e0bff817 	ldw	r2,-32(fp)
 9093adc:	e0bff215 	stw	r2,-56(fp)
 9093ae0:	e0bff217 	ldw	r2,-56(fp)
 9093ae4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 9093ae8:	00800a04 	movi	r2,40
 9093aec:	e0bfff15 	stw	r2,-4(fp)
 9093af0:	e0bfff17 	ldw	r2,-4(fp)
}
 9093af4:	e037883a 	mov	sp,fp
 9093af8:	dfc00117 	ldw	ra,4(sp)
 9093afc:	df000017 	ldw	fp,0(sp)
 9093b00:	dec00204 	addi	sp,sp,8
 9093b04:	f800283a 	ret

09093b08 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 9093b08:	deffeb04 	addi	sp,sp,-84
 9093b0c:	dfc01415 	stw	ra,80(sp)
 9093b10:	df001315 	stw	fp,76(sp)
 9093b14:	df001304 	addi	fp,sp,76
 9093b18:	e13ff915 	stw	r4,-28(fp)
 9093b1c:	e17ffa15 	stw	r5,-24(fp)
 9093b20:	e1bffb15 	stw	r6,-20(fp)
 9093b24:	e0800217 	ldw	r2,8(fp)
 9093b28:	e0c00617 	ldw	r3,24(fp)
 9093b2c:	e1fffc05 	stb	r7,-16(fp)
 9093b30:	e0bffd0d 	sth	r2,-12(fp)
 9093b34:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 9093b38:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 9093b3c:	e0bffc03 	ldbu	r2,-16(fp)
 9093b40:	10800570 	cmpltui	r2,r2,21
 9093b44:	1000031e 	bne	r2,zero,9093b54 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 9093b48:	00800a84 	movi	r2,42
 9093b4c:	e0bfff15 	stw	r2,-4(fp)
 9093b50:	00006706 	br	9093cf0 <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093b54:	0005303a 	rdctl	r2,status
 9093b58:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093b5c:	e0fff517 	ldw	r3,-44(fp)
 9093b60:	00bfff84 	movi	r2,-2
 9093b64:	1884703a 	and	r2,r3,r2
 9093b68:	1001703a 	wrctl	status,r2
  
  return context;
 9093b6c:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9093b70:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 9093b74:	00824374 	movhi	r2,2317
 9093b78:	108c1304 	addi	r2,r2,12364
 9093b7c:	10800003 	ldbu	r2,0(r2)
 9093b80:	10803fcc 	andi	r2,r2,255
 9093b84:	1005003a 	cmpeq	r2,r2,zero
 9093b88:	1000071e 	bne	r2,zero,9093ba8 <OSTaskCreateExt+0xa0>
 9093b8c:	e0bff617 	ldw	r2,-40(fp)
 9093b90:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093b94:	e0bff417 	ldw	r2,-48(fp)
 9093b98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 9093b9c:	00800f04 	movi	r2,60
 9093ba0:	e0bfff15 	stw	r2,-4(fp)
 9093ba4:	00005206 	br	9093cf0 <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 9093ba8:	e0bffc03 	ldbu	r2,-16(fp)
 9093bac:	00c243b4 	movhi	r3,2318
 9093bb0:	18f2ac04 	addi	r3,r3,-13648
 9093bb4:	1085883a 	add	r2,r2,r2
 9093bb8:	1085883a 	add	r2,r2,r2
 9093bbc:	10c5883a 	add	r2,r2,r3
 9093bc0:	10800017 	ldw	r2,0(r2)
 9093bc4:	1004c03a 	cmpne	r2,r2,zero
 9093bc8:	1000431e 	bne	r2,zero,9093cd8 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 9093bcc:	e0bffc03 	ldbu	r2,-16(fp)
 9093bd0:	00c243b4 	movhi	r3,2318
 9093bd4:	18f2ac04 	addi	r3,r3,-13648
 9093bd8:	1085883a 	add	r2,r2,r2
 9093bdc:	1085883a 	add	r2,r2,r2
 9093be0:	10c7883a 	add	r3,r2,r3
 9093be4:	00800044 	movi	r2,1
 9093be8:	18800015 	stw	r2,0(r3)
 9093bec:	e0bff617 	ldw	r2,-40(fp)
 9093bf0:	e0bff315 	stw	r2,-52(fp)
 9093bf4:	e0bff317 	ldw	r2,-52(fp)
 9093bf8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 9093bfc:	e1bffe0b 	ldhu	r6,-8(fp)
 9093c00:	e1000317 	ldw	r4,12(fp)
 9093c04:	e1400417 	ldw	r5,16(fp)
 9093c08:	9094d840 	call	9094d84 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 9093c0c:	e1fffe0b 	ldhu	r7,-8(fp)
 9093c10:	e13ff917 	ldw	r4,-28(fp)
 9093c14:	e17ffa17 	ldw	r5,-24(fp)
 9093c18:	e1bffb17 	ldw	r6,-20(fp)
 9093c1c:	90b9f340 	call	90b9f34 <OSTaskStkInit>
 9093c20:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 9093c24:	e13ffc03 	ldbu	r4,-16(fp)
 9093c28:	e1fffd0b 	ldhu	r7,-12(fp)
 9093c2c:	e0fffe0b 	ldhu	r3,-8(fp)
 9093c30:	e0800417 	ldw	r2,16(fp)
 9093c34:	d8800015 	stw	r2,0(sp)
 9093c38:	e0800517 	ldw	r2,20(fp)
 9093c3c:	d8800115 	stw	r2,4(sp)
 9093c40:	d8c00215 	stw	r3,8(sp)
 9093c44:	e17ff817 	ldw	r5,-32(fp)
 9093c48:	e1800317 	ldw	r6,12(fp)
 9093c4c:	908ef140 	call	908ef14 <OS_TCBInit>
 9093c50:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 9093c54:	e0bff703 	ldbu	r2,-36(fp)
 9093c58:	1004c03a 	cmpne	r2,r2,zero
 9093c5c:	1000081e 	bne	r2,zero,9093c80 <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 9093c60:	00824374 	movhi	r2,2317
 9093c64:	108c0544 	addi	r2,r2,12309
 9093c68:	10800003 	ldbu	r2,0(r2)
 9093c6c:	10803fcc 	andi	r2,r2,255
 9093c70:	10800058 	cmpnei	r2,r2,1
 9093c74:	1000151e 	bne	r2,zero,9093ccc <OSTaskCreateExt+0x1c4>
                OS_Sched();
 9093c78:	908eaf40 	call	908eaf4 <OS_Sched>
 9093c7c:	00001306 	br	9093ccc <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093c80:	0005303a 	rdctl	r2,status
 9093c84:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093c88:	e0fff217 	ldw	r3,-56(fp)
 9093c8c:	00bfff84 	movi	r2,-2
 9093c90:	1884703a 	and	r2,r3,r2
 9093c94:	1001703a 	wrctl	status,r2
  
  return context;
 9093c98:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 9093c9c:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 9093ca0:	e0bffc03 	ldbu	r2,-16(fp)
 9093ca4:	00c243b4 	movhi	r3,2318
 9093ca8:	18f2ac04 	addi	r3,r3,-13648
 9093cac:	1085883a 	add	r2,r2,r2
 9093cb0:	1085883a 	add	r2,r2,r2
 9093cb4:	10c5883a 	add	r2,r2,r3
 9093cb8:	10000015 	stw	zero,0(r2)
 9093cbc:	e0bff617 	ldw	r2,-40(fp)
 9093cc0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093cc4:	e0bff117 	ldw	r2,-60(fp)
 9093cc8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 9093ccc:	e0bff703 	ldbu	r2,-36(fp)
 9093cd0:	e0bfff15 	stw	r2,-4(fp)
 9093cd4:	00000606 	br	9093cf0 <OSTaskCreateExt+0x1e8>
 9093cd8:	e0bff617 	ldw	r2,-40(fp)
 9093cdc:	e0bff015 	stw	r2,-64(fp)
 9093ce0:	e0bff017 	ldw	r2,-64(fp)
 9093ce4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 9093ce8:	00800a04 	movi	r2,40
 9093cec:	e0bfff15 	stw	r2,-4(fp)
 9093cf0:	e0bfff17 	ldw	r2,-4(fp)
}
 9093cf4:	e037883a 	mov	sp,fp
 9093cf8:	dfc00117 	ldw	ra,4(sp)
 9093cfc:	df000017 	ldw	fp,0(sp)
 9093d00:	dec00204 	addi	sp,sp,8
 9093d04:	f800283a 	ret

09093d08 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 9093d08:	defff304 	addi	sp,sp,-52
 9093d0c:	dfc00c15 	stw	ra,48(sp)
 9093d10:	df000b15 	stw	fp,44(sp)
 9093d14:	df000b04 	addi	fp,sp,44
 9093d18:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 9093d1c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 9093d20:	00824374 	movhi	r2,2317
 9093d24:	108c1304 	addi	r2,r2,12364
 9093d28:	10800003 	ldbu	r2,0(r2)
 9093d2c:	10803fcc 	andi	r2,r2,255
 9093d30:	1005003a 	cmpeq	r2,r2,zero
 9093d34:	1000031e 	bne	r2,zero,9093d44 <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 9093d38:	00801004 	movi	r2,64
 9093d3c:	e0bfff15 	stw	r2,-4(fp)
 9093d40:	0000ee06 	br	90940fc <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 9093d44:	e0bffe03 	ldbu	r2,-8(fp)
 9093d48:	10800518 	cmpnei	r2,r2,20
 9093d4c:	1000031e 	bne	r2,zero,9093d5c <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 9093d50:	00800f84 	movi	r2,62
 9093d54:	e0bfff15 	stw	r2,-4(fp)
 9093d58:	0000e806 	br	90940fc <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 9093d5c:	e0bffe03 	ldbu	r2,-8(fp)
 9093d60:	10800530 	cmpltui	r2,r2,20
 9093d64:	1000061e 	bne	r2,zero,9093d80 <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 9093d68:	e0bffe03 	ldbu	r2,-8(fp)
 9093d6c:	10803fe0 	cmpeqi	r2,r2,255
 9093d70:	1000031e 	bne	r2,zero,9093d80 <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 9093d74:	00800a84 	movi	r2,42
 9093d78:	e0bfff15 	stw	r2,-4(fp)
 9093d7c:	0000df06 	br	90940fc <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093d80:	0005303a 	rdctl	r2,status
 9093d84:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093d88:	e0fffa17 	ldw	r3,-24(fp)
 9093d8c:	00bfff84 	movi	r2,-2
 9093d90:	1884703a 	and	r2,r3,r2
 9093d94:	1001703a 	wrctl	status,r2
  
  return context;
 9093d98:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 9093d9c:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 9093da0:	e0bffe03 	ldbu	r2,-8(fp)
 9093da4:	10803fd8 	cmpnei	r2,r2,255
 9093da8:	1000051e 	bne	r2,zero,9093dc0 <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 9093dac:	00824374 	movhi	r2,2317
 9093db0:	108c1404 	addi	r2,r2,12368
 9093db4:	10800017 	ldw	r2,0(r2)
 9093db8:	10800c83 	ldbu	r2,50(r2)
 9093dbc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9093dc0:	e0bffe03 	ldbu	r2,-8(fp)
 9093dc4:	00c243b4 	movhi	r3,2318
 9093dc8:	18f2ac04 	addi	r3,r3,-13648
 9093dcc:	1085883a 	add	r2,r2,r2
 9093dd0:	1085883a 	add	r2,r2,r2
 9093dd4:	10c5883a 	add	r2,r2,r3
 9093dd8:	10800017 	ldw	r2,0(r2)
 9093ddc:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 9093de0:	e0bffc17 	ldw	r2,-16(fp)
 9093de4:	1004c03a 	cmpne	r2,r2,zero
 9093de8:	1000071e 	bne	r2,zero,9093e08 <OSTaskDel+0x100>
 9093dec:	e0bffb17 	ldw	r2,-20(fp)
 9093df0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093df4:	e0bff917 	ldw	r2,-28(fp)
 9093df8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9093dfc:	008010c4 	movi	r2,67
 9093e00:	e0bfff15 	stw	r2,-4(fp)
 9093e04:	0000bd06 	br	90940fc <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 9093e08:	e0bffc17 	ldw	r2,-16(fp)
 9093e0c:	10800058 	cmpnei	r2,r2,1
 9093e10:	1000071e 	bne	r2,zero,9093e30 <OSTaskDel+0x128>
 9093e14:	e0bffb17 	ldw	r2,-20(fp)
 9093e18:	e0bff815 	stw	r2,-32(fp)
 9093e1c:	e0bff817 	ldw	r2,-32(fp)
 9093e20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 9093e24:	00800f44 	movi	r2,61
 9093e28:	e0bfff15 	stw	r2,-4(fp)
 9093e2c:	0000b306 	br	90940fc <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 9093e30:	e0bffc17 	ldw	r2,-16(fp)
 9093e34:	10800d03 	ldbu	r2,52(r2)
 9093e38:	11003fcc 	andi	r4,r2,255
 9093e3c:	e0bffc17 	ldw	r2,-16(fp)
 9093e40:	10800d03 	ldbu	r2,52(r2)
 9093e44:	10c03fcc 	andi	r3,r2,255
 9093e48:	00824374 	movhi	r2,2317
 9093e4c:	108c1144 	addi	r2,r2,12357
 9093e50:	10c5883a 	add	r2,r2,r3
 9093e54:	10800003 	ldbu	r2,0(r2)
 9093e58:	1007883a 	mov	r3,r2
 9093e5c:	e0bffc17 	ldw	r2,-16(fp)
 9093e60:	10800d43 	ldbu	r2,53(r2)
 9093e64:	0084303a 	nor	r2,zero,r2
 9093e68:	1884703a 	and	r2,r3,r2
 9093e6c:	1007883a 	mov	r3,r2
 9093e70:	00824374 	movhi	r2,2317
 9093e74:	108c1144 	addi	r2,r2,12357
 9093e78:	1105883a 	add	r2,r2,r4
 9093e7c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 9093e80:	e0bffc17 	ldw	r2,-16(fp)
 9093e84:	10800d03 	ldbu	r2,52(r2)
 9093e88:	10c03fcc 	andi	r3,r2,255
 9093e8c:	00824374 	movhi	r2,2317
 9093e90:	108c1144 	addi	r2,r2,12357
 9093e94:	10c5883a 	add	r2,r2,r3
 9093e98:	10800003 	ldbu	r2,0(r2)
 9093e9c:	10803fcc 	andi	r2,r2,255
 9093ea0:	1004c03a 	cmpne	r2,r2,zero
 9093ea4:	10000c1e 	bne	r2,zero,9093ed8 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 9093ea8:	e0bffc17 	ldw	r2,-16(fp)
 9093eac:	10800d83 	ldbu	r2,54(r2)
 9093eb0:	0084303a 	nor	r2,zero,r2
 9093eb4:	1007883a 	mov	r3,r2
 9093eb8:	00824374 	movhi	r2,2317
 9093ebc:	108c1104 	addi	r2,r2,12356
 9093ec0:	10800003 	ldbu	r2,0(r2)
 9093ec4:	1884703a 	and	r2,r3,r2
 9093ec8:	1007883a 	mov	r3,r2
 9093ecc:	00824374 	movhi	r2,2317
 9093ed0:	108c1104 	addi	r2,r2,12356
 9093ed4:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 9093ed8:	e0bffc17 	ldw	r2,-16(fp)
 9093edc:	10800717 	ldw	r2,28(r2)
 9093ee0:	1005003a 	cmpeq	r2,r2,zero
 9093ee4:	1000041e 	bne	r2,zero,9093ef8 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 9093ee8:	e0bffc17 	ldw	r2,-16(fp)
 9093eec:	11400717 	ldw	r5,28(r2)
 9093ef0:	e13ffc17 	ldw	r4,-16(fp)
 9093ef4:	908e4ac0 	call	908e4ac <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 9093ef8:	e0bffc17 	ldw	r2,-16(fp)
 9093efc:	10800817 	ldw	r2,32(r2)
 9093f00:	1005003a 	cmpeq	r2,r2,zero
 9093f04:	1000041e 	bne	r2,zero,9093f18 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 9093f08:	e0bffc17 	ldw	r2,-16(fp)
 9093f0c:	11400817 	ldw	r5,32(r2)
 9093f10:	e13ffc17 	ldw	r4,-16(fp)
 9093f14:	908e5640 	call	908e564 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 9093f18:	e0bffc17 	ldw	r2,-16(fp)
 9093f1c:	10800a17 	ldw	r2,40(r2)
 9093f20:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 9093f24:	e0bffd17 	ldw	r2,-12(fp)
 9093f28:	1005003a 	cmpeq	r2,r2,zero
 9093f2c:	1000021e 	bne	r2,zero,9093f38 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 9093f30:	e13ffd17 	ldw	r4,-12(fp)
 9093f34:	9090c100 	call	9090c10 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 9093f38:	e0bffc17 	ldw	r2,-16(fp)
 9093f3c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 9093f40:	e0bffc17 	ldw	r2,-16(fp)
 9093f44:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 9093f48:	e0bffc17 	ldw	r2,-16(fp)
 9093f4c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 9093f50:	00824374 	movhi	r2,2317
 9093f54:	108c0504 	addi	r2,r2,12308
 9093f58:	10800003 	ldbu	r2,0(r2)
 9093f5c:	10803fcc 	andi	r2,r2,255
 9093f60:	10803fe0 	cmpeqi	r2,r2,255
 9093f64:	1000081e 	bne	r2,zero,9093f88 <OSTaskDel+0x280>
        OSLockNesting++;
 9093f68:	00824374 	movhi	r2,2317
 9093f6c:	108c0504 	addi	r2,r2,12308
 9093f70:	10800003 	ldbu	r2,0(r2)
 9093f74:	10800044 	addi	r2,r2,1
 9093f78:	1007883a 	mov	r3,r2
 9093f7c:	00824374 	movhi	r2,2317
 9093f80:	108c0504 	addi	r2,r2,12308
 9093f84:	10c00005 	stb	r3,0(r2)
 9093f88:	e0bffb17 	ldw	r2,-20(fp)
 9093f8c:	e0bff715 	stw	r2,-36(fp)
 9093f90:	e0bff717 	ldw	r2,-36(fp)
 9093f94:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 9093f98:	908e0980 	call	908e098 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093f9c:	0005303a 	rdctl	r2,status
 9093fa0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093fa4:	e0fff617 	ldw	r3,-40(fp)
 9093fa8:	00bfff84 	movi	r2,-2
 9093fac:	1884703a 	and	r2,r3,r2
 9093fb0:	1001703a 	wrctl	status,r2
  
  return context;
 9093fb4:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 9093fb8:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 9093fbc:	00824374 	movhi	r2,2317
 9093fc0:	108c0504 	addi	r2,r2,12308
 9093fc4:	10800003 	ldbu	r2,0(r2)
 9093fc8:	10803fcc 	andi	r2,r2,255
 9093fcc:	1005003a 	cmpeq	r2,r2,zero
 9093fd0:	1000081e 	bne	r2,zero,9093ff4 <OSTaskDel+0x2ec>
        OSLockNesting--;
 9093fd4:	00824374 	movhi	r2,2317
 9093fd8:	108c0504 	addi	r2,r2,12308
 9093fdc:	10800003 	ldbu	r2,0(r2)
 9093fe0:	10bfffc4 	addi	r2,r2,-1
 9093fe4:	1007883a 	mov	r3,r2
 9093fe8:	00824374 	movhi	r2,2317
 9093fec:	108c0504 	addi	r2,r2,12308
 9093ff0:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 9093ff4:	e13ffc17 	ldw	r4,-16(fp)
 9093ff8:	90ba2640 	call	90ba264 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 9093ffc:	00824374 	movhi	r2,2317
 9094000:	108c0d44 	addi	r2,r2,12341
 9094004:	10800003 	ldbu	r2,0(r2)
 9094008:	10bfffc4 	addi	r2,r2,-1
 909400c:	1007883a 	mov	r3,r2
 9094010:	00824374 	movhi	r2,2317
 9094014:	108c0d44 	addi	r2,r2,12341
 9094018:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 909401c:	e0bffe03 	ldbu	r2,-8(fp)
 9094020:	00c243b4 	movhi	r3,2318
 9094024:	18f2ac04 	addi	r3,r3,-13648
 9094028:	1085883a 	add	r2,r2,r2
 909402c:	1085883a 	add	r2,r2,r2
 9094030:	10c5883a 	add	r2,r2,r3
 9094034:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 9094038:	e0bffc17 	ldw	r2,-16(fp)
 909403c:	10800617 	ldw	r2,24(r2)
 9094040:	1004c03a 	cmpne	r2,r2,zero
 9094044:	1000091e 	bne	r2,zero,909406c <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 9094048:	e0bffc17 	ldw	r2,-16(fp)
 909404c:	10800517 	ldw	r2,20(r2)
 9094050:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 9094054:	e0bffc17 	ldw	r2,-16(fp)
 9094058:	10c00517 	ldw	r3,20(r2)
 909405c:	00824374 	movhi	r2,2317
 9094060:	108c0804 	addi	r2,r2,12320
 9094064:	10c00015 	stw	r3,0(r2)
 9094068:	00000a06 	br	9094094 <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 909406c:	e0bffc17 	ldw	r2,-16(fp)
 9094070:	10c00617 	ldw	r3,24(r2)
 9094074:	e0bffc17 	ldw	r2,-16(fp)
 9094078:	10800517 	ldw	r2,20(r2)
 909407c:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 9094080:	e0bffc17 	ldw	r2,-16(fp)
 9094084:	10c00517 	ldw	r3,20(r2)
 9094088:	e0bffc17 	ldw	r2,-16(fp)
 909408c:	10800617 	ldw	r2,24(r2)
 9094090:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 9094094:	00824374 	movhi	r2,2317
 9094098:	108c0c04 	addi	r2,r2,12336
 909409c:	10c00017 	ldw	r3,0(r2)
 90940a0:	e0bffc17 	ldw	r2,-16(fp)
 90940a4:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 90940a8:	00c24374 	movhi	r3,2317
 90940ac:	18cc0c04 	addi	r3,r3,12336
 90940b0:	e0bffc17 	ldw	r2,-16(fp)
 90940b4:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 90940b8:	e0fffc17 	ldw	r3,-16(fp)
 90940bc:	00800fc4 	movi	r2,63
 90940c0:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 90940c4:	e0bffc17 	ldw	r2,-16(fp)
 90940c8:	10001345 	stb	zero,77(r2)
 90940cc:	e0bffb17 	ldw	r2,-20(fp)
 90940d0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90940d4:	e0bff517 	ldw	r2,-44(fp)
 90940d8:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 90940dc:	00824374 	movhi	r2,2317
 90940e0:	108c0544 	addi	r2,r2,12309
 90940e4:	10800003 	ldbu	r2,0(r2)
 90940e8:	10803fcc 	andi	r2,r2,255
 90940ec:	10800058 	cmpnei	r2,r2,1
 90940f0:	1000011e 	bne	r2,zero,90940f8 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 90940f4:	908eaf40 	call	908eaf4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 90940f8:	e03fff15 	stw	zero,-4(fp)
 90940fc:	e0bfff17 	ldw	r2,-4(fp)
}
 9094100:	e037883a 	mov	sp,fp
 9094104:	dfc00117 	ldw	ra,4(sp)
 9094108:	df000017 	ldw	fp,0(sp)
 909410c:	dec00204 	addi	sp,sp,8
 9094110:	f800283a 	ret

09094114 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 9094114:	defff404 	addi	sp,sp,-48
 9094118:	df000b15 	stw	fp,44(sp)
 909411c:	df000b04 	addi	fp,sp,44
 9094120:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9094124:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 9094128:	e0bffe03 	ldbu	r2,-8(fp)
 909412c:	10800518 	cmpnei	r2,r2,20
 9094130:	1000031e 	bne	r2,zero,9094140 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 9094134:	00800f84 	movi	r2,62
 9094138:	e0bfff15 	stw	r2,-4(fp)
 909413c:	00004c06 	br	9094270 <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 9094140:	e0bffe03 	ldbu	r2,-8(fp)
 9094144:	10800530 	cmpltui	r2,r2,20
 9094148:	1000061e 	bne	r2,zero,9094164 <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 909414c:	e0bffe03 	ldbu	r2,-8(fp)
 9094150:	10803fe0 	cmpeqi	r2,r2,255
 9094154:	1000031e 	bne	r2,zero,9094164 <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 9094158:	00800a84 	movi	r2,42
 909415c:	e0bfff15 	stw	r2,-4(fp)
 9094160:	00004306 	br	9094270 <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 9094164:	e0bffe03 	ldbu	r2,-8(fp)
 9094168:	10803fd8 	cmpnei	r2,r2,255
 909416c:	1000141e 	bne	r2,zero,90941c0 <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094170:	0005303a 	rdctl	r2,status
 9094174:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094178:	e0fffa17 	ldw	r3,-24(fp)
 909417c:	00bfff84 	movi	r2,-2
 9094180:	1884703a 	and	r2,r3,r2
 9094184:	1001703a 	wrctl	status,r2
  
  return context;
 9094188:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 909418c:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 9094190:	00824374 	movhi	r2,2317
 9094194:	108c1404 	addi	r2,r2,12368
 9094198:	10800017 	ldw	r2,0(r2)
 909419c:	10800dc3 	ldbu	r2,55(r2)
 90941a0:	e0bffd05 	stb	r2,-12(fp)
 90941a4:	e0bffb17 	ldw	r2,-20(fp)
 90941a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90941ac:	e0bff917 	ldw	r2,-28(fp)
 90941b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 90941b4:	e0bffd03 	ldbu	r2,-12(fp)
 90941b8:	e0bfff15 	stw	r2,-4(fp)
 90941bc:	00002c06 	br	9094270 <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90941c0:	0005303a 	rdctl	r2,status
 90941c4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90941c8:	e0fff817 	ldw	r3,-32(fp)
 90941cc:	00bfff84 	movi	r2,-2
 90941d0:	1884703a 	and	r2,r3,r2
 90941d4:	1001703a 	wrctl	status,r2
  
  return context;
 90941d8:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 90941dc:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 90941e0:	e0bffe03 	ldbu	r2,-8(fp)
 90941e4:	00c243b4 	movhi	r3,2318
 90941e8:	18f2ac04 	addi	r3,r3,-13648
 90941ec:	1085883a 	add	r2,r2,r2
 90941f0:	1085883a 	add	r2,r2,r2
 90941f4:	10c5883a 	add	r2,r2,r3
 90941f8:	10800017 	ldw	r2,0(r2)
 90941fc:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 9094200:	e0bffc17 	ldw	r2,-16(fp)
 9094204:	1004c03a 	cmpne	r2,r2,zero
 9094208:	1000071e 	bne	r2,zero,9094228 <OSTaskDelReq+0x114>
 909420c:	e0bffb17 	ldw	r2,-20(fp)
 9094210:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094214:	e0bff717 	ldw	r2,-36(fp)
 9094218:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 909421c:	008010c4 	movi	r2,67
 9094220:	e0bfff15 	stw	r2,-4(fp)
 9094224:	00001206 	br	9094270 <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 9094228:	e0bffc17 	ldw	r2,-16(fp)
 909422c:	10800058 	cmpnei	r2,r2,1
 9094230:	1000071e 	bne	r2,zero,9094250 <OSTaskDelReq+0x13c>
 9094234:	e0bffb17 	ldw	r2,-20(fp)
 9094238:	e0bff615 	stw	r2,-40(fp)
 909423c:	e0bff617 	ldw	r2,-40(fp)
 9094240:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 9094244:	00800f44 	movi	r2,61
 9094248:	e0bfff15 	stw	r2,-4(fp)
 909424c:	00000806 	br	9094270 <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 9094250:	e0fffc17 	ldw	r3,-16(fp)
 9094254:	00800fc4 	movi	r2,63
 9094258:	18800dc5 	stb	r2,55(r3)
 909425c:	e0bffb17 	ldw	r2,-20(fp)
 9094260:	e0bff515 	stw	r2,-44(fp)
 9094264:	e0bff517 	ldw	r2,-44(fp)
 9094268:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 909426c:	e03fff15 	stw	zero,-4(fp)
 9094270:	e0bfff17 	ldw	r2,-4(fp)
}
 9094274:	e037883a 	mov	sp,fp
 9094278:	df000017 	ldw	fp,0(sp)
 909427c:	dec00104 	addi	sp,sp,4
 9094280:	f800283a 	ret

09094284 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 9094284:	defff304 	addi	sp,sp,-52
 9094288:	dfc00c15 	stw	ra,48(sp)
 909428c:	df000b15 	stw	fp,44(sp)
 9094290:	df000b04 	addi	fp,sp,44
 9094294:	e17ffd15 	stw	r5,-12(fp)
 9094298:	e1bffe15 	stw	r6,-8(fp)
 909429c:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 90942a0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 90942a4:	e0bffe17 	ldw	r2,-8(fp)
 90942a8:	1004c03a 	cmpne	r2,r2,zero
 90942ac:	1000021e 	bne	r2,zero,90942b8 <OSTaskNameGet+0x34>
        return (0);
 90942b0:	e03fff15 	stw	zero,-4(fp)
 90942b4:	00005b06 	br	9094424 <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 90942b8:	e0bffc03 	ldbu	r2,-16(fp)
 90942bc:	10800570 	cmpltui	r2,r2,21
 90942c0:	1000081e 	bne	r2,zero,90942e4 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 90942c4:	e0bffc03 	ldbu	r2,-16(fp)
 90942c8:	10803fe0 	cmpeqi	r2,r2,255
 90942cc:	1000051e 	bne	r2,zero,90942e4 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 90942d0:	e0fffe17 	ldw	r3,-8(fp)
 90942d4:	00800a84 	movi	r2,42
 90942d8:	18800005 	stb	r2,0(r3)
            return (0);
 90942dc:	e03fff15 	stw	zero,-4(fp)
 90942e0:	00005006 	br	9094424 <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 90942e4:	e0bffd17 	ldw	r2,-12(fp)
 90942e8:	1004c03a 	cmpne	r2,r2,zero
 90942ec:	1000051e 	bne	r2,zero,9094304 <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 90942f0:	e0fffe17 	ldw	r3,-8(fp)
 90942f4:	00800304 	movi	r2,12
 90942f8:	18800005 	stb	r2,0(r3)
        return (0);
 90942fc:	e03fff15 	stw	zero,-4(fp)
 9094300:	00004806 	br	9094424 <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 9094304:	00824374 	movhi	r2,2317
 9094308:	108c1304 	addi	r2,r2,12364
 909430c:	10800003 	ldbu	r2,0(r2)
 9094310:	10803fcc 	andi	r2,r2,255
 9094314:	1005003a 	cmpeq	r2,r2,zero
 9094318:	1000051e 	bne	r2,zero,9094330 <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 909431c:	e0fffe17 	ldw	r3,-8(fp)
 9094320:	00800444 	movi	r2,17
 9094324:	18800005 	stb	r2,0(r3)
        return (0);
 9094328:	e03fff15 	stw	zero,-4(fp)
 909432c:	00003d06 	br	9094424 <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094330:	0005303a 	rdctl	r2,status
 9094334:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094338:	e0fff817 	ldw	r3,-32(fp)
 909433c:	00bfff84 	movi	r2,-2
 9094340:	1884703a 	and	r2,r3,r2
 9094344:	1001703a 	wrctl	status,r2
  
  return context;
 9094348:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 909434c:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 9094350:	e0bffc03 	ldbu	r2,-16(fp)
 9094354:	10803fd8 	cmpnei	r2,r2,255
 9094358:	1000051e 	bne	r2,zero,9094370 <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 909435c:	00824374 	movhi	r2,2317
 9094360:	108c1404 	addi	r2,r2,12368
 9094364:	10800017 	ldw	r2,0(r2)
 9094368:	10800c83 	ldbu	r2,50(r2)
 909436c:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9094370:	e0bffc03 	ldbu	r2,-16(fp)
 9094374:	00c243b4 	movhi	r3,2318
 9094378:	18f2ac04 	addi	r3,r3,-13648
 909437c:	1085883a 	add	r2,r2,r2
 9094380:	1085883a 	add	r2,r2,r2
 9094384:	10c5883a 	add	r2,r2,r3
 9094388:	10800017 	ldw	r2,0(r2)
 909438c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 9094390:	e0bffb17 	ldw	r2,-20(fp)
 9094394:	1004c03a 	cmpne	r2,r2,zero
 9094398:	1000091e 	bne	r2,zero,90943c0 <OSTaskNameGet+0x13c>
 909439c:	e0bff917 	ldw	r2,-28(fp)
 90943a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90943a4:	e0bff717 	ldw	r2,-36(fp)
 90943a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 90943ac:	e0fffe17 	ldw	r3,-8(fp)
 90943b0:	008010c4 	movi	r2,67
 90943b4:	18800005 	stb	r2,0(r3)
        return (0);
 90943b8:	e03fff15 	stw	zero,-4(fp)
 90943bc:	00001906 	br	9094424 <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 90943c0:	e0bffb17 	ldw	r2,-20(fp)
 90943c4:	10800058 	cmpnei	r2,r2,1
 90943c8:	1000091e 	bne	r2,zero,90943f0 <OSTaskNameGet+0x16c>
 90943cc:	e0bff917 	ldw	r2,-28(fp)
 90943d0:	e0bff615 	stw	r2,-40(fp)
 90943d4:	e0bff617 	ldw	r2,-40(fp)
 90943d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 90943dc:	e0fffe17 	ldw	r3,-8(fp)
 90943e0:	008010c4 	movi	r2,67
 90943e4:	18800005 	stb	r2,0(r3)
        return (0);
 90943e8:	e03fff15 	stw	zero,-4(fp)
 90943ec:	00000d06 	br	9094424 <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 90943f0:	e0bffb17 	ldw	r2,-20(fp)
 90943f4:	11401304 	addi	r5,r2,76
 90943f8:	e13ffd17 	ldw	r4,-12(fp)
 90943fc:	908ec380 	call	908ec38 <OS_StrCopy>
 9094400:	e0bffa05 	stb	r2,-24(fp)
 9094404:	e0bff917 	ldw	r2,-28(fp)
 9094408:	e0bff515 	stw	r2,-44(fp)
 909440c:	e0bff517 	ldw	r2,-44(fp)
 9094410:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9094414:	e0bffe17 	ldw	r2,-8(fp)
 9094418:	10000005 	stb	zero,0(r2)
    return (len);
 909441c:	e0bffa03 	ldbu	r2,-24(fp)
 9094420:	e0bfff15 	stw	r2,-4(fp)
 9094424:	e0bfff17 	ldw	r2,-4(fp)
}
 9094428:	e037883a 	mov	sp,fp
 909442c:	dfc00117 	ldw	ra,4(sp)
 9094430:	df000017 	ldw	fp,0(sp)
 9094434:	dec00204 	addi	sp,sp,8
 9094438:	f800283a 	ret

0909443c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 909443c:	defff304 	addi	sp,sp,-52
 9094440:	dfc00c15 	stw	ra,48(sp)
 9094444:	df000b15 	stw	fp,44(sp)
 9094448:	df000b04 	addi	fp,sp,44
 909444c:	e17ffe15 	stw	r5,-8(fp)
 9094450:	e1bfff15 	stw	r6,-4(fp)
 9094454:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 9094458:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 909445c:	e0bfff17 	ldw	r2,-4(fp)
 9094460:	1005003a 	cmpeq	r2,r2,zero
 9094464:	1000611e 	bne	r2,zero,90945ec <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 9094468:	e0bffd03 	ldbu	r2,-12(fp)
 909446c:	10800570 	cmpltui	r2,r2,21
 9094470:	1000071e 	bne	r2,zero,9094490 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 9094474:	e0bffd03 	ldbu	r2,-12(fp)
 9094478:	10803fe0 	cmpeqi	r2,r2,255
 909447c:	1000041e 	bne	r2,zero,9094490 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 9094480:	e0ffff17 	ldw	r3,-4(fp)
 9094484:	00800a84 	movi	r2,42
 9094488:	18800005 	stb	r2,0(r3)
            return;
 909448c:	00005706 	br	90945ec <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 9094490:	e0bffe17 	ldw	r2,-8(fp)
 9094494:	1004c03a 	cmpne	r2,r2,zero
 9094498:	1000041e 	bne	r2,zero,90944ac <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 909449c:	e0ffff17 	ldw	r3,-4(fp)
 90944a0:	00800304 	movi	r2,12
 90944a4:	18800005 	stb	r2,0(r3)
        return;
 90944a8:	00005006 	br	90945ec <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 90944ac:	00824374 	movhi	r2,2317
 90944b0:	108c1304 	addi	r2,r2,12364
 90944b4:	10800003 	ldbu	r2,0(r2)
 90944b8:	10803fcc 	andi	r2,r2,255
 90944bc:	1005003a 	cmpeq	r2,r2,zero
 90944c0:	1000041e 	bne	r2,zero,90944d4 <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 90944c4:	e0ffff17 	ldw	r3,-4(fp)
 90944c8:	00800484 	movi	r2,18
 90944cc:	18800005 	stb	r2,0(r3)
        return;
 90944d0:	00004606 	br	90945ec <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90944d4:	0005303a 	rdctl	r2,status
 90944d8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90944dc:	e0fff917 	ldw	r3,-28(fp)
 90944e0:	00bfff84 	movi	r2,-2
 90944e4:	1884703a 	and	r2,r3,r2
 90944e8:	1001703a 	wrctl	status,r2
  
  return context;
 90944ec:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 90944f0:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 90944f4:	e0bffd03 	ldbu	r2,-12(fp)
 90944f8:	10803fd8 	cmpnei	r2,r2,255
 90944fc:	1000051e 	bne	r2,zero,9094514 <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 9094500:	00824374 	movhi	r2,2317
 9094504:	108c1404 	addi	r2,r2,12368
 9094508:	10800017 	ldw	r2,0(r2)
 909450c:	10800c83 	ldbu	r2,50(r2)
 9094510:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9094514:	e0bffd03 	ldbu	r2,-12(fp)
 9094518:	00c243b4 	movhi	r3,2318
 909451c:	18f2ac04 	addi	r3,r3,-13648
 9094520:	1085883a 	add	r2,r2,r2
 9094524:	1085883a 	add	r2,r2,r2
 9094528:	10c5883a 	add	r2,r2,r3
 909452c:	10800017 	ldw	r2,0(r2)
 9094530:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 9094534:	e0bffb17 	ldw	r2,-20(fp)
 9094538:	1004c03a 	cmpne	r2,r2,zero
 909453c:	1000081e 	bne	r2,zero,9094560 <OSTaskNameSet+0x124>
 9094540:	e0bffa17 	ldw	r2,-24(fp)
 9094544:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094548:	e0bff817 	ldw	r2,-32(fp)
 909454c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 9094550:	e0ffff17 	ldw	r3,-4(fp)
 9094554:	008010c4 	movi	r2,67
 9094558:	18800005 	stb	r2,0(r3)
        return;
 909455c:	00002306 	br	90945ec <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 9094560:	e0bffb17 	ldw	r2,-20(fp)
 9094564:	10800058 	cmpnei	r2,r2,1
 9094568:	1000081e 	bne	r2,zero,909458c <OSTaskNameSet+0x150>
 909456c:	e0bffa17 	ldw	r2,-24(fp)
 9094570:	e0bff715 	stw	r2,-36(fp)
 9094574:	e0bff717 	ldw	r2,-36(fp)
 9094578:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 909457c:	e0ffff17 	ldw	r3,-4(fp)
 9094580:	008010c4 	movi	r2,67
 9094584:	18800005 	stb	r2,0(r3)
        return;
 9094588:	00001806 	br	90945ec <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 909458c:	e13ffe17 	ldw	r4,-8(fp)
 9094590:	908ecb80 	call	908ecb8 <OS_StrLen>
 9094594:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 9094598:	e0bffc03 	ldbu	r2,-16(fp)
 909459c:	10800830 	cmpltui	r2,r2,32
 90945a0:	1000081e 	bne	r2,zero,90945c4 <OSTaskNameSet+0x188>
 90945a4:	e0bffa17 	ldw	r2,-24(fp)
 90945a8:	e0bff615 	stw	r2,-40(fp)
 90945ac:	e0bff617 	ldw	r2,-40(fp)
 90945b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 90945b4:	e0ffff17 	ldw	r3,-4(fp)
 90945b8:	00801044 	movi	r2,65
 90945bc:	18800005 	stb	r2,0(r3)
        return;
 90945c0:	00000a06 	br	90945ec <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 90945c4:	e0bffb17 	ldw	r2,-20(fp)
 90945c8:	11001304 	addi	r4,r2,76
 90945cc:	e17ffe17 	ldw	r5,-8(fp)
 90945d0:	908ec380 	call	908ec38 <OS_StrCopy>
 90945d4:	e0bffa17 	ldw	r2,-24(fp)
 90945d8:	e0bff515 	stw	r2,-44(fp)
 90945dc:	e0bff517 	ldw	r2,-44(fp)
 90945e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90945e4:	e0bfff17 	ldw	r2,-4(fp)
 90945e8:	10000005 	stb	zero,0(r2)
}
 90945ec:	e037883a 	mov	sp,fp
 90945f0:	dfc00117 	ldw	ra,4(sp)
 90945f4:	df000017 	ldw	fp,0(sp)
 90945f8:	dec00204 	addi	sp,sp,8
 90945fc:	f800283a 	ret

09094600 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 9094600:	defff304 	addi	sp,sp,-52
 9094604:	dfc00c15 	stw	ra,48(sp)
 9094608:	df000b15 	stw	fp,44(sp)
 909460c:	df000b04 	addi	fp,sp,44
 9094610:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 9094614:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 9094618:	e0bffe03 	ldbu	r2,-8(fp)
 909461c:	10800530 	cmpltui	r2,r2,20
 9094620:	1000031e 	bne	r2,zero,9094630 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 9094624:	00800a84 	movi	r2,42
 9094628:	e0bfff15 	stw	r2,-4(fp)
 909462c:	00007406 	br	9094800 <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094630:	0005303a 	rdctl	r2,status
 9094634:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094638:	e0fffb17 	ldw	r3,-20(fp)
 909463c:	00bfff84 	movi	r2,-2
 9094640:	1884703a 	and	r2,r3,r2
 9094644:	1001703a 	wrctl	status,r2
  
  return context;
 9094648:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909464c:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 9094650:	e0bffe03 	ldbu	r2,-8(fp)
 9094654:	00c243b4 	movhi	r3,2318
 9094658:	18f2ac04 	addi	r3,r3,-13648
 909465c:	1085883a 	add	r2,r2,r2
 9094660:	1085883a 	add	r2,r2,r2
 9094664:	10c5883a 	add	r2,r2,r3
 9094668:	10800017 	ldw	r2,0(r2)
 909466c:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 9094670:	e0bffd17 	ldw	r2,-12(fp)
 9094674:	1004c03a 	cmpne	r2,r2,zero
 9094678:	1000071e 	bne	r2,zero,9094698 <OSTaskResume+0x98>
 909467c:	e0bffc17 	ldw	r2,-16(fp)
 9094680:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094684:	e0bffa17 	ldw	r2,-24(fp)
 9094688:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 909468c:	00801184 	movi	r2,70
 9094690:	e0bfff15 	stw	r2,-4(fp)
 9094694:	00005a06 	br	9094800 <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 9094698:	e0bffd17 	ldw	r2,-12(fp)
 909469c:	10800058 	cmpnei	r2,r2,1
 90946a0:	1000071e 	bne	r2,zero,90946c0 <OSTaskResume+0xc0>
 90946a4:	e0bffc17 	ldw	r2,-16(fp)
 90946a8:	e0bff915 	stw	r2,-28(fp)
 90946ac:	e0bff917 	ldw	r2,-28(fp)
 90946b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 90946b4:	008010c4 	movi	r2,67
 90946b8:	e0bfff15 	stw	r2,-4(fp)
 90946bc:	00005006 	br	9094800 <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 90946c0:	e0bffd17 	ldw	r2,-12(fp)
 90946c4:	10800c03 	ldbu	r2,48(r2)
 90946c8:	10803fcc 	andi	r2,r2,255
 90946cc:	1080020c 	andi	r2,r2,8
 90946d0:	1005003a 	cmpeq	r2,r2,zero
 90946d4:	1000441e 	bne	r2,zero,90947e8 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 90946d8:	e0bffd17 	ldw	r2,-12(fp)
 90946dc:	10c00c03 	ldbu	r3,48(r2)
 90946e0:	00bffdc4 	movi	r2,-9
 90946e4:	1884703a 	and	r2,r3,r2
 90946e8:	1007883a 	mov	r3,r2
 90946ec:	e0bffd17 	ldw	r2,-12(fp)
 90946f0:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 90946f4:	e0bffd17 	ldw	r2,-12(fp)
 90946f8:	10800c03 	ldbu	r2,48(r2)
 90946fc:	10803fcc 	andi	r2,r2,255
 9094700:	1004c03a 	cmpne	r2,r2,zero
 9094704:	1000321e 	bne	r2,zero,90947d0 <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 9094708:	e0bffd17 	ldw	r2,-12(fp)
 909470c:	10800b8b 	ldhu	r2,46(r2)
 9094710:	10bfffcc 	andi	r2,r2,65535
 9094714:	1004c03a 	cmpne	r2,r2,zero
 9094718:	1000281e 	bne	r2,zero,90947bc <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 909471c:	e0bffd17 	ldw	r2,-12(fp)
 9094720:	10c00d83 	ldbu	r3,54(r2)
 9094724:	00824374 	movhi	r2,2317
 9094728:	108c1104 	addi	r2,r2,12356
 909472c:	10800003 	ldbu	r2,0(r2)
 9094730:	1884b03a 	or	r2,r3,r2
 9094734:	1007883a 	mov	r3,r2
 9094738:	00824374 	movhi	r2,2317
 909473c:	108c1104 	addi	r2,r2,12356
 9094740:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9094744:	e0bffd17 	ldw	r2,-12(fp)
 9094748:	10800d03 	ldbu	r2,52(r2)
 909474c:	11003fcc 	andi	r4,r2,255
 9094750:	e0bffd17 	ldw	r2,-12(fp)
 9094754:	10800d03 	ldbu	r2,52(r2)
 9094758:	10c03fcc 	andi	r3,r2,255
 909475c:	00824374 	movhi	r2,2317
 9094760:	108c1144 	addi	r2,r2,12357
 9094764:	10c5883a 	add	r2,r2,r3
 9094768:	10c00003 	ldbu	r3,0(r2)
 909476c:	e0bffd17 	ldw	r2,-12(fp)
 9094770:	10800d43 	ldbu	r2,53(r2)
 9094774:	1884b03a 	or	r2,r3,r2
 9094778:	1007883a 	mov	r3,r2
 909477c:	00824374 	movhi	r2,2317
 9094780:	108c1144 	addi	r2,r2,12357
 9094784:	1105883a 	add	r2,r2,r4
 9094788:	10c00005 	stb	r3,0(r2)
 909478c:	e0bffc17 	ldw	r2,-16(fp)
 9094790:	e0bff815 	stw	r2,-32(fp)
 9094794:	e0bff817 	ldw	r2,-32(fp)
 9094798:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 909479c:	00824374 	movhi	r2,2317
 90947a0:	108c0544 	addi	r2,r2,12309
 90947a4:	10800003 	ldbu	r2,0(r2)
 90947a8:	10803fcc 	andi	r2,r2,255
 90947ac:	10800058 	cmpnei	r2,r2,1
 90947b0:	10000b1e 	bne	r2,zero,90947e0 <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 90947b4:	908eaf40 	call	908eaf4 <OS_Sched>
 90947b8:	00000906 	br	90947e0 <OSTaskResume+0x1e0>
 90947bc:	e0bffc17 	ldw	r2,-16(fp)
 90947c0:	e0bff715 	stw	r2,-36(fp)
 90947c4:	e0bff717 	ldw	r2,-36(fp)
 90947c8:	1001703a 	wrctl	status,r2
 90947cc:	00000406 	br	90947e0 <OSTaskResume+0x1e0>
 90947d0:	e0bffc17 	ldw	r2,-16(fp)
 90947d4:	e0bff615 	stw	r2,-40(fp)
 90947d8:	e0bff617 	ldw	r2,-40(fp)
 90947dc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 90947e0:	e03fff15 	stw	zero,-4(fp)
 90947e4:	00000606 	br	9094800 <OSTaskResume+0x200>
 90947e8:	e0bffc17 	ldw	r2,-16(fp)
 90947ec:	e0bff515 	stw	r2,-44(fp)
 90947f0:	e0bff517 	ldw	r2,-44(fp)
 90947f4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 90947f8:	00801104 	movi	r2,68
 90947fc:	e0bfff15 	stw	r2,-4(fp)
 9094800:	e0bfff17 	ldw	r2,-4(fp)
}
 9094804:	e037883a 	mov	sp,fp
 9094808:	dfc00117 	ldw	ra,4(sp)
 909480c:	df000017 	ldw	fp,0(sp)
 9094810:	dec00204 	addi	sp,sp,8
 9094814:	f800283a 	ret

09094818 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 9094818:	defff204 	addi	sp,sp,-56
 909481c:	df000d15 	stw	fp,52(sp)
 9094820:	df000d04 	addi	fp,sp,52
 9094824:	e17ffe15 	stw	r5,-8(fp)
 9094828:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 909482c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 9094830:	e0bffd03 	ldbu	r2,-12(fp)
 9094834:	10800570 	cmpltui	r2,r2,21
 9094838:	1000061e 	bne	r2,zero,9094854 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 909483c:	e0bffd03 	ldbu	r2,-12(fp)
 9094840:	10803fe0 	cmpeqi	r2,r2,255
 9094844:	1000031e 	bne	r2,zero,9094854 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 9094848:	00800a84 	movi	r2,42
 909484c:	e0bfff15 	stw	r2,-4(fp)
 9094850:	00006b06 	br	9094a00 <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 9094854:	e0bffe17 	ldw	r2,-8(fp)
 9094858:	1004c03a 	cmpne	r2,r2,zero
 909485c:	1000031e 	bne	r2,zero,909486c <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 9094860:	00800244 	movi	r2,9
 9094864:	e0bfff15 	stw	r2,-4(fp)
 9094868:	00006506 	br	9094a00 <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 909486c:	e0bffe17 	ldw	r2,-8(fp)
 9094870:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 9094874:	e0bffe17 	ldw	r2,-8(fp)
 9094878:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909487c:	0005303a 	rdctl	r2,status
 9094880:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094884:	e0fff717 	ldw	r3,-36(fp)
 9094888:	00bfff84 	movi	r2,-2
 909488c:	1884703a 	and	r2,r3,r2
 9094890:	1001703a 	wrctl	status,r2
  
  return context;
 9094894:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 9094898:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 909489c:	e0bffd03 	ldbu	r2,-12(fp)
 90948a0:	10803fd8 	cmpnei	r2,r2,255
 90948a4:	1000051e 	bne	r2,zero,90948bc <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 90948a8:	00824374 	movhi	r2,2317
 90948ac:	108c1404 	addi	r2,r2,12368
 90948b0:	10800017 	ldw	r2,0(r2)
 90948b4:	10800c83 	ldbu	r2,50(r2)
 90948b8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 90948bc:	e0bffd03 	ldbu	r2,-12(fp)
 90948c0:	00c243b4 	movhi	r3,2318
 90948c4:	18f2ac04 	addi	r3,r3,-13648
 90948c8:	1085883a 	add	r2,r2,r2
 90948cc:	1085883a 	add	r2,r2,r2
 90948d0:	10c5883a 	add	r2,r2,r3
 90948d4:	10800017 	ldw	r2,0(r2)
 90948d8:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 90948dc:	e0bffc17 	ldw	r2,-16(fp)
 90948e0:	1004c03a 	cmpne	r2,r2,zero
 90948e4:	1000071e 	bne	r2,zero,9094904 <OSTaskStkChk+0xec>
 90948e8:	e0bff817 	ldw	r2,-32(fp)
 90948ec:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90948f0:	e0bff617 	ldw	r2,-40(fp)
 90948f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 90948f8:	008010c4 	movi	r2,67
 90948fc:	e0bfff15 	stw	r2,-4(fp)
 9094900:	00003f06 	br	9094a00 <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 9094904:	e0bffc17 	ldw	r2,-16(fp)
 9094908:	10800058 	cmpnei	r2,r2,1
 909490c:	1000071e 	bne	r2,zero,909492c <OSTaskStkChk+0x114>
 9094910:	e0bff817 	ldw	r2,-32(fp)
 9094914:	e0bff515 	stw	r2,-44(fp)
 9094918:	e0bff517 	ldw	r2,-44(fp)
 909491c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9094920:	008010c4 	movi	r2,67
 9094924:	e0bfff15 	stw	r2,-4(fp)
 9094928:	00003506 	br	9094a00 <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 909492c:	e0bffc17 	ldw	r2,-16(fp)
 9094930:	1080040b 	ldhu	r2,16(r2)
 9094934:	10bfffcc 	andi	r2,r2,65535
 9094938:	1080004c 	andi	r2,r2,1
 909493c:	1004c03a 	cmpne	r2,r2,zero
 9094940:	1000071e 	bne	r2,zero,9094960 <OSTaskStkChk+0x148>
 9094944:	e0bff817 	ldw	r2,-32(fp)
 9094948:	e0bff415 	stw	r2,-48(fp)
 909494c:	e0bff417 	ldw	r2,-48(fp)
 9094950:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 9094954:	00801144 	movi	r2,69
 9094958:	e0bfff15 	stw	r2,-4(fp)
 909495c:	00002806 	br	9094a00 <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 9094960:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 9094964:	e0bffc17 	ldw	r2,-16(fp)
 9094968:	10800317 	ldw	r2,12(r2)
 909496c:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 9094970:	e0bffc17 	ldw	r2,-16(fp)
 9094974:	10800217 	ldw	r2,8(r2)
 9094978:	e0bffb15 	stw	r2,-20(fp)
 909497c:	e0bff817 	ldw	r2,-32(fp)
 9094980:	e0bff315 	stw	r2,-52(fp)
 9094984:	e0bff317 	ldw	r2,-52(fp)
 9094988:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 909498c:	00000306 	br	909499c <OSTaskStkChk+0x184>
        nfree++;
 9094990:	e0bffa17 	ldw	r2,-24(fp)
 9094994:	10800044 	addi	r2,r2,1
 9094998:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 909499c:	e0bffb17 	ldw	r2,-20(fp)
 90949a0:	10800017 	ldw	r2,0(r2)
 90949a4:	1005003a 	cmpeq	r2,r2,zero
 90949a8:	1007883a 	mov	r3,r2
 90949ac:	e0bffb17 	ldw	r2,-20(fp)
 90949b0:	10800104 	addi	r2,r2,4
 90949b4:	e0bffb15 	stw	r2,-20(fp)
 90949b8:	18803fcc 	andi	r2,r3,255
 90949bc:	1004c03a 	cmpne	r2,r2,zero
 90949c0:	103ff31e 	bne	r2,zero,9094990 <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 90949c4:	e0bffa17 	ldw	r2,-24(fp)
 90949c8:	1085883a 	add	r2,r2,r2
 90949cc:	1085883a 	add	r2,r2,r2
 90949d0:	1007883a 	mov	r3,r2
 90949d4:	e0bffe17 	ldw	r2,-8(fp)
 90949d8:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 90949dc:	e0fff917 	ldw	r3,-28(fp)
 90949e0:	e0bffa17 	ldw	r2,-24(fp)
 90949e4:	1885c83a 	sub	r2,r3,r2
 90949e8:	1085883a 	add	r2,r2,r2
 90949ec:	1085883a 	add	r2,r2,r2
 90949f0:	1007883a 	mov	r3,r2
 90949f4:	e0bffe17 	ldw	r2,-8(fp)
 90949f8:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 90949fc:	e03fff15 	stw	zero,-4(fp)
 9094a00:	e0bfff17 	ldw	r2,-4(fp)
}
 9094a04:	e037883a 	mov	sp,fp
 9094a08:	df000017 	ldw	fp,0(sp)
 9094a0c:	dec00104 	addi	sp,sp,4
 9094a10:	f800283a 	ret

09094a14 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 9094a14:	defff404 	addi	sp,sp,-48
 9094a18:	dfc00b15 	stw	ra,44(sp)
 9094a1c:	df000a15 	stw	fp,40(sp)
 9094a20:	df000a04 	addi	fp,sp,40
 9094a24:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9094a28:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 9094a2c:	e0bffe03 	ldbu	r2,-8(fp)
 9094a30:	10800518 	cmpnei	r2,r2,20
 9094a34:	1000031e 	bne	r2,zero,9094a44 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 9094a38:	008011c4 	movi	r2,71
 9094a3c:	e0bfff15 	stw	r2,-4(fp)
 9094a40:	00007906 	br	9094c28 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 9094a44:	e0bffe03 	ldbu	r2,-8(fp)
 9094a48:	10800530 	cmpltui	r2,r2,20
 9094a4c:	1000061e 	bne	r2,zero,9094a68 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 9094a50:	e0bffe03 	ldbu	r2,-8(fp)
 9094a54:	10803fe0 	cmpeqi	r2,r2,255
 9094a58:	1000031e 	bne	r2,zero,9094a68 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 9094a5c:	00800a84 	movi	r2,42
 9094a60:	e0bfff15 	stw	r2,-4(fp)
 9094a64:	00007006 	br	9094c28 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094a68:	0005303a 	rdctl	r2,status
 9094a6c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094a70:	e0fff917 	ldw	r3,-28(fp)
 9094a74:	00bfff84 	movi	r2,-2
 9094a78:	1884703a 	and	r2,r3,r2
 9094a7c:	1001703a 	wrctl	status,r2
  
  return context;
 9094a80:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 9094a84:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 9094a88:	e0bffe03 	ldbu	r2,-8(fp)
 9094a8c:	10803fd8 	cmpnei	r2,r2,255
 9094a90:	1000081e 	bne	r2,zero,9094ab4 <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 9094a94:	00824374 	movhi	r2,2317
 9094a98:	108c1404 	addi	r2,r2,12368
 9094a9c:	10800017 	ldw	r2,0(r2)
 9094aa0:	10800c83 	ldbu	r2,50(r2)
 9094aa4:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 9094aa8:	00800044 	movi	r2,1
 9094aac:	e0bffd05 	stb	r2,-12(fp)
 9094ab0:	00000b06 	br	9094ae0 <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 9094ab4:	00824374 	movhi	r2,2317
 9094ab8:	108c1404 	addi	r2,r2,12368
 9094abc:	10800017 	ldw	r2,0(r2)
 9094ac0:	10800c83 	ldbu	r2,50(r2)
 9094ac4:	10c03fcc 	andi	r3,r2,255
 9094ac8:	e0bffe03 	ldbu	r2,-8(fp)
 9094acc:	1880031e 	bne	r3,r2,9094adc <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 9094ad0:	00800044 	movi	r2,1
 9094ad4:	e0bffd05 	stb	r2,-12(fp)
 9094ad8:	00000106 	br	9094ae0 <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 9094adc:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9094ae0:	e0bffe03 	ldbu	r2,-8(fp)
 9094ae4:	00c243b4 	movhi	r3,2318
 9094ae8:	18f2ac04 	addi	r3,r3,-13648
 9094aec:	1085883a 	add	r2,r2,r2
 9094af0:	1085883a 	add	r2,r2,r2
 9094af4:	10c5883a 	add	r2,r2,r3
 9094af8:	10800017 	ldw	r2,0(r2)
 9094afc:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 9094b00:	e0bffc17 	ldw	r2,-16(fp)
 9094b04:	1004c03a 	cmpne	r2,r2,zero
 9094b08:	1000071e 	bne	r2,zero,9094b28 <OSTaskSuspend+0x114>
 9094b0c:	e0bffa17 	ldw	r2,-24(fp)
 9094b10:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094b14:	e0bff817 	ldw	r2,-32(fp)
 9094b18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 9094b1c:	00801204 	movi	r2,72
 9094b20:	e0bfff15 	stw	r2,-4(fp)
 9094b24:	00004006 	br	9094c28 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 9094b28:	e0bffc17 	ldw	r2,-16(fp)
 9094b2c:	10800058 	cmpnei	r2,r2,1
 9094b30:	1000071e 	bne	r2,zero,9094b50 <OSTaskSuspend+0x13c>
 9094b34:	e0bffa17 	ldw	r2,-24(fp)
 9094b38:	e0bff715 	stw	r2,-36(fp)
 9094b3c:	e0bff717 	ldw	r2,-36(fp)
 9094b40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9094b44:	008010c4 	movi	r2,67
 9094b48:	e0bfff15 	stw	r2,-4(fp)
 9094b4c:	00003606 	br	9094c28 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 9094b50:	e0bffc17 	ldw	r2,-16(fp)
 9094b54:	10800d03 	ldbu	r2,52(r2)
 9094b58:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 9094b5c:	e13ffb03 	ldbu	r4,-20(fp)
 9094b60:	e0fffb03 	ldbu	r3,-20(fp)
 9094b64:	00824374 	movhi	r2,2317
 9094b68:	108c1144 	addi	r2,r2,12357
 9094b6c:	10c5883a 	add	r2,r2,r3
 9094b70:	10800003 	ldbu	r2,0(r2)
 9094b74:	1007883a 	mov	r3,r2
 9094b78:	e0bffc17 	ldw	r2,-16(fp)
 9094b7c:	10800d43 	ldbu	r2,53(r2)
 9094b80:	0084303a 	nor	r2,zero,r2
 9094b84:	1884703a 	and	r2,r3,r2
 9094b88:	1007883a 	mov	r3,r2
 9094b8c:	00824374 	movhi	r2,2317
 9094b90:	108c1144 	addi	r2,r2,12357
 9094b94:	1105883a 	add	r2,r2,r4
 9094b98:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 9094b9c:	e0fffb03 	ldbu	r3,-20(fp)
 9094ba0:	00824374 	movhi	r2,2317
 9094ba4:	108c1144 	addi	r2,r2,12357
 9094ba8:	10c5883a 	add	r2,r2,r3
 9094bac:	10800003 	ldbu	r2,0(r2)
 9094bb0:	10803fcc 	andi	r2,r2,255
 9094bb4:	1004c03a 	cmpne	r2,r2,zero
 9094bb8:	10000c1e 	bne	r2,zero,9094bec <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 9094bbc:	e0bffc17 	ldw	r2,-16(fp)
 9094bc0:	10800d83 	ldbu	r2,54(r2)
 9094bc4:	0084303a 	nor	r2,zero,r2
 9094bc8:	1007883a 	mov	r3,r2
 9094bcc:	00824374 	movhi	r2,2317
 9094bd0:	108c1104 	addi	r2,r2,12356
 9094bd4:	10800003 	ldbu	r2,0(r2)
 9094bd8:	1884703a 	and	r2,r3,r2
 9094bdc:	1007883a 	mov	r3,r2
 9094be0:	00824374 	movhi	r2,2317
 9094be4:	108c1104 	addi	r2,r2,12356
 9094be8:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 9094bec:	e0bffc17 	ldw	r2,-16(fp)
 9094bf0:	10800c03 	ldbu	r2,48(r2)
 9094bf4:	10800214 	ori	r2,r2,8
 9094bf8:	1007883a 	mov	r3,r2
 9094bfc:	e0bffc17 	ldw	r2,-16(fp)
 9094c00:	10c00c05 	stb	r3,48(r2)
 9094c04:	e0bffa17 	ldw	r2,-24(fp)
 9094c08:	e0bff615 	stw	r2,-40(fp)
 9094c0c:	e0bff617 	ldw	r2,-40(fp)
 9094c10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 9094c14:	e0bffd03 	ldbu	r2,-12(fp)
 9094c18:	10800058 	cmpnei	r2,r2,1
 9094c1c:	1000011e 	bne	r2,zero,9094c24 <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 9094c20:	908eaf40 	call	908eaf4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 9094c24:	e03fff15 	stw	zero,-4(fp)
 9094c28:	e0bfff17 	ldw	r2,-4(fp)
}
 9094c2c:	e037883a 	mov	sp,fp
 9094c30:	dfc00117 	ldw	ra,4(sp)
 9094c34:	df000017 	ldw	fp,0(sp)
 9094c38:	dec00204 	addi	sp,sp,8
 9094c3c:	f800283a 	ret

09094c40 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 9094c40:	defff504 	addi	sp,sp,-44
 9094c44:	dfc00a15 	stw	ra,40(sp)
 9094c48:	df000915 	stw	fp,36(sp)
 9094c4c:	df000904 	addi	fp,sp,36
 9094c50:	e17ffe15 	stw	r5,-8(fp)
 9094c54:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9094c58:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 9094c5c:	e0bffd03 	ldbu	r2,-12(fp)
 9094c60:	10800570 	cmpltui	r2,r2,21
 9094c64:	1000061e 	bne	r2,zero,9094c80 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 9094c68:	e0bffd03 	ldbu	r2,-12(fp)
 9094c6c:	10803fe0 	cmpeqi	r2,r2,255
 9094c70:	1000031e 	bne	r2,zero,9094c80 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 9094c74:	00800a84 	movi	r2,42
 9094c78:	e0bfff15 	stw	r2,-4(fp)
 9094c7c:	00003b06 	br	9094d6c <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 9094c80:	e0bffe17 	ldw	r2,-8(fp)
 9094c84:	1004c03a 	cmpne	r2,r2,zero
 9094c88:	1000031e 	bne	r2,zero,9094c98 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 9094c8c:	00800244 	movi	r2,9
 9094c90:	e0bfff15 	stw	r2,-4(fp)
 9094c94:	00003506 	br	9094d6c <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094c98:	0005303a 	rdctl	r2,status
 9094c9c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094ca0:	e0fffa17 	ldw	r3,-24(fp)
 9094ca4:	00bfff84 	movi	r2,-2
 9094ca8:	1884703a 	and	r2,r3,r2
 9094cac:	1001703a 	wrctl	status,r2
  
  return context;
 9094cb0:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9094cb4:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 9094cb8:	e0bffd03 	ldbu	r2,-12(fp)
 9094cbc:	10803fd8 	cmpnei	r2,r2,255
 9094cc0:	1000051e 	bne	r2,zero,9094cd8 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 9094cc4:	00824374 	movhi	r2,2317
 9094cc8:	108c1404 	addi	r2,r2,12368
 9094ccc:	10800017 	ldw	r2,0(r2)
 9094cd0:	10800c83 	ldbu	r2,50(r2)
 9094cd4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9094cd8:	e0bffd03 	ldbu	r2,-12(fp)
 9094cdc:	00c243b4 	movhi	r3,2318
 9094ce0:	18f2ac04 	addi	r3,r3,-13648
 9094ce4:	1085883a 	add	r2,r2,r2
 9094ce8:	1085883a 	add	r2,r2,r2
 9094cec:	10c5883a 	add	r2,r2,r3
 9094cf0:	10800017 	ldw	r2,0(r2)
 9094cf4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 9094cf8:	e0bffc17 	ldw	r2,-16(fp)
 9094cfc:	1004c03a 	cmpne	r2,r2,zero
 9094d00:	1000071e 	bne	r2,zero,9094d20 <OSTaskQuery+0xe0>
 9094d04:	e0bffb17 	ldw	r2,-20(fp)
 9094d08:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094d0c:	e0bff917 	ldw	r2,-28(fp)
 9094d10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 9094d14:	00800a44 	movi	r2,41
 9094d18:	e0bfff15 	stw	r2,-4(fp)
 9094d1c:	00001306 	br	9094d6c <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 9094d20:	e0bffc17 	ldw	r2,-16(fp)
 9094d24:	10800058 	cmpnei	r2,r2,1
 9094d28:	1000071e 	bne	r2,zero,9094d48 <OSTaskQuery+0x108>
 9094d2c:	e0bffb17 	ldw	r2,-20(fp)
 9094d30:	e0bff815 	stw	r2,-32(fp)
 9094d34:	e0bff817 	ldw	r2,-32(fp)
 9094d38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9094d3c:	008010c4 	movi	r2,67
 9094d40:	e0bfff15 	stw	r2,-4(fp)
 9094d44:	00000906 	br	9094d6c <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 9094d48:	e13ffe17 	ldw	r4,-8(fp)
 9094d4c:	e17ffc17 	ldw	r5,-16(fp)
 9094d50:	01801b04 	movi	r6,108
 9094d54:	908ea880 	call	908ea88 <OS_MemCopy>
 9094d58:	e0bffb17 	ldw	r2,-20(fp)
 9094d5c:	e0bff715 	stw	r2,-36(fp)
 9094d60:	e0bff717 	ldw	r2,-36(fp)
 9094d64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9094d68:	e03fff15 	stw	zero,-4(fp)
 9094d6c:	e0bfff17 	ldw	r2,-4(fp)
}
 9094d70:	e037883a 	mov	sp,fp
 9094d74:	dfc00117 	ldw	ra,4(sp)
 9094d78:	df000017 	ldw	fp,0(sp)
 9094d7c:	dec00204 	addi	sp,sp,8
 9094d80:	f800283a 	ret

09094d84 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 9094d84:	defffc04 	addi	sp,sp,-16
 9094d88:	df000315 	stw	fp,12(sp)
 9094d8c:	df000304 	addi	fp,sp,12
 9094d90:	e13ffd15 	stw	r4,-12(fp)
 9094d94:	e17ffe15 	stw	r5,-8(fp)
 9094d98:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 9094d9c:	e0bfff0b 	ldhu	r2,-4(fp)
 9094da0:	1080004c 	andi	r2,r2,1
 9094da4:	10803fcc 	andi	r2,r2,255
 9094da8:	1005003a 	cmpeq	r2,r2,zero
 9094dac:	1000101e 	bne	r2,zero,9094df0 <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 9094db0:	e0bfff0b 	ldhu	r2,-4(fp)
 9094db4:	1080008c 	andi	r2,r2,2
 9094db8:	1005003a 	cmpeq	r2,r2,zero
 9094dbc:	10000c1e 	bne	r2,zero,9094df0 <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 9094dc0:	00000806 	br	9094de4 <OS_TaskStkClr+0x60>
                size--;
 9094dc4:	e0bffe17 	ldw	r2,-8(fp)
 9094dc8:	10bfffc4 	addi	r2,r2,-1
 9094dcc:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 9094dd0:	e0bffd17 	ldw	r2,-12(fp)
 9094dd4:	10000015 	stw	zero,0(r2)
 9094dd8:	e0bffd17 	ldw	r2,-12(fp)
 9094ddc:	10800104 	addi	r2,r2,4
 9094de0:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 9094de4:	e0bffe17 	ldw	r2,-8(fp)
 9094de8:	1004c03a 	cmpne	r2,r2,zero
 9094dec:	103ff51e 	bne	r2,zero,9094dc4 <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 9094df0:	e037883a 	mov	sp,fp
 9094df4:	df000017 	ldw	fp,0(sp)
 9094df8:	dec00104 	addi	sp,sp,4
 9094dfc:	f800283a 	ret

09094e00 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 9094e00:	defff904 	addi	sp,sp,-28
 9094e04:	dfc00615 	stw	ra,24(sp)
 9094e08:	df000515 	stw	fp,20(sp)
 9094e0c:	df000504 	addi	fp,sp,20
 9094e10:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9094e14:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9094e18:	00824374 	movhi	r2,2317
 9094e1c:	108c1304 	addi	r2,r2,12364
 9094e20:	10800003 	ldbu	r2,0(r2)
 9094e24:	10803fcc 	andi	r2,r2,255
 9094e28:	1004c03a 	cmpne	r2,r2,zero
 9094e2c:	1000421e 	bne	r2,zero,9094f38 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 9094e30:	e0bfff0b 	ldhu	r2,-4(fp)
 9094e34:	1005003a 	cmpeq	r2,r2,zero
 9094e38:	10003f1e 	bne	r2,zero,9094f38 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094e3c:	0005303a 	rdctl	r2,status
 9094e40:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094e44:	e0fffc17 	ldw	r3,-16(fp)
 9094e48:	00bfff84 	movi	r2,-2
 9094e4c:	1884703a 	and	r2,r3,r2
 9094e50:	1001703a 	wrctl	status,r2
  
  return context;
 9094e54:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 9094e58:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 9094e5c:	00824374 	movhi	r2,2317
 9094e60:	108c1404 	addi	r2,r2,12368
 9094e64:	10800017 	ldw	r2,0(r2)
 9094e68:	10800d03 	ldbu	r2,52(r2)
 9094e6c:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 9094e70:	e13ffe03 	ldbu	r4,-8(fp)
 9094e74:	e0fffe03 	ldbu	r3,-8(fp)
 9094e78:	00824374 	movhi	r2,2317
 9094e7c:	108c1144 	addi	r2,r2,12357
 9094e80:	10c5883a 	add	r2,r2,r3
 9094e84:	10800003 	ldbu	r2,0(r2)
 9094e88:	1007883a 	mov	r3,r2
 9094e8c:	00824374 	movhi	r2,2317
 9094e90:	108c1404 	addi	r2,r2,12368
 9094e94:	10800017 	ldw	r2,0(r2)
 9094e98:	10800d43 	ldbu	r2,53(r2)
 9094e9c:	0084303a 	nor	r2,zero,r2
 9094ea0:	1884703a 	and	r2,r3,r2
 9094ea4:	1007883a 	mov	r3,r2
 9094ea8:	00824374 	movhi	r2,2317
 9094eac:	108c1144 	addi	r2,r2,12357
 9094eb0:	1105883a 	add	r2,r2,r4
 9094eb4:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 9094eb8:	e0fffe03 	ldbu	r3,-8(fp)
 9094ebc:	00824374 	movhi	r2,2317
 9094ec0:	108c1144 	addi	r2,r2,12357
 9094ec4:	10c5883a 	add	r2,r2,r3
 9094ec8:	10800003 	ldbu	r2,0(r2)
 9094ecc:	10803fcc 	andi	r2,r2,255
 9094ed0:	1004c03a 	cmpne	r2,r2,zero
 9094ed4:	10000e1e 	bne	r2,zero,9094f10 <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 9094ed8:	00824374 	movhi	r2,2317
 9094edc:	108c1404 	addi	r2,r2,12368
 9094ee0:	10800017 	ldw	r2,0(r2)
 9094ee4:	10800d83 	ldbu	r2,54(r2)
 9094ee8:	0084303a 	nor	r2,zero,r2
 9094eec:	1007883a 	mov	r3,r2
 9094ef0:	00824374 	movhi	r2,2317
 9094ef4:	108c1104 	addi	r2,r2,12356
 9094ef8:	10800003 	ldbu	r2,0(r2)
 9094efc:	1884703a 	and	r2,r3,r2
 9094f00:	1007883a 	mov	r3,r2
 9094f04:	00824374 	movhi	r2,2317
 9094f08:	108c1104 	addi	r2,r2,12356
 9094f0c:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 9094f10:	00824374 	movhi	r2,2317
 9094f14:	108c1404 	addi	r2,r2,12368
 9094f18:	10c00017 	ldw	r3,0(r2)
 9094f1c:	e0bfff0b 	ldhu	r2,-4(fp)
 9094f20:	18800b8d 	sth	r2,46(r3)
 9094f24:	e0bffd17 	ldw	r2,-12(fp)
 9094f28:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094f2c:	e0bffb17 	ldw	r2,-20(fp)
 9094f30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 9094f34:	908eaf40 	call	908eaf4 <OS_Sched>
    }
}
 9094f38:	e037883a 	mov	sp,fp
 9094f3c:	dfc00117 	ldw	ra,4(sp)
 9094f40:	df000017 	ldw	fp,0(sp)
 9094f44:	dec00204 	addi	sp,sp,8
 9094f48:	f800283a 	ret

09094f4c <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 9094f4c:	defff504 	addi	sp,sp,-44
 9094f50:	dfc00a15 	stw	ra,40(sp)
 9094f54:	df000915 	stw	fp,36(sp)
 9094f58:	dc400815 	stw	r17,32(sp)
 9094f5c:	dc000715 	stw	r16,28(sp)
 9094f60:	df000704 	addi	fp,sp,28
 9094f64:	e13ffb05 	stb	r4,-20(fp)
 9094f68:	e17ffc05 	stb	r5,-16(fp)
 9094f6c:	e1bffd05 	stb	r6,-12(fp)
 9094f70:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9094f74:	00824374 	movhi	r2,2317
 9094f78:	108c1304 	addi	r2,r2,12364
 9094f7c:	10800003 	ldbu	r2,0(r2)
 9094f80:	10803fcc 	andi	r2,r2,255
 9094f84:	1005003a 	cmpeq	r2,r2,zero
 9094f88:	1000031e 	bne	r2,zero,9094f98 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
 9094f8c:	00801544 	movi	r2,85
 9094f90:	e0bfff15 	stw	r2,-4(fp)
 9094f94:	00007606 	br	9095170 <OSTimeDlyHMSM+0x224>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 9094f98:	e0bffb03 	ldbu	r2,-20(fp)
 9094f9c:	1004c03a 	cmpne	r2,r2,zero
 9094fa0:	10000c1e 	bne	r2,zero,9094fd4 <OSTimeDlyHMSM+0x88>
        if (minutes == 0) {
 9094fa4:	e0bffc03 	ldbu	r2,-16(fp)
 9094fa8:	1004c03a 	cmpne	r2,r2,zero
 9094fac:	1000091e 	bne	r2,zero,9094fd4 <OSTimeDlyHMSM+0x88>
            if (seconds == 0) {
 9094fb0:	e0bffd03 	ldbu	r2,-12(fp)
 9094fb4:	1004c03a 	cmpne	r2,r2,zero
 9094fb8:	1000061e 	bne	r2,zero,9094fd4 <OSTimeDlyHMSM+0x88>
                if (ms == 0) {
 9094fbc:	e0bffe0b 	ldhu	r2,-8(fp)
 9094fc0:	1004c03a 	cmpne	r2,r2,zero
 9094fc4:	1000031e 	bne	r2,zero,9094fd4 <OSTimeDlyHMSM+0x88>
                    return (OS_ERR_TIME_ZERO_DLY);
 9094fc8:	00801504 	movi	r2,84
 9094fcc:	e0bfff15 	stw	r2,-4(fp)
 9094fd0:	00006706 	br	9095170 <OSTimeDlyHMSM+0x224>
                }
            }
        }
    }
    if (minutes > 59) {
 9094fd4:	e0bffc03 	ldbu	r2,-16(fp)
 9094fd8:	10800f30 	cmpltui	r2,r2,60
 9094fdc:	1000031e 	bne	r2,zero,9094fec <OSTimeDlyHMSM+0xa0>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 9094fe0:	00801444 	movi	r2,81
 9094fe4:	e0bfff15 	stw	r2,-4(fp)
 9094fe8:	00006106 	br	9095170 <OSTimeDlyHMSM+0x224>
    }
    if (seconds > 59) {
 9094fec:	e0bffd03 	ldbu	r2,-12(fp)
 9094ff0:	10800f30 	cmpltui	r2,r2,60
 9094ff4:	1000031e 	bne	r2,zero,9095004 <OSTimeDlyHMSM+0xb8>
        return (OS_ERR_TIME_INVALID_SECONDS);
 9094ff8:	00801484 	movi	r2,82
 9094ffc:	e0bfff15 	stw	r2,-4(fp)
 9095000:	00005b06 	br	9095170 <OSTimeDlyHMSM+0x224>
    }
    if (ms > 999) {
 9095004:	e0bffe0b 	ldhu	r2,-8(fp)
 9095008:	1080fa30 	cmpltui	r2,r2,1000
 909500c:	1000031e 	bne	r2,zero,909501c <OSTimeDlyHMSM+0xd0>
        return (OS_ERR_TIME_INVALID_MS);
 9095010:	008014c4 	movi	r2,83
 9095014:	e0bfff15 	stw	r2,-4(fp)
 9095018:	00005506 	br	9095170 <OSTimeDlyHMSM+0x224>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 909501c:	e0bffb03 	ldbu	r2,-20(fp)
 9095020:	10c38424 	muli	r3,r2,3600
 9095024:	e0bffc03 	ldbu	r2,-16(fp)
 9095028:	10800f24 	muli	r2,r2,60
 909502c:	1887883a 	add	r3,r3,r2
 9095030:	e0bffd03 	ldbu	r2,-12(fp)
 9095034:	1889883a 	add	r4,r3,r2
 9095038:	908c0380 	call	908c038 <__floatunsidf>
 909503c:	100b883a 	mov	r5,r2
 9095040:	180d883a 	mov	r6,r3
 9095044:	2809883a 	mov	r4,r5
 9095048:	300b883a 	mov	r5,r6
 909504c:	000d883a 	mov	r6,zero
 9095050:	01d01674 	movhi	r7,16473
 9095054:	908b5b40 	call	908b5b4 <__muldf3>
 9095058:	1009883a 	mov	r4,r2
 909505c:	180b883a 	mov	r5,r3
 9095060:	2021883a 	mov	r16,r4
 9095064:	2823883a 	mov	r17,r5
 9095068:	e13ffe0b 	ldhu	r4,-8(fp)
 909506c:	908c0380 	call	908c038 <__floatunsidf>
 9095070:	100b883a 	mov	r5,r2
 9095074:	180d883a 	mov	r6,r3
 9095078:	2809883a 	mov	r4,r5
 909507c:	300b883a 	mov	r5,r6
 9095080:	000d883a 	mov	r6,zero
 9095084:	01d00534 	movhi	r7,16404
 9095088:	908b5400 	call	908b540 <__adddf3>
 909508c:	1009883a 	mov	r4,r2
 9095090:	180b883a 	mov	r5,r3
 9095094:	2005883a 	mov	r2,r4
 9095098:	2807883a 	mov	r3,r5
 909509c:	1009883a 	mov	r4,r2
 90950a0:	180b883a 	mov	r5,r3
 90950a4:	000d883a 	mov	r6,zero
 90950a8:	01d01674 	movhi	r7,16473
 90950ac:	908b5b40 	call	908b5b4 <__muldf3>
 90950b0:	1009883a 	mov	r4,r2
 90950b4:	180b883a 	mov	r5,r3
 90950b8:	2005883a 	mov	r2,r4
 90950bc:	2807883a 	mov	r3,r5
 90950c0:	1009883a 	mov	r4,r2
 90950c4:	180b883a 	mov	r5,r3
 90950c8:	000d883a 	mov	r6,zero
 90950cc:	01d023f4 	movhi	r7,16527
 90950d0:	39d00004 	addi	r7,r7,16384
 90950d4:	908b9680 	call	908b968 <__divdf3>
 90950d8:	1009883a 	mov	r4,r2
 90950dc:	180b883a 	mov	r5,r3
 90950e0:	2005883a 	mov	r2,r4
 90950e4:	2807883a 	mov	r3,r5
 90950e8:	8009883a 	mov	r4,r16
 90950ec:	880b883a 	mov	r5,r17
 90950f0:	100d883a 	mov	r6,r2
 90950f4:	180f883a 	mov	r7,r3
 90950f8:	908b5400 	call	908b540 <__adddf3>
 90950fc:	1009883a 	mov	r4,r2
 9095100:	180b883a 	mov	r5,r3
 9095104:	2005883a 	mov	r2,r4
 9095108:	2807883a 	mov	r3,r5
 909510c:	1009883a 	mov	r4,r2
 9095110:	180b883a 	mov	r5,r3
 9095114:	90cade40 	call	90cade4 <__fixunsdfsi>
 9095118:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 909511c:	e0bffa17 	ldw	r2,-24(fp)
 9095120:	1004d43a 	srli	r2,r2,16
 9095124:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 9095128:	e0bffa17 	ldw	r2,-24(fp)
 909512c:	10bfffcc 	andi	r2,r2,65535
 9095130:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 9095134:	e0bffa17 	ldw	r2,-24(fp)
 9095138:	113fffcc 	andi	r4,r2,65535
 909513c:	9094e000 	call	9094e00 <OSTimeDly>
    while (loops > 0) {
 9095140:	00000706 	br	9095160 <OSTimeDlyHMSM+0x214>
        OSTimeDly((INT16U)32768u);
 9095144:	01200014 	movui	r4,32768
 9095148:	9094e000 	call	9094e00 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 909514c:	01200014 	movui	r4,32768
 9095150:	9094e000 	call	9094e00 <OSTimeDly>
        loops--;
 9095154:	e0bff90b 	ldhu	r2,-28(fp)
 9095158:	10bfffc4 	addi	r2,r2,-1
 909515c:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 9095160:	e0bff90b 	ldhu	r2,-28(fp)
 9095164:	1004c03a 	cmpne	r2,r2,zero
 9095168:	103ff61e 	bne	r2,zero,9095144 <OSTimeDlyHMSM+0x1f8>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 909516c:	e03fff15 	stw	zero,-4(fp)
 9095170:	e0bfff17 	ldw	r2,-4(fp)
}
 9095174:	e037883a 	mov	sp,fp
 9095178:	dfc00317 	ldw	ra,12(sp)
 909517c:	df000217 	ldw	fp,8(sp)
 9095180:	dc400117 	ldw	r17,4(sp)
 9095184:	dc000017 	ldw	r16,0(sp)
 9095188:	dec00404 	addi	sp,sp,16
 909518c:	f800283a 	ret

09095190 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 9095190:	defff404 	addi	sp,sp,-48
 9095194:	dfc00b15 	stw	ra,44(sp)
 9095198:	df000a15 	stw	fp,40(sp)
 909519c:	df000a04 	addi	fp,sp,40
 90951a0:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90951a4:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 90951a8:	e0bffe03 	ldbu	r2,-8(fp)
 90951ac:	10800530 	cmpltui	r2,r2,20
 90951b0:	1000031e 	bne	r2,zero,90951c0 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 90951b4:	00800a84 	movi	r2,42
 90951b8:	e0bfff15 	stw	r2,-4(fp)
 90951bc:	00007206 	br	9095388 <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90951c0:	0005303a 	rdctl	r2,status
 90951c4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90951c8:	e0fffb17 	ldw	r3,-20(fp)
 90951cc:	00bfff84 	movi	r2,-2
 90951d0:	1884703a 	and	r2,r3,r2
 90951d4:	1001703a 	wrctl	status,r2
  
  return context;
 90951d8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 90951dc:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 90951e0:	e0bffe03 	ldbu	r2,-8(fp)
 90951e4:	00c243b4 	movhi	r3,2318
 90951e8:	18f2ac04 	addi	r3,r3,-13648
 90951ec:	1085883a 	add	r2,r2,r2
 90951f0:	1085883a 	add	r2,r2,r2
 90951f4:	10c5883a 	add	r2,r2,r3
 90951f8:	10800017 	ldw	r2,0(r2)
 90951fc:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 9095200:	e0bffd17 	ldw	r2,-12(fp)
 9095204:	1004c03a 	cmpne	r2,r2,zero
 9095208:	1000071e 	bne	r2,zero,9095228 <OSTimeDlyResume+0x98>
 909520c:	e0bffc17 	ldw	r2,-16(fp)
 9095210:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095214:	e0bffa17 	ldw	r2,-24(fp)
 9095218:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 909521c:	008010c4 	movi	r2,67
 9095220:	e0bfff15 	stw	r2,-4(fp)
 9095224:	00005806 	br	9095388 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 9095228:	e0bffd17 	ldw	r2,-12(fp)
 909522c:	10800058 	cmpnei	r2,r2,1
 9095230:	1000071e 	bne	r2,zero,9095250 <OSTimeDlyResume+0xc0>
 9095234:	e0bffc17 	ldw	r2,-16(fp)
 9095238:	e0bff915 	stw	r2,-28(fp)
 909523c:	e0bff917 	ldw	r2,-28(fp)
 9095240:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 9095244:	008010c4 	movi	r2,67
 9095248:	e0bfff15 	stw	r2,-4(fp)
 909524c:	00004e06 	br	9095388 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 9095250:	e0bffd17 	ldw	r2,-12(fp)
 9095254:	10800b8b 	ldhu	r2,46(r2)
 9095258:	10bfffcc 	andi	r2,r2,65535
 909525c:	1004c03a 	cmpne	r2,r2,zero
 9095260:	1000071e 	bne	r2,zero,9095280 <OSTimeDlyResume+0xf0>
 9095264:	e0bffc17 	ldw	r2,-16(fp)
 9095268:	e0bff815 	stw	r2,-32(fp)
 909526c:	e0bff817 	ldw	r2,-32(fp)
 9095270:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 9095274:	00801404 	movi	r2,80
 9095278:	e0bfff15 	stw	r2,-4(fp)
 909527c:	00004206 	br	9095388 <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 9095280:	e0bffd17 	ldw	r2,-12(fp)
 9095284:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 9095288:	e0bffd17 	ldw	r2,-12(fp)
 909528c:	10800c03 	ldbu	r2,48(r2)
 9095290:	10803fcc 	andi	r2,r2,255
 9095294:	10800dcc 	andi	r2,r2,55
 9095298:	1005003a 	cmpeq	r2,r2,zero
 909529c:	10000b1e 	bne	r2,zero,90952cc <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 90952a0:	e0bffd17 	ldw	r2,-12(fp)
 90952a4:	10c00c03 	ldbu	r3,48(r2)
 90952a8:	00bff204 	movi	r2,-56
 90952ac:	1884703a 	and	r2,r3,r2
 90952b0:	1007883a 	mov	r3,r2
 90952b4:	e0bffd17 	ldw	r2,-12(fp)
 90952b8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 90952bc:	e0fffd17 	ldw	r3,-12(fp)
 90952c0:	00800044 	movi	r2,1
 90952c4:	18800c45 	stb	r2,49(r3)
 90952c8:	00000206 	br	90952d4 <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 90952cc:	e0bffd17 	ldw	r2,-12(fp)
 90952d0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 90952d4:	e0bffd17 	ldw	r2,-12(fp)
 90952d8:	10800c03 	ldbu	r2,48(r2)
 90952dc:	10803fcc 	andi	r2,r2,255
 90952e0:	1080020c 	andi	r2,r2,8
 90952e4:	1004c03a 	cmpne	r2,r2,zero
 90952e8:	1000221e 	bne	r2,zero,9095374 <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 90952ec:	e0bffd17 	ldw	r2,-12(fp)
 90952f0:	10c00d83 	ldbu	r3,54(r2)
 90952f4:	00824374 	movhi	r2,2317
 90952f8:	108c1104 	addi	r2,r2,12356
 90952fc:	10800003 	ldbu	r2,0(r2)
 9095300:	1884b03a 	or	r2,r3,r2
 9095304:	1007883a 	mov	r3,r2
 9095308:	00824374 	movhi	r2,2317
 909530c:	108c1104 	addi	r2,r2,12356
 9095310:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9095314:	e0bffd17 	ldw	r2,-12(fp)
 9095318:	10800d03 	ldbu	r2,52(r2)
 909531c:	11003fcc 	andi	r4,r2,255
 9095320:	e0bffd17 	ldw	r2,-12(fp)
 9095324:	10800d03 	ldbu	r2,52(r2)
 9095328:	10c03fcc 	andi	r3,r2,255
 909532c:	00824374 	movhi	r2,2317
 9095330:	108c1144 	addi	r2,r2,12357
 9095334:	10c5883a 	add	r2,r2,r3
 9095338:	10c00003 	ldbu	r3,0(r2)
 909533c:	e0bffd17 	ldw	r2,-12(fp)
 9095340:	10800d43 	ldbu	r2,53(r2)
 9095344:	1884b03a 	or	r2,r3,r2
 9095348:	1007883a 	mov	r3,r2
 909534c:	00824374 	movhi	r2,2317
 9095350:	108c1144 	addi	r2,r2,12357
 9095354:	1105883a 	add	r2,r2,r4
 9095358:	10c00005 	stb	r3,0(r2)
 909535c:	e0bffc17 	ldw	r2,-16(fp)
 9095360:	e0bff715 	stw	r2,-36(fp)
 9095364:	e0bff717 	ldw	r2,-36(fp)
 9095368:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 909536c:	908eaf40 	call	908eaf4 <OS_Sched>
 9095370:	00000406 	br	9095384 <OSTimeDlyResume+0x1f4>
 9095374:	e0bffc17 	ldw	r2,-16(fp)
 9095378:	e0bff615 	stw	r2,-40(fp)
 909537c:	e0bff617 	ldw	r2,-40(fp)
 9095380:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 9095384:	e03fff15 	stw	zero,-4(fp)
 9095388:	e0bfff17 	ldw	r2,-4(fp)
}
 909538c:	e037883a 	mov	sp,fp
 9095390:	dfc00117 	ldw	ra,4(sp)
 9095394:	df000017 	ldw	fp,0(sp)
 9095398:	dec00204 	addi	sp,sp,8
 909539c:	f800283a 	ret

090953a0 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 90953a0:	defffb04 	addi	sp,sp,-20
 90953a4:	df000415 	stw	fp,16(sp)
 90953a8:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 90953ac:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90953b0:	0005303a 	rdctl	r2,status
 90953b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90953b8:	e0fffd17 	ldw	r3,-12(fp)
 90953bc:	00bfff84 	movi	r2,-2
 90953c0:	1884703a 	and	r2,r3,r2
 90953c4:	1001703a 	wrctl	status,r2
  
  return context;
 90953c8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 90953cc:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 90953d0:	00824374 	movhi	r2,2317
 90953d4:	108c1504 	addi	r2,r2,12372
 90953d8:	10800017 	ldw	r2,0(r2)
 90953dc:	e0bfff15 	stw	r2,-4(fp)
 90953e0:	e0bffe17 	ldw	r2,-8(fp)
 90953e4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90953e8:	e0bffc17 	ldw	r2,-16(fp)
 90953ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 90953f0:	e0bfff17 	ldw	r2,-4(fp)
}
 90953f4:	e037883a 	mov	sp,fp
 90953f8:	df000017 	ldw	fp,0(sp)
 90953fc:	dec00104 	addi	sp,sp,4
 9095400:	f800283a 	ret

09095404 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 9095404:	defffb04 	addi	sp,sp,-20
 9095408:	df000415 	stw	fp,16(sp)
 909540c:	df000404 	addi	fp,sp,16
 9095410:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9095414:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095418:	0005303a 	rdctl	r2,status
 909541c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095420:	e0fffd17 	ldw	r3,-12(fp)
 9095424:	00bfff84 	movi	r2,-2
 9095428:	1884703a 	and	r2,r3,r2
 909542c:	1001703a 	wrctl	status,r2
  
  return context;
 9095430:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 9095434:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 9095438:	00c24374 	movhi	r3,2317
 909543c:	18cc1504 	addi	r3,r3,12372
 9095440:	e0bfff17 	ldw	r2,-4(fp)
 9095444:	18800015 	stw	r2,0(r3)
 9095448:	e0bffe17 	ldw	r2,-8(fp)
 909544c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095450:	e0bffc17 	ldw	r2,-16(fp)
 9095454:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 9095458:	e037883a 	mov	sp,fp
 909545c:	df000017 	ldw	fp,0(sp)
 9095460:	dec00104 	addi	sp,sp,4
 9095464:	f800283a 	ret

09095468 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 9095468:	defffd04 	addi	sp,sp,-12
 909546c:	dfc00215 	stw	ra,8(sp)
 9095470:	df000115 	stw	fp,4(sp)
 9095474:	df000104 	addi	fp,sp,4
 9095478:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 909547c:	90b9e440 	call	90b9e44 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 9095480:	00800044 	movi	r2,1
 9095484:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 9095488:	e037883a 	mov	sp,fp
 909548c:	dfc00117 	ldw	ra,4(sp)
 9095490:	df000017 	ldw	fp,0(sp)
 9095494:	dec00204 	addi	sp,sp,8
 9095498:	f800283a 	ret

0909549c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 909549c:	defffa04 	addi	sp,sp,-24
 90954a0:	dfc00515 	stw	ra,20(sp)
 90954a4:	df000415 	stw	fp,16(sp)
 90954a8:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 90954ac:	01020034 	movhi	r4,2048
 90954b0:	21001804 	addi	r4,r4,96
 90954b4:	000b883a 	mov	r5,zero
 90954b8:	000d883a 	mov	r6,zero
 90954bc:	01c01904 	movi	r7,100
 90954c0:	909a0280 	call	909a028 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 90954c4:	01024374 	movhi	r4,2317
 90954c8:	2105f604 	addi	r4,r4,6104
 90954cc:	90957540 	call	9095754 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 90954d0:	01024374 	movhi	r4,2317
 90954d4:	21063604 	addi	r4,r4,6360
 90954d8:	000b883a 	mov	r5,zero
 90954dc:	01800144 	movi	r6,5
 90954e0:	909761c0 	call	909761c <altera_avalon_jtag_uart_init>
 90954e4:	01024374 	movhi	r4,2317
 90954e8:	21062c04 	addi	r4,r4,6320
 90954ec:	909571c0 	call	909571c <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 90954f0:	01024374 	movhi	r4,2317
 90954f4:	210a5104 	addi	r4,r4,10564
 90954f8:	90990000 	call	9099000 <altera_avalon_lcd_16207_init>
 90954fc:	01024374 	movhi	r4,2317
 9095500:	210a4704 	addi	r4,r4,10524
 9095504:	909571c0 	call	909571c <alt_dev_reg>
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER, performance_counter);
 9095508:	00c20034 	movhi	r3,2048
 909550c:	00800044 	movi	r2,1
 9095510:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 9095514:	01024374 	movhi	r4,2317
 9095518:	210a9004 	addi	r4,r4,10816
 909551c:	000b883a 	mov	r5,zero
 9095520:	018000c4 	movi	r6,3
 9095524:	9099f0c0 	call	9099f0c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 9095528:	01024374 	movhi	r4,2317
 909552c:	210a9c04 	addi	r4,r4,10864
 9095530:	000b883a 	mov	r5,zero
 9095534:	01800084 	movi	r6,2
 9095538:	9099f0c0 	call	9099f0c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 909553c:	e03fff15 	stw	zero,-4(fp)
 9095540:	00800044 	movi	r2,1
 9095544:	e0bffe15 	stw	r2,-8(fp)
 9095548:	e0bffe17 	ldw	r2,-8(fp)
 909554c:	10800048 	cmpgei	r2,r2,1
 9095550:	1000021e 	bne	r2,zero,909555c <alt_sys_init+0xc0>
 9095554:	00800044 	movi	r2,1
 9095558:	e0bffe15 	stw	r2,-8(fp)
 909555c:	e03fff15 	stw	zero,-4(fp)
 9095560:	00006606 	br	90956fc <alt_sys_init+0x260>
 9095564:	e0bfff17 	ldw	r2,-4(fp)
 9095568:	00c243b4 	movhi	r3,2318
 909556c:	18f2c104 	addi	r3,r3,-13564
 9095570:	10800724 	muli	r2,r2,28
 9095574:	10c5883a 	add	r2,r2,r3
 9095578:	10000015 	stw	zero,0(r2)
 909557c:	e0bfff17 	ldw	r2,-4(fp)
 9095580:	00c243b4 	movhi	r3,2318
 9095584:	18f2c104 	addi	r3,r3,-13564
 9095588:	10800724 	muli	r2,r2,28
 909558c:	10c5883a 	add	r2,r2,r3
 9095590:	10800104 	addi	r2,r2,4
 9095594:	10000015 	stw	zero,0(r2)
 9095598:	e0bfff17 	ldw	r2,-4(fp)
 909559c:	d1202717 	ldw	r4,-32612(gp)
 90955a0:	00c243b4 	movhi	r3,2318
 90955a4:	18f2c104 	addi	r3,r3,-13564
 90955a8:	10800724 	muli	r2,r2,28
 90955ac:	10c5883a 	add	r2,r2,r3
 90955b0:	10800204 	addi	r2,r2,8
 90955b4:	11000015 	stw	r4,0(r2)
 90955b8:	e0bfff17 	ldw	r2,-4(fp)
 90955bc:	00c243b4 	movhi	r3,2318
 90955c0:	18f2c104 	addi	r3,r3,-13564
 90955c4:	10800724 	muli	r2,r2,28
 90955c8:	10c5883a 	add	r2,r2,r3
 90955cc:	10c00304 	addi	r3,r2,12
 90955d0:	008242b4 	movhi	r2,2314
 90955d4:	10bcfe04 	addi	r2,r2,-3080
 90955d8:	18800015 	stw	r2,0(r3)
 90955dc:	e0bfff17 	ldw	r2,-4(fp)
 90955e0:	10c00724 	muli	r3,r2,28
 90955e4:	008243b4 	movhi	r2,2318
 90955e8:	10b2c104 	addi	r2,r2,-13564
 90955ec:	1887883a 	add	r3,r3,r2
 90955f0:	00824374 	movhi	r2,2317
 90955f4:	108bc604 	addi	r2,r2,12056
 90955f8:	e0bffc15 	stw	r2,-16(fp)
 90955fc:	e0fffd15 	stw	r3,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 9095600:	e0fffd17 	ldw	r3,-12(fp)
 9095604:	e0bffc17 	ldw	r2,-16(fp)
 9095608:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 909560c:	e0bffc17 	ldw	r2,-16(fp)
 9095610:	10c00017 	ldw	r3,0(r2)
 9095614:	e0bffd17 	ldw	r2,-12(fp)
 9095618:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 909561c:	e0bffc17 	ldw	r2,-16(fp)
 9095620:	10c00017 	ldw	r3,0(r2)
 9095624:	e0bffd17 	ldw	r2,-12(fp)
 9095628:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 909562c:	e0fffc17 	ldw	r3,-16(fp)
 9095630:	e0bffd17 	ldw	r2,-12(fp)
 9095634:	18800015 	stw	r2,0(r3)
 9095638:	00824374 	movhi	r2,2317
 909563c:	108c1a04 	addi	r2,r2,12392
 9095640:	10800003 	ldbu	r2,0(r2)
 9095644:	11403fcc 	andi	r5,r2,255
 9095648:	e0bfff17 	ldw	r2,-4(fp)
 909564c:	10c00724 	muli	r3,r2,28
 9095650:	008243b4 	movhi	r2,2318
 9095654:	10b2c104 	addi	r2,r2,-13564
 9095658:	1889883a 	add	r4,r3,r2
 909565c:	00c243b4 	movhi	r3,2318
 9095660:	18f30104 	addi	r3,r3,-13308
 9095664:	28800324 	muli	r2,r5,12
 9095668:	10c5883a 	add	r2,r2,r3
 909566c:	11000015 	stw	r4,0(r2)
 9095670:	00824374 	movhi	r2,2317
 9095674:	108c1a04 	addi	r2,r2,12392
 9095678:	10800003 	ldbu	r2,0(r2)
 909567c:	10803fcc 	andi	r2,r2,255
 9095680:	00c243b4 	movhi	r3,2318
 9095684:	18f30104 	addi	r3,r3,-13308
 9095688:	10800324 	muli	r2,r2,12
 909568c:	10c5883a 	add	r2,r2,r3
 9095690:	10c00104 	addi	r3,r2,4
 9095694:	00824434 	movhi	r2,2320
 9095698:	108c0004 	addi	r2,r2,12288
 909569c:	18800015 	stw	r2,0(r3)
 90956a0:	00824374 	movhi	r2,2317
 90956a4:	108c1a04 	addi	r2,r2,12392
 90956a8:	10800003 	ldbu	r2,0(r2)
 90956ac:	11003fcc 	andi	r4,r2,255
 90956b0:	e0bfff17 	ldw	r2,-4(fp)
 90956b4:	100b883a 	mov	r5,r2
 90956b8:	00c243b4 	movhi	r3,2318
 90956bc:	18f30104 	addi	r3,r3,-13308
 90956c0:	20800324 	muli	r2,r4,12
 90956c4:	10c5883a 	add	r2,r2,r3
 90956c8:	10800204 	addi	r2,r2,8
 90956cc:	11400005 	stb	r5,0(r2)
 90956d0:	00824374 	movhi	r2,2317
 90956d4:	108c1a04 	addi	r2,r2,12392
 90956d8:	10800003 	ldbu	r2,0(r2)
 90956dc:	10800044 	addi	r2,r2,1
 90956e0:	1007883a 	mov	r3,r2
 90956e4:	00824374 	movhi	r2,2317
 90956e8:	108c1a04 	addi	r2,r2,12392
 90956ec:	10c00005 	stb	r3,0(r2)
 90956f0:	e0bfff17 	ldw	r2,-4(fp)
 90956f4:	10800044 	addi	r2,r2,1
 90956f8:	e0bfff15 	stw	r2,-4(fp)
 90956fc:	e0ffff17 	ldw	r3,-4(fp)
 9095700:	e0bffe17 	ldw	r2,-8(fp)
 9095704:	18bf9716 	blt	r3,r2,9095564 <alt_sys_init+0xc8>
}
 9095708:	e037883a 	mov	sp,fp
 909570c:	dfc00117 	ldw	ra,4(sp)
 9095710:	df000017 	ldw	fp,0(sp)
 9095714:	dec00204 	addi	sp,sp,8
 9095718:	f800283a 	ret

0909571c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 909571c:	defffd04 	addi	sp,sp,-12
 9095720:	dfc00215 	stw	ra,8(sp)
 9095724:	df000115 	stw	fp,4(sp)
 9095728:	df000104 	addi	fp,sp,4
 909572c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 9095730:	e13fff17 	ldw	r4,-4(fp)
 9095734:	01424374 	movhi	r5,2317
 9095738:	294bdc04 	addi	r5,r5,12144
 909573c:	90b8cf00 	call	90b8cf0 <alt_dev_llist_insert>
}
 9095740:	e037883a 	mov	sp,fp
 9095744:	dfc00117 	ldw	ra,4(sp)
 9095748:	df000017 	ldw	fp,0(sp)
 909574c:	dec00204 	addi	sp,sp,8
 9095750:	f800283a 	ret

09095754 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 9095754:	defffc04 	addi	sp,sp,-16
 9095758:	dfc00315 	stw	ra,12(sp)
 909575c:	df000215 	stw	fp,8(sp)
 9095760:	df000204 	addi	fp,sp,8
 9095764:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 9095768:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 909576c:	e13fff17 	ldw	r4,-4(fp)
 9095770:	9096c4c0 	call	9096c4c <alt_read_cfi_width>
 9095774:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9095778:	e0bffe17 	ldw	r2,-8(fp)
 909577c:	1004c03a 	cmpne	r2,r2,zero
 9095780:	1000031e 	bne	r2,zero,9095790 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 9095784:	e13fff17 	ldw	r4,-4(fp)
 9095788:	90963640 	call	9096364 <alt_set_flash_width_func>
 909578c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9095790:	e0bffe17 	ldw	r2,-8(fp)
 9095794:	1004c03a 	cmpne	r2,r2,zero
 9095798:	1000031e 	bne	r2,zero,90957a8 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 909579c:	e13fff17 	ldw	r4,-4(fp)
 90957a0:	909666c0 	call	909666c <alt_read_cfi_table>
 90957a4:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 90957a8:	e0bffe17 	ldw	r2,-8(fp)
 90957ac:	1004c03a 	cmpne	r2,r2,zero
 90957b0:	1000031e 	bne	r2,zero,90957c0 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 90957b4:	e13fff17 	ldw	r4,-4(fp)
 90957b8:	90965440 	call	9096544 <alt_set_flash_algorithm_func>
 90957bc:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 90957c0:	e0bffe17 	ldw	r2,-8(fp)
 90957c4:	1004c03a 	cmpne	r2,r2,zero
 90957c8:	1000031e 	bne	r2,zero,90957d8 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 90957cc:	e13fff17 	ldw	r4,-4(fp)
 90957d0:	90957f00 	call	90957f0 <alt_flash_device_register>
 90957d4:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 90957d8:	e0bffe17 	ldw	r2,-8(fp)
}
 90957dc:	e037883a 	mov	sp,fp
 90957e0:	dfc00117 	ldw	ra,4(sp)
 90957e4:	df000017 	ldw	fp,0(sp)
 90957e8:	dec00204 	addi	sp,sp,8
 90957ec:	f800283a 	ret

090957f0 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 90957f0:	defffd04 	addi	sp,sp,-12
 90957f4:	dfc00215 	stw	ra,8(sp)
 90957f8:	df000115 	stw	fp,4(sp)
 90957fc:	df000104 	addi	fp,sp,4
 9095800:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 9095804:	e13fff17 	ldw	r4,-4(fp)
 9095808:	01424374 	movhi	r5,2317
 909580c:	294be004 	addi	r5,r5,12160
 9095810:	90b8cf00 	call	90b8cf0 <alt_dev_llist_insert>
}
 9095814:	e037883a 	mov	sp,fp
 9095818:	dfc00117 	ldw	ra,4(sp)
 909581c:	df000017 	ldw	fp,0(sp)
 9095820:	dec00204 	addi	sp,sp,8
 9095824:	f800283a 	ret

09095828 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 9095828:	deffef04 	addi	sp,sp,-68
 909582c:	dfc01015 	stw	ra,64(sp)
 9095830:	df000f15 	stw	fp,60(sp)
 9095834:	df000f04 	addi	fp,sp,60
 9095838:	e13ffa15 	stw	r4,-24(fp)
 909583c:	e17ffb15 	stw	r5,-20(fp)
 9095840:	e1bffc15 	stw	r6,-16(fp)
 9095844:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 9095848:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 909584c:	e0bffd17 	ldw	r2,-12(fp)
 9095850:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 9095854:	e0bffb17 	ldw	r2,-20(fp)
 9095858:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 909585c:	e0bffa17 	ldw	r2,-24(fp)
 9095860:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9095864:	e03ff815 	stw	zero,-32(fp)
 9095868:	00008e06 	br	9095aa4 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 909586c:	e0bff817 	ldw	r2,-32(fp)
 9095870:	e0fff217 	ldw	r3,-56(fp)
 9095874:	1004913a 	slli	r2,r2,4
 9095878:	10c5883a 	add	r2,r2,r3
 909587c:	10800d04 	addi	r2,r2,52
 9095880:	10c00017 	ldw	r3,0(r2)
 9095884:	e0bffb17 	ldw	r2,-20(fp)
 9095888:	10c08316 	blt	r2,r3,9095a98 <alt_flash_cfi_write+0x270>
 909588c:	e0bff817 	ldw	r2,-32(fp)
 9095890:	e0fff217 	ldw	r3,-56(fp)
 9095894:	1004913a 	slli	r2,r2,4
 9095898:	10c5883a 	add	r2,r2,r3
 909589c:	10800d04 	addi	r2,r2,52
 90958a0:	11000017 	ldw	r4,0(r2)
 90958a4:	e0bff817 	ldw	r2,-32(fp)
 90958a8:	e0fff217 	ldw	r3,-56(fp)
 90958ac:	1004913a 	slli	r2,r2,4
 90958b0:	10c5883a 	add	r2,r2,r3
 90958b4:	10800e04 	addi	r2,r2,56
 90958b8:	10800017 	ldw	r2,0(r2)
 90958bc:	2087883a 	add	r3,r4,r2
 90958c0:	e0bffb17 	ldw	r2,-20(fp)
 90958c4:	10c0740e 	bge	r2,r3,9095a98 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 90958c8:	e0bff817 	ldw	r2,-32(fp)
 90958cc:	e0fff217 	ldw	r3,-56(fp)
 90958d0:	1004913a 	slli	r2,r2,4
 90958d4:	10c5883a 	add	r2,r2,r3
 90958d8:	10800d04 	addi	r2,r2,52
 90958dc:	10800017 	ldw	r2,0(r2)
 90958e0:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 90958e4:	e03ff715 	stw	zero,-36(fp)
 90958e8:	00006306 	br	9095a78 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 90958ec:	e0fffb17 	ldw	r3,-20(fp)
 90958f0:	e0bff417 	ldw	r2,-48(fp)
 90958f4:	18805416 	blt	r3,r2,9095a48 <alt_flash_cfi_write+0x220>
 90958f8:	e0bff817 	ldw	r2,-32(fp)
 90958fc:	e0fff217 	ldw	r3,-56(fp)
 9095900:	1004913a 	slli	r2,r2,4
 9095904:	10c5883a 	add	r2,r2,r3
 9095908:	10801004 	addi	r2,r2,64
 909590c:	10c00017 	ldw	r3,0(r2)
 9095910:	e0bff417 	ldw	r2,-48(fp)
 9095914:	1887883a 	add	r3,r3,r2
 9095918:	e0bffb17 	ldw	r2,-20(fp)
 909591c:	10c04a0e 	bge	r2,r3,9095a48 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 9095920:	e0bff817 	ldw	r2,-32(fp)
 9095924:	e0fff217 	ldw	r3,-56(fp)
 9095928:	1004913a 	slli	r2,r2,4
 909592c:	10c5883a 	add	r2,r2,r3
 9095930:	10801004 	addi	r2,r2,64
 9095934:	10c00017 	ldw	r3,0(r2)
 9095938:	e0bff417 	ldw	r2,-48(fp)
 909593c:	1887883a 	add	r3,r3,r2
 9095940:	e0bffb17 	ldw	r2,-20(fp)
 9095944:	1885c83a 	sub	r2,r3,r2
 9095948:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 909594c:	e0bff617 	ldw	r2,-40(fp)
 9095950:	e0bfff15 	stw	r2,-4(fp)
 9095954:	e0fffd17 	ldw	r3,-12(fp)
 9095958:	e0fffe15 	stw	r3,-8(fp)
 909595c:	e0bfff17 	ldw	r2,-4(fp)
 9095960:	e0fffe17 	ldw	r3,-8(fp)
 9095964:	10c0020e 	bge	r2,r3,9095970 <alt_flash_cfi_write+0x148>
 9095968:	e0bfff17 	ldw	r2,-4(fp)
 909596c:	e0bffe15 	stw	r2,-8(fp)
 9095970:	e0fffe17 	ldw	r3,-8(fp)
 9095974:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 9095978:	e0bff217 	ldw	r2,-56(fp)
 909597c:	10800a17 	ldw	r2,40(r2)
 9095980:	1007883a 	mov	r3,r2
 9095984:	e0bffb17 	ldw	r2,-20(fp)
 9095988:	188b883a 	add	r5,r3,r2
 909598c:	e1bff617 	ldw	r6,-40(fp)
 9095990:	e13ffc17 	ldw	r4,-16(fp)
 9095994:	90ca5400 	call	90ca540 <memcmp>
 9095998:	1005003a 	cmpeq	r2,r2,zero
 909599c:	1000131e 	bne	r2,zero,90959ec <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 90959a0:	e0bff217 	ldw	r2,-56(fp)
 90959a4:	10800817 	ldw	r2,32(r2)
 90959a8:	e13ff217 	ldw	r4,-56(fp)
 90959ac:	e17ff417 	ldw	r5,-48(fp)
 90959b0:	103ee83a 	callr	r2
 90959b4:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 90959b8:	e0bff917 	ldw	r2,-28(fp)
 90959bc:	1004c03a 	cmpne	r2,r2,zero
 90959c0:	10000a1e 	bne	r2,zero,90959ec <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 90959c4:	e0bff217 	ldw	r2,-56(fp)
 90959c8:	10c00917 	ldw	r3,36(r2)
 90959cc:	e13ff217 	ldw	r4,-56(fp)
 90959d0:	e0bff617 	ldw	r2,-40(fp)
 90959d4:	d8800015 	stw	r2,0(sp)
 90959d8:	e17ff417 	ldw	r5,-48(fp)
 90959dc:	e1bffb17 	ldw	r6,-20(fp)
 90959e0:	e1fffc17 	ldw	r7,-16(fp)
 90959e4:	183ee83a 	callr	r3
 90959e8:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 90959ec:	e0fffd17 	ldw	r3,-12(fp)
 90959f0:	e0bff617 	ldw	r2,-40(fp)
 90959f4:	18802f26 	beq	r3,r2,9095ab4 <alt_flash_cfi_write+0x28c>
 90959f8:	e0bff917 	ldw	r2,-28(fp)
 90959fc:	1004c03a 	cmpne	r2,r2,zero
 9095a00:	10002c1e 	bne	r2,zero,9095ab4 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 9095a04:	e0fffd17 	ldw	r3,-12(fp)
 9095a08:	e0bff617 	ldw	r2,-40(fp)
 9095a0c:	1885c83a 	sub	r2,r3,r2
 9095a10:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 9095a14:	e0bff817 	ldw	r2,-32(fp)
 9095a18:	e0fff217 	ldw	r3,-56(fp)
 9095a1c:	1004913a 	slli	r2,r2,4
 9095a20:	10c5883a 	add	r2,r2,r3
 9095a24:	10801004 	addi	r2,r2,64
 9095a28:	10c00017 	ldw	r3,0(r2)
 9095a2c:	e0bff417 	ldw	r2,-48(fp)
 9095a30:	1885883a 	add	r2,r3,r2
 9095a34:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 9095a38:	e0fffc17 	ldw	r3,-16(fp)
 9095a3c:	e0bff617 	ldw	r2,-40(fp)
 9095a40:	1885883a 	add	r2,r3,r2
 9095a44:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 9095a48:	e0bff817 	ldw	r2,-32(fp)
 9095a4c:	e0fff217 	ldw	r3,-56(fp)
 9095a50:	1004913a 	slli	r2,r2,4
 9095a54:	10c5883a 	add	r2,r2,r3
 9095a58:	10801004 	addi	r2,r2,64
 9095a5c:	10c00017 	ldw	r3,0(r2)
 9095a60:	e0bff417 	ldw	r2,-48(fp)
 9095a64:	10c5883a 	add	r2,r2,r3
 9095a68:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 9095a6c:	e0bff717 	ldw	r2,-36(fp)
 9095a70:	10800044 	addi	r2,r2,1
 9095a74:	e0bff715 	stw	r2,-36(fp)
 9095a78:	e0bff817 	ldw	r2,-32(fp)
 9095a7c:	e0fff217 	ldw	r3,-56(fp)
 9095a80:	1004913a 	slli	r2,r2,4
 9095a84:	10c5883a 	add	r2,r2,r3
 9095a88:	10800f04 	addi	r2,r2,60
 9095a8c:	10c00017 	ldw	r3,0(r2)
 9095a90:	e0bff717 	ldw	r2,-36(fp)
 9095a94:	10ff9516 	blt	r2,r3,90958ec <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9095a98:	e0bff817 	ldw	r2,-32(fp)
 9095a9c:	10800044 	addi	r2,r2,1
 9095aa0:	e0bff815 	stw	r2,-32(fp)
 9095aa4:	e0bff217 	ldw	r2,-56(fp)
 9095aa8:	10c00c17 	ldw	r3,48(r2)
 9095aac:	e0bff817 	ldw	r2,-32(fp)
 9095ab0:	10ff6e16 	blt	r2,r3,909586c <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 9095ab4:	e0bff217 	ldw	r2,-56(fp)
 9095ab8:	10800a17 	ldw	r2,40(r2)
 9095abc:	1007883a 	mov	r3,r2
 9095ac0:	e0bff317 	ldw	r2,-52(fp)
 9095ac4:	1889883a 	add	r4,r3,r2
 9095ac8:	e17ff517 	ldw	r5,-44(fp)
 9095acc:	90b8c4c0 	call	90b8c4c <alt_dcache_flush>
  return ret_code;
 9095ad0:	e0bff917 	ldw	r2,-28(fp)
}
 9095ad4:	e037883a 	mov	sp,fp
 9095ad8:	dfc00117 	ldw	ra,4(sp)
 9095adc:	df000017 	ldw	fp,0(sp)
 9095ae0:	dec00204 	addi	sp,sp,8
 9095ae4:	f800283a 	ret

09095ae8 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 9095ae8:	defffa04 	addi	sp,sp,-24
 9095aec:	df000515 	stw	fp,20(sp)
 9095af0:	df000504 	addi	fp,sp,20
 9095af4:	e13ffd15 	stw	r4,-12(fp)
 9095af8:	e17ffe15 	stw	r5,-8(fp)
 9095afc:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 9095b00:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 9095b04:	e0bffd17 	ldw	r2,-12(fp)
 9095b08:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 9095b0c:	e0bffb17 	ldw	r2,-20(fp)
 9095b10:	10c00c17 	ldw	r3,48(r2)
 9095b14:	e0bfff17 	ldw	r2,-4(fp)
 9095b18:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 9095b1c:	e0bffb17 	ldw	r2,-20(fp)
 9095b20:	10800c17 	ldw	r2,48(r2)
 9095b24:	1004c03a 	cmpne	r2,r2,zero
 9095b28:	1000031e 	bne	r2,zero,9095b38 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 9095b2c:	00bffec4 	movi	r2,-5
 9095b30:	e0bffc15 	stw	r2,-16(fp)
 9095b34:	00000b06 	br	9095b64 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 9095b38:	e0bffb17 	ldw	r2,-20(fp)
 9095b3c:	10800c17 	ldw	r2,48(r2)
 9095b40:	10800250 	cmplti	r2,r2,9
 9095b44:	1000031e 	bne	r2,zero,9095b54 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 9095b48:	00bffd04 	movi	r2,-12
 9095b4c:	e0bffc15 	stw	r2,-16(fp)
 9095b50:	00000406 	br	9095b64 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 9095b54:	e0bffb17 	ldw	r2,-20(fp)
 9095b58:	10c00d04 	addi	r3,r2,52
 9095b5c:	e0bffe17 	ldw	r2,-8(fp)
 9095b60:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 9095b64:	e0bffc17 	ldw	r2,-16(fp)
}
 9095b68:	e037883a 	mov	sp,fp
 9095b6c:	df000017 	ldw	fp,0(sp)
 9095b70:	dec00104 	addi	sp,sp,4
 9095b74:	f800283a 	ret

09095b78 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 9095b78:	defff904 	addi	sp,sp,-28
 9095b7c:	dfc00615 	stw	ra,24(sp)
 9095b80:	df000515 	stw	fp,20(sp)
 9095b84:	df000504 	addi	fp,sp,20
 9095b88:	e13ffc15 	stw	r4,-16(fp)
 9095b8c:	e17ffd15 	stw	r5,-12(fp)
 9095b90:	e1bffe15 	stw	r6,-8(fp)
 9095b94:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9095b98:	e0bffc17 	ldw	r2,-16(fp)
 9095b9c:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 9095ba0:	e0bffb17 	ldw	r2,-20(fp)
 9095ba4:	10800a17 	ldw	r2,40(r2)
 9095ba8:	1007883a 	mov	r3,r2
 9095bac:	e0bffd17 	ldw	r2,-12(fp)
 9095bb0:	1887883a 	add	r3,r3,r2
 9095bb4:	e1bfff17 	ldw	r6,-4(fp)
 9095bb8:	e0bffe17 	ldw	r2,-8(fp)
 9095bbc:	1009883a 	mov	r4,r2
 9095bc0:	180b883a 	mov	r5,r3
 9095bc4:	90822780 	call	9082278 <memcpy>
  return 0;
 9095bc8:	0005883a 	mov	r2,zero
}
 9095bcc:	e037883a 	mov	sp,fp
 9095bd0:	dfc00117 	ldw	ra,4(sp)
 9095bd4:	df000017 	ldw	fp,0(sp)
 9095bd8:	dec00204 	addi	sp,sp,8
 9095bdc:	f800283a 	ret

09095be0 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 9095be0:	defffa04 	addi	sp,sp,-24
 9095be4:	df000515 	stw	fp,20(sp)
 9095be8:	df000504 	addi	fp,sp,20
 9095bec:	e13ffd15 	stw	r4,-12(fp)
 9095bf0:	e17ffe15 	stw	r5,-8(fp)
 9095bf4:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 9095bf8:	e0bffd17 	ldw	r2,-12(fp)
 9095bfc:	10802e17 	ldw	r2,184(r2)
 9095c00:	10800058 	cmpnei	r2,r2,1
 9095c04:	10000b1e 	bne	r2,zero,9095c34 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 9095c08:	e0bffd17 	ldw	r2,-12(fp)
 9095c0c:	10800a17 	ldw	r2,40(r2)
 9095c10:	1007883a 	mov	r3,r2
 9095c14:	e0bffe17 	ldw	r2,-8(fp)
 9095c18:	1889883a 	add	r4,r3,r2
 9095c1c:	e0bfff17 	ldw	r2,-4(fp)
 9095c20:	10800003 	ldbu	r2,0(r2)
 9095c24:	10c03fcc 	andi	r3,r2,255
 9095c28:	2005883a 	mov	r2,r4
 9095c2c:	10c00025 	stbio	r3,0(r2)
 9095c30:	00004006 	br	9095d34 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 9095c34:	e0bffd17 	ldw	r2,-12(fp)
 9095c38:	10802e17 	ldw	r2,184(r2)
 9095c3c:	10800098 	cmpnei	r2,r2,2
 9095c40:	1000151e 	bne	r2,zero,9095c98 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 9095c44:	e0bfff17 	ldw	r2,-4(fp)
 9095c48:	10800003 	ldbu	r2,0(r2)
 9095c4c:	10803fcc 	andi	r2,r2,255
 9095c50:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 9095c54:	e0bfff17 	ldw	r2,-4(fp)
 9095c58:	10800044 	addi	r2,r2,1
 9095c5c:	10800003 	ldbu	r2,0(r2)
 9095c60:	10803fcc 	andi	r2,r2,255
 9095c64:	1004923a 	slli	r2,r2,8
 9095c68:	1007883a 	mov	r3,r2
 9095c6c:	e0bffc0b 	ldhu	r2,-16(fp)
 9095c70:	1884b03a 	or	r2,r3,r2
 9095c74:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 9095c78:	e0bffd17 	ldw	r2,-12(fp)
 9095c7c:	10800a17 	ldw	r2,40(r2)
 9095c80:	1007883a 	mov	r3,r2
 9095c84:	e0bffe17 	ldw	r2,-8(fp)
 9095c88:	1885883a 	add	r2,r3,r2
 9095c8c:	e0fffc0b 	ldhu	r3,-16(fp)
 9095c90:	10c0002d 	sthio	r3,0(r2)
 9095c94:	00002706 	br	9095d34 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 9095c98:	e0bffd17 	ldw	r2,-12(fp)
 9095c9c:	10802e17 	ldw	r2,184(r2)
 9095ca0:	10800118 	cmpnei	r2,r2,4
 9095ca4:	1000231e 	bne	r2,zero,9095d34 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 9095ca8:	e0bfff17 	ldw	r2,-4(fp)
 9095cac:	10800003 	ldbu	r2,0(r2)
 9095cb0:	10803fcc 	andi	r2,r2,255
 9095cb4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 9095cb8:	e0bfff17 	ldw	r2,-4(fp)
 9095cbc:	10800044 	addi	r2,r2,1
 9095cc0:	10800003 	ldbu	r2,0(r2)
 9095cc4:	10803fcc 	andi	r2,r2,255
 9095cc8:	1006923a 	slli	r3,r2,8
 9095ccc:	e0bffb17 	ldw	r2,-20(fp)
 9095cd0:	10c4b03a 	or	r2,r2,r3
 9095cd4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 9095cd8:	e0bfff17 	ldw	r2,-4(fp)
 9095cdc:	10800084 	addi	r2,r2,2
 9095ce0:	10800003 	ldbu	r2,0(r2)
 9095ce4:	10803fcc 	andi	r2,r2,255
 9095ce8:	1006943a 	slli	r3,r2,16
 9095cec:	e0bffb17 	ldw	r2,-20(fp)
 9095cf0:	10c4b03a 	or	r2,r2,r3
 9095cf4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 9095cf8:	e0bfff17 	ldw	r2,-4(fp)
 9095cfc:	108000c4 	addi	r2,r2,3
 9095d00:	10800003 	ldbu	r2,0(r2)
 9095d04:	10803fcc 	andi	r2,r2,255
 9095d08:	1006963a 	slli	r3,r2,24
 9095d0c:	e0bffb17 	ldw	r2,-20(fp)
 9095d10:	10c4b03a 	or	r2,r2,r3
 9095d14:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 9095d18:	e0bffd17 	ldw	r2,-12(fp)
 9095d1c:	10800a17 	ldw	r2,40(r2)
 9095d20:	1007883a 	mov	r3,r2
 9095d24:	e0bffe17 	ldw	r2,-8(fp)
 9095d28:	1885883a 	add	r2,r3,r2
 9095d2c:	e0fffb17 	ldw	r3,-20(fp)
 9095d30:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 9095d34:	e037883a 	mov	sp,fp
 9095d38:	df000017 	ldw	fp,0(sp)
 9095d3c:	dec00104 	addi	sp,sp,4
 9095d40:	f800283a 	ret

09095d44 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 9095d44:	defff304 	addi	sp,sp,-52
 9095d48:	dfc00c15 	stw	ra,48(sp)
 9095d4c:	df000b15 	stw	fp,44(sp)
 9095d50:	df000b04 	addi	fp,sp,44
 9095d54:	e13ffc15 	stw	r4,-16(fp)
 9095d58:	e17ffd15 	stw	r5,-12(fp)
 9095d5c:	e1bffe15 	stw	r6,-8(fp)
 9095d60:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 9095d64:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 9095d68:	e0bffc17 	ldw	r2,-16(fp)
 9095d6c:	10800a17 	ldw	r2,40(r2)
 9095d70:	1007883a 	mov	r3,r2
 9095d74:	e0bffd17 	ldw	r2,-12(fp)
 9095d78:	1885883a 	add	r2,r3,r2
 9095d7c:	1009883a 	mov	r4,r2
 9095d80:	e0bffc17 	ldw	r2,-16(fp)
 9095d84:	10c02e17 	ldw	r3,184(r2)
 9095d88:	20c5283a 	div	r2,r4,r3
 9095d8c:	10c5383a 	mul	r2,r2,r3
 9095d90:	2085c83a 	sub	r2,r4,r2
 9095d94:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 9095d98:	e0bff917 	ldw	r2,-28(fp)
 9095d9c:	1005003a 	cmpeq	r2,r2,zero
 9095da0:	10003a1e 	bne	r2,zero,9095e8c <alt_flash_program_block+0x148>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 9095da4:	e0bffc17 	ldw	r2,-16(fp)
 9095da8:	10c02e17 	ldw	r3,184(r2)
 9095dac:	e0bff917 	ldw	r2,-28(fp)
 9095db0:	1885c83a 	sub	r2,r3,r2
 9095db4:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9095db8:	e03ff615 	stw	zero,-40(fp)
 9095dbc:	00001206 	br	9095e08 <alt_flash_program_block+0xc4>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 9095dc0:	e17ff617 	ldw	r5,-40(fp)
 9095dc4:	e0bffc17 	ldw	r2,-16(fp)
 9095dc8:	10800a17 	ldw	r2,40(r2)
 9095dcc:	1009883a 	mov	r4,r2
 9095dd0:	e0fffd17 	ldw	r3,-12(fp)
 9095dd4:	e0bff917 	ldw	r2,-28(fp)
 9095dd8:	1887c83a 	sub	r3,r3,r2
 9095ddc:	e0bff617 	ldw	r2,-40(fp)
 9095de0:	1885883a 	add	r2,r3,r2
 9095de4:	2085883a 	add	r2,r4,r2
 9095de8:	10800023 	ldbuio	r2,0(r2)
 9095dec:	1007883a 	mov	r3,r2
 9095df0:	e0bffb04 	addi	r2,fp,-20
 9095df4:	1145883a 	add	r2,r2,r5
 9095df8:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9095dfc:	e0bff617 	ldw	r2,-40(fp)
 9095e00:	10800044 	addi	r2,r2,1
 9095e04:	e0bff615 	stw	r2,-40(fp)
 9095e08:	e0fff617 	ldw	r3,-40(fp)
 9095e0c:	e0bff917 	ldw	r2,-28(fp)
 9095e10:	18bfeb16 	blt	r3,r2,9095dc0 <alt_flash_program_block+0x7c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9095e14:	e03ff615 	stw	zero,-40(fp)
 9095e18:	00000e06 	br	9095e54 <alt_flash_program_block+0x110>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 9095e1c:	e0fff917 	ldw	r3,-28(fp)
 9095e20:	e0bff617 	ldw	r2,-40(fp)
 9095e24:	1889883a 	add	r4,r3,r2
 9095e28:	e0bff617 	ldw	r2,-40(fp)
 9095e2c:	1007883a 	mov	r3,r2
 9095e30:	e0bffe17 	ldw	r2,-8(fp)
 9095e34:	1885883a 	add	r2,r3,r2
 9095e38:	10c00003 	ldbu	r3,0(r2)
 9095e3c:	e0bffb04 	addi	r2,fp,-20
 9095e40:	1105883a 	add	r2,r2,r4
 9095e44:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9095e48:	e0bff617 	ldw	r2,-40(fp)
 9095e4c:	10800044 	addi	r2,r2,1
 9095e50:	e0bff615 	stw	r2,-40(fp)
 9095e54:	e0fff617 	ldw	r3,-40(fp)
 9095e58:	e0bff817 	ldw	r2,-32(fp)
 9095e5c:	18bfef16 	blt	r3,r2,9095e1c <alt_flash_program_block+0xd8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 9095e60:	e0fffd17 	ldw	r3,-12(fp)
 9095e64:	e0bff917 	ldw	r2,-28(fp)
 9095e68:	188bc83a 	sub	r5,r3,r2
 9095e6c:	e1bffb04 	addi	r6,fp,-20
 9095e70:	e0800217 	ldw	r2,8(fp)
 9095e74:	e13ffc17 	ldw	r4,-16(fp)
 9095e78:	103ee83a 	callr	r2
 9095e7c:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 9095e80:	e0bff817 	ldw	r2,-32(fp)
 9095e84:	e0bff615 	stw	r2,-40(fp)
 9095e88:	00000106 	br	9095e90 <alt_flash_program_block+0x14c>
  }
  else
  {
    i = 0;
 9095e8c:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 9095e90:	e0fffd17 	ldw	r3,-12(fp)
 9095e94:	e0bfff17 	ldw	r2,-4(fp)
 9095e98:	1889883a 	add	r4,r3,r2
 9095e9c:	e0bffc17 	ldw	r2,-16(fp)
 9095ea0:	10c02e17 	ldw	r3,184(r2)
 9095ea4:	20c5283a 	div	r2,r4,r3
 9095ea8:	10c5383a 	mul	r2,r2,r3
 9095eac:	2085c83a 	sub	r2,r4,r2
 9095eb0:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9095eb4:	00001006 	br	9095ef8 <alt_flash_program_block+0x1b4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 9095eb8:	e0fffd17 	ldw	r3,-12(fp)
 9095ebc:	e0bff617 	ldw	r2,-40(fp)
 9095ec0:	188b883a 	add	r5,r3,r2
 9095ec4:	e0bff617 	ldw	r2,-40(fp)
 9095ec8:	1007883a 	mov	r3,r2
 9095ecc:	e0bffe17 	ldw	r2,-8(fp)
 9095ed0:	188d883a 	add	r6,r3,r2
 9095ed4:	e0800217 	ldw	r2,8(fp)
 9095ed8:	e13ffc17 	ldw	r4,-16(fp)
 9095edc:	103ee83a 	callr	r2
 9095ee0:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 9095ee4:	e0bffc17 	ldw	r2,-16(fp)
 9095ee8:	10c02e17 	ldw	r3,184(r2)
 9095eec:	e0bff617 	ldw	r2,-40(fp)
 9095ef0:	10c5883a 	add	r2,r2,r3
 9095ef4:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9095ef8:	e0bffa17 	ldw	r2,-24(fp)
 9095efc:	1004c03a 	cmpne	r2,r2,zero
 9095f00:	1000051e 	bne	r2,zero,9095f18 <alt_flash_program_block+0x1d4>
 9095f04:	e0ffff17 	ldw	r3,-4(fp)
 9095f08:	e0bff717 	ldw	r2,-36(fp)
 9095f0c:	1887c83a 	sub	r3,r3,r2
 9095f10:	e0bff617 	ldw	r2,-40(fp)
 9095f14:	10ffe816 	blt	r2,r3,9095eb8 <alt_flash_program_block+0x174>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 9095f18:	e0bff717 	ldw	r2,-36(fp)
 9095f1c:	1005003a 	cmpeq	r2,r2,zero
 9095f20:	10003c1e 	bne	r2,zero,9096014 <alt_flash_program_block+0x2d0>
 9095f24:	e0bffa17 	ldw	r2,-24(fp)
 9095f28:	1004c03a 	cmpne	r2,r2,zero
 9095f2c:	1000391e 	bne	r2,zero,9096014 <alt_flash_program_block+0x2d0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 9095f30:	e0bffc17 	ldw	r2,-16(fp)
 9095f34:	10c02e17 	ldw	r3,184(r2)
 9095f38:	e0bff717 	ldw	r2,-36(fp)
 9095f3c:	1885c83a 	sub	r2,r3,r2
 9095f40:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 9095f44:	e03ff515 	stw	zero,-44(fp)
 9095f48:	00000e06 	br	9095f84 <alt_flash_program_block+0x240>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 9095f4c:	e13ff517 	ldw	r4,-44(fp)
 9095f50:	e0bff617 	ldw	r2,-40(fp)
 9095f54:	1007883a 	mov	r3,r2
 9095f58:	e0bffe17 	ldw	r2,-8(fp)
 9095f5c:	1887883a 	add	r3,r3,r2
 9095f60:	e0bff517 	ldw	r2,-44(fp)
 9095f64:	1885883a 	add	r2,r3,r2
 9095f68:	10c00003 	ldbu	r3,0(r2)
 9095f6c:	e0bffb04 	addi	r2,fp,-20
 9095f70:	1105883a 	add	r2,r2,r4
 9095f74:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 9095f78:	e0bff517 	ldw	r2,-44(fp)
 9095f7c:	10800044 	addi	r2,r2,1
 9095f80:	e0bff515 	stw	r2,-44(fp)
 9095f84:	e0fff517 	ldw	r3,-44(fp)
 9095f88:	e0bff717 	ldw	r2,-36(fp)
 9095f8c:	18bfef16 	blt	r3,r2,9095f4c <alt_flash_program_block+0x208>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9095f90:	e03ff515 	stw	zero,-44(fp)
 9095f94:	00001406 	br	9095fe8 <alt_flash_program_block+0x2a4>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 9095f98:	e0fff717 	ldw	r3,-36(fp)
 9095f9c:	e0bff517 	ldw	r2,-44(fp)
 9095fa0:	188b883a 	add	r5,r3,r2
 9095fa4:	e0bffc17 	ldw	r2,-16(fp)
 9095fa8:	10800a17 	ldw	r2,40(r2)
 9095fac:	1009883a 	mov	r4,r2
 9095fb0:	e0fffd17 	ldw	r3,-12(fp)
 9095fb4:	e0bfff17 	ldw	r2,-4(fp)
 9095fb8:	1887883a 	add	r3,r3,r2
 9095fbc:	e0bff517 	ldw	r2,-44(fp)
 9095fc0:	1885883a 	add	r2,r3,r2
 9095fc4:	2085883a 	add	r2,r4,r2
 9095fc8:	10800023 	ldbuio	r2,0(r2)
 9095fcc:	1007883a 	mov	r3,r2
 9095fd0:	e0bffb04 	addi	r2,fp,-20
 9095fd4:	1145883a 	add	r2,r2,r5
 9095fd8:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9095fdc:	e0bff517 	ldw	r2,-44(fp)
 9095fe0:	10800044 	addi	r2,r2,1
 9095fe4:	e0bff515 	stw	r2,-44(fp)
 9095fe8:	e0fff517 	ldw	r3,-44(fp)
 9095fec:	e0bff917 	ldw	r2,-28(fp)
 9095ff0:	18bfe916 	blt	r3,r2,9095f98 <alt_flash_program_block+0x254>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 9095ff4:	e0fffd17 	ldw	r3,-12(fp)
 9095ff8:	e0bff617 	ldw	r2,-40(fp)
 9095ffc:	188b883a 	add	r5,r3,r2
 9096000:	e1bffb04 	addi	r6,fp,-20
 9096004:	e0800217 	ldw	r2,8(fp)
 9096008:	e13ffc17 	ldw	r4,-16(fp)
 909600c:	103ee83a 	callr	r2
 9096010:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 9096014:	e0bffa17 	ldw	r2,-24(fp)
}
 9096018:	e037883a 	mov	sp,fp
 909601c:	dfc00117 	ldw	ra,4(sp)
 9096020:	df000017 	ldw	fp,0(sp)
 9096024:	dec00204 	addi	sp,sp,8
 9096028:	f800283a 	ret

0909602c <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 909602c:	defffd04 	addi	sp,sp,-12
 9096030:	df000215 	stw	fp,8(sp)
 9096034:	df000204 	addi	fp,sp,8
 9096038:	e13ffe15 	stw	r4,-8(fp)
 909603c:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 9096040:	e0bffe17 	ldw	r2,-8(fp)
 9096044:	10800a17 	ldw	r2,40(r2)
 9096048:	1007883a 	mov	r3,r2
 909604c:	e0bfff17 	ldw	r2,-4(fp)
 9096050:	1885883a 	add	r2,r3,r2
 9096054:	10800023 	ldbuio	r2,0(r2)
 9096058:	10803fcc 	andi	r2,r2,255
}
 909605c:	e037883a 	mov	sp,fp
 9096060:	df000017 	ldw	fp,0(sp)
 9096064:	dec00104 	addi	sp,sp,4
 9096068:	f800283a 	ret

0909606c <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 909606c:	defffd04 	addi	sp,sp,-12
 9096070:	df000215 	stw	fp,8(sp)
 9096074:	df000204 	addi	fp,sp,8
 9096078:	e13ffe15 	stw	r4,-8(fp)
 909607c:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 9096080:	e0bffe17 	ldw	r2,-8(fp)
 9096084:	10800a17 	ldw	r2,40(r2)
 9096088:	1007883a 	mov	r3,r2
 909608c:	e0bfff17 	ldw	r2,-4(fp)
 9096090:	1085883a 	add	r2,r2,r2
 9096094:	1885883a 	add	r2,r3,r2
 9096098:	1080002b 	ldhuio	r2,0(r2)
 909609c:	10803fcc 	andi	r2,r2,255
}
 90960a0:	e037883a 	mov	sp,fp
 90960a4:	df000017 	ldw	fp,0(sp)
 90960a8:	dec00104 	addi	sp,sp,4
 90960ac:	f800283a 	ret

090960b0 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 90960b0:	defffd04 	addi	sp,sp,-12
 90960b4:	df000215 	stw	fp,8(sp)
 90960b8:	df000204 	addi	fp,sp,8
 90960bc:	e13ffe15 	stw	r4,-8(fp)
 90960c0:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 90960c4:	e0bffe17 	ldw	r2,-8(fp)
 90960c8:	10800a17 	ldw	r2,40(r2)
 90960cc:	1007883a 	mov	r3,r2
 90960d0:	e0bfff17 	ldw	r2,-4(fp)
 90960d4:	1085883a 	add	r2,r2,r2
 90960d8:	1085883a 	add	r2,r2,r2
 90960dc:	1885883a 	add	r2,r3,r2
 90960e0:	10800037 	ldwio	r2,0(r2)
 90960e4:	10803fcc 	andi	r2,r2,255
}
 90960e8:	e037883a 	mov	sp,fp
 90960ec:	df000017 	ldw	fp,0(sp)
 90960f0:	dec00104 	addi	sp,sp,4
 90960f4:	f800283a 	ret

090960f8 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90960f8:	defffc04 	addi	sp,sp,-16
 90960fc:	df000315 	stw	fp,12(sp)
 9096100:	df000304 	addi	fp,sp,12
 9096104:	e13ffd15 	stw	r4,-12(fp)
 9096108:	e17ffe15 	stw	r5,-8(fp)
 909610c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 9096110:	e0fffd17 	ldw	r3,-12(fp)
 9096114:	e0bffe17 	ldw	r2,-8(fp)
 9096118:	1885883a 	add	r2,r3,r2
 909611c:	e0ffff03 	ldbu	r3,-4(fp)
 9096120:	10c00025 	stbio	r3,0(r2)
  return;
}
 9096124:	e037883a 	mov	sp,fp
 9096128:	df000017 	ldw	fp,0(sp)
 909612c:	dec00104 	addi	sp,sp,4
 9096130:	f800283a 	ret

09096134 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9096134:	defffc04 	addi	sp,sp,-16
 9096138:	df000315 	stw	fp,12(sp)
 909613c:	df000304 	addi	fp,sp,12
 9096140:	e13ffd15 	stw	r4,-12(fp)
 9096144:	e17ffe15 	stw	r5,-8(fp)
 9096148:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 909614c:	e0bffe17 	ldw	r2,-8(fp)
 9096150:	1080004c 	andi	r2,r2,1
 9096154:	10803fcc 	andi	r2,r2,255
 9096158:	1005003a 	cmpeq	r2,r2,zero
 909615c:	1000081e 	bne	r2,zero,9096180 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 9096160:	e0bffe17 	ldw	r2,-8(fp)
 9096164:	1085883a 	add	r2,r2,r2
 9096168:	1007883a 	mov	r3,r2
 909616c:	e0bffd17 	ldw	r2,-12(fp)
 9096170:	1885883a 	add	r2,r3,r2
 9096174:	e0ffff03 	ldbu	r3,-4(fp)
 9096178:	10c00025 	stbio	r3,0(r2)
 909617c:	00000806 	br	90961a0 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 9096180:	e0bffe17 	ldw	r2,-8(fp)
 9096184:	1085883a 	add	r2,r2,r2
 9096188:	1007883a 	mov	r3,r2
 909618c:	e0bffd17 	ldw	r2,-12(fp)
 9096190:	1885883a 	add	r2,r3,r2
 9096194:	10800044 	addi	r2,r2,1
 9096198:	e0ffff03 	ldbu	r3,-4(fp)
 909619c:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 90961a0:	e037883a 	mov	sp,fp
 90961a4:	df000017 	ldw	fp,0(sp)
 90961a8:	dec00104 	addi	sp,sp,4
 90961ac:	f800283a 	ret

090961b0 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90961b0:	defffc04 	addi	sp,sp,-16
 90961b4:	df000315 	stw	fp,12(sp)
 90961b8:	df000304 	addi	fp,sp,12
 90961bc:	e13ffd15 	stw	r4,-12(fp)
 90961c0:	e17ffe15 	stw	r5,-8(fp)
 90961c4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 90961c8:	e0bffe17 	ldw	r2,-8(fp)
 90961cc:	1085883a 	add	r2,r2,r2
 90961d0:	1085883a 	add	r2,r2,r2
 90961d4:	1007883a 	mov	r3,r2
 90961d8:	e0bffd17 	ldw	r2,-12(fp)
 90961dc:	1885883a 	add	r2,r3,r2
 90961e0:	e0ffff03 	ldbu	r3,-4(fp)
 90961e4:	10c00025 	stbio	r3,0(r2)
  return;
}
 90961e8:	e037883a 	mov	sp,fp
 90961ec:	df000017 	ldw	fp,0(sp)
 90961f0:	dec00104 	addi	sp,sp,4
 90961f4:	f800283a 	ret

090961f8 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90961f8:	defffc04 	addi	sp,sp,-16
 90961fc:	df000315 	stw	fp,12(sp)
 9096200:	df000304 	addi	fp,sp,12
 9096204:	e13ffd15 	stw	r4,-12(fp)
 9096208:	e17ffe15 	stw	r5,-8(fp)
 909620c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 9096210:	e0bffe17 	ldw	r2,-8(fp)
 9096214:	1085883a 	add	r2,r2,r2
 9096218:	1007883a 	mov	r3,r2
 909621c:	e0bffd17 	ldw	r2,-12(fp)
 9096220:	1885883a 	add	r2,r3,r2
 9096224:	e0ffff03 	ldbu	r3,-4(fp)
 9096228:	10c0002d 	sthio	r3,0(r2)
  return;
}
 909622c:	e037883a 	mov	sp,fp
 9096230:	df000017 	ldw	fp,0(sp)
 9096234:	dec00104 	addi	sp,sp,4
 9096238:	f800283a 	ret

0909623c <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 909623c:	defffc04 	addi	sp,sp,-16
 9096240:	df000315 	stw	fp,12(sp)
 9096244:	df000304 	addi	fp,sp,12
 9096248:	e13ffd15 	stw	r4,-12(fp)
 909624c:	e17ffe15 	stw	r5,-8(fp)
 9096250:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 9096254:	e0bffe17 	ldw	r2,-8(fp)
 9096258:	1085883a 	add	r2,r2,r2
 909625c:	1085883a 	add	r2,r2,r2
 9096260:	1007883a 	mov	r3,r2
 9096264:	e0bffd17 	ldw	r2,-12(fp)
 9096268:	1885883a 	add	r2,r3,r2
 909626c:	e0ffff03 	ldbu	r3,-4(fp)
 9096270:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9096274:	e037883a 	mov	sp,fp
 9096278:	df000017 	ldw	fp,0(sp)
 909627c:	dec00104 	addi	sp,sp,4
 9096280:	f800283a 	ret

09096284 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9096284:	defffc04 	addi	sp,sp,-16
 9096288:	df000315 	stw	fp,12(sp)
 909628c:	df000304 	addi	fp,sp,12
 9096290:	e13ffd15 	stw	r4,-12(fp)
 9096294:	e17ffe15 	stw	r5,-8(fp)
 9096298:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 909629c:	e0bffe17 	ldw	r2,-8(fp)
 90962a0:	1085883a 	add	r2,r2,r2
 90962a4:	1085883a 	add	r2,r2,r2
 90962a8:	1007883a 	mov	r3,r2
 90962ac:	e0bffd17 	ldw	r2,-12(fp)
 90962b0:	1885883a 	add	r2,r3,r2
 90962b4:	e0ffff03 	ldbu	r3,-4(fp)
 90962b8:	10c00035 	stwio	r3,0(r2)
  return;
}
 90962bc:	e037883a 	mov	sp,fp
 90962c0:	df000017 	ldw	fp,0(sp)
 90962c4:	dec00104 	addi	sp,sp,4
 90962c8:	f800283a 	ret

090962cc <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 90962cc:	defffd04 	addi	sp,sp,-12
 90962d0:	df000215 	stw	fp,8(sp)
 90962d4:	df000204 	addi	fp,sp,8
 90962d8:	e13ffe15 	stw	r4,-8(fp)
 90962dc:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 90962e0:	e0bfff17 	ldw	r2,-4(fp)
 90962e4:	10c03fcc 	andi	r3,r2,255
 90962e8:	e0bffe17 	ldw	r2,-8(fp)
 90962ec:	10c00025 	stbio	r3,0(r2)
  return;
}
 90962f0:	e037883a 	mov	sp,fp
 90962f4:	df000017 	ldw	fp,0(sp)
 90962f8:	dec00104 	addi	sp,sp,4
 90962fc:	f800283a 	ret

09096300 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 9096300:	defffd04 	addi	sp,sp,-12
 9096304:	df000215 	stw	fp,8(sp)
 9096308:	df000204 	addi	fp,sp,8
 909630c:	e13ffe15 	stw	r4,-8(fp)
 9096310:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 9096314:	e0bfff17 	ldw	r2,-4(fp)
 9096318:	10ffffcc 	andi	r3,r2,65535
 909631c:	e0bffe17 	ldw	r2,-8(fp)
 9096320:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9096324:	e037883a 	mov	sp,fp
 9096328:	df000017 	ldw	fp,0(sp)
 909632c:	dec00104 	addi	sp,sp,4
 9096330:	f800283a 	ret

09096334 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 9096334:	defffd04 	addi	sp,sp,-12
 9096338:	df000215 	stw	fp,8(sp)
 909633c:	df000204 	addi	fp,sp,8
 9096340:	e13ffe15 	stw	r4,-8(fp)
 9096344:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 9096348:	e0ffff17 	ldw	r3,-4(fp)
 909634c:	e0bffe17 	ldw	r2,-8(fp)
 9096350:	10c00035 	stwio	r3,0(r2)
  return;
}
 9096354:	e037883a 	mov	sp,fp
 9096358:	df000017 	ldw	fp,0(sp)
 909635c:	dec00104 	addi	sp,sp,4
 9096360:	f800283a 	ret

09096364 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 9096364:	defffb04 	addi	sp,sp,-20
 9096368:	df000415 	stw	fp,16(sp)
 909636c:	df000404 	addi	fp,sp,16
 9096370:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 9096374:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 9096378:	e0bffd17 	ldw	r2,-12(fp)
 909637c:	10802e17 	ldw	r2,184(r2)
 9096380:	e0bfff15 	stw	r2,-4(fp)
 9096384:	e0ffff17 	ldw	r3,-4(fp)
 9096388:	188000a0 	cmpeqi	r2,r3,2
 909638c:	1000261e 	bne	r2,zero,9096428 <alt_set_flash_width_func+0xc4>
 9096390:	e0ffff17 	ldw	r3,-4(fp)
 9096394:	18800120 	cmpeqi	r2,r3,4
 9096398:	1000391e 	bne	r2,zero,9096480 <alt_set_flash_width_func+0x11c>
 909639c:	e0ffff17 	ldw	r3,-4(fp)
 90963a0:	18800060 	cmpeqi	r2,r3,1
 90963a4:	1000011e 	bne	r2,zero,90963ac <alt_set_flash_width_func+0x48>
 90963a8:	00003e06 	br	90964a4 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 90963ac:	e0fffd17 	ldw	r3,-12(fp)
 90963b0:	00824274 	movhi	r2,2313
 90963b4:	1098b304 	addi	r2,r2,25292
 90963b8:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 90963bc:	e0bffd17 	ldw	r2,-12(fp)
 90963c0:	10802f17 	ldw	r2,188(r2)
 90963c4:	10800058 	cmpnei	r2,r2,1
 90963c8:	1000051e 	bne	r2,zero,90963e0 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 90963cc:	e0fffd17 	ldw	r3,-12(fp)
 90963d0:	00824274 	movhi	r2,2313
 90963d4:	10983e04 	addi	r2,r2,24824
 90963d8:	18803315 	stw	r2,204(r3)
 90963dc:	00003306 	br	90964ac <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 90963e0:	e0bffd17 	ldw	r2,-12(fp)
 90963e4:	10802f17 	ldw	r2,188(r2)
 90963e8:	10800098 	cmpnei	r2,r2,2
 90963ec:	1000051e 	bne	r2,zero,9096404 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 90963f0:	e0fffd17 	ldw	r3,-12(fp)
 90963f4:	00824274 	movhi	r2,2313
 90963f8:	10984d04 	addi	r2,r2,24884
 90963fc:	18803315 	stw	r2,204(r3)
 9096400:	00002a06 	br	90964ac <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 9096404:	e0bffd17 	ldw	r2,-12(fp)
 9096408:	10802f17 	ldw	r2,188(r2)
 909640c:	10800118 	cmpnei	r2,r2,4
 9096410:	1000261e 	bne	r2,zero,90964ac <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 9096414:	e0fffd17 	ldw	r3,-12(fp)
 9096418:	00824274 	movhi	r2,2313
 909641c:	10986c04 	addi	r2,r2,25008
 9096420:	18803315 	stw	r2,204(r3)
      }
      break;
 9096424:	00002106 	br	90964ac <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 9096428:	e0fffd17 	ldw	r3,-12(fp)
 909642c:	00824274 	movhi	r2,2313
 9096430:	1098c004 	addi	r2,r2,25344
 9096434:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 9096438:	e0bffd17 	ldw	r2,-12(fp)
 909643c:	10802f17 	ldw	r2,188(r2)
 9096440:	10800098 	cmpnei	r2,r2,2
 9096444:	1000051e 	bne	r2,zero,909645c <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 9096448:	e0fffd17 	ldw	r3,-12(fp)
 909644c:	00824274 	movhi	r2,2313
 9096450:	10987e04 	addi	r2,r2,25080
 9096454:	18803315 	stw	r2,204(r3)
 9096458:	00001406 	br	90964ac <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 909645c:	e0bffd17 	ldw	r2,-12(fp)
 9096460:	10802f17 	ldw	r2,188(r2)
 9096464:	10800118 	cmpnei	r2,r2,4
 9096468:	1000101e 	bne	r2,zero,90964ac <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 909646c:	e0fffd17 	ldw	r3,-12(fp)
 9096470:	00824274 	movhi	r2,2313
 9096474:	10988f04 	addi	r2,r2,25148
 9096478:	18803315 	stw	r2,204(r3)
      }

      break;
 909647c:	00000b06 	br	90964ac <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 9096480:	e0fffd17 	ldw	r3,-12(fp)
 9096484:	00824274 	movhi	r2,2313
 9096488:	1098cd04 	addi	r2,r2,25396
 909648c:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 9096490:	e0fffd17 	ldw	r3,-12(fp)
 9096494:	00824274 	movhi	r2,2313
 9096498:	1098a104 	addi	r2,r2,25220
 909649c:	18803315 	stw	r2,204(r3)
      break;
 90964a0:	00000206 	br	90964ac <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 90964a4:	00bffcc4 	movi	r2,-13
 90964a8:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 90964ac:	e0bffc17 	ldw	r2,-16(fp)
 90964b0:	1004c03a 	cmpne	r2,r2,zero
 90964b4:	10001e1e 	bne	r2,zero,9096530 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 90964b8:	e0bffd17 	ldw	r2,-12(fp)
 90964bc:	10802f17 	ldw	r2,188(r2)
 90964c0:	e0bffe15 	stw	r2,-8(fp)
 90964c4:	e0fffe17 	ldw	r3,-8(fp)
 90964c8:	188000a0 	cmpeqi	r2,r3,2
 90964cc:	10000c1e 	bne	r2,zero,9096500 <alt_set_flash_width_func+0x19c>
 90964d0:	e0fffe17 	ldw	r3,-8(fp)
 90964d4:	18800120 	cmpeqi	r2,r3,4
 90964d8:	10000e1e 	bne	r2,zero,9096514 <alt_set_flash_width_func+0x1b0>
 90964dc:	e0fffe17 	ldw	r3,-8(fp)
 90964e0:	18800060 	cmpeqi	r2,r3,1
 90964e4:	1000011e 	bne	r2,zero,90964ec <alt_set_flash_width_func+0x188>
 90964e8:	00000f06 	br	9096528 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 90964ec:	e0fffd17 	ldw	r3,-12(fp)
 90964f0:	00824274 	movhi	r2,2313
 90964f4:	10980b04 	addi	r2,r2,24620
 90964f8:	18803415 	stw	r2,208(r3)
        break;
 90964fc:	00000c06 	br	9096530 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 9096500:	e0fffd17 	ldw	r3,-12(fp)
 9096504:	00824274 	movhi	r2,2313
 9096508:	10981b04 	addi	r2,r2,24684
 909650c:	18803415 	stw	r2,208(r3)
        break;
 9096510:	00000706 	br	9096530 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 9096514:	e0fffd17 	ldw	r3,-12(fp)
 9096518:	00824274 	movhi	r2,2313
 909651c:	10982c04 	addi	r2,r2,24752
 9096520:	18803415 	stw	r2,208(r3)
        break;
 9096524:	00000206 	br	9096530 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 9096528:	00bffcc4 	movi	r2,-13
 909652c:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 9096530:	e0bffc17 	ldw	r2,-16(fp)
}
 9096534:	e037883a 	mov	sp,fp
 9096538:	df000017 	ldw	fp,0(sp)
 909653c:	dec00104 	addi	sp,sp,4
 9096540:	f800283a 	ret

09096544 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 9096544:	defffc04 	addi	sp,sp,-16
 9096548:	df000315 	stw	fp,12(sp)
 909654c:	df000304 	addi	fp,sp,12
 9096550:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 9096554:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 9096558:	e0bffe17 	ldw	r2,-8(fp)
 909655c:	10802d17 	ldw	r2,180(r2)
 9096560:	e0bfff15 	stw	r2,-4(fp)
 9096564:	e0ffff17 	ldw	r3,-4(fp)
 9096568:	188000a0 	cmpeqi	r2,r3,2
 909656c:	1000071e 	bne	r2,zero,909658c <alt_set_flash_algorithm_func+0x48>
 9096570:	e0ffff17 	ldw	r3,-4(fp)
 9096574:	188000e0 	cmpeqi	r2,r3,3
 9096578:	10000d1e 	bne	r2,zero,90965b0 <alt_set_flash_algorithm_func+0x6c>
 909657c:	e0ffff17 	ldw	r3,-4(fp)
 9096580:	18800060 	cmpeqi	r2,r3,1
 9096584:	10000a1e 	bne	r2,zero,90965b0 <alt_set_flash_algorithm_func+0x6c>
 9096588:	00001206 	br	90965d4 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 909658c:	e0fffe17 	ldw	r3,-8(fp)
 9096590:	00824334 	movhi	r2,2316
 9096594:	10a8f004 	addi	r2,r2,-23616
 9096598:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 909659c:	e0fffe17 	ldw	r3,-8(fp)
 90965a0:	00824334 	movhi	r2,2316
 90965a4:	10a8d604 	addi	r2,r2,-23720
 90965a8:	18800915 	stw	r2,36(r3)
      break;
 90965ac:	00000b06 	br	90965dc <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 90965b0:	e0fffe17 	ldw	r3,-8(fp)
 90965b4:	00824334 	movhi	r2,2316
 90965b8:	10aa0f04 	addi	r2,r2,-22468
 90965bc:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 90965c0:	e0fffe17 	ldw	r3,-8(fp)
 90965c4:	00824334 	movhi	r2,2316
 90965c8:	10a9ee04 	addi	r2,r2,-22600
 90965cc:	18800915 	stw	r2,36(r3)
      break;
 90965d0:	00000206 	br	90965dc <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 90965d4:	00bffec4 	movi	r2,-5
 90965d8:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 90965dc:	e0bffd17 	ldw	r2,-12(fp)
}
 90965e0:	e037883a 	mov	sp,fp
 90965e4:	df000017 	ldw	fp,0(sp)
 90965e8:	dec00104 	addi	sp,sp,4
 90965ec:	f800283a 	ret

090965f0 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 90965f0:	defffb04 	addi	sp,sp,-20
 90965f4:	dfc00415 	stw	ra,16(sp)
 90965f8:	df000315 	stw	fp,12(sp)
 90965fc:	df000304 	addi	fp,sp,12
 9096600:	e13ffe15 	stw	r4,-8(fp)
 9096604:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 9096608:	e0bffe17 	ldw	r2,-8(fp)
 909660c:	10803417 	ldw	r2,208(r2)
 9096610:	e13ffe17 	ldw	r4,-8(fp)
 9096614:	e17fff17 	ldw	r5,-4(fp)
 9096618:	103ee83a 	callr	r2
 909661c:	10803fcc 	andi	r2,r2,255
 9096620:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 9096624:	e0bffe17 	ldw	r2,-8(fp)
 9096628:	10c03417 	ldw	r3,208(r2)
 909662c:	e0bfff17 	ldw	r2,-4(fp)
 9096630:	11400044 	addi	r5,r2,1
 9096634:	e13ffe17 	ldw	r4,-8(fp)
 9096638:	183ee83a 	callr	r3
 909663c:	10803fcc 	andi	r2,r2,255
 9096640:	1004923a 	slli	r2,r2,8
 9096644:	1007883a 	mov	r3,r2
 9096648:	e0bffd0b 	ldhu	r2,-12(fp)
 909664c:	1884b03a 	or	r2,r3,r2
 9096650:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 9096654:	e0bffd0b 	ldhu	r2,-12(fp)
}
 9096658:	e037883a 	mov	sp,fp
 909665c:	dfc00117 	ldw	ra,4(sp)
 9096660:	df000017 	ldw	fp,0(sp)
 9096664:	dec00204 	addi	sp,sp,8
 9096668:	f800283a 	ret

0909666c <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 909666c:	defff104 	addi	sp,sp,-60
 9096670:	dfc00e15 	stw	ra,56(sp)
 9096674:	df000d15 	stw	fp,52(sp)
 9096678:	dc000c15 	stw	r16,48(sp)
 909667c:	df000c04 	addi	fp,sp,48
 9096680:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 9096684:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
 9096688:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 909668c:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 9096690:	e13ffe17 	ldw	r4,-8(fp)
 9096694:	90973f80 	call	90973f8 <alt_check_primary_table>
 9096698:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 909669c:	e0bffa17 	ldw	r2,-24(fp)
 90966a0:	1004c03a 	cmpne	r2,r2,zero
 90966a4:	1001621e 	bne	r2,zero,9096c30 <alt_read_cfi_table+0x5c4>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 90966a8:	e0bffe17 	ldw	r2,-8(fp)
 90966ac:	10803417 	ldw	r2,208(r2)
 90966b0:	e13ffe17 	ldw	r4,-8(fp)
 90966b4:	014004c4 	movi	r5,19
 90966b8:	103ee83a 	callr	r2
 90966bc:	10c03fcc 	andi	r3,r2,255
 90966c0:	e0bffe17 	ldw	r2,-8(fp)
 90966c4:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 90966c8:	e0bffe17 	ldw	r2,-8(fp)
 90966cc:	10803417 	ldw	r2,208(r2)
 90966d0:	e13ffe17 	ldw	r4,-8(fp)
 90966d4:	014007c4 	movi	r5,31
 90966d8:	103ee83a 	callr	r2
 90966dc:	10803fcc 	andi	r2,r2,255
 90966e0:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 90966e4:	e0bffe17 	ldw	r2,-8(fp)
 90966e8:	10803417 	ldw	r2,208(r2)
 90966ec:	e13ffe17 	ldw	r4,-8(fp)
 90966f0:	014008c4 	movi	r5,35
 90966f4:	103ee83a 	callr	r2
 90966f8:	10803fcc 	andi	r2,r2,255
 90966fc:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 9096700:	e0bff717 	ldw	r2,-36(fp)
 9096704:	1005003a 	cmpeq	r2,r2,zero
 9096708:	1000031e 	bne	r2,zero,9096718 <alt_read_cfi_table+0xac>
 909670c:	e0bff617 	ldw	r2,-40(fp)
 9096710:	1004c03a 	cmpne	r2,r2,zero
 9096714:	1000041e 	bne	r2,zero,9096728 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 9096718:	e0fffe17 	ldw	r3,-8(fp)
 909671c:	0080fa04 	movi	r2,1000
 9096720:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 9096724:	00000706 	br	9096744 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 9096728:	00c00044 	movi	r3,1
 909672c:	e0bff717 	ldw	r2,-36(fp)
 9096730:	1886983a 	sll	r3,r3,r2
 9096734:	e0bff617 	ldw	r2,-40(fp)
 9096738:	1886983a 	sll	r3,r3,r2
 909673c:	e0bffe17 	ldw	r2,-8(fp)
 9096740:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 9096744:	e0bffe17 	ldw	r2,-8(fp)
 9096748:	10803417 	ldw	r2,208(r2)
 909674c:	e13ffe17 	ldw	r4,-8(fp)
 9096750:	01400844 	movi	r5,33
 9096754:	103ee83a 	callr	r2
 9096758:	10803fcc 	andi	r2,r2,255
 909675c:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 9096760:	e0bffe17 	ldw	r2,-8(fp)
 9096764:	10803417 	ldw	r2,208(r2)
 9096768:	e13ffe17 	ldw	r4,-8(fp)
 909676c:	01400944 	movi	r5,37
 9096770:	103ee83a 	callr	r2
 9096774:	10803fcc 	andi	r2,r2,255
 9096778:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 909677c:	e0bff717 	ldw	r2,-36(fp)
 9096780:	1005003a 	cmpeq	r2,r2,zero
 9096784:	1000031e 	bne	r2,zero,9096794 <alt_read_cfi_table+0x128>
 9096788:	e0bff617 	ldw	r2,-40(fp)
 909678c:	1004c03a 	cmpne	r2,r2,zero
 9096790:	1000051e 	bne	r2,zero,90967a8 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 9096794:	e0fffe17 	ldw	r3,-8(fp)
 9096798:	00804c74 	movhi	r2,305
 909679c:	108b4004 	addi	r2,r2,11520
 90967a0:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 90967a4:	00000806 	br	90967c8 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 90967a8:	00c00044 	movi	r3,1
 90967ac:	e0bff717 	ldw	r2,-36(fp)
 90967b0:	1886983a 	sll	r3,r3,r2
 90967b4:	e0bff617 	ldw	r2,-40(fp)
 90967b8:	1884983a 	sll	r2,r3,r2
 90967bc:	10c0fa24 	muli	r3,r2,1000
 90967c0:	e0bffe17 	ldw	r2,-8(fp)
 90967c4:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 90967c8:	e0bffe17 	ldw	r2,-8(fp)
 90967cc:	10803417 	ldw	r2,208(r2)
 90967d0:	e13ffe17 	ldw	r4,-8(fp)
 90967d4:	014009c4 	movi	r5,39
 90967d8:	103ee83a 	callr	r2
 90967dc:	10c03fcc 	andi	r3,r2,255
 90967e0:	00800044 	movi	r2,1
 90967e4:	10c4983a 	sll	r2,r2,r3
 90967e8:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 90967ec:	e0bffe17 	ldw	r2,-8(fp)
 90967f0:	10803417 	ldw	r2,208(r2)
 90967f4:	e13ffe17 	ldw	r4,-8(fp)
 90967f8:	01400b04 	movi	r5,44
 90967fc:	103ee83a 	callr	r2
 9096800:	10c03fcc 	andi	r3,r2,255
 9096804:	e0bffe17 	ldw	r2,-8(fp)
 9096808:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 909680c:	e0bffe17 	ldw	r2,-8(fp)
 9096810:	10800c17 	ldw	r2,48(r2)
 9096814:	10800250 	cmplti	r2,r2,9
 9096818:	1000031e 	bne	r2,zero,9096828 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 909681c:	00bffd04 	movi	r2,-12
 9096820:	e0bffa15 	stw	r2,-24(fp)
 9096824:	00005e06 	br	90969a0 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 9096828:	e03ffd15 	stw	zero,-12(fp)
 909682c:	00005306 	br	909697c <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 9096830:	e43ffd17 	ldw	r16,-12(fp)
 9096834:	e0bffd17 	ldw	r2,-12(fp)
 9096838:	1085883a 	add	r2,r2,r2
 909683c:	1085883a 	add	r2,r2,r2
 9096840:	11400b44 	addi	r5,r2,45
 9096844:	e13ffe17 	ldw	r4,-8(fp)
 9096848:	90965f00 	call	90965f0 <alt_read_16bit_query_entry>
 909684c:	113fffcc 	andi	r4,r2,65535
 9096850:	e0fffe17 	ldw	r3,-8(fp)
 9096854:	8004913a 	slli	r2,r16,4
 9096858:	10c5883a 	add	r2,r2,r3
 909685c:	10800f04 	addi	r2,r2,60
 9096860:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 9096864:	e17ffd17 	ldw	r5,-12(fp)
 9096868:	e0bffd17 	ldw	r2,-12(fp)
 909686c:	e0fffe17 	ldw	r3,-8(fp)
 9096870:	1004913a 	slli	r2,r2,4
 9096874:	10c5883a 	add	r2,r2,r3
 9096878:	10800f04 	addi	r2,r2,60
 909687c:	10800017 	ldw	r2,0(r2)
 9096880:	11000044 	addi	r4,r2,1
 9096884:	e0fffe17 	ldw	r3,-8(fp)
 9096888:	2804913a 	slli	r2,r5,4
 909688c:	10c5883a 	add	r2,r2,r3
 9096890:	10800f04 	addi	r2,r2,60
 9096894:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 9096898:	e43ffd17 	ldw	r16,-12(fp)
 909689c:	e0bffd17 	ldw	r2,-12(fp)
 90968a0:	1085883a 	add	r2,r2,r2
 90968a4:	1085883a 	add	r2,r2,r2
 90968a8:	11400bc4 	addi	r5,r2,47
 90968ac:	e13ffe17 	ldw	r4,-8(fp)
 90968b0:	90965f00 	call	90965f0 <alt_read_16bit_query_entry>
 90968b4:	113fffcc 	andi	r4,r2,65535
 90968b8:	e0fffe17 	ldw	r3,-8(fp)
 90968bc:	8004913a 	slli	r2,r16,4
 90968c0:	10c5883a 	add	r2,r2,r3
 90968c4:	10801004 	addi	r2,r2,64
 90968c8:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 90968cc:	e17ffd17 	ldw	r5,-12(fp)
 90968d0:	e0bffd17 	ldw	r2,-12(fp)
 90968d4:	e0fffe17 	ldw	r3,-8(fp)
 90968d8:	1004913a 	slli	r2,r2,4
 90968dc:	10c5883a 	add	r2,r2,r3
 90968e0:	10801004 	addi	r2,r2,64
 90968e4:	10800017 	ldw	r2,0(r2)
 90968e8:	1008923a 	slli	r4,r2,8
 90968ec:	e0fffe17 	ldw	r3,-8(fp)
 90968f0:	2804913a 	slli	r2,r5,4
 90968f4:	10c5883a 	add	r2,r2,r3
 90968f8:	10801004 	addi	r2,r2,64
 90968fc:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 9096900:	e17ffd17 	ldw	r5,-12(fp)
 9096904:	e0bffd17 	ldw	r2,-12(fp)
 9096908:	e0fffe17 	ldw	r3,-8(fp)
 909690c:	1004913a 	slli	r2,r2,4
 9096910:	10c5883a 	add	r2,r2,r3
 9096914:	10800f04 	addi	r2,r2,60
 9096918:	11000017 	ldw	r4,0(r2)
 909691c:	e0bffd17 	ldw	r2,-12(fp)
 9096920:	e0fffe17 	ldw	r3,-8(fp)
 9096924:	1004913a 	slli	r2,r2,4
 9096928:	10c5883a 	add	r2,r2,r3
 909692c:	10801004 	addi	r2,r2,64
 9096930:	10800017 	ldw	r2,0(r2)
 9096934:	2089383a 	mul	r4,r4,r2
 9096938:	e0fffe17 	ldw	r3,-8(fp)
 909693c:	2804913a 	slli	r2,r5,4
 9096940:	10c5883a 	add	r2,r2,r3
 9096944:	10800e04 	addi	r2,r2,56
 9096948:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 909694c:	e0bffd17 	ldw	r2,-12(fp)
 9096950:	e0fffe17 	ldw	r3,-8(fp)
 9096954:	1004913a 	slli	r2,r2,4
 9096958:	10c5883a 	add	r2,r2,r3
 909695c:	10800e04 	addi	r2,r2,56
 9096960:	10c00017 	ldw	r3,0(r2)
 9096964:	e0bff917 	ldw	r2,-28(fp)
 9096968:	10c5883a 	add	r2,r2,r3
 909696c:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 9096970:	e0bffd17 	ldw	r2,-12(fp)
 9096974:	10800044 	addi	r2,r2,1
 9096978:	e0bffd15 	stw	r2,-12(fp)
 909697c:	e0bffe17 	ldw	r2,-8(fp)
 9096980:	10c00c17 	ldw	r3,48(r2)
 9096984:	e0bffd17 	ldw	r2,-12(fp)
 9096988:	10ffa916 	blt	r2,r3,9096830 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 909698c:	e0fff917 	ldw	r3,-28(fp)
 9096990:	e0bffb17 	ldw	r2,-20(fp)
 9096994:	18800226 	beq	r3,r2,90969a0 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 9096998:	00bffb44 	movi	r2,-19
 909699c:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 90969a0:	e0bffe17 	ldw	r2,-8(fp)
 90969a4:	10c03417 	ldw	r3,208(r2)
 90969a8:	e0bffe17 	ldw	r2,-8(fp)
 90969ac:	10803217 	ldw	r2,200(r2)
 90969b0:	114003c4 	addi	r5,r2,15
 90969b4:	e13ffe17 	ldw	r4,-8(fp)
 90969b8:	183ee83a 	callr	r3
 90969bc:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 90969c0:	e0bffe17 	ldw	r2,-8(fp)
 90969c4:	10802d17 	ldw	r2,180(r2)
 90969c8:	10800098 	cmpnei	r2,r2,2
 90969cc:	1000601e 	bne	r2,zero,9096b50 <alt_read_cfi_table+0x4e4>
 90969d0:	e0bff403 	ldbu	r2,-48(fp)
 90969d4:	108000d8 	cmpnei	r2,r2,3
 90969d8:	10005d1e 	bne	r2,zero,9096b50 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 90969dc:	e0bffe17 	ldw	r2,-8(fp)
 90969e0:	10800c17 	ldw	r2,48(r2)
 90969e4:	10bfffc4 	addi	r2,r2,-1
 90969e8:	e0bffd15 	stw	r2,-12(fp)
 90969ec:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
 90969f0:	00005406 	br	9096b44 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 90969f4:	e0bffd17 	ldw	r2,-12(fp)
 90969f8:	e0fffe17 	ldw	r3,-8(fp)
 90969fc:	1004913a 	slli	r2,r2,4
 9096a00:	10c5883a 	add	r2,r2,r3
 9096a04:	10800e04 	addi	r2,r2,56
 9096a08:	10800017 	ldw	r2,0(r2)
 9096a0c:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
 9096a10:	e17ffd17 	ldw	r5,-12(fp)
 9096a14:	e0bffc17 	ldw	r2,-16(fp)
 9096a18:	e0fffe17 	ldw	r3,-8(fp)
 9096a1c:	1004913a 	slli	r2,r2,4
 9096a20:	10c5883a 	add	r2,r2,r3
 9096a24:	10800e04 	addi	r2,r2,56
 9096a28:	11000017 	ldw	r4,0(r2)
 9096a2c:	e0fffe17 	ldw	r3,-8(fp)
 9096a30:	2804913a 	slli	r2,r5,4
 9096a34:	10c5883a 	add	r2,r2,r3
 9096a38:	10800e04 	addi	r2,r2,56
 9096a3c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 9096a40:	e0bffc17 	ldw	r2,-16(fp)
 9096a44:	e0fffe17 	ldw	r3,-8(fp)
 9096a48:	1004913a 	slli	r2,r2,4
 9096a4c:	10c5883a 	add	r2,r2,r3
 9096a50:	10c00e04 	addi	r3,r2,56
 9096a54:	e0bff817 	ldw	r2,-32(fp)
 9096a58:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 9096a5c:	e0bffd17 	ldw	r2,-12(fp)
 9096a60:	e0fffe17 	ldw	r3,-8(fp)
 9096a64:	1004913a 	slli	r2,r2,4
 9096a68:	10c5883a 	add	r2,r2,r3
 9096a6c:	10801004 	addi	r2,r2,64
 9096a70:	10800017 	ldw	r2,0(r2)
 9096a74:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
 9096a78:	e17ffd17 	ldw	r5,-12(fp)
 9096a7c:	e0bffc17 	ldw	r2,-16(fp)
 9096a80:	e0fffe17 	ldw	r3,-8(fp)
 9096a84:	1004913a 	slli	r2,r2,4
 9096a88:	10c5883a 	add	r2,r2,r3
 9096a8c:	10801004 	addi	r2,r2,64
 9096a90:	11000017 	ldw	r4,0(r2)
 9096a94:	e0fffe17 	ldw	r3,-8(fp)
 9096a98:	2804913a 	slli	r2,r5,4
 9096a9c:	10c5883a 	add	r2,r2,r3
 9096aa0:	10801004 	addi	r2,r2,64
 9096aa4:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 9096aa8:	e0bffc17 	ldw	r2,-16(fp)
 9096aac:	e0fffe17 	ldw	r3,-8(fp)
 9096ab0:	1004913a 	slli	r2,r2,4
 9096ab4:	10c5883a 	add	r2,r2,r3
 9096ab8:	10c01004 	addi	r3,r2,64
 9096abc:	e0bff817 	ldw	r2,-32(fp)
 9096ac0:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 9096ac4:	e0bffd17 	ldw	r2,-12(fp)
 9096ac8:	e0fffe17 	ldw	r3,-8(fp)
 9096acc:	1004913a 	slli	r2,r2,4
 9096ad0:	10c5883a 	add	r2,r2,r3
 9096ad4:	10800f04 	addi	r2,r2,60
 9096ad8:	10800017 	ldw	r2,0(r2)
 9096adc:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
 9096ae0:	e17ffd17 	ldw	r5,-12(fp)
 9096ae4:	e0bffc17 	ldw	r2,-16(fp)
 9096ae8:	e0fffe17 	ldw	r3,-8(fp)
 9096aec:	1004913a 	slli	r2,r2,4
 9096af0:	10c5883a 	add	r2,r2,r3
 9096af4:	10800f04 	addi	r2,r2,60
 9096af8:	11000017 	ldw	r4,0(r2)
 9096afc:	e0fffe17 	ldw	r3,-8(fp)
 9096b00:	2804913a 	slli	r2,r5,4
 9096b04:	10c5883a 	add	r2,r2,r3
 9096b08:	10800f04 	addi	r2,r2,60
 9096b0c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 9096b10:	e0bffc17 	ldw	r2,-16(fp)
 9096b14:	e0fffe17 	ldw	r3,-8(fp)
 9096b18:	1004913a 	slli	r2,r2,4
 9096b1c:	10c5883a 	add	r2,r2,r3
 9096b20:	10c00f04 	addi	r3,r2,60
 9096b24:	e0bff817 	ldw	r2,-32(fp)
 9096b28:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 9096b2c:	e0bffd17 	ldw	r2,-12(fp)
 9096b30:	10bfffc4 	addi	r2,r2,-1
 9096b34:	e0bffd15 	stw	r2,-12(fp)
 9096b38:	e0bffc17 	ldw	r2,-16(fp)
 9096b3c:	10800044 	addi	r2,r2,1
 9096b40:	e0bffc15 	stw	r2,-16(fp)
 9096b44:	e0fffc17 	ldw	r3,-16(fp)
 9096b48:	e0bffd17 	ldw	r2,-12(fp)
 9096b4c:	10ffa90e 	bge	r2,r3,90969f4 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 9096b50:	e03ffd15 	stw	zero,-12(fp)
 9096b54:	00001306 	br	9096ba4 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 9096b58:	e0bffd17 	ldw	r2,-12(fp)
 9096b5c:	e0fffe17 	ldw	r3,-8(fp)
 9096b60:	1004913a 	slli	r2,r2,4
 9096b64:	10c5883a 	add	r2,r2,r3
 9096b68:	10c00d04 	addi	r3,r2,52
 9096b6c:	e0bff517 	ldw	r2,-44(fp)
 9096b70:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 9096b74:	e0bffd17 	ldw	r2,-12(fp)
 9096b78:	e0fffe17 	ldw	r3,-8(fp)
 9096b7c:	1004913a 	slli	r2,r2,4
 9096b80:	10c5883a 	add	r2,r2,r3
 9096b84:	10800e04 	addi	r2,r2,56
 9096b88:	10c00017 	ldw	r3,0(r2)
 9096b8c:	e0bff517 	ldw	r2,-44(fp)
 9096b90:	10c5883a 	add	r2,r2,r3
 9096b94:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 9096b98:	e0bffd17 	ldw	r2,-12(fp)
 9096b9c:	10800044 	addi	r2,r2,1
 9096ba0:	e0bffd15 	stw	r2,-12(fp)
 9096ba4:	e0bffe17 	ldw	r2,-8(fp)
 9096ba8:	10c00c17 	ldw	r3,48(r2)
 9096bac:	e0bffd17 	ldw	r2,-12(fp)
 9096bb0:	10ffe916 	blt	r2,r3,9096b58 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 9096bb4:	e0bffe17 	ldw	r2,-8(fp)
 9096bb8:	10802d17 	ldw	r2,180(r2)
 9096bbc:	e0bfff15 	stw	r2,-4(fp)
 9096bc0:	e0ffff17 	ldw	r3,-4(fp)
 9096bc4:	188000a0 	cmpeqi	r2,r3,2
 9096bc8:	1000071e 	bne	r2,zero,9096be8 <alt_read_cfi_table+0x57c>
 9096bcc:	e0ffff17 	ldw	r3,-4(fp)
 9096bd0:	188000e0 	cmpeqi	r2,r3,3
 9096bd4:	10000c1e 	bne	r2,zero,9096c08 <alt_read_cfi_table+0x59c>
 9096bd8:	e0ffff17 	ldw	r3,-4(fp)
 9096bdc:	18800060 	cmpeqi	r2,r3,1
 9096be0:	1000091e 	bne	r2,zero,9096c08 <alt_read_cfi_table+0x59c>
 9096be4:	00001006 	br	9096c28 <alt_read_cfi_table+0x5bc>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 9096be8:	e0bffe17 	ldw	r2,-8(fp)
 9096bec:	10c03317 	ldw	r3,204(r2)
 9096bf0:	e0bffe17 	ldw	r2,-8(fp)
 9096bf4:	11000a17 	ldw	r4,40(r2)
 9096bf8:	01401544 	movi	r5,85
 9096bfc:	01803c04 	movi	r6,240
 9096c00:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 9096c04:	00000a06 	br	9096c30 <alt_read_cfi_table+0x5c4>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 9096c08:	e0bffe17 	ldw	r2,-8(fp)
 9096c0c:	10c03317 	ldw	r3,204(r2)
 9096c10:	e0bffe17 	ldw	r2,-8(fp)
 9096c14:	11000a17 	ldw	r4,40(r2)
 9096c18:	01401544 	movi	r5,85
 9096c1c:	01803fc4 	movi	r6,255
 9096c20:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 9096c24:	00000206 	br	9096c30 <alt_read_cfi_table+0x5c4>
      }
      default:
      {
        ret_code = -EIO;
 9096c28:	00bffec4 	movi	r2,-5
 9096c2c:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
 9096c30:	e0bffa17 	ldw	r2,-24(fp)
}
 9096c34:	e037883a 	mov	sp,fp
 9096c38:	dfc00217 	ldw	ra,8(sp)
 9096c3c:	df000117 	ldw	fp,4(sp)
 9096c40:	dc000017 	ldw	r16,0(sp)
 9096c44:	dec00304 	addi	sp,sp,12
 9096c48:	f800283a 	ret

09096c4c <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 9096c4c:	defff704 	addi	sp,sp,-36
 9096c50:	dfc00815 	stw	ra,32(sp)
 9096c54:	df000715 	stw	fp,28(sp)
 9096c58:	df000704 	addi	fp,sp,28
 9096c5c:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 9096c60:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9096c64:	e0bfff17 	ldw	r2,-4(fp)
 9096c68:	11000a17 	ldw	r4,40(r2)
 9096c6c:	01401544 	movi	r5,85
 9096c70:	01802604 	movi	r6,152
 9096c74:	90960f80 	call	90960f8 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 9096c78:	e03ffb15 	stw	zero,-20(fp)
 9096c7c:	00000f06 	br	9096cbc <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 9096c80:	e13ffb17 	ldw	r4,-20(fp)
 9096c84:	e0bfff17 	ldw	r2,-4(fp)
 9096c88:	10800a17 	ldw	r2,40(r2)
 9096c8c:	1007883a 	mov	r3,r2
 9096c90:	e0bffb17 	ldw	r2,-20(fp)
 9096c94:	1885883a 	add	r2,r3,r2
 9096c98:	10800404 	addi	r2,r2,16
 9096c9c:	10800023 	ldbuio	r2,0(r2)
 9096ca0:	1007883a 	mov	r3,r2
 9096ca4:	e0bffc04 	addi	r2,fp,-16
 9096ca8:	1105883a 	add	r2,r2,r4
 9096cac:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 9096cb0:	e0bffb17 	ldw	r2,-20(fp)
 9096cb4:	10800044 	addi	r2,r2,1
 9096cb8:	e0bffb15 	stw	r2,-20(fp)
 9096cbc:	e0bffb17 	ldw	r2,-20(fp)
 9096cc0:	108000d0 	cmplti	r2,r2,3
 9096cc4:	103fee1e 	bne	r2,zero,9096c80 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9096cc8:	e0bffc03 	ldbu	r2,-16(fp)
 9096ccc:	10803fcc 	andi	r2,r2,255
 9096cd0:	10801458 	cmpnei	r2,r2,81
 9096cd4:	10001d1e 	bne	r2,zero,9096d4c <alt_read_cfi_width+0x100>
 9096cd8:	e0bffc43 	ldbu	r2,-15(fp)
 9096cdc:	10803fcc 	andi	r2,r2,255
 9096ce0:	10801498 	cmpnei	r2,r2,82
 9096ce4:	1000191e 	bne	r2,zero,9096d4c <alt_read_cfi_width+0x100>
 9096ce8:	e0bffc83 	ldbu	r2,-14(fp)
 9096cec:	10803fcc 	andi	r2,r2,255
 9096cf0:	10801658 	cmpnei	r2,r2,89
 9096cf4:	1000151e 	bne	r2,zero,9096d4c <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 9096cf8:	e0ffff17 	ldw	r3,-4(fp)
 9096cfc:	00800044 	movi	r2,1
 9096d00:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 9096d04:	e0ffff17 	ldw	r3,-4(fp)
 9096d08:	00800044 	movi	r2,1
 9096d0c:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 9096d10:	e0bfff17 	ldw	r2,-4(fp)
 9096d14:	10800a17 	ldw	r2,40(r2)
 9096d18:	10800a04 	addi	r2,r2,40
 9096d1c:	1080002b 	ldhuio	r2,0(r2)
 9096d20:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 9096d24:	e0bffa0b 	ldhu	r2,-24(fp)
 9096d28:	10800044 	addi	r2,r2,1
 9096d2c:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 9096d30:	e0bffa0b 	ldhu	r2,-24(fp)
 9096d34:	1080004c 	andi	r2,r2,1
 9096d38:	1004c03a 	cmpne	r2,r2,zero
 9096d3c:	1001a81e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 9096d40:	00bffb44 	movi	r2,-19
 9096d44:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9096d48:	0001a506 	br	90973e0 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9096d4c:	e0bfff17 	ldw	r2,-4(fp)
 9096d50:	11000a17 	ldw	r4,40(r2)
 9096d54:	01401544 	movi	r5,85
 9096d58:	01802604 	movi	r6,152
 9096d5c:	90961340 	call	9096134 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 9096d60:	e03ffb15 	stw	zero,-20(fp)
 9096d64:	00000f06 	br	9096da4 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9096d68:	e13ffb17 	ldw	r4,-20(fp)
 9096d6c:	e0bfff17 	ldw	r2,-4(fp)
 9096d70:	10800a17 	ldw	r2,40(r2)
 9096d74:	1007883a 	mov	r3,r2
 9096d78:	e0bffb17 	ldw	r2,-20(fp)
 9096d7c:	1885883a 	add	r2,r3,r2
 9096d80:	10800804 	addi	r2,r2,32
 9096d84:	10800023 	ldbuio	r2,0(r2)
 9096d88:	1007883a 	mov	r3,r2
 9096d8c:	e0bffc04 	addi	r2,fp,-16
 9096d90:	1105883a 	add	r2,r2,r4
 9096d94:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 9096d98:	e0bffb17 	ldw	r2,-20(fp)
 9096d9c:	10800044 	addi	r2,r2,1
 9096da0:	e0bffb15 	stw	r2,-20(fp)
 9096da4:	e0bffb17 	ldw	r2,-20(fp)
 9096da8:	10800190 	cmplti	r2,r2,6
 9096dac:	103fee1e 	bne	r2,zero,9096d68 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9096db0:	e0bffc03 	ldbu	r2,-16(fp)
 9096db4:	10803fcc 	andi	r2,r2,255
 9096db8:	10801458 	cmpnei	r2,r2,81
 9096dbc:	1000291e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
 9096dc0:	e0bffc43 	ldbu	r2,-15(fp)
 9096dc4:	10803fcc 	andi	r2,r2,255
 9096dc8:	10801458 	cmpnei	r2,r2,81
 9096dcc:	1000251e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
 9096dd0:	e0bffc83 	ldbu	r2,-14(fp)
 9096dd4:	10803fcc 	andi	r2,r2,255
 9096dd8:	10801498 	cmpnei	r2,r2,82
 9096ddc:	1000211e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
 9096de0:	e0bffcc3 	ldbu	r2,-13(fp)
 9096de4:	10803fcc 	andi	r2,r2,255
 9096de8:	10801498 	cmpnei	r2,r2,82
 9096dec:	10001d1e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
 9096df0:	e0bffd03 	ldbu	r2,-12(fp)
 9096df4:	10803fcc 	andi	r2,r2,255
 9096df8:	10801658 	cmpnei	r2,r2,89
 9096dfc:	1000191e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
 9096e00:	e0bffd43 	ldbu	r2,-11(fp)
 9096e04:	10803fcc 	andi	r2,r2,255
 9096e08:	10801658 	cmpnei	r2,r2,89
 9096e0c:	1000151e 	bne	r2,zero,9096e64 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 9096e10:	e0ffff17 	ldw	r3,-4(fp)
 9096e14:	00800044 	movi	r2,1
 9096e18:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 9096e1c:	e0ffff17 	ldw	r3,-4(fp)
 9096e20:	00800084 	movi	r2,2
 9096e24:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9096e28:	e0bfff17 	ldw	r2,-4(fp)
 9096e2c:	10800a17 	ldw	r2,40(r2)
 9096e30:	10801404 	addi	r2,r2,80
 9096e34:	1080002b 	ldhuio	r2,0(r2)
 9096e38:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 9096e3c:	e0bffa0b 	ldhu	r2,-24(fp)
 9096e40:	10800044 	addi	r2,r2,1
 9096e44:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 9096e48:	e0bffa0b 	ldhu	r2,-24(fp)
 9096e4c:	1080004c 	andi	r2,r2,1
 9096e50:	1004c03a 	cmpne	r2,r2,zero
 9096e54:	1001621e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 9096e58:	00bffb44 	movi	r2,-19
 9096e5c:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9096e60:	00015f06 	br	90973e0 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9096e64:	e0bfff17 	ldw	r2,-4(fp)
 9096e68:	11000a17 	ldw	r4,40(r2)
 9096e6c:	01401544 	movi	r5,85
 9096e70:	01802604 	movi	r6,152
 9096e74:	90961f80 	call	90961f8 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 9096e78:	e03ffb15 	stw	zero,-20(fp)
 9096e7c:	00000f06 	br	9096ebc <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9096e80:	e13ffb17 	ldw	r4,-20(fp)
 9096e84:	e0bfff17 	ldw	r2,-4(fp)
 9096e88:	10800a17 	ldw	r2,40(r2)
 9096e8c:	1007883a 	mov	r3,r2
 9096e90:	e0bffb17 	ldw	r2,-20(fp)
 9096e94:	1885883a 	add	r2,r3,r2
 9096e98:	10800804 	addi	r2,r2,32
 9096e9c:	10800023 	ldbuio	r2,0(r2)
 9096ea0:	1007883a 	mov	r3,r2
 9096ea4:	e0bffc04 	addi	r2,fp,-16
 9096ea8:	1105883a 	add	r2,r2,r4
 9096eac:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 9096eb0:	e0bffb17 	ldw	r2,-20(fp)
 9096eb4:	10800044 	addi	r2,r2,1
 9096eb8:	e0bffb15 	stw	r2,-20(fp)
 9096ebc:	e0bffb17 	ldw	r2,-20(fp)
 9096ec0:	10800190 	cmplti	r2,r2,6
 9096ec4:	103fee1e 	bne	r2,zero,9096e80 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9096ec8:	e0bffc03 	ldbu	r2,-16(fp)
 9096ecc:	10803fcc 	andi	r2,r2,255
 9096ed0:	10801458 	cmpnei	r2,r2,81
 9096ed4:	1000291e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
 9096ed8:	e0bffc43 	ldbu	r2,-15(fp)
 9096edc:	10803fcc 	andi	r2,r2,255
 9096ee0:	1004c03a 	cmpne	r2,r2,zero
 9096ee4:	1000251e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
 9096ee8:	e0bffc83 	ldbu	r2,-14(fp)
 9096eec:	10803fcc 	andi	r2,r2,255
 9096ef0:	10801498 	cmpnei	r2,r2,82
 9096ef4:	1000211e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
 9096ef8:	e0bffcc3 	ldbu	r2,-13(fp)
 9096efc:	10803fcc 	andi	r2,r2,255
 9096f00:	1004c03a 	cmpne	r2,r2,zero
 9096f04:	10001d1e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
 9096f08:	e0bffd03 	ldbu	r2,-12(fp)
 9096f0c:	10803fcc 	andi	r2,r2,255
 9096f10:	10801658 	cmpnei	r2,r2,89
 9096f14:	1000191e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
 9096f18:	e0bffd43 	ldbu	r2,-11(fp)
 9096f1c:	10803fcc 	andi	r2,r2,255
 9096f20:	1004c03a 	cmpne	r2,r2,zero
 9096f24:	1000151e 	bne	r2,zero,9096f7c <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 9096f28:	e0ffff17 	ldw	r3,-4(fp)
 9096f2c:	00800084 	movi	r2,2
 9096f30:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 9096f34:	e0ffff17 	ldw	r3,-4(fp)
 9096f38:	00800084 	movi	r2,2
 9096f3c:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9096f40:	e0bfff17 	ldw	r2,-4(fp)
 9096f44:	10800a17 	ldw	r2,40(r2)
 9096f48:	10801404 	addi	r2,r2,80
 9096f4c:	1080002b 	ldhuio	r2,0(r2)
 9096f50:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 9096f54:	e0bffa0b 	ldhu	r2,-24(fp)
 9096f58:	10800044 	addi	r2,r2,1
 9096f5c:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 9096f60:	e0bffa0b 	ldhu	r2,-24(fp)
 9096f64:	1080008c 	andi	r2,r2,2
 9096f68:	1004c03a 	cmpne	r2,r2,zero
 9096f6c:	10011c1e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 9096f70:	00bffb44 	movi	r2,-19
 9096f74:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9096f78:	00011906 	br	90973e0 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9096f7c:	e0bfff17 	ldw	r2,-4(fp)
 9096f80:	11000a17 	ldw	r4,40(r2)
 9096f84:	01401544 	movi	r5,85
 9096f88:	01802604 	movi	r6,152
 9096f8c:	90962840 	call	9096284 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 9096f90:	e03ffb15 	stw	zero,-20(fp)
 9096f94:	00000f06 	br	9096fd4 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9096f98:	e13ffb17 	ldw	r4,-20(fp)
 9096f9c:	e0bfff17 	ldw	r2,-4(fp)
 9096fa0:	10800a17 	ldw	r2,40(r2)
 9096fa4:	1007883a 	mov	r3,r2
 9096fa8:	e0bffb17 	ldw	r2,-20(fp)
 9096fac:	1885883a 	add	r2,r3,r2
 9096fb0:	10801004 	addi	r2,r2,64
 9096fb4:	10800023 	ldbuio	r2,0(r2)
 9096fb8:	1007883a 	mov	r3,r2
 9096fbc:	e0bffc04 	addi	r2,fp,-16
 9096fc0:	1105883a 	add	r2,r2,r4
 9096fc4:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 9096fc8:	e0bffb17 	ldw	r2,-20(fp)
 9096fcc:	10800044 	addi	r2,r2,1
 9096fd0:	e0bffb15 	stw	r2,-20(fp)
 9096fd4:	e0bffb17 	ldw	r2,-20(fp)
 9096fd8:	10800310 	cmplti	r2,r2,12
 9096fdc:	103fee1e 	bne	r2,zero,9096f98 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 9096fe0:	e0bffc03 	ldbu	r2,-16(fp)
 9096fe4:	10803fcc 	andi	r2,r2,255
 9096fe8:	10801458 	cmpnei	r2,r2,81
 9096fec:	1000411e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9096ff0:	e0bffc43 	ldbu	r2,-15(fp)
 9096ff4:	10803fcc 	andi	r2,r2,255
 9096ff8:	1004c03a 	cmpne	r2,r2,zero
 9096ffc:	10003d1e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097000:	e0bffc83 	ldbu	r2,-14(fp)
 9097004:	10803fcc 	andi	r2,r2,255
 9097008:	1004c03a 	cmpne	r2,r2,zero
 909700c:	1000391e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097010:	e0bffcc3 	ldbu	r2,-13(fp)
 9097014:	10803fcc 	andi	r2,r2,255
 9097018:	1004c03a 	cmpne	r2,r2,zero
 909701c:	1000351e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097020:	e0bffd03 	ldbu	r2,-12(fp)
 9097024:	10803fcc 	andi	r2,r2,255
 9097028:	10801498 	cmpnei	r2,r2,82
 909702c:	1000311e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097030:	e0bffd43 	ldbu	r2,-11(fp)
 9097034:	10803fcc 	andi	r2,r2,255
 9097038:	1004c03a 	cmpne	r2,r2,zero
 909703c:	10002d1e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097040:	e0bffd83 	ldbu	r2,-10(fp)
 9097044:	10803fcc 	andi	r2,r2,255
 9097048:	1004c03a 	cmpne	r2,r2,zero
 909704c:	1000291e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097050:	e0bffdc3 	ldbu	r2,-9(fp)
 9097054:	10803fcc 	andi	r2,r2,255
 9097058:	1004c03a 	cmpne	r2,r2,zero
 909705c:	1000251e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097060:	e0bffe03 	ldbu	r2,-8(fp)
 9097064:	10803fcc 	andi	r2,r2,255
 9097068:	10801658 	cmpnei	r2,r2,89
 909706c:	1000211e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097070:	e0bffe43 	ldbu	r2,-7(fp)
 9097074:	10803fcc 	andi	r2,r2,255
 9097078:	1004c03a 	cmpne	r2,r2,zero
 909707c:	10001d1e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097080:	e0bffe83 	ldbu	r2,-6(fp)
 9097084:	10803fcc 	andi	r2,r2,255
 9097088:	1004c03a 	cmpne	r2,r2,zero
 909708c:	1000191e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
 9097090:	e0bffec3 	ldbu	r2,-5(fp)
 9097094:	10803fcc 	andi	r2,r2,255
 9097098:	1004c03a 	cmpne	r2,r2,zero
 909709c:	1000151e 	bne	r2,zero,90970f4 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 90970a0:	e0ffff17 	ldw	r3,-4(fp)
 90970a4:	00800104 	movi	r2,4
 90970a8:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 90970ac:	e0ffff17 	ldw	r3,-4(fp)
 90970b0:	00800104 	movi	r2,4
 90970b4:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 90970b8:	e0bfff17 	ldw	r2,-4(fp)
 90970bc:	10800a17 	ldw	r2,40(r2)
 90970c0:	10802804 	addi	r2,r2,160
 90970c4:	10800037 	ldwio	r2,0(r2)
 90970c8:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 90970cc:	e0bffa0b 	ldhu	r2,-24(fp)
 90970d0:	10800044 	addi	r2,r2,1
 90970d4:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 90970d8:	e0bffa0b 	ldhu	r2,-24(fp)
 90970dc:	1080010c 	andi	r2,r2,4
 90970e0:	1004c03a 	cmpne	r2,r2,zero
 90970e4:	1000be1e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 90970e8:	00bffb44 	movi	r2,-19
 90970ec:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 90970f0:	0000bb06 	br	90973e0 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 90970f4:	e0bfff17 	ldw	r2,-4(fp)
 90970f8:	11000a17 	ldw	r4,40(r2)
 90970fc:	01401544 	movi	r5,85
 9097100:	01802604 	movi	r6,152
 9097104:	909623c0 	call	909623c <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 9097108:	e03ffb15 	stw	zero,-20(fp)
 909710c:	00000f06 	br	909714c <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9097110:	e13ffb17 	ldw	r4,-20(fp)
 9097114:	e0bfff17 	ldw	r2,-4(fp)
 9097118:	10800a17 	ldw	r2,40(r2)
 909711c:	1007883a 	mov	r3,r2
 9097120:	e0bffb17 	ldw	r2,-20(fp)
 9097124:	1885883a 	add	r2,r3,r2
 9097128:	10801004 	addi	r2,r2,64
 909712c:	10800023 	ldbuio	r2,0(r2)
 9097130:	1007883a 	mov	r3,r2
 9097134:	e0bffc04 	addi	r2,fp,-16
 9097138:	1105883a 	add	r2,r2,r4
 909713c:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 9097140:	e0bffb17 	ldw	r2,-20(fp)
 9097144:	10800044 	addi	r2,r2,1
 9097148:	e0bffb15 	stw	r2,-20(fp)
 909714c:	e0bffb17 	ldw	r2,-20(fp)
 9097150:	10800310 	cmplti	r2,r2,12
 9097154:	103fee1e 	bne	r2,zero,9097110 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9097158:	e0bffc03 	ldbu	r2,-16(fp)
 909715c:	10803fcc 	andi	r2,r2,255
 9097160:	10801458 	cmpnei	r2,r2,81
 9097164:	1000411e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 9097168:	e0bffc43 	ldbu	r2,-15(fp)
 909716c:	10803fcc 	andi	r2,r2,255
 9097170:	1004c03a 	cmpne	r2,r2,zero
 9097174:	10003d1e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 9097178:	e0bffc83 	ldbu	r2,-14(fp)
 909717c:	10803fcc 	andi	r2,r2,255
 9097180:	10801458 	cmpnei	r2,r2,81
 9097184:	1000391e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 9097188:	e0bffcc3 	ldbu	r2,-13(fp)
 909718c:	10803fcc 	andi	r2,r2,255
 9097190:	1004c03a 	cmpne	r2,r2,zero
 9097194:	1000351e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 9097198:	e0bffd03 	ldbu	r2,-12(fp)
 909719c:	10803fcc 	andi	r2,r2,255
 90971a0:	10801498 	cmpnei	r2,r2,82
 90971a4:	1000311e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971a8:	e0bffd43 	ldbu	r2,-11(fp)
 90971ac:	10803fcc 	andi	r2,r2,255
 90971b0:	1004c03a 	cmpne	r2,r2,zero
 90971b4:	10002d1e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971b8:	e0bffd83 	ldbu	r2,-10(fp)
 90971bc:	10803fcc 	andi	r2,r2,255
 90971c0:	10801498 	cmpnei	r2,r2,82
 90971c4:	1000291e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971c8:	e0bffdc3 	ldbu	r2,-9(fp)
 90971cc:	10803fcc 	andi	r2,r2,255
 90971d0:	1004c03a 	cmpne	r2,r2,zero
 90971d4:	1000251e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971d8:	e0bffe03 	ldbu	r2,-8(fp)
 90971dc:	10803fcc 	andi	r2,r2,255
 90971e0:	10801658 	cmpnei	r2,r2,89
 90971e4:	1000211e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971e8:	e0bffe43 	ldbu	r2,-7(fp)
 90971ec:	10803fcc 	andi	r2,r2,255
 90971f0:	1004c03a 	cmpne	r2,r2,zero
 90971f4:	10001d1e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 90971f8:	e0bffe83 	ldbu	r2,-6(fp)
 90971fc:	10803fcc 	andi	r2,r2,255
 9097200:	10801658 	cmpnei	r2,r2,89
 9097204:	1000191e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
 9097208:	e0bffec3 	ldbu	r2,-5(fp)
 909720c:	10803fcc 	andi	r2,r2,255
 9097210:	1004c03a 	cmpne	r2,r2,zero
 9097214:	1000151e 	bne	r2,zero,909726c <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 9097218:	e0ffff17 	ldw	r3,-4(fp)
 909721c:	00800084 	movi	r2,2
 9097220:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 9097224:	e0ffff17 	ldw	r3,-4(fp)
 9097228:	00800104 	movi	r2,4
 909722c:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9097230:	e0bfff17 	ldw	r2,-4(fp)
 9097234:	10800a17 	ldw	r2,40(r2)
 9097238:	10802804 	addi	r2,r2,160
 909723c:	10800037 	ldwio	r2,0(r2)
 9097240:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 9097244:	e0bffa0b 	ldhu	r2,-24(fp)
 9097248:	10800044 	addi	r2,r2,1
 909724c:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 9097250:	e0bffa0b 	ldhu	r2,-24(fp)
 9097254:	1080010c 	andi	r2,r2,4
 9097258:	1004c03a 	cmpne	r2,r2,zero
 909725c:	1000601e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 9097260:	00bffb44 	movi	r2,-19
 9097264:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9097268:	00005d06 	br	90973e0 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 909726c:	e0bfff17 	ldw	r2,-4(fp)
 9097270:	11000a17 	ldw	r4,40(r2)
 9097274:	01401544 	movi	r5,85
 9097278:	01802604 	movi	r6,152
 909727c:	90961b00 	call	90961b0 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 9097280:	e03ffb15 	stw	zero,-20(fp)
 9097284:	00000f06 	br	90972c4 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9097288:	e13ffb17 	ldw	r4,-20(fp)
 909728c:	e0bfff17 	ldw	r2,-4(fp)
 9097290:	10800a17 	ldw	r2,40(r2)
 9097294:	1007883a 	mov	r3,r2
 9097298:	e0bffb17 	ldw	r2,-20(fp)
 909729c:	1885883a 	add	r2,r3,r2
 90972a0:	10801004 	addi	r2,r2,64
 90972a4:	10800023 	ldbuio	r2,0(r2)
 90972a8:	1007883a 	mov	r3,r2
 90972ac:	e0bffc04 	addi	r2,fp,-16
 90972b0:	1105883a 	add	r2,r2,r4
 90972b4:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 90972b8:	e0bffb17 	ldw	r2,-20(fp)
 90972bc:	10800044 	addi	r2,r2,1
 90972c0:	e0bffb15 	stw	r2,-20(fp)
 90972c4:	e0bffb17 	ldw	r2,-20(fp)
 90972c8:	10800310 	cmplti	r2,r2,12
 90972cc:	103fee1e 	bne	r2,zero,9097288 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 90972d0:	e0bffc03 	ldbu	r2,-16(fp)
 90972d4:	10803fcc 	andi	r2,r2,255
 90972d8:	10801458 	cmpnei	r2,r2,81
 90972dc:	1000401e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 90972e0:	e0bffc43 	ldbu	r2,-15(fp)
 90972e4:	10803fcc 	andi	r2,r2,255
 90972e8:	10801458 	cmpnei	r2,r2,81
 90972ec:	10003c1e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 90972f0:	e0bffc83 	ldbu	r2,-14(fp)
 90972f4:	10803fcc 	andi	r2,r2,255
 90972f8:	10801458 	cmpnei	r2,r2,81
 90972fc:	1000381e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097300:	e0bffcc3 	ldbu	r2,-13(fp)
 9097304:	10803fcc 	andi	r2,r2,255
 9097308:	10801458 	cmpnei	r2,r2,81
 909730c:	1000341e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097310:	e0bffd03 	ldbu	r2,-12(fp)
 9097314:	10803fcc 	andi	r2,r2,255
 9097318:	10801498 	cmpnei	r2,r2,82
 909731c:	1000301e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097320:	e0bffd43 	ldbu	r2,-11(fp)
 9097324:	10803fcc 	andi	r2,r2,255
 9097328:	10801498 	cmpnei	r2,r2,82
 909732c:	10002c1e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097330:	e0bffd83 	ldbu	r2,-10(fp)
 9097334:	10803fcc 	andi	r2,r2,255
 9097338:	10801498 	cmpnei	r2,r2,82
 909733c:	1000281e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097340:	e0bffdc3 	ldbu	r2,-9(fp)
 9097344:	10803fcc 	andi	r2,r2,255
 9097348:	10801498 	cmpnei	r2,r2,82
 909734c:	1000241e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097350:	e0bffe03 	ldbu	r2,-8(fp)
 9097354:	10803fcc 	andi	r2,r2,255
 9097358:	10801658 	cmpnei	r2,r2,89
 909735c:	1000201e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097360:	e0bffe43 	ldbu	r2,-7(fp)
 9097364:	10803fcc 	andi	r2,r2,255
 9097368:	10801658 	cmpnei	r2,r2,89
 909736c:	10001c1e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097370:	e0bffe83 	ldbu	r2,-6(fp)
 9097374:	10803fcc 	andi	r2,r2,255
 9097378:	10801658 	cmpnei	r2,r2,89
 909737c:	1000181e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
 9097380:	e0bffec3 	ldbu	r2,-5(fp)
 9097384:	10803fcc 	andi	r2,r2,255
 9097388:	10801658 	cmpnei	r2,r2,89
 909738c:	1000141e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 9097390:	e0ffff17 	ldw	r3,-4(fp)
 9097394:	00800044 	movi	r2,1
 9097398:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 909739c:	e0ffff17 	ldw	r3,-4(fp)
 90973a0:	00800104 	movi	r2,4
 90973a4:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 90973a8:	e0bfff17 	ldw	r2,-4(fp)
 90973ac:	10800a17 	ldw	r2,40(r2)
 90973b0:	10802804 	addi	r2,r2,160
 90973b4:	10800037 	ldwio	r2,0(r2)
 90973b8:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 90973bc:	e0bffa0b 	ldhu	r2,-24(fp)
 90973c0:	10800044 	addi	r2,r2,1
 90973c4:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 90973c8:	e0bffa0b 	ldhu	r2,-24(fp)
 90973cc:	1080010c 	andi	r2,r2,4
 90973d0:	1004c03a 	cmpne	r2,r2,zero
 90973d4:	1000021e 	bne	r2,zero,90973e0 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 90973d8:	00bffb44 	movi	r2,-19
 90973dc:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 90973e0:	e0bff917 	ldw	r2,-28(fp)
}
 90973e4:	e037883a 	mov	sp,fp
 90973e8:	dfc00117 	ldw	ra,4(sp)
 90973ec:	df000017 	ldw	fp,0(sp)
 90973f0:	dec00204 	addi	sp,sp,8
 90973f4:	f800283a 	ret

090973f8 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 90973f8:	defff904 	addi	sp,sp,-28
 90973fc:	dfc00615 	stw	ra,24(sp)
 9097400:	df000515 	stw	fp,20(sp)
 9097404:	dc000415 	stw	r16,16(sp)
 9097408:	df000404 	addi	fp,sp,16
 909740c:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 9097410:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 9097414:	e13fff17 	ldw	r4,-4(fp)
 9097418:	01400544 	movi	r5,21
 909741c:	90965f00 	call	90965f0 <alt_read_16bit_query_entry>
 9097420:	10ffffcc 	andi	r3,r2,65535
 9097424:	e0bfff17 	ldw	r2,-4(fp)
 9097428:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 909742c:	e03ffd15 	stw	zero,-12(fp)
 9097430:	00001006 	br	9097474 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 9097434:	e43ffd17 	ldw	r16,-12(fp)
 9097438:	e0bfff17 	ldw	r2,-4(fp)
 909743c:	11803417 	ldw	r6,208(r2)
 9097440:	e0bfff17 	ldw	r2,-4(fp)
 9097444:	10c03217 	ldw	r3,200(r2)
 9097448:	e0bffd17 	ldw	r2,-12(fp)
 909744c:	188b883a 	add	r5,r3,r2
 9097450:	e13fff17 	ldw	r4,-4(fp)
 9097454:	303ee83a 	callr	r6
 9097458:	1007883a 	mov	r3,r2
 909745c:	e0bffe04 	addi	r2,fp,-8
 9097460:	1405883a 	add	r2,r2,r16
 9097464:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 9097468:	e0bffd17 	ldw	r2,-12(fp)
 909746c:	10800044 	addi	r2,r2,1
 9097470:	e0bffd15 	stw	r2,-12(fp)
 9097474:	e0bffd17 	ldw	r2,-12(fp)
 9097478:	108000d0 	cmplti	r2,r2,3
 909747c:	103fed1e 	bne	r2,zero,9097434 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 9097480:	e0bffe03 	ldbu	r2,-8(fp)
 9097484:	10803fcc 	andi	r2,r2,255
 9097488:	10801418 	cmpnei	r2,r2,80
 909748c:	1000081e 	bne	r2,zero,90974b0 <alt_check_primary_table+0xb8>
 9097490:	e0bffe43 	ldbu	r2,-7(fp)
 9097494:	10803fcc 	andi	r2,r2,255
 9097498:	10801498 	cmpnei	r2,r2,82
 909749c:	1000041e 	bne	r2,zero,90974b0 <alt_check_primary_table+0xb8>
 90974a0:	e0bffe83 	ldbu	r2,-6(fp)
 90974a4:	10803fcc 	andi	r2,r2,255
 90974a8:	10801260 	cmpeqi	r2,r2,73
 90974ac:	1000021e 	bne	r2,zero,90974b8 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 90974b0:	00bffb44 	movi	r2,-19
 90974b4:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 90974b8:	e0bffc17 	ldw	r2,-16(fp)
}
 90974bc:	e037883a 	mov	sp,fp
 90974c0:	dfc00217 	ldw	ra,8(sp)
 90974c4:	df000117 	ldw	fp,4(sp)
 90974c8:	dc000017 	ldw	r16,0(sp)
 90974cc:	dec00304 	addi	sp,sp,12
 90974d0:	f800283a 	ret

090974d4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 90974d4:	defffa04 	addi	sp,sp,-24
 90974d8:	dfc00515 	stw	ra,20(sp)
 90974dc:	df000415 	stw	fp,16(sp)
 90974e0:	df000404 	addi	fp,sp,16
 90974e4:	e13ffd15 	stw	r4,-12(fp)
 90974e8:	e17ffe15 	stw	r5,-8(fp)
 90974ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 90974f0:	e0bffd17 	ldw	r2,-12(fp)
 90974f4:	10800017 	ldw	r2,0(r2)
 90974f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 90974fc:	e0bffc17 	ldw	r2,-16(fp)
 9097500:	11000a04 	addi	r4,r2,40
 9097504:	e0bffd17 	ldw	r2,-12(fp)
 9097508:	11c00217 	ldw	r7,8(r2)
 909750c:	e17ffe17 	ldw	r5,-8(fp)
 9097510:	e1bfff17 	ldw	r6,-4(fp)
 9097514:	9097c940 	call	9097c94 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 9097518:	e037883a 	mov	sp,fp
 909751c:	dfc00117 	ldw	ra,4(sp)
 9097520:	df000017 	ldw	fp,0(sp)
 9097524:	dec00204 	addi	sp,sp,8
 9097528:	f800283a 	ret

0909752c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 909752c:	defffa04 	addi	sp,sp,-24
 9097530:	dfc00515 	stw	ra,20(sp)
 9097534:	df000415 	stw	fp,16(sp)
 9097538:	df000404 	addi	fp,sp,16
 909753c:	e13ffd15 	stw	r4,-12(fp)
 9097540:	e17ffe15 	stw	r5,-8(fp)
 9097544:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9097548:	e0bffd17 	ldw	r2,-12(fp)
 909754c:	10800017 	ldw	r2,0(r2)
 9097550:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 9097554:	e0bffc17 	ldw	r2,-16(fp)
 9097558:	11000a04 	addi	r4,r2,40
 909755c:	e0bffd17 	ldw	r2,-12(fp)
 9097560:	11c00217 	ldw	r7,8(r2)
 9097564:	e17ffe17 	ldw	r5,-8(fp)
 9097568:	e1bfff17 	ldw	r6,-4(fp)
 909756c:	9097f540 	call	9097f54 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 9097570:	e037883a 	mov	sp,fp
 9097574:	dfc00117 	ldw	ra,4(sp)
 9097578:	df000017 	ldw	fp,0(sp)
 909757c:	dec00204 	addi	sp,sp,8
 9097580:	f800283a 	ret

09097584 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 9097584:	defffc04 	addi	sp,sp,-16
 9097588:	dfc00315 	stw	ra,12(sp)
 909758c:	df000215 	stw	fp,8(sp)
 9097590:	df000204 	addi	fp,sp,8
 9097594:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9097598:	e0bfff17 	ldw	r2,-4(fp)
 909759c:	10800017 	ldw	r2,0(r2)
 90975a0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 90975a4:	e0bffe17 	ldw	r2,-8(fp)
 90975a8:	11000a04 	addi	r4,r2,40
 90975ac:	e0bfff17 	ldw	r2,-4(fp)
 90975b0:	11400217 	ldw	r5,8(r2)
 90975b4:	9097b2c0 	call	9097b2c <altera_avalon_jtag_uart_close>
}
 90975b8:	e037883a 	mov	sp,fp
 90975bc:	dfc00117 	ldw	ra,4(sp)
 90975c0:	df000017 	ldw	fp,0(sp)
 90975c4:	dec00204 	addi	sp,sp,8
 90975c8:	f800283a 	ret

090975cc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 90975cc:	defffa04 	addi	sp,sp,-24
 90975d0:	dfc00515 	stw	ra,20(sp)
 90975d4:	df000415 	stw	fp,16(sp)
 90975d8:	df000404 	addi	fp,sp,16
 90975dc:	e13ffd15 	stw	r4,-12(fp)
 90975e0:	e17ffe15 	stw	r5,-8(fp)
 90975e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 90975e8:	e0bffd17 	ldw	r2,-12(fp)
 90975ec:	10800017 	ldw	r2,0(r2)
 90975f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 90975f4:	e0bffc17 	ldw	r2,-16(fp)
 90975f8:	11000a04 	addi	r4,r2,40
 90975fc:	e17ffe17 	ldw	r5,-8(fp)
 9097600:	e1bfff17 	ldw	r6,-4(fp)
 9097604:	9097ba00 	call	9097ba0 <altera_avalon_jtag_uart_ioctl>
}
 9097608:	e037883a 	mov	sp,fp
 909760c:	dfc00117 	ldw	ra,4(sp)
 9097610:	df000017 	ldw	fp,0(sp)
 9097614:	dec00204 	addi	sp,sp,8
 9097618:	f800283a 	ret

0909761c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 909761c:	defff404 	addi	sp,sp,-48
 9097620:	dfc00b15 	stw	ra,44(sp)
 9097624:	df000a15 	stw	fp,40(sp)
 9097628:	df000a04 	addi	fp,sp,40
 909762c:	e13ffd15 	stw	r4,-12(fp)
 9097630:	e17ffe15 	stw	r5,-8(fp)
 9097634:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 9097638:	e0bffd17 	ldw	r2,-12(fp)
 909763c:	10800c04 	addi	r2,r2,48
 9097640:	e0bffb15 	stw	r2,-20(fp)
 9097644:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 9097648:	e13ffc0b 	ldhu	r4,-16(fp)
 909764c:	e17ffc84 	addi	r5,fp,-14
 9097650:	908f6b40 	call	908f6b4 <OSFlagCreate>
 9097654:	1007883a 	mov	r3,r2
 9097658:	e0bffb17 	ldw	r2,-20(fp)
 909765c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 9097660:	e0bffd17 	ldw	r2,-12(fp)
 9097664:	10800a04 	addi	r2,r2,40
 9097668:	e0bff915 	stw	r2,-28(fp)
 909766c:	00800044 	movi	r2,1
 9097670:	e0bffa0d 	sth	r2,-24(fp)
 9097674:	e13ffa0b 	ldhu	r4,-24(fp)
 9097678:	90928b80 	call	90928b8 <OSSemCreate>
 909767c:	1007883a 	mov	r3,r2
 9097680:	e0bff917 	ldw	r2,-28(fp)
 9097684:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 9097688:	e0bffd17 	ldw	r2,-12(fp)
 909768c:	10800b04 	addi	r2,r2,44
 9097690:	e0bff715 	stw	r2,-36(fp)
 9097694:	00800044 	movi	r2,1
 9097698:	e0bff80d 	sth	r2,-32(fp)
 909769c:	e13ff80b 	ldhu	r4,-32(fp)
 90976a0:	90928b80 	call	90928b8 <OSSemCreate>
 90976a4:	1007883a 	mov	r3,r2
 90976a8:	e0bff717 	ldw	r2,-36(fp)
 90976ac:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 90976b0:	e0fffd17 	ldw	r3,-12(fp)
 90976b4:	00800044 	movi	r2,1
 90976b8:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 90976bc:	e0bffd17 	ldw	r2,-12(fp)
 90976c0:	10800017 	ldw	r2,0(r2)
 90976c4:	11000104 	addi	r4,r2,4
 90976c8:	e0bffd17 	ldw	r2,-12(fp)
 90976cc:	10800817 	ldw	r2,32(r2)
 90976d0:	1007883a 	mov	r3,r2
 90976d4:	2005883a 	mov	r2,r4
 90976d8:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 90976dc:	e13ffe17 	ldw	r4,-8(fp)
 90976e0:	e17fff17 	ldw	r5,-4(fp)
 90976e4:	d8000015 	stw	zero,0(sp)
 90976e8:	01824274 	movhi	r6,2313
 90976ec:	319dd504 	addi	r6,r6,30548
 90976f0:	e1fffd17 	ldw	r7,-12(fp)
 90976f4:	90b90300 	call	90b9030 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 90976f8:	e0bffd17 	ldw	r2,-12(fp)
 90976fc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 9097700:	e0bffd17 	ldw	r2,-12(fp)
 9097704:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 9097708:	00824374 	movhi	r2,2317
 909770c:	108c5204 	addi	r2,r2,12616
 9097710:	10800017 	ldw	r2,0(r2)
 9097714:	100b883a 	mov	r5,r2
 9097718:	01824274 	movhi	r6,2313
 909771c:	319e8604 	addi	r6,r6,31256
 9097720:	e1fffd17 	ldw	r7,-12(fp)
 9097724:	90b899c0 	call	90b899c <alt_alarm_start>
 9097728:	1004403a 	cmpge	r2,r2,zero
 909772c:	1000041e 	bne	r2,zero,9097740 <altera_avalon_jtag_uart_init+0x124>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 9097730:	e0fffd17 	ldw	r3,-12(fp)
 9097734:	00a00034 	movhi	r2,32768
 9097738:	10bfffc4 	addi	r2,r2,-1
 909773c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 9097740:	e037883a 	mov	sp,fp
 9097744:	dfc00117 	ldw	ra,4(sp)
 9097748:	df000017 	ldw	fp,0(sp)
 909774c:	dec00204 	addi	sp,sp,8
 9097750:	f800283a 	ret

09097754 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 9097754:	defff204 	addi	sp,sp,-56
 9097758:	dfc00d15 	stw	ra,52(sp)
 909775c:	df000c15 	stw	fp,48(sp)
 9097760:	df000c04 	addi	fp,sp,48
 9097764:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 9097768:	e0bfff17 	ldw	r2,-4(fp)
 909776c:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 9097770:	e0bffd17 	ldw	r2,-12(fp)
 9097774:	10800017 	ldw	r2,0(r2)
 9097778:	e0bffc15 	stw	r2,-16(fp)
 909777c:	00000006 	br	9097780 <altera_avalon_jtag_uart_irq+0x2c>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 9097780:	e0bffc17 	ldw	r2,-16(fp)
 9097784:	10800104 	addi	r2,r2,4
 9097788:	10800037 	ldwio	r2,0(r2)
 909778c:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 9097790:	e0bffb17 	ldw	r2,-20(fp)
 9097794:	1080c00c 	andi	r2,r2,768
 9097798:	1005003a 	cmpeq	r2,r2,zero
 909779c:	1000991e 	bne	r2,zero,9097a04 <altera_avalon_jtag_uart_irq+0x2b0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 90977a0:	e0bffb17 	ldw	r2,-20(fp)
 90977a4:	1080400c 	andi	r2,r2,256
 90977a8:	1005003a 	cmpeq	r2,r2,zero
 90977ac:	1000481e 	bne	r2,zero,90978d0 <altera_avalon_jtag_uart_irq+0x17c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 90977b0:	00800074 	movhi	r2,1
 90977b4:	e0bffa15 	stw	r2,-24(fp)
 90977b8:	00000006 	br	90977bc <altera_avalon_jtag_uart_irq+0x68>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 90977bc:	e0bffd17 	ldw	r2,-12(fp)
 90977c0:	10800d17 	ldw	r2,52(r2)
 90977c4:	10800044 	addi	r2,r2,1
 90977c8:	1081ffcc 	andi	r2,r2,2047
 90977cc:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 90977d0:	e0bffd17 	ldw	r2,-12(fp)
 90977d4:	10c00e17 	ldw	r3,56(r2)
 90977d8:	e0bff917 	ldw	r2,-28(fp)
 90977dc:	18802826 	beq	r3,r2,9097880 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 90977e0:	e0bffc17 	ldw	r2,-16(fp)
 90977e4:	10800037 	ldwio	r2,0(r2)
 90977e8:	e0bffa15 	stw	r2,-24(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 90977ec:	e0bffa17 	ldw	r2,-24(fp)
 90977f0:	10a0000c 	andi	r2,r2,32768
 90977f4:	1005003a 	cmpeq	r2,r2,zero
 90977f8:	1000211e 	bne	r2,zero,9097880 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 90977fc:	e0bffd17 	ldw	r2,-12(fp)
 9097800:	10c00d17 	ldw	r3,52(r2)
 9097804:	e0bffa17 	ldw	r2,-24(fp)
 9097808:	1009883a 	mov	r4,r2
 909780c:	e0bffd17 	ldw	r2,-12(fp)
 9097810:	1885883a 	add	r2,r3,r2
 9097814:	10801104 	addi	r2,r2,68
 9097818:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 909781c:	e0bffd17 	ldw	r2,-12(fp)
 9097820:	10800d17 	ldw	r2,52(r2)
 9097824:	10800044 	addi	r2,r2,1
 9097828:	10c1ffcc 	andi	r3,r2,2047
 909782c:	e0bffd17 	ldw	r2,-12(fp)
 9097830:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 9097834:	e0bffd17 	ldw	r2,-12(fp)
 9097838:	10800c17 	ldw	r2,48(r2)
 909783c:	e0bff615 	stw	r2,-40(fp)
 9097840:	00800044 	movi	r2,1
 9097844:	e0bff70d 	sth	r2,-36(fp)
 9097848:	00800044 	movi	r2,1
 909784c:	e0bff785 	stb	r2,-34(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9097850:	00824374 	movhi	r2,2317
 9097854:	108c0544 	addi	r2,r2,12309
 9097858:	10800003 	ldbu	r2,0(r2)
 909785c:	10803fcc 	andi	r2,r2,255
 9097860:	1005003a 	cmpeq	r2,r2,zero
 9097864:	103fd51e 	bne	r2,zero,90977bc <altera_avalon_jtag_uart_irq+0x68>
  {
    OSFlagPost (group, flags, opt, &err);
 9097868:	e17ff70b 	ldhu	r5,-36(fp)
 909786c:	e1bff783 	ldbu	r6,-34(fp)
 9097870:	e1fffe04 	addi	r7,fp,-8
 9097874:	e13ff617 	ldw	r4,-40(fp)
 9097878:	90903dc0 	call	90903dc <OSFlagPost>
    return err;
 909787c:	003fcf06 	br	90977bc <altera_avalon_jtag_uart_irq+0x68>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 9097880:	e0bffa17 	ldw	r2,-24(fp)
 9097884:	10bfffec 	andhi	r2,r2,65535
 9097888:	1005003a 	cmpeq	r2,r2,zero
 909788c:	1000101e 	bne	r2,zero,90978d0 <altera_avalon_jtag_uart_irq+0x17c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9097890:	e0bffd17 	ldw	r2,-12(fp)
 9097894:	10c00817 	ldw	r3,32(r2)
 9097898:	00bfff84 	movi	r2,-2
 909789c:	1886703a 	and	r3,r3,r2
 90978a0:	e0bffd17 	ldw	r2,-12(fp)
 90978a4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 90978a8:	e0bffc17 	ldw	r2,-16(fp)
 90978ac:	11000104 	addi	r4,r2,4
 90978b0:	e0bffd17 	ldw	r2,-12(fp)
 90978b4:	10800817 	ldw	r2,32(r2)
 90978b8:	1007883a 	mov	r3,r2
 90978bc:	2005883a 	mov	r2,r4
 90978c0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 90978c4:	e0bffc17 	ldw	r2,-16(fp)
 90978c8:	10800104 	addi	r2,r2,4
 90978cc:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 90978d0:	e0bffb17 	ldw	r2,-20(fp)
 90978d4:	1080800c 	andi	r2,r2,512
 90978d8:	1005003a 	cmpeq	r2,r2,zero
 90978dc:	103fa81e 	bne	r2,zero,9097780 <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 90978e0:	e0bffb17 	ldw	r2,-20(fp)
 90978e4:	10bfffec 	andhi	r2,r2,65535
 90978e8:	1004d43a 	srli	r2,r2,16
 90978ec:	e0bff815 	stw	r2,-32(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 90978f0:	00002706 	br	9097990 <altera_avalon_jtag_uart_irq+0x23c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 90978f4:	e13ffc17 	ldw	r4,-16(fp)
 90978f8:	e0bffd17 	ldw	r2,-12(fp)
 90978fc:	10c01017 	ldw	r3,64(r2)
 9097900:	e0bffd17 	ldw	r2,-12(fp)
 9097904:	1885883a 	add	r2,r3,r2
 9097908:	10821104 	addi	r2,r2,2116
 909790c:	10800003 	ldbu	r2,0(r2)
 9097910:	10c03fcc 	andi	r3,r2,255
 9097914:	18c0201c 	xori	r3,r3,128
 9097918:	18ffe004 	addi	r3,r3,-128
 909791c:	2005883a 	mov	r2,r4
 9097920:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9097924:	e0bffd17 	ldw	r2,-12(fp)
 9097928:	10801017 	ldw	r2,64(r2)
 909792c:	10800044 	addi	r2,r2,1
 9097930:	10c1ffcc 	andi	r3,r2,2047
 9097934:	e0bffd17 	ldw	r2,-12(fp)
 9097938:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 909793c:	e0bffd17 	ldw	r2,-12(fp)
 9097940:	10800c17 	ldw	r2,48(r2)
 9097944:	e0bff415 	stw	r2,-48(fp)
 9097948:	00800084 	movi	r2,2
 909794c:	e0bff50d 	sth	r2,-44(fp)
 9097950:	00800044 	movi	r2,1
 9097954:	e0bff585 	stb	r2,-42(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9097958:	00824374 	movhi	r2,2317
 909795c:	108c0544 	addi	r2,r2,12309
 9097960:	10800003 	ldbu	r2,0(r2)
 9097964:	10803fcc 	andi	r2,r2,255
 9097968:	1005003a 	cmpeq	r2,r2,zero
 909796c:	1000051e 	bne	r2,zero,9097984 <altera_avalon_jtag_uart_irq+0x230>
  {
    OSFlagPost (group, flags, opt, &err);
 9097970:	e17ff50b 	ldhu	r5,-44(fp)
 9097974:	e1bff583 	ldbu	r6,-42(fp)
 9097978:	e1fffe44 	addi	r7,fp,-7
 909797c:	e13ff417 	ldw	r4,-48(fp)
 9097980:	90903dc0 	call	90903dc <OSFlagPost>

        space--;
 9097984:	e0bff817 	ldw	r2,-32(fp)
 9097988:	10bfffc4 	addi	r2,r2,-1
 909798c:	e0bff815 	stw	r2,-32(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 9097990:	e0bff817 	ldw	r2,-32(fp)
 9097994:	1005003a 	cmpeq	r2,r2,zero
 9097998:	1000051e 	bne	r2,zero,90979b0 <altera_avalon_jtag_uart_irq+0x25c>
 909799c:	e0bffd17 	ldw	r2,-12(fp)
 90979a0:	10c01017 	ldw	r3,64(r2)
 90979a4:	e0bffd17 	ldw	r2,-12(fp)
 90979a8:	10800f17 	ldw	r2,60(r2)
 90979ac:	18bfd11e 	bne	r3,r2,90978f4 <altera_avalon_jtag_uart_irq+0x1a0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 90979b0:	e0bff817 	ldw	r2,-32(fp)
 90979b4:	1005003a 	cmpeq	r2,r2,zero
 90979b8:	103f711e 	bne	r2,zero,9097780 <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 90979bc:	e0bffd17 	ldw	r2,-12(fp)
 90979c0:	10c00817 	ldw	r3,32(r2)
 90979c4:	00bfff44 	movi	r2,-3
 90979c8:	1886703a 	and	r3,r3,r2
 90979cc:	e0bffd17 	ldw	r2,-12(fp)
 90979d0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 90979d4:	e0bffd17 	ldw	r2,-12(fp)
 90979d8:	10800017 	ldw	r2,0(r2)
 90979dc:	11000104 	addi	r4,r2,4
 90979e0:	e0bffd17 	ldw	r2,-12(fp)
 90979e4:	10800817 	ldw	r2,32(r2)
 90979e8:	1007883a 	mov	r3,r2
 90979ec:	2005883a 	mov	r2,r4
 90979f0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 90979f4:	e0bffc17 	ldw	r2,-16(fp)
 90979f8:	10800104 	addi	r2,r2,4
 90979fc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 9097a00:	003f5f06 	br	9097780 <altera_avalon_jtag_uart_irq+0x2c>
}
 9097a04:	e037883a 	mov	sp,fp
 9097a08:	dfc00117 	ldw	ra,4(sp)
 9097a0c:	df000017 	ldw	fp,0(sp)
 9097a10:	dec00204 	addi	sp,sp,8
 9097a14:	f800283a 	ret

09097a18 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 9097a18:	defff804 	addi	sp,sp,-32
 9097a1c:	dfc00715 	stw	ra,28(sp)
 9097a20:	df000615 	stw	fp,24(sp)
 9097a24:	df000604 	addi	fp,sp,24
 9097a28:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 9097a2c:	e0bfff17 	ldw	r2,-4(fp)
 9097a30:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 9097a34:	e0bffd17 	ldw	r2,-12(fp)
 9097a38:	10800017 	ldw	r2,0(r2)
 9097a3c:	10800104 	addi	r2,r2,4
 9097a40:	10800037 	ldwio	r2,0(r2)
 9097a44:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 9097a48:	e0bffc17 	ldw	r2,-16(fp)
 9097a4c:	1081000c 	andi	r2,r2,1024
 9097a50:	1005003a 	cmpeq	r2,r2,zero
 9097a54:	10000c1e 	bne	r2,zero,9097a88 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 9097a58:	e0bffd17 	ldw	r2,-12(fp)
 9097a5c:	10800017 	ldw	r2,0(r2)
 9097a60:	11000104 	addi	r4,r2,4
 9097a64:	e0bffd17 	ldw	r2,-12(fp)
 9097a68:	10800817 	ldw	r2,32(r2)
 9097a6c:	10810014 	ori	r2,r2,1024
 9097a70:	1007883a 	mov	r3,r2
 9097a74:	2005883a 	mov	r2,r4
 9097a78:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 9097a7c:	e0bffd17 	ldw	r2,-12(fp)
 9097a80:	10000915 	stw	zero,36(r2)
 9097a84:	00002106 	br	9097b0c <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 9097a88:	e0bffd17 	ldw	r2,-12(fp)
 9097a8c:	10c00917 	ldw	r3,36(r2)
 9097a90:	00a00034 	movhi	r2,32768
 9097a94:	10bfff04 	addi	r2,r2,-4
 9097a98:	10c01c36 	bltu	r2,r3,9097b0c <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 9097a9c:	e0bffd17 	ldw	r2,-12(fp)
 9097aa0:	10800917 	ldw	r2,36(r2)
 9097aa4:	10c00044 	addi	r3,r2,1
 9097aa8:	e0bffd17 	ldw	r2,-12(fp)
 9097aac:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 9097ab0:	e0bffd17 	ldw	r2,-12(fp)
 9097ab4:	10c00917 	ldw	r3,36(r2)
 9097ab8:	e0bffd17 	ldw	r2,-12(fp)
 9097abc:	10800117 	ldw	r2,4(r2)
 9097ac0:	18801236 	bltu	r3,r2,9097b0c <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 9097ac4:	e0bffd17 	ldw	r2,-12(fp)
 9097ac8:	10800c17 	ldw	r2,48(r2)
 9097acc:	e0bffa15 	stw	r2,-24(fp)
 9097ad0:	00800104 	movi	r2,4
 9097ad4:	e0bffb0d 	sth	r2,-20(fp)
 9097ad8:	00800044 	movi	r2,1
 9097adc:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9097ae0:	00824374 	movhi	r2,2317
 9097ae4:	108c0544 	addi	r2,r2,12309
 9097ae8:	10800003 	ldbu	r2,0(r2)
 9097aec:	10803fcc 	andi	r2,r2,255
 9097af0:	1005003a 	cmpeq	r2,r2,zero
 9097af4:	1000051e 	bne	r2,zero,9097b0c <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 9097af8:	e17ffb0b 	ldhu	r5,-20(fp)
 9097afc:	e1bffb83 	ldbu	r6,-18(fp)
 9097b00:	e1fffe04 	addi	r7,fp,-8
 9097b04:	e13ffa17 	ldw	r4,-24(fp)
 9097b08:	90903dc0 	call	90903dc <OSFlagPost>
 9097b0c:	00824374 	movhi	r2,2317
 9097b10:	108c5204 	addi	r2,r2,12616
 9097b14:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 9097b18:	e037883a 	mov	sp,fp
 9097b1c:	dfc00117 	ldw	ra,4(sp)
 9097b20:	df000017 	ldw	fp,0(sp)
 9097b24:	dec00204 	addi	sp,sp,8
 9097b28:	f800283a 	ret

09097b2c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 9097b2c:	defffc04 	addi	sp,sp,-16
 9097b30:	df000315 	stw	fp,12(sp)
 9097b34:	df000304 	addi	fp,sp,12
 9097b38:	e13ffd15 	stw	r4,-12(fp)
 9097b3c:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9097b40:	00000706 	br	9097b60 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 9097b44:	e0bffe17 	ldw	r2,-8(fp)
 9097b48:	1090000c 	andi	r2,r2,16384
 9097b4c:	1005003a 	cmpeq	r2,r2,zero
 9097b50:	1000031e 	bne	r2,zero,9097b60 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 9097b54:	00bffd44 	movi	r2,-11
 9097b58:	e0bfff15 	stw	r2,-4(fp)
 9097b5c:	00000b06 	br	9097b8c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9097b60:	e0bffd17 	ldw	r2,-12(fp)
 9097b64:	10c01017 	ldw	r3,64(r2)
 9097b68:	e0bffd17 	ldw	r2,-12(fp)
 9097b6c:	10800f17 	ldw	r2,60(r2)
 9097b70:	18800526 	beq	r3,r2,9097b88 <altera_avalon_jtag_uart_close+0x5c>
 9097b74:	e0bffd17 	ldw	r2,-12(fp)
 9097b78:	10c00917 	ldw	r3,36(r2)
 9097b7c:	e0bffd17 	ldw	r2,-12(fp)
 9097b80:	10800117 	ldw	r2,4(r2)
 9097b84:	18bfef36 	bltu	r3,r2,9097b44 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 9097b88:	e03fff15 	stw	zero,-4(fp)
 9097b8c:	e0bfff17 	ldw	r2,-4(fp)
}
 9097b90:	e037883a 	mov	sp,fp
 9097b94:	df000017 	ldw	fp,0(sp)
 9097b98:	dec00104 	addi	sp,sp,4
 9097b9c:	f800283a 	ret

09097ba0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 9097ba0:	defff804 	addi	sp,sp,-32
 9097ba4:	df000715 	stw	fp,28(sp)
 9097ba8:	df000704 	addi	fp,sp,28
 9097bac:	e13ffb15 	stw	r4,-20(fp)
 9097bb0:	e17ffc15 	stw	r5,-16(fp)
 9097bb4:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 9097bb8:	00bff9c4 	movi	r2,-25
 9097bbc:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 9097bc0:	e0bffc17 	ldw	r2,-16(fp)
 9097bc4:	e0bfff15 	stw	r2,-4(fp)
 9097bc8:	e0ffff17 	ldw	r3,-4(fp)
 9097bcc:	189a8060 	cmpeqi	r2,r3,27137
 9097bd0:	1000041e 	bne	r2,zero,9097be4 <altera_avalon_jtag_uart_ioctl+0x44>
 9097bd4:	e0ffff17 	ldw	r3,-4(fp)
 9097bd8:	189a80a0 	cmpeqi	r2,r3,27138
 9097bdc:	10001b1e 	bne	r2,zero,9097c4c <altera_avalon_jtag_uart_ioctl+0xac>
 9097be0:	00002706 	br	9097c80 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 9097be4:	e0bffb17 	ldw	r2,-20(fp)
 9097be8:	10c00117 	ldw	r3,4(r2)
 9097bec:	00a00034 	movhi	r2,32768
 9097bf0:	10bfffc4 	addi	r2,r2,-1
 9097bf4:	18802226 	beq	r3,r2,9097c80 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 9097bf8:	e0bffd17 	ldw	r2,-12(fp)
 9097bfc:	10800017 	ldw	r2,0(r2)
 9097c00:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 9097c04:	e0bff917 	ldw	r2,-28(fp)
 9097c08:	10800090 	cmplti	r2,r2,2
 9097c0c:	1000071e 	bne	r2,zero,9097c2c <altera_avalon_jtag_uart_ioctl+0x8c>
 9097c10:	e0fff917 	ldw	r3,-28(fp)
 9097c14:	00a00034 	movhi	r2,32768
 9097c18:	10bfffc4 	addi	r2,r2,-1
 9097c1c:	18800326 	beq	r3,r2,9097c2c <altera_avalon_jtag_uart_ioctl+0x8c>
 9097c20:	e0bff917 	ldw	r2,-28(fp)
 9097c24:	e0bffe15 	stw	r2,-8(fp)
 9097c28:	00000306 	br	9097c38 <altera_avalon_jtag_uart_ioctl+0x98>
 9097c2c:	00e00034 	movhi	r3,32768
 9097c30:	18ffff84 	addi	r3,r3,-2
 9097c34:	e0fffe15 	stw	r3,-8(fp)
 9097c38:	e0bffb17 	ldw	r2,-20(fp)
 9097c3c:	e0fffe17 	ldw	r3,-8(fp)
 9097c40:	10c00115 	stw	r3,4(r2)
      rc = 0;
 9097c44:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 9097c48:	00000d06 	br	9097c80 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 9097c4c:	e0bffb17 	ldw	r2,-20(fp)
 9097c50:	10c00117 	ldw	r3,4(r2)
 9097c54:	00a00034 	movhi	r2,32768
 9097c58:	10bfffc4 	addi	r2,r2,-1
 9097c5c:	18800826 	beq	r3,r2,9097c80 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 9097c60:	e13ffd17 	ldw	r4,-12(fp)
 9097c64:	e0bffb17 	ldw	r2,-20(fp)
 9097c68:	10c00917 	ldw	r3,36(r2)
 9097c6c:	e0bffb17 	ldw	r2,-20(fp)
 9097c70:	10800117 	ldw	r2,4(r2)
 9097c74:	1885803a 	cmpltu	r2,r3,r2
 9097c78:	20800015 	stw	r2,0(r4)
      rc = 0;
 9097c7c:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 9097c80:	e0bffa17 	ldw	r2,-24(fp)
}
 9097c84:	e037883a 	mov	sp,fp
 9097c88:	df000017 	ldw	fp,0(sp)
 9097c8c:	dec00104 	addi	sp,sp,4
 9097c90:	f800283a 	ret

09097c94 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 9097c94:	deffeb04 	addi	sp,sp,-84
 9097c98:	dfc01415 	stw	ra,80(sp)
 9097c9c:	df001315 	stw	fp,76(sp)
 9097ca0:	df001304 	addi	fp,sp,76
 9097ca4:	e13ffb15 	stw	r4,-20(fp)
 9097ca8:	e17ffc15 	stw	r5,-16(fp)
 9097cac:	e1bffd15 	stw	r6,-12(fp)
 9097cb0:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 9097cb4:	e0bffc17 	ldw	r2,-16(fp)
 9097cb8:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 9097cbc:	e0bffb17 	ldw	r2,-20(fp)
 9097cc0:	10800a17 	ldw	r2,40(r2)
 9097cc4:	e0bff315 	stw	r2,-52(fp)
 9097cc8:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 9097ccc:	e17ff40b 	ldhu	r5,-48(fp)
 9097cd0:	e1bffa44 	addi	r6,fp,-23
 9097cd4:	e13ff317 	ldw	r4,-52(fp)
 9097cd8:	9092c6c0 	call	9092c6c <OSSemPend>

  while (space > 0)
 9097cdc:	00006406 	br	9097e70 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 9097ce0:	e0bffb17 	ldw	r2,-20(fp)
 9097ce4:	10800d17 	ldw	r2,52(r2)
 9097ce8:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 9097cec:	e0bffb17 	ldw	r2,-20(fp)
 9097cf0:	10800e17 	ldw	r2,56(r2)
 9097cf4:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 9097cf8:	e0fff617 	ldw	r3,-40(fp)
 9097cfc:	e0bff517 	ldw	r2,-44(fp)
 9097d00:	18800536 	bltu	r3,r2,9097d18 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 9097d04:	e0bff617 	ldw	r2,-40(fp)
 9097d08:	e0fff517 	ldw	r3,-44(fp)
 9097d0c:	10c5c83a 	sub	r2,r2,r3
 9097d10:	e0bff715 	stw	r2,-36(fp)
 9097d14:	00000406 	br	9097d28 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 9097d18:	00820004 	movi	r2,2048
 9097d1c:	e0fff517 	ldw	r3,-44(fp)
 9097d20:	10c5c83a 	sub	r2,r2,r3
 9097d24:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 9097d28:	e0bff717 	ldw	r2,-36(fp)
 9097d2c:	1005003a 	cmpeq	r2,r2,zero
 9097d30:	10001f1e 	bne	r2,zero,9097db0 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 9097d34:	e0fffd17 	ldw	r3,-12(fp)
 9097d38:	e0bff717 	ldw	r2,-36(fp)
 9097d3c:	1880022e 	bgeu	r3,r2,9097d48 <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 9097d40:	e0bffd17 	ldw	r2,-12(fp)
 9097d44:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 9097d48:	e0bffb17 	ldw	r2,-20(fp)
 9097d4c:	10c01104 	addi	r3,r2,68
 9097d50:	e0bff517 	ldw	r2,-44(fp)
 9097d54:	1887883a 	add	r3,r3,r2
 9097d58:	e0bff917 	ldw	r2,-28(fp)
 9097d5c:	1009883a 	mov	r4,r2
 9097d60:	180b883a 	mov	r5,r3
 9097d64:	e1bff717 	ldw	r6,-36(fp)
 9097d68:	90822780 	call	9082278 <memcpy>
      ptr   += n;
 9097d6c:	e0fff717 	ldw	r3,-36(fp)
 9097d70:	e0bff917 	ldw	r2,-28(fp)
 9097d74:	10c5883a 	add	r2,r2,r3
 9097d78:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 9097d7c:	e0fffd17 	ldw	r3,-12(fp)
 9097d80:	e0bff717 	ldw	r2,-36(fp)
 9097d84:	1885c83a 	sub	r2,r3,r2
 9097d88:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9097d8c:	e0fff517 	ldw	r3,-44(fp)
 9097d90:	e0bff717 	ldw	r2,-36(fp)
 9097d94:	1885883a 	add	r2,r3,r2
 9097d98:	10c1ffcc 	andi	r3,r2,2047
 9097d9c:	e0bffb17 	ldw	r2,-20(fp)
 9097da0:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 9097da4:	e0bffd17 	ldw	r2,-12(fp)
 9097da8:	10800048 	cmpgei	r2,r2,1
 9097dac:	103fcc1e 	bne	r2,zero,9097ce0 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 9097db0:	e0fff917 	ldw	r3,-28(fp)
 9097db4:	e0bffc17 	ldw	r2,-16(fp)
 9097db8:	1880301e 	bne	r3,r2,9097e7c <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 9097dbc:	e0bffe17 	ldw	r2,-8(fp)
 9097dc0:	1090000c 	andi	r2,r2,16384
 9097dc4:	1004c03a 	cmpne	r2,r2,zero
 9097dc8:	10002c1e 	bne	r2,zero,9097e7c <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 9097dcc:	00824374 	movhi	r2,2317
 9097dd0:	108c0544 	addi	r2,r2,12309
 9097dd4:	10800003 	ldbu	r2,0(r2)
 9097dd8:	10803fcc 	andi	r2,r2,255
 9097ddc:	10800058 	cmpnei	r2,r2,1
 9097de0:	1000161e 	bne	r2,zero,9097e3c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 9097de4:	e0bffb17 	ldw	r2,-20(fp)
 9097de8:	10800c17 	ldw	r2,48(r2)
 9097dec:	e0bff015 	stw	r2,-64(fp)
 9097df0:	00800144 	movi	r2,5
 9097df4:	e0bff10d 	sth	r2,-60(fp)
 9097df8:	00bfe0c4 	movi	r2,-125
 9097dfc:	e0bff185 	stb	r2,-58(fp)
 9097e00:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 9097e04:	00824374 	movhi	r2,2317
 9097e08:	108c0544 	addi	r2,r2,12309
 9097e0c:	10800003 	ldbu	r2,0(r2)
 9097e10:	10803fcc 	andi	r2,r2,255
 9097e14:	1005003a 	cmpeq	r2,r2,zero
 9097e18:	1000111e 	bne	r2,zero,9097e60 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 9097e1c:	e17ff10b 	ldhu	r5,-60(fp)
 9097e20:	e1bff183 	ldbu	r6,-58(fp)
 9097e24:	e1fff20b 	ldhu	r7,-56(fp)
 9097e28:	e0bffa04 	addi	r2,fp,-24
 9097e2c:	d8800015 	stw	r2,0(sp)
 9097e30:	e13ff017 	ldw	r4,-64(fp)
 9097e34:	908fd300 	call	908fd30 <OSFlagPend>
    return err;
 9097e38:	00000906 	br	9097e60 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 9097e3c:	e0bffb17 	ldw	r2,-20(fp)
 9097e40:	10c00d17 	ldw	r3,52(r2)
 9097e44:	e0bff617 	ldw	r2,-40(fp)
 9097e48:	1880051e 	bne	r3,r2,9097e60 <altera_avalon_jtag_uart_read+0x1cc>
 9097e4c:	e0bffb17 	ldw	r2,-20(fp)
 9097e50:	10c00917 	ldw	r3,36(r2)
 9097e54:	e0bffb17 	ldw	r2,-20(fp)
 9097e58:	10800117 	ldw	r2,4(r2)
 9097e5c:	18bff736 	bltu	r3,r2,9097e3c <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 9097e60:	e0bffb17 	ldw	r2,-20(fp)
 9097e64:	10c00d17 	ldw	r3,52(r2)
 9097e68:	e0bff617 	ldw	r2,-40(fp)
 9097e6c:	18800326 	beq	r3,r2,9097e7c <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 9097e70:	e0bffd17 	ldw	r2,-12(fp)
 9097e74:	10800048 	cmpgei	r2,r2,1
 9097e78:	103f991e 	bne	r2,zero,9097ce0 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 9097e7c:	e0bffb17 	ldw	r2,-20(fp)
 9097e80:	11000a17 	ldw	r4,40(r2)
 9097e84:	90930640 	call	9093064 <OSSemPost>

  if (ptr != buffer)
 9097e88:	e0fff917 	ldw	r3,-28(fp)
 9097e8c:	e0bffc17 	ldw	r2,-16(fp)
 9097e90:	18801926 	beq	r3,r2,9097ef8 <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9097e94:	0005303a 	rdctl	r2,status
 9097e98:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9097e9c:	e0ffef17 	ldw	r3,-68(fp)
 9097ea0:	00bfff84 	movi	r2,-2
 9097ea4:	1884703a 	and	r2,r3,r2
 9097ea8:	1001703a 	wrctl	status,r2
  
  return context;
 9097eac:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 9097eb0:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9097eb4:	e0bffb17 	ldw	r2,-20(fp)
 9097eb8:	10800817 	ldw	r2,32(r2)
 9097ebc:	10c00054 	ori	r3,r2,1
 9097ec0:	e0bffb17 	ldw	r2,-20(fp)
 9097ec4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 9097ec8:	e0bffb17 	ldw	r2,-20(fp)
 9097ecc:	10800017 	ldw	r2,0(r2)
 9097ed0:	11000104 	addi	r4,r2,4
 9097ed4:	e0bffb17 	ldw	r2,-20(fp)
 9097ed8:	10800817 	ldw	r2,32(r2)
 9097edc:	1007883a 	mov	r3,r2
 9097ee0:	2005883a 	mov	r2,r4
 9097ee4:	10c00035 	stwio	r3,0(r2)
 9097ee8:	e0bff817 	ldw	r2,-32(fp)
 9097eec:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9097ef0:	e0bfee17 	ldw	r2,-72(fp)
 9097ef4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 9097ef8:	e0fff917 	ldw	r3,-28(fp)
 9097efc:	e0bffc17 	ldw	r2,-16(fp)
 9097f00:	18800526 	beq	r3,r2,9097f18 <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 9097f04:	e0fff917 	ldw	r3,-28(fp)
 9097f08:	e0bffc17 	ldw	r2,-16(fp)
 9097f0c:	1887c83a 	sub	r3,r3,r2
 9097f10:	e0ffff15 	stw	r3,-4(fp)
 9097f14:	00000906 	br	9097f3c <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 9097f18:	e0bffe17 	ldw	r2,-8(fp)
 9097f1c:	1090000c 	andi	r2,r2,16384
 9097f20:	1005003a 	cmpeq	r2,r2,zero
 9097f24:	1000031e 	bne	r2,zero,9097f34 <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 9097f28:	00bffd44 	movi	r2,-11
 9097f2c:	e0bfff15 	stw	r2,-4(fp)
 9097f30:	00000206 	br	9097f3c <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 9097f34:	00bffec4 	movi	r2,-5
 9097f38:	e0bfff15 	stw	r2,-4(fp)
 9097f3c:	e0bfff17 	ldw	r2,-4(fp)
}
 9097f40:	e037883a 	mov	sp,fp
 9097f44:	dfc00117 	ldw	ra,4(sp)
 9097f48:	df000017 	ldw	fp,0(sp)
 9097f4c:	dec00204 	addi	sp,sp,8
 9097f50:	f800283a 	ret

09097f54 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 9097f54:	deffeb04 	addi	sp,sp,-84
 9097f58:	dfc01415 	stw	ra,80(sp)
 9097f5c:	df001315 	stw	fp,76(sp)
 9097f60:	df001304 	addi	fp,sp,76
 9097f64:	e13ffb15 	stw	r4,-20(fp)
 9097f68:	e17ffc15 	stw	r5,-16(fp)
 9097f6c:	e1bffd15 	stw	r6,-12(fp)
 9097f70:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 9097f74:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 9097f78:	e0bffc17 	ldw	r2,-16(fp)
 9097f7c:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 9097f80:	e0bffb17 	ldw	r2,-20(fp)
 9097f84:	10800b17 	ldw	r2,44(r2)
 9097f88:	e0bff315 	stw	r2,-52(fp)
 9097f8c:	e03ff40d 	sth	zero,-48(fp)
 9097f90:	e17ff40b 	ldhu	r5,-48(fp)
 9097f94:	e1bffa04 	addi	r6,fp,-24
 9097f98:	e13ff317 	ldw	r4,-52(fp)
 9097f9c:	9092c6c0 	call	9092c6c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 9097fa0:	00003a06 	br	909808c <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 9097fa4:	e0bffb17 	ldw	r2,-20(fp)
 9097fa8:	10800f17 	ldw	r2,60(r2)
 9097fac:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 9097fb0:	e0bffb17 	ldw	r2,-20(fp)
 9097fb4:	10801017 	ldw	r2,64(r2)
 9097fb8:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 9097fbc:	e0fff917 	ldw	r3,-28(fp)
 9097fc0:	e0bff817 	ldw	r2,-32(fp)
 9097fc4:	1880062e 	bgeu	r3,r2,9097fe0 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 9097fc8:	e0fff817 	ldw	r3,-32(fp)
 9097fcc:	e0bff917 	ldw	r2,-28(fp)
 9097fd0:	1885c83a 	sub	r2,r3,r2
 9097fd4:	10bfffc4 	addi	r2,r2,-1
 9097fd8:	e0bff715 	stw	r2,-36(fp)
 9097fdc:	00000c06 	br	9098010 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 9097fe0:	e0bff817 	ldw	r2,-32(fp)
 9097fe4:	1005003a 	cmpeq	r2,r2,zero
 9097fe8:	1000051e 	bne	r2,zero,9098000 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 9097fec:	00820004 	movi	r2,2048
 9097ff0:	e0fff917 	ldw	r3,-28(fp)
 9097ff4:	10c5c83a 	sub	r2,r2,r3
 9097ff8:	e0bff715 	stw	r2,-36(fp)
 9097ffc:	00000406 	br	9098010 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 9098000:	0081ffc4 	movi	r2,2047
 9098004:	e0fff917 	ldw	r3,-28(fp)
 9098008:	10c5c83a 	sub	r2,r2,r3
 909800c:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 9098010:	e0bff717 	ldw	r2,-36(fp)
 9098014:	1005003a 	cmpeq	r2,r2,zero
 9098018:	10001f1e 	bne	r2,zero,9098098 <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 909801c:	e0fffd17 	ldw	r3,-12(fp)
 9098020:	e0bff717 	ldw	r2,-36(fp)
 9098024:	1880022e 	bgeu	r3,r2,9098030 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 9098028:	e0bffd17 	ldw	r2,-12(fp)
 909802c:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 9098030:	e0bffb17 	ldw	r2,-20(fp)
 9098034:	10c21104 	addi	r3,r2,2116
 9098038:	e0bff917 	ldw	r2,-28(fp)
 909803c:	1885883a 	add	r2,r3,r2
 9098040:	e0fffc17 	ldw	r3,-16(fp)
 9098044:	1009883a 	mov	r4,r2
 9098048:	180b883a 	mov	r5,r3
 909804c:	e1bff717 	ldw	r6,-36(fp)
 9098050:	90822780 	call	9082278 <memcpy>
      ptr   += n;
 9098054:	e0fff717 	ldw	r3,-36(fp)
 9098058:	e0bffc17 	ldw	r2,-16(fp)
 909805c:	10c5883a 	add	r2,r2,r3
 9098060:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 9098064:	e0fffd17 	ldw	r3,-12(fp)
 9098068:	e0bff717 	ldw	r2,-36(fp)
 909806c:	1885c83a 	sub	r2,r3,r2
 9098070:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9098074:	e0fff917 	ldw	r3,-28(fp)
 9098078:	e0bff717 	ldw	r2,-36(fp)
 909807c:	1885883a 	add	r2,r3,r2
 9098080:	10c1ffcc 	andi	r3,r2,2047
 9098084:	e0bffb17 	ldw	r2,-20(fp)
 9098088:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 909808c:	e0bffd17 	ldw	r2,-12(fp)
 9098090:	10800048 	cmpgei	r2,r2,1
 9098094:	103fc31e 	bne	r2,zero,9097fa4 <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9098098:	0005303a 	rdctl	r2,status
 909809c:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90980a0:	e0fff217 	ldw	r3,-56(fp)
 90980a4:	00bfff84 	movi	r2,-2
 90980a8:	1884703a 	and	r2,r3,r2
 90980ac:	1001703a 	wrctl	status,r2
  
  return context;
 90980b0:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 90980b4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 90980b8:	e0bffb17 	ldw	r2,-20(fp)
 90980bc:	10800817 	ldw	r2,32(r2)
 90980c0:	10c00094 	ori	r3,r2,2
 90980c4:	e0bffb17 	ldw	r2,-20(fp)
 90980c8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 90980cc:	e0bffb17 	ldw	r2,-20(fp)
 90980d0:	10800017 	ldw	r2,0(r2)
 90980d4:	11000104 	addi	r4,r2,4
 90980d8:	e0bffb17 	ldw	r2,-20(fp)
 90980dc:	10800817 	ldw	r2,32(r2)
 90980e0:	1007883a 	mov	r3,r2
 90980e4:	2005883a 	mov	r2,r4
 90980e8:	10c00035 	stwio	r3,0(r2)
 90980ec:	e0bff617 	ldw	r2,-40(fp)
 90980f0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90980f4:	e0bff117 	ldw	r2,-60(fp)
 90980f8:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 90980fc:	e0bffd17 	ldw	r2,-12(fp)
 9098100:	10800050 	cmplti	r2,r2,1
 9098104:	10002d1e 	bne	r2,zero,90981bc <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 9098108:	e0bffe17 	ldw	r2,-8(fp)
 909810c:	1090000c 	andi	r2,r2,16384
 9098110:	1004c03a 	cmpne	r2,r2,zero
 9098114:	10002c1e 	bne	r2,zero,90981c8 <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 9098118:	00824374 	movhi	r2,2317
 909811c:	108c0544 	addi	r2,r2,12309
 9098120:	10800003 	ldbu	r2,0(r2)
 9098124:	10803fcc 	andi	r2,r2,255
 9098128:	10800058 	cmpnei	r2,r2,1
 909812c:	1000161e 	bne	r2,zero,9098188 <altera_avalon_jtag_uart_write+0x234>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 9098130:	e0bffb17 	ldw	r2,-20(fp)
 9098134:	10800c17 	ldw	r2,48(r2)
 9098138:	e0bfee15 	stw	r2,-72(fp)
 909813c:	00800184 	movi	r2,6
 9098140:	e0bfef0d 	sth	r2,-68(fp)
 9098144:	00bfe0c4 	movi	r2,-125
 9098148:	e0bfef85 	stb	r2,-66(fp)
 909814c:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 9098150:	00824374 	movhi	r2,2317
 9098154:	108c0544 	addi	r2,r2,12309
 9098158:	10800003 	ldbu	r2,0(r2)
 909815c:	10803fcc 	andi	r2,r2,255
 9098160:	1005003a 	cmpeq	r2,r2,zero
 9098164:	1000111e 	bne	r2,zero,90981ac <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 9098168:	e17fef0b 	ldhu	r5,-68(fp)
 909816c:	e1bfef83 	ldbu	r6,-66(fp)
 9098170:	e1fff00b 	ldhu	r7,-64(fp)
 9098174:	e0bffa44 	addi	r2,fp,-23
 9098178:	d8800015 	stw	r2,0(sp)
 909817c:	e13fee17 	ldw	r4,-72(fp)
 9098180:	908fd300 	call	908fd30 <OSFlagPend>
    return err;
 9098184:	00000906 	br	90981ac <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 9098188:	e0bffb17 	ldw	r2,-20(fp)
 909818c:	10c01017 	ldw	r3,64(r2)
 9098190:	e0bff817 	ldw	r2,-32(fp)
 9098194:	1880051e 	bne	r3,r2,90981ac <altera_avalon_jtag_uart_write+0x258>
 9098198:	e0bffb17 	ldw	r2,-20(fp)
 909819c:	10c00917 	ldw	r3,36(r2)
 90981a0:	e0bffb17 	ldw	r2,-20(fp)
 90981a4:	10800117 	ldw	r2,4(r2)
 90981a8:	18bff736 	bltu	r3,r2,9098188 <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 90981ac:	e0bffb17 	ldw	r2,-20(fp)
 90981b0:	10c01017 	ldw	r3,64(r2)
 90981b4:	e0bff817 	ldw	r2,-32(fp)
 90981b8:	18800326 	beq	r3,r2,90981c8 <altera_avalon_jtag_uart_write+0x274>
         break;
    }
  }
  while (count > 0);
 90981bc:	e0bffd17 	ldw	r2,-12(fp)
 90981c0:	10800048 	cmpgei	r2,r2,1
 90981c4:	103fb11e 	bne	r2,zero,909808c <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 90981c8:	e0bffb17 	ldw	r2,-20(fp)
 90981cc:	11000b17 	ldw	r4,44(r2)
 90981d0:	90930640 	call	9093064 <OSSemPost>

  if (ptr != start)
 90981d4:	e0fffc17 	ldw	r3,-16(fp)
 90981d8:	e0bff517 	ldw	r2,-44(fp)
 90981dc:	18800526 	beq	r3,r2,90981f4 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 90981e0:	e0fffc17 	ldw	r3,-16(fp)
 90981e4:	e0bff517 	ldw	r2,-44(fp)
 90981e8:	1887c83a 	sub	r3,r3,r2
 90981ec:	e0ffff15 	stw	r3,-4(fp)
 90981f0:	00000906 	br	9098218 <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 90981f4:	e0bffe17 	ldw	r2,-8(fp)
 90981f8:	1090000c 	andi	r2,r2,16384
 90981fc:	1005003a 	cmpeq	r2,r2,zero
 9098200:	1000031e 	bne	r2,zero,9098210 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 9098204:	00bffd44 	movi	r2,-11
 9098208:	e0bfff15 	stw	r2,-4(fp)
 909820c:	00000206 	br	9098218 <altera_avalon_jtag_uart_write+0x2c4>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 9098210:	00bffec4 	movi	r2,-5
 9098214:	e0bfff15 	stw	r2,-4(fp)
 9098218:	e0bfff17 	ldw	r2,-4(fp)
}
 909821c:	e037883a 	mov	sp,fp
 9098220:	dfc00117 	ldw	ra,4(sp)
 9098224:	df000017 	ldw	fp,0(sp)
 9098228:	dec00204 	addi	sp,sp,8
 909822c:	f800283a 	ret

09098230 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 9098230:	defffa04 	addi	sp,sp,-24
 9098234:	dfc00515 	stw	ra,20(sp)
 9098238:	df000415 	stw	fp,16(sp)
 909823c:	df000404 	addi	fp,sp,16
 9098240:	e13ffe15 	stw	r4,-8(fp)
 9098244:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 9098248:	e0bffe17 	ldw	r2,-8(fp)
 909824c:	10800017 	ldw	r2,0(r2)
 9098250:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 9098254:	008003f4 	movhi	r2,15
 9098258:	10909004 	addi	r2,r2,16960
 909825c:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9098260:	e0bffe17 	ldw	r2,-8(fp)
 9098264:	10800803 	ldbu	r2,32(r2)
 9098268:	10803fcc 	andi	r2,r2,255
 909826c:	1080201c 	xori	r2,r2,128
 9098270:	10bfe004 	addi	r2,r2,-128
 9098274:	1004c03a 	cmpne	r2,r2,zero
 9098278:	1000161e 	bne	r2,zero,90982d4 <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 909827c:	00000a06 	br	90982a8 <lcd_write_command+0x78>
    if (--i == 0)
 9098280:	e0bffc17 	ldw	r2,-16(fp)
 9098284:	10bfffc4 	addi	r2,r2,-1
 9098288:	e0bffc15 	stw	r2,-16(fp)
 909828c:	e0bffc17 	ldw	r2,-16(fp)
 9098290:	1004c03a 	cmpne	r2,r2,zero
 9098294:	1000041e 	bne	r2,zero,90982a8 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 9098298:	e0fffe17 	ldw	r3,-8(fp)
 909829c:	00800044 	movi	r2,1
 90982a0:	18800805 	stb	r2,32(r3)
      return;
 90982a4:	00000b06 	br	90982d4 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 90982a8:	e0bffd17 	ldw	r2,-12(fp)
 90982ac:	10800104 	addi	r2,r2,4
 90982b0:	10800037 	ldwio	r2,0(r2)
 90982b4:	1080200c 	andi	r2,r2,128
 90982b8:	1004c03a 	cmpne	r2,r2,zero
 90982bc:	103ff01e 	bne	r2,zero,9098280 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 90982c0:	01001904 	movi	r4,100
 90982c4:	90b9b600 	call	90b9b60 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 90982c8:	e0bffd17 	ldw	r2,-12(fp)
 90982cc:	e0ffff03 	ldbu	r3,-4(fp)
 90982d0:	10c00035 	stwio	r3,0(r2)
}
 90982d4:	e037883a 	mov	sp,fp
 90982d8:	dfc00117 	ldw	ra,4(sp)
 90982dc:	df000017 	ldw	fp,0(sp)
 90982e0:	dec00204 	addi	sp,sp,8
 90982e4:	f800283a 	ret

090982e8 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 90982e8:	defffa04 	addi	sp,sp,-24
 90982ec:	dfc00515 	stw	ra,20(sp)
 90982f0:	df000415 	stw	fp,16(sp)
 90982f4:	df000404 	addi	fp,sp,16
 90982f8:	e13ffe15 	stw	r4,-8(fp)
 90982fc:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 9098300:	e0bffe17 	ldw	r2,-8(fp)
 9098304:	10800017 	ldw	r2,0(r2)
 9098308:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 909830c:	008003f4 	movhi	r2,15
 9098310:	10909004 	addi	r2,r2,16960
 9098314:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9098318:	e0bffe17 	ldw	r2,-8(fp)
 909831c:	10800803 	ldbu	r2,32(r2)
 9098320:	10803fcc 	andi	r2,r2,255
 9098324:	1080201c 	xori	r2,r2,128
 9098328:	10bfe004 	addi	r2,r2,-128
 909832c:	1004c03a 	cmpne	r2,r2,zero
 9098330:	10001d1e 	bne	r2,zero,90983a8 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9098334:	00000a06 	br	9098360 <lcd_write_data+0x78>
    if (--i == 0)
 9098338:	e0bffc17 	ldw	r2,-16(fp)
 909833c:	10bfffc4 	addi	r2,r2,-1
 9098340:	e0bffc15 	stw	r2,-16(fp)
 9098344:	e0bffc17 	ldw	r2,-16(fp)
 9098348:	1004c03a 	cmpne	r2,r2,zero
 909834c:	1000041e 	bne	r2,zero,9098360 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 9098350:	e0fffe17 	ldw	r3,-8(fp)
 9098354:	00800044 	movi	r2,1
 9098358:	18800805 	stb	r2,32(r3)
      return;
 909835c:	00001206 	br	90983a8 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9098360:	e0bffd17 	ldw	r2,-12(fp)
 9098364:	10800104 	addi	r2,r2,4
 9098368:	10800037 	ldwio	r2,0(r2)
 909836c:	1080200c 	andi	r2,r2,128
 9098370:	1004c03a 	cmpne	r2,r2,zero
 9098374:	103ff01e 	bne	r2,zero,9098338 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 9098378:	01001904 	movi	r4,100
 909837c:	90b9b600 	call	90b9b60 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 9098380:	e0bffd17 	ldw	r2,-12(fp)
 9098384:	10800204 	addi	r2,r2,8
 9098388:	e0ffff03 	ldbu	r3,-4(fp)
 909838c:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 9098390:	e0bffe17 	ldw	r2,-8(fp)
 9098394:	108008c3 	ldbu	r2,35(r2)
 9098398:	10800044 	addi	r2,r2,1
 909839c:	1007883a 	mov	r3,r2
 90983a0:	e0bffe17 	ldw	r2,-8(fp)
 90983a4:	10c008c5 	stb	r3,35(r2)
}
 90983a8:	e037883a 	mov	sp,fp
 90983ac:	dfc00117 	ldw	ra,4(sp)
 90983b0:	df000017 	ldw	fp,0(sp)
 90983b4:	dec00204 	addi	sp,sp,8
 90983b8:	f800283a 	ret

090983bc <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 90983bc:	defffc04 	addi	sp,sp,-16
 90983c0:	dfc00315 	stw	ra,12(sp)
 90983c4:	df000215 	stw	fp,8(sp)
 90983c8:	df000204 	addi	fp,sp,8
 90983cc:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 90983d0:	e13fff17 	ldw	r4,-4(fp)
 90983d4:	01400044 	movi	r5,1
 90983d8:	90982300 	call	9098230 <lcd_write_command>

  sp->x = 0;
 90983dc:	e0bfff17 	ldw	r2,-4(fp)
 90983e0:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 90983e4:	e0bfff17 	ldw	r2,-4(fp)
 90983e8:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 90983ec:	e0bfff17 	ldw	r2,-4(fp)
 90983f0:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90983f4:	e03ffe15 	stw	zero,-8(fp)
 90983f8:	00001906 	br	9098460 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 90983fc:	e0bffe17 	ldw	r2,-8(fp)
 9098400:	108018e4 	muli	r2,r2,99
 9098404:	10c01004 	addi	r3,r2,64
 9098408:	e0bfff17 	ldw	r2,-4(fp)
 909840c:	1889883a 	add	r4,r3,r2
 9098410:	01400804 	movi	r5,32
 9098414:	01801444 	movi	r6,81
 9098418:	90823f80 	call	90823f8 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 909841c:	e0bffe17 	ldw	r2,-8(fp)
 9098420:	108018e4 	muli	r2,r2,99
 9098424:	10c00c04 	addi	r3,r2,48
 9098428:	e0bfff17 	ldw	r2,-4(fp)
 909842c:	1889883a 	add	r4,r3,r2
 9098430:	01400804 	movi	r5,32
 9098434:	01800404 	movi	r6,16
 9098438:	90823f80 	call	90823f8 <memset>
    sp->line[y].width = 0;
 909843c:	e0bffe17 	ldw	r2,-8(fp)
 9098440:	e0ffff17 	ldw	r3,-4(fp)
 9098444:	108018e4 	muli	r2,r2,99
 9098448:	10c5883a 	add	r2,r2,r3
 909844c:	10802404 	addi	r2,r2,144
 9098450:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098454:	e0bffe17 	ldw	r2,-8(fp)
 9098458:	10800044 	addi	r2,r2,1
 909845c:	e0bffe15 	stw	r2,-8(fp)
 9098460:	e0bffe17 	ldw	r2,-8(fp)
 9098464:	10800090 	cmplti	r2,r2,2
 9098468:	103fe41e 	bne	r2,zero,90983fc <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 909846c:	e037883a 	mov	sp,fp
 9098470:	dfc00117 	ldw	ra,4(sp)
 9098474:	df000017 	ldw	fp,0(sp)
 9098478:	dec00204 	addi	sp,sp,8
 909847c:	f800283a 	ret

09098480 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 9098480:	defff704 	addi	sp,sp,-36
 9098484:	dfc00815 	stw	ra,32(sp)
 9098488:	df000715 	stw	fp,28(sp)
 909848c:	df000704 	addi	fp,sp,28
 9098490:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 9098494:	e0bfff17 	ldw	r2,-4(fp)
 9098498:	10800943 	ldbu	r2,37(r2)
 909849c:	10803fcc 	andi	r2,r2,255
 90984a0:	1080201c 	xori	r2,r2,128
 90984a4:	10bfe004 	addi	r2,r2,-128
 90984a8:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90984ac:	e03ffe15 	stw	zero,-8(fp)
 90984b0:	00006606 	br	909864c <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
 90984b4:	e0bffe17 	ldw	r2,-8(fp)
 90984b8:	e0ffff17 	ldw	r3,-4(fp)
 90984bc:	108018e4 	muli	r2,r2,99
 90984c0:	10c5883a 	add	r2,r2,r3
 90984c4:	10802404 	addi	r2,r2,144
 90984c8:	10800043 	ldbu	r2,1(r2)
 90984cc:	10803fcc 	andi	r2,r2,255
 90984d0:	1080201c 	xori	r2,r2,128
 90984d4:	10bfe004 	addi	r2,r2,-128
 90984d8:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 90984dc:	e0bffe17 	ldw	r2,-8(fp)
 90984e0:	e0ffff17 	ldw	r3,-4(fp)
 90984e4:	108018e4 	muli	r2,r2,99
 90984e8:	10c5883a 	add	r2,r2,r3
 90984ec:	10802404 	addi	r2,r2,144
 90984f0:	10800083 	ldbu	r2,2(r2)
 90984f4:	10c03fcc 	andi	r3,r2,255
 90984f8:	e0bffc17 	ldw	r2,-16(fp)
 90984fc:	1885383a 	mul	r2,r3,r2
 9098500:	1005d23a 	srai	r2,r2,8
 9098504:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 9098508:	e0fffa17 	ldw	r3,-24(fp)
 909850c:	e0bffb17 	ldw	r2,-20(fp)
 9098510:	18800116 	blt	r3,r2,9098518 <lcd_repaint_screen+0x98>
      offset = 0;
 9098514:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9098518:	e03ffd15 	stw	zero,-12(fp)
 909851c:	00004506 	br	9098634 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
 9098520:	e17ffe17 	ldw	r5,-8(fp)
 9098524:	e0fffd17 	ldw	r3,-12(fp)
 9098528:	e0bffa17 	ldw	r2,-24(fp)
 909852c:	1889883a 	add	r4,r3,r2
 9098530:	e0bffb17 	ldw	r2,-20(fp)
 9098534:	2087283a 	div	r3,r4,r2
 9098538:	e0bffb17 	ldw	r2,-20(fp)
 909853c:	1885383a 	mul	r2,r3,r2
 9098540:	2089c83a 	sub	r4,r4,r2
 9098544:	e0ffff17 	ldw	r3,-4(fp)
 9098548:	288018e4 	muli	r2,r5,99
 909854c:	10c5883a 	add	r2,r2,r3
 9098550:	1105883a 	add	r2,r2,r4
 9098554:	10801004 	addi	r2,r2,64
 9098558:	10800003 	ldbu	r2,0(r2)
 909855c:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 9098560:	e0bffe17 	ldw	r2,-8(fp)
 9098564:	e13ffd17 	ldw	r4,-12(fp)
 9098568:	e0ffff17 	ldw	r3,-4(fp)
 909856c:	108018e4 	muli	r2,r2,99
 9098570:	10c5883a 	add	r2,r2,r3
 9098574:	1105883a 	add	r2,r2,r4
 9098578:	10800c04 	addi	r2,r2,48
 909857c:	10800003 	ldbu	r2,0(r2)
 9098580:	10c03fcc 	andi	r3,r2,255
 9098584:	18c0201c 	xori	r3,r3,128
 9098588:	18ffe004 	addi	r3,r3,-128
 909858c:	e0bff947 	ldb	r2,-27(fp)
 9098590:	18802526 	beq	r3,r2,9098628 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
 9098594:	e0fffe17 	ldw	r3,-8(fp)
 9098598:	d0a02804 	addi	r2,gp,-32608
 909859c:	1885883a 	add	r2,r3,r2
 90985a0:	10800003 	ldbu	r2,0(r2)
 90985a4:	1007883a 	mov	r3,r2
 90985a8:	e0bffd17 	ldw	r2,-12(fp)
 90985ac:	1885883a 	add	r2,r3,r2
 90985b0:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 90985b4:	e0fff903 	ldbu	r3,-28(fp)
 90985b8:	e0bfff17 	ldw	r2,-4(fp)
 90985bc:	108008c3 	ldbu	r2,35(r2)
 90985c0:	10803fcc 	andi	r2,r2,255
 90985c4:	1080201c 	xori	r2,r2,128
 90985c8:	10bfe004 	addi	r2,r2,-128
 90985cc:	18800926 	beq	r3,r2,90985f4 <lcd_repaint_screen+0x174>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 90985d0:	e0fff903 	ldbu	r3,-28(fp)
 90985d4:	00bfe004 	movi	r2,-128
 90985d8:	1884b03a 	or	r2,r3,r2
 90985dc:	11403fcc 	andi	r5,r2,255
 90985e0:	e13fff17 	ldw	r4,-4(fp)
 90985e4:	90982300 	call	9098230 <lcd_write_command>
          sp->address = address;
 90985e8:	e0fff903 	ldbu	r3,-28(fp)
 90985ec:	e0bfff17 	ldw	r2,-4(fp)
 90985f0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 90985f4:	e0bff943 	ldbu	r2,-27(fp)
 90985f8:	11403fcc 	andi	r5,r2,255
 90985fc:	e13fff17 	ldw	r4,-4(fp)
 9098600:	90982e80 	call	90982e8 <lcd_write_data>
        sp->line[y].visible[x] = c;
 9098604:	e0bffe17 	ldw	r2,-8(fp)
 9098608:	e13ffd17 	ldw	r4,-12(fp)
 909860c:	e0ffff17 	ldw	r3,-4(fp)
 9098610:	108018e4 	muli	r2,r2,99
 9098614:	10c5883a 	add	r2,r2,r3
 9098618:	1105883a 	add	r2,r2,r4
 909861c:	10c00c04 	addi	r3,r2,48
 9098620:	e0bff943 	ldbu	r2,-27(fp)
 9098624:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9098628:	e0bffd17 	ldw	r2,-12(fp)
 909862c:	10800044 	addi	r2,r2,1
 9098630:	e0bffd15 	stw	r2,-12(fp)
 9098634:	e0bffd17 	ldw	r2,-12(fp)
 9098638:	10800410 	cmplti	r2,r2,16
 909863c:	103fb81e 	bne	r2,zero,9098520 <lcd_repaint_screen+0xa0>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098640:	e0bffe17 	ldw	r2,-8(fp)
 9098644:	10800044 	addi	r2,r2,1
 9098648:	e0bffe15 	stw	r2,-8(fp)
 909864c:	e0bffe17 	ldw	r2,-8(fp)
 9098650:	10800090 	cmplti	r2,r2,2
 9098654:	103f971e 	bne	r2,zero,90984b4 <lcd_repaint_screen+0x34>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 9098658:	e037883a 	mov	sp,fp
 909865c:	dfc00117 	ldw	ra,4(sp)
 9098660:	df000017 	ldw	fp,0(sp)
 9098664:	dec00204 	addi	sp,sp,8
 9098668:	f800283a 	ret

0909866c <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 909866c:	defffc04 	addi	sp,sp,-16
 9098670:	dfc00315 	stw	ra,12(sp)
 9098674:	df000215 	stw	fp,8(sp)
 9098678:	df000204 	addi	fp,sp,8
 909867c:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098680:	e03ffe15 	stw	zero,-8(fp)
 9098684:	00001d06 	br	90986fc <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 9098688:	e0bffe17 	ldw	r2,-8(fp)
 909868c:	10800048 	cmpgei	r2,r2,1
 9098690:	10000f1e 	bne	r2,zero,90986d0 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 9098694:	e0bffe17 	ldw	r2,-8(fp)
 9098698:	108018e4 	muli	r2,r2,99
 909869c:	10c01004 	addi	r3,r2,64
 90986a0:	e0bfff17 	ldw	r2,-4(fp)
 90986a4:	1889883a 	add	r4,r3,r2
 90986a8:	e0bffe17 	ldw	r2,-8(fp)
 90986ac:	10800044 	addi	r2,r2,1
 90986b0:	108018e4 	muli	r2,r2,99
 90986b4:	10c01004 	addi	r3,r2,64
 90986b8:	e0bfff17 	ldw	r2,-4(fp)
 90986bc:	1885883a 	add	r2,r3,r2
 90986c0:	100b883a 	mov	r5,r2
 90986c4:	01801404 	movi	r6,80
 90986c8:	90822780 	call	9082278 <memcpy>
 90986cc:	00000806 	br	90986f0 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 90986d0:	e0bffe17 	ldw	r2,-8(fp)
 90986d4:	108018e4 	muli	r2,r2,99
 90986d8:	10c01004 	addi	r3,r2,64
 90986dc:	e0bfff17 	ldw	r2,-4(fp)
 90986e0:	1889883a 	add	r4,r3,r2
 90986e4:	01400804 	movi	r5,32
 90986e8:	01801404 	movi	r6,80
 90986ec:	90823f80 	call	90823f8 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90986f0:	e0bffe17 	ldw	r2,-8(fp)
 90986f4:	10800044 	addi	r2,r2,1
 90986f8:	e0bffe15 	stw	r2,-8(fp)
 90986fc:	e0bffe17 	ldw	r2,-8(fp)
 9098700:	10800090 	cmplti	r2,r2,2
 9098704:	103fe01e 	bne	r2,zero,9098688 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 9098708:	e0bfff17 	ldw	r2,-4(fp)
 909870c:	10800883 	ldbu	r2,34(r2)
 9098710:	10bfffc4 	addi	r2,r2,-1
 9098714:	1007883a 	mov	r3,r2
 9098718:	e0bfff17 	ldw	r2,-4(fp)
 909871c:	10c00885 	stb	r3,34(r2)
}
 9098720:	e037883a 	mov	sp,fp
 9098724:	dfc00117 	ldw	ra,4(sp)
 9098728:	df000017 	ldw	fp,0(sp)
 909872c:	dec00204 	addi	sp,sp,8
 9098730:	f800283a 	ret

09098734 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 9098734:	defff804 	addi	sp,sp,-32
 9098738:	dfc00715 	stw	ra,28(sp)
 909873c:	df000615 	stw	fp,24(sp)
 9098740:	df000604 	addi	fp,sp,24
 9098744:	e13ffd15 	stw	r4,-12(fp)
 9098748:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 909874c:	e03ffc15 	stw	zero,-16(fp)
 9098750:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 9098754:	e0bffd17 	ldw	r2,-12(fp)
 9098758:	10800a03 	ldbu	r2,40(r2)
 909875c:	10803fcc 	andi	r2,r2,255
 9098760:	1080201c 	xori	r2,r2,128
 9098764:	10bfe004 	addi	r2,r2,-128
 9098768:	108016d8 	cmpnei	r2,r2,91
 909876c:	1000491e 	bne	r2,zero,9098894 <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 9098770:	e0bffd17 	ldw	r2,-12(fp)
 9098774:	10800a04 	addi	r2,r2,40
 9098778:	10800044 	addi	r2,r2,1
 909877c:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 9098780:	00000d06 	br	90987b8 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 9098784:	e0bffc17 	ldw	r2,-16(fp)
 9098788:	10c002a4 	muli	r3,r2,10
 909878c:	e0bffa17 	ldw	r2,-24(fp)
 9098790:	10800003 	ldbu	r2,0(r2)
 9098794:	10803fcc 	andi	r2,r2,255
 9098798:	1080201c 	xori	r2,r2,128
 909879c:	10bfe004 	addi	r2,r2,-128
 90987a0:	1885883a 	add	r2,r3,r2
 90987a4:	10bff404 	addi	r2,r2,-48
 90987a8:	e0bffc15 	stw	r2,-16(fp)
 90987ac:	e0bffa17 	ldw	r2,-24(fp)
 90987b0:	10800044 	addi	r2,r2,1
 90987b4:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 90987b8:	e0bffa17 	ldw	r2,-24(fp)
 90987bc:	10800003 	ldbu	r2,0(r2)
 90987c0:	10803fcc 	andi	r2,r2,255
 90987c4:	1080201c 	xori	r2,r2,128
 90987c8:	10bfe004 	addi	r2,r2,-128
 90987cc:	1007883a 	mov	r3,r2
 90987d0:	00824374 	movhi	r2,2317
 90987d4:	108b9a04 	addi	r2,r2,11880
 90987d8:	10800017 	ldw	r2,0(r2)
 90987dc:	1885883a 	add	r2,r3,r2
 90987e0:	10800003 	ldbu	r2,0(r2)
 90987e4:	10803fcc 	andi	r2,r2,255
 90987e8:	1080010c 	andi	r2,r2,4
 90987ec:	1004c03a 	cmpne	r2,r2,zero
 90987f0:	103fe41e 	bne	r2,zero,9098784 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 90987f4:	e0bffa17 	ldw	r2,-24(fp)
 90987f8:	10800003 	ldbu	r2,0(r2)
 90987fc:	10803fcc 	andi	r2,r2,255
 9098800:	1080201c 	xori	r2,r2,128
 9098804:	10bfe004 	addi	r2,r2,-128
 9098808:	10800ed8 	cmpnei	r2,r2,59
 909880c:	1000231e 	bne	r2,zero,909889c <lcd_handle_escape+0x168>
    {
      ptr++;
 9098810:	e0bffa17 	ldw	r2,-24(fp)
 9098814:	10800044 	addi	r2,r2,1
 9098818:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 909881c:	00000d06 	br	9098854 <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 9098820:	e0bffb17 	ldw	r2,-20(fp)
 9098824:	10c002a4 	muli	r3,r2,10
 9098828:	e0bffa17 	ldw	r2,-24(fp)
 909882c:	10800003 	ldbu	r2,0(r2)
 9098830:	10803fcc 	andi	r2,r2,255
 9098834:	1080201c 	xori	r2,r2,128
 9098838:	10bfe004 	addi	r2,r2,-128
 909883c:	1885883a 	add	r2,r3,r2
 9098840:	10bff404 	addi	r2,r2,-48
 9098844:	e0bffb15 	stw	r2,-20(fp)
 9098848:	e0bffa17 	ldw	r2,-24(fp)
 909884c:	10800044 	addi	r2,r2,1
 9098850:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 9098854:	e0bffa17 	ldw	r2,-24(fp)
 9098858:	10800003 	ldbu	r2,0(r2)
 909885c:	10803fcc 	andi	r2,r2,255
 9098860:	1080201c 	xori	r2,r2,128
 9098864:	10bfe004 	addi	r2,r2,-128
 9098868:	1007883a 	mov	r3,r2
 909886c:	00824374 	movhi	r2,2317
 9098870:	108b9a04 	addi	r2,r2,11880
 9098874:	10800017 	ldw	r2,0(r2)
 9098878:	1885883a 	add	r2,r3,r2
 909887c:	10800003 	ldbu	r2,0(r2)
 9098880:	10803fcc 	andi	r2,r2,255
 9098884:	1080010c 	andi	r2,r2,4
 9098888:	1004c03a 	cmpne	r2,r2,zero
 909888c:	103fe41e 	bne	r2,zero,9098820 <lcd_handle_escape+0xec>
 9098890:	00000206 	br	909889c <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 9098894:	00bfffc4 	movi	r2,-1
 9098898:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 909889c:	e0bffe07 	ldb	r2,-8(fp)
 90988a0:	e0bfff15 	stw	r2,-4(fp)
 90988a4:	e0ffff17 	ldw	r3,-4(fp)
 90988a8:	188012a0 	cmpeqi	r2,r3,74
 90988ac:	10002f1e 	bne	r2,zero,909896c <lcd_handle_escape+0x238>
 90988b0:	e0ffff17 	ldw	r3,-4(fp)
 90988b4:	188012c8 	cmpgei	r2,r3,75
 90988b8:	1000041e 	bne	r2,zero,90988cc <lcd_handle_escape+0x198>
 90988bc:	e0ffff17 	ldw	r3,-4(fp)
 90988c0:	18801220 	cmpeqi	r2,r3,72
 90988c4:	1000081e 	bne	r2,zero,90988e8 <lcd_handle_escape+0x1b4>
 90988c8:	00004906 	br	90989f0 <lcd_handle_escape+0x2bc>
 90988cc:	e0ffff17 	ldw	r3,-4(fp)
 90988d0:	188012e0 	cmpeqi	r2,r3,75
 90988d4:	10002b1e 	bne	r2,zero,9098984 <lcd_handle_escape+0x250>
 90988d8:	e0ffff17 	ldw	r3,-4(fp)
 90988dc:	188019a0 	cmpeqi	r2,r3,102
 90988e0:	1000011e 	bne	r2,zero,90988e8 <lcd_handle_escape+0x1b4>
 90988e4:	00004206 	br	90989f0 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 90988e8:	e0bffb17 	ldw	r2,-20(fp)
 90988ec:	10800050 	cmplti	r2,r2,1
 90988f0:	1000051e 	bne	r2,zero,9098908 <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 90988f4:	e0bffb17 	ldw	r2,-20(fp)
 90988f8:	10bfffc4 	addi	r2,r2,-1
 90988fc:	1007883a 	mov	r3,r2
 9098900:	e0bffd17 	ldw	r2,-12(fp)
 9098904:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 9098908:	e0bffc17 	ldw	r2,-16(fp)
 909890c:	10800050 	cmplti	r2,r2,1
 9098910:	1000371e 	bne	r2,zero,90989f0 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 9098914:	e0bffc17 	ldw	r2,-16(fp)
 9098918:	10bfffc4 	addi	r2,r2,-1
 909891c:	1007883a 	mov	r3,r2
 9098920:	e0bffd17 	ldw	r2,-12(fp)
 9098924:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 9098928:	e0bffd17 	ldw	r2,-12(fp)
 909892c:	10800883 	ldbu	r2,34(r2)
 9098930:	10803fcc 	andi	r2,r2,255
 9098934:	10800170 	cmpltui	r2,r2,5
 9098938:	1000061e 	bne	r2,zero,9098954 <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 909893c:	e0fffd17 	ldw	r3,-12(fp)
 9098940:	00800104 	movi	r2,4
 9098944:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 9098948:	00000206 	br	9098954 <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 909894c:	e13ffd17 	ldw	r4,-12(fp)
 9098950:	909866c0 	call	909866c <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 9098954:	e0bffd17 	ldw	r2,-12(fp)
 9098958:	10800883 	ldbu	r2,34(r2)
 909895c:	10803fcc 	andi	r2,r2,255
 9098960:	108000e8 	cmpgeui	r2,r2,3
 9098964:	103ff91e 	bne	r2,zero,909894c <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 9098968:	00002106 	br	90989f0 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 909896c:	e0bffc17 	ldw	r2,-16(fp)
 9098970:	10800098 	cmpnei	r2,r2,2
 9098974:	10001e1e 	bne	r2,zero,90989f0 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 9098978:	e13ffd17 	ldw	r4,-12(fp)
 909897c:	90983bc0 	call	90983bc <lcd_clear_screen>
    break;
 9098980:	00001b06 	br	90989f0 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 9098984:	e0bffc17 	ldw	r2,-16(fp)
 9098988:	10800048 	cmpgei	r2,r2,1
 909898c:	1000181e 	bne	r2,zero,90989f0 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9098990:	e0bffd17 	ldw	r2,-12(fp)
 9098994:	10800843 	ldbu	r2,33(r2)
 9098998:	10803fcc 	andi	r2,r2,255
 909899c:	10801428 	cmpgeui	r2,r2,80
 90989a0:	1000131e 	bne	r2,zero,90989f0 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 90989a4:	e0bffd17 	ldw	r2,-12(fp)
 90989a8:	10800883 	ldbu	r2,34(r2)
 90989ac:	10803fcc 	andi	r2,r2,255
 90989b0:	108018e4 	muli	r2,r2,99
 90989b4:	10c01004 	addi	r3,r2,64
 90989b8:	e0bffd17 	ldw	r2,-12(fp)
 90989bc:	1887883a 	add	r3,r3,r2
 90989c0:	e0bffd17 	ldw	r2,-12(fp)
 90989c4:	10800843 	ldbu	r2,33(r2)
 90989c8:	10803fcc 	andi	r2,r2,255
 90989cc:	1889883a 	add	r4,r3,r2
 90989d0:	e0bffd17 	ldw	r2,-12(fp)
 90989d4:	10800843 	ldbu	r2,33(r2)
 90989d8:	10c03fcc 	andi	r3,r2,255
 90989dc:	00801404 	movi	r2,80
 90989e0:	10c5c83a 	sub	r2,r2,r3
 90989e4:	100d883a 	mov	r6,r2
 90989e8:	01400804 	movi	r5,32
 90989ec:	90823f80 	call	90823f8 <memset>
    }
    break;
  }
}
 90989f0:	e037883a 	mov	sp,fp
 90989f4:	dfc00117 	ldw	ra,4(sp)
 90989f8:	df000017 	ldw	fp,0(sp)
 90989fc:	dec00204 	addi	sp,sp,8
 9098a00:	f800283a 	ret

09098a04 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 9098a04:	defff004 	addi	sp,sp,-64
 9098a08:	dfc00f15 	stw	ra,60(sp)
 9098a0c:	df000e15 	stw	fp,56(sp)
 9098a10:	df000e04 	addi	fp,sp,56
 9098a14:	e13ffc15 	stw	r4,-16(fp)
 9098a18:	e17ffd15 	stw	r5,-12(fp)
 9098a1c:	e1bffe15 	stw	r6,-8(fp)
 9098a20:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 9098a24:	e0bffe17 	ldw	r2,-8(fp)
 9098a28:	1007883a 	mov	r3,r2
 9098a2c:	e0bffd17 	ldw	r2,-12(fp)
 9098a30:	10c5883a 	add	r2,r2,r3
 9098a34:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 9098a38:	e0bffc17 	ldw	r2,-16(fp)
 9098a3c:	10803e17 	ldw	r2,248(r2)
 9098a40:	e0bff215 	stw	r2,-56(fp)
 9098a44:	e03ff30d 	sth	zero,-52(fp)
 9098a48:	e17ff30b 	ldhu	r5,-52(fp)
 9098a4c:	e1bffb04 	addi	r6,fp,-20
 9098a50:	e13ff217 	ldw	r4,-56(fp)
 9098a54:	9092c6c0 	call	9092c6c <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 9098a58:	e0fffc17 	ldw	r3,-16(fp)
 9098a5c:	00800044 	movi	r2,1
 9098a60:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 9098a64:	0000a206 	br	9098cf0 <altera_avalon_lcd_16207_write+0x2ec>
  {
    char c = *ptr;
 9098a68:	e0bffd17 	ldw	r2,-12(fp)
 9098a6c:	10800003 	ldbu	r2,0(r2)
 9098a70:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 9098a74:	e0bffc17 	ldw	r2,-16(fp)
 9098a78:	10800903 	ldbu	r2,36(r2)
 9098a7c:	10803fcc 	andi	r2,r2,255
 9098a80:	1080201c 	xori	r2,r2,128
 9098a84:	10bfe004 	addi	r2,r2,-128
 9098a88:	1004803a 	cmplt	r2,r2,zero
 9098a8c:	10003b1e 	bne	r2,zero,9098b7c <altera_avalon_lcd_16207_write+0x178>
    {
      unsigned int esccount = sp->esccount;
 9098a90:	e0bffc17 	ldw	r2,-16(fp)
 9098a94:	10800903 	ldbu	r2,36(r2)
 9098a98:	10803fcc 	andi	r2,r2,255
 9098a9c:	1080201c 	xori	r2,r2,128
 9098aa0:	10bfe004 	addi	r2,r2,-128
 9098aa4:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9098aa8:	e0bff617 	ldw	r2,-40(fp)
 9098aac:	1004c03a 	cmpne	r2,r2,zero
 9098ab0:	1000031e 	bne	r2,zero,9098ac0 <altera_avalon_lcd_16207_write+0xbc>
 9098ab4:	e0bff707 	ldb	r2,-36(fp)
 9098ab8:	108016d8 	cmpnei	r2,r2,91
 9098abc:	1000111e 	bne	r2,zero,9098b04 <altera_avalon_lcd_16207_write+0x100>
 9098ac0:	e0bff617 	ldw	r2,-40(fp)
 9098ac4:	1005003a 	cmpeq	r2,r2,zero
 9098ac8:	10001a1e 	bne	r2,zero,9098b34 <altera_avalon_lcd_16207_write+0x130>
 9098acc:	e0bff707 	ldb	r2,-36(fp)
 9098ad0:	1007883a 	mov	r3,r2
 9098ad4:	00824374 	movhi	r2,2317
 9098ad8:	108b9a04 	addi	r2,r2,11880
 9098adc:	10800017 	ldw	r2,0(r2)
 9098ae0:	1885883a 	add	r2,r3,r2
 9098ae4:	10800003 	ldbu	r2,0(r2)
 9098ae8:	10803fcc 	andi	r2,r2,255
 9098aec:	1080010c 	andi	r2,r2,4
 9098af0:	1004c03a 	cmpne	r2,r2,zero
 9098af4:	10000f1e 	bne	r2,zero,9098b34 <altera_avalon_lcd_16207_write+0x130>
 9098af8:	e0bff707 	ldb	r2,-36(fp)
 9098afc:	10800ee0 	cmpeqi	r2,r2,59
 9098b00:	10000c1e 	bne	r2,zero,9098b34 <altera_avalon_lcd_16207_write+0x130>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 9098b04:	e0fff617 	ldw	r3,-40(fp)
 9098b08:	e0bffc17 	ldw	r2,-16(fp)
 9098b0c:	1885883a 	add	r2,r3,r2
 9098b10:	10800a04 	addi	r2,r2,40
 9098b14:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 9098b18:	e17ff707 	ldb	r5,-36(fp)
 9098b1c:	e13ffc17 	ldw	r4,-16(fp)
 9098b20:	90987340 	call	9098734 <lcd_handle_escape>

        sp->esccount = -1;
 9098b24:	e0fffc17 	ldw	r3,-16(fp)
 9098b28:	00bfffc4 	movi	r2,-1
 9098b2c:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9098b30:	00006c06 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 9098b34:	e0bffc17 	ldw	r2,-16(fp)
 9098b38:	10800903 	ldbu	r2,36(r2)
 9098b3c:	10803fcc 	andi	r2,r2,255
 9098b40:	108001e8 	cmpgeui	r2,r2,7
 9098b44:	1000671e 	bne	r2,zero,9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
      {
        sp->escape[esccount] = c;
 9098b48:	e0fff617 	ldw	r3,-40(fp)
 9098b4c:	e0bffc17 	ldw	r2,-16(fp)
 9098b50:	1885883a 	add	r2,r3,r2
 9098b54:	10c00a04 	addi	r3,r2,40
 9098b58:	e0bff703 	ldbu	r2,-36(fp)
 9098b5c:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 9098b60:	e0bffc17 	ldw	r2,-16(fp)
 9098b64:	10800903 	ldbu	r2,36(r2)
 9098b68:	10800044 	addi	r2,r2,1
 9098b6c:	1007883a 	mov	r3,r2
 9098b70:	e0bffc17 	ldw	r2,-16(fp)
 9098b74:	10c00905 	stb	r3,36(r2)
 9098b78:	00005a06 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
      }
    }
    else if (c == 27) /* ESC */
 9098b7c:	e0bff707 	ldb	r2,-36(fp)
 9098b80:	108006d8 	cmpnei	r2,r2,27
 9098b84:	1000031e 	bne	r2,zero,9098b94 <altera_avalon_lcd_16207_write+0x190>
    {
      sp->esccount = 0;
 9098b88:	e0bffc17 	ldw	r2,-16(fp)
 9098b8c:	10000905 	stb	zero,36(r2)
 9098b90:	00005406 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\r')
 9098b94:	e0bff707 	ldb	r2,-36(fp)
 9098b98:	10800358 	cmpnei	r2,r2,13
 9098b9c:	1000031e 	bne	r2,zero,9098bac <altera_avalon_lcd_16207_write+0x1a8>
    {
      sp->x = 0;
 9098ba0:	e0bffc17 	ldw	r2,-16(fp)
 9098ba4:	10000845 	stb	zero,33(r2)
 9098ba8:	00004e06 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\n')
 9098bac:	e0bff707 	ldb	r2,-36(fp)
 9098bb0:	10800298 	cmpnei	r2,r2,10
 9098bb4:	1000101e 	bne	r2,zero,9098bf8 <altera_avalon_lcd_16207_write+0x1f4>
    {
      sp->x = 0;
 9098bb8:	e0bffc17 	ldw	r2,-16(fp)
 9098bbc:	10000845 	stb	zero,33(r2)
      sp->y++;
 9098bc0:	e0bffc17 	ldw	r2,-16(fp)
 9098bc4:	10800883 	ldbu	r2,34(r2)
 9098bc8:	10800044 	addi	r2,r2,1
 9098bcc:	1007883a 	mov	r3,r2
 9098bd0:	e0bffc17 	ldw	r2,-16(fp)
 9098bd4:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 9098bd8:	e0bffc17 	ldw	r2,-16(fp)
 9098bdc:	10800883 	ldbu	r2,34(r2)
 9098be0:	10803fcc 	andi	r2,r2,255
 9098be4:	108000f0 	cmpltui	r2,r2,3
 9098be8:	10003e1e 	bne	r2,zero,9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
        lcd_scroll_up(sp);
 9098bec:	e13ffc17 	ldw	r4,-16(fp)
 9098bf0:	909866c0 	call	909866c <lcd_scroll_up>
 9098bf4:	00003b06 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\b')
 9098bf8:	e0bff707 	ldb	r2,-36(fp)
 9098bfc:	10800218 	cmpnei	r2,r2,8
 9098c00:	10000c1e 	bne	r2,zero,9098c34 <altera_avalon_lcd_16207_write+0x230>
    {
      if (sp->x > 0)
 9098c04:	e0bffc17 	ldw	r2,-16(fp)
 9098c08:	10800843 	ldbu	r2,33(r2)
 9098c0c:	10803fcc 	andi	r2,r2,255
 9098c10:	1005003a 	cmpeq	r2,r2,zero
 9098c14:	1000331e 	bne	r2,zero,9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
        sp->x--;
 9098c18:	e0bffc17 	ldw	r2,-16(fp)
 9098c1c:	10800843 	ldbu	r2,33(r2)
 9098c20:	10bfffc4 	addi	r2,r2,-1
 9098c24:	1007883a 	mov	r3,r2
 9098c28:	e0bffc17 	ldw	r2,-16(fp)
 9098c2c:	10c00845 	stb	r3,33(r2)
 9098c30:	00002c06 	br	9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (isprint(c))
 9098c34:	e0bff707 	ldb	r2,-36(fp)
 9098c38:	1007883a 	mov	r3,r2
 9098c3c:	00824374 	movhi	r2,2317
 9098c40:	108b9a04 	addi	r2,r2,11880
 9098c44:	10800017 	ldw	r2,0(r2)
 9098c48:	1885883a 	add	r2,r3,r2
 9098c4c:	10800003 	ldbu	r2,0(r2)
 9098c50:	10803fcc 	andi	r2,r2,255
 9098c54:	1080201c 	xori	r2,r2,128
 9098c58:	10bfe004 	addi	r2,r2,-128
 9098c5c:	108025cc 	andi	r2,r2,151
 9098c60:	1005003a 	cmpeq	r2,r2,zero
 9098c64:	10001f1e 	bne	r2,zero,9098ce4 <altera_avalon_lcd_16207_write+0x2e0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 9098c68:	e0bffc17 	ldw	r2,-16(fp)
 9098c6c:	10800883 	ldbu	r2,34(r2)
 9098c70:	10803fcc 	andi	r2,r2,255
 9098c74:	108000b0 	cmpltui	r2,r2,2
 9098c78:	1000021e 	bne	r2,zero,9098c84 <altera_avalon_lcd_16207_write+0x280>
        lcd_scroll_up(sp);
 9098c7c:	e13ffc17 	ldw	r4,-16(fp)
 9098c80:	909866c0 	call	909866c <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9098c84:	e0bffc17 	ldw	r2,-16(fp)
 9098c88:	10800843 	ldbu	r2,33(r2)
 9098c8c:	10803fcc 	andi	r2,r2,255
 9098c90:	10801428 	cmpgeui	r2,r2,80
 9098c94:	10000d1e 	bne	r2,zero,9098ccc <altera_avalon_lcd_16207_write+0x2c8>
        sp->line[sp->y].data[sp->x] = c;
 9098c98:	e0bffc17 	ldw	r2,-16(fp)
 9098c9c:	10800883 	ldbu	r2,34(r2)
 9098ca0:	11003fcc 	andi	r4,r2,255
 9098ca4:	e0bffc17 	ldw	r2,-16(fp)
 9098ca8:	10800843 	ldbu	r2,33(r2)
 9098cac:	11403fcc 	andi	r5,r2,255
 9098cb0:	e0fffc17 	ldw	r3,-16(fp)
 9098cb4:	208018e4 	muli	r2,r4,99
 9098cb8:	10c5883a 	add	r2,r2,r3
 9098cbc:	1145883a 	add	r2,r2,r5
 9098cc0:	10c01004 	addi	r3,r2,64
 9098cc4:	e0bff703 	ldbu	r2,-36(fp)
 9098cc8:	18800005 	stb	r2,0(r3)

      sp->x++;
 9098ccc:	e0bffc17 	ldw	r2,-16(fp)
 9098cd0:	10800843 	ldbu	r2,33(r2)
 9098cd4:	10800044 	addi	r2,r2,1
 9098cd8:	1007883a 	mov	r3,r2
 9098cdc:	e0bffc17 	ldw	r2,-16(fp)
 9098ce0:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 9098ce4:	e0bffd17 	ldw	r2,-12(fp)
 9098ce8:	10800044 	addi	r2,r2,1
 9098cec:	e0bffd15 	stw	r2,-12(fp)
 9098cf0:	e0fffd17 	ldw	r3,-12(fp)
 9098cf4:	e0bffa17 	ldw	r2,-24(fp)
 9098cf8:	18bf5b36 	bltu	r3,r2,9098a68 <altera_avalon_lcd_16207_write+0x64>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 9098cfc:	00800404 	movi	r2,16
 9098d00:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098d04:	e03ff915 	stw	zero,-28(fp)
 9098d08:	00003606 	br	9098de4 <altera_avalon_lcd_16207_write+0x3e0>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 9098d0c:	00801404 	movi	r2,80
 9098d10:	e0bff515 	stw	r2,-44(fp)
 9098d14:	00001106 	br	9098d5c <altera_avalon_lcd_16207_write+0x358>
      if (sp->line[y].data[width-1] != ' ')
 9098d18:	e13ff917 	ldw	r4,-28(fp)
 9098d1c:	e0bff517 	ldw	r2,-44(fp)
 9098d20:	117fffc4 	addi	r5,r2,-1
 9098d24:	e0fffc17 	ldw	r3,-16(fp)
 9098d28:	208018e4 	muli	r2,r4,99
 9098d2c:	10c5883a 	add	r2,r2,r3
 9098d30:	1145883a 	add	r2,r2,r5
 9098d34:	10801004 	addi	r2,r2,64
 9098d38:	10800003 	ldbu	r2,0(r2)
 9098d3c:	10803fcc 	andi	r2,r2,255
 9098d40:	1080201c 	xori	r2,r2,128
 9098d44:	10bfe004 	addi	r2,r2,-128
 9098d48:	10800818 	cmpnei	r2,r2,32
 9098d4c:	1000061e 	bne	r2,zero,9098d68 <altera_avalon_lcd_16207_write+0x364>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 9098d50:	e0bff517 	ldw	r2,-44(fp)
 9098d54:	10bfffc4 	addi	r2,r2,-1
 9098d58:	e0bff515 	stw	r2,-44(fp)
 9098d5c:	e0bff517 	ldw	r2,-44(fp)
 9098d60:	10800048 	cmpgei	r2,r2,1
 9098d64:	103fec1e 	bne	r2,zero,9098d18 <altera_avalon_lcd_16207_write+0x314>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 9098d68:	e0bff517 	ldw	r2,-44(fp)
 9098d6c:	10800448 	cmpgei	r2,r2,17
 9098d70:	1000031e 	bne	r2,zero,9098d80 <altera_avalon_lcd_16207_write+0x37c>
      width = ALT_LCD_WIDTH;
 9098d74:	00800404 	movi	r2,16
 9098d78:	e0bff515 	stw	r2,-44(fp)
 9098d7c:	00000306 	br	9098d8c <altera_avalon_lcd_16207_write+0x388>
    else
      width++;
 9098d80:	e0bff517 	ldw	r2,-44(fp)
 9098d84:	10800044 	addi	r2,r2,1
 9098d88:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 9098d8c:	e13ff917 	ldw	r4,-28(fp)
 9098d90:	e0bff517 	ldw	r2,-44(fp)
 9098d94:	100b883a 	mov	r5,r2
 9098d98:	e0fffc17 	ldw	r3,-16(fp)
 9098d9c:	208018e4 	muli	r2,r4,99
 9098da0:	10c5883a 	add	r2,r2,r3
 9098da4:	10802404 	addi	r2,r2,144
 9098da8:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 9098dac:	e0fff817 	ldw	r3,-32(fp)
 9098db0:	e0bff517 	ldw	r2,-44(fp)
 9098db4:	1880020e 	bge	r3,r2,9098dc0 <altera_avalon_lcd_16207_write+0x3bc>
      widthmax = width;
 9098db8:	e0bff517 	ldw	r2,-44(fp)
 9098dbc:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 9098dc0:	e0bff917 	ldw	r2,-28(fp)
 9098dc4:	e0fffc17 	ldw	r3,-16(fp)
 9098dc8:	108018e4 	muli	r2,r2,99
 9098dcc:	10c5883a 	add	r2,r2,r3
 9098dd0:	10802404 	addi	r2,r2,144
 9098dd4:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098dd8:	e0bff917 	ldw	r2,-28(fp)
 9098ddc:	10800044 	addi	r2,r2,1
 9098de0:	e0bff915 	stw	r2,-28(fp)
 9098de4:	e0bff917 	ldw	r2,-28(fp)
 9098de8:	10800090 	cmplti	r2,r2,2
 9098dec:	103fc71e 	bne	r2,zero,9098d0c <altera_avalon_lcd_16207_write+0x308>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 9098df0:	e0bff817 	ldw	r2,-32(fp)
 9098df4:	10800448 	cmpgei	r2,r2,17
 9098df8:	1000031e 	bne	r2,zero,9098e08 <altera_avalon_lcd_16207_write+0x404>
    sp->scrollmax = 0;
 9098dfc:	e0bffc17 	ldw	r2,-16(fp)
 9098e00:	10000985 	stb	zero,38(r2)
 9098e04:	00002d06 	br	9098ebc <altera_avalon_lcd_16207_write+0x4b8>
  else
  {
    widthmax *= 2;
 9098e08:	e0bff817 	ldw	r2,-32(fp)
 9098e0c:	1085883a 	add	r2,r2,r2
 9098e10:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 9098e14:	e0bff817 	ldw	r2,-32(fp)
 9098e18:	1007883a 	mov	r3,r2
 9098e1c:	e0bffc17 	ldw	r2,-16(fp)
 9098e20:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098e24:	e03ff915 	stw	zero,-28(fp)
 9098e28:	00002106 	br	9098eb0 <altera_avalon_lcd_16207_write+0x4ac>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 9098e2c:	e0bff917 	ldw	r2,-28(fp)
 9098e30:	e0fffc17 	ldw	r3,-16(fp)
 9098e34:	108018e4 	muli	r2,r2,99
 9098e38:	10c5883a 	add	r2,r2,r3
 9098e3c:	10802404 	addi	r2,r2,144
 9098e40:	10800043 	ldbu	r2,1(r2)
 9098e44:	10803fcc 	andi	r2,r2,255
 9098e48:	1080201c 	xori	r2,r2,128
 9098e4c:	10bfe004 	addi	r2,r2,-128
 9098e50:	10800450 	cmplti	r2,r2,17
 9098e54:	1000131e 	bne	r2,zero,9098ea4 <altera_avalon_lcd_16207_write+0x4a0>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 9098e58:	e17ff917 	ldw	r5,-28(fp)
 9098e5c:	e0bff917 	ldw	r2,-28(fp)
 9098e60:	e0fffc17 	ldw	r3,-16(fp)
 9098e64:	108018e4 	muli	r2,r2,99
 9098e68:	10c5883a 	add	r2,r2,r3
 9098e6c:	10802404 	addi	r2,r2,144
 9098e70:	10800043 	ldbu	r2,1(r2)
 9098e74:	10803fcc 	andi	r2,r2,255
 9098e78:	1080201c 	xori	r2,r2,128
 9098e7c:	10bfe004 	addi	r2,r2,-128
 9098e80:	1006923a 	slli	r3,r2,8
 9098e84:	e0bff817 	ldw	r2,-32(fp)
 9098e88:	1885283a 	div	r2,r3,r2
 9098e8c:	1009883a 	mov	r4,r2
 9098e90:	e0fffc17 	ldw	r3,-16(fp)
 9098e94:	288018e4 	muli	r2,r5,99
 9098e98:	10c5883a 	add	r2,r2,r3
 9098e9c:	10802404 	addi	r2,r2,144
 9098ea0:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9098ea4:	e0bff917 	ldw	r2,-28(fp)
 9098ea8:	10800044 	addi	r2,r2,1
 9098eac:	e0bff915 	stw	r2,-28(fp)
 9098eb0:	e0bff917 	ldw	r2,-28(fp)
 9098eb4:	10800090 	cmplti	r2,r2,2
 9098eb8:	103fdc1e 	bne	r2,zero,9098e2c <altera_avalon_lcd_16207_write+0x428>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 9098ebc:	e0bffc17 	ldw	r2,-16(fp)
 9098ec0:	10800943 	ldbu	r2,37(r2)
 9098ec4:	10803fcc 	andi	r2,r2,255
 9098ec8:	1080201c 	xori	r2,r2,128
 9098ecc:	10bfe004 	addi	r2,r2,-128
 9098ed0:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 9098ed4:	e13ffc17 	ldw	r4,-16(fp)
 9098ed8:	90984800 	call	9098480 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 9098edc:	e0bffc17 	ldw	r2,-16(fp)
 9098ee0:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 9098ee4:	e0bffc17 	ldw	r2,-16(fp)
 9098ee8:	10800943 	ldbu	r2,37(r2)
 9098eec:	10c03fcc 	andi	r3,r2,255
 9098ef0:	18c0201c 	xori	r3,r3,128
 9098ef4:	18ffe004 	addi	r3,r3,-128
 9098ef8:	e0bff417 	ldw	r2,-48(fp)
 9098efc:	18800426 	beq	r3,r2,9098f10 <altera_avalon_lcd_16207_write+0x50c>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 9098f00:	e0fffc17 	ldw	r3,-16(fp)
 9098f04:	00800044 	movi	r2,1
 9098f08:	188009c5 	stb	r2,39(r3)
  }
 9098f0c:	003feb06 	br	9098ebc <altera_avalon_lcd_16207_write+0x4b8>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 9098f10:	e0bffc17 	ldw	r2,-16(fp)
 9098f14:	11003e17 	ldw	r4,248(r2)
 9098f18:	90930640 	call	9093064 <OSSemPost>

  return len;
 9098f1c:	e0bffe17 	ldw	r2,-8(fp)
}
 9098f20:	e037883a 	mov	sp,fp
 9098f24:	dfc00117 	ldw	ra,4(sp)
 9098f28:	df000017 	ldw	fp,0(sp)
 9098f2c:	dec00204 	addi	sp,sp,8
 9098f30:	f800283a 	ret

09098f34 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 9098f34:	defffc04 	addi	sp,sp,-16
 9098f38:	dfc00315 	stw	ra,12(sp)
 9098f3c:	df000215 	stw	fp,8(sp)
 9098f40:	df000204 	addi	fp,sp,8
 9098f44:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 9098f48:	e0bfff17 	ldw	r2,-4(fp)
 9098f4c:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 9098f50:	e0bffe17 	ldw	r2,-8(fp)
 9098f54:	10800943 	ldbu	r2,37(r2)
 9098f58:	10803fcc 	andi	r2,r2,255
 9098f5c:	1080201c 	xori	r2,r2,128
 9098f60:	10bfe004 	addi	r2,r2,-128
 9098f64:	10c00044 	addi	r3,r2,1
 9098f68:	e0bffe17 	ldw	r2,-8(fp)
 9098f6c:	10800983 	ldbu	r2,38(r2)
 9098f70:	10803fcc 	andi	r2,r2,255
 9098f74:	1080201c 	xori	r2,r2,128
 9098f78:	10bfe004 	addi	r2,r2,-128
 9098f7c:	18800316 	blt	r3,r2,9098f8c <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 9098f80:	e0bffe17 	ldw	r2,-8(fp)
 9098f84:	10000945 	stb	zero,37(r2)
 9098f88:	00000606 	br	9098fa4 <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 9098f8c:	e0bffe17 	ldw	r2,-8(fp)
 9098f90:	10800943 	ldbu	r2,37(r2)
 9098f94:	10800044 	addi	r2,r2,1
 9098f98:	1007883a 	mov	r3,r2
 9098f9c:	e0bffe17 	ldw	r2,-8(fp)
 9098fa0:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 9098fa4:	e0bffe17 	ldw	r2,-8(fp)
 9098fa8:	10800983 	ldbu	r2,38(r2)
 9098fac:	10803fcc 	andi	r2,r2,255
 9098fb0:	1080201c 	xori	r2,r2,128
 9098fb4:	10bfe004 	addi	r2,r2,-128
 9098fb8:	10800050 	cmplti	r2,r2,1
 9098fbc:	1000091e 	bne	r2,zero,9098fe4 <alt_lcd_16207_timeout+0xb0>
 9098fc0:	e0bffe17 	ldw	r2,-8(fp)
 9098fc4:	108009c3 	ldbu	r2,39(r2)
 9098fc8:	10803fcc 	andi	r2,r2,255
 9098fcc:	1080201c 	xori	r2,r2,128
 9098fd0:	10bfe004 	addi	r2,r2,-128
 9098fd4:	1004c03a 	cmpne	r2,r2,zero
 9098fd8:	1000021e 	bne	r2,zero,9098fe4 <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 9098fdc:	e13ffe17 	ldw	r4,-8(fp)
 9098fe0:	90984800 	call	9098480 <lcd_repaint_screen>

  return sp->period;
 9098fe4:	e0bffe17 	ldw	r2,-8(fp)
 9098fe8:	10800717 	ldw	r2,28(r2)
}
 9098fec:	e037883a 	mov	sp,fp
 9098ff0:	dfc00117 	ldw	ra,4(sp)
 9098ff4:	df000017 	ldw	fp,0(sp)
 9098ff8:	dec00204 	addi	sp,sp,8
 9098ffc:	f800283a 	ret

09099000 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 9099000:	defff804 	addi	sp,sp,-32
 9099004:	dfc00715 	stw	ra,28(sp)
 9099008:	df000615 	stw	fp,24(sp)
 909900c:	df000604 	addi	fp,sp,24
 9099010:	e13ffd15 	stw	r4,-12(fp)
  unsigned int base = sp->base;
 9099014:	e0bffd17 	ldw	r2,-12(fp)
 9099018:	10800017 	ldw	r2,0(r2)
 909901c:	e0bffc15 	stw	r2,-16(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 9099020:	e0bffd17 	ldw	r2,-12(fp)
 9099024:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 9099028:	e0bffd17 	ldw	r2,-12(fp)
 909902c:	10803e04 	addi	r2,r2,248
 9099030:	e0bffa15 	stw	r2,-24(fp)
 9099034:	00800044 	movi	r2,1
 9099038:	e0bffb0d 	sth	r2,-20(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 909903c:	e13ffb0b 	ldhu	r4,-20(fp)
 9099040:	90928b80 	call	90928b8 <OSSemCreate>
 9099044:	1007883a 	mov	r3,r2
 9099048:	e0bffa17 	ldw	r2,-24(fp)
 909904c:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 9099050:	010ea604 	movi	r4,15000
 9099054:	90b9b600 	call	90b9b60 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9099058:	e0bffc17 	ldw	r2,-16(fp)
 909905c:	1007883a 	mov	r3,r2
 9099060:	00800c04 	movi	r2,48
 9099064:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 9099068:	01040104 	movi	r4,4100
 909906c:	90b9b600 	call	90b9b60 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9099070:	e0bffc17 	ldw	r2,-16(fp)
 9099074:	1007883a 	mov	r3,r2
 9099078:	00800c04 	movi	r2,48
 909907c:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 9099080:	0100fa04 	movi	r4,1000
 9099084:	90b9b600 	call	90b9b60 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 9099088:	e0bffc17 	ldw	r2,-16(fp)
 909908c:	1007883a 	mov	r3,r2
 9099090:	00800c04 	movi	r2,48
 9099094:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 9099098:	e13ffd17 	ldw	r4,-12(fp)
 909909c:	01400e04 	movi	r5,56
 90990a0:	90982300 	call	9098230 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 90990a4:	e13ffd17 	ldw	r4,-12(fp)
 90990a8:	01400204 	movi	r5,8
 90990ac:	90982300 	call	9098230 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 90990b0:	e13ffd17 	ldw	r4,-12(fp)
 90990b4:	90983bc0 	call	90983bc <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 90990b8:	e13ffd17 	ldw	r4,-12(fp)
 90990bc:	01400184 	movi	r5,6
 90990c0:	90982300 	call	9098230 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 90990c4:	e13ffd17 	ldw	r4,-12(fp)
 90990c8:	01400304 	movi	r5,12
 90990cc:	90982300 	call	9098230 <lcd_write_command>

  sp->esccount = -1;
 90990d0:	e0fffd17 	ldw	r3,-12(fp)
 90990d4:	00bfffc4 	movi	r2,-1
 90990d8:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 90990dc:	e0bffd17 	ldw	r2,-12(fp)
 90990e0:	11000a04 	addi	r4,r2,40
 90990e4:	000b883a 	mov	r5,zero
 90990e8:	01800204 	movi	r6,8
 90990ec:	90823f80 	call	90823f8 <memset>

  sp->scrollpos = 0;
 90990f0:	e0bffd17 	ldw	r2,-12(fp)
 90990f4:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 90990f8:	e0bffd17 	ldw	r2,-12(fp)
 90990fc:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 9099100:	e0bffd17 	ldw	r2,-12(fp)
 9099104:	100009c5 	stb	zero,39(r2)
 9099108:	00824374 	movhi	r2,2317
 909910c:	108c5204 	addi	r2,r2,12616
 9099110:	10800017 	ldw	r2,0(r2)
 9099114:	1007883a 	mov	r3,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 9099118:	00b33374 	movhi	r2,52429
 909911c:	10b33344 	addi	r2,r2,-13107
 9099120:	1889383a 	mul	r4,r3,r2
 9099124:	e13ffe15 	stw	r4,-8(fp)
 9099128:	1886383a 	mulxuu	r3,r3,r2
 909912c:	e0ffff15 	stw	r3,-4(fp)
 9099130:	e0ffff17 	ldw	r3,-4(fp)
 9099134:	1804d0fa 	srli	r2,r3,3
 9099138:	1007883a 	mov	r3,r2
 909913c:	e0bffd17 	ldw	r2,-12(fp)
 9099140:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 9099144:	e0bffd17 	ldw	r2,-12(fp)
 9099148:	11000104 	addi	r4,r2,4
 909914c:	e0bffd17 	ldw	r2,-12(fp)
 9099150:	10800717 	ldw	r2,28(r2)
 9099154:	100b883a 	mov	r5,r2
 9099158:	018242b4 	movhi	r6,2314
 909915c:	31a3cd04 	addi	r6,r6,-28876
 9099160:	e1fffd17 	ldw	r7,-12(fp)
 9099164:	90b899c0 	call	90b899c <alt_alarm_start>
}
 9099168:	e037883a 	mov	sp,fp
 909916c:	dfc00117 	ldw	ra,4(sp)
 9099170:	df000017 	ldw	fp,0(sp)
 9099174:	dec00204 	addi	sp,sp,8
 9099178:	f800283a 	ret

0909917c <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 909917c:	defffa04 	addi	sp,sp,-24
 9099180:	dfc00515 	stw	ra,20(sp)
 9099184:	df000415 	stw	fp,16(sp)
 9099188:	df000404 	addi	fp,sp,16
 909918c:	e13ffd15 	stw	r4,-12(fp)
 9099190:	e17ffe15 	stw	r5,-8(fp)
 9099194:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 9099198:	e0bffd17 	ldw	r2,-12(fp)
 909919c:	10800017 	ldw	r2,0(r2)
 90991a0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 90991a4:	e0bffc17 	ldw	r2,-16(fp)
 90991a8:	11000a04 	addi	r4,r2,40
 90991ac:	e0bffd17 	ldw	r2,-12(fp)
 90991b0:	11c00217 	ldw	r7,8(r2)
 90991b4:	e17ffe17 	ldw	r5,-8(fp)
 90991b8:	e1bfff17 	ldw	r6,-4(fp)
 90991bc:	9098a040 	call	9098a04 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 90991c0:	e037883a 	mov	sp,fp
 90991c4:	dfc00117 	ldw	ra,4(sp)
 90991c8:	df000017 	ldw	fp,0(sp)
 90991cc:	dec00204 	addi	sp,sp,8
 90991d0:	f800283a 	ret

090991d4 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 90991d4:	defffb04 	addi	sp,sp,-20
 90991d8:	df000415 	stw	fp,16(sp)
 90991dc:	df000404 	addi	fp,sp,16
 90991e0:	e13ffd15 	stw	r4,-12(fp)
 90991e4:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 90991e8:	e0bffd17 	ldw	r2,-12(fp)
 90991ec:	10800317 	ldw	r2,12(r2)
 90991f0:	10800037 	ldwio	r2,0(r2)
 90991f4:	1080040c 	andi	r2,r2,16
 90991f8:	1005003a 	cmpeq	r2,r2,zero
 90991fc:	1000031e 	bne	r2,zero,909920c <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 9099200:	00bffc04 	movi	r2,-16
 9099204:	e0bfff15 	stw	r2,-4(fp)
 9099208:	00003c06 	br	90992fc <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909920c:	e0bffd17 	ldw	r2,-12(fp)
 9099210:	10800317 	ldw	r2,12(r2)
 9099214:	11000404 	addi	r4,r2,16
 9099218:	e0bffd17 	ldw	r2,-12(fp)
 909921c:	10800317 	ldw	r2,12(r2)
 9099220:	10800404 	addi	r2,r2,16
 9099224:	10c00037 	ldwio	r3,0(r2)
 9099228:	00bff7c4 	movi	r2,-33
 909922c:	1886703a 	and	r3,r3,r2
 9099230:	2005883a 	mov	r2,r4
 9099234:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9099238:	e0bffd17 	ldw	r2,-12(fp)
 909923c:	10800317 	ldw	r2,12(r2)
 9099240:	1007883a 	mov	r3,r2
 9099244:	00803fc4 	movi	r2,255
 9099248:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 909924c:	e0bffd17 	ldw	r2,-12(fp)
 9099250:	10800317 	ldw	r2,12(r2)
 9099254:	10800804 	addi	r2,r2,32
 9099258:	e0fffe17 	ldw	r3,-8(fp)
 909925c:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 9099260:	e0bffd17 	ldw	r2,-12(fp)
 9099264:	10800917 	ldw	r2,36(r2)
 9099268:	1005003a 	cmpeq	r2,r2,zero
 909926c:	1000111e 	bne	r2,zero,90992b4 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9099270:	e0bffd17 	ldw	r2,-12(fp)
 9099274:	10800317 	ldw	r2,12(r2)
 9099278:	10800404 	addi	r2,r2,16
 909927c:	10800037 	ldwio	r2,0(r2)
 9099280:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
 9099284:	e0bffd17 	ldw	r2,-12(fp)
 9099288:	10c00b17 	ldw	r3,44(r2)
 909928c:	e0bffc17 	ldw	r2,-16(fp)
 9099290:	1884b03a 	or	r2,r3,r2
 9099294:	10801814 	ori	r2,r2,96
 9099298:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909929c:	e0bffd17 	ldw	r2,-12(fp)
 90992a0:	10800317 	ldw	r2,12(r2)
 90992a4:	10800404 	addi	r2,r2,16
 90992a8:	e0fffc17 	ldw	r3,-16(fp)
 90992ac:	10c00035 	stwio	r3,0(r2)
 90992b0:	00001106 	br	90992f8 <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 90992b4:	e0bffd17 	ldw	r2,-12(fp)
 90992b8:	10800317 	ldw	r2,12(r2)
 90992bc:	10800404 	addi	r2,r2,16
 90992c0:	10800037 	ldwio	r2,0(r2)
 90992c4:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 90992c8:	e0bffc17 	ldw	r2,-16(fp)
 90992cc:	10801814 	ori	r2,r2,96
 90992d0:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 90992d4:	e0fffc17 	ldw	r3,-16(fp)
 90992d8:	00bffbc4 	movi	r2,-17
 90992dc:	1884703a 	and	r2,r3,r2
 90992e0:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 90992e4:	e0bffd17 	ldw	r2,-12(fp)
 90992e8:	10800317 	ldw	r2,12(r2)
 90992ec:	10800404 	addi	r2,r2,16
 90992f0:	e0fffc17 	ldw	r3,-16(fp)
 90992f4:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 90992f8:	e03fff15 	stw	zero,-4(fp)
 90992fc:	e0bfff17 	ldw	r2,-4(fp)
}
 9099300:	e037883a 	mov	sp,fp
 9099304:	df000017 	ldw	fp,0(sp)
 9099308:	dec00104 	addi	sp,sp,4
 909930c:	f800283a 	ret

09099310 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 9099310:	defffc04 	addi	sp,sp,-16
 9099314:	df000315 	stw	fp,12(sp)
 9099318:	df000304 	addi	fp,sp,12
 909931c:	e13ffe15 	stw	r4,-8(fp)
 9099320:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 9099324:	e0bffe17 	ldw	r2,-8(fp)
 9099328:	10800317 	ldw	r2,12(r2)
 909932c:	10800037 	ldwio	r2,0(r2)
 9099330:	1080040c 	andi	r2,r2,16
 9099334:	1004c03a 	cmpne	r2,r2,zero
 9099338:	103ffa1e 	bne	r2,zero,9099324 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909933c:	e0bffe17 	ldw	r2,-8(fp)
 9099340:	10800317 	ldw	r2,12(r2)
 9099344:	11000404 	addi	r4,r2,16
 9099348:	e0bffe17 	ldw	r2,-8(fp)
 909934c:	10800317 	ldw	r2,12(r2)
 9099350:	10800404 	addi	r2,r2,16
 9099354:	10c00037 	ldwio	r3,0(r2)
 9099358:	00bff7c4 	movi	r2,-33
 909935c:	1886703a 	and	r3,r3,r2
 9099360:	2005883a 	mov	r2,r4
 9099364:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9099368:	e0bffe17 	ldw	r2,-8(fp)
 909936c:	10800317 	ldw	r2,12(r2)
 9099370:	1007883a 	mov	r3,r2
 9099374:	00803fc4 	movi	r2,255
 9099378:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 909937c:	e0bffe17 	ldw	r2,-8(fp)
 9099380:	10800317 	ldw	r2,12(r2)
 9099384:	10800804 	addi	r2,r2,32
 9099388:	e0ffff17 	ldw	r3,-4(fp)
 909938c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9099390:	e0bffe17 	ldw	r2,-8(fp)
 9099394:	10800317 	ldw	r2,12(r2)
 9099398:	11000404 	addi	r4,r2,16
 909939c:	e0bffe17 	ldw	r2,-8(fp)
 90993a0:	10800317 	ldw	r2,12(r2)
 90993a4:	10800404 	addi	r2,r2,16
 90993a8:	10800037 	ldwio	r2,0(r2)
 90993ac:	10c01814 	ori	r3,r2,96
 90993b0:	2005883a 	mov	r2,r4
 90993b4:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 90993b8:	e0bffe17 	ldw	r2,-8(fp)
 90993bc:	10800317 	ldw	r2,12(r2)
 90993c0:	10800037 	ldwio	r2,0(r2)
 90993c4:	1080040c 	andi	r2,r2,16
 90993c8:	1004c03a 	cmpne	r2,r2,zero
 90993cc:	103ffa1e 	bne	r2,zero,90993b8 <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 90993d0:	e0bffe17 	ldw	r2,-8(fp)
 90993d4:	10800317 	ldw	r2,12(r2)
 90993d8:	11000404 	addi	r4,r2,16
 90993dc:	e0bffe17 	ldw	r2,-8(fp)
 90993e0:	10800317 	ldw	r2,12(r2)
 90993e4:	10800404 	addi	r2,r2,16
 90993e8:	10c00037 	ldwio	r3,0(r2)
 90993ec:	00bff7c4 	movi	r2,-33
 90993f0:	1886703a 	and	r3,r3,r2
 90993f4:	2005883a 	mov	r2,r4
 90993f8:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 90993fc:	e0bffe17 	ldw	r2,-8(fp)
 9099400:	10800317 	ldw	r2,12(r2)
 9099404:	10800037 	ldwio	r2,0(r2)
 9099408:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 909940c:	e0bffe17 	ldw	r2,-8(fp)
 9099410:	10800317 	ldw	r2,12(r2)
 9099414:	1007883a 	mov	r3,r2
 9099418:	00803fc4 	movi	r2,255
 909941c:	18800035 	stwio	r2,0(r3)

  return status;
 9099420:	e0bffd03 	ldbu	r2,-12(fp)
}
 9099424:	e037883a 	mov	sp,fp
 9099428:	df000017 	ldw	fp,0(sp)
 909942c:	dec00104 	addi	sp,sp,4
 9099430:	f800283a 	ret

09099434 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 9099434:	defff404 	addi	sp,sp,-48
 9099438:	dfc00b15 	stw	ra,44(sp)
 909943c:	df000a15 	stw	fp,40(sp)
 9099440:	df000a04 	addi	fp,sp,40
 9099444:	e13ffb15 	stw	r4,-20(fp)
 9099448:	e17ffc15 	stw	r5,-16(fp)
 909944c:	e1bffd15 	stw	r6,-12(fp)
 9099450:	e1fffe15 	stw	r7,-8(fp)
 9099454:	e0800217 	ldw	r2,8(fp)
 9099458:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 909945c:	e0bfff0b 	ldhu	r2,-4(fp)
 9099460:	d8800015 	stw	r2,0(sp)
 9099464:	e0800317 	ldw	r2,12(fp)
 9099468:	d8800115 	stw	r2,4(sp)
 909946c:	e0800417 	ldw	r2,16(fp)
 9099470:	d8800215 	stw	r2,8(sp)
 9099474:	d8000315 	stw	zero,12(sp)
 9099478:	d8000415 	stw	zero,16(sp)
 909947c:	e13ffb17 	ldw	r4,-20(fp)
 9099480:	e17ffc17 	ldw	r5,-16(fp)
 9099484:	e1bffd17 	ldw	r6,-12(fp)
 9099488:	e1fffe17 	ldw	r7,-8(fp)
 909948c:	90994a40 	call	90994a4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 9099490:	e037883a 	mov	sp,fp
 9099494:	dfc00117 	ldw	ra,4(sp)
 9099498:	df000017 	ldw	fp,0(sp)
 909949c:	dec00204 	addi	sp,sp,8
 90994a0:	f800283a 	ret

090994a4 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 90994a4:	defff204 	addi	sp,sp,-56
 90994a8:	dfc00d15 	stw	ra,52(sp)
 90994ac:	df000c15 	stw	fp,48(sp)
 90994b0:	df000c04 	addi	fp,sp,48
 90994b4:	e13ffb15 	stw	r4,-20(fp)
 90994b8:	e17ffc15 	stw	r5,-16(fp)
 90994bc:	e1bffd15 	stw	r6,-12(fp)
 90994c0:	e1fffe15 	stw	r7,-8(fp)
 90994c4:	e0800217 	ldw	r2,8(fp)
 90994c8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 90994cc:	e0bfff0b 	ldhu	r2,-4(fp)
 90994d0:	d8800015 	stw	r2,0(sp)
 90994d4:	d8000115 	stw	zero,4(sp)
 90994d8:	e0800317 	ldw	r2,12(fp)
 90994dc:	d8800215 	stw	r2,8(sp)
 90994e0:	e0800417 	ldw	r2,16(fp)
 90994e4:	d8800315 	stw	r2,12(sp)
 90994e8:	e0800517 	ldw	r2,20(fp)
 90994ec:	d8800415 	stw	r2,16(sp)
 90994f0:	e0800617 	ldw	r2,24(fp)
 90994f4:	d8800515 	stw	r2,20(sp)
 90994f8:	d8000615 	stw	zero,24(sp)
 90994fc:	e13ffb17 	ldw	r4,-20(fp)
 9099500:	e17ffc17 	ldw	r5,-16(fp)
 9099504:	e1bffd17 	ldw	r6,-12(fp)
 9099508:	e1fffe17 	ldw	r7,-8(fp)
 909950c:	9099a640 	call	9099a64 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 9099510:	e037883a 	mov	sp,fp
 9099514:	dfc00117 	ldw	ra,4(sp)
 9099518:	df000017 	ldw	fp,0(sp)
 909951c:	dec00204 	addi	sp,sp,8
 9099520:	f800283a 	ret

09099524 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 9099524:	defff804 	addi	sp,sp,-32
 9099528:	dfc00715 	stw	ra,28(sp)
 909952c:	df000615 	stw	fp,24(sp)
 9099530:	df000604 	addi	fp,sp,24
 9099534:	e13ffc15 	stw	r4,-16(fp)
 9099538:	e17ffd15 	stw	r5,-12(fp)
 909953c:	e1bffe15 	stw	r6,-8(fp)
 9099540:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 9099544:	e1ffff0b 	ldhu	r7,-4(fp)
 9099548:	e0800217 	ldw	r2,8(fp)
 909954c:	d8800015 	stw	r2,0(sp)
 9099550:	d8000115 	stw	zero,4(sp)
 9099554:	e13ffc17 	ldw	r4,-16(fp)
 9099558:	e17ffd17 	ldw	r5,-12(fp)
 909955c:	e1bffe17 	ldw	r6,-8(fp)
 9099560:	90995780 	call	9099578 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 9099564:	e037883a 	mov	sp,fp
 9099568:	dfc00117 	ldw	ra,4(sp)
 909956c:	df000017 	ldw	fp,0(sp)
 9099570:	dec00204 	addi	sp,sp,8
 9099574:	f800283a 	ret

09099578 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 9099578:	defff304 	addi	sp,sp,-52
 909957c:	dfc00c15 	stw	ra,48(sp)
 9099580:	df000b15 	stw	fp,44(sp)
 9099584:	df000b04 	addi	fp,sp,44
 9099588:	e13ffc15 	stw	r4,-16(fp)
 909958c:	e17ffd15 	stw	r5,-12(fp)
 9099590:	e1bffe15 	stw	r6,-8(fp)
 9099594:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 9099598:	e0bfff0b 	ldhu	r2,-4(fp)
 909959c:	d8800015 	stw	r2,0(sp)
 90995a0:	d8000115 	stw	zero,4(sp)
 90995a4:	d8000215 	stw	zero,8(sp)
 90995a8:	e0800217 	ldw	r2,8(fp)
 90995ac:	d8800315 	stw	r2,12(sp)
 90995b0:	d8000415 	stw	zero,16(sp)
 90995b4:	e0800317 	ldw	r2,12(fp)
 90995b8:	d8800515 	stw	r2,20(sp)
 90995bc:	d8000615 	stw	zero,24(sp)
 90995c0:	e13ffc17 	ldw	r4,-16(fp)
 90995c4:	e17ffd17 	ldw	r5,-12(fp)
 90995c8:	000d883a 	mov	r6,zero
 90995cc:	e1fffe17 	ldw	r7,-8(fp)
 90995d0:	9099a640 	call	9099a64 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 90995d4:	e037883a 	mov	sp,fp
 90995d8:	dfc00117 	ldw	ra,4(sp)
 90995dc:	df000017 	ldw	fp,0(sp)
 90995e0:	dec00204 	addi	sp,sp,8
 90995e4:	f800283a 	ret

090995e8 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 90995e8:	defff404 	addi	sp,sp,-48
 90995ec:	dfc00b15 	stw	ra,44(sp)
 90995f0:	df000a15 	stw	fp,40(sp)
 90995f4:	df000a04 	addi	fp,sp,40
 90995f8:	e13ffb15 	stw	r4,-20(fp)
 90995fc:	e17ffc15 	stw	r5,-16(fp)
 9099600:	e1bffd15 	stw	r6,-12(fp)
 9099604:	e0800517 	ldw	r2,20(fp)
 9099608:	e1fffe0d 	sth	r7,-8(fp)
 909960c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 9099610:	e1fffe0b 	ldhu	r7,-8(fp)
 9099614:	e0ffff03 	ldbu	r3,-4(fp)
 9099618:	e0800217 	ldw	r2,8(fp)
 909961c:	d8800015 	stw	r2,0(sp)
 9099620:	e0800317 	ldw	r2,12(fp)
 9099624:	d8800115 	stw	r2,4(sp)
 9099628:	e0800417 	ldw	r2,16(fp)
 909962c:	d8800215 	stw	r2,8(sp)
 9099630:	d8000315 	stw	zero,12(sp)
 9099634:	d8c00415 	stw	r3,16(sp)
 9099638:	e13ffb17 	ldw	r4,-20(fp)
 909963c:	e17ffc17 	ldw	r5,-16(fp)
 9099640:	e1bffd17 	ldw	r6,-12(fp)
 9099644:	909965c0 	call	909965c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 9099648:	e037883a 	mov	sp,fp
 909964c:	dfc00117 	ldw	ra,4(sp)
 9099650:	df000017 	ldw	fp,0(sp)
 9099654:	dec00204 	addi	sp,sp,8
 9099658:	f800283a 	ret

0909965c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 909965c:	defff204 	addi	sp,sp,-56
 9099660:	dfc00d15 	stw	ra,52(sp)
 9099664:	df000c15 	stw	fp,48(sp)
 9099668:	df000c04 	addi	fp,sp,48
 909966c:	e13ffb15 	stw	r4,-20(fp)
 9099670:	e17ffc15 	stw	r5,-16(fp)
 9099674:	e1bffd15 	stw	r6,-12(fp)
 9099678:	e0800617 	ldw	r2,24(fp)
 909967c:	e1fffe0d 	sth	r7,-8(fp)
 9099680:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 9099684:	e0bffe0b 	ldhu	r2,-8(fp)
 9099688:	e0ffff03 	ldbu	r3,-4(fp)
 909968c:	d8800015 	stw	r2,0(sp)
 9099690:	e0800417 	ldw	r2,16(fp)
 9099694:	d8800115 	stw	r2,4(sp)
 9099698:	e0800217 	ldw	r2,8(fp)
 909969c:	d8800215 	stw	r2,8(sp)
 90996a0:	e0800317 	ldw	r2,12(fp)
 90996a4:	d8800315 	stw	r2,12(sp)
 90996a8:	e0800517 	ldw	r2,20(fp)
 90996ac:	d8800415 	stw	r2,16(sp)
 90996b0:	d8000515 	stw	zero,20(sp)
 90996b4:	d8c00615 	stw	r3,24(sp)
 90996b8:	e13ffb17 	ldw	r4,-20(fp)
 90996bc:	e17ffc17 	ldw	r5,-16(fp)
 90996c0:	e1bffd17 	ldw	r6,-12(fp)
 90996c4:	000f883a 	mov	r7,zero
 90996c8:	9099a640 	call	9099a64 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 90996cc:	e037883a 	mov	sp,fp
 90996d0:	dfc00117 	ldw	ra,4(sp)
 90996d4:	df000017 	ldw	fp,0(sp)
 90996d8:	dec00204 	addi	sp,sp,8
 90996dc:	f800283a 	ret

090996e0 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 90996e0:	defffb04 	addi	sp,sp,-20
 90996e4:	df000415 	stw	fp,16(sp)
 90996e8:	df000404 	addi	fp,sp,16
 90996ec:	e13ffc15 	stw	r4,-16(fp)
 90996f0:	e17ffd15 	stw	r5,-12(fp)
 90996f4:	e1bffe15 	stw	r6,-8(fp)
 90996f8:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 90996fc:	e0fffc17 	ldw	r3,-16(fp)
 9099700:	e0bffd17 	ldw	r2,-12(fp)
 9099704:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
 9099708:	e0fffc17 	ldw	r3,-16(fp)
 909970c:	e0bfff17 	ldw	r2,-4(fp)
 9099710:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
 9099714:	e0fffc17 	ldw	r3,-16(fp)
 9099718:	e0bffe17 	ldw	r2,-8(fp)
 909971c:	18800b15 	stw	r2,44(r3)
}
 9099720:	e037883a 	mov	sp,fp
 9099724:	df000017 	ldw	fp,0(sp)
 9099728:	dec00104 	addi	sp,sp,4
 909972c:	f800283a 	ret

09099730 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 9099730:	defffd04 	addi	sp,sp,-12
 9099734:	df000215 	stw	fp,8(sp)
 9099738:	df000204 	addi	fp,sp,8
 909973c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9099740:	e0bfff17 	ldw	r2,-4(fp)
 9099744:	10800317 	ldw	r2,12(r2)
 9099748:	10800404 	addi	r2,r2,16
 909974c:	10800037 	ldwio	r2,0(r2)
 9099750:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 9099754:	e0bffe17 	ldw	r2,-8(fp)
 9099758:	10800814 	ori	r2,r2,32
 909975c:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9099760:	e0bfff17 	ldw	r2,-4(fp)
 9099764:	10800317 	ldw	r2,12(r2)
 9099768:	10800404 	addi	r2,r2,16
 909976c:	e0fffe17 	ldw	r3,-8(fp)
 9099770:	10c00035 	stwio	r3,0(r2)
}
 9099774:	e037883a 	mov	sp,fp
 9099778:	df000017 	ldw	fp,0(sp)
 909977c:	dec00104 	addi	sp,sp,4
 9099780:	f800283a 	ret

09099784 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 9099784:	defffd04 	addi	sp,sp,-12
 9099788:	df000215 	stw	fp,8(sp)
 909978c:	df000204 	addi	fp,sp,8
 9099790:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9099794:	e0bfff17 	ldw	r2,-4(fp)
 9099798:	10800317 	ldw	r2,12(r2)
 909979c:	10800404 	addi	r2,r2,16
 90997a0:	10800037 	ldwio	r2,0(r2)
 90997a4:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 90997a8:	e0fffe17 	ldw	r3,-8(fp)
 90997ac:	00bff7c4 	movi	r2,-33
 90997b0:	1884703a 	and	r2,r3,r2
 90997b4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 90997b8:	e0bfff17 	ldw	r2,-4(fp)
 90997bc:	10800317 	ldw	r2,12(r2)
 90997c0:	10800404 	addi	r2,r2,16
 90997c4:	e0fffe17 	ldw	r3,-8(fp)
 90997c8:	10c00035 	stwio	r3,0(r2)
}
 90997cc:	e037883a 	mov	sp,fp
 90997d0:	df000017 	ldw	fp,0(sp)
 90997d4:	dec00104 	addi	sp,sp,4
 90997d8:	f800283a 	ret

090997dc <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 90997dc:	defffd04 	addi	sp,sp,-12
 90997e0:	df000215 	stw	fp,8(sp)
 90997e4:	df000204 	addi	fp,sp,8
 90997e8:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 90997ec:	e0bffe17 	ldw	r2,-8(fp)
 90997f0:	10800784 	addi	r2,r2,30
 90997f4:	10800023 	ldbuio	r2,0(r2)
 90997f8:	10801fcc 	andi	r2,r2,127
 90997fc:	1005003a 	cmpeq	r2,r2,zero
 9099800:	1000031e 	bne	r2,zero,9099810 <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 9099804:	00bffec4 	movi	r2,-5
 9099808:	e0bfff15 	stw	r2,-4(fp)
 909980c:	00000a06 	br	9099838 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 9099810:	e0bffe17 	ldw	r2,-8(fp)
 9099814:	108007c4 	addi	r2,r2,31
 9099818:	10800023 	ldbuio	r2,0(r2)
 909981c:	1080200c 	andi	r2,r2,128
 9099820:	1005003a 	cmpeq	r2,r2,zero
 9099824:	1000031e 	bne	r2,zero,9099834 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 9099828:	00bfe244 	movi	r2,-119
 909982c:	e0bfff15 	stw	r2,-4(fp)
 9099830:	00000106 	br	9099838 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
 9099834:	e03fff15 	stw	zero,-4(fp)
 9099838:	e0bfff17 	ldw	r2,-4(fp)
}
 909983c:	e037883a 	mov	sp,fp
 9099840:	df000017 	ldw	fp,0(sp)
 9099844:	dec00104 	addi	sp,sp,4
 9099848:	f800283a 	ret

0909984c <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 909984c:	defffc04 	addi	sp,sp,-16
 9099850:	dfc00315 	stw	ra,12(sp)
 9099854:	df000215 	stw	fp,8(sp)
 9099858:	df000204 	addi	fp,sp,8
 909985c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 9099860:	e13fff17 	ldw	r4,-4(fp)
 9099864:	d1602904 	addi	r5,gp,-32604
 9099868:	90b8ecc0 	call	90b8ecc <alt_find_dev>
 909986c:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 9099870:	e0bffe17 	ldw	r2,-8(fp)
 9099874:	1004c03a 	cmpne	r2,r2,zero
 9099878:	1000041e 	bne	r2,zero,909988c <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
 909987c:	90998a40 	call	90998a4 <alt_get_errno>
 9099880:	1007883a 	mov	r3,r2
 9099884:	008004c4 	movi	r2,19
 9099888:	18800015 	stw	r2,0(r3)
  }

  return dev;
 909988c:	e0bffe17 	ldw	r2,-8(fp)
}
 9099890:	e037883a 	mov	sp,fp
 9099894:	dfc00117 	ldw	ra,4(sp)
 9099898:	df000017 	ldw	fp,0(sp)
 909989c:	dec00204 	addi	sp,sp,8
 90998a0:	f800283a 	ret

090998a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90998a4:	defffd04 	addi	sp,sp,-12
 90998a8:	dfc00215 	stw	ra,8(sp)
 90998ac:	df000115 	stw	fp,4(sp)
 90998b0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90998b4:	00824374 	movhi	r2,2317
 90998b8:	108bdf04 	addi	r2,r2,12156
 90998bc:	10800017 	ldw	r2,0(r2)
 90998c0:	1005003a 	cmpeq	r2,r2,zero
 90998c4:	1000061e 	bne	r2,zero,90998e0 <alt_get_errno+0x3c>
 90998c8:	00824374 	movhi	r2,2317
 90998cc:	108bdf04 	addi	r2,r2,12156
 90998d0:	10800017 	ldw	r2,0(r2)
 90998d4:	103ee83a 	callr	r2
 90998d8:	e0bfff15 	stw	r2,-4(fp)
 90998dc:	00000306 	br	90998ec <alt_get_errno+0x48>
 90998e0:	00824374 	movhi	r2,2317
 90998e4:	108bfd04 	addi	r2,r2,12276
 90998e8:	e0bfff15 	stw	r2,-4(fp)
 90998ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90998f0:	e037883a 	mov	sp,fp
 90998f4:	dfc00117 	ldw	ra,4(sp)
 90998f8:	df000017 	ldw	fp,0(sp)
 90998fc:	dec00204 	addi	sp,sp,8
 9099900:	f800283a 	ret

09099904 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 9099904:	defff104 	addi	sp,sp,-60
 9099908:	dfc00e15 	stw	ra,56(sp)
 909990c:	df000d15 	stw	fp,52(sp)
 9099910:	df000d04 	addi	fp,sp,52
 9099914:	e13ffa15 	stw	r4,-24(fp)
 9099918:	e17ffb15 	stw	r5,-20(fp)
 909991c:	e1bffc15 	stw	r6,-16(fp)
 9099920:	e1fffd15 	stw	r7,-12(fp)
 9099924:	e0800217 	ldw	r2,8(fp)
 9099928:	e0c00617 	ldw	r3,24(fp)
 909992c:	e0bffe0d 	sth	r2,-8(fp)
 9099930:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 9099934:	e0bffe0b 	ldhu	r2,-8(fp)
 9099938:	e0ffff03 	ldbu	r3,-4(fp)
 909993c:	d8800015 	stw	r2,0(sp)
 9099940:	e0800317 	ldw	r2,12(fp)
 9099944:	d8800115 	stw	r2,4(sp)
 9099948:	e0800417 	ldw	r2,16(fp)
 909994c:	d8800215 	stw	r2,8(sp)
 9099950:	e0800517 	ldw	r2,20(fp)
 9099954:	d8800315 	stw	r2,12(sp)
 9099958:	d8000415 	stw	zero,16(sp)
 909995c:	d8000515 	stw	zero,20(sp)
 9099960:	d8c00615 	stw	r3,24(sp)
 9099964:	e13ffa17 	ldw	r4,-24(fp)
 9099968:	e17ffb17 	ldw	r5,-20(fp)
 909996c:	e1bffc17 	ldw	r6,-16(fp)
 9099970:	e1fffd17 	ldw	r7,-12(fp)
 9099974:	9099a640 	call	9099a64 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 9099978:	e037883a 	mov	sp,fp
 909997c:	dfc00117 	ldw	ra,4(sp)
 9099980:	df000017 	ldw	fp,0(sp)
 9099984:	dec00204 	addi	sp,sp,8
 9099988:	f800283a 	ret

0909998c <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 909998c:	defffc04 	addi	sp,sp,-16
 9099990:	df000315 	stw	fp,12(sp)
 9099994:	df000304 	addi	fp,sp,12
 9099998:	e13ffe15 	stw	r4,-8(fp)
 909999c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 90999a0:	e0bffe17 	ldw	r2,-8(fp)
 90999a4:	10800317 	ldw	r2,12(r2)
 90999a8:	10800404 	addi	r2,r2,16
 90999ac:	10800037 	ldwio	r2,0(r2)
 90999b0:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 90999b4:	e0fffd17 	ldw	r3,-12(fp)
 90999b8:	00a00434 	movhi	r2,32784
 90999bc:	10bfffc4 	addi	r2,r2,-1
 90999c0:	1884703a 	and	r2,r3,r2
 90999c4:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 90999c8:	e0bfff17 	ldw	r2,-4(fp)
 90999cc:	1004953a 	slli	r2,r2,20
 90999d0:	10dffc2c 	andhi	r3,r2,32752
 90999d4:	e0bffd17 	ldw	r2,-12(fp)
 90999d8:	1884b03a 	or	r2,r3,r2
 90999dc:	10800134 	orhi	r2,r2,4
 90999e0:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 90999e4:	e0bffe17 	ldw	r2,-8(fp)
 90999e8:	10800317 	ldw	r2,12(r2)
 90999ec:	10800404 	addi	r2,r2,16
 90999f0:	e0fffd17 	ldw	r3,-12(fp)
 90999f4:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 90999f8:	e037883a 	mov	sp,fp
 90999fc:	df000017 	ldw	fp,0(sp)
 9099a00:	dec00104 	addi	sp,sp,4
 9099a04:	f800283a 	ret

09099a08 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 9099a08:	defffd04 	addi	sp,sp,-12
 9099a0c:	df000215 	stw	fp,8(sp)
 9099a10:	df000204 	addi	fp,sp,8
 9099a14:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9099a18:	e0bfff17 	ldw	r2,-4(fp)
 9099a1c:	10800317 	ldw	r2,12(r2)
 9099a20:	10800404 	addi	r2,r2,16
 9099a24:	10800037 	ldwio	r2,0(r2)
 9099a28:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 9099a2c:	e0fffe17 	ldw	r3,-8(fp)
 9099a30:	00bfff34 	movhi	r2,65532
 9099a34:	10bfffc4 	addi	r2,r2,-1
 9099a38:	1884703a 	and	r2,r3,r2
 9099a3c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 9099a40:	e0bfff17 	ldw	r2,-4(fp)
 9099a44:	10800317 	ldw	r2,12(r2)
 9099a48:	10800404 	addi	r2,r2,16
 9099a4c:	e0fffe17 	ldw	r3,-8(fp)
 9099a50:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 9099a54:	e037883a 	mov	sp,fp
 9099a58:	df000017 	ldw	fp,0(sp)
 9099a5c:	dec00104 	addi	sp,sp,4
 9099a60:	f800283a 	ret

09099a64 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 9099a64:	defff204 	addi	sp,sp,-56
 9099a68:	dfc00d15 	stw	ra,52(sp)
 9099a6c:	df000c15 	stw	fp,48(sp)
 9099a70:	df000c04 	addi	fp,sp,48
 9099a74:	e13ff415 	stw	r4,-48(fp)
 9099a78:	e17ff515 	stw	r5,-44(fp)
 9099a7c:	e1bff615 	stw	r6,-40(fp)
 9099a80:	e1fff715 	stw	r7,-36(fp)
 9099a84:	e0800217 	ldw	r2,8(fp)
 9099a88:	e0c00817 	ldw	r3,32(fp)
 9099a8c:	e0bff80d 	sth	r2,-32(fp)
 9099a90:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 9099a94:	e0bff517 	ldw	r2,-44(fp)
 9099a98:	110007c4 	addi	r4,r2,31
 9099a9c:	e0bff517 	ldw	r2,-44(fp)
 9099aa0:	108007c3 	ldbu	r2,31(r2)
 9099aa4:	10c03fcc 	andi	r3,r2,255
 9099aa8:	00bfdfc4 	movi	r2,-129
 9099aac:	1886703a 	and	r3,r3,r2
 9099ab0:	2005883a 	mov	r2,r4
 9099ab4:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 9099ab8:	e13ff417 	ldw	r4,-48(fp)
 9099abc:	e0bff617 	ldw	r2,-40(fp)
 9099ac0:	11403fcc 	andi	r5,r2,255
 9099ac4:	20800003 	ldbu	r2,0(r4)
 9099ac8:	1004703a 	and	r2,r2,zero
 9099acc:	1007883a 	mov	r3,r2
 9099ad0:	2805883a 	mov	r2,r5
 9099ad4:	1884b03a 	or	r2,r3,r2
 9099ad8:	20800005 	stb	r2,0(r4)
 9099adc:	e0bff617 	ldw	r2,-40(fp)
 9099ae0:	1004d23a 	srli	r2,r2,8
 9099ae4:	11403fcc 	andi	r5,r2,255
 9099ae8:	20800043 	ldbu	r2,1(r4)
 9099aec:	1004703a 	and	r2,r2,zero
 9099af0:	1007883a 	mov	r3,r2
 9099af4:	2805883a 	mov	r2,r5
 9099af8:	1884b03a 	or	r2,r3,r2
 9099afc:	20800045 	stb	r2,1(r4)
 9099b00:	e0bff617 	ldw	r2,-40(fp)
 9099b04:	1004d43a 	srli	r2,r2,16
 9099b08:	11403fcc 	andi	r5,r2,255
 9099b0c:	20800083 	ldbu	r2,2(r4)
 9099b10:	1004703a 	and	r2,r2,zero
 9099b14:	1007883a 	mov	r3,r2
 9099b18:	2805883a 	mov	r2,r5
 9099b1c:	1884b03a 	or	r2,r3,r2
 9099b20:	20800085 	stb	r2,2(r4)
 9099b24:	e0bff617 	ldw	r2,-40(fp)
 9099b28:	100ad63a 	srli	r5,r2,24
 9099b2c:	208000c3 	ldbu	r2,3(r4)
 9099b30:	1004703a 	and	r2,r2,zero
 9099b34:	1007883a 	mov	r3,r2
 9099b38:	2805883a 	mov	r2,r5
 9099b3c:	1884b03a 	or	r2,r3,r2
 9099b40:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
 9099b44:	e13ff417 	ldw	r4,-48(fp)
 9099b48:	e0bff717 	ldw	r2,-36(fp)
 9099b4c:	11403fcc 	andi	r5,r2,255
 9099b50:	20800203 	ldbu	r2,8(r4)
 9099b54:	1004703a 	and	r2,r2,zero
 9099b58:	1007883a 	mov	r3,r2
 9099b5c:	2805883a 	mov	r2,r5
 9099b60:	1884b03a 	or	r2,r3,r2
 9099b64:	20800205 	stb	r2,8(r4)
 9099b68:	e0bff717 	ldw	r2,-36(fp)
 9099b6c:	1004d23a 	srli	r2,r2,8
 9099b70:	11403fcc 	andi	r5,r2,255
 9099b74:	20800243 	ldbu	r2,9(r4)
 9099b78:	1004703a 	and	r2,r2,zero
 9099b7c:	1007883a 	mov	r3,r2
 9099b80:	2805883a 	mov	r2,r5
 9099b84:	1884b03a 	or	r2,r3,r2
 9099b88:	20800245 	stb	r2,9(r4)
 9099b8c:	e0bff717 	ldw	r2,-36(fp)
 9099b90:	1004d43a 	srli	r2,r2,16
 9099b94:	11403fcc 	andi	r5,r2,255
 9099b98:	20800283 	ldbu	r2,10(r4)
 9099b9c:	1004703a 	and	r2,r2,zero
 9099ba0:	1007883a 	mov	r3,r2
 9099ba4:	2805883a 	mov	r2,r5
 9099ba8:	1884b03a 	or	r2,r3,r2
 9099bac:	20800285 	stb	r2,10(r4)
 9099bb0:	e0bff717 	ldw	r2,-36(fp)
 9099bb4:	100ad63a 	srli	r5,r2,24
 9099bb8:	208002c3 	ldbu	r2,11(r4)
 9099bbc:	1004703a 	and	r2,r2,zero
 9099bc0:	1007883a 	mov	r3,r2
 9099bc4:	2805883a 	mov	r2,r5
 9099bc8:	1884b03a 	or	r2,r3,r2
 9099bcc:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
 9099bd0:	e1bff517 	ldw	r6,-44(fp)
 9099bd4:	e13ff417 	ldw	r4,-48(fp)
 9099bd8:	31403fcc 	andi	r5,r6,255
 9099bdc:	20800403 	ldbu	r2,16(r4)
 9099be0:	1004703a 	and	r2,r2,zero
 9099be4:	1007883a 	mov	r3,r2
 9099be8:	2805883a 	mov	r2,r5
 9099bec:	1884b03a 	or	r2,r3,r2
 9099bf0:	20800405 	stb	r2,16(r4)
 9099bf4:	3004d23a 	srli	r2,r6,8
 9099bf8:	11403fcc 	andi	r5,r2,255
 9099bfc:	20800443 	ldbu	r2,17(r4)
 9099c00:	1004703a 	and	r2,r2,zero
 9099c04:	1007883a 	mov	r3,r2
 9099c08:	2805883a 	mov	r2,r5
 9099c0c:	1884b03a 	or	r2,r3,r2
 9099c10:	20800445 	stb	r2,17(r4)
 9099c14:	3004d43a 	srli	r2,r6,16
 9099c18:	11403fcc 	andi	r5,r2,255
 9099c1c:	20800483 	ldbu	r2,18(r4)
 9099c20:	1004703a 	and	r2,r2,zero
 9099c24:	1007883a 	mov	r3,r2
 9099c28:	2805883a 	mov	r2,r5
 9099c2c:	1884b03a 	or	r2,r3,r2
 9099c30:	20800485 	stb	r2,18(r4)
 9099c34:	300ad63a 	srli	r5,r6,24
 9099c38:	208004c3 	ldbu	r2,19(r4)
 9099c3c:	1004703a 	and	r2,r2,zero
 9099c40:	1007883a 	mov	r3,r2
 9099c44:	2805883a 	mov	r2,r5
 9099c48:	1884b03a 	or	r2,r3,r2
 9099c4c:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
 9099c50:	e0fff417 	ldw	r3,-48(fp)
 9099c54:	18800103 	ldbu	r2,4(r3)
 9099c58:	1004703a 	and	r2,r2,zero
 9099c5c:	18800105 	stb	r2,4(r3)
 9099c60:	18800143 	ldbu	r2,5(r3)
 9099c64:	1004703a 	and	r2,r2,zero
 9099c68:	18800145 	stb	r2,5(r3)
 9099c6c:	18800183 	ldbu	r2,6(r3)
 9099c70:	1004703a 	and	r2,r2,zero
 9099c74:	18800185 	stb	r2,6(r3)
 9099c78:	188001c3 	ldbu	r2,7(r3)
 9099c7c:	1004703a 	and	r2,r2,zero
 9099c80:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
 9099c84:	e0fff417 	ldw	r3,-48(fp)
 9099c88:	18800303 	ldbu	r2,12(r3)
 9099c8c:	1004703a 	and	r2,r2,zero
 9099c90:	18800305 	stb	r2,12(r3)
 9099c94:	18800343 	ldbu	r2,13(r3)
 9099c98:	1004703a 	and	r2,r2,zero
 9099c9c:	18800345 	stb	r2,13(r3)
 9099ca0:	18800383 	ldbu	r2,14(r3)
 9099ca4:	1004703a 	and	r2,r2,zero
 9099ca8:	18800385 	stb	r2,14(r3)
 9099cac:	188003c3 	ldbu	r2,15(r3)
 9099cb0:	1004703a 	and	r2,r2,zero
 9099cb4:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
 9099cb8:	e0fff417 	ldw	r3,-48(fp)
 9099cbc:	18800503 	ldbu	r2,20(r3)
 9099cc0:	1004703a 	and	r2,r2,zero
 9099cc4:	18800505 	stb	r2,20(r3)
 9099cc8:	18800543 	ldbu	r2,21(r3)
 9099ccc:	1004703a 	and	r2,r2,zero
 9099cd0:	18800545 	stb	r2,21(r3)
 9099cd4:	18800583 	ldbu	r2,22(r3)
 9099cd8:	1004703a 	and	r2,r2,zero
 9099cdc:	18800585 	stb	r2,22(r3)
 9099ce0:	188005c3 	ldbu	r2,23(r3)
 9099ce4:	1004703a 	and	r2,r2,zero
 9099ce8:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
 9099cec:	e13ff417 	ldw	r4,-48(fp)
 9099cf0:	e0bff80b 	ldhu	r2,-32(fp)
 9099cf4:	11403fcc 	andi	r5,r2,255
 9099cf8:	20800603 	ldbu	r2,24(r4)
 9099cfc:	1004703a 	and	r2,r2,zero
 9099d00:	1007883a 	mov	r3,r2
 9099d04:	2805883a 	mov	r2,r5
 9099d08:	1884b03a 	or	r2,r3,r2
 9099d0c:	20800605 	stb	r2,24(r4)
 9099d10:	e0bff80b 	ldhu	r2,-32(fp)
 9099d14:	1004d23a 	srli	r2,r2,8
 9099d18:	117fffcc 	andi	r5,r2,65535
 9099d1c:	20800643 	ldbu	r2,25(r4)
 9099d20:	1004703a 	and	r2,r2,zero
 9099d24:	1007883a 	mov	r3,r2
 9099d28:	2805883a 	mov	r2,r5
 9099d2c:	1884b03a 	or	r2,r3,r2
 9099d30:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
 9099d34:	e0fff417 	ldw	r3,-48(fp)
 9099d38:	18800703 	ldbu	r2,28(r3)
 9099d3c:	1004703a 	and	r2,r2,zero
 9099d40:	18800705 	stb	r2,28(r3)
 9099d44:	18800743 	ldbu	r2,29(r3)
 9099d48:	1004703a 	and	r2,r2,zero
 9099d4c:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
 9099d50:	e0bff417 	ldw	r2,-48(fp)
 9099d54:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 9099d58:	e0800617 	ldw	r2,24(fp)
 9099d5c:	1007883a 	mov	r3,r2
 9099d60:	e0bff417 	ldw	r2,-48(fp)
 9099d64:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 9099d68:	e0800717 	ldw	r2,28(fp)
 9099d6c:	1007883a 	mov	r3,r2
 9099d70:	e0bff417 	ldw	r2,-48(fp)
 9099d74:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 9099d78:	e0800317 	ldw	r2,12(fp)
 9099d7c:	1005003a 	cmpeq	r2,r2,zero
 9099d80:	1000031e 	bne	r2,zero,9099d90 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 9099d84:	00bfe044 	movi	r2,-127
 9099d88:	e0bfff05 	stb	r2,-4(fp)
 9099d8c:	00000206 	br	9099d98 <alt_avalon_sgdma_construct_descriptor_burst+0x334>
 9099d90:	00bfe004 	movi	r2,-128
 9099d94:	e0bfff05 	stb	r2,-4(fp)
 9099d98:	e0800417 	ldw	r2,16(fp)
 9099d9c:	1005003a 	cmpeq	r2,r2,zero
 9099da0:	1000031e 	bne	r2,zero,9099db0 <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
 9099da4:	00800084 	movi	r2,2
 9099da8:	e0bffe05 	stb	r2,-8(fp)
 9099dac:	00000106 	br	9099db4 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
 9099db0:	e03ffe05 	stb	zero,-8(fp)
 9099db4:	e0ffff03 	ldbu	r3,-4(fp)
 9099db8:	e13ffe03 	ldbu	r4,-8(fp)
 9099dbc:	1904b03a 	or	r2,r3,r4
 9099dc0:	e0bffd05 	stb	r2,-12(fp)
 9099dc4:	e0800517 	ldw	r2,20(fp)
 9099dc8:	1005003a 	cmpeq	r2,r2,zero
 9099dcc:	1000031e 	bne	r2,zero,9099ddc <alt_avalon_sgdma_construct_descriptor_burst+0x378>
 9099dd0:	00800104 	movi	r2,4
 9099dd4:	e0bffc05 	stb	r2,-16(fp)
 9099dd8:	00000106 	br	9099de0 <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
 9099ddc:	e03ffc05 	stb	zero,-16(fp)
 9099de0:	e0fffd03 	ldbu	r3,-12(fp)
 9099de4:	e13ffc03 	ldbu	r4,-16(fp)
 9099de8:	1904b03a 	or	r2,r3,r4
 9099dec:	e0bffb05 	stb	r2,-20(fp)
 9099df0:	e0bff903 	ldbu	r2,-28(fp)
 9099df4:	1005003a 	cmpeq	r2,r2,zero
 9099df8:	1000051e 	bne	r2,zero,9099e10 <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
 9099dfc:	e0bff903 	ldbu	r2,-28(fp)
 9099e00:	108003cc 	andi	r2,r2,15
 9099e04:	100490fa 	slli	r2,r2,3
 9099e08:	e0bffa05 	stb	r2,-24(fp)
 9099e0c:	00000106 	br	9099e14 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
 9099e10:	e03ffa05 	stb	zero,-24(fp)
 9099e14:	e0fffb03 	ldbu	r3,-20(fp)
 9099e18:	e13ffa03 	ldbu	r4,-24(fp)
 9099e1c:	1904b03a 	or	r2,r3,r4
 9099e20:	1007883a 	mov	r3,r2
 9099e24:	e0bff417 	ldw	r2,-48(fp)
 9099e28:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 9099e2c:	e13ff417 	ldw	r4,-48(fp)
 9099e30:	01400804 	movi	r5,32
 9099e34:	90b99140 	call	90b9914 <alt_remap_uncached>
}
 9099e38:	e037883a 	mov	sp,fp
 9099e3c:	dfc00117 	ldw	ra,4(sp)
 9099e40:	df000017 	ldw	fp,0(sp)
 9099e44:	dec00204 	addi	sp,sp,8
 9099e48:	f800283a 	ret

09099e4c <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 9099e4c:	defff904 	addi	sp,sp,-28
 9099e50:	dfc00615 	stw	ra,24(sp)
 9099e54:	df000515 	stw	fp,20(sp)
 9099e58:	df000504 	addi	fp,sp,20
 9099e5c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 9099e60:	e0bfff17 	ldw	r2,-4(fp)
 9099e64:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 9099e68:	e0bffe17 	ldw	r2,-8(fp)
 9099e6c:	10800317 	ldw	r2,12(r2)
 9099e70:	11000404 	addi	r4,r2,16
 9099e74:	e0bffe17 	ldw	r2,-8(fp)
 9099e78:	10800317 	ldw	r2,12(r2)
 9099e7c:	10800404 	addi	r2,r2,16
 9099e80:	10800037 	ldwio	r2,0(r2)
 9099e84:	10a00034 	orhi	r2,r2,32768
 9099e88:	1007883a 	mov	r3,r2
 9099e8c:	2005883a 	mov	r2,r4
 9099e90:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 9099e94:	e0bffe17 	ldw	r2,-8(fp)
 9099e98:	10800317 	ldw	r2,12(r2)
 9099e9c:	10800404 	addi	r2,r2,16
 9099ea0:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 9099ea4:	e0bffe17 	ldw	r2,-8(fp)
 9099ea8:	10800917 	ldw	r2,36(r2)
 9099eac:	1005003a 	cmpeq	r2,r2,zero
 9099eb0:	1000111e 	bne	r2,zero,9099ef8 <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9099eb4:	0005303a 	rdctl	r2,status
 9099eb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9099ebc:	e0fffc17 	ldw	r3,-16(fp)
 9099ec0:	00bfff84 	movi	r2,-2
 9099ec4:	1884703a 	and	r2,r3,r2
 9099ec8:	1001703a 	wrctl	status,r2
  
  return context;
 9099ecc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
 9099ed0:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
 9099ed4:	e0bffe17 	ldw	r2,-8(fp)
 9099ed8:	10c00917 	ldw	r3,36(r2)
 9099edc:	e0bffe17 	ldw	r2,-8(fp)
 9099ee0:	11000a17 	ldw	r4,40(r2)
 9099ee4:	183ee83a 	callr	r3
 9099ee8:	e0bffd17 	ldw	r2,-12(fp)
 9099eec:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9099ef0:	e0bffb17 	ldw	r2,-20(fp)
 9099ef4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 9099ef8:	e037883a 	mov	sp,fp
 9099efc:	dfc00117 	ldw	ra,4(sp)
 9099f00:	df000017 	ldw	fp,0(sp)
 9099f04:	dec00204 	addi	sp,sp,8
 9099f08:	f800283a 	ret

09099f0c <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 9099f0c:	defffa04 	addi	sp,sp,-24
 9099f10:	dfc00515 	stw	ra,20(sp)
 9099f14:	df000415 	stw	fp,16(sp)
 9099f18:	df000404 	addi	fp,sp,16
 9099f1c:	e13ffd15 	stw	r4,-12(fp)
 9099f20:	e17ffe15 	stw	r5,-8(fp)
 9099f24:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9099f28:	e0bffd17 	ldw	r2,-12(fp)
 9099f2c:	10800317 	ldw	r2,12(r2)
 9099f30:	10800404 	addi	r2,r2,16
 9099f34:	1007883a 	mov	r3,r2
 9099f38:	00800074 	movhi	r2,1
 9099f3c:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 9099f40:	e0bffd17 	ldw	r2,-12(fp)
 9099f44:	10800317 	ldw	r2,12(r2)
 9099f48:	10800404 	addi	r2,r2,16
 9099f4c:	1007883a 	mov	r3,r2
 9099f50:	00800074 	movhi	r2,1
 9099f54:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 9099f58:	e0bffd17 	ldw	r2,-12(fp)
 9099f5c:	10800317 	ldw	r2,12(r2)
 9099f60:	10800404 	addi	r2,r2,16
 9099f64:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 9099f68:	e0bffd17 	ldw	r2,-12(fp)
 9099f6c:	10800317 	ldw	r2,12(r2)
 9099f70:	1007883a 	mov	r3,r2
 9099f74:	00803fc4 	movi	r2,255
 9099f78:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 9099f7c:	e13ffd17 	ldw	r4,-12(fp)
 9099f80:	d1602904 	addi	r5,gp,-32604
 9099f84:	90b8cf00 	call	90b8cf0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 9099f88:	d8000015 	stw	zero,0(sp)
 9099f8c:	e13ffe17 	ldw	r4,-8(fp)
 9099f90:	e17fff17 	ldw	r5,-4(fp)
 9099f94:	018242b4 	movhi	r6,2314
 9099f98:	31a79304 	addi	r6,r6,-25012
 9099f9c:	e1fffd17 	ldw	r7,-12(fp)
 9099fa0:	90b90300 	call	90b9030 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 9099fa4:	e037883a 	mov	sp,fp
 9099fa8:	dfc00117 	ldw	ra,4(sp)
 9099fac:	df000017 	ldw	fp,0(sp)
 9099fb0:	dec00204 	addi	sp,sp,8
 9099fb4:	f800283a 	ret

09099fb8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 9099fb8:	defffa04 	addi	sp,sp,-24
 9099fbc:	dfc00515 	stw	ra,20(sp)
 9099fc0:	df000415 	stw	fp,16(sp)
 9099fc4:	df000404 	addi	fp,sp,16
 9099fc8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 9099fcc:	e0bfff17 	ldw	r2,-4(fp)
 9099fd0:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 9099fd4:	e0bfff17 	ldw	r2,-4(fp)
 9099fd8:	10800104 	addi	r2,r2,4
 9099fdc:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9099fe0:	0005303a 	rdctl	r2,status
 9099fe4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9099fe8:	e0fffd17 	ldw	r3,-12(fp)
 9099fec:	00bfff84 	movi	r2,-2
 9099ff0:	1884703a 	and	r2,r3,r2
 9099ff4:	1001703a 	wrctl	status,r2
  
  return context;
 9099ff8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 9099ffc:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 909a000:	90b99ec0 	call	90b99ec <alt_tick>
 909a004:	e0bffe17 	ldw	r2,-8(fp)
 909a008:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909a00c:	e0bffc17 	ldw	r2,-16(fp)
 909a010:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 909a014:	e037883a 	mov	sp,fp
 909a018:	dfc00117 	ldw	ra,4(sp)
 909a01c:	df000017 	ldw	fp,0(sp)
 909a020:	dec00204 	addi	sp,sp,8
 909a024:	f800283a 	ret

0909a028 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 909a028:	defff804 	addi	sp,sp,-32
 909a02c:	dfc00715 	stw	ra,28(sp)
 909a030:	df000615 	stw	fp,24(sp)
 909a034:	df000604 	addi	fp,sp,24
 909a038:	e13ffc15 	stw	r4,-16(fp)
 909a03c:	e17ffd15 	stw	r5,-12(fp)
 909a040:	e1bffe15 	stw	r6,-8(fp)
 909a044:	e1ffff15 	stw	r7,-4(fp)
 909a048:	e0bfff17 	ldw	r2,-4(fp)
 909a04c:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 909a050:	00824374 	movhi	r2,2317
 909a054:	108c5204 	addi	r2,r2,12616
 909a058:	10800017 	ldw	r2,0(r2)
 909a05c:	1004c03a 	cmpne	r2,r2,zero
 909a060:	1000041e 	bne	r2,zero,909a074 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 909a064:	00c24374 	movhi	r3,2317
 909a068:	18cc5204 	addi	r3,r3,12616
 909a06c:	e0bffb17 	ldw	r2,-20(fp)
 909a070:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 909a074:	e0bffc17 	ldw	r2,-16(fp)
 909a078:	10800104 	addi	r2,r2,4
 909a07c:	1007883a 	mov	r3,r2
 909a080:	008001c4 	movi	r2,7
 909a084:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 909a088:	d8000015 	stw	zero,0(sp)
 909a08c:	e13ffd17 	ldw	r4,-12(fp)
 909a090:	e17ffe17 	ldw	r5,-8(fp)
 909a094:	018242b4 	movhi	r6,2314
 909a098:	31a7ee04 	addi	r6,r6,-24648
 909a09c:	e1fffc17 	ldw	r7,-16(fp)
 909a0a0:	90b90300 	call	90b9030 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 909a0a4:	e037883a 	mov	sp,fp
 909a0a8:	dfc00117 	ldw	ra,4(sp)
 909a0ac:	df000017 	ldw	fp,0(sp)
 909a0b0:	dec00204 	addi	sp,sp,8
 909a0b4:	f800283a 	ret

0909a0b8 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 909a0b8:	defffb04 	addi	sp,sp,-20
 909a0bc:	df000115 	stw	fp,4(sp)
 909a0c0:	df000104 	addi	fp,sp,4
 909a0c4:	e1400115 	stw	r5,4(fp)
 909a0c8:	e1800215 	stw	r6,8(fp)
 909a0cc:	e1c00315 	stw	r7,12(fp)
 909a0d0:	e13fff15 	stw	r4,-4(fp)
 909a0d4:	e037883a 	mov	sp,fp
 909a0d8:	df000017 	ldw	fp,0(sp)
 909a0dc:	dec00404 	addi	sp,sp,16
 909a0e0:	f800283a 	ret

0909a0e4 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 909a0e4:	defffb04 	addi	sp,sp,-20
 909a0e8:	df000415 	stw	fp,16(sp)
 909a0ec:	df000404 	addi	fp,sp,16
 909a0f0:	e13ffc15 	stw	r4,-16(fp)
 909a0f4:	e17ffd15 	stw	r5,-12(fp)
 909a0f8:	e1bffe15 	stw	r6,-8(fp)
 909a0fc:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 909a100:	e0fffd17 	ldw	r3,-12(fp)
 909a104:	e0bffc17 	ldw	r2,-16(fp)
 909a108:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 909a10c:	e0fffe17 	ldw	r3,-8(fp)
 909a110:	e0bffc17 	ldw	r2,-16(fp)
 909a114:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 909a118:	e0ffff17 	ldw	r3,-4(fp)
 909a11c:	e0bffc17 	ldw	r2,-16(fp)
 909a120:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 909a124:	e0c00117 	ldw	r3,4(fp)
 909a128:	e0bffc17 	ldw	r2,-16(fp)
 909a12c:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 909a130:	0005883a 	mov	r2,zero
}
 909a134:	e037883a 	mov	sp,fp
 909a138:	df000017 	ldw	fp,0(sp)
 909a13c:	dec00104 	addi	sp,sp,4
 909a140:	f800283a 	ret

0909a144 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 909a144:	defff904 	addi	sp,sp,-28
 909a148:	dfc00615 	stw	ra,24(sp)
 909a14c:	df000515 	stw	fp,20(sp)
 909a150:	df000504 	addi	fp,sp,20
 909a154:	e13ffd15 	stw	r4,-12(fp)
 909a158:	e17ffe15 	stw	r5,-8(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 909a15c:	e03ffb85 	stb	zero,-18(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 909a160:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 909a164:	00000d06 	br	909a19c <tse_mac_sTxWrite+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 909a168:	e0bffc17 	ldw	r2,-16(fp)
 909a16c:	10800044 	addi	r2,r2,1
 909a170:	e0bffc15 	stw	r2,-16(fp)
 909a174:	e0fffc17 	ldw	r3,-16(fp)
 909a178:	008003f4 	movhi	r2,15
 909a17c:	10909044 	addi	r2,r2,16961
 909a180:	1880061e 	bne	r3,r2,909a19c <tse_mac_sTxWrite+0x58>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 909a184:	01024374 	movhi	r4,2317
 909a188:	21338e04 	addi	r4,r4,-12744
 909a18c:	90828380 	call	9082838 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 909a190:	00bffa84 	movi	r2,-22
 909a194:	e0bfff15 	stw	r2,-4(fp)
 909a198:	00002006 	br	909a21c <tse_mac_sTxWrite+0xd8>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 909a19c:	e0bffd17 	ldw	r2,-12(fp)
 909a1a0:	10800117 	ldw	r2,4(r2)
 909a1a4:	10800317 	ldw	r2,12(r2)
 909a1a8:	10800037 	ldwio	r2,0(r2)
 909a1ac:	1080040c 	andi	r2,r2,16
 909a1b0:	1004c03a 	cmpne	r2,r2,zero
 909a1b4:	103fec1e 	bne	r2,zero,909a168 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 909a1b8:	e0bffd17 	ldw	r2,-12(fp)
 909a1bc:	10800117 	ldw	r2,4(r2)
 909a1c0:	10800317 	ldw	r2,12(r2)
 909a1c4:	10800404 	addi	r2,r2,16
 909a1c8:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 909a1cc:	e0bffd17 	ldw	r2,-12(fp)
 909a1d0:	10800117 	ldw	r2,4(r2)
 909a1d4:	10800317 	ldw	r2,12(r2)
 909a1d8:	1007883a 	mov	r3,r2
 909a1dc:	00803fc4 	movi	r2,255
 909a1e0:	18800035 	stwio	r2,0(r3)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 909a1e4:	e0bffd17 	ldw	r2,-12(fp)
 909a1e8:	11000117 	ldw	r4,4(r2)
 909a1ec:	e17ffe17 	ldw	r5,-8(fp)
 909a1f0:	90993100 	call	9099310 <alt_avalon_sgdma_do_sync_transfer>
 909a1f4:	e0bffb85 	stb	r2,-18(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 909a1f8:	e0bffe17 	ldw	r2,-8(fp)
 909a1fc:	10800704 	addi	r2,r2,28
 909a200:	10800037 	ldwio	r2,0(r2)
 909a204:	1007883a 	mov	r3,r2
 909a208:	00bfffc4 	movi	r2,-1
 909a20c:	1884703a 	and	r2,r3,r2
 909a210:	e0bffb0d 	sth	r2,-20(fp)

  return actualBytesTransferred;
 909a214:	e0bffb0b 	ldhu	r2,-20(fp)
 909a218:	e0bfff15 	stw	r2,-4(fp)
 909a21c:	e0bfff17 	ldw	r2,-4(fp)
}
 909a220:	e037883a 	mov	sp,fp
 909a224:	dfc00117 	ldw	ra,4(sp)
 909a228:	df000017 	ldw	fp,0(sp)
 909a22c:	dec00204 	addi	sp,sp,8
 909a230:	f800283a 	ret

0909a234 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 909a234:	defff904 	addi	sp,sp,-28
 909a238:	dfc00615 	stw	ra,24(sp)
 909a23c:	df000515 	stw	fp,20(sp)
 909a240:	df000504 	addi	fp,sp,20
 909a244:	e13ffd15 	stw	r4,-12(fp)
 909a248:	e17ffe15 	stw	r5,-8(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 909a24c:	e03ffb05 	stb	zero,-20(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 909a250:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 909a254:	00000d06 	br	909a28c <tse_mac_aRxRead+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 909a258:	e0bffc17 	ldw	r2,-16(fp)
 909a25c:	10800044 	addi	r2,r2,1
 909a260:	e0bffc15 	stw	r2,-16(fp)
 909a264:	e0fffc17 	ldw	r3,-16(fp)
 909a268:	008003f4 	movhi	r2,15
 909a26c:	10909044 	addi	r2,r2,16961
 909a270:	1880061e 	bne	r3,r2,909a28c <tse_mac_aRxRead+0x58>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 909a274:	01024374 	movhi	r4,2317
 909a278:	21339504 	addi	r4,r4,-12716
 909a27c:	90828380 	call	9082838 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 909a280:	00bffa84 	movi	r2,-22
 909a284:	e0bfff15 	stw	r2,-4(fp)
 909a288:	00000d06 	br	909a2c0 <tse_mac_aRxRead+0x8c>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 909a28c:	e0bffd17 	ldw	r2,-12(fp)
 909a290:	10800217 	ldw	r2,8(r2)
 909a294:	10800317 	ldw	r2,12(r2)
 909a298:	10800037 	ldwio	r2,0(r2)
 909a29c:	1080040c 	andi	r2,r2,16
 909a2a0:	1004c03a 	cmpne	r2,r2,zero
 909a2a4:	103fec1e 	bne	r2,zero,909a258 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 909a2a8:	e0bffd17 	ldw	r2,-12(fp)
 909a2ac:	11000217 	ldw	r4,8(r2)
 909a2b0:	e17ffe17 	ldw	r5,-8(fp)
 909a2b4:	90991d40 	call	90991d4 <alt_avalon_sgdma_do_async_transfer>
 909a2b8:	e0bffb05 	stb	r2,-20(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
 909a2bc:	e03fff15 	stw	zero,-4(fp)
 909a2c0:	e0bfff17 	ldw	r2,-4(fp)
}
 909a2c4:	e037883a 	mov	sp,fp
 909a2c8:	dfc00117 	ldw	ra,4(sp)
 909a2cc:	df000017 	ldw	fp,0(sp)
 909a2d0:	dec00204 	addi	sp,sp,8
 909a2d4:	f800283a 	ret

0909a2d8 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 909a2d8:	defffc04 	addi	sp,sp,-16
 909a2dc:	df000315 	stw	fp,12(sp)
 909a2e0:	df000304 	addi	fp,sp,12
 909a2e4:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909a2e8:	e0bfff17 	ldw	r2,-4(fp)
 909a2ec:	10800204 	addi	r2,r2,8
 909a2f0:	10800037 	ldwio	r2,0(r2)
 909a2f4:	e0bffd15 	stw	r2,-12(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 909a2f8:	e0bfff17 	ldw	r2,-4(fp)
 909a2fc:	10800204 	addi	r2,r2,8
 909a300:	1007883a 	mov	r3,r2
 909a304:	00880204 	movi	r2,8200
 909a308:	18800035 	stwio	r2,0(r3)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 909a30c:	e03ffe15 	stw	zero,-8(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 909a310:	00000306 	br	909a320 <tse_mac_SwReset+0x48>
 909a314:	e0bffe17 	ldw	r2,-8(fp)
 909a318:	10800044 	addi	r2,r2,1
 909a31c:	e0bffe15 	stw	r2,-8(fp)
 909a320:	e0bfff17 	ldw	r2,-4(fp)
 909a324:	10800204 	addi	r2,r2,8
 909a328:	10800037 	ldwio	r2,0(r2)
 909a32c:	1088000c 	andi	r2,r2,8192
 909a330:	1005003a 	cmpeq	r2,r2,zero
 909a334:	1000031e 	bne	r2,zero,909a344 <tse_mac_SwReset+0x6c>
 909a338:	e0bffe17 	ldw	r2,-8(fp)
 909a33c:	1089c410 	cmplti	r2,r2,10000
 909a340:	103ff41e 	bne	r2,zero,909a314 <tse_mac_SwReset+0x3c>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 909a344:	e0bfff17 	ldw	r2,-4(fp)
 909a348:	10800204 	addi	r2,r2,8
 909a34c:	1007883a 	mov	r3,r2
 909a350:	e0bffd17 	ldw	r2,-12(fp)
 909a354:	18800035 	stwio	r2,0(r3)
    return SUCCESS;
 909a358:	0005883a 	mov	r2,zero
}
 909a35c:	e037883a 	mov	sp,fp
 909a360:	df000017 	ldw	fp,0(sp)
 909a364:	dec00104 	addi	sp,sp,4
 909a368:	f800283a 	ret

0909a36c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 909a36c:	defffd04 	addi	sp,sp,-12
 909a370:	df000215 	stw	fp,8(sp)
 909a374:	df000204 	addi	fp,sp,8
 909a378:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909a37c:	e0bfff17 	ldw	r2,-4(fp)
 909a380:	10800204 	addi	r2,r2,8
 909a384:	10800037 	ldwio	r2,0(r2)
 909a388:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 909a38c:	e0fffe17 	ldw	r3,-8(fp)
 909a390:	00bffdc4 	movi	r2,-9
 909a394:	1884703a 	and	r2,r3,r2
 909a398:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 909a39c:	e0bfff17 	ldw	r2,-4(fp)
 909a3a0:	10800204 	addi	r2,r2,8
 909a3a4:	1007883a 	mov	r3,r2
 909a3a8:	e0bffe17 	ldw	r2,-8(fp)
 909a3ac:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909a3b0:	0005883a 	mov	r2,zero
}
 909a3b4:	e037883a 	mov	sp,fp
 909a3b8:	df000017 	ldw	fp,0(sp)
 909a3bc:	dec00104 	addi	sp,sp,4
 909a3c0:	f800283a 	ret

0909a3c4 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 909a3c4:	defffd04 	addi	sp,sp,-12
 909a3c8:	df000215 	stw	fp,8(sp)
 909a3cc:	df000204 	addi	fp,sp,8
 909a3d0:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909a3d4:	e0bfff17 	ldw	r2,-4(fp)
 909a3d8:	10800204 	addi	r2,r2,8
 909a3dc:	10800037 	ldwio	r2,0(r2)
 909a3e0:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909a3e4:	e0bffe17 	ldw	r2,-8(fp)
 909a3e8:	10800214 	ori	r2,r2,8
 909a3ec:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 909a3f0:	e0bfff17 	ldw	r2,-4(fp)
 909a3f4:	10800204 	addi	r2,r2,8
 909a3f8:	1007883a 	mov	r3,r2
 909a3fc:	e0bffe17 	ldw	r2,-8(fp)
 909a400:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909a404:	0005883a 	mov	r2,zero
}
 909a408:	e037883a 	mov	sp,fp
 909a40c:	df000017 	ldw	fp,0(sp)
 909a410:	dec00104 	addi	sp,sp,4
 909a414:	f800283a 	ret

0909a418 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 909a418:	defffa04 	addi	sp,sp,-24
 909a41c:	dfc00515 	stw	ra,20(sp)
 909a420:	df000415 	stw	fp,16(sp)
 909a424:	dc000315 	stw	r16,12(sp)
 909a428:	df000304 	addi	fp,sp,12
 909a42c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 909a430:	e03ffd15 	stw	zero,-12(fp)
 909a434:	00002706 	br	909a4d4 <alt_tse_phy_add_profile+0xbc>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 909a438:	e0bffd17 	ldw	r2,-12(fp)
 909a43c:	00c243b4 	movhi	r3,2318
 909a440:	18f2fd04 	addi	r3,r3,-13324
 909a444:	1085883a 	add	r2,r2,r2
 909a448:	1085883a 	add	r2,r2,r2
 909a44c:	10c5883a 	add	r2,r2,r3
 909a450:	10800017 	ldw	r2,0(r2)
 909a454:	10c01417 	ldw	r3,80(r2)
 909a458:	e0bffe17 	ldw	r2,-8(fp)
 909a45c:	10801417 	ldw	r2,80(r2)
 909a460:	1880191e 	bne	r3,r2,909a4c8 <alt_tse_phy_add_profile+0xb0>
 909a464:	e0bffd17 	ldw	r2,-12(fp)
 909a468:	00c243b4 	movhi	r3,2318
 909a46c:	18f2fd04 	addi	r3,r3,-13324
 909a470:	1085883a 	add	r2,r2,r2
 909a474:	1085883a 	add	r2,r2,r2
 909a478:	10c5883a 	add	r2,r2,r3
 909a47c:	10800017 	ldw	r2,0(r2)
 909a480:	10c01503 	ldbu	r3,84(r2)
 909a484:	e0bffe17 	ldw	r2,-8(fp)
 909a488:	10801503 	ldbu	r2,84(r2)
 909a48c:	18c03fcc 	andi	r3,r3,255
 909a490:	10803fcc 	andi	r2,r2,255
 909a494:	18800c1e 	bne	r3,r2,909a4c8 <alt_tse_phy_add_profile+0xb0>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 909a498:	e0bffe17 	ldw	r2,-8(fp)
 909a49c:	10801417 	ldw	r2,80(r2)
 909a4a0:	100b883a 	mov	r5,r2
 909a4a4:	e0bffe17 	ldw	r2,-8(fp)
 909a4a8:	10801503 	ldbu	r2,84(r2)
 909a4ac:	11803fcc 	andi	r6,r2,255
 909a4b0:	01024374 	movhi	r4,2317
 909a4b4:	21339c04 	addi	r4,r4,-12688
 909a4b8:	90825100 	call	9082510 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 909a4bc:	01024374 	movhi	r4,2317
 909a4c0:	2133b004 	addi	r4,r4,-12608
 909a4c4:	90828380 	call	9082838 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 909a4c8:	e0bffd17 	ldw	r2,-12(fp)
 909a4cc:	10800044 	addi	r2,r2,1
 909a4d0:	e0bffd15 	stw	r2,-12(fp)
 909a4d4:	d0a07f03 	ldbu	r2,-32260(gp)
 909a4d8:	10c03fcc 	andi	r3,r2,255
 909a4dc:	e0bffd17 	ldw	r2,-12(fp)
 909a4e0:	10ffd516 	blt	r2,r3,909a438 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 909a4e4:	d0a07f03 	ldbu	r2,-32260(gp)
 909a4e8:	14003fcc 	andi	r16,r2,255
 909a4ec:	01001904 	movi	r4,100
 909a4f0:	90ca52c0 	call	90ca52c <malloc>
 909a4f4:	1009883a 	mov	r4,r2
 909a4f8:	00c243b4 	movhi	r3,2318
 909a4fc:	18f2fd04 	addi	r3,r3,-13324
 909a500:	8405883a 	add	r2,r16,r16
 909a504:	1085883a 	add	r2,r2,r2
 909a508:	10c5883a 	add	r2,r2,r3
 909a50c:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 909a510:	d0a07f03 	ldbu	r2,-32260(gp)
 909a514:	10803fcc 	andi	r2,r2,255
 909a518:	00c243b4 	movhi	r3,2318
 909a51c:	18f2fd04 	addi	r3,r3,-13324
 909a520:	1085883a 	add	r2,r2,r2
 909a524:	1085883a 	add	r2,r2,r2
 909a528:	10c5883a 	add	r2,r2,r3
 909a52c:	10800017 	ldw	r2,0(r2)
 909a530:	1004c03a 	cmpne	r2,r2,zero
 909a534:	1000081e 	bne	r2,zero,909a558 <alt_tse_phy_add_profile+0x140>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 909a538:	d0a07f03 	ldbu	r2,-32260(gp)
 909a53c:	11403fcc 	andi	r5,r2,255
 909a540:	01024374 	movhi	r4,2317
 909a544:	2133c804 	addi	r4,r4,-12512
 909a548:	90825100 	call	9082510 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 909a54c:	00bfffc4 	movi	r2,-1
 909a550:	e0bfff15 	stw	r2,-4(fp)
 909a554:	00001f06 	br	909a5d4 <alt_tse_phy_add_profile+0x1bc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 909a558:	d0a07f03 	ldbu	r2,-32260(gp)
 909a55c:	10803fcc 	andi	r2,r2,255
 909a560:	00c243b4 	movhi	r3,2318
 909a564:	18f2fd04 	addi	r3,r3,-13324
 909a568:	1085883a 	add	r2,r2,r2
 909a56c:	1085883a 	add	r2,r2,r2
 909a570:	10c5883a 	add	r2,r2,r3
 909a574:	10800017 	ldw	r2,0(r2)
 909a578:	e0fffe17 	ldw	r3,-8(fp)
 909a57c:	1009883a 	mov	r4,r2
 909a580:	180b883a 	mov	r5,r3
 909a584:	01801904 	movi	r6,100
 909a588:	90822780 	call	9082278 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 909a58c:	d0a07f03 	ldbu	r2,-32260(gp)
 909a590:	10803fcc 	andi	r2,r2,255
 909a594:	00c243b4 	movhi	r3,2318
 909a598:	18f2fd04 	addi	r3,r3,-13324
 909a59c:	1085883a 	add	r2,r2,r2
 909a5a0:	1085883a 	add	r2,r2,r2
 909a5a4:	10c5883a 	add	r2,r2,r3
 909a5a8:	10800017 	ldw	r2,0(r2)
 909a5ac:	1009883a 	mov	r4,r2
 909a5b0:	e17ffe17 	ldw	r5,-8(fp)
 909a5b4:	90ca5b40 	call	90ca5b4 <strcpy>
    
    phy_profile_count++;
 909a5b8:	d0a07f03 	ldbu	r2,-32260(gp)
 909a5bc:	10800044 	addi	r2,r2,1
 909a5c0:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 909a5c4:	d0a07f03 	ldbu	r2,-32260(gp)
 909a5c8:	10803fcc 	andi	r2,r2,255
 909a5cc:	10bfffc4 	addi	r2,r2,-1
 909a5d0:	e0bfff15 	stw	r2,-4(fp)
 909a5d4:	e0bfff17 	ldw	r2,-4(fp)
}
 909a5d8:	e037883a 	mov	sp,fp
 909a5dc:	dfc00217 	ldw	ra,8(sp)
 909a5e0:	df000117 	ldw	fp,4(sp)
 909a5e4:	dc000017 	ldw	r16,0(sp)
 909a5e8:	dec00304 	addi	sp,sp,12
 909a5ec:	f800283a 	ret

0909a5f0 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 909a5f0:	defff104 	addi	sp,sp,-60
 909a5f4:	dfc00e15 	stw	ra,56(sp)
 909a5f8:	df000d15 	stw	fp,52(sp)
 909a5fc:	dc000c15 	stw	r16,48(sp)
 909a600:	df000c04 	addi	fp,sp,48
 909a604:	e13ffb15 	stw	r4,-20(fp)
 909a608:	e17ffc15 	stw	r5,-16(fp)
 909a60c:	e1bffd15 	stw	r6,-12(fp)
 909a610:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 909a614:	e0bffb17 	ldw	r2,-20(fp)
 909a618:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 909a61c:	e0bffc17 	ldw	r2,-16(fp)
 909a620:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 909a624:	e0bffd17 	ldw	r2,-12(fp)
 909a628:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 909a62c:	e0bffe17 	ldw	r2,-8(fp)
 909a630:	e0bff515 	stw	r2,-44(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 909a634:	e0800317 	ldw	r2,12(fp)
 909a638:	e0bff415 	stw	r2,-48(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 909a63c:	e0bff817 	ldw	r2,-32(fp)
 909a640:	10800303 	ldbu	r2,12(r2)
 909a644:	10803fcc 	andi	r2,r2,255
 909a648:	1004c03a 	cmpne	r2,r2,zero
 909a64c:	1000031e 	bne	r2,zero,909a65c <alt_tse_system_add_sys+0x6c>
		loop_end = 1;
 909a650:	00800044 	movi	r2,1
 909a654:	e0bff915 	stw	r2,-28(fp)
 909a658:	00001006 	br	909a69c <alt_tse_system_add_sys+0xac>
	}
	else if(pmac->tse_num_of_channel > 0) {
 909a65c:	e0bff817 	ldw	r2,-32(fp)
 909a660:	10800303 	ldbu	r2,12(r2)
 909a664:	10803fcc 	andi	r2,r2,255
 909a668:	1005003a 	cmpeq	r2,r2,zero
 909a66c:	1000051e 	bne	r2,zero,909a684 <alt_tse_system_add_sys+0x94>
		loop_end = pmac->tse_num_of_channel; 
 909a670:	e0bff817 	ldw	r2,-32(fp)
 909a674:	10800303 	ldbu	r2,12(r2)
 909a678:	10803fcc 	andi	r2,r2,255
 909a67c:	e0bff915 	stw	r2,-28(fp)
 909a680:	00000606 	br	909a69c <alt_tse_system_add_sys+0xac>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 909a684:	01024374 	movhi	r4,2317
 909a688:	2133d704 	addi	r4,r4,-12452
 909a68c:	90828380 	call	9082838 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909a690:	00bfffc4 	movi	r2,-1
 909a694:	e0bfff15 	stw	r2,-4(fp)
 909a698:	00025306 	br	909afe8 <alt_tse_system_add_sys+0x9f8>
	}

	for(i = 0; i < loop_end; i++) {
 909a69c:	e03ffa15 	stw	zero,-24(fp)
 909a6a0:	00024d06 	br	909afd8 <alt_tse_system_add_sys+0x9e8>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 909a6a4:	d0a07f83 	ldbu	r2,-32258(gp)
 909a6a8:	10803fcc 	andi	r2,r2,255
 909a6ac:	1080201c 	xori	r2,r2,128
 909a6b0:	10bfe004 	addi	r2,r2,-128
 909a6b4:	10800110 	cmplti	r2,r2,4
 909a6b8:	10000b1e 	bne	r2,zero,909a6e8 <alt_tse_system_add_sys+0xf8>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 909a6bc:	01024374 	movhi	r4,2317
 909a6c0:	2133e304 	addi	r4,r4,-12404
 909a6c4:	90828380 	call	9082838 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 909a6c8:	d0a07f83 	ldbu	r2,-32258(gp)
 909a6cc:	11803fcc 	andi	r6,r2,255
 909a6d0:	3180201c 	xori	r6,r6,128
 909a6d4:	31bfe004 	addi	r6,r6,-128
 909a6d8:	01024374 	movhi	r4,2317
 909a6dc:	2133f304 	addi	r4,r4,-12340
 909a6e0:	01400104 	movi	r5,4
 909a6e4:	90825100 	call	9082510 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 909a6e8:	e0bff817 	ldw	r2,-32(fp)
 909a6ec:	1004c03a 	cmpne	r2,r2,zero
 909a6f0:	1000091e 	bne	r2,zero,909a718 <alt_tse_system_add_sys+0x128>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 909a6f4:	01024374 	movhi	r4,2317
 909a6f8:	21340204 	addi	r4,r4,-12280
 909a6fc:	90828380 	call	9082838 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 909a700:	01024374 	movhi	r4,2317
 909a704:	21340c04 	addi	r4,r4,-12240
 909a708:	90828380 	call	9082838 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909a70c:	00bfffc4 	movi	r2,-1
 909a710:	e0bfff15 	stw	r2,-4(fp)
 909a714:	00023406 	br	909afe8 <alt_tse_system_add_sys+0x9f8>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 909a718:	d0a07f83 	ldbu	r2,-32258(gp)
 909a71c:	11403fcc 	andi	r5,r2,255
 909a720:	2940201c 	xori	r5,r5,128
 909a724:	297fe004 	addi	r5,r5,-128
 909a728:	e0bff817 	ldw	r2,-32(fp)
 909a72c:	10c00017 	ldw	r3,0(r2)
 909a730:	e0bffa17 	ldw	r2,-24(fp)
 909a734:	100492ba 	slli	r2,r2,10
 909a738:	1889883a 	add	r4,r3,r2
 909a73c:	00c24374 	movhi	r3,2317
 909a740:	18c3a904 	addi	r3,r3,3748
 909a744:	28801224 	muli	r2,r5,72
 909a748:	10c5883a 	add	r2,r2,r3
 909a74c:	11000015 	stw	r4,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 909a750:	d0a07f83 	ldbu	r2,-32258(gp)
 909a754:	11003fcc 	andi	r4,r2,255
 909a758:	2100201c 	xori	r4,r4,128
 909a75c:	213fe004 	addi	r4,r4,-128
 909a760:	e0bff817 	ldw	r2,-32(fp)
 909a764:	1140010b 	ldhu	r5,4(r2)
 909a768:	00c24374 	movhi	r3,2317
 909a76c:	18c3a904 	addi	r3,r3,3748
 909a770:	20801224 	muli	r2,r4,72
 909a774:	10c5883a 	add	r2,r2,r3
 909a778:	10800104 	addi	r2,r2,4
 909a77c:	1140000d 	sth	r5,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 909a780:	d0a07f83 	ldbu	r2,-32258(gp)
 909a784:	11003fcc 	andi	r4,r2,255
 909a788:	2100201c 	xori	r4,r4,128
 909a78c:	213fe004 	addi	r4,r4,-128
 909a790:	e0bff817 	ldw	r2,-32(fp)
 909a794:	1140018b 	ldhu	r5,6(r2)
 909a798:	00c24374 	movhi	r3,2317
 909a79c:	18c3a904 	addi	r3,r3,3748
 909a7a0:	20801224 	muli	r2,r4,72
 909a7a4:	10c5883a 	add	r2,r2,r3
 909a7a8:	10800104 	addi	r2,r2,4
 909a7ac:	1140008d 	sth	r5,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 909a7b0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a7b4:	11003fcc 	andi	r4,r2,255
 909a7b8:	2100201c 	xori	r4,r4,128
 909a7bc:	213fe004 	addi	r4,r4,-128
 909a7c0:	e0bff817 	ldw	r2,-32(fp)
 909a7c4:	11400203 	ldbu	r5,8(r2)
 909a7c8:	00c24374 	movhi	r3,2317
 909a7cc:	18c3a904 	addi	r3,r3,3748
 909a7d0:	20801224 	muli	r2,r4,72
 909a7d4:	10c5883a 	add	r2,r2,r3
 909a7d8:	10800204 	addi	r2,r2,8
 909a7dc:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 909a7e0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a7e4:	11003fcc 	andi	r4,r2,255
 909a7e8:	2100201c 	xori	r4,r4,128
 909a7ec:	213fe004 	addi	r4,r4,-128
 909a7f0:	e0bff817 	ldw	r2,-32(fp)
 909a7f4:	11400243 	ldbu	r5,9(r2)
 909a7f8:	00c24374 	movhi	r3,2317
 909a7fc:	18c3a904 	addi	r3,r3,3748
 909a800:	20801224 	muli	r2,r4,72
 909a804:	10c5883a 	add	r2,r2,r3
 909a808:	10800204 	addi	r2,r2,8
 909a80c:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 909a810:	d0a07f83 	ldbu	r2,-32258(gp)
 909a814:	11003fcc 	andi	r4,r2,255
 909a818:	2100201c 	xori	r4,r4,128
 909a81c:	213fe004 	addi	r4,r4,-128
 909a820:	e0bff817 	ldw	r2,-32(fp)
 909a824:	11400283 	ldbu	r5,10(r2)
 909a828:	00c24374 	movhi	r3,2317
 909a82c:	18c3a904 	addi	r3,r3,3748
 909a830:	20801224 	muli	r2,r4,72
 909a834:	10c5883a 	add	r2,r2,r3
 909a838:	10800204 	addi	r2,r2,8
 909a83c:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 909a840:	d0a07f83 	ldbu	r2,-32258(gp)
 909a844:	11003fcc 	andi	r4,r2,255
 909a848:	2100201c 	xori	r4,r4,128
 909a84c:	213fe004 	addi	r4,r4,-128
 909a850:	e0bff817 	ldw	r2,-32(fp)
 909a854:	114002c3 	ldbu	r5,11(r2)
 909a858:	00c24374 	movhi	r3,2317
 909a85c:	18c3a904 	addi	r3,r3,3748
 909a860:	20801224 	muli	r2,r4,72
 909a864:	10c5883a 	add	r2,r2,r3
 909a868:	10800204 	addi	r2,r2,8
 909a86c:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 909a870:	d0a07f83 	ldbu	r2,-32258(gp)
 909a874:	11003fcc 	andi	r4,r2,255
 909a878:	2100201c 	xori	r4,r4,128
 909a87c:	213fe004 	addi	r4,r4,-128
 909a880:	e0bff817 	ldw	r2,-32(fp)
 909a884:	11400303 	ldbu	r5,12(r2)
 909a888:	00c24374 	movhi	r3,2317
 909a88c:	18c3a904 	addi	r3,r3,3748
 909a890:	20801224 	muli	r2,r4,72
 909a894:	10c5883a 	add	r2,r2,r3
 909a898:	10800304 	addi	r2,r2,12
 909a89c:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 909a8a0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a8a4:	11003fcc 	andi	r4,r2,255
 909a8a8:	2100201c 	xori	r4,r4,128
 909a8ac:	213fe004 	addi	r4,r4,-128
 909a8b0:	e0bff817 	ldw	r2,-32(fp)
 909a8b4:	11400343 	ldbu	r5,13(r2)
 909a8b8:	00c24374 	movhi	r3,2317
 909a8bc:	18c3a904 	addi	r3,r3,3748
 909a8c0:	20801224 	muli	r2,r4,72
 909a8c4:	10c5883a 	add	r2,r2,r3
 909a8c8:	10800304 	addi	r2,r2,12
 909a8cc:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 909a8d0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a8d4:	11003fcc 	andi	r4,r2,255
 909a8d8:	2100201c 	xori	r4,r4,128
 909a8dc:	213fe004 	addi	r4,r4,-128
 909a8e0:	e0bff817 	ldw	r2,-32(fp)
 909a8e4:	11400383 	ldbu	r5,14(r2)
 909a8e8:	00c24374 	movhi	r3,2317
 909a8ec:	18c3a904 	addi	r3,r3,3748
 909a8f0:	20801224 	muli	r2,r4,72
 909a8f4:	10c5883a 	add	r2,r2,r3
 909a8f8:	10800304 	addi	r2,r2,12
 909a8fc:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 909a900:	d0a07f83 	ldbu	r2,-32258(gp)
 909a904:	11003fcc 	andi	r4,r2,255
 909a908:	2100201c 	xori	r4,r4,128
 909a90c:	213fe004 	addi	r4,r4,-128
 909a910:	e0bff817 	ldw	r2,-32(fp)
 909a914:	114003c3 	ldbu	r5,15(r2)
 909a918:	00c24374 	movhi	r3,2317
 909a91c:	18c3a904 	addi	r3,r3,3748
 909a920:	20801224 	muli	r2,r4,72
 909a924:	10c5883a 	add	r2,r2,r3
 909a928:	10800304 	addi	r2,r2,12
 909a92c:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 909a930:	d0a07f83 	ldbu	r2,-32258(gp)
 909a934:	11003fcc 	andi	r4,r2,255
 909a938:	2100201c 	xori	r4,r4,128
 909a93c:	213fe004 	addi	r4,r4,-128
 909a940:	e0bff817 	ldw	r2,-32(fp)
 909a944:	11400403 	ldbu	r5,16(r2)
 909a948:	00c24374 	movhi	r3,2317
 909a94c:	18c3a904 	addi	r3,r3,3748
 909a950:	20801224 	muli	r2,r4,72
 909a954:	10c5883a 	add	r2,r2,r3
 909a958:	10800404 	addi	r2,r2,16
 909a95c:	11400005 	stb	r5,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 909a960:	e0bff717 	ldw	r2,-36(fp)
 909a964:	1004c03a 	cmpne	r2,r2,zero
 909a968:	10000d1e 	bne	r2,zero,909a9a0 <alt_tse_system_add_sys+0x3b0>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 909a96c:	01024374 	movhi	r4,2317
 909a970:	21341e04 	addi	r4,r4,-12168
 909a974:	90828380 	call	9082838 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 909a978:	d0a07f83 	ldbu	r2,-32258(gp)
 909a97c:	11403fcc 	andi	r5,r2,255
 909a980:	2940201c 	xori	r5,r5,128
 909a984:	297fe004 	addi	r5,r5,-128
 909a988:	01024374 	movhi	r4,2317
 909a98c:	21342904 	addi	r4,r4,-12124
 909a990:	90825100 	call	9082510 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909a994:	00bfffc4 	movi	r2,-1
 909a998:	e0bfff15 	stw	r2,-4(fp)
 909a99c:	00019206 	br	909afe8 <alt_tse_system_add_sys+0x9f8>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 909a9a0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a9a4:	14003fcc 	andi	r16,r2,255
 909a9a8:	8400201c 	xori	r16,r16,128
 909a9ac:	843fe004 	addi	r16,r16,-128
 909a9b0:	e0bff717 	ldw	r2,-36(fp)
 909a9b4:	11000017 	ldw	r4,0(r2)
 909a9b8:	90830d40 	call	90830d4 <strlen>
 909a9bc:	11000044 	addi	r4,r2,1
 909a9c0:	90ca52c0 	call	90ca52c <malloc>
 909a9c4:	1009883a 	mov	r4,r2
 909a9c8:	00c24374 	movhi	r3,2317
 909a9cc:	18c3a904 	addi	r3,r3,3748
 909a9d0:	80801224 	muli	r2,r16,72
 909a9d4:	10c5883a 	add	r2,r2,r3
 909a9d8:	10800504 	addi	r2,r2,20
 909a9dc:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 909a9e0:	d0a07f83 	ldbu	r2,-32258(gp)
 909a9e4:	10803fcc 	andi	r2,r2,255
 909a9e8:	1080201c 	xori	r2,r2,128
 909a9ec:	10bfe004 	addi	r2,r2,-128
 909a9f0:	00c24374 	movhi	r3,2317
 909a9f4:	18c3a904 	addi	r3,r3,3748
 909a9f8:	10801224 	muli	r2,r2,72
 909a9fc:	10c5883a 	add	r2,r2,r3
 909aa00:	10800504 	addi	r2,r2,20
 909aa04:	10800017 	ldw	r2,0(r2)
 909aa08:	1004c03a 	cmpne	r2,r2,zero
 909aa0c:	10000a1e 	bne	r2,zero,909aa38 <alt_tse_system_add_sys+0x448>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 909aa10:	d0a07f83 	ldbu	r2,-32258(gp)
 909aa14:	11403fcc 	andi	r5,r2,255
 909aa18:	2940201c 	xori	r5,r5,128
 909aa1c:	297fe004 	addi	r5,r5,-128
 909aa20:	01024374 	movhi	r4,2317
 909aa24:	21344104 	addi	r4,r4,-12028
 909aa28:	90825100 	call	9082510 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 909aa2c:	00bfffc4 	movi	r2,-1
 909aa30:	e0bfff15 	stw	r2,-4(fp)
 909aa34:	00016c06 	br	909afe8 <alt_tse_system_add_sys+0x9f8>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 909aa38:	d0a07f83 	ldbu	r2,-32258(gp)
 909aa3c:	10803fcc 	andi	r2,r2,255
 909aa40:	1080201c 	xori	r2,r2,128
 909aa44:	10bfe004 	addi	r2,r2,-128
 909aa48:	00c24374 	movhi	r3,2317
 909aa4c:	18c3a904 	addi	r3,r3,3748
 909aa50:	10801224 	muli	r2,r2,72
 909aa54:	10c5883a 	add	r2,r2,r3
 909aa58:	10800504 	addi	r2,r2,20
 909aa5c:	11000017 	ldw	r4,0(r2)
 909aa60:	e0bff717 	ldw	r2,-36(fp)
 909aa64:	11400017 	ldw	r5,0(r2)
 909aa68:	90ca5b40 	call	90ca5b4 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 909aa6c:	d0a07f83 	ldbu	r2,-32258(gp)
 909aa70:	14003fcc 	andi	r16,r2,255
 909aa74:	8400201c 	xori	r16,r16,128
 909aa78:	843fe004 	addi	r16,r16,-128
 909aa7c:	e0bff717 	ldw	r2,-36(fp)
 909aa80:	11000117 	ldw	r4,4(r2)
 909aa84:	90830d40 	call	90830d4 <strlen>
 909aa88:	11000044 	addi	r4,r2,1
 909aa8c:	90ca52c0 	call	90ca52c <malloc>
 909aa90:	1009883a 	mov	r4,r2
 909aa94:	00c24374 	movhi	r3,2317
 909aa98:	18c3a904 	addi	r3,r3,3748
 909aa9c:	80801224 	muli	r2,r16,72
 909aaa0:	10c5883a 	add	r2,r2,r3
 909aaa4:	10800604 	addi	r2,r2,24
 909aaa8:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 909aaac:	d0a07f83 	ldbu	r2,-32258(gp)
 909aab0:	10803fcc 	andi	r2,r2,255
 909aab4:	1080201c 	xori	r2,r2,128
 909aab8:	10bfe004 	addi	r2,r2,-128
 909aabc:	00c24374 	movhi	r3,2317
 909aac0:	18c3a904 	addi	r3,r3,3748
 909aac4:	10801224 	muli	r2,r2,72
 909aac8:	10c5883a 	add	r2,r2,r3
 909aacc:	10800604 	addi	r2,r2,24
 909aad0:	10800017 	ldw	r2,0(r2)
 909aad4:	1004c03a 	cmpne	r2,r2,zero
 909aad8:	10000a1e 	bne	r2,zero,909ab04 <alt_tse_system_add_sys+0x514>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 909aadc:	d0a07f83 	ldbu	r2,-32258(gp)
 909aae0:	11403fcc 	andi	r5,r2,255
 909aae4:	2940201c 	xori	r5,r5,128
 909aae8:	297fe004 	addi	r5,r5,-128
 909aaec:	01024374 	movhi	r4,2317
 909aaf0:	21345404 	addi	r4,r4,-11952
 909aaf4:	90825100 	call	9082510 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 909aaf8:	00bfffc4 	movi	r2,-1
 909aafc:	e0bfff15 	stw	r2,-4(fp)
 909ab00:	00013906 	br	909afe8 <alt_tse_system_add_sys+0x9f8>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 909ab04:	d0a07f83 	ldbu	r2,-32258(gp)
 909ab08:	10803fcc 	andi	r2,r2,255
 909ab0c:	1080201c 	xori	r2,r2,128
 909ab10:	10bfe004 	addi	r2,r2,-128
 909ab14:	00c24374 	movhi	r3,2317
 909ab18:	18c3a904 	addi	r3,r3,3748
 909ab1c:	10801224 	muli	r2,r2,72
 909ab20:	10c5883a 	add	r2,r2,r3
 909ab24:	10800604 	addi	r2,r2,24
 909ab28:	11000017 	ldw	r4,0(r2)
 909ab2c:	e0bff717 	ldw	r2,-36(fp)
 909ab30:	11400117 	ldw	r5,4(r2)
 909ab34:	90ca5b40 	call	90ca5b4 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 909ab38:	d0a07f83 	ldbu	r2,-32258(gp)
 909ab3c:	11003fcc 	andi	r4,r2,255
 909ab40:	2100201c 	xori	r4,r4,128
 909ab44:	213fe004 	addi	r4,r4,-128
 909ab48:	e0bff717 	ldw	r2,-36(fp)
 909ab4c:	1140020b 	ldhu	r5,8(r2)
 909ab50:	00c24374 	movhi	r3,2317
 909ab54:	18c3a904 	addi	r3,r3,3748
 909ab58:	20801224 	muli	r2,r4,72
 909ab5c:	10c5883a 	add	r2,r2,r3
 909ab60:	10800704 	addi	r2,r2,28
 909ab64:	1140000d 	sth	r5,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 909ab68:	e0bff617 	ldw	r2,-40(fp)
 909ab6c:	1004c03a 	cmpne	r2,r2,zero
 909ab70:	1000151e 	bne	r2,zero,909abc8 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 909ab74:	d0a07f83 	ldbu	r2,-32258(gp)
 909ab78:	10803fcc 	andi	r2,r2,255
 909ab7c:	1080201c 	xori	r2,r2,128
 909ab80:	10bfe004 	addi	r2,r2,-128
 909ab84:	00c24374 	movhi	r3,2317
 909ab88:	18c3a904 	addi	r3,r3,3748
 909ab8c:	10801224 	muli	r2,r2,72
 909ab90:	10c5883a 	add	r2,r2,r3
 909ab94:	10800704 	addi	r2,r2,28
 909ab98:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 909ab9c:	d0a07f83 	ldbu	r2,-32258(gp)
 909aba0:	10803fcc 	andi	r2,r2,255
 909aba4:	1080201c 	xori	r2,r2,128
 909aba8:	10bfe004 	addi	r2,r2,-128
 909abac:	00c24374 	movhi	r3,2317
 909abb0:	18c3a904 	addi	r3,r3,3748
 909abb4:	10801224 	muli	r2,r2,72
 909abb8:	10c5883a 	add	r2,r2,r3
 909abbc:	10800804 	addi	r2,r2,32
 909abc0:	10000015 	stw	zero,0(r2)
 909abc4:	00001806 	br	909ac28 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 909abc8:	d0a07f83 	ldbu	r2,-32258(gp)
 909abcc:	11003fcc 	andi	r4,r2,255
 909abd0:	2100201c 	xori	r4,r4,128
 909abd4:	213fe004 	addi	r4,r4,-128
 909abd8:	e0bff617 	ldw	r2,-40(fp)
 909abdc:	11400003 	ldbu	r5,0(r2)
 909abe0:	00c24374 	movhi	r3,2317
 909abe4:	18c3a904 	addi	r3,r3,3748
 909abe8:	20801224 	muli	r2,r4,72
 909abec:	10c5883a 	add	r2,r2,r3
 909abf0:	10800704 	addi	r2,r2,28
 909abf4:	11400085 	stb	r5,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 909abf8:	d0a07f83 	ldbu	r2,-32258(gp)
 909abfc:	11003fcc 	andi	r4,r2,255
 909ac00:	2100201c 	xori	r4,r4,128
 909ac04:	213fe004 	addi	r4,r4,-128
 909ac08:	e0bff617 	ldw	r2,-40(fp)
 909ac0c:	11400117 	ldw	r5,4(r2)
 909ac10:	00c24374 	movhi	r3,2317
 909ac14:	18c3a904 	addi	r3,r3,3748
 909ac18:	20801224 	muli	r2,r4,72
 909ac1c:	10c5883a 	add	r2,r2,r3
 909ac20:	10800804 	addi	r2,r2,32
 909ac24:	11400015 	stw	r5,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 909ac28:	e0bff517 	ldw	r2,-44(fp)
 909ac2c:	1004c03a 	cmpne	r2,r2,zero
 909ac30:	1000471e 	bne	r2,zero,909ad50 <alt_tse_system_add_sys+0x760>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 909ac34:	d0a07f83 	ldbu	r2,-32258(gp)
 909ac38:	10803fcc 	andi	r2,r2,255
 909ac3c:	1080201c 	xori	r2,r2,128
 909ac40:	10bfe004 	addi	r2,r2,-128
 909ac44:	00c24374 	movhi	r3,2317
 909ac48:	18c3a904 	addi	r3,r3,3748
 909ac4c:	10801224 	muli	r2,r2,72
 909ac50:	10c5883a 	add	r2,r2,r3
 909ac54:	10800904 	addi	r2,r2,36
 909ac58:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 909ac5c:	d0a07f83 	ldbu	r2,-32258(gp)
 909ac60:	10803fcc 	andi	r2,r2,255
 909ac64:	1080201c 	xori	r2,r2,128
 909ac68:	10bfe004 	addi	r2,r2,-128
 909ac6c:	00c24374 	movhi	r3,2317
 909ac70:	18c3a904 	addi	r3,r3,3748
 909ac74:	10801224 	muli	r2,r2,72
 909ac78:	10c5883a 	add	r2,r2,r3
 909ac7c:	10800a04 	addi	r2,r2,40
 909ac80:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 909ac84:	d0a07f83 	ldbu	r2,-32258(gp)
 909ac88:	10803fcc 	andi	r2,r2,255
 909ac8c:	1080201c 	xori	r2,r2,128
 909ac90:	10bfe004 	addi	r2,r2,-128
 909ac94:	00c24374 	movhi	r3,2317
 909ac98:	18c3a904 	addi	r3,r3,3748
 909ac9c:	10801224 	muli	r2,r2,72
 909aca0:	10c5883a 	add	r2,r2,r3
 909aca4:	10800b04 	addi	r2,r2,44
 909aca8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 909acac:	d0a07f83 	ldbu	r2,-32258(gp)
 909acb0:	10803fcc 	andi	r2,r2,255
 909acb4:	1080201c 	xori	r2,r2,128
 909acb8:	10bfe004 	addi	r2,r2,-128
 909acbc:	00c24374 	movhi	r3,2317
 909acc0:	18c3a904 	addi	r3,r3,3748
 909acc4:	10801224 	muli	r2,r2,72
 909acc8:	10c5883a 	add	r2,r2,r3
 909accc:	10800c04 	addi	r2,r2,48
 909acd0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 909acd4:	d0a07f83 	ldbu	r2,-32258(gp)
 909acd8:	10803fcc 	andi	r2,r2,255
 909acdc:	1080201c 	xori	r2,r2,128
 909ace0:	10bfe004 	addi	r2,r2,-128
 909ace4:	00c24374 	movhi	r3,2317
 909ace8:	18c3a904 	addi	r3,r3,3748
 909acec:	10801224 	muli	r2,r2,72
 909acf0:	10c5883a 	add	r2,r2,r3
 909acf4:	10800d04 	addi	r2,r2,52
 909acf8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 909acfc:	d0a07f83 	ldbu	r2,-32258(gp)
 909ad00:	10803fcc 	andi	r2,r2,255
 909ad04:	1080201c 	xori	r2,r2,128
 909ad08:	10bfe004 	addi	r2,r2,-128
 909ad0c:	00c24374 	movhi	r3,2317
 909ad10:	18c3a904 	addi	r3,r3,3748
 909ad14:	10801224 	muli	r2,r2,72
 909ad18:	10c5883a 	add	r2,r2,r3
 909ad1c:	10800e04 	addi	r2,r2,56
 909ad20:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 909ad24:	d0a07f83 	ldbu	r2,-32258(gp)
 909ad28:	10803fcc 	andi	r2,r2,255
 909ad2c:	1080201c 	xori	r2,r2,128
 909ad30:	10bfe004 	addi	r2,r2,-128
 909ad34:	00c24374 	movhi	r3,2317
 909ad38:	18c3a904 	addi	r3,r3,3748
 909ad3c:	10801224 	muli	r2,r2,72
 909ad40:	10c5883a 	add	r2,r2,r3
 909ad44:	10800f04 	addi	r2,r2,60
 909ad48:	10000015 	stw	zero,0(r2)
 909ad4c:	00005406 	br	909aea0 <alt_tse_system_add_sys+0x8b0>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 909ad50:	d0a07f83 	ldbu	r2,-32258(gp)
 909ad54:	11003fcc 	andi	r4,r2,255
 909ad58:	2100201c 	xori	r4,r4,128
 909ad5c:	213fe004 	addi	r4,r4,-128
 909ad60:	e0bff517 	ldw	r2,-44(fp)
 909ad64:	11400003 	ldbu	r5,0(r2)
 909ad68:	00c24374 	movhi	r3,2317
 909ad6c:	18c3a904 	addi	r3,r3,3748
 909ad70:	20801224 	muli	r2,r4,72
 909ad74:	10c5883a 	add	r2,r2,r3
 909ad78:	10800904 	addi	r2,r2,36
 909ad7c:	11400005 	stb	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 909ad80:	d0a07f83 	ldbu	r2,-32258(gp)
 909ad84:	11003fcc 	andi	r4,r2,255
 909ad88:	2100201c 	xori	r4,r4,128
 909ad8c:	213fe004 	addi	r4,r4,-128
 909ad90:	e0bff517 	ldw	r2,-44(fp)
 909ad94:	11400117 	ldw	r5,4(r2)
 909ad98:	00c24374 	movhi	r3,2317
 909ad9c:	18c3a904 	addi	r3,r3,3748
 909ada0:	20801224 	muli	r2,r4,72
 909ada4:	10c5883a 	add	r2,r2,r3
 909ada8:	10800a04 	addi	r2,r2,40
 909adac:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 909adb0:	d0a07f83 	ldbu	r2,-32258(gp)
 909adb4:	11003fcc 	andi	r4,r2,255
 909adb8:	2100201c 	xori	r4,r4,128
 909adbc:	213fe004 	addi	r4,r4,-128
 909adc0:	e0bff517 	ldw	r2,-44(fp)
 909adc4:	11400217 	ldw	r5,8(r2)
 909adc8:	00c24374 	movhi	r3,2317
 909adcc:	18c3a904 	addi	r3,r3,3748
 909add0:	20801224 	muli	r2,r4,72
 909add4:	10c5883a 	add	r2,r2,r3
 909add8:	10800b04 	addi	r2,r2,44
 909addc:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 909ade0:	d0a07f83 	ldbu	r2,-32258(gp)
 909ade4:	11003fcc 	andi	r4,r2,255
 909ade8:	2100201c 	xori	r4,r4,128
 909adec:	213fe004 	addi	r4,r4,-128
 909adf0:	e0bff517 	ldw	r2,-44(fp)
 909adf4:	11400317 	ldw	r5,12(r2)
 909adf8:	00c24374 	movhi	r3,2317
 909adfc:	18c3a904 	addi	r3,r3,3748
 909ae00:	20801224 	muli	r2,r4,72
 909ae04:	10c5883a 	add	r2,r2,r3
 909ae08:	10800c04 	addi	r2,r2,48
 909ae0c:	11400015 	stw	r5,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 909ae10:	d0a07f83 	ldbu	r2,-32258(gp)
 909ae14:	11003fcc 	andi	r4,r2,255
 909ae18:	2100201c 	xori	r4,r4,128
 909ae1c:	213fe004 	addi	r4,r4,-128
 909ae20:	e0bff517 	ldw	r2,-44(fp)
 909ae24:	11400417 	ldw	r5,16(r2)
 909ae28:	00c24374 	movhi	r3,2317
 909ae2c:	18c3a904 	addi	r3,r3,3748
 909ae30:	20801224 	muli	r2,r4,72
 909ae34:	10c5883a 	add	r2,r2,r3
 909ae38:	10800d04 	addi	r2,r2,52
 909ae3c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 909ae40:	d0a07f83 	ldbu	r2,-32258(gp)
 909ae44:	11003fcc 	andi	r4,r2,255
 909ae48:	2100201c 	xori	r4,r4,128
 909ae4c:	213fe004 	addi	r4,r4,-128
 909ae50:	e0bff517 	ldw	r2,-44(fp)
 909ae54:	11400517 	ldw	r5,20(r2)
 909ae58:	00c24374 	movhi	r3,2317
 909ae5c:	18c3a904 	addi	r3,r3,3748
 909ae60:	20801224 	muli	r2,r4,72
 909ae64:	10c5883a 	add	r2,r2,r3
 909ae68:	10800e04 	addi	r2,r2,56
 909ae6c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 909ae70:	d0a07f83 	ldbu	r2,-32258(gp)
 909ae74:	11003fcc 	andi	r4,r2,255
 909ae78:	2100201c 	xori	r4,r4,128
 909ae7c:	213fe004 	addi	r4,r4,-128
 909ae80:	e0bff517 	ldw	r2,-44(fp)
 909ae84:	11400617 	ldw	r5,24(r2)
 909ae88:	00c24374 	movhi	r3,2317
 909ae8c:	18c3a904 	addi	r3,r3,3748
 909ae90:	20801224 	muli	r2,r4,72
 909ae94:	10c5883a 	add	r2,r2,r3
 909ae98:	10800f04 	addi	r2,r2,60
 909ae9c:	11400015 	stw	r5,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 909aea0:	e0bff417 	ldw	r2,-48(fp)
 909aea4:	1004c03a 	cmpne	r2,r2,zero
 909aea8:	1000161e 	bne	r2,zero,909af04 <alt_tse_system_add_sys+0x914>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 909aeac:	d0a07f83 	ldbu	r2,-32258(gp)
 909aeb0:	10803fcc 	andi	r2,r2,255
 909aeb4:	1080201c 	xori	r2,r2,128
 909aeb8:	10bfe004 	addi	r2,r2,-128
 909aebc:	00c24374 	movhi	r3,2317
 909aec0:	18c3a904 	addi	r3,r3,3748
 909aec4:	10801224 	muli	r2,r2,72
 909aec8:	10c5883a 	add	r2,r2,r3
 909aecc:	10c01004 	addi	r3,r2,64
 909aed0:	00bfffc4 	movi	r2,-1
 909aed4:	18800015 	stw	r2,0(r3)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 909aed8:	d0a07f83 	ldbu	r2,-32258(gp)
 909aedc:	10803fcc 	andi	r2,r2,255
 909aee0:	1080201c 	xori	r2,r2,128
 909aee4:	10bfe004 	addi	r2,r2,-128
 909aee8:	00c24374 	movhi	r3,2317
 909aeec:	18c3a904 	addi	r3,r3,3748
 909aef0:	10801224 	muli	r2,r2,72
 909aef4:	10c5883a 	add	r2,r2,r3
 909aef8:	10801104 	addi	r2,r2,68
 909aefc:	10000015 	stw	zero,0(r2)
 909af00:	00001806 	br	909af64 <alt_tse_system_add_sys+0x974>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 909af04:	d0a07f83 	ldbu	r2,-32258(gp)
 909af08:	11003fcc 	andi	r4,r2,255
 909af0c:	2100201c 	xori	r4,r4,128
 909af10:	213fe004 	addi	r4,r4,-128
 909af14:	e0bff417 	ldw	r2,-48(fp)
 909af18:	11400017 	ldw	r5,0(r2)
 909af1c:	00c24374 	movhi	r3,2317
 909af20:	18c3a904 	addi	r3,r3,3748
 909af24:	20801224 	muli	r2,r4,72
 909af28:	10c5883a 	add	r2,r2,r3
 909af2c:	10801004 	addi	r2,r2,64
 909af30:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 909af34:	d0a07f83 	ldbu	r2,-32258(gp)
 909af38:	11003fcc 	andi	r4,r2,255
 909af3c:	2100201c 	xori	r4,r4,128
 909af40:	213fe004 	addi	r4,r4,-128
 909af44:	e0bff417 	ldw	r2,-48(fp)
 909af48:	11400117 	ldw	r5,4(r2)
 909af4c:	00c24374 	movhi	r3,2317
 909af50:	18c3a904 	addi	r3,r3,3748
 909af54:	20801224 	muli	r2,r4,72
 909af58:	10c5883a 	add	r2,r2,r3
 909af5c:	10801104 	addi	r2,r2,68
 909af60:	11400015 	stw	r5,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 909af64:	e0bff717 	ldw	r2,-36(fp)
 909af68:	10800304 	addi	r2,r2,12
 909af6c:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
 909af70:	e0bff617 	ldw	r2,-40(fp)
 909af74:	1005003a 	cmpeq	r2,r2,zero
 909af78:	1000031e 	bne	r2,zero,909af88 <alt_tse_system_add_sys+0x998>
 909af7c:	e0bff617 	ldw	r2,-40(fp)
 909af80:	10800204 	addi	r2,r2,8
 909af84:	e0bff615 	stw	r2,-40(fp)
		if(pfifo) pfifo++;
 909af88:	e0bff517 	ldw	r2,-44(fp)
 909af8c:	1005003a 	cmpeq	r2,r2,zero
 909af90:	1000031e 	bne	r2,zero,909afa0 <alt_tse_system_add_sys+0x9b0>
 909af94:	e0bff517 	ldw	r2,-44(fp)
 909af98:	10800704 	addi	r2,r2,28
 909af9c:	e0bff515 	stw	r2,-44(fp)
		if(pphy) pphy++;
 909afa0:	e0bff417 	ldw	r2,-48(fp)
 909afa4:	1005003a 	cmpeq	r2,r2,zero
 909afa8:	1000031e 	bne	r2,zero,909afb8 <alt_tse_system_add_sys+0x9c8>
 909afac:	e0bff417 	ldw	r2,-48(fp)
 909afb0:	10800204 	addi	r2,r2,8
 909afb4:	e0bff415 	stw	r2,-48(fp)
		
		tse_system_count++;
 909afb8:	d0a07f83 	ldbu	r2,-32258(gp)
 909afbc:	10800044 	addi	r2,r2,1
 909afc0:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 909afc4:	d0a07f83 	ldbu	r2,-32258(gp)
 909afc8:	d0a02b05 	stb	r2,-32596(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 909afcc:	e0bffa17 	ldw	r2,-24(fp)
 909afd0:	10800044 	addi	r2,r2,1
 909afd4:	e0bffa15 	stw	r2,-24(fp)
 909afd8:	e0fffa17 	ldw	r3,-24(fp)
 909afdc:	e0bff917 	ldw	r2,-28(fp)
 909afe0:	18bdb016 	blt	r3,r2,909a6a4 <alt_tse_system_add_sys+0xb4>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 909afe4:	e03fff15 	stw	zero,-4(fp)
 909afe8:	e0bfff17 	ldw	r2,-4(fp)
	
}
 909afec:	e037883a 	mov	sp,fp
 909aff0:	dfc00217 	ldw	ra,8(sp)
 909aff4:	df000117 	ldw	fp,4(sp)
 909aff8:	dc000017 	ldw	r16,0(sp)
 909affc:	dec00304 	addi	sp,sp,12
 909b000:	f800283a 	ret

0909b004 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 909b004:	defff804 	addi	sp,sp,-32
 909b008:	dfc00715 	stw	ra,28(sp)
 909b00c:	df000615 	stw	fp,24(sp)
 909b010:	df000604 	addi	fp,sp,24
 909b014:	e13ffd15 	stw	r4,-12(fp)
 909b018:	e17ffe05 	stb	r5,-8(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 909b01c:	e03ffc15 	stw	zero,-16(fp)
 909b020:	00004c06 	br	909b154 <alt_tse_sys_enable_mdio_sharing+0x150>
		psys_mac = psys_mac_list[i];
 909b024:	e0bffc17 	ldw	r2,-16(fp)
 909b028:	1085883a 	add	r2,r2,r2
 909b02c:	1085883a 	add	r2,r2,r2
 909b030:	1007883a 	mov	r3,r2
 909b034:	e0bffd17 	ldw	r2,-12(fp)
 909b038:	1885883a 	add	r2,r3,r2
 909b03c:	10800017 	ldw	r2,0(r2)
 909b040:	e0bffa15 	stw	r2,-24(fp)
		
		if(psys_mac == 0) {
 909b044:	e0bffa17 	ldw	r2,-24(fp)
 909b048:	1004c03a 	cmpne	r2,r2,zero
 909b04c:	1000091e 	bne	r2,zero,909b074 <alt_tse_sys_enable_mdio_sharing+0x70>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 909b050:	01024374 	movhi	r4,2317
 909b054:	21340204 	addi	r4,r4,-12280
 909b058:	90828380 	call	9082838 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 909b05c:	01024374 	movhi	r4,2317
 909b060:	21346704 	addi	r4,r4,-11876
 909b064:	90828380 	call	9082838 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909b068:	00bfffc4 	movi	r2,-1
 909b06c:	e0bfff15 	stw	r2,-4(fp)
 909b070:	00003c06 	br	909b164 <alt_tse_sys_enable_mdio_sharing+0x160>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 909b074:	e03ffb15 	stw	zero,-20(fp)
 909b078:	00002f06 	br	909b138 <alt_tse_sys_enable_mdio_sharing+0x134>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 909b07c:	e0bffa17 	ldw	r2,-24(fp)
 909b080:	11000017 	ldw	r4,0(r2)
 909b084:	e0bffb17 	ldw	r2,-20(fp)
 909b088:	00c24374 	movhi	r3,2317
 909b08c:	18c3a904 	addi	r3,r3,3748
 909b090:	10801224 	muli	r2,r2,72
 909b094:	10c5883a 	add	r2,r2,r3
 909b098:	10800017 	ldw	r2,0(r2)
 909b09c:	2080231e 	bne	r4,r2,909b12c <alt_tse_sys_enable_mdio_sharing+0x128>
				if(tse_mac_device[j].tse_multichannel_mac) {
 909b0a0:	e0bffb17 	ldw	r2,-20(fp)
 909b0a4:	00c24374 	movhi	r3,2317
 909b0a8:	18c3a904 	addi	r3,r3,3748
 909b0ac:	10801224 	muli	r2,r2,72
 909b0b0:	10c5883a 	add	r2,r2,r3
 909b0b4:	10800204 	addi	r2,r2,8
 909b0b8:	108000c3 	ldbu	r2,3(r2)
 909b0bc:	10803fcc 	andi	r2,r2,255
 909b0c0:	1005003a 	cmpeq	r2,r2,zero
 909b0c4:	1000091e 	bne	r2,zero,909b0ec <alt_tse_sys_enable_mdio_sharing+0xe8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 909b0c8:	01024374 	movhi	r4,2317
 909b0cc:	21347b04 	addi	r4,r4,-11796
 909b0d0:	90828380 	call	9082838 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 909b0d4:	01024374 	movhi	r4,2317
 909b0d8:	21348c04 	addi	r4,r4,-11728
 909b0dc:	90828380 	call	9082838 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909b0e0:	00bfffc4 	movi	r2,-1
 909b0e4:	e0bfff15 	stw	r2,-4(fp)
 909b0e8:	00001e06 	br	909b164 <alt_tse_sys_enable_mdio_sharing+0x160>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 909b0ec:	e0bffb17 	ldw	r2,-20(fp)
 909b0f0:	00c24374 	movhi	r3,2317
 909b0f4:	18c3a904 	addi	r3,r3,3748
 909b0f8:	10801224 	muli	r2,r2,72
 909b0fc:	10c5883a 	add	r2,r2,r3
 909b100:	10c00304 	addi	r3,r2,12
 909b104:	00800044 	movi	r2,1
 909b108:	18800045 	stb	r2,1(r3)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 909b10c:	e0bffb17 	ldw	r2,-20(fp)
 909b110:	00c24374 	movhi	r3,2317
 909b114:	18c3a904 	addi	r3,r3,3748
 909b118:	10801224 	muli	r2,r2,72
 909b11c:	10c5883a 	add	r2,r2,r3
 909b120:	10c00304 	addi	r3,r2,12
 909b124:	e0bffe03 	ldbu	r2,-8(fp)
 909b128:	18800085 	stb	r2,2(r3)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 909b12c:	e0bffb17 	ldw	r2,-20(fp)
 909b130:	10800044 	addi	r2,r2,1
 909b134:	e0bffb15 	stw	r2,-20(fp)
 909b138:	d0a02b03 	ldbu	r2,-32596(gp)
 909b13c:	10c03fcc 	andi	r3,r2,255
 909b140:	e0bffb17 	ldw	r2,-20(fp)
 909b144:	10ffcd16 	blt	r2,r3,909b07c <alt_tse_sys_enable_mdio_sharing+0x78>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 909b148:	e0bffc17 	ldw	r2,-16(fp)
 909b14c:	10800044 	addi	r2,r2,1
 909b150:	e0bffc15 	stw	r2,-16(fp)
 909b154:	e0fffe03 	ldbu	r3,-8(fp)
 909b158:	e0bffc17 	ldw	r2,-16(fp)
 909b15c:	10ffb116 	blt	r2,r3,909b024 <alt_tse_sys_enable_mdio_sharing+0x20>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 909b160:	e03fff15 	stw	zero,-4(fp)
 909b164:	e0bfff17 	ldw	r2,-4(fp)
}
 909b168:	e037883a 	mov	sp,fp
 909b16c:	dfc00117 	ldw	ra,4(sp)
 909b170:	df000017 	ldw	fp,0(sp)
 909b174:	dec00204 	addi	sp,sp,8
 909b178:	f800283a 	ret

0909b17c <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 909b17c:	defffc04 	addi	sp,sp,-16
 909b180:	dfc00315 	stw	ra,12(sp)
 909b184:	df000215 	stw	fp,8(sp)
 909b188:	df000204 	addi	fp,sp,8
 909b18c:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 909b190:	e13fff17 	ldw	r4,-4(fp)
 909b194:	909b38c0 	call	909b38c <alt_tse_get_mac_info>
 909b198:	10800317 	ldw	r2,12(r2)
 909b19c:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 909b1a0:	e13ffe17 	ldw	r4,-8(fp)
 909b1a4:	909e7e80 	call	909e7e8 <alt_tse_phy_get_common_speed>
}
 909b1a8:	e037883a 	mov	sp,fp
 909b1ac:	dfc00117 	ldw	ra,4(sp)
 909b1b0:	df000017 	ldw	fp,0(sp)
 909b1b4:	dec00204 	addi	sp,sp,8
 909b1b8:	f800283a 	ret

0909b1bc <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 909b1bc:	defffb04 	addi	sp,sp,-20
 909b1c0:	dfc00415 	stw	ra,16(sp)
 909b1c4:	df000315 	stw	fp,12(sp)
 909b1c8:	df000304 	addi	fp,sp,12
 909b1cc:	e13ffe15 	stw	r4,-8(fp)
 909b1d0:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 909b1d4:	e13ffe17 	ldw	r4,-8(fp)
 909b1d8:	909b38c0 	call	909b38c <alt_tse_get_mac_info>
 909b1dc:	10800317 	ldw	r2,12(r2)
 909b1e0:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 909b1e4:	e13ffd17 	ldw	r4,-12(fp)
 909b1e8:	e17fff17 	ldw	r5,-4(fp)
 909b1ec:	909eb040 	call	909eb04 <alt_tse_phy_set_common_speed>
}
 909b1f0:	e037883a 	mov	sp,fp
 909b1f4:	dfc00117 	ldw	ra,4(sp)
 909b1f8:	df000017 	ldw	fp,0(sp)
 909b1fc:	dec00204 	addi	sp,sp,8
 909b200:	f800283a 	ret

0909b204 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 909b204:	defffc04 	addi	sp,sp,-16
 909b208:	df000315 	stw	fp,12(sp)
 909b20c:	df000304 	addi	fp,sp,12
 909b210:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 909b214:	e03ffd15 	stw	zero,-12(fp)
 909b218:	00000e06 	br	909b254 <alt_tse_get_system_index+0x50>
        if(psys_info == &tse_mac_device[i]) {
 909b21c:	e0bffd17 	ldw	r2,-12(fp)
 909b220:	10801224 	muli	r2,r2,72
 909b224:	1007883a 	mov	r3,r2
 909b228:	00824374 	movhi	r2,2317
 909b22c:	1083a904 	addi	r2,r2,3748
 909b230:	1887883a 	add	r3,r3,r2
 909b234:	e0bffe17 	ldw	r2,-8(fp)
 909b238:	1880031e 	bne	r3,r2,909b248 <alt_tse_get_system_index+0x44>
            return i;
 909b23c:	e0bffd17 	ldw	r2,-12(fp)
 909b240:	e0bfff15 	stw	r2,-4(fp)
 909b244:	00000906 	br	909b26c <alt_tse_get_system_index+0x68>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 909b248:	e0bffd17 	ldw	r2,-12(fp)
 909b24c:	10800044 	addi	r2,r2,1
 909b250:	e0bffd15 	stw	r2,-12(fp)
 909b254:	d0a02b03 	ldbu	r2,-32596(gp)
 909b258:	10c03fcc 	andi	r3,r2,255
 909b25c:	e0bffd17 	ldw	r2,-12(fp)
 909b260:	10ffee16 	blt	r2,r3,909b21c <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 909b264:	00bfffc4 	movi	r2,-1
 909b268:	e0bfff15 	stw	r2,-4(fp)
 909b26c:	e0bfff17 	ldw	r2,-4(fp)
}
 909b270:	e037883a 	mov	sp,fp
 909b274:	df000017 	ldw	fp,0(sp)
 909b278:	dec00104 	addi	sp,sp,4
 909b27c:	f800283a 	ret

0909b280 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 909b280:	defffc04 	addi	sp,sp,-16
 909b284:	df000315 	stw	fp,12(sp)
 909b288:	df000304 	addi	fp,sp,12
 909b28c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 909b290:	e03ffd15 	stw	zero,-12(fp)
 909b294:	00000f06 	br	909b2d4 <alt_tse_get_mac_group_index+0x54>
        if(pmac_group == pmac_groups[i]) {
 909b298:	e0bffd17 	ldw	r2,-12(fp)
 909b29c:	00c243b4 	movhi	r3,2318
 909b2a0:	18f2f904 	addi	r3,r3,-13340
 909b2a4:	1085883a 	add	r2,r2,r2
 909b2a8:	1085883a 	add	r2,r2,r2
 909b2ac:	10c5883a 	add	r2,r2,r3
 909b2b0:	10c00017 	ldw	r3,0(r2)
 909b2b4:	e0bffe17 	ldw	r2,-8(fp)
 909b2b8:	1880031e 	bne	r3,r2,909b2c8 <alt_tse_get_mac_group_index+0x48>
            return i;
 909b2bc:	e0bffd17 	ldw	r2,-12(fp)
 909b2c0:	e0bfff15 	stw	r2,-4(fp)
 909b2c4:	00000906 	br	909b2ec <alt_tse_get_mac_group_index+0x6c>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 909b2c8:	e0bffd17 	ldw	r2,-12(fp)
 909b2cc:	10800044 	addi	r2,r2,1
 909b2d0:	e0bffd15 	stw	r2,-12(fp)
 909b2d4:	d0a07f43 	ldbu	r2,-32259(gp)
 909b2d8:	10c03fcc 	andi	r3,r2,255
 909b2dc:	e0bffd17 	ldw	r2,-12(fp)
 909b2e0:	10ffed16 	blt	r2,r3,909b298 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 909b2e4:	00bfffc4 	movi	r2,-1
 909b2e8:	e0bfff15 	stw	r2,-4(fp)
 909b2ec:	e0bfff17 	ldw	r2,-4(fp)
}
 909b2f0:	e037883a 	mov	sp,fp
 909b2f4:	df000017 	ldw	fp,0(sp)
 909b2f8:	dec00104 	addi	sp,sp,4
 909b2fc:	f800283a 	ret

0909b300 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 909b300:	defffc04 	addi	sp,sp,-16
 909b304:	df000315 	stw	fp,12(sp)
 909b308:	df000304 	addi	fp,sp,12
 909b30c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 909b310:	e03ffd15 	stw	zero,-12(fp)
 909b314:	00001006 	br	909b358 <alt_tse_get_mac_info_index+0x58>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 909b318:	e0bffe17 	ldw	r2,-8(fp)
 909b31c:	10c00317 	ldw	r3,12(r2)
 909b320:	e0bffd17 	ldw	r2,-12(fp)
 909b324:	1085883a 	add	r2,r2,r2
 909b328:	1085883a 	add	r2,r2,r2
 909b32c:	10c5883a 	add	r2,r2,r3
 909b330:	10800104 	addi	r2,r2,4
 909b334:	10c00017 	ldw	r3,0(r2)
 909b338:	e0bffe17 	ldw	r2,-8(fp)
 909b33c:	1880031e 	bne	r3,r2,909b34c <alt_tse_get_mac_info_index+0x4c>
            return i;
 909b340:	e0bffd17 	ldw	r2,-12(fp)
 909b344:	e0bfff15 	stw	r2,-4(fp)
 909b348:	00000b06 	br	909b378 <alt_tse_get_mac_info_index+0x78>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 909b34c:	e0bffd17 	ldw	r2,-12(fp)
 909b350:	10800044 	addi	r2,r2,1
 909b354:	e0bffd15 	stw	r2,-12(fp)
 909b358:	e0bffe17 	ldw	r2,-8(fp)
 909b35c:	10800317 	ldw	r2,12(r2)
 909b360:	10800003 	ldbu	r2,0(r2)
 909b364:	10c03fcc 	andi	r3,r2,255
 909b368:	e0bffd17 	ldw	r2,-12(fp)
 909b36c:	10ffea16 	blt	r2,r3,909b318 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 909b370:	00bfffc4 	movi	r2,-1
 909b374:	e0bfff15 	stw	r2,-4(fp)
 909b378:	e0bfff17 	ldw	r2,-4(fp)
}
 909b37c:	e037883a 	mov	sp,fp
 909b380:	df000017 	ldw	fp,0(sp)
 909b384:	dec00104 	addi	sp,sp,4
 909b388:	f800283a 	ret

0909b38c <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 909b38c:	defff904 	addi	sp,sp,-28
 909b390:	df000615 	stw	fp,24(sp)
 909b394:	df000604 	addi	fp,sp,24
 909b398:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 909b39c:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 909b3a0:	e03ffa15 	stw	zero,-24(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 909b3a4:	e03ffd15 	stw	zero,-12(fp)
 909b3a8:	00002606 	br	909b444 <alt_tse_get_mac_info+0xb8>
        pmac_group = pmac_groups[i];
 909b3ac:	e0bffd17 	ldw	r2,-12(fp)
 909b3b0:	00c243b4 	movhi	r3,2318
 909b3b4:	18f2f904 	addi	r3,r3,-13340
 909b3b8:	1085883a 	add	r2,r2,r2
 909b3bc:	1085883a 	add	r2,r2,r2
 909b3c0:	10c5883a 	add	r2,r2,r3
 909b3c4:	10800017 	ldw	r2,0(r2)
 909b3c8:	e0bffb15 	stw	r2,-20(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 909b3cc:	e03ffc15 	stw	zero,-16(fp)
 909b3d0:	00001406 	br	909b424 <alt_tse_get_mac_info+0x98>
            pmac_info = pmac_group->pmac_info[j];
 909b3d4:	e0bffc17 	ldw	r2,-16(fp)
 909b3d8:	e0fffb17 	ldw	r3,-20(fp)
 909b3dc:	1085883a 	add	r2,r2,r2
 909b3e0:	1085883a 	add	r2,r2,r2
 909b3e4:	10c5883a 	add	r2,r2,r3
 909b3e8:	10800104 	addi	r2,r2,4
 909b3ec:	10800017 	ldw	r2,0(r2)
 909b3f0:	e0bffa15 	stw	r2,-24(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 909b3f4:	e0bffa17 	ldw	r2,-24(fp)
 909b3f8:	10800217 	ldw	r2,8(r2)
 909b3fc:	10800017 	ldw	r2,0(r2)
 909b400:	1007883a 	mov	r3,r2
 909b404:	e0bffe17 	ldw	r2,-8(fp)
 909b408:	1880031e 	bne	r3,r2,909b418 <alt_tse_get_mac_info+0x8c>
                return pmac_info;
 909b40c:	e0bffa17 	ldw	r2,-24(fp)
 909b410:	e0bfff15 	stw	r2,-4(fp)
 909b414:	00001006 	br	909b458 <alt_tse_get_mac_info+0xcc>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 909b418:	e0bffc17 	ldw	r2,-16(fp)
 909b41c:	10800044 	addi	r2,r2,1
 909b420:	e0bffc15 	stw	r2,-16(fp)
 909b424:	e0bffb17 	ldw	r2,-20(fp)
 909b428:	10800003 	ldbu	r2,0(r2)
 909b42c:	10c03fcc 	andi	r3,r2,255
 909b430:	e0bffc17 	ldw	r2,-16(fp)
 909b434:	10ffe716 	blt	r2,r3,909b3d4 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 909b438:	e0bffd17 	ldw	r2,-12(fp)
 909b43c:	10800044 	addi	r2,r2,1
 909b440:	e0bffd15 	stw	r2,-12(fp)
 909b444:	d0a07f43 	ldbu	r2,-32259(gp)
 909b448:	10c03fcc 	andi	r3,r2,255
 909b44c:	e0bffd17 	ldw	r2,-12(fp)
 909b450:	10ffd616 	blt	r2,r3,909b3ac <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 909b454:	e03fff15 	stw	zero,-4(fp)
 909b458:	e0bfff17 	ldw	r2,-4(fp)
}
 909b45c:	e037883a 	mov	sp,fp
 909b460:	df000017 	ldw	fp,0(sp)
 909b464:	dec00104 	addi	sp,sp,4
 909b468:	f800283a 	ret

0909b46c <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 909b46c:	defffb04 	addi	sp,sp,-20
 909b470:	df000415 	stw	fp,16(sp)
 909b474:	df000404 	addi	fp,sp,16
 909b478:	e13ffd15 	stw	r4,-12(fp)
 909b47c:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909b480:	e0bffd17 	ldw	r2,-12(fp)
 909b484:	10800204 	addi	r2,r2,8
 909b488:	10800037 	ldwio	r2,0(r2)
 909b48c:	e0bffc15 	stw	r2,-16(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 909b490:	e0bffe03 	ldbu	r2,-8(fp)
 909b494:	10800098 	cmpnei	r2,r2,2
 909b498:	1000091e 	bne	r2,zero,909b4c0 <alt_tse_mac_set_speed+0x54>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909b49c:	e0bffc17 	ldw	r2,-16(fp)
 909b4a0:	10800214 	ori	r2,r2,8
 909b4a4:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909b4a8:	e0fffc17 	ldw	r3,-16(fp)
 909b4ac:	00bf8034 	movhi	r2,65024
 909b4b0:	10bfffc4 	addi	r2,r2,-1
 909b4b4:	1884703a 	and	r2,r3,r2
 909b4b8:	e0bffc15 	stw	r2,-16(fp)
 909b4bc:	00001b06 	br	909b52c <alt_tse_mac_set_speed+0xc0>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 909b4c0:	e0bffe03 	ldbu	r2,-8(fp)
 909b4c4:	10800058 	cmpnei	r2,r2,1
 909b4c8:	10000a1e 	bne	r2,zero,909b4f4 <alt_tse_mac_set_speed+0x88>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909b4cc:	e0fffc17 	ldw	r3,-16(fp)
 909b4d0:	00bffdc4 	movi	r2,-9
 909b4d4:	1884703a 	and	r2,r3,r2
 909b4d8:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909b4dc:	e0fffc17 	ldw	r3,-16(fp)
 909b4e0:	00bf8034 	movhi	r2,65024
 909b4e4:	10bfffc4 	addi	r2,r2,-1
 909b4e8:	1884703a 	and	r2,r3,r2
 909b4ec:	e0bffc15 	stw	r2,-16(fp)
 909b4f0:	00000e06 	br	909b52c <alt_tse_mac_set_speed+0xc0>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 909b4f4:	e0bffe03 	ldbu	r2,-8(fp)
 909b4f8:	1004c03a 	cmpne	r2,r2,zero
 909b4fc:	1000081e 	bne	r2,zero,909b520 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909b500:	e0fffc17 	ldw	r3,-16(fp)
 909b504:	00bffdc4 	movi	r2,-9
 909b508:	1884703a 	and	r2,r3,r2
 909b50c:	e0bffc15 	stw	r2,-16(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909b510:	e0bffc17 	ldw	r2,-16(fp)
 909b514:	10808034 	orhi	r2,r2,512
 909b518:	e0bffc15 	stw	r2,-16(fp)
 909b51c:	00000306 	br	909b52c <alt_tse_mac_set_speed+0xc0>
  }  
  else {
    return ENP_PARAM;
 909b520:	00bffd84 	movi	r2,-10
 909b524:	e0bfff15 	stw	r2,-4(fp)
 909b528:	00000606 	br	909b544 <alt_tse_mac_set_speed+0xd8>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 909b52c:	e0bffd17 	ldw	r2,-12(fp)
 909b530:	10800204 	addi	r2,r2,8
 909b534:	1007883a 	mov	r3,r2
 909b538:	e0bffc17 	ldw	r2,-16(fp)
 909b53c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909b540:	e03fff15 	stw	zero,-4(fp)
 909b544:	e0bfff17 	ldw	r2,-4(fp)
}
 909b548:	e037883a 	mov	sp,fp
 909b54c:	df000017 	ldw	fp,0(sp)
 909b550:	dec00104 	addi	sp,sp,4
 909b554:	f800283a 	ret

0909b558 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 909b558:	defffb04 	addi	sp,sp,-20
 909b55c:	df000415 	stw	fp,16(sp)
 909b560:	df000404 	addi	fp,sp,16
 909b564:	e13ffd15 	stw	r4,-12(fp)
 909b568:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909b56c:	e0bffd17 	ldw	r2,-12(fp)
 909b570:	10800204 	addi	r2,r2,8
 909b574:	10800037 	ldwio	r2,0(r2)
 909b578:	e0bffc15 	stw	r2,-16(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 909b57c:	e0bffe03 	ldbu	r2,-8(fp)
 909b580:	1004c03a 	cmpne	r2,r2,zero
 909b584:	1000041e 	bne	r2,zero,909b598 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 909b588:	e0bffc17 	ldw	r2,-16(fp)
 909b58c:	10810014 	ori	r2,r2,1024
 909b590:	e0bffc15 	stw	r2,-16(fp)
 909b594:	00000b06 	br	909b5c4 <alt_tse_mac_set_duplex+0x6c>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 909b598:	e0bffe03 	ldbu	r2,-8(fp)
 909b59c:	10800058 	cmpnei	r2,r2,1
 909b5a0:	1000051e 	bne	r2,zero,909b5b8 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 909b5a4:	e0bffc17 	ldw	r2,-16(fp)
 909b5a8:	00feffc4 	movi	r3,-1025
 909b5ac:	10c4703a 	and	r2,r2,r3
 909b5b0:	e0bffc15 	stw	r2,-16(fp)
 909b5b4:	00000306 	br	909b5c4 <alt_tse_mac_set_duplex+0x6c>
  }
  else {
    return ENP_PARAM;
 909b5b8:	00bffd84 	movi	r2,-10
 909b5bc:	e0bfff15 	stw	r2,-4(fp)
 909b5c0:	00000606 	br	909b5dc <alt_tse_mac_set_duplex+0x84>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 909b5c4:	e0bffd17 	ldw	r2,-12(fp)
 909b5c8:	10800204 	addi	r2,r2,8
 909b5cc:	1007883a 	mov	r3,r2
 909b5d0:	e0bffc17 	ldw	r2,-16(fp)
 909b5d4:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909b5d8:	e03fff15 	stw	zero,-4(fp)
 909b5dc:	e0bfff17 	ldw	r2,-4(fp)

}
 909b5e0:	e037883a 	mov	sp,fp
 909b5e4:	df000017 	ldw	fp,0(sp)
 909b5e8:	dec00104 	addi	sp,sp,4
 909b5ec:	f800283a 	ret

0909b5f0 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 909b5f0:	deff9704 	addi	sp,sp,-420
 909b5f4:	dfc06815 	stw	ra,416(sp)
 909b5f8:	df006715 	stw	fp,412(sp)
 909b5fc:	df006704 	addi	fp,sp,412
 909b600:	e13fa215 	stw	r4,-376(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909b604:	00800044 	movi	r2,1
 909b608:	e0bfa145 	stb	r2,-379(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 909b60c:	00800044 	movi	r2,1
 909b610:	e0bfa105 	stb	r2,-380(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 909b614:	e0bfa103 	ldbu	r2,-380(fp)
 909b618:	1080004c 	andi	r2,r2,1
 909b61c:	e0bfff15 	stw	r2,-4(fp)
 909b620:	e0bfa143 	ldbu	r2,-379(fp)
 909b624:	10800098 	cmpnei	r2,r2,2
 909b628:	1000031e 	bne	r2,zero,909b638 <getPHYSpeed+0x48>
 909b62c:	00800084 	movi	r2,2
 909b630:	e0bffe15 	stw	r2,-8(fp)
 909b634:	00000106 	br	909b63c <getPHYSpeed+0x4c>
 909b638:	e03ffe15 	stw	zero,-8(fp)
 909b63c:	e0ffff17 	ldw	r3,-4(fp)
 909b640:	e13ffe17 	ldw	r4,-8(fp)
 909b644:	1906b03a 	or	r3,r3,r4
 909b648:	e0fffd15 	stw	r3,-12(fp)
 909b64c:	e0bfa143 	ldbu	r2,-379(fp)
 909b650:	10800058 	cmpnei	r2,r2,1
 909b654:	1000031e 	bne	r2,zero,909b664 <getPHYSpeed+0x74>
 909b658:	00800104 	movi	r2,4
 909b65c:	e0bffc15 	stw	r2,-16(fp)
 909b660:	00000106 	br	909b668 <getPHYSpeed+0x78>
 909b664:	e03ffc15 	stw	zero,-16(fp)
 909b668:	e0fffd17 	ldw	r3,-12(fp)
 909b66c:	e13ffc17 	ldw	r4,-16(fp)
 909b670:	1906b03a 	or	r3,r3,r4
 909b674:	e0fffb15 	stw	r3,-20(fp)
 909b678:	e0bfa143 	ldbu	r2,-379(fp)
 909b67c:	1004c03a 	cmpne	r2,r2,zero
 909b680:	1000031e 	bne	r2,zero,909b690 <getPHYSpeed+0xa0>
 909b684:	00800204 	movi	r2,8
 909b688:	e0bffa15 	stw	r2,-24(fp)
 909b68c:	00000106 	br	909b694 <getPHYSpeed+0xa4>
 909b690:	e03ffa15 	stw	zero,-24(fp)
 909b694:	e0fffb17 	ldw	r3,-20(fp)
 909b698:	e13ffa17 	ldw	r4,-24(fp)
 909b69c:	1906b03a 	or	r3,r3,r4
 909b6a0:	e0fff915 	stw	r3,-28(fp)
 909b6a4:	e0bfa143 	ldbu	r2,-379(fp)
 909b6a8:	108000d8 	cmpnei	r2,r2,3
 909b6ac:	1000031e 	bne	r2,zero,909b6bc <getPHYSpeed+0xcc>
 909b6b0:	00800074 	movhi	r2,1
 909b6b4:	e0bff815 	stw	r2,-32(fp)
 909b6b8:	00000106 	br	909b6c0 <getPHYSpeed+0xd0>
 909b6bc:	e03ff815 	stw	zero,-32(fp)
 909b6c0:	e0fff917 	ldw	r3,-28(fp)
 909b6c4:	e13ff817 	ldw	r4,-32(fp)
 909b6c8:	1904b03a 	or	r2,r3,r4
 909b6cc:	e0bfa015 	stw	r2,-384(fp)
    
    alt_tse_phy_info *pphy = 0;
 909b6d0:	e03f9f15 	stw	zero,-388(fp)
    alt_tse_mac_info *pmac_info = 0;
 909b6d4:	e03f9e15 	stw	zero,-392(fp)
    alt_tse_mac_group *pmac_group = 0;
 909b6d8:	e03f9d15 	stw	zero,-396(fp)
    alt_tse_system_info *psys = 0;
 909b6dc:	e03f9c15 	stw	zero,-400(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909b6e0:	e03f9b45 	stb	zero,-403(fp)
    alt_8 mac_group_index = 0;
 909b6e4:	e03f9b05 	stb	zero,-404(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 909b6e8:	d0a07fc3 	ldbu	r2,-32257(gp)
 909b6ec:	10803fcc 	andi	r2,r2,255
 909b6f0:	1004c03a 	cmpne	r2,r2,zero
 909b6f4:	1000031e 	bne	r2,zero,909b704 <getPHYSpeed+0x114>
        alt_tse_phy_init();
 909b6f8:	909d9640 	call	909d964 <alt_tse_phy_init>
        is_init = 1;
 909b6fc:	00800044 	movi	r2,1
 909b700:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 909b704:	e13fa217 	ldw	r4,-376(fp)
 909b708:	909b38c0 	call	909b38c <alt_tse_get_mac_info>
 909b70c:	e0bf9e15 	stw	r2,-392(fp)
    
    if(pmac_info == 0) {
 909b710:	e0bf9e17 	ldw	r2,-392(fp)
 909b714:	1004c03a 	cmpne	r2,r2,zero
 909b718:	1000651e 	bne	r2,zero,909b8b0 <getPHYSpeed+0x2c0>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909b71c:	00800044 	movi	r2,1
 909b720:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909b724:	00800044 	movi	r2,1
 909b728:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 909b72c:	e0bfa103 	ldbu	r2,-380(fp)
 909b730:	1080004c 	andi	r2,r2,1
 909b734:	e0bff715 	stw	r2,-36(fp)
 909b738:	e0bfa143 	ldbu	r2,-379(fp)
 909b73c:	10800098 	cmpnei	r2,r2,2
 909b740:	1000031e 	bne	r2,zero,909b750 <getPHYSpeed+0x160>
 909b744:	00800084 	movi	r2,2
 909b748:	e0bff615 	stw	r2,-40(fp)
 909b74c:	00000106 	br	909b754 <getPHYSpeed+0x164>
 909b750:	e03ff615 	stw	zero,-40(fp)
 909b754:	e0fff717 	ldw	r3,-36(fp)
 909b758:	e13ff617 	ldw	r4,-40(fp)
 909b75c:	1906b03a 	or	r3,r3,r4
 909b760:	e0fff515 	stw	r3,-44(fp)
 909b764:	e0bfa143 	ldbu	r2,-379(fp)
 909b768:	10800058 	cmpnei	r2,r2,1
 909b76c:	1000031e 	bne	r2,zero,909b77c <getPHYSpeed+0x18c>
 909b770:	00800104 	movi	r2,4
 909b774:	e0bff415 	stw	r2,-48(fp)
 909b778:	00000106 	br	909b780 <getPHYSpeed+0x190>
 909b77c:	e03ff415 	stw	zero,-48(fp)
 909b780:	e0fff517 	ldw	r3,-44(fp)
 909b784:	e13ff417 	ldw	r4,-48(fp)
 909b788:	1906b03a 	or	r3,r3,r4
 909b78c:	e0fff315 	stw	r3,-52(fp)
 909b790:	e0bfa143 	ldbu	r2,-379(fp)
 909b794:	1004c03a 	cmpne	r2,r2,zero
 909b798:	1000031e 	bne	r2,zero,909b7a8 <getPHYSpeed+0x1b8>
 909b79c:	00800204 	movi	r2,8
 909b7a0:	e0bff215 	stw	r2,-56(fp)
 909b7a4:	00000106 	br	909b7ac <getPHYSpeed+0x1bc>
 909b7a8:	e03ff215 	stw	zero,-56(fp)
 909b7ac:	e0fff317 	ldw	r3,-52(fp)
 909b7b0:	e13ff217 	ldw	r4,-56(fp)
 909b7b4:	1906b03a 	or	r3,r3,r4
 909b7b8:	e0fff115 	stw	r3,-60(fp)
 909b7bc:	e0bfa143 	ldbu	r2,-379(fp)
 909b7c0:	108000d8 	cmpnei	r2,r2,3
 909b7c4:	1000031e 	bne	r2,zero,909b7d4 <getPHYSpeed+0x1e4>
 909b7c8:	00800074 	movhi	r2,1
 909b7cc:	e0bff015 	stw	r2,-64(fp)
 909b7d0:	00000106 	br	909b7d8 <getPHYSpeed+0x1e8>
 909b7d4:	e03ff015 	stw	zero,-64(fp)
 909b7d8:	e0fff117 	ldw	r3,-60(fp)
 909b7dc:	e13ff017 	ldw	r4,-64(fp)
 909b7e0:	1904b03a 	or	r2,r3,r4
 909b7e4:	10802034 	orhi	r2,r2,128
 909b7e8:	e0bfa015 	stw	r2,-384(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 909b7ec:	e0bfa143 	ldbu	r2,-379(fp)
 909b7f0:	108000a0 	cmpeqi	r2,r2,2
 909b7f4:	1000161e 	bne	r2,zero,909b850 <getPHYSpeed+0x260>
 909b7f8:	e0bfa143 	ldbu	r2,-379(fp)
 909b7fc:	10800060 	cmpeqi	r2,r2,1
 909b800:	10000d1e 	bne	r2,zero,909b838 <getPHYSpeed+0x248>
 909b804:	e0bfa143 	ldbu	r2,-379(fp)
 909b808:	1004c03a 	cmpne	r2,r2,zero
 909b80c:	1000041e 	bne	r2,zero,909b820 <getPHYSpeed+0x230>
 909b810:	00824374 	movhi	r2,2317
 909b814:	10b49b04 	addi	r2,r2,-11668
 909b818:	e0bfed15 	stw	r2,-76(fp)
 909b81c:	00000306 	br	909b82c <getPHYSpeed+0x23c>
 909b820:	00c24374 	movhi	r3,2317
 909b824:	18f49c04 	addi	r3,r3,-11664
 909b828:	e0ffed15 	stw	r3,-76(fp)
 909b82c:	e13fed17 	ldw	r4,-76(fp)
 909b830:	e13fee15 	stw	r4,-72(fp)
 909b834:	00000306 	br	909b844 <getPHYSpeed+0x254>
 909b838:	00824374 	movhi	r2,2317
 909b83c:	10b49e04 	addi	r2,r2,-11656
 909b840:	e0bfee15 	stw	r2,-72(fp)
 909b844:	e0ffee17 	ldw	r3,-72(fp)
 909b848:	e0ffef15 	stw	r3,-68(fp)
 909b84c:	00000306 	br	909b85c <getPHYSpeed+0x26c>
 909b850:	01024374 	movhi	r4,2317
 909b854:	21349f04 	addi	r4,r4,-11652
 909b858:	e13fef15 	stw	r4,-68(fp)
 909b85c:	e0bfa103 	ldbu	r2,-380(fp)
 909b860:	10800058 	cmpnei	r2,r2,1
 909b864:	1000041e 	bne	r2,zero,909b878 <getPHYSpeed+0x288>
 909b868:	00824374 	movhi	r2,2317
 909b86c:	10b4a104 	addi	r2,r2,-11644
 909b870:	e0bfec15 	stw	r2,-80(fp)
 909b874:	00000306 	br	909b884 <getPHYSpeed+0x294>
 909b878:	00c24374 	movhi	r3,2317
 909b87c:	18f4a304 	addi	r3,r3,-11636
 909b880:	e0ffec15 	stw	r3,-80(fp)
 909b884:	01024374 	movhi	r4,2317
 909b888:	2134a504 	addi	r4,r4,-11628
 909b88c:	e17fef17 	ldw	r5,-68(fp)
 909b890:	e1bfec17 	ldw	r6,-80(fp)
 909b894:	90825100 	call	9082510 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 909b898:	01024374 	movhi	r4,2317
 909b89c:	2134bd04 	addi	r4,r4,-11532
 909b8a0:	90828380 	call	9082838 <puts>
        return result;
 909b8a4:	e13fa017 	ldw	r4,-384(fp)
 909b8a8:	e13feb15 	stw	r4,-84(fp)
 909b8ac:	0002cc06 	br	909c3e0 <getPHYSpeed+0xdf0>
    }
    
    pphy = pmac_info->pphy_info;
 909b8b0:	e0bf9e17 	ldw	r2,-392(fp)
 909b8b4:	10800117 	ldw	r2,4(r2)
 909b8b8:	e0bf9f15 	stw	r2,-388(fp)
    pmac_group = pmac_info->pmac_group;
 909b8bc:	e0bf9e17 	ldw	r2,-392(fp)
 909b8c0:	10800317 	ldw	r2,12(r2)
 909b8c4:	e0bf9d15 	stw	r2,-396(fp)
    psys = pmac_info->psys_info;
 909b8c8:	e0bf9e17 	ldw	r2,-392(fp)
 909b8cc:	10800217 	ldw	r2,8(r2)
 909b8d0:	e0bf9c15 	stw	r2,-400(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909b8d4:	e13f9e17 	ldw	r4,-392(fp)
 909b8d8:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909b8dc:	e0bf9b45 	stb	r2,-403(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909b8e0:	e13f9d17 	ldw	r4,-396(fp)
 909b8e4:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909b8e8:	e0bf9b05 	stb	r2,-404(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 909b8ec:	e0bf9d17 	ldw	r2,-396(fp)
 909b8f0:	10800117 	ldw	r2,4(r2)
 909b8f4:	10800217 	ldw	r2,8(r2)
 909b8f8:	10800203 	ldbu	r2,8(r2)
 909b8fc:	10803fcc 	andi	r2,r2,255
 909b900:	1004c03a 	cmpne	r2,r2,zero
 909b904:	1000771e 	bne	r2,zero,909bae4 <getPHYSpeed+0x4f4>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909b908:	00800044 	movi	r2,1
 909b90c:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909b910:	00800044 	movi	r2,1
 909b914:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 909b918:	e0bfa103 	ldbu	r2,-380(fp)
 909b91c:	1080004c 	andi	r2,r2,1
 909b920:	e0bfea15 	stw	r2,-88(fp)
 909b924:	e0bfa143 	ldbu	r2,-379(fp)
 909b928:	10800098 	cmpnei	r2,r2,2
 909b92c:	1000031e 	bne	r2,zero,909b93c <getPHYSpeed+0x34c>
 909b930:	00800084 	movi	r2,2
 909b934:	e0bfe915 	stw	r2,-92(fp)
 909b938:	00000106 	br	909b940 <getPHYSpeed+0x350>
 909b93c:	e03fe915 	stw	zero,-92(fp)
 909b940:	e0ffea17 	ldw	r3,-88(fp)
 909b944:	e13fe917 	ldw	r4,-92(fp)
 909b948:	1906b03a 	or	r3,r3,r4
 909b94c:	e0ffe815 	stw	r3,-96(fp)
 909b950:	e0bfa143 	ldbu	r2,-379(fp)
 909b954:	10800058 	cmpnei	r2,r2,1
 909b958:	1000031e 	bne	r2,zero,909b968 <getPHYSpeed+0x378>
 909b95c:	00800104 	movi	r2,4
 909b960:	e0bfe715 	stw	r2,-100(fp)
 909b964:	00000106 	br	909b96c <getPHYSpeed+0x37c>
 909b968:	e03fe715 	stw	zero,-100(fp)
 909b96c:	e0ffe817 	ldw	r3,-96(fp)
 909b970:	e13fe717 	ldw	r4,-100(fp)
 909b974:	1906b03a 	or	r3,r3,r4
 909b978:	e0ffe615 	stw	r3,-104(fp)
 909b97c:	e0bfa143 	ldbu	r2,-379(fp)
 909b980:	1004c03a 	cmpne	r2,r2,zero
 909b984:	1000031e 	bne	r2,zero,909b994 <getPHYSpeed+0x3a4>
 909b988:	00800204 	movi	r2,8
 909b98c:	e0bfe515 	stw	r2,-108(fp)
 909b990:	00000106 	br	909b998 <getPHYSpeed+0x3a8>
 909b994:	e03fe515 	stw	zero,-108(fp)
 909b998:	e0ffe617 	ldw	r3,-104(fp)
 909b99c:	e13fe517 	ldw	r4,-108(fp)
 909b9a0:	1906b03a 	or	r3,r3,r4
 909b9a4:	e0ffe415 	stw	r3,-112(fp)
 909b9a8:	e0bfa143 	ldbu	r2,-379(fp)
 909b9ac:	108000d8 	cmpnei	r2,r2,3
 909b9b0:	1000031e 	bne	r2,zero,909b9c0 <getPHYSpeed+0x3d0>
 909b9b4:	00800074 	movhi	r2,1
 909b9b8:	e0bfe315 	stw	r2,-116(fp)
 909b9bc:	00000106 	br	909b9c4 <getPHYSpeed+0x3d4>
 909b9c0:	e03fe315 	stw	zero,-116(fp)
 909b9c4:	e0ffe417 	ldw	r3,-112(fp)
 909b9c8:	e13fe317 	ldw	r4,-116(fp)
 909b9cc:	1904b03a 	or	r2,r3,r4
 909b9d0:	10801034 	orhi	r2,r2,64
 909b9d4:	e0bfa015 	stw	r2,-384(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 909b9d8:	010003f4 	movhi	r4,15
 909b9dc:	21109004 	addi	r4,r4,16960
 909b9e0:	90b9b600 	call	90b9b60 <usleep>
        if(psys->tse_phy_cfg) {
 909b9e4:	e0bf9c17 	ldw	r2,-400(fp)
 909b9e8:	10801117 	ldw	r2,68(r2)
 909b9ec:	1005003a 	cmpeq	r2,r2,zero
 909b9f0:	10000b1e 	bne	r2,zero,909ba20 <getPHYSpeed+0x430>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 909b9f4:	e17f9b07 	ldb	r5,-404(fp)
 909b9f8:	e1bf9b47 	ldb	r6,-403(fp)
 909b9fc:	01024374 	movhi	r4,2317
 909ba00:	2134ce04 	addi	r4,r4,-11464
 909ba04:	90825100 	call	9082510 <printf>
        	result = psys->tse_phy_cfg(pmac);
 909ba08:	e0bf9c17 	ldw	r2,-400(fp)
 909ba0c:	10801117 	ldw	r2,68(r2)
 909ba10:	e13fa217 	ldw	r4,-376(fp)
 909ba14:	103ee83a 	callr	r2
 909ba18:	e0bfa015 	stw	r2,-384(fp)
 909ba1c:	00002e06 	br	909bad8 <getPHYSpeed+0x4e8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909ba20:	e0bf9b07 	ldb	r2,-404(fp)
 909ba24:	e0bfe215 	stw	r2,-120(fp)
 909ba28:	e0bfa143 	ldbu	r2,-379(fp)
 909ba2c:	108000a0 	cmpeqi	r2,r2,2
 909ba30:	1000161e 	bne	r2,zero,909ba8c <getPHYSpeed+0x49c>
 909ba34:	e0bfa143 	ldbu	r2,-379(fp)
 909ba38:	10800060 	cmpeqi	r2,r2,1
 909ba3c:	10000d1e 	bne	r2,zero,909ba74 <getPHYSpeed+0x484>
 909ba40:	e0bfa143 	ldbu	r2,-379(fp)
 909ba44:	1004c03a 	cmpne	r2,r2,zero
 909ba48:	1000041e 	bne	r2,zero,909ba5c <getPHYSpeed+0x46c>
 909ba4c:	00c24374 	movhi	r3,2317
 909ba50:	18f49b04 	addi	r3,r3,-11668
 909ba54:	e0ffdf15 	stw	r3,-132(fp)
 909ba58:	00000306 	br	909ba68 <getPHYSpeed+0x478>
 909ba5c:	01024374 	movhi	r4,2317
 909ba60:	21349c04 	addi	r4,r4,-11664
 909ba64:	e13fdf15 	stw	r4,-132(fp)
 909ba68:	e0bfdf17 	ldw	r2,-132(fp)
 909ba6c:	e0bfe015 	stw	r2,-128(fp)
 909ba70:	00000306 	br	909ba80 <getPHYSpeed+0x490>
 909ba74:	00c24374 	movhi	r3,2317
 909ba78:	18f49e04 	addi	r3,r3,-11656
 909ba7c:	e0ffe015 	stw	r3,-128(fp)
 909ba80:	e13fe017 	ldw	r4,-128(fp)
 909ba84:	e13fe115 	stw	r4,-124(fp)
 909ba88:	00000306 	br	909ba98 <getPHYSpeed+0x4a8>
 909ba8c:	00824374 	movhi	r2,2317
 909ba90:	10b49f04 	addi	r2,r2,-11652
 909ba94:	e0bfe115 	stw	r2,-124(fp)
 909ba98:	e0bfa103 	ldbu	r2,-380(fp)
 909ba9c:	10800058 	cmpnei	r2,r2,1
 909baa0:	1000041e 	bne	r2,zero,909bab4 <getPHYSpeed+0x4c4>
 909baa4:	00c24374 	movhi	r3,2317
 909baa8:	18f4a104 	addi	r3,r3,-11644
 909baac:	e0ffde15 	stw	r3,-136(fp)
 909bab0:	00000306 	br	909bac0 <getPHYSpeed+0x4d0>
 909bab4:	01024374 	movhi	r4,2317
 909bab8:	2134a304 	addi	r4,r4,-11636
 909babc:	e13fde15 	stw	r4,-136(fp)
 909bac0:	01024374 	movhi	r4,2317
 909bac4:	2134e004 	addi	r4,r4,-11392
 909bac8:	e17fe217 	ldw	r5,-120(fp)
 909bacc:	e1bfe117 	ldw	r6,-124(fp)
 909bad0:	e1ffde17 	ldw	r7,-136(fp)
 909bad4:	90825100 	call	9082510 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 909bad8:	e0bfa017 	ldw	r2,-384(fp)
 909badc:	e0bfeb15 	stw	r2,-84(fp)
 909bae0:	00023f06 	br	909c3e0 <getPHYSpeed+0xdf0>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909bae4:	e0bf9d17 	ldw	r2,-396(fp)
 909bae8:	10800117 	ldw	r2,4(r2)
 909baec:	10800217 	ldw	r2,8(r2)
 909baf0:	10800017 	ldw	r2,0(r2)
 909baf4:	e0bf9a15 	stw	r2,-408(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 909baf8:	e0bf9f17 	ldw	r2,-388(fp)
 909bafc:	1004c03a 	cmpne	r2,r2,zero
 909bb00:	1000691e 	bne	r2,zero,909bca8 <getPHYSpeed+0x6b8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909bb04:	00800044 	movi	r2,1
 909bb08:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909bb0c:	00800044 	movi	r2,1
 909bb10:	e0bfa105 	stb	r2,-380(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 909bb14:	e0bfa103 	ldbu	r2,-380(fp)
 909bb18:	1080004c 	andi	r2,r2,1
 909bb1c:	e0bfdd15 	stw	r2,-140(fp)
 909bb20:	e0bfa143 	ldbu	r2,-379(fp)
 909bb24:	10800098 	cmpnei	r2,r2,2
 909bb28:	1000031e 	bne	r2,zero,909bb38 <getPHYSpeed+0x548>
 909bb2c:	00c00084 	movi	r3,2
 909bb30:	e0ffdc15 	stw	r3,-144(fp)
 909bb34:	00000106 	br	909bb3c <getPHYSpeed+0x54c>
 909bb38:	e03fdc15 	stw	zero,-144(fp)
 909bb3c:	e13fdd17 	ldw	r4,-140(fp)
 909bb40:	e0bfdc17 	ldw	r2,-144(fp)
 909bb44:	2088b03a 	or	r4,r4,r2
 909bb48:	e13fdb15 	stw	r4,-148(fp)
 909bb4c:	e0bfa143 	ldbu	r2,-379(fp)
 909bb50:	10800058 	cmpnei	r2,r2,1
 909bb54:	1000031e 	bne	r2,zero,909bb64 <getPHYSpeed+0x574>
 909bb58:	00c00104 	movi	r3,4
 909bb5c:	e0ffda15 	stw	r3,-152(fp)
 909bb60:	00000106 	br	909bb68 <getPHYSpeed+0x578>
 909bb64:	e03fda15 	stw	zero,-152(fp)
 909bb68:	e13fdb17 	ldw	r4,-148(fp)
 909bb6c:	e0bfda17 	ldw	r2,-152(fp)
 909bb70:	2088b03a 	or	r4,r4,r2
 909bb74:	e13fd915 	stw	r4,-156(fp)
 909bb78:	e0bfa143 	ldbu	r2,-379(fp)
 909bb7c:	1004c03a 	cmpne	r2,r2,zero
 909bb80:	1000031e 	bne	r2,zero,909bb90 <getPHYSpeed+0x5a0>
 909bb84:	00c00204 	movi	r3,8
 909bb88:	e0ffd815 	stw	r3,-160(fp)
 909bb8c:	00000106 	br	909bb94 <getPHYSpeed+0x5a4>
 909bb90:	e03fd815 	stw	zero,-160(fp)
 909bb94:	e13fd917 	ldw	r4,-156(fp)
 909bb98:	e0bfd817 	ldw	r2,-160(fp)
 909bb9c:	2088b03a 	or	r4,r4,r2
 909bba0:	e13fd715 	stw	r4,-164(fp)
 909bba4:	e0bfa143 	ldbu	r2,-379(fp)
 909bba8:	108000d8 	cmpnei	r2,r2,3
 909bbac:	1000031e 	bne	r2,zero,909bbbc <getPHYSpeed+0x5cc>
 909bbb0:	00c00074 	movhi	r3,1
 909bbb4:	e0ffd615 	stw	r3,-168(fp)
 909bbb8:	00000106 	br	909bbc0 <getPHYSpeed+0x5d0>
 909bbbc:	e03fd615 	stw	zero,-168(fp)
 909bbc0:	e13fd717 	ldw	r4,-164(fp)
 909bbc4:	e0ffd617 	ldw	r3,-168(fp)
 909bbc8:	20c4b03a 	or	r2,r4,r3
 909bbcc:	10800834 	orhi	r2,r2,32
 909bbd0:	e0bfa015 	stw	r2,-384(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909bbd4:	e13f9b07 	ldb	r4,-404(fp)
 909bbd8:	e13fd515 	stw	r4,-172(fp)
 909bbdc:	e0bf9b47 	ldb	r2,-403(fp)
 909bbe0:	e0bfd415 	stw	r2,-176(fp)
 909bbe4:	e0bfa143 	ldbu	r2,-379(fp)
 909bbe8:	108000a0 	cmpeqi	r2,r2,2
 909bbec:	1000161e 	bne	r2,zero,909bc48 <getPHYSpeed+0x658>
 909bbf0:	e0bfa143 	ldbu	r2,-379(fp)
 909bbf4:	10800060 	cmpeqi	r2,r2,1
 909bbf8:	10000d1e 	bne	r2,zero,909bc30 <getPHYSpeed+0x640>
 909bbfc:	e0bfa143 	ldbu	r2,-379(fp)
 909bc00:	1004c03a 	cmpne	r2,r2,zero
 909bc04:	1000041e 	bne	r2,zero,909bc18 <getPHYSpeed+0x628>
 909bc08:	00c24374 	movhi	r3,2317
 909bc0c:	18f49b04 	addi	r3,r3,-11668
 909bc10:	e0ffd115 	stw	r3,-188(fp)
 909bc14:	00000306 	br	909bc24 <getPHYSpeed+0x634>
 909bc18:	01024374 	movhi	r4,2317
 909bc1c:	21349c04 	addi	r4,r4,-11664
 909bc20:	e13fd115 	stw	r4,-188(fp)
 909bc24:	e0bfd117 	ldw	r2,-188(fp)
 909bc28:	e0bfd215 	stw	r2,-184(fp)
 909bc2c:	00000306 	br	909bc3c <getPHYSpeed+0x64c>
 909bc30:	00c24374 	movhi	r3,2317
 909bc34:	18f49e04 	addi	r3,r3,-11656
 909bc38:	e0ffd215 	stw	r3,-184(fp)
 909bc3c:	e13fd217 	ldw	r4,-184(fp)
 909bc40:	e13fd315 	stw	r4,-180(fp)
 909bc44:	00000306 	br	909bc54 <getPHYSpeed+0x664>
 909bc48:	00824374 	movhi	r2,2317
 909bc4c:	10b49f04 	addi	r2,r2,-11652
 909bc50:	e0bfd315 	stw	r2,-180(fp)
 909bc54:	e0bfa103 	ldbu	r2,-380(fp)
 909bc58:	10800058 	cmpnei	r2,r2,1
 909bc5c:	1000041e 	bne	r2,zero,909bc70 <getPHYSpeed+0x680>
 909bc60:	00c24374 	movhi	r3,2317
 909bc64:	18f4a104 	addi	r3,r3,-11644
 909bc68:	e0ffd015 	stw	r3,-192(fp)
 909bc6c:	00000306 	br	909bc7c <getPHYSpeed+0x68c>
 909bc70:	01024374 	movhi	r4,2317
 909bc74:	2134a304 	addi	r4,r4,-11636
 909bc78:	e13fd015 	stw	r4,-192(fp)
 909bc7c:	e0bfd017 	ldw	r2,-192(fp)
 909bc80:	d8800015 	stw	r2,0(sp)
 909bc84:	01024374 	movhi	r4,2317
 909bc88:	2134f204 	addi	r4,r4,-11320
 909bc8c:	e17fd517 	ldw	r5,-172(fp)
 909bc90:	e1bfd417 	ldw	r6,-176(fp)
 909bc94:	e1ffd317 	ldw	r7,-180(fp)
 909bc98:	90825100 	call	9082510 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 909bc9c:	e0ffa017 	ldw	r3,-384(fp)
 909bca0:	e0ffeb15 	stw	r3,-84(fp)
 909bca4:	0001ce06 	br	909c3e0 <getPHYSpeed+0xdf0>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 909bca8:	e0bf9e17 	ldw	r2,-392(fp)
 909bcac:	10800003 	ldbu	r2,0(r2)
 909bcb0:	10803fcc 	andi	r2,r2,255
 909bcb4:	10800058 	cmpnei	r2,r2,1
 909bcb8:	1000081e 	bne	r2,zero,909bcdc <getPHYSpeed+0x6ec>
			alt_tse_phy_set_adv_1000(pphy, 0);
 909bcbc:	e13f9f17 	ldw	r4,-388(fp)
 909bcc0:	000b883a 	mov	r5,zero
 909bcc4:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909bcc8:	e13f9f17 	ldw	r4,-388(fp)
 909bccc:	01400134 	movhi	r5,4
 909bcd0:	29742404 	addi	r5,r5,-12144
 909bcd4:	909da780 	call	909da78 <alt_tse_phy_restart_an>
 909bcd8:	00000f06 	br	909bd18 <getPHYSpeed+0x728>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 909bcdc:	e0bf9e17 	ldw	r2,-392(fp)
 909bce0:	10800003 	ldbu	r2,0(r2)
 909bce4:	10803fcc 	andi	r2,r2,255
 909bce8:	10800098 	cmpnei	r2,r2,2
 909bcec:	10000a1e 	bne	r2,zero,909bd18 <getPHYSpeed+0x728>
			alt_tse_phy_set_adv_100(pphy, 0);
 909bcf0:	e13f9f17 	ldw	r4,-388(fp)
 909bcf4:	000b883a 	mov	r5,zero
 909bcf8:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 909bcfc:	e13f9f17 	ldw	r4,-388(fp)
 909bd00:	000b883a 	mov	r5,zero
 909bd04:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909bd08:	e13f9f17 	ldw	r4,-388(fp)
 909bd0c:	01400134 	movhi	r5,4
 909bd10:	29742404 	addi	r5,r5,-12144
 909bd14:	909da780 	call	909da78 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 909bd18:	e13f9f17 	ldw	r4,-388(fp)
 909bd1c:	01400134 	movhi	r5,4
 909bd20:	29742404 	addi	r5,r5,-12144
 909bd24:	909dc280 	call	909dc28 <alt_tse_phy_check_link>
 909bd28:	10bfffd8 	cmpnei	r2,r2,-1
 909bd2c:	1000691e 	bne	r2,zero,909bed4 <getPHYSpeed+0x8e4>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909bd30:	00800044 	movi	r2,1
 909bd34:	e0bfa145 	stb	r2,-379(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909bd38:	00800044 	movi	r2,1
 909bd3c:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 909bd40:	e0bfa103 	ldbu	r2,-380(fp)
 909bd44:	1080004c 	andi	r2,r2,1
 909bd48:	e0bfcf15 	stw	r2,-196(fp)
 909bd4c:	e0bfa143 	ldbu	r2,-379(fp)
 909bd50:	10800098 	cmpnei	r2,r2,2
 909bd54:	1000031e 	bne	r2,zero,909bd64 <getPHYSpeed+0x774>
 909bd58:	01000084 	movi	r4,2
 909bd5c:	e13fce15 	stw	r4,-200(fp)
 909bd60:	00000106 	br	909bd68 <getPHYSpeed+0x778>
 909bd64:	e03fce15 	stw	zero,-200(fp)
 909bd68:	e0bfcf17 	ldw	r2,-196(fp)
 909bd6c:	e0ffce17 	ldw	r3,-200(fp)
 909bd70:	10c4b03a 	or	r2,r2,r3
 909bd74:	e0bfcd15 	stw	r2,-204(fp)
 909bd78:	e0bfa143 	ldbu	r2,-379(fp)
 909bd7c:	10800058 	cmpnei	r2,r2,1
 909bd80:	1000031e 	bne	r2,zero,909bd90 <getPHYSpeed+0x7a0>
 909bd84:	01000104 	movi	r4,4
 909bd88:	e13fcc15 	stw	r4,-208(fp)
 909bd8c:	00000106 	br	909bd94 <getPHYSpeed+0x7a4>
 909bd90:	e03fcc15 	stw	zero,-208(fp)
 909bd94:	e0bfcd17 	ldw	r2,-204(fp)
 909bd98:	e0ffcc17 	ldw	r3,-208(fp)
 909bd9c:	10c4b03a 	or	r2,r2,r3
 909bda0:	e0bfcb15 	stw	r2,-212(fp)
 909bda4:	e0bfa143 	ldbu	r2,-379(fp)
 909bda8:	1004c03a 	cmpne	r2,r2,zero
 909bdac:	1000031e 	bne	r2,zero,909bdbc <getPHYSpeed+0x7cc>
 909bdb0:	01000204 	movi	r4,8
 909bdb4:	e13fca15 	stw	r4,-216(fp)
 909bdb8:	00000106 	br	909bdc0 <getPHYSpeed+0x7d0>
 909bdbc:	e03fca15 	stw	zero,-216(fp)
 909bdc0:	e0bfcb17 	ldw	r2,-212(fp)
 909bdc4:	e0ffca17 	ldw	r3,-216(fp)
 909bdc8:	10c4b03a 	or	r2,r2,r3
 909bdcc:	e0bfc915 	stw	r2,-220(fp)
 909bdd0:	e0bfa143 	ldbu	r2,-379(fp)
 909bdd4:	108000d8 	cmpnei	r2,r2,3
 909bdd8:	1000031e 	bne	r2,zero,909bde8 <getPHYSpeed+0x7f8>
 909bddc:	01000074 	movhi	r4,1
 909bde0:	e13fc815 	stw	r4,-224(fp)
 909bde4:	00000106 	br	909bdec <getPHYSpeed+0x7fc>
 909bde8:	e03fc815 	stw	zero,-224(fp)
 909bdec:	e0ffc917 	ldw	r3,-220(fp)
 909bdf0:	e13fc817 	ldw	r4,-224(fp)
 909bdf4:	1904b03a 	or	r2,r3,r4
 909bdf8:	10800234 	orhi	r2,r2,8
 909bdfc:	e0bfa015 	stw	r2,-384(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909be00:	e0bf9b07 	ldb	r2,-404(fp)
 909be04:	e0bfc715 	stw	r2,-228(fp)
 909be08:	e0ff9b47 	ldb	r3,-403(fp)
 909be0c:	e0ffc615 	stw	r3,-232(fp)
 909be10:	e0bfa143 	ldbu	r2,-379(fp)
 909be14:	108000a0 	cmpeqi	r2,r2,2
 909be18:	1000161e 	bne	r2,zero,909be74 <getPHYSpeed+0x884>
 909be1c:	e0bfa143 	ldbu	r2,-379(fp)
 909be20:	10800060 	cmpeqi	r2,r2,1
 909be24:	10000d1e 	bne	r2,zero,909be5c <getPHYSpeed+0x86c>
 909be28:	e0bfa143 	ldbu	r2,-379(fp)
 909be2c:	1004c03a 	cmpne	r2,r2,zero
 909be30:	1000041e 	bne	r2,zero,909be44 <getPHYSpeed+0x854>
 909be34:	01024374 	movhi	r4,2317
 909be38:	21349b04 	addi	r4,r4,-11668
 909be3c:	e13fc315 	stw	r4,-244(fp)
 909be40:	00000306 	br	909be50 <getPHYSpeed+0x860>
 909be44:	00824374 	movhi	r2,2317
 909be48:	10b49c04 	addi	r2,r2,-11664
 909be4c:	e0bfc315 	stw	r2,-244(fp)
 909be50:	e0ffc317 	ldw	r3,-244(fp)
 909be54:	e0ffc415 	stw	r3,-240(fp)
 909be58:	00000306 	br	909be68 <getPHYSpeed+0x878>
 909be5c:	01024374 	movhi	r4,2317
 909be60:	21349e04 	addi	r4,r4,-11656
 909be64:	e13fc415 	stw	r4,-240(fp)
 909be68:	e0bfc417 	ldw	r2,-240(fp)
 909be6c:	e0bfc515 	stw	r2,-236(fp)
 909be70:	00000306 	br	909be80 <getPHYSpeed+0x890>
 909be74:	00c24374 	movhi	r3,2317
 909be78:	18f49f04 	addi	r3,r3,-11652
 909be7c:	e0ffc515 	stw	r3,-236(fp)
 909be80:	e0bfa103 	ldbu	r2,-380(fp)
 909be84:	10800058 	cmpnei	r2,r2,1
 909be88:	1000041e 	bne	r2,zero,909be9c <getPHYSpeed+0x8ac>
 909be8c:	01024374 	movhi	r4,2317
 909be90:	2134a104 	addi	r4,r4,-11644
 909be94:	e13fc215 	stw	r4,-248(fp)
 909be98:	00000306 	br	909bea8 <getPHYSpeed+0x8b8>
 909be9c:	00824374 	movhi	r2,2317
 909bea0:	10b4a304 	addi	r2,r2,-11636
 909bea4:	e0bfc215 	stw	r2,-248(fp)
 909bea8:	e0ffc217 	ldw	r3,-248(fp)
 909beac:	d8c00015 	stw	r3,0(sp)
 909beb0:	01024374 	movhi	r4,2317
 909beb4:	21350304 	addi	r4,r4,-11252
 909beb8:	e17fc717 	ldw	r5,-228(fp)
 909bebc:	e1bfc617 	ldw	r6,-232(fp)
 909bec0:	e1ffc517 	ldw	r7,-236(fp)
 909bec4:	90825100 	call	9082510 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 909bec8:	e13fa017 	ldw	r4,-384(fp)
 909becc:	e13feb15 	stw	r4,-84(fp)
 909bed0:	00014306 	br	909c3e0 <getPHYSpeed+0xdf0>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 909bed4:	e0bf9a17 	ldw	r2,-408(fp)
 909bed8:	10801004 	addi	r2,r2,64
 909bedc:	1009883a 	mov	r4,r2
 909bee0:	e0bf9f17 	ldw	r2,-388(fp)
 909bee4:	10800003 	ldbu	r2,0(r2)
 909bee8:	10c03fcc 	andi	r3,r2,255
 909beec:	2005883a 	mov	r2,r4
 909bef0:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 909bef4:	d8000015 	stw	zero,0(sp)
 909bef8:	e13f9f17 	ldw	r4,-388(fp)
 909befc:	000b883a 	mov	r5,zero
 909bf00:	01800384 	movi	r6,14
 909bf04:	01c00044 	movi	r7,1
 909bf08:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 909bf0c:	e0bf9f17 	ldw	r2,-388(fp)
 909bf10:	10800517 	ldw	r2,20(r2)
 909bf14:	1004c03a 	cmpne	r2,r2,zero
 909bf18:	10003a1e 	bne	r2,zero,909c004 <getPHYSpeed+0xa14>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 909bf1c:	e17f9b07 	ldb	r5,-404(fp)
 909bf20:	e1bf9b47 	ldb	r6,-403(fp)
 909bf24:	01024374 	movhi	r4,2317
 909bf28:	21351704 	addi	r4,r4,-11172
 909bf2c:	90825100 	call	9082510 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909bf30:	00800044 	movi	r2,1
 909bf34:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909bf38:	00800044 	movi	r2,1
 909bf3c:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 909bf40:	e0bfa103 	ldbu	r2,-380(fp)
 909bf44:	1080004c 	andi	r2,r2,1
 909bf48:	e0bfc115 	stw	r2,-252(fp)
 909bf4c:	e0bfa143 	ldbu	r2,-379(fp)
 909bf50:	10800098 	cmpnei	r2,r2,2
 909bf54:	1000031e 	bne	r2,zero,909bf64 <getPHYSpeed+0x974>
 909bf58:	00800084 	movi	r2,2
 909bf5c:	e0bfc015 	stw	r2,-256(fp)
 909bf60:	00000106 	br	909bf68 <getPHYSpeed+0x978>
 909bf64:	e03fc015 	stw	zero,-256(fp)
 909bf68:	e0ffc117 	ldw	r3,-252(fp)
 909bf6c:	e13fc017 	ldw	r4,-256(fp)
 909bf70:	1906b03a 	or	r3,r3,r4
 909bf74:	e0ffbf15 	stw	r3,-260(fp)
 909bf78:	e0bfa143 	ldbu	r2,-379(fp)
 909bf7c:	10800058 	cmpnei	r2,r2,1
 909bf80:	1000031e 	bne	r2,zero,909bf90 <getPHYSpeed+0x9a0>
 909bf84:	00800104 	movi	r2,4
 909bf88:	e0bfbe15 	stw	r2,-264(fp)
 909bf8c:	00000106 	br	909bf94 <getPHYSpeed+0x9a4>
 909bf90:	e03fbe15 	stw	zero,-264(fp)
 909bf94:	e0ffbf17 	ldw	r3,-260(fp)
 909bf98:	e13fbe17 	ldw	r4,-264(fp)
 909bf9c:	1906b03a 	or	r3,r3,r4
 909bfa0:	e0ffbd15 	stw	r3,-268(fp)
 909bfa4:	e0bfa143 	ldbu	r2,-379(fp)
 909bfa8:	1004c03a 	cmpne	r2,r2,zero
 909bfac:	1000031e 	bne	r2,zero,909bfbc <getPHYSpeed+0x9cc>
 909bfb0:	00800204 	movi	r2,8
 909bfb4:	e0bfbc15 	stw	r2,-272(fp)
 909bfb8:	00000106 	br	909bfc0 <getPHYSpeed+0x9d0>
 909bfbc:	e03fbc15 	stw	zero,-272(fp)
 909bfc0:	e0ffbd17 	ldw	r3,-268(fp)
 909bfc4:	e13fbc17 	ldw	r4,-272(fp)
 909bfc8:	1906b03a 	or	r3,r3,r4
 909bfcc:	e0ffbb15 	stw	r3,-276(fp)
 909bfd0:	e0bfa143 	ldbu	r2,-379(fp)
 909bfd4:	108000d8 	cmpnei	r2,r2,3
 909bfd8:	1000031e 	bne	r2,zero,909bfe8 <getPHYSpeed+0x9f8>
 909bfdc:	00800074 	movhi	r2,1
 909bfe0:	e0bfba15 	stw	r2,-280(fp)
 909bfe4:	00000106 	br	909bfec <getPHYSpeed+0x9fc>
 909bfe8:	e03fba15 	stw	zero,-280(fp)
 909bfec:	e0ffbb17 	ldw	r3,-276(fp)
 909bff0:	e13fba17 	ldw	r4,-280(fp)
 909bff4:	1904b03a 	or	r2,r3,r4
 909bff8:	10800134 	orhi	r2,r2,4
 909bffc:	e0bfa015 	stw	r2,-384(fp)
 909c000:	0000c306 	br	909c310 <getPHYSpeed+0xd20>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 909c004:	e0bf9f17 	ldw	r2,-388(fp)
 909c008:	10800517 	ldw	r2,20(r2)
 909c00c:	10801817 	ldw	r2,96(r2)
 909c010:	1005003a 	cmpeq	r2,r2,zero
 909c014:	1000371e 	bne	r2,zero,909c0f4 <getPHYSpeed+0xb04>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 909c018:	e0bf9f17 	ldw	r2,-388(fp)
 909c01c:	10800517 	ldw	r2,20(r2)
 909c020:	10801817 	ldw	r2,96(r2)
 909c024:	e13f9a17 	ldw	r4,-408(fp)
 909c028:	103ee83a 	callr	r2
 909c02c:	e0bfa015 	stw	r2,-384(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 909c030:	e0bfa017 	ldw	r2,-384(fp)
 909c034:	1080008c 	andi	r2,r2,2
 909c038:	1004c03a 	cmpne	r2,r2,zero
 909c03c:	1000141e 	bne	r2,zero,909c090 <getPHYSpeed+0xaa0>
 909c040:	e0bfa017 	ldw	r2,-384(fp)
 909c044:	1080010c 	andi	r2,r2,4
 909c048:	1004c03a 	cmpne	r2,r2,zero
 909c04c:	10000b1e 	bne	r2,zero,909c07c <getPHYSpeed+0xa8c>
 909c050:	e0bfa017 	ldw	r2,-384(fp)
 909c054:	1080020c 	andi	r2,r2,8
 909c058:	1005003a 	cmpeq	r2,r2,zero
 909c05c:	1000021e 	bne	r2,zero,909c068 <getPHYSpeed+0xa78>
 909c060:	e03fb945 	stb	zero,-283(fp)
 909c064:	00000206 	br	909c070 <getPHYSpeed+0xa80>
 909c068:	008000c4 	movi	r2,3
 909c06c:	e0bfb945 	stb	r2,-283(fp)
 909c070:	e0ffb943 	ldbu	r3,-283(fp)
 909c074:	e0ffb985 	stb	r3,-282(fp)
 909c078:	00000206 	br	909c084 <getPHYSpeed+0xa94>
 909c07c:	01000044 	movi	r4,1
 909c080:	e13fb985 	stb	r4,-282(fp)
 909c084:	e0bfb983 	ldbu	r2,-282(fp)
 909c088:	e0bfb9c5 	stb	r2,-281(fp)
 909c08c:	00000206 	br	909c098 <getPHYSpeed+0xaa8>
 909c090:	00c00084 	movi	r3,2
 909c094:	e0ffb9c5 	stb	r3,-281(fp)
 909c098:	e13fb9c3 	ldbu	r4,-281(fp)
 909c09c:	e13fa145 	stb	r4,-379(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 909c0a0:	e0bfa017 	ldw	r2,-384(fp)
 909c0a4:	1080004c 	andi	r2,r2,1
 909c0a8:	10803fcc 	andi	r2,r2,255
 909c0ac:	1005003a 	cmpeq	r2,r2,zero
 909c0b0:	1000031e 	bne	r2,zero,909c0c0 <getPHYSpeed+0xad0>
 909c0b4:	00800044 	movi	r2,1
 909c0b8:	e0bfb905 	stb	r2,-284(fp)
 909c0bc:	00000106 	br	909c0c4 <getPHYSpeed+0xad4>
 909c0c0:	e03fb905 	stb	zero,-284(fp)
 909c0c4:	e0ffb903 	ldbu	r3,-284(fp)
 909c0c8:	e0ffa105 	stb	r3,-380(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 909c0cc:	e0bfa017 	ldw	r2,-384(fp)
 909c0d0:	1080006c 	andhi	r2,r2,1
 909c0d4:	1005003a 	cmpeq	r2,r2,zero
 909c0d8:	10008d1e 	bne	r2,zero,909c310 <getPHYSpeed+0xd20>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 909c0dc:	e17f9b07 	ldb	r5,-404(fp)
 909c0e0:	e1bf9b47 	ldb	r6,-403(fp)
 909c0e4:	01024374 	movhi	r4,2317
 909c0e8:	21352504 	addi	r4,r4,-11116
 909c0ec:	90825100 	call	9082510 <printf>
 909c0f0:	00008706 	br	909c310 <getPHYSpeed+0xd20>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 909c0f4:	e0bf9f17 	ldw	r2,-388(fp)
 909c0f8:	10800517 	ldw	r2,20(r2)
 909c0fc:	10801583 	ldbu	r2,86(r2)
 909c100:	10803fcc 	andi	r2,r2,255
 909c104:	1004c03a 	cmpne	r2,r2,zero
 909c108:	10003a1e 	bne	r2,zero,909c1f4 <getPHYSpeed+0xc04>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 909c10c:	e17f9b07 	ldb	r5,-404(fp)
 909c110:	e1bf9b47 	ldb	r6,-403(fp)
 909c114:	01024374 	movhi	r4,2317
 909c118:	21353204 	addi	r4,r4,-11064
 909c11c:	90825100 	call	9082510 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909c120:	00800044 	movi	r2,1
 909c124:	e0bfa145 	stb	r2,-379(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909c128:	00800044 	movi	r2,1
 909c12c:	e0bfa105 	stb	r2,-380(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 909c130:	e0bfa103 	ldbu	r2,-380(fp)
 909c134:	1080004c 	andi	r2,r2,1
 909c138:	e0bfb815 	stw	r2,-288(fp)
 909c13c:	e0bfa143 	ldbu	r2,-379(fp)
 909c140:	10800098 	cmpnei	r2,r2,2
 909c144:	1000031e 	bne	r2,zero,909c154 <getPHYSpeed+0xb64>
 909c148:	01000084 	movi	r4,2
 909c14c:	e13fb715 	stw	r4,-292(fp)
 909c150:	00000106 	br	909c158 <getPHYSpeed+0xb68>
 909c154:	e03fb715 	stw	zero,-292(fp)
 909c158:	e0bfb817 	ldw	r2,-288(fp)
 909c15c:	e0ffb717 	ldw	r3,-292(fp)
 909c160:	10c4b03a 	or	r2,r2,r3
 909c164:	e0bfb615 	stw	r2,-296(fp)
 909c168:	e0bfa143 	ldbu	r2,-379(fp)
 909c16c:	10800058 	cmpnei	r2,r2,1
 909c170:	1000031e 	bne	r2,zero,909c180 <getPHYSpeed+0xb90>
 909c174:	01000104 	movi	r4,4
 909c178:	e13fb515 	stw	r4,-300(fp)
 909c17c:	00000106 	br	909c184 <getPHYSpeed+0xb94>
 909c180:	e03fb515 	stw	zero,-300(fp)
 909c184:	e0bfb617 	ldw	r2,-296(fp)
 909c188:	e0ffb517 	ldw	r3,-300(fp)
 909c18c:	10c4b03a 	or	r2,r2,r3
 909c190:	e0bfb415 	stw	r2,-304(fp)
 909c194:	e0bfa143 	ldbu	r2,-379(fp)
 909c198:	1004c03a 	cmpne	r2,r2,zero
 909c19c:	1000031e 	bne	r2,zero,909c1ac <getPHYSpeed+0xbbc>
 909c1a0:	01000204 	movi	r4,8
 909c1a4:	e13fb315 	stw	r4,-308(fp)
 909c1a8:	00000106 	br	909c1b0 <getPHYSpeed+0xbc0>
 909c1ac:	e03fb315 	stw	zero,-308(fp)
 909c1b0:	e0bfb417 	ldw	r2,-304(fp)
 909c1b4:	e0ffb317 	ldw	r3,-308(fp)
 909c1b8:	10c4b03a 	or	r2,r2,r3
 909c1bc:	e0bfb215 	stw	r2,-312(fp)
 909c1c0:	e0bfa143 	ldbu	r2,-379(fp)
 909c1c4:	108000d8 	cmpnei	r2,r2,3
 909c1c8:	1000031e 	bne	r2,zero,909c1d8 <getPHYSpeed+0xbe8>
 909c1cc:	01000074 	movhi	r4,1
 909c1d0:	e13fb115 	stw	r4,-316(fp)
 909c1d4:	00000106 	br	909c1dc <getPHYSpeed+0xbec>
 909c1d8:	e03fb115 	stw	zero,-316(fp)
 909c1dc:	e0ffb217 	ldw	r3,-312(fp)
 909c1e0:	e13fb117 	ldw	r4,-316(fp)
 909c1e4:	1904b03a 	or	r2,r3,r4
 909c1e8:	108000b4 	orhi	r2,r2,2
 909c1ec:	e0bfa015 	stw	r2,-384(fp)
 909c1f0:	00004706 	br	909c310 <getPHYSpeed+0xd20>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 909c1f4:	e0bf9f17 	ldw	r2,-388(fp)
 909c1f8:	10800517 	ldw	r2,20(r2)
 909c1fc:	10801583 	ldbu	r2,86(r2)
 909c200:	11403fcc 	andi	r5,r2,255
 909c204:	e0bf9f17 	ldw	r2,-388(fp)
 909c208:	10800517 	ldw	r2,20(r2)
 909c20c:	108015c3 	ldbu	r2,87(r2)
 909c210:	11803fcc 	andi	r6,r2,255
 909c214:	e13f9f17 	ldw	r4,-388(fp)
 909c218:	01c00084 	movi	r7,2
 909c21c:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909c220:	e0bfa145 	stb	r2,-379(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 909c224:	e0bf9f17 	ldw	r2,-388(fp)
 909c228:	10800517 	ldw	r2,20(r2)
 909c22c:	10801583 	ldbu	r2,86(r2)
 909c230:	11403fcc 	andi	r5,r2,255
 909c234:	e0bf9f17 	ldw	r2,-388(fp)
 909c238:	10800517 	ldw	r2,20(r2)
 909c23c:	10801603 	ldbu	r2,88(r2)
 909c240:	11803fcc 	andi	r6,r2,255
 909c244:	e13f9f17 	ldw	r4,-388(fp)
 909c248:	01c00044 	movi	r7,1
 909c24c:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909c250:	e0bfa105 	stb	r2,-380(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 909c254:	e0bfa103 	ldbu	r2,-380(fp)
 909c258:	1080004c 	andi	r2,r2,1
 909c25c:	e0bfb015 	stw	r2,-320(fp)
 909c260:	e0bfa143 	ldbu	r2,-379(fp)
 909c264:	10800098 	cmpnei	r2,r2,2
 909c268:	1000031e 	bne	r2,zero,909c278 <getPHYSpeed+0xc88>
 909c26c:	00800084 	movi	r2,2
 909c270:	e0bfaf15 	stw	r2,-324(fp)
 909c274:	00000106 	br	909c27c <getPHYSpeed+0xc8c>
 909c278:	e03faf15 	stw	zero,-324(fp)
 909c27c:	e0ffb017 	ldw	r3,-320(fp)
 909c280:	e13faf17 	ldw	r4,-324(fp)
 909c284:	1906b03a 	or	r3,r3,r4
 909c288:	e0ffae15 	stw	r3,-328(fp)
 909c28c:	e0bfa143 	ldbu	r2,-379(fp)
 909c290:	10800058 	cmpnei	r2,r2,1
 909c294:	1000031e 	bne	r2,zero,909c2a4 <getPHYSpeed+0xcb4>
 909c298:	00800104 	movi	r2,4
 909c29c:	e0bfad15 	stw	r2,-332(fp)
 909c2a0:	00000106 	br	909c2a8 <getPHYSpeed+0xcb8>
 909c2a4:	e03fad15 	stw	zero,-332(fp)
 909c2a8:	e0ffae17 	ldw	r3,-328(fp)
 909c2ac:	e13fad17 	ldw	r4,-332(fp)
 909c2b0:	1906b03a 	or	r3,r3,r4
 909c2b4:	e0ffac15 	stw	r3,-336(fp)
 909c2b8:	e0bfa143 	ldbu	r2,-379(fp)
 909c2bc:	1004c03a 	cmpne	r2,r2,zero
 909c2c0:	1000031e 	bne	r2,zero,909c2d0 <getPHYSpeed+0xce0>
 909c2c4:	00800204 	movi	r2,8
 909c2c8:	e0bfab15 	stw	r2,-340(fp)
 909c2cc:	00000106 	br	909c2d4 <getPHYSpeed+0xce4>
 909c2d0:	e03fab15 	stw	zero,-340(fp)
 909c2d4:	e0ffac17 	ldw	r3,-336(fp)
 909c2d8:	e13fab17 	ldw	r4,-340(fp)
 909c2dc:	1906b03a 	or	r3,r3,r4
 909c2e0:	e0ffaa15 	stw	r3,-344(fp)
 909c2e4:	e0bfa143 	ldbu	r2,-379(fp)
 909c2e8:	108000d8 	cmpnei	r2,r2,3
 909c2ec:	1000031e 	bne	r2,zero,909c2fc <getPHYSpeed+0xd0c>
 909c2f0:	00800074 	movhi	r2,1
 909c2f4:	e0bfa915 	stw	r2,-348(fp)
 909c2f8:	00000106 	br	909c300 <getPHYSpeed+0xd10>
 909c2fc:	e03fa915 	stw	zero,-348(fp)
 909c300:	e0ffaa17 	ldw	r3,-344(fp)
 909c304:	e13fa917 	ldw	r4,-348(fp)
 909c308:	1904b03a 	or	r2,r3,r4
 909c30c:	e0bfa015 	stw	r2,-384(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909c310:	e0bf9b07 	ldb	r2,-404(fp)
 909c314:	e0bfa815 	stw	r2,-352(fp)
 909c318:	e0ff9b47 	ldb	r3,-403(fp)
 909c31c:	e0ffa715 	stw	r3,-356(fp)
 909c320:	e0bfa143 	ldbu	r2,-379(fp)
 909c324:	108000a0 	cmpeqi	r2,r2,2
 909c328:	1000161e 	bne	r2,zero,909c384 <getPHYSpeed+0xd94>
 909c32c:	e0bfa143 	ldbu	r2,-379(fp)
 909c330:	10800060 	cmpeqi	r2,r2,1
 909c334:	10000d1e 	bne	r2,zero,909c36c <getPHYSpeed+0xd7c>
 909c338:	e0bfa143 	ldbu	r2,-379(fp)
 909c33c:	1004c03a 	cmpne	r2,r2,zero
 909c340:	1000041e 	bne	r2,zero,909c354 <getPHYSpeed+0xd64>
 909c344:	01024374 	movhi	r4,2317
 909c348:	21349b04 	addi	r4,r4,-11668
 909c34c:	e13fa415 	stw	r4,-368(fp)
 909c350:	00000306 	br	909c360 <getPHYSpeed+0xd70>
 909c354:	00824374 	movhi	r2,2317
 909c358:	10b49c04 	addi	r2,r2,-11664
 909c35c:	e0bfa415 	stw	r2,-368(fp)
 909c360:	e0ffa417 	ldw	r3,-368(fp)
 909c364:	e0ffa515 	stw	r3,-364(fp)
 909c368:	00000306 	br	909c378 <getPHYSpeed+0xd88>
 909c36c:	01024374 	movhi	r4,2317
 909c370:	21349e04 	addi	r4,r4,-11656
 909c374:	e13fa515 	stw	r4,-364(fp)
 909c378:	e0bfa517 	ldw	r2,-364(fp)
 909c37c:	e0bfa615 	stw	r2,-360(fp)
 909c380:	00000306 	br	909c390 <getPHYSpeed+0xda0>
 909c384:	00c24374 	movhi	r3,2317
 909c388:	18f49f04 	addi	r3,r3,-11652
 909c38c:	e0ffa615 	stw	r3,-360(fp)
 909c390:	e0bfa103 	ldbu	r2,-380(fp)
 909c394:	10800058 	cmpnei	r2,r2,1
 909c398:	1000041e 	bne	r2,zero,909c3ac <getPHYSpeed+0xdbc>
 909c39c:	01024374 	movhi	r4,2317
 909c3a0:	2134a104 	addi	r4,r4,-11644
 909c3a4:	e13fa315 	stw	r4,-372(fp)
 909c3a8:	00000306 	br	909c3b8 <getPHYSpeed+0xdc8>
 909c3ac:	00824374 	movhi	r2,2317
 909c3b0:	10b4a304 	addi	r2,r2,-11636
 909c3b4:	e0bfa315 	stw	r2,-372(fp)
 909c3b8:	e0ffa317 	ldw	r3,-372(fp)
 909c3bc:	d8c00015 	stw	r3,0(sp)
 909c3c0:	01024374 	movhi	r4,2317
 909c3c4:	21354904 	addi	r4,r4,-10972
 909c3c8:	e17fa817 	ldw	r5,-352(fp)
 909c3cc:	e1bfa717 	ldw	r6,-356(fp)
 909c3d0:	e1ffa617 	ldw	r7,-360(fp)
 909c3d4:	90825100 	call	9082510 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 909c3d8:	e13fa017 	ldw	r4,-384(fp)
 909c3dc:	e13feb15 	stw	r4,-84(fp)
 909c3e0:	e0bfeb17 	ldw	r2,-84(fp)
}
 909c3e4:	e037883a 	mov	sp,fp
 909c3e8:	dfc00117 	ldw	ra,4(sp)
 909c3ec:	df000017 	ldw	fp,0(sp)
 909c3f0:	dec00204 	addi	sp,sp,8
 909c3f4:	f800283a 	ret

0909c3f8 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 909c3f8:	defffd04 	addi	sp,sp,-12
 909c3fc:	df000215 	stw	fp,8(sp)
 909c400:	df000204 	addi	fp,sp,8
 909c404:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909c408:	e0bfff17 	ldw	r2,-4(fp)
 909c40c:	10800617 	ldw	r2,24(r2)
 909c410:	10800317 	ldw	r2,12(r2)
 909c414:	10800117 	ldw	r2,4(r2)
 909c418:	10800217 	ldw	r2,8(r2)
 909c41c:	10800017 	ldw	r2,0(r2)
 909c420:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909c424:	e0bffe17 	ldw	r2,-8(fp)
 909c428:	10801004 	addi	r2,r2,64
 909c42c:	10800037 	ldwio	r2,0(r2)
}
 909c430:	e037883a 	mov	sp,fp
 909c434:	df000017 	ldw	fp,0(sp)
 909c438:	dec00104 	addi	sp,sp,4
 909c43c:	f800283a 	ret

0909c440 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 909c440:	defffc04 	addi	sp,sp,-16
 909c444:	df000315 	stw	fp,12(sp)
 909c448:	df000304 	addi	fp,sp,12
 909c44c:	e13ffe15 	stw	r4,-8(fp)
 909c450:	e17fff05 	stb	r5,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909c454:	e0bffe17 	ldw	r2,-8(fp)
 909c458:	10800617 	ldw	r2,24(r2)
 909c45c:	10800317 	ldw	r2,12(r2)
 909c460:	10800117 	ldw	r2,4(r2)
 909c464:	10800217 	ldw	r2,8(r2)
 909c468:	10800017 	ldw	r2,0(r2)
 909c46c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 909c470:	e0bffd17 	ldw	r2,-12(fp)
 909c474:	10801004 	addi	r2,r2,64
 909c478:	e0ffff03 	ldbu	r3,-4(fp)
 909c47c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 909c480:	0005883a 	mov	r2,zero
}
 909c484:	e037883a 	mov	sp,fp
 909c488:	df000017 	ldw	fp,0(sp)
 909c48c:	dec00104 	addi	sp,sp,4
 909c490:	f800283a 	ret

0909c494 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 909c494:	defff704 	addi	sp,sp,-36
 909c498:	df000815 	stw	fp,32(sp)
 909c49c:	df000804 	addi	fp,sp,32
 909c4a0:	e13ffb15 	stw	r4,-20(fp)
 909c4a4:	e0800117 	ldw	r2,4(fp)
 909c4a8:	e17ffc05 	stb	r5,-16(fp)
 909c4ac:	e1bffd05 	stb	r6,-12(fp)
 909c4b0:	e1fffe05 	stb	r7,-8(fp)
 909c4b4:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909c4b8:	e0bffb17 	ldw	r2,-20(fp)
 909c4bc:	10800617 	ldw	r2,24(r2)
 909c4c0:	10800317 	ldw	r2,12(r2)
 909c4c4:	10800117 	ldw	r2,4(r2)
 909c4c8:	10800217 	ldw	r2,8(r2)
 909c4cc:	10800017 	ldw	r2,0(r2)
 909c4d0:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 909c4d4:	e03ffa0d 	sth	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909c4d8:	e03ff915 	stw	zero,-28(fp)
 909c4dc:	00000906 	br	909c504 <alt_tse_phy_wr_mdio_reg+0x70>
    {
        bit_mask <<= 1;
 909c4e0:	e0bffa0b 	ldhu	r2,-24(fp)
 909c4e4:	1085883a 	add	r2,r2,r2
 909c4e8:	e0bffa0d 	sth	r2,-24(fp)
        bit_mask |= 0x01;        
 909c4ec:	e0bffa0b 	ldhu	r2,-24(fp)
 909c4f0:	10800054 	ori	r2,r2,1
 909c4f4:	e0bffa0d 	sth	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909c4f8:	e0bff917 	ldw	r2,-28(fp)
 909c4fc:	10800044 	addi	r2,r2,1
 909c500:	e0bff915 	stw	r2,-28(fp)
 909c504:	e0fffe03 	ldbu	r3,-8(fp)
 909c508:	e0bff917 	ldw	r2,-28(fp)
 909c50c:	10fff416 	blt	r2,r3,909c4e0 <alt_tse_phy_wr_mdio_reg+0x4c>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 909c510:	e0fffa0b 	ldhu	r3,-24(fp)
 909c514:	e0bffd03 	ldbu	r2,-12(fp)
 909c518:	1884983a 	sll	r2,r3,r2
 909c51c:	e0bffa0d 	sth	r2,-24(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 909c520:	e0bff817 	ldw	r2,-32(fp)
 909c524:	1080a004 	addi	r2,r2,640
 909c528:	1007883a 	mov	r3,r2
 909c52c:	e0bffc03 	ldbu	r2,-16(fp)
 909c530:	1085883a 	add	r2,r2,r2
 909c534:	1085883a 	add	r2,r2,r2
 909c538:	1885883a 	add	r2,r3,r2
 909c53c:	10800037 	ldwio	r2,0(r2)
 909c540:	e0bffa8d 	sth	r2,-22(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 909c544:	e0bffa0b 	ldhu	r2,-24(fp)
 909c548:	0084303a 	nor	r2,zero,r2
 909c54c:	1007883a 	mov	r3,r2
 909c550:	e0bffa8b 	ldhu	r2,-22(fp)
 909c554:	1884703a 	and	r2,r3,r2
 909c558:	e0bffa8d 	sth	r2,-22(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 909c55c:	e0ffff0b 	ldhu	r3,-4(fp)
 909c560:	e0bffd03 	ldbu	r2,-12(fp)
 909c564:	1884983a 	sll	r2,r3,r2
 909c568:	1007883a 	mov	r3,r2
 909c56c:	e0bffa0b 	ldhu	r2,-24(fp)
 909c570:	1884703a 	and	r2,r3,r2
 909c574:	1007883a 	mov	r3,r2
 909c578:	e0bffa8b 	ldhu	r2,-22(fp)
 909c57c:	1884b03a 	or	r2,r3,r2
 909c580:	e0bffa8d 	sth	r2,-22(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 909c584:	e0bff817 	ldw	r2,-32(fp)
 909c588:	1080a004 	addi	r2,r2,640
 909c58c:	1007883a 	mov	r3,r2
 909c590:	e0bffc03 	ldbu	r2,-16(fp)
 909c594:	1085883a 	add	r2,r2,r2
 909c598:	1085883a 	add	r2,r2,r2
 909c59c:	1885883a 	add	r2,r3,r2
 909c5a0:	e0fffa8b 	ldhu	r3,-22(fp)
 909c5a4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 909c5a8:	0005883a 	mov	r2,zero
    
}
 909c5ac:	e037883a 	mov	sp,fp
 909c5b0:	df000017 	ldw	fp,0(sp)
 909c5b4:	dec00104 	addi	sp,sp,4
 909c5b8:	f800283a 	ret

0909c5bc <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 909c5bc:	defff704 	addi	sp,sp,-36
 909c5c0:	df000815 	stw	fp,32(sp)
 909c5c4:	df000804 	addi	fp,sp,32
 909c5c8:	e13ffc15 	stw	r4,-16(fp)
 909c5cc:	e17ffd05 	stb	r5,-12(fp)
 909c5d0:	e1bffe05 	stb	r6,-8(fp)
 909c5d4:	e1ffff05 	stb	r7,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909c5d8:	e0bffc17 	ldw	r2,-16(fp)
 909c5dc:	10800617 	ldw	r2,24(r2)
 909c5e0:	10800317 	ldw	r2,12(r2)
 909c5e4:	10800117 	ldw	r2,4(r2)
 909c5e8:	10800217 	ldw	r2,8(r2)
 909c5ec:	10800017 	ldw	r2,0(r2)
 909c5f0:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 909c5f4:	e03ffa15 	stw	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909c5f8:	e03ff915 	stw	zero,-28(fp)
 909c5fc:	00000906 	br	909c624 <alt_tse_phy_rd_mdio_reg+0x68>
    {
        bit_mask <<= 1;
 909c600:	e0bffa17 	ldw	r2,-24(fp)
 909c604:	1085883a 	add	r2,r2,r2
 909c608:	e0bffa15 	stw	r2,-24(fp)
        bit_mask |= 0x01;        
 909c60c:	e0bffa17 	ldw	r2,-24(fp)
 909c610:	10800054 	ori	r2,r2,1
 909c614:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909c618:	e0bff917 	ldw	r2,-28(fp)
 909c61c:	10800044 	addi	r2,r2,1
 909c620:	e0bff915 	stw	r2,-28(fp)
 909c624:	e0ffff03 	ldbu	r3,-4(fp)
 909c628:	e0bff917 	ldw	r2,-28(fp)
 909c62c:	10fff416 	blt	r2,r3,909c600 <alt_tse_phy_rd_mdio_reg+0x44>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 909c630:	e0bff817 	ldw	r2,-32(fp)
 909c634:	1080a004 	addi	r2,r2,640
 909c638:	1007883a 	mov	r3,r2
 909c63c:	e0bffd03 	ldbu	r2,-12(fp)
 909c640:	1085883a 	add	r2,r2,r2
 909c644:	1085883a 	add	r2,r2,r2
 909c648:	1885883a 	add	r2,r3,r2
 909c64c:	10800037 	ldwio	r2,0(r2)
 909c650:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 909c654:	e0fffb0b 	ldhu	r3,-20(fp)
 909c658:	e0bffe03 	ldbu	r2,-8(fp)
 909c65c:	1885d83a 	sra	r2,r3,r2
 909c660:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 909c664:	e0fffb0b 	ldhu	r3,-20(fp)
 909c668:	e0bffa17 	ldw	r2,-24(fp)
 909c66c:	1884703a 	and	r2,r3,r2
}
 909c670:	e037883a 	mov	sp,fp
 909c674:	df000017 	ldw	fp,0(sp)
 909c678:	dec00104 	addi	sp,sp,4
 909c67c:	f800283a 	ret

0909c680 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 909c680:	deff9a04 	addi	sp,sp,-408
 909c684:	dfc06515 	stw	ra,404(sp)
 909c688:	df006415 	stw	fp,400(sp)
 909c68c:	df006404 	addi	fp,sp,400
                            0x11,                   /* Location of Status Register                                   */
                            14,                     /* Location of Speed Status                                      */
                            13,                     /* Location of Duplex Status                                     */
                            10,                     /* Location of Link Status                                       */
                            &marvell_phy_cfg        /* Function pointer to configure Marvell PHY                     */
                           };
 909c690:	e13f9c04 	addi	r4,fp,-400
 909c694:	01801904 	movi	r6,100
 909c698:	000b883a 	mov	r5,zero
 909c69c:	90823f80 	call	90823f8 <memset>
 909c6a0:	00c24374 	movhi	r3,2317
 909c6a4:	18f55504 	addi	r3,r3,-10924
 909c6a8:	18800017 	ldw	r2,0(r3)
 909c6ac:	e0bf9c15 	stw	r2,-400(fp)
 909c6b0:	18800117 	ldw	r2,4(r3)
 909c6b4:	e0bf9d15 	stw	r2,-396(fp)
 909c6b8:	18800217 	ldw	r2,8(r3)
 909c6bc:	e0bf9e15 	stw	r2,-392(fp)
 909c6c0:	18800317 	ldw	r2,12(r3)
 909c6c4:	e0bf9f15 	stw	r2,-388(fp)
 909c6c8:	e13fa004 	addi	r4,fp,-384
 909c6cc:	01801004 	movi	r6,64
 909c6d0:	000b883a 	mov	r5,zero
 909c6d4:	90823f80 	call	90823f8 <memset>
 909c6d8:	009410c4 	movi	r2,20547
 909c6dc:	e0bfb015 	stw	r2,-320(fp)
 909c6e0:	00800304 	movi	r2,12
 909c6e4:	e0bfb105 	stb	r2,-316(fp)
 909c6e8:	00800084 	movi	r2,2
 909c6ec:	e0bfb145 	stb	r2,-315(fp)
 909c6f0:	00800444 	movi	r2,17
 909c6f4:	e0bfb185 	stb	r2,-314(fp)
 909c6f8:	00800384 	movi	r2,14
 909c6fc:	e0bfb1c5 	stb	r2,-313(fp)
 909c700:	00800344 	movi	r2,13
 909c704:	e0bfb205 	stb	r2,-312(fp)
 909c708:	00800284 	movi	r2,10
 909c70c:	e0bfb245 	stb	r2,-311(fp)
 909c710:	008242b4 	movhi	r2,2314
 909c714:	10bbfa04 	addi	r2,r2,-4120
 909c718:	e0bfb315 	stw	r2,-308(fp)
                            0x11,                            /* Location of Status Register                                   */
                            14,                              /* Location of Speed Status                                      */
                            13,                              /* Location of Duplex Status                                     */
                            10,                              /* Location of Link Status                                       */
                            &marvell_phy_cfg                 /* Function pointer to configure Marvell PHY                     */
                           };
 909c71c:	e13fb504 	addi	r4,fp,-300
 909c720:	01801904 	movi	r6,100
 909c724:	000b883a 	mov	r5,zero
 909c728:	90823f80 	call	90823f8 <memset>
 909c72c:	00c24374 	movhi	r3,2317
 909c730:	18f56904 	addi	r3,r3,-10844
 909c734:	18800017 	ldw	r2,0(r3)
 909c738:	e0bfb515 	stw	r2,-300(fp)
 909c73c:	18800117 	ldw	r2,4(r3)
 909c740:	e0bfb615 	stw	r2,-296(fp)
 909c744:	18800217 	ldw	r2,8(r3)
 909c748:	e0bfb715 	stw	r2,-292(fp)
 909c74c:	18800317 	ldw	r2,12(r3)
 909c750:	e0bfb815 	stw	r2,-288(fp)
 909c754:	18800417 	ldw	r2,16(r3)
 909c758:	e0bfb915 	stw	r2,-284(fp)
 909c75c:	18800517 	ldw	r2,20(r3)
 909c760:	e0bfba15 	stw	r2,-280(fp)
 909c764:	18800603 	ldbu	r2,24(r3)
 909c768:	e0bfbb05 	stb	r2,-276(fp)
 909c76c:	e13fbb44 	addi	r4,fp,-275
 909c770:	01800dc4 	movi	r6,55
 909c774:	000b883a 	mov	r5,zero
 909c778:	90823f80 	call	90823f8 <memset>
 909c77c:	009410c4 	movi	r2,20547
 909c780:	e0bfc915 	stw	r2,-220(fp)
 909c784:	00800344 	movi	r2,13
 909c788:	e0bfca05 	stb	r2,-216(fp)
 909c78c:	00800084 	movi	r2,2
 909c790:	e0bfca45 	stb	r2,-215(fp)
 909c794:	00800444 	movi	r2,17
 909c798:	e0bfca85 	stb	r2,-214(fp)
 909c79c:	00800384 	movi	r2,14
 909c7a0:	e0bfcac5 	stb	r2,-213(fp)
 909c7a4:	00800344 	movi	r2,13
 909c7a8:	e0bfcb05 	stb	r2,-212(fp)
 909c7ac:	00800284 	movi	r2,10
 909c7b0:	e0bfcb45 	stb	r2,-211(fp)
 909c7b4:	008242b4 	movhi	r2,2314
 909c7b8:	10bbfa04 	addi	r2,r2,-4120
 909c7bc:	e0bfcc15 	stw	r2,-208(fp)
                          DP83865_REV,            /* Model Revision Number                            */
                          0x11,                   /* Location of Status Register                      */
                          3,                      /* Location of Speed Status                         */
                          1,                      /* Location of Duplex Status                        */
                          2                       /* Location of Link Status                          */
                         };
 909c7c0:	e13fce04 	addi	r4,fp,-200
 909c7c4:	01801904 	movi	r6,100
 909c7c8:	000b883a 	mov	r5,zero
 909c7cc:	90823f80 	call	90823f8 <memset>
 909c7d0:	00c24374 	movhi	r3,2317
 909c7d4:	18f57d04 	addi	r3,r3,-10764
 909c7d8:	18800017 	ldw	r2,0(r3)
 909c7dc:	e0bfce15 	stw	r2,-200(fp)
 909c7e0:	18800117 	ldw	r2,4(r3)
 909c7e4:	e0bfcf15 	stw	r2,-196(fp)
 909c7e8:	18800217 	ldw	r2,8(r3)
 909c7ec:	e0bfd015 	stw	r2,-192(fp)
 909c7f0:	18800317 	ldw	r2,12(r3)
 909c7f4:	e0bfd115 	stw	r2,-188(fp)
 909c7f8:	18800403 	ldbu	r2,16(r3)
 909c7fc:	e0bfd205 	stb	r2,-184(fp)
 909c800:	e13fd244 	addi	r4,fp,-183
 909c804:	01800fc4 	movi	r6,63
 909c808:	000b883a 	mov	r5,zero
 909c80c:	90823f80 	call	90823f8 <memset>
 909c810:	00800234 	movhi	r2,8
 909c814:	108005c4 	addi	r2,r2,23
 909c818:	e0bfe215 	stw	r2,-120(fp)
 909c81c:	008001c4 	movi	r2,7
 909c820:	e0bfe305 	stb	r2,-116(fp)
 909c824:	00800284 	movi	r2,10
 909c828:	e0bfe345 	stb	r2,-115(fp)
 909c82c:	00800444 	movi	r2,17
 909c830:	e0bfe385 	stb	r2,-114(fp)
 909c834:	008000c4 	movi	r2,3
 909c838:	e0bfe3c5 	stb	r2,-113(fp)
 909c83c:	00800044 	movi	r2,1
 909c840:	e0bfe405 	stb	r2,-112(fp)
 909c844:	00800084 	movi	r2,2
 909c848:	e0bfe445 	stb	r2,-111(fp)
                           0,                              /* Location of Speed Status    (ignored)                      */
                           0,                              /* Location of Duplex Status   (ignored)                      */
                           0,                              /* Location of Link Status     (ignored)                      */
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
 909c84c:	e13fe704 	addi	r4,fp,-100
 909c850:	01801904 	movi	r6,100
 909c854:	000b883a 	mov	r5,zero
 909c858:	90823f80 	call	90823f8 <memset>
 909c85c:	00c24374 	movhi	r3,2317
 909c860:	18f59104 	addi	r3,r3,-10684
 909c864:	18800017 	ldw	r2,0(r3)
 909c868:	e0bfe715 	stw	r2,-100(fp)
 909c86c:	18800117 	ldw	r2,4(r3)
 909c870:	e0bfe815 	stw	r2,-96(fp)
 909c874:	18800217 	ldw	r2,8(r3)
 909c878:	e0bfe915 	stw	r2,-92(fp)
 909c87c:	18800317 	ldw	r2,12(r3)
 909c880:	e0bfea15 	stw	r2,-88(fp)
 909c884:	1880040b 	ldhu	r2,16(r3)
 909c888:	e0bfeb0d 	sth	r2,-84(fp)
 909c88c:	e13feb84 	addi	r4,fp,-82
 909c890:	01800f84 	movi	r6,62
 909c894:	000b883a 	mov	r5,zero
 909c898:	90823f80 	call	90823f8 <memset>
 909c89c:	00800234 	movhi	r2,8
 909c8a0:	108005c4 	addi	r2,r2,23
 909c8a4:	e0bffb15 	stw	r2,-20(fp)
 909c8a8:	00800244 	movi	r2,9
 909c8ac:	e0bffc05 	stb	r2,-16(fp)
 909c8b0:	008242b4 	movhi	r2,2314
 909c8b4:	10bcde04 	addi	r2,r2,-3208
 909c8b8:	e0bfff15 	stw	r2,-4(fp)
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 909c8bc:	e13f9c04 	addi	r4,fp,-400
 909c8c0:	909a4180 	call	909a418 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 909c8c4:	e13fb504 	addi	r4,fp,-300
 909c8c8:	909a4180 	call	909a418 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 909c8cc:	e13fce04 	addi	r4,fp,-200
 909c8d0:	909a4180 	call	909a418 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 909c8d4:	e13fe704 	addi	r4,fp,-100
 909c8d8:	909a4180 	call	909a418 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 909c8dc:	d0a07f03 	ldbu	r2,-32260(gp)
 909c8e0:	10803fcc 	andi	r2,r2,255
}
 909c8e4:	e037883a 	mov	sp,fp
 909c8e8:	dfc00117 	ldw	ra,4(sp)
 909c8ec:	df000017 	ldw	fp,0(sp)
 909c8f0:	dec00204 	addi	sp,sp,8
 909c8f4:	f800283a 	ret

0909c8f8 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 909c8f8:	defffd04 	addi	sp,sp,-12
 909c8fc:	dfc00215 	stw	ra,8(sp)
 909c900:	df000115 	stw	fp,4(sp)
 909c904:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 909c908:	d0a07f03 	ldbu	r2,-32260(gp)
 909c90c:	11403fcc 	andi	r5,r2,255
 909c910:	01024374 	movhi	r4,2317
 909c914:	2135a504 	addi	r4,r4,-10604
 909c918:	909a0b80 	call	909a0b8 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 909c91c:	e03fff05 	stb	zero,-4(fp)
 909c920:	00006606 	br	909cabc <alt_tse_phy_print_profile+0x1c4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 909c924:	e17fff07 	ldb	r5,-4(fp)
 909c928:	01024374 	movhi	r4,2317
 909c92c:	2135b404 	addi	r4,r4,-10544
 909c930:	909a0b80 	call	909a0b8 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 909c934:	e0bfff07 	ldb	r2,-4(fp)
 909c938:	00c243b4 	movhi	r3,2318
 909c93c:	18f2fd04 	addi	r3,r3,-13324
 909c940:	1085883a 	add	r2,r2,r2
 909c944:	1085883a 	add	r2,r2,r2
 909c948:	10c5883a 	add	r2,r2,r3
 909c94c:	10800017 	ldw	r2,0(r2)
 909c950:	100b883a 	mov	r5,r2
 909c954:	01024374 	movhi	r4,2317
 909c958:	2135b904 	addi	r4,r4,-10524
 909c95c:	909a0b80 	call	909a0b8 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 909c960:	e0bfff07 	ldb	r2,-4(fp)
 909c964:	00c243b4 	movhi	r3,2318
 909c968:	18f2fd04 	addi	r3,r3,-13324
 909c96c:	1085883a 	add	r2,r2,r2
 909c970:	1085883a 	add	r2,r2,r2
 909c974:	10c5883a 	add	r2,r2,r3
 909c978:	10800017 	ldw	r2,0(r2)
 909c97c:	10801417 	ldw	r2,80(r2)
 909c980:	100b883a 	mov	r5,r2
 909c984:	01024374 	movhi	r4,2317
 909c988:	2135bf04 	addi	r4,r4,-10500
 909c98c:	909a0b80 	call	909a0b8 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 909c990:	e0bfff07 	ldb	r2,-4(fp)
 909c994:	00c243b4 	movhi	r3,2318
 909c998:	18f2fd04 	addi	r3,r3,-13324
 909c99c:	1085883a 	add	r2,r2,r2
 909c9a0:	1085883a 	add	r2,r2,r2
 909c9a4:	10c5883a 	add	r2,r2,r3
 909c9a8:	10800017 	ldw	r2,0(r2)
 909c9ac:	10801503 	ldbu	r2,84(r2)
 909c9b0:	11403fcc 	andi	r5,r2,255
 909c9b4:	01024374 	movhi	r4,2317
 909c9b8:	2135c604 	addi	r4,r4,-10472
 909c9bc:	909a0b80 	call	909a0b8 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 909c9c0:	e0bfff07 	ldb	r2,-4(fp)
 909c9c4:	00c243b4 	movhi	r3,2318
 909c9c8:	18f2fd04 	addi	r3,r3,-13324
 909c9cc:	1085883a 	add	r2,r2,r2
 909c9d0:	1085883a 	add	r2,r2,r2
 909c9d4:	10c5883a 	add	r2,r2,r3
 909c9d8:	10800017 	ldw	r2,0(r2)
 909c9dc:	10801543 	ldbu	r2,85(r2)
 909c9e0:	11403fcc 	andi	r5,r2,255
 909c9e4:	01024374 	movhi	r4,2317
 909c9e8:	2135cd04 	addi	r4,r4,-10444
 909c9ec:	909a0b80 	call	909a0b8 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 909c9f0:	e0bfff07 	ldb	r2,-4(fp)
 909c9f4:	00c243b4 	movhi	r3,2318
 909c9f8:	18f2fd04 	addi	r3,r3,-13324
 909c9fc:	1085883a 	add	r2,r2,r2
 909ca00:	1085883a 	add	r2,r2,r2
 909ca04:	10c5883a 	add	r2,r2,r3
 909ca08:	10800017 	ldw	r2,0(r2)
 909ca0c:	10801583 	ldbu	r2,86(r2)
 909ca10:	11403fcc 	andi	r5,r2,255
 909ca14:	01024374 	movhi	r4,2317
 909ca18:	2135d404 	addi	r4,r4,-10416
 909ca1c:	909a0b80 	call	909a0b8 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 909ca20:	e0bfff07 	ldb	r2,-4(fp)
 909ca24:	00c243b4 	movhi	r3,2318
 909ca28:	18f2fd04 	addi	r3,r3,-13324
 909ca2c:	1085883a 	add	r2,r2,r2
 909ca30:	1085883a 	add	r2,r2,r2
 909ca34:	10c5883a 	add	r2,r2,r3
 909ca38:	10800017 	ldw	r2,0(r2)
 909ca3c:	108015c3 	ldbu	r2,87(r2)
 909ca40:	11403fcc 	andi	r5,r2,255
 909ca44:	01024374 	movhi	r4,2317
 909ca48:	2135db04 	addi	r4,r4,-10388
 909ca4c:	909a0b80 	call	909a0b8 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 909ca50:	e0bfff07 	ldb	r2,-4(fp)
 909ca54:	00c243b4 	movhi	r3,2318
 909ca58:	18f2fd04 	addi	r3,r3,-13324
 909ca5c:	1085883a 	add	r2,r2,r2
 909ca60:	1085883a 	add	r2,r2,r2
 909ca64:	10c5883a 	add	r2,r2,r3
 909ca68:	10800017 	ldw	r2,0(r2)
 909ca6c:	10801603 	ldbu	r2,88(r2)
 909ca70:	11403fcc 	andi	r5,r2,255
 909ca74:	01024374 	movhi	r4,2317
 909ca78:	2135e104 	addi	r4,r4,-10364
 909ca7c:	909a0b80 	call	909a0b8 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 909ca80:	e0bfff07 	ldb	r2,-4(fp)
 909ca84:	00c243b4 	movhi	r3,2318
 909ca88:	18f2fd04 	addi	r3,r3,-13324
 909ca8c:	1085883a 	add	r2,r2,r2
 909ca90:	1085883a 	add	r2,r2,r2
 909ca94:	10c5883a 	add	r2,r2,r3
 909ca98:	10800017 	ldw	r2,0(r2)
 909ca9c:	10801643 	ldbu	r2,89(r2)
 909caa0:	11403fcc 	andi	r5,r2,255
 909caa4:	01024374 	movhi	r4,2317
 909caa8:	2135e704 	addi	r4,r4,-10340
 909caac:	909a0b80 	call	909a0b8 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 909cab0:	e0bfff03 	ldbu	r2,-4(fp)
 909cab4:	10800044 	addi	r2,r2,1
 909cab8:	e0bfff05 	stb	r2,-4(fp)
 909cabc:	e0bfff07 	ldb	r2,-4(fp)
 909cac0:	d0e07f03 	ldbu	r3,-32260(gp)
 909cac4:	18c03fcc 	andi	r3,r3,255
 909cac8:	10ff9616 	blt	r2,r3,909c924 <alt_tse_phy_print_profile+0x2c>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 909cacc:	d0a07f03 	ldbu	r2,-32260(gp)
 909cad0:	10803fcc 	andi	r2,r2,255
}
 909cad4:	e037883a 	mov	sp,fp
 909cad8:	dfc00117 	ldw	ra,4(sp)
 909cadc:	df000017 	ldw	fp,0(sp)
 909cae0:	dec00204 	addi	sp,sp,8
 909cae4:	f800283a 	ret

0909cae8 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 909cae8:	defff104 	addi	sp,sp,-60
 909caec:	dfc00e15 	stw	ra,56(sp)
 909caf0:	df000d15 	stw	fp,52(sp)
 909caf4:	df000d04 	addi	fp,sp,52
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 909caf8:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 909cafc:	e03ff415 	stw	zero,-48(fp)
    alt_tse_system_info *psys = 0;
 909cb00:	e03ff315 	stw	zero,-52(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 909cb04:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 909cb08:	e03ff645 	stb	zero,-39(fp)
 909cb0c:	0001ae06 	br	909d1c8 <alt_tse_mac_group_init+0x6e0>
        psys = &tse_mac_device[i];
 909cb10:	e0bff647 	ldb	r2,-39(fp)
 909cb14:	10801224 	muli	r2,r2,72
 909cb18:	1007883a 	mov	r3,r2
 909cb1c:	00824374 	movhi	r2,2317
 909cb20:	1083a904 	addi	r2,r2,3748
 909cb24:	1885883a 	add	r2,r3,r2
 909cb28:	e0bff315 	stw	r2,-52(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 909cb2c:	e0bff317 	ldw	r2,-52(fp)
 909cb30:	10800517 	ldw	r2,20(r2)
 909cb34:	1005003a 	cmpeq	r2,r2,zero
 909cb38:	1001a01e 	bne	r2,zero,909d1bc <alt_tse_mac_group_init+0x6d4>
 909cb3c:	e0bff317 	ldw	r2,-52(fp)
 909cb40:	10800617 	ldw	r2,24(r2)
 909cb44:	1005003a 	cmpeq	r2,r2,zero
 909cb48:	10019c1e 	bne	r2,zero,909d1bc <alt_tse_mac_group_init+0x6d4>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 909cb4c:	d0a07f43 	ldbu	r2,-32259(gp)
 909cb50:	11403fcc 	andi	r5,r2,255
 909cb54:	e0bff317 	ldw	r2,-52(fp)
 909cb58:	10800017 	ldw	r2,0(r2)
 909cb5c:	100d883a 	mov	r6,r2
 909cb60:	01024374 	movhi	r4,2317
 909cb64:	2135ed04 	addi	r4,r4,-10316
 909cb68:	90825100 	call	9082510 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 909cb6c:	01000504 	movi	r4,20
 909cb70:	90ca52c0 	call	90ca52c <malloc>
 909cb74:	e0bff515 	stw	r2,-44(fp)
            if(!pmac_group) {
 909cb78:	e0bff517 	ldw	r2,-44(fp)
 909cb7c:	1004c03a 	cmpne	r2,r2,zero
 909cb80:	1000081e 	bne	r2,zero,909cba4 <alt_tse_mac_group_init+0xbc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 909cb84:	d0a07f43 	ldbu	r2,-32259(gp)
 909cb88:	11403fcc 	andi	r5,r2,255
 909cb8c:	01024374 	movhi	r4,2317
 909cb90:	2135f904 	addi	r4,r4,-10268
 909cb94:	90825100 	call	9082510 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 909cb98:	00bfffc4 	movi	r2,-1
 909cb9c:	e0bfff15 	stw	r2,-4(fp)
 909cba0:	00018e06 	br	909d1dc <alt_tse_mac_group_init+0x6f4>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 909cba4:	e0bff317 	ldw	r2,-52(fp)
 909cba8:	108002c3 	ldbu	r2,11(r2)
 909cbac:	10803fcc 	andi	r2,r2,255
 909cbb0:	1005003a 	cmpeq	r2,r2,zero
 909cbb4:	1000111e 	bne	r2,zero,909cbfc <alt_tse_mac_group_init+0x114>
                pmac_group->channel = psys->tse_num_of_channel;
 909cbb8:	e0bff317 	ldw	r2,-52(fp)
 909cbbc:	10c00303 	ldbu	r3,12(r2)
 909cbc0:	e0bff517 	ldw	r2,-44(fp)
 909cbc4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 909cbc8:	01024374 	movhi	r4,2317
 909cbcc:	21360704 	addi	r4,r4,-10212
 909cbd0:	909a0b80 	call	909a0b8 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 909cbd4:	e0bff517 	ldw	r2,-44(fp)
 909cbd8:	10800003 	ldbu	r2,0(r2)
 909cbdc:	11403fcc 	andi	r5,r2,255
 909cbe0:	01024374 	movhi	r4,2317
 909cbe4:	21361204 	addi	r4,r4,-10168
 909cbe8:	909a0b80 	call	909a0b8 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 909cbec:	01024374 	movhi	r4,2317
 909cbf0:	21361d04 	addi	r4,r4,-10124
 909cbf4:	909a0b80 	call	909a0b8 <no_printf>
 909cbf8:	00001f06 	br	909cc78 <alt_tse_mac_group_init+0x190>
            }
            else if(psys->tse_mdio_shared) {
 909cbfc:	e0bff317 	ldw	r2,-52(fp)
 909cc00:	10800343 	ldbu	r2,13(r2)
 909cc04:	10803fcc 	andi	r2,r2,255
 909cc08:	1005003a 	cmpeq	r2,r2,zero
 909cc0c:	1000111e 	bne	r2,zero,909cc54 <alt_tse_mac_group_init+0x16c>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 909cc10:	e0bff317 	ldw	r2,-52(fp)
 909cc14:	10c00383 	ldbu	r3,14(r2)
 909cc18:	e0bff517 	ldw	r2,-44(fp)
 909cc1c:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 909cc20:	01024374 	movhi	r4,2317
 909cc24:	21362804 	addi	r4,r4,-10080
 909cc28:	909a0b80 	call	909a0b8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 909cc2c:	01024374 	movhi	r4,2317
 909cc30:	21361d04 	addi	r4,r4,-10124
 909cc34:	909a0b80 	call	909a0b8 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 909cc38:	e0bff517 	ldw	r2,-44(fp)
 909cc3c:	10800003 	ldbu	r2,0(r2)
 909cc40:	11403fcc 	andi	r5,r2,255
 909cc44:	01024374 	movhi	r4,2317
 909cc48:	21363304 	addi	r4,r4,-10036
 909cc4c:	909a0b80 	call	909a0b8 <no_printf>
 909cc50:	00000906 	br	909cc78 <alt_tse_mac_group_init+0x190>
            }
            else {
                pmac_group->channel = 1;
 909cc54:	e0fff517 	ldw	r3,-44(fp)
 909cc58:	00800044 	movi	r2,1
 909cc5c:	18800005 	stb	r2,0(r3)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 909cc60:	01024374 	movhi	r4,2317
 909cc64:	21362804 	addi	r4,r4,-10080
 909cc68:	909a0b80 	call	909a0b8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 909cc6c:	01024374 	movhi	r4,2317
 909cc70:	21363e04 	addi	r4,r4,-9992
 909cc74:	909a0b80 	call	909a0b8 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 909cc78:	e03ff605 	stb	zero,-40(fp)
 909cc7c:	00013806 	br	909d160 <alt_tse_mac_group_init+0x678>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 909cc80:	01000404 	movi	r4,16
 909cc84:	90ca52c0 	call	90ca52c <malloc>
 909cc88:	e0bff415 	stw	r2,-48(fp)
                if(!pmac_info) {
 909cc8c:	e0bff417 	ldw	r2,-48(fp)
 909cc90:	1004c03a 	cmpne	r2,r2,zero
 909cc94:	1000091e 	bne	r2,zero,909ccbc <alt_tse_mac_group_init+0x1d4>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 909cc98:	d0a07f43 	ldbu	r2,-32259(gp)
 909cc9c:	11403fcc 	andi	r5,r2,255
 909cca0:	e1bff607 	ldb	r6,-40(fp)
 909cca4:	01024374 	movhi	r4,2317
 909cca8:	21364904 	addi	r4,r4,-9948
 909ccac:	90825100 	call	9082510 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 909ccb0:	00ffffc4 	movi	r3,-1
 909ccb4:	e0ffff15 	stw	r3,-4(fp)
 909ccb8:	00014806 	br	909d1dc <alt_tse_mac_group_init+0x6f4>
                }
                
                pmac_info->pmac_group = pmac_group;
 909ccbc:	e0fff417 	ldw	r3,-48(fp)
 909ccc0:	e0bff517 	ldw	r2,-44(fp)
 909ccc4:	18800315 	stw	r2,12(r3)
                
                pmac_info->pphy_info = 0;
 909ccc8:	e0bff417 	ldw	r2,-48(fp)
 909cccc:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 909ccd0:	e0fff647 	ldb	r3,-39(fp)
 909ccd4:	e0bff607 	ldb	r2,-40(fp)
 909ccd8:	1885883a 	add	r2,r3,r2
 909ccdc:	10801224 	muli	r2,r2,72
 909cce0:	1007883a 	mov	r3,r2
 909cce4:	00824374 	movhi	r2,2317
 909cce8:	1083a904 	addi	r2,r2,3748
 909ccec:	1887883a 	add	r3,r3,r2
 909ccf0:	e0bff417 	ldw	r2,-48(fp)
 909ccf4:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 909ccf8:	e0bff417 	ldw	r2,-48(fp)
 909ccfc:	10800217 	ldw	r2,8(r2)
 909cd00:	10800517 	ldw	r2,20(r2)
 909cd04:	1005003a 	cmpeq	r2,r2,zero
 909cd08:	1000051e 	bne	r2,zero,909cd20 <alt_tse_mac_group_init+0x238>
 909cd0c:	e0bff417 	ldw	r2,-48(fp)
 909cd10:	10800217 	ldw	r2,8(r2)
 909cd14:	10800617 	ldw	r2,24(r2)
 909cd18:	1004c03a 	cmpne	r2,r2,zero
 909cd1c:	1000091e 	bne	r2,zero,909cd44 <alt_tse_mac_group_init+0x25c>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 909cd20:	e0bff647 	ldb	r2,-39(fp)
 909cd24:	e0fff607 	ldb	r3,-40(fp)
 909cd28:	10cb883a 	add	r5,r2,r3
 909cd2c:	01024374 	movhi	r4,2317
 909cd30:	21365b04 	addi	r4,r4,-9876
 909cd34:	90825100 	call	9082510 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909cd38:	00bfffc4 	movi	r2,-1
 909cd3c:	e0bfff15 	stw	r2,-4(fp)
 909cd40:	00012606 	br	909d1dc <alt_tse_mac_group_init+0x6f4>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 909cd44:	e0bff417 	ldw	r2,-48(fp)
 909cd48:	10800217 	ldw	r2,8(r2)
 909cd4c:	10800243 	ldbu	r2,9(r2)
 909cd50:	10803fcc 	andi	r2,r2,255
 909cd54:	1005003a 	cmpeq	r2,r2,zero
 909cd58:	10000e1e 	bne	r2,zero,909cd94 <alt_tse_mac_group_init+0x2ac>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 909cd5c:	e0bff417 	ldw	r2,-48(fp)
 909cd60:	10800217 	ldw	r2,8(r2)
 909cd64:	10800283 	ldbu	r2,10(r2)
 909cd68:	10803fcc 	andi	r2,r2,255
 909cd6c:	1005003a 	cmpeq	r2,r2,zero
 909cd70:	1000041e 	bne	r2,zero,909cd84 <alt_tse_mac_group_init+0x29c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 909cd74:	e0fff417 	ldw	r3,-48(fp)
 909cd78:	00800084 	movi	r2,2
 909cd7c:	18800005 	stb	r2,0(r3)
 909cd80:	00000606 	br	909cd9c <alt_tse_mac_group_init+0x2b4>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 909cd84:	e0fff417 	ldw	r3,-48(fp)
 909cd88:	00800044 	movi	r2,1
 909cd8c:	18800005 	stb	r2,0(r3)
 909cd90:	00000206 	br	909cd9c <alt_tse_mac_group_init+0x2b4>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 909cd94:	e0bff417 	ldw	r2,-48(fp)
 909cd98:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 909cd9c:	e0bff417 	ldw	r2,-48(fp)
 909cda0:	10800217 	ldw	r2,8(r2)
 909cda4:	10800343 	ldbu	r2,13(r2)
 909cda8:	10803fcc 	andi	r2,r2,255
 909cdac:	1005003a 	cmpeq	r2,r2,zero
 909cdb0:	10006d1e 	bne	r2,zero,909cf68 <alt_tse_mac_group_init+0x480>
 909cdb4:	e0bff417 	ldw	r2,-48(fp)
 909cdb8:	10800217 	ldw	r2,8(r2)
 909cdbc:	108002c3 	ldbu	r2,11(r2)
 909cdc0:	10803fcc 	andi	r2,r2,255
 909cdc4:	1004c03a 	cmpne	r2,r2,zero
 909cdc8:	1000671e 	bne	r2,zero,909cf68 <alt_tse_mac_group_init+0x480>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 909cdcc:	e17ff607 	ldb	r5,-40(fp)
 909cdd0:	e0bff417 	ldw	r2,-48(fp)
 909cdd4:	10800217 	ldw	r2,8(r2)
 909cdd8:	10800017 	ldw	r2,0(r2)
 909cddc:	100d883a 	mov	r6,r2
 909cde0:	01024374 	movhi	r4,2317
 909cde4:	21366a04 	addi	r4,r4,-9816
 909cde8:	909a0b80 	call	909a0b8 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 909cdec:	e17ff607 	ldb	r5,-40(fp)
 909cdf0:	e0fff647 	ldb	r3,-39(fp)
 909cdf4:	e0bff607 	ldb	r2,-40(fp)
 909cdf8:	188d883a 	add	r6,r3,r2
 909cdfc:	01024374 	movhi	r4,2317
 909ce00:	21367604 	addi	r4,r4,-9768
 909ce04:	909a0b80 	call	909a0b8 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 909ce08:	e0bff417 	ldw	r2,-48(fp)
 909ce0c:	10800003 	ldbu	r2,0(r2)
 909ce10:	10803fcc 	andi	r2,r2,255
 909ce14:	e0bffe15 	stw	r2,-8(fp)
 909ce18:	e0fffe17 	ldw	r3,-8(fp)
 909ce1c:	18800060 	cmpeqi	r2,r3,1
 909ce20:	10000e1e 	bne	r2,zero,909ce5c <alt_tse_mac_group_init+0x374>
 909ce24:	e0fffe17 	ldw	r3,-8(fp)
 909ce28:	188000a0 	cmpeqi	r2,r3,2
 909ce2c:	1000041e 	bne	r2,zero,909ce40 <alt_tse_mac_group_init+0x358>
 909ce30:	e0fffe17 	ldw	r3,-8(fp)
 909ce34:	1805003a 	cmpeq	r2,r3,zero
 909ce38:	10000f1e 	bne	r2,zero,909ce78 <alt_tse_mac_group_init+0x390>
 909ce3c:	00001506 	br	909ce94 <alt_tse_mac_group_init+0x3ac>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 909ce40:	e17ff607 	ldb	r5,-40(fp)
 909ce44:	01024374 	movhi	r4,2317
 909ce48:	21368504 	addi	r4,r4,-9708
 909ce4c:	01824374 	movhi	r6,2317
 909ce50:	31b69004 	addi	r6,r6,-9664
 909ce54:	909a0b80 	call	909a0b8 <no_printf>
                            break;
 909ce58:	00001406 	br	909ceac <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 909ce5c:	e17ff607 	ldb	r5,-40(fp)
 909ce60:	01024374 	movhi	r4,2317
 909ce64:	21368504 	addi	r4,r4,-9708
 909ce68:	01824374 	movhi	r6,2317
 909ce6c:	31b69504 	addi	r6,r6,-9644
 909ce70:	909a0b80 	call	909a0b8 <no_printf>
                            break;
 909ce74:	00000d06 	br	909ceac <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 909ce78:	e17ff607 	ldb	r5,-40(fp)
 909ce7c:	01024374 	movhi	r4,2317
 909ce80:	21368504 	addi	r4,r4,-9708
 909ce84:	01824374 	movhi	r6,2317
 909ce88:	31b69b04 	addi	r6,r6,-9620
 909ce8c:	909a0b80 	call	909a0b8 <no_printf>
                            break;
 909ce90:	00000606 	br	909ceac <alt_tse_mac_group_init+0x3c4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 909ce94:	e17ff607 	ldb	r5,-40(fp)
 909ce98:	01024374 	movhi	r4,2317
 909ce9c:	21368504 	addi	r4,r4,-9708
 909cea0:	01824374 	movhi	r6,2317
 909cea4:	31b49c04 	addi	r6,r6,-11664
 909cea8:	909a0b80 	call	909a0b8 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 909ceac:	e0bff417 	ldw	r2,-48(fp)
 909ceb0:	10800217 	ldw	r2,8(r2)
 909ceb4:	108003c3 	ldbu	r2,15(r2)
 909ceb8:	10803fcc 	andi	r2,r2,255
 909cebc:	1005003a 	cmpeq	r2,r2,zero
 909cec0:	10009c1e 	bne	r2,zero,909d134 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 909cec4:	e0bff607 	ldb	r2,-40(fp)
 909cec8:	e0bffd15 	stw	r2,-12(fp)
 909cecc:	e0bff417 	ldw	r2,-48(fp)
 909ced0:	10800217 	ldw	r2,8(r2)
 909ced4:	108003c3 	ldbu	r2,15(r2)
 909ced8:	10803fcc 	andi	r2,r2,255
 909cedc:	1005003a 	cmpeq	r2,r2,zero
 909cee0:	1000041e 	bne	r2,zero,909cef4 <alt_tse_mac_group_init+0x40c>
 909cee4:	00c24374 	movhi	r3,2317
 909cee8:	18f6a204 	addi	r3,r3,-9592
 909ceec:	e0fffc15 	stw	r3,-16(fp)
 909cef0:	00000306 	br	909cf00 <alt_tse_mac_group_init+0x418>
 909cef4:	00824374 	movhi	r2,2317
 909cef8:	10b6a304 	addi	r2,r2,-9588
 909cefc:	e0bffc15 	stw	r2,-16(fp)
 909cf00:	01024374 	movhi	r4,2317
 909cf04:	2136a404 	addi	r4,r4,-9584
 909cf08:	e17ffd17 	ldw	r5,-12(fp)
 909cf0c:	e1bffc17 	ldw	r6,-16(fp)
 909cf10:	909a0b80 	call	909a0b8 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 909cf14:	e0fff607 	ldb	r3,-40(fp)
 909cf18:	e0fffb15 	stw	r3,-20(fp)
 909cf1c:	e0bff417 	ldw	r2,-48(fp)
 909cf20:	10800217 	ldw	r2,8(r2)
 909cf24:	10800403 	ldbu	r2,16(r2)
 909cf28:	10803fcc 	andi	r2,r2,255
 909cf2c:	1005003a 	cmpeq	r2,r2,zero
 909cf30:	1000041e 	bne	r2,zero,909cf44 <alt_tse_mac_group_init+0x45c>
 909cf34:	00824374 	movhi	r2,2317
 909cf38:	10b6a204 	addi	r2,r2,-9592
 909cf3c:	e0bffa15 	stw	r2,-24(fp)
 909cf40:	00000306 	br	909cf50 <alt_tse_mac_group_init+0x468>
 909cf44:	00c24374 	movhi	r3,2317
 909cf48:	18f6a304 	addi	r3,r3,-9588
 909cf4c:	e0fffa15 	stw	r3,-24(fp)
 909cf50:	01024374 	movhi	r4,2317
 909cf54:	2136af04 	addi	r4,r4,-9540
 909cf58:	e17ffb17 	ldw	r5,-20(fp)
 909cf5c:	e1bffa17 	ldw	r6,-24(fp)
 909cf60:	909a0b80 	call	909a0b8 <no_printf>
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 909cf64:	00007306 	br	909d134 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 909cf68:	e0bff607 	ldb	r2,-40(fp)
 909cf6c:	1004c03a 	cmpne	r2,r2,zero
 909cf70:	10004d1e 	bne	r2,zero,909d0a8 <alt_tse_mac_group_init+0x5c0>
	                    switch(pmac_info->mac_type) {
 909cf74:	e0bff417 	ldw	r2,-48(fp)
 909cf78:	10800003 	ldbu	r2,0(r2)
 909cf7c:	10803fcc 	andi	r2,r2,255
 909cf80:	e0bff915 	stw	r2,-28(fp)
 909cf84:	e0fff917 	ldw	r3,-28(fp)
 909cf88:	18800060 	cmpeqi	r2,r3,1
 909cf8c:	10000d1e 	bne	r2,zero,909cfc4 <alt_tse_mac_group_init+0x4dc>
 909cf90:	e0fff917 	ldw	r3,-28(fp)
 909cf94:	188000a0 	cmpeqi	r2,r3,2
 909cf98:	1000041e 	bne	r2,zero,909cfac <alt_tse_mac_group_init+0x4c4>
 909cf9c:	e0fff917 	ldw	r3,-28(fp)
 909cfa0:	1805003a 	cmpeq	r2,r3,zero
 909cfa4:	10000d1e 	bne	r2,zero,909cfdc <alt_tse_mac_group_init+0x4f4>
 909cfa8:	00001206 	br	909cff4 <alt_tse_mac_group_init+0x50c>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 909cfac:	01024374 	movhi	r4,2317
 909cfb0:	2136ba04 	addi	r4,r4,-9496
 909cfb4:	01424374 	movhi	r5,2317
 909cfb8:	29769004 	addi	r5,r5,-9664
 909cfbc:	909a0b80 	call	909a0b8 <no_printf>
	                            break;
 909cfc0:	00001106 	br	909d008 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 909cfc4:	01024374 	movhi	r4,2317
 909cfc8:	2136ba04 	addi	r4,r4,-9496
 909cfcc:	01424374 	movhi	r5,2317
 909cfd0:	29769504 	addi	r5,r5,-9644
 909cfd4:	909a0b80 	call	909a0b8 <no_printf>
	                            break;
 909cfd8:	00000b06 	br	909d008 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 909cfdc:	01024374 	movhi	r4,2317
 909cfe0:	2136ba04 	addi	r4,r4,-9496
 909cfe4:	01424374 	movhi	r5,2317
 909cfe8:	29769b04 	addi	r5,r5,-9620
 909cfec:	909a0b80 	call	909a0b8 <no_printf>
	                            break;
 909cff0:	00000506 	br	909d008 <alt_tse_mac_group_init+0x520>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 909cff4:	01024374 	movhi	r4,2317
 909cff8:	2136ba04 	addi	r4,r4,-9496
 909cffc:	01424374 	movhi	r5,2317
 909d000:	29749c04 	addi	r5,r5,-11664
 909d004:	909a0b80 	call	909a0b8 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 909d008:	e0bff417 	ldw	r2,-48(fp)
 909d00c:	10800217 	ldw	r2,8(r2)
 909d010:	108003c3 	ldbu	r2,15(r2)
 909d014:	10803fcc 	andi	r2,r2,255
 909d018:	1005003a 	cmpeq	r2,r2,zero
 909d01c:	1000221e 	bne	r2,zero,909d0a8 <alt_tse_mac_group_init+0x5c0>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 909d020:	e0bff417 	ldw	r2,-48(fp)
 909d024:	10800217 	ldw	r2,8(r2)
 909d028:	108003c3 	ldbu	r2,15(r2)
 909d02c:	10803fcc 	andi	r2,r2,255
 909d030:	1005003a 	cmpeq	r2,r2,zero
 909d034:	1000041e 	bne	r2,zero,909d048 <alt_tse_mac_group_init+0x560>
 909d038:	00824374 	movhi	r2,2317
 909d03c:	10b6a204 	addi	r2,r2,-9592
 909d040:	e0bff815 	stw	r2,-32(fp)
 909d044:	00000306 	br	909d054 <alt_tse_mac_group_init+0x56c>
 909d048:	00c24374 	movhi	r3,2317
 909d04c:	18f6a304 	addi	r3,r3,-9588
 909d050:	e0fff815 	stw	r3,-32(fp)
 909d054:	01024374 	movhi	r4,2317
 909d058:	2136c504 	addi	r4,r4,-9452
 909d05c:	e17ff817 	ldw	r5,-32(fp)
 909d060:	909a0b80 	call	909a0b8 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 909d064:	e0bff417 	ldw	r2,-48(fp)
 909d068:	10800217 	ldw	r2,8(r2)
 909d06c:	10800403 	ldbu	r2,16(r2)
 909d070:	10803fcc 	andi	r2,r2,255
 909d074:	1005003a 	cmpeq	r2,r2,zero
 909d078:	1000041e 	bne	r2,zero,909d08c <alt_tse_mac_group_init+0x5a4>
 909d07c:	00824374 	movhi	r2,2317
 909d080:	10b6a204 	addi	r2,r2,-9592
 909d084:	e0bff715 	stw	r2,-36(fp)
 909d088:	00000306 	br	909d098 <alt_tse_mac_group_init+0x5b0>
 909d08c:	00c24374 	movhi	r3,2317
 909d090:	18f6a304 	addi	r3,r3,-9588
 909d094:	e0fff715 	stw	r3,-36(fp)
 909d098:	01024374 	movhi	r4,2317
 909d09c:	2136d004 	addi	r4,r4,-9408
 909d0a0:	e17ff717 	ldw	r5,-36(fp)
 909d0a4:	909a0b80 	call	909a0b8 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 909d0a8:	e0bff417 	ldw	r2,-48(fp)
 909d0ac:	10800217 	ldw	r2,8(r2)
 909d0b0:	108002c3 	ldbu	r2,11(r2)
 909d0b4:	10803fcc 	andi	r2,r2,255
 909d0b8:	1005003a 	cmpeq	r2,r2,zero
 909d0bc:	1000101e 	bne	r2,zero,909d100 <alt_tse_mac_group_init+0x618>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 909d0c0:	e17ff607 	ldb	r5,-40(fp)
 909d0c4:	e0bff417 	ldw	r2,-48(fp)
 909d0c8:	10800217 	ldw	r2,8(r2)
 909d0cc:	10800017 	ldw	r2,0(r2)
 909d0d0:	100d883a 	mov	r6,r2
 909d0d4:	01024374 	movhi	r4,2317
 909d0d8:	2136db04 	addi	r4,r4,-9364
 909d0dc:	909a0b80 	call	909a0b8 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 909d0e0:	e17ff607 	ldb	r5,-40(fp)
 909d0e4:	e0fff647 	ldb	r3,-39(fp)
 909d0e8:	e0bff607 	ldb	r2,-40(fp)
 909d0ec:	188d883a 	add	r6,r3,r2
 909d0f0:	01024374 	movhi	r4,2317
 909d0f4:	2136e704 	addi	r4,r4,-9316
 909d0f8:	909a0b80 	call	909a0b8 <no_printf>
 909d0fc:	00000d06 	br	909d134 <alt_tse_mac_group_init+0x64c>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 909d100:	e0bff417 	ldw	r2,-48(fp)
 909d104:	10800217 	ldw	r2,8(r2)
 909d108:	10800017 	ldw	r2,0(r2)
 909d10c:	100b883a 	mov	r5,r2
 909d110:	01024374 	movhi	r4,2317
 909d114:	2136f604 	addi	r4,r4,-9256
 909d118:	909a0b80 	call	909a0b8 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 909d11c:	e0fff647 	ldb	r3,-39(fp)
 909d120:	e0bff607 	ldb	r2,-40(fp)
 909d124:	188b883a 	add	r5,r3,r2
 909d128:	01024374 	movhi	r4,2317
 909d12c:	21370204 	addi	r4,r4,-9208
 909d130:	909a0b80 	call	909a0b8 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 909d134:	e0bff607 	ldb	r2,-40(fp)
 909d138:	e0fff517 	ldw	r3,-44(fp)
 909d13c:	1085883a 	add	r2,r2,r2
 909d140:	1085883a 	add	r2,r2,r2
 909d144:	10c5883a 	add	r2,r2,r3
 909d148:	10c00104 	addi	r3,r2,4
 909d14c:	e0bff417 	ldw	r2,-48(fp)
 909d150:	18800015 	stw	r2,0(r3)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 909d154:	e0bff603 	ldbu	r2,-40(fp)
 909d158:	10800044 	addi	r2,r2,1
 909d15c:	e0bff605 	stb	r2,-40(fp)
 909d160:	e0fff607 	ldb	r3,-40(fp)
 909d164:	e0bff517 	ldw	r2,-44(fp)
 909d168:	10800003 	ldbu	r2,0(r2)
 909d16c:	10803fcc 	andi	r2,r2,255
 909d170:	18bec316 	blt	r3,r2,909cc80 <alt_tse_mac_group_init+0x198>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 909d174:	d0a07f43 	ldbu	r2,-32259(gp)
 909d178:	10803fcc 	andi	r2,r2,255
 909d17c:	00c243b4 	movhi	r3,2318
 909d180:	18f2f904 	addi	r3,r3,-13340
 909d184:	1085883a 	add	r2,r2,r2
 909d188:	1085883a 	add	r2,r2,r2
 909d18c:	10c7883a 	add	r3,r2,r3
 909d190:	e0bff517 	ldw	r2,-44(fp)
 909d194:	18800015 	stw	r2,0(r3)
            
            mac_group_count++;
 909d198:	d0a07f43 	ldbu	r2,-32259(gp)
 909d19c:	10800044 	addi	r2,r2,1
 909d1a0:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 909d1a4:	e0bff517 	ldw	r2,-44(fp)
 909d1a8:	10c00003 	ldbu	r3,0(r2)
 909d1ac:	e0bff643 	ldbu	r2,-39(fp)
 909d1b0:	1885883a 	add	r2,r3,r2
 909d1b4:	10bfffc4 	addi	r2,r2,-1
 909d1b8:	e0bff645 	stb	r2,-39(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 909d1bc:	e0bff643 	ldbu	r2,-39(fp)
 909d1c0:	10800044 	addi	r2,r2,1
 909d1c4:	e0bff645 	stb	r2,-39(fp)
 909d1c8:	e0bff647 	ldb	r2,-39(fp)
 909d1cc:	d0e02b03 	ldbu	r3,-32596(gp)
 909d1d0:	18c03fcc 	andi	r3,r3,255
 909d1d4:	10fe4e16 	blt	r2,r3,909cb10 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 909d1d8:	e03fff15 	stw	zero,-4(fp)
 909d1dc:	e0bfff17 	ldw	r2,-4(fp)
}
 909d1e0:	e037883a 	mov	sp,fp
 909d1e4:	dfc00117 	ldw	ra,4(sp)
 909d1e8:	df000017 	ldw	fp,0(sp)
 909d1ec:	dec00204 	addi	sp,sp,8
 909d1f0:	f800283a 	ret

0909d1f4 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 909d1f4:	deffec04 	addi	sp,sp,-80
 909d1f8:	dfc01315 	stw	ra,76(sp)
 909d1fc:	df001215 	stw	fp,72(sp)
 909d200:	df001204 	addi	fp,sp,72
 909d204:	e13ffe15 	stw	r4,-8(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 909d208:	e03ffc15 	stw	zero,-16(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 909d20c:	e03ff615 	stw	zero,-40(fp)
    
    alt_8 phy_info_count = 0;
 909d210:	e03ff505 	stb	zero,-44(fp)
    
    alt_tse_phy_info *pphy = 0;
 909d214:	e03ff415 	stw	zero,-48(fp)
    alt_tse_mac_info *pmac_info = 0;
 909d218:	e03ff315 	stw	zero,-52(fp)
    alt_tse_system_info *psys = 0;
 909d21c:	e03ff215 	stw	zero,-56(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909d220:	e0bffe17 	ldw	r2,-8(fp)
 909d224:	10800117 	ldw	r2,4(r2)
 909d228:	10800217 	ldw	r2,8(r2)
 909d22c:	10800017 	ldw	r2,0(r2)
 909d230:	e0bff115 	stw	r2,-60(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909d234:	e0bff117 	ldw	r2,-60(fp)
 909d238:	10801004 	addi	r2,r2,64
 909d23c:	10800037 	ldwio	r2,0(r2)
 909d240:	e0bff015 	stw	r2,-64(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909d244:	e13ffe17 	ldw	r4,-8(fp)
 909d248:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909d24c:	e0bfef05 	stb	r2,-68(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 909d250:	e03ffb05 	stb	zero,-20(fp)
 909d254:	0000c806 	br	909d578 <alt_tse_mac_get_phy+0x384>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 909d258:	e0bff117 	ldw	r2,-60(fp)
 909d25c:	10801004 	addi	r2,r2,64
 909d260:	e0fffb03 	ldbu	r3,-20(fp)
 909d264:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 909d268:	e0bff117 	ldw	r2,-60(fp)
 909d26c:	1080a204 	addi	r2,r2,648
 909d270:	10800037 	ldwio	r2,0(r2)
 909d274:	e0bffd15 	stw	r2,-12(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 909d278:	e0bff117 	ldw	r2,-60(fp)
 909d27c:	1080a304 	addi	r2,r2,652
 909d280:	10800037 	ldwio	r2,0(r2)
 909d284:	e0bffc15 	stw	r2,-16(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 909d288:	e0fffd17 	ldw	r3,-12(fp)
 909d28c:	e0bffc17 	ldw	r2,-16(fp)
 909d290:	1880b626 	beq	r3,r2,909d56c <alt_tse_mac_get_phy+0x378>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 909d294:	01000704 	movi	r4,28
 909d298:	90ca52c0 	call	90ca52c <malloc>
 909d29c:	e0bff415 	stw	r2,-48(fp)
            if(!pphy) {
 909d2a0:	e0bff417 	ldw	r2,-48(fp)
 909d2a4:	1004c03a 	cmpne	r2,r2,zero
 909d2a8:	1000081e 	bne	r2,zero,909d2cc <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 909d2ac:	e17fef07 	ldb	r5,-68(fp)
 909d2b0:	e1bff507 	ldb	r6,-44(fp)
 909d2b4:	01024374 	movhi	r4,2317
 909d2b8:	21371104 	addi	r4,r4,-9148
 909d2bc:	90825100 	call	9082510 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 909d2c0:	00bfffc4 	movi	r2,-1
 909d2c4:	e0bfff15 	stw	r2,-4(fp)
 909d2c8:	0000ca06 	br	909d5f4 <alt_tse_mac_get_phy+0x400>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 909d2cc:	e0fff417 	ldw	r3,-48(fp)
 909d2d0:	e0bffb03 	ldbu	r2,-20(fp)
 909d2d4:	18800005 	stb	r2,0(r3)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 909d2d8:	e0bffd17 	ldw	r2,-12(fp)
 909d2dc:	100691ba 	slli	r3,r2,6
 909d2e0:	e0bffc17 	ldw	r2,-16(fp)
 909d2e4:	1005d2ba 	srai	r2,r2,10
 909d2e8:	10800fcc 	andi	r2,r2,63
 909d2ec:	1884b03a 	or	r2,r3,r2
 909d2f0:	e0bffa15 	stw	r2,-24(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 909d2f4:	e0bffc17 	ldw	r2,-16(fp)
 909d2f8:	1005d13a 	srai	r2,r2,4
 909d2fc:	10800fcc 	andi	r2,r2,63
 909d300:	e0bff945 	stb	r2,-27(fp)
            revision_number = phyid2 & 0x0f;
 909d304:	e0bffc17 	ldw	r2,-16(fp)
 909d308:	108003cc 	andi	r2,r2,15
 909d30c:	e0bff905 	stb	r2,-28(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 909d310:	e03ff705 	stb	zero,-36(fp)
            for(i = 0; i < phy_profile_count; i++) {
 909d314:	e03ff815 	stw	zero,-32(fp)
 909d318:	00003106 	br	909d3e0 <alt_tse_mac_get_phy+0x1ec>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 909d31c:	e0bff817 	ldw	r2,-32(fp)
 909d320:	00c243b4 	movhi	r3,2318
 909d324:	18f2fd04 	addi	r3,r3,-13324
 909d328:	1085883a 	add	r2,r2,r2
 909d32c:	1085883a 	add	r2,r2,r2
 909d330:	10c5883a 	add	r2,r2,r3
 909d334:	10800017 	ldw	r2,0(r2)
 909d338:	10c01417 	ldw	r3,80(r2)
 909d33c:	e0bffa17 	ldw	r2,-24(fp)
 909d340:	1880241e 	bne	r3,r2,909d3d4 <alt_tse_mac_get_phy+0x1e0>
 909d344:	e0bff817 	ldw	r2,-32(fp)
 909d348:	00c243b4 	movhi	r3,2318
 909d34c:	18f2fd04 	addi	r3,r3,-13324
 909d350:	1085883a 	add	r2,r2,r2
 909d354:	1085883a 	add	r2,r2,r2
 909d358:	10c5883a 	add	r2,r2,r3
 909d35c:	10800017 	ldw	r2,0(r2)
 909d360:	10801503 	ldbu	r2,84(r2)
 909d364:	10c03fcc 	andi	r3,r2,255
 909d368:	e0bff943 	ldbu	r2,-27(fp)
 909d36c:	1880191e 	bne	r3,r2,909d3d4 <alt_tse_mac_get_phy+0x1e0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 909d370:	e0bff817 	ldw	r2,-32(fp)
 909d374:	00c243b4 	movhi	r3,2318
 909d378:	18f2fd04 	addi	r3,r3,-13324
 909d37c:	1085883a 	add	r2,r2,r2
 909d380:	1085883a 	add	r2,r2,r2
 909d384:	10c5883a 	add	r2,r2,r3
 909d388:	10c00017 	ldw	r3,0(r2)
 909d38c:	e0bff417 	ldw	r2,-48(fp)
 909d390:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 909d394:	e0bff817 	ldw	r2,-32(fp)
 909d398:	00c243b4 	movhi	r3,2318
 909d39c:	18f2fd04 	addi	r3,r3,-13324
 909d3a0:	1085883a 	add	r2,r2,r2
 909d3a4:	1085883a 	add	r2,r2,r2
 909d3a8:	10c5883a 	add	r2,r2,r3
 909d3ac:	10800017 	ldw	r2,0(r2)
 909d3b0:	100b883a 	mov	r5,r2
 909d3b4:	e1bffb03 	ldbu	r6,-20(fp)
 909d3b8:	e1ffef07 	ldb	r7,-68(fp)
 909d3bc:	01024374 	movhi	r4,2317
 909d3c0:	21372004 	addi	r4,r4,-9088
 909d3c4:	90825100 	call	9082510 <printf>
                    is_phy_in_profile = 1;
 909d3c8:	00800044 	movi	r2,1
 909d3cc:	e0bff705 	stb	r2,-36(fp)
                    break;
 909d3d0:	00000706 	br	909d3f0 <alt_tse_mac_get_phy+0x1fc>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 909d3d4:	e0bff817 	ldw	r2,-32(fp)
 909d3d8:	10800044 	addi	r2,r2,1
 909d3dc:	e0bff815 	stw	r2,-32(fp)
 909d3e0:	d0a07f03 	ldbu	r2,-32260(gp)
 909d3e4:	10c03fcc 	andi	r3,r2,255
 909d3e8:	e0bff817 	ldw	r2,-32(fp)
 909d3ec:	10ffcb16 	blt	r2,r3,909d31c <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 909d3f0:	e0bff703 	ldbu	r2,-36(fp)
 909d3f4:	1004c03a 	cmpne	r2,r2,zero
 909d3f8:	10000d1e 	bne	r2,zero,909d430 <alt_tse_mac_get_phy+0x23c>
                pphy->pphy_profile = 0;
 909d3fc:	e0bff417 	ldw	r2,-48(fp)
 909d400:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 909d404:	e17ffb03 	ldbu	r5,-20(fp)
 909d408:	e1bfef07 	ldb	r6,-68(fp)
 909d40c:	01024374 	movhi	r4,2317
 909d410:	21373004 	addi	r4,r4,-9024
 909d414:	90825100 	call	9082510 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 909d418:	01024374 	movhi	r4,2317
 909d41c:	21374104 	addi	r4,r4,-8956
 909d420:	90828380 	call	9082838 <puts>
                return_value++;
 909d424:	e0bff617 	ldw	r2,-40(fp)
 909d428:	10800044 	addi	r2,r2,1
 909d42c:	e0bff615 	stw	r2,-40(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 909d430:	e17ffa17 	ldw	r5,-24(fp)
 909d434:	01024374 	movhi	r4,2317
 909d438:	21374e04 	addi	r4,r4,-8904
 909d43c:	909a0b80 	call	909a0b8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 909d440:	e17ff943 	ldbu	r5,-27(fp)
 909d444:	01024374 	movhi	r4,2317
 909d448:	21375904 	addi	r4,r4,-8860
 909d44c:	909a0b80 	call	909a0b8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 909d450:	e17ff903 	ldbu	r5,-28(fp)
 909d454:	01024374 	movhi	r4,2317
 909d458:	21376404 	addi	r4,r4,-8816
 909d45c:	909a0b80 	call	909a0b8 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 909d460:	e13ffe17 	ldw	r4,-8(fp)
 909d464:	e17ff417 	ldw	r5,-48(fp)
 909d468:	909d60c0 	call	909d60c <alt_tse_mac_associate_phy>
 909d46c:	1004c03a 	cmpne	r2,r2,zero
 909d470:	1000381e 	bne	r2,zero,909d554 <alt_tse_mac_get_phy+0x360>
            	
            	pmac_info = pphy->pmac_info;
 909d474:	e0bff417 	ldw	r2,-48(fp)
 909d478:	10800617 	ldw	r2,24(r2)
 909d47c:	e0bff315 	stw	r2,-52(fp)
            	psys = pmac_info->psys_info;
 909d480:	e0bff317 	ldw	r2,-52(fp)
 909d484:	10800217 	ldw	r2,8(r2)
 909d488:	e0bff215 	stw	r2,-56(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 909d48c:	d8000015 	stw	zero,0(sp)
 909d490:	e13ff417 	ldw	r4,-48(fp)
 909d494:	000b883a 	mov	r5,zero
 909d498:	01800384 	movi	r6,14
 909d49c:	01c00044 	movi	r7,1
 909d4a0:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 909d4a4:	e13ff417 	ldw	r4,-48(fp)
 909d4a8:	01400044 	movi	r5,1
 909d4ac:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 909d4b0:	e13ff417 	ldw	r4,-48(fp)
 909d4b4:	01400044 	movi	r5,1
 909d4b8:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 909d4bc:	e13ff417 	ldw	r4,-48(fp)
 909d4c0:	01400044 	movi	r5,1
 909d4c4:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 909d4c8:	e13ff417 	ldw	r4,-48(fp)
 909d4cc:	014003f4 	movhi	r5,15
 909d4d0:	29509004 	addi	r5,r5,16960
 909d4d4:	909da780 	call	909da78 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 909d4d8:	e0bff417 	ldw	r2,-48(fp)
 909d4dc:	10800517 	ldw	r2,20(r2)
 909d4e0:	1005003a 	cmpeq	r2,r2,zero
 909d4e4:	1000101e 	bne	r2,zero,909d528 <alt_tse_mac_get_phy+0x334>
		            if(pphy->pphy_profile->phy_cfg) {
 909d4e8:	e0bff417 	ldw	r2,-48(fp)
 909d4ec:	10800517 	ldw	r2,20(r2)
 909d4f0:	10801717 	ldw	r2,92(r2)
 909d4f4:	1005003a 	cmpeq	r2,r2,zero
 909d4f8:	10000b1e 	bne	r2,zero,909d528 <alt_tse_mac_get_phy+0x334>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 909d4fc:	e0bff417 	ldw	r2,-48(fp)
 909d500:	10800517 	ldw	r2,20(r2)
 909d504:	100b883a 	mov	r5,r2
 909d508:	01024374 	movhi	r4,2317
 909d50c:	21376f04 	addi	r4,r4,-8772
 909d510:	909a0b80 	call	909a0b8 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 909d514:	e0bff417 	ldw	r2,-48(fp)
 909d518:	10800517 	ldw	r2,20(r2)
 909d51c:	10801717 	ldw	r2,92(r2)
 909d520:	e13ff117 	ldw	r4,-60(fp)
 909d524:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 909d528:	e0bff217 	ldw	r2,-56(fp)
 909d52c:	10801117 	ldw	r2,68(r2)
 909d530:	1005003a 	cmpeq	r2,r2,zero
 909d534:	1000071e 	bne	r2,zero,909d554 <alt_tse_mac_get_phy+0x360>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 909d538:	01024374 	movhi	r4,2317
 909d53c:	21377d04 	addi	r4,r4,-8716
 909d540:	909a0b80 	call	909a0b8 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 909d544:	e0bff217 	ldw	r2,-56(fp)
 909d548:	10801117 	ldw	r2,68(r2)
 909d54c:	e13ff117 	ldw	r4,-60(fp)
 909d550:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 909d554:	01024374 	movhi	r4,2317
 909d558:	21378b04 	addi	r4,r4,-8660
 909d55c:	909a0b80 	call	909a0b8 <no_printf>
	            
            phy_info_count++;
 909d560:	e0bff503 	ldbu	r2,-44(fp)
 909d564:	10800044 	addi	r2,r2,1
 909d568:	e0bff505 	stb	r2,-44(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 909d56c:	e0bffb03 	ldbu	r2,-20(fp)
 909d570:	10800044 	addi	r2,r2,1
 909d574:	e0bffb05 	stb	r2,-20(fp)
 909d578:	e0bffb03 	ldbu	r2,-20(fp)
 909d57c:	10800830 	cmpltui	r2,r2,32
 909d580:	103f351e 	bne	r2,zero,909d258 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 909d584:	e0bffe17 	ldw	r2,-8(fp)
 909d588:	10800003 	ldbu	r2,0(r2)
 909d58c:	10c03fcc 	andi	r3,r2,255
 909d590:	e0bff507 	ldb	r2,-44(fp)
 909d594:	18801026 	beq	r3,r2,909d5d8 <alt_tse_mac_get_phy+0x3e4>
        if(phy_info_count == 0) {
 909d598:	e0bff507 	ldb	r2,-44(fp)
 909d59c:	1004c03a 	cmpne	r2,r2,zero
 909d5a0:	1000051e 	bne	r2,zero,909d5b8 <alt_tse_mac_get_phy+0x3c4>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 909d5a4:	e17fef07 	ldb	r5,-68(fp)
 909d5a8:	01024374 	movhi	r4,2317
 909d5ac:	21378c04 	addi	r4,r4,-8656
 909d5b0:	90825100 	call	9082510 <printf>
 909d5b4:	00000806 	br	909d5d8 <alt_tse_mac_get_phy+0x3e4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 909d5b8:	e17fef07 	ldb	r5,-68(fp)
 909d5bc:	e1bff507 	ldb	r6,-44(fp)
 909d5c0:	e0bffe17 	ldw	r2,-8(fp)
 909d5c4:	10800003 	ldbu	r2,0(r2)
 909d5c8:	11c03fcc 	andi	r7,r2,255
 909d5cc:	01024374 	movhi	r4,2317
 909d5d0:	21379804 	addi	r4,r4,-8608
 909d5d4:	90825100 	call	9082510 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909d5d8:	e0bff117 	ldw	r2,-60(fp)
 909d5dc:	10801004 	addi	r2,r2,64
 909d5e0:	1007883a 	mov	r3,r2
 909d5e4:	e0bff017 	ldw	r2,-64(fp)
 909d5e8:	18800035 	stwio	r2,0(r3)
    
    return return_value;
 909d5ec:	e0bff617 	ldw	r2,-40(fp)
 909d5f0:	e0bfff15 	stw	r2,-4(fp)
 909d5f4:	e0bfff17 	ldw	r2,-4(fp)
}
 909d5f8:	e037883a 	mov	sp,fp
 909d5fc:	dfc00117 	ldw	ra,4(sp)
 909d600:	df000017 	ldw	fp,0(sp)
 909d604:	dec00204 	addi	sp,sp,8
 909d608:	f800283a 	ret

0909d60c <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 909d60c:	defff604 	addi	sp,sp,-40
 909d610:	dfc00915 	stw	ra,36(sp)
 909d614:	df000815 	stw	fp,32(sp)
 909d618:	df000804 	addi	fp,sp,32
 909d61c:	e13ffe15 	stw	r4,-8(fp)
 909d620:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 909d624:	e03ffc15 	stw	zero,-16(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 909d628:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_info *pmac_info = 0;
 909d62c:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909d630:	e03ff885 	stb	zero,-30(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909d634:	e13ffe17 	ldw	r4,-8(fp)
 909d638:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909d63c:	e0bff845 	stb	r2,-31(fp)
    alt_8 sys_info_index = 0;
 909d640:	e03ff805 	stb	zero,-32(fp)
    
    is_mapped = 0;
 909d644:	e03ffb05 	stb	zero,-20(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 909d648:	e03ffd15 	stw	zero,-12(fp)
 909d64c:	00002906 	br	909d6f4 <alt_tse_mac_associate_phy+0xe8>
        pmac_info = pmac_group->pmac_info[i];
 909d650:	e0bffd17 	ldw	r2,-12(fp)
 909d654:	e0fffe17 	ldw	r3,-8(fp)
 909d658:	1085883a 	add	r2,r2,r2
 909d65c:	1085883a 	add	r2,r2,r2
 909d660:	10c5883a 	add	r2,r2,r3
 909d664:	10800104 	addi	r2,r2,4
 909d668:	10800017 	ldw	r2,0(r2)
 909d66c:	e0bff915 	stw	r2,-28(fp)
        psys = pmac_info->psys_info;
 909d670:	e0bff917 	ldw	r2,-28(fp)
 909d674:	10800217 	ldw	r2,8(r2)
 909d678:	e0bffa15 	stw	r2,-24(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 909d67c:	e0bffa17 	ldw	r2,-24(fp)
 909d680:	10c01017 	ldw	r3,64(r2)
 909d684:	e0bfff17 	ldw	r2,-4(fp)
 909d688:	10800003 	ldbu	r2,0(r2)
 909d68c:	10803fcc 	andi	r2,r2,255
 909d690:	1880151e 	bne	r3,r2,909d6e8 <alt_tse_mac_associate_phy+0xdc>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909d694:	e13ff917 	ldw	r4,-28(fp)
 909d698:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909d69c:	e0bff885 	stb	r2,-30(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 909d6a0:	e13ffa17 	ldw	r4,-24(fp)
 909d6a4:	909b2040 	call	909b204 <alt_tse_get_system_index>
 909d6a8:	e0bff805 	stb	r2,-32(fp)
	        
            pmac_info->pphy_info = pphy;
 909d6ac:	e0fff917 	ldw	r3,-28(fp)
 909d6b0:	e0bfff17 	ldw	r2,-4(fp)
 909d6b4:	18800115 	stw	r2,4(r3)
            pphy->pmac_info = pmac_info;
 909d6b8:	e0ffff17 	ldw	r3,-4(fp)
 909d6bc:	e0bff917 	ldw	r2,-28(fp)
 909d6c0:	18800615 	stw	r2,24(r3)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 909d6c4:	e17ff847 	ldb	r5,-31(fp)
 909d6c8:	e1bff887 	ldb	r6,-30(fp)
 909d6cc:	e1fff807 	ldb	r7,-32(fp)
 909d6d0:	01024374 	movhi	r4,2317
 909d6d4:	2137b704 	addi	r4,r4,-8484
 909d6d8:	90825100 	call	9082510 <printf>
            is_mapped = 1;
 909d6dc:	00800044 	movi	r2,1
 909d6e0:	e0bffb05 	stb	r2,-20(fp)
            break;
 909d6e4:	00000806 	br	909d708 <alt_tse_mac_associate_phy+0xfc>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 909d6e8:	e0bffd17 	ldw	r2,-12(fp)
 909d6ec:	10800044 	addi	r2,r2,1
 909d6f0:	e0bffd15 	stw	r2,-12(fp)
 909d6f4:	e0bffe17 	ldw	r2,-8(fp)
 909d6f8:	10800003 	ldbu	r2,0(r2)
 909d6fc:	10c03fcc 	andi	r3,r2,255
 909d700:	e0bffd17 	ldw	r2,-12(fp)
 909d704:	10ffd216 	blt	r2,r3,909d650 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 909d708:	e0bffb03 	ldbu	r2,-20(fp)
 909d70c:	1004c03a 	cmpne	r2,r2,zero
 909d710:	10003b1e 	bne	r2,zero,909d800 <alt_tse_mac_associate_phy+0x1f4>
        for(i = 0; i < pmac_group->channel; i++) {
 909d714:	e03ffd15 	stw	zero,-12(fp)
 909d718:	00003406 	br	909d7ec <alt_tse_mac_associate_phy+0x1e0>
            pmac_info = pmac_group->pmac_info[i];
 909d71c:	e0bffd17 	ldw	r2,-12(fp)
 909d720:	e0fffe17 	ldw	r3,-8(fp)
 909d724:	1085883a 	add	r2,r2,r2
 909d728:	1085883a 	add	r2,r2,r2
 909d72c:	10c5883a 	add	r2,r2,r3
 909d730:	10800104 	addi	r2,r2,4
 909d734:	10800017 	ldw	r2,0(r2)
 909d738:	e0bff915 	stw	r2,-28(fp)
            psys = pmac_info->psys_info;
 909d73c:	e0bff917 	ldw	r2,-28(fp)
 909d740:	10800217 	ldw	r2,8(r2)
 909d744:	e0bffa15 	stw	r2,-24(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 909d748:	e0bffa17 	ldw	r2,-24(fp)
 909d74c:	10800517 	ldw	r2,20(r2)
 909d750:	1005003a 	cmpeq	r2,r2,zero
 909d754:	1000221e 	bne	r2,zero,909d7e0 <alt_tse_mac_associate_phy+0x1d4>
 909d758:	e0bffa17 	ldw	r2,-24(fp)
 909d75c:	10800617 	ldw	r2,24(r2)
 909d760:	1005003a 	cmpeq	r2,r2,zero
 909d764:	10001e1e 	bne	r2,zero,909d7e0 <alt_tse_mac_associate_phy+0x1d4>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 909d768:	e0bffa17 	ldw	r2,-24(fp)
 909d76c:	10801017 	ldw	r2,64(r2)
 909d770:	10bfffd8 	cmpnei	r2,r2,-1
 909d774:	10001a1e 	bne	r2,zero,909d7e0 <alt_tse_mac_associate_phy+0x1d4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909d778:	e13ff917 	ldw	r4,-28(fp)
 909d77c:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909d780:	e0bff885 	stb	r2,-30(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 909d784:	e13ffa17 	ldw	r4,-24(fp)
 909d788:	909b2040 	call	909b204 <alt_tse_get_system_index>
 909d78c:	e0bff805 	stb	r2,-32(fp)
                
                pmac_info->pphy_info = pphy;
 909d790:	e0fff917 	ldw	r3,-28(fp)
 909d794:	e0bfff17 	ldw	r2,-4(fp)
 909d798:	18800115 	stw	r2,4(r3)
                pphy->pmac_info = pmac_info;
 909d79c:	e0ffff17 	ldw	r3,-4(fp)
 909d7a0:	e0bff917 	ldw	r2,-28(fp)
 909d7a4:	18800615 	stw	r2,24(r3)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 909d7a8:	e0bfff17 	ldw	r2,-4(fp)
 909d7ac:	10800003 	ldbu	r2,0(r2)
 909d7b0:	10c03fcc 	andi	r3,r2,255
 909d7b4:	e0bffa17 	ldw	r2,-24(fp)
 909d7b8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 909d7bc:	e17ff847 	ldb	r5,-31(fp)
 909d7c0:	e1bff887 	ldb	r6,-30(fp)
 909d7c4:	e1fff807 	ldb	r7,-32(fp)
 909d7c8:	01024374 	movhi	r4,2317
 909d7cc:	2137c704 	addi	r4,r4,-8420
 909d7d0:	90825100 	call	9082510 <printf>
                is_mapped = 1;
 909d7d4:	00800044 	movi	r2,1
 909d7d8:	e0bffb05 	stb	r2,-20(fp)
                break;
 909d7dc:	00000806 	br	909d800 <alt_tse_mac_associate_phy+0x1f4>
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 909d7e0:	e0bffd17 	ldw	r2,-12(fp)
 909d7e4:	10800044 	addi	r2,r2,1
 909d7e8:	e0bffd15 	stw	r2,-12(fp)
 909d7ec:	e0bffe17 	ldw	r2,-8(fp)
 909d7f0:	10800003 	ldbu	r2,0(r2)
 909d7f4:	10c03fcc 	andi	r3,r2,255
 909d7f8:	e0bffd17 	ldw	r2,-12(fp)
 909d7fc:	10ffc716 	blt	r2,r3,909d71c <alt_tse_mac_associate_phy+0x110>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 909d800:	e0bffb03 	ldbu	r2,-20(fp)
 909d804:	1004c03a 	cmpne	r2,r2,zero
 909d808:	1000081e 	bne	r2,zero,909d82c <alt_tse_mac_associate_phy+0x220>
    	pphy->pmac_info = 0;
 909d80c:	e0bfff17 	ldw	r2,-4(fp)
 909d810:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 909d814:	e17ff847 	ldb	r5,-31(fp)
 909d818:	01024374 	movhi	r4,2317
 909d81c:	2137d804 	addi	r4,r4,-8352
 909d820:	90825100 	call	9082510 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 909d824:	00bfffc4 	movi	r2,-1
 909d828:	e0bffc15 	stw	r2,-16(fp)
    }
    
    return return_value;
 909d82c:	e0bffc17 	ldw	r2,-16(fp)
}
 909d830:	e037883a 	mov	sp,fp
 909d834:	dfc00117 	ldw	ra,4(sp)
 909d838:	df000017 	ldw	fp,0(sp)
 909d83c:	dec00204 	addi	sp,sp,8
 909d840:	f800283a 	ret

0909d844 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 909d844:	defff804 	addi	sp,sp,-32
 909d848:	dfc00715 	stw	ra,28(sp)
 909d84c:	df000615 	stw	fp,24(sp)
 909d850:	df000604 	addi	fp,sp,24
 909d854:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 909d858:	e0bfff17 	ldw	r2,-4(fp)
 909d85c:	10800217 	ldw	r2,8(r2)
 909d860:	e0bffe15 	stw	r2,-8(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 909d864:	e0bffe17 	ldw	r2,-8(fp)
 909d868:	10800017 	ldw	r2,0(r2)
 909d86c:	e0bffd15 	stw	r2,-12(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909d870:	e0bfff17 	ldw	r2,-4(fp)
 909d874:	10800317 	ldw	r2,12(r2)
 909d878:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909d87c:	e13fff17 	ldw	r4,-4(fp)
 909d880:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909d884:	e0bffb45 	stb	r2,-19(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909d888:	e13ffc17 	ldw	r4,-16(fp)
 909d88c:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909d890:	e0bffb05 	stb	r2,-20(fp)

    if(psys->tse_pcs_ena) {
 909d894:	e0bffe17 	ldw	r2,-8(fp)
 909d898:	108003c3 	ldbu	r2,15(r2)
 909d89c:	10803fcc 	andi	r2,r2,255
 909d8a0:	1005003a 	cmpeq	r2,r2,zero
 909d8a4:	1000291e 	bne	r2,zero,909d94c <alt_tse_phy_cfg_pcs+0x108>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 909d8a8:	e17ffb07 	ldb	r5,-20(fp)
 909d8ac:	e1bffb47 	ldb	r6,-19(fp)
 909d8b0:	01024374 	movhi	r4,2317
 909d8b4:	21380904 	addi	r4,r4,-8156
 909d8b8:	90825100 	call	9082510 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 909d8bc:	e0bffd17 	ldw	r2,-12(fp)
 909d8c0:	10808004 	addi	r2,r2,512
 909d8c4:	10801404 	addi	r2,r2,80
 909d8c8:	10800037 	ldwio	r2,0(r2)
 909d8cc:	e0bffa15 	stw	r2,-24(fp)
        
        if(psys->tse_pcs_sgmii) {
 909d8d0:	e0bffe17 	ldw	r2,-8(fp)
 909d8d4:	10800403 	ldbu	r2,16(r2)
 909d8d8:	10803fcc 	andi	r2,r2,255
 909d8dc:	1005003a 	cmpeq	r2,r2,zero
 909d8e0:	10000d1e 	bne	r2,zero,909d918 <alt_tse_phy_cfg_pcs+0xd4>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 909d8e4:	e17ffb07 	ldb	r5,-20(fp)
 909d8e8:	e1bffb47 	ldb	r6,-19(fp)
 909d8ec:	01024374 	movhi	r4,2317
 909d8f0:	21381704 	addi	r4,r4,-8100
 909d8f4:	90825100 	call	9082510 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 909d8f8:	e0bffd17 	ldw	r2,-12(fp)
 909d8fc:	10808004 	addi	r2,r2,512
 909d900:	11001404 	addi	r4,r2,80
 909d904:	e0bffa17 	ldw	r2,-24(fp)
 909d908:	10c000d4 	ori	r3,r2,3
 909d90c:	2005883a 	mov	r2,r4
 909d910:	10c00035 	stwio	r3,0(r2)
 909d914:	00000d06 	br	909d94c <alt_tse_phy_cfg_pcs+0x108>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 909d918:	e17ffb07 	ldb	r5,-20(fp)
 909d91c:	e1bffb47 	ldb	r6,-19(fp)
 909d920:	01024374 	movhi	r4,2317
 909d924:	21382304 	addi	r4,r4,-8052
 909d928:	90825100 	call	9082510 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 909d92c:	e0bffd17 	ldw	r2,-12(fp)
 909d930:	10808004 	addi	r2,r2,512
 909d934:	11001404 	addi	r4,r2,80
 909d938:	e0fffa17 	ldw	r3,-24(fp)
 909d93c:	00bfff04 	movi	r2,-4
 909d940:	1886703a 	and	r3,r3,r2
 909d944:	2005883a 	mov	r2,r4
 909d948:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 909d94c:	0005883a 	mov	r2,zero
}
 909d950:	e037883a 	mov	sp,fp
 909d954:	dfc00117 	ldw	ra,4(sp)
 909d958:	df000017 	ldw	fp,0(sp)
 909d95c:	dec00204 	addi	sp,sp,8
 909d960:	f800283a 	ret

0909d964 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 909d964:	defffb04 	addi	sp,sp,-20
 909d968:	dfc00415 	stw	ra,16(sp)
 909d96c:	df000315 	stw	fp,12(sp)
 909d970:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 909d974:	e03fff45 	stb	zero,-3(fp)
	alt_8 j = 0;
 909d978:	e03fff05 	stb	zero,-4(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 909d97c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 909d980:	e03ffd15 	stw	zero,-12(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 909d984:	909c6800 	call	909c680 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 909d988:	909c8f80 	call	909c8f8 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 909d98c:	909cae80 	call	909cae8 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 909d990:	e03fff45 	stb	zero,-3(fp)
 909d994:	00002e06 	br	909da50 <alt_tse_phy_init+0xec>
        pmac_group = pmac_groups[i];
 909d998:	e0bfff47 	ldb	r2,-3(fp)
 909d99c:	00c243b4 	movhi	r3,2318
 909d9a0:	18f2f904 	addi	r3,r3,-13340
 909d9a4:	1085883a 	add	r2,r2,r2
 909d9a8:	1085883a 	add	r2,r2,r2
 909d9ac:	10c5883a 	add	r2,r2,r3
 909d9b0:	10800017 	ldw	r2,0(r2)
 909d9b4:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 909d9b8:	e0bffe17 	ldw	r2,-8(fp)
 909d9bc:	10800117 	ldw	r2,4(r2)
 909d9c0:	10800217 	ldw	r2,8(r2)
 909d9c4:	10800203 	ldbu	r2,8(r2)
 909d9c8:	10803fcc 	andi	r2,r2,255
 909d9cc:	1005003a 	cmpeq	r2,r2,zero
 909d9d0:	1000031e 	bne	r2,zero,909d9e0 <alt_tse_phy_init+0x7c>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 909d9d4:	e13ffe17 	ldw	r4,-8(fp)
 909d9d8:	909d1f40 	call	909d1f4 <alt_tse_mac_get_phy>
 909d9dc:	00000506 	br	909d9f4 <alt_tse_phy_init+0x90>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 909d9e0:	e17fff47 	ldb	r5,-3(fp)
 909d9e4:	e1bfff07 	ldb	r6,-4(fp)
 909d9e8:	01024374 	movhi	r4,2317
 909d9ec:	21382f04 	addi	r4,r4,-8004
 909d9f0:	90825100 	call	9082510 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 909d9f4:	e03fff05 	stb	zero,-4(fp)
 909d9f8:	00000d06 	br	909da30 <alt_tse_phy_init+0xcc>
            pmac_info = pmac_group->pmac_info[j];
 909d9fc:	e0bfff07 	ldb	r2,-4(fp)
 909da00:	e0fffe17 	ldw	r3,-8(fp)
 909da04:	1085883a 	add	r2,r2,r2
 909da08:	1085883a 	add	r2,r2,r2
 909da0c:	10c5883a 	add	r2,r2,r3
 909da10:	10800104 	addi	r2,r2,4
 909da14:	10800017 	ldw	r2,0(r2)
 909da18:	e0bffd15 	stw	r2,-12(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 909da1c:	e13ffd17 	ldw	r4,-12(fp)
 909da20:	909d8440 	call	909d844 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 909da24:	e0bfff03 	ldbu	r2,-4(fp)
 909da28:	10800044 	addi	r2,r2,1
 909da2c:	e0bfff05 	stb	r2,-4(fp)
 909da30:	e0ffff07 	ldb	r3,-4(fp)
 909da34:	e0bffe17 	ldw	r2,-8(fp)
 909da38:	10800003 	ldbu	r2,0(r2)
 909da3c:	10803fcc 	andi	r2,r2,255
 909da40:	18bfee16 	blt	r3,r2,909d9fc <alt_tse_phy_init+0x98>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 909da44:	e0bfff43 	ldbu	r2,-3(fp)
 909da48:	10800044 	addi	r2,r2,1
 909da4c:	e0bfff45 	stb	r2,-3(fp)
 909da50:	e0bfff47 	ldb	r2,-3(fp)
 909da54:	d0e07f43 	ldbu	r3,-32259(gp)
 909da58:	18c03fcc 	andi	r3,r3,255
 909da5c:	10ffce16 	blt	r2,r3,909d998 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 909da60:	0005883a 	mov	r2,zero
}
 909da64:	e037883a 	mov	sp,fp
 909da68:	dfc00117 	ldw	ra,4(sp)
 909da6c:	df000017 	ldw	fp,0(sp)
 909da70:	dec00204 	addi	sp,sp,8
 909da74:	f800283a 	ret

0909da78 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 909da78:	defff604 	addi	sp,sp,-40
 909da7c:	dfc00915 	stw	ra,36(sp)
 909da80:	df000815 	stw	fp,32(sp)
 909da84:	df000804 	addi	fp,sp,32
 909da88:	e13ffd15 	stw	r4,-12(fp)
 909da8c:	e17ffe15 	stw	r5,-8(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909da90:	e0bffd17 	ldw	r2,-12(fp)
 909da94:	10800617 	ldw	r2,24(r2)
 909da98:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909da9c:	e0bffc17 	ldw	r2,-16(fp)
 909daa0:	10800317 	ldw	r2,12(r2)
 909daa4:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909daa8:	e13ffc17 	ldw	r4,-16(fp)
 909daac:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909dab0:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909dab4:	e13ffb17 	ldw	r4,-20(fp)
 909dab8:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909dabc:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909dac0:	e13ffd17 	ldw	r4,-12(fp)
 909dac4:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909dac8:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909dacc:	e0bffd17 	ldw	r2,-12(fp)
 909dad0:	10800003 	ldbu	r2,0(r2)
 909dad4:	11403fcc 	andi	r5,r2,255
 909dad8:	e13ffd17 	ldw	r4,-12(fp)
 909dadc:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909dae0:	e13ffd17 	ldw	r4,-12(fp)
 909dae4:	01400044 	movi	r5,1
 909dae8:	018000c4 	movi	r6,3
 909daec:	01c00044 	movi	r7,1
 909daf0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909daf4:	1004c03a 	cmpne	r2,r2,zero
 909daf8:	10000b1e 	bne	r2,zero,909db28 <alt_tse_phy_restart_an+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 909dafc:	e17ffa47 	ldb	r5,-23(fp)
 909db00:	e1bffa87 	ldb	r6,-22(fp)
 909db04:	01024374 	movhi	r4,2317
 909db08:	21384504 	addi	r4,r4,-7916
 909db0c:	90825100 	call	9082510 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909db10:	e17ffa03 	ldbu	r5,-24(fp)
 909db14:	e13ffd17 	ldw	r4,-12(fp)
 909db18:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 909db1c:	00bfff84 	movi	r2,-2
 909db20:	e0bfff15 	stw	r2,-4(fp)
 909db24:	00003a06 	br	909dc10 <alt_tse_phy_restart_an+0x198>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 909db28:	00800044 	movi	r2,1
 909db2c:	d8800015 	stw	r2,0(sp)
 909db30:	e13ffd17 	ldw	r4,-12(fp)
 909db34:	000b883a 	mov	r5,zero
 909db38:	01800304 	movi	r6,12
 909db3c:	01c00044 	movi	r7,1
 909db40:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 909db44:	00800044 	movi	r2,1
 909db48:	d8800015 	stw	r2,0(sp)
 909db4c:	e13ffd17 	ldw	r4,-12(fp)
 909db50:	000b883a 	mov	r5,zero
 909db54:	01800244 	movi	r6,9
 909db58:	01c00044 	movi	r7,1
 909db5c:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 909db60:	e17ffa47 	ldb	r5,-23(fp)
 909db64:	e1bffa87 	ldb	r6,-22(fp)
 909db68:	01024374 	movhi	r4,2317
 909db6c:	21385504 	addi	r4,r4,-7852
 909db70:	90825100 	call	9082510 <printf>
    
    alt_32 timeout = 0;
 909db74:	e03ff915 	stw	zero,-28(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 909db78:	00001506 	br	909dbd0 <alt_tse_phy_restart_an+0x158>
        if(timeout++ > timeout_threshold) {
 909db7c:	e0fff917 	ldw	r3,-28(fp)
 909db80:	e0bffe17 	ldw	r2,-8(fp)
 909db84:	10c5803a 	cmpltu	r2,r2,r3
 909db88:	1007883a 	mov	r3,r2
 909db8c:	e0bff917 	ldw	r2,-28(fp)
 909db90:	10800044 	addi	r2,r2,1
 909db94:	e0bff915 	stw	r2,-28(fp)
 909db98:	18803fcc 	andi	r2,r3,255
 909db9c:	1005003a 	cmpeq	r2,r2,zero
 909dba0:	10000b1e 	bne	r2,zero,909dbd0 <alt_tse_phy_restart_an+0x158>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 909dba4:	e17ffa47 	ldb	r5,-23(fp)
 909dba8:	e1bffa87 	ldb	r6,-22(fp)
 909dbac:	01024374 	movhi	r4,2317
 909dbb0:	21386704 	addi	r4,r4,-7780
 909dbb4:	90825100 	call	9082510 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909dbb8:	e17ffa03 	ldbu	r5,-24(fp)
 909dbbc:	e13ffd17 	ldw	r4,-12(fp)
 909dbc0:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 909dbc4:	00bfffc4 	movi	r2,-1
 909dbc8:	e0bfff15 	stw	r2,-4(fp)
 909dbcc:	00001006 	br	909dc10 <alt_tse_phy_restart_an+0x198>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 909dbd0:	e13ffd17 	ldw	r4,-12(fp)
 909dbd4:	01400044 	movi	r5,1
 909dbd8:	01800144 	movi	r6,5
 909dbdc:	01c00044 	movi	r7,1
 909dbe0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dbe4:	1005003a 	cmpeq	r2,r2,zero
 909dbe8:	103fe41e 	bne	r2,zero,909db7c <alt_tse_phy_restart_an+0x104>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 909dbec:	e17ffa47 	ldb	r5,-23(fp)
 909dbf0:	e1bffa87 	ldb	r6,-22(fp)
 909dbf4:	01024374 	movhi	r4,2317
 909dbf8:	21387304 	addi	r4,r4,-7732
 909dbfc:	90825100 	call	9082510 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909dc00:	e17ffa03 	ldbu	r5,-24(fp)
 909dc04:	e13ffd17 	ldw	r4,-12(fp)
 909dc08:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 909dc0c:	e03fff15 	stw	zero,-4(fp)
 909dc10:	e0bfff17 	ldw	r2,-4(fp)
}
 909dc14:	e037883a 	mov	sp,fp
 909dc18:	dfc00117 	ldw	ra,4(sp)
 909dc1c:	df000017 	ldw	fp,0(sp)
 909dc20:	dec00204 	addi	sp,sp,8
 909dc24:	f800283a 	ret

0909dc28 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 909dc28:	defff804 	addi	sp,sp,-32
 909dc2c:	dfc00715 	stw	ra,28(sp)
 909dc30:	df000615 	stw	fp,24(sp)
 909dc34:	df000604 	addi	fp,sp,24
 909dc38:	e13ffd15 	stw	r4,-12(fp)
 909dc3c:	e17ffe15 	stw	r5,-8(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909dc40:	e0bffd17 	ldw	r2,-12(fp)
 909dc44:	10800617 	ldw	r2,24(r2)
 909dc48:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909dc4c:	e0bffc17 	ldw	r2,-16(fp)
 909dc50:	10800317 	ldw	r2,12(r2)
 909dc54:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909dc58:	e13ffc17 	ldw	r4,-16(fp)
 909dc5c:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909dc60:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 909dc64:	e13ffb17 	ldw	r4,-20(fp)
 909dc68:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909dc6c:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909dc70:	e13ffd17 	ldw	r4,-12(fp)
 909dc74:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909dc78:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909dc7c:	e0bffd17 	ldw	r2,-12(fp)
 909dc80:	10800003 	ldbu	r2,0(r2)
 909dc84:	11403fcc 	andi	r5,r2,255
 909dc88:	e13ffd17 	ldw	r4,-12(fp)
 909dc8c:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 909dc90:	e17ffa47 	ldb	r5,-23(fp)
 909dc94:	e1bffa87 	ldb	r6,-22(fp)
 909dc98:	01024374 	movhi	r4,2317
 909dc9c:	21387f04 	addi	r4,r4,-7684
 909dca0:	90825100 	call	9082510 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 909dca4:	e13ffd17 	ldw	r4,-12(fp)
 909dca8:	000b883a 	mov	r5,zero
 909dcac:	01800384 	movi	r6,14
 909dcb0:	01c00044 	movi	r7,1
 909dcb4:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dcb8:	1004c03a 	cmpne	r2,r2,zero
 909dcbc:	1000071e 	bne	r2,zero,909dcdc <alt_tse_phy_check_link+0xb4>
 909dcc0:	e13ffd17 	ldw	r4,-12(fp)
 909dcc4:	01400044 	movi	r5,1
 909dcc8:	01800144 	movi	r6,5
 909dccc:	01c00044 	movi	r7,1
 909dcd0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dcd4:	1004c03a 	cmpne	r2,r2,zero
 909dcd8:	1000151e 	bne	r2,zero,909dd30 <alt_tse_phy_check_link+0x108>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 909dcdc:	e17ffa47 	ldb	r5,-23(fp)
 909dce0:	e1bffa87 	ldb	r6,-22(fp)
 909dce4:	01024374 	movhi	r4,2317
 909dce8:	21388a04 	addi	r4,r4,-7640
 909dcec:	90825100 	call	9082510 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 909dcf0:	e13ffd17 	ldw	r4,-12(fp)
 909dcf4:	e17ffe17 	ldw	r5,-8(fp)
 909dcf8:	909da780 	call	909da78 <alt_tse_phy_restart_an>
 909dcfc:	10bfffd8 	cmpnei	r2,r2,-1
 909dd00:	10000b1e 	bne	r2,zero,909dd30 <alt_tse_phy_check_link+0x108>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 909dd04:	e17ffa47 	ldb	r5,-23(fp)
 909dd08:	e1bffa87 	ldb	r6,-22(fp)
 909dd0c:	01024374 	movhi	r4,2317
 909dd10:	21389e04 	addi	r4,r4,-7560
 909dd14:	90825100 	call	9082510 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909dd18:	e17ffa03 	ldbu	r5,-24(fp)
 909dd1c:	e13ffd17 	ldw	r4,-12(fp)
 909dd20:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 909dd24:	00bfffc4 	movi	r2,-1
 909dd28:	e0bfff15 	stw	r2,-4(fp)
 909dd2c:	00000906 	br	909dd54 <alt_tse_phy_check_link+0x12c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 909dd30:	e17ffa47 	ldb	r5,-23(fp)
 909dd34:	e1bffa87 	ldb	r6,-22(fp)
 909dd38:	01024374 	movhi	r4,2317
 909dd3c:	2138ab04 	addi	r4,r4,-7508
 909dd40:	90825100 	call	9082510 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909dd44:	e17ffa03 	ldbu	r5,-24(fp)
 909dd48:	e13ffd17 	ldw	r4,-12(fp)
 909dd4c:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 909dd50:	e03fff15 	stw	zero,-4(fp)
 909dd54:	e0bfff17 	ldw	r2,-4(fp)
}
 909dd58:	e037883a 	mov	sp,fp
 909dd5c:	dfc00117 	ldw	ra,4(sp)
 909dd60:	df000017 	ldw	fp,0(sp)
 909dd64:	dec00204 	addi	sp,sp,8
 909dd68:	f800283a 	ret

0909dd6c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 909dd6c:	defff804 	addi	sp,sp,-32
 909dd70:	dfc00715 	stw	ra,28(sp)
 909dd74:	df000615 	stw	fp,24(sp)
 909dd78:	df000604 	addi	fp,sp,24
 909dd7c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 909dd80:	e03ffd15 	stw	zero,-12(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909dd84:	e0bffe17 	ldw	r2,-8(fp)
 909dd88:	10800617 	ldw	r2,24(r2)
 909dd8c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909dd90:	e0bffc17 	ldw	r2,-16(fp)
 909dd94:	10800317 	ldw	r2,12(r2)
 909dd98:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909dd9c:	e13ffc17 	ldw	r4,-16(fp)
 909dda0:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909dda4:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 909dda8:	e13ffb17 	ldw	r4,-20(fp)
 909ddac:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909ddb0:	e0bffa45 	stb	r2,-23(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909ddb4:	e13ffe17 	ldw	r4,-8(fp)
 909ddb8:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909ddbc:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909ddc0:	e0bffe17 	ldw	r2,-8(fp)
 909ddc4:	10800003 	ldbu	r2,0(r2)
 909ddc8:	11403fcc 	andi	r5,r2,255
 909ddcc:	e13ffe17 	ldw	r4,-8(fp)
 909ddd0:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909ddd4:	e13ffe17 	ldw	r4,-8(fp)
 909ddd8:	01400044 	movi	r5,1
 909dddc:	018000c4 	movi	r6,3
 909dde0:	01c00044 	movi	r7,1
 909dde4:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dde8:	1004c03a 	cmpne	r2,r2,zero
 909ddec:	10000b1e 	bne	r2,zero,909de1c <alt_tse_phy_get_cap+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 909ddf0:	e17ffa47 	ldb	r5,-23(fp)
 909ddf4:	e1bffa87 	ldb	r6,-22(fp)
 909ddf8:	01024374 	movhi	r4,2317
 909ddfc:	21384504 	addi	r4,r4,-7916
 909de00:	90825100 	call	9082510 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909de04:	e17ffa03 	ldbu	r5,-24(fp)
 909de08:	e13ffe17 	ldw	r4,-8(fp)
 909de0c:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 909de10:	00bfff84 	movi	r2,-2
 909de14:	e0bfff15 	stw	r2,-4(fp)
 909de18:	00011e06 	br	909e294 <alt_tse_phy_get_cap+0x528>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909de1c:	e13ffe17 	ldw	r4,-8(fp)
 909de20:	01400134 	movhi	r5,4
 909de24:	29742404 	addi	r5,r5,-12144
 909de28:	909da780 	call	909da78 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 909de2c:	e13ffe17 	ldw	r4,-8(fp)
 909de30:	01400044 	movi	r5,1
 909de34:	01800144 	movi	r6,5
 909de38:	01c00044 	movi	r7,1
 909de3c:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909de40:	1004c03a 	cmpne	r2,r2,zero
 909de44:	1000021e 	bne	r2,zero,909de50 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 909de48:	00bfffc4 	movi	r2,-1
 909de4c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 909de50:	e13ffe17 	ldw	r4,-8(fp)
 909de54:	014003c4 	movi	r5,15
 909de58:	018003c4 	movi	r6,15
 909de5c:	01c00044 	movi	r7,1
 909de60:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909de64:	1007883a 	mov	r3,r2
 909de68:	e0bffe17 	ldw	r2,-8(fp)
 909de6c:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 909de70:	e13ffe17 	ldw	r4,-8(fp)
 909de74:	014003c4 	movi	r5,15
 909de78:	01800384 	movi	r6,14
 909de7c:	01c00044 	movi	r7,1
 909de80:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909de84:	1007883a 	mov	r3,r2
 909de88:	e0bffe17 	ldw	r2,-8(fp)
 909de8c:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 909de90:	e13ffe17 	ldw	r4,-8(fp)
 909de94:	014003c4 	movi	r5,15
 909de98:	01800344 	movi	r6,13
 909de9c:	01c00044 	movi	r7,1
 909dea0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dea4:	1007883a 	mov	r3,r2
 909dea8:	e0bffe17 	ldw	r2,-8(fp)
 909deac:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 909deb0:	e13ffe17 	ldw	r4,-8(fp)
 909deb4:	014003c4 	movi	r5,15
 909deb8:	01800304 	movi	r6,12
 909debc:	01c00044 	movi	r7,1
 909dec0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dec4:	1007883a 	mov	r3,r2
 909dec8:	e0bffe17 	ldw	r2,-8(fp)
 909decc:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 909ded0:	e13ffe17 	ldw	r4,-8(fp)
 909ded4:	01400044 	movi	r5,1
 909ded8:	018003c4 	movi	r6,15
 909dedc:	01c00044 	movi	r7,1
 909dee0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dee4:	1007883a 	mov	r3,r2
 909dee8:	e0bffe17 	ldw	r2,-8(fp)
 909deec:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 909def0:	e13ffe17 	ldw	r4,-8(fp)
 909def4:	01400044 	movi	r5,1
 909def8:	01800384 	movi	r6,14
 909defc:	01c00044 	movi	r7,1
 909df00:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909df04:	1007883a 	mov	r3,r2
 909df08:	e0bffe17 	ldw	r2,-8(fp)
 909df0c:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 909df10:	e13ffe17 	ldw	r4,-8(fp)
 909df14:	01400044 	movi	r5,1
 909df18:	01800344 	movi	r6,13
 909df1c:	01c00044 	movi	r7,1
 909df20:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909df24:	1007883a 	mov	r3,r2
 909df28:	e0bffe17 	ldw	r2,-8(fp)
 909df2c:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 909df30:	e13ffe17 	ldw	r4,-8(fp)
 909df34:	01400044 	movi	r5,1
 909df38:	01800284 	movi	r6,10
 909df3c:	01c00044 	movi	r7,1
 909df40:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909df44:	1007883a 	mov	r3,r2
 909df48:	e0bffe17 	ldw	r2,-8(fp)
 909df4c:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 909df50:	e13ffe17 	ldw	r4,-8(fp)
 909df54:	01400044 	movi	r5,1
 909df58:	01800244 	movi	r6,9
 909df5c:	01c00044 	movi	r7,1
 909df60:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909df64:	1007883a 	mov	r3,r2
 909df68:	e0bffe17 	ldw	r2,-8(fp)
 909df6c:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 909df70:	e13ffe17 	ldw	r4,-8(fp)
 909df74:	01400044 	movi	r5,1
 909df78:	01800304 	movi	r6,12
 909df7c:	01c00044 	movi	r7,1
 909df80:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909df84:	1007883a 	mov	r3,r2
 909df88:	e0bffe17 	ldw	r2,-8(fp)
 909df8c:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 909df90:	e13ffe17 	ldw	r4,-8(fp)
 909df94:	01400044 	movi	r5,1
 909df98:	018002c4 	movi	r6,11
 909df9c:	01c00044 	movi	r7,1
 909dfa0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dfa4:	1007883a 	mov	r3,r2
 909dfa8:	e0bffe17 	ldw	r2,-8(fp)
 909dfac:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 909dfb0:	e13ffe17 	ldw	r4,-8(fp)
 909dfb4:	01400284 	movi	r5,10
 909dfb8:	018002c4 	movi	r6,11
 909dfbc:	01c00044 	movi	r7,1
 909dfc0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dfc4:	1007883a 	mov	r3,r2
 909dfc8:	e0bffe17 	ldw	r2,-8(fp)
 909dfcc:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 909dfd0:	e13ffe17 	ldw	r4,-8(fp)
 909dfd4:	01400284 	movi	r5,10
 909dfd8:	01800284 	movi	r6,10
 909dfdc:	01c00044 	movi	r7,1
 909dfe0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909dfe4:	1007883a 	mov	r3,r2
 909dfe8:	e0bffe17 	ldw	r2,-8(fp)
 909dfec:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 909dff0:	e13ffe17 	ldw	r4,-8(fp)
 909dff4:	01400144 	movi	r5,5
 909dff8:	01800244 	movi	r6,9
 909dffc:	01c00044 	movi	r7,1
 909e000:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e004:	1007883a 	mov	r3,r2
 909e008:	e0bffe17 	ldw	r2,-8(fp)
 909e00c:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 909e010:	e13ffe17 	ldw	r4,-8(fp)
 909e014:	01400144 	movi	r5,5
 909e018:	01800204 	movi	r6,8
 909e01c:	01c00044 	movi	r7,1
 909e020:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e024:	1007883a 	mov	r3,r2
 909e028:	e0bffe17 	ldw	r2,-8(fp)
 909e02c:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 909e030:	e13ffe17 	ldw	r4,-8(fp)
 909e034:	01400144 	movi	r5,5
 909e038:	018001c4 	movi	r6,7
 909e03c:	01c00044 	movi	r7,1
 909e040:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e044:	1007883a 	mov	r3,r2
 909e048:	e0bffe17 	ldw	r2,-8(fp)
 909e04c:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 909e050:	e13ffe17 	ldw	r4,-8(fp)
 909e054:	01400144 	movi	r5,5
 909e058:	01800184 	movi	r6,6
 909e05c:	01c00044 	movi	r7,1
 909e060:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e064:	1007883a 	mov	r3,r2
 909e068:	e0bffe17 	ldw	r2,-8(fp)
 909e06c:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 909e070:	e13ffe17 	ldw	r4,-8(fp)
 909e074:	01400144 	movi	r5,5
 909e078:	01800144 	movi	r6,5
 909e07c:	01c00044 	movi	r7,1
 909e080:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e084:	1007883a 	mov	r3,r2
 909e088:	e0bffe17 	ldw	r2,-8(fp)
 909e08c:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 909e090:	e17ffa47 	ldb	r5,-23(fp)
 909e094:	e1bffa87 	ldb	r6,-22(fp)
 909e098:	01024374 	movhi	r4,2317
 909e09c:	2138b604 	addi	r4,r4,-7464
 909e0a0:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 909e0a4:	e0bffe17 	ldw	r2,-8(fp)
 909e0a8:	10800043 	ldbu	r2,1(r2)
 909e0ac:	11403fcc 	andi	r5,r2,255
 909e0b0:	01024374 	movhi	r4,2317
 909e0b4:	2138c104 	addi	r4,r4,-7420
 909e0b8:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 909e0bc:	e0bffe17 	ldw	r2,-8(fp)
 909e0c0:	10800083 	ldbu	r2,2(r2)
 909e0c4:	11403fcc 	andi	r5,r2,255
 909e0c8:	01024374 	movhi	r4,2317
 909e0cc:	2138cb04 	addi	r4,r4,-7380
 909e0d0:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 909e0d4:	e0bffe17 	ldw	r2,-8(fp)
 909e0d8:	108000c3 	ldbu	r2,3(r2)
 909e0dc:	11403fcc 	andi	r5,r2,255
 909e0e0:	01024374 	movhi	r4,2317
 909e0e4:	2138d504 	addi	r4,r4,-7340
 909e0e8:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 909e0ec:	e0bffe17 	ldw	r2,-8(fp)
 909e0f0:	10800103 	ldbu	r2,4(r2)
 909e0f4:	11403fcc 	andi	r5,r2,255
 909e0f8:	01024374 	movhi	r4,2317
 909e0fc:	2138df04 	addi	r4,r4,-7300
 909e100:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 909e104:	e0bffe17 	ldw	r2,-8(fp)
 909e108:	10800143 	ldbu	r2,5(r2)
 909e10c:	11403fcc 	andi	r5,r2,255
 909e110:	01024374 	movhi	r4,2317
 909e114:	2138e904 	addi	r4,r4,-7260
 909e118:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 909e11c:	e0bffe17 	ldw	r2,-8(fp)
 909e120:	10800183 	ldbu	r2,6(r2)
 909e124:	11403fcc 	andi	r5,r2,255
 909e128:	01024374 	movhi	r4,2317
 909e12c:	2138f304 	addi	r4,r4,-7220
 909e130:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 909e134:	e0bffe17 	ldw	r2,-8(fp)
 909e138:	108001c3 	ldbu	r2,7(r2)
 909e13c:	11403fcc 	andi	r5,r2,255
 909e140:	01024374 	movhi	r4,2317
 909e144:	2138fd04 	addi	r4,r4,-7180
 909e148:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 909e14c:	e0bffe17 	ldw	r2,-8(fp)
 909e150:	10800203 	ldbu	r2,8(r2)
 909e154:	11403fcc 	andi	r5,r2,255
 909e158:	01024374 	movhi	r4,2317
 909e15c:	21390704 	addi	r4,r4,-7140
 909e160:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 909e164:	e0bffe17 	ldw	r2,-8(fp)
 909e168:	10800243 	ldbu	r2,9(r2)
 909e16c:	11403fcc 	andi	r5,r2,255
 909e170:	01024374 	movhi	r4,2317
 909e174:	21391104 	addi	r4,r4,-7100
 909e178:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 909e17c:	e0bffe17 	ldw	r2,-8(fp)
 909e180:	10800283 	ldbu	r2,10(r2)
 909e184:	11403fcc 	andi	r5,r2,255
 909e188:	01024374 	movhi	r4,2317
 909e18c:	21391b04 	addi	r4,r4,-7060
 909e190:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 909e194:	e0bffe17 	ldw	r2,-8(fp)
 909e198:	108002c3 	ldbu	r2,11(r2)
 909e19c:	11403fcc 	andi	r5,r2,255
 909e1a0:	01024374 	movhi	r4,2317
 909e1a4:	21392504 	addi	r4,r4,-7020
 909e1a8:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "\n");
 909e1ac:	01024374 	movhi	r4,2317
 909e1b0:	21378b04 	addi	r4,r4,-8660
 909e1b4:	909a0b80 	call	909a0b8 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 909e1b8:	e17ffa47 	ldb	r5,-23(fp)
 909e1bc:	e1bffa87 	ldb	r6,-22(fp)
 909e1c0:	01024374 	movhi	r4,2317
 909e1c4:	21392f04 	addi	r4,r4,-6980
 909e1c8:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 909e1cc:	e0bffe17 	ldw	r2,-8(fp)
 909e1d0:	10800303 	ldbu	r2,12(r2)
 909e1d4:	11403fcc 	andi	r5,r2,255
 909e1d8:	01024374 	movhi	r4,2317
 909e1dc:	2138d504 	addi	r4,r4,-7340
 909e1e0:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 909e1e4:	e0bffe17 	ldw	r2,-8(fp)
 909e1e8:	10800343 	ldbu	r2,13(r2)
 909e1ec:	11403fcc 	andi	r5,r2,255
 909e1f0:	01024374 	movhi	r4,2317
 909e1f4:	2138df04 	addi	r4,r4,-7300
 909e1f8:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 909e1fc:	e0bffe17 	ldw	r2,-8(fp)
 909e200:	10800383 	ldbu	r2,14(r2)
 909e204:	11403fcc 	andi	r5,r2,255
 909e208:	01024374 	movhi	r4,2317
 909e20c:	2138e904 	addi	r4,r4,-7260
 909e210:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 909e214:	e0bffe17 	ldw	r2,-8(fp)
 909e218:	108003c3 	ldbu	r2,15(r2)
 909e21c:	11403fcc 	andi	r5,r2,255
 909e220:	01024374 	movhi	r4,2317
 909e224:	21393c04 	addi	r4,r4,-6928
 909e228:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 909e22c:	e0bffe17 	ldw	r2,-8(fp)
 909e230:	10800403 	ldbu	r2,16(r2)
 909e234:	11403fcc 	andi	r5,r2,255
 909e238:	01024374 	movhi	r4,2317
 909e23c:	21394604 	addi	r4,r4,-6888
 909e240:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 909e244:	e0bffe17 	ldw	r2,-8(fp)
 909e248:	10800443 	ldbu	r2,17(r2)
 909e24c:	11403fcc 	andi	r5,r2,255
 909e250:	01024374 	movhi	r4,2317
 909e254:	21395004 	addi	r4,r4,-6848
 909e258:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 909e25c:	e0bffe17 	ldw	r2,-8(fp)
 909e260:	10800483 	ldbu	r2,18(r2)
 909e264:	11403fcc 	andi	r5,r2,255
 909e268:	01024374 	movhi	r4,2317
 909e26c:	21395a04 	addi	r4,r4,-6808
 909e270:	909a0b80 	call	909a0b8 <no_printf>
    tse_dprintf(6, "\n");
 909e274:	01024374 	movhi	r4,2317
 909e278:	21378b04 	addi	r4,r4,-8660
 909e27c:	909a0b80 	call	909a0b8 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909e280:	e17ffa03 	ldbu	r5,-24(fp)
 909e284:	e13ffe17 	ldw	r4,-8(fp)
 909e288:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 909e28c:	e0bffd17 	ldw	r2,-12(fp)
 909e290:	e0bfff15 	stw	r2,-4(fp)
 909e294:	e0bfff17 	ldw	r2,-4(fp)
    
}
 909e298:	e037883a 	mov	sp,fp
 909e29c:	dfc00117 	ldw	ra,4(sp)
 909e2a0:	df000017 	ldw	fp,0(sp)
 909e2a4:	dec00204 	addi	sp,sp,8
 909e2a8:	f800283a 	ret

0909e2ac <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 909e2ac:	defff704 	addi	sp,sp,-36
 909e2b0:	dfc00815 	stw	ra,32(sp)
 909e2b4:	df000715 	stw	fp,28(sp)
 909e2b8:	df000704 	addi	fp,sp,28
 909e2bc:	e13ffe15 	stw	r4,-8(fp)
 909e2c0:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909e2c4:	e0bffe17 	ldw	r2,-8(fp)
 909e2c8:	10800617 	ldw	r2,24(r2)
 909e2cc:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909e2d0:	e0bffc17 	ldw	r2,-16(fp)
 909e2d4:	10800317 	ldw	r2,12(r2)
 909e2d8:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e2dc:	e13ffc17 	ldw	r4,-16(fp)
 909e2e0:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909e2e4:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e2e8:	e13ffb17 	ldw	r4,-20(fp)
 909e2ec:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909e2f0:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909e2f4:	e13ffe17 	ldw	r4,-8(fp)
 909e2f8:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909e2fc:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909e300:	e0bffe17 	ldw	r2,-8(fp)
 909e304:	10800003 	ldbu	r2,0(r2)
 909e308:	11403fcc 	andi	r5,r2,255
 909e30c:	e13ffe17 	ldw	r4,-8(fp)
 909e310:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909e314:	e0bfff03 	ldbu	r2,-4(fp)
 909e318:	1005003a 	cmpeq	r2,r2,zero
 909e31c:	1000271e 	bne	r2,zero,909e3bc <alt_tse_phy_set_adv_1000+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 909e320:	e13ffe17 	ldw	r4,-8(fp)
 909e324:	014003c4 	movi	r5,15
 909e328:	01800344 	movi	r6,13
 909e32c:	01c00044 	movi	r7,1
 909e330:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e334:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 909e338:	e0bffd03 	ldbu	r2,-12(fp)
 909e33c:	d8800015 	stw	r2,0(sp)
 909e340:	e13ffe17 	ldw	r4,-8(fp)
 909e344:	01400244 	movi	r5,9
 909e348:	01800244 	movi	r6,9
 909e34c:	01c00044 	movi	r7,1
 909e350:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e354:	e17ffa47 	ldb	r5,-23(fp)
 909e358:	e1bffa87 	ldb	r6,-22(fp)
 909e35c:	e1fffd03 	ldbu	r7,-12(fp)
 909e360:	01024374 	movhi	r4,2317
 909e364:	21396404 	addi	r4,r4,-6768
 909e368:	909a0b80 	call	909a0b8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 909e36c:	e13ffe17 	ldw	r4,-8(fp)
 909e370:	014003c4 	movi	r5,15
 909e374:	01800304 	movi	r6,12
 909e378:	01c00044 	movi	r7,1
 909e37c:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e380:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 909e384:	e0bffd03 	ldbu	r2,-12(fp)
 909e388:	d8800015 	stw	r2,0(sp)
 909e38c:	e13ffe17 	ldw	r4,-8(fp)
 909e390:	01400244 	movi	r5,9
 909e394:	01800204 	movi	r6,8
 909e398:	01c00044 	movi	r7,1
 909e39c:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e3a0:	e17ffa47 	ldb	r5,-23(fp)
 909e3a4:	e1bffa87 	ldb	r6,-22(fp)
 909e3a8:	e1fffd03 	ldbu	r7,-12(fp)
 909e3ac:	01024374 	movhi	r4,2317
 909e3b0:	21397704 	addi	r4,r4,-6692
 909e3b4:	909a0b80 	call	909a0b8 <no_printf>
 909e3b8:	00001806 	br	909e41c <alt_tse_phy_set_adv_1000+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 909e3bc:	d8000015 	stw	zero,0(sp)
 909e3c0:	e13ffe17 	ldw	r4,-8(fp)
 909e3c4:	01400244 	movi	r5,9
 909e3c8:	01800244 	movi	r6,9
 909e3cc:	01c00044 	movi	r7,1
 909e3d0:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e3d4:	e17ffa47 	ldb	r5,-23(fp)
 909e3d8:	e1bffa87 	ldb	r6,-22(fp)
 909e3dc:	01024374 	movhi	r4,2317
 909e3e0:	21396404 	addi	r4,r4,-6768
 909e3e4:	000f883a 	mov	r7,zero
 909e3e8:	909a0b80 	call	909a0b8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 909e3ec:	d8000015 	stw	zero,0(sp)
 909e3f0:	e13ffe17 	ldw	r4,-8(fp)
 909e3f4:	01400244 	movi	r5,9
 909e3f8:	01800204 	movi	r6,8
 909e3fc:	01c00044 	movi	r7,1
 909e400:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e404:	e17ffa47 	ldb	r5,-23(fp)
 909e408:	e1bffa87 	ldb	r6,-22(fp)
 909e40c:	01024374 	movhi	r4,2317
 909e410:	21398a04 	addi	r4,r4,-6616
 909e414:	000f883a 	mov	r7,zero
 909e418:	909a0b80 	call	909a0b8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 909e41c:	e17ffa03 	ldbu	r5,-24(fp)
 909e420:	e13ffe17 	ldw	r4,-8(fp)
 909e424:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 909e428:	0005883a 	mov	r2,zero
}
 909e42c:	e037883a 	mov	sp,fp
 909e430:	dfc00117 	ldw	ra,4(sp)
 909e434:	df000017 	ldw	fp,0(sp)
 909e438:	dec00204 	addi	sp,sp,8
 909e43c:	f800283a 	ret

0909e440 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 909e440:	defff704 	addi	sp,sp,-36
 909e444:	dfc00815 	stw	ra,32(sp)
 909e448:	df000715 	stw	fp,28(sp)
 909e44c:	df000704 	addi	fp,sp,28
 909e450:	e13ffe15 	stw	r4,-8(fp)
 909e454:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909e458:	e0bffe17 	ldw	r2,-8(fp)
 909e45c:	10800617 	ldw	r2,24(r2)
 909e460:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909e464:	e0bffc17 	ldw	r2,-16(fp)
 909e468:	10800317 	ldw	r2,12(r2)
 909e46c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e470:	e13ffc17 	ldw	r4,-16(fp)
 909e474:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909e478:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e47c:	e13ffb17 	ldw	r4,-20(fp)
 909e480:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909e484:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909e488:	e13ffe17 	ldw	r4,-8(fp)
 909e48c:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909e490:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909e494:	e0bffe17 	ldw	r2,-8(fp)
 909e498:	10800003 	ldbu	r2,0(r2)
 909e49c:	11403fcc 	andi	r5,r2,255
 909e4a0:	e13ffe17 	ldw	r4,-8(fp)
 909e4a4:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909e4a8:	e0bfff03 	ldbu	r2,-4(fp)
 909e4ac:	1005003a 	cmpeq	r2,r2,zero
 909e4b0:	10003a1e 	bne	r2,zero,909e59c <alt_tse_phy_set_adv_100+0x15c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 909e4b4:	e13ffe17 	ldw	r4,-8(fp)
 909e4b8:	01400044 	movi	r5,1
 909e4bc:	018003c4 	movi	r6,15
 909e4c0:	01c00044 	movi	r7,1
 909e4c4:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e4c8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 909e4cc:	e0bffd03 	ldbu	r2,-12(fp)
 909e4d0:	d8800015 	stw	r2,0(sp)
 909e4d4:	e13ffe17 	ldw	r4,-8(fp)
 909e4d8:	01400104 	movi	r5,4
 909e4dc:	01800244 	movi	r6,9
 909e4e0:	01c00044 	movi	r7,1
 909e4e4:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 909e4e8:	e17ffa47 	ldb	r5,-23(fp)
 909e4ec:	e1bffa87 	ldb	r6,-22(fp)
 909e4f0:	e1fffd03 	ldbu	r7,-12(fp)
 909e4f4:	01024374 	movhi	r4,2317
 909e4f8:	21399c04 	addi	r4,r4,-6544
 909e4fc:	909a0b80 	call	909a0b8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 909e500:	e13ffe17 	ldw	r4,-8(fp)
 909e504:	01400044 	movi	r5,1
 909e508:	01800384 	movi	r6,14
 909e50c:	01c00044 	movi	r7,1
 909e510:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e514:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 909e518:	e0bffd03 	ldbu	r2,-12(fp)
 909e51c:	d8800015 	stw	r2,0(sp)
 909e520:	e13ffe17 	ldw	r4,-8(fp)
 909e524:	01400104 	movi	r5,4
 909e528:	01800204 	movi	r6,8
 909e52c:	01c00044 	movi	r7,1
 909e530:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e534:	e17ffa47 	ldb	r5,-23(fp)
 909e538:	e1bffa87 	ldb	r6,-22(fp)
 909e53c:	e1fffd03 	ldbu	r7,-12(fp)
 909e540:	01024374 	movhi	r4,2317
 909e544:	2139ac04 	addi	r4,r4,-6480
 909e548:	909a0b80 	call	909a0b8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 909e54c:	e13ffe17 	ldw	r4,-8(fp)
 909e550:	01400044 	movi	r5,1
 909e554:	01800344 	movi	r6,13
 909e558:	01c00044 	movi	r7,1
 909e55c:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e560:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 909e564:	e0bffd03 	ldbu	r2,-12(fp)
 909e568:	d8800015 	stw	r2,0(sp)
 909e56c:	e13ffe17 	ldw	r4,-8(fp)
 909e570:	01400104 	movi	r5,4
 909e574:	018001c4 	movi	r6,7
 909e578:	01c00044 	movi	r7,1
 909e57c:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e580:	e17ffa47 	ldb	r5,-23(fp)
 909e584:	e1bffa87 	ldb	r6,-22(fp)
 909e588:	e1fffd03 	ldbu	r7,-12(fp)
 909e58c:	01024374 	movhi	r4,2317
 909e590:	2139bf04 	addi	r4,r4,-6404
 909e594:	909a0b80 	call	909a0b8 <no_printf>
 909e598:	00002406 	br	909e62c <alt_tse_phy_set_adv_100+0x1ec>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 909e59c:	d8000015 	stw	zero,0(sp)
 909e5a0:	e13ffe17 	ldw	r4,-8(fp)
 909e5a4:	01400104 	movi	r5,4
 909e5a8:	01800244 	movi	r6,9
 909e5ac:	01c00044 	movi	r7,1
 909e5b0:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 909e5b4:	e17ffa47 	ldb	r5,-23(fp)
 909e5b8:	e1bffa87 	ldb	r6,-22(fp)
 909e5bc:	01024374 	movhi	r4,2317
 909e5c0:	21399c04 	addi	r4,r4,-6544
 909e5c4:	000f883a 	mov	r7,zero
 909e5c8:	909a0b80 	call	909a0b8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 909e5cc:	d8000015 	stw	zero,0(sp)
 909e5d0:	e13ffe17 	ldw	r4,-8(fp)
 909e5d4:	01400104 	movi	r5,4
 909e5d8:	01800204 	movi	r6,8
 909e5dc:	01c00044 	movi	r7,1
 909e5e0:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e5e4:	e17ffa47 	ldb	r5,-23(fp)
 909e5e8:	e1bffa87 	ldb	r6,-22(fp)
 909e5ec:	01024374 	movhi	r4,2317
 909e5f0:	2139ac04 	addi	r4,r4,-6480
 909e5f4:	000f883a 	mov	r7,zero
 909e5f8:	909a0b80 	call	909a0b8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 909e5fc:	d8000015 	stw	zero,0(sp)
 909e600:	e13ffe17 	ldw	r4,-8(fp)
 909e604:	01400104 	movi	r5,4
 909e608:	018001c4 	movi	r6,7
 909e60c:	01c00044 	movi	r7,1
 909e610:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e614:	e17ffa47 	ldb	r5,-23(fp)
 909e618:	e1bffa87 	ldb	r6,-22(fp)
 909e61c:	01024374 	movhi	r4,2317
 909e620:	2139bf04 	addi	r4,r4,-6404
 909e624:	000f883a 	mov	r7,zero
 909e628:	909a0b80 	call	909a0b8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 909e62c:	e17ffa03 	ldbu	r5,-24(fp)
 909e630:	e13ffe17 	ldw	r4,-8(fp)
 909e634:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 909e638:	0005883a 	mov	r2,zero
}
 909e63c:	e037883a 	mov	sp,fp
 909e640:	dfc00117 	ldw	ra,4(sp)
 909e644:	df000017 	ldw	fp,0(sp)
 909e648:	dec00204 	addi	sp,sp,8
 909e64c:	f800283a 	ret

0909e650 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 909e650:	defff504 	addi	sp,sp,-44
 909e654:	dfc00a15 	stw	ra,40(sp)
 909e658:	df000915 	stw	fp,36(sp)
 909e65c:	df000904 	addi	fp,sp,36
 909e660:	e13ffe15 	stw	r4,-8(fp)
 909e664:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909e668:	e0bffe17 	ldw	r2,-8(fp)
 909e66c:	10800617 	ldw	r2,24(r2)
 909e670:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909e674:	e0bffc17 	ldw	r2,-16(fp)
 909e678:	10800317 	ldw	r2,12(r2)
 909e67c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e680:	e13ffc17 	ldw	r4,-16(fp)
 909e684:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909e688:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e68c:	e13ffb17 	ldw	r4,-20(fp)
 909e690:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909e694:	e0bff915 	stw	r2,-28(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909e698:	e13ffe17 	ldw	r4,-8(fp)
 909e69c:	909c3f80 	call	909c3f8 <alt_tse_phy_rd_mdio_addr>
 909e6a0:	e0bff815 	stw	r2,-32(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909e6a4:	e0bffe17 	ldw	r2,-8(fp)
 909e6a8:	10800003 	ldbu	r2,0(r2)
 909e6ac:	11403fcc 	andi	r5,r2,255
 909e6b0:	e13ffe17 	ldw	r4,-8(fp)
 909e6b4:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909e6b8:	e0bfff03 	ldbu	r2,-4(fp)
 909e6bc:	1005003a 	cmpeq	r2,r2,zero
 909e6c0:	1000271e 	bne	r2,zero,909e760 <alt_tse_phy_set_adv_10+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 909e6c4:	e13ffe17 	ldw	r4,-8(fp)
 909e6c8:	01400044 	movi	r5,1
 909e6cc:	01800304 	movi	r6,12
 909e6d0:	01c00044 	movi	r7,1
 909e6d4:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e6d8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 909e6dc:	e0bffd03 	ldbu	r2,-12(fp)
 909e6e0:	d8800015 	stw	r2,0(sp)
 909e6e4:	e13ffe17 	ldw	r4,-8(fp)
 909e6e8:	01400104 	movi	r5,4
 909e6ec:	01800184 	movi	r6,6
 909e6f0:	01c00044 	movi	r7,1
 909e6f4:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e6f8:	e1fffd03 	ldbu	r7,-12(fp)
 909e6fc:	01024374 	movhi	r4,2317
 909e700:	2139d204 	addi	r4,r4,-6328
 909e704:	e17ff917 	ldw	r5,-28(fp)
 909e708:	e1bffa17 	ldw	r6,-24(fp)
 909e70c:	909a0b80 	call	909a0b8 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 909e710:	e13ffe17 	ldw	r4,-8(fp)
 909e714:	01400044 	movi	r5,1
 909e718:	018002c4 	movi	r6,11
 909e71c:	01c00044 	movi	r7,1
 909e720:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909e724:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 909e728:	e0bffd03 	ldbu	r2,-12(fp)
 909e72c:	d8800015 	stw	r2,0(sp)
 909e730:	e13ffe17 	ldw	r4,-8(fp)
 909e734:	01400104 	movi	r5,4
 909e738:	01800144 	movi	r6,5
 909e73c:	01c00044 	movi	r7,1
 909e740:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909e744:	e1fffd03 	ldbu	r7,-12(fp)
 909e748:	01024374 	movhi	r4,2317
 909e74c:	2139e504 	addi	r4,r4,-6252
 909e750:	e17ff917 	ldw	r5,-28(fp)
 909e754:	e1bffa17 	ldw	r6,-24(fp)
 909e758:	909a0b80 	call	909a0b8 <no_printf>
 909e75c:	00001806 	br	909e7c0 <alt_tse_phy_set_adv_10+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 909e760:	d8000015 	stw	zero,0(sp)
 909e764:	e13ffe17 	ldw	r4,-8(fp)
 909e768:	01400104 	movi	r5,4
 909e76c:	01800184 	movi	r6,6
 909e770:	01c00044 	movi	r7,1
 909e774:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e778:	01024374 	movhi	r4,2317
 909e77c:	2139d204 	addi	r4,r4,-6328
 909e780:	e17ff917 	ldw	r5,-28(fp)
 909e784:	e1bffa17 	ldw	r6,-24(fp)
 909e788:	000f883a 	mov	r7,zero
 909e78c:	909a0b80 	call	909a0b8 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 909e790:	d8000015 	stw	zero,0(sp)
 909e794:	e13ffe17 	ldw	r4,-8(fp)
 909e798:	01400104 	movi	r5,4
 909e79c:	01800144 	movi	r6,5
 909e7a0:	01c00044 	movi	r7,1
 909e7a4:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909e7a8:	01024374 	movhi	r4,2317
 909e7ac:	2139e504 	addi	r4,r4,-6252
 909e7b0:	e17ff917 	ldw	r5,-28(fp)
 909e7b4:	e1bffa17 	ldw	r6,-24(fp)
 909e7b8:	000f883a 	mov	r7,zero
 909e7bc:	909a0b80 	call	909a0b8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909e7c0:	e0bff817 	ldw	r2,-32(fp)
 909e7c4:	11403fcc 	andi	r5,r2,255
 909e7c8:	e13ffe17 	ldw	r4,-8(fp)
 909e7cc:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 909e7d0:	0005883a 	mov	r2,zero
}
 909e7d4:	e037883a 	mov	sp,fp
 909e7d8:	dfc00117 	ldw	ra,4(sp)
 909e7dc:	df000017 	ldw	fp,0(sp)
 909e7e0:	dec00204 	addi	sp,sp,8
 909e7e4:	f800283a 	ret

0909e7e8 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 909e7e8:	defff604 	addi	sp,sp,-40
 909e7ec:	dfc00915 	stw	ra,36(sp)
 909e7f0:	df000815 	stw	fp,32(sp)
 909e7f4:	df000804 	addi	fp,sp,32
 909e7f8:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 909e7fc:	00800044 	movi	r2,1
 909e800:	e0bffd85 	stb	r2,-10(fp)
	alt_u8 common_100 = 1;
 909e804:	00800044 	movi	r2,1
 909e808:	e0bffd45 	stb	r2,-11(fp)
	alt_u8 common_10 = 1;
 909e80c:	00800044 	movi	r2,1
 909e810:	e0bffd05 	stb	r2,-12(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 909e814:	00800044 	movi	r2,1
 909e818:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 909e81c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_phy_info *pphy = 0;
 909e820:	e03ff915 	stw	zero,-28(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e824:	e13fff17 	ldw	r4,-4(fp)
 909e828:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909e82c:	e0bff805 	stb	r2,-32(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 909e830:	e03ffe15 	stw	zero,-8(fp)
 909e834:	00001d06 	br	909e8ac <alt_tse_phy_get_common_speed+0xc4>
        pmac_info = pmac_group->pmac_info[i];
 909e838:	e0bffe17 	ldw	r2,-8(fp)
 909e83c:	e0ffff17 	ldw	r3,-4(fp)
 909e840:	1085883a 	add	r2,r2,r2
 909e844:	1085883a 	add	r2,r2,r2
 909e848:	10c5883a 	add	r2,r2,r3
 909e84c:	10800104 	addi	r2,r2,4
 909e850:	10800017 	ldw	r2,0(r2)
 909e854:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 909e858:	e0bffa17 	ldw	r2,-24(fp)
 909e85c:	10800117 	ldw	r2,4(r2)
 909e860:	e0bff915 	stw	r2,-28(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 909e864:	e0bff917 	ldw	r2,-28(fp)
 909e868:	1005003a 	cmpeq	r2,r2,zero
 909e86c:	1000091e 	bne	r2,zero,909e894 <alt_tse_phy_get_common_speed+0xac>
            alt_tse_phy_set_adv_1000(pphy, 1);
 909e870:	e13ff917 	ldw	r4,-28(fp)
 909e874:	01400044 	movi	r5,1
 909e878:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909e87c:	e13ff917 	ldw	r4,-28(fp)
 909e880:	01400044 	movi	r5,1
 909e884:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909e888:	e13ff917 	ldw	r4,-28(fp)
 909e88c:	01400044 	movi	r5,1
 909e890:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 909e894:	01024374 	movhi	r4,2317
 909e898:	21378b04 	addi	r4,r4,-8660
 909e89c:	909a0b80 	call	909a0b8 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 909e8a0:	e0bffe17 	ldw	r2,-8(fp)
 909e8a4:	10800044 	addi	r2,r2,1
 909e8a8:	e0bffe15 	stw	r2,-8(fp)
 909e8ac:	e0bfff17 	ldw	r2,-4(fp)
 909e8b0:	10800003 	ldbu	r2,0(r2)
 909e8b4:	10c03fcc 	andi	r3,r2,255
 909e8b8:	e0bffe17 	ldw	r2,-8(fp)
 909e8bc:	10ffde16 	blt	r2,r3,909e838 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909e8c0:	e03ffe15 	stw	zero,-8(fp)
 909e8c4:	00005406 	br	909ea18 <alt_tse_phy_get_common_speed+0x230>

        pmac_info = pmac_group->pmac_info[i];
 909e8c8:	e0bffe17 	ldw	r2,-8(fp)
 909e8cc:	e0ffff17 	ldw	r3,-4(fp)
 909e8d0:	1085883a 	add	r2,r2,r2
 909e8d4:	1085883a 	add	r2,r2,r2
 909e8d8:	10c5883a 	add	r2,r2,r3
 909e8dc:	10800104 	addi	r2,r2,4
 909e8e0:	10800017 	ldw	r2,0(r2)
 909e8e4:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 909e8e8:	e0bffa17 	ldw	r2,-24(fp)
 909e8ec:	10800117 	ldw	r2,4(r2)
 909e8f0:	e0bff915 	stw	r2,-28(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 909e8f4:	e0bff917 	ldw	r2,-28(fp)
 909e8f8:	1005003a 	cmpeq	r2,r2,zero
 909e8fc:	1000431e 	bne	r2,zero,909ea0c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 909e900:	e13ff917 	ldw	r4,-28(fp)
 909e904:	909dd6c0 	call	909dd6c <alt_tse_phy_get_cap>
 909e908:	1004c03a 	cmpne	r2,r2,zero
 909e90c:	10003f1e 	bne	r2,zero,909ea0c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 909e910:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 909e914:	e0bffa17 	ldw	r2,-24(fp)
 909e918:	10800003 	ldbu	r2,0(r2)
 909e91c:	10803fcc 	andi	r2,r2,255
 909e920:	10800058 	cmpnei	r2,r2,1
 909e924:	1000021e 	bne	r2,zero,909e930 <alt_tse_phy_get_common_speed+0x148>
            common_1000 = 0;
 909e928:	e03ffd85 	stb	zero,-10(fp)
 909e92c:	00000706 	br	909e94c <alt_tse_phy_get_common_speed+0x164>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 909e930:	e0bffa17 	ldw	r2,-24(fp)
 909e934:	10800003 	ldbu	r2,0(r2)
 909e938:	10803fcc 	andi	r2,r2,255
 909e93c:	10800098 	cmpnei	r2,r2,2
 909e940:	1000021e 	bne	r2,zero,909e94c <alt_tse_phy_get_common_speed+0x164>
            common_100 = 0;
 909e944:	e03ffd45 	stb	zero,-11(fp)
            common_10 = 0;            
 909e948:	e03ffd05 	stb	zero,-12(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 909e94c:	e0bff917 	ldw	r2,-28(fp)
 909e950:	10c000c3 	ldbu	r3,3(r2)
 909e954:	e0bff917 	ldw	r2,-28(fp)
 909e958:	10800303 	ldbu	r2,12(r2)
 909e95c:	1884703a 	and	r2,r3,r2
 909e960:	1007883a 	mov	r3,r2
 909e964:	e0bffd83 	ldbu	r2,-10(fp)
 909e968:	10c4703a 	and	r2,r2,r3
 909e96c:	e0bffd85 	stb	r2,-10(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 909e970:	e0bff917 	ldw	r2,-28(fp)
 909e974:	10c00183 	ldbu	r3,6(r2)
 909e978:	e0bff917 	ldw	r2,-28(fp)
 909e97c:	108003c3 	ldbu	r2,15(r2)
 909e980:	1884703a 	and	r2,r3,r2
 909e984:	1009883a 	mov	r4,r2
 909e988:	e0bff917 	ldw	r2,-28(fp)
 909e98c:	10c001c3 	ldbu	r3,7(r2)
 909e990:	e0bff917 	ldw	r2,-28(fp)
 909e994:	10800403 	ldbu	r2,16(r2)
 909e998:	1884703a 	and	r2,r3,r2
 909e99c:	2084b03a 	or	r2,r4,r2
 909e9a0:	1009883a 	mov	r4,r2
 909e9a4:	e0bff917 	ldw	r2,-28(fp)
 909e9a8:	10c00143 	ldbu	r3,5(r2)
 909e9ac:	e0bff917 	ldw	r2,-28(fp)
 909e9b0:	10800383 	ldbu	r2,14(r2)
 909e9b4:	1884703a 	and	r2,r3,r2
 909e9b8:	2084b03a 	or	r2,r4,r2
 909e9bc:	1007883a 	mov	r3,r2
 909e9c0:	e0bffd43 	ldbu	r2,-11(fp)
 909e9c4:	10c4703a 	and	r2,r2,r3
 909e9c8:	e0bffd45 	stb	r2,-11(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 909e9cc:	e0bff917 	ldw	r2,-28(fp)
 909e9d0:	10c00283 	ldbu	r3,10(r2)
 909e9d4:	e0bff917 	ldw	r2,-28(fp)
 909e9d8:	10800443 	ldbu	r2,17(r2)
 909e9dc:	1884703a 	and	r2,r3,r2
 909e9e0:	1009883a 	mov	r4,r2
 909e9e4:	e0bff917 	ldw	r2,-28(fp)
 909e9e8:	10c002c3 	ldbu	r3,11(r2)
 909e9ec:	e0bff917 	ldw	r2,-28(fp)
 909e9f0:	10800483 	ldbu	r2,18(r2)
 909e9f4:	1884703a 	and	r2,r3,r2
 909e9f8:	2084b03a 	or	r2,r4,r2
 909e9fc:	1007883a 	mov	r3,r2
 909ea00:	e0bffd03 	ldbu	r2,-12(fp)
 909ea04:	10c4703a 	and	r2,r2,r3
 909ea08:	e0bffd05 	stb	r2,-12(fp)
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909ea0c:	e0bffe17 	ldw	r2,-8(fp)
 909ea10:	10800044 	addi	r2,r2,1
 909ea14:	e0bffe15 	stw	r2,-8(fp)
 909ea18:	e0bfff17 	ldw	r2,-4(fp)
 909ea1c:	10800003 	ldbu	r2,0(r2)
 909ea20:	10c03fcc 	andi	r3,r2,255
 909ea24:	e0bffe17 	ldw	r2,-8(fp)
 909ea28:	10ffa716 	blt	r2,r3,909e8c8 <alt_tse_phy_get_common_speed+0xe0>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 909ea2c:	e0bffb03 	ldbu	r2,-20(fp)
 909ea30:	10800058 	cmpnei	r2,r2,1
 909ea34:	1000071e 	bne	r2,zero,909ea54 <alt_tse_phy_get_common_speed+0x26c>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 909ea38:	00bfffc4 	movi	r2,-1
 909ea3c:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 909ea40:	e17ff807 	ldb	r5,-32(fp)
 909ea44:	01024374 	movhi	r4,2317
 909ea48:	2139f804 	addi	r4,r4,-6176
 909ea4c:	90825100 	call	9082510 <printf>
 909ea50:	00002606 	br	909eaec <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_1000) {
 909ea54:	e0bffd83 	ldbu	r2,-10(fp)
 909ea58:	1005003a 	cmpeq	r2,r2,zero
 909ea5c:	1000081e 	bne	r2,zero,909ea80 <alt_tse_phy_get_common_speed+0x298>
        common_speed = TSE_PHY_SPEED_1000;
 909ea60:	00800084 	movi	r2,2
 909ea64:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 909ea68:	e17ff807 	ldb	r5,-32(fp)
 909ea6c:	01024374 	movhi	r4,2317
 909ea70:	213a0a04 	addi	r4,r4,-6104
 909ea74:	0180fa04 	movi	r6,1000
 909ea78:	90825100 	call	9082510 <printf>
 909ea7c:	00001b06 	br	909eaec <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_100) {
 909ea80:	e0bffd43 	ldbu	r2,-11(fp)
 909ea84:	1005003a 	cmpeq	r2,r2,zero
 909ea88:	1000081e 	bne	r2,zero,909eaac <alt_tse_phy_get_common_speed+0x2c4>
        common_speed = TSE_PHY_SPEED_100;
 909ea8c:	00800044 	movi	r2,1
 909ea90:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 909ea94:	e17ff807 	ldb	r5,-32(fp)
 909ea98:	01024374 	movhi	r4,2317
 909ea9c:	213a0a04 	addi	r4,r4,-6104
 909eaa0:	01801904 	movi	r6,100
 909eaa4:	90825100 	call	9082510 <printf>
 909eaa8:	00001006 	br	909eaec <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_10) {
 909eaac:	e0bffd03 	ldbu	r2,-12(fp)
 909eab0:	1005003a 	cmpeq	r2,r2,zero
 909eab4:	1000071e 	bne	r2,zero,909ead4 <alt_tse_phy_get_common_speed+0x2ec>
        common_speed = TSE_PHY_SPEED_10;
 909eab8:	e03ffc15 	stw	zero,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 909eabc:	e17ff807 	ldb	r5,-32(fp)
 909eac0:	01024374 	movhi	r4,2317
 909eac4:	213a0a04 	addi	r4,r4,-6104
 909eac8:	01800284 	movi	r6,10
 909eacc:	90825100 	call	9082510 <printf>
 909ead0:	00000606 	br	909eaec <alt_tse_phy_get_common_speed+0x304>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 909ead4:	00bfffc4 	movi	r2,-1
 909ead8:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 909eadc:	e17ff807 	ldb	r5,-32(fp)
 909eae0:	01024374 	movhi	r4,2317
 909eae4:	213a1704 	addi	r4,r4,-6052
 909eae8:	90825100 	call	9082510 <printf>

    return common_speed;
 909eaec:	e0bffc17 	ldw	r2,-16(fp)
}
 909eaf0:	e037883a 	mov	sp,fp
 909eaf4:	dfc00117 	ldw	ra,4(sp)
 909eaf8:	df000017 	ldw	fp,0(sp)
 909eafc:	dec00204 	addi	sp,sp,8
 909eb00:	f800283a 	ret

0909eb04 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 909eb04:	deffec04 	addi	sp,sp,-80
 909eb08:	dfc01315 	stw	ra,76(sp)
 909eb0c:	df001215 	stw	fp,72(sp)
 909eb10:	dc401115 	stw	r17,68(sp)
 909eb14:	dc001015 	stw	r16,64(sp)
 909eb18:	df001004 	addi	fp,sp,64
 909eb1c:	e13ff915 	stw	r4,-28(fp)
 909eb20:	e17ffa15 	stw	r5,-24(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 909eb24:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 909eb28:	e03ff515 	stw	zero,-44(fp)
    alt_tse_system_info *psys = 0;
 909eb2c:	e03ff415 	stw	zero,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909eb30:	e03ff345 	stb	zero,-51(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909eb34:	e13ff917 	ldw	r4,-28(fp)
 909eb38:	909b2800 	call	909b280 <alt_tse_get_mac_group_index>
 909eb3c:	e0bff305 	stb	r2,-52(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909eb40:	e0bff917 	ldw	r2,-28(fp)
 909eb44:	10800117 	ldw	r2,4(r2)
 909eb48:	10800217 	ldw	r2,8(r2)
 909eb4c:	10800017 	ldw	r2,0(r2)
 909eb50:	e0bff215 	stw	r2,-56(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909eb54:	e0bff217 	ldw	r2,-56(fp)
 909eb58:	10801004 	addi	r2,r2,64
 909eb5c:	10800037 	ldwio	r2,0(r2)
 909eb60:	e0bff115 	stw	r2,-60(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 909eb64:	e0bffa17 	ldw	r2,-24(fp)
 909eb68:	1004803a 	cmplt	r2,r2,zero
 909eb6c:	1000031e 	bne	r2,zero,909eb7c <alt_tse_phy_set_common_speed+0x78>
 909eb70:	e0bffa17 	ldw	r2,-24(fp)
 909eb74:	108000d0 	cmplti	r2,r2,3
 909eb78:	10000d1e 	bne	r2,zero,909ebb0 <alt_tse_phy_set_common_speed+0xac>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 909eb7c:	e17ff307 	ldb	r5,-52(fp)
 909eb80:	01024374 	movhi	r4,2317
 909eb84:	213a2404 	addi	r4,r4,-6000
 909eb88:	e1bffa17 	ldw	r6,-24(fp)
 909eb8c:	90825100 	call	9082510 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909eb90:	e0bff217 	ldw	r2,-56(fp)
 909eb94:	10801004 	addi	r2,r2,64
 909eb98:	1007883a 	mov	r3,r2
 909eb9c:	e0bff117 	ldw	r2,-60(fp)
 909eba0:	18800035 	stwio	r2,0(r3)
        return TSE_PHY_SPEED_NO_COMMON;
 909eba4:	00bfffc4 	movi	r2,-1
 909eba8:	e0bfff15 	stw	r2,-4(fp)
 909ebac:	00010606 	br	909efc8 <alt_tse_phy_set_common_speed+0x4c4>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909ebb0:	e03ff815 	stw	zero,-32(fp)
 909ebb4:	0000dd06 	br	909ef2c <alt_tse_phy_set_common_speed+0x428>
        pmac_info = pmac_group->pmac_info[i];
 909ebb8:	e0bff817 	ldw	r2,-32(fp)
 909ebbc:	e0fff917 	ldw	r3,-28(fp)
 909ebc0:	1085883a 	add	r2,r2,r2
 909ebc4:	1085883a 	add	r2,r2,r2
 909ebc8:	10c5883a 	add	r2,r2,r3
 909ebcc:	10800104 	addi	r2,r2,4
 909ebd0:	10800017 	ldw	r2,0(r2)
 909ebd4:	e0bff515 	stw	r2,-44(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909ebd8:	e13ff517 	ldw	r4,-44(fp)
 909ebdc:	909b3000 	call	909b300 <alt_tse_get_mac_info_index>
 909ebe0:	e0bff345 	stb	r2,-51(fp)

        pphy = pmac_info->pphy_info;
 909ebe4:	e0bff517 	ldw	r2,-44(fp)
 909ebe8:	10800117 	ldw	r2,4(r2)
 909ebec:	e0bff615 	stw	r2,-40(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 909ebf0:	e0bff617 	ldw	r2,-40(fp)
 909ebf4:	1005003a 	cmpeq	r2,r2,zero
 909ebf8:	1000c91e 	bne	r2,zero,909ef20 <alt_tse_phy_set_common_speed+0x41c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 909ebfc:	e0bff517 	ldw	r2,-44(fp)
 909ec00:	10800217 	ldw	r2,8(r2)
 909ec04:	e0bff415 	stw	r2,-48(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909ec08:	e0bff617 	ldw	r2,-40(fp)
 909ec0c:	10800003 	ldbu	r2,0(r2)
 909ec10:	11403fcc 	andi	r5,r2,255
 909ec14:	e13ff617 	ldw	r4,-40(fp)
 909ec18:	909c4400 	call	909c440 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 909ec1c:	e0bff617 	ldw	r2,-40(fp)
 909ec20:	108000c3 	ldbu	r2,3(r2)
 909ec24:	10803fcc 	andi	r2,r2,255
 909ec28:	1004c03a 	cmpne	r2,r2,zero
 909ec2c:	10000f1e 	bne	r2,zero,909ec6c <alt_tse_phy_set_common_speed+0x168>
 909ec30:	e0bff617 	ldw	r2,-40(fp)
 909ec34:	10800103 	ldbu	r2,4(r2)
 909ec38:	10803fcc 	andi	r2,r2,255
 909ec3c:	1004c03a 	cmpne	r2,r2,zero
 909ec40:	10000a1e 	bne	r2,zero,909ec6c <alt_tse_phy_set_common_speed+0x168>
 909ec44:	e0bff617 	ldw	r2,-40(fp)
 909ec48:	10800043 	ldbu	r2,1(r2)
 909ec4c:	10803fcc 	andi	r2,r2,255
 909ec50:	1004c03a 	cmpne	r2,r2,zero
 909ec54:	1000051e 	bne	r2,zero,909ec6c <alt_tse_phy_set_common_speed+0x168>
 909ec58:	e0bff617 	ldw	r2,-40(fp)
 909ec5c:	10800083 	ldbu	r2,2(r2)
 909ec60:	10803fcc 	andi	r2,r2,255
 909ec64:	1005003a 	cmpeq	r2,r2,zero
 909ec68:	1000031e 	bne	r2,zero,909ec78 <alt_tse_phy_set_common_speed+0x174>
 909ec6c:	00800044 	movi	r2,1
 909ec70:	e0bffe15 	stw	r2,-8(fp)
 909ec74:	00000106 	br	909ec7c <alt_tse_phy_set_common_speed+0x178>
 909ec78:	e03ffe15 	stw	zero,-8(fp)
 909ec7c:	e0bffe17 	ldw	r2,-8(fp)
 909ec80:	e0bff705 	stb	r2,-36(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 909ec84:	e0bff703 	ldbu	r2,-36(fp)
 909ec88:	1004c03a 	cmpne	r2,r2,zero
 909ec8c:	1000101e 	bne	r2,zero,909ecd0 <alt_tse_phy_set_common_speed+0x1cc>
 909ec90:	e0bffa17 	ldw	r2,-24(fp)
 909ec94:	10800098 	cmpnei	r2,r2,2
 909ec98:	10000d1e 	bne	r2,zero,909ecd0 <alt_tse_phy_set_common_speed+0x1cc>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 909ec9c:	e17ff307 	ldb	r5,-52(fp)
 909eca0:	e1bff347 	ldb	r6,-51(fp)
 909eca4:	01024374 	movhi	r4,2317
 909eca8:	213a3804 	addi	r4,r4,-5920
 909ecac:	90825100 	call	9082510 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909ecb0:	e0bff217 	ldw	r2,-56(fp)
 909ecb4:	10801004 	addi	r2,r2,64
 909ecb8:	1007883a 	mov	r3,r2
 909ecbc:	e0bff117 	ldw	r2,-60(fp)
 909ecc0:	18800035 	stwio	r2,0(r3)
            return TSE_PHY_SPEED_NO_COMMON;
 909ecc4:	00bfffc4 	movi	r2,-1
 909ecc8:	e0bfff15 	stw	r2,-4(fp)
 909eccc:	0000be06 	br	909efc8 <alt_tse_phy_set_common_speed+0x4c4>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909ecd0:	e13ff617 	ldw	r4,-40(fp)
 909ecd4:	01400044 	movi	r5,1
 909ecd8:	018000c4 	movi	r6,3
 909ecdc:	01c00044 	movi	r7,1
 909ece0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909ece4:	1004c03a 	cmpne	r2,r2,zero
 909ece8:	1000151e 	bne	r2,zero,909ed40 <alt_tse_phy_set_common_speed+0x23c>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 909ecec:	e0bff703 	ldbu	r2,-36(fp)
 909ecf0:	1005003a 	cmpeq	r2,r2,zero
 909ecf4:	1000091e 	bne	r2,zero,909ed1c <alt_tse_phy_set_common_speed+0x218>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 909ecf8:	e0bffa17 	ldw	r2,-24(fp)
 909ecfc:	1005d07a 	srai	r2,r2,1
 909ed00:	10bfffcc 	andi	r2,r2,65535
 909ed04:	d8800015 	stw	r2,0(sp)
 909ed08:	e13ff617 	ldw	r4,-40(fp)
 909ed0c:	000b883a 	mov	r5,zero
 909ed10:	01800184 	movi	r6,6
 909ed14:	01c00044 	movi	r7,1
 909ed18:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 909ed1c:	e0bffa17 	ldw	r2,-24(fp)
 909ed20:	10bfffcc 	andi	r2,r2,65535
 909ed24:	d8800015 	stw	r2,0(sp)
 909ed28:	e13ff617 	ldw	r4,-40(fp)
 909ed2c:	000b883a 	mov	r5,zero
 909ed30:	01800344 	movi	r6,13
 909ed34:	01c00044 	movi	r7,1
 909ed38:	909c4940 	call	909c494 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 909ed3c:	00007806 	br	909ef20 <alt_tse_phy_set_common_speed+0x41c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 909ed40:	e0bffa17 	ldw	r2,-24(fp)
 909ed44:	10800098 	cmpnei	r2,r2,2
 909ed48:	10000a1e 	bne	r2,zero,909ed74 <alt_tse_phy_set_common_speed+0x270>
            alt_tse_phy_set_adv_1000(pphy, 1);
 909ed4c:	e13ff617 	ldw	r4,-40(fp)
 909ed50:	01400044 	movi	r5,1
 909ed54:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909ed58:	e13ff617 	ldw	r4,-40(fp)
 909ed5c:	01400044 	movi	r5,1
 909ed60:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909ed64:	e13ff617 	ldw	r4,-40(fp)
 909ed68:	01400044 	movi	r5,1
 909ed6c:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
 909ed70:	00002306 	br	909ee00 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 909ed74:	e0bffa17 	ldw	r2,-24(fp)
 909ed78:	10800058 	cmpnei	r2,r2,1
 909ed7c:	10000a1e 	bne	r2,zero,909eda8 <alt_tse_phy_set_common_speed+0x2a4>
            alt_tse_phy_set_adv_1000(pphy, 0);
 909ed80:	e13ff617 	ldw	r4,-40(fp)
 909ed84:	000b883a 	mov	r5,zero
 909ed88:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909ed8c:	e13ff617 	ldw	r4,-40(fp)
 909ed90:	01400044 	movi	r5,1
 909ed94:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909ed98:	e13ff617 	ldw	r4,-40(fp)
 909ed9c:	01400044 	movi	r5,1
 909eda0:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
 909eda4:	00001606 	br	909ee00 <alt_tse_phy_set_common_speed+0x2fc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 909eda8:	e0bffa17 	ldw	r2,-24(fp)
 909edac:	1004c03a 	cmpne	r2,r2,zero
 909edb0:	10000a1e 	bne	r2,zero,909eddc <alt_tse_phy_set_common_speed+0x2d8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 909edb4:	e13ff617 	ldw	r4,-40(fp)
 909edb8:	000b883a 	mov	r5,zero
 909edbc:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 909edc0:	e13ff617 	ldw	r4,-40(fp)
 909edc4:	000b883a 	mov	r5,zero
 909edc8:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909edcc:	e13ff617 	ldw	r4,-40(fp)
 909edd0:	01400044 	movi	r5,1
 909edd4:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
 909edd8:	00000906 	br	909ee00 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 909eddc:	e13ff617 	ldw	r4,-40(fp)
 909ede0:	000b883a 	mov	r5,zero
 909ede4:	909e2ac0 	call	909e2ac <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 909ede8:	e13ff617 	ldw	r4,-40(fp)
 909edec:	000b883a 	mov	r5,zero
 909edf0:	909e4400 	call	909e440 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 909edf4:	e13ff617 	ldw	r4,-40(fp)
 909edf8:	000b883a 	mov	r5,zero
 909edfc:	909e6500 	call	909e650 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 909ee00:	e13ff617 	ldw	r4,-40(fp)
 909ee04:	01400044 	movi	r5,1
 909ee08:	01800144 	movi	r6,5
 909ee0c:	01c00044 	movi	r7,1
 909ee10:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909ee14:	10800058 	cmpnei	r2,r2,1
 909ee18:	1000341e 	bne	r2,zero,909eeec <alt_tse_phy_set_common_speed+0x3e8>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 909ee1c:	e0bff703 	ldbu	r2,-36(fp)
 909ee20:	1005003a 	cmpeq	r2,r2,zero
 909ee24:	10000d1e 	bne	r2,zero,909ee5c <alt_tse_phy_set_common_speed+0x358>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 909ee28:	e0bff617 	ldw	r2,-40(fp)
 909ee2c:	10800517 	ldw	r2,20(r2)
 909ee30:	10801583 	ldbu	r2,86(r2)
 909ee34:	11403fcc 	andi	r5,r2,255
 909ee38:	e0bff617 	ldw	r2,-40(fp)
 909ee3c:	10800517 	ldw	r2,20(r2)
 909ee40:	108015c3 	ldbu	r2,87(r2)
 909ee44:	11803fcc 	andi	r6,r2,255
 909ee48:	e13ff617 	ldw	r4,-40(fp)
 909ee4c:	01c00084 	movi	r7,2
 909ee50:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909ee54:	e0bff785 	stb	r2,-34(fp)
 909ee58:	00000c06 	br	909ee8c <alt_tse_phy_set_common_speed+0x388>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 909ee5c:	e0bff617 	ldw	r2,-40(fp)
 909ee60:	10800517 	ldw	r2,20(r2)
 909ee64:	10801583 	ldbu	r2,86(r2)
 909ee68:	11403fcc 	andi	r5,r2,255
 909ee6c:	e0bff617 	ldw	r2,-40(fp)
 909ee70:	10800517 	ldw	r2,20(r2)
 909ee74:	108015c3 	ldbu	r2,87(r2)
 909ee78:	11803fcc 	andi	r6,r2,255
 909ee7c:	e13ff617 	ldw	r4,-40(fp)
 909ee80:	01c00044 	movi	r7,1
 909ee84:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909ee88:	e0bff785 	stb	r2,-34(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 909ee8c:	e0fff783 	ldbu	r3,-34(fp)
 909ee90:	e0bffa17 	ldw	r2,-24(fp)
 909ee94:	18800426 	beq	r3,r2,909eea8 <alt_tse_phy_set_common_speed+0x3a4>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909ee98:	e13ff617 	ldw	r4,-40(fp)
 909ee9c:	01400134 	movhi	r5,4
 909eea0:	29742404 	addi	r5,r5,-12144
 909eea4:	909da780 	call	909da78 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 909eea8:	e0bff617 	ldw	r2,-40(fp)
 909eeac:	10800517 	ldw	r2,20(r2)
 909eeb0:	10801583 	ldbu	r2,86(r2)
 909eeb4:	11403fcc 	andi	r5,r2,255
 909eeb8:	e0bff617 	ldw	r2,-40(fp)
 909eebc:	10800517 	ldw	r2,20(r2)
 909eec0:	10801603 	ldbu	r2,88(r2)
 909eec4:	11803fcc 	andi	r6,r2,255
 909eec8:	e13ff617 	ldw	r4,-40(fp)
 909eecc:	01c00044 	movi	r7,1
 909eed0:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909eed4:	e0bff745 	stb	r2,-35(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 909eed8:	e0bff417 	ldw	r2,-48(fp)
 909eedc:	10800017 	ldw	r2,0(r2)
 909eee0:	1009883a 	mov	r4,r2
 909eee4:	e17ff743 	ldbu	r5,-35(fp)
 909eee8:	909b5580 	call	909b558 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 909eeec:	e43ff307 	ldb	r16,-52(fp)
 909eef0:	e47ff347 	ldb	r17,-51(fp)
 909eef4:	e13ff617 	ldw	r4,-40(fp)
 909eef8:	01400044 	movi	r5,1
 909eefc:	000d883a 	mov	r6,zero
 909ef00:	01c00404 	movi	r7,16
 909ef04:	909c5bc0 	call	909c5bc <alt_tse_phy_rd_mdio_reg>
 909ef08:	100f883a 	mov	r7,r2
 909ef0c:	01024374 	movhi	r4,2317
 909ef10:	213a4f04 	addi	r4,r4,-5828
 909ef14:	800b883a 	mov	r5,r16
 909ef18:	880d883a 	mov	r6,r17
 909ef1c:	90825100 	call	9082510 <printf>
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909ef20:	e0bff817 	ldw	r2,-32(fp)
 909ef24:	10800044 	addi	r2,r2,1
 909ef28:	e0bff815 	stw	r2,-32(fp)
 909ef2c:	e0bff917 	ldw	r2,-28(fp)
 909ef30:	10800003 	ldbu	r2,0(r2)
 909ef34:	10c03fcc 	andi	r3,r2,255
 909ef38:	e0bff817 	ldw	r2,-32(fp)
 909ef3c:	10ff1e16 	blt	r2,r3,909ebb8 <alt_tse_phy_set_common_speed+0xb4>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 909ef40:	e0bff307 	ldb	r2,-52(fp)
 909ef44:	e0bffd15 	stw	r2,-12(fp)
 909ef48:	e0bffa17 	ldw	r2,-24(fp)
 909ef4c:	108000a0 	cmpeqi	r2,r2,2
 909ef50:	10000b1e 	bne	r2,zero,909ef80 <alt_tse_phy_set_common_speed+0x47c>
 909ef54:	e0bffa17 	ldw	r2,-24(fp)
 909ef58:	10800058 	cmpnei	r2,r2,1
 909ef5c:	1000031e 	bne	r2,zero,909ef6c <alt_tse_phy_set_common_speed+0x468>
 909ef60:	00801904 	movi	r2,100
 909ef64:	e0bffb15 	stw	r2,-20(fp)
 909ef68:	00000206 	br	909ef74 <alt_tse_phy_set_common_speed+0x470>
 909ef6c:	00800284 	movi	r2,10
 909ef70:	e0bffb15 	stw	r2,-20(fp)
 909ef74:	e0bffb17 	ldw	r2,-20(fp)
 909ef78:	e0bffc15 	stw	r2,-16(fp)
 909ef7c:	00000206 	br	909ef88 <alt_tse_phy_set_common_speed+0x484>
 909ef80:	0080fa04 	movi	r2,1000
 909ef84:	e0bffc15 	stw	r2,-16(fp)
 909ef88:	01024374 	movhi	r4,2317
 909ef8c:	213a5b04 	addi	r4,r4,-5780
 909ef90:	e17ffd17 	ldw	r5,-12(fp)
 909ef94:	e1bffc17 	ldw	r6,-16(fp)
 909ef98:	90825100 	call	9082510 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 909ef9c:	e0bffa17 	ldw	r2,-24(fp)
 909efa0:	11403fcc 	andi	r5,r2,255
 909efa4:	e13ff217 	ldw	r4,-56(fp)
 909efa8:	909b46c0 	call	909b46c <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909efac:	e0bff217 	ldw	r2,-56(fp)
 909efb0:	10801004 	addi	r2,r2,64
 909efb4:	1007883a 	mov	r3,r2
 909efb8:	e0bff117 	ldw	r2,-60(fp)
 909efbc:	18800035 	stwio	r2,0(r3)
        
    return common_speed;
 909efc0:	e0bffa17 	ldw	r2,-24(fp)
 909efc4:	e0bfff15 	stw	r2,-4(fp)
 909efc8:	e0bfff17 	ldw	r2,-4(fp)
}
 909efcc:	e037883a 	mov	sp,fp
 909efd0:	dfc00317 	ldw	ra,12(sp)
 909efd4:	df000217 	ldw	fp,8(sp)
 909efd8:	dc400117 	ldw	r17,4(sp)
 909efdc:	dc000017 	ldw	r16,0(sp)
 909efe0:	dec00404 	addi	sp,sp,16
 909efe4:	f800283a 	ret

0909efe8 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 909efe8:	defffc04 	addi	sp,sp,-16
 909efec:	dfc00315 	stw	ra,12(sp)
 909eff0:	df000215 	stw	fp,8(sp)
 909eff4:	df000204 	addi	fp,sp,8
 909eff8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 909effc:	e0bfff17 	ldw	r2,-4(fp)
 909f000:	1080a104 	addi	r2,r2,644
 909f004:	10800037 	ldwio	r2,0(r2)
 909f008:	1080080c 	andi	r2,r2,32
 909f00c:	1004c03a 	cmpne	r2,r2,zero
 909f010:	1000191e 	bne	r2,zero,909f078 <marvell_phy_cfg+0x90>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 909f014:	01024374 	movhi	r4,2317
 909f018:	213a6c04 	addi	r4,r4,-5712
 909f01c:	90828380 	call	9082838 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 909f020:	e0bfff17 	ldw	r2,-4(fp)
 909f024:	1080a004 	addi	r2,r2,640
 909f028:	10801004 	addi	r2,r2,64
 909f02c:	1007883a 	mov	r3,r2
 909f030:	00801e04 	movi	r2,120
 909f034:	18800035 	stwio	r2,0(r3)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 909f038:	01024374 	movhi	r4,2317
 909f03c:	213a7504 	addi	r4,r4,-5676
 909f040:	90828380 	call	9082838 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 909f044:	e0bfff17 	ldw	r2,-4(fp)
 909f048:	1080a004 	addi	r2,r2,640
 909f04c:	10800037 	ldwio	r2,0(r2)
 909f050:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 909f054:	e0bfff17 	ldw	r2,-4(fp)
 909f058:	1080a004 	addi	r2,r2,640
 909f05c:	1009883a 	mov	r4,r2
 909f060:	e0fffe0b 	ldhu	r3,-8(fp)
 909f064:	00a00004 	movi	r2,-32768
 909f068:	1884b03a 	or	r2,r3,r2
 909f06c:	10ffffcc 	andi	r3,r2,65535
 909f070:	2005883a 	mov	r2,r4
 909f074:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 909f078:	0005883a 	mov	r2,zero
}
 909f07c:	e037883a 	mov	sp,fp
 909f080:	dfc00117 	ldw	ra,4(sp)
 909f084:	df000017 	ldw	fp,0(sp)
 909f088:	dec00204 	addi	sp,sp,8
 909f08c:	f800283a 	ret

0909f090 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 909f090:	defffc04 	addi	sp,sp,-16
 909f094:	dfc00315 	stw	ra,12(sp)
 909f098:	df000215 	stw	fp,8(sp)
 909f09c:	df000204 	addi	fp,sp,8
 909f0a0:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 909f0a4:	e0bfff17 	ldw	r2,-4(fp)
 909f0a8:	1080bb04 	addi	r2,r2,748
 909f0ac:	10800037 	ldwio	r2,0(r2)
 909f0b0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 909f0b4:	00fffc04 	movi	r3,-16
 909f0b8:	e0bffe0b 	ldhu	r2,-8(fp)
 909f0bc:	10c4703a 	and	r2,r2,r3
 909f0c0:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 909f0c4:	01024374 	movhi	r4,2317
 909f0c8:	213a7a04 	addi	r4,r4,-5656
 909f0cc:	90828380 	call	9082838 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 909f0d0:	e0bfff17 	ldw	r2,-4(fp)
 909f0d4:	1080bb04 	addi	r2,r2,748
 909f0d8:	1009883a 	mov	r4,r2
 909f0dc:	e0bffe0b 	ldhu	r2,-8(fp)
 909f0e0:	108003d4 	ori	r2,r2,15
 909f0e4:	10ffffcc 	andi	r3,r2,65535
 909f0e8:	2005883a 	mov	r2,r4
 909f0ec:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 909f0f0:	01024374 	movhi	r4,2317
 909f0f4:	213a8604 	addi	r4,r4,-5608
 909f0f8:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 909f0fc:	e0bfff17 	ldw	r2,-4(fp)
 909f100:	1080b404 	addi	r2,r2,720
 909f104:	10800037 	ldwio	r2,0(r2)
 909f108:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 909f10c:	e0fffe0b 	ldhu	r3,-8(fp)
 909f110:	00bfdf44 	movi	r2,-131
 909f114:	1884703a 	and	r2,r3,r2
 909f118:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 909f11c:	e0bfff17 	ldw	r2,-4(fp)
 909f120:	1080b404 	addi	r2,r2,720
 909f124:	e0fffe0b 	ldhu	r3,-8(fp)
 909f128:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 909f12c:	01024374 	movhi	r4,2317
 909f130:	213a7504 	addi	r4,r4,-5676
 909f134:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 909f138:	e0bfff17 	ldw	r2,-4(fp)
 909f13c:	1080a004 	addi	r2,r2,640
 909f140:	10800037 	ldwio	r2,0(r2)
 909f144:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 909f148:	e0bfff17 	ldw	r2,-4(fp)
 909f14c:	1080a004 	addi	r2,r2,640
 909f150:	1009883a 	mov	r4,r2
 909f154:	e0fffe0b 	ldhu	r3,-8(fp)
 909f158:	00a00004 	movi	r2,-32768
 909f15c:	1884b03a 	or	r2,r3,r2
 909f160:	10ffffcc 	andi	r3,r2,65535
 909f164:	2005883a 	mov	r2,r4
 909f168:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 909f16c:	00800044 	movi	r2,1
}
 909f170:	e037883a 	mov	sp,fp
 909f174:	dfc00117 	ldw	ra,4(sp)
 909f178:	df000017 	ldw	fp,0(sp)
 909f17c:	dec00204 	addi	sp,sp,8
 909f180:	f800283a 	ret

0909f184 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 909f184:	defffc04 	addi	sp,sp,-16
 909f188:	dfc00315 	stw	ra,12(sp)
 909f18c:	df000215 	stw	fp,8(sp)
 909f190:	df000204 	addi	fp,sp,8
 909f194:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 909f198:	e0bfff17 	ldw	r2,-4(fp)
 909f19c:	1080bb04 	addi	r2,r2,748
 909f1a0:	10800037 	ldwio	r2,0(r2)
 909f1a4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 909f1a8:	00fffc04 	movi	r3,-16
 909f1ac:	e0bffe0b 	ldhu	r2,-8(fp)
 909f1b0:	10c4703a 	and	r2,r2,r3
 909f1b4:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 909f1b8:	01024374 	movhi	r4,2317
 909f1bc:	213a9004 	addi	r4,r4,-5568
 909f1c0:	90828380 	call	9082838 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 909f1c4:	e0bfff17 	ldw	r2,-4(fp)
 909f1c8:	1080bb04 	addi	r2,r2,748
 909f1cc:	1009883a 	mov	r4,r2
 909f1d0:	e0bffe0b 	ldhu	r2,-8(fp)
 909f1d4:	10800114 	ori	r2,r2,4
 909f1d8:	10ffffcc 	andi	r3,r2,65535
 909f1dc:	2005883a 	mov	r2,r4
 909f1e0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 909f1e4:	01024374 	movhi	r4,2317
 909f1e8:	213a8604 	addi	r4,r4,-5608
 909f1ec:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 909f1f0:	e0bfff17 	ldw	r2,-4(fp)
 909f1f4:	1080b404 	addi	r2,r2,720
 909f1f8:	10800037 	ldwio	r2,0(r2)
 909f1fc:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 909f200:	e0fffe0b 	ldhu	r3,-8(fp)
 909f204:	00bfdf44 	movi	r2,-131
 909f208:	1884703a 	and	r2,r3,r2
 909f20c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 909f210:	e0bfff17 	ldw	r2,-4(fp)
 909f214:	1080b404 	addi	r2,r2,720
 909f218:	e0fffe0b 	ldhu	r3,-8(fp)
 909f21c:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 909f220:	01024374 	movhi	r4,2317
 909f224:	213a7504 	addi	r4,r4,-5676
 909f228:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 909f22c:	e0bfff17 	ldw	r2,-4(fp)
 909f230:	1080a004 	addi	r2,r2,640
 909f234:	10800037 	ldwio	r2,0(r2)
 909f238:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 909f23c:	e0bfff17 	ldw	r2,-4(fp)
 909f240:	1080a004 	addi	r2,r2,640
 909f244:	1009883a 	mov	r4,r2
 909f248:	e0fffe0b 	ldhu	r3,-8(fp)
 909f24c:	00a00004 	movi	r2,-32768
 909f250:	1884b03a 	or	r2,r3,r2
 909f254:	10ffffcc 	andi	r3,r2,65535
 909f258:	2005883a 	mov	r2,r4
 909f25c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 909f260:	00800044 	movi	r2,1
}
 909f264:	e037883a 	mov	sp,fp
 909f268:	dfc00117 	ldw	ra,4(sp)
 909f26c:	df000017 	ldw	fp,0(sp)
 909f270:	dec00204 	addi	sp,sp,8
 909f274:	f800283a 	ret

0909f278 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 909f278:	defffc04 	addi	sp,sp,-16
 909f27c:	dfc00315 	stw	ra,12(sp)
 909f280:	df000215 	stw	fp,8(sp)
 909f284:	df000204 	addi	fp,sp,8
 909f288:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 909f28c:	e0bfff17 	ldw	r2,-4(fp)
 909f290:	1080bb04 	addi	r2,r2,748
 909f294:	10800037 	ldwio	r2,0(r2)
 909f298:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 909f29c:	00fffc04 	movi	r3,-16
 909f2a0:	e0bffe0b 	ldhu	r2,-8(fp)
 909f2a4:	10c4703a 	and	r2,r2,r3
 909f2a8:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 909f2ac:	01024374 	movhi	r4,2317
 909f2b0:	213aa504 	addi	r4,r4,-5484
 909f2b4:	90828380 	call	9082838 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 909f2b8:	e0bfff17 	ldw	r2,-4(fp)
 909f2bc:	1080bb04 	addi	r2,r2,748
 909f2c0:	1009883a 	mov	r4,r2
 909f2c4:	e0bffe0b 	ldhu	r2,-8(fp)
 909f2c8:	108002d4 	ori	r2,r2,11
 909f2cc:	10ffffcc 	andi	r3,r2,65535
 909f2d0:	2005883a 	mov	r2,r4
 909f2d4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 909f2d8:	01024374 	movhi	r4,2317
 909f2dc:	213ab404 	addi	r4,r4,-5424
 909f2e0:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 909f2e4:	e0bfff17 	ldw	r2,-4(fp)
 909f2e8:	1080b404 	addi	r2,r2,720
 909f2ec:	10800037 	ldwio	r2,0(r2)
 909f2f0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 909f2f4:	e0fffe0b 	ldhu	r3,-8(fp)
 909f2f8:	00bfdf44 	movi	r2,-131
 909f2fc:	1884703a 	and	r2,r3,r2
 909f300:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 909f304:	e0bffe0b 	ldhu	r2,-8(fp)
 909f308:	10802094 	ori	r2,r2,130
 909f30c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 909f310:	e0bfff17 	ldw	r2,-4(fp)
 909f314:	1080b404 	addi	r2,r2,720
 909f318:	e0fffe0b 	ldhu	r3,-8(fp)
 909f31c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 909f320:	01024374 	movhi	r4,2317
 909f324:	213a7504 	addi	r4,r4,-5676
 909f328:	90828380 	call	9082838 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 909f32c:	e0bfff17 	ldw	r2,-4(fp)
 909f330:	1080a004 	addi	r2,r2,640
 909f334:	10800037 	ldwio	r2,0(r2)
 909f338:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 909f33c:	e0bfff17 	ldw	r2,-4(fp)
 909f340:	1080a004 	addi	r2,r2,640
 909f344:	1009883a 	mov	r4,r2
 909f348:	e0fffe0b 	ldhu	r3,-8(fp)
 909f34c:	00a00004 	movi	r2,-32768
 909f350:	1884b03a 	or	r2,r3,r2
 909f354:	10ffffcc 	andi	r3,r2,65535
 909f358:	2005883a 	mov	r2,r4
 909f35c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 909f360:	00800044 	movi	r2,1
    
}
 909f364:	e037883a 	mov	sp,fp
 909f368:	dfc00117 	ldw	ra,4(sp)
 909f36c:	df000017 	ldw	fp,0(sp)
 909f370:	dec00204 	addi	sp,sp,8
 909f374:	f800283a 	ret

0909f378 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 909f378:	defffc04 	addi	sp,sp,-16
 909f37c:	df000315 	stw	fp,12(sp)
 909f380:	df000304 	addi	fp,sp,12
 909f384:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 909f388:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 909f38c:	e0bfff17 	ldw	r2,-4(fp)
 909f390:	1080b004 	addi	r2,r2,704
 909f394:	10800037 	ldwio	r2,0(r2)
 909f398:	e0bffd15 	stw	r2,-12(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 909f39c:	e0bffd17 	ldw	r2,-12(fp)
 909f3a0:	1080008c 	andi	r2,r2,2
 909f3a4:	1005003a 	cmpeq	r2,r2,zero
 909f3a8:	1000041e 	bne	r2,zero,909f3bc <DP83848C_link_status_read+0x44>
		link_status |= 0x8;
 909f3ac:	e0bffe17 	ldw	r2,-8(fp)
 909f3b0:	10800214 	ori	r2,r2,8
 909f3b4:	e0bffe15 	stw	r2,-8(fp)
 909f3b8:	00000306 	br	909f3c8 <DP83848C_link_status_read+0x50>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 909f3bc:	e0bffe17 	ldw	r2,-8(fp)
 909f3c0:	10800114 	ori	r2,r2,4
 909f3c4:	e0bffe15 	stw	r2,-8(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 909f3c8:	e0bffd17 	ldw	r2,-12(fp)
 909f3cc:	1080010c 	andi	r2,r2,4
 909f3d0:	1005003a 	cmpeq	r2,r2,zero
 909f3d4:	1000031e 	bne	r2,zero,909f3e4 <DP83848C_link_status_read+0x6c>
		link_status |= 0x1;
 909f3d8:	e0bffe17 	ldw	r2,-8(fp)
 909f3dc:	10800054 	ori	r2,r2,1
 909f3e0:	e0bffe15 	stw	r2,-8(fp)
	}
	
	return link_status;
 909f3e4:	e0bffe17 	ldw	r2,-8(fp)
}
 909f3e8:	e037883a 	mov	sp,fp
 909f3ec:	df000017 	ldw	fp,0(sp)
 909f3f0:	dec00104 	addi	sp,sp,4
 909f3f4:	f800283a 	ret

0909f3f8 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 909f3f8:	defff904 	addi	sp,sp,-28
 909f3fc:	dfc00615 	stw	ra,24(sp)
 909f400:	df000515 	stw	fp,20(sp)
 909f404:	df000504 	addi	fp,sp,20
 909f408:	e13ffe15 	stw	r4,-8(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 909f40c:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_system_info *psys_info = 0;
 909f410:	e03ffb15 	stw	zero,-20(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 909f414:	e03ffd15 	stw	zero,-12(fp)
 909f418:	00001206 	br	909f464 <altera_eth_tse_init+0x6c>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 909f41c:	e0bffd17 	ldw	r2,-12(fp)
 909f420:	00c243b4 	movhi	r3,2318
 909f424:	18f30104 	addi	r3,r3,-13308
 909f428:	10800324 	muli	r2,r2,12
 909f42c:	10c5883a 	add	r2,r2,r3
 909f430:	10c00017 	ldw	r3,0(r2)
 909f434:	e0bffe17 	ldw	r2,-8(fp)
 909f438:	1880071e 	bne	r3,r2,909f458 <altera_eth_tse_init+0x60>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 909f43c:	e0bffd17 	ldw	r2,-12(fp)
 909f440:	10800324 	muli	r2,r2,12
 909f444:	1007883a 	mov	r3,r2
 909f448:	008243b4 	movhi	r2,2318
 909f44c:	10b30104 	addi	r2,r2,-13308
 909f450:	1885883a 	add	r2,r3,r2
 909f454:	e0bffc15 	stw	r2,-16(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 909f458:	e0bffd17 	ldw	r2,-12(fp)
 909f45c:	10800044 	addi	r2,r2,1
 909f460:	e0bffd15 	stw	r2,-12(fp)
 909f464:	d0a08003 	ldbu	r2,-32256(gp)
 909f468:	10c03fcc 	andi	r3,r2,255
 909f46c:	e0bffd17 	ldw	r2,-12(fp)
 909f470:	10ffea16 	blt	r2,r3,909f41c <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 909f474:	e0bffc17 	ldw	r2,-16(fp)
 909f478:	1004c03a 	cmpne	r2,r2,zero
 909f47c:	1000031e 	bne	r2,zero,909f48c <altera_eth_tse_init+0x94>
        return ENP_HARDWARE;
 909f480:	00bff744 	movi	r2,-35
 909f484:	e0bfff15 	stw	r2,-4(fp)
 909f488:	00002c06 	br	909f53c <altera_eth_tse_init+0x144>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 909f48c:	e03ffd15 	stw	zero,-12(fp)
 909f490:	00001306 	br	909f4e0 <altera_eth_tse_init+0xe8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 909f494:	e0bffd17 	ldw	r2,-12(fp)
 909f498:	00c24374 	movhi	r3,2317
 909f49c:	18c3a904 	addi	r3,r3,3748
 909f4a0:	10801224 	muli	r2,r2,72
 909f4a4:	10c5883a 	add	r2,r2,r3
 909f4a8:	10c00017 	ldw	r3,0(r2)
 909f4ac:	e0bffc17 	ldw	r2,-16(fp)
 909f4b0:	10800117 	ldw	r2,4(r2)
 909f4b4:	1880071e 	bne	r3,r2,909f4d4 <altera_eth_tse_init+0xdc>
            psys_info = &tse_mac_device[i];
 909f4b8:	e0bffd17 	ldw	r2,-12(fp)
 909f4bc:	10801224 	muli	r2,r2,72
 909f4c0:	1007883a 	mov	r3,r2
 909f4c4:	00824374 	movhi	r2,2317
 909f4c8:	1083a904 	addi	r2,r2,3748
 909f4cc:	1885883a 	add	r2,r3,r2
 909f4d0:	e0bffb15 	stw	r2,-20(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 909f4d4:	e0bffd17 	ldw	r2,-12(fp)
 909f4d8:	10800044 	addi	r2,r2,1
 909f4dc:	e0bffd15 	stw	r2,-12(fp)
 909f4e0:	00824374 	movhi	r2,2317
 909f4e4:	108bc504 	addi	r2,r2,12052
 909f4e8:	10800003 	ldbu	r2,0(r2)
 909f4ec:	10c03fcc 	andi	r3,r2,255
 909f4f0:	e0bffd17 	ldw	r2,-12(fp)
 909f4f4:	10ffe716 	blt	r2,r3,909f494 <altera_eth_tse_init+0x9c>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 909f4f8:	e0bffb17 	ldw	r2,-20(fp)
 909f4fc:	1004c03a 	cmpne	r2,r2,zero
 909f500:	1000031e 	bne	r2,zero,909f510 <altera_eth_tse_init+0x118>
        return ENP_HARDWARE;
 909f504:	00bff744 	movi	r2,-35
 909f508:	e0bfff15 	stw	r2,-4(fp)
 909f50c:	00000b06 	br	909f53c <altera_eth_tse_init+0x144>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 909f510:	e0bffe17 	ldw	r2,-8(fp)
 909f514:	11000517 	ldw	r4,20(r2)
 909f518:	e0bffc17 	ldw	r2,-16(fp)
 909f51c:	10800203 	ldbu	r2,8(r2)
 909f520:	10803fcc 	andi	r2,r2,255
 909f524:	10801224 	muli	r2,r2,72
 909f528:	1007883a 	mov	r3,r2
 909f52c:	e0bffb17 	ldw	r2,-20(fp)
 909f530:	188b883a 	add	r5,r3,r2
 909f534:	909f5540 	call	909f554 <prep_tse_mac>
    
    return SUCCESS;
 909f538:	e03fff15 	stw	zero,-4(fp)
 909f53c:	e0bfff17 	ldw	r2,-4(fp)
}
 909f540:	e037883a 	mov	sp,fp
 909f544:	dfc00117 	ldw	ra,4(sp)
 909f548:	df000017 	ldw	fp,0(sp)
 909f54c:	dec00204 	addi	sp,sp,8
 909f550:	f800283a 	ret

0909f554 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 909f554:	defffa04 	addi	sp,sp,-24
 909f558:	dfc00515 	stw	ra,20(sp)
 909f55c:	df000415 	stw	fp,16(sp)
 909f560:	dc000315 	stw	r16,12(sp)
 909f564:	df000304 	addi	fp,sp,12
 909f568:	e13ffe15 	stw	r4,-8(fp)
 909f56c:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 909f570:	01024374 	movhi	r4,2317
 909f574:	213abe04 	addi	r4,r4,-5384
 909f578:	e17ffe17 	ldw	r5,-8(fp)
 909f57c:	90825100 	call	9082510 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 909f580:	e0bffe17 	ldw	r2,-8(fp)
 909f584:	00c243b4 	movhi	r3,2318
 909f588:	18f30d04 	addi	r3,r3,-13260
 909f58c:	10801324 	muli	r2,r2,76
 909f590:	10c5883a 	add	r2,r2,r3
 909f594:	10800c04 	addi	r2,r2,48
 909f598:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 909f59c:	e0bffe17 	ldw	r2,-8(fp)
 909f5a0:	00c243b4 	movhi	r3,2318
 909f5a4:	18f30d04 	addi	r3,r3,-13260
 909f5a8:	10801324 	muli	r2,r2,76
 909f5ac:	10c5883a 	add	r2,r2,r3
 909f5b0:	10c01204 	addi	r3,r2,72
 909f5b4:	e0bfff17 	ldw	r2,-4(fp)
 909f5b8:	18800015 	stw	r2,0(r3)

        ifp = nets[index];
 909f5bc:	e0bffe17 	ldw	r2,-8(fp)
 909f5c0:	00c243b4 	movhi	r3,2318
 909f5c4:	18f41e04 	addi	r3,r3,-12168
 909f5c8:	1085883a 	add	r2,r2,r2
 909f5cc:	1085883a 	add	r2,r2,r2
 909f5d0:	10c5883a 	add	r2,r2,r3
 909f5d4:	10800017 	ldw	r2,0(r2)
 909f5d8:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 909f5dc:	e0bffd17 	ldw	r2,-12(fp)
 909f5e0:	10c02717 	ldw	r3,156(r2)
 909f5e4:	00800084 	movi	r2,2
 909f5e8:	18800615 	stw	r2,24(r3)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 909f5ec:	e0bffd17 	ldw	r2,-12(fp)
 909f5f0:	10c02717 	ldw	r3,156(r2)
 909f5f4:	00800084 	movi	r2,2
 909f5f8:	18800715 	stw	r2,28(r3)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 909f5fc:	e0bffd17 	ldw	r2,-12(fp)
 909f600:	14002717 	ldw	r16,156(r2)
 909f604:	00824374 	movhi	r2,2317
 909f608:	108c4204 	addi	r2,r2,12552
 909f60c:	11000017 	ldw	r4,0(r2)
 909f610:	908c0380 	call	908c038 <__floatunsidf>
 909f614:	100b883a 	mov	r5,r2
 909f618:	180d883a 	mov	r6,r3
 909f61c:	2809883a 	mov	r4,r5
 909f620:	300b883a 	mov	r5,r6
 909f624:	90cade40 	call	90cade4 <__fixunsdfsi>
 909f628:	80800815 	stw	r2,32(r16)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 909f62c:	e0bffd17 	ldw	r2,-12(fp)
 909f630:	11002717 	ldw	r4,156(r2)
 909f634:	e0bffe17 	ldw	r2,-8(fp)
 909f638:	10801324 	muli	r2,r2,76
 909f63c:	10c00604 	addi	r3,r2,24
 909f640:	008243b4 	movhi	r2,2318
 909f644:	10b30d04 	addi	r2,r2,-13260
 909f648:	1885883a 	add	r2,r3,r2
 909f64c:	20800515 	stw	r2,20(r4)
        ifp->n_mib->ifDescr =       (u_char*)"Altera TSE MAC ethernet";
 909f650:	e0bffd17 	ldw	r2,-12(fp)
 909f654:	10c02717 	ldw	r3,156(r2)
 909f658:	00824374 	movhi	r2,2317
 909f65c:	10bac304 	addi	r2,r2,-5364
 909f660:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 909f664:	e0fffd17 	ldw	r3,-12(fp)
 909f668:	00800404 	movi	r2,16
 909f66c:	18800815 	stw	r2,32(r3)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 909f670:	e0fffd17 	ldw	r3,-12(fp)
 909f674:	00800184 	movi	r2,6
 909f678:	18801115 	stw	r2,68(r3)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 909f67c:	e0bffd17 	ldw	r2,-12(fp)
 909f680:	10c02717 	ldw	r3,156(r2)
 909f684:	00800184 	movi	r2,6
 909f688:	18800215 	stw	r2,8(r3)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 909f68c:	e0fffd17 	ldw	r3,-12(fp)
 909f690:	00817a84 	movi	r2,1514
 909f694:	18800915 	stw	r2,36(r3)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 909f698:	e0fffd17 	ldw	r3,-12(fp)
 909f69c:	008242b4 	movhi	r2,2314
 909f6a0:	10bdf604 	addi	r2,r2,-2088
 909f6a4:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 909f6a8:	e0bffd17 	ldw	r2,-12(fp)
 909f6ac:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 909f6b0:	e0fffd17 	ldw	r3,-12(fp)
 909f6b4:	008242b4 	movhi	r2,2314
 909f6b8:	1080b004 	addi	r2,r2,704
 909f6bc:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 909f6c0:	e0fffd17 	ldw	r3,-12(fp)
 909f6c4:	008242b4 	movhi	r2,2314
 909f6c8:	1082a604 	addi	r2,r2,2712
 909f6cc:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 909f6d0:	00c242b4 	movhi	r3,2314
 909f6d4:	18c29604 	addi	r3,r3,2648
 909f6d8:	e0bffd17 	ldw	r2,-12(fp)
 909f6dc:	10c00715 	stw	r3,28(r2)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 909f6e0:	e0bffd17 	ldw	r2,-12(fp)
 909f6e4:	10802a17 	ldw	r2,168(r2)
 909f6e8:	10c00214 	ori	r3,r2,8
 909f6ec:	e0bffd17 	ldw	r2,-12(fp)
 909f6f0:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 909f6f4:	e0bffe17 	ldw	r2,-8(fp)
 909f6f8:	00c243b4 	movhi	r3,2318
 909f6fc:	18f41e04 	addi	r3,r3,-12168
 909f700:	1085883a 	add	r2,r2,r2
 909f704:	1085883a 	add	r2,r2,r2
 909f708:	10c5883a 	add	r2,r2,r3
 909f70c:	10800017 	ldw	r2,0(r2)
 909f710:	11002717 	ldw	r4,156(r2)
 909f714:	e0bffe17 	ldw	r2,-8(fp)
 909f718:	10801324 	muli	r2,r2,76
 909f71c:	10c00604 	addi	r3,r2,24
 909f720:	008243b4 	movhi	r2,2318
 909f724:	10b30d04 	addi	r2,r2,-13260
 909f728:	1885883a 	add	r2,r3,r2
 909f72c:	20800515 	stw	r2,20(r4)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 909f730:	e0bffe17 	ldw	r2,-8(fp)
 909f734:	10801324 	muli	r2,r2,76
 909f738:	10c00604 	addi	r3,r2,24
 909f73c:	008243b4 	movhi	r2,2318
 909f740:	10b30d04 	addi	r2,r2,-13260
 909f744:	1885883a 	add	r2,r3,r2
 909f748:	100b883a 	mov	r5,r2
 909f74c:	e13ffd17 	ldw	r4,-12(fp)
 909f750:	90812e80 	call	90812e8 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 909f754:	e0bffe17 	ldw	r2,-8(fp)
 909f758:	00c243b4 	movhi	r3,2318
 909f75c:	18f30d04 	addi	r3,r3,-13260
 909f760:	10801324 	muli	r2,r2,76
 909f764:	10c7883a 	add	r3,r2,r3
 909f768:	e0bffe17 	ldw	r2,-8(fp)
 909f76c:	18800015 	stw	r2,0(r3)
        tse[index].netp = ifp;
 909f770:	e0bffe17 	ldw	r2,-8(fp)
 909f774:	00c243b4 	movhi	r3,2318
 909f778:	18f30d04 	addi	r3,r3,-13260
 909f77c:	10801324 	muli	r2,r2,76
 909f780:	10c5883a 	add	r2,r2,r3
 909f784:	10c00804 	addi	r3,r2,32
 909f788:	e0bffd17 	ldw	r2,-12(fp)
 909f78c:	18800015 	stw	r2,0(r3)
        ifp->n_local = (void*)(&tse[index]);
 909f790:	e0bffe17 	ldw	r2,-8(fp)
 909f794:	10801324 	muli	r2,r2,76
 909f798:	1007883a 	mov	r3,r2
 909f79c:	008243b4 	movhi	r2,2318
 909f7a0:	10b30d04 	addi	r2,r2,-13260
 909f7a4:	1887883a 	add	r3,r3,r2
 909f7a8:	e0bffd17 	ldw	r2,-12(fp)
 909f7ac:	10c02815 	stw	r3,160(r2)
    
        index++;
 909f7b0:	e0bffe17 	ldw	r2,-8(fp)
 909f7b4:	10800044 	addi	r2,r2,1
 909f7b8:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 909f7bc:	e0bffe17 	ldw	r2,-8(fp)
}
 909f7c0:	e037883a 	mov	sp,fp
 909f7c4:	dfc00217 	ldw	ra,8(sp)
 909f7c8:	df000117 	ldw	fp,4(sp)
 909f7cc:	dc000017 	ldw	r16,0(sp)
 909f7d0:	dec00304 	addi	sp,sp,12
 909f7d4:	f800283a 	ret

0909f7d8 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 909f7d8:	deffee04 	addi	sp,sp,-72
 909f7dc:	dfc01115 	stw	ra,68(sp)
 909f7e0:	df001015 	stw	fp,64(sp)
 909f7e4:	df001004 	addi	fp,sp,64
 909f7e8:	e13ffe15 	stw	r4,-8(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 909f7ec:	e03ff815 	stw	zero,-32(fp)
   
   NET ifp;
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 909f7f0:	e0bffe17 	ldw	r2,-8(fp)
 909f7f4:	00c243b4 	movhi	r3,2318
 909f7f8:	18f30d04 	addi	r3,r3,-13260
 909f7fc:	10801324 	muli	r2,r2,76
 909f800:	10c5883a 	add	r2,r2,r3
 909f804:	10801204 	addi	r2,r2,72
 909f808:	10800017 	ldw	r2,0(r2)
 909f80c:	e0bff415 	stw	r2,-48(fp)
   
   dprintf("[tse_mac_init]\n");
 909f810:	01024374 	movhi	r4,2317
 909f814:	213ac904 	addi	r4,r4,-5340
 909f818:	90828380 	call	9082838 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 909f81c:	e0bff417 	ldw	r2,-48(fp)
 909f820:	10800783 	ldbu	r2,30(r2)
 909f824:	10803fcc 	andi	r2,r2,255
 909f828:	10800058 	cmpnei	r2,r2,1
 909f82c:	10000b1e 	bne	r2,zero,909f85c <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 909f830:	e13ffe17 	ldw	r4,-8(fp)
 909f834:	e0bff417 	ldw	r2,-48(fp)
 909f838:	10800817 	ldw	r2,32(r2)
 909f83c:	100b883a 	mov	r5,r2
 909f840:	00c243b4 	movhi	r3,2318
 909f844:	18f30d04 	addi	r3,r3,-13260
 909f848:	20801324 	muli	r2,r4,76
 909f84c:	10c5883a 	add	r2,r2,r3
 909f850:	10800f04 	addi	r2,r2,60
 909f854:	11400015 	stw	r5,0(r2)
 909f858:	00001306 	br	909f8a8 <tse_mac_init+0xd0>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 909f85c:	01002804 	movi	r4,160
 909f860:	90b9afc0 	call	90b9afc <alt_uncached_malloc>
 909f864:	e0bff315 	stw	r2,-52(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 909f868:	00000306 	br	909f878 <tse_mac_init+0xa0>
        {
            temp_desc++;
 909f86c:	e0bff317 	ldw	r2,-52(fp)
 909f870:	10800044 	addi	r2,r2,1
 909f874:	e0bff315 	stw	r2,-52(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 909f878:	e0bff317 	ldw	r2,-52(fp)
 909f87c:	108007cc 	andi	r2,r2,31
 909f880:	1004c03a 	cmpne	r2,r2,zero
 909f884:	103ff91e 	bne	r2,zero,909f86c <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 909f888:	e0bffe17 	ldw	r2,-8(fp)
 909f88c:	e13ff317 	ldw	r4,-52(fp)
 909f890:	00c243b4 	movhi	r3,2318
 909f894:	18f30d04 	addi	r3,r3,-13260
 909f898:	10801324 	muli	r2,r2,76
 909f89c:	10c5883a 	add	r2,r2,r3
 909f8a0:	10800f04 	addi	r2,r2,60
 909f8a4:	11000015 	stw	r4,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 909f8a8:	e0bff417 	ldw	r2,-48(fp)
 909f8ac:	11000517 	ldw	r4,20(r2)
 909f8b0:	909984c0 	call	909984c <alt_avalon_sgdma_open>
 909f8b4:	e0bff615 	stw	r2,-40(fp)
   
   if(!sgdma_tx_dev) {
 909f8b8:	e0bff617 	ldw	r2,-40(fp)
 909f8bc:	1004c03a 	cmpne	r2,r2,zero
 909f8c0:	1000061e 	bne	r2,zero,909f8dc <tse_mac_init+0x104>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 909f8c4:	01024374 	movhi	r4,2317
 909f8c8:	213acd04 	addi	r4,r4,-5324
 909f8cc:	90828380 	call	9082838 <puts>
      return ENP_RESOURCE;
 909f8d0:	00bffa84 	movi	r2,-22
 909f8d4:	e0bfff15 	stw	r2,-4(fp)
 909f8d8:	00027306 	br	90a02a8 <tse_mac_init+0xad0>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 909f8dc:	e0bff417 	ldw	r2,-48(fp)
 909f8e0:	11000617 	ldw	r4,24(r2)
 909f8e4:	909984c0 	call	909984c <alt_avalon_sgdma_open>
 909f8e8:	e0bff515 	stw	r2,-44(fp)
   if(!sgdma_rx_dev) {
 909f8ec:	e0bff517 	ldw	r2,-44(fp)
 909f8f0:	1004c03a 	cmpne	r2,r2,zero
 909f8f4:	1000061e 	bne	r2,zero,909f910 <tse_mac_init+0x138>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 909f8f8:	01024374 	movhi	r4,2317
 909f8fc:	213ad904 	addi	r4,r4,-5276
 909f900:	90828380 	call	9082838 <puts>
      return ENP_RESOURCE;
 909f904:	00bffa84 	movi	r2,-22
 909f908:	e0bfff15 	stw	r2,-4(fp)
 909f90c:	00026606 	br	90a02a8 <tse_mac_init+0xad0>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 909f910:	e0bffe17 	ldw	r2,-8(fp)
 909f914:	10801324 	muli	r2,r2,76
 909f918:	10c00104 	addi	r3,r2,4
 909f91c:	008243b4 	movhi	r2,2318
 909f920:	10b30d04 	addi	r2,r2,-13260
 909f924:	1889883a 	add	r4,r3,r2
 909f928:	e0bff417 	ldw	r2,-48(fp)
 909f92c:	11400017 	ldw	r5,0(r2)
 909f930:	e0bff617 	ldw	r2,-40(fp)
 909f934:	100d883a 	mov	r6,r2
 909f938:	e0bff517 	ldw	r2,-44(fp)
 909f93c:	100f883a 	mov	r7,r2
 909f940:	d8000015 	stw	zero,0(sp)
 909f944:	909a0e40 	call	909a0e4 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 909f948:	e0bffe17 	ldw	r2,-8(fp)
 909f94c:	00c243b4 	movhi	r3,2318
 909f950:	18f30d04 	addi	r3,r3,-13260
 909f954:	10801324 	muli	r2,r2,76
 909f958:	10c5883a 	add	r2,r2,r3
 909f95c:	10800304 	addi	r2,r2,12
 909f960:	10800017 	ldw	r2,0(r2)
 909f964:	10800317 	ldw	r2,12(r2)
 909f968:	10800404 	addi	r2,r2,16
 909f96c:	1007883a 	mov	r3,r2
 909f970:	00800074 	movhi	r2,1
 909f974:	18800035 	stwio	r2,0(r3)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 909f978:	e0bffe17 	ldw	r2,-8(fp)
 909f97c:	00c243b4 	movhi	r3,2318
 909f980:	18f30d04 	addi	r3,r3,-13260
 909f984:	10801324 	muli	r2,r2,76
 909f988:	10c5883a 	add	r2,r2,r3
 909f98c:	10800304 	addi	r2,r2,12
 909f990:	10800017 	ldw	r2,0(r2)
 909f994:	10800317 	ldw	r2,12(r2)
 909f998:	10800404 	addi	r2,r2,16
 909f99c:	10000035 	stwio	zero,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 909f9a0:	e13ffe17 	ldw	r4,-8(fp)
 909f9a4:	e0bff417 	ldw	r2,-48(fp)
 909f9a8:	1080070b 	ldhu	r2,28(r2)
 909f9ac:	117fffcc 	andi	r5,r2,65535
 909f9b0:	00c243b4 	movhi	r3,2318
 909f9b4:	18f30d04 	addi	r3,r3,-13260
 909f9b8:	20801324 	muli	r2,r4,76
 909f9bc:	10c5883a 	add	r2,r2,r3
 909f9c0:	10800904 	addi	r2,r2,36
 909f9c4:	11400015 	stw	r5,0(r2)
   ifp = tse[iface].netp;
 909f9c8:	e0bffe17 	ldw	r2,-8(fp)
 909f9cc:	00c243b4 	movhi	r3,2318
 909f9d0:	18f30d04 	addi	r3,r3,-13260
 909f9d4:	10801324 	muli	r2,r2,76
 909f9d8:	10c5883a 	add	r2,r2,r3
 909f9dc:	10800804 	addi	r2,r2,32
 909f9e0:	10800017 	ldw	r2,0(r2)
 909f9e4:	e0bff715 	stw	r2,-36(fp)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 909f9e8:	e0bffe17 	ldw	r2,-8(fp)
 909f9ec:	00c243b4 	movhi	r3,2318
 909f9f0:	18f30d04 	addi	r3,r3,-13260
 909f9f4:	10801324 	muli	r2,r2,76
 909f9f8:	10c5883a 	add	r2,r2,r3
 909f9fc:	10800104 	addi	r2,r2,4
 909fa00:	11000017 	ldw	r4,0(r2)
 909fa04:	909b5f00 	call	909b5f0 <getPHYSpeed>
 909fa08:	e0bffa15 	stw	r2,-24(fp)
   speed = (result >> 1) & 0x07;
 909fa0c:	e0bffa17 	ldw	r2,-24(fp)
 909fa10:	1005d07a 	srai	r2,r2,1
 909fa14:	108001cc 	andi	r2,r2,7
 909fa18:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
 909fa1c:	e0bffa17 	ldw	r2,-24(fp)
 909fa20:	1080004c 	andi	r2,r2,1
 909fa24:	e0bffb15 	stw	r2,-20(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 909fa28:	e0bffe17 	ldw	r2,-8(fp)
 909fa2c:	00c243b4 	movhi	r3,2318
 909fa30:	18f30d04 	addi	r3,r3,-13260
 909fa34:	10801324 	muli	r2,r2,76
 909fa38:	10c5883a 	add	r2,r2,r3
 909fa3c:	10800104 	addi	r2,r2,4
 909fa40:	10800017 	ldw	r2,0(r2)
 909fa44:	10800204 	addi	r2,r2,8
 909fa48:	1007883a 	mov	r3,r2
 909fa4c:	008800c4 	movi	r2,8195
 909fa50:	18800035 	stwio	r2,0(r3)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 909fa54:	e03ff915 	stw	zero,-28(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 909fa58:	00000906 	br	909fa80 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 909fa5c:	e0bff917 	ldw	r2,-28(fp)
 909fa60:	1089c448 	cmpgei	r2,r2,10001
 909fa64:	1007883a 	mov	r3,r2
 909fa68:	e0bff917 	ldw	r2,-28(fp)
 909fa6c:	10800044 	addi	r2,r2,1
 909fa70:	e0bff915 	stw	r2,-28(fp)
 909fa74:	18803fcc 	andi	r2,r3,255
 909fa78:	1004c03a 	cmpne	r2,r2,zero
 909fa7c:	10000c1e 	bne	r2,zero,909fab0 <tse_mac_init+0x2d8>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 909fa80:	e0bffe17 	ldw	r2,-8(fp)
 909fa84:	00c243b4 	movhi	r3,2318
 909fa88:	18f30d04 	addi	r3,r3,-13260
 909fa8c:	10801324 	muli	r2,r2,76
 909fa90:	10c5883a 	add	r2,r2,r3
 909fa94:	10800104 	addi	r2,r2,4
 909fa98:	10800017 	ldw	r2,0(r2)
 909fa9c:	10800204 	addi	r2,r2,8
 909faa0:	10800037 	ldwio	r2,0(r2)
 909faa4:	1088000c 	andi	r2,r2,8192
 909faa8:	1004c03a 	cmpne	r2,r2,zero
 909faac:	103feb1e 	bne	r2,zero,909fa5c <tse_mac_init+0x284>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
     }
   }
   if(x >= 10000) {
 909fab0:	e0bff917 	ldw	r2,-28(fp)
 909fab4:	1089c410 	cmplti	r2,r2,10000
 909fab8:	1000031e 	bne	r2,zero,909fac8 <tse_mac_init+0x2f0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 909fabc:	01024374 	movhi	r4,2317
 909fac0:	213ae504 	addi	r4,r4,-5228
 909fac4:	90828380 	call	9082838 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 909fac8:	e0bffe17 	ldw	r2,-8(fp)
 909facc:	00c243b4 	movhi	r3,2318
 909fad0:	18f30d04 	addi	r3,r3,-13260
 909fad4:	10801324 	muli	r2,r2,76
 909fad8:	10c5883a 	add	r2,r2,r3
 909fadc:	10800104 	addi	r2,r2,4
 909fae0:	10800017 	ldw	r2,0(r2)
 909fae4:	10800204 	addi	r2,r2,8
 909fae8:	10800037 	ldwio	r2,0(r2)
 909faec:	e0bffd15 	stw	r2,-12(fp)
   if( (dat & 0x03) != 0 ) {
 909faf0:	e0bffd17 	ldw	r2,-12(fp)
 909faf4:	108000cc 	andi	r2,r2,3
 909faf8:	1005003a 	cmpeq	r2,r2,zero
 909fafc:	1000051e 	bne	r2,zero,909fb14 <tse_mac_init+0x33c>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 909fb00:	01024374 	movhi	r4,2317
 909fb04:	213aee04 	addi	r4,r4,-5192
 909fb08:	e17ffd17 	ldw	r5,-12(fp)
 909fb0c:	90825100 	call	9082510 <printf>
 909fb10:	00000506 	br	909fb28 <tse_mac_init+0x350>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 909fb14:	01024374 	movhi	r4,2317
 909fb18:	213b0204 	addi	r4,r4,-5112
 909fb1c:	e17ff917 	ldw	r5,-28(fp)
 909fb20:	e1bffd17 	ldw	r6,-12(fp)
 909fb24:	90825100 	call	9082510 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 909fb28:	e0bff417 	ldw	r2,-48(fp)
 909fb2c:	10800903 	ldbu	r2,36(r2)
 909fb30:	10803fcc 	andi	r2,r2,255
 909fb34:	10800058 	cmpnei	r2,r2,1
 909fb38:	1000351e 	bne	r2,zero,909fc10 <tse_mac_init+0x438>
      int channel_loop = 0;
 909fb3c:	e03ff215 	stw	zero,-56(fp)
      int mac_loop = 0;
 909fb40:	e03ff115 	stw	zero,-60(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 909fb44:	e03ff215 	stw	zero,-56(fp)
 909fb48:	00002b06 	br	909fbf8 <tse_mac_init+0x420>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 909fb4c:	e03ff115 	stw	zero,-60(fp)
 909fb50:	00001b06 	br	909fbc0 <tse_mac_init+0x3e8>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 909fb54:	e0bff217 	ldw	r2,-56(fp)
 909fb58:	00c243b4 	movhi	r3,2318
 909fb5c:	18f2f904 	addi	r3,r3,-13340
 909fb60:	1085883a 	add	r2,r2,r2
 909fb64:	1085883a 	add	r2,r2,r2
 909fb68:	10c5883a 	add	r2,r2,r3
 909fb6c:	10c00017 	ldw	r3,0(r2)
 909fb70:	e0bff117 	ldw	r2,-60(fp)
 909fb74:	1085883a 	add	r2,r2,r2
 909fb78:	1085883a 	add	r2,r2,r2
 909fb7c:	10c5883a 	add	r2,r2,r3
 909fb80:	10800104 	addi	r2,r2,4
 909fb84:	10800017 	ldw	r2,0(r2)
 909fb88:	10c00217 	ldw	r3,8(r2)
 909fb8c:	e0bff417 	ldw	r2,-48(fp)
 909fb90:	1880081e 	bne	r3,r2,909fbb4 <tse_mac_init+0x3dc>
            tse[iface].channel = mac_loop;
 909fb94:	e0bffe17 	ldw	r2,-8(fp)
 909fb98:	00c243b4 	movhi	r3,2318
 909fb9c:	18f30d04 	addi	r3,r3,-13260
 909fba0:	10801324 	muli	r2,r2,76
 909fba4:	10c5883a 	add	r2,r2,r3
 909fba8:	10c00d04 	addi	r3,r2,52
 909fbac:	e0bff117 	ldw	r2,-60(fp)
 909fbb0:	18800015 	stw	r2,0(r3)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 909fbb4:	e0bff117 	ldw	r2,-60(fp)
 909fbb8:	10800044 	addi	r2,r2,1
 909fbbc:	e0bff115 	stw	r2,-60(fp)
 909fbc0:	e0bff217 	ldw	r2,-56(fp)
 909fbc4:	00c243b4 	movhi	r3,2318
 909fbc8:	18f2f904 	addi	r3,r3,-13340
 909fbcc:	1085883a 	add	r2,r2,r2
 909fbd0:	1085883a 	add	r2,r2,r2
 909fbd4:	10c5883a 	add	r2,r2,r3
 909fbd8:	10800017 	ldw	r2,0(r2)
 909fbdc:	10800003 	ldbu	r2,0(r2)
 909fbe0:	10c03fcc 	andi	r3,r2,255
 909fbe4:	e0bff117 	ldw	r2,-60(fp)
 909fbe8:	10ffda16 	blt	r2,r3,909fb54 <tse_mac_init+0x37c>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 909fbec:	e0bff217 	ldw	r2,-56(fp)
 909fbf0:	10800044 	addi	r2,r2,1
 909fbf4:	e0bff215 	stw	r2,-56(fp)
 909fbf8:	00824374 	movhi	r2,2317
 909fbfc:	108c1944 	addi	r2,r2,12389
 909fc00:	10800003 	ldbu	r2,0(r2)
 909fc04:	10c03fcc 	andi	r3,r2,255
 909fc08:	e0bff217 	ldw	r2,-56(fp)
 909fc0c:	10ffcf16 	blt	r2,r3,909fb4c <tse_mac_init+0x374>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 909fc10:	e0bff417 	ldw	r2,-48(fp)
 909fc14:	10800903 	ldbu	r2,36(r2)
 909fc18:	10803fcc 	andi	r2,r2,255
 909fc1c:	10800058 	cmpnei	r2,r2,1
 909fc20:	1000121e 	bne	r2,zero,909fc6c <tse_mac_init+0x494>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 909fc24:	e0bff417 	ldw	r2,-48(fp)
 909fc28:	10800d17 	ldw	r2,52(r2)
 909fc2c:	1009883a 	mov	r4,r2
 909fc30:	e0bff417 	ldw	r2,-48(fp)
 909fc34:	10800f17 	ldw	r2,60(r2)
 909fc38:	1007883a 	mov	r3,r2
 909fc3c:	2005883a 	mov	r2,r4
 909fc40:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 909fc44:	e0bff417 	ldw	r2,-48(fp)
 909fc48:	10800d17 	ldw	r2,52(r2)
 909fc4c:	11000204 	addi	r4,r2,8
 909fc50:	e0bff417 	ldw	r2,-48(fp)
 909fc54:	10800f17 	ldw	r2,60(r2)
 909fc58:	10bfdd04 	addi	r2,r2,-140
 909fc5c:	1007883a 	mov	r3,r2
 909fc60:	2005883a 	mov	r2,r4
 909fc64:	10c00035 	stwio	r3,0(r2)
 909fc68:	00006506 	br	909fe00 <tse_mac_init+0x628>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 909fc6c:	e0bffe17 	ldw	r2,-8(fp)
 909fc70:	00c243b4 	movhi	r3,2318
 909fc74:	18f30d04 	addi	r3,r3,-13260
 909fc78:	10801324 	muli	r2,r2,76
 909fc7c:	10c5883a 	add	r2,r2,r3
 909fc80:	10800104 	addi	r2,r2,4
 909fc84:	10800017 	ldw	r2,0(r2)
 909fc88:	10800504 	addi	r2,r2,20
 909fc8c:	1007883a 	mov	r3,r2
 909fc90:	00817b84 	movi	r2,1518
 909fc94:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 909fc98:	e0bffe17 	ldw	r2,-8(fp)
 909fc9c:	00c243b4 	movhi	r3,2318
 909fca0:	18f30d04 	addi	r3,r3,-13260
 909fca4:	10801324 	muli	r2,r2,76
 909fca8:	10c5883a 	add	r2,r2,r3
 909fcac:	10800104 	addi	r2,r2,4
 909fcb0:	10800017 	ldw	r2,0(r2)
 909fcb4:	10800b04 	addi	r2,r2,44
 909fcb8:	1007883a 	mov	r3,r2
 909fcbc:	00800204 	movi	r2,8
 909fcc0:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 909fcc4:	e0bffe17 	ldw	r2,-8(fp)
 909fcc8:	00c243b4 	movhi	r3,2318
 909fccc:	18f30d04 	addi	r3,r3,-13260
 909fcd0:	10801324 	muli	r2,r2,76
 909fcd4:	10c5883a 	add	r2,r2,r3
 909fcd8:	10800104 	addi	r2,r2,4
 909fcdc:	10800017 	ldw	r2,0(r2)
 909fce0:	10800c04 	addi	r2,r2,48
 909fce4:	1007883a 	mov	r3,r2
 909fce8:	00800204 	movi	r2,8
 909fcec:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 909fcf0:	e0bffe17 	ldw	r2,-8(fp)
 909fcf4:	00c243b4 	movhi	r3,2318
 909fcf8:	18f30d04 	addi	r3,r3,-13260
 909fcfc:	10801324 	muli	r2,r2,76
 909fd00:	10c5883a 	add	r2,r2,r3
 909fd04:	10800104 	addi	r2,r2,4
 909fd08:	10800017 	ldw	r2,0(r2)
 909fd0c:	10800d04 	addi	r2,r2,52
 909fd10:	1007883a 	mov	r3,r2
 909fd14:	00800204 	movi	r2,8
 909fd18:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 909fd1c:	e0bffe17 	ldw	r2,-8(fp)
 909fd20:	00c243b4 	movhi	r3,2318
 909fd24:	18f30d04 	addi	r3,r3,-13260
 909fd28:	10801324 	muli	r2,r2,76
 909fd2c:	10c5883a 	add	r2,r2,r3
 909fd30:	10800104 	addi	r2,r2,4
 909fd34:	10800017 	ldw	r2,0(r2)
 909fd38:	10800e04 	addi	r2,r2,56
 909fd3c:	1007883a 	mov	r3,r2
 909fd40:	008000c4 	movi	r2,3
 909fd44:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 909fd48:	e0bffe17 	ldw	r2,-8(fp)
 909fd4c:	00c243b4 	movhi	r3,2318
 909fd50:	18f30d04 	addi	r3,r3,-13260
 909fd54:	10801324 	muli	r2,r2,76
 909fd58:	10c5883a 	add	r2,r2,r3
 909fd5c:	10800104 	addi	r2,r2,4
 909fd60:	10800017 	ldw	r2,0(r2)
 909fd64:	11000904 	addi	r4,r2,36
 909fd68:	e0bff417 	ldw	r2,-48(fp)
 909fd6c:	1080010b 	ldhu	r2,4(r2)
 909fd70:	10bfffcc 	andi	r2,r2,65535
 909fd74:	10fffc04 	addi	r3,r2,-16
 909fd78:	2005883a 	mov	r2,r4
 909fd7c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 909fd80:	e0bffe17 	ldw	r2,-8(fp)
 909fd84:	00c243b4 	movhi	r3,2318
 909fd88:	18f30d04 	addi	r3,r3,-13260
 909fd8c:	10801324 	muli	r2,r2,76
 909fd90:	10c5883a 	add	r2,r2,r3
 909fd94:	10800104 	addi	r2,r2,4
 909fd98:	10800017 	ldw	r2,0(r2)
 909fd9c:	10800a04 	addi	r2,r2,40
 909fda0:	10000035 	stwio	zero,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 909fda4:	e0bffe17 	ldw	r2,-8(fp)
 909fda8:	00c243b4 	movhi	r3,2318
 909fdac:	18f30d04 	addi	r3,r3,-13260
 909fdb0:	10801324 	muli	r2,r2,76
 909fdb4:	10c5883a 	add	r2,r2,r3
 909fdb8:	10800104 	addi	r2,r2,4
 909fdbc:	10800017 	ldw	r2,0(r2)
 909fdc0:	11000704 	addi	r4,r2,28
 909fdc4:	e0bff417 	ldw	r2,-48(fp)
 909fdc8:	1080018b 	ldhu	r2,6(r2)
 909fdcc:	10bfffcc 	andi	r2,r2,65535
 909fdd0:	10fffc04 	addi	r3,r2,-16
 909fdd4:	2005883a 	mov	r2,r4
 909fdd8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 909fddc:	e0bffe17 	ldw	r2,-8(fp)
 909fde0:	00c243b4 	movhi	r3,2318
 909fde4:	18f30d04 	addi	r3,r3,-13260
 909fde8:	10801324 	muli	r2,r2,76
 909fdec:	10c5883a 	add	r2,r2,r3
 909fdf0:	10800104 	addi	r2,r2,4
 909fdf4:	10800017 	ldw	r2,0(r2)
 909fdf8:	10800804 	addi	r2,r2,32
 909fdfc:	10000035 	stwio	zero,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 909fe00:	e0bffe17 	ldw	r2,-8(fp)
 909fe04:	00c243b4 	movhi	r3,2318
 909fe08:	18f30d04 	addi	r3,r3,-13260
 909fe0c:	10801324 	muli	r2,r2,76
 909fe10:	10c5883a 	add	r2,r2,r3
 909fe14:	10800104 	addi	r2,r2,4
 909fe18:	10800017 	ldw	r2,0(r2)
 909fe1c:	10803a04 	addi	r2,r2,232
 909fe20:	1007883a 	mov	r3,r2
 909fe24:	00800134 	movhi	r2,4
 909fe28:	18800035 	stwio	r2,0(r3)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 909fe2c:	e0bffe17 	ldw	r2,-8(fp)
 909fe30:	00c243b4 	movhi	r3,2318
 909fe34:	18f30d04 	addi	r3,r3,-13260
 909fe38:	10801324 	muli	r2,r2,76
 909fe3c:	10c5883a 	add	r2,r2,r3
 909fe40:	10800104 	addi	r2,r2,4
 909fe44:	10800017 	ldw	r2,0(r2)
 909fe48:	10803a04 	addi	r2,r2,232
 909fe4c:	10800037 	ldwio	r2,0(r2)
 909fe50:	1080012c 	andhi	r2,r2,4
 909fe54:	1005003a 	cmpeq	r2,r2,zero
 909fe58:	1000201e 	bne	r2,zero,909fedc <tse_mac_init+0x704>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 909fe5c:	e0bffe17 	ldw	r2,-8(fp)
 909fe60:	00c243b4 	movhi	r3,2318
 909fe64:	18f30d04 	addi	r3,r3,-13260
 909fe68:	10801324 	muli	r2,r2,76
 909fe6c:	10c5883a 	add	r2,r2,r3
 909fe70:	10c00a04 	addi	r3,r2,40
 909fe74:	00800044 	movi	r2,1
 909fe78:	18800015 	stw	r2,0(r3)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 909fe7c:	e0bffe17 	ldw	r2,-8(fp)
 909fe80:	00c243b4 	movhi	r3,2318
 909fe84:	18f30d04 	addi	r3,r3,-13260
 909fe88:	10801324 	muli	r2,r2,76
 909fe8c:	10c5883a 	add	r2,r2,r3
 909fe90:	10800104 	addi	r2,r2,4
 909fe94:	10800017 	ldw	r2,0(r2)
 909fe98:	10803b04 	addi	r2,r2,236
 909fe9c:	1007883a 	mov	r3,r2
 909fea0:	00808034 	movhi	r2,512
 909fea4:	18800035 	stwio	r2,0(r3)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 909fea8:	e0bffe17 	ldw	r2,-8(fp)
 909feac:	00c243b4 	movhi	r3,2318
 909feb0:	18f30d04 	addi	r3,r3,-13260
 909feb4:	10801324 	muli	r2,r2,76
 909feb8:	10c5883a 	add	r2,r2,r3
 909febc:	10800104 	addi	r2,r2,4
 909fec0:	10800017 	ldw	r2,0(r2)
 909fec4:	10803b04 	addi	r2,r2,236
 909fec8:	10800037 	ldwio	r2,0(r2)
 909fecc:	1080802c 	andhi	r2,r2,512
 909fed0:	1004c03a 	cmpne	r2,r2,zero
 909fed4:	10000f1e 	bne	r2,zero,909ff14 <tse_mac_init+0x73c>
 909fed8:	00001d06 	br	909ff50 <tse_mac_init+0x778>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 909fedc:	e0bffe17 	ldw	r2,-8(fp)
 909fee0:	00c243b4 	movhi	r3,2318
 909fee4:	18f30d04 	addi	r3,r3,-13260
 909fee8:	10801324 	muli	r2,r2,76
 909feec:	10c5883a 	add	r2,r2,r3
 909fef0:	10800a04 	addi	r2,r2,40
 909fef4:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 909fef8:	01024374 	movhi	r4,2317
 909fefc:	213b0a04 	addi	r4,r4,-5080
 909ff00:	01400084 	movi	r5,2
 909ff04:	90825100 	call	9082510 <printf>
      return ENP_LOGIC;
 909ff08:	00bffd44 	movi	r2,-11
 909ff0c:	e0bfff15 	stw	r2,-4(fp)
 909ff10:	0000e506 	br	90a02a8 <tse_mac_init+0xad0>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 909ff14:	e0bffe17 	ldw	r2,-8(fp)
 909ff18:	00c243b4 	movhi	r3,2318
 909ff1c:	18f30d04 	addi	r3,r3,-13260
 909ff20:	10801324 	muli	r2,r2,76
 909ff24:	10c5883a 	add	r2,r2,r3
 909ff28:	10c00b04 	addi	r3,r2,44
 909ff2c:	00800044 	movi	r2,1
 909ff30:	18800015 	stw	r2,0(r3)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 909ff34:	00810034 	movhi	r2,1024
 909ff38:	108080c4 	addi	r2,r2,515
 909ff3c:	e0bffd15 	stw	r2,-12(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 909ff40:	e0bffc17 	ldw	r2,-16(fp)
 909ff44:	10800060 	cmpeqi	r2,r2,1
 909ff48:	10000f1e 	bne	r2,zero,909ff88 <tse_mac_init+0x7b0>
 909ff4c:	00001706 	br	909ffac <tse_mac_init+0x7d4>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 909ff50:	e0bffe17 	ldw	r2,-8(fp)
 909ff54:	00c243b4 	movhi	r3,2318
 909ff58:	18f30d04 	addi	r3,r3,-13260
 909ff5c:	10801324 	muli	r2,r2,76
 909ff60:	10c5883a 	add	r2,r2,r3
 909ff64:	10800b04 	addi	r2,r2,44
 909ff68:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 909ff6c:	01024374 	movhi	r4,2317
 909ff70:	213b2204 	addi	r4,r4,-4984
 909ff74:	01400084 	movi	r5,2
 909ff78:	90825100 	call	9082510 <printf>
      return ENP_LOGIC;
 909ff7c:	00bffd44 	movi	r2,-11
 909ff80:	e0bfff15 	stw	r2,-4(fp)
 909ff84:	0000c806 	br	90a02a8 <tse_mac_init+0xad0>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909ff88:	e0bffd17 	ldw	r2,-12(fp)
 909ff8c:	10800214 	ori	r2,r2,8
 909ff90:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909ff94:	e0fffd17 	ldw	r3,-12(fp)
 909ff98:	00bf8034 	movhi	r2,65024
 909ff9c:	10bfffc4 	addi	r2,r2,-1
 909ffa0:	1884703a 	and	r2,r3,r2
 909ffa4:	e0bffd15 	stw	r2,-12(fp)
 909ffa8:	00002106 	br	90a0030 <tse_mac_init+0x858>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 909ffac:	e0bffc17 	ldw	r2,-16(fp)
 909ffb0:	10800098 	cmpnei	r2,r2,2
 909ffb4:	10000a1e 	bne	r2,zero,909ffe0 <tse_mac_init+0x808>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909ffb8:	e0fffd17 	ldw	r3,-12(fp)
 909ffbc:	00bffdc4 	movi	r2,-9
 909ffc0:	1884703a 	and	r2,r3,r2
 909ffc4:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909ffc8:	e0fffd17 	ldw	r3,-12(fp)
 909ffcc:	00bf8034 	movhi	r2,65024
 909ffd0:	10bfffc4 	addi	r2,r2,-1
 909ffd4:	1884703a 	and	r2,r3,r2
 909ffd8:	e0bffd15 	stw	r2,-12(fp)
 909ffdc:	00001406 	br	90a0030 <tse_mac_init+0x858>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 909ffe0:	e0bffc17 	ldw	r2,-16(fp)
 909ffe4:	10800118 	cmpnei	r2,r2,4
 909ffe8:	1000081e 	bne	r2,zero,90a000c <tse_mac_init+0x834>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909ffec:	e0fffd17 	ldw	r3,-12(fp)
 909fff0:	00bffdc4 	movi	r2,-9
 909fff4:	1884703a 	and	r2,r3,r2
 909fff8:	e0bffd15 	stw	r2,-12(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909fffc:	e0bffd17 	ldw	r2,-12(fp)
 90a0000:	10808034 	orhi	r2,r2,512
 90a0004:	e0bffd15 	stw	r2,-12(fp)
 90a0008:	00000906 	br	90a0030 <tse_mac_init+0x858>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 90a000c:	e0fffd17 	ldw	r3,-12(fp)
 90a0010:	00bffdc4 	movi	r2,-9
 90a0014:	1884703a 	and	r2,r3,r2
 90a0018:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 90a001c:	e0fffd17 	ldw	r3,-12(fp)
 90a0020:	00bf8034 	movhi	r2,65024
 90a0024:	10bfffc4 	addi	r2,r2,-1
 90a0028:	1884703a 	and	r2,r3,r2
 90a002c:	e0bffd15 	stw	r2,-12(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 90a0030:	e0bffb17 	ldw	r2,-20(fp)
 90a0034:	1004c03a 	cmpne	r2,r2,zero
 90a0038:	1000041e 	bne	r2,zero,90a004c <tse_mac_init+0x874>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 90a003c:	e0bffd17 	ldw	r2,-12(fp)
 90a0040:	10810014 	ori	r2,r2,1024
 90a0044:	e0bffd15 	stw	r2,-12(fp)
 90a0048:	00000406 	br	90a005c <tse_mac_init+0x884>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 90a004c:	e0bffd17 	ldw	r2,-12(fp)
 90a0050:	00feffc4 	movi	r3,-1025
 90a0054:	10c4703a 	and	r2,r2,r3
 90a0058:	e0bffd15 	stw	r2,-12(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 90a005c:	e0bffe17 	ldw	r2,-8(fp)
 90a0060:	00c243b4 	movhi	r3,2318
 90a0064:	18f30d04 	addi	r3,r3,-13260
 90a0068:	10801324 	muli	r2,r2,76
 90a006c:	10c5883a 	add	r2,r2,r3
 90a0070:	10800104 	addi	r2,r2,4
 90a0074:	10800017 	ldw	r2,0(r2)
 90a0078:	10800204 	addi	r2,r2,8
 90a007c:	1007883a 	mov	r3,r2
 90a0080:	e0bffd17 	ldw	r2,-12(fp)
 90a0084:	18800035 	stwio	r2,0(r3)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 90a0088:	e0bffe17 	ldw	r2,-8(fp)
 90a008c:	00c243b4 	movhi	r3,2318
 90a0090:	18f30d04 	addi	r3,r3,-13260
 90a0094:	10801324 	muli	r2,r2,76
 90a0098:	10c5883a 	add	r2,r2,r3
 90a009c:	10800104 	addi	r2,r2,4
 90a00a0:	10800017 	ldw	r2,0(r2)
 90a00a4:	10800204 	addi	r2,r2,8
 90a00a8:	11400037 	ldwio	r5,0(r2)
 90a00ac:	01024374 	movhi	r4,2317
 90a00b0:	213b3a04 	addi	r4,r4,-4888
 90a00b4:	90825100 	call	9082510 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 90a00b8:	e0bffe17 	ldw	r2,-8(fp)
 90a00bc:	00c243b4 	movhi	r3,2318
 90a00c0:	18f30d04 	addi	r3,r3,-13260
 90a00c4:	10801324 	muli	r2,r2,76
 90a00c8:	10c5883a 	add	r2,r2,r3
 90a00cc:	10800104 	addi	r2,r2,4
 90a00d0:	10800017 	ldw	r2,0(r2)
 90a00d4:	11400304 	addi	r5,r2,12
 90a00d8:	e0bffe17 	ldw	r2,-8(fp)
 90a00dc:	00c243b4 	movhi	r3,2318
 90a00e0:	18f30d04 	addi	r3,r3,-13260
 90a00e4:	10801324 	muli	r2,r2,76
 90a00e8:	10c5883a 	add	r2,r2,r3
 90a00ec:	10800604 	addi	r2,r2,24
 90a00f0:	10800003 	ldbu	r2,0(r2)
 90a00f4:	11003fcc 	andi	r4,r2,255
 90a00f8:	e0bffe17 	ldw	r2,-8(fp)
 90a00fc:	00c243b4 	movhi	r3,2318
 90a0100:	18f30d04 	addi	r3,r3,-13260
 90a0104:	10801324 	muli	r2,r2,76
 90a0108:	10c5883a 	add	r2,r2,r3
 90a010c:	10800644 	addi	r2,r2,25
 90a0110:	10800003 	ldbu	r2,0(r2)
 90a0114:	10803fcc 	andi	r2,r2,255
 90a0118:	1004923a 	slli	r2,r2,8
 90a011c:	2088b03a 	or	r4,r4,r2
 90a0120:	e0bffe17 	ldw	r2,-8(fp)
 90a0124:	00c243b4 	movhi	r3,2318
 90a0128:	18f30d04 	addi	r3,r3,-13260
 90a012c:	10801324 	muli	r2,r2,76
 90a0130:	10c5883a 	add	r2,r2,r3
 90a0134:	10800684 	addi	r2,r2,26
 90a0138:	10800003 	ldbu	r2,0(r2)
 90a013c:	10803fcc 	andi	r2,r2,255
 90a0140:	1004943a 	slli	r2,r2,16
 90a0144:	2088b03a 	or	r4,r4,r2
 90a0148:	e0bffe17 	ldw	r2,-8(fp)
 90a014c:	00c243b4 	movhi	r3,2318
 90a0150:	18f30d04 	addi	r3,r3,-13260
 90a0154:	10801324 	muli	r2,r2,76
 90a0158:	10c5883a 	add	r2,r2,r3
 90a015c:	108006c4 	addi	r2,r2,27
 90a0160:	10800003 	ldbu	r2,0(r2)
 90a0164:	10803fcc 	andi	r2,r2,255
 90a0168:	1004963a 	slli	r2,r2,24
 90a016c:	2086b03a 	or	r3,r4,r2
 90a0170:	2805883a 	mov	r2,r5
 90a0174:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 90a0178:	e0bffe17 	ldw	r2,-8(fp)
 90a017c:	00c243b4 	movhi	r3,2318
 90a0180:	18f30d04 	addi	r3,r3,-13260
 90a0184:	10801324 	muli	r2,r2,76
 90a0188:	10c5883a 	add	r2,r2,r3
 90a018c:	10800104 	addi	r2,r2,4
 90a0190:	10800017 	ldw	r2,0(r2)
 90a0194:	11400404 	addi	r5,r2,16
 90a0198:	e0bffe17 	ldw	r2,-8(fp)
 90a019c:	00c243b4 	movhi	r3,2318
 90a01a0:	18f30d04 	addi	r3,r3,-13260
 90a01a4:	10801324 	muli	r2,r2,76
 90a01a8:	10c5883a 	add	r2,r2,r3
 90a01ac:	10800704 	addi	r2,r2,28
 90a01b0:	10800003 	ldbu	r2,0(r2)
 90a01b4:	11003fcc 	andi	r4,r2,255
 90a01b8:	e0bffe17 	ldw	r2,-8(fp)
 90a01bc:	00c243b4 	movhi	r3,2318
 90a01c0:	18f30d04 	addi	r3,r3,-13260
 90a01c4:	10801324 	muli	r2,r2,76
 90a01c8:	10c5883a 	add	r2,r2,r3
 90a01cc:	10800744 	addi	r2,r2,29
 90a01d0:	10800003 	ldbu	r2,0(r2)
 90a01d4:	10803fcc 	andi	r2,r2,255
 90a01d8:	1004923a 	slli	r2,r2,8
 90a01dc:	2084b03a 	or	r2,r4,r2
 90a01e0:	10ffffcc 	andi	r3,r2,65535
 90a01e4:	2805883a 	mov	r2,r5
 90a01e8:	10c00035 	stwio	r3,0(r2)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 90a01ec:	e0bffe17 	ldw	r2,-8(fp)
 90a01f0:	00c243b4 	movhi	r3,2318
 90a01f4:	18f41e04 	addi	r3,r3,-12168
 90a01f8:	1085883a 	add	r2,r2,r2
 90a01fc:	1085883a 	add	r2,r2,r2
 90a0200:	10c5883a 	add	r2,r2,r3
 90a0204:	10800017 	ldw	r2,0(r2)
 90a0208:	10c02717 	ldw	r3,156(r2)
 90a020c:	00800044 	movi	r2,1
 90a0210:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 90a0214:	e0bffe17 	ldw	r2,-8(fp)
 90a0218:	00c243b4 	movhi	r3,2318
 90a021c:	18f41e04 	addi	r3,r3,-12168
 90a0220:	1085883a 	add	r2,r2,r2
 90a0224:	1085883a 	add	r2,r2,r2
 90a0228:	10c5883a 	add	r2,r2,r3
 90a022c:	10800017 	ldw	r2,0(r2)
 90a0230:	10c02717 	ldw	r3,156(r2)
 90a0234:	00800044 	movi	r2,1
 90a0238:	18800715 	stw	r2,28(r3)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 90a023c:	e0bffe17 	ldw	r2,-8(fp)
 90a0240:	00c243b4 	movhi	r3,2318
 90a0244:	18f30d04 	addi	r3,r3,-13260
 90a0248:	10801324 	muli	r2,r2,76
 90a024c:	10c5883a 	add	r2,r2,r3
 90a0250:	10800304 	addi	r2,r2,12
 90a0254:	11000017 	ldw	r4,0(r2)
 90a0258:	e0bffe17 	ldw	r2,-8(fp)
 90a025c:	10801324 	muli	r2,r2,76
 90a0260:	1007883a 	mov	r3,r2
 90a0264:	008243b4 	movhi	r2,2318
 90a0268:	10b30d04 	addi	r2,r2,-13260
 90a026c:	188f883a 	add	r7,r3,r2
 90a0270:	014242b4 	movhi	r5,2314
 90a0274:	29416e04 	addi	r5,r5,1464
 90a0278:	01800604 	movi	r6,24
 90a027c:	90996e00 	call	90996e0 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 90a0280:	e0bffe17 	ldw	r2,-8(fp)
 90a0284:	10801324 	muli	r2,r2,76
 90a0288:	1007883a 	mov	r3,r2
 90a028c:	008243b4 	movhi	r2,2318
 90a0290:	10b30d04 	addi	r2,r2,-13260
 90a0294:	1889883a 	add	r4,r3,r2
 90a0298:	90a06600 	call	90a0660 <tse_sgdma_read_init>
 90a029c:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 90a02a0:	e0bff817 	ldw	r2,-32(fp)
 90a02a4:	e0bfff15 	stw	r2,-4(fp)
 90a02a8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a02ac:	e037883a 	mov	sp,fp
 90a02b0:	dfc00117 	ldw	ra,4(sp)
 90a02b4:	df000017 	ldw	fp,0(sp)
 90a02b8:	dec00204 	addi	sp,sp,8
 90a02bc:	f800283a 	ret

090a02c0 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 90a02c0:	defe6304 	addi	sp,sp,-1652
 90a02c4:	dfc19c15 	stw	ra,1648(sp)
 90a02c8:	df019b15 	stw	fp,1644(sp)
 90a02cc:	df019b04 	addi	fp,sp,1644
 90a02d0:	e13ffc15 	stw	r4,-16(fp)
 90a02d4:	e17ffd15 	stw	r5,-12(fp)
 90a02d8:	e1bffe15 	stw	r6,-8(fp)
   int result,i,tx_length;
   unsigned len = data_bytes;
 90a02dc:	e0bffe17 	ldw	r2,-8(fp)
 90a02e0:	e0be7215 	stw	r2,-1592(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 90a02e4:	e0bffc17 	ldw	r2,-16(fp)
 90a02e8:	10802817 	ldw	r2,160(r2)
 90a02ec:	e0be7115 	stw	r2,-1596(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 90a02f0:	e0be7117 	ldw	r2,-1596(fp)
 90a02f4:	10801217 	ldw	r2,72(r2)
 90a02f8:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90a02fc:	0005303a 	rdctl	r2,status
 90a0300:	e0be6c15 	stw	r2,-1616(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90a0304:	e0fe6c17 	ldw	r3,-1616(fp)
 90a0308:	00bfff84 	movi	r2,-2
 90a030c:	1884703a 	and	r2,r3,r2
 90a0310:	1001703a 	wrctl	status,r2
  
  return context;
 90a0314:	e0be6c17 	ldw	r2,-1616(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 90a0318:	e0be6d15 	stw	r2,-1612(fp)
   mi = &tse_ptr->mi;
 90a031c:	e0be7117 	ldw	r2,-1596(fp)
 90a0320:	10800104 	addi	r2,r2,4
 90a0324:	e0be6f15 	stw	r2,-1604(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 90a0328:	e0be7117 	ldw	r2,-1596(fp)
 90a032c:	10800c17 	ldw	r2,48(r2)
 90a0330:	1005003a 	cmpeq	r2,r2,zero
 90a0334:	10000a1e 	bne	r2,zero,90a0360 <tse_mac_raw_send+0xa0>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 90a0338:	01024374 	movhi	r4,2317
 90a033c:	213b4604 	addi	r4,r4,-4840
 90a0340:	90828380 	call	9082838 <puts>
 90a0344:	e0be6d17 	ldw	r2,-1612(fp)
 90a0348:	e0be6b15 	stw	r2,-1620(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90a034c:	e0be6b17 	ldw	r2,-1620(fp)
 90a0350:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 90a0354:	00bffa84 	movi	r2,-22
 90a0358:	e0bfff15 	stw	r2,-4(fp)
 90a035c:	00009006 	br	90a05a0 <tse_mac_raw_send+0x2e0>
   }
 
   tse_ptr->sem = 1;  
 90a0360:	e0fe7117 	ldw	r3,-1596(fp)
 90a0364:	00800044 	movi	r2,1
 90a0368:	18800c15 	stw	r2,48(r3)

   if(((unsigned long)data & 0x03) == 0) 
 90a036c:	e0bffd17 	ldw	r2,-12(fp)
 90a0370:	108000cc 	andi	r2,r2,3
 90a0374:	1004c03a 	cmpne	r2,r2,zero
 90a0378:	1000031e 	bne	r2,zero,90a0388 <tse_mac_raw_send+0xc8>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 90a037c:	e0bffd17 	ldw	r2,-12(fp)
 90a0380:	e0be6e15 	stw	r2,-1608(fp)
 90a0384:	00001406 	br	90a03d8 <tse_mac_raw_send+0x118>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 90a0388:	e03e7415 	stw	zero,-1584(fp)
 90a038c:	00000d06 	br	90a03c4 <tse_mac_raw_send+0x104>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 90a0390:	e13e7417 	ldw	r4,-1584(fp)
 90a0394:	e0be7417 	ldw	r2,-1584(fp)
 90a0398:	1007883a 	mov	r3,r2
 90a039c:	e0bffd17 	ldw	r2,-12(fp)
 90a03a0:	1885883a 	add	r2,r3,r2
 90a03a4:	10800023 	ldbuio	r2,0(r2)
 90a03a8:	1007883a 	mov	r3,r2
 90a03ac:	e0be7604 	addi	r2,fp,-1576
 90a03b0:	1105883a 	add	r2,r2,r4
 90a03b4:	10c00005 	stb	r3,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 90a03b8:	e0be7417 	ldw	r2,-1584(fp)
 90a03bc:	10800044 	addi	r2,r2,1
 90a03c0:	e0be7415 	stw	r2,-1584(fp)
 90a03c4:	e0fe7417 	ldw	r3,-1584(fp)
 90a03c8:	e0be7217 	ldw	r2,-1592(fp)
 90a03cc:	18bff036 	bltu	r3,r2,90a0390 <tse_mac_raw_send+0xd0>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 90a03d0:	e0be7604 	addi	r2,fp,-1576
 90a03d4:	e0be6e15 	stw	r2,-1608(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 90a03d8:	e13e6e17 	ldw	r4,-1608(fp)
 90a03dc:	01400104 	movi	r5,4
 90a03e0:	90b98dc0 	call	90b98dc <alt_remap_cached>
 90a03e4:	e0be6e15 	stw	r2,-1608(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 90a03e8:	e0be7017 	ldw	r2,-1600(fp)
 90a03ec:	10800903 	ldbu	r2,36(r2)
 90a03f0:	10803fcc 	andi	r2,r2,255
 90a03f4:	10800058 	cmpnei	r2,r2,1
 90a03f8:	1000241e 	bne	r2,zero,90a048c <tse_mac_raw_send+0x1cc>
 90a03fc:	e0be7217 	ldw	r2,-1592(fp)
 90a0400:	108003f0 	cmpltui	r2,r2,15
 90a0404:	1000211e 	bne	r2,zero,90a048c <tse_mac_raw_send+0x1cc>
 90a0408:	e0be7017 	ldw	r2,-1600(fp)
 90a040c:	10800b17 	ldw	r2,44(r2)
 90a0410:	1007883a 	mov	r3,r2
 90a0414:	e0be7117 	ldw	r2,-1596(fp)
 90a0418:	10800d17 	ldw	r2,52(r2)
 90a041c:	1085883a 	add	r2,r2,r2
 90a0420:	1085883a 	add	r2,r2,r2
 90a0424:	1885883a 	add	r2,r3,r2
 90a0428:	10800037 	ldwio	r2,0(r2)
 90a042c:	10800388 	cmpgei	r2,r2,14
 90a0430:	1000161e 	bne	r2,zero,90a048c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 90a0434:	e0be7117 	ldw	r2,-1596(fp)
 90a0438:	11000f17 	ldw	r4,60(r2)
 90a043c:	e0be7117 	ldw	r2,-1596(fp)
 90a0440:	10800f17 	ldw	r2,60(r2)
 90a0444:	11400804 	addi	r5,r2,32
 90a0448:	e1be6e17 	ldw	r6,-1608(fp)
 90a044c:	e0be7217 	ldw	r2,-1592(fp)
 90a0450:	11ffffcc 	andi	r7,r2,65535
 90a0454:	d8000015 	stw	zero,0(sp)
 90a0458:	00800044 	movi	r2,1
 90a045c:	d8800115 	stw	r2,4(sp)
 90a0460:	00800044 	movi	r2,1
 90a0464:	d8800215 	stw	r2,8(sp)
 90a0468:	d8000315 	stw	zero,12(sp)
 90a046c:	90995e80 	call	90995e8 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 90a0470:	e0be7117 	ldw	r2,-1596(fp)
 90a0474:	11400f17 	ldw	r5,60(r2)
 90a0478:	e13e6f17 	ldw	r4,-1604(fp)
 90a047c:	909a1440 	call	909a144 <tse_mac_sTxWrite>
 90a0480:	e0be7315 	stw	r2,-1588(fp)
        result = 0;
 90a0484:	e03e7515 	stw	zero,-1580(fp)
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 90a0488:	00001b06 	br	90a04f8 <tse_mac_raw_send+0x238>
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 90a048c:	e0be7217 	ldw	r2,-1592(fp)
 90a0490:	108003f0 	cmpltui	r2,r2,15
 90a0494:	1000161e 	bne	r2,zero,90a04f0 <tse_mac_raw_send+0x230>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 90a0498:	e0be7117 	ldw	r2,-1596(fp)
 90a049c:	11000f17 	ldw	r4,60(r2)
 90a04a0:	e0be7117 	ldw	r2,-1596(fp)
 90a04a4:	10800f17 	ldw	r2,60(r2)
 90a04a8:	11400804 	addi	r5,r2,32
 90a04ac:	e1be6e17 	ldw	r6,-1608(fp)
 90a04b0:	e0be7217 	ldw	r2,-1592(fp)
 90a04b4:	11ffffcc 	andi	r7,r2,65535
 90a04b8:	d8000015 	stw	zero,0(sp)
 90a04bc:	00800044 	movi	r2,1
 90a04c0:	d8800115 	stw	r2,4(sp)
 90a04c4:	00800044 	movi	r2,1
 90a04c8:	d8800215 	stw	r2,8(sp)
 90a04cc:	d8000315 	stw	zero,12(sp)
 90a04d0:	90995e80 	call	90995e8 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 90a04d4:	e0be7117 	ldw	r2,-1596(fp)
 90a04d8:	11400f17 	ldw	r5,60(r2)
 90a04dc:	e13e6f17 	ldw	r4,-1604(fp)
 90a04e0:	909a1440 	call	909a144 <tse_mac_sTxWrite>
 90a04e4:	e0be7315 	stw	r2,-1588(fp)
       result = 0;
 90a04e8:	e03e7515 	stw	zero,-1580(fp)
 90a04ec:	00000206 	br	90a04f8 <tse_mac_raw_send+0x238>

   } else {
       result = -3;
 90a04f0:	00bfff44 	movi	r2,-3
 90a04f4:	e0be7515 	stw	r2,-1580(fp)
   }

   if(result < 0)   /* SGDMA not available */
 90a04f8:	e0be7517 	ldw	r2,-1580(fp)
 90a04fc:	1004403a 	cmpge	r2,r2,zero
 90a0500:	1000131e 	bne	r2,zero,90a0550 <tse_mac_raw_send+0x290>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 90a0504:	01024374 	movhi	r4,2317
 90a0508:	213b4d04 	addi	r4,r4,-4812
 90a050c:	e17e7517 	ldw	r5,-1580(fp)
 90a0510:	e1be7217 	ldw	r6,-1592(fp)
 90a0514:	90825100 	call	9082510 <printf>
      net->n_mib->ifOutDiscards++;
 90a0518:	e0bffc17 	ldw	r2,-16(fp)
 90a051c:	10c02717 	ldw	r3,156(r2)
 90a0520:	18801217 	ldw	r2,72(r3)
 90a0524:	10800044 	addi	r2,r2,1
 90a0528:	18801215 	stw	r2,72(r3)
      tse_ptr->sem = 0;
 90a052c:	e0be7117 	ldw	r2,-1596(fp)
 90a0530:	10000c15 	stw	zero,48(r2)
 90a0534:	e0be6d17 	ldw	r2,-1612(fp)
 90a0538:	e0be6a15 	stw	r2,-1624(fp)
 90a053c:	e0be6a17 	ldw	r2,-1624(fp)
 90a0540:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 90a0544:	00bffa84 	movi	r2,-22
 90a0548:	e0bfff15 	stw	r2,-4(fp)
 90a054c:	00001406 	br	90a05a0 <tse_mac_raw_send+0x2e0>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 90a0550:	e0bffc17 	ldw	r2,-16(fp)
 90a0554:	11002717 	ldw	r4,156(r2)
 90a0558:	e0bffc17 	ldw	r2,-16(fp)
 90a055c:	10802717 	ldw	r2,156(r2)
 90a0560:	10c00f17 	ldw	r3,60(r2)
 90a0564:	e0bffe17 	ldw	r2,-8(fp)
 90a0568:	1885883a 	add	r2,r3,r2
 90a056c:	20800f15 	stw	r2,60(r4)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 90a0570:	e0bffc17 	ldw	r2,-16(fp)
 90a0574:	10c02717 	ldw	r3,156(r2)
 90a0578:	18801017 	ldw	r2,64(r3)
 90a057c:	10800044 	addi	r2,r2,1
 90a0580:	18801015 	stw	r2,64(r3)
      tse_ptr->sem = 0;
 90a0584:	e0be7117 	ldw	r2,-1596(fp)
 90a0588:	10000c15 	stw	zero,48(r2)
 90a058c:	e0be6d17 	ldw	r2,-1612(fp)
 90a0590:	e0be6915 	stw	r2,-1628(fp)
 90a0594:	e0be6917 	ldw	r2,-1628(fp)
 90a0598:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 90a059c:	e03fff15 	stw	zero,-4(fp)
 90a05a0:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a05a4:	e037883a 	mov	sp,fp
 90a05a8:	dfc00117 	ldw	ra,4(sp)
 90a05ac:	df000017 	ldw	fp,0(sp)
 90a05b0:	dec00204 	addi	sp,sp,8
 90a05b4:	f800283a 	ret

090a05b8 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 90a05b8:	defffa04 	addi	sp,sp,-24
 90a05bc:	dfc00515 	stw	ra,20(sp)
 90a05c0:	df000415 	stw	fp,16(sp)
 90a05c4:	df000404 	addi	fp,sp,16
 90a05c8:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 90a05cc:	e0bfff17 	ldw	r2,-4(fp)
 90a05d0:	e0bffe15 	stw	r2,-8(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 90a05d4:	008243b4 	movhi	r2,2318
 90a05d8:	10b35904 	addi	r2,r2,-12956
 90a05dc:	10800217 	ldw	r2,8(r2)
 90a05e0:	e0bffc15 	stw	r2,-16(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 90a05e4:	e0bffe17 	ldw	r2,-8(fp)
 90a05e8:	10800317 	ldw	r2,12(r2)
 90a05ec:	10800317 	ldw	r2,12(r2)
 90a05f0:	10800037 	ldwio	r2,0(r2)
 90a05f4:	e0bffd05 	stb	r2,-12(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 90a05f8:	e0bffd03 	ldbu	r2,-12(fp)
 90a05fc:	1080030c 	andi	r2,r2,12
 90a0600:	1005003a 	cmpeq	r2,r2,zero
 90a0604:	1000111e 	bne	r2,zero,90a064c <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 90a0608:	e13ffe17 	ldw	r4,-8(fp)
 90a060c:	90a08080 	call	90a0808 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 90a0610:	e0bffe17 	ldw	r2,-8(fp)
 90a0614:	11000317 	ldw	r4,12(r2)
 90a0618:	e0bffe17 	ldw	r2,-8(fp)
 90a061c:	10800f17 	ldw	r2,60(r2)
 90a0620:	11401004 	addi	r5,r2,64
 90a0624:	90991d40 	call	90991d4 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 90a0628:	008243b4 	movhi	r2,2318
 90a062c:	10b35904 	addi	r2,r2,-12956
 90a0630:	10c00217 	ldw	r3,8(r2)
 90a0634:	e0bffc17 	ldw	r2,-16(fp)
 90a0638:	10c0040e 	bge	r2,r3,90a064c <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 90a063c:	00824374 	movhi	r2,2317
 90a0640:	108c4504 	addi	r2,r2,12564
 90a0644:	11000017 	ldw	r4,0(r2)
 90a0648:	90930640 	call	9093064 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 90a064c:	e037883a 	mov	sp,fp
 90a0650:	dfc00117 	ldw	ra,4(sp)
 90a0654:	df000017 	ldw	fp,0(sp)
 90a0658:	dec00204 	addi	sp,sp,8
 90a065c:	f800283a 	ret

090a0660 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 90a0660:	defff904 	addi	sp,sp,-28
 90a0664:	dfc00615 	stw	ra,24(sp)
 90a0668:	df000515 	stw	fp,20(sp)
 90a066c:	dc000415 	stw	r16,16(sp)
 90a0670:	df000404 	addi	fp,sp,16
 90a0674:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 90a0678:	e0bffe17 	ldw	r2,-8(fp)
 90a067c:	10000e15 	stw	zero,56(r2)
 90a0680:	00004406 	br	90a0794 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 90a0684:	e0bffe17 	ldw	r2,-8(fp)
 90a0688:	14000e17 	ldw	r16,56(r2)
 90a068c:	01017f04 	movi	r4,1532
 90a0690:	90a88440 	call	90a8844 <pk_alloc>
 90a0694:	1009883a 	mov	r4,r2
 90a0698:	e0fffe17 	ldw	r3,-8(fp)
 90a069c:	8405883a 	add	r2,r16,r16
 90a06a0:	1085883a 	add	r2,r2,r2
 90a06a4:	10c5883a 	add	r2,r2,r3
 90a06a8:	10801104 	addi	r2,r2,68
 90a06ac:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 90a06b0:	e0bffe17 	ldw	r2,-8(fp)
 90a06b4:	10800e17 	ldw	r2,56(r2)
 90a06b8:	e0fffe17 	ldw	r3,-8(fp)
 90a06bc:	1085883a 	add	r2,r2,r2
 90a06c0:	1085883a 	add	r2,r2,r2
 90a06c4:	10c5883a 	add	r2,r2,r3
 90a06c8:	10801104 	addi	r2,r2,68
 90a06cc:	10800017 	ldw	r2,0(r2)
 90a06d0:	1004c03a 	cmpne	r2,r2,zero
 90a06d4:	10000c1e 	bne	r2,zero,90a0708 <tse_sgdma_read_init+0xa8>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 90a06d8:	01024374 	movhi	r4,2317
 90a06dc:	213b5904 	addi	r4,r4,-4764
 90a06e0:	90828380 	call	9082838 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 90a06e4:	e0bffe17 	ldw	r2,-8(fp)
 90a06e8:	10800817 	ldw	r2,32(r2)
 90a06ec:	10c02717 	ldw	r3,156(r2)
 90a06f0:	18800c17 	ldw	r2,48(r3)
 90a06f4:	10800044 	addi	r2,r2,1
 90a06f8:	18800c15 	stw	r2,48(r3)
      
      return ENP_NOBUFFER;
 90a06fc:	00bffac4 	movi	r2,-21
 90a0700:	e0bfff15 	stw	r2,-4(fp)
 90a0704:	00003906 	br	90a07ec <tse_sgdma_read_init+0x18c>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 90a0708:	e0bffe17 	ldw	r2,-8(fp)
 90a070c:	10800e17 	ldw	r2,56(r2)
 90a0710:	e0fffe17 	ldw	r3,-8(fp)
 90a0714:	1085883a 	add	r2,r2,r2
 90a0718:	1085883a 	add	r2,r2,r2
 90a071c:	10c5883a 	add	r2,r2,r3
 90a0720:	10801104 	addi	r2,r2,68
 90a0724:	10800017 	ldw	r2,0(r2)
 90a0728:	11000117 	ldw	r4,4(r2)
 90a072c:	01400104 	movi	r5,4
 90a0730:	90b98dc0 	call	90b98dc <alt_remap_cached>
 90a0734:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 90a0738:	e0bffe17 	ldw	r2,-8(fp)
 90a073c:	10c00f17 	ldw	r3,60(r2)
 90a0740:	e0bffe17 	ldw	r2,-8(fp)
 90a0744:	10800e17 	ldw	r2,56(r2)
 90a0748:	1004917a 	slli	r2,r2,5
 90a074c:	1885883a 	add	r2,r3,r2
 90a0750:	11001004 	addi	r4,r2,64
 90a0754:	e0bffe17 	ldw	r2,-8(fp)
 90a0758:	10c00f17 	ldw	r3,60(r2)
 90a075c:	e0bffe17 	ldw	r2,-8(fp)
 90a0760:	10800e17 	ldw	r2,56(r2)
 90a0764:	1004917a 	slli	r2,r2,5
 90a0768:	1885883a 	add	r2,r3,r2
 90a076c:	11401804 	addi	r5,r2,96
 90a0770:	d8000015 	stw	zero,0(sp)
 90a0774:	e1bffd17 	ldw	r6,-12(fp)
 90a0778:	000f883a 	mov	r7,zero
 90a077c:	90995240 	call	9099524 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 90a0780:	e0bffe17 	ldw	r2,-8(fp)
 90a0784:	10800e17 	ldw	r2,56(r2)
 90a0788:	10c00044 	addi	r3,r2,1
 90a078c:	e0bffe17 	ldw	r2,-8(fp)
 90a0790:	10c00e15 	stw	r3,56(r2)
 90a0794:	e0bffe17 	ldw	r2,-8(fp)
 90a0798:	10800e17 	ldw	r2,56(r2)
 90a079c:	10800050 	cmplti	r2,r2,1
 90a07a0:	103fb81e 	bne	r2,zero,90a0684 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 90a07a4:	e0bffe17 	ldw	r2,-8(fp)
 90a07a8:	11400e17 	ldw	r5,56(r2)
 90a07ac:	01024374 	movhi	r4,2317
 90a07b0:	213b6a04 	addi	r4,r4,-4696
 90a07b4:	90825100 	call	9082510 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 90a07b8:	e0bffe17 	ldw	r2,-8(fp)
 90a07bc:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 90a07c0:	e0bffe17 	ldw	r2,-8(fp)
 90a07c4:	10800f17 	ldw	r2,60(r2)
 90a07c8:	10c01004 	addi	r3,r2,64
 90a07cc:	e0bffe17 	ldw	r2,-8(fp)
 90a07d0:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 90a07d4:	e0bffe17 	ldw	r2,-8(fp)
 90a07d8:	11000104 	addi	r4,r2,4
 90a07dc:	e0bffe17 	ldw	r2,-8(fp)
 90a07e0:	11401017 	ldw	r5,64(r2)
 90a07e4:	909a2340 	call	909a234 <tse_mac_aRxRead>
  
  return SUCCESS;
 90a07e8:	e03fff15 	stw	zero,-4(fp)
 90a07ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90a07f0:	e037883a 	mov	sp,fp
 90a07f4:	dfc00217 	ldw	ra,8(sp)
 90a07f8:	df000117 	ldw	fp,4(sp)
 90a07fc:	dc000017 	ldw	r16,0(sp)
 90a0800:	dec00304 	addi	sp,sp,12
 90a0804:	f800283a 	ret

090a0808 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 90a0808:	defff704 	addi	sp,sp,-36
 90a080c:	dfc00815 	stw	ra,32(sp)
 90a0810:	df000715 	stw	fp,28(sp)
 90a0814:	df000704 	addi	fp,sp,28
 90a0818:	e13fff15 	stw	r4,-4(fp)
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 90a081c:	e0bfff17 	ldw	r2,-4(fp)
 90a0820:	10c00f17 	ldw	r3,60(r2)
 90a0824:	e0bfff17 	ldw	r2,-4(fp)
 90a0828:	10800e17 	ldw	r2,56(r2)
 90a082c:	1004917a 	slli	r2,r2,5
 90a0830:	1885883a 	add	r2,r3,r2
 90a0834:	10c01004 	addi	r3,r2,64
 90a0838:	e0bfff17 	ldw	r2,-4(fp)
 90a083c:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 90a0840:	e0bfff17 	ldw	r2,-4(fp)
 90a0844:	10801017 	ldw	r2,64(r2)
 90a0848:	10800704 	addi	r2,r2,28
 90a084c:	10800037 	ldwio	r2,0(r2)
 90a0850:	1005d43a 	srai	r2,r2,16
 90a0854:	1007883a 	mov	r3,r2
 90a0858:	00bfffc4 	movi	r2,-1
 90a085c:	1884703a 	and	r2,r3,r2
 90a0860:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 90a0864:	e0bfff17 	ldw	r2,-4(fp)
 90a0868:	10801017 	ldw	r2,64(r2)
 90a086c:	10800704 	addi	r2,r2,28
 90a0870:	1080002b 	ldhuio	r2,0(r2)
 90a0874:	10bfff84 	addi	r2,r2,-2
 90a0878:	e0bffd15 	stw	r2,-12(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 90a087c:	e0bfff17 	ldw	r2,-4(fp)
 90a0880:	10800817 	ldw	r2,32(r2)
 90a0884:	11002717 	ldw	r4,156(r2)
 90a0888:	e0bfff17 	ldw	r2,-4(fp)
 90a088c:	10800817 	ldw	r2,32(r2)
 90a0890:	10802717 	ldw	r2,156(r2)
 90a0894:	10c00917 	ldw	r3,36(r2)
 90a0898:	e0bffd17 	ldw	r2,-12(fp)
 90a089c:	1885883a 	add	r2,r3,r2
 90a08a0:	20800915 	stw	r2,36(r4)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 90a08a4:	e0bfff17 	ldw	r2,-4(fp)
 90a08a8:	10800e17 	ldw	r2,56(r2)
 90a08ac:	e0ffff17 	ldw	r3,-4(fp)
 90a08b0:	1085883a 	add	r2,r2,r2
 90a08b4:	1085883a 	add	r2,r2,r2
 90a08b8:	10c5883a 	add	r2,r2,r3
 90a08bc:	10801104 	addi	r2,r2,68
 90a08c0:	10800017 	ldw	r2,0(r2)
 90a08c4:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 90a08c8:	e0bffb17 	ldw	r2,-20(fp)
 90a08cc:	10800117 	ldw	r2,4(r2)
 90a08d0:	10c00404 	addi	r3,r2,16
 90a08d4:	e0bffb17 	ldw	r2,-20(fp)
 90a08d8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 90a08dc:	e0bffd17 	ldw	r2,-12(fp)
 90a08e0:	10bffc84 	addi	r2,r2,-14
 90a08e4:	1007883a 	mov	r3,r2
 90a08e8:	e0bffb17 	ldw	r2,-20(fp)
 90a08ec:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 90a08f0:	00824374 	movhi	r2,2317
 90a08f4:	108c4204 	addi	r2,r2,12552
 90a08f8:	10800017 	ldw	r2,0(r2)
 90a08fc:	1007883a 	mov	r3,r2
 90a0900:	e0bffb17 	ldw	r2,-20(fp)
 90a0904:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 90a0908:	e0bfff17 	ldw	r2,-4(fp)
 90a090c:	10c00817 	ldw	r3,32(r2)
 90a0910:	e0bffb17 	ldw	r2,-20(fp)
 90a0914:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 90a0918:	e0bffb17 	ldw	r2,-20(fp)
 90a091c:	10800117 	ldw	r2,4(r2)
 90a0920:	10800084 	addi	r2,r2,2
 90a0924:	e0bffe15 	stw	r2,-8(fp)
    rx_packet->type = eth->e_type;
 90a0928:	e0bffe17 	ldw	r2,-8(fp)
 90a092c:	10c0030b 	ldhu	r3,12(r2)
 90a0930:	e0bffb17 	ldw	r2,-20(fp)
 90a0934:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 90a0938:	e0bff903 	ldbu	r2,-28(fp)
 90a093c:	10801fcc 	andi	r2,r2,127
 90a0940:	1004c03a 	cmpne	r2,r2,zero
 90a0944:	1000251e 	bne	r2,zero,90a09dc <tse_mac_rcv+0x1d4>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 90a0948:	01017f04 	movi	r4,1532
 90a094c:	90a88440 	call	90a8844 <pk_alloc>
 90a0950:	e0bffc15 	stw	r2,-16(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 90a0954:	e0bffc17 	ldw	r2,-16(fp)
 90a0958:	1004c03a 	cmpne	r2,r2,zero
 90a095c:	10000a1e 	bne	r2,zero,90a0988 <tse_mac_rcv+0x180>
        dprintf("No free buffers for rx\n");
 90a0960:	01024374 	movhi	r4,2317
 90a0964:	213b7b04 	addi	r4,r4,-4628
 90a0968:	90828380 	call	9082838 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 90a096c:	e0bfff17 	ldw	r2,-4(fp)
 90a0970:	10800817 	ldw	r2,32(r2)
 90a0974:	10c02717 	ldw	r3,156(r2)
 90a0978:	18800c17 	ldw	r2,48(r3)
 90a097c:	10800044 	addi	r2,r2,1
 90a0980:	18800c15 	stw	r2,48(r3)
 90a0984:	00001806 	br	90a09e8 <tse_mac_rcv+0x1e0>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 90a0988:	e0bfff17 	ldw	r2,-4(fp)
 90a098c:	10800e17 	ldw	r2,56(r2)
 90a0990:	e0ffff17 	ldw	r3,-4(fp)
 90a0994:	1085883a 	add	r2,r2,r2
 90a0998:	1085883a 	add	r2,r2,r2
 90a099c:	10c5883a 	add	r2,r2,r3
 90a09a0:	10801104 	addi	r2,r2,68
 90a09a4:	11400017 	ldw	r5,0(r2)
 90a09a8:	010243b4 	movhi	r4,2318
 90a09ac:	21335904 	addi	r4,r4,-12956
 90a09b0:	90a8e180 	call	90a8e18 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 90a09b4:	e0bfff17 	ldw	r2,-4(fp)
 90a09b8:	10800e17 	ldw	r2,56(r2)
 90a09bc:	e0ffff17 	ldw	r3,-4(fp)
 90a09c0:	1085883a 	add	r2,r2,r2
 90a09c4:	1085883a 	add	r2,r2,r2
 90a09c8:	10c5883a 	add	r2,r2,r3
 90a09cc:	10c01104 	addi	r3,r2,68
 90a09d0:	e0bffc17 	ldw	r2,-16(fp)
 90a09d4:	18800015 	stw	r2,0(r3)
 90a09d8:	00000306 	br	90a09e8 <tse_mac_rcv+0x1e0>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 90a09dc:	01024374 	movhi	r4,2317
 90a09e0:	213b8104 	addi	r4,r4,-4604
 90a09e4:	90828380 	call	9082838 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 90a09e8:	e0bfff17 	ldw	r2,-4(fp)
 90a09ec:	10800e17 	ldw	r2,56(r2)
 90a09f0:	e0ffff17 	ldw	r3,-4(fp)
 90a09f4:	1085883a 	add	r2,r2,r2
 90a09f8:	1085883a 	add	r2,r2,r2
 90a09fc:	10c5883a 	add	r2,r2,r3
 90a0a00:	10801104 	addi	r2,r2,68
 90a0a04:	10800017 	ldw	r2,0(r2)
 90a0a08:	11000117 	ldw	r4,4(r2)
 90a0a0c:	01400104 	movi	r5,4
 90a0a10:	90b98dc0 	call	90b98dc <alt_remap_cached>
 90a0a14:	e0bffa15 	stw	r2,-24(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 90a0a18:	e0bfff17 	ldw	r2,-4(fp)
 90a0a1c:	10801017 	ldw	r2,64(r2)
 90a0a20:	10800204 	addi	r2,r2,8
 90a0a24:	e0fffa17 	ldw	r3,-24(fp)
 90a0a28:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 90a0a2c:	e0bfff17 	ldw	r2,-4(fp)
 90a0a30:	10801017 	ldw	r2,64(r2)
 90a0a34:	10800704 	addi	r2,r2,28
 90a0a38:	1007883a 	mov	r3,r2
 90a0a3c:	00a04034 	movhi	r2,33024
 90a0a40:	18800035 	stwio	r2,0(r3)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 90a0a44:	e037883a 	mov	sp,fp
 90a0a48:	dfc00117 	ldw	ra,4(sp)
 90a0a4c:	df000017 	ldw	fp,0(sp)
 90a0a50:	dec00204 	addi	sp,sp,8
 90a0a54:	f800283a 	ret

090a0a58 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 90a0a58:	defffc04 	addi	sp,sp,-16
 90a0a5c:	dfc00315 	stw	ra,12(sp)
 90a0a60:	df000215 	stw	fp,8(sp)
 90a0a64:	df000204 	addi	fp,sp,8
 90a0a68:	e13ffe15 	stw	r4,-8(fp)
 90a0a6c:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 90a0a70:	e13ffe17 	ldw	r4,-8(fp)
 90a0a74:	01424374 	movhi	r5,2317
 90a0a78:	297b8d04 	addi	r5,r5,-4556
 90a0a7c:	90a45b40 	call	90a45b4 <ns_printf>
   return SUCCESS;
 90a0a80:	0005883a 	mov	r2,zero
}
 90a0a84:	e037883a 	mov	sp,fp
 90a0a88:	dfc00117 	ldw	ra,4(sp)
 90a0a8c:	df000017 	ldw	fp,0(sp)
 90a0a90:	dec00204 	addi	sp,sp,8
 90a0a94:	f800283a 	ret

090a0a98 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 90a0a98:	defffc04 	addi	sp,sp,-16
 90a0a9c:	dfc00315 	stw	ra,12(sp)
 90a0aa0:	df000215 	stw	fp,8(sp)
 90a0aa4:	df000204 	addi	fp,sp,8
 90a0aa8:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 90a0aac:	e0bfff17 	ldw	r2,-4(fp)
 90a0ab0:	00c243b4 	movhi	r3,2318
 90a0ab4:	18f41e04 	addi	r3,r3,-12168
 90a0ab8:	1085883a 	add	r2,r2,r2
 90a0abc:	1085883a 	add	r2,r2,r2
 90a0ac0:	10c5883a 	add	r2,r2,r3
 90a0ac4:	10800017 	ldw	r2,0(r2)
 90a0ac8:	10c02717 	ldw	r3,156(r2)
 90a0acc:	00800084 	movi	r2,2
 90a0ad0:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 90a0ad4:	e0bfff17 	ldw	r2,-4(fp)
 90a0ad8:	00c243b4 	movhi	r3,2318
 90a0adc:	18f30d04 	addi	r3,r3,-13260
 90a0ae0:	10801324 	muli	r2,r2,76
 90a0ae4:	10c5883a 	add	r2,r2,r3
 90a0ae8:	10800304 	addi	r2,r2,12
 90a0aec:	11000017 	ldw	r4,0(r2)
 90a0af0:	000b883a 	mov	r5,zero
 90a0af4:	000d883a 	mov	r6,zero
 90a0af8:	000f883a 	mov	r7,zero
 90a0afc:	90996e00 	call	90996e0 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 90a0b00:	e0bfff17 	ldw	r2,-4(fp)
 90a0b04:	00c243b4 	movhi	r3,2318
 90a0b08:	18f30d04 	addi	r3,r3,-13260
 90a0b0c:	10801324 	muli	r2,r2,76
 90a0b10:	10c5883a 	add	r2,r2,r3
 90a0b14:	10800104 	addi	r2,r2,4
 90a0b18:	10800017 	ldw	r2,0(r2)
 90a0b1c:	10800204 	addi	r2,r2,8
 90a0b20:	10800037 	ldwio	r2,0(r2)
 90a0b24:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 90a0b28:	e0bfff17 	ldw	r2,-4(fp)
 90a0b2c:	00c243b4 	movhi	r3,2318
 90a0b30:	18f30d04 	addi	r3,r3,-13260
 90a0b34:	10801324 	muli	r2,r2,76
 90a0b38:	10c5883a 	add	r2,r2,r3
 90a0b3c:	10800104 	addi	r2,r2,4
 90a0b40:	10800017 	ldw	r2,0(r2)
 90a0b44:	11000204 	addi	r4,r2,8
 90a0b48:	e0fffe17 	ldw	r3,-8(fp)
 90a0b4c:	00bfff44 	movi	r2,-3
 90a0b50:	1886703a 	and	r3,r3,r2
 90a0b54:	2005883a 	mov	r2,r4
 90a0b58:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 90a0b5c:	e0bfff17 	ldw	r2,-4(fp)
 90a0b60:	00c243b4 	movhi	r3,2318
 90a0b64:	18f41e04 	addi	r3,r3,-12168
 90a0b68:	1085883a 	add	r2,r2,r2
 90a0b6c:	1085883a 	add	r2,r2,r2
 90a0b70:	10c5883a 	add	r2,r2,r3
 90a0b74:	10800017 	ldw	r2,0(r2)
 90a0b78:	10c02717 	ldw	r3,156(r2)
 90a0b7c:	00800084 	movi	r2,2
 90a0b80:	18800715 	stw	r2,28(r3)

  return SUCCESS;
 90a0b84:	0005883a 	mov	r2,zero
}
 90a0b88:	e037883a 	mov	sp,fp
 90a0b8c:	dfc00117 	ldw	ra,4(sp)
 90a0b90:	df000017 	ldw	fp,0(sp)
 90a0b94:	dec00204 	addi	sp,sp,8
 90a0b98:	f800283a 	ret

090a0b9c <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 90a0b9c:	defffc04 	addi	sp,sp,-16
 90a0ba0:	dfc00315 	stw	ra,12(sp)
 90a0ba4:	df000215 	stw	fp,8(sp)
 90a0ba8:	df000204 	addi	fp,sp,8
 90a0bac:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 90a0bb0:	e0bffe17 	ldw	r2,-8(fp)
 90a0bb4:	10800808 	cmpgei	r2,r2,32
 90a0bb8:	1000041e 	bne	r2,zero,90a0bcc <close+0x30>
 90a0bbc:	e13ffe17 	ldw	r4,-8(fp)
 90a0bc0:	90b8af00 	call	90b8af0 <alt_close>
 90a0bc4:	e0bfff15 	stw	r2,-4(fp)
 90a0bc8:	00000306 	br	90a0bd8 <close+0x3c>
 90a0bcc:	e13ffe17 	ldw	r4,-8(fp)
 90a0bd0:	90adb300 	call	90adb30 <t_socketclose>
 90a0bd4:	e0bfff15 	stw	r2,-4(fp)
 90a0bd8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a0bdc:	e037883a 	mov	sp,fp
 90a0be0:	dfc00117 	ldw	ra,4(sp)
 90a0be4:	df000017 	ldw	fp,0(sp)
 90a0be8:	dec00204 	addi	sp,sp,8
 90a0bec:	f800283a 	ret

090a0bf0 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 90a0bf0:	defff504 	addi	sp,sp,-44
 90a0bf4:	dfc00a15 	stw	ra,40(sp)
 90a0bf8:	df000915 	stw	fp,36(sp)
 90a0bfc:	df000904 	addi	fp,sp,36
 90a0c00:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 90a0c04:	d0a02c17 	ldw	r2,-32592(gp)
 90a0c08:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 90a0c0c:	d0a02c04 	addi	r2,gp,-32592
 90a0c10:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 90a0c14:	00003e06 	br	90a0d10 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 90a0c18:	e0fffa17 	ldw	r3,-24(fp)
 90a0c1c:	e0bffa17 	ldw	r2,-24(fp)
 90a0c20:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 90a0c24:	e0fffa17 	ldw	r3,-24(fp)
 90a0c28:	e0bfff17 	ldw	r2,-4(fp)
 90a0c2c:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 90a0c30:	e0bffa17 	ldw	r2,-24(fp)
 90a0c34:	10800517 	ldw	r2,20(r2)
 90a0c38:	00c243b4 	movhi	r3,2318
 90a0c3c:	18f41e04 	addi	r3,r3,-12168
 90a0c40:	1085883a 	add	r2,r2,r2
 90a0c44:	1085883a 	add	r2,r2,r2
 90a0c48:	10c5883a 	add	r2,r2,r3
 90a0c4c:	10c00017 	ldw	r3,0(r2)
 90a0c50:	e0bffa17 	ldw	r2,-24(fp)
 90a0c54:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 90a0c58:	e0bffa17 	ldw	r2,-24(fp)
 90a0c5c:	10800317 	ldw	r2,12(r2)
 90a0c60:	e13ffa17 	ldw	r4,-24(fp)
 90a0c64:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 90a0c68:	e0bffa17 	ldw	r2,-24(fp)
 90a0c6c:	10800617 	ldw	r2,24(r2)
 90a0c70:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 90a0c74:	e17ffb04 	addi	r5,fp,-20
 90a0c78:	e1bffc04 	addi	r6,fp,-16
 90a0c7c:	e1fffd04 	addi	r7,fp,-12
 90a0c80:	e0bffe04 	addi	r2,fp,-8
 90a0c84:	d8800015 	stw	r2,0(sp)
 90a0c88:	e13ffa17 	ldw	r4,-24(fp)
 90a0c8c:	90813380 	call	9081338 <get_ip_addr>
 90a0c90:	1005003a 	cmpeq	r2,r2,zero
 90a0c94:	1000181e 	bne	r2,zero,90a0cf8 <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 90a0c98:	e0bffe17 	ldw	r2,-8(fp)
 90a0c9c:	1005003a 	cmpeq	r2,r2,zero
 90a0ca0:	1000051e 	bne	r2,zero,90a0cb8 <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 90a0ca4:	e0bff817 	ldw	r2,-32(fp)
 90a0ca8:	10802a17 	ldw	r2,168(r2)
 90a0cac:	10c04014 	ori	r3,r2,256
 90a0cb0:	e0bff817 	ldw	r2,-32(fp)
 90a0cb4:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 90a0cb8:	e0fffb17 	ldw	r3,-20(fp)
 90a0cbc:	e0bff817 	ldw	r2,-32(fp)
 90a0cc0:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 90a0cc4:	e0fffc17 	ldw	r3,-16(fp)
 90a0cc8:	e0bff817 	ldw	r2,-32(fp)
 90a0ccc:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 90a0cd0:	e0fffd17 	ldw	r3,-12(fp)
 90a0cd4:	e0bff817 	ldw	r2,-32(fp)
 90a0cd8:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 90a0cdc:	e0fff817 	ldw	r3,-32(fp)
 90a0ce0:	00824334 	movhi	r2,2316
 90a0ce4:	10ac0004 	addi	r2,r2,-20480
 90a0ce8:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 90a0cec:	e0fff817 	ldw	r3,-32(fp)
 90a0cf0:	00800084 	movi	r2,2
 90a0cf4:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 90a0cf8:	e0bfff17 	ldw	r2,-4(fp)
 90a0cfc:	10800044 	addi	r2,r2,1
 90a0d00:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 90a0d04:	e0bffa17 	ldw	r2,-24(fp)
 90a0d08:	10800017 	ldw	r2,0(r2)
 90a0d0c:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 90a0d10:	e0fffa17 	ldw	r3,-24(fp)
 90a0d14:	e0bff917 	ldw	r2,-28(fp)
 90a0d18:	18bfbf1e 	bne	r3,r2,90a0c18 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 90a0d1c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a0d20:	e037883a 	mov	sp,fp
 90a0d24:	dfc00117 	ldw	ra,4(sp)
 90a0d28:	df000017 	ldw	fp,0(sp)
 90a0d2c:	dec00204 	addi	sp,sp,8
 90a0d30:	f800283a 	ret

090a0d34 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 90a0d34:	defff804 	addi	sp,sp,-32
 90a0d38:	dfc00715 	stw	ra,28(sp)
 90a0d3c:	df000615 	stw	fp,24(sp)
 90a0d40:	df000604 	addi	fp,sp,24
 90a0d44:	e13ffc15 	stw	r4,-16(fp)
 90a0d48:	e17ffd15 	stw	r5,-12(fp)
 90a0d4c:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 90a0d50:	e0bffc17 	ldw	r2,-16(fp)
 90a0d54:	10800808 	cmpgei	r2,r2,32
 90a0d58:	1000061e 	bne	r2,zero,90a0d74 <read+0x40>
 90a0d5c:	e13ffc17 	ldw	r4,-16(fp)
 90a0d60:	e17ffd17 	ldw	r5,-12(fp)
 90a0d64:	e1bffe17 	ldw	r6,-8(fp)
 90a0d68:	90b96fc0 	call	90b96fc <alt_read>
 90a0d6c:	e0bfff15 	stw	r2,-4(fp)
 90a0d70:	00000806 	br	90a0d94 <read+0x60>
 90a0d74:	e1bffe17 	ldw	r6,-8(fp)
 90a0d78:	d8000015 	stw	zero,0(sp)
 90a0d7c:	d8000115 	stw	zero,4(sp)
 90a0d80:	e13ffc17 	ldw	r4,-16(fp)
 90a0d84:	e17ffd17 	ldw	r5,-12(fp)
 90a0d88:	000f883a 	mov	r7,zero
 90a0d8c:	90a3a3c0 	call	90a3a3c <bsd_recvfrom>
 90a0d90:	e0bfff15 	stw	r2,-4(fp)
 90a0d94:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 90a0d98:	e037883a 	mov	sp,fp
 90a0d9c:	dfc00117 	ldw	ra,4(sp)
 90a0da0:	df000017 	ldw	fp,0(sp)
 90a0da4:	dec00204 	addi	sp,sp,8
 90a0da8:	f800283a 	ret

090a0dac <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 90a0dac:	defffa04 	addi	sp,sp,-24
 90a0db0:	dfc00515 	stw	ra,20(sp)
 90a0db4:	df000415 	stw	fp,16(sp)
 90a0db8:	df000404 	addi	fp,sp,16
 90a0dbc:	e13ffc15 	stw	r4,-16(fp)
 90a0dc0:	e17ffd15 	stw	r5,-12(fp)
 90a0dc4:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 90a0dc8:	e0bffc17 	ldw	r2,-16(fp)
 90a0dcc:	10800808 	cmpgei	r2,r2,32
 90a0dd0:	1000061e 	bne	r2,zero,90a0dec <write+0x40>
  {
    return alt_write (fd, ptr, len);
 90a0dd4:	e13ffc17 	ldw	r4,-16(fp)
 90a0dd8:	e17ffd17 	ldw	r5,-12(fp)
 90a0ddc:	e1bffe17 	ldw	r6,-8(fp)
 90a0de0:	90b9cc40 	call	90b9cc4 <alt_write>
 90a0de4:	e0bfff15 	stw	r2,-4(fp)
 90a0de8:	00000606 	br	90a0e04 <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 90a0dec:	e17ffd17 	ldw	r5,-12(fp)
 90a0df0:	e1bffe17 	ldw	r6,-8(fp)
 90a0df4:	e13ffc17 	ldw	r4,-16(fp)
 90a0df8:	000f883a 	mov	r7,zero
 90a0dfc:	90ad8240 	call	90ad824 <t_send>
 90a0e00:	e0bfff15 	stw	r2,-4(fp)
 90a0e04:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 90a0e08:	e037883a 	mov	sp,fp
 90a0e0c:	dfc00117 	ldw	ra,4(sp)
 90a0e10:	df000017 	ldw	fp,0(sp)
 90a0e14:	dec00204 	addi	sp,sp,8
 90a0e18:	f800283a 	ret

090a0e1c <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 90a0e1c:	defff704 	addi	sp,sp,-36
 90a0e20:	dfc00815 	stw	ra,32(sp)
 90a0e24:	df000715 	stw	fp,28(sp)
 90a0e28:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 90a0e2c:	e03ffa15 	stw	zero,-24(fp)
 90a0e30:	00005806 	br	90a0f94 <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 90a0e34:	e0bffa17 	ldw	r2,-24(fp)
 90a0e38:	00c243b4 	movhi	r3,2318
 90a0e3c:	18f41e04 	addi	r3,r3,-12168
 90a0e40:	1085883a 	add	r2,r2,r2
 90a0e44:	1085883a 	add	r2,r2,r2
 90a0e48:	10c5883a 	add	r2,r2,r3
 90a0e4c:	10800017 	ldw	r2,0(r2)
 90a0e50:	10802717 	ldw	r2,156(r2)
 90a0e54:	10800217 	ldw	r2,8(r2)
 90a0e58:	10800198 	cmpnei	r2,r2,6
 90a0e5c:	1000261e 	bne	r2,zero,90a0ef8 <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 90a0e60:	e0bffa17 	ldw	r2,-24(fp)
 90a0e64:	00c243b4 	movhi	r3,2318
 90a0e68:	18f41e04 	addi	r3,r3,-12168
 90a0e6c:	1085883a 	add	r2,r2,r2
 90a0e70:	1085883a 	add	r2,r2,r2
 90a0e74:	10c5883a 	add	r2,r2,r3
 90a0e78:	10800017 	ldw	r2,0(r2)
 90a0e7c:	10800917 	ldw	r2,36(r2)
 90a0e80:	1004c03a 	cmpne	r2,r2,zero
 90a0e84:	1000091e 	bne	r2,zero,90a0eac <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 90a0e88:	e0bffa17 	ldw	r2,-24(fp)
 90a0e8c:	00c243b4 	movhi	r3,2318
 90a0e90:	18f41e04 	addi	r3,r3,-12168
 90a0e94:	1085883a 	add	r2,r2,r2
 90a0e98:	1085883a 	add	r2,r2,r2
 90a0e9c:	10c5883a 	add	r2,r2,r3
 90a0ea0:	10c00017 	ldw	r3,0(r2)
 90a0ea4:	00817a84 	movi	r2,1514
 90a0ea8:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 90a0eac:	e0bffa17 	ldw	r2,-24(fp)
 90a0eb0:	00c243b4 	movhi	r3,2318
 90a0eb4:	18f41e04 	addi	r3,r3,-12168
 90a0eb8:	1085883a 	add	r2,r2,r2
 90a0ebc:	1085883a 	add	r2,r2,r2
 90a0ec0:	10c5883a 	add	r2,r2,r3
 90a0ec4:	10800017 	ldw	r2,0(r2)
 90a0ec8:	10800817 	ldw	r2,32(r2)
 90a0ecc:	1004c03a 	cmpne	r2,r2,zero
 90a0ed0:	1000091e 	bne	r2,zero,90a0ef8 <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 90a0ed4:	e0bffa17 	ldw	r2,-24(fp)
 90a0ed8:	00c243b4 	movhi	r3,2318
 90a0edc:	18f41e04 	addi	r3,r3,-12168
 90a0ee0:	1085883a 	add	r2,r2,r2
 90a0ee4:	1085883a 	add	r2,r2,r2
 90a0ee8:	10c5883a 	add	r2,r2,r3
 90a0eec:	10c00017 	ldw	r3,0(r2)
 90a0ef0:	00800404 	movi	r2,16
 90a0ef4:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 90a0ef8:	e0bffa17 	ldw	r2,-24(fp)
 90a0efc:	00c243b4 	movhi	r3,2318
 90a0f00:	18f41e04 	addi	r3,r3,-12168
 90a0f04:	1085883a 	add	r2,r2,r2
 90a0f08:	1085883a 	add	r2,r2,r2
 90a0f0c:	10c5883a 	add	r2,r2,r3
 90a0f10:	10800017 	ldw	r2,0(r2)
 90a0f14:	10800817 	ldw	r2,32(r2)
 90a0f18:	d0e08117 	ldw	r3,-32252(gp)
 90a0f1c:	e0ffff15 	stw	r3,-4(fp)
 90a0f20:	e0bffe15 	stw	r2,-8(fp)
 90a0f24:	e0bffe17 	ldw	r2,-8(fp)
 90a0f28:	e0ffff17 	ldw	r3,-4(fp)
 90a0f2c:	10c0020e 	bge	r2,r3,90a0f38 <Netinit+0x11c>
 90a0f30:	e0bfff17 	ldw	r2,-4(fp)
 90a0f34:	e0bffe15 	stw	r2,-8(fp)
 90a0f38:	e0fffe17 	ldw	r3,-8(fp)
 90a0f3c:	d0e08115 	stw	r3,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 90a0f40:	e0bffa17 	ldw	r2,-24(fp)
 90a0f44:	00c243b4 	movhi	r3,2318
 90a0f48:	18f41e04 	addi	r3,r3,-12168
 90a0f4c:	1085883a 	add	r2,r2,r2
 90a0f50:	1085883a 	add	r2,r2,r2
 90a0f54:	10c5883a 	add	r2,r2,r3
 90a0f58:	10800017 	ldw	r2,0(r2)
 90a0f5c:	10800917 	ldw	r2,36(r2)
 90a0f60:	d0e08217 	ldw	r3,-32248(gp)
 90a0f64:	e0fffd15 	stw	r3,-12(fp)
 90a0f68:	e0bffc15 	stw	r2,-16(fp)
 90a0f6c:	e0bffc17 	ldw	r2,-16(fp)
 90a0f70:	e0fffd17 	ldw	r3,-12(fp)
 90a0f74:	10c0020e 	bge	r2,r3,90a0f80 <Netinit+0x164>
 90a0f78:	e0bffd17 	ldw	r2,-12(fp)
 90a0f7c:	e0bffc15 	stw	r2,-16(fp)
 90a0f80:	e0fffc17 	ldw	r3,-16(fp)
 90a0f84:	d0e08215 	stw	r3,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 90a0f88:	e0bffa17 	ldw	r2,-24(fp)
 90a0f8c:	10800044 	addi	r2,r2,1
 90a0f90:	e0bffa15 	stw	r2,-24(fp)
 90a0f94:	00824374 	movhi	r2,2317
 90a0f98:	108c1e04 	addi	r2,r2,12408
 90a0f9c:	10800017 	ldw	r2,0(r2)
 90a0fa0:	1007883a 	mov	r3,r2
 90a0fa4:	e0bffa17 	ldw	r2,-24(fp)
 90a0fa8:	10ffa216 	blt	r2,r3,90a0e34 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 90a0fac:	008243b4 	movhi	r2,2318
 90a0fb0:	10b35904 	addi	r2,r2,-12956
 90a0fb4:	10000115 	stw	zero,4(r2)
 90a0fb8:	008243b4 	movhi	r2,2318
 90a0fbc:	10b35904 	addi	r2,r2,-12956
 90a0fc0:	10c00117 	ldw	r3,4(r2)
 90a0fc4:	008243b4 	movhi	r2,2318
 90a0fc8:	10b35904 	addi	r2,r2,-12956
 90a0fcc:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 90a0fd0:	008243b4 	movhi	r2,2318
 90a0fd4:	10b35904 	addi	r2,r2,-12956
 90a0fd8:	10000215 	stw	zero,8(r2)
 90a0fdc:	008243b4 	movhi	r2,2318
 90a0fe0:	10b35904 	addi	r2,r2,-12956
 90a0fe4:	10c00217 	ldw	r3,8(r2)
 90a0fe8:	008243b4 	movhi	r2,2318
 90a0fec:	10b35904 	addi	r2,r2,-12956
 90a0ff0:	10c00415 	stw	r3,16(r2)
 90a0ff4:	008243b4 	movhi	r2,2318
 90a0ff8:	10b35904 	addi	r2,r2,-12956
 90a0ffc:	10c00417 	ldw	r3,16(r2)
 90a1000:	008243b4 	movhi	r2,2318
 90a1004:	10b35904 	addi	r2,r2,-12956
 90a1008:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a100c:	01000084 	movi	r4,2
 90a1010:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   e = pk_init();
 90a1014:	90a85b40 	call	90a85b4 <pk_init>
 90a1018:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a101c:	01000084 	movi	r4,2
 90a1020:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 90a1024:	e0bff917 	ldw	r2,-28(fp)
 90a1028:	1005003a 	cmpeq	r2,r2,zero
 90a102c:	1000031e 	bne	r2,zero,90a103c <Netinit+0x220>
      return e;
 90a1030:	e0bff917 	ldw	r2,-28(fp)
 90a1034:	e0bffb15 	stw	r2,-20(fp)
 90a1038:	00010506 	br	90a1450 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 90a103c:	010242b4 	movhi	r4,2314
 90a1040:	21057204 	addi	r4,r4,5576
 90a1044:	90a1fdc0 	call	90a1fdc <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 90a1048:	e03ffa15 	stw	zero,-24(fp)
 90a104c:	0000f906 	br	90a1434 <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 90a1050:	e0bffa17 	ldw	r2,-24(fp)
 90a1054:	00c243b4 	movhi	r3,2318
 90a1058:	18f41e04 	addi	r3,r3,-12168
 90a105c:	1085883a 	add	r2,r2,r2
 90a1060:	1085883a 	add	r2,r2,r2
 90a1064:	10c5883a 	add	r2,r2,r3
 90a1068:	10800017 	ldw	r2,0(r2)
 90a106c:	10800217 	ldw	r2,8(r2)
 90a1070:	1005003a 	cmpeq	r2,r2,zero
 90a1074:	1000931e 	bne	r2,zero,90a12c4 <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 90a1078:	e0bffa17 	ldw	r2,-24(fp)
 90a107c:	00c243b4 	movhi	r3,2318
 90a1080:	18f41e04 	addi	r3,r3,-12168
 90a1084:	1085883a 	add	r2,r2,r2
 90a1088:	1085883a 	add	r2,r2,r2
 90a108c:	10c5883a 	add	r2,r2,r3
 90a1090:	10800017 	ldw	r2,0(r2)
 90a1094:	10800217 	ldw	r2,8(r2)
 90a1098:	e13ffa17 	ldw	r4,-24(fp)
 90a109c:	103ee83a 	callr	r2
 90a10a0:	e0bff915 	stw	r2,-28(fp)
 90a10a4:	e0bff917 	ldw	r2,-28(fp)
 90a10a8:	1005003a 	cmpeq	r2,r2,zero
 90a10ac:	1000101e 	bne	r2,zero,90a10f0 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 90a10b0:	01024374 	movhi	r4,2317
 90a10b4:	213b9904 	addi	r4,r4,-4508
 90a10b8:	e17ff917 	ldw	r5,-28(fp)
 90a10bc:	e1bffa17 	ldw	r6,-24(fp)
 90a10c0:	90825100 	call	9082510 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 90a10c4:	e0bffa17 	ldw	r2,-24(fp)
 90a10c8:	00c243b4 	movhi	r3,2318
 90a10cc:	18f41e04 	addi	r3,r3,-12168
 90a10d0:	1085883a 	add	r2,r2,r2
 90a10d4:	1085883a 	add	r2,r2,r2
 90a10d8:	10c5883a 	add	r2,r2,r3
 90a10dc:	10800017 	ldw	r2,0(r2)
 90a10e0:	10c02717 	ldw	r3,156(r2)
 90a10e4:	00800084 	movi	r2,2
 90a10e8:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 90a10ec:	0000ce06 	br	90a1428 <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 90a10f0:	e0bffa17 	ldw	r2,-24(fp)
 90a10f4:	00c243b4 	movhi	r3,2318
 90a10f8:	18f41e04 	addi	r3,r3,-12168
 90a10fc:	1085883a 	add	r2,r2,r2
 90a1100:	1085883a 	add	r2,r2,r2
 90a1104:	10c5883a 	add	r2,r2,r3
 90a1108:	10800017 	ldw	r2,0(r2)
 90a110c:	10802717 	ldw	r2,156(r2)
 90a1110:	10800217 	ldw	r2,8(r2)
 90a1114:	10800198 	cmpnei	r2,r2,6
 90a1118:	1000111e 	bne	r2,zero,90a1160 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 90a111c:	e0bffa17 	ldw	r2,-24(fp)
 90a1120:	00c243b4 	movhi	r3,2318
 90a1124:	18f41e04 	addi	r3,r3,-12168
 90a1128:	1085883a 	add	r2,r2,r2
 90a112c:	1085883a 	add	r2,r2,r2
 90a1130:	10c5883a 	add	r2,r2,r3
 90a1134:	11000017 	ldw	r4,0(r2)
 90a1138:	e0bffa17 	ldw	r2,-24(fp)
 90a113c:	00c243b4 	movhi	r3,2318
 90a1140:	18f41e04 	addi	r3,r3,-12168
 90a1144:	1085883a 	add	r2,r2,r2
 90a1148:	1085883a 	add	r2,r2,r2
 90a114c:	10c5883a 	add	r2,r2,r3
 90a1150:	10800017 	ldw	r2,0(r2)
 90a1154:	10802a17 	ldw	r2,168(r2)
 90a1158:	10800054 	ori	r2,r2,1
 90a115c:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 90a1160:	e0bffa17 	ldw	r2,-24(fp)
 90a1164:	00c243b4 	movhi	r3,2318
 90a1168:	18f41e04 	addi	r3,r3,-12168
 90a116c:	1085883a 	add	r2,r2,r2
 90a1170:	1085883a 	add	r2,r2,r2
 90a1174:	10c5883a 	add	r2,r2,r3
 90a1178:	10800017 	ldw	r2,0(r2)
 90a117c:	10c02717 	ldw	r3,156(r2)
 90a1180:	00800044 	movi	r2,1
 90a1184:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 90a1188:	e0bffa17 	ldw	r2,-24(fp)
 90a118c:	00c243b4 	movhi	r3,2318
 90a1190:	18f41e04 	addi	r3,r3,-12168
 90a1194:	1085883a 	add	r2,r2,r2
 90a1198:	1085883a 	add	r2,r2,r2
 90a119c:	10c5883a 	add	r2,r2,r3
 90a11a0:	10800017 	ldw	r2,0(r2)
 90a11a4:	10800103 	ldbu	r2,4(r2)
 90a11a8:	10803fcc 	andi	r2,r2,255
 90a11ac:	1080201c 	xori	r2,r2,128
 90a11b0:	10bfe004 	addi	r2,r2,-128
 90a11b4:	1004c03a 	cmpne	r2,r2,zero
 90a11b8:	1000421e 	bne	r2,zero,90a12c4 <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 90a11bc:	e0bffa17 	ldw	r2,-24(fp)
 90a11c0:	00c243b4 	movhi	r3,2318
 90a11c4:	18f41e04 	addi	r3,r3,-12168
 90a11c8:	1085883a 	add	r2,r2,r2
 90a11cc:	1085883a 	add	r2,r2,r2
 90a11d0:	10c5883a 	add	r2,r2,r3
 90a11d4:	10800017 	ldw	r2,0(r2)
 90a11d8:	10802717 	ldw	r2,156(r2)
 90a11dc:	10800217 	ldw	r2,8(r2)
 90a11e0:	10800198 	cmpnei	r2,r2,6
 90a11e4:	1000131e 	bne	r2,zero,90a1234 <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 90a11e8:	e0bffa17 	ldw	r2,-24(fp)
 90a11ec:	00c243b4 	movhi	r3,2318
 90a11f0:	18f41e04 	addi	r3,r3,-12168
 90a11f4:	1085883a 	add	r2,r2,r2
 90a11f8:	1085883a 	add	r2,r2,r2
 90a11fc:	10c5883a 	add	r2,r2,r3
 90a1200:	10c00017 	ldw	r3,0(r2)
 90a1204:	00801944 	movi	r2,101
 90a1208:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 90a120c:	e0bffa17 	ldw	r2,-24(fp)
 90a1210:	00c243b4 	movhi	r3,2318
 90a1214:	18f41e04 	addi	r3,r3,-12168
 90a1218:	1085883a 	add	r2,r2,r2
 90a121c:	1085883a 	add	r2,r2,r2
 90a1220:	10c5883a 	add	r2,r2,r3
 90a1224:	10c00017 	ldw	r3,0(r2)
 90a1228:	00801d04 	movi	r2,116
 90a122c:	18800145 	stb	r2,5(r3)
 90a1230:	00001206 	br	90a127c <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 90a1234:	e0bffa17 	ldw	r2,-24(fp)
 90a1238:	00c243b4 	movhi	r3,2318
 90a123c:	18f41e04 	addi	r3,r3,-12168
 90a1240:	1085883a 	add	r2,r2,r2
 90a1244:	1085883a 	add	r2,r2,r2
 90a1248:	10c5883a 	add	r2,r2,r3
 90a124c:	10c00017 	ldw	r3,0(r2)
 90a1250:	00801a44 	movi	r2,105
 90a1254:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 90a1258:	e0bffa17 	ldw	r2,-24(fp)
 90a125c:	00c243b4 	movhi	r3,2318
 90a1260:	18f41e04 	addi	r3,r3,-12168
 90a1264:	1085883a 	add	r2,r2,r2
 90a1268:	1085883a 	add	r2,r2,r2
 90a126c:	10c5883a 	add	r2,r2,r3
 90a1270:	10c00017 	ldw	r3,0(r2)
 90a1274:	00801984 	movi	r2,102
 90a1278:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 90a127c:	e0bffa17 	ldw	r2,-24(fp)
 90a1280:	00c243b4 	movhi	r3,2318
 90a1284:	18f41e04 	addi	r3,r3,-12168
 90a1288:	1085883a 	add	r2,r2,r2
 90a128c:	1085883a 	add	r2,r2,r2
 90a1290:	10c5883a 	add	r2,r2,r3
 90a1294:	10c00017 	ldw	r3,0(r2)
 90a1298:	e0bffa17 	ldw	r2,-24(fp)
 90a129c:	10800c44 	addi	r2,r2,49
 90a12a0:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 90a12a4:	e0bffa17 	ldw	r2,-24(fp)
 90a12a8:	00c243b4 	movhi	r3,2318
 90a12ac:	18f41e04 	addi	r3,r3,-12168
 90a12b0:	1085883a 	add	r2,r2,r2
 90a12b4:	1085883a 	add	r2,r2,r2
 90a12b8:	10c5883a 	add	r2,r2,r3
 90a12bc:	10800017 	ldw	r2,0(r2)
 90a12c0:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 90a12c4:	e13ffa17 	ldw	r4,-24(fp)
 90a12c8:	90a14680 	call	90a1468 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 90a12cc:	e0bffa17 	ldw	r2,-24(fp)
 90a12d0:	00c243b4 	movhi	r3,2318
 90a12d4:	18f41e04 	addi	r3,r3,-12168
 90a12d8:	1085883a 	add	r2,r2,r2
 90a12dc:	1085883a 	add	r2,r2,r2
 90a12e0:	10c5883a 	add	r2,r2,r3
 90a12e4:	10800017 	ldw	r2,0(r2)
 90a12e8:	10800a17 	ldw	r2,40(r2)
 90a12ec:	1005003a 	cmpeq	r2,r2,zero
 90a12f0:	10004d1e 	bne	r2,zero,90a1428 <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 90a12f4:	e0bffa17 	ldw	r2,-24(fp)
 90a12f8:	00c243b4 	movhi	r3,2318
 90a12fc:	18f41e04 	addi	r3,r3,-12168
 90a1300:	1085883a 	add	r2,r2,r2
 90a1304:	1085883a 	add	r2,r2,r2
 90a1308:	10c5883a 	add	r2,r2,r3
 90a130c:	11400017 	ldw	r5,0(r2)
 90a1310:	e0bffa17 	ldw	r2,-24(fp)
 90a1314:	00c243b4 	movhi	r3,2318
 90a1318:	18f41e04 	addi	r3,r3,-12168
 90a131c:	1085883a 	add	r2,r2,r2
 90a1320:	1085883a 	add	r2,r2,r2
 90a1324:	10c5883a 	add	r2,r2,r3
 90a1328:	10800017 	ldw	r2,0(r2)
 90a132c:	11000a17 	ldw	r4,40(r2)
 90a1330:	e0bffa17 	ldw	r2,-24(fp)
 90a1334:	00c243b4 	movhi	r3,2318
 90a1338:	18f41e04 	addi	r3,r3,-12168
 90a133c:	1085883a 	add	r2,r2,r2
 90a1340:	1085883a 	add	r2,r2,r2
 90a1344:	10c5883a 	add	r2,r2,r3
 90a1348:	10800017 	ldw	r2,0(r2)
 90a134c:	10800c17 	ldw	r2,48(r2)
 90a1350:	0084303a 	nor	r2,zero,r2
 90a1354:	2084b03a 	or	r2,r4,r2
 90a1358:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 90a135c:	e0bffa17 	ldw	r2,-24(fp)
 90a1360:	00c243b4 	movhi	r3,2318
 90a1364:	18f41e04 	addi	r3,r3,-12168
 90a1368:	1085883a 	add	r2,r2,r2
 90a136c:	1085883a 	add	r2,r2,r2
 90a1370:	10c5883a 	add	r2,r2,r3
 90a1374:	11400017 	ldw	r5,0(r2)
 90a1378:	e0bffa17 	ldw	r2,-24(fp)
 90a137c:	00c243b4 	movhi	r3,2318
 90a1380:	18f41e04 	addi	r3,r3,-12168
 90a1384:	1085883a 	add	r2,r2,r2
 90a1388:	1085883a 	add	r2,r2,r2
 90a138c:	10c5883a 	add	r2,r2,r3
 90a1390:	10800017 	ldw	r2,0(r2)
 90a1394:	11000a17 	ldw	r4,40(r2)
 90a1398:	e0bffa17 	ldw	r2,-24(fp)
 90a139c:	00c243b4 	movhi	r3,2318
 90a13a0:	18f41e04 	addi	r3,r3,-12168
 90a13a4:	1085883a 	add	r2,r2,r2
 90a13a8:	1085883a 	add	r2,r2,r2
 90a13ac:	10c5883a 	add	r2,r2,r3
 90a13b0:	10800017 	ldw	r2,0(r2)
 90a13b4:	10800c17 	ldw	r2,48(r2)
 90a13b8:	2084703a 	and	r2,r4,r2
 90a13bc:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 90a13c0:	e0bffa17 	ldw	r2,-24(fp)
 90a13c4:	00c243b4 	movhi	r3,2318
 90a13c8:	18f41e04 	addi	r3,r3,-12168
 90a13cc:	1085883a 	add	r2,r2,r2
 90a13d0:	1085883a 	add	r2,r2,r2
 90a13d4:	10c5883a 	add	r2,r2,r3
 90a13d8:	11400017 	ldw	r5,0(r2)
 90a13dc:	e0bffa17 	ldw	r2,-24(fp)
 90a13e0:	00c243b4 	movhi	r3,2318
 90a13e4:	18f41e04 	addi	r3,r3,-12168
 90a13e8:	1085883a 	add	r2,r2,r2
 90a13ec:	1085883a 	add	r2,r2,r2
 90a13f0:	10c5883a 	add	r2,r2,r3
 90a13f4:	10800017 	ldw	r2,0(r2)
 90a13f8:	11000a17 	ldw	r4,40(r2)
 90a13fc:	e0bffa17 	ldw	r2,-24(fp)
 90a1400:	00c243b4 	movhi	r3,2318
 90a1404:	18f41e04 	addi	r3,r3,-12168
 90a1408:	1085883a 	add	r2,r2,r2
 90a140c:	1085883a 	add	r2,r2,r2
 90a1410:	10c5883a 	add	r2,r2,r3
 90a1414:	10800017 	ldw	r2,0(r2)
 90a1418:	10800c17 	ldw	r2,48(r2)
 90a141c:	0084303a 	nor	r2,zero,r2
 90a1420:	2084b03a 	or	r2,r4,r2
 90a1424:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 90a1428:	e0bffa17 	ldw	r2,-24(fp)
 90a142c:	10800044 	addi	r2,r2,1
 90a1430:	e0bffa15 	stw	r2,-24(fp)
 90a1434:	00824374 	movhi	r2,2317
 90a1438:	108c1e04 	addi	r2,r2,12408
 90a143c:	10800017 	ldw	r2,0(r2)
 90a1440:	1007883a 	mov	r3,r2
 90a1444:	e0bffa17 	ldw	r2,-24(fp)
 90a1448:	10ff0116 	blt	r2,r3,90a1050 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 90a144c:	e03ffb15 	stw	zero,-20(fp)
 90a1450:	e0bffb17 	ldw	r2,-20(fp)
}
 90a1454:	e037883a 	mov	sp,fp
 90a1458:	dfc00117 	ldw	ra,4(sp)
 90a145c:	df000017 	ldw	fp,0(sp)
 90a1460:	dec00204 	addi	sp,sp,8
 90a1464:	f800283a 	ret

090a1468 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 90a1468:	defffc04 	addi	sp,sp,-16
 90a146c:	dfc00315 	stw	ra,12(sp)
 90a1470:	df000215 	stw	fp,8(sp)
 90a1474:	df000204 	addi	fp,sp,8
 90a1478:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 90a147c:	e0bfff17 	ldw	r2,-4(fp)
 90a1480:	00c243b4 	movhi	r3,2318
 90a1484:	18f41e04 	addi	r3,r3,-12168
 90a1488:	1085883a 	add	r2,r2,r2
 90a148c:	1085883a 	add	r2,r2,r2
 90a1490:	10c5883a 	add	r2,r2,r3
 90a1494:	10800017 	ldw	r2,0(r2)
 90a1498:	10800c17 	ldw	r2,48(r2)
 90a149c:	1004c03a 	cmpne	r2,r2,zero
 90a14a0:	1000441e 	bne	r2,zero,90a15b4 <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 90a14a4:	e0bfff17 	ldw	r2,-4(fp)
 90a14a8:	00c243b4 	movhi	r3,2318
 90a14ac:	18f41e04 	addi	r3,r3,-12168
 90a14b0:	1085883a 	add	r2,r2,r2
 90a14b4:	1085883a 	add	r2,r2,r2
 90a14b8:	10c5883a 	add	r2,r2,r3
 90a14bc:	10800017 	ldw	r2,0(r2)
 90a14c0:	10800a17 	ldw	r2,40(r2)
 90a14c4:	1080200c 	andi	r2,r2,128
 90a14c8:	1004c03a 	cmpne	r2,r2,zero
 90a14cc:	1000031e 	bne	r2,zero,90a14dc <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 90a14d0:	00bfc034 	movhi	r2,65280
 90a14d4:	e0bffe15 	stw	r2,-8(fp)
 90a14d8:	00001f06 	br	90a1558 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 90a14dc:	e0bfff17 	ldw	r2,-4(fp)
 90a14e0:	00c243b4 	movhi	r3,2318
 90a14e4:	18f41e04 	addi	r3,r3,-12168
 90a14e8:	1085883a 	add	r2,r2,r2
 90a14ec:	1085883a 	add	r2,r2,r2
 90a14f0:	10c5883a 	add	r2,r2,r3
 90a14f4:	10800017 	ldw	r2,0(r2)
 90a14f8:	10800a17 	ldw	r2,40(r2)
 90a14fc:	1080300c 	andi	r2,r2,192
 90a1500:	10802018 	cmpnei	r2,r2,128
 90a1504:	1000031e 	bne	r2,zero,90a1514 <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 90a1508:	00bffff4 	movhi	r2,65535
 90a150c:	e0bffe15 	stw	r2,-8(fp)
 90a1510:	00001106 	br	90a1558 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 90a1514:	e0bfff17 	ldw	r2,-4(fp)
 90a1518:	00c243b4 	movhi	r3,2318
 90a151c:	18f41e04 	addi	r3,r3,-12168
 90a1520:	1085883a 	add	r2,r2,r2
 90a1524:	1085883a 	add	r2,r2,r2
 90a1528:	10c5883a 	add	r2,r2,r3
 90a152c:	10800017 	ldw	r2,0(r2)
 90a1530:	10800a17 	ldw	r2,40(r2)
 90a1534:	1080380c 	andi	r2,r2,224
 90a1538:	10803018 	cmpnei	r2,r2,192
 90a153c:	1000031e 	bne	r2,zero,90a154c <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 90a1540:	00bfc004 	movi	r2,-256
 90a1544:	e0bffe15 	stw	r2,-8(fp)
 90a1548:	00000306 	br	90a1558 <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 90a154c:	90a94880 	call	90a9488 <dtrap>
      smask = 0xFFFFFF00L;
 90a1550:	00bfc004 	movi	r2,-256
 90a1554:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 90a1558:	e0bfff17 	ldw	r2,-4(fp)
 90a155c:	00c243b4 	movhi	r3,2318
 90a1560:	18f41e04 	addi	r3,r3,-12168
 90a1564:	1085883a 	add	r2,r2,r2
 90a1568:	1085883a 	add	r2,r2,r2
 90a156c:	10c5883a 	add	r2,r2,r3
 90a1570:	11000017 	ldw	r4,0(r2)
 90a1574:	e0bffe17 	ldw	r2,-8(fp)
 90a1578:	1004d63a 	srli	r2,r2,24
 90a157c:	10c03fcc 	andi	r3,r2,255
 90a1580:	e0bffe17 	ldw	r2,-8(fp)
 90a1584:	1004d23a 	srli	r2,r2,8
 90a1588:	10bfc00c 	andi	r2,r2,65280
 90a158c:	1886b03a 	or	r3,r3,r2
 90a1590:	e0bffe17 	ldw	r2,-8(fp)
 90a1594:	10bfc00c 	andi	r2,r2,65280
 90a1598:	1004923a 	slli	r2,r2,8
 90a159c:	1886b03a 	or	r3,r3,r2
 90a15a0:	e0bffe17 	ldw	r2,-8(fp)
 90a15a4:	10803fcc 	andi	r2,r2,255
 90a15a8:	1004963a 	slli	r2,r2,24
 90a15ac:	1884b03a 	or	r2,r3,r2
 90a15b0:	20800c15 	stw	r2,48(r4)
}
 90a15b4:	e037883a 	mov	sp,fp
 90a15b8:	dfc00117 	ldw	ra,4(sp)
 90a15bc:	df000017 	ldw	fp,0(sp)
 90a15c0:	dec00204 	addi	sp,sp,8
 90a15c4:	f800283a 	ret

090a15c8 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 90a15c8:	defffc04 	addi	sp,sp,-16
 90a15cc:	dfc00315 	stw	ra,12(sp)
 90a15d0:	df000215 	stw	fp,8(sp)
 90a15d4:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 90a15d8:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 90a15dc:	d0a08317 	ldw	r2,-32244(gp)
 90a15e0:	1080010c 	andi	r2,r2,4
 90a15e4:	1005003a 	cmpeq	r2,r2,zero
 90a15e8:	1000031e 	bne	r2,zero,90a15f8 <netclose+0x30>
 90a15ec:	01024374 	movhi	r4,2317
 90a15f0:	213ba004 	addi	r4,r4,-4480
 90a15f4:	90828380 	call	9082838 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 90a15f8:	008243b4 	movhi	r2,2318
 90a15fc:	10b65f04 	addi	r2,r2,-9860
 90a1600:	10800017 	ldw	r2,0(r2)
 90a1604:	e0bfff15 	stw	r2,-4(fp)
 90a1608:	00002106 	br	90a1690 <netclose+0xc8>
   {
      if (ifp->n_close)
 90a160c:	e0bfff17 	ldw	r2,-4(fp)
 90a1610:	10800517 	ldw	r2,20(r2)
 90a1614:	1005003a 	cmpeq	r2,r2,zero
 90a1618:	10000e1e 	bne	r2,zero,90a1654 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 90a161c:	e0bfff17 	ldw	r2,-4(fp)
 90a1620:	10802717 	ldw	r2,156(r2)
 90a1624:	11400117 	ldw	r5,4(r2)
 90a1628:	01024374 	movhi	r4,2317
 90a162c:	213ba504 	addi	r4,r4,-4460
 90a1630:	90825100 	call	9082510 <printf>
         (*(ifp->n_close))(index++);
 90a1634:	e0bfff17 	ldw	r2,-4(fp)
 90a1638:	10c00517 	ldw	r3,20(r2)
 90a163c:	e13ffe17 	ldw	r4,-8(fp)
 90a1640:	e0bffe17 	ldw	r2,-8(fp)
 90a1644:	10800044 	addi	r2,r2,1
 90a1648:	e0bffe15 	stw	r2,-8(fp)
 90a164c:	183ee83a 	callr	r3
 90a1650:	00000c06 	br	90a1684 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 90a1654:	d0a08317 	ldw	r2,-32244(gp)
 90a1658:	1080010c 	andi	r2,r2,4
 90a165c:	1005003a 	cmpeq	r2,r2,zero
 90a1660:	1000051e 	bne	r2,zero,90a1678 <netclose+0xb0>
 90a1664:	e0bfff17 	ldw	r2,-4(fp)
 90a1668:	11400104 	addi	r5,r2,4
 90a166c:	01024374 	movhi	r4,2317
 90a1670:	213bac04 	addi	r4,r4,-4432
 90a1674:	90825100 	call	9082510 <printf>
#endif
         index++;
 90a1678:	e0bffe17 	ldw	r2,-8(fp)
 90a167c:	10800044 	addi	r2,r2,1
 90a1680:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 90a1684:	e0bfff17 	ldw	r2,-4(fp)
 90a1688:	10800017 	ldw	r2,0(r2)
 90a168c:	e0bfff15 	stw	r2,-4(fp)
 90a1690:	e0bfff17 	ldw	r2,-4(fp)
 90a1694:	1004c03a 	cmpne	r2,r2,zero
 90a1698:	103fdc1e 	bne	r2,zero,90a160c <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 90a169c:	e037883a 	mov	sp,fp
 90a16a0:	dfc00117 	ldw	ra,4(sp)
 90a16a4:	df000017 	ldw	fp,0(sp)
 90a16a8:	dec00204 	addi	sp,sp,8
 90a16ac:	f800283a 	ret

090a16b0 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 90a16b0:	defff804 	addi	sp,sp,-32
 90a16b4:	dfc00715 	stw	ra,28(sp)
 90a16b8:	df000615 	stw	fp,24(sp)
 90a16bc:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 90a16c0:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 90a16c4:	0000e506 	br	90a1a5c <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 90a16c8:	008243b4 	movhi	r2,2318
 90a16cc:	10b4c504 	addi	r2,r2,-11500
 90a16d0:	10c00217 	ldw	r3,8(r2)
 90a16d4:	e0bffb17 	ldw	r2,-20(fp)
 90a16d8:	1884803a 	cmplt	r2,r3,r2
 90a16dc:	1007883a 	mov	r3,r2
 90a16e0:	e0bffb17 	ldw	r2,-20(fp)
 90a16e4:	10800044 	addi	r2,r2,1
 90a16e8:	e0bffb15 	stw	r2,-20(fp)
 90a16ec:	18803fcc 	andi	r2,r3,255
 90a16f0:	1005003a 	cmpeq	r2,r2,zero
 90a16f4:	1000021e 	bne	r2,zero,90a1700 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 90a16f8:	90a501c0 	call	90a501c <tk_yield>
         pkts = 0;   /* reset counter */
 90a16fc:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 90a1700:	01000044 	movi	r4,1
 90a1704:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 90a1708:	010243b4 	movhi	r4,2318
 90a170c:	21335904 	addi	r4,r4,-12956
 90a1710:	90a8d500 	call	90a8d50 <getq>
 90a1714:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 90a1718:	01000044 	movi	r4,1
 90a171c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 90a1720:	e0bffe17 	ldw	r2,-8(fp)
 90a1724:	1004c03a 	cmpne	r2,r2,zero
 90a1728:	1000031e 	bne	r2,zero,90a1738 <pktdemux+0x88>
 90a172c:	01024374 	movhi	r4,2317
 90a1730:	213bb304 	addi	r4,r4,-4404
 90a1734:	90a438c0 	call	90a438c <panic>
      ifc = pkt->net;
 90a1738:	e0bffe17 	ldw	r2,-8(fp)
 90a173c:	10800617 	ldw	r2,24(r2)
 90a1740:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 90a1744:	e0bffd17 	ldw	r2,-12(fp)
 90a1748:	10802717 	ldw	r2,156(r2)
 90a174c:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 90a1750:	e0bffe17 	ldw	r2,-8(fp)
 90a1754:	10800117 	ldw	r2,4(r2)
 90a1758:	11400084 	addi	r5,r2,2
 90a175c:	e13ffd17 	ldw	r4,-12(fp)
 90a1760:	90bcd680 	call	90bcd68 <isbcast>
 90a1764:	1005003a 	cmpeq	r2,r2,zero
 90a1768:	1000061e 	bne	r2,zero,90a1784 <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 90a176c:	e0bffc17 	ldw	r2,-16(fp)
 90a1770:	10800b17 	ldw	r2,44(r2)
 90a1774:	10c00044 	addi	r3,r2,1
 90a1778:	e0bffc17 	ldw	r2,-16(fp)
 90a177c:	10c00b15 	stw	r3,44(r2)
 90a1780:	00000506 	br	90a1798 <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 90a1784:	e0bffc17 	ldw	r2,-16(fp)
 90a1788:	10800a17 	ldw	r2,40(r2)
 90a178c:	10c00044 	addi	r3,r2,1
 90a1790:	e0bffc17 	ldw	r2,-16(fp)
 90a1794:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 90a1798:	e0bffc17 	ldw	r2,-16(fp)
 90a179c:	10800617 	ldw	r2,24(r2)
 90a17a0:	10800098 	cmpnei	r2,r2,2
 90a17a4:	10000c1e 	bne	r2,zero,90a17d8 <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a17a8:	01000084 	movi	r4,2
 90a17ac:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 90a17b0:	e13ffe17 	ldw	r4,-8(fp)
 90a17b4:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a17b8:	01000084 	movi	r4,2
 90a17bc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 90a17c0:	e0bffc17 	ldw	r2,-16(fp)
 90a17c4:	10800c17 	ldw	r2,48(r2)
 90a17c8:	10c00044 	addi	r3,r2,1
 90a17cc:	e0bffc17 	ldw	r2,-16(fp)
 90a17d0:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 90a17d4:	0000a106 	br	90a1a5c <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 90a17d8:	e0bffe17 	ldw	r2,-8(fp)
 90a17dc:	10800117 	ldw	r2,4(r2)
 90a17e0:	10bfff04 	addi	r2,r2,-4
 90a17e4:	10800003 	ldbu	r2,0(r2)
 90a17e8:	10803fcc 	andi	r2,r2,255
 90a17ec:	1080201c 	xori	r2,r2,128
 90a17f0:	10bfe004 	addi	r2,r2,-128
 90a17f4:	10801358 	cmpnei	r2,r2,77
 90a17f8:	10000b1e 	bne	r2,zero,90a1828 <pktdemux+0x178>
 90a17fc:	e0bffe17 	ldw	r2,-8(fp)
 90a1800:	10c00117 	ldw	r3,4(r2)
 90a1804:	e0bffe17 	ldw	r2,-8(fp)
 90a1808:	10800217 	ldw	r2,8(r2)
 90a180c:	1885883a 	add	r2,r3,r2
 90a1810:	10800003 	ldbu	r2,0(r2)
 90a1814:	10803fcc 	andi	r2,r2,255
 90a1818:	1080201c 	xori	r2,r2,128
 90a181c:	10bfe004 	addi	r2,r2,-128
 90a1820:	10801360 	cmpeqi	r2,r2,77
 90a1824:	1000041e 	bne	r2,zero,90a1838 <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 90a1828:	90a94880 	call	90a9488 <dtrap>
         panic("pktdemux: corrupt pkt");
 90a182c:	01024374 	movhi	r4,2317
 90a1830:	213bb904 	addi	r4,r4,-4380
 90a1834:	90a438c0 	call	90a438c <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 90a1838:	e0bffd17 	ldw	r2,-12(fp)
 90a183c:	10802a17 	ldw	r2,168(r2)
 90a1840:	1080020c 	andi	r2,r2,8
 90a1844:	1004c03a 	cmpne	r2,r2,zero
 90a1848:	10004d1e 	bne	r2,zero,90a1980 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 90a184c:	e0bffd17 	ldw	r2,-12(fp)
 90a1850:	10802717 	ldw	r2,156(r2)
 90a1854:	10800217 	ldw	r2,8(r2)
 90a1858:	108001a0 	cmpeqi	r2,r2,6
 90a185c:	1000011e 	bne	r2,zero,90a1864 <pktdemux+0x1b4>
 90a1860:	00003a06 	br	90a194c <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 90a1864:	e0bffe17 	ldw	r2,-8(fp)
 90a1868:	10800117 	ldw	r2,4(r2)
 90a186c:	10800084 	addi	r2,r2,2
 90a1870:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 90a1874:	e0bffa17 	ldw	r2,-24(fp)
 90a1878:	10800304 	addi	r2,r2,12
 90a187c:	10800003 	ldbu	r2,0(r2)
 90a1880:	10803fcc 	andi	r2,r2,255
 90a1884:	1080201c 	xori	r2,r2,128
 90a1888:	10bfe004 	addi	r2,r2,-128
 90a188c:	1004923a 	slli	r2,r2,8
 90a1890:	1007883a 	mov	r3,r2
 90a1894:	e0bffa17 	ldw	r2,-24(fp)
 90a1898:	10800344 	addi	r2,r2,13
 90a189c:	10800003 	ldbu	r2,0(r2)
 90a18a0:	10803fcc 	andi	r2,r2,255
 90a18a4:	1080201c 	xori	r2,r2,128
 90a18a8:	10bfe004 	addi	r2,r2,-128
 90a18ac:	10803fcc 	andi	r2,r2,255
 90a18b0:	1885883a 	add	r2,r3,r2
 90a18b4:	10bfffcc 	andi	r2,r2,65535
 90a18b8:	1004d23a 	srli	r2,r2,8
 90a18bc:	10803fcc 	andi	r2,r2,255
 90a18c0:	1009883a 	mov	r4,r2
 90a18c4:	e0bffa17 	ldw	r2,-24(fp)
 90a18c8:	10800304 	addi	r2,r2,12
 90a18cc:	10800003 	ldbu	r2,0(r2)
 90a18d0:	10803fcc 	andi	r2,r2,255
 90a18d4:	1080201c 	xori	r2,r2,128
 90a18d8:	10bfe004 	addi	r2,r2,-128
 90a18dc:	1004923a 	slli	r2,r2,8
 90a18e0:	1007883a 	mov	r3,r2
 90a18e4:	e0bffa17 	ldw	r2,-24(fp)
 90a18e8:	10800344 	addi	r2,r2,13
 90a18ec:	10800003 	ldbu	r2,0(r2)
 90a18f0:	10803fcc 	andi	r2,r2,255
 90a18f4:	1080201c 	xori	r2,r2,128
 90a18f8:	10bfe004 	addi	r2,r2,-128
 90a18fc:	10803fcc 	andi	r2,r2,255
 90a1900:	1885883a 	add	r2,r3,r2
 90a1904:	10bfffcc 	andi	r2,r2,65535
 90a1908:	1004923a 	slli	r2,r2,8
 90a190c:	1007883a 	mov	r3,r2
 90a1910:	00bfc004 	movi	r2,-256
 90a1914:	1884703a 	and	r2,r3,r2
 90a1918:	2084b03a 	or	r2,r4,r2
 90a191c:	1007883a 	mov	r3,r2
 90a1920:	e0bffe17 	ldw	r2,-8(fp)
 90a1924:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 90a1928:	e0bffe17 	ldw	r2,-8(fp)
 90a192c:	10c00117 	ldw	r3,4(r2)
 90a1930:	e0bffe17 	ldw	r2,-8(fp)
 90a1934:	10800617 	ldw	r2,24(r2)
 90a1938:	10800817 	ldw	r2,32(r2)
 90a193c:	1887883a 	add	r3,r3,r2
 90a1940:	e0bffe17 	ldw	r2,-8(fp)
 90a1944:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 90a1948:	00000d06 	br	90a1980 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 90a194c:	e0bffd17 	ldw	r2,-12(fp)
 90a1950:	10802717 	ldw	r2,156(r2)
 90a1954:	11400217 	ldw	r5,8(r2)
 90a1958:	01024374 	movhi	r4,2317
 90a195c:	213bbf04 	addi	r4,r4,-4356
 90a1960:	90825100 	call	9082510 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1964:	01000084 	movi	r4,2
 90a1968:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 90a196c:	e13ffe17 	ldw	r4,-8(fp)
 90a1970:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a1974:	01000084 	movi	r4,2
 90a1978:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            continue;
 90a197c:	00003706 	br	90a1a5c <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 90a1980:	e0bffe17 	ldw	r2,-8(fp)
 90a1984:	1080080b 	ldhu	r2,32(r2)
 90a1988:	10bfffcc 	andi	r2,r2,65535
 90a198c:	e0bfff15 	stw	r2,-4(fp)
 90a1990:	e0ffff17 	ldw	r3,-4(fp)
 90a1994:	18800220 	cmpeqi	r2,r3,8
 90a1998:	1000041e 	bne	r2,zero,90a19ac <pktdemux+0x2fc>
 90a199c:	e0ffff17 	ldw	r3,-4(fp)
 90a19a0:	18818220 	cmpeqi	r2,r3,1544
 90a19a4:	1000081e 	bne	r2,zero,90a19c8 <pktdemux+0x318>
 90a19a8:	00000e06 	br	90a19e4 <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 90a19ac:	0009883a 	mov	r4,zero
 90a19b0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 90a19b4:	e13ffe17 	ldw	r4,-8(fp)
 90a19b8:	90c10280 	call	90c1028 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 90a19bc:	0009883a 	mov	r4,zero
 90a19c0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         break;
 90a19c4:	00002506 	br	90a1a5c <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 90a19c8:	0009883a 	mov	r4,zero
 90a19cc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 90a19d0:	e13ffe17 	ldw	r4,-8(fp)
 90a19d4:	90bc4480 	call	90bc448 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90a19d8:	0009883a 	mov	r4,zero
 90a19dc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         break;
 90a19e0:	00001e06 	br	90a1a5c <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 90a19e4:	d0a08317 	ldw	r2,-32244(gp)
 90a19e8:	1081000c 	andi	r2,r2,1024
 90a19ec:	1005003a 	cmpeq	r2,r2,zero
 90a19f0:	10000f1e 	bne	r2,zero,90a1a30 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 90a19f4:	e0bffe17 	ldw	r2,-8(fp)
 90a19f8:	1080080b 	ldhu	r2,32(r2)
 90a19fc:	10bfffcc 	andi	r2,r2,65535
 90a1a00:	1004d23a 	srli	r2,r2,8
 90a1a04:	10bfffcc 	andi	r2,r2,65535
 90a1a08:	10c03fcc 	andi	r3,r2,255
 90a1a0c:	e0bffe17 	ldw	r2,-8(fp)
 90a1a10:	1080080b 	ldhu	r2,32(r2)
 90a1a14:	10bfffcc 	andi	r2,r2,65535
 90a1a18:	1004923a 	slli	r2,r2,8
 90a1a1c:	10bfc00c 	andi	r2,r2,65280
 90a1a20:	188ab03a 	or	r5,r3,r2
 90a1a24:	01024374 	movhi	r4,2317
 90a1a28:	213bc704 	addi	r4,r4,-4324
 90a1a2c:	90825100 	call	9082510 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 90a1a30:	e0bffd17 	ldw	r2,-12(fp)
 90a1a34:	10c02717 	ldw	r3,156(r2)
 90a1a38:	18800e17 	ldw	r2,56(r3)
 90a1a3c:	10800044 	addi	r2,r2,1
 90a1a40:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1a44:	01000084 	movi	r4,2
 90a1a48:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 90a1a4c:	e13ffe17 	ldw	r4,-8(fp)
 90a1a50:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a1a54:	01000084 	movi	r4,2
 90a1a58:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 90a1a5c:	008243b4 	movhi	r2,2318
 90a1a60:	10b35904 	addi	r2,r2,-12956
 90a1a64:	10800217 	ldw	r2,8(r2)
 90a1a68:	1004c03a 	cmpne	r2,r2,zero
 90a1a6c:	103f161e 	bne	r2,zero,90a16c8 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 90a1a70:	e037883a 	mov	sp,fp
 90a1a74:	dfc00117 	ldw	ra,4(sp)
 90a1a78:	df000017 	ldw	fp,0(sp)
 90a1a7c:	dec00204 	addi	sp,sp,8
 90a1a80:	f800283a 	ret

090a1a84 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 90a1a84:	defffc04 	addi	sp,sp,-16
 90a1a88:	df000315 	stw	fp,12(sp)
 90a1a8c:	df000304 	addi	fp,sp,12
 90a1a90:	e13ffd15 	stw	r4,-12(fp)
 90a1a94:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 90a1a98:	00824374 	movhi	r2,2317
 90a1a9c:	108c4204 	addi	r2,r2,12552
 90a1aa0:	10800017 	ldw	r2,0(r2)
 90a1aa4:	1004403a 	cmpge	r2,r2,zero
 90a1aa8:	1000141e 	bne	r2,zero,90a1afc <c_older+0x78>
 90a1aac:	00824374 	movhi	r2,2317
 90a1ab0:	108c4204 	addi	r2,r2,12552
 90a1ab4:	10c00017 	ldw	r3,0(r2)
 90a1ab8:	e0bffd17 	ldw	r2,-12(fp)
 90a1abc:	18800536 	bltu	r3,r2,90a1ad4 <c_older+0x50>
 90a1ac0:	00824374 	movhi	r2,2317
 90a1ac4:	108c4204 	addi	r2,r2,12552
 90a1ac8:	10c00017 	ldw	r3,0(r2)
 90a1acc:	e0bffe17 	ldw	r2,-8(fp)
 90a1ad0:	18800a2e 	bgeu	r3,r2,90a1afc <c_older+0x78>
 90a1ad4:	00824374 	movhi	r2,2317
 90a1ad8:	108c4204 	addi	r2,r2,12552
 90a1adc:	10c00017 	ldw	r3,0(r2)
 90a1ae0:	e0bffd17 	ldw	r2,-12(fp)
 90a1ae4:	10c00e36 	bltu	r2,r3,90a1b20 <c_older+0x9c>
 90a1ae8:	00824374 	movhi	r2,2317
 90a1aec:	108c4204 	addi	r2,r2,12552
 90a1af0:	10c00017 	ldw	r3,0(r2)
 90a1af4:	e0bffe17 	ldw	r2,-8(fp)
 90a1af8:	10c00936 	bltu	r2,r3,90a1b20 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 90a1afc:	e0fffd17 	ldw	r3,-12(fp)
 90a1b00:	e0bffe17 	ldw	r2,-8(fp)
 90a1b04:	1880032e 	bgeu	r3,r2,90a1b14 <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 90a1b08:	e0bffd17 	ldw	r2,-12(fp)
 90a1b0c:	e0bfff15 	stw	r2,-4(fp)
 90a1b10:	00000b06 	br	90a1b40 <c_older+0xbc>
      else 
         return(ct2);
 90a1b14:	e0bffe17 	ldw	r2,-8(fp)
 90a1b18:	e0bfff15 	stw	r2,-4(fp)
 90a1b1c:	00000806 	br	90a1b40 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 90a1b20:	e0fffd17 	ldw	r3,-12(fp)
 90a1b24:	e0bffe17 	ldw	r2,-8(fp)
 90a1b28:	18800336 	bltu	r3,r2,90a1b38 <c_older+0xb4>
      return(ct1);
 90a1b2c:	e0bffd17 	ldw	r2,-12(fp)
 90a1b30:	e0bfff15 	stw	r2,-4(fp)
 90a1b34:	00000206 	br	90a1b40 <c_older+0xbc>
   else
      return(ct2);
 90a1b38:	e0bffe17 	ldw	r2,-8(fp)
 90a1b3c:	e0bfff15 	stw	r2,-4(fp)
 90a1b40:	e0bfff17 	ldw	r2,-4(fp)
}
 90a1b44:	e037883a 	mov	sp,fp
 90a1b48:	df000017 	ldw	fp,0(sp)
 90a1b4c:	dec00104 	addi	sp,sp,4
 90a1b50:	f800283a 	ret

090a1b54 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 90a1b54:	defffa04 	addi	sp,sp,-24
 90a1b58:	dfc00515 	stw	ra,20(sp)
 90a1b5c:	df000415 	stw	fp,16(sp)
 90a1b60:	df000404 	addi	fp,sp,16
 90a1b64:	e13ffd15 	stw	r4,-12(fp)
 90a1b68:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 90a1b6c:	e0bffd17 	ldw	r2,-12(fp)
 90a1b70:	10800617 	ldw	r2,24(r2)
 90a1b74:	10802717 	ldw	r2,156(r2)
 90a1b78:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 90a1b7c:	e0bffc17 	ldw	r2,-16(fp)
 90a1b80:	10800617 	ldw	r2,24(r2)
 90a1b84:	10800098 	cmpnei	r2,r2,2
 90a1b88:	1000091e 	bne	r2,zero,90a1bb0 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1b8c:	01000084 	movi	r4,2
 90a1b90:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90a1b94:	e13ffd17 	ldw	r4,-12(fp)
 90a1b98:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a1b9c:	01000084 	movi	r4,2
 90a1ba0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 90a1ba4:	00bff7c4 	movi	r2,-33
 90a1ba8:	e0bfff15 	stw	r2,-4(fp)
 90a1bac:	00004c06 	br	90a1ce0 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 90a1bb0:	e0bffd17 	ldw	r2,-12(fp)
 90a1bb4:	10800617 	ldw	r2,24(r2)
 90a1bb8:	10800817 	ldw	r2,32(r2)
 90a1bbc:	1005003a 	cmpeq	r2,r2,zero
 90a1bc0:	1000081e 	bne	r2,zero,90a1be4 <ip2mac+0x90>
 90a1bc4:	e0bffc17 	ldw	r2,-16(fp)
 90a1bc8:	10800217 	ldw	r2,8(r2)
 90a1bcc:	108005e0 	cmpeqi	r2,r2,23
 90a1bd0:	1000041e 	bne	r2,zero,90a1be4 <ip2mac+0x90>
 90a1bd4:	e0bffc17 	ldw	r2,-16(fp)
 90a1bd8:	10800217 	ldw	r2,8(r2)
 90a1bdc:	10800718 	cmpnei	r2,r2,28
 90a1be0:	1000291e 	bne	r2,zero,90a1c88 <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 90a1be4:	e0bffc17 	ldw	r2,-16(fp)
 90a1be8:	10801017 	ldw	r2,64(r2)
 90a1bec:	10c00044 	addi	r3,r2,1
 90a1bf0:	e0bffc17 	ldw	r2,-16(fp)
 90a1bf4:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 90a1bf8:	e0bffc17 	ldw	r2,-16(fp)
 90a1bfc:	10c00f17 	ldw	r3,60(r2)
 90a1c00:	e0bffd17 	ldw	r2,-12(fp)
 90a1c04:	10800417 	ldw	r2,16(r2)
 90a1c08:	1887883a 	add	r3,r3,r2
 90a1c0c:	e0bffc17 	ldw	r2,-16(fp)
 90a1c10:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 90a1c14:	e0bffd17 	ldw	r2,-12(fp)
 90a1c18:	10800617 	ldw	r2,24(r2)
 90a1c1c:	10800417 	ldw	r2,16(r2)
 90a1c20:	1005003a 	cmpeq	r2,r2,zero
 90a1c24:	1000061e 	bne	r2,zero,90a1c40 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 90a1c28:	e0bffd17 	ldw	r2,-12(fp)
 90a1c2c:	10800617 	ldw	r2,24(r2)
 90a1c30:	10800417 	ldw	r2,16(r2)
 90a1c34:	e13ffd17 	ldw	r4,-12(fp)
 90a1c38:	103ee83a 	callr	r2
 90a1c3c:	00001006 	br	90a1c80 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 90a1c40:	e0bffd17 	ldw	r2,-12(fp)
 90a1c44:	10800617 	ldw	r2,24(r2)
 90a1c48:	10c00317 	ldw	r3,12(r2)
 90a1c4c:	e0bffd17 	ldw	r2,-12(fp)
 90a1c50:	11000617 	ldw	r4,24(r2)
 90a1c54:	e0bffd17 	ldw	r2,-12(fp)
 90a1c58:	11400317 	ldw	r5,12(r2)
 90a1c5c:	e0bffd17 	ldw	r2,-12(fp)
 90a1c60:	11800417 	ldw	r6,16(r2)
 90a1c64:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1c68:	01000084 	movi	r4,2
 90a1c6c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90a1c70:	e13ffd17 	ldw	r4,-12(fp)
 90a1c74:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a1c78:	01000084 	movi	r4,2
 90a1c7c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 90a1c80:	e03fff15 	stw	zero,-4(fp)
 90a1c84:	00001606 	br	90a1ce0 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 90a1c88:	e0bffd17 	ldw	r2,-12(fp)
 90a1c8c:	10800617 	ldw	r2,24(r2)
 90a1c90:	10800a17 	ldw	r2,40(r2)
 90a1c94:	1004c03a 	cmpne	r2,r2,zero
 90a1c98:	10000d1e 	bne	r2,zero,90a1cd0 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 90a1c9c:	e0bffd17 	ldw	r2,-12(fp)
 90a1ca0:	10800717 	ldw	r2,28(r2)
 90a1ca4:	10bfffe0 	cmpeqi	r2,r2,-1
 90a1ca8:	1000091e 	bne	r2,zero,90a1cd0 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1cac:	01000084 	movi	r4,2
 90a1cb0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90a1cb4:	e13ffd17 	ldw	r4,-12(fp)
 90a1cb8:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a1cbc:	01000084 	movi	r4,2
 90a1cc0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 90a1cc4:	00bff884 	movi	r2,-30
 90a1cc8:	e0bfff15 	stw	r2,-4(fp)
 90a1ccc:	00000406 	br	90a1ce0 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 90a1cd0:	e13ffd17 	ldw	r4,-12(fp)
 90a1cd4:	e17ffe17 	ldw	r5,-8(fp)
 90a1cd8:	90bc6a80 	call	90bc6a8 <send_via_arp>
 90a1cdc:	e0bfff15 	stw	r2,-4(fp)
 90a1ce0:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 90a1ce4:	e037883a 	mov	sp,fp
 90a1ce8:	dfc00117 	ldw	ra,4(sp)
 90a1cec:	df000017 	ldw	fp,0(sp)
 90a1cf0:	dec00204 	addi	sp,sp,8
 90a1cf4:	f800283a 	ret

090a1cf8 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 90a1cf8:	defffb04 	addi	sp,sp,-20
 90a1cfc:	dfc00415 	stw	ra,16(sp)
 90a1d00:	df000315 	stw	fp,12(sp)
 90a1d04:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 90a1d08:	e03ffd15 	stw	zero,-12(fp)
 90a1d0c:	00002a06 	br	90a1db8 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 90a1d10:	e13ffd17 	ldw	r4,-12(fp)
 90a1d14:	e0bffd17 	ldw	r2,-12(fp)
 90a1d18:	10803024 	muli	r2,r2,192
 90a1d1c:	1007883a 	mov	r3,r2
 90a1d20:	008243b4 	movhi	r2,2318
 90a1d24:	10b35e04 	addi	r2,r2,-12936
 90a1d28:	188b883a 	add	r5,r3,r2
 90a1d2c:	00c243b4 	movhi	r3,2318
 90a1d30:	18f41e04 	addi	r3,r3,-12168
 90a1d34:	2105883a 	add	r2,r4,r4
 90a1d38:	1085883a 	add	r2,r2,r2
 90a1d3c:	10c5883a 	add	r2,r2,r3
 90a1d40:	11400015 	stw	r5,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 90a1d44:	e0bffd17 	ldw	r2,-12(fp)
 90a1d48:	00c243b4 	movhi	r3,2318
 90a1d4c:	18f41e04 	addi	r3,r3,-12168
 90a1d50:	1085883a 	add	r2,r2,r2
 90a1d54:	1085883a 	add	r2,r2,r2
 90a1d58:	10c5883a 	add	r2,r2,r3
 90a1d5c:	11000017 	ldw	r4,0(r2)
 90a1d60:	e0bffd17 	ldw	r2,-12(fp)
 90a1d64:	00c243b4 	movhi	r3,2318
 90a1d68:	18f41e04 	addi	r3,r3,-12168
 90a1d6c:	1085883a 	add	r2,r2,r2
 90a1d70:	1085883a 	add	r2,r2,r2
 90a1d74:	10c5883a 	add	r2,r2,r3
 90a1d78:	10800017 	ldw	r2,0(r2)
 90a1d7c:	10801204 	addi	r2,r2,72
 90a1d80:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 90a1d84:	e0bffd17 	ldw	r2,-12(fp)
 90a1d88:	00c243b4 	movhi	r3,2318
 90a1d8c:	18f41e04 	addi	r3,r3,-12168
 90a1d90:	1085883a 	add	r2,r2,r2
 90a1d94:	1085883a 	add	r2,r2,r2
 90a1d98:	10c5883a 	add	r2,r2,r3
 90a1d9c:	11400017 	ldw	r5,0(r2)
 90a1da0:	010243b4 	movhi	r4,2318
 90a1da4:	21365f04 	addi	r4,r4,-9860
 90a1da8:	90a8e180 	call	90a8e18 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 90a1dac:	e0bffd17 	ldw	r2,-12(fp)
 90a1db0:	10800044 	addi	r2,r2,1
 90a1db4:	e0bffd15 	stw	r2,-12(fp)
 90a1db8:	e0bffd17 	ldw	r2,-12(fp)
 90a1dbc:	10800110 	cmplti	r2,r2,4
 90a1dc0:	103fd31e 	bne	r2,zero,90a1d10 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 90a1dc4:	d0a08417 	ldw	r2,-32240(gp)
 90a1dc8:	1009883a 	mov	r4,r2
 90a1dcc:	90c21540 	call	90c2154 <prep_ifaces>
 90a1dd0:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 90a1dd4:	d0a08417 	ldw	r2,-32240(gp)
 90a1dd8:	1004c03a 	cmpne	r2,r2,zero
 90a1ddc:	1000041e 	bne	r2,zero,90a1df0 <ip_startup+0xf8>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 90a1de0:	00824374 	movhi	r2,2317
 90a1de4:	10bbd804 	addi	r2,r2,-4256
 90a1de8:	e0bfff15 	stw	r2,-4(fp)
 90a1dec:	00007506 	br	90a1fc4 <ip_startup+0x2cc>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 90a1df0:	d0a08417 	ldw	r2,-32240(gp)
 90a1df4:	e0bffd15 	stw	r2,-12(fp)
 90a1df8:	00001506 	br	90a1e50 <ip_startup+0x158>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 90a1dfc:	e0bffd17 	ldw	r2,-12(fp)
 90a1e00:	00c243b4 	movhi	r3,2318
 90a1e04:	18f41e04 	addi	r3,r3,-12168
 90a1e08:	1085883a 	add	r2,r2,r2
 90a1e0c:	1085883a 	add	r2,r2,r2
 90a1e10:	10c5883a 	add	r2,r2,r3
 90a1e14:	10800017 	ldw	r2,0(r2)
 90a1e18:	100b883a 	mov	r5,r2
 90a1e1c:	010243b4 	movhi	r4,2318
 90a1e20:	21365f04 	addi	r4,r4,-9860
 90a1e24:	90a8ec80 	call	90a8ec8 <qdel>
      nets[i] = NULL;               /* remove from array */
 90a1e28:	e0bffd17 	ldw	r2,-12(fp)
 90a1e2c:	00c243b4 	movhi	r3,2318
 90a1e30:	18f41e04 	addi	r3,r3,-12168
 90a1e34:	1085883a 	add	r2,r2,r2
 90a1e38:	1085883a 	add	r2,r2,r2
 90a1e3c:	10c5883a 	add	r2,r2,r3
 90a1e40:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 90a1e44:	e0bffd17 	ldw	r2,-12(fp)
 90a1e48:	10800044 	addi	r2,r2,1
 90a1e4c:	e0bffd15 	stw	r2,-12(fp)
 90a1e50:	e0bffd17 	ldw	r2,-12(fp)
 90a1e54:	10800110 	cmplti	r2,r2,4
 90a1e58:	103fe81e 	bne	r2,zero,90a1dfc <ip_startup+0x104>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 90a1e5c:	90a95c40 	call	90a95c4 <clock_init>
   exit_hook(clock_c);
 90a1e60:	010242f4 	movhi	r4,2315
 90a1e64:	21258004 	addi	r4,r4,-27136
 90a1e68:	90a1fdc0 	call	90a1fdc <exit_hook>

   e = Netinit();    /* start net interface(s) */
 90a1e6c:	90a0e1c0 	call	90a0e1c <Netinit>
 90a1e70:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a1e74:	e0bffe17 	ldw	r2,-8(fp)
 90a1e78:	1005003a 	cmpeq	r2,r2,zero
 90a1e7c:	1000041e 	bne	r2,zero,90a1e90 <ip_startup+0x198>
   {
      return("unable to initialize net");
 90a1e80:	00824374 	movhi	r2,2317
 90a1e84:	10bbe204 	addi	r2,r2,-4216
 90a1e88:	e0bfff15 	stw	r2,-4(fp)
 90a1e8c:	00004d06 	br	90a1fc4 <ip_startup+0x2cc>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 90a1e90:	90bb7480 	call	90bb748 <etainit>
 90a1e94:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a1e98:	e0bffe17 	ldw	r2,-8(fp)
 90a1e9c:	1005003a 	cmpeq	r2,r2,zero
 90a1ea0:	1000051e 	bne	r2,zero,90a1eb8 <ip_startup+0x1c0>
   {
      ip_exit();
 90a1ea4:	90a20480 	call	90a2048 <ip_exit>
      return("unable to initialize arp");
 90a1ea8:	00824374 	movhi	r2,2317
 90a1eac:	10bbe904 	addi	r2,r2,-4188
 90a1eb0:	e0bfff15 	stw	r2,-4(fp)
 90a1eb4:	00004306 	br	90a1fc4 <ip_startup+0x2cc>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 90a1eb8:	90bcf7c0 	call	90bcf7c <ip_init>
 90a1ebc:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a1ec0:	e0bffe17 	ldw	r2,-8(fp)
 90a1ec4:	1005003a 	cmpeq	r2,r2,zero
 90a1ec8:	1000051e 	bne	r2,zero,90a1ee0 <ip_startup+0x1e8>
   {
      ip_exit();
 90a1ecc:	90a20480 	call	90a2048 <ip_exit>
      return("unable to initialize IP");
 90a1ed0:	00824374 	movhi	r2,2317
 90a1ed4:	10bbf004 	addi	r2,r2,-4160
 90a1ed8:	e0bfff15 	stw	r2,-4(fp)
 90a1edc:	00003906 	br	90a1fc4 <ip_startup+0x2cc>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 90a1ee0:	90a21a80 	call	90a21a8 <igmp_init>
 90a1ee4:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a1ee8:	e0bffe17 	ldw	r2,-8(fp)
 90a1eec:	1005003a 	cmpeq	r2,r2,zero
 90a1ef0:	1000041e 	bne	r2,zero,90a1f04 <ip_startup+0x20c>
   {
      ip_exit();
 90a1ef4:	90a20480 	call	90a2048 <ip_exit>
      return(ipmcfail_str);
 90a1ef8:	d0a02e17 	ldw	r2,-32584(gp)
 90a1efc:	e0bfff15 	stw	r2,-4(fp)
 90a1f00:	00003006 	br	90a1fc4 <ip_startup+0x2cc>
   }

   for (i = 0; i < (int)ifNumber; i++)
 90a1f04:	e03ffd15 	stw	zero,-12(fp)
 90a1f08:	00001e06 	br	90a1f84 <ip_startup+0x28c>
   {
      if (nets[i]->n_mcastlist != NULL)
 90a1f0c:	e0bffd17 	ldw	r2,-12(fp)
 90a1f10:	00c243b4 	movhi	r3,2318
 90a1f14:	18f41e04 	addi	r3,r3,-12168
 90a1f18:	1085883a 	add	r2,r2,r2
 90a1f1c:	1085883a 	add	r2,r2,r2
 90a1f20:	10c5883a 	add	r2,r2,r3
 90a1f24:	10800017 	ldw	r2,0(r2)
 90a1f28:	10802b17 	ldw	r2,172(r2)
 90a1f2c:	1005003a 	cmpeq	r2,r2,zero
 90a1f30:	1000111e 	bne	r2,zero,90a1f78 <ip_startup+0x280>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 90a1f34:	e0bffd17 	ldw	r2,-12(fp)
 90a1f38:	00c243b4 	movhi	r3,2318
 90a1f3c:	18f41e04 	addi	r3,r3,-12168
 90a1f40:	1085883a 	add	r2,r2,r2
 90a1f44:	1085883a 	add	r2,r2,r2
 90a1f48:	10c5883a 	add	r2,r2,r3
 90a1f4c:	11400017 	ldw	r5,0(r2)
 90a1f50:	01024374 	movhi	r4,2317
 90a1f54:	210c2204 	addi	r4,r4,12424
 90a1f58:	01800104 	movi	r6,4
 90a1f5c:	90c1e640 	call	90c1e64 <in_addmulti>
 90a1f60:	1004c03a 	cmpne	r2,r2,zero
 90a1f64:	1000041e 	bne	r2,zero,90a1f78 <ip_startup+0x280>
      {
         ip_exit();
 90a1f68:	90a20480 	call	90a2048 <ip_exit>
         return(ipmcfail_str);
 90a1f6c:	d0a02e17 	ldw	r2,-32584(gp)
 90a1f70:	e0bfff15 	stw	r2,-4(fp)
 90a1f74:	00001306 	br	90a1fc4 <ip_startup+0x2cc>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 90a1f78:	e0bffd17 	ldw	r2,-12(fp)
 90a1f7c:	10800044 	addi	r2,r2,1
 90a1f80:	e0bffd15 	stw	r2,-12(fp)
 90a1f84:	d0a08417 	ldw	r2,-32240(gp)
 90a1f88:	1007883a 	mov	r3,r2
 90a1f8c:	e0bffd17 	ldw	r2,-12(fp)
 90a1f90:	10ffde16 	blt	r2,r3,90a1f0c <ip_startup+0x214>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 90a1f94:	90b7c300 	call	90b7c30 <tcpinit>
 90a1f98:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a1f9c:	e0bffe17 	ldw	r2,-8(fp)
 90a1fa0:	1005003a 	cmpeq	r2,r2,zero
 90a1fa4:	1000051e 	bne	r2,zero,90a1fbc <ip_startup+0x2c4>
   {
      ip_exit();
 90a1fa8:	90a20480 	call	90a2048 <ip_exit>
      return("unable to initialize TCP");
 90a1fac:	00824374 	movhi	r2,2317
 90a1fb0:	10bbf604 	addi	r2,r2,-4136
 90a1fb4:	e0bfff15 	stw	r2,-4(fp)
 90a1fb8:	00000206 	br	90a1fc4 <ip_startup+0x2cc>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 90a1fbc:	90c22100 	call	90c2210 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 90a1fc0:	e03fff15 	stw	zero,-4(fp)
 90a1fc4:	e0bfff17 	ldw	r2,-4(fp)
}
 90a1fc8:	e037883a 	mov	sp,fp
 90a1fcc:	dfc00117 	ldw	ra,4(sp)
 90a1fd0:	df000017 	ldw	fp,0(sp)
 90a1fd4:	dec00204 	addi	sp,sp,8
 90a1fd8:	f800283a 	ret

090a1fdc <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 90a1fdc:	defffd04 	addi	sp,sp,-12
 90a1fe0:	dfc00215 	stw	ra,8(sp)
 90a1fe4:	df000115 	stw	fp,4(sp)
 90a1fe8:	df000104 	addi	fp,sp,4
 90a1fec:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 90a1ff0:	d0a08517 	ldw	r2,-32236(gp)
 90a1ff4:	10800390 	cmplti	r2,r2,14
 90a1ff8:	1000031e 	bne	r2,zero,90a2008 <exit_hook+0x2c>
      panic("exit_hook");
 90a1ffc:	01024374 	movhi	r4,2317
 90a2000:	213bfd04 	addi	r4,r4,-4108
 90a2004:	90a438c0 	call	90a438c <panic>

   closers[++nclosers] = func;
 90a2008:	d0a08517 	ldw	r2,-32236(gp)
 90a200c:	10800044 	addi	r2,r2,1
 90a2010:	d0a08515 	stw	r2,-32236(gp)
 90a2014:	d0a08517 	ldw	r2,-32236(gp)
 90a2018:	00c24374 	movhi	r3,2317
 90a201c:	18cdfd04 	addi	r3,r3,14324
 90a2020:	1085883a 	add	r2,r2,r2
 90a2024:	1085883a 	add	r2,r2,r2
 90a2028:	10c7883a 	add	r3,r2,r3
 90a202c:	e0bfff17 	ldw	r2,-4(fp)
 90a2030:	18800015 	stw	r2,0(r3)
}
 90a2034:	e037883a 	mov	sp,fp
 90a2038:	dfc00117 	ldw	ra,4(sp)
 90a203c:	df000017 	ldw	fp,0(sp)
 90a2040:	dec00204 	addi	sp,sp,8
 90a2044:	f800283a 	ret

090a2048 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 90a2048:	defffd04 	addi	sp,sp,-12
 90a204c:	dfc00215 	stw	ra,8(sp)
 90a2050:	df000115 	stw	fp,4(sp)
 90a2054:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 90a2058:	d0a08517 	ldw	r2,-32236(gp)
 90a205c:	e0bfff15 	stw	r2,-4(fp)
 90a2060:	00002506 	br	90a20f8 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 90a2064:	e0bfff17 	ldw	r2,-4(fp)
 90a2068:	00c24374 	movhi	r3,2317
 90a206c:	18cdfd04 	addi	r3,r3,14324
 90a2070:	1085883a 	add	r2,r2,r2
 90a2074:	1085883a 	add	r2,r2,r2
 90a2078:	10c5883a 	add	r2,r2,r3
 90a207c:	11400017 	ldw	r5,0(r2)
 90a2080:	01024374 	movhi	r4,2317
 90a2084:	213c0004 	addi	r4,r4,-4096
 90a2088:	90825100 	call	9082510 <printf>
#endif
      if(closers[n])
 90a208c:	e0bfff17 	ldw	r2,-4(fp)
 90a2090:	00c24374 	movhi	r3,2317
 90a2094:	18cdfd04 	addi	r3,r3,14324
 90a2098:	1085883a 	add	r2,r2,r2
 90a209c:	1085883a 	add	r2,r2,r2
 90a20a0:	10c5883a 	add	r2,r2,r3
 90a20a4:	10800017 	ldw	r2,0(r2)
 90a20a8:	1005003a 	cmpeq	r2,r2,zero
 90a20ac:	10000f1e 	bne	r2,zero,90a20ec <ip_exit+0xa4>
      {
         (*closers[n])();
 90a20b0:	e0bfff17 	ldw	r2,-4(fp)
 90a20b4:	00c24374 	movhi	r3,2317
 90a20b8:	18cdfd04 	addi	r3,r3,14324
 90a20bc:	1085883a 	add	r2,r2,r2
 90a20c0:	1085883a 	add	r2,r2,r2
 90a20c4:	10c5883a 	add	r2,r2,r3
 90a20c8:	10800017 	ldw	r2,0(r2)
 90a20cc:	103ee83a 	callr	r2
         closers[n] = NULL;
 90a20d0:	e0bfff17 	ldw	r2,-4(fp)
 90a20d4:	00c24374 	movhi	r3,2317
 90a20d8:	18cdfd04 	addi	r3,r3,14324
 90a20dc:	1085883a 	add	r2,r2,r2
 90a20e0:	1085883a 	add	r2,r2,r2
 90a20e4:	10c5883a 	add	r2,r2,r3
 90a20e8:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 90a20ec:	e0bfff17 	ldw	r2,-4(fp)
 90a20f0:	10bfffc4 	addi	r2,r2,-1
 90a20f4:	e0bfff15 	stw	r2,-4(fp)
 90a20f8:	e0bfff17 	ldw	r2,-4(fp)
 90a20fc:	1004c03a 	cmpne	r2,r2,zero
 90a2100:	103fd81e 	bne	r2,zero,90a2064 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 90a2104:	e037883a 	mov	sp,fp
 90a2108:	dfc00117 	ldw	ra,4(sp)
 90a210c:	df000017 	ldw	fp,0(sp)
 90a2110:	dec00204 	addi	sp,sp,8
 90a2114:	f800283a 	ret

090a2118 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 90a2118:	defffa04 	addi	sp,sp,-24
 90a211c:	dfc00515 	stw	ra,20(sp)
 90a2120:	df000415 	stw	fp,16(sp)
 90a2124:	df000404 	addi	fp,sp,16
 90a2128:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 90a212c:	008243b4 	movhi	r2,2318
 90a2130:	10b65f04 	addi	r2,r2,-9860
 90a2134:	10800017 	ldw	r2,0(r2)
 90a2138:	e0bffc15 	stw	r2,-16(fp)
 90a213c:	e03ffd15 	stw	zero,-12(fp)
 90a2140:	00000c06 	br	90a2174 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 90a2144:	e0fffc17 	ldw	r3,-16(fp)
 90a2148:	e0bffe17 	ldw	r2,-8(fp)
 90a214c:	1880031e 	bne	r3,r2,90a215c <if_netnumber+0x44>
        return (int)i;
 90a2150:	e0bffd17 	ldw	r2,-12(fp)
 90a2154:	e0bfff15 	stw	r2,-4(fp)
 90a2158:	00000d06 	br	90a2190 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 90a215c:	e0bffc17 	ldw	r2,-16(fp)
 90a2160:	10800017 	ldw	r2,0(r2)
 90a2164:	e0bffc15 	stw	r2,-16(fp)
 90a2168:	e0bffd17 	ldw	r2,-12(fp)
 90a216c:	10800044 	addi	r2,r2,1
 90a2170:	e0bffd15 	stw	r2,-12(fp)
 90a2174:	e0bffc17 	ldw	r2,-16(fp)
 90a2178:	1004c03a 	cmpne	r2,r2,zero
 90a217c:	103ff11e 	bne	r2,zero,90a2144 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 90a2180:	01024374 	movhi	r4,2317
 90a2184:	213c0704 	addi	r4,r4,-4068
 90a2188:	90a438c0 	call	90a438c <panic>
   return 0;
 90a218c:	e03fff15 	stw	zero,-4(fp)
 90a2190:	e0bfff17 	ldw	r2,-4(fp)
}
 90a2194:	e037883a 	mov	sp,fp
 90a2198:	dfc00117 	ldw	ra,4(sp)
 90a219c:	df000017 	ldw	fp,0(sp)
 90a21a0:	dec00204 	addi	sp,sp,8
 90a21a4:	f800283a 	ret

090a21a8 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 90a21a8:	defffd04 	addi	sp,sp,-12
 90a21ac:	dfc00215 	stw	ra,8(sp)
 90a21b0:	df000115 	stw	fp,4(sp)
 90a21b4:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 90a21b8:	00804034 	movhi	r2,256
 90a21bc:	10803804 	addi	r2,r2,224
 90a21c0:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 90a21c4:	00808034 	movhi	r2,512
 90a21c8:	10803804 	addi	r2,r2,224
 90a21cc:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 90a21d0:	008243b4 	movhi	r2,2318
 90a21d4:	10b65f04 	addi	r2,r2,-9860
 90a21d8:	10800017 	ldw	r2,0(r2)
 90a21dc:	e0bfff15 	stw	r2,-4(fp)
 90a21e0:	00001006 	br	90a2224 <igmp_init+0x7c>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 90a21e4:	e0bfff17 	ldw	r2,-4(fp)
 90a21e8:	10802f03 	ldbu	r2,188(r2)
 90a21ec:	10803fcc 	andi	r2,r2,255
 90a21f0:	10800058 	cmpnei	r2,r2,1
 90a21f4:	1000041e 	bne	r2,zero,90a2208 <igmp_init+0x60>
      {
         ifp->igmpv1_rtr_present = 1;
 90a21f8:	e0ffff17 	ldw	r3,-4(fp)
 90a21fc:	00800044 	movi	r2,1
 90a2200:	18802d05 	stb	r2,180(r3)
 90a2204:	00000406 	br	90a2218 <igmp_init+0x70>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 90a2208:	e0bfff17 	ldw	r2,-4(fp)
 90a220c:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 90a2210:	e0bfff17 	ldw	r2,-4(fp)
 90a2214:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 90a2218:	e0bfff17 	ldw	r2,-4(fp)
 90a221c:	10800017 	ldw	r2,0(r2)
 90a2220:	e0bfff15 	stw	r2,-4(fp)
 90a2224:	e0bfff17 	ldw	r2,-4(fp)
 90a2228:	1004c03a 	cmpne	r2,r2,zero
 90a222c:	103fed1e 	bne	r2,zero,90a21e4 <igmp_init+0x3c>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 90a2230:	00824374 	movhi	r2,2317
 90a2234:	108c4204 	addi	r2,r2,12552
 90a2238:	11000017 	ldw	r4,0(r2)
 90a223c:	908c0380 	call	908c038 <__floatunsidf>
 90a2240:	100b883a 	mov	r5,r2
 90a2244:	180d883a 	mov	r6,r3
 90a2248:	2809883a 	mov	r4,r5
 90a224c:	300b883a 	mov	r5,r6
 90a2250:	000d883a 	mov	r6,zero
 90a2254:	01d00d34 	movhi	r7,16436
 90a2258:	908b5400 	call	908b540 <__adddf3>
 90a225c:	1009883a 	mov	r4,r2
 90a2260:	180b883a 	mov	r5,r3
 90a2264:	2005883a 	mov	r2,r4
 90a2268:	2807883a 	mov	r3,r5
 90a226c:	1009883a 	mov	r4,r2
 90a2270:	180b883a 	mov	r5,r3
 90a2274:	90cade40 	call	90cade4 <__fixunsdfsi>
 90a2278:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 90a227c:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 90a2280:	0005883a 	mov	r2,zero
}
 90a2284:	e037883a 	mov	sp,fp
 90a2288:	dfc00117 	ldw	ra,4(sp)
 90a228c:	df000017 	ldw	fp,0(sp)
 90a2290:	dec00204 	addi	sp,sp,8
 90a2294:	f800283a 	ret

090a2298 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 90a2298:	defff904 	addi	sp,sp,-28
 90a229c:	dfc00615 	stw	ra,24(sp)
 90a22a0:	df000515 	stw	fp,20(sp)
 90a22a4:	df000504 	addi	fp,sp,20
 90a22a8:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 90a22ac:	008243b4 	movhi	r2,2318
 90a22b0:	10b42204 	addi	r2,r2,-12152
 90a22b4:	10800017 	ldw	r2,0(r2)
 90a22b8:	10c00044 	addi	r3,r2,1
 90a22bc:	008243b4 	movhi	r2,2318
 90a22c0:	10b42204 	addi	r2,r2,-12152
 90a22c4:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 90a22c8:	e13ffd17 	ldw	r4,-12(fp)
 90a22cc:	90a2b640 	call	90a2b64 <igmp_validate>
 90a22d0:	e0bffb15 	stw	r2,-20(fp)
 90a22d4:	e0bffb17 	ldw	r2,-20(fp)
 90a22d8:	1004c03a 	cmpne	r2,r2,zero
 90a22dc:	10001e1e 	bne	r2,zero,90a2358 <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 90a22e0:	e0bffd17 	ldw	r2,-12(fp)
 90a22e4:	10800617 	ldw	r2,24(r2)
 90a22e8:	10802f03 	ldbu	r2,188(r2)
 90a22ec:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 90a22f0:	e0bffc03 	ldbu	r2,-16(fp)
 90a22f4:	e0bfff15 	stw	r2,-4(fp)
 90a22f8:	e0ffff17 	ldw	r3,-4(fp)
 90a22fc:	18800060 	cmpeqi	r2,r3,1
 90a2300:	1000041e 	bne	r2,zero,90a2314 <igmp_input+0x7c>
 90a2304:	e0ffff17 	ldw	r3,-4(fp)
 90a2308:	188000a0 	cmpeqi	r2,r3,2
 90a230c:	1000051e 	bne	r2,zero,90a2324 <igmp_input+0x8c>
 90a2310:	00000806 	br	90a2334 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 90a2314:	e13ffd17 	ldw	r4,-12(fp)
 90a2318:	90c3cb40 	call	90c3cb4 <igmpv1_input>
 90a231c:	e0bffe15 	stw	r2,-8(fp)
 90a2320:	00001506 	br	90a2378 <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 90a2324:	e13ffd17 	ldw	r4,-12(fp)
 90a2328:	90c3fa40 	call	90c3fa4 <igmpv2_input>
 90a232c:	e0bffe15 	stw	r2,-8(fp)
 90a2330:	00001106 	br	90a2378 <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 90a2334:	008243b4 	movhi	r2,2318
 90a2338:	10b42204 	addi	r2,r2,-12152
 90a233c:	10800d17 	ldw	r2,52(r2)
 90a2340:	10c00044 	addi	r3,r2,1
 90a2344:	008243b4 	movhi	r2,2318
 90a2348:	10b42204 	addi	r2,r2,-12152
 90a234c:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 90a2350:	00bfffc4 	movi	r2,-1
 90a2354:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2358:	01000084 	movi	r4,2
 90a235c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90a2360:	e13ffd17 	ldw	r4,-12(fp)
 90a2364:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2368:	01000084 	movi	r4,2
 90a236c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      
   return rc;
 90a2370:	e0bffb17 	ldw	r2,-20(fp)
 90a2374:	e0bffe15 	stw	r2,-8(fp)
 90a2378:	e0bffe17 	ldw	r2,-8(fp)
}
 90a237c:	e037883a 	mov	sp,fp
 90a2380:	dfc00117 	ldw	ra,4(sp)
 90a2384:	df000017 	ldw	fp,0(sp)
 90a2388:	dec00204 	addi	sp,sp,8
 90a238c:	f800283a 	ret

090a2390 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 90a2390:	defffa04 	addi	sp,sp,-24
 90a2394:	dfc00515 	stw	ra,20(sp)
 90a2398:	df000415 	stw	fp,16(sp)
 90a239c:	dc400315 	stw	r17,12(sp)
 90a23a0:	dc000215 	stw	r16,8(sp)
 90a23a4:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 90a23a8:	0009883a 	mov	r4,zero
 90a23ac:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 90a23b0:	d0a08617 	ldw	r2,-32232(gp)
 90a23b4:	1004c03a 	cmpne	r2,r2,zero
 90a23b8:	1000031e 	bne	r2,zero,90a23c8 <igmp_fasttimo+0x38>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 90a23bc:	0009883a 	mov	r4,zero
 90a23c0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return;
 90a23c4:	00007806 	br	90a25a8 <igmp_fasttimo+0x218>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a23c8:	008243b4 	movhi	r2,2318
 90a23cc:	10b65f04 	addi	r2,r2,-9860
 90a23d0:	10800017 	ldw	r2,0(r2)
 90a23d4:	e0bffe15 	stw	r2,-8(fp)
 90a23d8:	00005b06 	br	90a2548 <igmp_fasttimo+0x1b8>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 90a23dc:	e0bffe17 	ldw	r2,-8(fp)
 90a23e0:	10802c17 	ldw	r2,176(r2)
 90a23e4:	e0bfff15 	stw	r2,-4(fp)
 90a23e8:	00005106 	br	90a2530 <igmp_fasttimo+0x1a0>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 90a23ec:	e0bfff17 	ldw	r2,-4(fp)
 90a23f0:	10800017 	ldw	r2,0(r2)
 90a23f4:	1005003a 	cmpeq	r2,r2,zero
 90a23f8:	10004a1e 	bne	r2,zero,90a2524 <igmp_fasttimo+0x194>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 90a23fc:	e0bfff17 	ldw	r2,-4(fp)
 90a2400:	10800317 	ldw	r2,12(r2)
 90a2404:	1005003a 	cmpeq	r2,r2,zero
 90a2408:	1000461e 	bne	r2,zero,90a2524 <igmp_fasttimo+0x194>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 90a240c:	e0bfff17 	ldw	r2,-4(fp)
 90a2410:	10800317 	ldw	r2,12(r2)
 90a2414:	10ffffc4 	addi	r3,r2,-1
 90a2418:	e0bfff17 	ldw	r2,-4(fp)
 90a241c:	10c00315 	stw	r3,12(r2)
 90a2420:	e0bfff17 	ldw	r2,-4(fp)
 90a2424:	10800317 	ldw	r2,12(r2)
 90a2428:	1004c03a 	cmpne	r2,r2,zero
 90a242c:	10003d1e 	bne	r2,zero,90a2524 <igmp_fasttimo+0x194>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 90a2430:	e0bffe17 	ldw	r2,-8(fp)
 90a2434:	10802d03 	ldbu	r2,180(r2)
 90a2438:	10803fcc 	andi	r2,r2,255
 90a243c:	1005003a 	cmpeq	r2,r2,zero
 90a2440:	1000041e 	bne	r2,zero,90a2454 <igmp_fasttimo+0xc4>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 90a2444:	01000484 	movi	r4,18
 90a2448:	e17fff17 	ldw	r5,-4(fp)
 90a244c:	90a25c40 	call	90a25c4 <igmp_send>
 90a2450:	00000306 	br	90a2460 <igmp_fasttimo+0xd0>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 90a2454:	01000584 	movi	r4,22
 90a2458:	e17fff17 	ldw	r5,-4(fp)
 90a245c:	90a25c40 	call	90a25c4 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a2460:	e0bffe17 	ldw	r2,-8(fp)
 90a2464:	10802f03 	ldbu	r2,188(r2)
 90a2468:	10803fcc 	andi	r2,r2,255
 90a246c:	10800098 	cmpnei	r2,r2,2
 90a2470:	1000291e 	bne	r2,zero,90a2518 <igmp_fasttimo+0x188>
            {
               inm->last2send_report = IGMP_TRUE;
 90a2474:	e0ffff17 	ldw	r3,-4(fp)
 90a2478:	00800044 	movi	r2,1
 90a247c:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 90a2480:	e0bffe17 	ldw	r2,-8(fp)
 90a2484:	10802d03 	ldbu	r2,180(r2)
 90a2488:	10803fcc 	andi	r2,r2,255
 90a248c:	1005003a 	cmpeq	r2,r2,zero
 90a2490:	1000211e 	bne	r2,zero,90a2518 <igmp_fasttimo+0x188>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 90a2494:	00824374 	movhi	r2,2317
 90a2498:	108c4204 	addi	r2,r2,12552
 90a249c:	11000017 	ldw	r4,0(r2)
 90a24a0:	908c0380 	call	908c038 <__floatunsidf>
 90a24a4:	1021883a 	mov	r16,r2
 90a24a8:	1823883a 	mov	r17,r3
 90a24ac:	e0bffe17 	ldw	r2,-8(fp)
 90a24b0:	11002e17 	ldw	r4,184(r2)
 90a24b4:	908c0380 	call	908c038 <__floatunsidf>
 90a24b8:	100b883a 	mov	r5,r2
 90a24bc:	180d883a 	mov	r6,r3
 90a24c0:	2809883a 	mov	r4,r5
 90a24c4:	300b883a 	mov	r5,r6
 90a24c8:	000d883a 	mov	r6,zero
 90a24cc:	01d03934 	movhi	r7,16612
 90a24d0:	39e20004 	addi	r7,r7,-30720
 90a24d4:	908b5400 	call	908b540 <__adddf3>
 90a24d8:	1009883a 	mov	r4,r2
 90a24dc:	180b883a 	mov	r5,r3
 90a24e0:	2005883a 	mov	r2,r4
 90a24e4:	2807883a 	mov	r3,r5
 90a24e8:	8009883a 	mov	r4,r16
 90a24ec:	880b883a 	mov	r5,r17
 90a24f0:	100d883a 	mov	r6,r2
 90a24f4:	180f883a 	mov	r7,r3
 90a24f8:	908bcd00 	call	908bcd0 <__gtdf2>
 90a24fc:	10800048 	cmpgei	r2,r2,1
 90a2500:	1000011e 	bne	r2,zero,90a2508 <igmp_fasttimo+0x178>
 90a2504:	00000406 	br	90a2518 <igmp_fasttimo+0x188>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 90a2508:	e0bffe17 	ldw	r2,-8(fp)
 90a250c:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 90a2510:	e0bffe17 	ldw	r2,-8(fp)
 90a2514:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 90a2518:	d0a08617 	ldw	r2,-32232(gp)
 90a251c:	10bfffc4 	addi	r2,r2,-1
 90a2520:	d0a08615 	stw	r2,-32232(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 90a2524:	e0bfff17 	ldw	r2,-4(fp)
 90a2528:	10800517 	ldw	r2,20(r2)
 90a252c:	e0bfff15 	stw	r2,-4(fp)
 90a2530:	e0bfff17 	ldw	r2,-4(fp)
 90a2534:	1004c03a 	cmpne	r2,r2,zero
 90a2538:	103fac1e 	bne	r2,zero,90a23ec <igmp_fasttimo+0x5c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a253c:	e0bffe17 	ldw	r2,-8(fp)
 90a2540:	10800017 	ldw	r2,0(r2)
 90a2544:	e0bffe15 	stw	r2,-8(fp)
 90a2548:	e0bffe17 	ldw	r2,-8(fp)
 90a254c:	1004c03a 	cmpne	r2,r2,zero
 90a2550:	103fa21e 	bne	r2,zero,90a23dc <igmp_fasttimo+0x4c>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 90a2554:	00824374 	movhi	r2,2317
 90a2558:	108c4204 	addi	r2,r2,12552
 90a255c:	11000017 	ldw	r4,0(r2)
 90a2560:	908c0380 	call	908c038 <__floatunsidf>
 90a2564:	100b883a 	mov	r5,r2
 90a2568:	180d883a 	mov	r6,r3
 90a256c:	2809883a 	mov	r4,r5
 90a2570:	300b883a 	mov	r5,r6
 90a2574:	000d883a 	mov	r6,zero
 90a2578:	01d00d34 	movhi	r7,16436
 90a257c:	908b5400 	call	908b540 <__adddf3>
 90a2580:	1009883a 	mov	r4,r2
 90a2584:	180b883a 	mov	r5,r3
 90a2588:	2005883a 	mov	r2,r4
 90a258c:	2807883a 	mov	r3,r5
 90a2590:	1009883a 	mov	r4,r2
 90a2594:	180b883a 	mov	r5,r3
 90a2598:	90cade40 	call	90cade4 <__fixunsdfsi>
 90a259c:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90a25a0:	0009883a 	mov	r4,zero
 90a25a4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   
   return;
}
 90a25a8:	e037883a 	mov	sp,fp
 90a25ac:	dfc00317 	ldw	ra,12(sp)
 90a25b0:	df000217 	ldw	fp,8(sp)
 90a25b4:	dc400117 	ldw	r17,4(sp)
 90a25b8:	dc000017 	ldw	r16,0(sp)
 90a25bc:	dec00404 	addi	sp,sp,16
 90a25c0:	f800283a 	ret

090a25c4 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 90a25c4:	deffdd04 	addi	sp,sp,-140
 90a25c8:	dfc02215 	stw	ra,136(sp)
 90a25cc:	df002115 	stw	fp,132(sp)
 90a25d0:	df002104 	addi	fp,sp,132
 90a25d4:	e17fff15 	stw	r5,-4(fp)
 90a25d8:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 90a25dc:	00800504 	movi	r2,20
 90a25e0:	e0bffd05 	stb	r2,-12(fp)
 90a25e4:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 90a25e8:	00824374 	movhi	r2,2317
 90a25ec:	108c1b04 	addi	r2,r2,12396
 90a25f0:	10800017 	ldw	r2,0(r2)
 90a25f4:	10800704 	addi	r2,r2,28
 90a25f8:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a25fc:	e0bffe03 	ldbu	r2,-8(fp)
 90a2600:	108005e0 	cmpeqi	r2,r2,23
 90a2604:	1000031e 	bne	r2,zero,90a2614 <igmp_send+0x50>
 90a2608:	e0bffe03 	ldbu	r2,-8(fp)
 90a260c:	10800598 	cmpnei	r2,r2,22
 90a2610:	1000031e 	bne	r2,zero,90a2620 <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 90a2614:	e0bfdf03 	ldbu	r2,-132(fp)
 90a2618:	10800104 	addi	r2,r2,4
 90a261c:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 90a2620:	01000084 	movi	r4,2
 90a2624:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 90a2628:	e13fdf03 	ldbu	r4,-132(fp)
 90a262c:	90a88440 	call	90a8844 <pk_alloc>
 90a2630:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90a2634:	01000084 	movi	r4,2
 90a2638:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 90a263c:	e0bfe617 	ldw	r2,-104(fp)
 90a2640:	1004c03a 	cmpne	r2,r2,zero
 90a2644:	1000081e 	bne	r2,zero,90a2668 <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 90a2648:	008243b4 	movhi	r2,2318
 90a264c:	10b42204 	addi	r2,r2,-12152
 90a2650:	10800c17 	ldw	r2,48(r2)
 90a2654:	10c00044 	addi	r3,r2,1
 90a2658:	008243b4 	movhi	r2,2318
 90a265c:	10b42204 	addi	r2,r2,-12152
 90a2660:	10c00c15 	stw	r3,48(r2)
      return;
 90a2664:	00007c06 	br	90a2858 <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 90a2668:	e0bfe617 	ldw	r2,-104(fp)
 90a266c:	10800317 	ldw	r2,12(r2)
 90a2670:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 90a2674:	e0bfff17 	ldw	r2,-4(fp)
 90a2678:	10800117 	ldw	r2,4(r2)
 90a267c:	10c00a17 	ldw	r3,40(r2)
 90a2680:	e0bfe317 	ldw	r2,-116(fp)
 90a2684:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 90a2688:	e0bffe03 	ldbu	r2,-8(fp)
 90a268c:	108005d8 	cmpnei	r2,r2,23
 90a2690:	1000041e 	bne	r2,zero,90a26a4 <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 90a2694:	d0e08917 	ldw	r3,-32220(gp)
 90a2698:	e0bfe317 	ldw	r2,-116(fp)
 90a269c:	10c00415 	stw	r3,16(r2)
 90a26a0:	00000406 	br	90a26b4 <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 90a26a4:	e0bfff17 	ldw	r2,-4(fp)
 90a26a8:	10c00017 	ldw	r3,0(r2)
 90a26ac:	e0bfe317 	ldw	r2,-116(fp)
 90a26b0:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 90a26b4:	e0bfe317 	ldw	r2,-116(fp)
 90a26b8:	10c00417 	ldw	r3,16(r2)
 90a26bc:	e0bfe617 	ldw	r2,-104(fp)
 90a26c0:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 90a26c4:	e0bfe617 	ldw	r2,-104(fp)
 90a26c8:	10800317 	ldw	r2,12(r2)
 90a26cc:	10800504 	addi	r2,r2,20
 90a26d0:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a26d4:	e0bffe03 	ldbu	r2,-8(fp)
 90a26d8:	108005e0 	cmpeqi	r2,r2,23
 90a26dc:	1000031e 	bne	r2,zero,90a26ec <igmp_send+0x128>
 90a26e0:	e0bffe03 	ldbu	r2,-8(fp)
 90a26e4:	10800598 	cmpnei	r2,r2,22
 90a26e8:	1000061e 	bne	r2,zero,90a2704 <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 90a26ec:	e0bfe117 	ldw	r2,-124(fp)
 90a26f0:	10800104 	addi	r2,r2,4
 90a26f4:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 90a26f8:	e0bffd04 	addi	r2,fp,-12
 90a26fc:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a2700:	00000306 	br	90a2710 <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 90a2704:	e0bffd04 	addi	r2,fp,-12
 90a2708:	10800044 	addi	r2,r2,1
 90a270c:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 90a2710:	e0bfe117 	ldw	r2,-124(fp)
 90a2714:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 90a2718:	e0ffe517 	ldw	r3,-108(fp)
 90a271c:	e0bffe03 	ldbu	r2,-8(fp)
 90a2720:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 90a2724:	e0bfe517 	ldw	r2,-108(fp)
 90a2728:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 90a272c:	e0bfff17 	ldw	r2,-4(fp)
 90a2730:	10c00017 	ldw	r3,0(r2)
 90a2734:	e0bfe517 	ldw	r2,-108(fp)
 90a2738:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 90a273c:	e0bfe517 	ldw	r2,-108(fp)
 90a2740:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 90a2744:	e13fe517 	ldw	r4,-108(fp)
 90a2748:	01400104 	movi	r5,4
 90a274c:	90a3f040 	call	90a3f04 <cksum>
 90a2750:	0084303a 	nor	r2,zero,r2
 90a2754:	1007883a 	mov	r3,r2
 90a2758:	e0bfe517 	ldw	r2,-108(fp)
 90a275c:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 90a2760:	e0bfe704 	addi	r2,fp,-100
 90a2764:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 90a2768:	e0bfe417 	ldw	r2,-112(fp)
 90a276c:	1009883a 	mov	r4,r2
 90a2770:	01801604 	movi	r6,88
 90a2774:	000b883a 	mov	r5,zero
 90a2778:	90823f80 	call	90823f8 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 90a277c:	e0bfff17 	ldw	r2,-4(fp)
 90a2780:	10c00117 	ldw	r3,4(r2)
 90a2784:	e0bfe417 	ldw	r2,-112(fp)
 90a2788:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 90a278c:	e0ffe417 	ldw	r3,-112(fp)
 90a2790:	00800044 	movi	r2,1
 90a2794:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 90a2798:	e0bfe417 	ldw	r2,-112(fp)
 90a279c:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 90a27a0:	e0ffe117 	ldw	r3,-124(fp)
 90a27a4:	e0bfe617 	ldw	r2,-104(fp)
 90a27a8:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 90a27ac:	e0ffe617 	ldw	r3,-104(fp)
 90a27b0:	00800204 	movi	r2,8
 90a27b4:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 90a27b8:	e0ffe617 	ldw	r3,-104(fp)
 90a27bc:	e0bfe417 	ldw	r2,-112(fp)
 90a27c0:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 90a27c4:	01000084 	movi	r4,2
 90a27c8:	e17fe617 	ldw	r5,-104(fp)
 90a27cc:	e1bfe017 	ldw	r6,-128(fp)
 90a27d0:	90bdbe40 	call	90bdbe4 <ip_write2>
 90a27d4:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 90a27d8:	e0bffe03 	ldbu	r2,-8(fp)
 90a27dc:	108005d8 	cmpnei	r2,r2,23
 90a27e0:	1000081e 	bne	r2,zero,90a2804 <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 90a27e4:	008243b4 	movhi	r2,2318
 90a27e8:	10b42204 	addi	r2,r2,-12152
 90a27ec:	10801717 	ldw	r2,92(r2)
 90a27f0:	10c00044 	addi	r3,r2,1
 90a27f4:	008243b4 	movhi	r2,2318
 90a27f8:	10b42204 	addi	r2,r2,-12152
 90a27fc:	10c01715 	stw	r3,92(r2)
 90a2800:	00001506 	br	90a2858 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 90a2804:	e0bffe03 	ldbu	r2,-8(fp)
 90a2808:	10800598 	cmpnei	r2,r2,22
 90a280c:	1000081e 	bne	r2,zero,90a2830 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 90a2810:	008243b4 	movhi	r2,2318
 90a2814:	10b42204 	addi	r2,r2,-12152
 90a2818:	10801817 	ldw	r2,96(r2)
 90a281c:	10c00044 	addi	r3,r2,1
 90a2820:	008243b4 	movhi	r2,2318
 90a2824:	10b42204 	addi	r2,r2,-12152
 90a2828:	10c01815 	stw	r3,96(r2)
 90a282c:	00000a06 	br	90a2858 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 90a2830:	e0bffe03 	ldbu	r2,-8(fp)
 90a2834:	10800498 	cmpnei	r2,r2,18
 90a2838:	1000071e 	bne	r2,zero,90a2858 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 90a283c:	008243b4 	movhi	r2,2318
 90a2840:	10b42204 	addi	r2,r2,-12152
 90a2844:	10801617 	ldw	r2,88(r2)
 90a2848:	10c00044 	addi	r3,r2,1
 90a284c:	008243b4 	movhi	r2,2318
 90a2850:	10b42204 	addi	r2,r2,-12152
 90a2854:	10c01615 	stw	r3,88(r2)
}
 90a2858:	e037883a 	mov	sp,fp
 90a285c:	dfc00117 	ldw	ra,4(sp)
 90a2860:	df000017 	ldw	fp,0(sp)
 90a2864:	dec00204 	addi	sp,sp,8
 90a2868:	f800283a 	ret

090a286c <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 90a286c:	defffc04 	addi	sp,sp,-16
 90a2870:	dfc00315 	stw	ra,12(sp)
 90a2874:	df000215 	stw	fp,8(sp)
 90a2878:	df000204 	addi	fp,sp,8
 90a287c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 90a2880:	e0bfff17 	ldw	r2,-4(fp)
 90a2884:	10800117 	ldw	r2,4(r2)
 90a2888:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 90a288c:	e0bfff17 	ldw	r2,-4(fp)
 90a2890:	10c00017 	ldw	r3,0(r2)
 90a2894:	d0a08817 	ldw	r2,-32224(gp)
 90a2898:	1880031e 	bne	r3,r2,90a28a8 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 90a289c:	e0bfff17 	ldw	r2,-4(fp)
 90a28a0:	10000315 	stw	zero,12(r2)
 90a28a4:	00008b06 	br	90a2ad4 <igmp_joingroup+0x268>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 90a28a8:	e0bffe17 	ldw	r2,-8(fp)
 90a28ac:	10802d03 	ldbu	r2,180(r2)
 90a28b0:	10803fcc 	andi	r2,r2,255
 90a28b4:	1005003a 	cmpeq	r2,r2,zero
 90a28b8:	10003e1e 	bne	r2,zero,90a29b4 <igmp_joingroup+0x148>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 90a28bc:	01000484 	movi	r4,18
 90a28c0:	e17fff17 	ldw	r5,-4(fp)
 90a28c4:	90a25c40 	call	90a25c4 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 90a28c8:	008243b4 	movhi	r2,2318
 90a28cc:	10b66404 	addi	r2,r2,-9840
 90a28d0:	11000217 	ldw	r4,8(r2)
 90a28d4:	008243b4 	movhi	r2,2318
 90a28d8:	10b41e04 	addi	r2,r2,-12168
 90a28dc:	10800017 	ldw	r2,0(r2)
 90a28e0:	10800a17 	ldw	r2,40(r2)
 90a28e4:	1004d63a 	srli	r2,r2,24
 90a28e8:	10c03fcc 	andi	r3,r2,255
 90a28ec:	008243b4 	movhi	r2,2318
 90a28f0:	10b41e04 	addi	r2,r2,-12168
 90a28f4:	10800017 	ldw	r2,0(r2)
 90a28f8:	10800a17 	ldw	r2,40(r2)
 90a28fc:	1004d23a 	srli	r2,r2,8
 90a2900:	10bfc00c 	andi	r2,r2,65280
 90a2904:	1886b03a 	or	r3,r3,r2
 90a2908:	008243b4 	movhi	r2,2318
 90a290c:	10b41e04 	addi	r2,r2,-12168
 90a2910:	10800017 	ldw	r2,0(r2)
 90a2914:	10800a17 	ldw	r2,40(r2)
 90a2918:	10bfc00c 	andi	r2,r2,65280
 90a291c:	1004923a 	slli	r2,r2,8
 90a2920:	1886b03a 	or	r3,r3,r2
 90a2924:	008243b4 	movhi	r2,2318
 90a2928:	10b41e04 	addi	r2,r2,-12168
 90a292c:	10800017 	ldw	r2,0(r2)
 90a2930:	10800a17 	ldw	r2,40(r2)
 90a2934:	10803fcc 	andi	r2,r2,255
 90a2938:	1004963a 	slli	r2,r2,24
 90a293c:	1884b03a 	or	r2,r3,r2
 90a2940:	2089883a 	add	r4,r4,r2
 90a2944:	e0bfff17 	ldw	r2,-4(fp)
 90a2948:	10800017 	ldw	r2,0(r2)
 90a294c:	1004d63a 	srli	r2,r2,24
 90a2950:	10c03fcc 	andi	r3,r2,255
 90a2954:	e0bfff17 	ldw	r2,-4(fp)
 90a2958:	10800017 	ldw	r2,0(r2)
 90a295c:	1004d23a 	srli	r2,r2,8
 90a2960:	10bfc00c 	andi	r2,r2,65280
 90a2964:	1886b03a 	or	r3,r3,r2
 90a2968:	e0bfff17 	ldw	r2,-4(fp)
 90a296c:	10800017 	ldw	r2,0(r2)
 90a2970:	10bfc00c 	andi	r2,r2,65280
 90a2974:	1004923a 	slli	r2,r2,8
 90a2978:	1886b03a 	or	r3,r3,r2
 90a297c:	e0bfff17 	ldw	r2,-4(fp)
 90a2980:	10800017 	ldw	r2,0(r2)
 90a2984:	10803fcc 	andi	r2,r2,255
 90a2988:	1004963a 	slli	r2,r2,24
 90a298c:	1884b03a 	or	r2,r3,r2
 90a2990:	2087883a 	add	r3,r4,r2
 90a2994:	00800c84 	movi	r2,50
 90a2998:	1885203a 	divu	r2,r3,r2
 90a299c:	10800ca4 	muli	r2,r2,50
 90a29a0:	1885c83a 	sub	r2,r3,r2
 90a29a4:	10c00044 	addi	r3,r2,1
 90a29a8:	e0bfff17 	ldw	r2,-4(fp)
 90a29ac:	10c00315 	stw	r3,12(r2)
 90a29b0:	00003d06 	br	90a2aa8 <igmp_joingroup+0x23c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 90a29b4:	01000584 	movi	r4,22
 90a29b8:	e17fff17 	ldw	r5,-4(fp)
 90a29bc:	90a25c40 	call	90a25c4 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 90a29c0:	008243b4 	movhi	r2,2318
 90a29c4:	10b66404 	addi	r2,r2,-9840
 90a29c8:	11000217 	ldw	r4,8(r2)
 90a29cc:	008243b4 	movhi	r2,2318
 90a29d0:	10b41e04 	addi	r2,r2,-12168
 90a29d4:	10800017 	ldw	r2,0(r2)
 90a29d8:	10800a17 	ldw	r2,40(r2)
 90a29dc:	1004d63a 	srli	r2,r2,24
 90a29e0:	10c03fcc 	andi	r3,r2,255
 90a29e4:	008243b4 	movhi	r2,2318
 90a29e8:	10b41e04 	addi	r2,r2,-12168
 90a29ec:	10800017 	ldw	r2,0(r2)
 90a29f0:	10800a17 	ldw	r2,40(r2)
 90a29f4:	1004d23a 	srli	r2,r2,8
 90a29f8:	10bfc00c 	andi	r2,r2,65280
 90a29fc:	1886b03a 	or	r3,r3,r2
 90a2a00:	008243b4 	movhi	r2,2318
 90a2a04:	10b41e04 	addi	r2,r2,-12168
 90a2a08:	10800017 	ldw	r2,0(r2)
 90a2a0c:	10800a17 	ldw	r2,40(r2)
 90a2a10:	10bfc00c 	andi	r2,r2,65280
 90a2a14:	1004923a 	slli	r2,r2,8
 90a2a18:	1886b03a 	or	r3,r3,r2
 90a2a1c:	008243b4 	movhi	r2,2318
 90a2a20:	10b41e04 	addi	r2,r2,-12168
 90a2a24:	10800017 	ldw	r2,0(r2)
 90a2a28:	10800a17 	ldw	r2,40(r2)
 90a2a2c:	10803fcc 	andi	r2,r2,255
 90a2a30:	1004963a 	slli	r2,r2,24
 90a2a34:	1884b03a 	or	r2,r3,r2
 90a2a38:	2089883a 	add	r4,r4,r2
 90a2a3c:	e0bfff17 	ldw	r2,-4(fp)
 90a2a40:	10800017 	ldw	r2,0(r2)
 90a2a44:	1004d63a 	srli	r2,r2,24
 90a2a48:	10c03fcc 	andi	r3,r2,255
 90a2a4c:	e0bfff17 	ldw	r2,-4(fp)
 90a2a50:	10800017 	ldw	r2,0(r2)
 90a2a54:	1004d23a 	srli	r2,r2,8
 90a2a58:	10bfc00c 	andi	r2,r2,65280
 90a2a5c:	1886b03a 	or	r3,r3,r2
 90a2a60:	e0bfff17 	ldw	r2,-4(fp)
 90a2a64:	10800017 	ldw	r2,0(r2)
 90a2a68:	10bfc00c 	andi	r2,r2,65280
 90a2a6c:	1004923a 	slli	r2,r2,8
 90a2a70:	1886b03a 	or	r3,r3,r2
 90a2a74:	e0bfff17 	ldw	r2,-4(fp)
 90a2a78:	10800017 	ldw	r2,0(r2)
 90a2a7c:	10803fcc 	andi	r2,r2,255
 90a2a80:	1004963a 	slli	r2,r2,24
 90a2a84:	1884b03a 	or	r2,r3,r2
 90a2a88:	2087883a 	add	r3,r4,r2
 90a2a8c:	00800c84 	movi	r2,50
 90a2a90:	1885203a 	divu	r2,r3,r2
 90a2a94:	10800ca4 	muli	r2,r2,50
 90a2a98:	1885c83a 	sub	r2,r3,r2
 90a2a9c:	10c00044 	addi	r3,r2,1
 90a2aa0:	e0bfff17 	ldw	r2,-4(fp)
 90a2aa4:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a2aa8:	e0bffe17 	ldw	r2,-8(fp)
 90a2aac:	10802f03 	ldbu	r2,188(r2)
 90a2ab0:	10803fcc 	andi	r2,r2,255
 90a2ab4:	10800098 	cmpnei	r2,r2,2
 90a2ab8:	1000031e 	bne	r2,zero,90a2ac8 <igmp_joingroup+0x25c>
      {
         inm->last2send_report = IGMP_TRUE;
 90a2abc:	e0ffff17 	ldw	r3,-4(fp)
 90a2ac0:	00800044 	movi	r2,1
 90a2ac4:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 90a2ac8:	d0a08617 	ldw	r2,-32232(gp)
 90a2acc:	10800044 	addi	r2,r2,1
 90a2ad0:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
}     
 90a2ad4:	e037883a 	mov	sp,fp
 90a2ad8:	dfc00117 	ldw	ra,4(sp)
 90a2adc:	df000017 	ldw	fp,0(sp)
 90a2ae0:	dec00204 	addi	sp,sp,8
 90a2ae4:	f800283a 	ret

090a2ae8 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 90a2ae8:	defffc04 	addi	sp,sp,-16
 90a2aec:	dfc00315 	stw	ra,12(sp)
 90a2af0:	df000215 	stw	fp,8(sp)
 90a2af4:	df000204 	addi	fp,sp,8
 90a2af8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 90a2afc:	e0bfff17 	ldw	r2,-4(fp)
 90a2b00:	10800117 	ldw	r2,4(r2)
 90a2b04:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 90a2b08:	e0bffe17 	ldw	r2,-8(fp)
 90a2b0c:	10802f03 	ldbu	r2,188(r2)
 90a2b10:	10803fcc 	andi	r2,r2,255
 90a2b14:	10800098 	cmpnei	r2,r2,2
 90a2b18:	10000d1e 	bne	r2,zero,90a2b50 <igmp_leavegroup+0x68>
 90a2b1c:	e0bffe17 	ldw	r2,-8(fp)
 90a2b20:	10802d03 	ldbu	r2,180(r2)
 90a2b24:	10803fcc 	andi	r2,r2,255
 90a2b28:	1004c03a 	cmpne	r2,r2,zero
 90a2b2c:	1000081e 	bne	r2,zero,90a2b50 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 90a2b30:	e0bfff17 	ldw	r2,-4(fp)
 90a2b34:	10800403 	ldbu	r2,16(r2)
 90a2b38:	10803fcc 	andi	r2,r2,255
 90a2b3c:	10800058 	cmpnei	r2,r2,1
 90a2b40:	1000031e 	bne	r2,zero,90a2b50 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 90a2b44:	010005c4 	movi	r4,23
 90a2b48:	e17fff17 	ldw	r5,-4(fp)
 90a2b4c:	90a25c40 	call	90a25c4 <igmp_send>
   }
   
   return;
}
 90a2b50:	e037883a 	mov	sp,fp
 90a2b54:	dfc00117 	ldw	ra,4(sp)
 90a2b58:	df000017 	ldw	fp,0(sp)
 90a2b5c:	dec00204 	addi	sp,sp,8
 90a2b60:	f800283a 	ret

090a2b64 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 90a2b64:	defff504 	addi	sp,sp,-44
 90a2b68:	dfc00a15 	stw	ra,40(sp)
 90a2b6c:	df000915 	stw	fp,36(sp)
 90a2b70:	df000904 	addi	fp,sp,36
 90a2b74:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 90a2b78:	e0bffe17 	ldw	r2,-8(fp)
 90a2b7c:	10800317 	ldw	r2,12(r2)
 90a2b80:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 90a2b84:	e0bffe17 	ldw	r2,-8(fp)
 90a2b88:	10c00417 	ldw	r3,16(r2)
 90a2b8c:	e0bffd17 	ldw	r2,-12(fp)
 90a2b90:	10800003 	ldbu	r2,0(r2)
 90a2b94:	10803fcc 	andi	r2,r2,255
 90a2b98:	108003cc 	andi	r2,r2,15
 90a2b9c:	1085883a 	add	r2,r2,r2
 90a2ba0:	1085883a 	add	r2,r2,r2
 90a2ba4:	1885c83a 	sub	r2,r3,r2
 90a2ba8:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 90a2bac:	e0bffc17 	ldw	r2,-16(fp)
 90a2bb0:	10800220 	cmpeqi	r2,r2,8
 90a2bb4:	10000a1e 	bne	r2,zero,90a2be0 <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 90a2bb8:	008243b4 	movhi	r2,2318
 90a2bbc:	10b42204 	addi	r2,r2,-12152
 90a2bc0:	10800a17 	ldw	r2,40(r2)
 90a2bc4:	10c00044 	addi	r3,r2,1
 90a2bc8:	008243b4 	movhi	r2,2318
 90a2bcc:	10b42204 	addi	r2,r2,-12152
 90a2bd0:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 90a2bd4:	00bff804 	movi	r2,-32
 90a2bd8:	e0bfff15 	stw	r2,-4(fp)
 90a2bdc:	0000b206 	br	90a2ea8 <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 90a2be0:	e0bffd17 	ldw	r2,-12(fp)
 90a2be4:	10800003 	ldbu	r2,0(r2)
 90a2be8:	10803fcc 	andi	r2,r2,255
 90a2bec:	108003cc 	andi	r2,r2,15
 90a2bf0:	1085883a 	add	r2,r2,r2
 90a2bf4:	1085883a 	add	r2,r2,r2
 90a2bf8:	1007883a 	mov	r3,r2
 90a2bfc:	e0bffd17 	ldw	r2,-12(fp)
 90a2c00:	1885883a 	add	r2,r3,r2
 90a2c04:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 90a2c08:	e0bffb17 	ldw	r2,-20(fp)
 90a2c0c:	1080008b 	ldhu	r2,2(r2)
 90a2c10:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 90a2c14:	e0bffb17 	ldw	r2,-20(fp)
 90a2c18:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 90a2c1c:	e0bffc17 	ldw	r2,-16(fp)
 90a2c20:	1005d07a 	srai	r2,r2,1
 90a2c24:	100b883a 	mov	r5,r2
 90a2c28:	e13ffb17 	ldw	r4,-20(fp)
 90a2c2c:	90a3f040 	call	90a3f04 <cksum>
 90a2c30:	0084303a 	nor	r2,zero,r2
 90a2c34:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 90a2c38:	e0fff98b 	ldhu	r3,-26(fp)
 90a2c3c:	e0bffa0b 	ldhu	r2,-24(fp)
 90a2c40:	18800d26 	beq	r3,r2,90a2c78 <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 90a2c44:	e0fffb17 	ldw	r3,-20(fp)
 90a2c48:	e0bffa0b 	ldhu	r2,-24(fp)
 90a2c4c:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 90a2c50:	008243b4 	movhi	r2,2318
 90a2c54:	10b42204 	addi	r2,r2,-12152
 90a2c58:	10800b17 	ldw	r2,44(r2)
 90a2c5c:	10c00044 	addi	r3,r2,1
 90a2c60:	008243b4 	movhi	r2,2318
 90a2c64:	10b42204 	addi	r2,r2,-12152
 90a2c68:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 90a2c6c:	00bff804 	movi	r2,-32
 90a2c70:	e0bfff15 	stw	r2,-4(fp)
 90a2c74:	00008c06 	br	90a2ea8 <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 90a2c78:	e0bffb17 	ldw	r2,-20(fp)
 90a2c7c:	10800003 	ldbu	r2,0(r2)
 90a2c80:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 90a2c84:	e0bffb17 	ldw	r2,-20(fp)
 90a2c88:	10800117 	ldw	r2,4(r2)
 90a2c8c:	1004d63a 	srli	r2,r2,24
 90a2c90:	10c03fcc 	andi	r3,r2,255
 90a2c94:	e0bffb17 	ldw	r2,-20(fp)
 90a2c98:	10800117 	ldw	r2,4(r2)
 90a2c9c:	1004d23a 	srli	r2,r2,8
 90a2ca0:	10bfc00c 	andi	r2,r2,65280
 90a2ca4:	1886b03a 	or	r3,r3,r2
 90a2ca8:	e0bffb17 	ldw	r2,-20(fp)
 90a2cac:	10800117 	ldw	r2,4(r2)
 90a2cb0:	10bfc00c 	andi	r2,r2,65280
 90a2cb4:	1004923a 	slli	r2,r2,8
 90a2cb8:	1886b03a 	or	r3,r3,r2
 90a2cbc:	e0bffb17 	ldw	r2,-20(fp)
 90a2cc0:	10800117 	ldw	r2,4(r2)
 90a2cc4:	10803fcc 	andi	r2,r2,255
 90a2cc8:	1004963a 	slli	r2,r2,24
 90a2ccc:	1884b03a 	or	r2,r3,r2
 90a2cd0:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 90a2cd4:	e0bffb17 	ldw	r2,-20(fp)
 90a2cd8:	10800043 	ldbu	r2,1(r2)
 90a2cdc:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 90a2ce0:	e0bff903 	ldbu	r2,-28(fp)
 90a2ce4:	10800458 	cmpnei	r2,r2,17
 90a2ce8:	1000381e 	bne	r2,zero,90a2dcc <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 90a2cec:	e0bff703 	ldbu	r2,-36(fp)
 90a2cf0:	1005003a 	cmpeq	r2,r2,zero
 90a2cf4:	1000061e 	bne	r2,zero,90a2d10 <igmp_validate+0x1ac>
 90a2cf8:	e0bff703 	ldbu	r2,-36(fp)
 90a2cfc:	1005003a 	cmpeq	r2,r2,zero
 90a2d00:	1000111e 	bne	r2,zero,90a2d48 <igmp_validate+0x1e4>
 90a2d04:	e0bff817 	ldw	r2,-32(fp)
 90a2d08:	1004c03a 	cmpne	r2,r2,zero
 90a2d0c:	10000e1e 	bne	r2,zero,90a2d48 <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 90a2d10:	e0bffd17 	ldw	r2,-12(fp)
 90a2d14:	10c00417 	ldw	r3,16(r2)
 90a2d18:	d0a08817 	ldw	r2,-32224(gp)
 90a2d1c:	18800a26 	beq	r3,r2,90a2d48 <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 90a2d20:	008243b4 	movhi	r2,2318
 90a2d24:	10b42204 	addi	r2,r2,-12152
 90a2d28:	10800e17 	ldw	r2,56(r2)
 90a2d2c:	10c00044 	addi	r3,r2,1
 90a2d30:	008243b4 	movhi	r2,2318
 90a2d34:	10b42204 	addi	r2,r2,-12152
 90a2d38:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 90a2d3c:	00bff804 	movi	r2,-32
 90a2d40:	e0bfff15 	stw	r2,-4(fp)
 90a2d44:	00005806 	br	90a2ea8 <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 90a2d48:	e0bff703 	ldbu	r2,-36(fp)
 90a2d4c:	1005003a 	cmpeq	r2,r2,zero
 90a2d50:	10001e1e 	bne	r2,zero,90a2dcc <igmp_validate+0x268>
 90a2d54:	e0bff817 	ldw	r2,-32(fp)
 90a2d58:	1005003a 	cmpeq	r2,r2,zero
 90a2d5c:	10001b1e 	bne	r2,zero,90a2dcc <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 90a2d60:	e0bffe17 	ldw	r2,-8(fp)
 90a2d64:	10800617 	ldw	r2,24(r2)
 90a2d68:	10802f03 	ldbu	r2,188(r2)
 90a2d6c:	10803fcc 	andi	r2,r2,255
 90a2d70:	10800058 	cmpnei	r2,r2,1
 90a2d74:	1000031e 	bne	r2,zero,90a2d84 <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 90a2d78:	00bff804 	movi	r2,-32
 90a2d7c:	e0bfff15 	stw	r2,-4(fp)
 90a2d80:	00004906 	br	90a2ea8 <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 90a2d84:	e0bff817 	ldw	r2,-32(fp)
 90a2d88:	10fc002c 	andhi	r3,r2,61440
 90a2d8c:	00b80034 	movhi	r2,57344
 90a2d90:	1880041e 	bne	r3,r2,90a2da4 <igmp_validate+0x240>
 90a2d94:	e0bffb17 	ldw	r2,-20(fp)
 90a2d98:	10c00117 	ldw	r3,4(r2)
 90a2d9c:	d0a08817 	ldw	r2,-32224(gp)
 90a2da0:	18800a1e 	bne	r3,r2,90a2dcc <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 90a2da4:	008243b4 	movhi	r2,2318
 90a2da8:	10b42204 	addi	r2,r2,-12152
 90a2dac:	10801117 	ldw	r2,68(r2)
 90a2db0:	10c00044 	addi	r3,r2,1
 90a2db4:	008243b4 	movhi	r2,2318
 90a2db8:	10b42204 	addi	r2,r2,-12152
 90a2dbc:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 90a2dc0:	00bff804 	movi	r2,-32
 90a2dc4:	e0bfff15 	stw	r2,-4(fp)
 90a2dc8:	00003706 	br	90a2ea8 <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 90a2dcc:	e0bff903 	ldbu	r2,-28(fp)
 90a2dd0:	108004a0 	cmpeqi	r2,r2,18
 90a2dd4:	1000031e 	bne	r2,zero,90a2de4 <igmp_validate+0x280>
 90a2dd8:	e0bff903 	ldbu	r2,-28(fp)
 90a2ddc:	10800598 	cmpnei	r2,r2,22
 90a2de0:	1000131e 	bne	r2,zero,90a2e30 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 90a2de4:	e0bffb17 	ldw	r2,-20(fp)
 90a2de8:	10c00117 	ldw	r3,4(r2)
 90a2dec:	e0bffd17 	ldw	r2,-12(fp)
 90a2df0:	10800417 	ldw	r2,16(r2)
 90a2df4:	1880041e 	bne	r3,r2,90a2e08 <igmp_validate+0x2a4>
 90a2df8:	e0bff817 	ldw	r2,-32(fp)
 90a2dfc:	10fc002c 	andhi	r3,r2,61440
 90a2e00:	00b80034 	movhi	r2,57344
 90a2e04:	18800a26 	beq	r3,r2,90a2e30 <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 90a2e08:	008243b4 	movhi	r2,2318
 90a2e0c:	10b42204 	addi	r2,r2,-12152
 90a2e10:	10800f17 	ldw	r2,60(r2)
 90a2e14:	10c00044 	addi	r3,r2,1
 90a2e18:	008243b4 	movhi	r2,2318
 90a2e1c:	10b42204 	addi	r2,r2,-12152
 90a2e20:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 90a2e24:	00bff804 	movi	r2,-32
 90a2e28:	e0bfff15 	stw	r2,-4(fp)
 90a2e2c:	00001e06 	br	90a2ea8 <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a2e30:	e0bff903 	ldbu	r2,-28(fp)
 90a2e34:	108005e0 	cmpeqi	r2,r2,23
 90a2e38:	10000b1e 	bne	r2,zero,90a2e68 <igmp_validate+0x304>
 90a2e3c:	e0bff903 	ldbu	r2,-28(fp)
 90a2e40:	108005a0 	cmpeqi	r2,r2,22
 90a2e44:	1000081e 	bne	r2,zero,90a2e68 <igmp_validate+0x304>
 90a2e48:	e0bff903 	ldbu	r2,-28(fp)
 90a2e4c:	10800458 	cmpnei	r2,r2,17
 90a2e50:	1000141e 	bne	r2,zero,90a2ea4 <igmp_validate+0x340>
 90a2e54:	e0bffb17 	ldw	r2,-20(fp)
 90a2e58:	10800043 	ldbu	r2,1(r2)
 90a2e5c:	10803fcc 	andi	r2,r2,255
 90a2e60:	1005003a 	cmpeq	r2,r2,zero
 90a2e64:	10000f1e 	bne	r2,zero,90a2ea4 <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 90a2e68:	e13ffd17 	ldw	r4,-12(fp)
 90a2e6c:	90c45f40 	call	90c45f4 <igmpv2_chk4_rtr_alert_opt>
 90a2e70:	10803fcc 	andi	r2,r2,255
 90a2e74:	1004c03a 	cmpne	r2,r2,zero
 90a2e78:	10000a1e 	bne	r2,zero,90a2ea4 <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 90a2e7c:	008243b4 	movhi	r2,2318
 90a2e80:	10b42204 	addi	r2,r2,-12152
 90a2e84:	10801417 	ldw	r2,80(r2)
 90a2e88:	10c00044 	addi	r3,r2,1
 90a2e8c:	008243b4 	movhi	r2,2318
 90a2e90:	10b42204 	addi	r2,r2,-12152
 90a2e94:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 90a2e98:	00bff804 	movi	r2,-32
 90a2e9c:	e0bfff15 	stw	r2,-4(fp)
 90a2ea0:	00000106 	br	90a2ea8 <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 90a2ea4:	e03fff15 	stw	zero,-4(fp)
 90a2ea8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a2eac:	e037883a 	mov	sp,fp
 90a2eb0:	dfc00117 	ldw	ra,4(sp)
 90a2eb4:	df000017 	ldw	fp,0(sp)
 90a2eb8:	dec00204 	addi	sp,sp,8
 90a2ebc:	f800283a 	ret

090a2ec0 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 90a2ec0:	defff504 	addi	sp,sp,-44
 90a2ec4:	dfc00a15 	stw	ra,40(sp)
 90a2ec8:	df000915 	stw	fp,36(sp)
 90a2ecc:	df000904 	addi	fp,sp,36
 90a2ed0:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a2ed4:	008243b4 	movhi	r2,2318
 90a2ed8:	10b65f04 	addi	r2,r2,-9860
 90a2edc:	10800017 	ldw	r2,0(r2)
 90a2ee0:	e0bff915 	stw	r2,-28(fp)
 90a2ee4:	00004506 	br	90a2ffc <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 90a2ee8:	e0bff917 	ldw	r2,-28(fp)
 90a2eec:	10800104 	addi	r2,r2,4
 90a2ef0:	e0bfff15 	stw	r2,-4(fp)
 90a2ef4:	e0bff917 	ldw	r2,-28(fp)
 90a2ef8:	10802f03 	ldbu	r2,188(r2)
 90a2efc:	10803fcc 	andi	r2,r2,255
 90a2f00:	e0bffe15 	stw	r2,-8(fp)
 90a2f04:	e0bff917 	ldw	r2,-28(fp)
 90a2f08:	10802f03 	ldbu	r2,188(r2)
 90a2f0c:	10803fcc 	andi	r2,r2,255
 90a2f10:	10800058 	cmpnei	r2,r2,1
 90a2f14:	1000041e 	bne	r2,zero,90a2f28 <igmp_print_stats+0x68>
 90a2f18:	00824374 	movhi	r2,2317
 90a2f1c:	10bc0a04 	addi	r2,r2,-4056
 90a2f20:	e0bffd15 	stw	r2,-12(fp)
 90a2f24:	00000306 	br	90a2f34 <igmp_print_stats+0x74>
 90a2f28:	00824374 	movhi	r2,2317
 90a2f2c:	10bc0b04 	addi	r2,r2,-4052
 90a2f30:	e0bffd15 	stw	r2,-12(fp)
 90a2f34:	e0bffd17 	ldw	r2,-12(fp)
 90a2f38:	d8800015 	stw	r2,0(sp)
 90a2f3c:	e13ffa17 	ldw	r4,-24(fp)
 90a2f40:	01424374 	movhi	r5,2317
 90a2f44:	297c0c04 	addi	r5,r5,-4048
 90a2f48:	e1bfff17 	ldw	r6,-4(fp)
 90a2f4c:	e1fffe17 	ldw	r7,-8(fp)
 90a2f50:	90a45b40 	call	90a45b4 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a2f54:	e0bff917 	ldw	r2,-28(fp)
 90a2f58:	10802f03 	ldbu	r2,188(r2)
 90a2f5c:	10803fcc 	andi	r2,r2,255
 90a2f60:	10800098 	cmpnei	r2,r2,2
 90a2f64:	10001e1e 	bne	r2,zero,90a2fe0 <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 90a2f68:	e0bff917 	ldw	r2,-28(fp)
 90a2f6c:	10802d03 	ldbu	r2,180(r2)
 90a2f70:	10803fcc 	andi	r2,r2,255
 90a2f74:	e0bffc15 	stw	r2,-16(fp)
 90a2f78:	e0bff917 	ldw	r2,-28(fp)
 90a2f7c:	10802d03 	ldbu	r2,180(r2)
 90a2f80:	10803fcc 	andi	r2,r2,255
 90a2f84:	10800058 	cmpnei	r2,r2,1
 90a2f88:	1000041e 	bne	r2,zero,90a2f9c <igmp_print_stats+0xdc>
 90a2f8c:	00824374 	movhi	r2,2317
 90a2f90:	10bc1104 	addi	r2,r2,-4028
 90a2f94:	e0bffb15 	stw	r2,-20(fp)
 90a2f98:	00000306 	br	90a2fa8 <igmp_print_stats+0xe8>
 90a2f9c:	00824374 	movhi	r2,2317
 90a2fa0:	10bc1304 	addi	r2,r2,-4020
 90a2fa4:	e0bffb15 	stw	r2,-20(fp)
 90a2fa8:	e0bff917 	ldw	r2,-28(fp)
 90a2fac:	10c02e17 	ldw	r3,184(r2)
 90a2fb0:	00824374 	movhi	r2,2317
 90a2fb4:	108c4204 	addi	r2,r2,12552
 90a2fb8:	10800017 	ldw	r2,0(r2)
 90a2fbc:	d8c00015 	stw	r3,0(sp)
 90a2fc0:	d8800115 	stw	r2,4(sp)
 90a2fc4:	e13ffa17 	ldw	r4,-24(fp)
 90a2fc8:	01424374 	movhi	r5,2317
 90a2fcc:	297c1504 	addi	r5,r5,-4012
 90a2fd0:	e1bffc17 	ldw	r6,-16(fp)
 90a2fd4:	e1fffb17 	ldw	r7,-20(fp)
 90a2fd8:	90a45b40 	call	90a45b4 <ns_printf>
 90a2fdc:	00000406 	br	90a2ff0 <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 90a2fe0:	e13ffa17 	ldw	r4,-24(fp)
 90a2fe4:	01424374 	movhi	r5,2317
 90a2fe8:	297c2004 	addi	r5,r5,-3968
 90a2fec:	90a45b40 	call	90a45b4 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a2ff0:	e0bff917 	ldw	r2,-28(fp)
 90a2ff4:	10800017 	ldw	r2,0(r2)
 90a2ff8:	e0bff915 	stw	r2,-28(fp)
 90a2ffc:	e0bff917 	ldw	r2,-28(fp)
 90a3000:	1004c03a 	cmpne	r2,r2,zero
 90a3004:	103fb81e 	bne	r2,zero,90a2ee8 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 90a3008:	008243b4 	movhi	r2,2318
 90a300c:	10b42204 	addi	r2,r2,-12152
 90a3010:	11800017 	ldw	r6,0(r2)
 90a3014:	d1e08617 	ldw	r7,-32232(gp)
 90a3018:	e13ffa17 	ldw	r4,-24(fp)
 90a301c:	01424374 	movhi	r5,2317
 90a3020:	297c2104 	addi	r5,r5,-3964
 90a3024:	90a45b40 	call	90a45b4 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 90a3028:	008243b4 	movhi	r2,2318
 90a302c:	10b42204 	addi	r2,r2,-12152
 90a3030:	11800117 	ldw	r6,4(r2)
 90a3034:	e13ffa17 	ldw	r4,-24(fp)
 90a3038:	01424374 	movhi	r5,2317
 90a303c:	297c2e04 	addi	r5,r5,-3912
 90a3040:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 90a3044:	008243b4 	movhi	r2,2318
 90a3048:	10b42204 	addi	r2,r2,-12152
 90a304c:	11800217 	ldw	r6,8(r2)
 90a3050:	e13ffa17 	ldw	r4,-24(fp)
 90a3054:	01424374 	movhi	r5,2317
 90a3058:	297c3f04 	addi	r5,r5,-3844
 90a305c:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 90a3060:	008243b4 	movhi	r2,2318
 90a3064:	10b42204 	addi	r2,r2,-12152
 90a3068:	11800317 	ldw	r6,12(r2)
 90a306c:	e13ffa17 	ldw	r4,-24(fp)
 90a3070:	01424374 	movhi	r5,2317
 90a3074:	297c4b04 	addi	r5,r5,-3796
 90a3078:	90a45b40 	call	90a45b4 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 90a307c:	008243b4 	movhi	r2,2318
 90a3080:	10b42204 	addi	r2,r2,-12152
 90a3084:	11800417 	ldw	r6,16(r2)
 90a3088:	e13ffa17 	ldw	r4,-24(fp)
 90a308c:	01424374 	movhi	r5,2317
 90a3090:	297c5e04 	addi	r5,r5,-3720
 90a3094:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 90a3098:	008243b4 	movhi	r2,2318
 90a309c:	10b42204 	addi	r2,r2,-12152
 90a30a0:	11800517 	ldw	r6,20(r2)
 90a30a4:	008243b4 	movhi	r2,2318
 90a30a8:	10b42204 	addi	r2,r2,-12152
 90a30ac:	11c00617 	ldw	r7,24(r2)
 90a30b0:	e13ffa17 	ldw	r4,-24(fp)
 90a30b4:	01424374 	movhi	r5,2317
 90a30b8:	297c6f04 	addi	r5,r5,-3652
 90a30bc:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 90a30c0:	008243b4 	movhi	r2,2318
 90a30c4:	10b42204 	addi	r2,r2,-12152
 90a30c8:	11800717 	ldw	r6,28(r2)
 90a30cc:	e13ffa17 	ldw	r4,-24(fp)
 90a30d0:	01424374 	movhi	r5,2317
 90a30d4:	297c4b04 	addi	r5,r5,-3796
 90a30d8:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 90a30dc:	008243b4 	movhi	r2,2318
 90a30e0:	10b42204 	addi	r2,r2,-12152
 90a30e4:	11800817 	ldw	r6,32(r2)
 90a30e8:	e13ffa17 	ldw	r4,-24(fp)
 90a30ec:	01424374 	movhi	r5,2317
 90a30f0:	297c8204 	addi	r5,r5,-3576
 90a30f4:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 90a30f8:	008243b4 	movhi	r2,2318
 90a30fc:	10b42204 	addi	r2,r2,-12152
 90a3100:	11800917 	ldw	r6,36(r2)
 90a3104:	e13ffa17 	ldw	r4,-24(fp)
 90a3108:	01424374 	movhi	r5,2317
 90a310c:	297c9304 	addi	r5,r5,-3508
 90a3110:	90a45b40 	call	90a45b4 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 90a3114:	008243b4 	movhi	r2,2318
 90a3118:	10b42204 	addi	r2,r2,-12152
 90a311c:	11801717 	ldw	r6,92(r2)
 90a3120:	008243b4 	movhi	r2,2318
 90a3124:	10b42204 	addi	r2,r2,-12152
 90a3128:	11c01817 	ldw	r7,96(r2)
 90a312c:	e13ffa17 	ldw	r4,-24(fp)
 90a3130:	01424374 	movhi	r5,2317
 90a3134:	297c9f04 	addi	r5,r5,-3460
 90a3138:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 90a313c:	008243b4 	movhi	r2,2318
 90a3140:	10b42204 	addi	r2,r2,-12152
 90a3144:	11801617 	ldw	r6,88(r2)
 90a3148:	e13ffa17 	ldw	r4,-24(fp)
 90a314c:	01424374 	movhi	r5,2317
 90a3150:	297cb204 	addi	r5,r5,-3384
 90a3154:	90a45b40 	call	90a45b4 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 90a3158:	008243b4 	movhi	r2,2318
 90a315c:	10b42204 	addi	r2,r2,-12152
 90a3160:	11800a17 	ldw	r6,40(r2)
 90a3164:	e13ffa17 	ldw	r4,-24(fp)
 90a3168:	01424374 	movhi	r5,2317
 90a316c:	297cbe04 	addi	r5,r5,-3336
 90a3170:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 90a3174:	008243b4 	movhi	r2,2318
 90a3178:	10b42204 	addi	r2,r2,-12152
 90a317c:	11800b17 	ldw	r6,44(r2)
 90a3180:	e13ffa17 	ldw	r4,-24(fp)
 90a3184:	01424374 	movhi	r5,2317
 90a3188:	297cca04 	addi	r5,r5,-3288
 90a318c:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 90a3190:	008243b4 	movhi	r2,2318
 90a3194:	10b42204 	addi	r2,r2,-12152
 90a3198:	11800c17 	ldw	r6,48(r2)
 90a319c:	008243b4 	movhi	r2,2318
 90a31a0:	10b42204 	addi	r2,r2,-12152
 90a31a4:	11c00d17 	ldw	r7,52(r2)
 90a31a8:	e13ffa17 	ldw	r4,-24(fp)
 90a31ac:	01424374 	movhi	r5,2317
 90a31b0:	297cd604 	addi	r5,r5,-3240
 90a31b4:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 90a31b8:	008243b4 	movhi	r2,2318
 90a31bc:	10b42204 	addi	r2,r2,-12152
 90a31c0:	11800e17 	ldw	r6,56(r2)
 90a31c4:	008243b4 	movhi	r2,2318
 90a31c8:	10b42204 	addi	r2,r2,-12152
 90a31cc:	11c00f17 	ldw	r7,60(r2)
 90a31d0:	e13ffa17 	ldw	r4,-24(fp)
 90a31d4:	01424374 	movhi	r5,2317
 90a31d8:	297cea04 	addi	r5,r5,-3160
 90a31dc:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 90a31e0:	008243b4 	movhi	r2,2318
 90a31e4:	10b42204 	addi	r2,r2,-12152
 90a31e8:	11801117 	ldw	r6,68(r2)
 90a31ec:	e13ffa17 	ldw	r4,-24(fp)
 90a31f0:	01424374 	movhi	r5,2317
 90a31f4:	297cfa04 	addi	r5,r5,-3096
 90a31f8:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 90a31fc:	008243b4 	movhi	r2,2318
 90a3200:	10b42204 	addi	r2,r2,-12152
 90a3204:	11801217 	ldw	r6,72(r2)
 90a3208:	e13ffa17 	ldw	r4,-24(fp)
 90a320c:	01424374 	movhi	r5,2317
 90a3210:	297d0704 	addi	r5,r5,-3044
 90a3214:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 90a3218:	008243b4 	movhi	r2,2318
 90a321c:	10b42204 	addi	r2,r2,-12152
 90a3220:	11801317 	ldw	r6,76(r2)
 90a3224:	e13ffa17 	ldw	r4,-24(fp)
 90a3228:	01424374 	movhi	r5,2317
 90a322c:	297d1a04 	addi	r5,r5,-2968
 90a3230:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 90a3234:	008243b4 	movhi	r2,2318
 90a3238:	10b42204 	addi	r2,r2,-12152
 90a323c:	11801417 	ldw	r6,80(r2)
 90a3240:	e13ffa17 	ldw	r4,-24(fp)
 90a3244:	01424374 	movhi	r5,2317
 90a3248:	297d2b04 	addi	r5,r5,-2900
 90a324c:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 90a3250:	008243b4 	movhi	r2,2318
 90a3254:	10b42204 	addi	r2,r2,-12152
 90a3258:	11801017 	ldw	r6,64(r2)
 90a325c:	e13ffa17 	ldw	r4,-24(fp)
 90a3260:	01424374 	movhi	r5,2317
 90a3264:	297d3d04 	addi	r5,r5,-2828
 90a3268:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 90a326c:	008243b4 	movhi	r2,2318
 90a3270:	10b42204 	addi	r2,r2,-12152
 90a3274:	11801517 	ldw	r6,84(r2)
 90a3278:	e13ffa17 	ldw	r4,-24(fp)
 90a327c:	01424374 	movhi	r5,2317
 90a3280:	297d4d04 	addi	r5,r5,-2764
 90a3284:	90a45b40 	call	90a45b4 <ns_printf>
   
   return IGMP_OK;
 90a3288:	0005883a 	mov	r2,zero
}
 90a328c:	e037883a 	mov	sp,fp
 90a3290:	dfc00117 	ldw	ra,4(sp)
 90a3294:	df000017 	ldw	fp,0(sp)
 90a3298:	dec00204 	addi	sp,sp,8
 90a329c:	f800283a 	ret

090a32a0 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 90a32a0:	defff304 	addi	sp,sp,-52
 90a32a4:	dfc00c15 	stw	ra,48(sp)
 90a32a8:	df000b15 	stw	fp,44(sp)
 90a32ac:	df000b04 	addi	fp,sp,44
 90a32b0:	e13ffc15 	stw	r4,-16(fp)
 90a32b4:	e17ffd15 	stw	r5,-12(fp)
 90a32b8:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 90a32bc:	e0bffc17 	ldw	r2,-16(fp)
 90a32c0:	10bff804 	addi	r2,r2,-32
 90a32c4:	1085883a 	add	r2,r2,r2
 90a32c8:	1085883a 	add	r2,r2,r2
 90a32cc:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 90a32d0:	008243b4 	movhi	r2,2318
 90a32d4:	10b55b04 	addi	r2,r2,-10900
 90a32d8:	e0bff515 	stw	r2,-44(fp)
 90a32dc:	00000606 	br	90a32f8 <bsd_accept+0x58>
 90a32e0:	e0fff517 	ldw	r3,-44(fp)
 90a32e4:	e0bff717 	ldw	r2,-36(fp)
 90a32e8:	18800626 	beq	r3,r2,90a3304 <bsd_accept+0x64>
 90a32ec:	e0bff517 	ldw	r2,-44(fp)
 90a32f0:	10800017 	ldw	r2,0(r2)
 90a32f4:	e0bff515 	stw	r2,-44(fp)
 90a32f8:	e0bff517 	ldw	r2,-44(fp)
 90a32fc:	1004c03a 	cmpne	r2,r2,zero
 90a3300:	103ff71e 	bne	r2,zero,90a32e0 <bsd_accept+0x40>
 90a3304:	e0fff517 	ldw	r3,-44(fp)
 90a3308:	e0bff717 	ldw	r2,-36(fp)
 90a330c:	18800426 	beq	r3,r2,90a3320 <bsd_accept+0x80>
 90a3310:	90a94880 	call	90a9488 <dtrap>
 90a3314:	00bfffc4 	movi	r2,-1
 90a3318:	e0bfff15 	stw	r2,-4(fp)
 90a331c:	00002806 	br	90a33c0 <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 90a3320:	e0bffd17 	ldw	r2,-12(fp)
 90a3324:	1005003a 	cmpeq	r2,r2,zero
 90a3328:	1000091e 	bne	r2,zero,90a3350 <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 90a332c:	e0bffe17 	ldw	r2,-8(fp)
 90a3330:	1004c03a 	cmpne	r2,r2,zero
 90a3334:	1000061e 	bne	r2,zero,90a3350 <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 90a3338:	e0fff717 	ldw	r3,-36(fp)
 90a333c:	00800384 	movi	r2,14
 90a3340:	18800615 	stw	r2,24(r3)
         return -1;
 90a3344:	00bfffc4 	movi	r2,-1
 90a3348:	e0bfff15 	stw	r2,-4(fp)
 90a334c:	00001c06 	br	90a33c0 <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 90a3350:	e17ff804 	addi	r5,fp,-32
 90a3354:	e13ffc17 	ldw	r4,-16(fp)
 90a3358:	e1bffe17 	ldw	r6,-8(fp)
 90a335c:	90ac8740 	call	90ac874 <t_accept>
 90a3360:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 90a3364:	e0bff617 	ldw	r2,-40(fp)
 90a3368:	10bfffe0 	cmpeqi	r2,r2,-1
 90a336c:	1000121e 	bne	r2,zero,90a33b8 <bsd_accept+0x118>
 90a3370:	e0bffd17 	ldw	r2,-12(fp)
 90a3374:	1005003a 	cmpeq	r2,r2,zero
 90a3378:	10000f1e 	bne	r2,zero,90a33b8 <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 90a337c:	e0bffe17 	ldw	r2,-8(fp)
 90a3380:	10800017 	ldw	r2,0(r2)
 90a3384:	10800470 	cmpltui	r2,r2,17
 90a3388:	1000031e 	bne	r2,zero,90a3398 <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 90a338c:	e0fffe17 	ldw	r3,-8(fp)
 90a3390:	00800404 	movi	r2,16
 90a3394:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 90a3398:	e0bffe17 	ldw	r2,-8(fp)
 90a339c:	10800017 	ldw	r2,0(r2)
 90a33a0:	100d883a 	mov	r6,r2
 90a33a4:	e0bffd17 	ldw	r2,-12(fp)
 90a33a8:	e0fff804 	addi	r3,fp,-32
 90a33ac:	1009883a 	mov	r4,r2
 90a33b0:	180b883a 	mov	r5,r3
 90a33b4:	90822780 	call	9082278 <memcpy>
   }

   return lret;
 90a33b8:	e0bff617 	ldw	r2,-40(fp)
 90a33bc:	e0bfff15 	stw	r2,-4(fp)
 90a33c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a33c4:	e037883a 	mov	sp,fp
 90a33c8:	dfc00117 	ldw	ra,4(sp)
 90a33cc:	df000017 	ldw	fp,0(sp)
 90a33d0:	dec00204 	addi	sp,sp,8
 90a33d4:	f800283a 	ret

090a33d8 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 90a33d8:	defff204 	addi	sp,sp,-56
 90a33dc:	dfc00d15 	stw	ra,52(sp)
 90a33e0:	df000c15 	stw	fp,48(sp)
 90a33e4:	df000c04 	addi	fp,sp,48
 90a33e8:	e13ffc15 	stw	r4,-16(fp)
 90a33ec:	e17ffd15 	stw	r5,-12(fp)
 90a33f0:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 90a33f4:	e0bffc17 	ldw	r2,-16(fp)
 90a33f8:	10bff804 	addi	r2,r2,-32
 90a33fc:	1085883a 	add	r2,r2,r2
 90a3400:	1085883a 	add	r2,r2,r2
 90a3404:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 90a3408:	008243b4 	movhi	r2,2318
 90a340c:	10b55b04 	addi	r2,r2,-10900
 90a3410:	e0bff415 	stw	r2,-48(fp)
 90a3414:	00000606 	br	90a3430 <bsd_getpeername+0x58>
 90a3418:	e0fff417 	ldw	r3,-48(fp)
 90a341c:	e0bff617 	ldw	r2,-40(fp)
 90a3420:	18800626 	beq	r3,r2,90a343c <bsd_getpeername+0x64>
 90a3424:	e0bff417 	ldw	r2,-48(fp)
 90a3428:	10800017 	ldw	r2,0(r2)
 90a342c:	e0bff415 	stw	r2,-48(fp)
 90a3430:	e0bff417 	ldw	r2,-48(fp)
 90a3434:	1004c03a 	cmpne	r2,r2,zero
 90a3438:	103ff71e 	bne	r2,zero,90a3418 <bsd_getpeername+0x40>
 90a343c:	e0fff417 	ldw	r3,-48(fp)
 90a3440:	e0bff617 	ldw	r2,-40(fp)
 90a3444:	18800426 	beq	r3,r2,90a3458 <bsd_getpeername+0x80>
 90a3448:	90a94880 	call	90a9488 <dtrap>
 90a344c:	00bfffc4 	movi	r2,-1
 90a3450:	e0bfff15 	stw	r2,-4(fp)
 90a3454:	00002506 	br	90a34ec <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 90a3458:	e0bffe17 	ldw	r2,-8(fp)
 90a345c:	1004c03a 	cmpne	r2,r2,zero
 90a3460:	1000061e 	bne	r2,zero,90a347c <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 90a3464:	e0fff617 	ldw	r3,-40(fp)
 90a3468:	00800384 	movi	r2,14
 90a346c:	18800615 	stw	r2,24(r3)
      return -1;
 90a3470:	00bfffc4 	movi	r2,-1
 90a3474:	e0bfff15 	stw	r2,-4(fp)
 90a3478:	00001c06 	br	90a34ec <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 90a347c:	e0bffe17 	ldw	r2,-8(fp)
 90a3480:	10800017 	ldw	r2,0(r2)
 90a3484:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 90a3488:	e17ff704 	addi	r5,fp,-36
 90a348c:	e1bffb04 	addi	r6,fp,-20
 90a3490:	e13ffc17 	ldw	r4,-16(fp)
 90a3494:	90acdb40 	call	90acdb4 <t_getpeername>
 90a3498:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 90a349c:	e0bff517 	ldw	r2,-44(fp)
 90a34a0:	10bfffe0 	cmpeqi	r2,r2,-1
 90a34a4:	10000f1e 	bne	r2,zero,90a34e4 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 90a34a8:	e0bffb17 	ldw	r2,-20(fp)
 90a34ac:	10800470 	cmpltui	r2,r2,17
 90a34b0:	1000021e 	bne	r2,zero,90a34bc <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 90a34b4:	00800404 	movi	r2,16
 90a34b8:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 90a34bc:	e0bffb17 	ldw	r2,-20(fp)
 90a34c0:	100d883a 	mov	r6,r2
 90a34c4:	e0bffd17 	ldw	r2,-12(fp)
 90a34c8:	e0fff704 	addi	r3,fp,-36
 90a34cc:	1009883a 	mov	r4,r2
 90a34d0:	180b883a 	mov	r5,r3
 90a34d4:	90822780 	call	9082278 <memcpy>
      *namelen = lnamelen;
 90a34d8:	e0fffb17 	ldw	r3,-20(fp)
 90a34dc:	e0bffe17 	ldw	r2,-8(fp)
 90a34e0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a34e4:	e0bff517 	ldw	r2,-44(fp)
 90a34e8:	e0bfff15 	stw	r2,-4(fp)
 90a34ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90a34f0:	e037883a 	mov	sp,fp
 90a34f4:	dfc00117 	ldw	ra,4(sp)
 90a34f8:	df000017 	ldw	fp,0(sp)
 90a34fc:	dec00204 	addi	sp,sp,8
 90a3500:	f800283a 	ret

090a3504 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 90a3504:	defff204 	addi	sp,sp,-56
 90a3508:	dfc00d15 	stw	ra,52(sp)
 90a350c:	df000c15 	stw	fp,48(sp)
 90a3510:	df000c04 	addi	fp,sp,48
 90a3514:	e13ffc15 	stw	r4,-16(fp)
 90a3518:	e17ffd15 	stw	r5,-12(fp)
 90a351c:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 90a3520:	e0bffc17 	ldw	r2,-16(fp)
 90a3524:	10bff804 	addi	r2,r2,-32
 90a3528:	1085883a 	add	r2,r2,r2
 90a352c:	1085883a 	add	r2,r2,r2
 90a3530:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 90a3534:	008243b4 	movhi	r2,2318
 90a3538:	10b55b04 	addi	r2,r2,-10900
 90a353c:	e0bff415 	stw	r2,-48(fp)
 90a3540:	00000606 	br	90a355c <bsd_getsockname+0x58>
 90a3544:	e0fff417 	ldw	r3,-48(fp)
 90a3548:	e0bff617 	ldw	r2,-40(fp)
 90a354c:	18800626 	beq	r3,r2,90a3568 <bsd_getsockname+0x64>
 90a3550:	e0bff417 	ldw	r2,-48(fp)
 90a3554:	10800017 	ldw	r2,0(r2)
 90a3558:	e0bff415 	stw	r2,-48(fp)
 90a355c:	e0bff417 	ldw	r2,-48(fp)
 90a3560:	1004c03a 	cmpne	r2,r2,zero
 90a3564:	103ff71e 	bne	r2,zero,90a3544 <bsd_getsockname+0x40>
 90a3568:	e0fff417 	ldw	r3,-48(fp)
 90a356c:	e0bff617 	ldw	r2,-40(fp)
 90a3570:	18800426 	beq	r3,r2,90a3584 <bsd_getsockname+0x80>
 90a3574:	90a94880 	call	90a9488 <dtrap>
 90a3578:	00bfffc4 	movi	r2,-1
 90a357c:	e0bfff15 	stw	r2,-4(fp)
 90a3580:	00002506 	br	90a3618 <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 90a3584:	e0bffe17 	ldw	r2,-8(fp)
 90a3588:	1004c03a 	cmpne	r2,r2,zero
 90a358c:	1000061e 	bne	r2,zero,90a35a8 <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 90a3590:	e0fff617 	ldw	r3,-40(fp)
 90a3594:	00800384 	movi	r2,14
 90a3598:	18800615 	stw	r2,24(r3)
      return -1;
 90a359c:	00bfffc4 	movi	r2,-1
 90a35a0:	e0bfff15 	stw	r2,-4(fp)
 90a35a4:	00001c06 	br	90a3618 <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 90a35a8:	e0bffe17 	ldw	r2,-8(fp)
 90a35ac:	10800017 	ldw	r2,0(r2)
 90a35b0:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 90a35b4:	e17ff704 	addi	r5,fp,-36
 90a35b8:	e1bffb04 	addi	r6,fp,-20
 90a35bc:	e13ffc17 	ldw	r4,-16(fp)
 90a35c0:	90acdf80 	call	90acdf8 <t_getsockname>
 90a35c4:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 90a35c8:	e0bff517 	ldw	r2,-44(fp)
 90a35cc:	10bfffe0 	cmpeqi	r2,r2,-1
 90a35d0:	10000f1e 	bne	r2,zero,90a3610 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 90a35d4:	e0bffb17 	ldw	r2,-20(fp)
 90a35d8:	10800470 	cmpltui	r2,r2,17
 90a35dc:	1000021e 	bne	r2,zero,90a35e8 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 90a35e0:	00800404 	movi	r2,16
 90a35e4:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 90a35e8:	e0bffb17 	ldw	r2,-20(fp)
 90a35ec:	100d883a 	mov	r6,r2
 90a35f0:	e0bffd17 	ldw	r2,-12(fp)
 90a35f4:	e0fff704 	addi	r3,fp,-36
 90a35f8:	1009883a 	mov	r4,r2
 90a35fc:	180b883a 	mov	r5,r3
 90a3600:	90822780 	call	9082278 <memcpy>
      *namelen = lnamelen;
 90a3604:	e0fffb17 	ldw	r3,-20(fp)
 90a3608:	e0bffe17 	ldw	r2,-8(fp)
 90a360c:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a3610:	e0bff517 	ldw	r2,-44(fp)
 90a3614:	e0bfff15 	stw	r2,-4(fp)
 90a3618:	e0bfff17 	ldw	r2,-4(fp)
}
 90a361c:	e037883a 	mov	sp,fp
 90a3620:	dfc00117 	ldw	ra,4(sp)
 90a3624:	df000017 	ldw	fp,0(sp)
 90a3628:	dec00204 	addi	sp,sp,8
 90a362c:	f800283a 	ret

090a3630 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 90a3630:	defffb04 	addi	sp,sp,-20
 90a3634:	df000415 	stw	fp,16(sp)
 90a3638:	df000404 	addi	fp,sp,16
 90a363c:	e13ffc15 	stw	r4,-16(fp)
 90a3640:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 90a3644:	e0bffd17 	ldw	r2,-12(fp)
 90a3648:	e0bfff15 	stw	r2,-4(fp)
 90a364c:	e0ffff17 	ldw	r3,-4(fp)
 90a3650:	18802020 	cmpeqi	r2,r3,128
 90a3654:	1000491e 	bne	r2,zero,90a377c <bsd_i_sockoptlen+0x14c>
 90a3658:	e0ffff17 	ldw	r3,-4(fp)
 90a365c:	18802048 	cmpgei	r2,r3,129
 90a3660:	1000251e 	bne	r2,zero,90a36f8 <bsd_i_sockoptlen+0xc8>
 90a3664:	e0ffff17 	ldw	r3,-4(fp)
 90a3668:	18800308 	cmpgei	r2,r3,12
 90a366c:	1000141e 	bne	r2,zero,90a36c0 <bsd_i_sockoptlen+0x90>
 90a3670:	e0ffff17 	ldw	r3,-4(fp)
 90a3674:	18800288 	cmpgei	r2,r3,10
 90a3678:	10004c1e 	bne	r2,zero,90a37ac <bsd_i_sockoptlen+0x17c>
 90a367c:	e0ffff17 	ldw	r3,-4(fp)
 90a3680:	18800120 	cmpeqi	r2,r3,4
 90a3684:	1000431e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a3688:	e0ffff17 	ldw	r3,-4(fp)
 90a368c:	18800148 	cmpgei	r2,r3,5
 90a3690:	1000041e 	bne	r2,zero,90a36a4 <bsd_i_sockoptlen+0x74>
 90a3694:	e0ffff17 	ldw	r3,-4(fp)
 90a3698:	188000e0 	cmpeqi	r2,r3,3
 90a369c:	1000491e 	bne	r2,zero,90a37c4 <bsd_i_sockoptlen+0x194>
 90a36a0:	00004b06 	br	90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a36a4:	e0ffff17 	ldw	r3,-4(fp)
 90a36a8:	18800220 	cmpeqi	r2,r3,8
 90a36ac:	1000391e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a36b0:	e0ffff17 	ldw	r3,-4(fp)
 90a36b4:	18800260 	cmpeqi	r2,r3,9
 90a36b8:	1000391e 	bne	r2,zero,90a37a0 <bsd_i_sockoptlen+0x170>
 90a36bc:	00004406 	br	90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a36c0:	e0ffff17 	ldw	r3,-4(fp)
 90a36c4:	18800420 	cmpeqi	r2,r3,16
 90a36c8:	1000321e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a36cc:	e0ffff17 	ldw	r3,-4(fp)
 90a36d0:	18800448 	cmpgei	r2,r3,17
 90a36d4:	1000041e 	bne	r2,zero,90a36e8 <bsd_i_sockoptlen+0xb8>
 90a36d8:	e0ffff17 	ldw	r3,-4(fp)
 90a36dc:	18800388 	cmpgei	r2,r3,14
 90a36e0:	10003b1e 	bne	r2,zero,90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a36e4:	00003406 	br	90a37b8 <bsd_i_sockoptlen+0x188>
 90a36e8:	e0ffff17 	ldw	r3,-4(fp)
 90a36ec:	18800820 	cmpeqi	r2,r3,32
 90a36f0:	1000281e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a36f4:	00003606 	br	90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a36f8:	e0ffff17 	ldw	r3,-4(fp)
 90a36fc:	188401c8 	cmpgei	r2,r3,4103
 90a3700:	10000e1e 	bne	r2,zero,90a373c <bsd_i_sockoptlen+0x10c>
 90a3704:	e0ffff17 	ldw	r3,-4(fp)
 90a3708:	18840148 	cmpgei	r2,r3,4101
 90a370c:	10001e1e 	bne	r2,zero,90a3788 <bsd_i_sockoptlen+0x158>
 90a3710:	e0ffff17 	ldw	r3,-4(fp)
 90a3714:	18804020 	cmpeqi	r2,r3,256
 90a3718:	10001e1e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a371c:	e0ffff17 	ldw	r3,-4(fp)
 90a3720:	18804010 	cmplti	r2,r3,256
 90a3724:	10002a1e 	bne	r2,zero,90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a3728:	e0ffff17 	ldw	r3,-4(fp)
 90a372c:	18bbffc4 	addi	r2,r3,-4097
 90a3730:	108000a8 	cmpgeui	r2,r2,2
 90a3734:	1000261e 	bne	r2,zero,90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a3738:	00001606 	br	90a3794 <bsd_i_sockoptlen+0x164>
 90a373c:	e0ffff17 	ldw	r3,-4(fp)
 90a3740:	18840588 	cmpgei	r2,r3,4118
 90a3744:	1000071e 	bne	r2,zero,90a3764 <bsd_i_sockoptlen+0x134>
 90a3748:	e0ffff17 	ldw	r3,-4(fp)
 90a374c:	18840508 	cmpgei	r2,r3,4116
 90a3750:	1000081e 	bne	r2,zero,90a3774 <bsd_i_sockoptlen+0x144>
 90a3754:	e0ffff17 	ldw	r3,-4(fp)
 90a3758:	18840248 	cmpgei	r2,r3,4105
 90a375c:	10001c1e 	bne	r2,zero,90a37d0 <bsd_i_sockoptlen+0x1a0>
 90a3760:	00000c06 	br	90a3794 <bsd_i_sockoptlen+0x164>
 90a3764:	e0ffff17 	ldw	r3,-4(fp)
 90a3768:	188405a0 	cmpeqi	r2,r3,4118
 90a376c:	1000091e 	bne	r2,zero,90a3794 <bsd_i_sockoptlen+0x164>
 90a3770:	00001706 	br	90a37d0 <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 90a3774:	e03ffe15 	stw	zero,-8(fp)
 90a3778:	00001606 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 90a377c:	00800204 	movi	r2,8
 90a3780:	e0bffe15 	stw	r2,-8(fp)
 90a3784:	00001306 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 90a3788:	00c00084 	movi	r3,2
 90a378c:	e0fffe15 	stw	r3,-8(fp)
 90a3790:	00001006 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 90a3794:	00800104 	movi	r2,4
 90a3798:	e0bffe15 	stw	r2,-8(fp)
 90a379c:	00000d06 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 90a37a0:	00c00104 	movi	r3,4
 90a37a4:	e0fffe15 	stw	r3,-8(fp)
 90a37a8:	00000a06 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 90a37ac:	00800044 	movi	r2,1
 90a37b0:	e0bffe15 	stw	r2,-8(fp)
 90a37b4:	00000706 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 90a37b8:	00c00204 	movi	r3,8
 90a37bc:	e0fffe15 	stw	r3,-8(fp)
 90a37c0:	00000406 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 90a37c4:	00800104 	movi	r2,4
 90a37c8:	e0bffe15 	stw	r2,-8(fp)
 90a37cc:	00000106 	br	90a37d4 <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 90a37d0:	e03ffe15 	stw	zero,-8(fp)
 90a37d4:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 90a37d8:	e037883a 	mov	sp,fp
 90a37dc:	df000017 	ldw	fp,0(sp)
 90a37e0:	dec00104 	addi	sp,sp,4
 90a37e4:	f800283a 	ret

090a37e8 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 90a37e8:	defff404 	addi	sp,sp,-48
 90a37ec:	dfc00b15 	stw	ra,44(sp)
 90a37f0:	df000a15 	stw	fp,40(sp)
 90a37f4:	df000a04 	addi	fp,sp,40
 90a37f8:	e13ffb15 	stw	r4,-20(fp)
 90a37fc:	e17ffc15 	stw	r5,-16(fp)
 90a3800:	e1bffd15 	stw	r6,-12(fp)
 90a3804:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 90a3808:	e0bffb17 	ldw	r2,-20(fp)
 90a380c:	10bff804 	addi	r2,r2,-32
 90a3810:	1085883a 	add	r2,r2,r2
 90a3814:	1085883a 	add	r2,r2,r2
 90a3818:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a381c:	008243b4 	movhi	r2,2318
 90a3820:	10b55b04 	addi	r2,r2,-10900
 90a3824:	e0bff715 	stw	r2,-36(fp)
 90a3828:	00000606 	br	90a3844 <bsd_getsockopt+0x5c>
 90a382c:	e0fff717 	ldw	r3,-36(fp)
 90a3830:	e0bffa17 	ldw	r2,-24(fp)
 90a3834:	18800626 	beq	r3,r2,90a3850 <bsd_getsockopt+0x68>
 90a3838:	e0bff717 	ldw	r2,-36(fp)
 90a383c:	10800017 	ldw	r2,0(r2)
 90a3840:	e0bff715 	stw	r2,-36(fp)
 90a3844:	e0bff717 	ldw	r2,-36(fp)
 90a3848:	1004c03a 	cmpne	r2,r2,zero
 90a384c:	103ff71e 	bne	r2,zero,90a382c <bsd_getsockopt+0x44>
 90a3850:	e0fff717 	ldw	r3,-36(fp)
 90a3854:	e0bffa17 	ldw	r2,-24(fp)
 90a3858:	18800426 	beq	r3,r2,90a386c <bsd_getsockopt+0x84>
 90a385c:	90a94880 	call	90a9488 <dtrap>
 90a3860:	00bfffc4 	movi	r2,-1
 90a3864:	e0bfff15 	stw	r2,-4(fp)
 90a3868:	00002106 	br	90a38f0 <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 90a386c:	e13ffc17 	ldw	r4,-16(fp)
 90a3870:	e17ffd17 	ldw	r5,-12(fp)
 90a3874:	90a36300 	call	90a3630 <bsd_i_sockoptlen>
 90a3878:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 90a387c:	e0800217 	ldw	r2,8(fp)
 90a3880:	1005003a 	cmpeq	r2,r2,zero
 90a3884:	1000041e 	bne	r2,zero,90a3898 <bsd_getsockopt+0xb0>
 90a3888:	e0800217 	ldw	r2,8(fp)
 90a388c:	10c00017 	ldw	r3,0(r2)
 90a3890:	e0bff917 	ldw	r2,-28(fp)
 90a3894:	1880060e 	bge	r3,r2,90a38b0 <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 90a3898:	e0fffa17 	ldw	r3,-24(fp)
 90a389c:	00800384 	movi	r2,14
 90a38a0:	18800615 	stw	r2,24(r3)
      return -1;
 90a38a4:	00bfffc4 	movi	r2,-1
 90a38a8:	e0bfff15 	stw	r2,-4(fp)
 90a38ac:	00001006 	br	90a38f0 <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 90a38b0:	e0bff917 	ldw	r2,-28(fp)
 90a38b4:	d8800015 	stw	r2,0(sp)
 90a38b8:	e13ffb17 	ldw	r4,-20(fp)
 90a38bc:	e17ffc17 	ldw	r5,-16(fp)
 90a38c0:	e1bffd17 	ldw	r6,-12(fp)
 90a38c4:	e1fffe17 	ldw	r7,-8(fp)
 90a38c8:	90ad2140 	call	90ad214 <t_getsockopt>
 90a38cc:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 90a38d0:	e0bff817 	ldw	r2,-32(fp)
 90a38d4:	1004c03a 	cmpne	r2,r2,zero
 90a38d8:	1000031e 	bne	r2,zero,90a38e8 <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 90a38dc:	e0c00217 	ldw	r3,8(fp)
 90a38e0:	e0bff917 	ldw	r2,-28(fp)
 90a38e4:	18800015 	stw	r2,0(r3)
   }

   return e;
 90a38e8:	e0bff817 	ldw	r2,-32(fp)
 90a38ec:	e0bfff15 	stw	r2,-4(fp)
 90a38f0:	e0bfff17 	ldw	r2,-4(fp)
   
}
 90a38f4:	e037883a 	mov	sp,fp
 90a38f8:	dfc00117 	ldw	ra,4(sp)
 90a38fc:	df000017 	ldw	fp,0(sp)
 90a3900:	dec00204 	addi	sp,sp,8
 90a3904:	f800283a 	ret

090a3908 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 90a3908:	defff404 	addi	sp,sp,-48
 90a390c:	dfc00915 	stw	ra,36(sp)
 90a3910:	df000815 	stw	fp,32(sp)
 90a3914:	df000804 	addi	fp,sp,32
 90a3918:	e13ffd15 	stw	r4,-12(fp)
 90a391c:	e1800215 	stw	r6,8(fp)
 90a3920:	e1c00315 	stw	r7,12(fp)
 90a3924:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 90a3928:	e0bffd17 	ldw	r2,-12(fp)
 90a392c:	10bff804 	addi	r2,r2,-32
 90a3930:	1085883a 	add	r2,r2,r2
 90a3934:	1085883a 	add	r2,r2,r2
 90a3938:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a393c:	008243b4 	movhi	r2,2318
 90a3940:	10b55b04 	addi	r2,r2,-10900
 90a3944:	e0bff915 	stw	r2,-28(fp)
 90a3948:	00000606 	br	90a3964 <bsd_ioctl+0x5c>
 90a394c:	e0fff917 	ldw	r3,-28(fp)
 90a3950:	e0bffa17 	ldw	r2,-24(fp)
 90a3954:	18800626 	beq	r3,r2,90a3970 <bsd_ioctl+0x68>
 90a3958:	e0bff917 	ldw	r2,-28(fp)
 90a395c:	10800017 	ldw	r2,0(r2)
 90a3960:	e0bff915 	stw	r2,-28(fp)
 90a3964:	e0bff917 	ldw	r2,-28(fp)
 90a3968:	1004c03a 	cmpne	r2,r2,zero
 90a396c:	103ff71e 	bne	r2,zero,90a394c <bsd_ioctl+0x44>
 90a3970:	e0fff917 	ldw	r3,-28(fp)
 90a3974:	e0bffa17 	ldw	r2,-24(fp)
 90a3978:	18800426 	beq	r3,r2,90a398c <bsd_ioctl+0x84>
 90a397c:	90a94880 	call	90a9488 <dtrap>
 90a3980:	00bfffc4 	movi	r2,-1
 90a3984:	e0bfff15 	stw	r2,-4(fp)
 90a3988:	00001a06 	br	90a39f4 <bsd_ioctl+0xec>

   va_start(argptr, request);
 90a398c:	e0800204 	addi	r2,fp,8
 90a3990:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 90a3994:	e0bffe17 	ldw	r2,-8(fp)
 90a3998:	108405a0 	cmpeqi	r2,r2,4118
 90a399c:	1000011e 	bne	r2,zero,90a39a4 <bsd_ioctl+0x9c>
 90a39a0:	00000f06 	br	90a39e0 <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 90a39a4:	e0fffb17 	ldw	r3,-20(fp)
 90a39a8:	18800104 	addi	r2,r3,4
 90a39ac:	e0bffb15 	stw	r2,-20(fp)
 90a39b0:	1805883a 	mov	r2,r3
 90a39b4:	10800017 	ldw	r2,0(r2)
 90a39b8:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 90a39bc:	e1fffc04 	addi	r7,fp,-16
 90a39c0:	00800104 	movi	r2,4
 90a39c4:	d8800015 	stw	r2,0(sp)
 90a39c8:	e13ffd17 	ldw	r4,-12(fp)
 90a39cc:	017fffc4 	movi	r5,-1
 90a39d0:	01840584 	movi	r6,4118
 90a39d4:	90ad0380 	call	90ad038 <t_setsockopt>
 90a39d8:	e0bfff15 	stw	r2,-4(fp)
 90a39dc:	00000506 	br	90a39f4 <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 90a39e0:	e0fffa17 	ldw	r3,-24(fp)
 90a39e4:	00800584 	movi	r2,22
 90a39e8:	18800615 	stw	r2,24(r3)
      return -1;
 90a39ec:	00bfffc4 	movi	r2,-1
 90a39f0:	e0bfff15 	stw	r2,-4(fp)
 90a39f4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a39f8:	e037883a 	mov	sp,fp
 90a39fc:	dfc00117 	ldw	ra,4(sp)
 90a3a00:	df000017 	ldw	fp,0(sp)
 90a3a04:	dec00404 	addi	sp,sp,16
 90a3a08:	f800283a 	ret

090a3a0c <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 90a3a0c:	defffd04 	addi	sp,sp,-12
 90a3a10:	dfc00215 	stw	ra,8(sp)
 90a3a14:	df000115 	stw	fp,4(sp)
 90a3a18:	df000104 	addi	fp,sp,4
 90a3a1c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 90a3a20:	e13fff17 	ldw	r4,-4(fp)
 90a3a24:	90a415c0 	call	90a415c <print_ipad>
}
 90a3a28:	e037883a 	mov	sp,fp
 90a3a2c:	dfc00117 	ldw	ra,4(sp)
 90a3a30:	df000017 	ldw	fp,0(sp)
 90a3a34:	dec00204 	addi	sp,sp,8
 90a3a38:	f800283a 	ret

090a3a3c <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 90a3a3c:	deffef04 	addi	sp,sp,-68
 90a3a40:	dfc01015 	stw	ra,64(sp)
 90a3a44:	df000f15 	stw	fp,60(sp)
 90a3a48:	df000f04 	addi	fp,sp,60
 90a3a4c:	e13ffb15 	stw	r4,-20(fp)
 90a3a50:	e17ffc15 	stw	r5,-16(fp)
 90a3a54:	e1bffd15 	stw	r6,-12(fp)
 90a3a58:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 90a3a5c:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 90a3a60:	e0bffb17 	ldw	r2,-20(fp)
 90a3a64:	10bff804 	addi	r2,r2,-32
 90a3a68:	1085883a 	add	r2,r2,r2
 90a3a6c:	1085883a 	add	r2,r2,r2
 90a3a70:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 90a3a74:	008243b4 	movhi	r2,2318
 90a3a78:	10b55b04 	addi	r2,r2,-10900
 90a3a7c:	e0bff315 	stw	r2,-52(fp)
 90a3a80:	00000606 	br	90a3a9c <bsd_recvfrom+0x60>
 90a3a84:	e0fff317 	ldw	r3,-52(fp)
 90a3a88:	e0bff517 	ldw	r2,-44(fp)
 90a3a8c:	18800626 	beq	r3,r2,90a3aa8 <bsd_recvfrom+0x6c>
 90a3a90:	e0bff317 	ldw	r2,-52(fp)
 90a3a94:	10800017 	ldw	r2,0(r2)
 90a3a98:	e0bff315 	stw	r2,-52(fp)
 90a3a9c:	e0bff317 	ldw	r2,-52(fp)
 90a3aa0:	1004c03a 	cmpne	r2,r2,zero
 90a3aa4:	103ff71e 	bne	r2,zero,90a3a84 <bsd_recvfrom+0x48>
 90a3aa8:	e0fff317 	ldw	r3,-52(fp)
 90a3aac:	e0bff517 	ldw	r2,-44(fp)
 90a3ab0:	18800426 	beq	r3,r2,90a3ac4 <bsd_recvfrom+0x88>
 90a3ab4:	90a94880 	call	90a9488 <dtrap>
 90a3ab8:	00bfffc4 	movi	r2,-1
 90a3abc:	e0bfff15 	stw	r2,-4(fp)
 90a3ac0:	00003006 	br	90a3b84 <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 90a3ac4:	e0800217 	ldw	r2,8(fp)
 90a3ac8:	1005003a 	cmpeq	r2,r2,zero
 90a3acc:	10000c1e 	bne	r2,zero,90a3b00 <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 90a3ad0:	e0800317 	ldw	r2,12(fp)
 90a3ad4:	1004c03a 	cmpne	r2,r2,zero
 90a3ad8:	1000061e 	bne	r2,zero,90a3af4 <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 90a3adc:	e0fff517 	ldw	r3,-44(fp)
 90a3ae0:	00800384 	movi	r2,14
 90a3ae4:	18800615 	stw	r2,24(r3)
         return -1;
 90a3ae8:	00bfffc4 	movi	r2,-1
 90a3aec:	e0bfff15 	stw	r2,-4(fp)
 90a3af0:	00002406 	br	90a3b84 <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 90a3af4:	e0800317 	ldw	r2,12(fp)
 90a3af8:	10800017 	ldw	r2,0(r2)
 90a3afc:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 90a3b00:	e17ffc17 	ldw	r5,-16(fp)
 90a3b04:	e0bff604 	addi	r2,fp,-40
 90a3b08:	d8800015 	stw	r2,0(sp)
 90a3b0c:	e0bffa04 	addi	r2,fp,-24
 90a3b10:	d8800115 	stw	r2,4(sp)
 90a3b14:	e13ffb17 	ldw	r4,-20(fp)
 90a3b18:	e1bffd17 	ldw	r6,-12(fp)
 90a3b1c:	e1fffe17 	ldw	r7,-8(fp)
 90a3b20:	90ad4a80 	call	90ad4a8 <t_recvfrom>
 90a3b24:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 90a3b28:	e0bff417 	ldw	r2,-48(fp)
 90a3b2c:	10bfffe0 	cmpeqi	r2,r2,-1
 90a3b30:	1000121e 	bne	r2,zero,90a3b7c <bsd_recvfrom+0x140>
 90a3b34:	e0800217 	ldw	r2,8(fp)
 90a3b38:	1005003a 	cmpeq	r2,r2,zero
 90a3b3c:	10000f1e 	bne	r2,zero,90a3b7c <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 90a3b40:	e0bffa17 	ldw	r2,-24(fp)
 90a3b44:	10800470 	cmpltui	r2,r2,17
 90a3b48:	1000021e 	bne	r2,zero,90a3b54 <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 90a3b4c:	00800404 	movi	r2,16
 90a3b50:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 90a3b54:	e0bffa17 	ldw	r2,-24(fp)
 90a3b58:	100d883a 	mov	r6,r2
 90a3b5c:	e0800217 	ldw	r2,8(fp)
 90a3b60:	e0fff604 	addi	r3,fp,-40
 90a3b64:	1009883a 	mov	r4,r2
 90a3b68:	180b883a 	mov	r5,r3
 90a3b6c:	90822780 	call	9082278 <memcpy>
      *fromlen = lfromlen;
 90a3b70:	e0fffa17 	ldw	r3,-24(fp)
 90a3b74:	e0800317 	ldw	r2,12(fp)
 90a3b78:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a3b7c:	e0bff417 	ldw	r2,-48(fp)
 90a3b80:	e0bfff15 	stw	r2,-4(fp)
 90a3b84:	e0bfff17 	ldw	r2,-4(fp)
}
 90a3b88:	e037883a 	mov	sp,fp
 90a3b8c:	dfc00117 	ldw	ra,4(sp)
 90a3b90:	df000017 	ldw	fp,0(sp)
 90a3b94:	dec00204 	addi	sp,sp,8
 90a3b98:	f800283a 	ret

090a3b9c <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 90a3b9c:	defff604 	addi	sp,sp,-40
 90a3ba0:	dfc00915 	stw	ra,36(sp)
 90a3ba4:	df000815 	stw	fp,32(sp)
 90a3ba8:	dc400715 	stw	r17,28(sp)
 90a3bac:	dc000615 	stw	r16,24(sp)
 90a3bb0:	df000604 	addi	fp,sp,24
 90a3bb4:	e13ffc15 	stw	r4,-16(fp)
 90a3bb8:	e17ffd15 	stw	r5,-12(fp)
 90a3bbc:	e1bffe15 	stw	r6,-8(fp)
 90a3bc0:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 90a3bc4:	e0800417 	ldw	r2,16(fp)
 90a3bc8:	1005003a 	cmpeq	r2,r2,zero
 90a3bcc:	1000581e 	bne	r2,zero,90a3d30 <bsd_select+0x194>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 90a3bd0:	00801904 	movi	r2,100
 90a3bd4:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 90a3bd8:	e0bffa17 	ldw	r2,-24(fp)
 90a3bdc:	1080fa10 	cmplti	r2,r2,1000
 90a3be0:	10000b1e 	bne	r2,zero,90a3c10 <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 90a3be4:	e0800417 	ldw	r2,16(fp)
 90a3be8:	10800117 	ldw	r2,4(r2)
 90a3bec:	10c00c84 	addi	r3,r2,50
 90a3bf0:	00801904 	movi	r2,100
 90a3bf4:	1887283a 	div	r3,r3,r2
 90a3bf8:	e0bffa17 	ldw	r2,-24(fp)
 90a3bfc:	1887383a 	mul	r3,r3,r2
 90a3c00:	0089c404 	movi	r2,10000
 90a3c04:	1885283a 	div	r2,r3,r2
 90a3c08:	e0bffb15 	stw	r2,-20(fp)
 90a3c0c:	00002806 	br	90a3cb0 <bsd_select+0x114>
      }
      else if (tps >= 100)
 90a3c10:	e0bffa17 	ldw	r2,-24(fp)
 90a3c14:	10801910 	cmplti	r2,r2,100
 90a3c18:	10000b1e 	bne	r2,zero,90a3c48 <bsd_select+0xac>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 90a3c1c:	e0800417 	ldw	r2,16(fp)
 90a3c20:	10800117 	ldw	r2,4(r2)
 90a3c24:	10c07d04 	addi	r3,r2,500
 90a3c28:	0080fa04 	movi	r2,1000
 90a3c2c:	1887283a 	div	r3,r3,r2
 90a3c30:	e0bffa17 	ldw	r2,-24(fp)
 90a3c34:	1887383a 	mul	r3,r3,r2
 90a3c38:	0080fa04 	movi	r2,1000
 90a3c3c:	1885283a 	div	r2,r3,r2
 90a3c40:	e0bffb15 	stw	r2,-20(fp)
 90a3c44:	00001a06 	br	90a3cb0 <bsd_select+0x114>
      }
      else if (tps >= 10)
 90a3c48:	e0bffa17 	ldw	r2,-24(fp)
 90a3c4c:	10800290 	cmplti	r2,r2,10
 90a3c50:	10000b1e 	bne	r2,zero,90a3c80 <bsd_select+0xe4>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 90a3c54:	e0800417 	ldw	r2,16(fp)
 90a3c58:	10800117 	ldw	r2,4(r2)
 90a3c5c:	10c4e204 	addi	r3,r2,5000
 90a3c60:	0089c404 	movi	r2,10000
 90a3c64:	1887283a 	div	r3,r3,r2
 90a3c68:	e0bffa17 	ldw	r2,-24(fp)
 90a3c6c:	1887383a 	mul	r3,r3,r2
 90a3c70:	00801904 	movi	r2,100
 90a3c74:	1885283a 	div	r2,r3,r2
 90a3c78:	e0bffb15 	stw	r2,-20(fp)
 90a3c7c:	00000c06 	br	90a3cb0 <bsd_select+0x114>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 90a3c80:	e0800417 	ldw	r2,16(fp)
 90a3c84:	10c00117 	ldw	r3,4(r2)
 90a3c88:	00b0d414 	movui	r2,50000
 90a3c8c:	1887883a 	add	r3,r3,r2
 90a3c90:	008000b4 	movhi	r2,2
 90a3c94:	10a1a804 	addi	r2,r2,-31072
 90a3c98:	1887283a 	div	r3,r3,r2
 90a3c9c:	e0bffa17 	ldw	r2,-24(fp)
 90a3ca0:	1887383a 	mul	r3,r3,r2
 90a3ca4:	00800284 	movi	r2,10
 90a3ca8:	1885283a 	div	r2,r3,r2
 90a3cac:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 90a3cb0:	e13ffb17 	ldw	r4,-20(fp)
 90a3cb4:	908be680 	call	908be68 <__floatsidf>
 90a3cb8:	1021883a 	mov	r16,r2
 90a3cbc:	1823883a 	mov	r17,r3
 90a3cc0:	e0800417 	ldw	r2,16(fp)
 90a3cc4:	11000017 	ldw	r4,0(r2)
 90a3cc8:	908be680 	call	908be68 <__floatsidf>
 90a3ccc:	100b883a 	mov	r5,r2
 90a3cd0:	180d883a 	mov	r6,r3
 90a3cd4:	2809883a 	mov	r4,r5
 90a3cd8:	300b883a 	mov	r5,r6
 90a3cdc:	000d883a 	mov	r6,zero
 90a3ce0:	01d01674 	movhi	r7,16473
 90a3ce4:	908b5b40 	call	908b5b4 <__muldf3>
 90a3ce8:	1009883a 	mov	r4,r2
 90a3cec:	180b883a 	mov	r5,r3
 90a3cf0:	2005883a 	mov	r2,r4
 90a3cf4:	2807883a 	mov	r3,r5
 90a3cf8:	8009883a 	mov	r4,r16
 90a3cfc:	880b883a 	mov	r5,r17
 90a3d00:	100d883a 	mov	r6,r2
 90a3d04:	180f883a 	mov	r7,r3
 90a3d08:	908b5400 	call	908b540 <__adddf3>
 90a3d0c:	1009883a 	mov	r4,r2
 90a3d10:	180b883a 	mov	r5,r3
 90a3d14:	2005883a 	mov	r2,r4
 90a3d18:	2807883a 	mov	r3,r5
 90a3d1c:	1009883a 	mov	r4,r2
 90a3d20:	180b883a 	mov	r5,r3
 90a3d24:	908bf600 	call	908bf60 <__fixdfsi>
 90a3d28:	e0bffb15 	stw	r2,-20(fp)
 90a3d2c:	00000206 	br	90a3d38 <bsd_select+0x19c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 90a3d30:	00bfffc4 	movi	r2,-1
 90a3d34:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 90a3d38:	e13ffd17 	ldw	r4,-12(fp)
 90a3d3c:	e17ffe17 	ldw	r5,-8(fp)
 90a3d40:	e1bfff17 	ldw	r6,-4(fp)
 90a3d44:	e1fffb17 	ldw	r7,-20(fp)
 90a3d48:	90b14340 	call	90b1434 <t_select>
}
 90a3d4c:	e037883a 	mov	sp,fp
 90a3d50:	dfc00317 	ldw	ra,12(sp)
 90a3d54:	df000217 	ldw	fp,8(sp)
 90a3d58:	dc400117 	ldw	r17,4(sp)
 90a3d5c:	dc000017 	ldw	r16,0(sp)
 90a3d60:	dec00404 	addi	sp,sp,16
 90a3d64:	f800283a 	ret

090a3d68 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 90a3d68:	defff604 	addi	sp,sp,-40
 90a3d6c:	dfc00915 	stw	ra,36(sp)
 90a3d70:	df000815 	stw	fp,32(sp)
 90a3d74:	df000804 	addi	fp,sp,32
 90a3d78:	e13ffb15 	stw	r4,-20(fp)
 90a3d7c:	e17ffc15 	stw	r5,-16(fp)
 90a3d80:	e1bffd15 	stw	r6,-12(fp)
 90a3d84:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 90a3d88:	e0bffb17 	ldw	r2,-20(fp)
 90a3d8c:	10bff804 	addi	r2,r2,-32
 90a3d90:	1085883a 	add	r2,r2,r2
 90a3d94:	1085883a 	add	r2,r2,r2
 90a3d98:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a3d9c:	008243b4 	movhi	r2,2318
 90a3da0:	10b55b04 	addi	r2,r2,-10900
 90a3da4:	e0bff915 	stw	r2,-28(fp)
 90a3da8:	00000606 	br	90a3dc4 <bsd_setsockopt+0x5c>
 90a3dac:	e0fff917 	ldw	r3,-28(fp)
 90a3db0:	e0bffa17 	ldw	r2,-24(fp)
 90a3db4:	18800626 	beq	r3,r2,90a3dd0 <bsd_setsockopt+0x68>
 90a3db8:	e0bff917 	ldw	r2,-28(fp)
 90a3dbc:	10800017 	ldw	r2,0(r2)
 90a3dc0:	e0bff915 	stw	r2,-28(fp)
 90a3dc4:	e0bff917 	ldw	r2,-28(fp)
 90a3dc8:	1004c03a 	cmpne	r2,r2,zero
 90a3dcc:	103ff71e 	bne	r2,zero,90a3dac <bsd_setsockopt+0x44>
 90a3dd0:	e0fff917 	ldw	r3,-28(fp)
 90a3dd4:	e0bffa17 	ldw	r2,-24(fp)
 90a3dd8:	18800426 	beq	r3,r2,90a3dec <bsd_setsockopt+0x84>
 90a3ddc:	90a94880 	call	90a9488 <dtrap>
 90a3de0:	00bfffc4 	movi	r2,-1
 90a3de4:	e0bfff15 	stw	r2,-4(fp)
 90a3de8:	00001406 	br	90a3e3c <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 90a3dec:	e13ffc17 	ldw	r4,-16(fp)
 90a3df0:	e17ffd17 	ldw	r5,-12(fp)
 90a3df4:	90a36300 	call	90a3630 <bsd_i_sockoptlen>
 90a3df8:	1007883a 	mov	r3,r2
 90a3dfc:	e0800217 	ldw	r2,8(fp)
 90a3e00:	10c0060e 	bge	r2,r3,90a3e1c <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 90a3e04:	e0fffa17 	ldw	r3,-24(fp)
 90a3e08:	00800384 	movi	r2,14
 90a3e0c:	18800615 	stw	r2,24(r3)
      return -1;
 90a3e10:	00bfffc4 	movi	r2,-1
 90a3e14:	e0bfff15 	stw	r2,-4(fp)
 90a3e18:	00000806 	br	90a3e3c <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 90a3e1c:	e0800217 	ldw	r2,8(fp)
 90a3e20:	d8800015 	stw	r2,0(sp)
 90a3e24:	e13ffb17 	ldw	r4,-20(fp)
 90a3e28:	e17ffc17 	ldw	r5,-16(fp)
 90a3e2c:	e1bffd17 	ldw	r6,-12(fp)
 90a3e30:	e1fffe17 	ldw	r7,-8(fp)
 90a3e34:	90ad0380 	call	90ad038 <t_setsockopt>
 90a3e38:	e0bfff15 	stw	r2,-4(fp)
 90a3e3c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a3e40:	e037883a 	mov	sp,fp
 90a3e44:	dfc00117 	ldw	ra,4(sp)
 90a3e48:	df000017 	ldw	fp,0(sp)
 90a3e4c:	dec00204 	addi	sp,sp,8
 90a3e50:	f800283a 	ret

090a3e54 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 90a3e54:	defffa04 	addi	sp,sp,-24
 90a3e58:	df000515 	stw	fp,20(sp)
 90a3e5c:	df000504 	addi	fp,sp,20
 90a3e60:	e13ffe15 	stw	r4,-8(fp)
 90a3e64:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 90a3e68:	e0bffe17 	ldw	r2,-8(fp)
 90a3e6c:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 90a3e70:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 90a3e74:	e0bfff17 	ldw	r2,-4(fp)
 90a3e78:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 90a3e7c:	00000906 	br	90a3ea4 <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 90a3e80:	e0bffd17 	ldw	r2,-12(fp)
 90a3e84:	1080000b 	ldhu	r2,0(r2)
 90a3e88:	10ffffcc 	andi	r3,r2,65535
 90a3e8c:	e0bffc17 	ldw	r2,-16(fp)
 90a3e90:	10c5883a 	add	r2,r2,r3
 90a3e94:	e0bffc15 	stw	r2,-16(fp)
 90a3e98:	e0bffd17 	ldw	r2,-12(fp)
 90a3e9c:	10800084 	addi	r2,r2,2
 90a3ea0:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 90a3ea4:	e0bffb17 	ldw	r2,-20(fp)
 90a3ea8:	10bfffc4 	addi	r2,r2,-1
 90a3eac:	e0bffb15 	stw	r2,-20(fp)
 90a3eb0:	e0bffb17 	ldw	r2,-20(fp)
 90a3eb4:	1004403a 	cmpge	r2,r2,zero
 90a3eb8:	103ff11e 	bne	r2,zero,90a3e80 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 90a3ebc:	e0bffc17 	ldw	r2,-16(fp)
 90a3ec0:	10ffffcc 	andi	r3,r2,65535
 90a3ec4:	e0bffc17 	ldw	r2,-16(fp)
 90a3ec8:	1004d43a 	srli	r2,r2,16
 90a3ecc:	1885883a 	add	r2,r3,r2
 90a3ed0:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 90a3ed4:	e0bffc17 	ldw	r2,-16(fp)
 90a3ed8:	10ffffcc 	andi	r3,r2,65535
 90a3edc:	e0bffc17 	ldw	r2,-16(fp)
 90a3ee0:	1004d43a 	srli	r2,r2,16
 90a3ee4:	1885883a 	add	r2,r3,r2
 90a3ee8:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 90a3eec:	e0bffc17 	ldw	r2,-16(fp)
 90a3ef0:	10bfffcc 	andi	r2,r2,65535
}
 90a3ef4:	e037883a 	mov	sp,fp
 90a3ef8:	df000017 	ldw	fp,0(sp)
 90a3efc:	dec00104 	addi	sp,sp,4
 90a3f00:	f800283a 	ret

090a3f04 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 90a3f04:	defffb04 	addi	sp,sp,-20
 90a3f08:	dfc00415 	stw	ra,16(sp)
 90a3f0c:	df000315 	stw	fp,12(sp)
 90a3f10:	df000304 	addi	fp,sp,12
 90a3f14:	e13ffd15 	stw	r4,-12(fp)
 90a3f18:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 90a3f1c:	d0a02f17 	ldw	r2,-32580(gp)
 90a3f20:	108000a0 	cmpeqi	r2,r2,2
 90a3f24:	1000061e 	bne	r2,zero,90a3f40 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 90a3f28:	e13ffd17 	ldw	r4,-12(fp)
 90a3f2c:	e17ffe17 	ldw	r5,-8(fp)
 90a3f30:	90a3e540 	call	90a3e54 <ccksum>
 90a3f34:	10bfffcc 	andi	r2,r2,65535
 90a3f38:	e0bfff15 	stw	r2,-4(fp)
 90a3f3c:	00000506 	br	90a3f54 <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 90a3f40:	e13ffd17 	ldw	r4,-12(fp)
 90a3f44:	e17ffe17 	ldw	r5,-8(fp)
 90a3f48:	90a92f40 	call	90a92f4 <asm_cksum>
 90a3f4c:	10bfffcc 	andi	r2,r2,65535
 90a3f50:	e0bfff15 	stw	r2,-4(fp)
 90a3f54:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 90a3f58:	e037883a 	mov	sp,fp
 90a3f5c:	dfc00117 	ldw	ra,4(sp)
 90a3f60:	df000017 	ldw	fp,0(sp)
 90a3f64:	dec00204 	addi	sp,sp,8
 90a3f68:	f800283a 	ret

090a3f6c <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 90a3f6c:	defffe04 	addi	sp,sp,-8
 90a3f70:	dfc00115 	stw	ra,4(sp)
 90a3f74:	df000015 	stw	fp,0(sp)
 90a3f78:	d839883a 	mov	fp,sp
   dtrap();
 90a3f7c:	90a94880 	call	90a9488 <dtrap>
   return 0;
 90a3f80:	0005883a 	mov	r2,zero
}
 90a3f84:	e037883a 	mov	sp,fp
 90a3f88:	dfc00117 	ldw	ra,4(sp)
 90a3f8c:	df000017 	ldw	fp,0(sp)
 90a3f90:	dec00204 	addi	sp,sp,8
 90a3f94:	f800283a 	ret

090a3f98 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 90a3f98:	defffe04 	addi	sp,sp,-8
 90a3f9c:	df000115 	stw	fp,4(sp)
 90a3fa0:	df000104 	addi	fp,sp,4
 90a3fa4:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 90a3fa8:	00000306 	br	90a3fb8 <nextarg+0x20>
 90a3fac:	e0bfff17 	ldw	r2,-4(fp)
 90a3fb0:	10800044 	addi	r2,r2,1
 90a3fb4:	e0bfff15 	stw	r2,-4(fp)
 90a3fb8:	e0bfff17 	ldw	r2,-4(fp)
 90a3fbc:	10800003 	ldbu	r2,0(r2)
 90a3fc0:	10803fcc 	andi	r2,r2,255
 90a3fc4:	1080201c 	xori	r2,r2,128
 90a3fc8:	10bfe004 	addi	r2,r2,-128
 90a3fcc:	10800848 	cmpgei	r2,r2,33
 90a3fd0:	103ff61e 	bne	r2,zero,90a3fac <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 90a3fd4:	00000306 	br	90a3fe4 <nextarg+0x4c>
 90a3fd8:	e0bfff17 	ldw	r2,-4(fp)
 90a3fdc:	10800044 	addi	r2,r2,1
 90a3fe0:	e0bfff15 	stw	r2,-4(fp)
 90a3fe4:	e0bfff17 	ldw	r2,-4(fp)
 90a3fe8:	10800003 	ldbu	r2,0(r2)
 90a3fec:	10803fcc 	andi	r2,r2,255
 90a3ff0:	1080201c 	xori	r2,r2,128
 90a3ff4:	10bfe004 	addi	r2,r2,-128
 90a3ff8:	10800820 	cmpeqi	r2,r2,32
 90a3ffc:	103ff61e 	bne	r2,zero,90a3fd8 <nextarg+0x40>
      return (argp);
 90a4000:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4004:	e037883a 	mov	sp,fp
 90a4008:	df000017 	ldw	fp,0(sp)
 90a400c:	dec00104 	addi	sp,sp,4
 90a4010:	f800283a 	ret

090a4014 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 90a4014:	defff704 	addi	sp,sp,-36
 90a4018:	dfc00815 	stw	ra,32(sp)
 90a401c:	df000715 	stw	fp,28(sp)
 90a4020:	df000704 	addi	fp,sp,28
 90a4024:	e13ffc15 	stw	r4,-16(fp)
 90a4028:	e17ffd15 	stw	r5,-12(fp)
 90a402c:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 90a4030:	e0bffd17 	ldw	r2,-12(fp)
 90a4034:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 90a4038:	00004006 	br	90a413c <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a403c:	e03ffa15 	stw	zero,-24(fp)
 90a4040:	00000c06 	br	90a4074 <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 90a4044:	e0fffa17 	ldw	r3,-24(fp)
 90a4048:	e0bffb17 	ldw	r2,-20(fp)
 90a404c:	1885883a 	add	r2,r3,r2
 90a4050:	10800003 	ldbu	r2,0(r2)
 90a4054:	11803fcc 	andi	r6,r2,255
 90a4058:	e13ffc17 	ldw	r4,-16(fp)
 90a405c:	01424374 	movhi	r5,2317
 90a4060:	297d5d04 	addi	r5,r5,-2700
 90a4064:	90a45b40 	call	90a45b4 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a4068:	e0bffa17 	ldw	r2,-24(fp)
 90a406c:	10800044 	addi	r2,r2,1
 90a4070:	e0bffa15 	stw	r2,-24(fp)
 90a4074:	e0bffa17 	ldw	r2,-24(fp)
 90a4078:	10800428 	cmpgeui	r2,r2,16
 90a407c:	1000031e 	bne	r2,zero,90a408c <hexdump+0x78>
 90a4080:	e0fffa17 	ldw	r3,-24(fp)
 90a4084:	e0bffe17 	ldw	r2,-8(fp)
 90a4088:	18bfee36 	bltu	r3,r2,90a4044 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a408c:	e03ffa15 	stw	zero,-24(fp)
 90a4090:	00001806 	br	90a40f4 <hexdump+0xe0>
      {
         c = *(data + count);
 90a4094:	e0fffa17 	ldw	r3,-24(fp)
 90a4098:	e0bffb17 	ldw	r2,-20(fp)
 90a409c:	1885883a 	add	r2,r3,r2
 90a40a0:	10800003 	ldbu	r2,0(r2)
 90a40a4:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 90a40a8:	e0bff907 	ldb	r2,-28(fp)
 90a40ac:	10800810 	cmplti	r2,r2,32
 90a40b0:	1000061e 	bne	r2,zero,90a40cc <hexdump+0xb8>
 90a40b4:	e0bff907 	ldb	r2,-28(fp)
 90a40b8:	10801fe0 	cmpeqi	r2,r2,127
 90a40bc:	1000031e 	bne	r2,zero,90a40cc <hexdump+0xb8>
 90a40c0:	e0bff907 	ldb	r2,-28(fp)
 90a40c4:	e0bfff15 	stw	r2,-4(fp)
 90a40c8:	00000206 	br	90a40d4 <hexdump+0xc0>
 90a40cc:	00800b84 	movi	r2,46
 90a40d0:	e0bfff15 	stw	r2,-4(fp)
 90a40d4:	e13ffc17 	ldw	r4,-16(fp)
 90a40d8:	01424374 	movhi	r5,2317
 90a40dc:	297d5f04 	addi	r5,r5,-2692
 90a40e0:	e1bfff17 	ldw	r6,-4(fp)
 90a40e4:	90a45b40 	call	90a45b4 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a40e8:	e0bffa17 	ldw	r2,-24(fp)
 90a40ec:	10800044 	addi	r2,r2,1
 90a40f0:	e0bffa15 	stw	r2,-24(fp)
 90a40f4:	e0bffa17 	ldw	r2,-24(fp)
 90a40f8:	10800428 	cmpgeui	r2,r2,16
 90a40fc:	1000031e 	bne	r2,zero,90a410c <hexdump+0xf8>
 90a4100:	e0fffa17 	ldw	r3,-24(fp)
 90a4104:	e0bffe17 	ldw	r2,-8(fp)
 90a4108:	18bfe236 	bltu	r3,r2,90a4094 <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 90a410c:	e13ffc17 	ldw	r4,-16(fp)
 90a4110:	01424374 	movhi	r5,2317
 90a4114:	297d6004 	addi	r5,r5,-2688
 90a4118:	90a45b40 	call	90a45b4 <ns_printf>
      len -= count;
 90a411c:	e0fffe17 	ldw	r3,-8(fp)
 90a4120:	e0bffa17 	ldw	r2,-24(fp)
 90a4124:	1885c83a 	sub	r2,r3,r2
 90a4128:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 90a412c:	e0fffa17 	ldw	r3,-24(fp)
 90a4130:	e0bffb17 	ldw	r2,-20(fp)
 90a4134:	10c5883a 	add	r2,r2,r3
 90a4138:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 90a413c:	e0bffe17 	ldw	r2,-8(fp)
 90a4140:	1004c03a 	cmpne	r2,r2,zero
 90a4144:	103fbd1e 	bne	r2,zero,90a403c <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 90a4148:	e037883a 	mov	sp,fp
 90a414c:	dfc00117 	ldw	ra,4(sp)
 90a4150:	df000017 	ldw	fp,0(sp)
 90a4154:	dec00204 	addi	sp,sp,8
 90a4158:	f800283a 	ret

090a415c <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 90a415c:	defffa04 	addi	sp,sp,-24
 90a4160:	dfc00515 	stw	ra,20(sp)
 90a4164:	df000415 	stw	fp,16(sp)
 90a4168:	df000404 	addi	fp,sp,16
 90a416c:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 90a4170:	e0bfff17 	ldw	r2,-4(fp)
 90a4174:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 90a4178:	e0bffe03 	ldbu	r2,-8(fp)
 90a417c:	11803fcc 	andi	r6,r2,255
 90a4180:	e0bffe43 	ldbu	r2,-7(fp)
 90a4184:	11c03fcc 	andi	r7,r2,255
 90a4188:	e0bffe83 	ldbu	r2,-6(fp)
 90a418c:	10c03fcc 	andi	r3,r2,255
 90a4190:	e0bffec3 	ldbu	r2,-5(fp)
 90a4194:	10803fcc 	andi	r2,r2,255
 90a4198:	d8c00015 	stw	r3,0(sp)
 90a419c:	d8800115 	stw	r2,4(sp)
 90a41a0:	010243b4 	movhi	r4,2318
 90a41a4:	21343f84 	addi	r4,r4,-12034
 90a41a8:	01424374 	movhi	r5,2317
 90a41ac:	297d6104 	addi	r5,r5,-2684
 90a41b0:	90828ac0 	call	90828ac <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 90a41b4:	008243b4 	movhi	r2,2318
 90a41b8:	10b43f84 	addi	r2,r2,-12034
}
 90a41bc:	e037883a 	mov	sp,fp
 90a41c0:	dfc00117 	ldw	ra,4(sp)
 90a41c4:	df000017 	ldw	fp,0(sp)
 90a41c8:	dec00204 	addi	sp,sp,8
 90a41cc:	f800283a 	ret

090a41d0 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 90a41d0:	deffee04 	addi	sp,sp,-72
 90a41d4:	dfc01115 	stw	ra,68(sp)
 90a41d8:	df001015 	stw	fp,64(sp)
 90a41dc:	df001004 	addi	fp,sp,64
 90a41e0:	e13ff515 	stw	r4,-44(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 90a41e4:	e0fff517 	ldw	r3,-44(fp)
 90a41e8:	00947b34 	movhi	r2,20972
 90a41ec:	10a147c4 	addi	r2,r2,-31457
 90a41f0:	1889383a 	mul	r4,r3,r2
 90a41f4:	e13ff615 	stw	r4,-40(fp)
 90a41f8:	1886383a 	mulxuu	r3,r3,r2
 90a41fc:	e0fff715 	stw	r3,-36(fp)
 90a4200:	e0fff717 	ldw	r3,-36(fp)
 90a4204:	1804d17a 	srli	r2,r3,5
 90a4208:	e0bff515 	stw	r2,-44(fp)
   seconds = (unsigned)(timetick%60);
 90a420c:	e0fff517 	ldw	r3,-44(fp)
 90a4210:	00800f04 	movi	r2,60
 90a4214:	1885203a 	divu	r2,r3,r2
 90a4218:	10800f24 	muli	r2,r2,60
 90a421c:	1885c83a 	sub	r2,r3,r2
 90a4220:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 90a4224:	e0fff517 	ldw	r3,-44(fp)
 90a4228:	00a22274 	movhi	r2,34953
 90a422c:	10a22244 	addi	r2,r2,-30583
 90a4230:	1889383a 	mul	r4,r3,r2
 90a4234:	e13ff815 	stw	r4,-32(fp)
 90a4238:	1886383a 	mulxuu	r3,r3,r2
 90a423c:	e0fff915 	stw	r3,-28(fp)
 90a4240:	e0fff917 	ldw	r3,-28(fp)
 90a4244:	1804d17a 	srli	r2,r3,5
 90a4248:	e0bff515 	stw	r2,-44(fp)
   minutes = (unsigned)(timetick%60);
 90a424c:	e0fff517 	ldw	r3,-44(fp)
 90a4250:	00a22274 	movhi	r2,34953
 90a4254:	10a22244 	addi	r2,r2,-30583
 90a4258:	1889383a 	mul	r4,r3,r2
 90a425c:	e13ffa15 	stw	r4,-24(fp)
 90a4260:	1884383a 	mulxuu	r2,r3,r2
 90a4264:	e0bffb15 	stw	r2,-20(fp)
 90a4268:	e13ffb17 	ldw	r4,-20(fp)
 90a426c:	2004d17a 	srli	r2,r4,5
 90a4270:	10800f24 	muli	r2,r2,60
 90a4274:	1885c83a 	sub	r2,r3,r2
 90a4278:	e0bff315 	stw	r2,-52(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 90a427c:	e0fff517 	ldw	r3,-44(fp)
 90a4280:	00a22274 	movhi	r2,34953
 90a4284:	10a22244 	addi	r2,r2,-30583
 90a4288:	1889383a 	mul	r4,r3,r2
 90a428c:	e13ffc15 	stw	r4,-16(fp)
 90a4290:	1886383a 	mulxuu	r3,r3,r2
 90a4294:	e0fffd15 	stw	r3,-12(fp)
 90a4298:	e0fffd17 	ldw	r3,-12(fp)
 90a429c:	1804d17a 	srli	r2,r3,5
 90a42a0:	e0bff515 	stw	r2,-44(fp)
   hours = (unsigned)(timetick%24);
 90a42a4:	e0fff517 	ldw	r3,-44(fp)
 90a42a8:	00800604 	movi	r2,24
 90a42ac:	1885203a 	divu	r2,r3,r2
 90a42b0:	10800624 	muli	r2,r2,24
 90a42b4:	1885c83a 	sub	r2,r3,r2
 90a42b8:	e0bff215 	stw	r2,-56(fp)
   timetick = timetick/24;    /* turn timetick into days */
 90a42bc:	e0fff517 	ldw	r3,-44(fp)
 90a42c0:	00aaaaf4 	movhi	r2,43691
 90a42c4:	10aaaac4 	addi	r2,r2,-21845
 90a42c8:	1889383a 	mul	r4,r3,r2
 90a42cc:	e13ffe15 	stw	r4,-8(fp)
 90a42d0:	1886383a 	mulxuu	r3,r3,r2
 90a42d4:	e0ffff15 	stw	r3,-4(fp)
 90a42d8:	e0ffff17 	ldw	r3,-4(fp)
 90a42dc:	1804d13a 	srli	r2,r3,4
 90a42e0:	e0bff515 	stw	r2,-44(fp)

   if (timetick)  /* Is there a whole number of days? */
 90a42e4:	e0bff517 	ldw	r2,-44(fp)
 90a42e8:	1005003a 	cmpeq	r2,r2,zero
 90a42ec:	10000c1e 	bne	r2,zero,90a4320 <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 90a42f0:	e0bff317 	ldw	r2,-52(fp)
 90a42f4:	d8800015 	stw	r2,0(sp)
 90a42f8:	e0bff417 	ldw	r2,-48(fp)
 90a42fc:	d8800115 	stw	r2,4(sp)
 90a4300:	01024374 	movhi	r4,2317
 90a4304:	210e0c04 	addi	r4,r4,14384
 90a4308:	01424374 	movhi	r5,2317
 90a430c:	297d6404 	addi	r5,r5,-2672
 90a4310:	e1bff517 	ldw	r6,-44(fp)
 90a4314:	e1fff217 	ldw	r7,-56(fp)
 90a4318:	90828ac0 	call	90828ac <sprintf>
 90a431c:	00001406 	br	90a4370 <print_uptime+0x1a0>
    timetick, hours, minutes, seconds);
   else if (hours)
 90a4320:	e0bff217 	ldw	r2,-56(fp)
 90a4324:	1005003a 	cmpeq	r2,r2,zero
 90a4328:	10000a1e 	bne	r2,zero,90a4354 <print_uptime+0x184>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 90a432c:	e0bff417 	ldw	r2,-48(fp)
 90a4330:	d8800015 	stw	r2,0(sp)
 90a4334:	01024374 	movhi	r4,2317
 90a4338:	210e0c04 	addi	r4,r4,14384
 90a433c:	01424374 	movhi	r5,2317
 90a4340:	297d6a04 	addi	r5,r5,-2648
 90a4344:	e1bff217 	ldw	r6,-56(fp)
 90a4348:	e1fff317 	ldw	r7,-52(fp)
 90a434c:	90828ac0 	call	90828ac <sprintf>
 90a4350:	00000706 	br	90a4370 <print_uptime+0x1a0>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 90a4354:	01024374 	movhi	r4,2317
 90a4358:	210e0c04 	addi	r4,r4,14384
 90a435c:	01424374 	movhi	r5,2317
 90a4360:	297d6f04 	addi	r5,r5,-2628
 90a4364:	e1bff317 	ldw	r6,-52(fp)
 90a4368:	e1fff417 	ldw	r7,-48(fp)
 90a436c:	90828ac0 	call	90828ac <sprintf>
   return tistring;
 90a4370:	00824374 	movhi	r2,2317
 90a4374:	108e0c04 	addi	r2,r2,14384
}
 90a4378:	e037883a 	mov	sp,fp
 90a437c:	dfc00117 	ldw	ra,4(sp)
 90a4380:	df000017 	ldw	fp,0(sp)
 90a4384:	dec00204 	addi	sp,sp,8
 90a4388:	f800283a 	ret

090a438c <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 90a438c:	defffd04 	addi	sp,sp,-12
 90a4390:	dfc00215 	stw	ra,8(sp)
 90a4394:	df000115 	stw	fp,4(sp)
 90a4398:	df000104 	addi	fp,sp,4
 90a439c:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 90a43a0:	01024374 	movhi	r4,2317
 90a43a4:	213d7404 	addi	r4,r4,-2608
 90a43a8:	e17fff17 	ldw	r5,-4(fp)
 90a43ac:	90825100 	call	9082510 <printf>
   dtrap();                   /* try to hook debugger */
 90a43b0:	90a94880 	call	90a9488 <dtrap>
   netexit(1);                /* try to clean up */
 90a43b4:	01000044 	movi	r4,1
 90a43b8:	90c21e80 	call	90c21e8 <netexit>
}
 90a43bc:	e037883a 	mov	sp,fp
 90a43c0:	dfc00117 	ldw	ra,4(sp)
 90a43c4:	df000017 	ldw	fp,0(sp)
 90a43c8:	dec00204 	addi	sp,sp,8
 90a43cc:	f800283a 	ret

090a43d0 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 90a43d0:	defffb04 	addi	sp,sp,-20
 90a43d4:	df000415 	stw	fp,16(sp)
 90a43d8:	df000404 	addi	fp,sp,16
 90a43dc:	e13ffe15 	stw	r4,-8(fp)
 90a43e0:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 90a43e4:	008243b4 	movhi	r2,2318
 90a43e8:	10b43b04 	addi	r2,r2,-12052
 90a43ec:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 90a43f0:	e03ffd15 	stw	zero,-12(fp)
 90a43f4:	00004406 	br	90a4508 <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 90a43f8:	e0bffe17 	ldw	r2,-8(fp)
 90a43fc:	10800003 	ldbu	r2,0(r2)
 90a4400:	10803fcc 	andi	r2,r2,255
 90a4404:	1080201c 	xori	r2,r2,128
 90a4408:	10bfe004 	addi	r2,r2,-128
 90a440c:	1005d13a 	srai	r2,r2,4
 90a4410:	108003cc 	andi	r2,r2,15
 90a4414:	10800c04 	addi	r2,r2,48
 90a4418:	1007883a 	mov	r3,r2
 90a441c:	e0bffc17 	ldw	r2,-16(fp)
 90a4420:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 90a4424:	e0bffc17 	ldw	r2,-16(fp)
 90a4428:	10800003 	ldbu	r2,0(r2)
 90a442c:	10803fcc 	andi	r2,r2,255
 90a4430:	1080201c 	xori	r2,r2,128
 90a4434:	10bfe004 	addi	r2,r2,-128
 90a4438:	10800e90 	cmplti	r2,r2,58
 90a443c:	1000061e 	bne	r2,zero,90a4458 <print_eth+0x88>
         (*out) += 7;
 90a4440:	e0bffc17 	ldw	r2,-16(fp)
 90a4444:	10800003 	ldbu	r2,0(r2)
 90a4448:	108001c4 	addi	r2,r2,7
 90a444c:	1007883a 	mov	r3,r2
 90a4450:	e0bffc17 	ldw	r2,-16(fp)
 90a4454:	10c00005 	stb	r3,0(r2)
      out++;
 90a4458:	e0bffc17 	ldw	r2,-16(fp)
 90a445c:	10800044 	addi	r2,r2,1
 90a4460:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 90a4464:	e0bffe17 	ldw	r2,-8(fp)
 90a4468:	10800003 	ldbu	r2,0(r2)
 90a446c:	108003cc 	andi	r2,r2,15
 90a4470:	10800c04 	addi	r2,r2,48
 90a4474:	1007883a 	mov	r3,r2
 90a4478:	e0bffc17 	ldw	r2,-16(fp)
 90a447c:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 90a4480:	e0bffc17 	ldw	r2,-16(fp)
 90a4484:	10800003 	ldbu	r2,0(r2)
 90a4488:	10803fcc 	andi	r2,r2,255
 90a448c:	1080201c 	xori	r2,r2,128
 90a4490:	10bfe004 	addi	r2,r2,-128
 90a4494:	10800e90 	cmplti	r2,r2,58
 90a4498:	1000061e 	bne	r2,zero,90a44b4 <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 90a449c:	e0bffc17 	ldw	r2,-16(fp)
 90a44a0:	10800003 	ldbu	r2,0(r2)
 90a44a4:	108001c4 	addi	r2,r2,7
 90a44a8:	1007883a 	mov	r3,r2
 90a44ac:	e0bffc17 	ldw	r2,-16(fp)
 90a44b0:	10c00005 	stb	r3,0(r2)
      out++;
 90a44b4:	e0bffc17 	ldw	r2,-16(fp)
 90a44b8:	10800044 	addi	r2,r2,1
 90a44bc:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 90a44c0:	e0bfff07 	ldb	r2,-4(fp)
 90a44c4:	1005003a 	cmpeq	r2,r2,zero
 90a44c8:	1000091e 	bne	r2,zero,90a44f0 <print_eth+0x120>
 90a44cc:	e0bffd17 	ldw	r2,-12(fp)
 90a44d0:	10800148 	cmpgei	r2,r2,5
 90a44d4:	1000061e 	bne	r2,zero,90a44f0 <print_eth+0x120>
         *out++ = spacer;
 90a44d8:	e0fffc17 	ldw	r3,-16(fp)
 90a44dc:	e0bfff03 	ldbu	r2,-4(fp)
 90a44e0:	18800005 	stb	r2,0(r3)
 90a44e4:	e0bffc17 	ldw	r2,-16(fp)
 90a44e8:	10800044 	addi	r2,r2,1
 90a44ec:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 90a44f0:	e0bffe17 	ldw	r2,-8(fp)
 90a44f4:	10800044 	addi	r2,r2,1
 90a44f8:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 90a44fc:	e0bffd17 	ldw	r2,-12(fp)
 90a4500:	10800044 	addi	r2,r2,1
 90a4504:	e0bffd15 	stw	r2,-12(fp)
 90a4508:	e0bffd17 	ldw	r2,-12(fp)
 90a450c:	10800190 	cmplti	r2,r2,6
 90a4510:	103fb91e 	bne	r2,zero,90a43f8 <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 90a4514:	e0bffc17 	ldw	r2,-16(fp)
 90a4518:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 90a451c:	008243b4 	movhi	r2,2318
 90a4520:	10b43b04 	addi	r2,r2,-12052
}
 90a4524:	e037883a 	mov	sp,fp
 90a4528:	df000017 	ldw	fp,0(sp)
 90a452c:	dec00104 	addi	sp,sp,4
 90a4530:	f800283a 	ret

090a4534 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 90a4534:	defffd04 	addi	sp,sp,-12
 90a4538:	df000215 	stw	fp,8(sp)
 90a453c:	df000204 	addi	fp,sp,8
 90a4540:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 90a4544:	e0bfff17 	ldw	r2,-4(fp)
 90a4548:	e0bffe15 	stw	r2,-8(fp)
 90a454c:	00000d06 	br	90a4584 <uslash+0x50>
      if (*cp == '\\')
 90a4550:	e0bffe17 	ldw	r2,-8(fp)
 90a4554:	10800003 	ldbu	r2,0(r2)
 90a4558:	10803fcc 	andi	r2,r2,255
 90a455c:	1080201c 	xori	r2,r2,128
 90a4560:	10bfe004 	addi	r2,r2,-128
 90a4564:	10801718 	cmpnei	r2,r2,92
 90a4568:	1000031e 	bne	r2,zero,90a4578 <uslash+0x44>
      *cp = '/';
 90a456c:	e0fffe17 	ldw	r3,-8(fp)
 90a4570:	00800bc4 	movi	r2,47
 90a4574:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 90a4578:	e0bffe17 	ldw	r2,-8(fp)
 90a457c:	10800044 	addi	r2,r2,1
 90a4580:	e0bffe15 	stw	r2,-8(fp)
 90a4584:	e0bffe17 	ldw	r2,-8(fp)
 90a4588:	10800003 	ldbu	r2,0(r2)
 90a458c:	10803fcc 	andi	r2,r2,255
 90a4590:	1080201c 	xori	r2,r2,128
 90a4594:	10bfe004 	addi	r2,r2,-128
 90a4598:	1004c03a 	cmpne	r2,r2,zero
 90a459c:	103fec1e 	bne	r2,zero,90a4550 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 90a45a0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a45a4:	e037883a 	mov	sp,fp
 90a45a8:	df000017 	ldw	fp,0(sp)
 90a45ac:	dec00104 	addi	sp,sp,4
 90a45b0:	f800283a 	ret

090a45b4 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 90a45b4:	defff204 	addi	sp,sp,-56
 90a45b8:	dfc00b15 	stw	ra,44(sp)
 90a45bc:	df000a15 	stw	fp,40(sp)
 90a45c0:	dc400915 	stw	r17,36(sp)
 90a45c4:	dc000815 	stw	r16,32(sp)
 90a45c8:	df000804 	addi	fp,sp,32
 90a45cc:	e13ffd15 	stw	r4,-12(fp)
 90a45d0:	e1800415 	stw	r6,16(fp)
 90a45d4:	e1c00515 	stw	r7,20(fp)
 90a45d8:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 90a45dc:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 90a45e0:	00802704 	movi	r2,156
 90a45e4:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 90a45e8:	e0bffd17 	ldw	r2,-12(fp)
 90a45ec:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 90a45f0:	e0bff817 	ldw	r2,-32(fp)
 90a45f4:	1004c03a 	cmpne	r2,r2,zero
 90a45f8:	1000091e 	bne	r2,zero,90a4620 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 90a45fc:	e0800404 	addi	r2,fp,16
 90a4600:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 90a4604:	e17ffc17 	ldw	r5,-16(fp)
 90a4608:	e13ffe17 	ldw	r4,-8(fp)
 90a460c:	90caa680 	call	90caa68 <vprintf>
 90a4610:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 90a4614:	e0bffa17 	ldw	r2,-24(fp)
 90a4618:	e0bfff15 	stw	r2,-4(fp)
 90a461c:	00003e06 	br	90a4718 <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 90a4620:	e0bff817 	ldw	r2,-32(fp)
 90a4624:	10800117 	ldw	r2,4(r2)
 90a4628:	1004c03a 	cmpne	r2,r2,zero
 90a462c:	1000031e 	bne	r2,zero,90a463c <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 90a4630:	00bfffc4 	movi	r2,-1
 90a4634:	e0bfff15 	stw	r2,-4(fp)
 90a4638:	00003706 	br	90a4718 <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 90a463c:	e13ffe17 	ldw	r4,-8(fp)
 90a4640:	90830d40 	call	90830d4 <strlen>
 90a4644:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 90a4648:	e0bffa17 	ldw	r2,-24(fp)
 90a464c:	10802710 	cmplti	r2,r2,156
 90a4650:	1000041e 	bne	r2,zero,90a4664 <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 90a4654:	e0bff917 	ldw	r2,-28(fp)
 90a4658:	e0fffa17 	ldw	r3,-24(fp)
 90a465c:	10c5883a 	add	r2,r2,r3
 90a4660:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 90a4664:	e13ff917 	ldw	r4,-28(fp)
 90a4668:	90a9f0c0 	call	90a9f0c <npalloc>
 90a466c:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 90a4670:	e0bffb17 	ldw	r2,-20(fp)
 90a4674:	1004c03a 	cmpne	r2,r2,zero
 90a4678:	1000031e 	bne	r2,zero,90a4688 <ns_printf+0xd4>
   {
      return -2;
 90a467c:	00bfff84 	movi	r2,-2
 90a4680:	e0bfff15 	stw	r2,-4(fp)
 90a4684:	00002406 	br	90a4718 <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 90a4688:	e0800404 	addi	r2,fp,16
 90a468c:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 90a4690:	e1bffc17 	ldw	r6,-16(fp)
 90a4694:	e13ffb17 	ldw	r4,-20(fp)
 90a4698:	e17ffe17 	ldw	r5,-8(fp)
 90a469c:	90caad80 	call	90caad8 <vsprintf>
 90a46a0:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 90a46a4:	e13ffb17 	ldw	r4,-20(fp)
 90a46a8:	90830d40 	call	90830d4 <strlen>
 90a46ac:	1007883a 	mov	r3,r2
 90a46b0:	e0bff917 	ldw	r2,-28(fp)
 90a46b4:	10c0080e 	bge	r2,r3,90a46d8 <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 90a46b8:	01024374 	movhi	r4,2317
 90a46bc:	213d7704 	addi	r4,r4,-2596
 90a46c0:	90a438c0 	call	90a438c <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 90a46c4:	e0fff917 	ldw	r3,-28(fp)
 90a46c8:	e0bffb17 	ldw	r2,-20(fp)
 90a46cc:	1885883a 	add	r2,r3,r2
 90a46d0:	10bfffc4 	addi	r2,r2,-1
 90a46d4:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 90a46d8:	e0bff817 	ldw	r2,-32(fp)
 90a46dc:	14400117 	ldw	r17,4(r2)
 90a46e0:	e0bff817 	ldw	r2,-32(fp)
 90a46e4:	14000217 	ldw	r16,8(r2)
 90a46e8:	e13ffb17 	ldw	r4,-20(fp)
 90a46ec:	90830d40 	call	90830d4 <strlen>
 90a46f0:	100d883a 	mov	r6,r2
 90a46f4:	8009883a 	mov	r4,r16
 90a46f8:	e17ffb17 	ldw	r5,-20(fp)
 90a46fc:	883ee83a 	callr	r17
 90a4700:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 90a4704:	e13ffb17 	ldw	r4,-20(fp)
 90a4708:	90aa0000 	call	90aa000 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 90a470c:	90a501c0 	call	90a501c <tk_yield>

   return ret_value ;
 90a4710:	e0bffa17 	ldw	r2,-24(fp)
 90a4714:	e0bfff15 	stw	r2,-4(fp)
 90a4718:	e0bfff17 	ldw	r2,-4(fp)
}
 90a471c:	e037883a 	mov	sp,fp
 90a4720:	dfc00317 	ldw	ra,12(sp)
 90a4724:	df000217 	ldw	fp,8(sp)
 90a4728:	dc400117 	ldw	r17,4(sp)
 90a472c:	dc000017 	ldw	r16,0(sp)
 90a4730:	dec00604 	addi	sp,sp,24
 90a4734:	f800283a 	ret

090a4738 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 90a4738:	defffb04 	addi	sp,sp,-20
 90a473c:	dfc00415 	stw	ra,16(sp)
 90a4740:	df000315 	stw	fp,12(sp)
 90a4744:	df000304 	addi	fp,sp,12
 90a4748:	e13ffd15 	stw	r4,-12(fp)
 90a474c:	e17ffe15 	stw	r5,-8(fp)
 90a4750:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 90a4754:	01024374 	movhi	r4,2317
 90a4758:	213d7e04 	addi	r4,r4,-2568
 90a475c:	e17ffe17 	ldw	r5,-8(fp)
 90a4760:	90825100 	call	9082510 <printf>
   USE_ARG(s);
   return len;
 90a4764:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4768:	e037883a 	mov	sp,fp
 90a476c:	dfc00117 	ldw	ra,4(sp)
 90a4770:	df000017 	ldw	fp,0(sp)
 90a4774:	dec00204 	addi	sp,sp,8
 90a4778:	f800283a 	ret

090a477c <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 90a477c:	defff904 	addi	sp,sp,-28
 90a4780:	dfc00615 	stw	ra,24(sp)
 90a4784:	df000515 	stw	fp,20(sp)
 90a4788:	df000504 	addi	fp,sp,20
 90a478c:	e13ffd15 	stw	r4,-12(fp)
 90a4790:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 90a4794:	e0bffd17 	ldw	r2,-12(fp)
 90a4798:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 90a479c:	e0fffe17 	ldw	r3,-8(fp)
 90a47a0:	00800504 	movi	r2,20
 90a47a4:	1885283a 	div	r2,r3,r2
 90a47a8:	10800524 	muli	r2,r2,20
 90a47ac:	1885c83a 	sub	r2,r3,r2
 90a47b0:	1004c03a 	cmpne	r2,r2,zero
 90a47b4:	1000281e 	bne	r2,zero,90a4858 <con_page+0xdc>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 90a47b8:	e0bffb17 	ldw	r2,-20(fp)
 90a47bc:	1005003a 	cmpeq	r2,r2,zero
 90a47c0:	1000251e 	bne	r2,zero,90a4858 <con_page+0xdc>
 90a47c4:	e0bffb17 	ldw	r2,-20(fp)
 90a47c8:	10800317 	ldw	r2,12(r2)
 90a47cc:	1005003a 	cmpeq	r2,r2,zero
 90a47d0:	1000211e 	bne	r2,zero,90a4858 <con_page+0xdc>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 90a47d4:	e13ffb17 	ldw	r4,-20(fp)
 90a47d8:	01424374 	movhi	r5,2317
 90a47dc:	297d7f04 	addi	r5,r5,-2564
 90a47e0:	90a45b40 	call	90a45b4 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 90a47e4:	e0bffb17 	ldw	r2,-20(fp)
 90a47e8:	10c00317 	ldw	r3,12(r2)
 90a47ec:	e0bffb17 	ldw	r2,-20(fp)
 90a47f0:	11000217 	ldw	r4,8(r2)
 90a47f4:	183ee83a 	callr	r3
 90a47f8:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 90a47fc:	e0bffc17 	ldw	r2,-16(fp)
 90a4800:	1004c03a 	cmpne	r2,r2,zero
 90a4804:	1000011e 	bne	r2,zero,90a480c <con_page+0x90>
               tk_yield();    /* Give timeslice to other processes */
 90a4808:	90a501c0 	call	90a501c <tk_yield>
         } while (ch == 0) ;
 90a480c:	e0bffc17 	ldw	r2,-16(fp)
 90a4810:	1005003a 	cmpeq	r2,r2,zero
 90a4814:	103ff31e 	bne	r2,zero,90a47e4 <con_page+0x68>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 90a4818:	e0bffc17 	ldw	r2,-16(fp)
 90a481c:	10bfffd8 	cmpnei	r2,r2,-1
 90a4820:	1000031e 	bne	r2,zero,90a4830 <con_page+0xb4>
            return 1 ;
 90a4824:	00800044 	movi	r2,1
 90a4828:	e0bfff15 	stw	r2,-4(fp)
 90a482c:	00000b06 	br	90a485c <con_page+0xe0>

         ns_printf(pio,"\n");
 90a4830:	e13ffb17 	ldw	r4,-20(fp)
 90a4834:	01424374 	movhi	r5,2317
 90a4838:	297d6004 	addi	r5,r5,-2688
 90a483c:	90a45b40 	call	90a45b4 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 90a4840:	e0bffc17 	ldw	r2,-16(fp)
 90a4844:	108006d8 	cmpnei	r2,r2,27
 90a4848:	1000031e 	bne	r2,zero,90a4858 <con_page+0xdc>
            return 1 ;
 90a484c:	00800044 	movi	r2,1
 90a4850:	e0bfff15 	stw	r2,-4(fp)
 90a4854:	00000106 	br	90a485c <con_page+0xe0>
      }
   }
   return  0;
 90a4858:	e03fff15 	stw	zero,-4(fp)
 90a485c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4860:	e037883a 	mov	sp,fp
 90a4864:	dfc00117 	ldw	ra,4(sp)
 90a4868:	df000017 	ldw	fp,0(sp)
 90a486c:	dec00204 	addi	sp,sp,8
 90a4870:	f800283a 	ret

090a4874 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 90a4874:	defff604 	addi	sp,sp,-40
 90a4878:	dfc00915 	stw	ra,36(sp)
 90a487c:	df000815 	stw	fp,32(sp)
 90a4880:	df000804 	addi	fp,sp,32
 90a4884:	e13ffc15 	stw	r4,-16(fp)
 90a4888:	e17ffd15 	stw	r5,-12(fp)
 90a488c:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 90a4890:	e0bffc17 	ldw	r2,-16(fp)
 90a4894:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 90a4898:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 90a489c:	e0bffe17 	ldw	r2,-8(fp)
 90a48a0:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 90a48a4:	e0bffc17 	ldw	r2,-16(fp)
 90a48a8:	1004c03a 	cmpne	r2,r2,zero
 90a48ac:	1000021e 	bne	r2,zero,90a48b8 <parse_args+0x44>
   {
      return (NULL);
 90a48b0:	e03fff15 	stw	zero,-4(fp)
 90a48b4:	00007406 	br	90a4a88 <parse_args+0x214>
   }
   len = strlen(buf);
 90a48b8:	e13ffc17 	ldw	r4,-16(fp)
 90a48bc:	90830d40 	call	90830d4 <strlen>
 90a48c0:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 90a48c4:	e0bffa17 	ldw	r2,-24(fp)
 90a48c8:	10800048 	cmpgei	r2,r2,1
 90a48cc:	1000021e 	bne	r2,zero,90a48d8 <parse_args+0x64>
   {
      return (NULL);
 90a48d0:	e03fff15 	stw	zero,-4(fp)
 90a48d4:	00006c06 	br	90a4a88 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 90a48d8:	e0bffd17 	ldw	r2,-12(fp)
 90a48dc:	1085883a 	add	r2,r2,r2
 90a48e0:	1085883a 	add	r2,r2,r2
 90a48e4:	1009883a 	mov	r4,r2
 90a48e8:	90a9f0c0 	call	90a9f0c <npalloc>
 90a48ec:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 90a48f0:	e0bff817 	ldw	r2,-32(fp)
 90a48f4:	1004c03a 	cmpne	r2,r2,zero
 90a48f8:	1000051e 	bne	r2,zero,90a4910 <parse_args+0x9c>
   {
      return (NULL);
 90a48fc:	e03fff15 	stw	zero,-4(fp)
 90a4900:	00006106 	br	90a4a88 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 90a4904:	e0bff917 	ldw	r2,-28(fp)
 90a4908:	10800044 	addi	r2,r2,1
 90a490c:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 90a4910:	e0bff917 	ldw	r2,-28(fp)
 90a4914:	10800003 	ldbu	r2,0(r2)
 90a4918:	10803fcc 	andi	r2,r2,255
 90a491c:	1080201c 	xori	r2,r2,128
 90a4920:	10bfe004 	addi	r2,r2,-128
 90a4924:	10800820 	cmpeqi	r2,r2,32
 90a4928:	103ff61e 	bne	r2,zero,90a4904 <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 90a492c:	00003206 	br	90a49f8 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 90a4930:	e0bffe17 	ldw	r2,-8(fp)
 90a4934:	10800017 	ldw	r2,0(r2)
 90a4938:	1085883a 	add	r2,r2,r2
 90a493c:	1085883a 	add	r2,r2,r2
 90a4940:	1007883a 	mov	r3,r2
 90a4944:	e0bff817 	ldw	r2,-32(fp)
 90a4948:	1887883a 	add	r3,r3,r2
 90a494c:	e0bff917 	ldw	r2,-28(fp)
 90a4950:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 90a4954:	e0bffe17 	ldw	r2,-8(fp)
 90a4958:	10800017 	ldw	r2,0(r2)
 90a495c:	10c00044 	addi	r3,r2,1
 90a4960:	e0bffe17 	ldw	r2,-8(fp)
 90a4964:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 90a4968:	00000306 	br	90a4978 <parse_args+0x104>
      {
         bp++; 
 90a496c:	e0bff917 	ldw	r2,-28(fp)
 90a4970:	10800044 	addi	r2,r2,1
 90a4974:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 90a4978:	e0bff917 	ldw	r2,-28(fp)
 90a497c:	10800003 	ldbu	r2,0(r2)
 90a4980:	10803fcc 	andi	r2,r2,255
 90a4984:	1080201c 	xori	r2,r2,128
 90a4988:	10bfe004 	addi	r2,r2,-128
 90a498c:	10800820 	cmpeqi	r2,r2,32
 90a4990:	10000b1e 	bne	r2,zero,90a49c0 <parse_args+0x14c>
 90a4994:	e0bff917 	ldw	r2,-28(fp)
 90a4998:	10800003 	ldbu	r2,0(r2)
 90a499c:	10803fcc 	andi	r2,r2,255
 90a49a0:	1080201c 	xori	r2,r2,128
 90a49a4:	10bfe004 	addi	r2,r2,-128
 90a49a8:	1004c03a 	cmpne	r2,r2,zero
 90a49ac:	103fef1e 	bne	r2,zero,90a496c <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 90a49b0:	00000306 	br	90a49c0 <parse_args+0x14c>
      {
         bp++; 
 90a49b4:	e0bff917 	ldw	r2,-28(fp)
 90a49b8:	10800044 	addi	r2,r2,1
 90a49bc:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 90a49c0:	e0bff917 	ldw	r2,-28(fp)
 90a49c4:	10800003 	ldbu	r2,0(r2)
 90a49c8:	10803fcc 	andi	r2,r2,255
 90a49cc:	1080201c 	xori	r2,r2,128
 90a49d0:	10bfe004 	addi	r2,r2,-128
 90a49d4:	10800818 	cmpnei	r2,r2,32
 90a49d8:	1000071e 	bne	r2,zero,90a49f8 <parse_args+0x184>
 90a49dc:	e0bff917 	ldw	r2,-28(fp)
 90a49e0:	10800003 	ldbu	r2,0(r2)
 90a49e4:	10803fcc 	andi	r2,r2,255
 90a49e8:	1080201c 	xori	r2,r2,128
 90a49ec:	10bfe004 	addi	r2,r2,-128
 90a49f0:	1004c03a 	cmpne	r2,r2,zero
 90a49f4:	103fef1e 	bne	r2,zero,90a49b4 <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 90a49f8:	e0bff917 	ldw	r2,-28(fp)
 90a49fc:	10800003 	ldbu	r2,0(r2)
 90a4a00:	10803fcc 	andi	r2,r2,255
 90a4a04:	1080201c 	xori	r2,r2,128
 90a4a08:	10bfe004 	addi	r2,r2,-128
 90a4a0c:	1005003a 	cmpeq	r2,r2,zero
 90a4a10:	1000041e 	bne	r2,zero,90a4a24 <parse_args+0x1b0>
 90a4a14:	e0bffe17 	ldw	r2,-8(fp)
 90a4a18:	10c00017 	ldw	r3,0(r2)
 90a4a1c:	e0bffd17 	ldw	r2,-12(fp)
 90a4a20:	18bfc316 	blt	r3,r2,90a4930 <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 90a4a24:	e03ffb15 	stw	zero,-20(fp)
 90a4a28:	00001206 	br	90a4a74 <parse_args+0x200>
   {
      if (buf[i] == ' ')
 90a4a2c:	e0bffb17 	ldw	r2,-20(fp)
 90a4a30:	1007883a 	mov	r3,r2
 90a4a34:	e0bffc17 	ldw	r2,-16(fp)
 90a4a38:	1885883a 	add	r2,r3,r2
 90a4a3c:	10800003 	ldbu	r2,0(r2)
 90a4a40:	10803fcc 	andi	r2,r2,255
 90a4a44:	1080201c 	xori	r2,r2,128
 90a4a48:	10bfe004 	addi	r2,r2,-128
 90a4a4c:	10800818 	cmpnei	r2,r2,32
 90a4a50:	1000051e 	bne	r2,zero,90a4a68 <parse_args+0x1f4>
         buf[i] = '\0';
 90a4a54:	e0bffb17 	ldw	r2,-20(fp)
 90a4a58:	1007883a 	mov	r3,r2
 90a4a5c:	e0bffc17 	ldw	r2,-16(fp)
 90a4a60:	1885883a 	add	r2,r3,r2
 90a4a64:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 90a4a68:	e0bffb17 	ldw	r2,-20(fp)
 90a4a6c:	10800044 	addi	r2,r2,1
 90a4a70:	e0bffb15 	stw	r2,-20(fp)
 90a4a74:	e0fffb17 	ldw	r3,-20(fp)
 90a4a78:	e0bffa17 	ldw	r2,-24(fp)
 90a4a7c:	18bfeb16 	blt	r3,r2,90a4a2c <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 90a4a80:	e0bff817 	ldw	r2,-32(fp)
 90a4a84:	e0bfff15 	stw	r2,-4(fp)
 90a4a88:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4a8c:	e037883a 	mov	sp,fp
 90a4a90:	dfc00117 	ldw	ra,4(sp)
 90a4a94:	df000017 	ldw	fp,0(sp)
 90a4a98:	dec00204 	addi	sp,sp,8
 90a4a9c:	f800283a 	ret

090a4aa0 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 90a4aa0:	defffb04 	addi	sp,sp,-20
 90a4aa4:	dfc00415 	stw	ra,16(sp)
 90a4aa8:	df000315 	stw	fp,12(sp)
 90a4aac:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 90a4ab0:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 90a4ab4:	90bb0240 	call	90bb024 <prep_modules>
 90a4ab8:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 90a4abc:	e03ffe15 	stw	zero,-8(fp)
 90a4ac0:	00001c06 	br	90a4b34 <netmain+0x94>
   {
      e = TK_NEWTASK(&nettasks[i]);
 90a4ac4:	e0bffe17 	ldw	r2,-8(fp)
 90a4ac8:	10800624 	muli	r2,r2,24
 90a4acc:	1007883a 	mov	r3,r2
 90a4ad0:	00824374 	movhi	r2,2317
 90a4ad4:	108aa804 	addi	r2,r2,10912
 90a4ad8:	1889883a 	add	r4,r3,r2
 90a4adc:	90a98b00 	call	90a98b0 <TK_NEWTASK>
 90a4ae0:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 90a4ae4:	e0bffd17 	ldw	r2,-12(fp)
 90a4ae8:	1005003a 	cmpeq	r2,r2,zero
 90a4aec:	10000e1e 	bne	r2,zero,90a4b28 <netmain+0x88>
      {
         dprintf("task create error\n");
 90a4af0:	01024374 	movhi	r4,2317
 90a4af4:	213d9104 	addi	r4,r4,-2492
 90a4af8:	90828380 	call	9082838 <puts>
         panic((char *)&nettasks[i].name);
 90a4afc:	e0bffe17 	ldw	r2,-8(fp)
 90a4b00:	10800624 	muli	r2,r2,24
 90a4b04:	10c00104 	addi	r3,r2,4
 90a4b08:	00824374 	movhi	r2,2317
 90a4b0c:	108aa804 	addi	r2,r2,10912
 90a4b10:	1885883a 	add	r2,r3,r2
 90a4b14:	1009883a 	mov	r4,r2
 90a4b18:	90a438c0 	call	90a438c <panic>
         return -1;  /* compiler warnings */
 90a4b1c:	00bfffc4 	movi	r2,-1
 90a4b20:	e0bfff15 	stw	r2,-4(fp)
 90a4b24:	00001506 	br	90a4b7c <netmain+0xdc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 90a4b28:	e0bffe17 	ldw	r2,-8(fp)
 90a4b2c:	10800044 	addi	r2,r2,1
 90a4b30:	e0bffe15 	stw	r2,-8(fp)
 90a4b34:	d0e03017 	ldw	r3,-32576(gp)
 90a4b38:	e0bffe17 	ldw	r2,-8(fp)
 90a4b3c:	10ffe116 	blt	r2,r3,90a4ac4 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 90a4b40:	90bb5f40 	call	90bb5f4 <create_apptasks>
 90a4b44:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 90a4b48:	e0bffd17 	ldw	r2,-12(fp)
 90a4b4c:	1005003a 	cmpeq	r2,r2,zero
 90a4b50:	1000091e 	bne	r2,zero,90a4b78 <netmain+0xd8>
   {
      dprintf("task create error\n");
 90a4b54:	01024374 	movhi	r4,2317
 90a4b58:	213d9104 	addi	r4,r4,-2492
 90a4b5c:	90828380 	call	9082838 <puts>
      panic("netmain");
 90a4b60:	01024374 	movhi	r4,2317
 90a4b64:	213d9604 	addi	r4,r4,-2472
 90a4b68:	90a438c0 	call	90a438c <panic>
      return -1;  /* compiler warnings */
 90a4b6c:	00bfffc4 	movi	r2,-1
 90a4b70:	e0bfff15 	stw	r2,-4(fp)
 90a4b74:	00000106 	br	90a4b7c <netmain+0xdc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 90a4b78:	e03fff15 	stw	zero,-4(fp)
 90a4b7c:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 90a4b80:	e037883a 	mov	sp,fp
 90a4b84:	dfc00117 	ldw	ra,4(sp)
 90a4b88:	df000017 	ldw	fp,0(sp)
 90a4b8c:	dec00204 	addi	sp,sp,8
 90a4b90:	f800283a 	ret

090a4b94 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 90a4b94:	defffc04 	addi	sp,sp,-16
 90a4b98:	dfc00315 	stw	ra,12(sp)
 90a4b9c:	df000215 	stw	fp,8(sp)
 90a4ba0:	df000204 	addi	fp,sp,8
 90a4ba4:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 90a4ba8:	90bac180 	call	90bac18 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 90a4bac:	00800044 	movi	r2,1
 90a4bb0:	d0a08c15 	stw	r2,-32208(gp)
 90a4bb4:	00000006 	br	90a4bb8 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 90a4bb8:	00824374 	movhi	r2,2317
 90a4bbc:	108c4504 	addi	r2,r2,12564
 90a4bc0:	11000017 	ldw	r4,0(r2)
 90a4bc4:	01401904 	movi	r5,100
 90a4bc8:	e1bffe04 	addi	r6,fp,-8
 90a4bcc:	9092c6c0 	call	9092c6c <OSSemPend>
 90a4bd0:	e0bffe03 	ldbu	r2,-8(fp)
 90a4bd4:	10803fcc 	andi	r2,r2,255
 90a4bd8:	1005003a 	cmpeq	r2,r2,zero
 90a4bdc:	1000051e 	bne	r2,zero,90a4bf4 <tk_netmain+0x60>
 90a4be0:	e0bffe03 	ldbu	r2,-8(fp)
 90a4be4:	10803fcc 	andi	r2,r2,255
 90a4be8:	108002a0 	cmpeqi	r2,r2,10
 90a4bec:	1000011e 	bne	r2,zero,90a4bf4 <tk_netmain+0x60>
 90a4bf0:	90a94880 	call	90a9488 <dtrap>
      netmain_wakes++;  /* count wakeups */
 90a4bf4:	d0a08a17 	ldw	r2,-32216(gp)
 90a4bf8:	10800044 	addi	r2,r2,1
 90a4bfc:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 90a4c00:	008243b4 	movhi	r2,2318
 90a4c04:	10b35904 	addi	r2,r2,-12956
 90a4c08:	10800217 	ldw	r2,8(r2)
 90a4c0c:	1005003a 	cmpeq	r2,r2,zero
 90a4c10:	103fe91e 	bne	r2,zero,90a4bb8 <tk_netmain+0x24>
         pktdemux();
 90a4c14:	90a16b00 	call	90a16b0 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 90a4c18:	003fe706 	br	90a4bb8 <tk_netmain+0x24>

090a4c1c <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 90a4c1c:	defffd04 	addi	sp,sp,-12
 90a4c20:	dfc00215 	stw	ra,8(sp)
 90a4c24:	df000115 	stw	fp,4(sp)
 90a4c28:	df000104 	addi	fp,sp,4
 90a4c2c:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 90a4c30:	00000306 	br	90a4c40 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 90a4c34:	90a77a00 	call	90a77a0 <dhc_second>
#endif
      TK_SLEEP(1);
 90a4c38:	01000084 	movi	r4,2
 90a4c3c:	9094e000 	call	9094e00 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 90a4c40:	d0a08c17 	ldw	r2,-32208(gp)
 90a4c44:	1005003a 	cmpeq	r2,r2,zero
 90a4c48:	103ffa1e 	bne	r2,zero,90a4c34 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 90a4c4c:	01000084 	movi	r4,2
 90a4c50:	9094e000 	call	9094e00 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 90a4c54:	d0a08b17 	ldw	r2,-32212(gp)
 90a4c58:	10800044 	addi	r2,r2,1
 90a4c5c:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 90a4c60:	90bb07c0 	call	90bb07c <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 90a4c64:	003ff906 	br	90a4c4c <tk_nettick+0x30>

090a4c68 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 90a4c68:	defffe04 	addi	sp,sp,-8
 90a4c6c:	dfc00115 	stw	ra,4(sp)
 90a4c70:	df000015 	stw	fp,0(sp)
 90a4c74:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 90a4c78:	01000084 	movi	r4,2
 90a4c7c:	9094e000 	call	9094e00 <OSTimeDly>
}
 90a4c80:	e037883a 	mov	sp,fp
 90a4c84:	dfc00117 	ldw	ra,4(sp)
 90a4c88:	df000017 	ldw	fp,0(sp)
 90a4c8c:	dec00204 	addi	sp,sp,8
 90a4c90:	f800283a 	ret

090a4c94 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 90a4c94:	defffc04 	addi	sp,sp,-16
 90a4c98:	dfc00315 	stw	ra,12(sp)
 90a4c9c:	df000215 	stw	fp,8(sp)
 90a4ca0:	df000204 	addi	fp,sp,8
 90a4ca4:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 90a4ca8:	e0bfff17 	ldw	r2,-4(fp)
 90a4cac:	10800003 	ldbu	r2,0(r2)
 90a4cb0:	11003fcc 	andi	r4,r2,255
 90a4cb4:	90946000 	call	9094600 <OSTaskResume>
 90a4cb8:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 90a4cbc:	e0bffe03 	ldbu	r2,-8(fp)
 90a4cc0:	1005003a 	cmpeq	r2,r2,zero
 90a4cc4:	10000a1e 	bne	r2,zero,90a4cf0 <TK_OSTaskResume+0x5c>
 90a4cc8:	e0bffe03 	ldbu	r2,-8(fp)
 90a4ccc:	10801120 	cmpeqi	r2,r2,68
 90a4cd0:	1000071e 	bne	r2,zero,90a4cf0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 90a4cd4:	01024374 	movhi	r4,2317
 90a4cd8:	213d9804 	addi	r4,r4,-2464
 90a4cdc:	90828380 	call	9082838 <puts>
      dtrap();
 90a4ce0:	90a94880 	call	90a9488 <dtrap>
      panic("TK_OSTaskResume");      
 90a4ce4:	01024374 	movhi	r4,2317
 90a4ce8:	213da504 	addi	r4,r4,-2412
 90a4cec:	90a438c0 	call	90a438c <panic>
   }
#endif
}
 90a4cf0:	e037883a 	mov	sp,fp
 90a4cf4:	dfc00117 	ldw	ra,4(sp)
 90a4cf8:	df000017 	ldw	fp,0(sp)
 90a4cfc:	dec00204 	addi	sp,sp,8
 90a4d00:	f800283a 	ret

090a4d04 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 90a4d04:	defffb04 	addi	sp,sp,-20
 90a4d08:	dfc00415 	stw	ra,16(sp)
 90a4d0c:	df000315 	stw	fp,12(sp)
 90a4d10:	df000304 	addi	fp,sp,12
 90a4d14:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a4d18:	e03ffd15 	stw	zero,-12(fp)
 90a4d1c:	00005006 	br	90a4e60 <tcp_sleep+0x15c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 90a4d20:	e0bffd17 	ldw	r2,-12(fp)
 90a4d24:	00c243b4 	movhi	r3,2318
 90a4d28:	18f50904 	addi	r3,r3,-11228
 90a4d2c:	10800324 	muli	r2,r2,12
 90a4d30:	10c5883a 	add	r2,r2,r3
 90a4d34:	10800104 	addi	r2,r2,4
 90a4d38:	10800017 	ldw	r2,0(r2)
 90a4d3c:	1004c03a 	cmpne	r2,r2,zero
 90a4d40:	1000441e 	bne	r2,zero,90a4e54 <tcp_sleep+0x150>
      {
         global_TCPwakeup_set[i].soc_event = event;
 90a4d44:	e0bffd17 	ldw	r2,-12(fp)
 90a4d48:	00c243b4 	movhi	r3,2318
 90a4d4c:	18f50904 	addi	r3,r3,-11228
 90a4d50:	10800324 	muli	r2,r2,12
 90a4d54:	10c5883a 	add	r2,r2,r3
 90a4d58:	10c00104 	addi	r3,r2,4
 90a4d5c:	e0bfff17 	ldw	r2,-4(fp)
 90a4d60:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 90a4d64:	e13ffd17 	ldw	r4,-12(fp)
 90a4d68:	00824374 	movhi	r2,2317
 90a4d6c:	108c4204 	addi	r2,r2,12552
 90a4d70:	11400017 	ldw	r5,0(r2)
 90a4d74:	00c243b4 	movhi	r3,2318
 90a4d78:	18f50904 	addi	r3,r3,-11228
 90a4d7c:	20800324 	muli	r2,r4,12
 90a4d80:	10c5883a 	add	r2,r2,r3
 90a4d84:	11400015 	stw	r5,0(r2)
         if (i > global_TCPwakeup_setIndx)
 90a4d88:	00824374 	movhi	r2,2317
 90a4d8c:	108c4104 	addi	r2,r2,12548
 90a4d90:	10c00017 	ldw	r3,0(r2)
 90a4d94:	e0bffd17 	ldw	r2,-12(fp)
 90a4d98:	1880040e 	bge	r3,r2,90a4dac <tcp_sleep+0xa8>
            global_TCPwakeup_setIndx = i;
 90a4d9c:	00c24374 	movhi	r3,2317
 90a4da0:	18cc4104 	addi	r3,r3,12548
 90a4da4:	e0bffd17 	ldw	r2,-12(fp)
 90a4da8:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 90a4dac:	00824374 	movhi	r2,2317
 90a4db0:	108c3d04 	addi	r2,r2,12532
 90a4db4:	10800017 	ldw	r2,0(r2)
 90a4db8:	10c00044 	addi	r3,r2,1
 90a4dbc:	00824374 	movhi	r2,2317
 90a4dc0:	108c3d04 	addi	r2,r2,12532
 90a4dc4:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 90a4dc8:	0009883a 	mov	r4,zero
 90a4dcc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 90a4dd0:	e0bffd17 	ldw	r2,-12(fp)
 90a4dd4:	00c243b4 	movhi	r3,2318
 90a4dd8:	18f50904 	addi	r3,r3,-11228
 90a4ddc:	10800324 	muli	r2,r2,12
 90a4de0:	10c5883a 	add	r2,r2,r3
 90a4de4:	10800204 	addi	r2,r2,8
 90a4de8:	11000017 	ldw	r4,0(r2)
 90a4dec:	e1bffe04 	addi	r6,fp,-8
 90a4df0:	01401904 	movi	r5,100
 90a4df4:	9092c6c0 	call	9092c6c <OSSemPend>
         if (err == 10)
 90a4df8:	e0bffe03 	ldbu	r2,-8(fp)
 90a4dfc:	10803fcc 	andi	r2,r2,255
 90a4e00:	10800298 	cmpnei	r2,r2,10
 90a4e04:	1000101e 	bne	r2,zero,90a4e48 <tcp_sleep+0x144>
         {
            ++tcp_sleep_timeout;
 90a4e08:	d0a08e17 	ldw	r2,-32200(gp)
 90a4e0c:	10800044 	addi	r2,r2,1
 90a4e10:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 90a4e14:	e0bffd17 	ldw	r2,-12(fp)
 90a4e18:	00c243b4 	movhi	r3,2318
 90a4e1c:	18f50904 	addi	r3,r3,-11228
 90a4e20:	10800324 	muli	r2,r2,12
 90a4e24:	10c5883a 	add	r2,r2,r3
 90a4e28:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 90a4e2c:	e0bffd17 	ldw	r2,-12(fp)
 90a4e30:	00c243b4 	movhi	r3,2318
 90a4e34:	18f50904 	addi	r3,r3,-11228
 90a4e38:	10800324 	muli	r2,r2,12
 90a4e3c:	10c5883a 	add	r2,r2,r3
 90a4e40:	10800104 	addi	r2,r2,4
 90a4e44:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 90a4e48:	0009883a 	mov	r4,zero
 90a4e4c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         return;
 90a4e50:	00000f06 	br	90a4e90 <tcp_sleep+0x18c>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a4e54:	e0bffd17 	ldw	r2,-12(fp)
 90a4e58:	10800044 	addi	r2,r2,1
 90a4e5c:	e0bffd15 	stw	r2,-12(fp)
 90a4e60:	e0bffd17 	ldw	r2,-12(fp)
 90a4e64:	10800510 	cmplti	r2,r2,20
 90a4e68:	103fad1e 	bne	r2,zero,90a4d20 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 90a4e6c:	00c24374 	movhi	r3,2317
 90a4e70:	18cc4104 	addi	r3,r3,12548
 90a4e74:	e0bffd17 	ldw	r2,-12(fp)
 90a4e78:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 90a4e7c:	0009883a 	mov	r4,zero
 90a4e80:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 90a4e84:	90a501c0 	call	90a501c <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 90a4e88:	0009883a 	mov	r4,zero
 90a4e8c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
}
 90a4e90:	e037883a 	mov	sp,fp
 90a4e94:	dfc00117 	ldw	ra,4(sp)
 90a4e98:	df000017 	ldw	fp,0(sp)
 90a4e9c:	dec00204 	addi	sp,sp,8
 90a4ea0:	f800283a 	ret

090a4ea4 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 90a4ea4:	defffc04 	addi	sp,sp,-16
 90a4ea8:	dfc00315 	stw	ra,12(sp)
 90a4eac:	df000215 	stw	fp,8(sp)
 90a4eb0:	df000204 	addi	fp,sp,8
 90a4eb4:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 90a4eb8:	908dbac0 	call	908dbac <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a4ebc:	e03ffe15 	stw	zero,-8(fp)
 90a4ec0:	00003006 	br	90a4f84 <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 90a4ec4:	e0bffe17 	ldw	r2,-8(fp)
 90a4ec8:	00c243b4 	movhi	r3,2318
 90a4ecc:	18f50904 	addi	r3,r3,-11228
 90a4ed0:	10800324 	muli	r2,r2,12
 90a4ed4:	10c5883a 	add	r2,r2,r3
 90a4ed8:	10800017 	ldw	r2,0(r2)
 90a4edc:	1005003a 	cmpeq	r2,r2,zero
 90a4ee0:	1000251e 	bne	r2,zero,90a4f78 <tcp_wakeup+0xd4>
 90a4ee4:	e0bffe17 	ldw	r2,-8(fp)
 90a4ee8:	00c243b4 	movhi	r3,2318
 90a4eec:	18f50904 	addi	r3,r3,-11228
 90a4ef0:	10800324 	muli	r2,r2,12
 90a4ef4:	10c5883a 	add	r2,r2,r3
 90a4ef8:	10800104 	addi	r2,r2,4
 90a4efc:	10c00017 	ldw	r3,0(r2)
 90a4f00:	e0bfff17 	ldw	r2,-4(fp)
 90a4f04:	18801c1e 	bne	r3,r2,90a4f78 <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 90a4f08:	e0bffe17 	ldw	r2,-8(fp)
 90a4f0c:	00c243b4 	movhi	r3,2318
 90a4f10:	18f50904 	addi	r3,r3,-11228
 90a4f14:	10800324 	muli	r2,r2,12
 90a4f18:	10c5883a 	add	r2,r2,r3
 90a4f1c:	10800204 	addi	r2,r2,8
 90a4f20:	11000017 	ldw	r4,0(r2)
 90a4f24:	90930640 	call	9093064 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 90a4f28:	e0bffe17 	ldw	r2,-8(fp)
 90a4f2c:	00c243b4 	movhi	r3,2318
 90a4f30:	18f50904 	addi	r3,r3,-11228
 90a4f34:	10800324 	muli	r2,r2,12
 90a4f38:	10c5883a 	add	r2,r2,r3
 90a4f3c:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 90a4f40:	e0bffe17 	ldw	r2,-8(fp)
 90a4f44:	00c243b4 	movhi	r3,2318
 90a4f48:	18f50904 	addi	r3,r3,-11228
 90a4f4c:	10800324 	muli	r2,r2,12
 90a4f50:	10c5883a 	add	r2,r2,r3
 90a4f54:	10800104 	addi	r2,r2,4
 90a4f58:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 90a4f5c:	00824374 	movhi	r2,2317
 90a4f60:	108c3e04 	addi	r2,r2,12536
 90a4f64:	10800017 	ldw	r2,0(r2)
 90a4f68:	10c00044 	addi	r3,r2,1
 90a4f6c:	00824374 	movhi	r2,2317
 90a4f70:	108c3e04 	addi	r2,r2,12536
 90a4f74:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a4f78:	e0bffe17 	ldw	r2,-8(fp)
 90a4f7c:	10800044 	addi	r2,r2,1
 90a4f80:	e0bffe15 	stw	r2,-8(fp)
 90a4f84:	e0bffe17 	ldw	r2,-8(fp)
 90a4f88:	10800510 	cmplti	r2,r2,20
 90a4f8c:	103fcd1e 	bne	r2,zero,90a4ec4 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 90a4f90:	908dc380 	call	908dc38 <OSSchedUnlock>
}
 90a4f94:	e037883a 	mov	sp,fp
 90a4f98:	dfc00117 	ldw	ra,4(sp)
 90a4f9c:	df000017 	ldw	fp,0(sp)
 90a4fa0:	dec00204 	addi	sp,sp,8
 90a4fa4:	f800283a 	ret

090a4fa8 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 90a4fa8:	deffe104 	addi	sp,sp,-124
 90a4fac:	dfc01e15 	stw	ra,120(sp)
 90a4fb0:	df001d15 	stw	fp,116(sp)
 90a4fb4:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 90a4fb8:	e17fe404 	addi	r5,fp,-112
 90a4fbc:	01003fc4 	movi	r4,255
 90a4fc0:	9094c400 	call	9094c40 <OSTaskQuery>
 90a4fc4:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 90a4fc8:	e0bfe343 	ldbu	r2,-115(fp)
 90a4fcc:	1004c03a 	cmpne	r2,r2,zero
 90a4fd0:	1000051e 	bne	r2,zero,90a4fe8 <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 90a4fd4:	e0bff083 	ldbu	r2,-62(fp)
 90a4fd8:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 90a4fdc:	e0bfe303 	ldbu	r2,-116(fp)
 90a4fe0:	e0bfff15 	stw	r2,-4(fp)
 90a4fe4:	00000706 	br	90a5004 <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 90a4fe8:	01024374 	movhi	r4,2317
 90a4fec:	213da904 	addi	r4,r4,-2396
 90a4ff0:	90825100 	call	9082510 <printf>
      panic("TK_OSTaskQuery");
 90a4ff4:	01024374 	movhi	r4,2317
 90a4ff8:	213db604 	addi	r4,r4,-2344
 90a4ffc:	90a438c0 	call	90a438c <panic>
      return 0;
 90a5000:	e03fff15 	stw	zero,-4(fp)
 90a5004:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 90a5008:	e037883a 	mov	sp,fp
 90a500c:	dfc00117 	ldw	ra,4(sp)
 90a5010:	df000017 	ldw	fp,0(sp)
 90a5014:	dec00204 	addi	sp,sp,8
 90a5018:	f800283a 	ret

090a501c <tk_yield>:



void
tk_yield(void)
{
 90a501c:	defffe04 	addi	sp,sp,-8
 90a5020:	dfc00115 	stw	ra,4(sp)
 90a5024:	df000015 	stw	fp,0(sp)
 90a5028:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 90a502c:	01000044 	movi	r4,1
 90a5030:	9094e000 	call	9094e00 <OSTimeDly>
}
 90a5034:	e037883a 	mov	sp,fp
 90a5038:	dfc00117 	ldw	ra,4(sp)
 90a503c:	df000017 	ldw	fp,0(sp)
 90a5040:	dec00204 	addi	sp,sp,8
 90a5044:	f800283a 	ret

090a5048 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 90a5048:	deffef04 	addi	sp,sp,-68
 90a504c:	dfc01015 	stw	ra,64(sp)
 90a5050:	df000f15 	stw	fp,60(sp)
 90a5054:	df000f04 	addi	fp,sp,60
 90a5058:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 90a505c:	e13fff17 	ldw	r4,-4(fp)
 90a5060:	01424374 	movhi	r5,2317
 90a5064:	297dba04 	addi	r5,r5,-2328
 90a5068:	90a45b40 	call	90a45b4 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 90a506c:	00824374 	movhi	r2,2317
 90a5070:	108c0a04 	addi	r2,r2,12328
 90a5074:	11800017 	ldw	r6,0(r2)
 90a5078:	e13fff17 	ldw	r4,-4(fp)
 90a507c:	01424374 	movhi	r5,2317
 90a5080:	297dc004 	addi	r5,r5,-2304
 90a5084:	90a45b40 	call	90a45b4 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 90a5088:	e13fff17 	ldw	r4,-4(fp)
 90a508c:	01424374 	movhi	r5,2317
 90a5090:	297dc804 	addi	r5,r5,-2272
 90a5094:	90a45b40 	call	90a45b4 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 90a5098:	e03ff515 	stw	zero,-44(fp)
 90a509c:	00005106 	br	90a51e4 <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 90a50a0:	e0bff517 	ldw	r2,-44(fp)
 90a50a4:	00c243b4 	movhi	r3,2318
 90a50a8:	18f2ac04 	addi	r3,r3,-13648
 90a50ac:	1085883a 	add	r2,r2,r2
 90a50b0:	1085883a 	add	r2,r2,r2
 90a50b4:	10c5883a 	add	r2,r2,r3
 90a50b8:	10800017 	ldw	r2,0(r2)
 90a50bc:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 90a50c0:	e0bff417 	ldw	r2,-48(fp)
 90a50c4:	1005003a 	cmpeq	r2,r2,zero
 90a50c8:	1000431e 	bne	r2,zero,90a51d8 <tk_stats+0x190>
 90a50cc:	e0bff417 	ldw	r2,-48(fp)
 90a50d0:	10800060 	cmpeqi	r2,r2,1
 90a50d4:	1000401e 	bne	r2,zero,90a51d8 <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 90a50d8:	e0bff417 	ldw	r2,-48(fp)
 90a50dc:	10800c83 	ldbu	r2,50(r2)
 90a50e0:	11003fcc 	andi	r4,r2,255
 90a50e4:	e17ff604 	addi	r5,fp,-40
 90a50e8:	e1bffe44 	addi	r6,fp,-7
 90a50ec:	90942840 	call	9094284 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 90a50f0:	e0bff417 	ldw	r2,-48(fp)
 90a50f4:	10800c83 	ldbu	r2,50(r2)
 90a50f8:	11c03fcc 	andi	r7,r2,255
 90a50fc:	e0bff417 	ldw	r2,-48(fp)
 90a5100:	10800c03 	ldbu	r2,48(r2)
 90a5104:	10803fcc 	andi	r2,r2,255
 90a5108:	e1bff604 	addi	r6,fp,-40
 90a510c:	d8800015 	stw	r2,0(sp)
 90a5110:	e13fff17 	ldw	r4,-4(fp)
 90a5114:	01424374 	movhi	r5,2317
 90a5118:	297dd804 	addi	r5,r5,-2208
 90a511c:	90a45b40 	call	90a45b4 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 90a5120:	e0bff417 	ldw	r2,-48(fp)
 90a5124:	10800217 	ldw	r2,8(r2)
 90a5128:	1005003a 	cmpeq	r2,r2,zero
 90a512c:	1000261e 	bne	r2,zero,90a51c8 <tk_stats+0x180>
 90a5130:	e0bff417 	ldw	r2,-48(fp)
 90a5134:	10800317 	ldw	r2,12(r2)
 90a5138:	1005003a 	cmpeq	r2,r2,zero
 90a513c:	1000221e 	bne	r2,zero,90a51c8 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 90a5140:	e0bff417 	ldw	r2,-48(fp)
 90a5144:	10800217 	ldw	r2,8(r2)
 90a5148:	10800104 	addi	r2,r2,4
 90a514c:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 90a5150:	00000306 	br	90a5160 <tk_stats+0x118>
            sp++;
 90a5154:	e0bff317 	ldw	r2,-52(fp)
 90a5158:	10800104 	addi	r2,r2,4
 90a515c:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 90a5160:	e0bff317 	ldw	r2,-52(fp)
 90a5164:	10800017 	ldw	r2,0(r2)
 90a5168:	1005003a 	cmpeq	r2,r2,zero
 90a516c:	103ff91e 	bne	r2,zero,90a5154 <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 90a5170:	e0bff417 	ldw	r2,-48(fp)
 90a5174:	11000317 	ldw	r4,12(r2)
 90a5178:	e0fff317 	ldw	r3,-52(fp)
 90a517c:	e0bff417 	ldw	r2,-48(fp)
 90a5180:	10800217 	ldw	r2,8(r2)
 90a5184:	1885c83a 	sub	r2,r3,r2
 90a5188:	1005d0ba 	srai	r2,r2,2
 90a518c:	2085c83a 	sub	r2,r4,r2
 90a5190:	1085883a 	add	r2,r2,r2
 90a5194:	1085883a 	add	r2,r2,r2
 90a5198:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 90a519c:	e0bff417 	ldw	r2,-48(fp)
 90a51a0:	10800317 	ldw	r2,12(r2)
 90a51a4:	1085883a 	add	r2,r2,r2
 90a51a8:	1085883a 	add	r2,r2,r2
 90a51ac:	100d883a 	mov	r6,r2
 90a51b0:	e13fff17 	ldw	r4,-4(fp)
 90a51b4:	01424374 	movhi	r5,2317
 90a51b8:	297de004 	addi	r5,r5,-2176
 90a51bc:	e1fff217 	ldw	r7,-56(fp)
 90a51c0:	90a45b40 	call	90a45b4 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 90a51c4:	00000406 	br	90a51d8 <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 90a51c8:	e13fff17 	ldw	r4,-4(fp)
 90a51cc:	01424374 	movhi	r5,2317
 90a51d0:	297de404 	addi	r5,r5,-2160
 90a51d4:	90a45b40 	call	90a45b4 <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 90a51d8:	e0bff517 	ldw	r2,-44(fp)
 90a51dc:	10800044 	addi	r2,r2,1
 90a51e0:	e0bff515 	stw	r2,-44(fp)
 90a51e4:	e0bff517 	ldw	r2,-44(fp)
 90a51e8:	10800550 	cmplti	r2,r2,21
 90a51ec:	103fac1e 	bne	r2,zero,90a50a0 <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 90a51f0:	00824374 	movhi	r2,2317
 90a51f4:	108c3d04 	addi	r2,r2,12532
 90a51f8:	11800017 	ldw	r6,0(r2)
 90a51fc:	00824374 	movhi	r2,2317
 90a5200:	108c3e04 	addi	r2,r2,12536
 90a5204:	11c00017 	ldw	r7,0(r2)
 90a5208:	e13fff17 	ldw	r4,-4(fp)
 90a520c:	01424374 	movhi	r5,2317
 90a5210:	297de804 	addi	r5,r5,-2144
 90a5214:	90a45b40 	call	90a45b4 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 90a5218:	00824374 	movhi	r2,2317
 90a521c:	108c4104 	addi	r2,r2,12548
 90a5220:	11800017 	ldw	r6,0(r2)
 90a5224:	d1e08e17 	ldw	r7,-32200(gp)
 90a5228:	e13fff17 	ldw	r4,-4(fp)
 90a522c:	01424374 	movhi	r5,2317
 90a5230:	297df404 	addi	r5,r5,-2096
 90a5234:	90a45b40 	call	90a45b4 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 90a5238:	0005883a 	mov	r2,zero
}
 90a523c:	e037883a 	mov	sp,fp
 90a5240:	dfc00117 	ldw	ra,4(sp)
 90a5244:	df000017 	ldw	fp,0(sp)
 90a5248:	dec00204 	addi	sp,sp,8
 90a524c:	f800283a 	ret

090a5250 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 90a5250:	defffa04 	addi	sp,sp,-24
 90a5254:	dfc00515 	stw	ra,20(sp)
 90a5258:	df000415 	stw	fp,16(sp)
 90a525c:	df000404 	addi	fp,sp,16
 90a5260:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 90a5264:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 90a5268:	01000d84 	movi	r4,54
 90a526c:	e17fff17 	ldw	r5,-4(fp)
 90a5270:	90a84e80 	call	90a84e8 <find_opt>
 90a5274:	e0bffe15 	stw	r2,-8(fp)
 90a5278:	e0bffe17 	ldw	r2,-8(fp)
 90a527c:	1005003a 	cmpeq	r2,r2,zero
 90a5280:	1000111e 	bne	r2,zero,90a52c8 <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 90a5284:	e0bffe17 	ldw	r2,-8(fp)
 90a5288:	10800044 	addi	r2,r2,1
 90a528c:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 90a5290:	e0bffe17 	ldw	r2,-8(fp)
 90a5294:	10800003 	ldbu	r2,0(r2)
 90a5298:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 90a529c:	e0bffe17 	ldw	r2,-8(fp)
 90a52a0:	10800044 	addi	r2,r2,1
 90a52a4:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 90a52a8:	e13ffe17 	ldw	r4,-8(fp)
 90a52ac:	90a74180 	call	90a7418 <dh_getlong>
 90a52b0:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 90a52b4:	e0bffd03 	ldbu	r2,-12(fp)
 90a52b8:	1007883a 	mov	r3,r2
 90a52bc:	e0bffe17 	ldw	r2,-8(fp)
 90a52c0:	10c5883a 	add	r2,r2,r3
 90a52c4:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 90a52c8:	e0bffc17 	ldw	r2,-16(fp)
} 
 90a52cc:	e037883a 	mov	sp,fp
 90a52d0:	dfc00117 	ldw	ra,4(sp)
 90a52d4:	df000017 	ldw	fp,0(sp)
 90a52d8:	dec00204 	addi	sp,sp,8
 90a52dc:	f800283a 	ret

090a52e0 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 90a52e0:	defffb04 	addi	sp,sp,-20
 90a52e4:	dfc00415 	stw	ra,16(sp)
 90a52e8:	df000315 	stw	fp,12(sp)
 90a52ec:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 90a52f0:	00bfff44 	movi	r2,-3
 90a52f4:	d8800015 	stw	r2,0(sp)
 90a52f8:	0009883a 	mov	r4,zero
 90a52fc:	014010c4 	movi	r5,67
 90a5300:	01801104 	movi	r6,68
 90a5304:	01c242b4 	movhi	r7,2314
 90a5308:	39d4f804 	addi	r7,r7,21472
 90a530c:	90a8fd80 	call	90a8fd8 <udp_open>
 90a5310:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 90a5314:	d0a08f17 	ldw	r2,-32196(gp)
 90a5318:	1004c03a 	cmpne	r2,r2,zero
 90a531c:	1000031e 	bne	r2,zero,90a532c <dhc_init+0x4c>
      return ENP_RESOURCE;
 90a5320:	00bffa84 	movi	r2,-22
 90a5324:	e0bfff15 	stw	r2,-4(fp)
 90a5328:	00001606 	br	90a5384 <dhc_init+0xa4>

   for (i = 0; i < MAXNETS; i++)
 90a532c:	e03ffe15 	stw	zero,-8(fp)
 90a5330:	00001006 	br	90a5374 <dhc_init+0x94>
   {
      dhc_states[i].state = DHCS_UNUSED;
 90a5334:	e0bffe17 	ldw	r2,-8(fp)
 90a5338:	00c243b4 	movhi	r3,2318
 90a533c:	18f44404 	addi	r3,r3,-12016
 90a5340:	10800f24 	muli	r2,r2,60
 90a5344:	10c5883a 	add	r2,r2,r3
 90a5348:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 90a534c:	e0bffe17 	ldw	r2,-8(fp)
 90a5350:	00c243b4 	movhi	r3,2318
 90a5354:	18f44404 	addi	r3,r3,-12016
 90a5358:	10800f24 	muli	r2,r2,60
 90a535c:	10c5883a 	add	r2,r2,r3
 90a5360:	10800104 	addi	r2,r2,4
 90a5364:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 90a5368:	e0bffe17 	ldw	r2,-8(fp)
 90a536c:	10800044 	addi	r2,r2,1
 90a5370:	e0bffe15 	stw	r2,-8(fp)
 90a5374:	e0bffe17 	ldw	r2,-8(fp)
 90a5378:	10800110 	cmplti	r2,r2,4
 90a537c:	103fed1e 	bne	r2,zero,90a5334 <dhc_init+0x54>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 90a5380:	e03fff15 	stw	zero,-4(fp)
 90a5384:	e0bfff17 	ldw	r2,-4(fp)
}
 90a5388:	e037883a 	mov	sp,fp
 90a538c:	dfc00117 	ldw	ra,4(sp)
 90a5390:	df000017 	ldw	fp,0(sp)
 90a5394:	dec00204 	addi	sp,sp,8
 90a5398:	f800283a 	ret

090a539c <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 90a539c:	defffd04 	addi	sp,sp,-12
 90a53a0:	df000215 	stw	fp,8(sp)
 90a53a4:	df000204 	addi	fp,sp,8
 90a53a8:	e13ffe15 	stw	r4,-8(fp)
 90a53ac:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 90a53b0:	e0bffe17 	ldw	r2,-8(fp)
 90a53b4:	00c243b4 	movhi	r3,2318
 90a53b8:	18f44404 	addi	r3,r3,-12016
 90a53bc:	10800f24 	muli	r2,r2,60
 90a53c0:	10c5883a 	add	r2,r2,r3
 90a53c4:	10c00e04 	addi	r3,r2,56
 90a53c8:	e0bfff17 	ldw	r2,-4(fp)
 90a53cc:	18800015 	stw	r2,0(r3)
}
 90a53d0:	e037883a 	mov	sp,fp
 90a53d4:	df000017 	ldw	fp,0(sp)
 90a53d8:	dec00104 	addi	sp,sp,4
 90a53dc:	f800283a 	ret

090a53e0 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 90a53e0:	defff204 	addi	sp,sp,-56
 90a53e4:	dfc00d15 	stw	ra,52(sp)
 90a53e8:	df000c15 	stw	fp,48(sp)
 90a53ec:	dc000b15 	stw	r16,44(sp)
 90a53f0:	df000b04 	addi	fp,sp,44
 90a53f4:	e13ffb15 	stw	r4,-20(fp)
 90a53f8:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 90a53fc:	e0bffb17 	ldw	r2,-20(fp)
 90a5400:	10800417 	ldw	r2,16(r2)
 90a5404:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 90a5408:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 90a540c:	e0bffc17 	ldw	r2,-16(fp)
 90a5410:	10bfff60 	cmpeqi	r2,r2,-3
 90a5414:	1000041e 	bne	r2,zero,90a5428 <dhc_upcall+0x48>
   {
      dtrap();
 90a5418:	90a94880 	call	90a9488 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 90a541c:	00bffd44 	movi	r2,-11
 90a5420:	e0bffe15 	stw	r2,-8(fp)
 90a5424:	0001f306 	br	90a5bf4 <dhc_upcall+0x814>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 90a5428:	e0bffb17 	ldw	r2,-20(fp)
 90a542c:	11000617 	ldw	r4,24(r2)
 90a5430:	90a21180 	call	90a2118 <if_netnumber>
 90a5434:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 90a5438:	e0bff617 	ldw	r2,-40(fp)
 90a543c:	00c243b4 	movhi	r3,2318
 90a5440:	18f44404 	addi	r3,r3,-12016
 90a5444:	10800f24 	muli	r2,r2,60
 90a5448:	10c5883a 	add	r2,r2,r3
 90a544c:	10800017 	ldw	r2,0(r2)
 90a5450:	1004c03a 	cmpne	r2,r2,zero
 90a5454:	1000031e 	bne	r2,zero,90a5464 <dhc_upcall+0x84>
      return ENP_NOT_MINE;
 90a5458:	00c00084 	movi	r3,2
 90a545c:	e0fffe15 	stw	r3,-8(fp)
 90a5460:	0001e406 	br	90a5bf4 <dhc_upcall+0x814>

   bp = (struct bootp *)pkt->nb_prot;
 90a5464:	e0bffb17 	ldw	r2,-20(fp)
 90a5468:	10800317 	ldw	r2,12(r2)
 90a546c:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 90a5470:	e0bff917 	ldw	r2,-28(fp)
 90a5474:	10803b30 	cmpltui	r2,r2,236
 90a5478:	10000b1e 	bne	r2,zero,90a54a8 <dhc_upcall+0xc8>
 90a547c:	e0bffa17 	ldw	r2,-24(fp)
 90a5480:	10800003 	ldbu	r2,0(r2)
 90a5484:	10803fcc 	andi	r2,r2,255
 90a5488:	10800098 	cmpnei	r2,r2,2
 90a548c:	1000061e 	bne	r2,zero,90a54a8 <dhc_upcall+0xc8>
 90a5490:	e0bffa17 	ldw	r2,-24(fp)
 90a5494:	10803b04 	addi	r2,r2,236
 90a5498:	10c00017 	ldw	r3,0(r2)
 90a549c:	0098d534 	movhi	r2,25428
 90a54a0:	10a098c4 	addi	r2,r2,-32157
 90a54a4:	18800726 	beq	r3,r2,90a54c4 <dhc_upcall+0xe4>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 90a54a8:	90a94880 	call	90a9488 <dtrap>
      dsc_errors++;
 90a54ac:	d0a09017 	ldw	r2,-32192(gp)
 90a54b0:	10800044 	addi	r2,r2,1
 90a54b4:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 90a54b8:	01000084 	movi	r4,2
 90a54bc:	e13ffe15 	stw	r4,-8(fp)
 90a54c0:	0001cc06 	br	90a5bf4 <dhc_upcall+0x814>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 90a54c4:	e0bffa17 	ldw	r2,-24(fp)
 90a54c8:	11000704 	addi	r4,r2,28
 90a54cc:	e0bffb17 	ldw	r2,-20(fp)
 90a54d0:	10800617 	ldw	r2,24(r2)
 90a54d4:	11401717 	ldw	r5,92(r2)
 90a54d8:	e0bffb17 	ldw	r2,-20(fp)
 90a54dc:	10800617 	ldw	r2,24(r2)
 90a54e0:	11801117 	ldw	r6,68(r2)
 90a54e4:	90ca5400 	call	90ca540 <memcmp>
 90a54e8:	1005003a 	cmpeq	r2,r2,zero
 90a54ec:	1000031e 	bne	r2,zero,90a54fc <dhc_upcall+0x11c>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 90a54f0:	00800084 	movi	r2,2
 90a54f4:	e0bffe15 	stw	r2,-8(fp)
 90a54f8:	0001be06 	br	90a5bf4 <dhc_upcall+0x814>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 90a54fc:	e0bffa17 	ldw	r2,-24(fp)
 90a5500:	10803b04 	addi	r2,r2,236
 90a5504:	11400104 	addi	r5,r2,4
 90a5508:	01000d44 	movi	r4,53
 90a550c:	90a84e80 	call	90a84e8 <find_opt>
 90a5510:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 90a5514:	e0bff517 	ldw	r2,-44(fp)
 90a5518:	1005003a 	cmpeq	r2,r2,zero
 90a551c:	1000101e 	bne	r2,zero,90a5560 <dhc_upcall+0x180>
 90a5520:	e0bff517 	ldw	r2,-44(fp)
 90a5524:	10800003 	ldbu	r2,0(r2)
 90a5528:	10803fcc 	andi	r2,r2,255
 90a552c:	10800d58 	cmpnei	r2,r2,53
 90a5530:	10000b1e 	bne	r2,zero,90a5560 <dhc_upcall+0x180>
   {
      dhcptype = *(opts+2);
 90a5534:	e0bff517 	ldw	r2,-44(fp)
 90a5538:	10800084 	addi	r2,r2,2
 90a553c:	10800003 	ldbu	r2,0(r2)
 90a5540:	10803fcc 	andi	r2,r2,255
 90a5544:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 90a5548:	e0bffa17 	ldw	r2,-24(fp)
 90a554c:	10800003 	ldbu	r2,0(r2)
 90a5550:	10800114 	ori	r2,r2,4
 90a5554:	1007883a 	mov	r3,r2
 90a5558:	e0bffa17 	ldw	r2,-24(fp)
 90a555c:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 90a5560:	e0bffa17 	ldw	r2,-24(fp)
 90a5564:	10800003 	ldbu	r2,0(r2)
 90a5568:	10803fcc 	andi	r2,r2,255
 90a556c:	1080010c 	andi	r2,r2,4
 90a5570:	1005003a 	cmpeq	r2,r2,zero
 90a5574:	10017e1e 	bne	r2,zero,90a5b70 <dhc_upcall+0x790>
   {
      switch (dhcptype)
 90a5578:	e0fff817 	ldw	r3,-32(fp)
 90a557c:	e0ffff15 	stw	r3,-4(fp)
 90a5580:	e13fff17 	ldw	r4,-4(fp)
 90a5584:	20800148 	cmpgei	r2,r4,5
 90a5588:	1000071e 	bne	r2,zero,90a55a8 <dhc_upcall+0x1c8>
 90a558c:	e0ffff17 	ldw	r3,-4(fp)
 90a5590:	188000c8 	cmpgei	r2,r3,3
 90a5594:	1000081e 	bne	r2,zero,90a55b8 <dhc_upcall+0x1d8>
 90a5598:	e13fff17 	ldw	r4,-4(fp)
 90a559c:	20800060 	cmpeqi	r2,r4,1
 90a55a0:	1000051e 	bne	r2,zero,90a55b8 <dhc_upcall+0x1d8>
 90a55a4:	00000a06 	br	90a55d0 <dhc_upcall+0x1f0>
 90a55a8:	e0ffff17 	ldw	r3,-4(fp)
 90a55ac:	188001e0 	cmpeqi	r2,r3,7
 90a55b0:	1000011e 	bne	r2,zero,90a55b8 <dhc_upcall+0x1d8>
 90a55b4:	00000606 	br	90a55d0 <dhc_upcall+0x1f0>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 90a55b8:	d0a09017 	ldw	r2,-32192(gp)
 90a55bc:	10800044 	addi	r2,r2,1
 90a55c0:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 90a55c4:	01000084 	movi	r4,2
 90a55c8:	e13ffe15 	stw	r4,-8(fp)
 90a55cc:	00018906 	br	90a5bf4 <dhc_upcall+0x814>
      }

      switch (dhc_states[iface].state)
 90a55d0:	e0bff617 	ldw	r2,-40(fp)
 90a55d4:	00c243b4 	movhi	r3,2318
 90a55d8:	18f44404 	addi	r3,r3,-12016
 90a55dc:	10800f24 	muli	r2,r2,60
 90a55e0:	10c5883a 	add	r2,r2,r3
 90a55e4:	10800017 	ldw	r2,0(r2)
 90a55e8:	e0bffd15 	stw	r2,-12(fp)
 90a55ec:	e0fffd17 	ldw	r3,-12(fp)
 90a55f0:	18800268 	cmpgeui	r2,r3,9
 90a55f4:	1001541e 	bne	r2,zero,90a5b48 <dhc_upcall+0x768>
 90a55f8:	e13ffd17 	ldw	r4,-12(fp)
 90a55fc:	e13ffd17 	ldw	r4,-12(fp)
 90a5600:	2105883a 	add	r2,r4,r4
 90a5604:	1087883a 	add	r3,r2,r2
 90a5608:	008242b4 	movhi	r2,2314
 90a560c:	10958704 	addi	r2,r2,22044
 90a5610:	1885883a 	add	r2,r3,r2
 90a5614:	10800017 	ldw	r2,0(r2)
 90a5618:	1000683a 	jmp	r2
 90a561c:	090a5b48 	cmpgei	r4,at,10605
 90a5620:	090a5640 	call	90a564 <OSCtxSw_SWITCH_PC+0x90a524>
 90a5624:	090a5640 	call	90a564 <OSCtxSw_SWITCH_PC+0x90a524>
 90a5628:	090a5894 	ori	r4,at,10594
 90a562c:	090a5658 	cmpnei	r4,at,10585
 90a5630:	090a57dc 	xori	r4,at,10591
 90a5634:	090a5640 	call	90a564 <OSCtxSw_SWITCH_PC+0x90a524>
 90a5638:	090a57dc 	xori	r4,at,10591
 90a563c:	090a57dc 	xori	r4,at,10591
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 90a5640:	d0a09017 	ldw	r2,-32192(gp)
 90a5644:	10800044 	addi	r2,r2,1
 90a5648:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 90a564c:	00800084 	movi	r2,2
 90a5650:	e0bffe15 	stw	r2,-8(fp)
 90a5654:	00016706 	br	90a5bf4 <dhc_upcall+0x814>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 90a5658:	e0bff817 	ldw	r2,-32(fp)
 90a565c:	10800098 	cmpnei	r2,r2,2
 90a5660:	1000521e 	bne	r2,zero,90a57ac <dhc_upcall+0x3cc>
         {
            dsc_offers++;
 90a5664:	d0a09217 	ldw	r2,-32184(gp)
 90a5668:	10800044 	addi	r2,r2,1
 90a566c:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 90a5670:	e43ff617 	ldw	r16,-40(fp)
 90a5674:	e0bffa17 	ldw	r2,-24(fp)
 90a5678:	10803b04 	addi	r2,r2,236
 90a567c:	11000104 	addi	r4,r2,4
 90a5680:	90a52500 	call	90a5250 <dhc_get_srv_ipaddr>
 90a5684:	1009883a 	mov	r4,r2
 90a5688:	00c243b4 	movhi	r3,2318
 90a568c:	18f44404 	addi	r3,r3,-12016
 90a5690:	80800f24 	muli	r2,r16,60
 90a5694:	10c5883a 	add	r2,r2,r3
 90a5698:	10800d04 	addi	r2,r2,52
 90a569c:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 90a56a0:	e0bff617 	ldw	r2,-40(fp)
 90a56a4:	00c243b4 	movhi	r3,2318
 90a56a8:	18f44404 	addi	r3,r3,-12016
 90a56ac:	10800f24 	muli	r2,r2,60
 90a56b0:	10c5883a 	add	r2,r2,r3
 90a56b4:	10800d04 	addi	r2,r2,52
 90a56b8:	10800017 	ldw	r2,0(r2)
 90a56bc:	1004c03a 	cmpne	r2,r2,zero
 90a56c0:	10000d1e 	bne	r2,zero,90a56f8 <dhc_upcall+0x318>
            {
               dtrap(); /* didn't receive server-identifier option */
 90a56c4:	90a94880 	call	90a9488 <dtrap>
               dsc_errors++;
 90a56c8:	d0a09017 	ldw	r2,-32192(gp)
 90a56cc:	10800044 	addi	r2,r2,1
 90a56d0:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 90a56d4:	e13ff617 	ldw	r4,-40(fp)
 90a56d8:	e0bffb17 	ldw	r2,-20(fp)
 90a56dc:	11400717 	ldw	r5,28(r2)
 90a56e0:	00c243b4 	movhi	r3,2318
 90a56e4:	18f44404 	addi	r3,r3,-12016
 90a56e8:	20800f24 	muli	r2,r4,60
 90a56ec:	10c5883a 	add	r2,r2,r3
 90a56f0:	10800d04 	addi	r2,r2,52
 90a56f4:	11400015 	stw	r5,0(r2)
            }

            if (bp->hops)
 90a56f8:	e0bffa17 	ldw	r2,-24(fp)
 90a56fc:	108000c3 	ldbu	r2,3(r2)
 90a5700:	10803fcc 	andi	r2,r2,255
 90a5704:	1005003a 	cmpeq	r2,r2,zero
 90a5708:	10000a1e 	bne	r2,zero,90a5734 <dhc_upcall+0x354>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 90a570c:	e13ff617 	ldw	r4,-40(fp)
 90a5710:	e0bffb17 	ldw	r2,-20(fp)
 90a5714:	11400717 	ldw	r5,28(r2)
 90a5718:	00c243b4 	movhi	r3,2318
 90a571c:	18f44404 	addi	r3,r3,-12016
 90a5720:	20800f24 	muli	r2,r4,60
 90a5724:	10c5883a 	add	r2,r2,r3
 90a5728:	10800c04 	addi	r2,r2,48
 90a572c:	11400015 	stw	r5,0(r2)
 90a5730:	00000706 	br	90a5750 <dhc_upcall+0x370>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 90a5734:	e0bff617 	ldw	r2,-40(fp)
 90a5738:	00c243b4 	movhi	r3,2318
 90a573c:	18f44404 	addi	r3,r3,-12016
 90a5740:	10800f24 	muli	r2,r2,60
 90a5744:	10c5883a 	add	r2,r2,r3
 90a5748:	10800c04 	addi	r2,r2,48
 90a574c:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 90a5750:	e0bffb17 	ldw	r2,-20(fp)
 90a5754:	11800417 	ldw	r6,16(r2)
 90a5758:	e13ff617 	ldw	r4,-40(fp)
 90a575c:	e17ffa17 	ldw	r5,-24(fp)
 90a5760:	90a635c0 	call	90a635c <dhc_rx_offer>
 90a5764:	e0bff715 	stw	r2,-36(fp)
            if (e)
 90a5768:	e0bff717 	ldw	r2,-36(fp)
 90a576c:	1005003a 	cmpeq	r2,r2,zero
 90a5770:	10000a1e 	bne	r2,zero,90a579c <dhc_upcall+0x3bc>
            {
               dsc_errors++;
 90a5774:	d0a09017 	ldw	r2,-32192(gp)
 90a5778:	10800044 	addi	r2,r2,1
 90a577c:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 90a5780:	e13ff617 	ldw	r4,-40(fp)
 90a5784:	01400044 	movi	r5,1
 90a5788:	90a84380 	call	90a8438 <dhc_set_state>
               dtrap();
 90a578c:	90a94880 	call	90a9488 <dtrap>
               return ENP_NOT_MINE;
 90a5790:	00c00084 	movi	r3,2
 90a5794:	e0fffe15 	stw	r3,-8(fp)
 90a5798:	00011606 	br	90a5bf4 <dhc_upcall+0x814>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 90a579c:	e13ff617 	ldw	r4,-40(fp)
 90a57a0:	01400144 	movi	r5,5
 90a57a4:	90a84380 	call	90a8438 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 90a57a8:	00010f06 	br	90a5be8 <dhc_upcall+0x808>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 90a57ac:	d0a09017 	ldw	r2,-32192(gp)
 90a57b0:	10800044 	addi	r2,r2,1
 90a57b4:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 90a57b8:	e0bff817 	ldw	r2,-32(fp)
 90a57bc:	10800198 	cmpnei	r2,r2,6
 90a57c0:	1000031e 	bne	r2,zero,90a57d0 <dhc_upcall+0x3f0>
               dsc_naks++;
 90a57c4:	d0a09817 	ldw	r2,-32160(gp)
 90a57c8:	10800044 	addi	r2,r2,1
 90a57cc:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 90a57d0:	01000084 	movi	r4,2
 90a57d4:	e13ffe15 	stw	r4,-8(fp)
 90a57d8:	00010606 	br	90a5bf4 <dhc_upcall+0x814>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 90a57dc:	e0bff617 	ldw	r2,-40(fp)
 90a57e0:	00c243b4 	movhi	r3,2318
 90a57e4:	18f44404 	addi	r3,r3,-12016
 90a57e8:	10800f24 	muli	r2,r2,60
 90a57ec:	10c5883a 	add	r2,r2,r3
 90a57f0:	10800d04 	addi	r2,r2,52
 90a57f4:	14000017 	ldw	r16,0(r2)
 90a57f8:	e0bffa17 	ldw	r2,-24(fp)
 90a57fc:	10803b04 	addi	r2,r2,236
 90a5800:	11000104 	addi	r4,r2,4
 90a5804:	90a52500 	call	90a5250 <dhc_get_srv_ipaddr>
 90a5808:	80800626 	beq	r16,r2,90a5824 <dhc_upcall+0x444>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 90a580c:	d0a09017 	ldw	r2,-32192(gp)
 90a5810:	10800044 	addi	r2,r2,1
 90a5814:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 90a5818:	00800084 	movi	r2,2
 90a581c:	e0bffe15 	stw	r2,-8(fp)
 90a5820:	0000f406 	br	90a5bf4 <dhc_upcall+0x814>
         }
         if (dhc_states[iface].rly_ipaddr &&
 90a5824:	e0bff617 	ldw	r2,-40(fp)
 90a5828:	00c243b4 	movhi	r3,2318
 90a582c:	18f44404 	addi	r3,r3,-12016
 90a5830:	10800f24 	muli	r2,r2,60
 90a5834:	10c5883a 	add	r2,r2,r3
 90a5838:	10800c04 	addi	r2,r2,48
 90a583c:	10800017 	ldw	r2,0(r2)
 90a5840:	1005003a 	cmpeq	r2,r2,zero
 90a5844:	1000131e 	bne	r2,zero,90a5894 <dhc_upcall+0x4b4>
 90a5848:	e0bff617 	ldw	r2,-40(fp)
 90a584c:	00c243b4 	movhi	r3,2318
 90a5850:	18f44404 	addi	r3,r3,-12016
 90a5854:	10800f24 	muli	r2,r2,60
 90a5858:	10c5883a 	add	r2,r2,r3
 90a585c:	10800c04 	addi	r2,r2,48
 90a5860:	10c00017 	ldw	r3,0(r2)
 90a5864:	e0bffb17 	ldw	r2,-20(fp)
 90a5868:	10800717 	ldw	r2,28(r2)
 90a586c:	18800926 	beq	r3,r2,90a5894 <dhc_upcall+0x4b4>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 90a5870:	d0a09b17 	ldw	r2,-32148(gp)
 90a5874:	10800044 	addi	r2,r2,1
 90a5878:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 90a587c:	d0a09017 	ldw	r2,-32192(gp)
 90a5880:	10800044 	addi	r2,r2,1
 90a5884:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 90a5888:	00c00084 	movi	r3,2
 90a588c:	e0fffe15 	stw	r3,-8(fp)
 90a5890:	0000d806 	br	90a5bf4 <dhc_upcall+0x814>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 90a5894:	e0bff817 	ldw	r2,-32(fp)
 90a5898:	10800158 	cmpnei	r2,r2,5
 90a589c:	1000891e 	bne	r2,zero,90a5ac4 <dhc_upcall+0x6e4>
         {
            dsc_acks++;
 90a58a0:	d0a09417 	ldw	r2,-32176(gp)
 90a58a4:	10800044 	addi	r2,r2,1
 90a58a8:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 90a58ac:	e0bffa17 	ldw	r2,-24(fp)
 90a58b0:	10803b04 	addi	r2,r2,236
 90a58b4:	11400104 	addi	r5,r2,4
 90a58b8:	e13ff617 	ldw	r4,-40(fp)
 90a58bc:	90a74e40 	call	90a74e4 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 90a58c0:	e0bff617 	ldw	r2,-40(fp)
 90a58c4:	00c243b4 	movhi	r3,2318
 90a58c8:	18f44404 	addi	r3,r3,-12016
 90a58cc:	10800f24 	muli	r2,r2,60
 90a58d0:	10c5883a 	add	r2,r2,r3
 90a58d4:	10800504 	addi	r2,r2,20
 90a58d8:	10800017 	ldw	r2,0(r2)
 90a58dc:	10bfffd8 	cmpnei	r2,r2,-1
 90a58e0:	1000111e 	bne	r2,zero,90a5928 <dhc_upcall+0x548>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 90a58e4:	e0bff617 	ldw	r2,-40(fp)
 90a58e8:	00c243b4 	movhi	r3,2318
 90a58ec:	18f44404 	addi	r3,r3,-12016
 90a58f0:	10800f24 	muli	r2,r2,60
 90a58f4:	10c5883a 	add	r2,r2,r3
 90a58f8:	10c00604 	addi	r3,r2,24
 90a58fc:	00bfffc4 	movi	r2,-1
 90a5900:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 90a5904:	e0bff617 	ldw	r2,-40(fp)
 90a5908:	00c243b4 	movhi	r3,2318
 90a590c:	18f44404 	addi	r3,r3,-12016
 90a5910:	10800f24 	muli	r2,r2,60
 90a5914:	10c5883a 	add	r2,r2,r3
 90a5918:	10c00704 	addi	r3,r2,28
 90a591c:	00bfffc4 	movi	r2,-1
 90a5920:	18800015 	stw	r2,0(r3)
 90a5924:	00001f06 	br	90a59a4 <dhc_upcall+0x5c4>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 90a5928:	e17ff617 	ldw	r5,-40(fp)
 90a592c:	e0bff617 	ldw	r2,-40(fp)
 90a5930:	00c243b4 	movhi	r3,2318
 90a5934:	18f44404 	addi	r3,r3,-12016
 90a5938:	10800f24 	muli	r2,r2,60
 90a593c:	10c5883a 	add	r2,r2,r3
 90a5940:	10800504 	addi	r2,r2,20
 90a5944:	10800017 	ldw	r2,0(r2)
 90a5948:	1008d07a 	srli	r4,r2,1
 90a594c:	00c243b4 	movhi	r3,2318
 90a5950:	18f44404 	addi	r3,r3,-12016
 90a5954:	28800f24 	muli	r2,r5,60
 90a5958:	10c5883a 	add	r2,r2,r3
 90a595c:	10800604 	addi	r2,r2,24
 90a5960:	11000015 	stw	r4,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 90a5964:	e17ff617 	ldw	r5,-40(fp)
 90a5968:	e0bff617 	ldw	r2,-40(fp)
 90a596c:	00c243b4 	movhi	r3,2318
 90a5970:	18f44404 	addi	r3,r3,-12016
 90a5974:	10800f24 	muli	r2,r2,60
 90a5978:	10c5883a 	add	r2,r2,r3
 90a597c:	10800504 	addi	r2,r2,20
 90a5980:	10800017 	ldw	r2,0(r2)
 90a5984:	1004d0fa 	srli	r2,r2,3
 90a5988:	110001e4 	muli	r4,r2,7
 90a598c:	00c243b4 	movhi	r3,2318
 90a5990:	18f44404 	addi	r3,r3,-12016
 90a5994:	28800f24 	muli	r2,r5,60
 90a5998:	10c5883a 	add	r2,r2,r3
 90a599c:	10800704 	addi	r2,r2,28
 90a59a0:	11000015 	stw	r4,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 90a59a4:	e13ff617 	ldw	r4,-40(fp)
 90a59a8:	00824374 	movhi	r2,2317
 90a59ac:	108c4204 	addi	r2,r2,12552
 90a59b0:	11400017 	ldw	r5,0(r2)
 90a59b4:	00c243b4 	movhi	r3,2318
 90a59b8:	18f44404 	addi	r3,r3,-12016
 90a59bc:	20800f24 	muli	r2,r4,60
 90a59c0:	10c5883a 	add	r2,r2,r3
 90a59c4:	10800804 	addi	r2,r2,32
 90a59c8:	11400015 	stw	r5,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 90a59cc:	e43ff617 	ldw	r16,-40(fp)
 90a59d0:	e0bffa17 	ldw	r2,-24(fp)
 90a59d4:	10803b04 	addi	r2,r2,236
 90a59d8:	11000104 	addi	r4,r2,4
 90a59dc:	90a52500 	call	90a5250 <dhc_get_srv_ipaddr>
 90a59e0:	1009883a 	mov	r4,r2
 90a59e4:	00c243b4 	movhi	r3,2318
 90a59e8:	18f44404 	addi	r3,r3,-12016
 90a59ec:	80800f24 	muli	r2,r16,60
 90a59f0:	10c5883a 	add	r2,r2,r3
 90a59f4:	10800d04 	addi	r2,r2,52
 90a59f8:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 90a59fc:	e0bff617 	ldw	r2,-40(fp)
 90a5a00:	00c243b4 	movhi	r3,2318
 90a5a04:	18f44404 	addi	r3,r3,-12016
 90a5a08:	10800f24 	muli	r2,r2,60
 90a5a0c:	10c5883a 	add	r2,r2,r3
 90a5a10:	10800d04 	addi	r2,r2,52
 90a5a14:	10800017 	ldw	r2,0(r2)
 90a5a18:	1004c03a 	cmpne	r2,r2,zero
 90a5a1c:	10000d1e 	bne	r2,zero,90a5a54 <dhc_upcall+0x674>
            {
               dtrap(); /* didn't receive server-identifier option */
 90a5a20:	90a94880 	call	90a9488 <dtrap>
               dsc_errors++;
 90a5a24:	d0a09017 	ldw	r2,-32192(gp)
 90a5a28:	10800044 	addi	r2,r2,1
 90a5a2c:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 90a5a30:	e13ff617 	ldw	r4,-40(fp)
 90a5a34:	e0bffb17 	ldw	r2,-20(fp)
 90a5a38:	11400717 	ldw	r5,28(r2)
 90a5a3c:	00c243b4 	movhi	r3,2318
 90a5a40:	18f44404 	addi	r3,r3,-12016
 90a5a44:	20800f24 	muli	r2,r4,60
 90a5a48:	10c5883a 	add	r2,r2,r3
 90a5a4c:	10800d04 	addi	r2,r2,52
 90a5a50:	11400015 	stw	r5,0(r2)
            }
            if (bp->hops)
 90a5a54:	e0bffa17 	ldw	r2,-24(fp)
 90a5a58:	108000c3 	ldbu	r2,3(r2)
 90a5a5c:	10803fcc 	andi	r2,r2,255
 90a5a60:	1005003a 	cmpeq	r2,r2,zero
 90a5a64:	10000a1e 	bne	r2,zero,90a5a90 <dhc_upcall+0x6b0>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 90a5a68:	e13ff617 	ldw	r4,-40(fp)
 90a5a6c:	e0bffb17 	ldw	r2,-20(fp)
 90a5a70:	11400717 	ldw	r5,28(r2)
 90a5a74:	00c243b4 	movhi	r3,2318
 90a5a78:	18f44404 	addi	r3,r3,-12016
 90a5a7c:	20800f24 	muli	r2,r4,60
 90a5a80:	10c5883a 	add	r2,r2,r3
 90a5a84:	10800c04 	addi	r2,r2,48
 90a5a88:	11400015 	stw	r5,0(r2)
 90a5a8c:	00000706 	br	90a5aac <dhc_upcall+0x6cc>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 90a5a90:	e0bff617 	ldw	r2,-40(fp)
 90a5a94:	00c243b4 	movhi	r3,2318
 90a5a98:	18f44404 	addi	r3,r3,-12016
 90a5a9c:	10800f24 	muli	r2,r2,60
 90a5aa0:	10c5883a 	add	r2,r2,r3
 90a5aa4:	10800c04 	addi	r2,r2,48
 90a5aa8:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 90a5aac:	e13ff617 	ldw	r4,-40(fp)
 90a5ab0:	90a6f9c0 	call	90a6f9c <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 90a5ab4:	e13ff617 	ldw	r4,-40(fp)
 90a5ab8:	01400184 	movi	r5,6
 90a5abc:	90a84380 	call	90a8438 <dhc_set_state>
 90a5ac0:	00004906 	br	90a5be8 <dhc_upcall+0x808>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 90a5ac4:	e0bff817 	ldw	r2,-32(fp)
 90a5ac8:	10800198 	cmpnei	r2,r2,6
 90a5acc:	1000071e 	bne	r2,zero,90a5aec <dhc_upcall+0x70c>
         {
            dhc_set_state(iface,DHCS_INIT);
 90a5ad0:	e13ff617 	ldw	r4,-40(fp)
 90a5ad4:	01400044 	movi	r5,1
 90a5ad8:	90a84380 	call	90a8438 <dhc_set_state>
            dsc_naks++;
 90a5adc:	d0a09817 	ldw	r2,-32160(gp)
 90a5ae0:	10800044 	addi	r2,r2,1
 90a5ae4:	d0a09815 	stw	r2,-32160(gp)
 90a5ae8:	00003f06 	br	90a5be8 <dhc_upcall+0x808>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 90a5aec:	e0bff617 	ldw	r2,-40(fp)
 90a5af0:	00c243b4 	movhi	r3,2318
 90a5af4:	18f44404 	addi	r3,r3,-12016
 90a5af8:	10800f24 	muli	r2,r2,60
 90a5afc:	10c5883a 	add	r2,r2,r3
 90a5b00:	10800017 	ldw	r2,0(r2)
 90a5b04:	10800158 	cmpnei	r2,r2,5
 90a5b08:	1000091e 	bne	r2,zero,90a5b30 <dhc_upcall+0x750>
 90a5b0c:	e0bff817 	ldw	r2,-32(fp)
 90a5b10:	10800098 	cmpnei	r2,r2,2
 90a5b14:	1000061e 	bne	r2,zero,90a5b30 <dhc_upcall+0x750>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 90a5b18:	d0a09217 	ldw	r2,-32184(gp)
 90a5b1c:	10800044 	addi	r2,r2,1
 90a5b20:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 90a5b24:	01000084 	movi	r4,2
 90a5b28:	e13ffe15 	stw	r4,-8(fp)
 90a5b2c:	00003106 	br	90a5bf4 <dhc_upcall+0x814>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 90a5b30:	d0a09017 	ldw	r2,-32192(gp)
 90a5b34:	10800044 	addi	r2,r2,1
 90a5b38:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 90a5b3c:	00800084 	movi	r2,2
 90a5b40:	e0bffe15 	stw	r2,-8(fp)
 90a5b44:	00002b06 	br	90a5bf4 <dhc_upcall+0x814>
         }
         break;
      default:    /* bad state */
         dtrap();
 90a5b48:	90a94880 	call	90a9488 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 90a5b4c:	e13ff617 	ldw	r4,-40(fp)
 90a5b50:	01400044 	movi	r5,1
 90a5b54:	90a84380 	call	90a8438 <dhc_set_state>
         dsc_errors++;
 90a5b58:	d0a09017 	ldw	r2,-32192(gp)
 90a5b5c:	10800044 	addi	r2,r2,1
 90a5b60:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 90a5b64:	00ffffc4 	movi	r3,-1
 90a5b68:	e0fffe15 	stw	r3,-8(fp)
 90a5b6c:	00002106 	br	90a5bf4 <dhc_upcall+0x814>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 90a5b70:	d0a09517 	ldw	r2,-32172(gp)
 90a5b74:	10800044 	addi	r2,r2,1
 90a5b78:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 90a5b7c:	e0bffa17 	ldw	r2,-24(fp)
 90a5b80:	10803b04 	addi	r2,r2,236
 90a5b84:	11400104 	addi	r5,r2,4
 90a5b88:	e13ff617 	ldw	r4,-40(fp)
 90a5b8c:	90a74e40 	call	90a74e4 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 90a5b90:	e13ff617 	ldw	r4,-40(fp)
 90a5b94:	e0bffa17 	ldw	r2,-24(fp)
 90a5b98:	11400417 	ldw	r5,16(r2)
 90a5b9c:	00c243b4 	movhi	r3,2318
 90a5ba0:	18f44404 	addi	r3,r3,-12016
 90a5ba4:	20800f24 	muli	r2,r4,60
 90a5ba8:	10c5883a 	add	r2,r2,r3
 90a5bac:	10800904 	addi	r2,r2,36
 90a5bb0:	11400015 	stw	r5,0(r2)
      dhc_setip(iface);
 90a5bb4:	e13ff617 	ldw	r4,-40(fp)
 90a5bb8:	90a6f9c0 	call	90a6f9c <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 90a5bbc:	e13ff617 	ldw	r4,-40(fp)
 90a5bc0:	01400184 	movi	r5,6
 90a5bc4:	90a84380 	call	90a8438 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 90a5bc8:	e0bff617 	ldw	r2,-40(fp)
 90a5bcc:	00c243b4 	movhi	r3,2318
 90a5bd0:	18f44404 	addi	r3,r3,-12016
 90a5bd4:	10800f24 	muli	r2,r2,60
 90a5bd8:	10c5883a 	add	r2,r2,r3
 90a5bdc:	10c00604 	addi	r3,r2,24
 90a5be0:	00bfffc4 	movi	r2,-1
 90a5be4:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 90a5be8:	e13ffb17 	ldw	r4,-20(fp)
 90a5bec:	90c3c740 	call	90c3c74 <udp_free>
   return 0;
 90a5bf0:	e03ffe15 	stw	zero,-8(fp)
 90a5bf4:	e0bffe17 	ldw	r2,-8(fp)
}
 90a5bf8:	e037883a 	mov	sp,fp
 90a5bfc:	dfc00217 	ldw	ra,8(sp)
 90a5c00:	df000117 	ldw	fp,4(sp)
 90a5c04:	dc000017 	ldw	r16,0(sp)
 90a5c08:	dec00304 	addi	sp,sp,12
 90a5c0c:	f800283a 	ret

090a5c10 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 90a5c10:	defff804 	addi	sp,sp,-32
 90a5c14:	dfc00715 	stw	ra,28(sp)
 90a5c18:	df000615 	stw	fp,24(sp)
 90a5c1c:	df000604 	addi	fp,sp,24
 90a5c20:	e13ffb15 	stw	r4,-20(fp)
 90a5c24:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 90a5c28:	e0bffc17 	ldw	r2,-16(fp)
 90a5c2c:	1009883a 	mov	r4,r2
 90a5c30:	01804b04 	movi	r6,300
 90a5c34:	000b883a 	mov	r5,zero
 90a5c38:	90823f80 	call	90823f8 <memset>
   outbp->op = BOOTREQUEST;
 90a5c3c:	e0fffc17 	ldw	r3,-16(fp)
 90a5c40:	00800044 	movi	r2,1
 90a5c44:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 90a5c48:	e0bffb17 	ldw	r2,-20(fp)
 90a5c4c:	00c243b4 	movhi	r3,2318
 90a5c50:	18f41e04 	addi	r3,r3,-12168
 90a5c54:	1085883a 	add	r2,r2,r2
 90a5c58:	1085883a 	add	r2,r2,r2
 90a5c5c:	10c5883a 	add	r2,r2,r3
 90a5c60:	10800017 	ldw	r2,0(r2)
 90a5c64:	10802717 	ldw	r2,156(r2)
 90a5c68:	10800217 	ldw	r2,8(r2)
 90a5c6c:	e0bfff15 	stw	r2,-4(fp)
 90a5c70:	e0ffff17 	ldw	r3,-4(fp)
 90a5c74:	188005e0 	cmpeqi	r2,r3,23
 90a5c78:	10000b1e 	bne	r2,zero,90a5ca8 <dhc_buildheader+0x98>
 90a5c7c:	e0ffff17 	ldw	r3,-4(fp)
 90a5c80:	18800720 	cmpeqi	r2,r3,28
 90a5c84:	1000081e 	bne	r2,zero,90a5ca8 <dhc_buildheader+0x98>
 90a5c88:	e0ffff17 	ldw	r3,-4(fp)
 90a5c8c:	188001a0 	cmpeqi	r2,r3,6
 90a5c90:	1000011e 	bne	r2,zero,90a5c98 <dhc_buildheader+0x88>
 90a5c94:	00000806 	br	90a5cb8 <dhc_buildheader+0xa8>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 90a5c98:	e0fffc17 	ldw	r3,-16(fp)
 90a5c9c:	00800044 	movi	r2,1
 90a5ca0:	18800045 	stb	r2,1(r3)
   break;
 90a5ca4:	00000806 	br	90a5cc8 <dhc_buildheader+0xb8>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 90a5ca8:	e0fffc17 	ldw	r3,-16(fp)
 90a5cac:	00800504 	movi	r2,20
 90a5cb0:	18800045 	stb	r2,1(r3)
   break;
 90a5cb4:	00000406 	br	90a5cc8 <dhc_buildheader+0xb8>
      default:
      dtrap();
 90a5cb8:	90a94880 	call	90a9488 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 90a5cbc:	00bffd44 	movi	r2,-11
 90a5cc0:	e0bffe15 	stw	r2,-8(fp)
 90a5cc4:	00005306 	br	90a5e14 <dhc_buildheader+0x204>
   }

   addrlen = min(16, nets[iface]->n_hal);
 90a5cc8:	e0bffb17 	ldw	r2,-20(fp)
 90a5ccc:	00c243b4 	movhi	r3,2318
 90a5cd0:	18f41e04 	addi	r3,r3,-12168
 90a5cd4:	1085883a 	add	r2,r2,r2
 90a5cd8:	1085883a 	add	r2,r2,r2
 90a5cdc:	10c5883a 	add	r2,r2,r3
 90a5ce0:	10800017 	ldw	r2,0(r2)
 90a5ce4:	10801117 	ldw	r2,68(r2)
 90a5ce8:	e0bffd15 	stw	r2,-12(fp)
 90a5cec:	e0fffd17 	ldw	r3,-12(fp)
 90a5cf0:	18800470 	cmpltui	r2,r3,17
 90a5cf4:	1000021e 	bne	r2,zero,90a5d00 <dhc_buildheader+0xf0>
 90a5cf8:	00800404 	movi	r2,16
 90a5cfc:	e0bffd15 	stw	r2,-12(fp)
 90a5d00:	e0fffd17 	ldw	r3,-12(fp)
 90a5d04:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 90a5d08:	e0bffa17 	ldw	r2,-24(fp)
 90a5d0c:	1007883a 	mov	r3,r2
 90a5d10:	e0bffc17 	ldw	r2,-16(fp)
 90a5d14:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 90a5d18:	e0bffc17 	ldw	r2,-16(fp)
 90a5d1c:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 90a5d20:	e0bffb17 	ldw	r2,-20(fp)
 90a5d24:	00c243b4 	movhi	r3,2318
 90a5d28:	18f44404 	addi	r3,r3,-12016
 90a5d2c:	10800f24 	muli	r2,r2,60
 90a5d30:	10c5883a 	add	r2,r2,r3
 90a5d34:	10800017 	ldw	r2,0(r2)
 90a5d38:	108001d8 	cmpnei	r2,r2,7
 90a5d3c:	1000031e 	bne	r2,zero,90a5d4c <dhc_buildheader+0x13c>
      outbp->flags = 0; /* Renewing needs unicast */
 90a5d40:	e0bffc17 	ldw	r2,-16(fp)
 90a5d44:	1000028d 	sth	zero,10(r2)
 90a5d48:	00000306 	br	90a5d58 <dhc_buildheader+0x148>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 90a5d4c:	e0fffc17 	ldw	r3,-16(fp)
 90a5d50:	00802004 	movi	r2,128
 90a5d54:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 90a5d58:	e0bffb17 	ldw	r2,-20(fp)
 90a5d5c:	00c243b4 	movhi	r3,2318
 90a5d60:	18f44404 	addi	r3,r3,-12016
 90a5d64:	10800f24 	muli	r2,r2,60
 90a5d68:	10c5883a 	add	r2,r2,r3
 90a5d6c:	10800204 	addi	r2,r2,8
 90a5d70:	10c00017 	ldw	r3,0(r2)
 90a5d74:	e0bffc17 	ldw	r2,-16(fp)
 90a5d78:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 90a5d7c:	e0bffb17 	ldw	r2,-20(fp)
 90a5d80:	00c243b4 	movhi	r3,2318
 90a5d84:	18f44404 	addi	r3,r3,-12016
 90a5d88:	10800f24 	muli	r2,r2,60
 90a5d8c:	10c5883a 	add	r2,r2,r3
 90a5d90:	10800304 	addi	r2,r2,12
 90a5d94:	10c0000b 	ldhu	r3,0(r2)
 90a5d98:	e0bffc17 	ldw	r2,-16(fp)
 90a5d9c:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 90a5da0:	e0bffb17 	ldw	r2,-20(fp)
 90a5da4:	00c243b4 	movhi	r3,2318
 90a5da8:	18f41e04 	addi	r3,r3,-12168
 90a5dac:	1085883a 	add	r2,r2,r2
 90a5db0:	1085883a 	add	r2,r2,r2
 90a5db4:	10c5883a 	add	r2,r2,r3
 90a5db8:	10800017 	ldw	r2,0(r2)
 90a5dbc:	10801717 	ldw	r2,92(r2)
 90a5dc0:	1004c03a 	cmpne	r2,r2,zero
 90a5dc4:	1000041e 	bne	r2,zero,90a5dd8 <dhc_buildheader+0x1c8>
   {
      dtrap();
 90a5dc8:	90a94880 	call	90a9488 <dtrap>
      return ENP_LOGIC;
 90a5dcc:	00bffd44 	movi	r2,-11
 90a5dd0:	e0bffe15 	stw	r2,-8(fp)
 90a5dd4:	00000f06 	br	90a5e14 <dhc_buildheader+0x204>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 90a5dd8:	e0bffc17 	ldw	r2,-16(fp)
 90a5ddc:	11000704 	addi	r4,r2,28
 90a5de0:	e0bffb17 	ldw	r2,-20(fp)
 90a5de4:	00c243b4 	movhi	r3,2318
 90a5de8:	18f41e04 	addi	r3,r3,-12168
 90a5dec:	1085883a 	add	r2,r2,r2
 90a5df0:	1085883a 	add	r2,r2,r2
 90a5df4:	10c5883a 	add	r2,r2,r3
 90a5df8:	10800017 	ldw	r2,0(r2)
 90a5dfc:	10801717 	ldw	r2,92(r2)
 90a5e00:	e0fffa17 	ldw	r3,-24(fp)
 90a5e04:	100b883a 	mov	r5,r2
 90a5e08:	180d883a 	mov	r6,r3
 90a5e0c:	90822780 	call	9082278 <memcpy>

   /* return success */
   return 0;
 90a5e10:	e03ffe15 	stw	zero,-8(fp)
 90a5e14:	e0bffe17 	ldw	r2,-8(fp)
}
 90a5e18:	e037883a 	mov	sp,fp
 90a5e1c:	dfc00117 	ldw	ra,4(sp)
 90a5e20:	df000017 	ldw	fp,0(sp)
 90a5e24:	dec00204 	addi	sp,sp,8
 90a5e28:	f800283a 	ret

090a5e2c <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 90a5e2c:	defff204 	addi	sp,sp,-56
 90a5e30:	dfc00d15 	stw	ra,52(sp)
 90a5e34:	df000c15 	stw	fp,48(sp)
 90a5e38:	dc000b15 	stw	r16,44(sp)
 90a5e3c:	df000b04 	addi	fp,sp,44
 90a5e40:	e13ffc15 	stw	r4,-16(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 90a5e44:	01004b04 	movi	r4,300
 90a5e48:	000b883a 	mov	r5,zero
 90a5e4c:	90c3b880 	call	90c3b88 <udp_alloc>
 90a5e50:	e0bff915 	stw	r2,-28(fp)
   if (!pkt) 
 90a5e54:	e0bff917 	ldw	r2,-28(fp)
 90a5e58:	1004c03a 	cmpne	r2,r2,zero
 90a5e5c:	1000031e 	bne	r2,zero,90a5e6c <dhc_discover+0x40>
      return ENP_NOMEM;
 90a5e60:	00bffb04 	movi	r2,-20
 90a5e64:	e0bffd15 	stw	r2,-12(fp)
 90a5e68:	00013506 	br	90a6340 <dhc_discover+0x514>
   pkt->nb_plen = sizeof(struct bootp);
 90a5e6c:	e0fff917 	ldw	r3,-28(fp)
 90a5e70:	00804b04 	movi	r2,300
 90a5e74:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 90a5e78:	e0bffc17 	ldw	r2,-16(fp)
 90a5e7c:	d1203117 	ldw	r4,-32572(gp)
 90a5e80:	200b883a 	mov	r5,r4
 90a5e84:	00c243b4 	movhi	r3,2318
 90a5e88:	18f44404 	addi	r3,r3,-12016
 90a5e8c:	10800f24 	muli	r2,r2,60
 90a5e90:	10c5883a 	add	r2,r2,r3
 90a5e94:	10800204 	addi	r2,r2,8
 90a5e98:	11400015 	stw	r5,0(r2)
 90a5e9c:	20800044 	addi	r2,r4,1
 90a5ea0:	d0a03115 	stw	r2,-32572(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 90a5ea4:	e43ffc17 	ldw	r16,-16(fp)
 90a5ea8:	90baf240 	call	90baf24 <sysuptime>
 90a5eac:	1007883a 	mov	r3,r2
 90a5eb0:	00947b34 	movhi	r2,20972
 90a5eb4:	10a147c4 	addi	r2,r2,-31457
 90a5eb8:	1889383a 	mul	r4,r3,r2
 90a5ebc:	e13ffe15 	stw	r4,-8(fp)
 90a5ec0:	1886383a 	mulxuu	r3,r3,r2
 90a5ec4:	e0ffff15 	stw	r3,-4(fp)
 90a5ec8:	e0ffff17 	ldw	r3,-4(fp)
 90a5ecc:	1804d17a 	srli	r2,r3,5
 90a5ed0:	1009883a 	mov	r4,r2
 90a5ed4:	00c243b4 	movhi	r3,2318
 90a5ed8:	18f44404 	addi	r3,r3,-12016
 90a5edc:	80800f24 	muli	r2,r16,60
 90a5ee0:	10c5883a 	add	r2,r2,r3
 90a5ee4:	10800304 	addi	r2,r2,12
 90a5ee8:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 90a5eec:	e0bff917 	ldw	r2,-28(fp)
 90a5ef0:	10800317 	ldw	r2,12(r2)
 90a5ef4:	e0bff815 	stw	r2,-32(fp)
   e = dhc_buildheader(iface,outbp);
 90a5ef8:	e13ffc17 	ldw	r4,-16(fp)
 90a5efc:	e17ff817 	ldw	r5,-32(fp)
 90a5f00:	90a5c100 	call	90a5c10 <dhc_buildheader>
 90a5f04:	e0bff615 	stw	r2,-40(fp)
   if (e)
 90a5f08:	e0bff617 	ldw	r2,-40(fp)
 90a5f0c:	1005003a 	cmpeq	r2,r2,zero
 90a5f10:	1000031e 	bne	r2,zero,90a5f20 <dhc_discover+0xf4>
      return e;
 90a5f14:	e13ff617 	ldw	r4,-40(fp)
 90a5f18:	e13ffd15 	stw	r4,-12(fp)
 90a5f1c:	00010806 	br	90a6340 <dhc_discover+0x514>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 90a5f20:	e0bff817 	ldw	r2,-32(fp)
 90a5f24:	10803b04 	addi	r2,r2,236
 90a5f28:	1007883a 	mov	r3,r2
 90a5f2c:	0098d534 	movhi	r2,25428
 90a5f30:	10a098c4 	addi	r2,r2,-32157
 90a5f34:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 90a5f38:	e0bff817 	ldw	r2,-32(fp)
 90a5f3c:	10803b04 	addi	r2,r2,236
 90a5f40:	10800104 	addi	r2,r2,4
 90a5f44:	e0bff715 	stw	r2,-36(fp)
   *opts++ = DHOP_TYPE;
 90a5f48:	e0fff717 	ldw	r3,-36(fp)
 90a5f4c:	00800d44 	movi	r2,53
 90a5f50:	18800005 	stb	r2,0(r3)
 90a5f54:	e0bff717 	ldw	r2,-36(fp)
 90a5f58:	10800044 	addi	r2,r2,1
 90a5f5c:	e0bff715 	stw	r2,-36(fp)
   *opts++ = 1;   /* length of option field */
 90a5f60:	e0fff717 	ldw	r3,-36(fp)
 90a5f64:	00800044 	movi	r2,1
 90a5f68:	18800005 	stb	r2,0(r3)
 90a5f6c:	e0bff717 	ldw	r2,-36(fp)
 90a5f70:	10800044 	addi	r2,r2,1
 90a5f74:	e0bff715 	stw	r2,-36(fp)
   *opts++ = DHCP_DISCOVER;
 90a5f78:	e0fff717 	ldw	r3,-36(fp)
 90a5f7c:	00800044 	movi	r2,1
 90a5f80:	18800005 	stb	r2,0(r3)
 90a5f84:	e0bff717 	ldw	r2,-36(fp)
 90a5f88:	10800044 	addi	r2,r2,1
 90a5f8c:	e0bff715 	stw	r2,-36(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 90a5f90:	00bfffc4 	movi	r2,-1
 90a5f94:	e0bffa15 	stw	r2,-24(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 90a5f98:	e0fff717 	ldw	r3,-36(fp)
 90a5f9c:	00800cc4 	movi	r2,51
 90a5fa0:	18800005 	stb	r2,0(r3)
 90a5fa4:	e0bff717 	ldw	r2,-36(fp)
 90a5fa8:	10800044 	addi	r2,r2,1
 90a5fac:	e0bff715 	stw	r2,-36(fp)
 90a5fb0:	e0fff717 	ldw	r3,-36(fp)
 90a5fb4:	00800104 	movi	r2,4
 90a5fb8:	18800005 	stb	r2,0(r3)
 90a5fbc:	e0bff717 	ldw	r2,-36(fp)
 90a5fc0:	10800044 	addi	r2,r2,1
 90a5fc4:	e0bff715 	stw	r2,-36(fp)
 90a5fc8:	e0bff717 	ldw	r2,-36(fp)
 90a5fcc:	10c000c4 	addi	r3,r2,3
 90a5fd0:	e0bffa04 	addi	r2,fp,-24
 90a5fd4:	10800003 	ldbu	r2,0(r2)
 90a5fd8:	18800005 	stb	r2,0(r3)
 90a5fdc:	e0bff717 	ldw	r2,-36(fp)
 90a5fe0:	10c00084 	addi	r3,r2,2
 90a5fe4:	e0bffa04 	addi	r2,fp,-24
 90a5fe8:	10800044 	addi	r2,r2,1
 90a5fec:	10800003 	ldbu	r2,0(r2)
 90a5ff0:	18800005 	stb	r2,0(r3)
 90a5ff4:	e0bff717 	ldw	r2,-36(fp)
 90a5ff8:	10c00044 	addi	r3,r2,1
 90a5ffc:	e0bffa04 	addi	r2,fp,-24
 90a6000:	10800084 	addi	r2,r2,2
 90a6004:	10800003 	ldbu	r2,0(r2)
 90a6008:	18800005 	stb	r2,0(r3)
 90a600c:	e0bffa04 	addi	r2,fp,-24
 90a6010:	108000c4 	addi	r2,r2,3
 90a6014:	10800003 	ldbu	r2,0(r2)
 90a6018:	1007883a 	mov	r3,r2
 90a601c:	e0bff717 	ldw	r2,-36(fp)
 90a6020:	10c00005 	stb	r3,0(r2)
 90a6024:	e0bff717 	ldw	r2,-36(fp)
 90a6028:	10800104 	addi	r2,r2,4
 90a602c:	e0bff715 	stw	r2,-36(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 90a6030:	e0bffc17 	ldw	r2,-16(fp)
 90a6034:	00c243b4 	movhi	r3,2318
 90a6038:	18f41e04 	addi	r3,r3,-12168
 90a603c:	1085883a 	add	r2,r2,r2
 90a6040:	1085883a 	add	r2,r2,r2
 90a6044:	10c5883a 	add	r2,r2,r3
 90a6048:	10800017 	ldw	r2,0(r2)
 90a604c:	10800a17 	ldw	r2,40(r2)
 90a6050:	1005003a 	cmpeq	r2,r2,zero
 90a6054:	1000521e 	bne	r2,zero,90a61a0 <dhc_discover+0x374>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 90a6058:	e0bffc17 	ldw	r2,-16(fp)
 90a605c:	00c243b4 	movhi	r3,2318
 90a6060:	18f41e04 	addi	r3,r3,-12168
 90a6064:	1085883a 	add	r2,r2,r2
 90a6068:	1085883a 	add	r2,r2,r2
 90a606c:	10c5883a 	add	r2,r2,r3
 90a6070:	10800017 	ldw	r2,0(r2)
 90a6074:	10800a17 	ldw	r2,40(r2)
 90a6078:	1004d63a 	srli	r2,r2,24
 90a607c:	11003fcc 	andi	r4,r2,255
 90a6080:	e0bffc17 	ldw	r2,-16(fp)
 90a6084:	00c243b4 	movhi	r3,2318
 90a6088:	18f41e04 	addi	r3,r3,-12168
 90a608c:	1085883a 	add	r2,r2,r2
 90a6090:	1085883a 	add	r2,r2,r2
 90a6094:	10c5883a 	add	r2,r2,r3
 90a6098:	10800017 	ldw	r2,0(r2)
 90a609c:	10800a17 	ldw	r2,40(r2)
 90a60a0:	1004d23a 	srli	r2,r2,8
 90a60a4:	10bfc00c 	andi	r2,r2,65280
 90a60a8:	2088b03a 	or	r4,r4,r2
 90a60ac:	e0bffc17 	ldw	r2,-16(fp)
 90a60b0:	00c243b4 	movhi	r3,2318
 90a60b4:	18f41e04 	addi	r3,r3,-12168
 90a60b8:	1085883a 	add	r2,r2,r2
 90a60bc:	1085883a 	add	r2,r2,r2
 90a60c0:	10c5883a 	add	r2,r2,r3
 90a60c4:	10800017 	ldw	r2,0(r2)
 90a60c8:	10800a17 	ldw	r2,40(r2)
 90a60cc:	10bfc00c 	andi	r2,r2,65280
 90a60d0:	1004923a 	slli	r2,r2,8
 90a60d4:	2088b03a 	or	r4,r4,r2
 90a60d8:	e0bffc17 	ldw	r2,-16(fp)
 90a60dc:	00c243b4 	movhi	r3,2318
 90a60e0:	18f41e04 	addi	r3,r3,-12168
 90a60e4:	1085883a 	add	r2,r2,r2
 90a60e8:	1085883a 	add	r2,r2,r2
 90a60ec:	10c5883a 	add	r2,r2,r3
 90a60f0:	10800017 	ldw	r2,0(r2)
 90a60f4:	10800a17 	ldw	r2,40(r2)
 90a60f8:	10803fcc 	andi	r2,r2,255
 90a60fc:	1004963a 	slli	r2,r2,24
 90a6100:	2084b03a 	or	r2,r4,r2
 90a6104:	e0bffb15 	stw	r2,-20(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 90a6108:	e0fff717 	ldw	r3,-36(fp)
 90a610c:	00800c84 	movi	r2,50
 90a6110:	18800005 	stb	r2,0(r3)
 90a6114:	e0bff717 	ldw	r2,-36(fp)
 90a6118:	10800044 	addi	r2,r2,1
 90a611c:	e0bff715 	stw	r2,-36(fp)
 90a6120:	e0fff717 	ldw	r3,-36(fp)
 90a6124:	00800104 	movi	r2,4
 90a6128:	18800005 	stb	r2,0(r3)
 90a612c:	e0bff717 	ldw	r2,-36(fp)
 90a6130:	10800044 	addi	r2,r2,1
 90a6134:	e0bff715 	stw	r2,-36(fp)
 90a6138:	e0bff717 	ldw	r2,-36(fp)
 90a613c:	10c000c4 	addi	r3,r2,3
 90a6140:	e0bffb04 	addi	r2,fp,-20
 90a6144:	10800003 	ldbu	r2,0(r2)
 90a6148:	18800005 	stb	r2,0(r3)
 90a614c:	e0bff717 	ldw	r2,-36(fp)
 90a6150:	10c00084 	addi	r3,r2,2
 90a6154:	e0bffb04 	addi	r2,fp,-20
 90a6158:	10800044 	addi	r2,r2,1
 90a615c:	10800003 	ldbu	r2,0(r2)
 90a6160:	18800005 	stb	r2,0(r3)
 90a6164:	e0bff717 	ldw	r2,-36(fp)
 90a6168:	10c00044 	addi	r3,r2,1
 90a616c:	e0bffb04 	addi	r2,fp,-20
 90a6170:	10800084 	addi	r2,r2,2
 90a6174:	10800003 	ldbu	r2,0(r2)
 90a6178:	18800005 	stb	r2,0(r3)
 90a617c:	e0bffb04 	addi	r2,fp,-20
 90a6180:	108000c4 	addi	r2,r2,3
 90a6184:	10800003 	ldbu	r2,0(r2)
 90a6188:	1007883a 	mov	r3,r2
 90a618c:	e0bff717 	ldw	r2,-36(fp)
 90a6190:	10c00005 	stb	r3,0(r2)
 90a6194:	e0bff717 	ldw	r2,-36(fp)
 90a6198:	10800104 	addi	r2,r2,4
 90a619c:	e0bff715 	stw	r2,-36(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 90a61a0:	d0a03317 	ldw	r2,-32564(gp)
 90a61a4:	10800050 	cmplti	r2,r2,1
 90a61a8:	10001e1e 	bne	r2,zero,90a6224 <dhc_discover+0x3f8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 90a61ac:	e0fff717 	ldw	r3,-36(fp)
 90a61b0:	00800dc4 	movi	r2,55
 90a61b4:	18800005 	stb	r2,0(r3)
 90a61b8:	e0bff717 	ldw	r2,-36(fp)
 90a61bc:	10800044 	addi	r2,r2,1
 90a61c0:	e0bff715 	stw	r2,-36(fp)
      *opts++ = (u_char)reqlist_len ;
 90a61c4:	d0a03317 	ldw	r2,-32564(gp)
 90a61c8:	1007883a 	mov	r3,r2
 90a61cc:	e0bff717 	ldw	r2,-36(fp)
 90a61d0:	10c00005 	stb	r3,0(r2)
 90a61d4:	e0bff717 	ldw	r2,-36(fp)
 90a61d8:	10800044 	addi	r2,r2,1
 90a61dc:	e0bff715 	stw	r2,-36(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 90a61e0:	e03ff515 	stw	zero,-44(fp)
 90a61e4:	00000c06 	br	90a6218 <dhc_discover+0x3ec>
         *opts++ = reqlist[i];
 90a61e8:	e0fff517 	ldw	r3,-44(fp)
 90a61ec:	d0a03204 	addi	r2,gp,-32568
 90a61f0:	1885883a 	add	r2,r3,r2
 90a61f4:	10c00003 	ldbu	r3,0(r2)
 90a61f8:	e0bff717 	ldw	r2,-36(fp)
 90a61fc:	10c00005 	stb	r3,0(r2)
 90a6200:	e0bff717 	ldw	r2,-36(fp)
 90a6204:	10800044 	addi	r2,r2,1
 90a6208:	e0bff715 	stw	r2,-36(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 90a620c:	e0bff517 	ldw	r2,-44(fp)
 90a6210:	10800044 	addi	r2,r2,1
 90a6214:	e0bff515 	stw	r2,-44(fp)
 90a6218:	d0e03317 	ldw	r3,-32564(gp)
 90a621c:	e0bff517 	ldw	r2,-44(fp)
 90a6220:	10fff116 	blt	r2,r3,90a61e8 <dhc_discover+0x3bc>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 90a6224:	e0fff717 	ldw	r3,-36(fp)
 90a6228:	00bfffc4 	movi	r2,-1
 90a622c:	18800005 	stb	r2,0(r3)
 90a6230:	e0bff717 	ldw	r2,-36(fp)
 90a6234:	10800044 	addi	r2,r2,1
 90a6238:	e0bff715 	stw	r2,-36(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 90a623c:	e13ffc17 	ldw	r4,-16(fp)
 90a6240:	00824374 	movhi	r2,2317
 90a6244:	108c4204 	addi	r2,r2,12552
 90a6248:	11400017 	ldw	r5,0(r2)
 90a624c:	00c243b4 	movhi	r3,2318
 90a6250:	18f44404 	addi	r3,r3,-12016
 90a6254:	20800f24 	muli	r2,r4,60
 90a6258:	10c5883a 	add	r2,r2,r3
 90a625c:	10800404 	addi	r2,r2,16
 90a6260:	11400015 	stw	r5,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 90a6264:	e0fff917 	ldw	r3,-28(fp)
 90a6268:	00bfffc4 	movi	r2,-1
 90a626c:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 90a6270:	e0bffc17 	ldw	r2,-16(fp)
 90a6274:	00c243b4 	movhi	r3,2318
 90a6278:	18f41e04 	addi	r3,r3,-12168
 90a627c:	1085883a 	add	r2,r2,r2
 90a6280:	1085883a 	add	r2,r2,r2
 90a6284:	10c5883a 	add	r2,r2,r3
 90a6288:	10c00017 	ldw	r3,0(r2)
 90a628c:	e0bff917 	ldw	r2,-28(fp)
 90a6290:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 90a6294:	e0bffc17 	ldw	r2,-16(fp)
 90a6298:	00c243b4 	movhi	r3,2318
 90a629c:	18f44404 	addi	r3,r3,-12016
 90a62a0:	10800f24 	muli	r2,r2,60
 90a62a4:	10c5883a 	add	r2,r2,r3
 90a62a8:	10800017 	ldw	r2,0(r2)
 90a62ac:	10800120 	cmpeqi	r2,r2,4
 90a62b0:	1000031e 	bne	r2,zero,90a62c0 <dhc_discover+0x494>
      dhc_set_state(iface, DHCS_SELECTING);
 90a62b4:	e13ffc17 	ldw	r4,-16(fp)
 90a62b8:	01400104 	movi	r5,4
 90a62bc:	90a84380 	call	90a8438 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a62c0:	010010c4 	movi	r4,67
 90a62c4:	01401104 	movi	r5,68
 90a62c8:	e1bff917 	ldw	r6,-28(fp)
 90a62cc:	90c36d00 	call	90c36d0 <udp_send>
   dsc_discovers++;
 90a62d0:	d0a09117 	ldw	r2,-32188(gp)
 90a62d4:	10800044 	addi	r2,r2,1
 90a62d8:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 90a62dc:	e13ffc17 	ldw	r4,-16(fp)
 90a62e0:	00824374 	movhi	r2,2317
 90a62e4:	108c4204 	addi	r2,r2,12552
 90a62e8:	11400017 	ldw	r5,0(r2)
 90a62ec:	00c243b4 	movhi	r3,2318
 90a62f0:	18f44404 	addi	r3,r3,-12016
 90a62f4:	20800f24 	muli	r2,r4,60
 90a62f8:	10c5883a 	add	r2,r2,r3
 90a62fc:	10800404 	addi	r2,r2,16
 90a6300:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 90a6304:	e17ffc17 	ldw	r5,-16(fp)
 90a6308:	00c243b4 	movhi	r3,2318
 90a630c:	18f44404 	addi	r3,r3,-12016
 90a6310:	28800f24 	muli	r2,r5,60
 90a6314:	10c5883a 	add	r2,r2,r3
 90a6318:	10800104 	addi	r2,r2,4
 90a631c:	10800017 	ldw	r2,0(r2)
 90a6320:	11000044 	addi	r4,r2,1
 90a6324:	00c243b4 	movhi	r3,2318
 90a6328:	18f44404 	addi	r3,r3,-12016
 90a632c:	28800f24 	muli	r2,r5,60
 90a6330:	10c5883a 	add	r2,r2,r3
 90a6334:	10800104 	addi	r2,r2,4
 90a6338:	11000015 	stw	r4,0(r2)

   return 0;
 90a633c:	e03ffd15 	stw	zero,-12(fp)
 90a6340:	e0bffd17 	ldw	r2,-12(fp)
}
 90a6344:	e037883a 	mov	sp,fp
 90a6348:	dfc00217 	ldw	ra,8(sp)
 90a634c:	df000117 	ldw	fp,4(sp)
 90a6350:	dc000017 	ldw	r16,0(sp)
 90a6354:	dec00304 	addi	sp,sp,12
 90a6358:	f800283a 	ret

090a635c <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 90a635c:	defff804 	addi	sp,sp,-32
 90a6360:	dfc00715 	stw	ra,28(sp)
 90a6364:	df000615 	stw	fp,24(sp)
 90a6368:	df000604 	addi	fp,sp,24
 90a636c:	e13ffc15 	stw	r4,-16(fp)
 90a6370:	e17ffd15 	stw	r5,-12(fp)
 90a6374:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 90a6378:	e0bffc17 	ldw	r2,-16(fp)
 90a637c:	00c243b4 	movhi	r3,2318
 90a6380:	18f44404 	addi	r3,r3,-12016
 90a6384:	10800f24 	muli	r2,r2,60
 90a6388:	10c5883a 	add	r2,r2,r3
 90a638c:	10800204 	addi	r2,r2,8
 90a6390:	10c00017 	ldw	r3,0(r2)
 90a6394:	e0bffd17 	ldw	r2,-12(fp)
 90a6398:	10800117 	ldw	r2,4(r2)
 90a639c:	18800326 	beq	r3,r2,90a63ac <dhc_rx_offer+0x50>
      return ENP_NOT_MINE;
 90a63a0:	00800084 	movi	r2,2
 90a63a4:	e0bfff15 	stw	r2,-4(fp)
 90a63a8:	00002706 	br	90a6448 <dhc_rx_offer+0xec>

   opts = &bp->options[4];    /* examine options after cookie */
 90a63ac:	e0bffd17 	ldw	r2,-12(fp)
 90a63b0:	10803b04 	addi	r2,r2,236
 90a63b4:	10800104 	addi	r2,r2,4
 90a63b8:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 90a63bc:	e13ffc17 	ldw	r4,-16(fp)
 90a63c0:	e17ffb17 	ldw	r5,-20(fp)
 90a63c4:	90a74e40 	call	90a74e4 <dhc_extract_opts>
 90a63c8:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 90a63cc:	e0bffa17 	ldw	r2,-24(fp)
 90a63d0:	1005003a 	cmpeq	r2,r2,zero
 90a63d4:	1000041e 	bne	r2,zero,90a63e8 <dhc_rx_offer+0x8c>
   {
      dtrap();
 90a63d8:	90a94880 	call	90a9488 <dtrap>
      return e;
 90a63dc:	e0bffa17 	ldw	r2,-24(fp)
 90a63e0:	e0bfff15 	stw	r2,-4(fp)
 90a63e4:	00001806 	br	90a6448 <dhc_rx_offer+0xec>
   }
   if (!bp->yiaddr)  /* require an IP address */
 90a63e8:	e0bffd17 	ldw	r2,-12(fp)
 90a63ec:	10800417 	ldw	r2,16(r2)
 90a63f0:	1004c03a 	cmpne	r2,r2,zero
 90a63f4:	1000071e 	bne	r2,zero,90a6414 <dhc_rx_offer+0xb8>
   {
      dhc_decline(iface,bp, bplen);
 90a63f8:	e13ffc17 	ldw	r4,-16(fp)
 90a63fc:	e17ffd17 	ldw	r5,-12(fp)
 90a6400:	e1bffe17 	ldw	r6,-8(fp)
 90a6404:	90a73000 	call	90a7300 <dhc_decline>
      return ENP_NOT_MINE;
 90a6408:	00800084 	movi	r2,2
 90a640c:	e0bfff15 	stw	r2,-4(fp)
 90a6410:	00000d06 	br	90a6448 <dhc_rx_offer+0xec>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 90a6414:	e13ffc17 	ldw	r4,-16(fp)
 90a6418:	e0bffd17 	ldw	r2,-12(fp)
 90a641c:	11400417 	ldw	r5,16(r2)
 90a6420:	00c243b4 	movhi	r3,2318
 90a6424:	18f44404 	addi	r3,r3,-12016
 90a6428:	20800f24 	muli	r2,r4,60
 90a642c:	10c5883a 	add	r2,r2,r3
 90a6430:	10800904 	addi	r2,r2,36
 90a6434:	11400015 	stw	r5,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 90a6438:	e13ffc17 	ldw	r4,-16(fp)
 90a643c:	000b883a 	mov	r5,zero
 90a6440:	90a64600 	call	90a6460 <dhc_request>
 90a6444:	e0bfff15 	stw	r2,-4(fp)
 90a6448:	e0bfff17 	ldw	r2,-4(fp)
}
 90a644c:	e037883a 	mov	sp,fp
 90a6450:	dfc00117 	ldw	ra,4(sp)
 90a6454:	df000017 	ldw	fp,0(sp)
 90a6458:	dec00204 	addi	sp,sp,8
 90a645c:	f800283a 	ret

090a6460 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 90a6460:	defff304 	addi	sp,sp,-52
 90a6464:	dfc00c15 	stw	ra,48(sp)
 90a6468:	df000b15 	stw	fp,44(sp)
 90a646c:	df000b04 	addi	fp,sp,44
 90a6470:	e13ffd15 	stw	r4,-12(fp)
 90a6474:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 90a6478:	01008904 	movi	r4,548
 90a647c:	000b883a 	mov	r5,zero
 90a6480:	90c3b880 	call	90c3b88 <udp_alloc>
 90a6484:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 90a6488:	e0bffa17 	ldw	r2,-24(fp)
 90a648c:	1004c03a 	cmpne	r2,r2,zero
 90a6490:	1000031e 	bne	r2,zero,90a64a0 <dhc_request+0x40>
      return ENP_NOMEM;
 90a6494:	00bffb04 	movi	r2,-20
 90a6498:	e0bfff15 	stw	r2,-4(fp)
 90a649c:	0002b906 	br	90a6f84 <dhc_request+0xb24>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 90a64a0:	e0fffa17 	ldw	r3,-24(fp)
 90a64a4:	00803b04 	movi	r2,236
 90a64a8:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 90a64ac:	e0bffe17 	ldw	r2,-8(fp)
 90a64b0:	10800058 	cmpnei	r2,r2,1
 90a64b4:	1000121e 	bne	r2,zero,90a6500 <dhc_request+0xa0>
   {
      dhc_states[iface].xid  = xids++;
 90a64b8:	e0bffd17 	ldw	r2,-12(fp)
 90a64bc:	d1203117 	ldw	r4,-32572(gp)
 90a64c0:	200b883a 	mov	r5,r4
 90a64c4:	00c243b4 	movhi	r3,2318
 90a64c8:	18f44404 	addi	r3,r3,-12016
 90a64cc:	10800f24 	muli	r2,r2,60
 90a64d0:	10c5883a 	add	r2,r2,r3
 90a64d4:	10800204 	addi	r2,r2,8
 90a64d8:	11400015 	stw	r5,0(r2)
 90a64dc:	20800044 	addi	r2,r4,1
 90a64e0:	d0a03115 	stw	r2,-32572(gp)
      dhc_states[iface].secs = 0;
 90a64e4:	e0bffd17 	ldw	r2,-12(fp)
 90a64e8:	00c243b4 	movhi	r3,2318
 90a64ec:	18f44404 	addi	r3,r3,-12016
 90a64f0:	10800f24 	muli	r2,r2,60
 90a64f4:	10c5883a 	add	r2,r2,r3
 90a64f8:	10800304 	addi	r2,r2,12
 90a64fc:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 90a6500:	e0bffa17 	ldw	r2,-24(fp)
 90a6504:	10800317 	ldw	r2,12(r2)
 90a6508:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 90a650c:	e13ffd17 	ldw	r4,-12(fp)
 90a6510:	e17ffb17 	ldw	r5,-20(fp)
 90a6514:	90a5c100 	call	90a5c10 <dhc_buildheader>
 90a6518:	e0bff815 	stw	r2,-32(fp)
   if (e)
 90a651c:	e0bff817 	ldw	r2,-32(fp)
 90a6520:	1005003a 	cmpeq	r2,r2,zero
 90a6524:	1000031e 	bne	r2,zero,90a6534 <dhc_request+0xd4>
      return e;
 90a6528:	e0bff817 	ldw	r2,-32(fp)
 90a652c:	e0bfff15 	stw	r2,-4(fp)
 90a6530:	00029406 	br	90a6f84 <dhc_request+0xb24>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 90a6534:	e0bffb17 	ldw	r2,-20(fp)
 90a6538:	10803b04 	addi	r2,r2,236
 90a653c:	1007883a 	mov	r3,r2
 90a6540:	0098d534 	movhi	r2,25428
 90a6544:	10a098c4 	addi	r2,r2,-32157
 90a6548:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 90a654c:	e0bffb17 	ldw	r2,-20(fp)
 90a6550:	10803b04 	addi	r2,r2,236
 90a6554:	10800104 	addi	r2,r2,4
 90a6558:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 90a655c:	e0fff917 	ldw	r3,-28(fp)
 90a6560:	00800d44 	movi	r2,53
 90a6564:	18800005 	stb	r2,0(r3)
 90a6568:	e0bff917 	ldw	r2,-28(fp)
 90a656c:	10800044 	addi	r2,r2,1
 90a6570:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 90a6574:	e0fff917 	ldw	r3,-28(fp)
 90a6578:	00800044 	movi	r2,1
 90a657c:	18800005 	stb	r2,0(r3)
 90a6580:	e0bff917 	ldw	r2,-28(fp)
 90a6584:	10800044 	addi	r2,r2,1
 90a6588:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 90a658c:	e0fff917 	ldw	r3,-28(fp)
 90a6590:	008000c4 	movi	r2,3
 90a6594:	18800005 	stb	r2,0(r3)
 90a6598:	e0bff917 	ldw	r2,-28(fp)
 90a659c:	10800044 	addi	r2,r2,1
 90a65a0:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 90a65a4:	e0bffd17 	ldw	r2,-12(fp)
 90a65a8:	00c243b4 	movhi	r3,2318
 90a65ac:	18f44404 	addi	r3,r3,-12016
 90a65b0:	10800f24 	muli	r2,r2,60
 90a65b4:	10c5883a 	add	r2,r2,r3
 90a65b8:	10800017 	ldw	r2,0(r2)
 90a65bc:	10800120 	cmpeqi	r2,r2,4
 90a65c0:	1000181e 	bne	r2,zero,90a6624 <dhc_request+0x1c4>
 90a65c4:	e0bffd17 	ldw	r2,-12(fp)
 90a65c8:	00c243b4 	movhi	r3,2318
 90a65cc:	18f44404 	addi	r3,r3,-12016
 90a65d0:	10800f24 	muli	r2,r2,60
 90a65d4:	10c5883a 	add	r2,r2,r3
 90a65d8:	10800017 	ldw	r2,0(r2)
 90a65dc:	10800160 	cmpeqi	r2,r2,5
 90a65e0:	1000101e 	bne	r2,zero,90a6624 <dhc_request+0x1c4>
 90a65e4:	e0bffd17 	ldw	r2,-12(fp)
 90a65e8:	00c243b4 	movhi	r3,2318
 90a65ec:	18f44404 	addi	r3,r3,-12016
 90a65f0:	10800f24 	muli	r2,r2,60
 90a65f4:	10c5883a 	add	r2,r2,r3
 90a65f8:	10800017 	ldw	r2,0(r2)
 90a65fc:	108000e0 	cmpeqi	r2,r2,3
 90a6600:	1000081e 	bne	r2,zero,90a6624 <dhc_request+0x1c4>
 90a6604:	e0bffd17 	ldw	r2,-12(fp)
 90a6608:	00c243b4 	movhi	r3,2318
 90a660c:	18f44404 	addi	r3,r3,-12016
 90a6610:	10800f24 	muli	r2,r2,60
 90a6614:	10c5883a 	add	r2,r2,r3
 90a6618:	10800017 	ldw	r2,0(r2)
 90a661c:	10800098 	cmpnei	r2,r2,2
 90a6620:	10004e1e 	bne	r2,zero,90a675c <dhc_request+0x2fc>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 90a6624:	e0bffd17 	ldw	r2,-12(fp)
 90a6628:	00c243b4 	movhi	r3,2318
 90a662c:	18f44404 	addi	r3,r3,-12016
 90a6630:	10800f24 	muli	r2,r2,60
 90a6634:	10c5883a 	add	r2,r2,r3
 90a6638:	10800904 	addi	r2,r2,36
 90a663c:	10800017 	ldw	r2,0(r2)
 90a6640:	1004d63a 	srli	r2,r2,24
 90a6644:	11003fcc 	andi	r4,r2,255
 90a6648:	e0bffd17 	ldw	r2,-12(fp)
 90a664c:	00c243b4 	movhi	r3,2318
 90a6650:	18f44404 	addi	r3,r3,-12016
 90a6654:	10800f24 	muli	r2,r2,60
 90a6658:	10c5883a 	add	r2,r2,r3
 90a665c:	10800904 	addi	r2,r2,36
 90a6660:	10800017 	ldw	r2,0(r2)
 90a6664:	1004d23a 	srli	r2,r2,8
 90a6668:	10bfc00c 	andi	r2,r2,65280
 90a666c:	2088b03a 	or	r4,r4,r2
 90a6670:	e0bffd17 	ldw	r2,-12(fp)
 90a6674:	00c243b4 	movhi	r3,2318
 90a6678:	18f44404 	addi	r3,r3,-12016
 90a667c:	10800f24 	muli	r2,r2,60
 90a6680:	10c5883a 	add	r2,r2,r3
 90a6684:	10800904 	addi	r2,r2,36
 90a6688:	10800017 	ldw	r2,0(r2)
 90a668c:	10bfc00c 	andi	r2,r2,65280
 90a6690:	1004923a 	slli	r2,r2,8
 90a6694:	2088b03a 	or	r4,r4,r2
 90a6698:	e0bffd17 	ldw	r2,-12(fp)
 90a669c:	00c243b4 	movhi	r3,2318
 90a66a0:	18f44404 	addi	r3,r3,-12016
 90a66a4:	10800f24 	muli	r2,r2,60
 90a66a8:	10c5883a 	add	r2,r2,r3
 90a66ac:	10800904 	addi	r2,r2,36
 90a66b0:	10800017 	ldw	r2,0(r2)
 90a66b4:	10803fcc 	andi	r2,r2,255
 90a66b8:	1004963a 	slli	r2,r2,24
 90a66bc:	2084b03a 	or	r2,r4,r2
 90a66c0:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 90a66c4:	e0fff917 	ldw	r3,-28(fp)
 90a66c8:	00800c84 	movi	r2,50
 90a66cc:	18800005 	stb	r2,0(r3)
 90a66d0:	e0bff917 	ldw	r2,-28(fp)
 90a66d4:	10800044 	addi	r2,r2,1
 90a66d8:	e0bff915 	stw	r2,-28(fp)
 90a66dc:	e0fff917 	ldw	r3,-28(fp)
 90a66e0:	00800104 	movi	r2,4
 90a66e4:	18800005 	stb	r2,0(r3)
 90a66e8:	e0bff917 	ldw	r2,-28(fp)
 90a66ec:	10800044 	addi	r2,r2,1
 90a66f0:	e0bff915 	stw	r2,-28(fp)
 90a66f4:	e0bff917 	ldw	r2,-28(fp)
 90a66f8:	10c000c4 	addi	r3,r2,3
 90a66fc:	e0bffc04 	addi	r2,fp,-16
 90a6700:	10800003 	ldbu	r2,0(r2)
 90a6704:	18800005 	stb	r2,0(r3)
 90a6708:	e0bff917 	ldw	r2,-28(fp)
 90a670c:	10c00084 	addi	r3,r2,2
 90a6710:	e0bffc04 	addi	r2,fp,-16
 90a6714:	10800044 	addi	r2,r2,1
 90a6718:	10800003 	ldbu	r2,0(r2)
 90a671c:	18800005 	stb	r2,0(r3)
 90a6720:	e0bff917 	ldw	r2,-28(fp)
 90a6724:	10c00044 	addi	r3,r2,1
 90a6728:	e0bffc04 	addi	r2,fp,-16
 90a672c:	10800084 	addi	r2,r2,2
 90a6730:	10800003 	ldbu	r2,0(r2)
 90a6734:	18800005 	stb	r2,0(r3)
 90a6738:	e0bffc04 	addi	r2,fp,-16
 90a673c:	108000c4 	addi	r2,r2,3
 90a6740:	10800003 	ldbu	r2,0(r2)
 90a6744:	1007883a 	mov	r3,r2
 90a6748:	e0bff917 	ldw	r2,-28(fp)
 90a674c:	10c00005 	stb	r3,0(r2)
 90a6750:	e0bff917 	ldw	r2,-28(fp)
 90a6754:	10800104 	addi	r2,r2,4
 90a6758:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 90a675c:	e0bffd17 	ldw	r2,-12(fp)
 90a6760:	00c243b4 	movhi	r3,2318
 90a6764:	18f44404 	addi	r3,r3,-12016
 90a6768:	10800f24 	muli	r2,r2,60
 90a676c:	10c5883a 	add	r2,r2,r3
 90a6770:	10800a04 	addi	r2,r2,40
 90a6774:	10800017 	ldw	r2,0(r2)
 90a6778:	1005003a 	cmpeq	r2,r2,zero
 90a677c:	10004e1e 	bne	r2,zero,90a68b8 <dhc_request+0x458>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 90a6780:	e0bffd17 	ldw	r2,-12(fp)
 90a6784:	00c243b4 	movhi	r3,2318
 90a6788:	18f44404 	addi	r3,r3,-12016
 90a678c:	10800f24 	muli	r2,r2,60
 90a6790:	10c5883a 	add	r2,r2,r3
 90a6794:	10800a04 	addi	r2,r2,40
 90a6798:	10800017 	ldw	r2,0(r2)
 90a679c:	1004d63a 	srli	r2,r2,24
 90a67a0:	11003fcc 	andi	r4,r2,255
 90a67a4:	e0bffd17 	ldw	r2,-12(fp)
 90a67a8:	00c243b4 	movhi	r3,2318
 90a67ac:	18f44404 	addi	r3,r3,-12016
 90a67b0:	10800f24 	muli	r2,r2,60
 90a67b4:	10c5883a 	add	r2,r2,r3
 90a67b8:	10800a04 	addi	r2,r2,40
 90a67bc:	10800017 	ldw	r2,0(r2)
 90a67c0:	1004d23a 	srli	r2,r2,8
 90a67c4:	10bfc00c 	andi	r2,r2,65280
 90a67c8:	2088b03a 	or	r4,r4,r2
 90a67cc:	e0bffd17 	ldw	r2,-12(fp)
 90a67d0:	00c243b4 	movhi	r3,2318
 90a67d4:	18f44404 	addi	r3,r3,-12016
 90a67d8:	10800f24 	muli	r2,r2,60
 90a67dc:	10c5883a 	add	r2,r2,r3
 90a67e0:	10800a04 	addi	r2,r2,40
 90a67e4:	10800017 	ldw	r2,0(r2)
 90a67e8:	10bfc00c 	andi	r2,r2,65280
 90a67ec:	1004923a 	slli	r2,r2,8
 90a67f0:	2088b03a 	or	r4,r4,r2
 90a67f4:	e0bffd17 	ldw	r2,-12(fp)
 90a67f8:	00c243b4 	movhi	r3,2318
 90a67fc:	18f44404 	addi	r3,r3,-12016
 90a6800:	10800f24 	muli	r2,r2,60
 90a6804:	10c5883a 	add	r2,r2,r3
 90a6808:	10800a04 	addi	r2,r2,40
 90a680c:	10800017 	ldw	r2,0(r2)
 90a6810:	10803fcc 	andi	r2,r2,255
 90a6814:	1004963a 	slli	r2,r2,24
 90a6818:	2084b03a 	or	r2,r4,r2
 90a681c:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 90a6820:	e0fff917 	ldw	r3,-28(fp)
 90a6824:	00800044 	movi	r2,1
 90a6828:	18800005 	stb	r2,0(r3)
 90a682c:	e0bff917 	ldw	r2,-28(fp)
 90a6830:	10800044 	addi	r2,r2,1
 90a6834:	e0bff915 	stw	r2,-28(fp)
 90a6838:	e0fff917 	ldw	r3,-28(fp)
 90a683c:	00800104 	movi	r2,4
 90a6840:	18800005 	stb	r2,0(r3)
 90a6844:	e0bff917 	ldw	r2,-28(fp)
 90a6848:	10800044 	addi	r2,r2,1
 90a684c:	e0bff915 	stw	r2,-28(fp)
 90a6850:	e0bff917 	ldw	r2,-28(fp)
 90a6854:	10c000c4 	addi	r3,r2,3
 90a6858:	e0bffc04 	addi	r2,fp,-16
 90a685c:	10800003 	ldbu	r2,0(r2)
 90a6860:	18800005 	stb	r2,0(r3)
 90a6864:	e0bff917 	ldw	r2,-28(fp)
 90a6868:	10c00084 	addi	r3,r2,2
 90a686c:	e0bffc04 	addi	r2,fp,-16
 90a6870:	10800044 	addi	r2,r2,1
 90a6874:	10800003 	ldbu	r2,0(r2)
 90a6878:	18800005 	stb	r2,0(r3)
 90a687c:	e0bff917 	ldw	r2,-28(fp)
 90a6880:	10c00044 	addi	r3,r2,1
 90a6884:	e0bffc04 	addi	r2,fp,-16
 90a6888:	10800084 	addi	r2,r2,2
 90a688c:	10800003 	ldbu	r2,0(r2)
 90a6890:	18800005 	stb	r2,0(r3)
 90a6894:	e0bffc04 	addi	r2,fp,-16
 90a6898:	108000c4 	addi	r2,r2,3
 90a689c:	10800003 	ldbu	r2,0(r2)
 90a68a0:	1007883a 	mov	r3,r2
 90a68a4:	e0bff917 	ldw	r2,-28(fp)
 90a68a8:	10c00005 	stb	r3,0(r2)
 90a68ac:	e0bff917 	ldw	r2,-28(fp)
 90a68b0:	10800104 	addi	r2,r2,4
 90a68b4:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 90a68b8:	e0bffd17 	ldw	r2,-12(fp)
 90a68bc:	00c243b4 	movhi	r3,2318
 90a68c0:	18f44404 	addi	r3,r3,-12016
 90a68c4:	10800f24 	muli	r2,r2,60
 90a68c8:	10c5883a 	add	r2,r2,r3
 90a68cc:	10800b04 	addi	r2,r2,44
 90a68d0:	10800017 	ldw	r2,0(r2)
 90a68d4:	1005003a 	cmpeq	r2,r2,zero
 90a68d8:	10004e1e 	bne	r2,zero,90a6a14 <dhc_request+0x5b4>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 90a68dc:	e0bffd17 	ldw	r2,-12(fp)
 90a68e0:	00c243b4 	movhi	r3,2318
 90a68e4:	18f44404 	addi	r3,r3,-12016
 90a68e8:	10800f24 	muli	r2,r2,60
 90a68ec:	10c5883a 	add	r2,r2,r3
 90a68f0:	10800b04 	addi	r2,r2,44
 90a68f4:	10800017 	ldw	r2,0(r2)
 90a68f8:	1004d63a 	srli	r2,r2,24
 90a68fc:	11003fcc 	andi	r4,r2,255
 90a6900:	e0bffd17 	ldw	r2,-12(fp)
 90a6904:	00c243b4 	movhi	r3,2318
 90a6908:	18f44404 	addi	r3,r3,-12016
 90a690c:	10800f24 	muli	r2,r2,60
 90a6910:	10c5883a 	add	r2,r2,r3
 90a6914:	10800b04 	addi	r2,r2,44
 90a6918:	10800017 	ldw	r2,0(r2)
 90a691c:	1004d23a 	srli	r2,r2,8
 90a6920:	10bfc00c 	andi	r2,r2,65280
 90a6924:	2088b03a 	or	r4,r4,r2
 90a6928:	e0bffd17 	ldw	r2,-12(fp)
 90a692c:	00c243b4 	movhi	r3,2318
 90a6930:	18f44404 	addi	r3,r3,-12016
 90a6934:	10800f24 	muli	r2,r2,60
 90a6938:	10c5883a 	add	r2,r2,r3
 90a693c:	10800b04 	addi	r2,r2,44
 90a6940:	10800017 	ldw	r2,0(r2)
 90a6944:	10bfc00c 	andi	r2,r2,65280
 90a6948:	1004923a 	slli	r2,r2,8
 90a694c:	2088b03a 	or	r4,r4,r2
 90a6950:	e0bffd17 	ldw	r2,-12(fp)
 90a6954:	00c243b4 	movhi	r3,2318
 90a6958:	18f44404 	addi	r3,r3,-12016
 90a695c:	10800f24 	muli	r2,r2,60
 90a6960:	10c5883a 	add	r2,r2,r3
 90a6964:	10800b04 	addi	r2,r2,44
 90a6968:	10800017 	ldw	r2,0(r2)
 90a696c:	10803fcc 	andi	r2,r2,255
 90a6970:	1004963a 	slli	r2,r2,24
 90a6974:	2084b03a 	or	r2,r4,r2
 90a6978:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 90a697c:	e0fff917 	ldw	r3,-28(fp)
 90a6980:	008000c4 	movi	r2,3
 90a6984:	18800005 	stb	r2,0(r3)
 90a6988:	e0bff917 	ldw	r2,-28(fp)
 90a698c:	10800044 	addi	r2,r2,1
 90a6990:	e0bff915 	stw	r2,-28(fp)
 90a6994:	e0fff917 	ldw	r3,-28(fp)
 90a6998:	00800104 	movi	r2,4
 90a699c:	18800005 	stb	r2,0(r3)
 90a69a0:	e0bff917 	ldw	r2,-28(fp)
 90a69a4:	10800044 	addi	r2,r2,1
 90a69a8:	e0bff915 	stw	r2,-28(fp)
 90a69ac:	e0bff917 	ldw	r2,-28(fp)
 90a69b0:	10c000c4 	addi	r3,r2,3
 90a69b4:	e0bffc04 	addi	r2,fp,-16
 90a69b8:	10800003 	ldbu	r2,0(r2)
 90a69bc:	18800005 	stb	r2,0(r3)
 90a69c0:	e0bff917 	ldw	r2,-28(fp)
 90a69c4:	10c00084 	addi	r3,r2,2
 90a69c8:	e0bffc04 	addi	r2,fp,-16
 90a69cc:	10800044 	addi	r2,r2,1
 90a69d0:	10800003 	ldbu	r2,0(r2)
 90a69d4:	18800005 	stb	r2,0(r3)
 90a69d8:	e0bff917 	ldw	r2,-28(fp)
 90a69dc:	10c00044 	addi	r3,r2,1
 90a69e0:	e0bffc04 	addi	r2,fp,-16
 90a69e4:	10800084 	addi	r2,r2,2
 90a69e8:	10800003 	ldbu	r2,0(r2)
 90a69ec:	18800005 	stb	r2,0(r3)
 90a69f0:	e0bffc04 	addi	r2,fp,-16
 90a69f4:	108000c4 	addi	r2,r2,3
 90a69f8:	10800003 	ldbu	r2,0(r2)
 90a69fc:	1007883a 	mov	r3,r2
 90a6a00:	e0bff917 	ldw	r2,-28(fp)
 90a6a04:	10c00005 	stb	r3,0(r2)
 90a6a08:	e0bff917 	ldw	r2,-28(fp)
 90a6a0c:	10800104 	addi	r2,r2,4
 90a6a10:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 90a6a14:	e0bffd17 	ldw	r2,-12(fp)
 90a6a18:	00c243b4 	movhi	r3,2318
 90a6a1c:	18f44404 	addi	r3,r3,-12016
 90a6a20:	10800f24 	muli	r2,r2,60
 90a6a24:	10c5883a 	add	r2,r2,r3
 90a6a28:	10800504 	addi	r2,r2,20
 90a6a2c:	10800017 	ldw	r2,0(r2)
 90a6a30:	1005003a 	cmpeq	r2,r2,zero
 90a6a34:	10003a1e 	bne	r2,zero,90a6b20 <dhc_request+0x6c0>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 90a6a38:	e0fff917 	ldw	r3,-28(fp)
 90a6a3c:	00800cc4 	movi	r2,51
 90a6a40:	18800005 	stb	r2,0(r3)
 90a6a44:	e0bff917 	ldw	r2,-28(fp)
 90a6a48:	10800044 	addi	r2,r2,1
 90a6a4c:	e0bff915 	stw	r2,-28(fp)
 90a6a50:	e0fff917 	ldw	r3,-28(fp)
 90a6a54:	00800104 	movi	r2,4
 90a6a58:	18800005 	stb	r2,0(r3)
 90a6a5c:	e0bff917 	ldw	r2,-28(fp)
 90a6a60:	10800044 	addi	r2,r2,1
 90a6a64:	e0bff915 	stw	r2,-28(fp)
 90a6a68:	e0bff917 	ldw	r2,-28(fp)
 90a6a6c:	110000c4 	addi	r4,r2,3
 90a6a70:	e0bffd17 	ldw	r2,-12(fp)
 90a6a74:	10800f24 	muli	r2,r2,60
 90a6a78:	10c00504 	addi	r3,r2,20
 90a6a7c:	008243b4 	movhi	r2,2318
 90a6a80:	10b44404 	addi	r2,r2,-12016
 90a6a84:	1885883a 	add	r2,r3,r2
 90a6a88:	10800003 	ldbu	r2,0(r2)
 90a6a8c:	20800005 	stb	r2,0(r4)
 90a6a90:	e0bff917 	ldw	r2,-28(fp)
 90a6a94:	11000084 	addi	r4,r2,2
 90a6a98:	e0bffd17 	ldw	r2,-12(fp)
 90a6a9c:	10800f24 	muli	r2,r2,60
 90a6aa0:	10c00504 	addi	r3,r2,20
 90a6aa4:	008243b4 	movhi	r2,2318
 90a6aa8:	10b44404 	addi	r2,r2,-12016
 90a6aac:	1885883a 	add	r2,r3,r2
 90a6ab0:	10800044 	addi	r2,r2,1
 90a6ab4:	10800003 	ldbu	r2,0(r2)
 90a6ab8:	20800005 	stb	r2,0(r4)
 90a6abc:	e0bff917 	ldw	r2,-28(fp)
 90a6ac0:	11000044 	addi	r4,r2,1
 90a6ac4:	e0bffd17 	ldw	r2,-12(fp)
 90a6ac8:	10800f24 	muli	r2,r2,60
 90a6acc:	10c00504 	addi	r3,r2,20
 90a6ad0:	008243b4 	movhi	r2,2318
 90a6ad4:	10b44404 	addi	r2,r2,-12016
 90a6ad8:	1885883a 	add	r2,r3,r2
 90a6adc:	10800084 	addi	r2,r2,2
 90a6ae0:	10800003 	ldbu	r2,0(r2)
 90a6ae4:	20800005 	stb	r2,0(r4)
 90a6ae8:	e0bffd17 	ldw	r2,-12(fp)
 90a6aec:	10800f24 	muli	r2,r2,60
 90a6af0:	10c00504 	addi	r3,r2,20
 90a6af4:	008243b4 	movhi	r2,2318
 90a6af8:	10b44404 	addi	r2,r2,-12016
 90a6afc:	1885883a 	add	r2,r3,r2
 90a6b00:	108000c4 	addi	r2,r2,3
 90a6b04:	10800003 	ldbu	r2,0(r2)
 90a6b08:	1007883a 	mov	r3,r2
 90a6b0c:	e0bff917 	ldw	r2,-28(fp)
 90a6b10:	10c00005 	stb	r3,0(r2)
 90a6b14:	e0bff917 	ldw	r2,-28(fp)
 90a6b18:	10800104 	addi	r2,r2,4
 90a6b1c:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 90a6b20:	d0a03317 	ldw	r2,-32564(gp)
 90a6b24:	10800050 	cmplti	r2,r2,1
 90a6b28:	10001e1e 	bne	r2,zero,90a6ba4 <dhc_request+0x744>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 90a6b2c:	e0fff917 	ldw	r3,-28(fp)
 90a6b30:	00800dc4 	movi	r2,55
 90a6b34:	18800005 	stb	r2,0(r3)
 90a6b38:	e0bff917 	ldw	r2,-28(fp)
 90a6b3c:	10800044 	addi	r2,r2,1
 90a6b40:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 90a6b44:	d0a03317 	ldw	r2,-32564(gp)
 90a6b48:	1007883a 	mov	r3,r2
 90a6b4c:	e0bff917 	ldw	r2,-28(fp)
 90a6b50:	10c00005 	stb	r3,0(r2)
 90a6b54:	e0bff917 	ldw	r2,-28(fp)
 90a6b58:	10800044 	addi	r2,r2,1
 90a6b5c:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 90a6b60:	e03ff715 	stw	zero,-36(fp)
 90a6b64:	00000c06 	br	90a6b98 <dhc_request+0x738>
         *opts++ = reqlist[i];
 90a6b68:	e0fff717 	ldw	r3,-36(fp)
 90a6b6c:	d0a03204 	addi	r2,gp,-32568
 90a6b70:	1885883a 	add	r2,r3,r2
 90a6b74:	10c00003 	ldbu	r3,0(r2)
 90a6b78:	e0bff917 	ldw	r2,-28(fp)
 90a6b7c:	10c00005 	stb	r3,0(r2)
 90a6b80:	e0bff917 	ldw	r2,-28(fp)
 90a6b84:	10800044 	addi	r2,r2,1
 90a6b88:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 90a6b8c:	e0bff717 	ldw	r2,-36(fp)
 90a6b90:	10800044 	addi	r2,r2,1
 90a6b94:	e0bff715 	stw	r2,-36(fp)
 90a6b98:	d0e03317 	ldw	r3,-32564(gp)
 90a6b9c:	e0bff717 	ldw	r2,-36(fp)
 90a6ba0:	10fff116 	blt	r2,r3,90a6b68 <dhc_request+0x708>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 90a6ba4:	e0bffd17 	ldw	r2,-12(fp)
 90a6ba8:	00c243b4 	movhi	r3,2318
 90a6bac:	18f44404 	addi	r3,r3,-12016
 90a6bb0:	10800f24 	muli	r2,r2,60
 90a6bb4:	10c5883a 	add	r2,r2,r3
 90a6bb8:	10800017 	ldw	r2,0(r2)
 90a6bbc:	108001e0 	cmpeqi	r2,r2,7
 90a6bc0:	1000081e 	bne	r2,zero,90a6be4 <dhc_request+0x784>
 90a6bc4:	e0bffd17 	ldw	r2,-12(fp)
 90a6bc8:	00c243b4 	movhi	r3,2318
 90a6bcc:	18f44404 	addi	r3,r3,-12016
 90a6bd0:	10800f24 	muli	r2,r2,60
 90a6bd4:	10c5883a 	add	r2,r2,r3
 90a6bd8:	10800017 	ldw	r2,0(r2)
 90a6bdc:	10800218 	cmpnei	r2,r2,8
 90a6be0:	10000a1e 	bne	r2,zero,90a6c0c <dhc_request+0x7ac>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 90a6be4:	e0bffd17 	ldw	r2,-12(fp)
 90a6be8:	00c243b4 	movhi	r3,2318
 90a6bec:	18f41e04 	addi	r3,r3,-12168
 90a6bf0:	1085883a 	add	r2,r2,r2
 90a6bf4:	1085883a 	add	r2,r2,r2
 90a6bf8:	10c5883a 	add	r2,r2,r3
 90a6bfc:	10800017 	ldw	r2,0(r2)
 90a6c00:	10c00a17 	ldw	r3,40(r2)
 90a6c04:	e0bffb17 	ldw	r2,-20(fp)
 90a6c08:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 90a6c0c:	e0bffd17 	ldw	r2,-12(fp)
 90a6c10:	00c243b4 	movhi	r3,2318
 90a6c14:	18f44404 	addi	r3,r3,-12016
 90a6c18:	10800f24 	muli	r2,r2,60
 90a6c1c:	10c5883a 	add	r2,r2,r3
 90a6c20:	10800017 	ldw	r2,0(r2)
 90a6c24:	10800120 	cmpeqi	r2,r2,4
 90a6c28:	1000081e 	bne	r2,zero,90a6c4c <dhc_request+0x7ec>
 90a6c2c:	e0bffd17 	ldw	r2,-12(fp)
 90a6c30:	00c243b4 	movhi	r3,2318
 90a6c34:	18f44404 	addi	r3,r3,-12016
 90a6c38:	10800f24 	muli	r2,r2,60
 90a6c3c:	10c5883a 	add	r2,r2,r3
 90a6c40:	10800017 	ldw	r2,0(r2)
 90a6c44:	10800158 	cmpnei	r2,r2,5
 90a6c48:	10004e1e 	bne	r2,zero,90a6d84 <dhc_request+0x924>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 90a6c4c:	e0bffd17 	ldw	r2,-12(fp)
 90a6c50:	00c243b4 	movhi	r3,2318
 90a6c54:	18f44404 	addi	r3,r3,-12016
 90a6c58:	10800f24 	muli	r2,r2,60
 90a6c5c:	10c5883a 	add	r2,r2,r3
 90a6c60:	10800d04 	addi	r2,r2,52
 90a6c64:	10800017 	ldw	r2,0(r2)
 90a6c68:	1004d63a 	srli	r2,r2,24
 90a6c6c:	11003fcc 	andi	r4,r2,255
 90a6c70:	e0bffd17 	ldw	r2,-12(fp)
 90a6c74:	00c243b4 	movhi	r3,2318
 90a6c78:	18f44404 	addi	r3,r3,-12016
 90a6c7c:	10800f24 	muli	r2,r2,60
 90a6c80:	10c5883a 	add	r2,r2,r3
 90a6c84:	10800d04 	addi	r2,r2,52
 90a6c88:	10800017 	ldw	r2,0(r2)
 90a6c8c:	1004d23a 	srli	r2,r2,8
 90a6c90:	10bfc00c 	andi	r2,r2,65280
 90a6c94:	2088b03a 	or	r4,r4,r2
 90a6c98:	e0bffd17 	ldw	r2,-12(fp)
 90a6c9c:	00c243b4 	movhi	r3,2318
 90a6ca0:	18f44404 	addi	r3,r3,-12016
 90a6ca4:	10800f24 	muli	r2,r2,60
 90a6ca8:	10c5883a 	add	r2,r2,r3
 90a6cac:	10800d04 	addi	r2,r2,52
 90a6cb0:	10800017 	ldw	r2,0(r2)
 90a6cb4:	10bfc00c 	andi	r2,r2,65280
 90a6cb8:	1004923a 	slli	r2,r2,8
 90a6cbc:	2088b03a 	or	r4,r4,r2
 90a6cc0:	e0bffd17 	ldw	r2,-12(fp)
 90a6cc4:	00c243b4 	movhi	r3,2318
 90a6cc8:	18f44404 	addi	r3,r3,-12016
 90a6ccc:	10800f24 	muli	r2,r2,60
 90a6cd0:	10c5883a 	add	r2,r2,r3
 90a6cd4:	10800d04 	addi	r2,r2,52
 90a6cd8:	10800017 	ldw	r2,0(r2)
 90a6cdc:	10803fcc 	andi	r2,r2,255
 90a6ce0:	1004963a 	slli	r2,r2,24
 90a6ce4:	2084b03a 	or	r2,r4,r2
 90a6ce8:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 90a6cec:	e0fff917 	ldw	r3,-28(fp)
 90a6cf0:	00800d84 	movi	r2,54
 90a6cf4:	18800005 	stb	r2,0(r3)
 90a6cf8:	e0bff917 	ldw	r2,-28(fp)
 90a6cfc:	10800044 	addi	r2,r2,1
 90a6d00:	e0bff915 	stw	r2,-28(fp)
 90a6d04:	e0fff917 	ldw	r3,-28(fp)
 90a6d08:	00800104 	movi	r2,4
 90a6d0c:	18800005 	stb	r2,0(r3)
 90a6d10:	e0bff917 	ldw	r2,-28(fp)
 90a6d14:	10800044 	addi	r2,r2,1
 90a6d18:	e0bff915 	stw	r2,-28(fp)
 90a6d1c:	e0bff917 	ldw	r2,-28(fp)
 90a6d20:	10c000c4 	addi	r3,r2,3
 90a6d24:	e0bffc04 	addi	r2,fp,-16
 90a6d28:	10800003 	ldbu	r2,0(r2)
 90a6d2c:	18800005 	stb	r2,0(r3)
 90a6d30:	e0bff917 	ldw	r2,-28(fp)
 90a6d34:	10c00084 	addi	r3,r2,2
 90a6d38:	e0bffc04 	addi	r2,fp,-16
 90a6d3c:	10800044 	addi	r2,r2,1
 90a6d40:	10800003 	ldbu	r2,0(r2)
 90a6d44:	18800005 	stb	r2,0(r3)
 90a6d48:	e0bff917 	ldw	r2,-28(fp)
 90a6d4c:	10c00044 	addi	r3,r2,1
 90a6d50:	e0bffc04 	addi	r2,fp,-16
 90a6d54:	10800084 	addi	r2,r2,2
 90a6d58:	10800003 	ldbu	r2,0(r2)
 90a6d5c:	18800005 	stb	r2,0(r3)
 90a6d60:	e0bffc04 	addi	r2,fp,-16
 90a6d64:	108000c4 	addi	r2,r2,3
 90a6d68:	10800003 	ldbu	r2,0(r2)
 90a6d6c:	1007883a 	mov	r3,r2
 90a6d70:	e0bff917 	ldw	r2,-28(fp)
 90a6d74:	10c00005 	stb	r3,0(r2)
 90a6d78:	e0bff917 	ldw	r2,-28(fp)
 90a6d7c:	10800104 	addi	r2,r2,4
 90a6d80:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 90a6d84:	e0fff917 	ldw	r3,-28(fp)
 90a6d88:	00801444 	movi	r2,81
 90a6d8c:	18800005 	stb	r2,0(r3)
 90a6d90:	e0bff917 	ldw	r2,-28(fp)
 90a6d94:	10800044 	addi	r2,r2,1
 90a6d98:	e0bff915 	stw	r2,-28(fp)
 90a6d9c:	00800184 	movi	r2,6
 90a6da0:	e0bff615 	stw	r2,-40(fp)
 90a6da4:	e0bff617 	ldw	r2,-40(fp)
 90a6da8:	1007883a 	mov	r3,r2
 90a6dac:	e0bff917 	ldw	r2,-28(fp)
 90a6db0:	10c00005 	stb	r3,0(r2)
 90a6db4:	e0bff917 	ldw	r2,-28(fp)
 90a6db8:	10800044 	addi	r2,r2,1
 90a6dbc:	e0bff915 	stw	r2,-28(fp)
 90a6dc0:	e13ff917 	ldw	r4,-28(fp)
 90a6dc4:	e1bff617 	ldw	r6,-40(fp)
 90a6dc8:	01424374 	movhi	r5,2317
 90a6dcc:	297e0204 	addi	r5,r5,-2040
 90a6dd0:	90ca7300 	call	90ca730 <strncpy>
 90a6dd4:	e0bff617 	ldw	r2,-40(fp)
 90a6dd8:	1007883a 	mov	r3,r2
 90a6ddc:	e0bff917 	ldw	r2,-28(fp)
 90a6de0:	10c5883a 	add	r2,r2,r3
 90a6de4:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 90a6de8:	e0fff917 	ldw	r3,-28(fp)
 90a6dec:	00800f04 	movi	r2,60
 90a6df0:	18800005 	stb	r2,0(r3)
 90a6df4:	e0bff917 	ldw	r2,-28(fp)
 90a6df8:	10800044 	addi	r2,r2,1
 90a6dfc:	e0bff915 	stw	r2,-28(fp)
 90a6e00:	00824374 	movhi	r2,2317
 90a6e04:	108be504 	addi	r2,r2,12180
 90a6e08:	11000017 	ldw	r4,0(r2)
 90a6e0c:	90830d40 	call	90830d4 <strlen>
 90a6e10:	e0bff515 	stw	r2,-44(fp)
 90a6e14:	e0bff517 	ldw	r2,-44(fp)
 90a6e18:	1007883a 	mov	r3,r2
 90a6e1c:	e0bff917 	ldw	r2,-28(fp)
 90a6e20:	10c00005 	stb	r3,0(r2)
 90a6e24:	e0bff917 	ldw	r2,-28(fp)
 90a6e28:	10800044 	addi	r2,r2,1
 90a6e2c:	e0bff915 	stw	r2,-28(fp)
 90a6e30:	e13ff917 	ldw	r4,-28(fp)
 90a6e34:	00824374 	movhi	r2,2317
 90a6e38:	108be504 	addi	r2,r2,12180
 90a6e3c:	11400017 	ldw	r5,0(r2)
 90a6e40:	e1bff517 	ldw	r6,-44(fp)
 90a6e44:	90ca7300 	call	90ca730 <strncpy>
 90a6e48:	e0bff517 	ldw	r2,-44(fp)
 90a6e4c:	1007883a 	mov	r3,r2
 90a6e50:	e0bff917 	ldw	r2,-28(fp)
 90a6e54:	10c5883a 	add	r2,r2,r3
 90a6e58:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 90a6e5c:	e0fff917 	ldw	r3,-28(fp)
 90a6e60:	00bfffc4 	movi	r2,-1
 90a6e64:	18800005 	stb	r2,0(r3)
 90a6e68:	e0bff917 	ldw	r2,-28(fp)
 90a6e6c:	10800044 	addi	r2,r2,1
 90a6e70:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 90a6e74:	e0bffd17 	ldw	r2,-12(fp)
 90a6e78:	00c243b4 	movhi	r3,2318
 90a6e7c:	18f44404 	addi	r3,r3,-12016
 90a6e80:	10800f24 	muli	r2,r2,60
 90a6e84:	10c5883a 	add	r2,r2,r3
 90a6e88:	10800017 	ldw	r2,0(r2)
 90a6e8c:	108001d8 	cmpnei	r2,r2,7
 90a6e90:	10000a1e 	bne	r2,zero,90a6ebc <dhc_request+0xa5c>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 90a6e94:	e0bffd17 	ldw	r2,-12(fp)
 90a6e98:	00c243b4 	movhi	r3,2318
 90a6e9c:	18f44404 	addi	r3,r3,-12016
 90a6ea0:	10800f24 	muli	r2,r2,60
 90a6ea4:	10c5883a 	add	r2,r2,r3
 90a6ea8:	10800d04 	addi	r2,r2,52
 90a6eac:	10c00017 	ldw	r3,0(r2)
 90a6eb0:	e0bffa17 	ldw	r2,-24(fp)
 90a6eb4:	10c00715 	stw	r3,28(r2)
 90a6eb8:	00000306 	br	90a6ec8 <dhc_request+0xa68>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 90a6ebc:	e0fffa17 	ldw	r3,-24(fp)
 90a6ec0:	00bfffc4 	movi	r2,-1
 90a6ec4:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 90a6ec8:	e0bffd17 	ldw	r2,-12(fp)
 90a6ecc:	00c243b4 	movhi	r3,2318
 90a6ed0:	18f41e04 	addi	r3,r3,-12168
 90a6ed4:	1085883a 	add	r2,r2,r2
 90a6ed8:	1085883a 	add	r2,r2,r2
 90a6edc:	10c5883a 	add	r2,r2,r3
 90a6ee0:	10c00017 	ldw	r3,0(r2)
 90a6ee4:	e0bffa17 	ldw	r2,-24(fp)
 90a6ee8:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 90a6eec:	e0fff917 	ldw	r3,-28(fp)
 90a6ef0:	e0bffb17 	ldw	r2,-20(fp)
 90a6ef4:	1885c83a 	sub	r2,r3,r2
 90a6ef8:	1007883a 	mov	r3,r2
 90a6efc:	e0bffa17 	ldw	r2,-24(fp)
 90a6f00:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a6f04:	010010c4 	movi	r4,67
 90a6f08:	01401104 	movi	r5,68
 90a6f0c:	e1bffa17 	ldw	r6,-24(fp)
 90a6f10:	90c36d00 	call	90c36d0 <udp_send>
   dsc_requests++;
 90a6f14:	d0a09317 	ldw	r2,-32180(gp)
 90a6f18:	10800044 	addi	r2,r2,1
 90a6f1c:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 90a6f20:	e13ffd17 	ldw	r4,-12(fp)
 90a6f24:	00824374 	movhi	r2,2317
 90a6f28:	108c4204 	addi	r2,r2,12552
 90a6f2c:	11400017 	ldw	r5,0(r2)
 90a6f30:	00c243b4 	movhi	r3,2318
 90a6f34:	18f44404 	addi	r3,r3,-12016
 90a6f38:	20800f24 	muli	r2,r4,60
 90a6f3c:	10c5883a 	add	r2,r2,r3
 90a6f40:	10800404 	addi	r2,r2,16
 90a6f44:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 90a6f48:	e17ffd17 	ldw	r5,-12(fp)
 90a6f4c:	00c243b4 	movhi	r3,2318
 90a6f50:	18f44404 	addi	r3,r3,-12016
 90a6f54:	28800f24 	muli	r2,r5,60
 90a6f58:	10c5883a 	add	r2,r2,r3
 90a6f5c:	10800104 	addi	r2,r2,4
 90a6f60:	10800017 	ldw	r2,0(r2)
 90a6f64:	11000044 	addi	r4,r2,1
 90a6f68:	00c243b4 	movhi	r3,2318
 90a6f6c:	18f44404 	addi	r3,r3,-12016
 90a6f70:	28800f24 	muli	r2,r5,60
 90a6f74:	10c5883a 	add	r2,r2,r3
 90a6f78:	10800104 	addi	r2,r2,4
 90a6f7c:	11000015 	stw	r4,0(r2)

   return 0;   /* return OK code */
 90a6f80:	e03fff15 	stw	zero,-4(fp)
 90a6f84:	e0bfff17 	ldw	r2,-4(fp)
}
 90a6f88:	e037883a 	mov	sp,fp
 90a6f8c:	dfc00117 	ldw	ra,4(sp)
 90a6f90:	df000017 	ldw	fp,0(sp)
 90a6f94:	dec00204 	addi	sp,sp,8
 90a6f98:	f800283a 	ret

090a6f9c <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 90a6f9c:	defffd04 	addi	sp,sp,-12
 90a6fa0:	dfc00215 	stw	ra,8(sp)
 90a6fa4:	df000115 	stw	fp,4(sp)
 90a6fa8:	df000104 	addi	fp,sp,4
 90a6fac:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 90a6fb0:	e0bfff17 	ldw	r2,-4(fp)
 90a6fb4:	00c243b4 	movhi	r3,2318
 90a6fb8:	18f41e04 	addi	r3,r3,-12168
 90a6fbc:	1085883a 	add	r2,r2,r2
 90a6fc0:	1085883a 	add	r2,r2,r2
 90a6fc4:	10c5883a 	add	r2,r2,r3
 90a6fc8:	11000017 	ldw	r4,0(r2)
 90a6fcc:	e0bfff17 	ldw	r2,-4(fp)
 90a6fd0:	00c243b4 	movhi	r3,2318
 90a6fd4:	18f44404 	addi	r3,r3,-12016
 90a6fd8:	10800f24 	muli	r2,r2,60
 90a6fdc:	10c5883a 	add	r2,r2,r3
 90a6fe0:	10800904 	addi	r2,r2,36
 90a6fe4:	10800017 	ldw	r2,0(r2)
 90a6fe8:	20800a15 	stw	r2,40(r4)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 90a6fec:	e0bfff17 	ldw	r2,-4(fp)
 90a6ff0:	00c243b4 	movhi	r3,2318
 90a6ff4:	18f41e04 	addi	r3,r3,-12168
 90a6ff8:	1085883a 	add	r2,r2,r2
 90a6ffc:	1085883a 	add	r2,r2,r2
 90a7000:	10c5883a 	add	r2,r2,r3
 90a7004:	11000017 	ldw	r4,0(r2)
 90a7008:	e0bfff17 	ldw	r2,-4(fp)
 90a700c:	00c243b4 	movhi	r3,2318
 90a7010:	18f44404 	addi	r3,r3,-12016
 90a7014:	10800f24 	muli	r2,r2,60
 90a7018:	10c5883a 	add	r2,r2,r3
 90a701c:	10800a04 	addi	r2,r2,40
 90a7020:	10800017 	ldw	r2,0(r2)
 90a7024:	20800c15 	stw	r2,48(r4)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 90a7028:	e0bfff17 	ldw	r2,-4(fp)
 90a702c:	00c243b4 	movhi	r3,2318
 90a7030:	18f41e04 	addi	r3,r3,-12168
 90a7034:	1085883a 	add	r2,r2,r2
 90a7038:	1085883a 	add	r2,r2,r2
 90a703c:	10c5883a 	add	r2,r2,r3
 90a7040:	11000017 	ldw	r4,0(r2)
 90a7044:	e0bfff17 	ldw	r2,-4(fp)
 90a7048:	00c243b4 	movhi	r3,2318
 90a704c:	18f44404 	addi	r3,r3,-12016
 90a7050:	10800f24 	muli	r2,r2,60
 90a7054:	10c5883a 	add	r2,r2,r3
 90a7058:	10800b04 	addi	r2,r2,44
 90a705c:	10800017 	ldw	r2,0(r2)
 90a7060:	20800d15 	stw	r2,52(r4)

   if ( nets[iface]->snmask == 0 )
 90a7064:	e0bfff17 	ldw	r2,-4(fp)
 90a7068:	00c243b4 	movhi	r3,2318
 90a706c:	18f41e04 	addi	r3,r3,-12168
 90a7070:	1085883a 	add	r2,r2,r2
 90a7074:	1085883a 	add	r2,r2,r2
 90a7078:	10c5883a 	add	r2,r2,r3
 90a707c:	10800017 	ldw	r2,0(r2)
 90a7080:	10800c17 	ldw	r2,48(r2)
 90a7084:	1004c03a 	cmpne	r2,r2,zero
 90a7088:	1000111e 	bne	r2,zero,90a70d0 <dhc_setip+0x134>
   {
      fixup_subnet_mask(iface);
 90a708c:	e13fff17 	ldw	r4,-4(fp)
 90a7090:	90a14680 	call	90a1468 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 90a7094:	e17fff17 	ldw	r5,-4(fp)
 90a7098:	e0bfff17 	ldw	r2,-4(fp)
 90a709c:	00c243b4 	movhi	r3,2318
 90a70a0:	18f41e04 	addi	r3,r3,-12168
 90a70a4:	1085883a 	add	r2,r2,r2
 90a70a8:	1085883a 	add	r2,r2,r2
 90a70ac:	10c5883a 	add	r2,r2,r3
 90a70b0:	10800017 	ldw	r2,0(r2)
 90a70b4:	11000c17 	ldw	r4,48(r2)
 90a70b8:	00c243b4 	movhi	r3,2318
 90a70bc:	18f44404 	addi	r3,r3,-12016
 90a70c0:	28800f24 	muli	r2,r5,60
 90a70c4:	10c5883a 	add	r2,r2,r3
 90a70c8:	10800a04 	addi	r2,r2,40
 90a70cc:	11000015 	stw	r4,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 90a70d0:	e0bfff17 	ldw	r2,-4(fp)
 90a70d4:	00c243b4 	movhi	r3,2318
 90a70d8:	18f41e04 	addi	r3,r3,-12168
 90a70dc:	1085883a 	add	r2,r2,r2
 90a70e0:	1085883a 	add	r2,r2,r2
 90a70e4:	10c5883a 	add	r2,r2,r3
 90a70e8:	11400017 	ldw	r5,0(r2)
 90a70ec:	e0bfff17 	ldw	r2,-4(fp)
 90a70f0:	00c243b4 	movhi	r3,2318
 90a70f4:	18f41e04 	addi	r3,r3,-12168
 90a70f8:	1085883a 	add	r2,r2,r2
 90a70fc:	1085883a 	add	r2,r2,r2
 90a7100:	10c5883a 	add	r2,r2,r3
 90a7104:	10800017 	ldw	r2,0(r2)
 90a7108:	11000a17 	ldw	r4,40(r2)
 90a710c:	e0bfff17 	ldw	r2,-4(fp)
 90a7110:	00c243b4 	movhi	r3,2318
 90a7114:	18f41e04 	addi	r3,r3,-12168
 90a7118:	1085883a 	add	r2,r2,r2
 90a711c:	1085883a 	add	r2,r2,r2
 90a7120:	10c5883a 	add	r2,r2,r3
 90a7124:	10800017 	ldw	r2,0(r2)
 90a7128:	10800c17 	ldw	r2,48(r2)
 90a712c:	0084303a 	nor	r2,zero,r2
 90a7130:	2084b03a 	or	r2,r4,r2
 90a7134:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 90a7138:	e0bfff17 	ldw	r2,-4(fp)
 90a713c:	00c243b4 	movhi	r3,2318
 90a7140:	18f41e04 	addi	r3,r3,-12168
 90a7144:	1085883a 	add	r2,r2,r2
 90a7148:	1085883a 	add	r2,r2,r2
 90a714c:	10c5883a 	add	r2,r2,r3
 90a7150:	11400017 	ldw	r5,0(r2)
 90a7154:	e0bfff17 	ldw	r2,-4(fp)
 90a7158:	00c243b4 	movhi	r3,2318
 90a715c:	18f41e04 	addi	r3,r3,-12168
 90a7160:	1085883a 	add	r2,r2,r2
 90a7164:	1085883a 	add	r2,r2,r2
 90a7168:	10c5883a 	add	r2,r2,r3
 90a716c:	10800017 	ldw	r2,0(r2)
 90a7170:	11000a17 	ldw	r4,40(r2)
 90a7174:	e0bfff17 	ldw	r2,-4(fp)
 90a7178:	00c243b4 	movhi	r3,2318
 90a717c:	18f41e04 	addi	r3,r3,-12168
 90a7180:	1085883a 	add	r2,r2,r2
 90a7184:	1085883a 	add	r2,r2,r2
 90a7188:	10c5883a 	add	r2,r2,r3
 90a718c:	10800017 	ldw	r2,0(r2)
 90a7190:	10800c17 	ldw	r2,48(r2)
 90a7194:	2084703a 	and	r2,r4,r2
 90a7198:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 90a719c:	e0bfff17 	ldw	r2,-4(fp)
 90a71a0:	00c243b4 	movhi	r3,2318
 90a71a4:	18f41e04 	addi	r3,r3,-12168
 90a71a8:	1085883a 	add	r2,r2,r2
 90a71ac:	1085883a 	add	r2,r2,r2
 90a71b0:	10c5883a 	add	r2,r2,r3
 90a71b4:	11400017 	ldw	r5,0(r2)
 90a71b8:	e0bfff17 	ldw	r2,-4(fp)
 90a71bc:	00c243b4 	movhi	r3,2318
 90a71c0:	18f41e04 	addi	r3,r3,-12168
 90a71c4:	1085883a 	add	r2,r2,r2
 90a71c8:	1085883a 	add	r2,r2,r2
 90a71cc:	10c5883a 	add	r2,r2,r3
 90a71d0:	10800017 	ldw	r2,0(r2)
 90a71d4:	11000a17 	ldw	r4,40(r2)
 90a71d8:	e0bfff17 	ldw	r2,-4(fp)
 90a71dc:	00c243b4 	movhi	r3,2318
 90a71e0:	18f41e04 	addi	r3,r3,-12168
 90a71e4:	1085883a 	add	r2,r2,r2
 90a71e8:	1085883a 	add	r2,r2,r2
 90a71ec:	10c5883a 	add	r2,r2,r3
 90a71f0:	10800017 	ldw	r2,0(r2)
 90a71f4:	10800c17 	ldw	r2,48(r2)
 90a71f8:	0084303a 	nor	r2,zero,r2
 90a71fc:	2084b03a 	or	r2,r4,r2
 90a7200:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 90a7204:	0005883a 	mov	r2,zero
}
 90a7208:	e037883a 	mov	sp,fp
 90a720c:	dfc00117 	ldw	ra,4(sp)
 90a7210:	df000017 	ldw	fp,0(sp)
 90a7214:	dec00204 	addi	sp,sp,8
 90a7218:	f800283a 	ret

090a721c <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 90a721c:	defffe04 	addi	sp,sp,-8
 90a7220:	df000115 	stw	fp,4(sp)
 90a7224:	df000104 	addi	fp,sp,4
 90a7228:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 90a722c:	e0bfff17 	ldw	r2,-4(fp)
 90a7230:	00c243b4 	movhi	r3,2318
 90a7234:	18f41e04 	addi	r3,r3,-12168
 90a7238:	1085883a 	add	r2,r2,r2
 90a723c:	1085883a 	add	r2,r2,r2
 90a7240:	10c5883a 	add	r2,r2,r3
 90a7244:	10800017 	ldw	r2,0(r2)
 90a7248:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 90a724c:	e0bfff17 	ldw	r2,-4(fp)
 90a7250:	00c243b4 	movhi	r3,2318
 90a7254:	18f41e04 	addi	r3,r3,-12168
 90a7258:	1085883a 	add	r2,r2,r2
 90a725c:	1085883a 	add	r2,r2,r2
 90a7260:	10c5883a 	add	r2,r2,r3
 90a7264:	10800017 	ldw	r2,0(r2)
 90a7268:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 90a726c:	e0bfff17 	ldw	r2,-4(fp)
 90a7270:	00c243b4 	movhi	r3,2318
 90a7274:	18f41e04 	addi	r3,r3,-12168
 90a7278:	1085883a 	add	r2,r2,r2
 90a727c:	1085883a 	add	r2,r2,r2
 90a7280:	10c5883a 	add	r2,r2,r3
 90a7284:	10800017 	ldw	r2,0(r2)
 90a7288:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 90a728c:	e0bfff17 	ldw	r2,-4(fp)
 90a7290:	00c243b4 	movhi	r3,2318
 90a7294:	18f41e04 	addi	r3,r3,-12168
 90a7298:	1085883a 	add	r2,r2,r2
 90a729c:	1085883a 	add	r2,r2,r2
 90a72a0:	10c5883a 	add	r2,r2,r3
 90a72a4:	10800017 	ldw	r2,0(r2)
 90a72a8:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 90a72ac:	e0bfff17 	ldw	r2,-4(fp)
 90a72b0:	00c243b4 	movhi	r3,2318
 90a72b4:	18f41e04 	addi	r3,r3,-12168
 90a72b8:	1085883a 	add	r2,r2,r2
 90a72bc:	1085883a 	add	r2,r2,r2
 90a72c0:	10c5883a 	add	r2,r2,r3
 90a72c4:	10800017 	ldw	r2,0(r2)
 90a72c8:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 90a72cc:	e0bfff17 	ldw	r2,-4(fp)
 90a72d0:	00c243b4 	movhi	r3,2318
 90a72d4:	18f41e04 	addi	r3,r3,-12168
 90a72d8:	1085883a 	add	r2,r2,r2
 90a72dc:	1085883a 	add	r2,r2,r2
 90a72e0:	10c5883a 	add	r2,r2,r3
 90a72e4:	10800017 	ldw	r2,0(r2)
 90a72e8:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 90a72ec:	0005883a 	mov	r2,zero
}
 90a72f0:	e037883a 	mov	sp,fp
 90a72f4:	df000017 	ldw	fp,0(sp)
 90a72f8:	dec00104 	addi	sp,sp,4
 90a72fc:	f800283a 	ret

090a7300 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 90a7300:	defff704 	addi	sp,sp,-36
 90a7304:	dfc00815 	stw	ra,32(sp)
 90a7308:	df000715 	stw	fp,28(sp)
 90a730c:	df000704 	addi	fp,sp,28
 90a7310:	e13ffc15 	stw	r4,-16(fp)
 90a7314:	e17ffd15 	stw	r5,-12(fp)
 90a7318:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 90a731c:	e13ffe17 	ldw	r4,-8(fp)
 90a7320:	000b883a 	mov	r5,zero
 90a7324:	90c3b880 	call	90c3b88 <udp_alloc>
 90a7328:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 90a732c:	e0bffa17 	ldw	r2,-24(fp)
 90a7330:	1004c03a 	cmpne	r2,r2,zero
 90a7334:	1000031e 	bne	r2,zero,90a7344 <dhc_decline+0x44>
      return ENP_NOMEM;
 90a7338:	00bffb04 	movi	r2,-20
 90a733c:	e0bfff15 	stw	r2,-4(fp)
 90a7340:	00002f06 	br	90a7400 <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 90a7344:	e0fffa17 	ldw	r3,-24(fp)
 90a7348:	e0bffe17 	ldw	r2,-8(fp)
 90a734c:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 90a7350:	e0bffa17 	ldw	r2,-24(fp)
 90a7354:	10800317 	ldw	r2,12(r2)
 90a7358:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 90a735c:	e0bffb17 	ldw	r2,-20(fp)
 90a7360:	e0fffd17 	ldw	r3,-12(fp)
 90a7364:	1009883a 	mov	r4,r2
 90a7368:	180b883a 	mov	r5,r3
 90a736c:	e1bffe17 	ldw	r6,-8(fp)
 90a7370:	90822780 	call	9082278 <memcpy>
   outbp->op = BOOTREQUEST;
 90a7374:	e0fffb17 	ldw	r3,-20(fp)
 90a7378:	00800044 	movi	r2,1
 90a737c:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 90a7380:	e0bffb17 	ldw	r2,-20(fp)
 90a7384:	10803b04 	addi	r2,r2,236
 90a7388:	11400104 	addi	r5,r2,4
 90a738c:	01000d44 	movi	r4,53
 90a7390:	90a84e80 	call	90a84e8 <find_opt>
 90a7394:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 90a7398:	e0bff917 	ldw	r2,-28(fp)
 90a739c:	10800084 	addi	r2,r2,2
 90a73a0:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 90a73a4:	e0fff917 	ldw	r3,-28(fp)
 90a73a8:	00800104 	movi	r2,4
 90a73ac:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 90a73b0:	e0fffa17 	ldw	r3,-24(fp)
 90a73b4:	00bfffc4 	movi	r2,-1
 90a73b8:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 90a73bc:	e0bffc17 	ldw	r2,-16(fp)
 90a73c0:	00c243b4 	movhi	r3,2318
 90a73c4:	18f41e04 	addi	r3,r3,-12168
 90a73c8:	1085883a 	add	r2,r2,r2
 90a73cc:	1085883a 	add	r2,r2,r2
 90a73d0:	10c5883a 	add	r2,r2,r3
 90a73d4:	10c00017 	ldw	r3,0(r2)
 90a73d8:	e0bffa17 	ldw	r2,-24(fp)
 90a73dc:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a73e0:	010010c4 	movi	r4,67
 90a73e4:	01401104 	movi	r5,68
 90a73e8:	e1bffa17 	ldw	r6,-24(fp)
 90a73ec:	90c36d00 	call	90c36d0 <udp_send>
   dsc_declines++;   /* count declines sent */
 90a73f0:	d0a09617 	ldw	r2,-32168(gp)
 90a73f4:	10800044 	addi	r2,r2,1
 90a73f8:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 90a73fc:	e03fff15 	stw	zero,-4(fp)
 90a7400:	e0bfff17 	ldw	r2,-4(fp)
}
 90a7404:	e037883a 	mov	sp,fp
 90a7408:	dfc00117 	ldw	ra,4(sp)
 90a740c:	df000017 	ldw	fp,0(sp)
 90a7410:	dec00204 	addi	sp,sp,8
 90a7414:	f800283a 	ret

090a7418 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 90a7418:	defffc04 	addi	sp,sp,-16
 90a741c:	df000315 	stw	fp,12(sp)
 90a7420:	df000304 	addi	fp,sp,12
 90a7424:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 90a7428:	e0bffe04 	addi	r2,fp,-8
 90a742c:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 90a7430:	e0bfff17 	ldw	r2,-4(fp)
 90a7434:	10c00003 	ldbu	r3,0(r2)
 90a7438:	e0bffd17 	ldw	r2,-12(fp)
 90a743c:	10c00005 	stb	r3,0(r2)
 90a7440:	e0bffd17 	ldw	r2,-12(fp)
 90a7444:	10800044 	addi	r2,r2,1
 90a7448:	e0bffd15 	stw	r2,-12(fp)
 90a744c:	e0bfff17 	ldw	r2,-4(fp)
 90a7450:	10800044 	addi	r2,r2,1
 90a7454:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a7458:	e0bfff17 	ldw	r2,-4(fp)
 90a745c:	10c00003 	ldbu	r3,0(r2)
 90a7460:	e0bffd17 	ldw	r2,-12(fp)
 90a7464:	10c00005 	stb	r3,0(r2)
 90a7468:	e0bffd17 	ldw	r2,-12(fp)
 90a746c:	10800044 	addi	r2,r2,1
 90a7470:	e0bffd15 	stw	r2,-12(fp)
 90a7474:	e0bfff17 	ldw	r2,-4(fp)
 90a7478:	10800044 	addi	r2,r2,1
 90a747c:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a7480:	e0bfff17 	ldw	r2,-4(fp)
 90a7484:	10c00003 	ldbu	r3,0(r2)
 90a7488:	e0bffd17 	ldw	r2,-12(fp)
 90a748c:	10c00005 	stb	r3,0(r2)
 90a7490:	e0bffd17 	ldw	r2,-12(fp)
 90a7494:	10800044 	addi	r2,r2,1
 90a7498:	e0bffd15 	stw	r2,-12(fp)
 90a749c:	e0bfff17 	ldw	r2,-4(fp)
 90a74a0:	10800044 	addi	r2,r2,1
 90a74a4:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a74a8:	e0bfff17 	ldw	r2,-4(fp)
 90a74ac:	10c00003 	ldbu	r3,0(r2)
 90a74b0:	e0bffd17 	ldw	r2,-12(fp)
 90a74b4:	10c00005 	stb	r3,0(r2)
 90a74b8:	e0bffd17 	ldw	r2,-12(fp)
 90a74bc:	10800044 	addi	r2,r2,1
 90a74c0:	e0bffd15 	stw	r2,-12(fp)
 90a74c4:	e0bfff17 	ldw	r2,-4(fp)
 90a74c8:	10800044 	addi	r2,r2,1
 90a74cc:	e0bfff15 	stw	r2,-4(fp)

   return v;
 90a74d0:	e0bffe17 	ldw	r2,-8(fp)
}
 90a74d4:	e037883a 	mov	sp,fp
 90a74d8:	df000017 	ldw	fp,0(sp)
 90a74dc:	dec00104 	addi	sp,sp,4
 90a74e0:	f800283a 	ret

090a74e4 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 90a74e4:	defff604 	addi	sp,sp,-40
 90a74e8:	dfc00915 	stw	ra,36(sp)
 90a74ec:	df000815 	stw	fp,32(sp)
 90a74f0:	dc400715 	stw	r17,28(sp)
 90a74f4:	dc000615 	stw	r16,24(sp)
 90a74f8:	df000604 	addi	fp,sp,24
 90a74fc:	e13ffc15 	stw	r4,-16(fp)
 90a7500:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 90a7504:	e0bffd17 	ldw	r2,-12(fp)
 90a7508:	10804e04 	addi	r2,r2,312
 90a750c:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 90a7510:	e0bffc17 	ldw	r2,-16(fp)
 90a7514:	00c243b4 	movhi	r3,2318
 90a7518:	18f44404 	addi	r3,r3,-12016
 90a751c:	10800f24 	muli	r2,r2,60
 90a7520:	10c5883a 	add	r2,r2,r3
 90a7524:	10800a04 	addi	r2,r2,40
 90a7528:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 90a752c:	e0bffc17 	ldw	r2,-16(fp)
 90a7530:	00c243b4 	movhi	r3,2318
 90a7534:	18f44404 	addi	r3,r3,-12016
 90a7538:	10800f24 	muli	r2,r2,60
 90a753c:	10c5883a 	add	r2,r2,r3
 90a7540:	10800b04 	addi	r2,r2,44
 90a7544:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 90a7548:	e0bffc17 	ldw	r2,-16(fp)
 90a754c:	00c243b4 	movhi	r3,2318
 90a7550:	18f44404 	addi	r3,r3,-12016
 90a7554:	10800f24 	muli	r2,r2,60
 90a7558:	10c5883a 	add	r2,r2,r3
 90a755c:	10800504 	addi	r2,r2,20
 90a7560:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 90a7564:	00008006 	br	90a7768 <dhc_extract_opts+0x284>
   {
      switch (*opts++)
 90a7568:	e0bffd17 	ldw	r2,-12(fp)
 90a756c:	10800003 	ldbu	r2,0(r2)
 90a7570:	10803fcc 	andi	r2,r2,255
 90a7574:	e0bfff15 	stw	r2,-4(fp)
 90a7578:	e0bffd17 	ldw	r2,-12(fp)
 90a757c:	10800044 	addi	r2,r2,1
 90a7580:	e0bffd15 	stw	r2,-12(fp)
 90a7584:	e0ffff17 	ldw	r3,-4(fp)
 90a7588:	188000e0 	cmpeqi	r2,r3,3
 90a758c:	1000271e 	bne	r2,zero,90a762c <dhc_extract_opts+0x148>
 90a7590:	e0ffff17 	ldw	r3,-4(fp)
 90a7594:	18800108 	cmpgei	r2,r3,4
 90a7598:	1000071e 	bne	r2,zero,90a75b8 <dhc_extract_opts+0xd4>
 90a759c:	e0ffff17 	ldw	r3,-4(fp)
 90a75a0:	1805003a 	cmpeq	r2,r3,zero
 90a75a4:	1000701e 	bne	r2,zero,90a7768 <dhc_extract_opts+0x284>
 90a75a8:	e0ffff17 	ldw	r3,-4(fp)
 90a75ac:	18800060 	cmpeqi	r2,r3,1
 90a75b0:	10000d1e 	bne	r2,zero,90a75e8 <dhc_extract_opts+0x104>
 90a75b4:	00006406 	br	90a7748 <dhc_extract_opts+0x264>
 90a75b8:	e0ffff17 	ldw	r3,-4(fp)
 90a75bc:	18800ce0 	cmpeqi	r2,r3,51
 90a75c0:	1000331e 	bne	r2,zero,90a7690 <dhc_extract_opts+0x1ac>
 90a75c4:	e0ffff17 	ldw	r3,-4(fp)
 90a75c8:	18803fe0 	cmpeqi	r2,r3,255
 90a75cc:	1000041e 	bne	r2,zero,90a75e0 <dhc_extract_opts+0xfc>
 90a75d0:	e0ffff17 	ldw	r3,-4(fp)
 90a75d4:	188001a0 	cmpeqi	r2,r3,6
 90a75d8:	10004f1e 	bne	r2,zero,90a7718 <dhc_extract_opts+0x234>
 90a75dc:	00005a06 	br	90a7748 <dhc_extract_opts+0x264>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 90a75e0:	e03ffe15 	stw	zero,-8(fp)
 90a75e4:	00006606 	br	90a7780 <dhc_extract_opts+0x29c>
      case DHOP_SNMASK:
         opts++;
 90a75e8:	e0bffd17 	ldw	r2,-12(fp)
 90a75ec:	10800044 	addi	r2,r2,1
 90a75f0:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 90a75f4:	e43ffc17 	ldw	r16,-16(fp)
 90a75f8:	e13ffd17 	ldw	r4,-12(fp)
 90a75fc:	90a74180 	call	90a7418 <dh_getlong>
 90a7600:	1009883a 	mov	r4,r2
 90a7604:	00c243b4 	movhi	r3,2318
 90a7608:	18f44404 	addi	r3,r3,-12016
 90a760c:	80800f24 	muli	r2,r16,60
 90a7610:	10c5883a 	add	r2,r2,r3
 90a7614:	10800a04 	addi	r2,r2,40
 90a7618:	11000015 	stw	r4,0(r2)
         opts += 4;
 90a761c:	e0bffd17 	ldw	r2,-12(fp)
 90a7620:	10800104 	addi	r2,r2,4
 90a7624:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a7628:	00004f06 	br	90a7768 <dhc_extract_opts+0x284>
      case DHOP_ROUTER:
         optlen = *opts++;
 90a762c:	e0bffd17 	ldw	r2,-12(fp)
 90a7630:	10800003 	ldbu	r2,0(r2)
 90a7634:	e0bffa05 	stb	r2,-24(fp)
 90a7638:	e0bffd17 	ldw	r2,-12(fp)
 90a763c:	10800044 	addi	r2,r2,1
 90a7640:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 90a7644:	e0bffa03 	ldbu	r2,-24(fp)
 90a7648:	10800130 	cmpltui	r2,r2,4
 90a764c:	10000a1e 	bne	r2,zero,90a7678 <dhc_extract_opts+0x194>
            dhc_states[iface].defgw = dh_getlong(opts);
 90a7650:	e43ffc17 	ldw	r16,-16(fp)
 90a7654:	e13ffd17 	ldw	r4,-12(fp)
 90a7658:	90a74180 	call	90a7418 <dh_getlong>
 90a765c:	1009883a 	mov	r4,r2
 90a7660:	00c243b4 	movhi	r3,2318
 90a7664:	18f44404 	addi	r3,r3,-12016
 90a7668:	80800f24 	muli	r2,r16,60
 90a766c:	10c5883a 	add	r2,r2,r3
 90a7670:	10800b04 	addi	r2,r2,44
 90a7674:	11000015 	stw	r4,0(r2)
         opts += optlen;
 90a7678:	e0bffa03 	ldbu	r2,-24(fp)
 90a767c:	1007883a 	mov	r3,r2
 90a7680:	e0bffd17 	ldw	r2,-12(fp)
 90a7684:	10c5883a 	add	r2,r2,r3
 90a7688:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a768c:	00003606 	br	90a7768 <dhc_extract_opts+0x284>
      case DHOP_LEASE:
         opts++;
 90a7690:	e0bffd17 	ldw	r2,-12(fp)
 90a7694:	10800044 	addi	r2,r2,1
 90a7698:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 90a769c:	e47ffc17 	ldw	r17,-16(fp)
 90a76a0:	e13ffd17 	ldw	r4,-12(fp)
 90a76a4:	90a74180 	call	90a7418 <dh_getlong>
 90a76a8:	1005d63a 	srai	r2,r2,24
 90a76ac:	14003fcc 	andi	r16,r2,255
 90a76b0:	e13ffd17 	ldw	r4,-12(fp)
 90a76b4:	90a74180 	call	90a7418 <dh_getlong>
 90a76b8:	1005d23a 	srai	r2,r2,8
 90a76bc:	10bfc00c 	andi	r2,r2,65280
 90a76c0:	80a0b03a 	or	r16,r16,r2
 90a76c4:	e13ffd17 	ldw	r4,-12(fp)
 90a76c8:	90a74180 	call	90a7418 <dh_getlong>
 90a76cc:	10bfc00c 	andi	r2,r2,65280
 90a76d0:	1004923a 	slli	r2,r2,8
 90a76d4:	80a0b03a 	or	r16,r16,r2
 90a76d8:	e13ffd17 	ldw	r4,-12(fp)
 90a76dc:	90a74180 	call	90a7418 <dh_getlong>
 90a76e0:	10803fcc 	andi	r2,r2,255
 90a76e4:	1004963a 	slli	r2,r2,24
 90a76e8:	8084b03a 	or	r2,r16,r2
 90a76ec:	1009883a 	mov	r4,r2
 90a76f0:	00c243b4 	movhi	r3,2318
 90a76f4:	18f44404 	addi	r3,r3,-12016
 90a76f8:	88800f24 	muli	r2,r17,60
 90a76fc:	10c5883a 	add	r2,r2,r3
 90a7700:	10800504 	addi	r2,r2,20
 90a7704:	11000015 	stw	r4,0(r2)
         opts += 4;
 90a7708:	e0bffd17 	ldw	r2,-12(fp)
 90a770c:	10800104 	addi	r2,r2,4
 90a7710:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a7714:	00001406 	br	90a7768 <dhc_extract_opts+0x284>
      case DHOP_DNSRV:
         optlen = *opts++;
 90a7718:	e0bffd17 	ldw	r2,-12(fp)
 90a771c:	10800003 	ldbu	r2,0(r2)
 90a7720:	e0bffa05 	stb	r2,-24(fp)
 90a7724:	e0bffd17 	ldw	r2,-12(fp)
 90a7728:	10800044 	addi	r2,r2,1
 90a772c:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 90a7730:	e0bffa03 	ldbu	r2,-24(fp)
 90a7734:	1007883a 	mov	r3,r2
 90a7738:	e0bffd17 	ldw	r2,-12(fp)
 90a773c:	10c5883a 	add	r2,r2,r3
 90a7740:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a7744:	00000806 	br	90a7768 <dhc_extract_opts+0x284>
      default:
         opts += ((*opts) + 1);
 90a7748:	e0bffd17 	ldw	r2,-12(fp)
 90a774c:	10800003 	ldbu	r2,0(r2)
 90a7750:	10803fcc 	andi	r2,r2,255
 90a7754:	1007883a 	mov	r3,r2
 90a7758:	e0bffd17 	ldw	r2,-12(fp)
 90a775c:	1885883a 	add	r2,r3,r2
 90a7760:	10800044 	addi	r2,r2,1
 90a7764:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 90a7768:	e0fffd17 	ldw	r3,-12(fp)
 90a776c:	e0bffb17 	ldw	r2,-20(fp)
 90a7770:	10ff7d2e 	bgeu	r2,r3,90a7568 <dhc_extract_opts+0x84>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 90a7774:	90a94880 	call	90a9488 <dtrap>
   return -1;
 90a7778:	00bfffc4 	movi	r2,-1
 90a777c:	e0bffe15 	stw	r2,-8(fp)
 90a7780:	e0bffe17 	ldw	r2,-8(fp)
}
 90a7784:	e037883a 	mov	sp,fp
 90a7788:	dfc00317 	ldw	ra,12(sp)
 90a778c:	df000217 	ldw	fp,8(sp)
 90a7790:	dc400117 	ldw	r17,4(sp)
 90a7794:	dc000017 	ldw	r16,0(sp)
 90a7798:	dec00404 	addi	sp,sp,16
 90a779c:	f800283a 	ret

090a77a0 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 90a77a0:	defff504 	addi	sp,sp,-44
 90a77a4:	dfc00a15 	stw	ra,40(sp)
 90a77a8:	df000915 	stw	fp,36(sp)
 90a77ac:	dc400815 	stw	r17,32(sp)
 90a77b0:	dc000715 	stw	r16,28(sp)
 90a77b4:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 90a77b8:	e03ffc15 	stw	zero,-16(fp)
 90a77bc:	00022306 	br	90a804c <dhc_second+0x8ac>
   {
      switch (dhc_states[iface].state)
 90a77c0:	e0bffc17 	ldw	r2,-16(fp)
 90a77c4:	00c243b4 	movhi	r3,2318
 90a77c8:	18f44404 	addi	r3,r3,-12016
 90a77cc:	10800f24 	muli	r2,r2,60
 90a77d0:	10c5883a 	add	r2,r2,r3
 90a77d4:	10800017 	ldw	r2,0(r2)
 90a77d8:	e0bfff15 	stw	r2,-4(fp)
 90a77dc:	e0ffff17 	ldw	r3,-4(fp)
 90a77e0:	18800268 	cmpgeui	r2,r3,9
 90a77e4:	1002161e 	bne	r2,zero,90a8040 <dhc_second+0x8a0>
 90a77e8:	e13fff17 	ldw	r4,-4(fp)
 90a77ec:	e13fff17 	ldw	r4,-4(fp)
 90a77f0:	2105883a 	add	r2,r4,r4
 90a77f4:	1087883a 	add	r3,r2,r2
 90a77f8:	008242b4 	movhi	r2,2314
 90a77fc:	109e0304 	addi	r2,r2,30732
 90a7800:	1885883a 	add	r2,r3,r2
 90a7804:	10800017 	ldw	r2,0(r2)
 90a7808:	1000683a 	jmp	r2
 90a780c:	090a8040 	call	90a804 <OSCtxSw_SWITCH_PC+0x90a7c4>
 90a7810:	090a7830 	cmpltui	r4,at,10720
 90a7814:	090a7868 	cmpgeui	r4,at,10721
 90a7818:	090a78a0 	cmpeqi	r4,at,10722
 90a781c:	090a78a0 	cmpeqi	r4,at,10722
 90a7820:	090a78a0 	cmpeqi	r4,at,10722
 90a7824:	090a7c5c 	xori	r4,at,10737
 90a7828:	090a7d94 	ori	r4,at,10742
 90a782c:	090a79d0 	cmplti	r4,at,10727
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 90a7830:	e13ffc17 	ldw	r4,-16(fp)
 90a7834:	90a5e2c0 	call	90a5e2c <dhc_discover>
 90a7838:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 90a783c:	e0bffa17 	ldw	r2,-24(fp)
 90a7840:	1005003a 	cmpeq	r2,r2,zero
 90a7844:	1000041e 	bne	r2,zero,90a7858 <dhc_second+0xb8>
         {
            dtrap();
 90a7848:	90a94880 	call	90a9488 <dtrap>
            return e;
 90a784c:	e0bffa17 	ldw	r2,-24(fp)
 90a7850:	e0bffe15 	stw	r2,-8(fp)
 90a7854:	00020106 	br	90a805c <dhc_second+0x8bc>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 90a7858:	e13ffc17 	ldw	r4,-16(fp)
 90a785c:	01400104 	movi	r5,4
 90a7860:	90a84380 	call	90a8438 <dhc_set_state>
         break;
 90a7864:	0001f606 	br	90a8040 <dhc_second+0x8a0>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 90a7868:	e13ffc17 	ldw	r4,-16(fp)
 90a786c:	90a81040 	call	90a8104 <dhc_reclaim>
 90a7870:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 90a7874:	e0bffa17 	ldw	r2,-24(fp)
 90a7878:	1005003a 	cmpeq	r2,r2,zero
 90a787c:	1000041e 	bne	r2,zero,90a7890 <dhc_second+0xf0>
         {
            dtrap();
 90a7880:	90a94880 	call	90a9488 <dtrap>
            return e;
 90a7884:	e0fffa17 	ldw	r3,-24(fp)
 90a7888:	e0fffe15 	stw	r3,-8(fp)
 90a788c:	0001f306 	br	90a805c <dhc_second+0x8bc>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 90a7890:	e13ffc17 	ldw	r4,-16(fp)
 90a7894:	014000c4 	movi	r5,3
 90a7898:	90a84380 	call	90a8438 <dhc_set_state>
         break;
 90a789c:	0001e806 	br	90a8040 <dhc_second+0x8a0>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 90a78a0:	e0bffc17 	ldw	r2,-16(fp)
 90a78a4:	00c243b4 	movhi	r3,2318
 90a78a8:	18f44404 	addi	r3,r3,-12016
 90a78ac:	10800f24 	muli	r2,r2,60
 90a78b0:	10c5883a 	add	r2,r2,r3
 90a78b4:	10800104 	addi	r2,r2,4
 90a78b8:	10800017 	ldw	r2,0(r2)
 90a78bc:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 90a78c0:	e0bffb17 	ldw	r2,-20(fp)
 90a78c4:	10800110 	cmplti	r2,r2,4
 90a78c8:	1000021e 	bne	r2,zero,90a78d4 <dhc_second+0x134>
            tries= DHC_MAX_TRIES;
 90a78cc:	00800104 	movi	r2,4
 90a78d0:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 90a78d4:	e0bffc17 	ldw	r2,-16(fp)
 90a78d8:	00c243b4 	movhi	r3,2318
 90a78dc:	18f44404 	addi	r3,r3,-12016
 90a78e0:	10800f24 	muli	r2,r2,60
 90a78e4:	10c5883a 	add	r2,r2,r3
 90a78e8:	10800404 	addi	r2,r2,16
 90a78ec:	11000017 	ldw	r4,0(r2)
 90a78f0:	00c06404 	movi	r3,400
 90a78f4:	e0bffb17 	ldw	r2,-20(fp)
 90a78f8:	1884983a 	sll	r2,r3,r2
 90a78fc:	2087883a 	add	r3,r4,r2
 90a7900:	00824374 	movhi	r2,2317
 90a7904:	108c4204 	addi	r2,r2,12552
 90a7908:	10800017 	ldw	r2,0(r2)
 90a790c:	18801c2e 	bgeu	r3,r2,90a7980 <dhc_second+0x1e0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 90a7910:	e0bffc17 	ldw	r2,-16(fp)
 90a7914:	00c243b4 	movhi	r3,2318
 90a7918:	18f44404 	addi	r3,r3,-12016
 90a791c:	10800f24 	muli	r2,r2,60
 90a7920:	10c5883a 	add	r2,r2,r3
 90a7924:	10800017 	ldw	r2,0(r2)
 90a7928:	e0bffd15 	stw	r2,-12(fp)
 90a792c:	e13ffd17 	ldw	r4,-12(fp)
 90a7930:	20800120 	cmpeqi	r2,r4,4
 90a7934:	1000071e 	bne	r2,zero,90a7954 <dhc_second+0x1b4>
 90a7938:	e0fffd17 	ldw	r3,-12(fp)
 90a793c:	18800160 	cmpeqi	r2,r3,5
 90a7940:	1000071e 	bne	r2,zero,90a7960 <dhc_second+0x1c0>
 90a7944:	e13ffd17 	ldw	r4,-12(fp)
 90a7948:	208000e0 	cmpeqi	r2,r4,3
 90a794c:	1000081e 	bne	r2,zero,90a7970 <dhc_second+0x1d0>
 90a7950:	00000a06 	br	90a797c <dhc_second+0x1dc>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 90a7954:	e13ffc17 	ldw	r4,-16(fp)
 90a7958:	90a5e2c0 	call	90a5e2c <dhc_discover>
               break;
 90a795c:	00000806 	br	90a7980 <dhc_second+0x1e0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 90a7960:	e13ffc17 	ldw	r4,-16(fp)
 90a7964:	000b883a 	mov	r5,zero
 90a7968:	90a64600 	call	90a6460 <dhc_request>
               break;
 90a796c:	00000406 	br	90a7980 <dhc_second+0x1e0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 90a7970:	e13ffc17 	ldw	r4,-16(fp)
 90a7974:	90a81040 	call	90a8104 <dhc_reclaim>
               break;
 90a7978:	00000106 	br	90a7980 <dhc_second+0x1e0>
            default:
               dtrap(); /* bogus state */
 90a797c:	90a94880 	call	90a9488 <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 90a7980:	e0bffb17 	ldw	r2,-20(fp)
 90a7984:	10800118 	cmpnei	r2,r2,4
 90a7988:	1001ad1e 	bne	r2,zero,90a8040 <dhc_second+0x8a0>
 90a798c:	e0bffc17 	ldw	r2,-16(fp)
 90a7990:	00c243b4 	movhi	r3,2318
 90a7994:	18f44404 	addi	r3,r3,-12016
 90a7998:	10800f24 	muli	r2,r2,60
 90a799c:	10c5883a 	add	r2,r2,r3
 90a79a0:	10800017 	ldw	r2,0(r2)
 90a79a4:	10800120 	cmpeqi	r2,r2,4
 90a79a8:	1001a51e 	bne	r2,zero,90a8040 <dhc_second+0x8a0>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 90a79ac:	e13ffc17 	ldw	r4,-16(fp)
 90a79b0:	01400244 	movi	r5,9
 90a79b4:	90a84380 	call	90a8438 <dhc_set_state>
            dhc_resetip(iface);
 90a79b8:	e13ffc17 	ldw	r4,-16(fp)
 90a79bc:	90a721c0 	call	90a721c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 90a79c0:	e13ffc17 	ldw	r4,-16(fp)
 90a79c4:	01400044 	movi	r5,1
 90a79c8:	90a84380 	call	90a8438 <dhc_set_state>
         }
         break;
 90a79cc:	00019c06 	br	90a8040 <dhc_second+0x8a0>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 90a79d0:	e0bffc17 	ldw	r2,-16(fp)
 90a79d4:	00c243b4 	movhi	r3,2318
 90a79d8:	18f44404 	addi	r3,r3,-12016
 90a79dc:	10800f24 	muli	r2,r2,60
 90a79e0:	10c5883a 	add	r2,r2,r3
 90a79e4:	10800504 	addi	r2,r2,20
 90a79e8:	11000017 	ldw	r4,0(r2)
 90a79ec:	908c0380 	call	908c038 <__floatunsidf>
 90a79f0:	100b883a 	mov	r5,r2
 90a79f4:	180d883a 	mov	r6,r3
 90a79f8:	2809883a 	mov	r4,r5
 90a79fc:	300b883a 	mov	r5,r6
 90a7a00:	000d883a 	mov	r6,zero
 90a7a04:	01d01674 	movhi	r7,16473
 90a7a08:	908b5b40 	call	908b5b4 <__muldf3>
 90a7a0c:	1009883a 	mov	r4,r2
 90a7a10:	180b883a 	mov	r5,r3
 90a7a14:	2021883a 	mov	r16,r4
 90a7a18:	2823883a 	mov	r17,r5
 90a7a1c:	e0bffc17 	ldw	r2,-16(fp)
 90a7a20:	00c243b4 	movhi	r3,2318
 90a7a24:	18f44404 	addi	r3,r3,-12016
 90a7a28:	10800f24 	muli	r2,r2,60
 90a7a2c:	10c5883a 	add	r2,r2,r3
 90a7a30:	10800804 	addi	r2,r2,32
 90a7a34:	11000017 	ldw	r4,0(r2)
 90a7a38:	908c0380 	call	908c038 <__floatunsidf>
 90a7a3c:	100f883a 	mov	r7,r2
 90a7a40:	1811883a 	mov	r8,r3
 90a7a44:	8009883a 	mov	r4,r16
 90a7a48:	880b883a 	mov	r5,r17
 90a7a4c:	380d883a 	mov	r6,r7
 90a7a50:	400f883a 	mov	r7,r8
 90a7a54:	908b5400 	call	908b540 <__adddf3>
 90a7a58:	1009883a 	mov	r4,r2
 90a7a5c:	180b883a 	mov	r5,r3
 90a7a60:	2021883a 	mov	r16,r4
 90a7a64:	2823883a 	mov	r17,r5
 90a7a68:	00824374 	movhi	r2,2317
 90a7a6c:	108c4204 	addi	r2,r2,12552
 90a7a70:	11000017 	ldw	r4,0(r2)
 90a7a74:	908c0380 	call	908c038 <__floatunsidf>
 90a7a78:	100f883a 	mov	r7,r2
 90a7a7c:	1811883a 	mov	r8,r3
 90a7a80:	8009883a 	mov	r4,r16
 90a7a84:	880b883a 	mov	r5,r17
 90a7a88:	380d883a 	mov	r6,r7
 90a7a8c:	400f883a 	mov	r7,r8
 90a7a90:	908bcd00 	call	908bcd0 <__gtdf2>
 90a7a94:	10800048 	cmpgei	r2,r2,1
 90a7a98:	1000011e 	bne	r2,zero,90a7aa0 <dhc_second+0x300>
 90a7a9c:	00006606 	br	90a7c38 <dhc_second+0x498>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 90a7aa0:	e0bffc17 	ldw	r2,-16(fp)
 90a7aa4:	00c243b4 	movhi	r3,2318
 90a7aa8:	18f44404 	addi	r3,r3,-12016
 90a7aac:	10800f24 	muli	r2,r2,60
 90a7ab0:	10c5883a 	add	r2,r2,r3
 90a7ab4:	10800804 	addi	r2,r2,32
 90a7ab8:	11000017 	ldw	r4,0(r2)
 90a7abc:	908c0380 	call	908c038 <__floatunsidf>
 90a7ac0:	1021883a 	mov	r16,r2
 90a7ac4:	1823883a 	mov	r17,r3
 90a7ac8:	e0bffc17 	ldw	r2,-16(fp)
 90a7acc:	00c243b4 	movhi	r3,2318
 90a7ad0:	18f44404 	addi	r3,r3,-12016
 90a7ad4:	10800f24 	muli	r2,r2,60
 90a7ad8:	10c5883a 	add	r2,r2,r3
 90a7adc:	10800504 	addi	r2,r2,20
 90a7ae0:	11000017 	ldw	r4,0(r2)
 90a7ae4:	908c0380 	call	908c038 <__floatunsidf>
 90a7ae8:	100b883a 	mov	r5,r2
 90a7aec:	180d883a 	mov	r6,r3
 90a7af0:	2809883a 	mov	r4,r5
 90a7af4:	300b883a 	mov	r5,r6
 90a7af8:	000d883a 	mov	r6,zero
 90a7afc:	01d01674 	movhi	r7,16473
 90a7b00:	908b5b40 	call	908b5b4 <__muldf3>
 90a7b04:	1009883a 	mov	r4,r2
 90a7b08:	180b883a 	mov	r5,r3
 90a7b0c:	2005883a 	mov	r2,r4
 90a7b10:	2807883a 	mov	r3,r5
 90a7b14:	8009883a 	mov	r4,r16
 90a7b18:	880b883a 	mov	r5,r17
 90a7b1c:	100d883a 	mov	r6,r2
 90a7b20:	180f883a 	mov	r7,r3
 90a7b24:	908b5400 	call	908b540 <__adddf3>
 90a7b28:	1009883a 	mov	r4,r2
 90a7b2c:	180b883a 	mov	r5,r3
 90a7b30:	2021883a 	mov	r16,r4
 90a7b34:	2823883a 	mov	r17,r5
 90a7b38:	e0bffc17 	ldw	r2,-16(fp)
 90a7b3c:	00c243b4 	movhi	r3,2318
 90a7b40:	18f44404 	addi	r3,r3,-12016
 90a7b44:	10800f24 	muli	r2,r2,60
 90a7b48:	10c5883a 	add	r2,r2,r3
 90a7b4c:	10800404 	addi	r2,r2,16
 90a7b50:	11000017 	ldw	r4,0(r2)
 90a7b54:	908c0380 	call	908c038 <__floatunsidf>
 90a7b58:	100f883a 	mov	r7,r2
 90a7b5c:	1811883a 	mov	r8,r3
 90a7b60:	8009883a 	mov	r4,r16
 90a7b64:	880b883a 	mov	r5,r17
 90a7b68:	380d883a 	mov	r6,r7
 90a7b6c:	400f883a 	mov	r7,r8
 90a7b70:	908b4c00 	call	908b4c0 <__subdf3>
 90a7b74:	1009883a 	mov	r4,r2
 90a7b78:	180b883a 	mov	r5,r3
 90a7b7c:	2005883a 	mov	r2,r4
 90a7b80:	2807883a 	mov	r3,r5
 90a7b84:	1009883a 	mov	r4,r2
 90a7b88:	180b883a 	mov	r5,r3
 90a7b8c:	000d883a 	mov	r6,zero
 90a7b90:	01d00034 	movhi	r7,16384
 90a7b94:	908b9680 	call	908b968 <__divdf3>
 90a7b98:	1009883a 	mov	r4,r2
 90a7b9c:	180b883a 	mov	r5,r3
 90a7ba0:	2005883a 	mov	r2,r4
 90a7ba4:	2807883a 	mov	r3,r5
 90a7ba8:	1009883a 	mov	r4,r2
 90a7bac:	180b883a 	mov	r5,r3
 90a7bb0:	90cade40 	call	90cade4 <__fixunsdfsi>
 90a7bb4:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 90a7bb8:	e13ff917 	ldw	r4,-28(fp)
 90a7bbc:	908c0380 	call	908c038 <__floatunsidf>
 90a7bc0:	100b883a 	mov	r5,r2
 90a7bc4:	180d883a 	mov	r6,r3
 90a7bc8:	2809883a 	mov	r4,r5
 90a7bcc:	300b883a 	mov	r5,r6
 90a7bd0:	000d883a 	mov	r6,zero
 90a7bd4:	01d02df4 	movhi	r7,16567
 90a7bd8:	39dc0004 	addi	r7,r7,28672
 90a7bdc:	908bde00 	call	908bde0 <__ltdf2>
 90a7be0:	1004803a 	cmplt	r2,r2,zero
 90a7be4:	1000011e 	bne	r2,zero,90a7bec <dhc_second+0x44c>
 90a7be8:	00000206 	br	90a7bf4 <dhc_second+0x454>
               half_time = 60*TPS;
 90a7bec:	0085dc04 	movi	r2,6000
 90a7bf0:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 90a7bf4:	e0bffc17 	ldw	r2,-16(fp)
 90a7bf8:	00c243b4 	movhi	r3,2318
 90a7bfc:	18f44404 	addi	r3,r3,-12016
 90a7c00:	10800f24 	muli	r2,r2,60
 90a7c04:	10c5883a 	add	r2,r2,r3
 90a7c08:	10800404 	addi	r2,r2,16
 90a7c0c:	10c00017 	ldw	r3,0(r2)
 90a7c10:	e0bff917 	ldw	r2,-28(fp)
 90a7c14:	1887883a 	add	r3,r3,r2
 90a7c18:	00824374 	movhi	r2,2317
 90a7c1c:	108c4204 	addi	r2,r2,12552
 90a7c20:	10800017 	ldw	r2,0(r2)
 90a7c24:	1881062e 	bgeu	r3,r2,90a8040 <dhc_second+0x8a0>
            {
               dhc_request(iface,FALSE);
 90a7c28:	e13ffc17 	ldw	r4,-16(fp)
 90a7c2c:	000b883a 	mov	r5,zero
 90a7c30:	90a64600 	call	90a6460 <dhc_request>
 90a7c34:	00010206 	br	90a8040 <dhc_second+0x8a0>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 90a7c38:	e13ffc17 	ldw	r4,-16(fp)
 90a7c3c:	01400244 	movi	r5,9
 90a7c40:	90a84380 	call	90a8438 <dhc_set_state>
            dhc_resetip(iface);
 90a7c44:	e13ffc17 	ldw	r4,-16(fp)
 90a7c48:	90a721c0 	call	90a721c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 90a7c4c:	e13ffc17 	ldw	r4,-16(fp)
 90a7c50:	01400044 	movi	r5,1
 90a7c54:	90a84380 	call	90a8438 <dhc_set_state>
         }
         break;
 90a7c58:	0000f906 	br	90a8040 <dhc_second+0x8a0>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 90a7c5c:	e0bffc17 	ldw	r2,-16(fp)
 90a7c60:	00c243b4 	movhi	r3,2318
 90a7c64:	18f44404 	addi	r3,r3,-12016
 90a7c68:	10800f24 	muli	r2,r2,60
 90a7c6c:	10c5883a 	add	r2,r2,r3
 90a7c70:	10800604 	addi	r2,r2,24
 90a7c74:	10800017 	ldw	r2,0(r2)
 90a7c78:	10bfffe0 	cmpeqi	r2,r2,-1
 90a7c7c:	1000f01e 	bne	r2,zero,90a8040 <dhc_second+0x8a0>
 90a7c80:	e0bffc17 	ldw	r2,-16(fp)
 90a7c84:	00c243b4 	movhi	r3,2318
 90a7c88:	18f44404 	addi	r3,r3,-12016
 90a7c8c:	10800f24 	muli	r2,r2,60
 90a7c90:	10c5883a 	add	r2,r2,r3
 90a7c94:	10800604 	addi	r2,r2,24
 90a7c98:	11000017 	ldw	r4,0(r2)
 90a7c9c:	908c0380 	call	908c038 <__floatunsidf>
 90a7ca0:	100b883a 	mov	r5,r2
 90a7ca4:	180d883a 	mov	r6,r3
 90a7ca8:	2809883a 	mov	r4,r5
 90a7cac:	300b883a 	mov	r5,r6
 90a7cb0:	000d883a 	mov	r6,zero
 90a7cb4:	01d01674 	movhi	r7,16473
 90a7cb8:	908b5b40 	call	908b5b4 <__muldf3>
 90a7cbc:	1009883a 	mov	r4,r2
 90a7cc0:	180b883a 	mov	r5,r3
 90a7cc4:	2021883a 	mov	r16,r4
 90a7cc8:	2823883a 	mov	r17,r5
 90a7ccc:	e0bffc17 	ldw	r2,-16(fp)
 90a7cd0:	00c243b4 	movhi	r3,2318
 90a7cd4:	18f44404 	addi	r3,r3,-12016
 90a7cd8:	10800f24 	muli	r2,r2,60
 90a7cdc:	10c5883a 	add	r2,r2,r3
 90a7ce0:	10800804 	addi	r2,r2,32
 90a7ce4:	11000017 	ldw	r4,0(r2)
 90a7ce8:	908c0380 	call	908c038 <__floatunsidf>
 90a7cec:	100f883a 	mov	r7,r2
 90a7cf0:	1811883a 	mov	r8,r3
 90a7cf4:	8009883a 	mov	r4,r16
 90a7cf8:	880b883a 	mov	r5,r17
 90a7cfc:	380d883a 	mov	r6,r7
 90a7d00:	400f883a 	mov	r7,r8
 90a7d04:	908b5400 	call	908b540 <__adddf3>
 90a7d08:	1009883a 	mov	r4,r2
 90a7d0c:	180b883a 	mov	r5,r3
 90a7d10:	2021883a 	mov	r16,r4
 90a7d14:	2823883a 	mov	r17,r5
 90a7d18:	00824374 	movhi	r2,2317
 90a7d1c:	108c4204 	addi	r2,r2,12552
 90a7d20:	11000017 	ldw	r4,0(r2)
 90a7d24:	908c0380 	call	908c038 <__floatunsidf>
 90a7d28:	100f883a 	mov	r7,r2
 90a7d2c:	1811883a 	mov	r8,r3
 90a7d30:	8009883a 	mov	r4,r16
 90a7d34:	880b883a 	mov	r5,r17
 90a7d38:	380d883a 	mov	r6,r7
 90a7d3c:	400f883a 	mov	r7,r8
 90a7d40:	908bde00 	call	908bde0 <__ltdf2>
 90a7d44:	1004803a 	cmplt	r2,r2,zero
 90a7d48:	1000011e 	bne	r2,zero,90a7d50 <dhc_second+0x5b0>
 90a7d4c:	0000bc06 	br	90a8040 <dhc_second+0x8a0>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 90a7d50:	e13ffc17 	ldw	r4,-16(fp)
 90a7d54:	014001c4 	movi	r5,7
 90a7d58:	90a84380 	call	90a8438 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 90a7d5c:	e13ffc17 	ldw	r4,-16(fp)
 90a7d60:	90a81040 	call	90a8104 <dhc_reclaim>
 90a7d64:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 90a7d68:	e0bffa17 	ldw	r2,-24(fp)
 90a7d6c:	1005003a 	cmpeq	r2,r2,zero
 90a7d70:	1000041e 	bne	r2,zero,90a7d84 <dhc_second+0x5e4>
            {
               dtrap();
 90a7d74:	90a94880 	call	90a9488 <dtrap>
               return e;
 90a7d78:	e0bffa17 	ldw	r2,-24(fp)
 90a7d7c:	e0bffe15 	stw	r2,-8(fp)
 90a7d80:	0000b606 	br	90a805c <dhc_second+0x8bc>
            }
            dsc_renew++;
 90a7d84:	d0a09917 	ldw	r2,-32156(gp)
 90a7d88:	10800044 	addi	r2,r2,1
 90a7d8c:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 90a7d90:	0000ab06 	br	90a8040 <dhc_second+0x8a0>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 90a7d94:	e0bffc17 	ldw	r2,-16(fp)
 90a7d98:	00c243b4 	movhi	r3,2318
 90a7d9c:	18f44404 	addi	r3,r3,-12016
 90a7da0:	10800f24 	muli	r2,r2,60
 90a7da4:	10c5883a 	add	r2,r2,r3
 90a7da8:	10800704 	addi	r2,r2,28
 90a7dac:	11000017 	ldw	r4,0(r2)
 90a7db0:	908c0380 	call	908c038 <__floatunsidf>
 90a7db4:	100b883a 	mov	r5,r2
 90a7db8:	180d883a 	mov	r6,r3
 90a7dbc:	2809883a 	mov	r4,r5
 90a7dc0:	300b883a 	mov	r5,r6
 90a7dc4:	000d883a 	mov	r6,zero
 90a7dc8:	01d01674 	movhi	r7,16473
 90a7dcc:	908b5b40 	call	908b5b4 <__muldf3>
 90a7dd0:	1009883a 	mov	r4,r2
 90a7dd4:	180b883a 	mov	r5,r3
 90a7dd8:	2021883a 	mov	r16,r4
 90a7ddc:	2823883a 	mov	r17,r5
 90a7de0:	e0bffc17 	ldw	r2,-16(fp)
 90a7de4:	00c243b4 	movhi	r3,2318
 90a7de8:	18f44404 	addi	r3,r3,-12016
 90a7dec:	10800f24 	muli	r2,r2,60
 90a7df0:	10c5883a 	add	r2,r2,r3
 90a7df4:	10800804 	addi	r2,r2,32
 90a7df8:	11000017 	ldw	r4,0(r2)
 90a7dfc:	908c0380 	call	908c038 <__floatunsidf>
 90a7e00:	100f883a 	mov	r7,r2
 90a7e04:	1811883a 	mov	r8,r3
 90a7e08:	8009883a 	mov	r4,r16
 90a7e0c:	880b883a 	mov	r5,r17
 90a7e10:	380d883a 	mov	r6,r7
 90a7e14:	400f883a 	mov	r7,r8
 90a7e18:	908b5400 	call	908b540 <__adddf3>
 90a7e1c:	1009883a 	mov	r4,r2
 90a7e20:	180b883a 	mov	r5,r3
 90a7e24:	2021883a 	mov	r16,r4
 90a7e28:	2823883a 	mov	r17,r5
 90a7e2c:	00824374 	movhi	r2,2317
 90a7e30:	108c4204 	addi	r2,r2,12552
 90a7e34:	11000017 	ldw	r4,0(r2)
 90a7e38:	908c0380 	call	908c038 <__floatunsidf>
 90a7e3c:	100f883a 	mov	r7,r2
 90a7e40:	1811883a 	mov	r8,r3
 90a7e44:	8009883a 	mov	r4,r16
 90a7e48:	880b883a 	mov	r5,r17
 90a7e4c:	380d883a 	mov	r6,r7
 90a7e50:	400f883a 	mov	r7,r8
 90a7e54:	908bcd00 	call	908bcd0 <__gtdf2>
 90a7e58:	10800048 	cmpgei	r2,r2,1
 90a7e5c:	1000011e 	bne	r2,zero,90a7e64 <dhc_second+0x6c4>
 90a7e60:	00006606 	br	90a7ffc <dhc_second+0x85c>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 90a7e64:	e0bffc17 	ldw	r2,-16(fp)
 90a7e68:	00c243b4 	movhi	r3,2318
 90a7e6c:	18f44404 	addi	r3,r3,-12016
 90a7e70:	10800f24 	muli	r2,r2,60
 90a7e74:	10c5883a 	add	r2,r2,r3
 90a7e78:	10800804 	addi	r2,r2,32
 90a7e7c:	11000017 	ldw	r4,0(r2)
 90a7e80:	908c0380 	call	908c038 <__floatunsidf>
 90a7e84:	1021883a 	mov	r16,r2
 90a7e88:	1823883a 	mov	r17,r3
 90a7e8c:	e0bffc17 	ldw	r2,-16(fp)
 90a7e90:	00c243b4 	movhi	r3,2318
 90a7e94:	18f44404 	addi	r3,r3,-12016
 90a7e98:	10800f24 	muli	r2,r2,60
 90a7e9c:	10c5883a 	add	r2,r2,r3
 90a7ea0:	10800704 	addi	r2,r2,28
 90a7ea4:	11000017 	ldw	r4,0(r2)
 90a7ea8:	908c0380 	call	908c038 <__floatunsidf>
 90a7eac:	100b883a 	mov	r5,r2
 90a7eb0:	180d883a 	mov	r6,r3
 90a7eb4:	2809883a 	mov	r4,r5
 90a7eb8:	300b883a 	mov	r5,r6
 90a7ebc:	000d883a 	mov	r6,zero
 90a7ec0:	01d01674 	movhi	r7,16473
 90a7ec4:	908b5b40 	call	908b5b4 <__muldf3>
 90a7ec8:	1009883a 	mov	r4,r2
 90a7ecc:	180b883a 	mov	r5,r3
 90a7ed0:	2005883a 	mov	r2,r4
 90a7ed4:	2807883a 	mov	r3,r5
 90a7ed8:	8009883a 	mov	r4,r16
 90a7edc:	880b883a 	mov	r5,r17
 90a7ee0:	100d883a 	mov	r6,r2
 90a7ee4:	180f883a 	mov	r7,r3
 90a7ee8:	908b5400 	call	908b540 <__adddf3>
 90a7eec:	1009883a 	mov	r4,r2
 90a7ef0:	180b883a 	mov	r5,r3
 90a7ef4:	2021883a 	mov	r16,r4
 90a7ef8:	2823883a 	mov	r17,r5
 90a7efc:	e0bffc17 	ldw	r2,-16(fp)
 90a7f00:	00c243b4 	movhi	r3,2318
 90a7f04:	18f44404 	addi	r3,r3,-12016
 90a7f08:	10800f24 	muli	r2,r2,60
 90a7f0c:	10c5883a 	add	r2,r2,r3
 90a7f10:	10800404 	addi	r2,r2,16
 90a7f14:	11000017 	ldw	r4,0(r2)
 90a7f18:	908c0380 	call	908c038 <__floatunsidf>
 90a7f1c:	100f883a 	mov	r7,r2
 90a7f20:	1811883a 	mov	r8,r3
 90a7f24:	8009883a 	mov	r4,r16
 90a7f28:	880b883a 	mov	r5,r17
 90a7f2c:	380d883a 	mov	r6,r7
 90a7f30:	400f883a 	mov	r7,r8
 90a7f34:	908b4c00 	call	908b4c0 <__subdf3>
 90a7f38:	1009883a 	mov	r4,r2
 90a7f3c:	180b883a 	mov	r5,r3
 90a7f40:	2005883a 	mov	r2,r4
 90a7f44:	2807883a 	mov	r3,r5
 90a7f48:	1009883a 	mov	r4,r2
 90a7f4c:	180b883a 	mov	r5,r3
 90a7f50:	000d883a 	mov	r6,zero
 90a7f54:	01d00034 	movhi	r7,16384
 90a7f58:	908b9680 	call	908b968 <__divdf3>
 90a7f5c:	1009883a 	mov	r4,r2
 90a7f60:	180b883a 	mov	r5,r3
 90a7f64:	2005883a 	mov	r2,r4
 90a7f68:	2807883a 	mov	r3,r5
 90a7f6c:	1009883a 	mov	r4,r2
 90a7f70:	180b883a 	mov	r5,r3
 90a7f74:	90cade40 	call	90cade4 <__fixunsdfsi>
 90a7f78:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 90a7f7c:	e13ff917 	ldw	r4,-28(fp)
 90a7f80:	908c0380 	call	908c038 <__floatunsidf>
 90a7f84:	100b883a 	mov	r5,r2
 90a7f88:	180d883a 	mov	r6,r3
 90a7f8c:	2809883a 	mov	r4,r5
 90a7f90:	300b883a 	mov	r5,r6
 90a7f94:	000d883a 	mov	r6,zero
 90a7f98:	01d02df4 	movhi	r7,16567
 90a7f9c:	39dc0004 	addi	r7,r7,28672
 90a7fa0:	908bde00 	call	908bde0 <__ltdf2>
 90a7fa4:	1004803a 	cmplt	r2,r2,zero
 90a7fa8:	1000011e 	bne	r2,zero,90a7fb0 <dhc_second+0x810>
 90a7fac:	00000206 	br	90a7fb8 <dhc_second+0x818>
               half_time = 60*TPS;
 90a7fb0:	0085dc04 	movi	r2,6000
 90a7fb4:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 90a7fb8:	e0bffc17 	ldw	r2,-16(fp)
 90a7fbc:	00c243b4 	movhi	r3,2318
 90a7fc0:	18f44404 	addi	r3,r3,-12016
 90a7fc4:	10800f24 	muli	r2,r2,60
 90a7fc8:	10c5883a 	add	r2,r2,r3
 90a7fcc:	10800404 	addi	r2,r2,16
 90a7fd0:	10c00017 	ldw	r3,0(r2)
 90a7fd4:	e0bff917 	ldw	r2,-28(fp)
 90a7fd8:	1887883a 	add	r3,r3,r2
 90a7fdc:	00824374 	movhi	r2,2317
 90a7fe0:	108c4204 	addi	r2,r2,12552
 90a7fe4:	10800017 	ldw	r2,0(r2)
 90a7fe8:	1880152e 	bgeu	r3,r2,90a8040 <dhc_second+0x8a0>
            {
               dhc_request(iface,FALSE);
 90a7fec:	e13ffc17 	ldw	r4,-16(fp)
 90a7ff0:	000b883a 	mov	r5,zero
 90a7ff4:	90a64600 	call	90a6460 <dhc_request>
 90a7ff8:	00001106 	br	90a8040 <dhc_second+0x8a0>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 90a7ffc:	e13ffc17 	ldw	r4,-16(fp)
 90a8000:	01400204 	movi	r5,8
 90a8004:	90a84380 	call	90a8438 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 90a8008:	e13ffc17 	ldw	r4,-16(fp)
 90a800c:	01400044 	movi	r5,1
 90a8010:	90a64600 	call	90a6460 <dhc_request>
 90a8014:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 90a8018:	e0bffa17 	ldw	r2,-24(fp)
 90a801c:	1005003a 	cmpeq	r2,r2,zero
 90a8020:	1000041e 	bne	r2,zero,90a8034 <dhc_second+0x894>
            {
               dtrap();
 90a8024:	90a94880 	call	90a9488 <dtrap>
               return e;
 90a8028:	e0fffa17 	ldw	r3,-24(fp)
 90a802c:	e0fffe15 	stw	r3,-8(fp)
 90a8030:	00000a06 	br	90a805c <dhc_second+0x8bc>
            }
            dsc_rebind++;
 90a8034:	d0a09a17 	ldw	r2,-32152(gp)
 90a8038:	10800044 	addi	r2,r2,1
 90a803c:	d0a09a15 	stw	r2,-32152(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 90a8040:	e0bffc17 	ldw	r2,-16(fp)
 90a8044:	10800044 	addi	r2,r2,1
 90a8048:	e0bffc15 	stw	r2,-16(fp)
 90a804c:	e0bffc17 	ldw	r2,-16(fp)
 90a8050:	10800110 	cmplti	r2,r2,4
 90a8054:	103dda1e 	bne	r2,zero,90a77c0 <dhc_second+0x20>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 90a8058:	e03ffe15 	stw	zero,-8(fp)
 90a805c:	e0bffe17 	ldw	r2,-8(fp)
}
 90a8060:	e037883a 	mov	sp,fp
 90a8064:	dfc00317 	ldw	ra,12(sp)
 90a8068:	df000217 	ldw	fp,8(sp)
 90a806c:	dc400117 	ldw	r17,4(sp)
 90a8070:	dc000017 	ldw	r16,0(sp)
 90a8074:	dec00404 	addi	sp,sp,16
 90a8078:	f800283a 	ret

090a807c <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 90a807c:	defffd04 	addi	sp,sp,-12
 90a8080:	dfc00215 	stw	ra,8(sp)
 90a8084:	df000115 	stw	fp,4(sp)
 90a8088:	df000104 	addi	fp,sp,4
 90a808c:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 90a8090:	e0bfff17 	ldw	r2,-4(fp)
 90a8094:	1004803a 	cmplt	r2,r2,zero
 90a8098:	1000031e 	bne	r2,zero,90a80a8 <dhc_halt+0x2c>
 90a809c:	e0bfff17 	ldw	r2,-4(fp)
 90a80a0:	10800150 	cmplti	r2,r2,5
 90a80a4:	1000021e 	bne	r2,zero,90a80b0 <dhc_halt+0x34>
   {
      dtrap();
 90a80a8:	90a94880 	call	90a9488 <dtrap>
      return;
 90a80ac:	00001006 	br	90a80f0 <dhc_halt+0x74>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 90a80b0:	e0bfff17 	ldw	r2,-4(fp)
 90a80b4:	10800f24 	muli	r2,r2,60
 90a80b8:	1007883a 	mov	r3,r2
 90a80bc:	008243b4 	movhi	r2,2318
 90a80c0:	10b44404 	addi	r2,r2,-12016
 90a80c4:	1885883a 	add	r2,r3,r2
 90a80c8:	1009883a 	mov	r4,r2
 90a80cc:	01800f04 	movi	r6,60
 90a80d0:	000b883a 	mov	r5,zero
 90a80d4:	90823f80 	call	90823f8 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 90a80d8:	e0bfff17 	ldw	r2,-4(fp)
 90a80dc:	00c243b4 	movhi	r3,2318
 90a80e0:	18f44404 	addi	r3,r3,-12016
 90a80e4:	10800f24 	muli	r2,r2,60
 90a80e8:	10c5883a 	add	r2,r2,r3
 90a80ec:	10000015 	stw	zero,0(r2)
}
 90a80f0:	e037883a 	mov	sp,fp
 90a80f4:	dfc00117 	ldw	ra,4(sp)
 90a80f8:	df000017 	ldw	fp,0(sp)
 90a80fc:	dec00204 	addi	sp,sp,8
 90a8100:	f800283a 	ret

090a8104 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 90a8104:	defffb04 	addi	sp,sp,-20
 90a8108:	dfc00415 	stw	ra,16(sp)
 90a810c:	df000315 	stw	fp,12(sp)
 90a8110:	df000304 	addi	fp,sp,12
 90a8114:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 90a8118:	e0bffe17 	ldw	r2,-8(fp)
 90a811c:	00c243b4 	movhi	r3,2318
 90a8120:	18f41e04 	addi	r3,r3,-12168
 90a8124:	1085883a 	add	r2,r2,r2
 90a8128:	1085883a 	add	r2,r2,r2
 90a812c:	10c5883a 	add	r2,r2,r3
 90a8130:	10800017 	ldw	r2,0(r2)
 90a8134:	10800a17 	ldw	r2,40(r2)
 90a8138:	1004c03a 	cmpne	r2,r2,zero
 90a813c:	1000041e 	bne	r2,zero,90a8150 <dhc_reclaim+0x4c>
   {
      dtrap();    /* programming bug? */
 90a8140:	90a94880 	call	90a9488 <dtrap>
      return ENP_LOGIC;
 90a8144:	00bffd44 	movi	r2,-11
 90a8148:	e0bfff15 	stw	r2,-4(fp)
 90a814c:	00005b06 	br	90a82bc <dhc_reclaim+0x1b8>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 90a8150:	e17ffe17 	ldw	r5,-8(fp)
 90a8154:	e0bffe17 	ldw	r2,-8(fp)
 90a8158:	00c243b4 	movhi	r3,2318
 90a815c:	18f41e04 	addi	r3,r3,-12168
 90a8160:	1085883a 	add	r2,r2,r2
 90a8164:	1085883a 	add	r2,r2,r2
 90a8168:	10c5883a 	add	r2,r2,r3
 90a816c:	10800017 	ldw	r2,0(r2)
 90a8170:	11000a17 	ldw	r4,40(r2)
 90a8174:	00c243b4 	movhi	r3,2318
 90a8178:	18f44404 	addi	r3,r3,-12016
 90a817c:	28800f24 	muli	r2,r5,60
 90a8180:	10c5883a 	add	r2,r2,r3
 90a8184:	10800904 	addi	r2,r2,36
 90a8188:	11000015 	stw	r4,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 90a818c:	e17ffe17 	ldw	r5,-8(fp)
 90a8190:	e0bffe17 	ldw	r2,-8(fp)
 90a8194:	00c243b4 	movhi	r3,2318
 90a8198:	18f41e04 	addi	r3,r3,-12168
 90a819c:	1085883a 	add	r2,r2,r2
 90a81a0:	1085883a 	add	r2,r2,r2
 90a81a4:	10c5883a 	add	r2,r2,r3
 90a81a8:	10800017 	ldw	r2,0(r2)
 90a81ac:	11000c17 	ldw	r4,48(r2)
 90a81b0:	00c243b4 	movhi	r3,2318
 90a81b4:	18f44404 	addi	r3,r3,-12016
 90a81b8:	28800f24 	muli	r2,r5,60
 90a81bc:	10c5883a 	add	r2,r2,r3
 90a81c0:	10800a04 	addi	r2,r2,40
 90a81c4:	11000015 	stw	r4,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 90a81c8:	e17ffe17 	ldw	r5,-8(fp)
 90a81cc:	e0bffe17 	ldw	r2,-8(fp)
 90a81d0:	00c243b4 	movhi	r3,2318
 90a81d4:	18f41e04 	addi	r3,r3,-12168
 90a81d8:	1085883a 	add	r2,r2,r2
 90a81dc:	1085883a 	add	r2,r2,r2
 90a81e0:	10c5883a 	add	r2,r2,r3
 90a81e4:	10800017 	ldw	r2,0(r2)
 90a81e8:	11000d17 	ldw	r4,52(r2)
 90a81ec:	00c243b4 	movhi	r3,2318
 90a81f0:	18f44404 	addi	r3,r3,-12016
 90a81f4:	28800f24 	muli	r2,r5,60
 90a81f8:	10c5883a 	add	r2,r2,r3
 90a81fc:	10800b04 	addi	r2,r2,44
 90a8200:	11000015 	stw	r4,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 90a8204:	e0bffe17 	ldw	r2,-8(fp)
 90a8208:	00c243b4 	movhi	r3,2318
 90a820c:	18f44404 	addi	r3,r3,-12016
 90a8210:	10800f24 	muli	r2,r2,60
 90a8214:	10c5883a 	add	r2,r2,r3
 90a8218:	10800c04 	addi	r2,r2,48
 90a821c:	10800017 	ldw	r2,0(r2)
 90a8220:	1005003a 	cmpeq	r2,r2,zero
 90a8224:	1000211e 	bne	r2,zero,90a82ac <dhc_reclaim+0x1a8>
   {
      if (dhc_states[iface].srv_ipaddr)
 90a8228:	e0bffe17 	ldw	r2,-8(fp)
 90a822c:	00c243b4 	movhi	r3,2318
 90a8230:	18f44404 	addi	r3,r3,-12016
 90a8234:	10800f24 	muli	r2,r2,60
 90a8238:	10c5883a 	add	r2,r2,r3
 90a823c:	10800d04 	addi	r2,r2,52
 90a8240:	10800017 	ldw	r2,0(r2)
 90a8244:	1005003a 	cmpeq	r2,r2,zero
 90a8248:	1000171e 	bne	r2,zero,90a82a8 <dhc_reclaim+0x1a4>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 90a824c:	e0bffe17 	ldw	r2,-8(fp)
 90a8250:	00c243b4 	movhi	r3,2318
 90a8254:	18f44404 	addi	r3,r3,-12016
 90a8258:	10800f24 	muli	r2,r2,60
 90a825c:	10c5883a 	add	r2,r2,r3
 90a8260:	10800d04 	addi	r2,r2,52
 90a8264:	11000017 	ldw	r4,0(r2)
 90a8268:	e0bffe17 	ldw	r2,-8(fp)
 90a826c:	00c243b4 	movhi	r3,2318
 90a8270:	18f44404 	addi	r3,r3,-12016
 90a8274:	10800f24 	muli	r2,r2,60
 90a8278:	10c5883a 	add	r2,r2,r3
 90a827c:	10800c04 	addi	r2,r2,48
 90a8280:	11800017 	ldw	r6,0(r2)
 90a8284:	00800084 	movi	r2,2
 90a8288:	d8800015 	stw	r2,0(sp)
 90a828c:	017fffc4 	movi	r5,-1
 90a8290:	e1fffe17 	ldw	r7,-8(fp)
 90a8294:	90c290c0 	call	90c290c <add_route>
 90a8298:	1004c03a 	cmpne	r2,r2,zero
 90a829c:	1000031e 	bne	r2,zero,90a82ac <dhc_reclaim+0x1a8>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 90a82a0:	90a94880 	call	90a9488 <dtrap>
 90a82a4:	00000106 	br	90a82ac <dhc_reclaim+0x1a8>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 90a82a8:	90a94880 	call	90a9488 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 90a82ac:	e13ffe17 	ldw	r4,-8(fp)
 90a82b0:	01400044 	movi	r5,1
 90a82b4:	90a64600 	call	90a6460 <dhc_request>
 90a82b8:	e0bfff15 	stw	r2,-4(fp)
 90a82bc:	e0bfff17 	ldw	r2,-4(fp)
}
 90a82c0:	e037883a 	mov	sp,fp
 90a82c4:	dfc00117 	ldw	ra,4(sp)
 90a82c8:	df000017 	ldw	fp,0(sp)
 90a82cc:	dec00204 	addi	sp,sp,8
 90a82d0:	f800283a 	ret

090a82d4 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 90a82d4:	defffa04 	addi	sp,sp,-24
 90a82d8:	dfc00515 	stw	ra,20(sp)
 90a82dc:	df000415 	stw	fp,16(sp)
 90a82e0:	df000404 	addi	fp,sp,16
 90a82e4:	e13ffd15 	stw	r4,-12(fp)
 90a82e8:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 90a82ec:	e0bffe17 	ldw	r2,-8(fp)
 90a82f0:	10800058 	cmpnei	r2,r2,1
 90a82f4:	1000031e 	bne	r2,zero,90a8304 <dhc_state_init+0x30>
 90a82f8:	00800044 	movi	r2,1
 90a82fc:	e0bfff15 	stw	r2,-4(fp)
 90a8300:	00000206 	br	90a830c <dhc_state_init+0x38>
 90a8304:	00800084 	movi	r2,2
 90a8308:	e0bfff15 	stw	r2,-4(fp)
 90a830c:	e0bfff17 	ldw	r2,-4(fp)
 90a8310:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 90a8314:	e13ffd17 	ldw	r4,-12(fp)
 90a8318:	e17ffc17 	ldw	r5,-16(fp)
 90a831c:	90a84380 	call	90a8438 <dhc_set_state>
}
 90a8320:	e037883a 	mov	sp,fp
 90a8324:	dfc00117 	ldw	ra,4(sp)
 90a8328:	df000017 	ldw	fp,0(sp)
 90a832c:	dec00204 	addi	sp,sp,8
 90a8330:	f800283a 	ret

090a8334 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 90a8334:	defffd04 	addi	sp,sp,-12
 90a8338:	df000215 	stw	fp,8(sp)
 90a833c:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 90a8340:	e03ffe15 	stw	zero,-8(fp)
 90a8344:	00001506 	br	90a839c <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 90a8348:	e0bffe17 	ldw	r2,-8(fp)
 90a834c:	00c243b4 	movhi	r3,2318
 90a8350:	18f44404 	addi	r3,r3,-12016
 90a8354:	10800f24 	muli	r2,r2,60
 90a8358:	10c5883a 	add	r2,r2,r3
 90a835c:	10800017 	ldw	r2,0(r2)
 90a8360:	1005003a 	cmpeq	r2,r2,zero
 90a8364:	10000a1e 	bne	r2,zero,90a8390 <dhc_alldone+0x5c>
 90a8368:	e0bffe17 	ldw	r2,-8(fp)
 90a836c:	00c243b4 	movhi	r3,2318
 90a8370:	18f44404 	addi	r3,r3,-12016
 90a8374:	10800f24 	muli	r2,r2,60
 90a8378:	10c5883a 	add	r2,r2,r3
 90a837c:	10800017 	ldw	r2,0(r2)
 90a8380:	108001a0 	cmpeqi	r2,r2,6
 90a8384:	1000021e 	bne	r2,zero,90a8390 <dhc_alldone+0x5c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 90a8388:	e03fff15 	stw	zero,-4(fp)
 90a838c:	00000806 	br	90a83b0 <dhc_alldone+0x7c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 90a8390:	e0bffe17 	ldw	r2,-8(fp)
 90a8394:	10800044 	addi	r2,r2,1
 90a8398:	e0bffe15 	stw	r2,-8(fp)
 90a839c:	e0bffe17 	ldw	r2,-8(fp)
 90a83a0:	10800110 	cmplti	r2,r2,4
 90a83a4:	103fe81e 	bne	r2,zero,90a8348 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 90a83a8:	00800044 	movi	r2,1
 90a83ac:	e0bfff15 	stw	r2,-4(fp)
 90a83b0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a83b4:	e037883a 	mov	sp,fp
 90a83b8:	df000017 	ldw	fp,0(sp)
 90a83bc:	dec00104 	addi	sp,sp,4
 90a83c0:	f800283a 	ret

090a83c4 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 90a83c4:	defffd04 	addi	sp,sp,-12
 90a83c8:	df000215 	stw	fp,8(sp)
 90a83cc:	df000204 	addi	fp,sp,8
 90a83d0:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 90a83d4:	e0bffe17 	ldw	r2,-8(fp)
 90a83d8:	00c243b4 	movhi	r3,2318
 90a83dc:	18f44404 	addi	r3,r3,-12016
 90a83e0:	10800f24 	muli	r2,r2,60
 90a83e4:	10c5883a 	add	r2,r2,r3
 90a83e8:	10800017 	ldw	r2,0(r2)
 90a83ec:	1005003a 	cmpeq	r2,r2,zero
 90a83f0:	1000081e 	bne	r2,zero,90a8414 <dhc_ifacedone+0x50>
 90a83f4:	e0bffe17 	ldw	r2,-8(fp)
 90a83f8:	00c243b4 	movhi	r3,2318
 90a83fc:	18f44404 	addi	r3,r3,-12016
 90a8400:	10800f24 	muli	r2,r2,60
 90a8404:	10c5883a 	add	r2,r2,r3
 90a8408:	10800017 	ldw	r2,0(r2)
 90a840c:	10800198 	cmpnei	r2,r2,6
 90a8410:	1000031e 	bne	r2,zero,90a8420 <dhc_ifacedone+0x5c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 90a8414:	00800044 	movi	r2,1
 90a8418:	e0bfff15 	stw	r2,-4(fp)
 90a841c:	00000106 	br	90a8424 <dhc_ifacedone+0x60>
   }
   else
   {
      return FALSE ;
 90a8420:	e03fff15 	stw	zero,-4(fp)
 90a8424:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a8428:	e037883a 	mov	sp,fp
 90a842c:	df000017 	ldw	fp,0(sp)
 90a8430:	dec00104 	addi	sp,sp,4
 90a8434:	f800283a 	ret

090a8438 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 90a8438:	defffc04 	addi	sp,sp,-16
 90a843c:	dfc00315 	stw	ra,12(sp)
 90a8440:	df000215 	stw	fp,8(sp)
 90a8444:	df000204 	addi	fp,sp,8
 90a8448:	e13ffe15 	stw	r4,-8(fp)
 90a844c:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 90a8450:	e0bffe17 	ldw	r2,-8(fp)
 90a8454:	e13fff17 	ldw	r4,-4(fp)
 90a8458:	00c243b4 	movhi	r3,2318
 90a845c:	18f44404 	addi	r3,r3,-12016
 90a8460:	10800f24 	muli	r2,r2,60
 90a8464:	10c5883a 	add	r2,r2,r3
 90a8468:	11000015 	stw	r4,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 90a846c:	e0bffe17 	ldw	r2,-8(fp)
 90a8470:	00c243b4 	movhi	r3,2318
 90a8474:	18f44404 	addi	r3,r3,-12016
 90a8478:	10800f24 	muli	r2,r2,60
 90a847c:	10c5883a 	add	r2,r2,r3
 90a8480:	10800104 	addi	r2,r2,4
 90a8484:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 90a8488:	e0bffe17 	ldw	r2,-8(fp)
 90a848c:	00c243b4 	movhi	r3,2318
 90a8490:	18f44404 	addi	r3,r3,-12016
 90a8494:	10800f24 	muli	r2,r2,60
 90a8498:	10c5883a 	add	r2,r2,r3
 90a849c:	10800e04 	addi	r2,r2,56
 90a84a0:	10800017 	ldw	r2,0(r2)
 90a84a4:	1005003a 	cmpeq	r2,r2,zero
 90a84a8:	10000a1e 	bne	r2,zero,90a84d4 <dhc_set_state+0x9c>
      dhc_states[iface].callback(iface,state);
 90a84ac:	e0bffe17 	ldw	r2,-8(fp)
 90a84b0:	00c243b4 	movhi	r3,2318
 90a84b4:	18f44404 	addi	r3,r3,-12016
 90a84b8:	10800f24 	muli	r2,r2,60
 90a84bc:	10c5883a 	add	r2,r2,r3
 90a84c0:	10800e04 	addi	r2,r2,56
 90a84c4:	10800017 	ldw	r2,0(r2)
 90a84c8:	e13ffe17 	ldw	r4,-8(fp)
 90a84cc:	e17fff17 	ldw	r5,-4(fp)
 90a84d0:	103ee83a 	callr	r2
}
 90a84d4:	e037883a 	mov	sp,fp
 90a84d8:	dfc00117 	ldw	ra,4(sp)
 90a84dc:	df000017 	ldw	fp,0(sp)
 90a84e0:	dec00204 	addi	sp,sp,8
 90a84e4:	f800283a 	ret

090a84e8 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 90a84e8:	defffb04 	addi	sp,sp,-20
 90a84ec:	df000415 	stw	fp,16(sp)
 90a84f0:	df000404 	addi	fp,sp,16
 90a84f4:	e17ffe15 	stw	r5,-8(fp)
 90a84f8:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 90a84fc:	e0bffe17 	ldw	r2,-8(fp)
 90a8500:	10804e04 	addi	r2,r2,312
 90a8504:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 90a8508:	00002106 	br	90a8590 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 90a850c:	e0bffe17 	ldw	r2,-8(fp)
 90a8510:	10800003 	ldbu	r2,0(r2)
 90a8514:	10c03fcc 	andi	r3,r2,255
 90a8518:	e0bffd03 	ldbu	r2,-12(fp)
 90a851c:	1880031e 	bne	r3,r2,90a852c <find_opt+0x44>
         return opts;
 90a8520:	e0bffe17 	ldw	r2,-8(fp)
 90a8524:	e0bfff15 	stw	r2,-4(fp)
 90a8528:	00001d06 	br	90a85a0 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 90a852c:	e0bffe17 	ldw	r2,-8(fp)
 90a8530:	10800003 	ldbu	r2,0(r2)
 90a8534:	10803fcc 	andi	r2,r2,255
 90a8538:	10803fd8 	cmpnei	r2,r2,255
 90a853c:	1000021e 	bne	r2,zero,90a8548 <find_opt+0x60>
         return NULL;
 90a8540:	e03fff15 	stw	zero,-4(fp)
 90a8544:	00001606 	br	90a85a0 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 90a8548:	e0bffe17 	ldw	r2,-8(fp)
 90a854c:	10800003 	ldbu	r2,0(r2)
 90a8550:	10803fcc 	andi	r2,r2,255
 90a8554:	1004c03a 	cmpne	r2,r2,zero
 90a8558:	1000041e 	bne	r2,zero,90a856c <find_opt+0x84>
         opts++;
 90a855c:	e0bffe17 	ldw	r2,-8(fp)
 90a8560:	10800044 	addi	r2,r2,1
 90a8564:	e0bffe15 	stw	r2,-8(fp)
 90a8568:	00000906 	br	90a8590 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 90a856c:	e0bffe17 	ldw	r2,-8(fp)
 90a8570:	10800044 	addi	r2,r2,1
 90a8574:	10800003 	ldbu	r2,0(r2)
 90a8578:	10803fcc 	andi	r2,r2,255
 90a857c:	1007883a 	mov	r3,r2
 90a8580:	e0bffe17 	ldw	r2,-8(fp)
 90a8584:	1885883a 	add	r2,r3,r2
 90a8588:	10800084 	addi	r2,r2,2
 90a858c:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 90a8590:	e0fffe17 	ldw	r3,-8(fp)
 90a8594:	e0bffc17 	ldw	r2,-16(fp)
 90a8598:	18bfdc36 	bltu	r3,r2,90a850c <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 90a859c:	e03fff15 	stw	zero,-4(fp)
 90a85a0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a85a4:	e037883a 	mov	sp,fp
 90a85a8:	df000017 	ldw	fp,0(sp)
 90a85ac:	dec00104 	addi	sp,sp,4
 90a85b0:	f800283a 	ret

090a85b4 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 90a85b4:	defff704 	addi	sp,sp,-36
 90a85b8:	dfc00815 	stw	ra,32(sp)
 90a85bc:	df000715 	stw	fp,28(sp)
 90a85c0:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 90a85c4:	d0a03617 	ldw	r2,-32552(gp)
 90a85c8:	d0e03417 	ldw	r3,-32560(gp)
 90a85cc:	10c5883a 	add	r2,r2,r3
 90a85d0:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 90a85d4:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 90a85d8:	e03ffd15 	stw	zero,-12(fp)
 90a85dc:	00007e06 	br	90a87d8 <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 90a85e0:	01000d04 	movi	r4,52
 90a85e4:	90a9f0c0 	call	90a9f0c <npalloc>
 90a85e8:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 90a85ec:	e0bffe17 	ldw	r2,-8(fp)
 90a85f0:	1005003a 	cmpeq	r2,r2,zero
 90a85f4:	1000871e 	bne	r2,zero,90a8814 <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 90a85f8:	e0bffd17 	ldw	r2,-12(fp)
 90a85fc:	10800f30 	cmpltui	r2,r2,60
 90a8600:	1000061e 	bne	r2,zero,90a861c <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 90a8604:	01024374 	movhi	r4,2317
 90a8608:	213e0404 	addi	r4,r4,-2032
 90a860c:	90828380 	call	9082838 <puts>
         return -1;
 90a8610:	00bfffc4 	movi	r2,-1
 90a8614:	e0bfff15 	stw	r2,-4(fp)
 90a8618:	00008406 	br	90a882c <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 90a861c:	e0bffd17 	ldw	r2,-12(fp)
 90a8620:	00c243b4 	movhi	r3,2318
 90a8624:	18f48904 	addi	r3,r3,-11740
 90a8628:	1085883a 	add	r2,r2,r2
 90a862c:	1085883a 	add	r2,r2,r2
 90a8630:	10c7883a 	add	r3,r2,r3
 90a8634:	e0bffe17 	ldw	r2,-8(fp)
 90a8638:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 90a863c:	e0bffe17 	ldw	r2,-8(fp)
 90a8640:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 90a8644:	d0e03617 	ldw	r3,-32552(gp)
 90a8648:	e0bffd17 	ldw	r2,-12(fp)
 90a864c:	10c0302e 	bgeu	r2,r3,90a8710 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 90a8650:	d0a03717 	ldw	r2,-32548(gp)
 90a8654:	11000144 	addi	r4,r2,5
 90a8658:	90aa0b80 	call	90aa0b8 <ncpalloc>
 90a865c:	1007883a 	mov	r3,r2
 90a8660:	e0bffe17 	ldw	r2,-8(fp)
 90a8664:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 90a8668:	e0bffe17 	ldw	r2,-8(fp)
 90a866c:	10800117 	ldw	r2,4(r2)
 90a8670:	1005003a 	cmpeq	r2,r2,zero
 90a8674:	1000671e 	bne	r2,zero,90a8814 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a8678:	e03ffa15 	stw	zero,-24(fp)
 90a867c:	00000906 	br	90a86a4 <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 90a8680:	e0bffe17 	ldw	r2,-8(fp)
 90a8684:	10c00117 	ldw	r3,4(r2)
 90a8688:	e0bffa17 	ldw	r2,-24(fp)
 90a868c:	1887883a 	add	r3,r3,r2
 90a8690:	00801344 	movi	r2,77
 90a8694:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a8698:	e0bffa17 	ldw	r2,-24(fp)
 90a869c:	10800044 	addi	r2,r2,1
 90a86a0:	e0bffa15 	stw	r2,-24(fp)
 90a86a4:	e0bffa17 	ldw	r2,-24(fp)
 90a86a8:	10800110 	cmplti	r2,r2,4
 90a86ac:	103ff41e 	bne	r2,zero,90a8680 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 90a86b0:	e0bffe17 	ldw	r2,-8(fp)
 90a86b4:	10c00117 	ldw	r3,4(r2)
 90a86b8:	d0a03717 	ldw	r2,-32548(gp)
 90a86bc:	1885883a 	add	r2,r3,r2
 90a86c0:	10c00104 	addi	r3,r2,4
 90a86c4:	00801344 	movi	r2,77
 90a86c8:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 90a86cc:	e0bffe17 	ldw	r2,-8(fp)
 90a86d0:	10800117 	ldw	r2,4(r2)
 90a86d4:	10c00104 	addi	r3,r2,4
 90a86d8:	e0bffe17 	ldw	r2,-8(fp)
 90a86dc:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 90a86e0:	e0bffe17 	ldw	r2,-8(fp)
 90a86e4:	10800117 	ldw	r2,4(r2)
 90a86e8:	1005003a 	cmpeq	r2,r2,zero
 90a86ec:	1000491e 	bne	r2,zero,90a8814 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 90a86f0:	d0e03717 	ldw	r3,-32548(gp)
 90a86f4:	e0bffe17 	ldw	r2,-8(fp)
 90a86f8:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 90a86fc:	010243b4 	movhi	r4,2318
 90a8700:	2134c504 	addi	r4,r4,-11500
 90a8704:	e17ffe17 	ldw	r5,-8(fp)
 90a8708:	90a8e180 	call	90a8e18 <putq>
 90a870c:	00002f06 	br	90a87cc <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 90a8710:	d0a03517 	ldw	r2,-32556(gp)
 90a8714:	11000144 	addi	r4,r2,5
 90a8718:	90aa0b80 	call	90aa0b8 <ncpalloc>
 90a871c:	1007883a 	mov	r3,r2
 90a8720:	e0bffe17 	ldw	r2,-8(fp)
 90a8724:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 90a8728:	e0bffe17 	ldw	r2,-8(fp)
 90a872c:	10800117 	ldw	r2,4(r2)
 90a8730:	1005003a 	cmpeq	r2,r2,zero
 90a8734:	1000371e 	bne	r2,zero,90a8814 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a8738:	e03ff915 	stw	zero,-28(fp)
 90a873c:	00000906 	br	90a8764 <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 90a8740:	e0bffe17 	ldw	r2,-8(fp)
 90a8744:	10c00117 	ldw	r3,4(r2)
 90a8748:	e0bff917 	ldw	r2,-28(fp)
 90a874c:	1887883a 	add	r3,r3,r2
 90a8750:	00801344 	movi	r2,77
 90a8754:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a8758:	e0bff917 	ldw	r2,-28(fp)
 90a875c:	10800044 	addi	r2,r2,1
 90a8760:	e0bff915 	stw	r2,-28(fp)
 90a8764:	e0bff917 	ldw	r2,-28(fp)
 90a8768:	10800110 	cmplti	r2,r2,4
 90a876c:	103ff41e 	bne	r2,zero,90a8740 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 90a8770:	e0bffe17 	ldw	r2,-8(fp)
 90a8774:	10c00117 	ldw	r3,4(r2)
 90a8778:	d0a03517 	ldw	r2,-32556(gp)
 90a877c:	1885883a 	add	r2,r3,r2
 90a8780:	10c00104 	addi	r3,r2,4
 90a8784:	00801344 	movi	r2,77
 90a8788:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 90a878c:	e0bffe17 	ldw	r2,-8(fp)
 90a8790:	10800117 	ldw	r2,4(r2)
 90a8794:	10c00104 	addi	r3,r2,4
 90a8798:	e0bffe17 	ldw	r2,-8(fp)
 90a879c:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 90a87a0:	e0bffe17 	ldw	r2,-8(fp)
 90a87a4:	10800117 	ldw	r2,4(r2)
 90a87a8:	1005003a 	cmpeq	r2,r2,zero
 90a87ac:	1000191e 	bne	r2,zero,90a8814 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 90a87b0:	d0e03517 	ldw	r3,-32556(gp)
 90a87b4:	e0bffe17 	ldw	r2,-8(fp)
 90a87b8:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 90a87bc:	010243b4 	movhi	r4,2318
 90a87c0:	21348004 	addi	r4,r4,-11776
 90a87c4:	e17ffe17 	ldw	r5,-8(fp)
 90a87c8:	90a8e180 	call	90a8e18 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 90a87cc:	e0bffd17 	ldw	r2,-12(fp)
 90a87d0:	10800044 	addi	r2,r2,1
 90a87d4:	e0bffd15 	stw	r2,-12(fp)
 90a87d8:	e0fffd17 	ldw	r3,-12(fp)
 90a87dc:	e0bffc17 	ldw	r2,-16(fp)
 90a87e0:	18bf7f36 	bltu	r3,r2,90a85e0 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 90a87e4:	d0a03617 	ldw	r2,-32552(gp)
 90a87e8:	1007883a 	mov	r3,r2
 90a87ec:	008243b4 	movhi	r2,2318
 90a87f0:	10b4c504 	addi	r2,r2,-11500
 90a87f4:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 90a87f8:	d0a03417 	ldw	r2,-32560(gp)
 90a87fc:	1007883a 	mov	r3,r2
 90a8800:	008243b4 	movhi	r2,2318
 90a8804:	10b48004 	addi	r2,r2,-11776
 90a8808:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 90a880c:	e03fff15 	stw	zero,-4(fp)
 90a8810:	00000606 	br	90a882c <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 90a8814:	01024374 	movhi	r4,2317
 90a8818:	213e0904 	addi	r4,r4,-2012
 90a881c:	e17ffd17 	ldw	r5,-12(fp)
 90a8820:	90825100 	call	9082510 <printf>
#endif
   return(-1);
 90a8824:	00bfffc4 	movi	r2,-1
 90a8828:	e0bfff15 	stw	r2,-4(fp)
 90a882c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a8830:	e037883a 	mov	sp,fp
 90a8834:	dfc00117 	ldw	ra,4(sp)
 90a8838:	df000017 	ldw	fp,0(sp)
 90a883c:	dec00204 	addi	sp,sp,8
 90a8840:	f800283a 	ret

090a8844 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 90a8844:	defffb04 	addi	sp,sp,-20
 90a8848:	dfc00415 	stw	ra,16(sp)
 90a884c:	df000315 	stw	fp,12(sp)
 90a8850:	df000304 	addi	fp,sp,12
 90a8854:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 90a8858:	d0e03717 	ldw	r3,-32548(gp)
 90a885c:	e0bffe17 	ldw	r2,-8(fp)
 90a8860:	1880022e 	bgeu	r3,r2,90a886c <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 90a8864:	e03fff15 	stw	zero,-4(fp)
 90a8868:	00002706 	br	90a8908 <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 90a886c:	d0e03517 	ldw	r3,-32556(gp)
 90a8870:	e0bffe17 	ldw	r2,-8(fp)
 90a8874:	18800536 	bltu	r3,r2,90a888c <pk_alloc+0x48>
 90a8878:	008243b4 	movhi	r2,2318
 90a887c:	10b48004 	addi	r2,r2,-11776
 90a8880:	10800217 	ldw	r2,8(r2)
 90a8884:	1004c03a 	cmpne	r2,r2,zero
 90a8888:	1000051e 	bne	r2,zero,90a88a0 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 90a888c:	010243b4 	movhi	r4,2318
 90a8890:	2134c504 	addi	r4,r4,-11500
 90a8894:	90a8d500 	call	90a8d50 <getq>
 90a8898:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 90a889c:	00000406 	br	90a88b0 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 90a88a0:	010243b4 	movhi	r4,2318
 90a88a4:	21348004 	addi	r4,r4,-11776
 90a88a8:	90a8d500 	call	90a8d50 <getq>
 90a88ac:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 90a88b0:	e0bffd17 	ldw	r2,-12(fp)
 90a88b4:	1004c03a 	cmpne	r2,r2,zero
 90a88b8:	1000021e 	bne	r2,zero,90a88c4 <pk_alloc+0x80>
         return NULL;
 90a88bc:	e03fff15 	stw	zero,-4(fp)
 90a88c0:	00001106 	br	90a8908 <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 90a88c4:	e0bffd17 	ldw	r2,-12(fp)
 90a88c8:	10c00117 	ldw	r3,4(r2)
 90a88cc:	00824374 	movhi	r2,2317
 90a88d0:	108c1b04 	addi	r2,r2,12396
 90a88d4:	10800017 	ldw	r2,0(r2)
 90a88d8:	1887883a 	add	r3,r3,r2
 90a88dc:	e0bffd17 	ldw	r2,-12(fp)
 90a88e0:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 90a88e4:	e0bffd17 	ldw	r2,-12(fp)
 90a88e8:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 90a88ec:	e0bffd17 	ldw	r2,-12(fp)
 90a88f0:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 90a88f4:	e0fffd17 	ldw	r3,-12(fp)
 90a88f8:	00800044 	movi	r2,1
 90a88fc:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 90a8900:	e0bffd17 	ldw	r2,-12(fp)
 90a8904:	e0bfff15 	stw	r2,-4(fp)
 90a8908:	e0bfff17 	ldw	r2,-4(fp)
}
 90a890c:	e037883a 	mov	sp,fp
 90a8910:	dfc00117 	ldw	ra,4(sp)
 90a8914:	df000017 	ldw	fp,0(sp)
 90a8918:	dec00204 	addi	sp,sp,8
 90a891c:	f800283a 	ret

090a8920 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 90a8920:	defffa04 	addi	sp,sp,-24
 90a8924:	dfc00515 	stw	ra,20(sp)
 90a8928:	df000415 	stw	fp,16(sp)
 90a892c:	df000404 	addi	fp,sp,16
 90a8930:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 90a8934:	e0bffe17 	ldw	r2,-8(fp)
 90a8938:	10800017 	ldw	r2,0(r2)
 90a893c:	1005003a 	cmpeq	r2,r2,zero
 90a8940:	1000101e 	bne	r2,zero,90a8984 <pk_validate+0x64>
 90a8944:	e0bffe17 	ldw	r2,-8(fp)
 90a8948:	10800917 	ldw	r2,36(r2)
 90a894c:	1005003a 	cmpeq	r2,r2,zero
 90a8950:	10000c1e 	bne	r2,zero,90a8984 <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 90a8954:	90a96c80 	call	90a96c8 <irq_Mask>
 90a8958:	008243b4 	movhi	r2,2318
 90a895c:	10b48504 	addi	r2,r2,-11756
 90a8960:	10800317 	ldw	r2,12(r2)
 90a8964:	10c00044 	addi	r3,r2,1
 90a8968:	008243b4 	movhi	r2,2318
 90a896c:	10b48504 	addi	r2,r2,-11756
 90a8970:	10c00315 	stw	r3,12(r2)
 90a8974:	90a97240 	call	90a9724 <irq_Unmask>
      return -1;
 90a8978:	00bfffc4 	movi	r2,-1
 90a897c:	e0bfff15 	stw	r2,-4(fp)
 90a8980:	00008f06 	br	90a8bc0 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 90a8984:	e0bffe17 	ldw	r2,-8(fp)
 90a8988:	10c00217 	ldw	r3,8(r2)
 90a898c:	d0a03717 	ldw	r2,-32548(gp)
 90a8990:	1880221e 	bne	r3,r2,90a8a1c <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 90a8994:	90a96c80 	call	90a96c8 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 90a8998:	008243b4 	movhi	r2,2318
 90a899c:	10b4c504 	addi	r2,r2,-11500
 90a89a0:	10800017 	ldw	r2,0(r2)
 90a89a4:	e0bffd15 	stw	r2,-12(fp)
 90a89a8:	00001706 	br	90a8a08 <pk_validate+0xe8>
            if (p == pkt)
 90a89ac:	e0fffd17 	ldw	r3,-12(fp)
 90a89b0:	e0bffe17 	ldw	r2,-8(fp)
 90a89b4:	1880111e 	bne	r3,r2,90a89fc <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 90a89b8:	01024374 	movhi	r4,2317
 90a89bc:	213e1404 	addi	r4,r4,-1968
 90a89c0:	e17ffe17 	ldw	r5,-8(fp)
 90a89c4:	90825100 	call	9082510 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 90a89c8:	90a97240 	call	90a9724 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 90a89cc:	90a96c80 	call	90a96c8 <irq_Mask>
 90a89d0:	008243b4 	movhi	r2,2318
 90a89d4:	10b48504 	addi	r2,r2,-11756
 90a89d8:	10800217 	ldw	r2,8(r2)
 90a89dc:	10c00044 	addi	r3,r2,1
 90a89e0:	008243b4 	movhi	r2,2318
 90a89e4:	10b48504 	addi	r2,r2,-11756
 90a89e8:	10c00215 	stw	r3,8(r2)
 90a89ec:	90a97240 	call	90a9724 <irq_Unmask>
               return -1;
 90a89f0:	00bfffc4 	movi	r2,-1
 90a89f4:	e0bfff15 	stw	r2,-4(fp)
 90a89f8:	00007106 	br	90a8bc0 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 90a89fc:	e0bffd17 	ldw	r2,-12(fp)
 90a8a00:	10800017 	ldw	r2,0(r2)
 90a8a04:	e0bffd15 	stw	r2,-12(fp)
 90a8a08:	e0bffd17 	ldw	r2,-12(fp)
 90a8a0c:	1004c03a 	cmpne	r2,r2,zero
 90a8a10:	103fe61e 	bne	r2,zero,90a89ac <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 90a8a14:	90a97240 	call	90a9724 <irq_Unmask>
 90a8a18:	00003206 	br	90a8ae4 <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 90a8a1c:	e0bffe17 	ldw	r2,-8(fp)
 90a8a20:	10c00217 	ldw	r3,8(r2)
 90a8a24:	d0a03517 	ldw	r2,-32556(gp)
 90a8a28:	1880221e 	bne	r3,r2,90a8ab4 <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 90a8a2c:	90a96c80 	call	90a96c8 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 90a8a30:	008243b4 	movhi	r2,2318
 90a8a34:	10b48004 	addi	r2,r2,-11776
 90a8a38:	10800017 	ldw	r2,0(r2)
 90a8a3c:	e0bffd15 	stw	r2,-12(fp)
 90a8a40:	00001706 	br	90a8aa0 <pk_validate+0x180>
            if (p == pkt)
 90a8a44:	e0fffd17 	ldw	r3,-12(fp)
 90a8a48:	e0bffe17 	ldw	r2,-8(fp)
 90a8a4c:	1880111e 	bne	r3,r2,90a8a94 <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 90a8a50:	01024374 	movhi	r4,2317
 90a8a54:	213e1e04 	addi	r4,r4,-1928
 90a8a58:	e17ffe17 	ldw	r5,-8(fp)
 90a8a5c:	90825100 	call	9082510 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 90a8a60:	90a97240 	call	90a9724 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 90a8a64:	90a96c80 	call	90a96c8 <irq_Mask>
 90a8a68:	008243b4 	movhi	r2,2318
 90a8a6c:	10b48504 	addi	r2,r2,-11756
 90a8a70:	10800217 	ldw	r2,8(r2)
 90a8a74:	10c00044 	addi	r3,r2,1
 90a8a78:	008243b4 	movhi	r2,2318
 90a8a7c:	10b48504 	addi	r2,r2,-11756
 90a8a80:	10c00215 	stw	r3,8(r2)
 90a8a84:	90a97240 	call	90a9724 <irq_Unmask>
            return -1;
 90a8a88:	00bfffc4 	movi	r2,-1
 90a8a8c:	e0bfff15 	stw	r2,-4(fp)
 90a8a90:	00004b06 	br	90a8bc0 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 90a8a94:	e0bffd17 	ldw	r2,-12(fp)
 90a8a98:	10800017 	ldw	r2,0(r2)
 90a8a9c:	e0bffd15 	stw	r2,-12(fp)
 90a8aa0:	e0bffd17 	ldw	r2,-12(fp)
 90a8aa4:	1004c03a 	cmpne	r2,r2,zero
 90a8aa8:	103fe61e 	bne	r2,zero,90a8a44 <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 90a8aac:	90a97240 	call	90a9724 <irq_Unmask>
 90a8ab0:	00000c06 	br	90a8ae4 <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 90a8ab4:	90a96c80 	call	90a96c8 <irq_Mask>
 90a8ab8:	008243b4 	movhi	r2,2318
 90a8abc:	10b48504 	addi	r2,r2,-11756
 90a8ac0:	10800017 	ldw	r2,0(r2)
 90a8ac4:	10c00044 	addi	r3,r2,1
 90a8ac8:	008243b4 	movhi	r2,2318
 90a8acc:	10b48504 	addi	r2,r2,-11756
 90a8ad0:	10c00015 	stw	r3,0(r2)
 90a8ad4:	90a97240 	call	90a9724 <irq_Unmask>
         return -1;
 90a8ad8:	00bfffc4 	movi	r2,-1
 90a8adc:	e0bfff15 	stw	r2,-4(fp)
 90a8ae0:	00003706 	br	90a8bc0 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 90a8ae4:	00800104 	movi	r2,4
 90a8ae8:	e0bffc15 	stw	r2,-16(fp)
 90a8aec:	00001906 	br	90a8b54 <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 90a8af0:	e0bffe17 	ldw	r2,-8(fp)
 90a8af4:	10c00117 	ldw	r3,4(r2)
 90a8af8:	e0bffc17 	ldw	r2,-16(fp)
 90a8afc:	1885c83a 	sub	r2,r3,r2
 90a8b00:	10800003 	ldbu	r2,0(r2)
 90a8b04:	10803fcc 	andi	r2,r2,255
 90a8b08:	1080201c 	xori	r2,r2,128
 90a8b0c:	10bfe004 	addi	r2,r2,-128
 90a8b10:	10801360 	cmpeqi	r2,r2,77
 90a8b14:	10000c1e 	bne	r2,zero,90a8b48 <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 90a8b18:	90a96c80 	call	90a96c8 <irq_Mask>
 90a8b1c:	008243b4 	movhi	r2,2318
 90a8b20:	10b48504 	addi	r2,r2,-11756
 90a8b24:	10800117 	ldw	r2,4(r2)
 90a8b28:	10c00044 	addi	r3,r2,1
 90a8b2c:	008243b4 	movhi	r2,2318
 90a8b30:	10b48504 	addi	r2,r2,-11756
 90a8b34:	10c00115 	stw	r3,4(r2)
 90a8b38:	90a97240 	call	90a9724 <irq_Unmask>
         return -1;
 90a8b3c:	00bfffc4 	movi	r2,-1
 90a8b40:	e0bfff15 	stw	r2,-4(fp)
 90a8b44:	00001e06 	br	90a8bc0 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 90a8b48:	e0bffc17 	ldw	r2,-16(fp)
 90a8b4c:	10bfffc4 	addi	r2,r2,-1
 90a8b50:	e0bffc15 	stw	r2,-16(fp)
 90a8b54:	e0bffc17 	ldw	r2,-16(fp)
 90a8b58:	10800048 	cmpgei	r2,r2,1
 90a8b5c:	103fe41e 	bne	r2,zero,90a8af0 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 90a8b60:	e0bffe17 	ldw	r2,-8(fp)
 90a8b64:	10c00117 	ldw	r3,4(r2)
 90a8b68:	e0bffe17 	ldw	r2,-8(fp)
 90a8b6c:	10800217 	ldw	r2,8(r2)
 90a8b70:	1885883a 	add	r2,r3,r2
 90a8b74:	10800003 	ldbu	r2,0(r2)
 90a8b78:	10803fcc 	andi	r2,r2,255
 90a8b7c:	1080201c 	xori	r2,r2,128
 90a8b80:	10bfe004 	addi	r2,r2,-128
 90a8b84:	10801360 	cmpeqi	r2,r2,77
 90a8b88:	10000c1e 	bne	r2,zero,90a8bbc <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 90a8b8c:	90a96c80 	call	90a96c8 <irq_Mask>
 90a8b90:	008243b4 	movhi	r2,2318
 90a8b94:	10b48504 	addi	r2,r2,-11756
 90a8b98:	10800117 	ldw	r2,4(r2)
 90a8b9c:	10c00044 	addi	r3,r2,1
 90a8ba0:	008243b4 	movhi	r2,2318
 90a8ba4:	10b48504 	addi	r2,r2,-11756
 90a8ba8:	10c00115 	stw	r3,4(r2)
 90a8bac:	90a97240 	call	90a9724 <irq_Unmask>
      return -1;
 90a8bb0:	00bfffc4 	movi	r2,-1
 90a8bb4:	e0bfff15 	stw	r2,-4(fp)
 90a8bb8:	00000106 	br	90a8bc0 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 90a8bbc:	e03fff15 	stw	zero,-4(fp)
 90a8bc0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a8bc4:	e037883a 	mov	sp,fp
 90a8bc8:	dfc00117 	ldw	ra,4(sp)
 90a8bcc:	df000017 	ldw	fp,0(sp)
 90a8bd0:	dec00204 	addi	sp,sp,8
 90a8bd4:	f800283a 	ret

090a8bd8 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 90a8bd8:	defffc04 	addi	sp,sp,-16
 90a8bdc:	dfc00315 	stw	ra,12(sp)
 90a8be0:	df000215 	stw	fp,8(sp)
 90a8be4:	df000204 	addi	fp,sp,8
 90a8be8:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 90a8bec:	e13fff17 	ldw	r4,-4(fp)
 90a8bf0:	90a89200 	call	90a8920 <pk_validate>
 90a8bf4:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 90a8bf8:	e0bffe17 	ldw	r2,-8(fp)
 90a8bfc:	1004c03a 	cmpne	r2,r2,zero
 90a8c00:	10001b1e 	bne	r2,zero,90a8c70 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 90a8c04:	e0bfff17 	ldw	r2,-4(fp)
 90a8c08:	10c00917 	ldw	r3,36(r2)
 90a8c0c:	188000a8 	cmpgeui	r2,r3,2
 90a8c10:	1009883a 	mov	r4,r2
 90a8c14:	18ffffc4 	addi	r3,r3,-1
 90a8c18:	e0bfff17 	ldw	r2,-4(fp)
 90a8c1c:	10c00915 	stw	r3,36(r2)
 90a8c20:	20803fcc 	andi	r2,r4,255
 90a8c24:	1004c03a 	cmpne	r2,r2,zero
 90a8c28:	1000111e 	bne	r2,zero,90a8c70 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 90a8c2c:	e0bfff17 	ldw	r2,-4(fp)
 90a8c30:	10c00217 	ldw	r3,8(r2)
 90a8c34:	d0a03717 	ldw	r2,-32548(gp)
 90a8c38:	1880051e 	bne	r3,r2,90a8c50 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 90a8c3c:	e17fff17 	ldw	r5,-4(fp)
 90a8c40:	010243b4 	movhi	r4,2318
 90a8c44:	2134c504 	addi	r4,r4,-11500
 90a8c48:	90a8e180 	call	90a8e18 <putq>
 90a8c4c:	00000806 	br	90a8c70 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 90a8c50:	e0bfff17 	ldw	r2,-4(fp)
 90a8c54:	10c00217 	ldw	r3,8(r2)
 90a8c58:	d0a03517 	ldw	r2,-32556(gp)
 90a8c5c:	1880041e 	bne	r3,r2,90a8c70 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 90a8c60:	e17fff17 	ldw	r5,-4(fp)
 90a8c64:	010243b4 	movhi	r4,2318
 90a8c68:	21348004 	addi	r4,r4,-11776
 90a8c6c:	90a8e180 	call	90a8e18 <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 90a8c70:	e037883a 	mov	sp,fp
 90a8c74:	dfc00117 	ldw	ra,4(sp)
 90a8c78:	df000017 	ldw	fp,0(sp)
 90a8c7c:	dec00204 	addi	sp,sp,8
 90a8c80:	f800283a 	ret

090a8c84 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 90a8c84:	deffff04 	addi	sp,sp,-4
 90a8c88:	df000015 	stw	fp,0(sp)
 90a8c8c:	d839883a 	mov	fp,sp
   return bigbufsiz;
 90a8c90:	d0a03717 	ldw	r2,-32548(gp)
}
 90a8c94:	e037883a 	mov	sp,fp
 90a8c98:	df000017 	ldw	fp,0(sp)
 90a8c9c:	dec00104 	addi	sp,sp,4
 90a8ca0:	f800283a 	ret

090a8ca4 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 90a8ca4:	defff904 	addi	sp,sp,-28
 90a8ca8:	dfc00615 	stw	ra,24(sp)
 90a8cac:	df000515 	stw	fp,20(sp)
 90a8cb0:	df000504 	addi	fp,sp,20
 90a8cb4:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a8cb8:	01000084 	movi	r4,2
 90a8cbc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 90a8cc0:	90a96c80 	call	90a96c8 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 90a8cc4:	00c243b4 	movhi	r3,2318
 90a8cc8:	18f48504 	addi	r3,r3,-11756
 90a8ccc:	18800017 	ldw	r2,0(r3)
 90a8cd0:	e0bffb15 	stw	r2,-20(fp)
 90a8cd4:	18800117 	ldw	r2,4(r3)
 90a8cd8:	e0bffc15 	stw	r2,-16(fp)
 90a8cdc:	18800217 	ldw	r2,8(r3)
 90a8ce0:	e0bffd15 	stw	r2,-12(fp)
 90a8ce4:	18800317 	ldw	r2,12(r3)
 90a8ce8:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 90a8cec:	90a97240 	call	90a9724 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a8cf0:	01000084 	movi	r4,2
 90a8cf4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 90a8cf8:	e13fff17 	ldw	r4,-4(fp)
 90a8cfc:	01424374 	movhi	r5,2317
 90a8d00:	297e2804 	addi	r5,r5,-1888
 90a8d04:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 90a8d08:	e1bffb17 	ldw	r6,-20(fp)
 90a8d0c:	e1fffc17 	ldw	r7,-16(fp)
 90a8d10:	e13fff17 	ldw	r4,-4(fp)
 90a8d14:	01424374 	movhi	r5,2317
 90a8d18:	297e3104 	addi	r5,r5,-1852
 90a8d1c:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 90a8d20:	e1bffd17 	ldw	r6,-12(fp)
 90a8d24:	e1fffe17 	ldw	r7,-8(fp)
 90a8d28:	e13fff17 	ldw	r4,-4(fp)
 90a8d2c:	01424374 	movhi	r5,2317
 90a8d30:	297e3e04 	addi	r5,r5,-1800
 90a8d34:	90a45b40 	call	90a45b4 <ns_printf>

   return 0;
 90a8d38:	0005883a 	mov	r2,zero
}
 90a8d3c:	e037883a 	mov	sp,fp
 90a8d40:	dfc00117 	ldw	ra,4(sp)
 90a8d44:	df000017 	ldw	fp,0(sp)
 90a8d48:	dec00204 	addi	sp,sp,8
 90a8d4c:	f800283a 	ret

090a8d50 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 90a8d50:	defffb04 	addi	sp,sp,-20
 90a8d54:	dfc00415 	stw	ra,16(sp)
 90a8d58:	df000315 	stw	fp,12(sp)
 90a8d5c:	df000304 	addi	fp,sp,12
 90a8d60:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 90a8d64:	90a96c80 	call	90a96c8 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 90a8d68:	e0bffe17 	ldw	r2,-8(fp)
 90a8d6c:	10800017 	ldw	r2,0(r2)
 90a8d70:	e0bffd15 	stw	r2,-12(fp)
 90a8d74:	e0bffd17 	ldw	r2,-12(fp)
 90a8d78:	1004c03a 	cmpne	r2,r2,zero
 90a8d7c:	1000031e 	bne	r2,zero,90a8d8c <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 90a8d80:	90a97240 	call	90a9724 <irq_Unmask>
      return (0);             /* yes, show none */
 90a8d84:	e03fff15 	stw	zero,-4(fp)
 90a8d88:	00001d06 	br	90a8e00 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 90a8d8c:	e0bffd17 	ldw	r2,-12(fp)
 90a8d90:	10c00017 	ldw	r3,0(r2)
 90a8d94:	e0bffe17 	ldw	r2,-8(fp)
 90a8d98:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 90a8d9c:	e0bffd17 	ldw	r2,-12(fp)
 90a8da0:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 90a8da4:	e0bffe17 	ldw	r2,-8(fp)
 90a8da8:	10800017 	ldw	r2,0(r2)
 90a8dac:	1004c03a 	cmpne	r2,r2,zero
 90a8db0:	1000021e 	bne	r2,zero,90a8dbc <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 90a8db4:	e0bffe17 	ldw	r2,-8(fp)
 90a8db8:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 90a8dbc:	e0bffe17 	ldw	r2,-8(fp)
 90a8dc0:	10800217 	ldw	r2,8(r2)
 90a8dc4:	10ffffc4 	addi	r3,r2,-1
 90a8dc8:	e0bffe17 	ldw	r2,-8(fp)
 90a8dcc:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 90a8dd0:	e0bffe17 	ldw	r2,-8(fp)
 90a8dd4:	10c00217 	ldw	r3,8(r2)
 90a8dd8:	e0bffe17 	ldw	r2,-8(fp)
 90a8ddc:	10800417 	ldw	r2,16(r2)
 90a8de0:	1880040e 	bge	r3,r2,90a8df4 <getq+0xa4>
      q->q_min = q->q_len;
 90a8de4:	e0bffe17 	ldw	r2,-8(fp)
 90a8de8:	10c00217 	ldw	r3,8(r2)
 90a8dec:	e0bffe17 	ldw	r2,-8(fp)
 90a8df0:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 90a8df4:	90a97240 	call	90a9724 <irq_Unmask>

   return ((void*)temp);
 90a8df8:	e0bffd17 	ldw	r2,-12(fp)
 90a8dfc:	e0bfff15 	stw	r2,-4(fp)
 90a8e00:	e0bfff17 	ldw	r2,-4(fp)
}
 90a8e04:	e037883a 	mov	sp,fp
 90a8e08:	dfc00117 	ldw	ra,4(sp)
 90a8e0c:	df000017 	ldw	fp,0(sp)
 90a8e10:	dec00204 	addi	sp,sp,8
 90a8e14:	f800283a 	ret

090a8e18 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 90a8e18:	defffc04 	addi	sp,sp,-16
 90a8e1c:	dfc00315 	stw	ra,12(sp)
 90a8e20:	df000215 	stw	fp,8(sp)
 90a8e24:	df000204 	addi	fp,sp,8
 90a8e28:	e13ffe15 	stw	r4,-8(fp)
 90a8e2c:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 90a8e30:	90a96c80 	call	90a96c8 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 90a8e34:	e0bfff17 	ldw	r2,-4(fp)
 90a8e38:	10000015 	stw	zero,0(r2)
 90a8e3c:	e0bffe17 	ldw	r2,-8(fp)
 90a8e40:	10800017 	ldw	r2,0(r2)
 90a8e44:	1004c03a 	cmpne	r2,r2,zero
 90a8e48:	1000041e 	bne	r2,zero,90a8e5c <putq+0x44>
 90a8e4c:	e0ffff17 	ldw	r3,-4(fp)
 90a8e50:	e0bffe17 	ldw	r2,-8(fp)
 90a8e54:	10c00015 	stw	r3,0(r2)
 90a8e58:	00000406 	br	90a8e6c <putq+0x54>
 90a8e5c:	e0bffe17 	ldw	r2,-8(fp)
 90a8e60:	10c00117 	ldw	r3,4(r2)
 90a8e64:	e0bfff17 	ldw	r2,-4(fp)
 90a8e68:	18800015 	stw	r2,0(r3)
 90a8e6c:	e0ffff17 	ldw	r3,-4(fp)
 90a8e70:	e0bffe17 	ldw	r2,-8(fp)
 90a8e74:	10c00115 	stw	r3,4(r2)
 90a8e78:	e0bffe17 	ldw	r2,-8(fp)
 90a8e7c:	10800217 	ldw	r2,8(r2)
 90a8e80:	10c00044 	addi	r3,r2,1
 90a8e84:	e0bffe17 	ldw	r2,-8(fp)
 90a8e88:	10c00215 	stw	r3,8(r2)
 90a8e8c:	e0bffe17 	ldw	r2,-8(fp)
 90a8e90:	10c00217 	ldw	r3,8(r2)
 90a8e94:	e0bffe17 	ldw	r2,-8(fp)
 90a8e98:	10800317 	ldw	r2,12(r2)
 90a8e9c:	10c0040e 	bge	r2,r3,90a8eb0 <putq+0x98>
 90a8ea0:	e0bffe17 	ldw	r2,-8(fp)
 90a8ea4:	10c00217 	ldw	r3,8(r2)
 90a8ea8:	e0bffe17 	ldw	r2,-8(fp)
 90a8eac:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 90a8eb0:	90a97240 	call	90a9724 <irq_Unmask>
}
 90a8eb4:	e037883a 	mov	sp,fp
 90a8eb8:	dfc00117 	ldw	ra,4(sp)
 90a8ebc:	df000017 	ldw	fp,0(sp)
 90a8ec0:	dec00204 	addi	sp,sp,8
 90a8ec4:	f800283a 	ret

090a8ec8 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 90a8ec8:	defff904 	addi	sp,sp,-28
 90a8ecc:	dfc00615 	stw	ra,24(sp)
 90a8ed0:	df000515 	stw	fp,20(sp)
 90a8ed4:	df000504 	addi	fp,sp,20
 90a8ed8:	e13ffd15 	stw	r4,-12(fp)
 90a8edc:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 90a8ee0:	90a96c80 	call	90a96c8 <irq_Mask>
   qptr = q->q_head;
 90a8ee4:	e0bffd17 	ldw	r2,-12(fp)
 90a8ee8:	10800017 	ldw	r2,0(r2)
 90a8eec:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 90a8ef0:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 90a8ef4:	00002d06 	br	90a8fac <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 90a8ef8:	e0fffe17 	ldw	r3,-8(fp)
 90a8efc:	e0bffc17 	ldw	r2,-16(fp)
 90a8f00:	10c0251e 	bne	r2,r3,90a8f98 <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 90a8f04:	e0bffb17 	ldw	r2,-20(fp)
 90a8f08:	1005003a 	cmpeq	r2,r2,zero
 90a8f0c:	1000051e 	bne	r2,zero,90a8f24 <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 90a8f10:	e0bffc17 	ldw	r2,-16(fp)
 90a8f14:	10c00017 	ldw	r3,0(r2)
 90a8f18:	e0bffb17 	ldw	r2,-20(fp)
 90a8f1c:	10c00015 	stw	r3,0(r2)
 90a8f20:	00000406 	br	90a8f34 <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 90a8f24:	e0bffc17 	ldw	r2,-16(fp)
 90a8f28:	10c00017 	ldw	r3,0(r2)
 90a8f2c:	e0bffd17 	ldw	r2,-12(fp)
 90a8f30:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 90a8f34:	e0bffd17 	ldw	r2,-12(fp)
 90a8f38:	10c00117 	ldw	r3,4(r2)
 90a8f3c:	e0bffe17 	ldw	r2,-8(fp)
 90a8f40:	1880031e 	bne	r3,r2,90a8f50 <qdel+0x88>
            q->q_tail = qlast;
 90a8f44:	e0fffd17 	ldw	r3,-12(fp)
 90a8f48:	e0bffb17 	ldw	r2,-20(fp)
 90a8f4c:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 90a8f50:	e0bffd17 	ldw	r2,-12(fp)
 90a8f54:	10800217 	ldw	r2,8(r2)
 90a8f58:	10ffffc4 	addi	r3,r2,-1
 90a8f5c:	e0bffd17 	ldw	r2,-12(fp)
 90a8f60:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 90a8f64:	e0bffd17 	ldw	r2,-12(fp)
 90a8f68:	10c00217 	ldw	r3,8(r2)
 90a8f6c:	e0bffd17 	ldw	r2,-12(fp)
 90a8f70:	10800417 	ldw	r2,16(r2)
 90a8f74:	1880040e 	bge	r3,r2,90a8f88 <qdel+0xc0>
            q->q_min = q->q_len;
 90a8f78:	e0bffd17 	ldw	r2,-12(fp)
 90a8f7c:	10c00217 	ldw	r3,8(r2)
 90a8f80:	e0bffd17 	ldw	r2,-12(fp)
 90a8f84:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 90a8f88:	90a97240 	call	90a9724 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 90a8f8c:	e0bffe17 	ldw	r2,-8(fp)
 90a8f90:	e0bfff15 	stw	r2,-4(fp)
 90a8f94:	00000a06 	br	90a8fc0 <qdel+0xf8>
      }
      qlast = qptr;
 90a8f98:	e0bffc17 	ldw	r2,-16(fp)
 90a8f9c:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 90a8fa0:	e0bffc17 	ldw	r2,-16(fp)
 90a8fa4:	10800017 	ldw	r2,0(r2)
 90a8fa8:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 90a8fac:	e0bffc17 	ldw	r2,-16(fp)
 90a8fb0:	1004c03a 	cmpne	r2,r2,zero
 90a8fb4:	103fd01e 	bne	r2,zero,90a8ef8 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 90a8fb8:	90a97240 	call	90a9724 <irq_Unmask>
   return NULL;   /* item not found in queue */
 90a8fbc:	e03fff15 	stw	zero,-4(fp)
 90a8fc0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a8fc4:	e037883a 	mov	sp,fp
 90a8fc8:	dfc00117 	ldw	ra,4(sp)
 90a8fcc:	df000017 	ldw	fp,0(sp)
 90a8fd0:	dec00204 	addi	sp,sp,8
 90a8fd4:	f800283a 	ret

090a8fd8 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 90a8fd8:	defff304 	addi	sp,sp,-52
 90a8fdc:	dfc00c15 	stw	ra,48(sp)
 90a8fe0:	df000b15 	stw	fp,44(sp)
 90a8fe4:	df000b04 	addi	fp,sp,44
 90a8fe8:	e13ffb15 	stw	r4,-20(fp)
 90a8fec:	e1fffe15 	stw	r7,-8(fp)
 90a8ff0:	e17ffc0d 	sth	r5,-16(fp)
 90a8ff4:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 90a8ff8:	00824374 	movhi	r2,2317
 90a8ffc:	108c1d04 	addi	r2,r2,12404
 90a9000:	10800017 	ldw	r2,0(r2)
 90a9004:	1080010c 	andi	r2,r2,4
 90a9008:	1005003a 	cmpeq	r2,r2,zero
 90a900c:	1000171e 	bne	r2,zero,90a906c <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 90a9010:	e0bffb17 	ldw	r2,-20(fp)
 90a9014:	11803fcc 	andi	r6,r2,255
 90a9018:	e0bffb17 	ldw	r2,-20(fp)
 90a901c:	1004d23a 	srli	r2,r2,8
 90a9020:	11c03fcc 	andi	r7,r2,255
 90a9024:	e0bffb17 	ldw	r2,-20(fp)
 90a9028:	1004d43a 	srli	r2,r2,16
 90a902c:	12003fcc 	andi	r8,r2,255
 90a9030:	e0bffb17 	ldw	r2,-20(fp)
 90a9034:	1006d63a 	srli	r3,r2,24
 90a9038:	e13ffd0b 	ldhu	r4,-12(fp)
 90a903c:	e17ffc0b 	ldhu	r5,-16(fp)
 90a9040:	e0800217 	ldw	r2,8(fp)
 90a9044:	d8c00015 	stw	r3,0(sp)
 90a9048:	d9000115 	stw	r4,4(sp)
 90a904c:	d9400215 	stw	r5,8(sp)
 90a9050:	d8800315 	stw	r2,12(sp)
 90a9054:	01024374 	movhi	r4,2317
 90a9058:	213e4a04 	addi	r4,r4,-1752
 90a905c:	300b883a 	mov	r5,r6
 90a9060:	380d883a 	mov	r6,r7
 90a9064:	400f883a 	mov	r7,r8
 90a9068:	90825100 	call	9082510 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 90a906c:	0009883a 	mov	r4,zero
 90a9070:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   ocon = NULL;
 90a9074:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 90a9078:	d0a09c17 	ldw	r2,-32144(gp)
 90a907c:	e0bffa15 	stw	r2,-24(fp)
 90a9080:	00002406 	br	90a9114 <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 90a9084:	e0bffa17 	ldw	r2,-24(fp)
 90a9088:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 90a908c:	e0bffa17 	ldw	r2,-24(fp)
 90a9090:	1080018b 	ldhu	r2,6(r2)
 90a9094:	10ffffcc 	andi	r3,r2,65535
 90a9098:	e0bffd0b 	ldhu	r2,-12(fp)
 90a909c:	18801a1e 	bne	r3,r2,90a9108 <udp_open+0x130>
 90a90a0:	e0bffa17 	ldw	r2,-24(fp)
 90a90a4:	1080020b 	ldhu	r2,8(r2)
 90a90a8:	10ffffcc 	andi	r3,r2,65535
 90a90ac:	e0bffc0b 	ldhu	r2,-16(fp)
 90a90b0:	1880151e 	bne	r3,r2,90a9108 <udp_open+0x130>
 90a90b4:	e0bffa17 	ldw	r2,-24(fp)
 90a90b8:	10800317 	ldw	r2,12(r2)
 90a90bc:	1004c03a 	cmpne	r2,r2,zero
 90a90c0:	1000111e 	bne	r2,zero,90a9108 <udp_open+0x130>
 90a90c4:	e0bffa17 	ldw	r2,-24(fp)
 90a90c8:	10c00417 	ldw	r3,16(r2)
 90a90cc:	e0bffb17 	ldw	r2,-20(fp)
 90a90d0:	18800d1e 	bne	r3,r2,90a9108 <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 90a90d4:	00824374 	movhi	r2,2317
 90a90d8:	108c1d04 	addi	r2,r2,12404
 90a90dc:	10800017 	ldw	r2,0(r2)
 90a90e0:	1080050c 	andi	r2,r2,20
 90a90e4:	1005003a 	cmpeq	r2,r2,zero
 90a90e8:	1000031e 	bne	r2,zero,90a90f8 <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 90a90ec:	01024374 	movhi	r4,2317
 90a90f0:	213e5904 	addi	r4,r4,-1692
 90a90f4:	90828380 	call	9082838 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 90a90f8:	0009883a 	mov	r4,zero
 90a90fc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return(NULL);
 90a9100:	e03fff15 	stw	zero,-4(fp)
 90a9104:	00003c06 	br	90a91f8 <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 90a9108:	e0bffa17 	ldw	r2,-24(fp)
 90a910c:	10800017 	ldw	r2,0(r2)
 90a9110:	e0bffa15 	stw	r2,-24(fp)
 90a9114:	e0bffa17 	ldw	r2,-24(fp)
 90a9118:	1004c03a 	cmpne	r2,r2,zero
 90a911c:	103fd91e 	bne	r2,zero,90a9084 <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 90a9120:	01000804 	movi	r4,32
 90a9124:	90a9f0c0 	call	90a9f0c <npalloc>
 90a9128:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 90a912c:	e0bffa17 	ldw	r2,-24(fp)
 90a9130:	1004c03a 	cmpne	r2,r2,zero
 90a9134:	10000d1e 	bne	r2,zero,90a916c <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 90a9138:	00824374 	movhi	r2,2317
 90a913c:	108c1d04 	addi	r2,r2,12404
 90a9140:	10800017 	ldw	r2,0(r2)
 90a9144:	1080010c 	andi	r2,r2,4
 90a9148:	1005003a 	cmpeq	r2,r2,zero
 90a914c:	1000031e 	bne	r2,zero,90a915c <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 90a9150:	01024374 	movhi	r4,2317
 90a9154:	213e6104 	addi	r4,r4,-1660
 90a9158:	90828380 	call	9082838 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90a915c:	0009883a 	mov	r4,zero
 90a9160:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return(NULL);
 90a9164:	e03fff15 	stw	zero,-4(fp)
 90a9168:	00002306 	br	90a91f8 <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 90a916c:	e0bff917 	ldw	r2,-28(fp)
 90a9170:	1005003a 	cmpeq	r2,r2,zero
 90a9174:	1000041e 	bne	r2,zero,90a9188 <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 90a9178:	e0fff917 	ldw	r3,-28(fp)
 90a917c:	e0bffa17 	ldw	r2,-24(fp)
 90a9180:	18800015 	stw	r2,0(r3)
 90a9184:	00000206 	br	90a9190 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 90a9188:	e0bffa17 	ldw	r2,-24(fp)
 90a918c:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 90a9190:	e0bffa17 	ldw	r2,-24(fp)
 90a9194:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 90a9198:	e0fffa17 	ldw	r3,-24(fp)
 90a919c:	e0bffd0b 	ldhu	r2,-12(fp)
 90a91a0:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 90a91a4:	e0fffa17 	ldw	r3,-24(fp)
 90a91a8:	e0bffc0b 	ldhu	r2,-16(fp)
 90a91ac:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 90a91b0:	e0bffa17 	ldw	r2,-24(fp)
 90a91b4:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 90a91b8:	e0fffa17 	ldw	r3,-24(fp)
 90a91bc:	e0bffb17 	ldw	r2,-20(fp)
 90a91c0:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 90a91c4:	e0fffa17 	ldw	r3,-24(fp)
 90a91c8:	e0bffe17 	ldw	r2,-8(fp)
 90a91cc:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 90a91d0:	e0fffa17 	ldw	r3,-24(fp)
 90a91d4:	e0800217 	ldw	r2,8(fp)
 90a91d8:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 90a91dc:	e0fffa17 	ldw	r3,-24(fp)
 90a91e0:	00800044 	movi	r2,1
 90a91e4:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 90a91e8:	0009883a 	mov	r4,zero
 90a91ec:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return(con);
 90a91f0:	e0bffa17 	ldw	r2,-24(fp)
 90a91f4:	e0bfff15 	stw	r2,-4(fp)
 90a91f8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a91fc:	e037883a 	mov	sp,fp
 90a9200:	dfc00117 	ldw	ra,4(sp)
 90a9204:	df000017 	ldw	fp,0(sp)
 90a9208:	dec00204 	addi	sp,sp,8
 90a920c:	f800283a 	ret

090a9210 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 90a9210:	defffb04 	addi	sp,sp,-20
 90a9214:	dfc00415 	stw	ra,16(sp)
 90a9218:	df000315 	stw	fp,12(sp)
 90a921c:	df000304 	addi	fp,sp,12
 90a9220:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 90a9224:	e0bfff17 	ldw	r2,-4(fp)
 90a9228:	1005003a 	cmpeq	r2,r2,zero
 90a922c:	1000031e 	bne	r2,zero,90a923c <udp_close+0x2c>
 90a9230:	d0a09c17 	ldw	r2,-32144(gp)
 90a9234:	1004c03a 	cmpne	r2,r2,zero
 90a9238:	1000021e 	bne	r2,zero,90a9244 <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 90a923c:	90a94880 	call	90a9488 <dtrap>
      return;
 90a9240:	00002706 	br	90a92e0 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 90a9244:	0009883a 	mov	r4,zero
 90a9248:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 90a924c:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 90a9250:	d0a09c17 	ldw	r2,-32144(gp)
 90a9254:	e0bffe15 	stw	r2,-8(fp)
 90a9258:	00000806 	br	90a927c <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 90a925c:	e0fffe17 	ldw	r3,-8(fp)
 90a9260:	e0bfff17 	ldw	r2,-4(fp)
 90a9264:	18800826 	beq	r3,r2,90a9288 <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 90a9268:	e0bffe17 	ldw	r2,-8(fp)
 90a926c:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 90a9270:	e0bffe17 	ldw	r2,-8(fp)
 90a9274:	10800017 	ldw	r2,0(r2)
 90a9278:	e0bffe15 	stw	r2,-8(fp)
 90a927c:	e0bffe17 	ldw	r2,-8(fp)
 90a9280:	1004c03a 	cmpne	r2,r2,zero
 90a9284:	103ff51e 	bne	r2,zero,90a925c <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 90a9288:	e0bffe17 	ldw	r2,-8(fp)
 90a928c:	1004c03a 	cmpne	r2,r2,zero
 90a9290:	1000041e 	bne	r2,zero,90a92a4 <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 90a9294:	90a94880 	call	90a9488 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 90a9298:	0009883a 	mov	r4,zero
 90a929c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return;
 90a92a0:	00000f06 	br	90a92e0 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 90a92a4:	e0bffd17 	ldw	r2,-12(fp)
 90a92a8:	1005003a 	cmpeq	r2,r2,zero
 90a92ac:	1000051e 	bne	r2,zero,90a92c4 <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 90a92b0:	e0bfff17 	ldw	r2,-4(fp)
 90a92b4:	10c00017 	ldw	r3,0(r2)
 90a92b8:	e0bffd17 	ldw	r2,-12(fp)
 90a92bc:	10c00015 	stw	r3,0(r2)
 90a92c0:	00000306 	br	90a92d0 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 90a92c4:	e0bfff17 	ldw	r2,-4(fp)
 90a92c8:	10800017 	ldw	r2,0(r2)
 90a92cc:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 90a92d0:	e13fff17 	ldw	r4,-4(fp)
 90a92d4:	90aa0000 	call	90aa000 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90a92d8:	0009883a 	mov	r4,zero
 90a92dc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
}
 90a92e0:	e037883a 	mov	sp,fp
 90a92e4:	dfc00117 	ldw	ra,4(sp)
 90a92e8:	df000017 	ldw	fp,0(sp)
 90a92ec:	dec00204 	addi	sp,sp,8
 90a92f0:	f800283a 	ret

090a92f4 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 90a92f4:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 90a92f8:	0140620e 	bge	zero,r5,90a9484 <done>

      mov   r6, zero		       /* carry accumulator */
 90a92fc:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 90a9300:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 90a9304:	18000326 	beq	r3,zero,90a9314 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 90a9308:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 90a930c:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 90a9310:	297fffc4 	addi	r5,r5,-1

090a9314 <asm1>:
 90a9314:	02c242f4 	movhi	r11,2315
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 90a9318:	5ae51004 	addi	r11,r11,-27584
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 90a931c:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 90a9320:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 90a9324:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 90a9328:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 90a932c:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 90a9330:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 90a9334:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 90a9338:	5800683a 	jmp	r11

090a933c <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 90a933c:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 90a9340:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 90a9344:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9348:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a934c:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 90a9350:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 90a9354:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9358:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a935c:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 90a9360:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 90a9364:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9368:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a936c:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 90a9370:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 90a9374:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9378:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a937c:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 90a9380:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 90a9384:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9388:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a938c:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 90a9390:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 90a9394:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9398:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a939c:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 90a93a0:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 90a93a4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93a8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93ac:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 90a93b0:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 90a93b4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93b8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93bc:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 90a93c0:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 90a93c4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93c8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93cc:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 90a93d0:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 90a93d4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93d8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93dc:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 90a93e0:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 90a93e4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93e8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93ec:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 90a93f0:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 90a93f4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a93f8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a93fc:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 90a9400:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 90a9404:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9408:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a940c:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 90a9410:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 90a9414:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9418:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a941c:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 90a9420:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 90a9424:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9428:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a942c:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 90a9430:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 90a9434:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9438:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a943c:	418d883a 	add	r6,r8,r6

090a9440 <loop0>:
loop0:
      subi  r5, r5, 16
 90a9440:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 90a9444:	283fbd0e 	bge	r5,zero,90a933c <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 90a9448:	48000426 	beq	r9,zero,90a945c <fold>
      ldhu  r7, 0(r4)
 90a944c:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 90a9450:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90a9454:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90a9458:	418d883a 	add	r6,r8,r6

090a945c <fold>:
      
fold:
      srli  r7, r2, 16
 90a945c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90a9460:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 90a9464:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 90a9468:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 90a946c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90a9470:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 90a9474:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 90a9478:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90a947c:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 90a9480:	3885883a 	add	r2,r7,r2

090a9484 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 90a9484:	f800283a 	ret

090a9488 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 90a9488:	defffe04 	addi	sp,sp,-8
 90a948c:	dfc00115 	stw	ra,4(sp)
 90a9490:	df000015 	stw	fp,0(sp)
 90a9494:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 90a9498:	01024374 	movhi	r4,2317
 90a949c:	213e6b04 	addi	r4,r4,-1620
 90a94a0:	90828380 	call	9082838 <puts>
}
 90a94a4:	e037883a 	mov	sp,fp
 90a94a8:	dfc00117 	ldw	ra,4(sp)
 90a94ac:	df000017 	ldw	fp,0(sp)
 90a94b0:	dec00204 	addi	sp,sp,8
 90a94b4:	f800283a 	ret

090a94b8 <kbhit>:

int
kbhit()
{
 90a94b8:	defffc04 	addi	sp,sp,-16
 90a94bc:	dfc00315 	stw	ra,12(sp)
 90a94c0:	df000215 	stw	fp,8(sp)
 90a94c4:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 90a94c8:	d0a09d17 	ldw	r2,-32140(gp)
 90a94cc:	1004c03a 	cmpne	r2,r2,zero
 90a94d0:	10000c1e 	bne	r2,zero,90a9504 <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 90a94d4:	0009883a 	mov	r4,zero
 90a94d8:	01400104 	movi	r5,4
 90a94dc:	01900004 	movi	r6,16384
 90a94e0:	90bb6980 	call	90bb698 <fcntl>
 90a94e4:	1005003a 	cmpeq	r2,r2,zero
 90a94e8:	1000041e 	bne	r2,zero,90a94fc <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 90a94ec:	01024374 	movhi	r4,2317
 90a94f0:	213e7204 	addi	r4,r4,-1592
 90a94f4:	90828380 	call	9082838 <puts>
         dtrap();
 90a94f8:	90a94880 	call	90a9488 <dtrap>
      }
      kbd_init = 1; 
 90a94fc:	00800044 	movi	r2,1
 90a9500:	d0a09d15 	stw	r2,-32140(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 90a9504:	d0a03817 	ldw	r2,-32544(gp)
 90a9508:	10bfffd8 	cmpnei	r2,r2,-1
 90a950c:	10000d1e 	bne	r2,zero,90a9544 <kbhit+0x8c>
   {
      kb = getchar();
 90a9510:	00824374 	movhi	r2,2317
 90a9514:	108b9b04 	addi	r2,r2,11884
 90a9518:	10800017 	ldw	r2,0(r2)
 90a951c:	11000117 	ldw	r4,4(r2)
 90a9520:	90821500 	call	9082150 <getc>
 90a9524:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 90a9528:	e0bffe17 	ldw	r2,-8(fp)
 90a952c:	1004403a 	cmpge	r2,r2,zero
 90a9530:	1000021e 	bne	r2,zero,90a953c <kbhit+0x84>
         return (FALSE);
 90a9534:	e03fff15 	stw	zero,-4(fp)
 90a9538:	00000406 	br	90a954c <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 90a953c:	e0bffe17 	ldw	r2,-8(fp)
 90a9540:	d0a03815 	stw	r2,-32544(gp)
   }

   return (TRUE);
 90a9544:	00800044 	movi	r2,1
 90a9548:	e0bfff15 	stw	r2,-4(fp)
 90a954c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9550:	e037883a 	mov	sp,fp
 90a9554:	dfc00117 	ldw	ra,4(sp)
 90a9558:	df000017 	ldw	fp,0(sp)
 90a955c:	dec00204 	addi	sp,sp,8
 90a9560:	f800283a 	ret

090a9564 <getch>:

int 
getch()
{
 90a9564:	defffd04 	addi	sp,sp,-12
 90a9568:	dfc00215 	stw	ra,8(sp)
 90a956c:	df000115 	stw	fp,4(sp)
 90a9570:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 90a9574:	d0a03817 	ldw	r2,-32544(gp)
 90a9578:	10bfffe0 	cmpeqi	r2,r2,-1
 90a957c:	1000051e 	bne	r2,zero,90a9594 <getch+0x30>
   {
      chr = kb_last;
 90a9580:	d0a03817 	ldw	r2,-32544(gp)
 90a9584:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 90a9588:	00bfffc4 	movi	r2,-1
 90a958c:	d0a03815 	stw	r2,-32544(gp)
 90a9590:	00000606 	br	90a95ac <getch+0x48>
   }
   else
      chr = getchar();
 90a9594:	00824374 	movhi	r2,2317
 90a9598:	108b9b04 	addi	r2,r2,11884
 90a959c:	10800017 	ldw	r2,0(r2)
 90a95a0:	11000117 	ldw	r4,4(r2)
 90a95a4:	90821500 	call	9082150 <getc>
 90a95a8:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 90a95ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90a95b0:	e037883a 	mov	sp,fp
 90a95b4:	dfc00117 	ldw	ra,4(sp)
 90a95b8:	df000017 	ldw	fp,0(sp)
 90a95bc:	dec00204 	addi	sp,sp,8
 90a95c0:	f800283a 	ret

090a95c4 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 90a95c4:	deffff04 	addi	sp,sp,-4
 90a95c8:	df000015 	stw	fp,0(sp)
 90a95cc:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 90a95d0:	00801904 	movi	r2,100
 90a95d4:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 90a95d8:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 90a95dc:	00824374 	movhi	r2,2317
 90a95e0:	108c4204 	addi	r2,r2,12552
 90a95e4:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 90a95e8:	00800044 	movi	r2,1
 90a95ec:	d0a09e15 	stw	r2,-32136(gp)
}
 90a95f0:	e037883a 	mov	sp,fp
 90a95f4:	df000017 	ldw	fp,0(sp)
 90a95f8:	dec00104 	addi	sp,sp,4
 90a95fc:	f800283a 	ret

090a9600 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 90a9600:	deffff04 	addi	sp,sp,-4
 90a9604:	df000015 	stw	fp,0(sp)
 90a9608:	d839883a 	mov	fp,sp
   /* null */ ;
}
 90a960c:	e037883a 	mov	sp,fp
 90a9610:	df000017 	ldw	fp,0(sp)
 90a9614:	dec00104 	addi	sp,sp,4
 90a9618:	f800283a 	ret

090a961c <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 90a961c:	defffe04 	addi	sp,sp,-8
 90a9620:	dfc00115 	stw	ra,4(sp)
 90a9624:	df000015 	stw	fp,0(sp)
 90a9628:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 90a962c:	d0a09e17 	ldw	r2,-32136(gp)
 90a9630:	1005003a 	cmpeq	r2,r2,zero
 90a9634:	10001f1e 	bne	r2,zero,90a96b4 <cticks_hook+0x98>
   {
      cticks_factor += TPS;
 90a9638:	d120a117 	ldw	r4,-32124(gp)
 90a963c:	908be680 	call	908be68 <__floatsidf>
 90a9640:	100b883a 	mov	r5,r2
 90a9644:	180d883a 	mov	r6,r3
 90a9648:	2809883a 	mov	r4,r5
 90a964c:	300b883a 	mov	r5,r6
 90a9650:	000d883a 	mov	r6,zero
 90a9654:	01d01674 	movhi	r7,16473
 90a9658:	908b5400 	call	908b540 <__adddf3>
 90a965c:	1009883a 	mov	r4,r2
 90a9660:	180b883a 	mov	r5,r3
 90a9664:	2005883a 	mov	r2,r4
 90a9668:	2807883a 	mov	r3,r5
 90a966c:	1009883a 	mov	r4,r2
 90a9670:	180b883a 	mov	r5,r3
 90a9674:	908bf600 	call	908bf60 <__fixdfsi>
 90a9678:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 90a967c:	d0e0a117 	ldw	r3,-32124(gp)
 90a9680:	d0a0a217 	ldw	r2,-32120(gp)
 90a9684:	18800b16 	blt	r3,r2,90a96b4 <cticks_hook+0x98>
      {
         cticks++;
 90a9688:	00824374 	movhi	r2,2317
 90a968c:	108c4204 	addi	r2,r2,12552
 90a9690:	10800017 	ldw	r2,0(r2)
 90a9694:	10c00044 	addi	r3,r2,1
 90a9698:	00824374 	movhi	r2,2317
 90a969c:	108c4204 	addi	r2,r2,12552
 90a96a0:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 90a96a4:	d0e0a117 	ldw	r3,-32124(gp)
 90a96a8:	d0a0a217 	ldw	r2,-32120(gp)
 90a96ac:	1885c83a 	sub	r2,r3,r2
 90a96b0:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 90a96b4:	e037883a 	mov	sp,fp
 90a96b8:	dfc00117 	ldw	ra,4(sp)
 90a96bc:	df000017 	ldw	fp,0(sp)
 90a96c0:	dec00204 	addi	sp,sp,8
 90a96c4:	f800283a 	ret

090a96c8 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 90a96c8:	defffd04 	addi	sp,sp,-12
 90a96cc:	df000215 	stw	fp,8(sp)
 90a96d0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90a96d4:	0005303a 	rdctl	r2,status
 90a96d8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90a96dc:	e0fffe17 	ldw	r3,-8(fp)
 90a96e0:	00bfff84 	movi	r2,-2
 90a96e4:	1884703a 	and	r2,r3,r2
 90a96e8:	1001703a 	wrctl	status,r2
  
  return context;
 90a96ec:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 90a96f0:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 90a96f4:	d0a09f17 	ldw	r2,-32132(gp)
 90a96f8:	10800044 	addi	r2,r2,1
 90a96fc:	d0a09f15 	stw	r2,-32132(gp)
 90a9700:	d0a09f17 	ldw	r2,-32132(gp)
 90a9704:	10800058 	cmpnei	r2,r2,1
 90a9708:	1000021e 	bne	r2,zero,90a9714 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 90a970c:	e0bfff17 	ldw	r2,-4(fp)
 90a9710:	d0a0a015 	stw	r2,-32128(gp)
   }
}
 90a9714:	e037883a 	mov	sp,fp
 90a9718:	df000017 	ldw	fp,0(sp)
 90a971c:	dec00104 	addi	sp,sp,4
 90a9720:	f800283a 	ret

090a9724 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 90a9724:	defffe04 	addi	sp,sp,-8
 90a9728:	df000115 	stw	fp,4(sp)
 90a972c:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 90a9730:	d0a09f17 	ldw	r2,-32132(gp)
 90a9734:	10bfffc4 	addi	r2,r2,-1
 90a9738:	d0a09f15 	stw	r2,-32132(gp)
 90a973c:	d0a09f17 	ldw	r2,-32132(gp)
 90a9740:	1004c03a 	cmpne	r2,r2,zero
 90a9744:	1000041e 	bne	r2,zero,90a9758 <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 90a9748:	d0a0a017 	ldw	r2,-32128(gp)
 90a974c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90a9750:	e0bfff17 	ldw	r2,-4(fp)
 90a9754:	1001703a 	wrctl	status,r2
   }
}
 90a9758:	e037883a 	mov	sp,fp
 90a975c:	df000017 	ldw	fp,0(sp)
 90a9760:	dec00104 	addi	sp,sp,4
 90a9764:	f800283a 	ret

090a9768 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 90a9768:	defffb04 	addi	sp,sp,-20
 90a976c:	dfc00415 	stw	ra,16(sp)
 90a9770:	df000315 	stw	fp,12(sp)
 90a9774:	df000304 	addi	fp,sp,12
 90a9778:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90a977c:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 90a9780:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 90a9784:	e0bfff17 	ldw	r2,-4(fp)
 90a9788:	1004803a 	cmplt	r2,r2,zero
 90a978c:	1000201e 	bne	r2,zero,90a9810 <LOCK_NET_RESOURCE+0xa8>
 90a9790:	e0bfff17 	ldw	r2,-4(fp)
 90a9794:	10800408 	cmpgei	r2,r2,16
 90a9798:	10001d1e 	bne	r2,zero,90a9810 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 90a979c:	e0bfff17 	ldw	r2,-4(fp)
 90a97a0:	00c243b4 	movhi	r3,2318
 90a97a4:	18f54504 	addi	r3,r3,-10988
 90a97a8:	1085883a 	add	r2,r2,r2
 90a97ac:	1085883a 	add	r2,r2,r2
 90a97b0:	10c5883a 	add	r2,r2,r3
 90a97b4:	11000017 	ldw	r4,0(r2)
 90a97b8:	e1bffe04 	addi	r6,fp,-8
 90a97bc:	000b883a 	mov	r5,zero
 90a97c0:	9092c6c0 	call	9092c6c <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 90a97c4:	e0bffe03 	ldbu	r2,-8(fp)
 90a97c8:	10803fcc 	andi	r2,r2,255
 90a97cc:	10800298 	cmpnei	r2,r2,10
 90a97d0:	10000a1e 	bne	r2,zero,90a97fc <LOCK_NET_RESOURCE+0x94>
 90a97d4:	e0bffd17 	ldw	r2,-12(fp)
 90a97d8:	10800044 	addi	r2,r2,1
 90a97dc:	e0bffd15 	stw	r2,-12(fp)
 90a97e0:	e0bffd17 	ldw	r2,-12(fp)
 90a97e4:	1080fa50 	cmplti	r2,r2,1001
 90a97e8:	1000041e 	bne	r2,zero,90a97fc <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 90a97ec:	01024374 	movhi	r4,2317
 90a97f0:	213e7604 	addi	r4,r4,-1576
 90a97f4:	90a438c0 	call	90a438c <panic>
            return;
 90a97f8:	00000606 	br	90a9814 <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 90a97fc:	e0bffe03 	ldbu	r2,-8(fp)
 90a9800:	10803fcc 	andi	r2,r2,255
 90a9804:	108002a0 	cmpeqi	r2,r2,10
 90a9808:	103fe41e 	bne	r2,zero,90a979c <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 90a980c:	00000106 	br	90a9814 <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 90a9810:	90a94880 	call	90a9488 <dtrap>
}
 90a9814:	e037883a 	mov	sp,fp
 90a9818:	dfc00117 	ldw	ra,4(sp)
 90a981c:	df000017 	ldw	fp,0(sp)
 90a9820:	dec00204 	addi	sp,sp,8
 90a9824:	f800283a 	ret

090a9828 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 90a9828:	defffc04 	addi	sp,sp,-16
 90a982c:	dfc00315 	stw	ra,12(sp)
 90a9830:	df000215 	stw	fp,8(sp)
 90a9834:	df000204 	addi	fp,sp,8
 90a9838:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90a983c:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 90a9840:	e0bfff17 	ldw	r2,-4(fp)
 90a9844:	1004803a 	cmplt	r2,r2,zero
 90a9848:	1000131e 	bne	r2,zero,90a9898 <UNLOCK_NET_RESOURCE+0x70>
 90a984c:	e0bfff17 	ldw	r2,-4(fp)
 90a9850:	10800408 	cmpgei	r2,r2,16
 90a9854:	1000101e 	bne	r2,zero,90a9898 <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 90a9858:	e0bfff17 	ldw	r2,-4(fp)
 90a985c:	00c243b4 	movhi	r3,2318
 90a9860:	18f54504 	addi	r3,r3,-10988
 90a9864:	1085883a 	add	r2,r2,r2
 90a9868:	1085883a 	add	r2,r2,r2
 90a986c:	10c5883a 	add	r2,r2,r3
 90a9870:	11000017 	ldw	r4,0(r2)
 90a9874:	90930640 	call	9093064 <OSSemPost>
 90a9878:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 90a987c:	e0bffe03 	ldbu	r2,-8(fp)
 90a9880:	1005003a 	cmpeq	r2,r2,zero
 90a9884:	1000051e 	bne	r2,zero,90a989c <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 90a9888:	01024374 	movhi	r4,2317
 90a988c:	213e7904 	addi	r4,r4,-1564
 90a9890:	90a438c0 	call	90a438c <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 90a9894:	00000106 	br	90a989c <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 90a9898:	90a94880 	call	90a9488 <dtrap>
}
 90a989c:	e037883a 	mov	sp,fp
 90a98a0:	dfc00117 	ldw	ra,4(sp)
 90a98a4:	df000017 	ldw	fp,0(sp)
 90a98a8:	dec00204 	addi	sp,sp,8
 90a98ac:	f800283a 	ret

090a98b0 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 90a98b0:	deffed04 	addi	sp,sp,-76
 90a98b4:	dfc01215 	stw	ra,72(sp)
 90a98b8:	df001115 	stw	fp,68(sp)
 90a98bc:	df001104 	addi	fp,sp,68
 90a98c0:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 90a98c4:	e0bffe17 	ldw	r2,-8(fp)
 90a98c8:	10800417 	ldw	r2,16(r2)
 90a98cc:	1009883a 	mov	r4,r2
 90a98d0:	90a9f0c0 	call	90a9f0c <npalloc>
 90a98d4:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 90a98d8:	e0bff417 	ldw	r2,-48(fp)
 90a98dc:	1004c03a 	cmpne	r2,r2,zero
 90a98e0:	1000031e 	bne	r2,zero,90a98f0 <TK_NEWTASK+0x40>
      panic("stack alloc");
 90a98e4:	01024374 	movhi	r4,2317
 90a98e8:	213e7c04 	addi	r4,r4,-1552
 90a98ec:	90a438c0 	call	90a438c <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 90a98f0:	e0bffe17 	ldw	r2,-8(fp)
 90a98f4:	11400217 	ldw	r5,8(r2)
 90a98f8:	e0bffe17 	ldw	r2,-8(fp)
 90a98fc:	10800417 	ldw	r2,16(r2)
 90a9900:	1004d0ba 	srli	r2,r2,2
 90a9904:	1085883a 	add	r2,r2,r2
 90a9908:	1085883a 	add	r2,r2,r2
 90a990c:	1007883a 	mov	r3,r2
 90a9910:	e0bff417 	ldw	r2,-48(fp)
 90a9914:	1885883a 	add	r2,r3,r2
 90a9918:	11bfff04 	addi	r6,r2,-4
 90a991c:	e0bffe17 	ldw	r2,-8(fp)
 90a9920:	10800317 	ldw	r2,12(r2)
 90a9924:	11c03fcc 	andi	r7,r2,255
 90a9928:	e0bffe17 	ldw	r2,-8(fp)
 90a992c:	10800317 	ldw	r2,12(r2)
 90a9930:	10ffffcc 	andi	r3,r2,65535
 90a9934:	e0bffe17 	ldw	r2,-8(fp)
 90a9938:	10800417 	ldw	r2,16(r2)
 90a993c:	1008d0ba 	srli	r4,r2,2
 90a9940:	d8c00015 	stw	r3,0(sp)
 90a9944:	e0bff417 	ldw	r2,-48(fp)
 90a9948:	d8800115 	stw	r2,4(sp)
 90a994c:	d9000215 	stw	r4,8(sp)
 90a9950:	d8000315 	stw	zero,12(sp)
 90a9954:	008000c4 	movi	r2,3
 90a9958:	d8800415 	stw	r2,16(sp)
 90a995c:	2809883a 	mov	r4,r5
 90a9960:	000b883a 	mov	r5,zero
 90a9964:	9093b080 	call	9093b08 <OSTaskCreateExt>
 90a9968:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 90a996c:	e0bff503 	ldbu	r2,-44(fp)
 90a9970:	10803fcc 	andi	r2,r2,255
 90a9974:	10800a18 	cmpnei	r2,r2,40
 90a9978:	1000161e 	bne	r2,zero,90a99d4 <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 90a997c:	e0bffe17 	ldw	r2,-8(fp)
 90a9980:	10800317 	ldw	r2,12(r2)
 90a9984:	11003fcc 	andi	r4,r2,255
 90a9988:	e17ff584 	addi	r5,fp,-42
 90a998c:	e1bff544 	addi	r6,fp,-43
 90a9990:	90942840 	call	9094284 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 90a9994:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 90a9998:	e0bffe17 	ldw	r2,-8(fp)
 90a999c:	11400117 	ldw	r5,4(r2)
 90a99a0:	e0bffe17 	ldw	r2,-8(fp)
 90a99a4:	11800317 	ldw	r6,12(r2)
 90a99a8:	e0bffe17 	ldw	r2,-8(fp)
 90a99ac:	10800317 	ldw	r2,12(r2)
 90a99b0:	e1fff584 	addi	r7,fp,-42
 90a99b4:	d8800015 	stw	r2,0(sp)
 90a99b8:	01024374 	movhi	r4,2317
 90a99bc:	213e7f04 	addi	r4,r4,-1540
 90a99c0:	90825100 	call	9082510 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 90a99c4:	01024374 	movhi	r4,2317
 90a99c8:	213e9704 	addi	r4,r4,-1444
 90a99cc:	90828380 	call	9082838 <puts>
 90a99d0:	00001e06 	br	90a9a4c <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 90a99d4:	e0bff503 	ldbu	r2,-44(fp)
 90a99d8:	10803fcc 	andi	r2,r2,255
 90a99dc:	10800a98 	cmpnei	r2,r2,42
 90a99e0:	10000c1e 	bne	r2,zero,90a9a14 <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 90a99e4:	e0bffe17 	ldw	r2,-8(fp)
 90a99e8:	11400117 	ldw	r5,4(r2)
 90a99ec:	e0bffe17 	ldw	r2,-8(fp)
 90a99f0:	11800317 	ldw	r6,12(r2)
 90a99f4:	01024374 	movhi	r4,2317
 90a99f8:	213ebf04 	addi	r4,r4,-1284
 90a99fc:	01c00504 	movi	r7,20
 90a9a00:	90825100 	call	9082510 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 90a9a04:	01024374 	movhi	r4,2317
 90a9a08:	213edc04 	addi	r4,r4,-1168
 90a9a0c:	90828380 	call	9082838 <puts>
 90a9a10:	00000e06 	br	90a9a4c <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 90a9a14:	e0bff503 	ldbu	r2,-44(fp)
 90a9a18:	10803fcc 	andi	r2,r2,255
 90a9a1c:	1005003a 	cmpeq	r2,r2,zero
 90a9a20:	10000a1e 	bne	r2,zero,90a9a4c <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 90a9a24:	e0bff503 	ldbu	r2,-44(fp)
 90a9a28:	11403fcc 	andi	r5,r2,255
 90a9a2c:	e0bffe17 	ldw	r2,-8(fp)
 90a9a30:	11800117 	ldw	r6,4(r2)
 90a9a34:	01024374 	movhi	r4,2317
 90a9a38:	213efb04 	addi	r4,r4,-1044
 90a9a3c:	90825100 	call	9082510 <printf>
             error, nettask->name);
      return (-1);
 90a9a40:	00bfffc4 	movi	r2,-1
 90a9a44:	e0bfff15 	stw	r2,-4(fp)
 90a9a48:	00001806 	br	90a9aac <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 90a9a4c:	e0bffe17 	ldw	r2,-8(fp)
 90a9a50:	10800317 	ldw	r2,12(r2)
 90a9a54:	11003fcc 	andi	r4,r2,255
 90a9a58:	e0bffe17 	ldw	r2,-8(fp)
 90a9a5c:	10800117 	ldw	r2,4(r2)
 90a9a60:	100b883a 	mov	r5,r2
 90a9a64:	e1bff504 	addi	r6,fp,-44
 90a9a68:	909443c0 	call	909443c <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 90a9a6c:	e0fff417 	ldw	r3,-48(fp)
 90a9a70:	e0bffe17 	ldw	r2,-8(fp)
 90a9a74:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 90a9a78:	e0bffe17 	ldw	r2,-8(fp)
 90a9a7c:	10c00017 	ldw	r3,0(r2)
 90a9a80:	e0bffe17 	ldw	r2,-8(fp)
 90a9a84:	10800317 	ldw	r2,12(r2)
 90a9a88:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 90a9a8c:	e0bffe17 	ldw	r2,-8(fp)
 90a9a90:	11400117 	ldw	r5,4(r2)
 90a9a94:	e0bffe17 	ldw	r2,-8(fp)
 90a9a98:	11800317 	ldw	r6,12(r2)
 90a9a9c:	01024374 	movhi	r4,2317
 90a9aa0:	213f0904 	addi	r4,r4,-988
 90a9aa4:	90825100 	call	9082510 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 90a9aa8:	e03fff15 	stw	zero,-4(fp)
 90a9aac:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9ab0:	e037883a 	mov	sp,fp
 90a9ab4:	dfc00117 	ldw	ra,4(sp)
 90a9ab8:	df000017 	ldw	fp,0(sp)
 90a9abc:	dec00204 	addi	sp,sp,8
 90a9ac0:	f800283a 	ret

090a9ac4 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 90a9ac4:	defffb04 	addi	sp,sp,-20
 90a9ac8:	dfc00415 	stw	ra,16(sp)
 90a9acc:	df000315 	stw	fp,12(sp)
 90a9ad0:	df000304 	addi	fp,sp,12
 90a9ad4:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90a9ad8:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 90a9adc:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 90a9ae0:	e0bfff17 	ldw	r2,-4(fp)
 90a9ae4:	108001a8 	cmpgeui	r2,r2,6
 90a9ae8:	10001d1e 	bne	r2,zero,90a9b60 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 90a9aec:	e0bfff17 	ldw	r2,-4(fp)
 90a9af0:	00c243b4 	movhi	r3,2318
 90a9af4:	18f55504 	addi	r3,r3,-10924
 90a9af8:	1085883a 	add	r2,r2,r2
 90a9afc:	1085883a 	add	r2,r2,r2
 90a9b00:	10c5883a 	add	r2,r2,r3
 90a9b04:	11000017 	ldw	r4,0(r2)
 90a9b08:	e1bffe04 	addi	r6,fp,-8
 90a9b0c:	000b883a 	mov	r5,zero
 90a9b10:	9092c6c0 	call	9092c6c <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 90a9b14:	e0bffe03 	ldbu	r2,-8(fp)
 90a9b18:	10803fcc 	andi	r2,r2,255
 90a9b1c:	10800298 	cmpnei	r2,r2,10
 90a9b20:	10000a1e 	bne	r2,zero,90a9b4c <wait_app_sem+0x88>
 90a9b24:	e0bffd17 	ldw	r2,-12(fp)
 90a9b28:	10800044 	addi	r2,r2,1
 90a9b2c:	e0bffd15 	stw	r2,-12(fp)
 90a9b30:	e0bffd17 	ldw	r2,-12(fp)
 90a9b34:	1080fa50 	cmplti	r2,r2,1001
 90a9b38:	1000041e 	bne	r2,zero,90a9b4c <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 90a9b3c:	01024374 	movhi	r4,2317
 90a9b40:	213e7604 	addi	r4,r4,-1576
 90a9b44:	90a438c0 	call	90a438c <panic>
            return;
 90a9b48:	00000606 	br	90a9b64 <wait_app_sem+0xa0>
         }
      } while (error == 10);
 90a9b4c:	e0bffe03 	ldbu	r2,-8(fp)
 90a9b50:	10803fcc 	andi	r2,r2,255
 90a9b54:	108002a0 	cmpeqi	r2,r2,10
 90a9b58:	103fe41e 	bne	r2,zero,90a9aec <wait_app_sem+0x28>
 90a9b5c:	00000106 	br	90a9b64 <wait_app_sem+0xa0>
   }
   else
      dtrap();
 90a9b60:	90a94880 	call	90a9488 <dtrap>
}
 90a9b64:	e037883a 	mov	sp,fp
 90a9b68:	dfc00117 	ldw	ra,4(sp)
 90a9b6c:	df000017 	ldw	fp,0(sp)
 90a9b70:	dec00204 	addi	sp,sp,8
 90a9b74:	f800283a 	ret

090a9b78 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 90a9b78:	defffc04 	addi	sp,sp,-16
 90a9b7c:	dfc00315 	stw	ra,12(sp)
 90a9b80:	df000215 	stw	fp,8(sp)
 90a9b84:	df000204 	addi	fp,sp,8
 90a9b88:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 90a9b8c:	e0bfff17 	ldw	r2,-4(fp)
 90a9b90:	108001a8 	cmpgeui	r2,r2,6
 90a9b94:	1000101e 	bne	r2,zero,90a9bd8 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 90a9b98:	e0bfff17 	ldw	r2,-4(fp)
 90a9b9c:	00c243b4 	movhi	r3,2318
 90a9ba0:	18f55504 	addi	r3,r3,-10924
 90a9ba4:	1085883a 	add	r2,r2,r2
 90a9ba8:	1085883a 	add	r2,r2,r2
 90a9bac:	10c5883a 	add	r2,r2,r3
 90a9bb0:	11000017 	ldw	r4,0(r2)
 90a9bb4:	90930640 	call	9093064 <OSSemPost>
 90a9bb8:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 90a9bbc:	e0bffe03 	ldbu	r2,-8(fp)
 90a9bc0:	1005003a 	cmpeq	r2,r2,zero
 90a9bc4:	1000051e 	bne	r2,zero,90a9bdc <post_app_sem+0x64>
      {
         panic("unlock NET");
 90a9bc8:	01024374 	movhi	r4,2317
 90a9bcc:	213e7904 	addi	r4,r4,-1564
 90a9bd0:	90a438c0 	call	90a438c <panic>
 90a9bd4:	00000106 	br	90a9bdc <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 90a9bd8:	90a94880 	call	90a9488 <dtrap>
}
 90a9bdc:	e037883a 	mov	sp,fp
 90a9be0:	dfc00117 	ldw	ra,4(sp)
 90a9be4:	df000017 	ldw	fp,0(sp)
 90a9be8:	dec00204 	addi	sp,sp,8
 90a9bec:	f800283a 	ret

090a9bf0 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 90a9bf0:	defffc04 	addi	sp,sp,-16
 90a9bf4:	dfc00315 	stw	ra,12(sp)
 90a9bf8:	df000215 	stw	fp,8(sp)
 90a9bfc:	dc000115 	stw	r16,4(sp)
 90a9c00:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 90a9c04:	01000044 	movi	r4,1
 90a9c08:	90928b80 	call	90928b8 <OSSemCreate>
 90a9c0c:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 90a9c10:	d0a0aa17 	ldw	r2,-32088(gp)
 90a9c14:	1004c03a 	cmpne	r2,r2,zero
 90a9c18:	1000031e 	bne	r2,zero,90a9c28 <alt_iniche_init+0x38>
      panic("mheap_sem_ptr create err"); 
 90a9c1c:	01024374 	movhi	r4,2317
 90a9c20:	213f1104 	addi	r4,r4,-956
 90a9c24:	90a438c0 	call	90a438c <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 90a9c28:	0009883a 	mov	r4,zero
 90a9c2c:	90928b80 	call	90928b8 <OSSemCreate>
 90a9c30:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 90a9c34:	d0a0ab17 	ldw	r2,-32084(gp)
 90a9c38:	1004c03a 	cmpne	r2,r2,zero
 90a9c3c:	1000031e 	bne	r2,zero,90a9c4c <alt_iniche_init+0x5c>
      panic("rcvdq_sem_ptr create err"); 
 90a9c40:	01024374 	movhi	r4,2317
 90a9c44:	213f1804 	addi	r4,r4,-928
 90a9c48:	90a438c0 	call	90a438c <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 90a9c4c:	e03fff15 	stw	zero,-4(fp)
 90a9c50:	00001906 	br	90a9cb8 <alt_iniche_init+0xc8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 90a9c54:	e43fff17 	ldw	r16,-4(fp)
 90a9c58:	01000044 	movi	r4,1
 90a9c5c:	90928b80 	call	90928b8 <OSSemCreate>
 90a9c60:	1009883a 	mov	r4,r2
 90a9c64:	00c243b4 	movhi	r3,2318
 90a9c68:	18f54504 	addi	r3,r3,-10988
 90a9c6c:	8405883a 	add	r2,r16,r16
 90a9c70:	1085883a 	add	r2,r2,r2
 90a9c74:	10c5883a 	add	r2,r2,r3
 90a9c78:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 90a9c7c:	e0bfff17 	ldw	r2,-4(fp)
 90a9c80:	00c243b4 	movhi	r3,2318
 90a9c84:	18f54504 	addi	r3,r3,-10988
 90a9c88:	1085883a 	add	r2,r2,r2
 90a9c8c:	1085883a 	add	r2,r2,r2
 90a9c90:	10c5883a 	add	r2,r2,r3
 90a9c94:	10800017 	ldw	r2,0(r2)
 90a9c98:	1004c03a 	cmpne	r2,r2,zero
 90a9c9c:	1000031e 	bne	r2,zero,90a9cac <alt_iniche_init+0xbc>
         panic("resid_semaphore create err");  
 90a9ca0:	01024374 	movhi	r4,2317
 90a9ca4:	213f1f04 	addi	r4,r4,-900
 90a9ca8:	90a438c0 	call	90a438c <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 90a9cac:	e0bfff17 	ldw	r2,-4(fp)
 90a9cb0:	10800044 	addi	r2,r2,1
 90a9cb4:	e0bfff15 	stw	r2,-4(fp)
 90a9cb8:	e0bfff17 	ldw	r2,-4(fp)
 90a9cbc:	10800410 	cmplti	r2,r2,16
 90a9cc0:	103fe41e 	bne	r2,zero,90a9c54 <alt_iniche_init+0x64>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 90a9cc4:	e03fff15 	stw	zero,-4(fp)
 90a9cc8:	00001906 	br	90a9d30 <alt_iniche_init+0x140>
   {
      app_semaphore[i] = OSSemCreate(1);
 90a9ccc:	e43fff17 	ldw	r16,-4(fp)
 90a9cd0:	01000044 	movi	r4,1
 90a9cd4:	90928b80 	call	90928b8 <OSSemCreate>
 90a9cd8:	1009883a 	mov	r4,r2
 90a9cdc:	00c243b4 	movhi	r3,2318
 90a9ce0:	18f55504 	addi	r3,r3,-10924
 90a9ce4:	8405883a 	add	r2,r16,r16
 90a9ce8:	1085883a 	add	r2,r2,r2
 90a9cec:	10c5883a 	add	r2,r2,r3
 90a9cf0:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 90a9cf4:	e0bfff17 	ldw	r2,-4(fp)
 90a9cf8:	00c243b4 	movhi	r3,2318
 90a9cfc:	18f55504 	addi	r3,r3,-10924
 90a9d00:	1085883a 	add	r2,r2,r2
 90a9d04:	1085883a 	add	r2,r2,r2
 90a9d08:	10c5883a 	add	r2,r2,r3
 90a9d0c:	10800017 	ldw	r2,0(r2)
 90a9d10:	1004c03a 	cmpne	r2,r2,zero
 90a9d14:	1000031e 	bne	r2,zero,90a9d24 <alt_iniche_init+0x134>
         panic("app_semaphore create err");  
 90a9d18:	01024374 	movhi	r4,2317
 90a9d1c:	213f2604 	addi	r4,r4,-872
 90a9d20:	90a438c0 	call	90a438c <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 90a9d24:	e0bfff17 	ldw	r2,-4(fp)
 90a9d28:	10800044 	addi	r2,r2,1
 90a9d2c:	e0bfff15 	stw	r2,-4(fp)
 90a9d30:	e0bfff17 	ldw	r2,-4(fp)
 90a9d34:	10800190 	cmplti	r2,r2,6
 90a9d38:	103fe41e 	bne	r2,zero,90a9ccc <alt_iniche_init+0xdc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a9d3c:	e03fff15 	stw	zero,-4(fp)
 90a9d40:	00002606 	br	90a9ddc <alt_iniche_init+0x1ec>
   {
      global_TCPwakeup_set[i].ctick = 0;
 90a9d44:	e0bfff17 	ldw	r2,-4(fp)
 90a9d48:	00c243b4 	movhi	r3,2318
 90a9d4c:	18f50904 	addi	r3,r3,-11228
 90a9d50:	10800324 	muli	r2,r2,12
 90a9d54:	10c5883a 	add	r2,r2,r3
 90a9d58:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 90a9d5c:	e0bfff17 	ldw	r2,-4(fp)
 90a9d60:	00c243b4 	movhi	r3,2318
 90a9d64:	18f50904 	addi	r3,r3,-11228
 90a9d68:	10800324 	muli	r2,r2,12
 90a9d6c:	10c5883a 	add	r2,r2,r3
 90a9d70:	10800104 	addi	r2,r2,4
 90a9d74:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 90a9d78:	e43fff17 	ldw	r16,-4(fp)
 90a9d7c:	0009883a 	mov	r4,zero
 90a9d80:	90928b80 	call	90928b8 <OSSemCreate>
 90a9d84:	1009883a 	mov	r4,r2
 90a9d88:	00c243b4 	movhi	r3,2318
 90a9d8c:	18f50904 	addi	r3,r3,-11228
 90a9d90:	80800324 	muli	r2,r16,12
 90a9d94:	10c5883a 	add	r2,r2,r3
 90a9d98:	10800204 	addi	r2,r2,8
 90a9d9c:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 90a9da0:	e0bfff17 	ldw	r2,-4(fp)
 90a9da4:	00c243b4 	movhi	r3,2318
 90a9da8:	18f50904 	addi	r3,r3,-11228
 90a9dac:	10800324 	muli	r2,r2,12
 90a9db0:	10c5883a 	add	r2,r2,r3
 90a9db4:	10800204 	addi	r2,r2,8
 90a9db8:	10800017 	ldw	r2,0(r2)
 90a9dbc:	1004c03a 	cmpne	r2,r2,zero
 90a9dc0:	1000031e 	bne	r2,zero,90a9dd0 <alt_iniche_init+0x1e0>
         panic("globwake_semaphore create err");  
 90a9dc4:	01024374 	movhi	r4,2317
 90a9dc8:	213f2d04 	addi	r4,r4,-844
 90a9dcc:	90a438c0 	call	90a438c <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a9dd0:	e0bfff17 	ldw	r2,-4(fp)
 90a9dd4:	10800044 	addi	r2,r2,1
 90a9dd8:	e0bfff15 	stw	r2,-4(fp)
 90a9ddc:	e0bfff17 	ldw	r2,-4(fp)
 90a9de0:	10800510 	cmplti	r2,r2,20
 90a9de4:	103fd71e 	bne	r2,zero,90a9d44 <alt_iniche_init+0x154>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 90a9de8:	00824374 	movhi	r2,2317
 90a9dec:	108c4104 	addi	r2,r2,12548
 90a9df0:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 90a9df4:	e037883a 	mov	sp,fp
 90a9df8:	dfc00217 	ldw	ra,8(sp)
 90a9dfc:	df000117 	ldw	fp,4(sp)
 90a9e00:	dc000017 	ldw	r16,0(sp)
 90a9e04:	dec00304 	addi	sp,sp,12
 90a9e08:	f800283a 	ret

090a9e0c <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 90a9e0c:	deffff04 	addi	sp,sp,-4
 90a9e10:	df000015 	stw	fp,0(sp)
 90a9e14:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 90a9e18:	00c24374 	movhi	r3,2317
 90a9e1c:	18cbd004 	addi	r3,r3,12096
 90a9e20:	00800784 	movi	r2,30
 90a9e24:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 90a9e28:	00c24374 	movhi	r3,2317
 90a9e2c:	18cbce04 	addi	r3,r3,12088
 90a9e30:	00800784 	movi	r2,30
 90a9e34:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 90a9e38:	00c24374 	movhi	r3,2317
 90a9e3c:	18cbd104 	addi	r3,r3,12100
 90a9e40:	00818004 	movi	r2,1536
 90a9e44:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 90a9e48:	00c24374 	movhi	r3,2317
 90a9e4c:	18cbcf04 	addi	r3,r3,12092
 90a9e50:	00802004 	movi	r2,128
 90a9e54:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 90a9e58:	00c24374 	movhi	r3,2317
 90a9e5c:	18cc6404 	addi	r3,r3,12688
 90a9e60:	008242f4 	movhi	r2,2315
 90a9e64:	10a7a804 	addi	r2,r2,-24928
 90a9e68:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 90a9e6c:	0005883a 	mov	r2,zero
}
 90a9e70:	e037883a 	mov	sp,fp
 90a9e74:	df000017 	ldw	fp,0(sp)
 90a9e78:	dec00104 	addi	sp,sp,4
 90a9e7c:	f800283a 	ret

090a9e80 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 90a9e80:	deffff04 	addi	sp,sp,-4
 90a9e84:	df000015 	stw	fp,0(sp)
 90a9e88:	d839883a 	mov	fp,sp
   return NULL;
 90a9e8c:	0005883a 	mov	r2,zero
}
 90a9e90:	e037883a 	mov	sp,fp
 90a9e94:	df000017 	ldw	fp,0(sp)
 90a9e98:	dec00104 	addi	sp,sp,4
 90a9e9c:	f800283a 	ret

090a9ea0 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 90a9ea0:	defffd04 	addi	sp,sp,-12
 90a9ea4:	dfc00215 	stw	ra,8(sp)
 90a9ea8:	df000115 	stw	fp,4(sp)
 90a9eac:	df000104 	addi	fp,sp,4
 90a9eb0:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 90a9eb4:	e13fff17 	ldw	r4,-4(fp)
 90a9eb8:	90a0bf00 	call	90a0bf0 <iniche_devices_init>
 90a9ebc:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 90a9ec0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9ec4:	e037883a 	mov	sp,fp
 90a9ec8:	dfc00117 	ldw	ra,4(sp)
 90a9ecc:	df000017 	ldw	fp,0(sp)
 90a9ed0:	dec00204 	addi	sp,sp,8
 90a9ed4:	f800283a 	ret

090a9ed8 <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 90a9ed8:	defffd04 	addi	sp,sp,-12
 90a9edc:	dfc00215 	stw	ra,8(sp)
 90a9ee0:	df000115 	stw	fp,4(sp)
 90a9ee4:	df000104 	addi	fp,sp,4
 90a9ee8:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 90a9eec:	01000044 	movi	r4,1
 90a9ef0:	e17fff17 	ldw	r5,-4(fp)
 90a9ef4:	90ca4c40 	call	90ca4c4 <calloc>
}
 90a9ef8:	e037883a 	mov	sp,fp
 90a9efc:	dfc00117 	ldw	ra,4(sp)
 90a9f00:	df000017 	ldw	fp,0(sp)
 90a9f04:	dec00204 	addi	sp,sp,8
 90a9f08:	f800283a 	ret

090a9f0c <npalloc>:


char *
npalloc(unsigned size)
{
 90a9f0c:	defff904 	addi	sp,sp,-28
 90a9f10:	dfc00615 	stw	ra,24(sp)
 90a9f14:	df000515 	stw	fp,20(sp)
 90a9f18:	df000504 	addi	fp,sp,20
 90a9f1c:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 90a9f20:	d120aa17 	ldw	r4,-32088(gp)
 90a9f24:	e1bffd04 	addi	r6,fp,-12
 90a9f28:	000b883a 	mov	r5,zero
 90a9f2c:	9092c6c0 	call	9092c6c <OSSemPend>
   if(err)
 90a9f30:	e0bffd03 	ldbu	r2,-12(fp)
 90a9f34:	10803fcc 	andi	r2,r2,255
 90a9f38:	1005003a 	cmpeq	r2,r2,zero
 90a9f3c:	1000181e 	bne	r2,zero,90a9fa0 <npalloc+0x94>
   {
      int errct = 0;
 90a9f40:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 90a9f44:	00001206 	br	90a9f90 <npalloc+0x84>
      {
         if(errct++ > 1000)
 90a9f48:	e0bffb17 	ldw	r2,-20(fp)
 90a9f4c:	1080fa48 	cmpgei	r2,r2,1001
 90a9f50:	1007883a 	mov	r3,r2
 90a9f54:	e0bffb17 	ldw	r2,-20(fp)
 90a9f58:	10800044 	addi	r2,r2,1
 90a9f5c:	e0bffb15 	stw	r2,-20(fp)
 90a9f60:	18803fcc 	andi	r2,r3,255
 90a9f64:	1005003a 	cmpeq	r2,r2,zero
 90a9f68:	1000051e 	bne	r2,zero,90a9f80 <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 90a9f6c:	01024374 	movhi	r4,2317
 90a9f70:	213f3504 	addi	r4,r4,-812
 90a9f74:	90a438c0 	call	90a438c <panic>
            return NULL;
 90a9f78:	e03fff15 	stw	zero,-4(fp)
 90a9f7c:	00001a06 	br	90a9fe8 <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 90a9f80:	d120aa17 	ldw	r4,-32088(gp)
 90a9f84:	e1bffd04 	addi	r6,fp,-12
 90a9f88:	000b883a 	mov	r5,zero
 90a9f8c:	9092c6c0 	call	9092c6c <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 90a9f90:	e0bffd03 	ldbu	r2,-12(fp)
 90a9f94:	10803fcc 	andi	r2,r2,255
 90a9f98:	108002a0 	cmpeqi	r2,r2,10
 90a9f9c:	103fea1e 	bne	r2,zero,90a9f48 <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 90a9fa0:	e13ffe17 	ldw	r4,-8(fp)
 90a9fa4:	90a9ed80 	call	90a9ed8 <calloc2>
 90a9fa8:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 90a9fac:	d120aa17 	ldw	r4,-32088(gp)
 90a9fb0:	90930640 	call	9093064 <OSSemPost>
 90a9fb4:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 90a9fb8:	e0bffc17 	ldw	r2,-16(fp)
 90a9fbc:	1004c03a 	cmpne	r2,r2,zero
 90a9fc0:	1000021e 	bne	r2,zero,90a9fcc <npalloc+0xc0>
      return NULL;
 90a9fc4:	e03fff15 	stw	zero,-4(fp)
 90a9fc8:	00000706 	br	90a9fe8 <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 90a9fcc:	e0bffc17 	ldw	r2,-16(fp)
 90a9fd0:	1009883a 	mov	r4,r2
 90a9fd4:	e1bffe17 	ldw	r6,-8(fp)
 90a9fd8:	000b883a 	mov	r5,zero
 90a9fdc:	90823f80 	call	90823f8 <memset>
   return ptr;      
 90a9fe0:	e0bffc17 	ldw	r2,-16(fp)
 90a9fe4:	e0bfff15 	stw	r2,-4(fp)
 90a9fe8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9fec:	e037883a 	mov	sp,fp
 90a9ff0:	dfc00117 	ldw	ra,4(sp)
 90a9ff4:	df000017 	ldw	fp,0(sp)
 90a9ff8:	dec00204 	addi	sp,sp,8
 90a9ffc:	f800283a 	ret

090aa000 <npfree>:

void
npfree(void * ptr)
{
 90aa000:	defffb04 	addi	sp,sp,-20
 90aa004:	dfc00415 	stw	ra,16(sp)
 90aa008:	df000315 	stw	fp,12(sp)
 90aa00c:	df000304 	addi	fp,sp,12
 90aa010:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 90aa014:	d120aa17 	ldw	r4,-32088(gp)
 90aa018:	e1bffe04 	addi	r6,fp,-8
 90aa01c:	000b883a 	mov	r5,zero
 90aa020:	9092c6c0 	call	9092c6c <OSSemPend>
   if (err)
 90aa024:	e0bffe03 	ldbu	r2,-8(fp)
 90aa028:	10803fcc 	andi	r2,r2,255
 90aa02c:	1005003a 	cmpeq	r2,r2,zero
 90aa030:	1000171e 	bne	r2,zero,90aa090 <npfree+0x90>
   {
      int errct = 0;
 90aa034:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 90aa038:	00001106 	br	90aa080 <npfree+0x80>
      {
         if (errct++ > 1000)
 90aa03c:	e0bffd17 	ldw	r2,-12(fp)
 90aa040:	1080fa48 	cmpgei	r2,r2,1001
 90aa044:	1007883a 	mov	r3,r2
 90aa048:	e0bffd17 	ldw	r2,-12(fp)
 90aa04c:	10800044 	addi	r2,r2,1
 90aa050:	e0bffd15 	stw	r2,-12(fp)
 90aa054:	18803fcc 	andi	r2,r3,255
 90aa058:	1005003a 	cmpeq	r2,r2,zero
 90aa05c:	1000041e 	bne	r2,zero,90aa070 <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 90aa060:	01024374 	movhi	r4,2317
 90aa064:	213f3704 	addi	r4,r4,-804
 90aa068:	90a438c0 	call	90a438c <panic>
            return;
 90aa06c:	00000d06 	br	90aa0a4 <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 90aa070:	d120aa17 	ldw	r4,-32088(gp)
 90aa074:	e1bffe04 	addi	r6,fp,-8
 90aa078:	000b883a 	mov	r5,zero
 90aa07c:	9092c6c0 	call	9092c6c <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 90aa080:	e0bffe03 	ldbu	r2,-8(fp)
 90aa084:	10803fcc 	andi	r2,r2,255
 90aa088:	108002a0 	cmpeqi	r2,r2,10
 90aa08c:	103feb1e 	bne	r2,zero,90aa03c <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 90aa090:	e13fff17 	ldw	r4,-4(fp)
 90aa094:	90ca5180 	call	90ca518 <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 90aa098:	d120aa17 	ldw	r4,-32088(gp)
 90aa09c:	90930640 	call	9093064 <OSSemPost>
 90aa0a0:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 90aa0a4:	e037883a 	mov	sp,fp
 90aa0a8:	dfc00117 	ldw	ra,4(sp)
 90aa0ac:	df000017 	ldw	fp,0(sp)
 90aa0b0:	dec00204 	addi	sp,sp,8
 90aa0b4:	f800283a 	ret

090aa0b8 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 90aa0b8:	defffc04 	addi	sp,sp,-16
 90aa0bc:	dfc00315 	stw	ra,12(sp)
 90aa0c0:	df000215 	stw	fp,8(sp)
 90aa0c4:	df000204 	addi	fp,sp,8
 90aa0c8:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 90aa0cc:	e13fff17 	ldw	r4,-4(fp)
 90aa0d0:	90a9f0c0 	call	90a9f0c <npalloc>
 90aa0d4:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 90aa0d8:	e0bffe17 	ldw	r2,-8(fp)
 90aa0dc:	1005003a 	cmpeq	r2,r2,zero
 90aa0e0:	1000041e 	bne	r2,zero,90aa0f4 <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 90aa0e4:	e13ffe17 	ldw	r4,-8(fp)
 90aa0e8:	e17fff17 	ldw	r5,-4(fp)
 90aa0ec:	90b99140 	call	90b9914 <alt_remap_uncached>
 90aa0f0:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 90aa0f4:	e0bffe17 	ldw	r2,-8(fp)
}
 90aa0f8:	e037883a 	mov	sp,fp
 90aa0fc:	dfc00117 	ldw	ra,4(sp)
 90aa100:	df000017 	ldw	fp,0(sp)
 90aa104:	dec00204 	addi	sp,sp,8
 90aa108:	f800283a 	ret

090aa10c <ncpfree>:

void ncpfree(void *ptr)
{
 90aa10c:	defffd04 	addi	sp,sp,-12
 90aa110:	dfc00215 	stw	ra,8(sp)
 90aa114:	df000115 	stw	fp,4(sp)
 90aa118:	df000104 	addi	fp,sp,4
 90aa11c:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 90aa120:	e0bfff17 	ldw	r2,-4(fp)
 90aa124:	1005003a 	cmpeq	r2,r2,zero
 90aa128:	1000061e 	bne	r2,zero,90aa144 <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 90aa12c:	e13fff17 	ldw	r4,-4(fp)
 90aa130:	01400104 	movi	r5,4
 90aa134:	90b98dc0 	call	90b98dc <alt_remap_cached>
 90aa138:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 90aa13c:	e13fff17 	ldw	r4,-4(fp)
 90aa140:	90aa0000 	call	90aa000 <npfree>
   }
}
 90aa144:	e037883a 	mov	sp,fp
 90aa148:	dfc00117 	ldw	ra,4(sp)
 90aa14c:	df000017 	ldw	fp,0(sp)
 90aa150:	dec00204 	addi	sp,sp,8
 90aa154:	f800283a 	ret

090aa158 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 90aa158:	defffb04 	addi	sp,sp,-20
 90aa15c:	dfc00415 	stw	ra,16(sp)
 90aa160:	df000315 	stw	fp,12(sp)
 90aa164:	df000304 	addi	fp,sp,12
 90aa168:	e13ffd15 	stw	r4,-12(fp)
 90aa16c:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 90aa170:	e0bffd17 	ldw	r2,-12(fp)
 90aa174:	108000a0 	cmpeqi	r2,r2,2
 90aa178:	1000031e 	bne	r2,zero,90aa188 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 90aa17c:	90a94880 	call	90a9488 <dtrap>
         return NULL;
 90aa180:	e03fff15 	stw	zero,-4(fp)
 90aa184:	00001606 	br	90aa1e0 <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 90aa188:	e0bffe17 	ldw	r2,-8(fp)
 90aa18c:	10800058 	cmpnei	r2,r2,1
 90aa190:	1000041e 	bne	r2,zero,90aa1a4 <pffindtype+0x4c>
      return &tcp_protosw;
 90aa194:	00824374 	movhi	r2,2317
 90aa198:	108ab404 	addi	r2,r2,10960
 90aa19c:	e0bfff15 	stw	r2,-4(fp)
 90aa1a0:	00000f06 	br	90aa1e0 <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 90aa1a4:	e0bffe17 	ldw	r2,-8(fp)
 90aa1a8:	10800098 	cmpnei	r2,r2,2
 90aa1ac:	1000041e 	bne	r2,zero,90aa1c0 <pffindtype+0x68>
      return &udp_protosw;
 90aa1b0:	00824374 	movhi	r2,2317
 90aa1b4:	108aba04 	addi	r2,r2,10984
 90aa1b8:	e0bfff15 	stw	r2,-4(fp)
 90aa1bc:	00000806 	br	90aa1e0 <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 90aa1c0:	e0bffe17 	ldw	r2,-8(fp)
 90aa1c4:	108000d8 	cmpnei	r2,r2,3
 90aa1c8:	1000041e 	bne	r2,zero,90aa1dc <pffindtype+0x84>
      return &rawip_protosw;
 90aa1cc:	00824374 	movhi	r2,2317
 90aa1d0:	108ac004 	addi	r2,r2,11008
 90aa1d4:	e0bfff15 	stw	r2,-4(fp)
 90aa1d8:	00000106 	br	90aa1e0 <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 90aa1dc:	e03fff15 	stw	zero,-4(fp)
 90aa1e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa1e4:	e037883a 	mov	sp,fp
 90aa1e8:	dfc00117 	ldw	ra,4(sp)
 90aa1ec:	df000017 	ldw	fp,0(sp)
 90aa1f0:	dec00204 	addi	sp,sp,8
 90aa1f4:	f800283a 	ret

090aa1f8 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 90aa1f8:	defff904 	addi	sp,sp,-28
 90aa1fc:	dfc00615 	stw	ra,24(sp)
 90aa200:	df000515 	stw	fp,20(sp)
 90aa204:	df000504 	addi	fp,sp,20
 90aa208:	e13ffb15 	stw	r4,-20(fp)
 90aa20c:	e17ffc15 	stw	r5,-16(fp)
 90aa210:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 90aa214:	e0bffd17 	ldw	r2,-12(fp)
 90aa218:	108000d8 	cmpnei	r2,r2,3
 90aa21c:	1000051e 	bne	r2,zero,90aa234 <pffindproto+0x3c>
      return(pffindtype(domain, type));
 90aa220:	e13ffb17 	ldw	r4,-20(fp)
 90aa224:	e17ffd17 	ldw	r5,-12(fp)
 90aa228:	90aa1580 	call	90aa158 <pffindtype>
 90aa22c:	e0bffe15 	stw	r2,-8(fp)
 90aa230:	00001f06 	br	90aa2b0 <pffindproto+0xb8>
#endif

   switch (protocol)
 90aa234:	e0bffc17 	ldw	r2,-16(fp)
 90aa238:	e0bfff15 	stw	r2,-4(fp)
 90aa23c:	e0ffff17 	ldw	r3,-4(fp)
 90aa240:	188001a0 	cmpeqi	r2,r3,6
 90aa244:	1000071e 	bne	r2,zero,90aa264 <pffindproto+0x6c>
 90aa248:	e0ffff17 	ldw	r3,-4(fp)
 90aa24c:	18800460 	cmpeqi	r2,r3,17
 90aa250:	10000a1e 	bne	r2,zero,90aa27c <pffindproto+0x84>
 90aa254:	e0ffff17 	ldw	r3,-4(fp)
 90aa258:	1805003a 	cmpeq	r2,r3,zero
 90aa25c:	1000101e 	bne	r2,zero,90aa2a0 <pffindproto+0xa8>
 90aa260:	00000c06 	br	90aa294 <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 90aa264:	e0bffd17 	ldw	r2,-12(fp)
 90aa268:	10800060 	cmpeqi	r2,r2,1
 90aa26c:	10000c1e 	bne	r2,zero,90aa2a0 <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 90aa270:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90aa274:	e03ffe15 	stw	zero,-8(fp)
 90aa278:	00000d06 	br	90aa2b0 <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 90aa27c:	e0bffd17 	ldw	r2,-12(fp)
 90aa280:	108000a0 	cmpeqi	r2,r2,2
 90aa284:	1000061e 	bne	r2,zero,90aa2a0 <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 90aa288:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90aa28c:	e03ffe15 	stw	zero,-8(fp)
 90aa290:	00000706 	br	90aa2b0 <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 90aa294:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90aa298:	e03ffe15 	stw	zero,-8(fp)
 90aa29c:	00000406 	br	90aa2b0 <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 90aa2a0:	e13ffb17 	ldw	r4,-20(fp)
 90aa2a4:	e17ffd17 	ldw	r5,-12(fp)
 90aa2a8:	90aa1580 	call	90aa158 <pffindtype>
 90aa2ac:	e0bffe15 	stw	r2,-8(fp)
 90aa2b0:	e0bffe17 	ldw	r2,-8(fp)
}
 90aa2b4:	e037883a 	mov	sp,fp
 90aa2b8:	dfc00117 	ldw	ra,4(sp)
 90aa2bc:	df000017 	ldw	fp,0(sp)
 90aa2c0:	dec00204 	addi	sp,sp,8
 90aa2c4:	f800283a 	ret

090aa2c8 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 90aa2c8:	defff904 	addi	sp,sp,-28
 90aa2cc:	dfc00615 	stw	ra,24(sp)
 90aa2d0:	df000515 	stw	fp,20(sp)
 90aa2d4:	df000504 	addi	fp,sp,20
 90aa2d8:	e13ffd15 	stw	r4,-12(fp)
 90aa2dc:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 90aa2e0:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 90aa2e4:	e0bffd17 	ldw	r2,-12(fp)
 90aa2e8:	10800050 	cmplti	r2,r2,1
 90aa2ec:	1000031e 	bne	r2,zero,90aa2fc <m_getnbuf+0x34>
 90aa2f0:	e0bffd17 	ldw	r2,-12(fp)
 90aa2f4:	10800390 	cmplti	r2,r2,14
 90aa2f8:	1000011e 	bne	r2,zero,90aa300 <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 90aa2fc:	90a94880 	call	90a9488 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 90aa300:	e0bffe17 	ldw	r2,-8(fp)
 90aa304:	1005003a 	cmpeq	r2,r2,zero
 90aa308:	10000e1e 	bne	r2,zero,90aa344 <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90aa30c:	01000084 	movi	r4,2
 90aa310:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 90aa314:	e0bffe17 	ldw	r2,-8(fp)
 90aa318:	10800e04 	addi	r2,r2,56
 90aa31c:	1009883a 	mov	r4,r2
 90aa320:	90a88440 	call	90a8844 <pk_alloc>
 90aa324:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aa328:	01000084 	movi	r4,2
 90aa32c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 90aa330:	e0bffb17 	ldw	r2,-20(fp)
 90aa334:	1004c03a 	cmpne	r2,r2,zero
 90aa338:	1000021e 	bne	r2,zero,90aa344 <m_getnbuf+0x7c>
         return NULL;
 90aa33c:	e03fff15 	stw	zero,-4(fp)
 90aa340:	00004506 	br	90aa458 <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 90aa344:	010243b4 	movhi	r4,2318
 90aa348:	21357404 	addi	r4,r4,-10800
 90aa34c:	90a8d500 	call	90a8d50 <getq>
 90aa350:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 90aa354:	e0bffc17 	ldw	r2,-16(fp)
 90aa358:	1004c03a 	cmpne	r2,r2,zero
 90aa35c:	10000b1e 	bne	r2,zero,90aa38c <m_getnbuf+0xc4>
   {
      if (pkt) 
 90aa360:	e0bffb17 	ldw	r2,-20(fp)
 90aa364:	1005003a 	cmpeq	r2,r2,zero
 90aa368:	1000061e 	bne	r2,zero,90aa384 <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90aa36c:	01000084 	movi	r4,2
 90aa370:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90aa374:	e13ffb17 	ldw	r4,-20(fp)
 90aa378:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aa37c:	01000084 	movi	r4,2
 90aa380:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 90aa384:	e03fff15 	stw	zero,-4(fp)
 90aa388:	00003306 	br	90aa458 <m_getnbuf+0x190>
   }
   m->m_type = type;
 90aa38c:	e0fffc17 	ldw	r3,-16(fp)
 90aa390:	e0bffd17 	ldw	r2,-12(fp)
 90aa394:	18800815 	stw	r2,32(r3)
   if (len == 0)
 90aa398:	e0bffe17 	ldw	r2,-8(fp)
 90aa39c:	1004c03a 	cmpne	r2,r2,zero
 90aa3a0:	1000071e 	bne	r2,zero,90aa3c0 <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 90aa3a4:	e0bffc17 	ldw	r2,-16(fp)
 90aa3a8:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 90aa3ac:	e0bffc17 	ldw	r2,-16(fp)
 90aa3b0:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 90aa3b4:	e0bffc17 	ldw	r2,-16(fp)
 90aa3b8:	10000515 	stw	zero,20(r2)
 90aa3bc:	00001506 	br	90aa414 <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 90aa3c0:	e0fffc17 	ldw	r3,-16(fp)
 90aa3c4:	e0bffb17 	ldw	r2,-20(fp)
 90aa3c8:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 90aa3cc:	e0bffb17 	ldw	r2,-20(fp)
 90aa3d0:	10800117 	ldw	r2,4(r2)
 90aa3d4:	10c00e04 	addi	r3,r2,56
 90aa3d8:	e0bffb17 	ldw	r2,-20(fp)
 90aa3dc:	10c00315 	stw	r3,12(r2)
 90aa3e0:	e0bffb17 	ldw	r2,-20(fp)
 90aa3e4:	10c00317 	ldw	r3,12(r2)
 90aa3e8:	e0bffc17 	ldw	r2,-16(fp)
 90aa3ec:	10c00315 	stw	r3,12(r2)
 90aa3f0:	e0bffc17 	ldw	r2,-16(fp)
 90aa3f4:	10c00317 	ldw	r3,12(r2)
 90aa3f8:	e0bffc17 	ldw	r2,-16(fp)
 90aa3fc:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 90aa400:	e0bffb17 	ldw	r2,-20(fp)
 90aa404:	10800217 	ldw	r2,8(r2)
 90aa408:	10fff204 	addi	r3,r2,-56
 90aa40c:	e0bffc17 	ldw	r2,-16(fp)
 90aa410:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 90aa414:	e0bffc17 	ldw	r2,-16(fp)
 90aa418:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 90aa41c:	e0bffc17 	ldw	r2,-16(fp)
 90aa420:	10000715 	stw	zero,28(r2)
 90aa424:	e0bffc17 	ldw	r2,-16(fp)
 90aa428:	10c00717 	ldw	r3,28(r2)
 90aa42c:	e0bffc17 	ldw	r2,-16(fp)
 90aa430:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 90aa434:	d0a0ae17 	ldw	r2,-32072(gp)
 90aa438:	10800044 	addi	r2,r2,1
 90aa43c:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 90aa440:	e17ffc17 	ldw	r5,-16(fp)
 90aa444:	010243b4 	movhi	r4,2318
 90aa448:	21356f04 	addi	r4,r4,-10820
 90aa44c:	90a8e180 	call	90a8e18 <putq>
   return m;
 90aa450:	e0bffc17 	ldw	r2,-16(fp)
 90aa454:	e0bfff15 	stw	r2,-4(fp)
 90aa458:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa45c:	e037883a 	mov	sp,fp
 90aa460:	dfc00117 	ldw	ra,4(sp)
 90aa464:	df000017 	ldw	fp,0(sp)
 90aa468:	dec00204 	addi	sp,sp,8
 90aa46c:	f800283a 	ret

090aa470 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 90aa470:	defffb04 	addi	sp,sp,-20
 90aa474:	dfc00415 	stw	ra,16(sp)
 90aa478:	df000315 	stw	fp,12(sp)
 90aa47c:	df000304 	addi	fp,sp,12
 90aa480:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 90aa484:	008243b4 	movhi	r2,2318
 90aa488:	10b56f04 	addi	r2,r2,-10820
 90aa48c:	10800217 	ldw	r2,8(r2)
 90aa490:	10800048 	cmpgei	r2,r2,1
 90aa494:	1000031e 	bne	r2,zero,90aa4a4 <m_free+0x34>
      panic("mfree: q_len");
 90aa498:	01024374 	movhi	r4,2317
 90aa49c:	213f3904 	addi	r4,r4,-796
 90aa4a0:	90a438c0 	call	90a438c <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 90aa4a4:	e0bffe17 	ldw	r2,-8(fp)
 90aa4a8:	10800817 	ldw	r2,32(r2)
 90aa4ac:	10800050 	cmplti	r2,r2,1
 90aa4b0:	1000041e 	bne	r2,zero,90aa4c4 <m_free+0x54>
 90aa4b4:	e0bffe17 	ldw	r2,-8(fp)
 90aa4b8:	10800817 	ldw	r2,32(r2)
 90aa4bc:	10800390 	cmplti	r2,r2,14
 90aa4c0:	10000c1e 	bne	r2,zero,90aa4f4 <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 90aa4c4:	e0bffe17 	ldw	r2,-8(fp)
 90aa4c8:	10800817 	ldw	r2,32(r2)
 90aa4cc:	1004c03a 	cmpne	r2,r2,zero
 90aa4d0:	1000051e 	bne	r2,zero,90aa4e8 <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 90aa4d4:	90a94880 	call	90a9488 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 90aa4d8:	e0bffe17 	ldw	r2,-8(fp)
 90aa4dc:	10800617 	ldw	r2,24(r2)
 90aa4e0:	e0bfff15 	stw	r2,-4(fp)
 90aa4e4:	00002906 	br	90aa58c <m_free+0x11c>
      }
      else
         panic("m_free: type");
 90aa4e8:	01024374 	movhi	r4,2317
 90aa4ec:	213f3d04 	addi	r4,r4,-780
 90aa4f0:	90a438c0 	call	90a438c <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 90aa4f4:	e0bffe17 	ldw	r2,-8(fp)
 90aa4f8:	10800617 	ldw	r2,24(r2)
 90aa4fc:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 90aa500:	010243b4 	movhi	r4,2318
 90aa504:	21356f04 	addi	r4,r4,-10820
 90aa508:	e17ffe17 	ldw	r5,-8(fp)
 90aa50c:	90a8ec80 	call	90a8ec8 <qdel>
 90aa510:	1004c03a 	cmpne	r2,r2,zero
 90aa514:	1000031e 	bne	r2,zero,90aa524 <m_free+0xb4>
      panic("m_free: missing");
 90aa518:	01024374 	movhi	r4,2317
 90aa51c:	213f4104 	addi	r4,r4,-764
 90aa520:	90a438c0 	call	90a438c <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 90aa524:	e0bffe17 	ldw	r2,-8(fp)
 90aa528:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 90aa52c:	e0bffe17 	ldw	r2,-8(fp)
 90aa530:	10800117 	ldw	r2,4(r2)
 90aa534:	1005003a 	cmpeq	r2,r2,zero
 90aa538:	1000071e 	bne	r2,zero,90aa558 <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90aa53c:	01000084 	movi	r4,2
 90aa540:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 90aa544:	e0bffe17 	ldw	r2,-8(fp)
 90aa548:	11000117 	ldw	r4,4(r2)
 90aa54c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aa550:	01000084 	movi	r4,2
 90aa554:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 90aa558:	00824374 	movhi	r2,2317
 90aa55c:	108c4904 	addi	r2,r2,12580
 90aa560:	10800017 	ldw	r2,0(r2)
 90aa564:	10c00044 	addi	r3,r2,1
 90aa568:	00824374 	movhi	r2,2317
 90aa56c:	108c4904 	addi	r2,r2,12580
 90aa570:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 90aa574:	e17ffe17 	ldw	r5,-8(fp)
 90aa578:	010243b4 	movhi	r4,2318
 90aa57c:	21357404 	addi	r4,r4,-10800
 90aa580:	90a8e180 	call	90a8e18 <putq>
   return nextptr;
 90aa584:	e0bffd17 	ldw	r2,-12(fp)
 90aa588:	e0bfff15 	stw	r2,-4(fp)
 90aa58c:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa590:	e037883a 	mov	sp,fp
 90aa594:	dfc00117 	ldw	ra,4(sp)
 90aa598:	df000017 	ldw	fp,0(sp)
 90aa59c:	dec00204 	addi	sp,sp,8
 90aa5a0:	f800283a 	ret

090aa5a4 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 90aa5a4:	defffd04 	addi	sp,sp,-12
 90aa5a8:	dfc00215 	stw	ra,8(sp)
 90aa5ac:	df000115 	stw	fp,4(sp)
 90aa5b0:	df000104 	addi	fp,sp,4
 90aa5b4:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 90aa5b8:	00000306 	br	90aa5c8 <m_freem+0x24>
      m = m_free(m);
 90aa5bc:	e13fff17 	ldw	r4,-4(fp)
 90aa5c0:	90aa4700 	call	90aa470 <m_free>
 90aa5c4:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 90aa5c8:	e0bfff17 	ldw	r2,-4(fp)
 90aa5cc:	1004c03a 	cmpne	r2,r2,zero
 90aa5d0:	103ffa1e 	bne	r2,zero,90aa5bc <m_freem+0x18>
      m = m_free(m);
}
 90aa5d4:	e037883a 	mov	sp,fp
 90aa5d8:	dfc00117 	ldw	ra,4(sp)
 90aa5dc:	df000017 	ldw	fp,0(sp)
 90aa5e0:	dec00204 	addi	sp,sp,8
 90aa5e4:	f800283a 	ret

090aa5e8 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 90aa5e8:	defff404 	addi	sp,sp,-48
 90aa5ec:	dfc00b15 	stw	ra,44(sp)
 90aa5f0:	df000a15 	stw	fp,40(sp)
 90aa5f4:	df000a04 	addi	fp,sp,40
 90aa5f8:	e13ffa15 	stw	r4,-24(fp)
 90aa5fc:	e17ffb15 	stw	r5,-20(fp)
 90aa600:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 90aa604:	e0bffc17 	ldw	r2,-16(fp)
 90aa608:	1004c03a 	cmpne	r2,r2,zero
 90aa60c:	1000021e 	bne	r2,zero,90aa618 <m_copy+0x30>
      return NULL;
 90aa610:	e03ffd15 	stw	zero,-12(fp)
 90aa614:	0000b706 	br	90aa8f4 <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 90aa618:	e0bffb17 	ldw	r2,-20(fp)
 90aa61c:	1004803a 	cmplt	r2,r2,zero
 90aa620:	1000061e 	bne	r2,zero,90aa63c <m_copy+0x54>
 90aa624:	e0bffc17 	ldw	r2,-16(fp)
 90aa628:	1004403a 	cmpge	r2,r2,zero
 90aa62c:	1000191e 	bne	r2,zero,90aa694 <m_copy+0xac>
 90aa630:	e0bffc17 	ldw	r2,-16(fp)
 90aa634:	10bfffe0 	cmpeqi	r2,r2,-1
 90aa638:	1000161e 	bne	r2,zero,90aa694 <m_copy+0xac>
   {
      dtrap();
 90aa63c:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90aa640:	e03ffd15 	stw	zero,-12(fp)
 90aa644:	0000ab06 	br	90aa8f4 <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 90aa648:	e0bffa17 	ldw	r2,-24(fp)
 90aa64c:	1004c03a 	cmpne	r2,r2,zero
 90aa650:	1000031e 	bne	r2,zero,90aa660 <m_copy+0x78>
      {
         dtrap();
 90aa654:	90a94880 	call	90a9488 <dtrap>
         return NULL;
 90aa658:	e03ffd15 	stw	zero,-12(fp)
 90aa65c:	0000a506 	br	90aa8f4 <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 90aa660:	e0bffa17 	ldw	r2,-24(fp)
 90aa664:	10800217 	ldw	r2,8(r2)
 90aa668:	1007883a 	mov	r3,r2
 90aa66c:	e0bffb17 	ldw	r2,-20(fp)
 90aa670:	10c00b16 	blt	r2,r3,90aa6a0 <m_copy+0xb8>
         break;
      off -= m->m_len;
 90aa674:	e0fffb17 	ldw	r3,-20(fp)
 90aa678:	e0bffa17 	ldw	r2,-24(fp)
 90aa67c:	10800217 	ldw	r2,8(r2)
 90aa680:	1885c83a 	sub	r2,r3,r2
 90aa684:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 90aa688:	e0bffa17 	ldw	r2,-24(fp)
 90aa68c:	10800617 	ldw	r2,24(r2)
 90aa690:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 90aa694:	e0bffb17 	ldw	r2,-20(fp)
 90aa698:	10800048 	cmpgei	r2,r2,1
 90aa69c:	103fea1e 	bne	r2,zero,90aa648 <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 90aa6a0:	e03ff715 	stw	zero,-36(fp)
 90aa6a4:	e0bff717 	ldw	r2,-36(fp)
 90aa6a8:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 90aa6ac:	00008806 	br	90aa8d0 <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 90aa6b0:	e0bffa17 	ldw	r2,-24(fp)
 90aa6b4:	1004c03a 	cmpne	r2,r2,zero
 90aa6b8:	1000051e 	bne	r2,zero,90aa6d0 <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 90aa6bc:	01024374 	movhi	r4,2317
 90aa6c0:	213f4504 	addi	r4,r4,-748
 90aa6c4:	90a438c0 	call	90a438c <panic>
         return NULL;
 90aa6c8:	e03ffd15 	stw	zero,-12(fp)
 90aa6cc:	00008906 	br	90aa8f4 <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 90aa6d0:	e0bffa17 	ldw	r2,-24(fp)
 90aa6d4:	10c00217 	ldw	r3,8(r2)
 90aa6d8:	e0bffb17 	ldw	r2,-20(fp)
 90aa6dc:	1885c83a 	sub	r2,r3,r2
 90aa6e0:	e0fffc17 	ldw	r3,-16(fp)
 90aa6e4:	e0ffff15 	stw	r3,-4(fp)
 90aa6e8:	e0bffe15 	stw	r2,-8(fp)
 90aa6ec:	e0bfff17 	ldw	r2,-4(fp)
 90aa6f0:	e0fffe17 	ldw	r3,-8(fp)
 90aa6f4:	10c0020e 	bge	r2,r3,90aa700 <m_copy+0x118>
 90aa6f8:	e0bfff17 	ldw	r2,-4(fp)
 90aa6fc:	e0bffe15 	stw	r2,-8(fp)
 90aa700:	e0fffe17 	ldw	r3,-8(fp)
 90aa704:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 90aa708:	e0bffb17 	ldw	r2,-20(fp)
 90aa70c:	108000cc 	andi	r2,r2,3
 90aa710:	1004c03a 	cmpne	r2,r2,zero
 90aa714:	1000051e 	bne	r2,zero,90aa72c <m_copy+0x144>
 90aa718:	e0bffa17 	ldw	r2,-24(fp)
 90aa71c:	10800117 	ldw	r2,4(r2)
 90aa720:	10800917 	ldw	r2,36(r2)
 90aa724:	10800060 	cmpeqi	r2,r2,1
 90aa728:	1000251e 	bne	r2,zero,90aa7c0 <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 90aa72c:	e0bffa17 	ldw	r2,-24(fp)
 90aa730:	11000817 	ldw	r4,32(r2)
 90aa734:	e17ff617 	ldw	r5,-40(fp)
 90aa738:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aa73c:	e0bff915 	stw	r2,-28(fp)
 90aa740:	e0bff917 	ldw	r2,-28(fp)
 90aa744:	1005003a 	cmpeq	r2,r2,zero
 90aa748:	1000671e 	bne	r2,zero,90aa8e8 <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 90aa74c:	e0bff917 	ldw	r2,-28(fp)
 90aa750:	11000317 	ldw	r4,12(r2)
 90aa754:	e0bffa17 	ldw	r2,-24(fp)
 90aa758:	10c00317 	ldw	r3,12(r2)
 90aa75c:	e0bffb17 	ldw	r2,-20(fp)
 90aa760:	1885883a 	add	r2,r3,r2
 90aa764:	e0fff617 	ldw	r3,-40(fp)
 90aa768:	100b883a 	mov	r5,r2
 90aa76c:	180d883a 	mov	r6,r3
 90aa770:	90822780 	call	9082278 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 90aa774:	e0fff617 	ldw	r3,-40(fp)
 90aa778:	e0bff917 	ldw	r2,-28(fp)
 90aa77c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 90aa780:	008243b4 	movhi	r2,2318
 90aa784:	10b58e04 	addi	r2,r2,-10696
 90aa788:	10802e17 	ldw	r2,184(r2)
 90aa78c:	10c00044 	addi	r3,r2,1
 90aa790:	008243b4 	movhi	r2,2318
 90aa794:	10b58e04 	addi	r2,r2,-10696
 90aa798:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 90aa79c:	008243b4 	movhi	r2,2318
 90aa7a0:	10b58e04 	addi	r2,r2,-10696
 90aa7a4:	10c03017 	ldw	r3,192(r2)
 90aa7a8:	e0bff617 	ldw	r2,-40(fp)
 90aa7ac:	1887883a 	add	r3,r3,r2
 90aa7b0:	008243b4 	movhi	r2,2318
 90aa7b4:	10b58e04 	addi	r2,r2,-10696
 90aa7b8:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 90aa7bc:	00003106 	br	90aa884 <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 90aa7c0:	e0bffa17 	ldw	r2,-24(fp)
 90aa7c4:	11000817 	ldw	r4,32(r2)
 90aa7c8:	000b883a 	mov	r5,zero
 90aa7cc:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aa7d0:	e0bff915 	stw	r2,-28(fp)
 90aa7d4:	e0bff917 	ldw	r2,-28(fp)
 90aa7d8:	1005003a 	cmpeq	r2,r2,zero
 90aa7dc:	1000421e 	bne	r2,zero,90aa8e8 <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 90aa7e0:	e0bffa17 	ldw	r2,-24(fp)
 90aa7e4:	10c00117 	ldw	r3,4(r2)
 90aa7e8:	18800917 	ldw	r2,36(r3)
 90aa7ec:	10800044 	addi	r2,r2,1
 90aa7f0:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 90aa7f4:	e0bffa17 	ldw	r2,-24(fp)
 90aa7f8:	10c00117 	ldw	r3,4(r2)
 90aa7fc:	e0bff917 	ldw	r2,-28(fp)
 90aa800:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 90aa804:	e0bffa17 	ldw	r2,-24(fp)
 90aa808:	10c00417 	ldw	r3,16(r2)
 90aa80c:	e0bff917 	ldw	r2,-28(fp)
 90aa810:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 90aa814:	e0bffa17 	ldw	r2,-24(fp)
 90aa818:	10c00517 	ldw	r3,20(r2)
 90aa81c:	e0bff917 	ldw	r2,-28(fp)
 90aa820:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 90aa824:	e0bffa17 	ldw	r2,-24(fp)
 90aa828:	10c00317 	ldw	r3,12(r2)
 90aa82c:	e0bffb17 	ldw	r2,-20(fp)
 90aa830:	1887883a 	add	r3,r3,r2
 90aa834:	e0bff917 	ldw	r2,-28(fp)
 90aa838:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 90aa83c:	e0fff617 	ldw	r3,-40(fp)
 90aa840:	e0bff917 	ldw	r2,-28(fp)
 90aa844:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 90aa848:	008243b4 	movhi	r2,2318
 90aa84c:	10b58e04 	addi	r2,r2,-10696
 90aa850:	10802f17 	ldw	r2,188(r2)
 90aa854:	10c00044 	addi	r3,r2,1
 90aa858:	008243b4 	movhi	r2,2318
 90aa85c:	10b58e04 	addi	r2,r2,-10696
 90aa860:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 90aa864:	008243b4 	movhi	r2,2318
 90aa868:	10b58e04 	addi	r2,r2,-10696
 90aa86c:	10c03117 	ldw	r3,196(r2)
 90aa870:	e0bff617 	ldw	r2,-40(fp)
 90aa874:	1887883a 	add	r3,r3,r2
 90aa878:	008243b4 	movhi	r2,2318
 90aa87c:	10b58e04 	addi	r2,r2,-10696
 90aa880:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 90aa884:	e0fffc17 	ldw	r3,-16(fp)
 90aa888:	e0bff617 	ldw	r2,-40(fp)
 90aa88c:	1885c83a 	sub	r2,r3,r2
 90aa890:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 90aa894:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 90aa898:	e0bff717 	ldw	r2,-36(fp)
 90aa89c:	1005003a 	cmpeq	r2,r2,zero
 90aa8a0:	1000041e 	bne	r2,zero,90aa8b4 <m_copy+0x2cc>
         tail->m_next = nb;
 90aa8a4:	e0fff717 	ldw	r3,-36(fp)
 90aa8a8:	e0bff917 	ldw	r2,-28(fp)
 90aa8ac:	18800615 	stw	r2,24(r3)
 90aa8b0:	00000206 	br	90aa8bc <m_copy+0x2d4>
      else
         head = nb;
 90aa8b4:	e0bff917 	ldw	r2,-28(fp)
 90aa8b8:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 90aa8bc:	e0bff917 	ldw	r2,-28(fp)
 90aa8c0:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 90aa8c4:	e0bffa17 	ldw	r2,-24(fp)
 90aa8c8:	10800617 	ldw	r2,24(r2)
 90aa8cc:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 90aa8d0:	e0bffc17 	ldw	r2,-16(fp)
 90aa8d4:	10800048 	cmpgei	r2,r2,1
 90aa8d8:	103f751e 	bne	r2,zero,90aa6b0 <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 90aa8dc:	e0bff817 	ldw	r2,-32(fp)
 90aa8e0:	e0bffd15 	stw	r2,-12(fp)
 90aa8e4:	00000306 	br	90aa8f4 <m_copy+0x30c>

nospace:
   m_freem (head);
 90aa8e8:	e13ff817 	ldw	r4,-32(fp)
 90aa8ec:	90aa5a40 	call	90aa5a4 <m_freem>
   return NULL;
 90aa8f0:	e03ffd15 	stw	zero,-12(fp)
 90aa8f4:	e0bffd17 	ldw	r2,-12(fp)
}
 90aa8f8:	e037883a 	mov	sp,fp
 90aa8fc:	dfc00117 	ldw	ra,4(sp)
 90aa900:	df000017 	ldw	fp,0(sp)
 90aa904:	dec00204 	addi	sp,sp,8
 90aa908:	f800283a 	ret

090aa90c <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 90aa90c:	defffb04 	addi	sp,sp,-20
 90aa910:	df000415 	stw	fp,16(sp)
 90aa914:	df000404 	addi	fp,sp,16
 90aa918:	e13ffe15 	stw	r4,-8(fp)
 90aa91c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 90aa920:	e0bffe17 	ldw	r2,-8(fp)
 90aa924:	e0bffd15 	stw	r2,-12(fp)
 90aa928:	e0bffd17 	ldw	r2,-12(fp)
 90aa92c:	1005003a 	cmpeq	r2,r2,zero
 90aa930:	1000661e 	bne	r2,zero,90aaacc <m_adj+0x1c0>
      return;

   if (len >= 0) 
 90aa934:	e0bfff17 	ldw	r2,-4(fp)
 90aa938:	1004803a 	cmplt	r2,r2,zero
 90aa93c:	1000241e 	bne	r2,zero,90aa9d0 <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 90aa940:	00001c06 	br	90aa9b4 <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 90aa944:	e0bffd17 	ldw	r2,-12(fp)
 90aa948:	10c00217 	ldw	r3,8(r2)
 90aa94c:	e0bfff17 	ldw	r2,-4(fp)
 90aa950:	10c00b36 	bltu	r2,r3,90aa980 <m_adj+0x74>
         {
            len -= m->m_len;
 90aa954:	e0ffff17 	ldw	r3,-4(fp)
 90aa958:	e0bffd17 	ldw	r2,-12(fp)
 90aa95c:	10800217 	ldw	r2,8(r2)
 90aa960:	1885c83a 	sub	r2,r3,r2
 90aa964:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 90aa968:	e0bffd17 	ldw	r2,-12(fp)
 90aa96c:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 90aa970:	e0bffd17 	ldw	r2,-12(fp)
 90aa974:	10800617 	ldw	r2,24(r2)
 90aa978:	e0bffd15 	stw	r2,-12(fp)
 90aa97c:	00000d06 	br	90aa9b4 <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 90aa980:	e0bffd17 	ldw	r2,-12(fp)
 90aa984:	10c00217 	ldw	r3,8(r2)
 90aa988:	e0bfff17 	ldw	r2,-4(fp)
 90aa98c:	1887c83a 	sub	r3,r3,r2
 90aa990:	e0bffd17 	ldw	r2,-12(fp)
 90aa994:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 90aa998:	e0bffd17 	ldw	r2,-12(fp)
 90aa99c:	10c00317 	ldw	r3,12(r2)
 90aa9a0:	e0bfff17 	ldw	r2,-4(fp)
 90aa9a4:	1887883a 	add	r3,r3,r2
 90aa9a8:	e0bffd17 	ldw	r2,-12(fp)
 90aa9ac:	10c00315 	stw	r3,12(r2)
            break;
 90aa9b0:	00004606 	br	90aaacc <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 90aa9b4:	e0bffd17 	ldw	r2,-12(fp)
 90aa9b8:	1005003a 	cmpeq	r2,r2,zero
 90aa9bc:	1000431e 	bne	r2,zero,90aaacc <m_adj+0x1c0>
 90aa9c0:	e0bfff17 	ldw	r2,-4(fp)
 90aa9c4:	10800048 	cmpgei	r2,r2,1
 90aa9c8:	103fde1e 	bne	r2,zero,90aa944 <m_adj+0x38>
 90aa9cc:	00003f06 	br	90aaacc <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 90aa9d0:	e0bfff17 	ldw	r2,-4(fp)
 90aa9d4:	0085c83a 	sub	r2,zero,r2
 90aa9d8:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 90aa9dc:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 90aa9e0:	e0bffd17 	ldw	r2,-12(fp)
 90aa9e4:	10c00217 	ldw	r3,8(r2)
 90aa9e8:	e0bffc17 	ldw	r2,-16(fp)
 90aa9ec:	1885883a 	add	r2,r3,r2
 90aa9f0:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 90aa9f4:	e0bffd17 	ldw	r2,-12(fp)
 90aa9f8:	10800617 	ldw	r2,24(r2)
 90aa9fc:	1005003a 	cmpeq	r2,r2,zero
 90aaa00:	1000041e 	bne	r2,zero,90aaa14 <m_adj+0x108>
            break;
         m = m->m_next;
 90aaa04:	e0bffd17 	ldw	r2,-12(fp)
 90aaa08:	10800617 	ldw	r2,24(r2)
 90aaa0c:	e0bffd15 	stw	r2,-12(fp)
      }
 90aaa10:	003ff306 	br	90aa9e0 <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 90aaa14:	e0bffd17 	ldw	r2,-12(fp)
 90aaa18:	10c00217 	ldw	r3,8(r2)
 90aaa1c:	e0bfff17 	ldw	r2,-4(fp)
 90aaa20:	18800736 	bltu	r3,r2,90aaa40 <m_adj+0x134>
      {
         m->m_len -= len;
 90aaa24:	e0bffd17 	ldw	r2,-12(fp)
 90aaa28:	10c00217 	ldw	r3,8(r2)
 90aaa2c:	e0bfff17 	ldw	r2,-4(fp)
 90aaa30:	1887c83a 	sub	r3,r3,r2
 90aaa34:	e0bffd17 	ldw	r2,-12(fp)
 90aaa38:	10c00215 	stw	r3,8(r2)
         return;
 90aaa3c:	00002306 	br	90aaacc <m_adj+0x1c0>
      }
      count -= len;
 90aaa40:	e0fffc17 	ldw	r3,-16(fp)
 90aaa44:	e0bfff17 	ldw	r2,-4(fp)
 90aaa48:	1885c83a 	sub	r2,r3,r2
 90aaa4c:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 90aaa50:	e0bffe17 	ldw	r2,-8(fp)
 90aaa54:	e0bffd15 	stw	r2,-12(fp)
 90aaa58:	00001006 	br	90aaa9c <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 90aaa5c:	e0bffd17 	ldw	r2,-12(fp)
 90aaa60:	10c00217 	ldw	r3,8(r2)
 90aaa64:	e0bffc17 	ldw	r2,-16(fp)
 90aaa68:	18800436 	bltu	r3,r2,90aaa7c <m_adj+0x170>
         {
            m->m_len = count;
 90aaa6c:	e0fffc17 	ldw	r3,-16(fp)
 90aaa70:	e0bffd17 	ldw	r2,-12(fp)
 90aaa74:	10c00215 	stw	r3,8(r2)
            break;
 90aaa78:	00000e06 	br	90aaab4 <m_adj+0x1a8>
         }
         count -= m->m_len;
 90aaa7c:	e0fffc17 	ldw	r3,-16(fp)
 90aaa80:	e0bffd17 	ldw	r2,-12(fp)
 90aaa84:	10800217 	ldw	r2,8(r2)
 90aaa88:	1885c83a 	sub	r2,r3,r2
 90aaa8c:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 90aaa90:	e0bffd17 	ldw	r2,-12(fp)
 90aaa94:	10800617 	ldw	r2,24(r2)
 90aaa98:	e0bffd15 	stw	r2,-12(fp)
 90aaa9c:	e0bffd17 	ldw	r2,-12(fp)
 90aaaa0:	1004c03a 	cmpne	r2,r2,zero
 90aaaa4:	103fed1e 	bne	r2,zero,90aaa5c <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 90aaaa8:	00000206 	br	90aaab4 <m_adj+0x1a8>
         m->m_len = 0;
 90aaaac:	e0bffd17 	ldw	r2,-12(fp)
 90aaab0:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 90aaab4:	e0bffd17 	ldw	r2,-12(fp)
 90aaab8:	10800617 	ldw	r2,24(r2)
 90aaabc:	e0bffd15 	stw	r2,-12(fp)
 90aaac0:	e0bffd17 	ldw	r2,-12(fp)
 90aaac4:	1004c03a 	cmpne	r2,r2,zero
 90aaac8:	103ff81e 	bne	r2,zero,90aaaac <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 90aaacc:	e037883a 	mov	sp,fp
 90aaad0:	df000017 	ldw	fp,0(sp)
 90aaad4:	dec00104 	addi	sp,sp,4
 90aaad8:	f800283a 	ret

090aaadc <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 90aaadc:	defffd04 	addi	sp,sp,-12
 90aaae0:	df000215 	stw	fp,8(sp)
 90aaae4:	df000204 	addi	fp,sp,8
 90aaae8:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 90aaaec:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 90aaaf0:	00000806 	br	90aab14 <mbuf_len+0x38>
   {
      len += m->m_len;
 90aaaf4:	e0bfff17 	ldw	r2,-4(fp)
 90aaaf8:	10c00217 	ldw	r3,8(r2)
 90aaafc:	e0bffe17 	ldw	r2,-8(fp)
 90aab00:	1885883a 	add	r2,r3,r2
 90aab04:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 90aab08:	e0bfff17 	ldw	r2,-4(fp)
 90aab0c:	10800617 	ldw	r2,24(r2)
 90aab10:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 90aab14:	e0bfff17 	ldw	r2,-4(fp)
 90aab18:	1004c03a 	cmpne	r2,r2,zero
 90aab1c:	103ff51e 	bne	r2,zero,90aaaf4 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 90aab20:	e0bffe17 	ldw	r2,-8(fp)
}
 90aab24:	e037883a 	mov	sp,fp
 90aab28:	df000017 	ldw	fp,0(sp)
 90aab2c:	dec00104 	addi	sp,sp,4
 90aab30:	f800283a 	ret

090aab34 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 90aab34:	defffa04 	addi	sp,sp,-24
 90aab38:	dfc00515 	stw	ra,20(sp)
 90aab3c:	df000415 	stw	fp,16(sp)
 90aab40:	df000404 	addi	fp,sp,16
 90aab44:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 90aab48:	008243b4 	movhi	r2,2318
 90aab4c:	10b56f04 	addi	r2,r2,-10820
 90aab50:	10800017 	ldw	r2,0(r2)
 90aab54:	e0bffd15 	stw	r2,-12(fp)
 90aab58:	00001306 	br	90aaba8 <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 90aab5c:	e0bffd17 	ldw	r2,-12(fp)
 90aab60:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 90aab64:	e0bffc17 	ldw	r2,-16(fp)
 90aab68:	10c00417 	ldw	r3,16(r2)
 90aab6c:	e0bffe17 	ldw	r2,-8(fp)
 90aab70:	10c00a36 	bltu	r2,r3,90aab9c <dtom+0x68>
 90aab74:	e0bffc17 	ldw	r2,-16(fp)
 90aab78:	10c00417 	ldw	r3,16(r2)
 90aab7c:	e0bffc17 	ldw	r2,-16(fp)
 90aab80:	10800517 	ldw	r2,20(r2)
 90aab84:	1887883a 	add	r3,r3,r2
 90aab88:	e0bffe17 	ldw	r2,-8(fp)
 90aab8c:	10c0032e 	bgeu	r2,r3,90aab9c <dtom+0x68>
         return (struct mbuf *)qptr;
 90aab90:	e0bffd17 	ldw	r2,-12(fp)
 90aab94:	e0bfff15 	stw	r2,-4(fp)
 90aab98:	00000a06 	br	90aabc4 <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 90aab9c:	e0bffd17 	ldw	r2,-12(fp)
 90aaba0:	10800017 	ldw	r2,0(r2)
 90aaba4:	e0bffd15 	stw	r2,-12(fp)
 90aaba8:	e0bffd17 	ldw	r2,-12(fp)
 90aabac:	1004c03a 	cmpne	r2,r2,zero
 90aabb0:	103fea1e 	bne	r2,zero,90aab5c <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 90aabb4:	01024374 	movhi	r4,2317
 90aabb8:	213f4904 	addi	r4,r4,-732
 90aabbc:	90a438c0 	call	90a438c <panic>
   return NULL;
 90aabc0:	e03fff15 	stw	zero,-4(fp)
 90aabc4:	e0bfff17 	ldw	r2,-4(fp)
}
 90aabc8:	e037883a 	mov	sp,fp
 90aabcc:	dfc00117 	ldw	ra,4(sp)
 90aabd0:	df000017 	ldw	fp,0(sp)
 90aabd4:	dec00204 	addi	sp,sp,8
 90aabd8:	f800283a 	ret

090aabdc <remque>:
};


void
remque (void * arg)
{
 90aabdc:	defffd04 	addi	sp,sp,-12
 90aabe0:	df000215 	stw	fp,8(sp)
 90aabe4:	df000204 	addi	fp,sp,8
 90aabe8:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 90aabec:	e0bfff17 	ldw	r2,-4(fp)
 90aabf0:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 90aabf4:	e0bffe17 	ldw	r2,-8(fp)
 90aabf8:	10800117 	ldw	r2,4(r2)
 90aabfc:	1005003a 	cmpeq	r2,r2,zero
 90aac00:	10000e1e 	bne	r2,zero,90aac3c <remque+0x60>
      old->prev->next = old->next;
 90aac04:	e0bffe17 	ldw	r2,-8(fp)
 90aac08:	10c00117 	ldw	r3,4(r2)
 90aac0c:	e0bffe17 	ldw	r2,-8(fp)
 90aac10:	10800017 	ldw	r2,0(r2)
 90aac14:	18800015 	stw	r2,0(r3)
   if (old->next)
 90aac18:	e0bffe17 	ldw	r2,-8(fp)
 90aac1c:	10800017 	ldw	r2,0(r2)
 90aac20:	1005003a 	cmpeq	r2,r2,zero
 90aac24:	1000051e 	bne	r2,zero,90aac3c <remque+0x60>
      old->next->prev = old->prev;
 90aac28:	e0bffe17 	ldw	r2,-8(fp)
 90aac2c:	10c00017 	ldw	r3,0(r2)
 90aac30:	e0bffe17 	ldw	r2,-8(fp)
 90aac34:	10800117 	ldw	r2,4(r2)
 90aac38:	18800115 	stw	r2,4(r3)
}
 90aac3c:	e037883a 	mov	sp,fp
 90aac40:	df000017 	ldw	fp,0(sp)
 90aac44:	dec00104 	addi	sp,sp,4
 90aac48:	f800283a 	ret

090aac4c <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 90aac4c:	defffb04 	addi	sp,sp,-20
 90aac50:	df000415 	stw	fp,16(sp)
 90aac54:	df000404 	addi	fp,sp,16
 90aac58:	e13ffe15 	stw	r4,-8(fp)
 90aac5c:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 90aac60:	e0bffe17 	ldw	r2,-8(fp)
 90aac64:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 90aac68:	e0bfff17 	ldw	r2,-4(fp)
 90aac6c:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 90aac70:	e0bffc17 	ldw	r2,-16(fp)
 90aac74:	10c00017 	ldw	r3,0(r2)
 90aac78:	e0bffd17 	ldw	r2,-12(fp)
 90aac7c:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 90aac80:	e0fffd17 	ldw	r3,-12(fp)
 90aac84:	e0bffc17 	ldw	r2,-16(fp)
 90aac88:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 90aac8c:	e0fffc17 	ldw	r3,-16(fp)
 90aac90:	e0bffd17 	ldw	r2,-12(fp)
 90aac94:	18800015 	stw	r2,0(r3)
   if (newe->next)
 90aac98:	e0bffd17 	ldw	r2,-12(fp)
 90aac9c:	10800017 	ldw	r2,0(r2)
 90aaca0:	1005003a 	cmpeq	r2,r2,zero
 90aaca4:	1000041e 	bne	r2,zero,90aacb8 <insque+0x6c>
      newe->next->prev = newe;
 90aaca8:	e0bffd17 	ldw	r2,-12(fp)
 90aacac:	10c00017 	ldw	r3,0(r2)
 90aacb0:	e0bffd17 	ldw	r2,-12(fp)
 90aacb4:	18800115 	stw	r2,4(r3)
}
 90aacb8:	e037883a 	mov	sp,fp
 90aacbc:	df000017 	ldw	fp,0(sp)
 90aacc0:	dec00104 	addi	sp,sp,4
 90aacc4:	f800283a 	ret

090aacc8 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 90aacc8:	defffb04 	addi	sp,sp,-20
 90aaccc:	dfc00415 	stw	ra,16(sp)
 90aacd0:	df000315 	stw	fp,12(sp)
 90aacd4:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 90aacd8:	00824374 	movhi	r2,2317
 90aacdc:	108bce04 	addi	r2,r2,12088
 90aace0:	10c00017 	ldw	r3,0(r2)
 90aace4:	00824374 	movhi	r2,2317
 90aace8:	108bd004 	addi	r2,r2,12096
 90aacec:	10800017 	ldw	r2,0(r2)
 90aacf0:	1885883a 	add	r2,r3,r2
 90aacf4:	1085883a 	add	r2,r2,r2
 90aacf8:	108000c4 	addi	r2,r2,3
 90aacfc:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 90aad00:	008243b4 	movhi	r2,2318
 90aad04:	10b55b04 	addi	r2,r2,-10900
 90aad08:	10000015 	stw	zero,0(r2)
 90aad0c:	10000115 	stw	zero,4(r2)
 90aad10:	10000215 	stw	zero,8(r2)
 90aad14:	10000315 	stw	zero,12(r2)
 90aad18:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 90aad1c:	008243b4 	movhi	r2,2318
 90aad20:	10b56f04 	addi	r2,r2,-10820
 90aad24:	10000015 	stw	zero,0(r2)
 90aad28:	10000115 	stw	zero,4(r2)
 90aad2c:	10000215 	stw	zero,8(r2)
 90aad30:	10000315 	stw	zero,12(r2)
 90aad34:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 90aad38:	008243b4 	movhi	r2,2318
 90aad3c:	10b57404 	addi	r2,r2,-10800
 90aad40:	10000015 	stw	zero,0(r2)
 90aad44:	10000115 	stw	zero,4(r2)
 90aad48:	10000215 	stw	zero,8(r2)
 90aad4c:	10000315 	stw	zero,12(r2)
 90aad50:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 90aad54:	e03fff15 	stw	zero,-4(fp)
 90aad58:	00001606 	br	90aadb4 <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 90aad5c:	01000904 	movi	r4,36
 90aad60:	90a9f0c0 	call	90a9f0c <npalloc>
 90aad64:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 90aad68:	e0bffd17 	ldw	r2,-12(fp)
 90aad6c:	1004c03a 	cmpne	r2,r2,zero
 90aad70:	1000031e 	bne	r2,zero,90aad80 <nptcp_init+0xb8>
         panic("tcpinit");
 90aad74:	01024374 	movhi	r4,2317
 90aad78:	213f4b04 	addi	r4,r4,-724
 90aad7c:	90a438c0 	call	90a438c <panic>
      m->m_type = MT_FREE;
 90aad80:	e0bffd17 	ldw	r2,-12(fp)
 90aad84:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 90aad88:	e0bffd17 	ldw	r2,-12(fp)
 90aad8c:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 90aad90:	e0bffd17 	ldw	r2,-12(fp)
 90aad94:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 90aad98:	e17ffd17 	ldw	r5,-12(fp)
 90aad9c:	010243b4 	movhi	r4,2318
 90aada0:	21357404 	addi	r4,r4,-10800
 90aada4:	90a8e180 	call	90a8e18 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 90aada8:	e0bfff17 	ldw	r2,-4(fp)
 90aadac:	10800044 	addi	r2,r2,1
 90aadb0:	e0bfff15 	stw	r2,-4(fp)
 90aadb4:	e0fffe17 	ldw	r3,-8(fp)
 90aadb8:	e0bfff17 	ldw	r2,-4(fp)
 90aadbc:	10ffe716 	blt	r2,r3,90aad5c <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 90aadc0:	e0fffe17 	ldw	r3,-8(fp)
 90aadc4:	008243b4 	movhi	r2,2318
 90aadc8:	10b57404 	addi	r2,r2,-10800
 90aadcc:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 90aadd0:	90b60c40 	call	90b60c4 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 90aadd4:	0005883a 	mov	r2,zero
}
 90aadd8:	e037883a 	mov	sp,fp
 90aaddc:	dfc00117 	ldw	ra,4(sp)
 90aade0:	df000017 	ldw	fp,0(sp)
 90aade4:	dec00204 	addi	sp,sp,8
 90aade8:	f800283a 	ret

090aadec <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 90aadec:	defff804 	addi	sp,sp,-32
 90aadf0:	dfc00715 	stw	ra,28(sp)
 90aadf4:	df000615 	stw	fp,24(sp)
 90aadf8:	df000604 	addi	fp,sp,24
 90aadfc:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 90aae00:	e0bffe17 	ldw	r2,-8(fp)
 90aae04:	10800317 	ldw	r2,12(r2)
 90aae08:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 90aae0c:	e0bffc17 	ldw	r2,-16(fp)
 90aae10:	1080008b 	ldhu	r2,2(r2)
 90aae14:	10bfffcc 	andi	r2,r2,65535
 90aae18:	1004d23a 	srli	r2,r2,8
 90aae1c:	10803fcc 	andi	r2,r2,255
 90aae20:	1009883a 	mov	r4,r2
 90aae24:	e0bffc17 	ldw	r2,-16(fp)
 90aae28:	1080008b 	ldhu	r2,2(r2)
 90aae2c:	10bfffcc 	andi	r2,r2,65535
 90aae30:	1004923a 	slli	r2,r2,8
 90aae34:	1007883a 	mov	r3,r2
 90aae38:	00bfc004 	movi	r2,-256
 90aae3c:	1884703a 	and	r2,r3,r2
 90aae40:	2084b03a 	or	r2,r4,r2
 90aae44:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 90aae48:	e0bffc17 	ldw	r2,-16(fp)
 90aae4c:	10800003 	ldbu	r2,0(r2)
 90aae50:	10803fcc 	andi	r2,r2,255
 90aae54:	108003cc 	andi	r2,r2,15
 90aae58:	1085883a 	add	r2,r2,r2
 90aae5c:	1085883a 	add	r2,r2,r2
 90aae60:	1007883a 	mov	r3,r2
 90aae64:	e0bffc17 	ldw	r2,-16(fp)
 90aae68:	1885883a 	add	r2,r3,r2
 90aae6c:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 90aae70:	e13ffc17 	ldw	r4,-16(fp)
 90aae74:	90c67340 	call	90c6734 <tcp_cksum>
 90aae78:	1007883a 	mov	r3,r2
 90aae7c:	e0bffb17 	ldw	r2,-20(fp)
 90aae80:	1080040b 	ldhu	r2,16(r2)
 90aae84:	18ffffcc 	andi	r3,r3,65535
 90aae88:	10bfffcc 	andi	r2,r2,65535
 90aae8c:	18801726 	beq	r3,r2,90aaeec <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 90aae90:	008243b4 	movhi	r2,2318
 90aae94:	10b56004 	addi	r2,r2,-10880
 90aae98:	10800d17 	ldw	r2,52(r2)
 90aae9c:	10c00044 	addi	r3,r2,1
 90aaea0:	008243b4 	movhi	r2,2318
 90aaea4:	10b56004 	addi	r2,r2,-10880
 90aaea8:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 90aaeac:	008243b4 	movhi	r2,2318
 90aaeb0:	10b58e04 	addi	r2,r2,-10696
 90aaeb4:	10801c17 	ldw	r2,112(r2)
 90aaeb8:	10c00044 	addi	r3,r2,1
 90aaebc:	008243b4 	movhi	r2,2318
 90aaec0:	10b58e04 	addi	r2,r2,-10696
 90aaec4:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90aaec8:	01000084 	movi	r4,2
 90aaecc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 90aaed0:	e13ffe17 	ldw	r4,-8(fp)
 90aaed4:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aaed8:	01000084 	movi	r4,2
 90aaedc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 90aaee0:	00bff804 	movi	r2,-32
 90aaee4:	e0bfff15 	stw	r2,-4(fp)
 90aaee8:	00003506 	br	90aafc0 <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 90aaeec:	01000044 	movi	r4,1
 90aaef0:	000b883a 	mov	r5,zero
 90aaef4:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aaef8:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 90aaefc:	e0bffd17 	ldw	r2,-12(fp)
 90aaf00:	1004c03a 	cmpne	r2,r2,zero
 90aaf04:	1000091e 	bne	r2,zero,90aaf2c <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90aaf08:	01000084 	movi	r4,2
 90aaf0c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90aaf10:	e13ffe17 	ldw	r4,-8(fp)
 90aaf14:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aaf18:	01000084 	movi	r4,2
 90aaf1c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 90aaf20:	00bffa84 	movi	r2,-22
 90aaf24:	e0bfff15 	stw	r2,-4(fp)
 90aaf28:	00002506 	br	90aafc0 <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 90aaf2c:	e0bffc17 	ldw	r2,-16(fp)
 90aaf30:	10800003 	ldbu	r2,0(r2)
 90aaf34:	10803fcc 	andi	r2,r2,255
 90aaf38:	108003cc 	andi	r2,r2,15
 90aaf3c:	1085883a 	add	r2,r2,r2
 90aaf40:	1085883a 	add	r2,r2,r2
 90aaf44:	1007883a 	mov	r3,r2
 90aaf48:	e0bffa0b 	ldhu	r2,-24(fp)
 90aaf4c:	10c5c83a 	sub	r2,r2,r3
 90aaf50:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 90aaf54:	e0fffc17 	ldw	r3,-16(fp)
 90aaf58:	e0bffa0b 	ldhu	r2,-24(fp)
 90aaf5c:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 90aaf60:	e0fffd17 	ldw	r3,-12(fp)
 90aaf64:	e0bffe17 	ldw	r2,-8(fp)
 90aaf68:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 90aaf6c:	e0bffe17 	ldw	r2,-8(fp)
 90aaf70:	10c00317 	ldw	r3,12(r2)
 90aaf74:	e0bffd17 	ldw	r2,-12(fp)
 90aaf78:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90aaf7c:	e0bffe17 	ldw	r2,-8(fp)
 90aaf80:	10c00417 	ldw	r3,16(r2)
 90aaf84:	e0bffd17 	ldw	r2,-12(fp)
 90aaf88:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 90aaf8c:	e0bffe17 	ldw	r2,-8(fp)
 90aaf90:	10c00117 	ldw	r3,4(r2)
 90aaf94:	e0bffd17 	ldw	r2,-12(fp)
 90aaf98:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 90aaf9c:	e0bffe17 	ldw	r2,-8(fp)
 90aafa0:	10c00217 	ldw	r3,8(r2)
 90aafa4:	e0bffd17 	ldw	r2,-12(fp)
 90aafa8:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 90aafac:	e0bffe17 	ldw	r2,-8(fp)
 90aafb0:	11400617 	ldw	r5,24(r2)
 90aafb4:	e13ffd17 	ldw	r4,-12(fp)
 90aafb8:	90b21500 	call	90b2150 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 90aafbc:	e03fff15 	stw	zero,-4(fp)
 90aafc0:	e0bfff17 	ldw	r2,-4(fp)
}
 90aafc4:	e037883a 	mov	sp,fp
 90aafc8:	dfc00117 	ldw	ra,4(sp)
 90aafcc:	df000017 	ldw	fp,0(sp)
 90aafd0:	dec00204 	addi	sp,sp,8
 90aafd4:	f800283a 	ret

090aafd8 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 90aafd8:	defff304 	addi	sp,sp,-52
 90aafdc:	dfc00c15 	stw	ra,48(sp)
 90aafe0:	df000b15 	stw	fp,44(sp)
 90aafe4:	df000b04 	addi	fp,sp,44
 90aafe8:	e13ffd15 	stw	r4,-12(fp)
 90aafec:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 90aaff0:	e0bffd17 	ldw	r2,-12(fp)
 90aaff4:	10800617 	ldw	r2,24(r2)
 90aaff8:	1005003a 	cmpeq	r2,r2,zero
 90aaffc:	1001101e 	bne	r2,zero,90ab440 <ip_output+0x468>
   {
      m1 = data;
 90ab000:	e0bffd17 	ldw	r2,-12(fp)
 90ab004:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 90ab008:	e0bffd17 	ldw	r2,-12(fp)
 90ab00c:	10800617 	ldw	r2,24(r2)
 90ab010:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 90ab014:	00003406 	br	90ab0e8 <ip_output+0x110>
      {
         pkt = m1->pkt;
 90ab018:	e0bff917 	ldw	r2,-28(fp)
 90ab01c:	10800117 	ldw	r2,4(r2)
 90ab020:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 90ab024:	e0bffa17 	ldw	r2,-24(fp)
 90ab028:	10c00117 	ldw	r3,4(r2)
 90ab02c:	e0bffa17 	ldw	r2,-24(fp)
 90ab030:	10800217 	ldw	r2,8(r2)
 90ab034:	1889883a 	add	r4,r3,r2
 90ab038:	e0bff917 	ldw	r2,-28(fp)
 90ab03c:	10c00317 	ldw	r3,12(r2)
 90ab040:	e0bff917 	ldw	r2,-28(fp)
 90ab044:	10800217 	ldw	r2,8(r2)
 90ab048:	1887883a 	add	r3,r3,r2
 90ab04c:	e0bff817 	ldw	r2,-32(fp)
 90ab050:	10800217 	ldw	r2,8(r2)
 90ab054:	1885883a 	add	r2,r3,r2
 90ab058:	1100822e 	bgeu	r2,r4,90ab264 <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 90ab05c:	e0bff917 	ldw	r2,-28(fp)
 90ab060:	10c00317 	ldw	r3,12(r2)
 90ab064:	e0bff917 	ldw	r2,-28(fp)
 90ab068:	10800217 	ldw	r2,8(r2)
 90ab06c:	1887883a 	add	r3,r3,r2
 90ab070:	e0bff817 	ldw	r2,-32(fp)
 90ab074:	11400317 	ldw	r5,12(r2)
 90ab078:	e0bff817 	ldw	r2,-32(fp)
 90ab07c:	10800217 	ldw	r2,8(r2)
 90ab080:	1809883a 	mov	r4,r3
 90ab084:	100d883a 	mov	r6,r2
 90ab088:	90822780 	call	9082278 <memcpy>
            m1->m_len += m2->m_len;
 90ab08c:	e0bff917 	ldw	r2,-28(fp)
 90ab090:	10c00217 	ldw	r3,8(r2)
 90ab094:	e0bff817 	ldw	r2,-32(fp)
 90ab098:	10800217 	ldw	r2,8(r2)
 90ab09c:	1887883a 	add	r3,r3,r2
 90ab0a0:	e0bff917 	ldw	r2,-28(fp)
 90ab0a4:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 90ab0a8:	e0bff817 	ldw	r2,-32(fp)
 90ab0ac:	10c00617 	ldw	r3,24(r2)
 90ab0b0:	e0bff917 	ldw	r2,-28(fp)
 90ab0b4:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 90ab0b8:	e13ff817 	ldw	r4,-32(fp)
 90ab0bc:	90aa4700 	call	90aa470 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 90ab0c0:	e0bff917 	ldw	r2,-28(fp)
 90ab0c4:	10800617 	ldw	r2,24(r2)
 90ab0c8:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 90ab0cc:	008243b4 	movhi	r2,2318
 90ab0d0:	10b58e04 	addi	r2,r2,-10696
 90ab0d4:	10803317 	ldw	r2,204(r2)
 90ab0d8:	10c00044 	addi	r3,r2,1
 90ab0dc:	008243b4 	movhi	r2,2318
 90ab0e0:	10b58e04 	addi	r2,r2,-10696
 90ab0e4:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 90ab0e8:	e0bff817 	ldw	r2,-32(fp)
 90ab0ec:	1005003a 	cmpeq	r2,r2,zero
 90ab0f0:	10005c1e 	bne	r2,zero,90ab264 <ip_output+0x28c>
 90ab0f4:	e0bff817 	ldw	r2,-32(fp)
 90ab0f8:	10800217 	ldw	r2,8(r2)
 90ab0fc:	108002b0 	cmpltui	r2,r2,10
 90ab100:	103fc51e 	bne	r2,zero,90ab018 <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 90ab104:	00005706 	br	90ab264 <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 90ab108:	e0bff817 	ldw	r2,-32(fp)
 90ab10c:	10800317 	ldw	r2,12(r2)
 90ab110:	1007883a 	mov	r3,r2
 90ab114:	e0bff817 	ldw	r2,-32(fp)
 90ab118:	10800117 	ldw	r2,4(r2)
 90ab11c:	10800117 	ldw	r2,4(r2)
 90ab120:	1885c83a 	sub	r2,r3,r2
 90ab124:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 90ab128:	00824374 	movhi	r2,2317
 90ab12c:	108c1b04 	addi	r2,r2,12396
 90ab130:	10c00017 	ldw	r3,0(r2)
 90ab134:	e0bff617 	ldw	r2,-40(fp)
 90ab138:	10c00a0e 	bge	r2,r3,90ab164 <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 90ab13c:	00824374 	movhi	r2,2317
 90ab140:	108c1b04 	addi	r2,r2,12396
 90ab144:	11400017 	ldw	r5,0(r2)
 90ab148:	01024374 	movhi	r4,2317
 90ab14c:	213f4d04 	addi	r4,r4,-716
 90ab150:	e1bff617 	ldw	r6,-40(fp)
 90ab154:	90825100 	call	9082510 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 90ab158:	01024374 	movhi	r4,2317
 90ab15c:	213f5304 	addi	r4,r4,-692
 90ab160:	90a438c0 	call	90a438c <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 90ab164:	e0bff917 	ldw	r2,-28(fp)
 90ab168:	11000217 	ldw	r4,8(r2)
 90ab16c:	00824374 	movhi	r2,2317
 90ab170:	108c1b04 	addi	r2,r2,12396
 90ab174:	10c00017 	ldw	r3,0(r2)
 90ab178:	e0bff617 	ldw	r2,-40(fp)
 90ab17c:	10c5c83a 	sub	r2,r2,r3
 90ab180:	20803b2e 	bgeu	r4,r2,90ab270 <ip_output+0x298>
 90ab184:	e0bff917 	ldw	r2,-28(fp)
 90ab188:	10800217 	ldw	r2,8(r2)
 90ab18c:	108000cc 	andi	r2,r2,3
 90ab190:	1004c03a 	cmpne	r2,r2,zero
 90ab194:	1000361e 	bne	r2,zero,90ab270 <ip_output+0x298>
 90ab198:	e0bff817 	ldw	r2,-32(fp)
 90ab19c:	10800317 	ldw	r2,12(r2)
 90ab1a0:	1007883a 	mov	r3,r2
 90ab1a4:	e0bff817 	ldw	r2,-32(fp)
 90ab1a8:	10800117 	ldw	r2,4(r2)
 90ab1ac:	10800117 	ldw	r2,4(r2)
 90ab1b0:	1885c83a 	sub	r2,r3,r2
 90ab1b4:	10800e18 	cmpnei	r2,r2,56
 90ab1b8:	10002d1e 	bne	r2,zero,90ab270 <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 90ab1bc:	e0bff817 	ldw	r2,-32(fp)
 90ab1c0:	10c00317 	ldw	r3,12(r2)
 90ab1c4:	e0bff917 	ldw	r2,-28(fp)
 90ab1c8:	10800217 	ldw	r2,8(r2)
 90ab1cc:	1887c83a 	sub	r3,r3,r2
 90ab1d0:	e0bff917 	ldw	r2,-28(fp)
 90ab1d4:	11400317 	ldw	r5,12(r2)
 90ab1d8:	e0bff917 	ldw	r2,-28(fp)
 90ab1dc:	10800217 	ldw	r2,8(r2)
 90ab1e0:	1809883a 	mov	r4,r3
 90ab1e4:	100d883a 	mov	r6,r2
 90ab1e8:	90822780 	call	9082278 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 90ab1ec:	e0bff817 	ldw	r2,-32(fp)
 90ab1f0:	10c00317 	ldw	r3,12(r2)
 90ab1f4:	e0bff917 	ldw	r2,-28(fp)
 90ab1f8:	10800217 	ldw	r2,8(r2)
 90ab1fc:	1887c83a 	sub	r3,r3,r2
 90ab200:	e0bff817 	ldw	r2,-32(fp)
 90ab204:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 90ab208:	e0bff817 	ldw	r2,-32(fp)
 90ab20c:	10c00217 	ldw	r3,8(r2)
 90ab210:	e0bff917 	ldw	r2,-28(fp)
 90ab214:	10800217 	ldw	r2,8(r2)
 90ab218:	1887883a 	add	r3,r3,r2
 90ab21c:	e0bff817 	ldw	r2,-32(fp)
 90ab220:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 90ab224:	e13ff917 	ldw	r4,-28(fp)
 90ab228:	90aa4700 	call	90aa470 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 90ab22c:	e0bff817 	ldw	r2,-32(fp)
 90ab230:	e0bff915 	stw	r2,-28(fp)
 90ab234:	e0bff917 	ldw	r2,-28(fp)
 90ab238:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 90ab23c:	e0bff817 	ldw	r2,-32(fp)
 90ab240:	10800617 	ldw	r2,24(r2)
 90ab244:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 90ab248:	008243b4 	movhi	r2,2318
 90ab24c:	10b58e04 	addi	r2,r2,-10696
 90ab250:	10803217 	ldw	r2,200(r2)
 90ab254:	10c00044 	addi	r3,r2,1
 90ab258:	008243b4 	movhi	r2,2318
 90ab25c:	10b58e04 	addi	r2,r2,-10696
 90ab260:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 90ab264:	e0bff817 	ldw	r2,-32(fp)
 90ab268:	1004c03a 	cmpne	r2,r2,zero
 90ab26c:	103fa61e 	bne	r2,zero,90ab108 <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 90ab270:	e0bff817 	ldw	r2,-32(fp)
 90ab274:	1005003a 	cmpeq	r2,r2,zero
 90ab278:	1000711e 	bne	r2,zero,90ab440 <ip_output+0x468>
      {
         total = 0;
 90ab27c:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 90ab280:	e0bff917 	ldw	r2,-28(fp)
 90ab284:	e0bff715 	stw	r2,-36(fp)
 90ab288:	00000806 	br	90ab2ac <ip_output+0x2d4>
            total += mtmp->m_len;
 90ab28c:	e0bff717 	ldw	r2,-36(fp)
 90ab290:	10c00217 	ldw	r3,8(r2)
 90ab294:	e0bff517 	ldw	r2,-44(fp)
 90ab298:	1885883a 	add	r2,r3,r2
 90ab29c:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 90ab2a0:	e0bff717 	ldw	r2,-36(fp)
 90ab2a4:	10800617 	ldw	r2,24(r2)
 90ab2a8:	e0bff715 	stw	r2,-36(fp)
 90ab2ac:	e0bff717 	ldw	r2,-36(fp)
 90ab2b0:	1004c03a 	cmpne	r2,r2,zero
 90ab2b4:	103ff51e 	bne	r2,zero,90ab28c <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90ab2b8:	01000084 	movi	r4,2
 90ab2bc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 90ab2c0:	e0bff517 	ldw	r2,-44(fp)
 90ab2c4:	10800e04 	addi	r2,r2,56
 90ab2c8:	1009883a 	mov	r4,r2
 90ab2cc:	90a88440 	call	90a8844 <pk_alloc>
 90ab2d0:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ab2d4:	01000084 	movi	r4,2
 90ab2d8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 90ab2dc:	e0bffa17 	ldw	r2,-24(fp)
 90ab2e0:	1004c03a 	cmpne	r2,r2,zero
 90ab2e4:	1000031e 	bne	r2,zero,90ab2f4 <ip_output+0x31c>
            return ENOBUFS;
 90ab2e8:	00801a44 	movi	r2,105
 90ab2ec:	e0bfff15 	stw	r2,-4(fp)
 90ab2f0:	0000b106 	br	90ab5b8 <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 90ab2f4:	e0bffa17 	ldw	r2,-24(fp)
 90ab2f8:	10c00117 	ldw	r3,4(r2)
 90ab2fc:	00824374 	movhi	r2,2317
 90ab300:	108c1b04 	addi	r2,r2,12396
 90ab304:	10800017 	ldw	r2,0(r2)
 90ab308:	1887883a 	add	r3,r3,r2
 90ab30c:	e0bffa17 	ldw	r2,-24(fp)
 90ab310:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 90ab314:	e0bff917 	ldw	r2,-28(fp)
 90ab318:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 90ab31c:	00002806 	br	90ab3c0 <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 90ab320:	e0bffa17 	ldw	r2,-24(fp)
 90ab324:	10c00317 	ldw	r3,12(r2)
 90ab328:	e0bff717 	ldw	r2,-36(fp)
 90ab32c:	11400317 	ldw	r5,12(r2)
 90ab330:	e0bff717 	ldw	r2,-36(fp)
 90ab334:	10800217 	ldw	r2,8(r2)
 90ab338:	1809883a 	mov	r4,r3
 90ab33c:	100d883a 	mov	r6,r2
 90ab340:	90822780 	call	9082278 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 90ab344:	e0bffa17 	ldw	r2,-24(fp)
 90ab348:	10c00317 	ldw	r3,12(r2)
 90ab34c:	e0bff717 	ldw	r2,-36(fp)
 90ab350:	10800217 	ldw	r2,8(r2)
 90ab354:	1887883a 	add	r3,r3,r2
 90ab358:	e0bffa17 	ldw	r2,-24(fp)
 90ab35c:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 90ab360:	e0bffa17 	ldw	r2,-24(fp)
 90ab364:	10c00417 	ldw	r3,16(r2)
 90ab368:	e0bff717 	ldw	r2,-36(fp)
 90ab36c:	10800217 	ldw	r2,8(r2)
 90ab370:	1887883a 	add	r3,r3,r2
 90ab374:	e0bffa17 	ldw	r2,-24(fp)
 90ab378:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 90ab37c:	e0bff717 	ldw	r2,-36(fp)
 90ab380:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 90ab384:	e0bff717 	ldw	r2,-36(fp)
 90ab388:	10800617 	ldw	r2,24(r2)
 90ab38c:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 90ab390:	e0fff817 	ldw	r3,-32(fp)
 90ab394:	e0bffd17 	ldw	r2,-12(fp)
 90ab398:	18800226 	beq	r3,r2,90ab3a4 <ip_output+0x3cc>
               m_free(m2);
 90ab39c:	e13ff817 	ldw	r4,-32(fp)
 90ab3a0:	90aa4700 	call	90aa470 <m_free>
            tcpstat.tcps_ocopies++;
 90ab3a4:	008243b4 	movhi	r2,2318
 90ab3a8:	10b58e04 	addi	r2,r2,-10696
 90ab3ac:	10803417 	ldw	r2,208(r2)
 90ab3b0:	10c00044 	addi	r3,r2,1
 90ab3b4:	008243b4 	movhi	r2,2318
 90ab3b8:	10b58e04 	addi	r2,r2,-10696
 90ab3bc:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 90ab3c0:	e0bff717 	ldw	r2,-36(fp)
 90ab3c4:	1004c03a 	cmpne	r2,r2,zero
 90ab3c8:	103fd51e 	bne	r2,zero,90ab320 <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 90ab3cc:	e0bffa17 	ldw	r2,-24(fp)
 90ab3d0:	10c00317 	ldw	r3,12(r2)
 90ab3d4:	e0bff517 	ldw	r2,-44(fp)
 90ab3d8:	1887c83a 	sub	r3,r3,r2
 90ab3dc:	e0bffa17 	ldw	r2,-24(fp)
 90ab3e0:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90ab3e4:	01000084 	movi	r4,2
 90ab3e8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 90ab3ec:	e0bffd17 	ldw	r2,-12(fp)
 90ab3f0:	11000117 	ldw	r4,4(r2)
 90ab3f4:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ab3f8:	01000084 	movi	r4,2
 90ab3fc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 90ab400:	e0fffd17 	ldw	r3,-12(fp)
 90ab404:	e0bffa17 	ldw	r2,-24(fp)
 90ab408:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 90ab40c:	e0bffa17 	ldw	r2,-24(fp)
 90ab410:	10c00417 	ldw	r3,16(r2)
 90ab414:	e0bffd17 	ldw	r2,-12(fp)
 90ab418:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 90ab41c:	e0bffd17 	ldw	r2,-12(fp)
 90ab420:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 90ab424:	e0bffa17 	ldw	r2,-24(fp)
 90ab428:	10c00317 	ldw	r3,12(r2)
 90ab42c:	e0bffd17 	ldw	r2,-12(fp)
 90ab430:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 90ab434:	e0fff517 	ldw	r3,-44(fp)
 90ab438:	e0bffd17 	ldw	r2,-12(fp)
 90ab43c:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 90ab440:	e0bffd17 	ldw	r2,-12(fp)
 90ab444:	11000317 	ldw	r4,12(r2)
 90ab448:	e0bffd17 	ldw	r2,-12(fp)
 90ab44c:	10800117 	ldw	r2,4(r2)
 90ab450:	10c00117 	ldw	r3,4(r2)
 90ab454:	00824374 	movhi	r2,2317
 90ab458:	108c1b04 	addi	r2,r2,12396
 90ab45c:	10800017 	ldw	r2,0(r2)
 90ab460:	1885883a 	add	r2,r3,r2
 90ab464:	2080032e 	bgeu	r4,r2,90ab474 <ip_output+0x49c>
      panic("ip_output: overflow");
 90ab468:	01024374 	movhi	r4,2317
 90ab46c:	213f5804 	addi	r4,r4,-672
 90ab470:	90a438c0 	call	90a438c <panic>

   pkt = data->pkt;
 90ab474:	e0bffd17 	ldw	r2,-12(fp)
 90ab478:	10800117 	ldw	r2,4(r2)
 90ab47c:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 90ab480:	e0bffe17 	ldw	r2,-8(fp)
 90ab484:	1005003a 	cmpeq	r2,r2,zero
 90ab488:	1000031e 	bne	r2,zero,90ab498 <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 90ab48c:	e0fffa17 	ldw	r3,-24(fp)
 90ab490:	e0bffe17 	ldw	r2,-8(fp)
 90ab494:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 90ab498:	e0bffd17 	ldw	r2,-12(fp)
 90ab49c:	10800317 	ldw	r2,12(r2)
 90ab4a0:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 90ab4a4:	e0bffc17 	ldw	r2,-16(fp)
 90ab4a8:	10c00417 	ldw	r3,16(r2)
 90ab4ac:	e0bffa17 	ldw	r2,-24(fp)
 90ab4b0:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 90ab4b4:	e0fffc17 	ldw	r3,-16(fp)
 90ab4b8:	00801144 	movi	r2,69
 90ab4bc:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 90ab4c0:	e0bffc17 	ldw	r2,-16(fp)
 90ab4c4:	1080008b 	ldhu	r2,2(r2)
 90ab4c8:	10bfffcc 	andi	r2,r2,65535
 90ab4cc:	1004d23a 	srli	r2,r2,8
 90ab4d0:	10803fcc 	andi	r2,r2,255
 90ab4d4:	1009883a 	mov	r4,r2
 90ab4d8:	e0bffc17 	ldw	r2,-16(fp)
 90ab4dc:	1080008b 	ldhu	r2,2(r2)
 90ab4e0:	10bfffcc 	andi	r2,r2,65535
 90ab4e4:	1004923a 	slli	r2,r2,8
 90ab4e8:	1007883a 	mov	r3,r2
 90ab4ec:	00bfc004 	movi	r2,-256
 90ab4f0:	1884703a 	and	r2,r3,r2
 90ab4f4:	2084b03a 	or	r2,r4,r2
 90ab4f8:	1007883a 	mov	r3,r2
 90ab4fc:	e0bffc17 	ldw	r2,-16(fp)
 90ab500:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 90ab504:	e0bffc17 	ldw	r2,-16(fp)
 90ab508:	10800003 	ldbu	r2,0(r2)
 90ab50c:	10803fcc 	andi	r2,r2,255
 90ab510:	108003cc 	andi	r2,r2,15
 90ab514:	1085883a 	add	r2,r2,r2
 90ab518:	1085883a 	add	r2,r2,r2
 90ab51c:	1007883a 	mov	r3,r2
 90ab520:	e0bffc17 	ldw	r2,-16(fp)
 90ab524:	1885883a 	add	r2,r3,r2
 90ab528:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 90ab52c:	e13ffc17 	ldw	r4,-16(fp)
 90ab530:	90c67340 	call	90c6734 <tcp_cksum>
 90ab534:	1007883a 	mov	r3,r2
 90ab538:	e0bffb17 	ldw	r2,-20(fp)
 90ab53c:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 90ab540:	e0bffc17 	ldw	r2,-16(fp)
 90ab544:	10800504 	addi	r2,r2,20
 90ab548:	1007883a 	mov	r3,r2
 90ab54c:	e0bffa17 	ldw	r2,-24(fp)
 90ab550:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 90ab554:	e0bffd17 	ldw	r2,-12(fp)
 90ab558:	10800217 	ldw	r2,8(r2)
 90ab55c:	10fffb04 	addi	r3,r2,-20
 90ab560:	e0bffa17 	ldw	r2,-24(fp)
 90ab564:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 90ab568:	01000184 	movi	r4,6
 90ab56c:	e17ffa17 	ldw	r5,-24(fp)
 90ab570:	90bd99c0 	call	90bd99c <ip_write>
 90ab574:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 90ab578:	e0bffd17 	ldw	r2,-12(fp)
 90ab57c:	10000115 	stw	zero,4(r2)
   m_freem(data);
 90ab580:	e13ffd17 	ldw	r4,-12(fp)
 90ab584:	90aa5a40 	call	90aa5a4 <m_freem>

   if (e < 0)
 90ab588:	e0bff617 	ldw	r2,-40(fp)
 90ab58c:	1004403a 	cmpge	r2,r2,zero
 90ab590:	1000081e 	bne	r2,zero,90ab5b4 <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 90ab594:	e0bff617 	ldw	r2,-40(fp)
 90ab598:	10bffa98 	cmpnei	r2,r2,-22
 90ab59c:	1000021e 	bne	r2,zero,90ab5a8 <ip_output+0x5d0>
         return 0;
 90ab5a0:	e03fff15 	stw	zero,-4(fp)
 90ab5a4:	00000406 	br	90ab5b8 <ip_output+0x5e0>
      return e;
 90ab5a8:	e0bff617 	ldw	r2,-40(fp)
 90ab5ac:	e0bfff15 	stw	r2,-4(fp)
 90ab5b0:	00000106 	br	90ab5b8 <ip_output+0x5e0>
   }
   else
      return 0;
 90ab5b4:	e03fff15 	stw	zero,-4(fp)
 90ab5b8:	e0bfff17 	ldw	r2,-4(fp)
}
 90ab5bc:	e037883a 	mov	sp,fp
 90ab5c0:	dfc00117 	ldw	ra,4(sp)
 90ab5c4:	df000017 	ldw	fp,0(sp)
 90ab5c8:	dec00204 	addi	sp,sp,8
 90ab5cc:	f800283a 	ret

090ab5d0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 90ab5d0:	defffd04 	addi	sp,sp,-12
 90ab5d4:	df000215 	stw	fp,8(sp)
 90ab5d8:	df000204 	addi	fp,sp,8
 90ab5dc:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 90ab5e0:	e0bffe17 	ldw	r2,-8(fp)
 90ab5e4:	10bfffd8 	cmpnei	r2,r2,-1
 90ab5e8:	1000031e 	bne	r2,zero,90ab5f8 <in_broadcast+0x28>
      return TRUE;
 90ab5ec:	00800044 	movi	r2,1
 90ab5f0:	e0bfff15 	stw	r2,-4(fp)
 90ab5f4:	00000106 	br	90ab5fc <in_broadcast+0x2c>

   return FALSE;
 90ab5f8:	e03fff15 	stw	zero,-4(fp)
 90ab5fc:	e0bfff17 	ldw	r2,-4(fp)
}
 90ab600:	e037883a 	mov	sp,fp
 90ab604:	df000017 	ldw	fp,0(sp)
 90ab608:	dec00104 	addi	sp,sp,4
 90ab60c:	f800283a 	ret

090ab610 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 90ab610:	defffb04 	addi	sp,sp,-20
 90ab614:	dfc00415 	stw	ra,16(sp)
 90ab618:	df000315 	stw	fp,12(sp)
 90ab61c:	df000304 	addi	fp,sp,12
 90ab620:	e13ffe15 	stw	r4,-8(fp)
 90ab624:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 90ab628:	e0bffe17 	ldw	r2,-8(fp)
 90ab62c:	10800003 	ldbu	r2,0(r2)
 90ab630:	10803fcc 	andi	r2,r2,255
 90ab634:	108003cc 	andi	r2,r2,15
 90ab638:	1085883a 	add	r2,r2,r2
 90ab63c:	1085883a 	add	r2,r2,r2
 90ab640:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 90ab644:	e0bffd17 	ldw	r2,-12(fp)
 90ab648:	10800550 	cmplti	r2,r2,21
 90ab64c:	1000251e 	bne	r2,zero,90ab6e4 <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 90ab650:	e0bffd17 	ldw	r2,-12(fp)
 90ab654:	10bffb04 	addi	r2,r2,-20
 90ab658:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 90ab65c:	e0bffe17 	ldw	r2,-8(fp)
 90ab660:	10c0008b 	ldhu	r3,2(r2)
 90ab664:	e0bffd17 	ldw	r2,-12(fp)
 90ab668:	1885c83a 	sub	r2,r3,r2
 90ab66c:	1007883a 	mov	r3,r2
 90ab670:	e0bffe17 	ldw	r2,-8(fp)
 90ab674:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 90ab678:	e0bffe17 	ldw	r2,-8(fp)
 90ab67c:	10800003 	ldbu	r2,0(r2)
 90ab680:	1007883a 	mov	r3,r2
 90ab684:	00bffc04 	movi	r2,-16
 90ab688:	1884703a 	and	r2,r3,r2
 90ab68c:	10800154 	ori	r2,r2,5
 90ab690:	1007883a 	mov	r3,r2
 90ab694:	e0bffe17 	ldw	r2,-8(fp)
 90ab698:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 90ab69c:	e0fffe17 	ldw	r3,-8(fp)
 90ab6a0:	e0bffd17 	ldw	r2,-12(fp)
 90ab6a4:	1889883a 	add	r4,r3,r2
 90ab6a8:	e17ffe17 	ldw	r5,-8(fp)
 90ab6ac:	01800504 	movi	r6,20
 90ab6b0:	90823180 	call	9082318 <memmove>
   m->m_len -= ihlen;
 90ab6b4:	e0bfff17 	ldw	r2,-4(fp)
 90ab6b8:	10c00217 	ldw	r3,8(r2)
 90ab6bc:	e0bffd17 	ldw	r2,-12(fp)
 90ab6c0:	1887c83a 	sub	r3,r3,r2
 90ab6c4:	e0bfff17 	ldw	r2,-4(fp)
 90ab6c8:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 90ab6cc:	e0bfff17 	ldw	r2,-4(fp)
 90ab6d0:	10c00317 	ldw	r3,12(r2)
 90ab6d4:	e0bffd17 	ldw	r2,-12(fp)
 90ab6d8:	1887883a 	add	r3,r3,r2
 90ab6dc:	e0bfff17 	ldw	r2,-4(fp)
 90ab6e0:	10c00315 	stw	r3,12(r2)
}
 90ab6e4:	e037883a 	mov	sp,fp
 90ab6e8:	dfc00117 	ldw	ra,4(sp)
 90ab6ec:	df000017 	ldw	fp,0(sp)
 90ab6f0:	dec00204 	addi	sp,sp,8
 90ab6f4:	f800283a 	ret

090ab6f8 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 90ab6f8:	defff304 	addi	sp,sp,-52
 90ab6fc:	dfc00c15 	stw	ra,48(sp)
 90ab700:	df000b15 	stw	fp,44(sp)
 90ab704:	df000b04 	addi	fp,sp,44
 90ab708:	e13ffe15 	stw	r4,-8(fp)
 90ab70c:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 90ab710:	e0bfff17 	ldw	r2,-4(fp)
 90ab714:	10800617 	ldw	r2,24(r2)
 90ab718:	1004d63a 	srli	r2,r2,24
 90ab71c:	10c03fcc 	andi	r3,r2,255
 90ab720:	e0bfff17 	ldw	r2,-4(fp)
 90ab724:	10800617 	ldw	r2,24(r2)
 90ab728:	1004d23a 	srli	r2,r2,8
 90ab72c:	10bfc00c 	andi	r2,r2,65280
 90ab730:	1886b03a 	or	r3,r3,r2
 90ab734:	e0bfff17 	ldw	r2,-4(fp)
 90ab738:	10800617 	ldw	r2,24(r2)
 90ab73c:	10bfc00c 	andi	r2,r2,65280
 90ab740:	1004923a 	slli	r2,r2,8
 90ab744:	1886b03a 	or	r3,r3,r2
 90ab748:	e0bfff17 	ldw	r2,-4(fp)
 90ab74c:	10800617 	ldw	r2,24(r2)
 90ab750:	10803fcc 	andi	r2,r2,255
 90ab754:	1004963a 	slli	r2,r2,24
 90ab758:	1884b03a 	or	r2,r3,r2
 90ab75c:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 90ab760:	e0bfff17 	ldw	r2,-4(fp)
 90ab764:	10800517 	ldw	r2,20(r2)
 90ab768:	1004d63a 	srli	r2,r2,24
 90ab76c:	10c03fcc 	andi	r3,r2,255
 90ab770:	e0bfff17 	ldw	r2,-4(fp)
 90ab774:	10800517 	ldw	r2,20(r2)
 90ab778:	1004d23a 	srli	r2,r2,8
 90ab77c:	10bfc00c 	andi	r2,r2,65280
 90ab780:	1886b03a 	or	r3,r3,r2
 90ab784:	e0bfff17 	ldw	r2,-4(fp)
 90ab788:	10800517 	ldw	r2,20(r2)
 90ab78c:	10bfc00c 	andi	r2,r2,65280
 90ab790:	1004923a 	slli	r2,r2,8
 90ab794:	1886b03a 	or	r3,r3,r2
 90ab798:	e0bfff17 	ldw	r2,-4(fp)
 90ab79c:	10800517 	ldw	r2,20(r2)
 90ab7a0:	10803fcc 	andi	r2,r2,255
 90ab7a4:	1004963a 	slli	r2,r2,24
 90ab7a8:	1884b03a 	or	r2,r3,r2
 90ab7ac:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 90ab7b0:	e0bfff17 	ldw	r2,-4(fp)
 90ab7b4:	10800704 	addi	r2,r2,28
 90ab7b8:	1080000b 	ldhu	r2,0(r2)
 90ab7bc:	10bfffcc 	andi	r2,r2,65535
 90ab7c0:	1004d23a 	srli	r2,r2,8
 90ab7c4:	10803fcc 	andi	r2,r2,255
 90ab7c8:	1009883a 	mov	r4,r2
 90ab7cc:	e0bfff17 	ldw	r2,-4(fp)
 90ab7d0:	10800704 	addi	r2,r2,28
 90ab7d4:	1080000b 	ldhu	r2,0(r2)
 90ab7d8:	10bfffcc 	andi	r2,r2,65535
 90ab7dc:	1004923a 	slli	r2,r2,8
 90ab7e0:	1007883a 	mov	r3,r2
 90ab7e4:	00bfc004 	movi	r2,-256
 90ab7e8:	1884703a 	and	r2,r3,r2
 90ab7ec:	2084b03a 	or	r2,r4,r2
 90ab7f0:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 90ab7f4:	e0bfff17 	ldw	r2,-4(fp)
 90ab7f8:	10800704 	addi	r2,r2,28
 90ab7fc:	10800084 	addi	r2,r2,2
 90ab800:	1080000b 	ldhu	r2,0(r2)
 90ab804:	10bfffcc 	andi	r2,r2,65535
 90ab808:	1004d23a 	srli	r2,r2,8
 90ab80c:	10803fcc 	andi	r2,r2,255
 90ab810:	1009883a 	mov	r4,r2
 90ab814:	e0bfff17 	ldw	r2,-4(fp)
 90ab818:	10800704 	addi	r2,r2,28
 90ab81c:	10800084 	addi	r2,r2,2
 90ab820:	1080000b 	ldhu	r2,0(r2)
 90ab824:	10bfffcc 	andi	r2,r2,65535
 90ab828:	1004923a 	slli	r2,r2,8
 90ab82c:	1007883a 	mov	r3,r2
 90ab830:	00bfc004 	movi	r2,-256
 90ab834:	1884703a 	and	r2,r3,r2
 90ab838:	2084b03a 	or	r2,r4,r2
 90ab83c:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 90ab840:	e0bfff17 	ldw	r2,-4(fp)
 90ab844:	10800043 	ldbu	r2,1(r2)
 90ab848:	10803fcc 	andi	r2,r2,255
 90ab84c:	1080201c 	xori	r2,r2,128
 90ab850:	10bfe004 	addi	r2,r2,-128
 90ab854:	10800120 	cmpeqi	r2,r2,4
 90ab858:	1000721e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 90ab85c:	e0bfff17 	ldw	r2,-4(fp)
 90ab860:	10800443 	ldbu	r2,17(r2)
 90ab864:	10803fcc 	andi	r2,r2,255
 90ab868:	10800198 	cmpnei	r2,r2,6
 90ab86c:	1000241e 	bne	r2,zero,90ab900 <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 90ab870:	e1bffb8b 	ldhu	r6,-18(fp)
 90ab874:	e0bffb0b 	ldhu	r2,-20(fp)
 90ab878:	d8800015 	stw	r2,0(sp)
 90ab87c:	00800044 	movi	r2,1
 90ab880:	d8800115 	stw	r2,4(sp)
 90ab884:	010243b4 	movhi	r4,2318
 90ab888:	21358304 	addi	r4,r4,-10740
 90ab88c:	e17ffc17 	ldw	r5,-16(fp)
 90ab890:	e1fffd17 	ldw	r7,-12(fp)
 90ab894:	90c6fa40 	call	90c6fa4 <in_pcblookup>
 90ab898:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 90ab89c:	e0bffa17 	ldw	r2,-24(fp)
 90ab8a0:	1005003a 	cmpeq	r2,r2,zero
 90ab8a4:	10005f1e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 90ab8a8:	e0bffa17 	ldw	r2,-24(fp)
 90ab8ac:	10800817 	ldw	r2,32(r2)
 90ab8b0:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 90ab8b4:	e0bff917 	ldw	r2,-28(fp)
 90ab8b8:	1005003a 	cmpeq	r2,r2,zero
 90ab8bc:	1000591e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 90ab8c0:	e0bffa17 	ldw	r2,-24(fp)
 90ab8c4:	10800917 	ldw	r2,36(r2)
 90ab8c8:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 90ab8cc:	e0bff817 	ldw	r2,-32(fp)
 90ab8d0:	1005003a 	cmpeq	r2,r2,zero
 90ab8d4:	1000061e 	bne	r2,zero,90ab8f0 <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 90ab8d8:	e0bff817 	ldw	r2,-32(fp)
 90ab8dc:	10800217 	ldw	r2,8(r2)
 90ab8e0:	10800090 	cmplti	r2,r2,2
 90ab8e4:	10004f1e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 90ab8e8:	e13ff817 	ldw	r4,-32(fp)
 90ab8ec:	90b68800 	call	90b6880 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 90ab8f0:	e0fff917 	ldw	r3,-28(fp)
 90ab8f4:	00801bc4 	movi	r2,111
 90ab8f8:	18800615 	stw	r2,24(r3)
 90ab8fc:	00004906 	br	90aba24 <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 90ab900:	e0bfff17 	ldw	r2,-4(fp)
 90ab904:	10800443 	ldbu	r2,17(r2)
 90ab908:	10803fcc 	andi	r2,r2,255
 90ab90c:	10800458 	cmpnei	r2,r2,17
 90ab910:	1000441e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90ab914:	00824374 	movhi	r2,2317
 90ab918:	108c3604 	addi	r2,r2,12504
 90ab91c:	10800017 	ldw	r2,0(r2)
 90ab920:	e0bff715 	stw	r2,-36(fp)
 90ab924:	00002406 	br	90ab9b8 <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 90ab928:	e0bff717 	ldw	r2,-36(fp)
 90ab92c:	1080020b 	ldhu	r2,8(r2)
 90ab930:	10ffffcc 	andi	r3,r2,65535
 90ab934:	e0bffb8b 	ldhu	r2,-18(fp)
 90ab938:	18800526 	beq	r3,r2,90ab950 <so_icmpdu+0x258>
 90ab93c:	e0bff717 	ldw	r2,-36(fp)
 90ab940:	1080020b 	ldhu	r2,8(r2)
 90ab944:	10bfffcc 	andi	r2,r2,65535
 90ab948:	1004c03a 	cmpne	r2,r2,zero
 90ab94c:	1000171e 	bne	r2,zero,90ab9ac <so_icmpdu+0x2b4>
 90ab950:	e0bff717 	ldw	r2,-36(fp)
 90ab954:	11000417 	ldw	r4,16(r2)
 90ab958:	e0bffc17 	ldw	r2,-16(fp)
 90ab95c:	1004d63a 	srli	r2,r2,24
 90ab960:	10c03fcc 	andi	r3,r2,255
 90ab964:	e0bffc17 	ldw	r2,-16(fp)
 90ab968:	1004d23a 	srli	r2,r2,8
 90ab96c:	10bfc00c 	andi	r2,r2,65280
 90ab970:	1886b03a 	or	r3,r3,r2
 90ab974:	e0bffc17 	ldw	r2,-16(fp)
 90ab978:	10bfc00c 	andi	r2,r2,65280
 90ab97c:	1004923a 	slli	r2,r2,8
 90ab980:	1886b03a 	or	r3,r3,r2
 90ab984:	e0bffc17 	ldw	r2,-16(fp)
 90ab988:	10803fcc 	andi	r2,r2,255
 90ab98c:	1004963a 	slli	r2,r2,24
 90ab990:	1884b03a 	or	r2,r3,r2
 90ab994:	2080051e 	bne	r4,r2,90ab9ac <so_icmpdu+0x2b4>
 90ab998:	e0bff717 	ldw	r2,-36(fp)
 90ab99c:	1080018b 	ldhu	r2,6(r2)
 90ab9a0:	10ffffcc 	andi	r3,r2,65535
 90ab9a4:	e0bffb0b 	ldhu	r2,-20(fp)
 90ab9a8:	18800626 	beq	r3,r2,90ab9c4 <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90ab9ac:	e0bff717 	ldw	r2,-36(fp)
 90ab9b0:	10800017 	ldw	r2,0(r2)
 90ab9b4:	e0bff715 	stw	r2,-36(fp)
 90ab9b8:	e0bff717 	ldw	r2,-36(fp)
 90ab9bc:	1004c03a 	cmpne	r2,r2,zero
 90ab9c0:	103fd91e 	bne	r2,zero,90ab928 <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 90ab9c4:	e0bff717 	ldw	r2,-36(fp)
 90ab9c8:	1005003a 	cmpeq	r2,r2,zero
 90ab9cc:	1000151e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 90ab9d0:	e0bff717 	ldw	r2,-36(fp)
 90ab9d4:	10800617 	ldw	r2,24(r2)
 90ab9d8:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 90ab9dc:	e0bff917 	ldw	r2,-28(fp)
 90ab9e0:	10800983 	ldbu	r2,38(r2)
 90ab9e4:	10803fcc 	andi	r2,r2,255
 90ab9e8:	1080201c 	xori	r2,r2,128
 90ab9ec:	10bfe004 	addi	r2,r2,-128
 90ab9f0:	10800098 	cmpnei	r2,r2,2
 90ab9f4:	10000b1e 	bne	r2,zero,90aba24 <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 90ab9f8:	e0fff917 	ldw	r3,-28(fp)
 90ab9fc:	00801bc4 	movi	r2,111
 90aba00:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 90aba04:	e0bff917 	ldw	r2,-28(fp)
 90aba08:	11400a04 	addi	r5,r2,40
 90aba0c:	e13ff917 	ldw	r4,-28(fp)
 90aba10:	90b08f40 	call	90b08f4 <sbwakeup>
      sowwakeup(so);
 90aba14:	e0bff917 	ldw	r2,-28(fp)
 90aba18:	11401204 	addi	r5,r2,72
 90aba1c:	e13ff917 	ldw	r4,-28(fp)
 90aba20:	90b08f40 	call	90b08f4 <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90aba24:	01000084 	movi	r4,2
 90aba28:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 90aba2c:	e13ffe17 	ldw	r4,-8(fp)
 90aba30:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aba34:	01000084 	movi	r4,2
 90aba38:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return;
}
 90aba3c:	e037883a 	mov	sp,fp
 90aba40:	dfc00117 	ldw	ra,4(sp)
 90aba44:	df000017 	ldw	fp,0(sp)
 90aba48:	dec00204 	addi	sp,sp,8
 90aba4c:	f800283a 	ret

090aba50 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 90aba50:	defffe04 	addi	sp,sp,-8
 90aba54:	dfc00115 	stw	ra,4(sp)
 90aba58:	df000015 	stw	fp,0(sp)
 90aba5c:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 90aba60:	d0a0ad17 	ldw	r2,-32076(gp)
 90aba64:	1004c03a 	cmpne	r2,r2,zero
 90aba68:	1000231e 	bne	r2,zero,90abaf8 <tcp_tick+0xa8>
      return;
   in_tcptick++;
 90aba6c:	d0a0ad17 	ldw	r2,-32076(gp)
 90aba70:	10800044 	addi	r2,r2,1
 90aba74:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 90aba78:	0009883a 	mov	r4,zero
 90aba7c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 90aba80:	00824374 	movhi	r2,2317
 90aba84:	108c4204 	addi	r2,r2,12552
 90aba88:	10c00017 	ldw	r3,0(r2)
 90aba8c:	d0a0ac17 	ldw	r2,-32080(gp)
 90aba90:	18801436 	bltu	r3,r2,90abae4 <tcp_tick+0x94>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 90aba94:	90b6aac0 	call	90b6aac <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 90aba98:	00824374 	movhi	r2,2317
 90aba9c:	108c4204 	addi	r2,r2,12552
 90abaa0:	11000017 	ldw	r4,0(r2)
 90abaa4:	908c0380 	call	908c038 <__floatunsidf>
 90abaa8:	100b883a 	mov	r5,r2
 90abaac:	180d883a 	mov	r6,r3
 90abab0:	2809883a 	mov	r4,r5
 90abab4:	300b883a 	mov	r5,r6
 90abab8:	000d883a 	mov	r6,zero
 90ababc:	01d01274 	movhi	r7,16457
 90abac0:	908b5400 	call	908b540 <__adddf3>
 90abac4:	1009883a 	mov	r4,r2
 90abac8:	180b883a 	mov	r5,r3
 90abacc:	2005883a 	mov	r2,r4
 90abad0:	2807883a 	mov	r3,r5
 90abad4:	1009883a 	mov	r4,r2
 90abad8:	180b883a 	mov	r5,r3
 90abadc:	90cade40 	call	90cade4 <__fixunsdfsi>
 90abae0:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 90abae4:	0009883a 	mov	r4,zero
 90abae8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 90abaec:	d0a0ad17 	ldw	r2,-32076(gp)
 90abaf0:	10bfffc4 	addi	r2,r2,-1
 90abaf4:	d0a0ad15 	stw	r2,-32076(gp)
}
 90abaf8:	e037883a 	mov	sp,fp
 90abafc:	dfc00117 	ldw	ra,4(sp)
 90abb00:	df000017 	ldw	fp,0(sp)
 90abb04:	dec00204 	addi	sp,sp,8
 90abb08:	f800283a 	ret

090abb0c <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 90abb0c:	defffc04 	addi	sp,sp,-16
 90abb10:	df000315 	stw	fp,12(sp)
 90abb14:	df000304 	addi	fp,sp,12
 90abb18:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 90abb1c:	00824374 	movhi	r2,2317
 90abb20:	108c6904 	addi	r2,r2,12708
 90abb24:	10800017 	ldw	r2,0(r2)
 90abb28:	e0bffd15 	stw	r2,-12(fp)
 90abb2c:	00000a06 	br	90abb58 <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 90abb30:	e0bffd17 	ldw	r2,-12(fp)
 90abb34:	10c00417 	ldw	r3,16(r2)
 90abb38:	e0bffe17 	ldw	r2,-8(fp)
 90abb3c:	1880031e 	bne	r3,r2,90abb4c <rawip_lookup+0x40>
      return (tmp);
 90abb40:	e0bffd17 	ldw	r2,-12(fp)
 90abb44:	e0bfff15 	stw	r2,-4(fp)
 90abb48:	00000706 	br	90abb68 <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 90abb4c:	e0bffd17 	ldw	r2,-12(fp)
 90abb50:	10800017 	ldw	r2,0(r2)
 90abb54:	e0bffd15 	stw	r2,-12(fp)
 90abb58:	e0bffd17 	ldw	r2,-12(fp)
 90abb5c:	1004c03a 	cmpne	r2,r2,zero
 90abb60:	103ff31e 	bne	r2,zero,90abb30 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 90abb64:	e03fff15 	stw	zero,-4(fp)
 90abb68:	e0bfff17 	ldw	r2,-4(fp)
}
 90abb6c:	e037883a 	mov	sp,fp
 90abb70:	df000017 	ldw	fp,0(sp)
 90abb74:	dec00104 	addi	sp,sp,4
 90abb78:	f800283a 	ret

090abb7c <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 90abb7c:	defff404 	addi	sp,sp,-48
 90abb80:	dfc00b15 	stw	ra,44(sp)
 90abb84:	df000a15 	stw	fp,40(sp)
 90abb88:	df000a04 	addi	fp,sp,40
 90abb8c:	e13ffd15 	stw	r4,-12(fp)
 90abb90:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 90abb94:	e0bffe17 	ldw	r2,-8(fp)
 90abb98:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 90abb9c:	0009883a 	mov	r4,zero
 90abba0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 90abba4:	e0bff717 	ldw	r2,-36(fp)
 90abba8:	10c00a17 	ldw	r3,40(r2)
 90abbac:	e0bffd17 	ldw	r2,-12(fp)
 90abbb0:	10800417 	ldw	r2,16(r2)
 90abbb4:	1887883a 	add	r3,r3,r2
 90abbb8:	e0bff717 	ldw	r2,-36(fp)
 90abbbc:	10800b17 	ldw	r2,44(r2)
 90abbc0:	18800536 	bltu	r3,r2,90abbd8 <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90abbc4:	0009883a 	mov	r4,zero
 90abbc8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90abbcc:	00801a44 	movi	r2,105
 90abbd0:	e0bfff15 	stw	r2,-4(fp)
 90abbd4:	00005806 	br	90abd38 <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 90abbd8:	01000044 	movi	r4,1
 90abbdc:	000b883a 	mov	r5,zero
 90abbe0:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90abbe4:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 90abbe8:	e0bff817 	ldw	r2,-32(fp)
 90abbec:	1004c03a 	cmpne	r2,r2,zero
 90abbf0:	1000051e 	bne	r2,zero,90abc08 <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90abbf4:	0009883a 	mov	r4,zero
 90abbf8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90abbfc:	00801a44 	movi	r2,105
 90abc00:	e0bfff15 	stw	r2,-4(fp)
 90abc04:	00004c06 	br	90abd38 <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 90abc08:	e0fff817 	ldw	r3,-32(fp)
 90abc0c:	e0bffd17 	ldw	r2,-12(fp)
 90abc10:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 90abc14:	e0bffd17 	ldw	r2,-12(fp)
 90abc18:	10c00117 	ldw	r3,4(r2)
 90abc1c:	e0bff817 	ldw	r2,-32(fp)
 90abc20:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 90abc24:	e0bffd17 	ldw	r2,-12(fp)
 90abc28:	10c00217 	ldw	r3,8(r2)
 90abc2c:	e0bff817 	ldw	r2,-32(fp)
 90abc30:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 90abc34:	e0bffd17 	ldw	r2,-12(fp)
 90abc38:	10c00317 	ldw	r3,12(r2)
 90abc3c:	e0bff817 	ldw	r2,-32(fp)
 90abc40:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90abc44:	e0bffd17 	ldw	r2,-12(fp)
 90abc48:	10c00417 	ldw	r3,16(r2)
 90abc4c:	e0bff817 	ldw	r2,-32(fp)
 90abc50:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 90abc54:	e0bff717 	ldw	r2,-36(fp)
 90abc58:	10800417 	ldw	r2,16(r2)
 90abc5c:	1088000c 	andi	r2,r2,8192
 90abc60:	1004c03a 	cmpne	r2,r2,zero
 90abc64:	1000141e 	bne	r2,zero,90abcb8 <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 90abc68:	e0bffd17 	ldw	r2,-12(fp)
 90abc6c:	10800317 	ldw	r2,12(r2)
 90abc70:	10800003 	ldbu	r2,0(r2)
 90abc74:	10803fcc 	andi	r2,r2,255
 90abc78:	108003cc 	andi	r2,r2,15
 90abc7c:	1085883a 	add	r2,r2,r2
 90abc80:	1085883a 	add	r2,r2,r2
 90abc84:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 90abc88:	e0bff817 	ldw	r2,-32(fp)
 90abc8c:	10c00317 	ldw	r3,12(r2)
 90abc90:	e0bff617 	ldw	r2,-40(fp)
 90abc94:	1887883a 	add	r3,r3,r2
 90abc98:	e0bff817 	ldw	r2,-32(fp)
 90abc9c:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 90abca0:	e0bff817 	ldw	r2,-32(fp)
 90abca4:	10c00217 	ldw	r3,8(r2)
 90abca8:	e0bff617 	ldw	r2,-40(fp)
 90abcac:	1887c83a 	sub	r3,r3,r2
 90abcb0:	e0bff817 	ldw	r2,-32(fp)
 90abcb4:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 90abcb8:	e0bffd17 	ldw	r2,-12(fp)
 90abcbc:	10800717 	ldw	r2,28(r2)
 90abcc0:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 90abcc4:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 90abcc8:	00800084 	movi	r2,2
 90abccc:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 90abcd0:	e0bff717 	ldw	r2,-36(fp)
 90abcd4:	11000a04 	addi	r4,r2,40
 90abcd8:	e17ff904 	addi	r5,fp,-28
 90abcdc:	e1bff817 	ldw	r6,-32(fp)
 90abce0:	90b0c400 	call	90b0c40 <sbappendaddr>
 90abce4:	1004c03a 	cmpne	r2,r2,zero
 90abce8:	1000091e 	bne	r2,zero,90abd10 <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 90abcec:	e0bff817 	ldw	r2,-32(fp)
 90abcf0:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 90abcf4:	e13ff817 	ldw	r4,-32(fp)
 90abcf8:	90aa4700 	call	90aa470 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90abcfc:	0009883a 	mov	r4,zero
 90abd00:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90abd04:	00801a44 	movi	r2,105
 90abd08:	e0bfff15 	stw	r2,-4(fp)
 90abd0c:	00000a06 	br	90abd38 <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 90abd10:	e0bff717 	ldw	r2,-36(fp)
 90abd14:	11000a04 	addi	r4,r2,40
 90abd18:	90a4ea40 	call	90a4ea4 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 90abd1c:	e0bff717 	ldw	r2,-36(fp)
 90abd20:	11400a04 	addi	r5,r2,40
 90abd24:	e13ff717 	ldw	r4,-36(fp)
 90abd28:	90b08f40 	call	90b08f4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90abd2c:	0009883a 	mov	r4,zero
 90abd30:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return 0;
 90abd34:	e03fff15 	stw	zero,-4(fp)
 90abd38:	e0bfff17 	ldw	r2,-4(fp)
}
 90abd3c:	e037883a 	mov	sp,fp
 90abd40:	dfc00117 	ldw	ra,4(sp)
 90abd44:	df000017 	ldw	fp,0(sp)
 90abd48:	dec00204 	addi	sp,sp,8
 90abd4c:	f800283a 	ret

090abd50 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90abd50:	deffee04 	addi	sp,sp,-72
 90abd54:	dfc01115 	stw	ra,68(sp)
 90abd58:	df001015 	stw	fp,64(sp)
 90abd5c:	dc000f15 	stw	r16,60(sp)
 90abd60:	df000f04 	addi	fp,sp,60
 90abd64:	e13ffc15 	stw	r4,-16(fp)
 90abd68:	e17ffd15 	stw	r5,-12(fp)
 90abd6c:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 90abd70:	e0bffc17 	ldw	r2,-16(fp)
 90abd74:	10800717 	ldw	r2,28(r2)
 90abd78:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 90abd7c:	e0bff317 	ldw	r2,-52(fp)
 90abd80:	10800468 	cmpgeui	r2,r2,17
 90abd84:	1001e31e 	bne	r2,zero,90ac514 <rawip_usrreq+0x7c4>
 90abd88:	e0bff317 	ldw	r2,-52(fp)
 90abd8c:	1085883a 	add	r2,r2,r2
 90abd90:	1087883a 	add	r3,r2,r2
 90abd94:	008242f4 	movhi	r2,2315
 90abd98:	10af6a04 	addi	r2,r2,-16984
 90abd9c:	1885883a 	add	r2,r3,r2
 90abda0:	10800017 	ldw	r2,0(r2)
 90abda4:	1000683a 	jmp	r2
 90abda8:	090abdec 	andhi	r4,at,10999
 90abdac:	090abe74 	orhi	r4,at,11001
 90abdb0:	090abeb8 	rdprs	r4,at,11002
 90abdb4:	090ac514 	ori	r4,at,11028
 90abdb8:	090abeb8 	rdprs	r4,at,11002
 90abdbc:	090ac514 	ori	r4,at,11028
 90abdc0:	090ac508 	cmpgei	r4,at,11028
 90abdc4:	090ac514 	ori	r4,at,11028
 90abdc8:	090ac508 	cmpgei	r4,at,11028
 90abdcc:	090ac06c 	andhi	r4,at,11009
 90abdd0:	090ac514 	ori	r4,at,11028
 90abdd4:	090ac514 	ori	r4,at,11028
 90abdd8:	090ac514 	ori	r4,at,11028
 90abddc:	090ac514 	ori	r4,at,11028
 90abde0:	090ac514 	ori	r4,at,11028
 90abde4:	090ac45c 	xori	r4,at,11025
 90abde8:	090ac45c 	xori	r4,at,11025
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 90abdec:	e0bffc17 	ldw	r2,-16(fp)
 90abdf0:	10800417 	ldw	r2,16(r2)
 90abdf4:	1108000c 	andi	r4,r2,8192
 90abdf8:	90c272c0 	call	90c272c <ip_raw_maxalloc>
 90abdfc:	1007883a 	mov	r3,r2
 90abe00:	e0bffc17 	ldw	r2,-16(fp)
 90abe04:	10c01315 	stw	r3,76(r2)
 90abe08:	e0bffc17 	ldw	r2,-16(fp)
 90abe0c:	10c01317 	ldw	r3,76(r2)
 90abe10:	e0bffc17 	ldw	r2,-16(fp)
 90abe14:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 90abe18:	e0bffe17 	ldw	r2,-8(fp)
 90abe1c:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90abe20:	0009883a 	mov	r4,zero
 90abe24:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 90abe28:	e13ff503 	ldbu	r4,-44(fp)
 90abe2c:	e0bffc17 	ldw	r2,-16(fp)
 90abe30:	d8800015 	stw	r2,0(sp)
 90abe34:	000b883a 	mov	r5,zero
 90abe38:	000d883a 	mov	r6,zero
 90abe3c:	01c242f4 	movhi	r7,2315
 90abe40:	39eedf04 	addi	r7,r7,-17540
 90abe44:	90c22380 	call	90c2238 <ip_raw_open>
 90abe48:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 90abe4c:	0009883a 	mov	r4,zero
 90abe50:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      if (!ep)
 90abe54:	e0bff817 	ldw	r2,-32(fp)
 90abe58:	1004c03a 	cmpne	r2,r2,zero
 90abe5c:	1000031e 	bne	r2,zero,90abe6c <rawip_usrreq+0x11c>
         return(EINVAL);
 90abe60:	00800584 	movi	r2,22
 90abe64:	e0bfff15 	stw	r2,-4(fp)
 90abe68:	0001ac06 	br	90ac51c <rawip_usrreq+0x7cc>
      return 0;
 90abe6c:	e03fff15 	stw	zero,-4(fp)
 90abe70:	0001aa06 	br	90ac51c <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 90abe74:	e13ffc17 	ldw	r4,-16(fp)
 90abe78:	90abb0c0 	call	90abb0c <rawip_lookup>
 90abe7c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90abe80:	e0bff817 	ldw	r2,-32(fp)
 90abe84:	1004c03a 	cmpne	r2,r2,zero
 90abe88:	1000031e 	bne	r2,zero,90abe98 <rawip_usrreq+0x148>
         return(EINVAL);
 90abe8c:	00800584 	movi	r2,22
 90abe90:	e0bfff15 	stw	r2,-4(fp)
 90abe94:	0001a106 	br	90ac51c <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90abe98:	0009883a 	mov	r4,zero
 90abe9c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 90abea0:	e13ff817 	ldw	r4,-32(fp)
 90abea4:	90c23280 	call	90c2328 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 90abea8:	0009883a 	mov	r4,zero
 90abeac:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      return 0;
 90abeb0:	e03fff15 	stw	zero,-4(fp)
 90abeb4:	00019906 	br	90ac51c <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 90abeb8:	e0bffe17 	ldw	r2,-8(fp)
 90abebc:	1004c03a 	cmpne	r2,r2,zero
 90abec0:	1000031e 	bne	r2,zero,90abed0 <rawip_usrreq+0x180>
         return(EINVAL);
 90abec4:	00800584 	movi	r2,22
 90abec8:	e0bfff15 	stw	r2,-4(fp)
 90abecc:	00019306 	br	90ac51c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 90abed0:	e0bffe17 	ldw	r2,-8(fp)
 90abed4:	10800317 	ldw	r2,12(r2)
 90abed8:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 90abedc:	e0bff917 	ldw	r2,-28(fp)
 90abee0:	1004c03a 	cmpne	r2,r2,zero
 90abee4:	1000031e 	bne	r2,zero,90abef4 <rawip_usrreq+0x1a4>
         return(EINVAL);
 90abee8:	00800584 	movi	r2,22
 90abeec:	e0bfff15 	stw	r2,-4(fp)
 90abef0:	00018a06 	br	90ac51c <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 90abef4:	e0bffe17 	ldw	r2,-8(fp)
 90abef8:	10800217 	ldw	r2,8(r2)
 90abefc:	10800420 	cmpeqi	r2,r2,16
 90abf00:	1000031e 	bne	r2,zero,90abf10 <rawip_usrreq+0x1c0>
         return(EINVAL);
 90abf04:	00800584 	movi	r2,22
 90abf08:	e0bfff15 	stw	r2,-4(fp)
 90abf0c:	00018306 	br	90ac51c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 90abf10:	e13ffc17 	ldw	r4,-16(fp)
 90abf14:	90abb0c0 	call	90abb0c <rawip_lookup>
 90abf18:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90abf1c:	e0bff817 	ldw	r2,-32(fp)
 90abf20:	1004c03a 	cmpne	r2,r2,zero
 90abf24:	1000031e 	bne	r2,zero,90abf34 <rawip_usrreq+0x1e4>
         return(EINVAL);
 90abf28:	00800584 	movi	r2,22
 90abf2c:	e0bfff15 	stw	r2,-4(fp)
 90abf30:	00017a06 	br	90ac51c <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 90abf34:	e0bff317 	ldw	r2,-52(fp)
 90abf38:	10800098 	cmpnei	r2,r2,2
 90abf3c:	1000221e 	bne	r2,zero,90abfc8 <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 90abf40:	e0bff917 	ldw	r2,-28(fp)
 90abf44:	10800117 	ldw	r2,4(r2)
 90abf48:	1004c03a 	cmpne	r2,r2,zero
 90abf4c:	1000021e 	bne	r2,zero,90abf58 <rawip_usrreq+0x208>
         {
            lhost = 0L;
 90abf50:	e03ff615 	stw	zero,-40(fp)
 90abf54:	00001806 	br	90abfb8 <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 90abf58:	e0bff917 	ldw	r2,-28(fp)
 90abf5c:	10800117 	ldw	r2,4(r2)
 90abf60:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90abf64:	008243b4 	movhi	r2,2318
 90abf68:	10b65f04 	addi	r2,r2,-9860
 90abf6c:	10800017 	ldw	r2,0(r2)
 90abf70:	e0bff215 	stw	r2,-56(fp)
 90abf74:	00000706 	br	90abf94 <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 90abf78:	e0bff217 	ldw	r2,-56(fp)
 90abf7c:	10c00a17 	ldw	r3,40(r2)
 90abf80:	e0bff617 	ldw	r2,-40(fp)
 90abf84:	18800626 	beq	r3,r2,90abfa0 <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90abf88:	e0bff217 	ldw	r2,-56(fp)
 90abf8c:	10800017 	ldw	r2,0(r2)
 90abf90:	e0bff215 	stw	r2,-56(fp)
 90abf94:	e0bff217 	ldw	r2,-56(fp)
 90abf98:	1004c03a 	cmpne	r2,r2,zero
 90abf9c:	103ff61e 	bne	r2,zero,90abf78 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 90abfa0:	e0bff217 	ldw	r2,-56(fp)
 90abfa4:	1004c03a 	cmpne	r2,r2,zero
 90abfa8:	1000031e 	bne	r2,zero,90abfb8 <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 90abfac:	00801f44 	movi	r2,125
 90abfb0:	e0bfff15 	stw	r2,-4(fp)
 90abfb4:	00015906 	br	90ac51c <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 90abfb8:	e0fff817 	ldw	r3,-32(fp)
 90abfbc:	e0bff617 	ldw	r2,-40(fp)
 90abfc0:	18800115 	stw	r2,4(r3)
 90abfc4:	00002706 	br	90ac064 <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 90abfc8:	e0bff917 	ldw	r2,-28(fp)
 90abfcc:	10800117 	ldw	r2,4(r2)
 90abfd0:	1004c03a 	cmpne	r2,r2,zero
 90abfd4:	1000021e 	bne	r2,zero,90abfe0 <rawip_usrreq+0x290>
            fhost = 0L;
 90abfd8:	e03ff715 	stw	zero,-36(fp)
 90abfdc:	00000306 	br	90abfec <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 90abfe0:	e0bff917 	ldw	r2,-28(fp)
 90abfe4:	10800117 	ldw	r2,4(r2)
 90abfe8:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 90abfec:	e0fff817 	ldw	r3,-32(fp)
 90abff0:	e0bff717 	ldw	r2,-36(fp)
 90abff4:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 90abff8:	e0bff717 	ldw	r2,-36(fp)
 90abffc:	1005003a 	cmpeq	r2,r2,zero
 90ac000:	10000e1e 	bne	r2,zero,90ac03c <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90ac004:	e0bffc17 	ldw	r2,-16(fp)
 90ac008:	10c0088b 	ldhu	r3,34(r2)
 90ac00c:	00bffcc4 	movi	r2,-13
 90ac010:	1884703a 	and	r2,r3,r2
 90ac014:	1007883a 	mov	r3,r2
 90ac018:	e0bffc17 	ldw	r2,-16(fp)
 90ac01c:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 90ac020:	e0bffc17 	ldw	r2,-16(fp)
 90ac024:	1080088b 	ldhu	r2,34(r2)
 90ac028:	10800094 	ori	r2,r2,2
 90ac02c:	1007883a 	mov	r3,r2
 90ac030:	e0bffc17 	ldw	r2,-16(fp)
 90ac034:	10c0088d 	sth	r3,34(r2)
 90ac038:	00000706 	br	90ac058 <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 90ac03c:	e0bffc17 	ldw	r2,-16(fp)
 90ac040:	10c0088b 	ldhu	r3,34(r2)
 90ac044:	00bfff44 	movi	r2,-3
 90ac048:	1884703a 	and	r2,r3,r2
 90ac04c:	1007883a 	mov	r3,r2
 90ac050:	e0bffc17 	ldw	r2,-16(fp)
 90ac054:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 90ac058:	e0bffc17 	ldw	r2,-16(fp)
 90ac05c:	11000a04 	addi	r4,r2,40
 90ac060:	90b10300 	call	90b1030 <sbflush>
      }
      return 0;
 90ac064:	e03fff15 	stw	zero,-4(fp)
 90ac068:	00012c06 	br	90ac51c <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 90ac06c:	e0bffd17 	ldw	r2,-12(fp)
 90ac070:	1004c03a 	cmpne	r2,r2,zero
 90ac074:	1000031e 	bne	r2,zero,90ac084 <rawip_usrreq+0x334>
         return(EINVAL);
 90ac078:	00800584 	movi	r2,22
 90ac07c:	e0bfff15 	stw	r2,-4(fp)
 90ac080:	00012606 	br	90ac51c <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 90ac084:	e13ffc17 	ldw	r4,-16(fp)
 90ac088:	90abb0c0 	call	90abb0c <rawip_lookup>
 90ac08c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90ac090:	e0bff817 	ldw	r2,-32(fp)
 90ac094:	1004c03a 	cmpne	r2,r2,zero
 90ac098:	1000051e 	bne	r2,zero,90ac0b0 <rawip_usrreq+0x360>
      {
         m_free(m);
 90ac09c:	e13ffd17 	ldw	r4,-12(fp)
 90ac0a0:	90aa4700 	call	90aa470 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 90ac0a4:	00801bc4 	movi	r2,111
 90ac0a8:	e0bfff15 	stw	r2,-4(fp)
 90ac0ac:	00011b06 	br	90ac51c <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 90ac0b0:	e0bffe17 	ldw	r2,-8(fp)
 90ac0b4:	1004c03a 	cmpne	r2,r2,zero
 90ac0b8:	10000d1e 	bne	r2,zero,90ac0f0 <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 90ac0bc:	e0bffc17 	ldw	r2,-16(fp)
 90ac0c0:	1080088b 	ldhu	r2,34(r2)
 90ac0c4:	10bfffcc 	andi	r2,r2,65535
 90ac0c8:	1080008c 	andi	r2,r2,2
 90ac0cc:	1004c03a 	cmpne	r2,r2,zero
 90ac0d0:	1000031e 	bne	r2,zero,90ac0e0 <rawip_usrreq+0x390>
            return (ENOTCONN);
 90ac0d4:	00802004 	movi	r2,128
 90ac0d8:	e0bfff15 	stw	r2,-4(fp)
 90ac0dc:	00010f06 	br	90ac51c <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 90ac0e0:	e0bff817 	ldw	r2,-32(fp)
 90ac0e4:	10800217 	ldw	r2,8(r2)
 90ac0e8:	e0bff715 	stw	r2,-36(fp)
 90ac0ec:	00001706 	br	90ac14c <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 90ac0f0:	e0bffc17 	ldw	r2,-16(fp)
 90ac0f4:	1080088b 	ldhu	r2,34(r2)
 90ac0f8:	10bfffcc 	andi	r2,r2,65535
 90ac0fc:	1080008c 	andi	r2,r2,2
 90ac100:	1005003a 	cmpeq	r2,r2,zero
 90ac104:	1000031e 	bne	r2,zero,90ac114 <rawip_usrreq+0x3c4>
            return (EISCONN);
 90ac108:	00801fc4 	movi	r2,127
 90ac10c:	e0bfff15 	stw	r2,-4(fp)
 90ac110:	00010206 	br	90ac51c <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 90ac114:	e0bffe17 	ldw	r2,-8(fp)
 90ac118:	10800217 	ldw	r2,8(r2)
 90ac11c:	10800420 	cmpeqi	r2,r2,16
 90ac120:	1000041e 	bne	r2,zero,90ac134 <rawip_usrreq+0x3e4>
         {
            dtrap();
 90ac124:	90a94880 	call	90a9488 <dtrap>
            return (EINVAL);
 90ac128:	00800584 	movi	r2,22
 90ac12c:	e0bfff15 	stw	r2,-4(fp)
 90ac130:	0000fa06 	br	90ac51c <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 90ac134:	e0bffe17 	ldw	r2,-8(fp)
 90ac138:	10800317 	ldw	r2,12(r2)
 90ac13c:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 90ac140:	e0bff917 	ldw	r2,-28(fp)
 90ac144:	10800117 	ldw	r2,4(r2)
 90ac148:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 90ac14c:	e0bffd17 	ldw	r2,-12(fp)
 90ac150:	14000217 	ldw	r16,8(r2)
 90ac154:	e0bffc17 	ldw	r2,-16(fp)
 90ac158:	10800417 	ldw	r2,16(r2)
 90ac15c:	1108000c 	andi	r4,r2,8192
 90ac160:	90c272c0 	call	90c272c <ip_raw_maxalloc>
 90ac164:	1400042e 	bgeu	r2,r16,90ac178 <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 90ac168:	90a94880 	call	90a9488 <dtrap>
         return EMSGSIZE;  /* try to recover */
 90ac16c:	00801e84 	movi	r2,122
 90ac170:	e0bfff15 	stw	r2,-4(fp)
 90ac174:	0000e906 	br	90ac51c <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 90ac178:	e0bffd17 	ldw	r2,-12(fp)
 90ac17c:	10800217 	ldw	r2,8(r2)
 90ac180:	1009883a 	mov	r4,r2
 90ac184:	e0bffc17 	ldw	r2,-16(fp)
 90ac188:	10800417 	ldw	r2,16(r2)
 90ac18c:	1148000c 	andi	r5,r2,8192
 90ac190:	90c26200 	call	90c2620 <ip_raw_alloc>
 90ac194:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 90ac198:	e0bffa17 	ldw	r2,-24(fp)
 90ac19c:	1004c03a 	cmpne	r2,r2,zero
 90ac1a0:	1000051e 	bne	r2,zero,90ac1b8 <rawip_usrreq+0x468>
      {
         m_free(m);
 90ac1a4:	e13ffd17 	ldw	r4,-12(fp)
 90ac1a8:	90aa4700 	call	90aa470 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 90ac1ac:	00801a44 	movi	r2,105
 90ac1b0:	e0bfff15 	stw	r2,-4(fp)
 90ac1b4:	0000d906 	br	90ac51c <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 90ac1b8:	e0bffa17 	ldw	r2,-24(fp)
 90ac1bc:	10c00317 	ldw	r3,12(r2)
 90ac1c0:	e0bffd17 	ldw	r2,-12(fp)
 90ac1c4:	11400317 	ldw	r5,12(r2)
 90ac1c8:	e0bffd17 	ldw	r2,-12(fp)
 90ac1cc:	10800217 	ldw	r2,8(r2)
 90ac1d0:	1809883a 	mov	r4,r3
 90ac1d4:	100d883a 	mov	r6,r2
 90ac1d8:	90822780 	call	9082278 <memcpy>
      pkt->nb_plen = m->m_len;
 90ac1dc:	e0bffd17 	ldw	r2,-12(fp)
 90ac1e0:	10c00217 	ldw	r3,8(r2)
 90ac1e4:	e0bffa17 	ldw	r2,-24(fp)
 90ac1e8:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 90ac1ec:	e13ffd17 	ldw	r4,-12(fp)
 90ac1f0:	90aa4700 	call	90aa470 <m_free>
      pkt->fhost = fhost;
 90ac1f4:	e0fffa17 	ldw	r3,-24(fp)
 90ac1f8:	e0bff717 	ldw	r2,-36(fp)
 90ac1fc:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 90ac200:	e0bff717 	ldw	r2,-36(fp)
 90ac204:	10bfffd8 	cmpnei	r2,r2,-1
 90ac208:	10004f1e 	bne	r2,zero,90ac348 <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 90ac20c:	e0bff817 	ldw	r2,-32(fp)
 90ac210:	10800117 	ldw	r2,4(r2)
 90ac214:	1005003a 	cmpeq	r2,r2,zero
 90ac218:	1000111e 	bne	r2,zero,90ac260 <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac21c:	008243b4 	movhi	r2,2318
 90ac220:	10b65f04 	addi	r2,r2,-9860
 90ac224:	10800017 	ldw	r2,0(r2)
 90ac228:	e0bff215 	stw	r2,-56(fp)
 90ac22c:	00000806 	br	90ac250 <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 90ac230:	e0bff217 	ldw	r2,-56(fp)
 90ac234:	10c00a17 	ldw	r3,40(r2)
 90ac238:	e0bff817 	ldw	r2,-32(fp)
 90ac23c:	10800117 	ldw	r2,4(r2)
 90ac240:	18802126 	beq	r3,r2,90ac2c8 <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac244:	e0bff217 	ldw	r2,-56(fp)
 90ac248:	10800017 	ldw	r2,0(r2)
 90ac24c:	e0bff215 	stw	r2,-56(fp)
 90ac250:	e0bff217 	ldw	r2,-56(fp)
 90ac254:	1004c03a 	cmpne	r2,r2,zero
 90ac258:	103ff51e 	bne	r2,zero,90ac230 <rawip_usrreq+0x4e0>
 90ac25c:	00001a06 	br	90ac2c8 <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac260:	008243b4 	movhi	r2,2318
 90ac264:	10b65f04 	addi	r2,r2,-9860
 90ac268:	10800017 	ldw	r2,0(r2)
 90ac26c:	e0bff215 	stw	r2,-56(fp)
 90ac270:	00001206 	br	90ac2bc <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 90ac274:	e0bff217 	ldw	r2,-56(fp)
 90ac278:	10802a17 	ldw	r2,168(r2)
 90ac27c:	1080004c 	andi	r2,r2,1
 90ac280:	10803fcc 	andi	r2,r2,255
 90ac284:	1005003a 	cmpeq	r2,r2,zero
 90ac288:	1000091e 	bne	r2,zero,90ac2b0 <rawip_usrreq+0x560>
 90ac28c:	e0bff217 	ldw	r2,-56(fp)
 90ac290:	10802717 	ldw	r2,156(r2)
 90ac294:	1005003a 	cmpeq	r2,r2,zero
 90ac298:	1000051e 	bne	r2,zero,90ac2b0 <rawip_usrreq+0x560>
 90ac29c:	e0bff217 	ldw	r2,-56(fp)
 90ac2a0:	10802717 	ldw	r2,156(r2)
 90ac2a4:	10800617 	ldw	r2,24(r2)
 90ac2a8:	10800060 	cmpeqi	r2,r2,1
 90ac2ac:	1000061e 	bne	r2,zero,90ac2c8 <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac2b0:	e0bff217 	ldw	r2,-56(fp)
 90ac2b4:	10800017 	ldw	r2,0(r2)
 90ac2b8:	e0bff215 	stw	r2,-56(fp)
 90ac2bc:	e0bff217 	ldw	r2,-56(fp)
 90ac2c0:	1004c03a 	cmpne	r2,r2,zero
 90ac2c4:	103feb1e 	bne	r2,zero,90ac274 <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 90ac2c8:	e0bff217 	ldw	r2,-56(fp)
 90ac2cc:	1004c03a 	cmpne	r2,r2,zero
 90ac2d0:	10001a1e 	bne	r2,zero,90ac33c <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac2d4:	008243b4 	movhi	r2,2318
 90ac2d8:	10b65f04 	addi	r2,r2,-9860
 90ac2dc:	10800017 	ldw	r2,0(r2)
 90ac2e0:	e0bff215 	stw	r2,-56(fp)
 90ac2e4:	00000c06 	br	90ac318 <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 90ac2e8:	e0bff217 	ldw	r2,-56(fp)
 90ac2ec:	10802717 	ldw	r2,156(r2)
 90ac2f0:	1005003a 	cmpeq	r2,r2,zero
 90ac2f4:	1000051e 	bne	r2,zero,90ac30c <rawip_usrreq+0x5bc>
 90ac2f8:	e0bff217 	ldw	r2,-56(fp)
 90ac2fc:	10802717 	ldw	r2,156(r2)
 90ac300:	10800617 	ldw	r2,24(r2)
 90ac304:	10800060 	cmpeqi	r2,r2,1
 90ac308:	1000061e 	bne	r2,zero,90ac324 <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ac30c:	e0bff217 	ldw	r2,-56(fp)
 90ac310:	10800017 	ldw	r2,0(r2)
 90ac314:	e0bff215 	stw	r2,-56(fp)
 90ac318:	e0bff217 	ldw	r2,-56(fp)
 90ac31c:	1004c03a 	cmpne	r2,r2,zero
 90ac320:	103ff11e 	bne	r2,zero,90ac2e8 <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 90ac324:	e0bff217 	ldw	r2,-56(fp)
 90ac328:	1004c03a 	cmpne	r2,r2,zero
 90ac32c:	1000031e 	bne	r2,zero,90ac33c <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 90ac330:	00801f44 	movi	r2,125
 90ac334:	e0bfff15 	stw	r2,-4(fp)
 90ac338:	00007806 	br	90ac51c <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 90ac33c:	e0fffa17 	ldw	r3,-24(fp)
 90ac340:	e0bff217 	ldw	r2,-56(fp)
 90ac344:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 90ac348:	e0bffc17 	ldw	r2,-16(fp)
 90ac34c:	10800317 	ldw	r2,12(r2)
 90ac350:	1005003a 	cmpeq	r2,r2,zero
 90ac354:	1000041e 	bne	r2,zero,90ac368 <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 90ac358:	e0bffc17 	ldw	r2,-16(fp)
 90ac35c:	10c00317 	ldw	r3,12(r2)
 90ac360:	e0bffa17 	ldw	r2,-24(fp)
 90ac364:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 90ac368:	e0bffc17 	ldw	r2,-16(fp)
 90ac36c:	10800417 	ldw	r2,16(r2)
 90ac370:	1088000c 	andi	r2,r2,8192
 90ac374:	1005003a 	cmpeq	r2,r2,zero
 90ac378:	1000081e 	bne	r2,zero,90ac39c <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ac37c:	0009883a 	mov	r4,zero
 90ac380:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 90ac384:	e13ffa17 	ldw	r4,-24(fp)
 90ac388:	90bdf940 	call	90bdf94 <ip_raw_write>
 90ac38c:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90ac390:	0009883a 	mov	r4,zero
 90ac394:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
 90ac398:	00002806 	br	90ac43c <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 90ac39c:	e0bffa17 	ldw	r2,-24(fp)
 90ac3a0:	10800317 	ldw	r2,12(r2)
 90ac3a4:	10bffb04 	addi	r2,r2,-20
 90ac3a8:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 90ac3ac:	e0bff817 	ldw	r2,-32(fp)
 90ac3b0:	10800117 	ldw	r2,4(r2)
 90ac3b4:	1005003a 	cmpeq	r2,r2,zero
 90ac3b8:	1000051e 	bne	r2,zero,90ac3d0 <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 90ac3bc:	e0bff817 	ldw	r2,-32(fp)
 90ac3c0:	10c00117 	ldw	r3,4(r2)
 90ac3c4:	e0bff417 	ldw	r2,-48(fp)
 90ac3c8:	10c00315 	stw	r3,12(r2)
 90ac3cc:	00000e06 	br	90ac408 <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 90ac3d0:	e0bff717 	ldw	r2,-36(fp)
 90ac3d4:	10bfffd8 	cmpnei	r2,r2,-1
 90ac3d8:	1000061e 	bne	r2,zero,90ac3f4 <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 90ac3dc:	e0bffa17 	ldw	r2,-24(fp)
 90ac3e0:	10800617 	ldw	r2,24(r2)
 90ac3e4:	10c00a17 	ldw	r3,40(r2)
 90ac3e8:	e0bff417 	ldw	r2,-48(fp)
 90ac3ec:	10c00315 	stw	r3,12(r2)
 90ac3f0:	00000506 	br	90ac408 <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 90ac3f4:	e13ff717 	ldw	r4,-36(fp)
 90ac3f8:	90beb200 	call	90beb20 <ip_mymach>
 90ac3fc:	1007883a 	mov	r3,r2
 90ac400:	e0bff417 	ldw	r2,-48(fp)
 90ac404:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 90ac408:	e0fff417 	ldw	r3,-48(fp)
 90ac40c:	e0bff717 	ldw	r2,-36(fp)
 90ac410:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ac414:	0009883a 	mov	r4,zero
 90ac418:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 90ac41c:	e0bff817 	ldw	r2,-32(fp)
 90ac420:	10800503 	ldbu	r2,20(r2)
 90ac424:	11003fcc 	andi	r4,r2,255
 90ac428:	e17ffa17 	ldw	r5,-24(fp)
 90ac42c:	90bd99c0 	call	90bd99c <ip_write>
 90ac430:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90ac434:	0009883a 	mov	r4,zero
 90ac438:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 90ac43c:	e0bffb17 	ldw	r2,-20(fp)
 90ac440:	1004403a 	cmpge	r2,r2,zero
 90ac444:	1000031e 	bne	r2,zero,90ac454 <rawip_usrreq+0x704>
         return(e);
 90ac448:	e0bffb17 	ldw	r2,-20(fp)
 90ac44c:	e0bfff15 	stw	r2,-4(fp)
 90ac450:	00003206 	br	90ac51c <rawip_usrreq+0x7cc>
      return 0;
 90ac454:	e03fff15 	stw	zero,-4(fp)
 90ac458:	00003006 	br	90ac51c <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 90ac45c:	e0bffe17 	ldw	r2,-8(fp)
 90ac460:	1004c03a 	cmpne	r2,r2,zero
 90ac464:	1000031e 	bne	r2,zero,90ac474 <rawip_usrreq+0x724>
         return(EINVAL);
 90ac468:	00800584 	movi	r2,22
 90ac46c:	e0bfff15 	stw	r2,-4(fp)
 90ac470:	00002a06 	br	90ac51c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 90ac474:	e0bffe17 	ldw	r2,-8(fp)
 90ac478:	10800317 	ldw	r2,12(r2)
 90ac47c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 90ac480:	e0bff917 	ldw	r2,-28(fp)
 90ac484:	1004c03a 	cmpne	r2,r2,zero
 90ac488:	1000031e 	bne	r2,zero,90ac498 <rawip_usrreq+0x748>
         return(EINVAL);
 90ac48c:	00800584 	movi	r2,22
 90ac490:	e0bfff15 	stw	r2,-4(fp)
 90ac494:	00002106 	br	90ac51c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 90ac498:	e13ffc17 	ldw	r4,-16(fp)
 90ac49c:	90abb0c0 	call	90abb0c <rawip_lookup>
 90ac4a0:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90ac4a4:	e0bff817 	ldw	r2,-32(fp)
 90ac4a8:	1004c03a 	cmpne	r2,r2,zero
 90ac4ac:	1000031e 	bne	r2,zero,90ac4bc <rawip_usrreq+0x76c>
         return(EINVAL);
 90ac4b0:	00800584 	movi	r2,22
 90ac4b4:	e0bfff15 	stw	r2,-4(fp)
 90ac4b8:	00001806 	br	90ac51c <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 90ac4bc:	e0bff917 	ldw	r2,-28(fp)
 90ac4c0:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 90ac4c4:	e0fffe17 	ldw	r3,-8(fp)
 90ac4c8:	00800404 	movi	r2,16
 90ac4cc:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 90ac4d0:	e0bff317 	ldw	r2,-52(fp)
 90ac4d4:	108003d8 	cmpnei	r2,r2,15
 90ac4d8:	1000051e 	bne	r2,zero,90ac4f0 <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 90ac4dc:	e0bff817 	ldw	r2,-32(fp)
 90ac4e0:	10c00117 	ldw	r3,4(r2)
 90ac4e4:	e0bff917 	ldw	r2,-28(fp)
 90ac4e8:	10c00115 	stw	r3,4(r2)
 90ac4ec:	00000406 	br	90ac500 <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 90ac4f0:	e0bff817 	ldw	r2,-32(fp)
 90ac4f4:	10c00217 	ldw	r3,8(r2)
 90ac4f8:	e0bff917 	ldw	r2,-28(fp)
 90ac4fc:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 90ac500:	e03fff15 	stw	zero,-4(fp)
 90ac504:	00000506 	br	90ac51c <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 90ac508:	90a94880 	call	90a9488 <dtrap>
      return 0;
 90ac50c:	e03fff15 	stw	zero,-4(fp)
 90ac510:	00000206 	br	90ac51c <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 90ac514:	008017c4 	movi	r2,95
 90ac518:	e0bfff15 	stw	r2,-4(fp)
 90ac51c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90ac520:	e037883a 	mov	sp,fp
 90ac524:	dfc00217 	ldw	ra,8(sp)
 90ac528:	df000117 	ldw	fp,4(sp)
 90ac52c:	dc000017 	ldw	r16,0(sp)
 90ac530:	dec00304 	addi	sp,sp,12
 90ac534:	f800283a 	ret

090ac538 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 90ac538:	defffc04 	addi	sp,sp,-16
 90ac53c:	dfc00315 	stw	ra,12(sp)
 90ac540:	df000215 	stw	fp,8(sp)
 90ac544:	df000204 	addi	fp,sp,8
 90ac548:	e13ffe15 	stw	r4,-8(fp)
 90ac54c:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 90ac550:	e0bffe17 	ldw	r2,-8(fp)
 90ac554:	10800517 	ldw	r2,20(r2)
 90ac558:	10800098 	cmpnei	r2,r2,2
 90ac55c:	1000041e 	bne	r2,zero,90ac570 <DOMAIN_CHECK+0x38>
 90ac560:	e0bfff17 	ldw	r2,-4(fp)
 90ac564:	10800428 	cmpgeui	r2,r2,16
 90ac568:	1000011e 	bne	r2,zero,90ac570 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 90ac56c:	90a94880 	call	90a9488 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 90ac570:	e037883a 	mov	sp,fp
 90ac574:	dfc00117 	ldw	ra,4(sp)
 90ac578:	df000017 	ldw	fp,0(sp)
 90ac57c:	dec00204 	addi	sp,sp,8
 90ac580:	f800283a 	ret

090ac584 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 90ac584:	defff904 	addi	sp,sp,-28
 90ac588:	dfc00615 	stw	ra,24(sp)
 90ac58c:	df000515 	stw	fp,20(sp)
 90ac590:	df000504 	addi	fp,sp,20
 90ac594:	e13ffc15 	stw	r4,-16(fp)
 90ac598:	e17ffd15 	stw	r5,-12(fp)
 90ac59c:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 90ac5a0:	0009883a 	mov	r4,zero
 90ac5a4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 90ac5a8:	e13ffc17 	ldw	r4,-16(fp)
 90ac5ac:	e17ffd17 	ldw	r5,-12(fp)
 90ac5b0:	e1bffe17 	ldw	r6,-8(fp)
 90ac5b4:	90add340 	call	90add34 <socreate>
 90ac5b8:	e0bffb15 	stw	r2,-20(fp)
 90ac5bc:	e0bffb17 	ldw	r2,-20(fp)
 90ac5c0:	1004c03a 	cmpne	r2,r2,zero
 90ac5c4:	1000051e 	bne	r2,zero,90ac5dc <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ac5c8:	0009883a 	mov	r4,zero
 90ac5cc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90ac5d0:	00bfffc4 	movi	r2,-1
 90ac5d4:	e0bfff15 	stw	r2,-4(fp)
 90ac5d8:	00000806 	br	90ac5fc <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 90ac5dc:	e0bffb17 	ldw	r2,-20(fp)
 90ac5e0:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ac5e4:	0009883a 	mov	r4,zero
 90ac5e8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 90ac5ec:	e0bffb17 	ldw	r2,-20(fp)
 90ac5f0:	1004d0ba 	srli	r2,r2,2
 90ac5f4:	10800804 	addi	r2,r2,32
 90ac5f8:	e0bfff15 	stw	r2,-4(fp)
 90ac5fc:	e0bfff17 	ldw	r2,-4(fp)
}
 90ac600:	e037883a 	mov	sp,fp
 90ac604:	dfc00117 	ldw	ra,4(sp)
 90ac608:	df000017 	ldw	fp,0(sp)
 90ac60c:	dec00204 	addi	sp,sp,8
 90ac610:	f800283a 	ret

090ac614 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 90ac614:	defff104 	addi	sp,sp,-60
 90ac618:	dfc00e15 	stw	ra,56(sp)
 90ac61c:	df000d15 	stw	fp,52(sp)
 90ac620:	df000d04 	addi	fp,sp,52
 90ac624:	e13ffc15 	stw	r4,-16(fp)
 90ac628:	e17ffd15 	stw	r5,-12(fp)
 90ac62c:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 90ac630:	e0bffc17 	ldw	r2,-16(fp)
 90ac634:	10bff804 	addi	r2,r2,-32
 90ac638:	1085883a 	add	r2,r2,r2
 90ac63c:	1085883a 	add	r2,r2,r2
 90ac640:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 90ac644:	008243b4 	movhi	r2,2318
 90ac648:	10b55b04 	addi	r2,r2,-10900
 90ac64c:	e0bff315 	stw	r2,-52(fp)
 90ac650:	00000606 	br	90ac66c <t_bind+0x58>
 90ac654:	e0fff317 	ldw	r3,-52(fp)
 90ac658:	e0bff517 	ldw	r2,-44(fp)
 90ac65c:	18800626 	beq	r3,r2,90ac678 <t_bind+0x64>
 90ac660:	e0bff317 	ldw	r2,-52(fp)
 90ac664:	10800017 	ldw	r2,0(r2)
 90ac668:	e0bff315 	stw	r2,-52(fp)
 90ac66c:	e0bff317 	ldw	r2,-52(fp)
 90ac670:	1004c03a 	cmpne	r2,r2,zero
 90ac674:	103ff71e 	bne	r2,zero,90ac654 <t_bind+0x40>
 90ac678:	e0fff317 	ldw	r3,-52(fp)
 90ac67c:	e0bff517 	ldw	r2,-44(fp)
 90ac680:	18800426 	beq	r3,r2,90ac694 <t_bind+0x80>
 90ac684:	90a94880 	call	90a9488 <dtrap>
 90ac688:	00bfffc4 	movi	r2,-1
 90ac68c:	e0bfff15 	stw	r2,-4(fp)
 90ac690:	00003906 	br	90ac778 <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 90ac694:	e13ff517 	ldw	r4,-44(fp)
 90ac698:	e17ffe17 	ldw	r5,-8(fp)
 90ac69c:	90ac5380 	call	90ac538 <DOMAIN_CHECK>

   so->so_error = 0;
 90ac6a0:	e0bff517 	ldw	r2,-44(fp)
 90ac6a4:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 90ac6a8:	e0bffd17 	ldw	r2,-12(fp)
 90ac6ac:	1004c03a 	cmpne	r2,r2,zero
 90ac6b0:	10000d1e 	bne	r2,zero,90ac6e8 <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 90ac6b4:	e0bff804 	addi	r2,fp,-32
 90ac6b8:	10000015 	stw	zero,0(r2)
 90ac6bc:	10000115 	stw	zero,4(r2)
 90ac6c0:	10000215 	stw	zero,8(r2)
 90ac6c4:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 90ac6c8:	00800404 	movi	r2,16
 90ac6cc:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 90ac6d0:	e0bff517 	ldw	r2,-44(fp)
 90ac6d4:	10800517 	ldw	r2,20(r2)
 90ac6d8:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 90ac6dc:	e0bff804 	addi	r2,fp,-32
 90ac6e0:	e0bff615 	stw	r2,-40(fp)
 90ac6e4:	00000206 	br	90ac6f0 <t_bind+0xdc>
   } else
      sap = addr;
 90ac6e8:	e0bffd17 	ldw	r2,-12(fp)
 90ac6ec:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 90ac6f0:	e13ff617 	ldw	r4,-40(fp)
 90ac6f4:	e17ffe17 	ldw	r5,-8(fp)
 90ac6f8:	01800244 	movi	r6,9
 90ac6fc:	90adc000 	call	90adc00 <sockargs>
 90ac700:	e0bff715 	stw	r2,-36(fp)
 90ac704:	e0bff717 	ldw	r2,-36(fp)
 90ac708:	1004c03a 	cmpne	r2,r2,zero
 90ac70c:	1000061e 	bne	r2,zero,90ac728 <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 90ac710:	e0fff517 	ldw	r3,-44(fp)
 90ac714:	00800304 	movi	r2,12
 90ac718:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ac71c:	00bfffc4 	movi	r2,-1
 90ac720:	e0bfff15 	stw	r2,-4(fp)
 90ac724:	00001406 	br	90ac778 <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90ac728:	0009883a 	mov	r4,zero
 90ac72c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 90ac730:	e13ff517 	ldw	r4,-44(fp)
 90ac734:	e17ff717 	ldw	r5,-36(fp)
 90ac738:	90adf000 	call	90adf00 <sobind>
 90ac73c:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 90ac740:	e13ff717 	ldw	r4,-36(fp)
 90ac744:	90aa5a40 	call	90aa5a4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ac748:	0009883a 	mov	r4,zero
 90ac74c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (err) 
 90ac750:	e0bff417 	ldw	r2,-48(fp)
 90ac754:	1005003a 	cmpeq	r2,r2,zero
 90ac758:	1000061e 	bne	r2,zero,90ac774 <t_bind+0x160>
   {
      so->so_error = err;
 90ac75c:	e0fff517 	ldw	r3,-44(fp)
 90ac760:	e0bff417 	ldw	r2,-48(fp)
 90ac764:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ac768:	00bfffc4 	movi	r2,-1
 90ac76c:	e0bfff15 	stw	r2,-4(fp)
 90ac770:	00000106 	br	90ac778 <t_bind+0x164>
   }
   return 0;
 90ac774:	e03fff15 	stw	zero,-4(fp)
 90ac778:	e0bfff17 	ldw	r2,-4(fp)
}
 90ac77c:	e037883a 	mov	sp,fp
 90ac780:	dfc00117 	ldw	ra,4(sp)
 90ac784:	df000017 	ldw	fp,0(sp)
 90ac788:	dec00204 	addi	sp,sp,8
 90ac78c:	f800283a 	ret

090ac790 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 90ac790:	defff804 	addi	sp,sp,-32
 90ac794:	dfc00715 	stw	ra,28(sp)
 90ac798:	df000615 	stw	fp,24(sp)
 90ac79c:	df000604 	addi	fp,sp,24
 90ac7a0:	e13ffd15 	stw	r4,-12(fp)
 90ac7a4:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 90ac7a8:	e0bffd17 	ldw	r2,-12(fp)
 90ac7ac:	10bff804 	addi	r2,r2,-32
 90ac7b0:	1085883a 	add	r2,r2,r2
 90ac7b4:	1085883a 	add	r2,r2,r2
 90ac7b8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 90ac7bc:	008243b4 	movhi	r2,2318
 90ac7c0:	10b55b04 	addi	r2,r2,-10900
 90ac7c4:	e0bffa15 	stw	r2,-24(fp)
 90ac7c8:	00000606 	br	90ac7e4 <t_listen+0x54>
 90ac7cc:	e0fffa17 	ldw	r3,-24(fp)
 90ac7d0:	e0bffc17 	ldw	r2,-16(fp)
 90ac7d4:	18800626 	beq	r3,r2,90ac7f0 <t_listen+0x60>
 90ac7d8:	e0bffa17 	ldw	r2,-24(fp)
 90ac7dc:	10800017 	ldw	r2,0(r2)
 90ac7e0:	e0bffa15 	stw	r2,-24(fp)
 90ac7e4:	e0bffa17 	ldw	r2,-24(fp)
 90ac7e8:	1004c03a 	cmpne	r2,r2,zero
 90ac7ec:	103ff71e 	bne	r2,zero,90ac7cc <t_listen+0x3c>
 90ac7f0:	e0fffa17 	ldw	r3,-24(fp)
 90ac7f4:	e0bffc17 	ldw	r2,-16(fp)
 90ac7f8:	18800426 	beq	r3,r2,90ac80c <t_listen+0x7c>
 90ac7fc:	90a94880 	call	90a9488 <dtrap>
 90ac800:	00bfffc4 	movi	r2,-1
 90ac804:	e0bfff15 	stw	r2,-4(fp)
 90ac808:	00001406 	br	90ac85c <t_listen+0xcc>
   so->so_error = 0;
 90ac80c:	e0bffc17 	ldw	r2,-16(fp)
 90ac810:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 90ac814:	0009883a 	mov	r4,zero
 90ac818:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 90ac81c:	e13ffc17 	ldw	r4,-16(fp)
 90ac820:	e17ffe17 	ldw	r5,-8(fp)
 90ac824:	90adf5c0 	call	90adf5c <solisten>
 90ac828:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ac82c:	0009883a 	mov	r4,zero
 90ac830:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 90ac834:	e0bffb17 	ldw	r2,-20(fp)
 90ac838:	1005003a 	cmpeq	r2,r2,zero
 90ac83c:	1000061e 	bne	r2,zero,90ac858 <t_listen+0xc8>
   {
      so->so_error = err;
 90ac840:	e0fffc17 	ldw	r3,-16(fp)
 90ac844:	e0bffb17 	ldw	r2,-20(fp)
 90ac848:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ac84c:	00bfffc4 	movi	r2,-1
 90ac850:	e0bfff15 	stw	r2,-4(fp)
 90ac854:	00000106 	br	90ac85c <t_listen+0xcc>
   }
   return 0;
 90ac858:	e03fff15 	stw	zero,-4(fp)
 90ac85c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ac860:	e037883a 	mov	sp,fp
 90ac864:	dfc00117 	ldw	ra,4(sp)
 90ac868:	df000017 	ldw	fp,0(sp)
 90ac86c:	dec00204 	addi	sp,sp,8
 90ac870:	f800283a 	ret

090ac874 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 90ac874:	defff604 	addi	sp,sp,-40
 90ac878:	dfc00915 	stw	ra,36(sp)
 90ac87c:	df000815 	stw	fp,32(sp)
 90ac880:	df000804 	addi	fp,sp,32
 90ac884:	e13ffc15 	stw	r4,-16(fp)
 90ac888:	e17ffd15 	stw	r5,-12(fp)
 90ac88c:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 90ac890:	e0bffc17 	ldw	r2,-16(fp)
 90ac894:	10bff804 	addi	r2,r2,-32
 90ac898:	1085883a 	add	r2,r2,r2
 90ac89c:	1085883a 	add	r2,r2,r2
 90ac8a0:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 90ac8a4:	008243b4 	movhi	r2,2318
 90ac8a8:	10b55b04 	addi	r2,r2,-10900
 90ac8ac:	e0bff915 	stw	r2,-28(fp)
 90ac8b0:	00000606 	br	90ac8cc <t_accept+0x58>
 90ac8b4:	e0fff917 	ldw	r3,-28(fp)
 90ac8b8:	e0bffb17 	ldw	r2,-20(fp)
 90ac8bc:	18800626 	beq	r3,r2,90ac8d8 <t_accept+0x64>
 90ac8c0:	e0bff917 	ldw	r2,-28(fp)
 90ac8c4:	10800017 	ldw	r2,0(r2)
 90ac8c8:	e0bff915 	stw	r2,-28(fp)
 90ac8cc:	e0bff917 	ldw	r2,-28(fp)
 90ac8d0:	1004c03a 	cmpne	r2,r2,zero
 90ac8d4:	103ff71e 	bne	r2,zero,90ac8b4 <t_accept+0x40>
 90ac8d8:	e0fff917 	ldw	r3,-28(fp)
 90ac8dc:	e0bffb17 	ldw	r2,-20(fp)
 90ac8e0:	18800426 	beq	r3,r2,90ac8f4 <t_accept+0x80>
 90ac8e4:	90a94880 	call	90a9488 <dtrap>
 90ac8e8:	00bfffc4 	movi	r2,-1
 90ac8ec:	e0bfff15 	stw	r2,-4(fp)
 90ac8f0:	00008006 	br	90acaf4 <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 90ac8f4:	e0bffe17 	ldw	r2,-8(fp)
 90ac8f8:	11400017 	ldw	r5,0(r2)
 90ac8fc:	e13ffb17 	ldw	r4,-20(fp)
 90ac900:	90ac5380 	call	90ac538 <DOMAIN_CHECK>

   so->so_error = 0;
 90ac904:	e0bffb17 	ldw	r2,-20(fp)
 90ac908:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 90ac90c:	e0bffb17 	ldw	r2,-20(fp)
 90ac910:	10800417 	ldw	r2,16(r2)
 90ac914:	1080008c 	andi	r2,r2,2
 90ac918:	1004c03a 	cmpne	r2,r2,zero
 90ac91c:	1000061e 	bne	r2,zero,90ac938 <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 90ac920:	e0fffb17 	ldw	r3,-20(fp)
 90ac924:	00800584 	movi	r2,22
 90ac928:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ac92c:	00bfffc4 	movi	r2,-1
 90ac930:	e0bfff15 	stw	r2,-4(fp)
 90ac934:	00006f06 	br	90acaf4 <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 90ac938:	e0bffb17 	ldw	r2,-20(fp)
 90ac93c:	1080088b 	ldhu	r2,34(r2)
 90ac940:	10bfffcc 	andi	r2,r2,65535
 90ac944:	1080400c 	andi	r2,r2,256
 90ac948:	1005003a 	cmpeq	r2,r2,zero
 90ac94c:	10000d1e 	bne	r2,zero,90ac984 <t_accept+0x110>
 90ac950:	e0bffb17 	ldw	r2,-20(fp)
 90ac954:	10801e43 	ldbu	r2,121(r2)
 90ac958:	10803fcc 	andi	r2,r2,255
 90ac95c:	1080201c 	xori	r2,r2,128
 90ac960:	10bfe004 	addi	r2,r2,-128
 90ac964:	1004c03a 	cmpne	r2,r2,zero
 90ac968:	1000061e 	bne	r2,zero,90ac984 <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 90ac96c:	e0fffb17 	ldw	r3,-20(fp)
 90ac970:	008002c4 	movi	r2,11
 90ac974:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ac978:	00bfffc4 	movi	r2,-1
 90ac97c:	e0bfff15 	stw	r2,-4(fp)
 90ac980:	00005c06 	br	90acaf4 <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90ac984:	0009883a 	mov	r4,zero
 90ac988:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 90ac98c:	00001206 	br	90ac9d8 <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 90ac990:	e0bffb17 	ldw	r2,-20(fp)
 90ac994:	1080088b 	ldhu	r2,34(r2)
 90ac998:	10bfffcc 	andi	r2,r2,65535
 90ac99c:	1080080c 	andi	r2,r2,32
 90ac9a0:	1005003a 	cmpeq	r2,r2,zero
 90ac9a4:	1000081e 	bne	r2,zero,90ac9c8 <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 90ac9a8:	e0fffb17 	ldw	r3,-20(fp)
 90ac9ac:	00801c44 	movi	r2,113
 90ac9b0:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ac9b4:	0009883a 	mov	r4,zero
 90ac9b8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ac9bc:	00bfffc4 	movi	r2,-1
 90ac9c0:	e0bfff15 	stw	r2,-4(fp)
 90ac9c4:	00004b06 	br	90acaf4 <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 90ac9c8:	e0bffb17 	ldw	r2,-20(fp)
 90ac9cc:	10800904 	addi	r2,r2,36
 90ac9d0:	1009883a 	mov	r4,r2
 90ac9d4:	90a4d040 	call	90a4d04 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 90ac9d8:	e0bffb17 	ldw	r2,-20(fp)
 90ac9dc:	10801e43 	ldbu	r2,121(r2)
 90ac9e0:	10803fcc 	andi	r2,r2,255
 90ac9e4:	1080201c 	xori	r2,r2,128
 90ac9e8:	10bfe004 	addi	r2,r2,-128
 90ac9ec:	1004c03a 	cmpne	r2,r2,zero
 90ac9f0:	1000041e 	bne	r2,zero,90aca04 <t_accept+0x190>
 90ac9f4:	e0bffb17 	ldw	r2,-20(fp)
 90ac9f8:	10800617 	ldw	r2,24(r2)
 90ac9fc:	1005003a 	cmpeq	r2,r2,zero
 90aca00:	103fe31e 	bne	r2,zero,90ac990 <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 90aca04:	e0bffb17 	ldw	r2,-20(fp)
 90aca08:	10800617 	ldw	r2,24(r2)
 90aca0c:	1005003a 	cmpeq	r2,r2,zero
 90aca10:	1000051e 	bne	r2,zero,90aca28 <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90aca14:	0009883a 	mov	r4,zero
 90aca18:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90aca1c:	00bfffc4 	movi	r2,-1
 90aca20:	e0bfff15 	stw	r2,-4(fp)
 90aca24:	00003306 	br	90acaf4 <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90aca28:	01000244 	movi	r4,9
 90aca2c:	01400404 	movi	r5,16
 90aca30:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aca34:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 90aca38:	e0bffa17 	ldw	r2,-24(fp)
 90aca3c:	1004c03a 	cmpne	r2,r2,zero
 90aca40:	1000081e 	bne	r2,zero,90aca64 <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90aca44:	0009883a 	mov	r4,zero
 90aca48:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 90aca4c:	e0fffb17 	ldw	r3,-20(fp)
 90aca50:	00800304 	movi	r2,12
 90aca54:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90aca58:	00bfffc4 	movi	r2,-1
 90aca5c:	e0bfff15 	stw	r2,-4(fp)
 90aca60:	00002406 	br	90acaf4 <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 90aca64:	e0bffb17 	ldw	r2,-20(fp)
 90aca68:	10801d17 	ldw	r2,116(r2)
 90aca6c:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 90aca70:	e13ff817 	ldw	r4,-32(fp)
 90aca74:	01400044 	movi	r5,1
 90aca78:	90b06940 	call	90b0694 <soqremque>
 90aca7c:	1004c03a 	cmpne	r2,r2,zero
 90aca80:	1000031e 	bne	r2,zero,90aca90 <t_accept+0x21c>
         panic("accept");
 90aca84:	01024374 	movhi	r4,2317
 90aca88:	213f5d04 	addi	r4,r4,-652
 90aca8c:	90a438c0 	call	90a438c <panic>
      so = aso;
 90aca90:	e0bff817 	ldw	r2,-32(fp)
 90aca94:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 90aca98:	e13ffb17 	ldw	r4,-20(fp)
 90aca9c:	e17ffa17 	ldw	r5,-24(fp)
 90acaa0:	90ae5340 	call	90ae534 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 90acaa4:	e0bffd17 	ldw	r2,-12(fp)
 90acaa8:	1005003a 	cmpeq	r2,r2,zero
 90acaac:	1000091e 	bne	r2,zero,90acad4 <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 90acab0:	e0bffa17 	ldw	r2,-24(fp)
 90acab4:	11400317 	ldw	r5,12(r2)
 90acab8:	e0bffe17 	ldw	r2,-8(fp)
 90acabc:	10800017 	ldw	r2,0(r2)
 90acac0:	1007883a 	mov	r3,r2
 90acac4:	e0bffd17 	ldw	r2,-12(fp)
 90acac8:	1009883a 	mov	r4,r2
 90acacc:	180d883a 	mov	r6,r3
 90acad0:	90822780 	call	9082278 <memcpy>
   m_freem (nam);
 90acad4:	e13ffa17 	ldw	r4,-24(fp)
 90acad8:	90aa5a40 	call	90aa5a4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90acadc:	0009883a 	mov	r4,zero
 90acae0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 90acae4:	e0bffb17 	ldw	r2,-20(fp)
 90acae8:	1004d0ba 	srli	r2,r2,2
 90acaec:	10800804 	addi	r2,r2,32
 90acaf0:	e0bfff15 	stw	r2,-4(fp)
 90acaf4:	e0bfff17 	ldw	r2,-4(fp)
}
 90acaf8:	e037883a 	mov	sp,fp
 90acafc:	dfc00117 	ldw	ra,4(sp)
 90acb00:	df000017 	ldw	fp,0(sp)
 90acb04:	dec00204 	addi	sp,sp,8
 90acb08:	f800283a 	ret

090acb0c <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 90acb0c:	defff704 	addi	sp,sp,-36
 90acb10:	dfc00815 	stw	ra,32(sp)
 90acb14:	df000715 	stw	fp,28(sp)
 90acb18:	df000704 	addi	fp,sp,28
 90acb1c:	e13ffc15 	stw	r4,-16(fp)
 90acb20:	e17ffd15 	stw	r5,-12(fp)
 90acb24:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 90acb28:	e0bffc17 	ldw	r2,-16(fp)
 90acb2c:	10bff804 	addi	r2,r2,-32
 90acb30:	1085883a 	add	r2,r2,r2
 90acb34:	1085883a 	add	r2,r2,r2
 90acb38:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 90acb3c:	008243b4 	movhi	r2,2318
 90acb40:	10b55b04 	addi	r2,r2,-10900
 90acb44:	e0bff915 	stw	r2,-28(fp)
 90acb48:	00000606 	br	90acb64 <t_connect+0x58>
 90acb4c:	e0fff917 	ldw	r3,-28(fp)
 90acb50:	e0bffb17 	ldw	r2,-20(fp)
 90acb54:	18800626 	beq	r3,r2,90acb70 <t_connect+0x64>
 90acb58:	e0bff917 	ldw	r2,-28(fp)
 90acb5c:	10800017 	ldw	r2,0(r2)
 90acb60:	e0bff915 	stw	r2,-28(fp)
 90acb64:	e0bff917 	ldw	r2,-28(fp)
 90acb68:	1004c03a 	cmpne	r2,r2,zero
 90acb6c:	103ff71e 	bne	r2,zero,90acb4c <t_connect+0x40>
 90acb70:	e0fff917 	ldw	r3,-28(fp)
 90acb74:	e0bffb17 	ldw	r2,-20(fp)
 90acb78:	18800426 	beq	r3,r2,90acb8c <t_connect+0x80>
 90acb7c:	90a94880 	call	90a9488 <dtrap>
 90acb80:	00bfffc4 	movi	r2,-1
 90acb84:	e0bfff15 	stw	r2,-4(fp)
 90acb88:	00008406 	br	90acd9c <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 90acb8c:	e13ffb17 	ldw	r4,-20(fp)
 90acb90:	e17ffe17 	ldw	r5,-8(fp)
 90acb94:	90ac5380 	call	90ac538 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 90acb98:	e0bffb17 	ldw	r2,-20(fp)
 90acb9c:	1080088b 	ldhu	r2,34(r2)
 90acba0:	10bfffcc 	andi	r2,r2,65535
 90acba4:	1080400c 	andi	r2,r2,256
 90acba8:	1005003a 	cmpeq	r2,r2,zero
 90acbac:	10002a1e 	bne	r2,zero,90acc58 <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 90acbb0:	e0bffb17 	ldw	r2,-20(fp)
 90acbb4:	1080088b 	ldhu	r2,34(r2)
 90acbb8:	10bfffcc 	andi	r2,r2,65535
 90acbbc:	1080010c 	andi	r2,r2,4
 90acbc0:	1005003a 	cmpeq	r2,r2,zero
 90acbc4:	1000061e 	bne	r2,zero,90acbe0 <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 90acbc8:	e0fffb17 	ldw	r3,-20(fp)
 90acbcc:	00801dc4 	movi	r2,119
 90acbd0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90acbd4:	00bfffc4 	movi	r2,-1
 90acbd8:	e0bfff15 	stw	r2,-4(fp)
 90acbdc:	00006f06 	br	90acd9c <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 90acbe0:	e0bffb17 	ldw	r2,-20(fp)
 90acbe4:	1080088b 	ldhu	r2,34(r2)
 90acbe8:	10bfffcc 	andi	r2,r2,65535
 90acbec:	1080008c 	andi	r2,r2,2
 90acbf0:	1005003a 	cmpeq	r2,r2,zero
 90acbf4:	1000041e 	bne	r2,zero,90acc08 <t_connect+0xfc>
      {
         so->so_error = 0;
 90acbf8:	e0bffb17 	ldw	r2,-20(fp)
 90acbfc:	10000615 	stw	zero,24(r2)
         return 0;
 90acc00:	e03fff15 	stw	zero,-4(fp)
 90acc04:	00006506 	br	90acd9c <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 90acc08:	e0bffb17 	ldw	r2,-20(fp)
 90acc0c:	1080088b 	ldhu	r2,34(r2)
 90acc10:	10bfffcc 	andi	r2,r2,65535
 90acc14:	1088000c 	andi	r2,r2,8192
 90acc18:	1005003a 	cmpeq	r2,r2,zero
 90acc1c:	10000e1e 	bne	r2,zero,90acc58 <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 90acc20:	e0bffb17 	ldw	r2,-20(fp)
 90acc24:	10c0088b 	ldhu	r3,34(r2)
 90acc28:	00b7ffc4 	movi	r2,-8193
 90acc2c:	1884703a 	and	r2,r3,r2
 90acc30:	1007883a 	mov	r3,r2
 90acc34:	e0bffb17 	ldw	r2,-20(fp)
 90acc38:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 90acc3c:	e0bffb17 	ldw	r2,-20(fp)
 90acc40:	10800617 	ldw	r2,24(r2)
 90acc44:	1005003a 	cmpeq	r2,r2,zero
 90acc48:	1000031e 	bne	r2,zero,90acc58 <t_connect+0x14c>
            return SOCKET_ERROR;
 90acc4c:	00bfffc4 	movi	r2,-1
 90acc50:	e0bfff15 	stw	r2,-4(fp)
 90acc54:	00005106 	br	90acd9c <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 90acc58:	e0bffb17 	ldw	r2,-20(fp)
 90acc5c:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 90acc60:	e13ffd17 	ldw	r4,-12(fp)
 90acc64:	e17ffe17 	ldw	r5,-8(fp)
 90acc68:	01800244 	movi	r6,9
 90acc6c:	90adc000 	call	90adc00 <sockargs>
 90acc70:	e0bffa15 	stw	r2,-24(fp)
 90acc74:	e0bffa17 	ldw	r2,-24(fp)
 90acc78:	1004c03a 	cmpne	r2,r2,zero
 90acc7c:	1000061e 	bne	r2,zero,90acc98 <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 90acc80:	e0fffb17 	ldw	r3,-20(fp)
 90acc84:	00800304 	movi	r2,12
 90acc88:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90acc8c:	00bfffc4 	movi	r2,-1
 90acc90:	e0bfff15 	stw	r2,-4(fp)
 90acc94:	00004106 	br	90acd9c <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 90acc98:	0009883a 	mov	r4,zero
 90acc9c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 90acca0:	e13ffb17 	ldw	r4,-20(fp)
 90acca4:	e17ffa17 	ldw	r5,-24(fp)
 90acca8:	90ae5d00 	call	90ae5d0 <soconnect>
 90accac:	1007883a 	mov	r3,r2
 90accb0:	e0bffb17 	ldw	r2,-20(fp)
 90accb4:	10c00615 	stw	r3,24(r2)
 90accb8:	e0bffb17 	ldw	r2,-20(fp)
 90accbc:	10800617 	ldw	r2,24(r2)
 90accc0:	1004c03a 	cmpne	r2,r2,zero
 90accc4:	10001e1e 	bne	r2,zero,90acd40 <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 90accc8:	e0bffb17 	ldw	r2,-20(fp)
 90acccc:	1080088b 	ldhu	r2,34(r2)
 90accd0:	10bfffcc 	andi	r2,r2,65535
 90accd4:	1080400c 	andi	r2,r2,256
 90accd8:	1005003a 	cmpeq	r2,r2,zero
 90accdc:	10000e1e 	bne	r2,zero,90acd18 <t_connect+0x20c>
 90acce0:	e0bffb17 	ldw	r2,-20(fp)
 90acce4:	1080088b 	ldhu	r2,34(r2)
 90acce8:	10bfffcc 	andi	r2,r2,65535
 90accec:	1080010c 	andi	r2,r2,4
 90accf0:	1005003a 	cmpeq	r2,r2,zero
 90accf4:	1000081e 	bne	r2,zero,90acd18 <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 90accf8:	e0fffb17 	ldw	r3,-20(fp)
 90accfc:	00801dc4 	movi	r2,119
 90acd00:	18800615 	stw	r2,24(r3)
      goto bad;
 90acd04:	00000e06 	br	90acd40 <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 90acd08:	e0bffb17 	ldw	r2,-20(fp)
 90acd0c:	10800904 	addi	r2,r2,36
 90acd10:	1009883a 	mov	r4,r2
 90acd14:	90a4d040 	call	90a4d04 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 90acd18:	e0bffb17 	ldw	r2,-20(fp)
 90acd1c:	1080088b 	ldhu	r2,34(r2)
 90acd20:	10bfffcc 	andi	r2,r2,65535
 90acd24:	1080010c 	andi	r2,r2,4
 90acd28:	1005003a 	cmpeq	r2,r2,zero
 90acd2c:	1000041e 	bne	r2,zero,90acd40 <t_connect+0x234>
 90acd30:	e0bffb17 	ldw	r2,-20(fp)
 90acd34:	10800617 	ldw	r2,24(r2)
 90acd38:	1005003a 	cmpeq	r2,r2,zero
 90acd3c:	103ff21e 	bne	r2,zero,90acd08 <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 90acd40:	e0bffb17 	ldw	r2,-20(fp)
 90acd44:	10800617 	ldw	r2,24(r2)
 90acd48:	10801de0 	cmpeqi	r2,r2,119
 90acd4c:	1000071e 	bne	r2,zero,90acd6c <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 90acd50:	e0bffb17 	ldw	r2,-20(fp)
 90acd54:	10c0088b 	ldhu	r3,34(r2)
 90acd58:	00b7fec4 	movi	r2,-8197
 90acd5c:	1884703a 	and	r2,r3,r2
 90acd60:	1007883a 	mov	r3,r2
 90acd64:	e0bffb17 	ldw	r2,-20(fp)
 90acd68:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 90acd6c:	e13ffa17 	ldw	r4,-24(fp)
 90acd70:	90aa5a40 	call	90aa5a4 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90acd74:	0009883a 	mov	r4,zero
 90acd78:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 90acd7c:	e0bffb17 	ldw	r2,-20(fp)
 90acd80:	10800617 	ldw	r2,24(r2)
 90acd84:	1005003a 	cmpeq	r2,r2,zero
 90acd88:	1000031e 	bne	r2,zero,90acd98 <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 90acd8c:	00bfffc4 	movi	r2,-1
 90acd90:	e0bfff15 	stw	r2,-4(fp)
 90acd94:	00000106 	br	90acd9c <t_connect+0x290>

   }
      return 0;
 90acd98:	e03fff15 	stw	zero,-4(fp)
 90acd9c:	e0bfff17 	ldw	r2,-4(fp)
}
 90acda0:	e037883a 	mov	sp,fp
 90acda4:	dfc00117 	ldw	ra,4(sp)
 90acda8:	df000017 	ldw	fp,0(sp)
 90acdac:	dec00204 	addi	sp,sp,8
 90acdb0:	f800283a 	ret

090acdb4 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 90acdb4:	defffb04 	addi	sp,sp,-20
 90acdb8:	dfc00415 	stw	ra,16(sp)
 90acdbc:	df000315 	stw	fp,12(sp)
 90acdc0:	df000304 	addi	fp,sp,12
 90acdc4:	e13ffd15 	stw	r4,-12(fp)
 90acdc8:	e17ffe15 	stw	r5,-8(fp)
 90acdcc:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 90acdd0:	e13ffd17 	ldw	r4,-12(fp)
 90acdd4:	e17ffe17 	ldw	r5,-8(fp)
 90acdd8:	e1bfff17 	ldw	r6,-4(fp)
 90acddc:	01c00404 	movi	r7,16
 90acde0:	90ace3c0 	call	90ace3c <t_getname>
}
 90acde4:	e037883a 	mov	sp,fp
 90acde8:	dfc00117 	ldw	ra,4(sp)
 90acdec:	df000017 	ldw	fp,0(sp)
 90acdf0:	dec00204 	addi	sp,sp,8
 90acdf4:	f800283a 	ret

090acdf8 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 90acdf8:	defffb04 	addi	sp,sp,-20
 90acdfc:	dfc00415 	stw	ra,16(sp)
 90ace00:	df000315 	stw	fp,12(sp)
 90ace04:	df000304 	addi	fp,sp,12
 90ace08:	e13ffd15 	stw	r4,-12(fp)
 90ace0c:	e17ffe15 	stw	r5,-8(fp)
 90ace10:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 90ace14:	e13ffd17 	ldw	r4,-12(fp)
 90ace18:	e17ffe17 	ldw	r5,-8(fp)
 90ace1c:	e1bfff17 	ldw	r6,-4(fp)
 90ace20:	01c003c4 	movi	r7,15
 90ace24:	90ace3c0 	call	90ace3c <t_getname>
}
 90ace28:	e037883a 	mov	sp,fp
 90ace2c:	dfc00117 	ldw	ra,4(sp)
 90ace30:	df000017 	ldw	fp,0(sp)
 90ace34:	dec00204 	addi	sp,sp,8
 90ace38:	f800283a 	ret

090ace3c <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 90ace3c:	defff504 	addi	sp,sp,-44
 90ace40:	dfc00a15 	stw	ra,40(sp)
 90ace44:	df000915 	stw	fp,36(sp)
 90ace48:	df000904 	addi	fp,sp,36
 90ace4c:	e13ffb15 	stw	r4,-20(fp)
 90ace50:	e17ffc15 	stw	r5,-16(fp)
 90ace54:	e1bffd15 	stw	r6,-12(fp)
 90ace58:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 90ace5c:	e0bffb17 	ldw	r2,-20(fp)
 90ace60:	10bff804 	addi	r2,r2,-32
 90ace64:	1085883a 	add	r2,r2,r2
 90ace68:	1085883a 	add	r2,r2,r2
 90ace6c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ace70:	008243b4 	movhi	r2,2318
 90ace74:	10b55b04 	addi	r2,r2,-10900
 90ace78:	e0bff715 	stw	r2,-36(fp)
 90ace7c:	00000606 	br	90ace98 <t_getname+0x5c>
 90ace80:	e0fff717 	ldw	r3,-36(fp)
 90ace84:	e0bffa17 	ldw	r2,-24(fp)
 90ace88:	18800626 	beq	r3,r2,90acea4 <t_getname+0x68>
 90ace8c:	e0bff717 	ldw	r2,-36(fp)
 90ace90:	10800017 	ldw	r2,0(r2)
 90ace94:	e0bff715 	stw	r2,-36(fp)
 90ace98:	e0bff717 	ldw	r2,-36(fp)
 90ace9c:	1004c03a 	cmpne	r2,r2,zero
 90acea0:	103ff71e 	bne	r2,zero,90ace80 <t_getname+0x44>
 90acea4:	e0fff717 	ldw	r3,-36(fp)
 90acea8:	e0bffa17 	ldw	r2,-24(fp)
 90aceac:	18800426 	beq	r3,r2,90acec0 <t_getname+0x84>
 90aceb0:	90a94880 	call	90a9488 <dtrap>
 90aceb4:	00bfffc4 	movi	r2,-1
 90aceb8:	e0bfff15 	stw	r2,-4(fp)
 90acebc:	00005806 	br	90ad020 <t_getname+0x1e4>

   so->so_error = 0;
 90acec0:	e0bffa17 	ldw	r2,-24(fp)
 90acec4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 90acec8:	e0bffe17 	ldw	r2,-8(fp)
 90acecc:	10800418 	cmpnei	r2,r2,16
 90aced0:	10000c1e 	bne	r2,zero,90acf04 <t_getname+0xc8>
 90aced4:	e0bffa17 	ldw	r2,-24(fp)
 90aced8:	1080088b 	ldhu	r2,34(r2)
 90acedc:	10bfffcc 	andi	r2,r2,65535
 90acee0:	1080008c 	andi	r2,r2,2
 90acee4:	1004c03a 	cmpne	r2,r2,zero
 90acee8:	1000061e 	bne	r2,zero,90acf04 <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 90aceec:	e0fffa17 	ldw	r3,-24(fp)
 90acef0:	00802004 	movi	r2,128
 90acef4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90acef8:	00bfffc4 	movi	r2,-1
 90acefc:	e0bfff15 	stw	r2,-4(fp)
 90acf00:	00004706 	br	90ad020 <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90acf04:	0009883a 	mov	r4,zero
 90acf08:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90acf0c:	01000244 	movi	r4,9
 90acf10:	01400404 	movi	r5,16
 90acf14:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90acf18:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 90acf1c:	e0bff917 	ldw	r2,-28(fp)
 90acf20:	1004c03a 	cmpne	r2,r2,zero
 90acf24:	1000081e 	bne	r2,zero,90acf48 <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 90acf28:	e0fffa17 	ldw	r3,-24(fp)
 90acf2c:	00800304 	movi	r2,12
 90acf30:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90acf34:	0009883a 	mov	r4,zero
 90acf38:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90acf3c:	00bfffc4 	movi	r2,-1
 90acf40:	e0bfff15 	stw	r2,-4(fp)
 90acf44:	00003606 	br	90ad020 <t_getname+0x1e4>
   }
   so->so_req = opcode;
 90acf48:	e0fffa17 	ldw	r3,-24(fp)
 90acf4c:	e0bffe17 	ldw	r2,-8(fp)
 90acf50:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 90acf54:	e0bffa17 	ldw	r2,-24(fp)
 90acf58:	10800217 	ldw	r2,8(r2)
 90acf5c:	10800317 	ldw	r2,12(r2)
 90acf60:	e13ffa17 	ldw	r4,-24(fp)
 90acf64:	000b883a 	mov	r5,zero
 90acf68:	e1bff917 	ldw	r6,-28(fp)
 90acf6c:	103ee83a 	callr	r2
 90acf70:	e0bff815 	stw	r2,-32(fp)
 90acf74:	e0bff817 	ldw	r2,-32(fp)
 90acf78:	1004c03a 	cmpne	r2,r2,zero
 90acf7c:	10001a1e 	bne	r2,zero,90acfe8 <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 90acf80:	e0bffa17 	ldw	r2,-24(fp)
 90acf84:	10800517 	ldw	r2,20(r2)
 90acf88:	10800098 	cmpnei	r2,r2,2
 90acf8c:	1000161e 	bne	r2,zero,90acfe8 <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 90acf90:	e0bffd17 	ldw	r2,-12(fp)
 90acf94:	10800017 	ldw	r2,0(r2)
 90acf98:	10800428 	cmpgeui	r2,r2,16
 90acf9c:	1000081e 	bne	r2,zero,90acfc0 <t_getname+0x184>
      {
         dtrap();    /* programming error */
 90acfa0:	90a94880 	call	90a9488 <dtrap>
         m_freem(m);
 90acfa4:	e13ff917 	ldw	r4,-28(fp)
 90acfa8:	90aa5a40 	call	90aa5a4 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90acfac:	0009883a 	mov	r4,zero
 90acfb0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 90acfb4:	00800584 	movi	r2,22
 90acfb8:	e0bfff15 	stw	r2,-4(fp)
 90acfbc:	00001806 	br	90ad020 <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 90acfc0:	e0bff917 	ldw	r2,-28(fp)
 90acfc4:	10c00317 	ldw	r3,12(r2)
 90acfc8:	e0bffc17 	ldw	r2,-16(fp)
 90acfcc:	1009883a 	mov	r4,r2
 90acfd0:	180b883a 	mov	r5,r3
 90acfd4:	01800404 	movi	r6,16
 90acfd8:	90822780 	call	9082278 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 90acfdc:	e0fffd17 	ldw	r3,-12(fp)
 90acfe0:	00800404 	movi	r2,16
 90acfe4:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 90acfe8:	e13ff917 	ldw	r4,-28(fp)
 90acfec:	90aa5a40 	call	90aa5a4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90acff0:	0009883a 	mov	r4,zero
 90acff4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (err) 
 90acff8:	e0bff817 	ldw	r2,-32(fp)
 90acffc:	1005003a 	cmpeq	r2,r2,zero
 90ad000:	1000061e 	bne	r2,zero,90ad01c <t_getname+0x1e0>
   {
      so->so_error = err;
 90ad004:	e0fffa17 	ldw	r3,-24(fp)
 90ad008:	e0bff817 	ldw	r2,-32(fp)
 90ad00c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad010:	00bfffc4 	movi	r2,-1
 90ad014:	e0bfff15 	stw	r2,-4(fp)
 90ad018:	00000106 	br	90ad020 <t_getname+0x1e4>
   }
   return 0;
 90ad01c:	e03fff15 	stw	zero,-4(fp)
 90ad020:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad024:	e037883a 	mov	sp,fp
 90ad028:	dfc00117 	ldw	ra,4(sp)
 90ad02c:	df000017 	ldw	fp,0(sp)
 90ad030:	dec00204 	addi	sp,sp,8
 90ad034:	f800283a 	ret

090ad038 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 90ad038:	defff604 	addi	sp,sp,-40
 90ad03c:	dfc00915 	stw	ra,36(sp)
 90ad040:	df000815 	stw	fp,32(sp)
 90ad044:	df000804 	addi	fp,sp,32
 90ad048:	e13ffb15 	stw	r4,-20(fp)
 90ad04c:	e17ffc15 	stw	r5,-16(fp)
 90ad050:	e1bffd15 	stw	r6,-12(fp)
 90ad054:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90ad058:	e0bffb17 	ldw	r2,-20(fp)
 90ad05c:	10bff804 	addi	r2,r2,-32
 90ad060:	1085883a 	add	r2,r2,r2
 90ad064:	1085883a 	add	r2,r2,r2
 90ad068:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ad06c:	008243b4 	movhi	r2,2318
 90ad070:	10b55b04 	addi	r2,r2,-10900
 90ad074:	e0bff815 	stw	r2,-32(fp)
 90ad078:	00000606 	br	90ad094 <t_setsockopt+0x5c>
 90ad07c:	e0fff817 	ldw	r3,-32(fp)
 90ad080:	e0bffa17 	ldw	r2,-24(fp)
 90ad084:	18800626 	beq	r3,r2,90ad0a0 <t_setsockopt+0x68>
 90ad088:	e0bff817 	ldw	r2,-32(fp)
 90ad08c:	10800017 	ldw	r2,0(r2)
 90ad090:	e0bff815 	stw	r2,-32(fp)
 90ad094:	e0bff817 	ldw	r2,-32(fp)
 90ad098:	1004c03a 	cmpne	r2,r2,zero
 90ad09c:	103ff71e 	bne	r2,zero,90ad07c <t_setsockopt+0x44>
 90ad0a0:	e0fff817 	ldw	r3,-32(fp)
 90ad0a4:	e0bffa17 	ldw	r2,-24(fp)
 90ad0a8:	18800426 	beq	r3,r2,90ad0bc <t_setsockopt+0x84>
 90ad0ac:	90a94880 	call	90a9488 <dtrap>
 90ad0b0:	00bfffc4 	movi	r2,-1
 90ad0b4:	e0bfff15 	stw	r2,-4(fp)
 90ad0b8:	00005006 	br	90ad1fc <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 90ad0bc:	0009883a 	mov	r4,zero
 90ad0c0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 90ad0c4:	e0bffa17 	ldw	r2,-24(fp)
 90ad0c8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 90ad0cc:	e0bffc17 	ldw	r2,-16(fp)
 90ad0d0:	10800060 	cmpeqi	r2,r2,1
 90ad0d4:	1000101e 	bne	r2,zero,90ad118 <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 90ad0d8:	e13ffa17 	ldw	r4,-24(fp)
 90ad0dc:	e17ffd17 	ldw	r5,-12(fp)
 90ad0e0:	e1bffe17 	ldw	r6,-8(fp)
 90ad0e4:	90af6d80 	call	90af6d8 <sosetopt>
 90ad0e8:	e0bff915 	stw	r2,-28(fp)
 90ad0ec:	e0bff917 	ldw	r2,-28(fp)
 90ad0f0:	1005003a 	cmpeq	r2,r2,zero
 90ad0f4:	10003e1e 	bne	r2,zero,90ad1f0 <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 90ad0f8:	e0fffa17 	ldw	r3,-24(fp)
 90ad0fc:	e0bff917 	ldw	r2,-28(fp)
 90ad100:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ad104:	0009883a 	mov	r4,zero
 90ad108:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ad10c:	00bfffc4 	movi	r2,-1
 90ad110:	e0bfff15 	stw	r2,-4(fp)
 90ad114:	00003906 	br	90ad1fc <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 90ad118:	e0bffa17 	ldw	r2,-24(fp)
 90ad11c:	10801f17 	ldw	r2,124(r2)
 90ad120:	1004c03a 	cmpne	r2,r2,zero
 90ad124:	1000111e 	bne	r2,zero,90ad16c <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 90ad128:	01000104 	movi	r4,4
 90ad12c:	90a9f0c0 	call	90a9f0c <npalloc>
 90ad130:	1007883a 	mov	r3,r2
 90ad134:	e0bffa17 	ldw	r2,-24(fp)
 90ad138:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 90ad13c:	e0bffa17 	ldw	r2,-24(fp)
 90ad140:	10801f17 	ldw	r2,124(r2)
 90ad144:	1004c03a 	cmpne	r2,r2,zero
 90ad148:	1000081e 	bne	r2,zero,90ad16c <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 90ad14c:	e0fffa17 	ldw	r3,-24(fp)
 90ad150:	00800304 	movi	r2,12
 90ad154:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 90ad158:	0009883a 	mov	r4,zero
 90ad15c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 90ad160:	00bfffc4 	movi	r2,-1
 90ad164:	e0bfff15 	stw	r2,-4(fp)
 90ad168:	00002406 	br	90ad1fc <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 90ad16c:	e0bffd17 	ldw	r2,-12(fp)
 90ad170:	10800118 	cmpnei	r2,r2,4
 90ad174:	1000061e 	bne	r2,zero,90ad190 <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 90ad178:	e0bffa17 	ldw	r2,-24(fp)
 90ad17c:	10c01f17 	ldw	r3,124(r2)
 90ad180:	e0bffe17 	ldw	r2,-8(fp)
 90ad184:	10800017 	ldw	r2,0(r2)
 90ad188:	18800045 	stb	r2,1(r3)
 90ad18c:	00001806 	br	90ad1f0 <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 90ad190:	e0bffd17 	ldw	r2,-12(fp)
 90ad194:	108000d8 	cmpnei	r2,r2,3
 90ad198:	1000061e 	bne	r2,zero,90ad1b4 <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 90ad19c:	e0bffa17 	ldw	r2,-24(fp)
 90ad1a0:	10c01f17 	ldw	r3,124(r2)
 90ad1a4:	e0bffe17 	ldw	r2,-8(fp)
 90ad1a8:	10800017 	ldw	r2,0(r2)
 90ad1ac:	18800005 	stb	r2,0(r3)
 90ad1b0:	00000f06 	br	90ad1f0 <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 90ad1b4:	e0bffd17 	ldw	r2,-12(fp)
 90ad1b8:	10800398 	cmpnei	r2,r2,14
 90ad1bc:	1000071e 	bne	r2,zero,90ad1dc <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 90ad1c0:	e0bffa17 	ldw	r2,-24(fp)
 90ad1c4:	10c01f17 	ldw	r3,124(r2)
 90ad1c8:	e0bffe17 	ldw	r2,-8(fp)
 90ad1cc:	10800017 	ldw	r2,0(r2)
 90ad1d0:	10803fcc 	andi	r2,r2,255
 90ad1d4:	18800115 	stw	r2,4(r3)
 90ad1d8:	00000506 	br	90ad1f0 <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ad1dc:	0009883a 	mov	r4,zero
 90ad1e0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ad1e4:	00bfffc4 	movi	r2,-1
 90ad1e8:	e0bfff15 	stw	r2,-4(fp)
 90ad1ec:	00000306 	br	90ad1fc <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 90ad1f0:	0009883a 	mov	r4,zero
 90ad1f4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return 0;
 90ad1f8:	e03fff15 	stw	zero,-4(fp)
 90ad1fc:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad200:	e037883a 	mov	sp,fp
 90ad204:	dfc00117 	ldw	ra,4(sp)
 90ad208:	df000017 	ldw	fp,0(sp)
 90ad20c:	dec00204 	addi	sp,sp,8
 90ad210:	f800283a 	ret

090ad214 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 90ad214:	defff604 	addi	sp,sp,-40
 90ad218:	dfc00915 	stw	ra,36(sp)
 90ad21c:	df000815 	stw	fp,32(sp)
 90ad220:	df000804 	addi	fp,sp,32
 90ad224:	e13ffb15 	stw	r4,-20(fp)
 90ad228:	e17ffc15 	stw	r5,-16(fp)
 90ad22c:	e1bffd15 	stw	r6,-12(fp)
 90ad230:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90ad234:	e0bffb17 	ldw	r2,-20(fp)
 90ad238:	10bff804 	addi	r2,r2,-32
 90ad23c:	1085883a 	add	r2,r2,r2
 90ad240:	1085883a 	add	r2,r2,r2
 90ad244:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ad248:	008243b4 	movhi	r2,2318
 90ad24c:	10b55b04 	addi	r2,r2,-10900
 90ad250:	e0bff815 	stw	r2,-32(fp)
 90ad254:	00000606 	br	90ad270 <t_getsockopt+0x5c>
 90ad258:	e0fff817 	ldw	r3,-32(fp)
 90ad25c:	e0bffa17 	ldw	r2,-24(fp)
 90ad260:	18800626 	beq	r3,r2,90ad27c <t_getsockopt+0x68>
 90ad264:	e0bff817 	ldw	r2,-32(fp)
 90ad268:	10800017 	ldw	r2,0(r2)
 90ad26c:	e0bff815 	stw	r2,-32(fp)
 90ad270:	e0bff817 	ldw	r2,-32(fp)
 90ad274:	1004c03a 	cmpne	r2,r2,zero
 90ad278:	103ff71e 	bne	r2,zero,90ad258 <t_getsockopt+0x44>
 90ad27c:	e0fff817 	ldw	r3,-32(fp)
 90ad280:	e0bffa17 	ldw	r2,-24(fp)
 90ad284:	18800426 	beq	r3,r2,90ad298 <t_getsockopt+0x84>
 90ad288:	90a94880 	call	90a9488 <dtrap>
 90ad28c:	00bfffc4 	movi	r2,-1
 90ad290:	e0bfff15 	stw	r2,-4(fp)
 90ad294:	00004206 	br	90ad3a0 <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 90ad298:	0009883a 	mov	r4,zero
 90ad29c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 90ad2a0:	e0bffc17 	ldw	r2,-16(fp)
 90ad2a4:	10800060 	cmpeqi	r2,r2,1
 90ad2a8:	1000101e 	bne	r2,zero,90ad2ec <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 90ad2ac:	e13ffa17 	ldw	r4,-24(fp)
 90ad2b0:	e17ffd17 	ldw	r5,-12(fp)
 90ad2b4:	e1bffe17 	ldw	r6,-8(fp)
 90ad2b8:	90afb980 	call	90afb98 <sogetopt>
 90ad2bc:	e0bff915 	stw	r2,-28(fp)
 90ad2c0:	e0bff917 	ldw	r2,-28(fp)
 90ad2c4:	1005003a 	cmpeq	r2,r2,zero
 90ad2c8:	1000301e 	bne	r2,zero,90ad38c <t_getsockopt+0x178>
      {
         so->so_error = err;
 90ad2cc:	e0fffa17 	ldw	r3,-24(fp)
 90ad2d0:	e0bff917 	ldw	r2,-28(fp)
 90ad2d4:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ad2d8:	0009883a 	mov	r4,zero
 90ad2dc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ad2e0:	00bfffc4 	movi	r2,-1
 90ad2e4:	e0bfff15 	stw	r2,-4(fp)
 90ad2e8:	00002d06 	br	90ad3a0 <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 90ad2ec:	e0bffd17 	ldw	r2,-12(fp)
 90ad2f0:	10800118 	cmpnei	r2,r2,4
 90ad2f4:	10000f1e 	bne	r2,zero,90ad334 <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 90ad2f8:	e0bffa17 	ldw	r2,-24(fp)
 90ad2fc:	10801f17 	ldw	r2,124(r2)
 90ad300:	1004c03a 	cmpne	r2,r2,zero
 90ad304:	1000041e 	bne	r2,zero,90ad318 <t_getsockopt+0x104>
 90ad308:	e0fffe17 	ldw	r3,-8(fp)
 90ad30c:	00801004 	movi	r2,64
 90ad310:	18800015 	stw	r2,0(r3)
 90ad314:	00001d06 	br	90ad38c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 90ad318:	e0fffe17 	ldw	r3,-8(fp)
 90ad31c:	e0bffa17 	ldw	r2,-24(fp)
 90ad320:	10801f17 	ldw	r2,124(r2)
 90ad324:	10800043 	ldbu	r2,1(r2)
 90ad328:	10803fcc 	andi	r2,r2,255
 90ad32c:	18800015 	stw	r2,0(r3)
 90ad330:	00001606 	br	90ad38c <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 90ad334:	e0bffd17 	ldw	r2,-12(fp)
 90ad338:	108000d8 	cmpnei	r2,r2,3
 90ad33c:	10000e1e 	bne	r2,zero,90ad378 <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 90ad340:	e0bffa17 	ldw	r2,-24(fp)
 90ad344:	10801f17 	ldw	r2,124(r2)
 90ad348:	1004c03a 	cmpne	r2,r2,zero
 90ad34c:	1000031e 	bne	r2,zero,90ad35c <t_getsockopt+0x148>
 90ad350:	e0bffe17 	ldw	r2,-8(fp)
 90ad354:	10000015 	stw	zero,0(r2)
 90ad358:	00000c06 	br	90ad38c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 90ad35c:	e0fffe17 	ldw	r3,-8(fp)
 90ad360:	e0bffa17 	ldw	r2,-24(fp)
 90ad364:	10801f17 	ldw	r2,124(r2)
 90ad368:	10800003 	ldbu	r2,0(r2)
 90ad36c:	10803fcc 	andi	r2,r2,255
 90ad370:	18800015 	stw	r2,0(r3)
 90ad374:	00000506 	br	90ad38c <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ad378:	0009883a 	mov	r4,zero
 90ad37c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ad380:	00bfffc4 	movi	r2,-1
 90ad384:	e0bfff15 	stw	r2,-4(fp)
 90ad388:	00000506 	br	90ad3a0 <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 90ad38c:	e0bffa17 	ldw	r2,-24(fp)
 90ad390:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90ad394:	0009883a 	mov	r4,zero
 90ad398:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return 0;
 90ad39c:	e03fff15 	stw	zero,-4(fp)
 90ad3a0:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad3a4:	e037883a 	mov	sp,fp
 90ad3a8:	dfc00117 	ldw	ra,4(sp)
 90ad3ac:	df000017 	ldw	fp,0(sp)
 90ad3b0:	dec00204 	addi	sp,sp,8
 90ad3b4:	f800283a 	ret

090ad3b8 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 90ad3b8:	defff504 	addi	sp,sp,-44
 90ad3bc:	dfc00a15 	stw	ra,40(sp)
 90ad3c0:	df000915 	stw	fp,36(sp)
 90ad3c4:	df000904 	addi	fp,sp,36
 90ad3c8:	e13ffb15 	stw	r4,-20(fp)
 90ad3cc:	e17ffc15 	stw	r5,-16(fp)
 90ad3d0:	e1bffd15 	stw	r6,-12(fp)
 90ad3d4:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 90ad3d8:	e0bffd17 	ldw	r2,-12(fp)
 90ad3dc:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 90ad3e0:	e0bffb17 	ldw	r2,-20(fp)
 90ad3e4:	10bff804 	addi	r2,r2,-32
 90ad3e8:	1085883a 	add	r2,r2,r2
 90ad3ec:	1085883a 	add	r2,r2,r2
 90ad3f0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 90ad3f4:	e0bffa17 	ldw	r2,-24(fp)
 90ad3f8:	1080088b 	ldhu	r2,34(r2)
 90ad3fc:	10bfffcc 	andi	r2,r2,65535
 90ad400:	1080038c 	andi	r2,r2,14
 90ad404:	108000a0 	cmpeqi	r2,r2,2
 90ad408:	1000061e 	bne	r2,zero,90ad424 <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 90ad40c:	e0fffa17 	ldw	r3,-24(fp)
 90ad410:	00800804 	movi	r2,32
 90ad414:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ad418:	00bfffc4 	movi	r2,-1
 90ad41c:	e0bfff15 	stw	r2,-4(fp)
 90ad420:	00001b06 	br	90ad490 <t_recv+0xd8>
   }
   so->so_error = 0;
 90ad424:	e0bffa17 	ldw	r2,-24(fp)
 90ad428:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 90ad42c:	0009883a 	mov	r4,zero
 90ad430:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 90ad434:	e1fffd04 	addi	r7,fp,-12
 90ad438:	e0bffe17 	ldw	r2,-8(fp)
 90ad43c:	d8800015 	stw	r2,0(sp)
 90ad440:	e13ffa17 	ldw	r4,-24(fp)
 90ad444:	000b883a 	mov	r5,zero
 90ad448:	e1bffc17 	ldw	r6,-16(fp)
 90ad44c:	90aed4c0 	call	90aed4c <soreceive>
 90ad450:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad454:	0009883a 	mov	r4,zero
 90ad458:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if(err)
 90ad45c:	e0bff917 	ldw	r2,-28(fp)
 90ad460:	1005003a 	cmpeq	r2,r2,zero
 90ad464:	1000061e 	bne	r2,zero,90ad480 <t_recv+0xc8>
   {
      so->so_error = err;
 90ad468:	e0fffa17 	ldw	r3,-24(fp)
 90ad46c:	e0bff917 	ldw	r2,-28(fp)
 90ad470:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ad474:	00bfffc4 	movi	r2,-1
 90ad478:	e0bfff15 	stw	r2,-4(fp)
 90ad47c:	00000406 	br	90ad490 <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 90ad480:	e0fffd17 	ldw	r3,-12(fp)
 90ad484:	e0bff817 	ldw	r2,-32(fp)
 90ad488:	10c5c83a 	sub	r2,r2,r3
 90ad48c:	e0bfff15 	stw	r2,-4(fp)
 90ad490:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad494:	e037883a 	mov	sp,fp
 90ad498:	dfc00117 	ldw	ra,4(sp)
 90ad49c:	df000017 	ldw	fp,0(sp)
 90ad4a0:	dec00204 	addi	sp,sp,8
 90ad4a4:	f800283a 	ret

090ad4a8 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 90ad4a8:	defff304 	addi	sp,sp,-52
 90ad4ac:	dfc00c15 	stw	ra,48(sp)
 90ad4b0:	df000b15 	stw	fp,44(sp)
 90ad4b4:	df000b04 	addi	fp,sp,44
 90ad4b8:	e13ffb15 	stw	r4,-20(fp)
 90ad4bc:	e17ffc15 	stw	r5,-16(fp)
 90ad4c0:	e1bffd15 	stw	r6,-12(fp)
 90ad4c4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 90ad4c8:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 90ad4cc:	e0bffd17 	ldw	r2,-12(fp)
 90ad4d0:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 90ad4d4:	e0bffb17 	ldw	r2,-20(fp)
 90ad4d8:	10bff804 	addi	r2,r2,-32
 90ad4dc:	1085883a 	add	r2,r2,r2
 90ad4e0:	1085883a 	add	r2,r2,r2
 90ad4e4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 90ad4e8:	008243b4 	movhi	r2,2318
 90ad4ec:	10b55b04 	addi	r2,r2,-10900
 90ad4f0:	e0bff615 	stw	r2,-40(fp)
 90ad4f4:	00000606 	br	90ad510 <t_recvfrom+0x68>
 90ad4f8:	e0fff617 	ldw	r3,-40(fp)
 90ad4fc:	e0bff917 	ldw	r2,-28(fp)
 90ad500:	18800626 	beq	r3,r2,90ad51c <t_recvfrom+0x74>
 90ad504:	e0bff617 	ldw	r2,-40(fp)
 90ad508:	10800017 	ldw	r2,0(r2)
 90ad50c:	e0bff615 	stw	r2,-40(fp)
 90ad510:	e0bff617 	ldw	r2,-40(fp)
 90ad514:	1004c03a 	cmpne	r2,r2,zero
 90ad518:	103ff71e 	bne	r2,zero,90ad4f8 <t_recvfrom+0x50>
 90ad51c:	e0fff617 	ldw	r3,-40(fp)
 90ad520:	e0bff917 	ldw	r2,-28(fp)
 90ad524:	18800426 	beq	r3,r2,90ad538 <t_recvfrom+0x90>
 90ad528:	90a94880 	call	90a9488 <dtrap>
 90ad52c:	00bfffc4 	movi	r2,-1
 90ad530:	e0bfff15 	stw	r2,-4(fp)
 90ad534:	00002a06 	br	90ad5e0 <t_recvfrom+0x138>
   so->so_error = 0;
 90ad538:	e0bff917 	ldw	r2,-28(fp)
 90ad53c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 90ad540:	0009883a 	mov	r4,zero
 90ad544:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 90ad548:	e17ffa04 	addi	r5,fp,-24
 90ad54c:	e1fffd04 	addi	r7,fp,-12
 90ad550:	e0bffe17 	ldw	r2,-8(fp)
 90ad554:	d8800015 	stw	r2,0(sp)
 90ad558:	e13ff917 	ldw	r4,-28(fp)
 90ad55c:	e1bffc17 	ldw	r6,-16(fp)
 90ad560:	90aed4c0 	call	90aed4c <soreceive>
 90ad564:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 90ad568:	e0bffa17 	ldw	r2,-24(fp)
 90ad56c:	1005003a 	cmpeq	r2,r2,zero
 90ad570:	10000c1e 	bne	r2,zero,90ad5a4 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 90ad574:	e0bffa17 	ldw	r2,-24(fp)
 90ad578:	10800317 	ldw	r2,12(r2)
 90ad57c:	100b883a 	mov	r5,r2
 90ad580:	e0800317 	ldw	r2,12(fp)
 90ad584:	10800017 	ldw	r2,0(r2)
 90ad588:	1007883a 	mov	r3,r2
 90ad58c:	e0800217 	ldw	r2,8(fp)
 90ad590:	1009883a 	mov	r4,r2
 90ad594:	180d883a 	mov	r6,r3
 90ad598:	90822780 	call	9082278 <memcpy>
      m_freem (sender);
 90ad59c:	e13ffa17 	ldw	r4,-24(fp)
 90ad5a0:	90aa5a40 	call	90aa5a4 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad5a4:	0009883a 	mov	r4,zero
 90ad5a8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if(err)
 90ad5ac:	e0bff817 	ldw	r2,-32(fp)
 90ad5b0:	1005003a 	cmpeq	r2,r2,zero
 90ad5b4:	1000061e 	bne	r2,zero,90ad5d0 <t_recvfrom+0x128>
   {
      so->so_error = err;
 90ad5b8:	e0fff917 	ldw	r3,-28(fp)
 90ad5bc:	e0bff817 	ldw	r2,-32(fp)
 90ad5c0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad5c4:	00bfffc4 	movi	r2,-1
 90ad5c8:	e0bfff15 	stw	r2,-4(fp)
 90ad5cc:	00000406 	br	90ad5e0 <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 90ad5d0:	e0fffd17 	ldw	r3,-12(fp)
 90ad5d4:	e0bff717 	ldw	r2,-36(fp)
 90ad5d8:	10c5c83a 	sub	r2,r2,r3
 90ad5dc:	e0bfff15 	stw	r2,-4(fp)
 90ad5e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad5e4:	e037883a 	mov	sp,fp
 90ad5e8:	dfc00117 	ldw	ra,4(sp)
 90ad5ec:	df000017 	ldw	fp,0(sp)
 90ad5f0:	dec00204 	addi	sp,sp,8
 90ad5f4:	f800283a 	ret

090ad5f8 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 90ad5f8:	defff204 	addi	sp,sp,-56
 90ad5fc:	dfc00d15 	stw	ra,52(sp)
 90ad600:	df000c15 	stw	fp,48(sp)
 90ad604:	df000c04 	addi	fp,sp,48
 90ad608:	e13ffa15 	stw	r4,-24(fp)
 90ad60c:	e17ffb15 	stw	r5,-20(fp)
 90ad610:	e1bffc15 	stw	r6,-16(fp)
 90ad614:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 90ad618:	e0bffa17 	ldw	r2,-24(fp)
 90ad61c:	10bff804 	addi	r2,r2,-32
 90ad620:	1085883a 	add	r2,r2,r2
 90ad624:	1085883a 	add	r2,r2,r2
 90ad628:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 90ad62c:	008243b4 	movhi	r2,2318
 90ad630:	10b55b04 	addi	r2,r2,-10900
 90ad634:	e0bff515 	stw	r2,-44(fp)
 90ad638:	00000606 	br	90ad654 <t_sendto+0x5c>
 90ad63c:	e0fff517 	ldw	r3,-44(fp)
 90ad640:	e0bff817 	ldw	r2,-32(fp)
 90ad644:	18800626 	beq	r3,r2,90ad660 <t_sendto+0x68>
 90ad648:	e0bff517 	ldw	r2,-44(fp)
 90ad64c:	10800017 	ldw	r2,0(r2)
 90ad650:	e0bff515 	stw	r2,-44(fp)
 90ad654:	e0bff517 	ldw	r2,-44(fp)
 90ad658:	1004c03a 	cmpne	r2,r2,zero
 90ad65c:	103ff71e 	bne	r2,zero,90ad63c <t_sendto+0x44>
 90ad660:	e0fff517 	ldw	r3,-44(fp)
 90ad664:	e0bff817 	ldw	r2,-32(fp)
 90ad668:	18800426 	beq	r3,r2,90ad67c <t_sendto+0x84>
 90ad66c:	90a94880 	call	90a9488 <dtrap>
 90ad670:	00bfffc4 	movi	r2,-1
 90ad674:	e0bfff15 	stw	r2,-4(fp)
 90ad678:	00006406 	br	90ad80c <t_sendto+0x214>
   so->so_error = 0;
 90ad67c:	e0bff817 	ldw	r2,-32(fp)
 90ad680:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 90ad684:	e0bff817 	ldw	r2,-32(fp)
 90ad688:	10800983 	ldbu	r2,38(r2)
 90ad68c:	10803fcc 	andi	r2,r2,255
 90ad690:	1080201c 	xori	r2,r2,128
 90ad694:	10bfe004 	addi	r2,r2,-128
 90ad698:	e0bffe15 	stw	r2,-8(fp)
 90ad69c:	e0fffe17 	ldw	r3,-8(fp)
 90ad6a0:	188000a0 	cmpeqi	r2,r3,2
 90ad6a4:	10000e1e 	bne	r2,zero,90ad6e0 <t_sendto+0xe8>
 90ad6a8:	e0fffe17 	ldw	r3,-8(fp)
 90ad6ac:	188000e0 	cmpeqi	r2,r3,3
 90ad6b0:	10000e1e 	bne	r2,zero,90ad6ec <t_sendto+0xf4>
 90ad6b4:	e0fffe17 	ldw	r3,-8(fp)
 90ad6b8:	18800060 	cmpeqi	r2,r3,1
 90ad6bc:	1000011e 	bne	r2,zero,90ad6c4 <t_sendto+0xcc>
 90ad6c0:	00001006 	br	90ad704 <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 90ad6c4:	e13ffa17 	ldw	r4,-24(fp)
 90ad6c8:	e17ffb17 	ldw	r5,-20(fp)
 90ad6cc:	e1bffc17 	ldw	r6,-16(fp)
 90ad6d0:	e1fffd17 	ldw	r7,-12(fp)
 90ad6d4:	90ad8240 	call	90ad824 <t_send>
 90ad6d8:	e0bfff15 	stw	r2,-4(fp)
 90ad6dc:	00004b06 	br	90ad80c <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 90ad6e0:	90c3c480 	call	90c3c48 <udp_maxalloc>
 90ad6e4:	e0bff915 	stw	r2,-28(fp)
      break;
 90ad6e8:	00000d06 	br	90ad720 <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 90ad6ec:	e0bff817 	ldw	r2,-32(fp)
 90ad6f0:	10800417 	ldw	r2,16(r2)
 90ad6f4:	1108000c 	andi	r4,r2,8192
 90ad6f8:	90c272c0 	call	90c272c <ip_raw_maxalloc>
 90ad6fc:	e0bff915 	stw	r2,-28(fp)
      break;
 90ad700:	00000706 	br	90ad720 <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 90ad704:	90a94880 	call	90a9488 <dtrap>
      so->so_error = EFAULT;
 90ad708:	e0fff817 	ldw	r3,-32(fp)
 90ad70c:	00800384 	movi	r2,14
 90ad710:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad714:	00bfffc4 	movi	r2,-1
 90ad718:	e0bfff15 	stw	r2,-4(fp)
 90ad71c:	00003b06 	br	90ad80c <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 90ad720:	e0fff917 	ldw	r3,-28(fp)
 90ad724:	e0bffc17 	ldw	r2,-16(fp)
 90ad728:	1880060e 	bge	r3,r2,90ad744 <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 90ad72c:	e0fff817 	ldw	r3,-32(fp)
 90ad730:	00801e84 	movi	r2,122
 90ad734:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad738:	00ffffc4 	movi	r3,-1
 90ad73c:	e0ffff15 	stw	r3,-4(fp)
 90ad740:	00003206 	br	90ad80c <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 90ad744:	e0800217 	ldw	r2,8(fp)
 90ad748:	1005003a 	cmpeq	r2,r2,zero
 90ad74c:	10000e1e 	bne	r2,zero,90ad788 <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 90ad750:	e1000217 	ldw	r4,8(fp)
 90ad754:	e1400317 	ldw	r5,12(fp)
 90ad758:	01800244 	movi	r6,9
 90ad75c:	90adc000 	call	90adc00 <sockargs>
 90ad760:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 90ad764:	e0bff617 	ldw	r2,-40(fp)
 90ad768:	1004c03a 	cmpne	r2,r2,zero
 90ad76c:	1000071e 	bne	r2,zero,90ad78c <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 90ad770:	e0fff817 	ldw	r3,-32(fp)
 90ad774:	00800304 	movi	r2,12
 90ad778:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90ad77c:	00bfffc4 	movi	r2,-1
 90ad780:	e0bfff15 	stw	r2,-4(fp)
 90ad784:	00002106 	br	90ad80c <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 90ad788:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 90ad78c:	e0bffc17 	ldw	r2,-16(fp)
 90ad790:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 90ad794:	0009883a 	mov	r4,zero
 90ad798:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 90ad79c:	e1fff904 	addi	r7,fp,-28
 90ad7a0:	e0bffd17 	ldw	r2,-12(fp)
 90ad7a4:	d8800015 	stw	r2,0(sp)
 90ad7a8:	e13ff817 	ldw	r4,-32(fp)
 90ad7ac:	e17ff617 	ldw	r5,-40(fp)
 90ad7b0:	e1bffb17 	ldw	r6,-20(fp)
 90ad7b4:	90ae7440 	call	90ae744 <sosend>
 90ad7b8:	e0bff715 	stw	r2,-36(fp)

   if (name)
 90ad7bc:	e0bff617 	ldw	r2,-40(fp)
 90ad7c0:	1005003a 	cmpeq	r2,r2,zero
 90ad7c4:	1000021e 	bne	r2,zero,90ad7d0 <t_sendto+0x1d8>
      m_freem(name);
 90ad7c8:	e13ff617 	ldw	r4,-40(fp)
 90ad7cc:	90aa5a40 	call	90aa5a4 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad7d0:	0009883a 	mov	r4,zero
 90ad7d4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 90ad7d8:	e0bff717 	ldw	r2,-36(fp)
 90ad7dc:	1005003a 	cmpeq	r2,r2,zero
 90ad7e0:	1000061e 	bne	r2,zero,90ad7fc <t_sendto+0x204>
   {
      so->so_error = err;
 90ad7e4:	e0fff817 	ldw	r3,-32(fp)
 90ad7e8:	e0bff717 	ldw	r2,-36(fp)
 90ad7ec:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad7f0:	00ffffc4 	movi	r3,-1
 90ad7f4:	e0ffff15 	stw	r3,-4(fp)
 90ad7f8:	00000406 	br	90ad80c <t_sendto+0x214>
   }

   return (len - sendlen);
 90ad7fc:	e0fff917 	ldw	r3,-28(fp)
 90ad800:	e0bffc17 	ldw	r2,-16(fp)
 90ad804:	10c5c83a 	sub	r2,r2,r3
 90ad808:	e0bfff15 	stw	r2,-4(fp)
 90ad80c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad810:	e037883a 	mov	sp,fp
 90ad814:	dfc00117 	ldw	ra,4(sp)
 90ad818:	df000017 	ldw	fp,0(sp)
 90ad81c:	dec00204 	addi	sp,sp,8
 90ad820:	f800283a 	ret

090ad824 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 90ad824:	defff004 	addi	sp,sp,-64
 90ad828:	dfc00f15 	stw	ra,60(sp)
 90ad82c:	df000e15 	stw	fp,56(sp)
 90ad830:	df000e04 	addi	fp,sp,56
 90ad834:	e13ffb15 	stw	r4,-20(fp)
 90ad838:	e17ffc15 	stw	r5,-16(fp)
 90ad83c:	e1bffd15 	stw	r6,-12(fp)
 90ad840:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 90ad844:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 90ad848:	e0bffb17 	ldw	r2,-20(fp)
 90ad84c:	10bff804 	addi	r2,r2,-32
 90ad850:	1085883a 	add	r2,r2,r2
 90ad854:	1085883a 	add	r2,r2,r2
 90ad858:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 90ad85c:	e0bff917 	ldw	r2,-28(fp)
 90ad860:	1080088b 	ldhu	r2,34(r2)
 90ad864:	10bfffcc 	andi	r2,r2,65535
 90ad868:	1080038c 	andi	r2,r2,14
 90ad86c:	108000a0 	cmpeqi	r2,r2,2
 90ad870:	1000061e 	bne	r2,zero,90ad88c <t_send+0x68>
   {
      so->so_error = EPIPE;
 90ad874:	e0fff917 	ldw	r3,-28(fp)
 90ad878:	00800804 	movi	r2,32
 90ad87c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad880:	00bfffc4 	movi	r2,-1
 90ad884:	e0bfff15 	stw	r2,-4(fp)
 90ad888:	00006a06 	br	90ada34 <t_send+0x210>
   }
   so->so_error = 0;
 90ad88c:	e0bff917 	ldw	r2,-28(fp)
 90ad890:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 90ad894:	e0bff917 	ldw	r2,-28(fp)
 90ad898:	10800983 	ldbu	r2,38(r2)
 90ad89c:	10803fcc 	andi	r2,r2,255
 90ad8a0:	1080201c 	xori	r2,r2,128
 90ad8a4:	10bfe004 	addi	r2,r2,-128
 90ad8a8:	10800060 	cmpeqi	r2,r2,1
 90ad8ac:	1000091e 	bne	r2,zero,90ad8d4 <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 90ad8b0:	d8000015 	stw	zero,0(sp)
 90ad8b4:	d8000115 	stw	zero,4(sp)
 90ad8b8:	e13ffb17 	ldw	r4,-20(fp)
 90ad8bc:	e17ffc17 	ldw	r5,-16(fp)
 90ad8c0:	e1bffd17 	ldw	r6,-12(fp)
 90ad8c4:	e1fffe17 	ldw	r7,-8(fp)
 90ad8c8:	90ad5f80 	call	90ad5f8 <t_sendto>
 90ad8cc:	e0bfff15 	stw	r2,-4(fp)
 90ad8d0:	00005806 	br	90ada34 <t_send+0x210>

   maxpkt = TCP_MSS;
 90ad8d4:	00816d04 	movi	r2,1460
 90ad8d8:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 90ad8dc:	e0bff917 	ldw	r2,-28(fp)
 90ad8e0:	10800117 	ldw	r2,4(r2)
 90ad8e4:	1005003a 	cmpeq	r2,r2,zero
 90ad8e8:	10004d1e 	bne	r2,zero,90ada20 <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 90ad8ec:	e0bff917 	ldw	r2,-28(fp)
 90ad8f0:	10800117 	ldw	r2,4(r2)
 90ad8f4:	10800917 	ldw	r2,36(r2)
 90ad8f8:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 90ad8fc:	e0bff417 	ldw	r2,-48(fp)
 90ad900:	10800a0b 	ldhu	r2,40(r2)
 90ad904:	10bfffcc 	andi	r2,r2,65535
 90ad908:	1005003a 	cmpeq	r2,r2,zero
 90ad90c:	1000441e 	bne	r2,zero,90ada20 <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 90ad910:	e0bff417 	ldw	r2,-48(fp)
 90ad914:	10800a0b 	ldhu	r2,40(r2)
 90ad918:	10bfffcc 	andi	r2,r2,65535
 90ad91c:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 90ad920:	00003f06 	br	90ada20 <t_send+0x1fc>
   {
      if (len > maxpkt)
 90ad924:	e0fffd17 	ldw	r3,-12(fp)
 90ad928:	e0bff617 	ldw	r2,-40(fp)
 90ad92c:	10c0030e 	bge	r2,r3,90ad93c <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 90ad930:	e0bff617 	ldw	r2,-40(fp)
 90ad934:	e0bffa15 	stw	r2,-24(fp)
 90ad938:	00000206 	br	90ad944 <t_send+0x120>
      else
         sendlen = len;
 90ad93c:	e0bffd17 	ldw	r2,-12(fp)
 90ad940:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 90ad944:	e0bffa17 	ldw	r2,-24(fp)
 90ad948:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 90ad94c:	0009883a 	mov	r4,zero
 90ad950:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 90ad954:	e1fffa04 	addi	r7,fp,-24
 90ad958:	e0bffe17 	ldw	r2,-8(fp)
 90ad95c:	d8800015 	stw	r2,0(sp)
 90ad960:	e13ff917 	ldw	r4,-28(fp)
 90ad964:	000b883a 	mov	r5,zero
 90ad968:	e1bffc17 	ldw	r6,-16(fp)
 90ad96c:	90ae7440 	call	90ae744 <sosend>
 90ad970:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ad974:	0009883a 	mov	r4,zero
 90ad978:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 90ad97c:	e0bff817 	ldw	r2,-32(fp)
 90ad980:	1005003a 	cmpeq	r2,r2,zero
 90ad984:	1000121e 	bne	r2,zero,90ad9d0 <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 90ad988:	e0bff817 	ldw	r2,-32(fp)
 90ad98c:	10801a60 	cmpeqi	r2,r2,105
 90ad990:	1000031e 	bne	r2,zero,90ad9a0 <t_send+0x17c>
 90ad994:	e0bff817 	ldw	r2,-32(fp)
 90ad998:	108002d8 	cmpnei	r2,r2,11
 90ad99c:	1000061e 	bne	r2,zero,90ad9b8 <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 90ad9a0:	e0bff717 	ldw	r2,-36(fp)
 90ad9a4:	1005003a 	cmpeq	r2,r2,zero
 90ad9a8:	1000031e 	bne	r2,zero,90ad9b8 <t_send+0x194>
            {
               so->so_error = 0;
 90ad9ac:	e0bff917 	ldw	r2,-28(fp)
 90ad9b0:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 90ad9b4:	00001d06 	br	90ada2c <t_send+0x208>
            }
         }
         so->so_error = e;
 90ad9b8:	e0fff917 	ldw	r3,-28(fp)
 90ad9bc:	e0bff817 	ldw	r2,-32(fp)
 90ad9c0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90ad9c4:	00bfffc4 	movi	r2,-1
 90ad9c8:	e0bfff15 	stw	r2,-4(fp)
 90ad9cc:	00001906 	br	90ada34 <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 90ad9d0:	e0bffa17 	ldw	r2,-24(fp)
 90ad9d4:	1004c03a 	cmpne	r2,r2,zero
 90ad9d8:	1000141e 	bne	r2,zero,90ada2c <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 90ad9dc:	e0fffa17 	ldw	r3,-24(fp)
 90ad9e0:	e0bff517 	ldw	r2,-44(fp)
 90ad9e4:	10c5c83a 	sub	r2,r2,r3
 90ad9e8:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 90ad9ec:	e0bff517 	ldw	r2,-44(fp)
 90ad9f0:	1007883a 	mov	r3,r2
 90ad9f4:	e0bffc17 	ldw	r2,-16(fp)
 90ad9f8:	10c5883a 	add	r2,r2,r3
 90ad9fc:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 90ada00:	e0fffd17 	ldw	r3,-12(fp)
 90ada04:	e0bff517 	ldw	r2,-44(fp)
 90ada08:	1885c83a 	sub	r2,r3,r2
 90ada0c:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 90ada10:	e0fff717 	ldw	r3,-36(fp)
 90ada14:	e0bff517 	ldw	r2,-44(fp)
 90ada18:	1885883a 	add	r2,r3,r2
 90ada1c:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 90ada20:	e0bffd17 	ldw	r2,-12(fp)
 90ada24:	1004c03a 	cmpne	r2,r2,zero
 90ada28:	103fbe1e 	bne	r2,zero,90ad924 <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 90ada2c:	e0bff717 	ldw	r2,-36(fp)
 90ada30:	e0bfff15 	stw	r2,-4(fp)
 90ada34:	e0bfff17 	ldw	r2,-4(fp)
}
 90ada38:	e037883a 	mov	sp,fp
 90ada3c:	dfc00117 	ldw	ra,4(sp)
 90ada40:	df000017 	ldw	fp,0(sp)
 90ada44:	dec00204 	addi	sp,sp,8
 90ada48:	f800283a 	ret

090ada4c <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 90ada4c:	defff804 	addi	sp,sp,-32
 90ada50:	dfc00715 	stw	ra,28(sp)
 90ada54:	df000615 	stw	fp,24(sp)
 90ada58:	df000604 	addi	fp,sp,24
 90ada5c:	e13ffd15 	stw	r4,-12(fp)
 90ada60:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 90ada64:	e0bffd17 	ldw	r2,-12(fp)
 90ada68:	10bff804 	addi	r2,r2,-32
 90ada6c:	1085883a 	add	r2,r2,r2
 90ada70:	1085883a 	add	r2,r2,r2
 90ada74:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 90ada78:	008243b4 	movhi	r2,2318
 90ada7c:	10b55b04 	addi	r2,r2,-10900
 90ada80:	e0bffa15 	stw	r2,-24(fp)
 90ada84:	00000606 	br	90adaa0 <t_shutdown+0x54>
 90ada88:	e0fffa17 	ldw	r3,-24(fp)
 90ada8c:	e0bffc17 	ldw	r2,-16(fp)
 90ada90:	18800626 	beq	r3,r2,90adaac <t_shutdown+0x60>
 90ada94:	e0bffa17 	ldw	r2,-24(fp)
 90ada98:	10800017 	ldw	r2,0(r2)
 90ada9c:	e0bffa15 	stw	r2,-24(fp)
 90adaa0:	e0bffa17 	ldw	r2,-24(fp)
 90adaa4:	1004c03a 	cmpne	r2,r2,zero
 90adaa8:	103ff71e 	bne	r2,zero,90ada88 <t_shutdown+0x3c>
 90adaac:	e0fffa17 	ldw	r3,-24(fp)
 90adab0:	e0bffc17 	ldw	r2,-16(fp)
 90adab4:	18800426 	beq	r3,r2,90adac8 <t_shutdown+0x7c>
 90adab8:	90a94880 	call	90a9488 <dtrap>
 90adabc:	00bfffc4 	movi	r2,-1
 90adac0:	e0bfff15 	stw	r2,-4(fp)
 90adac4:	00001406 	br	90adb18 <t_shutdown+0xcc>
   so->so_error = 0;
 90adac8:	e0bffc17 	ldw	r2,-16(fp)
 90adacc:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 90adad0:	0009883a 	mov	r4,zero
 90adad4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 90adad8:	e13ffc17 	ldw	r4,-16(fp)
 90adadc:	e17ffe17 	ldw	r5,-8(fp)
 90adae0:	90af5300 	call	90af530 <soshutdown>
 90adae4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90adae8:	0009883a 	mov	r4,zero
 90adaec:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 90adaf0:	e0bffb17 	ldw	r2,-20(fp)
 90adaf4:	1005003a 	cmpeq	r2,r2,zero
 90adaf8:	1000061e 	bne	r2,zero,90adb14 <t_shutdown+0xc8>
   {
      so->so_error = err;
 90adafc:	e0fffc17 	ldw	r3,-16(fp)
 90adb00:	e0bffb17 	ldw	r2,-20(fp)
 90adb04:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90adb08:	00bfffc4 	movi	r2,-1
 90adb0c:	e0bfff15 	stw	r2,-4(fp)
 90adb10:	00000106 	br	90adb18 <t_shutdown+0xcc>
   }
   return 0;
 90adb14:	e03fff15 	stw	zero,-4(fp)
 90adb18:	e0bfff17 	ldw	r2,-4(fp)
}
 90adb1c:	e037883a 	mov	sp,fp
 90adb20:	dfc00117 	ldw	ra,4(sp)
 90adb24:	df000017 	ldw	fp,0(sp)
 90adb28:	dec00204 	addi	sp,sp,8
 90adb2c:	f800283a 	ret

090adb30 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 90adb30:	defff904 	addi	sp,sp,-28
 90adb34:	dfc00615 	stw	ra,24(sp)
 90adb38:	df000515 	stw	fp,20(sp)
 90adb3c:	df000504 	addi	fp,sp,20
 90adb40:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90adb44:	e0bffe17 	ldw	r2,-8(fp)
 90adb48:	10bff804 	addi	r2,r2,-32
 90adb4c:	1085883a 	add	r2,r2,r2
 90adb50:	1085883a 	add	r2,r2,r2
 90adb54:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 90adb58:	008243b4 	movhi	r2,2318
 90adb5c:	10b55b04 	addi	r2,r2,-10900
 90adb60:	e0bffb15 	stw	r2,-20(fp)
 90adb64:	00000606 	br	90adb80 <t_socketclose+0x50>
 90adb68:	e0fffb17 	ldw	r3,-20(fp)
 90adb6c:	e0bffd17 	ldw	r2,-12(fp)
 90adb70:	18800626 	beq	r3,r2,90adb8c <t_socketclose+0x5c>
 90adb74:	e0bffb17 	ldw	r2,-20(fp)
 90adb78:	10800017 	ldw	r2,0(r2)
 90adb7c:	e0bffb15 	stw	r2,-20(fp)
 90adb80:	e0bffb17 	ldw	r2,-20(fp)
 90adb84:	1004c03a 	cmpne	r2,r2,zero
 90adb88:	103ff71e 	bne	r2,zero,90adb68 <t_socketclose+0x38>
 90adb8c:	e0fffb17 	ldw	r3,-20(fp)
 90adb90:	e0bffd17 	ldw	r2,-12(fp)
 90adb94:	18800426 	beq	r3,r2,90adba8 <t_socketclose+0x78>
 90adb98:	90a94880 	call	90a9488 <dtrap>
 90adb9c:	00bfffc4 	movi	r2,-1
 90adba0:	e0bfff15 	stw	r2,-4(fp)
 90adba4:	00001006 	br	90adbe8 <t_socketclose+0xb8>
   so->so_error = 0;
 90adba8:	e0bffd17 	ldw	r2,-12(fp)
 90adbac:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 90adbb0:	0009883a 	mov	r4,zero
 90adbb4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   err = soclose(so);
 90adbb8:	e13ffd17 	ldw	r4,-12(fp)
 90adbbc:	90ae17c0 	call	90ae17c <soclose>
 90adbc0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90adbc4:	0009883a 	mov	r4,zero
 90adbc8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 90adbcc:	e0bffc17 	ldw	r2,-16(fp)
 90adbd0:	1005003a 	cmpeq	r2,r2,zero
 90adbd4:	1000031e 	bne	r2,zero,90adbe4 <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 90adbd8:	00bfffc4 	movi	r2,-1
 90adbdc:	e0bfff15 	stw	r2,-4(fp)
 90adbe0:	00000106 	br	90adbe8 <t_socketclose+0xb8>
   }
   return 0;
 90adbe4:	e03fff15 	stw	zero,-4(fp)
 90adbe8:	e0bfff17 	ldw	r2,-4(fp)
}
 90adbec:	e037883a 	mov	sp,fp
 90adbf0:	dfc00117 	ldw	ra,4(sp)
 90adbf4:	df000017 	ldw	fp,0(sp)
 90adbf8:	dec00204 	addi	sp,sp,8
 90adbfc:	f800283a 	ret

090adc00 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 90adc00:	defff904 	addi	sp,sp,-28
 90adc04:	dfc00615 	stw	ra,24(sp)
 90adc08:	df000515 	stw	fp,20(sp)
 90adc0c:	df000504 	addi	fp,sp,20
 90adc10:	e13ffc15 	stw	r4,-16(fp)
 90adc14:	e17ffd15 	stw	r5,-12(fp)
 90adc18:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 90adc1c:	0009883a 	mov	r4,zero
 90adc20:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 90adc24:	e13ffe17 	ldw	r4,-8(fp)
 90adc28:	e17ffd17 	ldw	r5,-12(fp)
 90adc2c:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90adc30:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90adc34:	0009883a 	mov	r4,zero
 90adc38:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 90adc3c:	e0bffb17 	ldw	r2,-20(fp)
 90adc40:	1004c03a 	cmpne	r2,r2,zero
 90adc44:	1000021e 	bne	r2,zero,90adc50 <sockargs+0x50>
      return NULL;
 90adc48:	e03fff15 	stw	zero,-4(fp)
 90adc4c:	00000c06 	br	90adc80 <sockargs+0x80>
   m->m_len = arglen;
 90adc50:	e0fffd17 	ldw	r3,-12(fp)
 90adc54:	e0bffb17 	ldw	r2,-20(fp)
 90adc58:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 90adc5c:	e0bffb17 	ldw	r2,-20(fp)
 90adc60:	10c00317 	ldw	r3,12(r2)
 90adc64:	e1bffd17 	ldw	r6,-12(fp)
 90adc68:	e0bffc17 	ldw	r2,-16(fp)
 90adc6c:	1809883a 	mov	r4,r3
 90adc70:	100b883a 	mov	r5,r2
 90adc74:	90822780 	call	9082278 <memcpy>
   return m;
 90adc78:	e0bffb17 	ldw	r2,-20(fp)
 90adc7c:	e0bfff15 	stw	r2,-4(fp)
 90adc80:	e0bfff17 	ldw	r2,-4(fp)
}
 90adc84:	e037883a 	mov	sp,fp
 90adc88:	dfc00117 	ldw	ra,4(sp)
 90adc8c:	df000017 	ldw	fp,0(sp)
 90adc90:	dec00204 	addi	sp,sp,8
 90adc94:	f800283a 	ret

090adc98 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 90adc98:	defffa04 	addi	sp,sp,-24
 90adc9c:	dfc00515 	stw	ra,20(sp)
 90adca0:	df000415 	stw	fp,16(sp)
 90adca4:	df000404 	addi	fp,sp,16
 90adca8:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 90adcac:	e0bfff17 	ldw	r2,-4(fp)
 90adcb0:	10bff804 	addi	r2,r2,-32
 90adcb4:	1085883a 	add	r2,r2,r2
 90adcb8:	1085883a 	add	r2,r2,r2
 90adcbc:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 90adcc0:	00801b04 	movi	r2,108
 90adcc4:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 90adcc8:	0009883a 	mov	r4,zero
 90adccc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 90adcd0:	008243b4 	movhi	r2,2318
 90adcd4:	10b55b04 	addi	r2,r2,-10900
 90adcd8:	e0bffd15 	stw	r2,-12(fp)
 90adcdc:	00000a06 	br	90add08 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 90adce0:	e0fffd17 	ldw	r3,-12(fp)
 90adce4:	e0bffe17 	ldw	r2,-8(fp)
 90adce8:	1880041e 	bne	r3,r2,90adcfc <t_errno+0x64>
      {
         errcode = so->so_error;
 90adcec:	e0bffe17 	ldw	r2,-8(fp)
 90adcf0:	10800617 	ldw	r2,24(r2)
 90adcf4:	e0bffc15 	stw	r2,-16(fp)
         break;
 90adcf8:	00000606 	br	90add14 <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 90adcfc:	e0bffd17 	ldw	r2,-12(fp)
 90add00:	10800017 	ldw	r2,0(r2)
 90add04:	e0bffd15 	stw	r2,-12(fp)
 90add08:	e0bffd17 	ldw	r2,-12(fp)
 90add0c:	1004c03a 	cmpne	r2,r2,zero
 90add10:	103ff31e 	bne	r2,zero,90adce0 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 90add14:	0009883a 	mov	r4,zero
 90add18:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   return errcode;
 90add1c:	e0bffc17 	ldw	r2,-16(fp)
}
 90add20:	e037883a 	mov	sp,fp
 90add24:	dfc00117 	ldw	ra,4(sp)
 90add28:	df000017 	ldw	fp,0(sp)
 90add2c:	dec00204 	addi	sp,sp,8
 90add30:	f800283a 	ret

090add34 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 90add34:	defff604 	addi	sp,sp,-40
 90add38:	dfc00915 	stw	ra,36(sp)
 90add3c:	df000815 	stw	fp,32(sp)
 90add40:	df000804 	addi	fp,sp,32
 90add44:	e13ffc15 	stw	r4,-16(fp)
 90add48:	e17ffd15 	stw	r5,-12(fp)
 90add4c:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 90add50:	e0bffe17 	ldw	r2,-8(fp)
 90add54:	1005003a 	cmpeq	r2,r2,zero
 90add58:	1000061e 	bne	r2,zero,90add74 <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 90add5c:	e13ffc17 	ldw	r4,-16(fp)
 90add60:	e17ffe17 	ldw	r5,-8(fp)
 90add64:	e1bffd17 	ldw	r6,-12(fp)
 90add68:	90aa1f80 	call	90aa1f8 <pffindproto>
 90add6c:	e0bffb15 	stw	r2,-20(fp)
 90add70:	00000406 	br	90add84 <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 90add74:	e13ffc17 	ldw	r4,-16(fp)
 90add78:	e17ffd17 	ldw	r5,-12(fp)
 90add7c:	90aa1580 	call	90aa158 <pffindtype>
 90add80:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 90add84:	e0bffb17 	ldw	r2,-20(fp)
 90add88:	1004c03a 	cmpne	r2,r2,zero
 90add8c:	1000021e 	bne	r2,zero,90add98 <socreate+0x64>
      return NULL;
 90add90:	e03fff15 	stw	zero,-4(fp)
 90add94:	00005406 	br	90adee8 <socreate+0x1b4>
   if (prp->pr_type != type)
 90add98:	e0bffb17 	ldw	r2,-20(fp)
 90add9c:	1080000b 	ldhu	r2,0(r2)
 90adda0:	10ffffcc 	andi	r3,r2,65535
 90adda4:	18e0001c 	xori	r3,r3,32768
 90adda8:	18e00004 	addi	r3,r3,-32768
 90addac:	e0bffd17 	ldw	r2,-12(fp)
 90addb0:	18800226 	beq	r3,r2,90addbc <socreate+0x88>
      return NULL;
 90addb4:	e03fff15 	stw	zero,-4(fp)
 90addb8:	00004b06 	br	90adee8 <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 90addbc:	01002104 	movi	r4,132
 90addc0:	90a9f0c0 	call	90a9f0c <npalloc>
 90addc4:	e0bffa15 	stw	r2,-24(fp)
 90addc8:	e0bffa17 	ldw	r2,-24(fp)
 90addcc:	1004c03a 	cmpne	r2,r2,zero
 90addd0:	1000021e 	bne	r2,zero,90adddc <socreate+0xa8>
      return NULL;
 90addd4:	e03fff15 	stw	zero,-4(fp)
 90addd8:	00004306 	br	90adee8 <socreate+0x1b4>
   so->next = NULL;
 90adddc:	e0bffa17 	ldw	r2,-24(fp)
 90adde0:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 90adde4:	e17ffa17 	ldw	r5,-24(fp)
 90adde8:	010243b4 	movhi	r4,2318
 90addec:	21355b04 	addi	r4,r4,-10900
 90addf0:	90a8e180 	call	90a8e18 <putq>

   so->so_options = socket_defaults;
 90addf4:	d0a03a0b 	ldhu	r2,-32536(gp)
 90addf8:	10ffffcc 	andi	r3,r2,65535
 90addfc:	e0bffa17 	ldw	r2,-24(fp)
 90ade00:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 90ade04:	e0fffa17 	ldw	r3,-24(fp)
 90ade08:	e0bffc17 	ldw	r2,-16(fp)
 90ade0c:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 90ade10:	e0bffa17 	ldw	r2,-24(fp)
 90ade14:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 90ade18:	e0bffd17 	ldw	r2,-12(fp)
 90ade1c:	1007883a 	mov	r3,r2
 90ade20:	e0bffa17 	ldw	r2,-24(fp)
 90ade24:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 90ade28:	e0fffa17 	ldw	r3,-24(fp)
 90ade2c:	e0bffb17 	ldw	r2,-20(fp)
 90ade30:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 90ade34:	e0bffa17 	ldw	r2,-24(fp)
 90ade38:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 90ade3c:	e0bffa17 	ldw	r2,-24(fp)
 90ade40:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 90ade44:	e0bffb17 	ldw	r2,-20(fp)
 90ade48:	10800317 	ldw	r2,12(r2)
 90ade4c:	e1bffe17 	ldw	r6,-8(fp)
 90ade50:	e13ffa17 	ldw	r4,-24(fp)
 90ade54:	000b883a 	mov	r5,zero
 90ade58:	103ee83a 	callr	r2
 90ade5c:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 90ade60:	e0bff917 	ldw	r2,-28(fp)
 90ade64:	1004c03a 	cmpne	r2,r2,zero
 90ade68:	10000f1e 	bne	r2,zero,90adea8 <socreate+0x174>

   if (so_evtmap)
 90ade6c:	00824374 	movhi	r2,2317
 90ade70:	108c6804 	addi	r2,r2,12704
 90ade74:	10800003 	ldbu	r2,0(r2)
 90ade78:	10803fcc 	andi	r2,r2,255
 90ade7c:	1005003a 	cmpeq	r2,r2,zero
 90ade80:	1000171e 	bne	r2,zero,90adee0 <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 90ade84:	00824374 	movhi	r2,2317
 90ade88:	108c6604 	addi	r2,r2,12696
 90ade8c:	10800017 	ldw	r2,0(r2)
 90ade90:	e13ffa17 	ldw	r4,-24(fp)
 90ade94:	103ee83a 	callr	r2
 90ade98:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 90ade9c:	e0bff817 	ldw	r2,-32(fp)
 90adea0:	1005003a 	cmpeq	r2,r2,zero
 90adea4:	10000a1e 	bne	r2,zero,90aded0 <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 90adea8:	e0bffa17 	ldw	r2,-24(fp)
 90adeac:	1080088b 	ldhu	r2,34(r2)
 90adeb0:	10800054 	ori	r2,r2,1
 90adeb4:	1007883a 	mov	r3,r2
 90adeb8:	e0bffa17 	ldw	r2,-24(fp)
 90adebc:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 90adec0:	e13ffa17 	ldw	r4,-24(fp)
 90adec4:	90ae04c0 	call	90ae04c <sofree>
         return NULL;   
 90adec8:	e03fff15 	stw	zero,-4(fp)
 90adecc:	00000606 	br	90adee8 <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 90aded0:	90a4fa80 	call	90a4fa8 <TK_OSTaskQuery>
 90aded4:	1007883a 	mov	r3,r2
 90aded8:	e0bffa17 	ldw	r2,-24(fp)
 90adedc:	10c02005 	stb	r3,128(r2)
   }

   return so;
 90adee0:	e0bffa17 	ldw	r2,-24(fp)
 90adee4:	e0bfff15 	stw	r2,-4(fp)
 90adee8:	e0bfff17 	ldw	r2,-4(fp)
}
 90adeec:	e037883a 	mov	sp,fp
 90adef0:	dfc00117 	ldw	ra,4(sp)
 90adef4:	df000017 	ldw	fp,0(sp)
 90adef8:	dec00204 	addi	sp,sp,8
 90adefc:	f800283a 	ret

090adf00 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 90adf00:	defffb04 	addi	sp,sp,-20
 90adf04:	dfc00415 	stw	ra,16(sp)
 90adf08:	df000315 	stw	fp,12(sp)
 90adf0c:	df000304 	addi	fp,sp,12
 90adf10:	e13ffe15 	stw	r4,-8(fp)
 90adf14:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 90adf18:	e0fffe17 	ldw	r3,-8(fp)
 90adf1c:	00800084 	movi	r2,2
 90adf20:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90adf24:	e0bffe17 	ldw	r2,-8(fp)
 90adf28:	10800217 	ldw	r2,8(r2)
 90adf2c:	10800317 	ldw	r2,12(r2)
 90adf30:	e13ffe17 	ldw	r4,-8(fp)
 90adf34:	000b883a 	mov	r5,zero
 90adf38:	e1bfff17 	ldw	r6,-4(fp)
 90adf3c:	103ee83a 	callr	r2
 90adf40:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 90adf44:	e0bffd17 	ldw	r2,-12(fp)
}
 90adf48:	e037883a 	mov	sp,fp
 90adf4c:	dfc00117 	ldw	ra,4(sp)
 90adf50:	df000017 	ldw	fp,0(sp)
 90adf54:	dec00204 	addi	sp,sp,8
 90adf58:	f800283a 	ret

090adf5c <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 90adf5c:	defff904 	addi	sp,sp,-28
 90adf60:	dfc00615 	stw	ra,24(sp)
 90adf64:	df000515 	stw	fp,20(sp)
 90adf68:	df000504 	addi	fp,sp,20
 90adf6c:	e13ffc15 	stw	r4,-16(fp)
 90adf70:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 90adf74:	e0fffc17 	ldw	r3,-16(fp)
 90adf78:	008000c4 	movi	r2,3
 90adf7c:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 90adf80:	e0bffc17 	ldw	r2,-16(fp)
 90adf84:	10800217 	ldw	r2,8(r2)
 90adf88:	10800317 	ldw	r2,12(r2)
 90adf8c:	e13ffc17 	ldw	r4,-16(fp)
 90adf90:	000b883a 	mov	r5,zero
 90adf94:	000d883a 	mov	r6,zero
 90adf98:	103ee83a 	callr	r2
 90adf9c:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 90adfa0:	e0bffb17 	ldw	r2,-20(fp)
 90adfa4:	1005003a 	cmpeq	r2,r2,zero
 90adfa8:	1000031e 	bne	r2,zero,90adfb8 <solisten+0x5c>
   {
      return (error);
 90adfac:	e0bffb17 	ldw	r2,-20(fp)
 90adfb0:	e0bfff15 	stw	r2,-4(fp)
 90adfb4:	00001f06 	br	90ae034 <solisten+0xd8>
   }
   if (so->so_q == 0) 
 90adfb8:	e0bffc17 	ldw	r2,-16(fp)
 90adfbc:	10801d17 	ldw	r2,116(r2)
 90adfc0:	1004c03a 	cmpne	r2,r2,zero
 90adfc4:	10000b1e 	bne	r2,zero,90adff4 <solisten+0x98>
   {
      so->so_q = so;
 90adfc8:	e0fffc17 	ldw	r3,-16(fp)
 90adfcc:	e0bffc17 	ldw	r2,-16(fp)
 90adfd0:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 90adfd4:	e0fffc17 	ldw	r3,-16(fp)
 90adfd8:	e0bffc17 	ldw	r2,-16(fp)
 90adfdc:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 90adfe0:	e0bffc17 	ldw	r2,-16(fp)
 90adfe4:	10800417 	ldw	r2,16(r2)
 90adfe8:	10c00094 	ori	r3,r2,2
 90adfec:	e0bffc17 	ldw	r2,-16(fp)
 90adff0:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 90adff4:	e0bffd17 	ldw	r2,-12(fp)
 90adff8:	1004403a 	cmpge	r2,r2,zero
 90adffc:	1000011e 	bne	r2,zero,90ae004 <solisten+0xa8>
      backlog = 0;
 90ae000:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 90ae004:	e0fffd17 	ldw	r3,-12(fp)
 90ae008:	e0fffe15 	stw	r3,-8(fp)
 90ae00c:	e0fffe17 	ldw	r3,-8(fp)
 90ae010:	18800190 	cmplti	r2,r3,6
 90ae014:	1000021e 	bne	r2,zero,90ae020 <solisten+0xc4>
 90ae018:	00800144 	movi	r2,5
 90ae01c:	e0bffe15 	stw	r2,-8(fp)
 90ae020:	e0bffe17 	ldw	r2,-8(fp)
 90ae024:	1007883a 	mov	r3,r2
 90ae028:	e0bffc17 	ldw	r2,-16(fp)
 90ae02c:	10c01e85 	stb	r3,122(r2)
   return 0;
 90ae030:	e03fff15 	stw	zero,-4(fp)
 90ae034:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae038:	e037883a 	mov	sp,fp
 90ae03c:	dfc00117 	ldw	ra,4(sp)
 90ae040:	df000017 	ldw	fp,0(sp)
 90ae044:	dec00204 	addi	sp,sp,8
 90ae048:	f800283a 	ret

090ae04c <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 90ae04c:	defffd04 	addi	sp,sp,-12
 90ae050:	dfc00215 	stw	ra,8(sp)
 90ae054:	df000115 	stw	fp,4(sp)
 90ae058:	df000104 	addi	fp,sp,4
 90ae05c:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 90ae060:	e0bfff17 	ldw	r2,-4(fp)
 90ae064:	10800117 	ldw	r2,4(r2)
 90ae068:	1004c03a 	cmpne	r2,r2,zero
 90ae06c:	10003e1e 	bne	r2,zero,90ae168 <sofree+0x11c>
 90ae070:	e0bfff17 	ldw	r2,-4(fp)
 90ae074:	1080088b 	ldhu	r2,34(r2)
 90ae078:	10bfffcc 	andi	r2,r2,65535
 90ae07c:	1080004c 	andi	r2,r2,1
 90ae080:	1004c03a 	cmpne	r2,r2,zero
 90ae084:	1000011e 	bne	r2,zero,90ae08c <sofree+0x40>
      return;
 90ae088:	00003706 	br	90ae168 <sofree+0x11c>
   if (so->so_head) 
 90ae08c:	e0bfff17 	ldw	r2,-4(fp)
 90ae090:	10801b17 	ldw	r2,108(r2)
 90ae094:	1005003a 	cmpeq	r2,r2,zero
 90ae098:	10000f1e 	bne	r2,zero,90ae0d8 <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 90ae09c:	e13fff17 	ldw	r4,-4(fp)
 90ae0a0:	000b883a 	mov	r5,zero
 90ae0a4:	90b06940 	call	90b0694 <soqremque>
 90ae0a8:	1004c03a 	cmpne	r2,r2,zero
 90ae0ac:	1000081e 	bne	r2,zero,90ae0d0 <sofree+0x84>
 90ae0b0:	e13fff17 	ldw	r4,-4(fp)
 90ae0b4:	01400044 	movi	r5,1
 90ae0b8:	90b06940 	call	90b0694 <soqremque>
 90ae0bc:	1004c03a 	cmpne	r2,r2,zero
 90ae0c0:	1000031e 	bne	r2,zero,90ae0d0 <sofree+0x84>
         panic("sofree");
 90ae0c4:	01024374 	movhi	r4,2317
 90ae0c8:	213f5f04 	addi	r4,r4,-644
 90ae0cc:	90a438c0 	call	90a438c <panic>
      so->so_head = 0;
 90ae0d0:	e0bfff17 	ldw	r2,-4(fp)
 90ae0d4:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 90ae0d8:	e0bfff17 	ldw	r2,-4(fp)
 90ae0dc:	11001204 	addi	r4,r2,72
 90ae0e0:	90b0a700 	call	90b0a70 <sbrelease>
   sorflush(so);
 90ae0e4:	e13fff17 	ldw	r4,-4(fp)
 90ae0e8:	90af5d80 	call	90af5d8 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 90ae0ec:	e0bfff17 	ldw	r2,-4(fp)
 90ae0f0:	10800317 	ldw	r2,12(r2)
 90ae0f4:	1005003a 	cmpeq	r2,r2,zero
 90ae0f8:	1000031e 	bne	r2,zero,90ae108 <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 90ae0fc:	e0bfff17 	ldw	r2,-4(fp)
 90ae100:	11000317 	ldw	r4,12(r2)
 90ae104:	90c4fdc0 	call	90c4fdc <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 90ae108:	e0bfff17 	ldw	r2,-4(fp)
 90ae10c:	10801f17 	ldw	r2,124(r2)
 90ae110:	1005003a 	cmpeq	r2,r2,zero
 90ae114:	1000031e 	bne	r2,zero,90ae124 <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 90ae118:	e0bfff17 	ldw	r2,-4(fp)
 90ae11c:	11001f17 	ldw	r4,124(r2)
 90ae120:	90aa0000 	call	90aa000 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 90ae124:	010243b4 	movhi	r4,2318
 90ae128:	21355b04 	addi	r4,r4,-10900
 90ae12c:	e17fff17 	ldw	r5,-4(fp)
 90ae130:	90a8ec80 	call	90a8ec8 <qdel>
   
   if (so_evtmap)  
 90ae134:	00824374 	movhi	r2,2317
 90ae138:	108c6804 	addi	r2,r2,12704
 90ae13c:	10800003 	ldbu	r2,0(r2)
 90ae140:	10803fcc 	andi	r2,r2,255
 90ae144:	1005003a 	cmpeq	r2,r2,zero
 90ae148:	1000051e 	bne	r2,zero,90ae160 <sofree+0x114>
      (*so_evtmap_delete) (so);
 90ae14c:	00824374 	movhi	r2,2317
 90ae150:	108c6704 	addi	r2,r2,12700
 90ae154:	10800017 	ldw	r2,0(r2)
 90ae158:	e13fff17 	ldw	r4,-4(fp)
 90ae15c:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 90ae160:	e13fff17 	ldw	r4,-4(fp)
 90ae164:	90aa0000 	call	90aa000 <npfree>
}
 90ae168:	e037883a 	mov	sp,fp
 90ae16c:	dfc00117 	ldw	ra,4(sp)
 90ae170:	df000017 	ldw	fp,0(sp)
 90ae174:	dec00204 	addi	sp,sp,8
 90ae178:	f800283a 	ret

090ae17c <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 90ae17c:	defff604 	addi	sp,sp,-40
 90ae180:	dfc00915 	stw	ra,36(sp)
 90ae184:	df000815 	stw	fp,32(sp)
 90ae188:	dc400715 	stw	r17,28(sp)
 90ae18c:	dc000615 	stw	r16,24(sp)
 90ae190:	df000604 	addi	fp,sp,24
 90ae194:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 90ae198:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 90ae19c:	008243b4 	movhi	r2,2318
 90ae1a0:	10b55b04 	addi	r2,r2,-10900
 90ae1a4:	10800017 	ldw	r2,0(r2)
 90ae1a8:	e0bffc15 	stw	r2,-16(fp)
 90ae1ac:	00000606 	br	90ae1c8 <soclose+0x4c>
   {
      if (so == tmpso)
 90ae1b0:	e0fffe17 	ldw	r3,-8(fp)
 90ae1b4:	e0bffc17 	ldw	r2,-16(fp)
 90ae1b8:	18800626 	beq	r3,r2,90ae1d4 <soclose+0x58>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 90ae1bc:	e0bffc17 	ldw	r2,-16(fp)
 90ae1c0:	10800017 	ldw	r2,0(r2)
 90ae1c4:	e0bffc15 	stw	r2,-16(fp)
 90ae1c8:	e0bffc17 	ldw	r2,-16(fp)
 90ae1cc:	1004c03a 	cmpne	r2,r2,zero
 90ae1d0:	103ff71e 	bne	r2,zero,90ae1b0 <soclose+0x34>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 90ae1d4:	e0bffc17 	ldw	r2,-16(fp)
 90ae1d8:	1004c03a 	cmpne	r2,r2,zero
 90ae1dc:	1000031e 	bne	r2,zero,90ae1ec <soclose+0x70>
      return EINVAL;
 90ae1e0:	00800584 	movi	r2,22
 90ae1e4:	e0bfff15 	stw	r2,-4(fp)
 90ae1e8:	0000b606 	br	90ae4c4 <soclose+0x348>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 90ae1ec:	e0bffe17 	ldw	r2,-8(fp)
 90ae1f0:	10800417 	ldw	r2,16(r2)
 90ae1f4:	1080008c 	andi	r2,r2,2
 90ae1f8:	1005003a 	cmpeq	r2,r2,zero
 90ae1fc:	1000101e 	bne	r2,zero,90ae240 <soclose+0xc4>
   {
      while (so->so_q0 != so)
 90ae200:	00000306 	br	90ae210 <soclose+0x94>
         (void) soabort(so->so_q0);
 90ae204:	e0bffe17 	ldw	r2,-8(fp)
 90ae208:	11001c17 	ldw	r4,112(r2)
 90ae20c:	90ae4e40 	call	90ae4e4 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 90ae210:	e0bffe17 	ldw	r2,-8(fp)
 90ae214:	10c01c17 	ldw	r3,112(r2)
 90ae218:	e0bffe17 	ldw	r2,-8(fp)
 90ae21c:	18bff91e 	bne	r3,r2,90ae204 <soclose+0x88>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 90ae220:	00000306 	br	90ae230 <soclose+0xb4>
         (void) soabort(so->so_q);
 90ae224:	e0bffe17 	ldw	r2,-8(fp)
 90ae228:	11001d17 	ldw	r4,116(r2)
 90ae22c:	90ae4e40 	call	90ae4e4 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 90ae230:	e0bffe17 	ldw	r2,-8(fp)
 90ae234:	10c01d17 	ldw	r3,116(r2)
 90ae238:	e0bffe17 	ldw	r2,-8(fp)
 90ae23c:	18bff91e 	bne	r3,r2,90ae224 <soclose+0xa8>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 90ae240:	e0bffe17 	ldw	r2,-8(fp)
 90ae244:	10800983 	ldbu	r2,38(r2)
 90ae248:	10803fcc 	andi	r2,r2,255
 90ae24c:	1080201c 	xori	r2,r2,128
 90ae250:	10bfe004 	addi	r2,r2,-128
 90ae254:	10800060 	cmpeqi	r2,r2,1
 90ae258:	10000c1e 	bne	r2,zero,90ae28c <soclose+0x110>
   { 
      so->so_req = PRU_DETACH;
 90ae25c:	e0fffe17 	ldw	r3,-8(fp)
 90ae260:	00800044 	movi	r2,1
 90ae264:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 90ae268:	e0bffe17 	ldw	r2,-8(fp)
 90ae26c:	10800217 	ldw	r2,8(r2)
 90ae270:	10800317 	ldw	r2,12(r2)
 90ae274:	e13ffe17 	ldw	r4,-8(fp)
 90ae278:	000b883a 	mov	r5,zero
 90ae27c:	000d883a 	mov	r6,zero
 90ae280:	103ee83a 	callr	r2
 90ae284:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 90ae288:	00007c06 	br	90ae47c <soclose+0x300>
   }

   if (so->so_pcb == 0)
 90ae28c:	e0bffe17 	ldw	r2,-8(fp)
 90ae290:	10800117 	ldw	r2,4(r2)
 90ae294:	1005003a 	cmpeq	r2,r2,zero
 90ae298:	1000781e 	bne	r2,zero,90ae47c <soclose+0x300>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 90ae29c:	e0bffe17 	ldw	r2,-8(fp)
 90ae2a0:	1080088b 	ldhu	r2,34(r2)
 90ae2a4:	10bfffcc 	andi	r2,r2,65535
 90ae2a8:	1080008c 	andi	r2,r2,2
 90ae2ac:	1005003a 	cmpeq	r2,r2,zero
 90ae2b0:	10005e1e 	bne	r2,zero,90ae42c <soclose+0x2b0>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 90ae2b4:	e0bffe17 	ldw	r2,-8(fp)
 90ae2b8:	1080088b 	ldhu	r2,34(r2)
 90ae2bc:	10bfffcc 	andi	r2,r2,65535
 90ae2c0:	1080020c 	andi	r2,r2,8
 90ae2c4:	1004c03a 	cmpne	r2,r2,zero
 90ae2c8:	1000061e 	bne	r2,zero,90ae2e4 <soclose+0x168>
      {
         error = sodisconnect(so);
 90ae2cc:	e13ffe17 	ldw	r4,-8(fp)
 90ae2d0:	90ae6a40 	call	90ae6a4 <sodisconnect>
 90ae2d4:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 90ae2d8:	e0bffd17 	ldw	r2,-12(fp)
 90ae2dc:	1004c03a 	cmpne	r2,r2,zero
 90ae2e0:	1000521e 	bne	r2,zero,90ae42c <soclose+0x2b0>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 90ae2e4:	e0bffe17 	ldw	r2,-8(fp)
 90ae2e8:	10800417 	ldw	r2,16(r2)
 90ae2ec:	1080200c 	andi	r2,r2,128
 90ae2f0:	1005003a 	cmpeq	r2,r2,zero
 90ae2f4:	1000411e 	bne	r2,zero,90ae3fc <soclose+0x280>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 90ae2f8:	e0bffe17 	ldw	r2,-8(fp)
 90ae2fc:	1080088b 	ldhu	r2,34(r2)
 90ae300:	10bfffcc 	andi	r2,r2,65535
 90ae304:	1080020c 	andi	r2,r2,8
 90ae308:	1005003a 	cmpeq	r2,r2,zero
 90ae30c:	1000061e 	bne	r2,zero,90ae328 <soclose+0x1ac>
 90ae310:	e0bffe17 	ldw	r2,-8(fp)
 90ae314:	1080088b 	ldhu	r2,34(r2)
 90ae318:	10bfffcc 	andi	r2,r2,65535
 90ae31c:	1080400c 	andi	r2,r2,256
 90ae320:	1004c03a 	cmpne	r2,r2,zero
 90ae324:	1000411e 	bne	r2,zero,90ae42c <soclose+0x2b0>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 90ae328:	00824374 	movhi	r2,2317
 90ae32c:	108c4204 	addi	r2,r2,12552
 90ae330:	11000017 	ldw	r4,0(r2)
 90ae334:	908c0380 	call	908c038 <__floatunsidf>
 90ae338:	1021883a 	mov	r16,r2
 90ae33c:	1823883a 	mov	r17,r3
 90ae340:	e0bffe17 	ldw	r2,-8(fp)
 90ae344:	1080080b 	ldhu	r2,32(r2)
 90ae348:	113fffcc 	andi	r4,r2,65535
 90ae34c:	2120001c 	xori	r4,r4,32768
 90ae350:	21200004 	addi	r4,r4,-32768
 90ae354:	908c0380 	call	908c038 <__floatunsidf>
 90ae358:	100b883a 	mov	r5,r2
 90ae35c:	180d883a 	mov	r6,r3
 90ae360:	2809883a 	mov	r4,r5
 90ae364:	300b883a 	mov	r5,r6
 90ae368:	000d883a 	mov	r6,zero
 90ae36c:	01d01674 	movhi	r7,16473
 90ae370:	908b5b40 	call	908b5b4 <__muldf3>
 90ae374:	1009883a 	mov	r4,r2
 90ae378:	180b883a 	mov	r5,r3
 90ae37c:	2005883a 	mov	r2,r4
 90ae380:	2807883a 	mov	r3,r5
 90ae384:	8009883a 	mov	r4,r16
 90ae388:	880b883a 	mov	r5,r17
 90ae38c:	100d883a 	mov	r6,r2
 90ae390:	180f883a 	mov	r7,r3
 90ae394:	908b5400 	call	908b540 <__adddf3>
 90ae398:	1009883a 	mov	r4,r2
 90ae39c:	180b883a 	mov	r5,r3
 90ae3a0:	2005883a 	mov	r2,r4
 90ae3a4:	2807883a 	mov	r3,r5
 90ae3a8:	1009883a 	mov	r4,r2
 90ae3ac:	180b883a 	mov	r5,r3
 90ae3b0:	90cade40 	call	90cade4 <__fixunsdfsi>
 90ae3b4:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 90ae3b8:	00000406 	br	90ae3cc <soclose+0x250>
         {
            tcp_sleep((char *)&so->so_timeo);
 90ae3bc:	e0bffe17 	ldw	r2,-8(fp)
 90ae3c0:	10800904 	addi	r2,r2,36
 90ae3c4:	1009883a 	mov	r4,r2
 90ae3c8:	90a4d040 	call	90a4d04 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 90ae3cc:	e0bffe17 	ldw	r2,-8(fp)
 90ae3d0:	1080088b 	ldhu	r2,34(r2)
 90ae3d4:	10bfffcc 	andi	r2,r2,65535
 90ae3d8:	1080008c 	andi	r2,r2,2
 90ae3dc:	1005003a 	cmpeq	r2,r2,zero
 90ae3e0:	1000121e 	bne	r2,zero,90ae42c <soclose+0x2b0>
 90ae3e4:	00824374 	movhi	r2,2317
 90ae3e8:	108c4204 	addi	r2,r2,12552
 90ae3ec:	10c00017 	ldw	r3,0(r2)
 90ae3f0:	e0bffb17 	ldw	r2,-20(fp)
 90ae3f4:	18bff136 	bltu	r3,r2,90ae3bc <soclose+0x240>
 90ae3f8:	00000c06 	br	90ae42c <soclose+0x2b0>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 90ae3fc:	e0bffe17 	ldw	r2,-8(fp)
 90ae400:	10801217 	ldw	r2,72(r2)
 90ae404:	1005003a 	cmpeq	r2,r2,zero
 90ae408:	1000081e 	bne	r2,zero,90ae42c <soclose+0x2b0>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 90ae40c:	e0bffe17 	ldw	r2,-8(fp)
 90ae410:	1080088b 	ldhu	r2,34(r2)
 90ae414:	10800054 	ori	r2,r2,1
 90ae418:	1007883a 	mov	r3,r2
 90ae41c:	e0bffe17 	ldw	r2,-8(fp)
 90ae420:	10c0088d 	sth	r3,34(r2)
            return 0;
 90ae424:	e03fff15 	stw	zero,-4(fp)
 90ae428:	00002606 	br	90ae4c4 <soclose+0x348>
         }
      }
   }
drop:
   if (so->so_pcb) 
 90ae42c:	e0bffe17 	ldw	r2,-8(fp)
 90ae430:	10800117 	ldw	r2,4(r2)
 90ae434:	1005003a 	cmpeq	r2,r2,zero
 90ae438:	1000101e 	bne	r2,zero,90ae47c <soclose+0x300>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 90ae43c:	e0fffe17 	ldw	r3,-8(fp)
 90ae440:	00800044 	movi	r2,1
 90ae444:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 90ae448:	e0bffe17 	ldw	r2,-8(fp)
 90ae44c:	10800217 	ldw	r2,8(r2)
 90ae450:	10800317 	ldw	r2,12(r2)
 90ae454:	e13ffe17 	ldw	r4,-8(fp)
 90ae458:	000b883a 	mov	r5,zero
 90ae45c:	000d883a 	mov	r6,zero
 90ae460:	103ee83a 	callr	r2
 90ae464:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 90ae468:	e0bffd17 	ldw	r2,-12(fp)
 90ae46c:	1004c03a 	cmpne	r2,r2,zero
 90ae470:	1000021e 	bne	r2,zero,90ae47c <soclose+0x300>
         error = error2;
 90ae474:	e0bffa17 	ldw	r2,-24(fp)
 90ae478:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 90ae47c:	e0bffe17 	ldw	r2,-8(fp)
 90ae480:	1080088b 	ldhu	r2,34(r2)
 90ae484:	10bfffcc 	andi	r2,r2,65535
 90ae488:	1080004c 	andi	r2,r2,1
 90ae48c:	10803fcc 	andi	r2,r2,255
 90ae490:	1005003a 	cmpeq	r2,r2,zero
 90ae494:	1000011e 	bne	r2,zero,90ae49c <soclose+0x320>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 90ae498:	90a94880 	call	90a9488 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 90ae49c:	e0bffe17 	ldw	r2,-8(fp)
 90ae4a0:	1080088b 	ldhu	r2,34(r2)
 90ae4a4:	10800054 	ori	r2,r2,1
 90ae4a8:	1007883a 	mov	r3,r2
 90ae4ac:	e0bffe17 	ldw	r2,-8(fp)
 90ae4b0:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 90ae4b4:	e13ffe17 	ldw	r4,-8(fp)
 90ae4b8:	90ae04c0 	call	90ae04c <sofree>
   return (error);
 90ae4bc:	e0bffd17 	ldw	r2,-12(fp)
 90ae4c0:	e0bfff15 	stw	r2,-4(fp)
 90ae4c4:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae4c8:	e037883a 	mov	sp,fp
 90ae4cc:	dfc00317 	ldw	ra,12(sp)
 90ae4d0:	df000217 	ldw	fp,8(sp)
 90ae4d4:	dc400117 	ldw	r17,4(sp)
 90ae4d8:	dc000017 	ldw	r16,0(sp)
 90ae4dc:	dec00404 	addi	sp,sp,16
 90ae4e0:	f800283a 	ret

090ae4e4 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 90ae4e4:	defffd04 	addi	sp,sp,-12
 90ae4e8:	dfc00215 	stw	ra,8(sp)
 90ae4ec:	df000115 	stw	fp,4(sp)
 90ae4f0:	df000104 	addi	fp,sp,4
 90ae4f4:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 90ae4f8:	e0ffff17 	ldw	r3,-4(fp)
 90ae4fc:	00800284 	movi	r2,10
 90ae500:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 90ae504:	e0bfff17 	ldw	r2,-4(fp)
 90ae508:	10800217 	ldw	r2,8(r2)
 90ae50c:	10800317 	ldw	r2,12(r2)
 90ae510:	e13fff17 	ldw	r4,-4(fp)
 90ae514:	000b883a 	mov	r5,zero
 90ae518:	000d883a 	mov	r6,zero
 90ae51c:	103ee83a 	callr	r2
}
 90ae520:	e037883a 	mov	sp,fp
 90ae524:	dfc00117 	ldw	ra,4(sp)
 90ae528:	df000017 	ldw	fp,0(sp)
 90ae52c:	dec00204 	addi	sp,sp,8
 90ae530:	f800283a 	ret

090ae534 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 90ae534:	defffb04 	addi	sp,sp,-20
 90ae538:	dfc00415 	stw	ra,16(sp)
 90ae53c:	df000315 	stw	fp,12(sp)
 90ae540:	df000304 	addi	fp,sp,12
 90ae544:	e13ffe15 	stw	r4,-8(fp)
 90ae548:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 90ae54c:	e0bffe17 	ldw	r2,-8(fp)
 90ae550:	1080088b 	ldhu	r2,34(r2)
 90ae554:	10bfffcc 	andi	r2,r2,65535
 90ae558:	1080004c 	andi	r2,r2,1
 90ae55c:	1004c03a 	cmpne	r2,r2,zero
 90ae560:	1000031e 	bne	r2,zero,90ae570 <soaccept+0x3c>
      panic("soaccept");
 90ae564:	01024374 	movhi	r4,2317
 90ae568:	213f6104 	addi	r4,r4,-636
 90ae56c:	90a438c0 	call	90a438c <panic>
   so->so_state &= ~SS_NOFDREF;
 90ae570:	e0bffe17 	ldw	r2,-8(fp)
 90ae574:	10c0088b 	ldhu	r3,34(r2)
 90ae578:	00bfff84 	movi	r2,-2
 90ae57c:	1884703a 	and	r2,r3,r2
 90ae580:	1007883a 	mov	r3,r2
 90ae584:	e0bffe17 	ldw	r2,-8(fp)
 90ae588:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 90ae58c:	e0fffe17 	ldw	r3,-8(fp)
 90ae590:	00800144 	movi	r2,5
 90ae594:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90ae598:	e0bffe17 	ldw	r2,-8(fp)
 90ae59c:	10800217 	ldw	r2,8(r2)
 90ae5a0:	10800317 	ldw	r2,12(r2)
 90ae5a4:	e13ffe17 	ldw	r4,-8(fp)
 90ae5a8:	000b883a 	mov	r5,zero
 90ae5ac:	e1bfff17 	ldw	r6,-4(fp)
 90ae5b0:	103ee83a 	callr	r2
 90ae5b4:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 90ae5b8:	e0bffd17 	ldw	r2,-12(fp)
}
 90ae5bc:	e037883a 	mov	sp,fp
 90ae5c0:	dfc00117 	ldw	ra,4(sp)
 90ae5c4:	df000017 	ldw	fp,0(sp)
 90ae5c8:	dec00204 	addi	sp,sp,8
 90ae5cc:	f800283a 	ret

090ae5d0 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 90ae5d0:	defffa04 	addi	sp,sp,-24
 90ae5d4:	dfc00515 	stw	ra,20(sp)
 90ae5d8:	df000415 	stw	fp,16(sp)
 90ae5dc:	df000404 	addi	fp,sp,16
 90ae5e0:	e13ffd15 	stw	r4,-12(fp)
 90ae5e4:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 90ae5e8:	e0bffd17 	ldw	r2,-12(fp)
 90ae5ec:	10800417 	ldw	r2,16(r2)
 90ae5f0:	1080008c 	andi	r2,r2,2
 90ae5f4:	1005003a 	cmpeq	r2,r2,zero
 90ae5f8:	1000031e 	bne	r2,zero,90ae608 <soconnect+0x38>
      return (EOPNOTSUPP);
 90ae5fc:	008017c4 	movi	r2,95
 90ae600:	e0bfff15 	stw	r2,-4(fp)
 90ae604:	00002106 	br	90ae68c <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 90ae608:	e0bffd17 	ldw	r2,-12(fp)
 90ae60c:	1080088b 	ldhu	r2,34(r2)
 90ae610:	10bfffcc 	andi	r2,r2,65535
 90ae614:	1080018c 	andi	r2,r2,6
 90ae618:	1005003a 	cmpeq	r2,r2,zero
 90ae61c:	10000e1e 	bne	r2,zero,90ae658 <soconnect+0x88>
 90ae620:	e0bffd17 	ldw	r2,-12(fp)
 90ae624:	10800217 	ldw	r2,8(r2)
 90ae628:	1080010b 	ldhu	r2,4(r2)
 90ae62c:	10bfffcc 	andi	r2,r2,65535
 90ae630:	1080010c 	andi	r2,r2,4
 90ae634:	1004c03a 	cmpne	r2,r2,zero
 90ae638:	1000041e 	bne	r2,zero,90ae64c <soconnect+0x7c>
 90ae63c:	e13ffd17 	ldw	r4,-12(fp)
 90ae640:	90ae6a40 	call	90ae6a4 <sodisconnect>
 90ae644:	1005003a 	cmpeq	r2,r2,zero
 90ae648:	1000031e 	bne	r2,zero,90ae658 <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 90ae64c:	00801fc4 	movi	r2,127
 90ae650:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 90ae654:	00000b06 	br	90ae684 <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 90ae658:	e0fffd17 	ldw	r3,-12(fp)
 90ae65c:	00800104 	movi	r2,4
 90ae660:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90ae664:	e0bffd17 	ldw	r2,-12(fp)
 90ae668:	10800217 	ldw	r2,8(r2)
 90ae66c:	10800317 	ldw	r2,12(r2)
 90ae670:	e13ffd17 	ldw	r4,-12(fp)
 90ae674:	000b883a 	mov	r5,zero
 90ae678:	e1bffe17 	ldw	r6,-8(fp)
 90ae67c:	103ee83a 	callr	r2
 90ae680:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 90ae684:	e0bffc17 	ldw	r2,-16(fp)
 90ae688:	e0bfff15 	stw	r2,-4(fp)
 90ae68c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae690:	e037883a 	mov	sp,fp
 90ae694:	dfc00117 	ldw	ra,4(sp)
 90ae698:	df000017 	ldw	fp,0(sp)
 90ae69c:	dec00204 	addi	sp,sp,8
 90ae6a0:	f800283a 	ret

090ae6a4 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 90ae6a4:	defffc04 	addi	sp,sp,-16
 90ae6a8:	dfc00315 	stw	ra,12(sp)
 90ae6ac:	df000215 	stw	fp,8(sp)
 90ae6b0:	df000204 	addi	fp,sp,8
 90ae6b4:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 90ae6b8:	e0bfff17 	ldw	r2,-4(fp)
 90ae6bc:	1080088b 	ldhu	r2,34(r2)
 90ae6c0:	10bfffcc 	andi	r2,r2,65535
 90ae6c4:	1080008c 	andi	r2,r2,2
 90ae6c8:	1004c03a 	cmpne	r2,r2,zero
 90ae6cc:	1000031e 	bne	r2,zero,90ae6dc <sodisconnect+0x38>
   {
      error = ENOTCONN;
 90ae6d0:	00802004 	movi	r2,128
 90ae6d4:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 90ae6d8:	00001406 	br	90ae72c <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 90ae6dc:	e0bfff17 	ldw	r2,-4(fp)
 90ae6e0:	1080088b 	ldhu	r2,34(r2)
 90ae6e4:	10bfffcc 	andi	r2,r2,65535
 90ae6e8:	1080020c 	andi	r2,r2,8
 90ae6ec:	1005003a 	cmpeq	r2,r2,zero
 90ae6f0:	1000031e 	bne	r2,zero,90ae700 <sodisconnect+0x5c>
   {
      error = EALREADY;
 90ae6f4:	00801e04 	movi	r2,120
 90ae6f8:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 90ae6fc:	00000b06 	br	90ae72c <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 90ae700:	e0ffff17 	ldw	r3,-4(fp)
 90ae704:	00800184 	movi	r2,6
 90ae708:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 90ae70c:	e0bfff17 	ldw	r2,-4(fp)
 90ae710:	10800217 	ldw	r2,8(r2)
 90ae714:	10800317 	ldw	r2,12(r2)
 90ae718:	e13fff17 	ldw	r4,-4(fp)
 90ae71c:	000b883a 	mov	r5,zero
 90ae720:	000d883a 	mov	r6,zero
 90ae724:	103ee83a 	callr	r2
 90ae728:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 90ae72c:	e0bffe17 	ldw	r2,-8(fp)
}
 90ae730:	e037883a 	mov	sp,fp
 90ae734:	dfc00117 	ldw	ra,4(sp)
 90ae738:	df000017 	ldw	fp,0(sp)
 90ae73c:	dec00204 	addi	sp,sp,8
 90ae740:	f800283a 	ret

090ae744 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 90ae744:	deffee04 	addi	sp,sp,-72
 90ae748:	dfc01115 	stw	ra,68(sp)
 90ae74c:	df001015 	stw	fp,64(sp)
 90ae750:	df001004 	addi	fp,sp,64
 90ae754:	e13ff815 	stw	r4,-32(fp)
 90ae758:	e17ff915 	stw	r5,-28(fp)
 90ae75c:	e1bffa15 	stw	r6,-24(fp)
 90ae760:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 90ae764:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 90ae768:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 90ae76c:	00800044 	movi	r2,1
 90ae770:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 90ae774:	e0bffb17 	ldw	r2,-20(fp)
 90ae778:	10800017 	ldw	r2,0(r2)
 90ae77c:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 90ae780:	e0bff417 	ldw	r2,-48(fp)
 90ae784:	1004403a 	cmpge	r2,r2,zero
 90ae788:	1000031e 	bne	r2,zero,90ae798 <sosend+0x54>
      return (EINVAL);
 90ae78c:	00800584 	movi	r2,22
 90ae790:	e0bfff15 	stw	r2,-4(fp)
 90ae794:	00016706 	br	90aed34 <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 90ae798:	e0bff817 	ldw	r2,-32(fp)
 90ae79c:	10800217 	ldw	r2,8(r2)
 90ae7a0:	1080010b 	ldhu	r2,4(r2)
 90ae7a4:	10bfffcc 	andi	r2,r2,65535
 90ae7a8:	1080004c 	andi	r2,r2,1
 90ae7ac:	10803fcc 	andi	r2,r2,255
 90ae7b0:	1005003a 	cmpeq	r2,r2,zero
 90ae7b4:	1000081e 	bne	r2,zero,90ae7d8 <sosend+0x94>
 90ae7b8:	e0bff817 	ldw	r2,-32(fp)
 90ae7bc:	10801317 	ldw	r2,76(r2)
 90ae7c0:	1007883a 	mov	r3,r2
 90ae7c4:	e0bff417 	ldw	r2,-48(fp)
 90ae7c8:	1880030e 	bge	r3,r2,90ae7d8 <sosend+0x94>
      return (EMSGSIZE);
 90ae7cc:	00c01e84 	movi	r3,122
 90ae7d0:	e0ffff15 	stw	r3,-4(fp)
 90ae7d4:	00015706 	br	90aed34 <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 90ae7d8:	e0800217 	ldw	r2,8(fp)
 90ae7dc:	1080010c 	andi	r2,r2,4
 90ae7e0:	1005003a 	cmpeq	r2,r2,zero
 90ae7e4:	1000111e 	bne	r2,zero,90ae82c <sosend+0xe8>
 90ae7e8:	e0bff817 	ldw	r2,-32(fp)
 90ae7ec:	10800417 	ldw	r2,16(r2)
 90ae7f0:	1080040c 	andi	r2,r2,16
 90ae7f4:	1004c03a 	cmpne	r2,r2,zero
 90ae7f8:	10000c1e 	bne	r2,zero,90ae82c <sosend+0xe8>
 90ae7fc:	e0bff817 	ldw	r2,-32(fp)
 90ae800:	10800217 	ldw	r2,8(r2)
 90ae804:	1080010b 	ldhu	r2,4(r2)
 90ae808:	10bfffcc 	andi	r2,r2,65535
 90ae80c:	1080004c 	andi	r2,r2,1
 90ae810:	1080005c 	xori	r2,r2,1
 90ae814:	10803fcc 	andi	r2,r2,255
 90ae818:	1004c03a 	cmpne	r2,r2,zero
 90ae81c:	1000031e 	bne	r2,zero,90ae82c <sosend+0xe8>
 90ae820:	00800044 	movi	r2,1
 90ae824:	e0bffe15 	stw	r2,-8(fp)
 90ae828:	00000106 	br	90ae830 <sosend+0xec>
 90ae82c:	e03ffe15 	stw	zero,-8(fp)
 90ae830:	e0fffe17 	ldw	r3,-8(fp)
 90ae834:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 90ae838:	00000406 	br	90ae84c <sosend+0x108>
 90ae83c:	e0bff817 	ldw	r2,-32(fp)
 90ae840:	10801904 	addi	r2,r2,100
 90ae844:	1009883a 	mov	r4,r2
 90ae848:	90a4d040 	call	90a4d04 <tcp_sleep>
 90ae84c:	e0bff817 	ldw	r2,-32(fp)
 90ae850:	1080190b 	ldhu	r2,100(r2)
 90ae854:	10bfffcc 	andi	r2,r2,65535
 90ae858:	1080004c 	andi	r2,r2,1
 90ae85c:	10803fcc 	andi	r2,r2,255
 90ae860:	1004c03a 	cmpne	r2,r2,zero
 90ae864:	103ff51e 	bne	r2,zero,90ae83c <sosend+0xf8>
 90ae868:	e0bff817 	ldw	r2,-32(fp)
 90ae86c:	1080190b 	ldhu	r2,100(r2)
 90ae870:	10800054 	ori	r2,r2,1
 90ae874:	1007883a 	mov	r3,r2
 90ae878:	e0bff817 	ldw	r2,-32(fp)
 90ae87c:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 90ae880:	e0bff817 	ldw	r2,-32(fp)
 90ae884:	10800617 	ldw	r2,24(r2)
 90ae888:	1005003a 	cmpeq	r2,r2,zero
 90ae88c:	1000061e 	bne	r2,zero,90ae8a8 <sosend+0x164>
      {
         error = so->so_error;
 90ae890:	e0bff817 	ldw	r2,-32(fp)
 90ae894:	10800617 	ldw	r2,24(r2)
 90ae898:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 90ae89c:	e0bff817 	ldw	r2,-32(fp)
 90ae8a0:	10000615 	stw	zero,24(r2)
         goto release;
 90ae8a4:	00011106 	br	90aecec <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 90ae8a8:	e0bff817 	ldw	r2,-32(fp)
 90ae8ac:	1080088b 	ldhu	r2,34(r2)
 90ae8b0:	10bfffcc 	andi	r2,r2,65535
 90ae8b4:	1080040c 	andi	r2,r2,16
 90ae8b8:	1005003a 	cmpeq	r2,r2,zero
 90ae8bc:	1000031e 	bne	r2,zero,90ae8cc <sosend+0x188>
         snderr(EPIPE);
 90ae8c0:	00800804 	movi	r2,32
 90ae8c4:	e0bff215 	stw	r2,-56(fp)
 90ae8c8:	00010806 	br	90aecec <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 90ae8cc:	e0bff817 	ldw	r2,-32(fp)
 90ae8d0:	1080088b 	ldhu	r2,34(r2)
 90ae8d4:	10bfffcc 	andi	r2,r2,65535
 90ae8d8:	1080008c 	andi	r2,r2,2
 90ae8dc:	1004c03a 	cmpne	r2,r2,zero
 90ae8e0:	1000101e 	bne	r2,zero,90ae924 <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 90ae8e4:	e0bff817 	ldw	r2,-32(fp)
 90ae8e8:	10800217 	ldw	r2,8(r2)
 90ae8ec:	1080010b 	ldhu	r2,4(r2)
 90ae8f0:	10bfffcc 	andi	r2,r2,65535
 90ae8f4:	1080010c 	andi	r2,r2,4
 90ae8f8:	1005003a 	cmpeq	r2,r2,zero
 90ae8fc:	1000031e 	bne	r2,zero,90ae90c <sosend+0x1c8>
            snderr(ENOTCONN);
 90ae900:	00802004 	movi	r2,128
 90ae904:	e0bff215 	stw	r2,-56(fp)
 90ae908:	0000f806 	br	90aecec <sosend+0x5a8>
         if (nam == 0)
 90ae90c:	e0bff917 	ldw	r2,-28(fp)
 90ae910:	1004c03a 	cmpne	r2,r2,zero
 90ae914:	1000031e 	bne	r2,zero,90ae924 <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 90ae918:	00801e44 	movi	r2,121
 90ae91c:	e0bff215 	stw	r2,-56(fp)
 90ae920:	0000f206 	br	90aecec <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 90ae924:	e0800217 	ldw	r2,8(fp)
 90ae928:	1080004c 	andi	r2,r2,1
 90ae92c:	10803fcc 	andi	r2,r2,255
 90ae930:	1005003a 	cmpeq	r2,r2,zero
 90ae934:	1000031e 	bne	r2,zero,90ae944 <sosend+0x200>
         space = 1024;
 90ae938:	00810004 	movi	r2,1024
 90ae93c:	e0bff515 	stw	r2,-44(fp)
 90ae940:	00005106 	br	90aea88 <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 90ae944:	e0bff817 	ldw	r2,-32(fp)
 90ae948:	10801317 	ldw	r2,76(r2)
 90ae94c:	1007883a 	mov	r3,r2
 90ae950:	e0bff817 	ldw	r2,-32(fp)
 90ae954:	10801217 	ldw	r2,72(r2)
 90ae958:	1885c83a 	sub	r2,r3,r2
 90ae95c:	1004803a 	cmplt	r2,r2,zero
 90ae960:	1000071e 	bne	r2,zero,90ae980 <sosend+0x23c>
 90ae964:	e0bff817 	ldw	r2,-32(fp)
 90ae968:	10c01317 	ldw	r3,76(r2)
 90ae96c:	e0bff817 	ldw	r2,-32(fp)
 90ae970:	10801217 	ldw	r2,72(r2)
 90ae974:	1885c83a 	sub	r2,r3,r2
 90ae978:	e0bffd15 	stw	r2,-12(fp)
 90ae97c:	00000106 	br	90ae984 <sosend+0x240>
 90ae980:	e03ffd15 	stw	zero,-12(fp)
 90ae984:	e0bffd17 	ldw	r2,-12(fp)
 90ae988:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 90ae98c:	e0bff817 	ldw	r2,-32(fp)
 90ae990:	10800217 	ldw	r2,8(r2)
 90ae994:	1080010b 	ldhu	r2,4(r2)
 90ae998:	10bfffcc 	andi	r2,r2,65535
 90ae99c:	1080004c 	andi	r2,r2,1
 90ae9a0:	1080005c 	xori	r2,r2,1
 90ae9a4:	10803fcc 	andi	r2,r2,255
 90ae9a8:	1004c03a 	cmpne	r2,r2,zero
 90ae9ac:	1000031e 	bne	r2,zero,90ae9bc <sosend+0x278>
 90ae9b0:	e0fff517 	ldw	r3,-44(fp)
 90ae9b4:	e0bff417 	ldw	r2,-48(fp)
 90ae9b8:	18801416 	blt	r3,r2,90aea0c <sosend+0x2c8>
 90ae9bc:	e0bff417 	ldw	r2,-48(fp)
 90ae9c0:	10815e10 	cmplti	r2,r2,1400
 90ae9c4:	1000301e 	bne	r2,zero,90aea88 <sosend+0x344>
 90ae9c8:	e0bff517 	ldw	r2,-44(fp)
 90ae9cc:	10815e08 	cmpgei	r2,r2,1400
 90ae9d0:	10002d1e 	bne	r2,zero,90aea88 <sosend+0x344>
 90ae9d4:	e0bff817 	ldw	r2,-32(fp)
 90ae9d8:	10801217 	ldw	r2,72(r2)
 90ae9dc:	10815e30 	cmpltui	r2,r2,1400
 90ae9e0:	1000291e 	bne	r2,zero,90aea88 <sosend+0x344>
 90ae9e4:	e0bff817 	ldw	r2,-32(fp)
 90ae9e8:	1080088b 	ldhu	r2,34(r2)
 90ae9ec:	10bfffcc 	andi	r2,r2,65535
 90ae9f0:	1080400c 	andi	r2,r2,256
 90ae9f4:	1004c03a 	cmpne	r2,r2,zero
 90ae9f8:	1000231e 	bne	r2,zero,90aea88 <sosend+0x344>
 90ae9fc:	e0800217 	ldw	r2,8(fp)
 90aea00:	1080080c 	andi	r2,r2,32
 90aea04:	1004c03a 	cmpne	r2,r2,zero
 90aea08:	10001f1e 	bne	r2,zero,90aea88 <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 90aea0c:	e0bff817 	ldw	r2,-32(fp)
 90aea10:	1080088b 	ldhu	r2,34(r2)
 90aea14:	10bfffcc 	andi	r2,r2,65535
 90aea18:	1080400c 	andi	r2,r2,256
 90aea1c:	1004c03a 	cmpne	r2,r2,zero
 90aea20:	1000041e 	bne	r2,zero,90aea34 <sosend+0x2f0>
 90aea24:	e0800217 	ldw	r2,8(fp)
 90aea28:	1080080c 	andi	r2,r2,32
 90aea2c:	1005003a 	cmpeq	r2,r2,zero
 90aea30:	1000061e 	bne	r2,zero,90aea4c <sosend+0x308>
            {
               if (first)
 90aea34:	e0bff017 	ldw	r2,-64(fp)
 90aea38:	1005003a 	cmpeq	r2,r2,zero
 90aea3c:	1000ab1e 	bne	r2,zero,90aecec <sosend+0x5a8>
                  error = EWOULDBLOCK;
 90aea40:	008002c4 	movi	r2,11
 90aea44:	e0bff215 	stw	r2,-56(fp)
               goto release;
 90aea48:	0000a806 	br	90aecec <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 90aea4c:	e0bff817 	ldw	r2,-32(fp)
 90aea50:	10c0190b 	ldhu	r3,100(r2)
 90aea54:	00bfff84 	movi	r2,-2
 90aea58:	1884703a 	and	r2,r3,r2
 90aea5c:	1007883a 	mov	r3,r2
 90aea60:	e0bff817 	ldw	r2,-32(fp)
 90aea64:	10c0190d 	sth	r3,100(r2)
 90aea68:	e0bff817 	ldw	r2,-32(fp)
 90aea6c:	10801904 	addi	r2,r2,100
 90aea70:	1009883a 	mov	r4,r2
 90aea74:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
            sbwait(&so->so_snd);
 90aea78:	e0bff817 	ldw	r2,-32(fp)
 90aea7c:	11001204 	addi	r4,r2,72
 90aea80:	90b088c0 	call	90b088c <sbwait>
            goto restart;
 90aea84:	003f7106 	br	90ae84c <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 90aea88:	e0bff517 	ldw	r2,-44(fp)
 90aea8c:	10800048 	cmpgei	r2,r2,1
 90aea90:	1000651e 	bne	r2,zero,90aec28 <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 90aea94:	e0bff817 	ldw	r2,-32(fp)
 90aea98:	1080088b 	ldhu	r2,34(r2)
 90aea9c:	10bfffcc 	andi	r2,r2,65535
 90aeaa0:	1080400c 	andi	r2,r2,256
 90aeaa4:	1004c03a 	cmpne	r2,r2,zero
 90aeaa8:	1000041e 	bne	r2,zero,90aeabc <sosend+0x378>
 90aeaac:	e0800217 	ldw	r2,8(fp)
 90aeab0:	1080080c 	andi	r2,r2,32
 90aeab4:	1005003a 	cmpeq	r2,r2,zero
 90aeab8:	1000061e 	bne	r2,zero,90aead4 <sosend+0x390>
         {
            if (first)     /* report first error */
 90aeabc:	e0bff017 	ldw	r2,-64(fp)
 90aeac0:	1005003a 	cmpeq	r2,r2,zero
 90aeac4:	1000891e 	bne	r2,zero,90aecec <sosend+0x5a8>
               error = EWOULDBLOCK;
 90aeac8:	008002c4 	movi	r2,11
 90aeacc:	e0bff215 	stw	r2,-56(fp)
            goto release;
 90aead0:	00008606 	br	90aecec <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 90aead4:	e0bff817 	ldw	r2,-32(fp)
 90aead8:	10c0190b 	ldhu	r3,100(r2)
 90aeadc:	00bfff84 	movi	r2,-2
 90aeae0:	1884703a 	and	r2,r3,r2
 90aeae4:	1007883a 	mov	r3,r2
 90aeae8:	e0bff817 	ldw	r2,-32(fp)
 90aeaec:	10c0190d 	sth	r3,100(r2)
 90aeaf0:	e0bff817 	ldw	r2,-32(fp)
 90aeaf4:	10801904 	addi	r2,r2,100
 90aeaf8:	1009883a 	mov	r4,r2
 90aeafc:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
         sbwait(&so->so_snd);
 90aeb00:	e0bff817 	ldw	r2,-32(fp)
 90aeb04:	11001204 	addi	r4,r2,72
 90aeb08:	90b088c0 	call	90b088c <sbwait>
         goto restart;
 90aeb0c:	003f4f06 	br	90ae84c <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 90aeb10:	e0bff417 	ldw	r2,-48(fp)
 90aeb14:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 90aeb18:	e0bff817 	ldw	r2,-32(fp)
 90aeb1c:	10800983 	ldbu	r2,38(r2)
 90aeb20:	10803fcc 	andi	r2,r2,255
 90aeb24:	1080201c 	xori	r2,r2,128
 90aeb28:	10bfe004 	addi	r2,r2,-128
 90aeb2c:	10800058 	cmpnei	r2,r2,1
 90aeb30:	1000181e 	bne	r2,zero,90aeb94 <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 90aeb34:	01000084 	movi	r4,2
 90aeb38:	e17ff317 	ldw	r5,-52(fp)
 90aeb3c:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aeb40:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 90aeb44:	e0bff617 	ldw	r2,-40(fp)
 90aeb48:	1004c03a 	cmpne	r2,r2,zero
 90aeb4c:	1000031e 	bne	r2,zero,90aeb5c <sosend+0x418>
               snderr(ENOBUFS);
 90aeb50:	00801a44 	movi	r2,105
 90aeb54:	e0bff215 	stw	r2,-56(fp)
 90aeb58:	00006406 	br	90aecec <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 90aeb5c:	e0bff617 	ldw	r2,-40(fp)
 90aeb60:	10c00317 	ldw	r3,12(r2)
 90aeb64:	e1bff317 	ldw	r6,-52(fp)
 90aeb68:	e0bffa17 	ldw	r2,-24(fp)
 90aeb6c:	1809883a 	mov	r4,r3
 90aeb70:	100b883a 	mov	r5,r2
 90aeb74:	90822780 	call	9082278 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 90aeb78:	e0bff817 	ldw	r2,-32(fp)
 90aeb7c:	1080190b 	ldhu	r2,100(r2)
 90aeb80:	10802014 	ori	r2,r2,128
 90aeb84:	1007883a 	mov	r3,r2
 90aeb88:	e0bff817 	ldw	r2,-32(fp)
 90aeb8c:	10c0190d 	sth	r3,100(r2)
 90aeb90:	00000706 	br	90aebb0 <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 90aeb94:	01000084 	movi	r4,2
 90aeb98:	000b883a 	mov	r5,zero
 90aeb9c:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aeba0:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 90aeba4:	e0fff617 	ldw	r3,-40(fp)
 90aeba8:	e0bffa17 	ldw	r2,-24(fp)
 90aebac:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 90aebb0:	e0bffb17 	ldw	r2,-20(fp)
 90aebb4:	10c00017 	ldw	r3,0(r2)
 90aebb8:	e0bff317 	ldw	r2,-52(fp)
 90aebbc:	1887c83a 	sub	r3,r3,r2
 90aebc0:	e0bffb17 	ldw	r2,-20(fp)
 90aebc4:	10c00015 	stw	r3,0(r2)
         resid -= len;
 90aebc8:	e0fff417 	ldw	r3,-48(fp)
 90aebcc:	e0bff317 	ldw	r2,-52(fp)
 90aebd0:	1885c83a 	sub	r2,r3,r2
 90aebd4:	e0bff415 	stw	r2,-48(fp)
         data += len;
 90aebd8:	e0bff317 	ldw	r2,-52(fp)
 90aebdc:	1007883a 	mov	r3,r2
 90aebe0:	e0bffa17 	ldw	r2,-24(fp)
 90aebe4:	10c5883a 	add	r2,r2,r3
 90aebe8:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 90aebec:	e0fff317 	ldw	r3,-52(fp)
 90aebf0:	e0bff617 	ldw	r2,-40(fp)
 90aebf4:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 90aebf8:	e0bff717 	ldw	r2,-36(fp)
 90aebfc:	1004c03a 	cmpne	r2,r2,zero
 90aec00:	1000021e 	bne	r2,zero,90aec0c <sosend+0x4c8>
            head = m;
 90aec04:	e0bff617 	ldw	r2,-40(fp)
 90aec08:	e0bff715 	stw	r2,-36(fp)
         if (error)
 90aec0c:	e0bff217 	ldw	r2,-56(fp)
 90aec10:	1004c03a 	cmpne	r2,r2,zero
 90aec14:	1000351e 	bne	r2,zero,90aecec <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 90aec18:	e0bffb17 	ldw	r2,-20(fp)
 90aec1c:	10800017 	ldw	r2,0(r2)
 90aec20:	10800050 	cmplti	r2,r2,1
 90aec24:	1000031e 	bne	r2,zero,90aec34 <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 90aec28:	e0bff517 	ldw	r2,-44(fp)
 90aec2c:	10800048 	cmpgei	r2,r2,1
 90aec30:	103fb71e 	bne	r2,zero,90aeb10 <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 90aec34:	e0bff117 	ldw	r2,-60(fp)
 90aec38:	1005003a 	cmpeq	r2,r2,zero
 90aec3c:	1000051e 	bne	r2,zero,90aec54 <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 90aec40:	e0bff817 	ldw	r2,-32(fp)
 90aec44:	10800417 	ldw	r2,16(r2)
 90aec48:	10c00414 	ori	r3,r2,16
 90aec4c:	e0bff817 	ldw	r2,-32(fp)
 90aec50:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 90aec54:	e0800217 	ldw	r2,8(fp)
 90aec58:	1080004c 	andi	r2,r2,1
 90aec5c:	10803fcc 	andi	r2,r2,255
 90aec60:	1005003a 	cmpeq	r2,r2,zero
 90aec64:	1000031e 	bne	r2,zero,90aec74 <sosend+0x530>
 90aec68:	00c00384 	movi	r3,14
 90aec6c:	e0fffc15 	stw	r3,-16(fp)
 90aec70:	00000206 	br	90aec7c <sosend+0x538>
 90aec74:	00800244 	movi	r2,9
 90aec78:	e0bffc15 	stw	r2,-16(fp)
 90aec7c:	e0bff817 	ldw	r2,-32(fp)
 90aec80:	e0fffc17 	ldw	r3,-16(fp)
 90aec84:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 90aec88:	e0bff817 	ldw	r2,-32(fp)
 90aec8c:	10800217 	ldw	r2,8(r2)
 90aec90:	10800317 	ldw	r2,12(r2)
 90aec94:	e13ff817 	ldw	r4,-32(fp)
 90aec98:	e17ff717 	ldw	r5,-36(fp)
 90aec9c:	e1bff917 	ldw	r6,-28(fp)
 90aeca0:	103ee83a 	callr	r2
 90aeca4:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 90aeca8:	e0bff117 	ldw	r2,-60(fp)
 90aecac:	1005003a 	cmpeq	r2,r2,zero
 90aecb0:	1000061e 	bne	r2,zero,90aeccc <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 90aecb4:	e0bff817 	ldw	r2,-32(fp)
 90aecb8:	10c00417 	ldw	r3,16(r2)
 90aecbc:	00bffbc4 	movi	r2,-17
 90aecc0:	1886703a 	and	r3,r3,r2
 90aecc4:	e0bff817 	ldw	r2,-32(fp)
 90aecc8:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 90aeccc:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 90aecd0:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 90aecd4:	e0bff417 	ldw	r2,-48(fp)
 90aecd8:	1005003a 	cmpeq	r2,r2,zero
 90aecdc:	1000031e 	bne	r2,zero,90aecec <sosend+0x5a8>
 90aece0:	e0bff217 	ldw	r2,-56(fp)
 90aece4:	1005003a 	cmpeq	r2,r2,zero
 90aece8:	103ee51e 	bne	r2,zero,90ae880 <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 90aecec:	e0bff817 	ldw	r2,-32(fp)
 90aecf0:	10c0190b 	ldhu	r3,100(r2)
 90aecf4:	00bfff84 	movi	r2,-2
 90aecf8:	1884703a 	and	r2,r3,r2
 90aecfc:	1007883a 	mov	r3,r2
 90aed00:	e0bff817 	ldw	r2,-32(fp)
 90aed04:	10c0190d 	sth	r3,100(r2)
 90aed08:	e0bff817 	ldw	r2,-32(fp)
 90aed0c:	10801904 	addi	r2,r2,100
 90aed10:	1009883a 	mov	r4,r2
 90aed14:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   if (head)
 90aed18:	e0bff717 	ldw	r2,-36(fp)
 90aed1c:	1005003a 	cmpeq	r2,r2,zero
 90aed20:	1000021e 	bne	r2,zero,90aed2c <sosend+0x5e8>
      m_freem(head);
 90aed24:	e13ff717 	ldw	r4,-36(fp)
 90aed28:	90aa5a40 	call	90aa5a4 <m_freem>
   return error;
 90aed2c:	e0bff217 	ldw	r2,-56(fp)
 90aed30:	e0bfff15 	stw	r2,-4(fp)
 90aed34:	e0bfff17 	ldw	r2,-4(fp)
}
 90aed38:	e037883a 	mov	sp,fp
 90aed3c:	dfc00117 	ldw	ra,4(sp)
 90aed40:	df000017 	ldw	fp,0(sp)
 90aed44:	dec00204 	addi	sp,sp,8
 90aed48:	f800283a 	ret

090aed4c <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 90aed4c:	defff104 	addi	sp,sp,-60
 90aed50:	dfc00e15 	stw	ra,56(sp)
 90aed54:	df000d15 	stw	fp,52(sp)
 90aed58:	df000d04 	addi	fp,sp,52
 90aed5c:	e13ffb15 	stw	r4,-20(fp)
 90aed60:	e17ffc15 	stw	r5,-16(fp)
 90aed64:	e1bffd15 	stw	r6,-12(fp)
 90aed68:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 90aed6c:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 90aed70:	e0bffb17 	ldw	r2,-20(fp)
 90aed74:	10800217 	ldw	r2,8(r2)
 90aed78:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 90aed7c:	e0bffc17 	ldw	r2,-16(fp)
 90aed80:	1005003a 	cmpeq	r2,r2,zero
 90aed84:	1000021e 	bne	r2,zero,90aed90 <soreceive+0x44>
      *aname = 0;
 90aed88:	e0bffc17 	ldw	r2,-16(fp)
 90aed8c:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 90aed90:	e0800217 	ldw	r2,8(fp)
 90aed94:	1080004c 	andi	r2,r2,1
 90aed98:	10803fcc 	andi	r2,r2,255
 90aed9c:	1005003a 	cmpeq	r2,r2,zero
 90aeda0:	10004d1e 	bne	r2,zero,90aeed8 <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 90aeda4:	01000044 	movi	r4,1
 90aeda8:	000b883a 	mov	r5,zero
 90aedac:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90aedb0:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 90aedb4:	e0bffa17 	ldw	r2,-24(fp)
 90aedb8:	1004c03a 	cmpne	r2,r2,zero
 90aedbc:	1000031e 	bne	r2,zero,90aedcc <soreceive+0x80>
         return ENOBUFS;
 90aedc0:	00801a44 	movi	r2,105
 90aedc4:	e0bfff15 	stw	r2,-4(fp)
 90aedc8:	0001d306 	br	90af518 <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 90aedcc:	e0800217 	ldw	r2,8(fp)
 90aedd0:	1080008c 	andi	r2,r2,2
 90aedd4:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 90aedd8:	e0fffb17 	ldw	r3,-20(fp)
 90aeddc:	00800344 	movi	r2,13
 90aede0:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 90aede4:	e0bff617 	ldw	r2,-40(fp)
 90aede8:	10800317 	ldw	r2,12(r2)
 90aedec:	e1bff317 	ldw	r6,-52(fp)
 90aedf0:	e13ffb17 	ldw	r4,-20(fp)
 90aedf4:	e17ffa17 	ldw	r5,-24(fp)
 90aedf8:	103ee83a 	callr	r2
 90aedfc:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 90aee00:	e0bff817 	ldw	r2,-32(fp)
 90aee04:	1004c03a 	cmpne	r2,r2,zero
 90aee08:	1000271e 	bne	r2,zero,90aeea8 <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 90aee0c:	e0bffe17 	ldw	r2,-8(fp)
 90aee10:	10800017 	ldw	r2,0(r2)
 90aee14:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 90aee18:	e0bffa17 	ldw	r2,-24(fp)
 90aee1c:	10800217 	ldw	r2,8(r2)
 90aee20:	1007883a 	mov	r3,r2
 90aee24:	e0bff917 	ldw	r2,-28(fp)
 90aee28:	1880030e 	bge	r3,r2,90aee38 <soreceive+0xec>
               len = m->m_len;
 90aee2c:	e0bffa17 	ldw	r2,-24(fp)
 90aee30:	10800217 	ldw	r2,8(r2)
 90aee34:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 90aee38:	e0bffa17 	ldw	r2,-24(fp)
 90aee3c:	10c00317 	ldw	r3,12(r2)
 90aee40:	e1bff917 	ldw	r6,-28(fp)
 90aee44:	e0bffd17 	ldw	r2,-12(fp)
 90aee48:	1009883a 	mov	r4,r2
 90aee4c:	180b883a 	mov	r5,r3
 90aee50:	90822780 	call	9082278 <memcpy>
            data += len;
 90aee54:	e0bff917 	ldw	r2,-28(fp)
 90aee58:	1007883a 	mov	r3,r2
 90aee5c:	e0bffd17 	ldw	r2,-12(fp)
 90aee60:	10c5883a 	add	r2,r2,r3
 90aee64:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 90aee68:	e0fffe17 	ldw	r3,-8(fp)
 90aee6c:	e0bff917 	ldw	r2,-28(fp)
 90aee70:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 90aee74:	e13ffa17 	ldw	r4,-24(fp)
 90aee78:	90aa4700 	call	90aa470 <m_free>
 90aee7c:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 90aee80:	e0bffe17 	ldw	r2,-8(fp)
 90aee84:	10800017 	ldw	r2,0(r2)
 90aee88:	1005003a 	cmpeq	r2,r2,zero
 90aee8c:	1000061e 	bne	r2,zero,90aeea8 <soreceive+0x15c>
 90aee90:	e0bff817 	ldw	r2,-32(fp)
 90aee94:	1004c03a 	cmpne	r2,r2,zero
 90aee98:	1000031e 	bne	r2,zero,90aeea8 <soreceive+0x15c>
 90aee9c:	e0bffa17 	ldw	r2,-24(fp)
 90aeea0:	1004c03a 	cmpne	r2,r2,zero
 90aeea4:	103fd91e 	bne	r2,zero,90aee0c <soreceive+0xc0>
      }

      if (m)
 90aeea8:	e0bffa17 	ldw	r2,-24(fp)
 90aeeac:	1005003a 	cmpeq	r2,r2,zero
 90aeeb0:	1000021e 	bne	r2,zero,90aeebc <soreceive+0x170>
         m_freem(m);
 90aeeb4:	e13ffa17 	ldw	r4,-24(fp)
 90aeeb8:	90aa5a40 	call	90aa5a4 <m_freem>
      return (error);
 90aeebc:	e0bff817 	ldw	r2,-32(fp)
 90aeec0:	e0bfff15 	stw	r2,-4(fp)
 90aeec4:	00019406 	br	90af518 <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 90aeec8:	e0bffb17 	ldw	r2,-20(fp)
 90aeecc:	10801104 	addi	r2,r2,68
 90aeed0:	1009883a 	mov	r4,r2
 90aeed4:	90a4d040 	call	90a4d04 <tcp_sleep>
 90aeed8:	e0bffb17 	ldw	r2,-20(fp)
 90aeedc:	1080110b 	ldhu	r2,68(r2)
 90aeee0:	10bfffcc 	andi	r2,r2,65535
 90aeee4:	1080004c 	andi	r2,r2,1
 90aeee8:	10803fcc 	andi	r2,r2,255
 90aeeec:	1004c03a 	cmpne	r2,r2,zero
 90aeef0:	103ff51e 	bne	r2,zero,90aeec8 <soreceive+0x17c>
 90aeef4:	e0bffb17 	ldw	r2,-20(fp)
 90aeef8:	1080110b 	ldhu	r2,68(r2)
 90aeefc:	10800054 	ori	r2,r2,1
 90aef00:	1007883a 	mov	r3,r2
 90aef04:	e0bffb17 	ldw	r2,-20(fp)
 90aef08:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 90aef0c:	e0bffb17 	ldw	r2,-20(fp)
 90aef10:	10800a17 	ldw	r2,40(r2)
 90aef14:	1004c03a 	cmpne	r2,r2,zero
 90aef18:	1000401e 	bne	r2,zero,90af01c <soreceive+0x2d0>
   {
      if (so->so_error) 
 90aef1c:	e0bffb17 	ldw	r2,-20(fp)
 90aef20:	10800617 	ldw	r2,24(r2)
 90aef24:	1005003a 	cmpeq	r2,r2,zero
 90aef28:	1000061e 	bne	r2,zero,90aef44 <soreceive+0x1f8>
      {
         error = so->so_error;
 90aef2c:	e0bffb17 	ldw	r2,-20(fp)
 90aef30:	10800617 	ldw	r2,24(r2)
 90aef34:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 90aef38:	e0bffb17 	ldw	r2,-20(fp)
 90aef3c:	10000615 	stw	zero,24(r2)
         goto release;
 90aef40:	00016806 	br	90af4e4 <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 90aef44:	e0bffb17 	ldw	r2,-20(fp)
 90aef48:	1080088b 	ldhu	r2,34(r2)
 90aef4c:	10bfffcc 	andi	r2,r2,65535
 90aef50:	1080080c 	andi	r2,r2,32
 90aef54:	1004c03a 	cmpne	r2,r2,zero
 90aef58:	1001621e 	bne	r2,zero,90af4e4 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 90aef5c:	e0bffb17 	ldw	r2,-20(fp)
 90aef60:	1080088b 	ldhu	r2,34(r2)
 90aef64:	10bfffcc 	andi	r2,r2,65535
 90aef68:	1080008c 	andi	r2,r2,2
 90aef6c:	1004c03a 	cmpne	r2,r2,zero
 90aef70:	10000a1e 	bne	r2,zero,90aef9c <soreceive+0x250>
 90aef74:	e0bffb17 	ldw	r2,-20(fp)
 90aef78:	10800217 	ldw	r2,8(r2)
 90aef7c:	1080010b 	ldhu	r2,4(r2)
 90aef80:	10bfffcc 	andi	r2,r2,65535
 90aef84:	1080010c 	andi	r2,r2,4
 90aef88:	1005003a 	cmpeq	r2,r2,zero
 90aef8c:	1000031e 	bne	r2,zero,90aef9c <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 90aef90:	00802004 	movi	r2,128
 90aef94:	e0bff815 	stw	r2,-32(fp)
         goto release;
 90aef98:	00015206 	br	90af4e4 <soreceive+0x798>
      }
      if (*datalen == 0)
 90aef9c:	e0bffe17 	ldw	r2,-8(fp)
 90aefa0:	10800017 	ldw	r2,0(r2)
 90aefa4:	1005003a 	cmpeq	r2,r2,zero
 90aefa8:	10014e1e 	bne	r2,zero,90af4e4 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 90aefac:	e0bffb17 	ldw	r2,-20(fp)
 90aefb0:	1080088b 	ldhu	r2,34(r2)
 90aefb4:	10bfffcc 	andi	r2,r2,65535
 90aefb8:	1080400c 	andi	r2,r2,256
 90aefbc:	1004c03a 	cmpne	r2,r2,zero
 90aefc0:	1000041e 	bne	r2,zero,90aefd4 <soreceive+0x288>
 90aefc4:	e0800217 	ldw	r2,8(fp)
 90aefc8:	1080080c 	andi	r2,r2,32
 90aefcc:	1005003a 	cmpeq	r2,r2,zero
 90aefd0:	1000031e 	bne	r2,zero,90aefe0 <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 90aefd4:	008002c4 	movi	r2,11
 90aefd8:	e0bff815 	stw	r2,-32(fp)
         goto release;
 90aefdc:	00014106 	br	90af4e4 <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 90aefe0:	e0bffb17 	ldw	r2,-20(fp)
 90aefe4:	10c0110b 	ldhu	r3,68(r2)
 90aefe8:	00bfff84 	movi	r2,-2
 90aefec:	1884703a 	and	r2,r3,r2
 90aeff0:	1007883a 	mov	r3,r2
 90aeff4:	e0bffb17 	ldw	r2,-20(fp)
 90aeff8:	10c0110d 	sth	r3,68(r2)
 90aeffc:	e0bffb17 	ldw	r2,-20(fp)
 90af000:	10801104 	addi	r2,r2,68
 90af004:	1009883a 	mov	r4,r2
 90af008:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
      sbwait(&so->so_rcv);
 90af00c:	e0bffb17 	ldw	r2,-20(fp)
 90af010:	11000a04 	addi	r4,r2,40
 90af014:	90b088c0 	call	90b088c <sbwait>
      goto restart;
 90af018:	003faf06 	br	90aeed8 <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 90af01c:	e0bffb17 	ldw	r2,-20(fp)
 90af020:	10801017 	ldw	r2,64(r2)
 90af024:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 90af028:	e0bffa17 	ldw	r2,-24(fp)
 90af02c:	1004c03a 	cmpne	r2,r2,zero
 90af030:	1000031e 	bne	r2,zero,90af040 <soreceive+0x2f4>
      panic("sorecv 1");
 90af034:	01024374 	movhi	r4,2317
 90af038:	213f6404 	addi	r4,r4,-624
 90af03c:	90a438c0 	call	90a438c <panic>
   nextrecord = m->m_act;
 90af040:	e0bffa17 	ldw	r2,-24(fp)
 90af044:	10800717 	ldw	r2,28(r2)
 90af048:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 90af04c:	e0bff617 	ldw	r2,-40(fp)
 90af050:	1080010b 	ldhu	r2,4(r2)
 90af054:	10bfffcc 	andi	r2,r2,65535
 90af058:	1080008c 	andi	r2,r2,2
 90af05c:	1005003a 	cmpeq	r2,r2,zero
 90af060:	1000451e 	bne	r2,zero,90af178 <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 90af064:	e0bffa17 	ldw	r2,-24(fp)
 90af068:	10800817 	ldw	r2,32(r2)
 90af06c:	10800260 	cmpeqi	r2,r2,9
 90af070:	1000081e 	bne	r2,zero,90af094 <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 90af074:	e0bffa17 	ldw	r2,-24(fp)
 90af078:	11400817 	ldw	r5,32(r2)
 90af07c:	01024374 	movhi	r4,2317
 90af080:	213f6704 	addi	r4,r4,-612
 90af084:	90825100 	call	9082510 <printf>
         panic("sorecv 2");
 90af088:	01024374 	movhi	r4,2317
 90af08c:	213f6d04 	addi	r4,r4,-588
 90af090:	90a438c0 	call	90a438c <panic>
      }
      if (flags & MSG_PEEK) 
 90af094:	e0800217 	ldw	r2,8(fp)
 90af098:	1080008c 	andi	r2,r2,2
 90af09c:	1005003a 	cmpeq	r2,r2,zero
 90af0a0:	1000101e 	bne	r2,zero,90af0e4 <soreceive+0x398>
      {
         if (aname)
 90af0a4:	e0bffc17 	ldw	r2,-16(fp)
 90af0a8:	1005003a 	cmpeq	r2,r2,zero
 90af0ac:	1000091e 	bne	r2,zero,90af0d4 <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 90af0b0:	e0bffa17 	ldw	r2,-24(fp)
 90af0b4:	10800217 	ldw	r2,8(r2)
 90af0b8:	100d883a 	mov	r6,r2
 90af0bc:	e13ffa17 	ldw	r4,-24(fp)
 90af0c0:	000b883a 	mov	r5,zero
 90af0c4:	90aa5e80 	call	90aa5e8 <m_copy>
 90af0c8:	1007883a 	mov	r3,r2
 90af0cc:	e0bffc17 	ldw	r2,-16(fp)
 90af0d0:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 90af0d4:	e0bffa17 	ldw	r2,-24(fp)
 90af0d8:	10800617 	ldw	r2,24(r2)
 90af0dc:	e0bffa15 	stw	r2,-24(fp)
 90af0e0:	00002506 	br	90af178 <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 90af0e4:	e0bffb17 	ldw	r2,-20(fp)
 90af0e8:	10c00a17 	ldw	r3,40(r2)
 90af0ec:	e0bffa17 	ldw	r2,-24(fp)
 90af0f0:	10800217 	ldw	r2,8(r2)
 90af0f4:	1887c83a 	sub	r3,r3,r2
 90af0f8:	e0bffb17 	ldw	r2,-20(fp)
 90af0fc:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 90af100:	e0bffc17 	ldw	r2,-16(fp)
 90af104:	1005003a 	cmpeq	r2,r2,zero
 90af108:	10000d1e 	bne	r2,zero,90af140 <soreceive+0x3f4>
         {
            *aname = m;
 90af10c:	e0fffc17 	ldw	r3,-16(fp)
 90af110:	e0bffa17 	ldw	r2,-24(fp)
 90af114:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 90af118:	e0bffa17 	ldw	r2,-24(fp)
 90af11c:	10800617 	ldw	r2,24(r2)
 90af120:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 90af124:	e0bffc17 	ldw	r2,-16(fp)
 90af128:	10800017 	ldw	r2,0(r2)
 90af12c:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 90af130:	e0fffb17 	ldw	r3,-20(fp)
 90af134:	e0bffa17 	ldw	r2,-24(fp)
 90af138:	18801015 	stw	r2,64(r3)
 90af13c:	00000806 	br	90af160 <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 90af140:	e13ffa17 	ldw	r4,-24(fp)
 90af144:	90aa4700 	call	90aa470 <m_free>
 90af148:	1007883a 	mov	r3,r2
 90af14c:	e0bffb17 	ldw	r2,-20(fp)
 90af150:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 90af154:	e0bffb17 	ldw	r2,-20(fp)
 90af158:	10801017 	ldw	r2,64(r2)
 90af15c:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 90af160:	e0bffa17 	ldw	r2,-24(fp)
 90af164:	1005003a 	cmpeq	r2,r2,zero
 90af168:	1000031e 	bne	r2,zero,90af178 <soreceive+0x42c>
            m->m_act = nextrecord;
 90af16c:	e0fffa17 	ldw	r3,-24(fp)
 90af170:	e0bff517 	ldw	r2,-44(fp)
 90af174:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 90af178:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 90af17c:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 90af180:	0000a606 	br	90af41c <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 90af184:	e0bffa17 	ldw	r2,-24(fp)
 90af188:	10800817 	ldw	r2,32(r2)
 90af18c:	10800060 	cmpeqi	r2,r2,1
 90af190:	1000071e 	bne	r2,zero,90af1b0 <soreceive+0x464>
 90af194:	e0bffa17 	ldw	r2,-24(fp)
 90af198:	10800817 	ldw	r2,32(r2)
 90af19c:	108000e0 	cmpeqi	r2,r2,3
 90af1a0:	1000031e 	bne	r2,zero,90af1b0 <soreceive+0x464>
         panic("sorecv 3");
 90af1a4:	01024374 	movhi	r4,2317
 90af1a8:	213f7004 	addi	r4,r4,-576
 90af1ac:	90a438c0 	call	90a438c <panic>
      len = *datalen;
 90af1b0:	e0bffe17 	ldw	r2,-8(fp)
 90af1b4:	10800017 	ldw	r2,0(r2)
 90af1b8:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 90af1bc:	e0bffb17 	ldw	r2,-20(fp)
 90af1c0:	10c0088b 	ldhu	r3,34(r2)
 90af1c4:	00bfefc4 	movi	r2,-65
 90af1c8:	1884703a 	and	r2,r3,r2
 90af1cc:	1007883a 	mov	r3,r2
 90af1d0:	e0bffb17 	ldw	r2,-20(fp)
 90af1d4:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 90af1d8:	e0bffb17 	ldw	r2,-20(fp)
 90af1dc:	10801a17 	ldw	r2,104(r2)
 90af1e0:	1005003a 	cmpeq	r2,r2,zero
 90af1e4:	10000c1e 	bne	r2,zero,90af218 <soreceive+0x4cc>
 90af1e8:	e0bffb17 	ldw	r2,-20(fp)
 90af1ec:	10c01a17 	ldw	r3,104(r2)
 90af1f0:	e0bff717 	ldw	r2,-36(fp)
 90af1f4:	1885c83a 	sub	r2,r3,r2
 90af1f8:	1007883a 	mov	r3,r2
 90af1fc:	e0bff917 	ldw	r2,-28(fp)
 90af200:	1880050e 	bge	r3,r2,90af218 <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 90af204:	e0bffb17 	ldw	r2,-20(fp)
 90af208:	10c01a17 	ldw	r3,104(r2)
 90af20c:	e0bff717 	ldw	r2,-36(fp)
 90af210:	1885c83a 	sub	r2,r3,r2
 90af214:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 90af218:	e0bffa17 	ldw	r2,-24(fp)
 90af21c:	10c00217 	ldw	r3,8(r2)
 90af220:	e0bff417 	ldw	r2,-48(fp)
 90af224:	1885c83a 	sub	r2,r3,r2
 90af228:	1007883a 	mov	r3,r2
 90af22c:	e0bff917 	ldw	r2,-28(fp)
 90af230:	1880050e 	bge	r3,r2,90af248 <soreceive+0x4fc>
         len = m->m_len - moff;
 90af234:	e0bffa17 	ldw	r2,-24(fp)
 90af238:	10c00217 	ldw	r3,8(r2)
 90af23c:	e0bff417 	ldw	r2,-48(fp)
 90af240:	1885c83a 	sub	r2,r3,r2
 90af244:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 90af248:	e0bffa17 	ldw	r2,-24(fp)
 90af24c:	10c00317 	ldw	r3,12(r2)
 90af250:	e0bff417 	ldw	r2,-48(fp)
 90af254:	1887883a 	add	r3,r3,r2
 90af258:	e1bff917 	ldw	r6,-28(fp)
 90af25c:	e0bffd17 	ldw	r2,-12(fp)
 90af260:	1009883a 	mov	r4,r2
 90af264:	180b883a 	mov	r5,r3
 90af268:	90822780 	call	9082278 <memcpy>
      data += len;
 90af26c:	e0bff917 	ldw	r2,-28(fp)
 90af270:	1007883a 	mov	r3,r2
 90af274:	e0bffd17 	ldw	r2,-12(fp)
 90af278:	10c5883a 	add	r2,r2,r3
 90af27c:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 90af280:	e0bffe17 	ldw	r2,-8(fp)
 90af284:	10c00017 	ldw	r3,0(r2)
 90af288:	e0bff917 	ldw	r2,-28(fp)
 90af28c:	1887c83a 	sub	r3,r3,r2
 90af290:	e0bffe17 	ldw	r2,-8(fp)
 90af294:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 90af298:	e0bffa17 	ldw	r2,-24(fp)
 90af29c:	10c00217 	ldw	r3,8(r2)
 90af2a0:	e0bff417 	ldw	r2,-48(fp)
 90af2a4:	1885c83a 	sub	r2,r3,r2
 90af2a8:	1007883a 	mov	r3,r2
 90af2ac:	e0bff917 	ldw	r2,-28(fp)
 90af2b0:	1880221e 	bne	r3,r2,90af33c <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 90af2b4:	e0800217 	ldw	r2,8(fp)
 90af2b8:	1080008c 	andi	r2,r2,2
 90af2bc:	1005003a 	cmpeq	r2,r2,zero
 90af2c0:	1000051e 	bne	r2,zero,90af2d8 <soreceive+0x58c>
         {
            m = m->m_next;
 90af2c4:	e0bffa17 	ldw	r2,-24(fp)
 90af2c8:	10800617 	ldw	r2,24(r2)
 90af2cc:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 90af2d0:	e03ff415 	stw	zero,-48(fp)
 90af2d4:	00003406 	br	90af3a8 <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 90af2d8:	e0bffa17 	ldw	r2,-24(fp)
 90af2dc:	10800717 	ldw	r2,28(r2)
 90af2e0:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 90af2e4:	e0bffb17 	ldw	r2,-20(fp)
 90af2e8:	10c00a17 	ldw	r3,40(r2)
 90af2ec:	e0bffa17 	ldw	r2,-24(fp)
 90af2f0:	10800217 	ldw	r2,8(r2)
 90af2f4:	1887c83a 	sub	r3,r3,r2
 90af2f8:	e0bffb17 	ldw	r2,-20(fp)
 90af2fc:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 90af300:	e13ffa17 	ldw	r4,-24(fp)
 90af304:	90aa4700 	call	90aa470 <m_free>
 90af308:	1007883a 	mov	r3,r2
 90af30c:	e0bffb17 	ldw	r2,-20(fp)
 90af310:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 90af314:	e0bffb17 	ldw	r2,-20(fp)
 90af318:	10801017 	ldw	r2,64(r2)
 90af31c:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 90af320:	e0bffa17 	ldw	r2,-24(fp)
 90af324:	1005003a 	cmpeq	r2,r2,zero
 90af328:	10001f1e 	bne	r2,zero,90af3a8 <soreceive+0x65c>
               m->m_act = nextrecord;
 90af32c:	e0fffa17 	ldw	r3,-24(fp)
 90af330:	e0bff517 	ldw	r2,-44(fp)
 90af334:	18800715 	stw	r2,28(r3)
 90af338:	00001b06 	br	90af3a8 <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 90af33c:	e0800217 	ldw	r2,8(fp)
 90af340:	1080008c 	andi	r2,r2,2
 90af344:	1005003a 	cmpeq	r2,r2,zero
 90af348:	1000051e 	bne	r2,zero,90af360 <soreceive+0x614>
            moff += len;
 90af34c:	e0bff417 	ldw	r2,-48(fp)
 90af350:	e0fff917 	ldw	r3,-28(fp)
 90af354:	10c5883a 	add	r2,r2,r3
 90af358:	e0bff415 	stw	r2,-48(fp)
 90af35c:	00001206 	br	90af3a8 <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 90af360:	e0bffa17 	ldw	r2,-24(fp)
 90af364:	10c00317 	ldw	r3,12(r2)
 90af368:	e0bff917 	ldw	r2,-28(fp)
 90af36c:	1887883a 	add	r3,r3,r2
 90af370:	e0bffa17 	ldw	r2,-24(fp)
 90af374:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 90af378:	e0bffa17 	ldw	r2,-24(fp)
 90af37c:	10c00217 	ldw	r3,8(r2)
 90af380:	e0bff917 	ldw	r2,-28(fp)
 90af384:	1887c83a 	sub	r3,r3,r2
 90af388:	e0bffa17 	ldw	r2,-24(fp)
 90af38c:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 90af390:	e0bffb17 	ldw	r2,-20(fp)
 90af394:	10c00a17 	ldw	r3,40(r2)
 90af398:	e0bff917 	ldw	r2,-28(fp)
 90af39c:	1887c83a 	sub	r3,r3,r2
 90af3a0:	e0bffb17 	ldw	r2,-20(fp)
 90af3a4:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 90af3a8:	e0bffb17 	ldw	r2,-20(fp)
 90af3ac:	10801a17 	ldw	r2,104(r2)
 90af3b0:	1005003a 	cmpeq	r2,r2,zero
 90af3b4:	1000191e 	bne	r2,zero,90af41c <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 90af3b8:	e0800217 	ldw	r2,8(fp)
 90af3bc:	1080008c 	andi	r2,r2,2
 90af3c0:	1004c03a 	cmpne	r2,r2,zero
 90af3c4:	1000111e 	bne	r2,zero,90af40c <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 90af3c8:	e0bffb17 	ldw	r2,-20(fp)
 90af3cc:	10c01a17 	ldw	r3,104(r2)
 90af3d0:	e0bff917 	ldw	r2,-28(fp)
 90af3d4:	1887c83a 	sub	r3,r3,r2
 90af3d8:	e0bffb17 	ldw	r2,-20(fp)
 90af3dc:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 90af3e0:	e0bffb17 	ldw	r2,-20(fp)
 90af3e4:	10801a17 	ldw	r2,104(r2)
 90af3e8:	1004c03a 	cmpne	r2,r2,zero
 90af3ec:	10000b1e 	bne	r2,zero,90af41c <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 90af3f0:	e0bffb17 	ldw	r2,-20(fp)
 90af3f4:	1080088b 	ldhu	r2,34(r2)
 90af3f8:	10801014 	ori	r2,r2,64
 90af3fc:	1007883a 	mov	r3,r2
 90af400:	e0bffb17 	ldw	r2,-20(fp)
 90af404:	10c0088d 	sth	r3,34(r2)
               break;
 90af408:	00000e06 	br	90af444 <soreceive+0x6f8>
            }
         } else
            offset += len;
 90af40c:	e0bff717 	ldw	r2,-36(fp)
 90af410:	e0fff917 	ldw	r3,-28(fp)
 90af414:	10c5883a 	add	r2,r2,r3
 90af418:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 90af41c:	e0bffa17 	ldw	r2,-24(fp)
 90af420:	1005003a 	cmpeq	r2,r2,zero
 90af424:	1000071e 	bne	r2,zero,90af444 <soreceive+0x6f8>
 90af428:	e0bffe17 	ldw	r2,-8(fp)
 90af42c:	10800017 	ldw	r2,0(r2)
 90af430:	10800050 	cmplti	r2,r2,1
 90af434:	1000031e 	bne	r2,zero,90af444 <soreceive+0x6f8>
 90af438:	e0bff817 	ldw	r2,-32(fp)
 90af43c:	1005003a 	cmpeq	r2,r2,zero
 90af440:	103f501e 	bne	r2,zero,90af184 <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 90af444:	e0800217 	ldw	r2,8(fp)
 90af448:	1080008c 	andi	r2,r2,2
 90af44c:	1004c03a 	cmpne	r2,r2,zero
 90af450:	1000241e 	bne	r2,zero,90af4e4 <soreceive+0x798>
   {
      if (m == 0)
 90af454:	e0bffa17 	ldw	r2,-24(fp)
 90af458:	1004c03a 	cmpne	r2,r2,zero
 90af45c:	1000041e 	bne	r2,zero,90af470 <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 90af460:	e0fffb17 	ldw	r3,-20(fp)
 90af464:	e0bff517 	ldw	r2,-44(fp)
 90af468:	18801015 	stw	r2,64(r3)
 90af46c:	00000a06 	br	90af498 <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 90af470:	e0bff617 	ldw	r2,-40(fp)
 90af474:	1080010b 	ldhu	r2,4(r2)
 90af478:	10bfffcc 	andi	r2,r2,65535
 90af47c:	1080004c 	andi	r2,r2,1
 90af480:	10803fcc 	andi	r2,r2,255
 90af484:	1005003a 	cmpeq	r2,r2,zero
 90af488:	1000031e 	bne	r2,zero,90af498 <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 90af48c:	e0bffb17 	ldw	r2,-20(fp)
 90af490:	11000a04 	addi	r4,r2,40
 90af494:	90b13a00 	call	90b13a0 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 90af498:	e0bff617 	ldw	r2,-40(fp)
 90af49c:	1080010b 	ldhu	r2,4(r2)
 90af4a0:	10bfffcc 	andi	r2,r2,65535
 90af4a4:	1080020c 	andi	r2,r2,8
 90af4a8:	1005003a 	cmpeq	r2,r2,zero
 90af4ac:	10000d1e 	bne	r2,zero,90af4e4 <soreceive+0x798>
 90af4b0:	e0bffb17 	ldw	r2,-20(fp)
 90af4b4:	10800117 	ldw	r2,4(r2)
 90af4b8:	1005003a 	cmpeq	r2,r2,zero
 90af4bc:	1000091e 	bne	r2,zero,90af4e4 <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 90af4c0:	e0fffb17 	ldw	r3,-20(fp)
 90af4c4:	00800204 	movi	r2,8
 90af4c8:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 90af4cc:	e0bff617 	ldw	r2,-40(fp)
 90af4d0:	10800317 	ldw	r2,12(r2)
 90af4d4:	e13ffb17 	ldw	r4,-20(fp)
 90af4d8:	000b883a 	mov	r5,zero
 90af4dc:	000d883a 	mov	r6,zero
 90af4e0:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 90af4e4:	e0bffb17 	ldw	r2,-20(fp)
 90af4e8:	10c0110b 	ldhu	r3,68(r2)
 90af4ec:	00bfff84 	movi	r2,-2
 90af4f0:	1884703a 	and	r2,r3,r2
 90af4f4:	1007883a 	mov	r3,r2
 90af4f8:	e0bffb17 	ldw	r2,-20(fp)
 90af4fc:	10c0110d 	sth	r3,68(r2)
 90af500:	e0bffb17 	ldw	r2,-20(fp)
 90af504:	10801104 	addi	r2,r2,68
 90af508:	1009883a 	mov	r4,r2
 90af50c:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   return (error);
 90af510:	e0bff817 	ldw	r2,-32(fp)
 90af514:	e0bfff15 	stw	r2,-4(fp)
 90af518:	e0bfff17 	ldw	r2,-4(fp)
}
 90af51c:	e037883a 	mov	sp,fp
 90af520:	dfc00117 	ldw	ra,4(sp)
 90af524:	df000017 	ldw	fp,0(sp)
 90af528:	dec00204 	addi	sp,sp,8
 90af52c:	f800283a 	ret

090af530 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 90af530:	defffb04 	addi	sp,sp,-20
 90af534:	dfc00415 	stw	ra,16(sp)
 90af538:	df000315 	stw	fp,12(sp)
 90af53c:	df000304 	addi	fp,sp,12
 90af540:	e13ffd15 	stw	r4,-12(fp)
 90af544:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 90af548:	e0bffe17 	ldw	r2,-8(fp)
 90af54c:	10800044 	addi	r2,r2,1
 90af550:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 90af554:	e0bffe17 	ldw	r2,-8(fp)
 90af558:	1080004c 	andi	r2,r2,1
 90af55c:	10803fcc 	andi	r2,r2,255
 90af560:	1005003a 	cmpeq	r2,r2,zero
 90af564:	1000021e 	bne	r2,zero,90af570 <soshutdown+0x40>
      sorflush(so);
 90af568:	e13ffd17 	ldw	r4,-12(fp)
 90af56c:	90af5d80 	call	90af5d8 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 90af570:	e0bffe17 	ldw	r2,-8(fp)
 90af574:	1080008c 	andi	r2,r2,2
 90af578:	1005003a 	cmpeq	r2,r2,zero
 90af57c:	10000f1e 	bne	r2,zero,90af5bc <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 90af580:	e0bffd17 	ldw	r2,-12(fp)
 90af584:	11001204 	addi	r4,r2,72
 90af588:	90b10300 	call	90b1030 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 90af58c:	e0fffd17 	ldw	r3,-12(fp)
 90af590:	008001c4 	movi	r2,7
 90af594:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 90af598:	e0bffd17 	ldw	r2,-12(fp)
 90af59c:	10800217 	ldw	r2,8(r2)
 90af5a0:	10800317 	ldw	r2,12(r2)
 90af5a4:	e13ffd17 	ldw	r4,-12(fp)
 90af5a8:	000b883a 	mov	r5,zero
 90af5ac:	000d883a 	mov	r6,zero
 90af5b0:	103ee83a 	callr	r2
 90af5b4:	e0bfff15 	stw	r2,-4(fp)
 90af5b8:	00000106 	br	90af5c0 <soshutdown+0x90>
   }

   return 0;
 90af5bc:	e03fff15 	stw	zero,-4(fp)
 90af5c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90af5c4:	e037883a 	mov	sp,fp
 90af5c8:	dfc00117 	ldw	ra,4(sp)
 90af5cc:	df000017 	ldw	fp,0(sp)
 90af5d0:	dec00204 	addi	sp,sp,8
 90af5d4:	f800283a 	ret

090af5d8 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 90af5d8:	defffb04 	addi	sp,sp,-20
 90af5dc:	dfc00415 	stw	ra,16(sp)
 90af5e0:	df000315 	stw	fp,12(sp)
 90af5e4:	df000304 	addi	fp,sp,12
 90af5e8:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 90af5ec:	e0bfff17 	ldw	r2,-4(fp)
 90af5f0:	10800a04 	addi	r2,r2,40
 90af5f4:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 90af5f8:	00000406 	br	90af60c <sorflush+0x34>
 90af5fc:	e0bffe17 	ldw	r2,-8(fp)
 90af600:	10800704 	addi	r2,r2,28
 90af604:	1009883a 	mov	r4,r2
 90af608:	90a4d040 	call	90a4d04 <tcp_sleep>
 90af60c:	e0bffe17 	ldw	r2,-8(fp)
 90af610:	1080070b 	ldhu	r2,28(r2)
 90af614:	10bfffcc 	andi	r2,r2,65535
 90af618:	1080004c 	andi	r2,r2,1
 90af61c:	10803fcc 	andi	r2,r2,255
 90af620:	1004c03a 	cmpne	r2,r2,zero
 90af624:	103ff51e 	bne	r2,zero,90af5fc <sorflush+0x24>
 90af628:	e0bffe17 	ldw	r2,-8(fp)
 90af62c:	1080070b 	ldhu	r2,28(r2)
 90af630:	10800054 	ori	r2,r2,1
 90af634:	1007883a 	mov	r3,r2
 90af638:	e0bffe17 	ldw	r2,-8(fp)
 90af63c:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 90af640:	e13fff17 	ldw	r4,-4(fp)
 90af644:	90b08040 	call	90b0804 <socantrcvmore>
   sbunlock(sb);
 90af648:	e0bffe17 	ldw	r2,-8(fp)
 90af64c:	10c0070b 	ldhu	r3,28(r2)
 90af650:	00bfff84 	movi	r2,-2
 90af654:	1884703a 	and	r2,r3,r2
 90af658:	1007883a 	mov	r3,r2
 90af65c:	e0bffe17 	ldw	r2,-8(fp)
 90af660:	10c0070d 	sth	r3,28(r2)
 90af664:	e0bffe17 	ldw	r2,-8(fp)
 90af668:	10800704 	addi	r2,r2,28
 90af66c:	1009883a 	mov	r4,r2
 90af670:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   sbrelease(sb);
 90af674:	e13ffe17 	ldw	r4,-8(fp)
 90af678:	90b0a700 	call	90b0a70 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 90af67c:	e0bffe17 	ldw	r2,-8(fp)
 90af680:	1009883a 	mov	r4,r2
 90af684:	01800804 	movi	r6,32
 90af688:	000b883a 	mov	r5,zero
 90af68c:	90823f80 	call	90823f8 <memset>
   s = so->so_error;
 90af690:	e0bfff17 	ldw	r2,-4(fp)
 90af694:	10800617 	ldw	r2,24(r2)
 90af698:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 90af69c:	e0ffff17 	ldw	r3,-4(fp)
 90af6a0:	00801b84 	movi	r2,110
 90af6a4:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 90af6a8:	e0bfff17 	ldw	r2,-4(fp)
 90af6ac:	11400a04 	addi	r5,r2,40
 90af6b0:	e13fff17 	ldw	r4,-4(fp)
 90af6b4:	90b08f40 	call	90b08f4 <sbwakeup>
   so->so_error = s;
 90af6b8:	e0ffff17 	ldw	r3,-4(fp)
 90af6bc:	e0bffd17 	ldw	r2,-12(fp)
 90af6c0:	18800615 	stw	r2,24(r3)
}
 90af6c4:	e037883a 	mov	sp,fp
 90af6c8:	dfc00117 	ldw	ra,4(sp)
 90af6cc:	df000017 	ldw	fp,0(sp)
 90af6d0:	dec00204 	addi	sp,sp,8
 90af6d4:	f800283a 	ret

090af6d8 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 90af6d8:	defff404 	addi	sp,sp,-48
 90af6dc:	dfc00b15 	stw	ra,44(sp)
 90af6e0:	df000a15 	stw	fp,40(sp)
 90af6e4:	df000a04 	addi	fp,sp,40
 90af6e8:	e13ffb15 	stw	r4,-20(fp)
 90af6ec:	e17ffc15 	stw	r5,-16(fp)
 90af6f0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90af6f4:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 90af6f8:	e0bffc17 	ldw	r2,-16(fp)
 90af6fc:	e0bfff15 	stw	r2,-4(fp)
 90af700:	e0ffff17 	ldw	r3,-4(fp)
 90af704:	18808020 	cmpeqi	r2,r3,512
 90af708:	1000521e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af70c:	e0ffff17 	ldw	r3,-4(fp)
 90af710:	18808048 	cmpgei	r2,r3,513
 90af714:	1000211e 	bne	r2,zero,90af79c <sosetopt+0xc4>
 90af718:	e0ffff17 	ldw	r3,-4(fp)
 90af71c:	18800388 	cmpgei	r2,r3,14
 90af720:	10000d1e 	bne	r2,zero,90af758 <sosetopt+0x80>
 90af724:	e0ffff17 	ldw	r3,-4(fp)
 90af728:	18800248 	cmpgei	r2,r3,9
 90af72c:	10009d1e 	bne	r2,zero,90af9a4 <sosetopt+0x2cc>
 90af730:	e0ffff17 	ldw	r3,-4(fp)
 90af734:	18800120 	cmpeqi	r2,r3,4
 90af738:	1000461e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af73c:	e0ffff17 	ldw	r3,-4(fp)
 90af740:	18800220 	cmpeqi	r2,r3,8
 90af744:	1000431e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af748:	e0ffff17 	ldw	r3,-4(fp)
 90af74c:	188000a0 	cmpeqi	r2,r3,2
 90af750:	10009a1e 	bne	r2,zero,90af9bc <sosetopt+0x2e4>
 90af754:	00010806 	br	90afb78 <sosetopt+0x4a0>
 90af758:	e0ffff17 	ldw	r3,-4(fp)
 90af75c:	18800820 	cmpeqi	r2,r3,32
 90af760:	10003c1e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af764:	e0ffff17 	ldw	r3,-4(fp)
 90af768:	18800848 	cmpgei	r2,r3,33
 90af76c:	1000041e 	bne	r2,zero,90af780 <sosetopt+0xa8>
 90af770:	e0ffff17 	ldw	r3,-4(fp)
 90af774:	18800420 	cmpeqi	r2,r3,16
 90af778:	1000361e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af77c:	0000fe06 	br	90afb78 <sosetopt+0x4a0>
 90af780:	e0ffff17 	ldw	r3,-4(fp)
 90af784:	18802020 	cmpeqi	r2,r3,128
 90af788:	10002d1e 	bne	r2,zero,90af840 <sosetopt+0x168>
 90af78c:	e0ffff17 	ldw	r3,-4(fp)
 90af790:	18804020 	cmpeqi	r2,r3,256
 90af794:	10002f1e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af798:	0000f706 	br	90afb78 <sosetopt+0x4a0>
 90af79c:	e0ffff17 	ldw	r3,-4(fp)
 90af7a0:	18840520 	cmpeqi	r2,r3,4116
 90af7a4:	1000571e 	bne	r2,zero,90af904 <sosetopt+0x22c>
 90af7a8:	e0ffff17 	ldw	r3,-4(fp)
 90af7ac:	18840548 	cmpgei	r2,r3,4117
 90af7b0:	10000f1e 	bne	r2,zero,90af7f0 <sosetopt+0x118>
 90af7b4:	e0ffff17 	ldw	r3,-4(fp)
 90af7b8:	188401a0 	cmpeqi	r2,r3,4102
 90af7bc:	10004c1e 	bne	r2,zero,90af8f0 <sosetopt+0x218>
 90af7c0:	e0ffff17 	ldw	r3,-4(fp)
 90af7c4:	188401c8 	cmpgei	r2,r3,4103
 90af7c8:	1000051e 	bne	r2,zero,90af7e0 <sosetopt+0x108>
 90af7cc:	e0ffff17 	ldw	r3,-4(fp)
 90af7d0:	18bbffc4 	addi	r2,r3,-4097
 90af7d4:	108000a8 	cmpgeui	r2,r2,2
 90af7d8:	1000e71e 	bne	r2,zero,90afb78 <sosetopt+0x4a0>
 90af7dc:	00003006 	br	90af8a0 <sosetopt+0x1c8>
 90af7e0:	e0ffff17 	ldw	r3,-4(fp)
 90af7e4:	18840420 	cmpeqi	r2,r3,4112
 90af7e8:	1000ba1e 	bne	r2,zero,90afad4 <sosetopt+0x3fc>
 90af7ec:	0000e206 	br	90afb78 <sosetopt+0x4a0>
 90af7f0:	e0ffff17 	ldw	r3,-4(fp)
 90af7f4:	188800e0 	cmpeqi	r2,r3,8195
 90af7f8:	1000b61e 	bne	r2,zero,90afad4 <sosetopt+0x3fc>
 90af7fc:	e0ffff17 	ldw	r3,-4(fp)
 90af800:	18880108 	cmpgei	r2,r3,8196
 90af804:	1000071e 	bne	r2,zero,90af824 <sosetopt+0x14c>
 90af808:	e0ffff17 	ldw	r3,-4(fp)
 90af80c:	18840560 	cmpeqi	r2,r3,4117
 90af810:	1000431e 	bne	r2,zero,90af920 <sosetopt+0x248>
 90af814:	e0ffff17 	ldw	r3,-4(fp)
 90af818:	188405a0 	cmpeqi	r2,r3,4118
 90af81c:	1000481e 	bne	r2,zero,90af940 <sosetopt+0x268>
 90af820:	0000d506 	br	90afb78 <sosetopt+0x4a0>
 90af824:	e0ffff17 	ldw	r3,-4(fp)
 90af828:	18880120 	cmpeqi	r2,r3,8196
 90af82c:	10007a1e 	bne	r2,zero,90afa18 <sosetopt+0x340>
 90af830:	e0ffff17 	ldw	r3,-4(fp)
 90af834:	18900020 	cmpeqi	r2,r3,16384
 90af838:	1000061e 	bne	r2,zero,90af854 <sosetopt+0x17c>
 90af83c:	0000ce06 	br	90afb78 <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 90af840:	e0bffd17 	ldw	r2,-12(fp)
 90af844:	10800117 	ldw	r2,4(r2)
 90af848:	1007883a 	mov	r3,r2
 90af84c:	e0bffb17 	ldw	r2,-20(fp)
 90af850:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 90af854:	e0bffd17 	ldw	r2,-12(fp)
 90af858:	10800017 	ldw	r2,0(r2)
 90af85c:	1005003a 	cmpeq	r2,r2,zero
 90af860:	1000071e 	bne	r2,zero,90af880 <sosetopt+0x1a8>
         so->so_options |= optname;
 90af864:	e0bffb17 	ldw	r2,-20(fp)
 90af868:	10c00417 	ldw	r3,16(r2)
 90af86c:	e0bffc17 	ldw	r2,-16(fp)
 90af870:	1886b03a 	or	r3,r3,r2
 90af874:	e0bffb17 	ldw	r2,-20(fp)
 90af878:	10c00415 	stw	r3,16(r2)
 90af87c:	0000c006 	br	90afb80 <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 90af880:	e0bffb17 	ldw	r2,-20(fp)
 90af884:	10c00417 	ldw	r3,16(r2)
 90af888:	e0bffc17 	ldw	r2,-16(fp)
 90af88c:	0084303a 	nor	r2,zero,r2
 90af890:	1886703a 	and	r3,r3,r2
 90af894:	e0bffb17 	ldw	r2,-20(fp)
 90af898:	10c00415 	stw	r3,16(r2)
      break;
 90af89c:	0000b806 	br	90afb80 <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 90af8a0:	e0bffc17 	ldw	r2,-16(fp)
 90af8a4:	10840058 	cmpnei	r2,r2,4097
 90af8a8:	1000041e 	bne	r2,zero,90af8bc <sosetopt+0x1e4>
 90af8ac:	e0bffb17 	ldw	r2,-20(fp)
 90af8b0:	10801204 	addi	r2,r2,72
 90af8b4:	e0bffe15 	stw	r2,-8(fp)
 90af8b8:	00000306 	br	90af8c8 <sosetopt+0x1f0>
 90af8bc:	e0bffb17 	ldw	r2,-20(fp)
 90af8c0:	10800a04 	addi	r2,r2,40
 90af8c4:	e0bffe15 	stw	r2,-8(fp)
 90af8c8:	e0bffd17 	ldw	r2,-12(fp)
 90af8cc:	10800017 	ldw	r2,0(r2)
 90af8d0:	100b883a 	mov	r5,r2
 90af8d4:	e13ffe17 	ldw	r4,-8(fp)
 90af8d8:	90b0a100 	call	90b0a10 <sbreserve>
 90af8dc:	1004c03a 	cmpne	r2,r2,zero
 90af8e0:	1000a71e 	bne	r2,zero,90afb80 <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 90af8e4:	00801a44 	movi	r2,105
 90af8e8:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 90af8ec:	0000a406 	br	90afb80 <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 90af8f0:	e0bffd17 	ldw	r2,-12(fp)
 90af8f4:	10c0000b 	ldhu	r3,0(r2)
 90af8f8:	e0bffb17 	ldw	r2,-20(fp)
 90af8fc:	10c0118d 	sth	r3,70(r2)
      break;
 90af900:	00009f06 	br	90afb80 <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 90af904:	e0bffb17 	ldw	r2,-20(fp)
 90af908:	1080088b 	ldhu	r2,34(r2)
 90af90c:	10804014 	ori	r2,r2,256
 90af910:	1007883a 	mov	r3,r2
 90af914:	e0bffb17 	ldw	r2,-20(fp)
 90af918:	10c0088d 	sth	r3,34(r2)
      break;
 90af91c:	00009806 	br	90afb80 <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 90af920:	e0bffb17 	ldw	r2,-20(fp)
 90af924:	10c0088b 	ldhu	r3,34(r2)
 90af928:	00bfbfc4 	movi	r2,-257
 90af92c:	1884703a 	and	r2,r3,r2
 90af930:	1007883a 	mov	r3,r2
 90af934:	e0bffb17 	ldw	r2,-20(fp)
 90af938:	10c0088d 	sth	r3,34(r2)
      break;
 90af93c:	00009006 	br	90afb80 <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 90af940:	e0bffd17 	ldw	r2,-12(fp)
 90af944:	1004c03a 	cmpne	r2,r2,zero
 90af948:	1000031e 	bne	r2,zero,90af958 <sosetopt+0x280>
      {
         error = ENP_PARAM;
 90af94c:	00bffd84 	movi	r2,-10
 90af950:	e0bffa15 	stw	r2,-24(fp)
         break;
 90af954:	00008a06 	br	90afb80 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 90af958:	e0bffd17 	ldw	r2,-12(fp)
 90af95c:	10800017 	ldw	r2,0(r2)
 90af960:	1005003a 	cmpeq	r2,r2,zero
 90af964:	1000071e 	bne	r2,zero,90af984 <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 90af968:	e0bffb17 	ldw	r2,-20(fp)
 90af96c:	1080088b 	ldhu	r2,34(r2)
 90af970:	10804014 	ori	r2,r2,256
 90af974:	1007883a 	mov	r3,r2
 90af978:	e0bffb17 	ldw	r2,-20(fp)
 90af97c:	10c0088d 	sth	r3,34(r2)
 90af980:	00007f06 	br	90afb80 <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 90af984:	e0bffb17 	ldw	r2,-20(fp)
 90af988:	10c0088b 	ldhu	r3,34(r2)
 90af98c:	00bfbfc4 	movi	r2,-257
 90af990:	1884703a 	and	r2,r3,r2
 90af994:	1007883a 	mov	r3,r2
 90af998:	e0bffb17 	ldw	r2,-20(fp)
 90af99c:	10c0088d 	sth	r3,34(r2)
      break;
 90af9a0:	00007706 	br	90afb80 <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 90af9a4:	e13ffc17 	ldw	r4,-16(fp)
 90af9a8:	e17ffb17 	ldw	r5,-20(fp)
 90af9ac:	e1bffd17 	ldw	r6,-12(fp)
 90af9b0:	90c48ac0 	call	90c48ac <ip_setmoptions>
 90af9b4:	e0bffa15 	stw	r2,-24(fp)
      break;
 90af9b8:	00007106 	br	90afb80 <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 90af9bc:	e0bffd17 	ldw	r2,-12(fp)
 90af9c0:	1004c03a 	cmpne	r2,r2,zero
 90af9c4:	1000031e 	bne	r2,zero,90af9d4 <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 90af9c8:	00bffd84 	movi	r2,-10
 90af9cc:	e0bffa15 	stw	r2,-24(fp)
         break;
 90af9d0:	00006b06 	br	90afb80 <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 90af9d4:	e0bffd17 	ldw	r2,-12(fp)
 90af9d8:	10800017 	ldw	r2,0(r2)
 90af9dc:	1005003a 	cmpeq	r2,r2,zero
 90af9e0:	1000061e 	bne	r2,zero,90af9fc <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 90af9e4:	e0bffb17 	ldw	r2,-20(fp)
 90af9e8:	10800417 	ldw	r2,16(r2)
 90af9ec:	10c80014 	ori	r3,r2,8192
 90af9f0:	e0bffb17 	ldw	r2,-20(fp)
 90af9f4:	10c00415 	stw	r3,16(r2)
 90af9f8:	00006106 	br	90afb80 <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 90af9fc:	e0bffb17 	ldw	r2,-20(fp)
 90afa00:	10c00417 	ldw	r3,16(r2)
 90afa04:	00b7ffc4 	movi	r2,-8193
 90afa08:	1886703a 	and	r3,r3,r2
 90afa0c:	e0bffb17 	ldw	r2,-20(fp)
 90afa10:	10c00415 	stw	r3,16(r2)
      break;
 90afa14:	00005a06 	br	90afb80 <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90afa18:	e0bffb17 	ldw	r2,-20(fp)
 90afa1c:	10800983 	ldbu	r2,38(r2)
 90afa20:	10803fcc 	andi	r2,r2,255
 90afa24:	1080201c 	xori	r2,r2,128
 90afa28:	10bfe004 	addi	r2,r2,-128
 90afa2c:	10800060 	cmpeqi	r2,r2,1
 90afa30:	1000031e 	bne	r2,zero,90afa40 <sosetopt+0x368>
      {
         error = EINVAL;
 90afa34:	00800584 	movi	r2,22
 90afa38:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afa3c:	00005006 	br	90afb80 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90afa40:	e0bffb17 	ldw	r2,-20(fp)
 90afa44:	10800117 	ldw	r2,4(r2)
 90afa48:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 90afa4c:	e0bff917 	ldw	r2,-28(fp)
 90afa50:	10800917 	ldw	r2,36(r2)
 90afa54:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 90afa58:	e0bff817 	ldw	r2,-32(fp)
 90afa5c:	1004c03a 	cmpne	r2,r2,zero
 90afa60:	1000031e 	bne	r2,zero,90afa70 <sosetopt+0x398>
      {
         error = ENOTCONN;
 90afa64:	00802004 	movi	r2,128
 90afa68:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afa6c:	00004406 	br	90afb80 <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 90afa70:	e0bffd17 	ldw	r2,-12(fp)
 90afa74:	1004c03a 	cmpne	r2,r2,zero
 90afa78:	1000031e 	bne	r2,zero,90afa88 <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 90afa7c:	00bffd84 	movi	r2,-10
 90afa80:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afa84:	00003e06 	br	90afb80 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 90afa88:	e0bffd17 	ldw	r2,-12(fp)
 90afa8c:	10800017 	ldw	r2,0(r2)
 90afa90:	1005003a 	cmpeq	r2,r2,zero
 90afa94:	1000071e 	bne	r2,zero,90afab4 <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 90afa98:	e0bff817 	ldw	r2,-32(fp)
 90afa9c:	10800b0b 	ldhu	r2,44(r2)
 90afaa0:	10800114 	ori	r2,r2,4
 90afaa4:	1007883a 	mov	r3,r2
 90afaa8:	e0bff817 	ldw	r2,-32(fp)
 90afaac:	10c00b0d 	sth	r3,44(r2)
 90afab0:	00003306 	br	90afb80 <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 90afab4:	e0bff817 	ldw	r2,-32(fp)
 90afab8:	10c00b0b 	ldhu	r3,44(r2)
 90afabc:	00bffec4 	movi	r2,-5
 90afac0:	1884703a 	and	r2,r3,r2
 90afac4:	1007883a 	mov	r3,r2
 90afac8:	e0bff817 	ldw	r2,-32(fp)
 90afacc:	10c00b0d 	sth	r3,44(r2)

      break;
 90afad0:	00002b06 	br	90afb80 <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90afad4:	e0bffb17 	ldw	r2,-20(fp)
 90afad8:	10800983 	ldbu	r2,38(r2)
 90afadc:	10803fcc 	andi	r2,r2,255
 90afae0:	1080201c 	xori	r2,r2,128
 90afae4:	10bfe004 	addi	r2,r2,-128
 90afae8:	10800060 	cmpeqi	r2,r2,1
 90afaec:	1000031e 	bne	r2,zero,90afafc <sosetopt+0x424>
      {
         error = EINVAL;
 90afaf0:	00800584 	movi	r2,22
 90afaf4:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afaf8:	00002106 	br	90afb80 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90afafc:	e0bffb17 	ldw	r2,-20(fp)
 90afb00:	10800117 	ldw	r2,4(r2)
 90afb04:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 90afb08:	e0bff717 	ldw	r2,-36(fp)
 90afb0c:	10800917 	ldw	r2,36(r2)
 90afb10:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 90afb14:	e0bff617 	ldw	r2,-40(fp)
 90afb18:	1004c03a 	cmpne	r2,r2,zero
 90afb1c:	1000031e 	bne	r2,zero,90afb2c <sosetopt+0x454>
      {
         error = ENOTCONN;
 90afb20:	00802004 	movi	r2,128
 90afb24:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afb28:	00001506 	br	90afb80 <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 90afb2c:	e0bff617 	ldw	r2,-40(fp)
 90afb30:	10800217 	ldw	r2,8(r2)
 90afb34:	1005003a 	cmpeq	r2,r2,zero
 90afb38:	1000031e 	bne	r2,zero,90afb48 <sosetopt+0x470>
      {
         error = EINVAL;
 90afb3c:	00800584 	movi	r2,22
 90afb40:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afb44:	00000e06 	br	90afb80 <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 90afb48:	e0bffd17 	ldw	r2,-12(fp)
 90afb4c:	10800017 	ldw	r2,0(r2)
 90afb50:	1007883a 	mov	r3,r2
 90afb54:	e0bff617 	ldw	r2,-40(fp)
 90afb58:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 90afb5c:	e0bff617 	ldw	r2,-40(fp)
 90afb60:	10800b0b 	ldhu	r2,44(r2)
 90afb64:	10810014 	ori	r2,r2,1024
 90afb68:	1007883a 	mov	r3,r2
 90afb6c:	e0bff617 	ldw	r2,-40(fp)
 90afb70:	10c00b0d 	sth	r3,44(r2)
      break;
 90afb74:	00000206 	br	90afb80 <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 90afb78:	00801b44 	movi	r2,109
 90afb7c:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 90afb80:	e0bffa17 	ldw	r2,-24(fp)
}
 90afb84:	e037883a 	mov	sp,fp
 90afb88:	dfc00117 	ldw	ra,4(sp)
 90afb8c:	df000017 	ldw	fp,0(sp)
 90afb90:	dec00204 	addi	sp,sp,8
 90afb94:	f800283a 	ret

090afb98 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 90afb98:	defff304 	addi	sp,sp,-52
 90afb9c:	dfc00c15 	stw	ra,48(sp)
 90afba0:	df000b15 	stw	fp,44(sp)
 90afba4:	df000b04 	addi	fp,sp,44
 90afba8:	e13ffb15 	stw	r4,-20(fp)
 90afbac:	e17ffc15 	stw	r5,-16(fp)
 90afbb0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90afbb4:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 90afbb8:	e0bffd17 	ldw	r2,-12(fp)
 90afbbc:	1004c03a 	cmpne	r2,r2,zero
 90afbc0:	1000031e 	bne	r2,zero,90afbd0 <sogetopt+0x38>
   {
      return ENP_PARAM;
 90afbc4:	00bffd84 	movi	r2,-10
 90afbc8:	e0bffe15 	stw	r2,-8(fp)
 90afbcc:	00013c06 	br	90b00c0 <sogetopt+0x528>
   }

   switch (optname) 
 90afbd0:	e0fffc17 	ldw	r3,-16(fp)
 90afbd4:	e0ffff15 	stw	r3,-4(fp)
 90afbd8:	e0ffff17 	ldw	r3,-4(fp)
 90afbdc:	188400e0 	cmpeqi	r2,r3,4099
 90afbe0:	10008f1e 	bne	r2,zero,90afe20 <sogetopt+0x288>
 90afbe4:	e0ffff17 	ldw	r3,-4(fp)
 90afbe8:	18840108 	cmpgei	r2,r3,4100
 90afbec:	10002e1e 	bne	r2,zero,90afca8 <sogetopt+0x110>
 90afbf0:	e0ffff17 	ldw	r3,-4(fp)
 90afbf4:	18800420 	cmpeqi	r2,r3,16
 90afbf8:	1000821e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afbfc:	e0ffff17 	ldw	r3,-4(fp)
 90afc00:	18800448 	cmpgei	r2,r3,17
 90afc04:	1000111e 	bne	r2,zero,90afc4c <sogetopt+0xb4>
 90afc08:	e0ffff17 	ldw	r3,-4(fp)
 90afc0c:	18800220 	cmpeqi	r2,r3,8
 90afc10:	10007c1e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afc14:	e0ffff17 	ldw	r3,-4(fp)
 90afc18:	18800248 	cmpgei	r2,r3,9
 90afc1c:	1000071e 	bne	r2,zero,90afc3c <sogetopt+0xa4>
 90afc20:	e0ffff17 	ldw	r3,-4(fp)
 90afc24:	188000a0 	cmpeqi	r2,r3,2
 90afc28:	1000eb1e 	bne	r2,zero,90affd8 <sogetopt+0x440>
 90afc2c:	e0ffff17 	ldw	r3,-4(fp)
 90afc30:	18800120 	cmpeqi	r2,r3,4
 90afc34:	1000731e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afc38:	00011c06 	br	90b00ac <sogetopt+0x514>
 90afc3c:	e0ffff17 	ldw	r3,-4(fp)
 90afc40:	18800308 	cmpgei	r2,r3,12
 90afc44:	1001191e 	bne	r2,zero,90b00ac <sogetopt+0x514>
 90afc48:	0000dd06 	br	90affc0 <sogetopt+0x428>
 90afc4c:	e0ffff17 	ldw	r3,-4(fp)
 90afc50:	18804020 	cmpeqi	r2,r3,256
 90afc54:	10006b1e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afc58:	e0ffff17 	ldw	r3,-4(fp)
 90afc5c:	18804048 	cmpgei	r2,r3,257
 90afc60:	1000071e 	bne	r2,zero,90afc80 <sogetopt+0xe8>
 90afc64:	e0ffff17 	ldw	r3,-4(fp)
 90afc68:	18800820 	cmpeqi	r2,r3,32
 90afc6c:	1000651e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afc70:	e0ffff17 	ldw	r3,-4(fp)
 90afc74:	18802020 	cmpeqi	r2,r3,128
 90afc78:	1000531e 	bne	r2,zero,90afdc8 <sogetopt+0x230>
 90afc7c:	00010b06 	br	90b00ac <sogetopt+0x514>
 90afc80:	e0ffff17 	ldw	r3,-4(fp)
 90afc84:	18840060 	cmpeqi	r2,r3,4097
 90afc88:	10006f1e 	bne	r2,zero,90afe48 <sogetopt+0x2b0>
 90afc8c:	e0ffff17 	ldw	r3,-4(fp)
 90afc90:	18840088 	cmpgei	r2,r3,4098
 90afc94:	1000711e 	bne	r2,zero,90afe5c <sogetopt+0x2c4>
 90afc98:	e0ffff17 	ldw	r3,-4(fp)
 90afc9c:	18808020 	cmpeqi	r2,r3,512
 90afca0:	1000581e 	bne	r2,zero,90afe04 <sogetopt+0x26c>
 90afca4:	00010106 	br	90b00ac <sogetopt+0x514>
 90afca8:	e0ffff17 	ldw	r3,-4(fp)
 90afcac:	18840420 	cmpeqi	r2,r3,4112
 90afcb0:	1000881e 	bne	r2,zero,90afed4 <sogetopt+0x33c>
 90afcb4:	e0ffff17 	ldw	r3,-4(fp)
 90afcb8:	18840448 	cmpgei	r2,r3,4113
 90afcbc:	1000171e 	bne	r2,zero,90afd1c <sogetopt+0x184>
 90afcc0:	e0ffff17 	ldw	r3,-4(fp)
 90afcc4:	188401a0 	cmpeqi	r2,r3,4102
 90afcc8:	1000a31e 	bne	r2,zero,90aff58 <sogetopt+0x3c0>
 90afccc:	e0ffff17 	ldw	r3,-4(fp)
 90afcd0:	188401c8 	cmpgei	r2,r3,4103
 90afcd4:	1000071e 	bne	r2,zero,90afcf4 <sogetopt+0x15c>
 90afcd8:	e0ffff17 	ldw	r3,-4(fp)
 90afcdc:	18840120 	cmpeqi	r2,r3,4100
 90afce0:	1000541e 	bne	r2,zero,90afe34 <sogetopt+0x29c>
 90afce4:	e0ffff17 	ldw	r3,-4(fp)
 90afce8:	18840160 	cmpeqi	r2,r3,4101
 90afcec:	1000951e 	bne	r2,zero,90aff44 <sogetopt+0x3ac>
 90afcf0:	0000ee06 	br	90b00ac <sogetopt+0x514>
 90afcf4:	e0ffff17 	ldw	r3,-4(fp)
 90afcf8:	18840220 	cmpeqi	r2,r3,4104
 90afcfc:	1000661e 	bne	r2,zero,90afe98 <sogetopt+0x300>
 90afd00:	e0ffff17 	ldw	r3,-4(fp)
 90afd04:	18840210 	cmplti	r2,r3,4104
 90afd08:	10006b1e 	bne	r2,zero,90afeb8 <sogetopt+0x320>
 90afd0c:	e0ffff17 	ldw	r3,-4(fp)
 90afd10:	18840260 	cmpeqi	r2,r3,4105
 90afd14:	1000951e 	bne	r2,zero,90aff6c <sogetopt+0x3d4>
 90afd18:	0000e406 	br	90b00ac <sogetopt+0x514>
 90afd1c:	e0ffff17 	ldw	r3,-4(fp)
 90afd20:	188404e0 	cmpeqi	r2,r3,4115
 90afd24:	1000141e 	bne	r2,zero,90afd78 <sogetopt+0x1e0>
 90afd28:	e0ffff17 	ldw	r3,-4(fp)
 90afd2c:	18840508 	cmpgei	r2,r3,4116
 90afd30:	1000071e 	bne	r2,zero,90afd50 <sogetopt+0x1b8>
 90afd34:	e0ffff17 	ldw	r3,-4(fp)
 90afd38:	18840460 	cmpeqi	r2,r3,4113
 90afd3c:	10004c1e 	bne	r2,zero,90afe70 <sogetopt+0x2d8>
 90afd40:	e0ffff17 	ldw	r3,-4(fp)
 90afd44:	188404a0 	cmpeqi	r2,r3,4114
 90afd48:	10004e1e 	bne	r2,zero,90afe84 <sogetopt+0x2ec>
 90afd4c:	0000d706 	br	90b00ac <sogetopt+0x514>
 90afd50:	e0ffff17 	ldw	r3,-4(fp)
 90afd54:	188800e0 	cmpeqi	r2,r3,8195
 90afd58:	10005e1e 	bne	r2,zero,90afed4 <sogetopt+0x33c>
 90afd5c:	e0ffff17 	ldw	r3,-4(fp)
 90afd60:	18880120 	cmpeqi	r2,r3,8196
 90afd64:	1000a81e 	bne	r2,zero,90b0008 <sogetopt+0x470>
 90afd68:	e0ffff17 	ldw	r3,-4(fp)
 90afd6c:	188405a0 	cmpeqi	r2,r3,4118
 90afd70:	1000861e 	bne	r2,zero,90aff8c <sogetopt+0x3f4>
 90afd74:	0000cd06 	br	90b00ac <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 90afd78:	e0bffb17 	ldw	r2,-20(fp)
 90afd7c:	1080088b 	ldhu	r2,34(r2)
 90afd80:	10bfffcc 	andi	r2,r2,65535
 90afd84:	1080008c 	andi	r2,r2,2
 90afd88:	1005003a 	cmpeq	r2,r2,zero
 90afd8c:	1000071e 	bne	r2,zero,90afdac <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 90afd90:	e0fffd17 	ldw	r3,-12(fp)
 90afd94:	e0bffb17 	ldw	r2,-20(fp)
 90afd98:	10800117 	ldw	r2,4(r2)
 90afd9c:	10800a17 	ldw	r2,40(r2)
 90afda0:	10800a17 	ldw	r2,40(r2)
 90afda4:	18800015 	stw	r2,0(r3)
 90afda8:	0000c306 	br	90b00b8 <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 90afdac:	e0fffd17 	ldw	r3,-12(fp)
 90afdb0:	008243b4 	movhi	r2,2318
 90afdb4:	10b41e04 	addi	r2,r2,-12168
 90afdb8:	10800017 	ldw	r2,0(r2)
 90afdbc:	10800a17 	ldw	r2,40(r2)
 90afdc0:	18800015 	stw	r2,0(r3)
      break;
 90afdc4:	0000bc06 	br	90b00b8 <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 90afdc8:	e0bffd17 	ldw	r2,-12(fp)
 90afdcc:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 90afdd0:	e0bffb17 	ldw	r2,-20(fp)
 90afdd4:	10800417 	ldw	r2,16(r2)
 90afdd8:	10c0200c 	andi	r3,r2,128
 90afddc:	e0bff917 	ldw	r2,-28(fp)
 90afde0:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 90afde4:	e0bffb17 	ldw	r2,-20(fp)
 90afde8:	1080080b 	ldhu	r2,32(r2)
 90afdec:	10ffffcc 	andi	r3,r2,65535
 90afdf0:	18e0001c 	xori	r3,r3,32768
 90afdf4:	18e00004 	addi	r3,r3,-32768
 90afdf8:	e0bff917 	ldw	r2,-28(fp)
 90afdfc:	10c00115 	stw	r3,4(r2)
      }
      break;
 90afe00:	0000ad06 	br	90b00b8 <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 90afe04:	e13ffd17 	ldw	r4,-12(fp)
 90afe08:	e0bffb17 	ldw	r2,-20(fp)
 90afe0c:	10c00417 	ldw	r3,16(r2)
 90afe10:	e0bffc17 	ldw	r2,-16(fp)
 90afe14:	1884703a 	and	r2,r3,r2
 90afe18:	20800015 	stw	r2,0(r4)
      break;
 90afe1c:	0000a606 	br	90b00b8 <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 90afe20:	e0fffd17 	ldw	r3,-12(fp)
 90afe24:	e0bffb17 	ldw	r2,-20(fp)
 90afe28:	10801617 	ldw	r2,88(r2)
 90afe2c:	18800015 	stw	r2,0(r3)
      break;
 90afe30:	0000a106 	br	90b00b8 <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 90afe34:	e0fffd17 	ldw	r3,-12(fp)
 90afe38:	e0bffb17 	ldw	r2,-20(fp)
 90afe3c:	10800e17 	ldw	r2,56(r2)
 90afe40:	18800015 	stw	r2,0(r3)
      break;
 90afe44:	00009c06 	br	90b00b8 <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 90afe48:	e0fffd17 	ldw	r3,-12(fp)
 90afe4c:	e0bffb17 	ldw	r2,-20(fp)
 90afe50:	10801317 	ldw	r2,76(r2)
 90afe54:	18800015 	stw	r2,0(r3)
      break;
 90afe58:	00009706 	br	90b00b8 <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 90afe5c:	e0fffd17 	ldw	r3,-12(fp)
 90afe60:	e0bffb17 	ldw	r2,-20(fp)
 90afe64:	10800b17 	ldw	r2,44(r2)
 90afe68:	18800015 	stw	r2,0(r3)
      break;
 90afe6c:	00009206 	br	90b00b8 <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 90afe70:	e0fffd17 	ldw	r3,-12(fp)
 90afe74:	e0bffb17 	ldw	r2,-20(fp)
 90afe78:	10800a17 	ldw	r2,40(r2)
 90afe7c:	18800015 	stw	r2,0(r3)
      break;
 90afe80:	00008d06 	br	90b00b8 <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 90afe84:	e0fffd17 	ldw	r3,-12(fp)
 90afe88:	e0bffb17 	ldw	r2,-20(fp)
 90afe8c:	10801217 	ldw	r2,72(r2)
 90afe90:	18800015 	stw	r2,0(r3)
      break;
 90afe94:	00008806 	br	90b00b8 <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 90afe98:	e0fffd17 	ldw	r3,-12(fp)
 90afe9c:	e0bffb17 	ldw	r2,-20(fp)
 90afea0:	10800983 	ldbu	r2,38(r2)
 90afea4:	10803fcc 	andi	r2,r2,255
 90afea8:	1080201c 	xori	r2,r2,128
 90afeac:	10bfe004 	addi	r2,r2,-128
 90afeb0:	18800015 	stw	r2,0(r3)
      break;
 90afeb4:	00008006 	br	90b00b8 <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 90afeb8:	e0fffd17 	ldw	r3,-12(fp)
 90afebc:	e0bffb17 	ldw	r2,-20(fp)
 90afec0:	10800617 	ldw	r2,24(r2)
 90afec4:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 90afec8:	e0bffb17 	ldw	r2,-20(fp)
 90afecc:	10000615 	stw	zero,24(r2)
      break;
 90afed0:	00007906 	br	90b00b8 <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90afed4:	e0bffb17 	ldw	r2,-20(fp)
 90afed8:	10800983 	ldbu	r2,38(r2)
 90afedc:	10803fcc 	andi	r2,r2,255
 90afee0:	1080201c 	xori	r2,r2,128
 90afee4:	10bfe004 	addi	r2,r2,-128
 90afee8:	10800060 	cmpeqi	r2,r2,1
 90afeec:	1000031e 	bne	r2,zero,90afefc <sogetopt+0x364>
      {
         error = EINVAL;
 90afef0:	00800584 	movi	r2,22
 90afef4:	e0bffa15 	stw	r2,-24(fp)
         break;
 90afef8:	00006f06 	br	90b00b8 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90afefc:	e0bffb17 	ldw	r2,-20(fp)
 90aff00:	10800117 	ldw	r2,4(r2)
 90aff04:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 90aff08:	e0bff817 	ldw	r2,-32(fp)
 90aff0c:	10800917 	ldw	r2,36(r2)
 90aff10:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 90aff14:	e0bff717 	ldw	r2,-36(fp)
 90aff18:	1004c03a 	cmpne	r2,r2,zero
 90aff1c:	1000031e 	bne	r2,zero,90aff2c <sogetopt+0x394>
      {
         error = ENOTCONN;
 90aff20:	00802004 	movi	r2,128
 90aff24:	e0bffa15 	stw	r2,-24(fp)
         break;
 90aff28:	00006306 	br	90b00b8 <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 90aff2c:	e0fffd17 	ldw	r3,-12(fp)
 90aff30:	e0bff717 	ldw	r2,-36(fp)
 90aff34:	10800a0b 	ldhu	r2,40(r2)
 90aff38:	10bfffcc 	andi	r2,r2,65535
 90aff3c:	18800015 	stw	r2,0(r3)
      break;
 90aff40:	00005d06 	br	90b00b8 <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 90aff44:	e0bffd17 	ldw	r2,-12(fp)
 90aff48:	e0fffb17 	ldw	r3,-20(fp)
 90aff4c:	18c0198b 	ldhu	r3,102(r3)
 90aff50:	10c0000d 	sth	r3,0(r2)
      break;
 90aff54:	00005806 	br	90b00b8 <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 90aff58:	e0bffd17 	ldw	r2,-12(fp)
 90aff5c:	e0fffb17 	ldw	r3,-20(fp)
 90aff60:	18c0118b 	ldhu	r3,70(r3)
 90aff64:	10c0000d 	sth	r3,0(r2)
      break;
 90aff68:	00005306 	br	90b00b8 <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 90aff6c:	e0fffd17 	ldw	r3,-12(fp)
 90aff70:	e0bffb17 	ldw	r2,-20(fp)
 90aff74:	108009c3 	ldbu	r2,39(r2)
 90aff78:	10803fcc 	andi	r2,r2,255
 90aff7c:	1080201c 	xori	r2,r2,128
 90aff80:	10bfe004 	addi	r2,r2,-128
 90aff84:	18800015 	stw	r2,0(r3)
      break;
 90aff88:	00004b06 	br	90b00b8 <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 90aff8c:	e0bffb17 	ldw	r2,-20(fp)
 90aff90:	1080088b 	ldhu	r2,34(r2)
 90aff94:	10bfffcc 	andi	r2,r2,65535
 90aff98:	1080400c 	andi	r2,r2,256
 90aff9c:	1005003a 	cmpeq	r2,r2,zero
 90affa0:	1000041e 	bne	r2,zero,90affb4 <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 90affa4:	e0fffd17 	ldw	r3,-12(fp)
 90affa8:	00800044 	movi	r2,1
 90affac:	18800015 	stw	r2,0(r3)
 90affb0:	00004106 	br	90b00b8 <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 90affb4:	e0bffd17 	ldw	r2,-12(fp)
 90affb8:	10000015 	stw	zero,0(r2)
      break;
 90affbc:	00003e06 	br	90b00b8 <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 90affc0:	e13ffc17 	ldw	r4,-16(fp)
 90affc4:	e17ffb17 	ldw	r5,-20(fp)
 90affc8:	e1bffd17 	ldw	r6,-12(fp)
 90affcc:	90c4e9c0 	call	90c4e9c <ip_getmoptions>
 90affd0:	e0bffa15 	stw	r2,-24(fp)
      break;
 90affd4:	00003806 	br	90b00b8 <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 90affd8:	e0bffb17 	ldw	r2,-20(fp)
 90affdc:	10800417 	ldw	r2,16(r2)
 90affe0:	1088000c 	andi	r2,r2,8192
 90affe4:	1005003a 	cmpeq	r2,r2,zero
 90affe8:	1000041e 	bne	r2,zero,90afffc <sogetopt+0x464>
         *(int *)val = 1;
 90affec:	e0fffd17 	ldw	r3,-12(fp)
 90afff0:	00800044 	movi	r2,1
 90afff4:	18800015 	stw	r2,0(r3)
 90afff8:	00002f06 	br	90b00b8 <sogetopt+0x520>
      else
         *(int *)val = 0;
 90afffc:	e0bffd17 	ldw	r2,-12(fp)
 90b0000:	10000015 	stw	zero,0(r2)
      break;
 90b0004:	00002c06 	br	90b00b8 <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90b0008:	e0bffb17 	ldw	r2,-20(fp)
 90b000c:	10800983 	ldbu	r2,38(r2)
 90b0010:	10803fcc 	andi	r2,r2,255
 90b0014:	1080201c 	xori	r2,r2,128
 90b0018:	10bfe004 	addi	r2,r2,-128
 90b001c:	10800060 	cmpeqi	r2,r2,1
 90b0020:	1000031e 	bne	r2,zero,90b0030 <sogetopt+0x498>
      {
         error = EINVAL;
 90b0024:	00800584 	movi	r2,22
 90b0028:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b002c:	00002206 	br	90b00b8 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90b0030:	e0bffb17 	ldw	r2,-20(fp)
 90b0034:	10800117 	ldw	r2,4(r2)
 90b0038:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 90b003c:	e0bff617 	ldw	r2,-40(fp)
 90b0040:	10800917 	ldw	r2,36(r2)
 90b0044:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 90b0048:	e0bff517 	ldw	r2,-44(fp)
 90b004c:	1004c03a 	cmpne	r2,r2,zero
 90b0050:	1000031e 	bne	r2,zero,90b0060 <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 90b0054:	00802004 	movi	r2,128
 90b0058:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b005c:	00001606 	br	90b00b8 <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 90b0060:	e0bffd17 	ldw	r2,-12(fp)
 90b0064:	1004c03a 	cmpne	r2,r2,zero
 90b0068:	1000031e 	bne	r2,zero,90b0078 <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 90b006c:	00bffd84 	movi	r2,-10
 90b0070:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0074:	00001006 	br	90b00b8 <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 90b0078:	e0bff517 	ldw	r2,-44(fp)
 90b007c:	10800b0b 	ldhu	r2,44(r2)
 90b0080:	10bfffcc 	andi	r2,r2,65535
 90b0084:	1080010c 	andi	r2,r2,4
 90b0088:	1005003a 	cmpeq	r2,r2,zero
 90b008c:	1000041e 	bne	r2,zero,90b00a0 <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 90b0090:	e0fffd17 	ldw	r3,-12(fp)
 90b0094:	00800044 	movi	r2,1
 90b0098:	18800015 	stw	r2,0(r3)
 90b009c:	00000606 	br	90b00b8 <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 90b00a0:	e0bffd17 	ldw	r2,-12(fp)
 90b00a4:	10000015 	stw	zero,0(r2)

      break;
 90b00a8:	00000306 	br	90b00b8 <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 90b00ac:	00801b44 	movi	r2,109
 90b00b0:	e0bffe15 	stw	r2,-8(fp)
 90b00b4:	00000206 	br	90b00c0 <sogetopt+0x528>
   }
   return error;     /* no error */
 90b00b8:	e0fffa17 	ldw	r3,-24(fp)
 90b00bc:	e0fffe15 	stw	r3,-8(fp)
 90b00c0:	e0bffe17 	ldw	r2,-8(fp)
}
 90b00c4:	e037883a 	mov	sp,fp
 90b00c8:	dfc00117 	ldw	ra,4(sp)
 90b00cc:	df000017 	ldw	fp,0(sp)
 90b00d0:	dec00204 	addi	sp,sp,8
 90b00d4:	f800283a 	ret

090b00d8 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 90b00d8:	defffd04 	addi	sp,sp,-12
 90b00dc:	dfc00215 	stw	ra,8(sp)
 90b00e0:	df000115 	stw	fp,4(sp)
 90b00e4:	df000104 	addi	fp,sp,4
 90b00e8:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 90b00ec:	e0ffff17 	ldw	r3,-4(fp)
 90b00f0:	00803644 	movi	r2,217
 90b00f4:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 90b00f8:	e0bfff17 	ldw	r2,-4(fp)
 90b00fc:	11400a04 	addi	r5,r2,40
 90b0100:	e13fff17 	ldw	r4,-4(fp)
 90b0104:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b0108:	e037883a 	mov	sp,fp
 90b010c:	dfc00117 	ldw	ra,4(sp)
 90b0110:	df000017 	ldw	fp,0(sp)
 90b0114:	dec00204 	addi	sp,sp,8
 90b0118:	f800283a 	ret

090b011c <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 90b011c:	defffd04 	addi	sp,sp,-12
 90b0120:	dfc00215 	stw	ra,8(sp)
 90b0124:	df000115 	stw	fp,4(sp)
 90b0128:	df000104 	addi	fp,sp,4
 90b012c:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 90b0130:	e0bfff17 	ldw	r2,-4(fp)
 90b0134:	10c0088b 	ldhu	r3,34(r2)
 90b0138:	00bffd44 	movi	r2,-11
 90b013c:	1884703a 	and	r2,r3,r2
 90b0140:	1007883a 	mov	r3,r2
 90b0144:	e0bfff17 	ldw	r2,-4(fp)
 90b0148:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 90b014c:	e0bfff17 	ldw	r2,-4(fp)
 90b0150:	1080088b 	ldhu	r2,34(r2)
 90b0154:	10800114 	ori	r2,r2,4
 90b0158:	1007883a 	mov	r3,r2
 90b015c:	e0bfff17 	ldw	r2,-4(fp)
 90b0160:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 90b0164:	e0bfff17 	ldw	r2,-4(fp)
 90b0168:	10800904 	addi	r2,r2,36
 90b016c:	1009883a 	mov	r4,r2
 90b0170:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
}
 90b0174:	e037883a 	mov	sp,fp
 90b0178:	dfc00117 	ldw	ra,4(sp)
 90b017c:	df000017 	ldw	fp,0(sp)
 90b0180:	dec00204 	addi	sp,sp,8
 90b0184:	f800283a 	ret

090b0188 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 90b0188:	defffc04 	addi	sp,sp,-16
 90b018c:	dfc00315 	stw	ra,12(sp)
 90b0190:	df000215 	stw	fp,8(sp)
 90b0194:	df000204 	addi	fp,sp,8
 90b0198:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 90b019c:	e0bfff17 	ldw	r2,-4(fp)
 90b01a0:	10801b17 	ldw	r2,108(r2)
 90b01a4:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 90b01a8:	e0bffe17 	ldw	r2,-8(fp)
 90b01ac:	1005003a 	cmpeq	r2,r2,zero
 90b01b0:	1000141e 	bne	r2,zero,90b0204 <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 90b01b4:	e13fff17 	ldw	r4,-4(fp)
 90b01b8:	000b883a 	mov	r5,zero
 90b01bc:	90b06940 	call	90b0694 <soqremque>
 90b01c0:	1004c03a 	cmpne	r2,r2,zero
 90b01c4:	1000031e 	bne	r2,zero,90b01d4 <soisconnected+0x4c>
         panic("soisconnected");
 90b01c8:	01024374 	movhi	r4,2317
 90b01cc:	213f7304 	addi	r4,r4,-564
 90b01d0:	90a438c0 	call	90a438c <panic>
      soqinsque(head, so, 1);
 90b01d4:	e13ffe17 	ldw	r4,-8(fp)
 90b01d8:	e17fff17 	ldw	r5,-4(fp)
 90b01dc:	01800044 	movi	r6,1
 90b01e0:	90b05e80 	call	90b05e8 <soqinsque>
      sorwakeup(head);
 90b01e4:	e0bffe17 	ldw	r2,-8(fp)
 90b01e8:	11400a04 	addi	r5,r2,40
 90b01ec:	e13ffe17 	ldw	r4,-8(fp)
 90b01f0:	90b08f40 	call	90b08f4 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 90b01f4:	e0bffe17 	ldw	r2,-8(fp)
 90b01f8:	10800904 	addi	r2,r2,36
 90b01fc:	1009883a 	mov	r4,r2
 90b0200:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90b0204:	e0bfff17 	ldw	r2,-4(fp)
 90b0208:	10c0088b 	ldhu	r3,34(r2)
 90b020c:	00bffcc4 	movi	r2,-13
 90b0210:	1884703a 	and	r2,r3,r2
 90b0214:	1007883a 	mov	r3,r2
 90b0218:	e0bfff17 	ldw	r2,-4(fp)
 90b021c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 90b0220:	e0bfff17 	ldw	r2,-4(fp)
 90b0224:	1080088b 	ldhu	r2,34(r2)
 90b0228:	10800094 	ori	r2,r2,2
 90b022c:	1007883a 	mov	r3,r2
 90b0230:	e0bfff17 	ldw	r2,-4(fp)
 90b0234:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 90b0238:	e0bfff17 	ldw	r2,-4(fp)
 90b023c:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 90b0240:	e0bfff17 	ldw	r2,-4(fp)
 90b0244:	10800904 	addi	r2,r2,36
 90b0248:	1009883a 	mov	r4,r2
 90b024c:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   sorwakeup (so);
 90b0250:	e0bfff17 	ldw	r2,-4(fp)
 90b0254:	11400a04 	addi	r5,r2,40
 90b0258:	e13fff17 	ldw	r4,-4(fp)
 90b025c:	90b08f40 	call	90b08f4 <sbwakeup>
   sowwakeup (so);
 90b0260:	e0bfff17 	ldw	r2,-4(fp)
 90b0264:	11401204 	addi	r5,r2,72
 90b0268:	e13fff17 	ldw	r4,-4(fp)
 90b026c:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b0270:	e037883a 	mov	sp,fp
 90b0274:	dfc00117 	ldw	ra,4(sp)
 90b0278:	df000017 	ldw	fp,0(sp)
 90b027c:	dec00204 	addi	sp,sp,8
 90b0280:	f800283a 	ret

090b0284 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 90b0284:	defffd04 	addi	sp,sp,-12
 90b0288:	dfc00215 	stw	ra,8(sp)
 90b028c:	df000115 	stw	fp,4(sp)
 90b0290:	df000104 	addi	fp,sp,4
 90b0294:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 90b0298:	e0bfff17 	ldw	r2,-4(fp)
 90b029c:	10c0088b 	ldhu	r3,34(r2)
 90b02a0:	00bffec4 	movi	r2,-5
 90b02a4:	1884703a 	and	r2,r3,r2
 90b02a8:	1007883a 	mov	r3,r2
 90b02ac:	e0bfff17 	ldw	r2,-4(fp)
 90b02b0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 90b02b4:	e0bfff17 	ldw	r2,-4(fp)
 90b02b8:	1080088b 	ldhu	r2,34(r2)
 90b02bc:	10800e14 	ori	r2,r2,56
 90b02c0:	1007883a 	mov	r3,r2
 90b02c4:	e0bfff17 	ldw	r2,-4(fp)
 90b02c8:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 90b02cc:	e0bfff17 	ldw	r2,-4(fp)
 90b02d0:	10800904 	addi	r2,r2,36
 90b02d4:	1009883a 	mov	r4,r2
 90b02d8:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   sowwakeup (so);
 90b02dc:	e0bfff17 	ldw	r2,-4(fp)
 90b02e0:	11401204 	addi	r5,r2,72
 90b02e4:	e13fff17 	ldw	r4,-4(fp)
 90b02e8:	90b08f40 	call	90b08f4 <sbwakeup>
   sorwakeup (so);
 90b02ec:	e0bfff17 	ldw	r2,-4(fp)
 90b02f0:	11400a04 	addi	r5,r2,40
 90b02f4:	e13fff17 	ldw	r4,-4(fp)
 90b02f8:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b02fc:	e037883a 	mov	sp,fp
 90b0300:	dfc00117 	ldw	ra,4(sp)
 90b0304:	df000017 	ldw	fp,0(sp)
 90b0308:	dec00204 	addi	sp,sp,8
 90b030c:	f800283a 	ret

090b0310 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 90b0310:	defffd04 	addi	sp,sp,-12
 90b0314:	dfc00215 	stw	ra,8(sp)
 90b0318:	df000115 	stw	fp,4(sp)
 90b031c:	df000104 	addi	fp,sp,4
 90b0320:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 90b0324:	e0bfff17 	ldw	r2,-4(fp)
 90b0328:	1080088b 	ldhu	r2,34(r2)
 90b032c:	10bfffcc 	andi	r2,r2,65535
 90b0330:	1080010c 	andi	r2,r2,4
 90b0334:	1005003a 	cmpeq	r2,r2,zero
 90b0338:	1000061e 	bne	r2,zero,90b0354 <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 90b033c:	e0bfff17 	ldw	r2,-4(fp)
 90b0340:	1080088b 	ldhu	r2,34(r2)
 90b0344:	10880014 	ori	r2,r2,8192
 90b0348:	1007883a 	mov	r3,r2
 90b034c:	e0bfff17 	ldw	r2,-4(fp)
 90b0350:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 90b0354:	e0bfff17 	ldw	r2,-4(fp)
 90b0358:	10c0088b 	ldhu	r3,34(r2)
 90b035c:	00bffc44 	movi	r2,-15
 90b0360:	1884703a 	and	r2,r3,r2
 90b0364:	1007883a 	mov	r3,r2
 90b0368:	e0bfff17 	ldw	r2,-4(fp)
 90b036c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 90b0370:	e0bfff17 	ldw	r2,-4(fp)
 90b0374:	1080088b 	ldhu	r2,34(r2)
 90b0378:	10800c14 	ori	r2,r2,48
 90b037c:	1007883a 	mov	r3,r2
 90b0380:	e0bfff17 	ldw	r2,-4(fp)
 90b0384:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 90b0388:	e0bfff17 	ldw	r2,-4(fp)
 90b038c:	10800904 	addi	r2,r2,36
 90b0390:	1009883a 	mov	r4,r2
 90b0394:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   sowwakeup (so);
 90b0398:	e0bfff17 	ldw	r2,-4(fp)
 90b039c:	11401204 	addi	r5,r2,72
 90b03a0:	e13fff17 	ldw	r4,-4(fp)
 90b03a4:	90b08f40 	call	90b08f4 <sbwakeup>
   sorwakeup (so);
 90b03a8:	e0bfff17 	ldw	r2,-4(fp)
 90b03ac:	11400a04 	addi	r5,r2,40
 90b03b0:	e13fff17 	ldw	r4,-4(fp)
 90b03b4:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b03b8:	e037883a 	mov	sp,fp
 90b03bc:	dfc00117 	ldw	ra,4(sp)
 90b03c0:	df000017 	ldw	fp,0(sp)
 90b03c4:	dec00204 	addi	sp,sp,8
 90b03c8:	f800283a 	ret

090b03cc <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 90b03cc:	defffa04 	addi	sp,sp,-24
 90b03d0:	dfc00515 	stw	ra,20(sp)
 90b03d4:	df000415 	stw	fp,16(sp)
 90b03d8:	df000404 	addi	fp,sp,16
 90b03dc:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 90b03e0:	e0bffe17 	ldw	r2,-8(fp)
 90b03e4:	10801e43 	ldbu	r2,121(r2)
 90b03e8:	10c03fcc 	andi	r3,r2,255
 90b03ec:	18c0201c 	xori	r3,r3,128
 90b03f0:	18ffe004 	addi	r3,r3,-128
 90b03f4:	e0bffe17 	ldw	r2,-8(fp)
 90b03f8:	10801e03 	ldbu	r2,120(r2)
 90b03fc:	10803fcc 	andi	r2,r2,255
 90b0400:	1080201c 	xori	r2,r2,128
 90b0404:	10bfe004 	addi	r2,r2,-128
 90b0408:	1889883a 	add	r4,r3,r2
 90b040c:	e0bffe17 	ldw	r2,-8(fp)
 90b0410:	10801e83 	ldbu	r2,122(r2)
 90b0414:	10c03fcc 	andi	r3,r2,255
 90b0418:	18c0201c 	xori	r3,r3,128
 90b041c:	18ffe004 	addi	r3,r3,-128
 90b0420:	1805883a 	mov	r2,r3
 90b0424:	1085883a 	add	r2,r2,r2
 90b0428:	10c7883a 	add	r3,r2,r3
 90b042c:	1804d7fa 	srli	r2,r3,31
 90b0430:	10c5883a 	add	r2,r2,r3
 90b0434:	1005d07a 	srai	r2,r2,1
 90b0438:	11006416 	blt	r2,r4,90b05cc <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 90b043c:	01002104 	movi	r4,132
 90b0440:	90a9f0c0 	call	90a9f0c <npalloc>
 90b0444:	e0bffd15 	stw	r2,-12(fp)
 90b0448:	e0bffd17 	ldw	r2,-12(fp)
 90b044c:	1005003a 	cmpeq	r2,r2,zero
 90b0450:	10005e1e 	bne	r2,zero,90b05cc <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 90b0454:	e0bffd17 	ldw	r2,-12(fp)
 90b0458:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 90b045c:	e17ffd17 	ldw	r5,-12(fp)
 90b0460:	010243b4 	movhi	r4,2318
 90b0464:	21355b04 	addi	r4,r4,-10900
 90b0468:	90a8e180 	call	90a8e18 <putq>
   so->so_type = head->so_type;
 90b046c:	e0bffe17 	ldw	r2,-8(fp)
 90b0470:	10c00983 	ldbu	r3,38(r2)
 90b0474:	e0bffd17 	ldw	r2,-12(fp)
 90b0478:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 90b047c:	e0bffe17 	ldw	r2,-8(fp)
 90b0480:	10c00417 	ldw	r3,16(r2)
 90b0484:	00bfff44 	movi	r2,-3
 90b0488:	1886703a 	and	r3,r3,r2
 90b048c:	e0bffd17 	ldw	r2,-12(fp)
 90b0490:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 90b0494:	e0bffe17 	ldw	r2,-8(fp)
 90b0498:	10c0080b 	ldhu	r3,32(r2)
 90b049c:	e0bffd17 	ldw	r2,-12(fp)
 90b04a0:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 90b04a4:	e0bffe17 	ldw	r2,-8(fp)
 90b04a8:	1080088b 	ldhu	r2,34(r2)
 90b04ac:	10800054 	ori	r2,r2,1
 90b04b0:	1007883a 	mov	r3,r2
 90b04b4:	e0bffd17 	ldw	r2,-12(fp)
 90b04b8:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 90b04bc:	e0bffe17 	ldw	r2,-8(fp)
 90b04c0:	10c00217 	ldw	r3,8(r2)
 90b04c4:	e0bffd17 	ldw	r2,-12(fp)
 90b04c8:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 90b04cc:	e0bffe17 	ldw	r2,-8(fp)
 90b04d0:	10c0090b 	ldhu	r3,36(r2)
 90b04d4:	e0bffd17 	ldw	r2,-12(fp)
 90b04d8:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 90b04dc:	00824374 	movhi	r2,2317
 90b04e0:	108bd904 	addi	r2,r2,12132
 90b04e4:	10c00017 	ldw	r3,0(r2)
 90b04e8:	e0bffd17 	ldw	r2,-12(fp)
 90b04ec:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 90b04f0:	00824374 	movhi	r2,2317
 90b04f4:	108bd804 	addi	r2,r2,12128
 90b04f8:	10c00017 	ldw	r3,0(r2)
 90b04fc:	e0bffd17 	ldw	r2,-12(fp)
 90b0500:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 90b0504:	e13ffe17 	ldw	r4,-8(fp)
 90b0508:	e17ffd17 	ldw	r5,-12(fp)
 90b050c:	000d883a 	mov	r6,zero
 90b0510:	90b05e80 	call	90b05e8 <soqinsque>
   so->so_req = PRU_ATTACH;
 90b0514:	e0bffd17 	ldw	r2,-12(fp)
 90b0518:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 90b051c:	e0bffe17 	ldw	r2,-8(fp)
 90b0520:	10c00517 	ldw	r3,20(r2)
 90b0524:	e0bffd17 	ldw	r2,-12(fp)
 90b0528:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 90b052c:	e0bffd17 	ldw	r2,-12(fp)
 90b0530:	10800217 	ldw	r2,8(r2)
 90b0534:	10800317 	ldw	r2,12(r2)
 90b0538:	e13ffd17 	ldw	r4,-12(fp)
 90b053c:	000b883a 	mov	r5,zero
 90b0540:	000d883a 	mov	r6,zero
 90b0544:	103ee83a 	callr	r2
 90b0548:	1004c03a 	cmpne	r2,r2,zero
 90b054c:	1000161e 	bne	r2,zero,90b05a8 <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 90b0550:	00824374 	movhi	r2,2317
 90b0554:	108c6804 	addi	r2,r2,12704
 90b0558:	10800003 	ldbu	r2,0(r2)
 90b055c:	10803fcc 	andi	r2,r2,255
 90b0560:	1005003a 	cmpeq	r2,r2,zero
 90b0564:	10000d1e 	bne	r2,zero,90b059c <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 90b0568:	00824374 	movhi	r2,2317
 90b056c:	108c6604 	addi	r2,r2,12696
 90b0570:	10800017 	ldw	r2,0(r2)
 90b0574:	e13ffd17 	ldw	r4,-12(fp)
 90b0578:	103ee83a 	callr	r2
 90b057c:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 90b0580:	e0bffc17 	ldw	r2,-16(fp)
 90b0584:	1004c03a 	cmpne	r2,r2,zero
 90b0588:	1000071e 	bne	r2,zero,90b05a8 <sonewconn+0x1dc>
      so->owner = head->owner;
 90b058c:	e0bffe17 	ldw	r2,-8(fp)
 90b0590:	10c02003 	ldbu	r3,128(r2)
 90b0594:	e0bffd17 	ldw	r2,-12(fp)
 90b0598:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 90b059c:	e0bffd17 	ldw	r2,-12(fp)
 90b05a0:	e0bfff15 	stw	r2,-4(fp)
 90b05a4:	00000a06 	br	90b05d0 <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 90b05a8:	e13ffd17 	ldw	r4,-12(fp)
 90b05ac:	000b883a 	mov	r5,zero
 90b05b0:	90b06940 	call	90b0694 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 90b05b4:	010243b4 	movhi	r4,2318
 90b05b8:	21355b04 	addi	r4,r4,-10900
 90b05bc:	e17ffd17 	ldw	r5,-12(fp)
 90b05c0:	90a8ec80 	call	90a8ec8 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 90b05c4:	e13ffd17 	ldw	r4,-12(fp)
 90b05c8:	90aa0000 	call	90aa000 <npfree>
bad:
   return ((struct socket *)0);
 90b05cc:	e03fff15 	stw	zero,-4(fp)
 90b05d0:	e0bfff17 	ldw	r2,-4(fp)
}
 90b05d4:	e037883a 	mov	sp,fp
 90b05d8:	dfc00117 	ldw	ra,4(sp)
 90b05dc:	df000017 	ldw	fp,0(sp)
 90b05e0:	dec00204 	addi	sp,sp,8
 90b05e4:	f800283a 	ret

090b05e8 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 90b05e8:	defffc04 	addi	sp,sp,-16
 90b05ec:	df000315 	stw	fp,12(sp)
 90b05f0:	df000304 	addi	fp,sp,12
 90b05f4:	e13ffd15 	stw	r4,-12(fp)
 90b05f8:	e17ffe15 	stw	r5,-8(fp)
 90b05fc:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 90b0600:	e0fffe17 	ldw	r3,-8(fp)
 90b0604:	e0bffd17 	ldw	r2,-12(fp)
 90b0608:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 90b060c:	e0bfff17 	ldw	r2,-4(fp)
 90b0610:	1004c03a 	cmpne	r2,r2,zero
 90b0614:	10000e1e 	bne	r2,zero,90b0650 <soqinsque+0x68>
   {
      head->so_q0len++;
 90b0618:	e0bffd17 	ldw	r2,-12(fp)
 90b061c:	10801e03 	ldbu	r2,120(r2)
 90b0620:	10800044 	addi	r2,r2,1
 90b0624:	1007883a 	mov	r3,r2
 90b0628:	e0bffd17 	ldw	r2,-12(fp)
 90b062c:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 90b0630:	e0bffd17 	ldw	r2,-12(fp)
 90b0634:	10c01c17 	ldw	r3,112(r2)
 90b0638:	e0bffe17 	ldw	r2,-8(fp)
 90b063c:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 90b0640:	e0fffd17 	ldw	r3,-12(fp)
 90b0644:	e0bffe17 	ldw	r2,-8(fp)
 90b0648:	18801c15 	stw	r2,112(r3)
 90b064c:	00000d06 	br	90b0684 <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 90b0650:	e0bffd17 	ldw	r2,-12(fp)
 90b0654:	10801e43 	ldbu	r2,121(r2)
 90b0658:	10800044 	addi	r2,r2,1
 90b065c:	1007883a 	mov	r3,r2
 90b0660:	e0bffd17 	ldw	r2,-12(fp)
 90b0664:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 90b0668:	e0bffd17 	ldw	r2,-12(fp)
 90b066c:	10c01d17 	ldw	r3,116(r2)
 90b0670:	e0bffe17 	ldw	r2,-8(fp)
 90b0674:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 90b0678:	e0fffd17 	ldw	r3,-12(fp)
 90b067c:	e0bffe17 	ldw	r2,-8(fp)
 90b0680:	18801d15 	stw	r2,116(r3)
   }
}
 90b0684:	e037883a 	mov	sp,fp
 90b0688:	df000017 	ldw	fp,0(sp)
 90b068c:	dec00104 	addi	sp,sp,4
 90b0690:	f800283a 	ret

090b0694 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 90b0694:	defff804 	addi	sp,sp,-32
 90b0698:	df000715 	stw	fp,28(sp)
 90b069c:	df000704 	addi	fp,sp,28
 90b06a0:	e13ffc15 	stw	r4,-16(fp)
 90b06a4:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 90b06a8:	e0bffc17 	ldw	r2,-16(fp)
 90b06ac:	10801b17 	ldw	r2,108(r2)
 90b06b0:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 90b06b4:	e0bffb17 	ldw	r2,-20(fp)
 90b06b8:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 90b06bc:	e0bffd17 	ldw	r2,-12(fp)
 90b06c0:	1005003a 	cmpeq	r2,r2,zero
 90b06c4:	1000041e 	bne	r2,zero,90b06d8 <soqremque+0x44>
 90b06c8:	e0bffa17 	ldw	r2,-24(fp)
 90b06cc:	10801d17 	ldw	r2,116(r2)
 90b06d0:	e0bfff15 	stw	r2,-4(fp)
 90b06d4:	00000306 	br	90b06e4 <soqremque+0x50>
 90b06d8:	e0bffa17 	ldw	r2,-24(fp)
 90b06dc:	10801c17 	ldw	r2,112(r2)
 90b06e0:	e0bfff15 	stw	r2,-4(fp)
 90b06e4:	e0bfff17 	ldw	r2,-4(fp)
 90b06e8:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 90b06ec:	e0fff917 	ldw	r3,-28(fp)
 90b06f0:	e0bffc17 	ldw	r2,-16(fp)
 90b06f4:	18800826 	beq	r3,r2,90b0718 <soqremque+0x84>
         break;
      if (next == head)
 90b06f8:	e0fff917 	ldw	r3,-28(fp)
 90b06fc:	e0bffb17 	ldw	r2,-20(fp)
 90b0700:	1880021e 	bne	r3,r2,90b070c <soqremque+0x78>
         return (0);
 90b0704:	e03ffe15 	stw	zero,-8(fp)
 90b0708:	00002506 	br	90b07a0 <soqremque+0x10c>
      prev = next;
 90b070c:	e0bff917 	ldw	r2,-28(fp)
 90b0710:	e0bffa15 	stw	r2,-24(fp)
   }
 90b0714:	003fe906 	br	90b06bc <soqremque+0x28>
   if (q == 0) 
 90b0718:	e0bffd17 	ldw	r2,-12(fp)
 90b071c:	1004c03a 	cmpne	r2,r2,zero
 90b0720:	10000b1e 	bne	r2,zero,90b0750 <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 90b0724:	e0bff917 	ldw	r2,-28(fp)
 90b0728:	10c01c17 	ldw	r3,112(r2)
 90b072c:	e0bffa17 	ldw	r2,-24(fp)
 90b0730:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 90b0734:	e0bffb17 	ldw	r2,-20(fp)
 90b0738:	10801e03 	ldbu	r2,120(r2)
 90b073c:	10bfffc4 	addi	r2,r2,-1
 90b0740:	1007883a 	mov	r3,r2
 90b0744:	e0bffb17 	ldw	r2,-20(fp)
 90b0748:	10c01e05 	stb	r3,120(r2)
 90b074c:	00000a06 	br	90b0778 <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 90b0750:	e0bff917 	ldw	r2,-28(fp)
 90b0754:	10c01d17 	ldw	r3,116(r2)
 90b0758:	e0bffa17 	ldw	r2,-24(fp)
 90b075c:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 90b0760:	e0bffb17 	ldw	r2,-20(fp)
 90b0764:	10801e43 	ldbu	r2,121(r2)
 90b0768:	10bfffc4 	addi	r2,r2,-1
 90b076c:	1007883a 	mov	r3,r2
 90b0770:	e0bffb17 	ldw	r2,-20(fp)
 90b0774:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 90b0778:	e0bff917 	ldw	r2,-28(fp)
 90b077c:	10001d15 	stw	zero,116(r2)
 90b0780:	e0bff917 	ldw	r2,-28(fp)
 90b0784:	10c01d17 	ldw	r3,116(r2)
 90b0788:	e0bff917 	ldw	r2,-28(fp)
 90b078c:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 90b0790:	e0bff917 	ldw	r2,-28(fp)
 90b0794:	10001b15 	stw	zero,108(r2)
   return 1;
 90b0798:	00800044 	movi	r2,1
 90b079c:	e0bffe15 	stw	r2,-8(fp)
 90b07a0:	e0bffe17 	ldw	r2,-8(fp)
}
 90b07a4:	e037883a 	mov	sp,fp
 90b07a8:	df000017 	ldw	fp,0(sp)
 90b07ac:	dec00104 	addi	sp,sp,4
 90b07b0:	f800283a 	ret

090b07b4 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 90b07b4:	defffd04 	addi	sp,sp,-12
 90b07b8:	dfc00215 	stw	ra,8(sp)
 90b07bc:	df000115 	stw	fp,4(sp)
 90b07c0:	df000104 	addi	fp,sp,4
 90b07c4:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 90b07c8:	e0bfff17 	ldw	r2,-4(fp)
 90b07cc:	1080088b 	ldhu	r2,34(r2)
 90b07d0:	10800414 	ori	r2,r2,16
 90b07d4:	1007883a 	mov	r3,r2
 90b07d8:	e0bfff17 	ldw	r2,-4(fp)
 90b07dc:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 90b07e0:	e0bfff17 	ldw	r2,-4(fp)
 90b07e4:	11401204 	addi	r5,r2,72
 90b07e8:	e13fff17 	ldw	r4,-4(fp)
 90b07ec:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b07f0:	e037883a 	mov	sp,fp
 90b07f4:	dfc00117 	ldw	ra,4(sp)
 90b07f8:	df000017 	ldw	fp,0(sp)
 90b07fc:	dec00204 	addi	sp,sp,8
 90b0800:	f800283a 	ret

090b0804 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 90b0804:	defffd04 	addi	sp,sp,-12
 90b0808:	dfc00215 	stw	ra,8(sp)
 90b080c:	df000115 	stw	fp,4(sp)
 90b0810:	df000104 	addi	fp,sp,4
 90b0814:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 90b0818:	e0bfff17 	ldw	r2,-4(fp)
 90b081c:	1080088b 	ldhu	r2,34(r2)
 90b0820:	10800814 	ori	r2,r2,32
 90b0824:	1007883a 	mov	r3,r2
 90b0828:	e0bfff17 	ldw	r2,-4(fp)
 90b082c:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 90b0830:	e0bfff17 	ldw	r2,-4(fp)
 90b0834:	11400a04 	addi	r5,r2,40
 90b0838:	e13fff17 	ldw	r4,-4(fp)
 90b083c:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b0840:	e037883a 	mov	sp,fp
 90b0844:	dfc00117 	ldw	ra,4(sp)
 90b0848:	df000017 	ldw	fp,0(sp)
 90b084c:	dec00204 	addi	sp,sp,8
 90b0850:	f800283a 	ret

090b0854 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 90b0854:	defffe04 	addi	sp,sp,-8
 90b0858:	df000115 	stw	fp,4(sp)
 90b085c:	df000104 	addi	fp,sp,4
 90b0860:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 90b0864:	e0bfff17 	ldw	r2,-4(fp)
 90b0868:	1080070b 	ldhu	r2,28(r2)
 90b086c:	10800214 	ori	r2,r2,8
 90b0870:	1007883a 	mov	r3,r2
 90b0874:	e0bfff17 	ldw	r2,-4(fp)
 90b0878:	10c0070d 	sth	r3,28(r2)
}
 90b087c:	e037883a 	mov	sp,fp
 90b0880:	df000017 	ldw	fp,0(sp)
 90b0884:	dec00104 	addi	sp,sp,4
 90b0888:	f800283a 	ret

090b088c <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 90b088c:	defffd04 	addi	sp,sp,-12
 90b0890:	dfc00215 	stw	ra,8(sp)
 90b0894:	df000115 	stw	fp,4(sp)
 90b0898:	df000104 	addi	fp,sp,4
 90b089c:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 90b08a0:	e0bfff17 	ldw	r2,-4(fp)
 90b08a4:	1080070b 	ldhu	r2,28(r2)
 90b08a8:	10800114 	ori	r2,r2,4
 90b08ac:	1007883a 	mov	r3,r2
 90b08b0:	e0bfff17 	ldw	r2,-4(fp)
 90b08b4:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 90b08b8:	e0bfff17 	ldw	r2,-4(fp)
 90b08bc:	1009883a 	mov	r4,r2
 90b08c0:	90a4d040 	call	90a4d04 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 90b08c4:	e0bfff17 	ldw	r2,-4(fp)
 90b08c8:	10c0070b 	ldhu	r3,28(r2)
 90b08cc:	00bffec4 	movi	r2,-5
 90b08d0:	1884703a 	and	r2,r3,r2
 90b08d4:	1007883a 	mov	r3,r2
 90b08d8:	e0bfff17 	ldw	r2,-4(fp)
 90b08dc:	10c0070d 	sth	r3,28(r2)
}
 90b08e0:	e037883a 	mov	sp,fp
 90b08e4:	dfc00117 	ldw	ra,4(sp)
 90b08e8:	df000017 	ldw	fp,0(sp)
 90b08ec:	dec00204 	addi	sp,sp,8
 90b08f0:	f800283a 	ret

090b08f4 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 90b08f4:	defffc04 	addi	sp,sp,-16
 90b08f8:	dfc00315 	stw	ra,12(sp)
 90b08fc:	df000215 	stw	fp,8(sp)
 90b0900:	df000204 	addi	fp,sp,8
 90b0904:	e13ffe15 	stw	r4,-8(fp)
 90b0908:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 90b090c:	e0bfff17 	ldw	r2,-4(fp)
 90b0910:	1080070b 	ldhu	r2,28(r2)
 90b0914:	10bfffcc 	andi	r2,r2,65535
 90b0918:	1080020c 	andi	r2,r2,8
 90b091c:	1005003a 	cmpeq	r2,r2,zero
 90b0920:	10000d1e 	bne	r2,zero,90b0958 <sbwakeup+0x64>
   {
      select_wait = 0;
 90b0924:	00824374 	movhi	r2,2317
 90b0928:	108c4a04 	addi	r2,r2,12584
 90b092c:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 90b0930:	01024374 	movhi	r4,2317
 90b0934:	210c4a04 	addi	r4,r4,12584
 90b0938:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 90b093c:	e0bfff17 	ldw	r2,-4(fp)
 90b0940:	10c0070b 	ldhu	r3,28(r2)
 90b0944:	00bffdc4 	movi	r2,-9
 90b0948:	1884703a 	and	r2,r3,r2
 90b094c:	1007883a 	mov	r3,r2
 90b0950:	e0bfff17 	ldw	r2,-4(fp)
 90b0954:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 90b0958:	e0bfff17 	ldw	r2,-4(fp)
 90b095c:	1080070b 	ldhu	r2,28(r2)
 90b0960:	10bfffcc 	andi	r2,r2,65535
 90b0964:	1080010c 	andi	r2,r2,4
 90b0968:	1005003a 	cmpeq	r2,r2,zero
 90b096c:	1000031e 	bne	r2,zero,90b097c <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 90b0970:	e0bfff17 	ldw	r2,-4(fp)
 90b0974:	1009883a 	mov	r4,r2
 90b0978:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 90b097c:	e037883a 	mov	sp,fp
 90b0980:	dfc00117 	ldw	ra,4(sp)
 90b0984:	df000017 	ldw	fp,0(sp)
 90b0988:	dec00204 	addi	sp,sp,8
 90b098c:	f800283a 	ret

090b0990 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 90b0990:	defffa04 	addi	sp,sp,-24
 90b0994:	dfc00515 	stw	ra,20(sp)
 90b0998:	df000415 	stw	fp,16(sp)
 90b099c:	df000404 	addi	fp,sp,16
 90b09a0:	e13ffc15 	stw	r4,-16(fp)
 90b09a4:	e17ffd15 	stw	r5,-12(fp)
 90b09a8:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 90b09ac:	e0bffc17 	ldw	r2,-16(fp)
 90b09b0:	11001204 	addi	r4,r2,72
 90b09b4:	e17ffd17 	ldw	r5,-12(fp)
 90b09b8:	90b0a100 	call	90b0a10 <sbreserve>
 90b09bc:	1005003a 	cmpeq	r2,r2,zero
 90b09c0:	10000b1e 	bne	r2,zero,90b09f0 <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 90b09c4:	e0bffc17 	ldw	r2,-16(fp)
 90b09c8:	11000a04 	addi	r4,r2,40
 90b09cc:	e17ffe17 	ldw	r5,-8(fp)
 90b09d0:	90b0a100 	call	90b0a10 <sbreserve>
 90b09d4:	1005003a 	cmpeq	r2,r2,zero
 90b09d8:	1000021e 	bne	r2,zero,90b09e4 <soreserve+0x54>
      goto bad2;
   return (0);
 90b09dc:	e03fff15 	stw	zero,-4(fp)
 90b09e0:	00000506 	br	90b09f8 <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 90b09e4:	e0bffc17 	ldw	r2,-16(fp)
 90b09e8:	11001204 	addi	r4,r2,72
 90b09ec:	90b0a700 	call	90b0a70 <sbrelease>
bad:
   return (ENOBUFS);
 90b09f0:	00801a44 	movi	r2,105
 90b09f4:	e0bfff15 	stw	r2,-4(fp)
 90b09f8:	e0bfff17 	ldw	r2,-4(fp)
}
 90b09fc:	e037883a 	mov	sp,fp
 90b0a00:	dfc00117 	ldw	ra,4(sp)
 90b0a04:	df000017 	ldw	fp,0(sp)
 90b0a08:	dec00204 	addi	sp,sp,8
 90b0a0c:	f800283a 	ret

090b0a10 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 90b0a10:	defffc04 	addi	sp,sp,-16
 90b0a14:	df000315 	stw	fp,12(sp)
 90b0a18:	df000304 	addi	fp,sp,12
 90b0a1c:	e13ffd15 	stw	r4,-12(fp)
 90b0a20:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 90b0a24:	e0fffd17 	ldw	r3,-12(fp)
 90b0a28:	e0bffe17 	ldw	r2,-8(fp)
 90b0a2c:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 90b0a30:	e0bffe17 	ldw	r2,-8(fp)
 90b0a34:	1085883a 	add	r2,r2,r2
 90b0a38:	e0bfff15 	stw	r2,-4(fp)
 90b0a3c:	e0ffff17 	ldw	r3,-4(fp)
 90b0a40:	18900070 	cmpltui	r2,r3,16385
 90b0a44:	1000021e 	bne	r2,zero,90b0a50 <sbreserve+0x40>
 90b0a48:	00900004 	movi	r2,16384
 90b0a4c:	e0bfff15 	stw	r2,-4(fp)
 90b0a50:	e0bffd17 	ldw	r2,-12(fp)
 90b0a54:	e0ffff17 	ldw	r3,-4(fp)
 90b0a58:	10c00315 	stw	r3,12(r2)
   return (1);
 90b0a5c:	00800044 	movi	r2,1
}
 90b0a60:	e037883a 	mov	sp,fp
 90b0a64:	df000017 	ldw	fp,0(sp)
 90b0a68:	dec00104 	addi	sp,sp,4
 90b0a6c:	f800283a 	ret

090b0a70 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 90b0a70:	defffd04 	addi	sp,sp,-12
 90b0a74:	dfc00215 	stw	ra,8(sp)
 90b0a78:	df000115 	stw	fp,4(sp)
 90b0a7c:	df000104 	addi	fp,sp,4
 90b0a80:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 90b0a84:	e13fff17 	ldw	r4,-4(fp)
 90b0a88:	90b10300 	call	90b1030 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 90b0a8c:	e0bfff17 	ldw	r2,-4(fp)
 90b0a90:	10000315 	stw	zero,12(r2)
 90b0a94:	e0bfff17 	ldw	r2,-4(fp)
 90b0a98:	10c00317 	ldw	r3,12(r2)
 90b0a9c:	e0bfff17 	ldw	r2,-4(fp)
 90b0aa0:	10c00115 	stw	r3,4(r2)
}
 90b0aa4:	e037883a 	mov	sp,fp
 90b0aa8:	dfc00117 	ldw	ra,4(sp)
 90b0aac:	df000017 	ldw	fp,0(sp)
 90b0ab0:	dec00204 	addi	sp,sp,8
 90b0ab4:	f800283a 	ret

090b0ab8 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 90b0ab8:	defffb04 	addi	sp,sp,-20
 90b0abc:	dfc00415 	stw	ra,16(sp)
 90b0ac0:	df000315 	stw	fp,12(sp)
 90b0ac4:	df000304 	addi	fp,sp,12
 90b0ac8:	e13ffe15 	stw	r4,-8(fp)
 90b0acc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 90b0ad0:	e0bfff17 	ldw	r2,-4(fp)
 90b0ad4:	1005003a 	cmpeq	r2,r2,zero
 90b0ad8:	10001c1e 	bne	r2,zero,90b0b4c <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 90b0adc:	90a96c80 	call	90a96c8 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 90b0ae0:	e0bffe17 	ldw	r2,-8(fp)
 90b0ae4:	10800617 	ldw	r2,24(r2)
 90b0ae8:	e0bffd15 	stw	r2,-12(fp)
 90b0aec:	e0bffd17 	ldw	r2,-12(fp)
 90b0af0:	1005003a 	cmpeq	r2,r2,zero
 90b0af4:	1000101e 	bne	r2,zero,90b0b38 <sbappend+0x80>
   {
      while (n->m_act)
 90b0af8:	00000306 	br	90b0b08 <sbappend+0x50>
         n = n->m_act;
 90b0afc:	e0bffd17 	ldw	r2,-12(fp)
 90b0b00:	10800717 	ldw	r2,28(r2)
 90b0b04:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 90b0b08:	e0bffd17 	ldw	r2,-12(fp)
 90b0b0c:	10800717 	ldw	r2,28(r2)
 90b0b10:	1004c03a 	cmpne	r2,r2,zero
 90b0b14:	103ff91e 	bne	r2,zero,90b0afc <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 90b0b18:	00000306 	br	90b0b28 <sbappend+0x70>
         n = n->m_next;
 90b0b1c:	e0bffd17 	ldw	r2,-12(fp)
 90b0b20:	10800617 	ldw	r2,24(r2)
 90b0b24:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 90b0b28:	e0bffd17 	ldw	r2,-12(fp)
 90b0b2c:	10800617 	ldw	r2,24(r2)
 90b0b30:	1004c03a 	cmpne	r2,r2,zero
 90b0b34:	103ff91e 	bne	r2,zero,90b0b1c <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 90b0b38:	e13ffe17 	ldw	r4,-8(fp)
 90b0b3c:	e17fff17 	ldw	r5,-4(fp)
 90b0b40:	e1bffd17 	ldw	r6,-12(fp)
 90b0b44:	90b0e480 	call	90b0e48 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 90b0b48:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b0b4c:	e037883a 	mov	sp,fp
 90b0b50:	dfc00117 	ldw	ra,4(sp)
 90b0b54:	df000017 	ldw	fp,0(sp)
 90b0b58:	dec00204 	addi	sp,sp,8
 90b0b5c:	f800283a 	ret

090b0b60 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 90b0b60:	defffb04 	addi	sp,sp,-20
 90b0b64:	dfc00415 	stw	ra,16(sp)
 90b0b68:	df000315 	stw	fp,12(sp)
 90b0b6c:	df000304 	addi	fp,sp,12
 90b0b70:	e13ffe15 	stw	r4,-8(fp)
 90b0b74:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 90b0b78:	e0bfff17 	ldw	r2,-4(fp)
 90b0b7c:	1005003a 	cmpeq	r2,r2,zero
 90b0b80:	10002a1e 	bne	r2,zero,90b0c2c <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 90b0b84:	90a96c80 	call	90a96c8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 90b0b88:	e0bffe17 	ldw	r2,-8(fp)
 90b0b8c:	10800617 	ldw	r2,24(r2)
 90b0b90:	e0bffd15 	stw	r2,-12(fp)
 90b0b94:	e0bffd17 	ldw	r2,-12(fp)
 90b0b98:	1005003a 	cmpeq	r2,r2,zero
 90b0b9c:	1000081e 	bne	r2,zero,90b0bc0 <sbappendrecord+0x60>
      while (m->m_act)
 90b0ba0:	00000306 	br	90b0bb0 <sbappendrecord+0x50>
      m = m->m_act;
 90b0ba4:	e0bffd17 	ldw	r2,-12(fp)
 90b0ba8:	10800717 	ldw	r2,28(r2)
 90b0bac:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 90b0bb0:	e0bffd17 	ldw	r2,-12(fp)
 90b0bb4:	10800717 	ldw	r2,28(r2)
 90b0bb8:	1004c03a 	cmpne	r2,r2,zero
 90b0bbc:	103ff91e 	bne	r2,zero,90b0ba4 <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 90b0bc0:	e0bffe17 	ldw	r2,-8(fp)
 90b0bc4:	10c00017 	ldw	r3,0(r2)
 90b0bc8:	e0bfff17 	ldw	r2,-4(fp)
 90b0bcc:	10800217 	ldw	r2,8(r2)
 90b0bd0:	1887883a 	add	r3,r3,r2
 90b0bd4:	e0bffe17 	ldw	r2,-8(fp)
 90b0bd8:	10c00015 	stw	r3,0(r2)
   if (m)
 90b0bdc:	e0bffd17 	ldw	r2,-12(fp)
 90b0be0:	1005003a 	cmpeq	r2,r2,zero
 90b0be4:	1000041e 	bne	r2,zero,90b0bf8 <sbappendrecord+0x98>
      m->m_act = m0;
 90b0be8:	e0fffd17 	ldw	r3,-12(fp)
 90b0bec:	e0bfff17 	ldw	r2,-4(fp)
 90b0bf0:	18800715 	stw	r2,28(r3)
 90b0bf4:	00000306 	br	90b0c04 <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 90b0bf8:	e0fffe17 	ldw	r3,-8(fp)
 90b0bfc:	e0bfff17 	ldw	r2,-4(fp)
 90b0c00:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 90b0c04:	e0bfff17 	ldw	r2,-4(fp)
 90b0c08:	10800617 	ldw	r2,24(r2)
 90b0c0c:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 90b0c10:	e0bfff17 	ldw	r2,-4(fp)
 90b0c14:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 90b0c18:	e13ffe17 	ldw	r4,-8(fp)
 90b0c1c:	e17ffd17 	ldw	r5,-12(fp)
 90b0c20:	e1bfff17 	ldw	r6,-4(fp)
 90b0c24:	90b0e480 	call	90b0e48 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 90b0c28:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b0c2c:	e037883a 	mov	sp,fp
 90b0c30:	dfc00117 	ldw	ra,4(sp)
 90b0c34:	df000017 	ldw	fp,0(sp)
 90b0c38:	dec00204 	addi	sp,sp,8
 90b0c3c:	f800283a 	ret

090b0c40 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 90b0c40:	defff604 	addi	sp,sp,-40
 90b0c44:	dfc00915 	stw	ra,36(sp)
 90b0c48:	df000815 	stw	fp,32(sp)
 90b0c4c:	df000804 	addi	fp,sp,32
 90b0c50:	e13ffb15 	stw	r4,-20(fp)
 90b0c54:	e17ffc15 	stw	r5,-16(fp)
 90b0c58:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 90b0c5c:	00800404 	movi	r2,16
 90b0c60:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 90b0c64:	90a96c80 	call	90a96c8 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 90b0c68:	e0bffd17 	ldw	r2,-12(fp)
 90b0c6c:	e0bffa15 	stw	r2,-24(fp)
 90b0c70:	00000806 	br	90b0c94 <sbappendaddr+0x54>
      space += m->m_len;
 90b0c74:	e0bffa17 	ldw	r2,-24(fp)
 90b0c78:	10c00217 	ldw	r3,8(r2)
 90b0c7c:	e0bff817 	ldw	r2,-32(fp)
 90b0c80:	1885883a 	add	r2,r3,r2
 90b0c84:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 90b0c88:	e0bffa17 	ldw	r2,-24(fp)
 90b0c8c:	10800617 	ldw	r2,24(r2)
 90b0c90:	e0bffa15 	stw	r2,-24(fp)
 90b0c94:	e0bffa17 	ldw	r2,-24(fp)
 90b0c98:	1004c03a 	cmpne	r2,r2,zero
 90b0c9c:	103ff51e 	bne	r2,zero,90b0c74 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 90b0ca0:	e0bffb17 	ldw	r2,-20(fp)
 90b0ca4:	10800117 	ldw	r2,4(r2)
 90b0ca8:	1007883a 	mov	r3,r2
 90b0cac:	e0bffb17 	ldw	r2,-20(fp)
 90b0cb0:	10800017 	ldw	r2,0(r2)
 90b0cb4:	1885c83a 	sub	r2,r3,r2
 90b0cb8:	1004803a 	cmplt	r2,r2,zero
 90b0cbc:	1000071e 	bne	r2,zero,90b0cdc <sbappendaddr+0x9c>
 90b0cc0:	e0bffb17 	ldw	r2,-20(fp)
 90b0cc4:	10c00117 	ldw	r3,4(r2)
 90b0cc8:	e0bffb17 	ldw	r2,-20(fp)
 90b0ccc:	10800017 	ldw	r2,0(r2)
 90b0cd0:	1885c83a 	sub	r2,r3,r2
 90b0cd4:	e0bfff15 	stw	r2,-4(fp)
 90b0cd8:	00000106 	br	90b0ce0 <sbappendaddr+0xa0>
 90b0cdc:	e03fff15 	stw	zero,-4(fp)
 90b0ce0:	e0bff817 	ldw	r2,-32(fp)
 90b0ce4:	e0ffff17 	ldw	r3,-4(fp)
 90b0ce8:	1880030e 	bge	r3,r2,90b0cf8 <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 90b0cec:	90a97240 	call	90a9724 <irq_Unmask>
      return (0);
 90b0cf0:	e03ffe15 	stw	zero,-8(fp)
 90b0cf4:	00004e06 	br	90b0e30 <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 90b0cf8:	01000244 	movi	r4,9
 90b0cfc:	01400404 	movi	r5,16
 90b0d00:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b0d04:	e0bffa15 	stw	r2,-24(fp)
 90b0d08:	e0bffa17 	ldw	r2,-24(fp)
 90b0d0c:	1004c03a 	cmpne	r2,r2,zero
 90b0d10:	1000031e 	bne	r2,zero,90b0d20 <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 90b0d14:	90a97240 	call	90a9724 <irq_Unmask>
      return 0;
 90b0d18:	e03ffe15 	stw	zero,-8(fp)
 90b0d1c:	00004406 	br	90b0e30 <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 90b0d20:	e0bffa17 	ldw	r2,-24(fp)
 90b0d24:	10800317 	ldw	r2,12(r2)
 90b0d28:	1009883a 	mov	r4,r2
 90b0d2c:	e0fffc17 	ldw	r3,-16(fp)
 90b0d30:	1880000b 	ldhu	r2,0(r3)
 90b0d34:	2080000d 	sth	r2,0(r4)
 90b0d38:	1880008b 	ldhu	r2,2(r3)
 90b0d3c:	2080008d 	sth	r2,2(r4)
 90b0d40:	1880010b 	ldhu	r2,4(r3)
 90b0d44:	2080010d 	sth	r2,4(r4)
 90b0d48:	1880018b 	ldhu	r2,6(r3)
 90b0d4c:	2080018d 	sth	r2,6(r4)
 90b0d50:	1880020b 	ldhu	r2,8(r3)
 90b0d54:	2080020d 	sth	r2,8(r4)
 90b0d58:	1880028b 	ldhu	r2,10(r3)
 90b0d5c:	2080028d 	sth	r2,10(r4)
 90b0d60:	1880030b 	ldhu	r2,12(r3)
 90b0d64:	2080030d 	sth	r2,12(r4)
 90b0d68:	1880038b 	ldhu	r2,14(r3)
 90b0d6c:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 90b0d70:	e0fffa17 	ldw	r3,-24(fp)
 90b0d74:	00800404 	movi	r2,16
 90b0d78:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 90b0d7c:	e0bffb17 	ldw	r2,-20(fp)
 90b0d80:	10c00017 	ldw	r3,0(r2)
 90b0d84:	e0bffa17 	ldw	r2,-24(fp)
 90b0d88:	10800217 	ldw	r2,8(r2)
 90b0d8c:	1887883a 	add	r3,r3,r2
 90b0d90:	e0bffb17 	ldw	r2,-20(fp)
 90b0d94:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 90b0d98:	e0bffb17 	ldw	r2,-20(fp)
 90b0d9c:	10800617 	ldw	r2,24(r2)
 90b0da0:	e0bff915 	stw	r2,-28(fp)
 90b0da4:	e0bff917 	ldw	r2,-28(fp)
 90b0da8:	1005003a 	cmpeq	r2,r2,zero
 90b0dac:	10000c1e 	bne	r2,zero,90b0de0 <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 90b0db0:	00000306 	br	90b0dc0 <sbappendaddr+0x180>
         n = n->m_act;
 90b0db4:	e0bff917 	ldw	r2,-28(fp)
 90b0db8:	10800717 	ldw	r2,28(r2)
 90b0dbc:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 90b0dc0:	e0bff917 	ldw	r2,-28(fp)
 90b0dc4:	10800717 	ldw	r2,28(r2)
 90b0dc8:	1004c03a 	cmpne	r2,r2,zero
 90b0dcc:	103ff91e 	bne	r2,zero,90b0db4 <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 90b0dd0:	e0fff917 	ldw	r3,-28(fp)
 90b0dd4:	e0bffa17 	ldw	r2,-24(fp)
 90b0dd8:	18800715 	stw	r2,28(r3)
 90b0ddc:	00000306 	br	90b0dec <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 90b0de0:	e0fffb17 	ldw	r3,-20(fp)
 90b0de4:	e0bffa17 	ldw	r2,-24(fp)
 90b0de8:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 90b0dec:	e0bffa17 	ldw	r2,-24(fp)
 90b0df0:	10800617 	ldw	r2,24(r2)
 90b0df4:	1005003a 	cmpeq	r2,r2,zero
 90b0df8:	1000031e 	bne	r2,zero,90b0e08 <sbappendaddr+0x1c8>
      m = m->m_next;
 90b0dfc:	e0bffa17 	ldw	r2,-24(fp)
 90b0e00:	10800617 	ldw	r2,24(r2)
 90b0e04:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 90b0e08:	e0bffd17 	ldw	r2,-12(fp)
 90b0e0c:	1005003a 	cmpeq	r2,r2,zero
 90b0e10:	1000041e 	bne	r2,zero,90b0e24 <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 90b0e14:	e13ffb17 	ldw	r4,-20(fp)
 90b0e18:	e17ffd17 	ldw	r5,-12(fp)
 90b0e1c:	e1bffa17 	ldw	r6,-24(fp)
 90b0e20:	90b0e480 	call	90b0e48 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 90b0e24:	90a97240 	call	90a9724 <irq_Unmask>
   return (1);
 90b0e28:	00800044 	movi	r2,1
 90b0e2c:	e0bffe15 	stw	r2,-8(fp)
 90b0e30:	e0bffe17 	ldw	r2,-8(fp)
}
 90b0e34:	e037883a 	mov	sp,fp
 90b0e38:	dfc00117 	ldw	ra,4(sp)
 90b0e3c:	df000017 	ldw	fp,0(sp)
 90b0e40:	dec00204 	addi	sp,sp,8
 90b0e44:	f800283a 	ret

090b0e48 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 90b0e48:	defffb04 	addi	sp,sp,-20
 90b0e4c:	dfc00415 	stw	ra,16(sp)
 90b0e50:	df000315 	stw	fp,12(sp)
 90b0e54:	df000304 	addi	fp,sp,12
 90b0e58:	e13ffd15 	stw	r4,-12(fp)
 90b0e5c:	e17ffe15 	stw	r5,-8(fp)
 90b0e60:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 90b0e64:	00006a06 	br	90b1010 <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 90b0e68:	e0bffe17 	ldw	r2,-8(fp)
 90b0e6c:	10800217 	ldw	r2,8(r2)
 90b0e70:	1004c03a 	cmpne	r2,r2,zero
 90b0e74:	1000041e 	bne	r2,zero,90b0e88 <sbcompress+0x40>
      {
         m = m_free(m);
 90b0e78:	e13ffe17 	ldw	r4,-8(fp)
 90b0e7c:	90aa4700 	call	90aa470 <m_free>
 90b0e80:	e0bffe15 	stw	r2,-8(fp)
         continue;
 90b0e84:	00006206 	br	90b1010 <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 90b0e88:	e0bffe17 	ldw	r2,-8(fp)
 90b0e8c:	10800817 	ldw	r2,32(r2)
 90b0e90:	10800060 	cmpeqi	r2,r2,1
 90b0e94:	1000101e 	bne	r2,zero,90b0ed8 <sbcompress+0x90>
 90b0e98:	e0bffe17 	ldw	r2,-8(fp)
 90b0e9c:	10800817 	ldw	r2,32(r2)
 90b0ea0:	108000a0 	cmpeqi	r2,r2,2
 90b0ea4:	10000c1e 	bne	r2,zero,90b0ed8 <sbcompress+0x90>
 90b0ea8:	e0bffe17 	ldw	r2,-8(fp)
 90b0eac:	10800817 	ldw	r2,32(r2)
 90b0eb0:	10800260 	cmpeqi	r2,r2,9
 90b0eb4:	1000081e 	bne	r2,zero,90b0ed8 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 90b0eb8:	e0bffe17 	ldw	r2,-8(fp)
 90b0ebc:	11400817 	ldw	r5,32(r2)
 90b0ec0:	01024374 	movhi	r4,2317
 90b0ec4:	213f7704 	addi	r4,r4,-548
 90b0ec8:	90825100 	call	9082510 <printf>
         panic ("sbcomp:bad");
 90b0ecc:	01024374 	movhi	r4,2317
 90b0ed0:	213f7c04 	addi	r4,r4,-528
 90b0ed4:	90a438c0 	call	90a438c <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 90b0ed8:	e0bfff17 	ldw	r2,-4(fp)
 90b0edc:	1005003a 	cmpeq	r2,r2,zero
 90b0ee0:	1000331e 	bne	r2,zero,90b0fb0 <sbcompress+0x168>
 90b0ee4:	e0bffd17 	ldw	r2,-12(fp)
 90b0ee8:	1080070b 	ldhu	r2,28(r2)
 90b0eec:	10bfffcc 	andi	r2,r2,65535
 90b0ef0:	1080200c 	andi	r2,r2,128
 90b0ef4:	1005003a 	cmpeq	r2,r2,zero
 90b0ef8:	10002d1e 	bne	r2,zero,90b0fb0 <sbcompress+0x168>
 90b0efc:	e0bfff17 	ldw	r2,-4(fp)
 90b0f00:	10c00217 	ldw	r3,8(r2)
 90b0f04:	e0bffe17 	ldw	r2,-8(fp)
 90b0f08:	10800217 	ldw	r2,8(r2)
 90b0f0c:	188b883a 	add	r5,r3,r2
 90b0f10:	e0bfff17 	ldw	r2,-4(fp)
 90b0f14:	11000517 	ldw	r4,20(r2)
 90b0f18:	e0bfff17 	ldw	r2,-4(fp)
 90b0f1c:	10800317 	ldw	r2,12(r2)
 90b0f20:	1007883a 	mov	r3,r2
 90b0f24:	e0bfff17 	ldw	r2,-4(fp)
 90b0f28:	10800417 	ldw	r2,16(r2)
 90b0f2c:	1885c83a 	sub	r2,r3,r2
 90b0f30:	2085c83a 	sub	r2,r4,r2
 90b0f34:	28801e2e 	bgeu	r5,r2,90b0fb0 <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 90b0f38:	e0bfff17 	ldw	r2,-4(fp)
 90b0f3c:	10c00317 	ldw	r3,12(r2)
 90b0f40:	e0bfff17 	ldw	r2,-4(fp)
 90b0f44:	10800217 	ldw	r2,8(r2)
 90b0f48:	1887883a 	add	r3,r3,r2
 90b0f4c:	e0bffe17 	ldw	r2,-8(fp)
 90b0f50:	11400317 	ldw	r5,12(r2)
 90b0f54:	e0bffe17 	ldw	r2,-8(fp)
 90b0f58:	10800217 	ldw	r2,8(r2)
 90b0f5c:	1809883a 	mov	r4,r3
 90b0f60:	100d883a 	mov	r6,r2
 90b0f64:	90822780 	call	9082278 <memcpy>
         sballoc(sb, m);
 90b0f68:	e0bffd17 	ldw	r2,-12(fp)
 90b0f6c:	10c00017 	ldw	r3,0(r2)
 90b0f70:	e0bffe17 	ldw	r2,-8(fp)
 90b0f74:	10800217 	ldw	r2,8(r2)
 90b0f78:	1887883a 	add	r3,r3,r2
 90b0f7c:	e0bffd17 	ldw	r2,-12(fp)
 90b0f80:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 90b0f84:	e0bfff17 	ldw	r2,-4(fp)
 90b0f88:	10c00217 	ldw	r3,8(r2)
 90b0f8c:	e0bffe17 	ldw	r2,-8(fp)
 90b0f90:	10800217 	ldw	r2,8(r2)
 90b0f94:	1887883a 	add	r3,r3,r2
 90b0f98:	e0bfff17 	ldw	r2,-4(fp)
 90b0f9c:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 90b0fa0:	e13ffe17 	ldw	r4,-8(fp)
 90b0fa4:	90aa4700 	call	90aa470 <m_free>
 90b0fa8:	e0bffe15 	stw	r2,-8(fp)
         continue;
 90b0fac:	00001806 	br	90b1010 <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 90b0fb0:	e0bffd17 	ldw	r2,-12(fp)
 90b0fb4:	10c00017 	ldw	r3,0(r2)
 90b0fb8:	e0bffe17 	ldw	r2,-8(fp)
 90b0fbc:	10800217 	ldw	r2,8(r2)
 90b0fc0:	1887883a 	add	r3,r3,r2
 90b0fc4:	e0bffd17 	ldw	r2,-12(fp)
 90b0fc8:	10c00015 	stw	r3,0(r2)
      if (n)
 90b0fcc:	e0bfff17 	ldw	r2,-4(fp)
 90b0fd0:	1005003a 	cmpeq	r2,r2,zero
 90b0fd4:	1000041e 	bne	r2,zero,90b0fe8 <sbcompress+0x1a0>
         n->m_next = m;
 90b0fd8:	e0ffff17 	ldw	r3,-4(fp)
 90b0fdc:	e0bffe17 	ldw	r2,-8(fp)
 90b0fe0:	18800615 	stw	r2,24(r3)
 90b0fe4:	00000306 	br	90b0ff4 <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 90b0fe8:	e0fffd17 	ldw	r3,-12(fp)
 90b0fec:	e0bffe17 	ldw	r2,-8(fp)
 90b0ff0:	18800615 	stw	r2,24(r3)
      n = m;
 90b0ff4:	e0bffe17 	ldw	r2,-8(fp)
 90b0ff8:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 90b0ffc:	e0bffe17 	ldw	r2,-8(fp)
 90b1000:	10800617 	ldw	r2,24(r2)
 90b1004:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 90b1008:	e0bfff17 	ldw	r2,-4(fp)
 90b100c:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 90b1010:	e0bffe17 	ldw	r2,-8(fp)
 90b1014:	1004c03a 	cmpne	r2,r2,zero
 90b1018:	103f931e 	bne	r2,zero,90b0e68 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 90b101c:	e037883a 	mov	sp,fp
 90b1020:	dfc00117 	ldw	ra,4(sp)
 90b1024:	df000017 	ldw	fp,0(sp)
 90b1028:	dec00204 	addi	sp,sp,8
 90b102c:	f800283a 	ret

090b1030 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 90b1030:	defffd04 	addi	sp,sp,-12
 90b1034:	dfc00215 	stw	ra,8(sp)
 90b1038:	df000115 	stw	fp,4(sp)
 90b103c:	df000104 	addi	fp,sp,4
 90b1040:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 90b1044:	90a96c80 	call	90a96c8 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 90b1048:	e0bfff17 	ldw	r2,-4(fp)
 90b104c:	1080070b 	ldhu	r2,28(r2)
 90b1050:	10bfffcc 	andi	r2,r2,65535
 90b1054:	1080004c 	andi	r2,r2,1
 90b1058:	10803fcc 	andi	r2,r2,255
 90b105c:	1005003a 	cmpeq	r2,r2,zero
 90b1060:	1000091e 	bne	r2,zero,90b1088 <sbflush+0x58>
      panic("sbflush");
 90b1064:	01024374 	movhi	r4,2317
 90b1068:	213f7f04 	addi	r4,r4,-516
 90b106c:	90a438c0 	call	90a438c <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 90b1070:	00000506 	br	90b1088 <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 90b1074:	e0bfff17 	ldw	r2,-4(fp)
 90b1078:	10800017 	ldw	r2,0(r2)
 90b107c:	100b883a 	mov	r5,r2
 90b1080:	e13fff17 	ldw	r4,-4(fp)
 90b1084:	90b10c00 	call	90b10c0 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 90b1088:	e0bfff17 	ldw	r2,-4(fp)
 90b108c:	10800217 	ldw	r2,8(r2)
 90b1090:	1004c03a 	cmpne	r2,r2,zero
 90b1094:	103ff71e 	bne	r2,zero,90b1074 <sbflush+0x44>
 90b1098:	e0bfff17 	ldw	r2,-4(fp)
 90b109c:	10800017 	ldw	r2,0(r2)
 90b10a0:	1004c03a 	cmpne	r2,r2,zero
 90b10a4:	103ff31e 	bne	r2,zero,90b1074 <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 90b10a8:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b10ac:	e037883a 	mov	sp,fp
 90b10b0:	dfc00117 	ldw	ra,4(sp)
 90b10b4:	df000017 	ldw	fp,0(sp)
 90b10b8:	dec00204 	addi	sp,sp,8
 90b10bc:	f800283a 	ret

090b10c0 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 90b10c0:	defff904 	addi	sp,sp,-28
 90b10c4:	dfc00615 	stw	ra,24(sp)
 90b10c8:	df000515 	stw	fp,20(sp)
 90b10cc:	df000504 	addi	fp,sp,20
 90b10d0:	e13ffe15 	stw	r4,-8(fp)
 90b10d4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 90b10d8:	90a96c80 	call	90a96c8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 90b10dc:	e0bffe17 	ldw	r2,-8(fp)
 90b10e0:	10800617 	ldw	r2,24(r2)
 90b10e4:	e0bffd15 	stw	r2,-12(fp)
 90b10e8:	e0bffd17 	ldw	r2,-12(fp)
 90b10ec:	1005003a 	cmpeq	r2,r2,zero
 90b10f0:	1000041e 	bne	r2,zero,90b1104 <sbdrop+0x44>
      next = m->m_act;
 90b10f4:	e0bffd17 	ldw	r2,-12(fp)
 90b10f8:	10800717 	ldw	r2,28(r2)
 90b10fc:	e0bffb15 	stw	r2,-20(fp)
 90b1100:	00003906 	br	90b11e8 <sbdrop+0x128>
   else
      next = NULL;
 90b1104:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 90b1108:	00003706 	br	90b11e8 <sbdrop+0x128>
   {
      if (m == 0) 
 90b110c:	e0bffd17 	ldw	r2,-12(fp)
 90b1110:	1004c03a 	cmpne	r2,r2,zero
 90b1114:	10000c1e 	bne	r2,zero,90b1148 <sbdrop+0x88>
      {
         if (next == 0)
 90b1118:	e0bffb17 	ldw	r2,-20(fp)
 90b111c:	1004c03a 	cmpne	r2,r2,zero
 90b1120:	1000031e 	bne	r2,zero,90b1130 <sbdrop+0x70>
            panic("sbdrop");
 90b1124:	01024374 	movhi	r4,2317
 90b1128:	213f8104 	addi	r4,r4,-508
 90b112c:	90a438c0 	call	90a438c <panic>
         m = next;
 90b1130:	e0bffb17 	ldw	r2,-20(fp)
 90b1134:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 90b1138:	e0bffd17 	ldw	r2,-12(fp)
 90b113c:	10800717 	ldw	r2,28(r2)
 90b1140:	e0bffb15 	stw	r2,-20(fp)
         continue;
 90b1144:	00002806 	br	90b11e8 <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 90b1148:	e0bffd17 	ldw	r2,-12(fp)
 90b114c:	10c00217 	ldw	r3,8(r2)
 90b1150:	e0bfff17 	ldw	r2,-4(fp)
 90b1154:	10c0132e 	bgeu	r2,r3,90b11a4 <sbdrop+0xe4>
      {
         m->m_len -= len;
 90b1158:	e0bffd17 	ldw	r2,-12(fp)
 90b115c:	10c00217 	ldw	r3,8(r2)
 90b1160:	e0bfff17 	ldw	r2,-4(fp)
 90b1164:	1887c83a 	sub	r3,r3,r2
 90b1168:	e0bffd17 	ldw	r2,-12(fp)
 90b116c:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 90b1170:	e0bffd17 	ldw	r2,-12(fp)
 90b1174:	10c00317 	ldw	r3,12(r2)
 90b1178:	e0bfff17 	ldw	r2,-4(fp)
 90b117c:	1887883a 	add	r3,r3,r2
 90b1180:	e0bffd17 	ldw	r2,-12(fp)
 90b1184:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 90b1188:	e0bffe17 	ldw	r2,-8(fp)
 90b118c:	10c00017 	ldw	r3,0(r2)
 90b1190:	e0bfff17 	ldw	r2,-4(fp)
 90b1194:	1887c83a 	sub	r3,r3,r2
 90b1198:	e0bffe17 	ldw	r2,-8(fp)
 90b119c:	10c00015 	stw	r3,0(r2)
         break;
 90b11a0:	00002106 	br	90b1228 <sbdrop+0x168>
      }
      len -= m->m_len;
 90b11a4:	e0ffff17 	ldw	r3,-4(fp)
 90b11a8:	e0bffd17 	ldw	r2,-12(fp)
 90b11ac:	10800217 	ldw	r2,8(r2)
 90b11b0:	1885c83a 	sub	r2,r3,r2
 90b11b4:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 90b11b8:	e0bffe17 	ldw	r2,-8(fp)
 90b11bc:	10c00017 	ldw	r3,0(r2)
 90b11c0:	e0bffd17 	ldw	r2,-12(fp)
 90b11c4:	10800217 	ldw	r2,8(r2)
 90b11c8:	1887c83a 	sub	r3,r3,r2
 90b11cc:	e0bffe17 	ldw	r2,-8(fp)
 90b11d0:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 90b11d4:	e13ffd17 	ldw	r4,-12(fp)
 90b11d8:	90aa4700 	call	90aa470 <m_free>
 90b11dc:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 90b11e0:	e0bffc17 	ldw	r2,-16(fp)
 90b11e4:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 90b11e8:	e0bfff17 	ldw	r2,-4(fp)
 90b11ec:	10800048 	cmpgei	r2,r2,1
 90b11f0:	103fc61e 	bne	r2,zero,90b110c <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 90b11f4:	00000c06 	br	90b1228 <sbdrop+0x168>
   {
      sbfree(sb, m);
 90b11f8:	e0bffe17 	ldw	r2,-8(fp)
 90b11fc:	10c00017 	ldw	r3,0(r2)
 90b1200:	e0bffd17 	ldw	r2,-12(fp)
 90b1204:	10800217 	ldw	r2,8(r2)
 90b1208:	1887c83a 	sub	r3,r3,r2
 90b120c:	e0bffe17 	ldw	r2,-8(fp)
 90b1210:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 90b1214:	e13ffd17 	ldw	r4,-12(fp)
 90b1218:	90aa4700 	call	90aa470 <m_free>
 90b121c:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 90b1220:	e0bffc17 	ldw	r2,-16(fp)
 90b1224:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 90b1228:	e0bffd17 	ldw	r2,-12(fp)
 90b122c:	1005003a 	cmpeq	r2,r2,zero
 90b1230:	1000041e 	bne	r2,zero,90b1244 <sbdrop+0x184>
 90b1234:	e0bffd17 	ldw	r2,-12(fp)
 90b1238:	10800217 	ldw	r2,8(r2)
 90b123c:	1005003a 	cmpeq	r2,r2,zero
 90b1240:	103fed1e 	bne	r2,zero,90b11f8 <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 90b1244:	e0bffd17 	ldw	r2,-12(fp)
 90b1248:	1005003a 	cmpeq	r2,r2,zero
 90b124c:	1000071e 	bne	r2,zero,90b126c <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 90b1250:	e0fffe17 	ldw	r3,-8(fp)
 90b1254:	e0bffd17 	ldw	r2,-12(fp)
 90b1258:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 90b125c:	e0fffd17 	ldw	r3,-12(fp)
 90b1260:	e0bffb17 	ldw	r2,-20(fp)
 90b1264:	18800715 	stw	r2,28(r3)
 90b1268:	00000306 	br	90b1278 <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 90b126c:	e0fffe17 	ldw	r3,-8(fp)
 90b1270:	e0bffb17 	ldw	r2,-20(fp)
 90b1274:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 90b1278:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b127c:	e037883a 	mov	sp,fp
 90b1280:	dfc00117 	ldw	ra,4(sp)
 90b1284:	df000017 	ldw	fp,0(sp)
 90b1288:	dec00204 	addi	sp,sp,8
 90b128c:	f800283a 	ret

090b1290 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 90b1290:	defff904 	addi	sp,sp,-28
 90b1294:	dfc00615 	stw	ra,24(sp)
 90b1298:	df000515 	stw	fp,20(sp)
 90b129c:	df000504 	addi	fp,sp,20
 90b12a0:	e13ffe15 	stw	r4,-8(fp)
 90b12a4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 90b12a8:	90a96c80 	call	90a96c8 <irq_Mask>
   len = mbuf_len(m);
 90b12ac:	e13fff17 	ldw	r4,-4(fp)
 90b12b0:	90aaadc0 	call	90aaadc <mbuf_len>
 90b12b4:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 90b12b8:	e0bffb17 	ldw	r2,-20(fp)
 90b12bc:	10800050 	cmplti	r2,r2,1
 90b12c0:	1000051e 	bne	r2,zero,90b12d8 <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 90b12c4:	e0bffe17 	ldw	r2,-8(fp)
 90b12c8:	11000617 	ldw	r4,24(r2)
 90b12cc:	e0bffb17 	ldw	r2,-20(fp)
 90b12d0:	008bc83a 	sub	r5,zero,r2
 90b12d4:	90aa90c0 	call	90aa90c <m_adj>
   nmb = sb->sb_mb;
 90b12d8:	e0bffe17 	ldw	r2,-8(fp)
 90b12dc:	10800617 	ldw	r2,24(r2)
 90b12e0:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 90b12e4:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 90b12e8:	e0bffe17 	ldw	r2,-8(fp)
 90b12ec:	10800617 	ldw	r2,24(r2)
 90b12f0:	10800217 	ldw	r2,8(r2)
 90b12f4:	1004c03a 	cmpne	r2,r2,zero
 90b12f8:	1000081e 	bne	r2,zero,90b131c <sbdropend+0x8c>
      sb->sb_mb = NULL;
 90b12fc:	e0bffe17 	ldw	r2,-8(fp)
 90b1300:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 90b1304:	00000506 	br	90b131c <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 90b1308:	e0bffd17 	ldw	r2,-12(fp)
 90b130c:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 90b1310:	e0bffd17 	ldw	r2,-12(fp)
 90b1314:	10800617 	ldw	r2,24(r2)
 90b1318:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 90b131c:	e0bffd17 	ldw	r2,-12(fp)
 90b1320:	1005003a 	cmpeq	r2,r2,zero
 90b1324:	1000041e 	bne	r2,zero,90b1338 <sbdropend+0xa8>
 90b1328:	e0bffd17 	ldw	r2,-12(fp)
 90b132c:	10800217 	ldw	r2,8(r2)
 90b1330:	1004c03a 	cmpne	r2,r2,zero
 90b1334:	103ff41e 	bne	r2,zero,90b1308 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 90b1338:	e0bffd17 	ldw	r2,-12(fp)
 90b133c:	1005003a 	cmpeq	r2,r2,zero
 90b1340:	10000b1e 	bne	r2,zero,90b1370 <sbdropend+0xe0>
 90b1344:	e0bffd17 	ldw	r2,-12(fp)
 90b1348:	10800217 	ldw	r2,8(r2)
 90b134c:	1004c03a 	cmpne	r2,r2,zero
 90b1350:	1000071e 	bne	r2,zero,90b1370 <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 90b1354:	e0bffc17 	ldw	r2,-16(fp)
 90b1358:	1005003a 	cmpeq	r2,r2,zero
 90b135c:	1000021e 	bne	r2,zero,90b1368 <sbdropend+0xd8>
         pmb->m_next = NULL;
 90b1360:	e0bffc17 	ldw	r2,-16(fp)
 90b1364:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 90b1368:	e13ffd17 	ldw	r4,-12(fp)
 90b136c:	90aa5a40 	call	90aa5a4 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 90b1370:	e0bffe17 	ldw	r2,-8(fp)
 90b1374:	10c00017 	ldw	r3,0(r2)
 90b1378:	e0bffb17 	ldw	r2,-20(fp)
 90b137c:	1887c83a 	sub	r3,r3,r2
 90b1380:	e0bffe17 	ldw	r2,-8(fp)
 90b1384:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 90b1388:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b138c:	e037883a 	mov	sp,fp
 90b1390:	dfc00117 	ldw	ra,4(sp)
 90b1394:	df000017 	ldw	fp,0(sp)
 90b1398:	dec00204 	addi	sp,sp,8
 90b139c:	f800283a 	ret

090b13a0 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 90b13a0:	defffb04 	addi	sp,sp,-20
 90b13a4:	dfc00415 	stw	ra,16(sp)
 90b13a8:	df000315 	stw	fp,12(sp)
 90b13ac:	df000304 	addi	fp,sp,12
 90b13b0:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 90b13b4:	90a96c80 	call	90a96c8 <irq_Mask>
   m = sb->sb_mb;
 90b13b8:	e0bfff17 	ldw	r2,-4(fp)
 90b13bc:	10800617 	ldw	r2,24(r2)
 90b13c0:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 90b13c4:	e0bffe17 	ldw	r2,-8(fp)
 90b13c8:	1005003a 	cmpeq	r2,r2,zero
 90b13cc:	1000131e 	bne	r2,zero,90b141c <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 90b13d0:	e0bffe17 	ldw	r2,-8(fp)
 90b13d4:	10c00717 	ldw	r3,28(r2)
 90b13d8:	e0bfff17 	ldw	r2,-4(fp)
 90b13dc:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 90b13e0:	e0bfff17 	ldw	r2,-4(fp)
 90b13e4:	10c00017 	ldw	r3,0(r2)
 90b13e8:	e0bffe17 	ldw	r2,-8(fp)
 90b13ec:	10800217 	ldw	r2,8(r2)
 90b13f0:	1887c83a 	sub	r3,r3,r2
 90b13f4:	e0bfff17 	ldw	r2,-4(fp)
 90b13f8:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 90b13fc:	e13ffe17 	ldw	r4,-8(fp)
 90b1400:	90aa4700 	call	90aa470 <m_free>
 90b1404:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 90b1408:	e0bffd17 	ldw	r2,-12(fp)
 90b140c:	e0bffe15 	stw	r2,-8(fp)
 90b1410:	e0bffe17 	ldw	r2,-8(fp)
 90b1414:	1004c03a 	cmpne	r2,r2,zero
 90b1418:	103ff11e 	bne	r2,zero,90b13e0 <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 90b141c:	90a97240 	call	90a9724 <irq_Unmask>
}
 90b1420:	e037883a 	mov	sp,fp
 90b1424:	dfc00117 	ldw	ra,4(sp)
 90b1428:	df000017 	ldw	fp,0(sp)
 90b142c:	dec00204 	addi	sp,sp,8
 90b1430:	f800283a 	ret

090b1434 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 90b1434:	defe7204 	addi	sp,sp,-1592
 90b1438:	dfc18d15 	stw	ra,1588(sp)
 90b143c:	df018c15 	stw	fp,1584(sp)
 90b1440:	df018c04 	addi	fp,sp,1584
 90b1444:	e13ffc15 	stw	r4,-16(fp)
 90b1448:	e17ffd15 	stw	r5,-12(fp)
 90b144c:	e1bffe15 	stw	r6,-8(fp)
 90b1450:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 90b1454:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 90b1458:	e0be7604 	addi	r2,fp,-1576
 90b145c:	1009883a 	mov	r4,r2
 90b1460:	0180c304 	movi	r6,780
 90b1464:	000b883a 	mov	r5,zero
 90b1468:	90823f80 	call	90823f8 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 90b146c:	e0bf3904 	addi	r2,fp,-796
 90b1470:	1009883a 	mov	r4,r2
 90b1474:	0180c304 	movi	r6,780
 90b1478:	000b883a 	mov	r5,zero
 90b147c:	90823f80 	call	90823f8 <memset>

   if (in)
 90b1480:	e0bffc17 	ldw	r2,-16(fp)
 90b1484:	1005003a 	cmpeq	r2,r2,zero
 90b1488:	1000061e 	bne	r2,zero,90b14a4 <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 90b148c:	e0bf3904 	addi	r2,fp,-796
 90b1490:	e0fffc17 	ldw	r3,-16(fp)
 90b1494:	1009883a 	mov	r4,r2
 90b1498:	180b883a 	mov	r5,r3
 90b149c:	01804104 	movi	r6,260
 90b14a0:	90822780 	call	9082278 <memcpy>
   if (out)
 90b14a4:	e0bffd17 	ldw	r2,-12(fp)
 90b14a8:	1005003a 	cmpeq	r2,r2,zero
 90b14ac:	1000071e 	bne	r2,zero,90b14cc <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 90b14b0:	e0bf3904 	addi	r2,fp,-796
 90b14b4:	10804104 	addi	r2,r2,260
 90b14b8:	e0fffd17 	ldw	r3,-12(fp)
 90b14bc:	1009883a 	mov	r4,r2
 90b14c0:	180b883a 	mov	r5,r3
 90b14c4:	01804104 	movi	r6,260
 90b14c8:	90822780 	call	9082278 <memcpy>
   if (ex)
 90b14cc:	e0bffe17 	ldw	r2,-8(fp)
 90b14d0:	1005003a 	cmpeq	r2,r2,zero
 90b14d4:	1000071e 	bne	r2,zero,90b14f4 <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 90b14d8:	e0bf3904 	addi	r2,fp,-796
 90b14dc:	10808204 	addi	r2,r2,520
 90b14e0:	e0fffe17 	ldw	r3,-8(fp)
 90b14e4:	1009883a 	mov	r4,r2
 90b14e8:	180b883a 	mov	r5,r3
 90b14ec:	01804104 	movi	r6,260
 90b14f0:	90822780 	call	9082278 <memcpy>
   tmo = cticks + tv;
 90b14f4:	00824374 	movhi	r2,2317
 90b14f8:	108c4204 	addi	r2,r2,12552
 90b14fc:	10c00017 	ldw	r3,0(r2)
 90b1500:	e0bfff17 	ldw	r2,-4(fp)
 90b1504:	1885883a 	add	r2,r3,r2
 90b1508:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 90b150c:	e0bf3917 	ldw	r2,-796(fp)
 90b1510:	1004c03a 	cmpne	r2,r2,zero
 90b1514:	10000e1e 	bne	r2,zero,90b1550 <t_select+0x11c>
 90b1518:	e0bf7a17 	ldw	r2,-536(fp)
 90b151c:	1004c03a 	cmpne	r2,r2,zero
 90b1520:	10000b1e 	bne	r2,zero,90b1550 <t_select+0x11c>
 90b1524:	e0bfbb17 	ldw	r2,-276(fp)
 90b1528:	1004c03a 	cmpne	r2,r2,zero
 90b152c:	1000081e 	bne	r2,zero,90b1550 <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 90b1530:	e0bfff17 	ldw	r2,-4(fp)
 90b1534:	10800050 	cmplti	r2,r2,1
 90b1538:	1000201e 	bne	r2,zero,90b15bc <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 90b153c:	e0bfff17 	ldw	r2,-4(fp)
 90b1540:	10800044 	addi	r2,r2,1
 90b1544:	113fffcc 	andi	r4,r2,65535
 90b1548:	9094e000 	call	9094e00 <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 90b154c:	00001b06 	br	90b15bc <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 90b1550:	0009883a 	mov	r4,zero
 90b1554:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 90b1558:	00000f06 	br	90b1598 <t_select+0x164>
      {
         if (tv != -1L) 
 90b155c:	e0bfff17 	ldw	r2,-4(fp)
 90b1560:	10bfffe0 	cmpeqi	r2,r2,-1
 90b1564:	1000051e 	bne	r2,zero,90b157c <t_select+0x148>
         {
            if (tmo <= cticks)
 90b1568:	00824374 	movhi	r2,2317
 90b156c:	108c4204 	addi	r2,r2,12552
 90b1570:	10c00017 	ldw	r3,0(r2)
 90b1574:	e0be7517 	ldw	r2,-1580(fp)
 90b1578:	18800e2e 	bgeu	r3,r2,90b15b4 <t_select+0x180>
               break;
         }
         select_wait = 1;
 90b157c:	00c24374 	movhi	r3,2317
 90b1580:	18cc4a04 	addi	r3,r3,12584
 90b1584:	00800044 	movi	r2,1
 90b1588:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 90b158c:	01024374 	movhi	r4,2317
 90b1590:	210c4a04 	addi	r4,r4,12584
 90b1594:	90a4d040 	call	90a4d04 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 90b1598:	e13f3904 	addi	r4,fp,-796
 90b159c:	e17e7604 	addi	r5,fp,-1576
 90b15a0:	90b16540 	call	90b1654 <sock_selscan>
 90b15a4:	e0be7415 	stw	r2,-1584(fp)
 90b15a8:	e0be7417 	ldw	r2,-1584(fp)
 90b15ac:	1005003a 	cmpeq	r2,r2,zero
 90b15b0:	103fea1e 	bne	r2,zero,90b155c <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b15b4:	0009883a 	mov	r4,zero
 90b15b8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 90b15bc:	e0be7417 	ldw	r2,-1584(fp)
 90b15c0:	1004803a 	cmplt	r2,r2,zero
 90b15c4:	10001d1e 	bne	r2,zero,90b163c <t_select+0x208>
   {
      if (in)
 90b15c8:	e0bffc17 	ldw	r2,-16(fp)
 90b15cc:	1005003a 	cmpeq	r2,r2,zero
 90b15d0:	1000061e 	bne	r2,zero,90b15ec <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 90b15d4:	e0bffc17 	ldw	r2,-16(fp)
 90b15d8:	e0fe7604 	addi	r3,fp,-1576
 90b15dc:	1009883a 	mov	r4,r2
 90b15e0:	180b883a 	mov	r5,r3
 90b15e4:	01804104 	movi	r6,260
 90b15e8:	90822780 	call	9082278 <memcpy>
      if (out)
 90b15ec:	e0bffd17 	ldw	r2,-12(fp)
 90b15f0:	1005003a 	cmpeq	r2,r2,zero
 90b15f4:	1000071e 	bne	r2,zero,90b1614 <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 90b15f8:	e0be7604 	addi	r2,fp,-1576
 90b15fc:	10c04104 	addi	r3,r2,260
 90b1600:	e0bffd17 	ldw	r2,-12(fp)
 90b1604:	1009883a 	mov	r4,r2
 90b1608:	180b883a 	mov	r5,r3
 90b160c:	01804104 	movi	r6,260
 90b1610:	90822780 	call	9082278 <memcpy>
      if (ex)
 90b1614:	e0bffe17 	ldw	r2,-8(fp)
 90b1618:	1005003a 	cmpeq	r2,r2,zero
 90b161c:	1000071e 	bne	r2,zero,90b163c <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 90b1620:	e0be7604 	addi	r2,fp,-1576
 90b1624:	10c08204 	addi	r3,r2,520
 90b1628:	e0bffe17 	ldw	r2,-8(fp)
 90b162c:	1009883a 	mov	r4,r2
 90b1630:	180b883a 	mov	r5,r3
 90b1634:	01804104 	movi	r6,260
 90b1638:	90822780 	call	9082278 <memcpy>
   }
   return retval;
 90b163c:	e0be7417 	ldw	r2,-1584(fp)
}
 90b1640:	e037883a 	mov	sp,fp
 90b1644:	dfc00117 	ldw	ra,4(sp)
 90b1648:	df000017 	ldw	fp,0(sp)
 90b164c:	dec00204 	addi	sp,sp,8
 90b1650:	f800283a 	ret

090b1654 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 90b1654:	defff504 	addi	sp,sp,-44
 90b1658:	dfc00a15 	stw	ra,40(sp)
 90b165c:	df000915 	stw	fp,36(sp)
 90b1660:	df000904 	addi	fp,sp,36
 90b1664:	e13ffd15 	stw	r4,-12(fp)
 90b1668:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 90b166c:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 90b1670:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 90b1674:	e03ffa15 	stw	zero,-24(fp)
 90b1678:	00004306 	br	90b1788 <sock_selscan+0x134>
   {
      switch (which)
 90b167c:	e0bffa17 	ldw	r2,-24(fp)
 90b1680:	e0bfff15 	stw	r2,-4(fp)
 90b1684:	e0ffff17 	ldw	r3,-4(fp)
 90b1688:	18800060 	cmpeqi	r2,r3,1
 90b168c:	10000a1e 	bne	r2,zero,90b16b8 <sock_selscan+0x64>
 90b1690:	e0ffff17 	ldw	r3,-4(fp)
 90b1694:	188000a0 	cmpeqi	r2,r3,2
 90b1698:	10000a1e 	bne	r2,zero,90b16c4 <sock_selscan+0x70>
 90b169c:	e0ffff17 	ldw	r3,-4(fp)
 90b16a0:	1805003a 	cmpeq	r2,r3,zero
 90b16a4:	1000011e 	bne	r2,zero,90b16ac <sock_selscan+0x58>
 90b16a8:	00000706 	br	90b16c8 <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 90b16ac:	00800044 	movi	r2,1
 90b16b0:	e0bff815 	stw	r2,-32(fp)
 90b16b4:	00000406 	br	90b16c8 <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 90b16b8:	00800084 	movi	r2,2
 90b16bc:	e0bff815 	stw	r2,-32(fp)
 90b16c0:	00000106 	br	90b16c8 <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 90b16c4:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 90b16c8:	e0bffa17 	ldw	r2,-24(fp)
 90b16cc:	10804124 	muli	r2,r2,260
 90b16d0:	1007883a 	mov	r3,r2
 90b16d4:	e0bffd17 	ldw	r2,-12(fp)
 90b16d8:	1885883a 	add	r2,r3,r2
 90b16dc:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 90b16e0:	e0bffa17 	ldw	r2,-24(fp)
 90b16e4:	10804124 	muli	r2,r2,260
 90b16e8:	1007883a 	mov	r3,r2
 90b16ec:	e0bffe17 	ldw	r2,-8(fp)
 90b16f0:	1885883a 	add	r2,r3,r2
 90b16f4:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 90b16f8:	e03ff915 	stw	zero,-28(fp)
 90b16fc:	00001a06 	br	90b1768 <sock_selscan+0x114>
      {
         if (sock_select (in->fd_array[sock], flag))
 90b1700:	e0bff917 	ldw	r2,-28(fp)
 90b1704:	e0fffc17 	ldw	r3,-16(fp)
 90b1708:	1085883a 	add	r2,r2,r2
 90b170c:	1085883a 	add	r2,r2,r2
 90b1710:	10c5883a 	add	r2,r2,r3
 90b1714:	10800104 	addi	r2,r2,4
 90b1718:	11000017 	ldw	r4,0(r2)
 90b171c:	e17ff817 	ldw	r5,-32(fp)
 90b1720:	90b17ac0 	call	90b17ac <sock_select>
 90b1724:	1005003a 	cmpeq	r2,r2,zero
 90b1728:	10000c1e 	bne	r2,zero,90b175c <sock_selscan+0x108>
         {
            FD_SET(in->fd_array[sock], out);
 90b172c:	e0bff917 	ldw	r2,-28(fp)
 90b1730:	e0fffc17 	ldw	r3,-16(fp)
 90b1734:	1085883a 	add	r2,r2,r2
 90b1738:	1085883a 	add	r2,r2,r2
 90b173c:	10c5883a 	add	r2,r2,r3
 90b1740:	10800104 	addi	r2,r2,4
 90b1744:	11000017 	ldw	r4,0(r2)
 90b1748:	e17ffb17 	ldw	r5,-20(fp)
 90b174c:	90b1be40 	call	90b1be4 <ifd_set>
            num_sel++;
 90b1750:	e0bff717 	ldw	r2,-36(fp)
 90b1754:	10800044 	addi	r2,r2,1
 90b1758:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 90b175c:	e0bff917 	ldw	r2,-28(fp)
 90b1760:	10800044 	addi	r2,r2,1
 90b1764:	e0bff915 	stw	r2,-28(fp)
 90b1768:	e0bffc17 	ldw	r2,-16(fp)
 90b176c:	10800017 	ldw	r2,0(r2)
 90b1770:	1007883a 	mov	r3,r2
 90b1774:	e0bff917 	ldw	r2,-28(fp)
 90b1778:	10ffe116 	blt	r2,r3,90b1700 <sock_selscan+0xac>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 90b177c:	e0bffa17 	ldw	r2,-24(fp)
 90b1780:	10800044 	addi	r2,r2,1
 90b1784:	e0bffa15 	stw	r2,-24(fp)
 90b1788:	e0bffa17 	ldw	r2,-24(fp)
 90b178c:	108000d0 	cmplti	r2,r2,3
 90b1790:	103fba1e 	bne	r2,zero,90b167c <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 90b1794:	e0bff717 	ldw	r2,-36(fp)
}
 90b1798:	e037883a 	mov	sp,fp
 90b179c:	dfc00117 	ldw	ra,4(sp)
 90b17a0:	df000017 	ldw	fp,0(sp)
 90b17a4:	dec00204 	addi	sp,sp,8
 90b17a8:	f800283a 	ret

090b17ac <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 90b17ac:	defff904 	addi	sp,sp,-28
 90b17b0:	dfc00615 	stw	ra,24(sp)
 90b17b4:	df000515 	stw	fp,20(sp)
 90b17b8:	df000504 	addi	fp,sp,20
 90b17bc:	e13ffd15 	stw	r4,-12(fp)
 90b17c0:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 90b17c4:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 90b17c8:	e0bffd17 	ldw	r2,-12(fp)
 90b17cc:	10bff804 	addi	r2,r2,-32
 90b17d0:	1085883a 	add	r2,r2,r2
 90b17d4:	1085883a 	add	r2,r2,r2
 90b17d8:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 90b17dc:	e0bffe17 	ldw	r2,-8(fp)
 90b17e0:	e0bfff15 	stw	r2,-4(fp)
 90b17e4:	e0ffff17 	ldw	r3,-4(fp)
 90b17e8:	18800060 	cmpeqi	r2,r3,1
 90b17ec:	1000071e 	bne	r2,zero,90b180c <sock_select+0x60>
 90b17f0:	e0ffff17 	ldw	r3,-4(fp)
 90b17f4:	188000a0 	cmpeqi	r2,r3,2
 90b17f8:	1000251e 	bne	r2,zero,90b1890 <sock_select+0xe4>
 90b17fc:	e0ffff17 	ldw	r3,-4(fp)
 90b1800:	1805003a 	cmpeq	r2,r3,zero
 90b1804:	1000491e 	bne	r2,zero,90b192c <sock_select+0x180>
 90b1808:	00006706 	br	90b19a8 <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 90b180c:	e0bffc17 	ldw	r2,-16(fp)
 90b1810:	10800a17 	ldw	r2,40(r2)
 90b1814:	1005003a 	cmpeq	r2,r2,zero
 90b1818:	1000031e 	bne	r2,zero,90b1828 <sock_select+0x7c>
      {
         ready = 1;
 90b181c:	00800044 	movi	r2,1
 90b1820:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b1824:	00006006 	br	90b19a8 <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 90b1828:	e0bffc17 	ldw	r2,-16(fp)
 90b182c:	1080088b 	ldhu	r2,34(r2)
 90b1830:	10bfffcc 	andi	r2,r2,65535
 90b1834:	1080080c 	andi	r2,r2,32
 90b1838:	1005003a 	cmpeq	r2,r2,zero
 90b183c:	1000031e 	bne	r2,zero,90b184c <sock_select+0xa0>
      {  ready = 1;
 90b1840:	00800044 	movi	r2,1
 90b1844:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b1848:	00005706 	br	90b19a8 <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 90b184c:	e0bffc17 	ldw	r2,-16(fp)
 90b1850:	10801e43 	ldbu	r2,121(r2)
 90b1854:	10803fcc 	andi	r2,r2,255
 90b1858:	1080201c 	xori	r2,r2,128
 90b185c:	10bfe004 	addi	r2,r2,-128
 90b1860:	1005003a 	cmpeq	r2,r2,zero
 90b1864:	1000031e 	bne	r2,zero,90b1874 <sock_select+0xc8>
      {
         ready = 1;
 90b1868:	00800044 	movi	r2,1
 90b186c:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b1870:	00004d06 	br	90b19a8 <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 90b1874:	e0bffc17 	ldw	r2,-16(fp)
 90b1878:	1080110b 	ldhu	r2,68(r2)
 90b187c:	10800214 	ori	r2,r2,8
 90b1880:	1007883a 	mov	r3,r2
 90b1884:	e0bffc17 	ldw	r2,-16(fp)
 90b1888:	10c0110d 	sth	r3,68(r2)
      break;
 90b188c:	00004606 	br	90b19a8 <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 90b1890:	e0bffc17 	ldw	r2,-16(fp)
 90b1894:	10801317 	ldw	r2,76(r2)
 90b1898:	1007883a 	mov	r3,r2
 90b189c:	e0bffc17 	ldw	r2,-16(fp)
 90b18a0:	10801217 	ldw	r2,72(r2)
 90b18a4:	1885c83a 	sub	r2,r3,r2
 90b18a8:	1004803a 	cmplt	r2,r2,zero
 90b18ac:	10001b1e 	bne	r2,zero,90b191c <sock_select+0x170>
 90b18b0:	e0bffc17 	ldw	r2,-16(fp)
 90b18b4:	10c01317 	ldw	r3,76(r2)
 90b18b8:	e0bffc17 	ldw	r2,-16(fp)
 90b18bc:	10801217 	ldw	r2,72(r2)
 90b18c0:	18801626 	beq	r3,r2,90b191c <sock_select+0x170>
 90b18c4:	e0bffc17 	ldw	r2,-16(fp)
 90b18c8:	1080088b 	ldhu	r2,34(r2)
 90b18cc:	10bfffcc 	andi	r2,r2,65535
 90b18d0:	1080008c 	andi	r2,r2,2
 90b18d4:	1004c03a 	cmpne	r2,r2,zero
 90b18d8:	10000d1e 	bne	r2,zero,90b1910 <sock_select+0x164>
 90b18dc:	e0bffc17 	ldw	r2,-16(fp)
 90b18e0:	10800217 	ldw	r2,8(r2)
 90b18e4:	1080010b 	ldhu	r2,4(r2)
 90b18e8:	10bfffcc 	andi	r2,r2,65535
 90b18ec:	1080010c 	andi	r2,r2,4
 90b18f0:	1005003a 	cmpeq	r2,r2,zero
 90b18f4:	1000061e 	bne	r2,zero,90b1910 <sock_select+0x164>
 90b18f8:	e0bffc17 	ldw	r2,-16(fp)
 90b18fc:	1080088b 	ldhu	r2,34(r2)
 90b1900:	10bfffcc 	andi	r2,r2,65535
 90b1904:	1080040c 	andi	r2,r2,16
 90b1908:	1005003a 	cmpeq	r2,r2,zero
 90b190c:	1000031e 	bne	r2,zero,90b191c <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 90b1910:	00800044 	movi	r2,1
 90b1914:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b1918:	00002306 	br	90b19a8 <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 90b191c:	e0bffc17 	ldw	r2,-16(fp)
 90b1920:	11001204 	addi	r4,r2,72
 90b1924:	90b08540 	call	90b0854 <sbselqueue>
      break;
 90b1928:	00001f06 	br	90b19a8 <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 90b192c:	e0bffc17 	ldw	r2,-16(fp)
 90b1930:	10801a17 	ldw	r2,104(r2)
 90b1934:	1004c03a 	cmpne	r2,r2,zero
 90b1938:	1000061e 	bne	r2,zero,90b1954 <sock_select+0x1a8>
 90b193c:	e0bffc17 	ldw	r2,-16(fp)
 90b1940:	1080088b 	ldhu	r2,34(r2)
 90b1944:	10bfffcc 	andi	r2,r2,65535
 90b1948:	1080100c 	andi	r2,r2,64
 90b194c:	1005003a 	cmpeq	r2,r2,zero
 90b1950:	1000031e 	bne	r2,zero,90b1960 <sock_select+0x1b4>
      {
         ready = 1;
 90b1954:	00800044 	movi	r2,1
 90b1958:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b195c:	00001206 	br	90b19a8 <sock_select+0x1fc>
      }
      if (so->so_error &&
 90b1960:	e0bffc17 	ldw	r2,-16(fp)
 90b1964:	10800617 	ldw	r2,24(r2)
 90b1968:	1005003a 	cmpeq	r2,r2,zero
 90b196c:	10000b1e 	bne	r2,zero,90b199c <sock_select+0x1f0>
 90b1970:	e0bffc17 	ldw	r2,-16(fp)
 90b1974:	10800617 	ldw	r2,24(r2)
 90b1978:	10801de0 	cmpeqi	r2,r2,119
 90b197c:	1000071e 	bne	r2,zero,90b199c <sock_select+0x1f0>
 90b1980:	e0bffc17 	ldw	r2,-16(fp)
 90b1984:	10800617 	ldw	r2,24(r2)
 90b1988:	108002e0 	cmpeqi	r2,r2,11
 90b198c:	1000031e 	bne	r2,zero,90b199c <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 90b1990:	00800044 	movi	r2,1
 90b1994:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b1998:	00000306 	br	90b19a8 <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 90b199c:	e0bffc17 	ldw	r2,-16(fp)
 90b19a0:	11000a04 	addi	r4,r2,40
 90b19a4:	90b08540 	call	90b0854 <sbselqueue>
      break;
   }

   return ready;
 90b19a8:	e0bffb17 	ldw	r2,-20(fp)
}
 90b19ac:	e037883a 	mov	sp,fp
 90b19b0:	dfc00117 	ldw	ra,4(sp)
 90b19b4:	df000017 	ldw	fp,0(sp)
 90b19b8:	dec00204 	addi	sp,sp,8
 90b19bc:	f800283a 	ret

090b19c0 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 90b19c0:	defff804 	addi	sp,sp,-32
 90b19c4:	dfc00715 	stw	ra,28(sp)
 90b19c8:	df000615 	stw	fp,24(sp)
 90b19cc:	df000604 	addi	fp,sp,24
 90b19d0:	e13ffc15 	stw	r4,-16(fp)
 90b19d4:	e17ffd15 	stw	r5,-12(fp)
 90b19d8:	e1bffe15 	stw	r6,-8(fp)
 90b19dc:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 90b19e0:	e0bffc17 	ldw	r2,-16(fp)
 90b19e4:	10800017 	ldw	r2,0(r2)
 90b19e8:	e0bffb15 	stw	r2,-20(fp)
 90b19ec:	00001f06 	br	90b1a6c <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 90b19f0:	e0bffb17 	ldw	r2,-20(fp)
 90b19f4:	10c00317 	ldw	r3,12(r2)
 90b19f8:	e0bffd17 	ldw	r2,-12(fp)
 90b19fc:	10800017 	ldw	r2,0(r2)
 90b1a00:	1880041e 	bne	r3,r2,90b1a14 <in_pcbnotify+0x54>
 90b1a04:	e0bffb17 	ldw	r2,-20(fp)
 90b1a08:	10800817 	ldw	r2,32(r2)
 90b1a0c:	1004c03a 	cmpne	r2,r2,zero
 90b1a10:	1000041e 	bne	r2,zero,90b1a24 <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 90b1a14:	e0bffb17 	ldw	r2,-20(fp)
 90b1a18:	10800017 	ldw	r2,0(r2)
 90b1a1c:	e0bffb15 	stw	r2,-20(fp)
         continue;
 90b1a20:	00001206 	br	90b1a6c <in_pcbnotify+0xac>
      }
      if (errnum) 
 90b1a24:	e0bffe17 	ldw	r2,-8(fp)
 90b1a28:	1005003a 	cmpeq	r2,r2,zero
 90b1a2c:	1000041e 	bne	r2,zero,90b1a40 <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 90b1a30:	e0bffb17 	ldw	r2,-20(fp)
 90b1a34:	10c00817 	ldw	r3,32(r2)
 90b1a38:	e0bffe17 	ldw	r2,-8(fp)
 90b1a3c:	18800615 	stw	r2,24(r3)
      oinp = inp;
 90b1a40:	e0bffb17 	ldw	r2,-20(fp)
 90b1a44:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 90b1a48:	e0bffb17 	ldw	r2,-20(fp)
 90b1a4c:	10800017 	ldw	r2,0(r2)
 90b1a50:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 90b1a54:	e0bfff17 	ldw	r2,-4(fp)
 90b1a58:	1005003a 	cmpeq	r2,r2,zero
 90b1a5c:	1000031e 	bne	r2,zero,90b1a6c <in_pcbnotify+0xac>
         (*notify)(oinp);
 90b1a60:	e0bfff17 	ldw	r2,-4(fp)
 90b1a64:	e13ffa17 	ldw	r4,-24(fp)
 90b1a68:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 90b1a6c:	e0fffb17 	ldw	r3,-20(fp)
 90b1a70:	e0bffc17 	ldw	r2,-16(fp)
 90b1a74:	18bfde1e 	bne	r3,r2,90b19f0 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 90b1a78:	e037883a 	mov	sp,fp
 90b1a7c:	dfc00117 	ldw	ra,4(sp)
 90b1a80:	df000017 	ldw	fp,0(sp)
 90b1a84:	dec00204 	addi	sp,sp,8
 90b1a88:	f800283a 	ret

090b1a8c <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 90b1a8c:	defffd04 	addi	sp,sp,-12
 90b1a90:	dfc00215 	stw	ra,8(sp)
 90b1a94:	df000115 	stw	fp,4(sp)
 90b1a98:	df000104 	addi	fp,sp,4
 90b1a9c:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 90b1aa0:	e0bfff17 	ldw	r2,-4(fp)
 90b1aa4:	10800817 	ldw	r2,32(r2)
 90b1aa8:	11000904 	addi	r4,r2,36
 90b1aac:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 90b1ab0:	e0bfff17 	ldw	r2,-4(fp)
 90b1ab4:	11000817 	ldw	r4,32(r2)
 90b1ab8:	e0bfff17 	ldw	r2,-4(fp)
 90b1abc:	10800817 	ldw	r2,32(r2)
 90b1ac0:	11400a04 	addi	r5,r2,40
 90b1ac4:	90b08f40 	call	90b08f4 <sbwakeup>
   sowwakeup(inp->inp_socket);
 90b1ac8:	e0bfff17 	ldw	r2,-4(fp)
 90b1acc:	11000817 	ldw	r4,32(r2)
 90b1ad0:	e0bfff17 	ldw	r2,-4(fp)
 90b1ad4:	10800817 	ldw	r2,32(r2)
 90b1ad8:	11401204 	addi	r5,r2,72
 90b1adc:	90b08f40 	call	90b08f4 <sbwakeup>
}
 90b1ae0:	e037883a 	mov	sp,fp
 90b1ae4:	dfc00117 	ldw	ra,4(sp)
 90b1ae8:	df000017 	ldw	fp,0(sp)
 90b1aec:	dec00204 	addi	sp,sp,8
 90b1af0:	f800283a 	ret

090b1af4 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 90b1af4:	defffb04 	addi	sp,sp,-20
 90b1af8:	dfc00415 	stw	ra,16(sp)
 90b1afc:	df000315 	stw	fp,12(sp)
 90b1b00:	df000304 	addi	fp,sp,12
 90b1b04:	e13ffe15 	stw	r4,-8(fp)
 90b1b08:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 90b1b0c:	e03ffd15 	stw	zero,-12(fp)
 90b1b10:	00002a06 	br	90b1bbc <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 90b1b14:	e0bffd17 	ldw	r2,-12(fp)
 90b1b18:	e0ffff17 	ldw	r3,-4(fp)
 90b1b1c:	1085883a 	add	r2,r2,r2
 90b1b20:	1085883a 	add	r2,r2,r2
 90b1b24:	10c5883a 	add	r2,r2,r3
 90b1b28:	10800104 	addi	r2,r2,4
 90b1b2c:	10c00017 	ldw	r3,0(r2)
 90b1b30:	e0bffe17 	ldw	r2,-8(fp)
 90b1b34:	18801e1e 	bne	r3,r2,90b1bb0 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 90b1b38:	00001206 	br	90b1b84 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 90b1b3c:	e13ffd17 	ldw	r4,-12(fp)
 90b1b40:	e0bffd17 	ldw	r2,-12(fp)
 90b1b44:	10800044 	addi	r2,r2,1
 90b1b48:	e0ffff17 	ldw	r3,-4(fp)
 90b1b4c:	1085883a 	add	r2,r2,r2
 90b1b50:	1085883a 	add	r2,r2,r2
 90b1b54:	10c5883a 	add	r2,r2,r3
 90b1b58:	10800104 	addi	r2,r2,4
 90b1b5c:	11400017 	ldw	r5,0(r2)
 90b1b60:	e0ffff17 	ldw	r3,-4(fp)
 90b1b64:	2105883a 	add	r2,r4,r4
 90b1b68:	1085883a 	add	r2,r2,r2
 90b1b6c:	10c5883a 	add	r2,r2,r3
 90b1b70:	10800104 	addi	r2,r2,4
 90b1b74:	11400015 	stw	r5,0(r2)
            i++;
 90b1b78:	e0bffd17 	ldw	r2,-12(fp)
 90b1b7c:	10800044 	addi	r2,r2,1
 90b1b80:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 90b1b84:	e0bffd17 	ldw	r2,-12(fp)
 90b1b88:	10c00044 	addi	r3,r2,1
 90b1b8c:	e0bfff17 	ldw	r2,-4(fp)
 90b1b90:	10800017 	ldw	r2,0(r2)
 90b1b94:	18bfe936 	bltu	r3,r2,90b1b3c <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 90b1b98:	e0bfff17 	ldw	r2,-4(fp)
 90b1b9c:	10800017 	ldw	r2,0(r2)
 90b1ba0:	10ffffc4 	addi	r3,r2,-1
 90b1ba4:	e0bfff17 	ldw	r2,-4(fp)
 90b1ba8:	10c00015 	stw	r3,0(r2)
         return;
 90b1bac:	00000806 	br	90b1bd0 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 90b1bb0:	e0bffd17 	ldw	r2,-12(fp)
 90b1bb4:	10800044 	addi	r2,r2,1
 90b1bb8:	e0bffd15 	stw	r2,-12(fp)
 90b1bbc:	e0bfff17 	ldw	r2,-4(fp)
 90b1bc0:	10c00017 	ldw	r3,0(r2)
 90b1bc4:	e0bffd17 	ldw	r2,-12(fp)
 90b1bc8:	10ffd236 	bltu	r2,r3,90b1b14 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 90b1bcc:	90a94880 	call	90a9488 <dtrap>
#endif
}
 90b1bd0:	e037883a 	mov	sp,fp
 90b1bd4:	dfc00117 	ldw	ra,4(sp)
 90b1bd8:	df000017 	ldw	fp,0(sp)
 90b1bdc:	dec00204 	addi	sp,sp,8
 90b1be0:	f800283a 	ret

090b1be4 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 90b1be4:	defffc04 	addi	sp,sp,-16
 90b1be8:	dfc00315 	stw	ra,12(sp)
 90b1bec:	df000215 	stw	fp,8(sp)
 90b1bf0:	df000204 	addi	fp,sp,8
 90b1bf4:	e13ffe15 	stw	r4,-8(fp)
 90b1bf8:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 90b1bfc:	e0bfff17 	ldw	r2,-4(fp)
 90b1c00:	10800017 	ldw	r2,0(r2)
 90b1c04:	10801028 	cmpgeui	r2,r2,64
 90b1c08:	10000d1e 	bne	r2,zero,90b1c40 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 90b1c0c:	e0bfff17 	ldw	r2,-4(fp)
 90b1c10:	10c00017 	ldw	r3,0(r2)
 90b1c14:	e13fff17 	ldw	r4,-4(fp)
 90b1c18:	18c5883a 	add	r2,r3,r3
 90b1c1c:	1085883a 	add	r2,r2,r2
 90b1c20:	1105883a 	add	r2,r2,r4
 90b1c24:	11000104 	addi	r4,r2,4
 90b1c28:	e0bffe17 	ldw	r2,-8(fp)
 90b1c2c:	20800015 	stw	r2,0(r4)
 90b1c30:	18c00044 	addi	r3,r3,1
 90b1c34:	e0bfff17 	ldw	r2,-4(fp)
 90b1c38:	10c00015 	stw	r3,0(r2)
 90b1c3c:	00000106 	br	90b1c44 <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 90b1c40:	90a94880 	call	90a9488 <dtrap>
#endif
}
 90b1c44:	e037883a 	mov	sp,fp
 90b1c48:	dfc00117 	ldw	ra,4(sp)
 90b1c4c:	df000017 	ldw	fp,0(sp)
 90b1c50:	dec00204 	addi	sp,sp,8
 90b1c54:	f800283a 	ret

090b1c58 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 90b1c58:	defffb04 	addi	sp,sp,-20
 90b1c5c:	df000415 	stw	fp,16(sp)
 90b1c60:	df000404 	addi	fp,sp,16
 90b1c64:	e13ffd15 	stw	r4,-12(fp)
 90b1c68:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 90b1c6c:	e03ffc15 	stw	zero,-16(fp)
 90b1c70:	00000f06 	br	90b1cb0 <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 90b1c74:	e0bffc17 	ldw	r2,-16(fp)
 90b1c78:	e0fffe17 	ldw	r3,-8(fp)
 90b1c7c:	1085883a 	add	r2,r2,r2
 90b1c80:	1085883a 	add	r2,r2,r2
 90b1c84:	10c5883a 	add	r2,r2,r3
 90b1c88:	10800104 	addi	r2,r2,4
 90b1c8c:	10c00017 	ldw	r3,0(r2)
 90b1c90:	e0bffd17 	ldw	r2,-12(fp)
 90b1c94:	1880031e 	bne	r3,r2,90b1ca4 <ifd_isset+0x4c>
         return TRUE;
 90b1c98:	00800044 	movi	r2,1
 90b1c9c:	e0bfff15 	stw	r2,-4(fp)
 90b1ca0:	00000806 	br	90b1cc4 <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 90b1ca4:	e0bffc17 	ldw	r2,-16(fp)
 90b1ca8:	10800044 	addi	r2,r2,1
 90b1cac:	e0bffc15 	stw	r2,-16(fp)
 90b1cb0:	e0bffe17 	ldw	r2,-8(fp)
 90b1cb4:	10c00017 	ldw	r3,0(r2)
 90b1cb8:	e0bffc17 	ldw	r2,-16(fp)
 90b1cbc:	10ffed36 	bltu	r2,r3,90b1c74 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 90b1cc0:	e03fff15 	stw	zero,-4(fp)
 90b1cc4:	e0bfff17 	ldw	r2,-4(fp)
}
 90b1cc8:	e037883a 	mov	sp,fp
 90b1ccc:	df000017 	ldw	fp,0(sp)
 90b1cd0:	dec00104 	addi	sp,sp,4
 90b1cd4:	f800283a 	ret

090b1cd8 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 90b1cd8:	defffb04 	addi	sp,sp,-20
 90b1cdc:	dfc00415 	stw	ra,16(sp)
 90b1ce0:	df000315 	stw	fp,12(sp)
 90b1ce4:	df000304 	addi	fp,sp,12
 90b1ce8:	e13ffd15 	stw	r4,-12(fp)
 90b1cec:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 90b1cf0:	e0bffe17 	ldw	r2,-8(fp)
 90b1cf4:	10c00017 	ldw	r3,0(r2)
 90b1cf8:	e0bffd17 	ldw	r2,-12(fp)
 90b1cfc:	10c0092e 	bgeu	r2,r3,90b1d24 <ifd_get+0x4c>
      return set->fd_array[i];
 90b1d00:	e0bffd17 	ldw	r2,-12(fp)
 90b1d04:	e0fffe17 	ldw	r3,-8(fp)
 90b1d08:	1085883a 	add	r2,r2,r2
 90b1d0c:	1085883a 	add	r2,r2,r2
 90b1d10:	10c5883a 	add	r2,r2,r3
 90b1d14:	10800104 	addi	r2,r2,4
 90b1d18:	10800017 	ldw	r2,0(r2)
 90b1d1c:	e0bfff15 	stw	r2,-4(fp)
 90b1d20:	00000306 	br	90b1d30 <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 90b1d24:	90a94880 	call	90a9488 <dtrap>
#endif
      return INVALID_SOCKET;
 90b1d28:	00bfffc4 	movi	r2,-1
 90b1d2c:	e0bfff15 	stw	r2,-4(fp)
 90b1d30:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90b1d34:	e037883a 	mov	sp,fp
 90b1d38:	dfc00117 	ldw	ra,4(sp)
 90b1d3c:	df000017 	ldw	fp,0(sp)
 90b1d40:	dec00204 	addi	sp,sp,8
 90b1d44:	f800283a 	ret

090b1d48 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 90b1d48:	defff404 	addi	sp,sp,-48
 90b1d4c:	dfc00b15 	stw	ra,44(sp)
 90b1d50:	df000a15 	stw	fp,40(sp)
 90b1d54:	df000a04 	addi	fp,sp,40
 90b1d58:	e13ffc15 	stw	r4,-16(fp)
 90b1d5c:	e17ffd15 	stw	r5,-12(fp)
 90b1d60:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b1d64:	e0bffc17 	ldw	r2,-16(fp)
 90b1d68:	10800d17 	ldw	r2,52(r2)
 90b1d6c:	10800817 	ldw	r2,32(r2)
 90b1d70:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 90b1d74:	e0bffd17 	ldw	r2,-12(fp)
 90b1d78:	1005003a 	cmpeq	r2,r2,zero
 90b1d7c:	10009c1e 	bne	r2,zero,90b1ff0 <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 90b1d80:	e0bffc17 	ldw	r2,-16(fp)
 90b1d84:	10800017 	ldw	r2,0(r2)
 90b1d88:	e0bffb15 	stw	r2,-20(fp)
 90b1d8c:	00000a06 	br	90b1db8 <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 90b1d90:	e0bffb17 	ldw	r2,-20(fp)
 90b1d94:	10c00617 	ldw	r3,24(r2)
 90b1d98:	e0bffd17 	ldw	r2,-12(fp)
 90b1d9c:	10800617 	ldw	r2,24(r2)
 90b1da0:	1885c83a 	sub	r2,r3,r2
 90b1da4:	10800048 	cmpgei	r2,r2,1
 90b1da8:	1000061e 	bne	r2,zero,90b1dc4 <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 90b1dac:	e0bffb17 	ldw	r2,-20(fp)
 90b1db0:	10800017 	ldw	r2,0(r2)
 90b1db4:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 90b1db8:	e0fffc17 	ldw	r3,-16(fp)
 90b1dbc:	e0bffb17 	ldw	r2,-20(fp)
 90b1dc0:	10fff31e 	bne	r2,r3,90b1d90 <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 90b1dc4:	e0bffb17 	ldw	r2,-20(fp)
 90b1dc8:	10800117 	ldw	r2,4(r2)
 90b1dcc:	1007883a 	mov	r3,r2
 90b1dd0:	e0bffc17 	ldw	r2,-16(fp)
 90b1dd4:	18803c26 	beq	r3,r2,90b1ec8 <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 90b1dd8:	e0bffb17 	ldw	r2,-20(fp)
 90b1ddc:	10800117 	ldw	r2,4(r2)
 90b1de0:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 90b1de4:	e0bffb17 	ldw	r2,-20(fp)
 90b1de8:	10c00617 	ldw	r3,24(r2)
 90b1dec:	e0bffb17 	ldw	r2,-20(fp)
 90b1df0:	1080028b 	ldhu	r2,10(r2)
 90b1df4:	10bfffcc 	andi	r2,r2,65535
 90b1df8:	1887883a 	add	r3,r3,r2
 90b1dfc:	e0bffd17 	ldw	r2,-12(fp)
 90b1e00:	10800617 	ldw	r2,24(r2)
 90b1e04:	1885c83a 	sub	r2,r3,r2
 90b1e08:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 90b1e0c:	e0bff717 	ldw	r2,-36(fp)
 90b1e10:	10800050 	cmplti	r2,r2,1
 90b1e14:	1000291e 	bne	r2,zero,90b1ebc <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 90b1e18:	e0bffd17 	ldw	r2,-12(fp)
 90b1e1c:	1080028b 	ldhu	r2,10(r2)
 90b1e20:	10ffffcc 	andi	r3,r2,65535
 90b1e24:	e0bff717 	ldw	r2,-36(fp)
 90b1e28:	10c01416 	blt	r2,r3,90b1e7c <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 90b1e2c:	008243b4 	movhi	r2,2318
 90b1e30:	10b58e04 	addi	r2,r2,-10696
 90b1e34:	10801f17 	ldw	r2,124(r2)
 90b1e38:	10c00044 	addi	r3,r2,1
 90b1e3c:	008243b4 	movhi	r2,2318
 90b1e40:	10b58e04 	addi	r2,r2,-10696
 90b1e44:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 90b1e48:	008243b4 	movhi	r2,2318
 90b1e4c:	10b58e04 	addi	r2,r2,-10696
 90b1e50:	10c02017 	ldw	r3,128(r2)
 90b1e54:	e0bffd17 	ldw	r2,-12(fp)
 90b1e58:	1080028b 	ldhu	r2,10(r2)
 90b1e5c:	10bfffcc 	andi	r2,r2,65535
 90b1e60:	1887883a 	add	r3,r3,r2
 90b1e64:	008243b4 	movhi	r2,2318
 90b1e68:	10b58e04 	addi	r2,r2,-10696
 90b1e6c:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 90b1e70:	008025c4 	movi	r2,151
 90b1e74:	d0a0b215 	stw	r2,-32056(gp)
 90b1e78:	0000ac06 	br	90b212c <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 90b1e7c:	e13ffe17 	ldw	r4,-8(fp)
 90b1e80:	e17ff717 	ldw	r5,-36(fp)
 90b1e84:	90aa90c0 	call	90aa90c <m_adj>
         ti->ti_len -= (short)i;
 90b1e88:	e0bffd17 	ldw	r2,-12(fp)
 90b1e8c:	10c0028b 	ldhu	r3,10(r2)
 90b1e90:	e0bff717 	ldw	r2,-36(fp)
 90b1e94:	1885c83a 	sub	r2,r3,r2
 90b1e98:	1007883a 	mov	r3,r2
 90b1e9c:	e0bffd17 	ldw	r2,-12(fp)
 90b1ea0:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 90b1ea4:	e0bffd17 	ldw	r2,-12(fp)
 90b1ea8:	10c00617 	ldw	r3,24(r2)
 90b1eac:	e0bff717 	ldw	r2,-36(fp)
 90b1eb0:	1887883a 	add	r3,r3,r2
 90b1eb4:	e0bffd17 	ldw	r2,-12(fp)
 90b1eb8:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 90b1ebc:	e0bffb17 	ldw	r2,-20(fp)
 90b1ec0:	10800017 	ldw	r2,0(r2)
 90b1ec4:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 90b1ec8:	008243b4 	movhi	r2,2318
 90b1ecc:	10b58e04 	addi	r2,r2,-10696
 90b1ed0:	10802317 	ldw	r2,140(r2)
 90b1ed4:	10c00044 	addi	r3,r2,1
 90b1ed8:	008243b4 	movhi	r2,2318
 90b1edc:	10b58e04 	addi	r2,r2,-10696
 90b1ee0:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 90b1ee4:	008243b4 	movhi	r2,2318
 90b1ee8:	10b58e04 	addi	r2,r2,-10696
 90b1eec:	10c02417 	ldw	r3,144(r2)
 90b1ef0:	e0bffd17 	ldw	r2,-12(fp)
 90b1ef4:	1080028b 	ldhu	r2,10(r2)
 90b1ef8:	10bfffcc 	andi	r2,r2,65535
 90b1efc:	1887883a 	add	r3,r3,r2
 90b1f00:	008243b4 	movhi	r2,2318
 90b1f04:	10b58e04 	addi	r2,r2,-10696
 90b1f08:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 90b1f0c:	00003106 	br	90b1fd4 <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 90b1f10:	e0bffd17 	ldw	r2,-12(fp)
 90b1f14:	10c00617 	ldw	r3,24(r2)
 90b1f18:	e0bffd17 	ldw	r2,-12(fp)
 90b1f1c:	1080028b 	ldhu	r2,10(r2)
 90b1f20:	10bfffcc 	andi	r2,r2,65535
 90b1f24:	1887883a 	add	r3,r3,r2
 90b1f28:	e0bffb17 	ldw	r2,-20(fp)
 90b1f2c:	10800617 	ldw	r2,24(r2)
 90b1f30:	1885c83a 	sub	r2,r3,r2
 90b1f34:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 90b1f38:	e0bff617 	ldw	r2,-40(fp)
 90b1f3c:	10800050 	cmplti	r2,r2,1
 90b1f40:	1000271e 	bne	r2,zero,90b1fe0 <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 90b1f44:	e0bffb17 	ldw	r2,-20(fp)
 90b1f48:	1080028b 	ldhu	r2,10(r2)
 90b1f4c:	10ffffcc 	andi	r3,r2,65535
 90b1f50:	e0bff617 	ldw	r2,-40(fp)
 90b1f54:	10c0130e 	bge	r2,r3,90b1fa4 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 90b1f58:	e0bffb17 	ldw	r2,-20(fp)
 90b1f5c:	10c00617 	ldw	r3,24(r2)
 90b1f60:	e0bff617 	ldw	r2,-40(fp)
 90b1f64:	1887883a 	add	r3,r3,r2
 90b1f68:	e0bffb17 	ldw	r2,-20(fp)
 90b1f6c:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 90b1f70:	e0bffb17 	ldw	r2,-20(fp)
 90b1f74:	10c0028b 	ldhu	r3,10(r2)
 90b1f78:	e0bff617 	ldw	r2,-40(fp)
 90b1f7c:	1885c83a 	sub	r2,r3,r2
 90b1f80:	1007883a 	mov	r3,r2
 90b1f84:	e0bffb17 	ldw	r2,-20(fp)
 90b1f88:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 90b1f8c:	e13ffb17 	ldw	r4,-20(fp)
 90b1f90:	90aab340 	call	90aab34 <dtom>
 90b1f94:	1009883a 	mov	r4,r2
 90b1f98:	e17ff617 	ldw	r5,-40(fp)
 90b1f9c:	90aa90c0 	call	90aa90c <m_adj>
         break;
 90b1fa0:	00000f06 	br	90b1fe0 <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 90b1fa4:	e0bffb17 	ldw	r2,-20(fp)
 90b1fa8:	10800017 	ldw	r2,0(r2)
 90b1fac:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 90b1fb0:	e0bffb17 	ldw	r2,-20(fp)
 90b1fb4:	11000117 	ldw	r4,4(r2)
 90b1fb8:	90aab340 	call	90aab34 <dtom>
 90b1fbc:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 90b1fc0:	e0bffb17 	ldw	r2,-20(fp)
 90b1fc4:	11000117 	ldw	r4,4(r2)
 90b1fc8:	90aabdc0 	call	90aabdc <remque>
      m_freem (m);
 90b1fcc:	e13ff917 	ldw	r4,-28(fp)
 90b1fd0:	90aa5a40 	call	90aa5a4 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 90b1fd4:	e0fffc17 	ldw	r3,-16(fp)
 90b1fd8:	e0bffb17 	ldw	r2,-20(fp)
 90b1fdc:	10ffcc1e 	bne	r2,r3,90b1f10 <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 90b1fe0:	e0bffb17 	ldw	r2,-20(fp)
 90b1fe4:	11400117 	ldw	r5,4(r2)
 90b1fe8:	e13ffd17 	ldw	r4,-12(fp)
 90b1fec:	90aac4c0 	call	90aac4c <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 90b1ff0:	e0bffc17 	ldw	r2,-16(fp)
 90b1ff4:	10800217 	ldw	r2,8(r2)
 90b1ff8:	108000c8 	cmpgei	r2,r2,3
 90b1ffc:	1000021e 	bne	r2,zero,90b2008 <tcp_reass+0x2c0>
      return (0);
 90b2000:	e03fff15 	stw	zero,-4(fp)
 90b2004:	00004c06 	br	90b2138 <tcp_reass+0x3f0>
   ti = tp->seg_next;
 90b2008:	e0bffc17 	ldw	r2,-16(fp)
 90b200c:	10800017 	ldw	r2,0(r2)
 90b2010:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 90b2014:	e0fffc17 	ldw	r3,-16(fp)
 90b2018:	e0bffd17 	ldw	r2,-12(fp)
 90b201c:	10c00526 	beq	r2,r3,90b2034 <tcp_reass+0x2ec>
 90b2020:	e0bffd17 	ldw	r2,-12(fp)
 90b2024:	10c00617 	ldw	r3,24(r2)
 90b2028:	e0bffc17 	ldw	r2,-16(fp)
 90b202c:	10801617 	ldw	r2,88(r2)
 90b2030:	18800226 	beq	r3,r2,90b203c <tcp_reass+0x2f4>
      return (0);
 90b2034:	e03fff15 	stw	zero,-4(fp)
 90b2038:	00003f06 	br	90b2138 <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 90b203c:	e0bffc17 	ldw	r2,-16(fp)
 90b2040:	10800217 	ldw	r2,8(r2)
 90b2044:	108000d8 	cmpnei	r2,r2,3
 90b2048:	1000071e 	bne	r2,zero,90b2068 <tcp_reass+0x320>
 90b204c:	e0bffd17 	ldw	r2,-12(fp)
 90b2050:	1080028b 	ldhu	r2,10(r2)
 90b2054:	10bfffcc 	andi	r2,r2,65535
 90b2058:	1005003a 	cmpeq	r2,r2,zero
 90b205c:	1000021e 	bne	r2,zero,90b2068 <tcp_reass+0x320>
      return (0);
 90b2060:	e03fff15 	stw	zero,-4(fp)
 90b2064:	00003406 	br	90b2138 <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 90b2068:	e0bffc17 	ldw	r2,-16(fp)
 90b206c:	10c01617 	ldw	r3,88(r2)
 90b2070:	e0bffd17 	ldw	r2,-12(fp)
 90b2074:	1080028b 	ldhu	r2,10(r2)
 90b2078:	10bfffcc 	andi	r2,r2,65535
 90b207c:	1887883a 	add	r3,r3,r2
 90b2080:	e0bffc17 	ldw	r2,-16(fp)
 90b2084:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 90b2088:	e0bffd17 	ldw	r2,-12(fp)
 90b208c:	10800843 	ldbu	r2,33(r2)
 90b2090:	10803fcc 	andi	r2,r2,255
 90b2094:	1080004c 	andi	r2,r2,1
 90b2098:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 90b209c:	e13ffd17 	ldw	r4,-12(fp)
 90b20a0:	90aabdc0 	call	90aabdc <remque>
      m = dtom(ti);
 90b20a4:	e13ffd17 	ldw	r4,-12(fp)
 90b20a8:	90aab340 	call	90aab34 <dtom>
 90b20ac:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 90b20b0:	e0bffd17 	ldw	r2,-12(fp)
 90b20b4:	10800017 	ldw	r2,0(r2)
 90b20b8:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 90b20bc:	e0bffa17 	ldw	r2,-24(fp)
 90b20c0:	1080088b 	ldhu	r2,34(r2)
 90b20c4:	10bfffcc 	andi	r2,r2,65535
 90b20c8:	1080080c 	andi	r2,r2,32
 90b20cc:	1005003a 	cmpeq	r2,r2,zero
 90b20d0:	1000031e 	bne	r2,zero,90b20e0 <tcp_reass+0x398>
         m_freem (m);
 90b20d4:	e13ff917 	ldw	r4,-28(fp)
 90b20d8:	90aa5a40 	call	90aa5a4 <m_freem>
 90b20dc:	00000406 	br	90b20f0 <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 90b20e0:	e0bffa17 	ldw	r2,-24(fp)
 90b20e4:	11000a04 	addi	r4,r2,40
 90b20e8:	e17ff917 	ldw	r5,-28(fp)
 90b20ec:	90b0ab80 	call	90b0ab8 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 90b20f0:	e0fffc17 	ldw	r3,-16(fp)
 90b20f4:	e0bffd17 	ldw	r2,-12(fp)
 90b20f8:	10c00526 	beq	r2,r3,90b2110 <tcp_reass+0x3c8>
 90b20fc:	e0bffd17 	ldw	r2,-12(fp)
 90b2100:	10c00617 	ldw	r3,24(r2)
 90b2104:	e0bffc17 	ldw	r2,-16(fp)
 90b2108:	10801617 	ldw	r2,88(r2)
 90b210c:	18bfd626 	beq	r3,r2,90b2068 <tcp_reass+0x320>
      sorwakeup(so);
 90b2110:	e0bffa17 	ldw	r2,-24(fp)
 90b2114:	11400a04 	addi	r5,r2,40
 90b2118:	e13ffa17 	ldw	r4,-24(fp)
 90b211c:	90b08f40 	call	90b08f4 <sbwakeup>
   return (flags);
 90b2120:	e0bff817 	ldw	r2,-32(fp)
 90b2124:	e0bfff15 	stw	r2,-4(fp)
 90b2128:	00000306 	br	90b2138 <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 90b212c:	e13ffe17 	ldw	r4,-8(fp)
 90b2130:	90aa5a40 	call	90aa5a4 <m_freem>
   return (0);
 90b2134:	e03fff15 	stw	zero,-4(fp)
 90b2138:	e0bfff17 	ldw	r2,-4(fp)
}
 90b213c:	e037883a 	mov	sp,fp
 90b2140:	dfc00117 	ldw	ra,4(sp)
 90b2144:	df000017 	ldw	fp,0(sp)
 90b2148:	dec00204 	addi	sp,sp,8
 90b214c:	f800283a 	ret

090b2150 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 90b2150:	deffd004 	addi	sp,sp,-192
 90b2154:	dfc02f15 	stw	ra,188(sp)
 90b2158:	df002e15 	stw	fp,184(sp)
 90b215c:	df002e04 	addi	fp,sp,184
 90b2160:	e13ff015 	stw	r4,-64(fp)
 90b2164:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 90b2168:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 90b216c:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 90b2170:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 90b2174:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 90b2178:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 90b217c:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 90b2180:	008243b4 	movhi	r2,2318
 90b2184:	10b58e04 	addi	r2,r2,-10696
 90b2188:	10801917 	ldw	r2,100(r2)
 90b218c:	10c00044 	addi	r3,r2,1
 90b2190:	008243b4 	movhi	r2,2318
 90b2194:	10b58e04 	addi	r2,r2,-10696
 90b2198:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 90b219c:	008243b4 	movhi	r2,2318
 90b21a0:	10b56004 	addi	r2,r2,-10880
 90b21a4:	10800917 	ldw	r2,36(r2)
 90b21a8:	10c00044 	addi	r3,r2,1
 90b21ac:	008243b4 	movhi	r2,2318
 90b21b0:	10b56004 	addi	r2,r2,-10880
 90b21b4:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 90b21b8:	e0bff017 	ldw	r2,-64(fp)
 90b21bc:	10800317 	ldw	r2,12(r2)
 90b21c0:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 90b21c4:	e0bfee17 	ldw	r2,-72(fp)
 90b21c8:	10800003 	ldbu	r2,0(r2)
 90b21cc:	10803fcc 	andi	r2,r2,255
 90b21d0:	108011b0 	cmpltui	r2,r2,70
 90b21d4:	1000061e 	bne	r2,zero,90b21f0 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 90b21d8:	e13fee17 	ldw	r4,-72(fp)
 90b21dc:	e17ff017 	ldw	r5,-64(fp)
 90b21e0:	90ab6100 	call	90ab610 <np_stripoptions>
         pip = mtod(m, struct ip *);
 90b21e4:	e0bff017 	ldw	r2,-64(fp)
 90b21e8:	10800317 	ldw	r2,12(r2)
 90b21ec:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 90b21f0:	e0bff017 	ldw	r2,-64(fp)
 90b21f4:	10800217 	ldw	r2,8(r2)
 90b21f8:	10800a28 	cmpgeui	r2,r2,40
 90b21fc:	1000081e 	bne	r2,zero,90b2220 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 90b2200:	008243b4 	movhi	r2,2318
 90b2204:	10b58e04 	addi	r2,r2,-10696
 90b2208:	10801e17 	ldw	r2,120(r2)
 90b220c:	10c00044 	addi	r3,r2,1
 90b2210:	008243b4 	movhi	r2,2318
 90b2214:	10b58e04 	addi	r2,r2,-10696
 90b2218:	10c01e15 	stw	r3,120(r2)
         return;
 90b221c:	00091c06 	br	90b4690 <tcp_input+0x2540>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 90b2220:	e0bfee17 	ldw	r2,-72(fp)
 90b2224:	1080008b 	ldhu	r2,2(r2)
 90b2228:	10bfffcc 	andi	r2,r2,65535
 90b222c:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 90b2230:	e0bff017 	ldw	r2,-64(fp)
 90b2234:	10800317 	ldw	r2,12(r2)
 90b2238:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 90b223c:	e0bff017 	ldw	r2,-64(fp)
 90b2240:	10800117 	ldw	r2,4(r2)
 90b2244:	10c00117 	ldw	r3,4(r2)
 90b2248:	e0bfed17 	ldw	r2,-76(fp)
 90b224c:	10c0032e 	bgeu	r2,r3,90b225c <tcp_input+0x10c>
      {
         panic("tcp_input");
 90b2250:	01024374 	movhi	r4,2317
 90b2254:	213f8304 	addi	r4,r4,-500
 90b2258:	90a438c0 	call	90a438c <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 90b225c:	e0bfed17 	ldw	r2,-76(fp)
 90b2260:	10800803 	ldbu	r2,32(r2)
 90b2264:	10803fcc 	andi	r2,r2,255
 90b2268:	1004d13a 	srli	r2,r2,4
 90b226c:	10803fcc 	andi	r2,r2,255
 90b2270:	1085883a 	add	r2,r2,r2
 90b2274:	1085883a 	add	r2,r2,r2
 90b2278:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 90b227c:	e0bfe817 	ldw	r2,-96(fp)
 90b2280:	10800530 	cmpltui	r2,r2,20
 90b2284:	1000031e 	bne	r2,zero,90b2294 <tcp_input+0x144>
 90b2288:	e0ffe817 	ldw	r3,-96(fp)
 90b228c:	e0bfe917 	ldw	r2,-92(fp)
 90b2290:	10c0110e 	bge	r2,r3,90b22d8 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 90b2294:	008243b4 	movhi	r2,2318
 90b2298:	10b58e04 	addi	r2,r2,-10696
 90b229c:	10801d17 	ldw	r2,116(r2)
 90b22a0:	10c00044 	addi	r3,r2,1
 90b22a4:	008243b4 	movhi	r2,2318
 90b22a8:	10b58e04 	addi	r2,r2,-10696
 90b22ac:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 90b22b0:	008243b4 	movhi	r2,2318
 90b22b4:	10b56004 	addi	r2,r2,-10880
 90b22b8:	10800d17 	ldw	r2,52(r2)
 90b22bc:	10c00044 	addi	r3,r2,1
 90b22c0:	008243b4 	movhi	r2,2318
 90b22c4:	10b56004 	addi	r2,r2,-10880
 90b22c8:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 90b22cc:	00805784 	movi	r2,350
 90b22d0:	d0a0b215 	stw	r2,-32056(gp)
 90b22d4:	0008e206 	br	90b4660 <tcp_input+0x2510>
   }
   tlen -= (int)off;
 90b22d8:	e0ffe917 	ldw	r3,-92(fp)
 90b22dc:	e0bfe817 	ldw	r2,-96(fp)
 90b22e0:	1885c83a 	sub	r2,r3,r2
 90b22e4:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 90b22e8:	e0bfe917 	ldw	r2,-92(fp)
 90b22ec:	1007883a 	mov	r3,r2
 90b22f0:	e0bfed17 	ldw	r2,-76(fp)
 90b22f4:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 90b22f8:	e0bfe817 	ldw	r2,-96(fp)
 90b22fc:	10800570 	cmpltui	r2,r2,21
 90b2300:	1000341e 	bne	r2,zero,90b23d4 <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 90b2304:	e0bfe817 	ldw	r2,-96(fp)
 90b2308:	10bffb04 	addi	r2,r2,-20
 90b230c:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 90b2310:	01000044 	movi	r4,1
 90b2314:	e17fdd17 	ldw	r5,-140(fp)
 90b2318:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b231c:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 90b2320:	e0bfeb17 	ldw	r2,-84(fp)
 90b2324:	1004c03a 	cmpne	r2,r2,zero
 90b2328:	1000031e 	bne	r2,zero,90b2338 <tcp_input+0x1e8>
         GOTO_DROP;
 90b232c:	00805a84 	movi	r2,362
 90b2330:	d0a0b215 	stw	r2,-32056(gp)
 90b2334:	0008ca06 	br	90b4660 <tcp_input+0x2510>
      om->m_len = olen;       /* set mbuf length */
 90b2338:	e0ffdd17 	ldw	r3,-140(fp)
 90b233c:	e0bfeb17 	ldw	r2,-84(fp)
 90b2340:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 90b2344:	e0bff017 	ldw	r2,-64(fp)
 90b2348:	10800117 	ldw	r2,4(r2)
 90b234c:	1080080b 	ldhu	r2,32(r2)
 90b2350:	10ffffcc 	andi	r3,r2,65535
 90b2354:	00b76194 	movui	r2,56710
 90b2358:	1880051e 	bne	r3,r2,90b2370 <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 90b235c:	e0bff017 	ldw	r2,-64(fp)
 90b2360:	10800317 	ldw	r2,12(r2)
 90b2364:	10800504 	addi	r2,r2,20
 90b2368:	e0bfdc15 	stw	r2,-144(fp)
 90b236c:	00000406 	br	90b2380 <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 90b2370:	e0bff017 	ldw	r2,-64(fp)
 90b2374:	10800317 	ldw	r2,12(r2)
 90b2378:	10800a04 	addi	r2,r2,40
 90b237c:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 90b2380:	e0bfeb17 	ldw	r2,-84(fp)
 90b2384:	10c00317 	ldw	r3,12(r2)
 90b2388:	e1bfdd17 	ldw	r6,-140(fp)
 90b238c:	e0bfdc17 	ldw	r2,-144(fp)
 90b2390:	1809883a 	mov	r4,r3
 90b2394:	100b883a 	mov	r5,r2
 90b2398:	90822780 	call	9082278 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 90b239c:	e0bff017 	ldw	r2,-64(fp)
 90b23a0:	10c00317 	ldw	r3,12(r2)
 90b23a4:	e0bfeb17 	ldw	r2,-84(fp)
 90b23a8:	10800217 	ldw	r2,8(r2)
 90b23ac:	1887883a 	add	r3,r3,r2
 90b23b0:	e0bff017 	ldw	r2,-64(fp)
 90b23b4:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 90b23b8:	e0bff017 	ldw	r2,-64(fp)
 90b23bc:	10c00217 	ldw	r3,8(r2)
 90b23c0:	e0bfeb17 	ldw	r2,-84(fp)
 90b23c4:	10800217 	ldw	r2,8(r2)
 90b23c8:	1887c83a 	sub	r3,r3,r2
 90b23cc:	e0bff017 	ldw	r2,-64(fp)
 90b23d0:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 90b23d4:	e0bfed17 	ldw	r2,-76(fp)
 90b23d8:	10800843 	ldbu	r2,33(r2)
 90b23dc:	10803fcc 	andi	r2,r2,255
 90b23e0:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 90b23e4:	e0bfed17 	ldw	r2,-76(fp)
 90b23e8:	10800617 	ldw	r2,24(r2)
 90b23ec:	1004d63a 	srli	r2,r2,24
 90b23f0:	10c03fcc 	andi	r3,r2,255
 90b23f4:	e0bfed17 	ldw	r2,-76(fp)
 90b23f8:	10800617 	ldw	r2,24(r2)
 90b23fc:	1004d23a 	srli	r2,r2,8
 90b2400:	10bfc00c 	andi	r2,r2,65280
 90b2404:	1886b03a 	or	r3,r3,r2
 90b2408:	e0bfed17 	ldw	r2,-76(fp)
 90b240c:	10800617 	ldw	r2,24(r2)
 90b2410:	10bfc00c 	andi	r2,r2,65280
 90b2414:	1004923a 	slli	r2,r2,8
 90b2418:	1886b03a 	or	r3,r3,r2
 90b241c:	e0bfed17 	ldw	r2,-76(fp)
 90b2420:	10800617 	ldw	r2,24(r2)
 90b2424:	10803fcc 	andi	r2,r2,255
 90b2428:	1004963a 	slli	r2,r2,24
 90b242c:	1886b03a 	or	r3,r3,r2
 90b2430:	e0bfed17 	ldw	r2,-76(fp)
 90b2434:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 90b2438:	e0bfed17 	ldw	r2,-76(fp)
 90b243c:	10800717 	ldw	r2,28(r2)
 90b2440:	1004d63a 	srli	r2,r2,24
 90b2444:	10c03fcc 	andi	r3,r2,255
 90b2448:	e0bfed17 	ldw	r2,-76(fp)
 90b244c:	10800717 	ldw	r2,28(r2)
 90b2450:	1004d23a 	srli	r2,r2,8
 90b2454:	10bfc00c 	andi	r2,r2,65280
 90b2458:	1886b03a 	or	r3,r3,r2
 90b245c:	e0bfed17 	ldw	r2,-76(fp)
 90b2460:	10800717 	ldw	r2,28(r2)
 90b2464:	10bfc00c 	andi	r2,r2,65280
 90b2468:	1004923a 	slli	r2,r2,8
 90b246c:	1886b03a 	or	r3,r3,r2
 90b2470:	e0bfed17 	ldw	r2,-76(fp)
 90b2474:	10800717 	ldw	r2,28(r2)
 90b2478:	10803fcc 	andi	r2,r2,255
 90b247c:	1004963a 	slli	r2,r2,24
 90b2480:	1886b03a 	or	r3,r3,r2
 90b2484:	e0bfed17 	ldw	r2,-76(fp)
 90b2488:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 90b248c:	e0bfed17 	ldw	r2,-76(fp)
 90b2490:	1080098b 	ldhu	r2,38(r2)
 90b2494:	10bfffcc 	andi	r2,r2,65535
 90b2498:	1004d23a 	srli	r2,r2,8
 90b249c:	10803fcc 	andi	r2,r2,255
 90b24a0:	1009883a 	mov	r4,r2
 90b24a4:	e0bfed17 	ldw	r2,-76(fp)
 90b24a8:	1080098b 	ldhu	r2,38(r2)
 90b24ac:	10bfffcc 	andi	r2,r2,65535
 90b24b0:	1004923a 	slli	r2,r2,8
 90b24b4:	1007883a 	mov	r3,r2
 90b24b8:	00bfc004 	movi	r2,-256
 90b24bc:	1884703a 	and	r2,r3,r2
 90b24c0:	2084b03a 	or	r2,r4,r2
 90b24c4:	1007883a 	mov	r3,r2
 90b24c8:	e0bfed17 	ldw	r2,-76(fp)
 90b24cc:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 90b24d0:	e0bff017 	ldw	r2,-64(fp)
 90b24d4:	10800117 	ldw	r2,4(r2)
 90b24d8:	1080080b 	ldhu	r2,32(r2)
 90b24dc:	10bfffcc 	andi	r2,r2,65535
 90b24e0:	10800220 	cmpeqi	r2,r2,8
 90b24e4:	1000011e 	bne	r2,zero,90b24ec <tcp_input+0x39c>
 90b24e8:	00001f06 	br	90b2568 <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 90b24ec:	e0bff017 	ldw	r2,-64(fp)
 90b24f0:	10800317 	ldw	r2,12(r2)
 90b24f4:	10c00a04 	addi	r3,r2,40
 90b24f8:	e0bff017 	ldw	r2,-64(fp)
 90b24fc:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 90b2500:	e0bff017 	ldw	r2,-64(fp)
 90b2504:	10800217 	ldw	r2,8(r2)
 90b2508:	10fff604 	addi	r3,r2,-40
 90b250c:	e0bff017 	ldw	r2,-64(fp)
 90b2510:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 90b2514:	e0bfed17 	ldw	r2,-76(fp)
 90b2518:	11400317 	ldw	r5,12(r2)
 90b251c:	e0bfed17 	ldw	r2,-76(fp)
 90b2520:	1080050b 	ldhu	r2,20(r2)
 90b2524:	11bfffcc 	andi	r6,r2,65535
 90b2528:	e0bfed17 	ldw	r2,-76(fp)
 90b252c:	11c00417 	ldw	r7,16(r2)
 90b2530:	e0bfed17 	ldw	r2,-76(fp)
 90b2534:	1080058b 	ldhu	r2,22(r2)
 90b2538:	10bfffcc 	andi	r2,r2,65535
 90b253c:	d8800015 	stw	r2,0(sp)
 90b2540:	00800044 	movi	r2,1
 90b2544:	d8800115 	stw	r2,4(sp)
 90b2548:	010243b4 	movhi	r4,2318
 90b254c:	21358304 	addi	r4,r4,-10740
 90b2550:	90c6fa40 	call	90c6fa4 <in_pcblookup>
 90b2554:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 90b2558:	e0bfec17 	ldw	r2,-80(fp)
 90b255c:	1005003a 	cmpeq	r2,r2,zero
 90b2560:	1000031e 	bne	r2,zero,90b2570 <tcp_input+0x420>
 90b2564:	00000506 	br	90b257c <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 90b2568:	90a94880 	call	90a9488 <dtrap>
      return;
 90b256c:	00084806 	br	90b4690 <tcp_input+0x2540>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 90b2570:	00806b04 	movi	r2,428
 90b2574:	d0a0b215 	stw	r2,-32056(gp)
 90b2578:	0007f506 	br	90b4550 <tcp_input+0x2400>
   tp = intotcpcb (inp);
 90b257c:	e0bfec17 	ldw	r2,-80(fp)
 90b2580:	10800917 	ldw	r2,36(r2)
 90b2584:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 90b2588:	e0bfe717 	ldw	r2,-100(fp)
 90b258c:	1004c03a 	cmpne	r2,r2,zero
 90b2590:	1000031e 	bne	r2,zero,90b25a0 <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 90b2594:	00806bc4 	movi	r2,431
 90b2598:	d0a0b215 	stw	r2,-32056(gp)
 90b259c:	0007ec06 	br	90b4550 <tcp_input+0x2400>
   if (tp->t_state == TCPS_CLOSED)
 90b25a0:	e0bfe717 	ldw	r2,-100(fp)
 90b25a4:	10800217 	ldw	r2,8(r2)
 90b25a8:	1004c03a 	cmpne	r2,r2,zero
 90b25ac:	1000031e 	bne	r2,zero,90b25bc <tcp_input+0x46c>
      GOTO_DROP;
 90b25b0:	00806c44 	movi	r2,433
 90b25b4:	d0a0b215 	stw	r2,-32056(gp)
 90b25b8:	00082906 	br	90b4660 <tcp_input+0x2510>
   so = inp->inp_socket;
 90b25bc:	e0bfec17 	ldw	r2,-80(fp)
 90b25c0:	10800817 	ldw	r2,32(r2)
 90b25c4:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 90b25c8:	e0bfed17 	ldw	r2,-76(fp)
 90b25cc:	1080088b 	ldhu	r2,34(r2)
 90b25d0:	10bfffcc 	andi	r2,r2,65535
 90b25d4:	1004d23a 	srli	r2,r2,8
 90b25d8:	10bfffcc 	andi	r2,r2,65535
 90b25dc:	10c03fcc 	andi	r3,r2,255
 90b25e0:	e0bfed17 	ldw	r2,-76(fp)
 90b25e4:	1080088b 	ldhu	r2,34(r2)
 90b25e8:	10bfffcc 	andi	r2,r2,65535
 90b25ec:	1004923a 	slli	r2,r2,8
 90b25f0:	10bfc00c 	andi	r2,r2,65280
 90b25f4:	1884b03a 	or	r2,r3,r2
 90b25f8:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 90b25fc:	e0bfe517 	ldw	r2,-108(fp)
 90b2600:	10800417 	ldw	r2,16(r2)
 90b2604:	1080008c 	andi	r2,r2,2
 90b2608:	1005003a 	cmpeq	r2,r2,zero
 90b260c:	10002d1e 	bne	r2,zero,90b26c4 <tcp_input+0x574>
   {
      so = sonewconn(so);
 90b2610:	e13fe517 	ldw	r4,-108(fp)
 90b2614:	90b03cc0 	call	90b03cc <sonewconn>
 90b2618:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 90b261c:	e0bfe517 	ldw	r2,-108(fp)
 90b2620:	1004c03a 	cmpne	r2,r2,zero
 90b2624:	1000031e 	bne	r2,zero,90b2634 <tcp_input+0x4e4>
         GOTO_DROP;
 90b2628:	00807344 	movi	r2,461
 90b262c:	d0a0b215 	stw	r2,-32056(gp)
 90b2630:	00080b06 	br	90b4660 <tcp_input+0x2510>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 90b2634:	e0bfe017 	ldw	r2,-128(fp)
 90b2638:	10800044 	addi	r2,r2,1
 90b263c:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 90b2640:	e0bfe517 	ldw	r2,-108(fp)
 90b2644:	10800117 	ldw	r2,4(r2)
 90b2648:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 90b264c:	e0ffec17 	ldw	r3,-80(fp)
 90b2650:	e0bff117 	ldw	r2,-60(fp)
 90b2654:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 90b2658:	e0bfe517 	ldw	r2,-108(fp)
 90b265c:	10800517 	ldw	r2,20(r2)
 90b2660:	108000a0 	cmpeqi	r2,r2,2
 90b2664:	1000011e 	bne	r2,zero,90b266c <tcp_input+0x51c>
 90b2668:	00000c06 	br	90b269c <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 90b266c:	e0bfed17 	ldw	r2,-76(fp)
 90b2670:	10c00417 	ldw	r3,16(r2)
 90b2674:	e0bfec17 	ldw	r2,-80(fp)
 90b2678:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 90b267c:	e0bff117 	ldw	r2,-60(fp)
 90b2680:	10c00917 	ldw	r3,36(r2)
 90b2684:	e0bff117 	ldw	r2,-60(fp)
 90b2688:	10800817 	ldw	r2,32(r2)
 90b268c:	1885c83a 	sub	r2,r3,r2
 90b2690:	10fff604 	addi	r3,r2,-40
 90b2694:	e0bfec17 	ldw	r2,-80(fp)
 90b2698:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 90b269c:	e0bfed17 	ldw	r2,-76(fp)
 90b26a0:	10c0058b 	ldhu	r3,22(r2)
 90b26a4:	e0bfec17 	ldw	r2,-80(fp)
 90b26a8:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 90b26ac:	e0bfec17 	ldw	r2,-80(fp)
 90b26b0:	10800917 	ldw	r2,36(r2)
 90b26b4:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 90b26b8:	e0ffe717 	ldw	r3,-100(fp)
 90b26bc:	00800044 	movi	r2,1
 90b26c0:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 90b26c4:	e0bfe717 	ldw	r2,-100(fp)
 90b26c8:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 90b26cc:	00824374 	movhi	r2,2317
 90b26d0:	108bd604 	addi	r2,r2,12120
 90b26d4:	10c00017 	ldw	r3,0(r2)
 90b26d8:	e0bfe717 	ldw	r2,-100(fp)
 90b26dc:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 90b26e0:	e0bfeb17 	ldw	r2,-84(fp)
 90b26e4:	1005003a 	cmpeq	r2,r2,zero
 90b26e8:	1000091e 	bne	r2,zero,90b2710 <tcp_input+0x5c0>
 90b26ec:	e0bfe717 	ldw	r2,-100(fp)
 90b26f0:	10800217 	ldw	r2,8(r2)
 90b26f4:	10800060 	cmpeqi	r2,r2,1
 90b26f8:	1000051e 	bne	r2,zero,90b2710 <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 90b26fc:	e13fe717 	ldw	r4,-100(fp)
 90b2700:	e17feb17 	ldw	r5,-84(fp)
 90b2704:	e1bfed17 	ldw	r6,-76(fp)
 90b2708:	90b46a40 	call	90b46a4 <tcp_dooptions>
      om = 0;
 90b270c:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 90b2710:	e0bfed17 	ldw	r2,-76(fp)
 90b2714:	10c00717 	ldw	r3,28(r2)
 90b2718:	e0bfe717 	ldw	r2,-100(fp)
 90b271c:	10800e17 	ldw	r2,56(r2)
 90b2720:	1885c83a 	sub	r2,r3,r2
 90b2724:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 90b2728:	e0bfe517 	ldw	r2,-108(fp)
 90b272c:	10800b17 	ldw	r2,44(r2)
 90b2730:	1007883a 	mov	r3,r2
 90b2734:	e0bfe517 	ldw	r2,-108(fp)
 90b2738:	10800a17 	ldw	r2,40(r2)
 90b273c:	1885c83a 	sub	r2,r3,r2
 90b2740:	1004803a 	cmplt	r2,r2,zero
 90b2744:	1000071e 	bne	r2,zero,90b2764 <tcp_input+0x614>
 90b2748:	e0bfe517 	ldw	r2,-108(fp)
 90b274c:	10c00b17 	ldw	r3,44(r2)
 90b2750:	e0bfe517 	ldw	r2,-108(fp)
 90b2754:	10800a17 	ldw	r2,40(r2)
 90b2758:	1885c83a 	sub	r2,r3,r2
 90b275c:	e0bffd15 	stw	r2,-12(fp)
 90b2760:	00000106 	br	90b2768 <tcp_input+0x618>
 90b2764:	e03ffd15 	stw	zero,-12(fp)
 90b2768:	e0bffd17 	ldw	r2,-12(fp)
 90b276c:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 90b2770:	e0bfdb17 	ldw	r2,-148(fp)
 90b2774:	1004403a 	cmpge	r2,r2,zero
 90b2778:	1000011e 	bne	r2,zero,90b2780 <tcp_input+0x630>
         win = 0;
 90b277c:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 90b2780:	e0bfe717 	ldw	r2,-100(fp)
 90b2784:	10c01917 	ldw	r3,100(r2)
 90b2788:	e0bfe717 	ldw	r2,-100(fp)
 90b278c:	10801617 	ldw	r2,88(r2)
 90b2790:	1885c83a 	sub	r2,r3,r2
 90b2794:	e0ffdb17 	ldw	r3,-148(fp)
 90b2798:	e0fffc15 	stw	r3,-16(fp)
 90b279c:	e0bffb15 	stw	r2,-20(fp)
 90b27a0:	e13ffb17 	ldw	r4,-20(fp)
 90b27a4:	e0bffc17 	ldw	r2,-16(fp)
 90b27a8:	2080022e 	bgeu	r4,r2,90b27b4 <tcp_input+0x664>
 90b27ac:	e0fffc17 	ldw	r3,-16(fp)
 90b27b0:	e0fffb15 	stw	r3,-20(fp)
 90b27b4:	e0bfe717 	ldw	r2,-100(fp)
 90b27b8:	e13ffb17 	ldw	r4,-20(fp)
 90b27bc:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 90b27c0:	e0bfe717 	ldw	r2,-100(fp)
 90b27c4:	10800217 	ldw	r2,8(r2)
 90b27c8:	10800118 	cmpnei	r2,r2,4
 90b27cc:	10010f1e 	bne	r2,zero,90b2c0c <tcp_input+0xabc>
 90b27d0:	e0bfe617 	ldw	r2,-104(fp)
 90b27d4:	10800dcc 	andi	r2,r2,55
 90b27d8:	10800418 	cmpnei	r2,r2,16
 90b27dc:	10010b1e 	bne	r2,zero,90b2c0c <tcp_input+0xabc>
 90b27e0:	e0bfed17 	ldw	r2,-76(fp)
 90b27e4:	10c00617 	ldw	r3,24(r2)
 90b27e8:	e0bfe717 	ldw	r2,-100(fp)
 90b27ec:	10801617 	ldw	r2,88(r2)
 90b27f0:	1881061e 	bne	r3,r2,90b2c0c <tcp_input+0xabc>
 90b27f4:	e0bfde17 	ldw	r2,-136(fp)
 90b27f8:	1005003a 	cmpeq	r2,r2,zero
 90b27fc:	1001031e 	bne	r2,zero,90b2c0c <tcp_input+0xabc>
 90b2800:	e0bfe717 	ldw	r2,-100(fp)
 90b2804:	10c01417 	ldw	r3,80(r2)
 90b2808:	e0bfde17 	ldw	r2,-136(fp)
 90b280c:	1880ff1e 	bne	r3,r2,90b2c0c <tcp_input+0xabc>
 90b2810:	e0bfe717 	ldw	r2,-100(fp)
 90b2814:	10c00f17 	ldw	r3,60(r2)
 90b2818:	e0bfe717 	ldw	r2,-100(fp)
 90b281c:	10801a17 	ldw	r2,104(r2)
 90b2820:	1880fa1e 	bne	r3,r2,90b2c0c <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 90b2824:	e0bfed17 	ldw	r2,-76(fp)
 90b2828:	1080028b 	ldhu	r2,10(r2)
 90b282c:	10bfffcc 	andi	r2,r2,65535
 90b2830:	1004c03a 	cmpne	r2,r2,zero
 90b2834:	1000651e 	bne	r2,zero,90b29cc <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 90b2838:	e0bfed17 	ldw	r2,-76(fp)
 90b283c:	10c00717 	ldw	r3,28(r2)
 90b2840:	e0bfe717 	ldw	r2,-100(fp)
 90b2844:	10800e17 	ldw	r2,56(r2)
 90b2848:	1885c83a 	sub	r2,r3,r2
 90b284c:	10800050 	cmplti	r2,r2,1
 90b2850:	1000ee1e 	bne	r2,zero,90b2c0c <tcp_input+0xabc>
 90b2854:	e0bfed17 	ldw	r2,-76(fp)
 90b2858:	10c00717 	ldw	r3,28(r2)
 90b285c:	e0bfe717 	ldw	r2,-100(fp)
 90b2860:	10801a17 	ldw	r2,104(r2)
 90b2864:	1885c83a 	sub	r2,r3,r2
 90b2868:	10800048 	cmpgei	r2,r2,1
 90b286c:	1000e71e 	bne	r2,zero,90b2c0c <tcp_input+0xabc>
 90b2870:	e0bfe717 	ldw	r2,-100(fp)
 90b2874:	10c01b17 	ldw	r3,108(r2)
 90b2878:	e0bfe717 	ldw	r2,-100(fp)
 90b287c:	10801417 	ldw	r2,80(r2)
 90b2880:	1880e236 	bltu	r3,r2,90b2c0c <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 90b2884:	008243b4 	movhi	r2,2318
 90b2888:	10b58e04 	addi	r2,r2,-10696
 90b288c:	10803517 	ldw	r2,212(r2)
 90b2890:	10c00044 	addi	r3,r2,1
 90b2894:	008243b4 	movhi	r2,2318
 90b2898:	10b58e04 	addi	r2,r2,-10696
 90b289c:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 90b28a0:	e0bfe717 	ldw	r2,-100(fp)
 90b28a4:	10801e17 	ldw	r2,120(r2)
 90b28a8:	1005003a 	cmpeq	r2,r2,zero
 90b28ac:	1000091e 	bne	r2,zero,90b28d4 <tcp_input+0x784>
 90b28b0:	e0bfed17 	ldw	r2,-76(fp)
 90b28b4:	10c00717 	ldw	r3,28(r2)
 90b28b8:	e0bfe717 	ldw	r2,-100(fp)
 90b28bc:	10801f17 	ldw	r2,124(r2)
 90b28c0:	1885c83a 	sub	r2,r3,r2
 90b28c4:	10800050 	cmplti	r2,r2,1
 90b28c8:	1000021e 	bne	r2,zero,90b28d4 <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 90b28cc:	e13fe717 	ldw	r4,-100(fp)
 90b28d0:	90b49600 	call	90b4960 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 90b28d4:	008243b4 	movhi	r2,2318
 90b28d8:	10b58e04 	addi	r2,r2,-10696
 90b28dc:	10802b17 	ldw	r2,172(r2)
 90b28e0:	10c00044 	addi	r3,r2,1
 90b28e4:	008243b4 	movhi	r2,2318
 90b28e8:	10b58e04 	addi	r2,r2,-10696
 90b28ec:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 90b28f0:	008243b4 	movhi	r2,2318
 90b28f4:	10b58e04 	addi	r2,r2,-10696
 90b28f8:	10c02c17 	ldw	r3,176(r2)
 90b28fc:	e0bfe317 	ldw	r2,-116(fp)
 90b2900:	1887883a 	add	r3,r3,r2
 90b2904:	008243b4 	movhi	r2,2318
 90b2908:	10b58e04 	addi	r2,r2,-10696
 90b290c:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 90b2910:	e0bfe517 	ldw	r2,-108(fp)
 90b2914:	11001204 	addi	r4,r2,72
 90b2918:	e17fe317 	ldw	r5,-116(fp)
 90b291c:	90b10c00 	call	90b10c0 <sbdrop>
            tp->snd_una = ti->ti_ack;
 90b2920:	e0bfed17 	ldw	r2,-76(fp)
 90b2924:	10c00717 	ldw	r3,28(r2)
 90b2928:	e0bfe717 	ldw	r2,-100(fp)
 90b292c:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 90b2930:	e13ff017 	ldw	r4,-64(fp)
 90b2934:	90aa5a40 	call	90aa5a4 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 90b2938:	e0bfe717 	ldw	r2,-100(fp)
 90b293c:	10c00e17 	ldw	r3,56(r2)
 90b2940:	e0bfe717 	ldw	r2,-100(fp)
 90b2944:	10801a17 	ldw	r2,104(r2)
 90b2948:	1880031e 	bne	r3,r2,90b2958 <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 90b294c:	e0bfe717 	ldw	r2,-100(fp)
 90b2950:	10000315 	stw	zero,12(r2)
 90b2954:	00000806 	br	90b2978 <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 90b2958:	e0bfe717 	ldw	r2,-100(fp)
 90b295c:	10800417 	ldw	r2,16(r2)
 90b2960:	1004c03a 	cmpne	r2,r2,zero
 90b2964:	1000041e 	bne	r2,zero,90b2978 <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b2968:	e0bfe717 	ldw	r2,-100(fp)
 90b296c:	10c00817 	ldw	r3,32(r2)
 90b2970:	e0bfe717 	ldw	r2,-100(fp)
 90b2974:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 90b2978:	e0bfe517 	ldw	r2,-108(fp)
 90b297c:	1080190b 	ldhu	r2,100(r2)
 90b2980:	10bfffcc 	andi	r2,r2,65535
 90b2984:	1080030c 	andi	r2,r2,12
 90b2988:	1005003a 	cmpeq	r2,r2,zero
 90b298c:	1000041e 	bne	r2,zero,90b29a0 <tcp_input+0x850>
               sowwakeup(so);
 90b2990:	e0bfe517 	ldw	r2,-108(fp)
 90b2994:	11401204 	addi	r5,r2,72
 90b2998:	e13fe517 	ldw	r4,-108(fp)
 90b299c:	90b08f40 	call	90b08f4 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 90b29a0:	e0bfe517 	ldw	r2,-108(fp)
 90b29a4:	11001217 	ldw	r4,72(r2)
 90b29a8:	e0bfe717 	ldw	r2,-100(fp)
 90b29ac:	10c00f17 	ldw	r3,60(r2)
 90b29b0:	e0bfe717 	ldw	r2,-100(fp)
 90b29b4:	10800e17 	ldw	r2,56(r2)
 90b29b8:	1885c83a 	sub	r2,r3,r2
 90b29bc:	1107342e 	bgeu	r2,r4,90b4690 <tcp_input+0x2540>
               (void) tcp_output(tp);
 90b29c0:	e13fe717 	ldw	r4,-100(fp)
 90b29c4:	90b4d640 	call	90b4d64 <tcp_output>
            return;
 90b29c8:	00073106 	br	90b4690 <tcp_input+0x2540>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 90b29cc:	e0bfed17 	ldw	r2,-76(fp)
 90b29d0:	10c00717 	ldw	r3,28(r2)
 90b29d4:	e0bfe717 	ldw	r2,-100(fp)
 90b29d8:	10800e17 	ldw	r2,56(r2)
 90b29dc:	18808b1e 	bne	r3,r2,90b2c0c <tcp_input+0xabc>
 90b29e0:	e0bfe717 	ldw	r2,-100(fp)
 90b29e4:	10c00017 	ldw	r3,0(r2)
 90b29e8:	e0bfe717 	ldw	r2,-100(fp)
 90b29ec:	1880871e 	bne	r3,r2,90b2c0c <tcp_input+0xabc>
 90b29f0:	e0bfed17 	ldw	r2,-76(fp)
 90b29f4:	1080028b 	ldhu	r2,10(r2)
 90b29f8:	10bfffcc 	andi	r2,r2,65535
 90b29fc:	e0bffa15 	stw	r2,-24(fp)
 90b2a00:	e0bfe517 	ldw	r2,-108(fp)
 90b2a04:	10800b17 	ldw	r2,44(r2)
 90b2a08:	1007883a 	mov	r3,r2
 90b2a0c:	e0bfe517 	ldw	r2,-108(fp)
 90b2a10:	10800a17 	ldw	r2,40(r2)
 90b2a14:	1885c83a 	sub	r2,r3,r2
 90b2a18:	1004803a 	cmplt	r2,r2,zero
 90b2a1c:	1000071e 	bne	r2,zero,90b2a3c <tcp_input+0x8ec>
 90b2a20:	e0bfe517 	ldw	r2,-108(fp)
 90b2a24:	10c00b17 	ldw	r3,44(r2)
 90b2a28:	e0bfe517 	ldw	r2,-108(fp)
 90b2a2c:	10800a17 	ldw	r2,40(r2)
 90b2a30:	1887c83a 	sub	r3,r3,r2
 90b2a34:	e0fff915 	stw	r3,-28(fp)
 90b2a38:	00000106 	br	90b2a40 <tcp_input+0x8f0>
 90b2a3c:	e03ff915 	stw	zero,-28(fp)
 90b2a40:	e0bff917 	ldw	r2,-28(fp)
 90b2a44:	e0fffa17 	ldw	r3,-24(fp)
 90b2a48:	10c07036 	bltu	r2,r3,90b2c0c <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 90b2a4c:	e0bfe717 	ldw	r2,-100(fp)
 90b2a50:	10801517 	ldw	r2,84(r2)
 90b2a54:	1004c03a 	cmpne	r2,r2,zero
 90b2a58:	10000c1e 	bne	r2,zero,90b2a8c <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 90b2a5c:	008243b4 	movhi	r2,2318
 90b2a60:	10b58e04 	addi	r2,r2,-10696
 90b2a64:	10802817 	ldw	r2,160(r2)
 90b2a68:	10c00044 	addi	r3,r2,1
 90b2a6c:	008243b4 	movhi	r2,2318
 90b2a70:	10b58e04 	addi	r2,r2,-10696
 90b2a74:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 90b2a78:	e13ff017 	ldw	r4,-64(fp)
 90b2a7c:	90aa5a40 	call	90aa5a4 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 90b2a80:	e13fe717 	ldw	r4,-100(fp)
 90b2a84:	90b4d640 	call	90b4d64 <tcp_output>
            return;
 90b2a88:	00070106 	br	90b4690 <tcp_input+0x2540>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 90b2a8c:	008243b4 	movhi	r2,2318
 90b2a90:	10b58e04 	addi	r2,r2,-10696
 90b2a94:	10803617 	ldw	r2,216(r2)
 90b2a98:	10c00044 	addi	r3,r2,1
 90b2a9c:	008243b4 	movhi	r2,2318
 90b2aa0:	10b58e04 	addi	r2,r2,-10696
 90b2aa4:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 90b2aa8:	e0bfe717 	ldw	r2,-100(fp)
 90b2aac:	10c01617 	ldw	r3,88(r2)
 90b2ab0:	e0bfed17 	ldw	r2,-76(fp)
 90b2ab4:	1080028b 	ldhu	r2,10(r2)
 90b2ab8:	10bfffcc 	andi	r2,r2,65535
 90b2abc:	1887883a 	add	r3,r3,r2
 90b2ac0:	e0bfe717 	ldw	r2,-100(fp)
 90b2ac4:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 90b2ac8:	008243b4 	movhi	r2,2318
 90b2acc:	10b58e04 	addi	r2,r2,-10696
 90b2ad0:	10801a17 	ldw	r2,104(r2)
 90b2ad4:	10c00044 	addi	r3,r2,1
 90b2ad8:	008243b4 	movhi	r2,2318
 90b2adc:	10b58e04 	addi	r2,r2,-10696
 90b2ae0:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 90b2ae4:	008243b4 	movhi	r2,2318
 90b2ae8:	10b58e04 	addi	r2,r2,-10696
 90b2aec:	10c01b17 	ldw	r3,108(r2)
 90b2af0:	e0bfed17 	ldw	r2,-76(fp)
 90b2af4:	1080028b 	ldhu	r2,10(r2)
 90b2af8:	10bfffcc 	andi	r2,r2,65535
 90b2afc:	1887883a 	add	r3,r3,r2
 90b2b00:	008243b4 	movhi	r2,2318
 90b2b04:	10b58e04 	addi	r2,r2,-10696
 90b2b08:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 90b2b0c:	e0bfe517 	ldw	r2,-108(fp)
 90b2b10:	11000a04 	addi	r4,r2,40
 90b2b14:	e17ff017 	ldw	r5,-64(fp)
 90b2b18:	90b0ab80 	call	90b0ab8 <sbappend>
         sorwakeup(so);
 90b2b1c:	e0bfe517 	ldw	r2,-108(fp)
 90b2b20:	11400a04 	addi	r5,r2,40
 90b2b24:	e13fe517 	ldw	r4,-108(fp)
 90b2b28:	90b08f40 	call	90b08f4 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 90b2b2c:	e0bfe617 	ldw	r2,-104(fp)
 90b2b30:	1080020c 	andi	r2,r2,8
 90b2b34:	1005003a 	cmpeq	r2,r2,zero
 90b2b38:	1000071e 	bne	r2,zero,90b2b58 <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 90b2b3c:	e0bfe717 	ldw	r2,-100(fp)
 90b2b40:	10800b0b 	ldhu	r2,44(r2)
 90b2b44:	10800054 	ori	r2,r2,1
 90b2b48:	1007883a 	mov	r3,r2
 90b2b4c:	e0bfe717 	ldw	r2,-100(fp)
 90b2b50:	10c00b0d 	sth	r3,44(r2)
 90b2b54:	00000606 	br	90b2b70 <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 90b2b58:	e0bfe717 	ldw	r2,-100(fp)
 90b2b5c:	10800b0b 	ldhu	r2,44(r2)
 90b2b60:	10800094 	ori	r2,r2,2
 90b2b64:	1007883a 	mov	r3,r2
 90b2b68:	e0bfe717 	ldw	r2,-100(fp)
 90b2b6c:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 90b2b70:	e0bfe717 	ldw	r2,-100(fp)
 90b2b74:	11001517 	ldw	r4,84(r2)
 90b2b78:	e0bfe717 	ldw	r2,-100(fp)
 90b2b7c:	10c01917 	ldw	r3,100(r2)
 90b2b80:	e0bfe717 	ldw	r2,-100(fp)
 90b2b84:	10801617 	ldw	r2,88(r2)
 90b2b88:	1885c83a 	sub	r2,r3,r2
 90b2b8c:	2085c83a 	sub	r2,r4,r2
 90b2b90:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 90b2b94:	e0bfe717 	ldw	r2,-100(fp)
 90b2b98:	10800a0b 	ldhu	r2,40(r2)
 90b2b9c:	10bfffcc 	andi	r2,r2,65535
 90b2ba0:	1085883a 	add	r2,r2,r2
 90b2ba4:	1007883a 	mov	r3,r2
 90b2ba8:	e0bfda17 	ldw	r2,-152(fp)
 90b2bac:	10c0070e 	bge	r2,r3,90b2bcc <tcp_input+0xa7c>
 90b2bb0:	e0bfe717 	ldw	r2,-100(fp)
 90b2bb4:	10800b0b 	ldhu	r2,44(r2)
 90b2bb8:	10bfffcc 	andi	r2,r2,65535
 90b2bbc:	1080004c 	andi	r2,r2,1
 90b2bc0:	10803fcc 	andi	r2,r2,255
 90b2bc4:	1005003a 	cmpeq	r2,r2,zero
 90b2bc8:	1006b11e 	bne	r2,zero,90b4690 <tcp_input+0x2540>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 90b2bcc:	e0bfe717 	ldw	r2,-100(fp)
 90b2bd0:	10800b0b 	ldhu	r2,44(r2)
 90b2bd4:	10800054 	ori	r2,r2,1
 90b2bd8:	1007883a 	mov	r3,r2
 90b2bdc:	e0bfe717 	ldw	r2,-100(fp)
 90b2be0:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 90b2be4:	e0bfe717 	ldw	r2,-100(fp)
 90b2be8:	10c00b0b 	ldhu	r3,44(r2)
 90b2bec:	00bfff44 	movi	r2,-3
 90b2bf0:	1884703a 	and	r2,r3,r2
 90b2bf4:	1007883a 	mov	r3,r2
 90b2bf8:	e0bfe717 	ldw	r2,-100(fp)
 90b2bfc:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 90b2c00:	e13fe717 	ldw	r4,-100(fp)
 90b2c04:	90b4d640 	call	90b4d64 <tcp_output>
         }

         return;
 90b2c08:	0006a106 	br	90b4690 <tcp_input+0x2540>
      }
   }

   switch (tp->t_state) 
 90b2c0c:	e0bfe717 	ldw	r2,-100(fp)
 90b2c10:	10800217 	ldw	r2,8(r2)
 90b2c14:	e0bff815 	stw	r2,-32(fp)
 90b2c18:	e13ff817 	ldw	r4,-32(fp)
 90b2c1c:	20800060 	cmpeqi	r2,r4,1
 90b2c20:	1000041e 	bne	r2,zero,90b2c34 <tcp_input+0xae4>
 90b2c24:	e0fff817 	ldw	r3,-32(fp)
 90b2c28:	188000a0 	cmpeqi	r2,r3,2
 90b2c2c:	1000b91e 	bne	r2,zero,90b2f14 <tcp_input+0xdc4>
 90b2c30:	00019806 	br	90b3294 <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 90b2c34:	e0bfe617 	ldw	r2,-104(fp)
 90b2c38:	1080010c 	andi	r2,r2,4
 90b2c3c:	1005003a 	cmpeq	r2,r2,zero
 90b2c40:	1000031e 	bne	r2,zero,90b2c50 <tcp_input+0xb00>
            GOTO_DROP;
 90b2c44:	0080bec4 	movi	r2,763
 90b2c48:	d0a0b215 	stw	r2,-32056(gp)
 90b2c4c:	00068406 	br	90b4660 <tcp_input+0x2510>
         if (tiflags & TH_ACK)
 90b2c50:	e0bfe617 	ldw	r2,-104(fp)
 90b2c54:	1080040c 	andi	r2,r2,16
 90b2c58:	1005003a 	cmpeq	r2,r2,zero
 90b2c5c:	1000031e 	bne	r2,zero,90b2c6c <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 90b2c60:	0080bf44 	movi	r2,765
 90b2c64:	d0a0b215 	stw	r2,-32056(gp)
 90b2c68:	00063906 	br	90b4550 <tcp_input+0x2400>
         if ((tiflags & TH_SYN) == 0)
 90b2c6c:	e0bfe617 	ldw	r2,-104(fp)
 90b2c70:	1080008c 	andi	r2,r2,2
 90b2c74:	1004c03a 	cmpne	r2,r2,zero
 90b2c78:	1000031e 	bne	r2,zero,90b2c88 <tcp_input+0xb38>
            GOTO_DROP;
 90b2c7c:	0080bfc4 	movi	r2,767
 90b2c80:	d0a0b215 	stw	r2,-32056(gp)
 90b2c84:	00067606 	br	90b4660 <tcp_input+0x2510>
         if(in_broadcast(ti->ti_dst.s_addr))
 90b2c88:	e0bfed17 	ldw	r2,-76(fp)
 90b2c8c:	11000417 	ldw	r4,16(r2)
 90b2c90:	90ab5d00 	call	90ab5d0 <in_broadcast>
 90b2c94:	1005003a 	cmpeq	r2,r2,zero
 90b2c98:	1000031e 	bne	r2,zero,90b2ca8 <tcp_input+0xb58>
            GOTO_DROP;
 90b2c9c:	0080c044 	movi	r2,769
 90b2ca0:	d0a0b215 	stw	r2,-32056(gp)
 90b2ca4:	00066e06 	br	90b4660 <tcp_input+0x2510>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90b2ca8:	01000244 	movi	r4,9
 90b2cac:	01400404 	movi	r5,16
 90b2cb0:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b2cb4:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 90b2cb8:	e0bfd917 	ldw	r2,-156(fp)
 90b2cbc:	1004c03a 	cmpne	r2,r2,zero
 90b2cc0:	1000031e 	bne	r2,zero,90b2cd0 <tcp_input+0xb80>
            GOTO_DROP;
 90b2cc4:	0080c104 	movi	r2,772
 90b2cc8:	d0a0b215 	stw	r2,-32056(gp)
 90b2ccc:	00066406 	br	90b4660 <tcp_input+0x2510>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 90b2cd0:	e0bfec17 	ldw	r2,-80(fp)
 90b2cd4:	10800817 	ldw	r2,32(r2)
 90b2cd8:	10800517 	ldw	r2,20(r2)
 90b2cdc:	10800098 	cmpnei	r2,r2,2
 90b2ce0:	10002e1e 	bne	r2,zero,90b2d9c <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 90b2ce4:	e0ffd917 	ldw	r3,-156(fp)
 90b2ce8:	00800404 	movi	r2,16
 90b2cec:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 90b2cf0:	e0bfd917 	ldw	r2,-156(fp)
 90b2cf4:	10800317 	ldw	r2,12(r2)
 90b2cf8:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 90b2cfc:	e0ffd817 	ldw	r3,-160(fp)
 90b2d00:	00800084 	movi	r2,2
 90b2d04:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 90b2d08:	e0bfed17 	ldw	r2,-76(fp)
 90b2d0c:	10c00317 	ldw	r3,12(r2)
 90b2d10:	e0bfd817 	ldw	r2,-160(fp)
 90b2d14:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 90b2d18:	e0bfed17 	ldw	r2,-76(fp)
 90b2d1c:	10c0050b 	ldhu	r3,20(r2)
 90b2d20:	e0bfd817 	ldw	r2,-160(fp)
 90b2d24:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 90b2d28:	e0bfec17 	ldw	r2,-80(fp)
 90b2d2c:	10800417 	ldw	r2,16(r2)
 90b2d30:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 90b2d34:	e0bfec17 	ldw	r2,-80(fp)
 90b2d38:	10800417 	ldw	r2,16(r2)
 90b2d3c:	1004c03a 	cmpne	r2,r2,zero
 90b2d40:	1000041e 	bne	r2,zero,90b2d54 <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 90b2d44:	e0bfed17 	ldw	r2,-76(fp)
 90b2d48:	10c00417 	ldw	r3,16(r2)
 90b2d4c:	e0bfec17 	ldw	r2,-80(fp)
 90b2d50:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 90b2d54:	e13fec17 	ldw	r4,-80(fp)
 90b2d58:	e17fd917 	ldw	r5,-156(fp)
 90b2d5c:	90c6c3c0 	call	90c6c3c <in_pcbconnect>
 90b2d60:	1005003a 	cmpeq	r2,r2,zero
 90b2d64:	1000081e 	bne	r2,zero,90b2d88 <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 90b2d68:	e0bfec17 	ldw	r2,-80(fp)
 90b2d6c:	e0ffef17 	ldw	r3,-68(fp)
 90b2d70:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 90b2d74:	e13fd917 	ldw	r4,-156(fp)
 90b2d78:	90aa4700 	call	90aa470 <m_free>
            GOTO_DROP;
 90b2d7c:	0080c684 	movi	r2,794
 90b2d80:	d0a0b215 	stw	r2,-32056(gp)
 90b2d84:	00063606 	br	90b4660 <tcp_input+0x2510>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 90b2d88:	e0ffec17 	ldw	r3,-80(fp)
 90b2d8c:	e0bff117 	ldw	r2,-60(fp)
 90b2d90:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 90b2d94:	e13fd917 	ldw	r4,-156(fp)
 90b2d98:	90aa4700 	call	90aa470 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 90b2d9c:	e13fe717 	ldw	r4,-100(fp)
 90b2da0:	90b611c0 	call	90b611c <tcp_template>
 90b2da4:	1007883a 	mov	r3,r2
 90b2da8:	e0bfe717 	ldw	r2,-100(fp)
 90b2dac:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 90b2db0:	e0bfe717 	ldw	r2,-100(fp)
 90b2db4:	10800c17 	ldw	r2,48(r2)
 90b2db8:	1004c03a 	cmpne	r2,r2,zero
 90b2dbc:	1000071e 	bne	r2,zero,90b2ddc <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 90b2dc0:	e13fe717 	ldw	r4,-100(fp)
 90b2dc4:	01401a44 	movi	r5,105
 90b2dc8:	90b67d40 	call	90b67d4 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 90b2dcc:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 90b2dd0:	0080d1c4 	movi	r2,839
 90b2dd4:	d0a0b215 	stw	r2,-32056(gp)
 90b2dd8:	00062106 	br	90b4660 <tcp_input+0x2510>
         }
         if (om) 
 90b2ddc:	e0bfeb17 	ldw	r2,-84(fp)
 90b2de0:	1005003a 	cmpeq	r2,r2,zero
 90b2de4:	1000051e 	bne	r2,zero,90b2dfc <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 90b2de8:	e13fe717 	ldw	r4,-100(fp)
 90b2dec:	e17feb17 	ldw	r5,-84(fp)
 90b2df0:	e1bfed17 	ldw	r6,-76(fp)
 90b2df4:	90b46a40 	call	90b46a4 <tcp_dooptions>
            om = 0;
 90b2df8:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 90b2dfc:	e0bfdf17 	ldw	r2,-132(fp)
 90b2e00:	1005003a 	cmpeq	r2,r2,zero
 90b2e04:	1000041e 	bne	r2,zero,90b2e18 <tcp_input+0xcc8>
            tp->iss = iss;
 90b2e08:	e0ffdf17 	ldw	r3,-132(fp)
 90b2e0c:	e0bfe717 	ldw	r2,-100(fp)
 90b2e10:	10c01315 	stw	r3,76(r2)
 90b2e14:	00000506 	br	90b2e2c <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 90b2e18:	00824374 	movhi	r2,2317
 90b2e1c:	108c4f04 	addi	r2,r2,12604
 90b2e20:	10c00017 	ldw	r3,0(r2)
 90b2e24:	e0bfe717 	ldw	r2,-100(fp)
 90b2e28:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 90b2e2c:	00824374 	movhi	r2,2317
 90b2e30:	108c4f04 	addi	r2,r2,12604
 90b2e34:	10c00017 	ldw	r3,0(r2)
 90b2e38:	00be9fd4 	movui	r2,64127
 90b2e3c:	1887883a 	add	r3,r3,r2
 90b2e40:	00824374 	movhi	r2,2317
 90b2e44:	108c4f04 	addi	r2,r2,12604
 90b2e48:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 90b2e4c:	e0bfed17 	ldw	r2,-76(fp)
 90b2e50:	10c00617 	ldw	r3,24(r2)
 90b2e54:	e0bfe717 	ldw	r2,-100(fp)
 90b2e58:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 90b2e5c:	e0bfe717 	ldw	r2,-100(fp)
 90b2e60:	10c01317 	ldw	r3,76(r2)
 90b2e64:	e0bfe717 	ldw	r2,-100(fp)
 90b2e68:	10c01015 	stw	r3,64(r2)
 90b2e6c:	e0bfe717 	ldw	r2,-100(fp)
 90b2e70:	10c01017 	ldw	r3,64(r2)
 90b2e74:	e0bfe717 	ldw	r2,-100(fp)
 90b2e78:	10c01a15 	stw	r3,104(r2)
 90b2e7c:	e0bfe717 	ldw	r2,-100(fp)
 90b2e80:	10c01a17 	ldw	r3,104(r2)
 90b2e84:	e0bfe717 	ldw	r2,-100(fp)
 90b2e88:	10c00f15 	stw	r3,60(r2)
 90b2e8c:	e0bfe717 	ldw	r2,-100(fp)
 90b2e90:	10c00f17 	ldw	r3,60(r2)
 90b2e94:	e0bfe717 	ldw	r2,-100(fp)
 90b2e98:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 90b2e9c:	e0bfe717 	ldw	r2,-100(fp)
 90b2ea0:	10801817 	ldw	r2,96(r2)
 90b2ea4:	10c00044 	addi	r3,r2,1
 90b2ea8:	e0bfe717 	ldw	r2,-100(fp)
 90b2eac:	10c01615 	stw	r3,88(r2)
 90b2eb0:	e0bfe717 	ldw	r2,-100(fp)
 90b2eb4:	10c01617 	ldw	r3,88(r2)
 90b2eb8:	e0bfe717 	ldw	r2,-100(fp)
 90b2ebc:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 90b2ec0:	e0bfe717 	ldw	r2,-100(fp)
 90b2ec4:	10800b0b 	ldhu	r2,44(r2)
 90b2ec8:	10800054 	ori	r2,r2,1
 90b2ecc:	1007883a 	mov	r3,r2
 90b2ed0:	e0bfe717 	ldw	r2,-100(fp)
 90b2ed4:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 90b2ed8:	e0ffe717 	ldw	r3,-100(fp)
 90b2edc:	008000c4 	movi	r2,3
 90b2ee0:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 90b2ee4:	e0ffe717 	ldw	r3,-100(fp)
 90b2ee8:	00802584 	movi	r2,150
 90b2eec:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 90b2ef0:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 90b2ef4:	008243b4 	movhi	r2,2318
 90b2ef8:	10b58e04 	addi	r2,r2,-10696
 90b2efc:	10800117 	ldw	r2,4(r2)
 90b2f00:	10c00044 	addi	r3,r2,1
 90b2f04:	008243b4 	movhi	r2,2318
 90b2f08:	10b58e04 	addi	r2,r2,-10696
 90b2f0c:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 90b2f10:	00009d06 	br	90b3188 <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 90b2f14:	e0ffec17 	ldw	r3,-80(fp)
 90b2f18:	e0bff117 	ldw	r2,-60(fp)
 90b2f1c:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 90b2f20:	e0bfe617 	ldw	r2,-104(fp)
 90b2f24:	1080040c 	andi	r2,r2,16
 90b2f28:	1005003a 	cmpeq	r2,r2,zero
 90b2f2c:	1000111e 	bne	r2,zero,90b2f74 <tcp_input+0xe24>
 90b2f30:	e0bfed17 	ldw	r2,-76(fp)
 90b2f34:	10c00717 	ldw	r3,28(r2)
 90b2f38:	e0bfe717 	ldw	r2,-100(fp)
 90b2f3c:	10801317 	ldw	r2,76(r2)
 90b2f40:	1885c83a 	sub	r2,r3,r2
 90b2f44:	10800050 	cmplti	r2,r2,1
 90b2f48:	1000071e 	bne	r2,zero,90b2f68 <tcp_input+0xe18>
 90b2f4c:	e0bfed17 	ldw	r2,-76(fp)
 90b2f50:	10c00717 	ldw	r3,28(r2)
 90b2f54:	e0bfe717 	ldw	r2,-100(fp)
 90b2f58:	10801a17 	ldw	r2,104(r2)
 90b2f5c:	1885c83a 	sub	r2,r3,r2
 90b2f60:	10800050 	cmplti	r2,r2,1
 90b2f64:	1000031e 	bne	r2,zero,90b2f74 <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 90b2f68:	0080dc04 	movi	r2,880
 90b2f6c:	d0a0b215 	stw	r2,-32056(gp)
 90b2f70:	00057706 	br	90b4550 <tcp_input+0x2400>
      }
      if (tiflags & TH_RST) 
 90b2f74:	e0bfe617 	ldw	r2,-104(fp)
 90b2f78:	1080010c 	andi	r2,r2,4
 90b2f7c:	1005003a 	cmpeq	r2,r2,zero
 90b2f80:	10000a1e 	bne	r2,zero,90b2fac <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 90b2f84:	e0bfe617 	ldw	r2,-104(fp)
 90b2f88:	1080040c 	andi	r2,r2,16
 90b2f8c:	1005003a 	cmpeq	r2,r2,zero
 90b2f90:	1000031e 	bne	r2,zero,90b2fa0 <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 90b2f94:	e13fe717 	ldw	r4,-100(fp)
 90b2f98:	01401bc4 	movi	r5,111
 90b2f9c:	90b67d40 	call	90b67d4 <tcp_drop>
         GOTO_DROP;
 90b2fa0:	0080dd84 	movi	r2,886
 90b2fa4:	d0a0b215 	stw	r2,-32056(gp)
 90b2fa8:	0005ad06 	br	90b4660 <tcp_input+0x2510>
      }
      if ((tiflags & TH_SYN) == 0)
 90b2fac:	e0bfe617 	ldw	r2,-104(fp)
 90b2fb0:	1080008c 	andi	r2,r2,2
 90b2fb4:	1004c03a 	cmpne	r2,r2,zero
 90b2fb8:	1000031e 	bne	r2,zero,90b2fc8 <tcp_input+0xe78>
         GOTO_DROP;
 90b2fbc:	0080de44 	movi	r2,889
 90b2fc0:	d0a0b215 	stw	r2,-32056(gp)
 90b2fc4:	0005a606 	br	90b4660 <tcp_input+0x2510>
      if (tiflags & TH_ACK) 
 90b2fc8:	e0bfe617 	ldw	r2,-104(fp)
 90b2fcc:	1080040c 	andi	r2,r2,16
 90b2fd0:	1005003a 	cmpeq	r2,r2,zero
 90b2fd4:	10000f1e 	bne	r2,zero,90b3014 <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 90b2fd8:	e0bfed17 	ldw	r2,-76(fp)
 90b2fdc:	10c00717 	ldw	r3,28(r2)
 90b2fe0:	e0bfe717 	ldw	r2,-100(fp)
 90b2fe4:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 90b2fe8:	e0bfe717 	ldw	r2,-100(fp)
 90b2fec:	10c00f17 	ldw	r3,60(r2)
 90b2ff0:	e0bfe717 	ldw	r2,-100(fp)
 90b2ff4:	10800e17 	ldw	r2,56(r2)
 90b2ff8:	1885c83a 	sub	r2,r3,r2
 90b2ffc:	1004403a 	cmpge	r2,r2,zero
 90b3000:	1000041e 	bne	r2,zero,90b3014 <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 90b3004:	e0bfe717 	ldw	r2,-100(fp)
 90b3008:	10c00e17 	ldw	r3,56(r2)
 90b300c:	e0bfe717 	ldw	r2,-100(fp)
 90b3010:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 90b3014:	e0bfe717 	ldw	r2,-100(fp)
 90b3018:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 90b301c:	e0bfed17 	ldw	r2,-76(fp)
 90b3020:	10c00617 	ldw	r3,24(r2)
 90b3024:	e0bfe717 	ldw	r2,-100(fp)
 90b3028:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 90b302c:	e0bfe717 	ldw	r2,-100(fp)
 90b3030:	10801817 	ldw	r2,96(r2)
 90b3034:	10c00044 	addi	r3,r2,1
 90b3038:	e0bfe717 	ldw	r2,-100(fp)
 90b303c:	10c01615 	stw	r3,88(r2)
 90b3040:	e0bfe717 	ldw	r2,-100(fp)
 90b3044:	10c01617 	ldw	r3,88(r2)
 90b3048:	e0bfe717 	ldw	r2,-100(fp)
 90b304c:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 90b3050:	e0bfec17 	ldw	r2,-80(fp)
 90b3054:	10c00417 	ldw	r3,16(r2)
 90b3058:	e0bfed17 	ldw	r2,-76(fp)
 90b305c:	10800417 	ldw	r2,16(r2)
 90b3060:	18801926 	beq	r3,r2,90b30c8 <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 90b3064:	e0bff017 	ldw	r2,-64(fp)
 90b3068:	10800117 	ldw	r2,4(r2)
 90b306c:	10800617 	ldw	r2,24(r2)
 90b3070:	1005003a 	cmpeq	r2,r2,zero
 90b3074:	1000141e 	bne	r2,zero,90b30c8 <tcp_input+0xf78>
 90b3078:	e0bff017 	ldw	r2,-64(fp)
 90b307c:	10800117 	ldw	r2,4(r2)
 90b3080:	10800617 	ldw	r2,24(r2)
 90b3084:	10c00a17 	ldw	r3,40(r2)
 90b3088:	e0bfed17 	ldw	r2,-76(fp)
 90b308c:	10800417 	ldw	r2,16(r2)
 90b3090:	18800d1e 	bne	r3,r2,90b30c8 <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 90b3094:	e0bfed17 	ldw	r2,-76(fp)
 90b3098:	10c00417 	ldw	r3,16(r2)
 90b309c:	e0bfec17 	ldw	r2,-80(fp)
 90b30a0:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 90b30a4:	e0bfe717 	ldw	r2,-100(fp)
 90b30a8:	10800c17 	ldw	r2,48(r2)
 90b30ac:	1005003a 	cmpeq	r2,r2,zero
 90b30b0:	1000051e 	bne	r2,zero,90b30c8 <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 90b30b4:	e0bfe717 	ldw	r2,-100(fp)
 90b30b8:	10c00c17 	ldw	r3,48(r2)
 90b30bc:	e0bfed17 	ldw	r2,-76(fp)
 90b30c0:	10800417 	ldw	r2,16(r2)
 90b30c4:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 90b30c8:	e0bfe717 	ldw	r2,-100(fp)
 90b30cc:	10800b0b 	ldhu	r2,44(r2)
 90b30d0:	10800054 	ori	r2,r2,1
 90b30d4:	1007883a 	mov	r3,r2
 90b30d8:	e0bfe717 	ldw	r2,-100(fp)
 90b30dc:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 90b30e0:	e0bfe617 	ldw	r2,-104(fp)
 90b30e4:	1080040c 	andi	r2,r2,16
 90b30e8:	1005003a 	cmpeq	r2,r2,zero
 90b30ec:	1000231e 	bne	r2,zero,90b317c <tcp_input+0x102c>
 90b30f0:	e0bfe717 	ldw	r2,-100(fp)
 90b30f4:	10c00e17 	ldw	r3,56(r2)
 90b30f8:	e0bfe717 	ldw	r2,-100(fp)
 90b30fc:	10801317 	ldw	r2,76(r2)
 90b3100:	1885c83a 	sub	r2,r3,r2
 90b3104:	10800050 	cmplti	r2,r2,1
 90b3108:	10001c1e 	bne	r2,zero,90b317c <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 90b310c:	008243b4 	movhi	r2,2318
 90b3110:	10b58e04 	addi	r2,r2,-10696
 90b3114:	10800217 	ldw	r2,8(r2)
 90b3118:	10c00044 	addi	r3,r2,1
 90b311c:	008243b4 	movhi	r2,2318
 90b3120:	10b58e04 	addi	r2,r2,-10696
 90b3124:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 90b3128:	e0ffe717 	ldw	r3,-100(fp)
 90b312c:	00800104 	movi	r2,4
 90b3130:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 90b3134:	e13fe517 	ldw	r4,-108(fp)
 90b3138:	90b01880 	call	90b0188 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 90b313c:	e13fe517 	ldw	r4,-108(fp)
 90b3140:	90b4c480 	call	90b4c48 <tcp_mss>
 90b3144:	1007883a 	mov	r3,r2
 90b3148:	e0bfe717 	ldw	r2,-100(fp)
 90b314c:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 90b3150:	e13fe717 	ldw	r4,-100(fp)
 90b3154:	000b883a 	mov	r5,zero
 90b3158:	e1bff017 	ldw	r6,-64(fp)
 90b315c:	90b1d480 	call	90b1d48 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 90b3160:	e0bfe717 	ldw	r2,-100(fp)
 90b3164:	10801e17 	ldw	r2,120(r2)
 90b3168:	1005003a 	cmpeq	r2,r2,zero
 90b316c:	1000061e 	bne	r2,zero,90b3188 <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 90b3170:	e13fe717 	ldw	r4,-100(fp)
 90b3174:	90b49600 	call	90b4960 <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 90b3178:	00000306 	br	90b3188 <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 90b317c:	e0ffe717 	ldw	r3,-100(fp)
 90b3180:	008000c4 	movi	r2,3
 90b3184:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 90b3188:	e0bfed17 	ldw	r2,-76(fp)
 90b318c:	10800617 	ldw	r2,24(r2)
 90b3190:	10c00044 	addi	r3,r2,1
 90b3194:	e0bfed17 	ldw	r2,-76(fp)
 90b3198:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 90b319c:	e0bfed17 	ldw	r2,-76(fp)
 90b31a0:	1080028b 	ldhu	r2,10(r2)
 90b31a4:	10ffffcc 	andi	r3,r2,65535
 90b31a8:	e0bfe717 	ldw	r2,-100(fp)
 90b31ac:	10801517 	ldw	r2,84(r2)
 90b31b0:	10c02e2e 	bgeu	r2,r3,90b326c <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 90b31b4:	e0bfed17 	ldw	r2,-76(fp)
 90b31b8:	1080028b 	ldhu	r2,10(r2)
 90b31bc:	10ffffcc 	andi	r3,r2,65535
 90b31c0:	e0bfe717 	ldw	r2,-100(fp)
 90b31c4:	10801517 	ldw	r2,84(r2)
 90b31c8:	10bfffcc 	andi	r2,r2,65535
 90b31cc:	1885c83a 	sub	r2,r3,r2
 90b31d0:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 90b31d4:	e0bff017 	ldw	r2,-64(fp)
 90b31d8:	10800217 	ldw	r2,8(r2)
 90b31dc:	1005003a 	cmpeq	r2,r2,zero
 90b31e0:	1000051e 	bne	r2,zero,90b31f8 <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 90b31e4:	e0bfe417 	ldw	r2,-112(fp)
 90b31e8:	008bc83a 	sub	r5,zero,r2
 90b31ec:	e13ff017 	ldw	r4,-64(fp)
 90b31f0:	90aa90c0 	call	90aa90c <m_adj>
 90b31f4:	00000506 	br	90b320c <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 90b31f8:	e0bff017 	ldw	r2,-64(fp)
 90b31fc:	11000617 	ldw	r4,24(r2)
 90b3200:	e0bfe417 	ldw	r2,-112(fp)
 90b3204:	008bc83a 	sub	r5,zero,r2
 90b3208:	90aa90c0 	call	90aa90c <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 90b320c:	e0bfe717 	ldw	r2,-100(fp)
 90b3210:	10801517 	ldw	r2,84(r2)
 90b3214:	1007883a 	mov	r3,r2
 90b3218:	e0bfed17 	ldw	r2,-76(fp)
 90b321c:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 90b3220:	e0ffe617 	ldw	r3,-104(fp)
 90b3224:	00bfff84 	movi	r2,-2
 90b3228:	1884703a 	and	r2,r3,r2
 90b322c:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 90b3230:	008243b4 	movhi	r2,2318
 90b3234:	10b58e04 	addi	r2,r2,-10696
 90b3238:	10802517 	ldw	r2,148(r2)
 90b323c:	10c00044 	addi	r3,r2,1
 90b3240:	008243b4 	movhi	r2,2318
 90b3244:	10b58e04 	addi	r2,r2,-10696
 90b3248:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 90b324c:	008243b4 	movhi	r2,2318
 90b3250:	10b58e04 	addi	r2,r2,-10696
 90b3254:	10c02617 	ldw	r3,152(r2)
 90b3258:	e0bfe417 	ldw	r2,-112(fp)
 90b325c:	1887883a 	add	r3,r3,r2
 90b3260:	008243b4 	movhi	r2,2318
 90b3264:	10b58e04 	addi	r2,r2,-10696
 90b3268:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 90b326c:	e0bfed17 	ldw	r2,-76(fp)
 90b3270:	10800617 	ldw	r2,24(r2)
 90b3274:	10ffffc4 	addi	r3,r2,-1
 90b3278:	e0bfe717 	ldw	r2,-100(fp)
 90b327c:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 90b3280:	e0bfed17 	ldw	r2,-76(fp)
 90b3284:	10c00617 	ldw	r3,24(r2)
 90b3288:	e0bfe717 	ldw	r2,-100(fp)
 90b328c:	10c01715 	stw	r3,92(r2)
      goto step6;
 90b3290:	00032406 	br	90b3f24 <tcp_input+0x1dd4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 90b3294:	e0bfe717 	ldw	r2,-100(fp)
 90b3298:	10c01617 	ldw	r3,88(r2)
 90b329c:	e0bfed17 	ldw	r2,-76(fp)
 90b32a0:	10800617 	ldw	r2,24(r2)
 90b32a4:	1885c83a 	sub	r2,r3,r2
 90b32a8:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 90b32ac:	e0bfe417 	ldw	r2,-112(fp)
 90b32b0:	10800050 	cmplti	r2,r2,1
 90b32b4:	1000971e 	bne	r2,zero,90b3514 <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 90b32b8:	e0bfe617 	ldw	r2,-104(fp)
 90b32bc:	1080008c 	andi	r2,r2,2
 90b32c0:	1005003a 	cmpeq	r2,r2,zero
 90b32c4:	10001c1e 	bne	r2,zero,90b3338 <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 90b32c8:	e0ffe617 	ldw	r3,-104(fp)
 90b32cc:	00bfff44 	movi	r2,-3
 90b32d0:	1884703a 	and	r2,r3,r2
 90b32d4:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 90b32d8:	e0bfed17 	ldw	r2,-76(fp)
 90b32dc:	10800617 	ldw	r2,24(r2)
 90b32e0:	10c00044 	addi	r3,r2,1
 90b32e4:	e0bfed17 	ldw	r2,-76(fp)
 90b32e8:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 90b32ec:	e0bfed17 	ldw	r2,-76(fp)
 90b32f0:	1080098b 	ldhu	r2,38(r2)
 90b32f4:	10bfffcc 	andi	r2,r2,65535
 90b32f8:	108000b0 	cmpltui	r2,r2,2
 90b32fc:	1000071e 	bne	r2,zero,90b331c <tcp_input+0x11cc>
            ti->ti_urp--;
 90b3300:	e0bfed17 	ldw	r2,-76(fp)
 90b3304:	1080098b 	ldhu	r2,38(r2)
 90b3308:	10bfffc4 	addi	r2,r2,-1
 90b330c:	1007883a 	mov	r3,r2
 90b3310:	e0bfed17 	ldw	r2,-76(fp)
 90b3314:	10c0098d 	sth	r3,38(r2)
 90b3318:	00000406 	br	90b332c <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 90b331c:	e0bfe617 	ldw	r2,-104(fp)
 90b3320:	00fff7c4 	movi	r3,-33
 90b3324:	10c4703a 	and	r2,r2,r3
 90b3328:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 90b332c:	e0bfe417 	ldw	r2,-112(fp)
 90b3330:	10bfffc4 	addi	r2,r2,-1
 90b3334:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 90b3338:	e0bfed17 	ldw	r2,-76(fp)
 90b333c:	1080028b 	ldhu	r2,10(r2)
 90b3340:	10ffffcc 	andi	r3,r2,65535
 90b3344:	e0bfe417 	ldw	r2,-112(fp)
 90b3348:	18800916 	blt	r3,r2,90b3370 <tcp_input+0x1220>
 90b334c:	e0bfed17 	ldw	r2,-76(fp)
 90b3350:	1080028b 	ldhu	r2,10(r2)
 90b3354:	10ffffcc 	andi	r3,r2,65535
 90b3358:	e0bfe417 	ldw	r2,-112(fp)
 90b335c:	18803a1e 	bne	r3,r2,90b3448 <tcp_input+0x12f8>
 90b3360:	e0bfe617 	ldw	r2,-104(fp)
 90b3364:	1080004c 	andi	r2,r2,1
 90b3368:	1004c03a 	cmpne	r2,r2,zero
 90b336c:	1000361e 	bne	r2,zero,90b3448 <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 90b3370:	008243b4 	movhi	r2,2318
 90b3374:	10b58e04 	addi	r2,r2,-10696
 90b3378:	10801f17 	ldw	r2,124(r2)
 90b337c:	10c00044 	addi	r3,r2,1
 90b3380:	008243b4 	movhi	r2,2318
 90b3384:	10b58e04 	addi	r2,r2,-10696
 90b3388:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 90b338c:	008243b4 	movhi	r2,2318
 90b3390:	10b58e04 	addi	r2,r2,-10696
 90b3394:	10c02017 	ldw	r3,128(r2)
 90b3398:	e0bfed17 	ldw	r2,-76(fp)
 90b339c:	1080028b 	ldhu	r2,10(r2)
 90b33a0:	10bfffcc 	andi	r2,r2,65535
 90b33a4:	1887883a 	add	r3,r3,r2
 90b33a8:	008243b4 	movhi	r2,2318
 90b33ac:	10b58e04 	addi	r2,r2,-10696
 90b33b0:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 90b33b4:	e0bfe617 	ldw	r2,-104(fp)
 90b33b8:	1080004c 	andi	r2,r2,1
 90b33bc:	1080005c 	xori	r2,r2,1
 90b33c0:	10803fcc 	andi	r2,r2,255
 90b33c4:	1004c03a 	cmpne	r2,r2,zero
 90b33c8:	1000061e 	bne	r2,zero,90b33e4 <tcp_input+0x1294>
 90b33cc:	e0bfed17 	ldw	r2,-76(fp)
 90b33d0:	1080028b 	ldhu	r2,10(r2)
 90b33d4:	10bfffcc 	andi	r2,r2,65535
 90b33d8:	10c00044 	addi	r3,r2,1
 90b33dc:	e0bfe417 	ldw	r2,-112(fp)
 90b33e0:	18800a26 	beq	r3,r2,90b340c <tcp_input+0x12bc>
 90b33e4:	e0bfe617 	ldw	r2,-104(fp)
 90b33e8:	1080010c 	andi	r2,r2,4
 90b33ec:	1005003a 	cmpeq	r2,r2,zero
 90b33f0:	1004451e 	bne	r2,zero,90b4508 <tcp_input+0x23b8>
 90b33f4:	e0bfed17 	ldw	r2,-76(fp)
 90b33f8:	10c00617 	ldw	r3,24(r2)
 90b33fc:	e0bfe717 	ldw	r2,-100(fp)
 90b3400:	10801617 	ldw	r2,88(r2)
 90b3404:	10bfffc4 	addi	r2,r2,-1
 90b3408:	18843f1e 	bne	r3,r2,90b4508 <tcp_input+0x23b8>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 90b340c:	e0bfed17 	ldw	r2,-76(fp)
 90b3410:	1080028b 	ldhu	r2,10(r2)
 90b3414:	10bfffcc 	andi	r2,r2,65535
 90b3418:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 90b341c:	e0ffe617 	ldw	r3,-104(fp)
 90b3420:	00bfff84 	movi	r2,-2
 90b3424:	1884703a 	and	r2,r3,r2
 90b3428:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 90b342c:	e0bfe717 	ldw	r2,-100(fp)
 90b3430:	10800b0b 	ldhu	r2,44(r2)
 90b3434:	10800054 	ori	r2,r2,1
 90b3438:	1007883a 	mov	r3,r2
 90b343c:	e0bfe717 	ldw	r2,-100(fp)
 90b3440:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 90b3444:	00000f06 	br	90b3484 <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 90b3448:	008243b4 	movhi	r2,2318
 90b344c:	10b58e04 	addi	r2,r2,-10696
 90b3450:	10802117 	ldw	r2,132(r2)
 90b3454:	10c00044 	addi	r3,r2,1
 90b3458:	008243b4 	movhi	r2,2318
 90b345c:	10b58e04 	addi	r2,r2,-10696
 90b3460:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 90b3464:	008243b4 	movhi	r2,2318
 90b3468:	10b58e04 	addi	r2,r2,-10696
 90b346c:	10c02217 	ldw	r3,136(r2)
 90b3470:	e0bfe417 	ldw	r2,-112(fp)
 90b3474:	1887883a 	add	r3,r3,r2
 90b3478:	008243b4 	movhi	r2,2318
 90b347c:	10b58e04 	addi	r2,r2,-10696
 90b3480:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 90b3484:	e13ff017 	ldw	r4,-64(fp)
 90b3488:	e17fe417 	ldw	r5,-112(fp)
 90b348c:	90aa90c0 	call	90aa90c <m_adj>
      ti->ti_seq += todrop;
 90b3490:	e0bfed17 	ldw	r2,-76(fp)
 90b3494:	10c00617 	ldw	r3,24(r2)
 90b3498:	e0bfe417 	ldw	r2,-112(fp)
 90b349c:	1887883a 	add	r3,r3,r2
 90b34a0:	e0bfed17 	ldw	r2,-76(fp)
 90b34a4:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 90b34a8:	e0bfed17 	ldw	r2,-76(fp)
 90b34ac:	10c0028b 	ldhu	r3,10(r2)
 90b34b0:	e0bfe417 	ldw	r2,-112(fp)
 90b34b4:	1885c83a 	sub	r2,r3,r2
 90b34b8:	1007883a 	mov	r3,r2
 90b34bc:	e0bfed17 	ldw	r2,-76(fp)
 90b34c0:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 90b34c4:	e0bfed17 	ldw	r2,-76(fp)
 90b34c8:	10c0098b 	ldhu	r3,38(r2)
 90b34cc:	e0bfe417 	ldw	r2,-112(fp)
 90b34d0:	18ffffcc 	andi	r3,r3,65535
 90b34d4:	10bfffcc 	andi	r2,r2,65535
 90b34d8:	10c0082e 	bgeu	r2,r3,90b34fc <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 90b34dc:	e0bfed17 	ldw	r2,-76(fp)
 90b34e0:	10c0098b 	ldhu	r3,38(r2)
 90b34e4:	e0bfe417 	ldw	r2,-112(fp)
 90b34e8:	1885c83a 	sub	r2,r3,r2
 90b34ec:	1007883a 	mov	r3,r2
 90b34f0:	e0bfed17 	ldw	r2,-76(fp)
 90b34f4:	10c0098d 	sth	r3,38(r2)
 90b34f8:	00000606 	br	90b3514 <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 90b34fc:	e0ffe617 	ldw	r3,-104(fp)
 90b3500:	00bff7c4 	movi	r2,-33
 90b3504:	1884703a 	and	r2,r3,r2
 90b3508:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 90b350c:	e0bfed17 	ldw	r2,-76(fp)
 90b3510:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 90b3514:	e0bfe517 	ldw	r2,-108(fp)
 90b3518:	1080088b 	ldhu	r2,34(r2)
 90b351c:	10bfffcc 	andi	r2,r2,65535
 90b3520:	1080004c 	andi	r2,r2,1
 90b3524:	10803fcc 	andi	r2,r2,255
 90b3528:	1005003a 	cmpeq	r2,r2,zero
 90b352c:	1000161e 	bne	r2,zero,90b3588 <tcp_input+0x1438>
 90b3530:	e0bfe717 	ldw	r2,-100(fp)
 90b3534:	10800217 	ldw	r2,8(r2)
 90b3538:	10800190 	cmplti	r2,r2,6
 90b353c:	1000121e 	bne	r2,zero,90b3588 <tcp_input+0x1438>
 90b3540:	e0bfed17 	ldw	r2,-76(fp)
 90b3544:	1080028b 	ldhu	r2,10(r2)
 90b3548:	10bfffcc 	andi	r2,r2,65535
 90b354c:	1005003a 	cmpeq	r2,r2,zero
 90b3550:	10000d1e 	bne	r2,zero,90b3588 <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 90b3554:	e13fe717 	ldw	r4,-100(fp)
 90b3558:	90b68800 	call	90b6880 <tcp_close>
 90b355c:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 90b3560:	008243b4 	movhi	r2,2318
 90b3564:	10b58e04 	addi	r2,r2,-10696
 90b3568:	10802717 	ldw	r2,156(r2)
 90b356c:	10c00044 	addi	r3,r2,1
 90b3570:	008243b4 	movhi	r2,2318
 90b3574:	10b58e04 	addi	r2,r2,-10696
 90b3578:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 90b357c:	00810444 	movi	r2,1041
 90b3580:	d0a0b215 	stw	r2,-32056(gp)
 90b3584:	0003f206 	br	90b4550 <tcp_input+0x2400>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 90b3588:	e0bfed17 	ldw	r2,-76(fp)
 90b358c:	10c00617 	ldw	r3,24(r2)
 90b3590:	e0bfed17 	ldw	r2,-76(fp)
 90b3594:	1080028b 	ldhu	r2,10(r2)
 90b3598:	10bfffcc 	andi	r2,r2,65535
 90b359c:	10a0001c 	xori	r2,r2,32768
 90b35a0:	10a00004 	addi	r2,r2,-32768
 90b35a4:	1889883a 	add	r4,r3,r2
 90b35a8:	e0bfe717 	ldw	r2,-100(fp)
 90b35ac:	10c01617 	ldw	r3,88(r2)
 90b35b0:	e0bfe717 	ldw	r2,-100(fp)
 90b35b4:	10801517 	ldw	r2,84(r2)
 90b35b8:	1885883a 	add	r2,r3,r2
 90b35bc:	2085c83a 	sub	r2,r4,r2
 90b35c0:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 90b35c4:	e0bfe417 	ldw	r2,-112(fp)
 90b35c8:	10800050 	cmplti	r2,r2,1
 90b35cc:	10006b1e 	bne	r2,zero,90b377c <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 90b35d0:	008243b4 	movhi	r2,2318
 90b35d4:	10b58e04 	addi	r2,r2,-10696
 90b35d8:	10802517 	ldw	r2,148(r2)
 90b35dc:	10c00044 	addi	r3,r2,1
 90b35e0:	008243b4 	movhi	r2,2318
 90b35e4:	10b58e04 	addi	r2,r2,-10696
 90b35e8:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 90b35ec:	e0bfed17 	ldw	r2,-76(fp)
 90b35f0:	1080028b 	ldhu	r2,10(r2)
 90b35f4:	10ffffcc 	andi	r3,r2,65535
 90b35f8:	e0bfe417 	ldw	r2,-112(fp)
 90b35fc:	10c03e16 	blt	r2,r3,90b36f8 <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 90b3600:	008243b4 	movhi	r2,2318
 90b3604:	10b58e04 	addi	r2,r2,-10696
 90b3608:	10c02617 	ldw	r3,152(r2)
 90b360c:	e0bfed17 	ldw	r2,-76(fp)
 90b3610:	1080028b 	ldhu	r2,10(r2)
 90b3614:	10bfffcc 	andi	r2,r2,65535
 90b3618:	1887883a 	add	r3,r3,r2
 90b361c:	008243b4 	movhi	r2,2318
 90b3620:	10b58e04 	addi	r2,r2,-10696
 90b3624:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 90b3628:	e0bfe617 	ldw	r2,-104(fp)
 90b362c:	1080008c 	andi	r2,r2,2
 90b3630:	1005003a 	cmpeq	r2,r2,zero
 90b3634:	1000191e 	bne	r2,zero,90b369c <tcp_input+0x154c>
 90b3638:	e0bfe717 	ldw	r2,-100(fp)
 90b363c:	10800217 	ldw	r2,8(r2)
 90b3640:	10800298 	cmpnei	r2,r2,10
 90b3644:	1000151e 	bne	r2,zero,90b369c <tcp_input+0x154c>
 90b3648:	e0bfed17 	ldw	r2,-76(fp)
 90b364c:	10c00617 	ldw	r3,24(r2)
 90b3650:	e0bfe717 	ldw	r2,-100(fp)
 90b3654:	10801617 	ldw	r2,88(r2)
 90b3658:	1885c83a 	sub	r2,r3,r2
 90b365c:	10800050 	cmplti	r2,r2,1
 90b3660:	10000e1e 	bne	r2,zero,90b369c <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 90b3664:	e0bfe717 	ldw	r2,-100(fp)
 90b3668:	10c01617 	ldw	r3,88(r2)
 90b366c:	008000b4 	movhi	r2,2
 90b3670:	10bd3fc4 	addi	r2,r2,-2817
 90b3674:	1885883a 	add	r2,r3,r2
 90b3678:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 90b367c:	e0bfdf17 	ldw	r2,-132(fp)
 90b3680:	10bfc02c 	andhi	r2,r2,65280
 90b3684:	1005003a 	cmpeq	r2,r2,zero
 90b3688:	1000011e 	bne	r2,zero,90b3690 <tcp_input+0x1540>
            {
               iss = 0L;
 90b368c:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 90b3690:	e13fe717 	ldw	r4,-100(fp)
 90b3694:	90b68800 	call	90b6880 <tcp_close>
            goto findpcb;
 90b3698:	003b8d06 	br	90b24d0 <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 90b369c:	e0bfe717 	ldw	r2,-100(fp)
 90b36a0:	10801517 	ldw	r2,84(r2)
 90b36a4:	1004c03a 	cmpne	r2,r2,zero
 90b36a8:	1003971e 	bne	r2,zero,90b4508 <tcp_input+0x23b8>
 90b36ac:	e0bfed17 	ldw	r2,-76(fp)
 90b36b0:	10c00617 	ldw	r3,24(r2)
 90b36b4:	e0bfe717 	ldw	r2,-100(fp)
 90b36b8:	10801617 	ldw	r2,88(r2)
 90b36bc:	1883921e 	bne	r3,r2,90b4508 <tcp_input+0x23b8>
         {
            tp->t_flags |= TF_ACKNOW;
 90b36c0:	e0bfe717 	ldw	r2,-100(fp)
 90b36c4:	10800b0b 	ldhu	r2,44(r2)
 90b36c8:	10800054 	ori	r2,r2,1
 90b36cc:	1007883a 	mov	r3,r2
 90b36d0:	e0bfe717 	ldw	r2,-100(fp)
 90b36d4:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 90b36d8:	008243b4 	movhi	r2,2318
 90b36dc:	10b58e04 	addi	r2,r2,-10696
 90b36e0:	10802817 	ldw	r2,160(r2)
 90b36e4:	10c00044 	addi	r3,r2,1
 90b36e8:	008243b4 	movhi	r2,2318
 90b36ec:	10b58e04 	addi	r2,r2,-10696
 90b36f0:	10c02815 	stw	r3,160(r2)
 90b36f4:	00000806 	br	90b3718 <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 90b36f8:	008243b4 	movhi	r2,2318
 90b36fc:	10b58e04 	addi	r2,r2,-10696
 90b3700:	10c02617 	ldw	r3,152(r2)
 90b3704:	e0bfe417 	ldw	r2,-112(fp)
 90b3708:	1887883a 	add	r3,r3,r2
 90b370c:	008243b4 	movhi	r2,2318
 90b3710:	10b58e04 	addi	r2,r2,-10696
 90b3714:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 90b3718:	e0bff017 	ldw	r2,-64(fp)
 90b371c:	10800217 	ldw	r2,8(r2)
 90b3720:	1005003a 	cmpeq	r2,r2,zero
 90b3724:	1000051e 	bne	r2,zero,90b373c <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 90b3728:	e0bfe417 	ldw	r2,-112(fp)
 90b372c:	008bc83a 	sub	r5,zero,r2
 90b3730:	e13ff017 	ldw	r4,-64(fp)
 90b3734:	90aa90c0 	call	90aa90c <m_adj>
 90b3738:	00000506 	br	90b3750 <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 90b373c:	e0bff017 	ldw	r2,-64(fp)
 90b3740:	11000617 	ldw	r4,24(r2)
 90b3744:	e0bfe417 	ldw	r2,-112(fp)
 90b3748:	008bc83a 	sub	r5,zero,r2
 90b374c:	90aa90c0 	call	90aa90c <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 90b3750:	e0bfed17 	ldw	r2,-76(fp)
 90b3754:	10c0028b 	ldhu	r3,10(r2)
 90b3758:	e0bfe417 	ldw	r2,-112(fp)
 90b375c:	1885c83a 	sub	r2,r3,r2
 90b3760:	1007883a 	mov	r3,r2
 90b3764:	e0bfed17 	ldw	r2,-76(fp)
 90b3768:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 90b376c:	e0ffe617 	ldw	r3,-104(fp)
 90b3770:	00bffd84 	movi	r2,-10
 90b3774:	1884703a 	and	r2,r3,r2
 90b3778:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 90b377c:	e0bfe617 	ldw	r2,-104(fp)
 90b3780:	1080010c 	andi	r2,r2,4
 90b3784:	1005003a 	cmpeq	r2,r2,zero
 90b3788:	1000391e 	bne	r2,zero,90b3870 <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 90b378c:	e0bfe717 	ldw	r2,-100(fp)
 90b3790:	10800217 	ldw	r2,8(r2)
 90b3794:	10bfff44 	addi	r2,r2,-3
 90b3798:	e0bffe15 	stw	r2,-8(fp)
 90b379c:	e13ffe17 	ldw	r4,-8(fp)
 90b37a0:	20800228 	cmpgeui	r2,r4,8
 90b37a4:	1000321e 	bne	r2,zero,90b3870 <tcp_input+0x1720>
 90b37a8:	e0fffe17 	ldw	r3,-8(fp)
 90b37ac:	e0fffe17 	ldw	r3,-8(fp)
 90b37b0:	18c5883a 	add	r2,r3,r3
 90b37b4:	1087883a 	add	r3,r2,r2
 90b37b8:	008242f4 	movhi	r2,2315
 90b37bc:	108df304 	addi	r2,r2,14284
 90b37c0:	1885883a 	add	r2,r3,r2
 90b37c4:	10800017 	ldw	r2,0(r2)
 90b37c8:	1000683a 	jmp	r2
 90b37cc:	090b37ec 	andhi	r4,at,11487
 90b37d0:	090b37fc 	xorhi	r4,at,11487
 90b37d4:	090b3818 	cmpnei	r4,at,11488
 90b37d8:	090b3818 	cmpnei	r4,at,11488
 90b37dc:	090b385c 	xori	r4,at,11489
 90b37e0:	090b385c 	xori	r4,at,11489
 90b37e4:	090b3818 	cmpnei	r4,at,11488
 90b37e8:	090b385c 	xori	r4,at,11489
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 90b37ec:	e0ffe517 	ldw	r3,-108(fp)
 90b37f0:	00801bc4 	movi	r2,111
 90b37f4:	18800615 	stw	r2,24(r3)
         goto close;
 90b37f8:	00000a06 	br	90b3824 <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 90b37fc:	008243b4 	movhi	r2,2318
 90b3800:	10b56004 	addi	r2,r2,-10880
 90b3804:	10800717 	ldw	r2,28(r2)
 90b3808:	10c00044 	addi	r3,r2,1
 90b380c:	008243b4 	movhi	r2,2318
 90b3810:	10b56004 	addi	r2,r2,-10880
 90b3814:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 90b3818:	e0ffe517 	ldw	r3,-108(fp)
 90b381c:	00801a04 	movi	r2,104
 90b3820:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 90b3824:	e0bfe717 	ldw	r2,-100(fp)
 90b3828:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 90b382c:	008243b4 	movhi	r2,2318
 90b3830:	10b58e04 	addi	r2,r2,-10696
 90b3834:	10800317 	ldw	r2,12(r2)
 90b3838:	10c00044 	addi	r3,r2,1
 90b383c:	008243b4 	movhi	r2,2318
 90b3840:	10b58e04 	addi	r2,r2,-10696
 90b3844:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 90b3848:	e13fe717 	ldw	r4,-100(fp)
 90b384c:	90b68800 	call	90b6880 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 90b3850:	00812204 	movi	r2,1160
 90b3854:	d0a0b215 	stw	r2,-32056(gp)
 90b3858:	00038106 	br	90b4660 <tcp_input+0x2510>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 90b385c:	e13fe717 	ldw	r4,-100(fp)
 90b3860:	90b68800 	call	90b6880 <tcp_close>
         GOTO_DROP;
 90b3864:	00812384 	movi	r2,1166
 90b3868:	d0a0b215 	stw	r2,-32056(gp)
 90b386c:	00037c06 	br	90b4660 <tcp_input+0x2510>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 90b3870:	e0bfe617 	ldw	r2,-104(fp)
 90b3874:	1080008c 	andi	r2,r2,2
 90b3878:	1005003a 	cmpeq	r2,r2,zero
 90b387c:	1000071e 	bne	r2,zero,90b389c <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 90b3880:	e13fe717 	ldw	r4,-100(fp)
 90b3884:	01401a04 	movi	r5,104
 90b3888:	90b67d40 	call	90b67d4 <tcp_drop>
 90b388c:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 90b3890:	00812b04 	movi	r2,1196
 90b3894:	d0a0b215 	stw	r2,-32056(gp)
 90b3898:	00032d06 	br	90b4550 <tcp_input+0x2400>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 90b389c:	e0bfe617 	ldw	r2,-104(fp)
 90b38a0:	1080040c 	andi	r2,r2,16
 90b38a4:	1004c03a 	cmpne	r2,r2,zero
 90b38a8:	1000031e 	bne	r2,zero,90b38b8 <tcp_input+0x1768>
      GOTO_DROP;
 90b38ac:	00812d04 	movi	r2,1204
 90b38b0:	d0a0b215 	stw	r2,-32056(gp)
 90b38b4:	00036a06 	br	90b4660 <tcp_input+0x2510>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 90b38b8:	e0bfe717 	ldw	r2,-100(fp)
 90b38bc:	10800217 	ldw	r2,8(r2)
 90b38c0:	e0bff715 	stw	r2,-36(fp)
 90b38c4:	e13ff717 	ldw	r4,-36(fp)
 90b38c8:	208000e0 	cmpeqi	r2,r4,3
 90b38cc:	1000071e 	bne	r2,zero,90b38ec <tcp_input+0x179c>
 90b38d0:	e0fff717 	ldw	r3,-36(fp)
 90b38d4:	188000d0 	cmplti	r2,r3,3
 90b38d8:	1001921e 	bne	r2,zero,90b3f24 <tcp_input+0x1dd4>
 90b38dc:	e13ff717 	ldw	r4,-36(fp)
 90b38e0:	208002c8 	cmpgei	r2,r4,11
 90b38e4:	10018f1e 	bne	r2,zero,90b3f24 <tcp_input+0x1dd4>
 90b38e8:	00003206 	br	90b39b4 <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 90b38ec:	e0bfe717 	ldw	r2,-100(fp)
 90b38f0:	10c00e17 	ldw	r3,56(r2)
 90b38f4:	e0bfed17 	ldw	r2,-76(fp)
 90b38f8:	10800717 	ldw	r2,28(r2)
 90b38fc:	1885c83a 	sub	r2,r3,r2
 90b3900:	10800048 	cmpgei	r2,r2,1
 90b3904:	1000071e 	bne	r2,zero,90b3924 <tcp_input+0x17d4>
 90b3908:	e0bfed17 	ldw	r2,-76(fp)
 90b390c:	10c00717 	ldw	r3,28(r2)
 90b3910:	e0bfe717 	ldw	r2,-100(fp)
 90b3914:	10801a17 	ldw	r2,104(r2)
 90b3918:	1885c83a 	sub	r2,r3,r2
 90b391c:	10800050 	cmplti	r2,r2,1
 90b3920:	10000a1e 	bne	r2,zero,90b394c <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 90b3924:	008243b4 	movhi	r2,2318
 90b3928:	10b56004 	addi	r2,r2,-10880
 90b392c:	10800717 	ldw	r2,28(r2)
 90b3930:	10c00044 	addi	r3,r2,1
 90b3934:	008243b4 	movhi	r2,2318
 90b3938:	10b56004 	addi	r2,r2,-10880
 90b393c:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 90b3940:	00813184 	movi	r2,1222
 90b3944:	d0a0b215 	stw	r2,-32056(gp)
 90b3948:	00030106 	br	90b4550 <tcp_input+0x2400>
      }
      tcpstat.tcps_connects++;
 90b394c:	008243b4 	movhi	r2,2318
 90b3950:	10b58e04 	addi	r2,r2,-10696
 90b3954:	10800217 	ldw	r2,8(r2)
 90b3958:	10c00044 	addi	r3,r2,1
 90b395c:	008243b4 	movhi	r2,2318
 90b3960:	10b58e04 	addi	r2,r2,-10696
 90b3964:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 90b3968:	e0ffe717 	ldw	r3,-100(fp)
 90b396c:	00800104 	movi	r2,4
 90b3970:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 90b3974:	e13fe517 	ldw	r4,-108(fp)
 90b3978:	90b01880 	call	90b0188 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 90b397c:	e13fe517 	ldw	r4,-108(fp)
 90b3980:	90b4c480 	call	90b4c48 <tcp_mss>
 90b3984:	1007883a 	mov	r3,r2
 90b3988:	e0bfe717 	ldw	r2,-100(fp)
 90b398c:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 90b3990:	e13fe717 	ldw	r4,-100(fp)
 90b3994:	000b883a 	mov	r5,zero
 90b3998:	e1bff017 	ldw	r6,-64(fp)
 90b399c:	90b1d480 	call	90b1d48 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 90b39a0:	e0bfed17 	ldw	r2,-76(fp)
 90b39a4:	10800617 	ldw	r2,24(r2)
 90b39a8:	10ffffc4 	addi	r3,r2,-1
 90b39ac:	e0bfe717 	ldw	r2,-100(fp)
 90b39b0:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 90b39b4:	e0bfed17 	ldw	r2,-76(fp)
 90b39b8:	10c00717 	ldw	r3,28(r2)
 90b39bc:	e0bfe717 	ldw	r2,-100(fp)
 90b39c0:	10800e17 	ldw	r2,56(r2)
 90b39c4:	1885c83a 	sub	r2,r3,r2
 90b39c8:	10800048 	cmpgei	r2,r2,1
 90b39cc:	1000671e 	bne	r2,zero,90b3b6c <tcp_input+0x1a1c>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 90b39d0:	e0bfed17 	ldw	r2,-76(fp)
 90b39d4:	1080028b 	ldhu	r2,10(r2)
 90b39d8:	10bfffcc 	andi	r2,r2,65535
 90b39dc:	1004c03a 	cmpne	r2,r2,zero
 90b39e0:	10005f1e 	bne	r2,zero,90b3b60 <tcp_input+0x1a10>
 90b39e4:	e0bfe717 	ldw	r2,-100(fp)
 90b39e8:	10c01417 	ldw	r3,80(r2)
 90b39ec:	e0bfde17 	ldw	r2,-136(fp)
 90b39f0:	18805b1e 	bne	r3,r2,90b3b60 <tcp_input+0x1a10>
         {
            tcpstat.tcps_rcvdupack++;
 90b39f4:	008243b4 	movhi	r2,2318
 90b39f8:	10b58e04 	addi	r2,r2,-10696
 90b39fc:	10802917 	ldw	r2,164(r2)
 90b3a00:	10c00044 	addi	r3,r2,1
 90b3a04:	008243b4 	movhi	r2,2318
 90b3a08:	10b58e04 	addi	r2,r2,-10696
 90b3a0c:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 90b3a10:	e0bfe717 	ldw	r2,-100(fp)
 90b3a14:	10800317 	ldw	r2,12(r2)
 90b3a18:	1005003a 	cmpeq	r2,r2,zero
 90b3a1c:	1000051e 	bne	r2,zero,90b3a34 <tcp_input+0x18e4>
 90b3a20:	e0bfed17 	ldw	r2,-76(fp)
 90b3a24:	10c00717 	ldw	r3,28(r2)
 90b3a28:	e0bfe717 	ldw	r2,-100(fp)
 90b3a2c:	10800e17 	ldw	r2,56(r2)
 90b3a30:	18800326 	beq	r3,r2,90b3a40 <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 90b3a34:	e0bfe717 	ldw	r2,-100(fp)
 90b3a38:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 90b3a3c:	00013906 	br	90b3f24 <tcp_input+0x1dd4>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 90b3a40:	e0bfe717 	ldw	r2,-100(fp)
 90b3a44:	10800917 	ldw	r2,36(r2)
 90b3a48:	10c00044 	addi	r3,r2,1
 90b3a4c:	e0bfe717 	ldw	r2,-100(fp)
 90b3a50:	10c00915 	stw	r3,36(r2)
 90b3a54:	e0bfe717 	ldw	r2,-100(fp)
 90b3a58:	10c00917 	ldw	r3,36(r2)
 90b3a5c:	d0a03a83 	ldbu	r2,-32534(gp)
 90b3a60:	10803fcc 	andi	r2,r2,255
 90b3a64:	1080201c 	xori	r2,r2,128
 90b3a68:	10bfe004 	addi	r2,r2,-128
 90b3a6c:	18812d1e 	bne	r3,r2,90b3f24 <tcp_input+0x1dd4>
            {
               tcp_seq onxt = tp->snd_nxt;
 90b3a70:	e0bfe717 	ldw	r2,-100(fp)
 90b3a74:	10800f17 	ldw	r2,60(r2)
 90b3a78:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 90b3a7c:	e0bfe717 	ldw	r2,-100(fp)
 90b3a80:	10c01417 	ldw	r3,80(r2)
 90b3a84:	e0bfe717 	ldw	r2,-100(fp)
 90b3a88:	10801b17 	ldw	r2,108(r2)
 90b3a8c:	e0bff615 	stw	r2,-40(fp)
 90b3a90:	e0fff515 	stw	r3,-44(fp)
 90b3a94:	e0bff617 	ldw	r2,-40(fp)
 90b3a98:	e0fff517 	ldw	r3,-44(fp)
 90b3a9c:	10c0022e 	bgeu	r2,r3,90b3aa8 <tcp_input+0x1958>
 90b3aa0:	e13ff617 	ldw	r4,-40(fp)
 90b3aa4:	e13ff515 	stw	r4,-44(fp)
 90b3aa8:	e0bff517 	ldw	r2,-44(fp)
 90b3aac:	1006d07a 	srli	r3,r2,1
 90b3ab0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ab4:	10800a0b 	ldhu	r2,40(r2)
 90b3ab8:	10bfffcc 	andi	r2,r2,65535
 90b3abc:	1885203a 	divu	r2,r3,r2
 90b3ac0:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 90b3ac4:	e0bfd60b 	ldhu	r2,-168(fp)
 90b3ac8:	108000a8 	cmpgeui	r2,r2,2
 90b3acc:	1000021e 	bne	r2,zero,90b3ad8 <tcp_input+0x1988>
                  win = 2;
 90b3ad0:	00800084 	movi	r2,2
 90b3ad4:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 90b3ad8:	e0bfe717 	ldw	r2,-100(fp)
 90b3adc:	10c00a0b 	ldhu	r3,40(r2)
 90b3ae0:	e0bfd60b 	ldhu	r2,-168(fp)
 90b3ae4:	1885383a 	mul	r2,r3,r2
 90b3ae8:	10ffffcc 	andi	r3,r2,65535
 90b3aec:	e0bfe717 	ldw	r2,-100(fp)
 90b3af0:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 90b3af4:	e0bfe717 	ldw	r2,-100(fp)
 90b3af8:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 90b3afc:	e0bfe717 	ldw	r2,-100(fp)
 90b3b00:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 90b3b04:	e0bfed17 	ldw	r2,-76(fp)
 90b3b08:	10c00717 	ldw	r3,28(r2)
 90b3b0c:	e0bfe717 	ldw	r2,-100(fp)
 90b3b10:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 90b3b14:	e0bfe717 	ldw	r2,-100(fp)
 90b3b18:	10800a0b 	ldhu	r2,40(r2)
 90b3b1c:	10ffffcc 	andi	r3,r2,65535
 90b3b20:	e0bfe717 	ldw	r2,-100(fp)
 90b3b24:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 90b3b28:	e13fe717 	ldw	r4,-100(fp)
 90b3b2c:	90b4d640 	call	90b4d64 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 90b3b30:	e0bfe717 	ldw	r2,-100(fp)
 90b3b34:	10c00f17 	ldw	r3,60(r2)
 90b3b38:	e0bfd717 	ldw	r2,-164(fp)
 90b3b3c:	10c5c83a 	sub	r2,r2,r3
 90b3b40:	10800050 	cmplti	r2,r2,1
 90b3b44:	1000031e 	bne	r2,zero,90b3b54 <tcp_input+0x1a04>
                  tp->snd_nxt = onxt;
 90b3b48:	e0ffe717 	ldw	r3,-100(fp)
 90b3b4c:	e0bfd717 	ldw	r2,-164(fp)
 90b3b50:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 90b3b54:	00814544 	movi	r2,1301
 90b3b58:	d0a0b215 	stw	r2,-32056(gp)
 90b3b5c:	0002c006 	br	90b4660 <tcp_input+0x2510>
            }
         } else
            tp->t_dupacks = 0;
 90b3b60:	e0bfe717 	ldw	r2,-100(fp)
 90b3b64:	10000915 	stw	zero,36(r2)
         break;
 90b3b68:	0000ee06 	br	90b3f24 <tcp_input+0x1dd4>
      }
      tp->t_dupacks = 0;
 90b3b6c:	e0bfe717 	ldw	r2,-100(fp)
 90b3b70:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 90b3b74:	e0bfed17 	ldw	r2,-76(fp)
 90b3b78:	10c00717 	ldw	r3,28(r2)
 90b3b7c:	e0bfe717 	ldw	r2,-100(fp)
 90b3b80:	10801a17 	ldw	r2,104(r2)
 90b3b84:	1885c83a 	sub	r2,r3,r2
 90b3b88:	10800050 	cmplti	r2,r2,1
 90b3b8c:	1000081e 	bne	r2,zero,90b3bb0 <tcp_input+0x1a60>
      {
         tcpstat.tcps_rcvacktoomuch++;
 90b3b90:	008243b4 	movhi	r2,2318
 90b3b94:	10b58e04 	addi	r2,r2,-10696
 90b3b98:	10802a17 	ldw	r2,168(r2)
 90b3b9c:	10c00044 	addi	r3,r2,1
 90b3ba0:	008243b4 	movhi	r2,2318
 90b3ba4:	10b58e04 	addi	r2,r2,-10696
 90b3ba8:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 90b3bac:	00025606 	br	90b4508 <tcp_input+0x23b8>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 90b3bb0:	e0bfed17 	ldw	r2,-76(fp)
 90b3bb4:	10c00717 	ldw	r3,28(r2)
 90b3bb8:	e0bfe717 	ldw	r2,-100(fp)
 90b3bbc:	10800e17 	ldw	r2,56(r2)
 90b3bc0:	1885c83a 	sub	r2,r3,r2
 90b3bc4:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 90b3bc8:	008243b4 	movhi	r2,2318
 90b3bcc:	10b58e04 	addi	r2,r2,-10696
 90b3bd0:	10802b17 	ldw	r2,172(r2)
 90b3bd4:	10c00044 	addi	r3,r2,1
 90b3bd8:	008243b4 	movhi	r2,2318
 90b3bdc:	10b58e04 	addi	r2,r2,-10696
 90b3be0:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 90b3be4:	008243b4 	movhi	r2,2318
 90b3be8:	10b58e04 	addi	r2,r2,-10696
 90b3bec:	10c02c17 	ldw	r3,176(r2)
 90b3bf0:	e0bfe317 	ldw	r2,-116(fp)
 90b3bf4:	1887883a 	add	r3,r3,r2
 90b3bf8:	008243b4 	movhi	r2,2318
 90b3bfc:	10b58e04 	addi	r2,r2,-10696
 90b3c00:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 90b3c04:	e0bfe717 	ldw	r2,-100(fp)
 90b3c08:	10801e17 	ldw	r2,120(r2)
 90b3c0c:	1005003a 	cmpeq	r2,r2,zero
 90b3c10:	1000091e 	bne	r2,zero,90b3c38 <tcp_input+0x1ae8>
 90b3c14:	e0bfed17 	ldw	r2,-76(fp)
 90b3c18:	10c00717 	ldw	r3,28(r2)
 90b3c1c:	e0bfe717 	ldw	r2,-100(fp)
 90b3c20:	10801f17 	ldw	r2,124(r2)
 90b3c24:	1885c83a 	sub	r2,r3,r2
 90b3c28:	10800050 	cmplti	r2,r2,1
 90b3c2c:	1000021e 	bne	r2,zero,90b3c38 <tcp_input+0x1ae8>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 90b3c30:	e13fe717 	ldw	r4,-100(fp)
 90b3c34:	90b49600 	call	90b4960 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 90b3c38:	e0bfed17 	ldw	r2,-76(fp)
 90b3c3c:	10c00717 	ldw	r3,28(r2)
 90b3c40:	e0bfe717 	ldw	r2,-100(fp)
 90b3c44:	10801a17 	ldw	r2,104(r2)
 90b3c48:	1880051e 	bne	r3,r2,90b3c60 <tcp_input+0x1b10>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 90b3c4c:	e0bfe717 	ldw	r2,-100(fp)
 90b3c50:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 90b3c54:	00800044 	movi	r2,1
 90b3c58:	e0bfe115 	stw	r2,-124(fp)
 90b3c5c:	00000806 	br	90b3c80 <tcp_input+0x1b30>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 90b3c60:	e0bfe717 	ldw	r2,-100(fp)
 90b3c64:	10800417 	ldw	r2,16(r2)
 90b3c68:	1004c03a 	cmpne	r2,r2,zero
 90b3c6c:	1000041e 	bne	r2,zero,90b3c80 <tcp_input+0x1b30>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b3c70:	e0bfe717 	ldw	r2,-100(fp)
 90b3c74:	10c00817 	ldw	r3,32(r2)
 90b3c78:	e0bfe717 	ldw	r2,-100(fp)
 90b3c7c:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 90b3c80:	e0bfe717 	ldw	r2,-100(fp)
 90b3c84:	10801b17 	ldw	r2,108(r2)
 90b3c88:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 90b3c8c:	e0bfe717 	ldw	r2,-100(fp)
 90b3c90:	10800a0b 	ldhu	r2,40(r2)
 90b3c94:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 90b3c98:	e0bfe717 	ldw	r2,-100(fp)
 90b3c9c:	10c01c17 	ldw	r3,112(r2)
 90b3ca0:	e0bfd517 	ldw	r2,-172(fp)
 90b3ca4:	18800e2e 	bgeu	r3,r2,90b3ce0 <tcp_input+0x1b90>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 90b3ca8:	e0ffd40b 	ldhu	r3,-176(fp)
 90b3cac:	e0bfd40b 	ldhu	r2,-176(fp)
 90b3cb0:	1885383a 	mul	r2,r3,r2
 90b3cb4:	1007883a 	mov	r3,r2
 90b3cb8:	e0bfd517 	ldw	r2,-172(fp)
 90b3cbc:	1885203a 	divu	r2,r3,r2
 90b3cc0:	e0bff415 	stw	r2,-48(fp)
 90b3cc4:	e0fff417 	ldw	r3,-48(fp)
 90b3cc8:	18800428 	cmpgeui	r2,r3,16
 90b3ccc:	1000021e 	bne	r2,zero,90b3cd8 <tcp_input+0x1b88>
 90b3cd0:	01000404 	movi	r4,16
 90b3cd4:	e13ff415 	stw	r4,-48(fp)
 90b3cd8:	e0bff417 	ldw	r2,-48(fp)
 90b3cdc:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 90b3ce0:	e0ffd40b 	ldhu	r3,-176(fp)
 90b3ce4:	e0bfd517 	ldw	r2,-172(fp)
 90b3ce8:	1885883a 	add	r2,r3,r2
 90b3cec:	e0bff315 	stw	r2,-52(fp)
 90b3cf0:	e0fff317 	ldw	r3,-52(fp)
 90b3cf4:	18980070 	cmpltui	r2,r3,24577
 90b3cf8:	1000021e 	bne	r2,zero,90b3d04 <tcp_input+0x1bb4>
 90b3cfc:	01180004 	movi	r4,24576
 90b3d00:	e13ff315 	stw	r4,-52(fp)
 90b3d04:	e0bfe717 	ldw	r2,-100(fp)
 90b3d08:	e0fff317 	ldw	r3,-52(fp)
 90b3d0c:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 90b3d10:	e0bfe517 	ldw	r2,-108(fp)
 90b3d14:	10801217 	ldw	r2,72(r2)
 90b3d18:	1007883a 	mov	r3,r2
 90b3d1c:	e0bfe317 	ldw	r2,-116(fp)
 90b3d20:	1880110e 	bge	r3,r2,90b3d68 <tcp_input+0x1c18>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 90b3d24:	e0bfe717 	ldw	r2,-100(fp)
 90b3d28:	10c01417 	ldw	r3,80(r2)
 90b3d2c:	e0bfe517 	ldw	r2,-108(fp)
 90b3d30:	10801217 	ldw	r2,72(r2)
 90b3d34:	10bfffcc 	andi	r2,r2,65535
 90b3d38:	1887c83a 	sub	r3,r3,r2
 90b3d3c:	e0bfe717 	ldw	r2,-100(fp)
 90b3d40:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 90b3d44:	e0bfe517 	ldw	r2,-108(fp)
 90b3d48:	11001204 	addi	r4,r2,72
 90b3d4c:	e0bfe517 	ldw	r2,-108(fp)
 90b3d50:	10801217 	ldw	r2,72(r2)
 90b3d54:	100b883a 	mov	r5,r2
 90b3d58:	90b10c00 	call	90b10c0 <sbdrop>
         ourfinisacked = 1;
 90b3d5c:	00800044 	movi	r2,1
 90b3d60:	e0bfe215 	stw	r2,-120(fp)
 90b3d64:	00000c06 	br	90b3d98 <tcp_input+0x1c48>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 90b3d68:	e0bfe517 	ldw	r2,-108(fp)
 90b3d6c:	11001204 	addi	r4,r2,72
 90b3d70:	e17fe317 	ldw	r5,-116(fp)
 90b3d74:	90b10c00 	call	90b10c0 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 90b3d78:	e0bfe717 	ldw	r2,-100(fp)
 90b3d7c:	10c01417 	ldw	r3,80(r2)
 90b3d80:	e0bfe317 	ldw	r2,-116(fp)
 90b3d84:	10bfffcc 	andi	r2,r2,65535
 90b3d88:	1887c83a 	sub	r3,r3,r2
 90b3d8c:	e0bfe717 	ldw	r2,-100(fp)
 90b3d90:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 90b3d94:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 90b3d98:	e0bfe517 	ldw	r2,-108(fp)
 90b3d9c:	1080190b 	ldhu	r2,100(r2)
 90b3da0:	10bfffcc 	andi	r2,r2,65535
 90b3da4:	1080030c 	andi	r2,r2,12
 90b3da8:	1005003a 	cmpeq	r2,r2,zero
 90b3dac:	1000041e 	bne	r2,zero,90b3dc0 <tcp_input+0x1c70>
         sowwakeup(so);
 90b3db0:	e0bfe517 	ldw	r2,-108(fp)
 90b3db4:	11401204 	addi	r5,r2,72
 90b3db8:	e13fe517 	ldw	r4,-108(fp)
 90b3dbc:	90b08f40 	call	90b08f4 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 90b3dc0:	e0bfed17 	ldw	r2,-76(fp)
 90b3dc4:	10c00717 	ldw	r3,28(r2)
 90b3dc8:	e0bfe717 	ldw	r2,-100(fp)
 90b3dcc:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 90b3dd0:	e0bfe717 	ldw	r2,-100(fp)
 90b3dd4:	10c00f17 	ldw	r3,60(r2)
 90b3dd8:	e0bfe717 	ldw	r2,-100(fp)
 90b3ddc:	10800e17 	ldw	r2,56(r2)
 90b3de0:	1885c83a 	sub	r2,r3,r2
 90b3de4:	1004403a 	cmpge	r2,r2,zero
 90b3de8:	1000041e 	bne	r2,zero,90b3dfc <tcp_input+0x1cac>
         tp->snd_nxt = tp->snd_una;
 90b3dec:	e0bfe717 	ldw	r2,-100(fp)
 90b3df0:	10c00e17 	ldw	r3,56(r2)
 90b3df4:	e0bfe717 	ldw	r2,-100(fp)
 90b3df8:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 90b3dfc:	e0bfe717 	ldw	r2,-100(fp)
 90b3e00:	10800217 	ldw	r2,8(r2)
 90b3e04:	e0bff215 	stw	r2,-56(fp)
 90b3e08:	e13ff217 	ldw	r4,-56(fp)
 90b3e0c:	208001e0 	cmpeqi	r2,r4,7
 90b3e10:	1000221e 	bne	r2,zero,90b3e9c <tcp_input+0x1d4c>
 90b3e14:	e0fff217 	ldw	r3,-56(fp)
 90b3e18:	18800208 	cmpgei	r2,r3,8
 90b3e1c:	1000041e 	bne	r2,zero,90b3e30 <tcp_input+0x1ce0>
 90b3e20:	e13ff217 	ldw	r4,-56(fp)
 90b3e24:	208001a0 	cmpeqi	r2,r4,6
 90b3e28:	1000081e 	bne	r2,zero,90b3e4c <tcp_input+0x1cfc>
 90b3e2c:	00003d06 	br	90b3f24 <tcp_input+0x1dd4>
 90b3e30:	e0fff217 	ldw	r3,-56(fp)
 90b3e34:	18800220 	cmpeqi	r2,r3,8
 90b3e38:	10002a1e 	bne	r2,zero,90b3ee4 <tcp_input+0x1d94>
 90b3e3c:	e13ff217 	ldw	r4,-56(fp)
 90b3e40:	208002a0 	cmpeqi	r2,r4,10
 90b3e44:	10002f1e 	bne	r2,zero,90b3f04 <tcp_input+0x1db4>
 90b3e48:	00003606 	br	90b3f24 <tcp_input+0x1dd4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 90b3e4c:	e0bfe217 	ldw	r2,-120(fp)
 90b3e50:	1005003a 	cmpeq	r2,r2,zero
 90b3e54:	1000331e 	bne	r2,zero,90b3f24 <tcp_input+0x1dd4>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 90b3e58:	e0bfe517 	ldw	r2,-108(fp)
 90b3e5c:	1080088b 	ldhu	r2,34(r2)
 90b3e60:	10bfffcc 	andi	r2,r2,65535
 90b3e64:	1080080c 	andi	r2,r2,32
 90b3e68:	1005003a 	cmpeq	r2,r2,zero
 90b3e6c:	1000071e 	bne	r2,zero,90b3e8c <tcp_input+0x1d3c>
            {
               soisdisconnected(so);
 90b3e70:	e13fe517 	ldw	r4,-108(fp)
 90b3e74:	90b03100 	call	90b0310 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 90b3e78:	00824374 	movhi	r2,2317
 90b3e7c:	108c4e04 	addi	r2,r2,12600
 90b3e80:	10c00017 	ldw	r3,0(r2)
 90b3e84:	e0bfe717 	ldw	r2,-100(fp)
 90b3e88:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 90b3e8c:	e0ffe717 	ldw	r3,-100(fp)
 90b3e90:	00800244 	movi	r2,9
 90b3e94:	18800215 	stw	r2,8(r3)
         }
         break;
 90b3e98:	00002206 	br	90b3f24 <tcp_input+0x1dd4>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 90b3e9c:	e0bfe217 	ldw	r2,-120(fp)
 90b3ea0:	1005003a 	cmpeq	r2,r2,zero
 90b3ea4:	10001f1e 	bne	r2,zero,90b3f24 <tcp_input+0x1dd4>
         {
            tp->t_state = TCPS_TIME_WAIT;
 90b3ea8:	e0ffe717 	ldw	r3,-100(fp)
 90b3eac:	00800284 	movi	r2,10
 90b3eb0:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 90b3eb4:	e13fe717 	ldw	r4,-100(fp)
 90b3eb8:	90b6d4c0 	call	90b6d4c <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b3ebc:	00824374 	movhi	r2,2317
 90b3ec0:	108bd304 	addi	r2,r2,12108
 90b3ec4:	10800017 	ldw	r2,0(r2)
 90b3ec8:	1085883a 	add	r2,r2,r2
 90b3ecc:	1007883a 	mov	r3,r2
 90b3ed0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ed4:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 90b3ed8:	e13fe517 	ldw	r4,-108(fp)
 90b3edc:	90b03100 	call	90b0310 <soisdisconnected>
         }
         break;
 90b3ee0:	00001006 	br	90b3f24 <tcp_input+0x1dd4>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 90b3ee4:	e0bfe217 	ldw	r2,-120(fp)
 90b3ee8:	1005003a 	cmpeq	r2,r2,zero
 90b3eec:	10000d1e 	bne	r2,zero,90b3f24 <tcp_input+0x1dd4>
         {
            SETTP(tp, tcp_close(tp));
 90b3ef0:	e13fe717 	ldw	r4,-100(fp)
 90b3ef4:	90b68800 	call	90b6880 <tcp_close>
            GOTO_DROP;
 90b3ef8:	00816644 	movi	r2,1433
 90b3efc:	d0a0b215 	stw	r2,-32056(gp)
 90b3f00:	0001d706 	br	90b4660 <tcp_input+0x2510>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b3f04:	00824374 	movhi	r2,2317
 90b3f08:	108bd304 	addi	r2,r2,12108
 90b3f0c:	10800017 	ldw	r2,0(r2)
 90b3f10:	1085883a 	add	r2,r2,r2
 90b3f14:	1007883a 	mov	r3,r2
 90b3f18:	e0bfe717 	ldw	r2,-100(fp)
 90b3f1c:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 90b3f20:	00017906 	br	90b4508 <tcp_input+0x23b8>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 90b3f24:	e0bfe617 	ldw	r2,-104(fp)
 90b3f28:	1080040c 	andi	r2,r2,16
 90b3f2c:	1005003a 	cmpeq	r2,r2,zero
 90b3f30:	1000471e 	bne	r2,zero,90b4050 <tcp_input+0x1f00>
 90b3f34:	e0bfe717 	ldw	r2,-100(fp)
 90b3f38:	10c01117 	ldw	r3,68(r2)
 90b3f3c:	e0bfed17 	ldw	r2,-76(fp)
 90b3f40:	10800617 	ldw	r2,24(r2)
 90b3f44:	1885c83a 	sub	r2,r3,r2
 90b3f48:	1004803a 	cmplt	r2,r2,zero
 90b3f4c:	1000151e 	bne	r2,zero,90b3fa4 <tcp_input+0x1e54>
 90b3f50:	e0bfe717 	ldw	r2,-100(fp)
 90b3f54:	10c01117 	ldw	r3,68(r2)
 90b3f58:	e0bfed17 	ldw	r2,-76(fp)
 90b3f5c:	10800617 	ldw	r2,24(r2)
 90b3f60:	18803b1e 	bne	r3,r2,90b4050 <tcp_input+0x1f00>
 90b3f64:	e0bfe717 	ldw	r2,-100(fp)
 90b3f68:	10c01217 	ldw	r3,72(r2)
 90b3f6c:	e0bfed17 	ldw	r2,-76(fp)
 90b3f70:	10800717 	ldw	r2,28(r2)
 90b3f74:	1885c83a 	sub	r2,r3,r2
 90b3f78:	1004803a 	cmplt	r2,r2,zero
 90b3f7c:	1000091e 	bne	r2,zero,90b3fa4 <tcp_input+0x1e54>
 90b3f80:	e0bfe717 	ldw	r2,-100(fp)
 90b3f84:	10c01217 	ldw	r3,72(r2)
 90b3f88:	e0bfed17 	ldw	r2,-76(fp)
 90b3f8c:	10800717 	ldw	r2,28(r2)
 90b3f90:	18802f1e 	bne	r3,r2,90b4050 <tcp_input+0x1f00>
 90b3f94:	e0bfe717 	ldw	r2,-100(fp)
 90b3f98:	10c01417 	ldw	r3,80(r2)
 90b3f9c:	e0bfde17 	ldw	r2,-136(fp)
 90b3fa0:	18802b2e 	bgeu	r3,r2,90b4050 <tcp_input+0x1f00>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 90b3fa4:	e0bfed17 	ldw	r2,-76(fp)
 90b3fa8:	1080028b 	ldhu	r2,10(r2)
 90b3fac:	10bfffcc 	andi	r2,r2,65535
 90b3fb0:	1004c03a 	cmpne	r2,r2,zero
 90b3fb4:	1000101e 	bne	r2,zero,90b3ff8 <tcp_input+0x1ea8>
 90b3fb8:	e0bfe717 	ldw	r2,-100(fp)
 90b3fbc:	10c01217 	ldw	r3,72(r2)
 90b3fc0:	e0bfed17 	ldw	r2,-76(fp)
 90b3fc4:	10800717 	ldw	r2,28(r2)
 90b3fc8:	18800b1e 	bne	r3,r2,90b3ff8 <tcp_input+0x1ea8>
 90b3fcc:	e0bfe717 	ldw	r2,-100(fp)
 90b3fd0:	10c01417 	ldw	r3,80(r2)
 90b3fd4:	e0bfde17 	ldw	r2,-136(fp)
 90b3fd8:	1880072e 	bgeu	r3,r2,90b3ff8 <tcp_input+0x1ea8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 90b3fdc:	008243b4 	movhi	r2,2318
 90b3fe0:	10b58e04 	addi	r2,r2,-10696
 90b3fe4:	10802d17 	ldw	r2,180(r2)
 90b3fe8:	10c00044 	addi	r3,r2,1
 90b3fec:	008243b4 	movhi	r2,2318
 90b3ff0:	10b58e04 	addi	r2,r2,-10696
 90b3ff4:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 90b3ff8:	e0ffe717 	ldw	r3,-100(fp)
 90b3ffc:	e0bfde17 	ldw	r2,-136(fp)
 90b4000:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 90b4004:	e0bfed17 	ldw	r2,-76(fp)
 90b4008:	10c00617 	ldw	r3,24(r2)
 90b400c:	e0bfe717 	ldw	r2,-100(fp)
 90b4010:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 90b4014:	e0bfed17 	ldw	r2,-76(fp)
 90b4018:	10c00717 	ldw	r3,28(r2)
 90b401c:	e0bfe717 	ldw	r2,-100(fp)
 90b4020:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 90b4024:	e0bfe717 	ldw	r2,-100(fp)
 90b4028:	10c01417 	ldw	r3,80(r2)
 90b402c:	e0bfe717 	ldw	r2,-100(fp)
 90b4030:	10802317 	ldw	r2,140(r2)
 90b4034:	10c0042e 	bgeu	r2,r3,90b4048 <tcp_input+0x1ef8>
         tp->max_sndwnd = tp->snd_wnd;
 90b4038:	e0bfe717 	ldw	r2,-100(fp)
 90b403c:	10c01417 	ldw	r3,80(r2)
 90b4040:	e0bfe717 	ldw	r2,-100(fp)
 90b4044:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 90b4048:	00800044 	movi	r2,1
 90b404c:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 90b4050:	e0bfe617 	ldw	r2,-104(fp)
 90b4054:	1080080c 	andi	r2,r2,32
 90b4058:	1005003a 	cmpeq	r2,r2,zero
 90b405c:	10005a1e 	bne	r2,zero,90b41c8 <tcp_input+0x2078>
 90b4060:	e0bfed17 	ldw	r2,-76(fp)
 90b4064:	1080098b 	ldhu	r2,38(r2)
 90b4068:	10bfffcc 	andi	r2,r2,65535
 90b406c:	1005003a 	cmpeq	r2,r2,zero
 90b4070:	1000551e 	bne	r2,zero,90b41c8 <tcp_input+0x2078>
 90b4074:	e0bfe717 	ldw	r2,-100(fp)
 90b4078:	10800217 	ldw	r2,8(r2)
 90b407c:	10800288 	cmpgei	r2,r2,10
 90b4080:	1000511e 	bne	r2,zero,90b41c8 <tcp_input+0x2078>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 90b4084:	e0bfed17 	ldw	r2,-76(fp)
 90b4088:	1080098b 	ldhu	r2,38(r2)
 90b408c:	10ffffcc 	andi	r3,r2,65535
 90b4090:	e0bfe517 	ldw	r2,-108(fp)
 90b4094:	10800a17 	ldw	r2,40(r2)
 90b4098:	1885883a 	add	r2,r3,r2
 90b409c:	10900070 	cmpltui	r2,r2,16385
 90b40a0:	1000071e 	bne	r2,zero,90b40c0 <tcp_input+0x1f70>
      {
         ti->ti_urp = 0;         /* XXX */
 90b40a4:	e0bfed17 	ldw	r2,-76(fp)
 90b40a8:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 90b40ac:	e0ffe617 	ldw	r3,-104(fp)
 90b40b0:	00bff7c4 	movi	r2,-33
 90b40b4:	1884703a 	and	r2,r3,r2
 90b40b8:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 90b40bc:	00004d06 	br	90b41f4 <tcp_input+0x20a4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 90b40c0:	e0bfed17 	ldw	r2,-76(fp)
 90b40c4:	10c00617 	ldw	r3,24(r2)
 90b40c8:	e0bfed17 	ldw	r2,-76(fp)
 90b40cc:	1080098b 	ldhu	r2,38(r2)
 90b40d0:	10bfffcc 	andi	r2,r2,65535
 90b40d4:	1887883a 	add	r3,r3,r2
 90b40d8:	e0bfe717 	ldw	r2,-100(fp)
 90b40dc:	10801717 	ldw	r2,92(r2)
 90b40e0:	1885c83a 	sub	r2,r3,r2
 90b40e4:	10800050 	cmplti	r2,r2,1
 90b40e8:	1000261e 	bne	r2,zero,90b4184 <tcp_input+0x2034>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 90b40ec:	e0bfed17 	ldw	r2,-76(fp)
 90b40f0:	10c00617 	ldw	r3,24(r2)
 90b40f4:	e0bfed17 	ldw	r2,-76(fp)
 90b40f8:	1080098b 	ldhu	r2,38(r2)
 90b40fc:	10bfffcc 	andi	r2,r2,65535
 90b4100:	1887883a 	add	r3,r3,r2
 90b4104:	e0bfe717 	ldw	r2,-100(fp)
 90b4108:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 90b410c:	e0bfe517 	ldw	r2,-108(fp)
 90b4110:	11000a17 	ldw	r4,40(r2)
 90b4114:	e0bfe717 	ldw	r2,-100(fp)
 90b4118:	10c01717 	ldw	r3,92(r2)
 90b411c:	e0bfe717 	ldw	r2,-100(fp)
 90b4120:	10801617 	ldw	r2,88(r2)
 90b4124:	1885c83a 	sub	r2,r3,r2
 90b4128:	2085883a 	add	r2,r4,r2
 90b412c:	10ffffc4 	addi	r3,r2,-1
 90b4130:	e0bfe517 	ldw	r2,-108(fp)
 90b4134:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 90b4138:	e0bfe517 	ldw	r2,-108(fp)
 90b413c:	10801a17 	ldw	r2,104(r2)
 90b4140:	1004c03a 	cmpne	r2,r2,zero
 90b4144:	1000061e 	bne	r2,zero,90b4160 <tcp_input+0x2010>
            so->so_state |= SS_RCVATMARK;
 90b4148:	e0bfe517 	ldw	r2,-108(fp)
 90b414c:	1080088b 	ldhu	r2,34(r2)
 90b4150:	10801014 	ori	r2,r2,64
 90b4154:	1007883a 	mov	r3,r2
 90b4158:	e0bfe517 	ldw	r2,-108(fp)
 90b415c:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 90b4160:	e13fe517 	ldw	r4,-108(fp)
 90b4164:	90b00d80 	call	90b00d8 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 90b4168:	e0bfe717 	ldw	r2,-100(fp)
 90b416c:	10c02403 	ldbu	r3,144(r2)
 90b4170:	00bfff04 	movi	r2,-4
 90b4174:	1884703a 	and	r2,r3,r2
 90b4178:	1007883a 	mov	r3,r2
 90b417c:	e0bfe717 	ldw	r2,-100(fp)
 90b4180:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 90b4184:	e0bfed17 	ldw	r2,-76(fp)
 90b4188:	10c0098b 	ldhu	r3,38(r2)
 90b418c:	e0bfed17 	ldw	r2,-76(fp)
 90b4190:	1080028b 	ldhu	r2,10(r2)
 90b4194:	18ffffcc 	andi	r3,r3,65535
 90b4198:	10bfffcc 	andi	r2,r2,65535
 90b419c:	10c01536 	bltu	r2,r3,90b41f4 <tcp_input+0x20a4>
 90b41a0:	e0bfe517 	ldw	r2,-108(fp)
 90b41a4:	10800417 	ldw	r2,16(r2)
 90b41a8:	1080400c 	andi	r2,r2,256
 90b41ac:	1004c03a 	cmpne	r2,r2,zero
 90b41b0:	1000101e 	bne	r2,zero,90b41f4 <tcp_input+0x20a4>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 90b41b4:	e13fe517 	ldw	r4,-108(fp)
 90b41b8:	e17fed17 	ldw	r5,-76(fp)
 90b41bc:	e1bff017 	ldw	r6,-64(fp)
 90b41c0:	90b48340 	call	90b4834 <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 90b41c4:	00000b06 	br	90b41f4 <tcp_input+0x20a4>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 90b41c8:	e0bfe717 	ldw	r2,-100(fp)
 90b41cc:	10c01617 	ldw	r3,88(r2)
 90b41d0:	e0bfe717 	ldw	r2,-100(fp)
 90b41d4:	10801717 	ldw	r2,92(r2)
 90b41d8:	1885c83a 	sub	r2,r3,r2
 90b41dc:	10800050 	cmplti	r2,r2,1
 90b41e0:	1000041e 	bne	r2,zero,90b41f4 <tcp_input+0x20a4>
      tp->rcv_up = tp->rcv_nxt;
 90b41e4:	e0bfe717 	ldw	r2,-100(fp)
 90b41e8:	10c01617 	ldw	r3,88(r2)
 90b41ec:	e0bfe717 	ldw	r2,-100(fp)
 90b41f0:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 90b41f4:	e0bfed17 	ldw	r2,-76(fp)
 90b41f8:	1080028b 	ldhu	r2,10(r2)
 90b41fc:	10bfffcc 	andi	r2,r2,65535
 90b4200:	1004c03a 	cmpne	r2,r2,zero
 90b4204:	1000051e 	bne	r2,zero,90b421c <tcp_input+0x20cc>
 90b4208:	e0bfe617 	ldw	r2,-104(fp)
 90b420c:	1080004c 	andi	r2,r2,1
 90b4210:	10803fcc 	andi	r2,r2,255
 90b4214:	1005003a 	cmpeq	r2,r2,zero
 90b4218:	10005c1e 	bne	r2,zero,90b438c <tcp_input+0x223c>
 90b421c:	e0bfe717 	ldw	r2,-100(fp)
 90b4220:	10800217 	ldw	r2,8(r2)
 90b4224:	10800288 	cmpgei	r2,r2,10
 90b4228:	1000581e 	bne	r2,zero,90b438c <tcp_input+0x223c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 90b422c:	e0bfed17 	ldw	r2,-76(fp)
 90b4230:	10c00617 	ldw	r3,24(r2)
 90b4234:	e0bfe717 	ldw	r2,-100(fp)
 90b4238:	10801617 	ldw	r2,88(r2)
 90b423c:	1880351e 	bne	r3,r2,90b4314 <tcp_input+0x21c4>
 90b4240:	e0bfe717 	ldw	r2,-100(fp)
 90b4244:	10c00017 	ldw	r3,0(r2)
 90b4248:	e0bfe717 	ldw	r2,-100(fp)
 90b424c:	1880311e 	bne	r3,r2,90b4314 <tcp_input+0x21c4>
 90b4250:	e0bfe717 	ldw	r2,-100(fp)
 90b4254:	10800217 	ldw	r2,8(r2)
 90b4258:	10800118 	cmpnei	r2,r2,4
 90b425c:	10002d1e 	bne	r2,zero,90b4314 <tcp_input+0x21c4>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 90b4260:	e0bfe717 	ldw	r2,-100(fp)
 90b4264:	10800b0b 	ldhu	r2,44(r2)
 90b4268:	10800054 	ori	r2,r2,1
 90b426c:	1007883a 	mov	r3,r2
 90b4270:	e0bfe717 	ldw	r2,-100(fp)
 90b4274:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 90b4278:	e0bfe717 	ldw	r2,-100(fp)
 90b427c:	10c01617 	ldw	r3,88(r2)
 90b4280:	e0bfed17 	ldw	r2,-76(fp)
 90b4284:	1080028b 	ldhu	r2,10(r2)
 90b4288:	10bfffcc 	andi	r2,r2,65535
 90b428c:	1887883a 	add	r3,r3,r2
 90b4290:	e0bfe717 	ldw	r2,-100(fp)
 90b4294:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 90b4298:	e0bfed17 	ldw	r2,-76(fp)
 90b429c:	10800843 	ldbu	r2,33(r2)
 90b42a0:	10803fcc 	andi	r2,r2,255
 90b42a4:	1080004c 	andi	r2,r2,1
 90b42a8:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 90b42ac:	008243b4 	movhi	r2,2318
 90b42b0:	10b58e04 	addi	r2,r2,-10696
 90b42b4:	10801a17 	ldw	r2,104(r2)
 90b42b8:	10c00044 	addi	r3,r2,1
 90b42bc:	008243b4 	movhi	r2,2318
 90b42c0:	10b58e04 	addi	r2,r2,-10696
 90b42c4:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 90b42c8:	008243b4 	movhi	r2,2318
 90b42cc:	10b58e04 	addi	r2,r2,-10696
 90b42d0:	10c01b17 	ldw	r3,108(r2)
 90b42d4:	e0bfed17 	ldw	r2,-76(fp)
 90b42d8:	1080028b 	ldhu	r2,10(r2)
 90b42dc:	10bfffcc 	andi	r2,r2,65535
 90b42e0:	1887883a 	add	r3,r3,r2
 90b42e4:	008243b4 	movhi	r2,2318
 90b42e8:	10b58e04 	addi	r2,r2,-10696
 90b42ec:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 90b42f0:	e0bfe517 	ldw	r2,-108(fp)
 90b42f4:	11000a04 	addi	r4,r2,40
 90b42f8:	e17ff017 	ldw	r5,-64(fp)
 90b42fc:	90b0ab80 	call	90b0ab8 <sbappend>
         sorwakeup(so);
 90b4300:	e0bfe517 	ldw	r2,-108(fp)
 90b4304:	11400a04 	addi	r5,r2,40
 90b4308:	e13fe517 	ldw	r4,-108(fp)
 90b430c:	90b08f40 	call	90b08f4 <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 90b4310:	00000b06 	br	90b4340 <tcp_input+0x21f0>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 90b4314:	e13fe717 	ldw	r4,-100(fp)
 90b4318:	e17fed17 	ldw	r5,-76(fp)
 90b431c:	e1bff017 	ldw	r6,-64(fp)
 90b4320:	90b1d480 	call	90b1d48 <tcp_reass>
 90b4324:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 90b4328:	e0bfe717 	ldw	r2,-100(fp)
 90b432c:	10800b0b 	ldhu	r2,44(r2)
 90b4330:	10800054 	ori	r2,r2,1
 90b4334:	1007883a 	mov	r3,r2
 90b4338:	e0bfe717 	ldw	r2,-100(fp)
 90b433c:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 90b4340:	e0bfe517 	ldw	r2,-108(fp)
 90b4344:	11000b17 	ldw	r4,44(r2)
 90b4348:	e0bfe717 	ldw	r2,-100(fp)
 90b434c:	10c01917 	ldw	r3,100(r2)
 90b4350:	e0bfe717 	ldw	r2,-100(fp)
 90b4354:	10801617 	ldw	r2,88(r2)
 90b4358:	1885c83a 	sub	r2,r3,r2
 90b435c:	2085c83a 	sub	r2,r4,r2
 90b4360:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 90b4364:	e0bfe717 	ldw	r2,-100(fp)
 90b4368:	10802217 	ldw	r2,136(r2)
 90b436c:	1007883a 	mov	r3,r2
 90b4370:	e0bfea17 	ldw	r2,-88(fp)
 90b4374:	18800b0e 	bge	r3,r2,90b43a4 <tcp_input+0x2254>
         tp->max_rcvd = (u_short)len;
 90b4378:	e0bfea17 	ldw	r2,-88(fp)
 90b437c:	10ffffcc 	andi	r3,r2,65535
 90b4380:	e0bfe717 	ldw	r2,-100(fp)
 90b4384:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 90b4388:	00000606 	br	90b43a4 <tcp_input+0x2254>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 90b438c:	e13ff017 	ldw	r4,-64(fp)
 90b4390:	90aa5a40 	call	90aa5a4 <m_freem>
      tiflags &= ~TH_FIN;
 90b4394:	e0bfe617 	ldw	r2,-104(fp)
 90b4398:	00ffff84 	movi	r3,-2
 90b439c:	10c4703a 	and	r2,r2,r3
 90b43a0:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 90b43a4:	e0bfe617 	ldw	r2,-104(fp)
 90b43a8:	1080004c 	andi	r2,r2,1
 90b43ac:	10803fcc 	andi	r2,r2,255
 90b43b0:	1005003a 	cmpeq	r2,r2,zero
 90b43b4:	1000471e 	bne	r2,zero,90b44d4 <tcp_input+0x2384>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 90b43b8:	e0bfe717 	ldw	r2,-100(fp)
 90b43bc:	10800217 	ldw	r2,8(r2)
 90b43c0:	10800288 	cmpgei	r2,r2,10
 90b43c4:	10000d1e 	bne	r2,zero,90b43fc <tcp_input+0x22ac>
      {
         socantrcvmore(so);
 90b43c8:	e13fe517 	ldw	r4,-108(fp)
 90b43cc:	90b08040 	call	90b0804 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 90b43d0:	e0bfe717 	ldw	r2,-100(fp)
 90b43d4:	10800b0b 	ldhu	r2,44(r2)
 90b43d8:	10800054 	ori	r2,r2,1
 90b43dc:	1007883a 	mov	r3,r2
 90b43e0:	e0bfe717 	ldw	r2,-100(fp)
 90b43e4:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 90b43e8:	e0bfe717 	ldw	r2,-100(fp)
 90b43ec:	10801617 	ldw	r2,88(r2)
 90b43f0:	10c00044 	addi	r3,r2,1
 90b43f4:	e0bfe717 	ldw	r2,-100(fp)
 90b43f8:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 90b43fc:	e0bfe717 	ldw	r2,-100(fp)
 90b4400:	10800217 	ldw	r2,8(r2)
 90b4404:	10bfff44 	addi	r2,r2,-3
 90b4408:	e0bfff15 	stw	r2,-4(fp)
 90b440c:	e0ffff17 	ldw	r3,-4(fp)
 90b4410:	18800228 	cmpgeui	r2,r3,8
 90b4414:	10002f1e 	bne	r2,zero,90b44d4 <tcp_input+0x2384>
 90b4418:	e13fff17 	ldw	r4,-4(fp)
 90b441c:	e13fff17 	ldw	r4,-4(fp)
 90b4420:	2105883a 	add	r2,r4,r4
 90b4424:	1087883a 	add	r3,r2,r2
 90b4428:	008242f4 	movhi	r2,2315
 90b442c:	10910f04 	addi	r2,r2,17468
 90b4430:	1885883a 	add	r2,r3,r2
 90b4434:	10800017 	ldw	r2,0(r2)
 90b4438:	1000683a 	jmp	r2
 90b443c:	090b445c 	xori	r4,at,11537
 90b4440:	090b445c 	xori	r4,at,11537
 90b4444:	090b44d4 	ori	r4,at,11539
 90b4448:	090b446c 	andhi	r4,at,11537
 90b444c:	090b44d4 	ori	r4,at,11539
 90b4450:	090b44d4 	ori	r4,at,11539
 90b4454:	090b447c 	xorhi	r4,at,11537
 90b4458:	090b44b8 	rdprs	r4,at,11538
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 90b445c:	e0ffe717 	ldw	r3,-100(fp)
 90b4460:	00800144 	movi	r2,5
 90b4464:	18800215 	stw	r2,8(r3)
         break;
 90b4468:	00001a06 	br	90b44d4 <tcp_input+0x2384>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 90b446c:	e0ffe717 	ldw	r3,-100(fp)
 90b4470:	008001c4 	movi	r2,7
 90b4474:	18800215 	stw	r2,8(r3)
         break;
 90b4478:	00001606 	br	90b44d4 <tcp_input+0x2384>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 90b447c:	e0ffe717 	ldw	r3,-100(fp)
 90b4480:	00800284 	movi	r2,10
 90b4484:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 90b4488:	e13fe717 	ldw	r4,-100(fp)
 90b448c:	90b6d4c0 	call	90b6d4c <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b4490:	00824374 	movhi	r2,2317
 90b4494:	108bd304 	addi	r2,r2,12108
 90b4498:	10800017 	ldw	r2,0(r2)
 90b449c:	1085883a 	add	r2,r2,r2
 90b44a0:	1007883a 	mov	r3,r2
 90b44a4:	e0bfe717 	ldw	r2,-100(fp)
 90b44a8:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 90b44ac:	e13fe517 	ldw	r4,-108(fp)
 90b44b0:	90b03100 	call	90b0310 <soisdisconnected>
         break;
 90b44b4:	00000706 	br	90b44d4 <tcp_input+0x2384>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b44b8:	00824374 	movhi	r2,2317
 90b44bc:	108bd304 	addi	r2,r2,12108
 90b44c0:	10800017 	ldw	r2,0(r2)
 90b44c4:	1085883a 	add	r2,r2,r2
 90b44c8:	1007883a 	mov	r3,r2
 90b44cc:	e0bfe717 	ldw	r2,-100(fp)
 90b44d0:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 90b44d4:	e0bfe117 	ldw	r2,-124(fp)
 90b44d8:	1004c03a 	cmpne	r2,r2,zero
 90b44dc:	1000071e 	bne	r2,zero,90b44fc <tcp_input+0x23ac>
 90b44e0:	e0bfe717 	ldw	r2,-100(fp)
 90b44e4:	10800b0b 	ldhu	r2,44(r2)
 90b44e8:	10bfffcc 	andi	r2,r2,65535
 90b44ec:	1080004c 	andi	r2,r2,1
 90b44f0:	10803fcc 	andi	r2,r2,255
 90b44f4:	1005003a 	cmpeq	r2,r2,zero
 90b44f8:	1000651e 	bne	r2,zero,90b4690 <tcp_input+0x2540>
      (void) tcp_output(tp);
 90b44fc:	e13fe717 	ldw	r4,-100(fp)
 90b4500:	90b4d640 	call	90b4d64 <tcp_output>
   return;
 90b4504:	00006206 	br	90b4690 <tcp_input+0x2540>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 90b4508:	e0bfe617 	ldw	r2,-104(fp)
 90b450c:	1080010c 	andi	r2,r2,4
 90b4510:	1005003a 	cmpeq	r2,r2,zero
 90b4514:	1000031e 	bne	r2,zero,90b4524 <tcp_input+0x23d4>
      GOTO_DROP;
 90b4518:	0081a904 	movi	r2,1700
 90b451c:	d0a0b215 	stw	r2,-32056(gp)
 90b4520:	00004f06 	br	90b4660 <tcp_input+0x2510>
   m_freem (m);
 90b4524:	e13ff017 	ldw	r4,-64(fp)
 90b4528:	90aa5a40 	call	90aa5a4 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 90b452c:	e0bfe717 	ldw	r2,-100(fp)
 90b4530:	10800b0b 	ldhu	r2,44(r2)
 90b4534:	10800054 	ori	r2,r2,1
 90b4538:	1007883a 	mov	r3,r2
 90b453c:	e0bfe717 	ldw	r2,-100(fp)
 90b4540:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 90b4544:	e13fe717 	ldw	r4,-100(fp)
 90b4548:	90b4d640 	call	90b4d64 <tcp_output>
   return;
 90b454c:	00005006 	br	90b4690 <tcp_input+0x2540>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 90b4550:	008243b4 	movhi	r2,2318
 90b4554:	10b56004 	addi	r2,r2,-10880
 90b4558:	10800d17 	ldw	r2,52(r2)
 90b455c:	10c00044 	addi	r3,r2,1
 90b4560:	008243b4 	movhi	r2,2318
 90b4564:	10b56004 	addi	r2,r2,-10880
 90b4568:	10c00d15 	stw	r3,52(r2)
   if (om) 
 90b456c:	e0bfeb17 	ldw	r2,-84(fp)
 90b4570:	1005003a 	cmpeq	r2,r2,zero
 90b4574:	1000031e 	bne	r2,zero,90b4584 <tcp_input+0x2434>
   {
      (void) m_free(om);
 90b4578:	e13feb17 	ldw	r4,-84(fp)
 90b457c:	90aa4700 	call	90aa470 <m_free>
      om = 0;
 90b4580:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 90b4584:	e0bfe617 	ldw	r2,-104(fp)
 90b4588:	1080010c 	andi	r2,r2,4
 90b458c:	1005003a 	cmpeq	r2,r2,zero
 90b4590:	1000031e 	bne	r2,zero,90b45a0 <tcp_input+0x2450>
      GOTO_DROP;
 90b4594:	0081ad04 	movi	r2,1716
 90b4598:	d0a0b215 	stw	r2,-32056(gp)
 90b459c:	00003006 	br	90b4660 <tcp_input+0x2510>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 90b45a0:	e0bfed17 	ldw	r2,-76(fp)
 90b45a4:	11000417 	ldw	r4,16(r2)
 90b45a8:	90ab5d00 	call	90ab5d0 <in_broadcast>
 90b45ac:	1005003a 	cmpeq	r2,r2,zero
 90b45b0:	1000031e 	bne	r2,zero,90b45c0 <tcp_input+0x2470>
      GOTO_DROP;
 90b45b4:	0081af44 	movi	r2,1725
 90b45b8:	d0a0b215 	stw	r2,-32056(gp)
 90b45bc:	00002806 	br	90b4660 <tcp_input+0x2510>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 90b45c0:	e0bfe617 	ldw	r2,-104(fp)
 90b45c4:	1080040c 	andi	r2,r2,16
 90b45c8:	1005003a 	cmpeq	r2,r2,zero
 90b45cc:	10000b1e 	bne	r2,zero,90b45fc <tcp_input+0x24ac>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 90b45d0:	e0bfed17 	ldw	r2,-76(fp)
 90b45d4:	11c00717 	ldw	r7,28(r2)
 90b45d8:	00800104 	movi	r2,4
 90b45dc:	d8800015 	stw	r2,0(sp)
 90b45e0:	e0bff017 	ldw	r2,-64(fp)
 90b45e4:	d8800115 	stw	r2,4(sp)
 90b45e8:	e13fe717 	ldw	r4,-100(fp)
 90b45ec:	e17fed17 	ldw	r5,-76(fp)
 90b45f0:	000d883a 	mov	r6,zero
 90b45f4:	90b62340 	call	90b6234 <tcp_respond>
 90b45f8:	00001306 	br	90b4648 <tcp_input+0x24f8>
   else
   {
      if (tiflags & TH_SYN)
 90b45fc:	e0bfe617 	ldw	r2,-104(fp)
 90b4600:	1080008c 	andi	r2,r2,2
 90b4604:	1005003a 	cmpeq	r2,r2,zero
 90b4608:	1000051e 	bne	r2,zero,90b4620 <tcp_input+0x24d0>
         ti->ti_seq++;
 90b460c:	e0bfed17 	ldw	r2,-76(fp)
 90b4610:	10800617 	ldw	r2,24(r2)
 90b4614:	10c00044 	addi	r3,r2,1
 90b4618:	e0bfed17 	ldw	r2,-76(fp)
 90b461c:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 90b4620:	e0bfed17 	ldw	r2,-76(fp)
 90b4624:	11800617 	ldw	r6,24(r2)
 90b4628:	00800504 	movi	r2,20
 90b462c:	d8800015 	stw	r2,0(sp)
 90b4630:	e0bff017 	ldw	r2,-64(fp)
 90b4634:	d8800115 	stw	r2,4(sp)
 90b4638:	e13fe717 	ldw	r4,-100(fp)
 90b463c:	e17fed17 	ldw	r5,-76(fp)
 90b4640:	000f883a 	mov	r7,zero
 90b4644:	90b62340 	call	90b6234 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 90b4648:	e0bfe017 	ldw	r2,-128(fp)
 90b464c:	1005003a 	cmpeq	r2,r2,zero
 90b4650:	10000f1e 	bne	r2,zero,90b4690 <tcp_input+0x2540>
      (void) soabort(so);
 90b4654:	e13fe517 	ldw	r4,-108(fp)
 90b4658:	90ae4e40 	call	90ae4e4 <soabort>
   return;
 90b465c:	00000c06 	br	90b4690 <tcp_input+0x2540>

drop:
   if (om)
 90b4660:	e0bfeb17 	ldw	r2,-84(fp)
 90b4664:	1005003a 	cmpeq	r2,r2,zero
 90b4668:	1000021e 	bne	r2,zero,90b4674 <tcp_input+0x2524>
      (void) m_free(om);
 90b466c:	e13feb17 	ldw	r4,-84(fp)
 90b4670:	90aa4700 	call	90aa470 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 90b4674:	e13ff017 	ldw	r4,-64(fp)
 90b4678:	90aa5a40 	call	90aa5a4 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 90b467c:	e0bfe017 	ldw	r2,-128(fp)
 90b4680:	1005003a 	cmpeq	r2,r2,zero
 90b4684:	1000021e 	bne	r2,zero,90b4690 <tcp_input+0x2540>
      (void) soabort(so);
 90b4688:	e13fe517 	ldw	r4,-108(fp)
 90b468c:	90ae4e40 	call	90ae4e4 <soabort>
   return;
}
 90b4690:	e037883a 	mov	sp,fp
 90b4694:	dfc00117 	ldw	ra,4(sp)
 90b4698:	df000017 	ldw	fp,0(sp)
 90b469c:	dec00204 	addi	sp,sp,8
 90b46a0:	f800283a 	ret

090b46a4 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 90b46a4:	defff404 	addi	sp,sp,-48
 90b46a8:	dfc00b15 	stw	ra,44(sp)
 90b46ac:	df000a15 	stw	fp,40(sp)
 90b46b0:	df000a04 	addi	fp,sp,40
 90b46b4:	e13ffc15 	stw	r4,-16(fp)
 90b46b8:	e17ffd15 	stw	r5,-12(fp)
 90b46bc:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 90b46c0:	e0bffc17 	ldw	r2,-16(fp)
 90b46c4:	10800d17 	ldw	r2,52(r2)
 90b46c8:	10800817 	ldw	r2,32(r2)
 90b46cc:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 90b46d0:	e0bffd17 	ldw	r2,-12(fp)
 90b46d4:	10800317 	ldw	r2,12(r2)
 90b46d8:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 90b46dc:	e0bffd17 	ldw	r2,-12(fp)
 90b46e0:	10800217 	ldw	r2,8(r2)
 90b46e4:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 90b46e8:	00004806 	br	90b480c <tcp_dooptions+0x168>
   {
      opt = cp[0];
 90b46ec:	e0bffb17 	ldw	r2,-20(fp)
 90b46f0:	10800003 	ldbu	r2,0(r2)
 90b46f4:	10803fcc 	andi	r2,r2,255
 90b46f8:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 90b46fc:	e0bffa17 	ldw	r2,-24(fp)
 90b4700:	1005003a 	cmpeq	r2,r2,zero
 90b4704:	1000441e 	bne	r2,zero,90b4818 <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 90b4708:	e0bffa17 	ldw	r2,-24(fp)
 90b470c:	10800058 	cmpnei	r2,r2,1
 90b4710:	1000031e 	bne	r2,zero,90b4720 <tcp_dooptions+0x7c>
         optlen = 1;
 90b4714:	00800044 	movi	r2,1
 90b4718:	e0bff915 	stw	r2,-28(fp)
 90b471c:	00000806 	br	90b4740 <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 90b4720:	e0bffb17 	ldw	r2,-20(fp)
 90b4724:	10800044 	addi	r2,r2,1
 90b4728:	10800003 	ldbu	r2,0(r2)
 90b472c:	10803fcc 	andi	r2,r2,255
 90b4730:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 90b4734:	e0bff917 	ldw	r2,-28(fp)
 90b4738:	10800050 	cmplti	r2,r2,1
 90b473c:	1000361e 	bne	r2,zero,90b4818 <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 90b4740:	e0bffa17 	ldw	r2,-24(fp)
 90b4744:	108000a0 	cmpeqi	r2,r2,2
 90b4748:	1000011e 	bne	r2,zero,90b4750 <tcp_dooptions+0xac>
 90b474c:	00002606 	br	90b47e8 <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 90b4750:	e0bff917 	ldw	r2,-28(fp)
 90b4754:	10800118 	cmpnei	r2,r2,4
 90b4758:	1000231e 	bne	r2,zero,90b47e8 <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 90b475c:	e0bffe17 	ldw	r2,-8(fp)
 90b4760:	10800843 	ldbu	r2,33(r2)
 90b4764:	10803fcc 	andi	r2,r2,255
 90b4768:	1080008c 	andi	r2,r2,2
 90b476c:	1005003a 	cmpeq	r2,r2,zero
 90b4770:	10001d1e 	bne	r2,zero,90b47e8 <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 90b4774:	e0bffb17 	ldw	r2,-20(fp)
 90b4778:	10800084 	addi	r2,r2,2
 90b477c:	1080000b 	ldhu	r2,0(r2)
 90b4780:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 90b4784:	e0bff60b 	ldhu	r2,-40(fp)
 90b4788:	1004d23a 	srli	r2,r2,8
 90b478c:	10803fcc 	andi	r2,r2,255
 90b4790:	1009883a 	mov	r4,r2
 90b4794:	e0bff60b 	ldhu	r2,-40(fp)
 90b4798:	1004923a 	slli	r2,r2,8
 90b479c:	1007883a 	mov	r3,r2
 90b47a0:	00bfc004 	movi	r2,-256
 90b47a4:	1884703a 	and	r2,r3,r2
 90b47a8:	2084b03a 	or	r2,r4,r2
 90b47ac:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 90b47b0:	e13ff717 	ldw	r4,-36(fp)
 90b47b4:	90b4c480 	call	90b4c48 <tcp_mss>
 90b47b8:	10ffffcc 	andi	r3,r2,65535
 90b47bc:	e0bff60b 	ldhu	r2,-40(fp)
 90b47c0:	1880042e 	bgeu	r3,r2,90b47d4 <tcp_dooptions+0x130>
 90b47c4:	e13ff717 	ldw	r4,-36(fp)
 90b47c8:	90b4c480 	call	90b4c48 <tcp_mss>
 90b47cc:	e0bfff0d 	sth	r2,-4(fp)
 90b47d0:	00000206 	br	90b47dc <tcp_dooptions+0x138>
 90b47d4:	e0bff60b 	ldhu	r2,-40(fp)
 90b47d8:	e0bfff0d 	sth	r2,-4(fp)
 90b47dc:	e0bffc17 	ldw	r2,-16(fp)
 90b47e0:	e0ffff0b 	ldhu	r3,-4(fp)
 90b47e4:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 90b47e8:	e0fff817 	ldw	r3,-32(fp)
 90b47ec:	e0bff917 	ldw	r2,-28(fp)
 90b47f0:	1885c83a 	sub	r2,r3,r2
 90b47f4:	e0bff815 	stw	r2,-32(fp)
 90b47f8:	e0bff917 	ldw	r2,-28(fp)
 90b47fc:	1007883a 	mov	r3,r2
 90b4800:	e0bffb17 	ldw	r2,-20(fp)
 90b4804:	10c5883a 	add	r2,r2,r3
 90b4808:	e0bffb15 	stw	r2,-20(fp)
 90b480c:	e0bff817 	ldw	r2,-32(fp)
 90b4810:	10800048 	cmpgei	r2,r2,1
 90b4814:	103fb51e 	bne	r2,zero,90b46ec <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 90b4818:	e13ffd17 	ldw	r4,-12(fp)
 90b481c:	90aa4700 	call	90aa470 <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 90b4820:	e037883a 	mov	sp,fp
 90b4824:	dfc00117 	ldw	ra,4(sp)
 90b4828:	df000017 	ldw	fp,0(sp)
 90b482c:	dec00204 	addi	sp,sp,8
 90b4830:	f800283a 	ret

090b4834 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 90b4834:	defff804 	addi	sp,sp,-32
 90b4838:	dfc00715 	stw	ra,28(sp)
 90b483c:	df000615 	stw	fp,24(sp)
 90b4840:	df000604 	addi	fp,sp,24
 90b4844:	e13ffd15 	stw	r4,-12(fp)
 90b4848:	e17ffe15 	stw	r5,-8(fp)
 90b484c:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 90b4850:	e0bffe17 	ldw	r2,-8(fp)
 90b4854:	1080098b 	ldhu	r2,38(r2)
 90b4858:	10bfffcc 	andi	r2,r2,65535
 90b485c:	10bfffc4 	addi	r2,r2,-1
 90b4860:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 90b4864:	00003306 	br	90b4934 <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 90b4868:	e0bfff17 	ldw	r2,-4(fp)
 90b486c:	10c00217 	ldw	r3,8(r2)
 90b4870:	e0bffc17 	ldw	r2,-16(fp)
 90b4874:	10c0242e 	bgeu	r2,r3,90b4908 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 90b4878:	e0bfff17 	ldw	r2,-4(fp)
 90b487c:	10c00317 	ldw	r3,12(r2)
 90b4880:	e0bffc17 	ldw	r2,-16(fp)
 90b4884:	1885883a 	add	r2,r3,r2
 90b4888:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 90b488c:	e0bffd17 	ldw	r2,-12(fp)
 90b4890:	10800117 	ldw	r2,4(r2)
 90b4894:	10800917 	ldw	r2,36(r2)
 90b4898:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 90b489c:	e0bffb17 	ldw	r2,-20(fp)
 90b48a0:	10c00003 	ldbu	r3,0(r2)
 90b48a4:	e0bffa17 	ldw	r2,-24(fp)
 90b48a8:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 90b48ac:	e0bffa17 	ldw	r2,-24(fp)
 90b48b0:	10802403 	ldbu	r2,144(r2)
 90b48b4:	10800054 	ori	r2,r2,1
 90b48b8:	1007883a 	mov	r3,r2
 90b48bc:	e0bffa17 	ldw	r2,-24(fp)
 90b48c0:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 90b48c4:	e0bffb17 	ldw	r2,-20(fp)
 90b48c8:	11400044 	addi	r5,r2,1
 90b48cc:	e0bfff17 	ldw	r2,-4(fp)
 90b48d0:	10c00217 	ldw	r3,8(r2)
 90b48d4:	e0bffc17 	ldw	r2,-16(fp)
 90b48d8:	1885c83a 	sub	r2,r3,r2
 90b48dc:	10ffffc4 	addi	r3,r2,-1
 90b48e0:	e0bffb17 	ldw	r2,-20(fp)
 90b48e4:	1009883a 	mov	r4,r2
 90b48e8:	180d883a 	mov	r6,r3
 90b48ec:	90822780 	call	9082278 <memcpy>
         m->m_len--;
 90b48f0:	e0bfff17 	ldw	r2,-4(fp)
 90b48f4:	10800217 	ldw	r2,8(r2)
 90b48f8:	10ffffc4 	addi	r3,r2,-1
 90b48fc:	e0bfff17 	ldw	r2,-4(fp)
 90b4900:	10c00215 	stw	r3,8(r2)
         return;
 90b4904:	00001106 	br	90b494c <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 90b4908:	e0fffc17 	ldw	r3,-16(fp)
 90b490c:	e0bfff17 	ldw	r2,-4(fp)
 90b4910:	10800217 	ldw	r2,8(r2)
 90b4914:	1885c83a 	sub	r2,r3,r2
 90b4918:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 90b491c:	e0bfff17 	ldw	r2,-4(fp)
 90b4920:	10800617 	ldw	r2,24(r2)
 90b4924:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 90b4928:	e0bfff17 	ldw	r2,-4(fp)
 90b492c:	1005003a 	cmpeq	r2,r2,zero
 90b4930:	1000031e 	bne	r2,zero,90b4940 <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 90b4934:	e0bffc17 	ldw	r2,-16(fp)
 90b4938:	1004403a 	cmpge	r2,r2,zero
 90b493c:	103fca1e 	bne	r2,zero,90b4868 <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 90b4940:	01024374 	movhi	r4,2317
 90b4944:	213f8604 	addi	r4,r4,-488
 90b4948:	90a438c0 	call	90a438c <panic>
}
 90b494c:	e037883a 	mov	sp,fp
 90b4950:	dfc00117 	ldw	ra,4(sp)
 90b4954:	df000017 	ldw	fp,0(sp)
 90b4958:	dec00204 	addi	sp,sp,8
 90b495c:	f800283a 	ret

090b4960 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 90b4960:	defffb04 	addi	sp,sp,-20
 90b4964:	dfc00415 	stw	ra,16(sp)
 90b4968:	df000315 	stw	fp,12(sp)
 90b496c:	df000304 	addi	fp,sp,12
 90b4970:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 90b4974:	e0bfff17 	ldw	r2,-4(fp)
 90b4978:	10801e17 	ldw	r2,120(r2)
 90b497c:	1004c03a 	cmpne	r2,r2,zero
 90b4980:	1000021e 	bne	r2,zero,90b498c <tcp_xmit_timer+0x2c>
 90b4984:	90a94880 	call	90a9488 <dtrap>
 90b4988:	00009806 	br	90b4bec <tcp_xmit_timer+0x28c>
#endif

   tcpstat.tcps_rttupdated++;
 90b498c:	008243b4 	movhi	r2,2318
 90b4990:	10b58e04 	addi	r2,r2,-10696
 90b4994:	10800717 	ldw	r2,28(r2)
 90b4998:	10c00044 	addi	r3,r2,1
 90b499c:	008243b4 	movhi	r2,2318
 90b49a0:	10b58e04 	addi	r2,r2,-10696
 90b49a4:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 90b49a8:	00824374 	movhi	r2,2317
 90b49ac:	108c4204 	addi	r2,r2,12552
 90b49b0:	10c00017 	ldw	r3,0(r2)
 90b49b4:	e0bfff17 	ldw	r2,-4(fp)
 90b49b8:	10801e17 	ldw	r2,120(r2)
 90b49bc:	1889c83a 	sub	r4,r3,r2
 90b49c0:	908c0380 	call	908c038 <__floatunsidf>
 90b49c4:	100b883a 	mov	r5,r2
 90b49c8:	180d883a 	mov	r6,r3
 90b49cc:	2809883a 	mov	r4,r5
 90b49d0:	300b883a 	mov	r5,r6
 90b49d4:	000d883a 	mov	r6,zero
 90b49d8:	01d01274 	movhi	r7,16457
 90b49dc:	908b9680 	call	908b968 <__divdf3>
 90b49e0:	1009883a 	mov	r4,r2
 90b49e4:	180b883a 	mov	r5,r3
 90b49e8:	2005883a 	mov	r2,r4
 90b49ec:	2807883a 	mov	r3,r5
 90b49f0:	1009883a 	mov	r4,r2
 90b49f4:	180b883a 	mov	r5,r3
 90b49f8:	908bf600 	call	908bf60 <__fixdfsi>
 90b49fc:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 90b4a00:	e0bfff17 	ldw	r2,-4(fp)
 90b4a04:	10802017 	ldw	r2,128(r2)
 90b4a08:	1005003a 	cmpeq	r2,r2,zero
 90b4a0c:	10004a1e 	bne	r2,zero,90b4b38 <tcp_xmit_timer+0x1d8>
   {
      if(rtt == 0)      /* fast path for small round trip */
 90b4a10:	e0bffd17 	ldw	r2,-12(fp)
 90b4a14:	1004c03a 	cmpne	r2,r2,zero
 90b4a18:	1000131e 	bne	r2,zero,90b4a68 <tcp_xmit_timer+0x108>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 90b4a1c:	e0bfff17 	ldw	r2,-4(fp)
 90b4a20:	10802017 	ldw	r2,128(r2)
 90b4a24:	10800090 	cmplti	r2,r2,2
 90b4a28:	1000051e 	bne	r2,zero,90b4a40 <tcp_xmit_timer+0xe0>
            tp->t_srtt--;
 90b4a2c:	e0bfff17 	ldw	r2,-4(fp)
 90b4a30:	10802017 	ldw	r2,128(r2)
 90b4a34:	10ffffc4 	addi	r3,r2,-1
 90b4a38:	e0bfff17 	ldw	r2,-4(fp)
 90b4a3c:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 90b4a40:	e0bfff17 	ldw	r2,-4(fp)
 90b4a44:	10802117 	ldw	r2,132(r2)
 90b4a48:	10800090 	cmplti	r2,r2,2
 90b4a4c:	1000481e 	bne	r2,zero,90b4b70 <tcp_xmit_timer+0x210>
            tp->t_rttvar--;
 90b4a50:	e0bfff17 	ldw	r2,-4(fp)
 90b4a54:	10802117 	ldw	r2,132(r2)
 90b4a58:	10ffffc4 	addi	r3,r2,-1
 90b4a5c:	e0bfff17 	ldw	r2,-4(fp)
 90b4a60:	10c02115 	stw	r3,132(r2)
 90b4a64:	00004206 	br	90b4b70 <tcp_xmit_timer+0x210>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 90b4a68:	e0bffd17 	ldw	r2,-12(fp)
 90b4a6c:	10bfffc4 	addi	r2,r2,-1
 90b4a70:	1085883a 	add	r2,r2,r2
 90b4a74:	1085883a 	add	r2,r2,r2
 90b4a78:	1007883a 	mov	r3,r2
 90b4a7c:	e0bfff17 	ldw	r2,-4(fp)
 90b4a80:	10802017 	ldw	r2,128(r2)
 90b4a84:	1005d0fa 	srai	r2,r2,3
 90b4a88:	1885c83a 	sub	r2,r3,r2
 90b4a8c:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 90b4a90:	e0bfff17 	ldw	r2,-4(fp)
 90b4a94:	10c02017 	ldw	r3,128(r2)
 90b4a98:	e0bffe17 	ldw	r2,-8(fp)
 90b4a9c:	1887883a 	add	r3,r3,r2
 90b4aa0:	e0bfff17 	ldw	r2,-4(fp)
 90b4aa4:	10c02015 	stw	r3,128(r2)
 90b4aa8:	e0bfff17 	ldw	r2,-4(fp)
 90b4aac:	10802017 	ldw	r2,128(r2)
 90b4ab0:	10800048 	cmpgei	r2,r2,1
 90b4ab4:	1000031e 	bne	r2,zero,90b4ac4 <tcp_xmit_timer+0x164>
         tp->t_srtt = 1;
 90b4ab8:	e0ffff17 	ldw	r3,-4(fp)
 90b4abc:	00800044 	movi	r2,1
 90b4ac0:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 90b4ac4:	e0bffe17 	ldw	r2,-8(fp)
 90b4ac8:	1004403a 	cmpge	r2,r2,zero
 90b4acc:	1000031e 	bne	r2,zero,90b4adc <tcp_xmit_timer+0x17c>
         delta = -delta;
 90b4ad0:	e0bffe17 	ldw	r2,-8(fp)
 90b4ad4:	0085c83a 	sub	r2,zero,r2
 90b4ad8:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 90b4adc:	e0bfff17 	ldw	r2,-4(fp)
 90b4ae0:	10802117 	ldw	r2,132(r2)
 90b4ae4:	1005d07a 	srai	r2,r2,1
 90b4ae8:	10ffffcc 	andi	r3,r2,65535
 90b4aec:	18e0001c 	xori	r3,r3,32768
 90b4af0:	18e00004 	addi	r3,r3,-32768
 90b4af4:	e0bffe17 	ldw	r2,-8(fp)
 90b4af8:	10c5c83a 	sub	r2,r2,r3
 90b4afc:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 90b4b00:	e0bfff17 	ldw	r2,-4(fp)
 90b4b04:	10c02117 	ldw	r3,132(r2)
 90b4b08:	e0bffe17 	ldw	r2,-8(fp)
 90b4b0c:	1887883a 	add	r3,r3,r2
 90b4b10:	e0bfff17 	ldw	r2,-4(fp)
 90b4b14:	10c02115 	stw	r3,132(r2)
 90b4b18:	e0bfff17 	ldw	r2,-4(fp)
 90b4b1c:	10802117 	ldw	r2,132(r2)
 90b4b20:	10800048 	cmpgei	r2,r2,1
 90b4b24:	1000121e 	bne	r2,zero,90b4b70 <tcp_xmit_timer+0x210>
         tp->t_rttvar = 1;
 90b4b28:	e0ffff17 	ldw	r3,-4(fp)
 90b4b2c:	00800044 	movi	r2,1
 90b4b30:	18802115 	stw	r2,132(r3)
 90b4b34:	00000e06 	br	90b4b70 <tcp_xmit_timer+0x210>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 90b4b38:	e0bffd17 	ldw	r2,-12(fp)
 90b4b3c:	10800048 	cmpgei	r2,r2,1
 90b4b40:	1000021e 	bne	r2,zero,90b4b4c <tcp_xmit_timer+0x1ec>
         rtt = 1;
 90b4b44:	00800044 	movi	r2,1
 90b4b48:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 90b4b4c:	e0bffd17 	ldw	r2,-12(fp)
 90b4b50:	100690fa 	slli	r3,r2,3
 90b4b54:	e0bfff17 	ldw	r2,-4(fp)
 90b4b58:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 90b4b5c:	e0bffd17 	ldw	r2,-12(fp)
 90b4b60:	1085883a 	add	r2,r2,r2
 90b4b64:	1007883a 	mov	r3,r2
 90b4b68:	e0bfff17 	ldw	r2,-4(fp)
 90b4b6c:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 90b4b70:	e0bfff17 	ldw	r2,-4(fp)
 90b4b74:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 90b4b78:	e0bfff17 	ldw	r2,-4(fp)
 90b4b7c:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 90b4b80:	e0bfff17 	ldw	r2,-4(fp)
 90b4b84:	10802017 	ldw	r2,128(r2)
 90b4b88:	1007d0ba 	srai	r3,r2,2
 90b4b8c:	e0bfff17 	ldw	r2,-4(fp)
 90b4b90:	10802117 	ldw	r2,132(r2)
 90b4b94:	1885883a 	add	r2,r3,r2
 90b4b98:	1005d07a 	srai	r2,r2,1
 90b4b9c:	10ffffcc 	andi	r3,r2,65535
 90b4ba0:	18e0001c 	xori	r3,r3,32768
 90b4ba4:	18e00004 	addi	r3,r3,-32768
 90b4ba8:	e0bfff17 	ldw	r2,-4(fp)
 90b4bac:	10c00815 	stw	r3,32(r2)
 90b4bb0:	e0bfff17 	ldw	r2,-4(fp)
 90b4bb4:	10800817 	ldw	r2,32(r2)
 90b4bb8:	10800088 	cmpgei	r2,r2,2
 90b4bbc:	1000041e 	bne	r2,zero,90b4bd0 <tcp_xmit_timer+0x270>
 90b4bc0:	e0ffff17 	ldw	r3,-4(fp)
 90b4bc4:	00800084 	movi	r2,2
 90b4bc8:	18800815 	stw	r2,32(r3)
 90b4bcc:	00000706 	br	90b4bec <tcp_xmit_timer+0x28c>
 90b4bd0:	e0bfff17 	ldw	r2,-4(fp)
 90b4bd4:	10800817 	ldw	r2,32(r2)
 90b4bd8:	10802050 	cmplti	r2,r2,129
 90b4bdc:	1000031e 	bne	r2,zero,90b4bec <tcp_xmit_timer+0x28c>
 90b4be0:	e0ffff17 	ldw	r3,-4(fp)
 90b4be4:	00802004 	movi	r2,128
 90b4be8:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 90b4bec:	e037883a 	mov	sp,fp
 90b4bf0:	dfc00117 	ldw	ra,4(sp)
 90b4bf4:	df000017 	ldw	fp,0(sp)
 90b4bf8:	dec00204 	addi	sp,sp,8
 90b4bfc:	f800283a 	ret

090b4c00 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 90b4c00:	defffd04 	addi	sp,sp,-12
 90b4c04:	df000215 	stw	fp,8(sp)
 90b4c08:	df000204 	addi	fp,sp,8
 90b4c0c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 90b4c10:	e0bfff17 	ldw	r2,-4(fp)
 90b4c14:	10800117 	ldw	r2,4(r2)
 90b4c18:	10800a17 	ldw	r2,40(r2)
 90b4c1c:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 90b4c20:	e0bffe17 	ldw	r2,-8(fp)
 90b4c24:	10c00917 	ldw	r3,36(r2)
 90b4c28:	e0bffe17 	ldw	r2,-8(fp)
 90b4c2c:	10800817 	ldw	r2,32(r2)
 90b4c30:	1885c83a 	sub	r2,r3,r2
 90b4c34:	10bff604 	addi	r2,r2,-40
}
 90b4c38:	e037883a 	mov	sp,fp
 90b4c3c:	df000017 	ldw	fp,0(sp)
 90b4c40:	dec00104 	addi	sp,sp,4
 90b4c44:	f800283a 	ret

090b4c48 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 90b4c48:	defff904 	addi	sp,sp,-28
 90b4c4c:	dfc00615 	stw	ra,24(sp)
 90b4c50:	df000515 	stw	fp,20(sp)
 90b4c54:	df000504 	addi	fp,sp,20
 90b4c58:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 90b4c5c:	e0bffe17 	ldw	r2,-8(fp)
 90b4c60:	1005003a 	cmpeq	r2,r2,zero
 90b4c64:	1000091e 	bne	r2,zero,90b4c8c <tcp_mss+0x44>
 90b4c68:	e0bffe17 	ldw	r2,-8(fp)
 90b4c6c:	10800117 	ldw	r2,4(r2)
 90b4c70:	1005003a 	cmpeq	r2,r2,zero
 90b4c74:	1000051e 	bne	r2,zero,90b4c8c <tcp_mss+0x44>
 90b4c78:	e0bffe17 	ldw	r2,-8(fp)
 90b4c7c:	10800117 	ldw	r2,4(r2)
 90b4c80:	10800a17 	ldw	r2,40(r2)
 90b4c84:	1004c03a 	cmpne	r2,r2,zero
 90b4c88:	1000071e 	bne	r2,zero,90b4ca8 <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 90b4c8c:	e0bffe17 	ldw	r2,-8(fp)
 90b4c90:	10800517 	ldw	r2,20(r2)
 90b4c94:	10800098 	cmpnei	r2,r2,2
 90b4c98:	1000031e 	bne	r2,zero,90b4ca8 <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 90b4c9c:	00816d04 	movi	r2,1460
 90b4ca0:	e0bfff15 	stw	r2,-4(fp)
 90b4ca4:	00002906 	br	90b4d4c <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 90b4ca8:	e13ffe17 	ldw	r4,-8(fp)
 90b4cac:	90b4c000 	call	90b4c00 <ip4_tcpmss>
 90b4cb0:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 90b4cb4:	e0bffd17 	ldw	r2,-12(fp)
 90b4cb8:	10816d50 	cmplti	r2,r2,1461
 90b4cbc:	1000021e 	bne	r2,zero,90b4cc8 <tcp_mss+0x80>
      mss = TCP_MSS;
 90b4cc0:	00816d04 	movi	r2,1460
 90b4cc4:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 90b4cc8:	e0bffe17 	ldw	r2,-8(fp)
 90b4ccc:	10800117 	ldw	r2,4(r2)
 90b4cd0:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 90b4cd4:	e0bffc17 	ldw	r2,-16(fp)
 90b4cd8:	10800917 	ldw	r2,36(r2)
 90b4cdc:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 90b4ce0:	e0bffb17 	ldw	r2,-20(fp)
 90b4ce4:	10800b0b 	ldhu	r2,44(r2)
 90b4ce8:	10bfffcc 	andi	r2,r2,65535
 90b4cec:	1081000c 	andi	r2,r2,1024
 90b4cf0:	1005003a 	cmpeq	r2,r2,zero
 90b4cf4:	1000051e 	bne	r2,zero,90b4d0c <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 90b4cf8:	e0bffb17 	ldw	r2,-20(fp)
 90b4cfc:	10800a0b 	ldhu	r2,40(r2)
 90b4d00:	10bfffcc 	andi	r2,r2,65535
 90b4d04:	e0bfff15 	stw	r2,-4(fp)
 90b4d08:	00001006 	br	90b4d4c <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 90b4d0c:	e0bffb17 	ldw	r2,-20(fp)
 90b4d10:	10800a0b 	ldhu	r2,40(r2)
 90b4d14:	10bfffcc 	andi	r2,r2,65535
 90b4d18:	1005003a 	cmpeq	r2,r2,zero
 90b4d1c:	1000091e 	bne	r2,zero,90b4d44 <tcp_mss+0xfc>
 90b4d20:	e0bffb17 	ldw	r2,-20(fp)
 90b4d24:	10800a0b 	ldhu	r2,40(r2)
 90b4d28:	10ffffcc 	andi	r3,r2,65535
 90b4d2c:	e0bffd17 	ldw	r2,-12(fp)
 90b4d30:	1880040e 	bge	r3,r2,90b4d44 <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 90b4d34:	e0bffb17 	ldw	r2,-20(fp)
 90b4d38:	10800a0b 	ldhu	r2,40(r2)
 90b4d3c:	10bfffcc 	andi	r2,r2,65535
 90b4d40:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 90b4d44:	e0bffd17 	ldw	r2,-12(fp)
 90b4d48:	e0bfff15 	stw	r2,-4(fp)
 90b4d4c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b4d50:	e037883a 	mov	sp,fp
 90b4d54:	dfc00117 	ldw	ra,4(sp)
 90b4d58:	df000017 	ldw	fp,0(sp)
 90b4d5c:	dec00204 	addi	sp,sp,8
 90b4d60:	f800283a 	ret

090b4d64 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 90b4d64:	deffe004 	addi	sp,sp,-128
 90b4d68:	dfc01f15 	stw	ra,124(sp)
 90b4d6c:	df001e15 	stw	fp,120(sp)
 90b4d70:	df001e04 	addi	fp,sp,120
 90b4d74:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b4d78:	e0bff717 	ldw	r2,-36(fp)
 90b4d7c:	10800d17 	ldw	r2,52(r2)
 90b4d80:	10800817 	ldw	r2,32(r2)
 90b4d84:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 90b4d88:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 90b4d8c:	e0bff717 	ldw	r2,-36(fp)
 90b4d90:	10c01a17 	ldw	r3,104(r2)
 90b4d94:	e0bff717 	ldw	r2,-36(fp)
 90b4d98:	10800e17 	ldw	r2,56(r2)
 90b4d9c:	1885003a 	cmpeq	r2,r3,r2
 90b4da0:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 90b4da4:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 90b4da8:	e0bff717 	ldw	r2,-36(fp)
 90b4dac:	10c00f17 	ldw	r3,60(r2)
 90b4db0:	e0bff717 	ldw	r2,-36(fp)
 90b4db4:	10800e17 	ldw	r2,56(r2)
 90b4db8:	1885c83a 	sub	r2,r3,r2
 90b4dbc:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 90b4dc0:	e0bff717 	ldw	r2,-36(fp)
 90b4dc4:	10801417 	ldw	r2,80(r2)
 90b4dc8:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 90b4dcc:	e0bff717 	ldw	r2,-36(fp)
 90b4dd0:	10801b17 	ldw	r2,108(r2)
 90b4dd4:	1007883a 	mov	r3,r2
 90b4dd8:	e0bff317 	ldw	r2,-52(fp)
 90b4ddc:	1880060e 	bge	r3,r2,90b4df8 <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 90b4de0:	e0bff717 	ldw	r2,-36(fp)
 90b4de4:	10801b17 	ldw	r2,108(r2)
 90b4de8:	1007883a 	mov	r3,r2
 90b4dec:	00bfff04 	movi	r2,-4
 90b4df0:	1884703a 	and	r2,r3,r2
 90b4df4:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 90b4df8:	e0bff717 	ldw	r2,-36(fp)
 90b4dfc:	10800a83 	ldbu	r2,42(r2)
 90b4e00:	10803fcc 	andi	r2,r2,255
 90b4e04:	1080201c 	xori	r2,r2,128
 90b4e08:	10bfe004 	addi	r2,r2,-128
 90b4e0c:	1005003a 	cmpeq	r2,r2,zero
 90b4e10:	10000a1e 	bne	r2,zero,90b4e3c <tcp_output+0xd8>
   {
      if (win == 0)
 90b4e14:	e0bff317 	ldw	r2,-52(fp)
 90b4e18:	1004c03a 	cmpne	r2,r2,zero
 90b4e1c:	1000031e 	bne	r2,zero,90b4e2c <tcp_output+0xc8>
         win = 1;
 90b4e20:	00800044 	movi	r2,1
 90b4e24:	e0bff315 	stw	r2,-52(fp)
 90b4e28:	00000406 	br	90b4e3c <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 90b4e2c:	e0bff717 	ldw	r2,-36(fp)
 90b4e30:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 90b4e34:	e0bff717 	ldw	r2,-36(fp)
 90b4e38:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 90b4e3c:	e0bff517 	ldw	r2,-44(fp)
 90b4e40:	10801217 	ldw	r2,72(r2)
 90b4e44:	e0fff317 	ldw	r3,-52(fp)
 90b4e48:	e0fffb15 	stw	r3,-20(fp)
 90b4e4c:	e0bffa15 	stw	r2,-24(fp)
 90b4e50:	e0bffb17 	ldw	r2,-20(fp)
 90b4e54:	e0fffa17 	ldw	r3,-24(fp)
 90b4e58:	10c0022e 	bgeu	r2,r3,90b4e64 <tcp_output+0x100>
 90b4e5c:	e0bffb17 	ldw	r2,-20(fp)
 90b4e60:	e0bffa15 	stw	r2,-24(fp)
 90b4e64:	e0fffa17 	ldw	r3,-24(fp)
 90b4e68:	e0bff217 	ldw	r2,-56(fp)
 90b4e6c:	1885c83a 	sub	r2,r3,r2
 90b4e70:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 90b4e74:	e0bff717 	ldw	r2,-36(fp)
 90b4e78:	10c00217 	ldw	r3,8(r2)
 90b4e7c:	00824374 	movhi	r2,2317
 90b4e80:	108ac604 	addi	r2,r2,11032
 90b4e84:	10c5883a 	add	r2,r2,r3
 90b4e88:	10800003 	ldbu	r2,0(r2)
 90b4e8c:	10803fcc 	andi	r2,r2,255
 90b4e90:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 90b4e94:	e0bff117 	ldw	r2,-60(fp)
 90b4e98:	1080008c 	andi	r2,r2,2
 90b4e9c:	1005003a 	cmpeq	r2,r2,zero
 90b4ea0:	1000081e 	bne	r2,zero,90b4ec4 <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 90b4ea4:	e0ffed17 	ldw	r3,-76(fp)
 90b4ea8:	d0a0b304 	addi	r2,gp,-32052
 90b4eac:	188b883a 	add	r5,r3,r2
 90b4eb0:	e13ff717 	ldw	r4,-36(fp)
 90b4eb4:	e1bff117 	ldw	r6,-60(fp)
 90b4eb8:	e1fff517 	ldw	r7,-44(fp)
 90b4ebc:	90b5fdc0 	call	90b5fdc <bld_options>
 90b4ec0:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 90b4ec4:	e0bff417 	ldw	r2,-48(fp)
 90b4ec8:	1004403a 	cmpge	r2,r2,zero
 90b4ecc:	10000a1e 	bne	r2,zero,90b4ef8 <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 90b4ed0:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 90b4ed4:	e0bff317 	ldw	r2,-52(fp)
 90b4ed8:	1004c03a 	cmpne	r2,r2,zero
 90b4edc:	1000061e 	bne	r2,zero,90b4ef8 <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 90b4ee0:	e0bff717 	ldw	r2,-36(fp)
 90b4ee4:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 90b4ee8:	e0bff717 	ldw	r2,-36(fp)
 90b4eec:	10c00e17 	ldw	r3,56(r2)
 90b4ef0:	e0bff717 	ldw	r2,-36(fp)
 90b4ef4:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 90b4ef8:	e0bff717 	ldw	r2,-36(fp)
 90b4efc:	10800a0b 	ldhu	r2,40(r2)
 90b4f00:	10ffffcc 	andi	r3,r2,65535
 90b4f04:	e0bff417 	ldw	r2,-48(fp)
 90b4f08:	1880060e 	bge	r3,r2,90b4f24 <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 90b4f0c:	e0bff717 	ldw	r2,-36(fp)
 90b4f10:	10800a0b 	ldhu	r2,40(r2)
 90b4f14:	10bfffcc 	andi	r2,r2,65535
 90b4f18:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 90b4f1c:	00800044 	movi	r2,1
 90b4f20:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 90b4f24:	e0bff717 	ldw	r2,-36(fp)
 90b4f28:	10c00f17 	ldw	r3,60(r2)
 90b4f2c:	e0bff417 	ldw	r2,-48(fp)
 90b4f30:	1889883a 	add	r4,r3,r2
 90b4f34:	e0bff717 	ldw	r2,-36(fp)
 90b4f38:	10c00e17 	ldw	r3,56(r2)
 90b4f3c:	e0bff517 	ldw	r2,-44(fp)
 90b4f40:	10801217 	ldw	r2,72(r2)
 90b4f44:	1885883a 	add	r2,r3,r2
 90b4f48:	2085c83a 	sub	r2,r4,r2
 90b4f4c:	1004403a 	cmpge	r2,r2,zero
 90b4f50:	1000041e 	bne	r2,zero,90b4f64 <tcp_output+0x200>
      flags &= ~TH_FIN;
 90b4f54:	e0bff117 	ldw	r2,-60(fp)
 90b4f58:	00ffff84 	movi	r3,-2
 90b4f5c:	10c4703a 	and	r2,r2,r3
 90b4f60:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 90b4f64:	e0bff517 	ldw	r2,-44(fp)
 90b4f68:	10800b17 	ldw	r2,44(r2)
 90b4f6c:	1007883a 	mov	r3,r2
 90b4f70:	e0bff517 	ldw	r2,-44(fp)
 90b4f74:	10800a17 	ldw	r2,40(r2)
 90b4f78:	1885c83a 	sub	r2,r3,r2
 90b4f7c:	1004803a 	cmplt	r2,r2,zero
 90b4f80:	1000071e 	bne	r2,zero,90b4fa0 <tcp_output+0x23c>
 90b4f84:	e0bff517 	ldw	r2,-44(fp)
 90b4f88:	10c00b17 	ldw	r3,44(r2)
 90b4f8c:	e0bff517 	ldw	r2,-44(fp)
 90b4f90:	10800a17 	ldw	r2,40(r2)
 90b4f94:	1885c83a 	sub	r2,r3,r2
 90b4f98:	e0bff915 	stw	r2,-28(fp)
 90b4f9c:	00000106 	br	90b4fa4 <tcp_output+0x240>
 90b4fa0:	e03ff915 	stw	zero,-28(fp)
 90b4fa4:	e0fff917 	ldw	r3,-28(fp)
 90b4fa8:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 90b4fac:	e0bff117 	ldw	r2,-60(fp)
 90b4fb0:	1080004c 	andi	r2,r2,1
 90b4fb4:	10803fcc 	andi	r2,r2,255
 90b4fb8:	1005003a 	cmpeq	r2,r2,zero
 90b4fbc:	10000f1e 	bne	r2,zero,90b4ffc <tcp_output+0x298>
 90b4fc0:	e0bff517 	ldw	r2,-44(fp)
 90b4fc4:	10801217 	ldw	r2,72(r2)
 90b4fc8:	1004c03a 	cmpne	r2,r2,zero
 90b4fcc:	10000b1e 	bne	r2,zero,90b4ffc <tcp_output+0x298>
 90b4fd0:	e0bff717 	ldw	r2,-36(fp)
 90b4fd4:	10800b0b 	ldhu	r2,44(r2)
 90b4fd8:	10bfffcc 	andi	r2,r2,65535
 90b4fdc:	1080040c 	andi	r2,r2,16
 90b4fe0:	1005003a 	cmpeq	r2,r2,zero
 90b4fe4:	1000721e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
 90b4fe8:	e0bff717 	ldw	r2,-36(fp)
 90b4fec:	10c00f17 	ldw	r3,60(r2)
 90b4ff0:	e0bff717 	ldw	r2,-36(fp)
 90b4ff4:	10800e17 	ldw	r2,56(r2)
 90b4ff8:	18806d26 	beq	r3,r2,90b51b0 <tcp_output+0x44c>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 90b4ffc:	e0bff717 	ldw	r2,-36(fp)
 90b5000:	10800b0b 	ldhu	r2,44(r2)
 90b5004:	10bfffcc 	andi	r2,r2,65535
 90b5008:	1080004c 	andi	r2,r2,1
 90b500c:	10803fcc 	andi	r2,r2,255
 90b5010:	1004c03a 	cmpne	r2,r2,zero
 90b5014:	1000661e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 90b5018:	e0bff117 	ldw	r2,-60(fp)
 90b501c:	1080018c 	andi	r2,r2,6
 90b5020:	1004c03a 	cmpne	r2,r2,zero
 90b5024:	1000621e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 90b5028:	e0bff717 	ldw	r2,-36(fp)
 90b502c:	10c01017 	ldw	r3,64(r2)
 90b5030:	e0bff717 	ldw	r2,-36(fp)
 90b5034:	10800e17 	ldw	r2,56(r2)
 90b5038:	1885c83a 	sub	r2,r3,r2
 90b503c:	10800048 	cmpgei	r2,r2,1
 90b5040:	10005b1e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 90b5044:	e0bff417 	ldw	r2,-48(fp)
 90b5048:	1005003a 	cmpeq	r2,r2,zero
 90b504c:	1000281e 	bne	r2,zero,90b50f0 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 90b5050:	e0bff717 	ldw	r2,-36(fp)
 90b5054:	10800a0b 	ldhu	r2,40(r2)
 90b5058:	10ffffcc 	andi	r3,r2,65535
 90b505c:	e0bff417 	ldw	r2,-48(fp)
 90b5060:	18805326 	beq	r3,r2,90b51b0 <tcp_output+0x44c>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 90b5064:	e0bfec17 	ldw	r2,-80(fp)
 90b5068:	1004c03a 	cmpne	r2,r2,zero
 90b506c:	1000061e 	bne	r2,zero,90b5088 <tcp_output+0x324>
 90b5070:	e0bff717 	ldw	r2,-36(fp)
 90b5074:	10800b0b 	ldhu	r2,44(r2)
 90b5078:	10bfffcc 	andi	r2,r2,65535
 90b507c:	1080010c 	andi	r2,r2,4
 90b5080:	1005003a 	cmpeq	r2,r2,zero
 90b5084:	1000061e 	bne	r2,zero,90b50a0 <tcp_output+0x33c>
 90b5088:	e0fff417 	ldw	r3,-48(fp)
 90b508c:	e0bff217 	ldw	r2,-56(fp)
 90b5090:	1887883a 	add	r3,r3,r2
 90b5094:	e0bff517 	ldw	r2,-44(fp)
 90b5098:	10801217 	ldw	r2,72(r2)
 90b509c:	1880440e 	bge	r3,r2,90b51b0 <tcp_output+0x44c>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 90b50a0:	e0bff717 	ldw	r2,-36(fp)
 90b50a4:	10800a83 	ldbu	r2,42(r2)
 90b50a8:	10803fcc 	andi	r2,r2,255
 90b50ac:	1080201c 	xori	r2,r2,128
 90b50b0:	10bfe004 	addi	r2,r2,-128
 90b50b4:	1004c03a 	cmpne	r2,r2,zero
 90b50b8:	10003d1e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 90b50bc:	e0bff717 	ldw	r2,-36(fp)
 90b50c0:	10802317 	ldw	r2,140(r2)
 90b50c4:	1004d07a 	srli	r2,r2,1
 90b50c8:	1007883a 	mov	r3,r2
 90b50cc:	e0bff417 	ldw	r2,-48(fp)
 90b50d0:	10c0370e 	bge	r2,r3,90b51b0 <tcp_output+0x44c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 90b50d4:	e0bff717 	ldw	r2,-36(fp)
 90b50d8:	10c00f17 	ldw	r3,60(r2)
 90b50dc:	e0bff717 	ldw	r2,-36(fp)
 90b50e0:	10801a17 	ldw	r2,104(r2)
 90b50e4:	1885c83a 	sub	r2,r3,r2
 90b50e8:	1004803a 	cmplt	r2,r2,zero
 90b50ec:	1000301e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 90b50f0:	e0bff317 	ldw	r2,-52(fp)
 90b50f4:	10800050 	cmplti	r2,r2,1
 90b50f8:	10001b1e 	bne	r2,zero,90b5168 <tcp_output+0x404>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 90b50fc:	e0bff717 	ldw	r2,-36(fp)
 90b5100:	10c01917 	ldw	r3,100(r2)
 90b5104:	e0bff717 	ldw	r2,-36(fp)
 90b5108:	10801617 	ldw	r2,88(r2)
 90b510c:	1885c83a 	sub	r2,r3,r2
 90b5110:	1007883a 	mov	r3,r2
 90b5114:	e0bff317 	ldw	r2,-52(fp)
 90b5118:	10c5c83a 	sub	r2,r2,r3
 90b511c:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 90b5120:	e0bff517 	ldw	r2,-44(fp)
 90b5124:	10800a17 	ldw	r2,40(r2)
 90b5128:	1004c03a 	cmpne	r2,r2,zero
 90b512c:	1000071e 	bne	r2,zero,90b514c <tcp_output+0x3e8>
 90b5130:	e0bff717 	ldw	r2,-36(fp)
 90b5134:	10800a0b 	ldhu	r2,40(r2)
 90b5138:	10bfffcc 	andi	r2,r2,65535
 90b513c:	1085883a 	add	r2,r2,r2
 90b5140:	1007883a 	mov	r3,r2
 90b5144:	e0bfe717 	ldw	r2,-100(fp)
 90b5148:	10c0190e 	bge	r2,r3,90b51b0 <tcp_output+0x44c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 90b514c:	e0bfe717 	ldw	r2,-100(fp)
 90b5150:	10c01924 	muli	r3,r2,100
 90b5154:	e0bff517 	ldw	r2,-44(fp)
 90b5158:	10800b17 	ldw	r2,44(r2)
 90b515c:	1885203a 	divu	r2,r3,r2
 90b5160:	108008e8 	cmpgeui	r2,r2,35
 90b5164:	1000121e 	bne	r2,zero,90b51b0 <tcp_output+0x44c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 90b5168:	e0bff517 	ldw	r2,-44(fp)
 90b516c:	10801217 	ldw	r2,72(r2)
 90b5170:	1005003a 	cmpeq	r2,r2,zero
 90b5174:	10000c1e 	bne	r2,zero,90b51a8 <tcp_output+0x444>
 90b5178:	e0bff717 	ldw	r2,-36(fp)
 90b517c:	10800317 	ldw	r2,12(r2)
 90b5180:	1004c03a 	cmpne	r2,r2,zero
 90b5184:	1000081e 	bne	r2,zero,90b51a8 <tcp_output+0x444>
 90b5188:	e0bff717 	ldw	r2,-36(fp)
 90b518c:	10800417 	ldw	r2,16(r2)
 90b5190:	1004c03a 	cmpne	r2,r2,zero
 90b5194:	1000041e 	bne	r2,zero,90b51a8 <tcp_output+0x444>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 90b5198:	e0bff717 	ldw	r2,-36(fp)
 90b519c:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 90b51a0:	e13ff717 	ldw	r4,-36(fp)
 90b51a4:	90b5ee00 	call	90b5ee0 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 90b51a8:	e03ff815 	stw	zero,-32(fp)
 90b51ac:	00034606 	br	90b5ec8 <tcp_output+0x1164>

send:
   ENTER_CRIT_SECTION(tp);
 90b51b0:	90a96c80 	call	90a96c8 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 90b51b4:	e0bff217 	ldw	r2,-56(fp)
 90b51b8:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 90b51bc:	e0bff517 	ldw	r2,-44(fp)
 90b51c0:	10801817 	ldw	r2,96(r2)
 90b51c4:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 90b51c8:	e0bff417 	ldw	r2,-48(fp)
 90b51cc:	1005003a 	cmpeq	r2,r2,zero
 90b51d0:	10006b1e 	bne	r2,zero,90b5380 <tcp_output+0x61c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 90b51d4:	00000b06 	br	90b5204 <tcp_output+0x4a0>
      {
         bufoff -= sendm->m_len;
 90b51d8:	e0ffe817 	ldw	r3,-96(fp)
 90b51dc:	e0bfea17 	ldw	r2,-88(fp)
 90b51e0:	10800217 	ldw	r2,8(r2)
 90b51e4:	1885c83a 	sub	r2,r3,r2
 90b51e8:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 90b51ec:	e0bfe817 	ldw	r2,-96(fp)
 90b51f0:	1004803a 	cmplt	r2,r2,zero
 90b51f4:	1000061e 	bne	r2,zero,90b5210 <tcp_output+0x4ac>
            break;
         sendm = sendm->m_next;
 90b51f8:	e0bfea17 	ldw	r2,-88(fp)
 90b51fc:	10800617 	ldw	r2,24(r2)
 90b5200:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 90b5204:	e0bfea17 	ldw	r2,-88(fp)
 90b5208:	1004c03a 	cmpne	r2,r2,zero
 90b520c:	103ff21e 	bne	r2,zero,90b51d8 <tcp_output+0x474>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 90b5210:	e0bfea17 	ldw	r2,-88(fp)
 90b5214:	1004c03a 	cmpne	r2,r2,zero
 90b5218:	1000011e 	bne	r2,zero,90b5220 <tcp_output+0x4bc>
 90b521c:	90a94880 	call	90a9488 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 90b5220:	e0bfea17 	ldw	r2,-88(fp)
 90b5224:	10c00217 	ldw	r3,8(r2)
 90b5228:	e0bfe817 	ldw	r2,-96(fp)
 90b522c:	1885883a 	add	r2,r3,r2
 90b5230:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 90b5234:	e0bfea17 	ldw	r2,-88(fp)
 90b5238:	10800617 	ldw	r2,24(r2)
 90b523c:	1005003a 	cmpeq	r2,r2,zero
 90b5240:	10000b1e 	bne	r2,zero,90b5270 <tcp_output+0x50c>
 90b5244:	e0bfea17 	ldw	r2,-88(fp)
 90b5248:	10800217 	ldw	r2,8(r2)
 90b524c:	1007883a 	mov	r3,r2
 90b5250:	e0bff417 	ldw	r2,-48(fp)
 90b5254:	1880060e 	bge	r3,r2,90b5270 <tcp_output+0x50c>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 90b5258:	e0fff117 	ldw	r3,-60(fp)
 90b525c:	00bfff84 	movi	r2,-2
 90b5260:	1884703a 	and	r2,r3,r2
 90b5264:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 90b5268:	00800044 	movi	r2,1
 90b526c:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 90b5270:	e0bff117 	ldw	r2,-60(fp)
 90b5274:	1080004c 	andi	r2,r2,1
 90b5278:	10803fcc 	andi	r2,r2,255
 90b527c:	1005003a 	cmpeq	r2,r2,zero
 90b5280:	1000081e 	bne	r2,zero,90b52a4 <tcp_output+0x540>
 90b5284:	e0bff517 	ldw	r2,-44(fp)
 90b5288:	10c01217 	ldw	r3,72(r2)
 90b528c:	e0bff417 	ldw	r2,-48(fp)
 90b5290:	10c0042e 	bgeu	r2,r3,90b52a4 <tcp_output+0x540>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 90b5294:	e0bff117 	ldw	r2,-60(fp)
 90b5298:	00ffff84 	movi	r3,-2
 90b529c:	10c4703a 	and	r2,r2,r3
 90b52a0:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 90b52a4:	e0bfea17 	ldw	r2,-88(fp)
 90b52a8:	10800217 	ldw	r2,8(r2)
 90b52ac:	e0fff417 	ldw	r3,-48(fp)
 90b52b0:	e0fffd15 	stw	r3,-12(fp)
 90b52b4:	e0bffc15 	stw	r2,-16(fp)
 90b52b8:	e0bffd17 	ldw	r2,-12(fp)
 90b52bc:	e0fffc17 	ldw	r3,-16(fp)
 90b52c0:	10c0020e 	bge	r2,r3,90b52cc <tcp_output+0x568>
 90b52c4:	e0bffd17 	ldw	r2,-12(fp)
 90b52c8:	e0bffc15 	stw	r2,-16(fp)
 90b52cc:	e0fffc17 	ldw	r3,-16(fp)
 90b52d0:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 90b52d4:	e0bfe817 	ldw	r2,-96(fp)
 90b52d8:	1004c03a 	cmpne	r2,r2,zero
 90b52dc:	1000091e 	bne	r2,zero,90b5304 <tcp_output+0x5a0>
 90b52e0:	e0bfea17 	ldw	r2,-88(fp)
 90b52e4:	10800317 	ldw	r2,12(r2)
 90b52e8:	1007883a 	mov	r3,r2
 90b52ec:	e0bfea17 	ldw	r2,-88(fp)
 90b52f0:	10800417 	ldw	r2,16(r2)
 90b52f4:	1885c83a 	sub	r2,r3,r2
 90b52f8:	108000cc 	andi	r2,r2,3
 90b52fc:	1005003a 	cmpeq	r2,r2,zero
 90b5300:	10001f1e 	bne	r2,zero,90b5380 <tcp_output+0x61c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 90b5304:	e0bfea17 	ldw	r2,-88(fp)
 90b5308:	10c00217 	ldw	r3,8(r2)
 90b530c:	e0bfe817 	ldw	r2,-96(fp)
 90b5310:	1885c83a 	sub	r2,r3,r2
 90b5314:	e0fff417 	ldw	r3,-48(fp)
 90b5318:	e0ffff15 	stw	r3,-4(fp)
 90b531c:	e0bffe15 	stw	r2,-8(fp)
 90b5320:	e0bfff17 	ldw	r2,-4(fp)
 90b5324:	e0fffe17 	ldw	r3,-8(fp)
 90b5328:	10c0020e 	bge	r2,r3,90b5334 <tcp_output+0x5d0>
 90b532c:	e0bfff17 	ldw	r2,-4(fp)
 90b5330:	e0bffe15 	stw	r2,-8(fp)
 90b5334:	e0fffe17 	ldw	r3,-8(fp)
 90b5338:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 90b533c:	00824374 	movhi	r2,2317
 90b5340:	108bcf04 	addi	r2,r2,12092
 90b5344:	10800017 	ldw	r2,0(r2)
 90b5348:	10bff204 	addi	r2,r2,-56
 90b534c:	1007883a 	mov	r3,r2
 90b5350:	e0bff417 	ldw	r2,-48(fp)
 90b5354:	18800a0e 	bge	r3,r2,90b5380 <tcp_output+0x61c>
 90b5358:	008243b4 	movhi	r2,2318
 90b535c:	10b4c504 	addi	r2,r2,-11500
 90b5360:	10800217 	ldw	r2,8(r2)
 90b5364:	10800088 	cmpgei	r2,r2,2
 90b5368:	1000051e 	bne	r2,zero,90b5380 <tcp_output+0x61c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 90b536c:	00824374 	movhi	r2,2317
 90b5370:	108bcf04 	addi	r2,r2,12092
 90b5374:	10800017 	ldw	r2,0(r2)
 90b5378:	10bff204 	addi	r2,r2,-56
 90b537c:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 90b5380:	e0bff417 	ldw	r2,-48(fp)
 90b5384:	1005003a 	cmpeq	r2,r2,zero
 90b5388:	10003b1e 	bne	r2,zero,90b5478 <tcp_output+0x714>
 90b538c:	e0bfe817 	ldw	r2,-96(fp)
 90b5390:	1004c03a 	cmpne	r2,r2,zero
 90b5394:	1000381e 	bne	r2,zero,90b5478 <tcp_output+0x714>
 90b5398:	e0bfea17 	ldw	r2,-88(fp)
 90b539c:	10800117 	ldw	r2,4(r2)
 90b53a0:	10800917 	ldw	r2,36(r2)
 90b53a4:	10800058 	cmpnei	r2,r2,1
 90b53a8:	1000331e 	bne	r2,zero,90b5478 <tcp_output+0x714>
 90b53ac:	e0bfea17 	ldw	r2,-88(fp)
 90b53b0:	10800317 	ldw	r2,12(r2)
 90b53b4:	1007883a 	mov	r3,r2
 90b53b8:	e0bfea17 	ldw	r2,-88(fp)
 90b53bc:	10800417 	ldw	r2,16(r2)
 90b53c0:	1885c83a 	sub	r2,r3,r2
 90b53c4:	108000cc 	andi	r2,r2,3
 90b53c8:	1004c03a 	cmpne	r2,r2,zero
 90b53cc:	10002a1e 	bne	r2,zero,90b5478 <tcp_output+0x714>
 90b53d0:	e0bfed17 	ldw	r2,-76(fp)
 90b53d4:	1004c03a 	cmpne	r2,r2,zero
 90b53d8:	1000271e 	bne	r2,zero,90b5478 <tcp_output+0x714>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 90b53dc:	01000084 	movi	r4,2
 90b53e0:	000b883a 	mov	r5,zero
 90b53e4:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b53e8:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 90b53ec:	e0bfef17 	ldw	r2,-68(fp)
 90b53f0:	1004c03a 	cmpne	r2,r2,zero
 90b53f4:	1000041e 	bne	r2,zero,90b5408 <tcp_output+0x6a4>
      {
         EXIT_CRIT_SECTION(tp);
 90b53f8:	90a97240 	call	90a9724 <irq_Unmask>
         return (ENOBUFS);
 90b53fc:	00801a44 	movi	r2,105
 90b5400:	e0bff815 	stw	r2,-32(fp)
 90b5404:	0002b006 	br	90b5ec8 <tcp_output+0x1164>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 90b5408:	e0bfea17 	ldw	r2,-88(fp)
 90b540c:	10c00117 	ldw	r3,4(r2)
 90b5410:	e0bfef17 	ldw	r2,-68(fp)
 90b5414:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 90b5418:	e0bfef17 	ldw	r2,-68(fp)
 90b541c:	10c00117 	ldw	r3,4(r2)
 90b5420:	18800917 	ldw	r2,36(r3)
 90b5424:	10800044 	addi	r2,r2,1
 90b5428:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 90b542c:	e0bfea17 	ldw	r2,-88(fp)
 90b5430:	10c00417 	ldw	r3,16(r2)
 90b5434:	e0bfef17 	ldw	r2,-68(fp)
 90b5438:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 90b543c:	e0bfea17 	ldw	r2,-88(fp)
 90b5440:	10c00517 	ldw	r3,20(r2)
 90b5444:	e0bfef17 	ldw	r2,-68(fp)
 90b5448:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 90b544c:	e0bff417 	ldw	r2,-48(fp)
 90b5450:	10800a04 	addi	r2,r2,40
 90b5454:	1007883a 	mov	r3,r2
 90b5458:	e0bfef17 	ldw	r2,-68(fp)
 90b545c:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 90b5460:	e0bfea17 	ldw	r2,-88(fp)
 90b5464:	10800317 	ldw	r2,12(r2)
 90b5468:	10fff604 	addi	r3,r2,-40
 90b546c:	e0bfef17 	ldw	r2,-68(fp)
 90b5470:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 90b5474:	00002e06 	br	90b5530 <tcp_output+0x7cc>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 90b5478:	00824374 	movhi	r2,2317
 90b547c:	108c1b04 	addi	r2,r2,12396
 90b5480:	10800017 	ldw	r2,0(r2)
 90b5484:	11400a04 	addi	r5,r2,40
 90b5488:	010000c4 	movi	r4,3
 90b548c:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b5490:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 90b5494:	e0bfef17 	ldw	r2,-68(fp)
 90b5498:	1004c03a 	cmpne	r2,r2,zero
 90b549c:	1000041e 	bne	r2,zero,90b54b0 <tcp_output+0x74c>
      {
         EXIT_CRIT_SECTION(tp);
 90b54a0:	90a97240 	call	90a9724 <irq_Unmask>
         return ENOBUFS;
 90b54a4:	00c01a44 	movi	r3,105
 90b54a8:	e0fff815 	stw	r3,-32(fp)
 90b54ac:	00028606 	br	90b5ec8 <tcp_output+0x1164>
      }

      m->m_len = TCPIPHDRSZ;
 90b54b0:	e0ffef17 	ldw	r3,-68(fp)
 90b54b4:	00800a04 	movi	r2,40
 90b54b8:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 90b54bc:	e0bfef17 	ldw	r2,-68(fp)
 90b54c0:	10c00317 	ldw	r3,12(r2)
 90b54c4:	00824374 	movhi	r2,2317
 90b54c8:	108c1b04 	addi	r2,r2,12396
 90b54cc:	10800017 	ldw	r2,0(r2)
 90b54d0:	1887883a 	add	r3,r3,r2
 90b54d4:	e0bfef17 	ldw	r2,-68(fp)
 90b54d8:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 90b54dc:	e0bff417 	ldw	r2,-48(fp)
 90b54e0:	1005003a 	cmpeq	r2,r2,zero
 90b54e4:	1000121e 	bne	r2,zero,90b5530 <tcp_output+0x7cc>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 90b54e8:	e0bff517 	ldw	r2,-44(fp)
 90b54ec:	11001817 	ldw	r4,96(r2)
 90b54f0:	e17ff217 	ldw	r5,-56(fp)
 90b54f4:	e1bff417 	ldw	r6,-48(fp)
 90b54f8:	90aa5e80 	call	90aa5e8 <m_copy>
 90b54fc:	1007883a 	mov	r3,r2
 90b5500:	e0bfef17 	ldw	r2,-68(fp)
 90b5504:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 90b5508:	e0bfef17 	ldw	r2,-68(fp)
 90b550c:	10800617 	ldw	r2,24(r2)
 90b5510:	1004c03a 	cmpne	r2,r2,zero
 90b5514:	1000061e 	bne	r2,zero,90b5530 <tcp_output+0x7cc>
         {
            m_freem(m);
 90b5518:	e13fef17 	ldw	r4,-68(fp)
 90b551c:	90aa5a40 	call	90aa5a4 <m_freem>
            EXIT_CRIT_SECTION(tp);
 90b5520:	90a97240 	call	90a9724 <irq_Unmask>
            return ENOBUFS;
 90b5524:	00801a44 	movi	r2,105
 90b5528:	e0bff815 	stw	r2,-32(fp)
 90b552c:	00026606 	br	90b5ec8 <tcp_output+0x1164>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 90b5530:	90a97240 	call	90a9724 <irq_Unmask>

   if (len) 
 90b5534:	e0bff417 	ldw	r2,-48(fp)
 90b5538:	1005003a 	cmpeq	r2,r2,zero
 90b553c:	1000391e 	bne	r2,zero,90b5624 <tcp_output+0x8c0>
   {
      if (tp->t_force && len == 1)
 90b5540:	e0bff717 	ldw	r2,-36(fp)
 90b5544:	10800a83 	ldbu	r2,42(r2)
 90b5548:	10803fcc 	andi	r2,r2,255
 90b554c:	1080201c 	xori	r2,r2,128
 90b5550:	10bfe004 	addi	r2,r2,-128
 90b5554:	1005003a 	cmpeq	r2,r2,zero
 90b5558:	10000b1e 	bne	r2,zero,90b5588 <tcp_output+0x824>
 90b555c:	e0bff417 	ldw	r2,-48(fp)
 90b5560:	10800058 	cmpnei	r2,r2,1
 90b5564:	1000081e 	bne	r2,zero,90b5588 <tcp_output+0x824>
         tcpstat.tcps_sndprobe++;
 90b5568:	008243b4 	movhi	r2,2318
 90b556c:	10b58e04 	addi	r2,r2,-10696
 90b5570:	10801517 	ldw	r2,84(r2)
 90b5574:	10c00044 	addi	r3,r2,1
 90b5578:	008243b4 	movhi	r2,2318
 90b557c:	10b58e04 	addi	r2,r2,-10696
 90b5580:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 90b5584:	00005806 	br	90b56e8 <tcp_output+0x984>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 90b5588:	e0bff717 	ldw	r2,-36(fp)
 90b558c:	10c00f17 	ldw	r3,60(r2)
 90b5590:	e0bff717 	ldw	r2,-36(fp)
 90b5594:	10801a17 	ldw	r2,104(r2)
 90b5598:	1885c83a 	sub	r2,r3,r2
 90b559c:	1004403a 	cmpge	r2,r2,zero
 90b55a0:	1000101e 	bne	r2,zero,90b55e4 <tcp_output+0x880>
      {
         tcpstat.tcps_sndrexmitpack++;
 90b55a4:	008243b4 	movhi	r2,2318
 90b55a8:	10b58e04 	addi	r2,r2,-10696
 90b55ac:	10801217 	ldw	r2,72(r2)
 90b55b0:	10c00044 	addi	r3,r2,1
 90b55b4:	008243b4 	movhi	r2,2318
 90b55b8:	10b58e04 	addi	r2,r2,-10696
 90b55bc:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 90b55c0:	008243b4 	movhi	r2,2318
 90b55c4:	10b58e04 	addi	r2,r2,-10696
 90b55c8:	10c01317 	ldw	r3,76(r2)
 90b55cc:	e0bff417 	ldw	r2,-48(fp)
 90b55d0:	1887883a 	add	r3,r3,r2
 90b55d4:	008243b4 	movhi	r2,2318
 90b55d8:	10b58e04 	addi	r2,r2,-10696
 90b55dc:	10c01315 	stw	r3,76(r2)
 90b55e0:	00004106 	br	90b56e8 <tcp_output+0x984>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 90b55e4:	008243b4 	movhi	r2,2318
 90b55e8:	10b58e04 	addi	r2,r2,-10696
 90b55ec:	10801017 	ldw	r2,64(r2)
 90b55f0:	10c00044 	addi	r3,r2,1
 90b55f4:	008243b4 	movhi	r2,2318
 90b55f8:	10b58e04 	addi	r2,r2,-10696
 90b55fc:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 90b5600:	008243b4 	movhi	r2,2318
 90b5604:	10b58e04 	addi	r2,r2,-10696
 90b5608:	10c01117 	ldw	r3,68(r2)
 90b560c:	e0bff417 	ldw	r2,-48(fp)
 90b5610:	1887883a 	add	r3,r3,r2
 90b5614:	008243b4 	movhi	r2,2318
 90b5618:	10b58e04 	addi	r2,r2,-10696
 90b561c:	10c01115 	stw	r3,68(r2)
 90b5620:	00003106 	br	90b56e8 <tcp_output+0x984>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 90b5624:	e0bff717 	ldw	r2,-36(fp)
 90b5628:	10800b0b 	ldhu	r2,44(r2)
 90b562c:	10bfffcc 	andi	r2,r2,65535
 90b5630:	1080004c 	andi	r2,r2,1
 90b5634:	10803fcc 	andi	r2,r2,255
 90b5638:	1005003a 	cmpeq	r2,r2,zero
 90b563c:	1000081e 	bne	r2,zero,90b5660 <tcp_output+0x8fc>
   {
      tcpstat.tcps_sndacks++;
 90b5640:	008243b4 	movhi	r2,2318
 90b5644:	10b58e04 	addi	r2,r2,-10696
 90b5648:	10801417 	ldw	r2,80(r2)
 90b564c:	10c00044 	addi	r3,r2,1
 90b5650:	008243b4 	movhi	r2,2318
 90b5654:	10b58e04 	addi	r2,r2,-10696
 90b5658:	10c01415 	stw	r3,80(r2)
 90b565c:	00002206 	br	90b56e8 <tcp_output+0x984>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 90b5660:	e0bff117 	ldw	r2,-60(fp)
 90b5664:	108001cc 	andi	r2,r2,7
 90b5668:	1005003a 	cmpeq	r2,r2,zero
 90b566c:	1000081e 	bne	r2,zero,90b5690 <tcp_output+0x92c>
      tcpstat.tcps_sndctrl++;
 90b5670:	008243b4 	movhi	r2,2318
 90b5674:	10b58e04 	addi	r2,r2,-10696
 90b5678:	10801817 	ldw	r2,96(r2)
 90b567c:	10c00044 	addi	r3,r2,1
 90b5680:	008243b4 	movhi	r2,2318
 90b5684:	10b58e04 	addi	r2,r2,-10696
 90b5688:	10c01815 	stw	r3,96(r2)
 90b568c:	00001606 	br	90b56e8 <tcp_output+0x984>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 90b5690:	e0bff717 	ldw	r2,-36(fp)
 90b5694:	10c01017 	ldw	r3,64(r2)
 90b5698:	e0bff717 	ldw	r2,-36(fp)
 90b569c:	10800e17 	ldw	r2,56(r2)
 90b56a0:	1885c83a 	sub	r2,r3,r2
 90b56a4:	10800050 	cmplti	r2,r2,1
 90b56a8:	1000081e 	bne	r2,zero,90b56cc <tcp_output+0x968>
      tcpstat.tcps_sndurg++;
 90b56ac:	008243b4 	movhi	r2,2318
 90b56b0:	10b58e04 	addi	r2,r2,-10696
 90b56b4:	10801617 	ldw	r2,88(r2)
 90b56b8:	10c00044 	addi	r3,r2,1
 90b56bc:	008243b4 	movhi	r2,2318
 90b56c0:	10b58e04 	addi	r2,r2,-10696
 90b56c4:	10c01615 	stw	r3,88(r2)
 90b56c8:	00000706 	br	90b56e8 <tcp_output+0x984>
   else
      tcpstat.tcps_sndwinup++;
 90b56cc:	008243b4 	movhi	r2,2318
 90b56d0:	10b58e04 	addi	r2,r2,-10696
 90b56d4:	10801717 	ldw	r2,92(r2)
 90b56d8:	10c00044 	addi	r3,r2,1
 90b56dc:	008243b4 	movhi	r2,2318
 90b56e0:	10b58e04 	addi	r2,r2,-10696
 90b56e4:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 90b56e8:	e0bfef17 	ldw	r2,-68(fp)
 90b56ec:	10800317 	ldw	r2,12(r2)
 90b56f0:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 90b56f4:	e0bfef17 	ldw	r2,-68(fp)
 90b56f8:	10800117 	ldw	r2,4(r2)
 90b56fc:	10c00117 	ldw	r3,4(r2)
 90b5700:	e0bfee17 	ldw	r2,-72(fp)
 90b5704:	10c0032e 	bgeu	r2,r3,90b5714 <tcp_output+0x9b0>
   {
      panic("tcp_out- packet ptr underflow\n");
 90b5708:	01024374 	movhi	r4,2317
 90b570c:	213f8b04 	addi	r4,r4,-468
 90b5710:	90a438c0 	call	90a438c <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 90b5714:	e0bfef17 	ldw	r2,-68(fp)
 90b5718:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 90b571c:	e0bff717 	ldw	r2,-36(fp)
 90b5720:	10800c17 	ldw	r2,48(r2)
 90b5724:	1004c03a 	cmpne	r2,r2,zero
 90b5728:	1000031e 	bne	r2,zero,90b5738 <tcp_output+0x9d4>
      panic("tcp_output");
 90b572c:	01024374 	movhi	r4,2317
 90b5730:	213f9304 	addi	r4,r4,-436
 90b5734:	90a438c0 	call	90a438c <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 90b5738:	e0ffee17 	ldw	r3,-72(fp)
 90b573c:	e0bff717 	ldw	r2,-36(fp)
 90b5740:	10800c17 	ldw	r2,48(r2)
 90b5744:	1809883a 	mov	r4,r3
 90b5748:	100b883a 	mov	r5,r2
 90b574c:	01800a04 	movi	r6,40
 90b5750:	90822780 	call	9082278 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 90b5754:	e0bff117 	ldw	r2,-60(fp)
 90b5758:	1080004c 	andi	r2,r2,1
 90b575c:	10803fcc 	andi	r2,r2,255
 90b5760:	1005003a 	cmpeq	r2,r2,zero
 90b5764:	1000101e 	bne	r2,zero,90b57a8 <tcp_output+0xa44>
 90b5768:	e0bff717 	ldw	r2,-36(fp)
 90b576c:	10800b0b 	ldhu	r2,44(r2)
 90b5770:	10bfffcc 	andi	r2,r2,65535
 90b5774:	1080040c 	andi	r2,r2,16
 90b5778:	1005003a 	cmpeq	r2,r2,zero
 90b577c:	10000a1e 	bne	r2,zero,90b57a8 <tcp_output+0xa44>
 90b5780:	e0bff717 	ldw	r2,-36(fp)
 90b5784:	10c00f17 	ldw	r3,60(r2)
 90b5788:	e0bff717 	ldw	r2,-36(fp)
 90b578c:	10801a17 	ldw	r2,104(r2)
 90b5790:	1880051e 	bne	r3,r2,90b57a8 <tcp_output+0xa44>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 90b5794:	e0bff717 	ldw	r2,-36(fp)
 90b5798:	10800f17 	ldw	r2,60(r2)
 90b579c:	10ffffc4 	addi	r3,r2,-1
 90b57a0:	e0bff717 	ldw	r2,-36(fp)
 90b57a4:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 90b57a8:	e0bff717 	ldw	r2,-36(fp)
 90b57ac:	10800f17 	ldw	r2,60(r2)
 90b57b0:	1004d63a 	srli	r2,r2,24
 90b57b4:	10c03fcc 	andi	r3,r2,255
 90b57b8:	e0bff717 	ldw	r2,-36(fp)
 90b57bc:	10800f17 	ldw	r2,60(r2)
 90b57c0:	1004d23a 	srli	r2,r2,8
 90b57c4:	10bfc00c 	andi	r2,r2,65280
 90b57c8:	1886b03a 	or	r3,r3,r2
 90b57cc:	e0bff717 	ldw	r2,-36(fp)
 90b57d0:	10800f17 	ldw	r2,60(r2)
 90b57d4:	10bfc00c 	andi	r2,r2,65280
 90b57d8:	1004923a 	slli	r2,r2,8
 90b57dc:	1886b03a 	or	r3,r3,r2
 90b57e0:	e0bff717 	ldw	r2,-36(fp)
 90b57e4:	10800f17 	ldw	r2,60(r2)
 90b57e8:	10803fcc 	andi	r2,r2,255
 90b57ec:	1004963a 	slli	r2,r2,24
 90b57f0:	1886b03a 	or	r3,r3,r2
 90b57f4:	e0bfee17 	ldw	r2,-72(fp)
 90b57f8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 90b57fc:	e0bff717 	ldw	r2,-36(fp)
 90b5800:	10801617 	ldw	r2,88(r2)
 90b5804:	1004d63a 	srli	r2,r2,24
 90b5808:	10c03fcc 	andi	r3,r2,255
 90b580c:	e0bff717 	ldw	r2,-36(fp)
 90b5810:	10801617 	ldw	r2,88(r2)
 90b5814:	1004d23a 	srli	r2,r2,8
 90b5818:	10bfc00c 	andi	r2,r2,65280
 90b581c:	1886b03a 	or	r3,r3,r2
 90b5820:	e0bff717 	ldw	r2,-36(fp)
 90b5824:	10801617 	ldw	r2,88(r2)
 90b5828:	10bfc00c 	andi	r2,r2,65280
 90b582c:	1004923a 	slli	r2,r2,8
 90b5830:	1886b03a 	or	r3,r3,r2
 90b5834:	e0bff717 	ldw	r2,-36(fp)
 90b5838:	10801617 	ldw	r2,88(r2)
 90b583c:	10803fcc 	andi	r2,r2,255
 90b5840:	1004963a 	slli	r2,r2,24
 90b5844:	1886b03a 	or	r3,r3,r2
 90b5848:	e0bfee17 	ldw	r2,-72(fp)
 90b584c:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 90b5850:	e0bff117 	ldw	r2,-60(fp)
 90b5854:	1080008c 	andi	r2,r2,2
 90b5858:	1005003a 	cmpeq	r2,r2,zero
 90b585c:	1000221e 	bne	r2,zero,90b58e8 <tcp_output+0xb84>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 90b5860:	e0bff517 	ldw	r2,-44(fp)
 90b5864:	10800117 	ldw	r2,4(r2)
 90b5868:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 90b586c:	e0bff517 	ldw	r2,-44(fp)
 90b5870:	10800517 	ldw	r2,20(r2)
 90b5874:	108000a0 	cmpeqi	r2,r2,2
 90b5878:	1000011e 	bne	r2,zero,90b5880 <tcp_output+0xb1c>
 90b587c:	00001906 	br	90b58e4 <tcp_output+0xb80>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 90b5880:	e0bff117 	ldw	r2,-60(fp)
 90b5884:	1080040c 	andi	r2,r2,16
 90b5888:	1004c03a 	cmpne	r2,r2,zero
 90b588c:	1000161e 	bne	r2,zero,90b58e8 <tcp_output+0xb84>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 90b5890:	e0bfee17 	ldw	r2,-72(fp)
 90b5894:	11000417 	ldw	r4,16(r2)
 90b5898:	e17ff604 	addi	r5,fp,-40
 90b589c:	90bee840 	call	90bee84 <iproute>
 90b58a0:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 90b58a4:	e0bfe517 	ldw	r2,-108(fp)
 90b58a8:	1005003a 	cmpeq	r2,r2,zero
 90b58ac:	1000091e 	bne	r2,zero,90b58d4 <tcp_output+0xb70>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 90b58b0:	e0bfe517 	ldw	r2,-108(fp)
 90b58b4:	10c00917 	ldw	r3,36(r2)
 90b58b8:	e0bfe517 	ldw	r2,-108(fp)
 90b58bc:	10800817 	ldw	r2,32(r2)
 90b58c0:	1885c83a 	sub	r2,r3,r2
 90b58c4:	10fff604 	addi	r3,r2,-40
 90b58c8:	e0bfe617 	ldw	r2,-104(fp)
 90b58cc:	10c00615 	stw	r3,24(r2)
 90b58d0:	00000506 	br	90b58e8 <tcp_output+0xb84>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 90b58d4:	e0ffe617 	ldw	r3,-104(fp)
 90b58d8:	00809104 	movi	r2,580
 90b58dc:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 90b58e0:	00000106 	br	90b58e8 <tcp_output+0xb84>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 90b58e4:	90a94880 	call	90a9488 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 90b58e8:	e0bfed17 	ldw	r2,-76(fp)
 90b58ec:	1005003a 	cmpeq	r2,r2,zero
 90b58f0:	10002f1e 	bne	r2,zero,90b59b0 <tcp_output+0xc4c>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 90b58f4:	01000084 	movi	r4,2
 90b58f8:	01404004 	movi	r5,256
 90b58fc:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b5900:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 90b5904:	e0bfe417 	ldw	r2,-112(fp)
 90b5908:	1004c03a 	cmpne	r2,r2,zero
 90b590c:	1000051e 	bne	r2,zero,90b5924 <tcp_output+0xbc0>
      {
         m_freem(m);
 90b5910:	e13fef17 	ldw	r4,-68(fp)
 90b5914:	90aa5a40 	call	90aa5a4 <m_freem>
         return (ENOBUFS);
 90b5918:	00c01a44 	movi	r3,105
 90b591c:	e0fff815 	stw	r3,-32(fp)
 90b5920:	00016906 	br	90b5ec8 <tcp_output+0x1164>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 90b5924:	e0bfe917 	ldw	r2,-92(fp)
 90b5928:	10c00617 	ldw	r3,24(r2)
 90b592c:	e0bfe417 	ldw	r2,-112(fp)
 90b5930:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 90b5934:	e0ffe917 	ldw	r3,-92(fp)
 90b5938:	e0bfe417 	ldw	r2,-112(fp)
 90b593c:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 90b5940:	00000706 	br	90b5960 <tcp_output+0xbfc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 90b5944:	e0ffed17 	ldw	r3,-76(fp)
 90b5948:	d0a0b304 	addi	r2,gp,-32052
 90b594c:	1885883a 	add	r2,r3,r2
 90b5950:	10000005 	stb	zero,0(r2)
 90b5954:	e0bfed17 	ldw	r2,-76(fp)
 90b5958:	10800044 	addi	r2,r2,1
 90b595c:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 90b5960:	e0bfed17 	ldw	r2,-76(fp)
 90b5964:	108000cc 	andi	r2,r2,3
 90b5968:	1004c03a 	cmpne	r2,r2,zero
 90b596c:	103ff51e 	bne	r2,zero,90b5944 <tcp_output+0xbe0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 90b5970:	e0bfe417 	ldw	r2,-112(fp)
 90b5974:	10800317 	ldw	r2,12(r2)
 90b5978:	1009883a 	mov	r4,r2
 90b597c:	d160b304 	addi	r5,gp,-32052
 90b5980:	e1bfed17 	ldw	r6,-76(fp)
 90b5984:	90822780 	call	9082278 <memcpy>
      mopt->m_len = optlen;
 90b5988:	e0ffe417 	ldw	r3,-112(fp)
 90b598c:	e0bfed17 	ldw	r2,-76(fp)
 90b5990:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 90b5994:	e0bfed17 	ldw	r2,-76(fp)
 90b5998:	10800504 	addi	r2,r2,20
 90b599c:	1004d0ba 	srli	r2,r2,2
 90b59a0:	1004913a 	slli	r2,r2,4
 90b59a4:	1007883a 	mov	r3,r2
 90b59a8:	e0bfee17 	ldw	r2,-72(fp)
 90b59ac:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 90b59b0:	e0bff117 	ldw	r2,-60(fp)
 90b59b4:	1007883a 	mov	r3,r2
 90b59b8:	e0bfee17 	ldw	r2,-72(fp)
 90b59bc:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 90b59c0:	e0bff517 	ldw	r2,-44(fp)
 90b59c4:	10800b17 	ldw	r2,44(r2)
 90b59c8:	1004d0ba 	srli	r2,r2,2
 90b59cc:	1007883a 	mov	r3,r2
 90b59d0:	e0bff317 	ldw	r2,-52(fp)
 90b59d4:	10c0060e 	bge	r2,r3,90b59f0 <tcp_output+0xc8c>
 90b59d8:	e0bff717 	ldw	r2,-36(fp)
 90b59dc:	10800a0b 	ldhu	r2,40(r2)
 90b59e0:	10ffffcc 	andi	r3,r2,65535
 90b59e4:	e0bff317 	ldw	r2,-52(fp)
 90b59e8:	10c0010e 	bge	r2,r3,90b59f0 <tcp_output+0xc8c>
      win = 0;
 90b59ec:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 90b59f0:	e0bff717 	ldw	r2,-36(fp)
 90b59f4:	10c01917 	ldw	r3,100(r2)
 90b59f8:	e0bff717 	ldw	r2,-36(fp)
 90b59fc:	10801617 	ldw	r2,88(r2)
 90b5a00:	1885c83a 	sub	r2,r3,r2
 90b5a04:	1007883a 	mov	r3,r2
 90b5a08:	e0bff317 	ldw	r2,-52(fp)
 90b5a0c:	10c0060e 	bge	r2,r3,90b5a28 <tcp_output+0xcc4>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 90b5a10:	e0bff717 	ldw	r2,-36(fp)
 90b5a14:	10c01917 	ldw	r3,100(r2)
 90b5a18:	e0bff717 	ldw	r2,-36(fp)
 90b5a1c:	10801617 	ldw	r2,88(r2)
 90b5a20:	1885c83a 	sub	r2,r3,r2
 90b5a24:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 90b5a28:	008243b4 	movhi	r2,2318
 90b5a2c:	10b4c504 	addi	r2,r2,-11500
 90b5a30:	10800217 	ldw	r2,8(r2)
 90b5a34:	1004c03a 	cmpne	r2,r2,zero
 90b5a38:	1000021e 	bne	r2,zero,90b5a44 <tcp_output+0xce0>
   {
      win = 0;
 90b5a3c:	e03ff315 	stw	zero,-52(fp)
 90b5a40:	00001406 	br	90b5a94 <tcp_output+0xd30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 90b5a44:	008243b4 	movhi	r2,2318
 90b5a48:	10b4c504 	addi	r2,r2,-11500
 90b5a4c:	10800217 	ldw	r2,8(r2)
 90b5a50:	10ffffc4 	addi	r3,r2,-1
 90b5a54:	00824374 	movhi	r2,2317
 90b5a58:	108bd104 	addi	r2,r2,12100
 90b5a5c:	10800017 	ldw	r2,0(r2)
 90b5a60:	1887383a 	mul	r3,r3,r2
 90b5a64:	e0bff317 	ldw	r2,-52(fp)
 90b5a68:	18800a0e 	bge	r3,r2,90b5a94 <tcp_output+0xd30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 90b5a6c:	008243b4 	movhi	r2,2318
 90b5a70:	10b4c504 	addi	r2,r2,-11500
 90b5a74:	10800217 	ldw	r2,8(r2)
 90b5a78:	10bfffc4 	addi	r2,r2,-1
 90b5a7c:	1007883a 	mov	r3,r2
 90b5a80:	00824374 	movhi	r2,2317
 90b5a84:	108bd104 	addi	r2,r2,12100
 90b5a88:	10800017 	ldw	r2,0(r2)
 90b5a8c:	1885383a 	mul	r2,r3,r2
 90b5a90:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 90b5a94:	e0bff317 	ldw	r2,-52(fp)
 90b5a98:	10bfffcc 	andi	r2,r2,65535
 90b5a9c:	1004d23a 	srli	r2,r2,8
 90b5aa0:	10803fcc 	andi	r2,r2,255
 90b5aa4:	1009883a 	mov	r4,r2
 90b5aa8:	e0bff317 	ldw	r2,-52(fp)
 90b5aac:	10bfffcc 	andi	r2,r2,65535
 90b5ab0:	1004923a 	slli	r2,r2,8
 90b5ab4:	1007883a 	mov	r3,r2
 90b5ab8:	00bfc004 	movi	r2,-256
 90b5abc:	1884703a 	and	r2,r3,r2
 90b5ac0:	2084b03a 	or	r2,r4,r2
 90b5ac4:	1007883a 	mov	r3,r2
 90b5ac8:	e0bfee17 	ldw	r2,-72(fp)
 90b5acc:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 90b5ad0:	e0bff717 	ldw	r2,-36(fp)
 90b5ad4:	10c01017 	ldw	r3,64(r2)
 90b5ad8:	e0bff717 	ldw	r2,-36(fp)
 90b5adc:	10800f17 	ldw	r2,60(r2)
 90b5ae0:	1885c83a 	sub	r2,r3,r2
 90b5ae4:	10800050 	cmplti	r2,r2,1
 90b5ae8:	1000201e 	bne	r2,zero,90b5b6c <tcp_output+0xe08>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 90b5aec:	e0bff717 	ldw	r2,-36(fp)
 90b5af0:	10801017 	ldw	r2,64(r2)
 90b5af4:	1007883a 	mov	r3,r2
 90b5af8:	e0bff717 	ldw	r2,-36(fp)
 90b5afc:	10800f17 	ldw	r2,60(r2)
 90b5b00:	1885c83a 	sub	r2,r3,r2
 90b5b04:	10bfffcc 	andi	r2,r2,65535
 90b5b08:	1004d23a 	srli	r2,r2,8
 90b5b0c:	10803fcc 	andi	r2,r2,255
 90b5b10:	1009883a 	mov	r4,r2
 90b5b14:	e0bff717 	ldw	r2,-36(fp)
 90b5b18:	10801017 	ldw	r2,64(r2)
 90b5b1c:	1007883a 	mov	r3,r2
 90b5b20:	e0bff717 	ldw	r2,-36(fp)
 90b5b24:	10800f17 	ldw	r2,60(r2)
 90b5b28:	1885c83a 	sub	r2,r3,r2
 90b5b2c:	10bfffcc 	andi	r2,r2,65535
 90b5b30:	1004923a 	slli	r2,r2,8
 90b5b34:	1007883a 	mov	r3,r2
 90b5b38:	00bfc004 	movi	r2,-256
 90b5b3c:	1884703a 	and	r2,r3,r2
 90b5b40:	2084b03a 	or	r2,r4,r2
 90b5b44:	1007883a 	mov	r3,r2
 90b5b48:	e0bfee17 	ldw	r2,-72(fp)
 90b5b4c:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 90b5b50:	e0bfee17 	ldw	r2,-72(fp)
 90b5b54:	10800843 	ldbu	r2,33(r2)
 90b5b58:	10800814 	ori	r2,r2,32
 90b5b5c:	1007883a 	mov	r3,r2
 90b5b60:	e0bfee17 	ldw	r2,-72(fp)
 90b5b64:	10c00845 	stb	r3,33(r2)
 90b5b68:	00000406 	br	90b5b7c <tcp_output+0xe18>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 90b5b6c:	e0bff717 	ldw	r2,-36(fp)
 90b5b70:	10c00e17 	ldw	r3,56(r2)
 90b5b74:	e0bff717 	ldw	r2,-36(fp)
 90b5b78:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 90b5b7c:	e0bff417 	ldw	r2,-48(fp)
 90b5b80:	1005003a 	cmpeq	r2,r2,zero
 90b5b84:	10000c1e 	bne	r2,zero,90b5bb8 <tcp_output+0xe54>
 90b5b88:	e0fff217 	ldw	r3,-56(fp)
 90b5b8c:	e0bff417 	ldw	r2,-48(fp)
 90b5b90:	1887883a 	add	r3,r3,r2
 90b5b94:	e0bff517 	ldw	r2,-44(fp)
 90b5b98:	10801217 	ldw	r2,72(r2)
 90b5b9c:	1880061e 	bne	r3,r2,90b5bb8 <tcp_output+0xe54>
      ti->ti_flags |= TH_PUSH;
 90b5ba0:	e0bfee17 	ldw	r2,-72(fp)
 90b5ba4:	10800843 	ldbu	r2,33(r2)
 90b5ba8:	10800214 	ori	r2,r2,8
 90b5bac:	1007883a 	mov	r3,r2
 90b5bb0:	e0bfee17 	ldw	r2,-72(fp)
 90b5bb4:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 90b5bb8:	e0bff717 	ldw	r2,-36(fp)
 90b5bbc:	10800a83 	ldbu	r2,42(r2)
 90b5bc0:	10803fcc 	andi	r2,r2,255
 90b5bc4:	1080201c 	xori	r2,r2,128
 90b5bc8:	10bfe004 	addi	r2,r2,-128
 90b5bcc:	1005003a 	cmpeq	r2,r2,zero
 90b5bd0:	1000041e 	bne	r2,zero,90b5be4 <tcp_output+0xe80>
 90b5bd4:	e0bff717 	ldw	r2,-36(fp)
 90b5bd8:	10800417 	ldw	r2,16(r2)
 90b5bdc:	1004c03a 	cmpne	r2,r2,zero
 90b5be0:	1000561e 	bne	r2,zero,90b5d3c <tcp_output+0xfd8>
   {
      tcp_seq startseq = tp->snd_nxt;
 90b5be4:	e0bff717 	ldw	r2,-36(fp)
 90b5be8:	10800f17 	ldw	r2,60(r2)
 90b5bec:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 90b5bf0:	e0bff117 	ldw	r2,-60(fp)
 90b5bf4:	1080008c 	andi	r2,r2,2
 90b5bf8:	1005003a 	cmpeq	r2,r2,zero
 90b5bfc:	1000051e 	bne	r2,zero,90b5c14 <tcp_output+0xeb0>
         tp->snd_nxt++;
 90b5c00:	e0bff717 	ldw	r2,-36(fp)
 90b5c04:	10800f17 	ldw	r2,60(r2)
 90b5c08:	10c00044 	addi	r3,r2,1
 90b5c0c:	e0bff717 	ldw	r2,-36(fp)
 90b5c10:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 90b5c14:	e0bff117 	ldw	r2,-60(fp)
 90b5c18:	1080004c 	andi	r2,r2,1
 90b5c1c:	10803fcc 	andi	r2,r2,255
 90b5c20:	1005003a 	cmpeq	r2,r2,zero
 90b5c24:	10000b1e 	bne	r2,zero,90b5c54 <tcp_output+0xef0>
      {
         tp->snd_nxt++;
 90b5c28:	e0bff717 	ldw	r2,-36(fp)
 90b5c2c:	10800f17 	ldw	r2,60(r2)
 90b5c30:	10c00044 	addi	r3,r2,1
 90b5c34:	e0bff717 	ldw	r2,-36(fp)
 90b5c38:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 90b5c3c:	e0bff717 	ldw	r2,-36(fp)
 90b5c40:	10800b0b 	ldhu	r2,44(r2)
 90b5c44:	10800414 	ori	r2,r2,16
 90b5c48:	1007883a 	mov	r3,r2
 90b5c4c:	e0bff717 	ldw	r2,-36(fp)
 90b5c50:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 90b5c54:	e0bff717 	ldw	r2,-36(fp)
 90b5c58:	10c00f17 	ldw	r3,60(r2)
 90b5c5c:	e0bff417 	ldw	r2,-48(fp)
 90b5c60:	1887883a 	add	r3,r3,r2
 90b5c64:	e0bff717 	ldw	r2,-36(fp)
 90b5c68:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 90b5c6c:	e0bff717 	ldw	r2,-36(fp)
 90b5c70:	10c00f17 	ldw	r3,60(r2)
 90b5c74:	e0bff717 	ldw	r2,-36(fp)
 90b5c78:	10801a17 	ldw	r2,104(r2)
 90b5c7c:	1885c83a 	sub	r2,r3,r2
 90b5c80:	10800050 	cmplti	r2,r2,1
 90b5c84:	1000171e 	bne	r2,zero,90b5ce4 <tcp_output+0xf80>
      {
         tp->snd_max = tp->snd_nxt;
 90b5c88:	e0bff717 	ldw	r2,-36(fp)
 90b5c8c:	10c00f17 	ldw	r3,60(r2)
 90b5c90:	e0bff717 	ldw	r2,-36(fp)
 90b5c94:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 90b5c98:	e0bff717 	ldw	r2,-36(fp)
 90b5c9c:	10801e17 	ldw	r2,120(r2)
 90b5ca0:	1004c03a 	cmpne	r2,r2,zero
 90b5ca4:	10000f1e 	bne	r2,zero,90b5ce4 <tcp_output+0xf80>
         {
            tp->t_rttick = cticks;
 90b5ca8:	00824374 	movhi	r2,2317
 90b5cac:	108c4204 	addi	r2,r2,12552
 90b5cb0:	10c00017 	ldw	r3,0(r2)
 90b5cb4:	e0bff717 	ldw	r2,-36(fp)
 90b5cb8:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 90b5cbc:	e0fff717 	ldw	r3,-36(fp)
 90b5cc0:	e0bfe317 	ldw	r2,-116(fp)
 90b5cc4:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 90b5cc8:	008243b4 	movhi	r2,2318
 90b5ccc:	10b58e04 	addi	r2,r2,-10696
 90b5cd0:	10800617 	ldw	r2,24(r2)
 90b5cd4:	10c00044 	addi	r3,r2,1
 90b5cd8:	008243b4 	movhi	r2,2318
 90b5cdc:	10b58e04 	addi	r2,r2,-10696
 90b5ce0:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 90b5ce4:	e0bff717 	ldw	r2,-36(fp)
 90b5ce8:	10800317 	ldw	r2,12(r2)
 90b5cec:	1004c03a 	cmpne	r2,r2,zero
 90b5cf0:	1000211e 	bne	r2,zero,90b5d78 <tcp_output+0x1014>
 90b5cf4:	e0bff717 	ldw	r2,-36(fp)
 90b5cf8:	10c00f17 	ldw	r3,60(r2)
 90b5cfc:	e0bff717 	ldw	r2,-36(fp)
 90b5d00:	10800e17 	ldw	r2,56(r2)
 90b5d04:	18801c26 	beq	r3,r2,90b5d78 <tcp_output+0x1014>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b5d08:	e0bff717 	ldw	r2,-36(fp)
 90b5d0c:	10c00817 	ldw	r3,32(r2)
 90b5d10:	e0bff717 	ldw	r2,-36(fp)
 90b5d14:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 90b5d18:	e0bff717 	ldw	r2,-36(fp)
 90b5d1c:	10800417 	ldw	r2,16(r2)
 90b5d20:	1005003a 	cmpeq	r2,r2,zero
 90b5d24:	1000141e 	bne	r2,zero,90b5d78 <tcp_output+0x1014>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 90b5d28:	e0bff717 	ldw	r2,-36(fp)
 90b5d2c:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 90b5d30:	e0bff717 	ldw	r2,-36(fp)
 90b5d34:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 90b5d38:	00000f06 	br	90b5d78 <tcp_output+0x1014>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 90b5d3c:	e0bff717 	ldw	r2,-36(fp)
 90b5d40:	10c00f17 	ldw	r3,60(r2)
 90b5d44:	e0bff417 	ldw	r2,-48(fp)
 90b5d48:	1887883a 	add	r3,r3,r2
 90b5d4c:	e0bff717 	ldw	r2,-36(fp)
 90b5d50:	10801a17 	ldw	r2,104(r2)
 90b5d54:	1885c83a 	sub	r2,r3,r2
 90b5d58:	10800050 	cmplti	r2,r2,1
 90b5d5c:	1000061e 	bne	r2,zero,90b5d78 <tcp_output+0x1014>
         tp->snd_max = tp->snd_nxt + len;
 90b5d60:	e0bff717 	ldw	r2,-36(fp)
 90b5d64:	10c00f17 	ldw	r3,60(r2)
 90b5d68:	e0bff417 	ldw	r2,-48(fp)
 90b5d6c:	1887883a 	add	r3,r3,r2
 90b5d70:	e0bff717 	ldw	r2,-36(fp)
 90b5d74:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 90b5d78:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 90b5d7c:	e0bfef17 	ldw	r2,-68(fp)
 90b5d80:	10800317 	ldw	r2,12(r2)
 90b5d84:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 90b5d88:	e0bfed17 	ldw	r2,-76(fp)
 90b5d8c:	1007883a 	mov	r3,r2
 90b5d90:	e0bff417 	ldw	r2,-48(fp)
 90b5d94:	1885883a 	add	r2,r3,r2
 90b5d98:	10800a04 	addi	r2,r2,40
 90b5d9c:	1007883a 	mov	r3,r2
 90b5da0:	e0bfe217 	ldw	r2,-120(fp)
 90b5da4:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 90b5da8:	e0bff517 	ldw	r2,-44(fp)
 90b5dac:	11401f17 	ldw	r5,124(r2)
 90b5db0:	e13fef17 	ldw	r4,-68(fp)
 90b5db4:	90aafd80 	call	90aafd8 <ip_output>
 90b5db8:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 90b5dbc:	e0bff017 	ldw	r2,-64(fp)
 90b5dc0:	1005003a 	cmpeq	r2,r2,zero
 90b5dc4:	1000151e 	bne	r2,zero,90b5e1c <tcp_output+0x10b8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 90b5dc8:	e0bff017 	ldw	r2,-64(fp)
 90b5dcc:	10801a58 	cmpnei	r2,r2,105
 90b5dd0:	10000f1e 	bne	r2,zero,90b5e10 <tcp_output+0x10ac>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 90b5dd4:	e0bfef17 	ldw	r2,-68(fp)
 90b5dd8:	10800817 	ldw	r2,32(r2)
 90b5ddc:	1004c03a 	cmpne	r2,r2,zero
 90b5de0:	1000031e 	bne	r2,zero,90b5df0 <tcp_output+0x108c>
            m = m->m_next;
 90b5de4:	e0bfef17 	ldw	r2,-68(fp)
 90b5de8:	10800617 	ldw	r2,24(r2)
 90b5dec:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 90b5df0:	e13fef17 	ldw	r4,-68(fp)
 90b5df4:	90aa5a40 	call	90aa5a4 <m_freem>
         tcp_quench(tp->t_inpcb);
 90b5df8:	e0bff717 	ldw	r2,-36(fp)
 90b5dfc:	11000d17 	ldw	r4,52(r2)
 90b5e00:	90b69680 	call	90b6968 <tcp_quench>
         return (error);
 90b5e04:	e0bff017 	ldw	r2,-64(fp)
 90b5e08:	e0bff815 	stw	r2,-32(fp)
 90b5e0c:	00002e06 	br	90b5ec8 <tcp_output+0x1164>
      }
      return (error);
 90b5e10:	e0fff017 	ldw	r3,-64(fp)
 90b5e14:	e0fff815 	stw	r3,-32(fp)
 90b5e18:	00002b06 	br	90b5ec8 <tcp_output+0x1164>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 90b5e1c:	008243b4 	movhi	r2,2318
 90b5e20:	10b56004 	addi	r2,r2,-10880
 90b5e24:	10800a17 	ldw	r2,40(r2)
 90b5e28:	10c00044 	addi	r3,r2,1
 90b5e2c:	008243b4 	movhi	r2,2318
 90b5e30:	10b56004 	addi	r2,r2,-10880
 90b5e34:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 90b5e38:	008243b4 	movhi	r2,2318
 90b5e3c:	10b58e04 	addi	r2,r2,-10696
 90b5e40:	10800f17 	ldw	r2,60(r2)
 90b5e44:	10c00044 	addi	r3,r2,1
 90b5e48:	008243b4 	movhi	r2,2318
 90b5e4c:	10b58e04 	addi	r2,r2,-10696
 90b5e50:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 90b5e54:	e0bff317 	ldw	r2,-52(fp)
 90b5e58:	10800050 	cmplti	r2,r2,1
 90b5e5c:	10000f1e 	bne	r2,zero,90b5e9c <tcp_output+0x1138>
 90b5e60:	e0bff717 	ldw	r2,-36(fp)
 90b5e64:	10c01617 	ldw	r3,88(r2)
 90b5e68:	e0bff317 	ldw	r2,-52(fp)
 90b5e6c:	1887883a 	add	r3,r3,r2
 90b5e70:	e0bff717 	ldw	r2,-36(fp)
 90b5e74:	10801917 	ldw	r2,100(r2)
 90b5e78:	1885c83a 	sub	r2,r3,r2
 90b5e7c:	10800050 	cmplti	r2,r2,1
 90b5e80:	1000061e 	bne	r2,zero,90b5e9c <tcp_output+0x1138>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 90b5e84:	e0bff717 	ldw	r2,-36(fp)
 90b5e88:	10c01617 	ldw	r3,88(r2)
 90b5e8c:	e0bff317 	ldw	r2,-52(fp)
 90b5e90:	1887883a 	add	r3,r3,r2
 90b5e94:	e0bff717 	ldw	r2,-36(fp)
 90b5e98:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 90b5e9c:	e0bff717 	ldw	r2,-36(fp)
 90b5ea0:	10c00b0b 	ldhu	r3,44(r2)
 90b5ea4:	00bfef04 	movi	r2,-68
 90b5ea8:	1884703a 	and	r2,r3,r2
 90b5eac:	1007883a 	mov	r3,r2
 90b5eb0:	e0bff717 	ldw	r2,-36(fp)
 90b5eb4:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 90b5eb8:	e0bfeb17 	ldw	r2,-84(fp)
 90b5ebc:	1004c03a 	cmpne	r2,r2,zero
 90b5ec0:	103bb81e 	bne	r2,zero,90b4da4 <tcp_output+0x40>
      goto again;
   return (0);
 90b5ec4:	e03ff815 	stw	zero,-32(fp)
 90b5ec8:	e0bff817 	ldw	r2,-32(fp)
}
 90b5ecc:	e037883a 	mov	sp,fp
 90b5ed0:	dfc00117 	ldw	ra,4(sp)
 90b5ed4:	df000017 	ldw	fp,0(sp)
 90b5ed8:	dec00204 	addi	sp,sp,8
 90b5edc:	f800283a 	ret

090b5ee0 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 90b5ee0:	defffc04 	addi	sp,sp,-16
 90b5ee4:	dfc00315 	stw	ra,12(sp)
 90b5ee8:	df000215 	stw	fp,8(sp)
 90b5eec:	df000204 	addi	fp,sp,8
 90b5ef0:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 90b5ef4:	e0bfff17 	ldw	r2,-4(fp)
 90b5ef8:	10802017 	ldw	r2,128(r2)
 90b5efc:	1007d0ba 	srai	r3,r2,2
 90b5f00:	e0bfff17 	ldw	r2,-4(fp)
 90b5f04:	10802117 	ldw	r2,132(r2)
 90b5f08:	1885883a 	add	r2,r3,r2
 90b5f0c:	1005d07a 	srai	r2,r2,1
 90b5f10:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 90b5f14:	e0bfff17 	ldw	r2,-4(fp)
 90b5f18:	10800317 	ldw	r2,12(r2)
 90b5f1c:	1005003a 	cmpeq	r2,r2,zero
 90b5f20:	1000031e 	bne	r2,zero,90b5f30 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 90b5f24:	01024374 	movhi	r4,2317
 90b5f28:	213f9604 	addi	r4,r4,-424
 90b5f2c:	90a438c0 	call	90a438c <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 90b5f30:	e0bfff17 	ldw	r2,-4(fp)
 90b5f34:	10c00717 	ldw	r3,28(r2)
 90b5f38:	00824374 	movhi	r2,2317
 90b5f3c:	108ac8c4 	addi	r2,r2,11043
 90b5f40:	10c5883a 	add	r2,r2,r3
 90b5f44:	10800003 	ldbu	r2,0(r2)
 90b5f48:	10c03fcc 	andi	r3,r2,255
 90b5f4c:	e0bffe17 	ldw	r2,-8(fp)
 90b5f50:	1885383a 	mul	r2,r3,r2
 90b5f54:	10ffffcc 	andi	r3,r2,65535
 90b5f58:	18e0001c 	xori	r3,r3,32768
 90b5f5c:	18e00004 	addi	r3,r3,-32768
 90b5f60:	e0bfff17 	ldw	r2,-4(fp)
 90b5f64:	10c00415 	stw	r3,16(r2)
 90b5f68:	e0bfff17 	ldw	r2,-4(fp)
 90b5f6c:	10800417 	ldw	r2,16(r2)
 90b5f70:	10800288 	cmpgei	r2,r2,10
 90b5f74:	1000041e 	bne	r2,zero,90b5f88 <tcp_setpersist+0xa8>
 90b5f78:	e0ffff17 	ldw	r3,-4(fp)
 90b5f7c:	00800284 	movi	r2,10
 90b5f80:	18800415 	stw	r2,16(r3)
 90b5f84:	00000706 	br	90b5fa4 <tcp_setpersist+0xc4>
 90b5f88:	e0bfff17 	ldw	r2,-4(fp)
 90b5f8c:	10800417 	ldw	r2,16(r2)
 90b5f90:	10801e50 	cmplti	r2,r2,121
 90b5f94:	1000031e 	bne	r2,zero,90b5fa4 <tcp_setpersist+0xc4>
 90b5f98:	e0ffff17 	ldw	r3,-4(fp)
 90b5f9c:	00801e04 	movi	r2,120
 90b5fa0:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 90b5fa4:	e0bfff17 	ldw	r2,-4(fp)
 90b5fa8:	10800717 	ldw	r2,28(r2)
 90b5fac:	10800308 	cmpgei	r2,r2,12
 90b5fb0:	1000051e 	bne	r2,zero,90b5fc8 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 90b5fb4:	e0bfff17 	ldw	r2,-4(fp)
 90b5fb8:	10800717 	ldw	r2,28(r2)
 90b5fbc:	10c00044 	addi	r3,r2,1
 90b5fc0:	e0bfff17 	ldw	r2,-4(fp)
 90b5fc4:	10c00715 	stw	r3,28(r2)

}
 90b5fc8:	e037883a 	mov	sp,fp
 90b5fcc:	dfc00117 	ldw	ra,4(sp)
 90b5fd0:	df000017 	ldw	fp,0(sp)
 90b5fd4:	dec00204 	addi	sp,sp,8
 90b5fd8:	f800283a 	ret

090b5fdc <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 90b5fdc:	defff704 	addi	sp,sp,-36
 90b5fe0:	dfc00815 	stw	ra,32(sp)
 90b5fe4:	df000715 	stw	fp,28(sp)
 90b5fe8:	df000704 	addi	fp,sp,28
 90b5fec:	e13ffb15 	stw	r4,-20(fp)
 90b5ff0:	e17ffc15 	stw	r5,-16(fp)
 90b5ff4:	e1bffd15 	stw	r6,-12(fp)
 90b5ff8:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 90b5ffc:	e0bffb17 	ldw	r2,-20(fp)
 90b6000:	10800b0b 	ldhu	r2,44(r2)
 90b6004:	10bfffcc 	andi	r2,r2,65535
 90b6008:	1080020c 	andi	r2,r2,8
 90b600c:	1005003a 	cmpeq	r2,r2,zero
 90b6010:	1000021e 	bne	r2,zero,90b601c <bld_options+0x40>
      return 0;
 90b6014:	e03fff15 	stw	zero,-4(fp)
 90b6018:	00002406 	br	90b60ac <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 90b601c:	e0bffd17 	ldw	r2,-12(fp)
 90b6020:	1080008c 	andi	r2,r2,2
 90b6024:	1005003a 	cmpeq	r2,r2,zero
 90b6028:	10001d1e 	bne	r2,zero,90b60a0 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 90b602c:	e13ffe17 	ldw	r4,-8(fp)
 90b6030:	90b4c480 	call	90b4c48 <tcp_mss>
 90b6034:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 90b6038:	e0fffc17 	ldw	r3,-16(fp)
 90b603c:	00800084 	movi	r2,2
 90b6040:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 90b6044:	e0bffc17 	ldw	r2,-16(fp)
 90b6048:	10c00044 	addi	r3,r2,1
 90b604c:	00800104 	movi	r2,4
 90b6050:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 90b6054:	e0bffc17 	ldw	r2,-16(fp)
 90b6058:	10c00084 	addi	r3,r2,2
 90b605c:	e0bff90b 	ldhu	r2,-28(fp)
 90b6060:	10bfc00c 	andi	r2,r2,65280
 90b6064:	1005d23a 	srai	r2,r2,8
 90b6068:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 90b606c:	e0bffc17 	ldw	r2,-16(fp)
 90b6070:	110000c4 	addi	r4,r2,3
 90b6074:	e0bff90b 	ldhu	r2,-28(fp)
 90b6078:	1007883a 	mov	r3,r2
 90b607c:	00bfffc4 	movi	r2,-1
 90b6080:	1884703a 	and	r2,r3,r2
 90b6084:	20800005 	stb	r2,0(r4)
      len = 4;
 90b6088:	00800104 	movi	r2,4
 90b608c:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 90b6090:	e0bffc17 	ldw	r2,-16(fp)
 90b6094:	10800104 	addi	r2,r2,4
 90b6098:	e0bffc15 	stw	r2,-16(fp)
 90b609c:	00000106 	br	90b60a4 <bld_options+0xc8>
   }
   else
      len = 0;
 90b60a0:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 90b60a4:	e0bffa17 	ldw	r2,-24(fp)
 90b60a8:	e0bfff15 	stw	r2,-4(fp)
 90b60ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90b60b0:	e037883a 	mov	sp,fp
 90b60b4:	dfc00117 	ldw	ra,4(sp)
 90b60b8:	df000017 	ldw	fp,0(sp)
 90b60bc:	dec00204 	addi	sp,sp,8
 90b60c0:	f800283a 	ret

090b60c4 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 90b60c4:	deffff04 	addi	sp,sp,-4
 90b60c8:	df000015 	stw	fp,0(sp)
 90b60cc:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 90b60d0:	00c24374 	movhi	r3,2317
 90b60d4:	18cc4f04 	addi	r3,r3,12604
 90b60d8:	00800044 	movi	r2,1
 90b60dc:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 90b60e0:	00c243b4 	movhi	r3,2318
 90b60e4:	18f58304 	addi	r3,r3,-10740
 90b60e8:	008243b4 	movhi	r2,2318
 90b60ec:	10b58304 	addi	r2,r2,-10740
 90b60f0:	18800115 	stw	r2,4(r3)
 90b60f4:	008243b4 	movhi	r2,2318
 90b60f8:	10b58304 	addi	r2,r2,-10740
 90b60fc:	10c00117 	ldw	r3,4(r2)
 90b6100:	008243b4 	movhi	r2,2318
 90b6104:	10b58304 	addi	r2,r2,-10740
 90b6108:	10c00015 	stw	r3,0(r2)
}
 90b610c:	e037883a 	mov	sp,fp
 90b6110:	df000017 	ldw	fp,0(sp)
 90b6114:	dec00104 	addi	sp,sp,4
 90b6118:	f800283a 	ret

090b611c <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 90b611c:	defffa04 	addi	sp,sp,-24
 90b6120:	dfc00515 	stw	ra,20(sp)
 90b6124:	df000415 	stw	fp,16(sp)
 90b6128:	df000404 	addi	fp,sp,16
 90b612c:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 90b6130:	e0bffe17 	ldw	r2,-8(fp)
 90b6134:	10800d17 	ldw	r2,52(r2)
 90b6138:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 90b613c:	e0bffe17 	ldw	r2,-8(fp)
 90b6140:	10800c17 	ldw	r2,48(r2)
 90b6144:	e0bffc15 	stw	r2,-16(fp)
 90b6148:	e0bffc17 	ldw	r2,-16(fp)
 90b614c:	1004c03a 	cmpne	r2,r2,zero
 90b6150:	1000081e 	bne	r2,zero,90b6174 <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 90b6154:	01000a04 	movi	r4,40
 90b6158:	90a9f0c0 	call	90a9f0c <npalloc>
 90b615c:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 90b6160:	e0bffc17 	ldw	r2,-16(fp)
 90b6164:	1004c03a 	cmpne	r2,r2,zero
 90b6168:	1000021e 	bne	r2,zero,90b6174 <tcp_template+0x58>
         return (0);
 90b616c:	e03fff15 	stw	zero,-4(fp)
 90b6170:	00002a06 	br	90b621c <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 90b6174:	e0bffc17 	ldw	r2,-16(fp)
 90b6178:	10000115 	stw	zero,4(r2)
 90b617c:	e0bffc17 	ldw	r2,-16(fp)
 90b6180:	10c00117 	ldw	r3,4(r2)
 90b6184:	e0bffc17 	ldw	r2,-16(fp)
 90b6188:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 90b618c:	e0fffc17 	ldw	r3,-16(fp)
 90b6190:	00850004 	movi	r2,5120
 90b6194:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 90b6198:	e0bffd17 	ldw	r2,-12(fp)
 90b619c:	10c00417 	ldw	r3,16(r2)
 90b61a0:	e0bffc17 	ldw	r2,-16(fp)
 90b61a4:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 90b61a8:	e0bffd17 	ldw	r2,-12(fp)
 90b61ac:	10c00317 	ldw	r3,12(r2)
 90b61b0:	e0bffc17 	ldw	r2,-16(fp)
 90b61b4:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 90b61b8:	e0bffd17 	ldw	r2,-12(fp)
 90b61bc:	10c0078b 	ldhu	r3,30(r2)
 90b61c0:	e0bffc17 	ldw	r2,-16(fp)
 90b61c4:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 90b61c8:	e0bffd17 	ldw	r2,-12(fp)
 90b61cc:	10c0070b 	ldhu	r3,28(r2)
 90b61d0:	e0bffc17 	ldw	r2,-16(fp)
 90b61d4:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 90b61d8:	e0bffc17 	ldw	r2,-16(fp)
 90b61dc:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 90b61e0:	e0bffc17 	ldw	r2,-16(fp)
 90b61e4:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 90b61e8:	e0fffc17 	ldw	r3,-16(fp)
 90b61ec:	00801404 	movi	r2,80
 90b61f0:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 90b61f4:	e0bffc17 	ldw	r2,-16(fp)
 90b61f8:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 90b61fc:	e0bffc17 	ldw	r2,-16(fp)
 90b6200:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 90b6204:	e0bffc17 	ldw	r2,-16(fp)
 90b6208:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 90b620c:	e0bffc17 	ldw	r2,-16(fp)
 90b6210:	1000098d 	sth	zero,38(r2)
   return (n);
 90b6214:	e0bffc17 	ldw	r2,-16(fp)
 90b6218:	e0bfff15 	stw	r2,-4(fp)
 90b621c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b6220:	e037883a 	mov	sp,fp
 90b6224:	dfc00117 	ldw	ra,4(sp)
 90b6228:	df000017 	ldw	fp,0(sp)
 90b622c:	dec00204 	addi	sp,sp,8
 90b6230:	f800283a 	ret

090b6234 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 90b6234:	defff104 	addi	sp,sp,-60
 90b6238:	dfc00e15 	stw	ra,56(sp)
 90b623c:	df000d15 	stw	fp,52(sp)
 90b6240:	df000d04 	addi	fp,sp,52
 90b6244:	e13ffb15 	stw	r4,-20(fp)
 90b6248:	e17ffc15 	stw	r5,-16(fp)
 90b624c:	e1bffd15 	stw	r6,-12(fp)
 90b6250:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 90b6254:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 90b6258:	e0bffb17 	ldw	r2,-20(fp)
 90b625c:	1005003a 	cmpeq	r2,r2,zero
 90b6260:	10001a1e 	bne	r2,zero,90b62cc <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 90b6264:	e0bffb17 	ldw	r2,-20(fp)
 90b6268:	10800d17 	ldw	r2,52(r2)
 90b626c:	10800817 	ldw	r2,32(r2)
 90b6270:	10800b17 	ldw	r2,44(r2)
 90b6274:	1007883a 	mov	r3,r2
 90b6278:	e0bffb17 	ldw	r2,-20(fp)
 90b627c:	10800d17 	ldw	r2,52(r2)
 90b6280:	10800817 	ldw	r2,32(r2)
 90b6284:	10800a17 	ldw	r2,40(r2)
 90b6288:	1885c83a 	sub	r2,r3,r2
 90b628c:	1004803a 	cmplt	r2,r2,zero
 90b6290:	10000b1e 	bne	r2,zero,90b62c0 <tcp_respond+0x8c>
 90b6294:	e0bffb17 	ldw	r2,-20(fp)
 90b6298:	10800d17 	ldw	r2,52(r2)
 90b629c:	10800817 	ldw	r2,32(r2)
 90b62a0:	10c00b17 	ldw	r3,44(r2)
 90b62a4:	e0bffb17 	ldw	r2,-20(fp)
 90b62a8:	10800d17 	ldw	r2,52(r2)
 90b62ac:	10800817 	ldw	r2,32(r2)
 90b62b0:	10800a17 	ldw	r2,40(r2)
 90b62b4:	1885c83a 	sub	r2,r3,r2
 90b62b8:	e0bfff15 	stw	r2,-4(fp)
 90b62bc:	00000106 	br	90b62c4 <tcp_respond+0x90>
 90b62c0:	e03fff15 	stw	zero,-4(fp)
 90b62c4:	e0bfff17 	ldw	r2,-4(fp)
 90b62c8:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 90b62cc:	e0800217 	ldw	r2,8(fp)
 90b62d0:	1004c03a 	cmpne	r2,r2,zero
 90b62d4:	1000391e 	bne	r2,zero,90b63bc <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 90b62d8:	010000c4 	movi	r4,3
 90b62dc:	01401004 	movi	r5,64
 90b62e0:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b62e4:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 90b62e8:	e0bff717 	ldw	r2,-36(fp)
 90b62ec:	1005003a 	cmpeq	r2,r2,zero
 90b62f0:	1000ed1e 	bne	r2,zero,90b66a8 <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 90b62f4:	00800044 	movi	r2,1
 90b62f8:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 90b62fc:	e0bffa17 	ldw	r2,-24(fp)
 90b6300:	10800a04 	addi	r2,r2,40
 90b6304:	1007883a 	mov	r3,r2
 90b6308:	e0bff717 	ldw	r2,-36(fp)
 90b630c:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 90b6310:	e0bff717 	ldw	r2,-36(fp)
 90b6314:	10800317 	ldw	r2,12(r2)
 90b6318:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 90b631c:	e0bff717 	ldw	r2,-36(fp)
 90b6320:	10800117 	ldw	r2,4(r2)
 90b6324:	10c00117 	ldw	r3,4(r2)
 90b6328:	e0bff617 	ldw	r2,-40(fp)
 90b632c:	10c0032e 	bgeu	r2,r3,90b633c <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 90b6330:	01024374 	movhi	r4,2317
 90b6334:	213f9b04 	addi	r4,r4,-404
 90b6338:	90a438c0 	call	90a438c <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 90b633c:	e13ff617 	ldw	r4,-40(fp)
 90b6340:	e0fffc17 	ldw	r3,-16(fp)
 90b6344:	18800017 	ldw	r2,0(r3)
 90b6348:	20800015 	stw	r2,0(r4)
 90b634c:	18800117 	ldw	r2,4(r3)
 90b6350:	20800115 	stw	r2,4(r4)
 90b6354:	18800217 	ldw	r2,8(r3)
 90b6358:	20800215 	stw	r2,8(r4)
 90b635c:	18800317 	ldw	r2,12(r3)
 90b6360:	20800315 	stw	r2,12(r4)
 90b6364:	18800417 	ldw	r2,16(r3)
 90b6368:	20800415 	stw	r2,16(r4)
 90b636c:	18800517 	ldw	r2,20(r3)
 90b6370:	20800515 	stw	r2,20(r4)
 90b6374:	18800617 	ldw	r2,24(r3)
 90b6378:	20800615 	stw	r2,24(r4)
 90b637c:	18800717 	ldw	r2,28(r3)
 90b6380:	20800715 	stw	r2,28(r4)
 90b6384:	18800817 	ldw	r2,32(r3)
 90b6388:	20800815 	stw	r2,32(r4)
 90b638c:	18800917 	ldw	r2,36(r3)
 90b6390:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 90b6394:	e0bff617 	ldw	r2,-40(fp)
 90b6398:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 90b639c:	00800404 	movi	r2,16
 90b63a0:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 90b63a4:	e0bffb17 	ldw	r2,-20(fp)
 90b63a8:	10800d17 	ldw	r2,52(r2)
 90b63ac:	10800817 	ldw	r2,32(r2)
 90b63b0:	10800517 	ldw	r2,20(r2)
 90b63b4:	e0bff915 	stw	r2,-28(fp)
 90b63b8:	00003b06 	br	90b64a8 <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 90b63bc:	e0800317 	ldw	r2,12(fp)
 90b63c0:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 90b63c4:	e0bff717 	ldw	r2,-36(fp)
 90b63c8:	10800117 	ldw	r2,4(r2)
 90b63cc:	1080080b 	ldhu	r2,32(r2)
 90b63d0:	10bfffcc 	andi	r2,r2,65535
 90b63d4:	10800218 	cmpnei	r2,r2,8
 90b63d8:	1000031e 	bne	r2,zero,90b63e8 <tcp_respond+0x1b4>
         domain = AF_INET;
 90b63dc:	00800084 	movi	r2,2
 90b63e0:	e0bff915 	stw	r2,-28(fp)
 90b63e4:	00000206 	br	90b63f0 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 90b63e8:	008000c4 	movi	r2,3
 90b63ec:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 90b63f0:	e0bff717 	ldw	r2,-36(fp)
 90b63f4:	11000617 	ldw	r4,24(r2)
 90b63f8:	90aa5a40 	call	90aa5a4 <m_freem>
      m->m_next = 0;
 90b63fc:	e0bff717 	ldw	r2,-36(fp)
 90b6400:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 90b6404:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 90b6408:	e0fff717 	ldw	r3,-36(fp)
 90b640c:	00800a04 	movi	r2,40
 90b6410:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 90b6414:	e0bffc17 	ldw	r2,-16(fp)
 90b6418:	1080058b 	ldhu	r2,22(r2)
 90b641c:	e0bff50d 	sth	r2,-44(fp)
 90b6420:	e0bffc17 	ldw	r2,-16(fp)
 90b6424:	10c0050b 	ldhu	r3,20(r2)
 90b6428:	e0bffc17 	ldw	r2,-16(fp)
 90b642c:	10c0058d 	sth	r3,22(r2)
 90b6430:	e0fffc17 	ldw	r3,-16(fp)
 90b6434:	e0bff50b 	ldhu	r2,-44(fp)
 90b6438:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 90b643c:	e0bff717 	ldw	r2,-36(fp)
 90b6440:	10800117 	ldw	r2,4(r2)
 90b6444:	1080080b 	ldhu	r2,32(r2)
 90b6448:	10bfffcc 	andi	r2,r2,65535
 90b644c:	10800218 	cmpnei	r2,r2,8
 90b6450:	10000a1e 	bne	r2,zero,90b647c <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 90b6454:	e0bffc17 	ldw	r2,-16(fp)
 90b6458:	10800417 	ldw	r2,16(r2)
 90b645c:	e0bff415 	stw	r2,-48(fp)
 90b6460:	e0bffc17 	ldw	r2,-16(fp)
 90b6464:	10c00317 	ldw	r3,12(r2)
 90b6468:	e0bffc17 	ldw	r2,-16(fp)
 90b646c:	10c00415 	stw	r3,16(r2)
 90b6470:	e0fffc17 	ldw	r3,-16(fp)
 90b6474:	e0bff417 	ldw	r2,-48(fp)
 90b6478:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 90b647c:	e0800217 	ldw	r2,8(fp)
 90b6480:	1080010c 	andi	r2,r2,4
 90b6484:	1005003a 	cmpeq	r2,r2,zero
 90b6488:	1000071e 	bne	r2,zero,90b64a8 <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 90b648c:	008243b4 	movhi	r2,2318
 90b6490:	10b56004 	addi	r2,r2,-10880
 90b6494:	10800e17 	ldw	r2,56(r2)
 90b6498:	10c00044 	addi	r3,r2,1
 90b649c:	008243b4 	movhi	r2,2318
 90b64a0:	10b56004 	addi	r2,r2,-10880
 90b64a4:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 90b64a8:	e0bffe17 	ldw	r2,-8(fp)
 90b64ac:	1004d63a 	srli	r2,r2,24
 90b64b0:	10c03fcc 	andi	r3,r2,255
 90b64b4:	e0bffe17 	ldw	r2,-8(fp)
 90b64b8:	1004d23a 	srli	r2,r2,8
 90b64bc:	10bfc00c 	andi	r2,r2,65280
 90b64c0:	1886b03a 	or	r3,r3,r2
 90b64c4:	e0bffe17 	ldw	r2,-8(fp)
 90b64c8:	10bfc00c 	andi	r2,r2,65280
 90b64cc:	1004923a 	slli	r2,r2,8
 90b64d0:	1886b03a 	or	r3,r3,r2
 90b64d4:	e0bffe17 	ldw	r2,-8(fp)
 90b64d8:	10803fcc 	andi	r2,r2,255
 90b64dc:	1004963a 	slli	r2,r2,24
 90b64e0:	1886b03a 	or	r3,r3,r2
 90b64e4:	e0bffc17 	ldw	r2,-16(fp)
 90b64e8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 90b64ec:	e0bffd17 	ldw	r2,-12(fp)
 90b64f0:	1004d63a 	srli	r2,r2,24
 90b64f4:	10c03fcc 	andi	r3,r2,255
 90b64f8:	e0bffd17 	ldw	r2,-12(fp)
 90b64fc:	1004d23a 	srli	r2,r2,8
 90b6500:	10bfc00c 	andi	r2,r2,65280
 90b6504:	1886b03a 	or	r3,r3,r2
 90b6508:	e0bffd17 	ldw	r2,-12(fp)
 90b650c:	10bfc00c 	andi	r2,r2,65280
 90b6510:	1004923a 	slli	r2,r2,8
 90b6514:	1886b03a 	or	r3,r3,r2
 90b6518:	e0bffd17 	ldw	r2,-12(fp)
 90b651c:	10803fcc 	andi	r2,r2,255
 90b6520:	1004963a 	slli	r2,r2,24
 90b6524:	1886b03a 	or	r3,r3,r2
 90b6528:	e0bffc17 	ldw	r2,-16(fp)
 90b652c:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 90b6530:	e0fffc17 	ldw	r3,-16(fp)
 90b6534:	00801404 	movi	r2,80
 90b6538:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 90b653c:	e0800217 	ldw	r2,8(fp)
 90b6540:	1007883a 	mov	r3,r2
 90b6544:	e0bffc17 	ldw	r2,-16(fp)
 90b6548:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 90b654c:	e0bff817 	ldw	r2,-32(fp)
 90b6550:	10bfffcc 	andi	r2,r2,65535
 90b6554:	1004d23a 	srli	r2,r2,8
 90b6558:	10803fcc 	andi	r2,r2,255
 90b655c:	1009883a 	mov	r4,r2
 90b6560:	e0bff817 	ldw	r2,-32(fp)
 90b6564:	10bfffcc 	andi	r2,r2,65535
 90b6568:	1004923a 	slli	r2,r2,8
 90b656c:	1007883a 	mov	r3,r2
 90b6570:	00bfc004 	movi	r2,-256
 90b6574:	1884703a 	and	r2,r3,r2
 90b6578:	2084b03a 	or	r2,r4,r2
 90b657c:	1007883a 	mov	r3,r2
 90b6580:	e0bffc17 	ldw	r2,-16(fp)
 90b6584:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 90b6588:	e0bffc17 	ldw	r2,-16(fp)
 90b658c:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 90b6590:	e0bff917 	ldw	r2,-28(fp)
 90b6594:	108000a0 	cmpeqi	r2,r2,2
 90b6598:	1000011e 	bne	r2,zero,90b65a0 <tcp_respond+0x36c>
 90b659c:	00004106 	br	90b66a4 <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 90b65a0:	e0bffc17 	ldw	r2,-16(fp)
 90b65a4:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 90b65a8:	e0bffa17 	ldw	r2,-24(fp)
 90b65ac:	10800a04 	addi	r2,r2,40
 90b65b0:	1007883a 	mov	r3,r2
 90b65b4:	e0bff317 	ldw	r2,-52(fp)
 90b65b8:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 90b65bc:	e0bff717 	ldw	r2,-36(fp)
 90b65c0:	10800117 	ldw	r2,4(r2)
 90b65c4:	10c00117 	ldw	r3,4(r2)
 90b65c8:	00824374 	movhi	r2,2317
 90b65cc:	108c1b04 	addi	r2,r2,12396
 90b65d0:	10800017 	ldw	r2,0(r2)
 90b65d4:	1885883a 	add	r2,r3,r2
 90b65d8:	1007883a 	mov	r3,r2
 90b65dc:	e0bff317 	ldw	r2,-52(fp)
 90b65e0:	10c00436 	bltu	r2,r3,90b65f4 <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 90b65e4:	e0fff317 	ldw	r3,-52(fp)
 90b65e8:	e0bff717 	ldw	r2,-36(fp)
 90b65ec:	10c00315 	stw	r3,12(r2)
 90b65f0:	00001206 	br	90b663c <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 90b65f4:	e0bff717 	ldw	r2,-36(fp)
 90b65f8:	11000117 	ldw	r4,4(r2)
 90b65fc:	e0bff717 	ldw	r2,-36(fp)
 90b6600:	10800117 	ldw	r2,4(r2)
 90b6604:	10c00117 	ldw	r3,4(r2)
 90b6608:	00824374 	movhi	r2,2317
 90b660c:	108c1b04 	addi	r2,r2,12396
 90b6610:	10800017 	ldw	r2,0(r2)
 90b6614:	1885883a 	add	r2,r3,r2
 90b6618:	20800315 	stw	r2,12(r4)
 90b661c:	20c00317 	ldw	r3,12(r4)
 90b6620:	e0bff717 	ldw	r2,-36(fp)
 90b6624:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 90b6628:	e0bff717 	ldw	r2,-36(fp)
 90b662c:	11000317 	ldw	r4,12(r2)
 90b6630:	e17ff317 	ldw	r5,-52(fp)
 90b6634:	01800a04 	movi	r6,40
 90b6638:	90823180 	call	9082318 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 90b663c:	e0bffb17 	ldw	r2,-20(fp)
 90b6640:	1004c03a 	cmpne	r2,r2,zero
 90b6644:	1000031e 	bne	r2,zero,90b6654 <tcp_respond+0x420>
              m_freem(m);
 90b6648:	e13ff717 	ldw	r4,-36(fp)
 90b664c:	90aa5a40 	call	90aa5a4 <m_freem>
 90b6650:	00001506 	br	90b66a8 <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 90b6654:	e0bffb17 	ldw	r2,-20(fp)
 90b6658:	10800d17 	ldw	r2,52(r2)
 90b665c:	1005003a 	cmpeq	r2,r2,zero
 90b6660:	10000c1e 	bne	r2,zero,90b6694 <tcp_respond+0x460>
 90b6664:	e0bffb17 	ldw	r2,-20(fp)
 90b6668:	10800d17 	ldw	r2,52(r2)
 90b666c:	10800817 	ldw	r2,32(r2)
 90b6670:	1005003a 	cmpeq	r2,r2,zero
 90b6674:	1000071e 	bne	r2,zero,90b6694 <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 90b6678:	e0bffb17 	ldw	r2,-20(fp)
 90b667c:	10800d17 	ldw	r2,52(r2)
 90b6680:	10800817 	ldw	r2,32(r2)
 90b6684:	11401f17 	ldw	r5,124(r2)
 90b6688:	e13ff717 	ldw	r4,-36(fp)
 90b668c:	90aafd80 	call	90aafd8 <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 90b6690:	00000506 	br	90b66a8 <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 90b6694:	e13ff717 	ldw	r4,-36(fp)
 90b6698:	000b883a 	mov	r5,zero
 90b669c:	90aafd80 	call	90aafd8 <ip_output>
		 }

         break;
 90b66a0:	00000106 	br	90b66a8 <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 90b66a4:	90a94880 	call	90a9488 <dtrap>
         break;
   }
   return;
}
 90b66a8:	e037883a 	mov	sp,fp
 90b66ac:	dfc00117 	ldw	ra,4(sp)
 90b66b0:	df000017 	ldw	fp,0(sp)
 90b66b4:	dec00204 	addi	sp,sp,8
 90b66b8:	f800283a 	ret

090b66bc <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 90b66bc:	defffa04 	addi	sp,sp,-24
 90b66c0:	dfc00515 	stw	ra,20(sp)
 90b66c4:	df000415 	stw	fp,16(sp)
 90b66c8:	df000404 	addi	fp,sp,16
 90b66cc:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 90b66d0:	01002504 	movi	r4,148
 90b66d4:	90a9f0c0 	call	90a9f0c <npalloc>
 90b66d8:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 90b66dc:	e0bffd17 	ldw	r2,-12(fp)
 90b66e0:	1004c03a 	cmpne	r2,r2,zero
 90b66e4:	1000021e 	bne	r2,zero,90b66f0 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 90b66e8:	e03fff15 	stw	zero,-4(fp)
 90b66ec:	00003306 	br	90b67bc <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 90b66f0:	e0fffd17 	ldw	r3,-12(fp)
 90b66f4:	e0bffd17 	ldw	r2,-12(fp)
 90b66f8:	10c00115 	stw	r3,4(r2)
 90b66fc:	e0bffd17 	ldw	r2,-12(fp)
 90b6700:	10c00117 	ldw	r3,4(r2)
 90b6704:	e0bffd17 	ldw	r2,-12(fp)
 90b6708:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 90b670c:	e0fffd17 	ldw	r3,-12(fp)
 90b6710:	00816d04 	movi	r2,1460
 90b6714:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 90b6718:	e0bffd17 	ldw	r2,-12(fp)
 90b671c:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 90b6720:	e0fffd17 	ldw	r3,-12(fp)
 90b6724:	e0bffe17 	ldw	r2,-8(fp)
 90b6728:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 90b672c:	e0bffd17 	ldw	r2,-12(fp)
 90b6730:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 90b6734:	e0fffd17 	ldw	r3,-12(fp)
 90b6738:	00800604 	movi	r2,24
 90b673c:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 90b6740:	00800304 	movi	r2,12
 90b6744:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 90b6748:	e0fffc0f 	ldh	r3,-16(fp)
 90b674c:	e0bffd17 	ldw	r2,-12(fp)
 90b6750:	10c00815 	stw	r3,32(r2)
 90b6754:	e0bffd17 	ldw	r2,-12(fp)
 90b6758:	10800817 	ldw	r2,32(r2)
 90b675c:	10800088 	cmpgei	r2,r2,2
 90b6760:	1000041e 	bne	r2,zero,90b6774 <tcp_newtcpcb+0xb8>
 90b6764:	e0fffd17 	ldw	r3,-12(fp)
 90b6768:	00800084 	movi	r2,2
 90b676c:	18800815 	stw	r2,32(r3)
 90b6770:	00000706 	br	90b6790 <tcp_newtcpcb+0xd4>
 90b6774:	e0bffd17 	ldw	r2,-12(fp)
 90b6778:	10800817 	ldw	r2,32(r2)
 90b677c:	10802050 	cmplti	r2,r2,129
 90b6780:	1000031e 	bne	r2,zero,90b6790 <tcp_newtcpcb+0xd4>
 90b6784:	e0fffd17 	ldw	r3,-12(fp)
 90b6788:	00802004 	movi	r2,128
 90b678c:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 90b6790:	e0fffd17 	ldw	r3,-12(fp)
 90b6794:	0082da04 	movi	r2,2920
 90b6798:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 90b679c:	e0fffd17 	ldw	r3,-12(fp)
 90b67a0:	00bfffd4 	movui	r2,65535
 90b67a4:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 90b67a8:	e0fffd17 	ldw	r3,-12(fp)
 90b67ac:	e0bffe17 	ldw	r2,-8(fp)
 90b67b0:	10c00915 	stw	r3,36(r2)
   return (tp);
 90b67b4:	e0bffd17 	ldw	r2,-12(fp)
 90b67b8:	e0bfff15 	stw	r2,-4(fp)
 90b67bc:	e0bfff17 	ldw	r2,-4(fp)
}
 90b67c0:	e037883a 	mov	sp,fp
 90b67c4:	dfc00117 	ldw	ra,4(sp)
 90b67c8:	df000017 	ldw	fp,0(sp)
 90b67cc:	dec00204 	addi	sp,sp,8
 90b67d0:	f800283a 	ret

090b67d4 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 90b67d4:	defffb04 	addi	sp,sp,-20
 90b67d8:	dfc00415 	stw	ra,16(sp)
 90b67dc:	df000315 	stw	fp,12(sp)
 90b67e0:	df000304 	addi	fp,sp,12
 90b67e4:	e13ffe15 	stw	r4,-8(fp)
 90b67e8:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b67ec:	e0bffe17 	ldw	r2,-8(fp)
 90b67f0:	10800d17 	ldw	r2,52(r2)
 90b67f4:	10800817 	ldw	r2,32(r2)
 90b67f8:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 90b67fc:	e0bffe17 	ldw	r2,-8(fp)
 90b6800:	10800217 	ldw	r2,8(r2)
 90b6804:	108000d0 	cmplti	r2,r2,3
 90b6808:	10000c1e 	bne	r2,zero,90b683c <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 90b680c:	e0bffe17 	ldw	r2,-8(fp)
 90b6810:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 90b6814:	e13ffe17 	ldw	r4,-8(fp)
 90b6818:	90b4d640 	call	90b4d64 <tcp_output>
      tcpstat.tcps_drops++;
 90b681c:	008243b4 	movhi	r2,2318
 90b6820:	10b58e04 	addi	r2,r2,-10696
 90b6824:	10800317 	ldw	r2,12(r2)
 90b6828:	10c00044 	addi	r3,r2,1
 90b682c:	008243b4 	movhi	r2,2318
 90b6830:	10b58e04 	addi	r2,r2,-10696
 90b6834:	10c00315 	stw	r3,12(r2)
 90b6838:	00000706 	br	90b6858 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 90b683c:	008243b4 	movhi	r2,2318
 90b6840:	10b58e04 	addi	r2,r2,-10696
 90b6844:	10800417 	ldw	r2,16(r2)
 90b6848:	10c00044 	addi	r3,r2,1
 90b684c:	008243b4 	movhi	r2,2318
 90b6850:	10b58e04 	addi	r2,r2,-10696
 90b6854:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 90b6858:	e0fffd17 	ldw	r3,-12(fp)
 90b685c:	e0bfff17 	ldw	r2,-4(fp)
 90b6860:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 90b6864:	e13ffe17 	ldw	r4,-8(fp)
 90b6868:	90b68800 	call	90b6880 <tcp_close>
}
 90b686c:	e037883a 	mov	sp,fp
 90b6870:	dfc00117 	ldw	ra,4(sp)
 90b6874:	df000017 	ldw	fp,0(sp)
 90b6878:	dec00204 	addi	sp,sp,8
 90b687c:	f800283a 	ret

090b6880 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 90b6880:	defff904 	addi	sp,sp,-28
 90b6884:	dfc00615 	stw	ra,24(sp)
 90b6888:	df000515 	stw	fp,20(sp)
 90b688c:	df000504 	addi	fp,sp,20
 90b6890:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 90b6894:	e0bfff17 	ldw	r2,-4(fp)
 90b6898:	10800d17 	ldw	r2,52(r2)
 90b689c:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 90b68a0:	e0bffd17 	ldw	r2,-12(fp)
 90b68a4:	10800817 	ldw	r2,32(r2)
 90b68a8:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 90b68ac:	e0bfff17 	ldw	r2,-4(fp)
 90b68b0:	10800017 	ldw	r2,0(r2)
 90b68b4:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 90b68b8:	00000c06 	br	90b68ec <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 90b68bc:	e0bffe17 	ldw	r2,-8(fp)
 90b68c0:	10800017 	ldw	r2,0(r2)
 90b68c4:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 90b68c8:	e0bffe17 	ldw	r2,-8(fp)
 90b68cc:	11000117 	ldw	r4,4(r2)
 90b68d0:	90aab340 	call	90aab34 <dtom>
 90b68d4:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 90b68d8:	e0bffe17 	ldw	r2,-8(fp)
 90b68dc:	11000117 	ldw	r4,4(r2)
 90b68e0:	90aabdc0 	call	90aabdc <remque>
      m_freem (m);
 90b68e4:	e13ffb17 	ldw	r4,-20(fp)
 90b68e8:	90aa5a40 	call	90aa5a4 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 90b68ec:	e0ffff17 	ldw	r3,-4(fp)
 90b68f0:	e0bffe17 	ldw	r2,-8(fp)
 90b68f4:	10fff11e 	bne	r2,r3,90b68bc <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 90b68f8:	e0bfff17 	ldw	r2,-4(fp)
 90b68fc:	10800c17 	ldw	r2,48(r2)
 90b6900:	1005003a 	cmpeq	r2,r2,zero
 90b6904:	1000031e 	bne	r2,zero,90b6914 <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 90b6908:	e0bfff17 	ldw	r2,-4(fp)
 90b690c:	11000c17 	ldw	r4,48(r2)
 90b6910:	90aa0000 	call	90aa000 <npfree>
   TCB_FREE (tp);
 90b6914:	e13fff17 	ldw	r4,-4(fp)
 90b6918:	90aa0000 	call	90aa000 <npfree>
   inp->inp_ppcb = 0;
 90b691c:	e0bffd17 	ldw	r2,-12(fp)
 90b6920:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 90b6924:	e13ffc17 	ldw	r4,-16(fp)
 90b6928:	90b03100 	call	90b0310 <soisdisconnected>
   in_pcbdetach(inp);
 90b692c:	e13ffd17 	ldw	r4,-12(fp)
 90b6930:	90c69940 	call	90c6994 <in_pcbdetach>
   tcpstat.tcps_closed++;
 90b6934:	008243b4 	movhi	r2,2318
 90b6938:	10b58e04 	addi	r2,r2,-10696
 90b693c:	10800517 	ldw	r2,20(r2)
 90b6940:	10c00044 	addi	r3,r2,1
 90b6944:	008243b4 	movhi	r2,2318
 90b6948:	10b58e04 	addi	r2,r2,-10696
 90b694c:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 90b6950:	0005883a 	mov	r2,zero
}
 90b6954:	e037883a 	mov	sp,fp
 90b6958:	dfc00117 	ldw	ra,4(sp)
 90b695c:	df000017 	ldw	fp,0(sp)
 90b6960:	dec00204 	addi	sp,sp,8
 90b6964:	f800283a 	ret

090b6968 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 90b6968:	defffd04 	addi	sp,sp,-12
 90b696c:	df000215 	stw	fp,8(sp)
 90b6970:	df000204 	addi	fp,sp,8
 90b6974:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 90b6978:	e0bfff17 	ldw	r2,-4(fp)
 90b697c:	10800917 	ldw	r2,36(r2)
 90b6980:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 90b6984:	e0bffe17 	ldw	r2,-8(fp)
 90b6988:	1005003a 	cmpeq	r2,r2,zero
 90b698c:	1000051e 	bne	r2,zero,90b69a4 <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 90b6990:	e0bffe17 	ldw	r2,-8(fp)
 90b6994:	10800a0b 	ldhu	r2,40(r2)
 90b6998:	10ffffcc 	andi	r3,r2,65535
 90b699c:	e0bffe17 	ldw	r2,-8(fp)
 90b69a0:	10c01b15 	stw	r3,108(r2)
}
 90b69a4:	e037883a 	mov	sp,fp
 90b69a8:	df000017 	ldw	fp,0(sp)
 90b69ac:	dec00104 	addi	sp,sp,4
 90b69b0:	f800283a 	ret

090b69b4 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 90b69b4:	defffc04 	addi	sp,sp,-16
 90b69b8:	df000315 	stw	fp,12(sp)
 90b69bc:	df000304 	addi	fp,sp,12
 90b69c0:	e13ffe15 	stw	r4,-8(fp)
 90b69c4:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 90b69c8:	e0bffe17 	ldw	r2,-8(fp)
 90b69cc:	108000c4 	addi	r2,r2,3
 90b69d0:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 90b69d4:	e03ffd15 	stw	zero,-12(fp)
 90b69d8:	00000d06 	br	90b6a10 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 90b69dc:	e0bfff17 	ldw	r2,-4(fp)
 90b69e0:	1007883a 	mov	r3,r2
 90b69e4:	e0bffe17 	ldw	r2,-8(fp)
 90b69e8:	10c00005 	stb	r3,0(r2)
 90b69ec:	e0bffe17 	ldw	r2,-8(fp)
 90b69f0:	10bfffc4 	addi	r2,r2,-1
 90b69f4:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 90b69f8:	e0bfff17 	ldw	r2,-4(fp)
 90b69fc:	1004d23a 	srli	r2,r2,8
 90b6a00:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 90b6a04:	e0bffd17 	ldw	r2,-12(fp)
 90b6a08:	10800044 	addi	r2,r2,1
 90b6a0c:	e0bffd15 	stw	r2,-12(fp)
 90b6a10:	e0bffd17 	ldw	r2,-12(fp)
 90b6a14:	10800110 	cmplti	r2,r2,4
 90b6a18:	103ff01e 	bne	r2,zero,90b69dc <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 90b6a1c:	e0bffe17 	ldw	r2,-8(fp)
 90b6a20:	10800144 	addi	r2,r2,5
}
 90b6a24:	e037883a 	mov	sp,fp
 90b6a28:	df000017 	ldw	fp,0(sp)
 90b6a2c:	dec00104 	addi	sp,sp,4
 90b6a30:	f800283a 	ret

090b6a34 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 90b6a34:	defffc04 	addi	sp,sp,-16
 90b6a38:	df000315 	stw	fp,12(sp)
 90b6a3c:	df000304 	addi	fp,sp,12
 90b6a40:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 90b6a44:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 90b6a48:	e03ffe15 	stw	zero,-8(fp)
 90b6a4c:	00000f06 	br	90b6a8c <tcp_getseq+0x58>
   {
      seq <<= 8;
 90b6a50:	e0bffd17 	ldw	r2,-12(fp)
 90b6a54:	1004923a 	slli	r2,r2,8
 90b6a58:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 90b6a5c:	e0bfff17 	ldw	r2,-4(fp)
 90b6a60:	10800003 	ldbu	r2,0(r2)
 90b6a64:	10c03fcc 	andi	r3,r2,255
 90b6a68:	e0bffd17 	ldw	r2,-12(fp)
 90b6a6c:	10c5883a 	add	r2,r2,r3
 90b6a70:	e0bffd15 	stw	r2,-12(fp)
 90b6a74:	e0bfff17 	ldw	r2,-4(fp)
 90b6a78:	10800044 	addi	r2,r2,1
 90b6a7c:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 90b6a80:	e0bffe17 	ldw	r2,-8(fp)
 90b6a84:	10800044 	addi	r2,r2,1
 90b6a88:	e0bffe15 	stw	r2,-8(fp)
 90b6a8c:	e0bffe17 	ldw	r2,-8(fp)
 90b6a90:	10800110 	cmplti	r2,r2,4
 90b6a94:	103fee1e 	bne	r2,zero,90b6a50 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 90b6a98:	e0bffd17 	ldw	r2,-12(fp)
}
 90b6a9c:	e037883a 	mov	sp,fp
 90b6aa0:	df000017 	ldw	fp,0(sp)
 90b6aa4:	dec00104 	addi	sp,sp,4
 90b6aa8:	f800283a 	ret

090b6aac <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 90b6aac:	defff704 	addi	sp,sp,-36
 90b6ab0:	dfc00815 	stw	ra,32(sp)
 90b6ab4:	df000715 	stw	fp,28(sp)
 90b6ab8:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 90b6abc:	d0a03d17 	ldw	r2,-32524(gp)
 90b6ac0:	100490fa 	slli	r2,r2,3
 90b6ac4:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 90b6ac8:	008243b4 	movhi	r2,2318
 90b6acc:	10b55b04 	addi	r2,r2,-10900
 90b6ad0:	10800017 	ldw	r2,0(r2)
 90b6ad4:	e0bffb15 	stw	r2,-20(fp)
 90b6ad8:	00008306 	br	90b6ce8 <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 90b6adc:	e0bffb17 	ldw	r2,-20(fp)
 90b6ae0:	10800017 	ldw	r2,0(r2)
 90b6ae4:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 90b6ae8:	e0bffb17 	ldw	r2,-20(fp)
 90b6aec:	10800983 	ldbu	r2,38(r2)
 90b6af0:	10803fcc 	andi	r2,r2,255
 90b6af4:	1080201c 	xori	r2,r2,128
 90b6af8:	10bfe004 	addi	r2,r2,-128
 90b6afc:	10800058 	cmpnei	r2,r2,1
 90b6b00:	1000471e 	bne	r2,zero,90b6c20 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 90b6b04:	e0bffb17 	ldw	r2,-20(fp)
 90b6b08:	10800117 	ldw	r2,4(r2)
 90b6b0c:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 90b6b10:	e0bfff17 	ldw	r2,-4(fp)
 90b6b14:	1005003a 	cmpeq	r2,r2,zero
 90b6b18:	1000711e 	bne	r2,zero,90b6ce0 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 90b6b1c:	e0bfff17 	ldw	r2,-4(fp)
 90b6b20:	10800017 	ldw	r2,0(r2)
 90b6b24:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 90b6b28:	e0bffb17 	ldw	r2,-20(fp)
 90b6b2c:	10800117 	ldw	r2,4(r2)
 90b6b30:	10800917 	ldw	r2,36(r2)
 90b6b34:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 90b6b38:	e0bffd17 	ldw	r2,-12(fp)
 90b6b3c:	1005003a 	cmpeq	r2,r2,zero
 90b6b40:	1000671e 	bne	r2,zero,90b6ce0 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 90b6b44:	e03ffc15 	stw	zero,-16(fp)
 90b6b48:	00002d06 	br	90b6c00 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 90b6b4c:	e0bffc17 	ldw	r2,-16(fp)
 90b6b50:	e0fffd17 	ldw	r3,-12(fp)
 90b6b54:	1085883a 	add	r2,r2,r2
 90b6b58:	1085883a 	add	r2,r2,r2
 90b6b5c:	10c5883a 	add	r2,r2,r3
 90b6b60:	10800304 	addi	r2,r2,12
 90b6b64:	10800017 	ldw	r2,0(r2)
 90b6b68:	1005003a 	cmpeq	r2,r2,zero
 90b6b6c:	1000211e 	bne	r2,zero,90b6bf4 <tcp_slowtimo+0x148>
 90b6b70:	e0fffc17 	ldw	r3,-16(fp)
 90b6b74:	e13ffd17 	ldw	r4,-12(fp)
 90b6b78:	18c5883a 	add	r2,r3,r3
 90b6b7c:	1085883a 	add	r2,r2,r2
 90b6b80:	1105883a 	add	r2,r2,r4
 90b6b84:	10800304 	addi	r2,r2,12
 90b6b88:	10800017 	ldw	r2,0(r2)
 90b6b8c:	117fffc4 	addi	r5,r2,-1
 90b6b90:	e13ffd17 	ldw	r4,-12(fp)
 90b6b94:	18c5883a 	add	r2,r3,r3
 90b6b98:	1085883a 	add	r2,r2,r2
 90b6b9c:	1105883a 	add	r2,r2,r4
 90b6ba0:	10800304 	addi	r2,r2,12
 90b6ba4:	11400015 	stw	r5,0(r2)
 90b6ba8:	e13ffd17 	ldw	r4,-12(fp)
 90b6bac:	18c5883a 	add	r2,r3,r3
 90b6bb0:	1085883a 	add	r2,r2,r2
 90b6bb4:	1105883a 	add	r2,r2,r4
 90b6bb8:	10800304 	addi	r2,r2,12
 90b6bbc:	10800017 	ldw	r2,0(r2)
 90b6bc0:	1004c03a 	cmpne	r2,r2,zero
 90b6bc4:	10000b1e 	bne	r2,zero,90b6bf4 <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 90b6bc8:	e0fffb17 	ldw	r3,-20(fp)
 90b6bcc:	008004c4 	movi	r2,19
 90b6bd0:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 90b6bd4:	e1bffc17 	ldw	r6,-16(fp)
 90b6bd8:	e13ffb17 	ldw	r4,-20(fp)
 90b6bdc:	000b883a 	mov	r5,zero
 90b6be0:	90b72440 	call	90b7244 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 90b6be4:	e0bffe17 	ldw	r2,-8(fp)
 90b6be8:	10c00117 	ldw	r3,4(r2)
 90b6bec:	e0bfff17 	ldw	r2,-4(fp)
 90b6bf0:	18803b1e 	bne	r3,r2,90b6ce0 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 90b6bf4:	e0bffc17 	ldw	r2,-16(fp)
 90b6bf8:	10800044 	addi	r2,r2,1
 90b6bfc:	e0bffc15 	stw	r2,-16(fp)
 90b6c00:	e0bffc17 	ldw	r2,-16(fp)
 90b6c04:	10800110 	cmplti	r2,r2,4
 90b6c08:	103fd01e 	bne	r2,zero,90b6b4c <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 90b6c0c:	e0bffd17 	ldw	r2,-12(fp)
 90b6c10:	10801d17 	ldw	r2,116(r2)
 90b6c14:	10c00044 	addi	r3,r2,1
 90b6c18:	e0bffd17 	ldw	r2,-12(fp)
 90b6c1c:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 90b6c20:	e0bffb17 	ldw	r2,-20(fp)
 90b6c24:	10800a04 	addi	r2,r2,40
 90b6c28:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 90b6c2c:	e0bff917 	ldw	r2,-28(fp)
 90b6c30:	1080070b 	ldhu	r2,28(r2)
 90b6c34:	10bfffcc 	andi	r2,r2,65535
 90b6c38:	1080020c 	andi	r2,r2,8
 90b6c3c:	1005003a 	cmpeq	r2,r2,zero
 90b6c40:	10000d1e 	bne	r2,zero,90b6c78 <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 90b6c44:	00824374 	movhi	r2,2317
 90b6c48:	108c4a04 	addi	r2,r2,12584
 90b6c4c:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 90b6c50:	01024374 	movhi	r4,2317
 90b6c54:	210c4a04 	addi	r4,r4,12584
 90b6c58:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 90b6c5c:	e0bff917 	ldw	r2,-28(fp)
 90b6c60:	10c0070b 	ldhu	r3,28(r2)
 90b6c64:	00bffdc4 	movi	r2,-9
 90b6c68:	1884703a 	and	r2,r3,r2
 90b6c6c:	1007883a 	mov	r3,r2
 90b6c70:	e0bff917 	ldw	r2,-28(fp)
 90b6c74:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 90b6c78:	e0bffb17 	ldw	r2,-20(fp)
 90b6c7c:	10801204 	addi	r2,r2,72
 90b6c80:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 90b6c84:	e0bff917 	ldw	r2,-28(fp)
 90b6c88:	1080070b 	ldhu	r2,28(r2)
 90b6c8c:	10bfffcc 	andi	r2,r2,65535
 90b6c90:	1080020c 	andi	r2,r2,8
 90b6c94:	1005003a 	cmpeq	r2,r2,zero
 90b6c98:	10000d1e 	bne	r2,zero,90b6cd0 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 90b6c9c:	00824374 	movhi	r2,2317
 90b6ca0:	108c4a04 	addi	r2,r2,12584
 90b6ca4:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 90b6ca8:	01024374 	movhi	r4,2317
 90b6cac:	210c4a04 	addi	r4,r4,12584
 90b6cb0:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 90b6cb4:	e0bff917 	ldw	r2,-28(fp)
 90b6cb8:	10c0070b 	ldhu	r3,28(r2)
 90b6cbc:	00bffdc4 	movi	r2,-9
 90b6cc0:	1884703a 	and	r2,r3,r2
 90b6cc4:	1007883a 	mov	r3,r2
 90b6cc8:	e0bff917 	ldw	r2,-28(fp)
 90b6ccc:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 90b6cd0:	e0bffb17 	ldw	r2,-20(fp)
 90b6cd4:	10800904 	addi	r2,r2,36
 90b6cd8:	1009883a 	mov	r4,r2
 90b6cdc:	90a4ea40 	call	90a4ea4 <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 90b6ce0:	e0bffa17 	ldw	r2,-24(fp)
 90b6ce4:	e0bffb15 	stw	r2,-20(fp)
 90b6ce8:	e0bffb17 	ldw	r2,-20(fp)
 90b6cec:	1004c03a 	cmpne	r2,r2,zero
 90b6cf0:	103f7a1e 	bne	r2,zero,90b6adc <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 90b6cf4:	00824374 	movhi	r2,2317
 90b6cf8:	108c4f04 	addi	r2,r2,12604
 90b6cfc:	10c00017 	ldw	r3,0(r2)
 90b6d00:	00be9fd4 	movui	r2,64127
 90b6d04:	1887883a 	add	r3,r3,r2
 90b6d08:	00824374 	movhi	r2,2317
 90b6d0c:	108c4f04 	addi	r2,r2,12604
 90b6d10:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 90b6d14:	00824374 	movhi	r2,2317
 90b6d18:	108c4f04 	addi	r2,r2,12604
 90b6d1c:	10800017 	ldw	r2,0(r2)
 90b6d20:	10bfc02c 	andhi	r2,r2,65280
 90b6d24:	1005003a 	cmpeq	r2,r2,zero
 90b6d28:	1000031e 	bne	r2,zero,90b6d38 <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 90b6d2c:	00824374 	movhi	r2,2317
 90b6d30:	108c4f04 	addi	r2,r2,12604
 90b6d34:	10000015 	stw	zero,0(r2)
}
 90b6d38:	e037883a 	mov	sp,fp
 90b6d3c:	dfc00117 	ldw	ra,4(sp)
 90b6d40:	df000017 	ldw	fp,0(sp)
 90b6d44:	dec00204 	addi	sp,sp,8
 90b6d48:	f800283a 	ret

090b6d4c <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 90b6d4c:	defffd04 	addi	sp,sp,-12
 90b6d50:	df000215 	stw	fp,8(sp)
 90b6d54:	df000204 	addi	fp,sp,8
 90b6d58:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 90b6d5c:	e03ffe15 	stw	zero,-8(fp)
 90b6d60:	00000a06 	br	90b6d8c <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 90b6d64:	e0bffe17 	ldw	r2,-8(fp)
 90b6d68:	e0ffff17 	ldw	r3,-4(fp)
 90b6d6c:	1085883a 	add	r2,r2,r2
 90b6d70:	1085883a 	add	r2,r2,r2
 90b6d74:	10c5883a 	add	r2,r2,r3
 90b6d78:	10800304 	addi	r2,r2,12
 90b6d7c:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 90b6d80:	e0bffe17 	ldw	r2,-8(fp)
 90b6d84:	10800044 	addi	r2,r2,1
 90b6d88:	e0bffe15 	stw	r2,-8(fp)
 90b6d8c:	e0bffe17 	ldw	r2,-8(fp)
 90b6d90:	10800110 	cmplti	r2,r2,4
 90b6d94:	103ff31e 	bne	r2,zero,90b6d64 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 90b6d98:	e037883a 	mov	sp,fp
 90b6d9c:	df000017 	ldw	fp,0(sp)
 90b6da0:	dec00104 	addi	sp,sp,4
 90b6da4:	f800283a 	ret

090b6da8 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 90b6da8:	defff504 	addi	sp,sp,-44
 90b6dac:	dfc00a15 	stw	ra,40(sp)
 90b6db0:	df000915 	stw	fp,36(sp)
 90b6db4:	df000904 	addi	fp,sp,36
 90b6db8:	e13ffb15 	stw	r4,-20(fp)
 90b6dbc:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 90b6dc0:	e0bffc17 	ldw	r2,-16(fp)
 90b6dc4:	e0bffe15 	stw	r2,-8(fp)
 90b6dc8:	e0fffe17 	ldw	r3,-8(fp)
 90b6dcc:	18800060 	cmpeqi	r2,r3,1
 90b6dd0:	1000bd1e 	bne	r2,zero,90b70c8 <tcp_timers+0x320>
 90b6dd4:	e0fffe17 	ldw	r3,-8(fp)
 90b6dd8:	18800088 	cmpgei	r2,r3,2
 90b6ddc:	1000041e 	bne	r2,zero,90b6df0 <tcp_timers+0x48>
 90b6de0:	e0fffe17 	ldw	r3,-8(fp)
 90b6de4:	1805003a 	cmpeq	r2,r3,zero
 90b6de8:	10001b1e 	bne	r2,zero,90b6e58 <tcp_timers+0xb0>
 90b6dec:	00010f06 	br	90b722c <tcp_timers+0x484>
 90b6df0:	e0fffe17 	ldw	r3,-8(fp)
 90b6df4:	188000a0 	cmpeqi	r2,r3,2
 90b6df8:	1000c41e 	bne	r2,zero,90b710c <tcp_timers+0x364>
 90b6dfc:	e0fffe17 	ldw	r3,-8(fp)
 90b6e00:	188000e0 	cmpeqi	r2,r3,3
 90b6e04:	1000011e 	bne	r2,zero,90b6e0c <tcp_timers+0x64>
 90b6e08:	00010806 	br	90b722c <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 90b6e0c:	e0bffb17 	ldw	r2,-20(fp)
 90b6e10:	10800217 	ldw	r2,8(r2)
 90b6e14:	108002a0 	cmpeqi	r2,r2,10
 90b6e18:	10000b1e 	bne	r2,zero,90b6e48 <tcp_timers+0xa0>
 90b6e1c:	e0bffb17 	ldw	r2,-20(fp)
 90b6e20:	10c01d17 	ldw	r3,116(r2)
 90b6e24:	d0a0b417 	ldw	r2,-32048(gp)
 90b6e28:	10c00716 	blt	r2,r3,90b6e48 <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 90b6e2c:	d0a03d17 	ldw	r2,-32524(gp)
 90b6e30:	10ffffcc 	andi	r3,r2,65535
 90b6e34:	18e0001c 	xori	r3,r3,32768
 90b6e38:	18e00004 	addi	r3,r3,-32768
 90b6e3c:	e0bffb17 	ldw	r2,-20(fp)
 90b6e40:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 90b6e44:	0000f906 	br	90b722c <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 90b6e48:	e13ffb17 	ldw	r4,-20(fp)
 90b6e4c:	90b68800 	call	90b6880 <tcp_close>
 90b6e50:	e0bffb15 	stw	r2,-20(fp)
      break;
 90b6e54:	0000f506 	br	90b722c <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 90b6e58:	008243b4 	movhi	r2,2318
 90b6e5c:	10b56004 	addi	r2,r2,-10880
 90b6e60:	10800b17 	ldw	r2,44(r2)
 90b6e64:	10c00044 	addi	r3,r2,1
 90b6e68:	008243b4 	movhi	r2,2318
 90b6e6c:	10b56004 	addi	r2,r2,-10880
 90b6e70:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 90b6e74:	e0bffb17 	ldw	r2,-20(fp)
 90b6e78:	10800717 	ldw	r2,28(r2)
 90b6e7c:	10c00044 	addi	r3,r2,1
 90b6e80:	e0bffb17 	ldw	r2,-20(fp)
 90b6e84:	10c00715 	stw	r3,28(r2)
 90b6e88:	e0bffb17 	ldw	r2,-20(fp)
 90b6e8c:	10800717 	ldw	r2,28(r2)
 90b6e90:	10800350 	cmplti	r2,r2,13
 90b6e94:	10000f1e 	bne	r2,zero,90b6ed4 <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 90b6e98:	e0fffb17 	ldw	r3,-20(fp)
 90b6e9c:	00800304 	movi	r2,12
 90b6ea0:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 90b6ea4:	008243b4 	movhi	r2,2318
 90b6ea8:	10b58e04 	addi	r2,r2,-10696
 90b6eac:	10800917 	ldw	r2,36(r2)
 90b6eb0:	10c00044 	addi	r3,r2,1
 90b6eb4:	008243b4 	movhi	r2,2318
 90b6eb8:	10b58e04 	addi	r2,r2,-10696
 90b6ebc:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 90b6ec0:	e13ffb17 	ldw	r4,-20(fp)
 90b6ec4:	01401d04 	movi	r5,116
 90b6ec8:	90b67d40 	call	90b67d4 <tcp_drop>
 90b6ecc:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b6ed0:	0000d606 	br	90b722c <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 90b6ed4:	008243b4 	movhi	r2,2318
 90b6ed8:	10b58e04 	addi	r2,r2,-10696
 90b6edc:	10800a17 	ldw	r2,40(r2)
 90b6ee0:	10c00044 	addi	r3,r2,1
 90b6ee4:	008243b4 	movhi	r2,2318
 90b6ee8:	10b58e04 	addi	r2,r2,-10696
 90b6eec:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 90b6ef0:	e0bffb17 	ldw	r2,-20(fp)
 90b6ef4:	10802017 	ldw	r2,128(r2)
 90b6ef8:	1007d0ba 	srai	r3,r2,2
 90b6efc:	e0bffb17 	ldw	r2,-20(fp)
 90b6f00:	10802117 	ldw	r2,132(r2)
 90b6f04:	1885883a 	add	r2,r3,r2
 90b6f08:	1005d07a 	srai	r2,r2,1
 90b6f0c:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 90b6f10:	e0bffb17 	ldw	r2,-20(fp)
 90b6f14:	10c00717 	ldw	r3,28(r2)
 90b6f18:	00824374 	movhi	r2,2317
 90b6f1c:	108ac8c4 	addi	r2,r2,11043
 90b6f20:	10c5883a 	add	r2,r2,r3
 90b6f24:	10800003 	ldbu	r2,0(r2)
 90b6f28:	10c03fcc 	andi	r3,r2,255
 90b6f2c:	e0bffa17 	ldw	r2,-24(fp)
 90b6f30:	10c5383a 	mul	r2,r2,r3
 90b6f34:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 90b6f38:	e0bffa17 	ldw	r2,-24(fp)
 90b6f3c:	10ffffcc 	andi	r3,r2,65535
 90b6f40:	18e0001c 	xori	r3,r3,32768
 90b6f44:	18e00004 	addi	r3,r3,-32768
 90b6f48:	e0bffb17 	ldw	r2,-20(fp)
 90b6f4c:	10c00815 	stw	r3,32(r2)
 90b6f50:	e0bffb17 	ldw	r2,-20(fp)
 90b6f54:	10800817 	ldw	r2,32(r2)
 90b6f58:	10800088 	cmpgei	r2,r2,2
 90b6f5c:	1000041e 	bne	r2,zero,90b6f70 <tcp_timers+0x1c8>
 90b6f60:	e0fffb17 	ldw	r3,-20(fp)
 90b6f64:	00800084 	movi	r2,2
 90b6f68:	18800815 	stw	r2,32(r3)
 90b6f6c:	00000706 	br	90b6f8c <tcp_timers+0x1e4>
 90b6f70:	e0bffb17 	ldw	r2,-20(fp)
 90b6f74:	10800817 	ldw	r2,32(r2)
 90b6f78:	10802050 	cmplti	r2,r2,129
 90b6f7c:	1000031e 	bne	r2,zero,90b6f8c <tcp_timers+0x1e4>
 90b6f80:	e0fffb17 	ldw	r3,-20(fp)
 90b6f84:	00802004 	movi	r2,128
 90b6f88:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b6f8c:	e0bffb17 	ldw	r2,-20(fp)
 90b6f90:	10c00817 	ldw	r3,32(r2)
 90b6f94:	e0bffb17 	ldw	r2,-20(fp)
 90b6f98:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 90b6f9c:	e0bffb17 	ldw	r2,-20(fp)
 90b6fa0:	10800717 	ldw	r2,28(r2)
 90b6fa4:	10800110 	cmplti	r2,r2,4
 90b6fa8:	1000101e 	bne	r2,zero,90b6fec <tcp_timers+0x244>
 90b6fac:	e0bffb17 	ldw	r2,-20(fp)
 90b6fb0:	10800b0b 	ldhu	r2,44(r2)
 90b6fb4:	10bfffcc 	andi	r2,r2,65535
 90b6fb8:	1080400c 	andi	r2,r2,256
 90b6fbc:	1004c03a 	cmpne	r2,r2,zero
 90b6fc0:	10000a1e 	bne	r2,zero,90b6fec <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 90b6fc4:	e0bffb17 	ldw	r2,-20(fp)
 90b6fc8:	10c02117 	ldw	r3,132(r2)
 90b6fcc:	e0bffb17 	ldw	r2,-20(fp)
 90b6fd0:	10802017 	ldw	r2,128(r2)
 90b6fd4:	1005d0ba 	srai	r2,r2,2
 90b6fd8:	1887883a 	add	r3,r3,r2
 90b6fdc:	e0bffb17 	ldw	r2,-20(fp)
 90b6fe0:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 90b6fe4:	e0bffb17 	ldw	r2,-20(fp)
 90b6fe8:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 90b6fec:	e0bffb17 	ldw	r2,-20(fp)
 90b6ff0:	10c00e17 	ldw	r3,56(r2)
 90b6ff4:	e0bffb17 	ldw	r2,-20(fp)
 90b6ff8:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 90b6ffc:	e0bffb17 	ldw	r2,-20(fp)
 90b7000:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 90b7004:	e0bffb17 	ldw	r2,-20(fp)
 90b7008:	10800d17 	ldw	r2,52(r2)
 90b700c:	10800817 	ldw	r2,32(r2)
 90b7010:	10800417 	ldw	r2,16(r2)
 90b7014:	1090000c 	andi	r2,r2,16384
 90b7018:	1004c03a 	cmpne	r2,r2,zero
 90b701c:	1000271e 	bne	r2,zero,90b70bc <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 90b7020:	e0bffb17 	ldw	r2,-20(fp)
 90b7024:	10c01417 	ldw	r3,80(r2)
 90b7028:	e0bffb17 	ldw	r2,-20(fp)
 90b702c:	10801b17 	ldw	r2,108(r2)
 90b7030:	e0bffd15 	stw	r2,-12(fp)
 90b7034:	e0ffff15 	stw	r3,-4(fp)
 90b7038:	e0bffd17 	ldw	r2,-12(fp)
 90b703c:	e0ffff17 	ldw	r3,-4(fp)
 90b7040:	10c0022e 	bgeu	r2,r3,90b704c <tcp_timers+0x2a4>
 90b7044:	e0bffd17 	ldw	r2,-12(fp)
 90b7048:	e0bfff15 	stw	r2,-4(fp)
 90b704c:	e0ffff17 	ldw	r3,-4(fp)
 90b7050:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 90b7054:	e0bff917 	ldw	r2,-28(fp)
 90b7058:	1006d07a 	srli	r3,r2,1
 90b705c:	e0bffb17 	ldw	r2,-20(fp)
 90b7060:	10800a0b 	ldhu	r2,40(r2)
 90b7064:	10bfffcc 	andi	r2,r2,65535
 90b7068:	1885203a 	divu	r2,r3,r2
 90b706c:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 90b7070:	e0bff917 	ldw	r2,-28(fp)
 90b7074:	108000a8 	cmpgeui	r2,r2,2
 90b7078:	1000021e 	bne	r2,zero,90b7084 <tcp_timers+0x2dc>
            win = 2;
 90b707c:	00800084 	movi	r2,2
 90b7080:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 90b7084:	e0bffb17 	ldw	r2,-20(fp)
 90b7088:	10800a0b 	ldhu	r2,40(r2)
 90b708c:	10ffffcc 	andi	r3,r2,65535
 90b7090:	e0bffb17 	ldw	r2,-20(fp)
 90b7094:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 90b7098:	e0bff917 	ldw	r2,-28(fp)
 90b709c:	10ffffcc 	andi	r3,r2,65535
 90b70a0:	e0bffb17 	ldw	r2,-20(fp)
 90b70a4:	10800a0b 	ldhu	r2,40(r2)
 90b70a8:	10bfffcc 	andi	r2,r2,65535
 90b70ac:	1885383a 	mul	r2,r3,r2
 90b70b0:	1007883a 	mov	r3,r2
 90b70b4:	e0bffb17 	ldw	r2,-20(fp)
 90b70b8:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 90b70bc:	e13ffb17 	ldw	r4,-20(fp)
 90b70c0:	90b4d640 	call	90b4d64 <tcp_output>
      break;
 90b70c4:	00005906 	br	90b722c <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 90b70c8:	008243b4 	movhi	r2,2318
 90b70cc:	10b58e04 	addi	r2,r2,-10696
 90b70d0:	10800b17 	ldw	r2,44(r2)
 90b70d4:	10c00044 	addi	r3,r2,1
 90b70d8:	008243b4 	movhi	r2,2318
 90b70dc:	10b58e04 	addi	r2,r2,-10696
 90b70e0:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 90b70e4:	e13ffb17 	ldw	r4,-20(fp)
 90b70e8:	90b5ee00 	call	90b5ee0 <tcp_setpersist>
      tp->t_force = 1;
 90b70ec:	e0fffb17 	ldw	r3,-20(fp)
 90b70f0:	00800044 	movi	r2,1
 90b70f4:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 90b70f8:	e13ffb17 	ldw	r4,-20(fp)
 90b70fc:	90b4d640 	call	90b4d64 <tcp_output>
      tp->t_force = 0;
 90b7100:	e0bffb17 	ldw	r2,-20(fp)
 90b7104:	10000a85 	stb	zero,42(r2)
      break;
 90b7108:	00004806 	br	90b722c <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 90b710c:	008243b4 	movhi	r2,2318
 90b7110:	10b58e04 	addi	r2,r2,-10696
 90b7114:	10800c17 	ldw	r2,48(r2)
 90b7118:	10c00044 	addi	r3,r2,1
 90b711c:	008243b4 	movhi	r2,2318
 90b7120:	10b58e04 	addi	r2,r2,-10696
 90b7124:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 90b7128:	e0bffb17 	ldw	r2,-20(fp)
 90b712c:	10800217 	ldw	r2,8(r2)
 90b7130:	10800110 	cmplti	r2,r2,4
 90b7134:	1000321e 	bne	r2,zero,90b7200 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 90b7138:	e0bffb17 	ldw	r2,-20(fp)
 90b713c:	10800d17 	ldw	r2,52(r2)
 90b7140:	10800817 	ldw	r2,32(r2)
 90b7144:	10800417 	ldw	r2,16(r2)
 90b7148:	1080020c 	andi	r2,r2,8
 90b714c:	1005003a 	cmpeq	r2,r2,zero
 90b7150:	1000241e 	bne	r2,zero,90b71e4 <tcp_timers+0x43c>
 90b7154:	e0bffb17 	ldw	r2,-20(fp)
 90b7158:	10800217 	ldw	r2,8(r2)
 90b715c:	10800188 	cmpgei	r2,r2,6
 90b7160:	1000201e 	bne	r2,zero,90b71e4 <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 90b7164:	e0bffb17 	ldw	r2,-20(fp)
 90b7168:	11001d17 	ldw	r4,116(r2)
 90b716c:	d0e03c17 	ldw	r3,-32528(gp)
 90b7170:	d0a0b417 	ldw	r2,-32048(gp)
 90b7174:	1885883a 	add	r2,r3,r2
 90b7178:	2080210e 	bge	r4,r2,90b7200 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 90b717c:	008243b4 	movhi	r2,2318
 90b7180:	10b58e04 	addi	r2,r2,-10696
 90b7184:	10800d17 	ldw	r2,52(r2)
 90b7188:	10c00044 	addi	r3,r2,1
 90b718c:	008243b4 	movhi	r2,2318
 90b7190:	10b58e04 	addi	r2,r2,-10696
 90b7194:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 90b7198:	e0bffb17 	ldw	r2,-20(fp)
 90b719c:	11400c17 	ldw	r5,48(r2)
 90b71a0:	e0bffb17 	ldw	r2,-20(fp)
 90b71a4:	10801617 	ldw	r2,88(r2)
 90b71a8:	11bfffc4 	addi	r6,r2,-1
 90b71ac:	e0bffb17 	ldw	r2,-20(fp)
 90b71b0:	10800e17 	ldw	r2,56(r2)
 90b71b4:	11ffffc4 	addi	r7,r2,-1
 90b71b8:	d8000015 	stw	zero,0(sp)
 90b71bc:	d8000115 	stw	zero,4(sp)
 90b71c0:	e13ffb17 	ldw	r4,-20(fp)
 90b71c4:	90b62340 	call	90b6234 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 90b71c8:	d0a03d17 	ldw	r2,-32524(gp)
 90b71cc:	10ffffcc 	andi	r3,r2,65535
 90b71d0:	18e0001c 	xori	r3,r3,32768
 90b71d4:	18e00004 	addi	r3,r3,-32768
 90b71d8:	e0bffb17 	ldw	r2,-20(fp)
 90b71dc:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 90b71e0:	00001206 	br	90b722c <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 90b71e4:	d0a03c17 	ldw	r2,-32528(gp)
 90b71e8:	10ffffcc 	andi	r3,r2,65535
 90b71ec:	18e0001c 	xori	r3,r3,32768
 90b71f0:	18e00004 	addi	r3,r3,-32768
 90b71f4:	e0bffb17 	ldw	r2,-20(fp)
 90b71f8:	10c00515 	stw	r3,20(r2)
      break;
 90b71fc:	00000b06 	br	90b722c <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 90b7200:	008243b4 	movhi	r2,2318
 90b7204:	10b58e04 	addi	r2,r2,-10696
 90b7208:	10800e17 	ldw	r2,56(r2)
 90b720c:	10c00044 	addi	r3,r2,1
 90b7210:	008243b4 	movhi	r2,2318
 90b7214:	10b58e04 	addi	r2,r2,-10696
 90b7218:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 90b721c:	e13ffb17 	ldw	r4,-20(fp)
 90b7220:	01401d04 	movi	r5,116
 90b7224:	90b67d40 	call	90b67d4 <tcp_drop>
 90b7228:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 90b722c:	e0bffb17 	ldw	r2,-20(fp)
}
 90b7230:	e037883a 	mov	sp,fp
 90b7234:	dfc00117 	ldw	ra,4(sp)
 90b7238:	df000017 	ldw	fp,0(sp)
 90b723c:	dec00204 	addi	sp,sp,8
 90b7240:	f800283a 	ret

090b7244 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90b7244:	defff504 	addi	sp,sp,-44
 90b7248:	dfc00a15 	stw	ra,40(sp)
 90b724c:	df000915 	stw	fp,36(sp)
 90b7250:	df000904 	addi	fp,sp,36
 90b7254:	e13ffc15 	stw	r4,-16(fp)
 90b7258:	e17ffd15 	stw	r5,-12(fp)
 90b725c:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 90b7260:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 90b7264:	e0bffc17 	ldw	r2,-16(fp)
 90b7268:	10800717 	ldw	r2,28(r2)
 90b726c:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 90b7270:	e0bffc17 	ldw	r2,-16(fp)
 90b7274:	10800117 	ldw	r2,4(r2)
 90b7278:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 90b727c:	e0bffb17 	ldw	r2,-20(fp)
 90b7280:	1004c03a 	cmpne	r2,r2,zero
 90b7284:	1000061e 	bne	r2,zero,90b72a0 <tcp_usrreq+0x5c>
 90b7288:	e0bff817 	ldw	r2,-32(fp)
 90b728c:	1005003a 	cmpeq	r2,r2,zero
 90b7290:	1000031e 	bne	r2,zero,90b72a0 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 90b7294:	00800584 	movi	r2,22
 90b7298:	e0bfff15 	stw	r2,-4(fp)
 90b729c:	0001a406 	br	90b7930 <tcp_usrreq+0x6ec>
   }

   if (inp)
 90b72a0:	e0bffb17 	ldw	r2,-20(fp)
 90b72a4:	1005003a 	cmpeq	r2,r2,zero
 90b72a8:	1000041e 	bne	r2,zero,90b72bc <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 90b72ac:	e0bffb17 	ldw	r2,-20(fp)
 90b72b0:	10800917 	ldw	r2,36(r2)
 90b72b4:	e0bffa15 	stw	r2,-24(fp)
 90b72b8:	00000906 	br	90b72e0 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 90b72bc:	e0bff817 	ldw	r2,-32(fp)
 90b72c0:	1004c03a 	cmpne	r2,r2,zero
 90b72c4:	1000021e 	bne	r2,zero,90b72d0 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 90b72c8:	e03ffa15 	stw	zero,-24(fp)
 90b72cc:	00000406 	br	90b72e0 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 90b72d0:	90a94880 	call	90a9488 <dtrap>
         return EINVAL;
 90b72d4:	00800584 	movi	r2,22
 90b72d8:	e0bfff15 	stw	r2,-4(fp)
 90b72dc:	00019406 	br	90b7930 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 90b72e0:	e0bff817 	ldw	r2,-32(fp)
 90b72e4:	10800528 	cmpgeui	r2,r2,20
 90b72e8:	10018c1e 	bne	r2,zero,90b791c <tcp_usrreq+0x6d8>
 90b72ec:	e0bff817 	ldw	r2,-32(fp)
 90b72f0:	1085883a 	add	r2,r2,r2
 90b72f4:	1087883a 	add	r3,r2,r2
 90b72f8:	008242f4 	movhi	r2,2315
 90b72fc:	109cc304 	addi	r2,r2,29452
 90b7300:	1885883a 	add	r2,r3,r2
 90b7304:	10800017 	ldw	r2,0(r2)
 90b7308:	1000683a 	jmp	r2
 90b730c:	090b735c 	xori	r4,at,11725
 90b7310:	090b73cc 	andi	r4,at,11727
 90b7314:	090b73f4 	orhi	r4,at,11727
 90b7318:	090b742c 	andhi	r4,at,11728
 90b731c:	090b746c 	andhi	r4,at,11729
 90b7320:	090b75f0 	cmpltui	r4,at,11735
 90b7324:	090b75e4 	muli	r4,at,11735
 90b7328:	090b769c 	xori	r4,at,11738
 90b732c:	090b76cc 	andi	r4,at,11739
 90b7330:	090b76d8 	cmpnei	r4,at,11739
 90b7334:	090b7730 	cmpltui	r4,at,11740
 90b7338:	090b791c 	xori	r4,at,11748
 90b733c:	090b7740 	call	90b774 <OSCtxSw_SWITCH_PC+0x90b734>
 90b7340:	090b774c 	andi	r4,at,11741
 90b7344:	090b781c 	xori	r4,at,11744
 90b7348:	090b78ec 	andhi	r4,at,11747
 90b734c:	090b78fc 	xorhi	r4,at,11747
 90b7350:	090b75d8 	cmpnei	r4,at,11735
 90b7354:	090b791c 	xori	r4,at,11748
 90b7358:	090b790c 	andi	r4,at,11748
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 90b735c:	e0bffb17 	ldw	r2,-20(fp)
 90b7360:	1005003a 	cmpeq	r2,r2,zero
 90b7364:	1000031e 	bne	r2,zero,90b7374 <tcp_usrreq+0x130>
      {
         error = EISCONN;
 90b7368:	00801fc4 	movi	r2,127
 90b736c:	e0bff915 	stw	r2,-28(fp)
         break;
 90b7370:	00016d06 	br	90b7928 <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 90b7374:	e13ffc17 	ldw	r4,-16(fp)
 90b7378:	90b79480 	call	90b7948 <tcp_attach>
 90b737c:	e0bff915 	stw	r2,-28(fp)
      if (error)
 90b7380:	e0bff917 	ldw	r2,-28(fp)
 90b7384:	1004c03a 	cmpne	r2,r2,zero
 90b7388:	1001671e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b738c:	e0bffc17 	ldw	r2,-16(fp)
 90b7390:	10800417 	ldw	r2,16(r2)
 90b7394:	1080200c 	andi	r2,r2,128
 90b7398:	1005003a 	cmpeq	r2,r2,zero
 90b739c:	1001621e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
 90b73a0:	e0bffc17 	ldw	r2,-16(fp)
 90b73a4:	1080080b 	ldhu	r2,32(r2)
 90b73a8:	10bfffcc 	andi	r2,r2,65535
 90b73ac:	10a0001c 	xori	r2,r2,32768
 90b73b0:	10a00004 	addi	r2,r2,-32768
 90b73b4:	1004c03a 	cmpne	r2,r2,zero
 90b73b8:	10015b1e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 90b73bc:	e0fffc17 	ldw	r3,-16(fp)
 90b73c0:	00801e04 	movi	r2,120
 90b73c4:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 90b73c8:	00015706 	br	90b7928 <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 90b73cc:	e0bffa17 	ldw	r2,-24(fp)
 90b73d0:	10800217 	ldw	r2,8(r2)
 90b73d4:	10800090 	cmplti	r2,r2,2
 90b73d8:	1000031e 	bne	r2,zero,90b73e8 <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 90b73dc:	e13ffa17 	ldw	r4,-24(fp)
 90b73e0:	90b7a7c0 	call	90b7a7c <tcp_disconnect>
 90b73e4:	00015006 	br	90b7928 <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 90b73e8:	e13ffa17 	ldw	r4,-24(fp)
 90b73ec:	90b68800 	call	90b6880 <tcp_close>
      break;
 90b73f0:	00014d06 	br	90b7928 <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 90b73f4:	e0bffb17 	ldw	r2,-20(fp)
 90b73f8:	10800817 	ldw	r2,32(r2)
 90b73fc:	10800517 	ldw	r2,20(r2)
 90b7400:	10800098 	cmpnei	r2,r2,2
 90b7404:	1000051e 	bne	r2,zero,90b741c <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 90b7408:	e13ffb17 	ldw	r4,-20(fp)
 90b740c:	e17ffe17 	ldw	r5,-8(fp)
 90b7410:	90c69e80 	call	90c69e8 <in_pcbbind>
 90b7414:	e0bff915 	stw	r2,-28(fp)
         break;
 90b7418:	00014306 	br	90b7928 <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 90b741c:	90a94880 	call	90a9488 <dtrap>
      error = EINVAL;
 90b7420:	00800584 	movi	r2,22
 90b7424:	e0bff915 	stw	r2,-28(fp)
      break;
 90b7428:	00013f06 	br	90b7928 <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 90b742c:	e0bffb17 	ldw	r2,-20(fp)
 90b7430:	1080078b 	ldhu	r2,30(r2)
 90b7434:	10bfffcc 	andi	r2,r2,65535
 90b7438:	1004c03a 	cmpne	r2,r2,zero
 90b743c:	1000041e 	bne	r2,zero,90b7450 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 90b7440:	e13ffb17 	ldw	r4,-20(fp)
 90b7444:	000b883a 	mov	r5,zero
 90b7448:	90c69e80 	call	90c69e8 <in_pcbbind>
 90b744c:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 90b7450:	e0bff917 	ldw	r2,-28(fp)
 90b7454:	1004c03a 	cmpne	r2,r2,zero
 90b7458:	1001331e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 90b745c:	e0fffa17 	ldw	r3,-24(fp)
 90b7460:	00800044 	movi	r2,1
 90b7464:	18800215 	stw	r2,8(r3)
      break;
 90b7468:	00012f06 	br	90b7928 <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 90b746c:	e0bffb17 	ldw	r2,-20(fp)
 90b7470:	1080078b 	ldhu	r2,30(r2)
 90b7474:	10bfffcc 	andi	r2,r2,65535
 90b7478:	1004c03a 	cmpne	r2,r2,zero
 90b747c:	1000071e 	bne	r2,zero,90b749c <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 90b7480:	e13ffb17 	ldw	r4,-20(fp)
 90b7484:	000b883a 	mov	r5,zero
 90b7488:	90c69e80 	call	90c69e8 <in_pcbbind>
 90b748c:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 90b7490:	e0bff917 	ldw	r2,-28(fp)
 90b7494:	1004c03a 	cmpne	r2,r2,zero
 90b7498:	1001231e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 90b749c:	e13ffb17 	ldw	r4,-20(fp)
 90b74a0:	e17ffe17 	ldw	r5,-8(fp)
 90b74a4:	90c6c3c0 	call	90c6c3c <in_pcbconnect>
 90b74a8:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 90b74ac:	e0bff917 	ldw	r2,-28(fp)
 90b74b0:	1004c03a 	cmpne	r2,r2,zero
 90b74b4:	10011c1e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 90b74b8:	e13ffa17 	ldw	r4,-24(fp)
 90b74bc:	90b611c0 	call	90b611c <tcp_template>
 90b74c0:	1007883a 	mov	r3,r2
 90b74c4:	e0bffa17 	ldw	r2,-24(fp)
 90b74c8:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 90b74cc:	e0bffa17 	ldw	r2,-24(fp)
 90b74d0:	10800c17 	ldw	r2,48(r2)
 90b74d4:	1004c03a 	cmpne	r2,r2,zero
 90b74d8:	1000051e 	bne	r2,zero,90b74f0 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 90b74dc:	e13ffb17 	ldw	r4,-20(fp)
 90b74e0:	90c6e4c0 	call	90c6e4c <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 90b74e4:	00801a44 	movi	r2,105
 90b74e8:	e0bff915 	stw	r2,-28(fp)
         break;
 90b74ec:	00010e06 	br	90b7928 <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 90b74f0:	e13ffc17 	ldw	r4,-16(fp)
 90b74f4:	90b011c0 	call	90b011c <soisconnecting>
      tcpstat.tcps_connattempt++;
 90b74f8:	008243b4 	movhi	r2,2318
 90b74fc:	10b58e04 	addi	r2,r2,-10696
 90b7500:	10800017 	ldw	r2,0(r2)
 90b7504:	10c00044 	addi	r3,r2,1
 90b7508:	008243b4 	movhi	r2,2318
 90b750c:	10b58e04 	addi	r2,r2,-10696
 90b7510:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 90b7514:	e0fffa17 	ldw	r3,-24(fp)
 90b7518:	00800084 	movi	r2,2
 90b751c:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 90b7520:	e0fffa17 	ldw	r3,-24(fp)
 90b7524:	00802584 	movi	r2,150
 90b7528:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 90b752c:	00824374 	movhi	r2,2317
 90b7530:	108c4f04 	addi	r2,r2,12604
 90b7534:	10c00017 	ldw	r3,0(r2)
 90b7538:	e0bffa17 	ldw	r2,-24(fp)
 90b753c:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 90b7540:	00824374 	movhi	r2,2317
 90b7544:	108c4f04 	addi	r2,r2,12604
 90b7548:	10c00017 	ldw	r3,0(r2)
 90b754c:	00be9fd4 	movui	r2,64127
 90b7550:	1887883a 	add	r3,r3,r2
 90b7554:	00824374 	movhi	r2,2317
 90b7558:	108c4f04 	addi	r2,r2,12604
 90b755c:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 90b7560:	e0bffa17 	ldw	r2,-24(fp)
 90b7564:	10c01317 	ldw	r3,76(r2)
 90b7568:	e0bffa17 	ldw	r2,-24(fp)
 90b756c:	10c01015 	stw	r3,64(r2)
 90b7570:	e0bffa17 	ldw	r2,-24(fp)
 90b7574:	10c01017 	ldw	r3,64(r2)
 90b7578:	e0bffa17 	ldw	r2,-24(fp)
 90b757c:	10c01a15 	stw	r3,104(r2)
 90b7580:	e0bffa17 	ldw	r2,-24(fp)
 90b7584:	10c01a17 	ldw	r3,104(r2)
 90b7588:	e0bffa17 	ldw	r2,-24(fp)
 90b758c:	10c00f15 	stw	r3,60(r2)
 90b7590:	e0bffa17 	ldw	r2,-24(fp)
 90b7594:	10c00f17 	ldw	r3,60(r2)
 90b7598:	e0bffa17 	ldw	r2,-24(fp)
 90b759c:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 90b75a0:	e13ffa17 	ldw	r4,-24(fp)
 90b75a4:	90b4d640 	call	90b4d64 <tcp_output>
 90b75a8:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 90b75ac:	e0bff917 	ldw	r2,-28(fp)
 90b75b0:	1004c03a 	cmpne	r2,r2,zero
 90b75b4:	1000dc1e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 90b75b8:	008243b4 	movhi	r2,2318
 90b75bc:	10b56004 	addi	r2,r2,-10880
 90b75c0:	10800417 	ldw	r2,16(r2)
 90b75c4:	10c00044 	addi	r3,r2,1
 90b75c8:	008243b4 	movhi	r2,2318
 90b75cc:	10b56004 	addi	r2,r2,-10880
 90b75d0:	10c00415 	stw	r3,16(r2)
      break;
 90b75d4:	0000d406 	br	90b7928 <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 90b75d8:	008017c4 	movi	r2,95
 90b75dc:	e0bff915 	stw	r2,-28(fp)
      break;
 90b75e0:	0000d106 	br	90b7928 <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 90b75e4:	e13ffa17 	ldw	r4,-24(fp)
 90b75e8:	90b7a7c0 	call	90b7a7c <tcp_disconnect>
      break;
 90b75ec:	0000ce06 	br	90b7928 <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 90b75f0:	e0bffe17 	ldw	r2,-8(fp)
 90b75f4:	10800317 	ldw	r2,12(r2)
 90b75f8:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 90b75fc:	e0bffc17 	ldw	r2,-16(fp)
 90b7600:	10800517 	ldw	r2,20(r2)
 90b7604:	10800098 	cmpnei	r2,r2,2
 90b7608:	10000e1e 	bne	r2,zero,90b7644 <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 90b760c:	e0fffe17 	ldw	r3,-8(fp)
 90b7610:	00800404 	movi	r2,16
 90b7614:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 90b7618:	e0fff717 	ldw	r3,-36(fp)
 90b761c:	00800084 	movi	r2,2
 90b7620:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 90b7624:	e0bffb17 	ldw	r2,-20(fp)
 90b7628:	10c0070b 	ldhu	r3,28(r2)
 90b762c:	e0bff717 	ldw	r2,-36(fp)
 90b7630:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 90b7634:	e0bffb17 	ldw	r2,-20(fp)
 90b7638:	10c00317 	ldw	r3,12(r2)
 90b763c:	e0bff717 	ldw	r2,-36(fp)
 90b7640:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 90b7644:	e0bffc17 	ldw	r2,-16(fp)
 90b7648:	10800517 	ldw	r2,20(r2)
 90b764c:	108000a0 	cmpeqi	r2,r2,2
 90b7650:	10000a1e 	bne	r2,zero,90b767c <tcp_usrreq+0x438>
 90b7654:	e0bffc17 	ldw	r2,-16(fp)
 90b7658:	10800517 	ldw	r2,20(r2)
 90b765c:	108000e0 	cmpeqi	r2,r2,3
 90b7660:	1000061e 	bne	r2,zero,90b767c <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 90b7664:	e0bffc17 	ldw	r2,-16(fp)
 90b7668:	11400517 	ldw	r5,20(r2)
 90b766c:	01024374 	movhi	r4,2317
 90b7670:	213fa404 	addi	r4,r4,-368
 90b7674:	90825100 	call	9082510 <printf>
            dtrap();
 90b7678:	90a94880 	call	90a9488 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 90b767c:	008243b4 	movhi	r2,2318
 90b7680:	10b56004 	addi	r2,r2,-10880
 90b7684:	10800517 	ldw	r2,20(r2)
 90b7688:	10c00044 	addi	r3,r2,1
 90b768c:	008243b4 	movhi	r2,2318
 90b7690:	10b56004 	addi	r2,r2,-10880
 90b7694:	10c00515 	stw	r3,20(r2)
         break;
 90b7698:	0000a306 	br	90b7928 <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 90b769c:	e13ffc17 	ldw	r4,-16(fp)
 90b76a0:	90b07b40 	call	90b07b4 <socantsendmore>
      tp = tcp_usrclosed(tp);
 90b76a4:	e13ffa17 	ldw	r4,-24(fp)
 90b76a8:	90b7b500 	call	90b7b50 <tcp_usrclosed>
 90b76ac:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 90b76b0:	e0bffa17 	ldw	r2,-24(fp)
 90b76b4:	1005003a 	cmpeq	r2,r2,zero
 90b76b8:	10009b1e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 90b76bc:	e13ffa17 	ldw	r4,-24(fp)
 90b76c0:	90b4d640 	call	90b4d64 <tcp_output>
 90b76c4:	e0bff915 	stw	r2,-28(fp)
      break;
 90b76c8:	00009706 	br	90b7928 <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 90b76cc:	e13ffa17 	ldw	r4,-24(fp)
 90b76d0:	90b4d640 	call	90b4d64 <tcp_output>
      break;
 90b76d4:	00009406 	br	90b7928 <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 90b76d8:	e0bffc17 	ldw	r2,-16(fp)
 90b76dc:	10800117 	ldw	r2,4(r2)
 90b76e0:	1004c03a 	cmpne	r2,r2,zero
 90b76e4:	1000031e 	bne	r2,zero,90b76f4 <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 90b76e8:	00800804 	movi	r2,32
 90b76ec:	e0bff915 	stw	r2,-28(fp)
         break;
 90b76f0:	00008d06 	br	90b7928 <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 90b76f4:	e0bffc17 	ldw	r2,-16(fp)
 90b76f8:	11001204 	addi	r4,r2,72
 90b76fc:	e17ffd17 	ldw	r5,-12(fp)
 90b7700:	90b0ab80 	call	90b0ab8 <sbappend>
      error = tcp_output(tp);
 90b7704:	e13ffa17 	ldw	r4,-24(fp)
 90b7708:	90b4d640 	call	90b4d64 <tcp_output>
 90b770c:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 90b7710:	e0bff917 	ldw	r2,-28(fp)
 90b7714:	10801a58 	cmpnei	r2,r2,105
 90b7718:	1000831e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 90b771c:	e0bffc17 	ldw	r2,-16(fp)
 90b7720:	11001204 	addi	r4,r2,72
 90b7724:	e17ffd17 	ldw	r5,-12(fp)
 90b7728:	90b12900 	call	90b1290 <sbdropend>
      break;
 90b772c:	00007e06 	br	90b7928 <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 90b7730:	e13ffa17 	ldw	r4,-24(fp)
 90b7734:	01401c44 	movi	r5,113
 90b7738:	90b67d40 	call	90b67d4 <tcp_drop>
      break;
 90b773c:	00007a06 	br	90b7928 <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 90b7740:	90a94880 	call	90a9488 <dtrap>
      return (0);
 90b7744:	e03fff15 	stw	zero,-4(fp)
 90b7748:	00007906 	br	90b7930 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 90b774c:	e0bffc17 	ldw	r2,-16(fp)
 90b7750:	10801a17 	ldw	r2,104(r2)
 90b7754:	1004c03a 	cmpne	r2,r2,zero
 90b7758:	1000061e 	bne	r2,zero,90b7774 <tcp_usrreq+0x530>
 90b775c:	e0bffc17 	ldw	r2,-16(fp)
 90b7760:	1080088b 	ldhu	r2,34(r2)
 90b7764:	10bfffcc 	andi	r2,r2,65535
 90b7768:	1080100c 	andi	r2,r2,64
 90b776c:	1005003a 	cmpeq	r2,r2,zero
 90b7770:	10000b1e 	bne	r2,zero,90b77a0 <tcp_usrreq+0x55c>
 90b7774:	e0bffc17 	ldw	r2,-16(fp)
 90b7778:	10800417 	ldw	r2,16(r2)
 90b777c:	1080400c 	andi	r2,r2,256
 90b7780:	1004c03a 	cmpne	r2,r2,zero
 90b7784:	1000061e 	bne	r2,zero,90b77a0 <tcp_usrreq+0x55c>
 90b7788:	e0bffa17 	ldw	r2,-24(fp)
 90b778c:	10802403 	ldbu	r2,144(r2)
 90b7790:	10803fcc 	andi	r2,r2,255
 90b7794:	1080008c 	andi	r2,r2,2
 90b7798:	1005003a 	cmpeq	r2,r2,zero
 90b779c:	1000031e 	bne	r2,zero,90b77ac <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 90b77a0:	00800584 	movi	r2,22
 90b77a4:	e0bff915 	stw	r2,-28(fp)
         break;
 90b77a8:	00005f06 	br	90b7928 <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 90b77ac:	e0bffa17 	ldw	r2,-24(fp)
 90b77b0:	10802403 	ldbu	r2,144(r2)
 90b77b4:	10803fcc 	andi	r2,r2,255
 90b77b8:	1080004c 	andi	r2,r2,1
 90b77bc:	1004c03a 	cmpne	r2,r2,zero
 90b77c0:	1000031e 	bne	r2,zero,90b77d0 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 90b77c4:	008002c4 	movi	r2,11
 90b77c8:	e0bff915 	stw	r2,-28(fp)
         break;
 90b77cc:	00005606 	br	90b7928 <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 90b77d0:	e0fffd17 	ldw	r3,-12(fp)
 90b77d4:	00800044 	movi	r2,1
 90b77d8:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 90b77dc:	e0bffd17 	ldw	r2,-12(fp)
 90b77e0:	10c00317 	ldw	r3,12(r2)
 90b77e4:	e0bffa17 	ldw	r2,-24(fp)
 90b77e8:	10802443 	ldbu	r2,145(r2)
 90b77ec:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 90b77f0:	e0bffe17 	ldw	r2,-8(fp)
 90b77f4:	1080008c 	andi	r2,r2,2
 90b77f8:	1004c03a 	cmpne	r2,r2,zero
 90b77fc:	10004a1e 	bne	r2,zero,90b7928 <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 90b7800:	e0bffa17 	ldw	r2,-24(fp)
 90b7804:	10802403 	ldbu	r2,144(r2)
 90b7808:	108000dc 	xori	r2,r2,3
 90b780c:	1007883a 	mov	r3,r2
 90b7810:	e0bffa17 	ldw	r2,-24(fp)
 90b7814:	10c02405 	stb	r3,144(r2)
      break;
 90b7818:	00004306 	br	90b7928 <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 90b781c:	e0bffc17 	ldw	r2,-16(fp)
 90b7820:	10800117 	ldw	r2,4(r2)
 90b7824:	1004c03a 	cmpne	r2,r2,zero
 90b7828:	1000031e 	bne	r2,zero,90b7838 <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 90b782c:	00800804 	movi	r2,32
 90b7830:	e0bff915 	stw	r2,-28(fp)
         break;
 90b7834:	00003c06 	br	90b7928 <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 90b7838:	e0bffc17 	ldw	r2,-16(fp)
 90b783c:	10801317 	ldw	r2,76(r2)
 90b7840:	1007883a 	mov	r3,r2
 90b7844:	e0bffc17 	ldw	r2,-16(fp)
 90b7848:	10801217 	ldw	r2,72(r2)
 90b784c:	1885c83a 	sub	r2,r3,r2
 90b7850:	1004803a 	cmplt	r2,r2,zero
 90b7854:	1000051e 	bne	r2,zero,90b786c <tcp_usrreq+0x628>
 90b7858:	e0bffc17 	ldw	r2,-16(fp)
 90b785c:	10c01317 	ldw	r3,76(r2)
 90b7860:	e0bffc17 	ldw	r2,-16(fp)
 90b7864:	10801217 	ldw	r2,72(r2)
 90b7868:	1880051e 	bne	r3,r2,90b7880 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 90b786c:	e13ffd17 	ldw	r4,-12(fp)
 90b7870:	90aa5a40 	call	90aa5a4 <m_freem>
         error = ENOBUFS;
 90b7874:	00801a44 	movi	r2,105
 90b7878:	e0bff915 	stw	r2,-28(fp)
         break;
 90b787c:	00002a06 	br	90b7928 <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 90b7880:	e0bffc17 	ldw	r2,-16(fp)
 90b7884:	11001204 	addi	r4,r2,72
 90b7888:	e17ffd17 	ldw	r5,-12(fp)
 90b788c:	90b0ab80 	call	90b0ab8 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 90b7890:	e0bffa17 	ldw	r2,-24(fp)
 90b7894:	10c00e17 	ldw	r3,56(r2)
 90b7898:	e0bffc17 	ldw	r2,-16(fp)
 90b789c:	10801217 	ldw	r2,72(r2)
 90b78a0:	1887883a 	add	r3,r3,r2
 90b78a4:	e0bffa17 	ldw	r2,-24(fp)
 90b78a8:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 90b78ac:	e0fffa17 	ldw	r3,-24(fp)
 90b78b0:	00800044 	movi	r2,1
 90b78b4:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 90b78b8:	e13ffa17 	ldw	r4,-24(fp)
 90b78bc:	90b4d640 	call	90b4d64 <tcp_output>
 90b78c0:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 90b78c4:	e0bff917 	ldw	r2,-28(fp)
 90b78c8:	10801a58 	cmpnei	r2,r2,105
 90b78cc:	1000041e 	bne	r2,zero,90b78e0 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 90b78d0:	e0bffc17 	ldw	r2,-16(fp)
 90b78d4:	11001204 	addi	r4,r2,72
 90b78d8:	e17ffd17 	ldw	r5,-12(fp)
 90b78dc:	90b12900 	call	90b1290 <sbdropend>
      tp->t_force = 0;
 90b78e0:	e0bffa17 	ldw	r2,-24(fp)
 90b78e4:	10000a85 	stb	zero,42(r2)
      break;
 90b78e8:	00000f06 	br	90b7928 <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 90b78ec:	e13ffb17 	ldw	r4,-20(fp)
 90b78f0:	e17ffe17 	ldw	r5,-8(fp)
 90b78f4:	90c6eac0 	call	90c6eac <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 90b78f8:	00000b06 	br	90b7928 <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 90b78fc:	e13ffb17 	ldw	r4,-20(fp)
 90b7900:	e17ffe17 	ldw	r5,-8(fp)
 90b7904:	90c6f280 	call	90c6f28 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 90b7908:	00000706 	br	90b7928 <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 90b790c:	e17ffe17 	ldw	r5,-8(fp)
 90b7910:	e13ffa17 	ldw	r4,-24(fp)
 90b7914:	90b6da80 	call	90b6da8 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 90b7918:	00000306 	br	90b7928 <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 90b791c:	01024374 	movhi	r4,2317
 90b7920:	213fac04 	addi	r4,r4,-336
 90b7924:	90a438c0 	call	90a438c <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 90b7928:	e0bff917 	ldw	r2,-28(fp)
 90b792c:	e0bfff15 	stw	r2,-4(fp)
 90b7930:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7934:	e037883a 	mov	sp,fp
 90b7938:	dfc00117 	ldw	ra,4(sp)
 90b793c:	df000017 	ldw	fp,0(sp)
 90b7940:	dec00204 	addi	sp,sp,8
 90b7944:	f800283a 	ret

090b7948 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 90b7948:	defff804 	addi	sp,sp,-32
 90b794c:	dfc00715 	stw	ra,28(sp)
 90b7950:	df000615 	stw	fp,24(sp)
 90b7954:	df000604 	addi	fp,sp,24
 90b7958:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 90b795c:	e0bffe17 	ldw	r2,-8(fp)
 90b7960:	10801317 	ldw	r2,76(r2)
 90b7964:	1005003a 	cmpeq	r2,r2,zero
 90b7968:	1000041e 	bne	r2,zero,90b797c <tcp_attach+0x34>
 90b796c:	e0bffe17 	ldw	r2,-8(fp)
 90b7970:	10800b17 	ldw	r2,44(r2)
 90b7974:	1004c03a 	cmpne	r2,r2,zero
 90b7978:	10000b1e 	bne	r2,zero,90b79a8 <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 90b797c:	d1603e17 	ldw	r5,-32520(gp)
 90b7980:	d1a03f17 	ldw	r6,-32516(gp)
 90b7984:	e13ffe17 	ldw	r4,-8(fp)
 90b7988:	90b09900 	call	90b0990 <soreserve>
 90b798c:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 90b7990:	e0bffb17 	ldw	r2,-20(fp)
 90b7994:	1005003a 	cmpeq	r2,r2,zero
 90b7998:	1000031e 	bne	r2,zero,90b79a8 <tcp_attach+0x60>
         return (error);
 90b799c:	e0bffb17 	ldw	r2,-20(fp)
 90b79a0:	e0bfff15 	stw	r2,-4(fp)
 90b79a4:	00002f06 	br	90b7a64 <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 90b79a8:	e13ffe17 	ldw	r4,-8(fp)
 90b79ac:	014243b4 	movhi	r5,2318
 90b79b0:	29758304 	addi	r5,r5,-10740
 90b79b4:	90c69000 	call	90c6900 <in_pcballoc>
 90b79b8:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 90b79bc:	e0bffb17 	ldw	r2,-20(fp)
 90b79c0:	1005003a 	cmpeq	r2,r2,zero
 90b79c4:	1000031e 	bne	r2,zero,90b79d4 <tcp_attach+0x8c>
      return (error);
 90b79c8:	e0bffb17 	ldw	r2,-20(fp)
 90b79cc:	e0bfff15 	stw	r2,-4(fp)
 90b79d0:	00002406 	br	90b7a64 <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 90b79d4:	e0bffe17 	ldw	r2,-8(fp)
 90b79d8:	10800117 	ldw	r2,4(r2)
 90b79dc:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 90b79e0:	e13ffc17 	ldw	r4,-16(fp)
 90b79e4:	90b66bc0 	call	90b66bc <tcp_newtcpcb>
 90b79e8:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 90b79ec:	e0bffd17 	ldw	r2,-12(fp)
 90b79f0:	1004c03a 	cmpne	r2,r2,zero
 90b79f4:	1000181e 	bne	r2,zero,90b7a58 <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 90b79f8:	e0bffe17 	ldw	r2,-8(fp)
 90b79fc:	1080088b 	ldhu	r2,34(r2)
 90b7a00:	10bfffcc 	andi	r2,r2,65535
 90b7a04:	1080004c 	andi	r2,r2,1
 90b7a08:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 90b7a0c:	e0bffe17 	ldw	r2,-8(fp)
 90b7a10:	10c0088b 	ldhu	r3,34(r2)
 90b7a14:	00bfff84 	movi	r2,-2
 90b7a18:	1884703a 	and	r2,r3,r2
 90b7a1c:	1007883a 	mov	r3,r2
 90b7a20:	e0bffe17 	ldw	r2,-8(fp)
 90b7a24:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 90b7a28:	e13ffc17 	ldw	r4,-16(fp)
 90b7a2c:	90c69940 	call	90c6994 <in_pcbdetach>
      so->so_state |= nofd;
 90b7a30:	e0bffe17 	ldw	r2,-8(fp)
 90b7a34:	10c0088b 	ldhu	r3,34(r2)
 90b7a38:	e0bffa17 	ldw	r2,-24(fp)
 90b7a3c:	1884b03a 	or	r2,r3,r2
 90b7a40:	1007883a 	mov	r3,r2
 90b7a44:	e0bffe17 	ldw	r2,-8(fp)
 90b7a48:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 90b7a4c:	00801a44 	movi	r2,105
 90b7a50:	e0bfff15 	stw	r2,-4(fp)
 90b7a54:	00000306 	br	90b7a64 <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 90b7a58:	e0bffd17 	ldw	r2,-12(fp)
 90b7a5c:	10000215 	stw	zero,8(r2)
   return (0);
 90b7a60:	e03fff15 	stw	zero,-4(fp)
 90b7a64:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7a68:	e037883a 	mov	sp,fp
 90b7a6c:	dfc00117 	ldw	ra,4(sp)
 90b7a70:	df000017 	ldw	fp,0(sp)
 90b7a74:	dec00204 	addi	sp,sp,8
 90b7a78:	f800283a 	ret

090b7a7c <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 90b7a7c:	defffc04 	addi	sp,sp,-16
 90b7a80:	dfc00315 	stw	ra,12(sp)
 90b7a84:	df000215 	stw	fp,8(sp)
 90b7a88:	df000204 	addi	fp,sp,8
 90b7a8c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b7a90:	e0bfff17 	ldw	r2,-4(fp)
 90b7a94:	10800d17 	ldw	r2,52(r2)
 90b7a98:	10800817 	ldw	r2,32(r2)
 90b7a9c:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 90b7aa0:	e0bfff17 	ldw	r2,-4(fp)
 90b7aa4:	10800217 	ldw	r2,8(r2)
 90b7aa8:	10800108 	cmpgei	r2,r2,4
 90b7aac:	1000041e 	bne	r2,zero,90b7ac0 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 90b7ab0:	e13fff17 	ldw	r4,-4(fp)
 90b7ab4:	90b68800 	call	90b6880 <tcp_close>
 90b7ab8:	e0bfff15 	stw	r2,-4(fp)
 90b7abc:	00001e06 	br	90b7b38 <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b7ac0:	e0bffe17 	ldw	r2,-8(fp)
 90b7ac4:	10800417 	ldw	r2,16(r2)
 90b7ac8:	1080200c 	andi	r2,r2,128
 90b7acc:	1005003a 	cmpeq	r2,r2,zero
 90b7ad0:	10000c1e 	bne	r2,zero,90b7b04 <tcp_disconnect+0x88>
 90b7ad4:	e0bffe17 	ldw	r2,-8(fp)
 90b7ad8:	1080080b 	ldhu	r2,32(r2)
 90b7adc:	10bfffcc 	andi	r2,r2,65535
 90b7ae0:	10a0001c 	xori	r2,r2,32768
 90b7ae4:	10a00004 	addi	r2,r2,-32768
 90b7ae8:	1004c03a 	cmpne	r2,r2,zero
 90b7aec:	1000051e 	bne	r2,zero,90b7b04 <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 90b7af0:	e13fff17 	ldw	r4,-4(fp)
 90b7af4:	000b883a 	mov	r5,zero
 90b7af8:	90b67d40 	call	90b67d4 <tcp_drop>
 90b7afc:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b7b00:	00000d06 	br	90b7b38 <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 90b7b04:	e13ffe17 	ldw	r4,-8(fp)
 90b7b08:	90b02840 	call	90b0284 <soisdisconnecting>
      sbflush(&so->so_rcv);
 90b7b0c:	e0bffe17 	ldw	r2,-8(fp)
 90b7b10:	11000a04 	addi	r4,r2,40
 90b7b14:	90b10300 	call	90b1030 <sbflush>
      tp = tcp_usrclosed(tp);
 90b7b18:	e13fff17 	ldw	r4,-4(fp)
 90b7b1c:	90b7b500 	call	90b7b50 <tcp_usrclosed>
 90b7b20:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 90b7b24:	e0bfff17 	ldw	r2,-4(fp)
 90b7b28:	1005003a 	cmpeq	r2,r2,zero
 90b7b2c:	1000021e 	bne	r2,zero,90b7b38 <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 90b7b30:	e13fff17 	ldw	r4,-4(fp)
 90b7b34:	90b4d640 	call	90b4d64 <tcp_output>
   }
   return (tp);
 90b7b38:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7b3c:	e037883a 	mov	sp,fp
 90b7b40:	dfc00117 	ldw	ra,4(sp)
 90b7b44:	df000017 	ldw	fp,0(sp)
 90b7b48:	dec00204 	addi	sp,sp,8
 90b7b4c:	f800283a 	ret

090b7b50 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 90b7b50:	defffc04 	addi	sp,sp,-16
 90b7b54:	dfc00315 	stw	ra,12(sp)
 90b7b58:	df000215 	stw	fp,8(sp)
 90b7b5c:	df000204 	addi	fp,sp,8
 90b7b60:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 90b7b64:	e0bffe17 	ldw	r2,-8(fp)
 90b7b68:	10800217 	ldw	r2,8(r2)
 90b7b6c:	e0bfff15 	stw	r2,-4(fp)
 90b7b70:	e0ffff17 	ldw	r3,-4(fp)
 90b7b74:	188001a8 	cmpgeui	r2,r3,6
 90b7b78:	10001c1e 	bne	r2,zero,90b7bec <tcp_usrclosed+0x9c>
 90b7b7c:	e13fff17 	ldw	r4,-4(fp)
 90b7b80:	e13fff17 	ldw	r4,-4(fp)
 90b7b84:	2105883a 	add	r2,r4,r4
 90b7b88:	1087883a 	add	r3,r2,r2
 90b7b8c:	008242f4 	movhi	r2,2315
 90b7b90:	109ee804 	addi	r2,r2,31648
 90b7b94:	1885883a 	add	r2,r3,r2
 90b7b98:	10800017 	ldw	r2,0(r2)
 90b7b9c:	1000683a 	jmp	r2
 90b7ba0:	090b7bb8 	rdprs	r4,at,11758
 90b7ba4:	090b7bb8 	rdprs	r4,at,11758
 90b7ba8:	090b7bb8 	rdprs	r4,at,11758
 90b7bac:	090b7bd0 	cmplti	r4,at,11759
 90b7bb0:	090b7bd0 	cmplti	r4,at,11759
 90b7bb4:	090b7be0 	cmpeqi	r4,at,11759
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 90b7bb8:	e0bffe17 	ldw	r2,-8(fp)
 90b7bbc:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 90b7bc0:	e13ffe17 	ldw	r4,-8(fp)
 90b7bc4:	90b68800 	call	90b6880 <tcp_close>
 90b7bc8:	e0bffe15 	stw	r2,-8(fp)
      break;
 90b7bcc:	00000706 	br	90b7bec <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 90b7bd0:	e0fffe17 	ldw	r3,-8(fp)
 90b7bd4:	00800184 	movi	r2,6
 90b7bd8:	18800215 	stw	r2,8(r3)
      break;
 90b7bdc:	00000306 	br	90b7bec <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 90b7be0:	e0fffe17 	ldw	r3,-8(fp)
 90b7be4:	00800204 	movi	r2,8
 90b7be8:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 90b7bec:	e0bffe17 	ldw	r2,-8(fp)
 90b7bf0:	1005003a 	cmpeq	r2,r2,zero
 90b7bf4:	1000081e 	bne	r2,zero,90b7c18 <tcp_usrclosed+0xc8>
 90b7bf8:	e0bffe17 	ldw	r2,-8(fp)
 90b7bfc:	10800217 	ldw	r2,8(r2)
 90b7c00:	10800250 	cmplti	r2,r2,9
 90b7c04:	1000041e 	bne	r2,zero,90b7c18 <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 90b7c08:	e0bffe17 	ldw	r2,-8(fp)
 90b7c0c:	10800d17 	ldw	r2,52(r2)
 90b7c10:	11000817 	ldw	r4,32(r2)
 90b7c14:	90b03100 	call	90b0310 <soisdisconnected>
   return (tp);
 90b7c18:	e0bffe17 	ldw	r2,-8(fp)
}
 90b7c1c:	e037883a 	mov	sp,fp
 90b7c20:	dfc00117 	ldw	ra,4(sp)
 90b7c24:	df000017 	ldw	fp,0(sp)
 90b7c28:	dec00204 	addi	sp,sp,8
 90b7c2c:	f800283a 	ret

090b7c30 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 90b7c30:	defffc04 	addi	sp,sp,-16
 90b7c34:	dfc00315 	stw	ra,12(sp)
 90b7c38:	df000215 	stw	fp,8(sp)
 90b7c3c:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 90b7c40:	90aacc80 	call	90aacc8 <nptcp_init>
 90b7c44:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90b7c48:	e0bffe17 	ldw	r2,-8(fp)
 90b7c4c:	1005003a 	cmpeq	r2,r2,zero
 90b7c50:	1000031e 	bne	r2,zero,90b7c60 <tcpinit+0x30>
      return e;
 90b7c54:	e0bffe17 	ldw	r2,-8(fp)
 90b7c58:	e0bfff15 	stw	r2,-4(fp)
 90b7c5c:	00000106 	br	90b7c64 <tcpinit+0x34>

   return 0;   /* good return */
 90b7c60:	e03fff15 	stw	zero,-4(fp)
 90b7c64:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7c68:	e037883a 	mov	sp,fp
 90b7c6c:	dfc00117 	ldw	ra,4(sp)
 90b7c70:	df000017 	ldw	fp,0(sp)
 90b7c74:	dec00204 	addi	sp,sp,8
 90b7c78:	f800283a 	ret

090b7c7c <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 90b7c7c:	defffc04 	addi	sp,sp,-16
 90b7c80:	df000315 	stw	fp,12(sp)
 90b7c84:	df000304 	addi	fp,sp,12
 90b7c88:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90b7c8c:	00824374 	movhi	r2,2317
 90b7c90:	108c3604 	addi	r2,r2,12504
 90b7c94:	10800017 	ldw	r2,0(r2)
 90b7c98:	e0bffd15 	stw	r2,-12(fp)
 90b7c9c:	00000a06 	br	90b7cc8 <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 90b7ca0:	e0bffd17 	ldw	r2,-12(fp)
 90b7ca4:	10c00617 	ldw	r3,24(r2)
 90b7ca8:	e0bffe17 	ldw	r2,-8(fp)
 90b7cac:	1880031e 	bne	r3,r2,90b7cbc <udp_lookup+0x40>
      return (tmp);
 90b7cb0:	e0bffd17 	ldw	r2,-12(fp)
 90b7cb4:	e0bfff15 	stw	r2,-4(fp)
 90b7cb8:	00000706 	br	90b7cd8 <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90b7cbc:	e0bffd17 	ldw	r2,-12(fp)
 90b7cc0:	10800017 	ldw	r2,0(r2)
 90b7cc4:	e0bffd15 	stw	r2,-12(fp)
 90b7cc8:	e0bffd17 	ldw	r2,-12(fp)
 90b7ccc:	1004c03a 	cmpne	r2,r2,zero
 90b7cd0:	103ff31e 	bne	r2,zero,90b7ca0 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 90b7cd4:	e03fff15 	stw	zero,-4(fp)
 90b7cd8:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7cdc:	e037883a 	mov	sp,fp
 90b7ce0:	df000017 	ldw	fp,0(sp)
 90b7ce4:	dec00104 	addi	sp,sp,4
 90b7ce8:	f800283a 	ret

090b7cec <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 90b7cec:	defff404 	addi	sp,sp,-48
 90b7cf0:	dfc00b15 	stw	ra,44(sp)
 90b7cf4:	df000a15 	stw	fp,40(sp)
 90b7cf8:	df000a04 	addi	fp,sp,40
 90b7cfc:	e13ffd15 	stw	r4,-12(fp)
 90b7d00:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 90b7d04:	e0bffe17 	ldw	r2,-8(fp)
 90b7d08:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 90b7d0c:	0009883a 	mov	r4,zero
 90b7d10:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 90b7d14:	e0bff717 	ldw	r2,-36(fp)
 90b7d18:	10c00a17 	ldw	r3,40(r2)
 90b7d1c:	e0bffd17 	ldw	r2,-12(fp)
 90b7d20:	10800417 	ldw	r2,16(r2)
 90b7d24:	1887883a 	add	r3,r3,r2
 90b7d28:	e0bff717 	ldw	r2,-36(fp)
 90b7d2c:	10800b17 	ldw	r2,44(r2)
 90b7d30:	18800536 	bltu	r3,r2,90b7d48 <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b7d34:	0009883a 	mov	r4,zero
 90b7d38:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b7d3c:	00801a44 	movi	r2,105
 90b7d40:	e0bfff15 	stw	r2,-4(fp)
 90b7d44:	00005106 	br	90b7e8c <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 90b7d48:	01000044 	movi	r4,1
 90b7d4c:	000b883a 	mov	r5,zero
 90b7d50:	90aa2c80 	call	90aa2c8 <m_getnbuf>
 90b7d54:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 90b7d58:	e0bff817 	ldw	r2,-32(fp)
 90b7d5c:	1004c03a 	cmpne	r2,r2,zero
 90b7d60:	1000051e 	bne	r2,zero,90b7d78 <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b7d64:	0009883a 	mov	r4,zero
 90b7d68:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b7d6c:	00801a44 	movi	r2,105
 90b7d70:	e0bfff15 	stw	r2,-4(fp)
 90b7d74:	00004506 	br	90b7e8c <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 90b7d78:	e0fff817 	ldw	r3,-32(fp)
 90b7d7c:	e0bffd17 	ldw	r2,-12(fp)
 90b7d80:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 90b7d84:	e0bffd17 	ldw	r2,-12(fp)
 90b7d88:	10c00317 	ldw	r3,12(r2)
 90b7d8c:	e0bff817 	ldw	r2,-32(fp)
 90b7d90:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90b7d94:	e0bffd17 	ldw	r2,-12(fp)
 90b7d98:	10c00417 	ldw	r3,16(r2)
 90b7d9c:	e0bff817 	ldw	r2,-32(fp)
 90b7da0:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 90b7da4:	e0bffd17 	ldw	r2,-12(fp)
 90b7da8:	10c00117 	ldw	r3,4(r2)
 90b7dac:	e0bff817 	ldw	r2,-32(fp)
 90b7db0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 90b7db4:	e0bffd17 	ldw	r2,-12(fp)
 90b7db8:	10c00217 	ldw	r3,8(r2)
 90b7dbc:	e0bff817 	ldw	r2,-32(fp)
 90b7dc0:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 90b7dc4:	e0bffd17 	ldw	r2,-12(fp)
 90b7dc8:	10800717 	ldw	r2,28(r2)
 90b7dcc:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 90b7dd0:	e0bffd17 	ldw	r2,-12(fp)
 90b7dd4:	10800317 	ldw	r2,12(r2)
 90b7dd8:	10bffe04 	addi	r2,r2,-8
 90b7ddc:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 90b7de0:	e0bff617 	ldw	r2,-40(fp)
 90b7de4:	1080000b 	ldhu	r2,0(r2)
 90b7de8:	10bfffcc 	andi	r2,r2,65535
 90b7dec:	1004d23a 	srli	r2,r2,8
 90b7df0:	10803fcc 	andi	r2,r2,255
 90b7df4:	1009883a 	mov	r4,r2
 90b7df8:	e0bff617 	ldw	r2,-40(fp)
 90b7dfc:	1080000b 	ldhu	r2,0(r2)
 90b7e00:	10bfffcc 	andi	r2,r2,65535
 90b7e04:	1004923a 	slli	r2,r2,8
 90b7e08:	1007883a 	mov	r3,r2
 90b7e0c:	00bfc004 	movi	r2,-256
 90b7e10:	1884703a 	and	r2,r3,r2
 90b7e14:	2084b03a 	or	r2,r4,r2
 90b7e18:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 90b7e1c:	00800084 	movi	r2,2
 90b7e20:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 90b7e24:	e0bff717 	ldw	r2,-36(fp)
 90b7e28:	11000a04 	addi	r4,r2,40
 90b7e2c:	e17ff904 	addi	r5,fp,-28
 90b7e30:	e1bff817 	ldw	r6,-32(fp)
 90b7e34:	90b0c400 	call	90b0c40 <sbappendaddr>
 90b7e38:	1004c03a 	cmpne	r2,r2,zero
 90b7e3c:	1000091e 	bne	r2,zero,90b7e64 <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 90b7e40:	e0bff817 	ldw	r2,-32(fp)
 90b7e44:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 90b7e48:	e13ff817 	ldw	r4,-32(fp)
 90b7e4c:	90aa4700 	call	90aa470 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b7e50:	0009883a 	mov	r4,zero
 90b7e54:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b7e58:	00801a44 	movi	r2,105
 90b7e5c:	e0bfff15 	stw	r2,-4(fp)
 90b7e60:	00000a06 	br	90b7e8c <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 90b7e64:	e0bff717 	ldw	r2,-36(fp)
 90b7e68:	11000a04 	addi	r4,r2,40
 90b7e6c:	90a4ea40 	call	90a4ea4 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 90b7e70:	e0bff717 	ldw	r2,-36(fp)
 90b7e74:	11400a04 	addi	r5,r2,40
 90b7e78:	e13ff717 	ldw	r4,-36(fp)
 90b7e7c:	90b08f40 	call	90b08f4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90b7e80:	0009883a 	mov	r4,zero
 90b7e84:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return 0;
 90b7e88:	e03fff15 	stw	zero,-4(fp)
 90b7e8c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7e90:	e037883a 	mov	sp,fp
 90b7e94:	dfc00117 	ldw	ra,4(sp)
 90b7e98:	df000017 	ldw	fp,0(sp)
 90b7e9c:	dec00204 	addi	sp,sp,8
 90b7ea0:	f800283a 	ret

090b7ea4 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90b7ea4:	defff704 	addi	sp,sp,-36
 90b7ea8:	dfc00815 	stw	ra,32(sp)
 90b7eac:	df000715 	stw	fp,28(sp)
 90b7eb0:	df000704 	addi	fp,sp,28
 90b7eb4:	e13ffc15 	stw	r4,-16(fp)
 90b7eb8:	e17ffd15 	stw	r5,-12(fp)
 90b7ebc:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 90b7ec0:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 90b7ec4:	e0bffc17 	ldw	r2,-16(fp)
 90b7ec8:	10800717 	ldw	r2,28(r2)
 90b7ecc:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 90b7ed0:	e0bffa17 	ldw	r2,-24(fp)
 90b7ed4:	10800468 	cmpgeui	r2,r2,17
 90b7ed8:	10008b1e 	bne	r2,zero,90b8108 <udp_usrreq+0x264>
 90b7edc:	e0bffa17 	ldw	r2,-24(fp)
 90b7ee0:	1085883a 	add	r2,r2,r2
 90b7ee4:	1087883a 	add	r3,r2,r2
 90b7ee8:	008242f4 	movhi	r2,2315
 90b7eec:	109fbf04 	addi	r2,r2,32508
 90b7ef0:	1885883a 	add	r2,r3,r2
 90b7ef4:	10800017 	ldw	r2,0(r2)
 90b7ef8:	1000683a 	jmp	r2
 90b7efc:	090b7f40 	call	90b7f4 <OSCtxSw_SWITCH_PC+0x90b7b4>
 90b7f00:	090b7fc8 	cmpgei	r4,at,11775
 90b7f04:	090b800c 	andi	r4,at,11776
 90b7f08:	090b8108 	cmpgei	r4,at,11780
 90b7f0c:	090b800c 	andi	r4,at,11776
 90b7f10:	090b8108 	cmpgei	r4,at,11780
 90b7f14:	090b80fc 	xorhi	r4,at,11779
 90b7f18:	090b8108 	cmpgei	r4,at,11780
 90b7f1c:	090b80fc 	xorhi	r4,at,11779
 90b7f20:	090b805c 	xori	r4,at,11777
 90b7f24:	090b8108 	cmpgei	r4,at,11780
 90b7f28:	090b8108 	cmpgei	r4,at,11780
 90b7f2c:	090b8108 	cmpgei	r4,at,11780
 90b7f30:	090b8108 	cmpgei	r4,at,11780
 90b7f34:	090b8108 	cmpgei	r4,at,11780
 90b7f38:	090b80ac 	andhi	r4,at,11778
 90b7f3c:	090b80ac 	andhi	r4,at,11778
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 90b7f40:	90c3c480 	call	90c3c48 <udp_maxalloc>
 90b7f44:	1007883a 	mov	r3,r2
 90b7f48:	e0bffc17 	ldw	r2,-16(fp)
 90b7f4c:	10c01315 	stw	r3,76(r2)
 90b7f50:	e0bffc17 	ldw	r2,-16(fp)
 90b7f54:	10c01317 	ldw	r3,76(r2)
 90b7f58:	e0bffc17 	ldw	r2,-16(fp)
 90b7f5c:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 90b7f60:	e0bffc17 	ldw	r2,-16(fp)
 90b7f64:	10800517 	ldw	r2,20(r2)
 90b7f68:	10800098 	cmpnei	r2,r2,2
 90b7f6c:	10000e1e 	bne	r2,zero,90b7fa8 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 90b7f70:	0009883a 	mov	r4,zero
 90b7f74:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 90b7f78:	90c3ab80 	call	90c3ab8 <udp_socket>
 90b7f7c:	11bfffcc 	andi	r6,r2,65535
 90b7f80:	e0bffc17 	ldw	r2,-16(fp)
 90b7f84:	d8800015 	stw	r2,0(sp)
 90b7f88:	0009883a 	mov	r4,zero
 90b7f8c:	000b883a 	mov	r5,zero
 90b7f90:	01c242f4 	movhi	r7,2315
 90b7f94:	39df3b04 	addi	r7,r7,31980
 90b7f98:	90a8fd80 	call	90a8fd8 <udp_open>
 90b7f9c:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 90b7fa0:	0009883a 	mov	r4,zero
 90b7fa4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 90b7fa8:	e0bffb17 	ldw	r2,-20(fp)
 90b7fac:	1004c03a 	cmpne	r2,r2,zero
 90b7fb0:	1000031e 	bne	r2,zero,90b7fc0 <udp_usrreq+0x11c>
         return(EINVAL);
 90b7fb4:	00800584 	movi	r2,22
 90b7fb8:	e0bfff15 	stw	r2,-4(fp)
 90b7fbc:	00005406 	br	90b8110 <udp_usrreq+0x26c>
      return 0;
 90b7fc0:	e03fff15 	stw	zero,-4(fp)
 90b7fc4:	00005206 	br	90b8110 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 90b7fc8:	e13ffc17 	ldw	r4,-16(fp)
 90b7fcc:	90b7c7c0 	call	90b7c7c <udp_lookup>
 90b7fd0:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 90b7fd4:	e0bffb17 	ldw	r2,-20(fp)
 90b7fd8:	1004c03a 	cmpne	r2,r2,zero
 90b7fdc:	1000031e 	bne	r2,zero,90b7fec <udp_usrreq+0x148>
         return(EINVAL);
 90b7fe0:	00800584 	movi	r2,22
 90b7fe4:	e0bfff15 	stw	r2,-4(fp)
 90b7fe8:	00004906 	br	90b8110 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b7fec:	0009883a 	mov	r4,zero
 90b7ff0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 90b7ff4:	e13ffb17 	ldw	r4,-20(fp)
 90b7ff8:	90a92100 	call	90a9210 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 90b7ffc:	0009883a 	mov	r4,zero
 90b8000:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      return 0;
 90b8004:	e03fff15 	stw	zero,-4(fp)
 90b8008:	00004106 	br	90b8110 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 90b800c:	e0bffe17 	ldw	r2,-8(fp)
 90b8010:	1004c03a 	cmpne	r2,r2,zero
 90b8014:	1000031e 	bne	r2,zero,90b8024 <udp_usrreq+0x180>
         return(EINVAL);
 90b8018:	00800584 	movi	r2,22
 90b801c:	e0bfff15 	stw	r2,-4(fp)
 90b8020:	00003b06 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b8024:	e0bffc17 	ldw	r2,-16(fp)
 90b8028:	10800517 	ldw	r2,20(r2)
 90b802c:	10800098 	cmpnei	r2,r2,2
 90b8030:	1000061e 	bne	r2,zero,90b804c <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 90b8034:	e13ffc17 	ldw	r4,-16(fp)
 90b8038:	e17ffe17 	ldw	r5,-8(fp)
 90b803c:	e1bffa17 	ldw	r6,-24(fp)
 90b8040:	90b81280 	call	90b8128 <udp4_sockbind>
 90b8044:	e0bfff15 	stw	r2,-4(fp)
 90b8048:	00003106 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 90b804c:	90a94880 	call	90a9488 <dtrap>
      return EINVAL;
 90b8050:	00800584 	movi	r2,22
 90b8054:	e0bfff15 	stw	r2,-4(fp)
 90b8058:	00002d06 	br	90b8110 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 90b805c:	e0bffd17 	ldw	r2,-12(fp)
 90b8060:	1004c03a 	cmpne	r2,r2,zero
 90b8064:	1000031e 	bne	r2,zero,90b8074 <udp_usrreq+0x1d0>
         return(EINVAL);
 90b8068:	00800584 	movi	r2,22
 90b806c:	e0bfff15 	stw	r2,-4(fp)
 90b8070:	00002706 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b8074:	e0bffc17 	ldw	r2,-16(fp)
 90b8078:	10800517 	ldw	r2,20(r2)
 90b807c:	10800098 	cmpnei	r2,r2,2
 90b8080:	1000061e 	bne	r2,zero,90b809c <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 90b8084:	e13ffc17 	ldw	r4,-16(fp)
 90b8088:	e17ffd17 	ldw	r5,-12(fp)
 90b808c:	e1bffe17 	ldw	r6,-8(fp)
 90b8090:	90b84640 	call	90b8464 <udp4_socksend>
 90b8094:	e0bfff15 	stw	r2,-4(fp)
 90b8098:	00001d06 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 90b809c:	90a94880 	call	90a9488 <dtrap>
      return EINVAL;
 90b80a0:	00800584 	movi	r2,22
 90b80a4:	e0bfff15 	stw	r2,-4(fp)
 90b80a8:	00001906 	br	90b8110 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 90b80ac:	e0bffe17 	ldw	r2,-8(fp)
 90b80b0:	1004c03a 	cmpne	r2,r2,zero
 90b80b4:	1000031e 	bne	r2,zero,90b80c4 <udp_usrreq+0x220>
         return(EINVAL);
 90b80b8:	00800584 	movi	r2,22
 90b80bc:	e0bfff15 	stw	r2,-4(fp)
 90b80c0:	00001306 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b80c4:	e0bffc17 	ldw	r2,-16(fp)
 90b80c8:	10800517 	ldw	r2,20(r2)
 90b80cc:	10800098 	cmpnei	r2,r2,2
 90b80d0:	1000061e 	bne	r2,zero,90b80ec <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 90b80d4:	e13ffc17 	ldw	r4,-16(fp)
 90b80d8:	e17ffe17 	ldw	r5,-8(fp)
 90b80dc:	e1bffa17 	ldw	r6,-24(fp)
 90b80e0:	90b88400 	call	90b8840 <udp4_sockaddr>
 90b80e4:	e0bfff15 	stw	r2,-4(fp)
 90b80e8:	00000906 	br	90b8110 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 90b80ec:	90a94880 	call	90a9488 <dtrap>
      return EINVAL;
 90b80f0:	00800584 	movi	r2,22
 90b80f4:	e0bfff15 	stw	r2,-4(fp)
 90b80f8:	00000506 	br	90b8110 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 90b80fc:	90a94880 	call	90a9488 <dtrap>
      return 0;
 90b8100:	e03fff15 	stw	zero,-4(fp)
 90b8104:	00000206 	br	90b8110 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 90b8108:	008017c4 	movi	r2,95
 90b810c:	e0bfff15 	stw	r2,-4(fp)
 90b8110:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90b8114:	e037883a 	mov	sp,fp
 90b8118:	dfc00117 	ldw	ra,4(sp)
 90b811c:	df000017 	ldw	fp,0(sp)
 90b8120:	dec00204 	addi	sp,sp,8
 90b8124:	f800283a 	ret

090b8128 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 90b8128:	defff304 	addi	sp,sp,-52
 90b812c:	dfc00c15 	stw	ra,48(sp)
 90b8130:	df000b15 	stw	fp,44(sp)
 90b8134:	df000b04 	addi	fp,sp,44
 90b8138:	e13ffc15 	stw	r4,-16(fp)
 90b813c:	e17ffd15 	stw	r5,-12(fp)
 90b8140:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 90b8144:	e0bffd17 	ldw	r2,-12(fp)
 90b8148:	10800317 	ldw	r2,12(r2)
 90b814c:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 90b8150:	e0bffb17 	ldw	r2,-20(fp)
 90b8154:	1004c03a 	cmpne	r2,r2,zero
 90b8158:	1000031e 	bne	r2,zero,90b8168 <udp4_sockbind+0x40>
    return(EINVAL);
 90b815c:	00800584 	movi	r2,22
 90b8160:	e0bfff15 	stw	r2,-4(fp)
 90b8164:	0000b906 	br	90b844c <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 90b8168:	e0bffd17 	ldw	r2,-12(fp)
 90b816c:	10800217 	ldw	r2,8(r2)
 90b8170:	10800420 	cmpeqi	r2,r2,16
 90b8174:	1000031e 	bne	r2,zero,90b8184 <udp4_sockbind+0x5c>
    return(EINVAL);
 90b8178:	00800584 	movi	r2,22
 90b817c:	e0bfff15 	stw	r2,-4(fp)
 90b8180:	0000b206 	br	90b844c <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 90b8184:	e13ffc17 	ldw	r4,-16(fp)
 90b8188:	90b7c7c0 	call	90b7c7c <udp_lookup>
 90b818c:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 90b8190:	e0bffa17 	ldw	r2,-24(fp)
 90b8194:	1004c03a 	cmpne	r2,r2,zero
 90b8198:	1000031e 	bne	r2,zero,90b81a8 <udp4_sockbind+0x80>
     return(EINVAL);
 90b819c:	00800584 	movi	r2,22
 90b81a0:	e0bfff15 	stw	r2,-4(fp)
 90b81a4:	0000a906 	br	90b844c <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 90b81a8:	e0bffe17 	ldw	r2,-8(fp)
 90b81ac:	10800098 	cmpnei	r2,r2,2
 90b81b0:	1000601e 	bne	r2,zero,90b8334 <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 90b81b4:	e0bffb17 	ldw	r2,-20(fp)
 90b81b8:	1080008b 	ldhu	r2,2(r2)
 90b81bc:	10bfffcc 	andi	r2,r2,65535
 90b81c0:	1004c03a 	cmpne	r2,r2,zero
 90b81c4:	10000c1e 	bne	r2,zero,90b81f8 <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 90b81c8:	e0bffa17 	ldw	r2,-24(fp)
 90b81cc:	1080018b 	ldhu	r2,6(r2)
 90b81d0:	10bfffcc 	andi	r2,r2,65535
 90b81d4:	1005003a 	cmpeq	r2,r2,zero
 90b81d8:	1000041e 	bne	r2,zero,90b81ec <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 90b81dc:	e0bffa17 	ldw	r2,-24(fp)
 90b81e0:	1080018b 	ldhu	r2,6(r2)
 90b81e4:	e0bff80d 	sth	r2,-32(fp)
 90b81e8:	00001206 	br	90b8234 <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 90b81ec:	90c3ab80 	call	90c3ab8 <udp_socket>
 90b81f0:	e0bff80d 	sth	r2,-32(fp)
 90b81f4:	00000f06 	br	90b8234 <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 90b81f8:	e0bffb17 	ldw	r2,-20(fp)
 90b81fc:	1080008b 	ldhu	r2,2(r2)
 90b8200:	10bfffcc 	andi	r2,r2,65535
 90b8204:	1004d23a 	srli	r2,r2,8
 90b8208:	10803fcc 	andi	r2,r2,255
 90b820c:	1009883a 	mov	r4,r2
 90b8210:	e0bffb17 	ldw	r2,-20(fp)
 90b8214:	1080008b 	ldhu	r2,2(r2)
 90b8218:	10bfffcc 	andi	r2,r2,65535
 90b821c:	1004923a 	slli	r2,r2,8
 90b8220:	1007883a 	mov	r3,r2
 90b8224:	00bfc004 	movi	r2,-256
 90b8228:	1884703a 	and	r2,r3,r2
 90b822c:	2084b03a 	or	r2,r4,r2
 90b8230:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 90b8234:	e0bffb17 	ldw	r2,-20(fp)
 90b8238:	10800117 	ldw	r2,4(r2)
 90b823c:	1004c03a 	cmpne	r2,r2,zero
 90b8240:	1000021e 	bne	r2,zero,90b824c <udp4_sockbind+0x124>
    {
      lhost = 0L;
 90b8244:	e03ff615 	stw	zero,-40(fp)
 90b8248:	00001806 	br	90b82ac <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 90b824c:	e0bffb17 	ldw	r2,-20(fp)
 90b8250:	10800117 	ldw	r2,4(r2)
 90b8254:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8258:	008243b4 	movhi	r2,2318
 90b825c:	10b65f04 	addi	r2,r2,-9860
 90b8260:	10800017 	ldw	r2,0(r2)
 90b8264:	e0bff515 	stw	r2,-44(fp)
 90b8268:	00000706 	br	90b8288 <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 90b826c:	e0bff517 	ldw	r2,-44(fp)
 90b8270:	10c00a17 	ldw	r3,40(r2)
 90b8274:	e0bff617 	ldw	r2,-40(fp)
 90b8278:	18800626 	beq	r3,r2,90b8294 <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b827c:	e0bff517 	ldw	r2,-44(fp)
 90b8280:	10800017 	ldw	r2,0(r2)
 90b8284:	e0bff515 	stw	r2,-44(fp)
 90b8288:	e0bff517 	ldw	r2,-44(fp)
 90b828c:	1004c03a 	cmpne	r2,r2,zero
 90b8290:	103ff61e 	bne	r2,zero,90b826c <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 90b8294:	e0bff517 	ldw	r2,-44(fp)
 90b8298:	1004c03a 	cmpne	r2,r2,zero
 90b829c:	1000031e 	bne	r2,zero,90b82ac <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 90b82a0:	00801f44 	movi	r2,125
 90b82a4:	e0bfff15 	stw	r2,-4(fp)
 90b82a8:	00006806 	br	90b844c <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 90b82ac:	e0bffc17 	ldw	r2,-16(fp)
 90b82b0:	10800417 	ldw	r2,16(r2)
 90b82b4:	1080010c 	andi	r2,r2,4
 90b82b8:	1004c03a 	cmpne	r2,r2,zero
 90b82bc:	1000161e 	bne	r2,zero,90b8318 <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 90b82c0:	00824374 	movhi	r2,2317
 90b82c4:	108c3604 	addi	r2,r2,12504
 90b82c8:	10800017 	ldw	r2,0(r2)
 90b82cc:	e0bff915 	stw	r2,-28(fp)
 90b82d0:	00000e06 	br	90b830c <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 90b82d4:	e0bff917 	ldw	r2,-28(fp)
 90b82d8:	1080018b 	ldhu	r2,6(r2)
 90b82dc:	10ffffcc 	andi	r3,r2,65535
 90b82e0:	e0bff80b 	ldhu	r2,-32(fp)
 90b82e4:	1880061e 	bne	r3,r2,90b8300 <udp4_sockbind+0x1d8>
 90b82e8:	e0fff917 	ldw	r3,-28(fp)
 90b82ec:	e0bffa17 	ldw	r2,-24(fp)
 90b82f0:	18800326 	beq	r3,r2,90b8300 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 90b82f4:	00801c04 	movi	r2,112
 90b82f8:	e0bfff15 	stw	r2,-4(fp)
 90b82fc:	00005306 	br	90b844c <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 90b8300:	e0bff917 	ldw	r2,-28(fp)
 90b8304:	10800017 	ldw	r2,0(r2)
 90b8308:	e0bff915 	stw	r2,-28(fp)
 90b830c:	e0bff917 	ldw	r2,-28(fp)
 90b8310:	1004c03a 	cmpne	r2,r2,zero
 90b8314:	103fef1e 	bne	r2,zero,90b82d4 <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 90b8318:	e0fffa17 	ldw	r3,-24(fp)
 90b831c:	e0bff80b 	ldhu	r2,-32(fp)
 90b8320:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 90b8324:	e0fffa17 	ldw	r3,-24(fp)
 90b8328:	e0bff617 	ldw	r2,-40(fp)
 90b832c:	18800315 	stw	r2,12(r3)
 90b8330:	00004506 	br	90b8448 <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 90b8334:	e0bffb17 	ldw	r2,-20(fp)
 90b8338:	1080008b 	ldhu	r2,2(r2)
 90b833c:	10bfffcc 	andi	r2,r2,65535
 90b8340:	1004d23a 	srli	r2,r2,8
 90b8344:	10803fcc 	andi	r2,r2,255
 90b8348:	1009883a 	mov	r4,r2
 90b834c:	e0bffb17 	ldw	r2,-20(fp)
 90b8350:	1080008b 	ldhu	r2,2(r2)
 90b8354:	10bfffcc 	andi	r2,r2,65535
 90b8358:	1004923a 	slli	r2,r2,8
 90b835c:	1007883a 	mov	r3,r2
 90b8360:	00bfc004 	movi	r2,-256
 90b8364:	1884703a 	and	r2,r3,r2
 90b8368:	2084b03a 	or	r2,r4,r2
 90b836c:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 90b8370:	e0bffb17 	ldw	r2,-20(fp)
 90b8374:	10800117 	ldw	r2,4(r2)
 90b8378:	1004c03a 	cmpne	r2,r2,zero
 90b837c:	1000021e 	bne	r2,zero,90b8388 <udp4_sockbind+0x260>
      fhost = 0L;
 90b8380:	e03ff715 	stw	zero,-36(fp)
 90b8384:	00000306 	br	90b8394 <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 90b8388:	e0bffb17 	ldw	r2,-20(fp)
 90b838c:	10800117 	ldw	r2,4(r2)
 90b8390:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 90b8394:	e13ff717 	ldw	r4,-36(fp)
 90b8398:	90beb200 	call	90beb20 <ip_mymach>
 90b839c:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 90b83a0:	e0bff617 	ldw	r2,-40(fp)
 90b83a4:	1004c03a 	cmpne	r2,r2,zero
 90b83a8:	1000031e 	bne	r2,zero,90b83b8 <udp4_sockbind+0x290>
      return(ENETUNREACH);
 90b83ac:	00801c84 	movi	r2,114
 90b83b0:	e0bfff15 	stw	r2,-4(fp)
 90b83b4:	00002506 	br	90b844c <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 90b83b8:	e0bffa17 	ldw	r2,-24(fp)
 90b83bc:	1080018b 	ldhu	r2,6(r2)
 90b83c0:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 90b83c4:	e0bff80b 	ldhu	r2,-32(fp)
 90b83c8:	1004c03a 	cmpne	r2,r2,zero
 90b83cc:	1000021e 	bne	r2,zero,90b83d8 <udp4_sockbind+0x2b0>
      lport = udp_socket();
 90b83d0:	90c3ab80 	call	90c3ab8 <udp_socket>
 90b83d4:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 90b83d8:	e0fffa17 	ldw	r3,-24(fp)
 90b83dc:	e0bff617 	ldw	r2,-40(fp)
 90b83e0:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 90b83e4:	e0fffa17 	ldw	r3,-24(fp)
 90b83e8:	e0bff80b 	ldhu	r2,-32(fp)
 90b83ec:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 90b83f0:	e0fffa17 	ldw	r3,-24(fp)
 90b83f4:	e0bff717 	ldw	r2,-36(fp)
 90b83f8:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 90b83fc:	e0fffa17 	ldw	r3,-24(fp)
 90b8400:	e0bff88b 	ldhu	r2,-30(fp)
 90b8404:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90b8408:	e0bffc17 	ldw	r2,-16(fp)
 90b840c:	10c0088b 	ldhu	r3,34(r2)
 90b8410:	00bffcc4 	movi	r2,-13
 90b8414:	1884703a 	and	r2,r3,r2
 90b8418:	1007883a 	mov	r3,r2
 90b841c:	e0bffc17 	ldw	r2,-16(fp)
 90b8420:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 90b8424:	e0bffc17 	ldw	r2,-16(fp)
 90b8428:	1080088b 	ldhu	r2,34(r2)
 90b842c:	10800094 	ori	r2,r2,2
 90b8430:	1007883a 	mov	r3,r2
 90b8434:	e0bffc17 	ldw	r2,-16(fp)
 90b8438:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 90b843c:	e0bffc17 	ldw	r2,-16(fp)
 90b8440:	11000a04 	addi	r4,r2,40
 90b8444:	90b10300 	call	90b1030 <sbflush>
  }
  return 0;
 90b8448:	e03fff15 	stw	zero,-4(fp)
 90b844c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8450:	e037883a 	mov	sp,fp
 90b8454:	dfc00117 	ldw	ra,4(sp)
 90b8458:	df000017 	ldw	fp,0(sp)
 90b845c:	dec00204 	addi	sp,sp,8
 90b8460:	f800283a 	ret

090b8464 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 90b8464:	defff204 	addi	sp,sp,-56
 90b8468:	dfc00d15 	stw	ra,52(sp)
 90b846c:	df000c15 	stw	fp,48(sp)
 90b8470:	dc000b15 	stw	r16,44(sp)
 90b8474:	df000b04 	addi	fp,sp,44
 90b8478:	e13ffc15 	stw	r4,-16(fp)
 90b847c:	e17ffd15 	stw	r5,-12(fp)
 90b8480:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 90b8484:	e13ffc17 	ldw	r4,-16(fp)
 90b8488:	90b7c7c0 	call	90b7c7c <udp_lookup>
 90b848c:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 90b8490:	e0bff917 	ldw	r2,-28(fp)
 90b8494:	1004c03a 	cmpne	r2,r2,zero
 90b8498:	1000051e 	bne	r2,zero,90b84b0 <udp4_socksend+0x4c>
  {
    m_free(m);
 90b849c:	e13ffd17 	ldw	r4,-12(fp)
 90b84a0:	90aa4700 	call	90aa470 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 90b84a4:	00801bc4 	movi	r2,111
 90b84a8:	e0bfff15 	stw	r2,-4(fp)
 90b84ac:	0000dd06 	br	90b8824 <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 90b84b0:	e0bffe17 	ldw	r2,-8(fp)
 90b84b4:	1004c03a 	cmpne	r2,r2,zero
 90b84b8:	1000101e 	bne	r2,zero,90b84fc <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 90b84bc:	e0bffc17 	ldw	r2,-16(fp)
 90b84c0:	1080088b 	ldhu	r2,34(r2)
 90b84c4:	10bfffcc 	andi	r2,r2,65535
 90b84c8:	1080008c 	andi	r2,r2,2
 90b84cc:	1005003a 	cmpeq	r2,r2,zero
 90b84d0:	1000071e 	bne	r2,zero,90b84f0 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 90b84d4:	e0bff917 	ldw	r2,-28(fp)
 90b84d8:	1080020b 	ldhu	r2,8(r2)
 90b84dc:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 90b84e0:	e0bff917 	ldw	r2,-28(fp)
 90b84e4:	10800417 	ldw	r2,16(r2)
 90b84e8:	e0bff715 	stw	r2,-36(fp)
 90b84ec:	00003106 	br	90b85b4 <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 90b84f0:	00800584 	movi	r2,22
 90b84f4:	e0bfff15 	stw	r2,-4(fp)
 90b84f8:	0000ca06 	br	90b8824 <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 90b84fc:	e0bffe17 	ldw	r2,-8(fp)
 90b8500:	10800217 	ldw	r2,8(r2)
 90b8504:	10800420 	cmpeqi	r2,r2,16
 90b8508:	1000041e 	bne	r2,zero,90b851c <udp4_socksend+0xb8>
  {
    dtrap();
 90b850c:	90a94880 	call	90a9488 <dtrap>
    return (EINVAL);
 90b8510:	00800584 	movi	r2,22
 90b8514:	e0bfff15 	stw	r2,-4(fp)
 90b8518:	0000c206 	br	90b8824 <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 90b851c:	e0bffe17 	ldw	r2,-8(fp)
 90b8520:	10800317 	ldw	r2,12(r2)
 90b8524:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 90b8528:	e0bffa17 	ldw	r2,-24(fp)
 90b852c:	10800117 	ldw	r2,4(r2)
 90b8530:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 90b8534:	e0bffa17 	ldw	r2,-24(fp)
 90b8538:	1080008b 	ldhu	r2,2(r2)
 90b853c:	10bfffcc 	andi	r2,r2,65535
 90b8540:	1005003a 	cmpeq	r2,r2,zero
 90b8544:	1000101e 	bne	r2,zero,90b8588 <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 90b8548:	e0bffa17 	ldw	r2,-24(fp)
 90b854c:	1080008b 	ldhu	r2,2(r2)
 90b8550:	10bfffcc 	andi	r2,r2,65535
 90b8554:	1004d23a 	srli	r2,r2,8
 90b8558:	10803fcc 	andi	r2,r2,255
 90b855c:	1009883a 	mov	r4,r2
 90b8560:	e0bffa17 	ldw	r2,-24(fp)
 90b8564:	1080008b 	ldhu	r2,2(r2)
 90b8568:	10bfffcc 	andi	r2,r2,65535
 90b856c:	1004923a 	slli	r2,r2,8
 90b8570:	1007883a 	mov	r3,r2
 90b8574:	00bfc004 	movi	r2,-256
 90b8578:	1884703a 	and	r2,r3,r2
 90b857c:	2084b03a 	or	r2,r4,r2
 90b8580:	e0bff80d 	sth	r2,-32(fp)
 90b8584:	00000b06 	br	90b85b4 <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 90b8588:	e0bff917 	ldw	r2,-28(fp)
 90b858c:	1080020b 	ldhu	r2,8(r2)
 90b8590:	10bfffcc 	andi	r2,r2,65535
 90b8594:	1004c03a 	cmpne	r2,r2,zero
 90b8598:	1000031e 	bne	r2,zero,90b85a8 <udp4_socksend+0x144>
        return (EINVAL);
 90b859c:	00800584 	movi	r2,22
 90b85a0:	e0bfff15 	stw	r2,-4(fp)
 90b85a4:	00009f06 	br	90b8824 <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 90b85a8:	e0bff917 	ldw	r2,-28(fp)
 90b85ac:	1080020b 	ldhu	r2,8(r2)
 90b85b0:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 90b85b4:	e0bffd17 	ldw	r2,-12(fp)
 90b85b8:	14000217 	ldw	r16,8(r2)
 90b85bc:	90c3c480 	call	90c3c48 <udp_maxalloc>
 90b85c0:	1400042e 	bgeu	r2,r16,90b85d4 <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 90b85c4:	90a94880 	call	90a9488 <dtrap>
    return EMSGSIZE;  /* try to recover */
 90b85c8:	00801e84 	movi	r2,122
 90b85cc:	e0bfff15 	stw	r2,-4(fp)
 90b85d0:	00009406 	br	90b8824 <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 90b85d4:	e0bffd17 	ldw	r2,-12(fp)
 90b85d8:	10800217 	ldw	r2,8(r2)
 90b85dc:	1009883a 	mov	r4,r2
 90b85e0:	000b883a 	mov	r5,zero
 90b85e4:	90c3b880 	call	90c3b88 <udp_alloc>
 90b85e8:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 90b85ec:	e0bff617 	ldw	r2,-40(fp)
 90b85f0:	1004c03a 	cmpne	r2,r2,zero
 90b85f4:	1000051e 	bne	r2,zero,90b860c <udp4_socksend+0x1a8>
  {
    m_free(m);
 90b85f8:	e13ffd17 	ldw	r4,-12(fp)
 90b85fc:	90aa4700 	call	90aa470 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 90b8600:	00801a44 	movi	r2,105
 90b8604:	e0bfff15 	stw	r2,-4(fp)
 90b8608:	00008606 	br	90b8824 <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 90b860c:	e0bff617 	ldw	r2,-40(fp)
 90b8610:	10c00317 	ldw	r3,12(r2)
 90b8614:	e0bffd17 	ldw	r2,-12(fp)
 90b8618:	11400317 	ldw	r5,12(r2)
 90b861c:	e0bffd17 	ldw	r2,-12(fp)
 90b8620:	10800217 	ldw	r2,8(r2)
 90b8624:	1809883a 	mov	r4,r3
 90b8628:	100d883a 	mov	r6,r2
 90b862c:	90822780 	call	9082278 <memcpy>
  pkt->nb_plen = m->m_len;
 90b8630:	e0bffd17 	ldw	r2,-12(fp)
 90b8634:	10c00217 	ldw	r3,8(r2)
 90b8638:	e0bff617 	ldw	r2,-40(fp)
 90b863c:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 90b8640:	e13ffd17 	ldw	r4,-12(fp)
 90b8644:	90aa4700 	call	90aa470 <m_free>
  pkt->fhost = fhost;
 90b8648:	e0fff617 	ldw	r3,-40(fp)
 90b864c:	e0bff717 	ldw	r2,-36(fp)
 90b8650:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 90b8654:	e0bff717 	ldw	r2,-36(fp)
 90b8658:	10bfffd8 	cmpnei	r2,r2,-1
 90b865c:	10004f1e 	bne	r2,zero,90b879c <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 90b8660:	e0bff917 	ldw	r2,-28(fp)
 90b8664:	10800317 	ldw	r2,12(r2)
 90b8668:	1005003a 	cmpeq	r2,r2,zero
 90b866c:	1000111e 	bne	r2,zero,90b86b4 <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8670:	008243b4 	movhi	r2,2318
 90b8674:	10b65f04 	addi	r2,r2,-9860
 90b8678:	10800017 	ldw	r2,0(r2)
 90b867c:	e0bff515 	stw	r2,-44(fp)
 90b8680:	00000806 	br	90b86a4 <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 90b8684:	e0bff517 	ldw	r2,-44(fp)
 90b8688:	10c00a17 	ldw	r3,40(r2)
 90b868c:	e0bff917 	ldw	r2,-28(fp)
 90b8690:	10800317 	ldw	r2,12(r2)
 90b8694:	18802126 	beq	r3,r2,90b871c <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8698:	e0bff517 	ldw	r2,-44(fp)
 90b869c:	10800017 	ldw	r2,0(r2)
 90b86a0:	e0bff515 	stw	r2,-44(fp)
 90b86a4:	e0bff517 	ldw	r2,-44(fp)
 90b86a8:	1004c03a 	cmpne	r2,r2,zero
 90b86ac:	103ff51e 	bne	r2,zero,90b8684 <udp4_socksend+0x220>
 90b86b0:	00001a06 	br	90b871c <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b86b4:	008243b4 	movhi	r2,2318
 90b86b8:	10b65f04 	addi	r2,r2,-9860
 90b86bc:	10800017 	ldw	r2,0(r2)
 90b86c0:	e0bff515 	stw	r2,-44(fp)
 90b86c4:	00001206 	br	90b8710 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 90b86c8:	e0bff517 	ldw	r2,-44(fp)
 90b86cc:	10802a17 	ldw	r2,168(r2)
 90b86d0:	1080004c 	andi	r2,r2,1
 90b86d4:	10803fcc 	andi	r2,r2,255
 90b86d8:	1005003a 	cmpeq	r2,r2,zero
 90b86dc:	1000091e 	bne	r2,zero,90b8704 <udp4_socksend+0x2a0>
 90b86e0:	e0bff517 	ldw	r2,-44(fp)
 90b86e4:	10802717 	ldw	r2,156(r2)
 90b86e8:	1005003a 	cmpeq	r2,r2,zero
 90b86ec:	1000051e 	bne	r2,zero,90b8704 <udp4_socksend+0x2a0>
 90b86f0:	e0bff517 	ldw	r2,-44(fp)
 90b86f4:	10802717 	ldw	r2,156(r2)
 90b86f8:	10800617 	ldw	r2,24(r2)
 90b86fc:	10800060 	cmpeqi	r2,r2,1
 90b8700:	1000061e 	bne	r2,zero,90b871c <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8704:	e0bff517 	ldw	r2,-44(fp)
 90b8708:	10800017 	ldw	r2,0(r2)
 90b870c:	e0bff515 	stw	r2,-44(fp)
 90b8710:	e0bff517 	ldw	r2,-44(fp)
 90b8714:	1004c03a 	cmpne	r2,r2,zero
 90b8718:	103feb1e 	bne	r2,zero,90b86c8 <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 90b871c:	e0bff517 	ldw	r2,-44(fp)
 90b8720:	1004c03a 	cmpne	r2,r2,zero
 90b8724:	10001a1e 	bne	r2,zero,90b8790 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8728:	008243b4 	movhi	r2,2318
 90b872c:	10b65f04 	addi	r2,r2,-9860
 90b8730:	10800017 	ldw	r2,0(r2)
 90b8734:	e0bff515 	stw	r2,-44(fp)
 90b8738:	00000c06 	br	90b876c <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 90b873c:	e0bff517 	ldw	r2,-44(fp)
 90b8740:	10802717 	ldw	r2,156(r2)
 90b8744:	1005003a 	cmpeq	r2,r2,zero
 90b8748:	1000051e 	bne	r2,zero,90b8760 <udp4_socksend+0x2fc>
 90b874c:	e0bff517 	ldw	r2,-44(fp)
 90b8750:	10802717 	ldw	r2,156(r2)
 90b8754:	10800617 	ldw	r2,24(r2)
 90b8758:	10800060 	cmpeqi	r2,r2,1
 90b875c:	1000061e 	bne	r2,zero,90b8778 <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b8760:	e0bff517 	ldw	r2,-44(fp)
 90b8764:	10800017 	ldw	r2,0(r2)
 90b8768:	e0bff515 	stw	r2,-44(fp)
 90b876c:	e0bff517 	ldw	r2,-44(fp)
 90b8770:	1004c03a 	cmpne	r2,r2,zero
 90b8774:	103ff11e 	bne	r2,zero,90b873c <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 90b8778:	e0bff517 	ldw	r2,-44(fp)
 90b877c:	1004c03a 	cmpne	r2,r2,zero
 90b8780:	1000031e 	bne	r2,zero,90b8790 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 90b8784:	00801f44 	movi	r2,125
 90b8788:	e0bfff15 	stw	r2,-4(fp)
 90b878c:	00002506 	br	90b8824 <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 90b8790:	e0fff617 	ldw	r3,-40(fp)
 90b8794:	e0bff517 	ldw	r2,-44(fp)
 90b8798:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 90b879c:	e0bffc17 	ldw	r2,-16(fp)
 90b87a0:	10800317 	ldw	r2,12(r2)
 90b87a4:	1005003a 	cmpeq	r2,r2,zero
 90b87a8:	1000041e 	bne	r2,zero,90b87bc <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 90b87ac:	e0bffc17 	ldw	r2,-16(fp)
 90b87b0:	10c00317 	ldw	r3,12(r2)
 90b87b4:	e0bff617 	ldw	r2,-40(fp)
 90b87b8:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 90b87bc:	e0bffc17 	ldw	r2,-16(fp)
 90b87c0:	10801f17 	ldw	r2,124(r2)
 90b87c4:	1005003a 	cmpeq	r2,r2,zero
 90b87c8:	1000041e 	bne	r2,zero,90b87dc <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 90b87cc:	e0bffc17 	ldw	r2,-16(fp)
 90b87d0:	10c01f17 	ldw	r3,124(r2)
 90b87d4:	e0bff617 	ldw	r2,-40(fp)
 90b87d8:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 90b87dc:	0009883a 	mov	r4,zero
 90b87e0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 90b87e4:	e13ff80b 	ldhu	r4,-32(fp)
 90b87e8:	e0bff917 	ldw	r2,-28(fp)
 90b87ec:	1080018b 	ldhu	r2,6(r2)
 90b87f0:	117fffcc 	andi	r5,r2,65535
 90b87f4:	e1bff617 	ldw	r6,-40(fp)
 90b87f8:	90c36d00 	call	90c36d0 <udp_send>
 90b87fc:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 90b8800:	0009883a 	mov	r4,zero
 90b8804:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
  if (e < 0) 
 90b8808:	e0bffb17 	ldw	r2,-20(fp)
 90b880c:	1004403a 	cmpge	r2,r2,zero
 90b8810:	1000031e 	bne	r2,zero,90b8820 <udp4_socksend+0x3bc>
     return(e);
 90b8814:	e0bffb17 	ldw	r2,-20(fp)
 90b8818:	e0bfff15 	stw	r2,-4(fp)
 90b881c:	00000106 	br	90b8824 <udp4_socksend+0x3c0>
  return 0;
 90b8820:	e03fff15 	stw	zero,-4(fp)
 90b8824:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8828:	e037883a 	mov	sp,fp
 90b882c:	dfc00217 	ldw	ra,8(sp)
 90b8830:	df000117 	ldw	fp,4(sp)
 90b8834:	dc000017 	ldw	r16,0(sp)
 90b8838:	dec00304 	addi	sp,sp,12
 90b883c:	f800283a 	ret

090b8840 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 90b8840:	defff804 	addi	sp,sp,-32
 90b8844:	dfc00715 	stw	ra,28(sp)
 90b8848:	df000615 	stw	fp,24(sp)
 90b884c:	df000604 	addi	fp,sp,24
 90b8850:	e13ffc15 	stw	r4,-16(fp)
 90b8854:	e17ffd15 	stw	r5,-12(fp)
 90b8858:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 90b885c:	e0bffd17 	ldw	r2,-12(fp)
 90b8860:	10800317 	ldw	r2,12(r2)
 90b8864:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 90b8868:	e0bffb17 	ldw	r2,-20(fp)
 90b886c:	1004c03a 	cmpne	r2,r2,zero
 90b8870:	1000031e 	bne	r2,zero,90b8880 <udp4_sockaddr+0x40>
     return(EINVAL);
 90b8874:	00800584 	movi	r2,22
 90b8878:	e0bfff15 	stw	r2,-4(fp)
 90b887c:	00004106 	br	90b8984 <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 90b8880:	e13ffc17 	ldw	r4,-16(fp)
 90b8884:	90b7c7c0 	call	90b7c7c <udp_lookup>
 90b8888:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 90b888c:	e0bffa17 	ldw	r2,-24(fp)
 90b8890:	1004c03a 	cmpne	r2,r2,zero
 90b8894:	1000031e 	bne	r2,zero,90b88a4 <udp4_sockaddr+0x64>
     return(EINVAL);
 90b8898:	00800584 	movi	r2,22
 90b889c:	e0bfff15 	stw	r2,-4(fp)
 90b88a0:	00003806 	br	90b8984 <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 90b88a4:	e0fffd17 	ldw	r3,-12(fp)
 90b88a8:	00800404 	movi	r2,16
 90b88ac:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 90b88b0:	e0bffe17 	ldw	r2,-8(fp)
 90b88b4:	108003d8 	cmpnei	r2,r2,15
 90b88b8:	1000191e 	bne	r2,zero,90b8920 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 90b88bc:	e0fffb17 	ldw	r3,-20(fp)
 90b88c0:	00800084 	movi	r2,2
 90b88c4:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 90b88c8:	e0bffa17 	ldw	r2,-24(fp)
 90b88cc:	1080018b 	ldhu	r2,6(r2)
 90b88d0:	10bfffcc 	andi	r2,r2,65535
 90b88d4:	1004d23a 	srli	r2,r2,8
 90b88d8:	10803fcc 	andi	r2,r2,255
 90b88dc:	1009883a 	mov	r4,r2
 90b88e0:	e0bffa17 	ldw	r2,-24(fp)
 90b88e4:	1080018b 	ldhu	r2,6(r2)
 90b88e8:	10bfffcc 	andi	r2,r2,65535
 90b88ec:	1004923a 	slli	r2,r2,8
 90b88f0:	1007883a 	mov	r3,r2
 90b88f4:	00bfc004 	movi	r2,-256
 90b88f8:	1884703a 	and	r2,r3,r2
 90b88fc:	2084b03a 	or	r2,r4,r2
 90b8900:	1007883a 	mov	r3,r2
 90b8904:	e0bffb17 	ldw	r2,-20(fp)
 90b8908:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 90b890c:	e0bffa17 	ldw	r2,-24(fp)
 90b8910:	10c00317 	ldw	r3,12(r2)
 90b8914:	e0bffb17 	ldw	r2,-20(fp)
 90b8918:	10c00115 	stw	r3,4(r2)
 90b891c:	00001806 	br	90b8980 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 90b8920:	e0fffb17 	ldw	r3,-20(fp)
 90b8924:	00800084 	movi	r2,2
 90b8928:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 90b892c:	e0bffa17 	ldw	r2,-24(fp)
 90b8930:	1080020b 	ldhu	r2,8(r2)
 90b8934:	10bfffcc 	andi	r2,r2,65535
 90b8938:	1004d23a 	srli	r2,r2,8
 90b893c:	10803fcc 	andi	r2,r2,255
 90b8940:	1009883a 	mov	r4,r2
 90b8944:	e0bffa17 	ldw	r2,-24(fp)
 90b8948:	1080020b 	ldhu	r2,8(r2)
 90b894c:	10bfffcc 	andi	r2,r2,65535
 90b8950:	1004923a 	slli	r2,r2,8
 90b8954:	1007883a 	mov	r3,r2
 90b8958:	00bfc004 	movi	r2,-256
 90b895c:	1884703a 	and	r2,r3,r2
 90b8960:	2084b03a 	or	r2,r4,r2
 90b8964:	1007883a 	mov	r3,r2
 90b8968:	e0bffb17 	ldw	r2,-20(fp)
 90b896c:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 90b8970:	e0bffa17 	ldw	r2,-24(fp)
 90b8974:	10c00417 	ldw	r3,16(r2)
 90b8978:	e0bffb17 	ldw	r2,-20(fp)
 90b897c:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 90b8980:	e03fff15 	stw	zero,-4(fp)
 90b8984:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8988:	e037883a 	mov	sp,fp
 90b898c:	dfc00117 	ldw	ra,4(sp)
 90b8990:	df000017 	ldw	fp,0(sp)
 90b8994:	dec00204 	addi	sp,sp,8
 90b8998:	f800283a 	ret

090b899c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 90b899c:	defff404 	addi	sp,sp,-48
 90b89a0:	df000b15 	stw	fp,44(sp)
 90b89a4:	df000b04 	addi	fp,sp,44
 90b89a8:	e13ffb15 	stw	r4,-20(fp)
 90b89ac:	e17ffc15 	stw	r5,-16(fp)
 90b89b0:	e1bffd15 	stw	r6,-12(fp)
 90b89b4:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 90b89b8:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 90b89bc:	00824374 	movhi	r2,2317
 90b89c0:	108c5204 	addi	r2,r2,12616
 90b89c4:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 90b89c8:	1005003a 	cmpeq	r2,r2,zero
 90b89cc:	1000411e 	bne	r2,zero,90b8ad4 <alt_alarm_start+0x138>
  {
    if (alarm)
 90b89d0:	e0bffb17 	ldw	r2,-20(fp)
 90b89d4:	1005003a 	cmpeq	r2,r2,zero
 90b89d8:	10003b1e 	bne	r2,zero,90b8ac8 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 90b89dc:	e0fffb17 	ldw	r3,-20(fp)
 90b89e0:	e0bffd17 	ldw	r2,-12(fp)
 90b89e4:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 90b89e8:	e0fffb17 	ldw	r3,-20(fp)
 90b89ec:	e0bffe17 	ldw	r2,-8(fp)
 90b89f0:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b89f4:	0005303a 	rdctl	r2,status
 90b89f8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b89fc:	e0fff817 	ldw	r3,-32(fp)
 90b8a00:	00bfff84 	movi	r2,-2
 90b8a04:	1884703a 	and	r2,r3,r2
 90b8a08:	1001703a 	wrctl	status,r2
  
  return context;
 90b8a0c:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 90b8a10:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 90b8a14:	00824374 	movhi	r2,2317
 90b8a18:	108c5304 	addi	r2,r2,12620
 90b8a1c:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 90b8a20:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 90b8a24:	e0fffc17 	ldw	r3,-16(fp)
 90b8a28:	e0bff917 	ldw	r2,-28(fp)
 90b8a2c:	1885883a 	add	r2,r3,r2
 90b8a30:	10c00044 	addi	r3,r2,1
 90b8a34:	e0bffb17 	ldw	r2,-20(fp)
 90b8a38:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 90b8a3c:	e0bffb17 	ldw	r2,-20(fp)
 90b8a40:	10c00217 	ldw	r3,8(r2)
 90b8a44:	e0bff917 	ldw	r2,-28(fp)
 90b8a48:	1880042e 	bgeu	r3,r2,90b8a5c <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 90b8a4c:	e0fffb17 	ldw	r3,-20(fp)
 90b8a50:	00800044 	movi	r2,1
 90b8a54:	18800405 	stb	r2,16(r3)
 90b8a58:	00000206 	br	90b8a64 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 90b8a5c:	e0bffb17 	ldw	r2,-20(fp)
 90b8a60:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 90b8a64:	e0fffb17 	ldw	r3,-20(fp)
 90b8a68:	00824374 	movhi	r2,2317
 90b8a6c:	108be304 	addi	r2,r2,12172
 90b8a70:	e0bff615 	stw	r2,-40(fp)
 90b8a74:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 90b8a78:	e0fff717 	ldw	r3,-36(fp)
 90b8a7c:	e0bff617 	ldw	r2,-40(fp)
 90b8a80:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 90b8a84:	e0bff617 	ldw	r2,-40(fp)
 90b8a88:	10c00017 	ldw	r3,0(r2)
 90b8a8c:	e0bff717 	ldw	r2,-36(fp)
 90b8a90:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 90b8a94:	e0bff617 	ldw	r2,-40(fp)
 90b8a98:	10c00017 	ldw	r3,0(r2)
 90b8a9c:	e0bff717 	ldw	r2,-36(fp)
 90b8aa0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 90b8aa4:	e0fff617 	ldw	r3,-40(fp)
 90b8aa8:	e0bff717 	ldw	r2,-36(fp)
 90b8aac:	18800015 	stw	r2,0(r3)
 90b8ab0:	e0bffa17 	ldw	r2,-24(fp)
 90b8ab4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b8ab8:	e0bff517 	ldw	r2,-44(fp)
 90b8abc:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 90b8ac0:	e03fff15 	stw	zero,-4(fp)
 90b8ac4:	00000506 	br	90b8adc <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 90b8ac8:	00bffa84 	movi	r2,-22
 90b8acc:	e0bfff15 	stw	r2,-4(fp)
 90b8ad0:	00000206 	br	90b8adc <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 90b8ad4:	00bfde84 	movi	r2,-134
 90b8ad8:	e0bfff15 	stw	r2,-4(fp)
 90b8adc:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 90b8ae0:	e037883a 	mov	sp,fp
 90b8ae4:	df000017 	ldw	fp,0(sp)
 90b8ae8:	dec00104 	addi	sp,sp,4
 90b8aec:	f800283a 	ret

090b8af0 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 90b8af0:	defff804 	addi	sp,sp,-32
 90b8af4:	dfc00715 	stw	ra,28(sp)
 90b8af8:	df000615 	stw	fp,24(sp)
 90b8afc:	df000604 	addi	fp,sp,24
 90b8b00:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 90b8b04:	e0bffc17 	ldw	r2,-16(fp)
 90b8b08:	1004803a 	cmplt	r2,r2,zero
 90b8b0c:	1000081e 	bne	r2,zero,90b8b30 <alt_close+0x40>
 90b8b10:	e0bffc17 	ldw	r2,-16(fp)
 90b8b14:	10800324 	muli	r2,r2,12
 90b8b18:	1007883a 	mov	r3,r2
 90b8b1c:	00824374 	movhi	r2,2317
 90b8b20:	108ad604 	addi	r2,r2,11096
 90b8b24:	1887883a 	add	r3,r3,r2
 90b8b28:	e0ffff15 	stw	r3,-4(fp)
 90b8b2c:	00000106 	br	90b8b34 <alt_close+0x44>
 90b8b30:	e03fff15 	stw	zero,-4(fp)
 90b8b34:	e0bfff17 	ldw	r2,-4(fp)
 90b8b38:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 90b8b3c:	e0bffb17 	ldw	r2,-20(fp)
 90b8b40:	1005003a 	cmpeq	r2,r2,zero
 90b8b44:	10001d1e 	bne	r2,zero,90b8bbc <alt_close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 90b8b48:	e0bffb17 	ldw	r2,-20(fp)
 90b8b4c:	10800017 	ldw	r2,0(r2)
 90b8b50:	10800417 	ldw	r2,16(r2)
 90b8b54:	1005003a 	cmpeq	r2,r2,zero
 90b8b58:	1000071e 	bne	r2,zero,90b8b78 <alt_close+0x88>
 90b8b5c:	e0bffb17 	ldw	r2,-20(fp)
 90b8b60:	10800017 	ldw	r2,0(r2)
 90b8b64:	10800417 	ldw	r2,16(r2)
 90b8b68:	e13ffb17 	ldw	r4,-20(fp)
 90b8b6c:	103ee83a 	callr	r2
 90b8b70:	e0bffe15 	stw	r2,-8(fp)
 90b8b74:	00000106 	br	90b8b7c <alt_close+0x8c>
 90b8b78:	e03ffe15 	stw	zero,-8(fp)
 90b8b7c:	e0bffe17 	ldw	r2,-8(fp)
 90b8b80:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 90b8b84:	e13ffc17 	ldw	r4,-16(fp)
 90b8b88:	90b987c0 	call	90b987c <alt_release_fd>
    if (rval < 0)
 90b8b8c:	e0bffa17 	ldw	r2,-24(fp)
 90b8b90:	1004403a 	cmpge	r2,r2,zero
 90b8b94:	1000071e 	bne	r2,zero,90b8bb4 <alt_close+0xc4>
    {
      ALT_ERRNO = -rval;
 90b8b98:	90b8bec0 	call	90b8bec <alt_get_errno>
 90b8b9c:	e0fffa17 	ldw	r3,-24(fp)
 90b8ba0:	00c7c83a 	sub	r3,zero,r3
 90b8ba4:	10c00015 	stw	r3,0(r2)
      return -1;
 90b8ba8:	00bfffc4 	movi	r2,-1
 90b8bac:	e0bffd15 	stw	r2,-12(fp)
 90b8bb0:	00000806 	br	90b8bd4 <alt_close+0xe4>
    }
    return 0;
 90b8bb4:	e03ffd15 	stw	zero,-12(fp)
 90b8bb8:	00000606 	br	90b8bd4 <alt_close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 90b8bbc:	90b8bec0 	call	90b8bec <alt_get_errno>
 90b8bc0:	1007883a 	mov	r3,r2
 90b8bc4:	00801444 	movi	r2,81
 90b8bc8:	18800015 	stw	r2,0(r3)
    return -1;
 90b8bcc:	00bfffc4 	movi	r2,-1
 90b8bd0:	e0bffd15 	stw	r2,-12(fp)
 90b8bd4:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 90b8bd8:	e037883a 	mov	sp,fp
 90b8bdc:	dfc00117 	ldw	ra,4(sp)
 90b8be0:	df000017 	ldw	fp,0(sp)
 90b8be4:	dec00204 	addi	sp,sp,8
 90b8be8:	f800283a 	ret

090b8bec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b8bec:	defffd04 	addi	sp,sp,-12
 90b8bf0:	dfc00215 	stw	ra,8(sp)
 90b8bf4:	df000115 	stw	fp,4(sp)
 90b8bf8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b8bfc:	00824374 	movhi	r2,2317
 90b8c00:	108bdf04 	addi	r2,r2,12156
 90b8c04:	10800017 	ldw	r2,0(r2)
 90b8c08:	1005003a 	cmpeq	r2,r2,zero
 90b8c0c:	1000061e 	bne	r2,zero,90b8c28 <alt_get_errno+0x3c>
 90b8c10:	00824374 	movhi	r2,2317
 90b8c14:	108bdf04 	addi	r2,r2,12156
 90b8c18:	10800017 	ldw	r2,0(r2)
 90b8c1c:	103ee83a 	callr	r2
 90b8c20:	e0bfff15 	stw	r2,-4(fp)
 90b8c24:	00000306 	br	90b8c34 <alt_get_errno+0x48>
 90b8c28:	00824374 	movhi	r2,2317
 90b8c2c:	108bfd04 	addi	r2,r2,12276
 90b8c30:	e0bfff15 	stw	r2,-4(fp)
 90b8c34:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8c38:	e037883a 	mov	sp,fp
 90b8c3c:	dfc00117 	ldw	ra,4(sp)
 90b8c40:	df000017 	ldw	fp,0(sp)
 90b8c44:	dec00204 	addi	sp,sp,8
 90b8c48:	f800283a 	ret

090b8c4c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 90b8c4c:	defffb04 	addi	sp,sp,-20
 90b8c50:	df000415 	stw	fp,16(sp)
 90b8c54:	df000404 	addi	fp,sp,16
 90b8c58:	e13ffe15 	stw	r4,-8(fp)
 90b8c5c:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 90b8c60:	e0fffe17 	ldw	r3,-8(fp)
 90b8c64:	e0bfff17 	ldw	r2,-4(fp)
 90b8c68:	1885883a 	add	r2,r3,r2
 90b8c6c:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 90b8c70:	e0bffe17 	ldw	r2,-8(fp)
 90b8c74:	e0bffd15 	stw	r2,-12(fp)
 90b8c78:	00000506 	br	90b8c90 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 90b8c7c:	e0bffd17 	ldw	r2,-12(fp)
 90b8c80:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 90b8c84:	e0bffd17 	ldw	r2,-12(fp)
 90b8c88:	10800804 	addi	r2,r2,32
 90b8c8c:	e0bffd15 	stw	r2,-12(fp)
 90b8c90:	e0fffd17 	ldw	r3,-12(fp)
 90b8c94:	e0bffc17 	ldw	r2,-16(fp)
 90b8c98:	18bff836 	bltu	r3,r2,90b8c7c <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 90b8c9c:	e0bffe17 	ldw	r2,-8(fp)
 90b8ca0:	108007cc 	andi	r2,r2,31
 90b8ca4:	1005003a 	cmpeq	r2,r2,zero
 90b8ca8:	1000021e 	bne	r2,zero,90b8cb4 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 90b8cac:	e0bffd17 	ldw	r2,-12(fp)
 90b8cb0:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 90b8cb4:	e037883a 	mov	sp,fp
 90b8cb8:	df000017 	ldw	fp,0(sp)
 90b8cbc:	dec00104 	addi	sp,sp,4
 90b8cc0:	f800283a 	ret

090b8cc4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 90b8cc4:	defffc04 	addi	sp,sp,-16
 90b8cc8:	df000315 	stw	fp,12(sp)
 90b8ccc:	df000304 	addi	fp,sp,12
 90b8cd0:	e13ffd15 	stw	r4,-12(fp)
 90b8cd4:	e17ffe15 	stw	r5,-8(fp)
 90b8cd8:	e1bfff15 	stw	r6,-4(fp)
  return len;
 90b8cdc:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8ce0:	e037883a 	mov	sp,fp
 90b8ce4:	df000017 	ldw	fp,0(sp)
 90b8ce8:	dec00104 	addi	sp,sp,4
 90b8cec:	f800283a 	ret

090b8cf0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 90b8cf0:	defff904 	addi	sp,sp,-28
 90b8cf4:	dfc00615 	stw	ra,24(sp)
 90b8cf8:	df000515 	stw	fp,20(sp)
 90b8cfc:	df000504 	addi	fp,sp,20
 90b8d00:	e13ffd15 	stw	r4,-12(fp)
 90b8d04:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 90b8d08:	e0bffd17 	ldw	r2,-12(fp)
 90b8d0c:	1005003a 	cmpeq	r2,r2,zero
 90b8d10:	1000041e 	bne	r2,zero,90b8d24 <alt_dev_llist_insert+0x34>
 90b8d14:	e0bffd17 	ldw	r2,-12(fp)
 90b8d18:	10800217 	ldw	r2,8(r2)
 90b8d1c:	1004c03a 	cmpne	r2,r2,zero
 90b8d20:	1000071e 	bne	r2,zero,90b8d40 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 90b8d24:	90b8da40 	call	90b8da4 <alt_get_errno>
 90b8d28:	1007883a 	mov	r3,r2
 90b8d2c:	00800584 	movi	r2,22
 90b8d30:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 90b8d34:	00bffa84 	movi	r2,-22
 90b8d38:	e0bfff15 	stw	r2,-4(fp)
 90b8d3c:	00001306 	br	90b8d8c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 90b8d40:	e0fffd17 	ldw	r3,-12(fp)
 90b8d44:	e0bffe17 	ldw	r2,-8(fp)
 90b8d48:	e0bffb15 	stw	r2,-20(fp)
 90b8d4c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 90b8d50:	e0fffc17 	ldw	r3,-16(fp)
 90b8d54:	e0bffb17 	ldw	r2,-20(fp)
 90b8d58:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 90b8d5c:	e0bffb17 	ldw	r2,-20(fp)
 90b8d60:	10c00017 	ldw	r3,0(r2)
 90b8d64:	e0bffc17 	ldw	r2,-16(fp)
 90b8d68:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 90b8d6c:	e0bffb17 	ldw	r2,-20(fp)
 90b8d70:	10c00017 	ldw	r3,0(r2)
 90b8d74:	e0bffc17 	ldw	r2,-16(fp)
 90b8d78:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 90b8d7c:	e0fffb17 	ldw	r3,-20(fp)
 90b8d80:	e0bffc17 	ldw	r2,-16(fp)
 90b8d84:	18800015 	stw	r2,0(r3)

  return 0;  
 90b8d88:	e03fff15 	stw	zero,-4(fp)
 90b8d8c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8d90:	e037883a 	mov	sp,fp
 90b8d94:	dfc00117 	ldw	ra,4(sp)
 90b8d98:	df000017 	ldw	fp,0(sp)
 90b8d9c:	dec00204 	addi	sp,sp,8
 90b8da0:	f800283a 	ret

090b8da4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b8da4:	defffd04 	addi	sp,sp,-12
 90b8da8:	dfc00215 	stw	ra,8(sp)
 90b8dac:	df000115 	stw	fp,4(sp)
 90b8db0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b8db4:	00824374 	movhi	r2,2317
 90b8db8:	108bdf04 	addi	r2,r2,12156
 90b8dbc:	10800017 	ldw	r2,0(r2)
 90b8dc0:	1005003a 	cmpeq	r2,r2,zero
 90b8dc4:	1000061e 	bne	r2,zero,90b8de0 <alt_get_errno+0x3c>
 90b8dc8:	00824374 	movhi	r2,2317
 90b8dcc:	108bdf04 	addi	r2,r2,12156
 90b8dd0:	10800017 	ldw	r2,0(r2)
 90b8dd4:	103ee83a 	callr	r2
 90b8dd8:	e0bfff15 	stw	r2,-4(fp)
 90b8ddc:	00000306 	br	90b8dec <alt_get_errno+0x48>
 90b8de0:	00824374 	movhi	r2,2317
 90b8de4:	108bfd04 	addi	r2,r2,12276
 90b8de8:	e0bfff15 	stw	r2,-4(fp)
 90b8dec:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8df0:	e037883a 	mov	sp,fp
 90b8df4:	dfc00117 	ldw	ra,4(sp)
 90b8df8:	df000017 	ldw	fp,0(sp)
 90b8dfc:	dec00204 	addi	sp,sp,8
 90b8e00:	f800283a 	ret

090b8e04 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 90b8e04:	defffd04 	addi	sp,sp,-12
 90b8e08:	dfc00215 	stw	ra,8(sp)
 90b8e0c:	df000115 	stw	fp,4(sp)
 90b8e10:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 90b8e14:	00bfff04 	movi	r2,-4
 90b8e18:	00c24374 	movhi	r3,2317
 90b8e1c:	18ebbe04 	addi	r3,r3,-20744
 90b8e20:	1885883a 	add	r2,r3,r2
 90b8e24:	e0bfff15 	stw	r2,-4(fp)
 90b8e28:	00000606 	br	90b8e44 <_do_ctors+0x40>
        (*ctor) (); 
 90b8e2c:	e0bfff17 	ldw	r2,-4(fp)
 90b8e30:	10800017 	ldw	r2,0(r2)
 90b8e34:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 90b8e38:	e0bfff17 	ldw	r2,-4(fp)
 90b8e3c:	10bfff04 	addi	r2,r2,-4
 90b8e40:	e0bfff15 	stw	r2,-4(fp)
 90b8e44:	e0ffff17 	ldw	r3,-4(fp)
 90b8e48:	00824374 	movhi	r2,2317
 90b8e4c:	10abbd04 	addi	r2,r2,-20748
 90b8e50:	18bff62e 	bgeu	r3,r2,90b8e2c <_do_ctors+0x28>
        (*ctor) (); 
}
 90b8e54:	e037883a 	mov	sp,fp
 90b8e58:	dfc00117 	ldw	ra,4(sp)
 90b8e5c:	df000017 	ldw	fp,0(sp)
 90b8e60:	dec00204 	addi	sp,sp,8
 90b8e64:	f800283a 	ret

090b8e68 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 90b8e68:	defffd04 	addi	sp,sp,-12
 90b8e6c:	dfc00215 	stw	ra,8(sp)
 90b8e70:	df000115 	stw	fp,4(sp)
 90b8e74:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 90b8e78:	00bfff04 	movi	r2,-4
 90b8e7c:	00c24374 	movhi	r3,2317
 90b8e80:	18ebbe04 	addi	r3,r3,-20744
 90b8e84:	1885883a 	add	r2,r3,r2
 90b8e88:	e0bfff15 	stw	r2,-4(fp)
 90b8e8c:	00000606 	br	90b8ea8 <_do_dtors+0x40>
        (*dtor) (); 
 90b8e90:	e0bfff17 	ldw	r2,-4(fp)
 90b8e94:	10800017 	ldw	r2,0(r2)
 90b8e98:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 90b8e9c:	e0bfff17 	ldw	r2,-4(fp)
 90b8ea0:	10bfff04 	addi	r2,r2,-4
 90b8ea4:	e0bfff15 	stw	r2,-4(fp)
 90b8ea8:	e0ffff17 	ldw	r3,-4(fp)
 90b8eac:	00824374 	movhi	r2,2317
 90b8eb0:	10abbe04 	addi	r2,r2,-20744
 90b8eb4:	18bff62e 	bgeu	r3,r2,90b8e90 <_do_dtors+0x28>
        (*dtor) (); 
}
 90b8eb8:	e037883a 	mov	sp,fp
 90b8ebc:	dfc00117 	ldw	ra,4(sp)
 90b8ec0:	df000017 	ldw	fp,0(sp)
 90b8ec4:	dec00204 	addi	sp,sp,8
 90b8ec8:	f800283a 	ret

090b8ecc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 90b8ecc:	defff904 	addi	sp,sp,-28
 90b8ed0:	dfc00615 	stw	ra,24(sp)
 90b8ed4:	df000515 	stw	fp,20(sp)
 90b8ed8:	df000504 	addi	fp,sp,20
 90b8edc:	e13ffd15 	stw	r4,-12(fp)
 90b8ee0:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 90b8ee4:	e0bffe17 	ldw	r2,-8(fp)
 90b8ee8:	10800017 	ldw	r2,0(r2)
 90b8eec:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 90b8ef0:	e13ffd17 	ldw	r4,-12(fp)
 90b8ef4:	90830d40 	call	90830d4 <strlen>
 90b8ef8:	10800044 	addi	r2,r2,1
 90b8efc:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 90b8f00:	00000d06 	br	90b8f38 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 90b8f04:	e0bffc17 	ldw	r2,-16(fp)
 90b8f08:	11000217 	ldw	r4,8(r2)
 90b8f0c:	e1bffb17 	ldw	r6,-20(fp)
 90b8f10:	e17ffd17 	ldw	r5,-12(fp)
 90b8f14:	90ca5400 	call	90ca540 <memcmp>
 90b8f18:	1004c03a 	cmpne	r2,r2,zero
 90b8f1c:	1000031e 	bne	r2,zero,90b8f2c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 90b8f20:	e0bffc17 	ldw	r2,-16(fp)
 90b8f24:	e0bfff15 	stw	r2,-4(fp)
 90b8f28:	00000706 	br	90b8f48 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 90b8f2c:	e0bffc17 	ldw	r2,-16(fp)
 90b8f30:	10800017 	ldw	r2,0(r2)
 90b8f34:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 90b8f38:	e0fffe17 	ldw	r3,-8(fp)
 90b8f3c:	e0bffc17 	ldw	r2,-16(fp)
 90b8f40:	10fff01e 	bne	r2,r3,90b8f04 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 90b8f44:	e03fff15 	stw	zero,-4(fp)
 90b8f48:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8f4c:	e037883a 	mov	sp,fp
 90b8f50:	dfc00117 	ldw	ra,4(sp)
 90b8f54:	df000017 	ldw	fp,0(sp)
 90b8f58:	dec00204 	addi	sp,sp,8
 90b8f5c:	f800283a 	ret

090b8f60 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 90b8f60:	defffb04 	addi	sp,sp,-20
 90b8f64:	dfc00415 	stw	ra,16(sp)
 90b8f68:	df000315 	stw	fp,12(sp)
 90b8f6c:	df000304 	addi	fp,sp,12
 90b8f70:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 90b8f74:	e13ffe17 	ldw	r4,-8(fp)
 90b8f78:	d1604604 	addi	r5,gp,-32488
 90b8f7c:	90b8ecc0 	call	90b8ecc <alt_find_dev>
 90b8f80:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 90b8f84:	e0bffd17 	ldw	r2,-12(fp)
 90b8f88:	1005003a 	cmpeq	r2,r2,zero
 90b8f8c:	10000b1e 	bne	r2,zero,90b8fbc <alt_flash_open_dev+0x5c>
 90b8f90:	e0bffd17 	ldw	r2,-12(fp)
 90b8f94:	10800317 	ldw	r2,12(r2)
 90b8f98:	1005003a 	cmpeq	r2,r2,zero
 90b8f9c:	1000071e 	bne	r2,zero,90b8fbc <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 90b8fa0:	e0bffd17 	ldw	r2,-12(fp)
 90b8fa4:	10800317 	ldw	r2,12(r2)
 90b8fa8:	e13ffd17 	ldw	r4,-12(fp)
 90b8fac:	e17ffe17 	ldw	r5,-8(fp)
 90b8fb0:	103ee83a 	callr	r2
 90b8fb4:	e0bfff15 	stw	r2,-4(fp)
 90b8fb8:	00000206 	br	90b8fc4 <alt_flash_open_dev+0x64>
  }

  return dev;
 90b8fbc:	e0bffd17 	ldw	r2,-12(fp)
 90b8fc0:	e0bfff15 	stw	r2,-4(fp)
 90b8fc4:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8fc8:	e037883a 	mov	sp,fp
 90b8fcc:	dfc00117 	ldw	ra,4(sp)
 90b8fd0:	df000017 	ldw	fp,0(sp)
 90b8fd4:	dec00204 	addi	sp,sp,8
 90b8fd8:	f800283a 	ret

090b8fdc <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 90b8fdc:	defffd04 	addi	sp,sp,-12
 90b8fe0:	dfc00215 	stw	ra,8(sp)
 90b8fe4:	df000115 	stw	fp,4(sp)
 90b8fe8:	df000104 	addi	fp,sp,4
 90b8fec:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 90b8ff0:	e0bfff17 	ldw	r2,-4(fp)
 90b8ff4:	1005003a 	cmpeq	r2,r2,zero
 90b8ff8:	1000081e 	bne	r2,zero,90b901c <alt_flash_close_dev+0x40>
 90b8ffc:	e0bfff17 	ldw	r2,-4(fp)
 90b9000:	10800417 	ldw	r2,16(r2)
 90b9004:	1005003a 	cmpeq	r2,r2,zero
 90b9008:	1000041e 	bne	r2,zero,90b901c <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 90b900c:	e0bfff17 	ldw	r2,-4(fp)
 90b9010:	10800417 	ldw	r2,16(r2)
 90b9014:	e13fff17 	ldw	r4,-4(fp)
 90b9018:	103ee83a 	callr	r2
  }
  return;
}
 90b901c:	e037883a 	mov	sp,fp
 90b9020:	dfc00117 	ldw	ra,4(sp)
 90b9024:	df000017 	ldw	fp,0(sp)
 90b9028:	dec00204 	addi	sp,sp,8
 90b902c:	f800283a 	ret

090b9030 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 90b9030:	defff904 	addi	sp,sp,-28
 90b9034:	dfc00615 	stw	ra,24(sp)
 90b9038:	df000515 	stw	fp,20(sp)
 90b903c:	df000504 	addi	fp,sp,20
 90b9040:	e13ffc15 	stw	r4,-16(fp)
 90b9044:	e17ffd15 	stw	r5,-12(fp)
 90b9048:	e1bffe15 	stw	r6,-8(fp)
 90b904c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 90b9050:	e0800217 	ldw	r2,8(fp)
 90b9054:	d8800015 	stw	r2,0(sp)
 90b9058:	e13ffc17 	ldw	r4,-16(fp)
 90b905c:	e17ffd17 	ldw	r5,-12(fp)
 90b9060:	e1bffe17 	ldw	r6,-8(fp)
 90b9064:	e1ffff17 	ldw	r7,-4(fp)
 90b9068:	90b92040 	call	90b9204 <alt_iic_isr_register>
}  
 90b906c:	e037883a 	mov	sp,fp
 90b9070:	dfc00117 	ldw	ra,4(sp)
 90b9074:	df000017 	ldw	fp,0(sp)
 90b9078:	dec00204 	addi	sp,sp,8
 90b907c:	f800283a 	ret

090b9080 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 90b9080:	defff904 	addi	sp,sp,-28
 90b9084:	df000615 	stw	fp,24(sp)
 90b9088:	df000604 	addi	fp,sp,24
 90b908c:	e13ffe15 	stw	r4,-8(fp)
 90b9090:	e17fff15 	stw	r5,-4(fp)
 90b9094:	e0bfff17 	ldw	r2,-4(fp)
 90b9098:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b909c:	0005303a 	rdctl	r2,status
 90b90a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b90a4:	e0fffb17 	ldw	r3,-20(fp)
 90b90a8:	00bfff84 	movi	r2,-2
 90b90ac:	1884703a 	and	r2,r3,r2
 90b90b0:	1001703a 	wrctl	status,r2
  
  return context;
 90b90b4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 90b90b8:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 90b90bc:	e0fffc17 	ldw	r3,-16(fp)
 90b90c0:	00800044 	movi	r2,1
 90b90c4:	10c4983a 	sll	r2,r2,r3
 90b90c8:	1007883a 	mov	r3,r2
 90b90cc:	00824374 	movhi	r2,2317
 90b90d0:	108c5104 	addi	r2,r2,12612
 90b90d4:	10800017 	ldw	r2,0(r2)
 90b90d8:	1886b03a 	or	r3,r3,r2
 90b90dc:	00824374 	movhi	r2,2317
 90b90e0:	108c5104 	addi	r2,r2,12612
 90b90e4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 90b90e8:	00824374 	movhi	r2,2317
 90b90ec:	108c5104 	addi	r2,r2,12612
 90b90f0:	10800017 	ldw	r2,0(r2)
 90b90f4:	100170fa 	wrctl	ienable,r2
 90b90f8:	e0bffd17 	ldw	r2,-12(fp)
 90b90fc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b9100:	e0bffa17 	ldw	r2,-24(fp)
 90b9104:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 90b9108:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 90b910c:	e037883a 	mov	sp,fp
 90b9110:	df000017 	ldw	fp,0(sp)
 90b9114:	dec00104 	addi	sp,sp,4
 90b9118:	f800283a 	ret

090b911c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 90b911c:	defff904 	addi	sp,sp,-28
 90b9120:	df000615 	stw	fp,24(sp)
 90b9124:	df000604 	addi	fp,sp,24
 90b9128:	e13ffe15 	stw	r4,-8(fp)
 90b912c:	e17fff15 	stw	r5,-4(fp)
 90b9130:	e0bfff17 	ldw	r2,-4(fp)
 90b9134:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b9138:	0005303a 	rdctl	r2,status
 90b913c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b9140:	e0fffb17 	ldw	r3,-20(fp)
 90b9144:	00bfff84 	movi	r2,-2
 90b9148:	1884703a 	and	r2,r3,r2
 90b914c:	1001703a 	wrctl	status,r2
  
  return context;
 90b9150:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 90b9154:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 90b9158:	e0fffc17 	ldw	r3,-16(fp)
 90b915c:	00800044 	movi	r2,1
 90b9160:	10c4983a 	sll	r2,r2,r3
 90b9164:	0084303a 	nor	r2,zero,r2
 90b9168:	1007883a 	mov	r3,r2
 90b916c:	00824374 	movhi	r2,2317
 90b9170:	108c5104 	addi	r2,r2,12612
 90b9174:	10800017 	ldw	r2,0(r2)
 90b9178:	1886703a 	and	r3,r3,r2
 90b917c:	00824374 	movhi	r2,2317
 90b9180:	108c5104 	addi	r2,r2,12612
 90b9184:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 90b9188:	00824374 	movhi	r2,2317
 90b918c:	108c5104 	addi	r2,r2,12612
 90b9190:	10800017 	ldw	r2,0(r2)
 90b9194:	100170fa 	wrctl	ienable,r2
 90b9198:	e0bffd17 	ldw	r2,-12(fp)
 90b919c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b91a0:	e0bffa17 	ldw	r2,-24(fp)
 90b91a4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 90b91a8:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 90b91ac:	e037883a 	mov	sp,fp
 90b91b0:	df000017 	ldw	fp,0(sp)
 90b91b4:	dec00104 	addi	sp,sp,4
 90b91b8:	f800283a 	ret

090b91bc <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 90b91bc:	defffc04 	addi	sp,sp,-16
 90b91c0:	df000315 	stw	fp,12(sp)
 90b91c4:	df000304 	addi	fp,sp,12
 90b91c8:	e13ffe15 	stw	r4,-8(fp)
 90b91cc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 90b91d0:	000530fa 	rdctl	r2,ienable
 90b91d4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 90b91d8:	e0ffff17 	ldw	r3,-4(fp)
 90b91dc:	00800044 	movi	r2,1
 90b91e0:	10c4983a 	sll	r2,r2,r3
 90b91e4:	1007883a 	mov	r3,r2
 90b91e8:	e0bffd17 	ldw	r2,-12(fp)
 90b91ec:	1884703a 	and	r2,r3,r2
 90b91f0:	1004c03a 	cmpne	r2,r2,zero
}
 90b91f4:	e037883a 	mov	sp,fp
 90b91f8:	df000017 	ldw	fp,0(sp)
 90b91fc:	dec00104 	addi	sp,sp,4
 90b9200:	f800283a 	ret

090b9204 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 90b9204:	defff404 	addi	sp,sp,-48
 90b9208:	dfc00b15 	stw	ra,44(sp)
 90b920c:	df000a15 	stw	fp,40(sp)
 90b9210:	df000a04 	addi	fp,sp,40
 90b9214:	e13ffb15 	stw	r4,-20(fp)
 90b9218:	e17ffc15 	stw	r5,-16(fp)
 90b921c:	e1bffd15 	stw	r6,-12(fp)
 90b9220:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 90b9224:	00bffa84 	movi	r2,-22
 90b9228:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 90b922c:	e0bffc17 	ldw	r2,-16(fp)
 90b9230:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 90b9234:	e0bff917 	ldw	r2,-28(fp)
 90b9238:	10800808 	cmpgei	r2,r2,32
 90b923c:	1000291e 	bne	r2,zero,90b92e4 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b9240:	0005303a 	rdctl	r2,status
 90b9244:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b9248:	e0fff717 	ldw	r3,-36(fp)
 90b924c:	00bfff84 	movi	r2,-2
 90b9250:	1884703a 	and	r2,r3,r2
 90b9254:	1001703a 	wrctl	status,r2
  
  return context;
 90b9258:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 90b925c:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 90b9260:	e0bff917 	ldw	r2,-28(fp)
 90b9264:	00c243b4 	movhi	r3,2318
 90b9268:	18f5c604 	addi	r3,r3,-10472
 90b926c:	100490fa 	slli	r2,r2,3
 90b9270:	10c7883a 	add	r3,r2,r3
 90b9274:	e0bffd17 	ldw	r2,-12(fp)
 90b9278:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 90b927c:	e0bff917 	ldw	r2,-28(fp)
 90b9280:	00c243b4 	movhi	r3,2318
 90b9284:	18f5c604 	addi	r3,r3,-10472
 90b9288:	100490fa 	slli	r2,r2,3
 90b928c:	10c5883a 	add	r2,r2,r3
 90b9290:	10c00104 	addi	r3,r2,4
 90b9294:	e0bffe17 	ldw	r2,-8(fp)
 90b9298:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 90b929c:	e0bffd17 	ldw	r2,-12(fp)
 90b92a0:	1005003a 	cmpeq	r2,r2,zero
 90b92a4:	1000051e 	bne	r2,zero,90b92bc <alt_iic_isr_register+0xb8>
 90b92a8:	e17ff917 	ldw	r5,-28(fp)
 90b92ac:	e13ffb17 	ldw	r4,-20(fp)
 90b92b0:	90b90800 	call	90b9080 <alt_ic_irq_enable>
 90b92b4:	e0bfff15 	stw	r2,-4(fp)
 90b92b8:	00000406 	br	90b92cc <alt_iic_isr_register+0xc8>
 90b92bc:	e17ff917 	ldw	r5,-28(fp)
 90b92c0:	e13ffb17 	ldw	r4,-20(fp)
 90b92c4:	90b911c0 	call	90b911c <alt_ic_irq_disable>
 90b92c8:	e0bfff15 	stw	r2,-4(fp)
 90b92cc:	e0bfff17 	ldw	r2,-4(fp)
 90b92d0:	e0bffa15 	stw	r2,-24(fp)
 90b92d4:	e0bff817 	ldw	r2,-32(fp)
 90b92d8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b92dc:	e0bff617 	ldw	r2,-40(fp)
 90b92e0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 90b92e4:	e0bffa17 	ldw	r2,-24(fp)
}
 90b92e8:	e037883a 	mov	sp,fp
 90b92ec:	dfc00117 	ldw	ra,4(sp)
 90b92f0:	df000017 	ldw	fp,0(sp)
 90b92f4:	dec00204 	addi	sp,sp,8
 90b92f8:	f800283a 	ret

090b92fc <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 90b92fc:	defff904 	addi	sp,sp,-28
 90b9300:	dfc00615 	stw	ra,24(sp)
 90b9304:	df000515 	stw	fp,20(sp)
 90b9308:	df000504 	addi	fp,sp,20
 90b930c:	e13ffc15 	stw	r4,-16(fp)
 90b9310:	e17ffd15 	stw	r5,-12(fp)
 90b9314:	e1bffe15 	stw	r6,-8(fp)
 90b9318:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 90b931c:	e13ffd17 	ldw	r4,-12(fp)
 90b9320:	e17ffe17 	ldw	r5,-8(fp)
 90b9324:	e1bfff17 	ldw	r6,-4(fp)
 90b9328:	90b95140 	call	90b9514 <open>
 90b932c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 90b9330:	e0bffb17 	ldw	r2,-20(fp)
 90b9334:	1004803a 	cmplt	r2,r2,zero
 90b9338:	10001c1e 	bne	r2,zero,90b93ac <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 90b933c:	e0bffb17 	ldw	r2,-20(fp)
 90b9340:	00c24374 	movhi	r3,2317
 90b9344:	18cad604 	addi	r3,r3,11096
 90b9348:	10800324 	muli	r2,r2,12
 90b934c:	10c5883a 	add	r2,r2,r3
 90b9350:	10c00017 	ldw	r3,0(r2)
 90b9354:	e0bffc17 	ldw	r2,-16(fp)
 90b9358:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 90b935c:	e0bffb17 	ldw	r2,-20(fp)
 90b9360:	00c24374 	movhi	r3,2317
 90b9364:	18cad604 	addi	r3,r3,11096
 90b9368:	10800324 	muli	r2,r2,12
 90b936c:	10c5883a 	add	r2,r2,r3
 90b9370:	10800104 	addi	r2,r2,4
 90b9374:	10c00017 	ldw	r3,0(r2)
 90b9378:	e0bffc17 	ldw	r2,-16(fp)
 90b937c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 90b9380:	e0bffb17 	ldw	r2,-20(fp)
 90b9384:	00c24374 	movhi	r3,2317
 90b9388:	18cad604 	addi	r3,r3,11096
 90b938c:	10800324 	muli	r2,r2,12
 90b9390:	10c5883a 	add	r2,r2,r3
 90b9394:	10800204 	addi	r2,r2,8
 90b9398:	10c00017 	ldw	r3,0(r2)
 90b939c:	e0bffc17 	ldw	r2,-16(fp)
 90b93a0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 90b93a4:	e13ffb17 	ldw	r4,-20(fp)
 90b93a8:	90b987c0 	call	90b987c <alt_release_fd>
  }
} 
 90b93ac:	e037883a 	mov	sp,fp
 90b93b0:	dfc00117 	ldw	ra,4(sp)
 90b93b4:	df000017 	ldw	fp,0(sp)
 90b93b8:	dec00204 	addi	sp,sp,8
 90b93bc:	f800283a 	ret

090b93c0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 90b93c0:	defffb04 	addi	sp,sp,-20
 90b93c4:	dfc00415 	stw	ra,16(sp)
 90b93c8:	df000315 	stw	fp,12(sp)
 90b93cc:	df000304 	addi	fp,sp,12
 90b93d0:	e13ffd15 	stw	r4,-12(fp)
 90b93d4:	e17ffe15 	stw	r5,-8(fp)
 90b93d8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 90b93dc:	01024374 	movhi	r4,2317
 90b93e0:	210ad904 	addi	r4,r4,11108
 90b93e4:	e17ffd17 	ldw	r5,-12(fp)
 90b93e8:	01800044 	movi	r6,1
 90b93ec:	01c07fc4 	movi	r7,511
 90b93f0:	90b92fc0 	call	90b92fc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 90b93f4:	01024374 	movhi	r4,2317
 90b93f8:	210ad604 	addi	r4,r4,11096
 90b93fc:	e17ffe17 	ldw	r5,-8(fp)
 90b9400:	000d883a 	mov	r6,zero
 90b9404:	01c07fc4 	movi	r7,511
 90b9408:	90b92fc0 	call	90b92fc <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 90b940c:	01024374 	movhi	r4,2317
 90b9410:	210adc04 	addi	r4,r4,11120
 90b9414:	e17fff17 	ldw	r5,-4(fp)
 90b9418:	01800044 	movi	r6,1
 90b941c:	01c07fc4 	movi	r7,511
 90b9420:	90b92fc0 	call	90b92fc <alt_open_fd>
}  
 90b9424:	e037883a 	mov	sp,fp
 90b9428:	dfc00117 	ldw	ra,4(sp)
 90b942c:	df000017 	ldw	fp,0(sp)
 90b9430:	dec00204 	addi	sp,sp,8
 90b9434:	f800283a 	ret

090b9438 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 90b9438:	defffc04 	addi	sp,sp,-16
 90b943c:	df000315 	stw	fp,12(sp)
 90b9440:	df000304 	addi	fp,sp,12
 90b9444:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 90b9448:	e0bffe17 	ldw	r2,-8(fp)
 90b944c:	10800217 	ldw	r2,8(r2)
 90b9450:	10d00034 	orhi	r3,r2,16384
 90b9454:	e0bffe17 	ldw	r2,-8(fp)
 90b9458:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 90b945c:	e03ffd15 	stw	zero,-12(fp)
 90b9460:	00002006 	br	90b94e4 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 90b9464:	e0bffd17 	ldw	r2,-12(fp)
 90b9468:	00c24374 	movhi	r3,2317
 90b946c:	18cad604 	addi	r3,r3,11096
 90b9470:	10800324 	muli	r2,r2,12
 90b9474:	10c5883a 	add	r2,r2,r3
 90b9478:	10c00017 	ldw	r3,0(r2)
 90b947c:	e0bffe17 	ldw	r2,-8(fp)
 90b9480:	10800017 	ldw	r2,0(r2)
 90b9484:	1880141e 	bne	r3,r2,90b94d8 <alt_file_locked+0xa0>
 90b9488:	e0bffd17 	ldw	r2,-12(fp)
 90b948c:	00c24374 	movhi	r3,2317
 90b9490:	18cad604 	addi	r3,r3,11096
 90b9494:	10800324 	muli	r2,r2,12
 90b9498:	10c5883a 	add	r2,r2,r3
 90b949c:	10800204 	addi	r2,r2,8
 90b94a0:	10800017 	ldw	r2,0(r2)
 90b94a4:	1004403a 	cmpge	r2,r2,zero
 90b94a8:	10000b1e 	bne	r2,zero,90b94d8 <alt_file_locked+0xa0>
 90b94ac:	e0bffd17 	ldw	r2,-12(fp)
 90b94b0:	10800324 	muli	r2,r2,12
 90b94b4:	1007883a 	mov	r3,r2
 90b94b8:	00824374 	movhi	r2,2317
 90b94bc:	108ad604 	addi	r2,r2,11096
 90b94c0:	1887883a 	add	r3,r3,r2
 90b94c4:	e0bffe17 	ldw	r2,-8(fp)
 90b94c8:	18800326 	beq	r3,r2,90b94d8 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 90b94cc:	00bffcc4 	movi	r2,-13
 90b94d0:	e0bfff15 	stw	r2,-4(fp)
 90b94d4:	00000a06 	br	90b9500 <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 90b94d8:	e0bffd17 	ldw	r2,-12(fp)
 90b94dc:	10800044 	addi	r2,r2,1
 90b94e0:	e0bffd15 	stw	r2,-12(fp)
 90b94e4:	00824374 	movhi	r2,2317
 90b94e8:	108bde04 	addi	r2,r2,12152
 90b94ec:	10800017 	ldw	r2,0(r2)
 90b94f0:	1007883a 	mov	r3,r2
 90b94f4:	e0bffd17 	ldw	r2,-12(fp)
 90b94f8:	18bfda2e 	bgeu	r3,r2,90b9464 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 90b94fc:	e03fff15 	stw	zero,-4(fp)
 90b9500:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9504:	e037883a 	mov	sp,fp
 90b9508:	df000017 	ldw	fp,0(sp)
 90b950c:	dec00104 	addi	sp,sp,4
 90b9510:	f800283a 	ret

090b9514 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 90b9514:	defff404 	addi	sp,sp,-48
 90b9518:	dfc00b15 	stw	ra,44(sp)
 90b951c:	df000a15 	stw	fp,40(sp)
 90b9520:	df000a04 	addi	fp,sp,40
 90b9524:	e13ffb15 	stw	r4,-20(fp)
 90b9528:	e17ffc15 	stw	r5,-16(fp)
 90b952c:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 90b9530:	00bfffc4 	movi	r2,-1
 90b9534:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 90b9538:	00bffb44 	movi	r2,-19
 90b953c:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 90b9540:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 90b9544:	e13ffb17 	ldw	r4,-20(fp)
 90b9548:	01424374 	movhi	r5,2317
 90b954c:	294bdc04 	addi	r5,r5,12144
 90b9550:	90b8ecc0 	call	90b8ecc <alt_find_dev>
 90b9554:	e0bffa15 	stw	r2,-24(fp)
 90b9558:	e0bffa17 	ldw	r2,-24(fp)
 90b955c:	1004c03a 	cmpne	r2,r2,zero
 90b9560:	1000051e 	bne	r2,zero,90b9578 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 90b9564:	e13ffb17 	ldw	r4,-20(fp)
 90b9568:	90c8f780 	call	90c8f78 <alt_find_file>
 90b956c:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 90b9570:	00800044 	movi	r2,1
 90b9574:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 90b9578:	e0bffa17 	ldw	r2,-24(fp)
 90b957c:	1005003a 	cmpeq	r2,r2,zero
 90b9580:	1000301e 	bne	r2,zero,90b9644 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 90b9584:	e13ffa17 	ldw	r4,-24(fp)
 90b9588:	90c90980 	call	90c9098 <alt_get_fd>
 90b958c:	e0bff815 	stw	r2,-32(fp)
 90b9590:	e0bff817 	ldw	r2,-32(fp)
 90b9594:	1004403a 	cmpge	r2,r2,zero
 90b9598:	1000031e 	bne	r2,zero,90b95a8 <open+0x94>
    {
      status = index;
 90b959c:	e0bff817 	ldw	r2,-32(fp)
 90b95a0:	e0bff715 	stw	r2,-36(fp)
 90b95a4:	00002906 	br	90b964c <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 90b95a8:	e0bff817 	ldw	r2,-32(fp)
 90b95ac:	10800324 	muli	r2,r2,12
 90b95b0:	1007883a 	mov	r3,r2
 90b95b4:	00824374 	movhi	r2,2317
 90b95b8:	108ad604 	addi	r2,r2,11096
 90b95bc:	1885883a 	add	r2,r3,r2
 90b95c0:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 90b95c4:	e0fffc17 	ldw	r3,-16(fp)
 90b95c8:	00900034 	movhi	r2,16384
 90b95cc:	10bfffc4 	addi	r2,r2,-1
 90b95d0:	1886703a 	and	r3,r3,r2
 90b95d4:	e0bff917 	ldw	r2,-28(fp)
 90b95d8:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 90b95dc:	e0bff617 	ldw	r2,-40(fp)
 90b95e0:	1004c03a 	cmpne	r2,r2,zero
 90b95e4:	1000061e 	bne	r2,zero,90b9600 <open+0xec>
 90b95e8:	e13ff917 	ldw	r4,-28(fp)
 90b95ec:	90b94380 	call	90b9438 <alt_file_locked>
 90b95f0:	e0bff715 	stw	r2,-36(fp)
 90b95f4:	e0bff717 	ldw	r2,-36(fp)
 90b95f8:	1004803a 	cmplt	r2,r2,zero
 90b95fc:	1000131e 	bne	r2,zero,90b964c <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 90b9600:	e0bffa17 	ldw	r2,-24(fp)
 90b9604:	10800317 	ldw	r2,12(r2)
 90b9608:	1005003a 	cmpeq	r2,r2,zero
 90b960c:	1000091e 	bne	r2,zero,90b9634 <open+0x120>
 90b9610:	e0bffa17 	ldw	r2,-24(fp)
 90b9614:	10800317 	ldw	r2,12(r2)
 90b9618:	e13ff917 	ldw	r4,-28(fp)
 90b961c:	e17ffb17 	ldw	r5,-20(fp)
 90b9620:	e1bffc17 	ldw	r6,-16(fp)
 90b9624:	e1fffd17 	ldw	r7,-12(fp)
 90b9628:	103ee83a 	callr	r2
 90b962c:	e0bfff15 	stw	r2,-4(fp)
 90b9630:	00000106 	br	90b9638 <open+0x124>
 90b9634:	e03fff15 	stw	zero,-4(fp)
 90b9638:	e0bfff17 	ldw	r2,-4(fp)
 90b963c:	e0bff715 	stw	r2,-36(fp)
 90b9640:	00000206 	br	90b964c <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 90b9644:	00bffb44 	movi	r2,-19
 90b9648:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 90b964c:	e0bff717 	ldw	r2,-36(fp)
 90b9650:	1004403a 	cmpge	r2,r2,zero
 90b9654:	1000091e 	bne	r2,zero,90b967c <open+0x168>
  {
    alt_release_fd (index);  
 90b9658:	e13ff817 	ldw	r4,-32(fp)
 90b965c:	90b987c0 	call	90b987c <alt_release_fd>
    ALT_ERRNO = -status;
 90b9660:	90b969c0 	call	90b969c <alt_get_errno>
 90b9664:	e0fff717 	ldw	r3,-36(fp)
 90b9668:	00c7c83a 	sub	r3,zero,r3
 90b966c:	10c00015 	stw	r3,0(r2)
    return -1;
 90b9670:	00bfffc4 	movi	r2,-1
 90b9674:	e0bffe15 	stw	r2,-8(fp)
 90b9678:	00000206 	br	90b9684 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 90b967c:	e0bff817 	ldw	r2,-32(fp)
 90b9680:	e0bffe15 	stw	r2,-8(fp)
 90b9684:	e0bffe17 	ldw	r2,-8(fp)
}
 90b9688:	e037883a 	mov	sp,fp
 90b968c:	dfc00117 	ldw	ra,4(sp)
 90b9690:	df000017 	ldw	fp,0(sp)
 90b9694:	dec00204 	addi	sp,sp,8
 90b9698:	f800283a 	ret

090b969c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b969c:	defffd04 	addi	sp,sp,-12
 90b96a0:	dfc00215 	stw	ra,8(sp)
 90b96a4:	df000115 	stw	fp,4(sp)
 90b96a8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b96ac:	00824374 	movhi	r2,2317
 90b96b0:	108bdf04 	addi	r2,r2,12156
 90b96b4:	10800017 	ldw	r2,0(r2)
 90b96b8:	1005003a 	cmpeq	r2,r2,zero
 90b96bc:	1000061e 	bne	r2,zero,90b96d8 <alt_get_errno+0x3c>
 90b96c0:	00824374 	movhi	r2,2317
 90b96c4:	108bdf04 	addi	r2,r2,12156
 90b96c8:	10800017 	ldw	r2,0(r2)
 90b96cc:	103ee83a 	callr	r2
 90b96d0:	e0bfff15 	stw	r2,-4(fp)
 90b96d4:	00000306 	br	90b96e4 <alt_get_errno+0x48>
 90b96d8:	00824374 	movhi	r2,2317
 90b96dc:	108bfd04 	addi	r2,r2,12276
 90b96e0:	e0bfff15 	stw	r2,-4(fp)
 90b96e4:	e0bfff17 	ldw	r2,-4(fp)
}
 90b96e8:	e037883a 	mov	sp,fp
 90b96ec:	dfc00117 	ldw	ra,4(sp)
 90b96f0:	df000017 	ldw	fp,0(sp)
 90b96f4:	dec00204 	addi	sp,sp,8
 90b96f8:	f800283a 	ret

090b96fc <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 90b96fc:	defff704 	addi	sp,sp,-36
 90b9700:	dfc00815 	stw	ra,32(sp)
 90b9704:	df000715 	stw	fp,28(sp)
 90b9708:	df000704 	addi	fp,sp,28
 90b970c:	e13ffb15 	stw	r4,-20(fp)
 90b9710:	e17ffc15 	stw	r5,-16(fp)
 90b9714:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90b9718:	e0bffb17 	ldw	r2,-20(fp)
 90b971c:	1004803a 	cmplt	r2,r2,zero
 90b9720:	1000081e 	bne	r2,zero,90b9744 <alt_read+0x48>
 90b9724:	e0bffb17 	ldw	r2,-20(fp)
 90b9728:	10800324 	muli	r2,r2,12
 90b972c:	1007883a 	mov	r3,r2
 90b9730:	00824374 	movhi	r2,2317
 90b9734:	108ad604 	addi	r2,r2,11096
 90b9738:	1887883a 	add	r3,r3,r2
 90b973c:	e0ffff15 	stw	r3,-4(fp)
 90b9740:	00000106 	br	90b9748 <alt_read+0x4c>
 90b9744:	e03fff15 	stw	zero,-4(fp)
 90b9748:	e0bfff17 	ldw	r2,-4(fp)
 90b974c:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 90b9750:	e0bffa17 	ldw	r2,-24(fp)
 90b9754:	1005003a 	cmpeq	r2,r2,zero
 90b9758:	1000241e 	bne	r2,zero,90b97ec <alt_read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 90b975c:	e0bffa17 	ldw	r2,-24(fp)
 90b9760:	10800217 	ldw	r2,8(r2)
 90b9764:	108000cc 	andi	r2,r2,3
 90b9768:	10800060 	cmpeqi	r2,r2,1
 90b976c:	10001a1e 	bne	r2,zero,90b97d8 <alt_read+0xdc>
 90b9770:	e0bffa17 	ldw	r2,-24(fp)
 90b9774:	10800017 	ldw	r2,0(r2)
 90b9778:	10800517 	ldw	r2,20(r2)
 90b977c:	1005003a 	cmpeq	r2,r2,zero
 90b9780:	1000151e 	bne	r2,zero,90b97d8 <alt_read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 90b9784:	e0bffa17 	ldw	r2,-24(fp)
 90b9788:	10800017 	ldw	r2,0(r2)
 90b978c:	10800517 	ldw	r2,20(r2)
 90b9790:	e17ffc17 	ldw	r5,-16(fp)
 90b9794:	e1bffd17 	ldw	r6,-12(fp)
 90b9798:	e13ffa17 	ldw	r4,-24(fp)
 90b979c:	103ee83a 	callr	r2
 90b97a0:	e0bff915 	stw	r2,-28(fp)
 90b97a4:	e0bff917 	ldw	r2,-28(fp)
 90b97a8:	1004403a 	cmpge	r2,r2,zero
 90b97ac:	1000071e 	bne	r2,zero,90b97cc <alt_read+0xd0>
        {
          ALT_ERRNO = -rval;
 90b97b0:	90b981c0 	call	90b981c <alt_get_errno>
 90b97b4:	e0fff917 	ldw	r3,-28(fp)
 90b97b8:	00c7c83a 	sub	r3,zero,r3
 90b97bc:	10c00015 	stw	r3,0(r2)
          return -1;
 90b97c0:	00bfffc4 	movi	r2,-1
 90b97c4:	e0bffe15 	stw	r2,-8(fp)
 90b97c8:	00000e06 	br	90b9804 <alt_read+0x108>
        }
        return rval;
 90b97cc:	e0bff917 	ldw	r2,-28(fp)
 90b97d0:	e0bffe15 	stw	r2,-8(fp)
 90b97d4:	00000b06 	br	90b9804 <alt_read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 90b97d8:	90b981c0 	call	90b981c <alt_get_errno>
 90b97dc:	1007883a 	mov	r3,r2
 90b97e0:	00800344 	movi	r2,13
 90b97e4:	18800015 	stw	r2,0(r3)
 90b97e8:	00000406 	br	90b97fc <alt_read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 90b97ec:	90b981c0 	call	90b981c <alt_get_errno>
 90b97f0:	1007883a 	mov	r3,r2
 90b97f4:	00801444 	movi	r2,81
 90b97f8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 90b97fc:	00bfffc4 	movi	r2,-1
 90b9800:	e0bffe15 	stw	r2,-8(fp)
 90b9804:	e0bffe17 	ldw	r2,-8(fp)
}
 90b9808:	e037883a 	mov	sp,fp
 90b980c:	dfc00117 	ldw	ra,4(sp)
 90b9810:	df000017 	ldw	fp,0(sp)
 90b9814:	dec00204 	addi	sp,sp,8
 90b9818:	f800283a 	ret

090b981c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b981c:	defffd04 	addi	sp,sp,-12
 90b9820:	dfc00215 	stw	ra,8(sp)
 90b9824:	df000115 	stw	fp,4(sp)
 90b9828:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b982c:	00824374 	movhi	r2,2317
 90b9830:	108bdf04 	addi	r2,r2,12156
 90b9834:	10800017 	ldw	r2,0(r2)
 90b9838:	1005003a 	cmpeq	r2,r2,zero
 90b983c:	1000061e 	bne	r2,zero,90b9858 <alt_get_errno+0x3c>
 90b9840:	00824374 	movhi	r2,2317
 90b9844:	108bdf04 	addi	r2,r2,12156
 90b9848:	10800017 	ldw	r2,0(r2)
 90b984c:	103ee83a 	callr	r2
 90b9850:	e0bfff15 	stw	r2,-4(fp)
 90b9854:	00000306 	br	90b9864 <alt_get_errno+0x48>
 90b9858:	00824374 	movhi	r2,2317
 90b985c:	108bfd04 	addi	r2,r2,12276
 90b9860:	e0bfff15 	stw	r2,-4(fp)
 90b9864:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9868:	e037883a 	mov	sp,fp
 90b986c:	dfc00117 	ldw	ra,4(sp)
 90b9870:	df000017 	ldw	fp,0(sp)
 90b9874:	dec00204 	addi	sp,sp,8
 90b9878:	f800283a 	ret

090b987c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 90b987c:	defffe04 	addi	sp,sp,-8
 90b9880:	df000115 	stw	fp,4(sp)
 90b9884:	df000104 	addi	fp,sp,4
 90b9888:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 90b988c:	e0bfff17 	ldw	r2,-4(fp)
 90b9890:	108000d0 	cmplti	r2,r2,3
 90b9894:	10000d1e 	bne	r2,zero,90b98cc <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 90b9898:	e0bfff17 	ldw	r2,-4(fp)
 90b989c:	00c24374 	movhi	r3,2317
 90b98a0:	18cad604 	addi	r3,r3,11096
 90b98a4:	10800324 	muli	r2,r2,12
 90b98a8:	10c5883a 	add	r2,r2,r3
 90b98ac:	10800204 	addi	r2,r2,8
 90b98b0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 90b98b4:	e0bfff17 	ldw	r2,-4(fp)
 90b98b8:	00c24374 	movhi	r3,2317
 90b98bc:	18cad604 	addi	r3,r3,11096
 90b98c0:	10800324 	muli	r2,r2,12
 90b98c4:	10c5883a 	add	r2,r2,r3
 90b98c8:	10000015 	stw	zero,0(r2)
  }
}
 90b98cc:	e037883a 	mov	sp,fp
 90b98d0:	df000017 	ldw	fp,0(sp)
 90b98d4:	dec00104 	addi	sp,sp,4
 90b98d8:	f800283a 	ret

090b98dc <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 90b98dc:	defffd04 	addi	sp,sp,-12
 90b98e0:	df000215 	stw	fp,8(sp)
 90b98e4:	df000204 	addi	fp,sp,8
 90b98e8:	e13ffe15 	stw	r4,-8(fp)
 90b98ec:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 90b98f0:	e0bffe17 	ldw	r2,-8(fp)
 90b98f4:	1007883a 	mov	r3,r2
 90b98f8:	00a00034 	movhi	r2,32768
 90b98fc:	10bfffc4 	addi	r2,r2,-1
 90b9900:	1884703a 	and	r2,r3,r2
}
 90b9904:	e037883a 	mov	sp,fp
 90b9908:	df000017 	ldw	fp,0(sp)
 90b990c:	dec00104 	addi	sp,sp,4
 90b9910:	f800283a 	ret

090b9914 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 90b9914:	defffc04 	addi	sp,sp,-16
 90b9918:	dfc00315 	stw	ra,12(sp)
 90b991c:	df000215 	stw	fp,8(sp)
 90b9920:	df000204 	addi	fp,sp,8
 90b9924:	e13ffe15 	stw	r4,-8(fp)
 90b9928:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 90b992c:	e13ffe17 	ldw	r4,-8(fp)
 90b9930:	e17fff17 	ldw	r5,-4(fp)
 90b9934:	90b8c4c0 	call	90b8c4c <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 90b9938:	e0bffe17 	ldw	r2,-8(fp)
 90b993c:	10a00034 	orhi	r2,r2,32768
}
 90b9940:	e037883a 	mov	sp,fp
 90b9944:	dfc00117 	ldw	ra,4(sp)
 90b9948:	df000017 	ldw	fp,0(sp)
 90b994c:	dec00204 	addi	sp,sp,8
 90b9950:	f800283a 	ret

090b9954 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 90b9954:	defffa04 	addi	sp,sp,-24
 90b9958:	df000515 	stw	fp,20(sp)
 90b995c:	df000504 	addi	fp,sp,20
 90b9960:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b9964:	0005303a 	rdctl	r2,status
 90b9968:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b996c:	e0fffd17 	ldw	r3,-12(fp)
 90b9970:	00bfff84 	movi	r2,-2
 90b9974:	1884703a 	and	r2,r3,r2
 90b9978:	1001703a 	wrctl	status,r2
  
  return context;
 90b997c:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 90b9980:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 90b9984:	e0bfff17 	ldw	r2,-4(fp)
 90b9988:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 90b998c:	e0bffc17 	ldw	r2,-16(fp)
 90b9990:	10c00017 	ldw	r3,0(r2)
 90b9994:	e0bffc17 	ldw	r2,-16(fp)
 90b9998:	10800117 	ldw	r2,4(r2)
 90b999c:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 90b99a0:	e0bffc17 	ldw	r2,-16(fp)
 90b99a4:	10c00117 	ldw	r3,4(r2)
 90b99a8:	e0bffc17 	ldw	r2,-16(fp)
 90b99ac:	10800017 	ldw	r2,0(r2)
 90b99b0:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 90b99b4:	e0fffc17 	ldw	r3,-16(fp)
 90b99b8:	e0bffc17 	ldw	r2,-16(fp)
 90b99bc:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 90b99c0:	e0fffc17 	ldw	r3,-16(fp)
 90b99c4:	e0bffc17 	ldw	r2,-16(fp)
 90b99c8:	18800015 	stw	r2,0(r3)
 90b99cc:	e0bffe17 	ldw	r2,-8(fp)
 90b99d0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b99d4:	e0bffb17 	ldw	r2,-20(fp)
 90b99d8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 90b99dc:	e037883a 	mov	sp,fp
 90b99e0:	df000017 	ldw	fp,0(sp)
 90b99e4:	dec00104 	addi	sp,sp,4
 90b99e8:	f800283a 	ret

090b99ec <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 90b99ec:	defffb04 	addi	sp,sp,-20
 90b99f0:	dfc00415 	stw	ra,16(sp)
 90b99f4:	df000315 	stw	fp,12(sp)
 90b99f8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 90b99fc:	d0a04917 	ldw	r2,-32476(gp)
 90b9a00:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 90b9a04:	d0a0b917 	ldw	r2,-32028(gp)
 90b9a08:	10800044 	addi	r2,r2,1
 90b9a0c:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 90b9a10:	00003106 	br	90b9ad8 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 90b9a14:	e0bffe17 	ldw	r2,-8(fp)
 90b9a18:	10800017 	ldw	r2,0(r2)
 90b9a1c:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 90b9a20:	e0bffe17 	ldw	r2,-8(fp)
 90b9a24:	10800403 	ldbu	r2,16(r2)
 90b9a28:	10803fcc 	andi	r2,r2,255
 90b9a2c:	1005003a 	cmpeq	r2,r2,zero
 90b9a30:	1000051e 	bne	r2,zero,90b9a48 <alt_tick+0x5c>
 90b9a34:	d0a0b917 	ldw	r2,-32028(gp)
 90b9a38:	1004c03a 	cmpne	r2,r2,zero
 90b9a3c:	1000021e 	bne	r2,zero,90b9a48 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 90b9a40:	e0bffe17 	ldw	r2,-8(fp)
 90b9a44:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 90b9a48:	e0bffe17 	ldw	r2,-8(fp)
 90b9a4c:	10c00217 	ldw	r3,8(r2)
 90b9a50:	d0a0b917 	ldw	r2,-32028(gp)
 90b9a54:	10c01e36 	bltu	r2,r3,90b9ad0 <alt_tick+0xe4>
 90b9a58:	e0bffe17 	ldw	r2,-8(fp)
 90b9a5c:	10800403 	ldbu	r2,16(r2)
 90b9a60:	10803fcc 	andi	r2,r2,255
 90b9a64:	1004c03a 	cmpne	r2,r2,zero
 90b9a68:	1000191e 	bne	r2,zero,90b9ad0 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 90b9a6c:	e0bffe17 	ldw	r2,-8(fp)
 90b9a70:	10c00317 	ldw	r3,12(r2)
 90b9a74:	e0bffe17 	ldw	r2,-8(fp)
 90b9a78:	11000517 	ldw	r4,20(r2)
 90b9a7c:	183ee83a 	callr	r3
 90b9a80:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 90b9a84:	e0bffd17 	ldw	r2,-12(fp)
 90b9a88:	1004c03a 	cmpne	r2,r2,zero
 90b9a8c:	1000031e 	bne	r2,zero,90b9a9c <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 90b9a90:	e13ffe17 	ldw	r4,-8(fp)
 90b9a94:	90b99540 	call	90b9954 <alt_alarm_stop>
 90b9a98:	00000d06 	br	90b9ad0 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 90b9a9c:	e0bffe17 	ldw	r2,-8(fp)
 90b9aa0:	10c00217 	ldw	r3,8(r2)
 90b9aa4:	e0bffd17 	ldw	r2,-12(fp)
 90b9aa8:	1887883a 	add	r3,r3,r2
 90b9aac:	e0bffe17 	ldw	r2,-8(fp)
 90b9ab0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 90b9ab4:	e0bffe17 	ldw	r2,-8(fp)
 90b9ab8:	10c00217 	ldw	r3,8(r2)
 90b9abc:	d0a0b917 	ldw	r2,-32028(gp)
 90b9ac0:	1880032e 	bgeu	r3,r2,90b9ad0 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 90b9ac4:	e0fffe17 	ldw	r3,-8(fp)
 90b9ac8:	00800044 	movi	r2,1
 90b9acc:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 90b9ad0:	e0bfff17 	ldw	r2,-4(fp)
 90b9ad4:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 90b9ad8:	d0e04904 	addi	r3,gp,-32476
 90b9adc:	e0bffe17 	ldw	r2,-8(fp)
 90b9ae0:	10ffcc1e 	bne	r2,r3,90b9a14 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 90b9ae4:	908de380 	call	908de38 <OSTimeTick>
}
 90b9ae8:	e037883a 	mov	sp,fp
 90b9aec:	dfc00117 	ldw	ra,4(sp)
 90b9af0:	df000017 	ldw	fp,0(sp)
 90b9af4:	dec00204 	addi	sp,sp,8
 90b9af8:	f800283a 	ret

090b9afc <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 90b9afc:	defffb04 	addi	sp,sp,-20
 90b9b00:	dfc00415 	stw	ra,16(sp)
 90b9b04:	df000315 	stw	fp,12(sp)
 90b9b08:	df000304 	addi	fp,sp,12
 90b9b0c:	e13ffe15 	stw	r4,-8(fp)
  void* ptr;

  ptr = malloc (size);
 90b9b10:	e13ffe17 	ldw	r4,-8(fp)
 90b9b14:	90ca52c0 	call	90ca52c <malloc>
 90b9b18:	e0bffd15 	stw	r2,-12(fp)

  alt_dcache_flush (ptr, size);
 90b9b1c:	e13ffd17 	ldw	r4,-12(fp)
 90b9b20:	e17ffe17 	ldw	r5,-8(fp)
 90b9b24:	90b8c4c0 	call	90b8c4c <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 90b9b28:	e0bffd17 	ldw	r2,-12(fp)
 90b9b2c:	1005003a 	cmpeq	r2,r2,zero
 90b9b30:	1000041e 	bne	r2,zero,90b9b44 <alt_uncached_malloc+0x48>
 90b9b34:	e0bffd17 	ldw	r2,-12(fp)
 90b9b38:	10a00034 	orhi	r2,r2,32768
 90b9b3c:	e0bfff15 	stw	r2,-4(fp)
 90b9b40:	00000106 	br	90b9b48 <alt_uncached_malloc+0x4c>
 90b9b44:	e03fff15 	stw	zero,-4(fp)
 90b9b48:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9b4c:	e037883a 	mov	sp,fp
 90b9b50:	dfc00117 	ldw	ra,4(sp)
 90b9b54:	df000017 	ldw	fp,0(sp)
 90b9b58:	dec00204 	addi	sp,sp,8
 90b9b5c:	f800283a 	ret

090b9b60 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 90b9b60:	defff304 	addi	sp,sp,-52
 90b9b64:	dfc00c15 	stw	ra,48(sp)
 90b9b68:	df000b15 	stw	fp,44(sp)
 90b9b6c:	df000b04 	addi	fp,sp,44
 90b9b70:	e13ff715 	stw	r4,-36(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 90b9b74:	00824374 	movhi	r2,2317
 90b9b78:	108c0544 	addi	r2,r2,12309
 90b9b7c:	10800003 	ldbu	r2,0(r2)
 90b9b80:	10803fcc 	andi	r2,r2,255
 90b9b84:	1004c03a 	cmpne	r2,r2,zero
 90b9b88:	1000041e 	bne	r2,zero,90b9b9c <usleep+0x3c>
  {
    return alt_busy_sleep (us);
 90b9b8c:	e13ff717 	ldw	r4,-36(fp)
 90b9b90:	90c8c980 	call	90c8c98 <alt_busy_sleep>
 90b9b94:	e0bff915 	stw	r2,-28(fp)
 90b9b98:	00004406 	br	90b9cac <usleep+0x14c>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 90b9b9c:	00824374 	movhi	r2,2317
 90b9ba0:	108c5204 	addi	r2,r2,12616
 90b9ba4:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 90b9ba8:	e0bff515 	stw	r2,-44(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 90b9bac:	e0fff717 	ldw	r3,-36(fp)
 90b9bb0:	0090c734 	movhi	r2,17180
 90b9bb4:	10b7a0c4 	addi	r2,r2,-8573
 90b9bb8:	1889383a 	mul	r4,r3,r2
 90b9bbc:	e13ffa15 	stw	r4,-24(fp)
 90b9bc0:	1886383a 	mulxuu	r3,r3,r2
 90b9bc4:	e0fffb15 	stw	r3,-20(fp)
 90b9bc8:	e17ffb17 	ldw	r5,-20(fp)
 90b9bcc:	2806d4ba 	srli	r3,r5,18
 90b9bd0:	e0bff517 	ldw	r2,-44(fp)
 90b9bd4:	1889383a 	mul	r4,r3,r2
 90b9bd8:	e0fff717 	ldw	r3,-36(fp)
 90b9bdc:	0090c734 	movhi	r2,17180
 90b9be0:	10b7a0c4 	addi	r2,r2,-8573
 90b9be4:	188b383a 	mul	r5,r3,r2
 90b9be8:	e17ffc15 	stw	r5,-16(fp)
 90b9bec:	1884383a 	mulxuu	r2,r3,r2
 90b9bf0:	e0bffd15 	stw	r2,-12(fp)
 90b9bf4:	e0bffd17 	ldw	r2,-12(fp)
 90b9bf8:	1004d4ba 	srli	r2,r2,18
 90b9bfc:	e0bff815 	stw	r2,-32(fp)
 90b9c00:	008003f4 	movhi	r2,15
 90b9c04:	10909004 	addi	r2,r2,16960
 90b9c08:	e17ff817 	ldw	r5,-32(fp)
 90b9c0c:	2885383a 	mul	r2,r5,r2
 90b9c10:	1887c83a 	sub	r3,r3,r2
 90b9c14:	e0fff815 	stw	r3,-32(fp)
 90b9c18:	e0bff517 	ldw	r2,-44(fp)
 90b9c1c:	e17ff817 	ldw	r5,-32(fp)
 90b9c20:	2887383a 	mul	r3,r5,r2
 90b9c24:	0090c734 	movhi	r2,17180
 90b9c28:	10b7a0c4 	addi	r2,r2,-8573
 90b9c2c:	188b383a 	mul	r5,r3,r2
 90b9c30:	e17ffe15 	stw	r5,-8(fp)
 90b9c34:	1886383a 	mulxuu	r3,r3,r2
 90b9c38:	e0ffff15 	stw	r3,-4(fp)
 90b9c3c:	e0ffff17 	ldw	r3,-4(fp)
 90b9c40:	1804d4ba 	srli	r2,r3,18
 90b9c44:	2085883a 	add	r2,r4,r2
 90b9c48:	e0bff615 	stw	r2,-40(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 90b9c4c:	00000706 	br	90b9c6c <usleep+0x10c>
  {
    OSTimeDly(0xffff);
 90b9c50:	013fffd4 	movui	r4,65535
 90b9c54:	9094e000 	call	9094e00 <OSTimeDly>
    ticks -= 0xffff;
 90b9c58:	e0bff617 	ldw	r2,-40(fp)
 90b9c5c:	00fffff4 	movhi	r3,65535
 90b9c60:	18c00044 	addi	r3,r3,1
 90b9c64:	10c5883a 	add	r2,r2,r3
 90b9c68:	e0bff615 	stw	r2,-40(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 90b9c6c:	e0fff617 	ldw	r3,-40(fp)
 90b9c70:	00bfffd4 	movui	r2,65535
 90b9c74:	10fff636 	bltu	r2,r3,90b9c50 <usleep+0xf0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 90b9c78:	e0bff617 	ldw	r2,-40(fp)
 90b9c7c:	113fffcc 	andi	r4,r2,65535
 90b9c80:	9094e000 	call	9094e00 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 90b9c84:	00c003f4 	movhi	r3,15
 90b9c88:	18d09004 	addi	r3,r3,16960
 90b9c8c:	e0bff517 	ldw	r2,-44(fp)
 90b9c90:	1887203a 	divu	r3,r3,r2
 90b9c94:	e13ff717 	ldw	r4,-36(fp)
 90b9c98:	20c5203a 	divu	r2,r4,r3
 90b9c9c:	10c5383a 	mul	r2,r2,r3
 90b9ca0:	2089c83a 	sub	r4,r4,r2
 90b9ca4:	90c8c980 	call	90c8c98 <alt_busy_sleep>

  return 0;  
 90b9ca8:	e03ff915 	stw	zero,-28(fp)
 90b9cac:	e0bff917 	ldw	r2,-28(fp)
}
 90b9cb0:	e037883a 	mov	sp,fp
 90b9cb4:	dfc00117 	ldw	ra,4(sp)
 90b9cb8:	df000017 	ldw	fp,0(sp)
 90b9cbc:	dec00204 	addi	sp,sp,8
 90b9cc0:	f800283a 	ret

090b9cc4 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 90b9cc4:	defff704 	addi	sp,sp,-36
 90b9cc8:	dfc00815 	stw	ra,32(sp)
 90b9ccc:	df000715 	stw	fp,28(sp)
 90b9cd0:	df000704 	addi	fp,sp,28
 90b9cd4:	e13ffb15 	stw	r4,-20(fp)
 90b9cd8:	e17ffc15 	stw	r5,-16(fp)
 90b9cdc:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90b9ce0:	e0bffb17 	ldw	r2,-20(fp)
 90b9ce4:	1004803a 	cmplt	r2,r2,zero
 90b9ce8:	1000081e 	bne	r2,zero,90b9d0c <alt_write+0x48>
 90b9cec:	e0bffb17 	ldw	r2,-20(fp)
 90b9cf0:	10800324 	muli	r2,r2,12
 90b9cf4:	1007883a 	mov	r3,r2
 90b9cf8:	00824374 	movhi	r2,2317
 90b9cfc:	108ad604 	addi	r2,r2,11096
 90b9d00:	1887883a 	add	r3,r3,r2
 90b9d04:	e0ffff15 	stw	r3,-4(fp)
 90b9d08:	00000106 	br	90b9d10 <alt_write+0x4c>
 90b9d0c:	e03fff15 	stw	zero,-4(fp)
 90b9d10:	e0bfff17 	ldw	r2,-4(fp)
 90b9d14:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 90b9d18:	e0bffa17 	ldw	r2,-24(fp)
 90b9d1c:	1005003a 	cmpeq	r2,r2,zero
 90b9d20:	1000241e 	bne	r2,zero,90b9db4 <alt_write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 90b9d24:	e0bffa17 	ldw	r2,-24(fp)
 90b9d28:	10800217 	ldw	r2,8(r2)
 90b9d2c:	108000cc 	andi	r2,r2,3
 90b9d30:	1005003a 	cmpeq	r2,r2,zero
 90b9d34:	10001a1e 	bne	r2,zero,90b9da0 <alt_write+0xdc>
 90b9d38:	e0bffa17 	ldw	r2,-24(fp)
 90b9d3c:	10800017 	ldw	r2,0(r2)
 90b9d40:	10800617 	ldw	r2,24(r2)
 90b9d44:	1005003a 	cmpeq	r2,r2,zero
 90b9d48:	1000151e 	bne	r2,zero,90b9da0 <alt_write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 90b9d4c:	e0bffa17 	ldw	r2,-24(fp)
 90b9d50:	10800017 	ldw	r2,0(r2)
 90b9d54:	10800617 	ldw	r2,24(r2)
 90b9d58:	e17ffc17 	ldw	r5,-16(fp)
 90b9d5c:	e1bffd17 	ldw	r6,-12(fp)
 90b9d60:	e13ffa17 	ldw	r4,-24(fp)
 90b9d64:	103ee83a 	callr	r2
 90b9d68:	e0bff915 	stw	r2,-28(fp)
 90b9d6c:	e0bff917 	ldw	r2,-28(fp)
 90b9d70:	1004403a 	cmpge	r2,r2,zero
 90b9d74:	1000071e 	bne	r2,zero,90b9d94 <alt_write+0xd0>
      {
        ALT_ERRNO = -rval;
 90b9d78:	90b9de40 	call	90b9de4 <alt_get_errno>
 90b9d7c:	e0fff917 	ldw	r3,-28(fp)
 90b9d80:	00c7c83a 	sub	r3,zero,r3
 90b9d84:	10c00015 	stw	r3,0(r2)
        return -1;
 90b9d88:	00bfffc4 	movi	r2,-1
 90b9d8c:	e0bffe15 	stw	r2,-8(fp)
 90b9d90:	00000e06 	br	90b9dcc <alt_write+0x108>
      }
      return rval;
 90b9d94:	e0bff917 	ldw	r2,-28(fp)
 90b9d98:	e0bffe15 	stw	r2,-8(fp)
 90b9d9c:	00000b06 	br	90b9dcc <alt_write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 90b9da0:	90b9de40 	call	90b9de4 <alt_get_errno>
 90b9da4:	1007883a 	mov	r3,r2
 90b9da8:	00800344 	movi	r2,13
 90b9dac:	18800015 	stw	r2,0(r3)
 90b9db0:	00000406 	br	90b9dc4 <alt_write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 90b9db4:	90b9de40 	call	90b9de4 <alt_get_errno>
 90b9db8:	1007883a 	mov	r3,r2
 90b9dbc:	00801444 	movi	r2,81
 90b9dc0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 90b9dc4:	00bfffc4 	movi	r2,-1
 90b9dc8:	e0bffe15 	stw	r2,-8(fp)
 90b9dcc:	e0bffe17 	ldw	r2,-8(fp)
}
 90b9dd0:	e037883a 	mov	sp,fp
 90b9dd4:	dfc00117 	ldw	ra,4(sp)
 90b9dd8:	df000017 	ldw	fp,0(sp)
 90b9ddc:	dec00204 	addi	sp,sp,8
 90b9de0:	f800283a 	ret

090b9de4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b9de4:	defffd04 	addi	sp,sp,-12
 90b9de8:	dfc00215 	stw	ra,8(sp)
 90b9dec:	df000115 	stw	fp,4(sp)
 90b9df0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b9df4:	00824374 	movhi	r2,2317
 90b9df8:	108bdf04 	addi	r2,r2,12156
 90b9dfc:	10800017 	ldw	r2,0(r2)
 90b9e00:	1005003a 	cmpeq	r2,r2,zero
 90b9e04:	1000061e 	bne	r2,zero,90b9e20 <alt_get_errno+0x3c>
 90b9e08:	00824374 	movhi	r2,2317
 90b9e0c:	108bdf04 	addi	r2,r2,12156
 90b9e10:	10800017 	ldw	r2,0(r2)
 90b9e14:	103ee83a 	callr	r2
 90b9e18:	e0bfff15 	stw	r2,-4(fp)
 90b9e1c:	00000306 	br	90b9e2c <alt_get_errno+0x48>
 90b9e20:	00824374 	movhi	r2,2317
 90b9e24:	108bfd04 	addi	r2,r2,12276
 90b9e28:	e0bfff15 	stw	r2,-4(fp)
 90b9e2c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9e30:	e037883a 	mov	sp,fp
 90b9e34:	dfc00117 	ldw	ra,4(sp)
 90b9e38:	df000017 	ldw	fp,0(sp)
 90b9e3c:	dec00204 	addi	sp,sp,8
 90b9e40:	f800283a 	ret

090b9e44 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 90b9e44:	deffff04 	addi	sp,sp,-4
 90b9e48:	df000015 	stw	fp,0(sp)
 90b9e4c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 90b9e50:	000170fa 	wrctl	ienable,zero
}
 90b9e54:	e037883a 	mov	sp,fp
 90b9e58:	df000017 	ldw	fp,0(sp)
 90b9e5c:	dec00104 	addi	sp,sp,4
 90b9e60:	f800283a 	ret

090b9e64 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 90b9e64:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 90b9e68:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 90b9e6c:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 90b9e70:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 90b9e74:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 90b9e78:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 90b9e7c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 90b9e80:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 90b9e84:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 90b9e88:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 90b9e8c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 90b9e90:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 90b9e94:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 90b9e98:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 90b9e9c:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 90b9ea0:	90ba2840 	call	90ba284 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 90b9ea4:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 90b9ea8:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 90b9eac:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 90b9eb0:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 90b9eb4:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 90b9eb8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 90b9ebc:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 90b9ec0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 90b9ec4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 90b9ec8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 90b9ecc:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 90b9ed0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 90b9ed4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 90b9ed8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 90b9edc:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 90b9ee0:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 90b9ee4:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 90b9ee8:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 90b9eec:	f800283a 	ret

090b9ef0 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 90b9ef0:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 90b9ef4:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 90b9ef8:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 90b9efc:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 90b9f00:	90ba2840 	call	90ba284 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 90b9f04:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 90b9f08:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 90b9f0c:	003fe506 	br	90b9ea4 <OSCtxSw+0x40>

090b9f10 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 90b9f10:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 90b9f14:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 90b9f18:	10800054 	ori	r2,r2,1
      wrctl status, r2
 90b9f1c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 90b9f20:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 90b9f24:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 90b9f28:	dec00204 	addi	sp,sp,8

      callr r2
 90b9f2c:	103ee83a 	callr	r2

      nop
 90b9f30:	0001883a 	nop

090b9f34 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 90b9f34:	defff704 	addi	sp,sp,-36
 90b9f38:	dfc00815 	stw	ra,32(sp)
 90b9f3c:	df000715 	stw	fp,28(sp)
 90b9f40:	df000704 	addi	fp,sp,28
 90b9f44:	e13ffc15 	stw	r4,-16(fp)
 90b9f48:	e17ffd15 	stw	r5,-12(fp)
 90b9f4c:	e1bffe15 	stw	r6,-8(fp)
 90b9f50:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 90b9f54:	e0bffe17 	ldw	r2,-8(fp)
 90b9f58:	1007883a 	mov	r3,r2
 90b9f5c:	00bfff04 	movi	r2,-4
 90b9f60:	1884703a 	and	r2,r3,r2
 90b9f64:	10bf0004 	addi	r2,r2,-1024
 90b9f68:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 90b9f6c:	e0bff917 	ldw	r2,-28(fp)
 90b9f70:	10000015 	stw	zero,0(r2)
 90b9f74:	e0bff917 	ldw	r2,-28(fp)
 90b9f78:	10c0bb04 	addi	r3,r2,748
 90b9f7c:	e0bff917 	ldw	r2,-28(fp)
 90b9f80:	10c00115 	stw	r3,4(r2)
 90b9f84:	e0bff917 	ldw	r2,-28(fp)
 90b9f88:	1080bb04 	addi	r2,r2,748
 90b9f8c:	10c01704 	addi	r3,r2,92
 90b9f90:	e0bff917 	ldw	r2,-28(fp)
 90b9f94:	10c00215 	stw	r3,8(r2)
 90b9f98:	e0bff917 	ldw	r2,-28(fp)
 90b9f9c:	1080bb04 	addi	r2,r2,748
 90b9fa0:	10c02e04 	addi	r3,r2,184
 90b9fa4:	e0bff917 	ldw	r2,-28(fp)
 90b9fa8:	10c00315 	stw	r3,12(r2)
 90b9fac:	e0bff917 	ldw	r2,-28(fp)
 90b9fb0:	10000415 	stw	zero,16(r2)
 90b9fb4:	e0bff917 	ldw	r2,-28(fp)
 90b9fb8:	10800504 	addi	r2,r2,20
 90b9fbc:	1009883a 	mov	r4,r2
 90b9fc0:	01800644 	movi	r6,25
 90b9fc4:	000b883a 	mov	r5,zero
 90b9fc8:	90823f80 	call	90823f8 <memset>
 90b9fcc:	e0bff917 	ldw	r2,-28(fp)
 90b9fd0:	10000c15 	stw	zero,48(r2)
 90b9fd4:	e0fff917 	ldw	r3,-28(fp)
 90b9fd8:	00824374 	movhi	r2,2317
 90b9fdc:	10bfb204 	addi	r2,r2,-312
 90b9fe0:	18800d15 	stw	r2,52(r3)
 90b9fe4:	e0bff917 	ldw	r2,-28(fp)
 90b9fe8:	10000e15 	stw	zero,56(r2)
 90b9fec:	e0bff917 	ldw	r2,-28(fp)
 90b9ff0:	10000f15 	stw	zero,60(r2)
 90b9ff4:	e0bff917 	ldw	r2,-28(fp)
 90b9ff8:	10001015 	stw	zero,64(r2)
 90b9ffc:	e0bff917 	ldw	r2,-28(fp)
 90ba000:	10001115 	stw	zero,68(r2)
 90ba004:	e0bff917 	ldw	r2,-28(fp)
 90ba008:	10001215 	stw	zero,72(r2)
 90ba00c:	e0bff917 	ldw	r2,-28(fp)
 90ba010:	10001315 	stw	zero,76(r2)
 90ba014:	e0bff917 	ldw	r2,-28(fp)
 90ba018:	10001415 	stw	zero,80(r2)
 90ba01c:	e0bff917 	ldw	r2,-28(fp)
 90ba020:	10001515 	stw	zero,84(r2)
 90ba024:	e0bff917 	ldw	r2,-28(fp)
 90ba028:	10001615 	stw	zero,88(r2)
 90ba02c:	e0bff917 	ldw	r2,-28(fp)
 90ba030:	10001715 	stw	zero,92(r2)
 90ba034:	e0bff917 	ldw	r2,-28(fp)
 90ba038:	10001805 	stb	zero,96(r2)
 90ba03c:	e0bff917 	ldw	r2,-28(fp)
 90ba040:	10801f04 	addi	r2,r2,124
 90ba044:	10000015 	stw	zero,0(r2)
 90ba048:	10000115 	stw	zero,4(r2)
 90ba04c:	10000215 	stw	zero,8(r2)
 90ba050:	10000315 	stw	zero,12(r2)
 90ba054:	10000415 	stw	zero,16(r2)
 90ba058:	10000515 	stw	zero,20(r2)
 90ba05c:	10000615 	stw	zero,24(r2)
 90ba060:	10000715 	stw	zero,28(r2)
 90ba064:	10000815 	stw	zero,32(r2)
 90ba068:	e0bff917 	ldw	r2,-28(fp)
 90ba06c:	10002815 	stw	zero,160(r2)
 90ba070:	e0fff917 	ldw	r3,-28(fp)
 90ba074:	00800044 	movi	r2,1
 90ba078:	18802915 	stw	r2,164(r3)
 90ba07c:	18002a15 	stw	zero,168(r3)
 90ba080:	e0fff917 	ldw	r3,-28(fp)
 90ba084:	008cc384 	movi	r2,13070
 90ba088:	18802b0d 	sth	r2,172(r3)
 90ba08c:	e0fff917 	ldw	r3,-28(fp)
 90ba090:	00aaf344 	movi	r2,-21555
 90ba094:	18802b8d 	sth	r2,174(r3)
 90ba098:	e0fff917 	ldw	r3,-28(fp)
 90ba09c:	00848d04 	movi	r2,4660
 90ba0a0:	18802c0d 	sth	r2,176(r3)
 90ba0a4:	e0fff917 	ldw	r3,-28(fp)
 90ba0a8:	00b99b44 	movi	r2,-6547
 90ba0ac:	18802c8d 	sth	r2,178(r3)
 90ba0b0:	e0fff917 	ldw	r3,-28(fp)
 90ba0b4:	00b7bb04 	movi	r2,-8468
 90ba0b8:	18802d0d 	sth	r2,180(r3)
 90ba0bc:	e0fff917 	ldw	r3,-28(fp)
 90ba0c0:	00800144 	movi	r2,5
 90ba0c4:	18802d8d 	sth	r2,182(r3)
 90ba0c8:	e0fff917 	ldw	r3,-28(fp)
 90ba0cc:	008002c4 	movi	r2,11
 90ba0d0:	18802e0d 	sth	r2,184(r3)
 90ba0d4:	e0bff917 	ldw	r2,-28(fp)
 90ba0d8:	10002f15 	stw	zero,188(r2)
 90ba0dc:	e0bff917 	ldw	r2,-28(fp)
 90ba0e0:	10003015 	stw	zero,192(r2)
 90ba0e4:	e0bff917 	ldw	r2,-28(fp)
 90ba0e8:	10003115 	stw	zero,196(r2)
 90ba0ec:	e0bff917 	ldw	r2,-28(fp)
 90ba0f0:	10003215 	stw	zero,200(r2)
 90ba0f4:	e0bff917 	ldw	r2,-28(fp)
 90ba0f8:	10003315 	stw	zero,204(r2)
 90ba0fc:	e0bff917 	ldw	r2,-28(fp)
 90ba100:	10003415 	stw	zero,208(r2)
 90ba104:	e0bff917 	ldw	r2,-28(fp)
 90ba108:	10003e15 	stw	zero,248(r2)
 90ba10c:	e0bff917 	ldw	r2,-28(fp)
 90ba110:	10003f15 	stw	zero,252(r2)
 90ba114:	e0bff917 	ldw	r2,-28(fp)
 90ba118:	10004015 	stw	zero,256(r2)
 90ba11c:	e0bff917 	ldw	r2,-28(fp)
 90ba120:	10004115 	stw	zero,260(r2)
 90ba124:	e0bff917 	ldw	r2,-28(fp)
 90ba128:	10004215 	stw	zero,264(r2)
 90ba12c:	e0bff917 	ldw	r2,-28(fp)
 90ba130:	10004315 	stw	zero,268(r2)
 90ba134:	e0bff917 	ldw	r2,-28(fp)
 90ba138:	10004415 	stw	zero,272(r2)
 90ba13c:	e0bff917 	ldw	r2,-28(fp)
 90ba140:	10004515 	stw	zero,276(r2)
 90ba144:	e0bff917 	ldw	r2,-28(fp)
 90ba148:	10004615 	stw	zero,280(r2)
 90ba14c:	e0bff917 	ldw	r2,-28(fp)
 90ba150:	10004715 	stw	zero,284(r2)
 90ba154:	e0bff917 	ldw	r2,-28(fp)
 90ba158:	10003505 	stb	zero,212(r2)
 90ba15c:	e0bff917 	ldw	r2,-28(fp)
 90ba160:	10003705 	stb	zero,220(r2)
 90ba164:	e0bff917 	ldw	r2,-28(fp)
 90ba168:	10003d15 	stw	zero,244(r2)
 90ba16c:	e0bff917 	ldw	r2,-28(fp)
 90ba170:	10005215 	stw	zero,328(r2)
 90ba174:	e0bff917 	ldw	r2,-28(fp)
 90ba178:	10005315 	stw	zero,332(r2)
 90ba17c:	e0bff917 	ldw	r2,-28(fp)
 90ba180:	10005415 	stw	zero,336(r2)
 90ba184:	e0bff917 	ldw	r2,-28(fp)
 90ba188:	10005515 	stw	zero,340(r2)
 90ba18c:	e0bff917 	ldw	r2,-28(fp)
 90ba190:	1000b515 	stw	zero,724(r2)
 90ba194:	e0bff917 	ldw	r2,-28(fp)
 90ba198:	10007515 	stw	zero,468(r2)
 90ba19c:	e0bff917 	ldw	r2,-28(fp)
 90ba1a0:	1000b715 	stw	zero,732(r2)
 90ba1a4:	e0bff917 	ldw	r2,-28(fp)
 90ba1a8:	1000b815 	stw	zero,736(r2)
 90ba1ac:	e0bff917 	ldw	r2,-28(fp)
 90ba1b0:	1000b915 	stw	zero,740(r2)
 90ba1b4:	e0bff917 	ldw	r2,-28(fp)
 90ba1b8:	1000ba15 	stw	zero,744(r2)
 90ba1bc:	e0bff917 	ldw	r2,-28(fp)
 90ba1c0:	1080bb04 	addi	r2,r2,748
 90ba1c4:	1009883a 	mov	r4,r2
 90ba1c8:	01804504 	movi	r6,276
 90ba1cc:	000b883a 	mov	r5,zero
 90ba1d0:	90823f80 	call	90823f8 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 90ba1d4:	e0bff917 	ldw	r2,-28(fp)
 90ba1d8:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 90ba1dc:	e0bffb17 	ldw	r2,-20(fp)
 90ba1e0:	10bff304 	addi	r2,r2,-52
 90ba1e4:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 90ba1e8:	e0bffa17 	ldw	r2,-24(fp)
 90ba1ec:	10c00c04 	addi	r3,r2,48
 90ba1f0:	e0bffc17 	ldw	r2,-16(fp)
 90ba1f4:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 90ba1f8:	e0bffa17 	ldw	r2,-24(fp)
 90ba1fc:	10c00b04 	addi	r3,r2,44
 90ba200:	e0bffd17 	ldw	r2,-12(fp)
 90ba204:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 90ba208:	e0bffa17 	ldw	r2,-24(fp)
 90ba20c:	10c00a04 	addi	r3,r2,40
 90ba210:	e0bff917 	ldw	r2,-28(fp)
 90ba214:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 90ba218:	00824334 	movhi	r2,2316
 90ba21c:	10a7c404 	addi	r2,r2,-24816
 90ba220:	10c00104 	addi	r3,r2,4
 90ba224:	e0bffa17 	ldw	r2,-24(fp)
 90ba228:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 90ba22c:	e0bffa17 	ldw	r2,-24(fp)
}
 90ba230:	e037883a 	mov	sp,fp
 90ba234:	dfc00117 	ldw	ra,4(sp)
 90ba238:	df000017 	ldw	fp,0(sp)
 90ba23c:	dec00204 	addi	sp,sp,8
 90ba240:	f800283a 	ret

090ba244 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 90ba244:	defffe04 	addi	sp,sp,-8
 90ba248:	df000115 	stw	fp,4(sp)
 90ba24c:	df000104 	addi	fp,sp,4
 90ba250:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 90ba254:	e037883a 	mov	sp,fp
 90ba258:	df000017 	ldw	fp,0(sp)
 90ba25c:	dec00104 	addi	sp,sp,4
 90ba260:	f800283a 	ret

090ba264 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 90ba264:	defffe04 	addi	sp,sp,-8
 90ba268:	df000115 	stw	fp,4(sp)
 90ba26c:	df000104 	addi	fp,sp,4
 90ba270:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 90ba274:	e037883a 	mov	sp,fp
 90ba278:	df000017 	ldw	fp,0(sp)
 90ba27c:	dec00104 	addi	sp,sp,4
 90ba280:	f800283a 	ret

090ba284 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 90ba284:	deffff04 	addi	sp,sp,-4
 90ba288:	df000015 	stw	fp,0(sp)
 90ba28c:	d839883a 	mov	fp,sp
}
 90ba290:	e037883a 	mov	sp,fp
 90ba294:	df000017 	ldw	fp,0(sp)
 90ba298:	dec00104 	addi	sp,sp,4
 90ba29c:	f800283a 	ret

090ba2a0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 90ba2a0:	deffff04 	addi	sp,sp,-4
 90ba2a4:	df000015 	stw	fp,0(sp)
 90ba2a8:	d839883a 	mov	fp,sp
}
 90ba2ac:	e037883a 	mov	sp,fp
 90ba2b0:	df000017 	ldw	fp,0(sp)
 90ba2b4:	dec00104 	addi	sp,sp,4
 90ba2b8:	f800283a 	ret

090ba2bc <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 90ba2bc:	defffe04 	addi	sp,sp,-8
 90ba2c0:	dfc00115 	stw	ra,4(sp)
 90ba2c4:	df000015 	stw	fp,0(sp)
 90ba2c8:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 90ba2cc:	90a961c0 	call	90a961c <cticks_hook>
#endif
}
 90ba2d0:	e037883a 	mov	sp,fp
 90ba2d4:	dfc00117 	ldw	ra,4(sp)
 90ba2d8:	df000017 	ldw	fp,0(sp)
 90ba2dc:	dec00204 	addi	sp,sp,8
 90ba2e0:	f800283a 	ret

090ba2e4 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 90ba2e4:	deffff04 	addi	sp,sp,-4
 90ba2e8:	df000015 	stw	fp,0(sp)
 90ba2ec:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 90ba2f0:	e037883a 	mov	sp,fp
 90ba2f4:	df000017 	ldw	fp,0(sp)
 90ba2f8:	dec00104 	addi	sp,sp,4
 90ba2fc:	f800283a 	ret

090ba300 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 90ba300:	deffff04 	addi	sp,sp,-4
 90ba304:	df000015 	stw	fp,0(sp)
 90ba308:	d839883a 	mov	fp,sp
}
 90ba30c:	e037883a 	mov	sp,fp
 90ba310:	df000017 	ldw	fp,0(sp)
 90ba314:	dec00104 	addi	sp,sp,4
 90ba318:	f800283a 	ret

090ba31c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 90ba31c:	deffff04 	addi	sp,sp,-4
 90ba320:	df000015 	stw	fp,0(sp)
 90ba324:	d839883a 	mov	fp,sp
}
 90ba328:	e037883a 	mov	sp,fp
 90ba32c:	df000017 	ldw	fp,0(sp)
 90ba330:	dec00104 	addi	sp,sp,4
 90ba334:	f800283a 	ret

090ba338 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 90ba338:	defffe04 	addi	sp,sp,-8
 90ba33c:	df000115 	stw	fp,4(sp)
 90ba340:	df000104 	addi	fp,sp,4
 90ba344:	e13fff15 	stw	r4,-4(fp)
}
 90ba348:	e037883a 	mov	sp,fp
 90ba34c:	df000017 	ldw	fp,0(sp)
 90ba350:	dec00104 	addi	sp,sp,4
 90ba354:	f800283a 	ret

090ba358 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 90ba358:	defff704 	addi	sp,sp,-36
 90ba35c:	dfc00815 	stw	ra,32(sp)
 90ba360:	df000715 	stw	fp,28(sp)
 90ba364:	df000704 	addi	fp,sp,28
 90ba368:	e13ffc15 	stw	r4,-16(fp)
 90ba36c:	e17ffd15 	stw	r5,-12(fp)
 90ba370:	e1bffe15 	stw	r6,-8(fp)
 90ba374:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 90ba378:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90ba37c:	e0bffc17 	ldw	r2,-16(fp)
 90ba380:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 90ba384:	e1bfff17 	ldw	r6,-4(fp)
 90ba388:	00824334 	movhi	r2,2316
 90ba38c:	10a9bf04 	addi	r2,r2,-22788
 90ba390:	d8800015 	stw	r2,0(sp)
 90ba394:	e13ffa17 	ldw	r4,-24(fp)
 90ba398:	e17ffe17 	ldw	r5,-8(fp)
 90ba39c:	e1c00217 	ldw	r7,8(fp)
 90ba3a0:	9095d440 	call	9095d44 <alt_flash_program_block>
 90ba3a4:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 90ba3a8:	e0bffb17 	ldw	r2,-20(fp)
}
 90ba3ac:	e037883a 	mov	sp,fp
 90ba3b0:	dfc00117 	ldw	ra,4(sp)
 90ba3b4:	df000017 	ldw	fp,0(sp)
 90ba3b8:	dec00204 	addi	sp,sp,8
 90ba3bc:	f800283a 	ret

090ba3c0 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 90ba3c0:	defff804 	addi	sp,sp,-32
 90ba3c4:	dfc00715 	stw	ra,28(sp)
 90ba3c8:	df000615 	stw	fp,24(sp)
 90ba3cc:	df000604 	addi	fp,sp,24
 90ba3d0:	e13ffe15 	stw	r4,-8(fp)
 90ba3d4:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 90ba3d8:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90ba3dc:	e0bffe17 	ldw	r2,-8(fp)
 90ba3e0:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90ba3e4:	e0bffa17 	ldw	r2,-24(fp)
 90ba3e8:	10c03317 	ldw	r3,204(r2)
 90ba3ec:	e0bffa17 	ldw	r2,-24(fp)
 90ba3f0:	11000a17 	ldw	r4,40(r2)
 90ba3f4:	01415544 	movi	r5,1365
 90ba3f8:	01802a84 	movi	r6,170
 90ba3fc:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90ba400:	e0bffa17 	ldw	r2,-24(fp)
 90ba404:	10c03317 	ldw	r3,204(r2)
 90ba408:	e0bffa17 	ldw	r2,-24(fp)
 90ba40c:	11000a17 	ldw	r4,40(r2)
 90ba410:	0140aa84 	movi	r5,682
 90ba414:	01801544 	movi	r6,85
 90ba418:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 90ba41c:	e0bffa17 	ldw	r2,-24(fp)
 90ba420:	10c03317 	ldw	r3,204(r2)
 90ba424:	e0bffa17 	ldw	r2,-24(fp)
 90ba428:	11000a17 	ldw	r4,40(r2)
 90ba42c:	01415544 	movi	r5,1365
 90ba430:	01802004 	movi	r6,128
 90ba434:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90ba438:	e0bffa17 	ldw	r2,-24(fp)
 90ba43c:	10c03317 	ldw	r3,204(r2)
 90ba440:	e0bffa17 	ldw	r2,-24(fp)
 90ba444:	11000a17 	ldw	r4,40(r2)
 90ba448:	01415544 	movi	r5,1365
 90ba44c:	01802a84 	movi	r6,170
 90ba450:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90ba454:	e0bffa17 	ldw	r2,-24(fp)
 90ba458:	10c03317 	ldw	r3,204(r2)
 90ba45c:	e0bffa17 	ldw	r2,-24(fp)
 90ba460:	11000a17 	ldw	r4,40(r2)
 90ba464:	0140aa84 	movi	r5,682
 90ba468:	01801544 	movi	r6,85
 90ba46c:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 90ba470:	e0bffa17 	ldw	r2,-24(fp)
 90ba474:	11803517 	ldw	r6,212(r2)
 90ba478:	e0bffa17 	ldw	r2,-24(fp)
 90ba47c:	10800a17 	ldw	r2,40(r2)
 90ba480:	1007883a 	mov	r3,r2
 90ba484:	e0bfff17 	ldw	r2,-4(fp)
 90ba488:	1889883a 	add	r4,r3,r2
 90ba48c:	01400c04 	movi	r5,48
 90ba490:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 90ba494:	0109c404 	movi	r4,10000
 90ba498:	90b9b600 	call	90b9b60 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 90ba49c:	00800c84 	movi	r2,50
 90ba4a0:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90ba4a4:	e0bffa17 	ldw	r2,-24(fp)
 90ba4a8:	10800a17 	ldw	r2,40(r2)
 90ba4ac:	1007883a 	mov	r3,r2
 90ba4b0:	e0bfff17 	ldw	r2,-4(fp)
 90ba4b4:	1885883a 	add	r2,r3,r2
 90ba4b8:	10800023 	ldbuio	r2,0(r2)
 90ba4bc:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 90ba4c0:	0100fa04 	movi	r4,1000
 90ba4c4:	90b9b600 	call	90b9b60 <usleep>
    timeout--;
 90ba4c8:	e0bffb17 	ldw	r2,-20(fp)
 90ba4cc:	10bfffc4 	addi	r2,r2,-1
 90ba4d0:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 90ba4d4:	e0bffd03 	ldbu	r2,-12(fp)
 90ba4d8:	10803fcc 	andi	r2,r2,255
 90ba4dc:	1080020c 	andi	r2,r2,8
 90ba4e0:	1004c03a 	cmpne	r2,r2,zero
 90ba4e4:	1000031e 	bne	r2,zero,90ba4f4 <alt_erase_block_amd+0x134>
 90ba4e8:	e0bffb17 	ldw	r2,-20(fp)
 90ba4ec:	10800048 	cmpgei	r2,r2,1
 90ba4f0:	103fec1e 	bne	r2,zero,90ba4a4 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 90ba4f4:	e0bffa17 	ldw	r2,-24(fp)
 90ba4f8:	10803117 	ldw	r2,196(r2)
 90ba4fc:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 90ba500:	00001706 	br	90ba560 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90ba504:	e0bffa17 	ldw	r2,-24(fp)
 90ba508:	10800a17 	ldw	r2,40(r2)
 90ba50c:	1007883a 	mov	r3,r2
 90ba510:	e0bfff17 	ldw	r2,-4(fp)
 90ba514:	1885883a 	add	r2,r3,r2
 90ba518:	10800023 	ldbuio	r2,0(r2)
 90ba51c:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 90ba520:	e0bffd03 	ldbu	r2,-12(fp)
 90ba524:	10803fcc 	andi	r2,r2,255
 90ba528:	1080201c 	xori	r2,r2,128
 90ba52c:	10bfe004 	addi	r2,r2,-128
 90ba530:	1004803a 	cmplt	r2,r2,zero
 90ba534:	10000d1e 	bne	r2,zero,90ba56c <alt_erase_block_amd+0x1ac>
 90ba538:	e0bffd03 	ldbu	r2,-12(fp)
 90ba53c:	10803fcc 	andi	r2,r2,255
 90ba540:	1080080c 	andi	r2,r2,32
 90ba544:	1004c03a 	cmpne	r2,r2,zero
 90ba548:	1000081e 	bne	r2,zero,90ba56c <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 90ba54c:	0100fa04 	movi	r4,1000
 90ba550:	90b9b600 	call	90b9b60 <usleep>
    timeout -= 1000;
 90ba554:	e0bffb17 	ldw	r2,-20(fp)
 90ba558:	10bf0604 	addi	r2,r2,-1000
 90ba55c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 90ba560:	e0bffb17 	ldw	r2,-20(fp)
 90ba564:	10800048 	cmpgei	r2,r2,1
 90ba568:	103fe61e 	bne	r2,zero,90ba504 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 90ba56c:	e0bffb17 	ldw	r2,-20(fp)
 90ba570:	10800048 	cmpgei	r2,r2,1
 90ba574:	1000031e 	bne	r2,zero,90ba584 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 90ba578:	00bfe304 	movi	r2,-116
 90ba57c:	e0bffc15 	stw	r2,-16(fp)
 90ba580:	00000f06 	br	90ba5c0 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90ba584:	e0bffa17 	ldw	r2,-24(fp)
 90ba588:	10800a17 	ldw	r2,40(r2)
 90ba58c:	1007883a 	mov	r3,r2
 90ba590:	e0bfff17 	ldw	r2,-4(fp)
 90ba594:	1885883a 	add	r2,r3,r2
 90ba598:	10800023 	ldbuio	r2,0(r2)
 90ba59c:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 90ba5a0:	e0bffd03 	ldbu	r2,-12(fp)
 90ba5a4:	10803fcc 	andi	r2,r2,255
 90ba5a8:	1080201c 	xori	r2,r2,128
 90ba5ac:	10bfe004 	addi	r2,r2,-128
 90ba5b0:	1004803a 	cmplt	r2,r2,zero
 90ba5b4:	1000021e 	bne	r2,zero,90ba5c0 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 90ba5b8:	00bffec4 	movi	r2,-5
 90ba5bc:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 90ba5c0:	e0bffc17 	ldw	r2,-16(fp)
}
 90ba5c4:	e037883a 	mov	sp,fp
 90ba5c8:	dfc00117 	ldw	ra,4(sp)
 90ba5cc:	df000017 	ldw	fp,0(sp)
 90ba5d0:	dec00204 	addi	sp,sp,8
 90ba5d4:	f800283a 	ret

090ba5d8 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 90ba5d8:	defff804 	addi	sp,sp,-32
 90ba5dc:	dfc00715 	stw	ra,28(sp)
 90ba5e0:	df000615 	stw	fp,24(sp)
 90ba5e4:	df000604 	addi	fp,sp,24
 90ba5e8:	e13ffd15 	stw	r4,-12(fp)
 90ba5ec:	e17ffe15 	stw	r5,-8(fp)
 90ba5f0:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 90ba5f4:	e0bffd17 	ldw	r2,-12(fp)
 90ba5f8:	10803017 	ldw	r2,192(r2)
 90ba5fc:	10801924 	muli	r2,r2,100
 90ba600:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 90ba604:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90ba608:	e0bffd17 	ldw	r2,-12(fp)
 90ba60c:	10800a17 	ldw	r2,40(r2)
 90ba610:	1007883a 	mov	r3,r2
 90ba614:	e0bffe17 	ldw	r2,-8(fp)
 90ba618:	1885883a 	add	r2,r3,r2
 90ba61c:	10800023 	ldbuio	r2,0(r2)
 90ba620:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 90ba624:	00001706 	br	90ba684 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 90ba628:	e0bffc03 	ldbu	r2,-16(fp)
 90ba62c:	10803fcc 	andi	r2,r2,255
 90ba630:	10c0200c 	andi	r3,r2,128
 90ba634:	e0bfff03 	ldbu	r2,-4(fp)
 90ba638:	1080200c 	andi	r2,r2,128
 90ba63c:	18801426 	beq	r3,r2,90ba690 <alt_wait_for_command_to_complete_amd+0xb8>
 90ba640:	e0bffc03 	ldbu	r2,-16(fp)
 90ba644:	10803fcc 	andi	r2,r2,255
 90ba648:	1080080c 	andi	r2,r2,32
 90ba64c:	1004c03a 	cmpne	r2,r2,zero
 90ba650:	10000f1e 	bne	r2,zero,90ba690 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 90ba654:	01000044 	movi	r4,1
 90ba658:	90b9b600 	call	90b9b60 <usleep>
    timeout--;
 90ba65c:	e0bffb17 	ldw	r2,-20(fp)
 90ba660:	10bfffc4 	addi	r2,r2,-1
 90ba664:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90ba668:	e0bffd17 	ldw	r2,-12(fp)
 90ba66c:	10800a17 	ldw	r2,40(r2)
 90ba670:	1007883a 	mov	r3,r2
 90ba674:	e0bffe17 	ldw	r2,-8(fp)
 90ba678:	1885883a 	add	r2,r3,r2
 90ba67c:	10800023 	ldbuio	r2,0(r2)
 90ba680:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 90ba684:	e0bffb17 	ldw	r2,-20(fp)
 90ba688:	10800048 	cmpgei	r2,r2,1
 90ba68c:	103fe61e 	bne	r2,zero,90ba628 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 90ba690:	e0bffb17 	ldw	r2,-20(fp)
 90ba694:	1004c03a 	cmpne	r2,r2,zero
 90ba698:	1000031e 	bne	r2,zero,90ba6a8 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 90ba69c:	00bfe304 	movi	r2,-116
 90ba6a0:	e0bffa15 	stw	r2,-24(fp)
 90ba6a4:	00000f06 	br	90ba6e4 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90ba6a8:	e0bffd17 	ldw	r2,-12(fp)
 90ba6ac:	10800a17 	ldw	r2,40(r2)
 90ba6b0:	1007883a 	mov	r3,r2
 90ba6b4:	e0bffe17 	ldw	r2,-8(fp)
 90ba6b8:	1885883a 	add	r2,r3,r2
 90ba6bc:	10800023 	ldbuio	r2,0(r2)
 90ba6c0:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 90ba6c4:	e0bffc03 	ldbu	r2,-16(fp)
 90ba6c8:	10803fcc 	andi	r2,r2,255
 90ba6cc:	10c0200c 	andi	r3,r2,128
 90ba6d0:	e0bfff03 	ldbu	r2,-4(fp)
 90ba6d4:	1080200c 	andi	r2,r2,128
 90ba6d8:	18800226 	beq	r3,r2,90ba6e4 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 90ba6dc:	00bffec4 	movi	r2,-5
 90ba6e0:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 90ba6e4:	e0bffa17 	ldw	r2,-24(fp)
}
 90ba6e8:	e037883a 	mov	sp,fp
 90ba6ec:	dfc00117 	ldw	ra,4(sp)
 90ba6f0:	df000017 	ldw	fp,0(sp)
 90ba6f4:	dec00204 	addi	sp,sp,8
 90ba6f8:	f800283a 	ret

090ba6fc <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 90ba6fc:	defff904 	addi	sp,sp,-28
 90ba700:	dfc00615 	stw	ra,24(sp)
 90ba704:	df000515 	stw	fp,20(sp)
 90ba708:	df000504 	addi	fp,sp,20
 90ba70c:	e13ffd15 	stw	r4,-12(fp)
 90ba710:	e17ffe15 	stw	r5,-8(fp)
 90ba714:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 90ba718:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90ba71c:	e0bffd17 	ldw	r2,-12(fp)
 90ba720:	10c03317 	ldw	r3,204(r2)
 90ba724:	e0bffd17 	ldw	r2,-12(fp)
 90ba728:	11000a17 	ldw	r4,40(r2)
 90ba72c:	01415544 	movi	r5,1365
 90ba730:	01802a84 	movi	r6,170
 90ba734:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90ba738:	e0bffd17 	ldw	r2,-12(fp)
 90ba73c:	10c03317 	ldw	r3,204(r2)
 90ba740:	e0bffd17 	ldw	r2,-12(fp)
 90ba744:	11000a17 	ldw	r4,40(r2)
 90ba748:	0140aa84 	movi	r5,682
 90ba74c:	01801544 	movi	r6,85
 90ba750:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 90ba754:	e0bffd17 	ldw	r2,-12(fp)
 90ba758:	10c03317 	ldw	r3,204(r2)
 90ba75c:	e0bffd17 	ldw	r2,-12(fp)
 90ba760:	11000a17 	ldw	r4,40(r2)
 90ba764:	01415544 	movi	r5,1365
 90ba768:	01802804 	movi	r6,160
 90ba76c:	183ee83a 	callr	r3
  
  value = *src_addr;
 90ba770:	e0bfff17 	ldw	r2,-4(fp)
 90ba774:	10800003 	ldbu	r2,0(r2)
 90ba778:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 90ba77c:	e13ffd17 	ldw	r4,-12(fp)
 90ba780:	e17ffe17 	ldw	r5,-8(fp)
 90ba784:	e1bfff17 	ldw	r6,-4(fp)
 90ba788:	9095be00 	call	9095be0 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 90ba78c:	e1bffb03 	ldbu	r6,-20(fp)
 90ba790:	e13ffd17 	ldw	r4,-12(fp)
 90ba794:	e17ffe17 	ldw	r5,-8(fp)
 90ba798:	90ba5d80 	call	90ba5d8 <alt_wait_for_command_to_complete_amd>
 90ba79c:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 90ba7a0:	e0bffc17 	ldw	r2,-16(fp)
  
}
 90ba7a4:	e037883a 	mov	sp,fp
 90ba7a8:	dfc00117 	ldw	ra,4(sp)
 90ba7ac:	df000017 	ldw	fp,0(sp)
 90ba7b0:	dec00204 	addi	sp,sp,8
 90ba7b4:	f800283a 	ret

090ba7b8 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 90ba7b8:	defff704 	addi	sp,sp,-36
 90ba7bc:	dfc00815 	stw	ra,32(sp)
 90ba7c0:	df000715 	stw	fp,28(sp)
 90ba7c4:	df000704 	addi	fp,sp,28
 90ba7c8:	e13ffc15 	stw	r4,-16(fp)
 90ba7cc:	e17ffd15 	stw	r5,-12(fp)
 90ba7d0:	e1bffe15 	stw	r6,-8(fp)
 90ba7d4:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 90ba7d8:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90ba7dc:	e0bffc17 	ldw	r2,-16(fp)
 90ba7e0:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 90ba7e4:	e13ffa17 	ldw	r4,-24(fp)
 90ba7e8:	e17ffd17 	ldw	r5,-12(fp)
 90ba7ec:	90ba9b00 	call	90ba9b0 <alt_unlock_block_intel>
 90ba7f0:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 90ba7f4:	e0bffb17 	ldw	r2,-20(fp)
 90ba7f8:	1004c03a 	cmpne	r2,r2,zero
 90ba7fc:	1000091e 	bne	r2,zero,90ba824 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 90ba800:	e1bfff17 	ldw	r6,-4(fp)
 90ba804:	00824334 	movhi	r2,2316
 90ba808:	10aacf04 	addi	r2,r2,-21700
 90ba80c:	d8800015 	stw	r2,0(sp)
 90ba810:	e13ffa17 	ldw	r4,-24(fp)
 90ba814:	e17ffe17 	ldw	r5,-8(fp)
 90ba818:	e1c00217 	ldw	r7,8(fp)
 90ba81c:	9095d440 	call	9095d44 <alt_flash_program_block>
 90ba820:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 90ba824:	e0bffb17 	ldw	r2,-20(fp)
}
 90ba828:	e037883a 	mov	sp,fp
 90ba82c:	dfc00117 	ldw	ra,4(sp)
 90ba830:	df000017 	ldw	fp,0(sp)
 90ba834:	dec00204 	addi	sp,sp,8
 90ba838:	f800283a 	ret

090ba83c <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 90ba83c:	defff804 	addi	sp,sp,-32
 90ba840:	dfc00715 	stw	ra,28(sp)
 90ba844:	df000615 	stw	fp,24(sp)
 90ba848:	df000604 	addi	fp,sp,24
 90ba84c:	e13ffe15 	stw	r4,-8(fp)
 90ba850:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 90ba854:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90ba858:	e0bffe17 	ldw	r2,-8(fp)
 90ba85c:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 90ba860:	e0bffb17 	ldw	r2,-20(fp)
 90ba864:	10803117 	ldw	r2,196(r2)
 90ba868:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 90ba86c:	e13ffb17 	ldw	r4,-20(fp)
 90ba870:	e17fff17 	ldw	r5,-4(fp)
 90ba874:	90ba9b00 	call	90ba9b0 <alt_unlock_block_intel>
 90ba878:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 90ba87c:	e0bffc17 	ldw	r2,-16(fp)
 90ba880:	1004c03a 	cmpne	r2,r2,zero
 90ba884:	1000441e 	bne	r2,zero,90ba998 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 90ba888:	e0bffb17 	ldw	r2,-20(fp)
 90ba88c:	11803517 	ldw	r6,212(r2)
 90ba890:	e0bffb17 	ldw	r2,-20(fp)
 90ba894:	10800a17 	ldw	r2,40(r2)
 90ba898:	1007883a 	mov	r3,r2
 90ba89c:	e0bfff17 	ldw	r2,-4(fp)
 90ba8a0:	1889883a 	add	r4,r3,r2
 90ba8a4:	01400804 	movi	r5,32
 90ba8a8:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 90ba8ac:	e0bffb17 	ldw	r2,-20(fp)
 90ba8b0:	11803517 	ldw	r6,212(r2)
 90ba8b4:	e0bffb17 	ldw	r2,-20(fp)
 90ba8b8:	10800a17 	ldw	r2,40(r2)
 90ba8bc:	1007883a 	mov	r3,r2
 90ba8c0:	e0bfff17 	ldw	r2,-4(fp)
 90ba8c4:	1889883a 	add	r4,r3,r2
 90ba8c8:	01403404 	movi	r5,208
 90ba8cc:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90ba8d0:	e0bffb17 	ldw	r2,-20(fp)
 90ba8d4:	10800a17 	ldw	r2,40(r2)
 90ba8d8:	1007883a 	mov	r3,r2
 90ba8dc:	e0bfff17 	ldw	r2,-4(fp)
 90ba8e0:	1885883a 	add	r2,r3,r2
 90ba8e4:	10800023 	ldbuio	r2,0(r2)
 90ba8e8:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 90ba8ec:	e0bffd03 	ldbu	r2,-12(fp)
 90ba8f0:	10803fcc 	andi	r2,r2,255
 90ba8f4:	1080201c 	xori	r2,r2,128
 90ba8f8:	10bfe004 	addi	r2,r2,-128
 90ba8fc:	1004803a 	cmplt	r2,r2,zero
 90ba900:	1000081e 	bne	r2,zero,90ba924 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 90ba904:	0100fa04 	movi	r4,1000
 90ba908:	90b9b600 	call	90b9b60 <usleep>
      timeout -= 1000;
 90ba90c:	e0bffa17 	ldw	r2,-24(fp)
 90ba910:	10bf0604 	addi	r2,r2,-1000
 90ba914:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 90ba918:	e0bffa17 	ldw	r2,-24(fp)
 90ba91c:	10800048 	cmpgei	r2,r2,1
 90ba920:	103feb1e 	bne	r2,zero,90ba8d0 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 90ba924:	e0bffa17 	ldw	r2,-24(fp)
 90ba928:	10800048 	cmpgei	r2,r2,1
 90ba92c:	1000031e 	bne	r2,zero,90ba93c <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 90ba930:	00bfe304 	movi	r2,-116
 90ba934:	e0bffc15 	stw	r2,-16(fp)
 90ba938:	00000e06 	br	90ba974 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 90ba93c:	e0bffd03 	ldbu	r2,-12(fp)
 90ba940:	10803fcc 	andi	r2,r2,255
 90ba944:	10801fcc 	andi	r2,r2,127
 90ba948:	1005003a 	cmpeq	r2,r2,zero
 90ba94c:	1000091e 	bne	r2,zero,90ba974 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 90ba950:	00bffec4 	movi	r2,-5
 90ba954:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90ba958:	e0bffb17 	ldw	r2,-20(fp)
 90ba95c:	10800a17 	ldw	r2,40(r2)
 90ba960:	1007883a 	mov	r3,r2
 90ba964:	e0bfff17 	ldw	r2,-4(fp)
 90ba968:	1885883a 	add	r2,r3,r2
 90ba96c:	10800023 	ldbuio	r2,0(r2)
 90ba970:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 90ba974:	e0bffb17 	ldw	r2,-20(fp)
 90ba978:	11803517 	ldw	r6,212(r2)
 90ba97c:	e0bffb17 	ldw	r2,-20(fp)
 90ba980:	10800a17 	ldw	r2,40(r2)
 90ba984:	1007883a 	mov	r3,r2
 90ba988:	e0bfff17 	ldw	r2,-4(fp)
 90ba98c:	1889883a 	add	r4,r3,r2
 90ba990:	01403fc4 	movi	r5,255
 90ba994:	303ee83a 	callr	r6
  }
  
  return ret_code;
 90ba998:	e0bffc17 	ldw	r2,-16(fp)
}
 90ba99c:	e037883a 	mov	sp,fp
 90ba9a0:	dfc00117 	ldw	ra,4(sp)
 90ba9a4:	df000017 	ldw	fp,0(sp)
 90ba9a8:	dec00204 	addi	sp,sp,8
 90ba9ac:	f800283a 	ret

090ba9b0 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 90ba9b0:	defff904 	addi	sp,sp,-28
 90ba9b4:	dfc00615 	stw	ra,24(sp)
 90ba9b8:	df000515 	stw	fp,20(sp)
 90ba9bc:	df000504 	addi	fp,sp,20
 90ba9c0:	e13ffe15 	stw	r4,-8(fp)
 90ba9c4:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 90ba9c8:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 90ba9cc:	e0bffe17 	ldw	r2,-8(fp)
 90ba9d0:	10803017 	ldw	r2,192(r2)
 90ba9d4:	10801924 	muli	r2,r2,100
 90ba9d8:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 90ba9dc:	e0bffe17 	ldw	r2,-8(fp)
 90ba9e0:	11803517 	ldw	r6,212(r2)
 90ba9e4:	e0bffe17 	ldw	r2,-8(fp)
 90ba9e8:	10800a17 	ldw	r2,40(r2)
 90ba9ec:	1007883a 	mov	r3,r2
 90ba9f0:	e0bfff17 	ldw	r2,-4(fp)
 90ba9f4:	1889883a 	add	r4,r3,r2
 90ba9f8:	01402404 	movi	r5,144
 90ba9fc:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 90baa00:	e0bffe17 	ldw	r2,-8(fp)
 90baa04:	10800a17 	ldw	r2,40(r2)
 90baa08:	1007883a 	mov	r3,r2
 90baa0c:	e0bfff17 	ldw	r2,-4(fp)
 90baa10:	1885883a 	add	r2,r3,r2
 90baa14:	10800104 	addi	r2,r2,4
 90baa18:	10800023 	ldbuio	r2,0(r2)
 90baa1c:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 90baa20:	e0bffd43 	ldbu	r2,-11(fp)
 90baa24:	1080004c 	andi	r2,r2,1
 90baa28:	10803fcc 	andi	r2,r2,255
 90baa2c:	1005003a 	cmpeq	r2,r2,zero
 90baa30:	1000331e 	bne	r2,zero,90bab00 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 90baa34:	e0bffe17 	ldw	r2,-8(fp)
 90baa38:	11803517 	ldw	r6,212(r2)
 90baa3c:	e0bffe17 	ldw	r2,-8(fp)
 90baa40:	10800a17 	ldw	r2,40(r2)
 90baa44:	1007883a 	mov	r3,r2
 90baa48:	e0bfff17 	ldw	r2,-4(fp)
 90baa4c:	1889883a 	add	r4,r3,r2
 90baa50:	01401804 	movi	r5,96
 90baa54:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 90baa58:	e0bffe17 	ldw	r2,-8(fp)
 90baa5c:	11803517 	ldw	r6,212(r2)
 90baa60:	e0bffe17 	ldw	r2,-8(fp)
 90baa64:	10800a17 	ldw	r2,40(r2)
 90baa68:	1007883a 	mov	r3,r2
 90baa6c:	e0bfff17 	ldw	r2,-4(fp)
 90baa70:	1889883a 	add	r4,r3,r2
 90baa74:	01403404 	movi	r5,208
 90baa78:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90baa7c:	e0bffe17 	ldw	r2,-8(fp)
 90baa80:	10800a17 	ldw	r2,40(r2)
 90baa84:	1007883a 	mov	r3,r2
 90baa88:	e0bfff17 	ldw	r2,-4(fp)
 90baa8c:	1885883a 	add	r2,r3,r2
 90baa90:	10800023 	ldbuio	r2,0(r2)
 90baa94:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 90baa98:	e0bffd03 	ldbu	r2,-12(fp)
 90baa9c:	10803fcc 	andi	r2,r2,255
 90baaa0:	1080201c 	xori	r2,r2,128
 90baaa4:	10bfe004 	addi	r2,r2,-128
 90baaa8:	1004803a 	cmplt	r2,r2,zero
 90baaac:	1000081e 	bne	r2,zero,90baad0 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 90baab0:	e0bffb17 	ldw	r2,-20(fp)
 90baab4:	10bfffc4 	addi	r2,r2,-1
 90baab8:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 90baabc:	01000044 	movi	r4,1
 90baac0:	90b9b600 	call	90b9b60 <usleep>
    }while(timeout > 0);
 90baac4:	e0bffb17 	ldw	r2,-20(fp)
 90baac8:	10800048 	cmpgei	r2,r2,1
 90baacc:	103feb1e 	bne	r2,zero,90baa7c <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 90baad0:	e0bffb17 	ldw	r2,-20(fp)
 90baad4:	1004c03a 	cmpne	r2,r2,zero
 90baad8:	1000031e 	bne	r2,zero,90baae8 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 90baadc:	00bfe304 	movi	r2,-116
 90baae0:	e0bffc15 	stw	r2,-16(fp)
 90baae4:	00000606 	br	90bab00 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 90baae8:	e0bffd03 	ldbu	r2,-12(fp)
 90baaec:	10801fcc 	andi	r2,r2,127
 90baaf0:	1005003a 	cmpeq	r2,r2,zero
 90baaf4:	1000021e 	bne	r2,zero,90bab00 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 90baaf8:	00bffec4 	movi	r2,-5
 90baafc:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 90bab00:	e0bffe17 	ldw	r2,-8(fp)
 90bab04:	11803517 	ldw	r6,212(r2)
 90bab08:	e0bffe17 	ldw	r2,-8(fp)
 90bab0c:	10800a17 	ldw	r2,40(r2)
 90bab10:	1007883a 	mov	r3,r2
 90bab14:	e0bfff17 	ldw	r2,-4(fp)
 90bab18:	1889883a 	add	r4,r3,r2
 90bab1c:	01403fc4 	movi	r5,255
 90bab20:	303ee83a 	callr	r6

  return ret_code;
 90bab24:	e0bffc17 	ldw	r2,-16(fp)
}
 90bab28:	e037883a 	mov	sp,fp
 90bab2c:	dfc00117 	ldw	ra,4(sp)
 90bab30:	df000017 	ldw	fp,0(sp)
 90bab34:	dec00204 	addi	sp,sp,8
 90bab38:	f800283a 	ret

090bab3c <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 90bab3c:	defff904 	addi	sp,sp,-28
 90bab40:	dfc00615 	stw	ra,24(sp)
 90bab44:	df000515 	stw	fp,20(sp)
 90bab48:	df000504 	addi	fp,sp,20
 90bab4c:	e13ffd15 	stw	r4,-12(fp)
 90bab50:	e17ffe15 	stw	r5,-8(fp)
 90bab54:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 90bab58:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 90bab5c:	e0bffd17 	ldw	r2,-12(fp)
 90bab60:	11803517 	ldw	r6,212(r2)
 90bab64:	e0bffd17 	ldw	r2,-12(fp)
 90bab68:	10800a17 	ldw	r2,40(r2)
 90bab6c:	1007883a 	mov	r3,r2
 90bab70:	e0bffe17 	ldw	r2,-8(fp)
 90bab74:	1889883a 	add	r4,r3,r2
 90bab78:	01401004 	movi	r5,64
 90bab7c:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 90bab80:	e13ffd17 	ldw	r4,-12(fp)
 90bab84:	e17ffe17 	ldw	r5,-8(fp)
 90bab88:	e1bfff17 	ldw	r6,-4(fp)
 90bab8c:	9095be00 	call	9095be0 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 90bab90:	e0bffd17 	ldw	r2,-12(fp)
 90bab94:	10800a17 	ldw	r2,40(r2)
 90bab98:	1007883a 	mov	r3,r2
 90bab9c:	e0bffe17 	ldw	r2,-8(fp)
 90baba0:	1885883a 	add	r2,r3,r2
 90baba4:	10800023 	ldbuio	r2,0(r2)
 90baba8:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 90babac:	e0bffb03 	ldbu	r2,-20(fp)
 90babb0:	10803fcc 	andi	r2,r2,255
 90babb4:	1080201c 	xori	r2,r2,128
 90babb8:	10bfe004 	addi	r2,r2,-128
 90babbc:	1004403a 	cmpge	r2,r2,zero
 90babc0:	103ff31e 	bne	r2,zero,90bab90 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 90babc4:	e0bffb03 	ldbu	r2,-20(fp)
 90babc8:	10801fcc 	andi	r2,r2,127
 90babcc:	1005003a 	cmpeq	r2,r2,zero
 90babd0:	1000021e 	bne	r2,zero,90babdc <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 90babd4:	00bffec4 	movi	r2,-5
 90babd8:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 90babdc:	e0bffd17 	ldw	r2,-12(fp)
 90babe0:	11803517 	ldw	r6,212(r2)
 90babe4:	e0bffd17 	ldw	r2,-12(fp)
 90babe8:	10800a17 	ldw	r2,40(r2)
 90babec:	1007883a 	mov	r3,r2
 90babf0:	e0bffe17 	ldw	r2,-8(fp)
 90babf4:	1889883a 	add	r4,r3,r2
 90babf8:	01403fc4 	movi	r5,255
 90babfc:	303ee83a 	callr	r6
  
  return ret_code;
 90bac00:	e0bffc17 	ldw	r2,-16(fp)
}
 90bac04:	e037883a 	mov	sp,fp
 90bac08:	dfc00117 	ldw	ra,4(sp)
 90bac0c:	df000017 	ldw	fp,0(sp)
 90bac10:	dec00204 	addi	sp,sp,8
 90bac14:	f800283a 	ret

090bac18 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 90bac18:	defffb04 	addi	sp,sp,-20
 90bac1c:	dfc00415 	stw	ra,16(sp)
 90bac20:	df000315 	stw	fp,12(sp)
 90bac24:	dc000215 	stw	r16,8(sp)
 90bac28:	df000204 	addi	fp,sp,8
   int   e = 0;
 90bac2c:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 90bac30:	d1204b17 	ldw	r4,-32468(gp)
 90bac34:	90828380 	call	9082838 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 90bac38:	01024374 	movhi	r4,2317
 90bac3c:	213fbe04 	addi	r4,r4,-264
 90bac40:	90828380 	call	9082838 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 90bac44:	90a9e0c0 	call	90a9e0c <pre_task_setup>
 90bac48:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bac4c:	e0bffe17 	ldw	r2,-8(fp)
 90bac50:	1005003a 	cmpeq	r2,r2,zero
 90bac54:	1000021e 	bne	r2,zero,90bac60 <netmain_init+0x48>
      panic(msg);
 90bac58:	e13ffe17 	ldw	r4,-8(fp)
 90bac5c:	90a438c0 	call	90a438c <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 90bac60:	90a1cf80 	call	90a1cf8 <ip_startup>
 90bac64:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bac68:	e0bffe17 	ldw	r2,-8(fp)
 90bac6c:	1005003a 	cmpeq	r2,r2,zero
 90bac70:	1000071e 	bne	r2,zero,90bac90 <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 90bac74:	01024374 	movhi	r4,2317
 90bac78:	213fd004 	addi	r4,r4,-192
 90bac7c:	e17ffe17 	ldw	r5,-8(fp)
 90bac80:	90825100 	call	9082510 <printf>
      panic("IP");
 90bac84:	01024374 	movhi	r4,2317
 90bac88:	213fd604 	addi	r4,r4,-168
 90bac8c:	90a438c0 	call	90a438c <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 90bac90:	90c5b180 	call	90c5b18 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 90bac94:	90c50600 	call	90c5060 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 90bac98:	00824374 	movhi	r2,2317
 90bac9c:	108c1d04 	addi	r2,r2,12404
 90baca0:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 90baca4:	008243b4 	movhi	r2,2318
 90baca8:	10b65f04 	addi	r2,r2,-9860
 90bacac:	10800017 	ldw	r2,0(r2)
 90bacb0:	14000104 	addi	r16,r2,4
 90bacb4:	008243b4 	movhi	r2,2318
 90bacb8:	10b65f04 	addi	r2,r2,-9860
 90bacbc:	10800017 	ldw	r2,0(r2)
 90bacc0:	11000a17 	ldw	r4,40(r2)
 90bacc4:	90a415c0 	call	90a415c <print_ipad>
 90bacc8:	100d883a 	mov	r6,r2
 90baccc:	01024374 	movhi	r4,2317
 90bacd0:	213fd704 	addi	r4,r4,-164
 90bacd4:	800b883a 	mov	r5,r16
 90bacd8:	90825100 	call	9082510 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 90bacdc:	90a9e800 	call	90a9e80 <post_task_setup>
 90bace0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bace4:	e0bffe17 	ldw	r2,-8(fp)
 90bace8:	1005003a 	cmpeq	r2,r2,zero
 90bacec:	1000021e 	bne	r2,zero,90bacf8 <netmain_init+0xe0>
      panic(msg);
 90bacf0:	e13ffe17 	ldw	r4,-8(fp)
 90bacf4:	90a438c0 	call	90a438c <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 90bacf8:	90c57480 	call	90c5748 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 90bacfc:	e037883a 	mov	sp,fp
 90bad00:	dfc00217 	ldw	ra,8(sp)
 90bad04:	df000117 	ldw	fp,4(sp)
 90bad08:	dc000017 	ldw	r16,0(sp)
 90bad0c:	dec00304 	addi	sp,sp,12
 90bad10:	f800283a 	ret

090bad14 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 90bad14:	defffb04 	addi	sp,sp,-20
 90bad18:	dfc00415 	stw	ra,16(sp)
 90bad1c:	df000315 	stw	fp,12(sp)
 90bad20:	dc000215 	stw	r16,8(sp)
 90bad24:	df000204 	addi	fp,sp,8
 90bad28:	e13ffe15 	stw	r4,-8(fp)
 90bad2c:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 90bad30:	e0bfff17 	ldw	r2,-4(fp)
 90bad34:	10800003 	ldbu	r2,0(r2)
 90bad38:	10803fcc 	andi	r2,r2,255
 90bad3c:	1080201c 	xori	r2,r2,128
 90bad40:	10bfe004 	addi	r2,r2,-128
 90bad44:	00c24374 	movhi	r3,2317
 90bad48:	18cb3604 	addi	r3,r3,11480
 90bad4c:	1085883a 	add	r2,r2,r2
 90bad50:	1085883a 	add	r2,r2,r2
 90bad54:	10c5883a 	add	r2,r2,r3
 90bad58:	14000017 	ldw	r16,0(r2)
 90bad5c:	e0bffe17 	ldw	r2,-8(fp)
 90bad60:	11000717 	ldw	r4,28(r2)
 90bad64:	90a415c0 	call	90a415c <print_ipad>
 90bad68:	100d883a 	mov	r6,r2
 90bad6c:	01024374 	movhi	r4,2317
 90bad70:	213fe704 	addi	r4,r4,-100
 90bad74:	800b883a 	mov	r5,r16
 90bad78:	90825100 	call	9082510 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 90bad7c:	d1204c17 	ldw	r4,-32464(gp)
 90bad80:	90825100 	call	9082510 <printf>
}
 90bad84:	e037883a 	mov	sp,fp
 90bad88:	dfc00217 	ldw	ra,8(sp)
 90bad8c:	df000117 	ldw	fp,4(sp)
 90bad90:	dc000017 	ldw	r16,0(sp)
 90bad94:	dec00304 	addi	sp,sp,12
 90bad98:	f800283a 	ret

090bad9c <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 90bad9c:	defff904 	addi	sp,sp,-28
 90bada0:	dfc00615 	stw	ra,24(sp)
 90bada4:	df000515 	stw	fp,20(sp)
 90bada8:	dc000415 	stw	r16,16(sp)
 90badac:	df000404 	addi	fp,sp,16
 90badb0:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 90badb4:	e03ffe15 	stw	zero,-8(fp)
 90badb8:	008243b4 	movhi	r2,2318
 90badbc:	10b65f04 	addi	r2,r2,-9860
 90badc0:	10800017 	ldw	r2,0(r2)
 90badc4:	e0bffd15 	stw	r2,-12(fp)
 90badc8:	00002206 	br	90bae54 <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 90badcc:	e0bffd17 	ldw	r2,-12(fp)
 90badd0:	14000104 	addi	r16,r2,4
 90badd4:	e0bffd17 	ldw	r2,-12(fp)
 90badd8:	11000a17 	ldw	r4,40(r2)
 90baddc:	90a415c0 	call	90a415c <print_ipad>
 90bade0:	d8800015 	stw	r2,0(sp)
 90bade4:	e13fff17 	ldw	r4,-4(fp)
 90bade8:	01424374 	movhi	r5,2317
 90badec:	297ff004 	addi	r5,r5,-64
 90badf0:	e1bffe17 	ldw	r6,-8(fp)
 90badf4:	800f883a 	mov	r7,r16
 90badf8:	90a45b40 	call	90a45b4 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 90badfc:	e0bffd17 	ldw	r2,-12(fp)
 90bae00:	11000c17 	ldw	r4,48(r2)
 90bae04:	90a415c0 	call	90a415c <print_ipad>
 90bae08:	100d883a 	mov	r6,r2
 90bae0c:	e13fff17 	ldw	r4,-4(fp)
 90bae10:	01424374 	movhi	r5,2317
 90bae14:	297ff704 	addi	r5,r5,-36
 90bae18:	90a45b40 	call	90a45b4 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 90bae1c:	e0bffd17 	ldw	r2,-12(fp)
 90bae20:	11000d17 	ldw	r4,52(r2)
 90bae24:	90a415c0 	call	90a415c <print_ipad>
 90bae28:	100d883a 	mov	r6,r2
 90bae2c:	e13fff17 	ldw	r4,-4(fp)
 90bae30:	01424374 	movhi	r5,2317
 90bae34:	297ffa04 	addi	r5,r5,-24
 90bae38:	90a45b40 	call	90a45b4 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 90bae3c:	e0bffd17 	ldw	r2,-12(fp)
 90bae40:	10800017 	ldw	r2,0(r2)
 90bae44:	e0bffd15 	stw	r2,-12(fp)
 90bae48:	e0bffe17 	ldw	r2,-8(fp)
 90bae4c:	10800044 	addi	r2,r2,1
 90bae50:	e0bffe15 	stw	r2,-8(fp)
 90bae54:	e0bffd17 	ldw	r2,-12(fp)
 90bae58:	1004c03a 	cmpne	r2,r2,zero
 90bae5c:	103fdb1e 	bne	r2,zero,90badcc <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 90bae60:	00824374 	movhi	r2,2317
 90bae64:	108c4204 	addi	r2,r2,12552
 90bae68:	11800017 	ldw	r6,0(r2)
 90bae6c:	e13fff17 	ldw	r4,-4(fp)
 90bae70:	01424374 	movhi	r5,2317
 90bae74:	297ffd04 	addi	r5,r5,-12
 90bae78:	90a45b40 	call	90a45b4 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 90bae7c:	d4204d17 	ldw	r16,-32460(gp)
 90bae80:	d1204d17 	ldw	r4,-32460(gp)
 90bae84:	908c0380 	call	908c038 <__floatunsidf>
 90bae88:	100b883a 	mov	r5,r2
 90bae8c:	180d883a 	mov	r6,r3
 90bae90:	2809883a 	mov	r4,r5
 90bae94:	300b883a 	mov	r5,r6
 90bae98:	000d883a 	mov	r6,zero
 90bae9c:	01d00934 	movhi	r7,16420
 90baea0:	908b5b40 	call	908b5b4 <__muldf3>
 90baea4:	1009883a 	mov	r4,r2
 90baea8:	180b883a 	mov	r5,r3
 90baeac:	2005883a 	mov	r2,r4
 90baeb0:	2807883a 	mov	r3,r5
 90baeb4:	d8c00015 	stw	r3,0(sp)
 90baeb8:	100f883a 	mov	r7,r2
 90baebc:	e13fff17 	ldw	r4,-4(fp)
 90baec0:	01424374 	movhi	r5,2317
 90baec4:	29400304 	addi	r5,r5,12
 90baec8:	800d883a 	mov	r6,r16
 90baecc:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 90baed0:	d120ba17 	ldw	r4,-32024(gp)
 90baed4:	90a415c0 	call	90a415c <print_ipad>
 90baed8:	100d883a 	mov	r6,r2
 90baedc:	e13fff17 	ldw	r4,-4(fp)
 90baee0:	01424374 	movhi	r5,2317
 90baee4:	29400f04 	addi	r5,r5,60
 90baee8:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 90baeec:	d1a04e17 	ldw	r6,-32456(gp)
 90baef0:	e13fff17 	ldw	r4,-4(fp)
 90baef4:	01424374 	movhi	r5,2317
 90baef8:	29401604 	addi	r5,r5,88
 90baefc:	90a45b40 	call	90a45b4 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 90baf00:	e13fff17 	ldw	r4,-4(fp)
 90baf04:	90bb6180 	call	90bb618 <task_stats>

   return 0;
 90baf08:	0005883a 	mov	r2,zero
}
 90baf0c:	e037883a 	mov	sp,fp
 90baf10:	dfc00217 	ldw	ra,8(sp)
 90baf14:	df000117 	ldw	fp,4(sp)
 90baf18:	dc000017 	ldw	r16,0(sp)
 90baf1c:	dec00304 	addi	sp,sp,12
 90baf20:	f800283a 	ret

090baf24 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 90baf24:	defffe04 	addi	sp,sp,-8
 90baf28:	dfc00115 	stw	ra,4(sp)
 90baf2c:	df000015 	stw	fp,0(sp)
 90baf30:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 90baf34:	00824374 	movhi	r2,2317
 90baf38:	108c4204 	addi	r2,r2,12552
 90baf3c:	11000017 	ldw	r4,0(r2)
 90baf40:	908c0380 	call	908c038 <__floatunsidf>
 90baf44:	100b883a 	mov	r5,r2
 90baf48:	180d883a 	mov	r6,r3
 90baf4c:	2809883a 	mov	r4,r5
 90baf50:	300b883a 	mov	r5,r6
 90baf54:	000d883a 	mov	r6,zero
 90baf58:	01d01674 	movhi	r7,16473
 90baf5c:	908b9680 	call	908b968 <__divdf3>
 90baf60:	1009883a 	mov	r4,r2
 90baf64:	180b883a 	mov	r5,r3
 90baf68:	2005883a 	mov	r2,r4
 90baf6c:	2807883a 	mov	r3,r5
 90baf70:	1009883a 	mov	r4,r2
 90baf74:	180b883a 	mov	r5,r3
 90baf78:	000d883a 	mov	r6,zero
 90baf7c:	01d01674 	movhi	r7,16473
 90baf80:	908b5b40 	call	908b5b4 <__muldf3>
 90baf84:	1009883a 	mov	r4,r2
 90baf88:	180b883a 	mov	r5,r3
 90baf8c:	2005883a 	mov	r2,r4
 90baf90:	2807883a 	mov	r3,r5
 90baf94:	1009883a 	mov	r4,r2
 90baf98:	180b883a 	mov	r5,r3
 90baf9c:	90cade40 	call	90cade4 <__fixunsdfsi>
}
 90bafa0:	e037883a 	mov	sp,fp
 90bafa4:	dfc00117 	ldw	ra,4(sp)
 90bafa8:	df000017 	ldw	fp,0(sp)
 90bafac:	dec00204 	addi	sp,sp,8
 90bafb0:	f800283a 	ret

090bafb4 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 90bafb4:	defffe04 	addi	sp,sp,-8
 90bafb8:	dfc00115 	stw	ra,4(sp)
 90bafbc:	df000015 	stw	fp,0(sp)
 90bafc0:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 90bafc4:	d0a0bb17 	ldw	r2,-32020(gp)
 90bafc8:	1004c03a 	cmpne	r2,r2,zero
 90bafcc:	1000071e 	bne	r2,zero,90bafec <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 90bafd0:	d0a0bb17 	ldw	r2,-32020(gp)
 90bafd4:	10800044 	addi	r2,r2,1
 90bafd8:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 90bafdc:	90a16b00 	call	90a16b0 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 90bafe0:	d0a0bb17 	ldw	r2,-32020(gp)
 90bafe4:	10bfffc4 	addi	r2,r2,-1
 90bafe8:	d0a0bb15 	stw	r2,-32020(gp)
}
 90bafec:	e037883a 	mov	sp,fp
 90baff0:	dfc00117 	ldw	ra,4(sp)
 90baff4:	df000017 	ldw	fp,0(sp)
 90baff8:	dec00204 	addi	sp,sp,8
 90baffc:	f800283a 	ret

090bb000 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 90bb000:	defffe04 	addi	sp,sp,-8
 90bb004:	df000115 	stw	fp,4(sp)
 90bb008:	df000104 	addi	fp,sp,4
 90bb00c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 90bb010:	0005883a 	mov	r2,zero
}
 90bb014:	e037883a 	mov	sp,fp
 90bb018:	df000017 	ldw	fp,0(sp)
 90bb01c:	dec00104 	addi	sp,sp,4
 90bb020:	f800283a 	ret

090bb024 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 90bb024:	defffd04 	addi	sp,sp,-12
 90bb028:	dfc00215 	stw	ra,8(sp)
 90bb02c:	df000115 	stw	fp,4(sp)
 90bb030:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 90bb034:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 90bb038:	90c8c740 	call	90c8c74 <prep_vfs>
 90bb03c:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 90bb040:	e0bfff17 	ldw	r2,-4(fp)
 90bb044:	1005003a 	cmpeq	r2,r2,zero
 90bb048:	1000061e 	bne	r2,zero,90bb064 <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 90bb04c:	01024374 	movhi	r4,2317
 90bb050:	21001e04 	addi	r4,r4,120
 90bb054:	90828380 	call	9082838 <puts>
      panic("prep_modules");
 90bb058:	01024374 	movhi	r4,2317
 90bb05c:	21002404 	addi	r4,r4,144
 90bb060:	90a438c0 	call	90a438c <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 90bb064:	0005883a 	mov	r2,zero
}
 90bb068:	e037883a 	mov	sp,fp
 90bb06c:	dfc00117 	ldw	ra,4(sp)
 90bb070:	df000017 	ldw	fp,0(sp)
 90bb074:	dec00204 	addi	sp,sp,8
 90bb078:	f800283a 	ret

090bb07c <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 90bb07c:	defffc04 	addi	sp,sp,-16
 90bb080:	dfc00315 	stw	ra,12(sp)
 90bb084:	df000215 	stw	fp,8(sp)
 90bb088:	dc400115 	stw	r17,4(sp)
 90bb08c:	dc000015 	stw	r16,0(sp)
 90bb090:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 90bb094:	00824374 	movhi	r2,2317
 90bb098:	108c6304 	addi	r2,r2,12684
 90bb09c:	10c00017 	ldw	r3,0(r2)
 90bb0a0:	00824374 	movhi	r2,2317
 90bb0a4:	108c4204 	addi	r2,r2,12552
 90bb0a8:	10800017 	ldw	r2,0(r2)
 90bb0ac:	1880012e 	bgeu	r3,r2,90bb0b4 <inet_timer+0x38>
      ip_reasm_process_timer_tick ();
 90bb0b0:	90c08280 	call	90c0828 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 90bb0b4:	90aba500 	call	90aba50 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 90bb0b8:	90bb1e00 	call	90bb1e0 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 90bb0bc:	00824374 	movhi	r2,2317
 90bb0c0:	108c2104 	addi	r2,r2,12420
 90bb0c4:	10c00017 	ldw	r3,0(r2)
 90bb0c8:	00824374 	movhi	r2,2317
 90bb0cc:	108c4204 	addi	r2,r2,12552
 90bb0d0:	10800017 	ldw	r2,0(r2)
 90bb0d4:	1880012e 	bgeu	r3,r2,90bb0dc <inet_timer+0x60>
      igmp_fasttimo();
 90bb0d8:	90a23900 	call	90a2390 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 90bb0dc:	d0a0bc17 	ldw	r2,-32016(gp)
 90bb0e0:	00c24374 	movhi	r3,2317
 90bb0e4:	18cc4204 	addi	r3,r3,12552
 90bb0e8:	18c00017 	ldw	r3,0(r3)
 90bb0ec:	10c01c36 	bltu	r2,r3,90bb160 <inet_timer+0xe4>
 90bb0f0:	d120bc17 	ldw	r4,-32016(gp)
 90bb0f4:	908c0380 	call	908c038 <__floatunsidf>
 90bb0f8:	1021883a 	mov	r16,r2
 90bb0fc:	1823883a 	mov	r17,r3
 90bb100:	00824374 	movhi	r2,2317
 90bb104:	108c4204 	addi	r2,r2,12552
 90bb108:	11000017 	ldw	r4,0(r2)
 90bb10c:	908c0380 	call	908c038 <__floatunsidf>
 90bb110:	100b883a 	mov	r5,r2
 90bb114:	180d883a 	mov	r6,r3
 90bb118:	2809883a 	mov	r4,r5
 90bb11c:	300b883a 	mov	r5,r6
 90bb120:	000d883a 	mov	r6,zero
 90bb124:	01d023f4 	movhi	r7,16527
 90bb128:	39d00004 	addi	r7,r7,16384
 90bb12c:	908b5400 	call	908b540 <__adddf3>
 90bb130:	1009883a 	mov	r4,r2
 90bb134:	180b883a 	mov	r5,r3
 90bb138:	2005883a 	mov	r2,r4
 90bb13c:	2807883a 	mov	r3,r5
 90bb140:	8009883a 	mov	r4,r16
 90bb144:	880b883a 	mov	r5,r17
 90bb148:	100d883a 	mov	r6,r2
 90bb14c:	180f883a 	mov	r7,r3
 90bb150:	908bcd00 	call	908bcd0 <__gtdf2>
 90bb154:	10800048 	cmpgei	r2,r2,1
 90bb158:	1000011e 	bne	r2,zero,90bb160 <inet_timer+0xe4>
 90bb15c:	00001906 	br	90bb1c4 <inet_timer+0x148>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 90bb160:	00824374 	movhi	r2,2317
 90bb164:	108c4204 	addi	r2,r2,12552
 90bb168:	11000017 	ldw	r4,0(r2)
 90bb16c:	908c0380 	call	908c038 <__floatunsidf>
 90bb170:	100b883a 	mov	r5,r2
 90bb174:	180d883a 	mov	r6,r3
 90bb178:	2809883a 	mov	r4,r5
 90bb17c:	300b883a 	mov	r5,r6
 90bb180:	000d883a 	mov	r6,zero
 90bb184:	01d01674 	movhi	r7,16473
 90bb188:	908b5400 	call	908b540 <__adddf3>
 90bb18c:	1009883a 	mov	r4,r2
 90bb190:	180b883a 	mov	r5,r3
 90bb194:	2005883a 	mov	r2,r4
 90bb198:	2807883a 	mov	r3,r5
 90bb19c:	1009883a 	mov	r4,r2
 90bb1a0:	180b883a 	mov	r5,r3
 90bb1a4:	90cade40 	call	90cade4 <__fixunsdfsi>
 90bb1a8:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 90bb1ac:	d0a0bd17 	ldw	r2,-32012(gp)
 90bb1b0:	1005003a 	cmpeq	r2,r2,zero
 90bb1b4:	1000021e 	bne	r2,zero,90bb1c0 <inet_timer+0x144>
         (*port_1s_callout)();
 90bb1b8:	d0a0bd17 	ldw	r2,-32012(gp)
 90bb1bc:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 90bb1c0:	90a77a00 	call	90a77a0 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 90bb1c4:	e037883a 	mov	sp,fp
 90bb1c8:	dfc00317 	ldw	ra,12(sp)
 90bb1cc:	df000217 	ldw	fp,8(sp)
 90bb1d0:	dc400117 	ldw	r17,4(sp)
 90bb1d4:	dc000017 	ldw	r16,0(sp)
 90bb1d8:	dec00404 	addi	sp,sp,16
 90bb1dc:	f800283a 	ret

090bb1e0 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 90bb1e0:	defffc04 	addi	sp,sp,-16
 90bb1e4:	dfc00315 	stw	ra,12(sp)
 90bb1e8:	df000215 	stw	fp,8(sp)
 90bb1ec:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 90bb1f0:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 90bb1f4:	d0a0be17 	ldw	r2,-32008(gp)
 90bb1f8:	10800050 	cmplti	r2,r2,1
 90bb1fc:	1000591e 	bne	r2,zero,90bb364 <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 90bb200:	e03fff15 	stw	zero,-4(fp)
 90bb204:	00005406 	br	90bb358 <check_interval_timers+0x178>
      {
         if (intimers[i].callback)   /* is this timer active? */
 90bb208:	e0bfff17 	ldw	r2,-4(fp)
 90bb20c:	00c243b4 	movhi	r3,2318
 90bb210:	18f60604 	addi	r3,r3,-10216
 90bb214:	10800524 	muli	r2,r2,20
 90bb218:	10c5883a 	add	r2,r2,r3
 90bb21c:	10800017 	ldw	r2,0(r2)
 90bb220:	1005003a 	cmpeq	r2,r2,zero
 90bb224:	1000491e 	bne	r2,zero,90bb34c <check_interval_timers+0x16c>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 90bb228:	e0bfff17 	ldw	r2,-4(fp)
 90bb22c:	00c243b4 	movhi	r3,2318
 90bb230:	18f60604 	addi	r3,r3,-10216
 90bb234:	10800524 	muli	r2,r2,20
 90bb238:	10c5883a 	add	r2,r2,r3
 90bb23c:	10800304 	addi	r2,r2,12
 90bb240:	10c00017 	ldw	r3,0(r2)
 90bb244:	00824374 	movhi	r2,2317
 90bb248:	108c4204 	addi	r2,r2,12552
 90bb24c:	10800017 	ldw	r2,0(r2)
 90bb250:	1880382e 	bgeu	r3,r2,90bb334 <check_interval_timers+0x154>
 90bb254:	e0bfff17 	ldw	r2,-4(fp)
 90bb258:	00c243b4 	movhi	r3,2318
 90bb25c:	18f60604 	addi	r3,r3,-10216
 90bb260:	10800524 	muli	r2,r2,20
 90bb264:	10c5883a 	add	r2,r2,r3
 90bb268:	10800404 	addi	r2,r2,16
 90bb26c:	10800017 	ldw	r2,0(r2)
 90bb270:	1004c03a 	cmpne	r2,r2,zero
 90bb274:	10002f1e 	bne	r2,zero,90bb334 <check_interval_timers+0x154>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 90bb278:	e17fff17 	ldw	r5,-4(fp)
 90bb27c:	e0bfff17 	ldw	r2,-4(fp)
 90bb280:	00c243b4 	movhi	r3,2318
 90bb284:	18f60604 	addi	r3,r3,-10216
 90bb288:	10800524 	muli	r2,r2,20
 90bb28c:	10c5883a 	add	r2,r2,r3
 90bb290:	10800204 	addi	r2,r2,8
 90bb294:	10c00017 	ldw	r3,0(r2)
 90bb298:	00824374 	movhi	r2,2317
 90bb29c:	108c4204 	addi	r2,r2,12552
 90bb2a0:	10800017 	ldw	r2,0(r2)
 90bb2a4:	1889883a 	add	r4,r3,r2
 90bb2a8:	00c243b4 	movhi	r3,2318
 90bb2ac:	18f60604 	addi	r3,r3,-10216
 90bb2b0:	28800524 	muli	r2,r5,20
 90bb2b4:	10c5883a 	add	r2,r2,r3
 90bb2b8:	10800304 	addi	r2,r2,12
 90bb2bc:	11000015 	stw	r4,0(r2)
               intimers[i].inuse = TRUE;
 90bb2c0:	e0bfff17 	ldw	r2,-4(fp)
 90bb2c4:	00c243b4 	movhi	r3,2318
 90bb2c8:	18f60604 	addi	r3,r3,-10216
 90bb2cc:	10800524 	muli	r2,r2,20
 90bb2d0:	10c5883a 	add	r2,r2,r3
 90bb2d4:	10c00404 	addi	r3,r2,16
 90bb2d8:	00800044 	movi	r2,1
 90bb2dc:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 90bb2e0:	e0bfff17 	ldw	r2,-4(fp)
 90bb2e4:	00c243b4 	movhi	r3,2318
 90bb2e8:	18f60604 	addi	r3,r3,-10216
 90bb2ec:	10800524 	muli	r2,r2,20
 90bb2f0:	10c5883a 	add	r2,r2,r3
 90bb2f4:	11400017 	ldw	r5,0(r2)
 90bb2f8:	e0bfff17 	ldw	r2,-4(fp)
 90bb2fc:	00c243b4 	movhi	r3,2318
 90bb300:	18f60604 	addi	r3,r3,-10216
 90bb304:	10800524 	muli	r2,r2,20
 90bb308:	10c5883a 	add	r2,r2,r3
 90bb30c:	10800104 	addi	r2,r2,4
 90bb310:	11000017 	ldw	r4,0(r2)
 90bb314:	283ee83a 	callr	r5
               intimers[i].inuse = FALSE;
 90bb318:	e0bfff17 	ldw	r2,-4(fp)
 90bb31c:	00c243b4 	movhi	r3,2318
 90bb320:	18f60604 	addi	r3,r3,-10216
 90bb324:	10800524 	muli	r2,r2,20
 90bb328:	10c5883a 	add	r2,r2,r3
 90bb32c:	10800404 	addi	r2,r2,16
 90bb330:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 90bb334:	e0bffe17 	ldw	r2,-8(fp)
 90bb338:	10800044 	addi	r2,r2,1
 90bb33c:	e0bffe15 	stw	r2,-8(fp)
 90bb340:	d0e0be17 	ldw	r3,-32008(gp)
 90bb344:	e0bffe17 	ldw	r2,-8(fp)
 90bb348:	10c0060e 	bge	r2,r3,90bb364 <check_interval_timers+0x184>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 90bb34c:	e0bfff17 	ldw	r2,-4(fp)
 90bb350:	10800044 	addi	r2,r2,1
 90bb354:	e0bfff15 	stw	r2,-4(fp)
 90bb358:	e0bfff17 	ldw	r2,-4(fp)
 90bb35c:	10800150 	cmplti	r2,r2,5
 90bb360:	103fa91e 	bne	r2,zero,90bb208 <check_interval_timers+0x28>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 90bb364:	e037883a 	mov	sp,fp
 90bb368:	dfc00117 	ldw	ra,4(sp)
 90bb36c:	df000017 	ldw	fp,0(sp)
 90bb370:	dec00204 	addi	sp,sp,8
 90bb374:	f800283a 	ret

090bb378 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 90bb378:	defff804 	addi	sp,sp,-32
 90bb37c:	dfc00715 	stw	ra,28(sp)
 90bb380:	df000615 	stw	fp,24(sp)
 90bb384:	dc000515 	stw	r16,20(sp)
 90bb388:	df000504 	addi	fp,sp,20
 90bb38c:	e13ffc15 	stw	r4,-16(fp)
 90bb390:	e17ffd15 	stw	r5,-12(fp)
 90bb394:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bb398:	e03ffb15 	stw	zero,-20(fp)
 90bb39c:	00006006 	br	90bb520 <in_timerset+0x1a8>
   {
      if(intimers[i].callback == NULL)
 90bb3a0:	e0bffb17 	ldw	r2,-20(fp)
 90bb3a4:	00c243b4 	movhi	r3,2318
 90bb3a8:	18f60604 	addi	r3,r3,-10216
 90bb3ac:	10800524 	muli	r2,r2,20
 90bb3b0:	10c5883a 	add	r2,r2,r3
 90bb3b4:	10800017 	ldw	r2,0(r2)
 90bb3b8:	1004c03a 	cmpne	r2,r2,zero
 90bb3bc:	1000551e 	bne	r2,zero,90bb514 <in_timerset+0x19c>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 90bb3c0:	e0bffb17 	ldw	r2,-20(fp)
 90bb3c4:	00c243b4 	movhi	r3,2318
 90bb3c8:	18f60604 	addi	r3,r3,-10216
 90bb3cc:	10800524 	muli	r2,r2,20
 90bb3d0:	10c7883a 	add	r3,r2,r3
 90bb3d4:	e0bffc17 	ldw	r2,-16(fp)
 90bb3d8:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 90bb3dc:	e0bffb17 	ldw	r2,-20(fp)
 90bb3e0:	00c243b4 	movhi	r3,2318
 90bb3e4:	18f60604 	addi	r3,r3,-10216
 90bb3e8:	10800524 	muli	r2,r2,20
 90bb3ec:	10c5883a 	add	r2,r2,r3
 90bb3f0:	10c00104 	addi	r3,r2,4
 90bb3f4:	e0bffe17 	ldw	r2,-8(fp)
 90bb3f8:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 90bb3fc:	e43ffb17 	ldw	r16,-20(fp)
 90bb400:	e13ffd17 	ldw	r4,-12(fp)
 90bb404:	908be680 	call	908be68 <__floatsidf>
 90bb408:	100b883a 	mov	r5,r2
 90bb40c:	180d883a 	mov	r6,r3
 90bb410:	2809883a 	mov	r4,r5
 90bb414:	300b883a 	mov	r5,r6
 90bb418:	000d883a 	mov	r6,zero
 90bb41c:	01d01674 	movhi	r7,16473
 90bb420:	908b5b40 	call	908b5b4 <__muldf3>
 90bb424:	1009883a 	mov	r4,r2
 90bb428:	180b883a 	mov	r5,r3
 90bb42c:	2005883a 	mov	r2,r4
 90bb430:	2807883a 	mov	r3,r5
 90bb434:	1009883a 	mov	r4,r2
 90bb438:	180b883a 	mov	r5,r3
 90bb43c:	000d883a 	mov	r6,zero
 90bb440:	01d023f4 	movhi	r7,16527
 90bb444:	39d00004 	addi	r7,r7,16384
 90bb448:	908b9680 	call	908b968 <__divdf3>
 90bb44c:	1009883a 	mov	r4,r2
 90bb450:	180b883a 	mov	r5,r3
 90bb454:	2005883a 	mov	r2,r4
 90bb458:	2807883a 	mov	r3,r5
 90bb45c:	1009883a 	mov	r4,r2
 90bb460:	180b883a 	mov	r5,r3
 90bb464:	90cade40 	call	90cade4 <__fixunsdfsi>
 90bb468:	1009883a 	mov	r4,r2
 90bb46c:	00c243b4 	movhi	r3,2318
 90bb470:	18f60604 	addi	r3,r3,-10216
 90bb474:	80800524 	muli	r2,r16,20
 90bb478:	10c5883a 	add	r2,r2,r3
 90bb47c:	10800204 	addi	r2,r2,8
 90bb480:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 90bb484:	e17ffb17 	ldw	r5,-20(fp)
 90bb488:	e0bffb17 	ldw	r2,-20(fp)
 90bb48c:	00c243b4 	movhi	r3,2318
 90bb490:	18f60604 	addi	r3,r3,-10216
 90bb494:	10800524 	muli	r2,r2,20
 90bb498:	10c5883a 	add	r2,r2,r3
 90bb49c:	10800204 	addi	r2,r2,8
 90bb4a0:	10c00017 	ldw	r3,0(r2)
 90bb4a4:	00824374 	movhi	r2,2317
 90bb4a8:	108c4204 	addi	r2,r2,12552
 90bb4ac:	10800017 	ldw	r2,0(r2)
 90bb4b0:	1889883a 	add	r4,r3,r2
 90bb4b4:	00c243b4 	movhi	r3,2318
 90bb4b8:	18f60604 	addi	r3,r3,-10216
 90bb4bc:	28800524 	muli	r2,r5,20
 90bb4c0:	10c5883a 	add	r2,r2,r3
 90bb4c4:	10800304 	addi	r2,r2,12
 90bb4c8:	11000015 	stw	r4,0(r2)
		 intimers[i].inuse = FALSE;
 90bb4cc:	e0bffb17 	ldw	r2,-20(fp)
 90bb4d0:	00c243b4 	movhi	r3,2318
 90bb4d4:	18f60604 	addi	r3,r3,-10216
 90bb4d8:	10800524 	muli	r2,r2,20
 90bb4dc:	10c5883a 	add	r2,r2,r3
 90bb4e0:	10800404 	addi	r2,r2,16
 90bb4e4:	10000015 	stw	zero,0(r2)
         numtimers++;
 90bb4e8:	d0a0be17 	ldw	r2,-32008(gp)
 90bb4ec:	10800044 	addi	r2,r2,1
 90bb4f0:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 90bb4f4:	e0bffb17 	ldw	r2,-20(fp)
 90bb4f8:	10800524 	muli	r2,r2,20
 90bb4fc:	1007883a 	mov	r3,r2
 90bb500:	008243b4 	movhi	r2,2318
 90bb504:	10b60604 	addi	r2,r2,-10216
 90bb508:	1885883a 	add	r2,r3,r2
 90bb50c:	e0bfff15 	stw	r2,-4(fp)
 90bb510:	00000706 	br	90bb530 <in_timerset+0x1b8>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bb514:	e0bffb17 	ldw	r2,-20(fp)
 90bb518:	10800044 	addi	r2,r2,1
 90bb51c:	e0bffb15 	stw	r2,-20(fp)
 90bb520:	e0bffb17 	ldw	r2,-20(fp)
 90bb524:	10800150 	cmplti	r2,r2,5
 90bb528:	103f9d1e 	bne	r2,zero,90bb3a0 <in_timerset+0x28>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 90bb52c:	e03fff15 	stw	zero,-4(fp)
 90bb530:	e0bfff17 	ldw	r2,-4(fp)
}
 90bb534:	e037883a 	mov	sp,fp
 90bb538:	dfc00217 	ldw	ra,8(sp)
 90bb53c:	df000117 	ldw	fp,4(sp)
 90bb540:	dc000017 	ldw	r16,0(sp)
 90bb544:	dec00304 	addi	sp,sp,12
 90bb548:	f800283a 	ret

090bb54c <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 90bb54c:	defffb04 	addi	sp,sp,-20
 90bb550:	dfc00415 	stw	ra,16(sp)
 90bb554:	df000315 	stw	fp,12(sp)
 90bb558:	df000304 	addi	fp,sp,12
 90bb55c:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bb560:	e03ffd15 	stw	zero,-12(fp)
 90bb564:	00001706 	br	90bb5c4 <in_timerkill+0x78>
   {
      if(timer == (long)&intimers[i])
 90bb568:	e0bffd17 	ldw	r2,-12(fp)
 90bb56c:	10800524 	muli	r2,r2,20
 90bb570:	1007883a 	mov	r3,r2
 90bb574:	008243b4 	movhi	r2,2318
 90bb578:	10b60604 	addi	r2,r2,-10216
 90bb57c:	1885883a 	add	r2,r3,r2
 90bb580:	1007883a 	mov	r3,r2
 90bb584:	e0bffe17 	ldw	r2,-8(fp)
 90bb588:	18800b1e 	bne	r3,r2,90bb5b8 <in_timerkill+0x6c>
      {
         intimers[i].callback = NULL;
 90bb58c:	e0bffd17 	ldw	r2,-12(fp)
 90bb590:	00c243b4 	movhi	r3,2318
 90bb594:	18f60604 	addi	r3,r3,-10216
 90bb598:	10800524 	muli	r2,r2,20
 90bb59c:	10c5883a 	add	r2,r2,r3
 90bb5a0:	10000015 	stw	zero,0(r2)
         numtimers--;
 90bb5a4:	d0a0be17 	ldw	r2,-32008(gp)
 90bb5a8:	10bfffc4 	addi	r2,r2,-1
 90bb5ac:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 90bb5b0:	e03fff15 	stw	zero,-4(fp)
 90bb5b4:	00000906 	br	90bb5dc <in_timerkill+0x90>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bb5b8:	e0bffd17 	ldw	r2,-12(fp)
 90bb5bc:	10800044 	addi	r2,r2,1
 90bb5c0:	e0bffd15 	stw	r2,-12(fp)
 90bb5c4:	e0bffd17 	ldw	r2,-12(fp)
 90bb5c8:	10800150 	cmplti	r2,r2,5
 90bb5cc:	103fe61e 	bne	r2,zero,90bb568 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 90bb5d0:	90a94880 	call	90a9488 <dtrap>
   return ENP_PARAM;
 90bb5d4:	00bffd84 	movi	r2,-10
 90bb5d8:	e0bfff15 	stw	r2,-4(fp)
 90bb5dc:	e0bfff17 	ldw	r2,-4(fp)
}
 90bb5e0:	e037883a 	mov	sp,fp
 90bb5e4:	dfc00117 	ldw	ra,4(sp)
 90bb5e8:	df000017 	ldw	fp,0(sp)
 90bb5ec:	dec00204 	addi	sp,sp,8
 90bb5f0:	f800283a 	ret

090bb5f4 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 90bb5f4:	defffe04 	addi	sp,sp,-8
 90bb5f8:	df000115 	stw	fp,4(sp)
 90bb5fc:	df000104 	addi	fp,sp,4
int e = 0;
 90bb600:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 90bb604:	e0bfff17 	ldw	r2,-4(fp)
}
 90bb608:	e037883a 	mov	sp,fp
 90bb60c:	df000017 	ldw	fp,0(sp)
 90bb610:	dec00104 	addi	sp,sp,4
 90bb614:	f800283a 	ret

090bb618 <task_stats>:
 */


void
task_stats(void * pio)
{
 90bb618:	defffd04 	addi	sp,sp,-12
 90bb61c:	dfc00215 	stw	ra,8(sp)
 90bb620:	df000115 	stw	fp,4(sp)
 90bb624:	df000104 	addi	fp,sp,4
 90bb628:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 90bb62c:	e13fff17 	ldw	r4,-4(fp)
 90bb630:	01424374 	movhi	r5,2317
 90bb634:	29402804 	addi	r5,r5,160
 90bb638:	90a45b40 	call	90a45b4 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 90bb63c:	00824374 	movhi	r2,2317
 90bb640:	108c2404 	addi	r2,r2,12432
 90bb644:	11800017 	ldw	r6,0(r2)
 90bb648:	e13fff17 	ldw	r4,-4(fp)
 90bb64c:	01424374 	movhi	r5,2317
 90bb650:	29402c04 	addi	r5,r5,176
 90bb654:	90a45b40 	call	90a45b4 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 90bb658:	00824374 	movhi	r2,2317
 90bb65c:	108c2504 	addi	r2,r2,12436
 90bb660:	11800017 	ldw	r6,0(r2)
 90bb664:	e13fff17 	ldw	r4,-4(fp)
 90bb668:	01424374 	movhi	r5,2317
 90bb66c:	29403004 	addi	r5,r5,192
 90bb670:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 90bb674:	e13fff17 	ldw	r4,-4(fp)
 90bb678:	01424374 	movhi	r5,2317
 90bb67c:	29403404 	addi	r5,r5,208
 90bb680:	90a45b40 	call	90a45b4 <ns_printf>
}
 90bb684:	e037883a 	mov	sp,fp
 90bb688:	dfc00117 	ldw	ra,4(sp)
 90bb68c:	df000017 	ldw	fp,0(sp)
 90bb690:	dec00204 	addi	sp,sp,8
 90bb694:	f800283a 	ret

090bb698 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 90bb698:	defff704 	addi	sp,sp,-36
 90bb69c:	dfc00615 	stw	ra,24(sp)
 90bb6a0:	df000515 	stw	fp,20(sp)
 90bb6a4:	df000504 	addi	fp,sp,20
 90bb6a8:	e13ffd15 	stw	r4,-12(fp)
 90bb6ac:	e1800215 	stw	r6,8(fp)
 90bb6b0:	e1c00315 	stw	r7,12(fp)
 90bb6b4:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 90bb6b8:	e0bffd17 	ldw	r2,-12(fp)
 90bb6bc:	10800808 	cmpgei	r2,r2,32
 90bb6c0:	10000e1e 	bne	r2,zero,90bb6fc <fcntl+0x64>
  {
    va_start(argp, cmd);
 90bb6c4:	e0800204 	addi	r2,fp,8
 90bb6c8:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 90bb6cc:	e0fffc17 	ldw	r3,-16(fp)
 90bb6d0:	18800104 	addi	r2,r3,4
 90bb6d4:	e0bffc15 	stw	r2,-16(fp)
 90bb6d8:	1805883a 	mov	r2,r3
 90bb6dc:	10800017 	ldw	r2,0(r2)
 90bb6e0:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 90bb6e4:	e13ffd17 	ldw	r4,-12(fp)
 90bb6e8:	e17ffe17 	ldw	r5,-8(fp)
 90bb6ec:	e1bffb17 	ldw	r6,-20(fp)
 90bb6f0:	90c8dc40 	call	90c8dc4 <alt_fcntl>
 90bb6f4:	e0bfff15 	stw	r2,-4(fp)
 90bb6f8:	00000d06 	br	90bb730 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 90bb6fc:	e0800204 	addi	r2,fp,8
 90bb700:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 90bb704:	e0fffc17 	ldw	r3,-16(fp)
 90bb708:	18800104 	addi	r2,r3,4
 90bb70c:	e0bffc15 	stw	r2,-16(fp)
 90bb710:	1805883a 	mov	r2,r3
 90bb714:	10800017 	ldw	r2,0(r2)
 90bb718:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 90bb71c:	e17ffe17 	ldw	r5,-8(fp)
 90bb720:	e13ffd17 	ldw	r4,-12(fp)
 90bb724:	e1bffb17 	ldw	r6,-20(fp)
 90bb728:	90a39080 	call	90a3908 <bsd_ioctl>
 90bb72c:	e0bfff15 	stw	r2,-4(fp)
 90bb730:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 90bb734:	e037883a 	mov	sp,fp
 90bb738:	dfc00117 	ldw	ra,4(sp)
 90bb73c:	df000017 	ldw	fp,0(sp)
 90bb740:	dec00404 	addi	sp,sp,16
 90bb744:	f800283a 	ret

090bb748 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 90bb748:	defffd04 	addi	sp,sp,-12
 90bb74c:	dfc00215 	stw	ra,8(sp)
 90bb750:	df000115 	stw	fp,4(sp)
 90bb754:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 90bb758:	01018204 	movi	r4,1544
 90bb75c:	90bce480 	call	90bce48 <reg_type>
 90bb760:	1005003a 	cmpeq	r2,r2,zero
 90bb764:	1000061e 	bne	r2,zero,90bb780 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 90bb768:	01024374 	movhi	r4,2317
 90bb76c:	21003504 	addi	r4,r4,212
 90bb770:	90828380 	call	9082838 <puts>
#endif
      return (1);
 90bb774:	00800044 	movi	r2,1
 90bb778:	e0bfff15 	stw	r2,-4(fp)
 90bb77c:	00000106 	br	90bb784 <etainit+0x3c>
   }
   return (0);
 90bb780:	e03fff15 	stw	zero,-4(fp)
 90bb784:	e0bfff17 	ldw	r2,-4(fp)
}
 90bb788:	e037883a 	mov	sp,fp
 90bb78c:	dfc00117 	ldw	ra,4(sp)
 90bb790:	df000017 	ldw	fp,0(sp)
 90bb794:	dec00204 	addi	sp,sp,8
 90bb798:	f800283a 	ret

090bb79c <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 90bb79c:	defff904 	addi	sp,sp,-28
 90bb7a0:	dfc00615 	stw	ra,24(sp)
 90bb7a4:	df000515 	stw	fp,20(sp)
 90bb7a8:	df000504 	addi	fp,sp,20
 90bb7ac:	e13ffe15 	stw	r4,-8(fp)
 90bb7b0:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 90bb7b4:	e0bffe17 	ldw	r2,-8(fp)
 90bb7b8:	10800617 	ldw	r2,24(r2)
 90bb7bc:	10802717 	ldw	r2,156(r2)
 90bb7c0:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 90bb7c4:	00824374 	movhi	r2,2317
 90bb7c8:	108c4204 	addi	r2,r2,12552
 90bb7cc:	10c00017 	ldw	r3,0(r2)
 90bb7d0:	e0bfff17 	ldw	r2,-4(fp)
 90bb7d4:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 90bb7d8:	e0bffe17 	ldw	r2,-8(fp)
 90bb7dc:	10800317 	ldw	r2,12(r2)
 90bb7e0:	10fffc04 	addi	r3,r2,-16
 90bb7e4:	e0bffe17 	ldw	r2,-8(fp)
 90bb7e8:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 90bb7ec:	e0bffe17 	ldw	r2,-8(fp)
 90bb7f0:	10800417 	ldw	r2,16(r2)
 90bb7f4:	10c00404 	addi	r3,r2,16
 90bb7f8:	e0bffe17 	ldw	r2,-8(fp)
 90bb7fc:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 90bb800:	e0bffe17 	ldw	r2,-8(fp)
 90bb804:	10800317 	ldw	r2,12(r2)
 90bb808:	10800084 	addi	r2,r2,2
 90bb80c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 90bb810:	e0bffe17 	ldw	r2,-8(fp)
 90bb814:	10c00117 	ldw	r3,4(r2)
 90bb818:	e0bffd17 	ldw	r2,-12(fp)
 90bb81c:	10c0032e 	bgeu	r2,r3,90bb82c <et_send+0x90>
      panic("et_send: prepend");
 90bb820:	01024374 	movhi	r4,2317
 90bb824:	21004104 	addi	r4,r4,260
 90bb828:	90a438c0 	call	90a438c <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 90bb82c:	e0bfff17 	ldw	r2,-4(fp)
 90bb830:	11400104 	addi	r5,r2,4
 90bb834:	e13ffd17 	ldw	r4,-12(fp)
 90bb838:	01800184 	movi	r6,6
 90bb83c:	90823180 	call	9082318 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 90bb840:	e0bffd17 	ldw	r2,-12(fp)
 90bb844:	11000184 	addi	r4,r2,6
 90bb848:	e0bffc17 	ldw	r2,-16(fp)
 90bb84c:	11400517 	ldw	r5,20(r2)
 90bb850:	01800184 	movi	r6,6
 90bb854:	90823180 	call	9082318 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 90bb858:	e0bfff17 	ldw	r2,-4(fp)
 90bb85c:	1080070b 	ldhu	r2,28(r2)
 90bb860:	10bfffcc 	andi	r2,r2,65535
 90bb864:	108000cc 	andi	r2,r2,3
 90bb868:	108000a0 	cmpeqi	r2,r2,2
 90bb86c:	1000041e 	bne	r2,zero,90bb880 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 90bb870:	e0bffd17 	ldw	r2,-12(fp)
 90bb874:	10c00304 	addi	r3,r2,12
 90bb878:	00800204 	movi	r2,8
 90bb87c:	18800005 	stb	r2,0(r3)
 90bb880:	e0bffd17 	ldw	r2,-12(fp)
 90bb884:	10800344 	addi	r2,r2,13
 90bb888:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 90bb88c:	e0bffe17 	ldw	r2,-8(fp)
 90bb890:	10800617 	ldw	r2,24(r2)
 90bb894:	10800417 	ldw	r2,16(r2)
 90bb898:	1005003a 	cmpeq	r2,r2,zero
 90bb89c:	1000071e 	bne	r2,zero,90bb8bc <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 90bb8a0:	e0bffe17 	ldw	r2,-8(fp)
 90bb8a4:	10800617 	ldw	r2,24(r2)
 90bb8a8:	10800417 	ldw	r2,16(r2)
 90bb8ac:	e13ffe17 	ldw	r4,-8(fp)
 90bb8b0:	103ee83a 	callr	r2
 90bb8b4:	e0bffb15 	stw	r2,-20(fp)
 90bb8b8:	00001106 	br	90bb900 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 90bb8bc:	e0bffe17 	ldw	r2,-8(fp)
 90bb8c0:	10800617 	ldw	r2,24(r2)
 90bb8c4:	10c00317 	ldw	r3,12(r2)
 90bb8c8:	e0bffe17 	ldw	r2,-8(fp)
 90bb8cc:	11000617 	ldw	r4,24(r2)
 90bb8d0:	e0bffe17 	ldw	r2,-8(fp)
 90bb8d4:	11400317 	ldw	r5,12(r2)
 90bb8d8:	e0bffe17 	ldw	r2,-8(fp)
 90bb8dc:	11800417 	ldw	r6,16(r2)
 90bb8e0:	183ee83a 	callr	r3
 90bb8e4:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bb8e8:	01000084 	movi	r4,2
 90bb8ec:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bb8f0:	e13ffe17 	ldw	r4,-8(fp)
 90bb8f4:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bb8f8:	01000084 	movi	r4,2
 90bb8fc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 90bb900:	e0bffb17 	ldw	r2,-20(fp)
}
 90bb904:	e037883a 	mov	sp,fp
 90bb908:	dfc00117 	ldw	ra,4(sp)
 90bb90c:	df000017 	ldw	fp,0(sp)
 90bb910:	dec00204 	addi	sp,sp,8
 90bb914:	f800283a 	ret

090bb918 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 90bb918:	defffb04 	addi	sp,sp,-20
 90bb91c:	dfc00415 	stw	ra,16(sp)
 90bb920:	df000315 	stw	fp,12(sp)
 90bb924:	df000304 	addi	fp,sp,12
 90bb928:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 90bb92c:	e0bfff17 	ldw	r2,-4(fp)
 90bb930:	10800417 	ldw	r2,16(r2)
 90bb934:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 90bb938:	e0bfff17 	ldw	r2,-4(fp)
 90bb93c:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bb940:	01000084 	movi	r4,2
 90bb944:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 90bb948:	00000906 	br	90bb970 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 90bb94c:	e0bffe17 	ldw	r2,-8(fp)
 90bb950:	10800017 	ldw	r2,0(r2)
 90bb954:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 90bb958:	e0bffe17 	ldw	r2,-8(fp)
 90bb95c:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 90bb960:	e13ffe17 	ldw	r4,-8(fp)
 90bb964:	90a8bd80 	call	90a8bd8 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 90bb968:	e0bffd17 	ldw	r2,-12(fp)
 90bb96c:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 90bb970:	e0bffe17 	ldw	r2,-8(fp)
 90bb974:	1004c03a 	cmpne	r2,r2,zero
 90bb978:	103ff41e 	bne	r2,zero,90bb94c <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 90bb97c:	e0bfff17 	ldw	r2,-4(fp)
 90bb980:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bb984:	01000084 	movi	r4,2
 90bb988:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
}
 90bb98c:	e037883a 	mov	sp,fp
 90bb990:	dfc00117 	ldw	ra,4(sp)
 90bb994:	df000017 	ldw	fp,0(sp)
 90bb998:	dec00204 	addi	sp,sp,8
 90bb99c:	f800283a 	ret

090bb9a0 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 90bb9a0:	defffc04 	addi	sp,sp,-16
 90bb9a4:	dfc00315 	stw	ra,12(sp)
 90bb9a8:	df000215 	stw	fp,8(sp)
 90bb9ac:	df000204 	addi	fp,sp,8
 90bb9b0:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 90bb9b4:	e0bfff17 	ldw	r2,-4(fp)
 90bb9b8:	10800417 	ldw	r2,16(r2)
 90bb9bc:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 90bb9c0:	00000906 	br	90bb9e8 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 90bb9c4:	e0bffe17 	ldw	r2,-8(fp)
 90bb9c8:	10c00017 	ldw	r3,0(r2)
 90bb9cc:	e0bfff17 	ldw	r2,-4(fp)
 90bb9d0:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 90bb9d4:	e0bffe17 	ldw	r2,-8(fp)
 90bb9d8:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 90bb9dc:	e13ffe17 	ldw	r4,-8(fp)
 90bb9e0:	e17fff17 	ldw	r5,-4(fp)
 90bb9e4:	90bb79c0 	call	90bb79c <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 90bb9e8:	e0bfff17 	ldw	r2,-4(fp)
 90bb9ec:	10800417 	ldw	r2,16(r2)
 90bb9f0:	e0bffe15 	stw	r2,-8(fp)
 90bb9f4:	e0bffe17 	ldw	r2,-8(fp)
 90bb9f8:	1004c03a 	cmpne	r2,r2,zero
 90bb9fc:	103ff11e 	bne	r2,zero,90bb9c4 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 90bba00:	e037883a 	mov	sp,fp
 90bba04:	dfc00117 	ldw	ra,4(sp)
 90bba08:	df000017 	ldw	fp,0(sp)
 90bba0c:	dec00204 	addi	sp,sp,8
 90bba10:	f800283a 	ret

090bba14 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 90bba14:	defff304 	addi	sp,sp,-52
 90bba18:	dfc00c15 	stw	ra,48(sp)
 90bba1c:	df000b15 	stw	fp,44(sp)
 90bba20:	df000b04 	addi	fp,sp,44
 90bba24:	e13ffd15 	stw	r4,-12(fp)
 90bba28:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 90bba2c:	e0bffd17 	ldw	r2,-12(fp)
 90bba30:	10800617 	ldw	r2,24(r2)
 90bba34:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 90bba38:	e0bffd17 	ldw	r2,-12(fp)
 90bba3c:	10800617 	ldw	r2,24(r2)
 90bba40:	10802717 	ldw	r2,156(r2)
 90bba44:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 90bba48:	e0bffe17 	ldw	r2,-8(fp)
 90bba4c:	10bfffe0 	cmpeqi	r2,r2,-1
 90bba50:	10001b1e 	bne	r2,zero,90bbac0 <send_arp+0xac>
 90bba54:	e0bff917 	ldw	r2,-28(fp)
 90bba58:	10800c17 	ldw	r2,48(r2)
 90bba5c:	0086303a 	nor	r3,zero,r2
 90bba60:	e0bffe17 	ldw	r2,-8(fp)
 90bba64:	1886703a 	and	r3,r3,r2
 90bba68:	e0bff917 	ldw	r2,-28(fp)
 90bba6c:	10800c17 	ldw	r2,48(r2)
 90bba70:	0084303a 	nor	r2,zero,r2
 90bba74:	18801226 	beq	r3,r2,90bbac0 <send_arp+0xac>
 90bba78:	e0bffe17 	ldw	r2,-8(fp)
 90bba7c:	1004d63a 	srli	r2,r2,24
 90bba80:	10c03fcc 	andi	r3,r2,255
 90bba84:	e0bffe17 	ldw	r2,-8(fp)
 90bba88:	1004d23a 	srli	r2,r2,8
 90bba8c:	10bfc00c 	andi	r2,r2,65280
 90bba90:	1886b03a 	or	r3,r3,r2
 90bba94:	e0bffe17 	ldw	r2,-8(fp)
 90bba98:	10bfc00c 	andi	r2,r2,65280
 90bba9c:	1004923a 	slli	r2,r2,8
 90bbaa0:	1886b03a 	or	r3,r3,r2
 90bbaa4:	e0bffe17 	ldw	r2,-8(fp)
 90bbaa8:	10803fcc 	andi	r2,r2,255
 90bbaac:	1004963a 	slli	r2,r2,24
 90bbab0:	1884b03a 	or	r2,r3,r2
 90bbab4:	10fc002c 	andhi	r3,r2,61440
 90bbab8:	00b80034 	movhi	r2,57344
 90bbabc:	1880441e 	bne	r3,r2,90bbbd0 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 90bbac0:	e0bffd17 	ldw	r2,-12(fp)
 90bbac4:	11400617 	ldw	r5,24(r2)
 90bbac8:	e13ffe17 	ldw	r4,-8(fp)
 90bbacc:	90bc0a00 	call	90bc0a0 <make_arp_entry>
 90bbad0:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 90bbad4:	e0bffb17 	ldw	r2,-20(fp)
 90bbad8:	10c00104 	addi	r3,r2,4
 90bbadc:	00bfffc4 	movi	r2,-1
 90bbae0:	18800005 	stb	r2,0(r3)
 90bbae4:	00bfffc4 	movi	r2,-1
 90bbae8:	18800045 	stb	r2,1(r3)
 90bbaec:	00bfffc4 	movi	r2,-1
 90bbaf0:	18800085 	stb	r2,2(r3)
 90bbaf4:	00bfffc4 	movi	r2,-1
 90bbaf8:	188000c5 	stb	r2,3(r3)
 90bbafc:	00bfffc4 	movi	r2,-1
 90bbb00:	18800105 	stb	r2,4(r3)
 90bbb04:	00bfffc4 	movi	r2,-1
 90bbb08:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 90bbb0c:	e0bffd17 	ldw	r2,-12(fp)
 90bbb10:	10800617 	ldw	r2,24(r2)
 90bbb14:	10802b17 	ldw	r2,172(r2)
 90bbb18:	1005003a 	cmpeq	r2,r2,zero
 90bbb1c:	1000271e 	bne	r2,zero,90bbbbc <send_arp+0x1a8>
 90bbb20:	e0bffe17 	ldw	r2,-8(fp)
 90bbb24:	1004d63a 	srli	r2,r2,24
 90bbb28:	10c03fcc 	andi	r3,r2,255
 90bbb2c:	e0bffe17 	ldw	r2,-8(fp)
 90bbb30:	1004d23a 	srli	r2,r2,8
 90bbb34:	10bfc00c 	andi	r2,r2,65280
 90bbb38:	1886b03a 	or	r3,r3,r2
 90bbb3c:	e0bffe17 	ldw	r2,-8(fp)
 90bbb40:	10bfc00c 	andi	r2,r2,65280
 90bbb44:	1004923a 	slli	r2,r2,8
 90bbb48:	1886b03a 	or	r3,r3,r2
 90bbb4c:	e0bffe17 	ldw	r2,-8(fp)
 90bbb50:	10803fcc 	andi	r2,r2,255
 90bbb54:	1004963a 	slli	r2,r2,24
 90bbb58:	1884b03a 	or	r2,r3,r2
 90bbb5c:	10fc002c 	andhi	r3,r2,61440
 90bbb60:	00b80034 	movhi	r2,57344
 90bbb64:	1880151e 	bne	r3,r2,90bbbbc <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 90bbb68:	e0bffe17 	ldw	r2,-8(fp)
 90bbb6c:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 90bbb70:	e0fffb17 	ldw	r3,-20(fp)
 90bbb74:	00800044 	movi	r2,1
 90bbb78:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 90bbb7c:	e0bffb17 	ldw	r2,-20(fp)
 90bbb80:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 90bbb84:	e0fffb17 	ldw	r3,-20(fp)
 90bbb88:	00801784 	movi	r2,94
 90bbb8c:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 90bbb90:	e0bffc43 	ldbu	r2,-15(fp)
 90bbb94:	10801fcc 	andi	r2,r2,127
 90bbb98:	1007883a 	mov	r3,r2
 90bbb9c:	e0bffb17 	ldw	r2,-20(fp)
 90bbba0:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 90bbba4:	e0fffc83 	ldbu	r3,-14(fp)
 90bbba8:	e0bffb17 	ldw	r2,-20(fp)
 90bbbac:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 90bbbb0:	e0fffcc3 	ldbu	r3,-13(fp)
 90bbbb4:	e0bffb17 	ldw	r2,-20(fp)
 90bbbb8:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 90bbbbc:	e13ffd17 	ldw	r4,-12(fp)
 90bbbc0:	e17ffb17 	ldw	r5,-20(fp)
 90bbbc4:	90bb79c0 	call	90bb79c <et_send>
 90bbbc8:	e0bfff15 	stw	r2,-4(fp)
 90bbbcc:	0000b106 	br	90bbe94 <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 90bbbd0:	e0bffd17 	ldw	r2,-12(fp)
 90bbbd4:	10c00717 	ldw	r3,28(r2)
 90bbbd8:	e0bffd17 	ldw	r2,-12(fp)
 90bbbdc:	10800617 	ldw	r2,24(r2)
 90bbbe0:	10800a17 	ldw	r2,40(r2)
 90bbbe4:	18800e1e 	bne	r3,r2,90bbc20 <send_arp+0x20c>
 90bbbe8:	e0bffd17 	ldw	r2,-12(fp)
 90bbbec:	10800717 	ldw	r2,28(r2)
 90bbbf0:	10803fcc 	andi	r2,r2,255
 90bbbf4:	10801fe0 	cmpeqi	r2,r2,127
 90bbbf8:	1000091e 	bne	r2,zero,90bbc20 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bbbfc:	01000084 	movi	r4,2
 90bbc00:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bbc04:	e13ffd17 	ldw	r4,-12(fp)
 90bbc08:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bbc0c:	01000084 	movi	r4,2
 90bbc10:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 90bbc14:	00bff7c4 	movi	r2,-33
 90bbc18:	e0bfff15 	stw	r2,-4(fp)
 90bbc1c:	00009d06 	br	90bbe94 <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 90bbc20:	01000084 	movi	r4,2
 90bbc24:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 90bbc28:	01000c04 	movi	r4,48
 90bbc2c:	90a88440 	call	90a8844 <pk_alloc>
 90bbc30:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 90bbc34:	e0bff617 	ldw	r2,-40(fp)
 90bbc38:	1004c03a 	cmpne	r2,r2,zero
 90bbc3c:	1000071e 	bne	r2,zero,90bbc5c <send_arp+0x248>
   {
      pk_free(pkt);
 90bbc40:	e13ffd17 	ldw	r4,-12(fp)
 90bbc44:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bbc48:	01000084 	movi	r4,2
 90bbc4c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 90bbc50:	00bffa84 	movi	r2,-22
 90bbc54:	e0bfff15 	stw	r2,-4(fp)
 90bbc58:	00008e06 	br	90bbe94 <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bbc5c:	01000084 	movi	r4,2
 90bbc60:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 90bbc64:	e0bff617 	ldw	r2,-40(fp)
 90bbc68:	10c00117 	ldw	r3,4(r2)
 90bbc6c:	e0bff617 	ldw	r2,-40(fp)
 90bbc70:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 90bbc74:	e0fff617 	ldw	r3,-40(fp)
 90bbc78:	00800c04 	movi	r2,48
 90bbc7c:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 90bbc80:	e0bffd17 	ldw	r2,-12(fp)
 90bbc84:	10c00617 	ldw	r3,24(r2)
 90bbc88:	e0bff617 	ldw	r2,-40(fp)
 90bbc8c:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 90bbc90:	e0bffd17 	ldw	r2,-12(fp)
 90bbc94:	11400617 	ldw	r5,24(r2)
 90bbc98:	e13ffe17 	ldw	r4,-8(fp)
 90bbc9c:	90bc0a00 	call	90bc0a0 <make_arp_entry>
 90bbca0:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 90bbca4:	e0fffb17 	ldw	r3,-20(fp)
 90bbca8:	e0bffd17 	ldw	r2,-12(fp)
 90bbcac:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 90bbcb0:	e0bff617 	ldw	r2,-40(fp)
 90bbcb4:	10800117 	ldw	r2,4(r2)
 90bbcb8:	10800084 	addi	r2,r2,2
 90bbcbc:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 90bbcc0:	e0bff617 	ldw	r2,-40(fp)
 90bbcc4:	10800117 	ldw	r2,4(r2)
 90bbcc8:	10800404 	addi	r2,r2,16
 90bbccc:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bbcd0:	e0fff817 	ldw	r3,-32(fp)
 90bbcd4:	00804004 	movi	r2,256
 90bbcd8:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 90bbcdc:	e0fff817 	ldw	r3,-32(fp)
 90bbce0:	00800204 	movi	r2,8
 90bbce4:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 90bbce8:	e0fff817 	ldw	r3,-32(fp)
 90bbcec:	00800184 	movi	r2,6
 90bbcf0:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 90bbcf4:	e0fff817 	ldw	r3,-32(fp)
 90bbcf8:	00800104 	movi	r2,4
 90bbcfc:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 90bbd00:	e0fff817 	ldw	r3,-32(fp)
 90bbd04:	00804004 	movi	r2,256
 90bbd08:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 90bbd0c:	e0fff817 	ldw	r3,-32(fp)
 90bbd10:	e0bffe17 	ldw	r2,-8(fp)
 90bbd14:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 90bbd18:	e0bffd17 	ldw	r2,-12(fp)
 90bbd1c:	10800617 	ldw	r2,24(r2)
 90bbd20:	10c00a17 	ldw	r3,40(r2)
 90bbd24:	e0bff817 	ldw	r2,-32(fp)
 90bbd28:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 90bbd2c:	e0bff817 	ldw	r2,-32(fp)
 90bbd30:	11000204 	addi	r4,r2,8
 90bbd34:	e0bff717 	ldw	r2,-36(fp)
 90bbd38:	11400517 	ldw	r5,20(r2)
 90bbd3c:	01800184 	movi	r6,6
 90bbd40:	90823180 	call	9082318 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 90bbd44:	e0fffa17 	ldw	r3,-24(fp)
 90bbd48:	00bfffc4 	movi	r2,-1
 90bbd4c:	18800005 	stb	r2,0(r3)
 90bbd50:	00bfffc4 	movi	r2,-1
 90bbd54:	18800045 	stb	r2,1(r3)
 90bbd58:	00bfffc4 	movi	r2,-1
 90bbd5c:	18800085 	stb	r2,2(r3)
 90bbd60:	00bfffc4 	movi	r2,-1
 90bbd64:	188000c5 	stb	r2,3(r3)
 90bbd68:	00bfffc4 	movi	r2,-1
 90bbd6c:	18800105 	stb	r2,4(r3)
 90bbd70:	00bfffc4 	movi	r2,-1
 90bbd74:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 90bbd78:	e0bffa17 	ldw	r2,-24(fp)
 90bbd7c:	11000184 	addi	r4,r2,6
 90bbd80:	e0bff717 	ldw	r2,-36(fp)
 90bbd84:	11400517 	ldw	r5,20(r2)
 90bbd88:	01800184 	movi	r6,6
 90bbd8c:	90823180 	call	9082318 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 90bbd90:	e0bffa17 	ldw	r2,-24(fp)
 90bbd94:	10c00304 	addi	r3,r2,12
 90bbd98:	00800204 	movi	r2,8
 90bbd9c:	18800005 	stb	r2,0(r3)
 90bbda0:	e0bffa17 	ldw	r2,-24(fp)
 90bbda4:	10c00344 	addi	r3,r2,13
 90bbda8:	00800184 	movi	r2,6
 90bbdac:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bbdb0:	e0bff817 	ldw	r2,-32(fp)
 90bbdb4:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 90bbdb8:	e0bff517 	ldw	r2,-44(fp)
 90bbdbc:	11000204 	addi	r4,r2,8
 90bbdc0:	e0bff817 	ldw	r2,-32(fp)
 90bbdc4:	11400204 	addi	r5,r2,8
 90bbdc8:	01800184 	movi	r6,6
 90bbdcc:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 90bbdd0:	e0bff517 	ldw	r2,-44(fp)
 90bbdd4:	10800204 	addi	r2,r2,8
 90bbdd8:	11000184 	addi	r4,r2,6
 90bbddc:	e0bff817 	ldw	r2,-32(fp)
 90bbde0:	11400404 	addi	r5,r2,16
 90bbde4:	01800104 	movi	r6,4
 90bbde8:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 90bbdec:	e0bff517 	ldw	r2,-44(fp)
 90bbdf0:	10800204 	addi	r2,r2,8
 90bbdf4:	11000284 	addi	r4,r2,10
 90bbdf8:	e0bff817 	ldw	r2,-32(fp)
 90bbdfc:	11400504 	addi	r5,r2,20
 90bbe00:	01800184 	movi	r6,6
 90bbe04:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 90bbe08:	e0bff517 	ldw	r2,-44(fp)
 90bbe0c:	10800204 	addi	r2,r2,8
 90bbe10:	11000404 	addi	r4,r2,16
 90bbe14:	e0bff817 	ldw	r2,-32(fp)
 90bbe18:	11400704 	addi	r5,r2,28
 90bbe1c:	01800104 	movi	r6,4
 90bbe20:	90823180 	call	9082318 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 90bbe24:	e0bff917 	ldw	r2,-28(fp)
 90bbe28:	10800417 	ldw	r2,16(r2)
 90bbe2c:	1005003a 	cmpeq	r2,r2,zero
 90bbe30:	1000051e 	bne	r2,zero,90bbe48 <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 90bbe34:	e0bff917 	ldw	r2,-28(fp)
 90bbe38:	10800417 	ldw	r2,16(r2)
 90bbe3c:	e13ff617 	ldw	r4,-40(fp)
 90bbe40:	103ee83a 	callr	r2
 90bbe44:	00000e06 	br	90bbe80 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 90bbe48:	e0bff917 	ldw	r2,-28(fp)
 90bbe4c:	10c00317 	ldw	r3,12(r2)
 90bbe50:	e0bff617 	ldw	r2,-40(fp)
 90bbe54:	11000617 	ldw	r4,24(r2)
 90bbe58:	e0bff617 	ldw	r2,-40(fp)
 90bbe5c:	11400117 	ldw	r5,4(r2)
 90bbe60:	01800c04 	movi	r6,48
 90bbe64:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bbe68:	01000084 	movi	r4,2
 90bbe6c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 90bbe70:	e13ff617 	ldw	r4,-40(fp)
 90bbe74:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bbe78:	01000084 	movi	r4,2
 90bbe7c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 90bbe80:	d0a0c217 	ldw	r2,-31992(gp)
 90bbe84:	10800044 	addi	r2,r2,1
 90bbe88:	d0a0c215 	stw	r2,-31992(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 90bbe8c:	00800044 	movi	r2,1
 90bbe90:	e0bfff15 	stw	r2,-4(fp)
 90bbe94:	e0bfff17 	ldw	r2,-4(fp)
}
 90bbe98:	e037883a 	mov	sp,fp
 90bbe9c:	dfc00117 	ldw	ra,4(sp)
 90bbea0:	df000017 	ldw	fp,0(sp)
 90bbea4:	dec00204 	addi	sp,sp,8
 90bbea8:	f800283a 	ret

090bbeac <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 90bbeac:	defff604 	addi	sp,sp,-40
 90bbeb0:	dfc00915 	stw	ra,36(sp)
 90bbeb4:	df000815 	stw	fp,32(sp)
 90bbeb8:	df000804 	addi	fp,sp,32
 90bbebc:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 90bbec0:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 90bbec4:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 90bbec8:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 90bbecc:	00824374 	movhi	r2,2317
 90bbed0:	108c4204 	addi	r2,r2,12552
 90bbed4:	10800017 	ldw	r2,0(r2)
 90bbed8:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bbedc:	008243b4 	movhi	r2,2318
 90bbee0:	10b61f04 	addi	r2,r2,-10116
 90bbee4:	e0bffc15 	stw	r2,-16(fp)
 90bbee8:	00005306 	br	90bc038 <find_oldest_arp+0x18c>
   {
      /* age out old, pending entries */
      if (tp->pending)
 90bbeec:	e0bffc17 	ldw	r2,-16(fp)
 90bbef0:	10800417 	ldw	r2,16(r2)
 90bbef4:	1005003a 	cmpeq	r2,r2,zero
 90bbef8:	1000141e 	bne	r2,zero,90bbf4c <find_oldest_arp+0xa0>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 90bbefc:	e0bffc17 	ldw	r2,-16(fp)
 90bbf00:	10c00517 	ldw	r3,20(r2)
 90bbf04:	e0bff817 	ldw	r2,-32(fp)
 90bbf08:	10c9c83a 	sub	r4,r2,r3
 90bbf0c:	908c0380 	call	908c038 <__floatunsidf>
 90bbf10:	100b883a 	mov	r5,r2
 90bbf14:	180d883a 	mov	r6,r3
 90bbf18:	2809883a 	mov	r4,r5
 90bbf1c:	300b883a 	mov	r5,r6
 90bbf20:	000d883a 	mov	r6,zero
 90bbf24:	01d01674 	movhi	r7,16473
 90bbf28:	908bcd00 	call	908bcd0 <__gtdf2>
 90bbf2c:	10800048 	cmpgei	r2,r2,1
 90bbf30:	1000011e 	bne	r2,zero,90bbf38 <find_oldest_arp+0x8c>
 90bbf34:	00002206 	br	90bbfc0 <find_oldest_arp+0x114>
         {
            arp_free_pending(tp);   /* free pending packets */
 90bbf38:	e13ffc17 	ldw	r4,-16(fp)
 90bbf3c:	90bb9180 	call	90bb918 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bbf40:	e0bffc17 	ldw	r2,-16(fp)
 90bbf44:	10000015 	stw	zero,0(r2)
 90bbf48:	00001d06 	br	90bbfc0 <find_oldest_arp+0x114>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 90bbf4c:	e0bffc17 	ldw	r2,-16(fp)
 90bbf50:	10800017 	ldw	r2,0(r2)
 90bbf54:	1005003a 	cmpeq	r2,r2,zero
 90bbf58:	1000191e 	bne	r2,zero,90bbfc0 <find_oldest_arp+0x114>
 90bbf5c:	e0bffc17 	ldw	r2,-16(fp)
 90bbf60:	10c00517 	ldw	r3,20(r2)
 90bbf64:	e0bff817 	ldw	r2,-32(fp)
 90bbf68:	10c5c83a 	sub	r2,r2,r3
 90bbf6c:	1007883a 	mov	r3,r2
 90bbf70:	d0a04f17 	ldw	r2,-32452(gp)
 90bbf74:	18801216 	blt	r3,r2,90bbfc0 <find_oldest_arp+0x114>
 90bbf78:	e0bffc17 	ldw	r2,-16(fp)
 90bbf7c:	10c00617 	ldw	r3,24(r2)
 90bbf80:	e0bff817 	ldw	r2,-32(fp)
 90bbf84:	10c5c83a 	sub	r2,r2,r3
 90bbf88:	1009883a 	mov	r4,r2
 90bbf8c:	908be680 	call	908be68 <__floatsidf>
 90bbf90:	100b883a 	mov	r5,r2
 90bbf94:	180d883a 	mov	r6,r3
 90bbf98:	2809883a 	mov	r4,r5
 90bbf9c:	300b883a 	mov	r5,r6
 90bbfa0:	000d883a 	mov	r6,zero
 90bbfa4:	01d01674 	movhi	r7,16473
 90bbfa8:	908bd580 	call	908bd58 <__gedf2>
 90bbfac:	1004403a 	cmpge	r2,r2,zero
 90bbfb0:	1000011e 	bne	r2,zero,90bbfb8 <find_oldest_arp+0x10c>
 90bbfb4:	00000206 	br	90bbfc0 <find_oldest_arp+0x114>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bbfb8:	e0bffc17 	ldw	r2,-16(fp)
 90bbfbc:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 90bbfc0:	e0bffc17 	ldw	r2,-16(fp)
 90bbfc4:	10c00017 	ldw	r3,0(r2)
 90bbfc8:	e0bffd17 	ldw	r2,-12(fp)
 90bbfcc:	1880031e 	bne	r3,r2,90bbfdc <find_oldest_arp+0x130>
      {
         exact = tp;
 90bbfd0:	e0bffc17 	ldw	r2,-16(fp)
 90bbfd4:	e0bffb15 	stw	r2,-20(fp)
 90bbfd8:	00001406 	br	90bc02c <find_oldest_arp+0x180>
      }
      else if (tp->t_pro_addr != 0)
 90bbfdc:	e0bffc17 	ldw	r2,-16(fp)
 90bbfe0:	10800017 	ldw	r2,0(r2)
 90bbfe4:	1005003a 	cmpeq	r2,r2,zero
 90bbfe8:	10000b1e 	bne	r2,zero,90bc018 <find_oldest_arp+0x16c>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 90bbfec:	e0bffa17 	ldw	r2,-24(fp)
 90bbff0:	1005003a 	cmpeq	r2,r2,zero
 90bbff4:	1000051e 	bne	r2,zero,90bc00c <find_oldest_arp+0x160>
 90bbff8:	e0bffc17 	ldw	r2,-16(fp)
 90bbffc:	10c00617 	ldw	r3,24(r2)
 90bc000:	e0bffa17 	ldw	r2,-24(fp)
 90bc004:	10800617 	ldw	r2,24(r2)
 90bc008:	1880082e 	bgeu	r3,r2,90bc02c <find_oldest_arp+0x180>
            oldest = tp;
 90bc00c:	e0bffc17 	ldw	r2,-16(fp)
 90bc010:	e0bffa15 	stw	r2,-24(fp)
 90bc014:	00000506 	br	90bc02c <find_oldest_arp+0x180>
      }
      else if (!empty)
 90bc018:	e0bff917 	ldw	r2,-28(fp)
 90bc01c:	1004c03a 	cmpne	r2,r2,zero
 90bc020:	1000021e 	bne	r2,zero,90bc02c <find_oldest_arp+0x180>
         empty = tp;          /* grab first empty slot */
 90bc024:	e0bffc17 	ldw	r2,-16(fp)
 90bc028:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bc02c:	e0bffc17 	ldw	r2,-16(fp)
 90bc030:	10800804 	addi	r2,r2,32
 90bc034:	e0bffc15 	stw	r2,-16(fp)
 90bc038:	00c243b4 	movhi	r3,2318
 90bc03c:	18f65f04 	addi	r3,r3,-9860
 90bc040:	e0bffc17 	ldw	r2,-16(fp)
 90bc044:	10ffa936 	bltu	r2,r3,90bbeec <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 90bc048:	e0bffb17 	ldw	r2,-20(fp)
 90bc04c:	1004c03a 	cmpne	r2,r2,zero
 90bc050:	10000b1e 	bne	r2,zero,90bc080 <find_oldest_arp+0x1d4>
 90bc054:	e0bff917 	ldw	r2,-28(fp)
 90bc058:	1005003a 	cmpeq	r2,r2,zero
 90bc05c:	1000031e 	bne	r2,zero,90bc06c <find_oldest_arp+0x1c0>
 90bc060:	e0bff917 	ldw	r2,-28(fp)
 90bc064:	e0bffe15 	stw	r2,-8(fp)
 90bc068:	00000206 	br	90bc074 <find_oldest_arp+0x1c8>
 90bc06c:	e0bffa17 	ldw	r2,-24(fp)
 90bc070:	e0bffe15 	stw	r2,-8(fp)
 90bc074:	e0bffe17 	ldw	r2,-8(fp)
 90bc078:	e0bfff15 	stw	r2,-4(fp)
 90bc07c:	00000206 	br	90bc088 <find_oldest_arp+0x1dc>
 90bc080:	e0bffb17 	ldw	r2,-20(fp)
 90bc084:	e0bfff15 	stw	r2,-4(fp)
 90bc088:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc08c:	e037883a 	mov	sp,fp
 90bc090:	dfc00117 	ldw	ra,4(sp)
 90bc094:	df000017 	ldw	fp,0(sp)
 90bc098:	dec00204 	addi	sp,sp,8
 90bc09c:	f800283a 	ret

090bc0a0 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 90bc0a0:	defffa04 	addi	sp,sp,-24
 90bc0a4:	dfc00515 	stw	ra,20(sp)
 90bc0a8:	df000415 	stw	fp,16(sp)
 90bc0ac:	df000404 	addi	fp,sp,16
 90bc0b0:	e13ffe15 	stw	r4,-8(fp)
 90bc0b4:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 90bc0b8:	00824374 	movhi	r2,2317
 90bc0bc:	108c4204 	addi	r2,r2,12552
 90bc0c0:	10800017 	ldw	r2,0(r2)
 90bc0c4:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 90bc0c8:	e13ffe17 	ldw	r4,-8(fp)
 90bc0cc:	90bbeac0 	call	90bbeac <find_oldest_arp>
 90bc0d0:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 90bc0d4:	e0bffd17 	ldw	r2,-12(fp)
 90bc0d8:	10800417 	ldw	r2,16(r2)
 90bc0dc:	1005003a 	cmpeq	r2,r2,zero
 90bc0e0:	1000061e 	bne	r2,zero,90bc0fc <make_arp_entry+0x5c>
 90bc0e4:	e0bffd17 	ldw	r2,-12(fp)
 90bc0e8:	10c00017 	ldw	r3,0(r2)
 90bc0ec:	e0bffe17 	ldw	r2,-8(fp)
 90bc0f0:	18800226 	beq	r3,r2,90bc0fc <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 90bc0f4:	e13ffd17 	ldw	r4,-12(fp)
 90bc0f8:	90bb9180 	call	90bb918 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 90bc0fc:	e0fffd17 	ldw	r3,-12(fp)
 90bc100:	e0bffe17 	ldw	r2,-8(fp)
 90bc104:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 90bc108:	e0fffd17 	ldw	r3,-12(fp)
 90bc10c:	e0bfff17 	ldw	r2,-4(fp)
 90bc110:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 90bc114:	e0bffd17 	ldw	r2,-12(fp)
 90bc118:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 90bc11c:	e0bffd17 	ldw	r2,-12(fp)
 90bc120:	10800104 	addi	r2,r2,4
 90bc124:	10000005 	stb	zero,0(r2)
 90bc128:	10000045 	stb	zero,1(r2)
 90bc12c:	10000085 	stb	zero,2(r2)
 90bc130:	100000c5 	stb	zero,3(r2)
 90bc134:	10000105 	stb	zero,4(r2)
 90bc138:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 90bc13c:	e0fffd17 	ldw	r3,-12(fp)
 90bc140:	e0bffc17 	ldw	r2,-16(fp)
 90bc144:	18800615 	stw	r2,24(r3)
 90bc148:	e0bffd17 	ldw	r2,-12(fp)
 90bc14c:	10c00617 	ldw	r3,24(r2)
 90bc150:	e0bffd17 	ldw	r2,-12(fp)
 90bc154:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 90bc158:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc15c:	1004c03a 	cmpne	r2,r2,zero
 90bc160:	1000071e 	bne	r2,zero,90bc180 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 90bc164:	01024334 	movhi	r4,2316
 90bc168:	21321d04 	addi	r4,r4,-14220
 90bc16c:	0149c404 	movi	r5,10000
 90bc170:	000d883a 	mov	r6,zero
 90bc174:	90bb3780 	call	90bb378 <in_timerset>
 90bc178:	d0a0bf15 	stw	r2,-32004(gp)
 90bc17c:	00000706 	br	90bc19c <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 90bc180:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc184:	1009883a 	mov	r4,r2
 90bc188:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc18c:	10c00217 	ldw	r3,8(r2)
 90bc190:	e0bffc17 	ldw	r2,-16(fp)
 90bc194:	1885883a 	add	r2,r3,r2
 90bc198:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 90bc19c:	e0bffd17 	ldw	r2,-12(fp)
}
 90bc1a0:	e037883a 	mov	sp,fp
 90bc1a4:	dfc00117 	ldw	ra,4(sp)
 90bc1a8:	df000017 	ldw	fp,0(sp)
 90bc1ac:	dec00204 	addi	sp,sp,8
 90bc1b0:	f800283a 	ret

090bc1b4 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 90bc1b4:	defff704 	addi	sp,sp,-36
 90bc1b8:	dfc00815 	stw	ra,32(sp)
 90bc1bc:	df000715 	stw	fp,28(sp)
 90bc1c0:	df000704 	addi	fp,sp,28
 90bc1c4:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc1c8:	01000084 	movi	r4,2
 90bc1cc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 90bc1d0:	01000c04 	movi	r4,48
 90bc1d4:	90a88440 	call	90a8844 <pk_alloc>
 90bc1d8:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc1dc:	01000084 	movi	r4,2
 90bc1e0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 90bc1e4:	e0bffe17 	ldw	r2,-8(fp)
 90bc1e8:	1004c03a 	cmpne	r2,r2,zero
 90bc1ec:	1000021e 	bne	r2,zero,90bc1f8 <arpReply+0x44>
   {
      dtrap();
 90bc1f0:	90a94880 	call	90a9488 <dtrap>
      return;
 90bc1f4:	00008f06 	br	90bc434 <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 90bc1f8:	e0bfff17 	ldw	r2,-4(fp)
 90bc1fc:	10c00617 	ldw	r3,24(r2)
 90bc200:	e0bffe17 	ldw	r2,-8(fp)
 90bc204:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 90bc208:	e0bfff17 	ldw	r2,-4(fp)
 90bc20c:	10800317 	ldw	r2,12(r2)
 90bc210:	10bffc84 	addi	r2,r2,-14
 90bc214:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 90bc218:	e0bffe17 	ldw	r2,-8(fp)
 90bc21c:	10800117 	ldw	r2,4(r2)
 90bc220:	10800084 	addi	r2,r2,2
 90bc224:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 90bc228:	e0bffb17 	ldw	r2,-20(fp)
 90bc22c:	10c00304 	addi	r3,r2,12
 90bc230:	00800204 	movi	r2,8
 90bc234:	18800005 	stb	r2,0(r3)
 90bc238:	e0bffb17 	ldw	r2,-20(fp)
 90bc23c:	10c00344 	addi	r3,r2,13
 90bc240:	00800184 	movi	r2,6
 90bc244:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 90bc248:	e0bfff17 	ldw	r2,-4(fp)
 90bc24c:	10800317 	ldw	r2,12(r2)
 90bc250:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 90bc254:	e0bffe17 	ldw	r2,-8(fp)
 90bc258:	10800117 	ldw	r2,4(r2)
 90bc25c:	10800404 	addi	r2,r2,16
 90bc260:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 90bc264:	e0fffe17 	ldw	r3,-8(fp)
 90bc268:	00800c04 	movi	r2,48
 90bc26c:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bc270:	e0fffc17 	ldw	r3,-16(fp)
 90bc274:	00804004 	movi	r2,256
 90bc278:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 90bc27c:	e0fffc17 	ldw	r3,-16(fp)
 90bc280:	00800204 	movi	r2,8
 90bc284:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 90bc288:	e0fffc17 	ldw	r3,-16(fp)
 90bc28c:	00800184 	movi	r2,6
 90bc290:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 90bc294:	e0fffc17 	ldw	r3,-16(fp)
 90bc298:	00800104 	movi	r2,4
 90bc29c:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 90bc2a0:	e0fffc17 	ldw	r3,-16(fp)
 90bc2a4:	00808004 	movi	r2,512
 90bc2a8:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 90bc2ac:	e0bffd17 	ldw	r2,-12(fp)
 90bc2b0:	10c00417 	ldw	r3,16(r2)
 90bc2b4:	e0bffc17 	ldw	r2,-16(fp)
 90bc2b8:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 90bc2bc:	e0bffd17 	ldw	r2,-12(fp)
 90bc2c0:	10c00717 	ldw	r3,28(r2)
 90bc2c4:	e0bffc17 	ldw	r2,-16(fp)
 90bc2c8:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 90bc2cc:	e0bffc17 	ldw	r2,-16(fp)
 90bc2d0:	11000504 	addi	r4,r2,20
 90bc2d4:	e0bffd17 	ldw	r2,-12(fp)
 90bc2d8:	11400204 	addi	r5,r2,8
 90bc2dc:	01800184 	movi	r6,6
 90bc2e0:	90823180 	call	9082318 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 90bc2e4:	e0bffc17 	ldw	r2,-16(fp)
 90bc2e8:	11000204 	addi	r4,r2,8
 90bc2ec:	e0bffe17 	ldw	r2,-8(fp)
 90bc2f0:	10800617 	ldw	r2,24(r2)
 90bc2f4:	10802717 	ldw	r2,156(r2)
 90bc2f8:	11400517 	ldw	r5,20(r2)
 90bc2fc:	01800184 	movi	r6,6
 90bc300:	90823180 	call	9082318 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 90bc304:	e0bffa17 	ldw	r2,-24(fp)
 90bc308:	11400184 	addi	r5,r2,6
 90bc30c:	e13ffb17 	ldw	r4,-20(fp)
 90bc310:	01800184 	movi	r6,6
 90bc314:	90823180 	call	9082318 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 90bc318:	e0bffb17 	ldw	r2,-20(fp)
 90bc31c:	11000184 	addi	r4,r2,6
 90bc320:	e0bffe17 	ldw	r2,-8(fp)
 90bc324:	10800617 	ldw	r2,24(r2)
 90bc328:	10802717 	ldw	r2,156(r2)
 90bc32c:	11400517 	ldw	r5,20(r2)
 90bc330:	01800184 	movi	r6,6
 90bc334:	90823180 	call	9082318 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 90bc338:	e0bffc17 	ldw	r2,-16(fp)
 90bc33c:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 90bc340:	e0bff917 	ldw	r2,-28(fp)
 90bc344:	11000204 	addi	r4,r2,8
 90bc348:	e0bffc17 	ldw	r2,-16(fp)
 90bc34c:	11400204 	addi	r5,r2,8
 90bc350:	01800184 	movi	r6,6
 90bc354:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 90bc358:	e0bff917 	ldw	r2,-28(fp)
 90bc35c:	10800204 	addi	r2,r2,8
 90bc360:	11000184 	addi	r4,r2,6
 90bc364:	e0bffc17 	ldw	r2,-16(fp)
 90bc368:	11400404 	addi	r5,r2,16
 90bc36c:	01800104 	movi	r6,4
 90bc370:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 90bc374:	e0bff917 	ldw	r2,-28(fp)
 90bc378:	10800204 	addi	r2,r2,8
 90bc37c:	11000284 	addi	r4,r2,10
 90bc380:	e0bffc17 	ldw	r2,-16(fp)
 90bc384:	11400504 	addi	r5,r2,20
 90bc388:	01800184 	movi	r6,6
 90bc38c:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 90bc390:	e0bff917 	ldw	r2,-28(fp)
 90bc394:	10800204 	addi	r2,r2,8
 90bc398:	11000404 	addi	r4,r2,16
 90bc39c:	e0bffc17 	ldw	r2,-16(fp)
 90bc3a0:	11400704 	addi	r5,r2,28
 90bc3a4:	01800104 	movi	r6,4
 90bc3a8:	90823180 	call	9082318 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 90bc3ac:	e0bffe17 	ldw	r2,-8(fp)
 90bc3b0:	10800617 	ldw	r2,24(r2)
 90bc3b4:	10800417 	ldw	r2,16(r2)
 90bc3b8:	1005003a 	cmpeq	r2,r2,zero
 90bc3bc:	10000a1e 	bne	r2,zero,90bc3e8 <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 90bc3c0:	e0bffe17 	ldw	r2,-8(fp)
 90bc3c4:	10c00117 	ldw	r3,4(r2)
 90bc3c8:	e0bffe17 	ldw	r2,-8(fp)
 90bc3cc:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 90bc3d0:	e0bffe17 	ldw	r2,-8(fp)
 90bc3d4:	10800617 	ldw	r2,24(r2)
 90bc3d8:	10800417 	ldw	r2,16(r2)
 90bc3dc:	e13ffe17 	ldw	r4,-8(fp)
 90bc3e0:	103ee83a 	callr	r2
 90bc3e4:	00001006 	br	90bc428 <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 90bc3e8:	e0bffe17 	ldw	r2,-8(fp)
 90bc3ec:	10800617 	ldw	r2,24(r2)
 90bc3f0:	10c00317 	ldw	r3,12(r2)
 90bc3f4:	e0bfff17 	ldw	r2,-4(fp)
 90bc3f8:	11000617 	ldw	r4,24(r2)
 90bc3fc:	e0bffe17 	ldw	r2,-8(fp)
 90bc400:	11400117 	ldw	r5,4(r2)
 90bc404:	e0bffe17 	ldw	r2,-8(fp)
 90bc408:	11800417 	ldw	r6,16(r2)
 90bc40c:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc410:	01000084 	movi	r4,2
 90bc414:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 90bc418:	e13ffe17 	ldw	r4,-8(fp)
 90bc41c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc420:	01000084 	movi	r4,2
 90bc424:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 90bc428:	d0a0c417 	ldw	r2,-31984(gp)
 90bc42c:	10800044 	addi	r2,r2,1
 90bc430:	d0a0c415 	stw	r2,-31984(gp)
}
 90bc434:	e037883a 	mov	sp,fp
 90bc438:	dfc00117 	ldw	ra,4(sp)
 90bc43c:	df000017 	ldw	fp,0(sp)
 90bc440:	dec00204 	addi	sp,sp,8
 90bc444:	f800283a 	ret

090bc448 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 90bc448:	defff804 	addi	sp,sp,-32
 90bc44c:	dfc00715 	stw	ra,28(sp)
 90bc450:	df000615 	stw	fp,24(sp)
 90bc454:	df000604 	addi	fp,sp,24
 90bc458:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 90bc45c:	e0bffe17 	ldw	r2,-8(fp)
 90bc460:	10800317 	ldw	r2,12(r2)
 90bc464:	10bffc84 	addi	r2,r2,-14
 90bc468:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 90bc46c:	e0bffe17 	ldw	r2,-8(fp)
 90bc470:	10800317 	ldw	r2,12(r2)
 90bc474:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bc478:	e0bffd17 	ldw	r2,-12(fp)
 90bc47c:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 90bc480:	e0bffd17 	ldw	r2,-12(fp)
 90bc484:	11000704 	addi	r4,r2,28
 90bc488:	e0bffa17 	ldw	r2,-24(fp)
 90bc48c:	10800204 	addi	r2,r2,8
 90bc490:	11400404 	addi	r5,r2,16
 90bc494:	01800104 	movi	r6,4
 90bc498:	90823180 	call	9082318 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 90bc49c:	e0bffd17 	ldw	r2,-12(fp)
 90bc4a0:	11000504 	addi	r4,r2,20
 90bc4a4:	e0bffa17 	ldw	r2,-24(fp)
 90bc4a8:	10800204 	addi	r2,r2,8
 90bc4ac:	11400284 	addi	r5,r2,10
 90bc4b0:	01800184 	movi	r6,6
 90bc4b4:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 90bc4b8:	e0bffd17 	ldw	r2,-12(fp)
 90bc4bc:	11000404 	addi	r4,r2,16
 90bc4c0:	e0bffa17 	ldw	r2,-24(fp)
 90bc4c4:	10800204 	addi	r2,r2,8
 90bc4c8:	11400184 	addi	r5,r2,6
 90bc4cc:	01800104 	movi	r6,4
 90bc4d0:	90823180 	call	9082318 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 90bc4d4:	e0bffd17 	ldw	r2,-12(fp)
 90bc4d8:	11000204 	addi	r4,r2,8
 90bc4dc:	e0bffa17 	ldw	r2,-24(fp)
 90bc4e0:	11400204 	addi	r5,r2,8
 90bc4e4:	01800184 	movi	r6,6
 90bc4e8:	90823180 	call	9082318 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 90bc4ec:	e0bffd17 	ldw	r2,-12(fp)
 90bc4f0:	10c00717 	ldw	r3,28(r2)
 90bc4f4:	e0bffe17 	ldw	r2,-8(fp)
 90bc4f8:	10800617 	ldw	r2,24(r2)
 90bc4fc:	10800a17 	ldw	r2,40(r2)
 90bc500:	18801f26 	beq	r3,r2,90bc580 <arprcv+0x138>
 90bc504:	e0bffd17 	ldw	r2,-12(fp)
 90bc508:	10800717 	ldw	r2,28(r2)
 90bc50c:	1004d63a 	srli	r2,r2,24
 90bc510:	10c03fcc 	andi	r3,r2,255
 90bc514:	e0bffd17 	ldw	r2,-12(fp)
 90bc518:	10800717 	ldw	r2,28(r2)
 90bc51c:	1004d23a 	srli	r2,r2,8
 90bc520:	10bfc00c 	andi	r2,r2,65280
 90bc524:	1886b03a 	or	r3,r3,r2
 90bc528:	e0bffd17 	ldw	r2,-12(fp)
 90bc52c:	10800717 	ldw	r2,28(r2)
 90bc530:	10bfc00c 	andi	r2,r2,65280
 90bc534:	1004923a 	slli	r2,r2,8
 90bc538:	1886b03a 	or	r3,r3,r2
 90bc53c:	e0bffd17 	ldw	r2,-12(fp)
 90bc540:	10800717 	ldw	r2,28(r2)
 90bc544:	10803fcc 	andi	r2,r2,255
 90bc548:	1004963a 	slli	r2,r2,24
 90bc54c:	1884b03a 	or	r2,r3,r2
 90bc550:	10fc002c 	andhi	r3,r2,61440
 90bc554:	00b80034 	movhi	r2,57344
 90bc558:	18800926 	beq	r3,r2,90bc580 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc55c:	01000084 	movi	r4,2
 90bc560:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 90bc564:	e13ffe17 	ldw	r4,-8(fp)
 90bc568:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc56c:	01000084 	movi	r4,2
 90bc570:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 90bc574:	00800084 	movi	r2,2
 90bc578:	e0bfff15 	stw	r2,-4(fp)
 90bc57c:	00004406 	br	90bc690 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 90bc580:	e0bffd17 	ldw	r2,-12(fp)
 90bc584:	1080018b 	ldhu	r2,6(r2)
 90bc588:	10bfffcc 	andi	r2,r2,65535
 90bc58c:	10804018 	cmpnei	r2,r2,256
 90bc590:	10000b1e 	bne	r2,zero,90bc5c0 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 90bc594:	d0a0c117 	ldw	r2,-31996(gp)
 90bc598:	10800044 	addi	r2,r2,1
 90bc59c:	d0a0c115 	stw	r2,-31996(gp)
      arpReply(pkt); /* send arp reply */
 90bc5a0:	e13ffe17 	ldw	r4,-8(fp)
 90bc5a4:	90bc1b40 	call	90bc1b4 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 90bc5a8:	e0bffd17 	ldw	r2,-12(fp)
 90bc5ac:	11000417 	ldw	r4,16(r2)
 90bc5b0:	e0bffe17 	ldw	r2,-8(fp)
 90bc5b4:	11400617 	ldw	r5,24(r2)
 90bc5b8:	90bc0a00 	call	90bc0a0 <make_arp_entry>
 90bc5bc:	00000306 	br	90bc5cc <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 90bc5c0:	d0a0c317 	ldw	r2,-31988(gp)
 90bc5c4:	10800044 	addi	r2,r2,1
 90bc5c8:	d0a0c315 	stw	r2,-31988(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bc5cc:	008243b4 	movhi	r2,2318
 90bc5d0:	10b61f04 	addi	r2,r2,-10116
 90bc5d4:	e0bffc15 	stw	r2,-16(fp)
 90bc5d8:	00002106 	br	90bc660 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 90bc5dc:	e0bffc17 	ldw	r2,-16(fp)
 90bc5e0:	10c00017 	ldw	r3,0(r2)
 90bc5e4:	e0bffd17 	ldw	r2,-12(fp)
 90bc5e8:	10800417 	ldw	r2,16(r2)
 90bc5ec:	1880191e 	bne	r3,r2,90bc654 <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 90bc5f0:	e0bffc17 	ldw	r2,-16(fp)
 90bc5f4:	11000104 	addi	r4,r2,4
 90bc5f8:	e0bffd17 	ldw	r2,-12(fp)
 90bc5fc:	11400204 	addi	r5,r2,8
 90bc600:	01800184 	movi	r6,6
 90bc604:	90823180 	call	9082318 <memmove>
         tp->lasttime = cticks;
 90bc608:	00824374 	movhi	r2,2317
 90bc60c:	108c4204 	addi	r2,r2,12552
 90bc610:	10c00017 	ldw	r3,0(r2)
 90bc614:	e0bffc17 	ldw	r2,-16(fp)
 90bc618:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 90bc61c:	e0bffc17 	ldw	r2,-16(fp)
 90bc620:	10800417 	ldw	r2,16(r2)
 90bc624:	1005003a 	cmpeq	r2,r2,zero
 90bc628:	1000021e 	bne	r2,zero,90bc634 <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 90bc62c:	e13ffc17 	ldw	r4,-16(fp)
 90bc630:	90bb9a00 	call	90bb9a0 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc634:	01000084 	movi	r4,2
 90bc638:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90bc63c:	e13ffe17 	ldw	r4,-8(fp)
 90bc640:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc644:	01000084 	movi	r4,2
 90bc648:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

         return (0);
 90bc64c:	e03fff15 	stw	zero,-4(fp)
 90bc650:	00000f06 	br	90bc690 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bc654:	e0bffc17 	ldw	r2,-16(fp)
 90bc658:	10800804 	addi	r2,r2,32
 90bc65c:	e0bffc15 	stw	r2,-16(fp)
 90bc660:	00c243b4 	movhi	r3,2318
 90bc664:	18f65f04 	addi	r3,r3,-9860
 90bc668:	e0bffc17 	ldw	r2,-16(fp)
 90bc66c:	10ffdb36 	bltu	r2,r3,90bc5dc <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc670:	01000084 	movi	r4,2
 90bc674:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 90bc678:	e13ffe17 	ldw	r4,-8(fp)
 90bc67c:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc680:	01000084 	movi	r4,2
 90bc684:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 90bc688:	00800084 	movi	r2,2
 90bc68c:	e0bfff15 	stw	r2,-4(fp)
 90bc690:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc694:	e037883a 	mov	sp,fp
 90bc698:	dfc00117 	ldw	ra,4(sp)
 90bc69c:	df000017 	ldw	fp,0(sp)
 90bc6a0:	dec00204 	addi	sp,sp,8
 90bc6a4:	f800283a 	ret

090bc6a8 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 90bc6a8:	defff704 	addi	sp,sp,-36
 90bc6ac:	dfc00815 	stw	ra,32(sp)
 90bc6b0:	df000715 	stw	fp,28(sp)
 90bc6b4:	df000704 	addi	fp,sp,28
 90bc6b8:	e13ffd15 	stw	r4,-12(fp)
 90bc6bc:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 90bc6c0:	00824374 	movhi	r2,2317
 90bc6c4:	108c4204 	addi	r2,r2,12552
 90bc6c8:	10800017 	ldw	r2,0(r2)
 90bc6cc:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 90bc6d0:	e0bffe17 	ldw	r2,-8(fp)
 90bc6d4:	1004c03a 	cmpne	r2,r2,zero
 90bc6d8:	1000091e 	bne	r2,zero,90bc700 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc6dc:	01000084 	movi	r4,2
 90bc6e0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bc6e4:	e13ffd17 	ldw	r4,-12(fp)
 90bc6e8:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc6ec:	01000084 	movi	r4,2
 90bc6f0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 90bc6f4:	00bffa84 	movi	r2,-22
 90bc6f8:	e0bfff15 	stw	r2,-4(fp)
 90bc6fc:	00005706 	br	90bc85c <send_via_arp+0x1b4>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 90bc700:	d0e0c517 	ldw	r3,-31980(gp)
 90bc704:	e0bffb17 	ldw	r2,-20(fp)
 90bc708:	10c9c83a 	sub	r4,r2,r3
 90bc70c:	908c0380 	call	908c038 <__floatunsidf>
 90bc710:	100b883a 	mov	r5,r2
 90bc714:	180d883a 	mov	r6,r3
 90bc718:	2809883a 	mov	r4,r5
 90bc71c:	300b883a 	mov	r5,r6
 90bc720:	000d883a 	mov	r6,zero
 90bc724:	01d01674 	movhi	r7,16473
 90bc728:	908bcd00 	call	908bcd0 <__gtdf2>
 90bc72c:	10800048 	cmpgei	r2,r2,1
 90bc730:	1000011e 	bne	r2,zero,90bc738 <send_via_arp+0x90>
 90bc734:	00000106 	br	90bc73c <send_via_arp+0x94>
      arpcache = (struct arptabent *)NULL;
 90bc738:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 90bc73c:	d0a0c017 	ldw	r2,-32000(gp)
 90bc740:	1005003a 	cmpeq	r2,r2,zero
 90bc744:	1000071e 	bne	r2,zero,90bc764 <send_via_arp+0xbc>
 90bc748:	d0a0c017 	ldw	r2,-32000(gp)
 90bc74c:	10c00017 	ldw	r3,0(r2)
 90bc750:	e0bffe17 	ldw	r2,-8(fp)
 90bc754:	1880031e 	bne	r3,r2,90bc764 <send_via_arp+0xbc>
      tp = arpcache;
 90bc758:	d0a0c017 	ldw	r2,-32000(gp)
 90bc75c:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 90bc760:	00000306 	br	90bc770 <send_via_arp+0xc8>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 90bc764:	e13ffe17 	ldw	r4,-8(fp)
 90bc768:	90bbeac0 	call	90bbeac <find_oldest_arp>
 90bc76c:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 90bc770:	e0bffc17 	ldw	r2,-16(fp)
 90bc774:	10c00017 	ldw	r3,0(r2)
 90bc778:	e0bffe17 	ldw	r2,-8(fp)
 90bc77c:	1880311e 	bne	r3,r2,90bc844 <send_via_arp+0x19c>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 90bc780:	e0bffc17 	ldw	r2,-16(fp)
 90bc784:	10800417 	ldw	r2,16(r2)
 90bc788:	1005003a 	cmpeq	r2,r2,zero
 90bc78c:	1000241e 	bne	r2,zero,90bc820 <send_via_arp+0x178>
      {
         if (lilfreeq.q_len < 2)
 90bc790:	008243b4 	movhi	r2,2318
 90bc794:	10b48004 	addi	r2,r2,-11776
 90bc798:	10800217 	ldw	r2,8(r2)
 90bc79c:	10800088 	cmpgei	r2,r2,2
 90bc7a0:	1000091e 	bne	r2,zero,90bc7c8 <send_via_arp+0x120>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc7a4:	01000084 	movi	r4,2
 90bc7a8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 90bc7ac:	e13ffd17 	ldw	r4,-12(fp)
 90bc7b0:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc7b4:	01000084 	movi	r4,2
 90bc7b8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 90bc7bc:	00bffa84 	movi	r2,-22
 90bc7c0:	e0bffa15 	stw	r2,-24(fp)
 90bc7c4:	00002306 	br	90bc854 <send_via_arp+0x1ac>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 90bc7c8:	e0bffc17 	ldw	r2,-16(fp)
 90bc7cc:	10800417 	ldw	r2,16(r2)
 90bc7d0:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 90bc7d4:	00000306 	br	90bc7e4 <send_via_arp+0x13c>
               tmppkt = tmppkt->next;
 90bc7d8:	e0bff917 	ldw	r2,-28(fp)
 90bc7dc:	10800017 	ldw	r2,0(r2)
 90bc7e0:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 90bc7e4:	e0bff917 	ldw	r2,-28(fp)
 90bc7e8:	10800017 	ldw	r2,0(r2)
 90bc7ec:	1004c03a 	cmpne	r2,r2,zero
 90bc7f0:	103ff91e 	bne	r2,zero,90bc7d8 <send_via_arp+0x130>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 90bc7f4:	e0fff917 	ldw	r3,-28(fp)
 90bc7f8:	e0bffd17 	ldw	r2,-12(fp)
 90bc7fc:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 90bc800:	e0bffd17 	ldw	r2,-12(fp)
 90bc804:	10800017 	ldw	r2,0(r2)
 90bc808:	1005003a 	cmpeq	r2,r2,zero
 90bc80c:	1000011e 	bne	r2,zero,90bc814 <send_via_arp+0x16c>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 90bc810:	90a94880 	call	90a9488 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 90bc814:	00800044 	movi	r2,1
 90bc818:	e0bffa15 	stw	r2,-24(fp)
 90bc81c:	00000d06 	br	90bc854 <send_via_arp+0x1ac>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 90bc820:	e0bffc17 	ldw	r2,-16(fp)
 90bc824:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 90bc828:	e0bffb17 	ldw	r2,-20(fp)
 90bc82c:	d0a0c515 	stw	r2,-31980(gp)
         err = et_send(pkt, tp);
 90bc830:	e13ffd17 	ldw	r4,-12(fp)
 90bc834:	e17ffc17 	ldw	r5,-16(fp)
 90bc838:	90bb79c0 	call	90bb79c <et_send>
 90bc83c:	e0bffa15 	stw	r2,-24(fp)
 90bc840:	00000406 	br	90bc854 <send_via_arp+0x1ac>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 90bc844:	e13ffd17 	ldw	r4,-12(fp)
 90bc848:	e17ffe17 	ldw	r5,-8(fp)
 90bc84c:	90bba140 	call	90bba14 <send_arp>
 90bc850:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 90bc854:	e0bffa17 	ldw	r2,-24(fp)
 90bc858:	e0bfff15 	stw	r2,-4(fp)
 90bc85c:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc860:	e037883a 	mov	sp,fp
 90bc864:	dfc00117 	ldw	ra,4(sp)
 90bc868:	df000017 	ldw	fp,0(sp)
 90bc86c:	dec00204 	addi	sp,sp,8
 90bc870:	f800283a 	ret

090bc874 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 90bc874:	defff804 	addi	sp,sp,-32
 90bc878:	dfc00715 	stw	ra,28(sp)
 90bc87c:	df000615 	stw	fp,24(sp)
 90bc880:	df000604 	addi	fp,sp,24
 90bc884:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   int arp_count = 0;
 90bc888:	e03ffb15 	stw	zero,-20(fp)
   unsigned long lticks = cticks;
 90bc88c:	00824374 	movhi	r2,2317
 90bc890:	108c4204 	addi	r2,r2,12552
 90bc894:	10800017 	ldw	r2,0(r2)
 90bc898:	e0bffa15 	stw	r2,-24(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bc89c:	008243b4 	movhi	r2,2318
 90bc8a0:	10b61f04 	addi	r2,r2,-10116
 90bc8a4:	e0bffc15 	stw	r2,-16(fp)
 90bc8a8:	00004c06 	br	90bc9dc <cb_arpent_tmo+0x168>
   {
      if (tp->t_pro_addr != 0)
 90bc8ac:	e0bffc17 	ldw	r2,-16(fp)
 90bc8b0:	10800017 	ldw	r2,0(r2)
 90bc8b4:	1005003a 	cmpeq	r2,r2,zero
 90bc8b8:	1000451e 	bne	r2,zero,90bc9d0 <cb_arpent_tmo+0x15c>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 90bc8bc:	e0bffc17 	ldw	r2,-16(fp)
 90bc8c0:	10800417 	ldw	r2,16(r2)
 90bc8c4:	1005003a 	cmpeq	r2,r2,zero
 90bc8c8:	10001c1e 	bne	r2,zero,90bc93c <cb_arpent_tmo+0xc8>
 90bc8cc:	e0bffc17 	ldw	r2,-16(fp)
 90bc8d0:	10c00517 	ldw	r3,20(r2)
 90bc8d4:	e0bffa17 	ldw	r2,-24(fp)
 90bc8d8:	10c9c83a 	sub	r4,r2,r3
 90bc8dc:	908c0380 	call	908c038 <__floatunsidf>
 90bc8e0:	100b883a 	mov	r5,r2
 90bc8e4:	180d883a 	mov	r6,r3
 90bc8e8:	e03fff05 	stb	zero,-4(fp)
 90bc8ec:	2809883a 	mov	r4,r5
 90bc8f0:	300b883a 	mov	r5,r6
 90bc8f4:	000d883a 	mov	r6,zero
 90bc8f8:	01d01674 	movhi	r7,16473
 90bc8fc:	908bcd00 	call	908bcd0 <__gtdf2>
 90bc900:	10800048 	cmpgei	r2,r2,1
 90bc904:	1000011e 	bne	r2,zero,90bc90c <cb_arpent_tmo+0x98>
 90bc908:	00000206 	br	90bc914 <cb_arpent_tmo+0xa0>
 90bc90c:	00800044 	movi	r2,1
 90bc910:	e0bfff05 	stb	r2,-4(fp)
 90bc914:	e0ffff03 	ldbu	r3,-4(fp)
 90bc918:	1880005c 	xori	r2,r3,1
 90bc91c:	10803fcc 	andi	r2,r2,255
 90bc920:	1004c03a 	cmpne	r2,r2,zero
 90bc924:	1000051e 	bne	r2,zero,90bc93c <cb_arpent_tmo+0xc8>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 90bc928:	e13ffc17 	ldw	r4,-16(fp)
 90bc92c:	90bb9180 	call	90bb918 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bc930:	e0bffc17 	ldw	r2,-16(fp)
 90bc934:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 90bc938:	00002506 	br	90bc9d0 <cb_arpent_tmo+0x15c>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 90bc93c:	e0bffc17 	ldw	r2,-16(fp)
 90bc940:	10c00517 	ldw	r3,20(r2)
 90bc944:	e0bffa17 	ldw	r2,-24(fp)
 90bc948:	10c5c83a 	sub	r2,r2,r3
 90bc94c:	1007883a 	mov	r3,r2
 90bc950:	d0a04f17 	ldw	r2,-32452(gp)
 90bc954:	18801b16 	blt	r3,r2,90bc9c4 <cb_arpent_tmo+0x150>
 90bc958:	e0bffc17 	ldw	r2,-16(fp)
 90bc95c:	10c00617 	ldw	r3,24(r2)
 90bc960:	e0bffa17 	ldw	r2,-24(fp)
 90bc964:	10c5c83a 	sub	r2,r2,r3
 90bc968:	1009883a 	mov	r4,r2
 90bc96c:	908be680 	call	908be68 <__floatsidf>
 90bc970:	100b883a 	mov	r5,r2
 90bc974:	180d883a 	mov	r6,r3
 90bc978:	e03ffe05 	stb	zero,-8(fp)
 90bc97c:	2809883a 	mov	r4,r5
 90bc980:	300b883a 	mov	r5,r6
 90bc984:	000d883a 	mov	r6,zero
 90bc988:	01d01674 	movhi	r7,16473
 90bc98c:	908bd580 	call	908bd58 <__gedf2>
 90bc990:	1004403a 	cmpge	r2,r2,zero
 90bc994:	1000011e 	bne	r2,zero,90bc99c <cb_arpent_tmo+0x128>
 90bc998:	00000206 	br	90bc9a4 <cb_arpent_tmo+0x130>
 90bc99c:	00800044 	movi	r2,1
 90bc9a0:	e0bffe05 	stb	r2,-8(fp)
 90bc9a4:	e0fffe03 	ldbu	r3,-8(fp)
 90bc9a8:	1880005c 	xori	r2,r3,1
 90bc9ac:	10803fcc 	andi	r2,r2,255
 90bc9b0:	1004c03a 	cmpne	r2,r2,zero
 90bc9b4:	1000031e 	bne	r2,zero,90bc9c4 <cb_arpent_tmo+0x150>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bc9b8:	e0bffc17 	ldw	r2,-16(fp)
 90bc9bc:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 90bc9c0:	00000306 	br	90bc9d0 <cb_arpent_tmo+0x15c>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 90bc9c4:	e0bffb17 	ldw	r2,-20(fp)
 90bc9c8:	10800044 	addi	r2,r2,1
 90bc9cc:	e0bffb15 	stw	r2,-20(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bc9d0:	e0bffc17 	ldw	r2,-16(fp)
 90bc9d4:	10800804 	addi	r2,r2,32
 90bc9d8:	e0bffc15 	stw	r2,-16(fp)
 90bc9dc:	00c243b4 	movhi	r3,2318
 90bc9e0:	18f65f04 	addi	r3,r3,-9860
 90bc9e4:	e0bffc17 	ldw	r2,-16(fp)
 90bc9e8:	10ffb036 	bltu	r2,r3,90bc8ac <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 90bc9ec:	e0bffb17 	ldw	r2,-20(fp)
 90bc9f0:	1004c03a 	cmpne	r2,r2,zero
 90bc9f4:	1000031e 	bne	r2,zero,90bca04 <cb_arpent_tmo+0x190>
   {
      in_timerkill(arp_timer);
 90bc9f8:	d120bf17 	ldw	r4,-32004(gp)
 90bc9fc:	90bb54c0 	call	90bb54c <in_timerkill>
      arp_timer = 0;
 90bca00:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 90bca04:	e037883a 	mov	sp,fp
 90bca08:	dfc00117 	ldw	ra,4(sp)
 90bca0c:	df000017 	ldw	fp,0(sp)
 90bca10:	dec00204 	addi	sp,sp,8
 90bca14:	f800283a 	ret

090bca18 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 90bca18:	defff604 	addi	sp,sp,-40
 90bca1c:	dfc00915 	stw	ra,36(sp)
 90bca20:	df000815 	stw	fp,32(sp)
 90bca24:	df000804 	addi	fp,sp,32
 90bca28:	e13ffd15 	stw	r4,-12(fp)
 90bca2c:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 90bca30:	e0bffd17 	ldw	r2,-12(fp)
 90bca34:	10802717 	ldw	r2,156(r2)
 90bca38:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 90bca3c:	01000084 	movi	r4,2
 90bca40:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 90bca44:	01000c04 	movi	r4,48
 90bca48:	90a88440 	call	90a8844 <pk_alloc>
 90bca4c:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 90bca50:	e0bff917 	ldw	r2,-28(fp)
 90bca54:	1004c03a 	cmpne	r2,r2,zero
 90bca58:	1000051e 	bne	r2,zero,90bca70 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bca5c:	01000084 	movi	r4,2
 90bca60:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 90bca64:	00bffa84 	movi	r2,-22
 90bca68:	e0bfff15 	stw	r2,-4(fp)
 90bca6c:	00009706 	br	90bcccc <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bca70:	01000084 	movi	r4,2
 90bca74:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 90bca78:	e0bff917 	ldw	r2,-28(fp)
 90bca7c:	10c00117 	ldw	r3,4(r2)
 90bca80:	e0bff917 	ldw	r2,-28(fp)
 90bca84:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 90bca88:	e0fff917 	ldw	r3,-28(fp)
 90bca8c:	00800c04 	movi	r2,48
 90bca90:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 90bca94:	e0fff917 	ldw	r3,-28(fp)
 90bca98:	e0bffd17 	ldw	r2,-12(fp)
 90bca9c:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 90bcaa0:	e0bff917 	ldw	r2,-28(fp)
 90bcaa4:	10800117 	ldw	r2,4(r2)
 90bcaa8:	10800084 	addi	r2,r2,2
 90bcaac:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 90bcab0:	e0bff917 	ldw	r2,-28(fp)
 90bcab4:	10800117 	ldw	r2,4(r2)
 90bcab8:	10800404 	addi	r2,r2,16
 90bcabc:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bcac0:	e0fffb17 	ldw	r3,-20(fp)
 90bcac4:	00804004 	movi	r2,256
 90bcac8:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 90bcacc:	e0fffb17 	ldw	r3,-20(fp)
 90bcad0:	00800204 	movi	r2,8
 90bcad4:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 90bcad8:	e0fffb17 	ldw	r3,-20(fp)
 90bcadc:	00800184 	movi	r2,6
 90bcae0:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 90bcae4:	e0fffb17 	ldw	r3,-20(fp)
 90bcae8:	00800104 	movi	r2,4
 90bcaec:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 90bcaf0:	e0bffe17 	ldw	r2,-8(fp)
 90bcaf4:	1004c03a 	cmpne	r2,r2,zero
 90bcaf8:	1000041e 	bne	r2,zero,90bcb0c <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 90bcafc:	e0fffb17 	ldw	r3,-20(fp)
 90bcb00:	00804004 	movi	r2,256
 90bcb04:	1880018d 	sth	r2,6(r3)
 90bcb08:	00000306 	br	90bcb18 <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 90bcb0c:	e0fffb17 	ldw	r3,-20(fp)
 90bcb10:	00808004 	movi	r2,512
 90bcb14:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 90bcb18:	e0bffd17 	ldw	r2,-12(fp)
 90bcb1c:	10c00a17 	ldw	r3,40(r2)
 90bcb20:	e0bffb17 	ldw	r2,-20(fp)
 90bcb24:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 90bcb28:	e0bffd17 	ldw	r2,-12(fp)
 90bcb2c:	10c00a17 	ldw	r3,40(r2)
 90bcb30:	e0bffb17 	ldw	r2,-20(fp)
 90bcb34:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 90bcb38:	e0bffb17 	ldw	r2,-20(fp)
 90bcb3c:	11000204 	addi	r4,r2,8
 90bcb40:	e0bffa17 	ldw	r2,-24(fp)
 90bcb44:	11400517 	ldw	r5,20(r2)
 90bcb48:	01800184 	movi	r6,6
 90bcb4c:	90823180 	call	9082318 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 90bcb50:	e0fffc17 	ldw	r3,-16(fp)
 90bcb54:	00bfffc4 	movi	r2,-1
 90bcb58:	18800005 	stb	r2,0(r3)
 90bcb5c:	00bfffc4 	movi	r2,-1
 90bcb60:	18800045 	stb	r2,1(r3)
 90bcb64:	00bfffc4 	movi	r2,-1
 90bcb68:	18800085 	stb	r2,2(r3)
 90bcb6c:	00bfffc4 	movi	r2,-1
 90bcb70:	188000c5 	stb	r2,3(r3)
 90bcb74:	00bfffc4 	movi	r2,-1
 90bcb78:	18800105 	stb	r2,4(r3)
 90bcb7c:	00bfffc4 	movi	r2,-1
 90bcb80:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 90bcb84:	e0bffc17 	ldw	r2,-16(fp)
 90bcb88:	11000184 	addi	r4,r2,6
 90bcb8c:	e0bffa17 	ldw	r2,-24(fp)
 90bcb90:	11400517 	ldw	r5,20(r2)
 90bcb94:	01800184 	movi	r6,6
 90bcb98:	90823180 	call	9082318 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 90bcb9c:	e0bffc17 	ldw	r2,-16(fp)
 90bcba0:	10c00304 	addi	r3,r2,12
 90bcba4:	00800204 	movi	r2,8
 90bcba8:	18800005 	stb	r2,0(r3)
 90bcbac:	e0bffc17 	ldw	r2,-16(fp)
 90bcbb0:	10c00344 	addi	r3,r2,13
 90bcbb4:	00800184 	movi	r2,6
 90bcbb8:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bcbbc:	e0bffb17 	ldw	r2,-20(fp)
 90bcbc0:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 90bcbc4:	e0bff817 	ldw	r2,-32(fp)
 90bcbc8:	11000204 	addi	r4,r2,8
 90bcbcc:	e0bffb17 	ldw	r2,-20(fp)
 90bcbd0:	11400204 	addi	r5,r2,8
 90bcbd4:	01800184 	movi	r6,6
 90bcbd8:	90823180 	call	9082318 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 90bcbdc:	e0bff817 	ldw	r2,-32(fp)
 90bcbe0:	10800204 	addi	r2,r2,8
 90bcbe4:	11000184 	addi	r4,r2,6
 90bcbe8:	e0bffb17 	ldw	r2,-20(fp)
 90bcbec:	11400404 	addi	r5,r2,16
 90bcbf0:	01800104 	movi	r6,4
 90bcbf4:	90823180 	call	9082318 <memmove>

   /* ARP req? */
   if (flag == 0)
 90bcbf8:	e0bffe17 	ldw	r2,-8(fp)
 90bcbfc:	1004c03a 	cmpne	r2,r2,zero
 90bcc00:	1000081e 	bne	r2,zero,90bcc24 <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 90bcc04:	e0bff817 	ldw	r2,-32(fp)
 90bcc08:	10800204 	addi	r2,r2,8
 90bcc0c:	11000284 	addi	r4,r2,10
 90bcc10:	e0bffb17 	ldw	r2,-20(fp)
 90bcc14:	11400504 	addi	r5,r2,20
 90bcc18:	01800184 	movi	r6,6
 90bcc1c:	90823180 	call	9082318 <memmove>
 90bcc20:	00000706 	br	90bcc40 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 90bcc24:	e0bff817 	ldw	r2,-32(fp)
 90bcc28:	10800204 	addi	r2,r2,8
 90bcc2c:	11000284 	addi	r4,r2,10
 90bcc30:	e0bffb17 	ldw	r2,-20(fp)
 90bcc34:	11400204 	addi	r5,r2,8
 90bcc38:	01800184 	movi	r6,6
 90bcc3c:	90823180 	call	9082318 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 90bcc40:	e0bff817 	ldw	r2,-32(fp)
 90bcc44:	10800204 	addi	r2,r2,8
 90bcc48:	11000404 	addi	r4,r2,16
 90bcc4c:	e0bffb17 	ldw	r2,-20(fp)
 90bcc50:	11400704 	addi	r5,r2,28
 90bcc54:	01800104 	movi	r6,4
 90bcc58:	90823180 	call	9082318 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 90bcc5c:	e0bffd17 	ldw	r2,-12(fp)
 90bcc60:	10800417 	ldw	r2,16(r2)
 90bcc64:	1005003a 	cmpeq	r2,r2,zero
 90bcc68:	1000051e 	bne	r2,zero,90bcc80 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 90bcc6c:	e0bffd17 	ldw	r2,-12(fp)
 90bcc70:	10800417 	ldw	r2,16(r2)
 90bcc74:	e13ff917 	ldw	r4,-28(fp)
 90bcc78:	103ee83a 	callr	r2
 90bcc7c:	00000e06 	br	90bccb8 <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 90bcc80:	e0bffd17 	ldw	r2,-12(fp)
 90bcc84:	10c00317 	ldw	r3,12(r2)
 90bcc88:	e0bff917 	ldw	r2,-28(fp)
 90bcc8c:	11000617 	ldw	r4,24(r2)
 90bcc90:	e0bff917 	ldw	r2,-28(fp)
 90bcc94:	11400117 	ldw	r5,4(r2)
 90bcc98:	01800c04 	movi	r6,48
 90bcc9c:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bcca0:	01000084 	movi	r4,2
 90bcca4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 90bcca8:	e13ff917 	ldw	r4,-28(fp)
 90bccac:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bccb0:	01000084 	movi	r4,2
 90bccb4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 90bccb8:	d0a0c217 	ldw	r2,-31992(gp)
 90bccbc:	10800044 	addi	r2,r2,1
 90bccc0:	d0a0c215 	stw	r2,-31992(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 90bccc4:	00800044 	movi	r2,1
 90bccc8:	e0bfff15 	stw	r2,-4(fp)
 90bcccc:	e0bfff17 	ldw	r2,-4(fp)
}
 90bccd0:	e037883a 	mov	sp,fp
 90bccd4:	dfc00117 	ldw	ra,4(sp)
 90bccd8:	df000017 	ldw	fp,0(sp)
 90bccdc:	dec00204 	addi	sp,sp,8
 90bcce0:	f800283a 	ret

090bcce4 <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 90bcce4:	defffb04 	addi	sp,sp,-20
 90bcce8:	dfc00415 	stw	ra,16(sp)
 90bccec:	df000315 	stw	fp,12(sp)
 90bccf0:	df000304 	addi	fp,sp,12
 90bccf4:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bccf8:	008243b4 	movhi	r2,2318
 90bccfc:	10b65f04 	addi	r2,r2,-9860
 90bcd00:	10800017 	ldw	r2,0(r2)
 90bcd04:	e0bffd15 	stw	r2,-12(fp)
 90bcd08:	00000c06 	br	90bcd3c <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 90bcd0c:	e0bffe17 	ldw	r2,-8(fp)
 90bcd10:	10bfffc4 	addi	r2,r2,-1
 90bcd14:	e0bffe15 	stw	r2,-8(fp)
 90bcd18:	e0bffe17 	ldw	r2,-8(fp)
 90bcd1c:	10bfffd8 	cmpnei	r2,r2,-1
 90bcd20:	1000031e 	bne	r2,zero,90bcd30 <if_getbynum+0x4c>
         return ifp;
 90bcd24:	e0bffd17 	ldw	r2,-12(fp)
 90bcd28:	e0bfff15 	stw	r2,-4(fp)
 90bcd2c:	00000806 	br	90bcd50 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bcd30:	e0bffd17 	ldw	r2,-12(fp)
 90bcd34:	10800017 	ldw	r2,0(r2)
 90bcd38:	e0bffd15 	stw	r2,-12(fp)
 90bcd3c:	e0bffd17 	ldw	r2,-12(fp)
 90bcd40:	1004c03a 	cmpne	r2,r2,zero
 90bcd44:	103ff11e 	bne	r2,zero,90bcd0c <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 90bcd48:	90a94880 	call	90a9488 <dtrap>
   return NULL;   /* list is not long enough */
 90bcd4c:	e03fff15 	stw	zero,-4(fp)
 90bcd50:	e0bfff17 	ldw	r2,-4(fp)
}
 90bcd54:	e037883a 	mov	sp,fp
 90bcd58:	dfc00117 	ldw	ra,4(sp)
 90bcd5c:	df000017 	ldw	fp,0(sp)
 90bcd60:	dec00204 	addi	sp,sp,8
 90bcd64:	f800283a 	ret

090bcd68 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 90bcd68:	defffc04 	addi	sp,sp,-16
 90bcd6c:	df000315 	stw	fp,12(sp)
 90bcd70:	df000304 	addi	fp,sp,12
 90bcd74:	e13ffd15 	stw	r4,-12(fp)
 90bcd78:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 90bcd7c:	e0bffe17 	ldw	r2,-8(fp)
 90bcd80:	108000cc 	andi	r2,r2,3
 90bcd84:	1005003a 	cmpeq	r2,r2,zero
 90bcd88:	10000e1e 	bne	r2,zero,90bcdc4 <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 90bcd8c:	e0bffe17 	ldw	r2,-8(fp)
 90bcd90:	1080000b 	ldhu	r2,0(r2)
 90bcd94:	10ffffcc 	andi	r3,r2,65535
 90bcd98:	00bfffd4 	movui	r2,65535
 90bcd9c:	18800226 	beq	r3,r2,90bcda8 <isbcast+0x40>
         return(FALSE);
 90bcda0:	e03fff15 	stw	zero,-4(fp)
 90bcda4:	00002306 	br	90bce34 <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 90bcda8:	e0bffe17 	ldw	r2,-8(fp)
 90bcdac:	10800084 	addi	r2,r2,2
 90bcdb0:	10800017 	ldw	r2,0(r2)
 90bcdb4:	10bfffe0 	cmpeqi	r2,r2,-1
 90bcdb8:	1000101e 	bne	r2,zero,90bcdfc <isbcast+0x94>
         return FALSE;
 90bcdbc:	e03fff15 	stw	zero,-4(fp)
 90bcdc0:	00001c06 	br	90bce34 <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 90bcdc4:	e0bffe17 	ldw	r2,-8(fp)
 90bcdc8:	10800017 	ldw	r2,0(r2)
 90bcdcc:	10bfffe0 	cmpeqi	r2,r2,-1
 90bcdd0:	1000021e 	bne	r2,zero,90bcddc <isbcast+0x74>
         return FALSE;
 90bcdd4:	e03fff15 	stw	zero,-4(fp)
 90bcdd8:	00001606 	br	90bce34 <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 90bcddc:	e0bffe17 	ldw	r2,-8(fp)
 90bcde0:	10800104 	addi	r2,r2,4
 90bcde4:	1080000b 	ldhu	r2,0(r2)
 90bcde8:	10ffffcc 	andi	r3,r2,65535
 90bcdec:	00bfffd4 	movui	r2,65535
 90bcdf0:	18800226 	beq	r3,r2,90bcdfc <isbcast+0x94>
         return(FALSE);
 90bcdf4:	e03fff15 	stw	zero,-4(fp)
 90bcdf8:	00000e06 	br	90bce34 <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 90bcdfc:	e0bffd17 	ldw	r2,-12(fp)
 90bce00:	10802717 	ldw	r2,156(r2)
 90bce04:	10800217 	ldw	r2,8(r2)
 90bce08:	108005e0 	cmpeqi	r2,r2,23
 90bce0c:	1000051e 	bne	r2,zero,90bce24 <isbcast+0xbc>
 90bce10:	e0bffd17 	ldw	r2,-12(fp)
 90bce14:	10802717 	ldw	r2,156(r2)
 90bce18:	10800217 	ldw	r2,8(r2)
 90bce1c:	10800718 	cmpnei	r2,r2,28
 90bce20:	1000021e 	bne	r2,zero,90bce2c <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 90bce24:	e03fff15 	stw	zero,-4(fp)
 90bce28:	00000206 	br	90bce34 <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 90bce2c:	00800044 	movi	r2,1
 90bce30:	e0bfff15 	stw	r2,-4(fp)
 90bce34:	e0bfff17 	ldw	r2,-4(fp)
}
 90bce38:	e037883a 	mov	sp,fp
 90bce3c:	df000017 	ldw	fp,0(sp)
 90bce40:	dec00104 	addi	sp,sp,4
 90bce44:	f800283a 	ret

090bce48 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 90bce48:	defffa04 	addi	sp,sp,-24
 90bce4c:	dfc00515 	stw	ra,20(sp)
 90bce50:	df000415 	stw	fp,16(sp)
 90bce54:	df000404 	addi	fp,sp,16
 90bce58:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bce5c:	008243b4 	movhi	r2,2318
 90bce60:	10b65f04 	addi	r2,r2,-9860
 90bce64:	10800017 	ldw	r2,0(r2)
 90bce68:	e0bffd15 	stw	r2,-12(fp)
 90bce6c:	00001306 	br	90bcebc <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 90bce70:	e0bffd17 	ldw	r2,-12(fp)
 90bce74:	10800617 	ldw	r2,24(r2)
 90bce78:	1005003a 	cmpeq	r2,r2,zero
 90bce7c:	10000c1e 	bne	r2,zero,90bceb0 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 90bce80:	e0bffd17 	ldw	r2,-12(fp)
 90bce84:	10800617 	ldw	r2,24(r2)
 90bce88:	e13ffe0b 	ldhu	r4,-8(fp)
 90bce8c:	e17ffd17 	ldw	r5,-12(fp)
 90bce90:	103ee83a 	callr	r2
 90bce94:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 90bce98:	e0bffc17 	ldw	r2,-16(fp)
 90bce9c:	1005003a 	cmpeq	r2,r2,zero
 90bcea0:	1000031e 	bne	r2,zero,90bceb0 <reg_type+0x68>
            return e;   /* bails out if error */
 90bcea4:	e0bffc17 	ldw	r2,-16(fp)
 90bcea8:	e0bfff15 	stw	r2,-4(fp)
 90bceac:	00000706 	br	90bcecc <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bceb0:	e0bffd17 	ldw	r2,-12(fp)
 90bceb4:	10800017 	ldw	r2,0(r2)
 90bceb8:	e0bffd15 	stw	r2,-12(fp)
 90bcebc:	e0bffd17 	ldw	r2,-12(fp)
 90bcec0:	1004c03a 	cmpne	r2,r2,zero
 90bcec4:	103fea1e 	bne	r2,zero,90bce70 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 90bcec8:	e03fff15 	stw	zero,-4(fp)
 90bcecc:	e0bfff17 	ldw	r2,-4(fp)
}
 90bced0:	e037883a 	mov	sp,fp
 90bced4:	dfc00117 	ldw	ra,4(sp)
 90bced8:	df000017 	ldw	fp,0(sp)
 90bcedc:	dec00204 	addi	sp,sp,8
 90bcee0:	f800283a 	ret

090bcee4 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 90bcee4:	defffa04 	addi	sp,sp,-24
 90bcee8:	dfc00515 	stw	ra,20(sp)
 90bceec:	df000415 	stw	fp,16(sp)
 90bcef0:	df000404 	addi	fp,sp,16
 90bcef4:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 90bcef8:	008243b4 	movhi	r2,2318
 90bcefc:	10b55b04 	addi	r2,r2,-10900
 90bcf00:	10800017 	ldw	r2,0(r2)
 90bcf04:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 90bcf08:	00001406 	br	90bcf5c <if_killsocks+0x78>
   {
      if(so->so_pcb)
 90bcf0c:	e0bffe17 	ldw	r2,-8(fp)
 90bcf10:	10800117 	ldw	r2,4(r2)
 90bcf14:	1005003a 	cmpeq	r2,r2,zero
 90bcf18:	1000051e 	bne	r2,zero,90bcf30 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 90bcf1c:	e0bffe17 	ldw	r2,-8(fp)
 90bcf20:	10800117 	ldw	r2,4(r2)
 90bcf24:	10800a17 	ldw	r2,40(r2)
 90bcf28:	e0bffc15 	stw	r2,-16(fp)
 90bcf2c:	00000106 	br	90bcf34 <if_killsocks+0x50>
      else
         so_ifp = NULL;
 90bcf30:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 90bcf34:	e0bffe17 	ldw	r2,-8(fp)
 90bcf38:	10800017 	ldw	r2,0(r2)
 90bcf3c:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 90bcf40:	e0fffc17 	ldw	r3,-16(fp)
 90bcf44:	e0bfff17 	ldw	r2,-4(fp)
 90bcf48:	1880021e 	bne	r3,r2,90bcf54 <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 90bcf4c:	e13ffe17 	ldw	r4,-8(fp)
 90bcf50:	90ae4e40 	call	90ae4e4 <soabort>
      }
      so = next;
 90bcf54:	e0bffd17 	ldw	r2,-12(fp)
 90bcf58:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 90bcf5c:	e0bffe17 	ldw	r2,-8(fp)
 90bcf60:	1004c03a 	cmpne	r2,r2,zero
 90bcf64:	103fe91e 	bne	r2,zero,90bcf0c <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 90bcf68:	e037883a 	mov	sp,fp
 90bcf6c:	dfc00117 	ldw	ra,4(sp)
 90bcf70:	df000017 	ldw	fp,0(sp)
 90bcf74:	dec00204 	addi	sp,sp,8
 90bcf78:	f800283a 	ret

090bcf7c <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 90bcf7c:	defffd04 	addi	sp,sp,-12
 90bcf80:	dfc00215 	stw	ra,8(sp)
 90bcf84:	df000115 	stw	fp,4(sp)
 90bcf88:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 90bcf8c:	01000204 	movi	r4,8
 90bcf90:	90bce480 	call	90bce48 <reg_type>
 90bcf94:	1005003a 	cmpeq	r2,r2,zero
 90bcf98:	1000061e 	bne	r2,zero,90bcfb4 <ip_init+0x38>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 90bcf9c:	01024374 	movhi	r4,2317
 90bcfa0:	21004604 	addi	r4,r4,280
 90bcfa4:	90828380 	call	9082838 <puts>
#endif
      return(1);
 90bcfa8:	00800044 	movi	r2,1
 90bcfac:	e0bfff15 	stw	r2,-4(fp)
 90bcfb0:	00002b06 	br	90bd060 <ip_init+0xe4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 90bcfb4:	008243b4 	movhi	r2,2318
 90bcfb8:	10b66404 	addi	r2,r2,-9840
 90bcfbc:	1009883a 	mov	r4,r2
 90bcfc0:	01801404 	movi	r6,80
 90bcfc4:	000b883a 	mov	r5,zero
 90bcfc8:	90823f80 	call	90823f8 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 90bcfcc:	00c243b4 	movhi	r3,2318
 90bcfd0:	18f66404 	addi	r3,r3,-9840
 90bcfd4:	00800084 	movi	r2,2
 90bcfd8:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 90bcfdc:	00c243b4 	movhi	r3,2318
 90bcfe0:	18f66404 	addi	r3,r3,-9840
 90bcfe4:	00801004 	movi	r2,64
 90bcfe8:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 90bcfec:	d0a05117 	ldw	r2,-32444(gp)
 90bcff0:	11000f24 	muli	r4,r2,60
 90bcff4:	90a9f0c0 	call	90a9f0c <npalloc>
 90bcff8:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 90bcffc:	d0a0c617 	ldw	r2,-31976(gp)
 90bd000:	1004c03a 	cmpne	r2,r2,zero
 90bd004:	1000061e 	bne	r2,zero,90bd020 <ip_init+0xa4>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 90bd008:	01024374 	movhi	r4,2317
 90bd00c:	21005304 	addi	r4,r4,332
 90bd010:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 90bd014:	00bffb04 	movi	r2,-20
 90bd018:	e0bfff15 	stw	r2,-4(fp)
 90bd01c:	00001006 	br	90bd060 <ip_init+0xe4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 90bd020:	d0e0c617 	ldw	r3,-31976(gp)
 90bd024:	d0a05117 	ldw	r2,-32444(gp)
 90bd028:	10800f24 	muli	r2,r2,60
 90bd02c:	1809883a 	mov	r4,r3
 90bd030:	100d883a 	mov	r6,r2
 90bd034:	000b883a 	mov	r5,zero
 90bd038:	90823f80 	call	90823f8 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 90bd03c:	00c243b4 	movhi	r3,2318
 90bd040:	18f66404 	addi	r3,r3,-9840
 90bd044:	00800044 	movi	r2,1
 90bd048:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 90bd04c:	00c243b4 	movhi	r3,2318
 90bd050:	18f66404 	addi	r3,r3,-9840
 90bd054:	00801e04 	movi	r2,120
 90bd058:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 90bd05c:	e03fff15 	stw	zero,-4(fp)
 90bd060:	e0bfff17 	ldw	r2,-4(fp)
}
 90bd064:	e037883a 	mov	sp,fp
 90bd068:	dfc00117 	ldw	ra,4(sp)
 90bd06c:	df000017 	ldw	fp,0(sp)
 90bd070:	dec00204 	addi	sp,sp,8
 90bd074:	f800283a 	ret

090bd078 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 90bd078:	defff804 	addi	sp,sp,-32
 90bd07c:	dfc00715 	stw	ra,28(sp)
 90bd080:	df000615 	stw	fp,24(sp)
 90bd084:	df000604 	addi	fp,sp,24
 90bd088:	e13ffc15 	stw	r4,-16(fp)
 90bd08c:	e17ffd15 	stw	r5,-12(fp)
 90bd090:	e1bffe05 	stb	r6,-8(fp)
 90bd094:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 90bd098:	e0bffc17 	ldw	r2,-16(fp)
 90bd09c:	10800317 	ldw	r2,12(r2)
 90bd0a0:	10fffb04 	addi	r3,r2,-20
 90bd0a4:	e0bffc17 	ldw	r2,-16(fp)
 90bd0a8:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 90bd0ac:	e0bffc17 	ldw	r2,-16(fp)
 90bd0b0:	10800417 	ldw	r2,16(r2)
 90bd0b4:	10c00504 	addi	r3,r2,20
 90bd0b8:	e0bffc17 	ldw	r2,-16(fp)
 90bd0bc:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 90bd0c0:	e0bffc17 	ldw	r2,-16(fp)
 90bd0c4:	10800317 	ldw	r2,12(r2)
 90bd0c8:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 90bd0cc:	e0fffb17 	ldw	r3,-20(fp)
 90bd0d0:	00801144 	movi	r2,69
 90bd0d4:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 90bd0d8:	e0fffb17 	ldw	r3,-20(fp)
 90bd0dc:	e0bfff0b 	ldhu	r2,-4(fp)
 90bd0e0:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 90bd0e4:	e0bffd17 	ldw	r2,-12(fp)
 90bd0e8:	10bfffcc 	andi	r2,r2,65535
 90bd0ec:	1004d23a 	srli	r2,r2,8
 90bd0f0:	10803fcc 	andi	r2,r2,255
 90bd0f4:	1009883a 	mov	r4,r2
 90bd0f8:	e0bffd17 	ldw	r2,-12(fp)
 90bd0fc:	10bfffcc 	andi	r2,r2,65535
 90bd100:	1004923a 	slli	r2,r2,8
 90bd104:	1007883a 	mov	r3,r2
 90bd108:	00bfc004 	movi	r2,-256
 90bd10c:	1884703a 	and	r2,r3,r2
 90bd110:	2084b03a 	or	r2,r4,r2
 90bd114:	1007883a 	mov	r3,r2
 90bd118:	e0bffb17 	ldw	r2,-20(fp)
 90bd11c:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 90bd120:	e0bffc17 	ldw	r2,-16(fp)
 90bd124:	10800417 	ldw	r2,16(r2)
 90bd128:	10bfffcc 	andi	r2,r2,65535
 90bd12c:	1004d23a 	srli	r2,r2,8
 90bd130:	10803fcc 	andi	r2,r2,255
 90bd134:	1009883a 	mov	r4,r2
 90bd138:	e0bffc17 	ldw	r2,-16(fp)
 90bd13c:	10800417 	ldw	r2,16(r2)
 90bd140:	10bfffcc 	andi	r2,r2,65535
 90bd144:	1004923a 	slli	r2,r2,8
 90bd148:	1007883a 	mov	r3,r2
 90bd14c:	00bfc004 	movi	r2,-256
 90bd150:	1884703a 	and	r2,r3,r2
 90bd154:	2084b03a 	or	r2,r4,r2
 90bd158:	1007883a 	mov	r3,r2
 90bd15c:	e0bffb17 	ldw	r2,-20(fp)
 90bd160:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 90bd164:	e0fffb17 	ldw	r3,-20(fp)
 90bd168:	e0bffe03 	ldbu	r2,-8(fp)
 90bd16c:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 90bd170:	e0bffc17 	ldw	r2,-16(fp)
 90bd174:	10800c17 	ldw	r2,48(r2)
 90bd178:	e0bffa15 	stw	r2,-24(fp)
 90bd17c:	e0bffa17 	ldw	r2,-24(fp)
 90bd180:	1005003a 	cmpeq	r2,r2,zero
 90bd184:	1000121e 	bne	r2,zero,90bd1d0 <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 90bd188:	e0bffa17 	ldw	r2,-24(fp)
 90bd18c:	10800043 	ldbu	r2,1(r2)
 90bd190:	10803fcc 	andi	r2,r2,255
 90bd194:	1005003a 	cmpeq	r2,r2,zero
 90bd198:	1000051e 	bne	r2,zero,90bd1b0 <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 90bd19c:	e0bffa17 	ldw	r2,-24(fp)
 90bd1a0:	10c00043 	ldbu	r3,1(r2)
 90bd1a4:	e0bffb17 	ldw	r2,-20(fp)
 90bd1a8:	10c00205 	stb	r3,8(r2)
 90bd1ac:	00000306 	br	90bd1bc <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 90bd1b0:	e0fffb17 	ldw	r3,-20(fp)
 90bd1b4:	00801004 	movi	r2,64
 90bd1b8:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90bd1bc:	e0bffa17 	ldw	r2,-24(fp)
 90bd1c0:	10c00003 	ldbu	r3,0(r2)
 90bd1c4:	e0bffb17 	ldw	r2,-20(fp)
 90bd1c8:	10c00045 	stb	r3,1(r2)
 90bd1cc:	00000506 	br	90bd1e4 <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 90bd1d0:	e0bffb17 	ldw	r2,-20(fp)
 90bd1d4:	00c01004 	movi	r3,64
 90bd1d8:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90bd1dc:	e0bffb17 	ldw	r2,-20(fp)
 90bd1e0:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 90bd1e4:	e0bffb17 	ldw	r2,-20(fp)
 90bd1e8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 90bd1ec:	e13ffb17 	ldw	r4,-20(fp)
 90bd1f0:	01400284 	movi	r5,10
 90bd1f4:	90a3f040 	call	90a3f04 <cksum>
 90bd1f8:	0084303a 	nor	r2,zero,r2
 90bd1fc:	1007883a 	mov	r3,r2
 90bd200:	e0bffb17 	ldw	r2,-20(fp)
 90bd204:	10c0028d 	sth	r3,10(r2)
}
 90bd208:	e037883a 	mov	sp,fp
 90bd20c:	dfc00117 	ldw	ra,4(sp)
 90bd210:	df000017 	ldw	fp,0(sp)
 90bd214:	dec00204 	addi	sp,sp,8
 90bd218:	f800283a 	ret

090bd21c <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 90bd21c:	deffed04 	addi	sp,sp,-76
 90bd220:	dfc01215 	stw	ra,72(sp)
 90bd224:	df001115 	stw	fp,68(sp)
 90bd228:	df001104 	addi	fp,sp,68
 90bd22c:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 90bd230:	e0bffc17 	ldw	r2,-16(fp)
 90bd234:	10800717 	ldw	r2,28(r2)
 90bd238:	1004d63a 	srli	r2,r2,24
 90bd23c:	10c03fcc 	andi	r3,r2,255
 90bd240:	e0bffc17 	ldw	r2,-16(fp)
 90bd244:	10800717 	ldw	r2,28(r2)
 90bd248:	1004d23a 	srli	r2,r2,8
 90bd24c:	10bfc00c 	andi	r2,r2,65280
 90bd250:	1886b03a 	or	r3,r3,r2
 90bd254:	e0bffc17 	ldw	r2,-16(fp)
 90bd258:	10800717 	ldw	r2,28(r2)
 90bd25c:	10bfc00c 	andi	r2,r2,65280
 90bd260:	1004923a 	slli	r2,r2,8
 90bd264:	1886b03a 	or	r3,r3,r2
 90bd268:	e0bffc17 	ldw	r2,-16(fp)
 90bd26c:	10800717 	ldw	r2,28(r2)
 90bd270:	10803fcc 	andi	r2,r2,255
 90bd274:	1004963a 	slli	r2,r2,24
 90bd278:	1884b03a 	or	r2,r3,r2
 90bd27c:	10fc002c 	andhi	r3,r2,61440
 90bd280:	00b80034 	movhi	r2,57344
 90bd284:	1880b31e 	bne	r3,r2,90bd554 <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 90bd288:	e0bffc17 	ldw	r2,-16(fp)
 90bd28c:	10800b17 	ldw	r2,44(r2)
 90bd290:	1005003a 	cmpeq	r2,r2,zero
 90bd294:	1000131e 	bne	r2,zero,90bd2e4 <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 90bd298:	e0bffc17 	ldw	r2,-16(fp)
 90bd29c:	10800b17 	ldw	r2,44(r2)
 90bd2a0:	10800017 	ldw	r2,0(r2)
 90bd2a4:	1005003a 	cmpeq	r2,r2,zero
 90bd2a8:	1000061e 	bne	r2,zero,90bd2c4 <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 90bd2ac:	e0bffc17 	ldw	r2,-16(fp)
 90bd2b0:	10800b17 	ldw	r2,44(r2)
 90bd2b4:	10c00017 	ldw	r3,0(r2)
 90bd2b8:	e0bffc17 	ldw	r2,-16(fp)
 90bd2bc:	10c00615 	stw	r3,24(r2)
 90bd2c0:	00002606 	br	90bd35c <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 90bd2c4:	e0bffc17 	ldw	r2,-16(fp)
 90bd2c8:	11000717 	ldw	r4,28(r2)
 90bd2cc:	e17ffb04 	addi	r5,fp,-20
 90bd2d0:	90bee840 	call	90bee84 <iproute>
 90bd2d4:	1007883a 	mov	r3,r2
 90bd2d8:	e0bffc17 	ldw	r2,-16(fp)
 90bd2dc:	10c00615 	stw	r3,24(r2)
 90bd2e0:	00001e06 	br	90bd35c <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 90bd2e4:	e03ff815 	stw	zero,-32(fp)
 90bd2e8:	00001706 	br	90bd348 <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 90bd2ec:	e0bff817 	ldw	r2,-32(fp)
 90bd2f0:	00c243b4 	movhi	r3,2318
 90bd2f4:	18f41e04 	addi	r3,r3,-12168
 90bd2f8:	1085883a 	add	r2,r2,r2
 90bd2fc:	1085883a 	add	r2,r2,r2
 90bd300:	10c5883a 	add	r2,r2,r3
 90bd304:	10800017 	ldw	r2,0(r2)
 90bd308:	10802b17 	ldw	r2,172(r2)
 90bd30c:	1005003a 	cmpeq	r2,r2,zero
 90bd310:	10000a1e 	bne	r2,zero,90bd33c <ip_write_internal+0x120>
            {
               p->net = nets[i];
 90bd314:	e0bff817 	ldw	r2,-32(fp)
 90bd318:	00c243b4 	movhi	r3,2318
 90bd31c:	18f41e04 	addi	r3,r3,-12168
 90bd320:	1085883a 	add	r2,r2,r2
 90bd324:	1085883a 	add	r2,r2,r2
 90bd328:	10c5883a 	add	r2,r2,r3
 90bd32c:	10c00017 	ldw	r3,0(r2)
 90bd330:	e0bffc17 	ldw	r2,-16(fp)
 90bd334:	10c00615 	stw	r3,24(r2)
               break;
 90bd338:	00000806 	br	90bd35c <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 90bd33c:	e0bff817 	ldw	r2,-32(fp)
 90bd340:	10800044 	addi	r2,r2,1
 90bd344:	e0bff815 	stw	r2,-32(fp)
 90bd348:	00824374 	movhi	r2,2317
 90bd34c:	108c1e04 	addi	r2,r2,12408
 90bd350:	10c00017 	ldw	r3,0(r2)
 90bd354:	e0bff817 	ldw	r2,-32(fp)
 90bd358:	10ffe436 	bltu	r2,r3,90bd2ec <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 90bd35c:	e0bffc17 	ldw	r2,-16(fp)
 90bd360:	10800617 	ldw	r2,24(r2)
 90bd364:	1005003a 	cmpeq	r2,r2,zero
 90bd368:	1000051e 	bne	r2,zero,90bd380 <ip_write_internal+0x164>
 90bd36c:	e0bffc17 	ldw	r2,-16(fp)
 90bd370:	10800617 	ldw	r2,24(r2)
 90bd374:	10802b17 	ldw	r2,172(r2)
 90bd378:	1004c03a 	cmpne	r2,r2,zero
 90bd37c:	10002e1e 	bne	r2,zero,90bd438 <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 90bd380:	00824374 	movhi	r2,2317
 90bd384:	108c1d04 	addi	r2,r2,12404
 90bd388:	10800017 	ldw	r2,0(r2)
 90bd38c:	1080840c 	andi	r2,r2,528
 90bd390:	1005003a 	cmpeq	r2,r2,zero
 90bd394:	1000181e 	bne	r2,zero,90bd3f8 <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 90bd398:	e0bffc17 	ldw	r2,-16(fp)
 90bd39c:	11800417 	ldw	r6,16(r2)
 90bd3a0:	e0bffc17 	ldw	r2,-16(fp)
 90bd3a4:	10800717 	ldw	r2,28(r2)
 90bd3a8:	11c03fcc 	andi	r7,r2,255
 90bd3ac:	e0bffc17 	ldw	r2,-16(fp)
 90bd3b0:	10800717 	ldw	r2,28(r2)
 90bd3b4:	1004d23a 	srli	r2,r2,8
 90bd3b8:	11003fcc 	andi	r4,r2,255
 90bd3bc:	e0bffc17 	ldw	r2,-16(fp)
 90bd3c0:	10800717 	ldw	r2,28(r2)
 90bd3c4:	1004d43a 	srli	r2,r2,16
 90bd3c8:	10c03fcc 	andi	r3,r2,255
 90bd3cc:	e0bffc17 	ldw	r2,-16(fp)
 90bd3d0:	10800717 	ldw	r2,28(r2)
 90bd3d4:	1004d63a 	srli	r2,r2,24
 90bd3d8:	d9000015 	stw	r4,0(sp)
 90bd3dc:	d8c00115 	stw	r3,4(sp)
 90bd3e0:	d8800215 	stw	r2,8(sp)
 90bd3e4:	01024374 	movhi	r4,2317
 90bd3e8:	21005d04 	addi	r4,r4,372
 90bd3ec:	e17ffc17 	ldw	r5,-16(fp)
 90bd3f0:	90825100 	call	9082510 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 90bd3f4:	90a94880 	call	90a9488 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 90bd3f8:	008243b4 	movhi	r2,2318
 90bd3fc:	10b66404 	addi	r2,r2,-9840
 90bd400:	10800b17 	ldw	r2,44(r2)
 90bd404:	10c00044 	addi	r3,r2,1
 90bd408:	008243b4 	movhi	r2,2318
 90bd40c:	10b66404 	addi	r2,r2,-9840
 90bd410:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd414:	01000084 	movi	r4,2
 90bd418:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90bd41c:	e13ffc17 	ldw	r4,-16(fp)
 90bd420:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd424:	01000084 	movi	r4,2
 90bd428:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 90bd42c:	00bff7c4 	movi	r2,-33
 90bd430:	e0bffd15 	stw	r2,-12(fp)
 90bd434:	00015306 	br	90bd984 <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 90bd438:	e0bffc17 	ldw	r2,-16(fp)
 90bd43c:	11000717 	ldw	r4,28(r2)
 90bd440:	e0bffc17 	ldw	r2,-16(fp)
 90bd444:	11400617 	ldw	r5,24(r2)
 90bd448:	90c20e40 	call	90c20e4 <lookup_mcast>
 90bd44c:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 90bd450:	e0bff917 	ldw	r2,-28(fp)
 90bd454:	1005003a 	cmpeq	r2,r2,zero
 90bd458:	10001f1e 	bne	r2,zero,90bd4d8 <ip_write_internal+0x2bc>
 90bd45c:	e0bffc17 	ldw	r2,-16(fp)
 90bd460:	10800b17 	ldw	r2,44(r2)
 90bd464:	1005003a 	cmpeq	r2,r2,zero
 90bd468:	1000061e 	bne	r2,zero,90bd484 <ip_write_internal+0x268>
 90bd46c:	e0bffc17 	ldw	r2,-16(fp)
 90bd470:	10800b17 	ldw	r2,44(r2)
 90bd474:	10800143 	ldbu	r2,5(r2)
 90bd478:	10803fcc 	andi	r2,r2,255
 90bd47c:	1005003a 	cmpeq	r2,r2,zero
 90bd480:	1000151e 	bne	r2,zero,90bd4d8 <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 90bd484:	e0fffc17 	ldw	r3,-16(fp)
 90bd488:	00800204 	movi	r2,8
 90bd48c:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 90bd490:	e13ffc17 	ldw	r4,-16(fp)
 90bd494:	90bf0f00 	call	90bf0f0 <ip_copypkt>
 90bd498:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 90bd49c:	e0bffa17 	ldw	r2,-24(fp)
 90bd4a0:	1005003a 	cmpeq	r2,r2,zero
 90bd4a4:	10000c1e 	bne	r2,zero,90bd4d8 <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 90bd4a8:	01000044 	movi	r4,1
 90bd4ac:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 90bd4b0:	e17ffa17 	ldw	r5,-24(fp)
 90bd4b4:	010243b4 	movhi	r4,2318
 90bd4b8:	21335904 	addi	r4,r4,-12956
 90bd4bc:	90a8e180 	call	90a8e18 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 90bd4c0:	01000044 	movi	r4,1
 90bd4c4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 90bd4c8:	00824374 	movhi	r2,2317
 90bd4cc:	108c4504 	addi	r2,r2,12564
 90bd4d0:	11000017 	ldw	r4,0(r2)
 90bd4d4:	90930640 	call	9093064 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 90bd4d8:	e0bffc17 	ldw	r2,-16(fp)
 90bd4dc:	10800317 	ldw	r2,12(r2)
 90bd4e0:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 90bd4e4:	e0bff717 	ldw	r2,-36(fp)
 90bd4e8:	10800203 	ldbu	r2,8(r2)
 90bd4ec:	10803fcc 	andi	r2,r2,255
 90bd4f0:	1005003a 	cmpeq	r2,r2,zero
 90bd4f4:	10000b1e 	bne	r2,zero,90bd524 <ip_write_internal+0x308>
 90bd4f8:	e0bffc17 	ldw	r2,-16(fp)
 90bd4fc:	10800717 	ldw	r2,28(r2)
 90bd500:	10803fcc 	andi	r2,r2,255
 90bd504:	10801fe0 	cmpeqi	r2,r2,127
 90bd508:	1000061e 	bne	r2,zero,90bd524 <ip_write_internal+0x308>
 90bd50c:	e0bffc17 	ldw	r2,-16(fp)
 90bd510:	10c00717 	ldw	r3,28(r2)
 90bd514:	e0bffc17 	ldw	r2,-16(fp)
 90bd518:	10800617 	ldw	r2,24(r2)
 90bd51c:	10800a17 	ldw	r2,40(r2)
 90bd520:	1880081e 	bne	r3,r2,90bd544 <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd524:	01000084 	movi	r4,2
 90bd528:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90bd52c:	e13ffc17 	ldw	r4,-16(fp)
 90bd530:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd534:	01000084 	movi	r4,2
 90bd538:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 90bd53c:	e03ffd15 	stw	zero,-12(fp)
 90bd540:	00011006 	br	90bd984 <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 90bd544:	e0bffc17 	ldw	r2,-16(fp)
 90bd548:	10800717 	ldw	r2,28(r2)
 90bd54c:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 90bd550:	00004106 	br	90bd658 <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 90bd554:	e0bffc17 	ldw	r2,-16(fp)
 90bd558:	10800717 	ldw	r2,28(r2)
 90bd55c:	10bfffd8 	cmpnei	r2,r2,-1
 90bd560:	1000041e 	bne	r2,zero,90bd574 <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 90bd564:	e0bffc17 	ldw	r2,-16(fp)
 90bd568:	10800717 	ldw	r2,28(r2)
 90bd56c:	e0bffb15 	stw	r2,-20(fp)
 90bd570:	00003906 	br	90bd658 <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 90bd574:	e0bffc17 	ldw	r2,-16(fp)
 90bd578:	11000717 	ldw	r4,28(r2)
 90bd57c:	e17ffb04 	addi	r5,fp,-20
 90bd580:	90bee840 	call	90bee84 <iproute>
 90bd584:	1007883a 	mov	r3,r2
 90bd588:	e0bffc17 	ldw	r2,-16(fp)
 90bd58c:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 90bd590:	e0bffc17 	ldw	r2,-16(fp)
 90bd594:	10800617 	ldw	r2,24(r2)
 90bd598:	1004c03a 	cmpne	r2,r2,zero
 90bd59c:	10002e1e 	bne	r2,zero,90bd658 <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 90bd5a0:	00824374 	movhi	r2,2317
 90bd5a4:	108c1d04 	addi	r2,r2,12404
 90bd5a8:	10800017 	ldw	r2,0(r2)
 90bd5ac:	1080840c 	andi	r2,r2,528
 90bd5b0:	1005003a 	cmpeq	r2,r2,zero
 90bd5b4:	1000181e 	bne	r2,zero,90bd618 <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 90bd5b8:	e0bffc17 	ldw	r2,-16(fp)
 90bd5bc:	11800417 	ldw	r6,16(r2)
 90bd5c0:	e0bffc17 	ldw	r2,-16(fp)
 90bd5c4:	10800717 	ldw	r2,28(r2)
 90bd5c8:	11c03fcc 	andi	r7,r2,255
 90bd5cc:	e0bffc17 	ldw	r2,-16(fp)
 90bd5d0:	10800717 	ldw	r2,28(r2)
 90bd5d4:	1004d23a 	srli	r2,r2,8
 90bd5d8:	11003fcc 	andi	r4,r2,255
 90bd5dc:	e0bffc17 	ldw	r2,-16(fp)
 90bd5e0:	10800717 	ldw	r2,28(r2)
 90bd5e4:	1004d43a 	srli	r2,r2,16
 90bd5e8:	10c03fcc 	andi	r3,r2,255
 90bd5ec:	e0bffc17 	ldw	r2,-16(fp)
 90bd5f0:	10800717 	ldw	r2,28(r2)
 90bd5f4:	1004d63a 	srli	r2,r2,24
 90bd5f8:	d9000015 	stw	r4,0(sp)
 90bd5fc:	d8c00115 	stw	r3,4(sp)
 90bd600:	d8800215 	stw	r2,8(sp)
 90bd604:	01024374 	movhi	r4,2317
 90bd608:	21005d04 	addi	r4,r4,372
 90bd60c:	e17ffc17 	ldw	r5,-16(fp)
 90bd610:	90825100 	call	9082510 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 90bd614:	90a94880 	call	90a9488 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 90bd618:	008243b4 	movhi	r2,2318
 90bd61c:	10b66404 	addi	r2,r2,-9840
 90bd620:	10800b17 	ldw	r2,44(r2)
 90bd624:	10c00044 	addi	r3,r2,1
 90bd628:	008243b4 	movhi	r2,2318
 90bd62c:	10b66404 	addi	r2,r2,-9840
 90bd630:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd634:	01000084 	movi	r4,2
 90bd638:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90bd63c:	e13ffc17 	ldw	r4,-16(fp)
 90bd640:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd644:	01000084 	movi	r4,2
 90bd648:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 90bd64c:	00fff7c4 	movi	r3,-33
 90bd650:	e0fffd15 	stw	r3,-12(fp)
 90bd654:	0000cb06 	br	90bd984 <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 90bd658:	00824374 	movhi	r2,2317
 90bd65c:	108c1d04 	addi	r2,r2,12404
 90bd660:	10800017 	ldw	r2,0(r2)
 90bd664:	1080800c 	andi	r2,r2,512
 90bd668:	1005003a 	cmpeq	r2,r2,zero
 90bd66c:	1000231e 	bne	r2,zero,90bd6fc <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 90bd670:	e0bffc17 	ldw	r2,-16(fp)
 90bd674:	11400417 	ldw	r5,16(r2)
 90bd678:	e0bffc17 	ldw	r2,-16(fp)
 90bd67c:	10800717 	ldw	r2,28(r2)
 90bd680:	11803fcc 	andi	r6,r2,255
 90bd684:	e0bffc17 	ldw	r2,-16(fp)
 90bd688:	10800717 	ldw	r2,28(r2)
 90bd68c:	1004d23a 	srli	r2,r2,8
 90bd690:	11c03fcc 	andi	r7,r2,255
 90bd694:	e0bffc17 	ldw	r2,-16(fp)
 90bd698:	10800717 	ldw	r2,28(r2)
 90bd69c:	1004d43a 	srli	r2,r2,16
 90bd6a0:	10c03fcc 	andi	r3,r2,255
 90bd6a4:	e0bffc17 	ldw	r2,-16(fp)
 90bd6a8:	10800717 	ldw	r2,28(r2)
 90bd6ac:	1004d63a 	srli	r2,r2,24
 90bd6b0:	d8c00015 	stw	r3,0(sp)
 90bd6b4:	d8800115 	stw	r2,4(sp)
 90bd6b8:	01024374 	movhi	r4,2317
 90bd6bc:	21006d04 	addi	r4,r4,436
 90bd6c0:	90825100 	call	9082510 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 90bd6c4:	e0bffb17 	ldw	r2,-20(fp)
 90bd6c8:	11403fcc 	andi	r5,r2,255
 90bd6cc:	e0bffb17 	ldw	r2,-20(fp)
 90bd6d0:	1004d23a 	srli	r2,r2,8
 90bd6d4:	11803fcc 	andi	r6,r2,255
 90bd6d8:	e0bffb17 	ldw	r2,-20(fp)
 90bd6dc:	1004d43a 	srli	r2,r2,16
 90bd6e0:	11c03fcc 	andi	r7,r2,255
 90bd6e4:	e0bffb17 	ldw	r2,-20(fp)
 90bd6e8:	1004d63a 	srli	r2,r2,24
 90bd6ec:	d8800015 	stw	r2,0(sp)
 90bd6f0:	01024374 	movhi	r4,2317
 90bd6f4:	21007604 	addi	r4,r4,472
 90bd6f8:	90825100 	call	9082510 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 90bd6fc:	e0bffc17 	ldw	r2,-16(fp)
 90bd700:	10800617 	ldw	r2,24(r2)
 90bd704:	10c00a17 	ldw	r3,40(r2)
 90bd708:	e0bffc17 	ldw	r2,-16(fp)
 90bd70c:	10800717 	ldw	r2,28(r2)
 90bd710:	18802a1e 	bne	r3,r2,90bd7bc <ip_write_internal+0x5a0>
 90bd714:	e0bffc17 	ldw	r2,-16(fp)
 90bd718:	10800717 	ldw	r2,28(r2)
 90bd71c:	10803fcc 	andi	r2,r2,255
 90bd720:	10801fe0 	cmpeqi	r2,r2,127
 90bd724:	1000251e 	bne	r2,zero,90bd7bc <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 90bd728:	e0bffc17 	ldw	r2,-16(fp)
 90bd72c:	10800617 	ldw	r2,24(r2)
 90bd730:	10802a17 	ldw	r2,168(r2)
 90bd734:	1080020c 	andi	r2,r2,8
 90bd738:	1004c03a 	cmpne	r2,r2,zero
 90bd73c:	10000a1e 	bne	r2,zero,90bd768 <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 90bd740:	90a94880 	call	90a9488 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd744:	01000084 	movi	r4,2
 90bd748:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90bd74c:	e13ffc17 	ldw	r4,-16(fp)
 90bd750:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd754:	01000084 	movi	r4,2
 90bd758:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 90bd75c:	00bffd44 	movi	r2,-11
 90bd760:	e0bffd15 	stw	r2,-12(fp)
 90bd764:	00008706 	br	90bd984 <ip_write_internal+0x768>
      }
      p->type = IPTP;
 90bd768:	e0fffc17 	ldw	r3,-16(fp)
 90bd76c:	00800204 	movi	r2,8
 90bd770:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90bd774:	0009883a 	mov	r4,zero
 90bd778:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 90bd77c:	01000044 	movi	r4,1
 90bd780:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 90bd784:	e17ffc17 	ldw	r5,-16(fp)
 90bd788:	010243b4 	movhi	r4,2318
 90bd78c:	21335904 	addi	r4,r4,-12956
 90bd790:	90a8e180 	call	90a8e18 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 90bd794:	01000044 	movi	r4,1
 90bd798:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 90bd79c:	0009883a 	mov	r4,zero
 90bd7a0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 90bd7a4:	00824374 	movhi	r2,2317
 90bd7a8:	108c4504 	addi	r2,r2,12564
 90bd7ac:	11000017 	ldw	r4,0(r2)
 90bd7b0:	90930640 	call	9093064 <OSSemPost>

      return SUCCESS;
 90bd7b4:	e03ffd15 	stw	zero,-12(fp)
 90bd7b8:	00007206 	br	90bd984 <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 90bd7bc:	e0bffc17 	ldw	r2,-16(fp)
 90bd7c0:	10800a17 	ldw	r2,40(r2)
 90bd7c4:	1080040c 	andi	r2,r2,16
 90bd7c8:	1005003a 	cmpeq	r2,r2,zero
 90bd7cc:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 90bd7d0:	90a8c840 	call	90a8c84 <pk_get_max_intrsafe_buf_len>
 90bd7d4:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 90bd7d8:	e0bff603 	ldbu	r2,-40(fp)
 90bd7dc:	1004c03a 	cmpne	r2,r2,zero
 90bd7e0:	10000e1e 	bne	r2,zero,90bd81c <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 90bd7e4:	e0bffc17 	ldw	r2,-16(fp)
 90bd7e8:	10800617 	ldw	r2,24(r2)
 90bd7ec:	10800917 	ldw	r2,36(r2)
 90bd7f0:	e0fff317 	ldw	r3,-52(fp)
 90bd7f4:	e0ffff15 	stw	r3,-4(fp)
 90bd7f8:	e0bffe15 	stw	r2,-8(fp)
 90bd7fc:	e0bfff17 	ldw	r2,-4(fp)
 90bd800:	e0fffe17 	ldw	r3,-8(fp)
 90bd804:	10c0022e 	bgeu	r2,r3,90bd810 <ip_write_internal+0x5f4>
 90bd808:	e0bfff17 	ldw	r2,-4(fp)
 90bd80c:	e0bffe15 	stw	r2,-8(fp)
 90bd810:	e0fffe17 	ldw	r3,-8(fp)
 90bd814:	e0fff515 	stw	r3,-44(fp)
 90bd818:	00000406 	br	90bd82c <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 90bd81c:	e0bffc17 	ldw	r2,-16(fp)
 90bd820:	10800617 	ldw	r2,24(r2)
 90bd824:	10800917 	ldw	r2,36(r2)
 90bd828:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 90bd82c:	e0bffc17 	ldw	r2,-16(fp)
 90bd830:	10c00417 	ldw	r3,16(r2)
 90bd834:	e0bffc17 	ldw	r2,-16(fp)
 90bd838:	10800617 	ldw	r2,24(r2)
 90bd83c:	10800817 	ldw	r2,32(r2)
 90bd840:	1887883a 	add	r3,r3,r2
 90bd844:	e0bff517 	ldw	r2,-44(fp)
 90bd848:	10c0072e 	bgeu	r2,r3,90bd868 <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 90bd84c:	e17ffb17 	ldw	r5,-20(fp)
 90bd850:	e13ffc17 	ldw	r4,-16(fp)
 90bd854:	90be4f40 	call	90be4f4 <ip_fragment>
 90bd858:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 90bd85c:	e0bff217 	ldw	r2,-56(fp)
 90bd860:	e0bffd15 	stw	r2,-12(fp)
 90bd864:	00004706 	br	90bd984 <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 90bd868:	e0bff603 	ldbu	r2,-40(fp)
 90bd86c:	1004c03a 	cmpne	r2,r2,zero
 90bd870:	1000401e 	bne	r2,zero,90bd974 <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd874:	01000084 	movi	r4,2
 90bd878:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 90bd87c:	e0bffc17 	ldw	r2,-16(fp)
 90bd880:	10c00417 	ldw	r3,16(r2)
 90bd884:	e0bffc17 	ldw	r2,-16(fp)
 90bd888:	10800617 	ldw	r2,24(r2)
 90bd88c:	10800817 	ldw	r2,32(r2)
 90bd890:	1889883a 	add	r4,r3,r2
 90bd894:	90a88440 	call	90a8844 <pk_alloc>
 90bd898:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd89c:	01000084 	movi	r4,2
 90bd8a0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 90bd8a4:	e0bff417 	ldw	r2,-48(fp)
 90bd8a8:	1004c03a 	cmpne	r2,r2,zero
 90bd8ac:	1000091e 	bne	r2,zero,90bd8d4 <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd8b0:	01000084 	movi	r4,2
 90bd8b4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90bd8b8:	e13ffc17 	ldw	r4,-16(fp)
 90bd8bc:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd8c0:	01000084 	movi	r4,2
 90bd8c4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 90bd8c8:	00fffac4 	movi	r3,-21
 90bd8cc:	e0fffd15 	stw	r3,-12(fp)
 90bd8d0:	00002c06 	br	90bd984 <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 90bd8d4:	e0bff417 	ldw	r2,-48(fp)
 90bd8d8:	10c00117 	ldw	r3,4(r2)
 90bd8dc:	e0bffc17 	ldw	r2,-16(fp)
 90bd8e0:	10800617 	ldw	r2,24(r2)
 90bd8e4:	10800817 	ldw	r2,32(r2)
 90bd8e8:	1887883a 	add	r3,r3,r2
 90bd8ec:	e0bff417 	ldw	r2,-48(fp)
 90bd8f0:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 90bd8f4:	e0bff417 	ldw	r2,-48(fp)
 90bd8f8:	10c00317 	ldw	r3,12(r2)
 90bd8fc:	e0bffc17 	ldw	r2,-16(fp)
 90bd900:	11400317 	ldw	r5,12(r2)
 90bd904:	e0bffc17 	ldw	r2,-16(fp)
 90bd908:	10800417 	ldw	r2,16(r2)
 90bd90c:	1809883a 	mov	r4,r3
 90bd910:	100d883a 	mov	r6,r2
 90bd914:	90822780 	call	9082278 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 90bd918:	e0bffc17 	ldw	r2,-16(fp)
 90bd91c:	10c00417 	ldw	r3,16(r2)
 90bd920:	e0bff417 	ldw	r2,-48(fp)
 90bd924:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 90bd928:	e0bffc17 	ldw	r2,-16(fp)
 90bd92c:	10c00617 	ldw	r3,24(r2)
 90bd930:	e0bff417 	ldw	r2,-48(fp)
 90bd934:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 90bd938:	e0bffc17 	ldw	r2,-16(fp)
 90bd93c:	10c00717 	ldw	r3,28(r2)
 90bd940:	e0bff417 	ldw	r2,-48(fp)
 90bd944:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd948:	01000084 	movi	r4,2
 90bd94c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90bd950:	e13ffc17 	ldw	r4,-16(fp)
 90bd954:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd958:	01000084 	movi	r4,2
 90bd95c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 90bd960:	e17ffb17 	ldw	r5,-20(fp)
 90bd964:	e13ff417 	ldw	r4,-48(fp)
 90bd968:	90a1b540 	call	90a1b54 <ip2mac>
 90bd96c:	e0bffd15 	stw	r2,-12(fp)
 90bd970:	00000406 	br	90bd984 <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 90bd974:	e17ffb17 	ldw	r5,-20(fp)
 90bd978:	e13ffc17 	ldw	r4,-16(fp)
 90bd97c:	90a1b540 	call	90a1b54 <ip2mac>
 90bd980:	e0bffd15 	stw	r2,-12(fp)
 90bd984:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 90bd988:	e037883a 	mov	sp,fp
 90bd98c:	dfc00117 	ldw	ra,4(sp)
 90bd990:	df000017 	ldw	fp,0(sp)
 90bd994:	dec00204 	addi	sp,sp,8
 90bd998:	f800283a 	ret

090bd99c <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 90bd99c:	defff904 	addi	sp,sp,-28
 90bd9a0:	dfc00615 	stw	ra,24(sp)
 90bd9a4:	df000515 	stw	fp,20(sp)
 90bd9a8:	df000504 	addi	fp,sp,20
 90bd9ac:	e17fff15 	stw	r5,-4(fp)
 90bd9b0:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90bd9b4:	008243b4 	movhi	r2,2318
 90bd9b8:	10b66404 	addi	r2,r2,-9840
 90bd9bc:	10800917 	ldw	r2,36(r2)
 90bd9c0:	10c00044 	addi	r3,r2,1
 90bd9c4:	008243b4 	movhi	r2,2318
 90bd9c8:	10b66404 	addi	r2,r2,-9840
 90bd9cc:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 90bd9d0:	e0bfff17 	ldw	r2,-4(fp)
 90bd9d4:	10800317 	ldw	r2,12(r2)
 90bd9d8:	10fffb04 	addi	r3,r2,-20
 90bd9dc:	e0bfff17 	ldw	r2,-4(fp)
 90bd9e0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 90bd9e4:	e0bfff17 	ldw	r2,-4(fp)
 90bd9e8:	10800417 	ldw	r2,16(r2)
 90bd9ec:	10c00504 	addi	r3,r2,20
 90bd9f0:	e0bfff17 	ldw	r2,-4(fp)
 90bd9f4:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 90bd9f8:	e0bfff17 	ldw	r2,-4(fp)
 90bd9fc:	10800317 	ldw	r2,12(r2)
 90bda00:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 90bda04:	e0fffd17 	ldw	r3,-12(fp)
 90bda08:	00801144 	movi	r2,69
 90bda0c:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 90bda10:	e0bffd17 	ldw	r2,-12(fp)
 90bda14:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 90bda18:	d0a05017 	ldw	r2,-32448(gp)
 90bda1c:	10bfffcc 	andi	r2,r2,65535
 90bda20:	1004d23a 	srli	r2,r2,8
 90bda24:	10803fcc 	andi	r2,r2,255
 90bda28:	1009883a 	mov	r4,r2
 90bda2c:	d0a05017 	ldw	r2,-32448(gp)
 90bda30:	10bfffcc 	andi	r2,r2,65535
 90bda34:	1004923a 	slli	r2,r2,8
 90bda38:	1007883a 	mov	r3,r2
 90bda3c:	00bfc004 	movi	r2,-256
 90bda40:	1884703a 	and	r2,r3,r2
 90bda44:	2084b03a 	or	r2,r4,r2
 90bda48:	1007883a 	mov	r3,r2
 90bda4c:	e0bffd17 	ldw	r2,-12(fp)
 90bda50:	10c0010d 	sth	r3,4(r2)
   uid++;
 90bda54:	d0a05017 	ldw	r2,-32448(gp)
 90bda58:	10800044 	addi	r2,r2,1
 90bda5c:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 90bda60:	e0bfff17 	ldw	r2,-4(fp)
 90bda64:	10800417 	ldw	r2,16(r2)
 90bda68:	10bfffcc 	andi	r2,r2,65535
 90bda6c:	1004d23a 	srli	r2,r2,8
 90bda70:	10803fcc 	andi	r2,r2,255
 90bda74:	1009883a 	mov	r4,r2
 90bda78:	e0bfff17 	ldw	r2,-4(fp)
 90bda7c:	10800417 	ldw	r2,16(r2)
 90bda80:	10bfffcc 	andi	r2,r2,65535
 90bda84:	1004923a 	slli	r2,r2,8
 90bda88:	1007883a 	mov	r3,r2
 90bda8c:	00bfc004 	movi	r2,-256
 90bda90:	1884703a 	and	r2,r3,r2
 90bda94:	2084b03a 	or	r2,r4,r2
 90bda98:	1007883a 	mov	r3,r2
 90bda9c:	e0bffd17 	ldw	r2,-12(fp)
 90bdaa0:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 90bdaa4:	e0fffd17 	ldw	r3,-12(fp)
 90bdaa8:	e0bffe03 	ldbu	r2,-8(fp)
 90bdaac:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90bdab0:	e0bffd17 	ldw	r2,-12(fp)
 90bdab4:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 90bdab8:	00801004 	movi	r2,64
 90bdabc:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 90bdac0:	e0bfff17 	ldw	r2,-4(fp)
 90bdac4:	10800717 	ldw	r2,28(r2)
 90bdac8:	1004d63a 	srli	r2,r2,24
 90bdacc:	10c03fcc 	andi	r3,r2,255
 90bdad0:	e0bfff17 	ldw	r2,-4(fp)
 90bdad4:	10800717 	ldw	r2,28(r2)
 90bdad8:	1004d23a 	srli	r2,r2,8
 90bdadc:	10bfc00c 	andi	r2,r2,65280
 90bdae0:	1886b03a 	or	r3,r3,r2
 90bdae4:	e0bfff17 	ldw	r2,-4(fp)
 90bdae8:	10800717 	ldw	r2,28(r2)
 90bdaec:	10bfc00c 	andi	r2,r2,65280
 90bdaf0:	1004923a 	slli	r2,r2,8
 90bdaf4:	1886b03a 	or	r3,r3,r2
 90bdaf8:	e0bfff17 	ldw	r2,-4(fp)
 90bdafc:	10800717 	ldw	r2,28(r2)
 90bdb00:	10803fcc 	andi	r2,r2,255
 90bdb04:	1004963a 	slli	r2,r2,24
 90bdb08:	1884b03a 	or	r2,r3,r2
 90bdb0c:	10fc002c 	andhi	r3,r2,61440
 90bdb10:	00b80034 	movhi	r2,57344
 90bdb14:	1880081e 	bne	r3,r2,90bdb38 <ip_write+0x19c>
 90bdb18:	e0bfff17 	ldw	r2,-4(fp)
 90bdb1c:	10800b17 	ldw	r2,44(r2)
 90bdb20:	1005003a 	cmpeq	r2,r2,zero
 90bdb24:	1000041e 	bne	r2,zero,90bdb38 <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 90bdb28:	e0bfff17 	ldw	r2,-4(fp)
 90bdb2c:	10800b17 	ldw	r2,44(r2)
 90bdb30:	10800103 	ldbu	r2,4(r2)
 90bdb34:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 90bdb38:	e0bfff17 	ldw	r2,-4(fp)
 90bdb3c:	10800c17 	ldw	r2,48(r2)
 90bdb40:	e0bffb15 	stw	r2,-20(fp)
 90bdb44:	e0bffb17 	ldw	r2,-20(fp)
 90bdb48:	1005003a 	cmpeq	r2,r2,zero
 90bdb4c:	1000121e 	bne	r2,zero,90bdb98 <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 90bdb50:	e0bffb17 	ldw	r2,-20(fp)
 90bdb54:	10800043 	ldbu	r2,1(r2)
 90bdb58:	10803fcc 	andi	r2,r2,255
 90bdb5c:	1005003a 	cmpeq	r2,r2,zero
 90bdb60:	1000051e 	bne	r2,zero,90bdb78 <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 90bdb64:	e0bffb17 	ldw	r2,-20(fp)
 90bdb68:	10c00043 	ldbu	r3,1(r2)
 90bdb6c:	e0bffd17 	ldw	r2,-12(fp)
 90bdb70:	10c00205 	stb	r3,8(r2)
 90bdb74:	00000306 	br	90bdb84 <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 90bdb78:	e0fffd17 	ldw	r3,-12(fp)
 90bdb7c:	e0bffc03 	ldbu	r2,-16(fp)
 90bdb80:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90bdb84:	e0bffb17 	ldw	r2,-20(fp)
 90bdb88:	10c00003 	ldbu	r3,0(r2)
 90bdb8c:	e0bffd17 	ldw	r2,-12(fp)
 90bdb90:	10c00045 	stb	r3,1(r2)
 90bdb94:	00000506 	br	90bdbac <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 90bdb98:	e0bffd17 	ldw	r2,-12(fp)
 90bdb9c:	e0fffc03 	ldbu	r3,-16(fp)
 90bdba0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90bdba4:	e0bffd17 	ldw	r2,-12(fp)
 90bdba8:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 90bdbac:	e13ffd17 	ldw	r4,-12(fp)
 90bdbb0:	01400284 	movi	r5,10
 90bdbb4:	90a3f040 	call	90a3f04 <cksum>
 90bdbb8:	0084303a 	nor	r2,zero,r2
 90bdbbc:	1007883a 	mov	r3,r2
 90bdbc0:	e0bffd17 	ldw	r2,-12(fp)
 90bdbc4:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 90bdbc8:	e13fff17 	ldw	r4,-4(fp)
 90bdbcc:	90bd21c0 	call	90bd21c <ip_write_internal>
}
 90bdbd0:	e037883a 	mov	sp,fp
 90bdbd4:	dfc00117 	ldw	ra,4(sp)
 90bdbd8:	df000017 	ldw	fp,0(sp)
 90bdbdc:	dec00204 	addi	sp,sp,8
 90bdbe0:	f800283a 	ret

090bdbe4 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 90bdbe4:	defff504 	addi	sp,sp,-44
 90bdbe8:	dfc00a15 	stw	ra,40(sp)
 90bdbec:	df000915 	stw	fp,36(sp)
 90bdbf0:	df000904 	addi	fp,sp,36
 90bdbf4:	e17ffe15 	stw	r5,-8(fp)
 90bdbf8:	e1bfff15 	stw	r6,-4(fp)
 90bdbfc:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 90bdc00:	00800504 	movi	r2,20
 90bdc04:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90bdc08:	008243b4 	movhi	r2,2318
 90bdc0c:	10b66404 	addi	r2,r2,-9840
 90bdc10:	10800917 	ldw	r2,36(r2)
 90bdc14:	10c00044 	addi	r3,r2,1
 90bdc18:	008243b4 	movhi	r2,2318
 90bdc1c:	10b66404 	addi	r2,r2,-9840
 90bdc20:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 90bdc24:	e0bfff17 	ldw	r2,-4(fp)
 90bdc28:	e0bff815 	stw	r2,-32(fp)
 90bdc2c:	00000c06 	br	90bdc60 <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 90bdc30:	e0bff817 	ldw	r2,-32(fp)
 90bdc34:	10800003 	ldbu	r2,0(r2)
 90bdc38:	10803fcc 	andi	r2,r2,255
 90bdc3c:	10800520 	cmpeqi	r2,r2,20
 90bdc40:	1000011e 	bne	r2,zero,90bdc48 <ip_write2+0x64>
 90bdc44:	00000306 	br	90bdc54 <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 90bdc48:	e0bff903 	ldbu	r2,-28(fp)
 90bdc4c:	10800104 	addi	r2,r2,4
 90bdc50:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 90bdc54:	e0bff817 	ldw	r2,-32(fp)
 90bdc58:	10800044 	addi	r2,r2,1
 90bdc5c:	e0bff815 	stw	r2,-32(fp)
 90bdc60:	e0bff817 	ldw	r2,-32(fp)
 90bdc64:	10800003 	ldbu	r2,0(r2)
 90bdc68:	10803fcc 	andi	r2,r2,255
 90bdc6c:	1004c03a 	cmpne	r2,r2,zero
 90bdc70:	103fef1e 	bne	r2,zero,90bdc30 <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 90bdc74:	e0bff903 	ldbu	r2,-28(fp)
 90bdc78:	108000cc 	andi	r2,r2,3
 90bdc7c:	1005003a 	cmpeq	r2,r2,zero
 90bdc80:	1000071e 	bne	r2,zero,90bdca0 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 90bdc84:	e0bff903 	ldbu	r2,-28(fp)
 90bdc88:	108000cc 	andi	r2,r2,3
 90bdc8c:	1007883a 	mov	r3,r2
 90bdc90:	00800104 	movi	r2,4
 90bdc94:	10c5c83a 	sub	r2,r2,r3
 90bdc98:	e0bff745 	stb	r2,-35(fp)
 90bdc9c:	00000106 	br	90bdca4 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 90bdca0:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 90bdca4:	e0bffe17 	ldw	r2,-8(fp)
 90bdca8:	11000317 	ldw	r4,12(r2)
 90bdcac:	e0fff903 	ldbu	r3,-28(fp)
 90bdcb0:	e0bff743 	ldbu	r2,-35(fp)
 90bdcb4:	1885883a 	add	r2,r3,r2
 90bdcb8:	2087c83a 	sub	r3,r4,r2
 90bdcbc:	e0bffe17 	ldw	r2,-8(fp)
 90bdcc0:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 90bdcc4:	e0bffe17 	ldw	r2,-8(fp)
 90bdcc8:	11000417 	ldw	r4,16(r2)
 90bdccc:	e0fff903 	ldbu	r3,-28(fp)
 90bdcd0:	e0bff743 	ldbu	r2,-35(fp)
 90bdcd4:	1885883a 	add	r2,r3,r2
 90bdcd8:	2087883a 	add	r3,r4,r2
 90bdcdc:	e0bffe17 	ldw	r2,-8(fp)
 90bdce0:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 90bdce4:	e0bffe17 	ldw	r2,-8(fp)
 90bdce8:	10800317 	ldw	r2,12(r2)
 90bdcec:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 90bdcf0:	e0fff903 	ldbu	r3,-28(fp)
 90bdcf4:	e0bff743 	ldbu	r2,-35(fp)
 90bdcf8:	1885883a 	add	r2,r3,r2
 90bdcfc:	1005d0ba 	srai	r2,r2,2
 90bdd00:	10801014 	ori	r2,r2,64
 90bdd04:	1007883a 	mov	r3,r2
 90bdd08:	e0bffc17 	ldw	r2,-16(fp)
 90bdd0c:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 90bdd10:	e0bffc17 	ldw	r2,-16(fp)
 90bdd14:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 90bdd18:	d0a05017 	ldw	r2,-32448(gp)
 90bdd1c:	10bfffcc 	andi	r2,r2,65535
 90bdd20:	1004d23a 	srli	r2,r2,8
 90bdd24:	10803fcc 	andi	r2,r2,255
 90bdd28:	1009883a 	mov	r4,r2
 90bdd2c:	d0a05017 	ldw	r2,-32448(gp)
 90bdd30:	10bfffcc 	andi	r2,r2,65535
 90bdd34:	1004923a 	slli	r2,r2,8
 90bdd38:	1007883a 	mov	r3,r2
 90bdd3c:	00bfc004 	movi	r2,-256
 90bdd40:	1884703a 	and	r2,r3,r2
 90bdd44:	2084b03a 	or	r2,r4,r2
 90bdd48:	1007883a 	mov	r3,r2
 90bdd4c:	e0bffc17 	ldw	r2,-16(fp)
 90bdd50:	10c0010d 	sth	r3,4(r2)
   uid++;
 90bdd54:	d0a05017 	ldw	r2,-32448(gp)
 90bdd58:	10800044 	addi	r2,r2,1
 90bdd5c:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 90bdd60:	e0bffe17 	ldw	r2,-8(fp)
 90bdd64:	10800417 	ldw	r2,16(r2)
 90bdd68:	10bfffcc 	andi	r2,r2,65535
 90bdd6c:	1004d23a 	srli	r2,r2,8
 90bdd70:	10803fcc 	andi	r2,r2,255
 90bdd74:	1009883a 	mov	r4,r2
 90bdd78:	e0bffe17 	ldw	r2,-8(fp)
 90bdd7c:	10800417 	ldw	r2,16(r2)
 90bdd80:	10bfffcc 	andi	r2,r2,65535
 90bdd84:	1004923a 	slli	r2,r2,8
 90bdd88:	1007883a 	mov	r3,r2
 90bdd8c:	00bfc004 	movi	r2,-256
 90bdd90:	1884703a 	and	r2,r3,r2
 90bdd94:	2084b03a 	or	r2,r4,r2
 90bdd98:	1007883a 	mov	r3,r2
 90bdd9c:	e0bffc17 	ldw	r2,-16(fp)
 90bdda0:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 90bdda4:	e0fffc17 	ldw	r3,-16(fp)
 90bdda8:	e0bffd03 	ldbu	r2,-12(fp)
 90bddac:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90bddb0:	e0bffc17 	ldw	r2,-16(fp)
 90bddb4:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 90bddb8:	00801004 	movi	r2,64
 90bddbc:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 90bddc0:	e0bffe17 	ldw	r2,-8(fp)
 90bddc4:	10800717 	ldw	r2,28(r2)
 90bddc8:	1004d63a 	srli	r2,r2,24
 90bddcc:	10c03fcc 	andi	r3,r2,255
 90bddd0:	e0bffe17 	ldw	r2,-8(fp)
 90bddd4:	10800717 	ldw	r2,28(r2)
 90bddd8:	1004d23a 	srli	r2,r2,8
 90bdddc:	10bfc00c 	andi	r2,r2,65280
 90bdde0:	1886b03a 	or	r3,r3,r2
 90bdde4:	e0bffe17 	ldw	r2,-8(fp)
 90bdde8:	10800717 	ldw	r2,28(r2)
 90bddec:	10bfc00c 	andi	r2,r2,65280
 90bddf0:	1004923a 	slli	r2,r2,8
 90bddf4:	1886b03a 	or	r3,r3,r2
 90bddf8:	e0bffe17 	ldw	r2,-8(fp)
 90bddfc:	10800717 	ldw	r2,28(r2)
 90bde00:	10803fcc 	andi	r2,r2,255
 90bde04:	1004963a 	slli	r2,r2,24
 90bde08:	1884b03a 	or	r2,r3,r2
 90bde0c:	10fc002c 	andhi	r3,r2,61440
 90bde10:	00b80034 	movhi	r2,57344
 90bde14:	1880081e 	bne	r3,r2,90bde38 <ip_write2+0x254>
 90bde18:	e0bffe17 	ldw	r2,-8(fp)
 90bde1c:	10800b17 	ldw	r2,44(r2)
 90bde20:	1005003a 	cmpeq	r2,r2,zero
 90bde24:	1000041e 	bne	r2,zero,90bde38 <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 90bde28:	e0bffe17 	ldw	r2,-8(fp)
 90bde2c:	10800b17 	ldw	r2,44(r2)
 90bde30:	10800103 	ldbu	r2,4(r2)
 90bde34:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 90bde38:	e0bffe17 	ldw	r2,-8(fp)
 90bde3c:	10800c17 	ldw	r2,48(r2)
 90bde40:	e0bffa15 	stw	r2,-24(fp)
 90bde44:	e0bffa17 	ldw	r2,-24(fp)
 90bde48:	1005003a 	cmpeq	r2,r2,zero
 90bde4c:	1000121e 	bne	r2,zero,90bde98 <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 90bde50:	e0bffa17 	ldw	r2,-24(fp)
 90bde54:	10800043 	ldbu	r2,1(r2)
 90bde58:	10803fcc 	andi	r2,r2,255
 90bde5c:	1005003a 	cmpeq	r2,r2,zero
 90bde60:	1000051e 	bne	r2,zero,90bde78 <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 90bde64:	e0bffa17 	ldw	r2,-24(fp)
 90bde68:	10c00043 	ldbu	r3,1(r2)
 90bde6c:	e0bffc17 	ldw	r2,-16(fp)
 90bde70:	10c00205 	stb	r3,8(r2)
 90bde74:	00000306 	br	90bde84 <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 90bde78:	e0fffc17 	ldw	r3,-16(fp)
 90bde7c:	e0bffb03 	ldbu	r2,-20(fp)
 90bde80:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90bde84:	e0bffa17 	ldw	r2,-24(fp)
 90bde88:	10c00003 	ldbu	r3,0(r2)
 90bde8c:	e0bffc17 	ldw	r2,-16(fp)
 90bde90:	10c00045 	stb	r3,1(r2)
 90bde94:	00000506 	br	90bdeac <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 90bde98:	e0bffc17 	ldw	r2,-16(fp)
 90bde9c:	e0fffb03 	ldbu	r3,-20(fp)
 90bdea0:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90bdea4:	e0bffc17 	ldw	r2,-16(fp)
 90bdea8:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 90bdeac:	e0bffe17 	ldw	r2,-8(fp)
 90bdeb0:	10800317 	ldw	r2,12(r2)
 90bdeb4:	10800504 	addi	r2,r2,20
 90bdeb8:	e0bff815 	stw	r2,-32(fp)
 90bdebc:	00000f06 	br	90bdefc <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 90bdec0:	e0bfff17 	ldw	r2,-4(fp)
 90bdec4:	10800003 	ldbu	r2,0(r2)
 90bdec8:	10803fcc 	andi	r2,r2,255
 90bdecc:	10800520 	cmpeqi	r2,r2,20
 90bded0:	1000011e 	bne	r2,zero,90bded8 <ip_write2+0x2f4>
 90bded4:	00000606 	br	90bdef0 <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 90bded8:	e0fff817 	ldw	r3,-32(fp)
 90bdedc:	00812504 	movi	r2,1172
 90bdee0:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 90bdee4:	e0bff817 	ldw	r2,-32(fp)
 90bdee8:	10800104 	addi	r2,r2,4
 90bdeec:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 90bdef0:	e0bfff17 	ldw	r2,-4(fp)
 90bdef4:	10800044 	addi	r2,r2,1
 90bdef8:	e0bfff15 	stw	r2,-4(fp)
 90bdefc:	e0bfff17 	ldw	r2,-4(fp)
 90bdf00:	10800003 	ldbu	r2,0(r2)
 90bdf04:	10803fcc 	andi	r2,r2,255
 90bdf08:	1004c03a 	cmpne	r2,r2,zero
 90bdf0c:	103fec1e 	bne	r2,zero,90bdec0 <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 90bdf10:	e03ff705 	stb	zero,-36(fp)
 90bdf14:	00000806 	br	90bdf38 <ip_write2+0x354>
 90bdf18:	e0bff703 	ldbu	r2,-36(fp)
 90bdf1c:	1007883a 	mov	r3,r2
 90bdf20:	e0bff817 	ldw	r2,-32(fp)
 90bdf24:	1885883a 	add	r2,r3,r2
 90bdf28:	10000005 	stb	zero,0(r2)
 90bdf2c:	e0bff703 	ldbu	r2,-36(fp)
 90bdf30:	10800044 	addi	r2,r2,1
 90bdf34:	e0bff705 	stb	r2,-36(fp)
 90bdf38:	e0fff703 	ldbu	r3,-36(fp)
 90bdf3c:	e0bff743 	ldbu	r2,-35(fp)
 90bdf40:	18bff536 	bltu	r3,r2,90bdf18 <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 90bdf44:	e0fff903 	ldbu	r3,-28(fp)
 90bdf48:	e0bff743 	ldbu	r2,-35(fp)
 90bdf4c:	1887883a 	add	r3,r3,r2
 90bdf50:	1804d7fa 	srli	r2,r3,31
 90bdf54:	10c5883a 	add	r2,r2,r3
 90bdf58:	1005d07a 	srai	r2,r2,1
 90bdf5c:	100b883a 	mov	r5,r2
 90bdf60:	e13ffc17 	ldw	r4,-16(fp)
 90bdf64:	90a3f040 	call	90a3f04 <cksum>
 90bdf68:	0084303a 	nor	r2,zero,r2
 90bdf6c:	1007883a 	mov	r3,r2
 90bdf70:	e0bffc17 	ldw	r2,-16(fp)
 90bdf74:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 90bdf78:	e13ffe17 	ldw	r4,-8(fp)
 90bdf7c:	90bd21c0 	call	90bd21c <ip_write_internal>
}
 90bdf80:	e037883a 	mov	sp,fp
 90bdf84:	dfc00117 	ldw	ra,4(sp)
 90bdf88:	df000017 	ldw	fp,0(sp)
 90bdf8c:	dec00204 	addi	sp,sp,8
 90bdf90:	f800283a 	ret

090bdf94 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 90bdf94:	defffc04 	addi	sp,sp,-16
 90bdf98:	dfc00315 	stw	ra,12(sp)
 90bdf9c:	df000215 	stw	fp,8(sp)
 90bdfa0:	df000204 	addi	fp,sp,8
 90bdfa4:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90bdfa8:	008243b4 	movhi	r2,2318
 90bdfac:	10b66404 	addi	r2,r2,-9840
 90bdfb0:	10800917 	ldw	r2,36(r2)
 90bdfb4:	10c00044 	addi	r3,r2,1
 90bdfb8:	008243b4 	movhi	r2,2318
 90bdfbc:	10b66404 	addi	r2,r2,-9840
 90bdfc0:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 90bdfc4:	e0bfff17 	ldw	r2,-4(fp)
 90bdfc8:	10800317 	ldw	r2,12(r2)
 90bdfcc:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 90bdfd0:	e0bffe17 	ldw	r2,-8(fp)
 90bdfd4:	1080010b 	ldhu	r2,4(r2)
 90bdfd8:	10bfffcc 	andi	r2,r2,65535
 90bdfdc:	1004c03a 	cmpne	r2,r2,zero
 90bdfe0:	1000121e 	bne	r2,zero,90be02c <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 90bdfe4:	d0a05017 	ldw	r2,-32448(gp)
 90bdfe8:	10bfffcc 	andi	r2,r2,65535
 90bdfec:	1004d23a 	srli	r2,r2,8
 90bdff0:	10803fcc 	andi	r2,r2,255
 90bdff4:	1009883a 	mov	r4,r2
 90bdff8:	d0a05017 	ldw	r2,-32448(gp)
 90bdffc:	10bfffcc 	andi	r2,r2,65535
 90be000:	1004923a 	slli	r2,r2,8
 90be004:	1007883a 	mov	r3,r2
 90be008:	00bfc004 	movi	r2,-256
 90be00c:	1884703a 	and	r2,r3,r2
 90be010:	2084b03a 	or	r2,r4,r2
 90be014:	1007883a 	mov	r3,r2
 90be018:	e0bffe17 	ldw	r2,-8(fp)
 90be01c:	10c0010d 	sth	r3,4(r2)
      uid++;
 90be020:	d0a05017 	ldw	r2,-32448(gp)
 90be024:	10800044 	addi	r2,r2,1
 90be028:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90be02c:	e0bffe17 	ldw	r2,-8(fp)
 90be030:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 90be034:	e13ffe17 	ldw	r4,-8(fp)
 90be038:	01400284 	movi	r5,10
 90be03c:	90a3f040 	call	90a3f04 <cksum>
 90be040:	0084303a 	nor	r2,zero,r2
 90be044:	1007883a 	mov	r3,r2
 90be048:	e0bffe17 	ldw	r2,-8(fp)
 90be04c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 90be050:	e13fff17 	ldw	r4,-4(fp)
 90be054:	90bd21c0 	call	90bd21c <ip_write_internal>
}
 90be058:	e037883a 	mov	sp,fp
 90be05c:	dfc00117 	ldw	ra,4(sp)
 90be060:	df000017 	ldw	fp,0(sp)
 90be064:	dec00204 	addi	sp,sp,8
 90be068:	f800283a 	ret

090be06c <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 90be06c:	deffed04 	addi	sp,sp,-76
 90be070:	dfc01215 	stw	ra,72(sp)
 90be074:	df001115 	stw	fp,68(sp)
 90be078:	df001104 	addi	fp,sp,68
 90be07c:	e13ffa15 	stw	r4,-24(fp)
 90be080:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 90be084:	008243b4 	movhi	r2,2318
 90be088:	10b66404 	addi	r2,r2,-9840
 90be08c:	10801017 	ldw	r2,64(r2)
 90be090:	10c00044 	addi	r3,r2,1
 90be094:	008243b4 	movhi	r2,2318
 90be098:	10b66404 	addi	r2,r2,-9840
 90be09c:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 90be0a0:	e0bffa17 	ldw	r2,-24(fp)
 90be0a4:	10800317 	ldw	r2,12(r2)
 90be0a8:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 90be0ac:	e0bff117 	ldw	r2,-60(fp)
 90be0b0:	10800003 	ldbu	r2,0(r2)
 90be0b4:	10803fcc 	andi	r2,r2,255
 90be0b8:	108003cc 	andi	r2,r2,15
 90be0bc:	1085883a 	add	r2,r2,r2
 90be0c0:	1085883a 	add	r2,r2,r2
 90be0c4:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 90be0c8:	e0bffa17 	ldw	r2,-24(fp)
 90be0cc:	10800417 	ldw	r2,16(r2)
 90be0d0:	1007883a 	mov	r3,r2
 90be0d4:	e0bff017 	ldw	r2,-64(fp)
 90be0d8:	1885c83a 	sub	r2,r3,r2
 90be0dc:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 90be0e0:	e0bffa17 	ldw	r2,-24(fp)
 90be0e4:	10800617 	ldw	r2,24(r2)
 90be0e8:	11000917 	ldw	r4,36(r2)
 90be0ec:	e0bffa17 	ldw	r2,-24(fp)
 90be0f0:	10800617 	ldw	r2,24(r2)
 90be0f4:	10c00817 	ldw	r3,32(r2)
 90be0f8:	e0bff017 	ldw	r2,-64(fp)
 90be0fc:	1885883a 	add	r2,r3,r2
 90be100:	2085c83a 	sub	r2,r4,r2
 90be104:	10bffe04 	addi	r2,r2,-8
 90be108:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 90be10c:	e0bff817 	ldw	r2,-32(fp)
 90be110:	10801028 	cmpgeui	r2,r2,64
 90be114:	1000041e 	bne	r2,zero,90be128 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 90be118:	90a94880 	call	90a9488 <dtrap>
      return ENP_LOGIC;
 90be11c:	00bffd44 	movi	r2,-11
 90be120:	e0bffe15 	stw	r2,-8(fp)
 90be124:	0000ed06 	br	90be4dc <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 90be128:	e0bffa17 	ldw	r2,-24(fp)
 90be12c:	10c00417 	ldw	r3,16(r2)
 90be130:	e0bff817 	ldw	r2,-32(fp)
 90be134:	1885203a 	divu	r2,r3,r2
 90be138:	10800044 	addi	r2,r2,1
 90be13c:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 90be140:	e0bffa17 	ldw	r2,-24(fp)
 90be144:	10c00417 	ldw	r3,16(r2)
 90be148:	e0bff717 	ldw	r2,-36(fp)
 90be14c:	1885883a 	add	r2,r3,r2
 90be150:	10ffffc4 	addi	r3,r2,-1
 90be154:	e0bff717 	ldw	r2,-36(fp)
 90be158:	1885203a 	divu	r2,r3,r2
 90be15c:	10c001c4 	addi	r3,r2,7
 90be160:	00bffe04 	movi	r2,-8
 90be164:	1884703a 	and	r2,r3,r2
 90be168:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 90be16c:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 90be170:	e0bff117 	ldw	r2,-60(fp)
 90be174:	1080018b 	ldhu	r2,6(r2)
 90be178:	10bfffcc 	andi	r2,r2,65535
 90be17c:	1004d23a 	srli	r2,r2,8
 90be180:	10803fcc 	andi	r2,r2,255
 90be184:	1009883a 	mov	r4,r2
 90be188:	e0bff117 	ldw	r2,-60(fp)
 90be18c:	1080018b 	ldhu	r2,6(r2)
 90be190:	10bfffcc 	andi	r2,r2,65535
 90be194:	1004923a 	slli	r2,r2,8
 90be198:	1007883a 	mov	r3,r2
 90be19c:	00bfc004 	movi	r2,-256
 90be1a0:	1884703a 	and	r2,r3,r2
 90be1a4:	2084b03a 	or	r2,r4,r2
 90be1a8:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 90be1ac:	e0ffef0b 	ldhu	r3,-68(fp)
 90be1b0:	00bffff4 	movhi	r2,65535
 90be1b4:	1087ffc4 	addi	r2,r2,8191
 90be1b8:	1884703a 	and	r2,r3,r2
 90be1bc:	1005003a 	cmpeq	r2,r2,zero
 90be1c0:	1000081e 	bne	r2,zero,90be1e4 <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 90be1c4:	e0ffef0b 	ldhu	r3,-68(fp)
 90be1c8:	00bffff4 	movhi	r2,65535
 90be1cc:	1087ffc4 	addi	r2,r2,8191
 90be1d0:	1884703a 	and	r2,r3,r2
 90be1d4:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 90be1d8:	e0bff617 	ldw	r2,-40(fp)
 90be1dc:	100490fa 	slli	r2,r2,3
 90be1e0:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 90be1e4:	e0bffa17 	ldw	r2,-24(fp)
 90be1e8:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 90be1ec:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 90be1f0:	0000b506 	br	90be4c8 <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 90be1f4:	e0bff317 	ldw	r2,-52(fp)
 90be1f8:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 90be1fc:	e0bffa17 	ldw	r2,-24(fp)
 90be200:	10800317 	ldw	r2,12(r2)
 90be204:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 90be208:	e0bff917 	ldw	r2,-28(fp)
 90be20c:	e0fff417 	ldw	r3,-48(fp)
 90be210:	e0ffff15 	stw	r3,-4(fp)
 90be214:	e0bffd15 	stw	r2,-12(fp)
 90be218:	e0bfff17 	ldw	r2,-4(fp)
 90be21c:	e0fffd17 	ldw	r3,-12(fp)
 90be220:	10c0020e 	bge	r2,r3,90be22c <ip_fragment_lc+0x1c0>
 90be224:	e0bfff17 	ldw	r2,-4(fp)
 90be228:	e0bffd15 	stw	r2,-12(fp)
 90be22c:	e0bff017 	ldw	r2,-64(fp)
 90be230:	e0fffd17 	ldw	r3,-12(fp)
 90be234:	1885883a 	add	r2,r3,r2
 90be238:	1007883a 	mov	r3,r2
 90be23c:	e0bffa17 	ldw	r2,-24(fp)
 90be240:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 90be244:	e0fff417 	ldw	r3,-48(fp)
 90be248:	e0bff917 	ldw	r2,-28(fp)
 90be24c:	1885c83a 	sub	r2,r3,r2
 90be250:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 90be254:	e0bffa17 	ldw	r2,-24(fp)
 90be258:	10800417 	ldw	r2,16(r2)
 90be25c:	10bfffcc 	andi	r2,r2,65535
 90be260:	1004d23a 	srli	r2,r2,8
 90be264:	10803fcc 	andi	r2,r2,255
 90be268:	1009883a 	mov	r4,r2
 90be26c:	e0bffa17 	ldw	r2,-24(fp)
 90be270:	10800417 	ldw	r2,16(r2)
 90be274:	10bfffcc 	andi	r2,r2,65535
 90be278:	1004923a 	slli	r2,r2,8
 90be27c:	1007883a 	mov	r3,r2
 90be280:	00bfc004 	movi	r2,-256
 90be284:	1884703a 	and	r2,r3,r2
 90be288:	2084b03a 	or	r2,r4,r2
 90be28c:	1007883a 	mov	r3,r2
 90be290:	e0bff117 	ldw	r2,-60(fp)
 90be294:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 90be298:	e0bff617 	ldw	r2,-40(fp)
 90be29c:	1004d0fa 	srli	r2,r2,3
 90be2a0:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 90be2a4:	e0bff417 	ldw	r2,-48(fp)
 90be2a8:	10800090 	cmplti	r2,r2,2
 90be2ac:	1000031e 	bne	r2,zero,90be2bc <ip_fragment_lc+0x250>
 90be2b0:	00880004 	movi	r2,8192
 90be2b4:	e0bffc0d 	sth	r2,-16(fp)
 90be2b8:	00000106 	br	90be2c0 <ip_fragment_lc+0x254>
 90be2bc:	e03ffc0d 	sth	zero,-16(fp)
 90be2c0:	e0bff50b 	ldhu	r2,-44(fp)
 90be2c4:	e0fffc0b 	ldhu	r3,-16(fp)
 90be2c8:	1884b03a 	or	r2,r3,r2
 90be2cc:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 90be2d0:	e0bfef0b 	ldhu	r2,-68(fp)
 90be2d4:	1088000c 	andi	r2,r2,8192
 90be2d8:	1005003a 	cmpeq	r2,r2,zero
 90be2dc:	1000031e 	bne	r2,zero,90be2ec <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 90be2e0:	e0bff50b 	ldhu	r2,-44(fp)
 90be2e4:	10880014 	ori	r2,r2,8192
 90be2e8:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 90be2ec:	e0bff50b 	ldhu	r2,-44(fp)
 90be2f0:	1004d23a 	srli	r2,r2,8
 90be2f4:	10803fcc 	andi	r2,r2,255
 90be2f8:	1009883a 	mov	r4,r2
 90be2fc:	e0bff50b 	ldhu	r2,-44(fp)
 90be300:	1004923a 	slli	r2,r2,8
 90be304:	1007883a 	mov	r3,r2
 90be308:	00bfc004 	movi	r2,-256
 90be30c:	1884703a 	and	r2,r3,r2
 90be310:	2084b03a 	or	r2,r4,r2
 90be314:	1007883a 	mov	r3,r2
 90be318:	e0bff117 	ldw	r2,-60(fp)
 90be31c:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 90be320:	e0bff417 	ldw	r2,-48(fp)
 90be324:	10800090 	cmplti	r2,r2,2
 90be328:	1000401e 	bne	r2,zero,90be42c <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be32c:	01000084 	movi	r4,2
 90be330:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 90be334:	e0fff417 	ldw	r3,-48(fp)
 90be338:	e0bff017 	ldw	r2,-64(fp)
 90be33c:	1887883a 	add	r3,r3,r2
 90be340:	00824374 	movhi	r2,2317
 90be344:	108c1b04 	addi	r2,r2,12396
 90be348:	10800017 	ldw	r2,0(r2)
 90be34c:	1885883a 	add	r2,r3,r2
 90be350:	1009883a 	mov	r4,r2
 90be354:	90a88440 	call	90a8844 <pk_alloc>
 90be358:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be35c:	01000084 	movi	r4,2
 90be360:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 90be364:	e0bff317 	ldw	r2,-52(fp)
 90be368:	1004c03a 	cmpne	r2,r2,zero
 90be36c:	1000111e 	bne	r2,zero,90be3b4 <ip_fragment_lc+0x348>
         {
            dtrap();
 90be370:	90a94880 	call	90a9488 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90be374:	01000084 	movi	r4,2
 90be378:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90be37c:	e13ffa17 	ldw	r4,-24(fp)
 90be380:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be384:	01000084 	movi	r4,2
 90be388:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 90be38c:	008243b4 	movhi	r2,2318
 90be390:	10b66404 	addi	r2,r2,-9840
 90be394:	10801117 	ldw	r2,68(r2)
 90be398:	10c00044 	addi	r3,r2,1
 90be39c:	008243b4 	movhi	r2,2318
 90be3a0:	10b66404 	addi	r2,r2,-9840
 90be3a4:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 90be3a8:	00bffa84 	movi	r2,-22
 90be3ac:	e0bffe15 	stw	r2,-8(fp)
 90be3b0:	00004a06 	br	90be4dc <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 90be3b4:	e0bffa17 	ldw	r2,-24(fp)
 90be3b8:	10c00617 	ldw	r3,24(r2)
 90be3bc:	e0bff317 	ldw	r2,-52(fp)
 90be3c0:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 90be3c4:	e0bffa17 	ldw	r2,-24(fp)
 90be3c8:	10c00717 	ldw	r3,28(r2)
 90be3cc:	e0bff317 	ldw	r2,-52(fp)
 90be3d0:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 90be3d4:	e0bff317 	ldw	r2,-52(fp)
 90be3d8:	11000317 	ldw	r4,12(r2)
 90be3dc:	e0bffa17 	ldw	r2,-24(fp)
 90be3e0:	10800317 	ldw	r2,12(r2)
 90be3e4:	e0fff017 	ldw	r3,-64(fp)
 90be3e8:	100b883a 	mov	r5,r2
 90be3ec:	180d883a 	mov	r6,r3
 90be3f0:	90822780 	call	9082278 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 90be3f4:	e0bff317 	ldw	r2,-52(fp)
 90be3f8:	10c00317 	ldw	r3,12(r2)
 90be3fc:	e0bff017 	ldw	r2,-64(fp)
 90be400:	1889883a 	add	r4,r3,r2
 90be404:	e0bffa17 	ldw	r2,-24(fp)
 90be408:	10c00317 	ldw	r3,12(r2)
 90be40c:	e0bff017 	ldw	r2,-64(fp)
 90be410:	1887883a 	add	r3,r3,r2
 90be414:	e0bff917 	ldw	r2,-28(fp)
 90be418:	1885883a 	add	r2,r3,r2
 90be41c:	e0fff417 	ldw	r3,-48(fp)
 90be420:	100b883a 	mov	r5,r2
 90be424:	180d883a 	mov	r6,r3
 90be428:	90822780 	call	9082278 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 90be42c:	e0bff117 	ldw	r2,-60(fp)
 90be430:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 90be434:	e13ff117 	ldw	r4,-60(fp)
 90be438:	01400284 	movi	r5,10
 90be43c:	90a3f040 	call	90a3f04 <cksum>
 90be440:	0084303a 	nor	r2,zero,r2
 90be444:	1007883a 	mov	r3,r2
 90be448:	e0bff117 	ldw	r2,-60(fp)
 90be44c:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 90be450:	e13ffa17 	ldw	r4,-24(fp)
 90be454:	e17ffb17 	ldw	r5,-20(fp)
 90be458:	90a1b540 	call	90a1b54 <ip2mac>
 90be45c:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 90be460:	008243b4 	movhi	r2,2318
 90be464:	10b66404 	addi	r2,r2,-9840
 90be468:	10801217 	ldw	r2,72(r2)
 90be46c:	10c00044 	addi	r3,r2,1
 90be470:	008243b4 	movhi	r2,2318
 90be474:	10b66404 	addi	r2,r2,-9840
 90be478:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 90be47c:	e0bff217 	ldw	r2,-56(fp)
 90be480:	1004403a 	cmpge	r2,r2,zero
 90be484:	10000c1e 	bne	r2,zero,90be4b8 <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 90be488:	e0bff417 	ldw	r2,-48(fp)
 90be48c:	10800090 	cmplti	r2,r2,2
 90be490:	1000061e 	bne	r2,zero,90be4ac <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90be494:	01000084 	movi	r4,2
 90be498:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 90be49c:	e13ff317 	ldw	r4,-52(fp)
 90be4a0:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be4a4:	01000084 	movi	r4,2
 90be4a8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         }
         return e;
 90be4ac:	e0fff217 	ldw	r3,-56(fp)
 90be4b0:	e0fffe15 	stw	r3,-8(fp)
 90be4b4:	00000906 	br	90be4dc <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 90be4b8:	e0bff617 	ldw	r2,-40(fp)
 90be4bc:	e0fff917 	ldw	r3,-28(fp)
 90be4c0:	10c5883a 	add	r2,r2,r3
 90be4c4:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 90be4c8:	e0bff417 	ldw	r2,-48(fp)
 90be4cc:	10800088 	cmpgei	r2,r2,2
 90be4d0:	103f481e 	bne	r2,zero,90be1f4 <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 90be4d4:	e0bff217 	ldw	r2,-56(fp)
 90be4d8:	e0bffe15 	stw	r2,-8(fp)
 90be4dc:	e0bffe17 	ldw	r2,-8(fp)
}
 90be4e0:	e037883a 	mov	sp,fp
 90be4e4:	dfc00117 	ldw	ra,4(sp)
 90be4e8:	df000017 	ldw	fp,0(sp)
 90be4ec:	dec00204 	addi	sp,sp,8
 90be4f0:	f800283a 	ret

090be4f4 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 90be4f4:	deffed04 	addi	sp,sp,-76
 90be4f8:	dfc01215 	stw	ra,72(sp)
 90be4fc:	df001115 	stw	fp,68(sp)
 90be500:	df001104 	addi	fp,sp,68
 90be504:	e13ffa15 	stw	r4,-24(fp)
 90be508:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 90be50c:	e0bffa17 	ldw	r2,-24(fp)
 90be510:	10800317 	ldw	r2,12(r2)
 90be514:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 90be518:	e0bff817 	ldw	r2,-32(fp)
 90be51c:	1080018b 	ldhu	r2,6(r2)
 90be520:	10bfffcc 	andi	r2,r2,65535
 90be524:	1004d23a 	srli	r2,r2,8
 90be528:	10bfffcc 	andi	r2,r2,65535
 90be52c:	10c03fcc 	andi	r3,r2,255
 90be530:	e0bff817 	ldw	r2,-32(fp)
 90be534:	1080018b 	ldhu	r2,6(r2)
 90be538:	10bfffcc 	andi	r2,r2,65535
 90be53c:	1004923a 	slli	r2,r2,8
 90be540:	10bfc00c 	andi	r2,r2,65280
 90be544:	1884b03a 	or	r2,r3,r2
 90be548:	1090000c 	andi	r2,r2,16384
 90be54c:	1005003a 	cmpeq	r2,r2,zero
 90be550:	10001a1e 	bne	r2,zero,90be5bc <ip_fragment+0xc8>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90be554:	01000084 	movi	r4,2
 90be558:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90be55c:	e13ffa17 	ldw	r4,-24(fp)
 90be560:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be564:	01000084 	movi	r4,2
 90be568:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 90be56c:	008243b4 	movhi	r2,2318
 90be570:	10b66404 	addi	r2,r2,-9840
 90be574:	10801117 	ldw	r2,68(r2)
 90be578:	10c00044 	addi	r3,r2,1
 90be57c:	008243b4 	movhi	r2,2318
 90be580:	10b66404 	addi	r2,r2,-9840
 90be584:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 90be588:	e0bff817 	ldw	r2,-32(fp)
 90be58c:	11000317 	ldw	r4,12(r2)
 90be590:	e0bffa17 	ldw	r2,-24(fp)
 90be594:	10800617 	ldw	r2,24(r2)
 90be598:	11400a17 	ldw	r5,40(r2)
 90be59c:	e0bffa17 	ldw	r2,-24(fp)
 90be5a0:	10800617 	ldw	r2,24(r2)
 90be5a4:	d8800015 	stw	r2,0(sp)
 90be5a8:	e1bff817 	ldw	r6,-32(fp)
 90be5ac:	01c00104 	movi	r7,4
 90be5b0:	90c9dc00 	call	90c9dc0 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 90be5b4:	e03ffe15 	stw	zero,-8(fp)
 90be5b8:	00015306 	br	90beb08 <ip_fragment+0x614>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 90be5bc:	90a8c840 	call	90a8c84 <pk_get_max_intrsafe_buf_len>
 90be5c0:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 90be5c4:	e0bffa17 	ldw	r2,-24(fp)
 90be5c8:	10800617 	ldw	r2,24(r2)
 90be5cc:	10800917 	ldw	r2,36(r2)
 90be5d0:	e0fff917 	ldw	r3,-28(fp)
 90be5d4:	e0ffff15 	stw	r3,-4(fp)
 90be5d8:	e0bffd15 	stw	r2,-12(fp)
 90be5dc:	e0bfff17 	ldw	r2,-4(fp)
 90be5e0:	e0fffd17 	ldw	r3,-12(fp)
 90be5e4:	10c0022e 	bgeu	r2,r3,90be5f0 <ip_fragment+0xfc>
 90be5e8:	e0bfff17 	ldw	r2,-4(fp)
 90be5ec:	e0bffd15 	stw	r2,-12(fp)
 90be5f0:	e0fffd17 	ldw	r3,-12(fp)
 90be5f4:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 90be5f8:	e0bff817 	ldw	r2,-32(fp)
 90be5fc:	10800003 	ldbu	r2,0(r2)
 90be600:	108003cc 	andi	r2,r2,15
 90be604:	1085883a 	add	r2,r2,r2
 90be608:	1085883a 	add	r2,r2,r2
 90be60c:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 90be610:	e0bffa17 	ldw	r2,-24(fp)
 90be614:	10800617 	ldw	r2,24(r2)
 90be618:	10800817 	ldw	r2,32(r2)
 90be61c:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 90be620:	e0fff7c3 	ldbu	r3,-33(fp)
 90be624:	e0bff58b 	ldhu	r2,-42(fp)
 90be628:	10c5c83a 	sub	r2,r2,r3
 90be62c:	1007883a 	mov	r3,r2
 90be630:	e0bff783 	ldbu	r2,-34(fp)
 90be634:	1885c83a 	sub	r2,r3,r2
 90be638:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 90be63c:	e0fff70b 	ldhu	r3,-36(fp)
 90be640:	00bffe04 	movi	r2,-8
 90be644:	1884703a 	and	r2,r3,r2
 90be648:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 90be64c:	e0bff817 	ldw	r2,-32(fp)
 90be650:	1080008b 	ldhu	r2,2(r2)
 90be654:	10bfffcc 	andi	r2,r2,65535
 90be658:	1004d23a 	srli	r2,r2,8
 90be65c:	10803fcc 	andi	r2,r2,255
 90be660:	1009883a 	mov	r4,r2
 90be664:	e0bff817 	ldw	r2,-32(fp)
 90be668:	1080008b 	ldhu	r2,2(r2)
 90be66c:	10bfffcc 	andi	r2,r2,65535
 90be670:	1004923a 	slli	r2,r2,8
 90be674:	1007883a 	mov	r3,r2
 90be678:	00bfc004 	movi	r2,-256
 90be67c:	1884703a 	and	r2,r3,r2
 90be680:	2084b03a 	or	r2,r4,r2
 90be684:	1007883a 	mov	r3,r2
 90be688:	e0bff7c3 	ldbu	r2,-33(fp)
 90be68c:	1885c83a 	sub	r2,r3,r2
 90be690:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 90be694:	e0fff68b 	ldhu	r3,-38(fp)
 90be698:	e0bff70b 	ldhu	r2,-36(fp)
 90be69c:	1885203a 	divu	r2,r3,r2
 90be6a0:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 90be6a4:	e13ff68b 	ldhu	r4,-38(fp)
 90be6a8:	e0fff70b 	ldhu	r3,-36(fp)
 90be6ac:	20c5203a 	divu	r2,r4,r3
 90be6b0:	10c5383a 	mul	r2,r2,r3
 90be6b4:	2085c83a 	sub	r2,r4,r2
 90be6b8:	e0bff60d 	sth	r2,-40(fp)
 90be6bc:	e0bff60b 	ldhu	r2,-40(fp)
 90be6c0:	1005003a 	cmpeq	r2,r2,zero
 90be6c4:	1000031e 	bne	r2,zero,90be6d4 <ip_fragment+0x1e0>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 90be6c8:	e0bff50b 	ldhu	r2,-44(fp)
 90be6cc:	10800044 	addi	r2,r2,1
 90be6d0:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 90be6d4:	e0bff50b 	ldhu	r2,-44(fp)
 90be6d8:	10800128 	cmpgeui	r2,r2,4
 90be6dc:	10000a1e 	bne	r2,zero,90be708 <ip_fragment+0x214>
 90be6e0:	e0bffa17 	ldw	r2,-24(fp)
 90be6e4:	10800a17 	ldw	r2,40(r2)
 90be6e8:	1080040c 	andi	r2,r2,16
 90be6ec:	1004c03a 	cmpne	r2,r2,zero
 90be6f0:	1000051e 	bne	r2,zero,90be708 <ip_fragment+0x214>
   {
      return (ip_fragment_lc (p, firsthop));
 90be6f4:	e13ffa17 	ldw	r4,-24(fp)
 90be6f8:	e17ffb17 	ldw	r5,-20(fp)
 90be6fc:	90be06c0 	call	90be06c <ip_fragment_lc>
 90be700:	e0bffe15 	stw	r2,-8(fp)
 90be704:	00010006 	br	90beb08 <ip_fragment+0x614>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90be708:	e0bff817 	ldw	r2,-32(fp)
 90be70c:	1080018b 	ldhu	r2,6(r2)
 90be710:	10bfffcc 	andi	r2,r2,65535
 90be714:	1004d23a 	srli	r2,r2,8
 90be718:	10803fcc 	andi	r2,r2,255
 90be71c:	1009883a 	mov	r4,r2
 90be720:	e0bff817 	ldw	r2,-32(fp)
 90be724:	1080018b 	ldhu	r2,6(r2)
 90be728:	10bfffcc 	andi	r2,r2,65535
 90be72c:	1004923a 	slli	r2,r2,8
 90be730:	1007883a 	mov	r3,r2
 90be734:	00bfc004 	movi	r2,-256
 90be738:	1884703a 	and	r2,r3,r2
 90be73c:	2084b03a 	or	r2,r4,r2
 90be740:	1087ffcc 	andi	r2,r2,8191
 90be744:	100490fa 	slli	r2,r2,3
 90be748:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 90be74c:	e0bff817 	ldw	r2,-32(fp)
 90be750:	1080018b 	ldhu	r2,6(r2)
 90be754:	10bfffcc 	andi	r2,r2,65535
 90be758:	1004d23a 	srli	r2,r2,8
 90be75c:	10803fcc 	andi	r2,r2,255
 90be760:	1009883a 	mov	r4,r2
 90be764:	e0bff817 	ldw	r2,-32(fp)
 90be768:	1080018b 	ldhu	r2,6(r2)
 90be76c:	10bfffcc 	andi	r2,r2,65535
 90be770:	1004923a 	slli	r2,r2,8
 90be774:	1007883a 	mov	r3,r2
 90be778:	00bfc004 	movi	r2,-256
 90be77c:	1884703a 	and	r2,r3,r2
 90be780:	2084b03a 	or	r2,r4,r2
 90be784:	1088000c 	andi	r2,r2,8192
 90be788:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 90be78c:	e03ff48d 	sth	zero,-46(fp)
 90be790:	0000cc06 	br	90beac4 <ip_fragment+0x5d0>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90be794:	01000084 	movi	r4,2
 90be798:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 90be79c:	e0fff70b 	ldhu	r3,-36(fp)
 90be7a0:	e0bff7c3 	ldbu	r2,-33(fp)
 90be7a4:	1887883a 	add	r3,r3,r2
 90be7a8:	e0bff783 	ldbu	r2,-34(fp)
 90be7ac:	1885883a 	add	r2,r3,r2
 90be7b0:	1009883a 	mov	r4,r2
 90be7b4:	90a88440 	call	90a8844 <pk_alloc>
 90be7b8:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be7bc:	01000084 	movi	r4,2
 90be7c0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 90be7c4:	e0bff217 	ldw	r2,-56(fp)
 90be7c8:	1004c03a 	cmpne	r2,r2,zero
 90be7cc:	1000101e 	bne	r2,zero,90be810 <ip_fragment+0x31c>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be7d0:	01000084 	movi	r4,2
 90be7d4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90be7d8:	e13ffa17 	ldw	r4,-24(fp)
 90be7dc:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be7e0:	01000084 	movi	r4,2
 90be7e4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 90be7e8:	008243b4 	movhi	r2,2318
 90be7ec:	10b66404 	addi	r2,r2,-9840
 90be7f0:	10801117 	ldw	r2,68(r2)
 90be7f4:	10c00044 	addi	r3,r2,1
 90be7f8:	008243b4 	movhi	r2,2318
 90be7fc:	10b66404 	addi	r2,r2,-9840
 90be800:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 90be804:	00bffac4 	movi	r2,-21
 90be808:	e0bffe15 	stw	r2,-8(fp)
 90be80c:	0000be06 	br	90beb08 <ip_fragment+0x614>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 90be810:	e0bff217 	ldw	r2,-56(fp)
 90be814:	10c00117 	ldw	r3,4(r2)
 90be818:	e0bff783 	ldbu	r2,-34(fp)
 90be81c:	1889883a 	add	r4,r3,r2
 90be820:	e0bffa17 	ldw	r2,-24(fp)
 90be824:	10800317 	ldw	r2,12(r2)
 90be828:	e0fff7c3 	ldbu	r3,-33(fp)
 90be82c:	100b883a 	mov	r5,r2
 90be830:	180d883a 	mov	r6,r3
 90be834:	90822780 	call	9082278 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 90be838:	e0fff48b 	ldhu	r3,-46(fp)
 90be83c:	e0bff50b 	ldhu	r2,-44(fp)
 90be840:	10bfffc4 	addi	r2,r2,-1
 90be844:	1880030e 	bge	r3,r2,90be854 <ip_fragment+0x360>
         {
            amt_to_copy = useable_payload_len;
 90be848:	e0bff70b 	ldhu	r2,-36(fp)
 90be84c:	e0bff40d 	sth	r2,-48(fp)
 90be850:	00000a06 	br	90be87c <ip_fragment+0x388>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 90be854:	e0bff60b 	ldhu	r2,-40(fp)
 90be858:	1004c03a 	cmpne	r2,r2,zero
 90be85c:	1000031e 	bne	r2,zero,90be86c <ip_fragment+0x378>
 90be860:	e0fff70b 	ldhu	r3,-36(fp)
 90be864:	e0fffc0d 	sth	r3,-16(fp)
 90be868:	00000206 	br	90be874 <ip_fragment+0x380>
 90be86c:	e0bff60b 	ldhu	r2,-40(fp)
 90be870:	e0bffc0d 	sth	r2,-16(fp)
 90be874:	e0fffc0b 	ldhu	r3,-16(fp)
 90be878:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 90be87c:	e0bff217 	ldw	r2,-56(fp)
 90be880:	10c00117 	ldw	r3,4(r2)
 90be884:	e0bff783 	ldbu	r2,-34(fp)
 90be888:	1887883a 	add	r3,r3,r2
 90be88c:	e0bff7c3 	ldbu	r2,-33(fp)
 90be890:	188b883a 	add	r5,r3,r2
 90be894:	e0bffa17 	ldw	r2,-24(fp)
 90be898:	10c00317 	ldw	r3,12(r2)
 90be89c:	e0bff7c3 	ldbu	r2,-33(fp)
 90be8a0:	1889883a 	add	r4,r3,r2
 90be8a4:	e0fff70b 	ldhu	r3,-36(fp)
 90be8a8:	e0bff48b 	ldhu	r2,-46(fp)
 90be8ac:	1885383a 	mul	r2,r3,r2
 90be8b0:	2085883a 	add	r2,r4,r2
 90be8b4:	e0fff40b 	ldhu	r3,-48(fp)
 90be8b8:	2809883a 	mov	r4,r5
 90be8bc:	100b883a 	mov	r5,r2
 90be8c0:	180d883a 	mov	r6,r3
 90be8c4:	90822780 	call	9082278 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 90be8c8:	e0bff217 	ldw	r2,-56(fp)
 90be8cc:	10c00117 	ldw	r3,4(r2)
 90be8d0:	e0bff783 	ldbu	r2,-34(fp)
 90be8d4:	1887883a 	add	r3,r3,r2
 90be8d8:	e0bff217 	ldw	r2,-56(fp)
 90be8dc:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 90be8e0:	e0fff7c3 	ldbu	r3,-33(fp)
 90be8e4:	e0bff40b 	ldhu	r2,-48(fp)
 90be8e8:	1885883a 	add	r2,r3,r2
 90be8ec:	1007883a 	mov	r3,r2
 90be8f0:	e0bff217 	ldw	r2,-56(fp)
 90be8f4:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 90be8f8:	e0bffa17 	ldw	r2,-24(fp)
 90be8fc:	10c00617 	ldw	r3,24(r2)
 90be900:	e0bff217 	ldw	r2,-56(fp)
 90be904:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 90be908:	e0bffa17 	ldw	r2,-24(fp)
 90be90c:	10c00717 	ldw	r3,28(r2)
 90be910:	e0bff217 	ldw	r2,-56(fp)
 90be914:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 90be918:	e0fff217 	ldw	r3,-56(fp)
 90be91c:	00820004 	movi	r2,2048
 90be920:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 90be924:	e0bff217 	ldw	r2,-56(fp)
 90be928:	10800317 	ldw	r2,12(r2)
 90be92c:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 90be930:	e0bff217 	ldw	r2,-56(fp)
 90be934:	10800417 	ldw	r2,16(r2)
 90be938:	1004d23a 	srli	r2,r2,8
 90be93c:	10803fcc 	andi	r2,r2,255
 90be940:	1009883a 	mov	r4,r2
 90be944:	e0bff217 	ldw	r2,-56(fp)
 90be948:	10800417 	ldw	r2,16(r2)
 90be94c:	1004923a 	slli	r2,r2,8
 90be950:	1007883a 	mov	r3,r2
 90be954:	00bfc004 	movi	r2,-256
 90be958:	1884703a 	and	r2,r3,r2
 90be95c:	2084b03a 	or	r2,r4,r2
 90be960:	1007883a 	mov	r3,r2
 90be964:	e0bff117 	ldw	r2,-60(fp)
 90be968:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 90be96c:	e13ff38b 	ldhu	r4,-50(fp)
 90be970:	e0fff70b 	ldhu	r3,-36(fp)
 90be974:	e0bff48b 	ldhu	r2,-46(fp)
 90be978:	1885383a 	mul	r2,r3,r2
 90be97c:	2085883a 	add	r2,r4,r2
 90be980:	1005d2fa 	srai	r2,r2,11
 90be984:	10803fcc 	andi	r2,r2,255
 90be988:	100b883a 	mov	r5,r2
 90be98c:	e13ff38b 	ldhu	r4,-50(fp)
 90be990:	e0fff70b 	ldhu	r3,-36(fp)
 90be994:	e0bff48b 	ldhu	r2,-46(fp)
 90be998:	1885383a 	mul	r2,r3,r2
 90be99c:	2085883a 	add	r2,r4,r2
 90be9a0:	1005d0fa 	srai	r2,r2,3
 90be9a4:	1004923a 	slli	r2,r2,8
 90be9a8:	1007883a 	mov	r3,r2
 90be9ac:	00bfc004 	movi	r2,-256
 90be9b0:	1884703a 	and	r2,r3,r2
 90be9b4:	2884b03a 	or	r2,r5,r2
 90be9b8:	1007883a 	mov	r3,r2
 90be9bc:	e0bff117 	ldw	r2,-60(fp)
 90be9c0:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 90be9c4:	e0fff48b 	ldhu	r3,-46(fp)
 90be9c8:	e0bff50b 	ldhu	r2,-44(fp)
 90be9cc:	10bfffc4 	addi	r2,r2,-1
 90be9d0:	1880070e 	bge	r3,r2,90be9f0 <ip_fragment+0x4fc>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 90be9d4:	e0bff117 	ldw	r2,-60(fp)
 90be9d8:	1080018b 	ldhu	r2,6(r2)
 90be9dc:	10800814 	ori	r2,r2,32
 90be9e0:	1007883a 	mov	r3,r2
 90be9e4:	e0bff117 	ldw	r2,-60(fp)
 90be9e8:	10c0018d 	sth	r3,6(r2)
 90be9ec:	00000906 	br	90bea14 <ip_fragment+0x520>
         }
         else
         {
            if (parent_mf)
 90be9f0:	e0bff30b 	ldhu	r2,-52(fp)
 90be9f4:	1005003a 	cmpeq	r2,r2,zero
 90be9f8:	1000061e 	bne	r2,zero,90bea14 <ip_fragment+0x520>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 90be9fc:	e0bff117 	ldw	r2,-60(fp)
 90bea00:	1080018b 	ldhu	r2,6(r2)
 90bea04:	10800814 	ori	r2,r2,32
 90bea08:	1007883a 	mov	r3,r2
 90bea0c:	e0bff117 	ldw	r2,-60(fp)
 90bea10:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 90bea14:	e0bff117 	ldw	r2,-60(fp)
 90bea18:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 90bea1c:	e0bff7c3 	ldbu	r2,-33(fp)
 90bea20:	1004d07a 	srli	r2,r2,1
 90bea24:	11403fcc 	andi	r5,r2,255
 90bea28:	e13ff117 	ldw	r4,-60(fp)
 90bea2c:	90a3f040 	call	90a3f04 <cksum>
 90bea30:	0084303a 	nor	r2,zero,r2
 90bea34:	1007883a 	mov	r3,r2
 90bea38:	e0bff117 	ldw	r2,-60(fp)
 90bea3c:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 90bea40:	008243b4 	movhi	r2,2318
 90bea44:	10b66404 	addi	r2,r2,-9840
 90bea48:	10801217 	ldw	r2,72(r2)
 90bea4c:	10c00044 	addi	r3,r2,1
 90bea50:	008243b4 	movhi	r2,2318
 90bea54:	10b66404 	addi	r2,r2,-9840
 90bea58:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 90bea5c:	e13ff217 	ldw	r4,-56(fp)
 90bea60:	e17ffb17 	ldw	r5,-20(fp)
 90bea64:	90a1b540 	call	90a1b54 <ip2mac>
 90bea68:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 90bea6c:	e0bff017 	ldw	r2,-64(fp)
 90bea70:	1004403a 	cmpge	r2,r2,zero
 90bea74:	1000101e 	bne	r2,zero,90beab8 <ip_fragment+0x5c4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bea78:	01000084 	movi	r4,2
 90bea7c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90bea80:	e13ffa17 	ldw	r4,-24(fp)
 90bea84:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bea88:	01000084 	movi	r4,2
 90bea8c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 90bea90:	008243b4 	movhi	r2,2318
 90bea94:	10b66404 	addi	r2,r2,-9840
 90bea98:	10801117 	ldw	r2,68(r2)
 90bea9c:	10c00044 	addi	r3,r2,1
 90beaa0:	008243b4 	movhi	r2,2318
 90beaa4:	10b66404 	addi	r2,r2,-9840
 90beaa8:	10c01115 	stw	r3,68(r2)
            return e;
 90beaac:	e0bff017 	ldw	r2,-64(fp)
 90beab0:	e0bffe15 	stw	r2,-8(fp)
 90beab4:	00001406 	br	90beb08 <ip_fragment+0x614>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 90beab8:	e0bff48b 	ldhu	r2,-46(fp)
 90beabc:	10800044 	addi	r2,r2,1
 90beac0:	e0bff48d 	sth	r2,-46(fp)
 90beac4:	e0fff48b 	ldhu	r3,-46(fp)
 90beac8:	e0bff50b 	ldhu	r2,-44(fp)
 90beacc:	18bf3136 	bltu	r3,r2,90be794 <ip_fragment+0x2a0>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bead0:	01000084 	movi	r4,2
 90bead4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90bead8:	e13ffa17 	ldw	r4,-24(fp)
 90beadc:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90beae0:	01000084 	movi	r4,2
 90beae4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 90beae8:	008243b4 	movhi	r2,2318
 90beaec:	10b66404 	addi	r2,r2,-9840
 90beaf0:	10801017 	ldw	r2,64(r2)
 90beaf4:	10c00044 	addi	r3,r2,1
 90beaf8:	008243b4 	movhi	r2,2318
 90beafc:	10b66404 	addi	r2,r2,-9840
 90beb00:	10c01015 	stw	r3,64(r2)

   return 0;
 90beb04:	e03ffe15 	stw	zero,-8(fp)
 90beb08:	e0bffe17 	ldw	r2,-8(fp)
}
 90beb0c:	e037883a 	mov	sp,fp
 90beb10:	dfc00117 	ldw	ra,4(sp)
 90beb14:	df000017 	ldw	fp,0(sp)
 90beb18:	dec00204 	addi	sp,sp,8
 90beb1c:	f800283a 	ret

090beb20 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 90beb20:	defff904 	addi	sp,sp,-28
 90beb24:	dfc00615 	stw	ra,24(sp)
 90beb28:	df000515 	stw	fp,20(sp)
 90beb2c:	df000504 	addi	fp,sp,20
 90beb30:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 90beb34:	e17ffd04 	addi	r5,fp,-12
 90beb38:	e13ffe17 	ldw	r4,-8(fp)
 90beb3c:	90bee840 	call	90bee84 <iproute>
 90beb40:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 90beb44:	e0bffc17 	ldw	r2,-16(fp)
 90beb48:	1004c03a 	cmpne	r2,r2,zero
 90beb4c:	1000161e 	bne	r2,zero,90beba8 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 90beb50:	00824374 	movhi	r2,2317
 90beb54:	108c1d04 	addi	r2,r2,12404
 90beb58:	10800017 	ldw	r2,0(r2)
 90beb5c:	1080050c 	andi	r2,r2,20
 90beb60:	1005003a 	cmpeq	r2,r2,zero
 90beb64:	10000e1e 	bne	r2,zero,90beba0 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90beb68:	e0bffe17 	ldw	r2,-8(fp)
 90beb6c:	11403fcc 	andi	r5,r2,255
 90beb70:	e0bffe17 	ldw	r2,-8(fp)
 90beb74:	1004d23a 	srli	r2,r2,8
 90beb78:	11803fcc 	andi	r6,r2,255
 90beb7c:	e0bffe17 	ldw	r2,-8(fp)
 90beb80:	1004d43a 	srli	r2,r2,16
 90beb84:	11c03fcc 	andi	r7,r2,255
 90beb88:	e0bffe17 	ldw	r2,-8(fp)
 90beb8c:	1004d63a 	srli	r2,r2,24
 90beb90:	d8800015 	stw	r2,0(sp)
 90beb94:	01024374 	movhi	r4,2317
 90beb98:	21007b04 	addi	r4,r4,492
 90beb9c:	90825100 	call	9082510 <printf>
#endif   /* NPDEBUG */
      return 0L;
 90beba0:	e03fff15 	stw	zero,-4(fp)
 90beba4:	00000306 	br	90bebb4 <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 90beba8:	e0bffc17 	ldw	r2,-16(fp)
 90bebac:	10800a17 	ldw	r2,40(r2)
 90bebb0:	e0bfff15 	stw	r2,-4(fp)
 90bebb4:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 90bebb8:	e037883a 	mov	sp,fp
 90bebbc:	dfc00117 	ldw	ra,4(sp)
 90bebc0:	df000017 	ldw	fp,0(sp)
 90bebc4:	dec00204 	addi	sp,sp,8
 90bebc8:	f800283a 	ret

090bebcc <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 90bebcc:	defff204 	addi	sp,sp,-56
 90bebd0:	dfc00d15 	stw	ra,52(sp)
 90bebd4:	df000c15 	stw	fp,48(sp)
 90bebd8:	df000c04 	addi	fp,sp,48
 90bebdc:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 90bebe0:	e0bffa17 	ldw	r2,-24(fp)
 90bebe4:	10800317 	ldw	r2,12(r2)
 90bebe8:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 90bebec:	e0bff917 	ldw	r2,-28(fp)
 90bebf0:	1080028b 	ldhu	r2,10(r2)
 90bebf4:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 90bebf8:	e0bff917 	ldw	r2,-28(fp)
 90bebfc:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 90bec00:	e0bff917 	ldw	r2,-28(fp)
 90bec04:	10800003 	ldbu	r2,0(r2)
 90bec08:	10803fcc 	andi	r2,r2,255
 90bec0c:	108003cc 	andi	r2,r2,15
 90bec10:	1085883a 	add	r2,r2,r2
 90bec14:	1085883a 	add	r2,r2,r2
 90bec18:	1005d07a 	srai	r2,r2,1
 90bec1c:	100b883a 	mov	r5,r2
 90bec20:	e13ff917 	ldw	r4,-28(fp)
 90bec24:	90a3f040 	call	90a3f04 <cksum>
 90bec28:	0084303a 	nor	r2,zero,r2
 90bec2c:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 90bec30:	e0fff70b 	ldhu	r3,-36(fp)
 90bec34:	e0bff78b 	ldhu	r2,-34(fp)
 90bec38:	18800126 	beq	r3,r2,90bec40 <ip_dump+0x74>
   {
      dtrap();
 90bec3c:	90a94880 	call	90a9488 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 90bec40:	0009883a 	mov	r4,zero
 90bec44:	01424374 	movhi	r5,2317
 90bec48:	29408404 	addi	r5,r5,528
 90bec4c:	90a45b40 	call	90a45b4 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 90bec50:	e0bff917 	ldw	r2,-28(fp)
 90bec54:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 90bec58:	e0bff817 	ldw	r2,-32(fp)
 90bec5c:	10800003 	ldbu	r2,0(r2)
 90bec60:	11803fcc 	andi	r6,r2,255
 90bec64:	e0bff817 	ldw	r2,-32(fp)
 90bec68:	10800044 	addi	r2,r2,1
 90bec6c:	10800003 	ldbu	r2,0(r2)
 90bec70:	11c03fcc 	andi	r7,r2,255
 90bec74:	e0bff917 	ldw	r2,-28(fp)
 90bec78:	1080008b 	ldhu	r2,2(r2)
 90bec7c:	10bfffcc 	andi	r2,r2,65535
 90bec80:	1004d23a 	srli	r2,r2,8
 90bec84:	10bfffcc 	andi	r2,r2,65535
 90bec88:	10c03fcc 	andi	r3,r2,255
 90bec8c:	e0bff917 	ldw	r2,-28(fp)
 90bec90:	1080008b 	ldhu	r2,2(r2)
 90bec94:	10bfffcc 	andi	r2,r2,65535
 90bec98:	1004923a 	slli	r2,r2,8
 90bec9c:	10bfc00c 	andi	r2,r2,65280
 90beca0:	1888b03a 	or	r4,r3,r2
 90beca4:	e0bff917 	ldw	r2,-28(fp)
 90beca8:	1080010b 	ldhu	r2,4(r2)
 90becac:	10bfffcc 	andi	r2,r2,65535
 90becb0:	1004d23a 	srli	r2,r2,8
 90becb4:	10bfffcc 	andi	r2,r2,65535
 90becb8:	10c03fcc 	andi	r3,r2,255
 90becbc:	e0bff917 	ldw	r2,-28(fp)
 90becc0:	1080010b 	ldhu	r2,4(r2)
 90becc4:	10bfffcc 	andi	r2,r2,65535
 90becc8:	1004923a 	slli	r2,r2,8
 90beccc:	10bfc00c 	andi	r2,r2,65280
 90becd0:	1884b03a 	or	r2,r3,r2
 90becd4:	d9000015 	stw	r4,0(sp)
 90becd8:	d8800115 	stw	r2,4(sp)
 90becdc:	0009883a 	mov	r4,zero
 90bece0:	01424374 	movhi	r5,2317
 90bece4:	29408904 	addi	r5,r5,548
 90bece8:	90a45b40 	call	90a45b4 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 90becec:	e0bff817 	ldw	r2,-32(fp)
 90becf0:	10800184 	addi	r2,r2,6
 90becf4:	1080000b 	ldhu	r2,0(r2)
 90becf8:	10bfffcc 	andi	r2,r2,65535
 90becfc:	1004d23a 	srli	r2,r2,8
 90bed00:	10bfffcc 	andi	r2,r2,65535
 90bed04:	10c03fcc 	andi	r3,r2,255
 90bed08:	e0bff817 	ldw	r2,-32(fp)
 90bed0c:	10800184 	addi	r2,r2,6
 90bed10:	1080000b 	ldhu	r2,0(r2)
 90bed14:	10bfffcc 	andi	r2,r2,65535
 90bed18:	1004923a 	slli	r2,r2,8
 90bed1c:	10bfc00c 	andi	r2,r2,65280
 90bed20:	1886b03a 	or	r3,r3,r2
 90bed24:	e0ffff15 	stw	r3,-4(fp)
 90bed28:	e0bff917 	ldw	r2,-28(fp)
 90bed2c:	10800203 	ldbu	r2,8(r2)
 90bed30:	10803fcc 	andi	r2,r2,255
 90bed34:	e0bffe15 	stw	r2,-8(fp)
 90bed38:	e0bff917 	ldw	r2,-28(fp)
 90bed3c:	10800243 	ldbu	r2,9(r2)
 90bed40:	10803fcc 	andi	r2,r2,255
 90bed44:	e0bffd15 	stw	r2,-12(fp)
 90bed48:	e0bff70b 	ldhu	r2,-36(fp)
 90bed4c:	1004d23a 	srli	r2,r2,8
 90bed50:	10bfffcc 	andi	r2,r2,65535
 90bed54:	10c03fcc 	andi	r3,r2,255
 90bed58:	e0bff70b 	ldhu	r2,-36(fp)
 90bed5c:	1004923a 	slli	r2,r2,8
 90bed60:	10bfc00c 	andi	r2,r2,65280
 90bed64:	1886b03a 	or	r3,r3,r2
 90bed68:	e0fffc15 	stw	r3,-16(fp)
 90bed6c:	e0fff70b 	ldhu	r3,-36(fp)
 90bed70:	e0bff78b 	ldhu	r2,-34(fp)
 90bed74:	1880041e 	bne	r3,r2,90bed88 <ip_dump+0x1bc>
 90bed78:	00824374 	movhi	r2,2317
 90bed7c:	10809504 	addi	r2,r2,596
 90bed80:	e0bffb15 	stw	r2,-20(fp)
 90bed84:	00000306 	br	90bed94 <ip_dump+0x1c8>
 90bed88:	00824374 	movhi	r2,2317
 90bed8c:	10809604 	addi	r2,r2,600
 90bed90:	e0bffb15 	stw	r2,-20(fp)
 90bed94:	e0bffd17 	ldw	r2,-12(fp)
 90bed98:	d8800015 	stw	r2,0(sp)
 90bed9c:	e0bffc17 	ldw	r2,-16(fp)
 90beda0:	d8800115 	stw	r2,4(sp)
 90beda4:	e0bffb17 	ldw	r2,-20(fp)
 90beda8:	d8800215 	stw	r2,8(sp)
 90bedac:	0009883a 	mov	r4,zero
 90bedb0:	01424374 	movhi	r5,2317
 90bedb4:	29409704 	addi	r5,r5,604
 90bedb8:	e1bfff17 	ldw	r6,-4(fp)
 90bedbc:	e1fffe17 	ldw	r7,-8(fp)
 90bedc0:	90a45b40 	call	90a45b4 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 90bedc4:	e0bff917 	ldw	r2,-28(fp)
 90bedc8:	10800317 	ldw	r2,12(r2)
 90bedcc:	11803fcc 	andi	r6,r2,255
 90bedd0:	e0bff917 	ldw	r2,-28(fp)
 90bedd4:	10800317 	ldw	r2,12(r2)
 90bedd8:	1004d23a 	srli	r2,r2,8
 90beddc:	11c03fcc 	andi	r7,r2,255
 90bede0:	e0bff917 	ldw	r2,-28(fp)
 90bede4:	10800317 	ldw	r2,12(r2)
 90bede8:	1004d43a 	srli	r2,r2,16
 90bedec:	10c03fcc 	andi	r3,r2,255
 90bedf0:	e0bff917 	ldw	r2,-28(fp)
 90bedf4:	10800317 	ldw	r2,12(r2)
 90bedf8:	1004d63a 	srli	r2,r2,24
 90bedfc:	d8c00015 	stw	r3,0(sp)
 90bee00:	d8800115 	stw	r2,4(sp)
 90bee04:	0009883a 	mov	r4,zero
 90bee08:	01424374 	movhi	r5,2317
 90bee0c:	2940a704 	addi	r5,r5,668
 90bee10:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 90bee14:	e0bff917 	ldw	r2,-28(fp)
 90bee18:	10800417 	ldw	r2,16(r2)
 90bee1c:	11803fcc 	andi	r6,r2,255
 90bee20:	e0bff917 	ldw	r2,-28(fp)
 90bee24:	10800417 	ldw	r2,16(r2)
 90bee28:	1004d23a 	srli	r2,r2,8
 90bee2c:	11c03fcc 	andi	r7,r2,255
 90bee30:	e0bff917 	ldw	r2,-28(fp)
 90bee34:	10800417 	ldw	r2,16(r2)
 90bee38:	1004d43a 	srli	r2,r2,16
 90bee3c:	10c03fcc 	andi	r3,r2,255
 90bee40:	e0bff917 	ldw	r2,-28(fp)
 90bee44:	10800417 	ldw	r2,16(r2)
 90bee48:	1004d63a 	srli	r2,r2,24
 90bee4c:	d8c00015 	stw	r3,0(sp)
 90bee50:	d8800115 	stw	r2,4(sp)
 90bee54:	0009883a 	mov	r4,zero
 90bee58:	01424374 	movhi	r5,2317
 90bee5c:	2940ac04 	addi	r5,r5,688
 90bee60:	90a45b40 	call	90a45b4 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 90bee64:	e0fff917 	ldw	r3,-28(fp)
 90bee68:	e0bff70b 	ldhu	r2,-36(fp)
 90bee6c:	1880028d 	sth	r2,10(r3)
}
 90bee70:	e037883a 	mov	sp,fp
 90bee74:	dfc00117 	ldw	ra,4(sp)
 90bee78:	df000017 	ldw	fp,0(sp)
 90bee7c:	dec00204 	addi	sp,sp,8
 90bee80:	f800283a 	ret

090bee84 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 90bee84:	defff704 	addi	sp,sp,-36
 90bee88:	dfc00815 	stw	ra,32(sp)
 90bee8c:	df000715 	stw	fp,28(sp)
 90bee90:	df000704 	addi	fp,sp,28
 90bee94:	e13ffd15 	stw	r4,-12(fp)
 90bee98:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 90bee9c:	e0bffd17 	ldw	r2,-12(fp)
 90beea0:	1004c03a 	cmpne	r2,r2,zero
 90beea4:	1000021e 	bne	r2,zero,90beeb0 <iproute+0x2c>
      return NULL;
 90beea8:	e03fff15 	stw	zero,-4(fp)
 90beeac:	00008a06 	br	90bf0d8 <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 90beeb0:	d0a0c617 	ldw	r2,-31976(gp)
 90beeb4:	1004c03a 	cmpne	r2,r2,zero
 90beeb8:	1000021e 	bne	r2,zero,90beec4 <iproute+0x40>
      return NULL;
 90beebc:	e03fff15 	stw	zero,-4(fp)
 90beec0:	00008506 	br	90bf0d8 <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 90beec4:	00824374 	movhi	r2,2317
 90beec8:	108c6a04 	addi	r2,r2,12712
 90beecc:	10800017 	ldw	r2,0(r2)
 90beed0:	1005003a 	cmpeq	r2,r2,zero
 90beed4:	1000191e 	bne	r2,zero,90bef3c <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 90beed8:	00824374 	movhi	r2,2317
 90beedc:	108c6a04 	addi	r2,r2,12712
 90beee0:	10800017 	ldw	r2,0(r2)
 90beee4:	10c00017 	ldw	r3,0(r2)
 90beee8:	e0bffd17 	ldw	r2,-12(fp)
 90beeec:	1880131e 	bne	r3,r2,90bef3c <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 90beef0:	00824374 	movhi	r2,2317
 90beef4:	108c6a04 	addi	r2,r2,12712
 90beef8:	10800017 	ldw	r2,0(r2)
 90beefc:	10c00617 	ldw	r3,24(r2)
 90bef00:	e0bffe17 	ldw	r2,-8(fp)
 90bef04:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 90bef08:	00824374 	movhi	r2,2317
 90bef0c:	108c6a04 	addi	r2,r2,12712
 90bef10:	10c00017 	ldw	r3,0(r2)
 90bef14:	00824374 	movhi	r2,2317
 90bef18:	108c4204 	addi	r2,r2,12552
 90bef1c:	10800017 	ldw	r2,0(r2)
 90bef20:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 90bef24:	00824374 	movhi	r2,2317
 90bef28:	108c6a04 	addi	r2,r2,12712
 90bef2c:	10800017 	ldw	r2,0(r2)
 90bef30:	10800e17 	ldw	r2,56(r2)
 90bef34:	e0bfff15 	stw	r2,-4(fp)
 90bef38:	00006706 	br	90bf0d8 <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 90bef3c:	e13ffd17 	ldw	r4,-12(fp)
 90bef40:	90c27880 	call	90c2788 <rt_lookup>
 90bef44:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 90bef48:	e0bffa17 	ldw	r2,-24(fp)
 90bef4c:	1005003a 	cmpeq	r2,r2,zero
 90bef50:	10000c1e 	bne	r2,zero,90bef84 <iproute+0x100>
   {
      cachedRoute = rtp;
 90bef54:	00c24374 	movhi	r3,2317
 90bef58:	18cc6a04 	addi	r3,r3,12712
 90bef5c:	e0bffa17 	ldw	r2,-24(fp)
 90bef60:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 90bef64:	e0bffa17 	ldw	r2,-24(fp)
 90bef68:	10c00617 	ldw	r3,24(r2)
 90bef6c:	e0bffe17 	ldw	r2,-8(fp)
 90bef70:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 90bef74:	e0bffa17 	ldw	r2,-24(fp)
 90bef78:	10800e17 	ldw	r2,56(r2)
 90bef7c:	e0bfff15 	stw	r2,-4(fp)
 90bef80:	00005506 	br	90bf0d8 <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 90bef84:	008243b4 	movhi	r2,2318
 90bef88:	10b65f04 	addi	r2,r2,-9860
 90bef8c:	10800017 	ldw	r2,0(r2)
 90bef90:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 90bef94:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 90bef98:	00002f06 	br	90bf058 <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 90bef9c:	e0bffb17 	ldw	r2,-20(fp)
 90befa0:	10800c17 	ldw	r2,48(r2)
 90befa4:	1005003a 	cmpeq	r2,r2,zero
 90befa8:	1000251e 	bne	r2,zero,90bf040 <iproute+0x1bc>
 90befac:	e0bffb17 	ldw	r2,-20(fp)
 90befb0:	10800a17 	ldw	r2,40(r2)
 90befb4:	1005003a 	cmpeq	r2,r2,zero
 90befb8:	1000211e 	bne	r2,zero,90bf040 <iproute+0x1bc>
 90befbc:	e0bffb17 	ldw	r2,-20(fp)
 90befc0:	10c00a17 	ldw	r3,40(r2)
 90befc4:	e0bffb17 	ldw	r2,-20(fp)
 90befc8:	10800c17 	ldw	r2,48(r2)
 90befcc:	1888703a 	and	r4,r3,r2
 90befd0:	e0bffb17 	ldw	r2,-20(fp)
 90befd4:	10c00c17 	ldw	r3,48(r2)
 90befd8:	e0bffd17 	ldw	r2,-12(fp)
 90befdc:	1884703a 	and	r2,r3,r2
 90befe0:	2080171e 	bne	r4,r2,90bf040 <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 90befe4:	00800044 	movi	r2,1
 90befe8:	d8800015 	stw	r2,0(sp)
 90befec:	e13ffd17 	ldw	r4,-12(fp)
 90beff0:	017fffc4 	movi	r5,-1
 90beff4:	e1bffd17 	ldw	r6,-12(fp)
 90beff8:	e1fffc17 	ldw	r7,-16(fp)
 90beffc:	90c290c0 	call	90c290c <add_route>
 90bf000:	1007883a 	mov	r3,r2
 90bf004:	00824374 	movhi	r2,2317
 90bf008:	108c6a04 	addi	r2,r2,12712
 90bf00c:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 90bf010:	00824374 	movhi	r2,2317
 90bf014:	108c6a04 	addi	r2,r2,12712
 90bf018:	10800017 	ldw	r2,0(r2)
 90bf01c:	1004c03a 	cmpne	r2,r2,zero
 90bf020:	1000011e 	bne	r2,zero,90bf028 <iproute+0x1a4>
            dtrap();
 90bf024:	90a94880 	call	90a9488 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 90bf028:	e0fffe17 	ldw	r3,-8(fp)
 90bf02c:	e0bffd17 	ldw	r2,-12(fp)
 90bf030:	18800015 	stw	r2,0(r3)
         return ifp;
 90bf034:	e0bffb17 	ldw	r2,-20(fp)
 90bf038:	e0bfff15 	stw	r2,-4(fp)
 90bf03c:	00002606 	br	90bf0d8 <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 90bf040:	e0bffb17 	ldw	r2,-20(fp)
 90bf044:	10800017 	ldw	r2,0(r2)
 90bf048:	e0bffb15 	stw	r2,-20(fp)
 90bf04c:	e0bffc17 	ldw	r2,-16(fp)
 90bf050:	10800044 	addi	r2,r2,1
 90bf054:	e0bffc15 	stw	r2,-16(fp)
 90bf058:	e0bffb17 	ldw	r2,-20(fp)
 90bf05c:	1004c03a 	cmpne	r2,r2,zero
 90bf060:	103fce1e 	bne	r2,zero,90bef9c <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 90bf064:	008243b4 	movhi	r2,2318
 90bf068:	10b65f04 	addi	r2,r2,-9860
 90bf06c:	10800017 	ldw	r2,0(r2)
 90bf070:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 90bf074:	00000e06 	br	90bf0b0 <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 90bf078:	e0bffb17 	ldw	r2,-20(fp)
 90bf07c:	10800d17 	ldw	r2,52(r2)
 90bf080:	1005003a 	cmpeq	r2,r2,zero
 90bf084:	1000071e 	bne	r2,zero,90bf0a4 <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 90bf088:	e0bffb17 	ldw	r2,-20(fp)
 90bf08c:	10c00d17 	ldw	r3,52(r2)
 90bf090:	e0bffe17 	ldw	r2,-8(fp)
 90bf094:	10c00015 	stw	r3,0(r2)
         return ifp;
 90bf098:	e0bffb17 	ldw	r2,-20(fp)
 90bf09c:	e0bfff15 	stw	r2,-4(fp)
 90bf0a0:	00000d06 	br	90bf0d8 <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 90bf0a4:	e0bffb17 	ldw	r2,-20(fp)
 90bf0a8:	10800017 	ldw	r2,0(r2)
 90bf0ac:	e0bffb15 	stw	r2,-20(fp)
 90bf0b0:	e0bffb17 	ldw	r2,-20(fp)
 90bf0b4:	1004c03a 	cmpne	r2,r2,zero
 90bf0b8:	103fef1e 	bne	r2,zero,90bf078 <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 90bf0bc:	e0fffe17 	ldw	r3,-8(fp)
 90bf0c0:	e0bffd17 	ldw	r2,-12(fp)
 90bf0c4:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 90bf0c8:	008243b4 	movhi	r2,2318
 90bf0cc:	10b65f04 	addi	r2,r2,-9860
 90bf0d0:	10800017 	ldw	r2,0(r2)
 90bf0d4:	e0bfff15 	stw	r2,-4(fp)
 90bf0d8:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 90bf0dc:	e037883a 	mov	sp,fp
 90bf0e0:	dfc00117 	ldw	ra,4(sp)
 90bf0e4:	df000017 	ldw	fp,0(sp)
 90bf0e8:	dec00204 	addi	sp,sp,8
 90bf0ec:	f800283a 	ret

090bf0f0 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 90bf0f0:	defffa04 	addi	sp,sp,-24
 90bf0f4:	dfc00515 	stw	ra,20(sp)
 90bf0f8:	df000415 	stw	fp,16(sp)
 90bf0fc:	df000404 	addi	fp,sp,16
 90bf100:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 90bf104:	e0bffe17 	ldw	r2,-8(fp)
 90bf108:	11000417 	ldw	r4,16(r2)
 90bf10c:	e0bffe17 	ldw	r2,-8(fp)
 90bf110:	10800317 	ldw	r2,12(r2)
 90bf114:	1007883a 	mov	r3,r2
 90bf118:	e0bffe17 	ldw	r2,-8(fp)
 90bf11c:	10800117 	ldw	r2,4(r2)
 90bf120:	1885c83a 	sub	r2,r3,r2
 90bf124:	2085883a 	add	r2,r4,r2
 90bf128:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf12c:	01000084 	movi	r4,2
 90bf130:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 90bf134:	e13ffc17 	ldw	r4,-16(fp)
 90bf138:	90a88440 	call	90a8844 <pk_alloc>
 90bf13c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf140:	01000084 	movi	r4,2
 90bf144:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 90bf148:	e0bffd17 	ldw	r2,-12(fp)
 90bf14c:	1004c03a 	cmpne	r2,r2,zero
 90bf150:	1000061e 	bne	r2,zero,90bf16c <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 90bf154:	01024374 	movhi	r4,2317
 90bf158:	2100b104 	addi	r4,r4,708
 90bf15c:	e17ffc17 	ldw	r5,-16(fp)
 90bf160:	90825100 	call	9082510 <printf>
#endif
      return NULL;
 90bf164:	e03fff15 	stw	zero,-4(fp)
 90bf168:	00002906 	br	90bf210 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 90bf16c:	e0bffd17 	ldw	r2,-12(fp)
 90bf170:	11000117 	ldw	r4,4(r2)
 90bf174:	e0bffe17 	ldw	r2,-8(fp)
 90bf178:	10800117 	ldw	r2,4(r2)
 90bf17c:	e0fffc17 	ldw	r3,-16(fp)
 90bf180:	100b883a 	mov	r5,r2
 90bf184:	180d883a 	mov	r6,r3
 90bf188:	90822780 	call	9082278 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 90bf18c:	e0bffd17 	ldw	r2,-12(fp)
 90bf190:	11000117 	ldw	r4,4(r2)
 90bf194:	e0bffe17 	ldw	r2,-8(fp)
 90bf198:	10800317 	ldw	r2,12(r2)
 90bf19c:	1007883a 	mov	r3,r2
 90bf1a0:	e0bffe17 	ldw	r2,-8(fp)
 90bf1a4:	10800117 	ldw	r2,4(r2)
 90bf1a8:	1885c83a 	sub	r2,r3,r2
 90bf1ac:	2087883a 	add	r3,r4,r2
 90bf1b0:	e0bffd17 	ldw	r2,-12(fp)
 90bf1b4:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 90bf1b8:	e0bffe17 	ldw	r2,-8(fp)
 90bf1bc:	10c00417 	ldw	r3,16(r2)
 90bf1c0:	e0bffd17 	ldw	r2,-12(fp)
 90bf1c4:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 90bf1c8:	e0bffe17 	ldw	r2,-8(fp)
 90bf1cc:	10c00617 	ldw	r3,24(r2)
 90bf1d0:	e0bffd17 	ldw	r2,-12(fp)
 90bf1d4:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 90bf1d8:	e0bffe17 	ldw	r2,-8(fp)
 90bf1dc:	10c00717 	ldw	r3,28(r2)
 90bf1e0:	e0bffd17 	ldw	r2,-12(fp)
 90bf1e4:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 90bf1e8:	e0bffe17 	ldw	r2,-8(fp)
 90bf1ec:	10c0080b 	ldhu	r3,32(r2)
 90bf1f0:	e0bffd17 	ldw	r2,-12(fp)
 90bf1f4:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 90bf1f8:	e0bffe17 	ldw	r2,-8(fp)
 90bf1fc:	10c00517 	ldw	r3,20(r2)
 90bf200:	e0bffd17 	ldw	r2,-12(fp)
 90bf204:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 90bf208:	e0bffd17 	ldw	r2,-12(fp)
 90bf20c:	e0bfff15 	stw	r2,-4(fp)
 90bf210:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf214:	e037883a 	mov	sp,fp
 90bf218:	dfc00117 	ldw	ra,4(sp)
 90bf21c:	df000017 	ldw	fp,0(sp)
 90bf220:	dec00204 	addi	sp,sp,8
 90bf224:	f800283a 	ret

090bf228 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 90bf228:	defff904 	addi	sp,sp,-28
 90bf22c:	df000615 	stw	fp,24(sp)
 90bf230:	df000604 	addi	fp,sp,24
 90bf234:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 90bf238:	e0bffe17 	ldw	r2,-8(fp)
 90bf23c:	10800317 	ldw	r2,12(r2)
 90bf240:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 90bf244:	e0bffe17 	ldw	r2,-8(fp)
 90bf248:	10800417 	ldw	r2,16(r2)
 90bf24c:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 90bf250:	e0bffe17 	ldw	r2,-8(fp)
 90bf254:	10800243 	ldbu	r2,9(r2)
 90bf258:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 90bf25c:	e0bffe17 	ldw	r2,-8(fp)
 90bf260:	1080010b 	ldhu	r2,4(r2)
 90bf264:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90bf268:	d0a0c817 	ldw	r2,-31968(gp)
 90bf26c:	e0bffa15 	stw	r2,-24(fp)
 90bf270:	00001806 	br	90bf2d4 <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 90bf274:	e0bffa17 	ldw	r2,-24(fp)
 90bf278:	10c00117 	ldw	r3,4(r2)
 90bf27c:	e0bffd17 	ldw	r2,-12(fp)
 90bf280:	1880111e 	bne	r3,r2,90bf2c8 <ip_reasm_match_frag_with_ire+0xa0>
 90bf284:	e0bffa17 	ldw	r2,-24(fp)
 90bf288:	10c00217 	ldw	r3,8(r2)
 90bf28c:	e0bffc17 	ldw	r2,-16(fp)
 90bf290:	18800d1e 	bne	r3,r2,90bf2c8 <ip_reasm_match_frag_with_ire+0xa0>
 90bf294:	e0bffa17 	ldw	r2,-24(fp)
 90bf298:	10800383 	ldbu	r2,14(r2)
 90bf29c:	10c03fcc 	andi	r3,r2,255
 90bf2a0:	e0bffb83 	ldbu	r2,-18(fp)
 90bf2a4:	1880081e 	bne	r3,r2,90bf2c8 <ip_reasm_match_frag_with_ire+0xa0>
 90bf2a8:	e0bffa17 	ldw	r2,-24(fp)
 90bf2ac:	1080030b 	ldhu	r2,12(r2)
 90bf2b0:	10ffffcc 	andi	r3,r2,65535
 90bf2b4:	e0bffb0b 	ldhu	r2,-20(fp)
 90bf2b8:	1880031e 	bne	r3,r2,90bf2c8 <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 90bf2bc:	e0bffa17 	ldw	r2,-24(fp)
 90bf2c0:	e0bfff15 	stw	r2,-4(fp)
 90bf2c4:	00000706 	br	90bf2e4 <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90bf2c8:	e0bffa17 	ldw	r2,-24(fp)
 90bf2cc:	10800017 	ldw	r2,0(r2)
 90bf2d0:	e0bffa15 	stw	r2,-24(fp)
 90bf2d4:	e0bffa17 	ldw	r2,-24(fp)
 90bf2d8:	1004c03a 	cmpne	r2,r2,zero
 90bf2dc:	103fe51e 	bne	r2,zero,90bf274 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 90bf2e0:	e03fff15 	stw	zero,-4(fp)
 90bf2e4:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf2e8:	e037883a 	mov	sp,fp
 90bf2ec:	df000017 	ldw	fp,0(sp)
 90bf2f0:	dec00104 	addi	sp,sp,4
 90bf2f4:	f800283a 	ret

090bf2f8 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 90bf2f8:	defffc04 	addi	sp,sp,-16
 90bf2fc:	df000315 	stw	fp,12(sp)
 90bf300:	df000304 	addi	fp,sp,12
 90bf304:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 90bf308:	e0bfff17 	ldw	r2,-4(fp)
 90bf30c:	1080018b 	ldhu	r2,6(r2)
 90bf310:	10bfffcc 	andi	r2,r2,65535
 90bf314:	1004d23a 	srli	r2,r2,8
 90bf318:	10bfffcc 	andi	r2,r2,65535
 90bf31c:	10c03fcc 	andi	r3,r2,255
 90bf320:	e0bfff17 	ldw	r2,-4(fp)
 90bf324:	1080018b 	ldhu	r2,6(r2)
 90bf328:	10bfffcc 	andi	r2,r2,65535
 90bf32c:	1004923a 	slli	r2,r2,8
 90bf330:	10bfc00c 	andi	r2,r2,65280
 90bf334:	1884b03a 	or	r2,r3,r2
 90bf338:	1088000c 	andi	r2,r2,8192
 90bf33c:	1005d37a 	srai	r2,r2,13
 90bf340:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 90bf344:	e0bfff17 	ldw	r2,-4(fp)
 90bf348:	1080018b 	ldhu	r2,6(r2)
 90bf34c:	10bfffcc 	andi	r2,r2,65535
 90bf350:	1004d23a 	srli	r2,r2,8
 90bf354:	10803fcc 	andi	r2,r2,255
 90bf358:	1009883a 	mov	r4,r2
 90bf35c:	e0bfff17 	ldw	r2,-4(fp)
 90bf360:	1080018b 	ldhu	r2,6(r2)
 90bf364:	10bfffcc 	andi	r2,r2,65535
 90bf368:	1004923a 	slli	r2,r2,8
 90bf36c:	1007883a 	mov	r3,r2
 90bf370:	00bfc004 	movi	r2,-256
 90bf374:	1884703a 	and	r2,r3,r2
 90bf378:	2084b03a 	or	r2,r4,r2
 90bf37c:	1087ffcc 	andi	r2,r2,8191
 90bf380:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 90bf384:	e0bffe8b 	ldhu	r2,-6(fp)
 90bf388:	1004c03a 	cmpne	r2,r2,zero
 90bf38c:	1000081e 	bne	r2,zero,90bf3b0 <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 90bf390:	e0bffe0b 	ldhu	r2,-8(fp)
 90bf394:	1004c03a 	cmpne	r2,r2,zero
 90bf398:	1000021e 	bne	r2,zero,90bf3a4 <ip_reasm_determine_type_of_frag+0xac>
 90bf39c:	e03ffd15 	stw	zero,-12(fp)
 90bf3a0:	00000b06 	br	90bf3d0 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 90bf3a4:	00800144 	movi	r2,5
 90bf3a8:	e0bffd15 	stw	r2,-12(fp)
 90bf3ac:	00000806 	br	90bf3d0 <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 90bf3b0:	e0bffe0b 	ldhu	r2,-8(fp)
 90bf3b4:	1004c03a 	cmpne	r2,r2,zero
 90bf3b8:	1000031e 	bne	r2,zero,90bf3c8 <ip_reasm_determine_type_of_frag+0xd0>
 90bf3bc:	00800044 	movi	r2,1
 90bf3c0:	e0bffd15 	stw	r2,-12(fp)
 90bf3c4:	00000206 	br	90bf3d0 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 90bf3c8:	008000c4 	movi	r2,3
 90bf3cc:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 90bf3d0:	e0bffd17 	ldw	r2,-12(fp)
}
 90bf3d4:	e037883a 	mov	sp,fp
 90bf3d8:	df000017 	ldw	fp,0(sp)
 90bf3dc:	dec00104 	addi	sp,sp,4
 90bf3e0:	f800283a 	ret

090bf3e4 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 90bf3e4:	defffd04 	addi	sp,sp,-12
 90bf3e8:	df000215 	stw	fp,8(sp)
 90bf3ec:	df000204 	addi	fp,sp,8
 90bf3f0:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90bf3f4:	d0e0c717 	ldw	r3,-31972(gp)
 90bf3f8:	008001b4 	movhi	r2,6
 90bf3fc:	10c0072e 	bgeu	r2,r3,90bf41c <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90bf400:	008243b4 	movhi	r2,2318
 90bf404:	10b67804 	addi	r2,r2,-9760
 90bf408:	10800217 	ldw	r2,8(r2)
 90bf40c:	10c00044 	addi	r3,r2,1
 90bf410:	008243b4 	movhi	r2,2318
 90bf414:	10b67804 	addi	r2,r2,-9760
 90bf418:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 90bf41c:	d0e0c717 	ldw	r3,-31972(gp)
 90bf420:	008001b4 	movhi	r2,6
 90bf424:	18800526 	beq	r3,r2,90bf43c <ip_reasm_check_mem_useage+0x58>
 90bf428:	e0fffe0b 	ldhu	r3,-8(fp)
 90bf42c:	d0a0c717 	ldw	r2,-31972(gp)
 90bf430:	1887883a 	add	r3,r3,r2
 90bf434:	008001b4 	movhi	r2,6
 90bf438:	10c00a2e 	bgeu	r2,r3,90bf464 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 90bf43c:	008243b4 	movhi	r2,2318
 90bf440:	10b67804 	addi	r2,r2,-9760
 90bf444:	10800317 	ldw	r2,12(r2)
 90bf448:	10c00044 	addi	r3,r2,1
 90bf44c:	008243b4 	movhi	r2,2318
 90bf450:	10b67804 	addi	r2,r2,-9760
 90bf454:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 90bf458:	00bffa84 	movi	r2,-22
 90bf45c:	e0bfff15 	stw	r2,-4(fp)
 90bf460:	00000106 	br	90bf468 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 90bf464:	e03fff15 	stw	zero,-4(fp)
 90bf468:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf46c:	e037883a 	mov	sp,fp
 90bf470:	df000017 	ldw	fp,0(sp)
 90bf474:	dec00104 	addi	sp,sp,4
 90bf478:	f800283a 	ret

090bf47c <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 90bf47c:	defffd04 	addi	sp,sp,-12
 90bf480:	df000215 	stw	fp,8(sp)
 90bf484:	df000204 	addi	fp,sp,8
 90bf488:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90bf48c:	d0e0c717 	ldw	r3,-31972(gp)
 90bf490:	008001b4 	movhi	r2,6
 90bf494:	10c00a2e 	bgeu	r2,r3,90bf4c0 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90bf498:	008243b4 	movhi	r2,2318
 90bf49c:	10b67804 	addi	r2,r2,-9760
 90bf4a0:	10800217 	ldw	r2,8(r2)
 90bf4a4:	10c00044 	addi	r3,r2,1
 90bf4a8:	008243b4 	movhi	r2,2318
 90bf4ac:	10b67804 	addi	r2,r2,-9760
 90bf4b0:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 90bf4b4:	00bffa84 	movi	r2,-22
 90bf4b8:	e0bfff15 	stw	r2,-4(fp)
 90bf4bc:	00001406 	br	90bf510 <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 90bf4c0:	e0fffe0b 	ldhu	r3,-8(fp)
 90bf4c4:	d0a0c717 	ldw	r2,-31972(gp)
 90bf4c8:	1887883a 	add	r3,r3,r2
 90bf4cc:	008001b4 	movhi	r2,6
 90bf4d0:	10c00a2e 	bgeu	r2,r3,90bf4fc <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 90bf4d4:	008243b4 	movhi	r2,2318
 90bf4d8:	10b67804 	addi	r2,r2,-9760
 90bf4dc:	10800417 	ldw	r2,16(r2)
 90bf4e0:	10c00044 	addi	r3,r2,1
 90bf4e4:	008243b4 	movhi	r2,2318
 90bf4e8:	10b67804 	addi	r2,r2,-9760
 90bf4ec:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 90bf4f0:	00bffa84 	movi	r2,-22
 90bf4f4:	e0bfff15 	stw	r2,-4(fp)
 90bf4f8:	00000506 	br	90bf510 <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 90bf4fc:	e0bffe0b 	ldhu	r2,-8(fp)
 90bf500:	d0e0c717 	ldw	r3,-31972(gp)
 90bf504:	10c5883a 	add	r2,r2,r3
 90bf508:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 90bf50c:	e03fff15 	stw	zero,-4(fp)
 90bf510:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf514:	e037883a 	mov	sp,fp
 90bf518:	df000017 	ldw	fp,0(sp)
 90bf51c:	dec00104 	addi	sp,sp,4
 90bf520:	f800283a 	ret

090bf524 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 90bf524:	defffd04 	addi	sp,sp,-12
 90bf528:	df000215 	stw	fp,8(sp)
 90bf52c:	df000204 	addi	fp,sp,8
 90bf530:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90bf534:	d0e0c717 	ldw	r3,-31972(gp)
 90bf538:	008001b4 	movhi	r2,6
 90bf53c:	10c00a2e 	bgeu	r2,r3,90bf568 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90bf540:	008243b4 	movhi	r2,2318
 90bf544:	10b67804 	addi	r2,r2,-9760
 90bf548:	10800217 	ldw	r2,8(r2)
 90bf54c:	10c00044 	addi	r3,r2,1
 90bf550:	008243b4 	movhi	r2,2318
 90bf554:	10b67804 	addi	r2,r2,-9760
 90bf558:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 90bf55c:	00bffa84 	movi	r2,-22
 90bf560:	e0bfff15 	stw	r2,-4(fp)
 90bf564:	00001206 	br	90bf5b0 <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 90bf568:	e0fffe0b 	ldhu	r3,-8(fp)
 90bf56c:	d0a0c717 	ldw	r2,-31972(gp)
 90bf570:	10c00a2e 	bgeu	r2,r3,90bf59c <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 90bf574:	008243b4 	movhi	r2,2318
 90bf578:	10b67804 	addi	r2,r2,-9760
 90bf57c:	10800517 	ldw	r2,20(r2)
 90bf580:	10c00044 	addi	r3,r2,1
 90bf584:	008243b4 	movhi	r2,2318
 90bf588:	10b67804 	addi	r2,r2,-9760
 90bf58c:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 90bf590:	00bffa84 	movi	r2,-22
 90bf594:	e0bfff15 	stw	r2,-4(fp)
 90bf598:	00000506 	br	90bf5b0 <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 90bf59c:	d0a0c717 	ldw	r2,-31972(gp)
 90bf5a0:	e0fffe0b 	ldhu	r3,-8(fp)
 90bf5a4:	10c5c83a 	sub	r2,r2,r3
 90bf5a8:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 90bf5ac:	e03fff15 	stw	zero,-4(fp)
 90bf5b0:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf5b4:	e037883a 	mov	sp,fp
 90bf5b8:	df000017 	ldw	fp,0(sp)
 90bf5bc:	dec00104 	addi	sp,sp,4
 90bf5c0:	f800283a 	ret

090bf5c4 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 90bf5c4:	defff604 	addi	sp,sp,-40
 90bf5c8:	dfc00915 	stw	ra,36(sp)
 90bf5cc:	df000815 	stw	fp,32(sp)
 90bf5d0:	df000804 	addi	fp,sp,32
 90bf5d4:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 90bf5d8:	e0bffe17 	ldw	r2,-8(fp)
 90bf5dc:	10800217 	ldw	r2,8(r2)
 90bf5e0:	10802204 	addi	r2,r2,136
 90bf5e4:	113fffcc 	andi	r4,r2,65535
 90bf5e8:	90bf3e40 	call	90bf3e4 <ip_reasm_check_mem_useage>
 90bf5ec:	e0bff815 	stw	r2,-32(fp)
 90bf5f0:	e0bff817 	ldw	r2,-32(fp)
 90bf5f4:	1005003a 	cmpeq	r2,r2,zero
 90bf5f8:	1000101e 	bne	r2,zero,90bf63c <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90bf5fc:	01000084 	movi	r4,2
 90bf600:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free (p);
 90bf604:	e13ffe17 	ldw	r4,-8(fp)
 90bf608:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bf60c:	01000084 	movi	r4,2
 90bf610:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90bf614:	008243b4 	movhi	r2,2318
 90bf618:	10b66404 	addi	r2,r2,-9840
 90bf61c:	10800f17 	ldw	r2,60(r2)
 90bf620:	10c00044 	addi	r3,r2,1
 90bf624:	008243b4 	movhi	r2,2318
 90bf628:	10b66404 	addi	r2,r2,-9840
 90bf62c:	10c00f15 	stw	r3,60(r2)
      return rc;
 90bf630:	e0bff817 	ldw	r2,-32(fp)
 90bf634:	e0bfff15 	stw	r2,-4(fp)
 90bf638:	00009406 	br	90bf88c <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 90bf63c:	01002204 	movi	r4,136
 90bf640:	90a9f0c0 	call	90a9f0c <npalloc>
 90bf644:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 90bf648:	e0bffc17 	ldw	r2,-16(fp)
 90bf64c:	1004c03a 	cmpne	r2,r2,zero
 90bf650:	1000101e 	bne	r2,zero,90bf694 <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90bf654:	01000084 	movi	r4,2
 90bf658:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free (p);
 90bf65c:	e13ffe17 	ldw	r4,-8(fp)
 90bf660:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bf664:	01000084 	movi	r4,2
 90bf668:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90bf66c:	008243b4 	movhi	r2,2318
 90bf670:	10b66404 	addi	r2,r2,-9840
 90bf674:	10800f17 	ldw	r2,60(r2)
 90bf678:	10c00044 	addi	r3,r2,1
 90bf67c:	008243b4 	movhi	r2,2318
 90bf680:	10b66404 	addi	r2,r2,-9840
 90bf684:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 90bf688:	00bffa84 	movi	r2,-22
 90bf68c:	e0bfff15 	stw	r2,-4(fp)
 90bf690:	00007e06 	br	90bf88c <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 90bf694:	e0bffe17 	ldw	r2,-8(fp)
 90bf698:	10800317 	ldw	r2,12(r2)
 90bf69c:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 90bf6a0:	e0bffd17 	ldw	r2,-12(fp)
 90bf6a4:	10800003 	ldbu	r2,0(r2)
 90bf6a8:	108003cc 	andi	r2,r2,15
 90bf6ac:	1085883a 	add	r2,r2,r2
 90bf6b0:	1085883a 	add	r2,r2,r2
 90bf6b4:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 90bf6b8:	e13ffd17 	ldw	r4,-12(fp)
 90bf6bc:	90bf2f80 	call	90bf2f8 <ip_reasm_determine_type_of_frag>
 90bf6c0:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90bf6c4:	e0bffd17 	ldw	r2,-12(fp)
 90bf6c8:	1080018b 	ldhu	r2,6(r2)
 90bf6cc:	10bfffcc 	andi	r2,r2,65535
 90bf6d0:	1004d23a 	srli	r2,r2,8
 90bf6d4:	10803fcc 	andi	r2,r2,255
 90bf6d8:	1009883a 	mov	r4,r2
 90bf6dc:	e0bffd17 	ldw	r2,-12(fp)
 90bf6e0:	1080018b 	ldhu	r2,6(r2)
 90bf6e4:	10bfffcc 	andi	r2,r2,65535
 90bf6e8:	1004923a 	slli	r2,r2,8
 90bf6ec:	1007883a 	mov	r3,r2
 90bf6f0:	00bfc004 	movi	r2,-256
 90bf6f4:	1884703a 	and	r2,r3,r2
 90bf6f8:	2084b03a 	or	r2,r4,r2
 90bf6fc:	1087ffcc 	andi	r2,r2,8191
 90bf700:	100490fa 	slli	r2,r2,3
 90bf704:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 90bf708:	e0bffd17 	ldw	r2,-12(fp)
 90bf70c:	1080008b 	ldhu	r2,2(r2)
 90bf710:	10bfffcc 	andi	r2,r2,65535
 90bf714:	1004d23a 	srli	r2,r2,8
 90bf718:	10803fcc 	andi	r2,r2,255
 90bf71c:	1009883a 	mov	r4,r2
 90bf720:	e0bffd17 	ldw	r2,-12(fp)
 90bf724:	1080008b 	ldhu	r2,2(r2)
 90bf728:	10bfffcc 	andi	r2,r2,65535
 90bf72c:	1004923a 	slli	r2,r2,8
 90bf730:	1007883a 	mov	r3,r2
 90bf734:	00bfc004 	movi	r2,-256
 90bf738:	1884703a 	and	r2,r3,r2
 90bf73c:	2084b03a 	or	r2,r4,r2
 90bf740:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 90bf744:	e0bffd17 	ldw	r2,-12(fp)
 90bf748:	10c00317 	ldw	r3,12(r2)
 90bf74c:	e0bffc17 	ldw	r2,-16(fp)
 90bf750:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 90bf754:	e0bffd17 	ldw	r2,-12(fp)
 90bf758:	10c00417 	ldw	r3,16(r2)
 90bf75c:	e0bffc17 	ldw	r2,-16(fp)
 90bf760:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 90bf764:	e0bffd17 	ldw	r2,-12(fp)
 90bf768:	10c00243 	ldbu	r3,9(r2)
 90bf76c:	e0bffc17 	ldw	r2,-16(fp)
 90bf770:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 90bf774:	e0bffd17 	ldw	r2,-12(fp)
 90bf778:	10c0010b 	ldhu	r3,4(r2)
 90bf77c:	e0bffc17 	ldw	r2,-16(fp)
 90bf780:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 90bf784:	e0bffb17 	ldw	r2,-20(fp)
 90bf788:	10800158 	cmpnei	r2,r2,5
 90bf78c:	10000a1e 	bne	r2,zero,90bf7b8 <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 90bf790:	e0fffa03 	ldbu	r3,-24(fp)
 90bf794:	e0bff90b 	ldhu	r2,-28(fp)
 90bf798:	10c5c83a 	sub	r2,r2,r3
 90bf79c:	1007883a 	mov	r3,r2
 90bf7a0:	e0bff98b 	ldhu	r2,-26(fp)
 90bf7a4:	1885883a 	add	r2,r3,r2
 90bf7a8:	1007883a 	mov	r3,r2
 90bf7ac:	e0bffc17 	ldw	r2,-16(fp)
 90bf7b0:	10c0040d 	sth	r3,16(r2)
 90bf7b4:	00000a06 	br	90bf7e0 <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 90bf7b8:	e0bffb17 	ldw	r2,-20(fp)
 90bf7bc:	10800058 	cmpnei	r2,r2,1
 90bf7c0:	1000071e 	bne	r2,zero,90bf7e0 <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 90bf7c4:	e0bffe17 	ldw	r2,-8(fp)
 90bf7c8:	10c00117 	ldw	r3,4(r2)
 90bf7cc:	e0bffc17 	ldw	r2,-16(fp)
 90bf7d0:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 90bf7d4:	e0fffd17 	ldw	r3,-12(fp)
 90bf7d8:	e0bffc17 	ldw	r2,-16(fp)
 90bf7dc:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 90bf7e0:	e0fffa03 	ldbu	r3,-24(fp)
 90bf7e4:	e0bff90b 	ldhu	r2,-28(fp)
 90bf7e8:	10c5c83a 	sub	r2,r2,r3
 90bf7ec:	1007883a 	mov	r3,r2
 90bf7f0:	e0bffc17 	ldw	r2,-16(fp)
 90bf7f4:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 90bf7f8:	e0bffc17 	ldw	r2,-16(fp)
 90bf7fc:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 90bf800:	e0bffc17 	ldw	r2,-16(fp)
 90bf804:	10802103 	ldbu	r2,132(r2)
 90bf808:	10800054 	ori	r2,r2,1
 90bf80c:	1007883a 	mov	r3,r2
 90bf810:	e0bffc17 	ldw	r2,-16(fp)
 90bf814:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 90bf818:	e0fffc17 	ldw	r3,-16(fp)
 90bf81c:	e0bffe17 	ldw	r2,-8(fp)
 90bf820:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 90bf824:	e0fffc17 	ldw	r3,-16(fp)
 90bf828:	e0bff98b 	ldhu	r2,-26(fp)
 90bf82c:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 90bf830:	e0bffe17 	ldw	r2,-8(fp)
 90bf834:	10c00317 	ldw	r3,12(r2)
 90bf838:	e0bffa03 	ldbu	r2,-24(fp)
 90bf83c:	1887883a 	add	r3,r3,r2
 90bf840:	e0bffe17 	ldw	r2,-8(fp)
 90bf844:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 90bf848:	e0bffe17 	ldw	r2,-8(fp)
 90bf84c:	10c00417 	ldw	r3,16(r2)
 90bf850:	e0bffa03 	ldbu	r2,-24(fp)
 90bf854:	1887c83a 	sub	r3,r3,r2
 90bf858:	e0bffe17 	ldw	r2,-8(fp)
 90bf85c:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 90bf860:	d0e0c817 	ldw	r3,-31968(gp)
 90bf864:	e0bffc17 	ldw	r2,-16(fp)
 90bf868:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 90bf86c:	e0bffc17 	ldw	r2,-16(fp)
 90bf870:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 90bf874:	e0bffe17 	ldw	r2,-8(fp)
 90bf878:	10800217 	ldw	r2,8(r2)
 90bf87c:	10802204 	addi	r2,r2,136
 90bf880:	113fffcc 	andi	r4,r2,65535
 90bf884:	90bf47c0 	call	90bf47c <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 90bf888:	e03fff15 	stw	zero,-4(fp)
 90bf88c:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf890:	e037883a 	mov	sp,fp
 90bf894:	dfc00117 	ldw	ra,4(sp)
 90bf898:	df000017 	ldw	fp,0(sp)
 90bf89c:	dec00204 	addi	sp,sp,8
 90bf8a0:	f800283a 	ret

090bf8a4 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 90bf8a4:	defff804 	addi	sp,sp,-32
 90bf8a8:	dfc00715 	stw	ra,28(sp)
 90bf8ac:	df000615 	stw	fp,24(sp)
 90bf8b0:	df000604 	addi	fp,sp,24
 90bf8b4:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 90bf8b8:	e0bffe17 	ldw	r2,-8(fp)
 90bf8bc:	10800317 	ldw	r2,12(r2)
 90bf8c0:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 90bf8c4:	e13ffc17 	ldw	r4,-16(fp)
 90bf8c8:	90bf2280 	call	90bf228 <ip_reasm_match_frag_with_ire>
 90bf8cc:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 90bf8d0:	e0bffd17 	ldw	r2,-12(fp)
 90bf8d4:	1004c03a 	cmpne	r2,r2,zero
 90bf8d8:	1000091e 	bne	r2,zero,90bf900 <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 90bf8dc:	e13ffe17 	ldw	r4,-8(fp)
 90bf8e0:	90bf5c40 	call	90bf5c4 <ip_reasm_process_first_fragment>
 90bf8e4:	e0bffb15 	stw	r2,-20(fp)
 90bf8e8:	e0bffb17 	ldw	r2,-20(fp)
 90bf8ec:	1005003a 	cmpeq	r2,r2,zero
 90bf8f0:	10000d1e 	bne	r2,zero,90bf928 <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 90bf8f4:	e0bffb17 	ldw	r2,-20(fp)
 90bf8f8:	e0bfff15 	stw	r2,-4(fp)
 90bf8fc:	00000b06 	br	90bf92c <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 90bf900:	e13ffe17 	ldw	r4,-8(fp)
 90bf904:	e17ffd17 	ldw	r5,-12(fp)
 90bf908:	90bfed40 	call	90bfed4 <ip_reasm_process_subsequent_fragments>
 90bf90c:	e0bffa15 	stw	r2,-24(fp)
 90bf910:	e0bffa17 	ldw	r2,-24(fp)
 90bf914:	1005003a 	cmpeq	r2,r2,zero
 90bf918:	1000031e 	bne	r2,zero,90bf928 <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 90bf91c:	e0bffa17 	ldw	r2,-24(fp)
 90bf920:	e0bfff15 	stw	r2,-4(fp)
 90bf924:	00000106 	br	90bf92c <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 90bf928:	e03fff15 	stw	zero,-4(fp)
 90bf92c:	e0bfff17 	ldw	r2,-4(fp)
}
 90bf930:	e037883a 	mov	sp,fp
 90bf934:	dfc00117 	ldw	ra,4(sp)
 90bf938:	df000017 	ldw	fp,0(sp)
 90bf93c:	dec00204 	addi	sp,sp,8
 90bf940:	f800283a 	ret

090bf944 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 90bf944:	defff204 	addi	sp,sp,-56
 90bf948:	dfc00d15 	stw	ra,52(sp)
 90bf94c:	df000c15 	stw	fp,48(sp)
 90bf950:	df000c04 	addi	fp,sp,48
 90bf954:	e13ffb15 	stw	r4,-20(fp)
 90bf958:	e17ffc15 	stw	r5,-16(fp)
 90bf95c:	e1bffd15 	stw	r6,-12(fp)
 90bf960:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90bf964:	e13ffc17 	ldw	r4,-16(fp)
 90bf968:	90c04680 	call	90c0468 <ip_reasm_find_ire>
 90bf96c:	10803fcc 	andi	r2,r2,255
 90bf970:	10800060 	cmpeqi	r2,r2,1
 90bf974:	1000101e 	bne	r2,zero,90bf9b8 <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 90bf978:	008243b4 	movhi	r2,2318
 90bf97c:	10b67804 	addi	r2,r2,-9760
 90bf980:	10800017 	ldw	r2,0(r2)
 90bf984:	10c00044 	addi	r3,r2,1
 90bf988:	008243b4 	movhi	r2,2318
 90bf98c:	10b67804 	addi	r2,r2,-9760
 90bf990:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90bf994:	01000084 	movi	r4,2
 90bf998:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free (p);
 90bf99c:	e13ffb17 	ldw	r4,-20(fp)
 90bf9a0:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bf9a4:	01000084 	movi	r4,2
 90bf9a8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 90bf9ac:	00800044 	movi	r2,1
 90bf9b0:	e0bfff15 	stw	r2,-4(fp)
 90bf9b4:	00014106 	br	90bfebc <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 90bf9b8:	e0bffb17 	ldw	r2,-20(fp)
 90bf9bc:	10800317 	ldw	r2,12(r2)
 90bf9c0:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 90bf9c4:	e0bff817 	ldw	r2,-32(fp)
 90bf9c8:	10800003 	ldbu	r2,0(r2)
 90bf9cc:	108003cc 	andi	r2,r2,15
 90bf9d0:	1085883a 	add	r2,r2,r2
 90bf9d4:	1085883a 	add	r2,r2,r2
 90bf9d8:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90bf9dc:	e0bff817 	ldw	r2,-32(fp)
 90bf9e0:	1080018b 	ldhu	r2,6(r2)
 90bf9e4:	10bfffcc 	andi	r2,r2,65535
 90bf9e8:	1004d23a 	srli	r2,r2,8
 90bf9ec:	10803fcc 	andi	r2,r2,255
 90bf9f0:	1009883a 	mov	r4,r2
 90bf9f4:	e0bff817 	ldw	r2,-32(fp)
 90bf9f8:	1080018b 	ldhu	r2,6(r2)
 90bf9fc:	10bfffcc 	andi	r2,r2,65535
 90bfa00:	1004923a 	slli	r2,r2,8
 90bfa04:	1007883a 	mov	r3,r2
 90bfa08:	00bfc004 	movi	r2,-256
 90bfa0c:	1884703a 	and	r2,r3,r2
 90bfa10:	2084b03a 	or	r2,r4,r2
 90bfa14:	1087ffcc 	andi	r2,r2,8191
 90bfa18:	100490fa 	slli	r2,r2,3
 90bfa1c:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 90bfa20:	e0bff817 	ldw	r2,-32(fp)
 90bfa24:	1080008b 	ldhu	r2,2(r2)
 90bfa28:	10bfffcc 	andi	r2,r2,65535
 90bfa2c:	1004d23a 	srli	r2,r2,8
 90bfa30:	10803fcc 	andi	r2,r2,255
 90bfa34:	1009883a 	mov	r4,r2
 90bfa38:	e0bff817 	ldw	r2,-32(fp)
 90bfa3c:	1080008b 	ldhu	r2,2(r2)
 90bfa40:	10bfffcc 	andi	r2,r2,65535
 90bfa44:	1004923a 	slli	r2,r2,8
 90bfa48:	1007883a 	mov	r3,r2
 90bfa4c:	00bfc004 	movi	r2,-256
 90bfa50:	1884703a 	and	r2,r3,r2
 90bfa54:	2084b03a 	or	r2,r4,r2
 90bfa58:	1007883a 	mov	r3,r2
 90bfa5c:	e0bff483 	ldbu	r2,-46(fp)
 90bfa60:	1885c83a 	sub	r2,r3,r2
 90bfa64:	1007883a 	mov	r3,r2
 90bfa68:	e0bff70b 	ldhu	r2,-36(fp)
 90bfa6c:	1885883a 	add	r2,r3,r2
 90bfa70:	10bfffc4 	addi	r2,r2,-1
 90bfa74:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 90bfa78:	e0bffb17 	ldw	r2,-20(fp)
 90bfa7c:	10c00317 	ldw	r3,12(r2)
 90bfa80:	e0bff483 	ldbu	r2,-46(fp)
 90bfa84:	1887883a 	add	r3,r3,r2
 90bfa88:	e0bffb17 	ldw	r2,-20(fp)
 90bfa8c:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 90bfa90:	e0bffb17 	ldw	r2,-20(fp)
 90bfa94:	10c00417 	ldw	r3,16(r2)
 90bfa98:	e0bff483 	ldbu	r2,-46(fp)
 90bfa9c:	1887c83a 	sub	r3,r3,r2
 90bfaa0:	e0bffb17 	ldw	r2,-20(fp)
 90bfaa4:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 90bfaa8:	e0c00217 	ldw	r3,8(fp)
 90bfaac:	e0bff70b 	ldhu	r2,-36(fp)
 90bfab0:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 90bfab4:	e0fffd17 	ldw	r3,-12(fp)
 90bfab8:	00800404 	movi	r2,16
 90bfabc:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 90bfac0:	e0bffe17 	ldw	r2,-8(fp)
 90bfac4:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 90bfac8:	e0800317 	ldw	r2,12(fp)
 90bfacc:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 90bfad0:	e0bffc17 	ldw	r2,-16(fp)
 90bfad4:	10800604 	addi	r2,r2,24
 90bfad8:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 90bfadc:	0000ef06 	br	90bfe9c <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90bfae0:	e03ff40d 	sth	zero,-48(fp)
 90bfae4:	0000df06 	br	90bfe64 <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 90bfae8:	e0bff40b 	ldhu	r2,-48(fp)
 90bfaec:	e0fffa17 	ldw	r3,-24(fp)
 90bfaf0:	1085883a 	add	r2,r2,r2
 90bfaf4:	1085883a 	add	r2,r2,r2
 90bfaf8:	10c5883a 	add	r2,r2,r3
 90bfafc:	10800104 	addi	r2,r2,4
 90bfb00:	10800017 	ldw	r2,0(r2)
 90bfb04:	e0bff915 	stw	r2,-28(fp)
 90bfb08:	e0bff917 	ldw	r2,-28(fp)
 90bfb0c:	1005003a 	cmpeq	r2,r2,zero
 90bfb10:	1000bf1e 	bne	r2,zero,90bfe10 <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 90bfb14:	e0bff40b 	ldhu	r2,-48(fp)
 90bfb18:	e0fffa17 	ldw	r3,-24(fp)
 90bfb1c:	1085883a 	add	r2,r2,r2
 90bfb20:	10c5883a 	add	r2,r2,r3
 90bfb24:	10801104 	addi	r2,r2,68
 90bfb28:	1080000b 	ldhu	r2,0(r2)
 90bfb2c:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 90bfb30:	e0bff917 	ldw	r2,-28(fp)
 90bfb34:	10800417 	ldw	r2,16(r2)
 90bfb38:	1007883a 	mov	r3,r2
 90bfb3c:	e0bff60b 	ldhu	r2,-40(fp)
 90bfb40:	1885883a 	add	r2,r3,r2
 90bfb44:	10bfffc4 	addi	r2,r2,-1
 90bfb48:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 90bfb4c:	e0fff60b 	ldhu	r3,-40(fp)
 90bfb50:	e0bff70b 	ldhu	r2,-36(fp)
 90bfb54:	18802b2e 	bgeu	r3,r2,90bfc04 <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 90bfb58:	e0fff58b 	ldhu	r3,-42(fp)
 90bfb5c:	e0bff68b 	ldhu	r2,-38(fp)
 90bfb60:	1880202e 	bgeu	r3,r2,90bfbe4 <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 90bfb64:	e0fff58b 	ldhu	r3,-42(fp)
 90bfb68:	e0bff70b 	ldhu	r2,-36(fp)
 90bfb6c:	1880ba36 	bltu	r3,r2,90bfe58 <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 90bfb70:	e0fff58b 	ldhu	r3,-42(fp)
 90bfb74:	e0bff70b 	ldhu	r2,-36(fp)
 90bfb78:	1885c83a 	sub	r2,r3,r2
 90bfb7c:	10800044 	addi	r2,r2,1
 90bfb80:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 90bfb84:	e0bffb17 	ldw	r2,-20(fp)
 90bfb88:	10c00317 	ldw	r3,12(r2)
 90bfb8c:	e0bff50b 	ldhu	r2,-44(fp)
 90bfb90:	1887883a 	add	r3,r3,r2
 90bfb94:	e0bffb17 	ldw	r2,-20(fp)
 90bfb98:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 90bfb9c:	e0bffb17 	ldw	r2,-20(fp)
 90bfba0:	10c00417 	ldw	r3,16(r2)
 90bfba4:	e0bff50b 	ldhu	r2,-44(fp)
 90bfba8:	1887c83a 	sub	r3,r3,r2
 90bfbac:	e0bffb17 	ldw	r2,-20(fp)
 90bfbb0:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 90bfbb4:	e0fff70b 	ldhu	r3,-36(fp)
 90bfbb8:	e0bff50b 	ldhu	r2,-44(fp)
 90bfbbc:	1885883a 	add	r2,r3,r2
 90bfbc0:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 90bfbc4:	e0bffb17 	ldw	r2,-20(fp)
 90bfbc8:	10800417 	ldw	r2,16(r2)
 90bfbcc:	1007883a 	mov	r3,r2
 90bfbd0:	e0bff70b 	ldhu	r2,-36(fp)
 90bfbd4:	1885883a 	add	r2,r3,r2
 90bfbd8:	10bfffc4 	addi	r2,r2,-1
 90bfbdc:	e0bff68d 	sth	r2,-38(fp)
 90bfbe0:	00009d06 	br	90bfe58 <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90bfbe4:	01000084 	movi	r4,2
 90bfbe8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90bfbec:	e13ffb17 	ldw	r4,-20(fp)
 90bfbf0:	90a8bd80 	call	90a8bd8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bfbf4:	01000084 	movi	r4,2
 90bfbf8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90bfbfc:	e03fff15 	stw	zero,-4(fp)
 90bfc00:	0000ae06 	br	90bfebc <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 90bfc04:	e0fff60b 	ldhu	r3,-40(fp)
 90bfc08:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc0c:	10c04d2e 	bgeu	r2,r3,90bfd44 <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 90bfc10:	e0fff58b 	ldhu	r3,-42(fp)
 90bfc14:	e0bff68b 	ldhu	r2,-38(fp)
 90bfc18:	10c0112e 	bgeu	r2,r3,90bfc60 <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 90bfc1c:	e0fff60b 	ldhu	r3,-40(fp)
 90bfc20:	e0bff68b 	ldhu	r2,-38(fp)
 90bfc24:	10c08c36 	bltu	r2,r3,90bfe58 <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 90bfc28:	e0fff60b 	ldhu	r3,-40(fp)
 90bfc2c:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc30:	1885c83a 	sub	r2,r3,r2
 90bfc34:	1007883a 	mov	r3,r2
 90bfc38:	e0bffb17 	ldw	r2,-20(fp)
 90bfc3c:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 90bfc40:	e0bffb17 	ldw	r2,-20(fp)
 90bfc44:	10800417 	ldw	r2,16(r2)
 90bfc48:	1007883a 	mov	r3,r2
 90bfc4c:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc50:	1885883a 	add	r2,r3,r2
 90bfc54:	10bfffc4 	addi	r2,r2,-1
 90bfc58:	e0bff68d 	sth	r2,-38(fp)
 90bfc5c:	00007e06 	br	90bfe58 <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 90bfc60:	e0fff58b 	ldhu	r3,-42(fp)
 90bfc64:	e0bff68b 	ldhu	r2,-38(fp)
 90bfc68:	18800e1e 	bne	r3,r2,90bfca4 <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 90bfc6c:	e0fff60b 	ldhu	r3,-40(fp)
 90bfc70:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc74:	1885c83a 	sub	r2,r3,r2
 90bfc78:	1007883a 	mov	r3,r2
 90bfc7c:	e0bffb17 	ldw	r2,-20(fp)
 90bfc80:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 90bfc84:	e0bffb17 	ldw	r2,-20(fp)
 90bfc88:	10800417 	ldw	r2,16(r2)
 90bfc8c:	1007883a 	mov	r3,r2
 90bfc90:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc94:	1885883a 	add	r2,r3,r2
 90bfc98:	10bfffc4 	addi	r2,r2,-1
 90bfc9c:	e0bff68d 	sth	r2,-38(fp)
 90bfca0:	00006d06 	br	90bfe58 <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 90bfca4:	e0bff917 	ldw	r2,-28(fp)
 90bfca8:	10800217 	ldw	r2,8(r2)
 90bfcac:	113fffcc 	andi	r4,r2,65535
 90bfcb0:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 90bfcb4:	e0bffc17 	ldw	r2,-16(fp)
 90bfcb8:	10c0048b 	ldhu	r3,18(r2)
 90bfcbc:	e0bff917 	ldw	r2,-28(fp)
 90bfcc0:	10800417 	ldw	r2,16(r2)
 90bfcc4:	1885c83a 	sub	r2,r3,r2
 90bfcc8:	1007883a 	mov	r3,r2
 90bfccc:	e0bffc17 	ldw	r2,-16(fp)
 90bfcd0:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90bfcd4:	01000084 	movi	r4,2
 90bfcd8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 90bfcdc:	e13ff917 	ldw	r4,-28(fp)
 90bfce0:	90a8bd80 	call	90a8bd8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bfce4:	01000084 	movi	r4,2
 90bfce8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 90bfcec:	e0bff40b 	ldhu	r2,-48(fp)
 90bfcf0:	e0fffa17 	ldw	r3,-24(fp)
 90bfcf4:	1085883a 	add	r2,r2,r2
 90bfcf8:	1085883a 	add	r2,r2,r2
 90bfcfc:	10c5883a 	add	r2,r2,r3
 90bfd00:	10800104 	addi	r2,r2,4
 90bfd04:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 90bfd08:	e0bffd17 	ldw	r2,-12(fp)
 90bfd0c:	1080000b 	ldhu	r2,0(r2)
 90bfd10:	10bfffcc 	andi	r2,r2,65535
 90bfd14:	10800418 	cmpnei	r2,r2,16
 90bfd18:	1000061e 	bne	r2,zero,90bfd34 <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 90bfd1c:	e0fffd17 	ldw	r3,-12(fp)
 90bfd20:	e0bff40b 	ldhu	r2,-48(fp)
 90bfd24:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 90bfd28:	e0fffe17 	ldw	r3,-8(fp)
 90bfd2c:	e0bffa17 	ldw	r2,-24(fp)
 90bfd30:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 90bfd34:	e0c00317 	ldw	r3,12(fp)
 90bfd38:	00800044 	movi	r2,1
 90bfd3c:	18800005 	stb	r2,0(r3)
 90bfd40:	00004506 	br	90bfe58 <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 90bfd44:	e0fff58b 	ldhu	r3,-42(fp)
 90bfd48:	e0bff68b 	ldhu	r2,-38(fp)
 90bfd4c:	1880081e 	bne	r3,r2,90bfd70 <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90bfd50:	01000084 	movi	r4,2
 90bfd54:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90bfd58:	e13ffb17 	ldw	r4,-20(fp)
 90bfd5c:	90a8bd80 	call	90a8bd8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bfd60:	01000084 	movi	r4,2
 90bfd64:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90bfd68:	e03fff15 	stw	zero,-4(fp)
 90bfd6c:	00005306 	br	90bfebc <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 90bfd70:	e0fff58b 	ldhu	r3,-42(fp)
 90bfd74:	e0bff68b 	ldhu	r2,-38(fp)
 90bfd78:	10c0082e 	bgeu	r2,r3,90bfd9c <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90bfd7c:	01000084 	movi	r4,2
 90bfd80:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90bfd84:	e13ffb17 	ldw	r4,-20(fp)
 90bfd88:	90a8bd80 	call	90a8bd8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bfd8c:	01000084 	movi	r4,2
 90bfd90:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90bfd94:	e03fff15 	stw	zero,-4(fp)
 90bfd98:	00004806 	br	90bfebc <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 90bfd9c:	e0fff58b 	ldhu	r3,-42(fp)
 90bfda0:	e0bff70b 	ldhu	r2,-36(fp)
 90bfda4:	1885c83a 	sub	r2,r3,r2
 90bfda8:	10800044 	addi	r2,r2,1
 90bfdac:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 90bfdb0:	e0bffb17 	ldw	r2,-20(fp)
 90bfdb4:	10c00317 	ldw	r3,12(r2)
 90bfdb8:	e0bff50b 	ldhu	r2,-44(fp)
 90bfdbc:	1887883a 	add	r3,r3,r2
 90bfdc0:	e0bffb17 	ldw	r2,-20(fp)
 90bfdc4:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 90bfdc8:	e0bffb17 	ldw	r2,-20(fp)
 90bfdcc:	10c00417 	ldw	r3,16(r2)
 90bfdd0:	e0bff50b 	ldhu	r2,-44(fp)
 90bfdd4:	1887c83a 	sub	r3,r3,r2
 90bfdd8:	e0bffb17 	ldw	r2,-20(fp)
 90bfddc:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 90bfde0:	e0fff70b 	ldhu	r3,-36(fp)
 90bfde4:	e0bff50b 	ldhu	r2,-44(fp)
 90bfde8:	1885883a 	add	r2,r3,r2
 90bfdec:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 90bfdf0:	e0bffb17 	ldw	r2,-20(fp)
 90bfdf4:	10800417 	ldw	r2,16(r2)
 90bfdf8:	1007883a 	mov	r3,r2
 90bfdfc:	e0bff70b 	ldhu	r2,-36(fp)
 90bfe00:	1885883a 	add	r2,r3,r2
 90bfe04:	10bfffc4 	addi	r2,r2,-1
 90bfe08:	e0bff68d 	sth	r2,-38(fp)
 90bfe0c:	00001206 	br	90bfe58 <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 90bfe10:	e0bffd17 	ldw	r2,-12(fp)
 90bfe14:	1080000b 	ldhu	r2,0(r2)
 90bfe18:	10bfffcc 	andi	r2,r2,65535
 90bfe1c:	10800418 	cmpnei	r2,r2,16
 90bfe20:	1000061e 	bne	r2,zero,90bfe3c <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 90bfe24:	e0fffd17 	ldw	r3,-12(fp)
 90bfe28:	e0bff40b 	ldhu	r2,-48(fp)
 90bfe2c:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 90bfe30:	e0fffe17 	ldw	r3,-8(fp)
 90bfe34:	e0bffa17 	ldw	r2,-24(fp)
 90bfe38:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 90bfe3c:	e0bffc17 	ldw	r2,-16(fp)
 90bfe40:	10802103 	ldbu	r2,132(r2)
 90bfe44:	10803fcc 	andi	r2,r2,255
 90bfe48:	1080004c 	andi	r2,r2,1
 90bfe4c:	10803fcc 	andi	r2,r2,255
 90bfe50:	1004c03a 	cmpne	r2,r2,zero
 90bfe54:	1000061e 	bne	r2,zero,90bfe70 <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90bfe58:	e0bff40b 	ldhu	r2,-48(fp)
 90bfe5c:	10800044 	addi	r2,r2,1
 90bfe60:	e0bff40d 	sth	r2,-48(fp)
 90bfe64:	e0bff40b 	ldhu	r2,-48(fp)
 90bfe68:	10800430 	cmpltui	r2,r2,16
 90bfe6c:	103f1e1e 	bne	r2,zero,90bfae8 <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 90bfe70:	e0bffd17 	ldw	r2,-12(fp)
 90bfe74:	1080000b 	ldhu	r2,0(r2)
 90bfe78:	10bfffcc 	andi	r2,r2,65535
 90bfe7c:	10800418 	cmpnei	r2,r2,16
 90bfe80:	1000031e 	bne	r2,zero,90bfe90 <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 90bfe84:	e0fffe17 	ldw	r3,-8(fp)
 90bfe88:	e0bffa17 	ldw	r2,-24(fp)
 90bfe8c:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 90bfe90:	e0bffa17 	ldw	r2,-24(fp)
 90bfe94:	10800017 	ldw	r2,0(r2)
 90bfe98:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 90bfe9c:	e0bffa17 	ldw	r2,-24(fp)
 90bfea0:	1004c03a 	cmpne	r2,r2,zero
 90bfea4:	103f0e1e 	bne	r2,zero,90bfae0 <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 90bfea8:	e0c00217 	ldw	r3,8(fp)
 90bfeac:	e0bff70b 	ldhu	r2,-36(fp)
 90bfeb0:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 90bfeb4:	00800084 	movi	r2,2
 90bfeb8:	e0bfff15 	stw	r2,-4(fp)
 90bfebc:	e0bfff17 	ldw	r2,-4(fp)
}
 90bfec0:	e037883a 	mov	sp,fp
 90bfec4:	dfc00117 	ldw	ra,4(sp)
 90bfec8:	df000017 	ldw	fp,0(sp)
 90bfecc:	dec00204 	addi	sp,sp,8
 90bfed0:	f800283a 	ret

090bfed4 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 90bfed4:	deffed04 	addi	sp,sp,-76
 90bfed8:	dfc01215 	stw	ra,72(sp)
 90bfedc:	df001115 	stw	fp,68(sp)
 90bfee0:	df001104 	addi	fp,sp,68
 90bfee4:	e13ffa15 	stw	r4,-24(fp)
 90bfee8:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 90bfeec:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90bfef0:	e13ffb17 	ldw	r4,-20(fp)
 90bfef4:	90c04680 	call	90c0468 <ip_reasm_find_ire>
 90bfef8:	10803fcc 	andi	r2,r2,255
 90bfefc:	10800060 	cmpeqi	r2,r2,1
 90bff00:	1000171e 	bne	r2,zero,90bff60 <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 90bff04:	008243b4 	movhi	r2,2318
 90bff08:	10b67804 	addi	r2,r2,-9760
 90bff0c:	10800017 	ldw	r2,0(r2)
 90bff10:	10c00044 	addi	r3,r2,1
 90bff14:	008243b4 	movhi	r2,2318
 90bff18:	10b67804 	addi	r2,r2,-9760
 90bff1c:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90bff20:	01000084 	movi	r4,2
 90bff24:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free (p);
 90bff28:	e13ffa17 	ldw	r4,-24(fp)
 90bff2c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90bff30:	01000084 	movi	r4,2
 90bff34:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90bff38:	008243b4 	movhi	r2,2318
 90bff3c:	10b66404 	addi	r2,r2,-9840
 90bff40:	10800f17 	ldw	r2,60(r2)
 90bff44:	10c00044 	addi	r3,r2,1
 90bff48:	008243b4 	movhi	r2,2318
 90bff4c:	10b66404 	addi	r2,r2,-9840
 90bff50:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 90bff54:	00bffd84 	movi	r2,-10
 90bff58:	e0bffe15 	stw	r2,-8(fp)
 90bff5c:	00013c06 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 90bff60:	e0bffa17 	ldw	r2,-24(fp)
 90bff64:	10800317 	ldw	r2,12(r2)
 90bff68:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 90bff6c:	e13ff517 	ldw	r4,-44(fp)
 90bff70:	90bf2f80 	call	90bf2f8 <ip_reasm_determine_type_of_frag>
 90bff74:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 90bff78:	e0bff217 	ldw	r2,-56(fp)
 90bff7c:	10800158 	cmpnei	r2,r2,5
 90bff80:	10002c1e 	bne	r2,zero,90c0034 <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 90bff84:	e0bff517 	ldw	r2,-44(fp)
 90bff88:	1080018b 	ldhu	r2,6(r2)
 90bff8c:	10bfffcc 	andi	r2,r2,65535
 90bff90:	1004d23a 	srli	r2,r2,8
 90bff94:	10803fcc 	andi	r2,r2,255
 90bff98:	1009883a 	mov	r4,r2
 90bff9c:	e0bff517 	ldw	r2,-44(fp)
 90bffa0:	1080018b 	ldhu	r2,6(r2)
 90bffa4:	10bfffcc 	andi	r2,r2,65535
 90bffa8:	1004923a 	slli	r2,r2,8
 90bffac:	1007883a 	mov	r3,r2
 90bffb0:	00bfc004 	movi	r2,-256
 90bffb4:	1884703a 	and	r2,r3,r2
 90bffb8:	2084b03a 	or	r2,r4,r2
 90bffbc:	1087ffcc 	andi	r2,r2,8191
 90bffc0:	100490fa 	slli	r2,r2,3
 90bffc4:	100b883a 	mov	r5,r2
 90bffc8:	e0bff517 	ldw	r2,-44(fp)
 90bffcc:	1080008b 	ldhu	r2,2(r2)
 90bffd0:	10bfffcc 	andi	r2,r2,65535
 90bffd4:	1004d23a 	srli	r2,r2,8
 90bffd8:	10803fcc 	andi	r2,r2,255
 90bffdc:	1009883a 	mov	r4,r2
 90bffe0:	e0bff517 	ldw	r2,-44(fp)
 90bffe4:	1080008b 	ldhu	r2,2(r2)
 90bffe8:	10bfffcc 	andi	r2,r2,65535
 90bffec:	1004923a 	slli	r2,r2,8
 90bfff0:	1007883a 	mov	r3,r2
 90bfff4:	00bfc004 	movi	r2,-256
 90bfff8:	1884703a 	and	r2,r3,r2
 90bfffc:	2084b03a 	or	r2,r4,r2
 90c0000:	1007883a 	mov	r3,r2
 90c0004:	e0bff517 	ldw	r2,-44(fp)
 90c0008:	10800003 	ldbu	r2,0(r2)
 90c000c:	10803fcc 	andi	r2,r2,255
 90c0010:	108003cc 	andi	r2,r2,15
 90c0014:	1085883a 	add	r2,r2,r2
 90c0018:	1085883a 	add	r2,r2,r2
 90c001c:	1885c83a 	sub	r2,r3,r2
 90c0020:	2885883a 	add	r2,r5,r2
 90c0024:	1007883a 	mov	r3,r2
 90c0028:	e0bffb17 	ldw	r2,-20(fp)
 90c002c:	10c0040d 	sth	r3,16(r2)
 90c0030:	00000a06 	br	90c005c <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 90c0034:	e0bff217 	ldw	r2,-56(fp)
 90c0038:	10800058 	cmpnei	r2,r2,1
 90c003c:	1000071e 	bne	r2,zero,90c005c <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 90c0040:	e0bffa17 	ldw	r2,-24(fp)
 90c0044:	10c00117 	ldw	r3,4(r2)
 90c0048:	e0bffb17 	ldw	r2,-20(fp)
 90c004c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 90c0050:	e0fff517 	ldw	r3,-44(fp)
 90c0054:	e0bffb17 	ldw	r2,-20(fp)
 90c0058:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 90c005c:	e1bff704 	addi	r6,fp,-36
 90c0060:	e1fff804 	addi	r7,fp,-32
 90c0064:	e0bff904 	addi	r2,fp,-28
 90c0068:	d8800015 	stw	r2,0(sp)
 90c006c:	e0bff984 	addi	r2,fp,-26
 90c0070:	d8800115 	stw	r2,4(sp)
 90c0074:	e13ffa17 	ldw	r4,-24(fp)
 90c0078:	e17ffb17 	ldw	r5,-20(fp)
 90c007c:	90bf9440 	call	90bf944 <ip_reasm_compute_overlap>
 90c0080:	e0bff115 	stw	r2,-60(fp)
 90c0084:	e0bff117 	ldw	r2,-60(fp)
 90c0088:	108000a0 	cmpeqi	r2,r2,2
 90c008c:	10000e1e 	bne	r2,zero,90c00c8 <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 90c0090:	e0fff117 	ldw	r3,-60(fp)
 90c0094:	e0ffff15 	stw	r3,-4(fp)
 90c0098:	e13fff17 	ldw	r4,-4(fp)
 90c009c:	2005003a 	cmpeq	r2,r4,zero
 90c00a0:	1000041e 	bne	r2,zero,90c00b4 <ip_reasm_process_subsequent_fragments+0x1e0>
 90c00a4:	e0ffff17 	ldw	r3,-4(fp)
 90c00a8:	18800060 	cmpeqi	r2,r3,1
 90c00ac:	1000031e 	bne	r2,zero,90c00bc <ip_reasm_process_subsequent_fragments+0x1e8>
 90c00b0:	00000506 	br	90c00c8 <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 90c00b4:	e03ffe15 	stw	zero,-8(fp)
 90c00b8:	0000e506 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 90c00bc:	013ffd84 	movi	r4,-10
 90c00c0:	e13ffe15 	stw	r4,-8(fp)
 90c00c4:	0000e206 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 90c00c8:	e0bffa17 	ldw	r2,-24(fp)
 90c00cc:	10800217 	ldw	r2,8(r2)
 90c00d0:	113fffcc 	andi	r4,r2,65535
 90c00d4:	90bf3e40 	call	90bf3e4 <ip_reasm_check_mem_useage>
 90c00d8:	e0bff315 	stw	r2,-52(fp)
 90c00dc:	e0bff317 	ldw	r2,-52(fp)
 90c00e0:	1005003a 	cmpeq	r2,r2,zero
 90c00e4:	1000121e 	bne	r2,zero,90c0130 <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c00e8:	01000084 	movi	r4,2
 90c00ec:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c00f0:	e13ffa17 	ldw	r4,-24(fp)
 90c00f4:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c00f8:	01000084 	movi	r4,2
 90c00fc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 90c0100:	e13ffb17 	ldw	r4,-20(fp)
 90c0104:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 90c0108:	008243b4 	movhi	r2,2318
 90c010c:	10b66404 	addi	r2,r2,-9840
 90c0110:	10800f17 	ldw	r2,60(r2)
 90c0114:	10c00044 	addi	r3,r2,1
 90c0118:	008243b4 	movhi	r2,2318
 90c011c:	10b66404 	addi	r2,r2,-9840
 90c0120:	10c00f15 	stw	r3,60(r2)
      return rc;
 90c0124:	e0bff317 	ldw	r2,-52(fp)
 90c0128:	e0bffe15 	stw	r2,-8(fp)
 90c012c:	0000c806 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 90c0130:	e0bff70b 	ldhu	r2,-36(fp)
 90c0134:	10bfffcc 	andi	r2,r2,65535
 90c0138:	10800420 	cmpeqi	r2,r2,16
 90c013c:	1000121e 	bne	r2,zero,90c0188 <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 90c0140:	e0fff817 	ldw	r3,-32(fp)
 90c0144:	e0bff70b 	ldhu	r2,-36(fp)
 90c0148:	10bfffcc 	andi	r2,r2,65535
 90c014c:	1085883a 	add	r2,r2,r2
 90c0150:	1085883a 	add	r2,r2,r2
 90c0154:	10c5883a 	add	r2,r2,r3
 90c0158:	10c00104 	addi	r3,r2,4
 90c015c:	e0bffa17 	ldw	r2,-24(fp)
 90c0160:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 90c0164:	e0fff817 	ldw	r3,-32(fp)
 90c0168:	e0bff70b 	ldhu	r2,-36(fp)
 90c016c:	10bfffcc 	andi	r2,r2,65535
 90c0170:	e13ff90b 	ldhu	r4,-28(fp)
 90c0174:	1085883a 	add	r2,r2,r2
 90c0178:	10c5883a 	add	r2,r2,r3
 90c017c:	10801104 	addi	r2,r2,68
 90c0180:	1100000d 	sth	r4,0(r2)
 90c0184:	00003c06 	br	90c0278 <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 90c0188:	e0bffa17 	ldw	r2,-24(fp)
 90c018c:	10800217 	ldw	r2,8(r2)
 90c0190:	10801904 	addi	r2,r2,100
 90c0194:	113fffcc 	andi	r4,r2,65535
 90c0198:	90bf3e40 	call	90bf3e4 <ip_reasm_check_mem_useage>
 90c019c:	e0bff315 	stw	r2,-52(fp)
 90c01a0:	e0bff317 	ldw	r2,-52(fp)
 90c01a4:	1005003a 	cmpeq	r2,r2,zero
 90c01a8:	1000121e 	bne	r2,zero,90c01f4 <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c01ac:	01000084 	movi	r4,2
 90c01b0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free (p);
 90c01b4:	e13ffa17 	ldw	r4,-24(fp)
 90c01b8:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c01bc:	01000084 	movi	r4,2
 90c01c0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 90c01c4:	e13ffb17 	ldw	r4,-20(fp)
 90c01c8:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c01cc:	008243b4 	movhi	r2,2318
 90c01d0:	10b66404 	addi	r2,r2,-9840
 90c01d4:	10800f17 	ldw	r2,60(r2)
 90c01d8:	10c00044 	addi	r3,r2,1
 90c01dc:	008243b4 	movhi	r2,2318
 90c01e0:	10b66404 	addi	r2,r2,-9840
 90c01e4:	10c00f15 	stw	r3,60(r2)
         return rc;
 90c01e8:	e0fff317 	ldw	r3,-52(fp)
 90c01ec:	e0fffe15 	stw	r3,-8(fp)
 90c01f0:	00009706 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 90c01f4:	01001904 	movi	r4,100
 90c01f8:	90a9f0c0 	call	90a9f0c <npalloc>
 90c01fc:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 90c0200:	e0bff417 	ldw	r2,-48(fp)
 90c0204:	1004c03a 	cmpne	r2,r2,zero
 90c0208:	1000121e 	bne	r2,zero,90c0254 <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c020c:	01000084 	movi	r4,2
 90c0210:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free (p);
 90c0214:	e13ffa17 	ldw	r4,-24(fp)
 90c0218:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c021c:	01000084 	movi	r4,2
 90c0220:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 90c0224:	e13ffb17 	ldw	r4,-20(fp)
 90c0228:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c022c:	008243b4 	movhi	r2,2318
 90c0230:	10b66404 	addi	r2,r2,-9840
 90c0234:	10800f17 	ldw	r2,60(r2)
 90c0238:	10c00044 	addi	r3,r2,1
 90c023c:	008243b4 	movhi	r2,2318
 90c0240:	10b66404 	addi	r2,r2,-9840
 90c0244:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 90c0248:	013ffa84 	movi	r4,-22
 90c024c:	e13ffe15 	stw	r4,-8(fp)
 90c0250:	00007f06 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 90c0254:	e0fff417 	ldw	r3,-48(fp)
 90c0258:	e0bffa17 	ldw	r2,-24(fp)
 90c025c:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 90c0260:	e0fff90b 	ldhu	r3,-28(fp)
 90c0264:	e0bff417 	ldw	r2,-48(fp)
 90c0268:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 90c026c:	e0fff817 	ldw	r3,-32(fp)
 90c0270:	e0bff417 	ldw	r2,-48(fp)
 90c0274:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 90c0278:	e0bff983 	ldbu	r2,-26(fp)
 90c027c:	10803fcc 	andi	r2,r2,255
 90c0280:	1005003a 	cmpeq	r2,r2,zero
 90c0284:	1000161e 	bne	r2,zero,90c02e0 <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 90c0288:	e13ffb17 	ldw	r4,-20(fp)
 90c028c:	90c0b0c0 	call	90c0b0c <ip_reasm_mark_compact_rfq>
 90c0290:	e0bff315 	stw	r2,-52(fp)
 90c0294:	e0bff317 	ldw	r2,-52(fp)
 90c0298:	1005003a 	cmpeq	r2,r2,zero
 90c029c:	1000101e 	bne	r2,zero,90c02e0 <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 90c02a0:	01000084 	movi	r4,2
 90c02a4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free (p);
 90c02a8:	e13ffa17 	ldw	r4,-24(fp)
 90c02ac:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c02b0:	01000084 	movi	r4,2
 90c02b4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 90c02b8:	008243b4 	movhi	r2,2318
 90c02bc:	10b66404 	addi	r2,r2,-9840
 90c02c0:	10800f17 	ldw	r2,60(r2)
 90c02c4:	10c00044 	addi	r3,r2,1
 90c02c8:	008243b4 	movhi	r2,2318
 90c02cc:	10b66404 	addi	r2,r2,-9840
 90c02d0:	10c00f15 	stw	r3,60(r2)
            return rc;
 90c02d4:	e0bff317 	ldw	r2,-52(fp)
 90c02d8:	e0bffe15 	stw	r2,-8(fp)
 90c02dc:	00005c06 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 90c02e0:	e0bffb17 	ldw	r2,-20(fp)
 90c02e4:	10c0048b 	ldhu	r3,18(r2)
 90c02e8:	e0bffa17 	ldw	r2,-24(fp)
 90c02ec:	10800417 	ldw	r2,16(r2)
 90c02f0:	1885883a 	add	r2,r3,r2
 90c02f4:	1007883a 	mov	r3,r2
 90c02f8:	e0bffb17 	ldw	r2,-20(fp)
 90c02fc:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 90c0300:	e0bffa17 	ldw	r2,-24(fp)
 90c0304:	10800217 	ldw	r2,8(r2)
 90c0308:	e0bffd0d 	sth	r2,-12(fp)
 90c030c:	e0bff417 	ldw	r2,-48(fp)
 90c0310:	1004c03a 	cmpne	r2,r2,zero
 90c0314:	1000021e 	bne	r2,zero,90c0320 <ip_reasm_process_subsequent_fragments+0x44c>
 90c0318:	e03ffc0d 	sth	zero,-16(fp)
 90c031c:	00000206 	br	90c0328 <ip_reasm_process_subsequent_fragments+0x454>
 90c0320:	00c01904 	movi	r3,100
 90c0324:	e0fffc0d 	sth	r3,-16(fp)
 90c0328:	e13ffd0b 	ldhu	r4,-12(fp)
 90c032c:	e0fffc0b 	ldhu	r3,-16(fp)
 90c0330:	20c5883a 	add	r2,r4,r3
 90c0334:	113fffcc 	andi	r4,r2,65535
 90c0338:	90bf47c0 	call	90bf47c <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 90c033c:	e0bffb17 	ldw	r2,-20(fp)
 90c0340:	1080040b 	ldhu	r2,16(r2)
 90c0344:	10bfffcc 	andi	r2,r2,65535
 90c0348:	1005003a 	cmpeq	r2,r2,zero
 90c034c:	10003f1e 	bne	r2,zero,90c044c <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 90c0350:	e0bffb17 	ldw	r2,-20(fp)
 90c0354:	10c0048b 	ldhu	r3,18(r2)
 90c0358:	e0bffb17 	ldw	r2,-20(fp)
 90c035c:	1080040b 	ldhu	r2,16(r2)
 90c0360:	18ffffcc 	andi	r3,r3,65535
 90c0364:	10bfffcc 	andi	r2,r2,65535
 90c0368:	1880381e 	bne	r3,r2,90c044c <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 90c036c:	e0bffb17 	ldw	r2,-20(fp)
 90c0370:	10802017 	ldw	r2,128(r2)
 90c0374:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0378:	01000084 	movi	r4,2
 90c037c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 90c0380:	e0bffb17 	ldw	r2,-20(fp)
 90c0384:	1080040b 	ldhu	r2,16(r2)
 90c0388:	113fffcc 	andi	r4,r2,65535
 90c038c:	e0bffb17 	ldw	r2,-20(fp)
 90c0390:	10802017 	ldw	r2,128(r2)
 90c0394:	1007883a 	mov	r3,r2
 90c0398:	e0bffb17 	ldw	r2,-20(fp)
 90c039c:	10801f17 	ldw	r2,124(r2)
 90c03a0:	1885c83a 	sub	r2,r3,r2
 90c03a4:	2087883a 	add	r3,r4,r2
 90c03a8:	e0bff517 	ldw	r2,-44(fp)
 90c03ac:	10800003 	ldbu	r2,0(r2)
 90c03b0:	10803fcc 	andi	r2,r2,255
 90c03b4:	108003cc 	andi	r2,r2,15
 90c03b8:	1085883a 	add	r2,r2,r2
 90c03bc:	1085883a 	add	r2,r2,r2
 90c03c0:	1885883a 	add	r2,r3,r2
 90c03c4:	1009883a 	mov	r4,r2
 90c03c8:	90a88440 	call	90a8844 <pk_alloc>
 90c03cc:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c03d0:	01000084 	movi	r4,2
 90c03d4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 90c03d8:	e0bff617 	ldw	r2,-40(fp)
 90c03dc:	1004c03a 	cmpne	r2,r2,zero
 90c03e0:	10000c1e 	bne	r2,zero,90c0414 <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 90c03e4:	e13ffb17 	ldw	r4,-20(fp)
 90c03e8:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 90c03ec:	008243b4 	movhi	r2,2318
 90c03f0:	10b66404 	addi	r2,r2,-9840
 90c03f4:	10800f17 	ldw	r2,60(r2)
 90c03f8:	10c00044 	addi	r3,r2,1
 90c03fc:	008243b4 	movhi	r2,2318
 90c0400:	10b66404 	addi	r2,r2,-9840
 90c0404:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 90c0408:	013ffac4 	movi	r4,-21
 90c040c:	e13ffe15 	stw	r4,-8(fp)
 90c0410:	00000f06 	br	90c0450 <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 90c0414:	e13ff617 	ldw	r4,-40(fp)
 90c0418:	e17ffb17 	ldw	r5,-20(fp)
 90c041c:	90c04cc0 	call	90c04cc <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 90c0420:	e13ffb17 	ldw	r4,-20(fp)
 90c0424:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 90c0428:	008243b4 	movhi	r2,2318
 90c042c:	10b66404 	addi	r2,r2,-9840
 90c0430:	10800e17 	ldw	r2,56(r2)
 90c0434:	10c00044 	addi	r3,r2,1
 90c0438:	008243b4 	movhi	r2,2318
 90c043c:	10b66404 	addi	r2,r2,-9840
 90c0440:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 90c0444:	e13ff617 	ldw	r4,-40(fp)
 90c0448:	90c1a340 	call	90c1a34 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 90c044c:	e03ffe15 	stw	zero,-8(fp)
 90c0450:	e0bffe17 	ldw	r2,-8(fp)
}
 90c0454:	e037883a 	mov	sp,fp
 90c0458:	dfc00117 	ldw	ra,4(sp)
 90c045c:	df000017 	ldw	fp,0(sp)
 90c0460:	dec00204 	addi	sp,sp,8
 90c0464:	f800283a 	ret

090c0468 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 90c0468:	defffc04 	addi	sp,sp,-16
 90c046c:	df000315 	stw	fp,12(sp)
 90c0470:	df000304 	addi	fp,sp,12
 90c0474:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c0478:	d0a0c817 	ldw	r2,-31968(gp)
 90c047c:	e0bffd15 	stw	r2,-12(fp)
 90c0480:	00000906 	br	90c04a8 <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 90c0484:	e0fffd17 	ldw	r3,-12(fp)
 90c0488:	e0bffe17 	ldw	r2,-8(fp)
 90c048c:	1880031e 	bne	r3,r2,90c049c <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 90c0490:	00800044 	movi	r2,1
 90c0494:	e0bfff15 	stw	r2,-4(fp)
 90c0498:	00000706 	br	90c04b8 <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c049c:	e0bffd17 	ldw	r2,-12(fp)
 90c04a0:	10800017 	ldw	r2,0(r2)
 90c04a4:	e0bffd15 	stw	r2,-12(fp)
 90c04a8:	e0bffd17 	ldw	r2,-12(fp)
 90c04ac:	1004c03a 	cmpne	r2,r2,zero
 90c04b0:	103ff41e 	bne	r2,zero,90c0484 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 90c04b4:	e03fff15 	stw	zero,-4(fp)
 90c04b8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c04bc:	e037883a 	mov	sp,fp
 90c04c0:	df000017 	ldw	fp,0(sp)
 90c04c4:	dec00104 	addi	sp,sp,4
 90c04c8:	f800283a 	ret

090c04cc <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 90c04cc:	defff404 	addi	sp,sp,-48
 90c04d0:	dfc00b15 	stw	ra,44(sp)
 90c04d4:	df000a15 	stw	fp,40(sp)
 90c04d8:	df000a04 	addi	fp,sp,40
 90c04dc:	e13ffe15 	stw	r4,-8(fp)
 90c04e0:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 90c04e4:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 90c04e8:	e0bfff17 	ldw	r2,-4(fp)
 90c04ec:	10802017 	ldw	r2,128(r2)
 90c04f0:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 90c04f4:	e0bffd17 	ldw	r2,-12(fp)
 90c04f8:	10800003 	ldbu	r2,0(r2)
 90c04fc:	108003cc 	andi	r2,r2,15
 90c0500:	1085883a 	add	r2,r2,r2
 90c0504:	1085883a 	add	r2,r2,r2
 90c0508:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 90c050c:	e0bfff17 	ldw	r2,-4(fp)
 90c0510:	10802017 	ldw	r2,128(r2)
 90c0514:	1007883a 	mov	r3,r2
 90c0518:	e0bfff17 	ldw	r2,-4(fp)
 90c051c:	10801f17 	ldw	r2,124(r2)
 90c0520:	1885c83a 	sub	r2,r3,r2
 90c0524:	1007883a 	mov	r3,r2
 90c0528:	e0bff803 	ldbu	r2,-32(fp)
 90c052c:	1885883a 	add	r2,r3,r2
 90c0530:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 90c0534:	e0bffe17 	ldw	r2,-8(fp)
 90c0538:	11000117 	ldw	r4,4(r2)
 90c053c:	e0bfff17 	ldw	r2,-4(fp)
 90c0540:	10801f17 	ldw	r2,124(r2)
 90c0544:	e0fffc03 	ldbu	r3,-16(fp)
 90c0548:	100b883a 	mov	r5,r2
 90c054c:	180d883a 	mov	r6,r3
 90c0550:	90822780 	call	9082278 <memcpy>

   rfqp = &(irep->rfq);
 90c0554:	e0bfff17 	ldw	r2,-4(fp)
 90c0558:	10800604 	addi	r2,r2,24
 90c055c:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 90c0560:	e0bffe17 	ldw	r2,-8(fp)
 90c0564:	10c00117 	ldw	r3,4(r2)
 90c0568:	e0bffc03 	ldbu	r2,-16(fp)
 90c056c:	1885883a 	add	r2,r3,r2
 90c0570:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 90c0574:	00004606 	br	90c0690 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0578:	e03ffa0d 	sth	zero,-24(fp)
 90c057c:	00003e06 	br	90c0678 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 90c0580:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0584:	e0fffb17 	ldw	r3,-20(fp)
 90c0588:	1085883a 	add	r2,r2,r2
 90c058c:	1085883a 	add	r2,r2,r2
 90c0590:	10c5883a 	add	r2,r2,r3
 90c0594:	10800104 	addi	r2,r2,4
 90c0598:	10800017 	ldw	r2,0(r2)
 90c059c:	e0bff915 	stw	r2,-28(fp)
 90c05a0:	e0bff917 	ldw	r2,-28(fp)
 90c05a4:	1005003a 	cmpeq	r2,r2,zero
 90c05a8:	1000291e 	bne	r2,zero,90c0650 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 90c05ac:	e0bffa0b 	ldhu	r2,-24(fp)
 90c05b0:	e0fffb17 	ldw	r3,-20(fp)
 90c05b4:	1085883a 	add	r2,r2,r2
 90c05b8:	10c5883a 	add	r2,r2,r3
 90c05bc:	10801104 	addi	r2,r2,68
 90c05c0:	1080000b 	ldhu	r2,0(r2)
 90c05c4:	10bfffcc 	andi	r2,r2,65535
 90c05c8:	1007883a 	mov	r3,r2
 90c05cc:	e0bff717 	ldw	r2,-36(fp)
 90c05d0:	1887883a 	add	r3,r3,r2
 90c05d4:	e0bff917 	ldw	r2,-28(fp)
 90c05d8:	11400317 	ldw	r5,12(r2)
 90c05dc:	e0bff917 	ldw	r2,-28(fp)
 90c05e0:	10800417 	ldw	r2,16(r2)
 90c05e4:	1809883a 	mov	r4,r3
 90c05e8:	100d883a 	mov	r6,r2
 90c05ec:	90822780 	call	9082278 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 90c05f0:	e0bff617 	ldw	r2,-40(fp)
 90c05f4:	1004c03a 	cmpne	r2,r2,zero
 90c05f8:	1000031e 	bne	r2,zero,90c0608 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 90c05fc:	e0bff917 	ldw	r2,-28(fp)
 90c0600:	e0bff615 	stw	r2,-40(fp)
 90c0604:	00000a06 	br	90c0630 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 90c0608:	e0bff917 	ldw	r2,-28(fp)
 90c060c:	10800217 	ldw	r2,8(r2)
 90c0610:	113fffcc 	andi	r4,r2,65535
 90c0614:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0618:	01000084 	movi	r4,2
 90c061c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
               pk_free (p);
 90c0620:	e13ff917 	ldw	r4,-28(fp)
 90c0624:	90a8bd80 	call	90a8bd8 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0628:	01000084 	movi	r4,2
 90c062c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 90c0630:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0634:	e0fffb17 	ldw	r3,-20(fp)
 90c0638:	1085883a 	add	r2,r2,r2
 90c063c:	1085883a 	add	r2,r2,r2
 90c0640:	10c5883a 	add	r2,r2,r3
 90c0644:	10800104 	addi	r2,r2,4
 90c0648:	10000015 	stw	zero,0(r2)
 90c064c:	00000706 	br	90c066c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 90c0650:	e0bfff17 	ldw	r2,-4(fp)
 90c0654:	10802103 	ldbu	r2,132(r2)
 90c0658:	10803fcc 	andi	r2,r2,255
 90c065c:	1080004c 	andi	r2,r2,1
 90c0660:	10803fcc 	andi	r2,r2,255
 90c0664:	1004c03a 	cmpne	r2,r2,zero
 90c0668:	1000061e 	bne	r2,zero,90c0684 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c066c:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0670:	10800044 	addi	r2,r2,1
 90c0674:	e0bffa0d 	sth	r2,-24(fp)
 90c0678:	e0bffa0b 	ldhu	r2,-24(fp)
 90c067c:	10800430 	cmpltui	r2,r2,16
 90c0680:	103fbf1e 	bne	r2,zero,90c0580 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 90c0684:	e0bffb17 	ldw	r2,-20(fp)
 90c0688:	10800017 	ldw	r2,0(r2)
 90c068c:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 90c0690:	e0bffb17 	ldw	r2,-20(fp)
 90c0694:	1004c03a 	cmpne	r2,r2,zero
 90c0698:	103fb71e 	bne	r2,zero,90c0578 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 90c069c:	e0bffe17 	ldw	r2,-8(fp)
 90c06a0:	11000117 	ldw	r4,4(r2)
 90c06a4:	e0bfff17 	ldw	r2,-4(fp)
 90c06a8:	10802017 	ldw	r2,128(r2)
 90c06ac:	1007883a 	mov	r3,r2
 90c06b0:	e0bfff17 	ldw	r2,-4(fp)
 90c06b4:	10801f17 	ldw	r2,124(r2)
 90c06b8:	1885c83a 	sub	r2,r3,r2
 90c06bc:	2087883a 	add	r3,r4,r2
 90c06c0:	e0bffe17 	ldw	r2,-8(fp)
 90c06c4:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 90c06c8:	e0bfff17 	ldw	r2,-4(fp)
 90c06cc:	1080040b 	ldhu	r2,16(r2)
 90c06d0:	10ffffcc 	andi	r3,r2,65535
 90c06d4:	e0bff803 	ldbu	r2,-32(fp)
 90c06d8:	1885883a 	add	r2,r3,r2
 90c06dc:	1007883a 	mov	r3,r2
 90c06e0:	e0bffe17 	ldw	r2,-8(fp)
 90c06e4:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 90c06e8:	00824374 	movhi	r2,2317
 90c06ec:	108c4204 	addi	r2,r2,12552
 90c06f0:	10800017 	ldw	r2,0(r2)
 90c06f4:	1007883a 	mov	r3,r2
 90c06f8:	e0bffe17 	ldw	r2,-8(fp)
 90c06fc:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 90c0700:	e0bffe17 	ldw	r2,-8(fp)
 90c0704:	10c00a17 	ldw	r3,40(r2)
 90c0708:	e0bff617 	ldw	r2,-40(fp)
 90c070c:	10800a17 	ldw	r2,40(r2)
 90c0710:	108000cc 	andi	r2,r2,3
 90c0714:	1886b03a 	or	r3,r3,r2
 90c0718:	e0bffe17 	ldw	r2,-8(fp)
 90c071c:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 90c0720:	e0bff617 	ldw	r2,-40(fp)
 90c0724:	10c00617 	ldw	r3,24(r2)
 90c0728:	e0bffe17 	ldw	r2,-8(fp)
 90c072c:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 90c0730:	e0bff617 	ldw	r2,-40(fp)
 90c0734:	10c0080b 	ldhu	r3,32(r2)
 90c0738:	e0bffe17 	ldw	r2,-8(fp)
 90c073c:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 90c0740:	e0bff617 	ldw	r2,-40(fp)
 90c0744:	10800217 	ldw	r2,8(r2)
 90c0748:	113fffcc 	andi	r4,r2,65535
 90c074c:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0750:	01000084 	movi	r4,2
 90c0754:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 90c0758:	e13ff617 	ldw	r4,-40(fp)
 90c075c:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0760:	01000084 	movi	r4,2
 90c0764:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 90c0768:	e0bffe17 	ldw	r2,-8(fp)
 90c076c:	10800317 	ldw	r2,12(r2)
 90c0770:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 90c0774:	e0bffe17 	ldw	r2,-8(fp)
 90c0778:	10800417 	ldw	r2,16(r2)
 90c077c:	1004d23a 	srli	r2,r2,8
 90c0780:	10803fcc 	andi	r2,r2,255
 90c0784:	1009883a 	mov	r4,r2
 90c0788:	e0bffe17 	ldw	r2,-8(fp)
 90c078c:	10800417 	ldw	r2,16(r2)
 90c0790:	1004923a 	slli	r2,r2,8
 90c0794:	1007883a 	mov	r3,r2
 90c0798:	00bfc004 	movi	r2,-256
 90c079c:	1884703a 	and	r2,r3,r2
 90c07a0:	2084b03a 	or	r2,r4,r2
 90c07a4:	1007883a 	mov	r3,r2
 90c07a8:	e0bffd17 	ldw	r2,-12(fp)
 90c07ac:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 90c07b0:	e0bffd17 	ldw	r2,-12(fp)
 90c07b4:	10c0018b 	ldhu	r3,6(r2)
 90c07b8:	00bff7c4 	movi	r2,-33
 90c07bc:	1884703a 	and	r2,r3,r2
 90c07c0:	1007883a 	mov	r3,r2
 90c07c4:	e0bffd17 	ldw	r2,-12(fp)
 90c07c8:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 90c07cc:	e0bffd17 	ldw	r2,-12(fp)
 90c07d0:	1080018b 	ldhu	r2,6(r2)
 90c07d4:	1080380c 	andi	r2,r2,224
 90c07d8:	1007883a 	mov	r3,r2
 90c07dc:	e0bffd17 	ldw	r2,-12(fp)
 90c07e0:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 90c07e4:	e0bffd17 	ldw	r2,-12(fp)
 90c07e8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 90c07ec:	e0bff803 	ldbu	r2,-32(fp)
 90c07f0:	1004d07a 	srli	r2,r2,1
 90c07f4:	11403fcc 	andi	r5,r2,255
 90c07f8:	e13ffd17 	ldw	r4,-12(fp)
 90c07fc:	90a3f040 	call	90a3f04 <cksum>
 90c0800:	0084303a 	nor	r2,zero,r2
 90c0804:	1007883a 	mov	r3,r2
 90c0808:	e0bffd17 	ldw	r2,-12(fp)
 90c080c:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 90c0810:	0005883a 	mov	r2,zero
}
 90c0814:	e037883a 	mov	sp,fp
 90c0818:	dfc00117 	ldw	ra,4(sp)
 90c081c:	df000017 	ldw	fp,0(sp)
 90c0820:	dec00204 	addi	sp,sp,8
 90c0824:	f800283a 	ret

090c0828 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 90c0828:	defffc04 	addi	sp,sp,-16
 90c082c:	dfc00315 	stw	ra,12(sp)
 90c0830:	df000215 	stw	fp,8(sp)
 90c0834:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 90c0838:	0009883a 	mov	r4,zero
 90c083c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 90c0840:	d0a0c817 	ldw	r2,-31968(gp)
 90c0844:	e0bfff15 	stw	r2,-4(fp)
 90c0848:	00002006 	br	90c08cc <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 90c084c:	e0bfff17 	ldw	r2,-4(fp)
 90c0850:	10800017 	ldw	r2,0(r2)
 90c0854:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 90c0858:	e0bfff17 	ldw	r2,-4(fp)
 90c085c:	10800517 	ldw	r2,20(r2)
 90c0860:	10c00044 	addi	r3,r2,1
 90c0864:	e0bfff17 	ldw	r2,-4(fp)
 90c0868:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 90c086c:	e0bfff17 	ldw	r2,-4(fp)
 90c0870:	10800517 	ldw	r2,20(r2)
 90c0874:	10801e18 	cmpnei	r2,r2,120
 90c0878:	1000121e 	bne	r2,zero,90c08c4 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 90c087c:	008243b4 	movhi	r2,2318
 90c0880:	10b67804 	addi	r2,r2,-9760
 90c0884:	10800117 	ldw	r2,4(r2)
 90c0888:	10c00044 	addi	r3,r2,1
 90c088c:	008243b4 	movhi	r2,2318
 90c0890:	10b67804 	addi	r2,r2,-9760
 90c0894:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 90c0898:	e13fff17 	ldw	r4,-4(fp)
 90c089c:	90c0fd40 	call	90c0fd4 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 90c08a0:	e13fff17 	ldw	r4,-4(fp)
 90c08a4:	90c09440 	call	90c0944 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c08a8:	008243b4 	movhi	r2,2318
 90c08ac:	10b66404 	addi	r2,r2,-9840
 90c08b0:	10800f17 	ldw	r2,60(r2)
 90c08b4:	10c00044 	addi	r3,r2,1
 90c08b8:	008243b4 	movhi	r2,2318
 90c08bc:	10b66404 	addi	r2,r2,-9840
 90c08c0:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 90c08c4:	e0bffe17 	ldw	r2,-8(fp)
 90c08c8:	e0bfff15 	stw	r2,-4(fp)
 90c08cc:	e0bfff17 	ldw	r2,-4(fp)
 90c08d0:	1004c03a 	cmpne	r2,r2,zero
 90c08d4:	103fdd1e 	bne	r2,zero,90c084c <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 90c08d8:	00824374 	movhi	r2,2317
 90c08dc:	108c4204 	addi	r2,r2,12552
 90c08e0:	11000017 	ldw	r4,0(r2)
 90c08e4:	908c0380 	call	908c038 <__floatunsidf>
 90c08e8:	100b883a 	mov	r5,r2
 90c08ec:	180d883a 	mov	r6,r3
 90c08f0:	2809883a 	mov	r4,r5
 90c08f4:	300b883a 	mov	r5,r6
 90c08f8:	000d883a 	mov	r6,zero
 90c08fc:	01d01674 	movhi	r7,16473
 90c0900:	908b5400 	call	908b540 <__adddf3>
 90c0904:	1009883a 	mov	r4,r2
 90c0908:	180b883a 	mov	r5,r3
 90c090c:	2005883a 	mov	r2,r4
 90c0910:	2807883a 	mov	r3,r5
 90c0914:	1009883a 	mov	r4,r2
 90c0918:	180b883a 	mov	r5,r3
 90c091c:	90cade40 	call	90cade4 <__fixunsdfsi>
 90c0920:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90c0924:	0009883a 	mov	r4,zero
 90c0928:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 90c092c:	0005883a 	mov	r2,zero
}
 90c0930:	e037883a 	mov	sp,fp
 90c0934:	dfc00117 	ldw	ra,4(sp)
 90c0938:	df000017 	ldw	fp,0(sp)
 90c093c:	dec00204 	addi	sp,sp,8
 90c0940:	f800283a 	ret

090c0944 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 90c0944:	defff504 	addi	sp,sp,-44
 90c0948:	dfc00a15 	stw	ra,40(sp)
 90c094c:	df000915 	stw	fp,36(sp)
 90c0950:	df000904 	addi	fp,sp,36
 90c0954:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 90c0958:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c095c:	d0a0c817 	ldw	r2,-31968(gp)
 90c0960:	e0bff815 	stw	r2,-32(fp)
 90c0964:	00001406 	br	90c09b8 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 90c0968:	e0fff817 	ldw	r3,-32(fp)
 90c096c:	e0bffe17 	ldw	r2,-8(fp)
 90c0970:	18800c1e 	bne	r3,r2,90c09a4 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 90c0974:	d0e0c817 	ldw	r3,-31968(gp)
 90c0978:	e0bff817 	ldw	r2,-32(fp)
 90c097c:	10c0041e 	bne	r2,r3,90c0990 <ip_reasm_delete_ire+0x4c>
 90c0980:	e0bffe17 	ldw	r2,-8(fp)
 90c0984:	10800017 	ldw	r2,0(r2)
 90c0988:	d0a0c815 	stw	r2,-31968(gp)
 90c098c:	00000d06 	br	90c09c4 <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 90c0990:	e0bffe17 	ldw	r2,-8(fp)
 90c0994:	10c00017 	ldw	r3,0(r2)
 90c0998:	e0bff717 	ldw	r2,-36(fp)
 90c099c:	10c00015 	stw	r3,0(r2)
         break;
 90c09a0:	00000806 	br	90c09c4 <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 90c09a4:	e0bff817 	ldw	r2,-32(fp)
 90c09a8:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c09ac:	e0bff817 	ldw	r2,-32(fp)
 90c09b0:	10800017 	ldw	r2,0(r2)
 90c09b4:	e0bff815 	stw	r2,-32(fp)
 90c09b8:	e0bff817 	ldw	r2,-32(fp)
 90c09bc:	1004c03a 	cmpne	r2,r2,zero
 90c09c0:	103fe91e 	bne	r2,zero,90c0968 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 90c09c4:	e0bff817 	ldw	r2,-32(fp)
 90c09c8:	1004c03a 	cmpne	r2,r2,zero
 90c09cc:	10000a1e 	bne	r2,zero,90c09f8 <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 90c09d0:	008243b4 	movhi	r2,2318
 90c09d4:	10b67804 	addi	r2,r2,-9760
 90c09d8:	10800017 	ldw	r2,0(r2)
 90c09dc:	10c00044 	addi	r3,r2,1
 90c09e0:	008243b4 	movhi	r2,2318
 90c09e4:	10b67804 	addi	r2,r2,-9760
 90c09e8:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 90c09ec:	00bffd84 	movi	r2,-10
 90c09f0:	e0bfff15 	stw	r2,-4(fp)
 90c09f4:	00003f06 	br	90c0af4 <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 90c09f8:	e0bffe17 	ldw	r2,-8(fp)
 90c09fc:	10800604 	addi	r2,r2,24
 90c0a00:	e0bffc15 	stw	r2,-16(fp)
 90c0a04:	e0bffc17 	ldw	r2,-16(fp)
 90c0a08:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 90c0a0c:	00003106 	br	90c0ad4 <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0a10:	e03ffa0d 	sth	zero,-24(fp)
 90c0a14:	00002006 	br	90c0a98 <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 90c0a18:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0a1c:	e0fffd17 	ldw	r3,-12(fp)
 90c0a20:	1085883a 	add	r2,r2,r2
 90c0a24:	1085883a 	add	r2,r2,r2
 90c0a28:	10c5883a 	add	r2,r2,r3
 90c0a2c:	10800104 	addi	r2,r2,4
 90c0a30:	10800017 	ldw	r2,0(r2)
 90c0a34:	e0bff915 	stw	r2,-28(fp)
 90c0a38:	e0bff917 	ldw	r2,-28(fp)
 90c0a3c:	1005003a 	cmpeq	r2,r2,zero
 90c0a40:	10000b1e 	bne	r2,zero,90c0a70 <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 90c0a44:	e0bff917 	ldw	r2,-28(fp)
 90c0a48:	10800217 	ldw	r2,8(r2)
 90c0a4c:	113fffcc 	andi	r4,r2,65535
 90c0a50:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0a54:	01000084 	movi	r4,2
 90c0a58:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free (p);
 90c0a5c:	e13ff917 	ldw	r4,-28(fp)
 90c0a60:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 90c0a64:	01000084 	movi	r4,2
 90c0a68:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
 90c0a6c:	00000706 	br	90c0a8c <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 90c0a70:	e0bffe17 	ldw	r2,-8(fp)
 90c0a74:	10802103 	ldbu	r2,132(r2)
 90c0a78:	10803fcc 	andi	r2,r2,255
 90c0a7c:	1080004c 	andi	r2,r2,1
 90c0a80:	10803fcc 	andi	r2,r2,255
 90c0a84:	1004c03a 	cmpne	r2,r2,zero
 90c0a88:	1000061e 	bne	r2,zero,90c0aa4 <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0a8c:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0a90:	10800044 	addi	r2,r2,1
 90c0a94:	e0bffa0d 	sth	r2,-24(fp)
 90c0a98:	e0bffa0b 	ldhu	r2,-24(fp)
 90c0a9c:	10800430 	cmpltui	r2,r2,16
 90c0aa0:	103fdd1e 	bne	r2,zero,90c0a18 <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 90c0aa4:	e0bffd17 	ldw	r2,-12(fp)
 90c0aa8:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 90c0aac:	e0bffd17 	ldw	r2,-12(fp)
 90c0ab0:	10800017 	ldw	r2,0(r2)
 90c0ab4:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 90c0ab8:	e0fffb17 	ldw	r3,-20(fp)
 90c0abc:	e0bffc17 	ldw	r2,-16(fp)
 90c0ac0:	18800426 	beq	r3,r2,90c0ad4 <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 90c0ac4:	01001904 	movi	r4,100
 90c0ac8:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 90c0acc:	e13ffb17 	ldw	r4,-20(fp)
 90c0ad0:	90aa0000 	call	90aa000 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 90c0ad4:	e0bffd17 	ldw	r2,-12(fp)
 90c0ad8:	1004c03a 	cmpne	r2,r2,zero
 90c0adc:	103fcc1e 	bne	r2,zero,90c0a10 <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 90c0ae0:	01002204 	movi	r4,136
 90c0ae4:	90bf5240 	call	90bf524 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 90c0ae8:	e13ffe17 	ldw	r4,-8(fp)
 90c0aec:	90aa0000 	call	90aa000 <npfree>

   return IPREASM_OK;
 90c0af0:	e03fff15 	stw	zero,-4(fp)
 90c0af4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0af8:	e037883a 	mov	sp,fp
 90c0afc:	dfc00117 	ldw	ra,4(sp)
 90c0b00:	df000017 	ldw	fp,0(sp)
 90c0b04:	dec00204 	addi	sp,sp,8
 90c0b08:	f800283a 	ret

090c0b0c <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 90c0b0c:	defffa04 	addi	sp,sp,-24
 90c0b10:	dfc00515 	stw	ra,20(sp)
 90c0b14:	df000415 	stw	fp,16(sp)
 90c0b18:	df000404 	addi	fp,sp,16
 90c0b1c:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 90c0b20:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 90c0b24:	00800044 	movi	r2,1
 90c0b28:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90c0b2c:	e13ffe17 	ldw	r4,-8(fp)
 90c0b30:	90c04680 	call	90c0468 <ip_reasm_find_ire>
 90c0b34:	10803fcc 	andi	r2,r2,255
 90c0b38:	10800060 	cmpeqi	r2,r2,1
 90c0b3c:	10000a1e 	bne	r2,zero,90c0b68 <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 90c0b40:	008243b4 	movhi	r2,2318
 90c0b44:	10b67804 	addi	r2,r2,-9760
 90c0b48:	10800017 	ldw	r2,0(r2)
 90c0b4c:	10c00044 	addi	r3,r2,1
 90c0b50:	008243b4 	movhi	r2,2318
 90c0b54:	10b67804 	addi	r2,r2,-9760
 90c0b58:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 90c0b5c:	00bffd84 	movi	r2,-10
 90c0b60:	e0bfff15 	stw	r2,-4(fp)
 90c0b64:	00003506 	br	90c0c3c <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 90c0b68:	e0bffe17 	ldw	r2,-8(fp)
 90c0b6c:	10800604 	addi	r2,r2,24
 90c0b70:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 90c0b74:	00001c06 	br	90c0be8 <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0b78:	e03ffc8d 	sth	zero,-14(fp)
 90c0b7c:	00001406 	br	90c0bd0 <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 90c0b80:	e0bffc8b 	ldhu	r2,-14(fp)
 90c0b84:	e0fffd17 	ldw	r3,-12(fp)
 90c0b88:	1085883a 	add	r2,r2,r2
 90c0b8c:	1085883a 	add	r2,r2,r2
 90c0b90:	10c5883a 	add	r2,r2,r3
 90c0b94:	10800104 	addi	r2,r2,4
 90c0b98:	10800017 	ldw	r2,0(r2)
 90c0b9c:	1004c03a 	cmpne	r2,r2,zero
 90c0ba0:	1000031e 	bne	r2,zero,90c0bb0 <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 90c0ba4:	00800044 	movi	r2,1
 90c0ba8:	e0bffc45 	stb	r2,-15(fp)
 90c0bac:	00000506 	br	90c0bc4 <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 90c0bb0:	e0bffc43 	ldbu	r2,-15(fp)
 90c0bb4:	1005003a 	cmpeq	r2,r2,zero
 90c0bb8:	1000021e 	bne	r2,zero,90c0bc4 <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 90c0bbc:	e03ffc05 	stb	zero,-16(fp)
               break;
 90c0bc0:	00000606 	br	90c0bdc <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0bc4:	e0bffc8b 	ldhu	r2,-14(fp)
 90c0bc8:	10800044 	addi	r2,r2,1
 90c0bcc:	e0bffc8d 	sth	r2,-14(fp)
 90c0bd0:	e0bffc8b 	ldhu	r2,-14(fp)
 90c0bd4:	10800430 	cmpltui	r2,r2,16
 90c0bd8:	103fe91e 	bne	r2,zero,90c0b80 <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 90c0bdc:	e0bffd17 	ldw	r2,-12(fp)
 90c0be0:	10800017 	ldw	r2,0(r2)
 90c0be4:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 90c0be8:	e0bffd17 	ldw	r2,-12(fp)
 90c0bec:	1004c03a 	cmpne	r2,r2,zero
 90c0bf0:	103fe11e 	bne	r2,zero,90c0b78 <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 90c0bf4:	e0bffc03 	ldbu	r2,-16(fp)
 90c0bf8:	1005003a 	cmpeq	r2,r2,zero
 90c0bfc:	1000071e 	bne	r2,zero,90c0c1c <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 90c0c00:	e0bffe17 	ldw	r2,-8(fp)
 90c0c04:	10802103 	ldbu	r2,132(r2)
 90c0c08:	10800054 	ori	r2,r2,1
 90c0c0c:	1007883a 	mov	r3,r2
 90c0c10:	e0bffe17 	ldw	r2,-8(fp)
 90c0c14:	10c02105 	stb	r3,132(r2)
 90c0c18:	00000706 	br	90c0c38 <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 90c0c1c:	e0bffe17 	ldw	r2,-8(fp)
 90c0c20:	10c02103 	ldbu	r3,132(r2)
 90c0c24:	00bfff84 	movi	r2,-2
 90c0c28:	1884703a 	and	r2,r3,r2
 90c0c2c:	1007883a 	mov	r3,r2
 90c0c30:	e0bffe17 	ldw	r2,-8(fp)
 90c0c34:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 90c0c38:	e03fff15 	stw	zero,-4(fp)
 90c0c3c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0c40:	e037883a 	mov	sp,fp
 90c0c44:	dfc00117 	ldw	ra,4(sp)
 90c0c48:	df000017 	ldw	fp,0(sp)
 90c0c4c:	dec00204 	addi	sp,sp,8
 90c0c50:	f800283a 	ret

090c0c54 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 90c0c54:	deffec04 	addi	sp,sp,-80
 90c0c58:	dfc01315 	stw	ra,76(sp)
 90c0c5c:	df001215 	stw	fp,72(sp)
 90c0c60:	dc001115 	stw	r16,68(sp)
 90c0c64:	df001104 	addi	fp,sp,68
 90c0c68:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 90c0c6c:	00824374 	movhi	r2,2317
 90c0c70:	108c4204 	addi	r2,r2,12552
 90c0c74:	10800017 	ldw	r2,0(r2)
 90c0c78:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 90c0c7c:	00802204 	movi	r2,136
 90c0c80:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 90c0c84:	00801904 	movi	r2,100
 90c0c88:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 90c0c8c:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 90c0c90:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 90c0c94:	e13fff17 	ldw	r4,-4(fp)
 90c0c98:	01424374 	movhi	r5,2317
 90c0c9c:	2940bd04 	addi	r5,r5,756
 90c0ca0:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 90c0ca4:	d420c717 	ldw	r16,-31972(gp)
 90c0ca8:	e13ffe17 	ldw	r4,-8(fp)
 90c0cac:	908c0380 	call	908c038 <__floatunsidf>
 90c0cb0:	100b883a 	mov	r5,r2
 90c0cb4:	180d883a 	mov	r6,r3
 90c0cb8:	2809883a 	mov	r4,r5
 90c0cbc:	300b883a 	mov	r5,r6
 90c0cc0:	000d883a 	mov	r6,zero
 90c0cc4:	01d01674 	movhi	r7,16473
 90c0cc8:	908b9680 	call	908b968 <__divdf3>
 90c0ccc:	1009883a 	mov	r4,r2
 90c0cd0:	180b883a 	mov	r5,r3
 90c0cd4:	2005883a 	mov	r2,r4
 90c0cd8:	2807883a 	mov	r3,r5
 90c0cdc:	e13ffd8b 	ldhu	r4,-10(fp)
 90c0ce0:	e17ffd0b 	ldhu	r5,-12(fp)
 90c0ce4:	d8800015 	stw	r2,0(sp)
 90c0ce8:	d8c00115 	stw	r3,4(sp)
 90c0cec:	d9000215 	stw	r4,8(sp)
 90c0cf0:	d9400315 	stw	r5,12(sp)
 90c0cf4:	e13fff17 	ldw	r4,-4(fp)
 90c0cf8:	01424374 	movhi	r5,2317
 90c0cfc:	2940c404 	addi	r5,r5,784
 90c0d00:	800d883a 	mov	r6,r16
 90c0d04:	e1fffe17 	ldw	r7,-8(fp)
 90c0d08:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 90c0d0c:	008243b4 	movhi	r2,2318
 90c0d10:	10b67804 	addi	r2,r2,-9760
 90c0d14:	11800117 	ldw	r6,4(r2)
 90c0d18:	008243b4 	movhi	r2,2318
 90c0d1c:	10b67804 	addi	r2,r2,-9760
 90c0d20:	11c00017 	ldw	r7,0(r2)
 90c0d24:	008243b4 	movhi	r2,2318
 90c0d28:	10b67804 	addi	r2,r2,-9760
 90c0d2c:	11000217 	ldw	r4,8(r2)
 90c0d30:	008243b4 	movhi	r2,2318
 90c0d34:	10b67804 	addi	r2,r2,-9760
 90c0d38:	11400317 	ldw	r5,12(r2)
 90c0d3c:	008243b4 	movhi	r2,2318
 90c0d40:	10b67804 	addi	r2,r2,-9760
 90c0d44:	10c00417 	ldw	r3,16(r2)
 90c0d48:	008243b4 	movhi	r2,2318
 90c0d4c:	10b67804 	addi	r2,r2,-9760
 90c0d50:	10800517 	ldw	r2,20(r2)
 90c0d54:	d9000015 	stw	r4,0(sp)
 90c0d58:	d9400115 	stw	r5,4(sp)
 90c0d5c:	d8c00215 	stw	r3,8(sp)
 90c0d60:	d8800315 	stw	r2,12(sp)
 90c0d64:	e13fff17 	ldw	r4,-4(fp)
 90c0d68:	01424374 	movhi	r5,2317
 90c0d6c:	2940d404 	addi	r5,r5,848
 90c0d70:	90a45b40 	call	90a45b4 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 90c0d74:	d1a0c817 	ldw	r6,-31968(gp)
 90c0d78:	e13fff17 	ldw	r4,-4(fp)
 90c0d7c:	01424374 	movhi	r5,2317
 90c0d80:	2940e904 	addi	r5,r5,932
 90c0d84:	90a45b40 	call	90a45b4 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c0d88:	d0a0c817 	ldw	r2,-31968(gp)
 90c0d8c:	e0bffc15 	stw	r2,-16(fp)
 90c0d90:	00008106 	br	90c0f98 <ipr_stats+0x344>
      {
      ++count;
 90c0d94:	e0bffb0b 	ldhu	r2,-20(fp)
 90c0d98:	10800044 	addi	r2,r2,1
 90c0d9c:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 90c0da0:	e0bffc17 	ldw	r2,-16(fp)
 90c0da4:	10800604 	addi	r2,r2,24
 90c0da8:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 90c0dac:	00001f06 	br	90c0e2c <ipr_stats+0x1d8>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0db0:	e03ff90d 	sth	zero,-28(fp)
 90c0db4:	00001706 	br	90c0e14 <ipr_stats+0x1c0>
            {
            if (rfqp->bufp [i] != 0)
 90c0db8:	e0bff90b 	ldhu	r2,-28(fp)
 90c0dbc:	e0fffa17 	ldw	r3,-24(fp)
 90c0dc0:	1085883a 	add	r2,r2,r2
 90c0dc4:	1085883a 	add	r2,r2,r2
 90c0dc8:	10c5883a 	add	r2,r2,r3
 90c0dcc:	10800104 	addi	r2,r2,4
 90c0dd0:	10800017 	ldw	r2,0(r2)
 90c0dd4:	1005003a 	cmpeq	r2,r2,zero
 90c0dd8:	1000041e 	bne	r2,zero,90c0dec <ipr_stats+0x198>
               {
               ++frag_count;            
 90c0ddc:	e0bff98b 	ldhu	r2,-26(fp)
 90c0de0:	10800044 	addi	r2,r2,1
 90c0de4:	e0bff98d 	sth	r2,-26(fp)
 90c0de8:	00000706 	br	90c0e08 <ipr_stats+0x1b4>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 90c0dec:	e0bffc17 	ldw	r2,-16(fp)
 90c0df0:	10802103 	ldbu	r2,132(r2)
 90c0df4:	10803fcc 	andi	r2,r2,255
 90c0df8:	1080004c 	andi	r2,r2,1
 90c0dfc:	10803fcc 	andi	r2,r2,255
 90c0e00:	1004c03a 	cmpne	r2,r2,zero
 90c0e04:	1000061e 	bne	r2,zero,90c0e20 <ipr_stats+0x1cc>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0e08:	e0bff90b 	ldhu	r2,-28(fp)
 90c0e0c:	10800044 	addi	r2,r2,1
 90c0e10:	e0bff90d 	sth	r2,-28(fp)
 90c0e14:	e0bff90b 	ldhu	r2,-28(fp)
 90c0e18:	10800430 	cmpltui	r2,r2,16
 90c0e1c:	103fe61e 	bne	r2,zero,90c0db8 <ipr_stats+0x164>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 90c0e20:	e0bffa17 	ldw	r2,-24(fp)
 90c0e24:	10800017 	ldw	r2,0(r2)
 90c0e28:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 90c0e2c:	e0bffa17 	ldw	r2,-24(fp)
 90c0e30:	1004c03a 	cmpne	r2,r2,zero
 90c0e34:	103fde1e 	bne	r2,zero,90c0db0 <ipr_stats+0x15c>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 90c0e38:	e1fff98b 	ldhu	r7,-26(fp)
 90c0e3c:	e0bffc17 	ldw	r2,-16(fp)
 90c0e40:	10800117 	ldw	r2,4(r2)
 90c0e44:	1004d63a 	srli	r2,r2,24
 90c0e48:	10c03fcc 	andi	r3,r2,255
 90c0e4c:	e0bffc17 	ldw	r2,-16(fp)
 90c0e50:	10800117 	ldw	r2,4(r2)
 90c0e54:	1004d23a 	srli	r2,r2,8
 90c0e58:	10bfc00c 	andi	r2,r2,65280
 90c0e5c:	1886b03a 	or	r3,r3,r2
 90c0e60:	e0bffc17 	ldw	r2,-16(fp)
 90c0e64:	10800117 	ldw	r2,4(r2)
 90c0e68:	10bfc00c 	andi	r2,r2,65280
 90c0e6c:	1004923a 	slli	r2,r2,8
 90c0e70:	1886b03a 	or	r3,r3,r2
 90c0e74:	e0bffc17 	ldw	r2,-16(fp)
 90c0e78:	10800117 	ldw	r2,4(r2)
 90c0e7c:	10803fcc 	andi	r2,r2,255
 90c0e80:	1004963a 	slli	r2,r2,24
 90c0e84:	1888b03a 	or	r4,r3,r2
 90c0e88:	e0bffc17 	ldw	r2,-16(fp)
 90c0e8c:	10800217 	ldw	r2,8(r2)
 90c0e90:	1004d63a 	srli	r2,r2,24
 90c0e94:	10c03fcc 	andi	r3,r2,255
 90c0e98:	e0bffc17 	ldw	r2,-16(fp)
 90c0e9c:	10800217 	ldw	r2,8(r2)
 90c0ea0:	1004d23a 	srli	r2,r2,8
 90c0ea4:	10bfc00c 	andi	r2,r2,65280
 90c0ea8:	1886b03a 	or	r3,r3,r2
 90c0eac:	e0bffc17 	ldw	r2,-16(fp)
 90c0eb0:	10800217 	ldw	r2,8(r2)
 90c0eb4:	10bfc00c 	andi	r2,r2,65280
 90c0eb8:	1004923a 	slli	r2,r2,8
 90c0ebc:	1886b03a 	or	r3,r3,r2
 90c0ec0:	e0bffc17 	ldw	r2,-16(fp)
 90c0ec4:	10800217 	ldw	r2,8(r2)
 90c0ec8:	10803fcc 	andi	r2,r2,255
 90c0ecc:	1004963a 	slli	r2,r2,24
 90c0ed0:	188ab03a 	or	r5,r3,r2
 90c0ed4:	e0bffc17 	ldw	r2,-16(fp)
 90c0ed8:	10800383 	ldbu	r2,14(r2)
 90c0edc:	11803fcc 	andi	r6,r2,255
 90c0ee0:	e0bffc17 	ldw	r2,-16(fp)
 90c0ee4:	1080030b 	ldhu	r2,12(r2)
 90c0ee8:	10bfffcc 	andi	r2,r2,65535
 90c0eec:	1004d23a 	srli	r2,r2,8
 90c0ef0:	10bfffcc 	andi	r2,r2,65535
 90c0ef4:	10c03fcc 	andi	r3,r2,255
 90c0ef8:	e0bffc17 	ldw	r2,-16(fp)
 90c0efc:	1080030b 	ldhu	r2,12(r2)
 90c0f00:	10bfffcc 	andi	r2,r2,65535
 90c0f04:	1004923a 	slli	r2,r2,8
 90c0f08:	10bfc00c 	andi	r2,r2,65280
 90c0f0c:	1886b03a 	or	r3,r3,r2
 90c0f10:	e0bffc17 	ldw	r2,-16(fp)
 90c0f14:	1080040b 	ldhu	r2,16(r2)
 90c0f18:	123fffcc 	andi	r8,r2,65535
 90c0f1c:	e0bffc17 	ldw	r2,-16(fp)
 90c0f20:	1080048b 	ldhu	r2,18(r2)
 90c0f24:	127fffcc 	andi	r9,r2,65535
 90c0f28:	e0bffc17 	ldw	r2,-16(fp)
 90c0f2c:	12800517 	ldw	r10,20(r2)
 90c0f30:	e0bffc17 	ldw	r2,-16(fp)
 90c0f34:	12c01f17 	ldw	r11,124(r2)
 90c0f38:	e0bffc17 	ldw	r2,-16(fp)
 90c0f3c:	13002017 	ldw	r12,128(r2)
 90c0f40:	e0bffc17 	ldw	r2,-16(fp)
 90c0f44:	10802103 	ldbu	r2,132(r2)
 90c0f48:	10803fcc 	andi	r2,r2,255
 90c0f4c:	1080004c 	andi	r2,r2,1
 90c0f50:	d9000015 	stw	r4,0(sp)
 90c0f54:	d9400115 	stw	r5,4(sp)
 90c0f58:	d9800215 	stw	r6,8(sp)
 90c0f5c:	d8c00315 	stw	r3,12(sp)
 90c0f60:	da000415 	stw	r8,16(sp)
 90c0f64:	da400515 	stw	r9,20(sp)
 90c0f68:	da800615 	stw	r10,24(sp)
 90c0f6c:	dac00715 	stw	r11,28(sp)
 90c0f70:	db000815 	stw	r12,32(sp)
 90c0f74:	d8800915 	stw	r2,36(sp)
 90c0f78:	e13fff17 	ldw	r4,-4(fp)
 90c0f7c:	01424374 	movhi	r5,2317
 90c0f80:	2940ef04 	addi	r5,r5,956
 90c0f84:	e1bffc17 	ldw	r6,-16(fp)
 90c0f88:	90a45b40 	call	90a45b4 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c0f8c:	e0bffc17 	ldw	r2,-16(fp)
 90c0f90:	10800017 	ldw	r2,0(r2)
 90c0f94:	e0bffc15 	stw	r2,-16(fp)
 90c0f98:	e0bffc17 	ldw	r2,-16(fp)
 90c0f9c:	1004c03a 	cmpne	r2,r2,zero
 90c0fa0:	103f7c1e 	bne	r2,zero,90c0d94 <ipr_stats+0x140>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 90c0fa4:	e1bffb0b 	ldhu	r6,-20(fp)
 90c0fa8:	e13fff17 	ldw	r4,-4(fp)
 90c0fac:	01424374 	movhi	r5,2317
 90c0fb0:	29410a04 	addi	r5,r5,1064
 90c0fb4:	90a45b40 	call	90a45b4 <ns_printf>

   return IPREASM_OK;
 90c0fb8:	0005883a 	mov	r2,zero
}
 90c0fbc:	e037883a 	mov	sp,fp
 90c0fc0:	dfc00217 	ldw	ra,8(sp)
 90c0fc4:	df000117 	ldw	fp,4(sp)
 90c0fc8:	dc000017 	ldw	r16,0(sp)
 90c0fcc:	dec00304 	addi	sp,sp,12
 90c0fd0:	f800283a 	ret

090c0fd4 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 90c0fd4:	defffc04 	addi	sp,sp,-16
 90c0fd8:	dfc00315 	stw	ra,12(sp)
 90c0fdc:	df000215 	stw	fp,8(sp)
 90c0fe0:	df000204 	addi	fp,sp,8
 90c0fe4:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 90c0fe8:	e0bfff17 	ldw	r2,-4(fp)
 90c0fec:	10801f17 	ldw	r2,124(r2)
 90c0ff0:	1005003a 	cmpeq	r2,r2,zero
 90c0ff4:	1000061e 	bne	r2,zero,90c1010 <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 90c0ff8:	e0bfff17 	ldw	r2,-4(fp)
 90c0ffc:	10802017 	ldw	r2,128(r2)
 90c1000:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 90c1004:	e13ffe17 	ldw	r4,-8(fp)
 90c1008:	01400044 	movi	r5,1
 90c100c:	90ca1100 	call	90ca110 <icmp_timex>
      }

   return IPREASM_OK;
 90c1010:	0005883a 	mov	r2,zero
}
 90c1014:	e037883a 	mov	sp,fp
 90c1018:	dfc00117 	ldw	ra,4(sp)
 90c101c:	df000017 	ldw	fp,0(sp)
 90c1020:	dec00204 	addi	sp,sp,8
 90c1024:	f800283a 	ret

090c1028 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 90c1028:	defff204 	addi	sp,sp,-56
 90c102c:	dfc00d15 	stw	ra,52(sp)
 90c1030:	df000c15 	stw	fp,48(sp)
 90c1034:	dc000b15 	stw	r16,44(sp)
 90c1038:	df000b04 	addi	fp,sp,44
 90c103c:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 90c1040:	00bfffc4 	movi	r2,-1
 90c1044:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1048:	00824374 	movhi	r2,2317
 90c104c:	108c1d04 	addi	r2,r2,12404
 90c1050:	10800017 	ldw	r2,0(r2)
 90c1054:	1081000c 	andi	r2,r2,1024
 90c1058:	1005003a 	cmpeq	r2,r2,zero
 90c105c:	1000101e 	bne	r2,zero,90c10a0 <ip_rcv+0x78>
 90c1060:	00824374 	movhi	r2,2317
 90c1064:	108c1d04 	addi	r2,r2,12404
 90c1068:	10800017 	ldw	r2,0(r2)
 90c106c:	1080800c 	andi	r2,r2,512
 90c1070:	1005003a 	cmpeq	r2,r2,zero
 90c1074:	10000a1e 	bne	r2,zero,90c10a0 <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 90c1078:	e0bffe17 	ldw	r2,-8(fp)
 90c107c:	14000417 	ldw	r16,16(r2)
 90c1080:	e0bffe17 	ldw	r2,-8(fp)
 90c1084:	11000617 	ldw	r4,24(r2)
 90c1088:	90a21180 	call	90a2118 <if_netnumber>
 90c108c:	100d883a 	mov	r6,r2
 90c1090:	01024374 	movhi	r4,2317
 90c1094:	21011304 	addi	r4,r4,1100
 90c1098:	800b883a 	mov	r5,r16
 90c109c:	90825100 	call	9082510 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 90c10a0:	e0bffe17 	ldw	r2,-8(fp)
 90c10a4:	10800617 	ldw	r2,24(r2)
 90c10a8:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 90c10ac:	008243b4 	movhi	r2,2318
 90c10b0:	10b66404 	addi	r2,r2,-9840
 90c10b4:	10800217 	ldw	r2,8(r2)
 90c10b8:	10c00044 	addi	r3,r2,1
 90c10bc:	008243b4 	movhi	r2,2318
 90c10c0:	10b66404 	addi	r2,r2,-9840
 90c10c4:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 90c10c8:	e0bffe17 	ldw	r2,-8(fp)
 90c10cc:	10800317 	ldw	r2,12(r2)
 90c10d0:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 90c10d4:	e0bffe17 	ldw	r2,-8(fp)
 90c10d8:	11000417 	ldw	r4,16(r2)
 90c10dc:	e0bffd17 	ldw	r2,-12(fp)
 90c10e0:	1080008b 	ldhu	r2,2(r2)
 90c10e4:	10bfffcc 	andi	r2,r2,65535
 90c10e8:	1004d23a 	srli	r2,r2,8
 90c10ec:	10bfffcc 	andi	r2,r2,65535
 90c10f0:	10c03fcc 	andi	r3,r2,255
 90c10f4:	e0bffd17 	ldw	r2,-12(fp)
 90c10f8:	1080008b 	ldhu	r2,2(r2)
 90c10fc:	10bfffcc 	andi	r2,r2,65535
 90c1100:	1004923a 	slli	r2,r2,8
 90c1104:	10bfc00c 	andi	r2,r2,65280
 90c1108:	1884b03a 	or	r2,r3,r2
 90c110c:	2080272e 	bgeu	r4,r2,90c11ac <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1110:	00824374 	movhi	r2,2317
 90c1114:	108c1d04 	addi	r2,r2,12404
 90c1118:	10800017 	ldw	r2,0(r2)
 90c111c:	1081000c 	andi	r2,r2,1024
 90c1120:	1005003a 	cmpeq	r2,r2,zero
 90c1124:	1000111e 	bne	r2,zero,90c116c <ip_rcv+0x144>
 90c1128:	00824374 	movhi	r2,2317
 90c112c:	108c1d04 	addi	r2,r2,12404
 90c1130:	10800017 	ldw	r2,0(r2)
 90c1134:	1080800c 	andi	r2,r2,512
 90c1138:	1005003a 	cmpeq	r2,r2,zero
 90c113c:	10000b1e 	bne	r2,zero,90c116c <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 90c1140:	01024374 	movhi	r4,2317
 90c1144:	21011c04 	addi	r4,r4,1136
 90c1148:	90828380 	call	9082838 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c114c:	00824374 	movhi	r2,2317
 90c1150:	108c1d04 	addi	r2,r2,12404
 90c1154:	10800017 	ldw	r2,0(r2)
 90c1158:	1080008c 	andi	r2,r2,2
 90c115c:	1005003a 	cmpeq	r2,r2,zero
 90c1160:	1000021e 	bne	r2,zero,90c116c <ip_rcv+0x144>
 90c1164:	e13ffe17 	ldw	r4,-8(fp)
 90c1168:	90bebcc0 	call	90bebcc <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c116c:	008243b4 	movhi	r2,2318
 90c1170:	10b66404 	addi	r2,r2,-9840
 90c1174:	10800317 	ldw	r2,12(r2)
 90c1178:	10c00044 	addi	r3,r2,1
 90c117c:	008243b4 	movhi	r2,2318
 90c1180:	10b66404 	addi	r2,r2,-9840
 90c1184:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1188:	01000084 	movi	r4,2
 90c118c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c1190:	e13ffe17 	ldw	r4,-8(fp)
 90c1194:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1198:	01000084 	movi	r4,2
 90c119c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c11a0:	00bff804 	movi	r2,-32
 90c11a4:	e0bfff15 	stw	r2,-4(fp)
 90c11a8:	00009806 	br	90c140c <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 90c11ac:	e0bffd17 	ldw	r2,-12(fp)
 90c11b0:	1080008b 	ldhu	r2,2(r2)
 90c11b4:	10bfffcc 	andi	r2,r2,65535
 90c11b8:	1004d23a 	srli	r2,r2,8
 90c11bc:	10bfffcc 	andi	r2,r2,65535
 90c11c0:	10c03fcc 	andi	r3,r2,255
 90c11c4:	e0bffd17 	ldw	r2,-12(fp)
 90c11c8:	1080008b 	ldhu	r2,2(r2)
 90c11cc:	10bfffcc 	andi	r2,r2,65535
 90c11d0:	1004923a 	slli	r2,r2,8
 90c11d4:	10bfc00c 	andi	r2,r2,65280
 90c11d8:	1884b03a 	or	r2,r3,r2
 90c11dc:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 90c11e0:	e0fffe17 	ldw	r3,-8(fp)
 90c11e4:	e0bff917 	ldw	r2,-28(fp)
 90c11e8:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 90c11ec:	e0bffd17 	ldw	r2,-12(fp)
 90c11f0:	10800003 	ldbu	r2,0(r2)
 90c11f4:	10803fcc 	andi	r2,r2,255
 90c11f8:	10803c0c 	andi	r2,r2,240
 90c11fc:	1005d13a 	srai	r2,r2,4
 90c1200:	10800120 	cmpeqi	r2,r2,4
 90c1204:	1000271e 	bne	r2,zero,90c12a4 <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1208:	00824374 	movhi	r2,2317
 90c120c:	108c1d04 	addi	r2,r2,12404
 90c1210:	10800017 	ldw	r2,0(r2)
 90c1214:	1081000c 	andi	r2,r2,1024
 90c1218:	1005003a 	cmpeq	r2,r2,zero
 90c121c:	1000111e 	bne	r2,zero,90c1264 <ip_rcv+0x23c>
 90c1220:	00824374 	movhi	r2,2317
 90c1224:	108c1d04 	addi	r2,r2,12404
 90c1228:	10800017 	ldw	r2,0(r2)
 90c122c:	1080800c 	andi	r2,r2,512
 90c1230:	1005003a 	cmpeq	r2,r2,zero
 90c1234:	10000b1e 	bne	r2,zero,90c1264 <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 90c1238:	01024374 	movhi	r4,2317
 90c123c:	21012104 	addi	r4,r4,1156
 90c1240:	90828380 	call	9082838 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c1244:	00824374 	movhi	r2,2317
 90c1248:	108c1d04 	addi	r2,r2,12404
 90c124c:	10800017 	ldw	r2,0(r2)
 90c1250:	1080008c 	andi	r2,r2,2
 90c1254:	1005003a 	cmpeq	r2,r2,zero
 90c1258:	1000021e 	bne	r2,zero,90c1264 <ip_rcv+0x23c>
 90c125c:	e13ffe17 	ldw	r4,-8(fp)
 90c1260:	90bebcc0 	call	90bebcc <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c1264:	008243b4 	movhi	r2,2318
 90c1268:	10b66404 	addi	r2,r2,-9840
 90c126c:	10800317 	ldw	r2,12(r2)
 90c1270:	10c00044 	addi	r3,r2,1
 90c1274:	008243b4 	movhi	r2,2318
 90c1278:	10b66404 	addi	r2,r2,-9840
 90c127c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1280:	01000084 	movi	r4,2
 90c1284:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c1288:	e13ffe17 	ldw	r4,-8(fp)
 90c128c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1290:	01000084 	movi	r4,2
 90c1294:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c1298:	00bff804 	movi	r2,-32
 90c129c:	e0bfff15 	stw	r2,-4(fp)
 90c12a0:	00005a06 	br	90c140c <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 90c12a4:	e0bffd17 	ldw	r2,-12(fp)
 90c12a8:	1080028b 	ldhu	r2,10(r2)
 90c12ac:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 90c12b0:	e0bffd17 	ldw	r2,-12(fp)
 90c12b4:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 90c12b8:	e0bffd17 	ldw	r2,-12(fp)
 90c12bc:	10800003 	ldbu	r2,0(r2)
 90c12c0:	10803fcc 	andi	r2,r2,255
 90c12c4:	108003cc 	andi	r2,r2,15
 90c12c8:	1085883a 	add	r2,r2,r2
 90c12cc:	1085883a 	add	r2,r2,r2
 90c12d0:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 90c12d4:	e0bffa17 	ldw	r2,-24(fp)
 90c12d8:	100ad07a 	srli	r5,r2,1
 90c12dc:	e13ffd17 	ldw	r4,-12(fp)
 90c12e0:	90a3f040 	call	90a3f04 <cksum>
 90c12e4:	0084303a 	nor	r2,zero,r2
 90c12e8:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 90c12ec:	e0fffc8b 	ldhu	r3,-14(fp)
 90c12f0:	e0bffc0b 	ldhu	r2,-16(fp)
 90c12f4:	18802a26 	beq	r3,r2,90c13a0 <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 90c12f8:	e0fffd17 	ldw	r3,-12(fp)
 90c12fc:	e0bffc8b 	ldhu	r2,-14(fp)
 90c1300:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1304:	00824374 	movhi	r2,2317
 90c1308:	108c1d04 	addi	r2,r2,12404
 90c130c:	10800017 	ldw	r2,0(r2)
 90c1310:	1081000c 	andi	r2,r2,1024
 90c1314:	1005003a 	cmpeq	r2,r2,zero
 90c1318:	1000111e 	bne	r2,zero,90c1360 <ip_rcv+0x338>
 90c131c:	00824374 	movhi	r2,2317
 90c1320:	108c1d04 	addi	r2,r2,12404
 90c1324:	10800017 	ldw	r2,0(r2)
 90c1328:	1080800c 	andi	r2,r2,512
 90c132c:	1005003a 	cmpeq	r2,r2,zero
 90c1330:	10000b1e 	bne	r2,zero,90c1360 <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 90c1334:	01024374 	movhi	r4,2317
 90c1338:	21012804 	addi	r4,r4,1184
 90c133c:	90828380 	call	9082838 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c1340:	00824374 	movhi	r2,2317
 90c1344:	108c1d04 	addi	r2,r2,12404
 90c1348:	10800017 	ldw	r2,0(r2)
 90c134c:	1080008c 	andi	r2,r2,2
 90c1350:	1005003a 	cmpeq	r2,r2,zero
 90c1354:	1000021e 	bne	r2,zero,90c1360 <ip_rcv+0x338>
 90c1358:	e13ffe17 	ldw	r4,-8(fp)
 90c135c:	90bebcc0 	call	90bebcc <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c1360:	008243b4 	movhi	r2,2318
 90c1364:	10b66404 	addi	r2,r2,-9840
 90c1368:	10800317 	ldw	r2,12(r2)
 90c136c:	10c00044 	addi	r3,r2,1
 90c1370:	008243b4 	movhi	r2,2318
 90c1374:	10b66404 	addi	r2,r2,-9840
 90c1378:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c137c:	01000084 	movi	r4,2
 90c1380:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c1384:	e13ffe17 	ldw	r4,-8(fp)
 90c1388:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c138c:	01000084 	movi	r4,2
 90c1390:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c1394:	00bff804 	movi	r2,-32
 90c1398:	e0bfff15 	stw	r2,-4(fp)
 90c139c:	00001b06 	br	90c140c <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 90c13a0:	e0fffd17 	ldw	r3,-12(fp)
 90c13a4:	e0bffc8b 	ldhu	r2,-14(fp)
 90c13a8:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 90c13ac:	00800044 	movi	r2,1
 90c13b0:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 90c13b4:	e0bffe04 	addi	r2,fp,-8
 90c13b8:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 90c13bc:	e03ff605 	stb	zero,-40(fp)
 90c13c0:	00000c06 	br	90c13f4 <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 90c13c4:	e0bff603 	ldbu	r2,-40(fp)
 90c13c8:	1085883a 	add	r2,r2,r2
 90c13cc:	1085883a 	add	r2,r2,r2
 90c13d0:	1007883a 	mov	r3,r2
 90c13d4:	e0bff717 	ldw	r2,-36(fp)
 90c13d8:	1885883a 	add	r2,r3,r2
 90c13dc:	11000017 	ldw	r4,0(r2)
 90c13e0:	90c14280 	call	90c1428 <ip_rcv_phase2>
 90c13e4:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 90c13e8:	e0bff603 	ldbu	r2,-40(fp)
 90c13ec:	10800044 	addi	r2,r2,1
 90c13f0:	e0bff605 	stb	r2,-40(fp)
 90c13f4:	e0bff603 	ldbu	r2,-40(fp)
 90c13f8:	10ffffcc 	andi	r3,r2,65535
 90c13fc:	e0bff80b 	ldhu	r2,-32(fp)
 90c1400:	18bff036 	bltu	r3,r2,90c13c4 <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 90c1404:	e0bff517 	ldw	r2,-44(fp)
 90c1408:	e0bfff15 	stw	r2,-4(fp)
 90c140c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1410:	e037883a 	mov	sp,fp
 90c1414:	dfc00217 	ldw	ra,8(sp)
 90c1418:	df000117 	ldw	fp,4(sp)
 90c141c:	dc000017 	ldw	r16,0(sp)
 90c1420:	dec00304 	addi	sp,sp,12
 90c1424:	f800283a 	ret

090c1428 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 90c1428:	defff404 	addi	sp,sp,-48
 90c142c:	dfc00b15 	stw	ra,44(sp)
 90c1430:	df000a15 	stw	fp,40(sp)
 90c1434:	df000a04 	addi	fp,sp,40
 90c1438:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 90c143c:	e0bffe17 	ldw	r2,-8(fp)
 90c1440:	10800317 	ldw	r2,12(r2)
 90c1444:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 90c1448:	e0bffe17 	ldw	r2,-8(fp)
 90c144c:	10800617 	ldw	r2,24(r2)
 90c1450:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 90c1454:	e0bffc17 	ldw	r2,-16(fp)
 90c1458:	10800417 	ldw	r2,16(r2)
 90c145c:	1004d63a 	srli	r2,r2,24
 90c1460:	10c03fcc 	andi	r3,r2,255
 90c1464:	e0bffc17 	ldw	r2,-16(fp)
 90c1468:	10800417 	ldw	r2,16(r2)
 90c146c:	1004d23a 	srli	r2,r2,8
 90c1470:	10bfc00c 	andi	r2,r2,65280
 90c1474:	1886b03a 	or	r3,r3,r2
 90c1478:	e0bffc17 	ldw	r2,-16(fp)
 90c147c:	10800417 	ldw	r2,16(r2)
 90c1480:	10bfc00c 	andi	r2,r2,65280
 90c1484:	1004923a 	slli	r2,r2,8
 90c1488:	1886b03a 	or	r3,r3,r2
 90c148c:	e0bffc17 	ldw	r2,-16(fp)
 90c1490:	10800417 	ldw	r2,16(r2)
 90c1494:	10803fcc 	andi	r2,r2,255
 90c1498:	1004963a 	slli	r2,r2,24
 90c149c:	1884b03a 	or	r2,r3,r2
 90c14a0:	10fc002c 	andhi	r3,r2,61440
 90c14a4:	00b80034 	movhi	r2,57344
 90c14a8:	1880181e 	bne	r3,r2,90c150c <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 90c14ac:	e0bffc17 	ldw	r2,-16(fp)
 90c14b0:	11000417 	ldw	r4,16(r2)
 90c14b4:	e17ffb17 	ldw	r5,-20(fp)
 90c14b8:	90c20e40 	call	90c20e4 <lookup_mcast>
 90c14bc:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 90c14c0:	e0bff917 	ldw	r2,-28(fp)
 90c14c4:	1004c03a 	cmpne	r2,r2,zero
 90c14c8:	10010d1e 	bne	r2,zero,90c1900 <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 90c14cc:	008243b4 	movhi	r2,2318
 90c14d0:	10b66404 	addi	r2,r2,-9840
 90c14d4:	10800b17 	ldw	r2,44(r2)
 90c14d8:	10c00044 	addi	r3,r2,1
 90c14dc:	008243b4 	movhi	r2,2318
 90c14e0:	10b66404 	addi	r2,r2,-9840
 90c14e4:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90c14e8:	01000084 	movi	r4,2
 90c14ec:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90c14f0:	e13ffe17 	ldw	r4,-8(fp)
 90c14f4:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c14f8:	01000084 	movi	r4,2
 90c14fc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 90c1500:	00800084 	movi	r2,2
 90c1504:	e0bfff15 	stw	r2,-4(fp)
 90c1508:	00014406 	br	90c1a1c <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 90c150c:	e0bffc17 	ldw	r2,-16(fp)
 90c1510:	10c00417 	ldw	r3,16(r2)
 90c1514:	e0bffb17 	ldw	r2,-20(fp)
 90c1518:	10800a17 	ldw	r2,40(r2)
 90c151c:	1880f826 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
 90c1520:	e0bffc17 	ldw	r2,-16(fp)
 90c1524:	10800417 	ldw	r2,16(r2)
 90c1528:	10bfffe0 	cmpeqi	r2,r2,-1
 90c152c:	1000f41e 	bne	r2,zero,90c1900 <ip_rcv_phase2+0x4d8>
 90c1530:	e0bffc17 	ldw	r2,-16(fp)
 90c1534:	10c00417 	ldw	r3,16(r2)
 90c1538:	e0bffb17 	ldw	r2,-20(fp)
 90c153c:	10800e17 	ldw	r2,56(r2)
 90c1540:	1880ef26 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
 90c1544:	e0bffc17 	ldw	r2,-16(fp)
 90c1548:	10c00417 	ldw	r3,16(r2)
 90c154c:	e0bffb17 	ldw	r2,-20(fp)
 90c1550:	10800f17 	ldw	r2,60(r2)
 90c1554:	1880ea26 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
 90c1558:	e0bffc17 	ldw	r2,-16(fp)
 90c155c:	10c00417 	ldw	r3,16(r2)
 90c1560:	e0bffb17 	ldw	r2,-20(fp)
 90c1564:	10801017 	ldw	r2,64(r2)
 90c1568:	1880e526 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
 90c156c:	e0bffb17 	ldw	r2,-20(fp)
 90c1570:	10c00a17 	ldw	r3,40(r2)
 90c1574:	e0bffb17 	ldw	r2,-20(fp)
 90c1578:	10800c17 	ldw	r2,48(r2)
 90c157c:	0084303a 	nor	r2,zero,r2
 90c1580:	1884703a 	and	r2,r3,r2
 90c1584:	1005003a 	cmpeq	r2,r2,zero
 90c1588:	1000dd1e 	bne	r2,zero,90c1900 <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c158c:	00824374 	movhi	r2,2317
 90c1590:	108c1d04 	addi	r2,r2,12404
 90c1594:	10800017 	ldw	r2,0(r2)
 90c1598:	1081000c 	andi	r2,r2,1024
 90c159c:	1005003a 	cmpeq	r2,r2,zero
 90c15a0:	1000181e 	bne	r2,zero,90c1604 <ip_rcv_phase2+0x1dc>
 90c15a4:	00824374 	movhi	r2,2317
 90c15a8:	108c1d04 	addi	r2,r2,12404
 90c15ac:	10800017 	ldw	r2,0(r2)
 90c15b0:	1080800c 	andi	r2,r2,512
 90c15b4:	1005003a 	cmpeq	r2,r2,zero
 90c15b8:	1000121e 	bne	r2,zero,90c1604 <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 90c15bc:	e0bffc17 	ldw	r2,-16(fp)
 90c15c0:	10800417 	ldw	r2,16(r2)
 90c15c4:	11403fcc 	andi	r5,r2,255
 90c15c8:	e0bffc17 	ldw	r2,-16(fp)
 90c15cc:	10800417 	ldw	r2,16(r2)
 90c15d0:	1004d23a 	srli	r2,r2,8
 90c15d4:	11803fcc 	andi	r6,r2,255
 90c15d8:	e0bffc17 	ldw	r2,-16(fp)
 90c15dc:	10800417 	ldw	r2,16(r2)
 90c15e0:	1004d43a 	srli	r2,r2,16
 90c15e4:	11c03fcc 	andi	r7,r2,255
 90c15e8:	e0bffc17 	ldw	r2,-16(fp)
 90c15ec:	10800417 	ldw	r2,16(r2)
 90c15f0:	1004d63a 	srli	r2,r2,24
 90c15f4:	d8800015 	stw	r2,0(sp)
 90c15f8:	01024374 	movhi	r4,2317
 90c15fc:	21012d04 	addi	r4,r4,1204
 90c1600:	90825100 	call	9082510 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 90c1604:	008243b4 	movhi	r2,2318
 90c1608:	10b66404 	addi	r2,r2,-9840
 90c160c:	10800017 	ldw	r2,0(r2)
 90c1610:	10800098 	cmpnei	r2,r2,2
 90c1614:	1000101e 	bne	r2,zero,90c1658 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 90c1618:	008243b4 	movhi	r2,2318
 90c161c:	10b66404 	addi	r2,r2,-9840
 90c1620:	10800a17 	ldw	r2,40(r2)
 90c1624:	10c00044 	addi	r3,r2,1
 90c1628:	008243b4 	movhi	r2,2318
 90c162c:	10b66404 	addi	r2,r2,-9840
 90c1630:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1634:	01000084 	movi	r4,2
 90c1638:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
         pk_free(p);
 90c163c:	e13ffe17 	ldw	r4,-8(fp)
 90c1640:	90a8bd80 	call	90a8bd8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1644:	01000084 	movi	r4,2
 90c1648:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 90c164c:	00bff7c4 	movi	r2,-33
 90c1650:	e0bfff15 	stw	r2,-4(fp)
 90c1654:	0000f106 	br	90c1a1c <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 90c1658:	008243b4 	movhi	r2,2318
 90c165c:	10b66404 	addi	r2,r2,-9840
 90c1660:	10800517 	ldw	r2,20(r2)
 90c1664:	10c00044 	addi	r3,r2,1
 90c1668:	008243b4 	movhi	r2,2318
 90c166c:	10b66404 	addi	r2,r2,-9840
 90c1670:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 90c1674:	e0bffc17 	ldw	r2,-16(fp)
 90c1678:	10800203 	ldbu	r2,8(r2)
 90c167c:	10803fcc 	andi	r2,r2,255
 90c1680:	108000a8 	cmpgeui	r2,r2,2
 90c1684:	10001b1e 	bne	r2,zero,90c16f4 <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 90c1688:	008243b4 	movhi	r2,2318
 90c168c:	10b66404 	addi	r2,r2,-9840
 90c1690:	10800a17 	ldw	r2,40(r2)
 90c1694:	10c00044 	addi	r3,r2,1
 90c1698:	008243b4 	movhi	r2,2318
 90c169c:	10b66404 	addi	r2,r2,-9840
 90c16a0:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 90c16a4:	e0bffc17 	ldw	r2,-16(fp)
 90c16a8:	11000317 	ldw	r4,12(r2)
 90c16ac:	e0bffe17 	ldw	r2,-8(fp)
 90c16b0:	10800617 	ldw	r2,24(r2)
 90c16b4:	11400a17 	ldw	r5,40(r2)
 90c16b8:	e0bffe17 	ldw	r2,-8(fp)
 90c16bc:	10800617 	ldw	r2,24(r2)
 90c16c0:	d8800015 	stw	r2,0(sp)
 90c16c4:	e1bffc17 	ldw	r6,-16(fp)
 90c16c8:	01c2c004 	movi	r7,2816
 90c16cc:	90c9dc00 	call	90c9dc0 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90c16d0:	01000084 	movi	r4,2
 90c16d4:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90c16d8:	e13ffe17 	ldw	r4,-8(fp)
 90c16dc:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c16e0:	01000084 	movi	r4,2
 90c16e4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 90c16e8:	00bff7c4 	movi	r2,-33
 90c16ec:	e0bfff15 	stw	r2,-4(fp)
 90c16f0:	0000ca06 	br	90c1a1c <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 90c16f4:	e0bffc17 	ldw	r2,-16(fp)
 90c16f8:	10c00417 	ldw	r3,16(r2)
 90c16fc:	e0bffe17 	ldw	r2,-8(fp)
 90c1700:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 90c1704:	e0bffe17 	ldw	r2,-8(fp)
 90c1708:	11000717 	ldw	r4,28(r2)
 90c170c:	e17ffd04 	addi	r5,fp,-12
 90c1710:	90bee840 	call	90bee84 <iproute>
 90c1714:	e0bff815 	stw	r2,-32(fp)
 90c1718:	e0bff817 	ldw	r2,-32(fp)
 90c171c:	1004c03a 	cmpne	r2,r2,zero
 90c1720:	1000101e 	bne	r2,zero,90c1764 <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 90c1724:	008243b4 	movhi	r2,2318
 90c1728:	10b66404 	addi	r2,r2,-9840
 90c172c:	10800b17 	ldw	r2,44(r2)
 90c1730:	10c00044 	addi	r3,r2,1
 90c1734:	008243b4 	movhi	r2,2318
 90c1738:	10b66404 	addi	r2,r2,-9840
 90c173c:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1740:	01000084 	movi	r4,2
 90c1744:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
            pk_free(p);
 90c1748:	e13ffe17 	ldw	r4,-8(fp)
 90c174c:	90a8bd80 	call	90a8bd8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1750:	01000084 	movi	r4,2
 90c1754:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 90c1758:	00bff7c4 	movi	r2,-33
 90c175c:	e0bfff15 	stw	r2,-4(fp)
 90c1760:	0000ae06 	br	90c1a1c <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 90c1764:	e0bffc17 	ldw	r2,-16(fp)
 90c1768:	10c00417 	ldw	r3,16(r2)
 90c176c:	e0bff817 	ldw	r2,-32(fp)
 90c1770:	10800a17 	ldw	r2,40(r2)
 90c1774:	18806226 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 90c1778:	e0bffc17 	ldw	r2,-16(fp)
 90c177c:	10c00417 	ldw	r3,16(r2)
 90c1780:	e0bff817 	ldw	r2,-32(fp)
 90c1784:	10800e17 	ldw	r2,56(r2)
 90c1788:	18805d26 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
 90c178c:	e0bffc17 	ldw	r2,-16(fp)
 90c1790:	10c00417 	ldw	r3,16(r2)
 90c1794:	e0bffe17 	ldw	r2,-8(fp)
 90c1798:	10800617 	ldw	r2,24(r2)
 90c179c:	10800e17 	ldw	r2,56(r2)
 90c17a0:	18805726 	beq	r3,r2,90c1900 <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 90c17a4:	e0fffe17 	ldw	r3,-8(fp)
 90c17a8:	e0bff817 	ldw	r2,-32(fp)
 90c17ac:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 90c17b0:	e0bffe17 	ldw	r2,-8(fp)
 90c17b4:	10c00417 	ldw	r3,16(r2)
 90c17b8:	e0bffe17 	ldw	r2,-8(fp)
 90c17bc:	10800617 	ldw	r2,24(r2)
 90c17c0:	10800817 	ldw	r2,32(r2)
 90c17c4:	1887883a 	add	r3,r3,r2
 90c17c8:	e0bff817 	ldw	r2,-32(fp)
 90c17cc:	10800917 	ldw	r2,36(r2)
 90c17d0:	10c0372e 	bgeu	r2,r3,90c18b0 <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 90c17d4:	e0bffc17 	ldw	r2,-16(fp)
 90c17d8:	1080018b 	ldhu	r2,6(r2)
 90c17dc:	10bfffcc 	andi	r2,r2,65535
 90c17e0:	1004d23a 	srli	r2,r2,8
 90c17e4:	10bfffcc 	andi	r2,r2,65535
 90c17e8:	10c03fcc 	andi	r3,r2,255
 90c17ec:	e0bffc17 	ldw	r2,-16(fp)
 90c17f0:	1080018b 	ldhu	r2,6(r2)
 90c17f4:	10bfffcc 	andi	r2,r2,65535
 90c17f8:	1004923a 	slli	r2,r2,8
 90c17fc:	10bfc00c 	andi	r2,r2,65280
 90c1800:	1884b03a 	or	r2,r3,r2
 90c1804:	1090000c 	andi	r2,r2,16384
 90c1808:	1005003a 	cmpeq	r2,r2,zero
 90c180c:	10001b1e 	bne	r2,zero,90c187c <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 90c1810:	e0bffc17 	ldw	r2,-16(fp)
 90c1814:	11000317 	ldw	r4,12(r2)
 90c1818:	e0bffe17 	ldw	r2,-8(fp)
 90c181c:	10800617 	ldw	r2,24(r2)
 90c1820:	11400a17 	ldw	r5,40(r2)
 90c1824:	e0bffe17 	ldw	r2,-8(fp)
 90c1828:	10800617 	ldw	r2,24(r2)
 90c182c:	d8800015 	stw	r2,0(sp)
 90c1830:	e1bffc17 	ldw	r6,-16(fp)
 90c1834:	01c00104 	movi	r7,4
 90c1838:	90c9dc00 	call	90c9dc0 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 90c183c:	008243b4 	movhi	r2,2318
 90c1840:	10b66404 	addi	r2,r2,-9840
 90c1844:	10801117 	ldw	r2,68(r2)
 90c1848:	10c00044 	addi	r3,r2,1
 90c184c:	008243b4 	movhi	r2,2318
 90c1850:	10b66404 	addi	r2,r2,-9840
 90c1854:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1858:	01000084 	movi	r4,2
 90c185c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
               pk_free(p);
 90c1860:	e13ffe17 	ldw	r4,-8(fp)
 90c1864:	90a8bd80 	call	90a8bd8 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1868:	01000084 	movi	r4,2
 90c186c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 90c1870:	00bffd44 	movi	r2,-11
 90c1874:	e0bfff15 	stw	r2,-4(fp)
 90c1878:	00006806 	br	90c1a1c <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 90c187c:	e0bffc17 	ldw	r2,-16(fp)
 90c1880:	10800203 	ldbu	r2,8(r2)
 90c1884:	10bfffc4 	addi	r2,r2,-1
 90c1888:	1007883a 	mov	r3,r2
 90c188c:	e0bffc17 	ldw	r2,-16(fp)
 90c1890:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 90c1894:	e17ffd17 	ldw	r5,-12(fp)
 90c1898:	e13ffe17 	ldw	r4,-8(fp)
 90c189c:	90be4f40 	call	90be4f4 <ip_fragment>
 90c18a0:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 90c18a4:	e0bff717 	ldw	r2,-36(fp)
 90c18a8:	e0bfff15 	stw	r2,-4(fp)
 90c18ac:	00005b06 	br	90c1a1c <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 90c18b0:	e0bffc17 	ldw	r2,-16(fp)
 90c18b4:	10800203 	ldbu	r2,8(r2)
 90c18b8:	10bfffc4 	addi	r2,r2,-1
 90c18bc:	1007883a 	mov	r3,r2
 90c18c0:	e0bffc17 	ldw	r2,-16(fp)
 90c18c4:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 90c18c8:	e0bffc17 	ldw	r2,-16(fp)
 90c18cc:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 90c18d0:	e13ffc17 	ldw	r4,-16(fp)
 90c18d4:	01400284 	movi	r5,10
 90c18d8:	90a3f040 	call	90a3f04 <cksum>
 90c18dc:	0084303a 	nor	r2,zero,r2
 90c18e0:	1007883a 	mov	r3,r2
 90c18e4:	e0bffc17 	ldw	r2,-16(fp)
 90c18e8:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 90c18ec:	e17ffd17 	ldw	r5,-12(fp)
 90c18f0:	e13ffe17 	ldw	r4,-8(fp)
 90c18f4:	90a1b540 	call	90a1b54 <ip2mac>
 90c18f8:	e0bfff15 	stw	r2,-4(fp)
 90c18fc:	00004706 	br	90c1a1c <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 90c1900:	e0bffc17 	ldw	r2,-16(fp)
 90c1904:	1080018b 	ldhu	r2,6(r2)
 90c1908:	10bfffcc 	andi	r2,r2,65535
 90c190c:	1004d23a 	srli	r2,r2,8
 90c1910:	10803fcc 	andi	r2,r2,255
 90c1914:	1009883a 	mov	r4,r2
 90c1918:	e0bffc17 	ldw	r2,-16(fp)
 90c191c:	1080018b 	ldhu	r2,6(r2)
 90c1920:	10bfffcc 	andi	r2,r2,65535
 90c1924:	1004923a 	slli	r2,r2,8
 90c1928:	1007883a 	mov	r3,r2
 90c192c:	00bfc004 	movi	r2,-256
 90c1930:	1884703a 	and	r2,r3,r2
 90c1934:	2084b03a 	or	r2,r4,r2
 90c1938:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 90c193c:	e0bffa0b 	ldhu	r2,-24(fp)
 90c1940:	1088000c 	andi	r2,r2,8192
 90c1944:	1004c03a 	cmpne	r2,r2,zero
 90c1948:	1000061e 	bne	r2,zero,90c1964 <ip_rcv_phase2+0x53c>
 90c194c:	e0fffa0b 	ldhu	r3,-24(fp)
 90c1950:	00bffff4 	movhi	r2,65535
 90c1954:	1087ffc4 	addi	r2,r2,8191
 90c1958:	1884703a 	and	r2,r3,r2
 90c195c:	1005003a 	cmpeq	r2,r2,zero
 90c1960:	10002b1e 	bne	r2,zero,90c1a10 <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1964:	00824374 	movhi	r2,2317
 90c1968:	108c1d04 	addi	r2,r2,12404
 90c196c:	10800017 	ldw	r2,0(r2)
 90c1970:	1081000c 	andi	r2,r2,1024
 90c1974:	1005003a 	cmpeq	r2,r2,zero
 90c1978:	10001a1e 	bne	r2,zero,90c19e4 <ip_rcv_phase2+0x5bc>
 90c197c:	00824374 	movhi	r2,2317
 90c1980:	108c1d04 	addi	r2,r2,12404
 90c1984:	10800017 	ldw	r2,0(r2)
 90c1988:	1080800c 	andi	r2,r2,512
 90c198c:	1005003a 	cmpeq	r2,r2,zero
 90c1990:	1000141e 	bne	r2,zero,90c19e4 <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 90c1994:	e0bffc17 	ldw	r2,-16(fp)
 90c1998:	10800317 	ldw	r2,12(r2)
 90c199c:	11403fcc 	andi	r5,r2,255
 90c19a0:	e0bffc17 	ldw	r2,-16(fp)
 90c19a4:	10800317 	ldw	r2,12(r2)
 90c19a8:	1004d23a 	srli	r2,r2,8
 90c19ac:	11803fcc 	andi	r6,r2,255
 90c19b0:	e0bffc17 	ldw	r2,-16(fp)
 90c19b4:	10800317 	ldw	r2,12(r2)
 90c19b8:	1004d43a 	srli	r2,r2,16
 90c19bc:	11c03fcc 	andi	r7,r2,255
 90c19c0:	e0bffc17 	ldw	r2,-16(fp)
 90c19c4:	10800317 	ldw	r2,12(r2)
 90c19c8:	1004d63a 	srli	r2,r2,24
 90c19cc:	d8800015 	stw	r2,0(sp)
 90c19d0:	01024374 	movhi	r4,2317
 90c19d4:	21013904 	addi	r4,r4,1252
 90c19d8:	90825100 	call	9082510 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 90c19dc:	e13ffe17 	ldw	r4,-8(fp)
 90c19e0:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 90c19e4:	008243b4 	movhi	r2,2318
 90c19e8:	10b66404 	addi	r2,r2,-9840
 90c19ec:	10800d17 	ldw	r2,52(r2)
 90c19f0:	10c00044 	addi	r3,r2,1
 90c19f4:	008243b4 	movhi	r2,2318
 90c19f8:	10b66404 	addi	r2,r2,-9840
 90c19fc:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 90c1a00:	e13ffe17 	ldw	r4,-8(fp)
 90c1a04:	90bf8a40 	call	90bf8a4 <ip_reassm>
 90c1a08:	e0bfff15 	stw	r2,-4(fp)
 90c1a0c:	00000306 	br	90c1a1c <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 90c1a10:	e13ffe17 	ldw	r4,-8(fp)
 90c1a14:	90c1a340 	call	90c1a34 <ip_demux>
 90c1a18:	e0bfff15 	stw	r2,-4(fp)
 90c1a1c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1a20:	e037883a 	mov	sp,fp
 90c1a24:	dfc00117 	ldw	ra,4(sp)
 90c1a28:	df000017 	ldw	fp,0(sp)
 90c1a2c:	dec00204 	addi	sp,sp,8
 90c1a30:	f800283a 	ret

090c1a34 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 90c1a34:	defff704 	addi	sp,sp,-36
 90c1a38:	dfc00815 	stw	ra,32(sp)
 90c1a3c:	df000715 	stw	fp,28(sp)
 90c1a40:	df000704 	addi	fp,sp,28
 90c1a44:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 90c1a48:	e0bffd17 	ldw	r2,-12(fp)
 90c1a4c:	10800317 	ldw	r2,12(r2)
 90c1a50:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 90c1a54:	e0bffc17 	ldw	r2,-16(fp)
 90c1a58:	10800003 	ldbu	r2,0(r2)
 90c1a5c:	10803fcc 	andi	r2,r2,255
 90c1a60:	10801160 	cmpeqi	r2,r2,69
 90c1a64:	1000131e 	bne	r2,zero,90c1ab4 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 90c1a68:	e0bffc17 	ldw	r2,-16(fp)
 90c1a6c:	10800003 	ldbu	r2,0(r2)
 90c1a70:	10803fcc 	andi	r2,r2,255
 90c1a74:	10801170 	cmpltui	r2,r2,69
 90c1a78:	1000051e 	bne	r2,zero,90c1a90 <ip_demux+0x5c>
 90c1a7c:	e0bffc17 	ldw	r2,-16(fp)
 90c1a80:	10800003 	ldbu	r2,0(r2)
 90c1a84:	10803fcc 	andi	r2,r2,255
 90c1a88:	10801230 	cmpltui	r2,r2,72
 90c1a8c:	1000091e 	bne	r2,zero,90c1ab4 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 90c1a90:	e0bffc17 	ldw	r2,-16(fp)
 90c1a94:	10800003 	ldbu	r2,0(r2)
 90c1a98:	11403fcc 	andi	r5,r2,255
 90c1a9c:	01024374 	movhi	r4,2317
 90c1aa0:	21014204 	addi	r4,r4,1288
 90c1aa4:	90825100 	call	9082510 <printf>
         return ENP_LOGIC;
 90c1aa8:	00bffd44 	movi	r2,-11
 90c1aac:	e0bfff15 	stw	r2,-4(fp)
 90c1ab0:	0000e606 	br	90c1e4c <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 90c1ab4:	e0bffc17 	ldw	r2,-16(fp)
 90c1ab8:	10c00317 	ldw	r3,12(r2)
 90c1abc:	e0bffd17 	ldw	r2,-12(fp)
 90c1ac0:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1ac4:	00824374 	movhi	r2,2317
 90c1ac8:	108c1d04 	addi	r2,r2,12404
 90c1acc:	10800017 	ldw	r2,0(r2)
 90c1ad0:	1081000c 	andi	r2,r2,1024
 90c1ad4:	1005003a 	cmpeq	r2,r2,zero
 90c1ad8:	1000241e 	bne	r2,zero,90c1b6c <ip_demux+0x138>
 90c1adc:	00824374 	movhi	r2,2317
 90c1ae0:	108c1d04 	addi	r2,r2,12404
 90c1ae4:	10800017 	ldw	r2,0(r2)
 90c1ae8:	1080800c 	andi	r2,r2,512
 90c1aec:	1005003a 	cmpeq	r2,r2,zero
 90c1af0:	10001e1e 	bne	r2,zero,90c1b6c <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 90c1af4:	e0bffc17 	ldw	r2,-16(fp)
 90c1af8:	10800243 	ldbu	r2,9(r2)
 90c1afc:	11403fcc 	andi	r5,r2,255
 90c1b00:	e0bffc17 	ldw	r2,-16(fp)
 90c1b04:	10800317 	ldw	r2,12(r2)
 90c1b08:	11803fcc 	andi	r6,r2,255
 90c1b0c:	e0bffc17 	ldw	r2,-16(fp)
 90c1b10:	10800317 	ldw	r2,12(r2)
 90c1b14:	1004d23a 	srli	r2,r2,8
 90c1b18:	11c03fcc 	andi	r7,r2,255
 90c1b1c:	e0bffc17 	ldw	r2,-16(fp)
 90c1b20:	10800317 	ldw	r2,12(r2)
 90c1b24:	1004d43a 	srli	r2,r2,16
 90c1b28:	10c03fcc 	andi	r3,r2,255
 90c1b2c:	e0bffc17 	ldw	r2,-16(fp)
 90c1b30:	10800317 	ldw	r2,12(r2)
 90c1b34:	1004d63a 	srli	r2,r2,24
 90c1b38:	d8c00015 	stw	r3,0(sp)
 90c1b3c:	d8800115 	stw	r2,4(sp)
 90c1b40:	01024374 	movhi	r4,2317
 90c1b44:	21014904 	addi	r4,r4,1316
 90c1b48:	90825100 	call	9082510 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 90c1b4c:	00824374 	movhi	r2,2317
 90c1b50:	108c1d04 	addi	r2,r2,12404
 90c1b54:	10800017 	ldw	r2,0(r2)
 90c1b58:	1080008c 	andi	r2,r2,2
 90c1b5c:	1005003a 	cmpeq	r2,r2,zero
 90c1b60:	1000021e 	bne	r2,zero,90c1b6c <ip_demux+0x138>
 90c1b64:	e13ffd17 	ldw	r4,-12(fp)
 90c1b68:	90bebcc0 	call	90bebcc <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 90c1b6c:	e0bffc17 	ldw	r2,-16(fp)
 90c1b70:	10800243 	ldbu	r2,9(r2)
 90c1b74:	10803fcc 	andi	r2,r2,255
 90c1b78:	e0bffe15 	stw	r2,-8(fp)
 90c1b7c:	e0fffe17 	ldw	r3,-8(fp)
 90c1b80:	188000a0 	cmpeqi	r2,r3,2
 90c1b84:	1000241e 	bne	r2,zero,90c1c18 <ip_demux+0x1e4>
 90c1b88:	e0fffe17 	ldw	r3,-8(fp)
 90c1b8c:	188000c8 	cmpgei	r2,r3,3
 90c1b90:	1000041e 	bne	r2,zero,90c1ba4 <ip_demux+0x170>
 90c1b94:	e0fffe17 	ldw	r3,-8(fp)
 90c1b98:	18800060 	cmpeqi	r2,r3,1
 90c1b9c:	1000131e 	bne	r2,zero,90c1bec <ip_demux+0x1b8>
 90c1ba0:	00003306 	br	90c1c70 <ip_demux+0x23c>
 90c1ba4:	e0fffe17 	ldw	r3,-8(fp)
 90c1ba8:	188001a0 	cmpeqi	r2,r3,6
 90c1bac:	1000251e 	bne	r2,zero,90c1c44 <ip_demux+0x210>
 90c1bb0:	e0fffe17 	ldw	r3,-8(fp)
 90c1bb4:	18800460 	cmpeqi	r2,r3,17
 90c1bb8:	1000011e 	bne	r2,zero,90c1bc0 <ip_demux+0x18c>
 90c1bbc:	00002c06 	br	90c1c70 <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 90c1bc0:	008243b4 	movhi	r2,2318
 90c1bc4:	10b66404 	addi	r2,r2,-9840
 90c1bc8:	10800817 	ldw	r2,32(r2)
 90c1bcc:	10c00044 	addi	r3,r2,1
 90c1bd0:	008243b4 	movhi	r2,2318
 90c1bd4:	10b66404 	addi	r2,r2,-9840
 90c1bd8:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 90c1bdc:	e13ffd17 	ldw	r4,-12(fp)
 90c1be0:	90c2e780 	call	90c2e78 <udpdemux>
 90c1be4:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c1be8:	00002b06 	br	90c1c98 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 90c1bec:	008243b4 	movhi	r2,2318
 90c1bf0:	10b66404 	addi	r2,r2,-9840
 90c1bf4:	10800817 	ldw	r2,32(r2)
 90c1bf8:	10c00044 	addi	r3,r2,1
 90c1bfc:	008243b4 	movhi	r2,2318
 90c1c00:	10b66404 	addi	r2,r2,-9840
 90c1c04:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 90c1c08:	e13ffd17 	ldw	r4,-12(fp)
 90c1c0c:	90c918c0 	call	90c918c <icmprcv>
 90c1c10:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c1c14:	00002006 	br	90c1c98 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 90c1c18:	008243b4 	movhi	r2,2318
 90c1c1c:	10b66404 	addi	r2,r2,-9840
 90c1c20:	10800817 	ldw	r2,32(r2)
 90c1c24:	10c00044 	addi	r3,r2,1
 90c1c28:	008243b4 	movhi	r2,2318
 90c1c2c:	10b66404 	addi	r2,r2,-9840
 90c1c30:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 90c1c34:	e13ffd17 	ldw	r4,-12(fp)
 90c1c38:	90a22980 	call	90a2298 <igmp_input>
 90c1c3c:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c1c40:	00001506 	br	90c1c98 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 90c1c44:	008243b4 	movhi	r2,2318
 90c1c48:	10b66404 	addi	r2,r2,-9840
 90c1c4c:	10800817 	ldw	r2,32(r2)
 90c1c50:	10c00044 	addi	r3,r2,1
 90c1c54:	008243b4 	movhi	r2,2318
 90c1c58:	10b66404 	addi	r2,r2,-9840
 90c1c5c:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 90c1c60:	e13ffd17 	ldw	r4,-12(fp)
 90c1c64:	90aadec0 	call	90aadec <tcp_rcv>
 90c1c68:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c1c6c:	00000a06 	br	90c1c98 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 90c1c70:	008243b4 	movhi	r2,2318
 90c1c74:	10b66404 	addi	r2,r2,-9840
 90c1c78:	10800817 	ldw	r2,32(r2)
 90c1c7c:	10c00044 	addi	r3,r2,1
 90c1c80:	008243b4 	movhi	r2,2318
 90c1c84:	10b66404 	addi	r2,r2,-9840
 90c1c88:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 90c1c8c:	e13ffd17 	ldw	r4,-12(fp)
 90c1c90:	90c23e80 	call	90c23e8 <ip_raw_input>
 90c1c94:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 90c1c98:	e0bffb17 	ldw	r2,-20(fp)
 90c1c9c:	10bffda0 	cmpeqi	r2,r2,-10
 90c1ca0:	1000031e 	bne	r2,zero,90c1cb0 <ip_demux+0x27c>
   {
      return err;
 90c1ca4:	e0bffb17 	ldw	r2,-20(fp)
 90c1ca8:	e0bfff15 	stw	r2,-4(fp)
 90c1cac:	00006706 	br	90c1e4c <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 90c1cb0:	e0bffc17 	ldw	r2,-16(fp)
 90c1cb4:	10800417 	ldw	r2,16(r2)
 90c1cb8:	10bfffe0 	cmpeqi	r2,r2,-1
 90c1cbc:	1000541e 	bne	r2,zero,90c1e10 <ip_demux+0x3dc>
 90c1cc0:	e0bffc17 	ldw	r2,-16(fp)
 90c1cc4:	10800417 	ldw	r2,16(r2)
 90c1cc8:	1004d63a 	srli	r2,r2,24
 90c1ccc:	10c03fcc 	andi	r3,r2,255
 90c1cd0:	e0bffc17 	ldw	r2,-16(fp)
 90c1cd4:	10800417 	ldw	r2,16(r2)
 90c1cd8:	1004d23a 	srli	r2,r2,8
 90c1cdc:	10bfc00c 	andi	r2,r2,65280
 90c1ce0:	1886b03a 	or	r3,r3,r2
 90c1ce4:	e0bffc17 	ldw	r2,-16(fp)
 90c1ce8:	10800417 	ldw	r2,16(r2)
 90c1cec:	10bfc00c 	andi	r2,r2,65280
 90c1cf0:	1004923a 	slli	r2,r2,8
 90c1cf4:	1886b03a 	or	r3,r3,r2
 90c1cf8:	e0bffc17 	ldw	r2,-16(fp)
 90c1cfc:	10800417 	ldw	r2,16(r2)
 90c1d00:	10803fcc 	andi	r2,r2,255
 90c1d04:	1004963a 	slli	r2,r2,24
 90c1d08:	1884b03a 	or	r2,r3,r2
 90c1d0c:	10fc002c 	andhi	r3,r2,61440
 90c1d10:	00b80034 	movhi	r2,57344
 90c1d14:	18803e26 	beq	r3,r2,90c1e10 <ip_demux+0x3dc>
 90c1d18:	e0bffc17 	ldw	r2,-16(fp)
 90c1d1c:	10c00417 	ldw	r3,16(r2)
 90c1d20:	e0bffd17 	ldw	r2,-12(fp)
 90c1d24:	10800617 	ldw	r2,24(r2)
 90c1d28:	10800e17 	ldw	r2,56(r2)
 90c1d2c:	18803826 	beq	r3,r2,90c1e10 <ip_demux+0x3dc>
 90c1d30:	e0bffc17 	ldw	r2,-16(fp)
 90c1d34:	10c00417 	ldw	r3,16(r2)
 90c1d38:	e0bffd17 	ldw	r2,-12(fp)
 90c1d3c:	10800617 	ldw	r2,24(r2)
 90c1d40:	10800f17 	ldw	r2,60(r2)
 90c1d44:	18803226 	beq	r3,r2,90c1e10 <ip_demux+0x3dc>
 90c1d48:	e0bffc17 	ldw	r2,-16(fp)
 90c1d4c:	10c00417 	ldw	r3,16(r2)
 90c1d50:	e0bffd17 	ldw	r2,-12(fp)
 90c1d54:	10800617 	ldw	r2,24(r2)
 90c1d58:	10801017 	ldw	r2,64(r2)
 90c1d5c:	18802c26 	beq	r3,r2,90c1e10 <ip_demux+0x3dc>
 90c1d60:	e0bffd17 	ldw	r2,-12(fp)
 90c1d64:	10800617 	ldw	r2,24(r2)
 90c1d68:	10c00a17 	ldw	r3,40(r2)
 90c1d6c:	e0bffd17 	ldw	r2,-12(fp)
 90c1d70:	10800617 	ldw	r2,24(r2)
 90c1d74:	10801017 	ldw	r2,64(r2)
 90c1d78:	18802526 	beq	r3,r2,90c1e10 <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1d7c:	00824374 	movhi	r2,2317
 90c1d80:	108c1d04 	addi	r2,r2,12404
 90c1d84:	10800017 	ldw	r2,0(r2)
 90c1d88:	1081000c 	andi	r2,r2,1024
 90c1d8c:	1005003a 	cmpeq	r2,r2,zero
 90c1d90:	1000141e 	bne	r2,zero,90c1de4 <ip_demux+0x3b0>
 90c1d94:	00824374 	movhi	r2,2317
 90c1d98:	108c1d04 	addi	r2,r2,12404
 90c1d9c:	10800017 	ldw	r2,0(r2)
 90c1da0:	1080800c 	andi	r2,r2,512
 90c1da4:	1005003a 	cmpeq	r2,r2,zero
 90c1da8:	10000e1e 	bne	r2,zero,90c1de4 <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 90c1dac:	e0bffc17 	ldw	r2,-16(fp)
 90c1db0:	10800243 	ldbu	r2,9(r2)
 90c1db4:	11403fcc 	andi	r5,r2,255
 90c1db8:	01024374 	movhi	r4,2317
 90c1dbc:	21015304 	addi	r4,r4,1356
 90c1dc0:	90825100 	call	9082510 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90c1dc4:	00824374 	movhi	r2,2317
 90c1dc8:	108c1d04 	addi	r2,r2,12404
 90c1dcc:	10800017 	ldw	r2,0(r2)
 90c1dd0:	1080008c 	andi	r2,r2,2
 90c1dd4:	1005003a 	cmpeq	r2,r2,zero
 90c1dd8:	1000021e 	bne	r2,zero,90c1de4 <ip_demux+0x3b0>
 90c1ddc:	e13ffd17 	ldw	r4,-12(fp)
 90c1de0:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 90c1de4:	e0bffc17 	ldw	r2,-16(fp)
 90c1de8:	11000317 	ldw	r4,12(r2)
 90c1dec:	e0bffd17 	ldw	r2,-12(fp)
 90c1df0:	10800617 	ldw	r2,24(r2)
 90c1df4:	11400a17 	ldw	r5,40(r2)
 90c1df8:	e0bffd17 	ldw	r2,-12(fp)
 90c1dfc:	10800617 	ldw	r2,24(r2)
 90c1e00:	d8800015 	stw	r2,0(sp)
 90c1e04:	e1bffc17 	ldw	r6,-16(fp)
 90c1e08:	01c00084 	movi	r7,2
 90c1e0c:	90c9dc00 	call	90c9dc0 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 90c1e10:	008243b4 	movhi	r2,2318
 90c1e14:	10b66404 	addi	r2,r2,-9840
 90c1e18:	10800617 	ldw	r2,24(r2)
 90c1e1c:	10c00044 	addi	r3,r2,1
 90c1e20:	008243b4 	movhi	r2,2318
 90c1e24:	10b66404 	addi	r2,r2,-9840
 90c1e28:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c1e2c:	01000084 	movi	r4,2
 90c1e30:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c1e34:	e13ffd17 	ldw	r4,-12(fp)
 90c1e38:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c1e3c:	01000084 	movi	r4,2
 90c1e40:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 90c1e44:	00c00084 	movi	r3,2
 90c1e48:	e0ffff15 	stw	r3,-4(fp)
 90c1e4c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1e50:	e037883a 	mov	sp,fp
 90c1e54:	dfc00117 	ldw	ra,4(sp)
 90c1e58:	df000017 	ldw	fp,0(sp)
 90c1e5c:	dec00204 	addi	sp,sp,8
 90c1e60:	f800283a 	ret

090c1e64 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 90c1e64:	defff804 	addi	sp,sp,-32
 90c1e68:	dfc00715 	stw	ra,28(sp)
 90c1e6c:	df000615 	stw	fp,24(sp)
 90c1e70:	df000604 	addi	fp,sp,24
 90c1e74:	e13ffc15 	stw	r4,-16(fp)
 90c1e78:	e17ffd15 	stw	r5,-12(fp)
 90c1e7c:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 90c1e80:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 90c1e84:	e0bffc17 	ldw	r2,-16(fp)
 90c1e88:	1005003a 	cmpeq	r2,r2,zero
 90c1e8c:	1000041e 	bne	r2,zero,90c1ea0 <in_addmulti+0x3c>
 90c1e90:	e0bffc17 	ldw	r2,-16(fp)
 90c1e94:	10800017 	ldw	r2,0(r2)
 90c1e98:	1004c03a 	cmpne	r2,r2,zero
 90c1e9c:	1000021e 	bne	r2,zero,90c1ea8 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 90c1ea0:	e03fff15 	stw	zero,-4(fp)
 90c1ea4:	00004306 	br	90c1fb4 <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 90c1ea8:	90a96c80 	call	90a96c8 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 90c1eac:	e0bffe17 	ldw	r2,-8(fp)
 90c1eb0:	108001a0 	cmpeqi	r2,r2,6
 90c1eb4:	1000051e 	bne	r2,zero,90c1ecc <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 90c1eb8:	e0bffc17 	ldw	r2,-16(fp)
 90c1ebc:	11000017 	ldw	r4,0(r2)
 90c1ec0:	e17ffd17 	ldw	r5,-12(fp)
 90c1ec4:	90c20e40 	call	90c20e4 <lookup_mcast>
 90c1ec8:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 90c1ecc:	e0bffb17 	ldw	r2,-20(fp)
 90c1ed0:	1005003a 	cmpeq	r2,r2,zero
 90c1ed4:	1000061e 	bne	r2,zero,90c1ef0 <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 90c1ed8:	e0bffb17 	ldw	r2,-20(fp)
 90c1edc:	10800217 	ldw	r2,8(r2)
 90c1ee0:	10c00044 	addi	r3,r2,1
 90c1ee4:	e0bffb17 	ldw	r2,-20(fp)
 90c1ee8:	10c00215 	stw	r3,8(r2)
 90c1eec:	00002e06 	br	90c1fa8 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 90c1ef0:	01000604 	movi	r4,24
 90c1ef4:	90a9f0c0 	call	90a9f0c <npalloc>
 90c1ef8:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 90c1efc:	e0bffb17 	ldw	r2,-20(fp)
 90c1f00:	1004c03a 	cmpne	r2,r2,zero
 90c1f04:	1000031e 	bne	r2,zero,90c1f14 <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 90c1f08:	90a97240 	call	90a9724 <irq_Unmask>
         return ((struct in_multi *)NULL);
 90c1f0c:	e03fff15 	stw	zero,-4(fp)
 90c1f10:	00002806 	br	90c1fb4 <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 90c1f14:	e0bffe17 	ldw	r2,-8(fp)
 90c1f18:	108001a0 	cmpeqi	r2,r2,6
 90c1f1c:	1000041e 	bne	r2,zero,90c1f30 <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 90c1f20:	e0bffc17 	ldw	r2,-16(fp)
 90c1f24:	10c00017 	ldw	r3,0(r2)
 90c1f28:	e0bffb17 	ldw	r2,-20(fp)
 90c1f2c:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 90c1f30:	e0fffb17 	ldw	r3,-20(fp)
 90c1f34:	e0bffd17 	ldw	r2,-12(fp)
 90c1f38:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 90c1f3c:	e0fffb17 	ldw	r3,-20(fp)
 90c1f40:	00800044 	movi	r2,1
 90c1f44:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 90c1f48:	e0bffd17 	ldw	r2,-12(fp)
 90c1f4c:	10c02c17 	ldw	r3,176(r2)
 90c1f50:	e0bffb17 	ldw	r2,-20(fp)
 90c1f54:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 90c1f58:	e0fffd17 	ldw	r3,-12(fp)
 90c1f5c:	e0bffb17 	ldw	r2,-20(fp)
 90c1f60:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 90c1f64:	e0bffd17 	ldw	r2,-12(fp)
 90c1f68:	10802b17 	ldw	r2,172(r2)
 90c1f6c:	1005003a 	cmpeq	r2,r2,zero
 90c1f70:	1000061e 	bne	r2,zero,90c1f8c <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 90c1f74:	e0bffd17 	ldw	r2,-12(fp)
 90c1f78:	10802b17 	ldw	r2,172(r2)
 90c1f7c:	e13ffb17 	ldw	r4,-20(fp)
 90c1f80:	103ee83a 	callr	r2
 90c1f84:	e0bffa15 	stw	r2,-24(fp)
 90c1f88:	00000106 	br	90c1f90 <in_addmulti+0x12c>
      else
         error = 0;
 90c1f8c:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 90c1f90:	e0bffb17 	ldw	r2,-20(fp)
 90c1f94:	10800017 	ldw	r2,0(r2)
 90c1f98:	1005003a 	cmpeq	r2,r2,zero
 90c1f9c:	1000021e 	bne	r2,zero,90c1fa8 <in_addmulti+0x144>
 90c1fa0:	e13ffb17 	ldw	r4,-20(fp)
 90c1fa4:	90a286c0 	call	90a286c <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 90c1fa8:	90a97240 	call	90a9724 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 90c1fac:	e0bffb17 	ldw	r2,-20(fp)
 90c1fb0:	e0bfff15 	stw	r2,-4(fp)
 90c1fb4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1fb8:	e037883a 	mov	sp,fp
 90c1fbc:	dfc00117 	ldw	ra,4(sp)
 90c1fc0:	df000017 	ldw	fp,0(sp)
 90c1fc4:	dec00204 	addi	sp,sp,8
 90c1fc8:	f800283a 	ret

090c1fcc <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 90c1fcc:	defffa04 	addi	sp,sp,-24
 90c1fd0:	dfc00515 	stw	ra,20(sp)
 90c1fd4:	df000415 	stw	fp,16(sp)
 90c1fd8:	df000404 	addi	fp,sp,16
 90c1fdc:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 90c1fe0:	e0bfff17 	ldw	r2,-4(fp)
 90c1fe4:	10800117 	ldw	r2,4(r2)
 90c1fe8:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 90c1fec:	90a96c80 	call	90a96c8 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 90c1ff0:	e0bfff17 	ldw	r2,-4(fp)
 90c1ff4:	10800217 	ldw	r2,8(r2)
 90c1ff8:	10ffffc4 	addi	r3,r2,-1
 90c1ffc:	e0bfff17 	ldw	r2,-4(fp)
 90c2000:	10c00215 	stw	r3,8(r2)
 90c2004:	e0bfff17 	ldw	r2,-4(fp)
 90c2008:	10800217 	ldw	r2,8(r2)
 90c200c:	1004c03a 	cmpne	r2,r2,zero
 90c2010:	10002e1e 	bne	r2,zero,90c20cc <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 90c2014:	e0bffd17 	ldw	r2,-12(fp)
 90c2018:	10802c17 	ldw	r2,176(r2)
 90c201c:	e0bffe15 	stw	r2,-8(fp)
 90c2020:	00001406 	br	90c2074 <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 90c2024:	e0fffe17 	ldw	r3,-8(fp)
 90c2028:	e0bfff17 	ldw	r2,-4(fp)
 90c202c:	1880051e 	bne	r3,r2,90c2044 <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 90c2030:	e0bffe17 	ldw	r2,-8(fp)
 90c2034:	10c00517 	ldw	r3,20(r2)
 90c2038:	e0bffd17 	ldw	r2,-12(fp)
 90c203c:	10c02c15 	stw	r3,176(r2)
            break;
 90c2040:	00000f06 	br	90c2080 <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 90c2044:	e0bffe17 	ldw	r2,-8(fp)
 90c2048:	10c00517 	ldw	r3,20(r2)
 90c204c:	e0bfff17 	ldw	r2,-4(fp)
 90c2050:	1880051e 	bne	r3,r2,90c2068 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 90c2054:	e0bfff17 	ldw	r2,-4(fp)
 90c2058:	10c00517 	ldw	r3,20(r2)
 90c205c:	e0bffe17 	ldw	r2,-8(fp)
 90c2060:	10c00515 	stw	r3,20(r2)
            break;
 90c2064:	00000606 	br	90c2080 <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 90c2068:	e0bffe17 	ldw	r2,-8(fp)
 90c206c:	10800517 	ldw	r2,20(r2)
 90c2070:	e0bffe15 	stw	r2,-8(fp)
 90c2074:	e0bffe17 	ldw	r2,-8(fp)
 90c2078:	1004c03a 	cmpne	r2,r2,zero
 90c207c:	103fe91e 	bne	r2,zero,90c2024 <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 90c2080:	e0bffd17 	ldw	r2,-12(fp)
 90c2084:	10802b17 	ldw	r2,172(r2)
 90c2088:	1005003a 	cmpeq	r2,r2,zero
 90c208c:	1000061e 	bne	r2,zero,90c20a8 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 90c2090:	e0bffd17 	ldw	r2,-12(fp)
 90c2094:	10802b17 	ldw	r2,172(r2)
 90c2098:	e13fff17 	ldw	r4,-4(fp)
 90c209c:	103ee83a 	callr	r2
 90c20a0:	e0bffc15 	stw	r2,-16(fp)
 90c20a4:	00000106 	br	90c20ac <in_delmulti+0xe0>
      else
         error = 0;
 90c20a8:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 90c20ac:	e0bfff17 	ldw	r2,-4(fp)
 90c20b0:	10800017 	ldw	r2,0(r2)
 90c20b4:	1005003a 	cmpeq	r2,r2,zero
 90c20b8:	1000021e 	bne	r2,zero,90c20c4 <in_delmulti+0xf8>
 90c20bc:	e13fff17 	ldw	r4,-4(fp)
 90c20c0:	90a2ae80 	call	90a2ae8 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 90c20c4:	e13fff17 	ldw	r4,-4(fp)
 90c20c8:	90aa0000 	call	90aa000 <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 90c20cc:	90a97240 	call	90a9724 <irq_Unmask>
}
 90c20d0:	e037883a 	mov	sp,fp
 90c20d4:	dfc00117 	ldw	ra,4(sp)
 90c20d8:	df000017 	ldw	fp,0(sp)
 90c20dc:	dec00204 	addi	sp,sp,8
 90c20e0:	f800283a 	ret

090c20e4 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 90c20e4:	defffb04 	addi	sp,sp,-20
 90c20e8:	df000415 	stw	fp,16(sp)
 90c20ec:	df000404 	addi	fp,sp,16
 90c20f0:	e13ffd15 	stw	r4,-12(fp)
 90c20f4:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 90c20f8:	e0bffe17 	ldw	r2,-8(fp)
 90c20fc:	10802c17 	ldw	r2,176(r2)
 90c2100:	e0bffc15 	stw	r2,-16(fp)
 90c2104:	00000a06 	br	90c2130 <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 90c2108:	e0bffc17 	ldw	r2,-16(fp)
 90c210c:	10c00017 	ldw	r3,0(r2)
 90c2110:	e0bffd17 	ldw	r2,-12(fp)
 90c2114:	1880031e 	bne	r3,r2,90c2124 <lookup_mcast+0x40>
         return imp;
 90c2118:	e0bffc17 	ldw	r2,-16(fp)
 90c211c:	e0bfff15 	stw	r2,-4(fp)
 90c2120:	00000706 	br	90c2140 <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 90c2124:	e0bffc17 	ldw	r2,-16(fp)
 90c2128:	10800517 	ldw	r2,20(r2)
 90c212c:	e0bffc15 	stw	r2,-16(fp)
 90c2130:	e0bffc17 	ldw	r2,-16(fp)
 90c2134:	1004c03a 	cmpne	r2,r2,zero
 90c2138:	103ff31e 	bne	r2,zero,90c2108 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 90c213c:	e03fff15 	stw	zero,-4(fp)
 90c2140:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2144:	e037883a 	mov	sp,fp
 90c2148:	df000017 	ldw	fp,0(sp)
 90c214c:	dec00104 	addi	sp,sp,4
 90c2150:	f800283a 	ret

090c2154 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 90c2154:	defffc04 	addi	sp,sp,-16
 90c2158:	dfc00315 	stw	ra,12(sp)
 90c215c:	df000215 	stw	fp,8(sp)
 90c2160:	df000204 	addi	fp,sp,8
 90c2164:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 90c2168:	d0a0ca17 	ldw	r2,-31960(gp)
 90c216c:	1005003a 	cmpeq	r2,r2,zero
 90c2170:	1000041e 	bne	r2,zero,90c2184 <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 90c2174:	d0a0ca17 	ldw	r2,-31960(gp)
 90c2178:	e13ffe17 	ldw	r4,-8(fp)
 90c217c:	103ee83a 	callr	r2
 90c2180:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 90c2184:	e0fffe17 	ldw	r3,-8(fp)
 90c2188:	00824374 	movhi	r2,2317
 90c218c:	108c1e04 	addi	r2,r2,12408
 90c2190:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 90c2194:	e0bffe17 	ldw	r2,-8(fp)
 90c2198:	10800058 	cmpnei	r2,r2,1
 90c219c:	1000041e 	bne	r2,zero,90c21b0 <prep_ifaces+0x5c>
 90c21a0:	00824374 	movhi	r2,2317
 90c21a4:	10815b04 	addi	r2,r2,1388
 90c21a8:	e0bfff15 	stw	r2,-4(fp)
 90c21ac:	00000306 	br	90c21bc <prep_ifaces+0x68>
 90c21b0:	00824374 	movhi	r2,2317
 90c21b4:	10815c04 	addi	r2,r2,1392
 90c21b8:	e0bfff15 	stw	r2,-4(fp)
 90c21bc:	01024374 	movhi	r4,2317
 90c21c0:	21015d04 	addi	r4,r4,1396
 90c21c4:	e17ffe17 	ldw	r5,-8(fp)
 90c21c8:	e1bfff17 	ldw	r6,-4(fp)
 90c21cc:	90825100 	call	9082510 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 90c21d0:	e0bffe17 	ldw	r2,-8(fp)
}
 90c21d4:	e037883a 	mov	sp,fp
 90c21d8:	dfc00117 	ldw	ra,4(sp)
 90c21dc:	df000017 	ldw	fp,0(sp)
 90c21e0:	dec00204 	addi	sp,sp,8
 90c21e4:	f800283a 	ret

090c21e8 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 90c21e8:	defffd04 	addi	sp,sp,-12
 90c21ec:	dfc00215 	stw	ra,8(sp)
 90c21f0:	df000115 	stw	fp,4(sp)
 90c21f4:	df000104 	addi	fp,sp,4
 90c21f8:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 90c21fc:	00800044 	movi	r2,1
 90c2200:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 90c2204:	90a20480 	call	90a2048 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 90c2208:	e13fff17 	ldw	r4,-4(fp)
 90c220c:	90ca4e00 	call	90ca4e0 <exit>

090c2210 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 90c2210:	deffff04 	addi	sp,sp,-4
 90c2214:	df000015 	stw	fp,0(sp)
 90c2218:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 90c221c:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 90c2220:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 90c2224:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 90c2228:	e037883a 	mov	sp,fp
 90c222c:	df000017 	ldw	fp,0(sp)
 90c2230:	dec00104 	addi	sp,sp,4
 90c2234:	f800283a 	ret

090c2238 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 90c2238:	defff804 	addi	sp,sp,-32
 90c223c:	dfc00715 	stw	ra,28(sp)
 90c2240:	df000615 	stw	fp,24(sp)
 90c2244:	df000604 	addi	fp,sp,24
 90c2248:	e17ffc15 	stw	r5,-16(fp)
 90c224c:	e1bffd15 	stw	r6,-12(fp)
 90c2250:	e1fffe15 	stw	r7,-8(fp)
 90c2254:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 90c2258:	0009883a 	mov	r4,zero
 90c225c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 90c2260:	01000604 	movi	r4,24
 90c2264:	90a9f0c0 	call	90a9f0c <npalloc>
 90c2268:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 90c226c:	e0bffa17 	ldw	r2,-24(fp)
 90c2270:	1004c03a 	cmpne	r2,r2,zero
 90c2274:	10000e1e 	bne	r2,zero,90c22b0 <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 90c2278:	00824374 	movhi	r2,2317
 90c227c:	108c1d04 	addi	r2,r2,12404
 90c2280:	10800017 	ldw	r2,0(r2)
 90c2284:	1080010c 	andi	r2,r2,4
 90c2288:	1005003a 	cmpeq	r2,r2,zero
 90c228c:	1000031e 	bne	r2,zero,90c229c <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 90c2290:	01024374 	movhi	r4,2317
 90c2294:	21016804 	addi	r4,r4,1440
 90c2298:	90828380 	call	9082838 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c229c:	0009883a 	mov	r4,zero
 90c22a0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ep;
 90c22a4:	e0bffa17 	ldw	r2,-24(fp)
 90c22a8:	e0bfff15 	stw	r2,-4(fp)
 90c22ac:	00001806 	br	90c2310 <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 90c22b0:	e0fffa17 	ldw	r3,-24(fp)
 90c22b4:	e0bffc17 	ldw	r2,-16(fp)
 90c22b8:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 90c22bc:	e0fffa17 	ldw	r3,-24(fp)
 90c22c0:	e0bffd17 	ldw	r2,-12(fp)
 90c22c4:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 90c22c8:	e0fffa17 	ldw	r3,-24(fp)
 90c22cc:	e0bffb03 	ldbu	r2,-20(fp)
 90c22d0:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 90c22d4:	e0fffa17 	ldw	r3,-24(fp)
 90c22d8:	e0bffe17 	ldw	r2,-8(fp)
 90c22dc:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 90c22e0:	e0fffa17 	ldw	r3,-24(fp)
 90c22e4:	e0800217 	ldw	r2,8(fp)
 90c22e8:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 90c22ec:	d0e0cf17 	ldw	r3,-31940(gp)
 90c22f0:	e0bffa17 	ldw	r2,-24(fp)
 90c22f4:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 90c22f8:	e0bffa17 	ldw	r2,-24(fp)
 90c22fc:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c2300:	0009883a 	mov	r4,zero
 90c2304:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return ep;
 90c2308:	e0bffa17 	ldw	r2,-24(fp)
 90c230c:	e0bfff15 	stw	r2,-4(fp)
 90c2310:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2314:	e037883a 	mov	sp,fp
 90c2318:	dfc00117 	ldw	ra,4(sp)
 90c231c:	df000017 	ldw	fp,0(sp)
 90c2320:	dec00204 	addi	sp,sp,8
 90c2324:	f800283a 	ret

090c2328 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 90c2328:	defffb04 	addi	sp,sp,-20
 90c232c:	dfc00415 	stw	ra,16(sp)
 90c2330:	df000315 	stw	fp,12(sp)
 90c2334:	df000304 	addi	fp,sp,12
 90c2338:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 90c233c:	0009883a 	mov	r4,zero
 90c2340:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 90c2344:	e03ffe15 	stw	zero,-8(fp)
 90c2348:	d0a0cf17 	ldw	r2,-31940(gp)
 90c234c:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 90c2350:	00000806 	br	90c2374 <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 90c2354:	e0fffd17 	ldw	r3,-12(fp)
 90c2358:	e0bfff17 	ldw	r2,-4(fp)
 90c235c:	18800826 	beq	r3,r2,90c2380 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 90c2360:	e0bffd17 	ldw	r2,-12(fp)
 90c2364:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 90c2368:	e0bffd17 	ldw	r2,-12(fp)
 90c236c:	10800017 	ldw	r2,0(r2)
 90c2370:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 90c2374:	e0bffd17 	ldw	r2,-12(fp)
 90c2378:	1004c03a 	cmpne	r2,r2,zero
 90c237c:	103ff51e 	bne	r2,zero,90c2354 <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 90c2380:	e0bffd17 	ldw	r2,-12(fp)
 90c2384:	1004c03a 	cmpne	r2,r2,zero
 90c2388:	1000041e 	bne	r2,zero,90c239c <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 90c238c:	90a94880 	call	90a9488 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c2390:	0009883a 	mov	r4,zero
 90c2394:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return;
 90c2398:	00000e06 	br	90c23d4 <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 90c239c:	e0bffe17 	ldw	r2,-8(fp)
 90c23a0:	1005003a 	cmpeq	r2,r2,zero
 90c23a4:	1000041e 	bne	r2,zero,90c23b8 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 90c23a8:	e0bffd17 	ldw	r2,-12(fp)
 90c23ac:	10800017 	ldw	r2,0(r2)
 90c23b0:	e0bffe15 	stw	r2,-8(fp)
 90c23b4:	00000306 	br	90c23c4 <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 90c23b8:	e0bffd17 	ldw	r2,-12(fp)
 90c23bc:	10800017 	ldw	r2,0(r2)
 90c23c0:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 90c23c4:	e13ffd17 	ldw	r4,-12(fp)
 90c23c8:	90aa0000 	call	90aa000 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c23cc:	0009883a 	mov	r4,zero
 90c23d0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
}
 90c23d4:	e037883a 	mov	sp,fp
 90c23d8:	dfc00117 	ldw	ra,4(sp)
 90c23dc:	df000017 	ldw	fp,0(sp)
 90c23e0:	dec00204 	addi	sp,sp,8
 90c23e4:	f800283a 	ret

090c23e8 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 90c23e8:	defff604 	addi	sp,sp,-40
 90c23ec:	dfc00915 	stw	ra,36(sp)
 90c23f0:	df000815 	stw	fp,32(sp)
 90c23f4:	df000804 	addi	fp,sp,32
 90c23f8:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 90c23fc:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 90c2400:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 90c2404:	e0bfff17 	ldw	r2,-4(fp)
 90c2408:	10800317 	ldw	r2,12(r2)
 90c240c:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 90c2410:	d0a0cf17 	ldw	r2,-31940(gp)
 90c2414:	e0bffd15 	stw	r2,-12(fp)
 90c2418:	00004d06 	br	90c2550 <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 90c241c:	e0bffd17 	ldw	r2,-12(fp)
 90c2420:	10800017 	ldw	r2,0(r2)
 90c2424:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 90c2428:	e0bffd17 	ldw	r2,-12(fp)
 90c242c:	10800503 	ldbu	r2,20(r2)
 90c2430:	10803fcc 	andi	r2,r2,255
 90c2434:	1005003a 	cmpeq	r2,r2,zero
 90c2438:	1000071e 	bne	r2,zero,90c2458 <ip_raw_input+0x70>
 90c243c:	e0bffd17 	ldw	r2,-12(fp)
 90c2440:	10c00503 	ldbu	r3,20(r2)
 90c2444:	e0bffe17 	ldw	r2,-8(fp)
 90c2448:	10800243 	ldbu	r2,9(r2)
 90c244c:	18c03fcc 	andi	r3,r3,255
 90c2450:	10803fcc 	andi	r2,r2,255
 90c2454:	18803c1e 	bne	r3,r2,90c2548 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 90c2458:	e0bffd17 	ldw	r2,-12(fp)
 90c245c:	10800117 	ldw	r2,4(r2)
 90c2460:	1005003a 	cmpeq	r2,r2,zero
 90c2464:	1000051e 	bne	r2,zero,90c247c <ip_raw_input+0x94>
 90c2468:	e0bffd17 	ldw	r2,-12(fp)
 90c246c:	10c00117 	ldw	r3,4(r2)
 90c2470:	e0bffe17 	ldw	r2,-8(fp)
 90c2474:	10800417 	ldw	r2,16(r2)
 90c2478:	1880331e 	bne	r3,r2,90c2548 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 90c247c:	e0bffd17 	ldw	r2,-12(fp)
 90c2480:	10800217 	ldw	r2,8(r2)
 90c2484:	1005003a 	cmpeq	r2,r2,zero
 90c2488:	1000051e 	bne	r2,zero,90c24a0 <ip_raw_input+0xb8>
 90c248c:	e0bffd17 	ldw	r2,-12(fp)
 90c2490:	10c00217 	ldw	r3,8(r2)
 90c2494:	e0bffe17 	ldw	r2,-8(fp)
 90c2498:	10800317 	ldw	r2,12(r2)
 90c249c:	18802a1e 	bne	r3,r2,90c2548 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 90c24a0:	e0bffd17 	ldw	r2,-12(fp)
 90c24a4:	10800317 	ldw	r2,12(r2)
 90c24a8:	1005003a 	cmpeq	r2,r2,zero
 90c24ac:	1000261e 	bne	r2,zero,90c2548 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c24b0:	e0bffb17 	ldw	r2,-20(fp)
 90c24b4:	1005003a 	cmpeq	r2,r2,zero
 90c24b8:	1000211e 	bne	r2,zero,90c2540 <ip_raw_input+0x158>
 90c24bc:	e0bffb17 	ldw	r2,-20(fp)
 90c24c0:	10800317 	ldw	r2,12(r2)
 90c24c4:	1005003a 	cmpeq	r2,r2,zero
 90c24c8:	10001d1e 	bne	r2,zero,90c2540 <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 90c24cc:	e13fff17 	ldw	r4,-4(fp)
 90c24d0:	90bf0f00 	call	90bf0f0 <ip_copypkt>
 90c24d4:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 90c24d8:	e0bff817 	ldw	r2,-32(fp)
 90c24dc:	1005003a 	cmpeq	r2,r2,zero
 90c24e0:	1000171e 	bne	r2,zero,90c2540 <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 90c24e4:	0009883a 	mov	r4,zero
 90c24e8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 90c24ec:	e0bffb17 	ldw	r2,-20(fp)
 90c24f0:	10c00317 	ldw	r3,12(r2)
 90c24f4:	e0bffb17 	ldw	r2,-20(fp)
 90c24f8:	11400417 	ldw	r5,16(r2)
 90c24fc:	e13ff817 	ldw	r4,-32(fp)
 90c2500:	183ee83a 	callr	r3
 90c2504:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 90c2508:	0009883a 	mov	r4,zero
 90c250c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
               if (err)
 90c2510:	e0bffa17 	ldw	r2,-24(fp)
 90c2514:	1005003a 	cmpeq	r2,r2,zero
 90c2518:	1000071e 	bne	r2,zero,90c2538 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 90c251c:	01000084 	movi	r4,2
 90c2520:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 90c2524:	e13ff817 	ldw	r4,-32(fp)
 90c2528:	90a8bd80 	call	90a8bd8 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c252c:	01000084 	movi	r4,2
 90c2530:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
 90c2534:	00000206 	br	90c2540 <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 90c2538:	00800044 	movi	r2,1
 90c253c:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 90c2540:	e0bffd17 	ldw	r2,-12(fp)
 90c2544:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 90c2548:	e0bffc17 	ldw	r2,-16(fp)
 90c254c:	e0bffd15 	stw	r2,-12(fp)
 90c2550:	e0bffd17 	ldw	r2,-12(fp)
 90c2554:	1004c03a 	cmpne	r2,r2,zero
 90c2558:	103fb01e 	bne	r2,zero,90c241c <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c255c:	e0bffb17 	ldw	r2,-20(fp)
 90c2560:	1005003a 	cmpeq	r2,r2,zero
 90c2564:	1000151e 	bne	r2,zero,90c25bc <ip_raw_input+0x1d4>
 90c2568:	e0bffb17 	ldw	r2,-20(fp)
 90c256c:	10800317 	ldw	r2,12(r2)
 90c2570:	1005003a 	cmpeq	r2,r2,zero
 90c2574:	1000111e 	bne	r2,zero,90c25bc <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c2578:	0009883a 	mov	r4,zero
 90c257c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 90c2580:	e0bffb17 	ldw	r2,-20(fp)
 90c2584:	10c00317 	ldw	r3,12(r2)
 90c2588:	e0bffb17 	ldw	r2,-20(fp)
 90c258c:	11400417 	ldw	r5,16(r2)
 90c2590:	e13fff17 	ldw	r4,-4(fp)
 90c2594:	183ee83a 	callr	r3
 90c2598:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 90c259c:	0009883a 	mov	r4,zero
 90c25a0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      if (err == 0)
 90c25a4:	e0bffa17 	ldw	r2,-24(fp)
 90c25a8:	1004c03a 	cmpne	r2,r2,zero
 90c25ac:	10000c1e 	bne	r2,zero,90c25e0 <ip_raw_input+0x1f8>
         delivered = 1;
 90c25b0:	00800044 	movi	r2,1
 90c25b4:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c25b8:	00000906 	br	90c25e0 <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 90c25bc:	00bffd84 	movi	r2,-10
 90c25c0:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 90c25c4:	008243b4 	movhi	r2,2318
 90c25c8:	10b66404 	addi	r2,r2,-9840
 90c25cc:	10800617 	ldw	r2,24(r2)
 90c25d0:	10c00044 	addi	r3,r2,1
 90c25d4:	008243b4 	movhi	r2,2318
 90c25d8:	10b66404 	addi	r2,r2,-9840
 90c25dc:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 90c25e0:	e0bff917 	ldw	r2,-28(fp)
 90c25e4:	1004c03a 	cmpne	r2,r2,zero
 90c25e8:	1000071e 	bne	r2,zero,90c2608 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 90c25ec:	008243b4 	movhi	r2,2318
 90c25f0:	10b66404 	addi	r2,r2,-9840
 90c25f4:	10800817 	ldw	r2,32(r2)
 90c25f8:	10ffffc4 	addi	r3,r2,-1
 90c25fc:	008243b4 	movhi	r2,2318
 90c2600:	10b66404 	addi	r2,r2,-9840
 90c2604:	10c00815 	stw	r3,32(r2)

   return err;
 90c2608:	e0bffa17 	ldw	r2,-24(fp)
}
 90c260c:	e037883a 	mov	sp,fp
 90c2610:	dfc00117 	ldw	ra,4(sp)
 90c2614:	df000017 	ldw	fp,0(sp)
 90c2618:	dec00204 	addi	sp,sp,8
 90c261c:	f800283a 	ret

090c2620 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 90c2620:	defffa04 	addi	sp,sp,-24
 90c2624:	dfc00515 	stw	ra,20(sp)
 90c2628:	df000415 	stw	fp,16(sp)
 90c262c:	df000404 	addi	fp,sp,16
 90c2630:	e13ffe15 	stw	r4,-8(fp)
 90c2634:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 90c2638:	e0bffe17 	ldw	r2,-8(fp)
 90c263c:	10c00044 	addi	r3,r2,1
 90c2640:	00bfff84 	movi	r2,-2
 90c2644:	1884703a 	and	r2,r3,r2
 90c2648:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 90c264c:	e0bfff17 	ldw	r2,-4(fp)
 90c2650:	1004c03a 	cmpne	r2,r2,zero
 90c2654:	1000031e 	bne	r2,zero,90c2664 <ip_raw_alloc+0x44>
      len += IPHSIZ;
 90c2658:	e0bffd17 	ldw	r2,-12(fp)
 90c265c:	10800504 	addi	r2,r2,20
 90c2660:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2664:	01000084 	movi	r4,2
 90c2668:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 90c266c:	00824374 	movhi	r2,2317
 90c2670:	108c1b04 	addi	r2,r2,12396
 90c2674:	10c00017 	ldw	r3,0(r2)
 90c2678:	e0bffd17 	ldw	r2,-12(fp)
 90c267c:	1885883a 	add	r2,r3,r2
 90c2680:	1009883a 	mov	r4,r2
 90c2684:	90a88440 	call	90a8844 <pk_alloc>
 90c2688:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c268c:	01000084 	movi	r4,2
 90c2690:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   if (p)
 90c2694:	e0bffc17 	ldw	r2,-16(fp)
 90c2698:	1005003a 	cmpeq	r2,r2,zero
 90c269c:	10000d1e 	bne	r2,zero,90c26d4 <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 90c26a0:	e0bfff17 	ldw	r2,-4(fp)
 90c26a4:	1004c03a 	cmpne	r2,r2,zero
 90c26a8:	10000a1e 	bne	r2,zero,90c26d4 <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 90c26ac:	e0bffc17 	ldw	r2,-16(fp)
 90c26b0:	10800317 	ldw	r2,12(r2)
 90c26b4:	10c00504 	addi	r3,r2,20
 90c26b8:	e0bffc17 	ldw	r2,-16(fp)
 90c26bc:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 90c26c0:	e0bffc17 	ldw	r2,-16(fp)
 90c26c4:	10800417 	ldw	r2,16(r2)
 90c26c8:	10fffb04 	addi	r3,r2,-20
 90c26cc:	e0bffc17 	ldw	r2,-16(fp)
 90c26d0:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 90c26d4:	e0bffc17 	ldw	r2,-16(fp)
}
 90c26d8:	e037883a 	mov	sp,fp
 90c26dc:	dfc00117 	ldw	ra,4(sp)
 90c26e0:	df000017 	ldw	fp,0(sp)
 90c26e4:	dec00204 	addi	sp,sp,8
 90c26e8:	f800283a 	ret

090c26ec <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 90c26ec:	defffd04 	addi	sp,sp,-12
 90c26f0:	dfc00215 	stw	ra,8(sp)
 90c26f4:	df000115 	stw	fp,4(sp)
 90c26f8:	df000104 	addi	fp,sp,4
 90c26fc:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2700:	01000084 	movi	r4,2
 90c2704:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c2708:	e13fff17 	ldw	r4,-4(fp)
 90c270c:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2710:	01000084 	movi	r4,2
 90c2714:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
}
 90c2718:	e037883a 	mov	sp,fp
 90c271c:	dfc00117 	ldw	ra,4(sp)
 90c2720:	df000017 	ldw	fp,0(sp)
 90c2724:	dec00204 	addi	sp,sp,8
 90c2728:	f800283a 	ret

090c272c <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 90c272c:	defffd04 	addi	sp,sp,-12
 90c2730:	df000215 	stw	fp,8(sp)
 90c2734:	df000204 	addi	fp,sp,8
 90c2738:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 90c273c:	00824374 	movhi	r2,2317
 90c2740:	108bd104 	addi	r2,r2,12100
 90c2744:	10c00017 	ldw	r3,0(r2)
 90c2748:	00824374 	movhi	r2,2317
 90c274c:	108c1b04 	addi	r2,r2,12396
 90c2750:	10800017 	ldw	r2,0(r2)
 90c2754:	1885c83a 	sub	r2,r3,r2
 90c2758:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 90c275c:	e0bfff17 	ldw	r2,-4(fp)
 90c2760:	1004c03a 	cmpne	r2,r2,zero
 90c2764:	1000031e 	bne	r2,zero,90c2774 <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 90c2768:	e0bffe17 	ldw	r2,-8(fp)
 90c276c:	10bffb04 	addi	r2,r2,-20
 90c2770:	e0bffe15 	stw	r2,-8(fp)
   return len;
 90c2774:	e0bffe17 	ldw	r2,-8(fp)
}
 90c2778:	e037883a 	mov	sp,fp
 90c277c:	df000017 	ldw	fp,0(sp)
 90c2780:	dec00104 	addi	sp,sp,4
 90c2784:	f800283a 	ret

090c2788 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 90c2788:	defff804 	addi	sp,sp,-32
 90c278c:	df000715 	stw	fp,28(sp)
 90c2790:	df000704 	addi	fp,sp,28
 90c2794:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 90c2798:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 90c279c:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c27a0:	00824374 	movhi	r2,2317
 90c27a4:	108c6004 	addi	r2,r2,12672
 90c27a8:	10800017 	ldw	r2,0(r2)
 90c27ac:	e0bffe15 	stw	r2,-8(fp)
 90c27b0:	00003e06 	br	90c28ac <rt_lookup+0x124>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 90c27b4:	e0bffe17 	ldw	r2,-8(fp)
 90c27b8:	10800617 	ldw	r2,24(r2)
 90c27bc:	1005003a 	cmpeq	r2,r2,zero
 90c27c0:	1000371e 	bne	r2,zero,90c28a0 <rt_lookup+0x118>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 90c27c4:	e0bffe17 	ldw	r2,-8(fp)
 90c27c8:	10800a17 	ldw	r2,40(r2)
 90c27cc:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 90c27d0:	e0bffe17 	ldw	r2,-8(fp)
 90c27d4:	10c00017 	ldw	r3,0(r2)
 90c27d8:	e0bffb17 	ldw	r2,-20(fp)
 90c27dc:	1888703a 	and	r4,r3,r2
 90c27e0:	e0ffff17 	ldw	r3,-4(fp)
 90c27e4:	e0bffb17 	ldw	r2,-20(fp)
 90c27e8:	1884703a 	and	r2,r3,r2
 90c27ec:	20802c1e 	bne	r4,r2,90c28a0 <rt_lookup+0x118>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 90c27f0:	e03ffc05 	stb	zero,-16(fp)
 90c27f4:	00a00034 	movhi	r2,32768
 90c27f8:	e0bffa15 	stw	r2,-24(fp)
 90c27fc:	00001b06 	br	90c286c <rt_lookup+0xe4>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 90c2800:	e0bffb17 	ldw	r2,-20(fp)
 90c2804:	1004d63a 	srli	r2,r2,24
 90c2808:	10c03fcc 	andi	r3,r2,255
 90c280c:	e0bffb17 	ldw	r2,-20(fp)
 90c2810:	1004d23a 	srli	r2,r2,8
 90c2814:	10bfc00c 	andi	r2,r2,65280
 90c2818:	1886b03a 	or	r3,r3,r2
 90c281c:	e0bffb17 	ldw	r2,-20(fp)
 90c2820:	10bfc00c 	andi	r2,r2,65280
 90c2824:	1004923a 	slli	r2,r2,8
 90c2828:	1886b03a 	or	r3,r3,r2
 90c282c:	e0bffb17 	ldw	r2,-20(fp)
 90c2830:	10803fcc 	andi	r2,r2,255
 90c2834:	1004963a 	slli	r2,r2,24
 90c2838:	1886b03a 	or	r3,r3,r2
 90c283c:	e0bffa17 	ldw	r2,-24(fp)
 90c2840:	1884703a 	and	r2,r3,r2
 90c2844:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 90c2848:	e0bff917 	ldw	r2,-28(fp)
 90c284c:	1005003a 	cmpeq	r2,r2,zero
 90c2850:	1000031e 	bne	r2,zero,90c2860 <rt_lookup+0xd8>
 90c2854:	e0bffc03 	ldbu	r2,-16(fp)
 90c2858:	10800044 	addi	r2,r2,1
 90c285c:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 90c2860:	e0bffa17 	ldw	r2,-24(fp)
 90c2864:	1004d07a 	srli	r2,r2,1
 90c2868:	e0bffa15 	stw	r2,-24(fp)
 90c286c:	e0bffa17 	ldw	r2,-24(fp)
 90c2870:	1004c03a 	cmpne	r2,r2,zero
 90c2874:	103fe21e 	bne	r2,zero,90c2800 <rt_lookup+0x78>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 90c2878:	e0fffc03 	ldbu	r3,-16(fp)
 90c287c:	e0bffc43 	ldbu	r2,-15(fp)
 90c2880:	10c0072e 	bgeu	r2,r3,90c28a0 <rt_lookup+0x118>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 90c2884:	e0bffc03 	ldbu	r2,-16(fp)
 90c2888:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 90c288c:	e0bffe17 	ldw	r2,-8(fp)
 90c2890:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 90c2894:	e0bffc43 	ldbu	r2,-15(fp)
 90c2898:	10800820 	cmpeqi	r2,r2,32
 90c289c:	10000e1e 	bne	r2,zero,90c28d8 <rt_lookup+0x150>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c28a0:	e0bffe17 	ldw	r2,-8(fp)
 90c28a4:	10800f04 	addi	r2,r2,60
 90c28a8:	e0bffe15 	stw	r2,-8(fp)
 90c28ac:	00824374 	movhi	r2,2317
 90c28b0:	108beb04 	addi	r2,r2,12204
 90c28b4:	10800017 	ldw	r2,0(r2)
 90c28b8:	10800f24 	muli	r2,r2,60
 90c28bc:	1007883a 	mov	r3,r2
 90c28c0:	00824374 	movhi	r2,2317
 90c28c4:	108c6004 	addi	r2,r2,12672
 90c28c8:	10800017 	ldw	r2,0(r2)
 90c28cc:	1887883a 	add	r3,r3,r2
 90c28d0:	e0bffe17 	ldw	r2,-8(fp)
 90c28d4:	10ffb736 	bltu	r2,r3,90c27b4 <rt_lookup+0x2c>
               break;
         }
      }
   }

   if (netmatch)
 90c28d8:	e0bffd17 	ldw	r2,-12(fp)
 90c28dc:	1005003a 	cmpeq	r2,r2,zero
 90c28e0:	1000051e 	bne	r2,zero,90c28f8 <rt_lookup+0x170>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 90c28e4:	00824374 	movhi	r2,2317
 90c28e8:	108c4204 	addi	r2,r2,12552
 90c28ec:	10c00017 	ldw	r3,0(r2)
 90c28f0:	e0bffd17 	ldw	r2,-12(fp)
 90c28f4:	10c00915 	stw	r3,36(r2)

   return netmatch;
 90c28f8:	e0bffd17 	ldw	r2,-12(fp)
}
 90c28fc:	e037883a 	mov	sp,fp
 90c2900:	df000017 	ldw	fp,0(sp)
 90c2904:	dec00104 	addi	sp,sp,4
 90c2908:	f800283a 	ret

090c290c <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 90c290c:	defff604 	addi	sp,sp,-40
 90c2910:	dfc00915 	stw	ra,36(sp)
 90c2914:	df000815 	stw	fp,32(sp)
 90c2918:	df000804 	addi	fp,sp,32
 90c291c:	e13ffb15 	stw	r4,-20(fp)
 90c2920:	e17ffc15 	stw	r5,-16(fp)
 90c2924:	e1bffd15 	stw	r6,-12(fp)
 90c2928:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 90c292c:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 90c2930:	e13ffe17 	ldw	r4,-8(fp)
 90c2934:	90bcce40 	call	90bcce4 <if_getbynum>
 90c2938:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 90c293c:	e0bff817 	ldw	r2,-32(fp)
 90c2940:	1004c03a 	cmpne	r2,r2,zero
 90c2944:	1000021e 	bne	r2,zero,90c2950 <add_route+0x44>
      return NULL;
 90c2948:	e03fff15 	stw	zero,-4(fp)
 90c294c:	0000f306 	br	90c2d1c <add_route+0x410>

   if (rt_mib == NULL)
 90c2950:	00824374 	movhi	r2,2317
 90c2954:	108c6004 	addi	r2,r2,12672
 90c2958:	10800017 	ldw	r2,0(r2)
 90c295c:	1004c03a 	cmpne	r2,r2,zero
 90c2960:	1000021e 	bne	r2,zero,90c296c <add_route+0x60>
      return NULL;
 90c2964:	e03fff15 	stw	zero,-4(fp)
 90c2968:	0000ec06 	br	90c2d1c <add_route+0x410>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 90c296c:	e0bffb17 	ldw	r2,-20(fp)
 90c2970:	1005003a 	cmpeq	r2,r2,zero
 90c2974:	1000031e 	bne	r2,zero,90c2984 <add_route+0x78>
 90c2978:	e0bffc17 	ldw	r2,-16(fp)
 90c297c:	1004c03a 	cmpne	r2,r2,zero
 90c2980:	1000241e 	bne	r2,zero,90c2a14 <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 90c2984:	90a94880 	call	90a9488 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 90c2988:	e0bffb17 	ldw	r2,-20(fp)
 90c298c:	1004d63a 	srli	r2,r2,24
 90c2990:	10c03fcc 	andi	r3,r2,255
 90c2994:	e0bffb17 	ldw	r2,-20(fp)
 90c2998:	1004d23a 	srli	r2,r2,8
 90c299c:	10bfc00c 	andi	r2,r2,65280
 90c29a0:	1886b03a 	or	r3,r3,r2
 90c29a4:	e0bffb17 	ldw	r2,-20(fp)
 90c29a8:	10bfc00c 	andi	r2,r2,65280
 90c29ac:	1004923a 	slli	r2,r2,8
 90c29b0:	1886b03a 	or	r3,r3,r2
 90c29b4:	e0bffb17 	ldw	r2,-20(fp)
 90c29b8:	10803fcc 	andi	r2,r2,255
 90c29bc:	1004963a 	slli	r2,r2,24
 90c29c0:	188ab03a 	or	r5,r3,r2
 90c29c4:	e0bffc17 	ldw	r2,-16(fp)
 90c29c8:	1004d63a 	srli	r2,r2,24
 90c29cc:	10c03fcc 	andi	r3,r2,255
 90c29d0:	e0bffc17 	ldw	r2,-16(fp)
 90c29d4:	1004d23a 	srli	r2,r2,8
 90c29d8:	10bfc00c 	andi	r2,r2,65280
 90c29dc:	1886b03a 	or	r3,r3,r2
 90c29e0:	e0bffc17 	ldw	r2,-16(fp)
 90c29e4:	10bfc00c 	andi	r2,r2,65280
 90c29e8:	1004923a 	slli	r2,r2,8
 90c29ec:	1886b03a 	or	r3,r3,r2
 90c29f0:	e0bffc17 	ldw	r2,-16(fp)
 90c29f4:	10803fcc 	andi	r2,r2,255
 90c29f8:	1004963a 	slli	r2,r2,24
 90c29fc:	188cb03a 	or	r6,r3,r2
 90c2a00:	01024374 	movhi	r4,2317
 90c2a04:	21017104 	addi	r4,r4,1476
 90c2a08:	90825100 	call	9082510 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 90c2a0c:	e03fff15 	stw	zero,-4(fp)
 90c2a10:	0000c206 	br	90c2d1c <add_route+0x410>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c2a14:	00824374 	movhi	r2,2317
 90c2a18:	108c6004 	addi	r2,r2,12672
 90c2a1c:	10800017 	ldw	r2,0(r2)
 90c2a20:	e0bffa15 	stw	r2,-24(fp)
 90c2a24:	00006f06 	br	90c2be4 <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 90c2a28:	e0bffa17 	ldw	r2,-24(fp)
 90c2a2c:	10c00017 	ldw	r3,0(r2)
 90c2a30:	e0bffb17 	ldw	r2,-20(fp)
 90c2a34:	1880181e 	bne	r3,r2,90c2a98 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 90c2a38:	e0fffa17 	ldw	r3,-24(fp)
 90c2a3c:	e0bffd17 	ldw	r2,-12(fp)
 90c2a40:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 90c2a44:	00824374 	movhi	r2,2317
 90c2a48:	108c4204 	addi	r2,r2,12552
 90c2a4c:	10c00017 	ldw	r3,0(r2)
 90c2a50:	e0bffa17 	ldw	r2,-24(fp)
 90c2a54:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 90c2a58:	e0bffe17 	ldw	r2,-8(fp)
 90c2a5c:	10c00044 	addi	r3,r2,1
 90c2a60:	e0bffa17 	ldw	r2,-24(fp)
 90c2a64:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 90c2a68:	e0fffa17 	ldw	r3,-24(fp)
 90c2a6c:	e0800217 	ldw	r2,8(fp)
 90c2a70:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 90c2a74:	e0fffa17 	ldw	r3,-24(fp)
 90c2a78:	e0bffc17 	ldw	r2,-16(fp)
 90c2a7c:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 90c2a80:	e0fffa17 	ldw	r3,-24(fp)
 90c2a84:	e0bff817 	ldw	r2,-32(fp)
 90c2a88:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 90c2a8c:	e0bffa17 	ldw	r2,-24(fp)
 90c2a90:	e0bfff15 	stw	r2,-4(fp)
 90c2a94:	0000a106 	br	90c2d1c <add_route+0x410>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 90c2a98:	e0bff917 	ldw	r2,-28(fp)
 90c2a9c:	1005003a 	cmpeq	r2,r2,zero
 90c2aa0:	1000041e 	bne	r2,zero,90c2ab4 <add_route+0x1a8>
 90c2aa4:	e0bff917 	ldw	r2,-28(fp)
 90c2aa8:	10800817 	ldw	r2,32(r2)
 90c2aac:	1005003a 	cmpeq	r2,r2,zero
 90c2ab0:	1000491e 	bne	r2,zero,90c2bd8 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 90c2ab4:	e0bffa17 	ldw	r2,-24(fp)
 90c2ab8:	10800617 	ldw	r2,24(r2)
 90c2abc:	1004c03a 	cmpne	r2,r2,zero
 90c2ac0:	1000051e 	bne	r2,zero,90c2ad8 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 90c2ac4:	e0bffa17 	ldw	r2,-24(fp)
 90c2ac8:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 90c2acc:	e0bff917 	ldw	r2,-28(fp)
 90c2ad0:	10000815 	stw	zero,32(r2)
            continue;
 90c2ad4:	00004006 	br	90c2bd8 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 90c2ad8:	e0c00217 	ldw	r3,8(fp)
 90c2adc:	00824374 	movhi	r2,2317
 90c2ae0:	108b3c04 	addi	r2,r2,11504
 90c2ae4:	10c5883a 	add	r2,r2,r3
 90c2ae8:	11000003 	ldbu	r4,0(r2)
 90c2aec:	e0bffa17 	ldw	r2,-24(fp)
 90c2af0:	10c00817 	ldw	r3,32(r2)
 90c2af4:	00824374 	movhi	r2,2317
 90c2af8:	108b3c04 	addi	r2,r2,11504
 90c2afc:	10c5883a 	add	r2,r2,r3
 90c2b00:	10800003 	ldbu	r2,0(r2)
 90c2b04:	20c03fcc 	andi	r3,r4,255
 90c2b08:	10803fcc 	andi	r2,r2,255
 90c2b0c:	18803236 	bltu	r3,r2,90c2bd8 <add_route+0x2cc>
         {
            if (!newrt)
 90c2b10:	e0bff917 	ldw	r2,-28(fp)
 90c2b14:	1004c03a 	cmpne	r2,r2,zero
 90c2b18:	1000031e 	bne	r2,zero,90c2b28 <add_route+0x21c>
            {
               newrt = rtp;
 90c2b1c:	e0bffa17 	ldw	r2,-24(fp)
 90c2b20:	e0bff915 	stw	r2,-28(fp)
               continue;
 90c2b24:	00002c06 	br	90c2bd8 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 90c2b28:	e0bffa17 	ldw	r2,-24(fp)
 90c2b2c:	10c00817 	ldw	r3,32(r2)
 90c2b30:	00824374 	movhi	r2,2317
 90c2b34:	108b3c04 	addi	r2,r2,11504
 90c2b38:	10c5883a 	add	r2,r2,r3
 90c2b3c:	11000003 	ldbu	r4,0(r2)
 90c2b40:	e0bff917 	ldw	r2,-28(fp)
 90c2b44:	10c00817 	ldw	r3,32(r2)
 90c2b48:	00824374 	movhi	r2,2317
 90c2b4c:	108b3c04 	addi	r2,r2,11504
 90c2b50:	10c5883a 	add	r2,r2,r3
 90c2b54:	10800003 	ldbu	r2,0(r2)
 90c2b58:	20c03fcc 	andi	r3,r4,255
 90c2b5c:	10803fcc 	andi	r2,r2,255
 90c2b60:	1880032e 	bgeu	r3,r2,90c2b70 <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 90c2b64:	e0bffa17 	ldw	r2,-24(fp)
 90c2b68:	e0bff915 	stw	r2,-28(fp)
 90c2b6c:	00001a06 	br	90c2bd8 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 90c2b70:	e0bffa17 	ldw	r2,-24(fp)
 90c2b74:	10c00817 	ldw	r3,32(r2)
 90c2b78:	00824374 	movhi	r2,2317
 90c2b7c:	108b3c04 	addi	r2,r2,11504
 90c2b80:	10c5883a 	add	r2,r2,r3
 90c2b84:	11000003 	ldbu	r4,0(r2)
 90c2b88:	e0bff917 	ldw	r2,-28(fp)
 90c2b8c:	10c00817 	ldw	r3,32(r2)
 90c2b90:	00824374 	movhi	r2,2317
 90c2b94:	108b3c04 	addi	r2,r2,11504
 90c2b98:	10c5883a 	add	r2,r2,r3
 90c2b9c:	10800003 	ldbu	r2,0(r2)
 90c2ba0:	20c03fcc 	andi	r3,r4,255
 90c2ba4:	10803fcc 	andi	r2,r2,255
 90c2ba8:	18800b1e 	bne	r3,r2,90c2bd8 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 90c2bac:	e0bffa17 	ldw	r2,-24(fp)
 90c2bb0:	11000917 	ldw	r4,36(r2)
 90c2bb4:	e0bff917 	ldw	r2,-28(fp)
 90c2bb8:	11400917 	ldw	r5,36(r2)
 90c2bbc:	90a1a840 	call	90a1a84 <c_older>
 90c2bc0:	1007883a 	mov	r3,r2
 90c2bc4:	e0bffa17 	ldw	r2,-24(fp)
 90c2bc8:	10800917 	ldw	r2,36(r2)
 90c2bcc:	1880021e 	bne	r3,r2,90c2bd8 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 90c2bd0:	e0bffa17 	ldw	r2,-24(fp)
 90c2bd4:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c2bd8:	e0bffa17 	ldw	r2,-24(fp)
 90c2bdc:	10800f04 	addi	r2,r2,60
 90c2be0:	e0bffa15 	stw	r2,-24(fp)
 90c2be4:	00824374 	movhi	r2,2317
 90c2be8:	108beb04 	addi	r2,r2,12204
 90c2bec:	10800017 	ldw	r2,0(r2)
 90c2bf0:	10800f24 	muli	r2,r2,60
 90c2bf4:	1007883a 	mov	r3,r2
 90c2bf8:	00824374 	movhi	r2,2317
 90c2bfc:	108c6004 	addi	r2,r2,12672
 90c2c00:	10800017 	ldw	r2,0(r2)
 90c2c04:	1887883a 	add	r3,r3,r2
 90c2c08:	e0bffa17 	ldw	r2,-24(fp)
 90c2c0c:	10ff8636 	bltu	r2,r3,90c2a28 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 90c2c10:	e0bff917 	ldw	r2,-28(fp)
 90c2c14:	1005003a 	cmpeq	r2,r2,zero
 90c2c18:	10002a1e 	bne	r2,zero,90c2cc4 <add_route+0x3b8>
      rtp = newrt;   /* create new entry in lowest priority slot */
 90c2c1c:	e0bff917 	ldw	r2,-28(fp)
 90c2c20:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 90c2c24:	e0fffa17 	ldw	r3,-24(fp)
 90c2c28:	e0bff817 	ldw	r2,-32(fp)
 90c2c2c:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 90c2c30:	e0fffa17 	ldw	r3,-24(fp)
 90c2c34:	e0bffb17 	ldw	r2,-20(fp)
 90c2c38:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 90c2c3c:	e13ff817 	ldw	r4,-32(fp)
 90c2c40:	90a21180 	call	90a2118 <if_netnumber>
 90c2c44:	10c00044 	addi	r3,r2,1
 90c2c48:	e0bffa17 	ldw	r2,-24(fp)
 90c2c4c:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 90c2c50:	008243b4 	movhi	r2,2318
 90c2c54:	10b66404 	addi	r2,r2,-9840
 90c2c58:	10800117 	ldw	r2,4(r2)
 90c2c5c:	1007883a 	mov	r3,r2
 90c2c60:	e0bffa17 	ldw	r2,-24(fp)
 90c2c64:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 90c2c68:	e0fffa17 	ldw	r3,-24(fp)
 90c2c6c:	00bfffc4 	movi	r2,-1
 90c2c70:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 90c2c74:	e0fffa17 	ldw	r3,-24(fp)
 90c2c78:	00bfffc4 	movi	r2,-1
 90c2c7c:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 90c2c80:	e0fffa17 	ldw	r3,-24(fp)
 90c2c84:	00bfffc4 	movi	r2,-1
 90c2c88:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 90c2c8c:	e0fffa17 	ldw	r3,-24(fp)
 90c2c90:	e0bffd17 	ldw	r2,-12(fp)
 90c2c94:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 90c2c98:	e0fffa17 	ldw	r3,-24(fp)
 90c2c9c:	e0800217 	ldw	r2,8(fp)
 90c2ca0:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 90c2ca4:	e0fffb17 	ldw	r3,-20(fp)
 90c2ca8:	e0bffc17 	ldw	r2,-16(fp)
 90c2cac:	1888703a 	and	r4,r3,r2
 90c2cb0:	e0fffd17 	ldw	r3,-12(fp)
 90c2cb4:	e0bffc17 	ldw	r2,-16(fp)
 90c2cb8:	1884703a 	and	r2,r3,r2
 90c2cbc:	20800326 	beq	r4,r2,90c2ccc <add_route+0x3c0>
 90c2cc0:	00000606 	br	90c2cdc <add_route+0x3d0>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 90c2cc4:	e03fff15 	stw	zero,-4(fp)
 90c2cc8:	00001406 	br	90c2d1c <add_route+0x410>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 90c2ccc:	e0fffa17 	ldw	r3,-24(fp)
 90c2cd0:	008000c4 	movi	r2,3
 90c2cd4:	18800715 	stw	r2,28(r3)
 90c2cd8:	00000306 	br	90c2ce8 <add_route+0x3dc>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 90c2cdc:	e0fffa17 	ldw	r3,-24(fp)
 90c2ce0:	00800104 	movi	r2,4
 90c2ce4:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 90c2ce8:	00824374 	movhi	r2,2317
 90c2cec:	108c4204 	addi	r2,r2,12552
 90c2cf0:	10c00017 	ldw	r3,0(r2)
 90c2cf4:	e0bffa17 	ldw	r2,-24(fp)
 90c2cf8:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 90c2cfc:	e0fffa17 	ldw	r3,-24(fp)
 90c2d00:	e0bffc17 	ldw	r2,-16(fp)
 90c2d04:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 90c2d08:	e0fffa17 	ldw	r3,-24(fp)
 90c2d0c:	00bfffc4 	movi	r2,-1
 90c2d10:	18800b15 	stw	r2,44(r3)
   return(rtp);
 90c2d14:	e0bffa17 	ldw	r2,-24(fp)
 90c2d18:	e0bfff15 	stw	r2,-4(fp)
 90c2d1c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2d20:	e037883a 	mov	sp,fp
 90c2d24:	dfc00117 	ldw	ra,4(sp)
 90c2d28:	df000017 	ldw	fp,0(sp)
 90c2d2c:	dec00204 	addi	sp,sp,8
 90c2d30:	f800283a 	ret

090c2d34 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 90c2d34:	defff704 	addi	sp,sp,-36
 90c2d38:	dfc00815 	stw	ra,32(sp)
 90c2d3c:	df000715 	stw	fp,28(sp)
 90c2d40:	df000704 	addi	fp,sp,28
 90c2d44:	e13ffc15 	stw	r4,-16(fp)
 90c2d48:	e17ffd15 	stw	r5,-12(fp)
 90c2d4c:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 90c2d50:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 90c2d54:	e0bffe17 	ldw	r2,-8(fp)
 90c2d58:	10bfffd8 	cmpnei	r2,r2,-1
 90c2d5c:	1000021e 	bne	r2,zero,90c2d68 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 90c2d60:	e03ff915 	stw	zero,-28(fp)
 90c2d64:	00000306 	br	90c2d74 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 90c2d68:	e13ffe17 	ldw	r4,-8(fp)
 90c2d6c:	90bcce40 	call	90bcce4 <if_getbynum>
 90c2d70:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 90c2d74:	00824374 	movhi	r2,2317
 90c2d78:	108c6004 	addi	r2,r2,12672
 90c2d7c:	10800017 	ldw	r2,0(r2)
 90c2d80:	1004c03a 	cmpne	r2,r2,zero
 90c2d84:	1000021e 	bne	r2,zero,90c2d90 <del_route+0x5c>
      return 0;
 90c2d88:	e03fff15 	stw	zero,-4(fp)
 90c2d8c:	00003406 	br	90c2e60 <del_route+0x12c>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c2d90:	00824374 	movhi	r2,2317
 90c2d94:	108c6004 	addi	r2,r2,12672
 90c2d98:	10800017 	ldw	r2,0(r2)
 90c2d9c:	e0bffb15 	stw	r2,-20(fp)
 90c2da0:	00002206 	br	90c2e2c <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 90c2da4:	e0bffb17 	ldw	r2,-20(fp)
 90c2da8:	10800617 	ldw	r2,24(r2)
 90c2dac:	1005003a 	cmpeq	r2,r2,zero
 90c2db0:	10001b1e 	bne	r2,zero,90c2e20 <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 90c2db4:	e0bff917 	ldw	r2,-28(fp)
 90c2db8:	1005003a 	cmpeq	r2,r2,zero
 90c2dbc:	1000041e 	bne	r2,zero,90c2dd0 <del_route+0x9c>
 90c2dc0:	e0bffb17 	ldw	r2,-20(fp)
 90c2dc4:	10c00e17 	ldw	r3,56(r2)
 90c2dc8:	e0bff917 	ldw	r2,-28(fp)
 90c2dcc:	1880141e 	bne	r3,r2,90c2e20 <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 90c2dd0:	e0bffb17 	ldw	r2,-20(fp)
 90c2dd4:	10c00017 	ldw	r3,0(r2)
 90c2dd8:	e0bffd17 	ldw	r2,-12(fp)
 90c2ddc:	1888703a 	and	r4,r3,r2
 90c2de0:	e0fffc17 	ldw	r3,-16(fp)
 90c2de4:	e0bffd17 	ldw	r2,-12(fp)
 90c2de8:	1884703a 	and	r2,r3,r2
 90c2dec:	2080081e 	bne	r4,r2,90c2e10 <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 90c2df0:	e0bffb17 	ldw	r2,-20(fp)
 90c2df4:	1009883a 	mov	r4,r2
 90c2df8:	01800f04 	movi	r6,60
 90c2dfc:	000b883a 	mov	r5,zero
 90c2e00:	90823f80 	call	90823f8 <memset>
         retval++;
 90c2e04:	e0bffa17 	ldw	r2,-24(fp)
 90c2e08:	10800044 	addi	r2,r2,1
 90c2e0c:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 90c2e10:	d0e0d017 	ldw	r3,-31936(gp)
 90c2e14:	e0bffb17 	ldw	r2,-20(fp)
 90c2e18:	1880011e 	bne	r3,r2,90c2e20 <del_route+0xec>
         cachedRoute = NULL;
 90c2e1c:	d020d015 	stw	zero,-31936(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c2e20:	e0bffb17 	ldw	r2,-20(fp)
 90c2e24:	10800f04 	addi	r2,r2,60
 90c2e28:	e0bffb15 	stw	r2,-20(fp)
 90c2e2c:	00824374 	movhi	r2,2317
 90c2e30:	108beb04 	addi	r2,r2,12204
 90c2e34:	10800017 	ldw	r2,0(r2)
 90c2e38:	10800f24 	muli	r2,r2,60
 90c2e3c:	1007883a 	mov	r3,r2
 90c2e40:	00824374 	movhi	r2,2317
 90c2e44:	108c6004 	addi	r2,r2,12672
 90c2e48:	10800017 	ldw	r2,0(r2)
 90c2e4c:	1887883a 	add	r3,r3,r2
 90c2e50:	e0bffb17 	ldw	r2,-20(fp)
 90c2e54:	10ffd336 	bltu	r2,r3,90c2da4 <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 90c2e58:	e0bffa17 	ldw	r2,-24(fp)
 90c2e5c:	e0bfff15 	stw	r2,-4(fp)
 90c2e60:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2e64:	e037883a 	mov	sp,fp
 90c2e68:	dfc00117 	ldw	ra,4(sp)
 90c2e6c:	df000017 	ldw	fp,0(sp)
 90c2e70:	dec00204 	addi	sp,sp,8
 90c2e74:	f800283a 	ret

090c2e78 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 90c2e78:	deffec04 	addi	sp,sp,-80
 90c2e7c:	dfc01315 	stw	ra,76(sp)
 90c2e80:	df001215 	stw	fp,72(sp)
 90c2e84:	df001204 	addi	fp,sp,72
 90c2e88:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 90c2e8c:	e0bffe17 	ldw	r2,-8(fp)
 90c2e90:	10800317 	ldw	r2,12(r2)
 90c2e94:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 90c2e98:	e0bffa17 	ldw	r2,-24(fp)
 90c2e9c:	10800003 	ldbu	r2,0(r2)
 90c2ea0:	10803fcc 	andi	r2,r2,255
 90c2ea4:	108003cc 	andi	r2,r2,15
 90c2ea8:	1085883a 	add	r2,r2,r2
 90c2eac:	1085883a 	add	r2,r2,r2
 90c2eb0:	1007883a 	mov	r3,r2
 90c2eb4:	e0bffa17 	ldw	r2,-24(fp)
 90c2eb8:	1885883a 	add	r2,r3,r2
 90c2ebc:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 90c2ec0:	e0bff917 	ldw	r2,-28(fp)
 90c2ec4:	1080010b 	ldhu	r2,4(r2)
 90c2ec8:	10bfffcc 	andi	r2,r2,65535
 90c2ecc:	1004d23a 	srli	r2,r2,8
 90c2ed0:	10bfffcc 	andi	r2,r2,65535
 90c2ed4:	10c03fcc 	andi	r3,r2,255
 90c2ed8:	e0bff917 	ldw	r2,-28(fp)
 90c2edc:	1080010b 	ldhu	r2,4(r2)
 90c2ee0:	10bfffcc 	andi	r2,r2,65535
 90c2ee4:	1004923a 	slli	r2,r2,8
 90c2ee8:	10bfc00c 	andi	r2,r2,65280
 90c2eec:	1884b03a 	or	r2,r3,r2
 90c2ef0:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 90c2ef4:	e0bffe17 	ldw	r2,-8(fp)
 90c2ef8:	10c00417 	ldw	r3,16(r2)
 90c2efc:	e0bff617 	ldw	r2,-40(fp)
 90c2f00:	18802a2e 	bgeu	r3,r2,90c2fac <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c2f04:	00824374 	movhi	r2,2317
 90c2f08:	108c1d04 	addi	r2,r2,12404
 90c2f0c:	10800017 	ldw	r2,0(r2)
 90c2f10:	1081000c 	andi	r2,r2,1024
 90c2f14:	1005003a 	cmpeq	r2,r2,zero
 90c2f18:	1000181e 	bne	r2,zero,90c2f7c <udpdemux+0x104>
 90c2f1c:	00824374 	movhi	r2,2317
 90c2f20:	108c1d04 	addi	r2,r2,12404
 90c2f24:	10800017 	ldw	r2,0(r2)
 90c2f28:	1080400c 	andi	r2,r2,256
 90c2f2c:	1005003a 	cmpeq	r2,r2,zero
 90c2f30:	1000121e 	bne	r2,zero,90c2f7c <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 90c2f34:	e0bffe17 	ldw	r2,-8(fp)
 90c2f38:	11400417 	ldw	r5,16(r2)
 90c2f3c:	e0bff917 	ldw	r2,-28(fp)
 90c2f40:	1080010b 	ldhu	r2,4(r2)
 90c2f44:	10bfffcc 	andi	r2,r2,65535
 90c2f48:	1004d23a 	srli	r2,r2,8
 90c2f4c:	10bfffcc 	andi	r2,r2,65535
 90c2f50:	10c03fcc 	andi	r3,r2,255
 90c2f54:	e0bff917 	ldw	r2,-28(fp)
 90c2f58:	1080010b 	ldhu	r2,4(r2)
 90c2f5c:	10bfffcc 	andi	r2,r2,65535
 90c2f60:	1004923a 	slli	r2,r2,8
 90c2f64:	10bfc00c 	andi	r2,r2,65280
 90c2f68:	1884b03a 	or	r2,r3,r2
 90c2f6c:	11800204 	addi	r6,r2,8
 90c2f70:	01024374 	movhi	r4,2317
 90c2f74:	21017f04 	addi	r4,r4,1532
 90c2f78:	90825100 	call	9082510 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 90c2f7c:	008243b4 	movhi	r2,2318
 90c2f80:	10b67e04 	addi	r2,r2,-9736
 90c2f84:	10800217 	ldw	r2,8(r2)
 90c2f88:	10c00044 	addi	r3,r2,1
 90c2f8c:	008243b4 	movhi	r2,2318
 90c2f90:	10b67e04 	addi	r2,r2,-9736
 90c2f94:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 90c2f98:	e13ffe17 	ldw	r4,-8(fp)
 90c2f9c:	90c3c740 	call	90c3c74 <udp_free>
      return ENP_BAD_HEADER;
 90c2fa0:	00bff804 	movi	r2,-32
 90c2fa4:	e0bfff15 	stw	r2,-4(fp)
 90c2fa8:	0001c306 	br	90c36b8 <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 90c2fac:	e0bff917 	ldw	r2,-28(fp)
 90c2fb0:	1080018b 	ldhu	r2,6(r2)
 90c2fb4:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 90c2fb8:	e0bff78b 	ldhu	r2,-34(fp)
 90c2fbc:	1005003a 	cmpeq	r2,r2,zero
 90c2fc0:	1000631e 	bne	r2,zero,90c3150 <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 90c2fc4:	e0bff617 	ldw	r2,-40(fp)
 90c2fc8:	1080004c 	andi	r2,r2,1
 90c2fcc:	10803fcc 	andi	r2,r2,255
 90c2fd0:	1005003a 	cmpeq	r2,r2,zero
 90c2fd4:	1000041e 	bne	r2,zero,90c2fe8 <udpdemux+0x170>
 90c2fd8:	e0bff917 	ldw	r2,-28(fp)
 90c2fdc:	e0fff617 	ldw	r3,-40(fp)
 90c2fe0:	10c5883a 	add	r2,r2,r3
 90c2fe4:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 90c2fe8:	e0bffe17 	ldw	r2,-8(fp)
 90c2fec:	10800717 	ldw	r2,28(r2)
 90c2ff0:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 90c2ff4:	e0bffa17 	ldw	r2,-24(fp)
 90c2ff8:	10800417 	ldw	r2,16(r2)
 90c2ffc:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 90c3000:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 90c3004:	00800444 	movi	r2,17
 90c3008:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 90c300c:	e0bff917 	ldw	r2,-28(fp)
 90c3010:	1080010b 	ldhu	r2,4(r2)
 90c3014:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 90c3018:	e13ffb04 	addi	r4,fp,-20
 90c301c:	01400184 	movi	r5,6
 90c3020:	90a3f040 	call	90a3f04 <cksum>
 90c3024:	1007883a 	mov	r3,r2
 90c3028:	e0bff917 	ldw	r2,-28(fp)
 90c302c:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 90c3030:	e0bff617 	ldw	r2,-40(fp)
 90c3034:	10800044 	addi	r2,r2,1
 90c3038:	100ad07a 	srli	r5,r2,1
 90c303c:	e13ff917 	ldw	r4,-28(fp)
 90c3040:	90a3f040 	call	90a3f04 <cksum>
 90c3044:	0084303a 	nor	r2,zero,r2
 90c3048:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 90c304c:	e0bff70b 	ldhu	r2,-36(fp)
 90c3050:	1004c03a 	cmpne	r2,r2,zero
 90c3054:	1000021e 	bne	r2,zero,90c3060 <udpdemux+0x1e8>
         xsum = 0xffff;
 90c3058:	00bfffc4 	movi	r2,-1
 90c305c:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 90c3060:	e0fff917 	ldw	r3,-28(fp)
 90c3064:	e0bff78b 	ldhu	r2,-34(fp)
 90c3068:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 90c306c:	e0fff70b 	ldhu	r3,-36(fp)
 90c3070:	e0bff78b 	ldhu	r2,-34(fp)
 90c3074:	18803626 	beq	r3,r2,90c3150 <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c3078:	00824374 	movhi	r2,2317
 90c307c:	108c1d04 	addi	r2,r2,12404
 90c3080:	10800017 	ldw	r2,0(r2)
 90c3084:	1081000c 	andi	r2,r2,1024
 90c3088:	1005003a 	cmpeq	r2,r2,zero
 90c308c:	1000241e 	bne	r2,zero,90c3120 <udpdemux+0x2a8>
 90c3090:	00824374 	movhi	r2,2317
 90c3094:	108c1d04 	addi	r2,r2,12404
 90c3098:	10800017 	ldw	r2,0(r2)
 90c309c:	1080400c 	andi	r2,r2,256
 90c30a0:	1005003a 	cmpeq	r2,r2,zero
 90c30a4:	10001e1e 	bne	r2,zero,90c3120 <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 90c30a8:	e17ff78b 	ldhu	r5,-34(fp)
 90c30ac:	e1bff70b 	ldhu	r6,-36(fp)
 90c30b0:	e0bffe17 	ldw	r2,-8(fp)
 90c30b4:	10800717 	ldw	r2,28(r2)
 90c30b8:	11c03fcc 	andi	r7,r2,255
 90c30bc:	e0bffe17 	ldw	r2,-8(fp)
 90c30c0:	10800717 	ldw	r2,28(r2)
 90c30c4:	1004d23a 	srli	r2,r2,8
 90c30c8:	11003fcc 	andi	r4,r2,255
 90c30cc:	e0bffe17 	ldw	r2,-8(fp)
 90c30d0:	10800717 	ldw	r2,28(r2)
 90c30d4:	1004d43a 	srli	r2,r2,16
 90c30d8:	10c03fcc 	andi	r3,r2,255
 90c30dc:	e0bffe17 	ldw	r2,-8(fp)
 90c30e0:	10800717 	ldw	r2,28(r2)
 90c30e4:	1004d63a 	srli	r2,r2,24
 90c30e8:	d9000015 	stw	r4,0(sp)
 90c30ec:	d8c00115 	stw	r3,4(sp)
 90c30f0:	d8800215 	stw	r2,8(sp)
 90c30f4:	01024374 	movhi	r4,2317
 90c30f8:	21018904 	addi	r4,r4,1572
 90c30fc:	90825100 	call	9082510 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 90c3100:	00824374 	movhi	r2,2317
 90c3104:	108c1d04 	addi	r2,r2,12404
 90c3108:	10800017 	ldw	r2,0(r2)
 90c310c:	1080008c 	andi	r2,r2,2
 90c3110:	1005003a 	cmpeq	r2,r2,zero
 90c3114:	1000021e 	bne	r2,zero,90c3120 <udpdemux+0x2a8>
               ip_dump(p);
 90c3118:	e13ffe17 	ldw	r4,-8(fp)
 90c311c:	90bebcc0 	call	90bebcc <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 90c3120:	008243b4 	movhi	r2,2318
 90c3124:	10b67e04 	addi	r2,r2,-9736
 90c3128:	10800217 	ldw	r2,8(r2)
 90c312c:	10c00044 	addi	r3,r2,1
 90c3130:	008243b4 	movhi	r2,2318
 90c3134:	10b67e04 	addi	r2,r2,-9736
 90c3138:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 90c313c:	e13ffe17 	ldw	r4,-8(fp)
 90c3140:	90c3c740 	call	90c3c74 <udp_free>
         return ENP_BAD_HEADER;
 90c3144:	00bff804 	movi	r2,-32
 90c3148:	e0bfff15 	stw	r2,-4(fp)
 90c314c:	00015a06 	br	90c36b8 <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c3150:	e13ff917 	ldw	r4,-28(fp)
 90c3154:	90c39880 	call	90c3988 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 90c3158:	e0bffa17 	ldw	r2,-24(fp)
 90c315c:	10800003 	ldbu	r2,0(r2)
 90c3160:	10803fcc 	andi	r2,r2,255
 90c3164:	108003cc 	andi	r2,r2,15
 90c3168:	1085883a 	add	r2,r2,r2
 90c316c:	1085883a 	add	r2,r2,r2
 90c3170:	10800204 	addi	r2,r2,8
 90c3174:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 90c3178:	e0bffe17 	ldw	r2,-8(fp)
 90c317c:	10c00417 	ldw	r3,16(r2)
 90c3180:	e0bff517 	ldw	r2,-44(fp)
 90c3184:	1887c83a 	sub	r3,r3,r2
 90c3188:	e0bffe17 	ldw	r2,-8(fp)
 90c318c:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 90c3190:	e0bffe17 	ldw	r2,-8(fp)
 90c3194:	10c00317 	ldw	r3,12(r2)
 90c3198:	e0bff517 	ldw	r2,-44(fp)
 90c319c:	1887883a 	add	r3,r3,r2
 90c31a0:	e0bffe17 	ldw	r2,-8(fp)
 90c31a4:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c31a8:	00824374 	movhi	r2,2317
 90c31ac:	108c1d04 	addi	r2,r2,12404
 90c31b0:	10800017 	ldw	r2,0(r2)
 90c31b4:	1081000c 	andi	r2,r2,1024
 90c31b8:	1005003a 	cmpeq	r2,r2,zero
 90c31bc:	1000221e 	bne	r2,zero,90c3248 <udpdemux+0x3d0>
 90c31c0:	00824374 	movhi	r2,2317
 90c31c4:	108c1d04 	addi	r2,r2,12404
 90c31c8:	10800017 	ldw	r2,0(r2)
 90c31cc:	1080400c 	andi	r2,r2,256
 90c31d0:	1005003a 	cmpeq	r2,r2,zero
 90c31d4:	10001c1e 	bne	r2,zero,90c3248 <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 90c31d8:	e0bffe17 	ldw	r2,-8(fp)
 90c31dc:	10800717 	ldw	r2,28(r2)
 90c31e0:	11803fcc 	andi	r6,r2,255
 90c31e4:	e0bffe17 	ldw	r2,-8(fp)
 90c31e8:	10800717 	ldw	r2,28(r2)
 90c31ec:	1004d23a 	srli	r2,r2,8
 90c31f0:	11c03fcc 	andi	r7,r2,255
 90c31f4:	e0bffe17 	ldw	r2,-8(fp)
 90c31f8:	10800717 	ldw	r2,28(r2)
 90c31fc:	1004d43a 	srli	r2,r2,16
 90c3200:	10c03fcc 	andi	r3,r2,255
 90c3204:	e0bffe17 	ldw	r2,-8(fp)
 90c3208:	10800717 	ldw	r2,28(r2)
 90c320c:	1008d63a 	srli	r4,r2,24
 90c3210:	e0bff917 	ldw	r2,-28(fp)
 90c3214:	1080000b 	ldhu	r2,0(r2)
 90c3218:	117fffcc 	andi	r5,r2,65535
 90c321c:	e0bff917 	ldw	r2,-28(fp)
 90c3220:	1080008b 	ldhu	r2,2(r2)
 90c3224:	10bfffcc 	andi	r2,r2,65535
 90c3228:	d8c00015 	stw	r3,0(sp)
 90c322c:	d9000115 	stw	r4,4(sp)
 90c3230:	d9400215 	stw	r5,8(sp)
 90c3234:	d8800315 	stw	r2,12(sp)
 90c3238:	01024374 	movhi	r4,2317
 90c323c:	21019704 	addi	r4,r4,1628
 90c3240:	e17ff617 	ldw	r5,-40(fp)
 90c3244:	90825100 	call	9082510 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 90c3248:	00824374 	movhi	r2,2317
 90c324c:	108c3604 	addi	r2,r2,12504
 90c3250:	10800017 	ldw	r2,0(r2)
 90c3254:	e0bff815 	stw	r2,-32(fp)
 90c3258:	0000b106 	br	90c3520 <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 90c325c:	e0bff817 	ldw	r2,-32(fp)
 90c3260:	1080018b 	ldhu	r2,6(r2)
 90c3264:	10bfffcc 	andi	r2,r2,65535
 90c3268:	1005003a 	cmpeq	r2,r2,zero
 90c326c:	1000071e 	bne	r2,zero,90c328c <udpdemux+0x414>
 90c3270:	e0bff817 	ldw	r2,-32(fp)
 90c3274:	10c0018b 	ldhu	r3,6(r2)
 90c3278:	e0bff917 	ldw	r2,-28(fp)
 90c327c:	1080008b 	ldhu	r2,2(r2)
 90c3280:	18ffffcc 	andi	r3,r3,65535
 90c3284:	10bfffcc 	andi	r2,r2,65535
 90c3288:	1880a21e 	bne	r3,r2,90c3514 <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 90c328c:	e0bff817 	ldw	r2,-32(fp)
 90c3290:	1080020b 	ldhu	r2,8(r2)
 90c3294:	10bfffcc 	andi	r2,r2,65535
 90c3298:	1005003a 	cmpeq	r2,r2,zero
 90c329c:	1000071e 	bne	r2,zero,90c32bc <udpdemux+0x444>
 90c32a0:	e0bff817 	ldw	r2,-32(fp)
 90c32a4:	10c0020b 	ldhu	r3,8(r2)
 90c32a8:	e0bff917 	ldw	r2,-28(fp)
 90c32ac:	1080000b 	ldhu	r2,0(r2)
 90c32b0:	18ffffcc 	andi	r3,r3,65535
 90c32b4:	10bfffcc 	andi	r2,r2,65535
 90c32b8:	1880961e 	bne	r3,r2,90c3514 <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 90c32bc:	e0bff817 	ldw	r2,-32(fp)
 90c32c0:	10800417 	ldw	r2,16(r2)
 90c32c4:	1005003a 	cmpeq	r2,r2,zero
 90c32c8:	1000051e 	bne	r2,zero,90c32e0 <udpdemux+0x468>
 90c32cc:	e0bff817 	ldw	r2,-32(fp)
 90c32d0:	10c00417 	ldw	r3,16(r2)
 90c32d4:	e0bffe17 	ldw	r2,-8(fp)
 90c32d8:	10800717 	ldw	r2,28(r2)
 90c32dc:	18808d1e 	bne	r3,r2,90c3514 <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 90c32e0:	e0bffa17 	ldw	r2,-24(fp)
 90c32e4:	10800417 	ldw	r2,16(r2)
 90c32e8:	1004d63a 	srli	r2,r2,24
 90c32ec:	10c03fcc 	andi	r3,r2,255
 90c32f0:	e0bffa17 	ldw	r2,-24(fp)
 90c32f4:	10800417 	ldw	r2,16(r2)
 90c32f8:	1004d23a 	srli	r2,r2,8
 90c32fc:	10bfc00c 	andi	r2,r2,65280
 90c3300:	1886b03a 	or	r3,r3,r2
 90c3304:	e0bffa17 	ldw	r2,-24(fp)
 90c3308:	10800417 	ldw	r2,16(r2)
 90c330c:	10bfc00c 	andi	r2,r2,65280
 90c3310:	1004923a 	slli	r2,r2,8
 90c3314:	1886b03a 	or	r3,r3,r2
 90c3318:	e0bffa17 	ldw	r2,-24(fp)
 90c331c:	10800417 	ldw	r2,16(r2)
 90c3320:	10803fcc 	andi	r2,r2,255
 90c3324:	1004963a 	slli	r2,r2,24
 90c3328:	1884b03a 	or	r2,r3,r2
 90c332c:	10fc002c 	andhi	r3,r2,61440
 90c3330:	00b80034 	movhi	r2,57344
 90c3334:	1880301e 	bne	r3,r2,90c33f8 <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 90c3338:	e0bff817 	ldw	r2,-32(fp)
 90c333c:	10800617 	ldw	r2,24(r2)
 90c3340:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 90c3344:	e0bff817 	ldw	r2,-32(fp)
 90c3348:	10c00517 	ldw	r3,20(r2)
 90c334c:	008242f4 	movhi	r2,2315
 90c3350:	109f3b04 	addi	r2,r2,31980
 90c3354:	1880281e 	bne	r3,r2,90c33f8 <udpdemux+0x580>
 90c3358:	e0bff417 	ldw	r2,-48(fp)
 90c335c:	10800317 	ldw	r2,12(r2)
 90c3360:	1005003a 	cmpeq	r2,r2,zero
 90c3364:	1000241e 	bne	r2,zero,90c33f8 <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 90c3368:	e0bff417 	ldw	r2,-48(fp)
 90c336c:	10800317 	ldw	r2,12(r2)
 90c3370:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 90c3374:	e03ff30d 	sth	zero,-52(fp)
 90c3378:	00001906 	br	90c33e0 <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 90c337c:	e0bff30b 	ldhu	r2,-52(fp)
 90c3380:	e0fff217 	ldw	r3,-56(fp)
 90c3384:	1085883a 	add	r2,r2,r2
 90c3388:	1085883a 	add	r2,r2,r2
 90c338c:	10c5883a 	add	r2,r2,r3
 90c3390:	10800204 	addi	r2,r2,8
 90c3394:	10800017 	ldw	r2,0(r2)
 90c3398:	10c00117 	ldw	r3,4(r2)
 90c339c:	e0bffe17 	ldw	r2,-8(fp)
 90c33a0:	10800617 	ldw	r2,24(r2)
 90c33a4:	18800b1e 	bne	r3,r2,90c33d4 <udpdemux+0x55c>
 90c33a8:	e0bff30b 	ldhu	r2,-52(fp)
 90c33ac:	e0fff217 	ldw	r3,-56(fp)
 90c33b0:	1085883a 	add	r2,r2,r2
 90c33b4:	1085883a 	add	r2,r2,r2
 90c33b8:	10c5883a 	add	r2,r2,r3
 90c33bc:	10800204 	addi	r2,r2,8
 90c33c0:	10800017 	ldw	r2,0(r2)
 90c33c4:	10c00017 	ldw	r3,0(r2)
 90c33c8:	e0bffa17 	ldw	r2,-24(fp)
 90c33cc:	10800417 	ldw	r2,16(r2)
 90c33d0:	18800926 	beq	r3,r2,90c33f8 <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 90c33d4:	e0bff30b 	ldhu	r2,-52(fp)
 90c33d8:	10800044 	addi	r2,r2,1
 90c33dc:	e0bff30d 	sth	r2,-52(fp)
 90c33e0:	e0bff217 	ldw	r2,-56(fp)
 90c33e4:	1080018b 	ldhu	r2,6(r2)
 90c33e8:	10ffffcc 	andi	r3,r2,65535
 90c33ec:	e0bff30b 	ldhu	r2,-52(fp)
 90c33f0:	10ffe236 	bltu	r2,r3,90c337c <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 90c33f4:	00004706 	br	90c3514 <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 90c33f8:	e0bffa17 	ldw	r2,-24(fp)
 90c33fc:	10800417 	ldw	r2,16(r2)
 90c3400:	1004d63a 	srli	r2,r2,24
 90c3404:	10c03fcc 	andi	r3,r2,255
 90c3408:	e0bffa17 	ldw	r2,-24(fp)
 90c340c:	10800417 	ldw	r2,16(r2)
 90c3410:	1004d23a 	srli	r2,r2,8
 90c3414:	10bfc00c 	andi	r2,r2,65280
 90c3418:	1886b03a 	or	r3,r3,r2
 90c341c:	e0bffa17 	ldw	r2,-24(fp)
 90c3420:	10800417 	ldw	r2,16(r2)
 90c3424:	10bfc00c 	andi	r2,r2,65280
 90c3428:	1004923a 	slli	r2,r2,8
 90c342c:	1886b03a 	or	r3,r3,r2
 90c3430:	e0bffa17 	ldw	r2,-24(fp)
 90c3434:	10800417 	ldw	r2,16(r2)
 90c3438:	10803fcc 	andi	r2,r2,255
 90c343c:	1004963a 	slli	r2,r2,24
 90c3440:	1884b03a 	or	r2,r3,r2
 90c3444:	10fc002c 	andhi	r3,r2,61440
 90c3448:	00b80034 	movhi	r2,57344
 90c344c:	18800926 	beq	r3,r2,90c3474 <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 90c3450:	e0bff817 	ldw	r2,-32(fp)
 90c3454:	10800317 	ldw	r2,12(r2)
 90c3458:	1005003a 	cmpeq	r2,r2,zero
 90c345c:	1000051e 	bne	r2,zero,90c3474 <udpdemux+0x5fc>
 90c3460:	e0bff817 	ldw	r2,-32(fp)
 90c3464:	10c00317 	ldw	r3,12(r2)
 90c3468:	e0bffa17 	ldw	r2,-24(fp)
 90c346c:	10800417 	ldw	r2,16(r2)
 90c3470:	1880281e 	bne	r3,r2,90c3514 <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 90c3474:	008243b4 	movhi	r2,2318
 90c3478:	10b67e04 	addi	r2,r2,-9736
 90c347c:	10800017 	ldw	r2,0(r2)
 90c3480:	10c00044 	addi	r3,r2,1
 90c3484:	008243b4 	movhi	r2,2318
 90c3488:	10b67e04 	addi	r2,r2,-9736
 90c348c:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 90c3490:	e0bff817 	ldw	r2,-32(fp)
 90c3494:	10800517 	ldw	r2,20(r2)
 90c3498:	1005003a 	cmpeq	r2,r2,zero
 90c349c:	10000c1e 	bne	r2,zero,90c34d0 <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 90c34a0:	0009883a 	mov	r4,zero
 90c34a4:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 90c34a8:	e0bff817 	ldw	r2,-32(fp)
 90c34ac:	10c00517 	ldw	r3,20(r2)
 90c34b0:	e0bff817 	ldw	r2,-32(fp)
 90c34b4:	11400617 	ldw	r5,24(r2)
 90c34b8:	e13ffe17 	ldw	r4,-8(fp)
 90c34bc:	183ee83a 	callr	r3
 90c34c0:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90c34c4:	0009883a 	mov	r4,zero
 90c34c8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
 90c34cc:	00000206 	br	90c34d8 <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 90c34d0:	00bffd44 	movi	r2,-11
 90c34d4:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 90c34d8:	e0bff517 	ldw	r2,-44(fp)
 90c34dc:	1005003a 	cmpeq	r2,r2,zero
 90c34e0:	1000091e 	bne	r2,zero,90c3508 <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 90c34e4:	008243b4 	movhi	r2,2318
 90c34e8:	10b67e04 	addi	r2,r2,-9736
 90c34ec:	10800217 	ldw	r2,8(r2)
 90c34f0:	10c00044 	addi	r3,r2,1
 90c34f4:	008243b4 	movhi	r2,2318
 90c34f8:	10b67e04 	addi	r2,r2,-9736
 90c34fc:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 90c3500:	e13ffe17 	ldw	r4,-8(fp)
 90c3504:	90c3c740 	call	90c3c74 <udp_free>
      }

      return(e);
 90c3508:	e0bff517 	ldw	r2,-44(fp)
 90c350c:	e0bfff15 	stw	r2,-4(fp)
 90c3510:	00006906 	br	90c36b8 <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 90c3514:	e0bff817 	ldw	r2,-32(fp)
 90c3518:	10800017 	ldw	r2,0(r2)
 90c351c:	e0bff815 	stw	r2,-32(fp)
 90c3520:	e0bff817 	ldw	r2,-32(fp)
 90c3524:	1004c03a 	cmpne	r2,r2,zero
 90c3528:	103f4c1e 	bne	r2,zero,90c325c <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 90c352c:	e0bffa17 	ldw	r2,-24(fp)
 90c3530:	10800417 	ldw	r2,16(r2)
 90c3534:	10bfffe0 	cmpeqi	r2,r2,-1
 90c3538:	1000121e 	bne	r2,zero,90c3584 <udpdemux+0x70c>
 90c353c:	e0bffa17 	ldw	r2,-24(fp)
 90c3540:	10c00417 	ldw	r3,16(r2)
 90c3544:	e0bffe17 	ldw	r2,-8(fp)
 90c3548:	10800617 	ldw	r2,24(r2)
 90c354c:	10800e17 	ldw	r2,56(r2)
 90c3550:	18800c26 	beq	r3,r2,90c3584 <udpdemux+0x70c>
 90c3554:	e0bffa17 	ldw	r2,-24(fp)
 90c3558:	10c00417 	ldw	r3,16(r2)
 90c355c:	e0bffe17 	ldw	r2,-8(fp)
 90c3560:	10800617 	ldw	r2,24(r2)
 90c3564:	10800f17 	ldw	r2,60(r2)
 90c3568:	18800626 	beq	r3,r2,90c3584 <udpdemux+0x70c>
 90c356c:	e0bffa17 	ldw	r2,-24(fp)
 90c3570:	10c00417 	ldw	r3,16(r2)
 90c3574:	e0bffe17 	ldw	r2,-8(fp)
 90c3578:	10800617 	ldw	r2,24(r2)
 90c357c:	10801017 	ldw	r2,64(r2)
 90c3580:	18801b1e 	bne	r3,r2,90c35f0 <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c3584:	00824374 	movhi	r2,2317
 90c3588:	108c1d04 	addi	r2,r2,12404
 90c358c:	10800017 	ldw	r2,0(r2)
 90c3590:	1081000c 	andi	r2,r2,1024
 90c3594:	1005003a 	cmpeq	r2,r2,zero
 90c3598:	1000091e 	bne	r2,zero,90c35c0 <udpdemux+0x748>
 90c359c:	00824374 	movhi	r2,2317
 90c35a0:	108c1d04 	addi	r2,r2,12404
 90c35a4:	10800017 	ldw	r2,0(r2)
 90c35a8:	1080400c 	andi	r2,r2,256
 90c35ac:	1005003a 	cmpeq	r2,r2,zero
 90c35b0:	1000031e 	bne	r2,zero,90c35c0 <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 90c35b4:	01024374 	movhi	r4,2317
 90c35b8:	2101a104 	addi	r4,r4,1668
 90c35bc:	90828380 	call	9082838 <puts>
#endif
      udp_mib.udpInErrors++;
 90c35c0:	008243b4 	movhi	r2,2318
 90c35c4:	10b67e04 	addi	r2,r2,-9736
 90c35c8:	10800217 	ldw	r2,8(r2)
 90c35cc:	10c00044 	addi	r3,r2,1
 90c35d0:	008243b4 	movhi	r2,2318
 90c35d4:	10b67e04 	addi	r2,r2,-9736
 90c35d8:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 90c35dc:	e13ffe17 	ldw	r4,-8(fp)
 90c35e0:	90c3c740 	call	90c3c74 <udp_free>
      return ENP_NOT_MINE;
 90c35e4:	00800084 	movi	r2,2
 90c35e8:	e0bfff15 	stw	r2,-4(fp)
 90c35ec:	00003206 	br	90c36b8 <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c35f0:	00824374 	movhi	r2,2317
 90c35f4:	108c1d04 	addi	r2,r2,12404
 90c35f8:	10800017 	ldw	r2,0(r2)
 90c35fc:	1081000c 	andi	r2,r2,1024
 90c3600:	1005003a 	cmpeq	r2,r2,zero
 90c3604:	1000141e 	bne	r2,zero,90c3658 <udpdemux+0x7e0>
 90c3608:	00824374 	movhi	r2,2317
 90c360c:	108c1d04 	addi	r2,r2,12404
 90c3610:	10800017 	ldw	r2,0(r2)
 90c3614:	1080400c 	andi	r2,r2,256
 90c3618:	1005003a 	cmpeq	r2,r2,zero
 90c361c:	10000e1e 	bne	r2,zero,90c3658 <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 90c3620:	e0bff917 	ldw	r2,-28(fp)
 90c3624:	1080008b 	ldhu	r2,2(r2)
 90c3628:	117fffcc 	andi	r5,r2,65535
 90c362c:	01024374 	movhi	r4,2317
 90c3630:	2101a804 	addi	r4,r4,1696
 90c3634:	90825100 	call	9082510 <printf>
      if (NDEBUG & DUMP) 
 90c3638:	00824374 	movhi	r2,2317
 90c363c:	108c1d04 	addi	r2,r2,12404
 90c3640:	10800017 	ldw	r2,0(r2)
 90c3644:	1080008c 	andi	r2,r2,2
 90c3648:	1005003a 	cmpeq	r2,r2,zero
 90c364c:	1000021e 	bne	r2,zero,90c3658 <udpdemux+0x7e0>
         ip_dump(p);
 90c3650:	e13ffe17 	ldw	r4,-8(fp)
 90c3654:	90bebcc0 	call	90bebcc <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c3658:	e13ff917 	ldw	r4,-28(fp)
 90c365c:	90c39880 	call	90c3988 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 90c3660:	e0bffe17 	ldw	r2,-8(fp)
 90c3664:	11000717 	ldw	r4,28(r2)
 90c3668:	e0bffe17 	ldw	r2,-8(fp)
 90c366c:	10800617 	ldw	r2,24(r2)
 90c3670:	11400a17 	ldw	r5,40(r2)
 90c3674:	e0bffe17 	ldw	r2,-8(fp)
 90c3678:	10800617 	ldw	r2,24(r2)
 90c367c:	d8800015 	stw	r2,0(sp)
 90c3680:	e1bffa17 	ldw	r6,-24(fp)
 90c3684:	01c000c4 	movi	r7,3
 90c3688:	90c9dc00 	call	90c9dc0 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 90c368c:	008243b4 	movhi	r2,2318
 90c3690:	10b67e04 	addi	r2,r2,-9736
 90c3694:	10800117 	ldw	r2,4(r2)
 90c3698:	10c00044 	addi	r3,r2,1
 90c369c:	008243b4 	movhi	r2,2318
 90c36a0:	10b67e04 	addi	r2,r2,-9736
 90c36a4:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 90c36a8:	e13ffe17 	ldw	r4,-8(fp)
 90c36ac:	90c3c740 	call	90c3c74 <udp_free>
   return ENP_NOT_MINE;
 90c36b0:	00800084 	movi	r2,2
 90c36b4:	e0bfff15 	stw	r2,-4(fp)
 90c36b8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c36bc:	e037883a 	mov	sp,fp
 90c36c0:	dfc00117 	ldw	ra,4(sp)
 90c36c4:	df000017 	ldw	fp,0(sp)
 90c36c8:	dec00204 	addi	sp,sp,8
 90c36cc:	f800283a 	ret

090c36d0 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 90c36d0:	deffee04 	addi	sp,sp,-72
 90c36d4:	dfc01115 	stw	ra,68(sp)
 90c36d8:	df001015 	stw	fp,64(sp)
 90c36dc:	df001004 	addi	fp,sp,64
 90c36e0:	e1bffe15 	stw	r6,-8(fp)
 90c36e4:	e13ffc0d 	sth	r4,-16(fp)
 90c36e8:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 90c36ec:	00824374 	movhi	r2,2317
 90c36f0:	108c1d04 	addi	r2,r2,12404
 90c36f4:	10800017 	ldw	r2,0(r2)
 90c36f8:	1080410c 	andi	r2,r2,260
 90c36fc:	1005003a 	cmpeq	r2,r2,zero
 90c3700:	10001c1e 	bne	r2,zero,90c3774 <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 90c3704:	e0bffe17 	ldw	r2,-8(fp)
 90c3708:	11800417 	ldw	r6,16(r2)
 90c370c:	e1fffd0b 	ldhu	r7,-12(fp)
 90c3710:	e0bffe17 	ldw	r2,-8(fp)
 90c3714:	10800717 	ldw	r2,28(r2)
 90c3718:	12003fcc 	andi	r8,r2,255
 90c371c:	e0bffe17 	ldw	r2,-8(fp)
 90c3720:	10800717 	ldw	r2,28(r2)
 90c3724:	1004d23a 	srli	r2,r2,8
 90c3728:	11003fcc 	andi	r4,r2,255
 90c372c:	e0bffe17 	ldw	r2,-8(fp)
 90c3730:	10800717 	ldw	r2,28(r2)
 90c3734:	1004d43a 	srli	r2,r2,16
 90c3738:	11403fcc 	andi	r5,r2,255
 90c373c:	e0bffe17 	ldw	r2,-8(fp)
 90c3740:	10800717 	ldw	r2,28(r2)
 90c3744:	1004d63a 	srli	r2,r2,24
 90c3748:	e0fffc0b 	ldhu	r3,-16(fp)
 90c374c:	d9000015 	stw	r4,0(sp)
 90c3750:	d9400115 	stw	r5,4(sp)
 90c3754:	d8800215 	stw	r2,8(sp)
 90c3758:	d8c00315 	stw	r3,12(sp)
 90c375c:	01024374 	movhi	r4,2317
 90c3760:	2101af04 	addi	r4,r4,1724
 90c3764:	300b883a 	mov	r5,r6
 90c3768:	380d883a 	mov	r6,r7
 90c376c:	400f883a 	mov	r7,r8
 90c3770:	90825100 	call	9082510 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 90c3774:	0009883a 	mov	r4,zero
 90c3778:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 90c377c:	e0bffe17 	ldw	r2,-8(fp)
 90c3780:	10800317 	ldw	r2,12(r2)
 90c3784:	10fffe04 	addi	r3,r2,-8
 90c3788:	e0bffe17 	ldw	r2,-8(fp)
 90c378c:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 90c3790:	e0bffe17 	ldw	r2,-8(fp)
 90c3794:	10800317 	ldw	r2,12(r2)
 90c3798:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 90c379c:	e0bffe17 	ldw	r2,-8(fp)
 90c37a0:	10800417 	ldw	r2,16(r2)
 90c37a4:	10800204 	addi	r2,r2,8
 90c37a8:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 90c37ac:	e0fff617 	ldw	r3,-40(fp)
 90c37b0:	e0bffe17 	ldw	r2,-8(fp)
 90c37b4:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 90c37b8:	e0bff617 	ldw	r2,-40(fp)
 90c37bc:	1080004c 	andi	r2,r2,1
 90c37c0:	10803fcc 	andi	r2,r2,255
 90c37c4:	1005003a 	cmpeq	r2,r2,zero
 90c37c8:	1000041e 	bne	r2,zero,90c37dc <udp_send+0x10c>
 90c37cc:	e0fff817 	ldw	r3,-32(fp)
 90c37d0:	e0bff617 	ldw	r2,-40(fp)
 90c37d4:	1885883a 	add	r2,r3,r2
 90c37d8:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 90c37dc:	e0bff617 	ldw	r2,-40(fp)
 90c37e0:	1007883a 	mov	r3,r2
 90c37e4:	e0bff817 	ldw	r2,-32(fp)
 90c37e8:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 90c37ec:	e0fff817 	ldw	r3,-32(fp)
 90c37f0:	e0bffd0b 	ldhu	r2,-12(fp)
 90c37f4:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 90c37f8:	e0fff817 	ldw	r3,-32(fp)
 90c37fc:	e0bffc0b 	ldhu	r2,-16(fp)
 90c3800:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c3804:	e13ff817 	ldw	r4,-32(fp)
 90c3808:	90c39880 	call	90c3988 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 90c380c:	e0bffe17 	ldw	r2,-8(fp)
 90c3810:	10800717 	ldw	r2,28(r2)
 90c3814:	10bfffd8 	cmpnei	r2,r2,-1
 90c3818:	1000111e 	bne	r2,zero,90c3860 <udp_send+0x190>
   {
      if (!p->net)
 90c381c:	e0bffe17 	ldw	r2,-8(fp)
 90c3820:	10800617 	ldw	r2,24(r2)
 90c3824:	1004c03a 	cmpne	r2,r2,zero
 90c3828:	1000081e 	bne	r2,zero,90c384c <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 90c382c:	90a94880 	call	90a9488 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 90c3830:	e13ffe17 	ldw	r4,-8(fp)
 90c3834:	90c3c740 	call	90c3c74 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90c3838:	0009883a 	mov	r4,zero
 90c383c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 90c3840:	00bff784 	movi	r2,-34
 90c3844:	e0bfff15 	stw	r2,-4(fp)
 90c3848:	00004906 	br	90c3970 <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 90c384c:	e0bffe17 	ldw	r2,-8(fp)
 90c3850:	10800617 	ldw	r2,24(r2)
 90c3854:	10800a17 	ldw	r2,40(r2)
 90c3858:	e0bff415 	stw	r2,-48(fp)
 90c385c:	00000406 	br	90c3870 <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 90c3860:	e0bffe17 	ldw	r2,-8(fp)
 90c3864:	11000717 	ldw	r4,28(r2)
 90c3868:	90beb200 	call	90beb20 <ip_mymach>
 90c386c:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 90c3870:	e0bff417 	ldw	r2,-48(fp)
 90c3874:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 90c3878:	e0bffe17 	ldw	r2,-8(fp)
 90c387c:	10800717 	ldw	r2,28(r2)
 90c3880:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 90c3884:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 90c3888:	00800444 	movi	r2,17
 90c388c:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 90c3890:	e0bff817 	ldw	r2,-32(fp)
 90c3894:	1080010b 	ldhu	r2,4(r2)
 90c3898:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 90c389c:	e13ff904 	addi	r4,fp,-28
 90c38a0:	01400184 	movi	r5,6
 90c38a4:	90a3f040 	call	90a3f04 <cksum>
 90c38a8:	1007883a 	mov	r3,r2
 90c38ac:	e0bff817 	ldw	r2,-32(fp)
 90c38b0:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 90c38b4:	e0bff617 	ldw	r2,-40(fp)
 90c38b8:	10800044 	addi	r2,r2,1
 90c38bc:	1005d07a 	srai	r2,r2,1
 90c38c0:	100b883a 	mov	r5,r2
 90c38c4:	e13ff817 	ldw	r4,-32(fp)
 90c38c8:	90a3f040 	call	90a3f04 <cksum>
 90c38cc:	0084303a 	nor	r2,zero,r2
 90c38d0:	1007883a 	mov	r3,r2
 90c38d4:	e0bff817 	ldw	r2,-32(fp)
 90c38d8:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 90c38dc:	e0bff817 	ldw	r2,-32(fp)
 90c38e0:	1080018b 	ldhu	r2,6(r2)
 90c38e4:	10bfffcc 	andi	r2,r2,65535
 90c38e8:	1004c03a 	cmpne	r2,r2,zero
 90c38ec:	1000031e 	bne	r2,zero,90c38fc <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 90c38f0:	e0fff817 	ldw	r3,-32(fp)
 90c38f4:	00bfffc4 	movi	r2,-1
 90c38f8:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 90c38fc:	e0bffe17 	ldw	r2,-8(fp)
 90c3900:	10800317 	ldw	r2,12(r2)
 90c3904:	10bffb04 	addi	r2,r2,-20
 90c3908:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 90c390c:	e0fff717 	ldw	r3,-36(fp)
 90c3910:	e0bff417 	ldw	r2,-48(fp)
 90c3914:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 90c3918:	e0bffe17 	ldw	r2,-8(fp)
 90c391c:	10c00717 	ldw	r3,28(r2)
 90c3920:	e0bff717 	ldw	r2,-36(fp)
 90c3924:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 90c3928:	008243b4 	movhi	r2,2318
 90c392c:	10b67e04 	addi	r2,r2,-9736
 90c3930:	10800317 	ldw	r2,12(r2)
 90c3934:	10c00044 	addi	r3,r2,1
 90c3938:	008243b4 	movhi	r2,2318
 90c393c:	10b67e04 	addi	r2,r2,-9736
 90c3940:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 90c3944:	e0fff617 	ldw	r3,-40(fp)
 90c3948:	e0bffe17 	ldw	r2,-8(fp)
 90c394c:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 90c3950:	01000444 	movi	r4,17
 90c3954:	e17ffe17 	ldw	r5,-8(fp)
 90c3958:	90bd99c0 	call	90bd99c <ip_write>
 90c395c:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c3960:	0009883a 	mov	r4,zero
 90c3964:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   return e;
 90c3968:	e0bff517 	ldw	r2,-44(fp)
 90c396c:	e0bfff15 	stw	r2,-4(fp)
 90c3970:	e0bfff17 	ldw	r2,-4(fp)
}
 90c3974:	e037883a 	mov	sp,fp
 90c3978:	dfc00117 	ldw	ra,4(sp)
 90c397c:	df000017 	ldw	fp,0(sp)
 90c3980:	dec00204 	addi	sp,sp,8
 90c3984:	f800283a 	ret

090c3988 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 90c3988:	defffe04 	addi	sp,sp,-8
 90c398c:	df000115 	stw	fp,4(sp)
 90c3990:	df000104 	addi	fp,sp,4
 90c3994:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 90c3998:	e0bfff17 	ldw	r2,-4(fp)
 90c399c:	1080000b 	ldhu	r2,0(r2)
 90c39a0:	10bfffcc 	andi	r2,r2,65535
 90c39a4:	1004d23a 	srli	r2,r2,8
 90c39a8:	10803fcc 	andi	r2,r2,255
 90c39ac:	1009883a 	mov	r4,r2
 90c39b0:	e0bfff17 	ldw	r2,-4(fp)
 90c39b4:	1080000b 	ldhu	r2,0(r2)
 90c39b8:	10bfffcc 	andi	r2,r2,65535
 90c39bc:	1004923a 	slli	r2,r2,8
 90c39c0:	1007883a 	mov	r3,r2
 90c39c4:	00bfc004 	movi	r2,-256
 90c39c8:	1884703a 	and	r2,r3,r2
 90c39cc:	2084b03a 	or	r2,r4,r2
 90c39d0:	1007883a 	mov	r3,r2
 90c39d4:	e0bfff17 	ldw	r2,-4(fp)
 90c39d8:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 90c39dc:	e0bfff17 	ldw	r2,-4(fp)
 90c39e0:	1080008b 	ldhu	r2,2(r2)
 90c39e4:	10bfffcc 	andi	r2,r2,65535
 90c39e8:	1004d23a 	srli	r2,r2,8
 90c39ec:	10803fcc 	andi	r2,r2,255
 90c39f0:	1009883a 	mov	r4,r2
 90c39f4:	e0bfff17 	ldw	r2,-4(fp)
 90c39f8:	1080008b 	ldhu	r2,2(r2)
 90c39fc:	10bfffcc 	andi	r2,r2,65535
 90c3a00:	1004923a 	slli	r2,r2,8
 90c3a04:	1007883a 	mov	r3,r2
 90c3a08:	00bfc004 	movi	r2,-256
 90c3a0c:	1884703a 	and	r2,r3,r2
 90c3a10:	2084b03a 	or	r2,r4,r2
 90c3a14:	1007883a 	mov	r3,r2
 90c3a18:	e0bfff17 	ldw	r2,-4(fp)
 90c3a1c:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 90c3a20:	e0bfff17 	ldw	r2,-4(fp)
 90c3a24:	1080010b 	ldhu	r2,4(r2)
 90c3a28:	10bfffcc 	andi	r2,r2,65535
 90c3a2c:	1004d23a 	srli	r2,r2,8
 90c3a30:	10803fcc 	andi	r2,r2,255
 90c3a34:	1009883a 	mov	r4,r2
 90c3a38:	e0bfff17 	ldw	r2,-4(fp)
 90c3a3c:	1080010b 	ldhu	r2,4(r2)
 90c3a40:	10bfffcc 	andi	r2,r2,65535
 90c3a44:	1004923a 	slli	r2,r2,8
 90c3a48:	1007883a 	mov	r3,r2
 90c3a4c:	00bfc004 	movi	r2,-256
 90c3a50:	1884703a 	and	r2,r3,r2
 90c3a54:	2084b03a 	or	r2,r4,r2
 90c3a58:	1007883a 	mov	r3,r2
 90c3a5c:	e0bfff17 	ldw	r2,-4(fp)
 90c3a60:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 90c3a64:	e0bfff17 	ldw	r2,-4(fp)
 90c3a68:	1080018b 	ldhu	r2,6(r2)
 90c3a6c:	10bfffcc 	andi	r2,r2,65535
 90c3a70:	1004d23a 	srli	r2,r2,8
 90c3a74:	10803fcc 	andi	r2,r2,255
 90c3a78:	1009883a 	mov	r4,r2
 90c3a7c:	e0bfff17 	ldw	r2,-4(fp)
 90c3a80:	1080018b 	ldhu	r2,6(r2)
 90c3a84:	10bfffcc 	andi	r2,r2,65535
 90c3a88:	1004923a 	slli	r2,r2,8
 90c3a8c:	1007883a 	mov	r3,r2
 90c3a90:	00bfc004 	movi	r2,-256
 90c3a94:	1884703a 	and	r2,r3,r2
 90c3a98:	2084b03a 	or	r2,r4,r2
 90c3a9c:	1007883a 	mov	r3,r2
 90c3aa0:	e0bfff17 	ldw	r2,-4(fp)
 90c3aa4:	10c0018d 	sth	r3,6(r2)
}
 90c3aa8:	e037883a 	mov	sp,fp
 90c3aac:	df000017 	ldw	fp,0(sp)
 90c3ab0:	dec00104 	addi	sp,sp,4
 90c3ab4:	f800283a 	ret

090c3ab8 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 90c3ab8:	defffe04 	addi	sp,sp,-8
 90c3abc:	df000115 	stw	fp,4(sp)
 90c3ac0:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 90c3ac4:	d0a0d10b 	ldhu	r2,-31932(gp)
 90c3ac8:	10bfffcc 	andi	r2,r2,65535
 90c3acc:	10812c28 	cmpgeui	r2,r2,1200
 90c3ad0:	10000c1e 	bne	r2,zero,90c3b04 <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 90c3ad4:	00824374 	movhi	r2,2317
 90c3ad8:	108c4204 	addi	r2,r2,12552
 90c3adc:	10800017 	ldw	r2,0(r2)
 90c3ae0:	109fffcc 	andi	r2,r2,32767
 90c3ae4:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 90c3ae8:	d0a0d10b 	ldhu	r2,-31932(gp)
 90c3aec:	10bfffcc 	andi	r2,r2,65535
 90c3af0:	10812c28 	cmpgeui	r2,r2,1200
 90c3af4:	1000031e 	bne	r2,zero,90c3b04 <udp_socket+0x4c>
         usocket += MINSOCKET;
 90c3af8:	d0a0d10b 	ldhu	r2,-31932(gp)
 90c3afc:	10812c04 	addi	r2,r2,1200
 90c3b00:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90c3b04:	00824374 	movhi	r2,2317
 90c3b08:	108c3604 	addi	r2,r2,12504
 90c3b0c:	10800017 	ldw	r2,0(r2)
 90c3b10:	e0bfff15 	stw	r2,-4(fp)
 90c3b14:	00001006 	br	90c3b58 <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 90c3b18:	e0bfff17 	ldw	r2,-4(fp)
 90c3b1c:	1080018b 	ldhu	r2,6(r2)
 90c3b20:	d0e0d10b 	ldhu	r3,-31932(gp)
 90c3b24:	113fffcc 	andi	r4,r2,65535
 90c3b28:	18bfffcc 	andi	r2,r3,65535
 90c3b2c:	2080071e 	bne	r4,r2,90c3b4c <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 90c3b30:	d0a0d10b 	ldhu	r2,-31932(gp)
 90c3b34:	10800044 	addi	r2,r2,1
 90c3b38:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 90c3b3c:	00824374 	movhi	r2,2317
 90c3b40:	108c3604 	addi	r2,r2,12504
 90c3b44:	10800017 	ldw	r2,0(r2)
 90c3b48:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90c3b4c:	e0bfff17 	ldw	r2,-4(fp)
 90c3b50:	10800017 	ldw	r2,0(r2)
 90c3b54:	e0bfff15 	stw	r2,-4(fp)
 90c3b58:	e0bfff17 	ldw	r2,-4(fp)
 90c3b5c:	1004c03a 	cmpne	r2,r2,zero
 90c3b60:	103fed1e 	bne	r2,zero,90c3b18 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 90c3b64:	d0a0d10b 	ldhu	r2,-31932(gp)
 90c3b68:	10ffffcc 	andi	r3,r2,65535
 90c3b6c:	10800044 	addi	r2,r2,1
 90c3b70:	d0a0d10d 	sth	r2,-31932(gp)
 90c3b74:	1805883a 	mov	r2,r3
}
 90c3b78:	e037883a 	mov	sp,fp
 90c3b7c:	df000017 	ldw	fp,0(sp)
 90c3b80:	dec00104 	addi	sp,sp,4
 90c3b84:	f800283a 	ret

090c3b88 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 90c3b88:	defffa04 	addi	sp,sp,-24
 90c3b8c:	dfc00515 	stw	ra,20(sp)
 90c3b90:	df000415 	stw	fp,16(sp)
 90c3b94:	df000404 	addi	fp,sp,16
 90c3b98:	e13ffe15 	stw	r4,-8(fp)
 90c3b9c:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 90c3ba0:	e0bffe17 	ldw	r2,-8(fp)
 90c3ba4:	10800244 	addi	r2,r2,9
 90c3ba8:	1007883a 	mov	r3,r2
 90c3bac:	00bfff84 	movi	r2,-2
 90c3bb0:	1884703a 	and	r2,r3,r2
 90c3bb4:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c3bb8:	01000084 	movi	r4,2
 90c3bbc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 90c3bc0:	e0fffd17 	ldw	r3,-12(fp)
 90c3bc4:	e0bfff17 	ldw	r2,-4(fp)
 90c3bc8:	1885883a 	add	r2,r3,r2
 90c3bcc:	10800904 	addi	r2,r2,36
 90c3bd0:	1009883a 	mov	r4,r2
 90c3bd4:	90a88440 	call	90a8844 <pk_alloc>
 90c3bd8:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c3bdc:	01000084 	movi	r4,2
 90c3be0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 90c3be4:	e0bffc17 	ldw	r2,-16(fp)
 90c3be8:	1005003a 	cmpeq	r2,r2,zero
 90c3bec:	1000101e 	bne	r2,zero,90c3c30 <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 90c3bf0:	e0bfff17 	ldw	r2,-4(fp)
 90c3bf4:	1005d0ba 	srai	r2,r2,2
 90c3bf8:	10800704 	addi	r2,r2,28
 90c3bfc:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 90c3c00:	e0bffc17 	ldw	r2,-16(fp)
 90c3c04:	10c00317 	ldw	r3,12(r2)
 90c3c08:	e0bffd17 	ldw	r2,-12(fp)
 90c3c0c:	1887883a 	add	r3,r3,r2
 90c3c10:	e0bffc17 	ldw	r2,-16(fp)
 90c3c14:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 90c3c18:	e0bffc17 	ldw	r2,-16(fp)
 90c3c1c:	10c00417 	ldw	r3,16(r2)
 90c3c20:	e0bffd17 	ldw	r2,-12(fp)
 90c3c24:	1887c83a 	sub	r3,r3,r2
 90c3c28:	e0bffc17 	ldw	r2,-16(fp)
 90c3c2c:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 90c3c30:	e0bffc17 	ldw	r2,-16(fp)
}
 90c3c34:	e037883a 	mov	sp,fp
 90c3c38:	dfc00117 	ldw	ra,4(sp)
 90c3c3c:	df000017 	ldw	fp,0(sp)
 90c3c40:	dec00204 	addi	sp,sp,8
 90c3c44:	f800283a 	ret

090c3c48 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 90c3c48:	deffff04 	addi	sp,sp,-4
 90c3c4c:	df000015 	stw	fp,0(sp)
 90c3c50:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 90c3c54:	00824374 	movhi	r2,2317
 90c3c58:	108bd104 	addi	r2,r2,12100
 90c3c5c:	10800017 	ldw	r2,0(r2)
 90c3c60:	10bff704 	addi	r2,r2,-36
#endif
}
 90c3c64:	e037883a 	mov	sp,fp
 90c3c68:	df000017 	ldw	fp,0(sp)
 90c3c6c:	dec00104 	addi	sp,sp,4
 90c3c70:	f800283a 	ret

090c3c74 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 90c3c74:	defffd04 	addi	sp,sp,-12
 90c3c78:	dfc00215 	stw	ra,8(sp)
 90c3c7c:	df000115 	stw	fp,4(sp)
 90c3c80:	df000104 	addi	fp,sp,4
 90c3c84:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c3c88:	01000084 	movi	r4,2
 90c3c8c:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c3c90:	e13fff17 	ldw	r4,-4(fp)
 90c3c94:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c3c98:	01000084 	movi	r4,2
 90c3c9c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
}
 90c3ca0:	e037883a 	mov	sp,fp
 90c3ca4:	dfc00117 	ldw	ra,4(sp)
 90c3ca8:	df000017 	ldw	fp,0(sp)
 90c3cac:	dec00204 	addi	sp,sp,8
 90c3cb0:	f800283a 	ret

090c3cb4 <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 90c3cb4:	defff704 	addi	sp,sp,-36
 90c3cb8:	dfc00815 	stw	ra,32(sp)
 90c3cbc:	df000715 	stw	fp,28(sp)
 90c3cc0:	df000704 	addi	fp,sp,28
 90c3cc4:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 90c3cc8:	e0bffe17 	ldw	r2,-8(fp)
 90c3ccc:	10800617 	ldw	r2,24(r2)
 90c3cd0:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 90c3cd4:	e0bffe17 	ldw	r2,-8(fp)
 90c3cd8:	10800317 	ldw	r2,12(r2)
 90c3cdc:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 90c3ce0:	e0bffc17 	ldw	r2,-16(fp)
 90c3ce4:	10800003 	ldbu	r2,0(r2)
 90c3ce8:	10803fcc 	andi	r2,r2,255
 90c3cec:	108003cc 	andi	r2,r2,15
 90c3cf0:	1085883a 	add	r2,r2,r2
 90c3cf4:	1085883a 	add	r2,r2,r2
 90c3cf8:	1007883a 	mov	r3,r2
 90c3cfc:	e0bffc17 	ldw	r2,-16(fp)
 90c3d00:	1885883a 	add	r2,r3,r2
 90c3d04:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 90c3d08:	e0bffd17 	ldw	r2,-12(fp)
 90c3d0c:	10800003 	ldbu	r2,0(r2)
 90c3d10:	10803fcc 	andi	r2,r2,255
 90c3d14:	e0bfff15 	stw	r2,-4(fp)
 90c3d18:	e0ffff17 	ldw	r3,-4(fp)
 90c3d1c:	18800460 	cmpeqi	r2,r3,17
 90c3d20:	1000041e 	bne	r2,zero,90c3d34 <igmpv1_input+0x80>
 90c3d24:	e0ffff17 	ldw	r3,-4(fp)
 90c3d28:	188004a0 	cmpeqi	r2,r3,18
 90c3d2c:	1000631e 	bne	r2,zero,90c3ebc <igmpv1_input+0x208>
 90c3d30:	00008706 	br	90c3f50 <igmpv1_input+0x29c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 90c3d34:	008243b4 	movhi	r2,2318
 90c3d38:	10b42204 	addi	r2,r2,-12152
 90c3d3c:	10800117 	ldw	r2,4(r2)
 90c3d40:	10c00044 	addi	r3,r2,1
 90c3d44:	008243b4 	movhi	r2,2318
 90c3d48:	10b42204 	addi	r2,r2,-12152
 90c3d4c:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c3d50:	e0bffa17 	ldw	r2,-24(fp)
 90c3d54:	10802c17 	ldw	r2,176(r2)
 90c3d58:	e0bffb15 	stw	r2,-20(fp)
 90c3d5c:	00005206 	br	90c3ea8 <igmpv1_input+0x1f4>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 90c3d60:	e0bffb17 	ldw	r2,-20(fp)
 90c3d64:	10800017 	ldw	r2,0(r2)
 90c3d68:	1005003a 	cmpeq	r2,r2,zero
 90c3d6c:	10004b1e 	bne	r2,zero,90c3e9c <igmpv1_input+0x1e8>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 90c3d70:	e0bffb17 	ldw	r2,-20(fp)
 90c3d74:	10c00017 	ldw	r3,0(r2)
 90c3d78:	00824374 	movhi	r2,2317
 90c3d7c:	108c2204 	addi	r2,r2,12424
 90c3d80:	10800017 	ldw	r2,0(r2)
 90c3d84:	18804526 	beq	r3,r2,90c3e9c <igmpv1_input+0x1e8>
         {
            if (inm->inm_timer == 0)
 90c3d88:	e0bffb17 	ldw	r2,-20(fp)
 90c3d8c:	10800317 	ldw	r2,12(r2)
 90c3d90:	1004c03a 	cmpne	r2,r2,zero
 90c3d94:	1000411e 	bne	r2,zero,90c3e9c <igmpv1_input+0x1e8>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 90c3d98:	008243b4 	movhi	r2,2318
 90c3d9c:	10b66404 	addi	r2,r2,-9840
 90c3da0:	11000217 	ldw	r4,8(r2)
 90c3da4:	008243b4 	movhi	r2,2318
 90c3da8:	10b41e04 	addi	r2,r2,-12168
 90c3dac:	10800017 	ldw	r2,0(r2)
 90c3db0:	10800a17 	ldw	r2,40(r2)
 90c3db4:	1004d63a 	srli	r2,r2,24
 90c3db8:	10c03fcc 	andi	r3,r2,255
 90c3dbc:	008243b4 	movhi	r2,2318
 90c3dc0:	10b41e04 	addi	r2,r2,-12168
 90c3dc4:	10800017 	ldw	r2,0(r2)
 90c3dc8:	10800a17 	ldw	r2,40(r2)
 90c3dcc:	1004d23a 	srli	r2,r2,8
 90c3dd0:	10bfc00c 	andi	r2,r2,65280
 90c3dd4:	1886b03a 	or	r3,r3,r2
 90c3dd8:	008243b4 	movhi	r2,2318
 90c3ddc:	10b41e04 	addi	r2,r2,-12168
 90c3de0:	10800017 	ldw	r2,0(r2)
 90c3de4:	10800a17 	ldw	r2,40(r2)
 90c3de8:	10bfc00c 	andi	r2,r2,65280
 90c3dec:	1004923a 	slli	r2,r2,8
 90c3df0:	1886b03a 	or	r3,r3,r2
 90c3df4:	008243b4 	movhi	r2,2318
 90c3df8:	10b41e04 	addi	r2,r2,-12168
 90c3dfc:	10800017 	ldw	r2,0(r2)
 90c3e00:	10800a17 	ldw	r2,40(r2)
 90c3e04:	10803fcc 	andi	r2,r2,255
 90c3e08:	1004963a 	slli	r2,r2,24
 90c3e0c:	1884b03a 	or	r2,r3,r2
 90c3e10:	2089883a 	add	r4,r4,r2
 90c3e14:	e0bffb17 	ldw	r2,-20(fp)
 90c3e18:	10800017 	ldw	r2,0(r2)
 90c3e1c:	1004d63a 	srli	r2,r2,24
 90c3e20:	10c03fcc 	andi	r3,r2,255
 90c3e24:	e0bffb17 	ldw	r2,-20(fp)
 90c3e28:	10800017 	ldw	r2,0(r2)
 90c3e2c:	1004d23a 	srli	r2,r2,8
 90c3e30:	10bfc00c 	andi	r2,r2,65280
 90c3e34:	1886b03a 	or	r3,r3,r2
 90c3e38:	e0bffb17 	ldw	r2,-20(fp)
 90c3e3c:	10800017 	ldw	r2,0(r2)
 90c3e40:	10bfc00c 	andi	r2,r2,65280
 90c3e44:	1004923a 	slli	r2,r2,8
 90c3e48:	1886b03a 	or	r3,r3,r2
 90c3e4c:	e0bffb17 	ldw	r2,-20(fp)
 90c3e50:	10800017 	ldw	r2,0(r2)
 90c3e54:	10803fcc 	andi	r2,r2,255
 90c3e58:	1004963a 	slli	r2,r2,24
 90c3e5c:	1884b03a 	or	r2,r3,r2
 90c3e60:	2087883a 	add	r3,r4,r2
 90c3e64:	00800c84 	movi	r2,50
 90c3e68:	1885203a 	divu	r2,r3,r2
 90c3e6c:	10800ca4 	muli	r2,r2,50
 90c3e70:	1885c83a 	sub	r2,r3,r2
 90c3e74:	10c00044 	addi	r3,r2,1
 90c3e78:	e0bffb17 	ldw	r2,-20(fp)
 90c3e7c:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 90c3e80:	00824374 	movhi	r2,2317
 90c3e84:	108c2004 	addi	r2,r2,12416
 90c3e88:	10800017 	ldw	r2,0(r2)
 90c3e8c:	10c00044 	addi	r3,r2,1
 90c3e90:	00824374 	movhi	r2,2317
 90c3e94:	108c2004 	addi	r2,r2,12416
 90c3e98:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c3e9c:	e0bffb17 	ldw	r2,-20(fp)
 90c3ea0:	10800517 	ldw	r2,20(r2)
 90c3ea4:	e0bffb15 	stw	r2,-20(fp)
 90c3ea8:	e0bffb17 	ldw	r2,-20(fp)
 90c3eac:	1004c03a 	cmpne	r2,r2,zero
 90c3eb0:	103fab1e 	bne	r2,zero,90c3d60 <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 90c3eb4:	e03ff915 	stw	zero,-28(fp)
      break;
 90c3eb8:	00002e06 	br	90c3f74 <igmpv1_input+0x2c0>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 90c3ebc:	008243b4 	movhi	r2,2318
 90c3ec0:	10b42204 	addi	r2,r2,-12152
 90c3ec4:	10800217 	ldw	r2,8(r2)
 90c3ec8:	10c00044 	addi	r3,r2,1
 90c3ecc:	008243b4 	movhi	r2,2318
 90c3ed0:	10b42204 	addi	r2,r2,-12152
 90c3ed4:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 90c3ed8:	e0bffd17 	ldw	r2,-12(fp)
 90c3edc:	11000117 	ldw	r4,4(r2)
 90c3ee0:	e17ffa17 	ldw	r5,-24(fp)
 90c3ee4:	90c20e40 	call	90c20e4 <lookup_mcast>
 90c3ee8:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 90c3eec:	e0bffb17 	ldw	r2,-20(fp)
 90c3ef0:	1005003a 	cmpeq	r2,r2,zero
 90c3ef4:	1000141e 	bne	r2,zero,90c3f48 <igmpv1_input+0x294>
      {
         if (inm->inm_timer > 0)
 90c3ef8:	e0bffb17 	ldw	r2,-20(fp)
 90c3efc:	10800317 	ldw	r2,12(r2)
 90c3f00:	1005003a 	cmpeq	r2,r2,zero
 90c3f04:	1000101e 	bne	r2,zero,90c3f48 <igmpv1_input+0x294>
         {
            inm->inm_timer = 0;
 90c3f08:	e0bffb17 	ldw	r2,-20(fp)
 90c3f0c:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 90c3f10:	00824374 	movhi	r2,2317
 90c3f14:	108c2004 	addi	r2,r2,12416
 90c3f18:	10800017 	ldw	r2,0(r2)
 90c3f1c:	10ffffc4 	addi	r3,r2,-1
 90c3f20:	00824374 	movhi	r2,2317
 90c3f24:	108c2004 	addi	r2,r2,12416
 90c3f28:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 90c3f2c:	008243b4 	movhi	r2,2318
 90c3f30:	10b42204 	addi	r2,r2,-12152
 90c3f34:	10800317 	ldw	r2,12(r2)
 90c3f38:	10c00044 	addi	r3,r2,1
 90c3f3c:	008243b4 	movhi	r2,2318
 90c3f40:	10b42204 	addi	r2,r2,-12152
 90c3f44:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 90c3f48:	e03ff915 	stw	zero,-28(fp)
      break;
 90c3f4c:	00000906 	br	90c3f74 <igmpv1_input+0x2c0>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 90c3f50:	008243b4 	movhi	r2,2318
 90c3f54:	10b42204 	addi	r2,r2,-12152
 90c3f58:	10801017 	ldw	r2,64(r2)
 90c3f5c:	10c00044 	addi	r3,r2,1
 90c3f60:	008243b4 	movhi	r2,2318
 90c3f64:	10b42204 	addi	r2,r2,-12152
 90c3f68:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 90c3f6c:	00bfffc4 	movi	r2,-1
 90c3f70:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c3f74:	01000084 	movi	r4,2
 90c3f78:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c3f7c:	e13ffe17 	ldw	r4,-8(fp)
 90c3f80:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c3f84:	01000084 	movi	r4,2
 90c3f88:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      
   return rc;
 90c3f8c:	e0bff917 	ldw	r2,-28(fp)
}
 90c3f90:	e037883a 	mov	sp,fp
 90c3f94:	dfc00117 	ldw	ra,4(sp)
 90c3f98:	df000017 	ldw	fp,0(sp)
 90c3f9c:	dec00204 	addi	sp,sp,8
 90c3fa0:	f800283a 	ret

090c3fa4 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 90c3fa4:	defff704 	addi	sp,sp,-36
 90c3fa8:	dfc00815 	stw	ra,32(sp)
 90c3fac:	df000715 	stw	fp,28(sp)
 90c3fb0:	df000704 	addi	fp,sp,28
 90c3fb4:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 90c3fb8:	e0bffe17 	ldw	r2,-8(fp)
 90c3fbc:	10800317 	ldw	r2,12(r2)
 90c3fc0:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 90c3fc4:	e0bffe17 	ldw	r2,-8(fp)
 90c3fc8:	10c00417 	ldw	r3,16(r2)
 90c3fcc:	e0bffc17 	ldw	r2,-16(fp)
 90c3fd0:	10800003 	ldbu	r2,0(r2)
 90c3fd4:	10803fcc 	andi	r2,r2,255
 90c3fd8:	108003cc 	andi	r2,r2,15
 90c3fdc:	1085883a 	add	r2,r2,r2
 90c3fe0:	1085883a 	add	r2,r2,r2
 90c3fe4:	1885c83a 	sub	r2,r3,r2
 90c3fe8:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 90c3fec:	e0bffc17 	ldw	r2,-16(fp)
 90c3ff0:	10800003 	ldbu	r2,0(r2)
 90c3ff4:	10803fcc 	andi	r2,r2,255
 90c3ff8:	108003cc 	andi	r2,r2,15
 90c3ffc:	1085883a 	add	r2,r2,r2
 90c4000:	1085883a 	add	r2,r2,r2
 90c4004:	1007883a 	mov	r3,r2
 90c4008:	e0bffc17 	ldw	r2,-16(fp)
 90c400c:	1885883a 	add	r2,r3,r2
 90c4010:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 90c4014:	e0bffd17 	ldw	r2,-12(fp)
 90c4018:	10800003 	ldbu	r2,0(r2)
 90c401c:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 90c4020:	e0bffa03 	ldbu	r2,-24(fp)
 90c4024:	e0bfff15 	stw	r2,-4(fp)
 90c4028:	e0ffff17 	ldw	r3,-4(fp)
 90c402c:	188004a0 	cmpeqi	r2,r3,18
 90c4030:	1000121e 	bne	r2,zero,90c407c <igmpv2_input+0xd8>
 90c4034:	e0ffff17 	ldw	r3,-4(fp)
 90c4038:	188004c8 	cmpgei	r2,r3,19
 90c403c:	1000041e 	bne	r2,zero,90c4050 <igmpv2_input+0xac>
 90c4040:	e0ffff17 	ldw	r3,-4(fp)
 90c4044:	18800460 	cmpeqi	r2,r3,17
 90c4048:	1000081e 	bne	r2,zero,90c406c <igmpv2_input+0xc8>
 90c404c:	00001806 	br	90c40b0 <igmpv2_input+0x10c>
 90c4050:	e0ffff17 	ldw	r3,-4(fp)
 90c4054:	188005a0 	cmpeqi	r2,r3,22
 90c4058:	1000081e 	bne	r2,zero,90c407c <igmpv2_input+0xd8>
 90c405c:	e0ffff17 	ldw	r3,-4(fp)
 90c4060:	188005e0 	cmpeqi	r2,r3,23
 90c4064:	1000091e 	bne	r2,zero,90c408c <igmpv2_input+0xe8>
 90c4068:	00001106 	br	90c40b0 <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 90c406c:	e13ffe17 	ldw	r4,-8(fp)
 90c4070:	90c42500 	call	90c4250 <igmpv2_process_query>
 90c4074:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4078:	00001606 	br	90c40d4 <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 90c407c:	e13ffe17 	ldw	r4,-8(fp)
 90c4080:	90c41040 	call	90c4104 <igmpv2_process_report>
 90c4084:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4088:	00001206 	br	90c40d4 <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 90c408c:	008243b4 	movhi	r2,2318
 90c4090:	10b42204 	addi	r2,r2,-12152
 90c4094:	10800917 	ldw	r2,36(r2)
 90c4098:	10c00044 	addi	r3,r2,1
 90c409c:	008243b4 	movhi	r2,2318
 90c40a0:	10b42204 	addi	r2,r2,-12152
 90c40a4:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 90c40a8:	e03ff915 	stw	zero,-28(fp)
         break;               
 90c40ac:	00000906 	br	90c40d4 <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 90c40b0:	008243b4 	movhi	r2,2318
 90c40b4:	10b42204 	addi	r2,r2,-12152
 90c40b8:	10801517 	ldw	r2,84(r2)
 90c40bc:	10c00044 	addi	r3,r2,1
 90c40c0:	008243b4 	movhi	r2,2318
 90c40c4:	10b42204 	addi	r2,r2,-12152
 90c40c8:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 90c40cc:	00bfffc4 	movi	r2,-1
 90c40d0:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c40d4:	01000084 	movi	r4,2
 90c40d8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c40dc:	e13ffe17 	ldw	r4,-8(fp)
 90c40e0:	90a8bd80 	call	90a8bd8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c40e4:	01000084 	movi	r4,2
 90c40e8:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
   
   return rc;
 90c40ec:	e0bff917 	ldw	r2,-28(fp)
}
 90c40f0:	e037883a 	mov	sp,fp
 90c40f4:	dfc00117 	ldw	ra,4(sp)
 90c40f8:	df000017 	ldw	fp,0(sp)
 90c40fc:	dec00204 	addi	sp,sp,8
 90c4100:	f800283a 	ret

090c4104 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 90c4104:	defff904 	addi	sp,sp,-28
 90c4108:	dfc00615 	stw	ra,24(sp)
 90c410c:	df000515 	stw	fp,20(sp)
 90c4110:	df000504 	addi	fp,sp,20
 90c4114:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 90c4118:	e0bfff17 	ldw	r2,-4(fp)
 90c411c:	10800617 	ldw	r2,24(r2)
 90c4120:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 90c4124:	e0bfff17 	ldw	r2,-4(fp)
 90c4128:	10800317 	ldw	r2,12(r2)
 90c412c:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 90c4130:	e0bffd17 	ldw	r2,-12(fp)
 90c4134:	10800003 	ldbu	r2,0(r2)
 90c4138:	10803fcc 	andi	r2,r2,255
 90c413c:	108003cc 	andi	r2,r2,15
 90c4140:	1085883a 	add	r2,r2,r2
 90c4144:	1085883a 	add	r2,r2,r2
 90c4148:	1007883a 	mov	r3,r2
 90c414c:	e0bffd17 	ldw	r2,-12(fp)
 90c4150:	1885883a 	add	r2,r3,r2
 90c4154:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 90c4158:	e0bffe17 	ldw	r2,-8(fp)
 90c415c:	11000117 	ldw	r4,4(r2)
 90c4160:	e17ffc17 	ldw	r5,-16(fp)
 90c4164:	90c20e40 	call	90c20e4 <lookup_mcast>
 90c4168:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 90c416c:	e0bffb17 	ldw	r2,-20(fp)
 90c4170:	1005003a 	cmpeq	r2,r2,zero
 90c4174:	1000291e 	bne	r2,zero,90c421c <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 90c4178:	e0bffb17 	ldw	r2,-20(fp)
 90c417c:	10800317 	ldw	r2,12(r2)
 90c4180:	1005003a 	cmpeq	r2,r2,zero
 90c4184:	10001d1e 	bne	r2,zero,90c41fc <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 90c4188:	e0bffc17 	ldw	r2,-16(fp)
 90c418c:	10802d03 	ldbu	r2,180(r2)
 90c4190:	10803fcc 	andi	r2,r2,255
 90c4194:	1005003a 	cmpeq	r2,r2,zero
 90c4198:	1000051e 	bne	r2,zero,90c41b0 <igmpv2_process_report+0xac>
 90c419c:	e0bffe17 	ldw	r2,-8(fp)
 90c41a0:	10800003 	ldbu	r2,0(r2)
 90c41a4:	10803fcc 	andi	r2,r2,255
 90c41a8:	108005a0 	cmpeqi	r2,r2,22
 90c41ac:	1000221e 	bne	r2,zero,90c4238 <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 90c41b0:	e0bffb17 	ldw	r2,-20(fp)
 90c41b4:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 90c41b8:	00824374 	movhi	r2,2317
 90c41bc:	108c2004 	addi	r2,r2,12416
 90c41c0:	10800017 	ldw	r2,0(r2)
 90c41c4:	10ffffc4 	addi	r3,r2,-1
 90c41c8:	00824374 	movhi	r2,2317
 90c41cc:	108c2004 	addi	r2,r2,12416
 90c41d0:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 90c41d4:	e0bffb17 	ldw	r2,-20(fp)
 90c41d8:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 90c41dc:	008243b4 	movhi	r2,2318
 90c41e0:	10b42204 	addi	r2,r2,-12152
 90c41e4:	10800717 	ldw	r2,28(r2)
 90c41e8:	10c00044 	addi	r3,r2,1
 90c41ec:	008243b4 	movhi	r2,2318
 90c41f0:	10b42204 	addi	r2,r2,-12152
 90c41f4:	10c00715 	stw	r3,28(r2)
 90c41f8:	00000f06 	br	90c4238 <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 90c41fc:	008243b4 	movhi	r2,2318
 90c4200:	10b42204 	addi	r2,r2,-12152
 90c4204:	10800817 	ldw	r2,32(r2)
 90c4208:	10c00044 	addi	r3,r2,1
 90c420c:	008243b4 	movhi	r2,2318
 90c4210:	10b42204 	addi	r2,r2,-12152
 90c4214:	10c00815 	stw	r3,32(r2)
 90c4218:	00000706 	br	90c4238 <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 90c421c:	008243b4 	movhi	r2,2318
 90c4220:	10b42204 	addi	r2,r2,-12152
 90c4224:	10801317 	ldw	r2,76(r2)
 90c4228:	10c00044 	addi	r3,r2,1
 90c422c:	008243b4 	movhi	r2,2318
 90c4230:	10b42204 	addi	r2,r2,-12152
 90c4234:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 90c4238:	0005883a 	mov	r2,zero
}
 90c423c:	e037883a 	mov	sp,fp
 90c4240:	dfc00117 	ldw	ra,4(sp)
 90c4244:	df000017 	ldw	fp,0(sp)
 90c4248:	dec00204 	addi	sp,sp,8
 90c424c:	f800283a 	ret

090c4250 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 90c4250:	defff704 	addi	sp,sp,-36
 90c4254:	dfc00815 	stw	ra,32(sp)
 90c4258:	df000715 	stw	fp,28(sp)
 90c425c:	df000704 	addi	fp,sp,28
 90c4260:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 90c4264:	e0bfff17 	ldw	r2,-4(fp)
 90c4268:	10800617 	ldw	r2,24(r2)
 90c426c:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 90c4270:	e0bfff17 	ldw	r2,-4(fp)
 90c4274:	10800317 	ldw	r2,12(r2)
 90c4278:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 90c427c:	e0bffd17 	ldw	r2,-12(fp)
 90c4280:	10800003 	ldbu	r2,0(r2)
 90c4284:	10803fcc 	andi	r2,r2,255
 90c4288:	108003cc 	andi	r2,r2,15
 90c428c:	1085883a 	add	r2,r2,r2
 90c4290:	1085883a 	add	r2,r2,r2
 90c4294:	1007883a 	mov	r3,r2
 90c4298:	e0bffd17 	ldw	r2,-12(fp)
 90c429c:	1885883a 	add	r2,r3,r2
 90c42a0:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 90c42a4:	e0bffe17 	ldw	r2,-8(fp)
 90c42a8:	10800117 	ldw	r2,4(r2)
 90c42ac:	1004d63a 	srli	r2,r2,24
 90c42b0:	10c03fcc 	andi	r3,r2,255
 90c42b4:	e0bffe17 	ldw	r2,-8(fp)
 90c42b8:	10800117 	ldw	r2,4(r2)
 90c42bc:	1004d23a 	srli	r2,r2,8
 90c42c0:	10bfc00c 	andi	r2,r2,65280
 90c42c4:	1886b03a 	or	r3,r3,r2
 90c42c8:	e0bffe17 	ldw	r2,-8(fp)
 90c42cc:	10800117 	ldw	r2,4(r2)
 90c42d0:	10bfc00c 	andi	r2,r2,65280
 90c42d4:	1004923a 	slli	r2,r2,8
 90c42d8:	1886b03a 	or	r3,r3,r2
 90c42dc:	e0bffe17 	ldw	r2,-8(fp)
 90c42e0:	10800117 	ldw	r2,4(r2)
 90c42e4:	10803fcc 	andi	r2,r2,255
 90c42e8:	1004963a 	slli	r2,r2,24
 90c42ec:	1884b03a 	or	r2,r3,r2
 90c42f0:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 90c42f4:	e0bffe17 	ldw	r2,-8(fp)
 90c42f8:	10800043 	ldbu	r2,1(r2)
 90c42fc:	10803fcc 	andi	r2,r2,255
 90c4300:	1004c03a 	cmpne	r2,r2,zero
 90c4304:	1000141e 	bne	r2,zero,90c4358 <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 90c4308:	e0fffc17 	ldw	r3,-16(fp)
 90c430c:	00800044 	movi	r2,1
 90c4310:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 90c4314:	00824374 	movhi	r2,2317
 90c4318:	108c4204 	addi	r2,r2,12552
 90c431c:	10c00017 	ldw	r3,0(r2)
 90c4320:	e0bffc17 	ldw	r2,-16(fp)
 90c4324:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 90c4328:	008243b4 	movhi	r2,2318
 90c432c:	10b42204 	addi	r2,r2,-12152
 90c4330:	10800417 	ldw	r2,16(r2)
 90c4334:	10c00044 	addi	r3,r2,1
 90c4338:	008243b4 	movhi	r2,2318
 90c433c:	10b42204 	addi	r2,r2,-12152
 90c4340:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 90c4344:	00800c84 	movi	r2,50
 90c4348:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 90c434c:	00800044 	movi	r2,1
 90c4350:	e0bffb05 	stb	r2,-20(fp)
 90c4354:	00001d06 	br	90c43cc <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 90c4358:	e0bffe17 	ldw	r2,-8(fp)
 90c435c:	10800117 	ldw	r2,4(r2)
 90c4360:	1004c03a 	cmpne	r2,r2,zero
 90c4364:	10000a1e 	bne	r2,zero,90c4390 <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 90c4368:	008243b4 	movhi	r2,2318
 90c436c:	10b42204 	addi	r2,r2,-12152
 90c4370:	10800517 	ldw	r2,20(r2)
 90c4374:	10c00044 	addi	r3,r2,1
 90c4378:	008243b4 	movhi	r2,2318
 90c437c:	10b42204 	addi	r2,r2,-12152
 90c4380:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 90c4384:	00800044 	movi	r2,1
 90c4388:	e0bffb05 	stb	r2,-20(fp)
 90c438c:	00000806 	br	90c43b0 <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 90c4390:	008243b4 	movhi	r2,2318
 90c4394:	10b42204 	addi	r2,r2,-12152
 90c4398:	10800617 	ldw	r2,24(r2)
 90c439c:	10c00044 	addi	r3,r2,1
 90c43a0:	008243b4 	movhi	r2,2318
 90c43a4:	10b42204 	addi	r2,r2,-12152
 90c43a8:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 90c43ac:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 90c43b0:	e0bffe17 	ldw	r2,-8(fp)
 90c43b4:	10800043 	ldbu	r2,1(r2)
 90c43b8:	10c03fcc 	andi	r3,r2,255
 90c43bc:	1804d7fa 	srli	r2,r3,31
 90c43c0:	10c5883a 	add	r2,r2,r3
 90c43c4:	1005d07a 	srai	r2,r2,1
 90c43c8:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 90c43cc:	e0bffb03 	ldbu	r2,-20(fp)
 90c43d0:	1005003a 	cmpeq	r2,r2,zero
 90c43d4:	1000181e 	bne	r2,zero,90c4438 <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c43d8:	e0bffc17 	ldw	r2,-16(fp)
 90c43dc:	10802c17 	ldw	r2,176(r2)
 90c43e0:	e0bffa15 	stw	r2,-24(fp)
 90c43e4:	00001006 	br	90c4428 <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 90c43e8:	e0bffa17 	ldw	r2,-24(fp)
 90c43ec:	10800017 	ldw	r2,0(r2)
 90c43f0:	1005003a 	cmpeq	r2,r2,zero
 90c43f4:	1000091e 	bne	r2,zero,90c441c <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 90c43f8:	e0bffa17 	ldw	r2,-24(fp)
 90c43fc:	10c00017 	ldw	r3,0(r2)
 90c4400:	00824374 	movhi	r2,2317
 90c4404:	108c2204 	addi	r2,r2,12424
 90c4408:	10800017 	ldw	r2,0(r2)
 90c440c:	18800326 	beq	r3,r2,90c441c <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 90c4410:	e17ffb8b 	ldhu	r5,-18(fp)
 90c4414:	e13ffa17 	ldw	r4,-24(fp)
 90c4418:	90c449c0 	call	90c449c <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c441c:	e0bffa17 	ldw	r2,-24(fp)
 90c4420:	10800517 	ldw	r2,20(r2)
 90c4424:	e0bffa15 	stw	r2,-24(fp)
 90c4428:	e0bffa17 	ldw	r2,-24(fp)
 90c442c:	1004c03a 	cmpne	r2,r2,zero
 90c4430:	103fed1e 	bne	r2,zero,90c43e8 <igmpv2_process_query+0x198>
 90c4434:	00001306 	br	90c4484 <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 90c4438:	e0bffe17 	ldw	r2,-8(fp)
 90c443c:	11000117 	ldw	r4,4(r2)
 90c4440:	e17ffc17 	ldw	r5,-16(fp)
 90c4444:	90c20e40 	call	90c20e4 <lookup_mcast>
 90c4448:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 90c444c:	e0bffa17 	ldw	r2,-24(fp)
 90c4450:	1005003a 	cmpeq	r2,r2,zero
 90c4454:	1000041e 	bne	r2,zero,90c4468 <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 90c4458:	e17ffb8b 	ldhu	r5,-18(fp)
 90c445c:	e13ffa17 	ldw	r4,-24(fp)
 90c4460:	90c449c0 	call	90c449c <igmpv2_chk_set_timer>
 90c4464:	00000706 	br	90c4484 <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 90c4468:	008243b4 	movhi	r2,2318
 90c446c:	10b42204 	addi	r2,r2,-12152
 90c4470:	10801217 	ldw	r2,72(r2)
 90c4474:	10c00044 	addi	r3,r2,1
 90c4478:	008243b4 	movhi	r2,2318
 90c447c:	10b42204 	addi	r2,r2,-12152
 90c4480:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 90c4484:	0005883a 	mov	r2,zero
}
 90c4488:	e037883a 	mov	sp,fp
 90c448c:	dfc00117 	ldw	ra,4(sp)
 90c4490:	df000017 	ldw	fp,0(sp)
 90c4494:	dec00204 	addi	sp,sp,8
 90c4498:	f800283a 	ret

090c449c <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 90c449c:	defffd04 	addi	sp,sp,-12
 90c44a0:	df000215 	stw	fp,8(sp)
 90c44a4:	df000204 	addi	fp,sp,8
 90c44a8:	e13ffe15 	stw	r4,-8(fp)
 90c44ac:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 90c44b0:	e0bffe17 	ldw	r2,-8(fp)
 90c44b4:	10c00317 	ldw	r3,12(r2)
 90c44b8:	e0bfff0b 	ldhu	r2,-4(fp)
 90c44bc:	10c00436 	bltu	r2,r3,90c44d0 <igmpv2_chk_set_timer+0x34>
 90c44c0:	e0bffe17 	ldw	r2,-8(fp)
 90c44c4:	10800317 	ldw	r2,12(r2)
 90c44c8:	1004c03a 	cmpne	r2,r2,zero
 90c44cc:	1000451e 	bne	r2,zero,90c45e4 <igmpv2_chk_set_timer+0x148>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 90c44d0:	e0bffe17 	ldw	r2,-8(fp)
 90c44d4:	10800317 	ldw	r2,12(r2)
 90c44d8:	1004c03a 	cmpne	r2,r2,zero
 90c44dc:	1000071e 	bne	r2,zero,90c44fc <igmpv2_chk_set_timer+0x60>
 90c44e0:	00824374 	movhi	r2,2317
 90c44e4:	108c2004 	addi	r2,r2,12416
 90c44e8:	10800017 	ldw	r2,0(r2)
 90c44ec:	10c00044 	addi	r3,r2,1
 90c44f0:	00824374 	movhi	r2,2317
 90c44f4:	108c2004 	addi	r2,r2,12416
 90c44f8:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 90c44fc:	008243b4 	movhi	r2,2318
 90c4500:	10b66404 	addi	r2,r2,-9840
 90c4504:	11000217 	ldw	r4,8(r2)
 90c4508:	008243b4 	movhi	r2,2318
 90c450c:	10b41e04 	addi	r2,r2,-12168
 90c4510:	10800017 	ldw	r2,0(r2)
 90c4514:	10800a17 	ldw	r2,40(r2)
 90c4518:	1004d63a 	srli	r2,r2,24
 90c451c:	10c03fcc 	andi	r3,r2,255
 90c4520:	008243b4 	movhi	r2,2318
 90c4524:	10b41e04 	addi	r2,r2,-12168
 90c4528:	10800017 	ldw	r2,0(r2)
 90c452c:	10800a17 	ldw	r2,40(r2)
 90c4530:	1004d23a 	srli	r2,r2,8
 90c4534:	10bfc00c 	andi	r2,r2,65280
 90c4538:	1886b03a 	or	r3,r3,r2
 90c453c:	008243b4 	movhi	r2,2318
 90c4540:	10b41e04 	addi	r2,r2,-12168
 90c4544:	10800017 	ldw	r2,0(r2)
 90c4548:	10800a17 	ldw	r2,40(r2)
 90c454c:	10bfc00c 	andi	r2,r2,65280
 90c4550:	1004923a 	slli	r2,r2,8
 90c4554:	1886b03a 	or	r3,r3,r2
 90c4558:	008243b4 	movhi	r2,2318
 90c455c:	10b41e04 	addi	r2,r2,-12168
 90c4560:	10800017 	ldw	r2,0(r2)
 90c4564:	10800a17 	ldw	r2,40(r2)
 90c4568:	10803fcc 	andi	r2,r2,255
 90c456c:	1004963a 	slli	r2,r2,24
 90c4570:	1884b03a 	or	r2,r3,r2
 90c4574:	2089883a 	add	r4,r4,r2
 90c4578:	e0bffe17 	ldw	r2,-8(fp)
 90c457c:	10800017 	ldw	r2,0(r2)
 90c4580:	1004d63a 	srli	r2,r2,24
 90c4584:	10c03fcc 	andi	r3,r2,255
 90c4588:	e0bffe17 	ldw	r2,-8(fp)
 90c458c:	10800017 	ldw	r2,0(r2)
 90c4590:	1004d23a 	srli	r2,r2,8
 90c4594:	10bfc00c 	andi	r2,r2,65280
 90c4598:	1886b03a 	or	r3,r3,r2
 90c459c:	e0bffe17 	ldw	r2,-8(fp)
 90c45a0:	10800017 	ldw	r2,0(r2)
 90c45a4:	10bfc00c 	andi	r2,r2,65280
 90c45a8:	1004923a 	slli	r2,r2,8
 90c45ac:	1886b03a 	or	r3,r3,r2
 90c45b0:	e0bffe17 	ldw	r2,-8(fp)
 90c45b4:	10800017 	ldw	r2,0(r2)
 90c45b8:	10803fcc 	andi	r2,r2,255
 90c45bc:	1004963a 	slli	r2,r2,24
 90c45c0:	1884b03a 	or	r2,r3,r2
 90c45c4:	2089883a 	add	r4,r4,r2
 90c45c8:	e0ffff0b 	ldhu	r3,-4(fp)
 90c45cc:	20c5203a 	divu	r2,r4,r3
 90c45d0:	10c5383a 	mul	r2,r2,r3
 90c45d4:	2085c83a 	sub	r2,r4,r2
 90c45d8:	10c00044 	addi	r3,r2,1
 90c45dc:	e0bffe17 	ldw	r2,-8(fp)
 90c45e0:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 90c45e4:	e037883a 	mov	sp,fp
 90c45e8:	df000017 	ldw	fp,0(sp)
 90c45ec:	dec00104 	addi	sp,sp,4
 90c45f0:	f800283a 	ret

090c45f4 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 90c45f4:	defff904 	addi	sp,sp,-28
 90c45f8:	df000615 	stw	fp,24(sp)
 90c45fc:	df000604 	addi	fp,sp,24
 90c4600:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 90c4604:	e0bffd17 	ldw	r2,-12(fp)
 90c4608:	10800003 	ldbu	r2,0(r2)
 90c460c:	108003cc 	andi	r2,r2,15
 90c4610:	1085883a 	add	r2,r2,r2
 90c4614:	1085883a 	add	r2,r2,r2
 90c4618:	10bffb04 	addi	r2,r2,-20
 90c461c:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 90c4620:	e0bffa83 	ldbu	r2,-22(fp)
 90c4624:	1005003a 	cmpeq	r2,r2,zero
 90c4628:	1000481e 	bne	r2,zero,90c474c <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 90c462c:	e0bffd17 	ldw	r2,-12(fp)
 90c4630:	10800504 	addi	r2,r2,20
 90c4634:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 90c4638:	00004106 	br	90c4740 <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 90c463c:	e0bffc17 	ldw	r2,-16(fp)
 90c4640:	10800003 	ldbu	r2,0(r2)
 90c4644:	108007cc 	andi	r2,r2,31
 90c4648:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 90c464c:	e0bffa03 	ldbu	r2,-24(fp)
 90c4650:	e0bfff15 	stw	r2,-4(fp)
 90c4654:	e0ffff17 	ldw	r3,-4(fp)
 90c4658:	18800060 	cmpeqi	r2,r3,1
 90c465c:	10000b1e 	bne	r2,zero,90c468c <igmpv2_chk4_rtr_alert_opt+0x98>
 90c4660:	e0ffff17 	ldw	r3,-4(fp)
 90c4664:	18800520 	cmpeqi	r2,r3,20
 90c4668:	10000b1e 	bne	r2,zero,90c4698 <igmpv2_chk4_rtr_alert_opt+0xa4>
 90c466c:	e0ffff17 	ldw	r3,-4(fp)
 90c4670:	1805003a 	cmpeq	r2,r3,zero
 90c4674:	1000011e 	bne	r2,zero,90c467c <igmpv2_chk4_rtr_alert_opt+0x88>
 90c4678:	00002306 	br	90c4708 <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 90c467c:	00800044 	movi	r2,1
 90c4680:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 90c4684:	e03ffe15 	stw	zero,-8(fp)
 90c4688:	00003106 	br	90c4750 <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 90c468c:	00800044 	movi	r2,1
 90c4690:	e0bffa45 	stb	r2,-23(fp)
               break;
 90c4694:	00002106 	br	90c471c <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 90c4698:	e0bffc17 	ldw	r2,-16(fp)
 90c469c:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 90c46a0:	e0bffb17 	ldw	r2,-20(fp)
 90c46a4:	10800017 	ldw	r2,0(r2)
 90c46a8:	1004d63a 	srli	r2,r2,24
 90c46ac:	10c03fcc 	andi	r3,r2,255
 90c46b0:	e0bffb17 	ldw	r2,-20(fp)
 90c46b4:	10800017 	ldw	r2,0(r2)
 90c46b8:	1004d23a 	srli	r2,r2,8
 90c46bc:	10bfc00c 	andi	r2,r2,65280
 90c46c0:	1886b03a 	or	r3,r3,r2
 90c46c4:	e0bffb17 	ldw	r2,-20(fp)
 90c46c8:	10800017 	ldw	r2,0(r2)
 90c46cc:	10bfc00c 	andi	r2,r2,65280
 90c46d0:	1004923a 	slli	r2,r2,8
 90c46d4:	1886b03a 	or	r3,r3,r2
 90c46d8:	e0bffb17 	ldw	r2,-20(fp)
 90c46dc:	10800017 	ldw	r2,0(r2)
 90c46e0:	10803fcc 	andi	r2,r2,255
 90c46e4:	1004963a 	slli	r2,r2,24
 90c46e8:	1886b03a 	or	r3,r3,r2
 90c46ec:	00a50134 	movhi	r2,37892
 90c46f0:	1880031e 	bne	r3,r2,90c4700 <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 90c46f4:	00800044 	movi	r2,1
 90c46f8:	e0bffe15 	stw	r2,-8(fp)
 90c46fc:	00001406 	br	90c4750 <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 90c4700:	e03ffe15 	stw	zero,-8(fp)
 90c4704:	00001206 	br	90c4750 <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 90c4708:	e0bffc17 	ldw	r2,-16(fp)
 90c470c:	10800044 	addi	r2,r2,1
 90c4710:	10800003 	ldbu	r2,0(r2)
 90c4714:	10800084 	addi	r2,r2,2
 90c4718:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 90c471c:	e0bffa43 	ldbu	r2,-23(fp)
 90c4720:	1007883a 	mov	r3,r2
 90c4724:	e0bffc17 	ldw	r2,-16(fp)
 90c4728:	10c5883a 	add	r2,r2,r3
 90c472c:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 90c4730:	e0fffa83 	ldbu	r3,-22(fp)
 90c4734:	e0bffa43 	ldbu	r2,-23(fp)
 90c4738:	1885c83a 	sub	r2,r3,r2
 90c473c:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 90c4740:	e0bffa83 	ldbu	r2,-22(fp)
 90c4744:	1004c03a 	cmpne	r2,r2,zero
 90c4748:	103fbc1e 	bne	r2,zero,90c463c <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 90c474c:	e03ffe15 	stw	zero,-8(fp)
 90c4750:	e0bffe17 	ldw	r2,-8(fp)
}
 90c4754:	e037883a 	mov	sp,fp
 90c4758:	df000017 	ldw	fp,0(sp)
 90c475c:	dec00104 	addi	sp,sp,4
 90c4760:	f800283a 	ret

090c4764 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 90c4764:	defffc04 	addi	sp,sp,-16
 90c4768:	df000315 	stw	fp,12(sp)
 90c476c:	df000304 	addi	fp,sp,12
 90c4770:	e13ffe15 	stw	r4,-8(fp)
 90c4774:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 90c4778:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 90c477c:	e0bffd0b 	ldhu	r2,-12(fp)
 90c4780:	00c243b4 	movhi	r3,2318
 90c4784:	18f41e04 	addi	r3,r3,-12168
 90c4788:	1085883a 	add	r2,r2,r2
 90c478c:	1085883a 	add	r2,r2,r2
 90c4790:	10c5883a 	add	r2,r2,r3
 90c4794:	10c00017 	ldw	r3,0(r2)
 90c4798:	e0bfff17 	ldw	r2,-4(fp)
 90c479c:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 90c47a0:	e0bffe17 	ldw	r2,-8(fp)
 90c47a4:	1004c03a 	cmpne	r2,r2,zero
 90c47a8:	1000331e 	bne	r2,zero,90c4878 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 90c47ac:	e03ffd0d 	sth	zero,-12(fp)
 90c47b0:	00001706 	br	90c4810 <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 90c47b4:	e0bffd0b 	ldhu	r2,-12(fp)
 90c47b8:	00c243b4 	movhi	r3,2318
 90c47bc:	18f41e04 	addi	r3,r3,-12168
 90c47c0:	1085883a 	add	r2,r2,r2
 90c47c4:	1085883a 	add	r2,r2,r2
 90c47c8:	10c5883a 	add	r2,r2,r3
 90c47cc:	10800017 	ldw	r2,0(r2)
 90c47d0:	10802b17 	ldw	r2,172(r2)
 90c47d4:	1005003a 	cmpeq	r2,r2,zero
 90c47d8:	10000a1e 	bne	r2,zero,90c4804 <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 90c47dc:	e0bffd0b 	ldhu	r2,-12(fp)
 90c47e0:	00c243b4 	movhi	r3,2318
 90c47e4:	18f41e04 	addi	r3,r3,-12168
 90c47e8:	1085883a 	add	r2,r2,r2
 90c47ec:	1085883a 	add	r2,r2,r2
 90c47f0:	10c5883a 	add	r2,r2,r3
 90c47f4:	10c00017 	ldw	r3,0(r2)
 90c47f8:	e0bfff17 	ldw	r2,-4(fp)
 90c47fc:	10c00015 	stw	r3,0(r2)
            break;
 90c4800:	00002606 	br	90c489c <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 90c4804:	e0bffd0b 	ldhu	r2,-12(fp)
 90c4808:	10800044 	addi	r2,r2,1
 90c480c:	e0bffd0d 	sth	r2,-12(fp)
 90c4810:	e0bffd0b 	ldhu	r2,-12(fp)
 90c4814:	00c24374 	movhi	r3,2317
 90c4818:	18cc1e04 	addi	r3,r3,12408
 90c481c:	18c00017 	ldw	r3,0(r3)
 90c4820:	10ffe436 	bltu	r2,r3,90c47b4 <IPADDR_TO_NETP+0x50>
 90c4824:	00001d06 	br	90c489c <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 90c4828:	e0bffd0b 	ldhu	r2,-12(fp)
 90c482c:	10800044 	addi	r2,r2,1
 90c4830:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 90c4834:	e0fffd0b 	ldhu	r3,-12(fp)
 90c4838:	00824374 	movhi	r2,2317
 90c483c:	108c1e04 	addi	r2,r2,12408
 90c4840:	10800017 	ldw	r2,0(r2)
 90c4844:	18800336 	bltu	r3,r2,90c4854 <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 90c4848:	e0bfff17 	ldw	r2,-4(fp)
 90c484c:	10000015 	stw	zero,0(r2)
            break;
 90c4850:	00001206 	br	90c489c <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 90c4854:	e0bffd0b 	ldhu	r2,-12(fp)
 90c4858:	00c243b4 	movhi	r3,2318
 90c485c:	18f41e04 	addi	r3,r3,-12168
 90c4860:	1085883a 	add	r2,r2,r2
 90c4864:	1085883a 	add	r2,r2,r2
 90c4868:	10c5883a 	add	r2,r2,r3
 90c486c:	10c00017 	ldw	r3,0(r2)
 90c4870:	e0bfff17 	ldw	r2,-4(fp)
 90c4874:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 90c4878:	e0bfff17 	ldw	r2,-4(fp)
 90c487c:	10800017 	ldw	r2,0(r2)
 90c4880:	1005003a 	cmpeq	r2,r2,zero
 90c4884:	1000051e 	bne	r2,zero,90c489c <IPADDR_TO_NETP+0x138>
 90c4888:	e0bfff17 	ldw	r2,-4(fp)
 90c488c:	10800017 	ldw	r2,0(r2)
 90c4890:	10c00a17 	ldw	r3,40(r2)
 90c4894:	e0bffe17 	ldw	r2,-8(fp)
 90c4898:	18bfe31e 	bne	r3,r2,90c4828 <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 90c489c:	e037883a 	mov	sp,fp
 90c48a0:	df000017 	ldw	fp,0(sp)
 90c48a4:	dec00104 	addi	sp,sp,4
 90c48a8:	f800283a 	ret

090c48ac <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 90c48ac:	defff104 	addi	sp,sp,-60
 90c48b0:	dfc00e15 	stw	ra,56(sp)
 90c48b4:	df000d15 	stw	fp,52(sp)
 90c48b8:	dc000c15 	stw	r16,48(sp)
 90c48bc:	df000c04 	addi	fp,sp,48
 90c48c0:	e13ffb15 	stw	r4,-20(fp)
 90c48c4:	e17ffc15 	stw	r5,-16(fp)
 90c48c8:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90c48cc:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 90c48d0:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 90c48d4:	e0bffc17 	ldw	r2,-16(fp)
 90c48d8:	10800317 	ldw	r2,12(r2)
 90c48dc:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 90c48e0:	e0bffc17 	ldw	r2,-16(fp)
 90c48e4:	10800304 	addi	r2,r2,12
 90c48e8:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 90c48ec:	e0bff617 	ldw	r2,-40(fp)
 90c48f0:	1004c03a 	cmpne	r2,r2,zero
 90c48f4:	1000161e 	bne	r2,zero,90c4950 <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 90c48f8:	01001604 	movi	r4,88
 90c48fc:	90a9f0c0 	call	90a9f0c <npalloc>
 90c4900:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 90c4904:	e0bff617 	ldw	r2,-40(fp)
 90c4908:	1004c03a 	cmpne	r2,r2,zero
 90c490c:	1000031e 	bne	r2,zero,90c491c <ip_setmoptions+0x70>
         return (ENOBUFS);
 90c4910:	00801a44 	movi	r2,105
 90c4914:	e0bffe15 	stw	r2,-8(fp)
 90c4918:	00015906 	br	90c4e80 <ip_setmoptions+0x5d4>
      *imop = imo;
 90c491c:	e0fff517 	ldw	r3,-44(fp)
 90c4920:	e0bff617 	ldw	r2,-40(fp)
 90c4924:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 90c4928:	e0bff617 	ldw	r2,-40(fp)
 90c492c:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 90c4930:	e0fff617 	ldw	r3,-40(fp)
 90c4934:	00800044 	movi	r2,1
 90c4938:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 90c493c:	e0fff617 	ldw	r3,-40(fp)
 90c4940:	00800044 	movi	r2,1
 90c4944:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 90c4948:	e0bff617 	ldw	r2,-40(fp)
 90c494c:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 90c4950:	e0bffb17 	ldw	r2,-20(fp)
 90c4954:	10bffdc4 	addi	r2,r2,-9
 90c4958:	e0bfff15 	stw	r2,-4(fp)
 90c495c:	e0ffff17 	ldw	r3,-4(fp)
 90c4960:	18800168 	cmpgeui	r2,r3,5
 90c4964:	10012a1e 	bne	r2,zero,90c4e10 <ip_setmoptions+0x564>
 90c4968:	e13fff17 	ldw	r4,-4(fp)
 90c496c:	e13fff17 	ldw	r4,-4(fp)
 90c4970:	2105883a 	add	r2,r4,r4
 90c4974:	1087883a 	add	r3,r2,r2
 90c4978:	00824334 	movhi	r2,2316
 90c497c:	10926304 	addi	r2,r2,18828
 90c4980:	1885883a 	add	r2,r3,r2
 90c4984:	10800017 	ldw	r2,0(r2)
 90c4988:	1000683a 	jmp	r2
 90c498c:	090c49a0 	cmpeqi	r4,at,12582
 90c4990:	090c4a14 	ori	r4,at,12584
 90c4994:	090c4a28 	cmpgeui	r4,at,12584
 90c4998:	090c4a5c 	xori	r4,at,12585
 90c499c:	090c4c2c 	andhi	r4,at,12592

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 90c49a0:	e0bffd17 	ldw	r2,-12(fp)
 90c49a4:	10800017 	ldw	r2,0(r2)
 90c49a8:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 90c49ac:	e0bff417 	ldw	r2,-48(fp)
 90c49b0:	1004c03a 	cmpne	r2,r2,zero
 90c49b4:	1000031e 	bne	r2,zero,90c49c4 <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 90c49b8:	e0bff617 	ldw	r2,-40(fp)
 90c49bc:	10000015 	stw	zero,0(r2)
         break;
 90c49c0:	00011506 	br	90c4e18 <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 90c49c4:	e17ffa04 	addi	r5,fp,-24
 90c49c8:	e13ff417 	ldw	r4,-48(fp)
 90c49cc:	90c47640 	call	90c4764 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 90c49d0:	e0bffa17 	ldw	r2,-24(fp)
 90c49d4:	1005003a 	cmpeq	r2,r2,zero
 90c49d8:	1000041e 	bne	r2,zero,90c49ec <ip_setmoptions+0x140>
 90c49dc:	e0bffa17 	ldw	r2,-24(fp)
 90c49e0:	10802b17 	ldw	r2,172(r2)
 90c49e4:	1004c03a 	cmpne	r2,r2,zero
 90c49e8:	1000031e 	bne	r2,zero,90c49f8 <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 90c49ec:	00801f44 	movi	r2,125
 90c49f0:	e0bff915 	stw	r2,-28(fp)
         break;
 90c49f4:	00010806 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 90c49f8:	e0bff417 	ldw	r2,-48(fp)
 90c49fc:	1005003a 	cmpeq	r2,r2,zero
 90c4a00:	1001051e 	bne	r2,zero,90c4e18 <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 90c4a04:	e0fffa17 	ldw	r3,-24(fp)
 90c4a08:	e0bff617 	ldw	r2,-40(fp)
 90c4a0c:	10c00015 	stw	r3,0(r2)
      break;
 90c4a10:	00010106 	br	90c4e18 <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 90c4a14:	e0bffd17 	ldw	r2,-12(fp)
 90c4a18:	10c00003 	ldbu	r3,0(r2)
 90c4a1c:	e0bff617 	ldw	r2,-40(fp)
 90c4a20:	10c00105 	stb	r3,4(r2)
      break;
 90c4a24:	0000fc06 	br	90c4e18 <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 90c4a28:	e0bffd17 	ldw	r2,-12(fp)
 90c4a2c:	10800003 	ldbu	r2,0(r2)
 90c4a30:	10803fcc 	andi	r2,r2,255
 90c4a34:	108000b0 	cmpltui	r2,r2,2
 90c4a38:	1000031e 	bne	r2,zero,90c4a48 <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 90c4a3c:	00800584 	movi	r2,22
 90c4a40:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4a44:	0000f406 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 90c4a48:	e0bffd17 	ldw	r2,-12(fp)
 90c4a4c:	10c00003 	ldbu	r3,0(r2)
 90c4a50:	e0bff617 	ldw	r2,-40(fp)
 90c4a54:	10c00145 	stb	r3,5(r2)
      break;
 90c4a58:	0000ef06 	br	90c4e18 <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 90c4a5c:	e0bffd17 	ldw	r2,-12(fp)
 90c4a60:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 90c4a64:	e0bff717 	ldw	r2,-36(fp)
 90c4a68:	10800017 	ldw	r2,0(r2)
 90c4a6c:	1004d63a 	srli	r2,r2,24
 90c4a70:	10c03fcc 	andi	r3,r2,255
 90c4a74:	e0bff717 	ldw	r2,-36(fp)
 90c4a78:	10800017 	ldw	r2,0(r2)
 90c4a7c:	1004d23a 	srli	r2,r2,8
 90c4a80:	10bfc00c 	andi	r2,r2,65280
 90c4a84:	1886b03a 	or	r3,r3,r2
 90c4a88:	e0bff717 	ldw	r2,-36(fp)
 90c4a8c:	10800017 	ldw	r2,0(r2)
 90c4a90:	10bfc00c 	andi	r2,r2,65280
 90c4a94:	1004923a 	slli	r2,r2,8
 90c4a98:	1886b03a 	or	r3,r3,r2
 90c4a9c:	e0bff717 	ldw	r2,-36(fp)
 90c4aa0:	10800017 	ldw	r2,0(r2)
 90c4aa4:	10803fcc 	andi	r2,r2,255
 90c4aa8:	1004963a 	slli	r2,r2,24
 90c4aac:	1884b03a 	or	r2,r3,r2
 90c4ab0:	10fc002c 	andhi	r3,r2,61440
 90c4ab4:	00b80034 	movhi	r2,57344
 90c4ab8:	18800326 	beq	r3,r2,90c4ac8 <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 90c4abc:	00800584 	movi	r2,22
 90c4ac0:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4ac4:	0000d406 	br	90c4e18 <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 90c4ac8:	e0bff717 	ldw	r2,-36(fp)
 90c4acc:	11000117 	ldw	r4,4(r2)
 90c4ad0:	e17ffa04 	addi	r5,fp,-24
 90c4ad4:	90c47640 	call	90c4764 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 90c4ad8:	e0bffa17 	ldw	r2,-24(fp)
 90c4adc:	1005003a 	cmpeq	r2,r2,zero
 90c4ae0:	1000041e 	bne	r2,zero,90c4af4 <ip_setmoptions+0x248>
 90c4ae4:	e0bffa17 	ldw	r2,-24(fp)
 90c4ae8:	10802b17 	ldw	r2,172(r2)
 90c4aec:	1004c03a 	cmpne	r2,r2,zero
 90c4af0:	1000031e 	bne	r2,zero,90c4b00 <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 90c4af4:	00801f44 	movi	r2,125
 90c4af8:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4afc:	0000c606 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c4b00:	e03ff80d 	sth	zero,-32(fp)
 90c4b04:	00001806 	br	90c4b68 <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 90c4b08:	e0bff80b 	ldhu	r2,-32(fp)
 90c4b0c:	e0fff617 	ldw	r3,-40(fp)
 90c4b10:	1085883a 	add	r2,r2,r2
 90c4b14:	1085883a 	add	r2,r2,r2
 90c4b18:	10c5883a 	add	r2,r2,r3
 90c4b1c:	10800204 	addi	r2,r2,8
 90c4b20:	10800017 	ldw	r2,0(r2)
 90c4b24:	10c00117 	ldw	r3,4(r2)
 90c4b28:	e0bffa17 	ldw	r2,-24(fp)
 90c4b2c:	18800b1e 	bne	r3,r2,90c4b5c <ip_setmoptions+0x2b0>
 90c4b30:	e0bff80b 	ldhu	r2,-32(fp)
 90c4b34:	e0fff617 	ldw	r3,-40(fp)
 90c4b38:	1085883a 	add	r2,r2,r2
 90c4b3c:	1085883a 	add	r2,r2,r2
 90c4b40:	10c5883a 	add	r2,r2,r3
 90c4b44:	10800204 	addi	r2,r2,8
 90c4b48:	10800017 	ldw	r2,0(r2)
 90c4b4c:	10c00017 	ldw	r3,0(r2)
 90c4b50:	e0bff717 	ldw	r2,-36(fp)
 90c4b54:	10800017 	ldw	r2,0(r2)
 90c4b58:	18800826 	beq	r3,r2,90c4b7c <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c4b5c:	e0bff80b 	ldhu	r2,-32(fp)
 90c4b60:	10800044 	addi	r2,r2,1
 90c4b64:	e0bff80d 	sth	r2,-32(fp)
 90c4b68:	e0bff617 	ldw	r2,-40(fp)
 90c4b6c:	1080018b 	ldhu	r2,6(r2)
 90c4b70:	10ffffcc 	andi	r3,r2,65535
 90c4b74:	e0bff80b 	ldhu	r2,-32(fp)
 90c4b78:	10ffe336 	bltu	r2,r3,90c4b08 <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 90c4b7c:	e0bff617 	ldw	r2,-40(fp)
 90c4b80:	1080018b 	ldhu	r2,6(r2)
 90c4b84:	10ffffcc 	andi	r3,r2,65535
 90c4b88:	e0bff80b 	ldhu	r2,-32(fp)
 90c4b8c:	10c0032e 	bgeu	r2,r3,90c4b9c <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 90c4b90:	00801c04 	movi	r2,112
 90c4b94:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4b98:	00009f06 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 90c4b9c:	e0bff80b 	ldhu	r2,-32(fp)
 90c4ba0:	10800518 	cmpnei	r2,r2,20
 90c4ba4:	1000031e 	bne	r2,zero,90c4bb4 <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 90c4ba8:	00802044 	movi	r2,129
 90c4bac:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4bb0:	00009906 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 90c4bb4:	e43ff80b 	ldhu	r16,-32(fp)
 90c4bb8:	e13ff717 	ldw	r4,-36(fp)
 90c4bbc:	e17ffa17 	ldw	r5,-24(fp)
 90c4bc0:	01800104 	movi	r6,4
 90c4bc4:	90c1e640 	call	90c1e64 <in_addmulti>
 90c4bc8:	1009883a 	mov	r4,r2
 90c4bcc:	e0fff617 	ldw	r3,-40(fp)
 90c4bd0:	8405883a 	add	r2,r16,r16
 90c4bd4:	1085883a 	add	r2,r2,r2
 90c4bd8:	10c5883a 	add	r2,r2,r3
 90c4bdc:	10800204 	addi	r2,r2,8
 90c4be0:	11000015 	stw	r4,0(r2)
 90c4be4:	e0fff617 	ldw	r3,-40(fp)
 90c4be8:	8405883a 	add	r2,r16,r16
 90c4bec:	1085883a 	add	r2,r2,r2
 90c4bf0:	10c5883a 	add	r2,r2,r3
 90c4bf4:	10800204 	addi	r2,r2,8
 90c4bf8:	10800017 	ldw	r2,0(r2)
 90c4bfc:	1004c03a 	cmpne	r2,r2,zero
 90c4c00:	1000031e 	bne	r2,zero,90c4c10 <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 90c4c04:	00801a44 	movi	r2,105
 90c4c08:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4c0c:	00008206 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 90c4c10:	e0bff617 	ldw	r2,-40(fp)
 90c4c14:	1080018b 	ldhu	r2,6(r2)
 90c4c18:	10800044 	addi	r2,r2,1
 90c4c1c:	1007883a 	mov	r3,r2
 90c4c20:	e0bff617 	ldw	r2,-40(fp)
 90c4c24:	10c0018d 	sth	r3,6(r2)
      break;
 90c4c28:	00007b06 	br	90c4e18 <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 90c4c2c:	e0bffd17 	ldw	r2,-12(fp)
 90c4c30:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 90c4c34:	e0bff717 	ldw	r2,-36(fp)
 90c4c38:	10800017 	ldw	r2,0(r2)
 90c4c3c:	1004d63a 	srli	r2,r2,24
 90c4c40:	10c03fcc 	andi	r3,r2,255
 90c4c44:	e0bff717 	ldw	r2,-36(fp)
 90c4c48:	10800017 	ldw	r2,0(r2)
 90c4c4c:	1004d23a 	srli	r2,r2,8
 90c4c50:	10bfc00c 	andi	r2,r2,65280
 90c4c54:	1886b03a 	or	r3,r3,r2
 90c4c58:	e0bff717 	ldw	r2,-36(fp)
 90c4c5c:	10800017 	ldw	r2,0(r2)
 90c4c60:	10bfc00c 	andi	r2,r2,65280
 90c4c64:	1004923a 	slli	r2,r2,8
 90c4c68:	1886b03a 	or	r3,r3,r2
 90c4c6c:	e0bff717 	ldw	r2,-36(fp)
 90c4c70:	10800017 	ldw	r2,0(r2)
 90c4c74:	10803fcc 	andi	r2,r2,255
 90c4c78:	1004963a 	slli	r2,r2,24
 90c4c7c:	1884b03a 	or	r2,r3,r2
 90c4c80:	10fc002c 	andhi	r3,r2,61440
 90c4c84:	00b80034 	movhi	r2,57344
 90c4c88:	18800326 	beq	r3,r2,90c4c98 <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 90c4c8c:	00800584 	movi	r2,22
 90c4c90:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4c94:	00006006 	br	90c4e18 <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 90c4c98:	e0bff717 	ldw	r2,-36(fp)
 90c4c9c:	11000117 	ldw	r4,4(r2)
 90c4ca0:	e17ffa04 	addi	r5,fp,-24
 90c4ca4:	90c47640 	call	90c4764 <IPADDR_TO_NETP>
      if (netp == NULL) 
 90c4ca8:	e0bffa17 	ldw	r2,-24(fp)
 90c4cac:	1004c03a 	cmpne	r2,r2,zero
 90c4cb0:	1000031e 	bne	r2,zero,90c4cc0 <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 90c4cb4:	00801f44 	movi	r2,125
 90c4cb8:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4cbc:	00005606 	br	90c4e18 <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c4cc0:	e03ff80d 	sth	zero,-32(fp)
 90c4cc4:	00001b06 	br	90c4d34 <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 90c4cc8:	e0bffa17 	ldw	r2,-24(fp)
 90c4ccc:	1005003a 	cmpeq	r2,r2,zero
 90c4cd0:	10000a1e 	bne	r2,zero,90c4cfc <ip_setmoptions+0x450>
 90c4cd4:	e0bff80b 	ldhu	r2,-32(fp)
 90c4cd8:	e0fff617 	ldw	r3,-40(fp)
 90c4cdc:	1085883a 	add	r2,r2,r2
 90c4ce0:	1085883a 	add	r2,r2,r2
 90c4ce4:	10c5883a 	add	r2,r2,r3
 90c4ce8:	10800204 	addi	r2,r2,8
 90c4cec:	10800017 	ldw	r2,0(r2)
 90c4cf0:	10c00117 	ldw	r3,4(r2)
 90c4cf4:	e0bffa17 	ldw	r2,-24(fp)
 90c4cf8:	18800b1e 	bne	r3,r2,90c4d28 <ip_setmoptions+0x47c>
 90c4cfc:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d00:	e0fff617 	ldw	r3,-40(fp)
 90c4d04:	1085883a 	add	r2,r2,r2
 90c4d08:	1085883a 	add	r2,r2,r2
 90c4d0c:	10c5883a 	add	r2,r2,r3
 90c4d10:	10800204 	addi	r2,r2,8
 90c4d14:	10800017 	ldw	r2,0(r2)
 90c4d18:	10c00017 	ldw	r3,0(r2)
 90c4d1c:	e0bff717 	ldw	r2,-36(fp)
 90c4d20:	10800017 	ldw	r2,0(r2)
 90c4d24:	18800826 	beq	r3,r2,90c4d48 <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c4d28:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d2c:	10800044 	addi	r2,r2,1
 90c4d30:	e0bff80d 	sth	r2,-32(fp)
 90c4d34:	e0bff617 	ldw	r2,-40(fp)
 90c4d38:	1080018b 	ldhu	r2,6(r2)
 90c4d3c:	10ffffcc 	andi	r3,r2,65535
 90c4d40:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d44:	10ffe036 	bltu	r2,r3,90c4cc8 <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 90c4d48:	e0bff617 	ldw	r2,-40(fp)
 90c4d4c:	1080018b 	ldhu	r2,6(r2)
 90c4d50:	10ffffcc 	andi	r3,r2,65535
 90c4d54:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d58:	1880031e 	bne	r3,r2,90c4d68 <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 90c4d5c:	00801f44 	movi	r2,125
 90c4d60:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4d64:	00002c06 	br	90c4e18 <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 90c4d68:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d6c:	e0fff617 	ldw	r3,-40(fp)
 90c4d70:	1085883a 	add	r2,r2,r2
 90c4d74:	1085883a 	add	r2,r2,r2
 90c4d78:	10c5883a 	add	r2,r2,r3
 90c4d7c:	10800204 	addi	r2,r2,8
 90c4d80:	11000017 	ldw	r4,0(r2)
 90c4d84:	90c1fcc0 	call	90c1fcc <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 90c4d88:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d8c:	10800044 	addi	r2,r2,1
 90c4d90:	e0bff80d 	sth	r2,-32(fp)
 90c4d94:	00001206 	br	90c4de0 <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 90c4d98:	e0bff80b 	ldhu	r2,-32(fp)
 90c4d9c:	113fffc4 	addi	r4,r2,-1
 90c4da0:	e0bff80b 	ldhu	r2,-32(fp)
 90c4da4:	e0fff617 	ldw	r3,-40(fp)
 90c4da8:	1085883a 	add	r2,r2,r2
 90c4dac:	1085883a 	add	r2,r2,r2
 90c4db0:	10c5883a 	add	r2,r2,r3
 90c4db4:	10800204 	addi	r2,r2,8
 90c4db8:	11400017 	ldw	r5,0(r2)
 90c4dbc:	e0fff617 	ldw	r3,-40(fp)
 90c4dc0:	2105883a 	add	r2,r4,r4
 90c4dc4:	1085883a 	add	r2,r2,r2
 90c4dc8:	10c5883a 	add	r2,r2,r3
 90c4dcc:	10800204 	addi	r2,r2,8
 90c4dd0:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 90c4dd4:	e0bff80b 	ldhu	r2,-32(fp)
 90c4dd8:	10800044 	addi	r2,r2,1
 90c4ddc:	e0bff80d 	sth	r2,-32(fp)
 90c4de0:	e0bff617 	ldw	r2,-40(fp)
 90c4de4:	1080018b 	ldhu	r2,6(r2)
 90c4de8:	10ffffcc 	andi	r3,r2,65535
 90c4dec:	e0bff80b 	ldhu	r2,-32(fp)
 90c4df0:	10ffe936 	bltu	r2,r3,90c4d98 <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 90c4df4:	e0bff617 	ldw	r2,-40(fp)
 90c4df8:	1080018b 	ldhu	r2,6(r2)
 90c4dfc:	10bfffc4 	addi	r2,r2,-1
 90c4e00:	1007883a 	mov	r3,r2
 90c4e04:	e0bff617 	ldw	r2,-40(fp)
 90c4e08:	10c0018d 	sth	r3,6(r2)
      break;
 90c4e0c:	00000206 	br	90c4e18 <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 90c4e10:	008017c4 	movi	r2,95
 90c4e14:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 90c4e18:	e0bff617 	ldw	r2,-40(fp)
 90c4e1c:	10800017 	ldw	r2,0(r2)
 90c4e20:	1004c03a 	cmpne	r2,r2,zero
 90c4e24:	1000141e 	bne	r2,zero,90c4e78 <ip_setmoptions+0x5cc>
 90c4e28:	e0bff617 	ldw	r2,-40(fp)
 90c4e2c:	10800103 	ldbu	r2,4(r2)
 90c4e30:	10803fcc 	andi	r2,r2,255
 90c4e34:	10800058 	cmpnei	r2,r2,1
 90c4e38:	10000f1e 	bne	r2,zero,90c4e78 <ip_setmoptions+0x5cc>
 90c4e3c:	e0bff617 	ldw	r2,-40(fp)
 90c4e40:	10800143 	ldbu	r2,5(r2)
 90c4e44:	10803fcc 	andi	r2,r2,255
 90c4e48:	10800058 	cmpnei	r2,r2,1
 90c4e4c:	10000a1e 	bne	r2,zero,90c4e78 <ip_setmoptions+0x5cc>
 90c4e50:	e0bff617 	ldw	r2,-40(fp)
 90c4e54:	1080018b 	ldhu	r2,6(r2)
 90c4e58:	10bfffcc 	andi	r2,r2,65535
 90c4e5c:	1004c03a 	cmpne	r2,r2,zero
 90c4e60:	1000051e 	bne	r2,zero,90c4e78 <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 90c4e64:	e0bff517 	ldw	r2,-44(fp)
 90c4e68:	11000017 	ldw	r4,0(r2)
 90c4e6c:	90aa0000 	call	90aa000 <npfree>
      *imop = NULL;
 90c4e70:	e0bff517 	ldw	r2,-44(fp)
 90c4e74:	10000015 	stw	zero,0(r2)
   }
   return (error);
 90c4e78:	e0bff917 	ldw	r2,-28(fp)
 90c4e7c:	e0bffe15 	stw	r2,-8(fp)
 90c4e80:	e0bffe17 	ldw	r2,-8(fp)
}
 90c4e84:	e037883a 	mov	sp,fp
 90c4e88:	dfc00217 	ldw	ra,8(sp)
 90c4e8c:	df000117 	ldw	fp,4(sp)
 90c4e90:	dc000017 	ldw	r16,0(sp)
 90c4e94:	dec00304 	addi	sp,sp,12
 90c4e98:	f800283a 	ret

090c4e9c <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 90c4e9c:	defff604 	addi	sp,sp,-40
 90c4ea0:	df000915 	stw	fp,36(sp)
 90c4ea4:	df000904 	addi	fp,sp,36
 90c4ea8:	e13ffb15 	stw	r4,-20(fp)
 90c4eac:	e17ffc15 	stw	r5,-16(fp)
 90c4eb0:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 90c4eb4:	e0bffc17 	ldw	r2,-16(fp)
 90c4eb8:	10800317 	ldw	r2,12(r2)
 90c4ebc:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 90c4ec0:	e0bffb17 	ldw	r2,-20(fp)
 90c4ec4:	e0bfff15 	stw	r2,-4(fp)
 90c4ec8:	e0ffff17 	ldw	r3,-4(fp)
 90c4ecc:	18800260 	cmpeqi	r2,r3,9
 90c4ed0:	10000a1e 	bne	r2,zero,90c4efc <ip_getmoptions+0x60>
 90c4ed4:	e0ffff17 	ldw	r3,-4(fp)
 90c4ed8:	18800250 	cmplti	r2,r3,9
 90c4edc:	1000381e 	bne	r2,zero,90c4fc0 <ip_getmoptions+0x124>
 90c4ee0:	e0ffff17 	ldw	r3,-4(fp)
 90c4ee4:	188002a0 	cmpeqi	r2,r3,10
 90c4ee8:	1000171e 	bne	r2,zero,90c4f48 <ip_getmoptions+0xac>
 90c4eec:	e0ffff17 	ldw	r3,-4(fp)
 90c4ef0:	188002e0 	cmpeqi	r2,r3,11
 90c4ef4:	1000231e 	bne	r2,zero,90c4f84 <ip_getmoptions+0xe8>
 90c4ef8:	00003106 	br	90c4fc0 <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 90c4efc:	e0bffd17 	ldw	r2,-12(fp)
 90c4f00:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 90c4f04:	e0bff717 	ldw	r2,-36(fp)
 90c4f08:	1005003a 	cmpeq	r2,r2,zero
 90c4f0c:	1000041e 	bne	r2,zero,90c4f20 <ip_getmoptions+0x84>
 90c4f10:	e0bff717 	ldw	r2,-36(fp)
 90c4f14:	10800017 	ldw	r2,0(r2)
 90c4f18:	1004c03a 	cmpne	r2,r2,zero
 90c4f1c:	1000031e 	bne	r2,zero,90c4f2c <ip_getmoptions+0x90>
         *addr = AADDR;
 90c4f20:	e0bff817 	ldw	r2,-32(fp)
 90c4f24:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 90c4f28:	00000506 	br	90c4f40 <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 90c4f2c:	e0bff717 	ldw	r2,-36(fp)
 90c4f30:	10800017 	ldw	r2,0(r2)
 90c4f34:	10c00a17 	ldw	r3,40(r2)
 90c4f38:	e0bff817 	ldw	r2,-32(fp)
 90c4f3c:	10c00015 	stw	r3,0(r2)
      return (0);
 90c4f40:	e03ffe15 	stw	zero,-8(fp)
 90c4f44:	00002006 	br	90c4fc8 <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 90c4f48:	e0bffd17 	ldw	r2,-12(fp)
 90c4f4c:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 90c4f50:	e0bff717 	ldw	r2,-36(fp)
 90c4f54:	1004c03a 	cmpne	r2,r2,zero
 90c4f58:	1000041e 	bne	r2,zero,90c4f6c <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 90c4f5c:	e0fffa17 	ldw	r3,-24(fp)
 90c4f60:	00800044 	movi	r2,1
 90c4f64:	18800005 	stb	r2,0(r3)
 90c4f68:	00000406 	br	90c4f7c <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 90c4f6c:	e0bff717 	ldw	r2,-36(fp)
 90c4f70:	10c00103 	ldbu	r3,4(r2)
 90c4f74:	e0bffa17 	ldw	r2,-24(fp)
 90c4f78:	10c00005 	stb	r3,0(r2)
      return (0);
 90c4f7c:	e03ffe15 	stw	zero,-8(fp)
 90c4f80:	00001106 	br	90c4fc8 <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 90c4f84:	e0bffd17 	ldw	r2,-12(fp)
 90c4f88:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 90c4f8c:	e0bff717 	ldw	r2,-36(fp)
 90c4f90:	1004c03a 	cmpne	r2,r2,zero
 90c4f94:	1000041e 	bne	r2,zero,90c4fa8 <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 90c4f98:	e0fff917 	ldw	r3,-28(fp)
 90c4f9c:	00800044 	movi	r2,1
 90c4fa0:	18800005 	stb	r2,0(r3)
 90c4fa4:	00000406 	br	90c4fb8 <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 90c4fa8:	e0bff717 	ldw	r2,-36(fp)
 90c4fac:	10c00143 	ldbu	r3,5(r2)
 90c4fb0:	e0bff917 	ldw	r2,-28(fp)
 90c4fb4:	10c00005 	stb	r3,0(r2)
      return (0);
 90c4fb8:	e03ffe15 	stw	zero,-8(fp)
 90c4fbc:	00000206 	br	90c4fc8 <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 90c4fc0:	008017c4 	movi	r2,95
 90c4fc4:	e0bffe15 	stw	r2,-8(fp)
 90c4fc8:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 90c4fcc:	e037883a 	mov	sp,fp
 90c4fd0:	df000017 	ldw	fp,0(sp)
 90c4fd4:	dec00104 	addi	sp,sp,4
 90c4fd8:	f800283a 	ret

090c4fdc <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 90c4fdc:	defffc04 	addi	sp,sp,-16
 90c4fe0:	dfc00315 	stw	ra,12(sp)
 90c4fe4:	df000215 	stw	fp,8(sp)
 90c4fe8:	df000204 	addi	fp,sp,8
 90c4fec:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 90c4ff0:	e0bfff17 	ldw	r2,-4(fp)
 90c4ff4:	1005003a 	cmpeq	r2,r2,zero
 90c4ff8:	1000141e 	bne	r2,zero,90c504c <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 90c4ffc:	e03ffe0d 	sth	zero,-8(fp)
 90c5000:	00000b06 	br	90c5030 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 90c5004:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5008:	e0ffff17 	ldw	r3,-4(fp)
 90c500c:	1085883a 	add	r2,r2,r2
 90c5010:	1085883a 	add	r2,r2,r2
 90c5014:	10c5883a 	add	r2,r2,r3
 90c5018:	10800204 	addi	r2,r2,8
 90c501c:	11000017 	ldw	r4,0(r2)
 90c5020:	90c1fcc0 	call	90c1fcc <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 90c5024:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5028:	10800044 	addi	r2,r2,1
 90c502c:	e0bffe0d 	sth	r2,-8(fp)
 90c5030:	e0bfff17 	ldw	r2,-4(fp)
 90c5034:	1080018b 	ldhu	r2,6(r2)
 90c5038:	10ffffcc 	andi	r3,r2,65535
 90c503c:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5040:	10fff036 	bltu	r2,r3,90c5004 <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 90c5044:	e13fff17 	ldw	r4,-4(fp)
 90c5048:	90aa0000 	call	90aa000 <npfree>
   }
}
 90c504c:	e037883a 	mov	sp,fp
 90c5050:	dfc00117 	ldw	ra,4(sp)
 90c5054:	df000017 	ldw	fp,0(sp)
 90c5058:	dec00204 	addi	sp,sp,8
 90c505c:	f800283a 	ret

090c5060 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 90c5060:	defffe04 	addi	sp,sp,-8
 90c5064:	dfc00115 	stw	ra,4(sp)
 90c5068:	df000015 	stw	fp,0(sp)
 90c506c:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 90c5070:	01024374 	movhi	r4,2317
 90c5074:	2101b904 	addi	r4,r4,1764
 90c5078:	90828380 	call	9082838 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 90c507c:	e037883a 	mov	sp,fp
 90c5080:	dfc00117 	ldw	ra,4(sp)
 90c5084:	df000017 	ldw	fp,0(sp)
 90c5088:	dec00204 	addi	sp,sp,8
 90c508c:	f800283a 	ret

090c5090 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 90c5090:	defede04 	addi	sp,sp,-1160
 90c5094:	dfc12115 	stw	ra,1156(sp)
 90c5098:	df012015 	stw	fp,1152(sp)
 90c509c:	df012004 	addi	fp,sp,1152
 90c50a0:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 90c50a4:	00c24374 	movhi	r3,2317
 90c50a8:	18c26504 	addi	r3,r3,2452
 90c50ac:	18800017 	ldw	r2,0(r3)
 90c50b0:	e0bff215 	stw	r2,-56(fp)
 90c50b4:	18800117 	ldw	r2,4(r3)
 90c50b8:	e0bff315 	stw	r2,-52(fp)
 90c50bc:	18800217 	ldw	r2,8(r3)
 90c50c0:	e0bff415 	stw	r2,-48(fp)
 90c50c4:	18800317 	ldw	r2,12(r3)
 90c50c8:	e0bff515 	stw	r2,-44(fp)
 90c50cc:	18800417 	ldw	r2,16(r3)
 90c50d0:	e0bff615 	stw	r2,-40(fp)
 90c50d4:	18800517 	ldw	r2,20(r3)
 90c50d8:	e0bff715 	stw	r2,-36(fp)
 90c50dc:	18800617 	ldw	r2,24(r3)
 90c50e0:	e0bff815 	stw	r2,-32(fp)
 90c50e4:	1880070b 	ldhu	r2,28(r3)
 90c50e8:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 90c50ec:	01000084 	movi	r4,2
 90c50f0:	01400084 	movi	r5,2
 90c50f4:	000d883a 	mov	r6,zero
 90c50f8:	90ac5840 	call	90ac584 <t_socket>
 90c50fc:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 90c5100:	e0bee517 	ldw	r2,-1132(fp)
 90c5104:	10bfffd8 	cmpnei	r2,r2,-1
 90c5108:	1000091e 	bne	r2,zero,90c5130 <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 90c510c:	e13ee517 	ldw	r4,-1132(fp)
 90c5110:	90adc980 	call	90adc98 <t_errno>
 90c5114:	100d883a 	mov	r6,r2
 90c5118:	e13fff17 	ldw	r4,-4(fp)
 90c511c:	01424374 	movhi	r5,2317
 90c5120:	2941be04 	addi	r5,r5,1784
 90c5124:	90a45b40 	call	90a45b4 <ns_printf>
      exit(1);
 90c5128:	01000044 	movi	r4,1
 90c512c:	90ca4e00 	call	90ca4e0 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 90c5130:	00800044 	movi	r2,1
 90c5134:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 90c5138:	e1fffa04 	addi	r7,fp,-24
 90c513c:	00800104 	movi	r2,4
 90c5140:	d8800015 	stw	r2,0(sp)
 90c5144:	e13ee517 	ldw	r4,-1132(fp)
 90c5148:	017fffc4 	movi	r5,-1
 90c514c:	01800104 	movi	r6,4
 90c5150:	90ad0380 	call	90ad038 <t_setsockopt>
 90c5154:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c5158:	e0bee317 	ldw	r2,-1140(fp)
 90c515c:	10bfffd8 	cmpnei	r2,r2,-1
 90c5160:	1000071e 	bne	r2,zero,90c5180 <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 90c5164:	e13ee517 	ldw	r4,-1132(fp)
 90c5168:	90adc980 	call	90adc98 <t_errno>
 90c516c:	100d883a 	mov	r6,r2
 90c5170:	e13fff17 	ldw	r4,-4(fp)
 90c5174:	01424374 	movhi	r5,2317
 90c5178:	2941c504 	addi	r5,r5,1812
 90c517c:	90a45b40 	call	90a45b4 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 90c5180:	00800084 	movi	r2,2
 90c5184:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 90c5188:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 90c518c:	00a00344 	movi	r2,-32755
 90c5190:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 90c5194:	e17ee604 	addi	r5,fp,-1128
 90c5198:	e13ee517 	ldw	r4,-1132(fp)
 90c519c:	01800404 	movi	r6,16
 90c51a0:	90ac6140 	call	90ac614 <t_bind>
 90c51a4:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c51a8:	e0bee317 	ldw	r2,-1140(fp)
 90c51ac:	10bfffd8 	cmpnei	r2,r2,-1
 90c51b0:	1000061e 	bne	r2,zero,90c51cc <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 90c51b4:	e13ee517 	ldw	r4,-1132(fp)
 90c51b8:	90adc980 	call	90adc98 <t_errno>
 90c51bc:	100b883a 	mov	r5,r2
 90c51c0:	01024374 	movhi	r4,2317
 90c51c4:	2101d104 	addi	r4,r4,1860
 90c51c8:	90825100 	call	9082510 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 90c51cc:	e13fff17 	ldw	r4,-4(fp)
 90c51d0:	01424374 	movhi	r5,2317
 90c51d4:	2941d804 	addi	r5,r5,1888
 90c51d8:	01824374 	movhi	r6,2317
 90c51dc:	3181e004 	addi	r6,r6,1920
 90c51e0:	90a45b40 	call	90a45b4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 90c51e4:	01024374 	movhi	r4,2317
 90c51e8:	2101e004 	addi	r4,r4,1920
 90c51ec:	90c62400 	call	90c6240 <inet_addr>
 90c51f0:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c51f4:	008243b4 	movhi	r2,2318
 90c51f8:	10b35e04 	addi	r2,r2,-12936
 90c51fc:	10800a17 	ldw	r2,40(r2)
 90c5200:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 90c5204:	e1fffb04 	addi	r7,fp,-20
 90c5208:	00800204 	movi	r2,8
 90c520c:	d8800015 	stw	r2,0(sp)
 90c5210:	e13ee517 	ldw	r4,-1132(fp)
 90c5214:	000b883a 	mov	r5,zero
 90c5218:	01800304 	movi	r6,12
 90c521c:	90ad0380 	call	90ad038 <t_setsockopt>
 90c5220:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c5224:	e0bee317 	ldw	r2,-1140(fp)
 90c5228:	10bfffd8 	cmpnei	r2,r2,-1
 90c522c:	1000071e 	bne	r2,zero,90c524c <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c5230:	e13ee517 	ldw	r4,-1132(fp)
 90c5234:	90adc980 	call	90adc98 <t_errno>
 90c5238:	100d883a 	mov	r6,r2
 90c523c:	e13fff17 	ldw	r4,-4(fp)
 90c5240:	01424374 	movhi	r5,2317
 90c5244:	2941e304 	addi	r5,r5,1932
 90c5248:	90a45b40 	call	90a45b4 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 90c524c:	90a501c0 	call	90a501c <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 90c5250:	e13fff17 	ldw	r4,-4(fp)
 90c5254:	01424374 	movhi	r5,2317
 90c5258:	2941d804 	addi	r5,r5,1888
 90c525c:	01824374 	movhi	r6,2317
 90c5260:	3181f004 	addi	r6,r6,1984
 90c5264:	90a45b40 	call	90a45b4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 90c5268:	01024374 	movhi	r4,2317
 90c526c:	2101f004 	addi	r4,r4,1984
 90c5270:	90c62400 	call	90c6240 <inet_addr>
 90c5274:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c5278:	008243b4 	movhi	r2,2318
 90c527c:	10b35e04 	addi	r2,r2,-12936
 90c5280:	10800a17 	ldw	r2,40(r2)
 90c5284:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 90c5288:	e1fffb04 	addi	r7,fp,-20
 90c528c:	00800204 	movi	r2,8
 90c5290:	d8800015 	stw	r2,0(sp)
 90c5294:	e13ee517 	ldw	r4,-1132(fp)
 90c5298:	000b883a 	mov	r5,zero
 90c529c:	01800304 	movi	r6,12
 90c52a0:	90ad0380 	call	90ad038 <t_setsockopt>
 90c52a4:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c52a8:	e0bee317 	ldw	r2,-1140(fp)
 90c52ac:	10bfffd8 	cmpnei	r2,r2,-1
 90c52b0:	1000071e 	bne	r2,zero,90c52d0 <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c52b4:	e13ee517 	ldw	r4,-1132(fp)
 90c52b8:	90adc980 	call	90adc98 <t_errno>
 90c52bc:	100d883a 	mov	r6,r2
 90c52c0:	e13fff17 	ldw	r4,-4(fp)
 90c52c4:	01424374 	movhi	r5,2317
 90c52c8:	2941e304 	addi	r5,r5,1932
 90c52cc:	90a45b40 	call	90a45b4 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 90c52d0:	90a501c0 	call	90a501c <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 90c52d4:	e13fff17 	ldw	r4,-4(fp)
 90c52d8:	01424374 	movhi	r5,2317
 90c52dc:	2941d804 	addi	r5,r5,1888
 90c52e0:	01824374 	movhi	r6,2317
 90c52e4:	3181f304 	addi	r6,r6,1996
 90c52e8:	90a45b40 	call	90a45b4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 90c52ec:	01024374 	movhi	r4,2317
 90c52f0:	2101f304 	addi	r4,r4,1996
 90c52f4:	90c62400 	call	90c6240 <inet_addr>
 90c52f8:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c52fc:	008243b4 	movhi	r2,2318
 90c5300:	10b35e04 	addi	r2,r2,-12936
 90c5304:	10800a17 	ldw	r2,40(r2)
 90c5308:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 90c530c:	e1fffb04 	addi	r7,fp,-20
 90c5310:	00800204 	movi	r2,8
 90c5314:	d8800015 	stw	r2,0(sp)
 90c5318:	e13ee517 	ldw	r4,-1132(fp)
 90c531c:	000b883a 	mov	r5,zero
 90c5320:	01800304 	movi	r6,12
 90c5324:	90ad0380 	call	90ad038 <t_setsockopt>
 90c5328:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c532c:	e0bee317 	ldw	r2,-1140(fp)
 90c5330:	10bfffd8 	cmpnei	r2,r2,-1
 90c5334:	1000071e 	bne	r2,zero,90c5354 <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c5338:	e13ee517 	ldw	r4,-1132(fp)
 90c533c:	90adc980 	call	90adc98 <t_errno>
 90c5340:	100d883a 	mov	r6,r2
 90c5344:	e13fff17 	ldw	r4,-4(fp)
 90c5348:	01424374 	movhi	r5,2317
 90c534c:	2941e304 	addi	r5,r5,1932
 90c5350:	90a45b40 	call	90a45b4 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 90c5354:	90a501c0 	call	90a501c <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 90c5358:	00800084 	movi	r2,2
 90c535c:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 90c5360:	e1fffd04 	addi	r7,fp,-12
 90c5364:	00800044 	movi	r2,1
 90c5368:	d8800015 	stw	r2,0(sp)
 90c536c:	e13ee517 	ldw	r4,-1132(fp)
 90c5370:	000b883a 	mov	r5,zero
 90c5374:	01800284 	movi	r6,10
 90c5378:	90ad0380 	call	90ad038 <t_setsockopt>
 90c537c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c5380:	e0bee317 	ldw	r2,-1140(fp)
 90c5384:	10bfffd8 	cmpnei	r2,r2,-1
 90c5388:	1000071e 	bne	r2,zero,90c53a8 <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 90c538c:	e13ee517 	ldw	r4,-1132(fp)
 90c5390:	90adc980 	call	90adc98 <t_errno>
 90c5394:	100d883a 	mov	r6,r2
 90c5398:	e13fff17 	ldw	r4,-4(fp)
 90c539c:	01424374 	movhi	r5,2317
 90c53a0:	2941f604 	addi	r5,r5,2008
 90c53a4:	90a45b40 	call	90a45b4 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 90c53a8:	00800044 	movi	r2,1
 90c53ac:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 90c53b0:	e1fffd04 	addi	r7,fp,-12
 90c53b4:	00800044 	movi	r2,1
 90c53b8:	d8800015 	stw	r2,0(sp)
 90c53bc:	e13ee517 	ldw	r4,-1132(fp)
 90c53c0:	000b883a 	mov	r5,zero
 90c53c4:	018002c4 	movi	r6,11
 90c53c8:	90ad0380 	call	90ad038 <t_setsockopt>
 90c53cc:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c53d0:	e0bee317 	ldw	r2,-1140(fp)
 90c53d4:	10bfffd8 	cmpnei	r2,r2,-1
 90c53d8:	1000071e 	bne	r2,zero,90c53f8 <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 90c53dc:	e13ee517 	ldw	r4,-1132(fp)
 90c53e0:	90adc980 	call	90adc98 <t_errno>
 90c53e4:	100d883a 	mov	r6,r2
 90c53e8:	e13fff17 	ldw	r4,-4(fp)
 90c53ec:	01424374 	movhi	r5,2317
 90c53f0:	29420304 	addi	r5,r5,2060
 90c53f4:	90a45b40 	call	90a45b4 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 90c53f8:	00800084 	movi	r2,2
 90c53fc:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 90c5400:	01024374 	movhi	r4,2317
 90c5404:	2101f004 	addi	r4,r4,1984
 90c5408:	90c62400 	call	90c6240 <inet_addr>
 90c540c:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 90c5410:	00a00344 	movi	r2,-32755
 90c5414:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 90c5418:	e13fff17 	ldw	r4,-4(fp)
 90c541c:	01424374 	movhi	r5,2317
 90c5420:	29421004 	addi	r5,r5,2112
 90c5424:	01824374 	movhi	r6,2317
 90c5428:	3181f004 	addi	r6,r6,1984
 90c542c:	90a45b40 	call	90a45b4 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 90c5430:	e03ee415 	stw	zero,-1136(fp)
 90c5434:	00009406 	br	90c5688 <u_mctest_run+0x5f8>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 90c5438:	e0bff204 	addi	r2,fp,-56
 90c543c:	11000404 	addi	r4,r2,16
 90c5440:	d0a05217 	ldw	r2,-32440(gp)
 90c5444:	100d883a 	mov	r6,r2
 90c5448:	10800044 	addi	r2,r2,1
 90c544c:	d0a05215 	stw	r2,-32440(gp)
 90c5450:	01424374 	movhi	r5,2317
 90c5454:	29421f04 	addi	r5,r5,2172
 90c5458:	90828ac0 	call	90828ac <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 90c545c:	e0beea04 	addi	r2,fp,-1112
 90c5460:	e17ff204 	addi	r5,fp,-56
 90c5464:	d8800015 	stw	r2,0(sp)
 90c5468:	00800404 	movi	r2,16
 90c546c:	d8800115 	stw	r2,4(sp)
 90c5470:	e13ee517 	ldw	r4,-1132(fp)
 90c5474:	01800784 	movi	r6,30
 90c5478:	000f883a 	mov	r7,zero
 90c547c:	90ad5f80 	call	90ad5f8 <t_sendto>
 90c5480:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 90c5484:	e0bee317 	ldw	r2,-1140(fp)
 90c5488:	1004403a 	cmpge	r2,r2,zero
 90c548c:	1000081e 	bne	r2,zero,90c54b0 <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 90c5490:	e13ee517 	ldw	r4,-1132(fp)
 90c5494:	90adc980 	call	90adc98 <t_errno>
 90c5498:	100d883a 	mov	r6,r2
 90c549c:	e13fff17 	ldw	r4,-4(fp)
 90c54a0:	01424374 	movhi	r5,2317
 90c54a4:	29422004 	addi	r5,r5,2176
 90c54a8:	90a45b40 	call	90a45b4 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 90c54ac:	00007906 	br	90c5694 <u_mctest_run+0x604>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 90c54b0:	00800044 	movi	r2,1
 90c54b4:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 90c54b8:	e1fffa04 	addi	r7,fp,-24
 90c54bc:	00800104 	movi	r2,4
 90c54c0:	d8800015 	stw	r2,0(sp)
 90c54c4:	e13ee517 	ldw	r4,-1132(fp)
 90c54c8:	017fffc4 	movi	r5,-1
 90c54cc:	01840584 	movi	r6,4118
 90c54d0:	90ad0380 	call	90ad038 <t_setsockopt>
 90c54d4:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 90c54d8:	e0bee317 	ldw	r2,-1140(fp)
 90c54dc:	10bfffd8 	cmpnei	r2,r2,-1
 90c54e0:	1000071e 	bne	r2,zero,90c5500 <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 90c54e4:	e13ee517 	ldw	r4,-1132(fp)
 90c54e8:	90adc980 	call	90adc98 <t_errno>
 90c54ec:	100d883a 	mov	r6,r2
 90c54f0:	e13fff17 	ldw	r4,-4(fp)
 90c54f4:	01424374 	movhi	r5,2317
 90c54f8:	29422804 	addi	r5,r5,2208
 90c54fc:	90a45b40 	call	90a45b4 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 90c5500:	00824374 	movhi	r2,2317
 90c5504:	108c4204 	addi	r2,r2,12552
 90c5508:	11000017 	ldw	r4,0(r2)
 90c550c:	908c0380 	call	908c038 <__floatunsidf>
 90c5510:	100b883a 	mov	r5,r2
 90c5514:	180d883a 	mov	r6,r3
 90c5518:	2809883a 	mov	r4,r5
 90c551c:	300b883a 	mov	r5,r6
 90c5520:	000d883a 	mov	r6,zero
 90c5524:	01d01ff4 	movhi	r7,16511
 90c5528:	39d00004 	addi	r7,r7,16384
 90c552c:	908b5400 	call	908b540 <__adddf3>
 90c5530:	1009883a 	mov	r4,r2
 90c5534:	180b883a 	mov	r5,r3
 90c5538:	2005883a 	mov	r2,r4
 90c553c:	2807883a 	mov	r3,r5
 90c5540:	1009883a 	mov	r4,r2
 90c5544:	180b883a 	mov	r5,r3
 90c5548:	90cade40 	call	90cade4 <__fixunsdfsi>
 90c554c:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 90c5550:	00003206 	br	90c561c <u_mctest_run+0x58c>
      {
         int sa_size = sizeof(struct sockaddr_in);
 90c5554:	00800404 	movi	r2,16
 90c5558:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 90c555c:	90a501c0 	call	90a501c <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 90c5560:	e0beee04 	addi	r2,fp,-1096
 90c5564:	e17ef204 	addi	r5,fp,-1080
 90c5568:	d8800015 	stw	r2,0(sp)
 90c556c:	e0bffe04 	addi	r2,fp,-8
 90c5570:	d8800115 	stw	r2,4(sp)
 90c5574:	e13ee517 	ldw	r4,-1132(fp)
 90c5578:	01810004 	movi	r6,1024
 90c557c:	000f883a 	mov	r7,zero
 90c5580:	90ad4a80 	call	90ad4a8 <t_recvfrom>
 90c5584:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 90c5588:	e0bee317 	ldw	r2,-1140(fp)
 90c558c:	1004403a 	cmpge	r2,r2,zero
 90c5590:	10000c1e 	bne	r2,zero,90c55c4 <u_mctest_run+0x534>
         {
            if (t_errno(s) != EWOULDBLOCK)
 90c5594:	e13ee517 	ldw	r4,-1132(fp)
 90c5598:	90adc980 	call	90adc98 <t_errno>
 90c559c:	108002e0 	cmpeqi	r2,r2,11
 90c55a0:	1000081e 	bne	r2,zero,90c55c4 <u_mctest_run+0x534>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 90c55a4:	e13ee517 	ldw	r4,-1132(fp)
 90c55a8:	90adc980 	call	90adc98 <t_errno>
 90c55ac:	100d883a 	mov	r6,r2
 90c55b0:	e13fff17 	ldw	r4,-4(fp)
 90c55b4:	01424374 	movhi	r5,2317
 90c55b8:	29423404 	addi	r5,r5,2256
 90c55bc:	90a45b40 	call	90a45b4 <ns_printf>
               /*     exit(1); */
               goto exitloop;
 90c55c0:	00003406 	br	90c5694 <u_mctest_run+0x604>
            }
         }
         if (iRet > 0)
 90c55c4:	e0bee317 	ldw	r2,-1140(fp)
 90c55c8:	10800050 	cmplti	r2,r2,1
 90c55cc:	1000131e 	bne	r2,zero,90c561c <u_mctest_run+0x58c>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 90c55d0:	e13eef17 	ldw	r4,-1092(fp)
 90c55d4:	90a415c0 	call	90a415c <print_ipad>
 90c55d8:	100d883a 	mov	r6,r2
 90c55dc:	e0beee8b 	ldhu	r2,-1094(fp)
 90c55e0:	10bfffcc 	andi	r2,r2,65535
 90c55e4:	1004d23a 	srli	r2,r2,8
 90c55e8:	10bfffcc 	andi	r2,r2,65535
 90c55ec:	10c03fcc 	andi	r3,r2,255
 90c55f0:	e0beee8b 	ldhu	r2,-1094(fp)
 90c55f4:	10bfffcc 	andi	r2,r2,65535
 90c55f8:	1004923a 	slli	r2,r2,8
 90c55fc:	10bfc00c 	andi	r2,r2,65280
 90c5600:	188eb03a 	or	r7,r3,r2
 90c5604:	e0bef204 	addi	r2,fp,-1080
 90c5608:	d8800015 	stw	r2,0(sp)
 90c560c:	e13fff17 	ldw	r4,-4(fp)
 90c5610:	01424374 	movhi	r5,2317
 90c5614:	29423c04 	addi	r5,r5,2288
 90c5618:	90a45b40 	call	90a45b4 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 90c561c:	00824374 	movhi	r2,2317
 90c5620:	108c4204 	addi	r2,r2,12552
 90c5624:	10c00017 	ldw	r3,0(r2)
 90c5628:	e0bee217 	ldw	r2,-1144(fp)
 90c562c:	18bfc936 	bltu	r3,r2,90c5554 <u_mctest_run+0x4c4>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 90c5630:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 90c5634:	e1fffd04 	addi	r7,fp,-12
 90c5638:	00800044 	movi	r2,1
 90c563c:	d8800015 	stw	r2,0(sp)
 90c5640:	e13ee517 	ldw	r4,-1132(fp)
 90c5644:	017fffc4 	movi	r5,-1
 90c5648:	01840584 	movi	r6,4118
 90c564c:	90ad0380 	call	90ad038 <t_setsockopt>
 90c5650:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 90c5654:	e0bee317 	ldw	r2,-1140(fp)
 90c5658:	10bfffd8 	cmpnei	r2,r2,-1
 90c565c:	1000071e 	bne	r2,zero,90c567c <u_mctest_run+0x5ec>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 90c5660:	e13ee517 	ldw	r4,-1132(fp)
 90c5664:	90adc980 	call	90adc98 <t_errno>
 90c5668:	100d883a 	mov	r6,r2
 90c566c:	e13fff17 	ldw	r4,-4(fp)
 90c5670:	01424374 	movhi	r5,2317
 90c5674:	29424304 	addi	r5,r5,2316
 90c5678:	90a45b40 	call	90a45b4 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 90c567c:	e0bee417 	ldw	r2,-1136(fp)
 90c5680:	10800044 	addi	r2,r2,1
 90c5684:	e0bee415 	stw	r2,-1136(fp)
 90c5688:	e0bee417 	ldw	r2,-1136(fp)
 90c568c:	108000d0 	cmplti	r2,r2,3
 90c5690:	103f691e 	bne	r2,zero,90c5438 <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 90c5694:	01024374 	movhi	r4,2317
 90c5698:	2101e004 	addi	r4,r4,1920
 90c569c:	90c62400 	call	90c6240 <inet_addr>
 90c56a0:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c56a4:	008243b4 	movhi	r2,2318
 90c56a8:	10b35e04 	addi	r2,r2,-12936
 90c56ac:	10800a17 	ldw	r2,40(r2)
 90c56b0:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 90c56b4:	e1fffb04 	addi	r7,fp,-20
 90c56b8:	00800204 	movi	r2,8
 90c56bc:	d8800015 	stw	r2,0(sp)
 90c56c0:	e13ee517 	ldw	r4,-1132(fp)
 90c56c4:	000b883a 	mov	r5,zero
 90c56c8:	01800344 	movi	r6,13
 90c56cc:	90ad0380 	call	90ad038 <t_setsockopt>
 90c56d0:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c56d4:	e0bee317 	ldw	r2,-1140(fp)
 90c56d8:	10bfffd8 	cmpnei	r2,r2,-1
 90c56dc:	1000071e 	bne	r2,zero,90c56fc <u_mctest_run+0x66c>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 90c56e0:	e13ee517 	ldw	r4,-1132(fp)
 90c56e4:	90adc980 	call	90adc98 <t_errno>
 90c56e8:	100d883a 	mov	r6,r2
 90c56ec:	e13fff17 	ldw	r4,-4(fp)
 90c56f0:	01424374 	movhi	r5,2317
 90c56f4:	29424f04 	addi	r5,r5,2364
 90c56f8:	90a45b40 	call	90a45b4 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 90c56fc:	e13ee517 	ldw	r4,-1132(fp)
 90c5700:	90adb300 	call	90adb30 <t_socketclose>
 90c5704:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c5708:	e0bee317 	ldw	r2,-1140(fp)
 90c570c:	10bfffd8 	cmpnei	r2,r2,-1
 90c5710:	1000071e 	bne	r2,zero,90c5730 <u_mctest_run+0x6a0>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 90c5714:	e13ee517 	ldw	r4,-1132(fp)
 90c5718:	90adc980 	call	90adc98 <t_errno>
 90c571c:	100d883a 	mov	r6,r2
 90c5720:	e13fff17 	ldw	r4,-4(fp)
 90c5724:	01424374 	movhi	r5,2317
 90c5728:	29425c04 	addi	r5,r5,2416
 90c572c:	90a45b40 	call	90a45b4 <ns_printf>
   }

   return(0);
 90c5730:	0005883a 	mov	r2,zero
}  /* end main() */  
 90c5734:	e037883a 	mov	sp,fp
 90c5738:	dfc00117 	ldw	ra,4(sp)
 90c573c:	df000017 	ldw	fp,0(sp)
 90c5740:	dec00204 	addi	sp,sp,8
 90c5744:	f800283a 	ret

090c5748 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 90c5748:	defff504 	addi	sp,sp,-44
 90c574c:	dfc00a15 	stw	ra,40(sp)
 90c5750:	df000915 	stw	fp,36(sp)
 90c5754:	df000904 	addi	fp,sp,36
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 90c5758:	e03ff715 	stw	zero,-36(fp)

   e = dhc_init();
 90c575c:	90a52e00 	call	90a52e0 <dhc_init>
 90c5760:	e0bff815 	stw	r2,-32(fp)

   if (e)
 90c5764:	e0bff817 	ldw	r2,-32(fp)
 90c5768:	1005003a 	cmpeq	r2,r2,zero
 90c576c:	1000051e 	bne	r2,zero,90c5784 <dhc_setup+0x3c>
   {
      printf("Error starting DHCP client code.\n");
 90c5770:	01024374 	movhi	r4,2317
 90c5774:	21026d04 	addi	r4,r4,2484
 90c5778:	90828380 	call	9082838 <puts>
      netexit(1);
 90c577c:	01000044 	movi	r4,1
 90c5780:	90c21e80 	call	90c21e8 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 90c5784:	00824374 	movhi	r2,2317
 90c5788:	108c4204 	addi	r2,r2,12552
 90c578c:	10800017 	ldw	r2,0(r2)
 90c5790:	e0bff915 	stw	r2,-28(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 90c5794:	e03ffa15 	stw	zero,-24(fp)
 90c5798:	00005106 	br	90c58e0 <dhc_setup+0x198>
   {
      if (!nets[iface])
 90c579c:	e0bffa17 	ldw	r2,-24(fp)
 90c57a0:	00c243b4 	movhi	r3,2318
 90c57a4:	18f41e04 	addi	r3,r3,-12168
 90c57a8:	1085883a 	add	r2,r2,r2
 90c57ac:	1085883a 	add	r2,r2,r2
 90c57b0:	10c5883a 	add	r2,r2,r3
 90c57b4:	10800017 	ldw	r2,0(r2)
 90c57b8:	1005003a 	cmpeq	r2,r2,zero
 90c57bc:	1000451e 	bne	r2,zero,90c58d4 <dhc_setup+0x18c>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 90c57c0:	e0bffa17 	ldw	r2,-24(fp)
 90c57c4:	00c243b4 	movhi	r3,2318
 90c57c8:	18f41e04 	addi	r3,r3,-12168
 90c57cc:	1085883a 	add	r2,r2,r2
 90c57d0:	1085883a 	add	r2,r2,r2
 90c57d4:	10c5883a 	add	r2,r2,r3
 90c57d8:	10800017 	ldw	r2,0(r2)
 90c57dc:	10802a17 	ldw	r2,168(r2)
 90c57e0:	1080400c 	andi	r2,r2,256
 90c57e4:	1005003a 	cmpeq	r2,r2,zero
 90c57e8:	10003a1e 	bne	r2,zero,90c58d4 <dhc_setup+0x18c>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 90c57ec:	e0bffa17 	ldw	r2,-24(fp)
 90c57f0:	00c243b4 	movhi	r3,2318
 90c57f4:	18f44404 	addi	r3,r3,-12016
 90c57f8:	10800f24 	muli	r2,r2,60
 90c57fc:	10c5883a 	add	r2,r2,r3
 90c5800:	10800e04 	addi	r2,r2,56
 90c5804:	10800017 	ldw	r2,0(r2)
 90c5808:	1004c03a 	cmpne	r2,r2,zero
 90c580c:	1000041e 	bne	r2,zero,90c5820 <dhc_setup+0xd8>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 90c5810:	e13ffa17 	ldw	r4,-24(fp)
 90c5814:	01424334 	movhi	r5,2316
 90c5818:	29568504 	addi	r5,r5,23060
 90c581c:	90a539c0 	call	90a539c <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 90c5820:	e13ffa17 	ldw	r4,-24(fp)
 90c5824:	e0bffa17 	ldw	r2,-24(fp)
 90c5828:	00c243b4 	movhi	r3,2318
 90c582c:	18f41e04 	addi	r3,r3,-12168
 90c5830:	1085883a 	add	r2,r2,r2
 90c5834:	1085883a 	add	r2,r2,r2
 90c5838:	10c5883a 	add	r2,r2,r3
 90c583c:	10800017 	ldw	r2,0(r2)
 90c5840:	10c00a17 	ldw	r3,40(r2)
 90c5844:	2105883a 	add	r2,r4,r4
 90c5848:	1085883a 	add	r2,r2,r2
 90c584c:	e13ff704 	addi	r4,fp,-36
 90c5850:	1105883a 	add	r2,r2,r4
 90c5854:	10800404 	addi	r2,r2,16
 90c5858:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 90c585c:	e0bffa17 	ldw	r2,-24(fp)
 90c5860:	1085883a 	add	r2,r2,r2
 90c5864:	1085883a 	add	r2,r2,r2
 90c5868:	e0fff704 	addi	r3,fp,-36
 90c586c:	10c5883a 	add	r2,r2,r3
 90c5870:	10800404 	addi	r2,r2,16
 90c5874:	10800017 	ldw	r2,0(r2)
 90c5878:	1004c03a 	cmpne	r2,r2,zero
 90c587c:	1000041e 	bne	r2,zero,90c5890 <dhc_setup+0x148>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 90c5880:	e13ffa17 	ldw	r4,-24(fp)
 90c5884:	01400044 	movi	r5,1
 90c5888:	90a82d40 	call	90a82d4 <dhc_state_init>
 90c588c:	00000306 	br	90c589c <dhc_setup+0x154>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 90c5890:	e13ffa17 	ldw	r4,-24(fp)
 90c5894:	000b883a 	mov	r5,zero
 90c5898:	90a82d40 	call	90a82d4 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 90c589c:	90a77a00 	call	90a77a0 <dhc_second>
 90c58a0:	e0bff815 	stw	r2,-32(fp)
      if (e)
 90c58a4:	e0bff817 	ldw	r2,-32(fp)
 90c58a8:	1005003a 	cmpeq	r2,r2,zero
 90c58ac:	1000061e 	bne	r2,zero,90c58c8 <dhc_setup+0x180>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 90c58b0:	01024374 	movhi	r4,2317
 90c58b4:	21027604 	addi	r4,r4,2520
 90c58b8:	e17ffa17 	ldw	r5,-24(fp)
 90c58bc:	90825100 	call	9082510 <printf>
         netexit(1);
 90c58c0:	01000044 	movi	r4,1
 90c58c4:	90c21e80 	call	90c21e8 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 90c58c8:	e0bff717 	ldw	r2,-36(fp)
 90c58cc:	10800044 	addi	r2,r2,1
 90c58d0:	e0bff715 	stw	r2,-36(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 90c58d4:	e0bffa17 	ldw	r2,-24(fp)
 90c58d8:	10800044 	addi	r2,r2,1
 90c58dc:	e0bffa15 	stw	r2,-24(fp)
 90c58e0:	e0bffa17 	ldw	r2,-24(fp)
 90c58e4:	10800110 	cmplti	r2,r2,4
 90c58e8:	103fac1e 	bne	r2,zero,90c579c <dhc_setup+0x54>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 90c58ec:	e0bff717 	ldw	r2,-36(fp)
 90c58f0:	1005003a 	cmpeq	r2,r2,zero
 90c58f4:	1000421e 	bne	r2,zero,90c5a00 <dhc_setup+0x2b8>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 90c58f8:	00000206 	br	90c5904 <dhc_setup+0x1bc>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 90c58fc:	90a501c0 	call	90a501c <tk_yield>
      pktdemux();
 90c5900:	90a16b00 	call	90a16b0 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 90c5904:	00824374 	movhi	r2,2317
 90c5908:	108c4204 	addi	r2,r2,12552
 90c590c:	10c00017 	ldw	r3,0(r2)
 90c5910:	e0bff917 	ldw	r2,-28(fp)
 90c5914:	1889c83a 	sub	r4,r3,r2
 90c5918:	908c0380 	call	908c038 <__floatunsidf>
 90c591c:	100b883a 	mov	r5,r2
 90c5920:	180d883a 	mov	r6,r3
 90c5924:	e03fff05 	stb	zero,-4(fp)
 90c5928:	2809883a 	mov	r4,r5
 90c592c:	300b883a 	mov	r5,r6
 90c5930:	000d883a 	mov	r6,zero
 90c5934:	01d03274 	movhi	r7,16585
 90c5938:	39d90004 	addi	r7,r7,25600
 90c593c:	908bde00 	call	908bde0 <__ltdf2>
 90c5940:	1004803a 	cmplt	r2,r2,zero
 90c5944:	1000011e 	bne	r2,zero,90c594c <dhc_setup+0x204>
 90c5948:	00000206 	br	90c5954 <dhc_setup+0x20c>
 90c594c:	01000044 	movi	r4,1
 90c5950:	e13fff05 	stb	r4,-4(fp)
 90c5954:	e0ffff03 	ldbu	r3,-4(fp)
 90c5958:	1880005c 	xori	r2,r3,1
 90c595c:	10803fcc 	andi	r2,r2,255
 90c5960:	1004c03a 	cmpne	r2,r2,zero
 90c5964:	1000031e 	bne	r2,zero,90c5974 <dhc_setup+0x22c>
 90c5968:	90a83340 	call	90a8334 <dhc_alldone>
 90c596c:	1005003a 	cmpeq	r2,r2,zero
 90c5970:	103fe21e 	bne	r2,zero,90c58fc <dhc_setup+0x1b4>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 90c5974:	90a83340 	call	90a8334 <dhc_alldone>
 90c5978:	1004c03a 	cmpne	r2,r2,zero
 90c597c:	1000201e 	bne	r2,zero,90c5a00 <dhc_setup+0x2b8>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 90c5980:	01024374 	movhi	r4,2317
 90c5984:	21028004 	addi	r4,r4,2560
 90c5988:	90828380 	call	9082838 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 90c598c:	e03ffa15 	stw	zero,-24(fp)
 90c5990:	00001806 	br	90c59f4 <dhc_setup+0x2ac>
      {
         if (dhc_ifacedone(iface) == FALSE)
 90c5994:	e13ffa17 	ldw	r4,-24(fp)
 90c5998:	90a83c40 	call	90a83c4 <dhc_ifacedone>
 90c599c:	1004c03a 	cmpne	r2,r2,zero
 90c59a0:	1000111e 	bne	r2,zero,90c59e8 <dhc_setup+0x2a0>
         {
            dhc_halt(iface);
 90c59a4:	e13ffa17 	ldw	r4,-24(fp)
 90c59a8:	90a807c0 	call	90a807c <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 90c59ac:	e0bffa17 	ldw	r2,-24(fp)
 90c59b0:	00c243b4 	movhi	r3,2318
 90c59b4:	18f41e04 	addi	r3,r3,-12168
 90c59b8:	1085883a 	add	r2,r2,r2
 90c59bc:	1085883a 	add	r2,r2,r2
 90c59c0:	10c5883a 	add	r2,r2,r3
 90c59c4:	10c00017 	ldw	r3,0(r2)
 90c59c8:	e0bffa17 	ldw	r2,-24(fp)
 90c59cc:	1085883a 	add	r2,r2,r2
 90c59d0:	1085883a 	add	r2,r2,r2
 90c59d4:	e13ff704 	addi	r4,fp,-36
 90c59d8:	1105883a 	add	r2,r2,r4
 90c59dc:	10800404 	addi	r2,r2,16
 90c59e0:	10800017 	ldw	r2,0(r2)
 90c59e4:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 90c59e8:	e0bffa17 	ldw	r2,-24(fp)
 90c59ec:	10800044 	addi	r2,r2,1
 90c59f0:	e0bffa15 	stw	r2,-24(fp)
 90c59f4:	e0bffa17 	ldw	r2,-24(fp)
 90c59f8:	10800110 	cmplti	r2,r2,4
 90c59fc:	103fe51e 	bne	r2,zero,90c5994 <dhc_setup+0x24c>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 90c5a00:	e037883a 	mov	sp,fp
 90c5a04:	dfc00117 	ldw	ra,4(sp)
 90c5a08:	df000017 	ldw	fp,0(sp)
 90c5a0c:	dec00204 	addi	sp,sp,8
 90c5a10:	f800283a 	ret

090c5a14 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 90c5a14:	defffc04 	addi	sp,sp,-16
 90c5a18:	dfc00315 	stw	ra,12(sp)
 90c5a1c:	df000215 	stw	fp,8(sp)
 90c5a20:	df000204 	addi	fp,sp,8
 90c5a24:	e13ffe15 	stw	r4,-8(fp)
 90c5a28:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 90c5a2c:	e0bfff17 	ldw	r2,-4(fp)
 90c5a30:	10800198 	cmpnei	r2,r2,6
 90c5a34:	1000321e 	bne	r2,zero,90c5b00 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 90c5a38:	e0bffe17 	ldw	r2,-8(fp)
 90c5a3c:	00c243b4 	movhi	r3,2318
 90c5a40:	18f41e04 	addi	r3,r3,-12168
 90c5a44:	1085883a 	add	r2,r2,r2
 90c5a48:	1085883a 	add	r2,r2,r2
 90c5a4c:	10c5883a 	add	r2,r2,r3
 90c5a50:	10800017 	ldw	r2,0(r2)
 90c5a54:	11400104 	addi	r5,r2,4
 90c5a58:	01024374 	movhi	r4,2317
 90c5a5c:	21028e04 	addi	r4,r4,2616
 90c5a60:	90825100 	call	9082510 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 90c5a64:	e0bffe17 	ldw	r2,-8(fp)
 90c5a68:	00c243b4 	movhi	r3,2318
 90c5a6c:	18f41e04 	addi	r3,r3,-12168
 90c5a70:	1085883a 	add	r2,r2,r2
 90c5a74:	1085883a 	add	r2,r2,r2
 90c5a78:	10c5883a 	add	r2,r2,r3
 90c5a7c:	10800017 	ldw	r2,0(r2)
 90c5a80:	11000a17 	ldw	r4,40(r2)
 90c5a84:	90a415c0 	call	90a415c <print_ipad>
 90c5a88:	100b883a 	mov	r5,r2
 90c5a8c:	01024374 	movhi	r4,2317
 90c5a90:	21029c04 	addi	r4,r4,2672
 90c5a94:	90825100 	call	9082510 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 90c5a98:	e0bffe17 	ldw	r2,-8(fp)
 90c5a9c:	00c243b4 	movhi	r3,2318
 90c5aa0:	18f41e04 	addi	r3,r3,-12168
 90c5aa4:	1085883a 	add	r2,r2,r2
 90c5aa8:	1085883a 	add	r2,r2,r2
 90c5aac:	10c5883a 	add	r2,r2,r3
 90c5ab0:	10800017 	ldw	r2,0(r2)
 90c5ab4:	11000c17 	ldw	r4,48(r2)
 90c5ab8:	90a415c0 	call	90a415c <print_ipad>
 90c5abc:	100b883a 	mov	r5,r2
 90c5ac0:	01024374 	movhi	r4,2317
 90c5ac4:	2102a104 	addi	r4,r4,2692
 90c5ac8:	90825100 	call	9082510 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 90c5acc:	e0bffe17 	ldw	r2,-8(fp)
 90c5ad0:	00c243b4 	movhi	r3,2318
 90c5ad4:	18f41e04 	addi	r3,r3,-12168
 90c5ad8:	1085883a 	add	r2,r2,r2
 90c5adc:	1085883a 	add	r2,r2,r2
 90c5ae0:	10c5883a 	add	r2,r2,r3
 90c5ae4:	10800017 	ldw	r2,0(r2)
 90c5ae8:	11000d17 	ldw	r4,52(r2)
 90c5aec:	90a415c0 	call	90a415c <print_ipad>
 90c5af0:	100b883a 	mov	r5,r2
 90c5af4:	01024374 	movhi	r4,2317
 90c5af8:	2102a604 	addi	r4,r4,2712
 90c5afc:	90825100 	call	9082510 <printf>
   }
   return 0;
 90c5b00:	0005883a 	mov	r2,zero
}
 90c5b04:	e037883a 	mov	sp,fp
 90c5b08:	dfc00117 	ldw	ra,4(sp)
 90c5b0c:	df000017 	ldw	fp,0(sp)
 90c5b10:	dec00204 	addi	sp,sp,8
 90c5b14:	f800283a 	ret

090c5b18 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 90c5b18:	deffff04 	addi	sp,sp,-4
 90c5b1c:	df000015 	stw	fp,0(sp)
 90c5b20:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 90c5b24:	00824374 	movhi	r2,2317
 90c5b28:	108c6e04 	addi	r2,r2,12728
 90c5b2c:	10c00017 	ldw	r3,0(r2)
 90c5b30:	00824374 	movhi	r2,2317
 90c5b34:	108b3f04 	addi	r2,r2,11516
 90c5b38:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 90c5b3c:	00c24374 	movhi	r3,2317
 90c5b40:	18cc6e04 	addi	r3,r3,12728
 90c5b44:	00824374 	movhi	r2,2317
 90c5b48:	108b3f04 	addi	r2,r2,11516
 90c5b4c:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 90c5b50:	00824374 	movhi	r2,2317
 90c5b54:	108c7004 	addi	r2,r2,12736
 90c5b58:	10c00017 	ldw	r3,0(r2)
 90c5b5c:	00824374 	movhi	r2,2317
 90c5b60:	108b4804 	addi	r2,r2,11552
 90c5b64:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 90c5b68:	00c24374 	movhi	r3,2317
 90c5b6c:	18cb6904 	addi	r3,r3,11684
 90c5b70:	00824374 	movhi	r2,2317
 90c5b74:	108c7004 	addi	r2,r2,12736
 90c5b78:	10c00015 	stw	r3,0(r2)

   return 0;
 90c5b7c:	0005883a 	mov	r2,zero
}
 90c5b80:	e037883a 	mov	sp,fp
 90c5b84:	df000017 	ldw	fp,0(sp)
 90c5b88:	dec00104 	addi	sp,sp,4
 90c5b8c:	f800283a 	ret

090c5b90 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 90c5b90:	defffd04 	addi	sp,sp,-12
 90c5b94:	df000215 	stw	fp,8(sp)
 90c5b98:	df000204 	addi	fp,sp,8
 90c5b9c:	e13ffe15 	stw	r4,-8(fp)
 90c5ba0:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 90c5ba4:	0005883a 	mov	r2,zero
}
 90c5ba8:	e037883a 	mov	sp,fp
 90c5bac:	df000017 	ldw	fp,0(sp)
 90c5bb0:	dec00104 	addi	sp,sp,4
 90c5bb4:	f800283a 	ret

090c5bb8 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 90c5bb8:	defffe04 	addi	sp,sp,-8
 90c5bbc:	df000115 	stw	fp,4(sp)
 90c5bc0:	df000104 	addi	fp,sp,4
 90c5bc4:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 90c5bc8:	e037883a 	mov	sp,fp
 90c5bcc:	df000017 	ldw	fp,0(sp)
 90c5bd0:	dec00104 	addi	sp,sp,4
 90c5bd4:	f800283a 	ret

090c5bd8 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c5bd8:	defff604 	addi	sp,sp,-40
 90c5bdc:	dfc00915 	stw	ra,36(sp)
 90c5be0:	df000815 	stw	fp,32(sp)
 90c5be4:	df000804 	addi	fp,sp,32
 90c5be8:	e13ffb15 	stw	r4,-20(fp)
 90c5bec:	e17ffc15 	stw	r5,-16(fp)
 90c5bf0:	e1bffd15 	stw	r6,-12(fp)
 90c5bf4:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 90c5bf8:	00800834 	movhi	r2,32
 90c5bfc:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 90c5c00:	e0bffe17 	ldw	r2,-8(fp)
 90c5c04:	1005003a 	cmpeq	r2,r2,zero
 90c5c08:	1000081e 	bne	r2,zero,90c5c2c <md_fread+0x54>
 90c5c0c:	e0bffe17 	ldw	r2,-8(fp)
 90c5c10:	10800117 	ldw	r2,4(r2)
 90c5c14:	1005003a 	cmpeq	r2,r2,zero
 90c5c18:	1000041e 	bne	r2,zero,90c5c2c <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 90c5c1c:	e0bffe17 	ldw	r2,-8(fp)
 90c5c20:	10800117 	ldw	r2,4(r2)
 90c5c24:	10800717 	ldw	r2,28(r2)
 90c5c28:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 90c5c2c:	e0bffe17 	ldw	r2,-8(fp)
 90c5c30:	10800217 	ldw	r2,8(r2)
 90c5c34:	1007883a 	mov	r3,r2
 90c5c38:	e0bffe17 	ldw	r2,-8(fp)
 90c5c3c:	10800117 	ldw	r2,4(r2)
 90c5c40:	10800617 	ldw	r2,24(r2)
 90c5c44:	1885c83a 	sub	r2,r3,r2
 90c5c48:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 90c5c4c:	e0fffd17 	ldw	r3,-12(fp)
 90c5c50:	e0bffc17 	ldw	r2,-16(fp)
 90c5c54:	1885383a 	mul	r2,r3,r2
 90c5c58:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 90c5c5c:	e0fff917 	ldw	r3,-28(fp)
 90c5c60:	e0bffa17 	ldw	r2,-24(fp)
 90c5c64:	1887883a 	add	r3,r3,r2
 90c5c68:	e0bff817 	ldw	r2,-32(fp)
 90c5c6c:	10c0042e 	bgeu	r2,r3,90c5c80 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 90c5c70:	e0bff817 	ldw	r2,-32(fp)
 90c5c74:	e0fff917 	ldw	r3,-28(fp)
 90c5c78:	10c5c83a 	sub	r2,r2,r3
 90c5c7c:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 90c5c80:	e0fff917 	ldw	r3,-28(fp)
 90c5c84:	e0bff817 	ldw	r2,-32(fp)
 90c5c88:	1880072e 	bgeu	r3,r2,90c5ca8 <md_fread+0xd0>
 90c5c8c:	e0bffa17 	ldw	r2,-24(fp)
 90c5c90:	10bfffec 	andhi	r2,r2,65535
 90c5c94:	1004c03a 	cmpne	r2,r2,zero
 90c5c98:	1000031e 	bne	r2,zero,90c5ca8 <md_fread+0xd0>
 90c5c9c:	e0bffa17 	ldw	r2,-24(fp)
 90c5ca0:	1004c03a 	cmpne	r2,r2,zero
 90c5ca4:	1000021e 	bne	r2,zero,90c5cb0 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 90c5ca8:	e03fff15 	stw	zero,-4(fp)
 90c5cac:	00002406 	br	90c5d40 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 90c5cb0:	e0bffe17 	ldw	r2,-8(fp)
 90c5cb4:	10800117 	ldw	r2,4(r2)
 90c5cb8:	1080058b 	ldhu	r2,22(r2)
 90c5cbc:	10bfffcc 	andi	r2,r2,65535
 90c5cc0:	10a0001c 	xori	r2,r2,32768
 90c5cc4:	10a00004 	addi	r2,r2,-32768
 90c5cc8:	1004803a 	cmplt	r2,r2,zero
 90c5ccc:	1000111e 	bne	r2,zero,90c5d14 <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 90c5cd0:	e0bffe17 	ldw	r2,-8(fp)
 90c5cd4:	10800117 	ldw	r2,4(r2)
 90c5cd8:	10800103 	ldbu	r2,4(r2)
 90c5cdc:	10803fcc 	andi	r2,r2,255
 90c5ce0:	1080201c 	xori	r2,r2,128
 90c5ce4:	10bfe004 	addi	r2,r2,-128
 90c5ce8:	10801b58 	cmpnei	r2,r2,109
 90c5cec:	1000091e 	bne	r2,zero,90c5d14 <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 90c5cf0:	e0bffe17 	ldw	r2,-8(fp)
 90c5cf4:	10c00217 	ldw	r3,8(r2)
 90c5cf8:	00800834 	movhi	r2,32
 90c5cfc:	1887883a 	add	r3,r3,r2
 90c5d00:	e0bffb17 	ldw	r2,-20(fp)
 90c5d04:	1009883a 	mov	r4,r2
 90c5d08:	180b883a 	mov	r5,r3
 90c5d0c:	e1bffa17 	ldw	r6,-24(fp)
 90c5d10:	90822780 	call	9082278 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 90c5d14:	e0bffe17 	ldw	r2,-8(fp)
 90c5d18:	10c00217 	ldw	r3,8(r2)
 90c5d1c:	e0bffa17 	ldw	r2,-24(fp)
 90c5d20:	1887883a 	add	r3,r3,r2
 90c5d24:	e0bffe17 	ldw	r2,-8(fp)
 90c5d28:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 90c5d2c:	e0bffa17 	ldw	r2,-24(fp)
 90c5d30:	1007883a 	mov	r3,r2
 90c5d34:	e0bffc17 	ldw	r2,-16(fp)
 90c5d38:	1885203a 	divu	r2,r3,r2
 90c5d3c:	e0bfff15 	stw	r2,-4(fp)
 90c5d40:	e0bfff17 	ldw	r2,-4(fp)
}
 90c5d44:	e037883a 	mov	sp,fp
 90c5d48:	dfc00117 	ldw	ra,4(sp)
 90c5d4c:	df000017 	ldw	fp,0(sp)
 90c5d50:	dec00204 	addi	sp,sp,8
 90c5d54:	f800283a 	ret

090c5d58 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c5d58:	defffa04 	addi	sp,sp,-24
 90c5d5c:	df000515 	stw	fp,20(sp)
 90c5d60:	df000504 	addi	fp,sp,20
 90c5d64:	e13ffb15 	stw	r4,-20(fp)
 90c5d68:	e17ffc15 	stw	r5,-16(fp)
 90c5d6c:	e1bffd15 	stw	r6,-12(fp)
 90c5d70:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 90c5d74:	e0bffe17 	ldw	r2,-8(fp)
 90c5d78:	10800117 	ldw	r2,4(r2)
 90c5d7c:	10800103 	ldbu	r2,4(r2)
 90c5d80:	10803fcc 	andi	r2,r2,255
 90c5d84:	1080201c 	xori	r2,r2,128
 90c5d88:	10bfe004 	addi	r2,r2,-128
 90c5d8c:	10801b58 	cmpnei	r2,r2,109
 90c5d90:	1000021e 	bne	r2,zero,90c5d9c <md_fwrite+0x44>
      return 0;   /* not writable device */
 90c5d94:	e03fff15 	stw	zero,-4(fp)
 90c5d98:	00000a06 	br	90c5dc4 <md_fwrite+0x6c>

   vfd->cmploc += (items * size);   /* adjust location */
 90c5d9c:	e0bffe17 	ldw	r2,-8(fp)
 90c5da0:	11000217 	ldw	r4,8(r2)
 90c5da4:	e0fffd17 	ldw	r3,-12(fp)
 90c5da8:	e0bffc17 	ldw	r2,-16(fp)
 90c5dac:	1885383a 	mul	r2,r3,r2
 90c5db0:	2087883a 	add	r3,r4,r2
 90c5db4:	e0bffe17 	ldw	r2,-8(fp)
 90c5db8:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 90c5dbc:	e0bffd17 	ldw	r2,-12(fp)
 90c5dc0:	e0bfff15 	stw	r2,-4(fp)
 90c5dc4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c5dc8:	e037883a 	mov	sp,fp
 90c5dcc:	df000017 	ldw	fp,0(sp)
 90c5dd0:	dec00104 	addi	sp,sp,4
 90c5dd4:	f800283a 	ret

090c5dd8 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 90c5dd8:	defffc04 	addi	sp,sp,-16
 90c5ddc:	df000315 	stw	fp,12(sp)
 90c5de0:	df000304 	addi	fp,sp,12
 90c5de4:	e13ffd15 	stw	r4,-12(fp)
 90c5de8:	e17ffe15 	stw	r5,-8(fp)
 90c5dec:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 90c5df0:	0005883a 	mov	r2,zero
}
 90c5df4:	e037883a 	mov	sp,fp
 90c5df8:	df000017 	ldw	fp,0(sp)
 90c5dfc:	dec00104 	addi	sp,sp,4
 90c5e00:	f800283a 	ret

090c5e04 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 90c5e04:	defffe04 	addi	sp,sp,-8
 90c5e08:	df000115 	stw	fp,4(sp)
 90c5e0c:	df000104 	addi	fp,sp,4
 90c5e10:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 90c5e14:	00800834 	movhi	r2,32
}
 90c5e18:	e037883a 	mov	sp,fp
 90c5e1c:	df000017 	ldw	fp,0(sp)
 90c5e20:	dec00104 	addi	sp,sp,4
 90c5e24:	f800283a 	ret

090c5e28 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 90c5e28:	defffb04 	addi	sp,sp,-20
 90c5e2c:	df000415 	stw	fp,16(sp)
 90c5e30:	df000404 	addi	fp,sp,16
 90c5e34:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 90c5e38:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 90c5e3c:	e0bffe17 	ldw	r2,-8(fp)
 90c5e40:	10800217 	ldw	r2,8(r2)
 90c5e44:	1007883a 	mov	r3,r2
 90c5e48:	e0bffe17 	ldw	r2,-8(fp)
 90c5e4c:	10800117 	ldw	r2,4(r2)
 90c5e50:	10800617 	ldw	r2,24(r2)
 90c5e54:	1885c83a 	sub	r2,r3,r2
 90c5e58:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 90c5e5c:	e0bffe17 	ldw	r2,-8(fp)
 90c5e60:	10800117 	ldw	r2,4(r2)
 90c5e64:	10c00717 	ldw	r3,28(r2)
 90c5e68:	e0bffd17 	ldw	r2,-12(fp)
 90c5e6c:	10c00336 	bltu	r2,r3,90c5e7c <md_fgetc+0x54>
      return EOF;
 90c5e70:	00bfffc4 	movi	r2,-1
 90c5e74:	e0bfff15 	stw	r2,-4(fp)
 90c5e78:	00001c06 	br	90c5eec <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 90c5e7c:	e0bffe17 	ldw	r2,-8(fp)
 90c5e80:	10800117 	ldw	r2,4(r2)
 90c5e84:	1080058b 	ldhu	r2,22(r2)
 90c5e88:	10bfffcc 	andi	r2,r2,65535
 90c5e8c:	10a0001c 	xori	r2,r2,32768
 90c5e90:	10a00004 	addi	r2,r2,-32768
 90c5e94:	1004803a 	cmplt	r2,r2,zero
 90c5e98:	10000d1e 	bne	r2,zero,90c5ed0 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 90c5e9c:	e0bffe17 	ldw	r2,-8(fp)
 90c5ea0:	10800117 	ldw	r2,4(r2)
 90c5ea4:	10800103 	ldbu	r2,4(r2)
 90c5ea8:	10803fcc 	andi	r2,r2,255
 90c5eac:	1080201c 	xori	r2,r2,128
 90c5eb0:	10bfe004 	addi	r2,r2,-128
 90c5eb4:	10801b58 	cmpnei	r2,r2,109
 90c5eb8:	1000051e 	bne	r2,zero,90c5ed0 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 90c5ebc:	e0bffe17 	ldw	r2,-8(fp)
 90c5ec0:	10800217 	ldw	r2,8(r2)
 90c5ec4:	10800003 	ldbu	r2,0(r2)
 90c5ec8:	10803fcc 	andi	r2,r2,255
 90c5ecc:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 90c5ed0:	e0bffe17 	ldw	r2,-8(fp)
 90c5ed4:	10800217 	ldw	r2,8(r2)
 90c5ed8:	10c00044 	addi	r3,r2,1
 90c5edc:	e0bffe17 	ldw	r2,-8(fp)
 90c5ee0:	10c00215 	stw	r3,8(r2)
   return retval;
 90c5ee4:	e0bffc17 	ldw	r2,-16(fp)
 90c5ee8:	e0bfff15 	stw	r2,-4(fp)
 90c5eec:	e0bfff17 	ldw	r2,-4(fp)
}
 90c5ef0:	e037883a 	mov	sp,fp
 90c5ef4:	df000017 	ldw	fp,0(sp)
 90c5ef8:	dec00104 	addi	sp,sp,4
 90c5efc:	f800283a 	ret

090c5f00 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 90c5f00:	defffe04 	addi	sp,sp,-8
 90c5f04:	df000115 	stw	fp,4(sp)
 90c5f08:	df000104 	addi	fp,sp,4
 90c5f0c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 90c5f10:	0005883a 	mov	r2,zero
}
 90c5f14:	e037883a 	mov	sp,fp
 90c5f18:	df000017 	ldw	fp,0(sp)
 90c5f1c:	dec00104 	addi	sp,sp,4
 90c5f20:	f800283a 	ret

090c5f24 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 90c5f24:	defff504 	addi	sp,sp,-44
 90c5f28:	dfc00a15 	stw	ra,40(sp)
 90c5f2c:	df000915 	stw	fp,36(sp)
 90c5f30:	df000904 	addi	fp,sp,36
 90c5f34:	e13ffc15 	stw	r4,-16(fp)
 90c5f38:	e17ffd15 	stw	r5,-12(fp)
 90c5f3c:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 90c5f40:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 90c5f44:	00824374 	movhi	r2,2317
 90c5f48:	1082ab04 	addi	r2,r2,2732
 90c5f4c:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 90c5f50:	e0bffe17 	ldw	r2,-8(fp)
 90c5f54:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 90c5f58:	00002606 	br	90c5ff4 <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 90c5f5c:	e0bffa17 	ldw	r2,-24(fp)
 90c5f60:	10800003 	ldbu	r2,0(r2)
 90c5f64:	10803fcc 	andi	r2,r2,255
 90c5f68:	1080201c 	xori	r2,r2,128
 90c5f6c:	10bfe004 	addi	r2,r2,-128
 90c5f70:	10800e88 	cmpgei	r2,r2,58
 90c5f74:	10000e1e 	bne	r2,zero,90c5fb0 <parse_ipad+0x8c>
 90c5f78:	e0bffa17 	ldw	r2,-24(fp)
 90c5f7c:	10800003 	ldbu	r2,0(r2)
 90c5f80:	10803fcc 	andi	r2,r2,255
 90c5f84:	1080201c 	xori	r2,r2,128
 90c5f88:	10bfe004 	addi	r2,r2,-128
 90c5f8c:	10800b90 	cmplti	r2,r2,46
 90c5f90:	1000071e 	bne	r2,zero,90c5fb0 <parse_ipad+0x8c>
 90c5f94:	e0bffa17 	ldw	r2,-24(fp)
 90c5f98:	10800003 	ldbu	r2,0(r2)
 90c5f9c:	10803fcc 	andi	r2,r2,255
 90c5fa0:	1080201c 	xori	r2,r2,128
 90c5fa4:	10bfe004 	addi	r2,r2,-128
 90c5fa8:	10800bd8 	cmpnei	r2,r2,47
 90c5fac:	1000041e 	bne	r2,zero,90c5fc0 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 90c5fb0:	00824374 	movhi	r2,2317
 90c5fb4:	1082b404 	addi	r2,r2,2768
 90c5fb8:	e0bfff15 	stw	r2,-4(fp)
 90c5fbc:	00009a06 	br	90c6228 <parse_ipad+0x304>
      if (*cp == '.')dots++;
 90c5fc0:	e0bffa17 	ldw	r2,-24(fp)
 90c5fc4:	10800003 	ldbu	r2,0(r2)
 90c5fc8:	10803fcc 	andi	r2,r2,255
 90c5fcc:	1080201c 	xori	r2,r2,128
 90c5fd0:	10bfe004 	addi	r2,r2,-128
 90c5fd4:	10800b98 	cmpnei	r2,r2,46
 90c5fd8:	1000031e 	bne	r2,zero,90c5fe8 <parse_ipad+0xc4>
 90c5fdc:	e0bff917 	ldw	r2,-28(fp)
 90c5fe0:	10800044 	addi	r2,r2,1
 90c5fe4:	e0bff915 	stw	r2,-28(fp)
         cp++;
 90c5fe8:	e0bffa17 	ldw	r2,-24(fp)
 90c5fec:	10800044 	addi	r2,r2,1
 90c5ff0:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 90c5ff4:	e0bffa17 	ldw	r2,-24(fp)
 90c5ff8:	10800003 	ldbu	r2,0(r2)
 90c5ffc:	10803fcc 	andi	r2,r2,255
 90c6000:	1080201c 	xori	r2,r2,128
 90c6004:	10bfe004 	addi	r2,r2,-128
 90c6008:	1004c03a 	cmpne	r2,r2,zero
 90c600c:	103fd31e 	bne	r2,zero,90c5f5c <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 90c6010:	e0bff917 	ldw	r2,-28(fp)
 90c6014:	10800050 	cmplti	r2,r2,1
 90c6018:	1000031e 	bne	r2,zero,90c6028 <parse_ipad+0x104>
 90c601c:	e0bff917 	ldw	r2,-28(fp)
 90c6020:	10800110 	cmplti	r2,r2,4
 90c6024:	1000041e 	bne	r2,zero,90c6038 <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 90c6028:	00824374 	movhi	r2,2317
 90c602c:	1082bf04 	addi	r2,r2,2812
 90c6030:	e0bfff15 	stw	r2,-4(fp)
 90c6034:	00007c06 	br	90c6228 <parse_ipad+0x304>

   cp = stringin;
 90c6038:	e0bffe17 	ldw	r2,-8(fp)
 90c603c:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 90c6040:	e13ffa17 	ldw	r4,-24(fp)
 90c6044:	90ca4b80 	call	90ca4b8 <atoi>
 90c6048:	e0bff815 	stw	r2,-32(fp)
 90c604c:	e0bff817 	ldw	r2,-32(fp)
 90c6050:	10804010 	cmplti	r2,r2,256
 90c6054:	1000031e 	bne	r2,zero,90c6064 <parse_ipad+0x140>
      return(toobig);
 90c6058:	e0bff717 	ldw	r2,-36(fp)
 90c605c:	e0bfff15 	stw	r2,-4(fp)
 90c6060:	00007106 	br	90c6228 <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 90c6064:	e0bff817 	ldw	r2,-32(fp)
 90c6068:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 90c606c:	00000306 	br	90c607c <parse_ipad+0x158>
 90c6070:	e0bffa17 	ldw	r2,-24(fp)
 90c6074:	10800044 	addi	r2,r2,1
 90c6078:	e0bffa15 	stw	r2,-24(fp)
 90c607c:	e0bffa17 	ldw	r2,-24(fp)
 90c6080:	10800003 	ldbu	r2,0(r2)
 90c6084:	10803fcc 	andi	r2,r2,255
 90c6088:	1080201c 	xori	r2,r2,128
 90c608c:	10bfe004 	addi	r2,r2,-128
 90c6090:	10800b98 	cmpnei	r2,r2,46
 90c6094:	103ff61e 	bne	r2,zero,90c6070 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 90c6098:	e0bffa17 	ldw	r2,-24(fp)
 90c609c:	10800044 	addi	r2,r2,1
 90c60a0:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 90c60a4:	e0bff917 	ldw	r2,-28(fp)
 90c60a8:	10800060 	cmpeqi	r2,r2,1
 90c60ac:	1000031e 	bne	r2,zero,90c60bc <parse_ipad+0x198>
 90c60b0:	e0bff917 	ldw	r2,-28(fp)
 90c60b4:	10800098 	cmpnei	r2,r2,2
 90c60b8:	1000021e 	bne	r2,zero,90c60c4 <parse_ipad+0x1a0>
 90c60bc:	e03ffb45 	stb	zero,-19(fp)
 90c60c0:	00001906 	br	90c6128 <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 90c60c4:	e13ffa17 	ldw	r4,-24(fp)
 90c60c8:	90ca4b80 	call	90ca4b8 <atoi>
 90c60cc:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 90c60d0:	00000306 	br	90c60e0 <parse_ipad+0x1bc>
 90c60d4:	e0bffa17 	ldw	r2,-24(fp)
 90c60d8:	10800044 	addi	r2,r2,1
 90c60dc:	e0bffa15 	stw	r2,-24(fp)
 90c60e0:	e0bffa17 	ldw	r2,-24(fp)
 90c60e4:	10800003 	ldbu	r2,0(r2)
 90c60e8:	10803fcc 	andi	r2,r2,255
 90c60ec:	1080201c 	xori	r2,r2,128
 90c60f0:	10bfe004 	addi	r2,r2,-128
 90c60f4:	10800b98 	cmpnei	r2,r2,46
 90c60f8:	103ff61e 	bne	r2,zero,90c60d4 <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 90c60fc:	e0bffa17 	ldw	r2,-24(fp)
 90c6100:	10800044 	addi	r2,r2,1
 90c6104:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 90c6108:	e0bff817 	ldw	r2,-32(fp)
 90c610c:	10804010 	cmplti	r2,r2,256
 90c6110:	1000031e 	bne	r2,zero,90c6120 <parse_ipad+0x1fc>
 90c6114:	e0bff717 	ldw	r2,-36(fp)
 90c6118:	e0bfff15 	stw	r2,-4(fp)
 90c611c:	00004206 	br	90c6228 <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 90c6120:	e0bff817 	ldw	r2,-32(fp)
 90c6124:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 90c6128:	e0bff917 	ldw	r2,-28(fp)
 90c612c:	10800058 	cmpnei	r2,r2,1
 90c6130:	1000021e 	bne	r2,zero,90c613c <parse_ipad+0x218>
 90c6134:	e03ffb85 	stb	zero,-18(fp)
 90c6138:	00001906 	br	90c61a0 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 90c613c:	e13ffa17 	ldw	r4,-24(fp)
 90c6140:	90ca4b80 	call	90ca4b8 <atoi>
 90c6144:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 90c6148:	00000306 	br	90c6158 <parse_ipad+0x234>
 90c614c:	e0bffa17 	ldw	r2,-24(fp)
 90c6150:	10800044 	addi	r2,r2,1
 90c6154:	e0bffa15 	stw	r2,-24(fp)
 90c6158:	e0bffa17 	ldw	r2,-24(fp)
 90c615c:	10800003 	ldbu	r2,0(r2)
 90c6160:	10803fcc 	andi	r2,r2,255
 90c6164:	1080201c 	xori	r2,r2,128
 90c6168:	10bfe004 	addi	r2,r2,-128
 90c616c:	10800b98 	cmpnei	r2,r2,46
 90c6170:	103ff61e 	bne	r2,zero,90c614c <parse_ipad+0x228>
         cp++;             /* point past dot */
 90c6174:	e0bffa17 	ldw	r2,-24(fp)
 90c6178:	10800044 	addi	r2,r2,1
 90c617c:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 90c6180:	e0bff817 	ldw	r2,-32(fp)
 90c6184:	10804010 	cmplti	r2,r2,256
 90c6188:	1000031e 	bne	r2,zero,90c6198 <parse_ipad+0x274>
 90c618c:	e0bff717 	ldw	r2,-36(fp)
 90c6190:	e0bfff15 	stw	r2,-4(fp)
 90c6194:	00002406 	br	90c6228 <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 90c6198:	e0bff817 	ldw	r2,-32(fp)
 90c619c:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 90c61a0:	e13ffa17 	ldw	r4,-24(fp)
 90c61a4:	90ca4b80 	call	90ca4b8 <atoi>
 90c61a8:	e0bff815 	stw	r2,-32(fp)
 90c61ac:	e0bff817 	ldw	r2,-32(fp)
 90c61b0:	10804010 	cmplti	r2,r2,256
 90c61b4:	1000031e 	bne	r2,zero,90c61c4 <parse_ipad+0x2a0>
      return(toobig);
 90c61b8:	e0bff717 	ldw	r2,-36(fp)
 90c61bc:	e0bfff15 	stw	r2,-4(fp)
 90c61c0:	00001906 	br	90c6228 <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 90c61c4:	e0bff817 	ldw	r2,-32(fp)
 90c61c8:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 90c61cc:	e0bffb03 	ldbu	r2,-20(fp)
 90c61d0:	10803fcc 	andi	r2,r2,255
 90c61d4:	10802028 	cmpgeui	r2,r2,128
 90c61d8:	1000041e 	bne	r2,zero,90c61ec <parse_ipad+0x2c8>
 90c61dc:	e0fffd17 	ldw	r3,-12(fp)
 90c61e0:	00800204 	movi	r2,8
 90c61e4:	18800015 	stw	r2,0(r3)
 90c61e8:	00000b06 	br	90c6218 <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 90c61ec:	e0bffb03 	ldbu	r2,-20(fp)
 90c61f0:	10803fcc 	andi	r2,r2,255
 90c61f4:	10803028 	cmpgeui	r2,r2,192
 90c61f8:	1000041e 	bne	r2,zero,90c620c <parse_ipad+0x2e8>
 90c61fc:	e0fffd17 	ldw	r3,-12(fp)
 90c6200:	00800404 	movi	r2,16
 90c6204:	18800015 	stw	r2,0(r3)
 90c6208:	00000306 	br	90c6218 <parse_ipad+0x2f4>
      else *sbits = 24;
 90c620c:	e0fffd17 	ldw	r3,-12(fp)
 90c6210:	00800604 	movi	r2,24
 90c6214:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 90c6218:	e0fffb17 	ldw	r3,-20(fp)
 90c621c:	e0bffc17 	ldw	r2,-16(fp)
 90c6220:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 90c6224:	e03fff15 	stw	zero,-4(fp)
 90c6228:	e0bfff17 	ldw	r2,-4(fp)
}
 90c622c:	e037883a 	mov	sp,fp
 90c6230:	dfc00117 	ldw	ra,4(sp)
 90c6234:	df000017 	ldw	fp,0(sp)
 90c6238:	dec00204 	addi	sp,sp,8
 90c623c:	f800283a 	ret

090c6240 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 90c6240:	defffa04 	addi	sp,sp,-24
 90c6244:	dfc00515 	stw	ra,20(sp)
 90c6248:	df000415 	stw	fp,16(sp)
 90c624c:	df000404 	addi	fp,sp,16
 90c6250:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 90c6254:	01024374 	movhi	r4,2317
 90c6258:	210e1204 	addi	r4,r4,14408
 90c625c:	e17ffe17 	ldw	r5,-8(fp)
 90c6260:	90ca5b40 	call	90ca5b4 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 90c6264:	e17ffd04 	addi	r5,fp,-12
 90c6268:	e13ffc04 	addi	r4,fp,-16
 90c626c:	01824374 	movhi	r6,2317
 90c6270:	318e1204 	addi	r6,r6,14408
 90c6274:	90c5f240 	call	90c5f24 <parse_ipad>
 90c6278:	1004c03a 	cmpne	r2,r2,zero
 90c627c:	1000031e 	bne	r2,zero,90c628c <inet_addr+0x4c>
   {
      return ipaddr ;
 90c6280:	e0bffc17 	ldw	r2,-16(fp)
 90c6284:	e0bfff15 	stw	r2,-4(fp)
 90c6288:	00000106 	br	90c6290 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 90c628c:	e03fff15 	stw	zero,-4(fp)
 90c6290:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90c6294:	e037883a 	mov	sp,fp
 90c6298:	dfc00117 	ldw	ra,4(sp)
 90c629c:	df000017 	ldw	fp,0(sp)
 90c62a0:	dec00204 	addi	sp,sp,8
 90c62a4:	f800283a 	ret

090c62a8 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 90c62a8:	defffd04 	addi	sp,sp,-12
 90c62ac:	df000215 	stw	fp,8(sp)
 90c62b0:	df000204 	addi	fp,sp,8
 90c62b4:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 90c62b8:	e0bffe17 	ldw	r2,-8(fp)
 90c62bc:	108003cc 	andi	r2,r2,15
 90c62c0:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 90c62c4:	e0bffe17 	ldw	r2,-8(fp)
 90c62c8:	10800288 	cmpgei	r2,r2,10
 90c62cc:	1000071e 	bne	r2,zero,90c62ec <hextoa+0x44>
      return (char)(val + '0');
 90c62d0:	e0bffe17 	ldw	r2,-8(fp)
 90c62d4:	10800c04 	addi	r2,r2,48
 90c62d8:	10803fcc 	andi	r2,r2,255
 90c62dc:	1080201c 	xori	r2,r2,128
 90c62e0:	10bfe004 	addi	r2,r2,-128
 90c62e4:	e0bfff15 	stw	r2,-4(fp)
 90c62e8:	00000606 	br	90c6304 <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 90c62ec:	e0bffe17 	ldw	r2,-8(fp)
 90c62f0:	10800dc4 	addi	r2,r2,55
 90c62f4:	10803fcc 	andi	r2,r2,255
 90c62f8:	1080201c 	xori	r2,r2,128
 90c62fc:	10bfe004 	addi	r2,r2,-128
 90c6300:	e0bfff15 	stw	r2,-4(fp)
 90c6304:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6308:	e037883a 	mov	sp,fp
 90c630c:	df000017 	ldw	fp,0(sp)
 90c6310:	dec00104 	addi	sp,sp,4
 90c6314:	f800283a 	ret

090c6318 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 90c6318:	defff704 	addi	sp,sp,-36
 90c631c:	dfc00815 	stw	ra,32(sp)
 90c6320:	df000715 	stw	fp,28(sp)
 90c6324:	df000704 	addi	fp,sp,28
 90c6328:	e13ffc15 	stw	r4,-16(fp)
 90c632c:	e17ffd15 	stw	r5,-12(fp)
 90c6330:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 90c6334:	e0bffc17 	ldw	r2,-16(fp)
 90c6338:	10800098 	cmpnei	r2,r2,2
 90c633c:	10001a1e 	bne	r2,zero,90c63a8 <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 90c6340:	e13ffa04 	addi	r4,fp,-24
 90c6344:	e17ffb04 	addi	r5,fp,-20
 90c6348:	e1bffd17 	ldw	r6,-12(fp)
 90c634c:	90c5f240 	call	90c5f24 <parse_ipad>
 90c6350:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 90c6354:	e0bff917 	ldw	r2,-28(fp)
 90c6358:	1004c03a 	cmpne	r2,r2,zero
 90c635c:	10000c1e 	bne	r2,zero,90c6390 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 90c6360:	e13ffe17 	ldw	r4,-8(fp)
 90c6364:	e0fffa04 	addi	r3,fp,-24
 90c6368:	18800003 	ldbu	r2,0(r3)
 90c636c:	20800005 	stb	r2,0(r4)
 90c6370:	18800043 	ldbu	r2,1(r3)
 90c6374:	20800045 	stb	r2,1(r4)
 90c6378:	18800083 	ldbu	r2,2(r3)
 90c637c:	20800085 	stb	r2,2(r4)
 90c6380:	188000c3 	ldbu	r2,3(r3)
 90c6384:	208000c5 	stb	r2,3(r4)
         return 0;
 90c6388:	e03fff15 	stw	zero,-4(fp)
 90c638c:	00000706 	br	90c63ac <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 90c6390:	00824374 	movhi	r2,2317
 90c6394:	1082c904 	addi	r2,r2,2852
 90c6398:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 90c639c:	00800044 	movi	r2,1
 90c63a0:	e0bfff15 	stw	r2,-4(fp)
 90c63a4:	00000106 	br	90c63ac <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 90c63a8:	e03fff15 	stw	zero,-4(fp)
 90c63ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90c63b0:	e037883a 	mov	sp,fp
 90c63b4:	dfc00117 	ldw	ra,4(sp)
 90c63b8:	df000017 	ldw	fp,0(sp)
 90c63bc:	dec00204 	addi	sp,sp,8
 90c63c0:	f800283a 	ret

090c63c4 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 90c63c4:	defff704 	addi	sp,sp,-36
 90c63c8:	dfc00815 	stw	ra,32(sp)
 90c63cc:	df000715 	stw	fp,28(sp)
 90c63d0:	df000704 	addi	fp,sp,28
 90c63d4:	e13ffb15 	stw	r4,-20(fp)
 90c63d8:	e17ffc15 	stw	r5,-16(fp)
 90c63dc:	e1bffd15 	stw	r6,-12(fp)
 90c63e0:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 90c63e4:	e0bffb17 	ldw	r2,-20(fp)
 90c63e8:	10800098 	cmpnei	r2,r2,2
 90c63ec:	1000111e 	bne	r2,zero,90c6434 <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 90c63f0:	e0bffc17 	ldw	r2,-16(fp)
 90c63f4:	10800017 	ldw	r2,0(r2)
 90c63f8:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 90c63fc:	e13ff917 	ldw	r4,-28(fp)
 90c6400:	90a415c0 	call	90a415c <print_ipad>
 90c6404:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 90c6408:	e13ffa17 	ldw	r4,-24(fp)
 90c640c:	90830d40 	call	90830d4 <strlen>
 90c6410:	1007883a 	mov	r3,r2
 90c6414:	e0bffe17 	ldw	r2,-8(fp)
 90c6418:	1880062e 	bgeu	r3,r2,90c6434 <inet_ntop+0x70>
      {
         strcpy(str, cp);
 90c641c:	e13ffd17 	ldw	r4,-12(fp)
 90c6420:	e17ffa17 	ldw	r5,-24(fp)
 90c6424:	90ca5b40 	call	90ca5b4 <strcpy>
         return (str);
 90c6428:	e0bffd17 	ldw	r2,-12(fp)
 90c642c:	e0bfff15 	stw	r2,-4(fp)
 90c6430:	00000106 	br	90c6438 <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 90c6434:	e03fff15 	stw	zero,-4(fp)
 90c6438:	e0bfff17 	ldw	r2,-4(fp)
}
 90c643c:	e037883a 	mov	sp,fp
 90c6440:	dfc00117 	ldw	ra,4(sp)
 90c6444:	df000017 	ldw	fp,0(sp)
 90c6448:	dec00204 	addi	sp,sp,8
 90c644c:	f800283a 	ret

090c6450 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 90c6450:	defffb04 	addi	sp,sp,-20
 90c6454:	dfc00415 	stw	ra,16(sp)
 90c6458:	df000315 	stw	fp,12(sp)
 90c645c:	df000304 	addi	fp,sp,12
 90c6460:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 90c6464:	e0bffe17 	ldw	r2,-8(fp)
 90c6468:	1080000b 	ldhu	r2,0(r2)
 90c646c:	10bfffcc 	andi	r2,r2,65535
 90c6470:	10800098 	cmpnei	r2,r2,2
 90c6474:	1000071e 	bne	r2,zero,90c6494 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 90c6478:	e0bffe17 	ldw	r2,-8(fp)
 90c647c:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 90c6480:	e0bffd17 	ldw	r2,-12(fp)
 90c6484:	11000117 	ldw	r4,4(r2)
 90c6488:	90a415c0 	call	90a415c <print_ipad>
 90c648c:	e0bfff15 	stw	r2,-4(fp)
 90c6490:	00000106 	br	90c6498 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 90c6494:	e03fff15 	stw	zero,-4(fp)
 90c6498:	e0bfff17 	ldw	r2,-4(fp)
}
 90c649c:	e037883a 	mov	sp,fp
 90c64a0:	dfc00117 	ldw	ra,4(sp)
 90c64a4:	df000017 	ldw	fp,0(sp)
 90c64a8:	dec00204 	addi	sp,sp,8
 90c64ac:	f800283a 	ret

090c64b0 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 90c64b0:	defffb04 	addi	sp,sp,-20
 90c64b4:	dfc00415 	stw	ra,16(sp)
 90c64b8:	df000315 	stw	fp,12(sp)
 90c64bc:	df000304 	addi	fp,sp,12
 90c64c0:	e13ffe15 	stw	r4,-8(fp)
 90c64c4:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 90c64c8:	e0ffff17 	ldw	r3,-4(fp)
 90c64cc:	00800084 	movi	r2,2
 90c64d0:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 90c64d4:	e0bffe17 	ldw	r2,-8(fp)
 90c64d8:	10800044 	addi	r2,r2,1
 90c64dc:	10800003 	ldbu	r2,0(r2)
 90c64e0:	10803fcc 	andi	r2,r2,255
 90c64e4:	1080201c 	xori	r2,r2,128
 90c64e8:	10bfe004 	addi	r2,r2,-128
 90c64ec:	10800ba0 	cmpeqi	r2,r2,46
 90c64f0:	1000101e 	bne	r2,zero,90c6534 <inet46_addr+0x84>
 90c64f4:	e0bffe17 	ldw	r2,-8(fp)
 90c64f8:	10800084 	addi	r2,r2,2
 90c64fc:	10800003 	ldbu	r2,0(r2)
 90c6500:	10803fcc 	andi	r2,r2,255
 90c6504:	1080201c 	xori	r2,r2,128
 90c6508:	10bfe004 	addi	r2,r2,-128
 90c650c:	10800ba0 	cmpeqi	r2,r2,46
 90c6510:	1000081e 	bne	r2,zero,90c6534 <inet46_addr+0x84>
 90c6514:	e0bffe17 	ldw	r2,-8(fp)
 90c6518:	108000c4 	addi	r2,r2,3
 90c651c:	10800003 	ldbu	r2,0(r2)
 90c6520:	10803fcc 	andi	r2,r2,255
 90c6524:	1080201c 	xori	r2,r2,128
 90c6528:	10bfe004 	addi	r2,r2,-128
 90c652c:	10800b98 	cmpnei	r2,r2,46
 90c6530:	10000a1e 	bne	r2,zero,90c655c <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 90c6534:	e0bfff17 	ldw	r2,-4(fp)
 90c6538:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 90c653c:	e13ffe17 	ldw	r4,-8(fp)
 90c6540:	90c62400 	call	90c6240 <inet_addr>
 90c6544:	1007883a 	mov	r3,r2
 90c6548:	e0bffd17 	ldw	r2,-12(fp)
 90c654c:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 90c6550:	e0fffd17 	ldw	r3,-12(fp)
 90c6554:	00800084 	movi	r2,2
 90c6558:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 90c655c:	0005883a 	mov	r2,zero
}
 90c6560:	e037883a 	mov	sp,fp
 90c6564:	dfc00117 	ldw	ra,4(sp)
 90c6568:	df000017 	ldw	fp,0(sp)
 90c656c:	dec00204 	addi	sp,sp,8
 90c6570:	f800283a 	ret

090c6574 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 90c6574:	defffc04 	addi	sp,sp,-16
 90c6578:	df000315 	stw	fp,12(sp)
 90c657c:	df000304 	addi	fp,sp,12
 90c6580:	e13ffe15 	stw	r4,-8(fp)
 90c6584:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 90c6588:	e0bffe17 	ldw	r2,-8(fp)
 90c658c:	1080000b 	ldhu	r2,0(r2)
 90c6590:	10bfffcc 	andi	r2,r2,65535
 90c6594:	10800098 	cmpnei	r2,r2,2
 90c6598:	10000f1e 	bne	r2,zero,90c65d8 <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 90c659c:	e0bffe17 	ldw	r2,-8(fp)
 90c65a0:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 90c65a4:	e0bfff17 	ldw	r2,-4(fp)
 90c65a8:	1005d23a 	srai	r2,r2,8
 90c65ac:	10803fcc 	andi	r2,r2,255
 90c65b0:	1009883a 	mov	r4,r2
 90c65b4:	e0bfff17 	ldw	r2,-4(fp)
 90c65b8:	1004923a 	slli	r2,r2,8
 90c65bc:	1007883a 	mov	r3,r2
 90c65c0:	00bfc004 	movi	r2,-256
 90c65c4:	1884703a 	and	r2,r3,r2
 90c65c8:	2084b03a 	or	r2,r4,r2
 90c65cc:	1007883a 	mov	r3,r2
 90c65d0:	e0bffd17 	ldw	r2,-12(fp)
 90c65d4:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 90c65d8:	e037883a 	mov	sp,fp
 90c65dc:	df000017 	ldw	fp,0(sp)
 90c65e0:	dec00104 	addi	sp,sp,4
 90c65e4:	f800283a 	ret

090c65e8 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 90c65e8:	defff804 	addi	sp,sp,-32
 90c65ec:	df000715 	stw	fp,28(sp)
 90c65f0:	df000704 	addi	fp,sp,28
 90c65f4:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 90c65f8:	e0bffe17 	ldw	r2,-8(fp)
 90c65fc:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 90c6600:	e0bffd04 	addi	r2,fp,-12
 90c6604:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 90c6608:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 90c660c:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 90c6610:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 90c6614:	00003306 	br	90c66e4 <convert_ip+0xfc>
   {
      if( *cp == '.')
 90c6618:	e0bffc17 	ldw	r2,-16(fp)
 90c661c:	10800003 	ldbu	r2,0(r2)
 90c6620:	10803fcc 	andi	r2,r2,255
 90c6624:	1080201c 	xori	r2,r2,128
 90c6628:	10bfe004 	addi	r2,r2,-128
 90c662c:	10800b98 	cmpnei	r2,r2,46
 90c6630:	1000101e 	bne	r2,zero,90c6674 <convert_ip+0x8c>
      {
         lpb[n] = (unsigned char) v;
 90c6634:	e0bffa17 	ldw	r2,-24(fp)
 90c6638:	1007883a 	mov	r3,r2
 90c663c:	e0bffb17 	ldw	r2,-20(fp)
 90c6640:	1887883a 	add	r3,r3,r2
 90c6644:	e0bff90b 	ldhu	r2,-28(fp)
 90c6648:	18800005 	stb	r2,0(r3)
         v = 0;
 90c664c:	e03ff90d 	sth	zero,-28(fp)
         n++;
 90c6650:	e0bffa17 	ldw	r2,-24(fp)
 90c6654:	10800044 	addi	r2,r2,1
 90c6658:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 90c665c:	e0bffa17 	ldw	r2,-24(fp)
 90c6660:	10800110 	cmplti	r2,r2,4
 90c6664:	10001c1e 	bne	r2,zero,90c66d8 <convert_ip+0xf0>
         {
            return dw;
 90c6668:	e0bffd17 	ldw	r2,-12(fp)
 90c666c:	e0bfff15 	stw	r2,-4(fp)
 90c6670:	00002b06 	br	90c6720 <convert_ip+0x138>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 90c6674:	e0bffc17 	ldw	r2,-16(fp)
 90c6678:	10800003 	ldbu	r2,0(r2)
 90c667c:	10803fcc 	andi	r2,r2,255
 90c6680:	1080201c 	xori	r2,r2,128
 90c6684:	10bfe004 	addi	r2,r2,-128
 90c6688:	10800c10 	cmplti	r2,r2,48
 90c668c:	1000121e 	bne	r2,zero,90c66d8 <convert_ip+0xf0>
 90c6690:	e0bffc17 	ldw	r2,-16(fp)
 90c6694:	10800003 	ldbu	r2,0(r2)
 90c6698:	10803fcc 	andi	r2,r2,255
 90c669c:	1080201c 	xori	r2,r2,128
 90c66a0:	10bfe004 	addi	r2,r2,-128
 90c66a4:	10800e88 	cmpgei	r2,r2,58
 90c66a8:	10000b1e 	bne	r2,zero,90c66d8 <convert_ip+0xf0>
      {
         v = (v * 10) + (*cp - '0');
 90c66ac:	e0bff90b 	ldhu	r2,-28(fp)
 90c66b0:	108002a4 	muli	r2,r2,10
 90c66b4:	1007883a 	mov	r3,r2
 90c66b8:	e0bffc17 	ldw	r2,-16(fp)
 90c66bc:	10800003 	ldbu	r2,0(r2)
 90c66c0:	10803fcc 	andi	r2,r2,255
 90c66c4:	1080201c 	xori	r2,r2,128
 90c66c8:	10bfe004 	addi	r2,r2,-128
 90c66cc:	1885883a 	add	r2,r3,r2
 90c66d0:	10bff404 	addi	r2,r2,-48
 90c66d4:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 90c66d8:	e0bffc17 	ldw	r2,-16(fp)
 90c66dc:	10800044 	addi	r2,r2,1
 90c66e0:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 90c66e4:	e0bffc17 	ldw	r2,-16(fp)
 90c66e8:	10800003 	ldbu	r2,0(r2)
 90c66ec:	10803fcc 	andi	r2,r2,255
 90c66f0:	1080201c 	xori	r2,r2,128
 90c66f4:	10bfe004 	addi	r2,r2,-128
 90c66f8:	1004c03a 	cmpne	r2,r2,zero
 90c66fc:	103fc61e 	bne	r2,zero,90c6618 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 90c6700:	e0bffa17 	ldw	r2,-24(fp)
 90c6704:	1007883a 	mov	r3,r2
 90c6708:	e0bffb17 	ldw	r2,-20(fp)
 90c670c:	1887883a 	add	r3,r3,r2
 90c6710:	e0bff90b 	ldhu	r2,-28(fp)
 90c6714:	18800005 	stb	r2,0(r3)
   return dw;
 90c6718:	e0bffd17 	ldw	r2,-12(fp)
 90c671c:	e0bfff15 	stw	r2,-4(fp)
 90c6720:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 90c6724:	e037883a 	mov	sp,fp
 90c6728:	df000017 	ldw	fp,0(sp)
 90c672c:	dec00104 	addi	sp,sp,4
 90c6730:	f800283a 	ret

090c6734 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 90c6734:	defff804 	addi	sp,sp,-32
 90c6738:	dfc00715 	stw	ra,28(sp)
 90c673c:	df000615 	stw	fp,24(sp)
 90c6740:	df000604 	addi	fp,sp,24
 90c6744:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 90c6748:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 90c674c:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 90c6750:	e0bfff17 	ldw	r2,-4(fp)
 90c6754:	10800003 	ldbu	r2,0(r2)
 90c6758:	10803fcc 	andi	r2,r2,255
 90c675c:	108003cc 	andi	r2,r2,15
 90c6760:	1085883a 	add	r2,r2,r2
 90c6764:	1085883a 	add	r2,r2,r2
 90c6768:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 90c676c:	e0bfff17 	ldw	r2,-4(fp)
 90c6770:	1080008b 	ldhu	r2,2(r2)
 90c6774:	10bfffcc 	andi	r2,r2,65535
 90c6778:	1004d23a 	srli	r2,r2,8
 90c677c:	10803fcc 	andi	r2,r2,255
 90c6780:	1009883a 	mov	r4,r2
 90c6784:	e0bfff17 	ldw	r2,-4(fp)
 90c6788:	1080008b 	ldhu	r2,2(r2)
 90c678c:	10bfffcc 	andi	r2,r2,65535
 90c6790:	1004923a 	slli	r2,r2,8
 90c6794:	1007883a 	mov	r3,r2
 90c6798:	00bfc004 	movi	r2,-256
 90c679c:	1884703a 	and	r2,r3,r2
 90c67a0:	2084b03a 	or	r2,r4,r2
 90c67a4:	1007883a 	mov	r3,r2
 90c67a8:	e0bffe8b 	ldhu	r2,-6(fp)
 90c67ac:	1885c83a 	sub	r2,r3,r2
 90c67b0:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 90c67b4:	e0bfff17 	ldw	r2,-4(fp)
 90c67b8:	10800003 	ldbu	r2,0(r2)
 90c67bc:	10803fcc 	andi	r2,r2,255
 90c67c0:	108003cc 	andi	r2,r2,15
 90c67c4:	1085883a 	add	r2,r2,r2
 90c67c8:	1085883a 	add	r2,r2,r2
 90c67cc:	1007883a 	mov	r3,r2
 90c67d0:	e0bfff17 	ldw	r2,-4(fp)
 90c67d4:	1885883a 	add	r2,r3,r2
 90c67d8:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 90c67dc:	e0bffa17 	ldw	r2,-24(fp)
 90c67e0:	1080040b 	ldhu	r2,16(r2)
 90c67e4:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 90c67e8:	e0bffe0b 	ldhu	r2,-8(fp)
 90c67ec:	10800184 	addi	r2,r2,6
 90c67f0:	1005d23a 	srai	r2,r2,8
 90c67f4:	10803fcc 	andi	r2,r2,255
 90c67f8:	1009883a 	mov	r4,r2
 90c67fc:	e0bffe0b 	ldhu	r2,-8(fp)
 90c6800:	10800184 	addi	r2,r2,6
 90c6804:	1004923a 	slli	r2,r2,8
 90c6808:	1007883a 	mov	r3,r2
 90c680c:	00bfc004 	movi	r2,-256
 90c6810:	1884703a 	and	r2,r3,r2
 90c6814:	2084b03a 	or	r2,r4,r2
 90c6818:	1007883a 	mov	r3,r2
 90c681c:	e0bffa17 	ldw	r2,-24(fp)
 90c6820:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 90c6824:	e0bffe0b 	ldhu	r2,-8(fp)
 90c6828:	1080004c 	andi	r2,r2,1
 90c682c:	10803fcc 	andi	r2,r2,255
 90c6830:	1005003a 	cmpeq	r2,r2,zero
 90c6834:	10000f1e 	bne	r2,zero,90c6874 <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 90c6838:	e0bffe8b 	ldhu	r2,-6(fp)
 90c683c:	1007883a 	mov	r3,r2
 90c6840:	e0bfff17 	ldw	r2,-4(fp)
 90c6844:	1887883a 	add	r3,r3,r2
 90c6848:	e0bffe0b 	ldhu	r2,-8(fp)
 90c684c:	1885883a 	add	r2,r3,r2
 90c6850:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 90c6854:	e0bffd17 	ldw	r2,-12(fp)
 90c6858:	10800003 	ldbu	r2,0(r2)
 90c685c:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 90c6860:	e0bffd17 	ldw	r2,-12(fp)
 90c6864:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 90c6868:	e0bffe0b 	ldhu	r2,-8(fp)
 90c686c:	10800044 	addi	r2,r2,1
 90c6870:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 90c6874:	e0bffa17 	ldw	r2,-24(fp)
 90c6878:	113ffe04 	addi	r4,r2,-8
 90c687c:	e0bffe0b 	ldhu	r2,-8(fp)
 90c6880:	10800204 	addi	r2,r2,8
 90c6884:	1005d07a 	srai	r2,r2,1
 90c6888:	100b883a 	mov	r5,r2
 90c688c:	90a3f040 	call	90a3f04 <cksum>
 90c6890:	0084303a 	nor	r2,zero,r2
 90c6894:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 90c6898:	e0fffb0b 	ldhu	r3,-20(fp)
 90c689c:	e0bffb8b 	ldhu	r2,-18(fp)
 90c68a0:	18800826 	beq	r3,r2,90c68c4 <tcp_cksum+0x190>
 90c68a4:	e0fffb8b 	ldhu	r3,-18(fp)
 90c68a8:	00bfffd4 	movui	r2,65535
 90c68ac:	1880051e 	bne	r3,r2,90c68c4 <tcp_cksum+0x190>
 90c68b0:	e0bffb0b 	ldhu	r2,-20(fp)
 90c68b4:	1004c03a 	cmpne	r2,r2,zero
 90c68b8:	1000021e 	bne	r2,zero,90c68c4 <tcp_cksum+0x190>
      newsum = 0xffff;
 90c68bc:	00bfffc4 	movi	r2,-1
 90c68c0:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 90c68c4:	e0fffa17 	ldw	r3,-24(fp)
 90c68c8:	e0bffb8b 	ldhu	r2,-18(fp)
 90c68cc:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 90c68d0:	e0bffc07 	ldb	r2,-16(fp)
 90c68d4:	1005003a 	cmpeq	r2,r2,zero
 90c68d8:	1000031e 	bne	r2,zero,90c68e8 <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 90c68dc:	e0fffd17 	ldw	r3,-12(fp)
 90c68e0:	e0bffc03 	ldbu	r2,-16(fp)
 90c68e4:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 90c68e8:	e0bffb0b 	ldhu	r2,-20(fp)
}
 90c68ec:	e037883a 	mov	sp,fp
 90c68f0:	dfc00117 	ldw	ra,4(sp)
 90c68f4:	df000017 	ldw	fp,0(sp)
 90c68f8:	dec00204 	addi	sp,sp,8
 90c68fc:	f800283a 	ret

090c6900 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 90c6900:	defffa04 	addi	sp,sp,-24
 90c6904:	dfc00515 	stw	ra,20(sp)
 90c6908:	df000415 	stw	fp,16(sp)
 90c690c:	df000404 	addi	fp,sp,16
 90c6910:	e13ffd15 	stw	r4,-12(fp)
 90c6914:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 90c6918:	01000b04 	movi	r4,44
 90c691c:	90a9f0c0 	call	90a9f0c <npalloc>
 90c6920:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 90c6924:	e0bffc17 	ldw	r2,-16(fp)
 90c6928:	1004c03a 	cmpne	r2,r2,zero
 90c692c:	1000031e 	bne	r2,zero,90c693c <in_pcballoc+0x3c>
      return ENOMEM;
 90c6930:	00800304 	movi	r2,12
 90c6934:	e0bfff15 	stw	r2,-4(fp)
 90c6938:	00001006 	br	90c697c <in_pcballoc+0x7c>
   inp->inp_head = head;
 90c693c:	e0fffc17 	ldw	r3,-16(fp)
 90c6940:	e0bffe17 	ldw	r2,-8(fp)
 90c6944:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 90c6948:	e0fffc17 	ldw	r3,-16(fp)
 90c694c:	e0bffd17 	ldw	r2,-12(fp)
 90c6950:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 90c6954:	e0fffc17 	ldw	r3,-16(fp)
 90c6958:	00808004 	movi	r2,512
 90c695c:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 90c6960:	e13ffc17 	ldw	r4,-16(fp)
 90c6964:	e17ffe17 	ldw	r5,-8(fp)
 90c6968:	90aac4c0 	call	90aac4c <insque>
   so->so_pcb = inp;
 90c696c:	e0fffd17 	ldw	r3,-12(fp)
 90c6970:	e0bffc17 	ldw	r2,-16(fp)
 90c6974:	18800115 	stw	r2,4(r3)
   return 0;
 90c6978:	e03fff15 	stw	zero,-4(fp)
 90c697c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6980:	e037883a 	mov	sp,fp
 90c6984:	dfc00117 	ldw	ra,4(sp)
 90c6988:	df000017 	ldw	fp,0(sp)
 90c698c:	dec00204 	addi	sp,sp,8
 90c6990:	f800283a 	ret

090c6994 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 90c6994:	defffc04 	addi	sp,sp,-16
 90c6998:	dfc00315 	stw	ra,12(sp)
 90c699c:	df000215 	stw	fp,8(sp)
 90c69a0:	df000204 	addi	fp,sp,8
 90c69a4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 90c69a8:	e0bfff17 	ldw	r2,-4(fp)
 90c69ac:	10800817 	ldw	r2,32(r2)
 90c69b0:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 90c69b4:	e0bffe17 	ldw	r2,-8(fp)
 90c69b8:	10000115 	stw	zero,4(r2)
   sofree(so);
 90c69bc:	e13ffe17 	ldw	r4,-8(fp)
 90c69c0:	90ae04c0 	call	90ae04c <sofree>
   remque(inp);
 90c69c4:	e13fff17 	ldw	r4,-4(fp)
 90c69c8:	90aabdc0 	call	90aabdc <remque>
   INP_FREE (inp);
 90c69cc:	e13fff17 	ldw	r4,-4(fp)
 90c69d0:	90aa0000 	call	90aa000 <npfree>
}
 90c69d4:	e037883a 	mov	sp,fp
 90c69d8:	dfc00117 	ldw	ra,4(sp)
 90c69dc:	df000017 	ldw	fp,0(sp)
 90c69e0:	dec00204 	addi	sp,sp,8
 90c69e4:	f800283a 	ret

090c69e8 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 90c69e8:	defff404 	addi	sp,sp,-48
 90c69ec:	dfc00b15 	stw	ra,44(sp)
 90c69f0:	df000a15 	stw	fp,40(sp)
 90c69f4:	df000a04 	addi	fp,sp,40
 90c69f8:	e13ffd15 	stw	r4,-12(fp)
 90c69fc:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 90c6a00:	e0bffd17 	ldw	r2,-12(fp)
 90c6a04:	10800817 	ldw	r2,32(r2)
 90c6a08:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 90c6a0c:	e0bffd17 	ldw	r2,-12(fp)
 90c6a10:	10800217 	ldw	r2,8(r2)
 90c6a14:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 90c6a18:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 90c6a1c:	e0bffd17 	ldw	r2,-12(fp)
 90c6a20:	1080078b 	ldhu	r2,30(r2)
 90c6a24:	10bfffcc 	andi	r2,r2,65535
 90c6a28:	1004c03a 	cmpne	r2,r2,zero
 90c6a2c:	1000041e 	bne	r2,zero,90c6a40 <in_pcbbind+0x58>
 90c6a30:	e0bffd17 	ldw	r2,-12(fp)
 90c6a34:	10800417 	ldw	r2,16(r2)
 90c6a38:	1005003a 	cmpeq	r2,r2,zero
 90c6a3c:	1000031e 	bne	r2,zero,90c6a4c <in_pcbbind+0x64>
      return (EINVAL);
 90c6a40:	00800584 	movi	r2,22
 90c6a44:	e0bfff15 	stw	r2,-4(fp)
 90c6a48:	00007606 	br	90c6c24 <in_pcbbind+0x23c>
   if (nam == 0)
 90c6a4c:	e0bffe17 	ldw	r2,-8(fp)
 90c6a50:	1005003a 	cmpeq	r2,r2,zero
 90c6a54:	10003e1e 	bne	r2,zero,90c6b50 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 90c6a58:	e0bffe17 	ldw	r2,-8(fp)
 90c6a5c:	10800317 	ldw	r2,12(r2)
 90c6a60:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 90c6a64:	e0bffa17 	ldw	r2,-24(fp)
 90c6a68:	10800117 	ldw	r2,4(r2)
 90c6a6c:	1005003a 	cmpeq	r2,r2,zero
 90c6a70:	10000a1e 	bne	r2,zero,90c6a9c <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 90c6a74:	e0bffa17 	ldw	r2,-24(fp)
 90c6a78:	11000117 	ldw	r4,4(r2)
 90c6a7c:	90beb200 	call	90beb20 <ip_mymach>
 90c6a80:	1007883a 	mov	r3,r2
 90c6a84:	e0bffa17 	ldw	r2,-24(fp)
 90c6a88:	10800117 	ldw	r2,4(r2)
 90c6a8c:	18800326 	beq	r3,r2,90c6a9c <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 90c6a90:	00801f44 	movi	r2,125
 90c6a94:	e0bfff15 	stw	r2,-4(fp)
 90c6a98:	00006206 	br	90c6c24 <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 90c6a9c:	e0bffa17 	ldw	r2,-24(fp)
 90c6aa0:	1080008b 	ldhu	r2,2(r2)
 90c6aa4:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 90c6aa8:	e0bff90b 	ldhu	r2,-28(fp)
 90c6aac:	1005003a 	cmpeq	r2,r2,zero
 90c6ab0:	1000231e 	bne	r2,zero,90c6b40 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 90c6ab4:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 90c6ab8:	e0bffc17 	ldw	r2,-16(fp)
 90c6abc:	10800417 	ldw	r2,16(r2)
 90c6ac0:	1080010c 	andi	r2,r2,4
 90c6ac4:	1004c03a 	cmpne	r2,r2,zero
 90c6ac8:	10000e1e 	bne	r2,zero,90c6b04 <in_pcbbind+0x11c>
 90c6acc:	e0bffc17 	ldw	r2,-16(fp)
 90c6ad0:	10800217 	ldw	r2,8(r2)
 90c6ad4:	1080010b 	ldhu	r2,4(r2)
 90c6ad8:	10bfffcc 	andi	r2,r2,65535
 90c6adc:	1080010c 	andi	r2,r2,4
 90c6ae0:	1005003a 	cmpeq	r2,r2,zero
 90c6ae4:	1000051e 	bne	r2,zero,90c6afc <in_pcbbind+0x114>
 90c6ae8:	e0bffc17 	ldw	r2,-16(fp)
 90c6aec:	10800417 	ldw	r2,16(r2)
 90c6af0:	1080008c 	andi	r2,r2,2
 90c6af4:	1004c03a 	cmpne	r2,r2,zero
 90c6af8:	1000021e 	bne	r2,zero,90c6b04 <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 90c6afc:	00800044 	movi	r2,1
 90c6b00:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 90c6b04:	e0bffa17 	ldw	r2,-24(fp)
 90c6b08:	11c00117 	ldw	r7,4(r2)
 90c6b0c:	e0bff90b 	ldhu	r2,-28(fp)
 90c6b10:	d8800015 	stw	r2,0(sp)
 90c6b14:	e0bff817 	ldw	r2,-32(fp)
 90c6b18:	d8800115 	stw	r2,4(sp)
 90c6b1c:	e13ffb17 	ldw	r4,-20(fp)
 90c6b20:	000b883a 	mov	r5,zero
 90c6b24:	000d883a 	mov	r6,zero
 90c6b28:	90c6fa40 	call	90c6fa4 <in_pcblookup>
 90c6b2c:	1005003a 	cmpeq	r2,r2,zero
 90c6b30:	1000031e 	bne	r2,zero,90c6b40 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 90c6b34:	00801c04 	movi	r2,112
 90c6b38:	e0bfff15 	stw	r2,-4(fp)
 90c6b3c:	00003906 	br	90c6c24 <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 90c6b40:	e0bffa17 	ldw	r2,-24(fp)
 90c6b44:	10c00117 	ldw	r3,4(r2)
 90c6b48:	e0bffd17 	ldw	r2,-12(fp)
 90c6b4c:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 90c6b50:	e0bff90b 	ldhu	r2,-28(fp)
 90c6b54:	1004c03a 	cmpne	r2,r2,zero
 90c6b58:	10002e1e 	bne	r2,zero,90c6c14 <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 90c6b5c:	e0bffb17 	ldw	r2,-20(fp)
 90c6b60:	10c0078b 	ldhu	r3,30(r2)
 90c6b64:	18bfffcc 	andi	r2,r3,65535
 90c6b68:	10810030 	cmpltui	r2,r2,1024
 90c6b6c:	1009883a 	mov	r4,r2
 90c6b70:	18800044 	addi	r2,r3,1
 90c6b74:	1007883a 	mov	r3,r2
 90c6b78:	e0bffb17 	ldw	r2,-20(fp)
 90c6b7c:	10c0078d 	sth	r3,30(r2)
 90c6b80:	20803fcc 	andi	r2,r4,255
 90c6b84:	1004c03a 	cmpne	r2,r2,zero
 90c6b88:	1000051e 	bne	r2,zero,90c6ba0 <in_pcbbind+0x1b8>
 90c6b8c:	e0bffb17 	ldw	r2,-20(fp)
 90c6b90:	1080078b 	ldhu	r2,30(r2)
 90c6b94:	10bfffcc 	andi	r2,r2,65535
 90c6b98:	1084e270 	cmpltui	r2,r2,5001
 90c6b9c:	1000031e 	bne	r2,zero,90c6bac <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 90c6ba0:	e0fffb17 	ldw	r3,-20(fp)
 90c6ba4:	00810004 	movi	r2,1024
 90c6ba8:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 90c6bac:	e0bffb17 	ldw	r2,-20(fp)
 90c6bb0:	1080078b 	ldhu	r2,30(r2)
 90c6bb4:	10bfffcc 	andi	r2,r2,65535
 90c6bb8:	1004d23a 	srli	r2,r2,8
 90c6bbc:	10803fcc 	andi	r2,r2,255
 90c6bc0:	1009883a 	mov	r4,r2
 90c6bc4:	e0bffb17 	ldw	r2,-20(fp)
 90c6bc8:	1080078b 	ldhu	r2,30(r2)
 90c6bcc:	10bfffcc 	andi	r2,r2,65535
 90c6bd0:	1004923a 	slli	r2,r2,8
 90c6bd4:	1007883a 	mov	r3,r2
 90c6bd8:	00bfc004 	movi	r2,-256
 90c6bdc:	1884703a 	and	r2,r3,r2
 90c6be0:	2084b03a 	or	r2,r4,r2
 90c6be4:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 90c6be8:	e0bffd17 	ldw	r2,-12(fp)
 90c6bec:	11c00417 	ldw	r7,16(r2)
 90c6bf0:	e0bff90b 	ldhu	r2,-28(fp)
 90c6bf4:	d8800015 	stw	r2,0(sp)
 90c6bf8:	d8000115 	stw	zero,4(sp)
 90c6bfc:	e13ffb17 	ldw	r4,-20(fp)
 90c6c00:	000b883a 	mov	r5,zero
 90c6c04:	000d883a 	mov	r6,zero
 90c6c08:	90c6fa40 	call	90c6fa4 <in_pcblookup>
 90c6c0c:	1004c03a 	cmpne	r2,r2,zero
 90c6c10:	103fd21e 	bne	r2,zero,90c6b5c <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 90c6c14:	e0fffd17 	ldw	r3,-12(fp)
 90c6c18:	e0bff90b 	ldhu	r2,-28(fp)
 90c6c1c:	1880078d 	sth	r2,30(r3)
   return (0);
 90c6c20:	e03fff15 	stw	zero,-4(fp)
 90c6c24:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6c28:	e037883a 	mov	sp,fp
 90c6c2c:	dfc00117 	ldw	ra,4(sp)
 90c6c30:	df000017 	ldw	fp,0(sp)
 90c6c34:	dec00204 	addi	sp,sp,8
 90c6c38:	f800283a 	ret

090c6c3c <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 90c6c3c:	defff504 	addi	sp,sp,-44
 90c6c40:	dfc00a15 	stw	ra,40(sp)
 90c6c44:	df000915 	stw	fp,36(sp)
 90c6c48:	df000904 	addi	fp,sp,36
 90c6c4c:	e13ffd15 	stw	r4,-12(fp)
 90c6c50:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 90c6c54:	e0bffe17 	ldw	r2,-8(fp)
 90c6c58:	10800317 	ldw	r2,12(r2)
 90c6c5c:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 90c6c60:	e0bffe17 	ldw	r2,-8(fp)
 90c6c64:	10800217 	ldw	r2,8(r2)
 90c6c68:	10800428 	cmpgeui	r2,r2,16
 90c6c6c:	1000031e 	bne	r2,zero,90c6c7c <in_pcbconnect+0x40>
      return (EINVAL);
 90c6c70:	00800584 	movi	r2,22
 90c6c74:	e0bfff15 	stw	r2,-4(fp)
 90c6c78:	00006e06 	br	90c6e34 <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 90c6c7c:	e0bffa17 	ldw	r2,-24(fp)
 90c6c80:	1080000b 	ldhu	r2,0(r2)
 90c6c84:	10bfffcc 	andi	r2,r2,65535
 90c6c88:	10a0001c 	xori	r2,r2,32768
 90c6c8c:	10a00004 	addi	r2,r2,-32768
 90c6c90:	108000a0 	cmpeqi	r2,r2,2
 90c6c94:	1000031e 	bne	r2,zero,90c6ca4 <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 90c6c98:	00801a84 	movi	r2,106
 90c6c9c:	e0bfff15 	stw	r2,-4(fp)
 90c6ca0:	00006406 	br	90c6e34 <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 90c6ca4:	e0bffa17 	ldw	r2,-24(fp)
 90c6ca8:	1080008b 	ldhu	r2,2(r2)
 90c6cac:	10bfffcc 	andi	r2,r2,65535
 90c6cb0:	1004c03a 	cmpne	r2,r2,zero
 90c6cb4:	1000031e 	bne	r2,zero,90c6cc4 <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 90c6cb8:	00801f44 	movi	r2,125
 90c6cbc:	e0bfff15 	stw	r2,-4(fp)
 90c6cc0:	00005c06 	br	90c6e34 <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 90c6cc4:	e0bffa17 	ldw	r2,-24(fp)
 90c6cc8:	10800117 	ldw	r2,4(r2)
 90c6ccc:	1004c03a 	cmpne	r2,r2,zero
 90c6cd0:	1000101e 	bne	r2,zero,90c6d14 <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 90c6cd4:	e0bffd17 	ldw	r2,-12(fp)
 90c6cd8:	1005003a 	cmpeq	r2,r2,zero
 90c6cdc:	10000a1e 	bne	r2,zero,90c6d08 <in_pcbconnect+0xcc>
 90c6ce0:	e0bffd17 	ldw	r2,-12(fp)
 90c6ce4:	10800a17 	ldw	r2,40(r2)
 90c6ce8:	1005003a 	cmpeq	r2,r2,zero
 90c6cec:	1000061e 	bne	r2,zero,90c6d08 <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 90c6cf0:	e0bffd17 	ldw	r2,-12(fp)
 90c6cf4:	10800a17 	ldw	r2,40(r2)
 90c6cf8:	10c00a17 	ldw	r3,40(r2)
 90c6cfc:	e0bffa17 	ldw	r2,-24(fp)
 90c6d00:	10c00115 	stw	r3,4(r2)
 90c6d04:	00000a06 	br	90c6d30 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 90c6d08:	00801f44 	movi	r2,125
 90c6d0c:	e0bfff15 	stw	r2,-4(fp)
 90c6d10:	00004806 	br	90c6e34 <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 90c6d14:	e0bffa17 	ldw	r2,-24(fp)
 90c6d18:	10800117 	ldw	r2,4(r2)
 90c6d1c:	10bfffd8 	cmpnei	r2,r2,-1
 90c6d20:	1000031e 	bne	r2,zero,90c6d30 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 90c6d24:	00801f44 	movi	r2,125
 90c6d28:	e0bfff15 	stw	r2,-4(fp)
 90c6d2c:	00004106 	br	90c6e34 <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 90c6d30:	e0bffd17 	ldw	r2,-12(fp)
 90c6d34:	10800417 	ldw	r2,16(r2)
 90c6d38:	1004c03a 	cmpne	r2,r2,zero
 90c6d3c:	10000f1e 	bne	r2,zero,90c6d7c <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 90c6d40:	e0bffa17 	ldw	r2,-24(fp)
 90c6d44:	11000117 	ldw	r4,4(r2)
 90c6d48:	e17ffc04 	addi	r5,fp,-16
 90c6d4c:	90bee840 	call	90bee84 <iproute>
 90c6d50:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 90c6d54:	e0bff917 	ldw	r2,-28(fp)
 90c6d58:	1004c03a 	cmpne	r2,r2,zero
 90c6d5c:	1000031e 	bne	r2,zero,90c6d6c <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 90c6d60:	00801f44 	movi	r2,125
 90c6d64:	e0bfff15 	stw	r2,-4(fp)
 90c6d68:	00003206 	br	90c6e34 <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 90c6d6c:	e0bff917 	ldw	r2,-28(fp)
 90c6d70:	10800a17 	ldw	r2,40(r2)
 90c6d74:	e0bffb15 	stw	r2,-20(fp)
 90c6d78:	00000306 	br	90c6d88 <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 90c6d7c:	e0bffd17 	ldw	r2,-12(fp)
 90c6d80:	10800417 	ldw	r2,16(r2)
 90c6d84:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 90c6d88:	e0bffd17 	ldw	r2,-12(fp)
 90c6d8c:	11000217 	ldw	r4,8(r2)
 90c6d90:	e0bffa17 	ldw	r2,-24(fp)
 90c6d94:	11400117 	ldw	r5,4(r2)
 90c6d98:	e0bffa17 	ldw	r2,-24(fp)
 90c6d9c:	1080008b 	ldhu	r2,2(r2)
 90c6da0:	11bfffcc 	andi	r6,r2,65535
 90c6da4:	e0bffd17 	ldw	r2,-12(fp)
 90c6da8:	1080078b 	ldhu	r2,30(r2)
 90c6dac:	10bfffcc 	andi	r2,r2,65535
 90c6db0:	d8800015 	stw	r2,0(sp)
 90c6db4:	d8000115 	stw	zero,4(sp)
 90c6db8:	e1fffb17 	ldw	r7,-20(fp)
 90c6dbc:	90c6fa40 	call	90c6fa4 <in_pcblookup>
 90c6dc0:	1005003a 	cmpeq	r2,r2,zero
 90c6dc4:	1000031e 	bne	r2,zero,90c6dd4 <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 90c6dc8:	00801c04 	movi	r2,112
 90c6dcc:	e0bfff15 	stw	r2,-4(fp)
 90c6dd0:	00001806 	br	90c6e34 <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 90c6dd4:	e0bffd17 	ldw	r2,-12(fp)
 90c6dd8:	10800417 	ldw	r2,16(r2)
 90c6ddc:	1004c03a 	cmpne	r2,r2,zero
 90c6de0:	10000b1e 	bne	r2,zero,90c6e10 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 90c6de4:	e0bffd17 	ldw	r2,-12(fp)
 90c6de8:	1080078b 	ldhu	r2,30(r2)
 90c6dec:	10bfffcc 	andi	r2,r2,65535
 90c6df0:	1004c03a 	cmpne	r2,r2,zero
 90c6df4:	1000031e 	bne	r2,zero,90c6e04 <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 90c6df8:	e13ffd17 	ldw	r4,-12(fp)
 90c6dfc:	000b883a 	mov	r5,zero
 90c6e00:	90c69e80 	call	90c69e8 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 90c6e04:	e0fffd17 	ldw	r3,-12(fp)
 90c6e08:	e0bffb17 	ldw	r2,-20(fp)
 90c6e0c:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 90c6e10:	e0bffa17 	ldw	r2,-24(fp)
 90c6e14:	10c00117 	ldw	r3,4(r2)
 90c6e18:	e0bffd17 	ldw	r2,-12(fp)
 90c6e1c:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 90c6e20:	e0bffa17 	ldw	r2,-24(fp)
 90c6e24:	10c0008b 	ldhu	r3,2(r2)
 90c6e28:	e0bffd17 	ldw	r2,-12(fp)
 90c6e2c:	10c0070d 	sth	r3,28(r2)
   return 0;
 90c6e30:	e03fff15 	stw	zero,-4(fp)
 90c6e34:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6e38:	e037883a 	mov	sp,fp
 90c6e3c:	dfc00117 	ldw	ra,4(sp)
 90c6e40:	df000017 	ldw	fp,0(sp)
 90c6e44:	dec00204 	addi	sp,sp,8
 90c6e48:	f800283a 	ret

090c6e4c <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 90c6e4c:	defffd04 	addi	sp,sp,-12
 90c6e50:	dfc00215 	stw	ra,8(sp)
 90c6e54:	df000115 	stw	fp,4(sp)
 90c6e58:	df000104 	addi	fp,sp,4
 90c6e5c:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 90c6e60:	e0bfff17 	ldw	r2,-4(fp)
 90c6e64:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 90c6e68:	e0bfff17 	ldw	r2,-4(fp)
 90c6e6c:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 90c6e70:	e0bfff17 	ldw	r2,-4(fp)
 90c6e74:	10800817 	ldw	r2,32(r2)
 90c6e78:	1080088b 	ldhu	r2,34(r2)
 90c6e7c:	10bfffcc 	andi	r2,r2,65535
 90c6e80:	1080004c 	andi	r2,r2,1
 90c6e84:	10803fcc 	andi	r2,r2,255
 90c6e88:	1005003a 	cmpeq	r2,r2,zero
 90c6e8c:	1000021e 	bne	r2,zero,90c6e98 <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 90c6e90:	e13fff17 	ldw	r4,-4(fp)
 90c6e94:	90c69940 	call	90c6994 <in_pcbdetach>
}
 90c6e98:	e037883a 	mov	sp,fp
 90c6e9c:	dfc00117 	ldw	ra,4(sp)
 90c6ea0:	df000017 	ldw	fp,0(sp)
 90c6ea4:	dec00204 	addi	sp,sp,8
 90c6ea8:	f800283a 	ret

090c6eac <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 90c6eac:	defffc04 	addi	sp,sp,-16
 90c6eb0:	df000315 	stw	fp,12(sp)
 90c6eb4:	df000304 	addi	fp,sp,12
 90c6eb8:	e13ffe15 	stw	r4,-8(fp)
 90c6ebc:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 90c6ec0:	e0ffff17 	ldw	r3,-4(fp)
 90c6ec4:	00800404 	movi	r2,16
 90c6ec8:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 90c6ecc:	e0bfff17 	ldw	r2,-4(fp)
 90c6ed0:	10800317 	ldw	r2,12(r2)
 90c6ed4:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 90c6ed8:	e0bffd17 	ldw	r2,-12(fp)
 90c6edc:	10000015 	stw	zero,0(r2)
 90c6ee0:	10000115 	stw	zero,4(r2)
 90c6ee4:	10000215 	stw	zero,8(r2)
 90c6ee8:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 90c6eec:	e0fffd17 	ldw	r3,-12(fp)
 90c6ef0:	00800084 	movi	r2,2
 90c6ef4:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 90c6ef8:	e0bffe17 	ldw	r2,-8(fp)
 90c6efc:	10c0078b 	ldhu	r3,30(r2)
 90c6f00:	e0bffd17 	ldw	r2,-12(fp)
 90c6f04:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 90c6f08:	e0bffe17 	ldw	r2,-8(fp)
 90c6f0c:	10c00417 	ldw	r3,16(r2)
 90c6f10:	e0bffd17 	ldw	r2,-12(fp)
 90c6f14:	10c00115 	stw	r3,4(r2)
}
 90c6f18:	e037883a 	mov	sp,fp
 90c6f1c:	df000017 	ldw	fp,0(sp)
 90c6f20:	dec00104 	addi	sp,sp,4
 90c6f24:	f800283a 	ret

090c6f28 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 90c6f28:	defffc04 	addi	sp,sp,-16
 90c6f2c:	df000315 	stw	fp,12(sp)
 90c6f30:	df000304 	addi	fp,sp,12
 90c6f34:	e13ffe15 	stw	r4,-8(fp)
 90c6f38:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 90c6f3c:	e0ffff17 	ldw	r3,-4(fp)
 90c6f40:	00800404 	movi	r2,16
 90c6f44:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 90c6f48:	e0bfff17 	ldw	r2,-4(fp)
 90c6f4c:	10800317 	ldw	r2,12(r2)
 90c6f50:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 90c6f54:	e0bffd17 	ldw	r2,-12(fp)
 90c6f58:	10000015 	stw	zero,0(r2)
 90c6f5c:	10000115 	stw	zero,4(r2)
 90c6f60:	10000215 	stw	zero,8(r2)
 90c6f64:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 90c6f68:	e0fffd17 	ldw	r3,-12(fp)
 90c6f6c:	00800084 	movi	r2,2
 90c6f70:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 90c6f74:	e0bffe17 	ldw	r2,-8(fp)
 90c6f78:	10c0070b 	ldhu	r3,28(r2)
 90c6f7c:	e0bffd17 	ldw	r2,-12(fp)
 90c6f80:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 90c6f84:	e0bffe17 	ldw	r2,-8(fp)
 90c6f88:	10c00317 	ldw	r3,12(r2)
 90c6f8c:	e0bffd17 	ldw	r2,-12(fp)
 90c6f90:	10c00115 	stw	r3,4(r2)
}
 90c6f94:	e037883a 	mov	sp,fp
 90c6f98:	df000017 	ldw	fp,0(sp)
 90c6f9c:	dec00104 	addi	sp,sp,4
 90c6fa0:	f800283a 	ret

090c6fa4 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 90c6fa4:	defff404 	addi	sp,sp,-48
 90c6fa8:	df000b15 	stw	fp,44(sp)
 90c6fac:	df000b04 	addi	fp,sp,44
 90c6fb0:	e13ffa15 	stw	r4,-24(fp)
 90c6fb4:	e17ffb15 	stw	r5,-20(fp)
 90c6fb8:	e1fffd15 	stw	r7,-12(fp)
 90c6fbc:	e0800117 	ldw	r2,4(fp)
 90c6fc0:	e1bffc0d 	sth	r6,-16(fp)
 90c6fc4:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 90c6fc8:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 90c6fcc:	e0bffc0b 	ldhu	r2,-16(fp)
 90c6fd0:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 90c6fd4:	e0bffe0b 	ldhu	r2,-8(fp)
 90c6fd8:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 90c6fdc:	008000c4 	movi	r2,3
 90c6fe0:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 90c6fe4:	e0bffa17 	ldw	r2,-24(fp)
 90c6fe8:	10800017 	ldw	r2,0(r2)
 90c6fec:	e0bff915 	stw	r2,-28(fp)
 90c6ff0:	00005006 	br	90c7134 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 90c6ff4:	e0bff917 	ldw	r2,-28(fp)
 90c6ff8:	1080078b 	ldhu	r2,30(r2)
 90c6ffc:	10ffffcc 	andi	r3,r2,65535
 90c7000:	e0bff70b 	ldhu	r2,-36(fp)
 90c7004:	1880481e 	bne	r3,r2,90c7128 <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 90c7008:	e0bff917 	ldw	r2,-28(fp)
 90c700c:	10800817 	ldw	r2,32(r2)
 90c7010:	10800517 	ldw	r2,20(r2)
 90c7014:	10800098 	cmpnei	r2,r2,2
 90c7018:	1000431e 	bne	r2,zero,90c7128 <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 90c701c:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 90c7020:	e0bff917 	ldw	r2,-28(fp)
 90c7024:	10800417 	ldw	r2,16(r2)
 90c7028:	1005003a 	cmpeq	r2,r2,zero
 90c702c:	10000c1e 	bne	r2,zero,90c7060 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 90c7030:	e0bffd17 	ldw	r2,-12(fp)
 90c7034:	1004c03a 	cmpne	r2,r2,zero
 90c7038:	1000041e 	bne	r2,zero,90c704c <in_pcblookup+0xa8>
            wildcard++;
 90c703c:	e0bff517 	ldw	r2,-44(fp)
 90c7040:	10800044 	addi	r2,r2,1
 90c7044:	e0bff515 	stw	r2,-44(fp)
 90c7048:	00000b06 	br	90c7078 <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 90c704c:	e0bff917 	ldw	r2,-28(fp)
 90c7050:	10c00417 	ldw	r3,16(r2)
 90c7054:	e0bffd17 	ldw	r2,-12(fp)
 90c7058:	1880331e 	bne	r3,r2,90c7128 <in_pcblookup+0x184>
            continue;
 90c705c:	00000606 	br	90c7078 <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 90c7060:	e0bffd17 	ldw	r2,-12(fp)
 90c7064:	1005003a 	cmpeq	r2,r2,zero
 90c7068:	1000031e 	bne	r2,zero,90c7078 <in_pcblookup+0xd4>
            wildcard++;
 90c706c:	e0bff517 	ldw	r2,-44(fp)
 90c7070:	10800044 	addi	r2,r2,1
 90c7074:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 90c7078:	e0bff917 	ldw	r2,-28(fp)
 90c707c:	10800317 	ldw	r2,12(r2)
 90c7080:	1005003a 	cmpeq	r2,r2,zero
 90c7084:	1000111e 	bne	r2,zero,90c70cc <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 90c7088:	e0bffb17 	ldw	r2,-20(fp)
 90c708c:	1004c03a 	cmpne	r2,r2,zero
 90c7090:	1000041e 	bne	r2,zero,90c70a4 <in_pcblookup+0x100>
            wildcard++;
 90c7094:	e0bff517 	ldw	r2,-44(fp)
 90c7098:	10800044 	addi	r2,r2,1
 90c709c:	e0bff515 	stw	r2,-44(fp)
 90c70a0:	00001006 	br	90c70e4 <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 90c70a4:	e0bff917 	ldw	r2,-28(fp)
 90c70a8:	10c00317 	ldw	r3,12(r2)
 90c70ac:	e0bffb17 	ldw	r2,-20(fp)
 90c70b0:	18801d1e 	bne	r3,r2,90c7128 <in_pcblookup+0x184>
 90c70b4:	e0bff917 	ldw	r2,-28(fp)
 90c70b8:	1080070b 	ldhu	r2,28(r2)
 90c70bc:	10ffffcc 	andi	r3,r2,65535
 90c70c0:	e0bff78b 	ldhu	r2,-34(fp)
 90c70c4:	1880181e 	bne	r3,r2,90c7128 <in_pcblookup+0x184>
 90c70c8:	00000606 	br	90c70e4 <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 90c70cc:	e0bffb17 	ldw	r2,-20(fp)
 90c70d0:	1005003a 	cmpeq	r2,r2,zero
 90c70d4:	1000031e 	bne	r2,zero,90c70e4 <in_pcblookup+0x140>
            wildcard++;
 90c70d8:	e0bff517 	ldw	r2,-44(fp)
 90c70dc:	10800044 	addi	r2,r2,1
 90c70e0:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 90c70e4:	e0bff517 	ldw	r2,-44(fp)
 90c70e8:	1005003a 	cmpeq	r2,r2,zero
 90c70ec:	1000041e 	bne	r2,zero,90c7100 <in_pcblookup+0x15c>
 90c70f0:	e0800217 	ldw	r2,8(fp)
 90c70f4:	1080004c 	andi	r2,r2,1
 90c70f8:	1005003a 	cmpeq	r2,r2,zero
 90c70fc:	10000a1e 	bne	r2,zero,90c7128 <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 90c7100:	e0fff517 	ldw	r3,-44(fp)
 90c7104:	e0bff617 	ldw	r2,-40(fp)
 90c7108:	1880070e 	bge	r3,r2,90c7128 <in_pcblookup+0x184>
      {
         match = inp;
 90c710c:	e0bff917 	ldw	r2,-28(fp)
 90c7110:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 90c7114:	e0bff517 	ldw	r2,-44(fp)
 90c7118:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 90c711c:	e0bff617 	ldw	r2,-40(fp)
 90c7120:	1005003a 	cmpeq	r2,r2,zero
 90c7124:	1000061e 	bne	r2,zero,90c7140 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 90c7128:	e0bff917 	ldw	r2,-28(fp)
 90c712c:	10800017 	ldw	r2,0(r2)
 90c7130:	e0bff915 	stw	r2,-28(fp)
 90c7134:	e0fff917 	ldw	r3,-28(fp)
 90c7138:	e0bffa17 	ldw	r2,-24(fp)
 90c713c:	18bfad1e 	bne	r3,r2,90c6ff4 <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 90c7140:	e0bff817 	ldw	r2,-32(fp)
 90c7144:	1004c03a 	cmpne	r2,r2,zero
 90c7148:	1000031e 	bne	r2,zero,90c7158 <in_pcblookup+0x1b4>
      return match;
 90c714c:	e0bff817 	ldw	r2,-32(fp)
 90c7150:	e0bfff15 	stw	r2,-4(fp)
 90c7154:	00002506 	br	90c71ec <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 90c7158:	e0bffa17 	ldw	r2,-24(fp)
 90c715c:	10c00017 	ldw	r3,0(r2)
 90c7160:	e0bff817 	ldw	r2,-32(fp)
 90c7164:	1880041e 	bne	r3,r2,90c7178 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 90c7168:	d0a0d217 	ldw	r2,-31928(gp)
 90c716c:	10800044 	addi	r2,r2,1
 90c7170:	d0a0d215 	stw	r2,-31928(gp)
 90c7174:	00001b06 	br	90c71e4 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 90c7178:	d0a0d317 	ldw	r2,-31924(gp)
 90c717c:	10800044 	addi	r2,r2,1
 90c7180:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 90c7184:	e0bff817 	ldw	r2,-32(fp)
 90c7188:	10c00017 	ldw	r3,0(r2)
 90c718c:	e0bff817 	ldw	r2,-32(fp)
 90c7190:	10800117 	ldw	r2,4(r2)
 90c7194:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 90c7198:	e0bff817 	ldw	r2,-32(fp)
 90c719c:	10c00117 	ldw	r3,4(r2)
 90c71a0:	e0bff817 	ldw	r2,-32(fp)
 90c71a4:	10800017 	ldw	r2,0(r2)
 90c71a8:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 90c71ac:	e0bffa17 	ldw	r2,-24(fp)
 90c71b0:	10c00017 	ldw	r3,0(r2)
 90c71b4:	e0bff817 	ldw	r2,-32(fp)
 90c71b8:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 90c71bc:	e0fffa17 	ldw	r3,-24(fp)
 90c71c0:	e0bff817 	ldw	r2,-32(fp)
 90c71c4:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 90c71c8:	e0fff817 	ldw	r3,-32(fp)
 90c71cc:	e0bffa17 	ldw	r2,-24(fp)
 90c71d0:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 90c71d4:	e0bff817 	ldw	r2,-32(fp)
 90c71d8:	10c00017 	ldw	r3,0(r2)
 90c71dc:	e0bff817 	ldw	r2,-32(fp)
 90c71e0:	18800115 	stw	r2,4(r3)
   }
   return (match);
 90c71e4:	e0bff817 	ldw	r2,-32(fp)
 90c71e8:	e0bfff15 	stw	r2,-4(fp)
 90c71ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90c71f0:	e037883a 	mov	sp,fp
 90c71f4:	df000017 	ldw	fp,0(sp)
 90c71f8:	dec00104 	addi	sp,sp,4
 90c71fc:	f800283a 	ret

090c7200 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 90c7200:	defffe04 	addi	sp,sp,-8
 90c7204:	df000115 	stw	fp,4(sp)
 90c7208:	df000104 	addi	fp,sp,4
 90c720c:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 90c7210:	e0bfff17 	ldw	r2,-4(fp)
 90c7214:	d0a0d715 	stw	r2,-31908(gp)
}
 90c7218:	e037883a 	mov	sp,fp
 90c721c:	df000017 	ldw	fp,0(sp)
 90c7220:	dec00104 	addi	sp,sp,4
 90c7224:	f800283a 	ret

090c7228 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 90c7228:	deffff04 	addi	sp,sp,-4
 90c722c:	df000015 	stw	fp,0(sp)
 90c7230:	d839883a 	mov	fp,sp
   return vfopen_error;
 90c7234:	d0a0d717 	ldw	r2,-31908(gp)
}
 90c7238:	e037883a 	mov	sp,fp
 90c723c:	df000017 	ldw	fp,0(sp)
 90c7240:	dec00104 	addi	sp,sp,4
 90c7244:	f800283a 	ret

090c7248 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 90c7248:	defffc04 	addi	sp,sp,-16
 90c724c:	dfc00315 	stw	ra,12(sp)
 90c7250:	df000215 	stw	fp,8(sp)
 90c7254:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 90c7258:	d0a0d917 	ldw	r2,-31900(gp)
 90c725c:	10803ff0 	cmpltui	r2,r2,255
 90c7260:	1000021e 	bne	r2,zero,90c726c <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 90c7264:	e03fff15 	stw	zero,-4(fp)
 90c7268:	00001006 	br	90c72ac <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 90c726c:	01000504 	movi	r4,20
 90c7270:	90a9f0c0 	call	90a9f0c <npalloc>
 90c7274:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 90c7278:	e0bffe17 	ldw	r2,-8(fp)
 90c727c:	1005003a 	cmpeq	r2,r2,zero
 90c7280:	1000081e 	bne	r2,zero,90c72a4 <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 90c7284:	d0e0d517 	ldw	r3,-31916(gp)
 90c7288:	e0bffe17 	ldw	r2,-8(fp)
 90c728c:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 90c7290:	e0bffe17 	ldw	r2,-8(fp)
 90c7294:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 90c7298:	d0a0d917 	ldw	r2,-31900(gp)
 90c729c:	10800044 	addi	r2,r2,1
 90c72a0:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 90c72a4:	e0bffe17 	ldw	r2,-8(fp)
 90c72a8:	e0bfff15 	stw	r2,-4(fp)
 90c72ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90c72b0:	e037883a 	mov	sp,fp
 90c72b4:	dfc00117 	ldw	ra,4(sp)
 90c72b8:	df000017 	ldw	fp,0(sp)
 90c72bc:	dec00204 	addi	sp,sp,8
 90c72c0:	f800283a 	ret

090c72c4 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 90c72c4:	defff804 	addi	sp,sp,-32
 90c72c8:	dfc00715 	stw	ra,28(sp)
 90c72cc:	df000615 	stw	fp,24(sp)
 90c72d0:	df000604 	addi	fp,sp,24
 90c72d4:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 90c72d8:	d0e0da17 	ldw	r3,-31896(gp)
 90c72dc:	e0bffe17 	ldw	r2,-8(fp)
 90c72e0:	1887883a 	add	r3,r3,r2
 90c72e4:	00bfffd4 	movui	r2,65535
 90c72e8:	10c0022e 	bgeu	r2,r3,90c72f4 <vf_alloc_buffer+0x30>
      return NULL;
 90c72ec:	e03fff15 	stw	zero,-4(fp)
 90c72f0:	00002406 	br	90c7384 <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 90c72f4:	00800104 	movi	r2,4
 90c72f8:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 90c72fc:	00800104 	movi	r2,4
 90c7300:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 90c7304:	e0fffc17 	ldw	r3,-16(fp)
 90c7308:	e0bffb17 	ldw	r2,-20(fp)
 90c730c:	10c0112e 	bgeu	r2,r3,90c7354 <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 90c7310:	e0bffb17 	ldw	r2,-20(fp)
 90c7314:	108000a0 	cmpeqi	r2,r2,2
 90c7318:	1000011e 	bne	r2,zero,90c7320 <vf_alloc_buffer+0x5c>
 90c731c:	00000806 	br	90c7340 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 90c7320:	00bffff4 	movhi	r2,65535
 90c7324:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 90c7328:	e0fffe17 	ldw	r3,-8(fp)
 90c732c:	e0bffa17 	ldw	r2,-24(fp)
 90c7330:	1884703a 	and	r2,r3,r2
 90c7334:	1004c03a 	cmpne	r2,r2,zero
 90c7338:	1000041e 	bne	r2,zero,90c734c <vf_alloc_buffer+0x88>
 90c733c:	00000506 	br	90c7354 <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 90c7340:	90a94880 	call	90a9488 <dtrap>
         return NULL;
 90c7344:	e03fff15 	stw	zero,-4(fp)
 90c7348:	00000e06 	br	90c7384 <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 90c734c:	e03fff15 	stw	zero,-4(fp)
 90c7350:	00000c06 	br	90c7384 <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 90c7354:	e13ffe17 	ldw	r4,-8(fp)
 90c7358:	90a9f0c0 	call	90a9f0c <npalloc>
 90c735c:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 90c7360:	e0bffd17 	ldw	r2,-12(fp)
 90c7364:	1005003a 	cmpeq	r2,r2,zero
 90c7368:	1000041e 	bne	r2,zero,90c737c <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 90c736c:	d0a0da17 	ldw	r2,-31896(gp)
 90c7370:	e0fffe17 	ldw	r3,-8(fp)
 90c7374:	10c5883a 	add	r2,r2,r3
 90c7378:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 90c737c:	e0bffd17 	ldw	r2,-12(fp)
 90c7380:	e0bfff15 	stw	r2,-4(fp)
 90c7384:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7388:	e037883a 	mov	sp,fp
 90c738c:	dfc00117 	ldw	ra,4(sp)
 90c7390:	df000017 	ldw	fp,0(sp)
 90c7394:	dec00204 	addi	sp,sp,8
 90c7398:	f800283a 	ret

090c739c <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 90c739c:	defffc04 	addi	sp,sp,-16
 90c73a0:	dfc00315 	stw	ra,12(sp)
 90c73a4:	df000215 	stw	fp,8(sp)
 90c73a8:	df000204 	addi	fp,sp,8
 90c73ac:	e13ffe15 	stw	r4,-8(fp)
 90c73b0:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 90c73b4:	e0bffe17 	ldw	r2,-8(fp)
 90c73b8:	1005003a 	cmpeq	r2,r2,zero
 90c73bc:	1000021e 	bne	r2,zero,90c73c8 <vf_free_buffer+0x2c>
      npfree(buffer);
 90c73c0:	e13ffe17 	ldw	r4,-8(fp)
 90c73c4:	90aa0000 	call	90aa000 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 90c73c8:	d0a0da17 	ldw	r2,-31896(gp)
 90c73cc:	e0ffff17 	ldw	r3,-4(fp)
 90c73d0:	10c5c83a 	sub	r2,r2,r3
 90c73d4:	d0a0da15 	stw	r2,-31896(gp)
}
 90c73d8:	e037883a 	mov	sp,fp
 90c73dc:	dfc00117 	ldw	ra,4(sp)
 90c73e0:	df000017 	ldw	fp,0(sp)
 90c73e4:	dec00204 	addi	sp,sp,8
 90c73e8:	f800283a 	ret

090c73ec <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 90c73ec:	defff804 	addi	sp,sp,-32
 90c73f0:	dfc00715 	stw	ra,28(sp)
 90c73f4:	df000615 	stw	fp,24(sp)
 90c73f8:	df000604 	addi	fp,sp,24
 90c73fc:	e13ffd15 	stw	r4,-12(fp)
 90c7400:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 90c7404:	0009883a 	mov	r4,zero
 90c7408:	90c72000 	call	90c7200 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 90c740c:	e13ffd17 	ldw	r4,-12(fp)
 90c7410:	01400fc4 	movi	r5,63
 90c7414:	90829800 	call	9082980 <strchr>
 90c7418:	1005003a 	cmpeq	r2,r2,zero
 90c741c:	1000031e 	bne	r2,zero,90c742c <vfopen_locked+0x40>
   {
      dtrap();
 90c7420:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90c7424:	e03fff15 	stw	zero,-4(fp)
 90c7428:	0000c406 	br	90c773c <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 90c742c:	e13ffd17 	ldw	r4,-12(fp)
 90c7430:	90c87980 	call	90c8798 <vfslookup_locked>
 90c7434:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 90c7438:	e0bffc17 	ldw	r2,-16(fp)
 90c743c:	1005003a 	cmpeq	r2,r2,zero
 90c7440:	10004e1e 	bne	r2,zero,90c757c <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 90c7444:	e0bffe17 	ldw	r2,-8(fp)
 90c7448:	10800003 	ldbu	r2,0(r2)
 90c744c:	10803fcc 	andi	r2,r2,255
 90c7450:	1080201c 	xori	r2,r2,128
 90c7454:	10bfe004 	addi	r2,r2,-128
 90c7458:	10801dd8 	cmpnei	r2,r2,119
 90c745c:	10000a1e 	bne	r2,zero,90c7488 <vfopen_locked+0x9c>
 90c7460:	e0bffc17 	ldw	r2,-16(fp)
 90c7464:	1080058b 	ldhu	r2,22(r2)
 90c7468:	10bfffcc 	andi	r2,r2,65535
 90c746c:	1080080c 	andi	r2,r2,32
 90c7470:	1004c03a 	cmpne	r2,r2,zero
 90c7474:	1000041e 	bne	r2,zero,90c7488 <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 90c7478:	013ff984 	movi	r4,-26
 90c747c:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c7480:	e03fff15 	stw	zero,-4(fp)
 90c7484:	0000ad06 	br	90c773c <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 90c7488:	90c72480 	call	90c7248 <vf_alloc_and_link_vop>
 90c748c:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 90c7490:	e0bffb17 	ldw	r2,-20(fp)
 90c7494:	1004c03a 	cmpne	r2,r2,zero
 90c7498:	1000041e 	bne	r2,zero,90c74ac <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 90c749c:	013ffb04 	movi	r4,-20
 90c74a0:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c74a4:	e03fff15 	stw	zero,-4(fp)
 90c74a8:	0000a406 	br	90c773c <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 90c74ac:	e0fffb17 	ldw	r3,-20(fp)
 90c74b0:	e0bffc17 	ldw	r2,-16(fp)
 90c74b4:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 90c74b8:	e0bffc17 	ldw	r2,-16(fp)
 90c74bc:	10c00617 	ldw	r3,24(r2)
 90c74c0:	e0bffb17 	ldw	r2,-20(fp)
 90c74c4:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 90c74c8:	e0bffe17 	ldw	r2,-8(fp)
 90c74cc:	10800003 	ldbu	r2,0(r2)
 90c74d0:	10803fcc 	andi	r2,r2,255
 90c74d4:	1080201c 	xori	r2,r2,128
 90c74d8:	10bfe004 	addi	r2,r2,-128
 90c74dc:	10801858 	cmpnei	r2,r2,97
 90c74e0:	10000b1e 	bne	r2,zero,90c7510 <vfopen_locked+0x124>
      {
         if (vfp->data)
 90c74e4:	e0bffc17 	ldw	r2,-16(fp)
 90c74e8:	10800617 	ldw	r2,24(r2)
 90c74ec:	1005003a 	cmpeq	r2,r2,zero
 90c74f0:	1000071e 	bne	r2,zero,90c7510 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 90c74f4:	e0bffc17 	ldw	r2,-16(fp)
 90c74f8:	10c00617 	ldw	r3,24(r2)
 90c74fc:	e0bffc17 	ldw	r2,-16(fp)
 90c7500:	10800817 	ldw	r2,32(r2)
 90c7504:	1887883a 	add	r3,r3,r2
 90c7508:	e0bffb17 	ldw	r2,-20(fp)
 90c750c:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 90c7510:	e0bffe17 	ldw	r2,-8(fp)
 90c7514:	10800003 	ldbu	r2,0(r2)
 90c7518:	10803fcc 	andi	r2,r2,255
 90c751c:	1080201c 	xori	r2,r2,128
 90c7520:	10bfe004 	addi	r2,r2,-128
 90c7524:	10801dd8 	cmpnei	r2,r2,119
 90c7528:	1000111e 	bne	r2,zero,90c7570 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 90c752c:	e0bffc17 	ldw	r2,-16(fp)
 90c7530:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 90c7534:	e0bffc17 	ldw	r2,-16(fp)
 90c7538:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 90c753c:	e0bffc17 	ldw	r2,-16(fp)
 90c7540:	1080058b 	ldhu	r2,22(r2)
 90c7544:	10808014 	ori	r2,r2,512
 90c7548:	1007883a 	mov	r3,r2
 90c754c:	e0bffc17 	ldw	r2,-16(fp)
 90c7550:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c7554:	e0bffc17 	ldw	r2,-16(fp)
 90c7558:	10c0058b 	ldhu	r3,22(r2)
 90c755c:	00bfff84 	movi	r2,-2
 90c7560:	1884703a 	and	r2,r3,r2
 90c7564:	1007883a 	mov	r3,r2
 90c7568:	e0bffc17 	ldw	r2,-16(fp)
 90c756c:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 90c7570:	e0bffb17 	ldw	r2,-20(fp)
 90c7574:	e0bfff15 	stw	r2,-4(fp)
 90c7578:	00007006 	br	90c773c <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 90c757c:	e0bffe17 	ldw	r2,-8(fp)
 90c7580:	10800003 	ldbu	r2,0(r2)
 90c7584:	10803fcc 	andi	r2,r2,255
 90c7588:	1080201c 	xori	r2,r2,128
 90c758c:	10bfe004 	addi	r2,r2,-128
 90c7590:	10801ca0 	cmpeqi	r2,r2,114
 90c7594:	1000151e 	bne	r2,zero,90c75ec <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 90c7598:	d0a0d417 	ldw	r2,-31920(gp)
 90c759c:	e0bffa15 	stw	r2,-24(fp)
 90c75a0:	00000f06 	br	90c75e0 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 90c75a4:	e0bffa17 	ldw	r2,-24(fp)
 90c75a8:	10800117 	ldw	r2,4(r2)
 90c75ac:	e13ffd17 	ldw	r4,-12(fp)
 90c75b0:	e17ffe17 	ldw	r5,-8(fp)
 90c75b4:	103ee83a 	callr	r2
 90c75b8:	e0bffb15 	stw	r2,-20(fp)
 90c75bc:	e0bffb17 	ldw	r2,-20(fp)
 90c75c0:	1005003a 	cmpeq	r2,r2,zero
 90c75c4:	1000031e 	bne	r2,zero,90c75d4 <vfopen_locked+0x1e8>
         {
            return vop;
 90c75c8:	e0bffb17 	ldw	r2,-20(fp)
 90c75cc:	e0bfff15 	stw	r2,-4(fp)
 90c75d0:	00005a06 	br	90c773c <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 90c75d4:	e0bffa17 	ldw	r2,-24(fp)
 90c75d8:	10800017 	ldw	r2,0(r2)
 90c75dc:	e0bffa15 	stw	r2,-24(fp)
 90c75e0:	e0bffa17 	ldw	r2,-24(fp)
 90c75e4:	1004c03a 	cmpne	r2,r2,zero
 90c75e8:	103fee1e 	bne	r2,zero,90c75a4 <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 90c75ec:	e0bffe17 	ldw	r2,-8(fp)
 90c75f0:	10800003 	ldbu	r2,0(r2)
 90c75f4:	10803fcc 	andi	r2,r2,255
 90c75f8:	1080201c 	xori	r2,r2,128
 90c75fc:	10bfe004 	addi	r2,r2,-128
 90c7600:	10801ca0 	cmpeqi	r2,r2,114
 90c7604:	10004a1e 	bne	r2,zero,90c7730 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 90c7608:	d0a0db17 	ldw	r2,-31892(gp)
 90c760c:	10803ff0 	cmpltui	r2,r2,255
 90c7610:	1000041e 	bne	r2,zero,90c7624 <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 90c7614:	013ffb04 	movi	r4,-20
 90c7618:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c761c:	e03fff15 	stw	zero,-4(fp)
 90c7620:	00004606 	br	90c773c <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 90c7624:	e13ffd17 	ldw	r4,-12(fp)
 90c7628:	90830d40 	call	90830d4 <strlen>
 90c762c:	10800470 	cmpltui	r2,r2,17
 90c7630:	1000041e 	bne	r2,zero,90c7644 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 90c7634:	013ffd84 	movi	r4,-10
 90c7638:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c763c:	e03fff15 	stw	zero,-4(fp)
 90c7640:	00003e06 	br	90c773c <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 90c7644:	01000b04 	movi	r4,44
 90c7648:	90a9f0c0 	call	90a9f0c <npalloc>
 90c764c:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 90c7650:	e0bffc17 	ldw	r2,-16(fp)
 90c7654:	1004c03a 	cmpne	r2,r2,zero
 90c7658:	1000041e 	bne	r2,zero,90c766c <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 90c765c:	013ffb04 	movi	r4,-20
 90c7660:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c7664:	e03fff15 	stw	zero,-4(fp)
 90c7668:	00003406 	br	90c773c <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 90c766c:	90c72480 	call	90c7248 <vf_alloc_and_link_vop>
 90c7670:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 90c7674:	e0bffb17 	ldw	r2,-20(fp)
 90c7678:	1004c03a 	cmpne	r2,r2,zero
 90c767c:	1000061e 	bne	r2,zero,90c7698 <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 90c7680:	e13ffc17 	ldw	r4,-16(fp)
 90c7684:	90aa0000 	call	90aa000 <npfree>
         set_vfopen_error(ENP_NOMEM);
 90c7688:	013ffb04 	movi	r4,-20
 90c768c:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c7690:	e03fff15 	stw	zero,-4(fp)
 90c7694:	00002906 	br	90c773c <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 90c7698:	d0e0d617 	ldw	r3,-31912(gp)
 90c769c:	e0bffc17 	ldw	r2,-16(fp)
 90c76a0:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 90c76a4:	e0bffc17 	ldw	r2,-16(fp)
 90c76a8:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 90c76ac:	d0a0db17 	ldw	r2,-31892(gp)
 90c76b0:	10800044 	addi	r2,r2,1
 90c76b4:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 90c76b8:	e0bffd17 	ldw	r2,-12(fp)
 90c76bc:	10800003 	ldbu	r2,0(r2)
 90c76c0:	10803fcc 	andi	r2,r2,255
 90c76c4:	1080201c 	xori	r2,r2,128
 90c76c8:	10bfe004 	addi	r2,r2,-128
 90c76cc:	10800be0 	cmpeqi	r2,r2,47
 90c76d0:	1000071e 	bne	r2,zero,90c76f0 <vfopen_locked+0x304>
 90c76d4:	e0bffd17 	ldw	r2,-12(fp)
 90c76d8:	10800003 	ldbu	r2,0(r2)
 90c76dc:	10803fcc 	andi	r2,r2,255
 90c76e0:	1080201c 	xori	r2,r2,128
 90c76e4:	10bfe004 	addi	r2,r2,-128
 90c76e8:	10801718 	cmpnei	r2,r2,92
 90c76ec:	1000031e 	bne	r2,zero,90c76fc <vfopen_locked+0x310>
         name++;
 90c76f0:	e0bffd17 	ldw	r2,-12(fp)
 90c76f4:	10800044 	addi	r2,r2,1
 90c76f8:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 90c76fc:	e0bffc17 	ldw	r2,-16(fp)
 90c7700:	11000104 	addi	r4,r2,4
 90c7704:	e17ffd17 	ldw	r5,-12(fp)
 90c7708:	90ca5b40 	call	90ca5b4 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 90c770c:	e0fffc17 	ldw	r3,-16(fp)
 90c7710:	0080d804 	movi	r2,864
 90c7714:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 90c7718:	e0fffb17 	ldw	r3,-20(fp)
 90c771c:	e0bffc17 	ldw	r2,-16(fp)
 90c7720:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 90c7724:	e0bffb17 	ldw	r2,-20(fp)
 90c7728:	e0bfff15 	stw	r2,-4(fp)
 90c772c:	00000306 	br	90c773c <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 90c7730:	013ff9c4 	movi	r4,-25
 90c7734:	90c72000 	call	90c7200 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 90c7738:	e03fff15 	stw	zero,-4(fp)
 90c773c:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 90c7740:	e037883a 	mov	sp,fp
 90c7744:	dfc00117 	ldw	ra,4(sp)
 90c7748:	df000017 	ldw	fp,0(sp)
 90c774c:	dec00204 	addi	sp,sp,8
 90c7750:	f800283a 	ret

090c7754 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 90c7754:	defffb04 	addi	sp,sp,-20
 90c7758:	dfc00415 	stw	ra,16(sp)
 90c775c:	df000315 	stw	fp,12(sp)
 90c7760:	df000304 	addi	fp,sp,12
 90c7764:	e13ffe15 	stw	r4,-8(fp)
 90c7768:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c776c:	01000144 	movi	r4,5
 90c7770:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 90c7774:	e13ffe17 	ldw	r4,-8(fp)
 90c7778:	e17fff17 	ldw	r5,-4(fp)
 90c777c:	90c73ec0 	call	90c73ec <vfopen_locked>
 90c7780:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 90c7784:	01000144 	movi	r4,5
 90c7788:	90a9b780 	call	90a9b78 <post_app_sem>

   return vfd;
 90c778c:	e0bffd17 	ldw	r2,-12(fp)
}
 90c7790:	e037883a 	mov	sp,fp
 90c7794:	dfc00117 	ldw	ra,4(sp)
 90c7798:	df000017 	ldw	fp,0(sp)
 90c779c:	dec00204 	addi	sp,sp,8
 90c77a0:	f800283a 	ret

090c77a4 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 90c77a4:	defff804 	addi	sp,sp,-32
 90c77a8:	dfc00715 	stw	ra,28(sp)
 90c77ac:	df000615 	stw	fp,24(sp)
 90c77b0:	df000604 	addi	fp,sp,24
 90c77b4:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 90c77b8:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 90c77bc:	d0a0d517 	ldw	r2,-31916(gp)
 90c77c0:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 90c77c4:	00000806 	br	90c77e8 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 90c77c8:	e0ffff17 	ldw	r3,-4(fp)
 90c77cc:	e0bffe17 	ldw	r2,-8(fp)
 90c77d0:	18800826 	beq	r3,r2,90c77f4 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 90c77d4:	e0bffe17 	ldw	r2,-8(fp)
 90c77d8:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 90c77dc:	e0bffe17 	ldw	r2,-8(fp)
 90c77e0:	10800017 	ldw	r2,0(r2)
 90c77e4:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 90c77e8:	e0bffe17 	ldw	r2,-8(fp)
 90c77ec:	1004c03a 	cmpne	r2,r2,zero
 90c77f0:	103ff51e 	bne	r2,zero,90c77c8 <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 90c77f4:	e0ffff17 	ldw	r3,-4(fp)
 90c77f8:	e0bffe17 	ldw	r2,-8(fp)
 90c77fc:	18804e1e 	bne	r3,r2,90c7938 <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 90c7800:	e0bfff17 	ldw	r2,-4(fp)
 90c7804:	10800117 	ldw	r2,4(r2)
 90c7808:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 90c780c:	e0bffc17 	ldw	r2,-16(fp)
 90c7810:	1005003a 	cmpeq	r2,r2,zero
 90c7814:	1000381e 	bne	r2,zero,90c78f8 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 90c7818:	e0bffc17 	ldw	r2,-16(fp)
 90c781c:	10800a17 	ldw	r2,40(r2)
 90c7820:	1005003a 	cmpeq	r2,r2,zero
 90c7824:	1000081e 	bne	r2,zero,90c7848 <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 90c7828:	e0bffc17 	ldw	r2,-16(fp)
 90c782c:	10800a17 	ldw	r2,40(r2)
 90c7830:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 90c7834:	e0bffa17 	ldw	r2,-24(fp)
 90c7838:	10800217 	ldw	r2,8(r2)
 90c783c:	e13fff17 	ldw	r4,-4(fp)
 90c7840:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 90c7844:	00002c06 	br	90c78f8 <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 90c7848:	e0bffc17 	ldw	r2,-16(fp)
 90c784c:	1080058b 	ldhu	r2,22(r2)
 90c7850:	10bfffcc 	andi	r2,r2,65535
 90c7854:	1080200c 	andi	r2,r2,128
 90c7858:	1005003a 	cmpeq	r2,r2,zero
 90c785c:	1000261e 	bne	r2,zero,90c78f8 <vfclose_locked+0x154>
 90c7860:	e0bffc17 	ldw	r2,-16(fp)
 90c7864:	10c00917 	ldw	r3,36(r2)
 90c7868:	e0bffc17 	ldw	r2,-16(fp)
 90c786c:	10800817 	ldw	r2,32(r2)
 90c7870:	1885c83a 	sub	r2,r3,r2
 90c7874:	10804030 	cmpltui	r2,r2,256
 90c7878:	10001f1e 	bne	r2,zero,90c78f8 <vfclose_locked+0x154>
 90c787c:	e0bffc17 	ldw	r2,-16(fp)
 90c7880:	10800617 	ldw	r2,24(r2)
 90c7884:	1005003a 	cmpeq	r2,r2,zero
 90c7888:	10001b1e 	bne	r2,zero,90c78f8 <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 90c788c:	e0bffc17 	ldw	r2,-16(fp)
 90c7890:	11000817 	ldw	r4,32(r2)
 90c7894:	90c72c40 	call	90c72c4 <vf_alloc_buffer>
 90c7898:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 90c789c:	e0bffb17 	ldw	r2,-20(fp)
 90c78a0:	1005003a 	cmpeq	r2,r2,zero
 90c78a4:	1000141e 	bne	r2,zero,90c78f8 <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 90c78a8:	e0bffc17 	ldw	r2,-16(fp)
 90c78ac:	10c00617 	ldw	r3,24(r2)
 90c78b0:	e0bffc17 	ldw	r2,-16(fp)
 90c78b4:	11800817 	ldw	r6,32(r2)
 90c78b8:	e0bffb17 	ldw	r2,-20(fp)
 90c78bc:	1009883a 	mov	r4,r2
 90c78c0:	180b883a 	mov	r5,r3
 90c78c4:	90822780 	call	9082278 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 90c78c8:	e0bffc17 	ldw	r2,-16(fp)
 90c78cc:	11000617 	ldw	r4,24(r2)
 90c78d0:	e0bffc17 	ldw	r2,-16(fp)
 90c78d4:	11400917 	ldw	r5,36(r2)
 90c78d8:	90c739c0 	call	90c739c <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 90c78dc:	e0fffc17 	ldw	r3,-16(fp)
 90c78e0:	e0bffb17 	ldw	r2,-20(fp)
 90c78e4:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 90c78e8:	e0bffc17 	ldw	r2,-16(fp)
 90c78ec:	10c00817 	ldw	r3,32(r2)
 90c78f0:	e0bffc17 	ldw	r2,-16(fp)
 90c78f4:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 90c78f8:	e0bffd17 	ldw	r2,-12(fp)
 90c78fc:	1005003a 	cmpeq	r2,r2,zero
 90c7900:	1000051e 	bne	r2,zero,90c7918 <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 90c7904:	e0bffe17 	ldw	r2,-8(fp)
 90c7908:	10c00017 	ldw	r3,0(r2)
 90c790c:	e0bffd17 	ldw	r2,-12(fp)
 90c7910:	10c00015 	stw	r3,0(r2)
 90c7914:	00000306 	br	90c7924 <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 90c7918:	e0bffe17 	ldw	r2,-8(fp)
 90c791c:	10800017 	ldw	r2,0(r2)
 90c7920:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 90c7924:	e13ffe17 	ldw	r4,-8(fp)
 90c7928:	90aa0000 	call	90aa000 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 90c792c:	d0a0d917 	ldw	r2,-31900(gp)
 90c7930:	10bfffc4 	addi	r2,r2,-1
 90c7934:	d0a0d915 	stw	r2,-31900(gp)
   return;
}
 90c7938:	e037883a 	mov	sp,fp
 90c793c:	dfc00117 	ldw	ra,4(sp)
 90c7940:	df000017 	ldw	fp,0(sp)
 90c7944:	dec00204 	addi	sp,sp,8
 90c7948:	f800283a 	ret

090c794c <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 90c794c:	defffd04 	addi	sp,sp,-12
 90c7950:	dfc00215 	stw	ra,8(sp)
 90c7954:	df000115 	stw	fp,4(sp)
 90c7958:	df000104 	addi	fp,sp,4
 90c795c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 90c7960:	01000144 	movi	r4,5
 90c7964:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   vfclose_locked(vfd);
 90c7968:	e13fff17 	ldw	r4,-4(fp)
 90c796c:	90c77a40 	call	90c77a4 <vfclose_locked>

   vfs_unlock();
 90c7970:	01000144 	movi	r4,5
 90c7974:	90a9b780 	call	90a9b78 <post_app_sem>
}
 90c7978:	e037883a 	mov	sp,fp
 90c797c:	dfc00117 	ldw	ra,4(sp)
 90c7980:	df000017 	ldw	fp,0(sp)
 90c7984:	dec00204 	addi	sp,sp,8
 90c7988:	f800283a 	ret

090c798c <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 90c798c:	defffd04 	addi	sp,sp,-12
 90c7990:	dfc00215 	stw	ra,8(sp)
 90c7994:	df000115 	stw	fp,4(sp)
 90c7998:	df000104 	addi	fp,sp,4
 90c799c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 90c79a0:	01000144 	movi	r4,5
 90c79a4:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 90c79a8:	01024374 	movhi	r4,2317
 90c79ac:	2102d004 	addi	r4,r4,2880
 90c79b0:	90828380 	call	9082838 <puts>

   vfs_unlock();
 90c79b4:	01000144 	movi	r4,5
 90c79b8:	90a9b780 	call	90a9b78 <post_app_sem>
   return(0);
 90c79bc:	0005883a 	mov	r2,zero
}
 90c79c0:	e037883a 	mov	sp,fp
 90c79c4:	dfc00117 	ldw	ra,4(sp)
 90c79c8:	df000017 	ldw	fp,0(sp)
 90c79cc:	dec00204 	addi	sp,sp,8
 90c79d0:	f800283a 	ret

090c79d4 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 90c79d4:	defff804 	addi	sp,sp,-32
 90c79d8:	dfc00715 	stw	ra,28(sp)
 90c79dc:	df000615 	stw	fp,24(sp)
 90c79e0:	df000604 	addi	fp,sp,24
 90c79e4:	e13ffc15 	stw	r4,-16(fp)
 90c79e8:	e17ffd15 	stw	r5,-12(fp)
 90c79ec:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 90c79f0:	e0bffc17 	ldw	r2,-16(fp)
 90c79f4:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 90c79f8:	00001106 	br	90c7a40 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 90c79fc:	e0bffb17 	ldw	r2,-20(fp)
 90c7a00:	1007883a 	mov	r3,r2
 90c7a04:	e0bffa17 	ldw	r2,-24(fp)
 90c7a08:	10c00005 	stb	r3,0(r2)
 90c7a0c:	e0bffa17 	ldw	r2,-24(fp)
 90c7a10:	10800003 	ldbu	r2,0(r2)
 90c7a14:	10803fcc 	andi	r2,r2,255
 90c7a18:	1080201c 	xori	r2,r2,128
 90c7a1c:	10bfe004 	addi	r2,r2,-128
 90c7a20:	108002a0 	cmpeqi	r2,r2,10
 90c7a24:	1007883a 	mov	r3,r2
 90c7a28:	e0bffa17 	ldw	r2,-24(fp)
 90c7a2c:	10800044 	addi	r2,r2,1
 90c7a30:	e0bffa15 	stw	r2,-24(fp)
 90c7a34:	18803fcc 	andi	r2,r3,255
 90c7a38:	1004c03a 	cmpne	r2,r2,zero
 90c7a3c:	10000c1e 	bne	r2,zero,90c7a70 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 90c7a40:	e0bffd17 	ldw	r2,-12(fp)
 90c7a44:	10bfffc4 	addi	r2,r2,-1
 90c7a48:	e0bffd15 	stw	r2,-12(fp)
 90c7a4c:	e0bffd17 	ldw	r2,-12(fp)
 90c7a50:	10800050 	cmplti	r2,r2,1
 90c7a54:	1000061e 	bne	r2,zero,90c7a70 <vfgets+0x9c>
 90c7a58:	e13ffe17 	ldw	r4,-8(fp)
 90c7a5c:	90c87500 	call	90c8750 <vgetc>
 90c7a60:	e0bffb15 	stw	r2,-20(fp)
 90c7a64:	e0bffb17 	ldw	r2,-20(fp)
 90c7a68:	10bfffd8 	cmpnei	r2,r2,-1
 90c7a6c:	103fe31e 	bne	r2,zero,90c79fc <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 90c7a70:	e0bffa17 	ldw	r2,-24(fp)
 90c7a74:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 90c7a78:	e0bffb17 	ldw	r2,-20(fp)
 90c7a7c:	10bfffd8 	cmpnei	r2,r2,-1
 90c7a80:	1000031e 	bne	r2,zero,90c7a90 <vfgets+0xbc>
 90c7a84:	e0fffa17 	ldw	r3,-24(fp)
 90c7a88:	e0bffc17 	ldw	r2,-16(fp)
 90c7a8c:	18800326 	beq	r3,r2,90c7a9c <vfgets+0xc8>
 90c7a90:	e0bffc17 	ldw	r2,-16(fp)
 90c7a94:	e0bfff15 	stw	r2,-4(fp)
 90c7a98:	00000106 	br	90c7aa0 <vfgets+0xcc>
 90c7a9c:	e03fff15 	stw	zero,-4(fp)
 90c7aa0:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7aa4:	e037883a 	mov	sp,fp
 90c7aa8:	dfc00117 	ldw	ra,4(sp)
 90c7aac:	df000017 	ldw	fp,0(sp)
 90c7ab0:	dec00204 	addi	sp,sp,8
 90c7ab4:	f800283a 	ret

090c7ab8 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 90c7ab8:	defffb04 	addi	sp,sp,-20
 90c7abc:	dfc00415 	stw	ra,16(sp)
 90c7ac0:	df000315 	stw	fp,12(sp)
 90c7ac4:	df000304 	addi	fp,sp,12
 90c7ac8:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 90c7acc:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 90c7ad0:	e13ffe17 	ldw	r4,-8(fp)
 90c7ad4:	90c87500 	call	90c8750 <vgetc>
 90c7ad8:	e0bffd15 	stw	r2,-12(fp)
 90c7adc:	e0bffd17 	ldw	r2,-12(fp)
 90c7ae0:	10bfffd8 	cmpnei	r2,r2,-1
 90c7ae4:	1000031e 	bne	r2,zero,90c7af4 <vfeof+0x3c>
   {
      return 1;
 90c7ae8:	00800044 	movi	r2,1
 90c7aec:	e0bfff15 	stw	r2,-4(fp)
 90c7af0:	00000106 	br	90c7af8 <vfeof+0x40>
   }   
   return 0;
 90c7af4:	e03fff15 	stw	zero,-4(fp)
 90c7af8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7afc:	e037883a 	mov	sp,fp
 90c7b00:	dfc00117 	ldw	ra,4(sp)
 90c7b04:	df000017 	ldw	fp,0(sp)
 90c7b08:	dec00204 	addi	sp,sp,8
 90c7b0c:	f800283a 	ret

090c7b10 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 90c7b10:	defffd04 	addi	sp,sp,-12
 90c7b14:	df000215 	stw	fp,8(sp)
 90c7b18:	df000204 	addi	fp,sp,8
 90c7b1c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c7b20:	d0a0d517 	ldw	r2,-31916(gp)
 90c7b24:	e0bffe15 	stw	r2,-8(fp)
 90c7b28:	00000906 	br	90c7b50 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 90c7b2c:	e0bffe17 	ldw	r2,-8(fp)
 90c7b30:	10c00117 	ldw	r3,4(r2)
 90c7b34:	e0bfff17 	ldw	r2,-4(fp)
 90c7b38:	1880021e 	bne	r3,r2,90c7b44 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 90c7b3c:	e0bffe17 	ldw	r2,-8(fp)
 90c7b40:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c7b44:	e0bffe17 	ldw	r2,-8(fp)
 90c7b48:	10800017 	ldw	r2,0(r2)
 90c7b4c:	e0bffe15 	stw	r2,-8(fp)
 90c7b50:	e0bffe17 	ldw	r2,-8(fp)
 90c7b54:	1004c03a 	cmpne	r2,r2,zero
 90c7b58:	103ff41e 	bne	r2,zero,90c7b2c <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 90c7b5c:	e037883a 	mov	sp,fp
 90c7b60:	df000017 	ldw	fp,0(sp)
 90c7b64:	dec00104 	addi	sp,sp,4
 90c7b68:	f800283a 	ret

090c7b6c <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 90c7b6c:	defff504 	addi	sp,sp,-44
 90c7b70:	dfc00a15 	stw	ra,40(sp)
 90c7b74:	df000915 	stw	fp,36(sp)
 90c7b78:	df000904 	addi	fp,sp,36
 90c7b7c:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 90c7b80:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 90c7b84:	e13ffe17 	ldw	r4,-8(fp)
 90c7b88:	90830d40 	call	90830d4 <strlen>
 90c7b8c:	11000044 	addi	r4,r2,1
 90c7b90:	90ca52c0 	call	90ca52c <malloc>
 90c7b94:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 90c7b98:	e13ff817 	ldw	r4,-32(fp)
 90c7b9c:	e17ffe17 	ldw	r5,-8(fp)
 90c7ba0:	90ca5b40 	call	90ca5b4 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c7ba4:	01000144 	movi	r4,5
 90c7ba8:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 90c7bac:	e13ff817 	ldw	r4,-32(fp)
 90c7bb0:	90c87980 	call	90c8798 <vfslookup_locked>
 90c7bb4:	e0bffd15 	stw	r2,-12(fp)
 90c7bb8:	e0bffd17 	ldw	r2,-12(fp)
 90c7bbc:	1004c03a 	cmpne	r2,r2,zero
 90c7bc0:	1000071e 	bne	r2,zero,90c7be0 <vunlink+0x74>
   {
      vfs_unlock();
 90c7bc4:	01000144 	movi	r4,5
 90c7bc8:	90a9b780 	call	90a9b78 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 90c7bcc:	e13ff817 	ldw	r4,-32(fp)
 90c7bd0:	90ca5180 	call	90ca518 <free>
      return -1;
 90c7bd4:	00bfffc4 	movi	r2,-1
 90c7bd8:	e0bfff15 	stw	r2,-4(fp)
 90c7bdc:	00006506 	br	90c7d74 <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 90c7be0:	e0bffd17 	ldw	r2,-12(fp)
 90c7be4:	10800017 	ldw	r2,0(r2)
 90c7be8:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 90c7bec:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 90c7bf0:	d0a0d617 	ldw	r2,-31912(gp)
 90c7bf4:	e0bffb15 	stw	r2,-20(fp)
 90c7bf8:	00000806 	br	90c7c1c <vunlink+0xb0>
   {
      if (vtmp == vfp)
 90c7bfc:	e0fffb17 	ldw	r3,-20(fp)
 90c7c00:	e0bffd17 	ldw	r2,-12(fp)
 90c7c04:	18800826 	beq	r3,r2,90c7c28 <vunlink+0xbc>
         break;
      vflast = vtmp;
 90c7c08:	e0bffb17 	ldw	r2,-20(fp)
 90c7c0c:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 90c7c10:	e0bffb17 	ldw	r2,-20(fp)
 90c7c14:	10800017 	ldw	r2,0(r2)
 90c7c18:	e0bffb15 	stw	r2,-20(fp)
 90c7c1c:	e0bffb17 	ldw	r2,-20(fp)
 90c7c20:	1004c03a 	cmpne	r2,r2,zero
 90c7c24:	103ff51e 	bne	r2,zero,90c7bfc <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 90c7c28:	e0bffb17 	ldw	r2,-20(fp)
 90c7c2c:	1004c03a 	cmpne	r2,r2,zero
 90c7c30:	1000081e 	bne	r2,zero,90c7c54 <vunlink+0xe8>
   {
      dtrap();
 90c7c34:	90a94880 	call	90a9488 <dtrap>
      vfs_unlock();
 90c7c38:	01000144 	movi	r4,5
 90c7c3c:	90a9b780 	call	90a9b78 <post_app_sem>
      free(name);
 90c7c40:	e13ff817 	ldw	r4,-32(fp)
 90c7c44:	90ca5180 	call	90ca518 <free>
      return -1;
 90c7c48:	00bfffc4 	movi	r2,-1
 90c7c4c:	e0bfff15 	stw	r2,-4(fp)
 90c7c50:	00004806 	br	90c7d74 <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 90c7c54:	e0bffd17 	ldw	r2,-12(fp)
 90c7c58:	10800a17 	ldw	r2,40(r2)
 90c7c5c:	1005003a 	cmpeq	r2,r2,zero
 90c7c60:	1000091e 	bne	r2,zero,90c7c88 <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 90c7c64:	e0bffd17 	ldw	r2,-12(fp)
 90c7c68:	10800a17 	ldw	r2,40(r2)
 90c7c6c:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 90c7c70:	e0bff717 	ldw	r2,-36(fp)
 90c7c74:	10800817 	ldw	r2,32(r2)
 90c7c78:	e13ff817 	ldw	r4,-32(fp)
 90c7c7c:	103ee83a 	callr	r2
 90c7c80:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 90c7c84:	00002806 	br	90c7d28 <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 90c7c88:	e0bffd17 	ldw	r2,-12(fp)
 90c7c8c:	1080058b 	ldhu	r2,22(r2)
 90c7c90:	10bfffcc 	andi	r2,r2,65535
 90c7c94:	1080080c 	andi	r2,r2,32
 90c7c98:	1004c03a 	cmpne	r2,r2,zero
 90c7c9c:	1000071e 	bne	r2,zero,90c7cbc <vunlink+0x150>
      {
         vfs_unlock();
 90c7ca0:	01000144 	movi	r4,5
 90c7ca4:	90a9b780 	call	90a9b78 <post_app_sem>
         free(name);
 90c7ca8:	e13ff817 	ldw	r4,-32(fp)
 90c7cac:	90ca5180 	call	90ca518 <free>
         return -1;
 90c7cb0:	00bfffc4 	movi	r2,-1
 90c7cb4:	e0bfff15 	stw	r2,-4(fp)
 90c7cb8:	00002e06 	br	90c7d74 <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 90c7cbc:	e0bffd17 	ldw	r2,-12(fp)
 90c7cc0:	1080058b 	ldhu	r2,22(r2)
 90c7cc4:	10bfffcc 	andi	r2,r2,65535
 90c7cc8:	1080200c 	andi	r2,r2,128
 90c7ccc:	1005003a 	cmpeq	r2,r2,zero
 90c7cd0:	1000091e 	bne	r2,zero,90c7cf8 <vunlink+0x18c>
 90c7cd4:	e0bffd17 	ldw	r2,-12(fp)
 90c7cd8:	10800617 	ldw	r2,24(r2)
 90c7cdc:	1005003a 	cmpeq	r2,r2,zero
 90c7ce0:	1000051e 	bne	r2,zero,90c7cf8 <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 90c7ce4:	e0bffd17 	ldw	r2,-12(fp)
 90c7ce8:	11000617 	ldw	r4,24(r2)
 90c7cec:	e0bffd17 	ldw	r2,-12(fp)
 90c7cf0:	11400917 	ldw	r5,36(r2)
 90c7cf4:	90c739c0 	call	90c739c <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 90c7cf8:	e0bffd17 	ldw	r2,-12(fp)
 90c7cfc:	1080058b 	ldhu	r2,22(r2)
 90c7d00:	10bfffcc 	andi	r2,r2,65535
 90c7d04:	1080100c 	andi	r2,r2,64
 90c7d08:	1005003a 	cmpeq	r2,r2,zero
 90c7d0c:	1000051e 	bne	r2,zero,90c7d24 <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 90c7d10:	d0a0db17 	ldw	r2,-31892(gp)
 90c7d14:	10bfffc4 	addi	r2,r2,-1
 90c7d18:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 90c7d1c:	e13ffd17 	ldw	r4,-12(fp)
 90c7d20:	90aa0000 	call	90aa000 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 90c7d24:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 90c7d28:	e0bffa17 	ldw	r2,-24(fp)
 90c7d2c:	1005003a 	cmpeq	r2,r2,zero
 90c7d30:	1000041e 	bne	r2,zero,90c7d44 <vunlink+0x1d8>
      vflast->next = vfnext;
 90c7d34:	e0fffa17 	ldw	r3,-24(fp)
 90c7d38:	e0bff917 	ldw	r2,-28(fp)
 90c7d3c:	18800015 	stw	r2,0(r3)
 90c7d40:	00000206 	br	90c7d4c <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 90c7d44:	e0bff917 	ldw	r2,-28(fp)
 90c7d48:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 90c7d4c:	e13ffd17 	ldw	r4,-12(fp)
 90c7d50:	90c7b100 	call	90c7b10 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 90c7d54:	00800044 	movi	r2,1
 90c7d58:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 90c7d5c:	01000144 	movi	r4,5
 90c7d60:	90a9b780 	call	90a9b78 <post_app_sem>
   free(name);
 90c7d64:	e13ff817 	ldw	r4,-32(fp)
 90c7d68:	90ca5180 	call	90ca518 <free>
   return rc;
 90c7d6c:	e0bffc17 	ldw	r2,-16(fp)
 90c7d70:	e0bfff15 	stw	r2,-4(fp)
 90c7d74:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7d78:	e037883a 	mov	sp,fp
 90c7d7c:	dfc00117 	ldw	ra,4(sp)
 90c7d80:	df000017 	ldw	fp,0(sp)
 90c7d84:	dec00204 	addi	sp,sp,8
 90c7d88:	f800283a 	ret

090c7d8c <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c7d8c:	defff504 	addi	sp,sp,-44
 90c7d90:	dfc00a15 	stw	ra,40(sp)
 90c7d94:	df000915 	stw	fp,36(sp)
 90c7d98:	df000904 	addi	fp,sp,36
 90c7d9c:	e13ffb15 	stw	r4,-20(fp)
 90c7da0:	e17ffc15 	stw	r5,-16(fp)
 90c7da4:	e1bffd15 	stw	r6,-12(fp)
 90c7da8:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 90c7dac:	01000144 	movi	r4,5
 90c7db0:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 90c7db4:	e13ffe17 	ldw	r4,-8(fp)
 90c7db8:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c7dbc:	1005003a 	cmpeq	r2,r2,zero
 90c7dc0:	1000541e 	bne	r2,zero,90c7f14 <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 90c7dc4:	e0bffe17 	ldw	r2,-8(fp)
 90c7dc8:	10800117 	ldw	r2,4(r2)
 90c7dcc:	1004c03a 	cmpne	r2,r2,zero
 90c7dd0:	1000041e 	bne	r2,zero,90c7de4 <vfread+0x58>
      {
         vfs_unlock();
 90c7dd4:	01000144 	movi	r4,5
 90c7dd8:	90a9b780 	call	90a9b78 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 90c7ddc:	e03fff15 	stw	zero,-4(fp)
 90c7de0:	00004f06 	br	90c7f20 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 90c7de4:	e0bffe17 	ldw	r2,-8(fp)
 90c7de8:	10800117 	ldw	r2,4(r2)
 90c7dec:	10800a17 	ldw	r2,40(r2)
 90c7df0:	1005003a 	cmpeq	r2,r2,zero
 90c7df4:	1000111e 	bne	r2,zero,90c7e3c <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 90c7df8:	e0bffe17 	ldw	r2,-8(fp)
 90c7dfc:	10800117 	ldw	r2,4(r2)
 90c7e00:	10800a17 	ldw	r2,40(r2)
 90c7e04:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 90c7e08:	e0bff917 	ldw	r2,-28(fp)
 90c7e0c:	10800317 	ldw	r2,12(r2)
 90c7e10:	e13ffb17 	ldw	r4,-20(fp)
 90c7e14:	e17ffc17 	ldw	r5,-16(fp)
 90c7e18:	e1bffd17 	ldw	r6,-12(fp)
 90c7e1c:	e1fffe17 	ldw	r7,-8(fp)
 90c7e20:	103ee83a 	callr	r2
 90c7e24:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 90c7e28:	01000144 	movi	r4,5
 90c7e2c:	90a9b780 	call	90a9b78 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 90c7e30:	e0bff817 	ldw	r2,-32(fp)
 90c7e34:	e0bfff15 	stw	r2,-4(fp)
 90c7e38:	00003906 	br	90c7f20 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 90c7e3c:	e0bffe17 	ldw	r2,-8(fp)
 90c7e40:	10800117 	ldw	r2,4(r2)
 90c7e44:	10800617 	ldw	r2,24(r2)
 90c7e48:	1004c03a 	cmpne	r2,r2,zero
 90c7e4c:	1000041e 	bne	r2,zero,90c7e60 <vfread+0xd4>
      {
         vfs_unlock();
 90c7e50:	01000144 	movi	r4,5
 90c7e54:	90a9b780 	call	90a9b78 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 90c7e58:	e03fff15 	stw	zero,-4(fp)
 90c7e5c:	00003006 	br	90c7f20 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 90c7e60:	e0fffd17 	ldw	r3,-12(fp)
 90c7e64:	e0bffc17 	ldw	r2,-16(fp)
 90c7e68:	1885383a 	mul	r2,r3,r2
 90c7e6c:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 90c7e70:	e0bffe17 	ldw	r2,-8(fp)
 90c7e74:	10800217 	ldw	r2,8(r2)
 90c7e78:	1007883a 	mov	r3,r2
 90c7e7c:	e0bffe17 	ldw	r2,-8(fp)
 90c7e80:	10800117 	ldw	r2,4(r2)
 90c7e84:	10800617 	ldw	r2,24(r2)
 90c7e88:	1885c83a 	sub	r2,r3,r2
 90c7e8c:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 90c7e90:	e0fff717 	ldw	r3,-36(fp)
 90c7e94:	e0bffa17 	ldw	r2,-24(fp)
 90c7e98:	1887883a 	add	r3,r3,r2
 90c7e9c:	e0bffe17 	ldw	r2,-8(fp)
 90c7ea0:	10800117 	ldw	r2,4(r2)
 90c7ea4:	10800817 	ldw	r2,32(r2)
 90c7ea8:	10c0062e 	bgeu	r2,r3,90c7ec4 <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 90c7eac:	e0bffe17 	ldw	r2,-8(fp)
 90c7eb0:	10800117 	ldw	r2,4(r2)
 90c7eb4:	10c00817 	ldw	r3,32(r2)
 90c7eb8:	e0bff717 	ldw	r2,-36(fp)
 90c7ebc:	1885c83a 	sub	r2,r3,r2
 90c7ec0:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 90c7ec4:	e0bffe17 	ldw	r2,-8(fp)
 90c7ec8:	10c00217 	ldw	r3,8(r2)
 90c7ecc:	e0bffb17 	ldw	r2,-20(fp)
 90c7ed0:	1009883a 	mov	r4,r2
 90c7ed4:	180b883a 	mov	r5,r3
 90c7ed8:	e1bffa17 	ldw	r6,-24(fp)
 90c7edc:	90822780 	call	9082278 <memcpy>
         vfd->cmploc += bcount;
 90c7ee0:	e0bffe17 	ldw	r2,-8(fp)
 90c7ee4:	10c00217 	ldw	r3,8(r2)
 90c7ee8:	e0bffa17 	ldw	r2,-24(fp)
 90c7eec:	1887883a 	add	r3,r3,r2
 90c7ef0:	e0bffe17 	ldw	r2,-8(fp)
 90c7ef4:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 90c7ef8:	01000144 	movi	r4,5
 90c7efc:	90a9b780 	call	90a9b78 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 90c7f00:	e0fffa17 	ldw	r3,-24(fp)
 90c7f04:	e0bffc17 	ldw	r2,-16(fp)
 90c7f08:	1885203a 	divu	r2,r3,r2
 90c7f0c:	e0bfff15 	stw	r2,-4(fp)
 90c7f10:	00000306 	br	90c7f20 <vfread+0x194>
   }

   vfs_unlock();
 90c7f14:	01000144 	movi	r4,5
 90c7f18:	90a9b780 	call	90a9b78 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 90c7f1c:	e03fff15 	stw	zero,-4(fp)
 90c7f20:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c7f24:	e037883a 	mov	sp,fp
 90c7f28:	dfc00117 	ldw	ra,4(sp)
 90c7f2c:	df000017 	ldw	fp,0(sp)
 90c7f30:	dec00204 	addi	sp,sp,8
 90c7f34:	f800283a 	ret

090c7f38 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c7f38:	defff104 	addi	sp,sp,-60
 90c7f3c:	dfc00e15 	stw	ra,56(sp)
 90c7f40:	df000d15 	stw	fp,52(sp)
 90c7f44:	df000d04 	addi	fp,sp,52
 90c7f48:	e13ffb15 	stw	r4,-20(fp)
 90c7f4c:	e17ffc15 	stw	r5,-16(fp)
 90c7f50:	e1bffd15 	stw	r6,-12(fp)
 90c7f54:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 90c7f58:	e13ffe17 	ldw	r4,-8(fp)
 90c7f5c:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c7f60:	1004c03a 	cmpne	r2,r2,zero
 90c7f64:	1000031e 	bne	r2,zero,90c7f74 <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 90c7f68:	00800244 	movi	r2,9
 90c7f6c:	e0bfff15 	stw	r2,-4(fp)
 90c7f70:	0000e506 	br	90c8308 <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 90c7f74:	e0bffe17 	ldw	r2,-8(fp)
 90c7f78:	10800117 	ldw	r2,4(r2)
 90c7f7c:	10800a17 	ldw	r2,40(r2)
 90c7f80:	1005003a 	cmpeq	r2,r2,zero
 90c7f84:	10000f1e 	bne	r2,zero,90c7fc4 <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 90c7f88:	e0bffe17 	ldw	r2,-8(fp)
 90c7f8c:	10800117 	ldw	r2,4(r2)
 90c7f90:	10800a17 	ldw	r2,40(r2)
 90c7f94:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 90c7f98:	e0bff717 	ldw	r2,-36(fp)
 90c7f9c:	10800417 	ldw	r2,16(r2)
 90c7fa0:	e13ffb17 	ldw	r4,-20(fp)
 90c7fa4:	e17ffc17 	ldw	r5,-16(fp)
 90c7fa8:	e1bffd17 	ldw	r6,-12(fp)
 90c7fac:	e1fffe17 	ldw	r7,-8(fp)
 90c7fb0:	103ee83a 	callr	r2
 90c7fb4:	e0bff615 	stw	r2,-40(fp)
      return rc;
 90c7fb8:	e0bff617 	ldw	r2,-40(fp)
 90c7fbc:	e0bfff15 	stw	r2,-4(fp)
 90c7fc0:	0000d106 	br	90c8308 <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 90c7fc4:	e0bffe17 	ldw	r2,-8(fp)
 90c7fc8:	10800117 	ldw	r2,4(r2)
 90c7fcc:	1004c03a 	cmpne	r2,r2,zero
 90c7fd0:	1000021e 	bne	r2,zero,90c7fdc <vfwrite_locked+0xa4>
   {
      return 0;
 90c7fd4:	e03fff15 	stw	zero,-4(fp)
 90c7fd8:	0000cb06 	br	90c8308 <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 90c7fdc:	e0bffe17 	ldw	r2,-8(fp)
 90c7fe0:	10800117 	ldw	r2,4(r2)
 90c7fe4:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 90c7fe8:	e0bff817 	ldw	r2,-32(fp)
 90c7fec:	1080058b 	ldhu	r2,22(r2)
 90c7ff0:	10bfffcc 	andi	r2,r2,65535
 90c7ff4:	1080080c 	andi	r2,r2,32
 90c7ff8:	1004c03a 	cmpne	r2,r2,zero
 90c7ffc:	1000051e 	bne	r2,zero,90c8014 <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 90c8000:	e0fffe17 	ldw	r3,-8(fp)
 90c8004:	00bff984 	movi	r2,-26
 90c8008:	18800415 	stw	r2,16(r3)
      return 0;
 90c800c:	e03fff15 	stw	zero,-4(fp)
 90c8010:	0000bd06 	br	90c8308 <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 90c8014:	e0fffc17 	ldw	r3,-16(fp)
 90c8018:	e0bffd17 	ldw	r2,-12(fp)
 90c801c:	1885383a 	mul	r2,r3,r2
 90c8020:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 90c8024:	e0bffa17 	ldw	r2,-24(fp)
 90c8028:	1004c03a 	cmpne	r2,r2,zero
 90c802c:	1000021e 	bne	r2,zero,90c8038 <vfwrite_locked+0x100>
   {
      return 0;
 90c8030:	e03fff15 	stw	zero,-4(fp)
 90c8034:	0000b406 	br	90c8308 <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 90c8038:	e0bff817 	ldw	r2,-32(fp)
 90c803c:	10800617 	ldw	r2,24(r2)
 90c8040:	1004c03a 	cmpne	r2,r2,zero
 90c8044:	1000401e 	bne	r2,zero,90c8148 <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 90c8048:	e0bffa17 	ldw	r2,-24(fp)
 90c804c:	10bfffc4 	addi	r2,r2,-1
 90c8050:	1004d37a 	srli	r2,r2,13
 90c8054:	1004937a 	slli	r2,r2,13
 90c8058:	10880004 	addi	r2,r2,8192
 90c805c:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 90c8060:	e13ff517 	ldw	r4,-44(fp)
 90c8064:	90c72c40 	call	90c72c4 <vf_alloc_buffer>
 90c8068:	1007883a 	mov	r3,r2
 90c806c:	e0bff817 	ldw	r2,-32(fp)
 90c8070:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 90c8074:	e0bff817 	ldw	r2,-32(fp)
 90c8078:	10800617 	ldw	r2,24(r2)
 90c807c:	1004c03a 	cmpne	r2,r2,zero
 90c8080:	1000051e 	bne	r2,zero,90c8098 <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 90c8084:	e0fffe17 	ldw	r3,-8(fp)
 90c8088:	00bffb04 	movi	r2,-20
 90c808c:	18800415 	stw	r2,16(r3)
         return 0;
 90c8090:	e03fff15 	stw	zero,-4(fp)
 90c8094:	00009c06 	br	90c8308 <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 90c8098:	e0fff817 	ldw	r3,-32(fp)
 90c809c:	e0bff517 	ldw	r2,-44(fp)
 90c80a0:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 90c80a4:	e0fff817 	ldw	r3,-32(fp)
 90c80a8:	e0bffa17 	ldw	r2,-24(fp)
 90c80ac:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 90c80b0:	e0fff817 	ldw	r3,-32(fp)
 90c80b4:	e0bffa17 	ldw	r2,-24(fp)
 90c80b8:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 90c80bc:	e0bff817 	ldw	r2,-32(fp)
 90c80c0:	10c00617 	ldw	r3,24(r2)
 90c80c4:	e0bffa17 	ldw	r2,-24(fp)
 90c80c8:	1887883a 	add	r3,r3,r2
 90c80cc:	e0bffe17 	ldw	r2,-8(fp)
 90c80d0:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c80d4:	e0bff817 	ldw	r2,-32(fp)
 90c80d8:	10c0058b 	ldhu	r3,22(r2)
 90c80dc:	00bfff84 	movi	r2,-2
 90c80e0:	1884703a 	and	r2,r3,r2
 90c80e4:	1007883a 	mov	r3,r2
 90c80e8:	e0bff817 	ldw	r2,-32(fp)
 90c80ec:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 90c80f0:	e0bff817 	ldw	r2,-32(fp)
 90c80f4:	1080058b 	ldhu	r2,22(r2)
 90c80f8:	10808014 	ori	r2,r2,512
 90c80fc:	1007883a 	mov	r3,r2
 90c8100:	e0bff817 	ldw	r2,-32(fp)
 90c8104:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 90c8108:	e0bff817 	ldw	r2,-32(fp)
 90c810c:	1080058b 	ldhu	r2,22(r2)
 90c8110:	10802014 	ori	r2,r2,128
 90c8114:	1007883a 	mov	r3,r2
 90c8118:	e0bff817 	ldw	r2,-32(fp)
 90c811c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 90c8120:	e0bff817 	ldw	r2,-32(fp)
 90c8124:	10800617 	ldw	r2,24(r2)
 90c8128:	e0fffb17 	ldw	r3,-20(fp)
 90c812c:	1009883a 	mov	r4,r2
 90c8130:	180b883a 	mov	r5,r3
 90c8134:	e1bffa17 	ldw	r6,-24(fp)
 90c8138:	90822780 	call	9082278 <memcpy>

      /* return the number of "items" written */
      return items;
 90c813c:	e0bffd17 	ldw	r2,-12(fp)
 90c8140:	e0bfff15 	stw	r2,-4(fp)
 90c8144:	00007006 	br	90c8308 <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 90c8148:	e0bffe17 	ldw	r2,-8(fp)
 90c814c:	10800217 	ldw	r2,8(r2)
 90c8150:	1007883a 	mov	r3,r2
 90c8154:	e0bff817 	ldw	r2,-32(fp)
 90c8158:	10800617 	ldw	r2,24(r2)
 90c815c:	1885c83a 	sub	r2,r3,r2
 90c8160:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 90c8164:	e0fff917 	ldw	r3,-28(fp)
 90c8168:	e0bffa17 	ldw	r2,-24(fp)
 90c816c:	1887883a 	add	r3,r3,r2
 90c8170:	e0bff817 	ldw	r2,-32(fp)
 90c8174:	10800917 	ldw	r2,36(r2)
 90c8178:	10c0382e 	bgeu	r2,r3,90c825c <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 90c817c:	e0fff917 	ldw	r3,-28(fp)
 90c8180:	e0bffa17 	ldw	r2,-24(fp)
 90c8184:	1885883a 	add	r2,r3,r2
 90c8188:	10bfffc4 	addi	r2,r2,-1
 90c818c:	1004d37a 	srli	r2,r2,13
 90c8190:	1004937a 	slli	r2,r2,13
 90c8194:	10880004 	addi	r2,r2,8192
 90c8198:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 90c819c:	e13ff417 	ldw	r4,-48(fp)
 90c81a0:	90c72c40 	call	90c72c4 <vf_alloc_buffer>
 90c81a4:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 90c81a8:	e0bff317 	ldw	r2,-52(fp)
 90c81ac:	1004c03a 	cmpne	r2,r2,zero
 90c81b0:	1000051e 	bne	r2,zero,90c81c8 <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 90c81b4:	e0fffe17 	ldw	r3,-8(fp)
 90c81b8:	00bffb04 	movi	r2,-20
 90c81bc:	18800415 	stw	r2,16(r3)
         return 0;
 90c81c0:	e03fff15 	stw	zero,-4(fp)
 90c81c4:	00005006 	br	90c8308 <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 90c81c8:	e0bff817 	ldw	r2,-32(fp)
 90c81cc:	10c00617 	ldw	r3,24(r2)
 90c81d0:	e0bff817 	ldw	r2,-32(fp)
 90c81d4:	11800817 	ldw	r6,32(r2)
 90c81d8:	e0bff317 	ldw	r2,-52(fp)
 90c81dc:	1009883a 	mov	r4,r2
 90c81e0:	180b883a 	mov	r5,r3
 90c81e4:	90822780 	call	9082278 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 90c81e8:	e0bff817 	ldw	r2,-32(fp)
 90c81ec:	1080058b 	ldhu	r2,22(r2)
 90c81f0:	10bfffcc 	andi	r2,r2,65535
 90c81f4:	1080200c 	andi	r2,r2,128
 90c81f8:	1005003a 	cmpeq	r2,r2,zero
 90c81fc:	1000051e 	bne	r2,zero,90c8214 <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 90c8200:	e0bff817 	ldw	r2,-32(fp)
 90c8204:	11000617 	ldw	r4,24(r2)
 90c8208:	e0bff817 	ldw	r2,-32(fp)
 90c820c:	11400917 	ldw	r5,36(r2)
 90c8210:	90c739c0 	call	90c739c <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 90c8214:	e0fff817 	ldw	r3,-32(fp)
 90c8218:	e0bff317 	ldw	r2,-52(fp)
 90c821c:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 90c8220:	e0fff817 	ldw	r3,-32(fp)
 90c8224:	e0bff417 	ldw	r2,-48(fp)
 90c8228:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 90c822c:	e0bff817 	ldw	r2,-32(fp)
 90c8230:	1080058b 	ldhu	r2,22(r2)
 90c8234:	10802014 	ori	r2,r2,128
 90c8238:	1007883a 	mov	r3,r2
 90c823c:	e0bff817 	ldw	r2,-32(fp)
 90c8240:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 90c8244:	e0bff817 	ldw	r2,-32(fp)
 90c8248:	10c00617 	ldw	r3,24(r2)
 90c824c:	e0bff917 	ldw	r2,-28(fp)
 90c8250:	1887883a 	add	r3,r3,r2
 90c8254:	e0bffe17 	ldw	r2,-8(fp)
 90c8258:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 90c825c:	e0bffe17 	ldw	r2,-8(fp)
 90c8260:	10800217 	ldw	r2,8(r2)
 90c8264:	e0fffb17 	ldw	r3,-20(fp)
 90c8268:	1009883a 	mov	r4,r2
 90c826c:	180b883a 	mov	r5,r3
 90c8270:	e1bffa17 	ldw	r6,-24(fp)
 90c8274:	90822780 	call	9082278 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 90c8278:	e0bffe17 	ldw	r2,-8(fp)
 90c827c:	10c00217 	ldw	r3,8(r2)
 90c8280:	e0bffa17 	ldw	r2,-24(fp)
 90c8284:	1887883a 	add	r3,r3,r2
 90c8288:	e0bffe17 	ldw	r2,-8(fp)
 90c828c:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 90c8290:	e0fff917 	ldw	r3,-28(fp)
 90c8294:	e0bffa17 	ldw	r2,-24(fp)
 90c8298:	1887883a 	add	r3,r3,r2
 90c829c:	e0bff817 	ldw	r2,-32(fp)
 90c82a0:	10800817 	ldw	r2,32(r2)
 90c82a4:	10c0052e 	bgeu	r2,r3,90c82bc <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 90c82a8:	e0fff917 	ldw	r3,-28(fp)
 90c82ac:	e0bffa17 	ldw	r2,-24(fp)
 90c82b0:	1887883a 	add	r3,r3,r2
 90c82b4:	e0bff817 	ldw	r2,-32(fp)
 90c82b8:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 90c82bc:	e0bff817 	ldw	r2,-32(fp)
 90c82c0:	10c00817 	ldw	r3,32(r2)
 90c82c4:	e0bff817 	ldw	r2,-32(fp)
 90c82c8:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c82cc:	e0bff817 	ldw	r2,-32(fp)
 90c82d0:	10c0058b 	ldhu	r3,22(r2)
 90c82d4:	00bfff84 	movi	r2,-2
 90c82d8:	1884703a 	and	r2,r3,r2
 90c82dc:	1007883a 	mov	r3,r2
 90c82e0:	e0bff817 	ldw	r2,-32(fp)
 90c82e4:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 90c82e8:	e0bff817 	ldw	r2,-32(fp)
 90c82ec:	1080058b 	ldhu	r2,22(r2)
 90c82f0:	10808014 	ori	r2,r2,512
 90c82f4:	1007883a 	mov	r3,r2
 90c82f8:	e0bff817 	ldw	r2,-32(fp)
 90c82fc:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 90c8300:	e0bffd17 	ldw	r2,-12(fp)
 90c8304:	e0bfff15 	stw	r2,-4(fp)
 90c8308:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 90c830c:	e037883a 	mov	sp,fp
 90c8310:	dfc00117 	ldw	ra,4(sp)
 90c8314:	df000017 	ldw	fp,0(sp)
 90c8318:	dec00204 	addi	sp,sp,8
 90c831c:	f800283a 	ret

090c8320 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c8320:	defff904 	addi	sp,sp,-28
 90c8324:	dfc00615 	stw	ra,24(sp)
 90c8328:	df000515 	stw	fp,20(sp)
 90c832c:	df000504 	addi	fp,sp,20
 90c8330:	e13ffc15 	stw	r4,-16(fp)
 90c8334:	e17ffd15 	stw	r5,-12(fp)
 90c8338:	e1bffe15 	stw	r6,-8(fp)
 90c833c:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 90c8340:	01000144 	movi	r4,5
 90c8344:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 90c8348:	e13ffc17 	ldw	r4,-16(fp)
 90c834c:	e17ffd17 	ldw	r5,-12(fp)
 90c8350:	e1bffe17 	ldw	r6,-8(fp)
 90c8354:	e1ffff17 	ldw	r7,-4(fp)
 90c8358:	90c7f380 	call	90c7f38 <vfwrite_locked>
 90c835c:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c8360:	01000144 	movi	r4,5
 90c8364:	90a9b780 	call	90a9b78 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 90c8368:	e0bffb17 	ldw	r2,-20(fp)
}
 90c836c:	e037883a 	mov	sp,fp
 90c8370:	dfc00117 	ldw	ra,4(sp)
 90c8374:	df000017 	ldw	fp,0(sp)
 90c8378:	dec00204 	addi	sp,sp,8
 90c837c:	f800283a 	ret

090c8380 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 90c8380:	defff704 	addi	sp,sp,-36
 90c8384:	dfc00815 	stw	ra,32(sp)
 90c8388:	df000715 	stw	fp,28(sp)
 90c838c:	df000704 	addi	fp,sp,28
 90c8390:	e13ffb15 	stw	r4,-20(fp)
 90c8394:	e17ffc15 	stw	r5,-16(fp)
 90c8398:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 90c839c:	01000144 	movi	r4,5
 90c83a0:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c83a4:	e13ffb17 	ldw	r4,-20(fp)
 90c83a8:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c83ac:	1005003a 	cmpeq	r2,r2,zero
 90c83b0:	1000481e 	bne	r2,zero,90c84d4 <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 90c83b4:	e0bffb17 	ldw	r2,-20(fp)
 90c83b8:	10800117 	ldw	r2,4(r2)
 90c83bc:	1004c03a 	cmpne	r2,r2,zero
 90c83c0:	1000051e 	bne	r2,zero,90c83d8 <vfseek+0x58>
      {
         vfs_unlock();
 90c83c4:	01000144 	movi	r4,5
 90c83c8:	90a9b780 	call	90a9b78 <post_app_sem>
         return -1;
 90c83cc:	00bfffc4 	movi	r2,-1
 90c83d0:	e0bffe15 	stw	r2,-8(fp)
 90c83d4:	00004306 	br	90c84e4 <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c83d8:	e0bffb17 	ldw	r2,-20(fp)
 90c83dc:	10800117 	ldw	r2,4(r2)
 90c83e0:	10800a17 	ldw	r2,40(r2)
 90c83e4:	1005003a 	cmpeq	r2,r2,zero
 90c83e8:	1000101e 	bne	r2,zero,90c842c <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 90c83ec:	e0bffb17 	ldw	r2,-20(fp)
 90c83f0:	10800117 	ldw	r2,4(r2)
 90c83f4:	10800a17 	ldw	r2,40(r2)
 90c83f8:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 90c83fc:	e0bffa17 	ldw	r2,-24(fp)
 90c8400:	10800517 	ldw	r2,20(r2)
 90c8404:	e13ffb17 	ldw	r4,-20(fp)
 90c8408:	e17ffc17 	ldw	r5,-16(fp)
 90c840c:	e1bffd17 	ldw	r6,-12(fp)
 90c8410:	103ee83a 	callr	r2
 90c8414:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 90c8418:	01000144 	movi	r4,5
 90c841c:	90a9b780 	call	90a9b78 <post_app_sem>
         return rc;
 90c8420:	e0fff917 	ldw	r3,-28(fp)
 90c8424:	e0fffe15 	stw	r3,-8(fp)
 90c8428:	00002e06 	br	90c84e4 <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 90c842c:	e0bffd17 	ldw	r2,-12(fp)
 90c8430:	e0bfff15 	stw	r2,-4(fp)
 90c8434:	e0ffff17 	ldw	r3,-4(fp)
 90c8438:	18800060 	cmpeqi	r2,r3,1
 90c843c:	10000f1e 	bne	r2,zero,90c847c <vfseek+0xfc>
 90c8440:	e0ffff17 	ldw	r3,-4(fp)
 90c8444:	188000a0 	cmpeqi	r2,r3,2
 90c8448:	1000131e 	bne	r2,zero,90c8498 <vfseek+0x118>
 90c844c:	e0ffff17 	ldw	r3,-4(fp)
 90c8450:	1805003a 	cmpeq	r2,r3,zero
 90c8454:	1000011e 	bne	r2,zero,90c845c <vfseek+0xdc>
 90c8458:	00001a06 	br	90c84c4 <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 90c845c:	e0bffb17 	ldw	r2,-20(fp)
 90c8460:	10800117 	ldw	r2,4(r2)
 90c8464:	10c00617 	ldw	r3,24(r2)
 90c8468:	e0bffc17 	ldw	r2,-16(fp)
 90c846c:	1887883a 	add	r3,r3,r2
 90c8470:	e0bffb17 	ldw	r2,-20(fp)
 90c8474:	10c00215 	stw	r3,8(r2)
         break;
 90c8478:	00001206 	br	90c84c4 <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 90c847c:	e0bffb17 	ldw	r2,-20(fp)
 90c8480:	10c00217 	ldw	r3,8(r2)
 90c8484:	e0bffc17 	ldw	r2,-16(fp)
 90c8488:	1887883a 	add	r3,r3,r2
 90c848c:	e0bffb17 	ldw	r2,-20(fp)
 90c8490:	10c00215 	stw	r3,8(r2)
         break;
 90c8494:	00000b06 	br	90c84c4 <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 90c8498:	e0bffb17 	ldw	r2,-20(fp)
 90c849c:	10800117 	ldw	r2,4(r2)
 90c84a0:	10c00617 	ldw	r3,24(r2)
 90c84a4:	e0bffb17 	ldw	r2,-20(fp)
 90c84a8:	10800117 	ldw	r2,4(r2)
 90c84ac:	10800817 	ldw	r2,32(r2)
 90c84b0:	1887883a 	add	r3,r3,r2
 90c84b4:	e0bffc17 	ldw	r2,-16(fp)
 90c84b8:	1887883a 	add	r3,r3,r2
 90c84bc:	e0bffb17 	ldw	r2,-20(fp)
 90c84c0:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 90c84c4:	01000144 	movi	r4,5
 90c84c8:	90a9b780 	call	90a9b78 <post_app_sem>
      return(0);
 90c84cc:	e03ffe15 	stw	zero,-8(fp)
 90c84d0:	00000406 	br	90c84e4 <vfseek+0x164>
   }

   vfs_unlock();
 90c84d4:	01000144 	movi	r4,5
 90c84d8:	90a9b780 	call	90a9b78 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 90c84dc:	00bfffc4 	movi	r2,-1
 90c84e0:	e0bffe15 	stw	r2,-8(fp)
 90c84e4:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 90c84e8:	e037883a 	mov	sp,fp
 90c84ec:	dfc00117 	ldw	ra,4(sp)
 90c84f0:	df000017 	ldw	fp,0(sp)
 90c84f4:	dec00204 	addi	sp,sp,8
 90c84f8:	f800283a 	ret

090c84fc <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 90c84fc:	defffa04 	addi	sp,sp,-24
 90c8500:	dfc00515 	stw	ra,20(sp)
 90c8504:	df000415 	stw	fp,16(sp)
 90c8508:	df000404 	addi	fp,sp,16
 90c850c:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 90c8510:	01000144 	movi	r4,5
 90c8514:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c8518:	e13ffe17 	ldw	r4,-8(fp)
 90c851c:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c8520:	1005003a 	cmpeq	r2,r2,zero
 90c8524:	1000381e 	bne	r2,zero,90c8608 <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 90c8528:	e0bffe17 	ldw	r2,-8(fp)
 90c852c:	10800117 	ldw	r2,4(r2)
 90c8530:	1004c03a 	cmpne	r2,r2,zero
 90c8534:	1000051e 	bne	r2,zero,90c854c <vftell+0x50>
      {
         vfs_unlock();
 90c8538:	01000144 	movi	r4,5
 90c853c:	90a9b780 	call	90a9b78 <post_app_sem>
         return -1;
 90c8540:	00bfffc4 	movi	r2,-1
 90c8544:	e0bfff15 	stw	r2,-4(fp)
 90c8548:	00003306 	br	90c8618 <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c854c:	e0bffe17 	ldw	r2,-8(fp)
 90c8550:	10800117 	ldw	r2,4(r2)
 90c8554:	10800a17 	ldw	r2,40(r2)
 90c8558:	1005003a 	cmpeq	r2,r2,zero
 90c855c:	10000e1e 	bne	r2,zero,90c8598 <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 90c8560:	e0bffe17 	ldw	r2,-8(fp)
 90c8564:	10800117 	ldw	r2,4(r2)
 90c8568:	10800a17 	ldw	r2,40(r2)
 90c856c:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 90c8570:	e0bffd17 	ldw	r2,-12(fp)
 90c8574:	10800617 	ldw	r2,24(r2)
 90c8578:	e13ffe17 	ldw	r4,-8(fp)
 90c857c:	103ee83a 	callr	r2
 90c8580:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 90c8584:	01000144 	movi	r4,5
 90c8588:	90a9b780 	call	90a9b78 <post_app_sem>
         return rc;
 90c858c:	e0bffc17 	ldw	r2,-16(fp)
 90c8590:	e0bfff15 	stw	r2,-4(fp)
 90c8594:	00002006 	br	90c8618 <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 90c8598:	e0bffe17 	ldw	r2,-8(fp)
 90c859c:	11000217 	ldw	r4,8(r2)
 90c85a0:	e0bffe17 	ldw	r2,-8(fp)
 90c85a4:	10800117 	ldw	r2,4(r2)
 90c85a8:	10c00617 	ldw	r3,24(r2)
 90c85ac:	e0bffe17 	ldw	r2,-8(fp)
 90c85b0:	10800117 	ldw	r2,4(r2)
 90c85b4:	10800817 	ldw	r2,32(r2)
 90c85b8:	1885883a 	add	r2,r3,r2
 90c85bc:	2080071e 	bne	r4,r2,90c85dc <vftell+0xe0>
      {
         vfs_unlock();
 90c85c0:	01000144 	movi	r4,5
 90c85c4:	90a9b780 	call	90a9b78 <post_app_sem>

         return vfd->file->comp_size;
 90c85c8:	e0bffe17 	ldw	r2,-8(fp)
 90c85cc:	10800117 	ldw	r2,4(r2)
 90c85d0:	10800817 	ldw	r2,32(r2)
 90c85d4:	e0bfff15 	stw	r2,-4(fp)
 90c85d8:	00000f06 	br	90c8618 <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 90c85dc:	01000144 	movi	r4,5
 90c85e0:	90a9b780 	call	90a9b78 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 90c85e4:	e0bffe17 	ldw	r2,-8(fp)
 90c85e8:	10800217 	ldw	r2,8(r2)
 90c85ec:	1007883a 	mov	r3,r2
 90c85f0:	e0bffe17 	ldw	r2,-8(fp)
 90c85f4:	10800117 	ldw	r2,4(r2)
 90c85f8:	10800617 	ldw	r2,24(r2)
 90c85fc:	1887c83a 	sub	r3,r3,r2
 90c8600:	e0ffff15 	stw	r3,-4(fp)
 90c8604:	00000406 	br	90c8618 <vftell+0x11c>
      }
   }

   vfs_unlock();
 90c8608:	01000144 	movi	r4,5
 90c860c:	90a9b780 	call	90a9b78 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 90c8610:	00800244 	movi	r2,9
 90c8614:	e0bfff15 	stw	r2,-4(fp)
 90c8618:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c861c:	e037883a 	mov	sp,fp
 90c8620:	dfc00117 	ldw	ra,4(sp)
 90c8624:	df000017 	ldw	fp,0(sp)
 90c8628:	dec00204 	addi	sp,sp,8
 90c862c:	f800283a 	ret

090c8630 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 90c8630:	defffa04 	addi	sp,sp,-24
 90c8634:	dfc00515 	stw	ra,20(sp)
 90c8638:	df000415 	stw	fp,16(sp)
 90c863c:	df000404 	addi	fp,sp,16
 90c8640:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 90c8644:	e13ffe17 	ldw	r4,-8(fp)
 90c8648:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c864c:	1005003a 	cmpeq	r2,r2,zero
 90c8650:	1000361e 	bne	r2,zero,90c872c <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 90c8654:	e0bffe17 	ldw	r2,-8(fp)
 90c8658:	10800117 	ldw	r2,4(r2)
 90c865c:	1004c03a 	cmpne	r2,r2,zero
 90c8660:	1000031e 	bne	r2,zero,90c8670 <vgetc_locked+0x40>
      {
         return EOF;
 90c8664:	00bfffc4 	movi	r2,-1
 90c8668:	e0bfff15 	stw	r2,-4(fp)
 90c866c:	00003206 	br	90c8738 <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c8670:	e0bffe17 	ldw	r2,-8(fp)
 90c8674:	10800117 	ldw	r2,4(r2)
 90c8678:	10800a17 	ldw	r2,40(r2)
 90c867c:	1005003a 	cmpeq	r2,r2,zero
 90c8680:	10000a1e 	bne	r2,zero,90c86ac <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 90c8684:	e0bffe17 	ldw	r2,-8(fp)
 90c8688:	10800117 	ldw	r2,4(r2)
 90c868c:	10800a17 	ldw	r2,40(r2)
 90c8690:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 90c8694:	e0bffc17 	ldw	r2,-16(fp)
 90c8698:	10800717 	ldw	r2,28(r2)
 90c869c:	e13ffe17 	ldw	r4,-8(fp)
 90c86a0:	103ee83a 	callr	r2
 90c86a4:	e0bfff15 	stw	r2,-4(fp)
 90c86a8:	00002306 	br	90c8738 <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 90c86ac:	e0bffe17 	ldw	r2,-8(fp)
 90c86b0:	10800117 	ldw	r2,4(r2)
 90c86b4:	10800617 	ldw	r2,24(r2)
 90c86b8:	1004c03a 	cmpne	r2,r2,zero
 90c86bc:	1000031e 	bne	r2,zero,90c86cc <vgetc_locked+0x9c>
         return EOF;
 90c86c0:	00bfffc4 	movi	r2,-1
 90c86c4:	e0bfff15 	stw	r2,-4(fp)
 90c86c8:	00001b06 	br	90c8738 <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 90c86cc:	e0bffe17 	ldw	r2,-8(fp)
 90c86d0:	11000217 	ldw	r4,8(r2)
 90c86d4:	e0bffe17 	ldw	r2,-8(fp)
 90c86d8:	10800117 	ldw	r2,4(r2)
 90c86dc:	10c00617 	ldw	r3,24(r2)
 90c86e0:	e0bffe17 	ldw	r2,-8(fp)
 90c86e4:	10800117 	ldw	r2,4(r2)
 90c86e8:	10800817 	ldw	r2,32(r2)
 90c86ec:	1885883a 	add	r2,r3,r2
 90c86f0:	20800336 	bltu	r4,r2,90c8700 <vgetc_locked+0xd0>
            chr = EOF;
 90c86f4:	00bfffc4 	movi	r2,-1
 90c86f8:	e0bffd15 	stw	r2,-12(fp)
 90c86fc:	00000806 	br	90c8720 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 90c8700:	e0bffe17 	ldw	r2,-8(fp)
 90c8704:	10c00217 	ldw	r3,8(r2)
 90c8708:	18800003 	ldbu	r2,0(r3)
 90c870c:	10803fcc 	andi	r2,r2,255
 90c8710:	e0bffd15 	stw	r2,-12(fp)
 90c8714:	18c00044 	addi	r3,r3,1
 90c8718:	e0bffe17 	ldw	r2,-8(fp)
 90c871c:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 90c8720:	e0bffd17 	ldw	r2,-12(fp)
 90c8724:	e0bfff15 	stw	r2,-4(fp)
 90c8728:	00000306 	br	90c8738 <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 90c872c:	90a94880 	call	90a9488 <dtrap>
   return EOF;
 90c8730:	00bfffc4 	movi	r2,-1
 90c8734:	e0bfff15 	stw	r2,-4(fp)
 90c8738:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c873c:	e037883a 	mov	sp,fp
 90c8740:	dfc00117 	ldw	ra,4(sp)
 90c8744:	df000017 	ldw	fp,0(sp)
 90c8748:	dec00204 	addi	sp,sp,8
 90c874c:	f800283a 	ret

090c8750 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 90c8750:	defffc04 	addi	sp,sp,-16
 90c8754:	dfc00315 	stw	ra,12(sp)
 90c8758:	df000215 	stw	fp,8(sp)
 90c875c:	df000204 	addi	fp,sp,8
 90c8760:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 90c8764:	01000144 	movi	r4,5
 90c8768:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 90c876c:	e13fff17 	ldw	r4,-4(fp)
 90c8770:	90c86300 	call	90c8630 <vgetc_locked>
 90c8774:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c8778:	01000144 	movi	r4,5
 90c877c:	90a9b780 	call	90a9b78 <post_app_sem>
   return rc;
 90c8780:	e0bffe17 	ldw	r2,-8(fp)
}
 90c8784:	e037883a 	mov	sp,fp
 90c8788:	dfc00117 	ldw	ra,4(sp)
 90c878c:	df000017 	ldw	fp,0(sp)
 90c8790:	dec00204 	addi	sp,sp,8
 90c8794:	f800283a 	ret

090c8798 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 90c8798:	defffa04 	addi	sp,sp,-24
 90c879c:	dfc00515 	stw	ra,20(sp)
 90c87a0:	df000415 	stw	fp,16(sp)
 90c87a4:	df000404 	addi	fp,sp,16
 90c87a8:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 90c87ac:	e0bffe17 	ldw	r2,-8(fp)
 90c87b0:	10800003 	ldbu	r2,0(r2)
 90c87b4:	10803fcc 	andi	r2,r2,255
 90c87b8:	1080201c 	xori	r2,r2,128
 90c87bc:	10bfe004 	addi	r2,r2,-128
 90c87c0:	10800be0 	cmpeqi	r2,r2,47
 90c87c4:	1000071e 	bne	r2,zero,90c87e4 <vfslookup_locked+0x4c>
 90c87c8:	e0bffe17 	ldw	r2,-8(fp)
 90c87cc:	10800003 	ldbu	r2,0(r2)
 90c87d0:	10803fcc 	andi	r2,r2,255
 90c87d4:	1080201c 	xori	r2,r2,128
 90c87d8:	10bfe004 	addi	r2,r2,-128
 90c87dc:	10801718 	cmpnei	r2,r2,92
 90c87e0:	10001a1e 	bne	r2,zero,90c884c <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 90c87e4:	e13ffe17 	ldw	r4,-8(fp)
 90c87e8:	90c89180 	call	90c8918 <strippath>
 90c87ec:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 90c87f0:	e0bffc17 	ldw	r2,-16(fp)
 90c87f4:	1004c03a 	cmpne	r2,r2,zero
 90c87f8:	1000121e 	bne	r2,zero,90c8844 <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 90c87fc:	e0bffe17 	ldw	r2,-8(fp)
 90c8800:	10800003 	ldbu	r2,0(r2)
 90c8804:	10803fcc 	andi	r2,r2,255
 90c8808:	1080201c 	xori	r2,r2,128
 90c880c:	10bfe004 	addi	r2,r2,-128
 90c8810:	10800be0 	cmpeqi	r2,r2,47
 90c8814:	1000071e 	bne	r2,zero,90c8834 <vfslookup_locked+0x9c>
 90c8818:	e0bffe17 	ldw	r2,-8(fp)
 90c881c:	10800003 	ldbu	r2,0(r2)
 90c8820:	10803fcc 	andi	r2,r2,255
 90c8824:	1080201c 	xori	r2,r2,128
 90c8828:	10bfe004 	addi	r2,r2,-128
 90c882c:	10801718 	cmpnei	r2,r2,92
 90c8830:	1000061e 	bne	r2,zero,90c884c <vfslookup_locked+0xb4>
            name++;
 90c8834:	e0bffe17 	ldw	r2,-8(fp)
 90c8838:	10800044 	addi	r2,r2,1
 90c883c:	e0bffe15 	stw	r2,-8(fp)
 90c8840:	00000206 	br	90c884c <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 90c8844:	e0bffc17 	ldw	r2,-16(fp)
 90c8848:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 90c884c:	e13ffe17 	ldw	r4,-8(fp)
 90c8850:	01400fc4 	movi	r5,63
 90c8854:	90829800 	call	9082980 <strchr>
 90c8858:	1005003a 	cmpeq	r2,r2,zero
 90c885c:	1000031e 	bne	r2,zero,90c886c <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 90c8860:	90a94880 	call	90a9488 <dtrap>
      return NULL;
 90c8864:	e03fff15 	stw	zero,-4(fp)
 90c8868:	00001306 	br	90c88b8 <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 90c886c:	d0a0d617 	ldw	r2,-31912(gp)
 90c8870:	e0bffd15 	stw	r2,-12(fp)
 90c8874:	00000c06 	br	90c88a8 <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 90c8878:	e0bffd17 	ldw	r2,-12(fp)
 90c887c:	11400104 	addi	r5,r2,4
 90c8880:	e13ffe17 	ldw	r4,-8(fp)
 90c8884:	9089fd40 	call	9089fd4 <strcmp>
 90c8888:	1004c03a 	cmpne	r2,r2,zero
 90c888c:	1000031e 	bne	r2,zero,90c889c <vfslookup_locked+0x104>
         return vp;
 90c8890:	e0bffd17 	ldw	r2,-12(fp)
 90c8894:	e0bfff15 	stw	r2,-4(fp)
 90c8898:	00000706 	br	90c88b8 <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 90c889c:	e0bffd17 	ldw	r2,-12(fp)
 90c88a0:	10800017 	ldw	r2,0(r2)
 90c88a4:	e0bffd15 	stw	r2,-12(fp)
 90c88a8:	e0bffd17 	ldw	r2,-12(fp)
 90c88ac:	1004c03a 	cmpne	r2,r2,zero
 90c88b0:	103ff11e 	bne	r2,zero,90c8878 <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 90c88b4:	e03fff15 	stw	zero,-4(fp)
 90c88b8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c88bc:	e037883a 	mov	sp,fp
 90c88c0:	dfc00117 	ldw	ra,4(sp)
 90c88c4:	df000017 	ldw	fp,0(sp)
 90c88c8:	dec00204 	addi	sp,sp,8
 90c88cc:	f800283a 	ret

090c88d0 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 90c88d0:	defffc04 	addi	sp,sp,-16
 90c88d4:	dfc00315 	stw	ra,12(sp)
 90c88d8:	df000215 	stw	fp,8(sp)
 90c88dc:	df000204 	addi	fp,sp,8
 90c88e0:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c88e4:	01000144 	movi	r4,5
 90c88e8:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 90c88ec:	e13fff17 	ldw	r4,-4(fp)
 90c88f0:	90c87980 	call	90c8798 <vfslookup_locked>
 90c88f4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c88f8:	01000144 	movi	r4,5
 90c88fc:	90a9b780 	call	90a9b78 <post_app_sem>
   return vp;
 90c8900:	e0bffe17 	ldw	r2,-8(fp)
}
 90c8904:	e037883a 	mov	sp,fp
 90c8908:	dfc00117 	ldw	ra,4(sp)
 90c890c:	df000017 	ldw	fp,0(sp)
 90c8910:	dec00204 	addi	sp,sp,8
 90c8914:	f800283a 	ret

090c8918 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 90c8918:	defff804 	addi	sp,sp,-32
 90c891c:	dfc00715 	stw	ra,28(sp)
 90c8920:	df000615 	stw	fp,24(sp)
 90c8924:	df000604 	addi	fp,sp,24
 90c8928:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 90c892c:	e13ffe17 	ldw	r4,-8(fp)
 90c8930:	90a45340 	call	90a4534 <uslash>
 90c8934:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 90c8938:	d0a05517 	ldw	r2,-32428(gp)
 90c893c:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 90c8940:	00003e06 	br	90c8a3c <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 90c8944:	e0bffd17 	ldw	r2,-12(fp)
 90c8948:	10800044 	addi	r2,r2,1
 90c894c:	e0bffd15 	stw	r2,-12(fp)
 90c8950:	e0bffd17 	ldw	r2,-12(fp)
 90c8954:	10800003 	ldbu	r2,0(r2)
 90c8958:	10803fcc 	andi	r2,r2,255
 90c895c:	1080201c 	xori	r2,r2,128
 90c8960:	10bfe004 	addi	r2,r2,-128
 90c8964:	10800be0 	cmpeqi	r2,r2,47
 90c8968:	103ff61e 	bne	r2,zero,90c8944 <strippath+0x2c>
         if (*path == 0)
 90c896c:	e0bffd17 	ldw	r2,-12(fp)
 90c8970:	10800003 	ldbu	r2,0(r2)
 90c8974:	10803fcc 	andi	r2,r2,255
 90c8978:	1080201c 	xori	r2,r2,128
 90c897c:	10bfe004 	addi	r2,r2,-128
 90c8980:	1005003a 	cmpeq	r2,r2,zero
 90c8984:	10003b1e 	bne	r2,zero,90c8a74 <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 90c8988:	e13ffd17 	ldw	r4,-12(fp)
 90c898c:	01400bc4 	movi	r5,47
 90c8990:	90829800 	call	9082980 <strchr>
 90c8994:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 90c8998:	e0bffc17 	ldw	r2,-16(fp)
 90c899c:	1005003a 	cmpeq	r2,r2,zero
 90c89a0:	1000051e 	bne	r2,zero,90c89b8 <strippath+0xa0>
         dirlen = ptmp - path;
 90c89a4:	e0bffc17 	ldw	r2,-16(fp)
 90c89a8:	e0fffd17 	ldw	r3,-12(fp)
 90c89ac:	10c5c83a 	sub	r2,r2,r3
 90c89b0:	e0bffa15 	stw	r2,-24(fp)
 90c89b4:	00000706 	br	90c89d4 <strippath+0xbc>
      else
         dirlen = strlen(path);
 90c89b8:	e13ffd17 	ldw	r4,-12(fp)
 90c89bc:	90830d40 	call	90830d4 <strlen>
 90c89c0:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 90c89c4:	00000306 	br	90c89d4 <strippath+0xbc>
 90c89c8:	e0bffb17 	ldw	r2,-20(fp)
 90c89cc:	10800044 	addi	r2,r2,1
 90c89d0:	e0bffb15 	stw	r2,-20(fp)
 90c89d4:	e0bffb17 	ldw	r2,-20(fp)
 90c89d8:	10800003 	ldbu	r2,0(r2)
 90c89dc:	10803fcc 	andi	r2,r2,255
 90c89e0:	1080201c 	xori	r2,r2,128
 90c89e4:	10bfe004 	addi	r2,r2,-128
 90c89e8:	10800be0 	cmpeqi	r2,r2,47
 90c89ec:	103ff61e 	bne	r2,zero,90c89c8 <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 90c89f0:	e1bffa17 	ldw	r6,-24(fp)
 90c89f4:	e13ffb17 	ldw	r4,-20(fp)
 90c89f8:	e17ffd17 	ldw	r5,-12(fp)
 90c89fc:	90ca6400 	call	90ca640 <strncmp>
 90c8a00:	1004c03a 	cmpne	r2,r2,zero
 90c8a04:	10000b1e 	bne	r2,zero,90c8a34 <strippath+0x11c>
      {
         path += dirlen;
 90c8a08:	e0bffa17 	ldw	r2,-24(fp)
 90c8a0c:	1007883a 	mov	r3,r2
 90c8a10:	e0bffd17 	ldw	r2,-12(fp)
 90c8a14:	10c5883a 	add	r2,r2,r3
 90c8a18:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 90c8a1c:	e0bffa17 	ldw	r2,-24(fp)
 90c8a20:	1007883a 	mov	r3,r2
 90c8a24:	e0bffb17 	ldw	r2,-20(fp)
 90c8a28:	10c5883a 	add	r2,r2,r3
 90c8a2c:	e0bffb15 	stw	r2,-20(fp)
 90c8a30:	00000206 	br	90c8a3c <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 90c8a34:	e03fff15 	stw	zero,-4(fp)
 90c8a38:	00002b06 	br	90c8ae8 <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 90c8a3c:	e0bffd17 	ldw	r2,-12(fp)
 90c8a40:	10800003 	ldbu	r2,0(r2)
 90c8a44:	10803fcc 	andi	r2,r2,255
 90c8a48:	1080201c 	xori	r2,r2,128
 90c8a4c:	10bfe004 	addi	r2,r2,-128
 90c8a50:	1005003a 	cmpeq	r2,r2,zero
 90c8a54:	1000071e 	bne	r2,zero,90c8a74 <strippath+0x15c>
 90c8a58:	e0bffb17 	ldw	r2,-20(fp)
 90c8a5c:	10800003 	ldbu	r2,0(r2)
 90c8a60:	10803fcc 	andi	r2,r2,255
 90c8a64:	1080201c 	xori	r2,r2,128
 90c8a68:	10bfe004 	addi	r2,r2,-128
 90c8a6c:	1004c03a 	cmpne	r2,r2,zero
 90c8a70:	103fb71e 	bne	r2,zero,90c8950 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 90c8a74:	e0bffd17 	ldw	r2,-12(fp)
 90c8a78:	10800003 	ldbu	r2,0(r2)
 90c8a7c:	10803fcc 	andi	r2,r2,255
 90c8a80:	1080201c 	xori	r2,r2,128
 90c8a84:	10bfe004 	addi	r2,r2,-128
 90c8a88:	1004c03a 	cmpne	r2,r2,zero
 90c8a8c:	1000151e 	bne	r2,zero,90c8ae4 <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 90c8a90:	00000306 	br	90c8aa0 <strippath+0x188>
         ntmp++;
 90c8a94:	e0bffb17 	ldw	r2,-20(fp)
 90c8a98:	10800044 	addi	r2,r2,1
 90c8a9c:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 90c8aa0:	e0bffb17 	ldw	r2,-20(fp)
 90c8aa4:	10800003 	ldbu	r2,0(r2)
 90c8aa8:	10803fcc 	andi	r2,r2,255
 90c8aac:	1080201c 	xori	r2,r2,128
 90c8ab0:	10bfe004 	addi	r2,r2,-128
 90c8ab4:	10801720 	cmpeqi	r2,r2,92
 90c8ab8:	103ff61e 	bne	r2,zero,90c8a94 <strippath+0x17c>
 90c8abc:	e0bffb17 	ldw	r2,-20(fp)
 90c8ac0:	10800003 	ldbu	r2,0(r2)
 90c8ac4:	10803fcc 	andi	r2,r2,255
 90c8ac8:	1080201c 	xori	r2,r2,128
 90c8acc:	10bfe004 	addi	r2,r2,-128
 90c8ad0:	10800be0 	cmpeqi	r2,r2,47
 90c8ad4:	103fef1e 	bne	r2,zero,90c8a94 <strippath+0x17c>
         ntmp++;
      return ntmp;
 90c8ad8:	e0bffb17 	ldw	r2,-20(fp)
 90c8adc:	e0bfff15 	stw	r2,-4(fp)
 90c8ae0:	00000106 	br	90c8ae8 <strippath+0x1d0>
   }
   else
      return NULL;
 90c8ae4:	e03fff15 	stw	zero,-4(fp)
 90c8ae8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8aec:	e037883a 	mov	sp,fp
 90c8af0:	dfc00117 	ldw	ra,4(sp)
 90c8af4:	df000017 	ldw	fp,0(sp)
 90c8af8:	dec00204 	addi	sp,sp,8
 90c8afc:	f800283a 	ret

090c8b00 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 90c8b00:	defffc04 	addi	sp,sp,-16
 90c8b04:	df000315 	stw	fp,12(sp)
 90c8b08:	df000304 	addi	fp,sp,12
 90c8b0c:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c8b10:	d0a0d517 	ldw	r2,-31916(gp)
 90c8b14:	e0bffd15 	stw	r2,-12(fp)
 90c8b18:	00000906 	br	90c8b40 <isvfile_locked+0x40>
      if (vtmp == vfp)
 90c8b1c:	e0fffd17 	ldw	r3,-12(fp)
 90c8b20:	e0bffe17 	ldw	r2,-8(fp)
 90c8b24:	1880031e 	bne	r3,r2,90c8b34 <isvfile_locked+0x34>
      return TRUE;
 90c8b28:	00800044 	movi	r2,1
 90c8b2c:	e0bfff15 	stw	r2,-4(fp)
 90c8b30:	00000706 	br	90c8b50 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c8b34:	e0bffd17 	ldw	r2,-12(fp)
 90c8b38:	10800017 	ldw	r2,0(r2)
 90c8b3c:	e0bffd15 	stw	r2,-12(fp)
 90c8b40:	e0bffd17 	ldw	r2,-12(fp)
 90c8b44:	1004c03a 	cmpne	r2,r2,zero
 90c8b48:	103ff41e 	bne	r2,zero,90c8b1c <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 90c8b4c:	e03fff15 	stw	zero,-4(fp)
 90c8b50:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8b54:	e037883a 	mov	sp,fp
 90c8b58:	df000017 	ldw	fp,0(sp)
 90c8b5c:	dec00104 	addi	sp,sp,4
 90c8b60:	f800283a 	ret

090c8b64 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 90c8b64:	defffc04 	addi	sp,sp,-16
 90c8b68:	dfc00315 	stw	ra,12(sp)
 90c8b6c:	df000215 	stw	fp,8(sp)
 90c8b70:	df000204 	addi	fp,sp,8
 90c8b74:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 90c8b78:	01000144 	movi	r4,5
 90c8b7c:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 90c8b80:	e13fff17 	ldw	r4,-4(fp)
 90c8b84:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c8b88:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c8b8c:	01000144 	movi	r4,5
 90c8b90:	90a9b780 	call	90a9b78 <post_app_sem>
   return rc;
 90c8b94:	e0bffe17 	ldw	r2,-8(fp)
}
 90c8b98:	e037883a 	mov	sp,fp
 90c8b9c:	dfc00117 	ldw	ra,4(sp)
 90c8ba0:	df000017 	ldw	fp,0(sp)
 90c8ba4:	dec00204 	addi	sp,sp,8
 90c8ba8:	f800283a 	ret

090c8bac <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 90c8bac:	defffc04 	addi	sp,sp,-16
 90c8bb0:	dfc00315 	stw	ra,12(sp)
 90c8bb4:	df000215 	stw	fp,8(sp)
 90c8bb8:	df000204 	addi	fp,sp,8
 90c8bbc:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 90c8bc0:	01000144 	movi	r4,5
 90c8bc4:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c8bc8:	e13ffe17 	ldw	r4,-8(fp)
 90c8bcc:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c8bd0:	1005003a 	cmpeq	r2,r2,zero
 90c8bd4:	1000061e 	bne	r2,zero,90c8bf0 <vferror+0x44>
   {
      vfs_unlock();
 90c8bd8:	01000144 	movi	r4,5
 90c8bdc:	90a9b780 	call	90a9b78 <post_app_sem>

      return vfd->error;
 90c8be0:	e0bffe17 	ldw	r2,-8(fp)
 90c8be4:	10800417 	ldw	r2,16(r2)
 90c8be8:	e0bfff15 	stw	r2,-4(fp)
 90c8bec:	00000406 	br	90c8c00 <vferror+0x54>
   }

   vfs_unlock();
 90c8bf0:	01000144 	movi	r4,5
 90c8bf4:	90a9b780 	call	90a9b78 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 90c8bf8:	00bfffc4 	movi	r2,-1
 90c8bfc:	e0bfff15 	stw	r2,-4(fp)
 90c8c00:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c8c04:	e037883a 	mov	sp,fp
 90c8c08:	dfc00117 	ldw	ra,4(sp)
 90c8c0c:	df000017 	ldw	fp,0(sp)
 90c8c10:	dec00204 	addi	sp,sp,8
 90c8c14:	f800283a 	ret

090c8c18 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 90c8c18:	defffd04 	addi	sp,sp,-12
 90c8c1c:	dfc00215 	stw	ra,8(sp)
 90c8c20:	df000115 	stw	fp,4(sp)
 90c8c24:	df000104 	addi	fp,sp,4
 90c8c28:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 90c8c2c:	01000144 	movi	r4,5
 90c8c30:	90a9ac40 	call	90a9ac4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c8c34:	e13fff17 	ldw	r4,-4(fp)
 90c8c38:	90c8b000 	call	90c8b00 <isvfile_locked>
 90c8c3c:	1005003a 	cmpeq	r2,r2,zero
 90c8c40:	1000051e 	bne	r2,zero,90c8c58 <vclearerr+0x40>
   {
      vfs_unlock();
 90c8c44:	01000144 	movi	r4,5
 90c8c48:	90a9b780 	call	90a9b78 <post_app_sem>

      vfd->error = 0;
 90c8c4c:	e0bfff17 	ldw	r2,-4(fp)
 90c8c50:	10000415 	stw	zero,16(r2)
      return;
 90c8c54:	00000206 	br	90c8c60 <vclearerr+0x48>
   }

   vfs_unlock();
 90c8c58:	01000144 	movi	r4,5
 90c8c5c:	90a9b780 	call	90a9b78 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 90c8c60:	e037883a 	mov	sp,fp
 90c8c64:	dfc00117 	ldw	ra,4(sp)
 90c8c68:	df000017 	ldw	fp,0(sp)
 90c8c6c:	dec00204 	addi	sp,sp,8
 90c8c70:	f800283a 	ret

090c8c74 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 90c8c74:	defffe04 	addi	sp,sp,-8
 90c8c78:	df000115 	stw	fp,4(sp)
 90c8c7c:	df000104 	addi	fp,sp,4
int e = 0;
 90c8c80:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 90c8c84:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8c88:	e037883a 	mov	sp,fp
 90c8c8c:	df000017 	ldw	fp,0(sp)
 90c8c90:	dec00104 	addi	sp,sp,4
 90c8c94:	f800283a 	ret

090c8c98 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 90c8c98:	defffb04 	addi	sp,sp,-20
 90c8c9c:	df000415 	stw	fp,16(sp)
 90c8ca0:	df000404 	addi	fp,sp,16
 90c8ca4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 90c8ca8:	008000c4 	movi	r2,3
 90c8cac:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 90c8cb0:	e0fffc17 	ldw	r3,-16(fp)
 90c8cb4:	008003f4 	movhi	r2,15
 90c8cb8:	10909004 	addi	r2,r2,16960
 90c8cbc:	1887383a 	mul	r3,r3,r2
 90c8cc0:	00817db4 	movhi	r2,1526
 90c8cc4:	10b84004 	addi	r2,r2,-7936
 90c8cc8:	10c7203a 	divu	r3,r2,r3
 90c8ccc:	00a00034 	movhi	r2,32768
 90c8cd0:	10bfffc4 	addi	r2,r2,-1
 90c8cd4:	10c7203a 	divu	r3,r2,r3
 90c8cd8:	e0bfff17 	ldw	r2,-4(fp)
 90c8cdc:	10c5203a 	divu	r2,r2,r3
 90c8ce0:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 90c8ce4:	e0bffd17 	ldw	r2,-12(fp)
 90c8ce8:	1005003a 	cmpeq	r2,r2,zero
 90c8cec:	1000251e 	bne	r2,zero,90c8d84 <alt_busy_sleep+0xec>
  {
    for(i=0;i<big_loops;i++)
 90c8cf0:	e03ffe15 	stw	zero,-8(fp)
 90c8cf4:	00001406 	br	90c8d48 <alt_busy_sleep+0xb0>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 90c8cf8:	00a00034 	movhi	r2,32768
 90c8cfc:	10bfffc4 	addi	r2,r2,-1
 90c8d00:	10bfffc4 	addi	r2,r2,-1
 90c8d04:	103ffe1e 	bne	r2,zero,90c8d00 <alt_busy_sleep+0x68>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 90c8d08:	e0fffc17 	ldw	r3,-16(fp)
 90c8d0c:	008003f4 	movhi	r2,15
 90c8d10:	10909004 	addi	r2,r2,16960
 90c8d14:	1887383a 	mul	r3,r3,r2
 90c8d18:	00817db4 	movhi	r2,1526
 90c8d1c:	10b84004 	addi	r2,r2,-7936
 90c8d20:	10c7203a 	divu	r3,r2,r3
 90c8d24:	00a00034 	movhi	r2,32768
 90c8d28:	10bfffc4 	addi	r2,r2,-1
 90c8d2c:	10c7203a 	divu	r3,r2,r3
 90c8d30:	e0bfff17 	ldw	r2,-4(fp)
 90c8d34:	10c5c83a 	sub	r2,r2,r3
 90c8d38:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 90c8d3c:	e0bffe17 	ldw	r2,-8(fp)
 90c8d40:	10800044 	addi	r2,r2,1
 90c8d44:	e0bffe15 	stw	r2,-8(fp)
 90c8d48:	e0fffe17 	ldw	r3,-8(fp)
 90c8d4c:	e0bffd17 	ldw	r2,-12(fp)
 90c8d50:	18bfe916 	blt	r3,r2,90c8cf8 <alt_busy_sleep+0x60>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 90c8d54:	e0fffc17 	ldw	r3,-16(fp)
 90c8d58:	008003f4 	movhi	r2,15
 90c8d5c:	10909004 	addi	r2,r2,16960
 90c8d60:	1887383a 	mul	r3,r3,r2
 90c8d64:	00817db4 	movhi	r2,1526
 90c8d68:	10b84004 	addi	r2,r2,-7936
 90c8d6c:	10c7203a 	divu	r3,r2,r3
 90c8d70:	e0bfff17 	ldw	r2,-4(fp)
 90c8d74:	1885383a 	mul	r2,r3,r2
 90c8d78:	10bfffc4 	addi	r2,r2,-1
 90c8d7c:	103ffe1e 	bne	r2,zero,90c8d78 <alt_busy_sleep+0xe0>
 90c8d80:	00000b06 	br	90c8db0 <alt_busy_sleep+0x118>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 90c8d84:	e0fffc17 	ldw	r3,-16(fp)
 90c8d88:	008003f4 	movhi	r2,15
 90c8d8c:	10909004 	addi	r2,r2,16960
 90c8d90:	1887383a 	mul	r3,r3,r2
 90c8d94:	00817db4 	movhi	r2,1526
 90c8d98:	10b84004 	addi	r2,r2,-7936
 90c8d9c:	10c7203a 	divu	r3,r2,r3
 90c8da0:	e0bfff17 	ldw	r2,-4(fp)
 90c8da4:	1885383a 	mul	r2,r3,r2
 90c8da8:	10bfffc4 	addi	r2,r2,-1
 90c8dac:	00bffe16 	blt	zero,r2,90c8da8 <alt_busy_sleep+0x110>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 90c8db0:	0005883a 	mov	r2,zero
}
 90c8db4:	e037883a 	mov	sp,fp
 90c8db8:	df000017 	ldw	fp,0(sp)
 90c8dbc:	dec00104 	addi	sp,sp,4
 90c8dc0:	f800283a 	ret

090c8dc4 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 90c8dc4:	defff404 	addi	sp,sp,-48
 90c8dc8:	dfc00915 	stw	ra,36(sp)
 90c8dcc:	df000815 	stw	fp,32(sp)
 90c8dd0:	df000804 	addi	fp,sp,32
 90c8dd4:	e13ffb15 	stw	r4,-20(fp)
 90c8dd8:	e1800215 	stw	r6,8(fp)
 90c8ddc:	e1c00315 	stw	r7,12(fp)
 90c8de0:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90c8de4:	e0bffb17 	ldw	r2,-20(fp)
 90c8de8:	1004803a 	cmplt	r2,r2,zero
 90c8dec:	1000081e 	bne	r2,zero,90c8e10 <alt_fcntl+0x4c>
 90c8df0:	e0bffb17 	ldw	r2,-20(fp)
 90c8df4:	10800324 	muli	r2,r2,12
 90c8df8:	1007883a 	mov	r3,r2
 90c8dfc:	00824374 	movhi	r2,2317
 90c8e00:	108ad604 	addi	r2,r2,11096
 90c8e04:	1887883a 	add	r3,r3,r2
 90c8e08:	e0fffe15 	stw	r3,-8(fp)
 90c8e0c:	00000106 	br	90c8e14 <alt_fcntl+0x50>
 90c8e10:	e03ffe15 	stw	zero,-8(fp)
 90c8e14:	e0bffe17 	ldw	r2,-8(fp)
 90c8e18:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 90c8e1c:	e0bff917 	ldw	r2,-28(fp)
 90c8e20:	1005003a 	cmpeq	r2,r2,zero
 90c8e24:	1000301e 	bne	r2,zero,90c8ee8 <alt_fcntl+0x124>
  {
    switch (cmd)
 90c8e28:	e0fffc17 	ldw	r3,-16(fp)
 90c8e2c:	e0ffff15 	stw	r3,-4(fp)
 90c8e30:	e0ffff17 	ldw	r3,-4(fp)
 90c8e34:	188000e0 	cmpeqi	r2,r3,3
 90c8e38:	1000041e 	bne	r2,zero,90c8e4c <alt_fcntl+0x88>
 90c8e3c:	e0ffff17 	ldw	r3,-4(fp)
 90c8e40:	18800120 	cmpeqi	r2,r3,4
 90c8e44:	1000081e 	bne	r2,zero,90c8e68 <alt_fcntl+0xa4>
 90c8e48:	00002006 	br	90c8ecc <alt_fcntl+0x108>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 90c8e4c:	e0bff917 	ldw	r2,-28(fp)
 90c8e50:	10c00217 	ldw	r3,8(r2)
 90c8e54:	00900034 	movhi	r2,16384
 90c8e58:	10bfffc4 	addi	r2,r2,-1
 90c8e5c:	1886703a 	and	r3,r3,r2
 90c8e60:	e0fffd15 	stw	r3,-12(fp)
 90c8e64:	00002606 	br	90c8f00 <alt_fcntl+0x13c>
    case F_SETFL:
      va_start(argp, cmd);
 90c8e68:	e0800204 	addi	r2,fp,8
 90c8e6c:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 90c8e70:	e0fffa17 	ldw	r3,-24(fp)
 90c8e74:	18800104 	addi	r2,r3,4
 90c8e78:	e0bffa15 	stw	r2,-24(fp)
 90c8e7c:	1805883a 	mov	r2,r3
 90c8e80:	10800017 	ldw	r2,0(r2)
 90c8e84:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 90c8e88:	e0bff917 	ldw	r2,-28(fp)
 90c8e8c:	10c00217 	ldw	r3,8(r2)
 90c8e90:	00affdc4 	movi	r2,-16393
 90c8e94:	1886703a 	and	r3,r3,r2
 90c8e98:	e0bff917 	ldw	r2,-28(fp)
 90c8e9c:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 90c8ea0:	e0bff917 	ldw	r2,-28(fp)
 90c8ea4:	10800217 	ldw	r2,8(r2)
 90c8ea8:	1007883a 	mov	r3,r2
 90c8eac:	e0bff817 	ldw	r2,-32(fp)
 90c8eb0:	1090020c 	andi	r2,r2,16392
 90c8eb4:	1884b03a 	or	r2,r3,r2
 90c8eb8:	1007883a 	mov	r3,r2
 90c8ebc:	e0bff917 	ldw	r2,-28(fp)
 90c8ec0:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 90c8ec4:	e03ffd15 	stw	zero,-12(fp)
 90c8ec8:	00000d06 	br	90c8f00 <alt_fcntl+0x13c>
    default:
      ALT_ERRNO = EINVAL;
 90c8ecc:	90c8f180 	call	90c8f18 <alt_get_errno>
 90c8ed0:	1007883a 	mov	r3,r2
 90c8ed4:	00800584 	movi	r2,22
 90c8ed8:	18800015 	stw	r2,0(r3)
      return -1;
 90c8edc:	00bfffc4 	movi	r2,-1
 90c8ee0:	e0bffd15 	stw	r2,-12(fp)
 90c8ee4:	00000606 	br	90c8f00 <alt_fcntl+0x13c>
    }
  }

  ALT_ERRNO = EBADFD;
 90c8ee8:	90c8f180 	call	90c8f18 <alt_get_errno>
 90c8eec:	1007883a 	mov	r3,r2
 90c8ef0:	00801444 	movi	r2,81
 90c8ef4:	18800015 	stw	r2,0(r3)
  return -1;
 90c8ef8:	00ffffc4 	movi	r3,-1
 90c8efc:	e0fffd15 	stw	r3,-12(fp)
 90c8f00:	e0bffd17 	ldw	r2,-12(fp)
}
 90c8f04:	e037883a 	mov	sp,fp
 90c8f08:	dfc00117 	ldw	ra,4(sp)
 90c8f0c:	df000017 	ldw	fp,0(sp)
 90c8f10:	dec00404 	addi	sp,sp,16
 90c8f14:	f800283a 	ret

090c8f18 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90c8f18:	defffd04 	addi	sp,sp,-12
 90c8f1c:	dfc00215 	stw	ra,8(sp)
 90c8f20:	df000115 	stw	fp,4(sp)
 90c8f24:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90c8f28:	00824374 	movhi	r2,2317
 90c8f2c:	108bdf04 	addi	r2,r2,12156
 90c8f30:	10800017 	ldw	r2,0(r2)
 90c8f34:	1005003a 	cmpeq	r2,r2,zero
 90c8f38:	1000061e 	bne	r2,zero,90c8f54 <alt_get_errno+0x3c>
 90c8f3c:	00824374 	movhi	r2,2317
 90c8f40:	108bdf04 	addi	r2,r2,12156
 90c8f44:	10800017 	ldw	r2,0(r2)
 90c8f48:	103ee83a 	callr	r2
 90c8f4c:	e0bfff15 	stw	r2,-4(fp)
 90c8f50:	00000306 	br	90c8f60 <alt_get_errno+0x48>
 90c8f54:	00824374 	movhi	r2,2317
 90c8f58:	108bfd04 	addi	r2,r2,12276
 90c8f5c:	e0bfff15 	stw	r2,-4(fp)
 90c8f60:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8f64:	e037883a 	mov	sp,fp
 90c8f68:	dfc00117 	ldw	ra,4(sp)
 90c8f6c:	df000017 	ldw	fp,0(sp)
 90c8f70:	dec00204 	addi	sp,sp,8
 90c8f74:	f800283a 	ret

090c8f78 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 90c8f78:	defffa04 	addi	sp,sp,-24
 90c8f7c:	dfc00515 	stw	ra,20(sp)
 90c8f80:	df000415 	stw	fp,16(sp)
 90c8f84:	df000404 	addi	fp,sp,16
 90c8f88:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 90c8f8c:	00824374 	movhi	r2,2317
 90c8f90:	108bda04 	addi	r2,r2,12136
 90c8f94:	10800017 	ldw	r2,0(r2)
 90c8f98:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 90c8f9c:	00003306 	br	90c906c <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 90c8fa0:	e0bffd17 	ldw	r2,-12(fp)
 90c8fa4:	11000217 	ldw	r4,8(r2)
 90c8fa8:	90830d40 	call	90830d4 <strlen>
 90c8fac:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 90c8fb0:	e0bffd17 	ldw	r2,-12(fp)
 90c8fb4:	10c00217 	ldw	r3,8(r2)
 90c8fb8:	e0bffc17 	ldw	r2,-16(fp)
 90c8fbc:	1885883a 	add	r2,r3,r2
 90c8fc0:	10bfffc4 	addi	r2,r2,-1
 90c8fc4:	10800003 	ldbu	r2,0(r2)
 90c8fc8:	10803fcc 	andi	r2,r2,255
 90c8fcc:	1080201c 	xori	r2,r2,128
 90c8fd0:	10bfe004 	addi	r2,r2,-128
 90c8fd4:	10800bd8 	cmpnei	r2,r2,47
 90c8fd8:	1000031e 	bne	r2,zero,90c8fe8 <alt_find_file+0x70>
    {
      len -= 1;
 90c8fdc:	e0bffc17 	ldw	r2,-16(fp)
 90c8fe0:	10bfffc4 	addi	r2,r2,-1
 90c8fe4:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 90c8fe8:	e0bffc17 	ldw	r2,-16(fp)
 90c8fec:	1007883a 	mov	r3,r2
 90c8ff0:	e0bffe17 	ldw	r2,-8(fp)
 90c8ff4:	1885883a 	add	r2,r3,r2
 90c8ff8:	10800003 	ldbu	r2,0(r2)
 90c8ffc:	10803fcc 	andi	r2,r2,255
 90c9000:	1080201c 	xori	r2,r2,128
 90c9004:	10bfe004 	addi	r2,r2,-128
 90c9008:	10800be0 	cmpeqi	r2,r2,47
 90c900c:	10000a1e 	bne	r2,zero,90c9038 <alt_find_file+0xc0>
 90c9010:	e0bffc17 	ldw	r2,-16(fp)
 90c9014:	1007883a 	mov	r3,r2
 90c9018:	e0bffe17 	ldw	r2,-8(fp)
 90c901c:	1885883a 	add	r2,r3,r2
 90c9020:	10800003 	ldbu	r2,0(r2)
 90c9024:	10803fcc 	andi	r2,r2,255
 90c9028:	1080201c 	xori	r2,r2,128
 90c902c:	10bfe004 	addi	r2,r2,-128
 90c9030:	1004c03a 	cmpne	r2,r2,zero
 90c9034:	10000a1e 	bne	r2,zero,90c9060 <alt_find_file+0xe8>
 90c9038:	e0bffd17 	ldw	r2,-12(fp)
 90c903c:	11000217 	ldw	r4,8(r2)
 90c9040:	e1bffc17 	ldw	r6,-16(fp)
 90c9044:	e17ffe17 	ldw	r5,-8(fp)
 90c9048:	90ca5400 	call	90ca540 <memcmp>
 90c904c:	1004c03a 	cmpne	r2,r2,zero
 90c9050:	1000031e 	bne	r2,zero,90c9060 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 90c9054:	e0bffd17 	ldw	r2,-12(fp)
 90c9058:	e0bfff15 	stw	r2,-4(fp)
 90c905c:	00000806 	br	90c9080 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 90c9060:	e0bffd17 	ldw	r2,-12(fp)
 90c9064:	10800017 	ldw	r2,0(r2)
 90c9068:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 90c906c:	00c24374 	movhi	r3,2317
 90c9070:	18cbda04 	addi	r3,r3,12136
 90c9074:	e0bffd17 	ldw	r2,-12(fp)
 90c9078:	10ffc91e 	bne	r2,r3,90c8fa0 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 90c907c:	e03fff15 	stw	zero,-4(fp)
 90c9080:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9084:	e037883a 	mov	sp,fp
 90c9088:	dfc00117 	ldw	ra,4(sp)
 90c908c:	df000017 	ldw	fp,0(sp)
 90c9090:	dec00204 	addi	sp,sp,8
 90c9094:	f800283a 	ret

090c9098 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 90c9098:	defff804 	addi	sp,sp,-32
 90c909c:	dfc00715 	stw	ra,28(sp)
 90c90a0:	df000615 	stw	fp,24(sp)
 90c90a4:	df000604 	addi	fp,sp,24
 90c90a8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 90c90ac:	00bffa04 	movi	r2,-24
 90c90b0:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 90c90b4:	00824374 	movhi	r2,2317
 90c90b8:	108c5004 	addi	r2,r2,12608
 90c90bc:	10800017 	ldw	r2,0(r2)
 90c90c0:	e0bffa15 	stw	r2,-24(fp)
 90c90c4:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 90c90c8:	e17ffb0b 	ldhu	r5,-20(fp)
 90c90cc:	e1bffe04 	addi	r6,fp,-8
 90c90d0:	e13ffa17 	ldw	r4,-24(fp)
 90c90d4:	9092c6c0 	call	9092c6c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 90c90d8:	e03ffd15 	stw	zero,-12(fp)
 90c90dc:	00001e06 	br	90c9158 <alt_get_fd+0xc0>
  {
    if (!alt_fd_list[i].dev)
 90c90e0:	e0bffd17 	ldw	r2,-12(fp)
 90c90e4:	00c24374 	movhi	r3,2317
 90c90e8:	18cad604 	addi	r3,r3,11096
 90c90ec:	10800324 	muli	r2,r2,12
 90c90f0:	10c5883a 	add	r2,r2,r3
 90c90f4:	10800017 	ldw	r2,0(r2)
 90c90f8:	1004c03a 	cmpne	r2,r2,zero
 90c90fc:	1000131e 	bne	r2,zero,90c914c <alt_get_fd+0xb4>
    {
      alt_fd_list[i].dev = dev;
 90c9100:	e0bffd17 	ldw	r2,-12(fp)
 90c9104:	00c24374 	movhi	r3,2317
 90c9108:	18cad604 	addi	r3,r3,11096
 90c910c:	10800324 	muli	r2,r2,12
 90c9110:	10c7883a 	add	r3,r2,r3
 90c9114:	e0bfff17 	ldw	r2,-4(fp)
 90c9118:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 90c911c:	00824374 	movhi	r2,2317
 90c9120:	108bde04 	addi	r2,r2,12152
 90c9124:	10c00017 	ldw	r3,0(r2)
 90c9128:	e0bffd17 	ldw	r2,-12(fp)
 90c912c:	1880040e 	bge	r3,r2,90c9140 <alt_get_fd+0xa8>
      {
        alt_max_fd = i;
 90c9130:	00c24374 	movhi	r3,2317
 90c9134:	18cbde04 	addi	r3,r3,12152
 90c9138:	e0bffd17 	ldw	r2,-12(fp)
 90c913c:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 90c9140:	e0bffd17 	ldw	r2,-12(fp)
 90c9144:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 90c9148:	00000606 	br	90c9164 <alt_get_fd+0xcc>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 90c914c:	e0bffd17 	ldw	r2,-12(fp)
 90c9150:	10800044 	addi	r2,r2,1
 90c9154:	e0bffd15 	stw	r2,-12(fp)
 90c9158:	e0bffd17 	ldw	r2,-12(fp)
 90c915c:	10800810 	cmplti	r2,r2,32
 90c9160:	103fdf1e 	bne	r2,zero,90c90e0 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 90c9164:	00824374 	movhi	r2,2317
 90c9168:	108c5004 	addi	r2,r2,12608
 90c916c:	11000017 	ldw	r4,0(r2)
 90c9170:	90930640 	call	9093064 <OSSemPost>

  return rc;
 90c9174:	e0bffc17 	ldw	r2,-16(fp)
}
 90c9178:	e037883a 	mov	sp,fp
 90c917c:	dfc00117 	ldw	ra,4(sp)
 90c9180:	df000017 	ldw	fp,0(sp)
 90c9184:	dec00204 	addi	sp,sp,8
 90c9188:	f800283a 	ret

090c918c <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 90c918c:	deffed04 	addi	sp,sp,-76
 90c9190:	dfc01215 	stw	ra,72(sp)
 90c9194:	df001115 	stw	fp,68(sp)
 90c9198:	dc401015 	stw	r17,64(sp)
 90c919c:	dc000f15 	stw	r16,60(sp)
 90c91a0:	df000f04 	addi	fp,sp,60
 90c91a4:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 90c91a8:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 90c91ac:	008243b4 	movhi	r2,2318
 90c91b0:	10b68204 	addi	r2,r2,-9720
 90c91b4:	10800017 	ldw	r2,0(r2)
 90c91b8:	10c00044 	addi	r3,r2,1
 90c91bc:	008243b4 	movhi	r2,2318
 90c91c0:	10b68204 	addi	r2,r2,-9720
 90c91c4:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 90c91c8:	e0bffd17 	ldw	r2,-12(fp)
 90c91cc:	10800317 	ldw	r2,12(r2)
 90c91d0:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 90c91d4:	e0bffd17 	ldw	r2,-12(fp)
 90c91d8:	10c00417 	ldw	r3,16(r2)
 90c91dc:	e0bffa17 	ldw	r2,-24(fp)
 90c91e0:	10800003 	ldbu	r2,0(r2)
 90c91e4:	10803fcc 	andi	r2,r2,255
 90c91e8:	108003cc 	andi	r2,r2,15
 90c91ec:	1085883a 	add	r2,r2,r2
 90c91f0:	1085883a 	add	r2,r2,r2
 90c91f4:	1885c83a 	sub	r2,r3,r2
 90c91f8:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 90c91fc:	e0bffd17 	ldw	r2,-12(fp)
 90c9200:	10800717 	ldw	r2,28(r2)
 90c9204:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c9208:	00824374 	movhi	r2,2317
 90c920c:	108c1d04 	addi	r2,r2,12404
 90c9210:	10800017 	ldw	r2,0(r2)
 90c9214:	1081000c 	andi	r2,r2,1024
 90c9218:	1005003a 	cmpeq	r2,r2,zero
 90c921c:	1000161e 	bne	r2,zero,90c9278 <icmprcv+0xec>
 90c9220:	00824374 	movhi	r2,2317
 90c9224:	108c1d04 	addi	r2,r2,12404
 90c9228:	10800017 	ldw	r2,0(r2)
 90c922c:	1080800c 	andi	r2,r2,512
 90c9230:	1005003a 	cmpeq	r2,r2,zero
 90c9234:	1000101e 	bne	r2,zero,90c9278 <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 90c9238:	e0bffb17 	ldw	r2,-20(fp)
 90c923c:	11803fcc 	andi	r6,r2,255
 90c9240:	e0bffb17 	ldw	r2,-20(fp)
 90c9244:	1004d23a 	srli	r2,r2,8
 90c9248:	11c03fcc 	andi	r7,r2,255
 90c924c:	e0bffb17 	ldw	r2,-20(fp)
 90c9250:	1004d43a 	srli	r2,r2,16
 90c9254:	10c03fcc 	andi	r3,r2,255
 90c9258:	e0bffb17 	ldw	r2,-20(fp)
 90c925c:	1004d63a 	srli	r2,r2,24
 90c9260:	d8c00015 	stw	r3,0(sp)
 90c9264:	d8800115 	stw	r2,4(sp)
 90c9268:	01024374 	movhi	r4,2317
 90c926c:	2102dd04 	addi	r4,r4,2932
 90c9270:	e17ffc17 	ldw	r5,-16(fp)
 90c9274:	90825100 	call	9082510 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 90c9278:	e0bffa17 	ldw	r2,-24(fp)
 90c927c:	10800003 	ldbu	r2,0(r2)
 90c9280:	10803fcc 	andi	r2,r2,255
 90c9284:	108003cc 	andi	r2,r2,15
 90c9288:	1085883a 	add	r2,r2,r2
 90c928c:	1085883a 	add	r2,r2,r2
 90c9290:	1007883a 	mov	r3,r2
 90c9294:	e0bffa17 	ldw	r2,-24(fp)
 90c9298:	1885883a 	add	r2,r3,r2
 90c929c:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 90c92a0:	e0bff917 	ldw	r2,-28(fp)
 90c92a4:	1080008b 	ldhu	r2,2(r2)
 90c92a8:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 90c92ac:	e0bff917 	ldw	r2,-28(fp)
 90c92b0:	1000008d 	sth	zero,2(r2)

   if (len&1)
 90c92b4:	e0bffc17 	ldw	r2,-16(fp)
 90c92b8:	1080004c 	andi	r2,r2,1
 90c92bc:	10803fcc 	andi	r2,r2,255
 90c92c0:	1005003a 	cmpeq	r2,r2,zero
 90c92c4:	1000091e 	bne	r2,zero,90c92ec <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 90c92c8:	e0fff917 	ldw	r3,-28(fp)
 90c92cc:	e0bffc17 	ldw	r2,-16(fp)
 90c92d0:	1885883a 	add	r2,r3,r2
 90c92d4:	10800003 	ldbu	r2,0(r2)
 90c92d8:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 90c92dc:	e0fff917 	ldw	r3,-28(fp)
 90c92e0:	e0bffc17 	ldw	r2,-16(fp)
 90c92e4:	1885883a 	add	r2,r3,r2
 90c92e8:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 90c92ec:	e0bffc17 	ldw	r2,-16(fp)
 90c92f0:	10800044 	addi	r2,r2,1
 90c92f4:	100ad07a 	srli	r5,r2,1
 90c92f8:	e13ff917 	ldw	r4,-28(fp)
 90c92fc:	90a3f040 	call	90a3f04 <cksum>
 90c9300:	0084303a 	nor	r2,zero,r2
 90c9304:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 90c9308:	e0bffc17 	ldw	r2,-16(fp)
 90c930c:	1080004c 	andi	r2,r2,1
 90c9310:	10803fcc 	andi	r2,r2,255
 90c9314:	1005003a 	cmpeq	r2,r2,zero
 90c9318:	1000051e 	bne	r2,zero,90c9330 <icmprcv+0x1a4>
 90c931c:	e0fff917 	ldw	r3,-28(fp)
 90c9320:	e0bffc17 	ldw	r2,-16(fp)
 90c9324:	1887883a 	add	r3,r3,r2
 90c9328:	e0bff503 	ldbu	r2,-44(fp)
 90c932c:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 90c9330:	e0fff80b 	ldhu	r3,-32(fp)
 90c9334:	e0bff88b 	ldhu	r2,-30(fp)
 90c9338:	18802c26 	beq	r3,r2,90c93ec <icmprcv+0x260>
   {
      e->pchksum = osum;
 90c933c:	e0fff917 	ldw	r3,-28(fp)
 90c9340:	e0bff88b 	ldhu	r2,-30(fp)
 90c9344:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c9348:	00824374 	movhi	r2,2317
 90c934c:	108c1d04 	addi	r2,r2,12404
 90c9350:	10800017 	ldw	r2,0(r2)
 90c9354:	1081000c 	andi	r2,r2,1024
 90c9358:	1005003a 	cmpeq	r2,r2,zero
 90c935c:	1000131e 	bne	r2,zero,90c93ac <icmprcv+0x220>
 90c9360:	00824374 	movhi	r2,2317
 90c9364:	108c1d04 	addi	r2,r2,12404
 90c9368:	10800017 	ldw	r2,0(r2)
 90c936c:	1080800c 	andi	r2,r2,512
 90c9370:	1005003a 	cmpeq	r2,r2,zero
 90c9374:	10000d1e 	bne	r2,zero,90c93ac <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 90c9378:	e17ff88b 	ldhu	r5,-30(fp)
 90c937c:	e1bff80b 	ldhu	r6,-32(fp)
 90c9380:	01024374 	movhi	r4,2317
 90c9384:	2102e504 	addi	r4,r4,2964
 90c9388:	90825100 	call	9082510 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 90c938c:	00824374 	movhi	r2,2317
 90c9390:	108c1d04 	addi	r2,r2,12404
 90c9394:	10800017 	ldw	r2,0(r2)
 90c9398:	1080008c 	andi	r2,r2,2
 90c939c:	1005003a 	cmpeq	r2,r2,zero
 90c93a0:	1000021e 	bne	r2,zero,90c93ac <icmprcv+0x220>
 90c93a4:	e13ffd17 	ldw	r4,-12(fp)
 90c93a8:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 90c93ac:	008243b4 	movhi	r2,2318
 90c93b0:	10b68204 	addi	r2,r2,-9720
 90c93b4:	10800117 	ldw	r2,4(r2)
 90c93b8:	10c00044 	addi	r3,r2,1
 90c93bc:	008243b4 	movhi	r2,2318
 90c93c0:	10b68204 	addi	r2,r2,-9720
 90c93c4:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c93c8:	01000084 	movi	r4,2
 90c93cc:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c93d0:	e13ffd17 	ldw	r4,-12(fp)
 90c93d4:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c93d8:	01000084 	movi	r4,2
 90c93dc:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 90c93e0:	00bff804 	movi	r2,-32
 90c93e4:	e0bfff15 	stw	r2,-4(fp)
 90c93e8:	00026d06 	br	90c9da0 <icmprcv+0xc14>
   }

   e->pchksum = osum;
 90c93ec:	e0fff917 	ldw	r3,-28(fp)
 90c93f0:	e0bff88b 	ldhu	r2,-30(fp)
 90c93f4:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 90c93f8:	e0bff917 	ldw	r2,-28(fp)
 90c93fc:	10800003 	ldbu	r2,0(r2)
 90c9400:	10803fcc 	andi	r2,r2,255
 90c9404:	1080201c 	xori	r2,r2,128
 90c9408:	10bfe004 	addi	r2,r2,-128
 90c940c:	e0bffe15 	stw	r2,-8(fp)
 90c9410:	e0fffe17 	ldw	r3,-8(fp)
 90c9414:	18800428 	cmpgeui	r2,r3,16
 90c9418:	1002401e 	bne	r2,zero,90c9d1c <icmprcv+0xb90>
 90c941c:	e13ffe17 	ldw	r4,-8(fp)
 90c9420:	e13ffe17 	ldw	r4,-8(fp)
 90c9424:	2105883a 	add	r2,r4,r4
 90c9428:	1087883a 	add	r3,r2,r2
 90c942c:	00824374 	movhi	r2,2317
 90c9430:	10a51004 	addi	r2,r2,-27584
 90c9434:	1885883a 	add	r2,r3,r2
 90c9438:	10800017 	ldw	r2,0(r2)
 90c943c:	1000683a 	jmp	r2
 90c9440:	090c9724 	muli	r4,at,12892
 90c9444:	090c9d1c 	xori	r4,at,12916
 90c9448:	090c9d1c 	xori	r4,at,12916
 90c944c:	090c9750 	cmplti	r4,at,12893
 90c9450:	090c9840 	call	90c984 <OSCtxSw_SWITCH_PC+0x90c944>
 90c9454:	090c98e8 	cmpgeui	r4,at,12899
 90c9458:	090c9d1c 	xori	r4,at,12916
 90c945c:	090c9d1c 	xori	r4,at,12916
 90c9460:	090c9480 	call	90c948 <OSCtxSw_SWITCH_PC+0x90c908>
 90c9464:	090c9d1c 	xori	r4,at,12916
 90c9468:	090c9d1c 	xori	r4,at,12916
 90c946c:	090c9a08 	cmpgei	r4,at,12904
 90c9470:	090c9b10 	cmplti	r4,at,12908
 90c9474:	090c9b8c 	andi	r4,at,12910
 90c9478:	090c9d1c 	xori	r4,at,12916
 90c947c:	090c9cdc 	xori	r4,at,12915
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 90c9480:	008243b4 	movhi	r2,2318
 90c9484:	10b68204 	addi	r2,r2,-9720
 90c9488:	10800717 	ldw	r2,28(r2)
 90c948c:	10c00044 	addi	r3,r2,1
 90c9490:	008243b4 	movhi	r2,2318
 90c9494:	10b68204 	addi	r2,r2,-9720
 90c9498:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c949c:	00824374 	movhi	r2,2317
 90c94a0:	108c1d04 	addi	r2,r2,12404
 90c94a4:	10800017 	ldw	r2,0(r2)
 90c94a8:	1081000c 	andi	r2,r2,1024
 90c94ac:	1005003a 	cmpeq	r2,r2,zero
 90c94b0:	1000141e 	bne	r2,zero,90c9504 <icmprcv+0x378>
 90c94b4:	00824374 	movhi	r2,2317
 90c94b8:	108c1d04 	addi	r2,r2,12404
 90c94bc:	10800017 	ldw	r2,0(r2)
 90c94c0:	1080800c 	andi	r2,r2,512
 90c94c4:	1005003a 	cmpeq	r2,r2,zero
 90c94c8:	10000e1e 	bne	r2,zero,90c9504 <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90c94cc:	e0bffb17 	ldw	r2,-20(fp)
 90c94d0:	11403fcc 	andi	r5,r2,255
 90c94d4:	e0bffb17 	ldw	r2,-20(fp)
 90c94d8:	1004d23a 	srli	r2,r2,8
 90c94dc:	11803fcc 	andi	r6,r2,255
 90c94e0:	e0bffb17 	ldw	r2,-20(fp)
 90c94e4:	1004d43a 	srli	r2,r2,16
 90c94e8:	11c03fcc 	andi	r7,r2,255
 90c94ec:	e0bffb17 	ldw	r2,-20(fp)
 90c94f0:	1004d63a 	srli	r2,r2,24
 90c94f4:	d8800015 	stw	r2,0(sp)
 90c94f8:	01024374 	movhi	r4,2317
 90c94fc:	2102f004 	addi	r4,r4,3008
 90c9500:	90825100 	call	9082510 <printf>
#endif
      e->ptype = ECHOREP;
 90c9504:	e0bff917 	ldw	r2,-28(fp)
 90c9508:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 90c950c:	e0bff917 	ldw	r2,-28(fp)
 90c9510:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 90c9514:	e0bffc17 	ldw	r2,-16(fp)
 90c9518:	1080004c 	andi	r2,r2,1
 90c951c:	10803fcc 	andi	r2,r2,255
 90c9520:	1005003a 	cmpeq	r2,r2,zero
 90c9524:	1000091e 	bne	r2,zero,90c954c <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 90c9528:	e0fff917 	ldw	r3,-28(fp)
 90c952c:	e0bffc17 	ldw	r2,-16(fp)
 90c9530:	1885883a 	add	r2,r3,r2
 90c9534:	10800003 	ldbu	r2,0(r2)
 90c9538:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 90c953c:	e0fff917 	ldw	r3,-28(fp)
 90c9540:	e0bffc17 	ldw	r2,-16(fp)
 90c9544:	1885883a 	add	r2,r3,r2
 90c9548:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 90c954c:	e0bffc17 	ldw	r2,-16(fp)
 90c9550:	10800044 	addi	r2,r2,1
 90c9554:	100ad07a 	srli	r5,r2,1
 90c9558:	e13ff917 	ldw	r4,-28(fp)
 90c955c:	90a3f040 	call	90a3f04 <cksum>
 90c9560:	0084303a 	nor	r2,zero,r2
 90c9564:	1007883a 	mov	r3,r2
 90c9568:	e0bff917 	ldw	r2,-28(fp)
 90c956c:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 90c9570:	e0bffc17 	ldw	r2,-16(fp)
 90c9574:	1080004c 	andi	r2,r2,1
 90c9578:	10803fcc 	andi	r2,r2,255
 90c957c:	1005003a 	cmpeq	r2,r2,zero
 90c9580:	1000051e 	bne	r2,zero,90c9598 <icmprcv+0x40c>
 90c9584:	e0fff917 	ldw	r3,-28(fp)
 90c9588:	e0bffc17 	ldw	r2,-16(fp)
 90c958c:	1887883a 	add	r3,r3,r2
 90c9590:	e0bff503 	ldbu	r2,-44(fp)
 90c9594:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 90c9598:	e0bffa17 	ldw	r2,-24(fp)
 90c959c:	10800417 	ldw	r2,16(r2)
 90c95a0:	10bfffe0 	cmpeqi	r2,r2,-1
 90c95a4:	1000211e 	bne	r2,zero,90c962c <icmprcv+0x4a0>
 90c95a8:	e0bffa17 	ldw	r2,-24(fp)
 90c95ac:	10800417 	ldw	r2,16(r2)
 90c95b0:	1004d63a 	srli	r2,r2,24
 90c95b4:	10c03fcc 	andi	r3,r2,255
 90c95b8:	e0bffa17 	ldw	r2,-24(fp)
 90c95bc:	10800417 	ldw	r2,16(r2)
 90c95c0:	1004d23a 	srli	r2,r2,8
 90c95c4:	10bfc00c 	andi	r2,r2,65280
 90c95c8:	1886b03a 	or	r3,r3,r2
 90c95cc:	e0bffa17 	ldw	r2,-24(fp)
 90c95d0:	10800417 	ldw	r2,16(r2)
 90c95d4:	10bfc00c 	andi	r2,r2,65280
 90c95d8:	1004923a 	slli	r2,r2,8
 90c95dc:	1886b03a 	or	r3,r3,r2
 90c95e0:	e0bffa17 	ldw	r2,-24(fp)
 90c95e4:	10800417 	ldw	r2,16(r2)
 90c95e8:	10803fcc 	andi	r2,r2,255
 90c95ec:	1004963a 	slli	r2,r2,24
 90c95f0:	1884b03a 	or	r2,r3,r2
 90c95f4:	10fc002c 	andhi	r3,r2,61440
 90c95f8:	00b80034 	movhi	r2,57344
 90c95fc:	18800b26 	beq	r3,r2,90c962c <icmprcv+0x4a0>
 90c9600:	e0bffa17 	ldw	r2,-24(fp)
 90c9604:	11000417 	ldw	r4,16(r2)
 90c9608:	e0bffd17 	ldw	r2,-12(fp)
 90c960c:	10800617 	ldw	r2,24(r2)
 90c9610:	10c00a17 	ldw	r3,40(r2)
 90c9614:	e0bffd17 	ldw	r2,-12(fp)
 90c9618:	10800617 	ldw	r2,24(r2)
 90c961c:	10800c17 	ldw	r2,48(r2)
 90c9620:	0084303a 	nor	r2,zero,r2
 90c9624:	1884b03a 	or	r2,r3,r2
 90c9628:	2080061e 	bne	r4,r2,90c9644 <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 90c962c:	e0bffd17 	ldw	r2,-12(fp)
 90c9630:	10800617 	ldw	r2,24(r2)
 90c9634:	10c00a17 	ldw	r3,40(r2)
 90c9638:	e0bffa17 	ldw	r2,-24(fp)
 90c963c:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 90c9640:	00000406 	br	90c9654 <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 90c9644:	e0bffa17 	ldw	r2,-24(fp)
 90c9648:	10c00417 	ldw	r3,16(r2)
 90c964c:	e0bffa17 	ldw	r2,-24(fp)
 90c9650:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 90c9654:	e0fffa17 	ldw	r3,-24(fp)
 90c9658:	e0bffb17 	ldw	r2,-20(fp)
 90c965c:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 90c9660:	008243b4 	movhi	r2,2318
 90c9664:	10b68204 	addi	r2,r2,-9720
 90c9668:	10801517 	ldw	r2,84(r2)
 90c966c:	10c00044 	addi	r3,r2,1
 90c9670:	008243b4 	movhi	r2,2318
 90c9674:	10b68204 	addi	r2,r2,-9720
 90c9678:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 90c967c:	008243b4 	movhi	r2,2318
 90c9680:	10b68204 	addi	r2,r2,-9720
 90c9684:	10800d17 	ldw	r2,52(r2)
 90c9688:	10c00044 	addi	r3,r2,1
 90c968c:	008243b4 	movhi	r2,2318
 90c9690:	10b68204 	addi	r2,r2,-9720
 90c9694:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 90c9698:	e0fffd17 	ldw	r3,-12(fp)
 90c969c:	e0bffb17 	ldw	r2,-20(fp)
 90c96a0:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 90c96a4:	e0bffd17 	ldw	r2,-12(fp)
 90c96a8:	10c00317 	ldw	r3,12(r2)
 90c96ac:	e0bffa17 	ldw	r2,-24(fp)
 90c96b0:	10800003 	ldbu	r2,0(r2)
 90c96b4:	10803fcc 	andi	r2,r2,255
 90c96b8:	108003cc 	andi	r2,r2,15
 90c96bc:	1085883a 	add	r2,r2,r2
 90c96c0:	1085883a 	add	r2,r2,r2
 90c96c4:	1887883a 	add	r3,r3,r2
 90c96c8:	e0bffd17 	ldw	r2,-12(fp)
 90c96cc:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 90c96d0:	e0fffd17 	ldw	r3,-12(fp)
 90c96d4:	e0bffc17 	ldw	r2,-16(fp)
 90c96d8:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 90c96dc:	01000044 	movi	r4,1
 90c96e0:	e17ffd17 	ldw	r5,-12(fp)
 90c96e4:	90bd99c0 	call	90bd99c <ip_write>
 90c96e8:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 90c96ec:	e0bff417 	ldw	r2,-48(fp)
 90c96f0:	1004403a 	cmpge	r2,r2,zero
 90c96f4:	1000091e 	bne	r2,zero,90c971c <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 90c96f8:	00824374 	movhi	r2,2317
 90c96fc:	108c1d04 	addi	r2,r2,12404
 90c9700:	10800017 	ldw	r2,0(r2)
 90c9704:	1081000c 	andi	r2,r2,1024
 90c9708:	1005003a 	cmpeq	r2,r2,zero
 90c970c:	1000031e 	bne	r2,zero,90c971c <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 90c9710:	01024374 	movhi	r4,2317
 90c9714:	2102f904 	addi	r4,r4,3044
 90c9718:	90828380 	call	9082838 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 90c971c:	e03fff15 	stw	zero,-4(fp)
 90c9720:	00019f06 	br	90c9da0 <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 90c9724:	008243b4 	movhi	r2,2318
 90c9728:	10b68204 	addi	r2,r2,-9720
 90c972c:	10800817 	ldw	r2,32(r2)
 90c9730:	10c00044 	addi	r3,r2,1
 90c9734:	008243b4 	movhi	r2,2318
 90c9738:	10b68204 	addi	r2,r2,-9720
 90c973c:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 90c9740:	e13ffd17 	ldw	r4,-12(fp)
 90c9744:	90c23e80 	call	90c23e8 <ip_raw_input>
 90c9748:	e0bfff15 	stw	r2,-4(fp)
 90c974c:	00019406 	br	90c9da0 <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 90c9750:	008243b4 	movhi	r2,2318
 90c9754:	10b68204 	addi	r2,r2,-9720
 90c9758:	10800217 	ldw	r2,8(r2)
 90c975c:	10c00044 	addi	r3,r2,1
 90c9760:	008243b4 	movhi	r2,2318
 90c9764:	10b68204 	addi	r2,r2,-9720
 90c9768:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 90c976c:	e0bff917 	ldw	r2,-28(fp)
 90c9770:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9774:	00824374 	movhi	r2,2317
 90c9778:	108c1d04 	addi	r2,r2,12404
 90c977c:	10800017 	ldw	r2,0(r2)
 90c9780:	1081000c 	andi	r2,r2,1024
 90c9784:	1005003a 	cmpeq	r2,r2,zero
 90c9788:	1000291e 	bne	r2,zero,90c9830 <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 90c978c:	01024374 	movhi	r4,2317
 90c9790:	2102fe04 	addi	r4,r4,3064
 90c9794:	90825100 	call	9082510 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 90c9798:	e0bff617 	ldw	r2,-40(fp)
 90c979c:	10800043 	ldbu	r2,1(r2)
 90c97a0:	11403fcc 	andi	r5,r2,255
 90c97a4:	2940201c 	xori	r5,r5,128
 90c97a8:	297fe004 	addi	r5,r5,-128
 90c97ac:	e0bff617 	ldw	r2,-40(fp)
 90c97b0:	10800617 	ldw	r2,24(r2)
 90c97b4:	11803fcc 	andi	r6,r2,255
 90c97b8:	e0bff617 	ldw	r2,-40(fp)
 90c97bc:	10800617 	ldw	r2,24(r2)
 90c97c0:	1004d23a 	srli	r2,r2,8
 90c97c4:	11c03fcc 	andi	r7,r2,255
 90c97c8:	e0bff617 	ldw	r2,-40(fp)
 90c97cc:	10800617 	ldw	r2,24(r2)
 90c97d0:	1004d43a 	srli	r2,r2,16
 90c97d4:	10c03fcc 	andi	r3,r2,255
 90c97d8:	e0bff617 	ldw	r2,-40(fp)
 90c97dc:	10800617 	ldw	r2,24(r2)
 90c97e0:	1004d63a 	srli	r2,r2,24
 90c97e4:	d8c00015 	stw	r3,0(sp)
 90c97e8:	d8800115 	stw	r2,4(sp)
 90c97ec:	01024374 	movhi	r4,2317
 90c97f0:	21030704 	addi	r4,r4,3100
 90c97f4:	90825100 	call	9082510 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90c97f8:	e0bffb17 	ldw	r2,-20(fp)
 90c97fc:	11403fcc 	andi	r5,r2,255
 90c9800:	e0bffb17 	ldw	r2,-20(fp)
 90c9804:	1004d23a 	srli	r2,r2,8
 90c9808:	11803fcc 	andi	r6,r2,255
 90c980c:	e0bffb17 	ldw	r2,-20(fp)
 90c9810:	1004d43a 	srli	r2,r2,16
 90c9814:	11c03fcc 	andi	r7,r2,255
 90c9818:	e0bffb17 	ldw	r2,-20(fp)
 90c981c:	1004d63a 	srli	r2,r2,24
 90c9820:	d8800015 	stw	r2,0(sp)
 90c9824:	01024374 	movhi	r4,2317
 90c9828:	21030c04 	addi	r4,r4,3120
 90c982c:	90825100 	call	9082510 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 90c9830:	e13ffd17 	ldw	r4,-12(fp)
 90c9834:	e17ff617 	ldw	r5,-40(fp)
 90c9838:	90ca4440 	call	90ca444 <icmp_du>
      break;
 90c983c:	00015606 	br	90c9d98 <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 90c9840:	008243b4 	movhi	r2,2318
 90c9844:	10b68204 	addi	r2,r2,-9720
 90c9848:	10800517 	ldw	r2,20(r2)
 90c984c:	10c00044 	addi	r3,r2,1
 90c9850:	008243b4 	movhi	r2,2318
 90c9854:	10b68204 	addi	r2,r2,-9720
 90c9858:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c985c:	00824374 	movhi	r2,2317
 90c9860:	108c1d04 	addi	r2,r2,12404
 90c9864:	10800017 	ldw	r2,0(r2)
 90c9868:	1081000c 	andi	r2,r2,1024
 90c986c:	1005003a 	cmpeq	r2,r2,zero
 90c9870:	1000161e 	bne	r2,zero,90c98cc <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90c9874:	e0bffb17 	ldw	r2,-20(fp)
 90c9878:	11403fcc 	andi	r5,r2,255
 90c987c:	e0bffb17 	ldw	r2,-20(fp)
 90c9880:	1004d23a 	srli	r2,r2,8
 90c9884:	11803fcc 	andi	r6,r2,255
 90c9888:	e0bffb17 	ldw	r2,-20(fp)
 90c988c:	1004d43a 	srli	r2,r2,16
 90c9890:	11c03fcc 	andi	r7,r2,255
 90c9894:	e0bffb17 	ldw	r2,-20(fp)
 90c9898:	1004d63a 	srli	r2,r2,24
 90c989c:	d8800015 	stw	r2,0(sp)
 90c98a0:	01024374 	movhi	r4,2317
 90c98a4:	21031104 	addi	r4,r4,3140
 90c98a8:	90825100 	call	9082510 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90c98ac:	00824374 	movhi	r2,2317
 90c98b0:	108c1d04 	addi	r2,r2,12404
 90c98b4:	10800017 	ldw	r2,0(r2)
 90c98b8:	1080008c 	andi	r2,r2,2
 90c98bc:	1005003a 	cmpeq	r2,r2,zero
 90c98c0:	1000021e 	bne	r2,zero,90c98cc <icmprcv+0x740>
 90c98c4:	e13ffd17 	ldw	r4,-12(fp)
 90c98c8:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c98cc:	01000084 	movi	r4,2
 90c98d0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c98d4:	e13ffd17 	ldw	r4,-12(fp)
 90c98d8:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c98dc:	01000084 	movi	r4,2
 90c98e0:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      break;
 90c98e4:	00012c06 	br	90c9d98 <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 90c98e8:	008243b4 	movhi	r2,2318
 90c98ec:	10b68204 	addi	r2,r2,-9720
 90c98f0:	10800617 	ldw	r2,24(r2)
 90c98f4:	10c00044 	addi	r3,r2,1
 90c98f8:	008243b4 	movhi	r2,2318
 90c98fc:	10b68204 	addi	r2,r2,-9720
 90c9900:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 90c9904:	e0bff917 	ldw	r2,-28(fp)
 90c9908:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c990c:	00824374 	movhi	r2,2317
 90c9910:	108c1d04 	addi	r2,r2,12404
 90c9914:	10800017 	ldw	r2,0(r2)
 90c9918:	1081000c 	andi	r2,r2,1024
 90c991c:	1005003a 	cmpeq	r2,r2,zero
 90c9920:	1000241e 	bne	r2,zero,90c99b4 <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 90c9924:	e0bff717 	ldw	r2,-36(fp)
 90c9928:	10800617 	ldw	r2,24(r2)
 90c992c:	11403fcc 	andi	r5,r2,255
 90c9930:	e0bff717 	ldw	r2,-36(fp)
 90c9934:	10800617 	ldw	r2,24(r2)
 90c9938:	1004d23a 	srli	r2,r2,8
 90c993c:	11803fcc 	andi	r6,r2,255
 90c9940:	e0bff717 	ldw	r2,-36(fp)
 90c9944:	10800617 	ldw	r2,24(r2)
 90c9948:	1004d43a 	srli	r2,r2,16
 90c994c:	11c03fcc 	andi	r7,r2,255
 90c9950:	e0bff717 	ldw	r2,-36(fp)
 90c9954:	10800617 	ldw	r2,24(r2)
 90c9958:	1004d63a 	srli	r2,r2,24
 90c995c:	d8800015 	stw	r2,0(sp)
 90c9960:	01024374 	movhi	r4,2317
 90c9964:	21031b04 	addi	r4,r4,3180
 90c9968:	90825100 	call	9082510 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 90c996c:	e0bff717 	ldw	r2,-36(fp)
 90c9970:	10800117 	ldw	r2,4(r2)
 90c9974:	11403fcc 	andi	r5,r2,255
 90c9978:	e0bff717 	ldw	r2,-36(fp)
 90c997c:	10800117 	ldw	r2,4(r2)
 90c9980:	1004d23a 	srli	r2,r2,8
 90c9984:	11803fcc 	andi	r6,r2,255
 90c9988:	e0bff717 	ldw	r2,-36(fp)
 90c998c:	10800117 	ldw	r2,4(r2)
 90c9990:	1004d43a 	srli	r2,r2,16
 90c9994:	11c03fcc 	andi	r7,r2,255
 90c9998:	e0bff717 	ldw	r2,-36(fp)
 90c999c:	10800117 	ldw	r2,4(r2)
 90c99a0:	1004d63a 	srli	r2,r2,24
 90c99a4:	d8800015 	stw	r2,0(sp)
 90c99a8:	01024374 	movhi	r4,2317
 90c99ac:	21032504 	addi	r4,r4,3220
 90c99b0:	90825100 	call	9082510 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 90c99b4:	e0bff717 	ldw	r2,-36(fp)
 90c99b8:	14000617 	ldw	r16,24(r2)
 90c99bc:	e0bff717 	ldw	r2,-36(fp)
 90c99c0:	14400117 	ldw	r17,4(r2)
 90c99c4:	e0bffd17 	ldw	r2,-12(fp)
 90c99c8:	11000617 	ldw	r4,24(r2)
 90c99cc:	90a21180 	call	90a2118 <if_netnumber>
 90c99d0:	100f883a 	mov	r7,r2
 90c99d4:	00800104 	movi	r2,4
 90c99d8:	d8800015 	stw	r2,0(sp)
 90c99dc:	8009883a 	mov	r4,r16
 90c99e0:	017fffc4 	movi	r5,-1
 90c99e4:	880d883a 	mov	r6,r17
 90c99e8:	90c290c0 	call	90c290c <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c99ec:	01000084 	movi	r4,2
 90c99f0:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c99f4:	e13ffd17 	ldw	r4,-12(fp)
 90c99f8:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c99fc:	01000084 	movi	r4,2
 90c9a00:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      break;
 90c9a04:	0000e406 	br	90c9d98 <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 90c9a08:	008243b4 	movhi	r2,2318
 90c9a0c:	10b68204 	addi	r2,r2,-9720
 90c9a10:	10800317 	ldw	r2,12(r2)
 90c9a14:	10c00044 	addi	r3,r2,1
 90c9a18:	008243b4 	movhi	r2,2318
 90c9a1c:	10b68204 	addi	r2,r2,-9720
 90c9a20:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9a24:	00824374 	movhi	r2,2317
 90c9a28:	108c1d04 	addi	r2,r2,12404
 90c9a2c:	10800017 	ldw	r2,0(r2)
 90c9a30:	1081000c 	andi	r2,r2,1024
 90c9a34:	1005003a 	cmpeq	r2,r2,zero
 90c9a38:	10002e1e 	bne	r2,zero,90c9af4 <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 90c9a3c:	e0bff917 	ldw	r2,-28(fp)
 90c9a40:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 90c9a44:	e0bffd17 	ldw	r2,-12(fp)
 90c9a48:	10800717 	ldw	r2,28(r2)
 90c9a4c:	11403fcc 	andi	r5,r2,255
 90c9a50:	e0bffd17 	ldw	r2,-12(fp)
 90c9a54:	10800717 	ldw	r2,28(r2)
 90c9a58:	1004d23a 	srli	r2,r2,8
 90c9a5c:	11803fcc 	andi	r6,r2,255
 90c9a60:	e0bffd17 	ldw	r2,-12(fp)
 90c9a64:	10800717 	ldw	r2,28(r2)
 90c9a68:	1004d43a 	srli	r2,r2,16
 90c9a6c:	11c03fcc 	andi	r7,r2,255
 90c9a70:	e0bffd17 	ldw	r2,-12(fp)
 90c9a74:	10800717 	ldw	r2,28(r2)
 90c9a78:	1004d63a 	srli	r2,r2,24
 90c9a7c:	d8800015 	stw	r2,0(sp)
 90c9a80:	01024374 	movhi	r4,2317
 90c9a84:	21032904 	addi	r4,r4,3236
 90c9a88:	90825100 	call	9082510 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 90c9a8c:	e0bff317 	ldw	r2,-52(fp)
 90c9a90:	10800617 	ldw	r2,24(r2)
 90c9a94:	11403fcc 	andi	r5,r2,255
 90c9a98:	e0bff317 	ldw	r2,-52(fp)
 90c9a9c:	10800617 	ldw	r2,24(r2)
 90c9aa0:	1004d23a 	srli	r2,r2,8
 90c9aa4:	11803fcc 	andi	r6,r2,255
 90c9aa8:	e0bff317 	ldw	r2,-52(fp)
 90c9aac:	10800617 	ldw	r2,24(r2)
 90c9ab0:	1004d43a 	srli	r2,r2,16
 90c9ab4:	11c03fcc 	andi	r7,r2,255
 90c9ab8:	e0bff317 	ldw	r2,-52(fp)
 90c9abc:	10800617 	ldw	r2,24(r2)
 90c9ac0:	1004d63a 	srli	r2,r2,24
 90c9ac4:	d8800015 	stw	r2,0(sp)
 90c9ac8:	01024374 	movhi	r4,2317
 90c9acc:	21033204 	addi	r4,r4,3272
 90c9ad0:	90825100 	call	9082510 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90c9ad4:	00824374 	movhi	r2,2317
 90c9ad8:	108c1d04 	addi	r2,r2,12404
 90c9adc:	10800017 	ldw	r2,0(r2)
 90c9ae0:	1080008c 	andi	r2,r2,2
 90c9ae4:	1005003a 	cmpeq	r2,r2,zero
 90c9ae8:	1000021e 	bne	r2,zero,90c9af4 <icmprcv+0x968>
 90c9aec:	e13ffd17 	ldw	r4,-12(fp)
 90c9af0:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c9af4:	01000084 	movi	r4,2
 90c9af8:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c9afc:	e13ffd17 	ldw	r4,-12(fp)
 90c9b00:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c9b04:	01000084 	movi	r4,2
 90c9b08:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      break;
 90c9b0c:	0000a206 	br	90c9d98 <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 90c9b10:	008243b4 	movhi	r2,2318
 90c9b14:	10b68204 	addi	r2,r2,-9720
 90c9b18:	10800417 	ldw	r2,16(r2)
 90c9b1c:	10c00044 	addi	r3,r2,1
 90c9b20:	008243b4 	movhi	r2,2318
 90c9b24:	10b68204 	addi	r2,r2,-9720
 90c9b28:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9b2c:	00824374 	movhi	r2,2317
 90c9b30:	108c1d04 	addi	r2,r2,12404
 90c9b34:	10800017 	ldw	r2,0(r2)
 90c9b38:	1081000c 	andi	r2,r2,1024
 90c9b3c:	1005003a 	cmpeq	r2,r2,zero
 90c9b40:	1000031e 	bne	r2,zero,90c9b50 <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 90c9b44:	01024374 	movhi	r4,2317
 90c9b48:	21033704 	addi	r4,r4,3292
 90c9b4c:	90828380 	call	9082838 <puts>
      if (NDEBUG & DUMP)
 90c9b50:	00824374 	movhi	r2,2317
 90c9b54:	108c1d04 	addi	r2,r2,12404
 90c9b58:	10800017 	ldw	r2,0(r2)
 90c9b5c:	1080008c 	andi	r2,r2,2
 90c9b60:	1005003a 	cmpeq	r2,r2,zero
 90c9b64:	1000021e 	bne	r2,zero,90c9b70 <icmprcv+0x9e4>
      {
         ip_dump(p);
 90c9b68:	e13ffd17 	ldw	r4,-12(fp)
 90c9b6c:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c9b70:	01000084 	movi	r4,2
 90c9b74:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c9b78:	e13ffd17 	ldw	r4,-12(fp)
 90c9b7c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c9b80:	01000084 	movi	r4,2
 90c9b84:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      break;
 90c9b88:	00008306 	br	90c9d98 <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 90c9b8c:	008243b4 	movhi	r2,2318
 90c9b90:	10b68204 	addi	r2,r2,-9720
 90c9b94:	10800917 	ldw	r2,36(r2)
 90c9b98:	10c00044 	addi	r3,r2,1
 90c9b9c:	008243b4 	movhi	r2,2318
 90c9ba0:	10b68204 	addi	r2,r2,-9720
 90c9ba4:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9ba8:	00824374 	movhi	r2,2317
 90c9bac:	108c1d04 	addi	r2,r2,12404
 90c9bb0:	10800017 	ldw	r2,0(r2)
 90c9bb4:	1081000c 	andi	r2,r2,1024
 90c9bb8:	1005003a 	cmpeq	r2,r2,zero
 90c9bbc:	1000031e 	bne	r2,zero,90c9bcc <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 90c9bc0:	01024374 	movhi	r4,2317
 90c9bc4:	21033f04 	addi	r4,r4,3324
 90c9bc8:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 90c9bcc:	e0fff917 	ldw	r3,-28(fp)
 90c9bd0:	00800384 	movi	r2,14
 90c9bd4:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 90c9bd8:	e0bff917 	ldw	r2,-28(fp)
 90c9bdc:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 90c9be0:	e13ff917 	ldw	r4,-28(fp)
 90c9be4:	01400284 	movi	r5,10
 90c9be8:	90a3f040 	call	90a3f04 <cksum>
 90c9bec:	0084303a 	nor	r2,zero,r2
 90c9bf0:	1007883a 	mov	r3,r2
 90c9bf4:	e0bff917 	ldw	r2,-28(fp)
 90c9bf8:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 90c9bfc:	e0bffa17 	ldw	r2,-24(fp)
 90c9c00:	10c00417 	ldw	r3,16(r2)
 90c9c04:	e0bffa17 	ldw	r2,-24(fp)
 90c9c08:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 90c9c0c:	e0fffa17 	ldw	r3,-24(fp)
 90c9c10:	e0bffb17 	ldw	r2,-20(fp)
 90c9c14:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 90c9c18:	008243b4 	movhi	r2,2318
 90c9c1c:	10b68204 	addi	r2,r2,-9720
 90c9c20:	10800d17 	ldw	r2,52(r2)
 90c9c24:	10c00044 	addi	r3,r2,1
 90c9c28:	008243b4 	movhi	r2,2318
 90c9c2c:	10b68204 	addi	r2,r2,-9720
 90c9c30:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 90c9c34:	008243b4 	movhi	r2,2318
 90c9c38:	10b68204 	addi	r2,r2,-9720
 90c9c3c:	10801717 	ldw	r2,92(r2)
 90c9c40:	10c00044 	addi	r3,r2,1
 90c9c44:	008243b4 	movhi	r2,2318
 90c9c48:	10b68204 	addi	r2,r2,-9720
 90c9c4c:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 90c9c50:	e0bffd17 	ldw	r2,-12(fp)
 90c9c54:	10c00317 	ldw	r3,12(r2)
 90c9c58:	e0bffa17 	ldw	r2,-24(fp)
 90c9c5c:	10800003 	ldbu	r2,0(r2)
 90c9c60:	10803fcc 	andi	r2,r2,255
 90c9c64:	108003cc 	andi	r2,r2,15
 90c9c68:	1085883a 	add	r2,r2,r2
 90c9c6c:	1085883a 	add	r2,r2,r2
 90c9c70:	1887883a 	add	r3,r3,r2
 90c9c74:	e0bffd17 	ldw	r2,-12(fp)
 90c9c78:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 90c9c7c:	e0fffd17 	ldw	r3,-12(fp)
 90c9c80:	00800504 	movi	r2,20
 90c9c84:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 90c9c88:	e0fffd17 	ldw	r3,-12(fp)
 90c9c8c:	e0bffb17 	ldw	r2,-20(fp)
 90c9c90:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 90c9c94:	01000044 	movi	r4,1
 90c9c98:	e17ffd17 	ldw	r5,-12(fp)
 90c9c9c:	90bd99c0 	call	90bd99c <ip_write>
 90c9ca0:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 90c9ca4:	e0bff417 	ldw	r2,-48(fp)
 90c9ca8:	1004403a 	cmpge	r2,r2,zero
 90c9cac:	1000091e 	bne	r2,zero,90c9cd4 <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 90c9cb0:	00824374 	movhi	r2,2317
 90c9cb4:	108c1d04 	addi	r2,r2,12404
 90c9cb8:	10800017 	ldw	r2,0(r2)
 90c9cbc:	1081000c 	andi	r2,r2,1024
 90c9cc0:	1005003a 	cmpeq	r2,r2,zero
 90c9cc4:	1000031e 	bne	r2,zero,90c9cd4 <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 90c9cc8:	01024374 	movhi	r4,2317
 90c9ccc:	21034604 	addi	r4,r4,3352
 90c9cd0:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 90c9cd4:	e03fff15 	stw	zero,-4(fp)
 90c9cd8:	00003106 	br	90c9da0 <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9cdc:	00824374 	movhi	r2,2317
 90c9ce0:	108c1d04 	addi	r2,r2,12404
 90c9ce4:	10800017 	ldw	r2,0(r2)
 90c9ce8:	1081000c 	andi	r2,r2,1024
 90c9cec:	1005003a 	cmpeq	r2,r2,zero
 90c9cf0:	1000031e 	bne	r2,zero,90c9d00 <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 90c9cf4:	01024374 	movhi	r4,2317
 90c9cf8:	21034f04 	addi	r4,r4,3388
 90c9cfc:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c9d00:	01000084 	movi	r4,2
 90c9d04:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c9d08:	e13ffd17 	ldw	r4,-12(fp)
 90c9d0c:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c9d10:	01000084 	movi	r4,2
 90c9d14:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      break;
 90c9d18:	00001f06 	br	90c9d98 <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90c9d1c:	00824374 	movhi	r2,2317
 90c9d20:	108c1d04 	addi	r2,r2,12404
 90c9d24:	10800017 	ldw	r2,0(r2)
 90c9d28:	1081000c 	andi	r2,r2,1024
 90c9d2c:	1005003a 	cmpeq	r2,r2,zero
 90c9d30:	1000101e 	bne	r2,zero,90c9d74 <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 90c9d34:	e0bff917 	ldw	r2,-28(fp)
 90c9d38:	10800003 	ldbu	r2,0(r2)
 90c9d3c:	11403fcc 	andi	r5,r2,255
 90c9d40:	2940201c 	xori	r5,r5,128
 90c9d44:	297fe004 	addi	r5,r5,-128
 90c9d48:	01024374 	movhi	r4,2317
 90c9d4c:	21035504 	addi	r4,r4,3412
 90c9d50:	90825100 	call	9082510 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90c9d54:	00824374 	movhi	r2,2317
 90c9d58:	108c1d04 	addi	r2,r2,12404
 90c9d5c:	10800017 	ldw	r2,0(r2)
 90c9d60:	1080008c 	andi	r2,r2,2
 90c9d64:	1005003a 	cmpeq	r2,r2,zero
 90c9d68:	1000021e 	bne	r2,zero,90c9d74 <icmprcv+0xbe8>
 90c9d6c:	e13ffd17 	ldw	r4,-12(fp)
 90c9d70:	90bebcc0 	call	90bebcc <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c9d74:	01000084 	movi	r4,2
 90c9d78:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c9d7c:	e13ffd17 	ldw	r4,-12(fp)
 90c9d80:	90a8bd80 	call	90a8bd8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c9d84:	01000084 	movi	r4,2
 90c9d88:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 90c9d8c:	00800084 	movi	r2,2
 90c9d90:	e0bfff15 	stw	r2,-4(fp)
 90c9d94:	00000206 	br	90c9da0 <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 90c9d98:	00c00084 	movi	r3,2
 90c9d9c:	e0ffff15 	stw	r3,-4(fp)
 90c9da0:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 90c9da4:	e037883a 	mov	sp,fp
 90c9da8:	dfc00317 	ldw	ra,12(sp)
 90c9dac:	df000217 	ldw	fp,8(sp)
 90c9db0:	dc400117 	ldw	r17,4(sp)
 90c9db4:	dc000017 	ldw	r16,0(sp)
 90c9db8:	dec00404 	addi	sp,sp,16
 90c9dbc:	f800283a 	ret

090c9dc0 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 90c9dc0:	defff404 	addi	sp,sp,-48
 90c9dc4:	dfc00b15 	stw	ra,44(sp)
 90c9dc8:	df000a15 	stw	fp,40(sp)
 90c9dcc:	df000a04 	addi	fp,sp,40
 90c9dd0:	e13ffc15 	stw	r4,-16(fp)
 90c9dd4:	e17ffd15 	stw	r5,-12(fp)
 90c9dd8:	e1bffe15 	stw	r6,-8(fp)
 90c9ddc:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 90c9de0:	00824374 	movhi	r2,2317
 90c9de4:	108c1d04 	addi	r2,r2,12404
 90c9de8:	10800017 	ldw	r2,0(r2)
 90c9dec:	1080040c 	andi	r2,r2,16
 90c9df0:	1005003a 	cmpeq	r2,r2,zero
 90c9df4:	1000171e 	bne	r2,zero,90c9e54 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 90c9df8:	e0bfff17 	ldw	r2,-4(fp)
 90c9dfc:	10803fcc 	andi	r2,r2,255
 90c9e00:	00c24374 	movhi	r3,2317
 90c9e04:	18cb9404 	addi	r3,r3,11856
 90c9e08:	1085883a 	add	r2,r2,r2
 90c9e0c:	1085883a 	add	r2,r2,r2
 90c9e10:	10c5883a 	add	r2,r2,r3
 90c9e14:	11400017 	ldw	r5,0(r2)
 90c9e18:	e0bffc17 	ldw	r2,-16(fp)
 90c9e1c:	11803fcc 	andi	r6,r2,255
 90c9e20:	e0bffc17 	ldw	r2,-16(fp)
 90c9e24:	1004d23a 	srli	r2,r2,8
 90c9e28:	11c03fcc 	andi	r7,r2,255
 90c9e2c:	e0bffc17 	ldw	r2,-16(fp)
 90c9e30:	1004d43a 	srli	r2,r2,16
 90c9e34:	10c03fcc 	andi	r3,r2,255
 90c9e38:	e0bffc17 	ldw	r2,-16(fp)
 90c9e3c:	1004d63a 	srli	r2,r2,24
 90c9e40:	d8c00015 	stw	r3,0(sp)
 90c9e44:	d8800115 	stw	r2,4(sp)
 90c9e48:	01024374 	movhi	r4,2317
 90c9e4c:	21036f04 	addi	r4,r4,3516
 90c9e50:	90825100 	call	9082510 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c9e54:	01000084 	movi	r4,2
 90c9e58:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 90c9e5c:	01008504 	movi	r4,532
 90c9e60:	90a88440 	call	90a8844 <pk_alloc>
 90c9e64:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c9e68:	01000084 	movi	r4,2
 90c9e6c:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 90c9e70:	e0bffb17 	ldw	r2,-20(fp)
 90c9e74:	1004c03a 	cmpne	r2,r2,zero
 90c9e78:	1000111e 	bne	r2,zero,90c9ec0 <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 90c9e7c:	00824374 	movhi	r2,2317
 90c9e80:	108c1d04 	addi	r2,r2,12404
 90c9e84:	10800017 	ldw	r2,0(r2)
 90c9e88:	1080800c 	andi	r2,r2,512
 90c9e8c:	1005003a 	cmpeq	r2,r2,zero
 90c9e90:	1000031e 	bne	r2,zero,90c9ea0 <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 90c9e94:	01024374 	movhi	r4,2317
 90c9e98:	21037c04 	addi	r4,r4,3568
 90c9e9c:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 90c9ea0:	008243b4 	movhi	r2,2318
 90c9ea4:	10b68204 	addi	r2,r2,-9720
 90c9ea8:	10800e17 	ldw	r2,56(r2)
 90c9eac:	10c00044 	addi	r3,r2,1
 90c9eb0:	008243b4 	movhi	r2,2318
 90c9eb4:	10b68204 	addi	r2,r2,-9720
 90c9eb8:	10c00e15 	stw	r3,56(r2)
      return;
 90c9ebc:	00008f06 	br	90ca0fc <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 90c9ec0:	e0bffb17 	ldw	r2,-20(fp)
 90c9ec4:	10800317 	ldw	r2,12(r2)
 90c9ec8:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 90c9ecc:	e0fff917 	ldw	r3,-28(fp)
 90c9ed0:	e0bffd17 	ldw	r2,-12(fp)
 90c9ed4:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 90c9ed8:	e0fff917 	ldw	r3,-28(fp)
 90c9edc:	e0bffc17 	ldw	r2,-16(fp)
 90c9ee0:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 90c9ee4:	e0bffb17 	ldw	r2,-20(fp)
 90c9ee8:	10800317 	ldw	r2,12(r2)
 90c9eec:	10c00504 	addi	r3,r2,20
 90c9ef0:	e0bffb17 	ldw	r2,-20(fp)
 90c9ef4:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 90c9ef8:	e0bffb17 	ldw	r2,-20(fp)
 90c9efc:	10800417 	ldw	r2,16(r2)
 90c9f00:	10fffb04 	addi	r3,r2,-20
 90c9f04:	e0bffb17 	ldw	r2,-20(fp)
 90c9f08:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 90c9f0c:	e0fffb17 	ldw	r3,-20(fp)
 90c9f10:	e0800217 	ldw	r2,8(fp)
 90c9f14:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 90c9f18:	e0bffb17 	ldw	r2,-20(fp)
 90c9f1c:	10800317 	ldw	r2,12(r2)
 90c9f20:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 90c9f24:	e0bfff17 	ldw	r2,-4(fp)
 90c9f28:	10bfc00c 	andi	r2,r2,65280
 90c9f2c:	1005003a 	cmpeq	r2,r2,zero
 90c9f30:	1000061e 	bne	r2,zero,90c9f4c <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 90c9f34:	e0bfff17 	ldw	r2,-4(fp)
 90c9f38:	1004d23a 	srli	r2,r2,8
 90c9f3c:	1007883a 	mov	r3,r2
 90c9f40:	e0bffa17 	ldw	r2,-24(fp)
 90c9f44:	10c00005 	stb	r3,0(r2)
 90c9f48:	00000306 	br	90c9f58 <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 90c9f4c:	e0fffa17 	ldw	r3,-24(fp)
 90c9f50:	008000c4 	movi	r2,3
 90c9f54:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 90c9f58:	e0bfff17 	ldw	r2,-4(fp)
 90c9f5c:	1007883a 	mov	r3,r2
 90c9f60:	e0bffa17 	ldw	r2,-24(fp)
 90c9f64:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 90c9f68:	e0bffa17 	ldw	r2,-24(fp)
 90c9f6c:	1000018d 	sth	zero,6(r2)
 90c9f70:	e0bffa17 	ldw	r2,-24(fp)
 90c9f74:	10c0018b 	ldhu	r3,6(r2)
 90c9f78:	e0bffa17 	ldw	r2,-24(fp)
 90c9f7c:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 90c9f80:	e0bfff17 	ldw	r2,-4(fp)
 90c9f84:	10803fcc 	andi	r2,r2,255
 90c9f88:	10800118 	cmpnei	r2,r2,4
 90c9f8c:	1000151e 	bne	r2,zero,90c9fe4 <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 90c9f90:	e0800217 	ldw	r2,8(fp)
 90c9f94:	10c00917 	ldw	r3,36(r2)
 90c9f98:	e0800217 	ldw	r2,8(fp)
 90c9f9c:	10800817 	ldw	r2,32(r2)
 90c9fa0:	1885c83a 	sub	r2,r3,r2
 90c9fa4:	1005d23a 	srai	r2,r2,8
 90c9fa8:	10803fcc 	andi	r2,r2,255
 90c9fac:	1009883a 	mov	r4,r2
 90c9fb0:	e0800217 	ldw	r2,8(fp)
 90c9fb4:	10c00917 	ldw	r3,36(r2)
 90c9fb8:	e0800217 	ldw	r2,8(fp)
 90c9fbc:	10800817 	ldw	r2,32(r2)
 90c9fc0:	1885c83a 	sub	r2,r3,r2
 90c9fc4:	1004923a 	slli	r2,r2,8
 90c9fc8:	1007883a 	mov	r3,r2
 90c9fcc:	00bfc004 	movi	r2,-256
 90c9fd0:	1884703a 	and	r2,r3,r2
 90c9fd4:	2084b03a 	or	r2,r4,r2
 90c9fd8:	1007883a 	mov	r3,r2
 90c9fdc:	e0bffa17 	ldw	r2,-24(fp)
 90c9fe0:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 90c9fe4:	e0bffa17 	ldw	r2,-24(fp)
 90c9fe8:	11000204 	addi	r4,r2,8
 90c9fec:	e0fffe17 	ldw	r3,-8(fp)
 90c9ff0:	18800017 	ldw	r2,0(r3)
 90c9ff4:	20800015 	stw	r2,0(r4)
 90c9ff8:	18800117 	ldw	r2,4(r3)
 90c9ffc:	20800115 	stw	r2,4(r4)
 90ca000:	18800217 	ldw	r2,8(r3)
 90ca004:	20800215 	stw	r2,8(r4)
 90ca008:	18800317 	ldw	r2,12(r3)
 90ca00c:	20800315 	stw	r2,12(r4)
 90ca010:	18800417 	ldw	r2,16(r3)
 90ca014:	20800415 	stw	r2,16(r4)
 90ca018:	18800517 	ldw	r2,20(r3)
 90ca01c:	20800515 	stw	r2,20(r4)
 90ca020:	18800617 	ldw	r2,24(r3)
 90ca024:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 90ca028:	e0bffa17 	ldw	r2,-24(fp)
 90ca02c:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 90ca030:	e13ffa17 	ldw	r4,-24(fp)
 90ca034:	01400484 	movi	r5,18
 90ca038:	90a3f040 	call	90a3f04 <cksum>
 90ca03c:	0084303a 	nor	r2,zero,r2
 90ca040:	1007883a 	mov	r3,r2
 90ca044:	e0bffa17 	ldw	r2,-24(fp)
 90ca048:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 90ca04c:	e0fffb17 	ldw	r3,-20(fp)
 90ca050:	00800904 	movi	r2,36
 90ca054:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 90ca058:	e0fffb17 	ldw	r3,-20(fp)
 90ca05c:	e0bffc17 	ldw	r2,-16(fp)
 90ca060:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 90ca064:	01000044 	movi	r4,1
 90ca068:	e17ffb17 	ldw	r5,-20(fp)
 90ca06c:	90bd99c0 	call	90bd99c <ip_write>
 90ca070:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 90ca074:	e0bff817 	ldw	r2,-32(fp)
 90ca078:	1004403a 	cmpge	r2,r2,zero
 90ca07c:	1000111e 	bne	r2,zero,90ca0c4 <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 90ca080:	008243b4 	movhi	r2,2318
 90ca084:	10b68204 	addi	r2,r2,-9720
 90ca088:	10800e17 	ldw	r2,56(r2)
 90ca08c:	10c00044 	addi	r3,r2,1
 90ca090:	008243b4 	movhi	r2,2318
 90ca094:	10b68204 	addi	r2,r2,-9720
 90ca098:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 90ca09c:	00824374 	movhi	r2,2317
 90ca0a0:	108c1d04 	addi	r2,r2,12404
 90ca0a4:	10800017 	ldw	r2,0(r2)
 90ca0a8:	1080860c 	andi	r2,r2,536
 90ca0ac:	1005003a 	cmpeq	r2,r2,zero
 90ca0b0:	1000121e 	bne	r2,zero,90ca0fc <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 90ca0b4:	01024374 	movhi	r4,2317
 90ca0b8:	21038204 	addi	r4,r4,3592
 90ca0bc:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG  */
      return;
 90ca0c0:	00000e06 	br	90ca0fc <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 90ca0c4:	008243b4 	movhi	r2,2318
 90ca0c8:	10b68204 	addi	r2,r2,-9720
 90ca0cc:	10800d17 	ldw	r2,52(r2)
 90ca0d0:	10c00044 	addi	r3,r2,1
 90ca0d4:	008243b4 	movhi	r2,2318
 90ca0d8:	10b68204 	addi	r2,r2,-9720
 90ca0dc:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 90ca0e0:	008243b4 	movhi	r2,2318
 90ca0e4:	10b68204 	addi	r2,r2,-9720
 90ca0e8:	10800f17 	ldw	r2,60(r2)
 90ca0ec:	10c00044 	addi	r3,r2,1
 90ca0f0:	008243b4 	movhi	r2,2318
 90ca0f4:	10b68204 	addi	r2,r2,-9720
 90ca0f8:	10c00f15 	stw	r3,60(r2)
   return;
}
 90ca0fc:	e037883a 	mov	sp,fp
 90ca100:	dfc00117 	ldw	ra,4(sp)
 90ca104:	df000017 	ldw	fp,0(sp)
 90ca108:	dec00204 	addi	sp,sp,8
 90ca10c:	f800283a 	ret

090ca110 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 90ca110:	defff504 	addi	sp,sp,-44
 90ca114:	dfc00a15 	stw	ra,40(sp)
 90ca118:	df000915 	stw	fp,36(sp)
 90ca11c:	df000904 	addi	fp,sp,36
 90ca120:	e13ffe15 	stw	r4,-8(fp)
 90ca124:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 90ca128:	00824374 	movhi	r2,2317
 90ca12c:	108c1d04 	addi	r2,r2,12404
 90ca130:	10800017 	ldw	r2,0(r2)
 90ca134:	1080040c 	andi	r2,r2,16
 90ca138:	1005003a 	cmpeq	r2,r2,zero
 90ca13c:	1000301e 	bne	r2,zero,90ca200 <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 90ca140:	e17fff07 	ldb	r5,-4(fp)
 90ca144:	e0bffe17 	ldw	r2,-8(fp)
 90ca148:	10800317 	ldw	r2,12(r2)
 90ca14c:	1004d23a 	srli	r2,r2,8
 90ca150:	10c03fcc 	andi	r3,r2,255
 90ca154:	e0bffe17 	ldw	r2,-8(fp)
 90ca158:	10800317 	ldw	r2,12(r2)
 90ca15c:	1004923a 	slli	r2,r2,8
 90ca160:	10bfc00c 	andi	r2,r2,65280
 90ca164:	1884b03a 	or	r2,r3,r2
 90ca168:	11803fcc 	andi	r6,r2,255
 90ca16c:	e0bffe17 	ldw	r2,-8(fp)
 90ca170:	10800317 	ldw	r2,12(r2)
 90ca174:	1004d23a 	srli	r2,r2,8
 90ca178:	10c03fcc 	andi	r3,r2,255
 90ca17c:	e0bffe17 	ldw	r2,-8(fp)
 90ca180:	10800317 	ldw	r2,12(r2)
 90ca184:	1004923a 	slli	r2,r2,8
 90ca188:	10bfc00c 	andi	r2,r2,65280
 90ca18c:	1884b03a 	or	r2,r3,r2
 90ca190:	1004d23a 	srli	r2,r2,8
 90ca194:	11c03fcc 	andi	r7,r2,255
 90ca198:	e0bffe17 	ldw	r2,-8(fp)
 90ca19c:	10800317 	ldw	r2,12(r2)
 90ca1a0:	1004d23a 	srli	r2,r2,8
 90ca1a4:	10c03fcc 	andi	r3,r2,255
 90ca1a8:	e0bffe17 	ldw	r2,-8(fp)
 90ca1ac:	10800317 	ldw	r2,12(r2)
 90ca1b0:	1004923a 	slli	r2,r2,8
 90ca1b4:	10bfc00c 	andi	r2,r2,65280
 90ca1b8:	1884b03a 	or	r2,r3,r2
 90ca1bc:	1004d43a 	srli	r2,r2,16
 90ca1c0:	11003fcc 	andi	r4,r2,255
 90ca1c4:	e0bffe17 	ldw	r2,-8(fp)
 90ca1c8:	10800317 	ldw	r2,12(r2)
 90ca1cc:	1004d23a 	srli	r2,r2,8
 90ca1d0:	10c03fcc 	andi	r3,r2,255
 90ca1d4:	e0bffe17 	ldw	r2,-8(fp)
 90ca1d8:	10800317 	ldw	r2,12(r2)
 90ca1dc:	1004923a 	slli	r2,r2,8
 90ca1e0:	10bfc00c 	andi	r2,r2,65280
 90ca1e4:	1884b03a 	or	r2,r3,r2
 90ca1e8:	1004d63a 	srli	r2,r2,24
 90ca1ec:	d9000015 	stw	r4,0(sp)
 90ca1f0:	d8800115 	stw	r2,4(sp)
 90ca1f4:	01024374 	movhi	r4,2317
 90ca1f8:	21038b04 	addi	r4,r4,3628
 90ca1fc:	90825100 	call	9082510 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 90ca200:	e0bffe17 	ldw	r2,-8(fp)
 90ca204:	10800003 	ldbu	r2,0(r2)
 90ca208:	108003cc 	andi	r2,r2,15
 90ca20c:	1085883a 	add	r2,r2,r2
 90ca210:	1085883a 	add	r2,r2,r2
 90ca214:	10800404 	addi	r2,r2,16
 90ca218:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90ca21c:	01000084 	movi	r4,2
 90ca220:	90a97680 	call	90a9768 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 90ca224:	e0fff903 	ldbu	r3,-28(fp)
 90ca228:	00824374 	movhi	r2,2317
 90ca22c:	108c1b04 	addi	r2,r2,12396
 90ca230:	10800017 	ldw	r2,0(r2)
 90ca234:	1885883a 	add	r2,r3,r2
 90ca238:	11000504 	addi	r4,r2,20
 90ca23c:	90a88440 	call	90a8844 <pk_alloc>
 90ca240:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ca244:	01000084 	movi	r4,2
 90ca248:	90a98280 	call	90a9828 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 90ca24c:	e0bffd17 	ldw	r2,-12(fp)
 90ca250:	1004c03a 	cmpne	r2,r2,zero
 90ca254:	1000111e 	bne	r2,zero,90ca29c <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 90ca258:	00824374 	movhi	r2,2317
 90ca25c:	108c1d04 	addi	r2,r2,12404
 90ca260:	10800017 	ldw	r2,0(r2)
 90ca264:	1080800c 	andi	r2,r2,512
 90ca268:	1005003a 	cmpeq	r2,r2,zero
 90ca26c:	1000031e 	bne	r2,zero,90ca27c <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 90ca270:	01024374 	movhi	r4,2317
 90ca274:	21037c04 	addi	r4,r4,3568
 90ca278:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 90ca27c:	008243b4 	movhi	r2,2318
 90ca280:	10b68204 	addi	r2,r2,-9720
 90ca284:	10800e17 	ldw	r2,56(r2)
 90ca288:	10c00044 	addi	r3,r2,1
 90ca28c:	008243b4 	movhi	r2,2318
 90ca290:	10b68204 	addi	r2,r2,-9720
 90ca294:	10c00e15 	stw	r3,56(r2)
      return;
 90ca298:	00006506 	br	90ca430 <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 90ca29c:	e0bffd17 	ldw	r2,-12(fp)
 90ca2a0:	10800317 	ldw	r2,12(r2)
 90ca2a4:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 90ca2a8:	e0bffe17 	ldw	r2,-8(fp)
 90ca2ac:	10c00417 	ldw	r3,16(r2)
 90ca2b0:	e0bffb17 	ldw	r2,-20(fp)
 90ca2b4:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 90ca2b8:	e0bffe17 	ldw	r2,-8(fp)
 90ca2bc:	10c00317 	ldw	r3,12(r2)
 90ca2c0:	e0bffb17 	ldw	r2,-20(fp)
 90ca2c4:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 90ca2c8:	e0bffd17 	ldw	r2,-12(fp)
 90ca2cc:	10800317 	ldw	r2,12(r2)
 90ca2d0:	10c00504 	addi	r3,r2,20
 90ca2d4:	e0bffd17 	ldw	r2,-12(fp)
 90ca2d8:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 90ca2dc:	e0bffd17 	ldw	r2,-12(fp)
 90ca2e0:	10800317 	ldw	r2,12(r2)
 90ca2e4:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 90ca2e8:	e0fffc17 	ldw	r3,-16(fp)
 90ca2ec:	008002c4 	movi	r2,11
 90ca2f0:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 90ca2f4:	e0fffc17 	ldw	r3,-16(fp)
 90ca2f8:	e0bfff03 	ldbu	r2,-4(fp)
 90ca2fc:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 90ca300:	e0bffc17 	ldw	r2,-16(fp)
 90ca304:	1000018d 	sth	zero,6(r2)
 90ca308:	e0bffc17 	ldw	r2,-16(fp)
 90ca30c:	10c0018b 	ldhu	r3,6(r2)
 90ca310:	e0bffc17 	ldw	r2,-16(fp)
 90ca314:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 90ca318:	e0bffc17 	ldw	r2,-16(fp)
 90ca31c:	11000204 	addi	r4,r2,8
 90ca320:	e0bffe17 	ldw	r2,-8(fp)
 90ca324:	10800003 	ldbu	r2,0(r2)
 90ca328:	10803fcc 	andi	r2,r2,255
 90ca32c:	108003cc 	andi	r2,r2,15
 90ca330:	1085883a 	add	r2,r2,r2
 90ca334:	1085883a 	add	r2,r2,r2
 90ca338:	10800204 	addi	r2,r2,8
 90ca33c:	1007883a 	mov	r3,r2
 90ca340:	e0bffe17 	ldw	r2,-8(fp)
 90ca344:	100b883a 	mov	r5,r2
 90ca348:	180d883a 	mov	r6,r3
 90ca34c:	90822780 	call	9082278 <memcpy>

   tx->tchksum = 0;
 90ca350:	e0bffc17 	ldw	r2,-16(fp)
 90ca354:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 90ca358:	e0bff903 	ldbu	r2,-28(fp)
 90ca35c:	1004d07a 	srli	r2,r2,1
 90ca360:	11403fcc 	andi	r5,r2,255
 90ca364:	e13ffc17 	ldw	r4,-16(fp)
 90ca368:	90a3f040 	call	90a3f04 <cksum>
 90ca36c:	0084303a 	nor	r2,zero,r2
 90ca370:	1007883a 	mov	r3,r2
 90ca374:	e0bffc17 	ldw	r2,-16(fp)
 90ca378:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 90ca37c:	e0fff903 	ldbu	r3,-28(fp)
 90ca380:	e0bffd17 	ldw	r2,-12(fp)
 90ca384:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 90ca388:	e0bffb17 	ldw	r2,-20(fp)
 90ca38c:	10c00417 	ldw	r3,16(r2)
 90ca390:	e0bffd17 	ldw	r2,-12(fp)
 90ca394:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 90ca398:	01000044 	movi	r4,1
 90ca39c:	e17ffd17 	ldw	r5,-12(fp)
 90ca3a0:	90bd99c0 	call	90bd99c <ip_write>
 90ca3a4:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 90ca3a8:	e0bffa17 	ldw	r2,-24(fp)
 90ca3ac:	1004403a 	cmpge	r2,r2,zero
 90ca3b0:	1000111e 	bne	r2,zero,90ca3f8 <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 90ca3b4:	008243b4 	movhi	r2,2318
 90ca3b8:	10b68204 	addi	r2,r2,-9720
 90ca3bc:	10800e17 	ldw	r2,56(r2)
 90ca3c0:	10c00044 	addi	r3,r2,1
 90ca3c4:	008243b4 	movhi	r2,2318
 90ca3c8:	10b68204 	addi	r2,r2,-9720
 90ca3cc:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 90ca3d0:	00824374 	movhi	r2,2317
 90ca3d4:	108c1d04 	addi	r2,r2,12404
 90ca3d8:	10800017 	ldw	r2,0(r2)
 90ca3dc:	1080860c 	andi	r2,r2,536
 90ca3e0:	1005003a 	cmpeq	r2,r2,zero
 90ca3e4:	1000121e 	bne	r2,zero,90ca430 <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 90ca3e8:	01024374 	movhi	r4,2317
 90ca3ec:	21039b04 	addi	r4,r4,3692
 90ca3f0:	90828380 	call	9082838 <puts>
#endif   /* NPDEBUG  */
      return;
 90ca3f4:	00000e06 	br	90ca430 <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 90ca3f8:	008243b4 	movhi	r2,2318
 90ca3fc:	10b68204 	addi	r2,r2,-9720
 90ca400:	10800d17 	ldw	r2,52(r2)
 90ca404:	10c00044 	addi	r3,r2,1
 90ca408:	008243b4 	movhi	r2,2318
 90ca40c:	10b68204 	addi	r2,r2,-9720
 90ca410:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 90ca414:	008243b4 	movhi	r2,2318
 90ca418:	10b68204 	addi	r2,r2,-9720
 90ca41c:	10801017 	ldw	r2,64(r2)
 90ca420:	10c00044 	addi	r3,r2,1
 90ca424:	008243b4 	movhi	r2,2318
 90ca428:	10b68204 	addi	r2,r2,-9720
 90ca42c:	10c01015 	stw	r3,64(r2)
   return;
}
 90ca430:	e037883a 	mov	sp,fp
 90ca434:	dfc00117 	ldw	ra,4(sp)
 90ca438:	df000017 	ldw	fp,0(sp)
 90ca43c:	dec00204 	addi	sp,sp,8
 90ca440:	f800283a 	ret

090ca444 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 90ca444:	defffc04 	addi	sp,sp,-16
 90ca448:	dfc00315 	stw	ra,12(sp)
 90ca44c:	df000215 	stw	fp,8(sp)
 90ca450:	df000204 	addi	fp,sp,8
 90ca454:	e13ffe15 	stw	r4,-8(fp)
 90ca458:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 90ca45c:	d0a0dc17 	ldw	r2,-31888(gp)
 90ca460:	1005003a 	cmpeq	r2,r2,zero
 90ca464:	1000041e 	bne	r2,zero,90ca478 <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 90ca468:	d0a0dc17 	ldw	r2,-31888(gp)
 90ca46c:	e13ffe17 	ldw	r4,-8(fp)
 90ca470:	e17fff17 	ldw	r5,-4(fp)
 90ca474:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 90ca478:	e13ffe17 	ldw	r4,-8(fp)
 90ca47c:	e17fff17 	ldw	r5,-4(fp)
 90ca480:	90ab6f80 	call	90ab6f8 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 90ca484:	e037883a 	mov	sp,fp
 90ca488:	dfc00117 	ldw	ra,4(sp)
 90ca48c:	df000017 	ldw	fp,0(sp)
 90ca490:	dec00204 	addi	sp,sp,8
 90ca494:	f800283a 	ret

090ca498 <atexit>:
 90ca498:	200b883a 	mov	r5,r4
 90ca49c:	000d883a 	mov	r6,zero
 90ca4a0:	0009883a 	mov	r4,zero
 90ca4a4:	000f883a 	mov	r7,zero
 90ca4a8:	90caafc1 	jmpi	90caafc <__register_exitproc>

090ca4ac <_atoi_r>:
 90ca4ac:	000d883a 	mov	r6,zero
 90ca4b0:	01c00284 	movi	r7,10
 90ca4b4:	90ca7ec1 	jmpi	90ca7ec <_strtol_r>

090ca4b8 <atoi>:
 90ca4b8:	000b883a 	mov	r5,zero
 90ca4bc:	01800284 	movi	r6,10
 90ca4c0:	90caa301 	jmpi	90caa30 <strtol>

090ca4c4 <calloc>:
 90ca4c4:	01824374 	movhi	r6,2317
 90ca4c8:	318b9b04 	addi	r6,r6,11884
 90ca4cc:	2007883a 	mov	r3,r4
 90ca4d0:	31000017 	ldw	r4,0(r6)
 90ca4d4:	280d883a 	mov	r6,r5
 90ca4d8:	180b883a 	mov	r5,r3
 90ca4dc:	908a1081 	jmpi	908a108 <_calloc_r>

090ca4e0 <exit>:
 90ca4e0:	defffe04 	addi	sp,sp,-8
 90ca4e4:	000b883a 	mov	r5,zero
 90ca4e8:	dc000015 	stw	r16,0(sp)
 90ca4ec:	dfc00115 	stw	ra,4(sp)
 90ca4f0:	2021883a 	mov	r16,r4
 90ca4f4:	90cac340 	call	90cac34 <__call_exitprocs>
 90ca4f8:	00824374 	movhi	r2,2317
 90ca4fc:	108b9c04 	addi	r2,r2,11888
 90ca500:	11000017 	ldw	r4,0(r2)
 90ca504:	20800f17 	ldw	r2,60(r4)
 90ca508:	10000126 	beq	r2,zero,90ca510 <exit+0x30>
 90ca50c:	103ee83a 	callr	r2
 90ca510:	8009883a 	mov	r4,r16
 90ca514:	90caec80 	call	90caec8 <_exit>

090ca518 <free>:
 90ca518:	00824374 	movhi	r2,2317
 90ca51c:	108b9b04 	addi	r2,r2,11884
 90ca520:	200b883a 	mov	r5,r4
 90ca524:	11000017 	ldw	r4,0(r2)
 90ca528:	90872341 	jmpi	9087234 <_free_r>

090ca52c <malloc>:
 90ca52c:	00824374 	movhi	r2,2317
 90ca530:	108b9b04 	addi	r2,r2,11884
 90ca534:	200b883a 	mov	r5,r4
 90ca538:	11000017 	ldw	r4,0(r2)
 90ca53c:	9087dbc1 	jmpi	9087dbc <_malloc_r>

090ca540 <memcmp>:
 90ca540:	00c000c4 	movi	r3,3
 90ca544:	1980032e 	bgeu	r3,r6,90ca554 <memcmp+0x14>
 90ca548:	2144b03a 	or	r2,r4,r5
 90ca54c:	10c4703a 	and	r2,r2,r3
 90ca550:	10000f26 	beq	r2,zero,90ca590 <memcmp+0x50>
 90ca554:	31ffffc4 	addi	r7,r6,-1
 90ca558:	3000061e 	bne	r6,zero,90ca574 <memcmp+0x34>
 90ca55c:	00000a06 	br	90ca588 <memcmp+0x48>
 90ca560:	39ffffc4 	addi	r7,r7,-1
 90ca564:	00bfffc4 	movi	r2,-1
 90ca568:	21000044 	addi	r4,r4,1
 90ca56c:	29400044 	addi	r5,r5,1
 90ca570:	38800526 	beq	r7,r2,90ca588 <memcmp+0x48>
 90ca574:	20c00003 	ldbu	r3,0(r4)
 90ca578:	28800003 	ldbu	r2,0(r5)
 90ca57c:	18bff826 	beq	r3,r2,90ca560 <memcmp+0x20>
 90ca580:	1885c83a 	sub	r2,r3,r2
 90ca584:	f800283a 	ret
 90ca588:	0005883a 	mov	r2,zero
 90ca58c:	f800283a 	ret
 90ca590:	180f883a 	mov	r7,r3
 90ca594:	20c00017 	ldw	r3,0(r4)
 90ca598:	28800017 	ldw	r2,0(r5)
 90ca59c:	18bfed1e 	bne	r3,r2,90ca554 <memcmp+0x14>
 90ca5a0:	31bfff04 	addi	r6,r6,-4
 90ca5a4:	21000104 	addi	r4,r4,4
 90ca5a8:	29400104 	addi	r5,r5,4
 90ca5ac:	39bff936 	bltu	r7,r6,90ca594 <memcmp+0x54>
 90ca5b0:	003fe806 	br	90ca554 <memcmp+0x14>

090ca5b4 <strcpy>:
 90ca5b4:	2904b03a 	or	r2,r5,r4
 90ca5b8:	108000cc 	andi	r2,r2,3
 90ca5bc:	10000826 	beq	r2,zero,90ca5e0 <strcpy+0x2c>
 90ca5c0:	2007883a 	mov	r3,r4
 90ca5c4:	28800003 	ldbu	r2,0(r5)
 90ca5c8:	29400044 	addi	r5,r5,1
 90ca5cc:	18800005 	stb	r2,0(r3)
 90ca5d0:	18c00044 	addi	r3,r3,1
 90ca5d4:	103ffb1e 	bne	r2,zero,90ca5c4 <strcpy+0x10>
 90ca5d8:	2005883a 	mov	r2,r4
 90ca5dc:	f800283a 	ret
 90ca5e0:	29800017 	ldw	r6,0(r5)
 90ca5e4:	023fbff4 	movhi	r8,65279
 90ca5e8:	423fbfc4 	addi	r8,r8,-257
 90ca5ec:	02a02074 	movhi	r10,32897
 90ca5f0:	52a02004 	addi	r10,r10,-32640
 90ca5f4:	3205883a 	add	r2,r6,r8
 90ca5f8:	0186303a 	nor	r3,zero,r6
 90ca5fc:	10c4703a 	and	r2,r2,r3
 90ca600:	1284703a 	and	r2,r2,r10
 90ca604:	200f883a 	mov	r7,r4
 90ca608:	10000b1e 	bne	r2,zero,90ca638 <strcpy+0x84>
 90ca60c:	4013883a 	mov	r9,r8
 90ca610:	5011883a 	mov	r8,r10
 90ca614:	39800015 	stw	r6,0(r7)
 90ca618:	29400104 	addi	r5,r5,4
 90ca61c:	29800017 	ldw	r6,0(r5)
 90ca620:	39c00104 	addi	r7,r7,4
 90ca624:	3245883a 	add	r2,r6,r9
 90ca628:	0186303a 	nor	r3,zero,r6
 90ca62c:	10c4703a 	and	r2,r2,r3
 90ca630:	1204703a 	and	r2,r2,r8
 90ca634:	103ff726 	beq	r2,zero,90ca614 <strcpy+0x60>
 90ca638:	3807883a 	mov	r3,r7
 90ca63c:	003fe106 	br	90ca5c4 <strcpy+0x10>

090ca640 <strncmp>:
 90ca640:	30003926 	beq	r6,zero,90ca728 <strncmp+0xe8>
 90ca644:	2144b03a 	or	r2,r4,r5
 90ca648:	108000cc 	andi	r2,r2,3
 90ca64c:	028000c4 	movi	r10,3
 90ca650:	1000241e 	bne	r2,zero,90ca6e4 <strncmp+0xa4>
 90ca654:	2011883a 	mov	r8,r4
 90ca658:	280f883a 	mov	r7,r5
 90ca65c:	51801f2e 	bgeu	r10,r6,90ca6dc <strncmp+0x9c>
 90ca660:	21000017 	ldw	r4,0(r4)
 90ca664:	28800017 	ldw	r2,0(r5)
 90ca668:	20801c1e 	bne	r4,r2,90ca6dc <strncmp+0x9c>
 90ca66c:	31bfff04 	addi	r6,r6,-4
 90ca670:	30002d26 	beq	r6,zero,90ca728 <strncmp+0xe8>
 90ca674:	027fbff4 	movhi	r9,65279
 90ca678:	4a7fbfc4 	addi	r9,r9,-257
 90ca67c:	2247883a 	add	r3,r4,r9
 90ca680:	01602074 	movhi	r5,32897
 90ca684:	29602004 	addi	r5,r5,-32640
 90ca688:	1946703a 	and	r3,r3,r5
 90ca68c:	0104303a 	nor	r2,zero,r4
 90ca690:	10c4703a 	and	r2,r2,r3
 90ca694:	1000241e 	bne	r2,zero,90ca728 <strncmp+0xe8>
 90ca698:	5017883a 	mov	r11,r10
 90ca69c:	4815883a 	mov	r10,r9
 90ca6a0:	2813883a 	mov	r9,r5
 90ca6a4:	00000a06 	br	90ca6d0 <strncmp+0x90>
 90ca6a8:	41000017 	ldw	r4,0(r8)
 90ca6ac:	39400017 	ldw	r5,0(r7)
 90ca6b0:	2285883a 	add	r2,r4,r10
 90ca6b4:	1244703a 	and	r2,r2,r9
 90ca6b8:	0106303a 	nor	r3,zero,r4
 90ca6bc:	1886703a 	and	r3,r3,r2
 90ca6c0:	2140061e 	bne	r4,r5,90ca6dc <strncmp+0x9c>
 90ca6c4:	31bfff04 	addi	r6,r6,-4
 90ca6c8:	30001726 	beq	r6,zero,90ca728 <strncmp+0xe8>
 90ca6cc:	1800161e 	bne	r3,zero,90ca728 <strncmp+0xe8>
 90ca6d0:	42000104 	addi	r8,r8,4
 90ca6d4:	39c00104 	addi	r7,r7,4
 90ca6d8:	59bff336 	bltu	r11,r6,90ca6a8 <strncmp+0x68>
 90ca6dc:	4009883a 	mov	r4,r8
 90ca6e0:	380b883a 	mov	r5,r7
 90ca6e4:	31bfffc4 	addi	r6,r6,-1
 90ca6e8:	01ffffc4 	movi	r7,-1
 90ca6ec:	31c00a1e 	bne	r6,r7,90ca718 <strncmp+0xd8>
 90ca6f0:	20c00003 	ldbu	r3,0(r4)
 90ca6f4:	28800003 	ldbu	r2,0(r5)
 90ca6f8:	1885c83a 	sub	r2,r3,r2
 90ca6fc:	f800283a 	ret
 90ca700:	30000926 	beq	r6,zero,90ca728 <strncmp+0xe8>
 90ca704:	18000826 	beq	r3,zero,90ca728 <strncmp+0xe8>
 90ca708:	31bfffc4 	addi	r6,r6,-1
 90ca70c:	21000044 	addi	r4,r4,1
 90ca710:	29400044 	addi	r5,r5,1
 90ca714:	31fff626 	beq	r6,r7,90ca6f0 <strncmp+0xb0>
 90ca718:	20c00007 	ldb	r3,0(r4)
 90ca71c:	28800007 	ldb	r2,0(r5)
 90ca720:	18bff726 	beq	r3,r2,90ca700 <strncmp+0xc0>
 90ca724:	003ff206 	br	90ca6f0 <strncmp+0xb0>
 90ca728:	0005883a 	mov	r2,zero
 90ca72c:	f800283a 	ret

090ca730 <strncpy>:
 90ca730:	2904b03a 	or	r2,r5,r4
 90ca734:	108000cc 	andi	r2,r2,3
 90ca738:	00c000c4 	movi	r3,3
 90ca73c:	1000291e 	bne	r2,zero,90ca7e4 <strncpy+0xb4>
 90ca740:	1980282e 	bgeu	r3,r6,90ca7e4 <strncpy+0xb4>
 90ca744:	1817883a 	mov	r11,r3
 90ca748:	2011883a 	mov	r8,r4
 90ca74c:	02bfbff4 	movhi	r10,65279
 90ca750:	52bfbfc4 	addi	r10,r10,-257
 90ca754:	02602074 	movhi	r9,32897
 90ca758:	4a602004 	addi	r9,r9,-32640
 90ca75c:	29c00017 	ldw	r7,0(r5)
 90ca760:	3a85883a 	add	r2,r7,r10
 90ca764:	01c6303a 	nor	r3,zero,r7
 90ca768:	10c4703a 	and	r2,r2,r3
 90ca76c:	1244703a 	and	r2,r2,r9
 90ca770:	1000051e 	bne	r2,zero,90ca788 <strncpy+0x58>
 90ca774:	31bfff04 	addi	r6,r6,-4
 90ca778:	41c00015 	stw	r7,0(r8)
 90ca77c:	29400104 	addi	r5,r5,4
 90ca780:	42000104 	addi	r8,r8,4
 90ca784:	59bff536 	bltu	r11,r6,90ca75c <strncpy+0x2c>
 90ca788:	400f883a 	mov	r7,r8
 90ca78c:	30001326 	beq	r6,zero,90ca7dc <strncpy+0xac>
 90ca790:	28800003 	ldbu	r2,0(r5)
 90ca794:	31bfffc4 	addi	r6,r6,-1
 90ca798:	38c00044 	addi	r3,r7,1
 90ca79c:	38800005 	stb	r2,0(r7)
 90ca7a0:	10000826 	beq	r2,zero,90ca7c4 <strncpy+0x94>
 90ca7a4:	29400044 	addi	r5,r5,1
 90ca7a8:	30000c26 	beq	r6,zero,90ca7dc <strncpy+0xac>
 90ca7ac:	28800003 	ldbu	r2,0(r5)
 90ca7b0:	31bfffc4 	addi	r6,r6,-1
 90ca7b4:	29400044 	addi	r5,r5,1
 90ca7b8:	18800005 	stb	r2,0(r3)
 90ca7bc:	18c00044 	addi	r3,r3,1
 90ca7c0:	103ff91e 	bne	r2,zero,90ca7a8 <strncpy+0x78>
 90ca7c4:	30000526 	beq	r6,zero,90ca7dc <strncpy+0xac>
 90ca7c8:	1805883a 	mov	r2,r3
 90ca7cc:	30cd883a 	add	r6,r6,r3
 90ca7d0:	10000005 	stb	zero,0(r2)
 90ca7d4:	10800044 	addi	r2,r2,1
 90ca7d8:	30bffd1e 	bne	r6,r2,90ca7d0 <strncpy+0xa0>
 90ca7dc:	2005883a 	mov	r2,r4
 90ca7e0:	f800283a 	ret
 90ca7e4:	200f883a 	mov	r7,r4
 90ca7e8:	003fe806 	br	90ca78c <strncpy+0x5c>

090ca7ec <_strtol_r>:
 90ca7ec:	defff304 	addi	sp,sp,-52
 90ca7f0:	00824374 	movhi	r2,2317
 90ca7f4:	108b9a04 	addi	r2,r2,11880
 90ca7f8:	dcc00615 	stw	r19,24(sp)
 90ca7fc:	14c00017 	ldw	r19,0(r2)
 90ca800:	ddc00a15 	stw	r23,40(sp)
 90ca804:	dc000315 	stw	r16,12(sp)
 90ca808:	dfc00c15 	stw	ra,48(sp)
 90ca80c:	df000b15 	stw	fp,44(sp)
 90ca810:	dd800915 	stw	r22,36(sp)
 90ca814:	dd400815 	stw	r21,32(sp)
 90ca818:	dd000715 	stw	r20,28(sp)
 90ca81c:	dc800515 	stw	r18,20(sp)
 90ca820:	dc400415 	stw	r17,16(sp)
 90ca824:	282f883a 	mov	r23,r5
 90ca828:	d9000015 	stw	r4,0(sp)
 90ca82c:	d9800115 	stw	r6,4(sp)
 90ca830:	2821883a 	mov	r16,r5
 90ca834:	84400007 	ldb	r17,0(r16)
 90ca838:	84000044 	addi	r16,r16,1
 90ca83c:	9c47883a 	add	r3,r19,r17
 90ca840:	18800003 	ldbu	r2,0(r3)
 90ca844:	1080020c 	andi	r2,r2,8
 90ca848:	103ffa1e 	bne	r2,zero,90ca834 <_strtol_r+0x48>
 90ca84c:	00800b44 	movi	r2,45
 90ca850:	88805c26 	beq	r17,r2,90ca9c4 <_strtol_r+0x1d8>
 90ca854:	00800ac4 	movi	r2,43
 90ca858:	88805726 	beq	r17,r2,90ca9b8 <_strtol_r+0x1cc>
 90ca85c:	0039883a 	mov	fp,zero
 90ca860:	3807003a 	cmpeq	r3,r7,zero
 90ca864:	1800431e 	bne	r3,zero,90ca974 <_strtol_r+0x188>
 90ca868:	00800404 	movi	r2,16
 90ca86c:	38804126 	beq	r7,r2,90ca974 <_strtol_r+0x188>
 90ca870:	3829883a 	mov	r20,r7
 90ca874:	e02cc03a 	cmpne	r22,fp,zero
 90ca878:	b0004b1e 	bne	r22,zero,90ca9a8 <_strtol_r+0x1bc>
 90ca87c:	04a00034 	movhi	r18,32768
 90ca880:	94bfffc4 	addi	r18,r18,-1
 90ca884:	9009883a 	mov	r4,r18
 90ca888:	a00b883a 	mov	r5,r20
 90ca88c:	d9c00215 	stw	r7,8(sp)
 90ca890:	908c3100 	call	908c310 <__umodsi3>
 90ca894:	9009883a 	mov	r4,r18
 90ca898:	a00b883a 	mov	r5,r20
 90ca89c:	102b883a 	mov	r21,r2
 90ca8a0:	908c3080 	call	908c308 <__udivsi3>
 90ca8a4:	1011883a 	mov	r8,r2
 90ca8a8:	9c45883a 	add	r2,r19,r17
 90ca8ac:	11000003 	ldbu	r4,0(r2)
 90ca8b0:	000b883a 	mov	r5,zero
 90ca8b4:	000d883a 	mov	r6,zero
 90ca8b8:	20c0010c 	andi	r3,r4,4
 90ca8bc:	d9c00217 	ldw	r7,8(sp)
 90ca8c0:	18000e26 	beq	r3,zero,90ca8fc <_strtol_r+0x110>
 90ca8c4:	88fff404 	addi	r3,r17,-48
 90ca8c8:	19c0140e 	bge	r3,r7,90ca91c <_strtol_r+0x130>
 90ca8cc:	30003116 	blt	r6,zero,90ca994 <_strtol_r+0x1a8>
 90ca8d0:	41403036 	bltu	r8,r5,90ca994 <_strtol_r+0x1a8>
 90ca8d4:	2a002e26 	beq	r5,r8,90ca990 <_strtol_r+0x1a4>
 90ca8d8:	2d05383a 	mul	r2,r5,r20
 90ca8dc:	01800044 	movi	r6,1
 90ca8e0:	10cb883a 	add	r5,r2,r3
 90ca8e4:	84400007 	ldb	r17,0(r16)
 90ca8e8:	84000044 	addi	r16,r16,1
 90ca8ec:	9c45883a 	add	r2,r19,r17
 90ca8f0:	11000003 	ldbu	r4,0(r2)
 90ca8f4:	20c0010c 	andi	r3,r4,4
 90ca8f8:	183ff21e 	bne	r3,zero,90ca8c4 <_strtol_r+0xd8>
 90ca8fc:	208000cc 	andi	r2,r4,3
 90ca900:	10000626 	beq	r2,zero,90ca91c <_strtol_r+0x130>
 90ca904:	2080004c 	andi	r2,r4,1
 90ca908:	1005003a 	cmpeq	r2,r2,zero
 90ca90c:	1000231e 	bne	r2,zero,90ca99c <_strtol_r+0x1b0>
 90ca910:	00800dc4 	movi	r2,55
 90ca914:	8887c83a 	sub	r3,r17,r2
 90ca918:	19ffec16 	blt	r3,r7,90ca8cc <_strtol_r+0xe0>
 90ca91c:	30002d16 	blt	r6,zero,90ca9d4 <_strtol_r+0x1e8>
 90ca920:	b000231e 	bne	r22,zero,90ca9b0 <_strtol_r+0x1c4>
 90ca924:	2807883a 	mov	r3,r5
 90ca928:	d8800117 	ldw	r2,4(sp)
 90ca92c:	10000426 	beq	r2,zero,90ca940 <_strtol_r+0x154>
 90ca930:	30000126 	beq	r6,zero,90ca938 <_strtol_r+0x14c>
 90ca934:	85ffffc4 	addi	r23,r16,-1
 90ca938:	d9000117 	ldw	r4,4(sp)
 90ca93c:	25c00015 	stw	r23,0(r4)
 90ca940:	1805883a 	mov	r2,r3
 90ca944:	dfc00c17 	ldw	ra,48(sp)
 90ca948:	df000b17 	ldw	fp,44(sp)
 90ca94c:	ddc00a17 	ldw	r23,40(sp)
 90ca950:	dd800917 	ldw	r22,36(sp)
 90ca954:	dd400817 	ldw	r21,32(sp)
 90ca958:	dd000717 	ldw	r20,28(sp)
 90ca95c:	dcc00617 	ldw	r19,24(sp)
 90ca960:	dc800517 	ldw	r18,20(sp)
 90ca964:	dc400417 	ldw	r17,16(sp)
 90ca968:	dc000317 	ldw	r16,12(sp)
 90ca96c:	dec00d04 	addi	sp,sp,52
 90ca970:	f800283a 	ret
 90ca974:	00800c04 	movi	r2,48
 90ca978:	88801d26 	beq	r17,r2,90ca9f0 <_strtol_r+0x204>
 90ca97c:	183fbc26 	beq	r3,zero,90ca870 <_strtol_r+0x84>
 90ca980:	00800c04 	movi	r2,48
 90ca984:	88802726 	beq	r17,r2,90caa24 <_strtol_r+0x238>
 90ca988:	01c00284 	movi	r7,10
 90ca98c:	003fb806 	br	90ca870 <_strtol_r+0x84>
 90ca990:	a8ffd10e 	bge	r21,r3,90ca8d8 <_strtol_r+0xec>
 90ca994:	01bfffc4 	movi	r6,-1
 90ca998:	003fd206 	br	90ca8e4 <_strtol_r+0xf8>
 90ca99c:	008015c4 	movi	r2,87
 90ca9a0:	8887c83a 	sub	r3,r17,r2
 90ca9a4:	003fdc06 	br	90ca918 <_strtol_r+0x12c>
 90ca9a8:	04a00034 	movhi	r18,32768
 90ca9ac:	003fb506 	br	90ca884 <_strtol_r+0x98>
 90ca9b0:	0147c83a 	sub	r3,zero,r5
 90ca9b4:	003fdc06 	br	90ca928 <_strtol_r+0x13c>
 90ca9b8:	84400007 	ldb	r17,0(r16)
 90ca9bc:	84000044 	addi	r16,r16,1
 90ca9c0:	003fa606 	br	90ca85c <_strtol_r+0x70>
 90ca9c4:	84400007 	ldb	r17,0(r16)
 90ca9c8:	07000044 	movi	fp,1
 90ca9cc:	84000044 	addi	r16,r16,1
 90ca9d0:	003fa306 	br	90ca860 <_strtol_r+0x74>
 90ca9d4:	e005003a 	cmpeq	r2,fp,zero
 90ca9d8:	10000f1e 	bne	r2,zero,90caa18 <_strtol_r+0x22c>
 90ca9dc:	00e00034 	movhi	r3,32768
 90ca9e0:	d9000017 	ldw	r4,0(sp)
 90ca9e4:	00800884 	movi	r2,34
 90ca9e8:	20800015 	stw	r2,0(r4)
 90ca9ec:	003fce06 	br	90ca928 <_strtol_r+0x13c>
 90ca9f0:	81000007 	ldb	r4,0(r16)
 90ca9f4:	00801e04 	movi	r2,120
 90ca9f8:	20800226 	beq	r4,r2,90caa04 <_strtol_r+0x218>
 90ca9fc:	00801604 	movi	r2,88
 90caa00:	20bfde1e 	bne	r4,r2,90ca97c <_strtol_r+0x190>
 90caa04:	84400047 	ldb	r17,1(r16)
 90caa08:	01c00404 	movi	r7,16
 90caa0c:	84000084 	addi	r16,r16,2
 90caa10:	3829883a 	mov	r20,r7
 90caa14:	003f9706 	br	90ca874 <_strtol_r+0x88>
 90caa18:	00e00034 	movhi	r3,32768
 90caa1c:	18ffffc4 	addi	r3,r3,-1
 90caa20:	003fef06 	br	90ca9e0 <_strtol_r+0x1f4>
 90caa24:	01c00204 	movi	r7,8
 90caa28:	3829883a 	mov	r20,r7
 90caa2c:	003f9106 	br	90ca874 <_strtol_r+0x88>

090caa30 <strtol>:
 90caa30:	00824374 	movhi	r2,2317
 90caa34:	108b9b04 	addi	r2,r2,11884
 90caa38:	2013883a 	mov	r9,r4
 90caa3c:	11000017 	ldw	r4,0(r2)
 90caa40:	2805883a 	mov	r2,r5
 90caa44:	300f883a 	mov	r7,r6
 90caa48:	480b883a 	mov	r5,r9
 90caa4c:	100d883a 	mov	r6,r2
 90caa50:	90ca7ec1 	jmpi	90ca7ec <_strtol_r>

090caa54 <_vprintf_r>:
 90caa54:	2807883a 	mov	r3,r5
 90caa58:	21400217 	ldw	r5,8(r4)
 90caa5c:	300f883a 	mov	r7,r6
 90caa60:	180d883a 	mov	r6,r3
 90caa64:	90831a81 	jmpi	90831a8 <___vfprintf_internal_r>

090caa68 <vprintf>:
 90caa68:	00824374 	movhi	r2,2317
 90caa6c:	108b9b04 	addi	r2,r2,11884
 90caa70:	12000017 	ldw	r8,0(r2)
 90caa74:	280f883a 	mov	r7,r5
 90caa78:	200d883a 	mov	r6,r4
 90caa7c:	41400217 	ldw	r5,8(r8)
 90caa80:	4009883a 	mov	r4,r8
 90caa84:	90831a81 	jmpi	90831a8 <___vfprintf_internal_r>

090caa88 <_vsprintf_r>:
 90caa88:	deffe804 	addi	sp,sp,-96
 90caa8c:	00808204 	movi	r2,520
 90caa90:	2811883a 	mov	r8,r5
 90caa94:	02600034 	movhi	r9,32768
 90caa98:	4a7fffc4 	addi	r9,r9,-1
 90caa9c:	d880030d 	sth	r2,12(sp)
 90caaa0:	d80b883a 	mov	r5,sp
 90caaa4:	00bfffc4 	movi	r2,-1
 90caaa8:	dfc01715 	stw	ra,92(sp)
 90caaac:	da000415 	stw	r8,16(sp)
 90caab0:	da400515 	stw	r9,20(sp)
 90caab4:	d880038d 	sth	r2,14(sp)
 90caab8:	da000015 	stw	r8,0(sp)
 90caabc:	da400215 	stw	r9,8(sp)
 90caac0:	90831a80 	call	90831a8 <___vfprintf_internal_r>
 90caac4:	d8c00017 	ldw	r3,0(sp)
 90caac8:	18000005 	stb	zero,0(r3)
 90caacc:	dfc01717 	ldw	ra,92(sp)
 90caad0:	dec01804 	addi	sp,sp,96
 90caad4:	f800283a 	ret

090caad8 <vsprintf>:
 90caad8:	00824374 	movhi	r2,2317
 90caadc:	108b9b04 	addi	r2,r2,11884
 90caae0:	2013883a 	mov	r9,r4
 90caae4:	11000017 	ldw	r4,0(r2)
 90caae8:	2805883a 	mov	r2,r5
 90caaec:	300f883a 	mov	r7,r6
 90caaf0:	480b883a 	mov	r5,r9
 90caaf4:	100d883a 	mov	r6,r2
 90caaf8:	90caa881 	jmpi	90caa88 <_vsprintf_r>

090caafc <__register_exitproc>:
 90caafc:	defffa04 	addi	sp,sp,-24
 90cab00:	00824374 	movhi	r2,2317
 90cab04:	108b9c04 	addi	r2,r2,11888
 90cab08:	dc000015 	stw	r16,0(sp)
 90cab0c:	14000017 	ldw	r16,0(r2)
 90cab10:	dd000415 	stw	r20,16(sp)
 90cab14:	2829883a 	mov	r20,r5
 90cab18:	81405217 	ldw	r5,328(r16)
 90cab1c:	dcc00315 	stw	r19,12(sp)
 90cab20:	dc800215 	stw	r18,8(sp)
 90cab24:	dc400115 	stw	r17,4(sp)
 90cab28:	dfc00515 	stw	ra,20(sp)
 90cab2c:	2023883a 	mov	r17,r4
 90cab30:	3027883a 	mov	r19,r6
 90cab34:	3825883a 	mov	r18,r7
 90cab38:	28002526 	beq	r5,zero,90cabd0 <__register_exitproc+0xd4>
 90cab3c:	29000117 	ldw	r4,4(r5)
 90cab40:	008007c4 	movi	r2,31
 90cab44:	11002716 	blt	r2,r4,90cabe4 <__register_exitproc+0xe8>
 90cab48:	8800101e 	bne	r17,zero,90cab8c <__register_exitproc+0x90>
 90cab4c:	2105883a 	add	r2,r4,r4
 90cab50:	1085883a 	add	r2,r2,r2
 90cab54:	20c00044 	addi	r3,r4,1
 90cab58:	1145883a 	add	r2,r2,r5
 90cab5c:	0009883a 	mov	r4,zero
 90cab60:	15000215 	stw	r20,8(r2)
 90cab64:	28c00115 	stw	r3,4(r5)
 90cab68:	2005883a 	mov	r2,r4
 90cab6c:	dfc00517 	ldw	ra,20(sp)
 90cab70:	dd000417 	ldw	r20,16(sp)
 90cab74:	dcc00317 	ldw	r19,12(sp)
 90cab78:	dc800217 	ldw	r18,8(sp)
 90cab7c:	dc400117 	ldw	r17,4(sp)
 90cab80:	dc000017 	ldw	r16,0(sp)
 90cab84:	dec00604 	addi	sp,sp,24
 90cab88:	f800283a 	ret
 90cab8c:	29802204 	addi	r6,r5,136
 90cab90:	00800044 	movi	r2,1
 90cab94:	110e983a 	sll	r7,r2,r4
 90cab98:	30c04017 	ldw	r3,256(r6)
 90cab9c:	2105883a 	add	r2,r4,r4
 90caba0:	1085883a 	add	r2,r2,r2
 90caba4:	1185883a 	add	r2,r2,r6
 90caba8:	19c6b03a 	or	r3,r3,r7
 90cabac:	14802015 	stw	r18,128(r2)
 90cabb0:	14c00015 	stw	r19,0(r2)
 90cabb4:	00800084 	movi	r2,2
 90cabb8:	30c04015 	stw	r3,256(r6)
 90cabbc:	88bfe31e 	bne	r17,r2,90cab4c <__register_exitproc+0x50>
 90cabc0:	30804117 	ldw	r2,260(r6)
 90cabc4:	11c4b03a 	or	r2,r2,r7
 90cabc8:	30804115 	stw	r2,260(r6)
 90cabcc:	003fdf06 	br	90cab4c <__register_exitproc+0x50>
 90cabd0:	008243b4 	movhi	r2,2318
 90cabd4:	10b69c04 	addi	r2,r2,-9616
 90cabd8:	100b883a 	mov	r5,r2
 90cabdc:	80805215 	stw	r2,328(r16)
 90cabe0:	003fd606 	br	90cab3c <__register_exitproc+0x40>
 90cabe4:	00824374 	movhi	r2,2317
 90cabe8:	10a94b04 	addi	r2,r2,-23252
 90cabec:	1000021e 	bne	r2,zero,90cabf8 <__register_exitproc+0xfc>
 90cabf0:	013fffc4 	movi	r4,-1
 90cabf4:	003fdc06 	br	90cab68 <__register_exitproc+0x6c>
 90cabf8:	01006404 	movi	r4,400
 90cabfc:	103ee83a 	callr	r2
 90cac00:	1007883a 	mov	r3,r2
 90cac04:	103ffa26 	beq	r2,zero,90cabf0 <__register_exitproc+0xf4>
 90cac08:	80805217 	ldw	r2,328(r16)
 90cac0c:	180b883a 	mov	r5,r3
 90cac10:	18000115 	stw	zero,4(r3)
 90cac14:	18800015 	stw	r2,0(r3)
 90cac18:	80c05215 	stw	r3,328(r16)
 90cac1c:	18006215 	stw	zero,392(r3)
 90cac20:	18006315 	stw	zero,396(r3)
 90cac24:	0009883a 	mov	r4,zero
 90cac28:	883fc826 	beq	r17,zero,90cab4c <__register_exitproc+0x50>
 90cac2c:	003fd706 	br	90cab8c <__register_exitproc+0x90>

090cac30 <register_fini>:
 90cac30:	f800283a 	ret

090cac34 <__call_exitprocs>:
 90cac34:	00824374 	movhi	r2,2317
 90cac38:	108b9c04 	addi	r2,r2,11888
 90cac3c:	10800017 	ldw	r2,0(r2)
 90cac40:	defff304 	addi	sp,sp,-52
 90cac44:	df000b15 	stw	fp,44(sp)
 90cac48:	d8800115 	stw	r2,4(sp)
 90cac4c:	00824374 	movhi	r2,2317
 90cac50:	10a94604 	addi	r2,r2,-23272
 90cac54:	1005003a 	cmpeq	r2,r2,zero
 90cac58:	d8800215 	stw	r2,8(sp)
 90cac5c:	d8800117 	ldw	r2,4(sp)
 90cac60:	dd400815 	stw	r21,32(sp)
 90cac64:	dd000715 	stw	r20,28(sp)
 90cac68:	10805204 	addi	r2,r2,328
 90cac6c:	dfc00c15 	stw	ra,48(sp)
 90cac70:	ddc00a15 	stw	r23,40(sp)
 90cac74:	dd800915 	stw	r22,36(sp)
 90cac78:	dcc00615 	stw	r19,24(sp)
 90cac7c:	dc800515 	stw	r18,20(sp)
 90cac80:	dc400415 	stw	r17,16(sp)
 90cac84:	dc000315 	stw	r16,12(sp)
 90cac88:	282b883a 	mov	r21,r5
 90cac8c:	2039883a 	mov	fp,r4
 90cac90:	d8800015 	stw	r2,0(sp)
 90cac94:	2829003a 	cmpeq	r20,r5,zero
 90cac98:	d8800117 	ldw	r2,4(sp)
 90cac9c:	14405217 	ldw	r17,328(r2)
 90caca0:	88001026 	beq	r17,zero,90cace4 <__call_exitprocs+0xb0>
 90caca4:	ddc00017 	ldw	r23,0(sp)
 90caca8:	88800117 	ldw	r2,4(r17)
 90cacac:	8c802204 	addi	r18,r17,136
 90cacb0:	143fffc4 	addi	r16,r2,-1
 90cacb4:	80000916 	blt	r16,zero,90cacdc <__call_exitprocs+0xa8>
 90cacb8:	05bfffc4 	movi	r22,-1
 90cacbc:	a000151e 	bne	r20,zero,90cad14 <__call_exitprocs+0xe0>
 90cacc0:	8409883a 	add	r4,r16,r16
 90cacc4:	2105883a 	add	r2,r4,r4
 90cacc8:	1485883a 	add	r2,r2,r18
 90caccc:	10c02017 	ldw	r3,128(r2)
 90cacd0:	a8c01126 	beq	r21,r3,90cad18 <__call_exitprocs+0xe4>
 90cacd4:	843fffc4 	addi	r16,r16,-1
 90cacd8:	85bff81e 	bne	r16,r22,90cacbc <__call_exitprocs+0x88>
 90cacdc:	d8800217 	ldw	r2,8(sp)
 90cace0:	10003126 	beq	r2,zero,90cada8 <__call_exitprocs+0x174>
 90cace4:	dfc00c17 	ldw	ra,48(sp)
 90cace8:	df000b17 	ldw	fp,44(sp)
 90cacec:	ddc00a17 	ldw	r23,40(sp)
 90cacf0:	dd800917 	ldw	r22,36(sp)
 90cacf4:	dd400817 	ldw	r21,32(sp)
 90cacf8:	dd000717 	ldw	r20,28(sp)
 90cacfc:	dcc00617 	ldw	r19,24(sp)
 90cad00:	dc800517 	ldw	r18,20(sp)
 90cad04:	dc400417 	ldw	r17,16(sp)
 90cad08:	dc000317 	ldw	r16,12(sp)
 90cad0c:	dec00d04 	addi	sp,sp,52
 90cad10:	f800283a 	ret
 90cad14:	8409883a 	add	r4,r16,r16
 90cad18:	88c00117 	ldw	r3,4(r17)
 90cad1c:	2105883a 	add	r2,r4,r4
 90cad20:	1445883a 	add	r2,r2,r17
 90cad24:	18ffffc4 	addi	r3,r3,-1
 90cad28:	11800217 	ldw	r6,8(r2)
 90cad2c:	1c001526 	beq	r3,r16,90cad84 <__call_exitprocs+0x150>
 90cad30:	10000215 	stw	zero,8(r2)
 90cad34:	303fe726 	beq	r6,zero,90cacd4 <__call_exitprocs+0xa0>
 90cad38:	00c00044 	movi	r3,1
 90cad3c:	1c06983a 	sll	r3,r3,r16
 90cad40:	90804017 	ldw	r2,256(r18)
 90cad44:	8cc00117 	ldw	r19,4(r17)
 90cad48:	1884703a 	and	r2,r3,r2
 90cad4c:	10001426 	beq	r2,zero,90cada0 <__call_exitprocs+0x16c>
 90cad50:	90804117 	ldw	r2,260(r18)
 90cad54:	1884703a 	and	r2,r3,r2
 90cad58:	10000c1e 	bne	r2,zero,90cad8c <__call_exitprocs+0x158>
 90cad5c:	2105883a 	add	r2,r4,r4
 90cad60:	1485883a 	add	r2,r2,r18
 90cad64:	11400017 	ldw	r5,0(r2)
 90cad68:	e009883a 	mov	r4,fp
 90cad6c:	303ee83a 	callr	r6
 90cad70:	88800117 	ldw	r2,4(r17)
 90cad74:	98bfc81e 	bne	r19,r2,90cac98 <__call_exitprocs+0x64>
 90cad78:	b8800017 	ldw	r2,0(r23)
 90cad7c:	147fd526 	beq	r2,r17,90cacd4 <__call_exitprocs+0xa0>
 90cad80:	003fc506 	br	90cac98 <__call_exitprocs+0x64>
 90cad84:	8c000115 	stw	r16,4(r17)
 90cad88:	003fea06 	br	90cad34 <__call_exitprocs+0x100>
 90cad8c:	2105883a 	add	r2,r4,r4
 90cad90:	1485883a 	add	r2,r2,r18
 90cad94:	11000017 	ldw	r4,0(r2)
 90cad98:	303ee83a 	callr	r6
 90cad9c:	003ff406 	br	90cad70 <__call_exitprocs+0x13c>
 90cada0:	303ee83a 	callr	r6
 90cada4:	003ff206 	br	90cad70 <__call_exitprocs+0x13c>
 90cada8:	88800117 	ldw	r2,4(r17)
 90cadac:	1000081e 	bne	r2,zero,90cadd0 <__call_exitprocs+0x19c>
 90cadb0:	89000017 	ldw	r4,0(r17)
 90cadb4:	20000726 	beq	r4,zero,90cadd4 <__call_exitprocs+0x1a0>
 90cadb8:	b9000015 	stw	r4,0(r23)
 90cadbc:	8809883a 	mov	r4,r17
 90cadc0:	90ca5180 	call	90ca518 <free>
 90cadc4:	bc400017 	ldw	r17,0(r23)
 90cadc8:	883fb71e 	bne	r17,zero,90caca8 <__call_exitprocs+0x74>
 90cadcc:	003fc506 	br	90cace4 <__call_exitprocs+0xb0>
 90cadd0:	89000017 	ldw	r4,0(r17)
 90cadd4:	882f883a 	mov	r23,r17
 90cadd8:	2023883a 	mov	r17,r4
 90caddc:	883fb21e 	bne	r17,zero,90caca8 <__call_exitprocs+0x74>
 90cade0:	003fc006 	br	90cace4 <__call_exitprocs+0xb0>

090cade4 <__fixunsdfsi>:
 90cade4:	defffb04 	addi	sp,sp,-20
 90cade8:	dc400115 	stw	r17,4(sp)
 90cadec:	dc000015 	stw	r16,0(sp)
 90cadf0:	04507834 	movhi	r17,16864
 90cadf4:	0021883a 	mov	r16,zero
 90cadf8:	800d883a 	mov	r6,r16
 90cadfc:	880f883a 	mov	r7,r17
 90cae00:	dcc00315 	stw	r19,12(sp)
 90cae04:	dc800215 	stw	r18,8(sp)
 90cae08:	2827883a 	mov	r19,r5
 90cae0c:	2025883a 	mov	r18,r4
 90cae10:	dfc00415 	stw	ra,16(sp)
 90cae14:	908bd580 	call	908bd58 <__gedf2>
 90cae18:	000d883a 	mov	r6,zero
 90cae1c:	880f883a 	mov	r7,r17
 90cae20:	980b883a 	mov	r5,r19
 90cae24:	9009883a 	mov	r4,r18
 90cae28:	10000d16 	blt	r2,zero,90cae60 <__fixunsdfsi+0x7c>
 90cae2c:	908b4c00 	call	908b4c0 <__subdf3>
 90cae30:	180b883a 	mov	r5,r3
 90cae34:	1009883a 	mov	r4,r2
 90cae38:	908bf600 	call	908bf60 <__fixdfsi>
 90cae3c:	00e00034 	movhi	r3,32768
 90cae40:	10c5883a 	add	r2,r2,r3
 90cae44:	dfc00417 	ldw	ra,16(sp)
 90cae48:	dcc00317 	ldw	r19,12(sp)
 90cae4c:	dc800217 	ldw	r18,8(sp)
 90cae50:	dc400117 	ldw	r17,4(sp)
 90cae54:	dc000017 	ldw	r16,0(sp)
 90cae58:	dec00504 	addi	sp,sp,20
 90cae5c:	f800283a 	ret
 90cae60:	980b883a 	mov	r5,r19
 90cae64:	9009883a 	mov	r4,r18
 90cae68:	908bf600 	call	908bf60 <__fixdfsi>
 90cae6c:	dfc00417 	ldw	ra,16(sp)
 90cae70:	dcc00317 	ldw	r19,12(sp)
 90cae74:	dc800217 	ldw	r18,8(sp)
 90cae78:	dc400117 	ldw	r17,4(sp)
 90cae7c:	dc000017 	ldw	r16,0(sp)
 90cae80:	dec00504 	addi	sp,sp,20
 90cae84:	f800283a 	ret

090cae88 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 90cae88:	defffd04 	addi	sp,sp,-12
 90cae8c:	df000215 	stw	fp,8(sp)
 90cae90:	df000204 	addi	fp,sp,8
 90cae94:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 90cae98:	e0bfff17 	ldw	r2,-4(fp)
 90cae9c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 90caea0:	e0bffe17 	ldw	r2,-8(fp)
 90caea4:	1005003a 	cmpeq	r2,r2,zero
 90caea8:	1000021e 	bne	r2,zero,90caeb4 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 90caeac:	002af070 	cmpltui	zero,zero,43969
 90caeb0:	00000106 	br	90caeb8 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 90caeb4:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 90caeb8:	e037883a 	mov	sp,fp
 90caebc:	df000017 	ldw	fp,0(sp)
 90caec0:	dec00104 	addi	sp,sp,4
 90caec4:	f800283a 	ret

090caec8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 90caec8:	defffd04 	addi	sp,sp,-12
 90caecc:	dfc00215 	stw	ra,8(sp)
 90caed0:	df000115 	stw	fp,4(sp)
 90caed4:	df000104 	addi	fp,sp,4
 90caed8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 90caedc:	00824374 	movhi	r2,2317
 90caee0:	108c0544 	addi	r2,r2,12309
 90caee4:	10000005 	stb	zero,0(r2)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 90caee8:	e13fff17 	ldw	r4,-4(fp)
 90caeec:	90cae880 	call	90cae88 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 90caef0:	003fff06 	br	90caef0 <_exit+0x28>
 90caef4:	090cac30 	cmpltui	r4,at,12976

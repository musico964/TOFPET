
AsicController.elf:     file format elf32-littlenios2
AsicController.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x090802bc

Program Header:
    LOAD off    0x00001000 vaddr 0x06020000 paddr 0x06020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001120 vaddr 0x09080120 paddr 0x09080120 align 2**12
         filesz 0x00053a4c memsz 0x0005e070 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  06020000  06020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  09080120  09080120  00001120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004b9b0  090802bc  090802bc  000012bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005da4  090cbc6c  090cbc6c  0004cc6c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000215c  090d1a10  090d1a10  00052a10  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000a624  090d3b6c  090d3b6c  00054b6c  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00054b6c  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000019f0  00000000  00000000  00054b98  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00005986  00000000  00000000  00056588  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0008014e  00000000  00000000  0005bf0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00011890  00000000  00000000  000dc05c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00042881  00000000  00000000  000ed8ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000687c  00000000  00000000  00130170  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003949  00000000  00000000  001369ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00013f0c  00000000  00000000  0013a335  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  0014e244  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000920  00000000  00000000  0014e298  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  001596c7  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  001596cd  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  001596d0  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  001596d1  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  001596d2  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  001596d6  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  001596da  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  001596de  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  001596e7  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  001596f0  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000e  00000000  00000000  001596f9  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000054  00000000  00000000  00159707  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     000ab3ec  00000000  00000000  0015975b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
06020000 l    d  .entry	00000000 .entry
09080120 l    d  .exceptions	00000000 .exceptions
090802bc l    d  .text	00000000 .text
090cbc6c l    d  .rodata	00000000 .rodata
090d1a10 l    d  .rwdata	00000000 .rwdata
090d3b6c l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
09080300 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 AsicCtrl.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 atoul.c
090d1a10 l     O .rwdata	00000011 uchex.2302
090d1a24 l     O .rwdata	00000011 hex.2301
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
090d3d8c l     O .bss	000005f0 conn.4526
090d3b78 l     O .bss	00000004 SSSCommand.4551
090d3b7c l     O .bss	00000004 j.4547
090d3b80 l     O .bss	00000004 i.4546
090d437c l     O .bss	00001000 p2.4545
090d3b84 l     O .bss	00000004 p1.4544
090d537c l     O .bss	00000020 ps.4543
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 ctype_.c
090ccbf5 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
090d1b70 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
09083fd0 l     F .text	00000058 __sprint_r
090cd596 l     O .rodata	00000010 blanks.3452
090cd586 l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
09086180 l     F .text	00000218 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
09087b7c l     F .text	00000058 std
09087c88 l     F .text	00000008 __fp_lock
09087c90 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
090d3a24 l     O .rwdata	00000004 charset
090cd5c8 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
090cd710 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0908ad8c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
0908c0b0 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0908d1cc l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0908d980 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0908daa0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
0908dbf0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
090d3a30 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
090d3a34 l     O .rwdata	00000004 lockid
090d3bb4 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
090d3a38 l     O .rwdata	00000004 lockid
090d3bbc l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0908f79c l     F .text	00000044 OS_InitMisc
0908f7e0 l     F .text	0000006c OS_InitRdyList
0908f944 l     F .text	000000e0 OS_InitTCBList
0908f6c0 l     F .text	000000dc OS_InitEventList
0908f84c l     F .text	0000007c OS_InitTaskIdle
0908f8c8 l     F .text	0000007c OS_InitTaskStat
0908fbb8 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
09091af0 l     F .text	00000110 OS_FlagTaskRdy
09091848 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
090d2384 l     O .rwdata	000000d8 ext_flash
090d245c l     O .rwdata	0000106c jtag_uart
090d34c8 l     O .rwdata	00000124 lcd
090d35ec l     O .rwdata	00000030 sgdma_rx
090d361c l     O .rwdata	00000030 sgdma_tx
0909670c l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
090967e0 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
090975e0 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
09098744 l     F .text	000002c4 altera_avalon_jtag_uart_irq
09098a08 l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
090d3ab4 l     O .rwdata	00000004 colstart
09099220 l     F .text	000000b8 lcd_write_command
090992d8 l     F .text	000000d4 lcd_write_data
090993ac l     F .text	000000c4 lcd_clear_screen
09099470 l     F .text	000001ec lcd_repaint_screen
0909965c l     F .text	000000c8 lcd_scroll_up
09099724 l     F .text	000002d0 lcd_handle_escape
09099f24 l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0909a894 l     F .text	00000060 alt_get_errno
0909ae3c l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0909afa8 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
090d3c16 l     O .bss	00000001 tse_system_count.4487
090d3c17 l     O .bss	00000001 is_init.4851
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
090d3c2c l     O .bss	00000004 nclosers
090d53c4 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
090d3ad0 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
090d5400 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
090a8408 l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
090aa474 l       .text	00000000 done
090aa304 l       .text	00000000 asm1
090aa430 l       .text	00000000 loop0
090aa32c l       .text	00000000 loop
090aa44c l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
090d3c8c l     O .bss	00000004 kbd_init.3746
090d3c98 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
090d3ccc l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
090aebf0 l     F .text	00000098 sockargs
090ade2c l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
090b6fcc l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
090b9bdc l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
090b9cb4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
090b9d94 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
090ba224 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
090ba360 l     F .text	000000dc alt_file_locked
090ba5c4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_read.c
090ba744 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
090bad0c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
090bb624 l     F .text	000000bc alt_write_word_amd
090bb500 l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
090bb8d8 l     F .text	0000018c alt_unlock_block_intel
090bba64 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 allports.c
090d3d04 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
090bc108 l     F .text	00000198 check_interval_timers
090d3d10 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
090d3d14 l     O .bss	00000004 arp_timer
090d3d2c l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
090d3b54 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
090d3d5c l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
090d3b5c l     O .rwdata	00000004 iCounter.4504
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
090d5418 l     O .bss	0000001e nearBuf.4182
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
090c9e40 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
090d39fc l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __call_atexit.c
090cba10 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 libgcc2.c
090835f4 g     F .text	0000001c putchar
090ddc8c g     O .bss	00000014 soq
090899ec g     F .text	00000094 _mprec_log10
0909c37c g     F .text	000000e0 alt_tse_get_mac_info
090d3a86 g     O .rwdata	00000002 OSTaskNameSize
09089ad8 g     F .text	00000088 __any_on
0908b3c4 g     F .text	00000070 _isatty_r
090cd6e8 g     O .rodata	00000028 __mprec_tinytens
090be144 g     F .text	00000780 ip_write_internal
0908dc50 g     F .text	000000b8 alt_main
090cb4c8 g     F .text	0000008c strcpy
090a9bc8 g     F .text	000000ac pk_free
09083618 g     F .text	000000a0 _puts_r
090970a0 g     F .text	00000048 alt_read_query_entry_32bit
090dde38 g     O .bss	00000100 alt_irq
090d389c g     O .rwdata	00000009 rtp_priority
0908b434 g     F .text	00000078 _lseek_r
090cb038 g     F .text	00000334 icmp_timex
090ab594 g     F .text	00000044 m_freem
090c9678 g     F .text	00000048 vgetc
090aa5f0 g     F .text	0000001c clock_c
090d3ce4 g     O .bss	00000004 tcp_optionbuf
090bdc0c g     F .text	00000084 if_getbynum
090923e4 g     F .text	000000d0 OS_MemInit
090d3c84 g     O .bss	00000004 dsc_rlyerrs
090d3c74 g     O .bss	00000004 dsc_releases
09096818 g     F .text	000002c0 alt_flash_cfi_write
090a5f98 g     F .text	00000074 TK_OSTaskQuery
090aa2e4 g       .text	00000000 asm_cksum
090a0268 g     F .text	00000100 marvell_cfg_rgmii
090963f4 g     F .text	00000064 OSTimeSet
090c9558 g     F .text	00000120 vgetc_locked
090aae70 g     F .text	00000020 post_task_setup
090c1b7c g     F .text	00000380 ipr_stats
090b8938 g     F .text	00000134 tcp_attach
090d3ae0 g     O .rwdata	00000004 reqlist_len
090aca40 g     F .text	000000bc tcp_tick
090a514c g     F .text	00000074 print_ipad
090a5e94 g     F .text	00000104 tcp_wakeup
0908cbc0 g     F .text	00000088 __eqdf2
090d3b70 g     O .bss	00000004 last_flash_sector_offset
090d3c30 g     O .bss	00000004 igmp_timers_are_running
090b5824 g     F .text	0000012c tcp_pulloutofband
0909d8e8 g     F .text	000001f0 alt_tse_phy_print_profile
0908e318 g     F .text	000006b4 OSEventPendMulti
090de190 g       *ABS*	00000000 __alt_heap_start
090bb16c g     F .text	00000020 OSTaskCreateHook
090a93b4 g     F .text	00000074 dhc_ifacedone
0909ffd8 g     F .text	000000a8 marvell_phy_cfg
090c1f50 g     F .text	00000400 ip_rcv
090c92a8 g     F .text	0000017c vfseek
090b1684 g     F .text	00000120 soqremque
090c3da0 g     F .text	00000858 udpdemux
090a1a88 g     F .text	00000104 tse_mac_close
09083390 g     F .text	00000044 printf
090807ec g     F .text	00000078 ReadDataFifo
090d3d30 g     O .bss	00000004 rt_mib
090d3a5e g     O .rwdata	00000002 OSMboxEn
090a92c4 g     F .text	00000060 dhc_state_init
090cb9ec g     F .text	00000024 vsprintf
0909a300 g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
0908ea20 g     F .text	0000007c OSIntEnter
0908ae90 g     F .text	00000068 __sseek
09087be4 g     F .text	000000a4 __sinit
090c2ef4 g     F .text	00000118 in_delmulti
09085ef8 g     F .text	00000130 __swbuf_r
090d3d48 g     O .bss	00000004 so_evtmap_create
090d3a6e g     O .rwdata	00000002 OSQEn
090c7828 g     F .text	00000094 in_pcballoc
090d3afc g     O .rwdata	00000002 socket_defaults
09088a08 g     F .text	00000084 _setlocale_r
090bc93c g     F .text	00000498 send_arp
09087ce4 g     F .text	00000068 __sfmoreglue
090c8314 g     F .text	00000368 vfopen_locked
0908dfd4 g     F .text	000000d0 __malloc_unlock
09080450 g     F .text	00000038 ReadNbitReg
090bb1c8 g     F .text	0000001c OSTaskStatHook
090bbf4c g     F .text	00000058 prep_modules
090a4620 g     F .text	000001b8 bsd_i_sockoptlen
090d3bc4 g     O .bss	00000001 OSLockNesting
090d3ad8 g     O .rwdata	00000004 xids
090838e0 g     F .text	00000674 strerror
0909c5e0 g     F .text	00000e08 getPHYSpeed
090c8874 g     F .text	00000040 vfclose
090ddd2c g     O .bss	0000002c tcb
090d3aac g     O .rwdata	00000002 OSDataSize
090ba804 g     F .text	00000038 alt_remap_cached
090d3bc5 g     O .bss	00000001 OSRunning
090bd940 g     F .text	000002cc grat_arp
090818b8 g     F .text	0000005c get_ip_addr
090805d0 g     F .text	0000006c ReadDataFifo1
090c7240 g     F .text	000000ac inet_pton
090bdd70 g     F .text	0000009c reg_type
090dd830 g     O .bss	000000f0 dhc_states
090a3380 g     F .text	00000234 igmp_fasttimo
090c8a38 g     F .text	0000005c vunlink_flag_open_files
090a906c g     F .text	00000088 dhc_halt
0909aa54 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
090d3c68 g     O .bss	00000004 dsc_acks
090ddd58 g     O .bss	000000e0 tcpstat
090c13f4 g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
090abb24 g     F .text	000000a8 dtom
090b6ed0 g     F .text	000000fc tcp_setpersist
090ae204 g     F .text	000001a4 t_getsockopt
09089500 g     F .text	000000e0 memmove
090d3c78 g     O .bss	00000004 dsc_naks
090abfc8 g     F .text	000005f8 ip_output
090bb20c g     F .text	0000001c OSInitHookBegin
090cb36c g     F .text	00000054 icmp_du
090d3ad4 g     O .rwdata	00000004 num_net_tasks
090d3d6c g     O .bss	00000004 vfiles
090d3aa4 g     O .rwdata	00000002 OSTmrSize
090c693c g     F .text	00000104 dhc_main_ipset
09087cd4 g     F .text	00000010 _cleanup
090c04ec g     F .text	000002e0 ip_reasm_process_first_fragment
09089b60 g     F .text	000000bc _Balloc
090d3bc8 g     O .bss	00000004 OSIdleCtr
0909f29c g     F .text	00000194 alt_tse_phy_set_adv_1000
090d3ac0 g     O .rwdata	00000001 max_mac_system
090c57d4 g     F .text	000005f0 ip_setmoptions
0909b5e0 g     F .text	00000a14 alt_tse_system_add_sys
0908ccd0 g     F .text	00000088 __gtdf2
090c6d00 g     F .text	0000002c md_fseek
090bae38 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0908ff04 g     F .text	000002e0 OS_TCBInit
090c07cc g     F .text	000000a0 ip_reassm
090a90f4 g     F .text	000001d0 dhc_reclaim
0909722c g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
09080564 g     F .text	0000006c ReadDataFifo0
090de118 g     O .bss	00000010 udp_mib
06020000 g     F .entry	00000000 __reset
090aea3c g     F .text	000000e4 t_shutdown
090ae498 g     F .text	00000150 t_recvfrom
090d3aaa g     O .rwdata	00000002 OSTmrWheelTblSize
090c5fb8 g     F .text	000006b8 u_mctest_run
0909a568 g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
090c307c g     F .text	00000094 prep_ifaces
090d3c4c g     O .bss	00000001 to_netmain
090a9834 g     F .text	000000dc pk_alloc
090d3a4a g     O .rwdata	00000002 OSEventSize
09081120 g     F .text	000002ec alt_SSSErrorHandler
090d3bcc g     O .bss	00000001 OSPrioHighRdy
0908b350 g     F .text	00000074 _fstat_r
090d1a50 g     O .rwdata	00000120 tse_mac_device
090a5c0c g     F .text	0000004c tk_nettick
090bb18c g     F .text	00000020 OSTaskDelHook
09096d34 g     F .text	000002e8 alt_flash_program_block
090d3ba4 g     O .bss	00000004 errno
09083718 g     F .text	00000014 __srget
090b29b0 g     F .text	000000cc in_pcbnotify
090bae18 g       .text	00000000 OSStartHighRdy
090dd920 g     O .bss	00000014 lilfreeq
09080864 g     F .text	00000624 alt_uCOSIIErrorHandler
090c3138 g     F .text	00000028 evtmap_setup
09094af8 g     F .text	00000200 OSTaskCreateExt
090d3c50 g     O .bss	00000004 tcp_sleep_timeout
090b20b0 g     F .text	000001d0 sbdrop
090d3d44 g     O .bss	00000004 net_system_exit
090de128 g     O .bss	00000068 icmp_mib
090b7a24 g     F .text	00000078 tcp_getseq
090c3548 g     F .text	000000cc ip_raw_alloc
0909faf4 g     F .text	000004e4 alt_tse_phy_set_common_speed
09091364 g     F .text	00000068 OSFlagPendGetFlagsRdy
090d3a8a g     O .rwdata	00000002 OSTaskStatStkSize
090dd304 g     O .bss	00000010 pmac_groups
090a7450 g     F .text	00000b3c dhc_request
090afd3c g     F .text	000007e4 soreceive
09090370 g     F .text	00000334 OSFlagAccept
09092b1c g     F .text	000000c8 OSQFlush
090924b4 g     F .text	00000154 OSQAccept
090d3bac g     O .bss	00000004 alt_argv
090dba14 g       *ABS*	00000000 _gp
090c1efc g     F .text	00000054 ip_reasm_send_icmp_timex
090baa88 g     F .text	00000164 usleep
090c88b4 g     F .text	00000048 vfflush
090ddc34 g     O .bss	00000040 resid_semaphore
090a5004 g     F .text	00000148 hexdump
090c03a4 g     F .text	000000a8 ip_reasm_incr_mem_useage
090aaec8 g     F .text	00000034 calloc2
090a3ad8 g     F .text	0000007c igmp_leavegroup
09094924 g     F .text	000001d4 OSTaskCreate
090943b0 g     F .text	00000574 OSTaskChangePrio
090d3bc0 g     O .bss	00000004 alt_heapsem
090d3b88 g     O .bss	00000004 fd_listen
090b7870 g     F .text	000000e8 tcp_close
090901e4 g     F .text	0000018c OSDebugInit
09094cf8 g     F .text	0000040c OSTaskDel
090c9ad4 g     F .text	0000006c vferror
090baa24 g     F .text	00000064 alt_uncached_malloc
0909b0d4 g     F .text	00000060 tse_mac_initTransInfo2
090c4ab0 g     F .text	000000c0 udp_alloc
090d3704 g     O .rwdata	00000180 alt_fd_list
090da000 g     O .bss	00000370 OSFlagTbl
090d3cd0 g     O .bss	00000008 mbstat
090831e8 g     F .text	00000090 _getc_r
09083150 g     F .text	00000098 getc
09083610 g     F .text	00000008 _putchar_r
0908f49c g     F .text	000000b8 OS_EventTaskRemove
090c53c4 g     F .text	00000158 igmpv2_chk_set_timer
090a5c58 g     F .text	0000002c TK_OSTimeDly
090b9df4 g     F .text	00000094 alt_find_dev
09089460 g     F .text	000000a0 memcpy
0909b35c g     F .text	00000058 tse_mac_setMIImode
090d3c80 g     O .bss	00000004 dsc_rebind
090bc540 g     F .text	00000080 task_stats
090ad528 g     F .text	0000004c DOMAIN_CHECK
090ac5c0 g     F .text	00000040 in_broadcast
090d3a74 g     O .rwdata	00000002 OSRdyTblSize
0909d3e8 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
090d3d68 g     O .bss	00000004 vfsystems
090c49e0 g     F .text	000000d0 udp_socket
090d3c20 g     O .bss	00000004 MaxMtu
090b2644 g     F .text	00000158 sock_selscan
09087cc8 g     F .text	0000000c _cleanup_r
0908ce68 g     F .text	000000f8 __floatsidf
090c0150 g     F .text	000000d0 ip_reasm_match_frag_with_ire
090b17f4 g     F .text	00000050 socantrcvmore
0909b134 g     F .text	000000f0 tse_mac_sTxWrite
0908337c g     F .text	00000014 perror
090ba2e8 g     F .text	00000078 alt_io_redirect
0908cde0 g     F .text	00000088 __ltdf2
090d3cac g     O .bss	00000004 netq_intmask
090c71d0 g     F .text	00000070 hextoa
090ae814 g     F .text	00000228 t_send
090b9ae0 g     F .text	000000fc alt_close
090d3cd8 g     O .bss	00000002 select_wait
090836b8 g     F .text	00000014 puts
090a5728 g     F .text	00000044 std_out
090d7438 g     O .bss	00000010 cliaddr
090dd324 g     O .bss	00000030 tse_iniche_dev_driver_data
090c96c0 g     F .text	00000138 vfslookup_locked
090af524 g     F .text	0000009c soaccept
0908e0a4 g     F .text	00000130 OSEventNameGet
090d3a58 g     O .rwdata	00000002 OSFlagMax
0908063c g     F .text	0000006c ReadDataFifo2
090ddca0 g     O .bss	0000003c tcpmib
090aec88 g     F .text	0000009c t_errno
090c3160 g     F .text	000000f0 ip_raw_open
090a82f0 g     F .text	00000118 dhc_decline
0908993c g     F .text	000000b0 __ratio
0908ea9c g     F .text	00000100 OSIntExit
090d3b58 g     O .rwdata	00000004 ipRoutes
090c89e0 g     F .text	00000058 vfeof
090b7d3c g     F .text	0000005c tcp_canceltimers
090a6c00 g     F .text	0000021c dhc_buildheader
090d3a92 g     O .rwdata	00000002 OSTCBSize
0909a64c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
090d3bcd g     O .bss	00000001 OSPrioCur
09098c84 g     F .text	000002c0 altera_avalon_jtag_uart_read
090cb440 g     F .text	00000014 malloc
090d3d64 g     O .bss	00000004 inpcb_cachemiss
090833d4 g     F .text	00000034 _printf_r
090c73d8 g     F .text	000000c4 inet46_addr
090d3d60 g     O .bss	00000004 inpcb_cachehits
0908d308 g     F .text	00000008 __udivsi3
090d36c4 g     O .rwdata	0000000b tcp_outflags
090dd354 g     O .bss	00000130 tse
0908d9e0 g     F .text	000000c0 isatty
0909bff4 g     F .text	00000178 alt_tse_sys_enable_mdio_sharing
090d3a78 g     O .rwdata	00000002 OSStkWidth
090cd5f8 g     O .rodata	000000c8 __mprec_tens
090c8170 g     F .text	0000007c vf_alloc_and_link_vop
090d3a6c g     O .rwdata	00000002 OSPtrSize
090d3d34 g     O .bss	00000004 ipr_curr_mem
090a2fcc g     F .text	0000006c exit_hook
090d3c34 g     O .bss	00000004 igmp_cticks
0909c2f0 g     F .text	0000008c alt_tse_get_mac_info_index
090d3cc0 g     O .bss	00000004 mheap_sem_ptr
090b5bf0 g     F .text	00000048 ip4_tcpmss
090889e4 g     F .text	00000008 __locale_charset
090d3a4c g     O .rwdata	00000002 OSEventTblSize
090de09c g     O .bss	00000014 netlist
090b0520 g     F .text	000000a8 soshutdown
090cbbc4 g     F .text	000000a4 __fixunsdfsi
090bad8c g       .text	00000000 OSCtxSw
090bbedc g     F .text	0000004c packet_check
090a7f8c g     F .text	00000280 dhc_setip
090ddcdc g     O .bss	00000014 mbufq
090af4d4 g     F .text	00000050 soabort
090d3b98 g     O .bss	00000004 __malloc_top_pad
090d3bd0 g     O .bss	00000004 OSTCBList
090a9eb8 g     F .text	00000110 qdel
090bbcc4 g     F .text	00000188 station_state
090c36b0 g     F .text	00000184 rt_lookup
090d3cf0 g     O .bss	00000004 alt_fd_list_lock
090d3a20 g     O .rwdata	00000004 __mb_cur_max
090a3b54 g     F .text	0000035c igmp_validate
090889ec g     F .text	0000000c _localeconv_r
090a2ce8 g     F .text	000002e4 ip_startup
090ad864 g     F .text	00000298 t_accept
090b1274 g     F .text	0000008c soisdisconnecting
0908a258 g     F .text	0000003c __i2b
090883c8 g     F .text	0000049c __sfvwrite_r
0909a774 g     F .text	00000058 alt_avalon_sgdma_stop
090a26a0 g     F .text	000003d4 pktdemux
090da370 g     O .bss	00000c30 OSMemTbl
090d3bd4 g     O .bss	00000001 OSTickStepState
0909d484 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
090aa4a8 g     F .text	000000ac kbhit
090ae028 g     F .text	000001dc t_setsockopt
0908ae18 g     F .text	00000070 _sbrk_r
090bb6e0 g     F .text	00000084 alt_program_intel
0908140c g     F .text	00000368 atoul
090d3884 g     O .rwdata	00000018 icmpdu_types
0909dad8 g     F .text	0000070c alt_tse_mac_group_init
090c8a94 g     F .text	00000220 vunlink
090a07c8 g     F .text	00000ae8 tse_mac_init
090803d4 g     F .text	00000044 ReadDummyReg
090d3a70 g     O .rwdata	00000002 OSQMax
090a4e44 g     F .text	000000b0 ccksum
090c81ec g     F .text	000000d8 vf_alloc_buffer
090d3d58 g     O .bss	00000004 cachedRoute
090d3ae4 g     O .rwdata	00000004 lilbufs
090dafa0 g     O .bss	00000800 OSTaskStatStk
090c6d2c g     F .text	00000024 md_ftell
090a4ef4 g     F .text	00000068 cksum
09091fcc g     F .text	0000010c OSMemNameGet
090af03c g     F .text	00000130 sofree
090d3c28 g     O .bss	00000004 ifNumber
090d3a50 g     O .rwdata	00000002 OSFlagEn
0908b4ac g     F .text	00000078 _read_r
090d3a96 g     O .rwdata	00000002 OSTimeTickHookEn
090b9c3c g     F .text	00000078 alt_dcache_flush
09093080 g     F .text	00000180 OSQPost
09091c00 g     F .text	000000ac OS_FlagUnlink
090d1f70 g     O .rwdata	0000000c __lc_ctype
090d3b24 g     O .rwdata	00000004 alt_max_fd
0909701c g     F .text	00000040 alt_read_query_entry_8bit
0908fa78 g     F .text	0000006c OS_MemCopy
090d3aec g     O .rwdata	00000004 bigbufs
090b8a6c g     F .text	000000d4 tcp_disconnect
0908fae4 g     F .text	000000d4 OS_Sched
0908d6ac g     F .text	00000138 __unpack_d
0908b22c g     F .text	00000110 _fclose_r
09091ec8 g     F .text	00000104 OSMemGet
0909542c g     F .text	000001c4 OSTaskNameSet
090bb764 g     F .text	00000174 alt_erase_block_intel
09087b48 g     F .text	00000034 fflush
090d3b9c g     O .bss	00000004 __malloc_max_sbrked_mem
090d3bd8 g     O .bss	00000004 OSCtxSwCtr
090dd7a8 g     O .bss	00000064 igmpstats
090bb1e4 g     F .text	00000028 OSTimeTickHook
090a734c g     F .text	00000104 dhc_rx_offer
090a47d8 g     F .text	00000120 bsd_getsockopt
090d3a5a g     O .rwdata	00000002 OSFlagNameSize
090de100 g     O .bss	00000018 ire_stats
090b8cdc g     F .text	000001b8 udp_soinput
090a9e08 g     F .text	000000b0 putq
0908f554 g     F .text	00000104 OS_EventTaskRemoveMulti
090d3c48 g     O .bss	00000004 iniche_net_ready
0908c540 g     F .text	00000074 __adddf3
0908f348 g     F .text	00000154 OS_EventTaskWaitMulti
090c9a8c g     F .text	00000048 isvfile
090b06c8 g     F .text	000004c0 sosetopt
090a5a90 g     F .text	000000f4 netmain
090b5c38 g     F .text	0000011c tcp_mss
0908981c g     F .text	00000120 __b2d
090c6e4c g     F .text	0000031c parse_ipad
090c8150 g     F .text	00000020 get_vfopen_error
090d3a72 g     O .rwdata	00000002 OSQSize
0908bb00 g     F .text	000005b0 __umoddi3
0908db00 g     F .text	000000f0 lseek
090bbfa4 g     F .text	00000164 inet_timer
09093c5c g     F .text	0000027c OSSemPend
0909d670 g     F .text	00000278 alt_tse_phy_add_profile_default
0909ed5c g     F .text	00000540 alt_tse_phy_get_cap
09080418 g     F .text	00000038 ReadCommandReg
090d3a1c g     O .rwdata	00000004 _global_impure_ptr
090a53c0 g     F .text	00000164 print_eth
090c867c g     F .text	00000050 vfopen
090ba624 g     F .text	00000120 alt_read
0908a5d4 g     F .text	000005f4 _realloc_r
09080e88 g     F .text	00000298 alt_NetworkErrorHandler
090d3a5c g     O .rwdata	00000002 OSLowestPrio
090de190 g       *ABS*	00000000 __bss_end
090ba12c g     F .text	000000f8 alt_iic_isr_register
0909a1c4 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
090ab460 g     F .text	00000134 m_free
090bb260 g     F .text	00000020 OSTCBInitHook
090a1a48 g     F .text	00000040 tse_mac_stats
090a9910 g     F .text	000002b8 pk_validate
090d3aa2 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
090ba914 g     F .text	00000110 alt_tick
090c7ecc g     F .text	0000025c in_pcblookup
090a94d8 g     F .text	000000cc find_opt
0908b524 g     F .text	000005dc __udivdi3
090ab2b8 g     F .text	000001a8 m_getnbuf
090a9c94 g     F .text	000000ac dump_buf_estats
0909ec18 g     F .text	00000144 alt_tse_phy_check_link
090d3d28 g     O .bss	00000004 arpRepsOut
090d3a44 g     O .rwdata	00000002 OSEventEn
090cd6c0 g     O .rodata	00000028 __mprec_bigtens
0908a4b4 g     F .text	00000120 __s2b
090d3a9e g     O .rwdata	00000002 OSTmrCfgNameSize
0908d038 g     F .text	00000194 __floatunsidf
090bbb40 g     F .text	000000fc netmain_init
090a0174 g     F .text	000000f4 marvell_cfg_sgmii
0909ea68 g     F .text	000001b0 alt_tse_phy_restart_an
0908973c g     F .text	00000060 __mcmp
090d3c64 g     O .bss	00000004 dsc_requests
090b7224 g     F .text	00000488 tcp_respond
090b9118 g     F .text	0000033c udp4_sockbind
090d3a14 g     O .rwdata	00000004 __ctype_ptr
090d3cb0 g     O .bss	00000004 old_mode
090a385c g     F .text	0000027c igmp_joingroup
090ac6e8 g     F .text	00000358 so_icmpdu
09087cb0 g     F .text	00000018 __fp_lock_all
090d3d78 g     O .bss	00000004 vfs_dir_stale
090ba0e4 g     F .text	00000048 alt_ic_irq_enabled
090dd314 g     O .bss	00000010 pphy_profiles
090c1750 g     F .text	0000011c ip_reasm_process_timer_tick
090c9b40 g     F .text	0000005c vclearerr
090a4d58 g     F .text	000000ec bsd_setsockopt
09080364 g     F .text	00000070 WriteCfgFifo
090abacc g     F .text	00000058 mbuf_len
09091a0c g     F .text	000000e4 OS_FlagInit
090ba87c g     F .text	00000098 alt_alarm_stop
090c9840 g     F .text	000001e8 strippath
090d3adc g     O .rwdata	00000004 reqlist
090a5cf4 g     F .text	000001a0 tcp_sleep
090cb944 g     F .text	00000024 strtol
090a63d0 g     F .text	00000830 dhc_upcall
090b8b40 g     F .text	000000e0 tcp_usrclosed
09100000 g       *ABS*	00000000 __alt_mem_descriptor_memory
090d3c9c g     O .bss	00000004 cticks_factor
090d3a80 g     O .rwdata	00000002 OSTaskIdleStkSize
090c7910 g     F .text	00000254 in_pcbbind
090d3cf4 g     O .bss	00000004 alt_irq_active
090937e8 g     F .text	000000c0 OSSemAccept
090921f8 g     F .text	000000f0 OSMemPut
09091cac g     F .text	0000021c OSMemCreate
090d3bdc g     O .bss	00000004 OSIdleCtrMax
090801ec g     F .exceptions	000000d0 alt_irq_handler
090d36dc g     O .rwdata	00000028 alt_dev_null
090d3afe g     O .rwdata	00000001 tcprexmtthresh
09080334 g     F .text	00000030 WriteNbitReg
090d3a94 g     O .rwdata	00000002 OSTicksPerSec
090bde0c g     F .text	00000098 if_killsocks
090be8c4 g     F .text	00000248 ip_write
090c2350 g     F .text	0000060c ip_rcv_phase2
090adde8 g     F .text	00000044 t_getsockname
090adafc g     F .text	000002a8 t_connect
090d3af8 g     O .rwdata	00000004 TCPTV_MSL
090dd934 g     O .bss	00000010 memestats
0909e954 g     F .text	00000114 alt_tse_phy_init
090aa554 g     F .text	00000060 getch
09082d64 g     F .text	000002b0 DataFifoReadout
09097534 g     F .text	000000ac alt_set_flash_algorithm_func
090d397c g     O .rwdata	00000080 vfs_root_path
090adda4 g     F .text	00000044 t_getpeername
0909a7cc g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
090c044c g     F .text	000000a0 ip_reasm_decr_mem_useage
090b1980 g     F .text	00000080 soreserve
090bad8c g       .text	00000000 OSIntCtxSw
090aaefc g     F .text	000000f4 npalloc
09089608 g     F .text	00000070 __hi0bits
090d3d54 g     O .bss	00000004 ipraw_eps
090a95a4 g     F .text	00000290 pk_init
090c6b00 g     F .text	00000180 md_fread
090cb3d8 g     F .text	0000001c calloc
090a12b0 g     F .text	000002f8 tse_mac_raw_send
0908cf60 g     F .text	000000d8 __fixdfsi
090ddf38 g     O .bss	00000064 intimers
090b1a60 g     F .text	00000048 sbrelease
090b2ae4 g     F .text	000000f0 ifd_clr
090b2390 g     F .text	00000094 sbdroprecord
090a5524 g     F .text	00000080 uslash
090babec g     F .text	00000120 alt_write
090970e8 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
090d3d24 g     O .bss	00000004 arpRepsIn
090a6240 g     F .text	00000090 dhc_get_srv_ipaddr
090bc2a0 g     F .text	000001d4 in_timerset
090d3be0 g     O .bss	00000004 OSTCBFreeList
09093ed8 g     F .text	0000017c OSSemPendAbort
090b5d54 g     F .text	0000117c tcp_output
090d3d00 g     O .bss	00000004 activehost
090d3b1c g     O .rwdata	00000008 alt_dev_list
090a5864 g     F .text	0000022c parse_args
090d3cb4 g     O .bss	00000004 global_TCPwakeup_setIndx
09087ea0 g     F .text	00000058 _fputc_r
090a1d9c g     F .text	00000070 write
0909a97c g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
090aaff0 g     F .text	000000b8 npfree
0908350c g     F .text	000000e8 _putc_r
090bd0dc g     F .text	00000294 arpReply
090a4f88 g     F .text	0000007c nextarg
090d3a98 g     O .rwdata	00000002 OSVersionNbr
090c0dfc g     F .text	00000594 ip_reasm_process_subsequent_fragments
090d3b64 g     O .rwdata	00000004 pton_error
090d3c58 g     O .bss	00000004 dsc_errors
090d5438 g     O .bss	00002000 SSSInitialTaskStk
090dd484 g     O .bss	00000014 rcvdq
090b2a7c g     F .text	00000068 tcp_notify
090806a8 g     F .text	0000006c ReadDataFifo3
0908d8ac g     F .text	000000d4 fstat
09083014 g     F .text	0000002c fprintf
090af5c0 g     F .text	000000d4 soconnect
090c3654 g     F .text	0000005c ip_raw_maxalloc
090a0368 g     F .text	00000080 DP83848C_link_status_read
090a6e1c g     F .text	00000530 dhc_discover
090983e8 g     F .text	000000dc alt_check_primary_table
09081c2c g     F .text	0000001c SSSCreateOSDataStructs
090c7e50 g     F .text	0000007c in_setpeeraddr
090d3a40 g     O .rwdata	00000004 OSEndiannessTest
090aa5b4 g     F .text	0000003c clock_init
090c88fc g     F .text	000000e4 vfgets
090bc6c4 g     F .text	0000017c et_send
0908a394 g     F .text	00000120 __pow5mult
090d3b8c g     O .bss	00000004 __nlocale_changed
0908d310 g     F .text	00000008 __umodsi3
09096b68 g     F .text	00000068 alt_flash_cfi_read
090972bc g     F .text	00000034 alt_write_native_8bit
090c7168 g     F .text	00000068 inet_addr
090c030c g     F .text	00000098 ip_reasm_check_mem_useage
090b05c8 g     F .text	00000100 sorflush
090cb97c g     F .text	00000020 vprintf
090dda48 g     O .bss	000000fc global_tcb_ext
090bef94 g     F .text	00000488 ip_fragment_lc
090dd498 g     O .bss	00000300 netstatic
090ad604 g     F .text	0000017c t_bind
0909a5d8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
090d3a52 g     O .rwdata	00000002 OSFlagGrpSize
090aa200 g     F .text	000000e4 udp_close
0909a6d0 g     F .text	00000050 alt_avalon_sgdma_register_callback
090aabe0 g     F .text	0000021c alt_iniche_init
090de190 g       *ABS*	00000000 end
090aa818 g     F .text	00000088 UNLOCK_NET_RESOURCE
09080304 g     F .text	00000030 WriteCommandReg
090ae3a8 g     F .text	000000f0 t_recv
090a0544 g     F .text	00000284 prep_tse_mac
09097124 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
090999f4 g     F .text	00000530 altera_avalon_lcd_16207_write
090c8cb4 g     F .text	000001ac vfread
090a25b8 g     F .text	000000e8 netclose
09081c64 g     F .text	000000a8 SSSSimpleSocketServerTask
090cb3c0 g     F .text	0000000c _atoi_r
0909b408 g     F .text	000001d8 alt_tse_phy_add_profile
0909765c g     F .text	000005e0 alt_read_cfi_table
090d3b08 g     O .rwdata	00000004 tcp_keepintvl
0909860c g     F .text	00000138 altera_avalon_jtag_uart_init
0908fd5c g     F .text	000000e0 OS_TaskStat
090d3c5c g     O .bss	00000004 dsc_discovers
090d3ab0 g     O .rwdata	00000004 tse_mac_name
090d367c g     O .rwdata	00000018 tcp_protosw
090d3d74 g     O .bss	00000004 vfopen_error
09100000 g       *ABS*	00000000 __alt_stack_pointer
090d3ce8 g     O .bss	00000004 tcp_maxidle
090d3c88 g     O .bss	00000004 firstudp
0909a9f8 g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
0909b018 g     F .text	00000090 alt_avalon_timer_sc_init
0908d318 g     F .text	00000080 __clzsi2
09098f44 g     F .text	000002dc altera_avalon_jtag_uart_write
0909a424 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
09096744 g     F .text	0000009c alt_flash_cfi_init
09087bd4 g     F .text	00000004 __sfp_lock_acquire
0908937c g     F .text	000000e4 memchr
0908fa24 g     F .text	00000054 OS_MemClr
09084028 g     F .text	00001eac ___vfprintf_internal_r
090bae5c g     F .text	00000310 OSTaskStkInit
090837a0 g     F .text	00000060 _sprintf_r
0909a514 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
090880b4 g     F .text	00000314 _free_r
090c551c g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
090aeb20 g     F .text	000000d0 t_socketclose
0908f0a4 g     F .text	00000194 OS_EventTaskRdy
090cba14 g     F .text	000001b0 __call_exitprocs
090836cc g     F .text	0000004c __srget_r
090a15a8 g     F .text	000000a8 tse_sgdmaRx_isr
090d3be4 g     O .bss	00000001 OSCPUUsage
090dd798 g     O .bss	00000010 nets
090aa758 g     F .text	000000c0 LOCK_NET_RESOURCE
090a820c g     F .text	000000e4 dhc_resetip
090d3b90 g     O .bss	00000004 __mlocale_changed
090a17f8 g     F .text	00000250 tse_mac_rcv
090ad574 g     F .text	00000090 t_socket
090d3a2c g     O .rwdata	00000004 __malloc_sbrk_base
090802bc g     F .text	00000048 _start
090bc670 g     F .text	00000054 etainit
090d3cf8 g     O .bss	00000004 _alt_tick_rate
090bbf28 g     F .text	00000024 mcastlist
09092be4 g     F .text	00000320 OSQPend
090dd944 g     O .bss	000000f0 pktlog
090c502c g     F .text	0000014c igmpv2_process_report
090b2c48 g     F .text	00000080 ifd_isset
090c3c5c g     F .text	00000144 del_route
0909a83c g     F .text	00000058 alt_avalon_sgdma_open
09083fc8 g     F .text	00000008 _user_strerror
09095df0 g     F .text	0000014c OSTimeDly
09081868 g     F .text	00000050 get_mac_addr
090aef4c g     F .text	000000f0 solisten
09089f24 g     F .text	0000014c __lshift
090d3cfc g     O .bss	00000004 _alt_nticks
0909d5ac g     F .text	000000c4 alt_tse_phy_rd_mdio_reg
090a1d24 g     F .text	00000078 read
0909648c g     F .text	00000280 alt_sys_init
090b7958 g     F .text	0000004c tcp_quench
090a55a4 g     F .text	00000184 ns_printf
090bdc90 g     F .text	000000e0 isbcast
090aa8a0 g     F .text	00000214 TK_NEWTASK
090d3be5 g     O .bss	00000001 OSTaskCtr
090c0220 g     F .text	000000ec ip_reasm_determine_type_of_frag
090d3c14 g     O .bss	00000001 phy_profile_count
090cb554 g     F .text	000000f0 strncmp
0909c270 g     F .text	00000080 alt_tse_get_mac_group_index
0909705c g     F .text	00000044 alt_read_query_entry_16bit
09095f3c g     F .text	00000244 OSTimeDlyHMSM
090ba83c g     F .text	00000040 alt_remap_uncached
090c3250 g     F .text	000000c0 ip_raw_close
0908a070 g     F .text	000001e8 __multiply
090d38cc g     O .rwdata	000000b0 mdlist
09098b1c g     F .text	00000074 altera_avalon_jtag_uart_close
090a3288 g     F .text	000000f8 igmp_input
090beebc g     F .text	000000d8 ip_raw_write
090c8e60 g     F .text	000003e8 vfwrite_locked
090cb644 g     F .text	000000bc strncpy
090d3c60 g     O .bss	00000004 dsc_offers
090d539c g     O .bss	00000028 __malloc_current_mallinfo
090d3a46 g     O .rwdata	00000002 OSEventMax
090c749c g     F .text	00000074 inet_setport
09097354 g     F .text	000001e0 alt_set_flash_width_func
09089c1c g     F .text	0000017c __d2b
09094054 g     F .text	00000128 OSSemPost
090b5694 g     F .text	00000190 tcp_dooptions
090b1178 g     F .text	000000fc soisconnected
090804f4 g     F .text	00000038 ReadStatusReg
0908ec28 g     F .text	000000e4 OSSchedUnlock
090c3110 g     F .text	00000028 netexit
09081914 g     F .text	000001dc get_serial_number
090d3c44 g     O .bss	00000004 nettick_wakes
0909d430 g     F .text	00000054 alt_tse_phy_wr_mdio_addr
090d3cdc g     O .bss	00000001 tcpprintfs
090bc474 g     F .text	000000a8 in_timerkill
090c4ecc g     F .text	00000160 igmpv2_input
090d3c70 g     O .bss	00000004 dsc_declines
090984c4 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
090a4f5c g     F .text	0000002c do_trap
090c9fc0 g     F .text	000000f4 alt_get_fd
090a48f8 g     F .text	00000104 bsd_ioctl
090d3be8 g     O .bss	00000004 OSMemFreeList
0908ed7c g     F .text	000000ac OSStatInit
090abddc g     F .text	000001ec tcp_rcv
090a537c g     F .text	00000044 panic
090d3d7c g     O .bss	00000004 vfs_open_files
090c9bc0 g     F .text	0000012c alt_busy_sleep
090a2b44 g     F .text	000001a4 ip2mac
09091774 g     F .text	000000d4 OSFlagQuery
0908d7e4 g     F .text	000000c8 __fpcmp_parts_d
090b279c g     F .text	00000214 sock_select
090c6670 g     F .text	000002cc dhc_setup
090b70b4 g     F .text	00000058 tcp_init
090d3cb8 g     O .bss	00000004 cticks
090d3c4d g     O .bss	00000001 to_nettick
090d3a7c g     O .rwdata	00000002 OSTaskCreateExtEn
0908b1bc g     F .text	00000070 _close_r
090a1e0c g     F .text	0000064c Netinit
090aae90 g     F .text	00000038 prep_armintcp
090c2d8c g     F .text	00000168 in_addmulti
090b710c g     F .text	00000118 tcp_template
0909f7d8 g     F .text	0000031c alt_tse_phy_get_common_speed
090abbcc g     F .text	00000070 remque
090bb2e8 g     F .text	00000218 alt_erase_block_amd
090cb968 g     F .text	00000014 _vprintf_r
09080780 g     F .text	0000006c ReadDataFifo5
090b2d38 g     F .text	00000408 tcp_reass
090c765c g     F .text	000001cc tcp_cksum
090b9454 g     F .text	000003dc udp4_socksend
090c86cc g     F .text	000001a8 vfclose_locked
090b2bd4 g     F .text	00000074 ifd_set
090cb454 g     F .text	00000074 memcmp
0908f088 g     F .text	0000001c OS_Dummy
09098574 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
090a9428 g     F .text	000000b0 dhc_set_state
090d3c24 g     O .bss	00000004 NDEBUG
090de190 g       *ABS*	00000000 __alt_stack_base
090d3b74 g     O .bss	00000004 last_flash_sector
090985bc g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
090b1a00 g     F .text	00000060 sbreserve
090d3c15 g     O .bss	00000001 mac_group_count
090c3310 g     F .text	00000238 ip_raw_input
09083074 g     F .text	0000009c _fwrite_r
090d3ae8 g     O .rwdata	00000004 lilbufsiz
090b2cc8 g     F .text	00000070 ifd_get
090b18e4 g     F .text	0000009c sbwakeup
09086044 g     F .text	0000013c __swsetup_r
09097c3c g     F .text	000007ac alt_read_cfi_width
090a03e8 g     F .text	0000015c altera_eth_tse_init
090db7a0 g     O .bss	000001e0 OSQTbl
090b5950 g     F .text	000002a0 tcp_xmit_timer
090a1650 g     F .text	000001a8 tse_sgdma_read_init
0908c968 g     F .text	00000258 __divdf3
09087d4c g     F .text	000000f0 __sfp
09081af0 g     F .text	0000013c generate_mac_addr
090bdfa0 g     F .text	000001a4 ip_bldhead
09089a80 g     F .text	00000058 __copybits
09082d4c g     F .text	00000018 DataFifoReadout_Task
090b1aa8 g     F .text	000000a8 sbappend
090d1f7c g     O .rwdata	00000408 __malloc_av_
09087be0 g     F .text	00000004 __sinit_lock_release
090d3bec g     O .bss	00000004 OSTCBHighRdy
0908c5b4 g     F .text	000003b4 __muldf3
090beb0c g     F .text	000003b0 ip_write2
0908af74 g     F .text	00000060 __sread
090d3b50 g     O .rwdata	00000004 arp_ageout
090d3bf0 g     O .bss	00000004 OSQFreeList
0909e1e4 g     F .text	00000418 alt_tse_mac_get_phy
090bdea4 g     F .text	000000fc ip_init
090c9ea0 g     F .text	00000120 alt_find_file
090c3614 g     F .text	00000040 ip_raw_free
090bcfc8 g     F .text	00000114 make_arp_entry
090b9ce0 g     F .text	000000b4 alt_dev_llist_insert
0908decc g     F .text	00000108 __malloc_lock
09083040 g     F .text	00000034 _fprintf_r
0908dd08 g     F .text	000000bc sbrk
090b8c6c g     F .text	00000070 udp_lookup
0909a720 g     F .text	00000054 alt_avalon_sgdma_start
0908e1d4 g     F .text	00000144 OSEventNameSet
0908794c g     F .text	000001fc _fflush_r
0909c548 g     F .text	00000098 alt_tse_mac_set_duplex
0908b108 g     F .text	000000b4 _calloc_r
090d3bf4 g     O .bss	00000001 OSRdyGrp
090c6ab8 g     F .text	00000028 md_fopen
090d3694 g     O .rwdata	00000018 udp_protosw
090d3b2c g     O .rwdata	00000008 alt_flash_dev_list
090d7448 g     O .bss	000005dc rx_buf
090971e8 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
090c7dd4 g     F .text	0000007c in_setsockaddr
090d3b6c g       *ABS*	00000000 __bss_start
090b1b50 g     F .text	000000e0 sbappendrecord
090de0b0 g     O .bss	00000050 ip_mib
09083278 g     F .text	00000098 memset
090af694 g     F .text	000000a0 sodisconnect
090817ec g     F .text	0000007c main
090d3bb0 g     O .bss	00000004 alt_envp
090d3ba0 g     O .bss	00000004 __malloc_max_total_mem
090ab8fc g     F .text	000001d0 m_adj
0909851c g     F .text	00000058 altera_avalon_jtag_uart_write_fd
09086028 g     F .text	0000001c __swbuf
090c6d50 g     F .text	000000d8 md_fgetc
090cd840 g     O .rodata	00000100 OSUnMapTbl
090bfaf4 g     F .text	000002b8 ip_dump
090a6038 g     F .text	00000208 tk_stats
090d3ac4 g     O .rwdata	00000008 alt_iniche_dev_list
09099ff0 g     F .text	0000017c altera_avalon_lcd_16207_init
090d3ab8 g     O .rwdata	00000008 alt_sgdma_list
090d3a76 g     O .rwdata	00000002 OSSemEn
090d3ca0 g     O .bss	00000004 OS_TPS
090acd40 g     F .text	000007e8 rawip_usrreq
090913cc g     F .text	000003a8 OSFlagPost
0908ae88 g     F .text	00000008 __sclose
090c7378 g     F .text	00000060 print46_addr
09100000 g       *ABS*	00000000 __alt_heap_limit
0908b33c g     F .text	00000014 fclose
0908f238 g     F .text	00000110 OS_EventTaskWait
090cb700 g     F .text	00000244 _strtol_r
090a51c0 g     F .text	000001bc print_uptime
0908fe3c g     F .text	000000c8 OS_TaskStatStkChk
09095104 g     F .text	00000170 OSTaskDelReq
09086398 g     F .text	000015b4 _dtoa_r
09088c3c g     F .text	00000740 _malloc_r
090c6e28 g     F .text	00000024 md_unlink
0909b2c8 g     F .text	00000094 tse_mac_SwReset
090c78bc g     F .text	00000054 in_pcbdetach
090d3b28 g     O .rwdata	00000004 alt_errno
090d3b60 g     O .rwdata	00000004 mdlist_size
0908ed0c g     F .text	00000070 OSStart
09097274 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
090c5f88 g     F .text	00000030 u_mctest_init
0908de70 g     F .text	0000005c __env_unlock
0908892c g     F .text	000000b8 _fwalk
090955f0 g     F .text	00000218 OSTaskResume
090922e8 g     F .text	000000fc OSMemQuery
090c7510 g     F .text	0000014c convert_ip
090bcdd4 g     F .text	000001f4 find_oldest_arp
090d3a88 g     O .rwdata	00000002 OSTaskStatEn
090d3d1c g     O .bss	00000004 arpReqsIn
090c82c4 g     F .text	00000050 vf_free_buffer
09096bd0 g     F .text	00000164 alt_write_value_to_flash
090c9cec g     F .text	00000154 alt_fcntl
090d3a62 g     O .rwdata	00000002 OSMemMax
09093200 g     F .text	00000188 OSQPostFront
090972f0 g     F .text	00000034 alt_write_native_16bit
090aa478 g     F .text	00000030 dtrap
090d3af4 g     O .rwdata	00000004 kb_last
09083408 g     F .text	00000104 putc
09080000 g       *ABS*	00000000 __alt_mem_onchip_SRAM
0908d248 g     F .text	00000060 __divsi3
0909c1ac g     F .text	00000048 alt_tse_mac_set_common_speed
090d3bf5 g     O .bss	00000003 OSRdyTbl
090d3a3c g     O .rwdata	00000002 OSDebugEn
090cd71c g     O .rodata	00000014 __thenan_df
090a3038 g     F .text	000000d0 ip_exit
09087f88 g     F .text	0000012c _malloc_trim_r
090d3a54 g     O .rwdata	00000002 OSFlagNodeSize
090d3c54 g     O .bss	00000004 dhc_conn
090aa60c g     F .text	000000ac cticks_hook
090d3a9c g     O .rwdata	00000002 OSTmrCfgMax
090bbe4c g     F .text	00000090 sysuptime
0908afd4 g     F .text	000000bc strcmp
090c186c g     F .text	000001c8 ip_reasm_delete_ire
09092608 g     F .text	00000214 OSQCreate
090aa6b8 g     F .text	0000005c irq_Mask
09095274 g     F .text	000001b8 OSTaskNameGet
090d3d08 g     O .bss	00000004 nextppp
090d3c94 g     O .bss	00000004 irq_level
090a2458 g     F .text	00000160 fixup_subnet_mask
09093388 g     F .text	00000234 OSQPostOpt
0908ee28 g     F .text	00000240 OSTimeTick
090c0018 g     F .text	00000138 ip_copypkt
090a9324 g     F .text	00000090 dhc_alldone
090d3a84 g     O .rwdata	00000002 OSTaskMax
090938a8 g     F .text	00000114 OSSemCreate
090d3c38 g     O .bss	00000004 igmp_all_hosts_group
090d3aa8 g     O .rwdata	00000002 OSTmrWheelSize
090b1844 g     F .text	00000038 sbselqueue
090d3c40 g     O .bss	00000004 netmain_wakes
090bd370 g     F .text	00000260 arprcv
090a5c84 g     F .text	00000070 TK_OSTaskResume
090a3eb0 g     F .text	000003e0 igmp_print_stats
0908cc48 g     F .text	00000088 __nedf2
090ab148 g     F .text	000000a0 pffindtype
090d3a7e g     O .rwdata	00000002 OSTaskDelEn
090d3b0c g     O .rwdata	00000004 tcp_sendspace
090c9424 g     F .text	00000134 vftell
090dd80c g     O .bss	00000012 eth_prt_buf
0909417c g     F .text	00000130 OSSemQuery
0909281c g     F .text	00000300 OSQDel
09092f04 g     F .text	0000017c OSQPendAbort
09096458 g     F .text	00000034 alt_irq_init
0909c16c g     F .text	00000040 alt_tse_mac_get_common_speed
090ddc74 g     O .bss	00000018 app_semaphore
090ba7a4 g     F .text	00000060 alt_release_fd
090aab68 g     F .text	00000078 post_app_sem
090a3198 g     F .text	000000f0 igmp_init
0908372c g     F .text	00000074 sprintf
090cd730 g     O .rodata	00000100 __clz_tab
090d3c7c g     O .bss	00000004 dsc_renew
090c6c80 g     F .text	00000080 md_fwrite
090d3b94 g     O .bss	00000004 _PathLocale
090d3ca4 g     O .bss	00000004 tcp_sleep_count
090abc3c g     F .text	0000007c insque
090d3d70 g     O .bss	00000004 vfsfiles
0908b090 g     F .text	00000078 _write_r
090cb99c g     F .text	00000050 _vsprintf_r
090c45f8 g     F .text	000002b8 udp_send
0908eb9c g     F .text	0000008c OSSchedLock
090a35b4 g     F .text	000002a8 igmp_send
09088a8c g     F .text	0000001c setlocale
090d7a24 g     O .bss	000005dc tx_buf
090906a4 g     F .text	0000013c OSFlagCreate
090aa714 g     F .text	00000044 irq_Unmask
090ad780 g     F .text	000000e4 t_listen
090d3a18 g     O .rwdata	00000004 _impure_ptr
090d1a38 g     O .rwdata	00000018 ssstask
090d3ba8 g     O .bss	00000004 alt_argc
090b8234 g     F .text	00000704 tcp_usrreq
090b8e94 g     F .text	00000284 udp_usrreq
090ab0a8 g     F .text	00000054 ncpalloc
09081d0c g     F .text	00001040 sss_udp_process
09080488 g     F .text	0000006c ReadCfgFifo
090d3a4e g     O .rwdata	00000002 OSEventMultiEn
090d3b48 g     O .rwdata	00000004 pingdelay
090bc8c8 g     F .text	00000074 arp_send_pending
090dd224 g     O .bss	000000e0 tse_mac_if
090c4bdc g     F .text	000002f0 igmpv1_input
0908abc8 g     F .text	000001c4 __srefill_r
090aadfc g     F .text	00000074 pre_task_setup
090d3cc4 g     O .bss	00000004 rcvdq_sem_ptr
090a44f4 g     F .text	0000012c bsd_getsockname
090c1a34 g     F .text	00000148 ip_reasm_mark_compact_rfq
090907e0 g     F .text	000002a8 OSFlagDel
090d3bf8 g     O .bss	00000004 OSEventFreeList
090a638c g     F .text	00000044 dhc_set_callback
09080120 g       .exceptions	00000000 alt_irq_entry
090d3d18 g     O .bss	00000004 arpcache
090cace8 g     F .text	00000350 icmp_destun
090c300c g     F .text	00000070 lookup_mcast
090c97f8 g     F .text	00000048 vfslookup
090c295c g     F .text	00000430 ip_demux
0908979c g     F .text	00000080 __ulp
0908ada8 g     F .text	00000040 __isinfd
090d3ca8 g     O .bss	00000004 tcp_wakeup_count
09090d20 g     F .text	00000644 OSFlagPend
090d3a9a g     O .rwdata	00000002 OSTmrEn
09087c98 g     F .text	00000018 __fp_unlock_all
090aaab4 g     F .text	000000b4 wait_app_sem
0909a16c g     F .text	00000058 altera_avalon_lcd_16207_write_fd
09087e3c g     F .text	00000064 fputc
090d3acc g     O .rwdata	00000004 ipmcfail_str
090d3cbc g     O .bss	00000004 memtrapsize
090ab5d8 g     F .text	00000324 m_copy
090d3b14 g     O .rwdata	00000008 alt_fs_list
090ddcf0 g     O .bss	00000014 mfreeq
0908fc28 g     F .text	00000080 OS_StrCopy
090aeef0 g     F .text	0000005c sobind
090c6a40 g     F .text	00000078 init_memdev
090d3b6c g     O .bss	00000001 to_ssstask
090971a0 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
090abcb8 g     F .text	00000124 nptcp_init
090d3a64 g     O .rwdata	00000002 OSMemNameSize
090ddb44 g     O .bss	000000f0 global_TCPwakeup_set
090bb228 g     F .text	0000001c OSInitHookEnd
090b1300 g     F .text	000000bc soisdisconnected
0908052c g     F .text	00000038 ReadDataFifoStatus
090bc840 g     F .text	00000088 arp_free_pending
090d3a90 g     O .rwdata	00000002 OSTCBPrioTblMax
090889f8 g     F .text	00000010 localeconv
090af16c g     F .text	00000368 soclose
090dda34 g     O .bss	00000014 bigfreeq
090d3a8c g     O .rwdata	00000002 OSTaskStatStkChkEn
090d3b44 g     O .rwdata	00000004 prompt
090d3b04 g     O .rwdata	00000004 tcp_keepidle
0909f640 g     F .text	00000198 alt_tse_phy_set_adv_10
090acb6c g     F .text	000001d4 rawip_soinput
090b9f58 g     F .text	00000050 alt_ic_isr_register
090c9248 g     F .text	00000060 vfwrite
090d3a60 g     O .rwdata	00000002 OSMemEn
090b15d8 g     F .text	000000ac soqinsque
090d3d4c g     O .bss	00000004 so_evtmap_delete
09083110 g     F .text	00000040 fwrite
090d3a6a g     O .rwdata	00000002 OSMutexEn
090d3d38 g     O .bss	00000004 h_ireq
090d3b6c g       *ABS*	00000000 _edata
090bf41c g     F .text	0000062c ip_fragment
090a1be0 g     F .text	00000144 iniche_devices_init
090ddd04 g     O .bss	00000028 tcp_saveti
090a576c g     F .text	000000f8 con_page
090de190 g       *ABS*	00000000 _end
090b0b88 g     F .text	00000540 sogetopt
090b9e88 g     F .text	0000007c alt_flash_open_dev
090d3bfc g     O .bss	00000001 OSIntNesting
0909e5fc g     F .text	00000238 alt_tse_mac_associate_phy
090d364c g     O .rwdata	00000030 nettasks
090a9c74 g     F .text	00000020 pk_get_max_intrsafe_buf_len
090bfdac g     F .text	0000026c iproute
090ac600 g     F .text	000000e8 np_stripoptions
090d3d50 g     O .bss	00000001 so_evtmap
09098b90 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
09087ef8 g     F .text	00000074 _fputs_r
09096180 g     F .text	00000210 OSTimeDlyResume
09081c48 g     F .text	0000001c SSSCreateTasks
090c3834 g     F .text	00000428 add_route
09090bcc g     F .text	00000154 OSFlagNameSet
090a2a74 g     F .text	000000d0 c_older
090b2020 g     F .text	00000090 sbflush
090c6ae0 g     F .text	00000020 md_fclose
090a600c g     F .text	0000002c tk_yield
09095808 g     F .text	000001fc OSTaskStkChk
090ba044 g     F .text	000000a0 alt_ic_irq_disable
090af734 g     F .text	00000608 sosend
090d3a66 g     O .rwdata	00000002 OSMemSize
090bfa48 g     F .text	000000ac ip_mymach
0909a8f4 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0908aef8 g     F .text	0000007c __swrite
090d3c90 g     O .bss	00000004 cticks_initialized
090d3b4c g     O .rwdata	00000004 deflength
090d3a28 g     O .rwdata	00000004 __malloc_trim_threshold
090ae5e8 g     F .text	0000022c t_sendto
09083310 g     F .text	0000006c _perror_r
090bad6c g     F .text	00000020 altera_nios2_qsys_irq_init
090d3c00 g     O .bss	00000004 OSTCBCur
06020000 g     F .entry	00000038 exit
090aed24 g     F .text	000001cc socreate
090ddf9c g     O .bss	00000100 arp_table
090d3d88 g     O .bss	00000004 icmpdu_hook
090d3a68 g     O .rwdata	00000002 OSMemTblSize
09088864 g     F .text	000000c8 _fwalk_reent
090bc51c g     F .text	00000024 create_apptasks
090d3b00 g     O .rwdata	00000004 tcp_ttl
09089d98 g     F .text	0000018c __mdiff
090b9f04 g     F .text	00000054 alt_flash_close_dev
090ab0fc g     F .text	0000004c ncpfree
0908d2a8 g     F .text	00000060 __modsi3
090d3c1c g     O .bss	00000004 MaxLnh
0909b3b4 g     F .text	00000054 tse_mac_setGMIImode
090c72ec g     F .text	0000008c inet_ntop
090c4b70 g     F .text	0000002c udp_maxalloc
090a0080 g     F .text	000000f4 marvell_cfg_gmii
09100000 g       *ABS*	00000000 __alt_data_end
09080120 g     F .exceptions	00000000 alt_exception
09087bd8 g     F .text	00000004 __sfp_lock_release
0908e9cc g     F .text	00000054 OSInit
0909e834 g     F .text	00000120 alt_tse_phy_cfg_pcs
09095c30 g     F .text	00000144 OSTaskQuery
090bbc3c g     F .text	00000088 icmp_port_du
090d3cec g     O .bss	00000004 tcp_iss
0909373c g     F .text	000000ac OS_QInit
090cb3cc g     F .text	0000000c atoi
090d3af0 g     O .rwdata	00000004 bigbufsiz
0908fca8 g     F .text	00000058 OS_StrLen
090b79a4 g     F .text	00000080 tcp_putseq
09080714 g     F .text	0000006c ReadDataFifo4
090920d8 g     F .text	00000120 OSMemNameSet
090ccaf4 g     O .rodata	00000101 _ctype_
090b1c30 g     F .text	00000208 sbappendaddr
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
090d3d80 g     O .bss	00000004 vfs_total_rw_space
090c5dc4 g     F .text	00000140 ip_getmoptions
090d3a82 g     O .rwdata	00000002 OSTaskProfileEn
090c48b0 g     F .text	00000130 udpswap
090d3c04 g     O .bss	00000004 OSTime
090d3cc8 g     O .bss	00000004 nextslow
090b7a9c g     F .text	000002a0 tcp_slowtimo
090d8000 g     O .bss	00002000 databuf
090b76ac g     F .text	00000118 tcp_newtcpcb
090bd5d0 g     F .text	000001cc send_via_arp
090a62d0 g     F .text	000000bc dhc_init
090c1390 g     F .text	00000064 ip_reasm_find_ire
090db980 g     O .bss	00000800 OSTaskIdleStk
090c9a28 g     F .text	00000064 isvfile_locked
0908ade8 g     F .text	00000030 __isnand
06020000 g       .entry	00000000 _exit
090a4b8c g     F .text	000001cc bsd_select
090b998c g     F .text	00000154 alt_alarm_start
09090a88 g     F .text	00000144 OSFlagNameGet
090c4b9c g     F .text	00000040 udp_free
090a9d40 g     F .text	000000c8 getq
090c9b9c g     F .text	00000024 prep_vfs
09096390 g     F .text	00000064 OSTimeGet
090d3b40 g     O .rwdata	00000004 name
090b2280 g     F .text	00000110 sbdropend
09088aa8 g     F .text	00000194 __smakebuf_r
09097324 g     F .text	00000030 alt_write_native_32bit
090bd79c g     F .text	000001a4 cb_arpent_tmo
09083f54 g     F .text	00000074 strlen
090c568c g     F .text	00000148 IPADDR_TO_NETP
090a49fc g     F .text	00000030 bsd_inet_ntoa
090bb1ac g     F .text	0000001c OSTaskSwHook
090ba43c g     F .text	00000188 open
090a9fc8 g     F .text	00000238 udp_open
090dc180 g     O .bss	00000b40 OSEventTbl
090b17a4 g     F .text	00000050 socantsendmore
090d3d84 g     O .bss	00000004 vfs_total_dyna_files
0908cd58 g     F .text	00000088 __gedf2
090dccc0 g     O .bss	00000510 OSTCBTbl
090d3d20 g     O .bss	00000004 arpReqsOut
090942ac g     F .text	00000104 OSSemSet
090d3b68 g     O .rwdata	00000004 http_root_path
090a84d4 g     F .text	000002bc dhc_extract_opts
090c086c g     F .text	00000590 ip_reasm_compute_overlap
09096ad8 g     F .text	00000090 alt_flash_cfi_get_info
0909b224 g     F .text	000000a4 tse_mac_aRxRead
09083800 g     F .text	000000e0 strchr
090dd81e g     O .bss	00000012 ipreturn
090d3d40 g     O .bss	00000004 port_prep
090d36cf g     O .rwdata	0000000d tcp_backoff
090b110c g     F .text	0000006c soisconnecting
09081774 g     F .text	00000078 SSSInitialTask
09087f6c g     F .text	0000001c fputs
090d3b34 g     O .rwdata	00000004 alt_priority_mask
090c5178 g     F .text	0000024c igmpv2_process_query
090b2424 g     F .text	00000220 t_select
090939bc g     F .text	000002a0 OSSemDel
090b9830 g     F .text	0000015c udp4_sockaddr
090d3c08 g     O .bss	00000004 OSFlagFreeList
090c7b64 g     F .text	00000210 in_pcbconnect
090d3ce0 g     O .bss	00000004 dropline
090d3d3c g     O .bss	00000004 ire_cticks
090b9fa8 g     F .text	0000009c alt_ic_irq_enable
090d3a48 g     O .rwdata	00000002 OSEventNameSize
09085ed4 g     F .text	00000024 __vfprintf_internal
090a5b84 g     F .text	00000088 tk_netmain
090c7d74 g     F .text	00000060 in_pcbdisconnect
090d3c0c g     O .bss	00000001 OSStatRdy
090dd1d0 g     O .bss	00000054 OSTCBPrioTbl
0908ddc4 g     F .text	000000ac __env_lock
090d3a8e g     O .rwdata	00000002 OSTaskSwHookEn
090d38a8 g     O .rwdata	00000024 mdio
0909c45c g     F .text	000000ec alt_tse_mac_set_speed
090a4290 g     F .text	00000138 bsd_accept
0909a494 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
090d3b10 g     O .rwdata	00000004 tcp_recvspace
0908c4c0 g     F .text	00000080 __subdf3
090b8c20 g     F .text	0000004c tcpinit
090d3c3c g     O .bss	00000004 igmp_all_rtrs_group
090acafc g     F .text	00000070 rawip_lookup
090bc5c0 g     F .text	000000b0 fcntl
09089678 g     F .text	000000c4 __lo0bits
090b1e38 g     F .text	000001e8 sbcompress
090d3b38 g     O .rwdata	00000008 alt_alarm_list
090b77c4 g     F .text	000000ac tcp_drop
090d3a56 g     O .rwdata	00000002 OSFlagWidth
0909f430 g     F .text	00000210 alt_tse_phy_set_adv_100
090b7d98 g     F .text	0000049c tcp_timers
090a3108 g     F .text	00000090 if_netnumber
090c5f04 g     F .text	00000084 ip_freemoptions
090b10c8 g     F .text	00000044 sohasoutofband
090b3140 g     F .text	00002554 tcp_input
090a43c8 g     F .text	0000012c bsd_getpeername
090a4a2c g     F .text	00000160 bsd_recvfrom
090a1b8c g     F .text	00000054 close
090d3c6c g     O .bss	00000004 dsc_bpreplys
090bb280 g     F .text	00000068 alt_program_amd
090d3bb8 g     O .bss	00000004 alt_envsem
090d3c10 g     O .bss	00000004 OSIdleCtrRun
0908f068 g     F .text	00000020 OSVersion
090d3aa0 g     O .rwdata	00000002 OSTmrCfgWheelSize
09095d74 g     F .text	0000007c OS_TaskStkClr
090c8128 g     F .text	00000028 set_vfopen_error
0908d398 g     F .text	00000314 __pack_d
090d3a7a g     O .rwdata	00000002 OSTaskCreateEn
0909c1f4 g     F .text	0000007c alt_tse_get_system_index
090d36ac g     O .rwdata	00000018 rawip_protosw
090b187c g     F .text	00000068 sbwait
0908f658 g     F .text	00000068 OS_EventWaitListInit
090a8790 g     F .text	000008dc dhc_second
0909aefc g     F .text	000000ac alt_avalon_sgdma_init
090d3d0c g     O .bss	00000004 port_1s_callout
090bb244 g     F .text	0000001c OSTaskIdleHook
090cb42c g     F .text	00000014 free
09087bdc g     F .text	00000004 __sinit_lock_acquire
090d3c18 g     O .bss	00000001 number_of_tse_mac
0908a294 g     F .text	00000100 __multadd
09095a04 g     F .text	0000022c OSTaskSuspend
090895e0 g     F .text	00000028 _Bfree
0909b0a8 g     F .text	0000002c no_printf
090b13bc g     F .text	0000021c sonewconn
090ca0b4 g     F .text	00000c34 icmprcv
090ab1e8 g     F .text	000000d0 pffindproto
0908fd00 g     F .text	0000005c OS_TaskIdle
090d3aa6 g     O .rwdata	00000002 OSTmrTblSize
090935bc g     F .text	00000180 OSQQuery



Disassembly of section .exceptions:

09080120 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 9080120:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 9080124:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 9080128:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 908012c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 9080130:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 9080134:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 9080138:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 908013c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 9080140:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 9080144:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 9080148:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 908014c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 9080150:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 9080154:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 9080158:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 908015c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 9080160:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 9080164:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 9080168:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 908016c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 9080170:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 9080174:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 9080178:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 908017c:	10000326 	beq	r2,zero,908018c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 9080180:	20000226 	beq	r4,zero,908018c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 9080184:	90801ec0 	call	90801ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 9080188:	00000306 	br	9080198 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 908018c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 9080190:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 9080194:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 9080198:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 908019c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 90801a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 90801a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 90801a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 90801ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 90801b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 90801b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 90801b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 90801bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 90801c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 90801c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 90801c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 90801cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 90801d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 90801d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 90801d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 90801dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 90801e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 90801e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 90801e8:	ef80083a 	eret

090801ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 90801ec:	defff904 	addi	sp,sp,-28
 90801f0:	dfc00615 	stw	ra,24(sp)
 90801f4:	df000515 	stw	fp,20(sp)
 90801f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 90801fc:	908ea200 	call	908ea20 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 9080200:	0005313a 	rdctl	r2,ipending
 9080204:	e0bffc15 	stw	r2,-16(fp)

  return active;
 9080208:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 908020c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 9080210:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 9080214:	00800044 	movi	r2,1
 9080218:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 908021c:	e0ffff17 	ldw	r3,-4(fp)
 9080220:	e0bffe17 	ldw	r2,-8(fp)
 9080224:	1884703a 	and	r2,r3,r2
 9080228:	1005003a 	cmpeq	r2,r2,zero
 908022c:	1000161e 	bne	r2,zero,9080288 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 9080230:	e0bffd17 	ldw	r2,-12(fp)
 9080234:	00c243b4 	movhi	r3,2318
 9080238:	18f78e04 	addi	r3,r3,-8648
 908023c:	100490fa 	slli	r2,r2,3
 9080240:	10c5883a 	add	r2,r2,r3
 9080244:	11400017 	ldw	r5,0(r2)
 9080248:	e0bffd17 	ldw	r2,-12(fp)
 908024c:	00c243b4 	movhi	r3,2318
 9080250:	18f78e04 	addi	r3,r3,-8648
 9080254:	100490fa 	slli	r2,r2,3
 9080258:	10c5883a 	add	r2,r2,r3
 908025c:	10800104 	addi	r2,r2,4
 9080260:	11000017 	ldw	r4,0(r2)
 9080264:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 9080268:	0005313a 	rdctl	r2,ipending
 908026c:	e0bffb15 	stw	r2,-20(fp)

  return active;
 9080270:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 9080274:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 9080278:	e0bfff17 	ldw	r2,-4(fp)
 908027c:	1004c03a 	cmpne	r2,r2,zero
 9080280:	103fe31e 	bne	r2,zero,9080210 <alt_irq_handler+0x24>
 9080284:	00000706 	br	90802a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 9080288:	e0bffe17 	ldw	r2,-8(fp)
 908028c:	1085883a 	add	r2,r2,r2
 9080290:	e0bffe15 	stw	r2,-8(fp)
      i++;
 9080294:	e0bffd17 	ldw	r2,-12(fp)
 9080298:	10800044 	addi	r2,r2,1
 908029c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 90802a0:	003fde06 	br	908021c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 90802a4:	908ea9c0 	call	908ea9c <OSIntExit>
}
 90802a8:	e037883a 	mov	sp,fp
 90802ac:	dfc00117 	ldw	ra,4(sp)
 90802b0:	df000017 	ldw	fp,0(sp)
 90802b4:	dec00204 	addi	sp,sp,8
 90802b8:	f800283a 	ret

Disassembly of section .text:

090802bc <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 90802bc:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 90802c0:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 90802c4:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 90802c8:	00bffd16 	blt	zero,r2,90802c0 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 90802cc:	06c24434 	movhi	sp,2320
    ori sp, sp, %lo(__alt_stack_pointer)
 90802d0:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 90802d4:	06824374 	movhi	gp,2317
    ori gp, gp, %lo(_gp)
 90802d8:	d6ae8514 	ori	gp,gp,47636
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 90802dc:	00824374 	movhi	r2,2317
    ori r2, r2, %lo(__bss_start)
 90802e0:	108edb14 	ori	r2,r2,15212

    movhi r3, %hi(__bss_end)
 90802e4:	00c24374 	movhi	r3,2317
    ori r3, r3, %lo(__bss_end)
 90802e8:	18f86414 	ori	r3,r3,57744

    beq r2, r3, 1f
 90802ec:	10c00326 	beq	r2,r3,90802fc <_start+0x40>

0:
    stw zero, (r2)
 90802f0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 90802f4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 90802f8:	10fffd36 	bltu	r2,r3,90802f0 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 90802fc:	908dc500 	call	908dc50 <alt_main>

09080300 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 9080300:	003fff06 	br	9080300 <alt_after_alt_main>

09080304 <WriteCommandReg>:

/* MicroC/OS-II definitions */
#include "includes.h"

int WriteCommandReg(INT32U val)
{
 9080304:	defffe04 	addi	sp,sp,-8
 9080308:	df000115 	stw	fp,4(sp)
 908030c:	df000104 	addi	fp,sp,4
 9080310:	e13fff15 	stw	r4,-4(fp)
	IOWR(TOFPET_AVALON_MM_IF_0_BASE, 0x0B, val);
 9080314:	e0ffff17 	ldw	r3,-4(fp)
 9080318:	00800b04 	movi	r2,44
 908031c:	10c00035 	stwio	r3,0(r2)
	return 0;
 9080320:	0005883a 	mov	r2,zero
}
 9080324:	e037883a 	mov	sp,fp
 9080328:	df000017 	ldw	fp,0(sp)
 908032c:	dec00104 	addi	sp,sp,4
 9080330:	f800283a 	ret

09080334 <WriteNbitReg>:

int WriteNbitReg(INT32U val)
{
 9080334:	defffe04 	addi	sp,sp,-8
 9080338:	df000115 	stw	fp,4(sp)
 908033c:	df000104 	addi	fp,sp,4
 9080340:	e13fff15 	stw	r4,-4(fp)
	IOWR(TOFPET_AVALON_MM_IF_0_BASE, 0x0A, val);
 9080344:	e0ffff17 	ldw	r3,-4(fp)
 9080348:	00800a04 	movi	r2,40
 908034c:	10c00035 	stwio	r3,0(r2)
	return 0;
 9080350:	0005883a 	mov	r2,zero
}
 9080354:	e037883a 	mov	sp,fp
 9080358:	df000017 	ldw	fp,0(sp)
 908035c:	dec00104 	addi	sp,sp,4
 9080360:	f800283a 	ret

09080364 <WriteCfgFifo>:

int WriteCfgFifo(int ndata, INT32U *val)
{
 9080364:	defffc04 	addi	sp,sp,-16
 9080368:	df000315 	stw	fp,12(sp)
 908036c:	df000304 	addi	fp,sp,12
 9080370:	e13ffe15 	stw	r4,-8(fp)
 9080374:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080378:	e03ffd15 	stw	zero,-12(fp)
 908037c:	00000d06 	br	90803b4 <WriteCfgFifo+0x50>
		IOWR(TOFPET_AVALON_MM_IF_0_BASE, 0x09, val[i]);
 9080380:	e0bffd17 	ldw	r2,-12(fp)
 9080384:	1085883a 	add	r2,r2,r2
 9080388:	1085883a 	add	r2,r2,r2
 908038c:	1007883a 	mov	r3,r2
 9080390:	e0bfff17 	ldw	r2,-4(fp)
 9080394:	1885883a 	add	r2,r3,r2
 9080398:	10800017 	ldw	r2,0(r2)
 908039c:	1007883a 	mov	r3,r2
 90803a0:	00800904 	movi	r2,36
 90803a4:	10c00035 	stwio	r3,0(r2)
}

int WriteCfgFifo(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 90803a8:	e0bffd17 	ldw	r2,-12(fp)
 90803ac:	10800044 	addi	r2,r2,1
 90803b0:	e0bffd15 	stw	r2,-12(fp)
 90803b4:	e0fffd17 	ldw	r3,-12(fp)
 90803b8:	e0bffe17 	ldw	r2,-8(fp)
 90803bc:	18bff016 	blt	r3,r2,9080380 <WriteCfgFifo+0x1c>
		IOWR(TOFPET_AVALON_MM_IF_0_BASE, 0x09, val[i]);
	return 0;
 90803c0:	0005883a 	mov	r2,zero
}
 90803c4:	e037883a 	mov	sp,fp
 90803c8:	df000017 	ldw	fp,0(sp)
 90803cc:	dec00104 	addi	sp,sp,4
 90803d0:	f800283a 	ret

090803d4 <ReadDummyReg>:

int ReadDummyReg(int x, INT32U *val)
{
 90803d4:	defffd04 	addi	sp,sp,-12
 90803d8:	df000215 	stw	fp,8(sp)
 90803dc:	df000204 	addi	fp,sp,8
 90803e0:	e13ffe15 	stw	r4,-8(fp)
 90803e4:	e17fff15 	stw	r5,-4(fp)
	*val = IORD(TOFPET_AVALON_MM_IF_0_BASE, x);
 90803e8:	e0bffe17 	ldw	r2,-8(fp)
 90803ec:	1085883a 	add	r2,r2,r2
 90803f0:	1085883a 	add	r2,r2,r2
 90803f4:	10800037 	ldwio	r2,0(r2)
 90803f8:	1007883a 	mov	r3,r2
 90803fc:	e0bfff17 	ldw	r2,-4(fp)
 9080400:	10c00015 	stw	r3,0(r2)
	return 0;
 9080404:	0005883a 	mov	r2,zero
}
 9080408:	e037883a 	mov	sp,fp
 908040c:	df000017 	ldw	fp,0(sp)
 9080410:	dec00104 	addi	sp,sp,4
 9080414:	f800283a 	ret

09080418 <ReadCommandReg>:

int ReadCommandReg(INT32U *val)
{
 9080418:	defffe04 	addi	sp,sp,-8
 908041c:	df000115 	stw	fp,4(sp)
 9080420:	df000104 	addi	fp,sp,4
 9080424:	e13fff15 	stw	r4,-4(fp)
	*val = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x0B);
 9080428:	00800b04 	movi	r2,44
 908042c:	10800037 	ldwio	r2,0(r2)
 9080430:	1007883a 	mov	r3,r2
 9080434:	e0bfff17 	ldw	r2,-4(fp)
 9080438:	10c00015 	stw	r3,0(r2)
	return 0;
 908043c:	0005883a 	mov	r2,zero
}
 9080440:	e037883a 	mov	sp,fp
 9080444:	df000017 	ldw	fp,0(sp)
 9080448:	dec00104 	addi	sp,sp,4
 908044c:	f800283a 	ret

09080450 <ReadNbitReg>:

int ReadNbitReg(INT32U *val)
{
 9080450:	defffe04 	addi	sp,sp,-8
 9080454:	df000115 	stw	fp,4(sp)
 9080458:	df000104 	addi	fp,sp,4
 908045c:	e13fff15 	stw	r4,-4(fp)
	*val = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x0A);
 9080460:	00800a04 	movi	r2,40
 9080464:	10800037 	ldwio	r2,0(r2)
 9080468:	1007883a 	mov	r3,r2
 908046c:	e0bfff17 	ldw	r2,-4(fp)
 9080470:	10c00015 	stw	r3,0(r2)
	return 0;
 9080474:	0005883a 	mov	r2,zero
}
 9080478:	e037883a 	mov	sp,fp
 908047c:	df000017 	ldw	fp,0(sp)
 9080480:	dec00104 	addi	sp,sp,4
 9080484:	f800283a 	ret

09080488 <ReadCfgFifo>:

int ReadCfgFifo(int ndata, INT32U *val)
{
 9080488:	defffc04 	addi	sp,sp,-16
 908048c:	df000315 	stw	fp,12(sp)
 9080490:	df000304 	addi	fp,sp,12
 9080494:	e13ffe15 	stw	r4,-8(fp)
 9080498:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 908049c:	e03ffd15 	stw	zero,-12(fp)
 90804a0:	00000c06 	br	90804d4 <ReadCfgFifo+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x08);
 90804a4:	e0bffd17 	ldw	r2,-12(fp)
 90804a8:	1085883a 	add	r2,r2,r2
 90804ac:	1085883a 	add	r2,r2,r2
 90804b0:	1007883a 	mov	r3,r2
 90804b4:	e0bfff17 	ldw	r2,-4(fp)
 90804b8:	1887883a 	add	r3,r3,r2
 90804bc:	00800804 	movi	r2,32
 90804c0:	10800037 	ldwio	r2,0(r2)
 90804c4:	18800015 	stw	r2,0(r3)
}

int ReadCfgFifo(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 90804c8:	e0bffd17 	ldw	r2,-12(fp)
 90804cc:	10800044 	addi	r2,r2,1
 90804d0:	e0bffd15 	stw	r2,-12(fp)
 90804d4:	e0fffd17 	ldw	r3,-12(fp)
 90804d8:	e0bffe17 	ldw	r2,-8(fp)
 90804dc:	18bff116 	blt	r3,r2,90804a4 <ReadCfgFifo+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x08);
	return 0;
 90804e0:	0005883a 	mov	r2,zero
}
 90804e4:	e037883a 	mov	sp,fp
 90804e8:	df000017 	ldw	fp,0(sp)
 90804ec:	dec00104 	addi	sp,sp,4
 90804f0:	f800283a 	ret

090804f4 <ReadStatusReg>:

int ReadStatusReg(INT32U *val)
{
 90804f4:	defffe04 	addi	sp,sp,-8
 90804f8:	df000115 	stw	fp,4(sp)
 90804fc:	df000104 	addi	fp,sp,4
 9080500:	e13fff15 	stw	r4,-4(fp)
	*val = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x0C);
 9080504:	00800c04 	movi	r2,48
 9080508:	10800037 	ldwio	r2,0(r2)
 908050c:	1007883a 	mov	r3,r2
 9080510:	e0bfff17 	ldw	r2,-4(fp)
 9080514:	10c00015 	stw	r3,0(r2)
	return 0;
 9080518:	0005883a 	mov	r2,zero
}
 908051c:	e037883a 	mov	sp,fp
 9080520:	df000017 	ldw	fp,0(sp)
 9080524:	dec00104 	addi	sp,sp,4
 9080528:	f800283a 	ret

0908052c <ReadDataFifoStatus>:

int ReadDataFifoStatus(INT32U *val)
{
 908052c:	defffe04 	addi	sp,sp,-8
 9080530:	df000115 	stw	fp,4(sp)
 9080534:	df000104 	addi	fp,sp,4
 9080538:	e13fff15 	stw	r4,-4(fp)
	*val = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x06);
 908053c:	00800604 	movi	r2,24
 9080540:	10800037 	ldwio	r2,0(r2)
 9080544:	1007883a 	mov	r3,r2
 9080548:	e0bfff17 	ldw	r2,-4(fp)
 908054c:	10c00015 	stw	r3,0(r2)
	return 0;
 9080550:	0005883a 	mov	r2,zero
}
 9080554:	e037883a 	mov	sp,fp
 9080558:	df000017 	ldw	fp,0(sp)
 908055c:	dec00104 	addi	sp,sp,4
 9080560:	f800283a 	ret

09080564 <ReadDataFifo0>:

int ReadDataFifo0(int ndata, INT32U *val)
{
 9080564:	defffc04 	addi	sp,sp,-16
 9080568:	df000315 	stw	fp,12(sp)
 908056c:	df000304 	addi	fp,sp,12
 9080570:	e13ffe15 	stw	r4,-8(fp)
 9080574:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080578:	e03ffd15 	stw	zero,-12(fp)
 908057c:	00000c06 	br	90805b0 <ReadDataFifo0+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x0);
 9080580:	e0bffd17 	ldw	r2,-12(fp)
 9080584:	1085883a 	add	r2,r2,r2
 9080588:	1085883a 	add	r2,r2,r2
 908058c:	1007883a 	mov	r3,r2
 9080590:	e0bfff17 	ldw	r2,-4(fp)
 9080594:	1887883a 	add	r3,r3,r2
 9080598:	0005883a 	mov	r2,zero
 908059c:	10800037 	ldwio	r2,0(r2)
 90805a0:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo0(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 90805a4:	e0bffd17 	ldw	r2,-12(fp)
 90805a8:	10800044 	addi	r2,r2,1
 90805ac:	e0bffd15 	stw	r2,-12(fp)
 90805b0:	e0fffd17 	ldw	r3,-12(fp)
 90805b4:	e0bffe17 	ldw	r2,-8(fp)
 90805b8:	18bff116 	blt	r3,r2,9080580 <ReadDataFifo0+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x0);
	return 0;
 90805bc:	0005883a 	mov	r2,zero
}
 90805c0:	e037883a 	mov	sp,fp
 90805c4:	df000017 	ldw	fp,0(sp)
 90805c8:	dec00104 	addi	sp,sp,4
 90805cc:	f800283a 	ret

090805d0 <ReadDataFifo1>:

int ReadDataFifo1(int ndata, INT32U *val)
{
 90805d0:	defffc04 	addi	sp,sp,-16
 90805d4:	df000315 	stw	fp,12(sp)
 90805d8:	df000304 	addi	fp,sp,12
 90805dc:	e13ffe15 	stw	r4,-8(fp)
 90805e0:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 90805e4:	e03ffd15 	stw	zero,-12(fp)
 90805e8:	00000c06 	br	908061c <ReadDataFifo1+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x01);
 90805ec:	e0bffd17 	ldw	r2,-12(fp)
 90805f0:	1085883a 	add	r2,r2,r2
 90805f4:	1085883a 	add	r2,r2,r2
 90805f8:	1007883a 	mov	r3,r2
 90805fc:	e0bfff17 	ldw	r2,-4(fp)
 9080600:	1887883a 	add	r3,r3,r2
 9080604:	00800104 	movi	r2,4
 9080608:	10800037 	ldwio	r2,0(r2)
 908060c:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo1(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 9080610:	e0bffd17 	ldw	r2,-12(fp)
 9080614:	10800044 	addi	r2,r2,1
 9080618:	e0bffd15 	stw	r2,-12(fp)
 908061c:	e0fffd17 	ldw	r3,-12(fp)
 9080620:	e0bffe17 	ldw	r2,-8(fp)
 9080624:	18bff116 	blt	r3,r2,90805ec <ReadDataFifo1+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x01);
	return 0;
 9080628:	0005883a 	mov	r2,zero
}
 908062c:	e037883a 	mov	sp,fp
 9080630:	df000017 	ldw	fp,0(sp)
 9080634:	dec00104 	addi	sp,sp,4
 9080638:	f800283a 	ret

0908063c <ReadDataFifo2>:

int ReadDataFifo2(int ndata, INT32U *val)
{
 908063c:	defffc04 	addi	sp,sp,-16
 9080640:	df000315 	stw	fp,12(sp)
 9080644:	df000304 	addi	fp,sp,12
 9080648:	e13ffe15 	stw	r4,-8(fp)
 908064c:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080650:	e03ffd15 	stw	zero,-12(fp)
 9080654:	00000c06 	br	9080688 <ReadDataFifo2+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x02);
 9080658:	e0bffd17 	ldw	r2,-12(fp)
 908065c:	1085883a 	add	r2,r2,r2
 9080660:	1085883a 	add	r2,r2,r2
 9080664:	1007883a 	mov	r3,r2
 9080668:	e0bfff17 	ldw	r2,-4(fp)
 908066c:	1887883a 	add	r3,r3,r2
 9080670:	00800204 	movi	r2,8
 9080674:	10800037 	ldwio	r2,0(r2)
 9080678:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo2(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 908067c:	e0bffd17 	ldw	r2,-12(fp)
 9080680:	10800044 	addi	r2,r2,1
 9080684:	e0bffd15 	stw	r2,-12(fp)
 9080688:	e0fffd17 	ldw	r3,-12(fp)
 908068c:	e0bffe17 	ldw	r2,-8(fp)
 9080690:	18bff116 	blt	r3,r2,9080658 <ReadDataFifo2+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x02);
	return 0;
 9080694:	0005883a 	mov	r2,zero
}
 9080698:	e037883a 	mov	sp,fp
 908069c:	df000017 	ldw	fp,0(sp)
 90806a0:	dec00104 	addi	sp,sp,4
 90806a4:	f800283a 	ret

090806a8 <ReadDataFifo3>:

int ReadDataFifo3(int ndata, INT32U *val)
{
 90806a8:	defffc04 	addi	sp,sp,-16
 90806ac:	df000315 	stw	fp,12(sp)
 90806b0:	df000304 	addi	fp,sp,12
 90806b4:	e13ffe15 	stw	r4,-8(fp)
 90806b8:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 90806bc:	e03ffd15 	stw	zero,-12(fp)
 90806c0:	00000c06 	br	90806f4 <ReadDataFifo3+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x03);
 90806c4:	e0bffd17 	ldw	r2,-12(fp)
 90806c8:	1085883a 	add	r2,r2,r2
 90806cc:	1085883a 	add	r2,r2,r2
 90806d0:	1007883a 	mov	r3,r2
 90806d4:	e0bfff17 	ldw	r2,-4(fp)
 90806d8:	1887883a 	add	r3,r3,r2
 90806dc:	00800304 	movi	r2,12
 90806e0:	10800037 	ldwio	r2,0(r2)
 90806e4:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo3(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 90806e8:	e0bffd17 	ldw	r2,-12(fp)
 90806ec:	10800044 	addi	r2,r2,1
 90806f0:	e0bffd15 	stw	r2,-12(fp)
 90806f4:	e0fffd17 	ldw	r3,-12(fp)
 90806f8:	e0bffe17 	ldw	r2,-8(fp)
 90806fc:	18bff116 	blt	r3,r2,90806c4 <ReadDataFifo3+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x03);
	return 0;
 9080700:	0005883a 	mov	r2,zero
}
 9080704:	e037883a 	mov	sp,fp
 9080708:	df000017 	ldw	fp,0(sp)
 908070c:	dec00104 	addi	sp,sp,4
 9080710:	f800283a 	ret

09080714 <ReadDataFifo4>:

int ReadDataFifo4(int ndata, INT32U *val)
{
 9080714:	defffc04 	addi	sp,sp,-16
 9080718:	df000315 	stw	fp,12(sp)
 908071c:	df000304 	addi	fp,sp,12
 9080720:	e13ffe15 	stw	r4,-8(fp)
 9080724:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080728:	e03ffd15 	stw	zero,-12(fp)
 908072c:	00000c06 	br	9080760 <ReadDataFifo4+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x04);
 9080730:	e0bffd17 	ldw	r2,-12(fp)
 9080734:	1085883a 	add	r2,r2,r2
 9080738:	1085883a 	add	r2,r2,r2
 908073c:	1007883a 	mov	r3,r2
 9080740:	e0bfff17 	ldw	r2,-4(fp)
 9080744:	1887883a 	add	r3,r3,r2
 9080748:	00800404 	movi	r2,16
 908074c:	10800037 	ldwio	r2,0(r2)
 9080750:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo4(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 9080754:	e0bffd17 	ldw	r2,-12(fp)
 9080758:	10800044 	addi	r2,r2,1
 908075c:	e0bffd15 	stw	r2,-12(fp)
 9080760:	e0fffd17 	ldw	r3,-12(fp)
 9080764:	e0bffe17 	ldw	r2,-8(fp)
 9080768:	18bff116 	blt	r3,r2,9080730 <ReadDataFifo4+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x04);
	return 0;
 908076c:	0005883a 	mov	r2,zero
}
 9080770:	e037883a 	mov	sp,fp
 9080774:	df000017 	ldw	fp,0(sp)
 9080778:	dec00104 	addi	sp,sp,4
 908077c:	f800283a 	ret

09080780 <ReadDataFifo5>:

int ReadDataFifo5(int ndata, INT32U *val)
{
 9080780:	defffc04 	addi	sp,sp,-16
 9080784:	df000315 	stw	fp,12(sp)
 9080788:	df000304 	addi	fp,sp,12
 908078c:	e13ffe15 	stw	r4,-8(fp)
 9080790:	e17fff15 	stw	r5,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080794:	e03ffd15 	stw	zero,-12(fp)
 9080798:	00000c06 	br	90807cc <ReadDataFifo5+0x4c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x05);
 908079c:	e0bffd17 	ldw	r2,-12(fp)
 90807a0:	1085883a 	add	r2,r2,r2
 90807a4:	1085883a 	add	r2,r2,r2
 90807a8:	1007883a 	mov	r3,r2
 90807ac:	e0bfff17 	ldw	r2,-4(fp)
 90807b0:	1887883a 	add	r3,r3,r2
 90807b4:	00800504 	movi	r2,20
 90807b8:	10800037 	ldwio	r2,0(r2)
 90807bc:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo5(int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 90807c0:	e0bffd17 	ldw	r2,-12(fp)
 90807c4:	10800044 	addi	r2,r2,1
 90807c8:	e0bffd15 	stw	r2,-12(fp)
 90807cc:	e0fffd17 	ldw	r3,-12(fp)
 90807d0:	e0bffe17 	ldw	r2,-8(fp)
 90807d4:	18bff116 	blt	r3,r2,908079c <ReadDataFifo5+0x1c>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, 0x05);
	return 0;
 90807d8:	0005883a 	mov	r2,zero
}
 90807dc:	e037883a 	mov	sp,fp
 90807e0:	df000017 	ldw	fp,0(sp)
 90807e4:	dec00104 	addi	sp,sp,4
 90807e8:	f800283a 	ret

090807ec <ReadDataFifo>:

int ReadDataFifo(int ch, int ndata, INT32U *val)
{
 90807ec:	defffb04 	addi	sp,sp,-20
 90807f0:	df000415 	stw	fp,16(sp)
 90807f4:	df000404 	addi	fp,sp,16
 90807f8:	e13ffd15 	stw	r4,-12(fp)
 90807fc:	e17ffe15 	stw	r5,-8(fp)
 9080800:	e1bfff15 	stw	r6,-4(fp)
	int i;
	for(i=0;i<ndata;i++)
 9080804:	e03ffc15 	stw	zero,-16(fp)
 9080808:	00000e06 	br	9080844 <ReadDataFifo+0x58>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, ch);
 908080c:	e0bffc17 	ldw	r2,-16(fp)
 9080810:	1085883a 	add	r2,r2,r2
 9080814:	1085883a 	add	r2,r2,r2
 9080818:	1007883a 	mov	r3,r2
 908081c:	e0bfff17 	ldw	r2,-4(fp)
 9080820:	1887883a 	add	r3,r3,r2
 9080824:	e0bffd17 	ldw	r2,-12(fp)
 9080828:	1085883a 	add	r2,r2,r2
 908082c:	1085883a 	add	r2,r2,r2
 9080830:	10800037 	ldwio	r2,0(r2)
 9080834:	18800015 	stw	r2,0(r3)
}

int ReadDataFifo(int ch, int ndata, INT32U *val)
{
	int i;
	for(i=0;i<ndata;i++)
 9080838:	e0bffc17 	ldw	r2,-16(fp)
 908083c:	10800044 	addi	r2,r2,1
 9080840:	e0bffc15 	stw	r2,-16(fp)
 9080844:	e0fffc17 	ldw	r3,-16(fp)
 9080848:	e0bffe17 	ldw	r2,-8(fp)
 908084c:	18bfef16 	blt	r3,r2,908080c <ReadDataFifo+0x20>
		*(val+i) = IORD(TOFPET_AVALON_MM_IF_0_BASE, ch);
	return 0;
 9080850:	0005883a 	mov	r2,zero
}
 9080854:	e037883a 	mov	sp,fp
 9080858:	df000017 	ldw	fp,0(sp)
 908085c:	dec00104 	addi	sp,sp,4
 9080860:	f800283a 	ret

09080864 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 9080864:	defff904 	addi	sp,sp,-28
 9080868:	dfc00615 	stw	ra,24(sp)
 908086c:	df000515 	stw	fp,20(sp)
 9080870:	df000504 	addi	fp,sp,20
 9080874:	e17ffd15 	stw	r5,-12(fp)
 9080878:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 908087c:	e0bffc03 	ldbu	r2,-16(fp)
 9080880:	1005003a 	cmpeq	r2,r2,zero
 9080884:	10017b1e 	bne	r2,zero,9080e74 <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 9080888:	00800084 	movi	r2,2
 908088c:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 9080890:	908eb9c0 	call	908eb9c <OSSchedLock>
      
   switch (error_code)
 9080894:	e0bffc03 	ldbu	r2,-16(fp)
 9080898:	e0bffe15 	stw	r2,-8(fp)
 908089c:	e0fffe17 	ldw	r3,-8(fp)
 90808a0:	18800a20 	cmpeqi	r2,r3,40
 90808a4:	1000371e 	bne	r2,zero,9080984 <alt_uCOSIIErrorHandler+0x120>
 90808a8:	e0fffe17 	ldw	r3,-8(fp)
 90808ac:	18800a48 	cmpgei	r2,r3,41
 90808b0:	10001a1e 	bne	r2,zero,908091c <alt_uCOSIIErrorHandler+0xb8>
 90808b4:	e0fffe17 	ldw	r3,-8(fp)
 90808b8:	18800120 	cmpeqi	r2,r3,4
 90808bc:	1000761e 	bne	r2,zero,9080a98 <alt_uCOSIIErrorHandler+0x234>
 90808c0:	e0fffe17 	ldw	r3,-8(fp)
 90808c4:	18800148 	cmpgei	r2,r3,5
 90808c8:	10000a1e 	bne	r2,zero,90808f4 <alt_uCOSIIErrorHandler+0x90>
 90808cc:	e0fffe17 	ldw	r3,-8(fp)
 90808d0:	188000a0 	cmpeqi	r2,r3,2
 90808d4:	1000911e 	bne	r2,zero,9080b1c <alt_uCOSIIErrorHandler+0x2b8>
 90808d8:	e0fffe17 	ldw	r3,-8(fp)
 90808dc:	188000c8 	cmpgei	r2,r3,3
 90808e0:	1000771e 	bne	r2,zero,9080ac0 <alt_uCOSIIErrorHandler+0x25c>
 90808e4:	e0fffe17 	ldw	r3,-8(fp)
 90808e8:	18800060 	cmpeqi	r2,r3,1
 90808ec:	10005e1e 	bne	r2,zero,9080a68 <alt_uCOSIIErrorHandler+0x204>
 90808f0:	0000d806 	br	9080c54 <alt_uCOSIIErrorHandler+0x3f0>
 90808f4:	e0fffe17 	ldw	r3,-8(fp)
 90808f8:	18800520 	cmpeqi	r2,r3,20
 90808fc:	10004f1e 	bne	r2,zero,9080a3c <alt_uCOSIIErrorHandler+0x1d8>
 9080900:	e0fffe17 	ldw	r3,-8(fp)
 9080904:	188007a0 	cmpeqi	r2,r3,30
 9080908:	1000ad1e 	bne	r2,zero,9080bc0 <alt_uCOSIIErrorHandler+0x35c>
 908090c:	e0fffe17 	ldw	r3,-8(fp)
 9080910:	188002a0 	cmpeqi	r2,r3,10
 9080914:	1000761e 	bne	r2,zero,9080af0 <alt_uCOSIIErrorHandler+0x28c>
 9080918:	0000ce06 	br	9080c54 <alt_uCOSIIErrorHandler+0x3f0>
 908091c:	e0fffe17 	ldw	r3,-8(fp)
 9080920:	18801020 	cmpeqi	r2,r3,64
 9080924:	10009c1e 	bne	r2,zero,9080b98 <alt_uCOSIIErrorHandler+0x334>
 9080928:	e0fffe17 	ldw	r3,-8(fp)
 908092c:	18801048 	cmpgei	r2,r3,65
 9080930:	10000a1e 	bne	r2,zero,908095c <alt_uCOSIIErrorHandler+0xf8>
 9080934:	e0fffe17 	ldw	r3,-8(fp)
 9080938:	18800f60 	cmpeqi	r2,r3,61
 908093c:	10008b1e 	bne	r2,zero,9080b6c <alt_uCOSIIErrorHandler+0x308>
 9080940:	e0fffe17 	ldw	r3,-8(fp)
 9080944:	18800fa0 	cmpeqi	r2,r3,62
 9080948:	10007e1e 	bne	r2,zero,9080b44 <alt_uCOSIIErrorHandler+0x2e0>
 908094c:	e0fffe17 	ldw	r3,-8(fp)
 9080950:	18800aa0 	cmpeqi	r2,r3,42
 9080954:	1000151e 	bne	r2,zero,90809ac <alt_uCOSIIErrorHandler+0x148>
 9080958:	0000be06 	br	9080c54 <alt_uCOSIIErrorHandler+0x3f0>
 908095c:	e0fffe17 	ldw	r3,-8(fp)
 9080960:	18801920 	cmpeqi	r2,r3,100
 9080964:	1000a11e 	bne	r2,zero,9080bec <alt_uCOSIIErrorHandler+0x388>
 9080968:	e0fffe17 	ldw	r3,-8(fp)
 908096c:	18803fe0 	cmpeqi	r2,r3,255
 9080970:	1000aa1e 	bne	r2,zero,9080c1c <alt_uCOSIIErrorHandler+0x3b8>
 9080974:	e0fffe17 	ldw	r3,-8(fp)
 9080978:	188010a0 	cmpeqi	r2,r3,66
 908097c:	10001d1e 	bne	r2,zero,90809f4 <alt_uCOSIIErrorHandler+0x190>
 9080980:	0000b406 	br	9080c54 <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 9080984:	00824374 	movhi	r2,2317
 9080988:	108e8604 	addi	r2,r2,14872
 908098c:	10800017 	ldw	r2,0(r2)
 9080990:	11c00317 	ldw	r7,12(r2)
 9080994:	01024374 	movhi	r4,2317
 9080998:	212f1b04 	addi	r4,r4,-17300
 908099c:	01400044 	movi	r5,1
 90809a0:	01800c44 	movi	r6,49
 90809a4:	90831100 	call	9083110 <fwrite>
         break;
 90809a8:	0000c106 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 90809ac:	00824374 	movhi	r2,2317
 90809b0:	108e8604 	addi	r2,r2,14872
 90809b4:	10800017 	ldw	r2,0(r2)
 90809b8:	11c00317 	ldw	r7,12(r2)
 90809bc:	01024374 	movhi	r4,2317
 90809c0:	212f2804 	addi	r4,r4,-17248
 90809c4:	01400044 	movi	r5,1
 90809c8:	01800c44 	movi	r6,49
 90809cc:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 90809d0:	00824374 	movhi	r2,2317
 90809d4:	108e8604 	addi	r2,r2,14872
 90809d8:	10800017 	ldw	r2,0(r2)
 90809dc:	11000317 	ldw	r4,12(r2)
 90809e0:	01424374 	movhi	r5,2317
 90809e4:	296f3504 	addi	r5,r5,-17196
 90809e8:	01800504 	movi	r6,20
 90809ec:	90830140 	call	9083014 <fprintf>
            OS_LOWEST_PRIO);
         break;
 90809f0:	0000af06 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 90809f4:	00824374 	movhi	r2,2317
 90809f8:	108e8604 	addi	r2,r2,14872
 90809fc:	10800017 	ldw	r2,0(r2)
 9080a00:	11c00317 	ldw	r7,12(r2)
 9080a04:	01024374 	movhi	r4,2317
 9080a08:	212f4204 	addi	r4,r4,-17144
 9080a0c:	01400044 	movi	r5,1
 9080a10:	01800a04 	movi	r6,40
 9080a14:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 9080a18:	00824374 	movhi	r2,2317
 9080a1c:	108e8604 	addi	r2,r2,14872
 9080a20:	10800017 	ldw	r2,0(r2)
 9080a24:	11000317 	ldw	r4,12(r2)
 9080a28:	01424374 	movhi	r5,2317
 9080a2c:	296f4d04 	addi	r5,r5,-17100
 9080a30:	01800284 	movi	r6,10
 9080a34:	90830140 	call	9083014 <fprintf>
         break;
 9080a38:	00009d06 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 9080a3c:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 9080a40:	00824374 	movhi	r2,2317
 9080a44:	108e8604 	addi	r2,r2,14872
 9080a48:	10800017 	ldw	r2,0(r2)
 9080a4c:	11c00317 	ldw	r7,12(r2)
 9080a50:	01024374 	movhi	r4,2317
 9080a54:	212f5604 	addi	r4,r4,-17064
 9080a58:	01400044 	movi	r5,1
 9080a5c:	01800c84 	movi	r6,50
 9080a60:	90831100 	call	9083110 <fwrite>
         break;
 9080a64:	00009206 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 9080a68:	00800044 	movi	r2,1
 9080a6c:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 9080a70:	00824374 	movhi	r2,2317
 9080a74:	108e8604 	addi	r2,r2,14872
 9080a78:	10800017 	ldw	r2,0(r2)
 9080a7c:	11c00317 	ldw	r7,12(r2)
 9080a80:	01024374 	movhi	r4,2317
 9080a84:	212f6304 	addi	r4,r4,-17012
 9080a88:	01400044 	movi	r5,1
 9080a8c:	01801244 	movi	r6,73
 9080a90:	90831100 	call	9083110 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 9080a94:	00008606 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 9080a98:	00824374 	movhi	r2,2317
 9080a9c:	108e8604 	addi	r2,r2,14872
 9080aa0:	10800017 	ldw	r2,0(r2)
 9080aa4:	11c00317 	ldw	r7,12(r2)
 9080aa8:	01024374 	movhi	r4,2317
 9080aac:	212f7604 	addi	r4,r4,-16936
 9080ab0:	01400044 	movi	r5,1
 9080ab4:	01800c44 	movi	r6,49
 9080ab8:	90831100 	call	9083110 <fwrite>
         break;
 9080abc:	00007c06 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 9080ac0:	00800044 	movi	r2,1
 9080ac4:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 9080ac8:	00824374 	movhi	r2,2317
 9080acc:	108e8604 	addi	r2,r2,14872
 9080ad0:	10800017 	ldw	r2,0(r2)
 9080ad4:	11c00317 	ldw	r7,12(r2)
 9080ad8:	01024374 	movhi	r4,2317
 9080adc:	212f8304 	addi	r4,r4,-16884
 9080ae0:	01400044 	movi	r5,1
 9080ae4:	01800a44 	movi	r6,41
 9080ae8:	90831100 	call	9083110 <fwrite>
         break;
 9080aec:	00007006 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 9080af0:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 9080af4:	00824374 	movhi	r2,2317
 9080af8:	108e8604 	addi	r2,r2,14872
 9080afc:	10800017 	ldw	r2,0(r2)
 9080b00:	11c00317 	ldw	r7,12(r2)
 9080b04:	01024374 	movhi	r4,2317
 9080b08:	212f8e04 	addi	r4,r4,-16840
 9080b0c:	01400044 	movi	r5,1
 9080b10:	01800a04 	movi	r6,40
 9080b14:	90831100 	call	9083110 <fwrite>
         break;
 9080b18:	00006506 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 9080b1c:	00824374 	movhi	r2,2317
 9080b20:	108e8604 	addi	r2,r2,14872
 9080b24:	10800017 	ldw	r2,0(r2)
 9080b28:	11c00317 	ldw	r7,12(r2)
 9080b2c:	01024374 	movhi	r4,2317
 9080b30:	212f9904 	addi	r4,r4,-16796
 9080b34:	01400044 	movi	r5,1
 9080b38:	01800b04 	movi	r6,44
 9080b3c:	90831100 	call	9083110 <fwrite>
         break;
 9080b40:	00005b06 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 9080b44:	00824374 	movhi	r2,2317
 9080b48:	108e8604 	addi	r2,r2,14872
 9080b4c:	10800017 	ldw	r2,0(r2)
 9080b50:	11c00317 	ldw	r7,12(r2)
 9080b54:	01024374 	movhi	r4,2317
 9080b58:	212fa504 	addi	r4,r4,-16748
 9080b5c:	01400044 	movi	r5,1
 9080b60:	01800884 	movi	r6,34
 9080b64:	90831100 	call	9083110 <fwrite>
         break;
 9080b68:	00005106 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 9080b6c:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 9080b70:	00824374 	movhi	r2,2317
 9080b74:	108e8604 	addi	r2,r2,14872
 9080b78:	10800017 	ldw	r2,0(r2)
 9080b7c:	11c00317 	ldw	r7,12(r2)
 9080b80:	01024374 	movhi	r4,2317
 9080b84:	212fae04 	addi	r4,r4,-16712
 9080b88:	01400044 	movi	r5,1
 9080b8c:	01800bc4 	movi	r6,47
 9080b90:	90831100 	call	9083110 <fwrite>
         break;
 9080b94:	00004606 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 9080b98:	00824374 	movhi	r2,2317
 9080b9c:	108e8604 	addi	r2,r2,14872
 9080ba0:	10800017 	ldw	r2,0(r2)
 9080ba4:	11c00317 	ldw	r7,12(r2)
 9080ba8:	01024374 	movhi	r4,2317
 9080bac:	212fba04 	addi	r4,r4,-16664
 9080bb0:	01400044 	movi	r5,1
 9080bb4:	018009c4 	movi	r6,39
 9080bb8:	90831100 	call	9083110 <fwrite>
         break;
 9080bbc:	00003c06 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 9080bc0:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 9080bc4:	00824374 	movhi	r2,2317
 9080bc8:	108e8604 	addi	r2,r2,14872
 9080bcc:	10800017 	ldw	r2,0(r2)
 9080bd0:	11c00317 	ldw	r7,12(r2)
 9080bd4:	01024374 	movhi	r4,2317
 9080bd8:	212fc404 	addi	r4,r4,-16624
 9080bdc:	01400044 	movi	r5,1
 9080be0:	01800a84 	movi	r6,42
 9080be4:	90831100 	call	9083110 <fwrite>
         break;
 9080be8:	00003106 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 9080bec:	00800044 	movi	r2,1
 9080bf0:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 9080bf4:	00824374 	movhi	r2,2317
 9080bf8:	108e8604 	addi	r2,r2,14872
 9080bfc:	10800017 	ldw	r2,0(r2)
 9080c00:	11c00317 	ldw	r7,12(r2)
 9080c04:	01024374 	movhi	r4,2317
 9080c08:	212fcf04 	addi	r4,r4,-16580
 9080c0c:	01400044 	movi	r5,1
 9080c10:	01800c04 	movi	r6,48
 9080c14:	90831100 	call	9083110 <fwrite>
         break;
 9080c18:	00002506 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 9080c1c:	00800084 	movi	r2,2
 9080c20:	e0bffb15 	stw	r2,-20(fp)
         printf(
 9080c24:	01024374 	movhi	r4,2317
 9080c28:	212fdc04 	addi	r4,r4,-16528
 9080c2c:	90833900 	call	9083390 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 9080c30:	00824374 	movhi	r2,2317
 9080c34:	108e8604 	addi	r2,r2,14872
 9080c38:	10800017 	ldw	r2,0(r2)
 9080c3c:	11000317 	ldw	r4,12(r2)
 9080c40:	e1bffd17 	ldw	r6,-12(fp)
 9080c44:	01424374 	movhi	r5,2317
 9080c48:	296fec04 	addi	r5,r5,-16464
 9080c4c:	90830140 	call	9083014 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 9080c50:	00001706 	br	9080cb0 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 9080c54:	01024374 	movhi	r4,2317
 9080c58:	212ff704 	addi	r4,r4,-16420
 9080c5c:	90836b80 	call	90836b8 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 9080c60:	00824374 	movhi	r2,2317
 9080c64:	108e8604 	addi	r2,r2,14872
 9080c68:	10800017 	ldw	r2,0(r2)
 9080c6c:	11c00317 	ldw	r7,12(r2)
 9080c70:	01024374 	movhi	r4,2317
 9080c74:	21300504 	addi	r4,r4,-16364
 9080c78:	01400044 	movi	r5,1
 9080c7c:	01800404 	movi	r6,16
 9080c80:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 9080c84:	00824374 	movhi	r2,2317
 9080c88:	108e8604 	addi	r2,r2,14872
 9080c8c:	10800017 	ldw	r2,0(r2)
 9080c90:	11000317 	ldw	r4,12(r2)
 9080c94:	e1bffc03 	ldbu	r6,-16(fp)
 9080c98:	01424374 	movhi	r5,2317
 9080c9c:	29700a04 	addi	r5,r5,-16344
 9080ca0:	90830140 	call	9083014 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 9080ca4:	01024374 	movhi	r4,2317
 9080ca8:	21300f04 	addi	r4,r4,-16324
 9080cac:	908337c0 	call	908337c <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 9080cb0:	e0bffb17 	ldw	r2,-20(fp)
 9080cb4:	e0bfff15 	stw	r2,-4(fp)
 9080cb8:	e0ffff17 	ldw	r3,-4(fp)
 9080cbc:	18800060 	cmpeqi	r2,r3,1
 9080cc0:	1000071e 	bne	r2,zero,9080ce0 <alt_uCOSIIErrorHandler+0x47c>
 9080cc4:	e0ffff17 	ldw	r3,-4(fp)
 9080cc8:	18800070 	cmpltui	r2,r3,1
 9080ccc:	10003f1e 	bne	r2,zero,9080dcc <alt_uCOSIIErrorHandler+0x568>
 9080cd0:	e0ffff17 	ldw	r3,-4(fp)
 9080cd4:	188000a0 	cmpeqi	r2,r3,2
 9080cd8:	10001d1e 	bne	r2,zero,9080d50 <alt_uCOSIIErrorHandler+0x4ec>
 9080cdc:	00005806 	br	9080e40 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 9080ce0:	01024374 	movhi	r4,2317
 9080ce4:	21301d04 	addi	r4,r4,-16268
 9080ce8:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 9080cec:	00824374 	movhi	r2,2317
 9080cf0:	108e8604 	addi	r2,r2,14872
 9080cf4:	10800017 	ldw	r2,0(r2)
 9080cf8:	11c00317 	ldw	r7,12(r2)
 9080cfc:	01024374 	movhi	r4,2317
 9080d00:	21302a04 	addi	r4,r4,-16216
 9080d04:	01400044 	movi	r5,1
 9080d08:	01800904 	movi	r6,36
 9080d0c:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 9080d10:	00824374 	movhi	r2,2317
 9080d14:	108e8604 	addi	r2,r2,14872
 9080d18:	10800017 	ldw	r2,0(r2)
 9080d1c:	11c00317 	ldw	r7,12(r2)
 9080d20:	01024374 	movhi	r4,2317
 9080d24:	21303404 	addi	r4,r4,-16176
 9080d28:	01400044 	movi	r5,1
 9080d2c:	01800a04 	movi	r6,40
 9080d30:	90831100 	call	9083110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 9080d34:	908ec280 	call	908ec28 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 9080d38:	01003fc4 	movi	r4,255
 9080d3c:	9094cf80 	call	9094cf8 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 9080d40:	e13ffc03 	ldbu	r4,-16(fp)
 9080d44:	000b883a 	mov	r5,zero
 9080d48:	90808640 	call	9080864 <alt_uCOSIIErrorHandler>
         break;
 9080d4c:	00004806 	br	9080e70 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 9080d50:	01024374 	movhi	r4,2317
 9080d54:	21303f04 	addi	r4,r4,-16132
 9080d58:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 9080d5c:	00824374 	movhi	r2,2317
 9080d60:	108e8604 	addi	r2,r2,14872
 9080d64:	10800017 	ldw	r2,0(r2)
 9080d68:	11c00317 	ldw	r7,12(r2)
 9080d6c:	01024374 	movhi	r4,2317
 9080d70:	21304d04 	addi	r4,r4,-16076
 9080d74:	01400044 	movi	r5,1
 9080d78:	01800984 	movi	r6,38
 9080d7c:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 9080d80:	00824374 	movhi	r2,2317
 9080d84:	108e8604 	addi	r2,r2,14872
 9080d88:	10800017 	ldw	r2,0(r2)
 9080d8c:	11c00317 	ldw	r7,12(r2)
 9080d90:	01024374 	movhi	r4,2317
 9080d94:	21305704 	addi	r4,r4,-16036
 9080d98:	01400044 	movi	r5,1
 9080d9c:	01800bc4 	movi	r6,47
 9080da0:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 9080da4:	00824374 	movhi	r2,2317
 9080da8:	108e8604 	addi	r2,r2,14872
 9080dac:	10800017 	ldw	r2,0(r2)
 9080db0:	11c00317 	ldw	r7,12(r2)
 9080db4:	01024374 	movhi	r4,2317
 9080db8:	21306304 	addi	r4,r4,-15988
 9080dbc:	01400044 	movi	r5,1
 9080dc0:	01800cc4 	movi	r6,51
 9080dc4:	90831100 	call	9083110 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 9080dc8:	003fff06 	br	9080dc8 <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 9080dcc:	00824374 	movhi	r2,2317
 9080dd0:	108e8604 	addi	r2,r2,14872
 9080dd4:	10800017 	ldw	r2,0(r2)
 9080dd8:	11c00317 	ldw	r7,12(r2)
 9080ddc:	01024374 	movhi	r4,2317
 9080de0:	21307004 	addi	r4,r4,-15936
 9080de4:	01400044 	movi	r5,1
 9080de8:	01800904 	movi	r6,36
 9080dec:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 9080df0:	00824374 	movhi	r2,2317
 9080df4:	108e8604 	addi	r2,r2,14872
 9080df8:	10800017 	ldw	r2,0(r2)
 9080dfc:	11c00317 	ldw	r7,12(r2)
 9080e00:	01024374 	movhi	r4,2317
 9080e04:	21307a04 	addi	r4,r4,-15896
 9080e08:	01400044 	movi	r5,1
 9080e0c:	01800c84 	movi	r6,50
 9080e10:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, 
 9080e14:	00824374 	movhi	r2,2317
 9080e18:	108e8604 	addi	r2,r2,14872
 9080e1c:	10800017 	ldw	r2,0(r2)
 9080e20:	11c00317 	ldw	r7,12(r2)
 9080e24:	01024374 	movhi	r4,2317
 9080e28:	21308704 	addi	r4,r4,-15844
 9080e2c:	01400044 	movi	r5,1
 9080e30:	01800f84 	movi	r6,62
 9080e34:	90831100 	call	9083110 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 9080e38:	908ec280 	call	908ec28 <OSSchedUnlock>
         return;   
 9080e3c:	00000d06 	br	9080e74 <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 9080e40:	01024374 	movhi	r4,2317
 9080e44:	21309704 	addi	r4,r4,-15780
 9080e48:	90836b80 	call	90836b8 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 9080e4c:	00824374 	movhi	r2,2317
 9080e50:	108e8604 	addi	r2,r2,14872
 9080e54:	10800017 	ldw	r2,0(r2)
 9080e58:	11c00317 	ldw	r7,12(r2)
 9080e5c:	01024374 	movhi	r4,2317
 9080e60:	2130a504 	addi	r4,r4,-15724
 9080e64:	01400044 	movi	r5,1
 9080e68:	01800ac4 	movi	r6,43
 9080e6c:	90831100 	call	9083110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 9080e70:	003fff06 	br	9080e70 <alt_uCOSIIErrorHandler+0x60c>
}
 9080e74:	e037883a 	mov	sp,fp
 9080e78:	dfc00117 	ldw	ra,4(sp)
 9080e7c:	df000017 	ldw	fp,0(sp)
 9080e80:	dec00204 	addi	sp,sp,8
 9080e84:	f800283a 	ret

09080e88 <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 9080e88:	defffa04 	addi	sp,sp,-24
 9080e8c:	dfc00515 	stw	ra,20(sp)
 9080e90:	df000415 	stw	fp,16(sp)
 9080e94:	df000404 	addi	fp,sp,16
 9080e98:	e17ffe15 	stw	r5,-8(fp)
 9080e9c:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 9080ea0:	e0bffd03 	ldbu	r2,-12(fp)
 9080ea4:	1005003a 	cmpeq	r2,r2,zero
 9080ea8:	1000981e 	bne	r2,zero,908110c <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 9080eac:	00800084 	movi	r2,2
 9080eb0:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 9080eb4:	908eb9c0 	call	908eb9c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 9080eb8:	e0bffd03 	ldbu	r2,-12(fp)
 9080ebc:	10803fd8 	cmpnei	r2,r2,255
 9080ec0:	1000111e 	bne	r2,zero,9080f08 <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 9080ec4:	00800084 	movi	r2,2
 9080ec8:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 9080ecc:	01024374 	movhi	r4,2317
 9080ed0:	2130b004 	addi	r4,r4,-15680
 9080ed4:	90833900 	call	9083390 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 9080ed8:	00824374 	movhi	r2,2317
 9080edc:	108e8604 	addi	r2,r2,14872
 9080ee0:	10800017 	ldw	r2,0(r2)
 9080ee4:	11000317 	ldw	r4,12(r2)
 9080ee8:	e1bffe17 	ldw	r6,-8(fp)
 9080eec:	01424374 	movhi	r5,2317
 9080ef0:	2970bf04 	addi	r5,r5,-15620
 9080ef4:	90830140 	call	9083014 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 9080ef8:	01024374 	movhi	r4,2317
 9080efc:	2130c304 	addi	r4,r4,-15604
 9080f00:	908337c0 	call	908337c <perror>
 9080f04:	00001006 	br	9080f48 <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 9080f08:	00800044 	movi	r2,1
 9080f0c:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 9080f10:	01024374 	movhi	r4,2317
 9080f14:	2130c904 	addi	r4,r4,-15580
 9080f18:	90836b80 	call	90836b8 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 9080f1c:	00824374 	movhi	r2,2317
 9080f20:	108e8604 	addi	r2,r2,14872
 9080f24:	10800017 	ldw	r2,0(r2)
 9080f28:	11000317 	ldw	r4,12(r2)
 9080f2c:	e1bffd03 	ldbu	r6,-12(fp)
 9080f30:	01424374 	movhi	r5,2317
 9080f34:	2970cf04 	addi	r5,r5,-15556
 9080f38:	90830140 	call	9083014 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 9080f3c:	01024374 	movhi	r4,2317
 9080f40:	2130c304 	addi	r4,r4,-15604
 9080f44:	908337c0 	call	908337c <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 9080f48:	e0bffc17 	ldw	r2,-16(fp)
 9080f4c:	e0bfff15 	stw	r2,-4(fp)
 9080f50:	e0ffff17 	ldw	r3,-4(fp)
 9080f54:	18800060 	cmpeqi	r2,r3,1
 9080f58:	1000071e 	bne	r2,zero,9080f78 <alt_NetworkErrorHandler+0xf0>
 9080f5c:	e0ffff17 	ldw	r3,-4(fp)
 9080f60:	18800070 	cmpltui	r2,r3,1
 9080f64:	10003f1e 	bne	r2,zero,9081064 <alt_NetworkErrorHandler+0x1dc>
 9080f68:	e0ffff17 	ldw	r3,-4(fp)
 9080f6c:	188000a0 	cmpeqi	r2,r3,2
 9080f70:	10001d1e 	bne	r2,zero,9080fe8 <alt_NetworkErrorHandler+0x160>
 9080f74:	00005806 	br	90810d8 <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 9080f78:	01024374 	movhi	r4,2317
 9080f7c:	2130d604 	addi	r4,r4,-15528
 9080f80:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 9080f84:	00824374 	movhi	r2,2317
 9080f88:	108e8604 	addi	r2,r2,14872
 9080f8c:	10800017 	ldw	r2,0(r2)
 9080f90:	11c00317 	ldw	r7,12(r2)
 9080f94:	01024374 	movhi	r4,2317
 9080f98:	2130e204 	addi	r4,r4,-15480
 9080f9c:	01400044 	movi	r5,1
 9080fa0:	018007c4 	movi	r6,31
 9080fa4:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 9080fa8:	00824374 	movhi	r2,2317
 9080fac:	108e8604 	addi	r2,r2,14872
 9080fb0:	10800017 	ldw	r2,0(r2)
 9080fb4:	11c00317 	ldw	r7,12(r2)
 9080fb8:	01024374 	movhi	r4,2317
 9080fbc:	2130ea04 	addi	r4,r4,-15448
 9080fc0:	01400044 	movi	r5,1
 9080fc4:	018008c4 	movi	r6,35
 9080fc8:	90831100 	call	9083110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 9080fcc:	908ec280 	call	908ec28 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 9080fd0:	01003fc4 	movi	r4,255
 9080fd4:	9094cf80 	call	9094cf8 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 9080fd8:	e13ffd03 	ldbu	r4,-12(fp)
 9080fdc:	000b883a 	mov	r5,zero
 9080fe0:	90808640 	call	9080864 <alt_uCOSIIErrorHandler>
         break;
 9080fe4:	00004806 	br	9081108 <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 9080fe8:	01024374 	movhi	r4,2317
 9080fec:	2130f304 	addi	r4,r4,-15412
 9080ff0:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 9080ff4:	00824374 	movhi	r2,2317
 9080ff8:	108e8604 	addi	r2,r2,14872
 9080ffc:	10800017 	ldw	r2,0(r2)
 9081000:	11c00317 	ldw	r7,12(r2)
 9081004:	01024374 	movhi	r4,2317
 9081008:	2130ff04 	addi	r4,r4,-15364
 908100c:	01400044 	movi	r5,1
 9081010:	01800884 	movi	r6,34
 9081014:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 9081018:	00824374 	movhi	r2,2317
 908101c:	108e8604 	addi	r2,r2,14872
 9081020:	10800017 	ldw	r2,0(r2)
 9081024:	11c00317 	ldw	r7,12(r2)
 9081028:	01024374 	movhi	r4,2317
 908102c:	21310804 	addi	r4,r4,-15328
 9081030:	01400044 	movi	r5,1
 9081034:	01800a84 	movi	r6,42
 9081038:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 908103c:	00824374 	movhi	r2,2317
 9081040:	108e8604 	addi	r2,r2,14872
 9081044:	10800017 	ldw	r2,0(r2)
 9081048:	11c00317 	ldw	r7,12(r2)
 908104c:	01024374 	movhi	r4,2317
 9081050:	21311304 	addi	r4,r4,-15284
 9081054:	01400044 	movi	r5,1
 9081058:	01800b84 	movi	r6,46
 908105c:	90831100 	call	9083110 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 9081060:	003fff06 	br	9081060 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 9081064:	00824374 	movhi	r2,2317
 9081068:	108e8604 	addi	r2,r2,14872
 908106c:	10800017 	ldw	r2,0(r2)
 9081070:	11c00317 	ldw	r7,12(r2)
 9081074:	01024374 	movhi	r4,2317
 9081078:	21311f04 	addi	r4,r4,-15236
 908107c:	01400044 	movi	r5,1
 9081080:	01800804 	movi	r6,32
 9081084:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 9081088:	00824374 	movhi	r2,2317
 908108c:	108e8604 	addi	r2,r2,14872
 9081090:	10800017 	ldw	r2,0(r2)
 9081094:	11c00317 	ldw	r7,12(r2)
 9081098:	01024374 	movhi	r4,2317
 908109c:	21312804 	addi	r4,r4,-15200
 90810a0:	01400044 	movi	r5,1
 90810a4:	01800d84 	movi	r6,54
 90810a8:	90831100 	call	9083110 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 90810ac:	00824374 	movhi	r2,2317
 90810b0:	108e8604 	addi	r2,r2,14872
 90810b4:	10800017 	ldw	r2,0(r2)
 90810b8:	11c00317 	ldw	r7,12(r2)
 90810bc:	01024374 	movhi	r4,2317
 90810c0:	21313604 	addi	r4,r4,-15144
 90810c4:	01400044 	movi	r5,1
 90810c8:	01800e44 	movi	r6,57
 90810cc:	90831100 	call	9083110 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 90810d0:	908ec280 	call	908ec28 <OSSchedUnlock>
         return;
 90810d4:	00000d06 	br	908110c <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 90810d8:	01024374 	movhi	r4,2317
 90810dc:	21314504 	addi	r4,r4,-15084
 90810e0:	90836b80 	call	90836b8 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 90810e4:	00824374 	movhi	r2,2317
 90810e8:	108e8604 	addi	r2,r2,14872
 90810ec:	10800017 	ldw	r2,0(r2)
 90810f0:	11c00317 	ldw	r7,12(r2)
 90810f4:	01024374 	movhi	r4,2317
 90810f8:	21315204 	addi	r4,r4,-15032
 90810fc:	01400044 	movi	r5,1
 9081100:	01800984 	movi	r6,38
 9081104:	90831100 	call	9083110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 9081108:	003fff06 	br	9081108 <alt_NetworkErrorHandler+0x280>
}
 908110c:	e037883a 	mov	sp,fp
 9081110:	dfc00117 	ldw	ra,4(sp)
 9081114:	df000017 	ldw	fp,0(sp)
 9081118:	dec00204 	addi	sp,sp,8
 908111c:	f800283a 	ret

09081120 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 9081120:	defff804 	addi	sp,sp,-32
 9081124:	dfc00715 	stw	ra,28(sp)
 9081128:	df000615 	stw	fp,24(sp)
 908112c:	df000604 	addi	fp,sp,24
 9081130:	e17ffc15 	stw	r5,-16(fp)
 9081134:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 9081138:	e0bffb03 	ldbu	r2,-20(fp)
 908113c:	1005003a 	cmpeq	r2,r2,zero
 9081140:	1000ad1e 	bne	r2,zero,90813f8 <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 9081144:	e0bffb03 	ldbu	r2,-20(fp)
 9081148:	1004c03a 	cmpne	r2,r2,zero
 908114c:	1000021e 	bne	r2,zero,9081158 <alt_SSSErrorHandler+0x38>
 9081150:	e03ffe15 	stw	zero,-8(fp)
 9081154:	00000206 	br	9081160 <alt_SSSErrorHandler+0x40>
 9081158:	00800084 	movi	r2,2
 908115c:	e0bffe15 	stw	r2,-8(fp)
 9081160:	e0fffe17 	ldw	r3,-8(fp)
 9081164:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 9081168:	908eb9c0 	call	908eb9c <OSSchedLock>
   switch (error_code)
 908116c:	e0bffb03 	ldbu	r2,-20(fp)
 9081170:	e0bffd15 	stw	r2,-12(fp)
 9081174:	e0fffd17 	ldw	r3,-12(fp)
 9081178:	188007a0 	cmpeqi	r2,r3,30
 908117c:	1000121e 	bne	r2,zero,90811c8 <alt_SSSErrorHandler+0xa8>
 9081180:	e0fffd17 	ldw	r3,-12(fp)
 9081184:	18803fe0 	cmpeqi	r2,r3,255
 9081188:	1000011e 	bne	r2,zero,9081190 <alt_SSSErrorHandler+0x70>
 908118c:	00001906 	br	90811f4 <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 9081190:	00800084 	movi	r2,2
 9081194:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 9081198:	01024374 	movhi	r4,2317
 908119c:	21315c04 	addi	r4,r4,-14992
 90811a0:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 90811a4:	00824374 	movhi	r2,2317
 90811a8:	108e8604 	addi	r2,r2,14872
 90811ac:	10800017 	ldw	r2,0(r2)
 90811b0:	11000317 	ldw	r4,12(r2)
 90811b4:	e1bffc17 	ldw	r6,-16(fp)
 90811b8:	01424374 	movhi	r5,2317
 90811bc:	29716a04 	addi	r5,r5,-14936
 90811c0:	90830140 	call	9083014 <fprintf>
         break;
 90811c4:	00001b06 	br	9081234 <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 90811c8:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 90811cc:	00824374 	movhi	r2,2317
 90811d0:	108e8604 	addi	r2,r2,14872
 90811d4:	10800017 	ldw	r2,0(r2)
 90811d8:	11c00317 	ldw	r7,12(r2)
 90811dc:	01024374 	movhi	r4,2317
 90811e0:	21316d04 	addi	r4,r4,-14924
 90811e4:	01400044 	movi	r5,1
 90811e8:	01800c84 	movi	r6,50
 90811ec:	90831100 	call	9083110 <fwrite>
         break;
 90811f0:	00001006 	br	9081234 <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 90811f4:	00800084 	movi	r2,2
 90811f8:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 90811fc:	01024374 	movhi	r4,2317
 9081200:	21317a04 	addi	r4,r4,-14872
 9081204:	90836b80 	call	90836b8 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 9081208:	00824374 	movhi	r2,2317
 908120c:	108e8604 	addi	r2,r2,14872
 9081210:	10800017 	ldw	r2,0(r2)
 9081214:	11000317 	ldw	r4,12(r2)
 9081218:	e1bffb03 	ldbu	r6,-20(fp)
 908121c:	01424374 	movhi	r5,2317
 9081220:	29717f04 	addi	r5,r5,-14852
 9081224:	90830140 	call	9083014 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 9081228:	01024374 	movhi	r4,2317
 908122c:	21318504 	addi	r4,r4,-14828
 9081230:	908337c0 	call	908337c <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 9081234:	e0bffa17 	ldw	r2,-24(fp)
 9081238:	e0bfff15 	stw	r2,-4(fp)
 908123c:	e0ffff17 	ldw	r3,-4(fp)
 9081240:	18800060 	cmpeqi	r2,r3,1
 9081244:	1000071e 	bne	r2,zero,9081264 <alt_SSSErrorHandler+0x144>
 9081248:	e0ffff17 	ldw	r3,-4(fp)
 908124c:	18800070 	cmpltui	r2,r3,1
 9081250:	10003f1e 	bne	r2,zero,9081350 <alt_SSSErrorHandler+0x230>
 9081254:	e0ffff17 	ldw	r3,-4(fp)
 9081258:	188000a0 	cmpeqi	r2,r3,2
 908125c:	10001d1e 	bne	r2,zero,90812d4 <alt_SSSErrorHandler+0x1b4>
 9081260:	00005806 	br	90813c4 <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 9081264:	01024374 	movhi	r4,2317
 9081268:	21318a04 	addi	r4,r4,-14808
 908126c:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 9081270:	00824374 	movhi	r2,2317
 9081274:	108e8604 	addi	r2,r2,14872
 9081278:	10800017 	ldw	r2,0(r2)
 908127c:	11c00317 	ldw	r7,12(r2)
 9081280:	01024374 	movhi	r4,2317
 9081284:	21319504 	addi	r4,r4,-14764
 9081288:	01400044 	movi	r5,1
 908128c:	018006c4 	movi	r6,27
 9081290:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 9081294:	00824374 	movhi	r2,2317
 9081298:	108e8604 	addi	r2,r2,14872
 908129c:	10800017 	ldw	r2,0(r2)
 90812a0:	11c00317 	ldw	r7,12(r2)
 90812a4:	01024374 	movhi	r4,2317
 90812a8:	21319c04 	addi	r4,r4,-14736
 90812ac:	01400044 	movi	r5,1
 90812b0:	018007c4 	movi	r6,31
 90812b4:	90831100 	call	9083110 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 90812b8:	908ec280 	call	908ec28 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 90812bc:	01003fc4 	movi	r4,255
 90812c0:	9094cf80 	call	9094cf8 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 90812c4:	e13ffb03 	ldbu	r4,-20(fp)
 90812c8:	000b883a 	mov	r5,zero
 90812cc:	90808640 	call	9080864 <alt_uCOSIIErrorHandler>
         break;
 90812d0:	00004806 	br	90813f4 <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 90812d4:	01024374 	movhi	r4,2317
 90812d8:	2131a404 	addi	r4,r4,-14704
 90812dc:	90833900 	call	9083390 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 90812e0:	00824374 	movhi	r2,2317
 90812e4:	108e8604 	addi	r2,r2,14872
 90812e8:	10800017 	ldw	r2,0(r2)
 90812ec:	11c00317 	ldw	r7,12(r2)
 90812f0:	01024374 	movhi	r4,2317
 90812f4:	2131af04 	addi	r4,r4,-14660
 90812f8:	01400044 	movi	r5,1
 90812fc:	01800784 	movi	r6,30
 9081300:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 9081304:	00824374 	movhi	r2,2317
 9081308:	108e8604 	addi	r2,r2,14872
 908130c:	10800017 	ldw	r2,0(r2)
 9081310:	11c00317 	ldw	r7,12(r2)
 9081314:	01024374 	movhi	r4,2317
 9081318:	2131b704 	addi	r4,r4,-14628
 908131c:	01400044 	movi	r5,1
 9081320:	01800984 	movi	r6,38
 9081324:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 9081328:	00824374 	movhi	r2,2317
 908132c:	108e8604 	addi	r2,r2,14872
 9081330:	10800017 	ldw	r2,0(r2)
 9081334:	11c00317 	ldw	r7,12(r2)
 9081338:	01024374 	movhi	r4,2317
 908133c:	2131c104 	addi	r4,r4,-14588
 9081340:	01400044 	movi	r5,1
 9081344:	01800a84 	movi	r6,42
 9081348:	90831100 	call	9083110 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 908134c:	003fff06 	br	908134c <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 9081350:	00824374 	movhi	r2,2317
 9081354:	108e8604 	addi	r2,r2,14872
 9081358:	10800017 	ldw	r2,0(r2)
 908135c:	11c00317 	ldw	r7,12(r2)
 9081360:	01024374 	movhi	r4,2317
 9081364:	2131cc04 	addi	r4,r4,-14544
 9081368:	01400044 	movi	r5,1
 908136c:	018006c4 	movi	r6,27
 9081370:	90831100 	call	9083110 <fwrite>
         fprintf(stderr, 
 9081374:	00824374 	movhi	r2,2317
 9081378:	108e8604 	addi	r2,r2,14872
 908137c:	10800017 	ldw	r2,0(r2)
 9081380:	11c00317 	ldw	r7,12(r2)
 9081384:	01024374 	movhi	r4,2317
 9081388:	2131d304 	addi	r4,r4,-14516
 908138c:	01400044 	movi	r5,1
 9081390:	01800f44 	movi	r6,61
 9081394:	90831100 	call	9083110 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 9081398:	00824374 	movhi	r2,2317
 908139c:	108e8604 	addi	r2,r2,14872
 90813a0:	10800017 	ldw	r2,0(r2)
 90813a4:	11c00317 	ldw	r7,12(r2)
 90813a8:	01024374 	movhi	r4,2317
 90813ac:	2131e304 	addi	r4,r4,-14452
 90813b0:	01400044 	movi	r5,1
 90813b4:	01800b84 	movi	r6,46
 90813b8:	90831100 	call	9083110 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 90813bc:	908ec280 	call	908ec28 <OSSchedUnlock>
         return;         
 90813c0:	00000d06 	br	90813f8 <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 90813c4:	01024374 	movhi	r4,2317
 90813c8:	2131ef04 	addi	r4,r4,-14404
 90813cc:	90836b80 	call	90836b8 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 90813d0:	00824374 	movhi	r2,2317
 90813d4:	108e8604 	addi	r2,r2,14872
 90813d8:	10800017 	ldw	r2,0(r2)
 90813dc:	11c00317 	ldw	r7,12(r2)
 90813e0:	01024374 	movhi	r4,2317
 90813e4:	2131fb04 	addi	r4,r4,-14356
 90813e8:	01400044 	movi	r5,1
 90813ec:	01800844 	movi	r6,33
 90813f0:	90831100 	call	9083110 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 90813f4:	003fff06 	br	90813f4 <alt_SSSErrorHandler+0x2d4>
}
 90813f8:	e037883a 	mov	sp,fp
 90813fc:	dfc00117 	ldw	ra,4(sp)
 9081400:	df000017 	ldw	fp,0(sp)
 9081404:	dec00204 	addi	sp,sp,8
 9081408:	f800283a 	ret

0908140c <atoul>:
atoul(src, srclen, base, resultp)
const char *src;
size_t srclen;			/* 0 means strlen(src) */
int base;			/* 0 means figure it out */
unsigned long *resultp;
{
 908140c:	defff204 	addi	sp,sp,-56
 9081410:	dfc00d15 	stw	ra,52(sp)
 9081414:	df000c15 	stw	fp,48(sp)
 9081418:	df000c04 	addi	fp,sp,48
 908141c:	e13ffb15 	stw	r4,-20(fp)
 9081420:	e17ffc15 	stw	r5,-16(fp)
 9081424:	e1bffd15 	stw	r6,-12(fp)
 9081428:	e1fffe15 	stw	r7,-8(fp)
	char *p;
	unsigned long r;
	unsigned long rlimit;
	int dlimit;

	if (srclen == 0)
 908142c:	e0bffc17 	ldw	r2,-16(fp)
 9081430:	1004c03a 	cmpne	r2,r2,zero
 9081434:	1000031e 	bne	r2,zero,9081444 <atoul+0x38>
		srclen = strlen(src);
 9081438:	e13ffb17 	ldw	r4,-20(fp)
 908143c:	9083f540 	call	9083f54 <strlen>
 9081440:	e0bffc15 	stw	r2,-16(fp)
	if (srclen == 0)
 9081444:	e0bffc17 	ldw	r2,-16(fp)
 9081448:	1004c03a 	cmpne	r2,r2,zero
 908144c:	1000041e 	bne	r2,zero,9081460 <atoul+0x54>
		return "empty string";
 9081450:	00824374 	movhi	r2,2317
 9081454:	10b20404 	addi	r2,r2,-14320
 9081458:	e0bfff15 	stw	r2,-4(fp)
 908145c:	0000bf06 	br	908175c <atoul+0x350>

	if (base == 0 || base == 13) {
 9081460:	e0bffd17 	ldw	r2,-12(fp)
 9081464:	1005003a 	cmpeq	r2,r2,zero
 9081468:	1000031e 	bne	r2,zero,9081478 <atoul+0x6c>
 908146c:	e0bffd17 	ldw	r2,-12(fp)
 9081470:	10800358 	cmpnei	r2,r2,13
 9081474:	1000381e 	bne	r2,zero,9081558 <atoul+0x14c>
//		if (srclen > 2 && *src == '0' && CIEQ(*(src+1), 'x'))
		if (srclen > 2 && *src == '0' && *(src+1) == 'x')
 9081478:	e0bffc17 	ldw	r2,-16(fp)
 908147c:	108000f0 	cmpltui	r2,r2,3
 9081480:	1000181e 	bne	r2,zero,90814e4 <atoul+0xd8>
 9081484:	e0bffb17 	ldw	r2,-20(fp)
 9081488:	10800003 	ldbu	r2,0(r2)
 908148c:	10803fcc 	andi	r2,r2,255
 9081490:	1080201c 	xori	r2,r2,128
 9081494:	10bfe004 	addi	r2,r2,-128
 9081498:	10800c18 	cmpnei	r2,r2,48
 908149c:	1000111e 	bne	r2,zero,90814e4 <atoul+0xd8>
 90814a0:	e0bffb17 	ldw	r2,-20(fp)
 90814a4:	10800044 	addi	r2,r2,1
 90814a8:	10800003 	ldbu	r2,0(r2)
 90814ac:	10803fcc 	andi	r2,r2,255
 90814b0:	1080201c 	xori	r2,r2,128
 90814b4:	10bfe004 	addi	r2,r2,-128
 90814b8:	10801e18 	cmpnei	r2,r2,120
 90814bc:	1000091e 	bne	r2,zero,90814e4 <atoul+0xd8>
			return atoul(src+2, srclen-2, 16, resultp);
 90814c0:	e0bffb17 	ldw	r2,-20(fp)
 90814c4:	11000084 	addi	r4,r2,2
 90814c8:	e0bffc17 	ldw	r2,-16(fp)
 90814cc:	117fff84 	addi	r5,r2,-2
 90814d0:	01800404 	movi	r6,16
 90814d4:	e1fffe17 	ldw	r7,-8(fp)
 90814d8:	908140c0 	call	908140c <atoul>
 90814dc:	e0bfff15 	stw	r2,-4(fp)
 90814e0:	00009e06 	br	908175c <atoul+0x350>
		if (srclen > 1 && *src == '0' && base != 13)
 90814e4:	e0bffc17 	ldw	r2,-16(fp)
 90814e8:	108000b0 	cmpltui	r2,r2,2
 90814ec:	1000131e 	bne	r2,zero,908153c <atoul+0x130>
 90814f0:	e0bffb17 	ldw	r2,-20(fp)
 90814f4:	10800003 	ldbu	r2,0(r2)
 90814f8:	10803fcc 	andi	r2,r2,255
 90814fc:	1080201c 	xori	r2,r2,128
 9081500:	10bfe004 	addi	r2,r2,-128
 9081504:	10800c18 	cmpnei	r2,r2,48
 9081508:	10000c1e 	bne	r2,zero,908153c <atoul+0x130>
 908150c:	e0bffd17 	ldw	r2,-12(fp)
 9081510:	10800360 	cmpeqi	r2,r2,13
 9081514:	1000091e 	bne	r2,zero,908153c <atoul+0x130>
			return atoul(src+1, srclen-1, 8, resultp);
 9081518:	e0bffb17 	ldw	r2,-20(fp)
 908151c:	11000044 	addi	r4,r2,1
 9081520:	e0bffc17 	ldw	r2,-16(fp)
 9081524:	117fffc4 	addi	r5,r2,-1
 9081528:	01800204 	movi	r6,8
 908152c:	e1fffe17 	ldw	r7,-8(fp)
 9081530:	908140c0 	call	908140c <atoul>
 9081534:	e0bfff15 	stw	r2,-4(fp)
 9081538:	00008806 	br	908175c <atoul+0x350>
		return atoul(src, srclen, 10, resultp);
 908153c:	e13ffb17 	ldw	r4,-20(fp)
 9081540:	e17ffc17 	ldw	r5,-16(fp)
 9081544:	01800284 	movi	r6,10
 9081548:	e1fffe17 	ldw	r7,-8(fp)
 908154c:	908140c0 	call	908140c <atoul>
 9081550:	e0bfff15 	stw	r2,-4(fp)
 9081554:	00008106 	br	908175c <atoul+0x350>
	}
	if (base != 8 && base != 10 && base != 16)
 9081558:	e0bffd17 	ldw	r2,-12(fp)
 908155c:	10800220 	cmpeqi	r2,r2,8
 9081560:	10000a1e 	bne	r2,zero,908158c <atoul+0x180>
 9081564:	e0bffd17 	ldw	r2,-12(fp)
 9081568:	108002a0 	cmpeqi	r2,r2,10
 908156c:	1000071e 	bne	r2,zero,908158c <atoul+0x180>
 9081570:	e0bffd17 	ldw	r2,-12(fp)
 9081574:	10800420 	cmpeqi	r2,r2,16
 9081578:	1000041e 	bne	r2,zero,908158c <atoul+0x180>
		return "unsupported number base";
 908157c:	00824374 	movhi	r2,2317
 9081580:	10b20804 	addi	r2,r2,-14304
 9081584:	e0bfff15 	stw	r2,-4(fp)
 9081588:	00007406 	br	908175c <atoul+0x350>

	r = 0;
 908158c:	e03ff615 	stw	zero,-40(fp)
	stop = src + srclen;
 9081590:	e0fffc17 	ldw	r3,-16(fp)
 9081594:	e0bffb17 	ldw	r2,-20(fp)
 9081598:	10c5883a 	add	r2,r2,r3
 908159c:	e0bffa15 	stw	r2,-24(fp)
	if (base == 16) {
 90815a0:	e0bffd17 	ldw	r2,-12(fp)
 90815a4:	10800418 	cmpnei	r2,r2,16
 90815a8:	1000351e 	bne	r2,zero,9081680 <atoul+0x274>
		while (src < stop) {
 90815ac:	00002a06 	br	9081658 <atoul+0x24c>
			c = *src++;
 90815b0:	e0bffb17 	ldw	r2,-20(fp)
 90815b4:	10800003 	ldbu	r2,0(r2)
 90815b8:	e0bff805 	stb	r2,-32(fp)
 90815bc:	e0bffb17 	ldw	r2,-20(fp)
 90815c0:	10800044 	addi	r2,r2,1
 90815c4:	e0bffb15 	stw	r2,-20(fp)
			p = strchr(hex, c);
 90815c8:	e17ff807 	ldb	r5,-32(fp)
 90815cc:	01024374 	movhi	r4,2317
 90815d0:	21068904 	addi	r4,r4,6692
 90815d4:	90838000 	call	9083800 <strchr>
 90815d8:	e0bff715 	stw	r2,-36(fp)
			if (p != NULL)
 90815dc:	e0bff717 	ldw	r2,-36(fp)
 90815e0:	1005003a 	cmpeq	r2,r2,zero
 90815e4:	1000061e 	bne	r2,zero,9081600 <atoul+0x1f4>
				d = p - hex;
 90815e8:	e0bff717 	ldw	r2,-36(fp)
 90815ec:	00c24374 	movhi	r3,2317
 90815f0:	18c68904 	addi	r3,r3,6692
 90815f4:	10c5c83a 	sub	r2,r2,r3
 90815f8:	e0bff915 	stw	r2,-28(fp)
 90815fc:	00001106 	br	9081644 <atoul+0x238>
			else {
				p = strchr(uchex, c);
 9081600:	e17ff807 	ldb	r5,-32(fp)
 9081604:	01024374 	movhi	r4,2317
 9081608:	21068404 	addi	r4,r4,6672
 908160c:	90838000 	call	9083800 <strchr>
 9081610:	e0bff715 	stw	r2,-36(fp)
				if (p == NULL)
 9081614:	e0bff717 	ldw	r2,-36(fp)
 9081618:	1004c03a 	cmpne	r2,r2,zero
 908161c:	1000041e 	bne	r2,zero,9081630 <atoul+0x224>
					return "non-hex-digit in hex number";
 9081620:	00824374 	movhi	r2,2317
 9081624:	10b20e04 	addi	r2,r2,-14280
 9081628:	e0bfff15 	stw	r2,-4(fp)
 908162c:	00004b06 	br	908175c <atoul+0x350>
				d = p - uchex;
 9081630:	e0bff717 	ldw	r2,-36(fp)
 9081634:	00c24374 	movhi	r3,2317
 9081638:	18c68404 	addi	r3,r3,6672
 908163c:	10c5c83a 	sub	r2,r2,r3
 9081640:	e0bff915 	stw	r2,-28(fp)
			}
			r = (r << 4) | d;
 9081644:	e0bff617 	ldw	r2,-40(fp)
 9081648:	1006913a 	slli	r3,r2,4
 908164c:	e0bff917 	ldw	r2,-28(fp)
 9081650:	1884b03a 	or	r2,r3,r2
 9081654:	e0bff615 	stw	r2,-40(fp)
		return "unsupported number base";

	r = 0;
	stop = src + srclen;
	if (base == 16) {
		while (src < stop) {
 9081658:	e0fffb17 	ldw	r3,-20(fp)
 908165c:	e0bffa17 	ldw	r2,-24(fp)
 9081660:	18bfd336 	bltu	r3,r2,90815b0 <atoul+0x1a4>
				d = p - uchex;
			}
			r = (r << 4) | d;
		}
		/* defer length check to catch invalid digits first */
		if (srclen > sizeof(unsigned long) * 2)
 9081664:	e0bffc17 	ldw	r2,-16(fp)
 9081668:	10800270 	cmpltui	r2,r2,9
 908166c:	1000371e 	bne	r2,zero,908174c <atoul+0x340>
			return "hex number too long";
 9081670:	00824374 	movhi	r2,2317
 9081674:	10b21504 	addi	r2,r2,-14252
 9081678:	e0bfff15 	stw	r2,-4(fp)
 908167c:	00003706 	br	908175c <atoul+0x350>
	} else {
		rlimit = ULONG_MAX / base;
 9081680:	e0fffd17 	ldw	r3,-12(fp)
 9081684:	00bfffc4 	movi	r2,-1
 9081688:	10c5203a 	divu	r2,r2,r3
 908168c:	e0bff515 	stw	r2,-44(fp)
		dlimit = (int)(ULONG_MAX - rlimit*base);
 9081690:	e0fffd17 	ldw	r3,-12(fp)
 9081694:	e0bff517 	ldw	r2,-44(fp)
 9081698:	1885383a 	mul	r2,r3,r2
 908169c:	0084303a 	nor	r2,zero,r2
 90816a0:	e0bff415 	stw	r2,-48(fp)
		while (src < stop) {
 90816a4:	00002606 	br	9081740 <atoul+0x334>
			c = *src++;
 90816a8:	e0bffb17 	ldw	r2,-20(fp)
 90816ac:	10800003 	ldbu	r2,0(r2)
 90816b0:	e0bff805 	stb	r2,-32(fp)
 90816b4:	e0bffb17 	ldw	r2,-20(fp)
 90816b8:	10800044 	addi	r2,r2,1
 90816bc:	e0bffb15 	stw	r2,-20(fp)
			d = c - '0';
 90816c0:	e0bff807 	ldb	r2,-32(fp)
 90816c4:	10bff404 	addi	r2,r2,-48
 90816c8:	e0bff915 	stw	r2,-28(fp)
			if (d < 0 || d >= base)
 90816cc:	e0bff917 	ldw	r2,-28(fp)
 90816d0:	1004803a 	cmplt	r2,r2,zero
 90816d4:	1000031e 	bne	r2,zero,90816e4 <atoul+0x2d8>
 90816d8:	e0fff917 	ldw	r3,-28(fp)
 90816dc:	e0bffd17 	ldw	r2,-12(fp)
 90816e0:	18800416 	blt	r3,r2,90816f4 <atoul+0x2e8>
				return "non-digit in number";
 90816e4:	00824374 	movhi	r2,2317
 90816e8:	10b21a04 	addi	r2,r2,-14232
 90816ec:	e0bfff15 	stw	r2,-4(fp)
 90816f0:	00001a06 	br	908175c <atoul+0x350>
			if (r > rlimit || (r == rlimit && d > dlimit))
 90816f4:	e0fff617 	ldw	r3,-40(fp)
 90816f8:	e0bff517 	ldw	r2,-44(fp)
 90816fc:	10c00636 	bltu	r2,r3,9081718 <atoul+0x30c>
 9081700:	e0fff617 	ldw	r3,-40(fp)
 9081704:	e0bff517 	ldw	r2,-44(fp)
 9081708:	1880071e 	bne	r3,r2,9081728 <atoul+0x31c>
 908170c:	e0fff917 	ldw	r3,-28(fp)
 9081710:	e0bff417 	ldw	r2,-48(fp)
 9081714:	10c0040e 	bge	r2,r3,9081728 <atoul+0x31c>
				return "unsigned-long overflow";
 9081718:	00824374 	movhi	r2,2317
 908171c:	10b21f04 	addi	r2,r2,-14212
 9081720:	e0bfff15 	stw	r2,-4(fp)
 9081724:	00000d06 	br	908175c <atoul+0x350>
			r = r*base + d;
 9081728:	e0fffd17 	ldw	r3,-12(fp)
 908172c:	e0bff617 	ldw	r2,-40(fp)
 9081730:	1887383a 	mul	r3,r3,r2
 9081734:	e0bff917 	ldw	r2,-28(fp)
 9081738:	1885883a 	add	r2,r3,r2
 908173c:	e0bff615 	stw	r2,-40(fp)
		if (srclen > sizeof(unsigned long) * 2)
			return "hex number too long";
	} else {
		rlimit = ULONG_MAX / base;
		dlimit = (int)(ULONG_MAX - rlimit*base);
		while (src < stop) {
 9081740:	e0fffb17 	ldw	r3,-20(fp)
 9081744:	e0bffa17 	ldw	r2,-24(fp)
 9081748:	18bfd736 	bltu	r3,r2,90816a8 <atoul+0x29c>
				return "unsigned-long overflow";
			r = r*base + d;
		}
	}

	*resultp = r;
 908174c:	e0fffe17 	ldw	r3,-8(fp)
 9081750:	e0bff617 	ldw	r2,-40(fp)
 9081754:	18800015 	stw	r2,0(r3)
	return NULL;
 9081758:	e03fff15 	stw	zero,-4(fp)
 908175c:	e0bfff17 	ldw	r2,-4(fp)
}
 9081760:	e037883a 	mov	sp,fp
 9081764:	dfc00117 	ldw	ra,4(sp)
 9081768:	df000017 	ldw	fp,0(sp)
 908176c:	dec00204 	addi	sp,sp,8
 9081770:	f800283a 	ret

09081774 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 9081774:	defffc04 	addi	sp,sp,-16
 9081778:	dfc00315 	stw	ra,12(sp)
 908177c:	df000215 	stw	fp,8(sp)
 9081780:	df000204 	addi	fp,sp,8
 9081784:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 9081788:	90aabe00 	call	90aabe0 <alt_iniche_init>
  netmain(); 
 908178c:	90a5a900 	call	90a5a90 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 9081790:	00000206 	br	908179c <SSSInitialTask+0x28>
    TK_SLEEP(1);
 9081794:	01000084 	movi	r4,2
 9081798:	9095df00 	call	9095df0 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 908179c:	00824374 	movhi	r2,2317
 90817a0:	108f1204 	addi	r2,r2,15432
 90817a4:	10800017 	ldw	r2,0(r2)
 90817a8:	1005003a 	cmpeq	r2,r2,zero
 90817ac:	103ff91e 	bne	r2,zero,9081794 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 90817b0:	01024374 	movhi	r4,2317
 90817b4:	21322b04 	addi	r4,r4,-14164
 90817b8:	90836b80 	call	90836b8 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 90817bc:	01024374 	movhi	r4,2317
 90817c0:	21068e04 	addi	r4,r4,6712
 90817c4:	90aa8a00 	call	90aa8a0 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 90817c8:	9081c2c0 	call	9081c2c <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 90817cc:	9081c480 	call	9081c48 <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 90817d0:	01003fc4 	movi	r4,255
 90817d4:	9094cf80 	call	9094cf8 <OSTaskDel>
 90817d8:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 90817dc:	e13ffe03 	ldbu	r4,-8(fp)
 90817e0:	000b883a 	mov	r5,zero
 90817e4:	90808640 	call	9080864 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 90817e8:	003fff06 	br	90817e8 <SSSInitialTask+0x74>

090817ec <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 90817ec:	defff504 	addi	sp,sp,-44
 90817f0:	dfc00a15 	stw	ra,40(sp)
 90817f4:	df000915 	stw	fp,36(sp)
 90817f8:	df000904 	addi	fp,sp,36
 90817fc:	e13ffd15 	stw	r4,-12(fp)
 9081800:	e17ffe15 	stw	r5,-8(fp)
 9081804:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 9081808:	0009883a 	mov	r4,zero
 908180c:	90963f40 	call	90963f4 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 9081810:	01824374 	movhi	r6,2317
 9081814:	319d0e04 	addi	r6,r6,29752
 9081818:	00800144 	movi	r2,5
 908181c:	d8800015 	stw	r2,0(sp)
 9081820:	00824374 	movhi	r2,2317
 9081824:	10950e04 	addi	r2,r2,21560
 9081828:	d8800115 	stw	r2,4(sp)
 908182c:	00820004 	movi	r2,2048
 9081830:	d8800215 	stw	r2,8(sp)
 9081834:	d8000315 	stw	zero,12(sp)
 9081838:	d8000415 	stw	zero,16(sp)
 908183c:	01024234 	movhi	r4,2312
 9081840:	2105dd04 	addi	r4,r4,6004
 9081844:	000b883a 	mov	r5,zero
 9081848:	01c00144 	movi	r7,5
 908184c:	9094af80 	call	9094af8 <OSTaskCreateExt>
 9081850:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 9081854:	e13ffc03 	ldbu	r4,-16(fp)
 9081858:	000b883a 	mov	r5,zero
 908185c:	90808640 	call	9080864 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 9081860:	908ed0c0 	call	908ed0c <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 9081864:	003fff06 	br	9081864 <main+0x78>

09081868 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 9081868:	defffb04 	addi	sp,sp,-20
 908186c:	dfc00415 	stw	ra,16(sp)
 9081870:	df000315 	stw	fp,12(sp)
 9081874:	df000304 	addi	fp,sp,12
 9081878:	e13ffe15 	stw	r4,-8(fp)
 908187c:	e17fff15 	stw	r5,-4(fp)
    error_t error = 1;
 9081880:	00800044 	movi	r2,1
 9081884:	e0bffd15 	stw	r2,-12(fp)
    
//    error = get_board_mac_addr(mac_addr);
    
    if(error)
 9081888:	e0bffd17 	ldw	r2,-12(fp)
 908188c:	1005003a 	cmpeq	r2,r2,zero
 9081890:	1000031e 	bne	r2,zero,90818a0 <get_mac_addr+0x38>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 9081894:	e13fff17 	ldw	r4,-4(fp)
 9081898:	9081af00 	call	9081af0 <generate_mac_addr>
 908189c:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 90818a0:	e0bffd17 	ldw	r2,-12(fp)
}
 90818a4:	e037883a 	mov	sp,fp
 90818a8:	dfc00117 	ldw	ra,4(sp)
 90818ac:	df000017 	ldw	fp,0(sp)
 90818b0:	dec00204 	addi	sp,sp,8
 90818b4:	f800283a 	ret

090818b8 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 90818b8:	defffb04 	addi	sp,sp,-20
 90818bc:	df000415 	stw	fp,16(sp)
 90818c0:	df000404 	addi	fp,sp,16
 90818c4:	e13ffc15 	stw	r4,-16(fp)
 90818c8:	e17ffd15 	stw	r5,-12(fp)
 90818cc:	e1bffe15 	stw	r6,-8(fp)
 90818d0:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 90818d4:	e0bffd17 	ldw	r2,-12(fp)
 90818d8:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 90818dc:	e0bfff17 	ldw	r2,-4(fp)
 90818e0:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 90818e4:	e0fffe17 	ldw	r3,-8(fp)
 90818e8:	00804034 	movhi	r2,256
 90818ec:	10bfffc4 	addi	r2,r2,-1
 90818f0:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 90818f4:	e0c00117 	ldw	r3,4(fp)
 90818f8:	00800044 	movi	r2,1
 90818fc:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 9081900:	00800044 	movi	r2,1
}
 9081904:	e037883a 	mov	sp,fp
 9081908:	df000017 	ldw	fp,0(sp)
 908190c:	dec00104 	addi	sp,sp,4
 9081910:	f800283a 	ret

09081914 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 9081914:	defff804 	addi	sp,sp,-32
 9081918:	dfc00715 	stw	ra,28(sp)
 908191c:	df000615 	stw	fp,24(sp)
 9081920:	dc000515 	stw	r16,20(sp)
 9081924:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 9081928:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 908192c:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 9081930:	00006506 	br	9081ac8 <get_serial_number+0x1b4>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 9081934:	01024374 	movhi	r4,2317
 9081938:	21323404 	addi	r4,r4,-14128
 908193c:	90836b80 	call	90836b8 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 9081940:	01024374 	movhi	r4,2317
 9081944:	21324404 	addi	r4,r4,-14064
 9081948:	90836b80 	call	90836b8 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 908194c:	01024374 	movhi	r4,2317
 9081950:	21325404 	addi	r4,r4,-14000
 9081954:	90833900 	call	9083390 <printf>
        
        for(i=0; i<9; i++)
 9081958:	e03ffb15 	stw	zero,-20(fp)
 908195c:	00002806 	br	9081a00 <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 9081960:	e43ffb17 	ldw	r16,-20(fp)
 9081964:	00824374 	movhi	r2,2317
 9081968:	108e8604 	addi	r2,r2,14872
 908196c:	10800017 	ldw	r2,0(r2)
 9081970:	11000117 	ldw	r4,4(r2)
 9081974:	90831500 	call	9083150 <getc>
 9081978:	1007883a 	mov	r3,r2
 908197c:	e0bffd04 	addi	r2,fp,-12
 9081980:	1405883a 	add	r2,r2,r16
 9081984:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 9081988:	e0fffb17 	ldw	r3,-20(fp)
 908198c:	e0bffd04 	addi	r2,fp,-12
 9081990:	10c5883a 	add	r2,r2,r3
 9081994:	10800003 	ldbu	r2,0(r2)
 9081998:	11003fcc 	andi	r4,r2,255
 908199c:	2100201c 	xori	r4,r4,128
 90819a0:	213fe004 	addi	r4,r4,-128
 90819a4:	00824374 	movhi	r2,2317
 90819a8:	108e8604 	addi	r2,r2,14872
 90819ac:	10800017 	ldw	r2,0(r2)
 90819b0:	11400217 	ldw	r5,8(r2)
 90819b4:	90834080 	call	9083408 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 90819b8:	e0fffb17 	ldw	r3,-20(fp)
 90819bc:	e0bffd04 	addi	r2,fp,-12
 90819c0:	10c5883a 	add	r2,r2,r3
 90819c4:	10800003 	ldbu	r2,0(r2)
 90819c8:	10803fcc 	andi	r2,r2,255
 90819cc:	1080201c 	xori	r2,r2,128
 90819d0:	10bfe004 	addi	r2,r2,-128
 90819d4:	10800218 	cmpnei	r2,r2,8
 90819d8:	1000061e 	bne	r2,zero,90819f4 <get_serial_number+0xe0>
 90819dc:	e0bffb17 	ldw	r2,-20(fp)
 90819e0:	1004803a 	cmplt	r2,r2,zero
 90819e4:	1000031e 	bne	r2,zero,90819f4 <get_serial_number+0xe0>
            {
                i--;
 90819e8:	e0bffb17 	ldw	r2,-20(fp)
 90819ec:	10bfffc4 	addi	r2,r2,-1
 90819f0:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 90819f4:	e0bffb17 	ldw	r2,-20(fp)
 90819f8:	10800044 	addi	r2,r2,1
 90819fc:	e0bffb15 	stw	r2,-20(fp)
 9081a00:	e0bffb17 	ldw	r2,-20(fp)
 9081a04:	10800250 	cmplti	r2,r2,9
 9081a08:	103fd51e 	bne	r2,zero,9081960 <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 9081a0c:	01000284 	movi	r4,10
 9081a10:	90835f40 	call	90835f4 <putchar>
                
        for(i=0; i<9; i++)
 9081a14:	e03ffb15 	stw	zero,-20(fp)
 9081a18:	00002806 	br	9081abc <get_serial_number+0x1a8>
        {
            if (isdigit(serial_number[i]))
 9081a1c:	e0fffb17 	ldw	r3,-20(fp)
 9081a20:	e0bffd04 	addi	r2,fp,-12
 9081a24:	10c5883a 	add	r2,r2,r3
 9081a28:	10800003 	ldbu	r2,0(r2)
 9081a2c:	10803fcc 	andi	r2,r2,255
 9081a30:	1080201c 	xori	r2,r2,128
 9081a34:	10bfe004 	addi	r2,r2,-128
 9081a38:	1007883a 	mov	r3,r2
 9081a3c:	00824374 	movhi	r2,2317
 9081a40:	108e8504 	addi	r2,r2,14868
 9081a44:	10800017 	ldw	r2,0(r2)
 9081a48:	1885883a 	add	r2,r3,r2
 9081a4c:	10800003 	ldbu	r2,0(r2)
 9081a50:	10803fcc 	andi	r2,r2,255
 9081a54:	1080010c 	andi	r2,r2,4
 9081a58:	1005003a 	cmpeq	r2,r2,zero
 9081a5c:	1000121e 	bne	r2,zero,9081aa8 <get_serial_number+0x194>
            {
                ser_num *= 10;
 9081a60:	e0bffc17 	ldw	r2,-16(fp)
 9081a64:	108002a4 	muli	r2,r2,10
 9081a68:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 9081a6c:	e0fffb17 	ldw	r3,-20(fp)
 9081a70:	e0bffd04 	addi	r2,fp,-12
 9081a74:	10c5883a 	add	r2,r2,r3
 9081a78:	10800003 	ldbu	r2,0(r2)
 9081a7c:	10c03fcc 	andi	r3,r2,255
 9081a80:	18c0201c 	xori	r3,r3,128
 9081a84:	18ffe004 	addi	r3,r3,-128
 9081a88:	e0bffc17 	ldw	r2,-16(fp)
 9081a8c:	1885883a 	add	r2,r3,r2
 9081a90:	10bff404 	addi	r2,r2,-48
 9081a94:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 9081a98:	e0bffb17 	ldw	r2,-20(fp)
 9081a9c:	10800044 	addi	r2,r2,1
 9081aa0:	e0bffb15 	stw	r2,-20(fp)
 9081aa4:	00000506 	br	9081abc <get_serial_number+0x1a8>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 9081aa8:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 9081aac:	01024374 	movhi	r4,2317
 9081ab0:	21326204 	addi	r4,r4,-13944
 9081ab4:	90836b80 	call	90836b8 <puts>
                break;
 9081ab8:	00000306 	br	9081ac8 <get_serial_number+0x1b4>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 9081abc:	e0bffb17 	ldw	r2,-20(fp)
 9081ac0:	10800250 	cmplti	r2,r2,9
 9081ac4:	103fd51e 	bne	r2,zero,9081a1c <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 9081ac8:	e0bffc17 	ldw	r2,-16(fp)
 9081acc:	1005003a 	cmpeq	r2,r2,zero
 9081ad0:	103f981e 	bne	r2,zero,9081934 <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 9081ad4:	e0bffc17 	ldw	r2,-16(fp)
}
 9081ad8:	e037883a 	mov	sp,fp
 9081adc:	dfc00217 	ldw	ra,8(sp)
 9081ae0:	df000117 	ldw	fp,4(sp)
 9081ae4:	dc000017 	ldw	r16,0(sp)
 9081ae8:	dec00304 	addi	sp,sp,12
 9081aec:	f800283a 	ret

09081af0 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 9081af0:	defff804 	addi	sp,sp,-32
 9081af4:	dfc00715 	stw	ra,28(sp)
 9081af8:	df000615 	stw	fp,24(sp)
 9081afc:	df000604 	addi	fp,sp,24
 9081b00:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 9081b04:	00bfffc4 	movi	r2,-1
 9081b08:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 9081b0c:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 9081b10:	01024374 	movhi	r4,2317
 9081b14:	21327104 	addi	r4,r4,-13884
 9081b18:	90836b80 	call	90836b8 <puts>
    printf("a MAC address.\n\n");
 9081b1c:	01024374 	movhi	r4,2317
 9081b20:	21328104 	addi	r4,r4,-13820
 9081b24:	90836b80 	call	90836b8 <puts>
    
//    ser_num = get_serial_number();
    ser_num = 0x096D;
 9081b28:	00825b44 	movi	r2,2413
 9081b2c:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 9081b30:	e0bffd17 	ldw	r2,-12(fp)
 9081b34:	1005003a 	cmpeq	r2,r2,zero
 9081b38:	1000361e 	bne	r2,zero,9081c14 <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 9081b3c:	e0bfff17 	ldw	r2,-4(fp)
 9081b40:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 9081b44:	e0bfff17 	ldw	r2,-4(fp)
 9081b48:	10c00044 	addi	r3,r2,1
 9081b4c:	008001c4 	movi	r2,7
 9081b50:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 9081b54:	e0bfff17 	ldw	r2,-4(fp)
 9081b58:	10c00084 	addi	r3,r2,2
 9081b5c:	00bffb44 	movi	r2,-19
 9081b60:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
//        mac_addr[3] = 0xFF;
        mac_addr[3] = 0x15;
 9081b64:	e0bfff17 	ldw	r2,-4(fp)
 9081b68:	10c000c4 	addi	r3,r2,3
 9081b6c:	00800544 	movi	r2,21
 9081b70:	18800005 	stb	r2,0(r3)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 9081b74:	e0bfff17 	ldw	r2,-4(fp)
 9081b78:	10c00104 	addi	r3,r2,4
 9081b7c:	e0bffd17 	ldw	r2,-12(fp)
 9081b80:	10bfc00c 	andi	r2,r2,65280
 9081b84:	1004d23a 	srli	r2,r2,8
 9081b88:	18800005 	stb	r2,0(r3)
        mac_addr[5] = ser_num & 0xff;
 9081b8c:	e0bfff17 	ldw	r2,-4(fp)
 9081b90:	10c00144 	addi	r3,r2,5
 9081b94:	e0bffd17 	ldw	r2,-12(fp)
 9081b98:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 9081b9c:	e0bfff17 	ldw	r2,-4(fp)
 9081ba0:	10800003 	ldbu	r2,0(r2)
 9081ba4:	11403fcc 	andi	r5,r2,255
 9081ba8:	e0bfff17 	ldw	r2,-4(fp)
 9081bac:	10800044 	addi	r2,r2,1
 9081bb0:	10800003 	ldbu	r2,0(r2)
 9081bb4:	11803fcc 	andi	r6,r2,255
 9081bb8:	e0bfff17 	ldw	r2,-4(fp)
 9081bbc:	10800084 	addi	r2,r2,2
 9081bc0:	10800003 	ldbu	r2,0(r2)
 9081bc4:	11c03fcc 	andi	r7,r2,255
 9081bc8:	e0bfff17 	ldw	r2,-4(fp)
 9081bcc:	108000c4 	addi	r2,r2,3
 9081bd0:	10800003 	ldbu	r2,0(r2)
 9081bd4:	10c03fcc 	andi	r3,r2,255
 9081bd8:	e0bfff17 	ldw	r2,-4(fp)
 9081bdc:	10800104 	addi	r2,r2,4
 9081be0:	10800003 	ldbu	r2,0(r2)
 9081be4:	11003fcc 	andi	r4,r2,255
 9081be8:	e0bfff17 	ldw	r2,-4(fp)
 9081bec:	10800144 	addi	r2,r2,5
 9081bf0:	10800003 	ldbu	r2,0(r2)
 9081bf4:	10803fcc 	andi	r2,r2,255
 9081bf8:	d8c00015 	stw	r3,0(sp)
 9081bfc:	d9000115 	stw	r4,4(sp)
 9081c00:	d8800215 	stw	r2,8(sp)
 9081c04:	01024374 	movhi	r4,2317
 9081c08:	21328504 	addi	r4,r4,-13804
 9081c0c:	90833900 	call	9083390 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 9081c10:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 9081c14:	e0bffe17 	ldw	r2,-8(fp)
}
 9081c18:	e037883a 	mov	sp,fp
 9081c1c:	dfc00117 	ldw	ra,4(sp)
 9081c20:	df000017 	ldw	fp,0(sp)
 9081c24:	dec00204 	addi	sp,sp,8
 9081c28:	f800283a 	ret

09081c2c <SSSCreateOSDataStructs>:
struct sockaddr_in cliaddr;
int fd_listen;


void SSSCreateOSDataStructs(void)	// called from iniche_init.c
{
 9081c2c:	deffff04 	addi	sp,sp,-4
 9081c30:	df000015 	stw	fp,0(sp)
 9081c34:	d839883a 	mov	fp,sp
}
 9081c38:	e037883a 	mov	sp,fp
 9081c3c:	df000017 	ldw	fp,0(sp)
 9081c40:	dec00104 	addi	sp,sp,4
 9081c44:	f800283a 	ret

09081c48 <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)	// called from iniche_init.c
{
 9081c48:	deffff04 	addi	sp,sp,-4
 9081c4c:	df000015 	stw	fp,0(sp)
 9081c50:	d839883a 	mov	fp,sp
}
 9081c54:	e037883a 	mov	sp,fp
 9081c58:	df000017 	ldw	fp,0(sp)
 9081c5c:	dec00104 	addi	sp,sp,4
 9081c60:	f800283a 	ret

09081c64 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 9081c64:	deffb804 	addi	sp,sp,-288
 9081c68:	dfc04715 	stw	ra,284(sp)
 9081c6c:	df004615 	stw	fp,280(sp)
 9081c70:	df004604 	addi	fp,sp,280
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
 9081c74:	01000084 	movi	r4,2
 9081c78:	01400084 	movi	r5,2
 9081c7c:	01800444 	movi	r6,17
 9081c80:	90ad5740 	call	90ad574 <t_socket>
 9081c84:	d0a05d15 	stw	r2,-32396(gp)
 9081c88:	d0a05d17 	ldw	r2,-32396(gp)
 9081c8c:	1004403a 	cmpge	r2,r2,zero
 9081c90:	1000041e 	bne	r2,zero,9081ca4 <SSSSimpleSocketServerTask+0x40>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 9081c94:	01003fc4 	movi	r4,255
 9081c98:	01424374 	movhi	r5,2317
 9081c9c:	29729404 	addi	r5,r5,-13744
 9081ca0:	9080e880 	call	9080e88 <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  bzero(&addr, sizeof(addr));
 9081ca4:	e0bfbb04 	addi	r2,fp,-276
 9081ca8:	10000015 	stw	zero,0(r2)
 9081cac:	10000115 	stw	zero,4(r2)
 9081cb0:	10000215 	stw	zero,8(r2)
 9081cb4:	10000315 	stw	zero,12(r2)
  addr.sin_family = AF_INET;
 9081cb8:	00800084 	movi	r2,2
 9081cbc:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 9081cc0:	00878004 	movi	r2,7680
 9081cc4:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
 9081cc8:	e03fbc15 	stw	zero,-272(fp)
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 9081ccc:	d1205d17 	ldw	r4,-32396(gp)
 9081cd0:	e17fbb04 	addi	r5,fp,-276
 9081cd4:	01800404 	movi	r6,16
 9081cd8:	90ad6040 	call	90ad604 <t_bind>
 9081cdc:	1004403a 	cmpge	r2,r2,zero
 9081ce0:	1000041e 	bne	r2,zero,9081cf4 <SSSSimpleSocketServerTask+0x90>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 9081ce4:	01003fc4 	movi	r4,255
 9081ce8:	01424374 	movhi	r5,2317
 9081cec:	29729d04 	addi	r5,r5,-13708
 9081cf0:	9080e880 	call	9080e88 <alt_NetworkErrorHandler>
  }
  sss_udp_process();
 9081cf4:	9081d0c0 	call	9081d0c <sss_udp_process>
}
 9081cf8:	e037883a 	mov	sp,fp
 9081cfc:	dfc00117 	ldw	ra,4(sp)
 9081d00:	df000017 	ldw	fp,0(sp)
 9081d04:	dec00204 	addi	sp,sp,8
 9081d08:	f800283a 	ret

09081d0c <sss_udp_process>:


void sss_udp_process(void)
{
 9081d0c:	defff104 	addi	sp,sp,-60
 9081d10:	dfc00e15 	stw	ra,56(sp)
 9081d14:	df000d15 	stw	fp,52(sp)
 9081d18:	dc400c15 	stw	r17,48(sp)
 9081d1c:	dc000b15 	stw	r16,44(sp)
 9081d20:	df000b04 	addi	fp,sp,44
   static INT32U p2[1024];
   static int i, j;
   int cliaddr_len, datalen;

	INT8U error_code;
printf("entering sss_udp_process()\n");
 9081d24:	01024374 	movhi	r4,2317
 9081d28:	2132a304 	addi	r4,r4,-13684
 9081d2c:	90836b80 	call	90836b8 <puts>

  bzero(&cliaddr, sizeof(cliaddr));
 9081d30:	00824374 	movhi	r2,2317
 9081d34:	109d0e04 	addi	r2,r2,29752
 9081d38:	10000015 	stw	zero,0(r2)
 9081d3c:	10000115 	stw	zero,4(r2)
 9081d40:	10000215 	stw	zero,8(r2)
 9081d44:	10000315 	stw	zero,12(r2)
  cliaddr.sin_family = AF_INET;
 9081d48:	00c24374 	movhi	r3,2317
 9081d4c:	18dd0e04 	addi	r3,r3,29752
 9081d50:	00800084 	movi	r2,2
 9081d54:	1880000d 	sth	r2,0(r3)
  cliaddr.sin_port = htons(SSS_PORT);
 9081d58:	00c24374 	movhi	r3,2317
 9081d5c:	18dd0e04 	addi	r3,r3,29752
 9081d60:	00878004 	movi	r2,7680
 9081d64:	1880008d 	sth	r2,2(r3)
	* have access to the stack of the SSSSimpleSocketServerTask.
	*/
	static INT32U SSSCommand;
	while(1)
	{
           tx_wr_pos = tx_buf;
 9081d68:	00824374 	movhi	r2,2317
 9081d6c:	109e8904 	addi	r2,r2,31268
 9081d70:	e0bffb15 	stw	r2,-20(fp)
           rx_pos = rx_buf;
 9081d74:	00824374 	movhi	r2,2317
 9081d78:	109d1204 	addi	r2,r2,29768
 9081d7c:	e0bffa15 	stw	r2,-24(fp)
	   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 9081d80:	00800c04 	movi	r2,48
 9081d84:	d0a05915 	stw	r2,-32412(gp)
	   p1 = 0;
 9081d88:	d0205c15 	stw	zero,-32400(gp)
	   memset(p2, 0, sizeof(p2));
 9081d8c:	00824374 	movhi	r2,2317
 9081d90:	1090df04 	addi	r2,r2,17276
 9081d94:	1009883a 	mov	r4,r2
 9081d98:	01840004 	movi	r6,4096
 9081d9c:	000b883a 	mov	r5,zero
 9081da0:	90832780 	call	9083278 <memset>

	   cliaddr_len = sizeof(cliaddr);
 9081da4:	00800404 	movi	r2,16
 9081da8:	e0bffd15 	stw	r2,-12(fp)
	   bytes_to_process = recvfrom(fd_listen, rx_buf, SSS_RX_BUF_SIZE, 0, (struct sockaddr*)&cliaddr, &cliaddr_len);
 9081dac:	d1205d17 	ldw	r4,-32396(gp)
 9081db0:	00824374 	movhi	r2,2317
 9081db4:	109d0e04 	addi	r2,r2,29752
 9081db8:	d8800015 	stw	r2,0(sp)
 9081dbc:	e0bffd04 	addi	r2,fp,-12
 9081dc0:	d8800115 	stw	r2,4(sp)
 9081dc4:	01424374 	movhi	r5,2317
 9081dc8:	295d1204 	addi	r5,r5,29768
 9081dcc:	01817704 	movi	r6,1500
 9081dd0:	000f883a 	mov	r7,zero
 9081dd4:	90a4a2c0 	call	90a4a2c <bsd_recvfrom>
 9081dd8:	e0bffc15 	stw	r2,-16(fp)
           rx_buf[bytes_to_process] = 0;
 9081ddc:	e0fffc17 	ldw	r3,-16(fp)
 9081de0:	00824374 	movhi	r2,2317
 9081de4:	109d1204 	addi	r2,r2,29768
 9081de8:	10c5883a 	add	r2,r2,r3
 9081dec:	10000005 	stb	zero,0(r2)
// printf("sss_udp_process(): bytes_to_process = %d\n", bytes_to_process);

	   while(bytes_to_process--)
 9081df0:	0003ac06 	br	9082ca4 <sss_udp_process+0xf98>
	   {
		  SSSCommand = toupper(*(rx_pos++));
 9081df4:	e0bffa17 	ldw	r2,-24(fp)
 9081df8:	10800003 	ldbu	r2,0(r2)
 9081dfc:	10803fcc 	andi	r2,r2,255
 9081e00:	e0bff715 	stw	r2,-36(fp)
 9081e04:	e0bffa17 	ldw	r2,-24(fp)
 9081e08:	10800044 	addi	r2,r2,1
 9081e0c:	e0bffa15 	stw	r2,-24(fp)
 9081e10:	00824374 	movhi	r2,2317
 9081e14:	108e8504 	addi	r2,r2,14868
 9081e18:	10c00017 	ldw	r3,0(r2)
 9081e1c:	e0bff717 	ldw	r2,-36(fp)
 9081e20:	1885883a 	add	r2,r3,r2
 9081e24:	10800003 	ldbu	r2,0(r2)
 9081e28:	10803fcc 	andi	r2,r2,255
 9081e2c:	1080008c 	andi	r2,r2,2
 9081e30:	1005003a 	cmpeq	r2,r2,zero
 9081e34:	1000041e 	bne	r2,zero,9081e48 <sss_udp_process+0x13c>
 9081e38:	e0bff717 	ldw	r2,-36(fp)
 9081e3c:	10bff804 	addi	r2,r2,-32
 9081e40:	e0bffe15 	stw	r2,-8(fp)
 9081e44:	00000206 	br	9081e50 <sss_udp_process+0x144>
 9081e48:	e0bff717 	ldw	r2,-36(fp)
 9081e4c:	e0bffe15 	stw	r2,-8(fp)
 9081e50:	e0bffe17 	ldw	r2,-8(fp)
 9081e54:	d0a05915 	stw	r2,-32412(gp)
// printf("sss_udp_process(): rx_buf = '%s'\n", rx_buf);

		  if(SSSCommand >= ' ' && SSSCommand <= '~')
 9081e58:	d0a05917 	ldw	r2,-32412(gp)
 9081e5c:	10800830 	cmpltui	r2,r2,32
 9081e60:	1003901e 	bne	r2,zero,9082ca4 <sss_udp_process+0xf98>
 9081e64:	d0a05917 	ldw	r2,-32412(gp)
 9081e68:	10801fe8 	cmpgeui	r2,r2,127
 9081e6c:	10038d1e 	bne	r2,zero,9082ca4 <sss_udp_process+0xf98>
		  {
//			 tx_wr_pos += sprintf(tx_wr_pos, "ACK %c.\n", (char)SSSCommand);
			 if (SSSCommand == CMD_QUIT)
 9081e70:	d0a05917 	ldw	r2,-32412(gp)
 9081e74:	10801460 	cmpeqi	r2,r2,81
 9081e78:	10038a1e 	bne	r2,zero,9082ca4 <sss_udp_process+0xf98>
//				return;
			 }
			 else
			 {
	// extract p1 parameter (always present, if unused == '0')
				 rx_pos++;	// skip blank space
 9081e7c:	e0bffa17 	ldw	r2,-24(fp)
 9081e80:	10800044 	addi	r2,r2,1
 9081e84:	e0bffa15 	stw	r2,-24(fp)
				 bytes_to_process--;
 9081e88:	e0bffc17 	ldw	r2,-16(fp)
 9081e8c:	10bfffc4 	addi	r2,r2,-1
 9081e90:	e0bffc15 	stw	r2,-16(fp)
				 j = 0;
 9081e94:	d0205a15 	stw	zero,-32408(gp)
				 while( *(rx_pos) != ' ' && bytes_to_process > 0 && j < 32 )
 9081e98:	00001006 	br	9081edc <sss_udp_process+0x1d0>
				 {
					 ps[j++] = *(rx_pos++);
 9081e9c:	d1205a17 	ldw	r4,-32408(gp)
 9081ea0:	e0bffa17 	ldw	r2,-24(fp)
 9081ea4:	10800003 	ldbu	r2,0(r2)
 9081ea8:	1007883a 	mov	r3,r2
 9081eac:	00824374 	movhi	r2,2317
 9081eb0:	1094df04 	addi	r2,r2,21372
 9081eb4:	1105883a 	add	r2,r2,r4
 9081eb8:	10c00005 	stb	r3,0(r2)
 9081ebc:	20800044 	addi	r2,r4,1
 9081ec0:	d0a05a15 	stw	r2,-32408(gp)
 9081ec4:	e0bffa17 	ldw	r2,-24(fp)
 9081ec8:	10800044 	addi	r2,r2,1
 9081ecc:	e0bffa15 	stw	r2,-24(fp)
					 bytes_to_process--;
 9081ed0:	e0bffc17 	ldw	r2,-16(fp)
 9081ed4:	10bfffc4 	addi	r2,r2,-1
 9081ed8:	e0bffc15 	stw	r2,-16(fp)
			 {
	// extract p1 parameter (always present, if unused == '0')
				 rx_pos++;	// skip blank space
				 bytes_to_process--;
				 j = 0;
				 while( *(rx_pos) != ' ' && bytes_to_process > 0 && j < 32 )
 9081edc:	e0bffa17 	ldw	r2,-24(fp)
 9081ee0:	10800003 	ldbu	r2,0(r2)
 9081ee4:	10803fcc 	andi	r2,r2,255
 9081ee8:	10800820 	cmpeqi	r2,r2,32
 9081eec:	1000061e 	bne	r2,zero,9081f08 <sss_udp_process+0x1fc>
 9081ef0:	e0bffc17 	ldw	r2,-16(fp)
 9081ef4:	10800050 	cmplti	r2,r2,1
 9081ef8:	1000031e 	bne	r2,zero,9081f08 <sss_udp_process+0x1fc>
 9081efc:	d0a05a17 	ldw	r2,-32408(gp)
 9081f00:	10800810 	cmplti	r2,r2,32
 9081f04:	103fe51e 	bne	r2,zero,9081e9c <sss_udp_process+0x190>
				 {
					 ps[j++] = *(rx_pos++);
					 bytes_to_process--;
				 }
				 if( bytes_to_process == 0 )
 9081f08:	e0bffc17 	ldw	r2,-16(fp)
 9081f0c:	1004c03a 	cmpne	r2,r2,zero
 9081f10:	1000031e 	bne	r2,zero,9081f20 <sss_udp_process+0x214>
					 j--;
 9081f14:	d0a05a17 	ldw	r2,-32408(gp)
 9081f18:	10bfffc4 	addi	r2,r2,-1
 9081f1c:	d0a05a15 	stw	r2,-32408(gp)
				 ps[j] = 0;
 9081f20:	d0e05a17 	ldw	r3,-32408(gp)
 9081f24:	00824374 	movhi	r2,2317
 9081f28:	1094df04 	addi	r2,r2,21372
 9081f2c:	10c5883a 	add	r2,r2,r3
 9081f30:	10000005 	stb	zero,0(r2)
				 atoul(ps,0,0,&p1);
 9081f34:	01024374 	movhi	r4,2317
 9081f38:	2114df04 	addi	r4,r4,21372
 9081f3c:	000b883a 	mov	r5,zero
 9081f40:	000d883a 	mov	r6,zero
 9081f44:	d1e05c04 	addi	r7,gp,-32400
 9081f48:	908140c0 	call	908140c <atoul>
// printf("j = %d, bytes_to_process = %d, ps = %s, p1 = 0x%08X.\n", j, bytes_to_process, ps, p1);
// printf("cmd = '%c'\n", SSSCommand);
	// extract p2[] parameters if any
				 if( SSSCommand == WRITE_CFG_FIFO )
 9081f4c:	d0a05917 	ldw	r2,-32412(gp)
 9081f50:	10800e58 	cmpnei	r2,r2,57
 9081f54:	1000431e 	bne	r2,zero,9082064 <sss_udp_process+0x358>
				 {
					 for(i=0;i<p1;i++)
 9081f58:	d0205b15 	stw	zero,-32404(gp)
 9081f5c:	00003d06 	br	9082054 <sss_udp_process+0x348>
					 {
						 rx_pos++;
 9081f60:	e0bffa17 	ldw	r2,-24(fp)
 9081f64:	10800044 	addi	r2,r2,1
 9081f68:	e0bffa15 	stw	r2,-24(fp)
						 bytes_to_process--;
 9081f6c:	e0bffc17 	ldw	r2,-16(fp)
 9081f70:	10bfffc4 	addi	r2,r2,-1
 9081f74:	e0bffc15 	stw	r2,-16(fp)
						 j = 0;
 9081f78:	d0205a15 	stw	zero,-32408(gp)
						 while( *(rx_pos) != ' ' && bytes_to_process > 0 && j < 32 )
 9081f7c:	00001006 	br	9081fc0 <sss_udp_process+0x2b4>
						 {
							 ps[j++] = *(rx_pos++);
 9081f80:	d1205a17 	ldw	r4,-32408(gp)
 9081f84:	e0bffa17 	ldw	r2,-24(fp)
 9081f88:	10800003 	ldbu	r2,0(r2)
 9081f8c:	1007883a 	mov	r3,r2
 9081f90:	00824374 	movhi	r2,2317
 9081f94:	1094df04 	addi	r2,r2,21372
 9081f98:	1105883a 	add	r2,r2,r4
 9081f9c:	10c00005 	stb	r3,0(r2)
 9081fa0:	20800044 	addi	r2,r4,1
 9081fa4:	d0a05a15 	stw	r2,-32408(gp)
 9081fa8:	e0bffa17 	ldw	r2,-24(fp)
 9081fac:	10800044 	addi	r2,r2,1
 9081fb0:	e0bffa15 	stw	r2,-24(fp)
							 bytes_to_process--;
 9081fb4:	e0bffc17 	ldw	r2,-16(fp)
 9081fb8:	10bfffc4 	addi	r2,r2,-1
 9081fbc:	e0bffc15 	stw	r2,-16(fp)
					 for(i=0;i<p1;i++)
					 {
						 rx_pos++;
						 bytes_to_process--;
						 j = 0;
						 while( *(rx_pos) != ' ' && bytes_to_process > 0 && j < 32 )
 9081fc0:	e0bffa17 	ldw	r2,-24(fp)
 9081fc4:	10800003 	ldbu	r2,0(r2)
 9081fc8:	10803fcc 	andi	r2,r2,255
 9081fcc:	10800820 	cmpeqi	r2,r2,32
 9081fd0:	1000061e 	bne	r2,zero,9081fec <sss_udp_process+0x2e0>
 9081fd4:	e0bffc17 	ldw	r2,-16(fp)
 9081fd8:	10800050 	cmplti	r2,r2,1
 9081fdc:	1000031e 	bne	r2,zero,9081fec <sss_udp_process+0x2e0>
 9081fe0:	d0a05a17 	ldw	r2,-32408(gp)
 9081fe4:	10800810 	cmplti	r2,r2,32
 9081fe8:	103fe51e 	bne	r2,zero,9081f80 <sss_udp_process+0x274>
						 {
							 ps[j++] = *(rx_pos++);
							 bytes_to_process--;
						 }
						 if( bytes_to_process == 0 )
 9081fec:	e0bffc17 	ldw	r2,-16(fp)
 9081ff0:	1004c03a 	cmpne	r2,r2,zero
 9081ff4:	1000031e 	bne	r2,zero,9082004 <sss_udp_process+0x2f8>
							 j--;
 9081ff8:	d0a05a17 	ldw	r2,-32408(gp)
 9081ffc:	10bfffc4 	addi	r2,r2,-1
 9082000:	d0a05a15 	stw	r2,-32408(gp)
						 ps[j] = 0;
 9082004:	d0e05a17 	ldw	r3,-32408(gp)
 9082008:	00824374 	movhi	r2,2317
 908200c:	1094df04 	addi	r2,r2,21372
 9082010:	10c5883a 	add	r2,r2,r3
 9082014:	10000005 	stb	zero,0(r2)
						 atoul(ps,0,0,&p2[i]);
 9082018:	d0a05b17 	ldw	r2,-32404(gp)
 908201c:	1085883a 	add	r2,r2,r2
 9082020:	1085883a 	add	r2,r2,r2
 9082024:	1007883a 	mov	r3,r2
 9082028:	00824374 	movhi	r2,2317
 908202c:	1090df04 	addi	r2,r2,17276
 9082030:	188f883a 	add	r7,r3,r2
 9082034:	01024374 	movhi	r4,2317
 9082038:	2114df04 	addi	r4,r4,21372
 908203c:	000b883a 	mov	r5,zero
 9082040:	000d883a 	mov	r6,zero
 9082044:	908140c0 	call	908140c <atoul>
// printf("j = %d, bytes_to_process = %d, ps = %s, p1 = 0x%08X.\n", j, bytes_to_process, ps, p1);
// printf("cmd = '%c'\n", SSSCommand);
	// extract p2[] parameters if any
				 if( SSSCommand == WRITE_CFG_FIFO )
				 {
					 for(i=0;i<p1;i++)
 9082048:	d0a05b17 	ldw	r2,-32404(gp)
 908204c:	10800044 	addi	r2,r2,1
 9082050:	d0a05b15 	stw	r2,-32404(gp)
 9082054:	d0a05b17 	ldw	r2,-32404(gp)
 9082058:	1007883a 	mov	r3,r2
 908205c:	d0a05c17 	ldw	r2,-32400(gp)
 9082060:	18bfbf36 	bltu	r3,r2,9081f60 <sss_udp_process+0x254>
						 atoul(ps,0,0,&p2[i]);
// printf("j = %d, bytes_to_process = %d, ps = %s, p2[%d] = 0x%08X.\n", j, bytes_to_process, ps, i, p2[i]);
					 }
				 }

				datalen = 0;
 9082064:	e03ff915 	stw	zero,-28(fp)

				 switch( SSSCommand ) {
 9082068:	d0a05917 	ldw	r2,-32412(gp)
 908206c:	10bff404 	addi	r2,r2,-48
 9082070:	e0bfff15 	stw	r2,-4(fp)
 9082074:	e0ffff17 	ldw	r3,-4(fp)
 9082078:	18800ae8 	cmpgeui	r2,r3,43
 908207c:	1003001e 	bne	r2,zero,9082c80 <sss_udp_process+0xf74>
 9082080:	e13fff17 	ldw	r4,-4(fp)
 9082084:	e13fff17 	ldw	r4,-4(fp)
 9082088:	2105883a 	add	r2,r4,r4
 908208c:	1087883a 	add	r3,r2,r2
 9082090:	00824234 	movhi	r2,2312
 9082094:	10882904 	addi	r2,r2,8356
 9082098:	1885883a 	add	r2,r3,r2
 908209c:	10800017 	ldw	r2,0(r2)
 90820a0:	1000683a 	jmp	r2
 90820a4:	09082150 	cmplti	r4,at,8325
 90820a8:	0908224c 	andi	r4,at,8329
 90820ac:	09082348 	cmpgei	r4,at,8333
 90820b0:	09082444 	addi	r4,at,8337
 90820b4:	09082540 	call	908254 <OSCtxSw_SWITCH_PC+0x908214>
 90820b8:	0908263c 	xorhi	r4,at,8344
 90820bc:	09082738 	rdprs	r4,at,8348
 90820c0:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820c4:	09082794 	ori	r4,at,8350
 90820c8:	09082890 	cmplti	r4,at,8354
 90820cc:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820d0:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820d4:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820d8:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820dc:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820e0:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820e4:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 90820e8:	090828d8 	cmpnei	r4,at,8355
 90820ec:	09082914 	ori	r4,at,8356
 90820f0:	09082950 	cmplti	r4,at,8357
 90820f4:	09082b64 	muli	r4,at,8365
 90820f8:	09082b94 	ori	r4,at,8366
 90820fc:	09082bc4 	addi	r4,at,8367
 9082100:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082104:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082108:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 908210c:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082110:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082114:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082118:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 908211c:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082120:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082124:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082128:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 908212c:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082130:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082134:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082138:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 908213c:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082140:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082144:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 9082148:	09082c80 	call	9082c8 <OSCtxSw_SWITCH_PC+0x908288>
 908214c:	09082c4c 	andi	r4,at,8369
					 case READ_DATA_FIFO_0: ReadDataFifo0(p1, p2);
 9082150:	d0a05c17 	ldw	r2,-32400(gp)
 9082154:	1009883a 	mov	r4,r2
 9082158:	01424374 	movhi	r5,2317
 908215c:	2950df04 	addi	r5,r5,17276
 9082160:	90805640 	call	9080564 <ReadDataFifo0>
// printf("sss_udp_process(): READ_DATA_FIFO_0\n");
						datalen = p1;
 9082164:	d0a05c17 	ldw	r2,-32400(gp)
 9082168:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 908216c:	d0205b15 	stw	zero,-32404(gp)
 9082170:	00003106 	br	9082238 <sss_udp_process+0x52c>
							databuf[i] = htonl(p2[i]);
 9082174:	d1605b17 	ldw	r5,-32404(gp)
 9082178:	d0a05b17 	ldw	r2,-32404(gp)
 908217c:	00c24374 	movhi	r3,2317
 9082180:	18d0df04 	addi	r3,r3,17276
 9082184:	1085883a 	add	r2,r2,r2
 9082188:	1085883a 	add	r2,r2,r2
 908218c:	10c5883a 	add	r2,r2,r3
 9082190:	10800017 	ldw	r2,0(r2)
 9082194:	1004d63a 	srli	r2,r2,24
 9082198:	11003fcc 	andi	r4,r2,255
 908219c:	d0a05b17 	ldw	r2,-32404(gp)
 90821a0:	00c24374 	movhi	r3,2317
 90821a4:	18d0df04 	addi	r3,r3,17276
 90821a8:	1085883a 	add	r2,r2,r2
 90821ac:	1085883a 	add	r2,r2,r2
 90821b0:	10c5883a 	add	r2,r2,r3
 90821b4:	10800017 	ldw	r2,0(r2)
 90821b8:	1004d23a 	srli	r2,r2,8
 90821bc:	10bfc00c 	andi	r2,r2,65280
 90821c0:	2088b03a 	or	r4,r4,r2
 90821c4:	d0a05b17 	ldw	r2,-32404(gp)
 90821c8:	00c24374 	movhi	r3,2317
 90821cc:	18d0df04 	addi	r3,r3,17276
 90821d0:	1085883a 	add	r2,r2,r2
 90821d4:	1085883a 	add	r2,r2,r2
 90821d8:	10c5883a 	add	r2,r2,r3
 90821dc:	10800017 	ldw	r2,0(r2)
 90821e0:	10bfc00c 	andi	r2,r2,65280
 90821e4:	1004923a 	slli	r2,r2,8
 90821e8:	2088b03a 	or	r4,r4,r2
 90821ec:	d0a05b17 	ldw	r2,-32404(gp)
 90821f0:	00c24374 	movhi	r3,2317
 90821f4:	18d0df04 	addi	r3,r3,17276
 90821f8:	1085883a 	add	r2,r2,r2
 90821fc:	1085883a 	add	r2,r2,r2
 9082200:	10c5883a 	add	r2,r2,r3
 9082204:	10800017 	ldw	r2,0(r2)
 9082208:	10803fcc 	andi	r2,r2,255
 908220c:	1004963a 	slli	r2,r2,24
 9082210:	2088b03a 	or	r4,r4,r2
 9082214:	00c243b4 	movhi	r3,2318
 9082218:	18e00004 	addi	r3,r3,-32768
 908221c:	2945883a 	add	r2,r5,r5
 9082220:	1085883a 	add	r2,r2,r2
 9082224:	10c5883a 	add	r2,r2,r3
 9082228:	11000015 	stw	r4,0(r2)

				 switch( SSSCommand ) {
					 case READ_DATA_FIFO_0: ReadDataFifo0(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_0\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 908222c:	d0a05b17 	ldw	r2,-32404(gp)
 9082230:	10800044 	addi	r2,r2,1
 9082234:	d0a05b15 	stw	r2,-32404(gp)
 9082238:	d0a05b17 	ldw	r2,-32404(gp)
 908223c:	1007883a 	mov	r3,r2
 9082240:	d0a05c17 	ldw	r2,-32400(gp)
 9082244:	18bfcb36 	bltu	r3,r2,9082174 <sss_udp_process+0x468>
							databuf[i] = htonl(p2[i]);
						break;
 9082248:	00029606 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_1: ReadDataFifo1(p1, p2);
 908224c:	d0a05c17 	ldw	r2,-32400(gp)
 9082250:	1009883a 	mov	r4,r2
 9082254:	01424374 	movhi	r5,2317
 9082258:	2950df04 	addi	r5,r5,17276
 908225c:	90805d00 	call	90805d0 <ReadDataFifo1>
// printf("sss_udp_process(): READ_DATA_FIFO_1\n");
						datalen = p1;
 9082260:	d0a05c17 	ldw	r2,-32400(gp)
 9082264:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 9082268:	d0205b15 	stw	zero,-32404(gp)
 908226c:	00003106 	br	9082334 <sss_udp_process+0x628>
							databuf[i] = htonl(p2[i]);
 9082270:	d1605b17 	ldw	r5,-32404(gp)
 9082274:	d0a05b17 	ldw	r2,-32404(gp)
 9082278:	00c24374 	movhi	r3,2317
 908227c:	18d0df04 	addi	r3,r3,17276
 9082280:	1085883a 	add	r2,r2,r2
 9082284:	1085883a 	add	r2,r2,r2
 9082288:	10c5883a 	add	r2,r2,r3
 908228c:	10800017 	ldw	r2,0(r2)
 9082290:	1004d63a 	srli	r2,r2,24
 9082294:	11003fcc 	andi	r4,r2,255
 9082298:	d0a05b17 	ldw	r2,-32404(gp)
 908229c:	00c24374 	movhi	r3,2317
 90822a0:	18d0df04 	addi	r3,r3,17276
 90822a4:	1085883a 	add	r2,r2,r2
 90822a8:	1085883a 	add	r2,r2,r2
 90822ac:	10c5883a 	add	r2,r2,r3
 90822b0:	10800017 	ldw	r2,0(r2)
 90822b4:	1004d23a 	srli	r2,r2,8
 90822b8:	10bfc00c 	andi	r2,r2,65280
 90822bc:	2088b03a 	or	r4,r4,r2
 90822c0:	d0a05b17 	ldw	r2,-32404(gp)
 90822c4:	00c24374 	movhi	r3,2317
 90822c8:	18d0df04 	addi	r3,r3,17276
 90822cc:	1085883a 	add	r2,r2,r2
 90822d0:	1085883a 	add	r2,r2,r2
 90822d4:	10c5883a 	add	r2,r2,r3
 90822d8:	10800017 	ldw	r2,0(r2)
 90822dc:	10bfc00c 	andi	r2,r2,65280
 90822e0:	1004923a 	slli	r2,r2,8
 90822e4:	2088b03a 	or	r4,r4,r2
 90822e8:	d0a05b17 	ldw	r2,-32404(gp)
 90822ec:	00c24374 	movhi	r3,2317
 90822f0:	18d0df04 	addi	r3,r3,17276
 90822f4:	1085883a 	add	r2,r2,r2
 90822f8:	1085883a 	add	r2,r2,r2
 90822fc:	10c5883a 	add	r2,r2,r3
 9082300:	10800017 	ldw	r2,0(r2)
 9082304:	10803fcc 	andi	r2,r2,255
 9082308:	1004963a 	slli	r2,r2,24
 908230c:	2088b03a 	or	r4,r4,r2
 9082310:	00c243b4 	movhi	r3,2318
 9082314:	18e00004 	addi	r3,r3,-32768
 9082318:	2945883a 	add	r2,r5,r5
 908231c:	1085883a 	add	r2,r2,r2
 9082320:	10c5883a 	add	r2,r2,r3
 9082324:	11000015 	stw	r4,0(r2)
							databuf[i] = htonl(p2[i]);
						break;
					 case READ_DATA_FIFO_1: ReadDataFifo1(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_1\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 9082328:	d0a05b17 	ldw	r2,-32404(gp)
 908232c:	10800044 	addi	r2,r2,1
 9082330:	d0a05b15 	stw	r2,-32404(gp)
 9082334:	d0a05b17 	ldw	r2,-32404(gp)
 9082338:	1007883a 	mov	r3,r2
 908233c:	d0a05c17 	ldw	r2,-32400(gp)
 9082340:	18bfcb36 	bltu	r3,r2,9082270 <sss_udp_process+0x564>
							databuf[i] = htonl(p2[i]);
						break;
 9082344:	00025706 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_2: ReadDataFifo2(p1, p2);
 9082348:	d0a05c17 	ldw	r2,-32400(gp)
 908234c:	1009883a 	mov	r4,r2
 9082350:	01424374 	movhi	r5,2317
 9082354:	2950df04 	addi	r5,r5,17276
 9082358:	908063c0 	call	908063c <ReadDataFifo2>
// printf("sss_udp_process(): READ_DATA_FIFO_2\n");
						datalen = p1;
 908235c:	d0a05c17 	ldw	r2,-32400(gp)
 9082360:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 9082364:	d0205b15 	stw	zero,-32404(gp)
 9082368:	00003106 	br	9082430 <sss_udp_process+0x724>
							databuf[i] = htonl(p2[i]);
 908236c:	d1605b17 	ldw	r5,-32404(gp)
 9082370:	d0a05b17 	ldw	r2,-32404(gp)
 9082374:	00c24374 	movhi	r3,2317
 9082378:	18d0df04 	addi	r3,r3,17276
 908237c:	1085883a 	add	r2,r2,r2
 9082380:	1085883a 	add	r2,r2,r2
 9082384:	10c5883a 	add	r2,r2,r3
 9082388:	10800017 	ldw	r2,0(r2)
 908238c:	1004d63a 	srli	r2,r2,24
 9082390:	11003fcc 	andi	r4,r2,255
 9082394:	d0a05b17 	ldw	r2,-32404(gp)
 9082398:	00c24374 	movhi	r3,2317
 908239c:	18d0df04 	addi	r3,r3,17276
 90823a0:	1085883a 	add	r2,r2,r2
 90823a4:	1085883a 	add	r2,r2,r2
 90823a8:	10c5883a 	add	r2,r2,r3
 90823ac:	10800017 	ldw	r2,0(r2)
 90823b0:	1004d23a 	srli	r2,r2,8
 90823b4:	10bfc00c 	andi	r2,r2,65280
 90823b8:	2088b03a 	or	r4,r4,r2
 90823bc:	d0a05b17 	ldw	r2,-32404(gp)
 90823c0:	00c24374 	movhi	r3,2317
 90823c4:	18d0df04 	addi	r3,r3,17276
 90823c8:	1085883a 	add	r2,r2,r2
 90823cc:	1085883a 	add	r2,r2,r2
 90823d0:	10c5883a 	add	r2,r2,r3
 90823d4:	10800017 	ldw	r2,0(r2)
 90823d8:	10bfc00c 	andi	r2,r2,65280
 90823dc:	1004923a 	slli	r2,r2,8
 90823e0:	2088b03a 	or	r4,r4,r2
 90823e4:	d0a05b17 	ldw	r2,-32404(gp)
 90823e8:	00c24374 	movhi	r3,2317
 90823ec:	18d0df04 	addi	r3,r3,17276
 90823f0:	1085883a 	add	r2,r2,r2
 90823f4:	1085883a 	add	r2,r2,r2
 90823f8:	10c5883a 	add	r2,r2,r3
 90823fc:	10800017 	ldw	r2,0(r2)
 9082400:	10803fcc 	andi	r2,r2,255
 9082404:	1004963a 	slli	r2,r2,24
 9082408:	2088b03a 	or	r4,r4,r2
 908240c:	00c243b4 	movhi	r3,2318
 9082410:	18e00004 	addi	r3,r3,-32768
 9082414:	2945883a 	add	r2,r5,r5
 9082418:	1085883a 	add	r2,r2,r2
 908241c:	10c5883a 	add	r2,r2,r3
 9082420:	11000015 	stw	r4,0(r2)
							databuf[i] = htonl(p2[i]);
						break;
					 case READ_DATA_FIFO_2: ReadDataFifo2(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_2\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 9082424:	d0a05b17 	ldw	r2,-32404(gp)
 9082428:	10800044 	addi	r2,r2,1
 908242c:	d0a05b15 	stw	r2,-32404(gp)
 9082430:	d0a05b17 	ldw	r2,-32404(gp)
 9082434:	1007883a 	mov	r3,r2
 9082438:	d0a05c17 	ldw	r2,-32400(gp)
 908243c:	18bfcb36 	bltu	r3,r2,908236c <sss_udp_process+0x660>
							databuf[i] = htonl(p2[i]);
						break;
 9082440:	00021806 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_3: ReadDataFifo3(p1, p2);
 9082444:	d0a05c17 	ldw	r2,-32400(gp)
 9082448:	1009883a 	mov	r4,r2
 908244c:	01424374 	movhi	r5,2317
 9082450:	2950df04 	addi	r5,r5,17276
 9082454:	90806a80 	call	90806a8 <ReadDataFifo3>
// printf("sss_udp_process(): READ_DATA_FIFO_3\n");
						datalen = p1;
 9082458:	d0a05c17 	ldw	r2,-32400(gp)
 908245c:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 9082460:	d0205b15 	stw	zero,-32404(gp)
 9082464:	00003106 	br	908252c <sss_udp_process+0x820>
							databuf[i] = htonl(p2[i]);
 9082468:	d1605b17 	ldw	r5,-32404(gp)
 908246c:	d0a05b17 	ldw	r2,-32404(gp)
 9082470:	00c24374 	movhi	r3,2317
 9082474:	18d0df04 	addi	r3,r3,17276
 9082478:	1085883a 	add	r2,r2,r2
 908247c:	1085883a 	add	r2,r2,r2
 9082480:	10c5883a 	add	r2,r2,r3
 9082484:	10800017 	ldw	r2,0(r2)
 9082488:	1004d63a 	srli	r2,r2,24
 908248c:	11003fcc 	andi	r4,r2,255
 9082490:	d0a05b17 	ldw	r2,-32404(gp)
 9082494:	00c24374 	movhi	r3,2317
 9082498:	18d0df04 	addi	r3,r3,17276
 908249c:	1085883a 	add	r2,r2,r2
 90824a0:	1085883a 	add	r2,r2,r2
 90824a4:	10c5883a 	add	r2,r2,r3
 90824a8:	10800017 	ldw	r2,0(r2)
 90824ac:	1004d23a 	srli	r2,r2,8
 90824b0:	10bfc00c 	andi	r2,r2,65280
 90824b4:	2088b03a 	or	r4,r4,r2
 90824b8:	d0a05b17 	ldw	r2,-32404(gp)
 90824bc:	00c24374 	movhi	r3,2317
 90824c0:	18d0df04 	addi	r3,r3,17276
 90824c4:	1085883a 	add	r2,r2,r2
 90824c8:	1085883a 	add	r2,r2,r2
 90824cc:	10c5883a 	add	r2,r2,r3
 90824d0:	10800017 	ldw	r2,0(r2)
 90824d4:	10bfc00c 	andi	r2,r2,65280
 90824d8:	1004923a 	slli	r2,r2,8
 90824dc:	2088b03a 	or	r4,r4,r2
 90824e0:	d0a05b17 	ldw	r2,-32404(gp)
 90824e4:	00c24374 	movhi	r3,2317
 90824e8:	18d0df04 	addi	r3,r3,17276
 90824ec:	1085883a 	add	r2,r2,r2
 90824f0:	1085883a 	add	r2,r2,r2
 90824f4:	10c5883a 	add	r2,r2,r3
 90824f8:	10800017 	ldw	r2,0(r2)
 90824fc:	10803fcc 	andi	r2,r2,255
 9082500:	1004963a 	slli	r2,r2,24
 9082504:	2088b03a 	or	r4,r4,r2
 9082508:	00c243b4 	movhi	r3,2318
 908250c:	18e00004 	addi	r3,r3,-32768
 9082510:	2945883a 	add	r2,r5,r5
 9082514:	1085883a 	add	r2,r2,r2
 9082518:	10c5883a 	add	r2,r2,r3
 908251c:	11000015 	stw	r4,0(r2)
							databuf[i] = htonl(p2[i]);
						break;
					 case READ_DATA_FIFO_3: ReadDataFifo3(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_3\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 9082520:	d0a05b17 	ldw	r2,-32404(gp)
 9082524:	10800044 	addi	r2,r2,1
 9082528:	d0a05b15 	stw	r2,-32404(gp)
 908252c:	d0a05b17 	ldw	r2,-32404(gp)
 9082530:	1007883a 	mov	r3,r2
 9082534:	d0a05c17 	ldw	r2,-32400(gp)
 9082538:	18bfcb36 	bltu	r3,r2,9082468 <sss_udp_process+0x75c>
							databuf[i] = htonl(p2[i]);
						break;
 908253c:	0001d906 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_4: ReadDataFifo4(p1, p2);
 9082540:	d0a05c17 	ldw	r2,-32400(gp)
 9082544:	1009883a 	mov	r4,r2
 9082548:	01424374 	movhi	r5,2317
 908254c:	2950df04 	addi	r5,r5,17276
 9082550:	90807140 	call	9080714 <ReadDataFifo4>
// printf("sss_udp_process(): READ_DATA_FIFO_4\n");
						datalen = p1;
 9082554:	d0a05c17 	ldw	r2,-32400(gp)
 9082558:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 908255c:	d0205b15 	stw	zero,-32404(gp)
 9082560:	00003106 	br	9082628 <sss_udp_process+0x91c>
							databuf[i] = htonl(p2[i]);
 9082564:	d1605b17 	ldw	r5,-32404(gp)
 9082568:	d0a05b17 	ldw	r2,-32404(gp)
 908256c:	00c24374 	movhi	r3,2317
 9082570:	18d0df04 	addi	r3,r3,17276
 9082574:	1085883a 	add	r2,r2,r2
 9082578:	1085883a 	add	r2,r2,r2
 908257c:	10c5883a 	add	r2,r2,r3
 9082580:	10800017 	ldw	r2,0(r2)
 9082584:	1004d63a 	srli	r2,r2,24
 9082588:	11003fcc 	andi	r4,r2,255
 908258c:	d0a05b17 	ldw	r2,-32404(gp)
 9082590:	00c24374 	movhi	r3,2317
 9082594:	18d0df04 	addi	r3,r3,17276
 9082598:	1085883a 	add	r2,r2,r2
 908259c:	1085883a 	add	r2,r2,r2
 90825a0:	10c5883a 	add	r2,r2,r3
 90825a4:	10800017 	ldw	r2,0(r2)
 90825a8:	1004d23a 	srli	r2,r2,8
 90825ac:	10bfc00c 	andi	r2,r2,65280
 90825b0:	2088b03a 	or	r4,r4,r2
 90825b4:	d0a05b17 	ldw	r2,-32404(gp)
 90825b8:	00c24374 	movhi	r3,2317
 90825bc:	18d0df04 	addi	r3,r3,17276
 90825c0:	1085883a 	add	r2,r2,r2
 90825c4:	1085883a 	add	r2,r2,r2
 90825c8:	10c5883a 	add	r2,r2,r3
 90825cc:	10800017 	ldw	r2,0(r2)
 90825d0:	10bfc00c 	andi	r2,r2,65280
 90825d4:	1004923a 	slli	r2,r2,8
 90825d8:	2088b03a 	or	r4,r4,r2
 90825dc:	d0a05b17 	ldw	r2,-32404(gp)
 90825e0:	00c24374 	movhi	r3,2317
 90825e4:	18d0df04 	addi	r3,r3,17276
 90825e8:	1085883a 	add	r2,r2,r2
 90825ec:	1085883a 	add	r2,r2,r2
 90825f0:	10c5883a 	add	r2,r2,r3
 90825f4:	10800017 	ldw	r2,0(r2)
 90825f8:	10803fcc 	andi	r2,r2,255
 90825fc:	1004963a 	slli	r2,r2,24
 9082600:	2088b03a 	or	r4,r4,r2
 9082604:	00c243b4 	movhi	r3,2318
 9082608:	18e00004 	addi	r3,r3,-32768
 908260c:	2945883a 	add	r2,r5,r5
 9082610:	1085883a 	add	r2,r2,r2
 9082614:	10c5883a 	add	r2,r2,r3
 9082618:	11000015 	stw	r4,0(r2)
							databuf[i] = htonl(p2[i]);
						break;
					 case READ_DATA_FIFO_4: ReadDataFifo4(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_4\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 908261c:	d0a05b17 	ldw	r2,-32404(gp)
 9082620:	10800044 	addi	r2,r2,1
 9082624:	d0a05b15 	stw	r2,-32404(gp)
 9082628:	d0a05b17 	ldw	r2,-32404(gp)
 908262c:	1007883a 	mov	r3,r2
 9082630:	d0a05c17 	ldw	r2,-32400(gp)
 9082634:	18bfcb36 	bltu	r3,r2,9082564 <sss_udp_process+0x858>
							databuf[i] = htonl(p2[i]);
						break;
 9082638:	00019a06 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_5: ReadDataFifo5(p1, p2);
 908263c:	d0a05c17 	ldw	r2,-32400(gp)
 9082640:	1009883a 	mov	r4,r2
 9082644:	01424374 	movhi	r5,2317
 9082648:	2950df04 	addi	r5,r5,17276
 908264c:	90807800 	call	9080780 <ReadDataFifo5>
// printf("sss_udp_process(): READ_DATA_FIFO_5\n");
						datalen = p1;
 9082650:	d0a05c17 	ldw	r2,-32400(gp)
 9082654:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 9082658:	d0205b15 	stw	zero,-32404(gp)
 908265c:	00003106 	br	9082724 <sss_udp_process+0xa18>
							databuf[i] = htonl(p2[i]);
 9082660:	d1605b17 	ldw	r5,-32404(gp)
 9082664:	d0a05b17 	ldw	r2,-32404(gp)
 9082668:	00c24374 	movhi	r3,2317
 908266c:	18d0df04 	addi	r3,r3,17276
 9082670:	1085883a 	add	r2,r2,r2
 9082674:	1085883a 	add	r2,r2,r2
 9082678:	10c5883a 	add	r2,r2,r3
 908267c:	10800017 	ldw	r2,0(r2)
 9082680:	1004d63a 	srli	r2,r2,24
 9082684:	11003fcc 	andi	r4,r2,255
 9082688:	d0a05b17 	ldw	r2,-32404(gp)
 908268c:	00c24374 	movhi	r3,2317
 9082690:	18d0df04 	addi	r3,r3,17276
 9082694:	1085883a 	add	r2,r2,r2
 9082698:	1085883a 	add	r2,r2,r2
 908269c:	10c5883a 	add	r2,r2,r3
 90826a0:	10800017 	ldw	r2,0(r2)
 90826a4:	1004d23a 	srli	r2,r2,8
 90826a8:	10bfc00c 	andi	r2,r2,65280
 90826ac:	2088b03a 	or	r4,r4,r2
 90826b0:	d0a05b17 	ldw	r2,-32404(gp)
 90826b4:	00c24374 	movhi	r3,2317
 90826b8:	18d0df04 	addi	r3,r3,17276
 90826bc:	1085883a 	add	r2,r2,r2
 90826c0:	1085883a 	add	r2,r2,r2
 90826c4:	10c5883a 	add	r2,r2,r3
 90826c8:	10800017 	ldw	r2,0(r2)
 90826cc:	10bfc00c 	andi	r2,r2,65280
 90826d0:	1004923a 	slli	r2,r2,8
 90826d4:	2088b03a 	or	r4,r4,r2
 90826d8:	d0a05b17 	ldw	r2,-32404(gp)
 90826dc:	00c24374 	movhi	r3,2317
 90826e0:	18d0df04 	addi	r3,r3,17276
 90826e4:	1085883a 	add	r2,r2,r2
 90826e8:	1085883a 	add	r2,r2,r2
 90826ec:	10c5883a 	add	r2,r2,r3
 90826f0:	10800017 	ldw	r2,0(r2)
 90826f4:	10803fcc 	andi	r2,r2,255
 90826f8:	1004963a 	slli	r2,r2,24
 90826fc:	2088b03a 	or	r4,r4,r2
 9082700:	00c243b4 	movhi	r3,2318
 9082704:	18e00004 	addi	r3,r3,-32768
 9082708:	2945883a 	add	r2,r5,r5
 908270c:	1085883a 	add	r2,r2,r2
 9082710:	10c5883a 	add	r2,r2,r3
 9082714:	11000015 	stw	r4,0(r2)
							databuf[i] = htonl(p2[i]);
						break;
					 case READ_DATA_FIFO_5: ReadDataFifo5(p1, p2);
// printf("sss_udp_process(): READ_DATA_FIFO_5\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 9082718:	d0a05b17 	ldw	r2,-32404(gp)
 908271c:	10800044 	addi	r2,r2,1
 9082720:	d0a05b15 	stw	r2,-32404(gp)
 9082724:	d0a05b17 	ldw	r2,-32404(gp)
 9082728:	1007883a 	mov	r3,r2
 908272c:	d0a05c17 	ldw	r2,-32400(gp)
 9082730:	18bfcb36 	bltu	r3,r2,9082660 <sss_udp_process+0x954>
							databuf[i] = htonl(p2[i]);
						break;
 9082734:	00015b06 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DATA_FIFO_STATUS: ReadDataFifoStatus(&p1);
 9082738:	d1205c04 	addi	r4,gp,-32400
 908273c:	908052c0 	call	908052c <ReadDataFifoStatus>
						datalen = 1;
 9082740:	00800044 	movi	r2,1
 9082744:	e0bff915 	stw	r2,-28(fp)
// printf("sss_udp_process(): READ_DATA_FIFO_STATUS: val = 0x%08X\n", p1);
						databuf[0] = htonl(p1);
 9082748:	d0a05c17 	ldw	r2,-32400(gp)
 908274c:	1004d63a 	srli	r2,r2,24
 9082750:	10c03fcc 	andi	r3,r2,255
 9082754:	d0a05c17 	ldw	r2,-32400(gp)
 9082758:	1004d23a 	srli	r2,r2,8
 908275c:	10bfc00c 	andi	r2,r2,65280
 9082760:	1886b03a 	or	r3,r3,r2
 9082764:	d0a05c17 	ldw	r2,-32400(gp)
 9082768:	10bfc00c 	andi	r2,r2,65280
 908276c:	1004923a 	slli	r2,r2,8
 9082770:	1886b03a 	or	r3,r3,r2
 9082774:	d0a05c17 	ldw	r2,-32400(gp)
 9082778:	10803fcc 	andi	r2,r2,255
 908277c:	1004963a 	slli	r2,r2,24
 9082780:	1886b03a 	or	r3,r3,r2
 9082784:	008243b4 	movhi	r2,2318
 9082788:	10a00004 	addi	r2,r2,-32768
 908278c:	10c00015 	stw	r3,0(r2)
						break;
 9082790:	00014406 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_CFG_FIFO: ReadCfgFifo(p1, p2);
 9082794:	d0a05c17 	ldw	r2,-32400(gp)
 9082798:	1009883a 	mov	r4,r2
 908279c:	01424374 	movhi	r5,2317
 90827a0:	2950df04 	addi	r5,r5,17276
 90827a4:	90804880 	call	9080488 <ReadCfgFifo>
// printf("sss_udp_process(): READ_CFG_FIFO\n");
						datalen = p1;
 90827a8:	d0a05c17 	ldw	r2,-32400(gp)
 90827ac:	e0bff915 	stw	r2,-28(fp)
						 for(i=0;i<p1;i++)
 90827b0:	d0205b15 	stw	zero,-32404(gp)
 90827b4:	00003106 	br	908287c <sss_udp_process+0xb70>
							databuf[i] = htonl(p2[i]);
 90827b8:	d1605b17 	ldw	r5,-32404(gp)
 90827bc:	d0a05b17 	ldw	r2,-32404(gp)
 90827c0:	00c24374 	movhi	r3,2317
 90827c4:	18d0df04 	addi	r3,r3,17276
 90827c8:	1085883a 	add	r2,r2,r2
 90827cc:	1085883a 	add	r2,r2,r2
 90827d0:	10c5883a 	add	r2,r2,r3
 90827d4:	10800017 	ldw	r2,0(r2)
 90827d8:	1004d63a 	srli	r2,r2,24
 90827dc:	11003fcc 	andi	r4,r2,255
 90827e0:	d0a05b17 	ldw	r2,-32404(gp)
 90827e4:	00c24374 	movhi	r3,2317
 90827e8:	18d0df04 	addi	r3,r3,17276
 90827ec:	1085883a 	add	r2,r2,r2
 90827f0:	1085883a 	add	r2,r2,r2
 90827f4:	10c5883a 	add	r2,r2,r3
 90827f8:	10800017 	ldw	r2,0(r2)
 90827fc:	1004d23a 	srli	r2,r2,8
 9082800:	10bfc00c 	andi	r2,r2,65280
 9082804:	2088b03a 	or	r4,r4,r2
 9082808:	d0a05b17 	ldw	r2,-32404(gp)
 908280c:	00c24374 	movhi	r3,2317
 9082810:	18d0df04 	addi	r3,r3,17276
 9082814:	1085883a 	add	r2,r2,r2
 9082818:	1085883a 	add	r2,r2,r2
 908281c:	10c5883a 	add	r2,r2,r3
 9082820:	10800017 	ldw	r2,0(r2)
 9082824:	10bfc00c 	andi	r2,r2,65280
 9082828:	1004923a 	slli	r2,r2,8
 908282c:	2088b03a 	or	r4,r4,r2
 9082830:	d0a05b17 	ldw	r2,-32404(gp)
 9082834:	00c24374 	movhi	r3,2317
 9082838:	18d0df04 	addi	r3,r3,17276
 908283c:	1085883a 	add	r2,r2,r2
 9082840:	1085883a 	add	r2,r2,r2
 9082844:	10c5883a 	add	r2,r2,r3
 9082848:	10800017 	ldw	r2,0(r2)
 908284c:	10803fcc 	andi	r2,r2,255
 9082850:	1004963a 	slli	r2,r2,24
 9082854:	2088b03a 	or	r4,r4,r2
 9082858:	00c243b4 	movhi	r3,2318
 908285c:	18e00004 	addi	r3,r3,-32768
 9082860:	2945883a 	add	r2,r5,r5
 9082864:	1085883a 	add	r2,r2,r2
 9082868:	10c5883a 	add	r2,r2,r3
 908286c:	11000015 	stw	r4,0(r2)
						databuf[0] = htonl(p1);
						break;
					 case READ_CFG_FIFO: ReadCfgFifo(p1, p2);
// printf("sss_udp_process(): READ_CFG_FIFO\n");
						datalen = p1;
						 for(i=0;i<p1;i++)
 9082870:	d0a05b17 	ldw	r2,-32404(gp)
 9082874:	10800044 	addi	r2,r2,1
 9082878:	d0a05b15 	stw	r2,-32404(gp)
 908287c:	d0a05b17 	ldw	r2,-32404(gp)
 9082880:	1007883a 	mov	r3,r2
 9082884:	d0a05c17 	ldw	r2,-32400(gp)
 9082888:	18bfcb36 	bltu	r3,r2,90827b8 <sss_udp_process+0xaac>
							databuf[i] = htonl(p2[i]);
						break;
 908288c:	00010506 	br	9082ca4 <sss_udp_process+0xf98>
					 case WRITE_CFG_FIFO: WriteCfgFifo(p1, p2);
 9082890:	d0a05c17 	ldw	r2,-32400(gp)
 9082894:	1009883a 	mov	r4,r2
 9082898:	01424374 	movhi	r5,2317
 908289c:	2950df04 	addi	r5,r5,17276
 90828a0:	90803640 	call	9080364 <WriteCfgFifo>
						tx_wr_pos += sprintf(tx_wr_pos, "ACK %c", (char)SSSCommand);
 90828a4:	e13ffb17 	ldw	r4,-20(fp)
 90828a8:	d0a05917 	ldw	r2,-32412(gp)
 90828ac:	11803fcc 	andi	r6,r2,255
 90828b0:	3180201c 	xori	r6,r6,128
 90828b4:	31bfe004 	addi	r6,r6,-128
 90828b8:	01424374 	movhi	r5,2317
 90828bc:	2972aa04 	addi	r5,r5,-13656
 90828c0:	908372c0 	call	908372c <sprintf>
 90828c4:	1007883a 	mov	r3,r2
 90828c8:	e0bffb17 	ldw	r2,-20(fp)
 90828cc:	10c5883a 	add	r2,r2,r3
 90828d0:	e0bffb15 	stw	r2,-20(fp)
// printf("sss_udp_process(): WRITE_CFG_FIFO\n");
						break;
 90828d4:	0000f306 	br	9082ca4 <sss_udp_process+0xf98>
					 case WRITE_NBIT_REG: WriteNbitReg(p1);
 90828d8:	d1205c17 	ldw	r4,-32400(gp)
 90828dc:	90803340 	call	9080334 <WriteNbitReg>
						tx_wr_pos += sprintf(tx_wr_pos, "ACK %c", (char)SSSCommand);
 90828e0:	e13ffb17 	ldw	r4,-20(fp)
 90828e4:	d0a05917 	ldw	r2,-32412(gp)
 90828e8:	11803fcc 	andi	r6,r2,255
 90828ec:	3180201c 	xori	r6,r6,128
 90828f0:	31bfe004 	addi	r6,r6,-128
 90828f4:	01424374 	movhi	r5,2317
 90828f8:	2972aa04 	addi	r5,r5,-13656
 90828fc:	908372c0 	call	908372c <sprintf>
 9082900:	1007883a 	mov	r3,r2
 9082904:	e0bffb17 	ldw	r2,-20(fp)
 9082908:	10c5883a 	add	r2,r2,r3
 908290c:	e0bffb15 	stw	r2,-20(fp)
// printf("sss_udp_process(): WRITE_NBIT_REG: val = 0x%08X\n", p1);
						break;
 9082910:	0000e406 	br	9082ca4 <sss_udp_process+0xf98>
					 case WRITE_COMMAND_REG: WriteCommandReg(p1);
 9082914:	d1205c17 	ldw	r4,-32400(gp)
 9082918:	90803040 	call	9080304 <WriteCommandReg>
						tx_wr_pos += sprintf(tx_wr_pos, "ACK %c", (char)SSSCommand);
 908291c:	e13ffb17 	ldw	r4,-20(fp)
 9082920:	d0a05917 	ldw	r2,-32412(gp)
 9082924:	11803fcc 	andi	r6,r2,255
 9082928:	3180201c 	xori	r6,r6,128
 908292c:	31bfe004 	addi	r6,r6,-128
 9082930:	01424374 	movhi	r5,2317
 9082934:	2972aa04 	addi	r5,r5,-13656
 9082938:	908372c0 	call	908372c <sprintf>
 908293c:	1007883a 	mov	r3,r2
 9082940:	e0bffb17 	ldw	r2,-20(fp)
 9082944:	10c5883a 	add	r2,r2,r3
 9082948:	e0bffb15 	stw	r2,-20(fp)
// printf("sss_udp_process(): WRITE_COMMAND_REG: val = 0x%08X\n", p1);
						break;
 908294c:	0000d506 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_STATUS_REG: ReadStatusReg(&p1);
 9082950:	d1205c04 	addi	r4,gp,-32400
 9082954:	90804f40 	call	90804f4 <ReadStatusReg>
// printf("sss_udp_process(): READ_STATUS_REG: val = 0x%08X\n", p1);
//						datalen = 1;	// Original
						datalen = 5;	// New
 9082958:	00800144 	movi	r2,5
 908295c:	e0bff915 	stw	r2,-28(fp)
						databuf[0] = htonl(p1);
 9082960:	d0a05c17 	ldw	r2,-32400(gp)
 9082964:	1004d63a 	srli	r2,r2,24
 9082968:	10c03fcc 	andi	r3,r2,255
 908296c:	d0a05c17 	ldw	r2,-32400(gp)
 9082970:	1004d23a 	srli	r2,r2,8
 9082974:	10bfc00c 	andi	r2,r2,65280
 9082978:	1886b03a 	or	r3,r3,r2
 908297c:	d0a05c17 	ldw	r2,-32400(gp)
 9082980:	10bfc00c 	andi	r2,r2,65280
 9082984:	1004923a 	slli	r2,r2,8
 9082988:	1886b03a 	or	r3,r3,r2
 908298c:	d0a05c17 	ldw	r2,-32400(gp)
 9082990:	10803fcc 	andi	r2,r2,255
 9082994:	1004963a 	slli	r2,r2,24
 9082998:	1886b03a 	or	r3,r3,r2
 908299c:	008243b4 	movhi	r2,2318
 90829a0:	10a00004 	addi	r2,r2,-32768
 90829a4:	10c00015 	stw	r3,0(r2)
						ReadDataFifoStatus(&p1);
 90829a8:	d1205c04 	addi	r4,gp,-32400
 90829ac:	908052c0 	call	908052c <ReadDataFifoStatus>
						databuf[1] = htonl(p1);
 90829b0:	d0a05c17 	ldw	r2,-32400(gp)
 90829b4:	1004d63a 	srli	r2,r2,24
 90829b8:	10c03fcc 	andi	r3,r2,255
 90829bc:	d0a05c17 	ldw	r2,-32400(gp)
 90829c0:	1004d23a 	srli	r2,r2,8
 90829c4:	10bfc00c 	andi	r2,r2,65280
 90829c8:	1886b03a 	or	r3,r3,r2
 90829cc:	d0a05c17 	ldw	r2,-32400(gp)
 90829d0:	10bfc00c 	andi	r2,r2,65280
 90829d4:	1004923a 	slli	r2,r2,8
 90829d8:	1886b03a 	or	r3,r3,r2
 90829dc:	d0a05c17 	ldw	r2,-32400(gp)
 90829e0:	10803fcc 	andi	r2,r2,255
 90829e4:	1004963a 	slli	r2,r2,24
 90829e8:	1886b03a 	or	r3,r3,r2
 90829ec:	008243b4 	movhi	r2,2318
 90829f0:	10a00004 	addi	r2,r2,-32768
 90829f4:	10c00115 	stw	r3,4(r2)
						ReadDummyReg(13, &p2[0]);
 90829f8:	01000344 	movi	r4,13
 90829fc:	01424374 	movhi	r5,2317
 9082a00:	2950df04 	addi	r5,r5,17276
 9082a04:	90803d40 	call	90803d4 <ReadDummyReg>
						databuf[2] = htonl(p2[0]);
 9082a08:	00824374 	movhi	r2,2317
 9082a0c:	1090df04 	addi	r2,r2,17276
 9082a10:	10800017 	ldw	r2,0(r2)
 9082a14:	1004d63a 	srli	r2,r2,24
 9082a18:	10c03fcc 	andi	r3,r2,255
 9082a1c:	00824374 	movhi	r2,2317
 9082a20:	1090df04 	addi	r2,r2,17276
 9082a24:	10800017 	ldw	r2,0(r2)
 9082a28:	1004d23a 	srli	r2,r2,8
 9082a2c:	10bfc00c 	andi	r2,r2,65280
 9082a30:	1886b03a 	or	r3,r3,r2
 9082a34:	00824374 	movhi	r2,2317
 9082a38:	1090df04 	addi	r2,r2,17276
 9082a3c:	10800017 	ldw	r2,0(r2)
 9082a40:	10bfc00c 	andi	r2,r2,65280
 9082a44:	1004923a 	slli	r2,r2,8
 9082a48:	1886b03a 	or	r3,r3,r2
 9082a4c:	00824374 	movhi	r2,2317
 9082a50:	1090df04 	addi	r2,r2,17276
 9082a54:	10800017 	ldw	r2,0(r2)
 9082a58:	10803fcc 	andi	r2,r2,255
 9082a5c:	1004963a 	slli	r2,r2,24
 9082a60:	1886b03a 	or	r3,r3,r2
 9082a64:	008243b4 	movhi	r2,2318
 9082a68:	10a00004 	addi	r2,r2,-32768
 9082a6c:	10c00215 	stw	r3,8(r2)
						ReadDummyReg(14, &p2[0]);
 9082a70:	01000384 	movi	r4,14
 9082a74:	01424374 	movhi	r5,2317
 9082a78:	2950df04 	addi	r5,r5,17276
 9082a7c:	90803d40 	call	90803d4 <ReadDummyReg>
						databuf[3] = htonl(p2[0]);
 9082a80:	00824374 	movhi	r2,2317
 9082a84:	1090df04 	addi	r2,r2,17276
 9082a88:	10800017 	ldw	r2,0(r2)
 9082a8c:	1004d63a 	srli	r2,r2,24
 9082a90:	10c03fcc 	andi	r3,r2,255
 9082a94:	00824374 	movhi	r2,2317
 9082a98:	1090df04 	addi	r2,r2,17276
 9082a9c:	10800017 	ldw	r2,0(r2)
 9082aa0:	1004d23a 	srli	r2,r2,8
 9082aa4:	10bfc00c 	andi	r2,r2,65280
 9082aa8:	1886b03a 	or	r3,r3,r2
 9082aac:	00824374 	movhi	r2,2317
 9082ab0:	1090df04 	addi	r2,r2,17276
 9082ab4:	10800017 	ldw	r2,0(r2)
 9082ab8:	10bfc00c 	andi	r2,r2,65280
 9082abc:	1004923a 	slli	r2,r2,8
 9082ac0:	1886b03a 	or	r3,r3,r2
 9082ac4:	00824374 	movhi	r2,2317
 9082ac8:	1090df04 	addi	r2,r2,17276
 9082acc:	10800017 	ldw	r2,0(r2)
 9082ad0:	10803fcc 	andi	r2,r2,255
 9082ad4:	1004963a 	slli	r2,r2,24
 9082ad8:	1886b03a 	or	r3,r3,r2
 9082adc:	008243b4 	movhi	r2,2318
 9082ae0:	10a00004 	addi	r2,r2,-32768
 9082ae4:	10c00315 	stw	r3,12(r2)
						ReadDummyReg(15, &p2[0]);
 9082ae8:	010003c4 	movi	r4,15
 9082aec:	01424374 	movhi	r5,2317
 9082af0:	2950df04 	addi	r5,r5,17276
 9082af4:	90803d40 	call	90803d4 <ReadDummyReg>
						databuf[4] = htonl(p2[0]);
 9082af8:	00824374 	movhi	r2,2317
 9082afc:	1090df04 	addi	r2,r2,17276
 9082b00:	10800017 	ldw	r2,0(r2)
 9082b04:	1004d63a 	srli	r2,r2,24
 9082b08:	10c03fcc 	andi	r3,r2,255
 9082b0c:	00824374 	movhi	r2,2317
 9082b10:	1090df04 	addi	r2,r2,17276
 9082b14:	10800017 	ldw	r2,0(r2)
 9082b18:	1004d23a 	srli	r2,r2,8
 9082b1c:	10bfc00c 	andi	r2,r2,65280
 9082b20:	1886b03a 	or	r3,r3,r2
 9082b24:	00824374 	movhi	r2,2317
 9082b28:	1090df04 	addi	r2,r2,17276
 9082b2c:	10800017 	ldw	r2,0(r2)
 9082b30:	10bfc00c 	andi	r2,r2,65280
 9082b34:	1004923a 	slli	r2,r2,8
 9082b38:	1886b03a 	or	r3,r3,r2
 9082b3c:	00824374 	movhi	r2,2317
 9082b40:	1090df04 	addi	r2,r2,17276
 9082b44:	10800017 	ldw	r2,0(r2)
 9082b48:	10803fcc 	andi	r2,r2,255
 9082b4c:	1004963a 	slli	r2,r2,24
 9082b50:	1886b03a 	or	r3,r3,r2
 9082b54:	008243b4 	movhi	r2,2318
 9082b58:	10a00004 	addi	r2,r2,-32768
 9082b5c:	10c00415 	stw	r3,16(r2)
						break;
 9082b60:	00005006 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_NBIT_REG: ReadNbitReg(&p1);
 9082b64:	d1205c04 	addi	r4,gp,-32400
 9082b68:	90804500 	call	9080450 <ReadNbitReg>
// printf("sss_udp_process(): READ_NBIT_REG: val = 0x%08X\n", p1);
						tx_wr_pos += sprintf(tx_wr_pos,"0x%08X", p1);
 9082b6c:	e13ffb17 	ldw	r4,-20(fp)
 9082b70:	d1a05c17 	ldw	r6,-32400(gp)
 9082b74:	01424374 	movhi	r5,2317
 9082b78:	2972ac04 	addi	r5,r5,-13648
 9082b7c:	908372c0 	call	908372c <sprintf>
 9082b80:	1007883a 	mov	r3,r2
 9082b84:	e0bffb17 	ldw	r2,-20(fp)
 9082b88:	10c5883a 	add	r2,r2,r3
 9082b8c:	e0bffb15 	stw	r2,-20(fp)
						break;
 9082b90:	00004406 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_COMMAND_REG: ReadCommandReg(&p1);
 9082b94:	d1205c04 	addi	r4,gp,-32400
 9082b98:	90804180 	call	9080418 <ReadCommandReg>
// printf("sss_udp_process(): READ_COMMAND_REG: val = 0x%08X\n", p1);
						tx_wr_pos += sprintf(tx_wr_pos,"0x%08X", p1);
 9082b9c:	e13ffb17 	ldw	r4,-20(fp)
 9082ba0:	d1a05c17 	ldw	r6,-32400(gp)
 9082ba4:	01424374 	movhi	r5,2317
 9082ba8:	2972ac04 	addi	r5,r5,-13648
 9082bac:	908372c0 	call	908372c <sprintf>
 9082bb0:	1007883a 	mov	r3,r2
 9082bb4:	e0bffb17 	ldw	r2,-20(fp)
 9082bb8:	10c5883a 	add	r2,r2,r3
 9082bbc:	e0bffb15 	stw	r2,-20(fp)
						break;
 9082bc0:	00003806 	br	9082ca4 <sss_udp_process+0xf98>
					 case READ_DUMMY_REG: ReadDummyReg(p1, &p2[0]);
 9082bc4:	d0a05c17 	ldw	r2,-32400(gp)
 9082bc8:	1009883a 	mov	r4,r2
 9082bcc:	01424374 	movhi	r5,2317
 9082bd0:	2950df04 	addi	r5,r5,17276
 9082bd4:	90803d40 	call	90803d4 <ReadDummyReg>
						datalen = 1;
 9082bd8:	00800044 	movi	r2,1
 9082bdc:	e0bff915 	stw	r2,-28(fp)
//printf("sss_udp_process(): READ_RUMMY_REG: x = %d, val = 0x%08X\n", p1, p2[0]);
						databuf[0] = htonl(p2[0]);
 9082be0:	00824374 	movhi	r2,2317
 9082be4:	1090df04 	addi	r2,r2,17276
 9082be8:	10800017 	ldw	r2,0(r2)
 9082bec:	1004d63a 	srli	r2,r2,24
 9082bf0:	10c03fcc 	andi	r3,r2,255
 9082bf4:	00824374 	movhi	r2,2317
 9082bf8:	1090df04 	addi	r2,r2,17276
 9082bfc:	10800017 	ldw	r2,0(r2)
 9082c00:	1004d23a 	srli	r2,r2,8
 9082c04:	10bfc00c 	andi	r2,r2,65280
 9082c08:	1886b03a 	or	r3,r3,r2
 9082c0c:	00824374 	movhi	r2,2317
 9082c10:	1090df04 	addi	r2,r2,17276
 9082c14:	10800017 	ldw	r2,0(r2)
 9082c18:	10bfc00c 	andi	r2,r2,65280
 9082c1c:	1004923a 	slli	r2,r2,8
 9082c20:	1886b03a 	or	r3,r3,r2
 9082c24:	00824374 	movhi	r2,2317
 9082c28:	1090df04 	addi	r2,r2,17276
 9082c2c:	10800017 	ldw	r2,0(r2)
 9082c30:	10803fcc 	andi	r2,r2,255
 9082c34:	1004963a 	slli	r2,r2,24
 9082c38:	1886b03a 	or	r3,r3,r2
 9082c3c:	008243b4 	movhi	r2,2318
 9082c40:	10a00004 	addi	r2,r2,-32768
 9082c44:	10c00015 	stw	r3,0(r2)
						 break;
 9082c48:	00001606 	br	9082ca4 <sss_udp_process+0xf98>
					 case CLIENT_NET_ADDR: //send_addr.sin_addr.s_addr = inet_addr(ps);
						tx_wr_pos += sprintf(tx_wr_pos, "ACK %c", (char)SSSCommand);
 9082c4c:	e13ffb17 	ldw	r4,-20(fp)
 9082c50:	d0a05917 	ldw	r2,-32412(gp)
 9082c54:	11803fcc 	andi	r6,r2,255
 9082c58:	3180201c 	xori	r6,r6,128
 9082c5c:	31bfe004 	addi	r6,r6,-128
 9082c60:	01424374 	movhi	r5,2317
 9082c64:	2972aa04 	addi	r5,r5,-13656
 9082c68:	908372c0 	call	908372c <sprintf>
 9082c6c:	1007883a 	mov	r3,r2
 9082c70:	e0bffb17 	ldw	r2,-20(fp)
 9082c74:	10c5883a 	add	r2,r2,r3
 9082c78:	e0bffb15 	stw	r2,-20(fp)
// printf("sss_udp_process(): WRITE_NBIT_REG: val = 0x%08X\n", p1);
						break;
 9082c7c:	00000906 	br	9082ca4 <sss_udp_process+0xf98>
					 default: tx_wr_pos += sprintf(tx_wr_pos,"'%c' Command not found.\n", SSSCommand); break;
 9082c80:	e13ffb17 	ldw	r4,-20(fp)
 9082c84:	d1a05917 	ldw	r6,-32412(gp)
 9082c88:	01424374 	movhi	r5,2317
 9082c8c:	2972ae04 	addi	r5,r5,-13640
 9082c90:	908372c0 	call	908372c <sprintf>
 9082c94:	1007883a 	mov	r3,r2
 9082c98:	e0bffb17 	ldw	r2,-20(fp)
 9082c9c:	10c5883a 	add	r2,r2,r3
 9082ca0:	e0bffb15 	stw	r2,-20(fp)
	   cliaddr_len = sizeof(cliaddr);
	   bytes_to_process = recvfrom(fd_listen, rx_buf, SSS_RX_BUF_SIZE, 0, (struct sockaddr*)&cliaddr, &cliaddr_len);
           rx_buf[bytes_to_process] = 0;
// printf("sss_udp_process(): bytes_to_process = %d\n", bytes_to_process);

	   while(bytes_to_process--)
 9082ca4:	e0bffc17 	ldw	r2,-16(fp)
 9082ca8:	10bfffc4 	addi	r2,r2,-1
 9082cac:	e0bffc15 	stw	r2,-16(fp)
 9082cb0:	e0bffc17 	ldw	r2,-16(fp)
 9082cb4:	10bfffd8 	cmpnei	r2,r2,-1
 9082cb8:	103c4e1e 	bne	r2,zero,9081df4 <sss_udp_process+0xe8>
			 }
		  }
	   }
//printf("sss_udp_process(): tx_buf = '%s'\n", tx_buf);
//	  sendto(fd_listen, tx_buf, strlen(tx_buf), 0, &send_addr, sizeof(struct sockaddr_in));
	if( datalen )
 9082cbc:	e0bff917 	ldw	r2,-28(fp)
 9082cc0:	1005003a 	cmpeq	r2,r2,zero
 9082cc4:	10000f1e 	bne	r2,zero,9082d04 <sss_udp_process+0xff8>
		sendto(fd_listen, databuf, datalen*4, 0, &cliaddr, sizeof(cliaddr));
 9082cc8:	d1205d17 	ldw	r4,-32396(gp)
 9082ccc:	014243b4 	movhi	r5,2318
 9082cd0:	29600004 	addi	r5,r5,-32768
 9082cd4:	e0bff917 	ldw	r2,-28(fp)
 9082cd8:	1085883a 	add	r2,r2,r2
 9082cdc:	1085883a 	add	r2,r2,r2
 9082ce0:	100d883a 	mov	r6,r2
 9082ce4:	00824374 	movhi	r2,2317
 9082ce8:	109d0e04 	addi	r2,r2,29752
 9082cec:	d8800015 	stw	r2,0(sp)
 9082cf0:	00800404 	movi	r2,16
 9082cf4:	d8800115 	stw	r2,4(sp)
 9082cf8:	000f883a 	mov	r7,zero
 9082cfc:	90ae5e80 	call	90ae5e8 <t_sendto>
 9082d00:	00001006 	br	9082d44 <sss_udp_process+0x1038>
	else
		sendto(fd_listen, tx_buf, strlen(tx_buf), 0, &cliaddr, sizeof(cliaddr));
 9082d04:	d4205d17 	ldw	r16,-32396(gp)
 9082d08:	04424374 	movhi	r17,2317
 9082d0c:	8c5e8904 	addi	r17,r17,31268
 9082d10:	01024374 	movhi	r4,2317
 9082d14:	211e8904 	addi	r4,r4,31268
 9082d18:	9083f540 	call	9083f54 <strlen>
 9082d1c:	100d883a 	mov	r6,r2
 9082d20:	00824374 	movhi	r2,2317
 9082d24:	109d0e04 	addi	r2,r2,29752
 9082d28:	d8800015 	stw	r2,0(sp)
 9082d2c:	00800404 	movi	r2,16
 9082d30:	d8800115 	stw	r2,4(sp)
 9082d34:	8009883a 	mov	r4,r16
 9082d38:	880b883a 	mov	r5,r17
 9082d3c:	000f883a 	mov	r7,zero
 9082d40:	90ae5e80 	call	90ae5e8 <t_sendto>

	DataFifoReadout();
 9082d44:	9082d640 	call	9082d64 <DataFifoReadout>

	}
 9082d48:	003c0706 	br	9081d68 <sss_udp_process+0x5c>

09082d4c <DataFifoReadout_Task>:
  return;
}

void DataFifoReadout_Task(void)
{
 9082d4c:	defffe04 	addi	sp,sp,-8
 9082d50:	dfc00115 	stw	ra,4(sp)
 9082d54:	df000015 	stw	fp,0(sp)
 9082d58:	d839883a 	mov	fp,sp
//printf("DataFifoReadout_Task() started!\n");

	while(1)
	{
//		TK_SLEEP(1);
		DataFifoReadout();
 9082d5c:	9082d640 	call	9082d64 <DataFifoReadout>
	}
 9082d60:	003ffe06 	br	9082d5c <DataFifoReadout_Task+0x10>

09082d64 <DataFifoReadout>:
}

void DataFifoReadout(void)
{
 9082d64:	defff804 	addi	sp,sp,-32
 9082d68:	dfc00715 	stw	ra,28(sp)
 9082d6c:	df000615 	stw	fp,24(sp)
 9082d70:	df000604 	addi	fp,sp,24
	int i, j, ndata;
	INT32U cmd;
//printf("DataFifoReadout() started!\n");

	ReadCommandReg(&cmd);
 9082d74:	e13fff04 	addi	r4,fp,-4
 9082d78:	90804180 	call	9080418 <ReadCommandReg>
	for(i=0; i<6; i++)
 9082d7c:	e03ffd15 	stw	zero,-12(fp)
 9082d80:	00009c06 	br	9082ff4 <DataFifoReadout+0x290>
	{
		if( cmd & (0x1000000 << i) )	// Readout enabled on chip i
 9082d84:	00c04034 	movhi	r3,256
 9082d88:	e0bffd17 	ldw	r2,-12(fp)
 9082d8c:	1884983a 	sll	r2,r3,r2
 9082d90:	1007883a 	mov	r3,r2
 9082d94:	e0bfff17 	ldw	r2,-4(fp)
 9082d98:	1884703a 	and	r2,r3,r2
 9082d9c:	1005003a 	cmpeq	r2,r2,zero
 9082da0:	1000911e 	bne	r2,zero,9082fe8 <DataFifoReadout+0x284>
		{
			switch( i )
 9082da4:	e0bffd17 	ldw	r2,-12(fp)
 9082da8:	108001a8 	cmpgeui	r2,r2,6
 9082dac:	1000371e 	bne	r2,zero,9082e8c <DataFifoReadout+0x128>
 9082db0:	e0bffd17 	ldw	r2,-12(fp)
 9082db4:	1085883a 	add	r2,r2,r2
 9082db8:	1087883a 	add	r3,r2,r2
 9082dbc:	00824234 	movhi	r2,2312
 9082dc0:	108b7404 	addi	r2,r2,11728
 9082dc4:	1885883a 	add	r2,r3,r2
 9082dc8:	10800017 	ldw	r2,0(r2)
 9082dcc:	1000683a 	jmp	r2
 9082dd0:	09082de8 	cmpgeui	r4,at,8375
 9082dd4:	09082e04 	addi	r4,at,8376
 9082dd8:	09082e20 	cmpeqi	r4,at,8376
 9082ddc:	09082e3c 	xorhi	r4,at,8376
 9082de0:	09082e58 	cmpnei	r4,at,8377
 9082de4:	09082e74 	orhi	r4,at,8377
			{
				case 0: ReadDummyReg(13, &ndata); ndata &= 0xFFFF; break;
 9082de8:	e17ffe04 	addi	r5,fp,-8
 9082dec:	01000344 	movi	r4,13
 9082df0:	90803d40 	call	90803d4 <ReadDummyReg>
 9082df4:	e0bffe17 	ldw	r2,-8(fp)
 9082df8:	10bfffcc 	andi	r2,r2,65535
 9082dfc:	e0bffe15 	stw	r2,-8(fp)
 9082e00:	00002206 	br	9082e8c <DataFifoReadout+0x128>
				case 1: ReadDummyReg(13, &ndata); ndata >>= 16; break;
 9082e04:	e17ffe04 	addi	r5,fp,-8
 9082e08:	01000344 	movi	r4,13
 9082e0c:	90803d40 	call	90803d4 <ReadDummyReg>
 9082e10:	e0bffe17 	ldw	r2,-8(fp)
 9082e14:	1005d43a 	srai	r2,r2,16
 9082e18:	e0bffe15 	stw	r2,-8(fp)
 9082e1c:	00001b06 	br	9082e8c <DataFifoReadout+0x128>
				case 2: ReadDummyReg(14, &ndata); ndata &= 0xFFFF; break;
 9082e20:	e17ffe04 	addi	r5,fp,-8
 9082e24:	01000384 	movi	r4,14
 9082e28:	90803d40 	call	90803d4 <ReadDummyReg>
 9082e2c:	e0bffe17 	ldw	r2,-8(fp)
 9082e30:	10bfffcc 	andi	r2,r2,65535
 9082e34:	e0bffe15 	stw	r2,-8(fp)
 9082e38:	00001406 	br	9082e8c <DataFifoReadout+0x128>
				case 3: ReadDummyReg(14, &ndata); ndata >>= 16; break;
 9082e3c:	e17ffe04 	addi	r5,fp,-8
 9082e40:	01000384 	movi	r4,14
 9082e44:	90803d40 	call	90803d4 <ReadDummyReg>
 9082e48:	e0bffe17 	ldw	r2,-8(fp)
 9082e4c:	1005d43a 	srai	r2,r2,16
 9082e50:	e0bffe15 	stw	r2,-8(fp)
 9082e54:	00000d06 	br	9082e8c <DataFifoReadout+0x128>
				case 4: ReadDummyReg(15, &ndata); ndata &= 0xFFFF; break;
 9082e58:	e17ffe04 	addi	r5,fp,-8
 9082e5c:	010003c4 	movi	r4,15
 9082e60:	90803d40 	call	90803d4 <ReadDummyReg>
 9082e64:	e0bffe17 	ldw	r2,-8(fp)
 9082e68:	10bfffcc 	andi	r2,r2,65535
 9082e6c:	e0bffe15 	stw	r2,-8(fp)
 9082e70:	00000606 	br	9082e8c <DataFifoReadout+0x128>
				case 5: ReadDummyReg(15, &ndata); ndata >>= 16; break;
 9082e74:	e17ffe04 	addi	r5,fp,-8
 9082e78:	010003c4 	movi	r4,15
 9082e7c:	90803d40 	call	90803d4 <ReadDummyReg>
 9082e80:	e0bffe17 	ldw	r2,-8(fp)
 9082e84:	1005d43a 	srai	r2,r2,16
 9082e88:	e0bffe15 	stw	r2,-8(fp)
			}
			if( ndata > 255 )
 9082e8c:	e0bffe17 	ldw	r2,-8(fp)
 9082e90:	10804010 	cmplti	r2,r2,256
 9082e94:	1000541e 	bne	r2,zero,9082fe8 <DataFifoReadout+0x284>
			{
				ndata = 256;
 9082e98:	00804004 	movi	r2,256
 9082e9c:	e0bffe15 	stw	r2,-8(fp)
				databuf[0] = 0x43485000 + i;	// 'CHPi'
 9082ea0:	e0fffd17 	ldw	r3,-12(fp)
 9082ea4:	0090d234 	movhi	r2,17224
 9082ea8:	10940004 	addi	r2,r2,20480
 9082eac:	1885883a 	add	r2,r3,r2
 9082eb0:	1007883a 	mov	r3,r2
 9082eb4:	008243b4 	movhi	r2,2318
 9082eb8:	10a00004 	addi	r2,r2,-32768
 9082ebc:	10c00015 	stw	r3,0(r2)
				ReadDataFifo(i, ndata-1, databuf+1);	// to avoid overflow
 9082ec0:	e0bffe17 	ldw	r2,-8(fp)
 9082ec4:	117fffc4 	addi	r5,r2,-1
 9082ec8:	018243b4 	movhi	r6,2318
 9082ecc:	31a00104 	addi	r6,r6,-32764
 9082ed0:	e13ffd17 	ldw	r4,-12(fp)
 9082ed4:	90807ec0 	call	90807ec <ReadDataFifo>
				for(j=0; j<ndata; j++)
 9082ed8:	e03ffc15 	stw	zero,-16(fp)
 9082edc:	00003106 	br	9082fa4 <DataFifoReadout+0x240>
					databuf[j] = htonl(databuf[j]);
 9082ee0:	e17ffc17 	ldw	r5,-16(fp)
 9082ee4:	e0bffc17 	ldw	r2,-16(fp)
 9082ee8:	00c243b4 	movhi	r3,2318
 9082eec:	18e00004 	addi	r3,r3,-32768
 9082ef0:	1085883a 	add	r2,r2,r2
 9082ef4:	1085883a 	add	r2,r2,r2
 9082ef8:	10c5883a 	add	r2,r2,r3
 9082efc:	10800017 	ldw	r2,0(r2)
 9082f00:	1004d63a 	srli	r2,r2,24
 9082f04:	11003fcc 	andi	r4,r2,255
 9082f08:	e0bffc17 	ldw	r2,-16(fp)
 9082f0c:	00c243b4 	movhi	r3,2318
 9082f10:	18e00004 	addi	r3,r3,-32768
 9082f14:	1085883a 	add	r2,r2,r2
 9082f18:	1085883a 	add	r2,r2,r2
 9082f1c:	10c5883a 	add	r2,r2,r3
 9082f20:	10800017 	ldw	r2,0(r2)
 9082f24:	1004d23a 	srli	r2,r2,8
 9082f28:	10bfc00c 	andi	r2,r2,65280
 9082f2c:	2088b03a 	or	r4,r4,r2
 9082f30:	e0bffc17 	ldw	r2,-16(fp)
 9082f34:	00c243b4 	movhi	r3,2318
 9082f38:	18e00004 	addi	r3,r3,-32768
 9082f3c:	1085883a 	add	r2,r2,r2
 9082f40:	1085883a 	add	r2,r2,r2
 9082f44:	10c5883a 	add	r2,r2,r3
 9082f48:	10800017 	ldw	r2,0(r2)
 9082f4c:	10bfc00c 	andi	r2,r2,65280
 9082f50:	1004923a 	slli	r2,r2,8
 9082f54:	2088b03a 	or	r4,r4,r2
 9082f58:	e0bffc17 	ldw	r2,-16(fp)
 9082f5c:	00c243b4 	movhi	r3,2318
 9082f60:	18e00004 	addi	r3,r3,-32768
 9082f64:	1085883a 	add	r2,r2,r2
 9082f68:	1085883a 	add	r2,r2,r2
 9082f6c:	10c5883a 	add	r2,r2,r3
 9082f70:	10800017 	ldw	r2,0(r2)
 9082f74:	10803fcc 	andi	r2,r2,255
 9082f78:	1004963a 	slli	r2,r2,24
 9082f7c:	2088b03a 	or	r4,r4,r2
 9082f80:	00c243b4 	movhi	r3,2318
 9082f84:	18e00004 	addi	r3,r3,-32768
 9082f88:	2945883a 	add	r2,r5,r5
 9082f8c:	1085883a 	add	r2,r2,r2
 9082f90:	10c5883a 	add	r2,r2,r3
 9082f94:	11000015 	stw	r4,0(r2)
			if( ndata > 255 )
			{
				ndata = 256;
				databuf[0] = 0x43485000 + i;	// 'CHPi'
				ReadDataFifo(i, ndata-1, databuf+1);	// to avoid overflow
				for(j=0; j<ndata; j++)
 9082f98:	e0bffc17 	ldw	r2,-16(fp)
 9082f9c:	10800044 	addi	r2,r2,1
 9082fa0:	e0bffc15 	stw	r2,-16(fp)
 9082fa4:	e0fffe17 	ldw	r3,-8(fp)
 9082fa8:	e0bffc17 	ldw	r2,-16(fp)
 9082fac:	10ffcc16 	blt	r2,r3,9082ee0 <DataFifoReadout+0x17c>
					databuf[j] = htonl(databuf[j]);
				sendto(fd_listen, databuf, ndata*4, 0, &cliaddr, sizeof(cliaddr));
 9082fb0:	d1205d17 	ldw	r4,-32396(gp)
 9082fb4:	014243b4 	movhi	r5,2318
 9082fb8:	29600004 	addi	r5,r5,-32768
 9082fbc:	e0bffe17 	ldw	r2,-8(fp)
 9082fc0:	1085883a 	add	r2,r2,r2
 9082fc4:	1085883a 	add	r2,r2,r2
 9082fc8:	100d883a 	mov	r6,r2
 9082fcc:	00824374 	movhi	r2,2317
 9082fd0:	109d0e04 	addi	r2,r2,29752
 9082fd4:	d8800015 	stw	r2,0(sp)
 9082fd8:	00800404 	movi	r2,16
 9082fdc:	d8800115 	stw	r2,4(sp)
 9082fe0:	000f883a 	mov	r7,zero
 9082fe4:	90ae5e80 	call	90ae5e8 <t_sendto>
	int i, j, ndata;
	INT32U cmd;
//printf("DataFifoReadout() started!\n");

	ReadCommandReg(&cmd);
	for(i=0; i<6; i++)
 9082fe8:	e0bffd17 	ldw	r2,-12(fp)
 9082fec:	10800044 	addi	r2,r2,1
 9082ff0:	e0bffd15 	stw	r2,-12(fp)
 9082ff4:	e0bffd17 	ldw	r2,-12(fp)
 9082ff8:	10800190 	cmplti	r2,r2,6
 9082ffc:	103f611e 	bne	r2,zero,9082d84 <DataFifoReadout+0x20>
				sendto(fd_listen, databuf, ndata*4, 0, &cliaddr, sizeof(cliaddr));
//printf("DataFifoReadout(): sending %d data\n", ndata);
			}
		}
	}
}
 9083000:	e037883a 	mov	sp,fp
 9083004:	dfc00117 	ldw	ra,4(sp)
 9083008:	df000017 	ldw	fp,0(sp)
 908300c:	dec00204 	addi	sp,sp,8
 9083010:	f800283a 	ret

09083014 <fprintf>:
 9083014:	defffc04 	addi	sp,sp,-16
 9083018:	dfc00115 	stw	ra,4(sp)
 908301c:	d9800215 	stw	r6,8(sp)
 9083020:	d9c00315 	stw	r7,12(sp)
 9083024:	d8800204 	addi	r2,sp,8
 9083028:	100d883a 	mov	r6,r2
 908302c:	d8800015 	stw	r2,0(sp)
 9083030:	9085ed40 	call	9085ed4 <__vfprintf_internal>
 9083034:	dfc00117 	ldw	ra,4(sp)
 9083038:	dec00404 	addi	sp,sp,16
 908303c:	f800283a 	ret

09083040 <_fprintf_r>:
 9083040:	defffd04 	addi	sp,sp,-12
 9083044:	2807883a 	mov	r3,r5
 9083048:	dfc00115 	stw	ra,4(sp)
 908304c:	d9c00215 	stw	r7,8(sp)
 9083050:	d8800204 	addi	r2,sp,8
 9083054:	300b883a 	mov	r5,r6
 9083058:	1809883a 	mov	r4,r3
 908305c:	100d883a 	mov	r6,r2
 9083060:	d8800015 	stw	r2,0(sp)
 9083064:	9085ed40 	call	9085ed4 <__vfprintf_internal>
 9083068:	dfc00117 	ldw	ra,4(sp)
 908306c:	dec00304 	addi	sp,sp,12
 9083070:	f800283a 	ret

09083074 <_fwrite_r>:
 9083074:	defff604 	addi	sp,sp,-40
 9083078:	dc400615 	stw	r17,24(sp)
 908307c:	39a3383a 	mul	r17,r7,r6
 9083080:	00800044 	movi	r2,1
 9083084:	dcc00815 	stw	r19,32(sp)
 9083088:	dc800715 	stw	r18,28(sp)
 908308c:	dc000515 	stw	r16,20(sp)
 9083090:	dfc00915 	stw	ra,36(sp)
 9083094:	3825883a 	mov	r18,r7
 9083098:	3027883a 	mov	r19,r6
 908309c:	2021883a 	mov	r16,r4
 90830a0:	d9400015 	stw	r5,0(sp)
 90830a4:	d8800315 	stw	r2,12(sp)
 90830a8:	dc400115 	stw	r17,4(sp)
 90830ac:	dc400415 	stw	r17,16(sp)
 90830b0:	dec00215 	stw	sp,8(sp)
 90830b4:	20000226 	beq	r4,zero,90830c0 <_fwrite_r+0x4c>
 90830b8:	20800e17 	ldw	r2,56(r4)
 90830bc:	10001226 	beq	r2,zero,9083108 <_fwrite_r+0x94>
 90830c0:	d9400a17 	ldw	r5,40(sp)
 90830c4:	8009883a 	mov	r4,r16
 90830c8:	d9800204 	addi	r6,sp,8
 90830cc:	90883c80 	call	90883c8 <__sfvwrite_r>
 90830d0:	980b883a 	mov	r5,r19
 90830d4:	10000426 	beq	r2,zero,90830e8 <_fwrite_r+0x74>
 90830d8:	d9000417 	ldw	r4,16(sp)
 90830dc:	8909c83a 	sub	r4,r17,r4
 90830e0:	908d3080 	call	908d308 <__udivsi3>
 90830e4:	1025883a 	mov	r18,r2
 90830e8:	9005883a 	mov	r2,r18
 90830ec:	dfc00917 	ldw	ra,36(sp)
 90830f0:	dcc00817 	ldw	r19,32(sp)
 90830f4:	dc800717 	ldw	r18,28(sp)
 90830f8:	dc400617 	ldw	r17,24(sp)
 90830fc:	dc000517 	ldw	r16,20(sp)
 9083100:	dec00a04 	addi	sp,sp,40
 9083104:	f800283a 	ret
 9083108:	9087be40 	call	9087be4 <__sinit>
 908310c:	003fec06 	br	90830c0 <_fwrite_r+0x4c>

09083110 <fwrite>:
 9083110:	00824374 	movhi	r2,2317
 9083114:	108e8604 	addi	r2,r2,14872
 9083118:	2017883a 	mov	r11,r4
 908311c:	11000017 	ldw	r4,0(r2)
 9083120:	defffe04 	addi	sp,sp,-8
 9083124:	3013883a 	mov	r9,r6
 9083128:	2805883a 	mov	r2,r5
 908312c:	d9c00015 	stw	r7,0(sp)
 9083130:	580b883a 	mov	r5,r11
 9083134:	100d883a 	mov	r6,r2
 9083138:	480f883a 	mov	r7,r9
 908313c:	dfc00115 	stw	ra,4(sp)
 9083140:	90830740 	call	9083074 <_fwrite_r>
 9083144:	dfc00117 	ldw	ra,4(sp)
 9083148:	dec00204 	addi	sp,sp,8
 908314c:	f800283a 	ret

09083150 <getc>:
 9083150:	defffd04 	addi	sp,sp,-12
 9083154:	dc400115 	stw	r17,4(sp)
 9083158:	04424374 	movhi	r17,2317
 908315c:	8c4e8604 	addi	r17,r17,14872
 9083160:	88c00017 	ldw	r3,0(r17)
 9083164:	dc000015 	stw	r16,0(sp)
 9083168:	dfc00215 	stw	ra,8(sp)
 908316c:	2021883a 	mov	r16,r4
 9083170:	18000326 	beq	r3,zero,9083180 <getc+0x30>
 9083174:	18800e17 	ldw	r2,56(r3)
 9083178:	1809883a 	mov	r4,r3
 908317c:	10000e26 	beq	r2,zero,90831b8 <getc+0x68>
 9083180:	80800117 	ldw	r2,4(r16)
 9083184:	800b883a 	mov	r5,r16
 9083188:	10bfffc4 	addi	r2,r2,-1
 908318c:	80800115 	stw	r2,4(r16)
 9083190:	10000f16 	blt	r2,zero,90831d0 <getc+0x80>
 9083194:	80c00017 	ldw	r3,0(r16)
 9083198:	18800003 	ldbu	r2,0(r3)
 908319c:	18c00044 	addi	r3,r3,1
 90831a0:	80c00015 	stw	r3,0(r16)
 90831a4:	dfc00217 	ldw	ra,8(sp)
 90831a8:	dc400117 	ldw	r17,4(sp)
 90831ac:	dc000017 	ldw	r16,0(sp)
 90831b0:	dec00304 	addi	sp,sp,12
 90831b4:	f800283a 	ret
 90831b8:	9087be40 	call	9087be4 <__sinit>
 90831bc:	80800117 	ldw	r2,4(r16)
 90831c0:	800b883a 	mov	r5,r16
 90831c4:	10bfffc4 	addi	r2,r2,-1
 90831c8:	80800115 	stw	r2,4(r16)
 90831cc:	103ff10e 	bge	r2,zero,9083194 <getc+0x44>
 90831d0:	89000017 	ldw	r4,0(r17)
 90831d4:	dfc00217 	ldw	ra,8(sp)
 90831d8:	dc400117 	ldw	r17,4(sp)
 90831dc:	dc000017 	ldw	r16,0(sp)
 90831e0:	dec00304 	addi	sp,sp,12
 90831e4:	90836cc1 	jmpi	90836cc <__srget_r>

090831e8 <_getc_r>:
 90831e8:	defffd04 	addi	sp,sp,-12
 90831ec:	dc400115 	stw	r17,4(sp)
 90831f0:	dc000015 	stw	r16,0(sp)
 90831f4:	dfc00215 	stw	ra,8(sp)
 90831f8:	2021883a 	mov	r16,r4
 90831fc:	2823883a 	mov	r17,r5
 9083200:	20000226 	beq	r4,zero,908320c <_getc_r+0x24>
 9083204:	20800e17 	ldw	r2,56(r4)
 9083208:	10000f26 	beq	r2,zero,9083248 <_getc_r+0x60>
 908320c:	88800117 	ldw	r2,4(r17)
 9083210:	8009883a 	mov	r4,r16
 9083214:	880b883a 	mov	r5,r17
 9083218:	10bfffc4 	addi	r2,r2,-1
 908321c:	88800115 	stw	r2,4(r17)
 9083220:	10001016 	blt	r2,zero,9083264 <_getc_r+0x7c>
 9083224:	88c00017 	ldw	r3,0(r17)
 9083228:	18800003 	ldbu	r2,0(r3)
 908322c:	18c00044 	addi	r3,r3,1
 9083230:	88c00015 	stw	r3,0(r17)
 9083234:	dfc00217 	ldw	ra,8(sp)
 9083238:	dc400117 	ldw	r17,4(sp)
 908323c:	dc000017 	ldw	r16,0(sp)
 9083240:	dec00304 	addi	sp,sp,12
 9083244:	f800283a 	ret
 9083248:	9087be40 	call	9087be4 <__sinit>
 908324c:	88800117 	ldw	r2,4(r17)
 9083250:	8009883a 	mov	r4,r16
 9083254:	880b883a 	mov	r5,r17
 9083258:	10bfffc4 	addi	r2,r2,-1
 908325c:	88800115 	stw	r2,4(r17)
 9083260:	103ff00e 	bge	r2,zero,9083224 <_getc_r+0x3c>
 9083264:	dfc00217 	ldw	ra,8(sp)
 9083268:	dc400117 	ldw	r17,4(sp)
 908326c:	dc000017 	ldw	r16,0(sp)
 9083270:	dec00304 	addi	sp,sp,12
 9083274:	90836cc1 	jmpi	90836cc <__srget_r>

09083278 <memset>:
 9083278:	008000c4 	movi	r2,3
 908327c:	29403fcc 	andi	r5,r5,255
 9083280:	2007883a 	mov	r3,r4
 9083284:	1180022e 	bgeu	r2,r6,9083290 <memset+0x18>
 9083288:	2084703a 	and	r2,r4,r2
 908328c:	10000826 	beq	r2,zero,90832b0 <memset+0x38>
 9083290:	30000526 	beq	r6,zero,90832a8 <memset+0x30>
 9083294:	2805883a 	mov	r2,r5
 9083298:	30cd883a 	add	r6,r6,r3
 908329c:	18800005 	stb	r2,0(r3)
 90832a0:	18c00044 	addi	r3,r3,1
 90832a4:	19bffd1e 	bne	r3,r6,908329c <memset+0x24>
 90832a8:	2005883a 	mov	r2,r4
 90832ac:	f800283a 	ret
 90832b0:	2804923a 	slli	r2,r5,8
 90832b4:	020003c4 	movi	r8,15
 90832b8:	200f883a 	mov	r7,r4
 90832bc:	2884b03a 	or	r2,r5,r2
 90832c0:	1006943a 	slli	r3,r2,16
 90832c4:	10c6b03a 	or	r3,r2,r3
 90832c8:	41800a2e 	bgeu	r8,r6,90832f4 <memset+0x7c>
 90832cc:	4005883a 	mov	r2,r8
 90832d0:	31bffc04 	addi	r6,r6,-16
 90832d4:	38c00015 	stw	r3,0(r7)
 90832d8:	38c00115 	stw	r3,4(r7)
 90832dc:	38c00215 	stw	r3,8(r7)
 90832e0:	38c00315 	stw	r3,12(r7)
 90832e4:	39c00404 	addi	r7,r7,16
 90832e8:	11bff936 	bltu	r2,r6,90832d0 <memset+0x58>
 90832ec:	008000c4 	movi	r2,3
 90832f0:	1180052e 	bgeu	r2,r6,9083308 <memset+0x90>
 90832f4:	31bfff04 	addi	r6,r6,-4
 90832f8:	008000c4 	movi	r2,3
 90832fc:	38c00015 	stw	r3,0(r7)
 9083300:	39c00104 	addi	r7,r7,4
 9083304:	11bffb36 	bltu	r2,r6,90832f4 <memset+0x7c>
 9083308:	3807883a 	mov	r3,r7
 908330c:	003fe006 	br	9083290 <memset+0x18>

09083310 <_perror_r>:
 9083310:	defffe04 	addi	sp,sp,-8
 9083314:	dc000015 	stw	r16,0(sp)
 9083318:	dfc00115 	stw	ra,4(sp)
 908331c:	2021883a 	mov	r16,r4
 9083320:	28000326 	beq	r5,zero,9083330 <_perror_r+0x20>
 9083324:	28800007 	ldb	r2,0(r5)
 9083328:	2809883a 	mov	r4,r5
 908332c:	10000c1e 	bne	r2,zero,9083360 <_perror_r+0x50>
 9083330:	81000017 	ldw	r4,0(r16)
 9083334:	90838e00 	call	90838e0 <strerror>
 9083338:	1009883a 	mov	r4,r2
 908333c:	10000226 	beq	r2,zero,9083348 <_perror_r+0x38>
 9083340:	81400317 	ldw	r5,12(r16)
 9083344:	9087f6c0 	call	9087f6c <fputs>
 9083348:	81400317 	ldw	r5,12(r16)
 908334c:	01000284 	movi	r4,10
 9083350:	dfc00117 	ldw	ra,4(sp)
 9083354:	dc000017 	ldw	r16,0(sp)
 9083358:	dec00204 	addi	sp,sp,8
 908335c:	9087e3c1 	jmpi	9087e3c <fputc>
 9083360:	81400317 	ldw	r5,12(r16)
 9083364:	9087f6c0 	call	9087f6c <fputs>
 9083368:	81400317 	ldw	r5,12(r16)
 908336c:	01024374 	movhi	r4,2317
 9083370:	21335f04 	addi	r4,r4,-12932
 9083374:	9087f6c0 	call	9087f6c <fputs>
 9083378:	003fed06 	br	9083330 <_perror_r+0x20>

0908337c <perror>:
 908337c:	00824374 	movhi	r2,2317
 9083380:	108e8604 	addi	r2,r2,14872
 9083384:	200b883a 	mov	r5,r4
 9083388:	11000017 	ldw	r4,0(r2)
 908338c:	90833101 	jmpi	9083310 <_perror_r>

09083390 <printf>:
 9083390:	defffb04 	addi	sp,sp,-20
 9083394:	dfc00115 	stw	ra,4(sp)
 9083398:	d9400215 	stw	r5,8(sp)
 908339c:	d9800315 	stw	r6,12(sp)
 90833a0:	d9c00415 	stw	r7,16(sp)
 90833a4:	00824374 	movhi	r2,2317
 90833a8:	108e8604 	addi	r2,r2,14872
 90833ac:	10c00017 	ldw	r3,0(r2)
 90833b0:	200b883a 	mov	r5,r4
 90833b4:	d8800204 	addi	r2,sp,8
 90833b8:	19000217 	ldw	r4,8(r3)
 90833bc:	100d883a 	mov	r6,r2
 90833c0:	d8800015 	stw	r2,0(sp)
 90833c4:	9085ed40 	call	9085ed4 <__vfprintf_internal>
 90833c8:	dfc00117 	ldw	ra,4(sp)
 90833cc:	dec00504 	addi	sp,sp,20
 90833d0:	f800283a 	ret

090833d4 <_printf_r>:
 90833d4:	defffc04 	addi	sp,sp,-16
 90833d8:	dfc00115 	stw	ra,4(sp)
 90833dc:	d9800215 	stw	r6,8(sp)
 90833e0:	d9c00315 	stw	r7,12(sp)
 90833e4:	280d883a 	mov	r6,r5
 90833e8:	21400217 	ldw	r5,8(r4)
 90833ec:	d8c00204 	addi	r3,sp,8
 90833f0:	180f883a 	mov	r7,r3
 90833f4:	d8c00015 	stw	r3,0(sp)
 90833f8:	90840280 	call	9084028 <___vfprintf_internal_r>
 90833fc:	dfc00117 	ldw	ra,4(sp)
 9083400:	dec00404 	addi	sp,sp,16
 9083404:	f800283a 	ret

09083408 <putc>:
 9083408:	defffc04 	addi	sp,sp,-16
 908340c:	dc800215 	stw	r18,8(sp)
 9083410:	04824374 	movhi	r18,2317
 9083414:	948e8604 	addi	r18,r18,14872
 9083418:	90c00017 	ldw	r3,0(r18)
 908341c:	dc400115 	stw	r17,4(sp)
 9083420:	dc000015 	stw	r16,0(sp)
 9083424:	dfc00315 	stw	ra,12(sp)
 9083428:	2023883a 	mov	r17,r4
 908342c:	2821883a 	mov	r16,r5
 9083430:	18000226 	beq	r3,zero,908343c <putc+0x34>
 9083434:	18800e17 	ldw	r2,56(r3)
 9083438:	10001126 	beq	r2,zero,9083480 <putc+0x78>
 908343c:	80800217 	ldw	r2,8(r16)
 9083440:	10ffffc4 	addi	r3,r2,-1
 9083444:	80c00215 	stw	r3,8(r16)
 9083448:	18001316 	blt	r3,zero,9083498 <putc+0x90>
 908344c:	80800017 	ldw	r2,0(r16)
 9083450:	14400005 	stb	r17,0(r2)
 9083454:	80c00017 	ldw	r3,0(r16)
 9083458:	18800044 	addi	r2,r3,1
 908345c:	18c00003 	ldbu	r3,0(r3)
 9083460:	80800015 	stw	r2,0(r16)
 9083464:	1805883a 	mov	r2,r3
 9083468:	dfc00317 	ldw	ra,12(sp)
 908346c:	dc800217 	ldw	r18,8(sp)
 9083470:	dc400117 	ldw	r17,4(sp)
 9083474:	dc000017 	ldw	r16,0(sp)
 9083478:	dec00404 	addi	sp,sp,16
 908347c:	f800283a 	ret
 9083480:	1809883a 	mov	r4,r3
 9083484:	9087be40 	call	9087be4 <__sinit>
 9083488:	80800217 	ldw	r2,8(r16)
 908348c:	10ffffc4 	addi	r3,r2,-1
 9083490:	80c00215 	stw	r3,8(r16)
 9083494:	183fed0e 	bge	r3,zero,908344c <putc+0x44>
 9083498:	80800617 	ldw	r2,24(r16)
 908349c:	18800f16 	blt	r3,r2,90834dc <putc+0xd4>
 90834a0:	80800017 	ldw	r2,0(r16)
 90834a4:	14400005 	stb	r17,0(r2)
 90834a8:	81000017 	ldw	r4,0(r16)
 90834ac:	00800284 	movi	r2,10
 90834b0:	20c00003 	ldbu	r3,0(r4)
 90834b4:	18801226 	beq	r3,r2,9083500 <putc+0xf8>
 90834b8:	20800044 	addi	r2,r4,1
 90834bc:	80800015 	stw	r2,0(r16)
 90834c0:	1805883a 	mov	r2,r3
 90834c4:	dfc00317 	ldw	ra,12(sp)
 90834c8:	dc800217 	ldw	r18,8(sp)
 90834cc:	dc400117 	ldw	r17,4(sp)
 90834d0:	dc000017 	ldw	r16,0(sp)
 90834d4:	dec00404 	addi	sp,sp,16
 90834d8:	f800283a 	ret
 90834dc:	91000017 	ldw	r4,0(r18)
 90834e0:	880b883a 	mov	r5,r17
 90834e4:	800d883a 	mov	r6,r16
 90834e8:	dfc00317 	ldw	ra,12(sp)
 90834ec:	dc800217 	ldw	r18,8(sp)
 90834f0:	dc400117 	ldw	r17,4(sp)
 90834f4:	dc000017 	ldw	r16,0(sp)
 90834f8:	dec00404 	addi	sp,sp,16
 90834fc:	9085ef81 	jmpi	9085ef8 <__swbuf_r>
 9083500:	91000017 	ldw	r4,0(r18)
 9083504:	180b883a 	mov	r5,r3
 9083508:	003ff606 	br	90834e4 <putc+0xdc>

0908350c <_putc_r>:
 908350c:	defffc04 	addi	sp,sp,-16
 9083510:	dc400215 	stw	r17,8(sp)
 9083514:	dc000115 	stw	r16,4(sp)
 9083518:	dfc00315 	stw	ra,12(sp)
 908351c:	2021883a 	mov	r16,r4
 9083520:	2823883a 	mov	r17,r5
 9083524:	20000226 	beq	r4,zero,9083530 <_putc_r+0x24>
 9083528:	20800e17 	ldw	r2,56(r4)
 908352c:	10001026 	beq	r2,zero,9083570 <_putc_r+0x64>
 9083530:	30800217 	ldw	r2,8(r6)
 9083534:	10ffffc4 	addi	r3,r2,-1
 9083538:	30c00215 	stw	r3,8(r6)
 908353c:	18001316 	blt	r3,zero,908358c <_putc_r+0x80>
 9083540:	30800017 	ldw	r2,0(r6)
 9083544:	14400005 	stb	r17,0(r2)
 9083548:	30c00017 	ldw	r3,0(r6)
 908354c:	18800044 	addi	r2,r3,1
 9083550:	18c00003 	ldbu	r3,0(r3)
 9083554:	30800015 	stw	r2,0(r6)
 9083558:	1805883a 	mov	r2,r3
 908355c:	dfc00317 	ldw	ra,12(sp)
 9083560:	dc400217 	ldw	r17,8(sp)
 9083564:	dc000117 	ldw	r16,4(sp)
 9083568:	dec00404 	addi	sp,sp,16
 908356c:	f800283a 	ret
 9083570:	d9800015 	stw	r6,0(sp)
 9083574:	9087be40 	call	9087be4 <__sinit>
 9083578:	d9800017 	ldw	r6,0(sp)
 908357c:	30800217 	ldw	r2,8(r6)
 9083580:	10ffffc4 	addi	r3,r2,-1
 9083584:	30c00215 	stw	r3,8(r6)
 9083588:	183fed0e 	bge	r3,zero,9083540 <_putc_r+0x34>
 908358c:	30800617 	ldw	r2,24(r6)
 9083590:	18800e16 	blt	r3,r2,90835cc <_putc_r+0xc0>
 9083594:	30800017 	ldw	r2,0(r6)
 9083598:	14400005 	stb	r17,0(r2)
 908359c:	31000017 	ldw	r4,0(r6)
 90835a0:	00800284 	movi	r2,10
 90835a4:	20c00003 	ldbu	r3,0(r4)
 90835a8:	18800f26 	beq	r3,r2,90835e8 <_putc_r+0xdc>
 90835ac:	20800044 	addi	r2,r4,1
 90835b0:	30800015 	stw	r2,0(r6)
 90835b4:	1805883a 	mov	r2,r3
 90835b8:	dfc00317 	ldw	ra,12(sp)
 90835bc:	dc400217 	ldw	r17,8(sp)
 90835c0:	dc000117 	ldw	r16,4(sp)
 90835c4:	dec00404 	addi	sp,sp,16
 90835c8:	f800283a 	ret
 90835cc:	8009883a 	mov	r4,r16
 90835d0:	880b883a 	mov	r5,r17
 90835d4:	dfc00317 	ldw	ra,12(sp)
 90835d8:	dc400217 	ldw	r17,8(sp)
 90835dc:	dc000117 	ldw	r16,4(sp)
 90835e0:	dec00404 	addi	sp,sp,16
 90835e4:	9085ef81 	jmpi	9085ef8 <__swbuf_r>
 90835e8:	8009883a 	mov	r4,r16
 90835ec:	180b883a 	mov	r5,r3
 90835f0:	003ff806 	br	90835d4 <_putc_r+0xc8>

090835f4 <putchar>:
 90835f4:	00824374 	movhi	r2,2317
 90835f8:	108e8604 	addi	r2,r2,14872
 90835fc:	11800017 	ldw	r6,0(r2)
 9083600:	200b883a 	mov	r5,r4
 9083604:	3009883a 	mov	r4,r6
 9083608:	31800217 	ldw	r6,8(r6)
 908360c:	908350c1 	jmpi	908350c <_putc_r>

09083610 <_putchar_r>:
 9083610:	21800217 	ldw	r6,8(r4)
 9083614:	908350c1 	jmpi	908350c <_putc_r>

09083618 <_puts_r>:
 9083618:	defff604 	addi	sp,sp,-40
 908361c:	dc400715 	stw	r17,28(sp)
 9083620:	2023883a 	mov	r17,r4
 9083624:	2809883a 	mov	r4,r5
 9083628:	dfc00915 	stw	ra,36(sp)
 908362c:	dcc00815 	stw	r19,32(sp)
 9083630:	2827883a 	mov	r19,r5
 9083634:	9083f540 	call	9083f54 <strlen>
 9083638:	89400217 	ldw	r5,8(r17)
 908363c:	00c24374 	movhi	r3,2317
 9083640:	18f36004 	addi	r3,r3,-12928
 9083644:	01c00044 	movi	r7,1
 9083648:	12000044 	addi	r8,r2,1
 908364c:	d8c00515 	stw	r3,20(sp)
 9083650:	d9c00615 	stw	r7,24(sp)
 9083654:	d8c00304 	addi	r3,sp,12
 9083658:	01c00084 	movi	r7,2
 908365c:	8809883a 	mov	r4,r17
 9083660:	d80d883a 	mov	r6,sp
 9083664:	d8c00015 	stw	r3,0(sp)
 9083668:	dcc00315 	stw	r19,12(sp)
 908366c:	da000215 	stw	r8,8(sp)
 9083670:	d9c00115 	stw	r7,4(sp)
 9083674:	d8800415 	stw	r2,16(sp)
 9083678:	90883c80 	call	90883c8 <__sfvwrite_r>
 908367c:	00ffffc4 	movi	r3,-1
 9083680:	10000626 	beq	r2,zero,908369c <_puts_r+0x84>
 9083684:	1805883a 	mov	r2,r3
 9083688:	dfc00917 	ldw	ra,36(sp)
 908368c:	dcc00817 	ldw	r19,32(sp)
 9083690:	dc400717 	ldw	r17,28(sp)
 9083694:	dec00a04 	addi	sp,sp,40
 9083698:	f800283a 	ret
 908369c:	00c00284 	movi	r3,10
 90836a0:	1805883a 	mov	r2,r3
 90836a4:	dfc00917 	ldw	ra,36(sp)
 90836a8:	dcc00817 	ldw	r19,32(sp)
 90836ac:	dc400717 	ldw	r17,28(sp)
 90836b0:	dec00a04 	addi	sp,sp,40
 90836b4:	f800283a 	ret

090836b8 <puts>:
 90836b8:	00824374 	movhi	r2,2317
 90836bc:	108e8604 	addi	r2,r2,14872
 90836c0:	200b883a 	mov	r5,r4
 90836c4:	11000017 	ldw	r4,0(r2)
 90836c8:	90836181 	jmpi	9083618 <_puts_r>

090836cc <__srget_r>:
 90836cc:	defffe04 	addi	sp,sp,-8
 90836d0:	dc000015 	stw	r16,0(sp)
 90836d4:	dfc00115 	stw	ra,4(sp)
 90836d8:	2821883a 	mov	r16,r5
 90836dc:	908abc80 	call	908abc8 <__srefill_r>
 90836e0:	013fffc4 	movi	r4,-1
 90836e4:	1000071e 	bne	r2,zero,9083704 <__srget_r+0x38>
 90836e8:	80800117 	ldw	r2,4(r16)
 90836ec:	81000017 	ldw	r4,0(r16)
 90836f0:	10bfffc4 	addi	r2,r2,-1
 90836f4:	20c00044 	addi	r3,r4,1
 90836f8:	80800115 	stw	r2,4(r16)
 90836fc:	21000003 	ldbu	r4,0(r4)
 9083700:	80c00015 	stw	r3,0(r16)
 9083704:	2005883a 	mov	r2,r4
 9083708:	dfc00117 	ldw	ra,4(sp)
 908370c:	dc000017 	ldw	r16,0(sp)
 9083710:	dec00204 	addi	sp,sp,8
 9083714:	f800283a 	ret

09083718 <__srget>:
 9083718:	00824374 	movhi	r2,2317
 908371c:	108e8604 	addi	r2,r2,14872
 9083720:	200b883a 	mov	r5,r4
 9083724:	11000017 	ldw	r4,0(r2)
 9083728:	90836cc1 	jmpi	90836cc <__srget_r>

0908372c <sprintf>:
 908372c:	deffe504 	addi	sp,sp,-108
 9083730:	2013883a 	mov	r9,r4
 9083734:	dfc01815 	stw	ra,96(sp)
 9083738:	d9801915 	stw	r6,100(sp)
 908373c:	d9c01a15 	stw	r7,104(sp)
 9083740:	d8801904 	addi	r2,sp,100
 9083744:	d8800015 	stw	r2,0(sp)
 9083748:	00824374 	movhi	r2,2317
 908374c:	108e8604 	addi	r2,r2,14872
 9083750:	11000017 	ldw	r4,0(r2)
 9083754:	d9c00017 	ldw	r7,0(sp)
 9083758:	00808204 	movi	r2,520
 908375c:	00e00034 	movhi	r3,32768
 9083760:	18ffffc4 	addi	r3,r3,-1
 9083764:	280d883a 	mov	r6,r5
 9083768:	d880040d 	sth	r2,16(sp)
 908376c:	d9400104 	addi	r5,sp,4
 9083770:	00bfffc4 	movi	r2,-1
 9083774:	d8c00615 	stw	r3,24(sp)
 9083778:	d8c00315 	stw	r3,12(sp)
 908377c:	da400515 	stw	r9,20(sp)
 9083780:	d880048d 	sth	r2,18(sp)
 9083784:	da400115 	stw	r9,4(sp)
 9083788:	90840280 	call	9084028 <___vfprintf_internal_r>
 908378c:	d8c00117 	ldw	r3,4(sp)
 9083790:	18000005 	stb	zero,0(r3)
 9083794:	dfc01817 	ldw	ra,96(sp)
 9083798:	dec01b04 	addi	sp,sp,108
 908379c:	f800283a 	ret

090837a0 <_sprintf_r>:
 90837a0:	deffe604 	addi	sp,sp,-104
 90837a4:	2813883a 	mov	r9,r5
 90837a8:	dfc01815 	stw	ra,96(sp)
 90837ac:	d9c01915 	stw	r7,100(sp)
 90837b0:	d8801904 	addi	r2,sp,100
 90837b4:	d8800015 	stw	r2,0(sp)
 90837b8:	100f883a 	mov	r7,r2
 90837bc:	00808204 	movi	r2,520
 90837c0:	00e00034 	movhi	r3,32768
 90837c4:	18ffffc4 	addi	r3,r3,-1
 90837c8:	d880040d 	sth	r2,16(sp)
 90837cc:	d9400104 	addi	r5,sp,4
 90837d0:	00bfffc4 	movi	r2,-1
 90837d4:	d8c00615 	stw	r3,24(sp)
 90837d8:	d8c00315 	stw	r3,12(sp)
 90837dc:	da400515 	stw	r9,20(sp)
 90837e0:	d880048d 	sth	r2,18(sp)
 90837e4:	da400115 	stw	r9,4(sp)
 90837e8:	90840280 	call	9084028 <___vfprintf_internal_r>
 90837ec:	d8c00117 	ldw	r3,4(sp)
 90837f0:	18000005 	stb	zero,0(r3)
 90837f4:	dfc01817 	ldw	ra,96(sp)
 90837f8:	dec01a04 	addi	sp,sp,104
 90837fc:	f800283a 	ret

09083800 <strchr>:
 9083800:	208000cc 	andi	r2,r4,3
 9083804:	2007883a 	mov	r3,r4
 9083808:	1000311e 	bne	r2,zero,90838d0 <strchr+0xd0>
 908380c:	29c03fcc 	andi	r7,r5,255
 9083810:	0015883a 	mov	r10,zero
 9083814:	0007883a 	mov	r3,zero
 9083818:	01400104 	movi	r5,4
 908381c:	5004923a 	slli	r2,r10,8
 9083820:	18c00044 	addi	r3,r3,1
 9083824:	3894b03a 	or	r10,r7,r2
 9083828:	197ffc1e 	bne	r3,r5,908381c <strchr+0x1c>
 908382c:	200d883a 	mov	r6,r4
 9083830:	21000017 	ldw	r4,0(r4)
 9083834:	017fbff4 	movhi	r5,65279
 9083838:	297fbfc4 	addi	r5,r5,-257
 908383c:	02202074 	movhi	r8,32897
 9083840:	42202004 	addi	r8,r8,-32640
 9083844:	2145883a 	add	r2,r4,r5
 9083848:	1204703a 	and	r2,r2,r8
 908384c:	0106303a 	nor	r3,zero,r4
 9083850:	10c4703a 	and	r2,r2,r3
 9083854:	1000151e 	bne	r2,zero,90838ac <strchr+0xac>
 9083858:	2284f03a 	xor	r2,r4,r10
 908385c:	1147883a 	add	r3,r2,r5
 9083860:	1a06703a 	and	r3,r3,r8
 9083864:	0084303a 	nor	r2,zero,r2
 9083868:	10c4703a 	and	r2,r2,r3
 908386c:	10000f1e 	bne	r2,zero,90838ac <strchr+0xac>
 9083870:	2813883a 	mov	r9,r5
 9083874:	00000106 	br	908387c <strchr+0x7c>
 9083878:	18000c1e 	bne	r3,zero,90838ac <strchr+0xac>
 908387c:	31800104 	addi	r6,r6,4
 9083880:	30800017 	ldw	r2,0(r6)
 9083884:	1286f03a 	xor	r3,r2,r10
 9083888:	124b883a 	add	r5,r2,r9
 908388c:	1a49883a 	add	r4,r3,r9
 9083890:	2a0a703a 	and	r5,r5,r8
 9083894:	0084303a 	nor	r2,zero,r2
 9083898:	2208703a 	and	r4,r4,r8
 908389c:	00c6303a 	nor	r3,zero,r3
 90838a0:	1144703a 	and	r2,r2,r5
 90838a4:	1906703a 	and	r3,r3,r4
 90838a8:	103ff326 	beq	r2,zero,9083878 <strchr+0x78>
 90838ac:	3007883a 	mov	r3,r6
 90838b0:	00000206 	br	90838bc <strchr+0xbc>
 90838b4:	38800426 	beq	r7,r2,90838c8 <strchr+0xc8>
 90838b8:	18c00044 	addi	r3,r3,1
 90838bc:	18800003 	ldbu	r2,0(r3)
 90838c0:	103ffc1e 	bne	r2,zero,90838b4 <strchr+0xb4>
 90838c4:	3800041e 	bne	r7,zero,90838d8 <strchr+0xd8>
 90838c8:	1805883a 	mov	r2,r3
 90838cc:	f800283a 	ret
 90838d0:	29c03fcc 	andi	r7,r5,255
 90838d4:	003ff906 	br	90838bc <strchr+0xbc>
 90838d8:	0005883a 	mov	r2,zero
 90838dc:	f800283a 	ret

090838e0 <strerror>:
 90838e0:	deffff04 	addi	sp,sp,-4
 90838e4:	00802184 	movi	r2,134
 90838e8:	dfc00015 	stw	ra,0(sp)
 90838ec:	200b883a 	mov	r5,r4
 90838f0:	11008e36 	bltu	r2,r4,9083b2c <strerror+0x24c>
 90838f4:	2105883a 	add	r2,r4,r4
 90838f8:	1085883a 	add	r2,r2,r2
 90838fc:	00c24234 	movhi	r3,2312
 9083900:	18ce4404 	addi	r3,r3,14608
 9083904:	10c5883a 	add	r2,r2,r3
 9083908:	11000017 	ldw	r4,0(r2)
 908390c:	2000683a 	jmp	r4
 9083910:	09083b2c 	andhi	r4,at,8428
 9083914:	09083b64 	muli	r4,at,8429
 9083918:	09083b70 	cmpltui	r4,at,8429
 908391c:	09083b7c 	xorhi	r4,at,8429
 9083920:	09083b88 	cmpgei	r4,at,8430
 9083924:	09083b94 	ori	r4,at,8430
 9083928:	09083ba0 	cmpeqi	r4,at,8430
 908392c:	09083bac 	andhi	r4,at,8430
 9083930:	09083bb8 	rdprs	r4,at,8430
 9083934:	09083bc4 	addi	r4,at,8431
 9083938:	09083bd0 	cmplti	r4,at,8431
 908393c:	09083bdc 	xori	r4,at,8431
 9083940:	09083be8 	cmpgeui	r4,at,8431
 9083944:	09083bf4 	orhi	r4,at,8431
 9083948:	09083c00 	call	9083c0 <OSCtxSw_SWITCH_PC+0x908380>
 908394c:	09083c0c 	andi	r4,at,8432
 9083950:	09083c18 	cmpnei	r4,at,8432
 9083954:	09083c24 	muli	r4,at,8432
 9083958:	09083c30 	cmpltui	r4,at,8432
 908395c:	09083c3c 	xorhi	r4,at,8432
 9083960:	09083c48 	cmpgei	r4,at,8433
 9083964:	09083c54 	ori	r4,at,8433
 9083968:	09083c60 	cmpeqi	r4,at,8433
 908396c:	09083c6c 	andhi	r4,at,8433
 9083970:	09083c78 	rdprs	r4,at,8433
 9083974:	09083c84 	addi	r4,at,8434
 9083978:	09083c90 	cmplti	r4,at,8434
 908397c:	09083c9c 	xori	r4,at,8434
 9083980:	09083ca8 	cmpgeui	r4,at,8434
 9083984:	09083cb4 	orhi	r4,at,8434
 9083988:	09083cc0 	call	9083cc <OSCtxSw_SWITCH_PC+0x90838c>
 908398c:	09083ccc 	andi	r4,at,8435
 9083990:	09083cd8 	cmpnei	r4,at,8435
 9083994:	09083ce4 	muli	r4,at,8435
 9083998:	09083cf0 	cmpltui	r4,at,8435
 908399c:	09083cfc 	xorhi	r4,at,8435
 90839a0:	09083d08 	cmpgei	r4,at,8436
 90839a4:	09083b2c 	andhi	r4,at,8428
 90839a8:	09083b2c 	andhi	r4,at,8428
 90839ac:	09083b2c 	andhi	r4,at,8428
 90839b0:	09083b2c 	andhi	r4,at,8428
 90839b4:	09083b2c 	andhi	r4,at,8428
 90839b8:	09083b2c 	andhi	r4,at,8428
 90839bc:	09083b2c 	andhi	r4,at,8428
 90839c0:	09083b2c 	andhi	r4,at,8428
 90839c4:	09083d14 	ori	r4,at,8436
 90839c8:	09083d20 	cmpeqi	r4,at,8436
 90839cc:	09083b2c 	andhi	r4,at,8428
 90839d0:	09083b2c 	andhi	r4,at,8428
 90839d4:	09083b2c 	andhi	r4,at,8428
 90839d8:	09083b2c 	andhi	r4,at,8428
 90839dc:	09083b2c 	andhi	r4,at,8428
 90839e0:	09083b2c 	andhi	r4,at,8428
 90839e4:	09083b2c 	andhi	r4,at,8428
 90839e8:	09083b2c 	andhi	r4,at,8428
 90839ec:	09083b2c 	andhi	r4,at,8428
 90839f0:	09083b2c 	andhi	r4,at,8428
 90839f4:	09083b2c 	andhi	r4,at,8428
 90839f8:	09083b2c 	andhi	r4,at,8428
 90839fc:	09083b2c 	andhi	r4,at,8428
 9083a00:	09083d2c 	andhi	r4,at,8436
 9083a04:	09083b2c 	andhi	r4,at,8428
 9083a08:	09083d38 	rdprs	r4,at,8436
 9083a0c:	09083d44 	addi	r4,at,8437
 9083a10:	09083d50 	cmplti	r4,at,8437
 9083a14:	09083d5c 	xori	r4,at,8437
 9083a18:	09083d68 	cmpgeui	r4,at,8437
 9083a1c:	09083d74 	orhi	r4,at,8437
 9083a20:	09083d80 	call	9083d8 <OSCtxSw_SWITCH_PC+0x908398>
 9083a24:	09083d8c 	andi	r4,at,8438
 9083a28:	09083d98 	cmpnei	r4,at,8438
 9083a2c:	09083da4 	muli	r4,at,8438
 9083a30:	09083b2c 	andhi	r4,at,8428
 9083a34:	09083b2c 	andhi	r4,at,8428
 9083a38:	09083db0 	cmpltui	r4,at,8438
 9083a3c:	09083b2c 	andhi	r4,at,8428
 9083a40:	09083b2c 	andhi	r4,at,8428
 9083a44:	09083dbc 	xorhi	r4,at,8438
 9083a48:	09083b2c 	andhi	r4,at,8428
 9083a4c:	09083b2c 	andhi	r4,at,8428
 9083a50:	09083b2c 	andhi	r4,at,8428
 9083a54:	09083b2c 	andhi	r4,at,8428
 9083a58:	09083b2c 	andhi	r4,at,8428
 9083a5c:	09083dc8 	cmpgei	r4,at,8439
 9083a60:	09083dd4 	ori	r4,at,8439
 9083a64:	09083de0 	cmpeqi	r4,at,8439
 9083a68:	09083dec 	andhi	r4,at,8439
 9083a6c:	09083df8 	rdprs	r4,at,8439
 9083a70:	09083e04 	addi	r4,at,8440
 9083a74:	09083e10 	cmplti	r4,at,8440
 9083a78:	09083e1c 	xori	r4,at,8440
 9083a7c:	09083e28 	cmpgeui	r4,at,8440
 9083a80:	09083e34 	orhi	r4,at,8440
 9083a84:	09083b2c 	andhi	r4,at,8428
 9083a88:	09083b2c 	andhi	r4,at,8428
 9083a8c:	09083e40 	call	9083e4 <OSCtxSw_SWITCH_PC+0x9083a4>
 9083a90:	09083b2c 	andhi	r4,at,8428
 9083a94:	09083b2c 	andhi	r4,at,8428
 9083a98:	09083b2c 	andhi	r4,at,8428
 9083a9c:	09083b2c 	andhi	r4,at,8428
 9083aa0:	09083b2c 	andhi	r4,at,8428
 9083aa4:	09083b2c 	andhi	r4,at,8428
 9083aa8:	09083b2c 	andhi	r4,at,8428
 9083aac:	09083b2c 	andhi	r4,at,8428
 9083ab0:	09083b2c 	andhi	r4,at,8428
 9083ab4:	09083e4c 	andi	r4,at,8441
 9083ab8:	09083e58 	cmpnei	r4,at,8441
 9083abc:	09083e64 	muli	r4,at,8441
 9083ac0:	09083e70 	cmpltui	r4,at,8441
 9083ac4:	09083e7c 	xorhi	r4,at,8441
 9083ac8:	09083e88 	cmpgei	r4,at,8442
 9083acc:	09083e94 	ori	r4,at,8442
 9083ad0:	09083ea0 	cmpeqi	r4,at,8442
 9083ad4:	09083eac 	andhi	r4,at,8442
 9083ad8:	09083eb8 	rdprs	r4,at,8442
 9083adc:	09083ec4 	addi	r4,at,8443
 9083ae0:	09083ed0 	cmplti	r4,at,8443
 9083ae4:	09083edc 	xori	r4,at,8443
 9083ae8:	09083ee8 	cmpgeui	r4,at,8443
 9083aec:	09083ef4 	orhi	r4,at,8443
 9083af0:	09083f00 	call	9083f0 <OSCtxSw_SWITCH_PC+0x9083b0>
 9083af4:	09083f0c 	andi	r4,at,8444
 9083af8:	09083f18 	cmpnei	r4,at,8444
 9083afc:	09083f24 	muli	r4,at,8444
 9083b00:	09083f30 	cmpltui	r4,at,8444
 9083b04:	09083b2c 	andhi	r4,at,8428
 9083b08:	09083b2c 	andhi	r4,at,8428
 9083b0c:	09083f3c 	xorhi	r4,at,8444
 9083b10:	09083f48 	cmpgei	r4,at,8445
 9083b14:	09083b2c 	andhi	r4,at,8428
 9083b18:	09083b2c 	andhi	r4,at,8428
 9083b1c:	09083b2c 	andhi	r4,at,8428
 9083b20:	09083b2c 	andhi	r4,at,8428
 9083b24:	09083b2c 	andhi	r4,at,8428
 9083b28:	09083b58 	cmpnei	r4,at,8429
 9083b2c:	2809883a 	mov	r4,r5
 9083b30:	9083fc80 	call	9083fc8 <_user_strerror>
 9083b34:	10000326 	beq	r2,zero,9083b44 <strerror+0x264>
 9083b38:	dfc00017 	ldw	ra,0(sp)
 9083b3c:	dec00104 	addi	sp,sp,4
 9083b40:	f800283a 	ret
 9083b44:	00824374 	movhi	r2,2317
 9083b48:	10b55904 	addi	r2,r2,-10908
 9083b4c:	dfc00017 	ldw	ra,0(sp)
 9083b50:	dec00104 	addi	sp,sp,4
 9083b54:	f800283a 	ret
 9083b58:	00824374 	movhi	r2,2317
 9083b5c:	10b41c04 	addi	r2,r2,-12176
 9083b60:	003ff506 	br	9083b38 <strerror+0x258>
 9083b64:	00824374 	movhi	r2,2317
 9083b68:	10b36c04 	addi	r2,r2,-12880
 9083b6c:	003ff206 	br	9083b38 <strerror+0x258>
 9083b70:	00824374 	movhi	r2,2317
 9083b74:	10b36f04 	addi	r2,r2,-12868
 9083b78:	003fef06 	br	9083b38 <strerror+0x258>
 9083b7c:	00824374 	movhi	r2,2317
 9083b80:	10b37604 	addi	r2,r2,-12840
 9083b84:	003fec06 	br	9083b38 <strerror+0x258>
 9083b88:	00824374 	movhi	r2,2317
 9083b8c:	10b37a04 	addi	r2,r2,-12824
 9083b90:	003fe906 	br	9083b38 <strerror+0x258>
 9083b94:	00824374 	movhi	r2,2317
 9083b98:	10b38004 	addi	r2,r2,-12800
 9083b9c:	003fe606 	br	9083b38 <strerror+0x258>
 9083ba0:	00824374 	movhi	r2,2317
 9083ba4:	10b38304 	addi	r2,r2,-12788
 9083ba8:	003fe306 	br	9083b38 <strerror+0x258>
 9083bac:	00824374 	movhi	r2,2317
 9083bb0:	10b38a04 	addi	r2,r2,-12760
 9083bb4:	003fe006 	br	9083b38 <strerror+0x258>
 9083bb8:	00824374 	movhi	r2,2317
 9083bbc:	10b38f04 	addi	r2,r2,-12740
 9083bc0:	003fdd06 	br	9083b38 <strerror+0x258>
 9083bc4:	00824374 	movhi	r2,2317
 9083bc8:	10b39b04 	addi	r2,r2,-12692
 9083bcc:	003fda06 	br	9083b38 <strerror+0x258>
 9083bd0:	00824374 	movhi	r2,2317
 9083bd4:	10b39f04 	addi	r2,r2,-12676
 9083bd8:	003fd706 	br	9083b38 <strerror+0x258>
 9083bdc:	00824374 	movhi	r2,2317
 9083be0:	10b3aa04 	addi	r2,r2,-12632
 9083be4:	003fd406 	br	9083b38 <strerror+0x258>
 9083be8:	00824374 	movhi	r2,2317
 9083bec:	10b3af04 	addi	r2,r2,-12612
 9083bf0:	003fd106 	br	9083b38 <strerror+0x258>
 9083bf4:	00824374 	movhi	r2,2317
 9083bf8:	10b3b404 	addi	r2,r2,-12592
 9083bfc:	003fce06 	br	9083b38 <strerror+0x258>
 9083c00:	00824374 	movhi	r2,2317
 9083c04:	10b3b904 	addi	r2,r2,-12572
 9083c08:	003fcb06 	br	9083b38 <strerror+0x258>
 9083c0c:	00824374 	movhi	r2,2317
 9083c10:	10b3bc04 	addi	r2,r2,-12560
 9083c14:	003fc806 	br	9083b38 <strerror+0x258>
 9083c18:	00824374 	movhi	r2,2317
 9083c1c:	10b3c204 	addi	r2,r2,-12536
 9083c20:	003fc506 	br	9083b38 <strerror+0x258>
 9083c24:	00824374 	movhi	r2,2317
 9083c28:	10b3c804 	addi	r2,r2,-12512
 9083c2c:	003fc206 	br	9083b38 <strerror+0x258>
 9083c30:	00824374 	movhi	r2,2317
 9083c34:	10b3cb04 	addi	r2,r2,-12500
 9083c38:	003fbf06 	br	9083b38 <strerror+0x258>
 9083c3c:	00824374 	movhi	r2,2317
 9083c40:	10b3d004 	addi	r2,r2,-12480
 9083c44:	003fbc06 	br	9083b38 <strerror+0x258>
 9083c48:	00824374 	movhi	r2,2317
 9083c4c:	10b3d404 	addi	r2,r2,-12464
 9083c50:	003fb906 	br	9083b38 <strerror+0x258>
 9083c54:	00824374 	movhi	r2,2317
 9083c58:	10b3e404 	addi	r2,r2,-12400
 9083c5c:	003fb606 	br	9083b38 <strerror+0x258>
 9083c60:	00824374 	movhi	r2,2317
 9083c64:	10b3e804 	addi	r2,r2,-12384
 9083c68:	003fb306 	br	9083b38 <strerror+0x258>
 9083c6c:	00824374 	movhi	r2,2317
 9083c70:	10b3f604 	addi	r2,r2,-12328
 9083c74:	003fb006 	br	9083b38 <strerror+0x258>
 9083c78:	00824374 	movhi	r2,2317
 9083c7c:	10b3fe04 	addi	r2,r2,-12296
 9083c80:	003fad06 	br	9083b38 <strerror+0x258>
 9083c84:	00824374 	movhi	r2,2317
 9083c88:	10b40304 	addi	r2,r2,-12276
 9083c8c:	003faa06 	br	9083b38 <strerror+0x258>
 9083c90:	00824374 	movhi	r2,2317
 9083c94:	10b40904 	addi	r2,r2,-12252
 9083c98:	003fa706 	br	9083b38 <strerror+0x258>
 9083c9c:	00824374 	movhi	r2,2317
 9083ca0:	10b40d04 	addi	r2,r2,-12236
 9083ca4:	003fa406 	br	9083b38 <strerror+0x258>
 9083ca8:	00824374 	movhi	r2,2317
 9083cac:	10b41604 	addi	r2,r2,-12200
 9083cb0:	003fa106 	br	9083b38 <strerror+0x258>
 9083cb4:	00824374 	movhi	r2,2317
 9083cb8:	10b42004 	addi	r2,r2,-12160
 9083cbc:	003f9e06 	br	9083b38 <strerror+0x258>
 9083cc0:	00824374 	movhi	r2,2317
 9083cc4:	10b42404 	addi	r2,r2,-12144
 9083cc8:	003f9b06 	br	9083b38 <strerror+0x258>
 9083ccc:	00824374 	movhi	r2,2317
 9083cd0:	10b42a04 	addi	r2,r2,-12120
 9083cd4:	003f9806 	br	9083b38 <strerror+0x258>
 9083cd8:	00824374 	movhi	r2,2317
 9083cdc:	10b42e04 	addi	r2,r2,-12104
 9083ce0:	003f9506 	br	9083b38 <strerror+0x258>
 9083ce4:	00824374 	movhi	r2,2317
 9083ce8:	10b43104 	addi	r2,r2,-12092
 9083cec:	003f9206 	br	9083b38 <strerror+0x258>
 9083cf0:	00824374 	movhi	r2,2317
 9083cf4:	10b43504 	addi	r2,r2,-12076
 9083cf8:	003f8f06 	br	9083b38 <strerror+0x258>
 9083cfc:	00824374 	movhi	r2,2317
 9083d00:	10b43a04 	addi	r2,r2,-12056
 9083d04:	003f8c06 	br	9083b38 <strerror+0x258>
 9083d08:	00824374 	movhi	r2,2317
 9083d0c:	10b44104 	addi	r2,r2,-12028
 9083d10:	003f8906 	br	9083b38 <strerror+0x258>
 9083d14:	00824374 	movhi	r2,2317
 9083d18:	10b44604 	addi	r2,r2,-12008
 9083d1c:	003f8606 	br	9083b38 <strerror+0x258>
 9083d20:	00824374 	movhi	r2,2317
 9083d24:	10b44f04 	addi	r2,r2,-11972
 9083d28:	003f8306 	br	9083b38 <strerror+0x258>
 9083d2c:	00824374 	movhi	r2,2317
 9083d30:	10b45104 	addi	r2,r2,-11964
 9083d34:	003f8006 	br	9083b38 <strerror+0x258>
 9083d38:	00824374 	movhi	r2,2317
 9083d3c:	10b45504 	addi	r2,r2,-11948
 9083d40:	003f7d06 	br	9083b38 <strerror+0x258>
 9083d44:	00824374 	movhi	r2,2317
 9083d48:	10b45b04 	addi	r2,r2,-11924
 9083d4c:	003f7a06 	br	9083b38 <strerror+0x258>
 9083d50:	00824374 	movhi	r2,2317
 9083d54:	10b46004 	addi	r2,r2,-11904
 9083d58:	003f7706 	br	9083b38 <strerror+0x258>
 9083d5c:	00824374 	movhi	r2,2317
 9083d60:	10b46804 	addi	r2,r2,-11872
 9083d64:	003f7406 	br	9083b38 <strerror+0x258>
 9083d68:	00824374 	movhi	r2,2317
 9083d6c:	10b46b04 	addi	r2,r2,-11860
 9083d70:	003f7106 	br	9083b38 <strerror+0x258>
 9083d74:	00824374 	movhi	r2,2317
 9083d78:	10b47004 	addi	r2,r2,-11840
 9083d7c:	003f6e06 	br	9083b38 <strerror+0x258>
 9083d80:	00824374 	movhi	r2,2317
 9083d84:	10b47604 	addi	r2,r2,-11816
 9083d88:	003f6b06 	br	9083b38 <strerror+0x258>
 9083d8c:	00824374 	movhi	r2,2317
 9083d90:	10b47a04 	addi	r2,r2,-11800
 9083d94:	003f6806 	br	9083b38 <strerror+0x258>
 9083d98:	00824374 	movhi	r2,2317
 9083d9c:	10b47e04 	addi	r2,r2,-11784
 9083da0:	003f6506 	br	9083b38 <strerror+0x258>
 9083da4:	00824374 	movhi	r2,2317
 9083da8:	10b48304 	addi	r2,r2,-11764
 9083dac:	003f6206 	br	9083b38 <strerror+0x258>
 9083db0:	00824374 	movhi	r2,2317
 9083db4:	10b48c04 	addi	r2,r2,-11728
 9083db8:	003f5f06 	br	9083b38 <strerror+0x258>
 9083dbc:	00824374 	movhi	r2,2317
 9083dc0:	10b49104 	addi	r2,r2,-11708
 9083dc4:	003f5c06 	br	9083b38 <strerror+0x258>
 9083dc8:	00824374 	movhi	r2,2317
 9083dcc:	10b49404 	addi	r2,r2,-11696
 9083dd0:	003f5906 	br	9083b38 <strerror+0x258>
 9083dd4:	00824374 	movhi	r2,2317
 9083dd8:	10b49e04 	addi	r2,r2,-11656
 9083ddc:	003f5606 	br	9083b38 <strerror+0x258>
 9083de0:	00824374 	movhi	r2,2317
 9083de4:	10b4a804 	addi	r2,r2,-11616
 9083de8:	003f5306 	br	9083b38 <strerror+0x258>
 9083dec:	00824374 	movhi	r2,2317
 9083df0:	10b4b004 	addi	r2,r2,-11584
 9083df4:	003f5006 	br	9083b38 <strerror+0x258>
 9083df8:	00824374 	movhi	r2,2317
 9083dfc:	10b4c004 	addi	r2,r2,-11520
 9083e00:	003f4d06 	br	9083b38 <strerror+0x258>
 9083e04:	00824374 	movhi	r2,2317
 9083e08:	10b4ca04 	addi	r2,r2,-11480
 9083e0c:	003f4a06 	br	9083b38 <strerror+0x258>
 9083e10:	00824374 	movhi	r2,2317
 9083e14:	10b4d104 	addi	r2,r2,-11452
 9083e18:	003f4706 	br	9083b38 <strerror+0x258>
 9083e1c:	00824374 	movhi	r2,2317
 9083e20:	10b4d504 	addi	r2,r2,-11436
 9083e24:	003f4406 	br	9083b38 <strerror+0x258>
 9083e28:	00824374 	movhi	r2,2317
 9083e2c:	10b4da04 	addi	r2,r2,-11416
 9083e30:	003f4106 	br	9083b38 <strerror+0x258>
 9083e34:	00824374 	movhi	r2,2317
 9083e38:	10b4e104 	addi	r2,r2,-11388
 9083e3c:	003f3e06 	br	9083b38 <strerror+0x258>
 9083e40:	00824374 	movhi	r2,2317
 9083e44:	10b54104 	addi	r2,r2,-11004
 9083e48:	003f3b06 	br	9083b38 <strerror+0x258>
 9083e4c:	00824374 	movhi	r2,2317
 9083e50:	10b4e704 	addi	r2,r2,-11364
 9083e54:	003f3806 	br	9083b38 <strerror+0x258>
 9083e58:	00824374 	movhi	r2,2317
 9083e5c:	10b4ee04 	addi	r2,r2,-11336
 9083e60:	003f3506 	br	9083b38 <strerror+0x258>
 9083e64:	00824374 	movhi	r2,2317
 9083e68:	10b4fa04 	addi	r2,r2,-11288
 9083e6c:	003f3206 	br	9083b38 <strerror+0x258>
 9083e70:	00824374 	movhi	r2,2317
 9083e74:	10b50204 	addi	r2,r2,-11256
 9083e78:	003f2f06 	br	9083b38 <strerror+0x258>
 9083e7c:	00824374 	movhi	r2,2317
 9083e80:	10b50a04 	addi	r2,r2,-11224
 9083e84:	003f2c06 	br	9083b38 <strerror+0x258>
 9083e88:	00824374 	movhi	r2,2317
 9083e8c:	10b51004 	addi	r2,r2,-11200
 9083e90:	003f2906 	br	9083b38 <strerror+0x258>
 9083e94:	00824374 	movhi	r2,2317
 9083e98:	10b51904 	addi	r2,r2,-11164
 9083e9c:	003f2606 	br	9083b38 <strerror+0x258>
 9083ea0:	00824374 	movhi	r2,2317
 9083ea4:	10b51e04 	addi	r2,r2,-11144
 9083ea8:	003f2306 	br	9083b38 <strerror+0x258>
 9083eac:	00824374 	movhi	r2,2317
 9083eb0:	10b52404 	addi	r2,r2,-11120
 9083eb4:	003f2006 	br	9083b38 <strerror+0x258>
 9083eb8:	00824374 	movhi	r2,2317
 9083ebc:	10b44904 	addi	r2,r2,-11996
 9083ec0:	003f1d06 	br	9083b38 <strerror+0x258>
 9083ec4:	00824374 	movhi	r2,2317
 9083ec8:	10b3ed04 	addi	r2,r2,-12364
 9083ecc:	003f1a06 	br	9083b38 <strerror+0x258>
 9083ed0:	00824374 	movhi	r2,2317
 9083ed4:	10b36604 	addi	r2,r2,-12904
 9083ed8:	003f1706 	br	9083b38 <strerror+0x258>
 9083edc:	00824374 	movhi	r2,2317
 9083ee0:	10b3d804 	addi	r2,r2,-12448
 9083ee4:	003f1406 	br	9083b38 <strerror+0x258>
 9083ee8:	00824374 	movhi	r2,2317
 9083eec:	10b41104 	addi	r2,r2,-12220
 9083ef0:	003f1106 	br	9083b38 <strerror+0x258>
 9083ef4:	00824374 	movhi	r2,2317
 9083ef8:	10b3dc04 	addi	r2,r2,-12432
 9083efc:	003f0e06 	br	9083b38 <strerror+0x258>
 9083f00:	00824374 	movhi	r2,2317
 9083f04:	10b39404 	addi	r2,r2,-12720
 9083f08:	003f0b06 	br	9083b38 <strerror+0x258>
 9083f0c:	00824374 	movhi	r2,2317
 9083f10:	10b3a204 	addi	r2,r2,-12664
 9083f14:	003f0806 	br	9083b38 <strerror+0x258>
 9083f18:	00824374 	movhi	r2,2317
 9083f1c:	10b36104 	addi	r2,r2,-12924
 9083f20:	003f0506 	br	9083b38 <strerror+0x258>
 9083f24:	00824374 	movhi	r2,2317
 9083f28:	10b48704 	addi	r2,r2,-11748
 9083f2c:	003f0206 	br	9083b38 <strerror+0x258>
 9083f30:	00824374 	movhi	r2,2317
 9083f34:	10b53304 	addi	r2,r2,-11060
 9083f38:	003eff06 	br	9083b38 <strerror+0x258>
 9083f3c:	00824374 	movhi	r2,2317
 9083f40:	10b53a04 	addi	r2,r2,-11032
 9083f44:	003efc06 	br	9083b38 <strerror+0x258>
 9083f48:	00824374 	movhi	r2,2317
 9083f4c:	10b52d04 	addi	r2,r2,-11084
 9083f50:	003ef906 	br	9083b38 <strerror+0x258>

09083f54 <strlen>:
 9083f54:	208000cc 	andi	r2,r4,3
 9083f58:	2011883a 	mov	r8,r4
 9083f5c:	1000161e 	bne	r2,zero,9083fb8 <strlen+0x64>
 9083f60:	20c00017 	ldw	r3,0(r4)
 9083f64:	017fbff4 	movhi	r5,65279
 9083f68:	297fbfc4 	addi	r5,r5,-257
 9083f6c:	01e02074 	movhi	r7,32897
 9083f70:	39e02004 	addi	r7,r7,-32640
 9083f74:	1945883a 	add	r2,r3,r5
 9083f78:	11c4703a 	and	r2,r2,r7
 9083f7c:	00c6303a 	nor	r3,zero,r3
 9083f80:	1886703a 	and	r3,r3,r2
 9083f84:	18000c1e 	bne	r3,zero,9083fb8 <strlen+0x64>
 9083f88:	280d883a 	mov	r6,r5
 9083f8c:	380b883a 	mov	r5,r7
 9083f90:	21000104 	addi	r4,r4,4
 9083f94:	20800017 	ldw	r2,0(r4)
 9083f98:	1187883a 	add	r3,r2,r6
 9083f9c:	1946703a 	and	r3,r3,r5
 9083fa0:	0084303a 	nor	r2,zero,r2
 9083fa4:	10c4703a 	and	r2,r2,r3
 9083fa8:	103ff926 	beq	r2,zero,9083f90 <strlen+0x3c>
 9083fac:	20800007 	ldb	r2,0(r4)
 9083fb0:	10000326 	beq	r2,zero,9083fc0 <strlen+0x6c>
 9083fb4:	21000044 	addi	r4,r4,1
 9083fb8:	20800007 	ldb	r2,0(r4)
 9083fbc:	103ffd1e 	bne	r2,zero,9083fb4 <strlen+0x60>
 9083fc0:	2205c83a 	sub	r2,r4,r8
 9083fc4:	f800283a 	ret

09083fc8 <_user_strerror>:
 9083fc8:	0005883a 	mov	r2,zero
 9083fcc:	f800283a 	ret

09083fd0 <__sprint_r>:
 9083fd0:	30800217 	ldw	r2,8(r6)
 9083fd4:	defffe04 	addi	sp,sp,-8
 9083fd8:	dc000015 	stw	r16,0(sp)
 9083fdc:	dfc00115 	stw	ra,4(sp)
 9083fe0:	3021883a 	mov	r16,r6
 9083fe4:	0007883a 	mov	r3,zero
 9083fe8:	1000061e 	bne	r2,zero,9084004 <__sprint_r+0x34>
 9083fec:	1805883a 	mov	r2,r3
 9083ff0:	30000115 	stw	zero,4(r6)
 9083ff4:	dfc00117 	ldw	ra,4(sp)
 9083ff8:	dc000017 	ldw	r16,0(sp)
 9083ffc:	dec00204 	addi	sp,sp,8
 9084000:	f800283a 	ret
 9084004:	90883c80 	call	90883c8 <__sfvwrite_r>
 9084008:	1007883a 	mov	r3,r2
 908400c:	1805883a 	mov	r2,r3
 9084010:	80000115 	stw	zero,4(r16)
 9084014:	80000215 	stw	zero,8(r16)
 9084018:	dfc00117 	ldw	ra,4(sp)
 908401c:	dc000017 	ldw	r16,0(sp)
 9084020:	dec00204 	addi	sp,sp,8
 9084024:	f800283a 	ret

09084028 <___vfprintf_internal_r>:
 9084028:	defea404 	addi	sp,sp,-1392
 908402c:	dd815815 	stw	r22,1376(sp)
 9084030:	dc015215 	stw	r16,1352(sp)
 9084034:	d9c15115 	stw	r7,1348(sp)
 9084038:	dfc15b15 	stw	ra,1388(sp)
 908403c:	df015a15 	stw	fp,1384(sp)
 9084040:	ddc15915 	stw	r23,1380(sp)
 9084044:	dd415715 	stw	r21,1372(sp)
 9084048:	dd015615 	stw	r20,1368(sp)
 908404c:	dcc15515 	stw	r19,1364(sp)
 9084050:	dc815415 	stw	r18,1360(sp)
 9084054:	dc415315 	stw	r17,1356(sp)
 9084058:	282d883a 	mov	r22,r5
 908405c:	3021883a 	mov	r16,r6
 9084060:	d9014f15 	stw	r4,1340(sp)
 9084064:	90889ec0 	call	90889ec <_localeconv_r>
 9084068:	10800017 	ldw	r2,0(r2)
 908406c:	d9c15117 	ldw	r7,1348(sp)
 9084070:	d8814915 	stw	r2,1316(sp)
 9084074:	d8814f17 	ldw	r2,1340(sp)
 9084078:	10000226 	beq	r2,zero,9084084 <___vfprintf_internal_r+0x5c>
 908407c:	10800e17 	ldw	r2,56(r2)
 9084080:	10020d26 	beq	r2,zero,90848b8 <___vfprintf_internal_r+0x890>
 9084084:	b080030b 	ldhu	r2,12(r22)
 9084088:	1080020c 	andi	r2,r2,8
 908408c:	10020e26 	beq	r2,zero,90848c8 <___vfprintf_internal_r+0x8a0>
 9084090:	b0800417 	ldw	r2,16(r22)
 9084094:	10020c26 	beq	r2,zero,90848c8 <___vfprintf_internal_r+0x8a0>
 9084098:	b200030b 	ldhu	r8,12(r22)
 908409c:	00800284 	movi	r2,10
 90840a0:	40c0068c 	andi	r3,r8,26
 90840a4:	18802f1e 	bne	r3,r2,9084164 <___vfprintf_internal_r+0x13c>
 90840a8:	b080038f 	ldh	r2,14(r22)
 90840ac:	10002d16 	blt	r2,zero,9084164 <___vfprintf_internal_r+0x13c>
 90840b0:	b240038b 	ldhu	r9,14(r22)
 90840b4:	b2800717 	ldw	r10,28(r22)
 90840b8:	b2c00917 	ldw	r11,36(r22)
 90840bc:	d9014f17 	ldw	r4,1340(sp)
 90840c0:	dc402904 	addi	r17,sp,164
 90840c4:	d8804004 	addi	r2,sp,256
 90840c8:	00c10004 	movi	r3,1024
 90840cc:	423fff4c 	andi	r8,r8,65533
 90840d0:	800d883a 	mov	r6,r16
 90840d4:	880b883a 	mov	r5,r17
 90840d8:	da002c0d 	sth	r8,176(sp)
 90840dc:	da402c8d 	sth	r9,178(sp)
 90840e0:	da803015 	stw	r10,192(sp)
 90840e4:	dac03215 	stw	r11,200(sp)
 90840e8:	d8802d15 	stw	r2,180(sp)
 90840ec:	d8c02e15 	stw	r3,184(sp)
 90840f0:	d8802915 	stw	r2,164(sp)
 90840f4:	d8c02b15 	stw	r3,172(sp)
 90840f8:	d8002f15 	stw	zero,188(sp)
 90840fc:	90840280 	call	9084028 <___vfprintf_internal_r>
 9084100:	d8814b15 	stw	r2,1324(sp)
 9084104:	10000416 	blt	r2,zero,9084118 <___vfprintf_internal_r+0xf0>
 9084108:	d9014f17 	ldw	r4,1340(sp)
 908410c:	880b883a 	mov	r5,r17
 9084110:	908794c0 	call	908794c <_fflush_r>
 9084114:	1002321e 	bne	r2,zero,90849e0 <___vfprintf_internal_r+0x9b8>
 9084118:	d8802c0b 	ldhu	r2,176(sp)
 908411c:	1080100c 	andi	r2,r2,64
 9084120:	10000326 	beq	r2,zero,9084130 <___vfprintf_internal_r+0x108>
 9084124:	b080030b 	ldhu	r2,12(r22)
 9084128:	10801014 	ori	r2,r2,64
 908412c:	b080030d 	sth	r2,12(r22)
 9084130:	d8814b17 	ldw	r2,1324(sp)
 9084134:	dfc15b17 	ldw	ra,1388(sp)
 9084138:	df015a17 	ldw	fp,1384(sp)
 908413c:	ddc15917 	ldw	r23,1380(sp)
 9084140:	dd815817 	ldw	r22,1376(sp)
 9084144:	dd415717 	ldw	r21,1372(sp)
 9084148:	dd015617 	ldw	r20,1368(sp)
 908414c:	dcc15517 	ldw	r19,1364(sp)
 9084150:	dc815417 	ldw	r18,1360(sp)
 9084154:	dc415317 	ldw	r17,1356(sp)
 9084158:	dc015217 	ldw	r16,1352(sp)
 908415c:	dec15c04 	addi	sp,sp,1392
 9084160:	f800283a 	ret
 9084164:	0005883a 	mov	r2,zero
 9084168:	0007883a 	mov	r3,zero
 908416c:	dd401904 	addi	r21,sp,100
 9084170:	d8814215 	stw	r2,1288(sp)
 9084174:	802f883a 	mov	r23,r16
 9084178:	d8c14315 	stw	r3,1292(sp)
 908417c:	d8014b15 	stw	zero,1324(sp)
 9084180:	d8014815 	stw	zero,1312(sp)
 9084184:	d8014415 	stw	zero,1296(sp)
 9084188:	d8014715 	stw	zero,1308(sp)
 908418c:	dd400c15 	stw	r21,48(sp)
 9084190:	d8000e15 	stw	zero,56(sp)
 9084194:	d8000d15 	stw	zero,52(sp)
 9084198:	b8800007 	ldb	r2,0(r23)
 908419c:	10001926 	beq	r2,zero,9084204 <___vfprintf_internal_r+0x1dc>
 90841a0:	00c00944 	movi	r3,37
 90841a4:	10c01726 	beq	r2,r3,9084204 <___vfprintf_internal_r+0x1dc>
 90841a8:	b821883a 	mov	r16,r23
 90841ac:	00000106 	br	90841b4 <___vfprintf_internal_r+0x18c>
 90841b0:	10c00326 	beq	r2,r3,90841c0 <___vfprintf_internal_r+0x198>
 90841b4:	84000044 	addi	r16,r16,1
 90841b8:	80800007 	ldb	r2,0(r16)
 90841bc:	103ffc1e 	bne	r2,zero,90841b0 <___vfprintf_internal_r+0x188>
 90841c0:	85e7c83a 	sub	r19,r16,r23
 90841c4:	98000e26 	beq	r19,zero,9084200 <___vfprintf_internal_r+0x1d8>
 90841c8:	dc800e17 	ldw	r18,56(sp)
 90841cc:	dc400d17 	ldw	r17,52(sp)
 90841d0:	008001c4 	movi	r2,7
 90841d4:	94e5883a 	add	r18,r18,r19
 90841d8:	8c400044 	addi	r17,r17,1
 90841dc:	adc00015 	stw	r23,0(r21)
 90841e0:	dc800e15 	stw	r18,56(sp)
 90841e4:	acc00115 	stw	r19,4(r21)
 90841e8:	dc400d15 	stw	r17,52(sp)
 90841ec:	14428b16 	blt	r2,r17,9084c1c <___vfprintf_internal_r+0xbf4>
 90841f0:	ad400204 	addi	r21,r21,8
 90841f4:	d9014b17 	ldw	r4,1324(sp)
 90841f8:	24c9883a 	add	r4,r4,r19
 90841fc:	d9014b15 	stw	r4,1324(sp)
 9084200:	802f883a 	mov	r23,r16
 9084204:	b8800007 	ldb	r2,0(r23)
 9084208:	10013c26 	beq	r2,zero,90846fc <___vfprintf_internal_r+0x6d4>
 908420c:	bdc00044 	addi	r23,r23,1
 9084210:	d8000405 	stb	zero,16(sp)
 9084214:	b8c00007 	ldb	r3,0(r23)
 9084218:	04ffffc4 	movi	r19,-1
 908421c:	d8014c15 	stw	zero,1328(sp)
 9084220:	d8014a15 	stw	zero,1320(sp)
 9084224:	d8c14d15 	stw	r3,1332(sp)
 9084228:	bdc00044 	addi	r23,r23,1
 908422c:	d9414d17 	ldw	r5,1332(sp)
 9084230:	00801604 	movi	r2,88
 9084234:	28fff804 	addi	r3,r5,-32
 9084238:	10c06036 	bltu	r2,r3,90843bc <___vfprintf_internal_r+0x394>
 908423c:	18c5883a 	add	r2,r3,r3
 9084240:	1085883a 	add	r2,r2,r2
 9084244:	00c24234 	movhi	r3,2312
 9084248:	18d09604 	addi	r3,r3,16984
 908424c:	10c5883a 	add	r2,r2,r3
 9084250:	11000017 	ldw	r4,0(r2)
 9084254:	2000683a 	jmp	r4
 9084258:	090851cc 	andi	r4,at,8519
 908425c:	090843bc 	xorhi	r4,at,8462
 9084260:	090843bc 	xorhi	r4,at,8462
 9084264:	090851b8 	rdprs	r4,at,8518
 9084268:	090843bc 	xorhi	r4,at,8462
 908426c:	090843bc 	xorhi	r4,at,8462
 9084270:	090843bc 	xorhi	r4,at,8462
 9084274:	090843bc 	xorhi	r4,at,8462
 9084278:	090843bc 	xorhi	r4,at,8462
 908427c:	090843bc 	xorhi	r4,at,8462
 9084280:	09084f98 	cmpnei	r4,at,8510
 9084284:	090851a8 	cmpgeui	r4,at,8518
 9084288:	090843bc 	xorhi	r4,at,8462
 908428c:	09084fb0 	cmpltui	r4,at,8510
 9084290:	09085244 	addi	r4,at,8521
 9084294:	090843bc 	xorhi	r4,at,8462
 9084298:	09085230 	cmpltui	r4,at,8520
 908429c:	090851f8 	rdprs	r4,at,8519
 90842a0:	090851f8 	rdprs	r4,at,8519
 90842a4:	090851f8 	rdprs	r4,at,8519
 90842a8:	090851f8 	rdprs	r4,at,8519
 90842ac:	090851f8 	rdprs	r4,at,8519
 90842b0:	090851f8 	rdprs	r4,at,8519
 90842b4:	090851f8 	rdprs	r4,at,8519
 90842b8:	090851f8 	rdprs	r4,at,8519
 90842bc:	090851f8 	rdprs	r4,at,8519
 90842c0:	090843bc 	xorhi	r4,at,8462
 90842c4:	090843bc 	xorhi	r4,at,8462
 90842c8:	090843bc 	xorhi	r4,at,8462
 90842cc:	090843bc 	xorhi	r4,at,8462
 90842d0:	090843bc 	xorhi	r4,at,8462
 90842d4:	090843bc 	xorhi	r4,at,8462
 90842d8:	090843bc 	xorhi	r4,at,8462
 90842dc:	090843bc 	xorhi	r4,at,8462
 90842e0:	090843bc 	xorhi	r4,at,8462
 90842e4:	090843bc 	xorhi	r4,at,8462
 90842e8:	09084a14 	ori	r4,at,8488
 90842ec:	09085080 	call	908508 <OSCtxSw_SWITCH_PC+0x9084c8>
 90842f0:	090843bc 	xorhi	r4,at,8462
 90842f4:	09085080 	call	908508 <OSCtxSw_SWITCH_PC+0x9084c8>
 90842f8:	090843bc 	xorhi	r4,at,8462
 90842fc:	090843bc 	xorhi	r4,at,8462
 9084300:	090843bc 	xorhi	r4,at,8462
 9084304:	090843bc 	xorhi	r4,at,8462
 9084308:	090851e4 	muli	r4,at,8519
 908430c:	090843bc 	xorhi	r4,at,8462
 9084310:	090843bc 	xorhi	r4,at,8462
 9084314:	09084ac8 	cmpgei	r4,at,8491
 9084318:	090843bc 	xorhi	r4,at,8462
 908431c:	090843bc 	xorhi	r4,at,8462
 9084320:	090843bc 	xorhi	r4,at,8462
 9084324:	090843bc 	xorhi	r4,at,8462
 9084328:	090843bc 	xorhi	r4,at,8462
 908432c:	09084b14 	ori	r4,at,8492
 9084330:	090843bc 	xorhi	r4,at,8462
 9084334:	090843bc 	xorhi	r4,at,8462
 9084338:	09085134 	orhi	r4,at,8516
 908433c:	090843bc 	xorhi	r4,at,8462
 9084340:	090843bc 	xorhi	r4,at,8462
 9084344:	090843bc 	xorhi	r4,at,8462
 9084348:	090843bc 	xorhi	r4,at,8462
 908434c:	090843bc 	xorhi	r4,at,8462
 9084350:	090843bc 	xorhi	r4,at,8462
 9084354:	090843bc 	xorhi	r4,at,8462
 9084358:	090843bc 	xorhi	r4,at,8462
 908435c:	090843bc 	xorhi	r4,at,8462
 9084360:	090843bc 	xorhi	r4,at,8462
 9084364:	09085108 	cmpgei	r4,at,8516
 9084368:	09084a20 	cmpeqi	r4,at,8488
 908436c:	09085080 	call	908508 <OSCtxSw_SWITCH_PC+0x9084c8>
 9084370:	09085080 	call	908508 <OSCtxSw_SWITCH_PC+0x9084c8>
 9084374:	09085080 	call	908508 <OSCtxSw_SWITCH_PC+0x9084c8>
 9084378:	0908506c 	andhi	r4,at,8513
 908437c:	09084a20 	cmpeqi	r4,at,8488
 9084380:	090843bc 	xorhi	r4,at,8462
 9084384:	090843bc 	xorhi	r4,at,8462
 9084388:	09084ff4 	orhi	r4,at,8511
 908438c:	090843bc 	xorhi	r4,at,8462
 9084390:	09084fc4 	addi	r4,at,8511
 9084394:	09084ad4 	ori	r4,at,8491
 9084398:	09085024 	muli	r4,at,8512
 908439c:	09085010 	cmplti	r4,at,8512
 90843a0:	090843bc 	xorhi	r4,at,8462
 90843a4:	090852a0 	cmpeqi	r4,at,8522
 90843a8:	090843bc 	xorhi	r4,at,8462
 90843ac:	09084b20 	cmpeqi	r4,at,8492
 90843b0:	090843bc 	xorhi	r4,at,8462
 90843b4:	090843bc 	xorhi	r4,at,8462
 90843b8:	09085198 	cmpnei	r4,at,8518
 90843bc:	d9014d17 	ldw	r4,1332(sp)
 90843c0:	2000ce26 	beq	r4,zero,90846fc <___vfprintf_internal_r+0x6d4>
 90843c4:	01400044 	movi	r5,1
 90843c8:	d9800f04 	addi	r6,sp,60
 90843cc:	d9c14015 	stw	r7,1280(sp)
 90843d0:	d9414515 	stw	r5,1300(sp)
 90843d4:	d9814115 	stw	r6,1284(sp)
 90843d8:	280f883a 	mov	r7,r5
 90843dc:	d9000f05 	stb	r4,60(sp)
 90843e0:	d8000405 	stb	zero,16(sp)
 90843e4:	d8014615 	stw	zero,1304(sp)
 90843e8:	d8c14c17 	ldw	r3,1328(sp)
 90843ec:	1880008c 	andi	r2,r3,2
 90843f0:	1005003a 	cmpeq	r2,r2,zero
 90843f4:	d8815015 	stw	r2,1344(sp)
 90843f8:	1000031e 	bne	r2,zero,9084408 <___vfprintf_internal_r+0x3e0>
 90843fc:	d9014517 	ldw	r4,1300(sp)
 9084400:	21000084 	addi	r4,r4,2
 9084404:	d9014515 	stw	r4,1300(sp)
 9084408:	d9414c17 	ldw	r5,1328(sp)
 908440c:	2940210c 	andi	r5,r5,132
 9084410:	d9414e15 	stw	r5,1336(sp)
 9084414:	28002d1e 	bne	r5,zero,90844cc <___vfprintf_internal_r+0x4a4>
 9084418:	d9814a17 	ldw	r6,1320(sp)
 908441c:	d8814517 	ldw	r2,1300(sp)
 9084420:	30a1c83a 	sub	r16,r6,r2
 9084424:	0400290e 	bge	zero,r16,90844cc <___vfprintf_internal_r+0x4a4>
 9084428:	00800404 	movi	r2,16
 908442c:	1404580e 	bge	r2,r16,9085590 <___vfprintf_internal_r+0x1568>
 9084430:	dc800e17 	ldw	r18,56(sp)
 9084434:	dc400d17 	ldw	r17,52(sp)
 9084438:	1027883a 	mov	r19,r2
 908443c:	07024374 	movhi	fp,2317
 9084440:	e7356584 	addi	fp,fp,-10858
 9084444:	050001c4 	movi	r20,7
 9084448:	00000306 	br	9084458 <___vfprintf_internal_r+0x430>
 908444c:	843ffc04 	addi	r16,r16,-16
 9084450:	ad400204 	addi	r21,r21,8
 9084454:	9c00130e 	bge	r19,r16,90844a4 <___vfprintf_internal_r+0x47c>
 9084458:	94800404 	addi	r18,r18,16
 908445c:	8c400044 	addi	r17,r17,1
 9084460:	af000015 	stw	fp,0(r21)
 9084464:	acc00115 	stw	r19,4(r21)
 9084468:	dc800e15 	stw	r18,56(sp)
 908446c:	dc400d15 	stw	r17,52(sp)
 9084470:	a47ff60e 	bge	r20,r17,908444c <___vfprintf_internal_r+0x424>
 9084474:	d9014f17 	ldw	r4,1340(sp)
 9084478:	b00b883a 	mov	r5,r22
 908447c:	d9800c04 	addi	r6,sp,48
 9084480:	d9c15115 	stw	r7,1348(sp)
 9084484:	9083fd00 	call	9083fd0 <__sprint_r>
 9084488:	d9c15117 	ldw	r7,1348(sp)
 908448c:	10009e1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084490:	843ffc04 	addi	r16,r16,-16
 9084494:	dc800e17 	ldw	r18,56(sp)
 9084498:	dc400d17 	ldw	r17,52(sp)
 908449c:	dd401904 	addi	r21,sp,100
 90844a0:	9c3fed16 	blt	r19,r16,9084458 <___vfprintf_internal_r+0x430>
 90844a4:	9425883a 	add	r18,r18,r16
 90844a8:	8c400044 	addi	r17,r17,1
 90844ac:	008001c4 	movi	r2,7
 90844b0:	af000015 	stw	fp,0(r21)
 90844b4:	ac000115 	stw	r16,4(r21)
 90844b8:	dc800e15 	stw	r18,56(sp)
 90844bc:	dc400d15 	stw	r17,52(sp)
 90844c0:	1441f516 	blt	r2,r17,9084c98 <___vfprintf_internal_r+0xc70>
 90844c4:	ad400204 	addi	r21,r21,8
 90844c8:	00000206 	br	90844d4 <___vfprintf_internal_r+0x4ac>
 90844cc:	dc800e17 	ldw	r18,56(sp)
 90844d0:	dc400d17 	ldw	r17,52(sp)
 90844d4:	d8800407 	ldb	r2,16(sp)
 90844d8:	10000b26 	beq	r2,zero,9084508 <___vfprintf_internal_r+0x4e0>
 90844dc:	00800044 	movi	r2,1
 90844e0:	94800044 	addi	r18,r18,1
 90844e4:	8c400044 	addi	r17,r17,1
 90844e8:	a8800115 	stw	r2,4(r21)
 90844ec:	d8c00404 	addi	r3,sp,16
 90844f0:	008001c4 	movi	r2,7
 90844f4:	a8c00015 	stw	r3,0(r21)
 90844f8:	dc800e15 	stw	r18,56(sp)
 90844fc:	dc400d15 	stw	r17,52(sp)
 9084500:	1441da16 	blt	r2,r17,9084c6c <___vfprintf_internal_r+0xc44>
 9084504:	ad400204 	addi	r21,r21,8
 9084508:	d9015017 	ldw	r4,1344(sp)
 908450c:	20000b1e 	bne	r4,zero,908453c <___vfprintf_internal_r+0x514>
 9084510:	d8800444 	addi	r2,sp,17
 9084514:	94800084 	addi	r18,r18,2
 9084518:	8c400044 	addi	r17,r17,1
 908451c:	a8800015 	stw	r2,0(r21)
 9084520:	00c00084 	movi	r3,2
 9084524:	008001c4 	movi	r2,7
 9084528:	a8c00115 	stw	r3,4(r21)
 908452c:	dc800e15 	stw	r18,56(sp)
 9084530:	dc400d15 	stw	r17,52(sp)
 9084534:	1441c216 	blt	r2,r17,9084c40 <___vfprintf_internal_r+0xc18>
 9084538:	ad400204 	addi	r21,r21,8
 908453c:	d9414e17 	ldw	r5,1336(sp)
 9084540:	00802004 	movi	r2,128
 9084544:	2880b126 	beq	r5,r2,908480c <___vfprintf_internal_r+0x7e4>
 9084548:	d8c14617 	ldw	r3,1304(sp)
 908454c:	19e1c83a 	sub	r16,r3,r7
 9084550:	0400260e 	bge	zero,r16,90845ec <___vfprintf_internal_r+0x5c4>
 9084554:	00800404 	movi	r2,16
 9084558:	1403c90e 	bge	r2,r16,9085480 <___vfprintf_internal_r+0x1458>
 908455c:	1027883a 	mov	r19,r2
 9084560:	07024374 	movhi	fp,2317
 9084564:	e7356184 	addi	fp,fp,-10874
 9084568:	050001c4 	movi	r20,7
 908456c:	00000306 	br	908457c <___vfprintf_internal_r+0x554>
 9084570:	843ffc04 	addi	r16,r16,-16
 9084574:	ad400204 	addi	r21,r21,8
 9084578:	9c00130e 	bge	r19,r16,90845c8 <___vfprintf_internal_r+0x5a0>
 908457c:	94800404 	addi	r18,r18,16
 9084580:	8c400044 	addi	r17,r17,1
 9084584:	af000015 	stw	fp,0(r21)
 9084588:	acc00115 	stw	r19,4(r21)
 908458c:	dc800e15 	stw	r18,56(sp)
 9084590:	dc400d15 	stw	r17,52(sp)
 9084594:	a47ff60e 	bge	r20,r17,9084570 <___vfprintf_internal_r+0x548>
 9084598:	d9014f17 	ldw	r4,1340(sp)
 908459c:	b00b883a 	mov	r5,r22
 90845a0:	d9800c04 	addi	r6,sp,48
 90845a4:	d9c15115 	stw	r7,1348(sp)
 90845a8:	9083fd00 	call	9083fd0 <__sprint_r>
 90845ac:	d9c15117 	ldw	r7,1348(sp)
 90845b0:	1000551e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90845b4:	843ffc04 	addi	r16,r16,-16
 90845b8:	dc800e17 	ldw	r18,56(sp)
 90845bc:	dc400d17 	ldw	r17,52(sp)
 90845c0:	dd401904 	addi	r21,sp,100
 90845c4:	9c3fed16 	blt	r19,r16,908457c <___vfprintf_internal_r+0x554>
 90845c8:	9425883a 	add	r18,r18,r16
 90845cc:	8c400044 	addi	r17,r17,1
 90845d0:	008001c4 	movi	r2,7
 90845d4:	af000015 	stw	fp,0(r21)
 90845d8:	ac000115 	stw	r16,4(r21)
 90845dc:	dc800e15 	stw	r18,56(sp)
 90845e0:	dc400d15 	stw	r17,52(sp)
 90845e4:	14418216 	blt	r2,r17,9084bf0 <___vfprintf_internal_r+0xbc8>
 90845e8:	ad400204 	addi	r21,r21,8
 90845ec:	d9014c17 	ldw	r4,1328(sp)
 90845f0:	2080400c 	andi	r2,r4,256
 90845f4:	10004a1e 	bne	r2,zero,9084720 <___vfprintf_internal_r+0x6f8>
 90845f8:	d9414117 	ldw	r5,1284(sp)
 90845fc:	91e5883a 	add	r18,r18,r7
 9084600:	8c400044 	addi	r17,r17,1
 9084604:	008001c4 	movi	r2,7
 9084608:	a9400015 	stw	r5,0(r21)
 908460c:	a9c00115 	stw	r7,4(r21)
 9084610:	dc800e15 	stw	r18,56(sp)
 9084614:	dc400d15 	stw	r17,52(sp)
 9084618:	14416716 	blt	r2,r17,9084bb8 <___vfprintf_internal_r+0xb90>
 908461c:	a8c00204 	addi	r3,r21,8
 9084620:	d9814c17 	ldw	r6,1328(sp)
 9084624:	3080010c 	andi	r2,r6,4
 9084628:	10002826 	beq	r2,zero,90846cc <___vfprintf_internal_r+0x6a4>
 908462c:	d8814a17 	ldw	r2,1320(sp)
 9084630:	d9014517 	ldw	r4,1300(sp)
 9084634:	1121c83a 	sub	r16,r2,r4
 9084638:	0400240e 	bge	zero,r16,90846cc <___vfprintf_internal_r+0x6a4>
 908463c:	00800404 	movi	r2,16
 9084640:	14044f0e 	bge	r2,r16,9085780 <___vfprintf_internal_r+0x1758>
 9084644:	dc400d17 	ldw	r17,52(sp)
 9084648:	1027883a 	mov	r19,r2
 908464c:	07024374 	movhi	fp,2317
 9084650:	e7356584 	addi	fp,fp,-10858
 9084654:	050001c4 	movi	r20,7
 9084658:	00000306 	br	9084668 <___vfprintf_internal_r+0x640>
 908465c:	843ffc04 	addi	r16,r16,-16
 9084660:	18c00204 	addi	r3,r3,8
 9084664:	9c00110e 	bge	r19,r16,90846ac <___vfprintf_internal_r+0x684>
 9084668:	94800404 	addi	r18,r18,16
 908466c:	8c400044 	addi	r17,r17,1
 9084670:	1f000015 	stw	fp,0(r3)
 9084674:	1cc00115 	stw	r19,4(r3)
 9084678:	dc800e15 	stw	r18,56(sp)
 908467c:	dc400d15 	stw	r17,52(sp)
 9084680:	a47ff60e 	bge	r20,r17,908465c <___vfprintf_internal_r+0x634>
 9084684:	d9014f17 	ldw	r4,1340(sp)
 9084688:	b00b883a 	mov	r5,r22
 908468c:	d9800c04 	addi	r6,sp,48
 9084690:	9083fd00 	call	9083fd0 <__sprint_r>
 9084694:	10001c1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084698:	843ffc04 	addi	r16,r16,-16
 908469c:	dc800e17 	ldw	r18,56(sp)
 90846a0:	dc400d17 	ldw	r17,52(sp)
 90846a4:	d8c01904 	addi	r3,sp,100
 90846a8:	9c3fef16 	blt	r19,r16,9084668 <___vfprintf_internal_r+0x640>
 90846ac:	9425883a 	add	r18,r18,r16
 90846b0:	8c400044 	addi	r17,r17,1
 90846b4:	008001c4 	movi	r2,7
 90846b8:	1f000015 	stw	fp,0(r3)
 90846bc:	1c000115 	stw	r16,4(r3)
 90846c0:	dc800e15 	stw	r18,56(sp)
 90846c4:	dc400d15 	stw	r17,52(sp)
 90846c8:	1440cb16 	blt	r2,r17,90849f8 <___vfprintf_internal_r+0x9d0>
 90846cc:	d8814a17 	ldw	r2,1320(sp)
 90846d0:	d9414517 	ldw	r5,1300(sp)
 90846d4:	1140010e 	bge	r2,r5,90846dc <___vfprintf_internal_r+0x6b4>
 90846d8:	2805883a 	mov	r2,r5
 90846dc:	d9814b17 	ldw	r6,1324(sp)
 90846e0:	308d883a 	add	r6,r6,r2
 90846e4:	d9814b15 	stw	r6,1324(sp)
 90846e8:	90013b1e 	bne	r18,zero,9084bd8 <___vfprintf_internal_r+0xbb0>
 90846ec:	d9c14017 	ldw	r7,1280(sp)
 90846f0:	dd401904 	addi	r21,sp,100
 90846f4:	d8000d15 	stw	zero,52(sp)
 90846f8:	003ea706 	br	9084198 <___vfprintf_internal_r+0x170>
 90846fc:	d8800e17 	ldw	r2,56(sp)
 9084700:	10053f1e 	bne	r2,zero,9085c00 <___vfprintf_internal_r+0x1bd8>
 9084704:	d8000d15 	stw	zero,52(sp)
 9084708:	b080030b 	ldhu	r2,12(r22)
 908470c:	1080100c 	andi	r2,r2,64
 9084710:	103e8726 	beq	r2,zero,9084130 <___vfprintf_internal_r+0x108>
 9084714:	00bfffc4 	movi	r2,-1
 9084718:	d8814b15 	stw	r2,1324(sp)
 908471c:	003e8406 	br	9084130 <___vfprintf_internal_r+0x108>
 9084720:	d9814d17 	ldw	r6,1332(sp)
 9084724:	00801944 	movi	r2,101
 9084728:	11806e16 	blt	r2,r6,90848e4 <___vfprintf_internal_r+0x8bc>
 908472c:	d9414717 	ldw	r5,1308(sp)
 9084730:	00c00044 	movi	r3,1
 9084734:	1943430e 	bge	r3,r5,9085444 <___vfprintf_internal_r+0x141c>
 9084738:	d8814117 	ldw	r2,1284(sp)
 908473c:	94800044 	addi	r18,r18,1
 9084740:	8c400044 	addi	r17,r17,1
 9084744:	a8800015 	stw	r2,0(r21)
 9084748:	008001c4 	movi	r2,7
 908474c:	a8c00115 	stw	r3,4(r21)
 9084750:	dc800e15 	stw	r18,56(sp)
 9084754:	dc400d15 	stw	r17,52(sp)
 9084758:	1441ca16 	blt	r2,r17,9084e84 <___vfprintf_internal_r+0xe5c>
 908475c:	a8c00204 	addi	r3,r21,8
 9084760:	d9014917 	ldw	r4,1316(sp)
 9084764:	00800044 	movi	r2,1
 9084768:	94800044 	addi	r18,r18,1
 908476c:	8c400044 	addi	r17,r17,1
 9084770:	18800115 	stw	r2,4(r3)
 9084774:	008001c4 	movi	r2,7
 9084778:	19000015 	stw	r4,0(r3)
 908477c:	dc800e15 	stw	r18,56(sp)
 9084780:	dc400d15 	stw	r17,52(sp)
 9084784:	1441b616 	blt	r2,r17,9084e60 <___vfprintf_internal_r+0xe38>
 9084788:	1cc00204 	addi	r19,r3,8
 908478c:	d9014217 	ldw	r4,1288(sp)
 9084790:	d9414317 	ldw	r5,1292(sp)
 9084794:	000d883a 	mov	r6,zero
 9084798:	000f883a 	mov	r7,zero
 908479c:	908cc480 	call	908cc48 <__nedf2>
 90847a0:	10017426 	beq	r2,zero,9084d74 <___vfprintf_internal_r+0xd4c>
 90847a4:	d9414717 	ldw	r5,1308(sp)
 90847a8:	d9814117 	ldw	r6,1284(sp)
 90847ac:	8c400044 	addi	r17,r17,1
 90847b0:	2c85883a 	add	r2,r5,r18
 90847b4:	14bfffc4 	addi	r18,r2,-1
 90847b8:	28bfffc4 	addi	r2,r5,-1
 90847bc:	30c00044 	addi	r3,r6,1
 90847c0:	98800115 	stw	r2,4(r19)
 90847c4:	008001c4 	movi	r2,7
 90847c8:	98c00015 	stw	r3,0(r19)
 90847cc:	dc800e15 	stw	r18,56(sp)
 90847d0:	dc400d15 	stw	r17,52(sp)
 90847d4:	14418e16 	blt	r2,r17,9084e10 <___vfprintf_internal_r+0xde8>
 90847d8:	9cc00204 	addi	r19,r19,8
 90847dc:	d9414817 	ldw	r5,1312(sp)
 90847e0:	d8800804 	addi	r2,sp,32
 90847e4:	8c400044 	addi	r17,r17,1
 90847e8:	9165883a 	add	r18,r18,r5
 90847ec:	98800015 	stw	r2,0(r19)
 90847f0:	008001c4 	movi	r2,7
 90847f4:	99400115 	stw	r5,4(r19)
 90847f8:	dc800e15 	stw	r18,56(sp)
 90847fc:	dc400d15 	stw	r17,52(sp)
 9084800:	1440ed16 	blt	r2,r17,9084bb8 <___vfprintf_internal_r+0xb90>
 9084804:	98c00204 	addi	r3,r19,8
 9084808:	003f8506 	br	9084620 <___vfprintf_internal_r+0x5f8>
 908480c:	d9814a17 	ldw	r6,1320(sp)
 9084810:	d8814517 	ldw	r2,1300(sp)
 9084814:	30a1c83a 	sub	r16,r6,r2
 9084818:	043f4b0e 	bge	zero,r16,9084548 <___vfprintf_internal_r+0x520>
 908481c:	00800404 	movi	r2,16
 9084820:	1404340e 	bge	r2,r16,90858f4 <___vfprintf_internal_r+0x18cc>
 9084824:	1027883a 	mov	r19,r2
 9084828:	07024374 	movhi	fp,2317
 908482c:	e7356184 	addi	fp,fp,-10874
 9084830:	050001c4 	movi	r20,7
 9084834:	00000306 	br	9084844 <___vfprintf_internal_r+0x81c>
 9084838:	843ffc04 	addi	r16,r16,-16
 908483c:	ad400204 	addi	r21,r21,8
 9084840:	9c00130e 	bge	r19,r16,9084890 <___vfprintf_internal_r+0x868>
 9084844:	94800404 	addi	r18,r18,16
 9084848:	8c400044 	addi	r17,r17,1
 908484c:	af000015 	stw	fp,0(r21)
 9084850:	acc00115 	stw	r19,4(r21)
 9084854:	dc800e15 	stw	r18,56(sp)
 9084858:	dc400d15 	stw	r17,52(sp)
 908485c:	a47ff60e 	bge	r20,r17,9084838 <___vfprintf_internal_r+0x810>
 9084860:	d9014f17 	ldw	r4,1340(sp)
 9084864:	b00b883a 	mov	r5,r22
 9084868:	d9800c04 	addi	r6,sp,48
 908486c:	d9c15115 	stw	r7,1348(sp)
 9084870:	9083fd00 	call	9083fd0 <__sprint_r>
 9084874:	d9c15117 	ldw	r7,1348(sp)
 9084878:	103fa31e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 908487c:	843ffc04 	addi	r16,r16,-16
 9084880:	dc800e17 	ldw	r18,56(sp)
 9084884:	dc400d17 	ldw	r17,52(sp)
 9084888:	dd401904 	addi	r21,sp,100
 908488c:	9c3fed16 	blt	r19,r16,9084844 <___vfprintf_internal_r+0x81c>
 9084890:	9425883a 	add	r18,r18,r16
 9084894:	8c400044 	addi	r17,r17,1
 9084898:	008001c4 	movi	r2,7
 908489c:	af000015 	stw	fp,0(r21)
 90848a0:	ac000115 	stw	r16,4(r21)
 90848a4:	dc800e15 	stw	r18,56(sp)
 90848a8:	dc400d15 	stw	r17,52(sp)
 90848ac:	14416116 	blt	r2,r17,9084e34 <___vfprintf_internal_r+0xe0c>
 90848b0:	ad400204 	addi	r21,r21,8
 90848b4:	003f2406 	br	9084548 <___vfprintf_internal_r+0x520>
 90848b8:	d9014f17 	ldw	r4,1340(sp)
 90848bc:	9087be40 	call	9087be4 <__sinit>
 90848c0:	d9c15117 	ldw	r7,1348(sp)
 90848c4:	003def06 	br	9084084 <___vfprintf_internal_r+0x5c>
 90848c8:	d9014f17 	ldw	r4,1340(sp)
 90848cc:	b00b883a 	mov	r5,r22
 90848d0:	d9c15115 	stw	r7,1348(sp)
 90848d4:	90860440 	call	9086044 <__swsetup_r>
 90848d8:	d9c15117 	ldw	r7,1348(sp)
 90848dc:	103dee26 	beq	r2,zero,9084098 <___vfprintf_internal_r+0x70>
 90848e0:	003f8c06 	br	9084714 <___vfprintf_internal_r+0x6ec>
 90848e4:	d9014217 	ldw	r4,1288(sp)
 90848e8:	d9414317 	ldw	r5,1292(sp)
 90848ec:	000d883a 	mov	r6,zero
 90848f0:	000f883a 	mov	r7,zero
 90848f4:	908cbc00 	call	908cbc0 <__eqdf2>
 90848f8:	1000f21e 	bne	r2,zero,9084cc4 <___vfprintf_internal_r+0xc9c>
 90848fc:	00824374 	movhi	r2,2317
 9084900:	10b56104 	addi	r2,r2,-10876
 9084904:	94800044 	addi	r18,r18,1
 9084908:	8c400044 	addi	r17,r17,1
 908490c:	a8800015 	stw	r2,0(r21)
 9084910:	00c00044 	movi	r3,1
 9084914:	008001c4 	movi	r2,7
 9084918:	a8c00115 	stw	r3,4(r21)
 908491c:	dc800e15 	stw	r18,56(sp)
 9084920:	dc400d15 	stw	r17,52(sp)
 9084924:	1442fa16 	blt	r2,r17,9085510 <___vfprintf_internal_r+0x14e8>
 9084928:	a8c00204 	addi	r3,r21,8
 908492c:	d8800517 	ldw	r2,20(sp)
 9084930:	d9014717 	ldw	r4,1308(sp)
 9084934:	11015c0e 	bge	r2,r4,9084ea8 <___vfprintf_internal_r+0xe80>
 9084938:	dc400d17 	ldw	r17,52(sp)
 908493c:	d9814917 	ldw	r6,1316(sp)
 9084940:	00800044 	movi	r2,1
 9084944:	94800044 	addi	r18,r18,1
 9084948:	8c400044 	addi	r17,r17,1
 908494c:	18800115 	stw	r2,4(r3)
 9084950:	008001c4 	movi	r2,7
 9084954:	19800015 	stw	r6,0(r3)
 9084958:	dc800e15 	stw	r18,56(sp)
 908495c:	dc400d15 	stw	r17,52(sp)
 9084960:	14431016 	blt	r2,r17,90855a4 <___vfprintf_internal_r+0x157c>
 9084964:	18c00204 	addi	r3,r3,8
 9084968:	d8814717 	ldw	r2,1308(sp)
 908496c:	143fffc4 	addi	r16,r2,-1
 9084970:	043f2b0e 	bge	zero,r16,9084620 <___vfprintf_internal_r+0x5f8>
 9084974:	00800404 	movi	r2,16
 9084978:	1402a20e 	bge	r2,r16,9085404 <___vfprintf_internal_r+0x13dc>
 908497c:	dc400d17 	ldw	r17,52(sp)
 9084980:	1027883a 	mov	r19,r2
 9084984:	07024374 	movhi	fp,2317
 9084988:	e7356184 	addi	fp,fp,-10874
 908498c:	050001c4 	movi	r20,7
 9084990:	00000306 	br	90849a0 <___vfprintf_internal_r+0x978>
 9084994:	18c00204 	addi	r3,r3,8
 9084998:	843ffc04 	addi	r16,r16,-16
 908499c:	9c029c0e 	bge	r19,r16,9085410 <___vfprintf_internal_r+0x13e8>
 90849a0:	94800404 	addi	r18,r18,16
 90849a4:	8c400044 	addi	r17,r17,1
 90849a8:	1f000015 	stw	fp,0(r3)
 90849ac:	1cc00115 	stw	r19,4(r3)
 90849b0:	dc800e15 	stw	r18,56(sp)
 90849b4:	dc400d15 	stw	r17,52(sp)
 90849b8:	a47ff60e 	bge	r20,r17,9084994 <___vfprintf_internal_r+0x96c>
 90849bc:	d9014f17 	ldw	r4,1340(sp)
 90849c0:	b00b883a 	mov	r5,r22
 90849c4:	d9800c04 	addi	r6,sp,48
 90849c8:	9083fd00 	call	9083fd0 <__sprint_r>
 90849cc:	103f4e1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90849d0:	dc800e17 	ldw	r18,56(sp)
 90849d4:	dc400d17 	ldw	r17,52(sp)
 90849d8:	d8c01904 	addi	r3,sp,100
 90849dc:	003fee06 	br	9084998 <___vfprintf_internal_r+0x970>
 90849e0:	d8802c0b 	ldhu	r2,176(sp)
 90849e4:	00ffffc4 	movi	r3,-1
 90849e8:	d8c14b15 	stw	r3,1324(sp)
 90849ec:	1080100c 	andi	r2,r2,64
 90849f0:	103dcc1e 	bne	r2,zero,9084124 <___vfprintf_internal_r+0xfc>
 90849f4:	003dce06 	br	9084130 <___vfprintf_internal_r+0x108>
 90849f8:	d9014f17 	ldw	r4,1340(sp)
 90849fc:	b00b883a 	mov	r5,r22
 9084a00:	d9800c04 	addi	r6,sp,48
 9084a04:	9083fd00 	call	9083fd0 <__sprint_r>
 9084a08:	103f3f1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084a0c:	dc800e17 	ldw	r18,56(sp)
 9084a10:	003f2e06 	br	90846cc <___vfprintf_internal_r+0x6a4>
 9084a14:	d9414c17 	ldw	r5,1328(sp)
 9084a18:	29400414 	ori	r5,r5,16
 9084a1c:	d9414c15 	stw	r5,1328(sp)
 9084a20:	d9814c17 	ldw	r6,1328(sp)
 9084a24:	3080080c 	andi	r2,r6,32
 9084a28:	10014f1e 	bne	r2,zero,9084f68 <___vfprintf_internal_r+0xf40>
 9084a2c:	d8c14c17 	ldw	r3,1328(sp)
 9084a30:	1880040c 	andi	r2,r3,16
 9084a34:	1002ea1e 	bne	r2,zero,90855e0 <___vfprintf_internal_r+0x15b8>
 9084a38:	d9014c17 	ldw	r4,1328(sp)
 9084a3c:	2080100c 	andi	r2,r4,64
 9084a40:	1002e726 	beq	r2,zero,90855e0 <___vfprintf_internal_r+0x15b8>
 9084a44:	3880000f 	ldh	r2,0(r7)
 9084a48:	39c00104 	addi	r7,r7,4
 9084a4c:	d9c14015 	stw	r7,1280(sp)
 9084a50:	1023d7fa 	srai	r17,r2,31
 9084a54:	1021883a 	mov	r16,r2
 9084a58:	88037216 	blt	r17,zero,9085824 <___vfprintf_internal_r+0x17fc>
 9084a5c:	01000044 	movi	r4,1
 9084a60:	98000416 	blt	r19,zero,9084a74 <___vfprintf_internal_r+0xa4c>
 9084a64:	d8c14c17 	ldw	r3,1328(sp)
 9084a68:	00bfdfc4 	movi	r2,-129
 9084a6c:	1886703a 	and	r3,r3,r2
 9084a70:	d8c14c15 	stw	r3,1328(sp)
 9084a74:	8444b03a 	or	r2,r16,r17
 9084a78:	1002261e 	bne	r2,zero,9085314 <___vfprintf_internal_r+0x12ec>
 9084a7c:	9802251e 	bne	r19,zero,9085314 <___vfprintf_internal_r+0x12ec>
 9084a80:	20803fcc 	andi	r2,r4,255
 9084a84:	10029b26 	beq	r2,zero,90854f4 <___vfprintf_internal_r+0x14cc>
 9084a88:	d8c01904 	addi	r3,sp,100
 9084a8c:	dd000f04 	addi	r20,sp,60
 9084a90:	d8c14115 	stw	r3,1284(sp)
 9084a94:	d8c14117 	ldw	r3,1284(sp)
 9084a98:	dcc14515 	stw	r19,1300(sp)
 9084a9c:	a0c5c83a 	sub	r2,r20,r3
 9084aa0:	11c00a04 	addi	r7,r2,40
 9084aa4:	99c0010e 	bge	r19,r7,9084aac <___vfprintf_internal_r+0xa84>
 9084aa8:	d9c14515 	stw	r7,1300(sp)
 9084aac:	dcc14615 	stw	r19,1304(sp)
 9084ab0:	d8800407 	ldb	r2,16(sp)
 9084ab4:	103e4c26 	beq	r2,zero,90843e8 <___vfprintf_internal_r+0x3c0>
 9084ab8:	d8814517 	ldw	r2,1300(sp)
 9084abc:	10800044 	addi	r2,r2,1
 9084ac0:	d8814515 	stw	r2,1300(sp)
 9084ac4:	003e4806 	br	90843e8 <___vfprintf_internal_r+0x3c0>
 9084ac8:	d9814c17 	ldw	r6,1328(sp)
 9084acc:	31800414 	ori	r6,r6,16
 9084ad0:	d9814c15 	stw	r6,1328(sp)
 9084ad4:	d8c14c17 	ldw	r3,1328(sp)
 9084ad8:	1880080c 	andi	r2,r3,32
 9084adc:	1001271e 	bne	r2,zero,9084f7c <___vfprintf_internal_r+0xf54>
 9084ae0:	d9414c17 	ldw	r5,1328(sp)
 9084ae4:	2880040c 	andi	r2,r5,16
 9084ae8:	1002b61e 	bne	r2,zero,90855c4 <___vfprintf_internal_r+0x159c>
 9084aec:	d9814c17 	ldw	r6,1328(sp)
 9084af0:	3080100c 	andi	r2,r6,64
 9084af4:	1002b326 	beq	r2,zero,90855c4 <___vfprintf_internal_r+0x159c>
 9084af8:	3c00000b 	ldhu	r16,0(r7)
 9084afc:	0009883a 	mov	r4,zero
 9084b00:	39c00104 	addi	r7,r7,4
 9084b04:	0023883a 	mov	r17,zero
 9084b08:	d9c14015 	stw	r7,1280(sp)
 9084b0c:	d8000405 	stb	zero,16(sp)
 9084b10:	003fd306 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9084b14:	d9014c17 	ldw	r4,1328(sp)
 9084b18:	21000414 	ori	r4,r4,16
 9084b1c:	d9014c15 	stw	r4,1328(sp)
 9084b20:	d9414c17 	ldw	r5,1328(sp)
 9084b24:	2880080c 	andi	r2,r5,32
 9084b28:	1001081e 	bne	r2,zero,9084f4c <___vfprintf_internal_r+0xf24>
 9084b2c:	d8c14c17 	ldw	r3,1328(sp)
 9084b30:	1880040c 	andi	r2,r3,16
 9084b34:	1002b01e 	bne	r2,zero,90855f8 <___vfprintf_internal_r+0x15d0>
 9084b38:	d9014c17 	ldw	r4,1328(sp)
 9084b3c:	2080100c 	andi	r2,r4,64
 9084b40:	1002ad26 	beq	r2,zero,90855f8 <___vfprintf_internal_r+0x15d0>
 9084b44:	3c00000b 	ldhu	r16,0(r7)
 9084b48:	01000044 	movi	r4,1
 9084b4c:	39c00104 	addi	r7,r7,4
 9084b50:	0023883a 	mov	r17,zero
 9084b54:	d9c14015 	stw	r7,1280(sp)
 9084b58:	d8000405 	stb	zero,16(sp)
 9084b5c:	003fc006 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9084b60:	d9014f17 	ldw	r4,1340(sp)
 9084b64:	b00b883a 	mov	r5,r22
 9084b68:	d9800c04 	addi	r6,sp,48
 9084b6c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084b70:	103ee51e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084b74:	dc800e17 	ldw	r18,56(sp)
 9084b78:	d8c01904 	addi	r3,sp,100
 9084b7c:	d9814c17 	ldw	r6,1328(sp)
 9084b80:	3080004c 	andi	r2,r6,1
 9084b84:	1005003a 	cmpeq	r2,r2,zero
 9084b88:	103ea51e 	bne	r2,zero,9084620 <___vfprintf_internal_r+0x5f8>
 9084b8c:	00800044 	movi	r2,1
 9084b90:	dc400d17 	ldw	r17,52(sp)
 9084b94:	18800115 	stw	r2,4(r3)
 9084b98:	d8814917 	ldw	r2,1316(sp)
 9084b9c:	94800044 	addi	r18,r18,1
 9084ba0:	8c400044 	addi	r17,r17,1
 9084ba4:	18800015 	stw	r2,0(r3)
 9084ba8:	008001c4 	movi	r2,7
 9084bac:	dc800e15 	stw	r18,56(sp)
 9084bb0:	dc400d15 	stw	r17,52(sp)
 9084bb4:	14421e0e 	bge	r2,r17,9085430 <___vfprintf_internal_r+0x1408>
 9084bb8:	d9014f17 	ldw	r4,1340(sp)
 9084bbc:	b00b883a 	mov	r5,r22
 9084bc0:	d9800c04 	addi	r6,sp,48
 9084bc4:	9083fd00 	call	9083fd0 <__sprint_r>
 9084bc8:	103ecf1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084bcc:	dc800e17 	ldw	r18,56(sp)
 9084bd0:	d8c01904 	addi	r3,sp,100
 9084bd4:	003e9206 	br	9084620 <___vfprintf_internal_r+0x5f8>
 9084bd8:	d9014f17 	ldw	r4,1340(sp)
 9084bdc:	b00b883a 	mov	r5,r22
 9084be0:	d9800c04 	addi	r6,sp,48
 9084be4:	9083fd00 	call	9083fd0 <__sprint_r>
 9084be8:	103ec026 	beq	r2,zero,90846ec <___vfprintf_internal_r+0x6c4>
 9084bec:	003ec606 	br	9084708 <___vfprintf_internal_r+0x6e0>
 9084bf0:	d9014f17 	ldw	r4,1340(sp)
 9084bf4:	b00b883a 	mov	r5,r22
 9084bf8:	d9800c04 	addi	r6,sp,48
 9084bfc:	d9c15115 	stw	r7,1348(sp)
 9084c00:	9083fd00 	call	9083fd0 <__sprint_r>
 9084c04:	d9c15117 	ldw	r7,1348(sp)
 9084c08:	103ebf1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084c0c:	dc800e17 	ldw	r18,56(sp)
 9084c10:	dc400d17 	ldw	r17,52(sp)
 9084c14:	dd401904 	addi	r21,sp,100
 9084c18:	003e7406 	br	90845ec <___vfprintf_internal_r+0x5c4>
 9084c1c:	d9014f17 	ldw	r4,1340(sp)
 9084c20:	b00b883a 	mov	r5,r22
 9084c24:	d9800c04 	addi	r6,sp,48
 9084c28:	d9c15115 	stw	r7,1348(sp)
 9084c2c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084c30:	d9c15117 	ldw	r7,1348(sp)
 9084c34:	103eb41e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084c38:	dd401904 	addi	r21,sp,100
 9084c3c:	003d6d06 	br	90841f4 <___vfprintf_internal_r+0x1cc>
 9084c40:	d9014f17 	ldw	r4,1340(sp)
 9084c44:	b00b883a 	mov	r5,r22
 9084c48:	d9800c04 	addi	r6,sp,48
 9084c4c:	d9c15115 	stw	r7,1348(sp)
 9084c50:	9083fd00 	call	9083fd0 <__sprint_r>
 9084c54:	d9c15117 	ldw	r7,1348(sp)
 9084c58:	103eab1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084c5c:	dc800e17 	ldw	r18,56(sp)
 9084c60:	dc400d17 	ldw	r17,52(sp)
 9084c64:	dd401904 	addi	r21,sp,100
 9084c68:	003e3406 	br	908453c <___vfprintf_internal_r+0x514>
 9084c6c:	d9014f17 	ldw	r4,1340(sp)
 9084c70:	b00b883a 	mov	r5,r22
 9084c74:	d9800c04 	addi	r6,sp,48
 9084c78:	d9c15115 	stw	r7,1348(sp)
 9084c7c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084c80:	d9c15117 	ldw	r7,1348(sp)
 9084c84:	103ea01e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084c88:	dc800e17 	ldw	r18,56(sp)
 9084c8c:	dc400d17 	ldw	r17,52(sp)
 9084c90:	dd401904 	addi	r21,sp,100
 9084c94:	003e1c06 	br	9084508 <___vfprintf_internal_r+0x4e0>
 9084c98:	d9014f17 	ldw	r4,1340(sp)
 9084c9c:	b00b883a 	mov	r5,r22
 9084ca0:	d9800c04 	addi	r6,sp,48
 9084ca4:	d9c15115 	stw	r7,1348(sp)
 9084ca8:	9083fd00 	call	9083fd0 <__sprint_r>
 9084cac:	d9c15117 	ldw	r7,1348(sp)
 9084cb0:	103e951e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084cb4:	dc800e17 	ldw	r18,56(sp)
 9084cb8:	dc400d17 	ldw	r17,52(sp)
 9084cbc:	dd401904 	addi	r21,sp,100
 9084cc0:	003e0406 	br	90844d4 <___vfprintf_internal_r+0x4ac>
 9084cc4:	d9000517 	ldw	r4,20(sp)
 9084cc8:	0102520e 	bge	zero,r4,9085614 <___vfprintf_internal_r+0x15ec>
 9084ccc:	d9814717 	ldw	r6,1308(sp)
 9084cd0:	21807a16 	blt	r4,r6,9084ebc <___vfprintf_internal_r+0xe94>
 9084cd4:	d8814117 	ldw	r2,1284(sp)
 9084cd8:	91a5883a 	add	r18,r18,r6
 9084cdc:	8c400044 	addi	r17,r17,1
 9084ce0:	a8800015 	stw	r2,0(r21)
 9084ce4:	008001c4 	movi	r2,7
 9084ce8:	a9800115 	stw	r6,4(r21)
 9084cec:	dc800e15 	stw	r18,56(sp)
 9084cf0:	dc400d15 	stw	r17,52(sp)
 9084cf4:	1442f616 	blt	r2,r17,90858d0 <___vfprintf_internal_r+0x18a8>
 9084cf8:	a8c00204 	addi	r3,r21,8
 9084cfc:	d9414717 	ldw	r5,1308(sp)
 9084d00:	2161c83a 	sub	r16,r4,r5
 9084d04:	043f9d0e 	bge	zero,r16,9084b7c <___vfprintf_internal_r+0xb54>
 9084d08:	00800404 	movi	r2,16
 9084d0c:	1402130e 	bge	r2,r16,908555c <___vfprintf_internal_r+0x1534>
 9084d10:	dc400d17 	ldw	r17,52(sp)
 9084d14:	1027883a 	mov	r19,r2
 9084d18:	07024374 	movhi	fp,2317
 9084d1c:	e7356184 	addi	fp,fp,-10874
 9084d20:	050001c4 	movi	r20,7
 9084d24:	00000306 	br	9084d34 <___vfprintf_internal_r+0xd0c>
 9084d28:	18c00204 	addi	r3,r3,8
 9084d2c:	843ffc04 	addi	r16,r16,-16
 9084d30:	9c020d0e 	bge	r19,r16,9085568 <___vfprintf_internal_r+0x1540>
 9084d34:	94800404 	addi	r18,r18,16
 9084d38:	8c400044 	addi	r17,r17,1
 9084d3c:	1f000015 	stw	fp,0(r3)
 9084d40:	1cc00115 	stw	r19,4(r3)
 9084d44:	dc800e15 	stw	r18,56(sp)
 9084d48:	dc400d15 	stw	r17,52(sp)
 9084d4c:	a47ff60e 	bge	r20,r17,9084d28 <___vfprintf_internal_r+0xd00>
 9084d50:	d9014f17 	ldw	r4,1340(sp)
 9084d54:	b00b883a 	mov	r5,r22
 9084d58:	d9800c04 	addi	r6,sp,48
 9084d5c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084d60:	103e691e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084d64:	dc800e17 	ldw	r18,56(sp)
 9084d68:	dc400d17 	ldw	r17,52(sp)
 9084d6c:	d8c01904 	addi	r3,sp,100
 9084d70:	003fee06 	br	9084d2c <___vfprintf_internal_r+0xd04>
 9084d74:	d8814717 	ldw	r2,1308(sp)
 9084d78:	143fffc4 	addi	r16,r2,-1
 9084d7c:	043e970e 	bge	zero,r16,90847dc <___vfprintf_internal_r+0x7b4>
 9084d80:	00800404 	movi	r2,16
 9084d84:	1400180e 	bge	r2,r16,9084de8 <___vfprintf_internal_r+0xdc0>
 9084d88:	1029883a 	mov	r20,r2
 9084d8c:	07024374 	movhi	fp,2317
 9084d90:	e7356184 	addi	fp,fp,-10874
 9084d94:	054001c4 	movi	r21,7
 9084d98:	00000306 	br	9084da8 <___vfprintf_internal_r+0xd80>
 9084d9c:	9cc00204 	addi	r19,r19,8
 9084da0:	843ffc04 	addi	r16,r16,-16
 9084da4:	a400120e 	bge	r20,r16,9084df0 <___vfprintf_internal_r+0xdc8>
 9084da8:	94800404 	addi	r18,r18,16
 9084dac:	8c400044 	addi	r17,r17,1
 9084db0:	9f000015 	stw	fp,0(r19)
 9084db4:	9d000115 	stw	r20,4(r19)
 9084db8:	dc800e15 	stw	r18,56(sp)
 9084dbc:	dc400d15 	stw	r17,52(sp)
 9084dc0:	ac7ff60e 	bge	r21,r17,9084d9c <___vfprintf_internal_r+0xd74>
 9084dc4:	d9014f17 	ldw	r4,1340(sp)
 9084dc8:	b00b883a 	mov	r5,r22
 9084dcc:	d9800c04 	addi	r6,sp,48
 9084dd0:	9083fd00 	call	9083fd0 <__sprint_r>
 9084dd4:	103e4c1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084dd8:	dc800e17 	ldw	r18,56(sp)
 9084ddc:	dc400d17 	ldw	r17,52(sp)
 9084de0:	dcc01904 	addi	r19,sp,100
 9084de4:	003fee06 	br	9084da0 <___vfprintf_internal_r+0xd78>
 9084de8:	07024374 	movhi	fp,2317
 9084dec:	e7356184 	addi	fp,fp,-10874
 9084df0:	9425883a 	add	r18,r18,r16
 9084df4:	8c400044 	addi	r17,r17,1
 9084df8:	008001c4 	movi	r2,7
 9084dfc:	9f000015 	stw	fp,0(r19)
 9084e00:	9c000115 	stw	r16,4(r19)
 9084e04:	dc800e15 	stw	r18,56(sp)
 9084e08:	dc400d15 	stw	r17,52(sp)
 9084e0c:	147e720e 	bge	r2,r17,90847d8 <___vfprintf_internal_r+0x7b0>
 9084e10:	d9014f17 	ldw	r4,1340(sp)
 9084e14:	b00b883a 	mov	r5,r22
 9084e18:	d9800c04 	addi	r6,sp,48
 9084e1c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084e20:	103e391e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084e24:	dc800e17 	ldw	r18,56(sp)
 9084e28:	dc400d17 	ldw	r17,52(sp)
 9084e2c:	dcc01904 	addi	r19,sp,100
 9084e30:	003e6a06 	br	90847dc <___vfprintf_internal_r+0x7b4>
 9084e34:	d9014f17 	ldw	r4,1340(sp)
 9084e38:	b00b883a 	mov	r5,r22
 9084e3c:	d9800c04 	addi	r6,sp,48
 9084e40:	d9c15115 	stw	r7,1348(sp)
 9084e44:	9083fd00 	call	9083fd0 <__sprint_r>
 9084e48:	d9c15117 	ldw	r7,1348(sp)
 9084e4c:	103e2e1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084e50:	dc800e17 	ldw	r18,56(sp)
 9084e54:	dc400d17 	ldw	r17,52(sp)
 9084e58:	dd401904 	addi	r21,sp,100
 9084e5c:	003dba06 	br	9084548 <___vfprintf_internal_r+0x520>
 9084e60:	d9014f17 	ldw	r4,1340(sp)
 9084e64:	b00b883a 	mov	r5,r22
 9084e68:	d9800c04 	addi	r6,sp,48
 9084e6c:	9083fd00 	call	9083fd0 <__sprint_r>
 9084e70:	103e251e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084e74:	dc800e17 	ldw	r18,56(sp)
 9084e78:	dc400d17 	ldw	r17,52(sp)
 9084e7c:	dcc01904 	addi	r19,sp,100
 9084e80:	003e4206 	br	908478c <___vfprintf_internal_r+0x764>
 9084e84:	d9014f17 	ldw	r4,1340(sp)
 9084e88:	b00b883a 	mov	r5,r22
 9084e8c:	d9800c04 	addi	r6,sp,48
 9084e90:	9083fd00 	call	9083fd0 <__sprint_r>
 9084e94:	103e1c1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9084e98:	dc800e17 	ldw	r18,56(sp)
 9084e9c:	dc400d17 	ldw	r17,52(sp)
 9084ea0:	d8c01904 	addi	r3,sp,100
 9084ea4:	003e2e06 	br	9084760 <___vfprintf_internal_r+0x738>
 9084ea8:	d9414c17 	ldw	r5,1328(sp)
 9084eac:	2880004c 	andi	r2,r5,1
 9084eb0:	1005003a 	cmpeq	r2,r2,zero
 9084eb4:	103dda1e 	bne	r2,zero,9084620 <___vfprintf_internal_r+0x5f8>
 9084eb8:	003e9f06 	br	9084938 <___vfprintf_internal_r+0x910>
 9084ebc:	d8c14117 	ldw	r3,1284(sp)
 9084ec0:	9125883a 	add	r18,r18,r4
 9084ec4:	8c400044 	addi	r17,r17,1
 9084ec8:	008001c4 	movi	r2,7
 9084ecc:	a8c00015 	stw	r3,0(r21)
 9084ed0:	a9000115 	stw	r4,4(r21)
 9084ed4:	dc800e15 	stw	r18,56(sp)
 9084ed8:	dc400d15 	stw	r17,52(sp)
 9084edc:	14426616 	blt	r2,r17,9085878 <___vfprintf_internal_r+0x1850>
 9084ee0:	a8c00204 	addi	r3,r21,8
 9084ee4:	d9414917 	ldw	r5,1316(sp)
 9084ee8:	00800044 	movi	r2,1
 9084eec:	94800044 	addi	r18,r18,1
 9084ef0:	8c400044 	addi	r17,r17,1
 9084ef4:	18800115 	stw	r2,4(r3)
 9084ef8:	008001c4 	movi	r2,7
 9084efc:	19400015 	stw	r5,0(r3)
 9084f00:	dc800e15 	stw	r18,56(sp)
 9084f04:	dc400d15 	stw	r17,52(sp)
 9084f08:	2021883a 	mov	r16,r4
 9084f0c:	14425016 	blt	r2,r17,9085850 <___vfprintf_internal_r+0x1828>
 9084f10:	19400204 	addi	r5,r3,8
 9084f14:	d9814717 	ldw	r6,1308(sp)
 9084f18:	8c400044 	addi	r17,r17,1
 9084f1c:	dc400d15 	stw	r17,52(sp)
 9084f20:	3107c83a 	sub	r3,r6,r4
 9084f24:	d9014117 	ldw	r4,1284(sp)
 9084f28:	90e5883a 	add	r18,r18,r3
 9084f2c:	28c00115 	stw	r3,4(r5)
 9084f30:	8105883a 	add	r2,r16,r4
 9084f34:	28800015 	stw	r2,0(r5)
 9084f38:	008001c4 	movi	r2,7
 9084f3c:	dc800e15 	stw	r18,56(sp)
 9084f40:	147f1d16 	blt	r2,r17,9084bb8 <___vfprintf_internal_r+0xb90>
 9084f44:	28c00204 	addi	r3,r5,8
 9084f48:	003db506 	br	9084620 <___vfprintf_internal_r+0x5f8>
 9084f4c:	3c000017 	ldw	r16,0(r7)
 9084f50:	3c400117 	ldw	r17,4(r7)
 9084f54:	39800204 	addi	r6,r7,8
 9084f58:	01000044 	movi	r4,1
 9084f5c:	d9814015 	stw	r6,1280(sp)
 9084f60:	d8000405 	stb	zero,16(sp)
 9084f64:	003ebe06 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9084f68:	3c000017 	ldw	r16,0(r7)
 9084f6c:	3c400117 	ldw	r17,4(r7)
 9084f70:	38800204 	addi	r2,r7,8
 9084f74:	d8814015 	stw	r2,1280(sp)
 9084f78:	003eb706 	br	9084a58 <___vfprintf_internal_r+0xa30>
 9084f7c:	3c000017 	ldw	r16,0(r7)
 9084f80:	3c400117 	ldw	r17,4(r7)
 9084f84:	39000204 	addi	r4,r7,8
 9084f88:	d9014015 	stw	r4,1280(sp)
 9084f8c:	0009883a 	mov	r4,zero
 9084f90:	d8000405 	stb	zero,16(sp)
 9084f94:	003eb206 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9084f98:	38c00017 	ldw	r3,0(r7)
 9084f9c:	39c00104 	addi	r7,r7,4
 9084fa0:	d8c14a15 	stw	r3,1320(sp)
 9084fa4:	1800d10e 	bge	r3,zero,90852ec <___vfprintf_internal_r+0x12c4>
 9084fa8:	00c7c83a 	sub	r3,zero,r3
 9084fac:	d8c14a15 	stw	r3,1320(sp)
 9084fb0:	d9014c17 	ldw	r4,1328(sp)
 9084fb4:	b8c00007 	ldb	r3,0(r23)
 9084fb8:	21000114 	ori	r4,r4,4
 9084fbc:	d9014c15 	stw	r4,1328(sp)
 9084fc0:	003c9806 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9084fc4:	d9814c17 	ldw	r6,1328(sp)
 9084fc8:	3080080c 	andi	r2,r6,32
 9084fcc:	1001f026 	beq	r2,zero,9085790 <___vfprintf_internal_r+0x1768>
 9084fd0:	d9014b17 	ldw	r4,1324(sp)
 9084fd4:	38800017 	ldw	r2,0(r7)
 9084fd8:	39c00104 	addi	r7,r7,4
 9084fdc:	d9c14015 	stw	r7,1280(sp)
 9084fe0:	2007d7fa 	srai	r3,r4,31
 9084fe4:	d9c14017 	ldw	r7,1280(sp)
 9084fe8:	11000015 	stw	r4,0(r2)
 9084fec:	10c00115 	stw	r3,4(r2)
 9084ff0:	003c6906 	br	9084198 <___vfprintf_internal_r+0x170>
 9084ff4:	b8c00007 	ldb	r3,0(r23)
 9084ff8:	00801b04 	movi	r2,108
 9084ffc:	18824f26 	beq	r3,r2,908593c <___vfprintf_internal_r+0x1914>
 9085000:	d9414c17 	ldw	r5,1328(sp)
 9085004:	29400414 	ori	r5,r5,16
 9085008:	d9414c15 	stw	r5,1328(sp)
 908500c:	003c8506 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085010:	d9814c17 	ldw	r6,1328(sp)
 9085014:	b8c00007 	ldb	r3,0(r23)
 9085018:	31800814 	ori	r6,r6,32
 908501c:	d9814c15 	stw	r6,1328(sp)
 9085020:	003c8006 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085024:	d8814c17 	ldw	r2,1328(sp)
 9085028:	3c000017 	ldw	r16,0(r7)
 908502c:	00c01e04 	movi	r3,120
 9085030:	10800094 	ori	r2,r2,2
 9085034:	d8814c15 	stw	r2,1328(sp)
 9085038:	39c00104 	addi	r7,r7,4
 908503c:	01424374 	movhi	r5,2317
 9085040:	29754a04 	addi	r5,r5,-10968
 9085044:	00800c04 	movi	r2,48
 9085048:	0023883a 	mov	r17,zero
 908504c:	01000084 	movi	r4,2
 9085050:	d9c14015 	stw	r7,1280(sp)
 9085054:	d8c14d15 	stw	r3,1332(sp)
 9085058:	d9414415 	stw	r5,1296(sp)
 908505c:	d8800445 	stb	r2,17(sp)
 9085060:	d8c00485 	stb	r3,18(sp)
 9085064:	d8000405 	stb	zero,16(sp)
 9085068:	003e7d06 	br	9084a60 <___vfprintf_internal_r+0xa38>
 908506c:	d8814c17 	ldw	r2,1328(sp)
 9085070:	b8c00007 	ldb	r3,0(r23)
 9085074:	10801014 	ori	r2,r2,64
 9085078:	d8814c15 	stw	r2,1328(sp)
 908507c:	003c6906 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085080:	d9414c17 	ldw	r5,1328(sp)
 9085084:	2880020c 	andi	r2,r5,8
 9085088:	1001df26 	beq	r2,zero,9085808 <___vfprintf_internal_r+0x17e0>
 908508c:	39800017 	ldw	r6,0(r7)
 9085090:	38800204 	addi	r2,r7,8
 9085094:	d8814015 	stw	r2,1280(sp)
 9085098:	d9814215 	stw	r6,1288(sp)
 908509c:	39c00117 	ldw	r7,4(r7)
 90850a0:	d9c14315 	stw	r7,1292(sp)
 90850a4:	d9014217 	ldw	r4,1288(sp)
 90850a8:	d9414317 	ldw	r5,1292(sp)
 90850ac:	908ada80 	call	908ada8 <__isinfd>
 90850b0:	10021726 	beq	r2,zero,9085910 <___vfprintf_internal_r+0x18e8>
 90850b4:	d9014217 	ldw	r4,1288(sp)
 90850b8:	d9414317 	ldw	r5,1292(sp)
 90850bc:	000d883a 	mov	r6,zero
 90850c0:	000f883a 	mov	r7,zero
 90850c4:	908cde00 	call	908cde0 <__ltdf2>
 90850c8:	1002ca16 	blt	r2,zero,9085bf4 <___vfprintf_internal_r+0x1bcc>
 90850cc:	d9414d17 	ldw	r5,1332(sp)
 90850d0:	008011c4 	movi	r2,71
 90850d4:	11420a16 	blt	r2,r5,9085900 <___vfprintf_internal_r+0x18d8>
 90850d8:	01824374 	movhi	r6,2317
 90850dc:	31b54f04 	addi	r6,r6,-10948
 90850e0:	d9814115 	stw	r6,1284(sp)
 90850e4:	d9014c17 	ldw	r4,1328(sp)
 90850e8:	00c000c4 	movi	r3,3
 90850ec:	00bfdfc4 	movi	r2,-129
 90850f0:	2088703a 	and	r4,r4,r2
 90850f4:	180f883a 	mov	r7,r3
 90850f8:	d8c14515 	stw	r3,1300(sp)
 90850fc:	d9014c15 	stw	r4,1328(sp)
 9085100:	d8014615 	stw	zero,1304(sp)
 9085104:	003e6a06 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 9085108:	38800017 	ldw	r2,0(r7)
 908510c:	00c00044 	movi	r3,1
 9085110:	39c00104 	addi	r7,r7,4
 9085114:	d9c14015 	stw	r7,1280(sp)
 9085118:	d9000f04 	addi	r4,sp,60
 908511c:	180f883a 	mov	r7,r3
 9085120:	d8c14515 	stw	r3,1300(sp)
 9085124:	d9014115 	stw	r4,1284(sp)
 9085128:	d8800f05 	stb	r2,60(sp)
 908512c:	d8000405 	stb	zero,16(sp)
 9085130:	003cac06 	br	90843e4 <___vfprintf_internal_r+0x3bc>
 9085134:	01424374 	movhi	r5,2317
 9085138:	29755504 	addi	r5,r5,-10924
 908513c:	d9414415 	stw	r5,1296(sp)
 9085140:	d9814c17 	ldw	r6,1328(sp)
 9085144:	3080080c 	andi	r2,r6,32
 9085148:	1000f926 	beq	r2,zero,9085530 <___vfprintf_internal_r+0x1508>
 908514c:	3c000017 	ldw	r16,0(r7)
 9085150:	3c400117 	ldw	r17,4(r7)
 9085154:	38800204 	addi	r2,r7,8
 9085158:	d8814015 	stw	r2,1280(sp)
 908515c:	d9414c17 	ldw	r5,1328(sp)
 9085160:	2880004c 	andi	r2,r5,1
 9085164:	1005003a 	cmpeq	r2,r2,zero
 9085168:	1000b31e 	bne	r2,zero,9085438 <___vfprintf_internal_r+0x1410>
 908516c:	8444b03a 	or	r2,r16,r17
 9085170:	1000b126 	beq	r2,zero,9085438 <___vfprintf_internal_r+0x1410>
 9085174:	d9814d17 	ldw	r6,1332(sp)
 9085178:	29400094 	ori	r5,r5,2
 908517c:	00800c04 	movi	r2,48
 9085180:	01000084 	movi	r4,2
 9085184:	d9414c15 	stw	r5,1328(sp)
 9085188:	d8800445 	stb	r2,17(sp)
 908518c:	d9800485 	stb	r6,18(sp)
 9085190:	d8000405 	stb	zero,16(sp)
 9085194:	003e3206 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9085198:	01824374 	movhi	r6,2317
 908519c:	31b54a04 	addi	r6,r6,-10968
 90851a0:	d9814415 	stw	r6,1296(sp)
 90851a4:	003fe606 	br	9085140 <___vfprintf_internal_r+0x1118>
 90851a8:	00800ac4 	movi	r2,43
 90851ac:	d8800405 	stb	r2,16(sp)
 90851b0:	b8c00007 	ldb	r3,0(r23)
 90851b4:	003c1b06 	br	9084224 <___vfprintf_internal_r+0x1fc>
 90851b8:	d8814c17 	ldw	r2,1328(sp)
 90851bc:	b8c00007 	ldb	r3,0(r23)
 90851c0:	10800054 	ori	r2,r2,1
 90851c4:	d8814c15 	stw	r2,1328(sp)
 90851c8:	003c1606 	br	9084224 <___vfprintf_internal_r+0x1fc>
 90851cc:	d8800407 	ldb	r2,16(sp)
 90851d0:	1000461e 	bne	r2,zero,90852ec <___vfprintf_internal_r+0x12c4>
 90851d4:	00800804 	movi	r2,32
 90851d8:	d8800405 	stb	r2,16(sp)
 90851dc:	b8c00007 	ldb	r3,0(r23)
 90851e0:	003c1006 	br	9084224 <___vfprintf_internal_r+0x1fc>
 90851e4:	d9814c17 	ldw	r6,1328(sp)
 90851e8:	b8c00007 	ldb	r3,0(r23)
 90851ec:	31800214 	ori	r6,r6,8
 90851f0:	d9814c15 	stw	r6,1328(sp)
 90851f4:	003c0b06 	br	9084224 <___vfprintf_internal_r+0x1fc>
 90851f8:	0007883a 	mov	r3,zero
 90851fc:	01000244 	movi	r4,9
 9085200:	188002a4 	muli	r2,r3,10
 9085204:	b8c00007 	ldb	r3,0(r23)
 9085208:	d9814d17 	ldw	r6,1332(sp)
 908520c:	bdc00044 	addi	r23,r23,1
 9085210:	d8c14d15 	stw	r3,1332(sp)
 9085214:	d9414d17 	ldw	r5,1332(sp)
 9085218:	3085883a 	add	r2,r6,r2
 908521c:	10fff404 	addi	r3,r2,-48
 9085220:	28bff404 	addi	r2,r5,-48
 9085224:	20bff62e 	bgeu	r4,r2,9085200 <___vfprintf_internal_r+0x11d8>
 9085228:	d8c14a15 	stw	r3,1320(sp)
 908522c:	003bff06 	br	908422c <___vfprintf_internal_r+0x204>
 9085230:	d9414c17 	ldw	r5,1328(sp)
 9085234:	b8c00007 	ldb	r3,0(r23)
 9085238:	29402014 	ori	r5,r5,128
 908523c:	d9414c15 	stw	r5,1328(sp)
 9085240:	003bf806 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085244:	b8c00007 	ldb	r3,0(r23)
 9085248:	00800a84 	movi	r2,42
 908524c:	bdc00044 	addi	r23,r23,1
 9085250:	18831526 	beq	r3,r2,9085ea8 <___vfprintf_internal_r+0x1e80>
 9085254:	d8c14d15 	stw	r3,1332(sp)
 9085258:	18bff404 	addi	r2,r3,-48
 908525c:	00c00244 	movi	r3,9
 9085260:	18827836 	bltu	r3,r2,9085c44 <___vfprintf_internal_r+0x1c1c>
 9085264:	000d883a 	mov	r6,zero
 9085268:	308002a4 	muli	r2,r6,10
 908526c:	b9800007 	ldb	r6,0(r23)
 9085270:	d9414d17 	ldw	r5,1332(sp)
 9085274:	bdc00044 	addi	r23,r23,1
 9085278:	d9814d15 	stw	r6,1332(sp)
 908527c:	d9014d17 	ldw	r4,1332(sp)
 9085280:	1145883a 	add	r2,r2,r5
 9085284:	11bff404 	addi	r6,r2,-48
 9085288:	20bff404 	addi	r2,r4,-48
 908528c:	18bff62e 	bgeu	r3,r2,9085268 <___vfprintf_internal_r+0x1240>
 9085290:	3027883a 	mov	r19,r6
 9085294:	303be50e 	bge	r6,zero,908422c <___vfprintf_internal_r+0x204>
 9085298:	04ffffc4 	movi	r19,-1
 908529c:	003be306 	br	908422c <___vfprintf_internal_r+0x204>
 90852a0:	d8000405 	stb	zero,16(sp)
 90852a4:	39800017 	ldw	r6,0(r7)
 90852a8:	39c00104 	addi	r7,r7,4
 90852ac:	d9c14015 	stw	r7,1280(sp)
 90852b0:	d9814115 	stw	r6,1284(sp)
 90852b4:	3001c926 	beq	r6,zero,90859dc <___vfprintf_internal_r+0x19b4>
 90852b8:	98000e16 	blt	r19,zero,90852f4 <___vfprintf_internal_r+0x12cc>
 90852bc:	d9014117 	ldw	r4,1284(sp)
 90852c0:	000b883a 	mov	r5,zero
 90852c4:	980d883a 	mov	r6,r19
 90852c8:	908937c0 	call	908937c <memchr>
 90852cc:	10025926 	beq	r2,zero,9085c34 <___vfprintf_internal_r+0x1c0c>
 90852d0:	d8c14117 	ldw	r3,1284(sp)
 90852d4:	10cfc83a 	sub	r7,r2,r3
 90852d8:	99c19e16 	blt	r19,r7,9085954 <___vfprintf_internal_r+0x192c>
 90852dc:	d9c14515 	stw	r7,1300(sp)
 90852e0:	38000916 	blt	r7,zero,9085308 <___vfprintf_internal_r+0x12e0>
 90852e4:	d8014615 	stw	zero,1304(sp)
 90852e8:	003df106 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 90852ec:	b8c00007 	ldb	r3,0(r23)
 90852f0:	003bcc06 	br	9084224 <___vfprintf_internal_r+0x1fc>
 90852f4:	d9014117 	ldw	r4,1284(sp)
 90852f8:	9083f540 	call	9083f54 <strlen>
 90852fc:	d8814515 	stw	r2,1300(sp)
 9085300:	100f883a 	mov	r7,r2
 9085304:	103ff70e 	bge	r2,zero,90852e4 <___vfprintf_internal_r+0x12bc>
 9085308:	d8014515 	stw	zero,1300(sp)
 908530c:	d8014615 	stw	zero,1304(sp)
 9085310:	003de706 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 9085314:	20c03fcc 	andi	r3,r4,255
 9085318:	00800044 	movi	r2,1
 908531c:	18802d26 	beq	r3,r2,90853d4 <___vfprintf_internal_r+0x13ac>
 9085320:	18800e36 	bltu	r3,r2,908535c <___vfprintf_internal_r+0x1334>
 9085324:	00800084 	movi	r2,2
 9085328:	1880fa26 	beq	r3,r2,9085714 <___vfprintf_internal_r+0x16ec>
 908532c:	01024374 	movhi	r4,2317
 9085330:	21355a04 	addi	r4,r4,-10904
 9085334:	9083f540 	call	9083f54 <strlen>
 9085338:	100f883a 	mov	r7,r2
 908533c:	dcc14515 	stw	r19,1300(sp)
 9085340:	9880010e 	bge	r19,r2,9085348 <___vfprintf_internal_r+0x1320>
 9085344:	d8814515 	stw	r2,1300(sp)
 9085348:	00824374 	movhi	r2,2317
 908534c:	10b55a04 	addi	r2,r2,-10904
 9085350:	dcc14615 	stw	r19,1304(sp)
 9085354:	d8814115 	stw	r2,1284(sp)
 9085358:	003dd506 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 908535c:	d9401904 	addi	r5,sp,100
 9085360:	dd000f04 	addi	r20,sp,60
 9085364:	d9414115 	stw	r5,1284(sp)
 9085368:	880a977a 	slli	r5,r17,29
 908536c:	d9814117 	ldw	r6,1284(sp)
 9085370:	8004d0fa 	srli	r2,r16,3
 9085374:	8806d0fa 	srli	r3,r17,3
 9085378:	810001cc 	andi	r4,r16,7
 908537c:	2884b03a 	or	r2,r5,r2
 9085380:	31bfffc4 	addi	r6,r6,-1
 9085384:	21000c04 	addi	r4,r4,48
 9085388:	d9814115 	stw	r6,1284(sp)
 908538c:	10cab03a 	or	r5,r2,r3
 9085390:	31000005 	stb	r4,0(r6)
 9085394:	1021883a 	mov	r16,r2
 9085398:	1823883a 	mov	r17,r3
 908539c:	283ff21e 	bne	r5,zero,9085368 <___vfprintf_internal_r+0x1340>
 90853a0:	d8c14c17 	ldw	r3,1328(sp)
 90853a4:	1880004c 	andi	r2,r3,1
 90853a8:	1005003a 	cmpeq	r2,r2,zero
 90853ac:	103db91e 	bne	r2,zero,9084a94 <___vfprintf_internal_r+0xa6c>
 90853b0:	20803fcc 	andi	r2,r4,255
 90853b4:	1080201c 	xori	r2,r2,128
 90853b8:	10bfe004 	addi	r2,r2,-128
 90853bc:	00c00c04 	movi	r3,48
 90853c0:	10fdb426 	beq	r2,r3,9084a94 <___vfprintf_internal_r+0xa6c>
 90853c4:	31bfffc4 	addi	r6,r6,-1
 90853c8:	d9814115 	stw	r6,1284(sp)
 90853cc:	30c00005 	stb	r3,0(r6)
 90853d0:	003db006 	br	9084a94 <___vfprintf_internal_r+0xa6c>
 90853d4:	88800068 	cmpgeui	r2,r17,1
 90853d8:	10002c1e 	bne	r2,zero,908548c <___vfprintf_internal_r+0x1464>
 90853dc:	8800021e 	bne	r17,zero,90853e8 <___vfprintf_internal_r+0x13c0>
 90853e0:	00800244 	movi	r2,9
 90853e4:	14002936 	bltu	r2,r16,908548c <___vfprintf_internal_r+0x1464>
 90853e8:	d90018c4 	addi	r4,sp,99
 90853ec:	dd000f04 	addi	r20,sp,60
 90853f0:	d9014115 	stw	r4,1284(sp)
 90853f4:	d9014117 	ldw	r4,1284(sp)
 90853f8:	80800c04 	addi	r2,r16,48
 90853fc:	20800005 	stb	r2,0(r4)
 9085400:	003da406 	br	9084a94 <___vfprintf_internal_r+0xa6c>
 9085404:	dc400d17 	ldw	r17,52(sp)
 9085408:	07024374 	movhi	fp,2317
 908540c:	e7356184 	addi	fp,fp,-10874
 9085410:	9425883a 	add	r18,r18,r16
 9085414:	8c400044 	addi	r17,r17,1
 9085418:	008001c4 	movi	r2,7
 908541c:	1f000015 	stw	fp,0(r3)
 9085420:	1c000115 	stw	r16,4(r3)
 9085424:	dc800e15 	stw	r18,56(sp)
 9085428:	dc400d15 	stw	r17,52(sp)
 908542c:	147de216 	blt	r2,r17,9084bb8 <___vfprintf_internal_r+0xb90>
 9085430:	18c00204 	addi	r3,r3,8
 9085434:	003c7a06 	br	9084620 <___vfprintf_internal_r+0x5f8>
 9085438:	01000084 	movi	r4,2
 908543c:	d8000405 	stb	zero,16(sp)
 9085440:	003d8706 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9085444:	d9814c17 	ldw	r6,1328(sp)
 9085448:	30c4703a 	and	r2,r6,r3
 908544c:	1005003a 	cmpeq	r2,r2,zero
 9085450:	103cb926 	beq	r2,zero,9084738 <___vfprintf_internal_r+0x710>
 9085454:	d9014117 	ldw	r4,1284(sp)
 9085458:	94800044 	addi	r18,r18,1
 908545c:	8c400044 	addi	r17,r17,1
 9085460:	008001c4 	movi	r2,7
 9085464:	a9000015 	stw	r4,0(r21)
 9085468:	a8c00115 	stw	r3,4(r21)
 908546c:	dc800e15 	stw	r18,56(sp)
 9085470:	dc400d15 	stw	r17,52(sp)
 9085474:	147e6616 	blt	r2,r17,9084e10 <___vfprintf_internal_r+0xde8>
 9085478:	acc00204 	addi	r19,r21,8
 908547c:	003cd706 	br	90847dc <___vfprintf_internal_r+0x7b4>
 9085480:	07024374 	movhi	fp,2317
 9085484:	e7356184 	addi	fp,fp,-10874
 9085488:	003c4f06 	br	90845c8 <___vfprintf_internal_r+0x5a0>
 908548c:	dd000f04 	addi	r20,sp,60
 9085490:	dc801904 	addi	r18,sp,100
 9085494:	8009883a 	mov	r4,r16
 9085498:	880b883a 	mov	r5,r17
 908549c:	01800284 	movi	r6,10
 90854a0:	000f883a 	mov	r7,zero
 90854a4:	908bb000 	call	908bb00 <__umoddi3>
 90854a8:	12000c04 	addi	r8,r2,48
 90854ac:	94bfffc4 	addi	r18,r18,-1
 90854b0:	8009883a 	mov	r4,r16
 90854b4:	880b883a 	mov	r5,r17
 90854b8:	01800284 	movi	r6,10
 90854bc:	000f883a 	mov	r7,zero
 90854c0:	92000005 	stb	r8,0(r18)
 90854c4:	908b5240 	call	908b524 <__udivdi3>
 90854c8:	1009883a 	mov	r4,r2
 90854cc:	1021883a 	mov	r16,r2
 90854d0:	18800068 	cmpgeui	r2,r3,1
 90854d4:	1823883a 	mov	r17,r3
 90854d8:	103fee1e 	bne	r2,zero,9085494 <___vfprintf_internal_r+0x146c>
 90854dc:	1800021e 	bne	r3,zero,90854e8 <___vfprintf_internal_r+0x14c0>
 90854e0:	00800244 	movi	r2,9
 90854e4:	113feb36 	bltu	r2,r4,9085494 <___vfprintf_internal_r+0x146c>
 90854e8:	94bfffc4 	addi	r18,r18,-1
 90854ec:	dc814115 	stw	r18,1284(sp)
 90854f0:	003fc006 	br	90853f4 <___vfprintf_internal_r+0x13cc>
 90854f4:	d9014c17 	ldw	r4,1328(sp)
 90854f8:	2080004c 	andi	r2,r4,1
 90854fc:	10009a1e 	bne	r2,zero,9085768 <___vfprintf_internal_r+0x1740>
 9085500:	d9401904 	addi	r5,sp,100
 9085504:	dd000f04 	addi	r20,sp,60
 9085508:	d9414115 	stw	r5,1284(sp)
 908550c:	003d6106 	br	9084a94 <___vfprintf_internal_r+0xa6c>
 9085510:	d9014f17 	ldw	r4,1340(sp)
 9085514:	b00b883a 	mov	r5,r22
 9085518:	d9800c04 	addi	r6,sp,48
 908551c:	9083fd00 	call	9083fd0 <__sprint_r>
 9085520:	103c791e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9085524:	dc800e17 	ldw	r18,56(sp)
 9085528:	d8c01904 	addi	r3,sp,100
 908552c:	003cff06 	br	908492c <___vfprintf_internal_r+0x904>
 9085530:	d8c14c17 	ldw	r3,1328(sp)
 9085534:	1880040c 	andi	r2,r3,16
 9085538:	1000711e 	bne	r2,zero,9085700 <___vfprintf_internal_r+0x16d8>
 908553c:	d9014c17 	ldw	r4,1328(sp)
 9085540:	2080100c 	andi	r2,r4,64
 9085544:	10006e26 	beq	r2,zero,9085700 <___vfprintf_internal_r+0x16d8>
 9085548:	3c00000b 	ldhu	r16,0(r7)
 908554c:	0023883a 	mov	r17,zero
 9085550:	39c00104 	addi	r7,r7,4
 9085554:	d9c14015 	stw	r7,1280(sp)
 9085558:	003f0006 	br	908515c <___vfprintf_internal_r+0x1134>
 908555c:	dc400d17 	ldw	r17,52(sp)
 9085560:	07024374 	movhi	fp,2317
 9085564:	e7356184 	addi	fp,fp,-10874
 9085568:	9425883a 	add	r18,r18,r16
 908556c:	8c400044 	addi	r17,r17,1
 9085570:	008001c4 	movi	r2,7
 9085574:	1f000015 	stw	fp,0(r3)
 9085578:	1c000115 	stw	r16,4(r3)
 908557c:	dc800e15 	stw	r18,56(sp)
 9085580:	dc400d15 	stw	r17,52(sp)
 9085584:	147d7616 	blt	r2,r17,9084b60 <___vfprintf_internal_r+0xb38>
 9085588:	18c00204 	addi	r3,r3,8
 908558c:	003d7b06 	br	9084b7c <___vfprintf_internal_r+0xb54>
 9085590:	dc800e17 	ldw	r18,56(sp)
 9085594:	dc400d17 	ldw	r17,52(sp)
 9085598:	07024374 	movhi	fp,2317
 908559c:	e7356584 	addi	fp,fp,-10858
 90855a0:	003bc006 	br	90844a4 <___vfprintf_internal_r+0x47c>
 90855a4:	d9014f17 	ldw	r4,1340(sp)
 90855a8:	b00b883a 	mov	r5,r22
 90855ac:	d9800c04 	addi	r6,sp,48
 90855b0:	9083fd00 	call	9083fd0 <__sprint_r>
 90855b4:	103c541e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90855b8:	dc800e17 	ldw	r18,56(sp)
 90855bc:	d8c01904 	addi	r3,sp,100
 90855c0:	003ce906 	br	9084968 <___vfprintf_internal_r+0x940>
 90855c4:	3c000017 	ldw	r16,0(r7)
 90855c8:	0009883a 	mov	r4,zero
 90855cc:	39c00104 	addi	r7,r7,4
 90855d0:	0023883a 	mov	r17,zero
 90855d4:	d9c14015 	stw	r7,1280(sp)
 90855d8:	d8000405 	stb	zero,16(sp)
 90855dc:	003d2006 	br	9084a60 <___vfprintf_internal_r+0xa38>
 90855e0:	38800017 	ldw	r2,0(r7)
 90855e4:	39c00104 	addi	r7,r7,4
 90855e8:	d9c14015 	stw	r7,1280(sp)
 90855ec:	1023d7fa 	srai	r17,r2,31
 90855f0:	1021883a 	mov	r16,r2
 90855f4:	003d1806 	br	9084a58 <___vfprintf_internal_r+0xa30>
 90855f8:	3c000017 	ldw	r16,0(r7)
 90855fc:	01000044 	movi	r4,1
 9085600:	39c00104 	addi	r7,r7,4
 9085604:	0023883a 	mov	r17,zero
 9085608:	d9c14015 	stw	r7,1280(sp)
 908560c:	d8000405 	stb	zero,16(sp)
 9085610:	003d1306 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9085614:	00824374 	movhi	r2,2317
 9085618:	10b56104 	addi	r2,r2,-10876
 908561c:	94800044 	addi	r18,r18,1
 9085620:	8c400044 	addi	r17,r17,1
 9085624:	a8800015 	stw	r2,0(r21)
 9085628:	00c00044 	movi	r3,1
 908562c:	008001c4 	movi	r2,7
 9085630:	a8c00115 	stw	r3,4(r21)
 9085634:	dc800e15 	stw	r18,56(sp)
 9085638:	dc400d15 	stw	r17,52(sp)
 908563c:	1440ca16 	blt	r2,r17,9085968 <___vfprintf_internal_r+0x1940>
 9085640:	a8c00204 	addi	r3,r21,8
 9085644:	2000061e 	bne	r4,zero,9085660 <___vfprintf_internal_r+0x1638>
 9085648:	d9414717 	ldw	r5,1308(sp)
 908564c:	2800041e 	bne	r5,zero,9085660 <___vfprintf_internal_r+0x1638>
 9085650:	d9814c17 	ldw	r6,1328(sp)
 9085654:	3080004c 	andi	r2,r6,1
 9085658:	1005003a 	cmpeq	r2,r2,zero
 908565c:	103bf01e 	bne	r2,zero,9084620 <___vfprintf_internal_r+0x5f8>
 9085660:	00800044 	movi	r2,1
 9085664:	dc400d17 	ldw	r17,52(sp)
 9085668:	18800115 	stw	r2,4(r3)
 908566c:	d8814917 	ldw	r2,1316(sp)
 9085670:	94800044 	addi	r18,r18,1
 9085674:	8c400044 	addi	r17,r17,1
 9085678:	18800015 	stw	r2,0(r3)
 908567c:	008001c4 	movi	r2,7
 9085680:	dc800e15 	stw	r18,56(sp)
 9085684:	dc400d15 	stw	r17,52(sp)
 9085688:	1440ca16 	blt	r2,r17,90859b4 <___vfprintf_internal_r+0x198c>
 908568c:	18c00204 	addi	r3,r3,8
 9085690:	0121c83a 	sub	r16,zero,r4
 9085694:	0400500e 	bge	zero,r16,90857d8 <___vfprintf_internal_r+0x17b0>
 9085698:	00800404 	movi	r2,16
 908569c:	1400800e 	bge	r2,r16,90858a0 <___vfprintf_internal_r+0x1878>
 90856a0:	1027883a 	mov	r19,r2
 90856a4:	07024374 	movhi	fp,2317
 90856a8:	e7356184 	addi	fp,fp,-10874
 90856ac:	050001c4 	movi	r20,7
 90856b0:	00000306 	br	90856c0 <___vfprintf_internal_r+0x1698>
 90856b4:	18c00204 	addi	r3,r3,8
 90856b8:	843ffc04 	addi	r16,r16,-16
 90856bc:	9c007a0e 	bge	r19,r16,90858a8 <___vfprintf_internal_r+0x1880>
 90856c0:	94800404 	addi	r18,r18,16
 90856c4:	8c400044 	addi	r17,r17,1
 90856c8:	1f000015 	stw	fp,0(r3)
 90856cc:	1cc00115 	stw	r19,4(r3)
 90856d0:	dc800e15 	stw	r18,56(sp)
 90856d4:	dc400d15 	stw	r17,52(sp)
 90856d8:	a47ff60e 	bge	r20,r17,90856b4 <___vfprintf_internal_r+0x168c>
 90856dc:	d9014f17 	ldw	r4,1340(sp)
 90856e0:	b00b883a 	mov	r5,r22
 90856e4:	d9800c04 	addi	r6,sp,48
 90856e8:	9083fd00 	call	9083fd0 <__sprint_r>
 90856ec:	103c061e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90856f0:	dc800e17 	ldw	r18,56(sp)
 90856f4:	dc400d17 	ldw	r17,52(sp)
 90856f8:	d8c01904 	addi	r3,sp,100
 90856fc:	003fee06 	br	90856b8 <___vfprintf_internal_r+0x1690>
 9085700:	3c000017 	ldw	r16,0(r7)
 9085704:	0023883a 	mov	r17,zero
 9085708:	39c00104 	addi	r7,r7,4
 908570c:	d9c14015 	stw	r7,1280(sp)
 9085710:	003e9206 	br	908515c <___vfprintf_internal_r+0x1134>
 9085714:	d9401904 	addi	r5,sp,100
 9085718:	dd000f04 	addi	r20,sp,60
 908571c:	d9414115 	stw	r5,1284(sp)
 9085720:	d9814417 	ldw	r6,1296(sp)
 9085724:	880a973a 	slli	r5,r17,28
 9085728:	8004d13a 	srli	r2,r16,4
 908572c:	810003cc 	andi	r4,r16,15
 9085730:	3109883a 	add	r4,r6,r4
 9085734:	2884b03a 	or	r2,r5,r2
 9085738:	21400003 	ldbu	r5,0(r4)
 908573c:	d9014117 	ldw	r4,1284(sp)
 9085740:	8806d13a 	srli	r3,r17,4
 9085744:	1021883a 	mov	r16,r2
 9085748:	213fffc4 	addi	r4,r4,-1
 908574c:	d9014115 	stw	r4,1284(sp)
 9085750:	d9814117 	ldw	r6,1284(sp)
 9085754:	10c8b03a 	or	r4,r2,r3
 9085758:	1823883a 	mov	r17,r3
 908575c:	31400005 	stb	r5,0(r6)
 9085760:	203fef1e 	bne	r4,zero,9085720 <___vfprintf_internal_r+0x16f8>
 9085764:	003ccb06 	br	9084a94 <___vfprintf_internal_r+0xa6c>
 9085768:	00800c04 	movi	r2,48
 908576c:	d98018c4 	addi	r6,sp,99
 9085770:	dd000f04 	addi	r20,sp,60
 9085774:	d88018c5 	stb	r2,99(sp)
 9085778:	d9814115 	stw	r6,1284(sp)
 908577c:	003cc506 	br	9084a94 <___vfprintf_internal_r+0xa6c>
 9085780:	dc400d17 	ldw	r17,52(sp)
 9085784:	07024374 	movhi	fp,2317
 9085788:	e7356584 	addi	fp,fp,-10858
 908578c:	003bc706 	br	90846ac <___vfprintf_internal_r+0x684>
 9085790:	d9414c17 	ldw	r5,1328(sp)
 9085794:	2880040c 	andi	r2,r5,16
 9085798:	10007c26 	beq	r2,zero,908598c <___vfprintf_internal_r+0x1964>
 908579c:	38800017 	ldw	r2,0(r7)
 90857a0:	39c00104 	addi	r7,r7,4
 90857a4:	d9c14015 	stw	r7,1280(sp)
 90857a8:	d9814b17 	ldw	r6,1324(sp)
 90857ac:	d9c14017 	ldw	r7,1280(sp)
 90857b0:	11800015 	stw	r6,0(r2)
 90857b4:	003a7806 	br	9084198 <___vfprintf_internal_r+0x170>
 90857b8:	d9014f17 	ldw	r4,1340(sp)
 90857bc:	b00b883a 	mov	r5,r22
 90857c0:	d9800c04 	addi	r6,sp,48
 90857c4:	9083fd00 	call	9083fd0 <__sprint_r>
 90857c8:	103bcf1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90857cc:	dc800e17 	ldw	r18,56(sp)
 90857d0:	dc400d17 	ldw	r17,52(sp)
 90857d4:	d8c01904 	addi	r3,sp,100
 90857d8:	d9014717 	ldw	r4,1308(sp)
 90857dc:	d9414117 	ldw	r5,1284(sp)
 90857e0:	8c400044 	addi	r17,r17,1
 90857e4:	9125883a 	add	r18,r18,r4
 90857e8:	008001c4 	movi	r2,7
 90857ec:	19400015 	stw	r5,0(r3)
 90857f0:	19000115 	stw	r4,4(r3)
 90857f4:	dc800e15 	stw	r18,56(sp)
 90857f8:	dc400d15 	stw	r17,52(sp)
 90857fc:	147cee16 	blt	r2,r17,9084bb8 <___vfprintf_internal_r+0xb90>
 9085800:	18c00204 	addi	r3,r3,8
 9085804:	003b8606 	br	9084620 <___vfprintf_internal_r+0x5f8>
 9085808:	38c00017 	ldw	r3,0(r7)
 908580c:	39000204 	addi	r4,r7,8
 9085810:	d9014015 	stw	r4,1280(sp)
 9085814:	d8c14215 	stw	r3,1288(sp)
 9085818:	39c00117 	ldw	r7,4(r7)
 908581c:	d9c14315 	stw	r7,1292(sp)
 9085820:	003e2006 	br	90850a4 <___vfprintf_internal_r+0x107c>
 9085824:	0005883a 	mov	r2,zero
 9085828:	1409c83a 	sub	r4,r2,r16
 908582c:	1105803a 	cmpltu	r2,r2,r4
 9085830:	044bc83a 	sub	r5,zero,r17
 9085834:	2885c83a 	sub	r2,r5,r2
 9085838:	2021883a 	mov	r16,r4
 908583c:	1023883a 	mov	r17,r2
 9085840:	01000044 	movi	r4,1
 9085844:	00800b44 	movi	r2,45
 9085848:	d8800405 	stb	r2,16(sp)
 908584c:	003c8406 	br	9084a60 <___vfprintf_internal_r+0xa38>
 9085850:	d9014f17 	ldw	r4,1340(sp)
 9085854:	b00b883a 	mov	r5,r22
 9085858:	d9800c04 	addi	r6,sp,48
 908585c:	9083fd00 	call	9083fd0 <__sprint_r>
 9085860:	103ba91e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9085864:	dc800e17 	ldw	r18,56(sp)
 9085868:	dc400d17 	ldw	r17,52(sp)
 908586c:	d9000517 	ldw	r4,20(sp)
 9085870:	d9401904 	addi	r5,sp,100
 9085874:	003da706 	br	9084f14 <___vfprintf_internal_r+0xeec>
 9085878:	d9014f17 	ldw	r4,1340(sp)
 908587c:	b00b883a 	mov	r5,r22
 9085880:	d9800c04 	addi	r6,sp,48
 9085884:	9083fd00 	call	9083fd0 <__sprint_r>
 9085888:	103b9f1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 908588c:	dc800e17 	ldw	r18,56(sp)
 9085890:	dc400d17 	ldw	r17,52(sp)
 9085894:	d9000517 	ldw	r4,20(sp)
 9085898:	d8c01904 	addi	r3,sp,100
 908589c:	003d9106 	br	9084ee4 <___vfprintf_internal_r+0xebc>
 90858a0:	07024374 	movhi	fp,2317
 90858a4:	e7356184 	addi	fp,fp,-10874
 90858a8:	9425883a 	add	r18,r18,r16
 90858ac:	8c400044 	addi	r17,r17,1
 90858b0:	008001c4 	movi	r2,7
 90858b4:	1f000015 	stw	fp,0(r3)
 90858b8:	1c000115 	stw	r16,4(r3)
 90858bc:	dc800e15 	stw	r18,56(sp)
 90858c0:	dc400d15 	stw	r17,52(sp)
 90858c4:	147fbc16 	blt	r2,r17,90857b8 <___vfprintf_internal_r+0x1790>
 90858c8:	18c00204 	addi	r3,r3,8
 90858cc:	003fc206 	br	90857d8 <___vfprintf_internal_r+0x17b0>
 90858d0:	d9014f17 	ldw	r4,1340(sp)
 90858d4:	b00b883a 	mov	r5,r22
 90858d8:	d9800c04 	addi	r6,sp,48
 90858dc:	9083fd00 	call	9083fd0 <__sprint_r>
 90858e0:	103b891e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90858e4:	dc800e17 	ldw	r18,56(sp)
 90858e8:	d9000517 	ldw	r4,20(sp)
 90858ec:	d8c01904 	addi	r3,sp,100
 90858f0:	003d0206 	br	9084cfc <___vfprintf_internal_r+0xcd4>
 90858f4:	07024374 	movhi	fp,2317
 90858f8:	e7356184 	addi	fp,fp,-10874
 90858fc:	003be406 	br	9084890 <___vfprintf_internal_r+0x868>
 9085900:	00824374 	movhi	r2,2317
 9085904:	10b55004 	addi	r2,r2,-10944
 9085908:	d8814115 	stw	r2,1284(sp)
 908590c:	003df506 	br	90850e4 <___vfprintf_internal_r+0x10bc>
 9085910:	d9014217 	ldw	r4,1288(sp)
 9085914:	d9414317 	ldw	r5,1292(sp)
 9085918:	908ade80 	call	908ade8 <__isnand>
 908591c:	10003926 	beq	r2,zero,9085a04 <___vfprintf_internal_r+0x19dc>
 9085920:	d9414d17 	ldw	r5,1332(sp)
 9085924:	008011c4 	movi	r2,71
 9085928:	1140ce16 	blt	r2,r5,9085c64 <___vfprintf_internal_r+0x1c3c>
 908592c:	01824374 	movhi	r6,2317
 9085930:	31b55104 	addi	r6,r6,-10940
 9085934:	d9814115 	stw	r6,1284(sp)
 9085938:	003dea06 	br	90850e4 <___vfprintf_internal_r+0x10bc>
 908593c:	d9014c17 	ldw	r4,1328(sp)
 9085940:	bdc00044 	addi	r23,r23,1
 9085944:	b8c00007 	ldb	r3,0(r23)
 9085948:	21000814 	ori	r4,r4,32
 908594c:	d9014c15 	stw	r4,1328(sp)
 9085950:	003a3406 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085954:	dcc14515 	stw	r19,1300(sp)
 9085958:	98011016 	blt	r19,zero,9085d9c <___vfprintf_internal_r+0x1d74>
 908595c:	980f883a 	mov	r7,r19
 9085960:	d8014615 	stw	zero,1304(sp)
 9085964:	003c5206 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 9085968:	d9014f17 	ldw	r4,1340(sp)
 908596c:	b00b883a 	mov	r5,r22
 9085970:	d9800c04 	addi	r6,sp,48
 9085974:	9083fd00 	call	9083fd0 <__sprint_r>
 9085978:	103b631e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 908597c:	dc800e17 	ldw	r18,56(sp)
 9085980:	d9000517 	ldw	r4,20(sp)
 9085984:	d8c01904 	addi	r3,sp,100
 9085988:	003f2e06 	br	9085644 <___vfprintf_internal_r+0x161c>
 908598c:	d8c14c17 	ldw	r3,1328(sp)
 9085990:	1880100c 	andi	r2,r3,64
 9085994:	1000a026 	beq	r2,zero,9085c18 <___vfprintf_internal_r+0x1bf0>
 9085998:	38800017 	ldw	r2,0(r7)
 908599c:	39c00104 	addi	r7,r7,4
 90859a0:	d9c14015 	stw	r7,1280(sp)
 90859a4:	d9014b17 	ldw	r4,1324(sp)
 90859a8:	d9c14017 	ldw	r7,1280(sp)
 90859ac:	1100000d 	sth	r4,0(r2)
 90859b0:	0039f906 	br	9084198 <___vfprintf_internal_r+0x170>
 90859b4:	d9014f17 	ldw	r4,1340(sp)
 90859b8:	b00b883a 	mov	r5,r22
 90859bc:	d9800c04 	addi	r6,sp,48
 90859c0:	9083fd00 	call	9083fd0 <__sprint_r>
 90859c4:	103b501e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 90859c8:	dc800e17 	ldw	r18,56(sp)
 90859cc:	dc400d17 	ldw	r17,52(sp)
 90859d0:	d9000517 	ldw	r4,20(sp)
 90859d4:	d8c01904 	addi	r3,sp,100
 90859d8:	003f2d06 	br	9085690 <___vfprintf_internal_r+0x1668>
 90859dc:	00800184 	movi	r2,6
 90859e0:	14c09a36 	bltu	r2,r19,9085c4c <___vfprintf_internal_r+0x1c24>
 90859e4:	dcc14515 	stw	r19,1300(sp)
 90859e8:	9800010e 	bge	r19,zero,90859f0 <___vfprintf_internal_r+0x19c8>
 90859ec:	d8014515 	stw	zero,1300(sp)
 90859f0:	00824374 	movhi	r2,2317
 90859f4:	10b55304 	addi	r2,r2,-10932
 90859f8:	980f883a 	mov	r7,r19
 90859fc:	d8814115 	stw	r2,1284(sp)
 9085a00:	003a7806 	br	90843e4 <___vfprintf_internal_r+0x3bc>
 9085a04:	00bfffc4 	movi	r2,-1
 9085a08:	9880e226 	beq	r19,r2,9085d94 <___vfprintf_internal_r+0x1d6c>
 9085a0c:	d9414d17 	ldw	r5,1332(sp)
 9085a10:	008019c4 	movi	r2,103
 9085a14:	2880dc26 	beq	r5,r2,9085d88 <___vfprintf_internal_r+0x1d60>
 9085a18:	008011c4 	movi	r2,71
 9085a1c:	2880da26 	beq	r5,r2,9085d88 <___vfprintf_internal_r+0x1d60>
 9085a20:	d9414c17 	ldw	r5,1328(sp)
 9085a24:	d9014317 	ldw	r4,1292(sp)
 9085a28:	d9814217 	ldw	r6,1288(sp)
 9085a2c:	29404014 	ori	r5,r5,256
 9085a30:	d9414c15 	stw	r5,1328(sp)
 9085a34:	2000cc16 	blt	r4,zero,9085d68 <___vfprintf_internal_r+0x1d40>
 9085a38:	3021883a 	mov	r16,r6
 9085a3c:	2023883a 	mov	r17,r4
 9085a40:	0039883a 	mov	fp,zero
 9085a44:	d9414d17 	ldw	r5,1332(sp)
 9085a48:	00801984 	movi	r2,102
 9085a4c:	2880b726 	beq	r5,r2,9085d2c <___vfprintf_internal_r+0x1d04>
 9085a50:	00801184 	movi	r2,70
 9085a54:	2880b526 	beq	r5,r2,9085d2c <___vfprintf_internal_r+0x1d04>
 9085a58:	00801944 	movi	r2,101
 9085a5c:	2880c826 	beq	r5,r2,9085d80 <___vfprintf_internal_r+0x1d58>
 9085a60:	00801144 	movi	r2,69
 9085a64:	2880c626 	beq	r5,r2,9085d80 <___vfprintf_internal_r+0x1d58>
 9085a68:	9829883a 	mov	r20,r19
 9085a6c:	d9014f17 	ldw	r4,1340(sp)
 9085a70:	d8800504 	addi	r2,sp,20
 9085a74:	880d883a 	mov	r6,r17
 9085a78:	d8800115 	stw	r2,4(sp)
 9085a7c:	d8c00604 	addi	r3,sp,24
 9085a80:	d8800704 	addi	r2,sp,28
 9085a84:	800b883a 	mov	r5,r16
 9085a88:	01c00084 	movi	r7,2
 9085a8c:	d8c00215 	stw	r3,8(sp)
 9085a90:	d8800315 	stw	r2,12(sp)
 9085a94:	dd000015 	stw	r20,0(sp)
 9085a98:	90863980 	call	9086398 <_dtoa_r>
 9085a9c:	d9814d17 	ldw	r6,1332(sp)
 9085aa0:	d8814115 	stw	r2,1284(sp)
 9085aa4:	008019c4 	movi	r2,103
 9085aa8:	30809526 	beq	r6,r2,9085d00 <___vfprintf_internal_r+0x1cd8>
 9085aac:	d8c14d17 	ldw	r3,1332(sp)
 9085ab0:	008011c4 	movi	r2,71
 9085ab4:	18809226 	beq	r3,r2,9085d00 <___vfprintf_internal_r+0x1cd8>
 9085ab8:	d9414117 	ldw	r5,1284(sp)
 9085abc:	d9814d17 	ldw	r6,1332(sp)
 9085ac0:	00801984 	movi	r2,102
 9085ac4:	2d25883a 	add	r18,r5,r20
 9085ac8:	30808626 	beq	r6,r2,9085ce4 <___vfprintf_internal_r+0x1cbc>
 9085acc:	00801184 	movi	r2,70
 9085ad0:	30808426 	beq	r6,r2,9085ce4 <___vfprintf_internal_r+0x1cbc>
 9085ad4:	000d883a 	mov	r6,zero
 9085ad8:	000f883a 	mov	r7,zero
 9085adc:	880b883a 	mov	r5,r17
 9085ae0:	8009883a 	mov	r4,r16
 9085ae4:	908cbc00 	call	908cbc0 <__eqdf2>
 9085ae8:	1000751e 	bne	r2,zero,9085cc0 <___vfprintf_internal_r+0x1c98>
 9085aec:	9005883a 	mov	r2,r18
 9085af0:	dc800715 	stw	r18,28(sp)
 9085af4:	d9014117 	ldw	r4,1284(sp)
 9085af8:	d9414d17 	ldw	r5,1332(sp)
 9085afc:	00c019c4 	movi	r3,103
 9085b00:	1125c83a 	sub	r18,r2,r4
 9085b04:	28c06826 	beq	r5,r3,9085ca8 <___vfprintf_internal_r+0x1c80>
 9085b08:	008011c4 	movi	r2,71
 9085b0c:	28806626 	beq	r5,r2,9085ca8 <___vfprintf_internal_r+0x1c80>
 9085b10:	d9000517 	ldw	r4,20(sp)
 9085b14:	d8c14d17 	ldw	r3,1332(sp)
 9085b18:	00801944 	movi	r2,101
 9085b1c:	10c05516 	blt	r2,r3,9085c74 <___vfprintf_internal_r+0x1c4c>
 9085b20:	213fffc4 	addi	r4,r4,-1
 9085b24:	d9000515 	stw	r4,20(sp)
 9085b28:	d8c00805 	stb	r3,32(sp)
 9085b2c:	2021883a 	mov	r16,r4
 9085b30:	2000c116 	blt	r4,zero,9085e38 <___vfprintf_internal_r+0x1e10>
 9085b34:	00800ac4 	movi	r2,43
 9085b38:	d8800845 	stb	r2,33(sp)
 9085b3c:	00800244 	movi	r2,9
 9085b40:	1400af0e 	bge	r2,r16,9085e00 <___vfprintf_internal_r+0x1dd8>
 9085b44:	1027883a 	mov	r19,r2
 9085b48:	dc400b84 	addi	r17,sp,46
 9085b4c:	8009883a 	mov	r4,r16
 9085b50:	01400284 	movi	r5,10
 9085b54:	908d2a80 	call	908d2a8 <__modsi3>
 9085b58:	10800c04 	addi	r2,r2,48
 9085b5c:	8c7fffc4 	addi	r17,r17,-1
 9085b60:	8009883a 	mov	r4,r16
 9085b64:	01400284 	movi	r5,10
 9085b68:	88800005 	stb	r2,0(r17)
 9085b6c:	908d2480 	call	908d248 <__divsi3>
 9085b70:	1021883a 	mov	r16,r2
 9085b74:	98bff516 	blt	r19,r2,9085b4c <___vfprintf_internal_r+0x1b24>
 9085b78:	10c00c04 	addi	r3,r2,48
 9085b7c:	d88009c4 	addi	r2,sp,39
 9085b80:	108001c4 	addi	r2,r2,7
 9085b84:	897fffc4 	addi	r5,r17,-1
 9085b88:	88ffffc5 	stb	r3,-1(r17)
 9085b8c:	2880a72e 	bgeu	r5,r2,9085e2c <___vfprintf_internal_r+0x1e04>
 9085b90:	1009883a 	mov	r4,r2
 9085b94:	d9800804 	addi	r6,sp,32
 9085b98:	d8c00884 	addi	r3,sp,34
 9085b9c:	28800003 	ldbu	r2,0(r5)
 9085ba0:	29400044 	addi	r5,r5,1
 9085ba4:	18800005 	stb	r2,0(r3)
 9085ba8:	18c00044 	addi	r3,r3,1
 9085bac:	293ffb36 	bltu	r5,r4,9085b9c <___vfprintf_internal_r+0x1b74>
 9085bb0:	1987c83a 	sub	r3,r3,r6
 9085bb4:	00800044 	movi	r2,1
 9085bb8:	d8c14815 	stw	r3,1312(sp)
 9085bbc:	90cf883a 	add	r7,r18,r3
 9085bc0:	1480960e 	bge	r2,r18,9085e1c <___vfprintf_internal_r+0x1df4>
 9085bc4:	39c00044 	addi	r7,r7,1
 9085bc8:	d9c14515 	stw	r7,1300(sp)
 9085bcc:	38003416 	blt	r7,zero,9085ca0 <___vfprintf_internal_r+0x1c78>
 9085bd0:	e0803fcc 	andi	r2,fp,255
 9085bd4:	1080201c 	xori	r2,r2,128
 9085bd8:	10bfe004 	addi	r2,r2,-128
 9085bdc:	10004e26 	beq	r2,zero,9085d18 <___vfprintf_internal_r+0x1cf0>
 9085be0:	00800b44 	movi	r2,45
 9085be4:	dc814715 	stw	r18,1308(sp)
 9085be8:	d8014615 	stw	zero,1304(sp)
 9085bec:	d8800405 	stb	r2,16(sp)
 9085bf0:	003bb106 	br	9084ab8 <___vfprintf_internal_r+0xa90>
 9085bf4:	00800b44 	movi	r2,45
 9085bf8:	d8800405 	stb	r2,16(sp)
 9085bfc:	003d3306 	br	90850cc <___vfprintf_internal_r+0x10a4>
 9085c00:	d9014f17 	ldw	r4,1340(sp)
 9085c04:	b00b883a 	mov	r5,r22
 9085c08:	d9800c04 	addi	r6,sp,48
 9085c0c:	9083fd00 	call	9083fd0 <__sprint_r>
 9085c10:	103abd1e 	bne	r2,zero,9084708 <___vfprintf_internal_r+0x6e0>
 9085c14:	003abb06 	br	9084704 <___vfprintf_internal_r+0x6dc>
 9085c18:	38800017 	ldw	r2,0(r7)
 9085c1c:	39c00104 	addi	r7,r7,4
 9085c20:	d9c14015 	stw	r7,1280(sp)
 9085c24:	d9414b17 	ldw	r5,1324(sp)
 9085c28:	d9c14017 	ldw	r7,1280(sp)
 9085c2c:	11400015 	stw	r5,0(r2)
 9085c30:	00395906 	br	9084198 <___vfprintf_internal_r+0x170>
 9085c34:	980f883a 	mov	r7,r19
 9085c38:	dcc14515 	stw	r19,1300(sp)
 9085c3c:	d8014615 	stw	zero,1304(sp)
 9085c40:	003b9b06 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 9085c44:	0027883a 	mov	r19,zero
 9085c48:	00397806 	br	908422c <___vfprintf_internal_r+0x204>
 9085c4c:	00c24374 	movhi	r3,2317
 9085c50:	18f55304 	addi	r3,r3,-10932
 9085c54:	100f883a 	mov	r7,r2
 9085c58:	d8814515 	stw	r2,1300(sp)
 9085c5c:	d8c14115 	stw	r3,1284(sp)
 9085c60:	0039e006 	br	90843e4 <___vfprintf_internal_r+0x3bc>
 9085c64:	00824374 	movhi	r2,2317
 9085c68:	10b55204 	addi	r2,r2,-10936
 9085c6c:	d8814115 	stw	r2,1284(sp)
 9085c70:	003d1c06 	br	90850e4 <___vfprintf_internal_r+0x10bc>
 9085c74:	d9414d17 	ldw	r5,1332(sp)
 9085c78:	00801984 	movi	r2,102
 9085c7c:	28804926 	beq	r5,r2,9085da4 <___vfprintf_internal_r+0x1d7c>
 9085c80:	200f883a 	mov	r7,r4
 9085c84:	24805716 	blt	r4,r18,9085de4 <___vfprintf_internal_r+0x1dbc>
 9085c88:	d9414c17 	ldw	r5,1328(sp)
 9085c8c:	2880004c 	andi	r2,r5,1
 9085c90:	10000126 	beq	r2,zero,9085c98 <___vfprintf_internal_r+0x1c70>
 9085c94:	21c00044 	addi	r7,r4,1
 9085c98:	d9c14515 	stw	r7,1300(sp)
 9085c9c:	383fcc0e 	bge	r7,zero,9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085ca0:	d8014515 	stw	zero,1300(sp)
 9085ca4:	003fca06 	br	9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085ca8:	d9000517 	ldw	r4,20(sp)
 9085cac:	00bfff04 	movi	r2,-4
 9085cb0:	1100480e 	bge	r2,r4,9085dd4 <___vfprintf_internal_r+0x1dac>
 9085cb4:	99004716 	blt	r19,r4,9085dd4 <___vfprintf_internal_r+0x1dac>
 9085cb8:	d8c14d15 	stw	r3,1332(sp)
 9085cbc:	003ff006 	br	9085c80 <___vfprintf_internal_r+0x1c58>
 9085cc0:	d8800717 	ldw	r2,28(sp)
 9085cc4:	14bf8b2e 	bgeu	r2,r18,9085af4 <___vfprintf_internal_r+0x1acc>
 9085cc8:	9007883a 	mov	r3,r18
 9085ccc:	01000c04 	movi	r4,48
 9085cd0:	11000005 	stb	r4,0(r2)
 9085cd4:	10800044 	addi	r2,r2,1
 9085cd8:	d8800715 	stw	r2,28(sp)
 9085cdc:	18bffc1e 	bne	r3,r2,9085cd0 <___vfprintf_internal_r+0x1ca8>
 9085ce0:	003f8406 	br	9085af4 <___vfprintf_internal_r+0x1acc>
 9085ce4:	d8814117 	ldw	r2,1284(sp)
 9085ce8:	10c00007 	ldb	r3,0(r2)
 9085cec:	00800c04 	movi	r2,48
 9085cf0:	18805b26 	beq	r3,r2,9085e60 <___vfprintf_internal_r+0x1e38>
 9085cf4:	d9000517 	ldw	r4,20(sp)
 9085cf8:	9125883a 	add	r18,r18,r4
 9085cfc:	003f7506 	br	9085ad4 <___vfprintf_internal_r+0x1aac>
 9085d00:	d9014c17 	ldw	r4,1328(sp)
 9085d04:	2080004c 	andi	r2,r4,1
 9085d08:	1005003a 	cmpeq	r2,r2,zero
 9085d0c:	103f6a26 	beq	r2,zero,9085ab8 <___vfprintf_internal_r+0x1a90>
 9085d10:	d8800717 	ldw	r2,28(sp)
 9085d14:	003f7706 	br	9085af4 <___vfprintf_internal_r+0x1acc>
 9085d18:	d9c14515 	stw	r7,1300(sp)
 9085d1c:	38004d16 	blt	r7,zero,9085e54 <___vfprintf_internal_r+0x1e2c>
 9085d20:	dc814715 	stw	r18,1308(sp)
 9085d24:	d8014615 	stw	zero,1304(sp)
 9085d28:	003b6106 	br	9084ab0 <___vfprintf_internal_r+0xa88>
 9085d2c:	d9014f17 	ldw	r4,1340(sp)
 9085d30:	d8800504 	addi	r2,sp,20
 9085d34:	d8800115 	stw	r2,4(sp)
 9085d38:	d8c00604 	addi	r3,sp,24
 9085d3c:	d8800704 	addi	r2,sp,28
 9085d40:	800b883a 	mov	r5,r16
 9085d44:	880d883a 	mov	r6,r17
 9085d48:	01c000c4 	movi	r7,3
 9085d4c:	d8c00215 	stw	r3,8(sp)
 9085d50:	d8800315 	stw	r2,12(sp)
 9085d54:	dcc00015 	stw	r19,0(sp)
 9085d58:	9829883a 	mov	r20,r19
 9085d5c:	90863980 	call	9086398 <_dtoa_r>
 9085d60:	d8814115 	stw	r2,1284(sp)
 9085d64:	003f5106 	br	9085aac <___vfprintf_internal_r+0x1a84>
 9085d68:	d8c14217 	ldw	r3,1288(sp)
 9085d6c:	d9014317 	ldw	r4,1292(sp)
 9085d70:	07000b44 	movi	fp,45
 9085d74:	1821883a 	mov	r16,r3
 9085d78:	2460003c 	xorhi	r17,r4,32768
 9085d7c:	003f3106 	br	9085a44 <___vfprintf_internal_r+0x1a1c>
 9085d80:	9d000044 	addi	r20,r19,1
 9085d84:	003f3906 	br	9085a6c <___vfprintf_internal_r+0x1a44>
 9085d88:	983f251e 	bne	r19,zero,9085a20 <___vfprintf_internal_r+0x19f8>
 9085d8c:	04c00044 	movi	r19,1
 9085d90:	003f2306 	br	9085a20 <___vfprintf_internal_r+0x19f8>
 9085d94:	04c00184 	movi	r19,6
 9085d98:	003f2106 	br	9085a20 <___vfprintf_internal_r+0x19f8>
 9085d9c:	d8014515 	stw	zero,1300(sp)
 9085da0:	003eee06 	br	908595c <___vfprintf_internal_r+0x1934>
 9085da4:	200f883a 	mov	r7,r4
 9085da8:	0100370e 	bge	zero,r4,9085e88 <___vfprintf_internal_r+0x1e60>
 9085dac:	9800031e 	bne	r19,zero,9085dbc <___vfprintf_internal_r+0x1d94>
 9085db0:	d9814c17 	ldw	r6,1328(sp)
 9085db4:	3080004c 	andi	r2,r6,1
 9085db8:	103fb726 	beq	r2,zero,9085c98 <___vfprintf_internal_r+0x1c70>
 9085dbc:	20800044 	addi	r2,r4,1
 9085dc0:	98a7883a 	add	r19,r19,r2
 9085dc4:	dcc14515 	stw	r19,1300(sp)
 9085dc8:	980f883a 	mov	r7,r19
 9085dcc:	983f800e 	bge	r19,zero,9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085dd0:	003fb306 	br	9085ca0 <___vfprintf_internal_r+0x1c78>
 9085dd4:	d9814d17 	ldw	r6,1332(sp)
 9085dd8:	31bfff84 	addi	r6,r6,-2
 9085ddc:	d9814d15 	stw	r6,1332(sp)
 9085de0:	003f4c06 	br	9085b14 <___vfprintf_internal_r+0x1aec>
 9085de4:	0100180e 	bge	zero,r4,9085e48 <___vfprintf_internal_r+0x1e20>
 9085de8:	00800044 	movi	r2,1
 9085dec:	1485883a 	add	r2,r2,r18
 9085df0:	d8814515 	stw	r2,1300(sp)
 9085df4:	100f883a 	mov	r7,r2
 9085df8:	103f750e 	bge	r2,zero,9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085dfc:	003fa806 	br	9085ca0 <___vfprintf_internal_r+0x1c78>
 9085e00:	80c00c04 	addi	r3,r16,48
 9085e04:	00800c04 	movi	r2,48
 9085e08:	d8c008c5 	stb	r3,35(sp)
 9085e0c:	d9800804 	addi	r6,sp,32
 9085e10:	d8c00904 	addi	r3,sp,36
 9085e14:	d8800885 	stb	r2,34(sp)
 9085e18:	003f6506 	br	9085bb0 <___vfprintf_internal_r+0x1b88>
 9085e1c:	d9014c17 	ldw	r4,1328(sp)
 9085e20:	2084703a 	and	r2,r4,r2
 9085e24:	103f9c26 	beq	r2,zero,9085c98 <___vfprintf_internal_r+0x1c70>
 9085e28:	003f6606 	br	9085bc4 <___vfprintf_internal_r+0x1b9c>
 9085e2c:	d9800804 	addi	r6,sp,32
 9085e30:	d8c00884 	addi	r3,sp,34
 9085e34:	003f5e06 	br	9085bb0 <___vfprintf_internal_r+0x1b88>
 9085e38:	00800b44 	movi	r2,45
 9085e3c:	0121c83a 	sub	r16,zero,r4
 9085e40:	d8800845 	stb	r2,33(sp)
 9085e44:	003f3d06 	br	9085b3c <___vfprintf_internal_r+0x1b14>
 9085e48:	00800084 	movi	r2,2
 9085e4c:	1105c83a 	sub	r2,r2,r4
 9085e50:	003fe606 	br	9085dec <___vfprintf_internal_r+0x1dc4>
 9085e54:	d8014515 	stw	zero,1300(sp)
 9085e58:	dc814715 	stw	r18,1308(sp)
 9085e5c:	003fb106 	br	9085d24 <___vfprintf_internal_r+0x1cfc>
 9085e60:	000d883a 	mov	r6,zero
 9085e64:	000f883a 	mov	r7,zero
 9085e68:	8009883a 	mov	r4,r16
 9085e6c:	880b883a 	mov	r5,r17
 9085e70:	908cc480 	call	908cc48 <__nedf2>
 9085e74:	103f9f26 	beq	r2,zero,9085cf4 <___vfprintf_internal_r+0x1ccc>
 9085e78:	00800044 	movi	r2,1
 9085e7c:	1509c83a 	sub	r4,r2,r20
 9085e80:	d9000515 	stw	r4,20(sp)
 9085e84:	003f9b06 	br	9085cf4 <___vfprintf_internal_r+0x1ccc>
 9085e88:	98000d1e 	bne	r19,zero,9085ec0 <___vfprintf_internal_r+0x1e98>
 9085e8c:	d8c14c17 	ldw	r3,1328(sp)
 9085e90:	1880004c 	andi	r2,r3,1
 9085e94:	10000a1e 	bne	r2,zero,9085ec0 <___vfprintf_internal_r+0x1e98>
 9085e98:	01000044 	movi	r4,1
 9085e9c:	200f883a 	mov	r7,r4
 9085ea0:	d9014515 	stw	r4,1300(sp)
 9085ea4:	003f4a06 	br	9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085ea8:	3cc00017 	ldw	r19,0(r7)
 9085eac:	39c00104 	addi	r7,r7,4
 9085eb0:	983d0e0e 	bge	r19,zero,90852ec <___vfprintf_internal_r+0x12c4>
 9085eb4:	b8c00007 	ldb	r3,0(r23)
 9085eb8:	04ffffc4 	movi	r19,-1
 9085ebc:	0038d906 	br	9084224 <___vfprintf_internal_r+0x1fc>
 9085ec0:	9cc00084 	addi	r19,r19,2
 9085ec4:	dcc14515 	stw	r19,1300(sp)
 9085ec8:	980f883a 	mov	r7,r19
 9085ecc:	983f400e 	bge	r19,zero,9085bd0 <___vfprintf_internal_r+0x1ba8>
 9085ed0:	003f7306 	br	9085ca0 <___vfprintf_internal_r+0x1c78>

09085ed4 <__vfprintf_internal>:
 9085ed4:	00824374 	movhi	r2,2317
 9085ed8:	108e8604 	addi	r2,r2,14872
 9085edc:	2013883a 	mov	r9,r4
 9085ee0:	11000017 	ldw	r4,0(r2)
 9085ee4:	2805883a 	mov	r2,r5
 9085ee8:	300f883a 	mov	r7,r6
 9085eec:	480b883a 	mov	r5,r9
 9085ef0:	100d883a 	mov	r6,r2
 9085ef4:	90840281 	jmpi	9084028 <___vfprintf_internal_r>

09085ef8 <__swbuf_r>:
 9085ef8:	defffc04 	addi	sp,sp,-16
 9085efc:	dc400215 	stw	r17,8(sp)
 9085f00:	dc000115 	stw	r16,4(sp)
 9085f04:	dfc00315 	stw	ra,12(sp)
 9085f08:	2023883a 	mov	r17,r4
 9085f0c:	2821883a 	mov	r16,r5
 9085f10:	20000226 	beq	r4,zero,9085f1c <__swbuf_r+0x24>
 9085f14:	20800e17 	ldw	r2,56(r4)
 9085f18:	10002f26 	beq	r2,zero,9085fd8 <__swbuf_r+0xe0>
 9085f1c:	3080030b 	ldhu	r2,12(r6)
 9085f20:	30c00617 	ldw	r3,24(r6)
 9085f24:	1080020c 	andi	r2,r2,8
 9085f28:	30c00215 	stw	r3,8(r6)
 9085f2c:	10002226 	beq	r2,zero,9085fb8 <__swbuf_r+0xc0>
 9085f30:	30c00417 	ldw	r3,16(r6)
 9085f34:	18002026 	beq	r3,zero,9085fb8 <__swbuf_r+0xc0>
 9085f38:	31000017 	ldw	r4,0(r6)
 9085f3c:	30800517 	ldw	r2,20(r6)
 9085f40:	20c7c83a 	sub	r3,r4,r3
 9085f44:	18802f0e 	bge	r3,r2,9086004 <__swbuf_r+0x10c>
 9085f48:	19400044 	addi	r5,r3,1
 9085f4c:	30800217 	ldw	r2,8(r6)
 9085f50:	84003fcc 	andi	r16,r16,255
 9085f54:	20c00044 	addi	r3,r4,1
 9085f58:	10bfffc4 	addi	r2,r2,-1
 9085f5c:	30800215 	stw	r2,8(r6)
 9085f60:	24000005 	stb	r16,0(r4)
 9085f64:	30800517 	ldw	r2,20(r6)
 9085f68:	30c00015 	stw	r3,0(r6)
 9085f6c:	11400c26 	beq	r2,r5,9085fa0 <__swbuf_r+0xa8>
 9085f70:	3080030b 	ldhu	r2,12(r6)
 9085f74:	1080004c 	andi	r2,r2,1
 9085f78:	1005003a 	cmpeq	r2,r2,zero
 9085f7c:	10000626 	beq	r2,zero,9085f98 <__swbuf_r+0xa0>
 9085f80:	8005883a 	mov	r2,r16
 9085f84:	dfc00317 	ldw	ra,12(sp)
 9085f88:	dc400217 	ldw	r17,8(sp)
 9085f8c:	dc000117 	ldw	r16,4(sp)
 9085f90:	dec00404 	addi	sp,sp,16
 9085f94:	f800283a 	ret
 9085f98:	00800284 	movi	r2,10
 9085f9c:	80bff81e 	bne	r16,r2,9085f80 <__swbuf_r+0x88>
 9085fa0:	8809883a 	mov	r4,r17
 9085fa4:	300b883a 	mov	r5,r6
 9085fa8:	908794c0 	call	908794c <_fflush_r>
 9085fac:	103ff426 	beq	r2,zero,9085f80 <__swbuf_r+0x88>
 9085fb0:	043fffc4 	movi	r16,-1
 9085fb4:	003ff206 	br	9085f80 <__swbuf_r+0x88>
 9085fb8:	300b883a 	mov	r5,r6
 9085fbc:	8809883a 	mov	r4,r17
 9085fc0:	d9800015 	stw	r6,0(sp)
 9085fc4:	90860440 	call	9086044 <__swsetup_r>
 9085fc8:	d9800017 	ldw	r6,0(sp)
 9085fcc:	1000061e 	bne	r2,zero,9085fe8 <__swbuf_r+0xf0>
 9085fd0:	30c00417 	ldw	r3,16(r6)
 9085fd4:	003fd806 	br	9085f38 <__swbuf_r+0x40>
 9085fd8:	d9800015 	stw	r6,0(sp)
 9085fdc:	9087be40 	call	9087be4 <__sinit>
 9085fe0:	d9800017 	ldw	r6,0(sp)
 9085fe4:	003fcd06 	br	9085f1c <__swbuf_r+0x24>
 9085fe8:	3080030b 	ldhu	r2,12(r6)
 9085fec:	00c00244 	movi	r3,9
 9085ff0:	043fffc4 	movi	r16,-1
 9085ff4:	10801014 	ori	r2,r2,64
 9085ff8:	3080030d 	sth	r2,12(r6)
 9085ffc:	88c00015 	stw	r3,0(r17)
 9086000:	003fdf06 	br	9085f80 <__swbuf_r+0x88>
 9086004:	300b883a 	mov	r5,r6
 9086008:	8809883a 	mov	r4,r17
 908600c:	d9800015 	stw	r6,0(sp)
 9086010:	908794c0 	call	908794c <_fflush_r>
 9086014:	d9800017 	ldw	r6,0(sp)
 9086018:	103fe51e 	bne	r2,zero,9085fb0 <__swbuf_r+0xb8>
 908601c:	31000017 	ldw	r4,0(r6)
 9086020:	01400044 	movi	r5,1
 9086024:	003fc906 	br	9085f4c <__swbuf_r+0x54>

09086028 <__swbuf>:
 9086028:	01824374 	movhi	r6,2317
 908602c:	318e8604 	addi	r6,r6,14872
 9086030:	2007883a 	mov	r3,r4
 9086034:	31000017 	ldw	r4,0(r6)
 9086038:	280d883a 	mov	r6,r5
 908603c:	180b883a 	mov	r5,r3
 9086040:	9085ef81 	jmpi	9085ef8 <__swbuf_r>

09086044 <__swsetup_r>:
 9086044:	00824374 	movhi	r2,2317
 9086048:	108e8604 	addi	r2,r2,14872
 908604c:	10c00017 	ldw	r3,0(r2)
 9086050:	defffd04 	addi	sp,sp,-12
 9086054:	dc400115 	stw	r17,4(sp)
 9086058:	dc000015 	stw	r16,0(sp)
 908605c:	dfc00215 	stw	ra,8(sp)
 9086060:	2023883a 	mov	r17,r4
 9086064:	2821883a 	mov	r16,r5
 9086068:	18000226 	beq	r3,zero,9086074 <__swsetup_r+0x30>
 908606c:	18800e17 	ldw	r2,56(r3)
 9086070:	10001f26 	beq	r2,zero,90860f0 <__swsetup_r+0xac>
 9086074:	8100030b 	ldhu	r4,12(r16)
 9086078:	2080020c 	andi	r2,r4,8
 908607c:	10002826 	beq	r2,zero,9086120 <__swsetup_r+0xdc>
 9086080:	81400417 	ldw	r5,16(r16)
 9086084:	28001d26 	beq	r5,zero,90860fc <__swsetup_r+0xb8>
 9086088:	2080004c 	andi	r2,r4,1
 908608c:	1005003a 	cmpeq	r2,r2,zero
 9086090:	10000b26 	beq	r2,zero,90860c0 <__swsetup_r+0x7c>
 9086094:	2080008c 	andi	r2,r4,2
 9086098:	10001226 	beq	r2,zero,90860e4 <__swsetup_r+0xa0>
 908609c:	0005883a 	mov	r2,zero
 90860a0:	80800215 	stw	r2,8(r16)
 90860a4:	28000b26 	beq	r5,zero,90860d4 <__swsetup_r+0x90>
 90860a8:	0005883a 	mov	r2,zero
 90860ac:	dfc00217 	ldw	ra,8(sp)
 90860b0:	dc400117 	ldw	r17,4(sp)
 90860b4:	dc000017 	ldw	r16,0(sp)
 90860b8:	dec00304 	addi	sp,sp,12
 90860bc:	f800283a 	ret
 90860c0:	80800517 	ldw	r2,20(r16)
 90860c4:	80000215 	stw	zero,8(r16)
 90860c8:	0085c83a 	sub	r2,zero,r2
 90860cc:	80800615 	stw	r2,24(r16)
 90860d0:	283ff51e 	bne	r5,zero,90860a8 <__swsetup_r+0x64>
 90860d4:	2080200c 	andi	r2,r4,128
 90860d8:	103ff326 	beq	r2,zero,90860a8 <__swsetup_r+0x64>
 90860dc:	00bfffc4 	movi	r2,-1
 90860e0:	003ff206 	br	90860ac <__swsetup_r+0x68>
 90860e4:	80800517 	ldw	r2,20(r16)
 90860e8:	80800215 	stw	r2,8(r16)
 90860ec:	003fed06 	br	90860a4 <__swsetup_r+0x60>
 90860f0:	1809883a 	mov	r4,r3
 90860f4:	9087be40 	call	9087be4 <__sinit>
 90860f8:	003fde06 	br	9086074 <__swsetup_r+0x30>
 90860fc:	20c0a00c 	andi	r3,r4,640
 9086100:	00808004 	movi	r2,512
 9086104:	18bfe026 	beq	r3,r2,9086088 <__swsetup_r+0x44>
 9086108:	8809883a 	mov	r4,r17
 908610c:	800b883a 	mov	r5,r16
 9086110:	9088aa80 	call	9088aa8 <__smakebuf_r>
 9086114:	8100030b 	ldhu	r4,12(r16)
 9086118:	81400417 	ldw	r5,16(r16)
 908611c:	003fda06 	br	9086088 <__swsetup_r+0x44>
 9086120:	2080040c 	andi	r2,r4,16
 9086124:	103fed26 	beq	r2,zero,90860dc <__swsetup_r+0x98>
 9086128:	2080010c 	andi	r2,r4,4
 908612c:	10001226 	beq	r2,zero,9086178 <__swsetup_r+0x134>
 9086130:	81400c17 	ldw	r5,48(r16)
 9086134:	28000526 	beq	r5,zero,908614c <__swsetup_r+0x108>
 9086138:	80801004 	addi	r2,r16,64
 908613c:	28800226 	beq	r5,r2,9086148 <__swsetup_r+0x104>
 9086140:	8809883a 	mov	r4,r17
 9086144:	90880b40 	call	90880b4 <_free_r>
 9086148:	80000c15 	stw	zero,48(r16)
 908614c:	8080030b 	ldhu	r2,12(r16)
 9086150:	81400417 	ldw	r5,16(r16)
 9086154:	80000115 	stw	zero,4(r16)
 9086158:	10bff6cc 	andi	r2,r2,65499
 908615c:	8080030d 	sth	r2,12(r16)
 9086160:	81400015 	stw	r5,0(r16)
 9086164:	8080030b 	ldhu	r2,12(r16)
 9086168:	10800214 	ori	r2,r2,8
 908616c:	113fffcc 	andi	r4,r2,65535
 9086170:	8080030d 	sth	r2,12(r16)
 9086174:	003fc306 	br	9086084 <__swsetup_r+0x40>
 9086178:	81400417 	ldw	r5,16(r16)
 908617c:	003ff906 	br	9086164 <__swsetup_r+0x120>

09086180 <quorem>:
 9086180:	28c00417 	ldw	r3,16(r5)
 9086184:	20800417 	ldw	r2,16(r4)
 9086188:	defff604 	addi	sp,sp,-40
 908618c:	ddc00715 	stw	r23,28(sp)
 9086190:	dd400515 	stw	r21,20(sp)
 9086194:	dfc00915 	stw	ra,36(sp)
 9086198:	df000815 	stw	fp,32(sp)
 908619c:	dd800615 	stw	r22,24(sp)
 90861a0:	dd000415 	stw	r20,16(sp)
 90861a4:	dcc00315 	stw	r19,12(sp)
 90861a8:	dc800215 	stw	r18,8(sp)
 90861ac:	dc400115 	stw	r17,4(sp)
 90861b0:	dc000015 	stw	r16,0(sp)
 90861b4:	202f883a 	mov	r23,r4
 90861b8:	282b883a 	mov	r21,r5
 90861bc:	10c07416 	blt	r2,r3,9086390 <quorem+0x210>
 90861c0:	1c7fffc4 	addi	r17,r3,-1
 90861c4:	8c45883a 	add	r2,r17,r17
 90861c8:	1085883a 	add	r2,r2,r2
 90861cc:	2c000504 	addi	r16,r5,20
 90861d0:	24c00504 	addi	r19,r4,20
 90861d4:	14ed883a 	add	r22,r2,r19
 90861d8:	80a5883a 	add	r18,r16,r2
 90861dc:	b7000017 	ldw	fp,0(r22)
 90861e0:	91400017 	ldw	r5,0(r18)
 90861e4:	e009883a 	mov	r4,fp
 90861e8:	29400044 	addi	r5,r5,1
 90861ec:	908d3080 	call	908d308 <__udivsi3>
 90861f0:	1029883a 	mov	r20,r2
 90861f4:	10003c1e 	bne	r2,zero,90862e8 <quorem+0x168>
 90861f8:	a80b883a 	mov	r5,r21
 90861fc:	b809883a 	mov	r4,r23
 9086200:	908973c0 	call	908973c <__mcmp>
 9086204:	10002b16 	blt	r2,zero,90862b4 <quorem+0x134>
 9086208:	a5000044 	addi	r20,r20,1
 908620c:	980f883a 	mov	r7,r19
 9086210:	0011883a 	mov	r8,zero
 9086214:	0009883a 	mov	r4,zero
 9086218:	81400017 	ldw	r5,0(r16)
 908621c:	38c00017 	ldw	r3,0(r7)
 9086220:	84000104 	addi	r16,r16,4
 9086224:	28bfffcc 	andi	r2,r5,65535
 9086228:	2085883a 	add	r2,r4,r2
 908622c:	11bfffcc 	andi	r6,r2,65535
 9086230:	193fffcc 	andi	r4,r3,65535
 9086234:	1004d43a 	srli	r2,r2,16
 9086238:	280ad43a 	srli	r5,r5,16
 908623c:	2189c83a 	sub	r4,r4,r6
 9086240:	2209883a 	add	r4,r4,r8
 9086244:	1806d43a 	srli	r3,r3,16
 9086248:	288b883a 	add	r5,r5,r2
 908624c:	200dd43a 	srai	r6,r4,16
 9086250:	28bfffcc 	andi	r2,r5,65535
 9086254:	1887c83a 	sub	r3,r3,r2
 9086258:	1987883a 	add	r3,r3,r6
 908625c:	3900000d 	sth	r4,0(r7)
 9086260:	38c0008d 	sth	r3,2(r7)
 9086264:	2808d43a 	srli	r4,r5,16
 9086268:	39c00104 	addi	r7,r7,4
 908626c:	1811d43a 	srai	r8,r3,16
 9086270:	943fe92e 	bgeu	r18,r16,9086218 <quorem+0x98>
 9086274:	8c45883a 	add	r2,r17,r17
 9086278:	1085883a 	add	r2,r2,r2
 908627c:	9885883a 	add	r2,r19,r2
 9086280:	10c00017 	ldw	r3,0(r2)
 9086284:	18000b1e 	bne	r3,zero,90862b4 <quorem+0x134>
 9086288:	113fff04 	addi	r4,r2,-4
 908628c:	9900082e 	bgeu	r19,r4,90862b0 <quorem+0x130>
 9086290:	10bfff17 	ldw	r2,-4(r2)
 9086294:	10000326 	beq	r2,zero,90862a4 <quorem+0x124>
 9086298:	00000506 	br	90862b0 <quorem+0x130>
 908629c:	20800017 	ldw	r2,0(r4)
 90862a0:	1000031e 	bne	r2,zero,90862b0 <quorem+0x130>
 90862a4:	213fff04 	addi	r4,r4,-4
 90862a8:	8c7fffc4 	addi	r17,r17,-1
 90862ac:	993ffb36 	bltu	r19,r4,908629c <quorem+0x11c>
 90862b0:	bc400415 	stw	r17,16(r23)
 90862b4:	a005883a 	mov	r2,r20
 90862b8:	dfc00917 	ldw	ra,36(sp)
 90862bc:	df000817 	ldw	fp,32(sp)
 90862c0:	ddc00717 	ldw	r23,28(sp)
 90862c4:	dd800617 	ldw	r22,24(sp)
 90862c8:	dd400517 	ldw	r21,20(sp)
 90862cc:	dd000417 	ldw	r20,16(sp)
 90862d0:	dcc00317 	ldw	r19,12(sp)
 90862d4:	dc800217 	ldw	r18,8(sp)
 90862d8:	dc400117 	ldw	r17,4(sp)
 90862dc:	dc000017 	ldw	r16,0(sp)
 90862e0:	dec00a04 	addi	sp,sp,40
 90862e4:	f800283a 	ret
 90862e8:	980f883a 	mov	r7,r19
 90862ec:	8011883a 	mov	r8,r16
 90862f0:	0013883a 	mov	r9,zero
 90862f4:	000d883a 	mov	r6,zero
 90862f8:	40c00017 	ldw	r3,0(r8)
 90862fc:	39000017 	ldw	r4,0(r7)
 9086300:	42000104 	addi	r8,r8,4
 9086304:	18bfffcc 	andi	r2,r3,65535
 9086308:	a085383a 	mul	r2,r20,r2
 908630c:	1806d43a 	srli	r3,r3,16
 9086310:	217fffcc 	andi	r5,r4,65535
 9086314:	3085883a 	add	r2,r6,r2
 9086318:	11bfffcc 	andi	r6,r2,65535
 908631c:	a0c7383a 	mul	r3,r20,r3
 9086320:	1004d43a 	srli	r2,r2,16
 9086324:	298bc83a 	sub	r5,r5,r6
 9086328:	2a4b883a 	add	r5,r5,r9
 908632c:	2008d43a 	srli	r4,r4,16
 9086330:	1887883a 	add	r3,r3,r2
 9086334:	280dd43a 	srai	r6,r5,16
 9086338:	18bfffcc 	andi	r2,r3,65535
 908633c:	2089c83a 	sub	r4,r4,r2
 9086340:	2189883a 	add	r4,r4,r6
 9086344:	3900008d 	sth	r4,2(r7)
 9086348:	3940000d 	sth	r5,0(r7)
 908634c:	180cd43a 	srli	r6,r3,16
 9086350:	39c00104 	addi	r7,r7,4
 9086354:	2013d43a 	srai	r9,r4,16
 9086358:	923fe72e 	bgeu	r18,r8,90862f8 <quorem+0x178>
 908635c:	e03fa61e 	bne	fp,zero,90861f8 <quorem+0x78>
 9086360:	b0ffff04 	addi	r3,r22,-4
 9086364:	98c0082e 	bgeu	r19,r3,9086388 <quorem+0x208>
 9086368:	b0bfff17 	ldw	r2,-4(r22)
 908636c:	10000326 	beq	r2,zero,908637c <quorem+0x1fc>
 9086370:	00000506 	br	9086388 <quorem+0x208>
 9086374:	18800017 	ldw	r2,0(r3)
 9086378:	1000031e 	bne	r2,zero,9086388 <quorem+0x208>
 908637c:	18ffff04 	addi	r3,r3,-4
 9086380:	8c7fffc4 	addi	r17,r17,-1
 9086384:	98fffb36 	bltu	r19,r3,9086374 <quorem+0x1f4>
 9086388:	bc400415 	stw	r17,16(r23)
 908638c:	003f9a06 	br	90861f8 <quorem+0x78>
 9086390:	0005883a 	mov	r2,zero
 9086394:	003fc806 	br	90862b8 <quorem+0x138>

09086398 <_dtoa_r>:
 9086398:	22001017 	ldw	r8,64(r4)
 908639c:	deffda04 	addi	sp,sp,-152
 90863a0:	dd402115 	stw	r21,132(sp)
 90863a4:	dd002015 	stw	r20,128(sp)
 90863a8:	dc801e15 	stw	r18,120(sp)
 90863ac:	dc401d15 	stw	r17,116(sp)
 90863b0:	dfc02515 	stw	ra,148(sp)
 90863b4:	df002415 	stw	fp,144(sp)
 90863b8:	ddc02315 	stw	r23,140(sp)
 90863bc:	dd802215 	stw	r22,136(sp)
 90863c0:	dcc01f15 	stw	r19,124(sp)
 90863c4:	dc001c15 	stw	r16,112(sp)
 90863c8:	d9001615 	stw	r4,88(sp)
 90863cc:	3023883a 	mov	r17,r6
 90863d0:	2829883a 	mov	r20,r5
 90863d4:	d9c01715 	stw	r7,92(sp)
 90863d8:	dc802817 	ldw	r18,160(sp)
 90863dc:	302b883a 	mov	r21,r6
 90863e0:	40000a26 	beq	r8,zero,908640c <_dtoa_r+0x74>
 90863e4:	20801117 	ldw	r2,68(r4)
 90863e8:	400b883a 	mov	r5,r8
 90863ec:	40800115 	stw	r2,4(r8)
 90863f0:	20c01117 	ldw	r3,68(r4)
 90863f4:	00800044 	movi	r2,1
 90863f8:	10c4983a 	sll	r2,r2,r3
 90863fc:	40800215 	stw	r2,8(r8)
 9086400:	90895e00 	call	90895e0 <_Bfree>
 9086404:	d8c01617 	ldw	r3,88(sp)
 9086408:	18001015 	stw	zero,64(r3)
 908640c:	8800a316 	blt	r17,zero,908669c <_dtoa_r+0x304>
 9086410:	90000015 	stw	zero,0(r18)
 9086414:	a8dffc2c 	andhi	r3,r21,32752
 9086418:	009ffc34 	movhi	r2,32752
 908641c:	18809126 	beq	r3,r2,9086664 <_dtoa_r+0x2cc>
 9086420:	000d883a 	mov	r6,zero
 9086424:	000f883a 	mov	r7,zero
 9086428:	a009883a 	mov	r4,r20
 908642c:	a80b883a 	mov	r5,r21
 9086430:	dd001215 	stw	r20,72(sp)
 9086434:	dd401315 	stw	r21,76(sp)
 9086438:	908cc480 	call	908cc48 <__nedf2>
 908643c:	1000171e 	bne	r2,zero,908649c <_dtoa_r+0x104>
 9086440:	d9802717 	ldw	r6,156(sp)
 9086444:	00800044 	movi	r2,1
 9086448:	30800015 	stw	r2,0(r6)
 908644c:	d8802917 	ldw	r2,164(sp)
 9086450:	10029b26 	beq	r2,zero,9086ec0 <_dtoa_r+0xb28>
 9086454:	d9002917 	ldw	r4,164(sp)
 9086458:	00824374 	movhi	r2,2317
 908645c:	10b56144 	addi	r2,r2,-10875
 9086460:	10ffffc4 	addi	r3,r2,-1
 9086464:	20800015 	stw	r2,0(r4)
 9086468:	1805883a 	mov	r2,r3
 908646c:	dfc02517 	ldw	ra,148(sp)
 9086470:	df002417 	ldw	fp,144(sp)
 9086474:	ddc02317 	ldw	r23,140(sp)
 9086478:	dd802217 	ldw	r22,136(sp)
 908647c:	dd402117 	ldw	r21,132(sp)
 9086480:	dd002017 	ldw	r20,128(sp)
 9086484:	dcc01f17 	ldw	r19,124(sp)
 9086488:	dc801e17 	ldw	r18,120(sp)
 908648c:	dc401d17 	ldw	r17,116(sp)
 9086490:	dc001c17 	ldw	r16,112(sp)
 9086494:	dec02604 	addi	sp,sp,152
 9086498:	f800283a 	ret
 908649c:	d9001617 	ldw	r4,88(sp)
 90864a0:	d9401217 	ldw	r5,72(sp)
 90864a4:	d8800104 	addi	r2,sp,4
 90864a8:	a80d883a 	mov	r6,r21
 90864ac:	d9c00204 	addi	r7,sp,8
 90864b0:	d8800015 	stw	r2,0(sp)
 90864b4:	9089c1c0 	call	9089c1c <__d2b>
 90864b8:	d8800715 	stw	r2,28(sp)
 90864bc:	a804d53a 	srli	r2,r21,20
 90864c0:	1101ffcc 	andi	r4,r2,2047
 90864c4:	20008626 	beq	r4,zero,90866e0 <_dtoa_r+0x348>
 90864c8:	d8c01217 	ldw	r3,72(sp)
 90864cc:	00800434 	movhi	r2,16
 90864d0:	10bfffc4 	addi	r2,r2,-1
 90864d4:	ddc00117 	ldw	r23,4(sp)
 90864d8:	a884703a 	and	r2,r21,r2
 90864dc:	1811883a 	mov	r8,r3
 90864e0:	124ffc34 	orhi	r9,r2,16368
 90864e4:	25bf0044 	addi	r22,r4,-1023
 90864e8:	d8000815 	stw	zero,32(sp)
 90864ec:	0005883a 	mov	r2,zero
 90864f0:	00cffe34 	movhi	r3,16376
 90864f4:	480b883a 	mov	r5,r9
 90864f8:	4009883a 	mov	r4,r8
 90864fc:	180f883a 	mov	r7,r3
 9086500:	100d883a 	mov	r6,r2
 9086504:	908c4c00 	call	908c4c0 <__subdf3>
 9086508:	0218dbf4 	movhi	r8,25455
 908650c:	4210d844 	addi	r8,r8,17249
 9086510:	024ff4f4 	movhi	r9,16339
 9086514:	4a61e9c4 	addi	r9,r9,-30809
 9086518:	480f883a 	mov	r7,r9
 908651c:	400d883a 	mov	r6,r8
 9086520:	180b883a 	mov	r5,r3
 9086524:	1009883a 	mov	r4,r2
 9086528:	908c5b40 	call	908c5b4 <__muldf3>
 908652c:	0222d874 	movhi	r8,35681
 9086530:	42322cc4 	addi	r8,r8,-14157
 9086534:	024ff1f4 	movhi	r9,16327
 9086538:	4a628a04 	addi	r9,r9,-30168
 908653c:	480f883a 	mov	r7,r9
 9086540:	400d883a 	mov	r6,r8
 9086544:	180b883a 	mov	r5,r3
 9086548:	1009883a 	mov	r4,r2
 908654c:	908c5400 	call	908c540 <__adddf3>
 9086550:	b009883a 	mov	r4,r22
 9086554:	1021883a 	mov	r16,r2
 9086558:	1823883a 	mov	r17,r3
 908655c:	908ce680 	call	908ce68 <__floatsidf>
 9086560:	021427f4 	movhi	r8,20639
 9086564:	421e7ec4 	addi	r8,r8,31227
 9086568:	024ff4f4 	movhi	r9,16339
 908656c:	4a5104c4 	addi	r9,r9,17427
 9086570:	480f883a 	mov	r7,r9
 9086574:	400d883a 	mov	r6,r8
 9086578:	180b883a 	mov	r5,r3
 908657c:	1009883a 	mov	r4,r2
 9086580:	908c5b40 	call	908c5b4 <__muldf3>
 9086584:	180f883a 	mov	r7,r3
 9086588:	880b883a 	mov	r5,r17
 908658c:	100d883a 	mov	r6,r2
 9086590:	8009883a 	mov	r4,r16
 9086594:	908c5400 	call	908c540 <__adddf3>
 9086598:	1009883a 	mov	r4,r2
 908659c:	180b883a 	mov	r5,r3
 90865a0:	1021883a 	mov	r16,r2
 90865a4:	1823883a 	mov	r17,r3
 90865a8:	908cf600 	call	908cf60 <__fixdfsi>
 90865ac:	000d883a 	mov	r6,zero
 90865b0:	000f883a 	mov	r7,zero
 90865b4:	8009883a 	mov	r4,r16
 90865b8:	880b883a 	mov	r5,r17
 90865bc:	d8800d15 	stw	r2,52(sp)
 90865c0:	908cde00 	call	908cde0 <__ltdf2>
 90865c4:	10031716 	blt	r2,zero,9087224 <_dtoa_r+0xe8c>
 90865c8:	d8c00d17 	ldw	r3,52(sp)
 90865cc:	00800584 	movi	r2,22
 90865d0:	10c1482e 	bgeu	r2,r3,9086af4 <_dtoa_r+0x75c>
 90865d4:	01000044 	movi	r4,1
 90865d8:	d9000c15 	stw	r4,48(sp)
 90865dc:	bd85c83a 	sub	r2,r23,r22
 90865e0:	11bfffc4 	addi	r6,r2,-1
 90865e4:	30030b16 	blt	r6,zero,9087214 <_dtoa_r+0xe7c>
 90865e8:	d9800a15 	stw	r6,40(sp)
 90865ec:	d8001115 	stw	zero,68(sp)
 90865f0:	d8c00d17 	ldw	r3,52(sp)
 90865f4:	1802ff16 	blt	r3,zero,90871f4 <_dtoa_r+0xe5c>
 90865f8:	d9000a17 	ldw	r4,40(sp)
 90865fc:	d8c00915 	stw	r3,36(sp)
 9086600:	d8001015 	stw	zero,64(sp)
 9086604:	20c9883a 	add	r4,r4,r3
 9086608:	d9000a15 	stw	r4,40(sp)
 908660c:	d9001717 	ldw	r4,92(sp)
 9086610:	00800244 	movi	r2,9
 9086614:	11004636 	bltu	r2,r4,9086730 <_dtoa_r+0x398>
 9086618:	00800144 	movi	r2,5
 908661c:	11020416 	blt	r2,r4,9086e30 <_dtoa_r+0xa98>
 9086620:	04400044 	movi	r17,1
 9086624:	d8c01717 	ldw	r3,92(sp)
 9086628:	00800144 	movi	r2,5
 908662c:	10c1ed36 	bltu	r2,r3,9086de4 <_dtoa_r+0xa4c>
 9086630:	18c5883a 	add	r2,r3,r3
 9086634:	1085883a 	add	r2,r2,r2
 9086638:	00c24234 	movhi	r3,2312
 908663c:	18d99304 	addi	r3,r3,26188
 9086640:	10c5883a 	add	r2,r2,r3
 9086644:	11000017 	ldw	r4,0(r2)
 9086648:	2000683a 	jmp	r4
 908664c:	09086738 	rdprs	r4,at,8604
 9086650:	09086738 	rdprs	r4,at,8604
 9086654:	09087138 	rdprs	r4,at,8644
 9086658:	09087110 	cmplti	r4,at,8644
 908665c:	09087154 	ori	r4,at,8645
 9086660:	09087160 	cmpeqi	r4,at,8645
 9086664:	d9002717 	ldw	r4,156(sp)
 9086668:	0089c3c4 	movi	r2,9999
 908666c:	20800015 	stw	r2,0(r4)
 9086670:	a0001026 	beq	r20,zero,90866b4 <_dtoa_r+0x31c>
 9086674:	00c24374 	movhi	r3,2317
 9086678:	18f56d04 	addi	r3,r3,-10828
 908667c:	d9802917 	ldw	r6,164(sp)
 9086680:	303f7926 	beq	r6,zero,9086468 <_dtoa_r+0xd0>
 9086684:	188000c7 	ldb	r2,3(r3)
 9086688:	190000c4 	addi	r4,r3,3
 908668c:	1000101e 	bne	r2,zero,90866d0 <_dtoa_r+0x338>
 9086690:	d8802917 	ldw	r2,164(sp)
 9086694:	11000015 	stw	r4,0(r2)
 9086698:	003f7306 	br	9086468 <_dtoa_r+0xd0>
 908669c:	00a00034 	movhi	r2,32768
 90866a0:	10bfffc4 	addi	r2,r2,-1
 90866a4:	00c00044 	movi	r3,1
 90866a8:	88aa703a 	and	r21,r17,r2
 90866ac:	90c00015 	stw	r3,0(r18)
 90866b0:	003f5806 	br	9086414 <_dtoa_r+0x7c>
 90866b4:	00800434 	movhi	r2,16
 90866b8:	10bfffc4 	addi	r2,r2,-1
 90866bc:	a884703a 	and	r2,r21,r2
 90866c0:	103fec1e 	bne	r2,zero,9086674 <_dtoa_r+0x2dc>
 90866c4:	00c24374 	movhi	r3,2317
 90866c8:	18f56a04 	addi	r3,r3,-10840
 90866cc:	003feb06 	br	908667c <_dtoa_r+0x2e4>
 90866d0:	d8802917 	ldw	r2,164(sp)
 90866d4:	19000204 	addi	r4,r3,8
 90866d8:	11000015 	stw	r4,0(r2)
 90866dc:	003f6206 	br	9086468 <_dtoa_r+0xd0>
 90866e0:	ddc00117 	ldw	r23,4(sp)
 90866e4:	d8800217 	ldw	r2,8(sp)
 90866e8:	01000804 	movi	r4,32
 90866ec:	b8c10c84 	addi	r3,r23,1074
 90866f0:	18a3883a 	add	r17,r3,r2
 90866f4:	2441b80e 	bge	r4,r17,9086dd8 <_dtoa_r+0xa40>
 90866f8:	00c01004 	movi	r3,64
 90866fc:	1c47c83a 	sub	r3,r3,r17
 9086700:	88bff804 	addi	r2,r17,-32
 9086704:	a8c6983a 	sll	r3,r21,r3
 9086708:	a084d83a 	srl	r2,r20,r2
 908670c:	1888b03a 	or	r4,r3,r2
 9086710:	908d0380 	call	908d038 <__floatunsidf>
 9086714:	1011883a 	mov	r8,r2
 9086718:	00bf8434 	movhi	r2,65040
 908671c:	01000044 	movi	r4,1
 9086720:	10d3883a 	add	r9,r2,r3
 9086724:	8dbef344 	addi	r22,r17,-1075
 9086728:	d9000815 	stw	r4,32(sp)
 908672c:	003f6f06 	br	90864ec <_dtoa_r+0x154>
 9086730:	d8001715 	stw	zero,92(sp)
 9086734:	04400044 	movi	r17,1
 9086738:	00bfffc4 	movi	r2,-1
 908673c:	00c00044 	movi	r3,1
 9086740:	d8800e15 	stw	r2,56(sp)
 9086744:	d8002615 	stw	zero,152(sp)
 9086748:	d8800f15 	stw	r2,60(sp)
 908674c:	d8c00b15 	stw	r3,44(sp)
 9086750:	1021883a 	mov	r16,r2
 9086754:	d8801617 	ldw	r2,88(sp)
 9086758:	10001115 	stw	zero,68(r2)
 908675c:	d8801617 	ldw	r2,88(sp)
 9086760:	11401117 	ldw	r5,68(r2)
 9086764:	1009883a 	mov	r4,r2
 9086768:	9089b600 	call	9089b60 <_Balloc>
 908676c:	d8c01617 	ldw	r3,88(sp)
 9086770:	d8800515 	stw	r2,20(sp)
 9086774:	18801015 	stw	r2,64(r3)
 9086778:	00800384 	movi	r2,14
 908677c:	14006836 	bltu	r2,r16,9086920 <_dtoa_r+0x588>
 9086780:	8805003a 	cmpeq	r2,r17,zero
 9086784:	1000661e 	bne	r2,zero,9086920 <_dtoa_r+0x588>
 9086788:	d9000d17 	ldw	r4,52(sp)
 908678c:	0102300e 	bge	zero,r4,9087050 <_dtoa_r+0xcb8>
 9086790:	208003cc 	andi	r2,r4,15
 9086794:	100490fa 	slli	r2,r2,3
 9086798:	2025d13a 	srai	r18,r4,4
 908679c:	00c24374 	movhi	r3,2317
 90867a0:	18f57e04 	addi	r3,r3,-10760
 90867a4:	10c5883a 	add	r2,r2,r3
 90867a8:	90c0040c 	andi	r3,r18,16
 90867ac:	14000017 	ldw	r16,0(r2)
 90867b0:	14400117 	ldw	r17,4(r2)
 90867b4:	18036a1e 	bne	r3,zero,9087560 <_dtoa_r+0x11c8>
 90867b8:	05800084 	movi	r22,2
 90867bc:	90001026 	beq	r18,zero,9086800 <_dtoa_r+0x468>
 90867c0:	04c24374 	movhi	r19,2317
 90867c4:	9cf5b004 	addi	r19,r19,-10560
 90867c8:	9080004c 	andi	r2,r18,1
 90867cc:	1005003a 	cmpeq	r2,r2,zero
 90867d0:	1000081e 	bne	r2,zero,90867f4 <_dtoa_r+0x45c>
 90867d4:	99800017 	ldw	r6,0(r19)
 90867d8:	99c00117 	ldw	r7,4(r19)
 90867dc:	880b883a 	mov	r5,r17
 90867e0:	8009883a 	mov	r4,r16
 90867e4:	908c5b40 	call	908c5b4 <__muldf3>
 90867e8:	1021883a 	mov	r16,r2
 90867ec:	b5800044 	addi	r22,r22,1
 90867f0:	1823883a 	mov	r17,r3
 90867f4:	9025d07a 	srai	r18,r18,1
 90867f8:	9cc00204 	addi	r19,r19,8
 90867fc:	903ff21e 	bne	r18,zero,90867c8 <_dtoa_r+0x430>
 9086800:	a80b883a 	mov	r5,r21
 9086804:	a009883a 	mov	r4,r20
 9086808:	880f883a 	mov	r7,r17
 908680c:	800d883a 	mov	r6,r16
 9086810:	908c9680 	call	908c968 <__divdf3>
 9086814:	1029883a 	mov	r20,r2
 9086818:	182b883a 	mov	r21,r3
 908681c:	d8c00c17 	ldw	r3,48(sp)
 9086820:	1805003a 	cmpeq	r2,r3,zero
 9086824:	1000081e 	bne	r2,zero,9086848 <_dtoa_r+0x4b0>
 9086828:	0005883a 	mov	r2,zero
 908682c:	00cffc34 	movhi	r3,16368
 9086830:	180f883a 	mov	r7,r3
 9086834:	a009883a 	mov	r4,r20
 9086838:	a80b883a 	mov	r5,r21
 908683c:	100d883a 	mov	r6,r2
 9086840:	908cde00 	call	908cde0 <__ltdf2>
 9086844:	1003fe16 	blt	r2,zero,9087840 <_dtoa_r+0x14a8>
 9086848:	b009883a 	mov	r4,r22
 908684c:	908ce680 	call	908ce68 <__floatsidf>
 9086850:	180b883a 	mov	r5,r3
 9086854:	1009883a 	mov	r4,r2
 9086858:	a00d883a 	mov	r6,r20
 908685c:	a80f883a 	mov	r7,r21
 9086860:	908c5b40 	call	908c5b4 <__muldf3>
 9086864:	0011883a 	mov	r8,zero
 9086868:	02500734 	movhi	r9,16412
 908686c:	1009883a 	mov	r4,r2
 9086870:	180b883a 	mov	r5,r3
 9086874:	480f883a 	mov	r7,r9
 9086878:	400d883a 	mov	r6,r8
 908687c:	908c5400 	call	908c540 <__adddf3>
 9086880:	d9000f17 	ldw	r4,60(sp)
 9086884:	102d883a 	mov	r22,r2
 9086888:	00bf3034 	movhi	r2,64704
 908688c:	18b9883a 	add	fp,r3,r2
 9086890:	e02f883a 	mov	r23,fp
 9086894:	20028f1e 	bne	r4,zero,90872d4 <_dtoa_r+0xf3c>
 9086898:	0005883a 	mov	r2,zero
 908689c:	00d00534 	movhi	r3,16404
 90868a0:	a009883a 	mov	r4,r20
 90868a4:	a80b883a 	mov	r5,r21
 90868a8:	180f883a 	mov	r7,r3
 90868ac:	100d883a 	mov	r6,r2
 90868b0:	908c4c00 	call	908c4c0 <__subdf3>
 90868b4:	1009883a 	mov	r4,r2
 90868b8:	e00f883a 	mov	r7,fp
 90868bc:	180b883a 	mov	r5,r3
 90868c0:	b00d883a 	mov	r6,r22
 90868c4:	1025883a 	mov	r18,r2
 90868c8:	1827883a 	mov	r19,r3
 90868cc:	908ccd00 	call	908ccd0 <__gtdf2>
 90868d0:	00834f16 	blt	zero,r2,9087610 <_dtoa_r+0x1278>
 90868d4:	e0e0003c 	xorhi	r3,fp,32768
 90868d8:	9009883a 	mov	r4,r18
 90868dc:	980b883a 	mov	r5,r19
 90868e0:	180f883a 	mov	r7,r3
 90868e4:	b00d883a 	mov	r6,r22
 90868e8:	908cde00 	call	908cde0 <__ltdf2>
 90868ec:	1000080e 	bge	r2,zero,9086910 <_dtoa_r+0x578>
 90868f0:	0027883a 	mov	r19,zero
 90868f4:	0025883a 	mov	r18,zero
 90868f8:	d8802617 	ldw	r2,152(sp)
 90868fc:	df000517 	ldw	fp,20(sp)
 9086900:	d8000615 	stw	zero,24(sp)
 9086904:	0084303a 	nor	r2,zero,r2
 9086908:	d8800d15 	stw	r2,52(sp)
 908690c:	00019b06 	br	9086f7c <_dtoa_r+0xbe4>
 9086910:	d9801217 	ldw	r6,72(sp)
 9086914:	d8801317 	ldw	r2,76(sp)
 9086918:	3029883a 	mov	r20,r6
 908691c:	102b883a 	mov	r21,r2
 9086920:	d8c00217 	ldw	r3,8(sp)
 9086924:	18008516 	blt	r3,zero,9086b3c <_dtoa_r+0x7a4>
 9086928:	d9000d17 	ldw	r4,52(sp)
 908692c:	00800384 	movi	r2,14
 9086930:	11008216 	blt	r2,r4,9086b3c <_dtoa_r+0x7a4>
 9086934:	200490fa 	slli	r2,r4,3
 9086938:	d9802617 	ldw	r6,152(sp)
 908693c:	00c24374 	movhi	r3,2317
 9086940:	18f57e04 	addi	r3,r3,-10760
 9086944:	10c5883a 	add	r2,r2,r3
 9086948:	14800017 	ldw	r18,0(r2)
 908694c:	14c00117 	ldw	r19,4(r2)
 9086950:	30031e16 	blt	r6,zero,90875cc <_dtoa_r+0x1234>
 9086954:	d9000517 	ldw	r4,20(sp)
 9086958:	d8c00f17 	ldw	r3,60(sp)
 908695c:	a823883a 	mov	r17,r21
 9086960:	a021883a 	mov	r16,r20
 9086964:	192b883a 	add	r21,r3,r4
 9086968:	2039883a 	mov	fp,r4
 908696c:	00000f06 	br	90869ac <_dtoa_r+0x614>
 9086970:	0005883a 	mov	r2,zero
 9086974:	00d00934 	movhi	r3,16420
 9086978:	5009883a 	mov	r4,r10
 908697c:	580b883a 	mov	r5,r11
 9086980:	180f883a 	mov	r7,r3
 9086984:	100d883a 	mov	r6,r2
 9086988:	908c5b40 	call	908c5b4 <__muldf3>
 908698c:	180b883a 	mov	r5,r3
 9086990:	000d883a 	mov	r6,zero
 9086994:	000f883a 	mov	r7,zero
 9086998:	1009883a 	mov	r4,r2
 908699c:	1021883a 	mov	r16,r2
 90869a0:	1823883a 	mov	r17,r3
 90869a4:	908cc480 	call	908cc48 <__nedf2>
 90869a8:	10004526 	beq	r2,zero,9086ac0 <_dtoa_r+0x728>
 90869ac:	900d883a 	mov	r6,r18
 90869b0:	980f883a 	mov	r7,r19
 90869b4:	8009883a 	mov	r4,r16
 90869b8:	880b883a 	mov	r5,r17
 90869bc:	908c9680 	call	908c968 <__divdf3>
 90869c0:	180b883a 	mov	r5,r3
 90869c4:	1009883a 	mov	r4,r2
 90869c8:	908cf600 	call	908cf60 <__fixdfsi>
 90869cc:	1009883a 	mov	r4,r2
 90869d0:	1029883a 	mov	r20,r2
 90869d4:	908ce680 	call	908ce68 <__floatsidf>
 90869d8:	180f883a 	mov	r7,r3
 90869dc:	9009883a 	mov	r4,r18
 90869e0:	980b883a 	mov	r5,r19
 90869e4:	100d883a 	mov	r6,r2
 90869e8:	908c5b40 	call	908c5b4 <__muldf3>
 90869ec:	180f883a 	mov	r7,r3
 90869f0:	880b883a 	mov	r5,r17
 90869f4:	8009883a 	mov	r4,r16
 90869f8:	100d883a 	mov	r6,r2
 90869fc:	908c4c00 	call	908c4c0 <__subdf3>
 9086a00:	1015883a 	mov	r10,r2
 9086a04:	a0800c04 	addi	r2,r20,48
 9086a08:	e0800005 	stb	r2,0(fp)
 9086a0c:	e7000044 	addi	fp,fp,1
 9086a10:	1817883a 	mov	r11,r3
 9086a14:	e57fd61e 	bne	fp,r21,9086970 <_dtoa_r+0x5d8>
 9086a18:	500d883a 	mov	r6,r10
 9086a1c:	180f883a 	mov	r7,r3
 9086a20:	5009883a 	mov	r4,r10
 9086a24:	180b883a 	mov	r5,r3
 9086a28:	908c5400 	call	908c540 <__adddf3>
 9086a2c:	100d883a 	mov	r6,r2
 9086a30:	9009883a 	mov	r4,r18
 9086a34:	980b883a 	mov	r5,r19
 9086a38:	180f883a 	mov	r7,r3
 9086a3c:	1021883a 	mov	r16,r2
 9086a40:	1823883a 	mov	r17,r3
 9086a44:	908cde00 	call	908cde0 <__ltdf2>
 9086a48:	10000816 	blt	r2,zero,9086a6c <_dtoa_r+0x6d4>
 9086a4c:	980b883a 	mov	r5,r19
 9086a50:	800d883a 	mov	r6,r16
 9086a54:	880f883a 	mov	r7,r17
 9086a58:	9009883a 	mov	r4,r18
 9086a5c:	908cbc00 	call	908cbc0 <__eqdf2>
 9086a60:	1000171e 	bne	r2,zero,9086ac0 <_dtoa_r+0x728>
 9086a64:	a080004c 	andi	r2,r20,1
 9086a68:	10001526 	beq	r2,zero,9086ac0 <_dtoa_r+0x728>
 9086a6c:	d8800d17 	ldw	r2,52(sp)
 9086a70:	d8800415 	stw	r2,16(sp)
 9086a74:	e009883a 	mov	r4,fp
 9086a78:	213fffc4 	addi	r4,r4,-1
 9086a7c:	20c00007 	ldb	r3,0(r4)
 9086a80:	00800e44 	movi	r2,57
 9086a84:	1880081e 	bne	r3,r2,9086aa8 <_dtoa_r+0x710>
 9086a88:	d8800517 	ldw	r2,20(sp)
 9086a8c:	113ffa1e 	bne	r2,r4,9086a78 <_dtoa_r+0x6e0>
 9086a90:	d8c00417 	ldw	r3,16(sp)
 9086a94:	d9800517 	ldw	r6,20(sp)
 9086a98:	00800c04 	movi	r2,48
 9086a9c:	18c00044 	addi	r3,r3,1
 9086aa0:	d8c00415 	stw	r3,16(sp)
 9086aa4:	30800005 	stb	r2,0(r6)
 9086aa8:	20800003 	ldbu	r2,0(r4)
 9086aac:	d8c00417 	ldw	r3,16(sp)
 9086ab0:	27000044 	addi	fp,r4,1
 9086ab4:	10800044 	addi	r2,r2,1
 9086ab8:	d8c00d15 	stw	r3,52(sp)
 9086abc:	20800005 	stb	r2,0(r4)
 9086ac0:	d9001617 	ldw	r4,88(sp)
 9086ac4:	d9400717 	ldw	r5,28(sp)
 9086ac8:	90895e00 	call	90895e0 <_Bfree>
 9086acc:	e0000005 	stb	zero,0(fp)
 9086ad0:	d9800d17 	ldw	r6,52(sp)
 9086ad4:	d8c02717 	ldw	r3,156(sp)
 9086ad8:	d9002917 	ldw	r4,164(sp)
 9086adc:	30800044 	addi	r2,r6,1
 9086ae0:	18800015 	stw	r2,0(r3)
 9086ae4:	20029c26 	beq	r4,zero,9087558 <_dtoa_r+0x11c0>
 9086ae8:	d8c00517 	ldw	r3,20(sp)
 9086aec:	27000015 	stw	fp,0(r4)
 9086af0:	003e5d06 	br	9086468 <_dtoa_r+0xd0>
 9086af4:	d9800d17 	ldw	r6,52(sp)
 9086af8:	00c24374 	movhi	r3,2317
 9086afc:	18f57e04 	addi	r3,r3,-10760
 9086b00:	d9001217 	ldw	r4,72(sp)
 9086b04:	300490fa 	slli	r2,r6,3
 9086b08:	d9401317 	ldw	r5,76(sp)
 9086b0c:	10c5883a 	add	r2,r2,r3
 9086b10:	12000017 	ldw	r8,0(r2)
 9086b14:	12400117 	ldw	r9,4(r2)
 9086b18:	400d883a 	mov	r6,r8
 9086b1c:	480f883a 	mov	r7,r9
 9086b20:	908cde00 	call	908cde0 <__ltdf2>
 9086b24:	1000030e 	bge	r2,zero,9086b34 <_dtoa_r+0x79c>
 9086b28:	d8800d17 	ldw	r2,52(sp)
 9086b2c:	10bfffc4 	addi	r2,r2,-1
 9086b30:	d8800d15 	stw	r2,52(sp)
 9086b34:	d8000c15 	stw	zero,48(sp)
 9086b38:	003ea806 	br	90865dc <_dtoa_r+0x244>
 9086b3c:	d9000b17 	ldw	r4,44(sp)
 9086b40:	202cc03a 	cmpne	r22,r4,zero
 9086b44:	b000c71e 	bne	r22,zero,9086e64 <_dtoa_r+0xacc>
 9086b48:	dc001117 	ldw	r16,68(sp)
 9086b4c:	dc801017 	ldw	r18,64(sp)
 9086b50:	0027883a 	mov	r19,zero
 9086b54:	04000b0e 	bge	zero,r16,9086b84 <_dtoa_r+0x7ec>
 9086b58:	d8c00a17 	ldw	r3,40(sp)
 9086b5c:	00c0090e 	bge	zero,r3,9086b84 <_dtoa_r+0x7ec>
 9086b60:	8005883a 	mov	r2,r16
 9086b64:	1c011316 	blt	r3,r16,9086fb4 <_dtoa_r+0xc1c>
 9086b68:	d9000a17 	ldw	r4,40(sp)
 9086b6c:	d9801117 	ldw	r6,68(sp)
 9086b70:	80a1c83a 	sub	r16,r16,r2
 9086b74:	2089c83a 	sub	r4,r4,r2
 9086b78:	308dc83a 	sub	r6,r6,r2
 9086b7c:	d9000a15 	stw	r4,40(sp)
 9086b80:	d9801115 	stw	r6,68(sp)
 9086b84:	d8801017 	ldw	r2,64(sp)
 9086b88:	0080150e 	bge	zero,r2,9086be0 <_dtoa_r+0x848>
 9086b8c:	d8c00b17 	ldw	r3,44(sp)
 9086b90:	1805003a 	cmpeq	r2,r3,zero
 9086b94:	1001c91e 	bne	r2,zero,90872bc <_dtoa_r+0xf24>
 9086b98:	04800e0e 	bge	zero,r18,9086bd4 <_dtoa_r+0x83c>
 9086b9c:	d9001617 	ldw	r4,88(sp)
 9086ba0:	980b883a 	mov	r5,r19
 9086ba4:	900d883a 	mov	r6,r18
 9086ba8:	908a3940 	call	908a394 <__pow5mult>
 9086bac:	d9001617 	ldw	r4,88(sp)
 9086bb0:	d9800717 	ldw	r6,28(sp)
 9086bb4:	100b883a 	mov	r5,r2
 9086bb8:	1027883a 	mov	r19,r2
 9086bbc:	908a0700 	call	908a070 <__multiply>
 9086bc0:	d9001617 	ldw	r4,88(sp)
 9086bc4:	d9400717 	ldw	r5,28(sp)
 9086bc8:	1023883a 	mov	r17,r2
 9086bcc:	90895e00 	call	90895e0 <_Bfree>
 9086bd0:	dc400715 	stw	r17,28(sp)
 9086bd4:	d9001017 	ldw	r4,64(sp)
 9086bd8:	248dc83a 	sub	r6,r4,r18
 9086bdc:	30010e1e 	bne	r6,zero,9087018 <_dtoa_r+0xc80>
 9086be0:	d9001617 	ldw	r4,88(sp)
 9086be4:	04400044 	movi	r17,1
 9086be8:	880b883a 	mov	r5,r17
 9086bec:	908a2580 	call	908a258 <__i2b>
 9086bf0:	d9800917 	ldw	r6,36(sp)
 9086bf4:	1025883a 	mov	r18,r2
 9086bf8:	0180040e 	bge	zero,r6,9086c0c <_dtoa_r+0x874>
 9086bfc:	d9001617 	ldw	r4,88(sp)
 9086c00:	100b883a 	mov	r5,r2
 9086c04:	908a3940 	call	908a394 <__pow5mult>
 9086c08:	1025883a 	mov	r18,r2
 9086c0c:	d8801717 	ldw	r2,92(sp)
 9086c10:	8880f30e 	bge	r17,r2,9086fe0 <_dtoa_r+0xc48>
 9086c14:	0023883a 	mov	r17,zero
 9086c18:	d9800917 	ldw	r6,36(sp)
 9086c1c:	30019e1e 	bne	r6,zero,9087298 <_dtoa_r+0xf00>
 9086c20:	00c00044 	movi	r3,1
 9086c24:	d9000a17 	ldw	r4,40(sp)
 9086c28:	20c5883a 	add	r2,r4,r3
 9086c2c:	10c007cc 	andi	r3,r2,31
 9086c30:	1800841e 	bne	r3,zero,9086e44 <_dtoa_r+0xaac>
 9086c34:	00800704 	movi	r2,28
 9086c38:	d9000a17 	ldw	r4,40(sp)
 9086c3c:	d9801117 	ldw	r6,68(sp)
 9086c40:	80a1883a 	add	r16,r16,r2
 9086c44:	2089883a 	add	r4,r4,r2
 9086c48:	308d883a 	add	r6,r6,r2
 9086c4c:	d9000a15 	stw	r4,40(sp)
 9086c50:	d9801115 	stw	r6,68(sp)
 9086c54:	d8801117 	ldw	r2,68(sp)
 9086c58:	0080050e 	bge	zero,r2,9086c70 <_dtoa_r+0x8d8>
 9086c5c:	d9400717 	ldw	r5,28(sp)
 9086c60:	d9001617 	ldw	r4,88(sp)
 9086c64:	100d883a 	mov	r6,r2
 9086c68:	9089f240 	call	9089f24 <__lshift>
 9086c6c:	d8800715 	stw	r2,28(sp)
 9086c70:	d8c00a17 	ldw	r3,40(sp)
 9086c74:	00c0050e 	bge	zero,r3,9086c8c <_dtoa_r+0x8f4>
 9086c78:	d9001617 	ldw	r4,88(sp)
 9086c7c:	900b883a 	mov	r5,r18
 9086c80:	180d883a 	mov	r6,r3
 9086c84:	9089f240 	call	9089f24 <__lshift>
 9086c88:	1025883a 	mov	r18,r2
 9086c8c:	d9000c17 	ldw	r4,48(sp)
 9086c90:	2005003a 	cmpeq	r2,r4,zero
 9086c94:	10016f26 	beq	r2,zero,9087254 <_dtoa_r+0xebc>
 9086c98:	d9000f17 	ldw	r4,60(sp)
 9086c9c:	0102170e 	bge	zero,r4,90874fc <_dtoa_r+0x1164>
 9086ca0:	d9800b17 	ldw	r6,44(sp)
 9086ca4:	3005003a 	cmpeq	r2,r6,zero
 9086ca8:	1000881e 	bne	r2,zero,9086ecc <_dtoa_r+0xb34>
 9086cac:	0400050e 	bge	zero,r16,9086cc4 <_dtoa_r+0x92c>
 9086cb0:	d9001617 	ldw	r4,88(sp)
 9086cb4:	980b883a 	mov	r5,r19
 9086cb8:	800d883a 	mov	r6,r16
 9086cbc:	9089f240 	call	9089f24 <__lshift>
 9086cc0:	1027883a 	mov	r19,r2
 9086cc4:	8804c03a 	cmpne	r2,r17,zero
 9086cc8:	1002541e 	bne	r2,zero,908761c <_dtoa_r+0x1284>
 9086ccc:	980b883a 	mov	r5,r19
 9086cd0:	dd800517 	ldw	r22,20(sp)
 9086cd4:	dcc00615 	stw	r19,24(sp)
 9086cd8:	a700004c 	andi	fp,r20,1
 9086cdc:	2827883a 	mov	r19,r5
 9086ce0:	d9000717 	ldw	r4,28(sp)
 9086ce4:	900b883a 	mov	r5,r18
 9086ce8:	90861800 	call	9086180 <quorem>
 9086cec:	d9000717 	ldw	r4,28(sp)
 9086cf0:	d9400617 	ldw	r5,24(sp)
 9086cf4:	1023883a 	mov	r17,r2
 9086cf8:	8dc00c04 	addi	r23,r17,48
 9086cfc:	908973c0 	call	908973c <__mcmp>
 9086d00:	d9001617 	ldw	r4,88(sp)
 9086d04:	900b883a 	mov	r5,r18
 9086d08:	980d883a 	mov	r6,r19
 9086d0c:	1029883a 	mov	r20,r2
 9086d10:	9089d980 	call	9089d98 <__mdiff>
 9086d14:	102b883a 	mov	r21,r2
 9086d18:	10800317 	ldw	r2,12(r2)
 9086d1c:	1001281e 	bne	r2,zero,90871c0 <_dtoa_r+0xe28>
 9086d20:	d9000717 	ldw	r4,28(sp)
 9086d24:	a80b883a 	mov	r5,r21
 9086d28:	908973c0 	call	908973c <__mcmp>
 9086d2c:	d9001617 	ldw	r4,88(sp)
 9086d30:	1021883a 	mov	r16,r2
 9086d34:	a80b883a 	mov	r5,r21
 9086d38:	90895e00 	call	90895e0 <_Bfree>
 9086d3c:	8000041e 	bne	r16,zero,9086d50 <_dtoa_r+0x9b8>
 9086d40:	d8801717 	ldw	r2,92(sp)
 9086d44:	1000021e 	bne	r2,zero,9086d50 <_dtoa_r+0x9b8>
 9086d48:	e004c03a 	cmpne	r2,fp,zero
 9086d4c:	10011726 	beq	r2,zero,90871ac <_dtoa_r+0xe14>
 9086d50:	a0010616 	blt	r20,zero,908716c <_dtoa_r+0xdd4>
 9086d54:	a000041e 	bne	r20,zero,9086d68 <_dtoa_r+0x9d0>
 9086d58:	d8c01717 	ldw	r3,92(sp)
 9086d5c:	1800021e 	bne	r3,zero,9086d68 <_dtoa_r+0x9d0>
 9086d60:	e004c03a 	cmpne	r2,fp,zero
 9086d64:	10010126 	beq	r2,zero,908716c <_dtoa_r+0xdd4>
 9086d68:	04023d16 	blt	zero,r16,9087660 <_dtoa_r+0x12c8>
 9086d6c:	b5c00005 	stb	r23,0(r22)
 9086d70:	d9800517 	ldw	r6,20(sp)
 9086d74:	d9000f17 	ldw	r4,60(sp)
 9086d78:	b5800044 	addi	r22,r22,1
 9086d7c:	3105883a 	add	r2,r6,r4
 9086d80:	b0806526 	beq	r22,r2,9086f18 <_dtoa_r+0xb80>
 9086d84:	d9400717 	ldw	r5,28(sp)
 9086d88:	d9001617 	ldw	r4,88(sp)
 9086d8c:	01800284 	movi	r6,10
 9086d90:	000f883a 	mov	r7,zero
 9086d94:	908a2940 	call	908a294 <__multadd>
 9086d98:	d8800715 	stw	r2,28(sp)
 9086d9c:	d8800617 	ldw	r2,24(sp)
 9086da0:	14c10c26 	beq	r2,r19,90871d4 <_dtoa_r+0xe3c>
 9086da4:	d9400617 	ldw	r5,24(sp)
 9086da8:	d9001617 	ldw	r4,88(sp)
 9086dac:	01800284 	movi	r6,10
 9086db0:	000f883a 	mov	r7,zero
 9086db4:	908a2940 	call	908a294 <__multadd>
 9086db8:	d9001617 	ldw	r4,88(sp)
 9086dbc:	980b883a 	mov	r5,r19
 9086dc0:	01800284 	movi	r6,10
 9086dc4:	000f883a 	mov	r7,zero
 9086dc8:	d8800615 	stw	r2,24(sp)
 9086dcc:	908a2940 	call	908a294 <__multadd>
 9086dd0:	1027883a 	mov	r19,r2
 9086dd4:	003fc206 	br	9086ce0 <_dtoa_r+0x948>
 9086dd8:	2445c83a 	sub	r2,r4,r17
 9086ddc:	a088983a 	sll	r4,r20,r2
 9086de0:	003e4b06 	br	9086710 <_dtoa_r+0x378>
 9086de4:	01bfffc4 	movi	r6,-1
 9086de8:	00800044 	movi	r2,1
 9086dec:	d9800e15 	stw	r6,56(sp)
 9086df0:	d9800f15 	stw	r6,60(sp)
 9086df4:	d8800b15 	stw	r2,44(sp)
 9086df8:	d8c01617 	ldw	r3,88(sp)
 9086dfc:	008005c4 	movi	r2,23
 9086e00:	18001115 	stw	zero,68(r3)
 9086e04:	1580082e 	bgeu	r2,r22,9086e28 <_dtoa_r+0xa90>
 9086e08:	00c00104 	movi	r3,4
 9086e0c:	0009883a 	mov	r4,zero
 9086e10:	18c7883a 	add	r3,r3,r3
 9086e14:	18800504 	addi	r2,r3,20
 9086e18:	21000044 	addi	r4,r4,1
 9086e1c:	b0bffc2e 	bgeu	r22,r2,9086e10 <_dtoa_r+0xa78>
 9086e20:	d9801617 	ldw	r6,88(sp)
 9086e24:	31001115 	stw	r4,68(r6)
 9086e28:	dc000f17 	ldw	r16,60(sp)
 9086e2c:	003e4b06 	br	908675c <_dtoa_r+0x3c4>
 9086e30:	d9801717 	ldw	r6,92(sp)
 9086e34:	0023883a 	mov	r17,zero
 9086e38:	31bfff04 	addi	r6,r6,-4
 9086e3c:	d9801715 	stw	r6,92(sp)
 9086e40:	003df806 	br	9086624 <_dtoa_r+0x28c>
 9086e44:	00800804 	movi	r2,32
 9086e48:	10c9c83a 	sub	r4,r2,r3
 9086e4c:	00c00104 	movi	r3,4
 9086e50:	19005a16 	blt	r3,r4,9086fbc <_dtoa_r+0xc24>
 9086e54:	008000c4 	movi	r2,3
 9086e58:	113f7e16 	blt	r2,r4,9086c54 <_dtoa_r+0x8bc>
 9086e5c:	20800704 	addi	r2,r4,28
 9086e60:	003f7506 	br	9086c38 <_dtoa_r+0x8a0>
 9086e64:	d9801717 	ldw	r6,92(sp)
 9086e68:	00800044 	movi	r2,1
 9086e6c:	1180a10e 	bge	r2,r6,90870f4 <_dtoa_r+0xd5c>
 9086e70:	d9800f17 	ldw	r6,60(sp)
 9086e74:	d8c01017 	ldw	r3,64(sp)
 9086e78:	30bfffc4 	addi	r2,r6,-1
 9086e7c:	1881c616 	blt	r3,r2,9087598 <_dtoa_r+0x1200>
 9086e80:	18a5c83a 	sub	r18,r3,r2
 9086e84:	d8800f17 	ldw	r2,60(sp)
 9086e88:	10026216 	blt	r2,zero,9087814 <_dtoa_r+0x147c>
 9086e8c:	dc001117 	ldw	r16,68(sp)
 9086e90:	1007883a 	mov	r3,r2
 9086e94:	d9800a17 	ldw	r6,40(sp)
 9086e98:	d8801117 	ldw	r2,68(sp)
 9086e9c:	d9001617 	ldw	r4,88(sp)
 9086ea0:	30cd883a 	add	r6,r6,r3
 9086ea4:	10c5883a 	add	r2,r2,r3
 9086ea8:	01400044 	movi	r5,1
 9086eac:	d9800a15 	stw	r6,40(sp)
 9086eb0:	d8801115 	stw	r2,68(sp)
 9086eb4:	908a2580 	call	908a258 <__i2b>
 9086eb8:	1027883a 	mov	r19,r2
 9086ebc:	003f2506 	br	9086b54 <_dtoa_r+0x7bc>
 9086ec0:	00c24374 	movhi	r3,2317
 9086ec4:	18f56104 	addi	r3,r3,-10876
 9086ec8:	003d6706 	br	9086468 <_dtoa_r+0xd0>
 9086ecc:	dd800517 	ldw	r22,20(sp)
 9086ed0:	04000044 	movi	r16,1
 9086ed4:	00000706 	br	9086ef4 <_dtoa_r+0xb5c>
 9086ed8:	d9400717 	ldw	r5,28(sp)
 9086edc:	d9001617 	ldw	r4,88(sp)
 9086ee0:	01800284 	movi	r6,10
 9086ee4:	000f883a 	mov	r7,zero
 9086ee8:	908a2940 	call	908a294 <__multadd>
 9086eec:	d8800715 	stw	r2,28(sp)
 9086ef0:	84000044 	addi	r16,r16,1
 9086ef4:	d9000717 	ldw	r4,28(sp)
 9086ef8:	900b883a 	mov	r5,r18
 9086efc:	90861800 	call	9086180 <quorem>
 9086f00:	15c00c04 	addi	r23,r2,48
 9086f04:	b5c00005 	stb	r23,0(r22)
 9086f08:	d8c00f17 	ldw	r3,60(sp)
 9086f0c:	b5800044 	addi	r22,r22,1
 9086f10:	80fff116 	blt	r16,r3,9086ed8 <_dtoa_r+0xb40>
 9086f14:	d8000615 	stw	zero,24(sp)
 9086f18:	d9400717 	ldw	r5,28(sp)
 9086f1c:	d9001617 	ldw	r4,88(sp)
 9086f20:	01800044 	movi	r6,1
 9086f24:	9089f240 	call	9089f24 <__lshift>
 9086f28:	1009883a 	mov	r4,r2
 9086f2c:	900b883a 	mov	r5,r18
 9086f30:	d8800715 	stw	r2,28(sp)
 9086f34:	908973c0 	call	908973c <__mcmp>
 9086f38:	00803c0e 	bge	zero,r2,908702c <_dtoa_r+0xc94>
 9086f3c:	b009883a 	mov	r4,r22
 9086f40:	213fffc4 	addi	r4,r4,-1
 9086f44:	21400003 	ldbu	r5,0(r4)
 9086f48:	00800e44 	movi	r2,57
 9086f4c:	28c03fcc 	andi	r3,r5,255
 9086f50:	18c0201c 	xori	r3,r3,128
 9086f54:	18ffe004 	addi	r3,r3,-128
 9086f58:	1881981e 	bne	r3,r2,90875bc <_dtoa_r+0x1224>
 9086f5c:	d9800517 	ldw	r6,20(sp)
 9086f60:	21bff71e 	bne	r4,r6,9086f40 <_dtoa_r+0xba8>
 9086f64:	d8800d17 	ldw	r2,52(sp)
 9086f68:	37000044 	addi	fp,r6,1
 9086f6c:	10800044 	addi	r2,r2,1
 9086f70:	d8800d15 	stw	r2,52(sp)
 9086f74:	00800c44 	movi	r2,49
 9086f78:	30800005 	stb	r2,0(r6)
 9086f7c:	d9001617 	ldw	r4,88(sp)
 9086f80:	900b883a 	mov	r5,r18
 9086f84:	90895e00 	call	90895e0 <_Bfree>
 9086f88:	983ecd26 	beq	r19,zero,9086ac0 <_dtoa_r+0x728>
 9086f8c:	d8c00617 	ldw	r3,24(sp)
 9086f90:	18000426 	beq	r3,zero,9086fa4 <_dtoa_r+0xc0c>
 9086f94:	1cc00326 	beq	r3,r19,9086fa4 <_dtoa_r+0xc0c>
 9086f98:	d9001617 	ldw	r4,88(sp)
 9086f9c:	180b883a 	mov	r5,r3
 9086fa0:	90895e00 	call	90895e0 <_Bfree>
 9086fa4:	d9001617 	ldw	r4,88(sp)
 9086fa8:	980b883a 	mov	r5,r19
 9086fac:	90895e00 	call	90895e0 <_Bfree>
 9086fb0:	003ec306 	br	9086ac0 <_dtoa_r+0x728>
 9086fb4:	1805883a 	mov	r2,r3
 9086fb8:	003eeb06 	br	9086b68 <_dtoa_r+0x7d0>
 9086fbc:	d9800a17 	ldw	r6,40(sp)
 9086fc0:	d8c01117 	ldw	r3,68(sp)
 9086fc4:	20bfff04 	addi	r2,r4,-4
 9086fc8:	308d883a 	add	r6,r6,r2
 9086fcc:	1887883a 	add	r3,r3,r2
 9086fd0:	80a1883a 	add	r16,r16,r2
 9086fd4:	d9800a15 	stw	r6,40(sp)
 9086fd8:	d8c01115 	stw	r3,68(sp)
 9086fdc:	003f1d06 	br	9086c54 <_dtoa_r+0x8bc>
 9086fe0:	a03f0c1e 	bne	r20,zero,9086c14 <_dtoa_r+0x87c>
 9086fe4:	00800434 	movhi	r2,16
 9086fe8:	10bfffc4 	addi	r2,r2,-1
 9086fec:	a884703a 	and	r2,r21,r2
 9086ff0:	103f081e 	bne	r2,zero,9086c14 <_dtoa_r+0x87c>
 9086ff4:	a89ffc2c 	andhi	r2,r21,32752
 9086ff8:	103f0626 	beq	r2,zero,9086c14 <_dtoa_r+0x87c>
 9086ffc:	d8c01117 	ldw	r3,68(sp)
 9087000:	d9000a17 	ldw	r4,40(sp)
 9087004:	18c00044 	addi	r3,r3,1
 9087008:	21000044 	addi	r4,r4,1
 908700c:	d8c01115 	stw	r3,68(sp)
 9087010:	d9000a15 	stw	r4,40(sp)
 9087014:	003f0006 	br	9086c18 <_dtoa_r+0x880>
 9087018:	d9400717 	ldw	r5,28(sp)
 908701c:	d9001617 	ldw	r4,88(sp)
 9087020:	908a3940 	call	908a394 <__pow5mult>
 9087024:	d8800715 	stw	r2,28(sp)
 9087028:	003eed06 	br	9086be0 <_dtoa_r+0x848>
 908702c:	1000021e 	bne	r2,zero,9087038 <_dtoa_r+0xca0>
 9087030:	b880004c 	andi	r2,r23,1
 9087034:	103fc11e 	bne	r2,zero,9086f3c <_dtoa_r+0xba4>
 9087038:	b5bfffc4 	addi	r22,r22,-1
 908703c:	b0c00007 	ldb	r3,0(r22)
 9087040:	00800c04 	movi	r2,48
 9087044:	18bffc26 	beq	r3,r2,9087038 <_dtoa_r+0xca0>
 9087048:	b7000044 	addi	fp,r22,1
 908704c:	003fcb06 	br	9086f7c <_dtoa_r+0xbe4>
 9087050:	d9800d17 	ldw	r6,52(sp)
 9087054:	018fc83a 	sub	r7,zero,r6
 9087058:	3801f726 	beq	r7,zero,9087838 <_dtoa_r+0x14a0>
 908705c:	398003cc 	andi	r6,r7,15
 9087060:	300c90fa 	slli	r6,r6,3
 9087064:	01424374 	movhi	r5,2317
 9087068:	29757e04 	addi	r5,r5,-10760
 908706c:	d9001217 	ldw	r4,72(sp)
 9087070:	314d883a 	add	r6,r6,r5
 9087074:	30c00117 	ldw	r3,4(r6)
 9087078:	30800017 	ldw	r2,0(r6)
 908707c:	d9401317 	ldw	r5,76(sp)
 9087080:	3821d13a 	srai	r16,r7,4
 9087084:	100d883a 	mov	r6,r2
 9087088:	180f883a 	mov	r7,r3
 908708c:	908c5b40 	call	908c5b4 <__muldf3>
 9087090:	1011883a 	mov	r8,r2
 9087094:	1813883a 	mov	r9,r3
 9087098:	1029883a 	mov	r20,r2
 908709c:	182b883a 	mov	r21,r3
 90870a0:	8001e526 	beq	r16,zero,9087838 <_dtoa_r+0x14a0>
 90870a4:	05800084 	movi	r22,2
 90870a8:	04424374 	movhi	r17,2317
 90870ac:	8c75b004 	addi	r17,r17,-10560
 90870b0:	8080004c 	andi	r2,r16,1
 90870b4:	1005003a 	cmpeq	r2,r2,zero
 90870b8:	1000081e 	bne	r2,zero,90870dc <_dtoa_r+0xd44>
 90870bc:	89800017 	ldw	r6,0(r17)
 90870c0:	89c00117 	ldw	r7,4(r17)
 90870c4:	480b883a 	mov	r5,r9
 90870c8:	4009883a 	mov	r4,r8
 90870cc:	908c5b40 	call	908c5b4 <__muldf3>
 90870d0:	1011883a 	mov	r8,r2
 90870d4:	b5800044 	addi	r22,r22,1
 90870d8:	1813883a 	mov	r9,r3
 90870dc:	8021d07a 	srai	r16,r16,1
 90870e0:	8c400204 	addi	r17,r17,8
 90870e4:	803ff21e 	bne	r16,zero,90870b0 <_dtoa_r+0xd18>
 90870e8:	4029883a 	mov	r20,r8
 90870ec:	482b883a 	mov	r21,r9
 90870f0:	003dca06 	br	908681c <_dtoa_r+0x484>
 90870f4:	d9000817 	ldw	r4,32(sp)
 90870f8:	2005003a 	cmpeq	r2,r4,zero
 90870fc:	1001f61e 	bne	r2,zero,90878d8 <_dtoa_r+0x1540>
 9087100:	dc001117 	ldw	r16,68(sp)
 9087104:	dc801017 	ldw	r18,64(sp)
 9087108:	18c10cc4 	addi	r3,r3,1075
 908710c:	003f6106 	br	9086e94 <_dtoa_r+0xafc>
 9087110:	d8000b15 	stw	zero,44(sp)
 9087114:	d9802617 	ldw	r6,152(sp)
 9087118:	d8c00d17 	ldw	r3,52(sp)
 908711c:	30800044 	addi	r2,r6,1
 9087120:	18ad883a 	add	r22,r3,r2
 9087124:	b13fffc4 	addi	r4,r22,-1
 9087128:	d9000e15 	stw	r4,56(sp)
 908712c:	0581f60e 	bge	zero,r22,9087908 <_dtoa_r+0x1570>
 9087130:	dd800f15 	stw	r22,60(sp)
 9087134:	003f3006 	br	9086df8 <_dtoa_r+0xa60>
 9087138:	d8000b15 	stw	zero,44(sp)
 908713c:	d9002617 	ldw	r4,152(sp)
 9087140:	0101eb0e 	bge	zero,r4,90878f0 <_dtoa_r+0x1558>
 9087144:	202d883a 	mov	r22,r4
 9087148:	d9000e15 	stw	r4,56(sp)
 908714c:	d9000f15 	stw	r4,60(sp)
 9087150:	003f2906 	br	9086df8 <_dtoa_r+0xa60>
 9087154:	01800044 	movi	r6,1
 9087158:	d9800b15 	stw	r6,44(sp)
 908715c:	003ff706 	br	908713c <_dtoa_r+0xda4>
 9087160:	01000044 	movi	r4,1
 9087164:	d9000b15 	stw	r4,44(sp)
 9087168:	003fea06 	br	9087114 <_dtoa_r+0xd7c>
 908716c:	04000c0e 	bge	zero,r16,90871a0 <_dtoa_r+0xe08>
 9087170:	d9400717 	ldw	r5,28(sp)
 9087174:	d9001617 	ldw	r4,88(sp)
 9087178:	01800044 	movi	r6,1
 908717c:	9089f240 	call	9089f24 <__lshift>
 9087180:	1009883a 	mov	r4,r2
 9087184:	900b883a 	mov	r5,r18
 9087188:	d8800715 	stw	r2,28(sp)
 908718c:	908973c0 	call	908973c <__mcmp>
 9087190:	0081e00e 	bge	zero,r2,9087914 <_dtoa_r+0x157c>
 9087194:	bdc00044 	addi	r23,r23,1
 9087198:	00800e84 	movi	r2,58
 908719c:	b881a226 	beq	r23,r2,9087828 <_dtoa_r+0x1490>
 90871a0:	b7000044 	addi	fp,r22,1
 90871a4:	b5c00005 	stb	r23,0(r22)
 90871a8:	003f7406 	br	9086f7c <_dtoa_r+0xbe4>
 90871ac:	00800e44 	movi	r2,57
 90871b0:	b8819d26 	beq	r23,r2,9087828 <_dtoa_r+0x1490>
 90871b4:	053ffa0e 	bge	zero,r20,90871a0 <_dtoa_r+0xe08>
 90871b8:	8dc00c44 	addi	r23,r17,49
 90871bc:	003ff806 	br	90871a0 <_dtoa_r+0xe08>
 90871c0:	d9001617 	ldw	r4,88(sp)
 90871c4:	a80b883a 	mov	r5,r21
 90871c8:	04000044 	movi	r16,1
 90871cc:	90895e00 	call	90895e0 <_Bfree>
 90871d0:	003edf06 	br	9086d50 <_dtoa_r+0x9b8>
 90871d4:	d9001617 	ldw	r4,88(sp)
 90871d8:	980b883a 	mov	r5,r19
 90871dc:	01800284 	movi	r6,10
 90871e0:	000f883a 	mov	r7,zero
 90871e4:	908a2940 	call	908a294 <__multadd>
 90871e8:	1027883a 	mov	r19,r2
 90871ec:	d8800615 	stw	r2,24(sp)
 90871f0:	003ebb06 	br	9086ce0 <_dtoa_r+0x948>
 90871f4:	d9801117 	ldw	r6,68(sp)
 90871f8:	d8800d17 	ldw	r2,52(sp)
 90871fc:	d8000915 	stw	zero,36(sp)
 9087200:	308dc83a 	sub	r6,r6,r2
 9087204:	0087c83a 	sub	r3,zero,r2
 9087208:	d9801115 	stw	r6,68(sp)
 908720c:	d8c01015 	stw	r3,64(sp)
 9087210:	003cfe06 	br	908660c <_dtoa_r+0x274>
 9087214:	018dc83a 	sub	r6,zero,r6
 9087218:	d9801115 	stw	r6,68(sp)
 908721c:	d8000a15 	stw	zero,40(sp)
 9087220:	003cf306 	br	90865f0 <_dtoa_r+0x258>
 9087224:	d9000d17 	ldw	r4,52(sp)
 9087228:	908ce680 	call	908ce68 <__floatsidf>
 908722c:	880b883a 	mov	r5,r17
 9087230:	8009883a 	mov	r4,r16
 9087234:	180f883a 	mov	r7,r3
 9087238:	100d883a 	mov	r6,r2
 908723c:	908cc480 	call	908cc48 <__nedf2>
 9087240:	103ce126 	beq	r2,zero,90865c8 <_dtoa_r+0x230>
 9087244:	d9800d17 	ldw	r6,52(sp)
 9087248:	31bfffc4 	addi	r6,r6,-1
 908724c:	d9800d15 	stw	r6,52(sp)
 9087250:	003cdd06 	br	90865c8 <_dtoa_r+0x230>
 9087254:	d9000717 	ldw	r4,28(sp)
 9087258:	900b883a 	mov	r5,r18
 908725c:	908973c0 	call	908973c <__mcmp>
 9087260:	103e8d0e 	bge	r2,zero,9086c98 <_dtoa_r+0x900>
 9087264:	d9400717 	ldw	r5,28(sp)
 9087268:	d9001617 	ldw	r4,88(sp)
 908726c:	01800284 	movi	r6,10
 9087270:	000f883a 	mov	r7,zero
 9087274:	908a2940 	call	908a294 <__multadd>
 9087278:	d9800d17 	ldw	r6,52(sp)
 908727c:	d8800715 	stw	r2,28(sp)
 9087280:	31bfffc4 	addi	r6,r6,-1
 9087284:	d9800d15 	stw	r6,52(sp)
 9087288:	b001a71e 	bne	r22,zero,9087928 <_dtoa_r+0x1590>
 908728c:	d8800e17 	ldw	r2,56(sp)
 9087290:	d8800f15 	stw	r2,60(sp)
 9087294:	003e8006 	br	9086c98 <_dtoa_r+0x900>
 9087298:	90800417 	ldw	r2,16(r18)
 908729c:	1085883a 	add	r2,r2,r2
 90872a0:	1085883a 	add	r2,r2,r2
 90872a4:	1485883a 	add	r2,r2,r18
 90872a8:	11000417 	ldw	r4,16(r2)
 90872ac:	90896080 	call	9089608 <__hi0bits>
 90872b0:	00c00804 	movi	r3,32
 90872b4:	1887c83a 	sub	r3,r3,r2
 90872b8:	003e5a06 	br	9086c24 <_dtoa_r+0x88c>
 90872bc:	d9400717 	ldw	r5,28(sp)
 90872c0:	d9801017 	ldw	r6,64(sp)
 90872c4:	d9001617 	ldw	r4,88(sp)
 90872c8:	908a3940 	call	908a394 <__pow5mult>
 90872cc:	d8800715 	stw	r2,28(sp)
 90872d0:	003e4306 	br	9086be0 <_dtoa_r+0x848>
 90872d4:	d9800f17 	ldw	r6,60(sp)
 90872d8:	d8800d17 	ldw	r2,52(sp)
 90872dc:	d9800315 	stw	r6,12(sp)
 90872e0:	d8800415 	stw	r2,16(sp)
 90872e4:	d8c00b17 	ldw	r3,44(sp)
 90872e8:	1805003a 	cmpeq	r2,r3,zero
 90872ec:	1000e21e 	bne	r2,zero,9087678 <_dtoa_r+0x12e0>
 90872f0:	d9000317 	ldw	r4,12(sp)
 90872f4:	0005883a 	mov	r2,zero
 90872f8:	00cff834 	movhi	r3,16352
 90872fc:	200c90fa 	slli	r6,r4,3
 9087300:	01024374 	movhi	r4,2317
 9087304:	21357e04 	addi	r4,r4,-10760
 9087308:	180b883a 	mov	r5,r3
 908730c:	310d883a 	add	r6,r6,r4
 9087310:	327fff17 	ldw	r9,-4(r6)
 9087314:	323ffe17 	ldw	r8,-8(r6)
 9087318:	1009883a 	mov	r4,r2
 908731c:	480f883a 	mov	r7,r9
 9087320:	400d883a 	mov	r6,r8
 9087324:	908c9680 	call	908c968 <__divdf3>
 9087328:	180b883a 	mov	r5,r3
 908732c:	b00d883a 	mov	r6,r22
 9087330:	b80f883a 	mov	r7,r23
 9087334:	1009883a 	mov	r4,r2
 9087338:	908c4c00 	call	908c4c0 <__subdf3>
 908733c:	a80b883a 	mov	r5,r21
 9087340:	a009883a 	mov	r4,r20
 9087344:	d8c01915 	stw	r3,100(sp)
 9087348:	d8801815 	stw	r2,96(sp)
 908734c:	908cf600 	call	908cf60 <__fixdfsi>
 9087350:	1009883a 	mov	r4,r2
 9087354:	1027883a 	mov	r19,r2
 9087358:	908ce680 	call	908ce68 <__floatsidf>
 908735c:	a80b883a 	mov	r5,r21
 9087360:	a009883a 	mov	r4,r20
 9087364:	180f883a 	mov	r7,r3
 9087368:	100d883a 	mov	r6,r2
 908736c:	908c4c00 	call	908c4c0 <__subdf3>
 9087370:	d9801817 	ldw	r6,96(sp)
 9087374:	1823883a 	mov	r17,r3
 9087378:	d8801415 	stw	r2,80(sp)
 908737c:	302d883a 	mov	r22,r6
 9087380:	d9800517 	ldw	r6,20(sp)
 9087384:	9cc00c04 	addi	r19,r19,48
 9087388:	dc401515 	stw	r17,84(sp)
 908738c:	d8c01917 	ldw	r3,100(sp)
 9087390:	34c00005 	stb	r19,0(r6)
 9087394:	d8800517 	ldw	r2,20(sp)
 9087398:	d9401917 	ldw	r5,100(sp)
 908739c:	d9801417 	ldw	r6,80(sp)
 90873a0:	b009883a 	mov	r4,r22
 90873a4:	880f883a 	mov	r7,r17
 90873a8:	182f883a 	mov	r23,r3
 90873ac:	17000044 	addi	fp,r2,1
 90873b0:	908ccd00 	call	908ccd0 <__gtdf2>
 90873b4:	00804e16 	blt	zero,r2,90874f0 <_dtoa_r+0x1158>
 90873b8:	d9801417 	ldw	r6,80(sp)
 90873bc:	0005883a 	mov	r2,zero
 90873c0:	00cffc34 	movhi	r3,16368
 90873c4:	180b883a 	mov	r5,r3
 90873c8:	880f883a 	mov	r7,r17
 90873cc:	1009883a 	mov	r4,r2
 90873d0:	908c4c00 	call	908c4c0 <__subdf3>
 90873d4:	d9401917 	ldw	r5,100(sp)
 90873d8:	180f883a 	mov	r7,r3
 90873dc:	b009883a 	mov	r4,r22
 90873e0:	100d883a 	mov	r6,r2
 90873e4:	908ccd00 	call	908ccd0 <__gtdf2>
 90873e8:	00bda216 	blt	zero,r2,9086a74 <_dtoa_r+0x6dc>
 90873ec:	d8c00317 	ldw	r3,12(sp)
 90873f0:	00800044 	movi	r2,1
 90873f4:	10c01216 	blt	r2,r3,9087440 <_dtoa_r+0x10a8>
 90873f8:	003d4506 	br	9086910 <_dtoa_r+0x578>
 90873fc:	d9801417 	ldw	r6,80(sp)
 9087400:	0005883a 	mov	r2,zero
 9087404:	00cffc34 	movhi	r3,16368
 9087408:	180b883a 	mov	r5,r3
 908740c:	880f883a 	mov	r7,r17
 9087410:	1009883a 	mov	r4,r2
 9087414:	908c4c00 	call	908c4c0 <__subdf3>
 9087418:	d9c01b17 	ldw	r7,108(sp)
 908741c:	180b883a 	mov	r5,r3
 9087420:	1009883a 	mov	r4,r2
 9087424:	b00d883a 	mov	r6,r22
 9087428:	908cde00 	call	908cde0 <__ltdf2>
 908742c:	103d9116 	blt	r2,zero,9086a74 <_dtoa_r+0x6dc>
 9087430:	d9800517 	ldw	r6,20(sp)
 9087434:	d9000317 	ldw	r4,12(sp)
 9087438:	3105883a 	add	r2,r6,r4
 908743c:	e0bd3426 	beq	fp,r2,9086910 <_dtoa_r+0x578>
 9087440:	04500934 	movhi	r17,16420
 9087444:	0021883a 	mov	r16,zero
 9087448:	b80b883a 	mov	r5,r23
 908744c:	b009883a 	mov	r4,r22
 9087450:	800d883a 	mov	r6,r16
 9087454:	880f883a 	mov	r7,r17
 9087458:	908c5b40 	call	908c5b4 <__muldf3>
 908745c:	d9401517 	ldw	r5,84(sp)
 9087460:	d9001417 	ldw	r4,80(sp)
 9087464:	880f883a 	mov	r7,r17
 9087468:	000d883a 	mov	r6,zero
 908746c:	d8801a15 	stw	r2,104(sp)
 9087470:	d8c01b15 	stw	r3,108(sp)
 9087474:	908c5b40 	call	908c5b4 <__muldf3>
 9087478:	180b883a 	mov	r5,r3
 908747c:	1009883a 	mov	r4,r2
 9087480:	1823883a 	mov	r17,r3
 9087484:	1021883a 	mov	r16,r2
 9087488:	908cf600 	call	908cf60 <__fixdfsi>
 908748c:	1009883a 	mov	r4,r2
 9087490:	102b883a 	mov	r21,r2
 9087494:	908ce680 	call	908ce68 <__floatsidf>
 9087498:	880b883a 	mov	r5,r17
 908749c:	8009883a 	mov	r4,r16
 90874a0:	180f883a 	mov	r7,r3
 90874a4:	100d883a 	mov	r6,r2
 90874a8:	908c4c00 	call	908c4c0 <__subdf3>
 90874ac:	1021883a 	mov	r16,r2
 90874b0:	d9001b17 	ldw	r4,108(sp)
 90874b4:	1823883a 	mov	r17,r3
 90874b8:	dc001415 	stw	r16,80(sp)
 90874bc:	ad400c04 	addi	r21,r21,48
 90874c0:	dc401515 	stw	r17,84(sp)
 90874c4:	d8801a17 	ldw	r2,104(sp)
 90874c8:	e5400005 	stb	r21,0(fp)
 90874cc:	202f883a 	mov	r23,r4
 90874d0:	d9c01b17 	ldw	r7,108(sp)
 90874d4:	d9001417 	ldw	r4,80(sp)
 90874d8:	880b883a 	mov	r5,r17
 90874dc:	100d883a 	mov	r6,r2
 90874e0:	102d883a 	mov	r22,r2
 90874e4:	e7000044 	addi	fp,fp,1
 90874e8:	908cde00 	call	908cde0 <__ltdf2>
 90874ec:	103fc30e 	bge	r2,zero,90873fc <_dtoa_r+0x1064>
 90874f0:	d9000417 	ldw	r4,16(sp)
 90874f4:	d9000d15 	stw	r4,52(sp)
 90874f8:	003d7106 	br	9086ac0 <_dtoa_r+0x728>
 90874fc:	d9801717 	ldw	r6,92(sp)
 9087500:	00800084 	movi	r2,2
 9087504:	11bde60e 	bge	r2,r6,9086ca0 <_dtoa_r+0x908>
 9087508:	203cfb1e 	bne	r4,zero,90868f8 <_dtoa_r+0x560>
 908750c:	d9001617 	ldw	r4,88(sp)
 9087510:	900b883a 	mov	r5,r18
 9087514:	01800144 	movi	r6,5
 9087518:	000f883a 	mov	r7,zero
 908751c:	908a2940 	call	908a294 <__multadd>
 9087520:	d9000717 	ldw	r4,28(sp)
 9087524:	100b883a 	mov	r5,r2
 9087528:	1025883a 	mov	r18,r2
 908752c:	908973c0 	call	908973c <__mcmp>
 9087530:	00bcf10e 	bge	zero,r2,90868f8 <_dtoa_r+0x560>
 9087534:	d8c00d17 	ldw	r3,52(sp)
 9087538:	d9000517 	ldw	r4,20(sp)
 908753c:	d8000615 	stw	zero,24(sp)
 9087540:	18c00044 	addi	r3,r3,1
 9087544:	d8c00d15 	stw	r3,52(sp)
 9087548:	00800c44 	movi	r2,49
 908754c:	27000044 	addi	fp,r4,1
 9087550:	20800005 	stb	r2,0(r4)
 9087554:	003e8906 	br	9086f7c <_dtoa_r+0xbe4>
 9087558:	d8c00517 	ldw	r3,20(sp)
 908755c:	003bc206 	br	9086468 <_dtoa_r+0xd0>
 9087560:	01824374 	movhi	r6,2317
 9087564:	31b5b004 	addi	r6,r6,-10560
 9087568:	30c00917 	ldw	r3,36(r6)
 908756c:	30800817 	ldw	r2,32(r6)
 9087570:	d9001217 	ldw	r4,72(sp)
 9087574:	d9401317 	ldw	r5,76(sp)
 9087578:	180f883a 	mov	r7,r3
 908757c:	100d883a 	mov	r6,r2
 9087580:	908c9680 	call	908c968 <__divdf3>
 9087584:	948003cc 	andi	r18,r18,15
 9087588:	058000c4 	movi	r22,3
 908758c:	1029883a 	mov	r20,r2
 9087590:	182b883a 	mov	r21,r3
 9087594:	003c8906 	br	90867bc <_dtoa_r+0x424>
 9087598:	d9001017 	ldw	r4,64(sp)
 908759c:	d9800917 	ldw	r6,36(sp)
 90875a0:	0025883a 	mov	r18,zero
 90875a4:	1105c83a 	sub	r2,r2,r4
 90875a8:	2089883a 	add	r4,r4,r2
 90875ac:	308d883a 	add	r6,r6,r2
 90875b0:	d9001015 	stw	r4,64(sp)
 90875b4:	d9800915 	stw	r6,36(sp)
 90875b8:	003e3206 	br	9086e84 <_dtoa_r+0xaec>
 90875bc:	28800044 	addi	r2,r5,1
 90875c0:	27000044 	addi	fp,r4,1
 90875c4:	20800005 	stb	r2,0(r4)
 90875c8:	003e6c06 	br	9086f7c <_dtoa_r+0xbe4>
 90875cc:	d8800f17 	ldw	r2,60(sp)
 90875d0:	00bce016 	blt	zero,r2,9086954 <_dtoa_r+0x5bc>
 90875d4:	d9800f17 	ldw	r6,60(sp)
 90875d8:	303cc51e 	bne	r6,zero,90868f0 <_dtoa_r+0x558>
 90875dc:	0005883a 	mov	r2,zero
 90875e0:	00d00534 	movhi	r3,16404
 90875e4:	980b883a 	mov	r5,r19
 90875e8:	180f883a 	mov	r7,r3
 90875ec:	9009883a 	mov	r4,r18
 90875f0:	100d883a 	mov	r6,r2
 90875f4:	908c5b40 	call	908c5b4 <__muldf3>
 90875f8:	180b883a 	mov	r5,r3
 90875fc:	a80f883a 	mov	r7,r21
 9087600:	1009883a 	mov	r4,r2
 9087604:	a00d883a 	mov	r6,r20
 9087608:	908cd580 	call	908cd58 <__gedf2>
 908760c:	103cb80e 	bge	r2,zero,90868f0 <_dtoa_r+0x558>
 9087610:	0027883a 	mov	r19,zero
 9087614:	0025883a 	mov	r18,zero
 9087618:	003fc606 	br	9087534 <_dtoa_r+0x119c>
 908761c:	99400117 	ldw	r5,4(r19)
 9087620:	d9001617 	ldw	r4,88(sp)
 9087624:	9089b600 	call	9089b60 <_Balloc>
 9087628:	99800417 	ldw	r6,16(r19)
 908762c:	11000304 	addi	r4,r2,12
 9087630:	99400304 	addi	r5,r19,12
 9087634:	318d883a 	add	r6,r6,r6
 9087638:	318d883a 	add	r6,r6,r6
 908763c:	31800204 	addi	r6,r6,8
 9087640:	1023883a 	mov	r17,r2
 9087644:	90894600 	call	9089460 <memcpy>
 9087648:	d9001617 	ldw	r4,88(sp)
 908764c:	880b883a 	mov	r5,r17
 9087650:	01800044 	movi	r6,1
 9087654:	9089f240 	call	9089f24 <__lshift>
 9087658:	100b883a 	mov	r5,r2
 908765c:	003d9c06 	br	9086cd0 <_dtoa_r+0x938>
 9087660:	00800e44 	movi	r2,57
 9087664:	b8807026 	beq	r23,r2,9087828 <_dtoa_r+0x1490>
 9087668:	b8800044 	addi	r2,r23,1
 908766c:	b7000044 	addi	fp,r22,1
 9087670:	b0800005 	stb	r2,0(r22)
 9087674:	003e4106 	br	9086f7c <_dtoa_r+0xbe4>
 9087678:	d8800317 	ldw	r2,12(sp)
 908767c:	01824374 	movhi	r6,2317
 9087680:	31b57e04 	addi	r6,r6,-10760
 9087684:	b009883a 	mov	r4,r22
 9087688:	100e90fa 	slli	r7,r2,3
 908768c:	b80b883a 	mov	r5,r23
 9087690:	398f883a 	add	r7,r7,r6
 9087694:	38bffe17 	ldw	r2,-8(r7)
 9087698:	d9800517 	ldw	r6,20(sp)
 908769c:	38ffff17 	ldw	r3,-4(r7)
 90876a0:	37000044 	addi	fp,r6,1
 90876a4:	180f883a 	mov	r7,r3
 90876a8:	100d883a 	mov	r6,r2
 90876ac:	908c5b40 	call	908c5b4 <__muldf3>
 90876b0:	a80b883a 	mov	r5,r21
 90876b4:	a009883a 	mov	r4,r20
 90876b8:	182f883a 	mov	r23,r3
 90876bc:	102d883a 	mov	r22,r2
 90876c0:	908cf600 	call	908cf60 <__fixdfsi>
 90876c4:	1009883a 	mov	r4,r2
 90876c8:	1027883a 	mov	r19,r2
 90876cc:	908ce680 	call	908ce68 <__floatsidf>
 90876d0:	a80b883a 	mov	r5,r21
 90876d4:	a009883a 	mov	r4,r20
 90876d8:	180f883a 	mov	r7,r3
 90876dc:	100d883a 	mov	r6,r2
 90876e0:	908c4c00 	call	908c4c0 <__subdf3>
 90876e4:	180b883a 	mov	r5,r3
 90876e8:	d8c00517 	ldw	r3,20(sp)
 90876ec:	9cc00c04 	addi	r19,r19,48
 90876f0:	1009883a 	mov	r4,r2
 90876f4:	1cc00005 	stb	r19,0(r3)
 90876f8:	2021883a 	mov	r16,r4
 90876fc:	d9000317 	ldw	r4,12(sp)
 9087700:	00800044 	movi	r2,1
 9087704:	2823883a 	mov	r17,r5
 9087708:	20802226 	beq	r4,r2,9087794 <_dtoa_r+0x13fc>
 908770c:	1029883a 	mov	r20,r2
 9087710:	0005883a 	mov	r2,zero
 9087714:	00d00934 	movhi	r3,16420
 9087718:	180f883a 	mov	r7,r3
 908771c:	100d883a 	mov	r6,r2
 9087720:	880b883a 	mov	r5,r17
 9087724:	8009883a 	mov	r4,r16
 9087728:	908c5b40 	call	908c5b4 <__muldf3>
 908772c:	180b883a 	mov	r5,r3
 9087730:	1009883a 	mov	r4,r2
 9087734:	1823883a 	mov	r17,r3
 9087738:	1021883a 	mov	r16,r2
 908773c:	908cf600 	call	908cf60 <__fixdfsi>
 9087740:	1009883a 	mov	r4,r2
 9087744:	102b883a 	mov	r21,r2
 9087748:	908ce680 	call	908ce68 <__floatsidf>
 908774c:	880b883a 	mov	r5,r17
 9087750:	8009883a 	mov	r4,r16
 9087754:	180f883a 	mov	r7,r3
 9087758:	100d883a 	mov	r6,r2
 908775c:	908c4c00 	call	908c4c0 <__subdf3>
 9087760:	180b883a 	mov	r5,r3
 9087764:	d8c00517 	ldw	r3,20(sp)
 9087768:	1009883a 	mov	r4,r2
 908776c:	ad400c04 	addi	r21,r21,48
 9087770:	1d05883a 	add	r2,r3,r20
 9087774:	15400005 	stb	r21,0(r2)
 9087778:	2021883a 	mov	r16,r4
 908777c:	d9000317 	ldw	r4,12(sp)
 9087780:	a5000044 	addi	r20,r20,1
 9087784:	2823883a 	mov	r17,r5
 9087788:	a13fe11e 	bne	r20,r4,9087710 <_dtoa_r+0x1378>
 908778c:	e505883a 	add	r2,fp,r20
 9087790:	173fffc4 	addi	fp,r2,-1
 9087794:	0025883a 	mov	r18,zero
 9087798:	04cff834 	movhi	r19,16352
 908779c:	b009883a 	mov	r4,r22
 90877a0:	b80b883a 	mov	r5,r23
 90877a4:	900d883a 	mov	r6,r18
 90877a8:	980f883a 	mov	r7,r19
 90877ac:	908c5400 	call	908c540 <__adddf3>
 90877b0:	180b883a 	mov	r5,r3
 90877b4:	1009883a 	mov	r4,r2
 90877b8:	800d883a 	mov	r6,r16
 90877bc:	880f883a 	mov	r7,r17
 90877c0:	908cde00 	call	908cde0 <__ltdf2>
 90877c4:	103cab16 	blt	r2,zero,9086a74 <_dtoa_r+0x6dc>
 90877c8:	0009883a 	mov	r4,zero
 90877cc:	980b883a 	mov	r5,r19
 90877d0:	b80f883a 	mov	r7,r23
 90877d4:	b00d883a 	mov	r6,r22
 90877d8:	908c4c00 	call	908c4c0 <__subdf3>
 90877dc:	180b883a 	mov	r5,r3
 90877e0:	880f883a 	mov	r7,r17
 90877e4:	1009883a 	mov	r4,r2
 90877e8:	800d883a 	mov	r6,r16
 90877ec:	908ccd00 	call	908ccd0 <__gtdf2>
 90877f0:	00bc470e 	bge	zero,r2,9086910 <_dtoa_r+0x578>
 90877f4:	00c00c04 	movi	r3,48
 90877f8:	e73fffc4 	addi	fp,fp,-1
 90877fc:	e0800007 	ldb	r2,0(fp)
 9087800:	10fffd26 	beq	r2,r3,90877f8 <_dtoa_r+0x1460>
 9087804:	d9800417 	ldw	r6,16(sp)
 9087808:	e7000044 	addi	fp,fp,1
 908780c:	d9800d15 	stw	r6,52(sp)
 9087810:	003cab06 	br	9086ac0 <_dtoa_r+0x728>
 9087814:	d8c00f17 	ldw	r3,60(sp)
 9087818:	d9001117 	ldw	r4,68(sp)
 908781c:	20e1c83a 	sub	r16,r4,r3
 9087820:	0007883a 	mov	r3,zero
 9087824:	003d9b06 	br	9086e94 <_dtoa_r+0xafc>
 9087828:	00800e44 	movi	r2,57
 908782c:	b0800005 	stb	r2,0(r22)
 9087830:	b5800044 	addi	r22,r22,1
 9087834:	003dc106 	br	9086f3c <_dtoa_r+0xba4>
 9087838:	05800084 	movi	r22,2
 908783c:	003bf706 	br	908681c <_dtoa_r+0x484>
 9087840:	d9000f17 	ldw	r4,60(sp)
 9087844:	013c000e 	bge	zero,r4,9086848 <_dtoa_r+0x4b0>
 9087848:	d9800e17 	ldw	r6,56(sp)
 908784c:	01bc300e 	bge	zero,r6,9086910 <_dtoa_r+0x578>
 9087850:	0005883a 	mov	r2,zero
 9087854:	00d00934 	movhi	r3,16420
 9087858:	a80b883a 	mov	r5,r21
 908785c:	180f883a 	mov	r7,r3
 9087860:	a009883a 	mov	r4,r20
 9087864:	100d883a 	mov	r6,r2
 9087868:	908c5b40 	call	908c5b4 <__muldf3>
 908786c:	b1000044 	addi	r4,r22,1
 9087870:	1021883a 	mov	r16,r2
 9087874:	1823883a 	mov	r17,r3
 9087878:	908ce680 	call	908ce68 <__floatsidf>
 908787c:	880b883a 	mov	r5,r17
 9087880:	8009883a 	mov	r4,r16
 9087884:	180f883a 	mov	r7,r3
 9087888:	100d883a 	mov	r6,r2
 908788c:	908c5b40 	call	908c5b4 <__muldf3>
 9087890:	0011883a 	mov	r8,zero
 9087894:	02500734 	movhi	r9,16412
 9087898:	180b883a 	mov	r5,r3
 908789c:	480f883a 	mov	r7,r9
 90878a0:	1009883a 	mov	r4,r2
 90878a4:	400d883a 	mov	r6,r8
 90878a8:	908c5400 	call	908c540 <__adddf3>
 90878ac:	102d883a 	mov	r22,r2
 90878b0:	00bf3034 	movhi	r2,64704
 90878b4:	10ef883a 	add	r23,r2,r3
 90878b8:	d8800d17 	ldw	r2,52(sp)
 90878bc:	d8c00e17 	ldw	r3,56(sp)
 90878c0:	8029883a 	mov	r20,r16
 90878c4:	10bfffc4 	addi	r2,r2,-1
 90878c8:	882b883a 	mov	r21,r17
 90878cc:	d8800415 	stw	r2,16(sp)
 90878d0:	d8c00315 	stw	r3,12(sp)
 90878d4:	003e8306 	br	90872e4 <_dtoa_r+0xf4c>
 90878d8:	d8800117 	ldw	r2,4(sp)
 90878dc:	dc001117 	ldw	r16,68(sp)
 90878e0:	dc801017 	ldw	r18,64(sp)
 90878e4:	00c00d84 	movi	r3,54
 90878e8:	1887c83a 	sub	r3,r3,r2
 90878ec:	003d6906 	br	9086e94 <_dtoa_r+0xafc>
 90878f0:	01800044 	movi	r6,1
 90878f4:	3021883a 	mov	r16,r6
 90878f8:	d9800f15 	stw	r6,60(sp)
 90878fc:	d9802615 	stw	r6,152(sp)
 9087900:	d9800e15 	stw	r6,56(sp)
 9087904:	003b9306 	br	9086754 <_dtoa_r+0x3bc>
 9087908:	b021883a 	mov	r16,r22
 908790c:	dd800f15 	stw	r22,60(sp)
 9087910:	003b9006 	br	9086754 <_dtoa_r+0x3bc>
 9087914:	103e221e 	bne	r2,zero,90871a0 <_dtoa_r+0xe08>
 9087918:	b880004c 	andi	r2,r23,1
 908791c:	1005003a 	cmpeq	r2,r2,zero
 9087920:	103e1f1e 	bne	r2,zero,90871a0 <_dtoa_r+0xe08>
 9087924:	003e1b06 	br	9087194 <_dtoa_r+0xdfc>
 9087928:	d9001617 	ldw	r4,88(sp)
 908792c:	980b883a 	mov	r5,r19
 9087930:	01800284 	movi	r6,10
 9087934:	000f883a 	mov	r7,zero
 9087938:	908a2940 	call	908a294 <__multadd>
 908793c:	d8c00e17 	ldw	r3,56(sp)
 9087940:	1027883a 	mov	r19,r2
 9087944:	d8c00f15 	stw	r3,60(sp)
 9087948:	003cd306 	br	9086c98 <_dtoa_r+0x900>

0908794c <_fflush_r>:
 908794c:	defffb04 	addi	sp,sp,-20
 9087950:	dcc00315 	stw	r19,12(sp)
 9087954:	dc800215 	stw	r18,8(sp)
 9087958:	dfc00415 	stw	ra,16(sp)
 908795c:	dc400115 	stw	r17,4(sp)
 9087960:	dc000015 	stw	r16,0(sp)
 9087964:	2027883a 	mov	r19,r4
 9087968:	2825883a 	mov	r18,r5
 908796c:	20000226 	beq	r4,zero,9087978 <_fflush_r+0x2c>
 9087970:	20800e17 	ldw	r2,56(r4)
 9087974:	10005626 	beq	r2,zero,9087ad0 <_fflush_r+0x184>
 9087978:	9100030b 	ldhu	r4,12(r18)
 908797c:	20ffffcc 	andi	r3,r4,65535
 9087980:	18e0001c 	xori	r3,r3,32768
 9087984:	18e00004 	addi	r3,r3,-32768
 9087988:	1880020c 	andi	r2,r3,8
 908798c:	1000261e 	bne	r2,zero,9087a28 <_fflush_r+0xdc>
 9087990:	90c00117 	ldw	r3,4(r18)
 9087994:	20820014 	ori	r2,r4,2048
 9087998:	9080030d 	sth	r2,12(r18)
 908799c:	1009883a 	mov	r4,r2
 90879a0:	00c0400e 	bge	zero,r3,9087aa4 <_fflush_r+0x158>
 90879a4:	92000a17 	ldw	r8,40(r18)
 90879a8:	40004026 	beq	r8,zero,9087aac <_fflush_r+0x160>
 90879ac:	2084000c 	andi	r2,r4,4096
 90879b0:	10005326 	beq	r2,zero,9087b00 <_fflush_r+0x1b4>
 90879b4:	94001417 	ldw	r16,80(r18)
 90879b8:	9080030b 	ldhu	r2,12(r18)
 90879bc:	1080010c 	andi	r2,r2,4
 90879c0:	1000481e 	bne	r2,zero,9087ae4 <_fflush_r+0x198>
 90879c4:	91400717 	ldw	r5,28(r18)
 90879c8:	9809883a 	mov	r4,r19
 90879cc:	800d883a 	mov	r6,r16
 90879d0:	000f883a 	mov	r7,zero
 90879d4:	403ee83a 	callr	r8
 90879d8:	8080261e 	bne	r16,r2,9087a74 <_fflush_r+0x128>
 90879dc:	9080030b 	ldhu	r2,12(r18)
 90879e0:	91000417 	ldw	r4,16(r18)
 90879e4:	90000115 	stw	zero,4(r18)
 90879e8:	10bdffcc 	andi	r2,r2,63487
 90879ec:	10ffffcc 	andi	r3,r2,65535
 90879f0:	18c4000c 	andi	r3,r3,4096
 90879f4:	9080030d 	sth	r2,12(r18)
 90879f8:	91000015 	stw	r4,0(r18)
 90879fc:	18002b26 	beq	r3,zero,9087aac <_fflush_r+0x160>
 9087a00:	0007883a 	mov	r3,zero
 9087a04:	1805883a 	mov	r2,r3
 9087a08:	94001415 	stw	r16,80(r18)
 9087a0c:	dfc00417 	ldw	ra,16(sp)
 9087a10:	dcc00317 	ldw	r19,12(sp)
 9087a14:	dc800217 	ldw	r18,8(sp)
 9087a18:	dc400117 	ldw	r17,4(sp)
 9087a1c:	dc000017 	ldw	r16,0(sp)
 9087a20:	dec00504 	addi	sp,sp,20
 9087a24:	f800283a 	ret
 9087a28:	94400417 	ldw	r17,16(r18)
 9087a2c:	88001f26 	beq	r17,zero,9087aac <_fflush_r+0x160>
 9087a30:	90800017 	ldw	r2,0(r18)
 9087a34:	18c000cc 	andi	r3,r3,3
 9087a38:	94400015 	stw	r17,0(r18)
 9087a3c:	1461c83a 	sub	r16,r2,r17
 9087a40:	18002526 	beq	r3,zero,9087ad8 <_fflush_r+0x18c>
 9087a44:	0005883a 	mov	r2,zero
 9087a48:	90800215 	stw	r2,8(r18)
 9087a4c:	0400170e 	bge	zero,r16,9087aac <_fflush_r+0x160>
 9087a50:	90c00917 	ldw	r3,36(r18)
 9087a54:	91400717 	ldw	r5,28(r18)
 9087a58:	880d883a 	mov	r6,r17
 9087a5c:	800f883a 	mov	r7,r16
 9087a60:	9809883a 	mov	r4,r19
 9087a64:	183ee83a 	callr	r3
 9087a68:	88a3883a 	add	r17,r17,r2
 9087a6c:	80a1c83a 	sub	r16,r16,r2
 9087a70:	00bff616 	blt	zero,r2,9087a4c <_fflush_r+0x100>
 9087a74:	9080030b 	ldhu	r2,12(r18)
 9087a78:	00ffffc4 	movi	r3,-1
 9087a7c:	10801014 	ori	r2,r2,64
 9087a80:	9080030d 	sth	r2,12(r18)
 9087a84:	1805883a 	mov	r2,r3
 9087a88:	dfc00417 	ldw	ra,16(sp)
 9087a8c:	dcc00317 	ldw	r19,12(sp)
 9087a90:	dc800217 	ldw	r18,8(sp)
 9087a94:	dc400117 	ldw	r17,4(sp)
 9087a98:	dc000017 	ldw	r16,0(sp)
 9087a9c:	dec00504 	addi	sp,sp,20
 9087aa0:	f800283a 	ret
 9087aa4:	90800f17 	ldw	r2,60(r18)
 9087aa8:	00bfbe16 	blt	zero,r2,90879a4 <_fflush_r+0x58>
 9087aac:	0007883a 	mov	r3,zero
 9087ab0:	1805883a 	mov	r2,r3
 9087ab4:	dfc00417 	ldw	ra,16(sp)
 9087ab8:	dcc00317 	ldw	r19,12(sp)
 9087abc:	dc800217 	ldw	r18,8(sp)
 9087ac0:	dc400117 	ldw	r17,4(sp)
 9087ac4:	dc000017 	ldw	r16,0(sp)
 9087ac8:	dec00504 	addi	sp,sp,20
 9087acc:	f800283a 	ret
 9087ad0:	9087be40 	call	9087be4 <__sinit>
 9087ad4:	003fa806 	br	9087978 <_fflush_r+0x2c>
 9087ad8:	90800517 	ldw	r2,20(r18)
 9087adc:	90800215 	stw	r2,8(r18)
 9087ae0:	003fda06 	br	9087a4c <_fflush_r+0x100>
 9087ae4:	90800117 	ldw	r2,4(r18)
 9087ae8:	90c00c17 	ldw	r3,48(r18)
 9087aec:	80a1c83a 	sub	r16,r16,r2
 9087af0:	183fb426 	beq	r3,zero,90879c4 <_fflush_r+0x78>
 9087af4:	90800f17 	ldw	r2,60(r18)
 9087af8:	80a1c83a 	sub	r16,r16,r2
 9087afc:	003fb106 	br	90879c4 <_fflush_r+0x78>
 9087b00:	91400717 	ldw	r5,28(r18)
 9087b04:	9809883a 	mov	r4,r19
 9087b08:	000d883a 	mov	r6,zero
 9087b0c:	01c00044 	movi	r7,1
 9087b10:	403ee83a 	callr	r8
 9087b14:	1021883a 	mov	r16,r2
 9087b18:	00bfffc4 	movi	r2,-1
 9087b1c:	80800226 	beq	r16,r2,9087b28 <_fflush_r+0x1dc>
 9087b20:	92000a17 	ldw	r8,40(r18)
 9087b24:	003fa406 	br	90879b8 <_fflush_r+0x6c>
 9087b28:	98c00017 	ldw	r3,0(r19)
 9087b2c:	00800744 	movi	r2,29
 9087b30:	18bfde26 	beq	r3,r2,9087aac <_fflush_r+0x160>
 9087b34:	9080030b 	ldhu	r2,12(r18)
 9087b38:	8007883a 	mov	r3,r16
 9087b3c:	10801014 	ori	r2,r2,64
 9087b40:	9080030d 	sth	r2,12(r18)
 9087b44:	003fcf06 	br	9087a84 <_fflush_r+0x138>

09087b48 <fflush>:
 9087b48:	01424234 	movhi	r5,2312
 9087b4c:	295e5304 	addi	r5,r5,31052
 9087b50:	2007883a 	mov	r3,r4
 9087b54:	20000526 	beq	r4,zero,9087b6c <fflush+0x24>
 9087b58:	00824374 	movhi	r2,2317
 9087b5c:	108e8604 	addi	r2,r2,14872
 9087b60:	11000017 	ldw	r4,0(r2)
 9087b64:	180b883a 	mov	r5,r3
 9087b68:	908794c1 	jmpi	908794c <_fflush_r>
 9087b6c:	00824374 	movhi	r2,2317
 9087b70:	108e8704 	addi	r2,r2,14876
 9087b74:	11000017 	ldw	r4,0(r2)
 9087b78:	90888641 	jmpi	9088864 <_fwalk_reent>

09087b7c <std>:
 9087b7c:	00824274 	movhi	r2,2313
 9087b80:	10aba204 	addi	r2,r2,-20856
 9087b84:	20800b15 	stw	r2,44(r4)
 9087b88:	00824274 	movhi	r2,2313
 9087b8c:	10abdd04 	addi	r2,r2,-20620
 9087b90:	20800815 	stw	r2,32(r4)
 9087b94:	00c24274 	movhi	r3,2313
 9087b98:	18ebbe04 	addi	r3,r3,-20744
 9087b9c:	00824274 	movhi	r2,2313
 9087ba0:	10aba404 	addi	r2,r2,-20848
 9087ba4:	2140030d 	sth	r5,12(r4)
 9087ba8:	2180038d 	sth	r6,14(r4)
 9087bac:	20c00915 	stw	r3,36(r4)
 9087bb0:	20800a15 	stw	r2,40(r4)
 9087bb4:	20000015 	stw	zero,0(r4)
 9087bb8:	20000115 	stw	zero,4(r4)
 9087bbc:	20000215 	stw	zero,8(r4)
 9087bc0:	20000415 	stw	zero,16(r4)
 9087bc4:	20000515 	stw	zero,20(r4)
 9087bc8:	20000615 	stw	zero,24(r4)
 9087bcc:	21000715 	stw	r4,28(r4)
 9087bd0:	f800283a 	ret

09087bd4 <__sfp_lock_acquire>:
 9087bd4:	f800283a 	ret

09087bd8 <__sfp_lock_release>:
 9087bd8:	f800283a 	ret

09087bdc <__sinit_lock_acquire>:
 9087bdc:	f800283a 	ret

09087be0 <__sinit_lock_release>:
 9087be0:	f800283a 	ret

09087be4 <__sinit>:
 9087be4:	20800e17 	ldw	r2,56(r4)
 9087be8:	defffd04 	addi	sp,sp,-12
 9087bec:	dc400115 	stw	r17,4(sp)
 9087bf0:	dc000015 	stw	r16,0(sp)
 9087bf4:	dfc00215 	stw	ra,8(sp)
 9087bf8:	04400044 	movi	r17,1
 9087bfc:	01400104 	movi	r5,4
 9087c00:	000d883a 	mov	r6,zero
 9087c04:	2021883a 	mov	r16,r4
 9087c08:	2200bb04 	addi	r8,r4,748
 9087c0c:	200f883a 	mov	r7,r4
 9087c10:	10000526 	beq	r2,zero,9087c28 <__sinit+0x44>
 9087c14:	dfc00217 	ldw	ra,8(sp)
 9087c18:	dc400117 	ldw	r17,4(sp)
 9087c1c:	dc000017 	ldw	r16,0(sp)
 9087c20:	dec00304 	addi	sp,sp,12
 9087c24:	f800283a 	ret
 9087c28:	21000117 	ldw	r4,4(r4)
 9087c2c:	00824234 	movhi	r2,2312
 9087c30:	109f3204 	addi	r2,r2,31944
 9087c34:	00c000c4 	movi	r3,3
 9087c38:	80800f15 	stw	r2,60(r16)
 9087c3c:	80c0b915 	stw	r3,740(r16)
 9087c40:	8200ba15 	stw	r8,744(r16)
 9087c44:	84400e15 	stw	r17,56(r16)
 9087c48:	8000b815 	stw	zero,736(r16)
 9087c4c:	9087b7c0 	call	9087b7c <std>
 9087c50:	81000217 	ldw	r4,8(r16)
 9087c54:	880d883a 	mov	r6,r17
 9087c58:	800f883a 	mov	r7,r16
 9087c5c:	01400284 	movi	r5,10
 9087c60:	9087b7c0 	call	9087b7c <std>
 9087c64:	81000317 	ldw	r4,12(r16)
 9087c68:	800f883a 	mov	r7,r16
 9087c6c:	01400484 	movi	r5,18
 9087c70:	01800084 	movi	r6,2
 9087c74:	dfc00217 	ldw	ra,8(sp)
 9087c78:	dc400117 	ldw	r17,4(sp)
 9087c7c:	dc000017 	ldw	r16,0(sp)
 9087c80:	dec00304 	addi	sp,sp,12
 9087c84:	9087b7c1 	jmpi	9087b7c <std>

09087c88 <__fp_lock>:
 9087c88:	0005883a 	mov	r2,zero
 9087c8c:	f800283a 	ret

09087c90 <__fp_unlock>:
 9087c90:	0005883a 	mov	r2,zero
 9087c94:	f800283a 	ret

09087c98 <__fp_unlock_all>:
 9087c98:	00824374 	movhi	r2,2317
 9087c9c:	108e8604 	addi	r2,r2,14872
 9087ca0:	11000017 	ldw	r4,0(r2)
 9087ca4:	01424234 	movhi	r5,2312
 9087ca8:	295f2404 	addi	r5,r5,31888
 9087cac:	908892c1 	jmpi	908892c <_fwalk>

09087cb0 <__fp_lock_all>:
 9087cb0:	00824374 	movhi	r2,2317
 9087cb4:	108e8604 	addi	r2,r2,14872
 9087cb8:	11000017 	ldw	r4,0(r2)
 9087cbc:	01424234 	movhi	r5,2312
 9087cc0:	295f2204 	addi	r5,r5,31880
 9087cc4:	908892c1 	jmpi	908892c <_fwalk>

09087cc8 <_cleanup_r>:
 9087cc8:	01424274 	movhi	r5,2313
 9087ccc:	296ccf04 	addi	r5,r5,-19652
 9087cd0:	908892c1 	jmpi	908892c <_fwalk>

09087cd4 <_cleanup>:
 9087cd4:	00824374 	movhi	r2,2317
 9087cd8:	108e8704 	addi	r2,r2,14876
 9087cdc:	11000017 	ldw	r4,0(r2)
 9087ce0:	9087cc81 	jmpi	9087cc8 <_cleanup_r>

09087ce4 <__sfmoreglue>:
 9087ce4:	defffc04 	addi	sp,sp,-16
 9087ce8:	dc400115 	stw	r17,4(sp)
 9087cec:	2c401724 	muli	r17,r5,92
 9087cf0:	dc800215 	stw	r18,8(sp)
 9087cf4:	2825883a 	mov	r18,r5
 9087cf8:	89400304 	addi	r5,r17,12
 9087cfc:	dc000015 	stw	r16,0(sp)
 9087d00:	dfc00315 	stw	ra,12(sp)
 9087d04:	9088c3c0 	call	9088c3c <_malloc_r>
 9087d08:	0021883a 	mov	r16,zero
 9087d0c:	880d883a 	mov	r6,r17
 9087d10:	000b883a 	mov	r5,zero
 9087d14:	10000626 	beq	r2,zero,9087d30 <__sfmoreglue+0x4c>
 9087d18:	11000304 	addi	r4,r2,12
 9087d1c:	14800115 	stw	r18,4(r2)
 9087d20:	10000015 	stw	zero,0(r2)
 9087d24:	11000215 	stw	r4,8(r2)
 9087d28:	1021883a 	mov	r16,r2
 9087d2c:	90832780 	call	9083278 <memset>
 9087d30:	8005883a 	mov	r2,r16
 9087d34:	dfc00317 	ldw	ra,12(sp)
 9087d38:	dc800217 	ldw	r18,8(sp)
 9087d3c:	dc400117 	ldw	r17,4(sp)
 9087d40:	dc000017 	ldw	r16,0(sp)
 9087d44:	dec00404 	addi	sp,sp,16
 9087d48:	f800283a 	ret

09087d4c <__sfp>:
 9087d4c:	defffd04 	addi	sp,sp,-12
 9087d50:	00824374 	movhi	r2,2317
 9087d54:	108e8704 	addi	r2,r2,14876
 9087d58:	dc000015 	stw	r16,0(sp)
 9087d5c:	14000017 	ldw	r16,0(r2)
 9087d60:	dc400115 	stw	r17,4(sp)
 9087d64:	dfc00215 	stw	ra,8(sp)
 9087d68:	80800e17 	ldw	r2,56(r16)
 9087d6c:	2023883a 	mov	r17,r4
 9087d70:	10002626 	beq	r2,zero,9087e0c <__sfp+0xc0>
 9087d74:	8400b804 	addi	r16,r16,736
 9087d78:	80800117 	ldw	r2,4(r16)
 9087d7c:	81000217 	ldw	r4,8(r16)
 9087d80:	10ffffc4 	addi	r3,r2,-1
 9087d84:	18000916 	blt	r3,zero,9087dac <__sfp+0x60>
 9087d88:	2080030f 	ldh	r2,12(r4)
 9087d8c:	10000b26 	beq	r2,zero,9087dbc <__sfp+0x70>
 9087d90:	017fffc4 	movi	r5,-1
 9087d94:	00000206 	br	9087da0 <__sfp+0x54>
 9087d98:	2080030f 	ldh	r2,12(r4)
 9087d9c:	10000726 	beq	r2,zero,9087dbc <__sfp+0x70>
 9087da0:	18ffffc4 	addi	r3,r3,-1
 9087da4:	21001704 	addi	r4,r4,92
 9087da8:	197ffb1e 	bne	r3,r5,9087d98 <__sfp+0x4c>
 9087dac:	80800017 	ldw	r2,0(r16)
 9087db0:	10001926 	beq	r2,zero,9087e18 <__sfp+0xcc>
 9087db4:	1021883a 	mov	r16,r2
 9087db8:	003fef06 	br	9087d78 <__sfp+0x2c>
 9087dbc:	00bfffc4 	movi	r2,-1
 9087dc0:	00c00044 	movi	r3,1
 9087dc4:	2080038d 	sth	r2,14(r4)
 9087dc8:	20c0030d 	sth	r3,12(r4)
 9087dcc:	20000015 	stw	zero,0(r4)
 9087dd0:	20000215 	stw	zero,8(r4)
 9087dd4:	20000115 	stw	zero,4(r4)
 9087dd8:	20000415 	stw	zero,16(r4)
 9087ddc:	20000515 	stw	zero,20(r4)
 9087de0:	20000615 	stw	zero,24(r4)
 9087de4:	20000c15 	stw	zero,48(r4)
 9087de8:	20000d15 	stw	zero,52(r4)
 9087dec:	20001115 	stw	zero,68(r4)
 9087df0:	20001215 	stw	zero,72(r4)
 9087df4:	2005883a 	mov	r2,r4
 9087df8:	dfc00217 	ldw	ra,8(sp)
 9087dfc:	dc400117 	ldw	r17,4(sp)
 9087e00:	dc000017 	ldw	r16,0(sp)
 9087e04:	dec00304 	addi	sp,sp,12
 9087e08:	f800283a 	ret
 9087e0c:	8009883a 	mov	r4,r16
 9087e10:	9087be40 	call	9087be4 <__sinit>
 9087e14:	003fd706 	br	9087d74 <__sfp+0x28>
 9087e18:	8809883a 	mov	r4,r17
 9087e1c:	01400104 	movi	r5,4
 9087e20:	9087ce40 	call	9087ce4 <__sfmoreglue>
 9087e24:	80800015 	stw	r2,0(r16)
 9087e28:	103fe21e 	bne	r2,zero,9087db4 <__sfp+0x68>
 9087e2c:	00800304 	movi	r2,12
 9087e30:	0009883a 	mov	r4,zero
 9087e34:	88800015 	stw	r2,0(r17)
 9087e38:	003fee06 	br	9087df4 <__sfp+0xa8>

09087e3c <fputc>:
 9087e3c:	defffc04 	addi	sp,sp,-16
 9087e40:	dc800215 	stw	r18,8(sp)
 9087e44:	04824374 	movhi	r18,2317
 9087e48:	948e8604 	addi	r18,r18,14872
 9087e4c:	90c00017 	ldw	r3,0(r18)
 9087e50:	dc400115 	stw	r17,4(sp)
 9087e54:	dc000015 	stw	r16,0(sp)
 9087e58:	dfc00315 	stw	ra,12(sp)
 9087e5c:	2021883a 	mov	r16,r4
 9087e60:	2823883a 	mov	r17,r5
 9087e64:	18000326 	beq	r3,zero,9087e74 <fputc+0x38>
 9087e68:	18800e17 	ldw	r2,56(r3)
 9087e6c:	1809883a 	mov	r4,r3
 9087e70:	10000926 	beq	r2,zero,9087e98 <fputc+0x5c>
 9087e74:	91000017 	ldw	r4,0(r18)
 9087e78:	800b883a 	mov	r5,r16
 9087e7c:	880d883a 	mov	r6,r17
 9087e80:	dfc00317 	ldw	ra,12(sp)
 9087e84:	dc800217 	ldw	r18,8(sp)
 9087e88:	dc400117 	ldw	r17,4(sp)
 9087e8c:	dc000017 	ldw	r16,0(sp)
 9087e90:	dec00404 	addi	sp,sp,16
 9087e94:	908350c1 	jmpi	908350c <_putc_r>
 9087e98:	9087be40 	call	9087be4 <__sinit>
 9087e9c:	003ff506 	br	9087e74 <fputc+0x38>

09087ea0 <_fputc_r>:
 9087ea0:	defffc04 	addi	sp,sp,-16
 9087ea4:	dc800215 	stw	r18,8(sp)
 9087ea8:	dc400115 	stw	r17,4(sp)
 9087eac:	dc000015 	stw	r16,0(sp)
 9087eb0:	dfc00315 	stw	ra,12(sp)
 9087eb4:	2021883a 	mov	r16,r4
 9087eb8:	2823883a 	mov	r17,r5
 9087ebc:	3025883a 	mov	r18,r6
 9087ec0:	20000226 	beq	r4,zero,9087ecc <_fputc_r+0x2c>
 9087ec4:	20800e17 	ldw	r2,56(r4)
 9087ec8:	10000926 	beq	r2,zero,9087ef0 <_fputc_r+0x50>
 9087ecc:	8009883a 	mov	r4,r16
 9087ed0:	880b883a 	mov	r5,r17
 9087ed4:	900d883a 	mov	r6,r18
 9087ed8:	dfc00317 	ldw	ra,12(sp)
 9087edc:	dc800217 	ldw	r18,8(sp)
 9087ee0:	dc400117 	ldw	r17,4(sp)
 9087ee4:	dc000017 	ldw	r16,0(sp)
 9087ee8:	dec00404 	addi	sp,sp,16
 9087eec:	908350c1 	jmpi	908350c <_putc_r>
 9087ef0:	9087be40 	call	9087be4 <__sinit>
 9087ef4:	003ff506 	br	9087ecc <_fputc_r+0x2c>

09087ef8 <_fputs_r>:
 9087ef8:	defff804 	addi	sp,sp,-32
 9087efc:	dc000515 	stw	r16,20(sp)
 9087f00:	2021883a 	mov	r16,r4
 9087f04:	2809883a 	mov	r4,r5
 9087f08:	dc400615 	stw	r17,24(sp)
 9087f0c:	dfc00715 	stw	ra,28(sp)
 9087f10:	3023883a 	mov	r17,r6
 9087f14:	d9400015 	stw	r5,0(sp)
 9087f18:	9083f540 	call	9083f54 <strlen>
 9087f1c:	00c00044 	movi	r3,1
 9087f20:	d8800115 	stw	r2,4(sp)
 9087f24:	d8c00315 	stw	r3,12(sp)
 9087f28:	d8800415 	stw	r2,16(sp)
 9087f2c:	dec00215 	stw	sp,8(sp)
 9087f30:	80000326 	beq	r16,zero,9087f40 <_fputs_r+0x48>
 9087f34:	80800e17 	ldw	r2,56(r16)
 9087f38:	8009883a 	mov	r4,r16
 9087f3c:	10000926 	beq	r2,zero,9087f64 <_fputs_r+0x6c>
 9087f40:	8009883a 	mov	r4,r16
 9087f44:	880b883a 	mov	r5,r17
 9087f48:	d9800204 	addi	r6,sp,8
 9087f4c:	90883c80 	call	90883c8 <__sfvwrite_r>
 9087f50:	dfc00717 	ldw	ra,28(sp)
 9087f54:	dc400617 	ldw	r17,24(sp)
 9087f58:	dc000517 	ldw	r16,20(sp)
 9087f5c:	dec00804 	addi	sp,sp,32
 9087f60:	f800283a 	ret
 9087f64:	9087be40 	call	9087be4 <__sinit>
 9087f68:	003ff506 	br	9087f40 <_fputs_r+0x48>

09087f6c <fputs>:
 9087f6c:	01824374 	movhi	r6,2317
 9087f70:	318e8604 	addi	r6,r6,14872
 9087f74:	2007883a 	mov	r3,r4
 9087f78:	31000017 	ldw	r4,0(r6)
 9087f7c:	280d883a 	mov	r6,r5
 9087f80:	180b883a 	mov	r5,r3
 9087f84:	9087ef81 	jmpi	9087ef8 <_fputs_r>

09087f88 <_malloc_trim_r>:
 9087f88:	defffb04 	addi	sp,sp,-20
 9087f8c:	dcc00315 	stw	r19,12(sp)
 9087f90:	04c24374 	movhi	r19,2317
 9087f94:	9cc7df04 	addi	r19,r19,8060
 9087f98:	dc800215 	stw	r18,8(sp)
 9087f9c:	dc400115 	stw	r17,4(sp)
 9087fa0:	dc000015 	stw	r16,0(sp)
 9087fa4:	2823883a 	mov	r17,r5
 9087fa8:	2025883a 	mov	r18,r4
 9087fac:	dfc00415 	stw	ra,16(sp)
 9087fb0:	908decc0 	call	908decc <__malloc_lock>
 9087fb4:	98800217 	ldw	r2,8(r19)
 9087fb8:	9009883a 	mov	r4,r18
 9087fbc:	000b883a 	mov	r5,zero
 9087fc0:	10c00117 	ldw	r3,4(r2)
 9087fc4:	00bfff04 	movi	r2,-4
 9087fc8:	18a0703a 	and	r16,r3,r2
 9087fcc:	8463c83a 	sub	r17,r16,r17
 9087fd0:	8c43fbc4 	addi	r17,r17,4079
 9087fd4:	8822d33a 	srli	r17,r17,12
 9087fd8:	0083ffc4 	movi	r2,4095
 9087fdc:	8c7fffc4 	addi	r17,r17,-1
 9087fe0:	8822933a 	slli	r17,r17,12
 9087fe4:	1440060e 	bge	r2,r17,9088000 <_malloc_trim_r+0x78>
 9087fe8:	908ae180 	call	908ae18 <_sbrk_r>
 9087fec:	98c00217 	ldw	r3,8(r19)
 9087ff0:	9009883a 	mov	r4,r18
 9087ff4:	044bc83a 	sub	r5,zero,r17
 9087ff8:	80c7883a 	add	r3,r16,r3
 9087ffc:	10c00926 	beq	r2,r3,9088024 <_malloc_trim_r+0x9c>
 9088000:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088004:	0005883a 	mov	r2,zero
 9088008:	dfc00417 	ldw	ra,16(sp)
 908800c:	dcc00317 	ldw	r19,12(sp)
 9088010:	dc800217 	ldw	r18,8(sp)
 9088014:	dc400117 	ldw	r17,4(sp)
 9088018:	dc000017 	ldw	r16,0(sp)
 908801c:	dec00504 	addi	sp,sp,20
 9088020:	f800283a 	ret
 9088024:	9009883a 	mov	r4,r18
 9088028:	908ae180 	call	908ae18 <_sbrk_r>
 908802c:	844dc83a 	sub	r6,r16,r17
 9088030:	00ffffc4 	movi	r3,-1
 9088034:	9009883a 	mov	r4,r18
 9088038:	000b883a 	mov	r5,zero
 908803c:	01c24374 	movhi	r7,2317
 9088040:	39d4e704 	addi	r7,r7,21404
 9088044:	31800054 	ori	r6,r6,1
 9088048:	10c00926 	beq	r2,r3,9088070 <_malloc_trim_r+0xe8>
 908804c:	38800017 	ldw	r2,0(r7)
 9088050:	98c00217 	ldw	r3,8(r19)
 9088054:	9009883a 	mov	r4,r18
 9088058:	1445c83a 	sub	r2,r2,r17
 908805c:	38800015 	stw	r2,0(r7)
 9088060:	19800115 	stw	r6,4(r3)
 9088064:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088068:	00800044 	movi	r2,1
 908806c:	003fe606 	br	9088008 <_malloc_trim_r+0x80>
 9088070:	908ae180 	call	908ae18 <_sbrk_r>
 9088074:	99800217 	ldw	r6,8(r19)
 9088078:	100f883a 	mov	r7,r2
 908807c:	9009883a 	mov	r4,r18
 9088080:	1187c83a 	sub	r3,r2,r6
 9088084:	008003c4 	movi	r2,15
 9088088:	19400054 	ori	r5,r3,1
 908808c:	10ffdc0e 	bge	r2,r3,9088000 <_malloc_trim_r+0x78>
 9088090:	00824374 	movhi	r2,2317
 9088094:	108e8b04 	addi	r2,r2,14892
 9088098:	10c00017 	ldw	r3,0(r2)
 908809c:	00824374 	movhi	r2,2317
 90880a0:	1094e704 	addi	r2,r2,21404
 90880a4:	31400115 	stw	r5,4(r6)
 90880a8:	38c7c83a 	sub	r3,r7,r3
 90880ac:	10c00015 	stw	r3,0(r2)
 90880b0:	003fd306 	br	9088000 <_malloc_trim_r+0x78>

090880b4 <_free_r>:
 90880b4:	defffd04 	addi	sp,sp,-12
 90880b8:	dc400115 	stw	r17,4(sp)
 90880bc:	dc000015 	stw	r16,0(sp)
 90880c0:	dfc00215 	stw	ra,8(sp)
 90880c4:	2821883a 	mov	r16,r5
 90880c8:	2023883a 	mov	r17,r4
 90880cc:	28005a26 	beq	r5,zero,9088238 <_free_r+0x184>
 90880d0:	908decc0 	call	908decc <__malloc_lock>
 90880d4:	823ffe04 	addi	r8,r16,-8
 90880d8:	41400117 	ldw	r5,4(r8)
 90880dc:	00bfff84 	movi	r2,-2
 90880e0:	02824374 	movhi	r10,2317
 90880e4:	5287df04 	addi	r10,r10,8060
 90880e8:	288e703a 	and	r7,r5,r2
 90880ec:	41cd883a 	add	r6,r8,r7
 90880f0:	30c00117 	ldw	r3,4(r6)
 90880f4:	51000217 	ldw	r4,8(r10)
 90880f8:	00bfff04 	movi	r2,-4
 90880fc:	1892703a 	and	r9,r3,r2
 9088100:	5017883a 	mov	r11,r10
 9088104:	31006726 	beq	r6,r4,90882a4 <_free_r+0x1f0>
 9088108:	2880004c 	andi	r2,r5,1
 908810c:	1005003a 	cmpeq	r2,r2,zero
 9088110:	32400115 	stw	r9,4(r6)
 9088114:	10001a1e 	bne	r2,zero,9088180 <_free_r+0xcc>
 9088118:	000b883a 	mov	r5,zero
 908811c:	3247883a 	add	r3,r6,r9
 9088120:	18800117 	ldw	r2,4(r3)
 9088124:	1080004c 	andi	r2,r2,1
 9088128:	1000231e 	bne	r2,zero,90881b8 <_free_r+0x104>
 908812c:	280ac03a 	cmpne	r5,r5,zero
 9088130:	3a4f883a 	add	r7,r7,r9
 9088134:	2800451e 	bne	r5,zero,908824c <_free_r+0x198>
 9088138:	31000217 	ldw	r4,8(r6)
 908813c:	00824374 	movhi	r2,2317
 9088140:	1087e104 	addi	r2,r2,8068
 9088144:	20807b26 	beq	r4,r2,9088334 <_free_r+0x280>
 9088148:	30800317 	ldw	r2,12(r6)
 908814c:	3a07883a 	add	r3,r7,r8
 9088150:	19c00015 	stw	r7,0(r3)
 9088154:	11000215 	stw	r4,8(r2)
 9088158:	20800315 	stw	r2,12(r4)
 908815c:	38800054 	ori	r2,r7,1
 9088160:	40800115 	stw	r2,4(r8)
 9088164:	28001a26 	beq	r5,zero,90881d0 <_free_r+0x11c>
 9088168:	8809883a 	mov	r4,r17
 908816c:	dfc00217 	ldw	ra,8(sp)
 9088170:	dc400117 	ldw	r17,4(sp)
 9088174:	dc000017 	ldw	r16,0(sp)
 9088178:	dec00304 	addi	sp,sp,12
 908817c:	908dfd41 	jmpi	908dfd4 <__malloc_unlock>
 9088180:	80bffe17 	ldw	r2,-8(r16)
 9088184:	50c00204 	addi	r3,r10,8
 9088188:	4091c83a 	sub	r8,r8,r2
 908818c:	41000217 	ldw	r4,8(r8)
 9088190:	388f883a 	add	r7,r7,r2
 9088194:	20c06126 	beq	r4,r3,908831c <_free_r+0x268>
 9088198:	40800317 	ldw	r2,12(r8)
 908819c:	3247883a 	add	r3,r6,r9
 90881a0:	000b883a 	mov	r5,zero
 90881a4:	11000215 	stw	r4,8(r2)
 90881a8:	20800315 	stw	r2,12(r4)
 90881ac:	18800117 	ldw	r2,4(r3)
 90881b0:	1080004c 	andi	r2,r2,1
 90881b4:	103fdd26 	beq	r2,zero,908812c <_free_r+0x78>
 90881b8:	38800054 	ori	r2,r7,1
 90881bc:	3a07883a 	add	r3,r7,r8
 90881c0:	280ac03a 	cmpne	r5,r5,zero
 90881c4:	40800115 	stw	r2,4(r8)
 90881c8:	19c00015 	stw	r7,0(r3)
 90881cc:	283fe61e 	bne	r5,zero,9088168 <_free_r+0xb4>
 90881d0:	00807fc4 	movi	r2,511
 90881d4:	11c01f2e 	bgeu	r2,r7,9088254 <_free_r+0x1a0>
 90881d8:	3806d27a 	srli	r3,r7,9
 90881dc:	1800481e 	bne	r3,zero,9088300 <_free_r+0x24c>
 90881e0:	3804d0fa 	srli	r2,r7,3
 90881e4:	100690fa 	slli	r3,r2,3
 90881e8:	1acd883a 	add	r6,r3,r11
 90881ec:	31400217 	ldw	r5,8(r6)
 90881f0:	31405926 	beq	r6,r5,9088358 <_free_r+0x2a4>
 90881f4:	28800117 	ldw	r2,4(r5)
 90881f8:	00ffff04 	movi	r3,-4
 90881fc:	10c4703a 	and	r2,r2,r3
 9088200:	3880022e 	bgeu	r7,r2,908820c <_free_r+0x158>
 9088204:	29400217 	ldw	r5,8(r5)
 9088208:	317ffa1e 	bne	r6,r5,90881f4 <_free_r+0x140>
 908820c:	29800317 	ldw	r6,12(r5)
 9088210:	41800315 	stw	r6,12(r8)
 9088214:	41400215 	stw	r5,8(r8)
 9088218:	8809883a 	mov	r4,r17
 908821c:	2a000315 	stw	r8,12(r5)
 9088220:	32000215 	stw	r8,8(r6)
 9088224:	dfc00217 	ldw	ra,8(sp)
 9088228:	dc400117 	ldw	r17,4(sp)
 908822c:	dc000017 	ldw	r16,0(sp)
 9088230:	dec00304 	addi	sp,sp,12
 9088234:	908dfd41 	jmpi	908dfd4 <__malloc_unlock>
 9088238:	dfc00217 	ldw	ra,8(sp)
 908823c:	dc400117 	ldw	r17,4(sp)
 9088240:	dc000017 	ldw	r16,0(sp)
 9088244:	dec00304 	addi	sp,sp,12
 9088248:	f800283a 	ret
 908824c:	31000217 	ldw	r4,8(r6)
 9088250:	003fbd06 	br	9088148 <_free_r+0x94>
 9088254:	3806d0fa 	srli	r3,r7,3
 9088258:	00800044 	movi	r2,1
 908825c:	51400117 	ldw	r5,4(r10)
 9088260:	180890fa 	slli	r4,r3,3
 9088264:	1807d0ba 	srai	r3,r3,2
 9088268:	22c9883a 	add	r4,r4,r11
 908826c:	21800217 	ldw	r6,8(r4)
 9088270:	10c4983a 	sll	r2,r2,r3
 9088274:	41000315 	stw	r4,12(r8)
 9088278:	41800215 	stw	r6,8(r8)
 908827c:	288ab03a 	or	r5,r5,r2
 9088280:	22000215 	stw	r8,8(r4)
 9088284:	8809883a 	mov	r4,r17
 9088288:	51400115 	stw	r5,4(r10)
 908828c:	32000315 	stw	r8,12(r6)
 9088290:	dfc00217 	ldw	ra,8(sp)
 9088294:	dc400117 	ldw	r17,4(sp)
 9088298:	dc000017 	ldw	r16,0(sp)
 908829c:	dec00304 	addi	sp,sp,12
 90882a0:	908dfd41 	jmpi	908dfd4 <__malloc_unlock>
 90882a4:	2880004c 	andi	r2,r5,1
 90882a8:	3a4d883a 	add	r6,r7,r9
 90882ac:	1000071e 	bne	r2,zero,90882cc <_free_r+0x218>
 90882b0:	80bffe17 	ldw	r2,-8(r16)
 90882b4:	4091c83a 	sub	r8,r8,r2
 90882b8:	41000317 	ldw	r4,12(r8)
 90882bc:	40c00217 	ldw	r3,8(r8)
 90882c0:	308d883a 	add	r6,r6,r2
 90882c4:	20c00215 	stw	r3,8(r4)
 90882c8:	19000315 	stw	r4,12(r3)
 90882cc:	00824374 	movhi	r2,2317
 90882d0:	108e8a04 	addi	r2,r2,14888
 90882d4:	11000017 	ldw	r4,0(r2)
 90882d8:	30c00054 	ori	r3,r6,1
 90882dc:	52000215 	stw	r8,8(r10)
 90882e0:	40c00115 	stw	r3,4(r8)
 90882e4:	313fa036 	bltu	r6,r4,9088168 <_free_r+0xb4>
 90882e8:	00824374 	movhi	r2,2317
 90882ec:	108ee604 	addi	r2,r2,15256
 90882f0:	11400017 	ldw	r5,0(r2)
 90882f4:	8809883a 	mov	r4,r17
 90882f8:	9087f880 	call	9087f88 <_malloc_trim_r>
 90882fc:	003f9a06 	br	9088168 <_free_r+0xb4>
 9088300:	00800104 	movi	r2,4
 9088304:	10c0072e 	bgeu	r2,r3,9088324 <_free_r+0x270>
 9088308:	00800504 	movi	r2,20
 908830c:	10c01936 	bltu	r2,r3,9088374 <_free_r+0x2c0>
 9088310:	188016c4 	addi	r2,r3,91
 9088314:	100690fa 	slli	r3,r2,3
 9088318:	003fb306 	br	90881e8 <_free_r+0x134>
 908831c:	01400044 	movi	r5,1
 9088320:	003f7e06 	br	908811c <_free_r+0x68>
 9088324:	3804d1ba 	srli	r2,r7,6
 9088328:	10800e04 	addi	r2,r2,56
 908832c:	100690fa 	slli	r3,r2,3
 9088330:	003fad06 	br	90881e8 <_free_r+0x134>
 9088334:	22000315 	stw	r8,12(r4)
 9088338:	22000215 	stw	r8,8(r4)
 908833c:	3a05883a 	add	r2,r7,r8
 9088340:	38c00054 	ori	r3,r7,1
 9088344:	11c00015 	stw	r7,0(r2)
 9088348:	41000215 	stw	r4,8(r8)
 908834c:	40c00115 	stw	r3,4(r8)
 9088350:	41000315 	stw	r4,12(r8)
 9088354:	003f8406 	br	9088168 <_free_r+0xb4>
 9088358:	1005d0ba 	srai	r2,r2,2
 908835c:	00c00044 	movi	r3,1
 9088360:	51000117 	ldw	r4,4(r10)
 9088364:	1886983a 	sll	r3,r3,r2
 9088368:	20c8b03a 	or	r4,r4,r3
 908836c:	51000115 	stw	r4,4(r10)
 9088370:	003fa706 	br	9088210 <_free_r+0x15c>
 9088374:	00801504 	movi	r2,84
 9088378:	10c00436 	bltu	r2,r3,908838c <_free_r+0x2d8>
 908837c:	3804d33a 	srli	r2,r7,12
 9088380:	10801b84 	addi	r2,r2,110
 9088384:	100690fa 	slli	r3,r2,3
 9088388:	003f9706 	br	90881e8 <_free_r+0x134>
 908838c:	00805504 	movi	r2,340
 9088390:	10c00436 	bltu	r2,r3,90883a4 <_free_r+0x2f0>
 9088394:	3804d3fa 	srli	r2,r7,15
 9088398:	10801dc4 	addi	r2,r2,119
 908839c:	100690fa 	slli	r3,r2,3
 90883a0:	003f9106 	br	90881e8 <_free_r+0x134>
 90883a4:	00815504 	movi	r2,1364
 90883a8:	10c0032e 	bgeu	r2,r3,90883b8 <_free_r+0x304>
 90883ac:	00801f84 	movi	r2,126
 90883b0:	00c0fc04 	movi	r3,1008
 90883b4:	003f8c06 	br	90881e8 <_free_r+0x134>
 90883b8:	3804d4ba 	srli	r2,r7,18
 90883bc:	10801f04 	addi	r2,r2,124
 90883c0:	100690fa 	slli	r3,r2,3
 90883c4:	003f8806 	br	90881e8 <_free_r+0x134>

090883c8 <__sfvwrite_r>:
 90883c8:	30800217 	ldw	r2,8(r6)
 90883cc:	defff504 	addi	sp,sp,-44
 90883d0:	df000915 	stw	fp,36(sp)
 90883d4:	dd800715 	stw	r22,28(sp)
 90883d8:	dc800315 	stw	r18,12(sp)
 90883dc:	dfc00a15 	stw	ra,40(sp)
 90883e0:	ddc00815 	stw	r23,32(sp)
 90883e4:	dd400615 	stw	r21,24(sp)
 90883e8:	dd000515 	stw	r20,20(sp)
 90883ec:	dcc00415 	stw	r19,16(sp)
 90883f0:	dc400215 	stw	r17,8(sp)
 90883f4:	dc000115 	stw	r16,4(sp)
 90883f8:	302d883a 	mov	r22,r6
 90883fc:	2039883a 	mov	fp,r4
 9088400:	2825883a 	mov	r18,r5
 9088404:	10001c26 	beq	r2,zero,9088478 <__sfvwrite_r+0xb0>
 9088408:	29c0030b 	ldhu	r7,12(r5)
 908840c:	3880020c 	andi	r2,r7,8
 9088410:	10002726 	beq	r2,zero,90884b0 <__sfvwrite_r+0xe8>
 9088414:	28800417 	ldw	r2,16(r5)
 9088418:	10002526 	beq	r2,zero,90884b0 <__sfvwrite_r+0xe8>
 908841c:	3880008c 	andi	r2,r7,2
 9088420:	b5400017 	ldw	r21,0(r22)
 9088424:	10002826 	beq	r2,zero,90884c8 <__sfvwrite_r+0x100>
 9088428:	0021883a 	mov	r16,zero
 908842c:	0023883a 	mov	r17,zero
 9088430:	880d883a 	mov	r6,r17
 9088434:	e009883a 	mov	r4,fp
 9088438:	00810004 	movi	r2,1024
 908843c:	80006e26 	beq	r16,zero,90885f8 <__sfvwrite_r+0x230>
 9088440:	800f883a 	mov	r7,r16
 9088444:	91400717 	ldw	r5,28(r18)
 9088448:	1400012e 	bgeu	r2,r16,9088450 <__sfvwrite_r+0x88>
 908844c:	100f883a 	mov	r7,r2
 9088450:	90c00917 	ldw	r3,36(r18)
 9088454:	183ee83a 	callr	r3
 9088458:	1007883a 	mov	r3,r2
 908845c:	80a1c83a 	sub	r16,r16,r2
 9088460:	88a3883a 	add	r17,r17,r2
 9088464:	00806d0e 	bge	zero,r2,908861c <__sfvwrite_r+0x254>
 9088468:	b0800217 	ldw	r2,8(r22)
 908846c:	10c5c83a 	sub	r2,r2,r3
 9088470:	b0800215 	stw	r2,8(r22)
 9088474:	103fee1e 	bne	r2,zero,9088430 <__sfvwrite_r+0x68>
 9088478:	0009883a 	mov	r4,zero
 908847c:	2005883a 	mov	r2,r4
 9088480:	dfc00a17 	ldw	ra,40(sp)
 9088484:	df000917 	ldw	fp,36(sp)
 9088488:	ddc00817 	ldw	r23,32(sp)
 908848c:	dd800717 	ldw	r22,28(sp)
 9088490:	dd400617 	ldw	r21,24(sp)
 9088494:	dd000517 	ldw	r20,20(sp)
 9088498:	dcc00417 	ldw	r19,16(sp)
 908849c:	dc800317 	ldw	r18,12(sp)
 90884a0:	dc400217 	ldw	r17,8(sp)
 90884a4:	dc000117 	ldw	r16,4(sp)
 90884a8:	dec00b04 	addi	sp,sp,44
 90884ac:	f800283a 	ret
 90884b0:	90860440 	call	9086044 <__swsetup_r>
 90884b4:	1000e41e 	bne	r2,zero,9088848 <__sfvwrite_r+0x480>
 90884b8:	91c0030b 	ldhu	r7,12(r18)
 90884bc:	b5400017 	ldw	r21,0(r22)
 90884c0:	3880008c 	andi	r2,r7,2
 90884c4:	103fd81e 	bne	r2,zero,9088428 <__sfvwrite_r+0x60>
 90884c8:	3880004c 	andi	r2,r7,1
 90884cc:	1005003a 	cmpeq	r2,r2,zero
 90884d0:	10005726 	beq	r2,zero,9088630 <__sfvwrite_r+0x268>
 90884d4:	0029883a 	mov	r20,zero
 90884d8:	002f883a 	mov	r23,zero
 90884dc:	a0004226 	beq	r20,zero,90885e8 <__sfvwrite_r+0x220>
 90884e0:	3880800c 	andi	r2,r7,512
 90884e4:	94000217 	ldw	r16,8(r18)
 90884e8:	10008b26 	beq	r2,zero,9088718 <__sfvwrite_r+0x350>
 90884ec:	800d883a 	mov	r6,r16
 90884f0:	a400a536 	bltu	r20,r16,9088788 <__sfvwrite_r+0x3c0>
 90884f4:	3881200c 	andi	r2,r7,1152
 90884f8:	10002726 	beq	r2,zero,9088598 <__sfvwrite_r+0x1d0>
 90884fc:	90800517 	ldw	r2,20(r18)
 9088500:	92000417 	ldw	r8,16(r18)
 9088504:	91400017 	ldw	r5,0(r18)
 9088508:	1087883a 	add	r3,r2,r2
 908850c:	1887883a 	add	r3,r3,r2
 9088510:	1808d7fa 	srli	r4,r3,31
 9088514:	2a21c83a 	sub	r16,r5,r8
 9088518:	80800044 	addi	r2,r16,1
 908851c:	20c9883a 	add	r4,r4,r3
 9088520:	2027d07a 	srai	r19,r4,1
 9088524:	a085883a 	add	r2,r20,r2
 9088528:	980d883a 	mov	r6,r19
 908852c:	9880022e 	bgeu	r19,r2,9088538 <__sfvwrite_r+0x170>
 9088530:	1027883a 	mov	r19,r2
 9088534:	100d883a 	mov	r6,r2
 9088538:	3881000c 	andi	r2,r7,1024
 908853c:	1000b826 	beq	r2,zero,9088820 <__sfvwrite_r+0x458>
 9088540:	300b883a 	mov	r5,r6
 9088544:	e009883a 	mov	r4,fp
 9088548:	9088c3c0 	call	9088c3c <_malloc_r>
 908854c:	10003126 	beq	r2,zero,9088614 <__sfvwrite_r+0x24c>
 9088550:	91400417 	ldw	r5,16(r18)
 9088554:	1009883a 	mov	r4,r2
 9088558:	800d883a 	mov	r6,r16
 908855c:	1023883a 	mov	r17,r2
 9088560:	90894600 	call	9089460 <memcpy>
 9088564:	90c0030b 	ldhu	r3,12(r18)
 9088568:	00beffc4 	movi	r2,-1025
 908856c:	1886703a 	and	r3,r3,r2
 9088570:	18c02014 	ori	r3,r3,128
 9088574:	90c0030d 	sth	r3,12(r18)
 9088578:	9c07c83a 	sub	r3,r19,r16
 908857c:	8c05883a 	add	r2,r17,r16
 9088580:	a00d883a 	mov	r6,r20
 9088584:	a021883a 	mov	r16,r20
 9088588:	90800015 	stw	r2,0(r18)
 908858c:	90c00215 	stw	r3,8(r18)
 9088590:	94400415 	stw	r17,16(r18)
 9088594:	94c00515 	stw	r19,20(r18)
 9088598:	91000017 	ldw	r4,0(r18)
 908859c:	b80b883a 	mov	r5,r23
 90885a0:	a023883a 	mov	r17,r20
 90885a4:	90895000 	call	9089500 <memmove>
 90885a8:	90c00217 	ldw	r3,8(r18)
 90885ac:	90800017 	ldw	r2,0(r18)
 90885b0:	a027883a 	mov	r19,r20
 90885b4:	1c07c83a 	sub	r3,r3,r16
 90885b8:	1405883a 	add	r2,r2,r16
 90885bc:	90c00215 	stw	r3,8(r18)
 90885c0:	a021883a 	mov	r16,r20
 90885c4:	90800015 	stw	r2,0(r18)
 90885c8:	b0800217 	ldw	r2,8(r22)
 90885cc:	1405c83a 	sub	r2,r2,r16
 90885d0:	b0800215 	stw	r2,8(r22)
 90885d4:	103fa826 	beq	r2,zero,9088478 <__sfvwrite_r+0xb0>
 90885d8:	a469c83a 	sub	r20,r20,r17
 90885dc:	91c0030b 	ldhu	r7,12(r18)
 90885e0:	bcef883a 	add	r23,r23,r19
 90885e4:	a03fbe1e 	bne	r20,zero,90884e0 <__sfvwrite_r+0x118>
 90885e8:	adc00017 	ldw	r23,0(r21)
 90885ec:	ad000117 	ldw	r20,4(r21)
 90885f0:	ad400204 	addi	r21,r21,8
 90885f4:	003fb906 	br	90884dc <__sfvwrite_r+0x114>
 90885f8:	ac400017 	ldw	r17,0(r21)
 90885fc:	ac000117 	ldw	r16,4(r21)
 9088600:	ad400204 	addi	r21,r21,8
 9088604:	003f8a06 	br	9088430 <__sfvwrite_r+0x68>
 9088608:	91400417 	ldw	r5,16(r18)
 908860c:	e009883a 	mov	r4,fp
 9088610:	90880b40 	call	90880b4 <_free_r>
 9088614:	00800304 	movi	r2,12
 9088618:	e0800015 	stw	r2,0(fp)
 908861c:	9080030b 	ldhu	r2,12(r18)
 9088620:	013fffc4 	movi	r4,-1
 9088624:	10801014 	ori	r2,r2,64
 9088628:	9080030d 	sth	r2,12(r18)
 908862c:	003f9306 	br	908847c <__sfvwrite_r+0xb4>
 9088630:	0027883a 	mov	r19,zero
 9088634:	002f883a 	mov	r23,zero
 9088638:	d8000015 	stw	zero,0(sp)
 908863c:	0029883a 	mov	r20,zero
 9088640:	98001e26 	beq	r19,zero,90886bc <__sfvwrite_r+0x2f4>
 9088644:	d8c00017 	ldw	r3,0(sp)
 9088648:	1804c03a 	cmpne	r2,r3,zero
 908864c:	10005e26 	beq	r2,zero,90887c8 <__sfvwrite_r+0x400>
 9088650:	9821883a 	mov	r16,r19
 9088654:	a4c0012e 	bgeu	r20,r19,908865c <__sfvwrite_r+0x294>
 9088658:	a021883a 	mov	r16,r20
 908865c:	91000017 	ldw	r4,0(r18)
 9088660:	90800417 	ldw	r2,16(r18)
 9088664:	91800217 	ldw	r6,8(r18)
 9088668:	91c00517 	ldw	r7,20(r18)
 908866c:	1100022e 	bgeu	r2,r4,9088678 <__sfvwrite_r+0x2b0>
 9088670:	31e3883a 	add	r17,r6,r7
 9088674:	8c001616 	blt	r17,r16,90886d0 <__sfvwrite_r+0x308>
 9088678:	81c03816 	blt	r16,r7,908875c <__sfvwrite_r+0x394>
 908867c:	90c00917 	ldw	r3,36(r18)
 9088680:	91400717 	ldw	r5,28(r18)
 9088684:	e009883a 	mov	r4,fp
 9088688:	b80d883a 	mov	r6,r23
 908868c:	183ee83a 	callr	r3
 9088690:	1023883a 	mov	r17,r2
 9088694:	00bfe10e 	bge	zero,r2,908861c <__sfvwrite_r+0x254>
 9088698:	a469c83a 	sub	r20,r20,r17
 908869c:	a0001826 	beq	r20,zero,9088700 <__sfvwrite_r+0x338>
 90886a0:	b0800217 	ldw	r2,8(r22)
 90886a4:	1445c83a 	sub	r2,r2,r17
 90886a8:	b0800215 	stw	r2,8(r22)
 90886ac:	103f7226 	beq	r2,zero,9088478 <__sfvwrite_r+0xb0>
 90886b0:	9c67c83a 	sub	r19,r19,r17
 90886b4:	bc6f883a 	add	r23,r23,r17
 90886b8:	983fe21e 	bne	r19,zero,9088644 <__sfvwrite_r+0x27c>
 90886bc:	adc00017 	ldw	r23,0(r21)
 90886c0:	acc00117 	ldw	r19,4(r21)
 90886c4:	ad400204 	addi	r21,r21,8
 90886c8:	d8000015 	stw	zero,0(sp)
 90886cc:	003fdc06 	br	9088640 <__sfvwrite_r+0x278>
 90886d0:	b80b883a 	mov	r5,r23
 90886d4:	880d883a 	mov	r6,r17
 90886d8:	90895000 	call	9089500 <memmove>
 90886dc:	90c00017 	ldw	r3,0(r18)
 90886e0:	e009883a 	mov	r4,fp
 90886e4:	900b883a 	mov	r5,r18
 90886e8:	1c47883a 	add	r3,r3,r17
 90886ec:	90c00015 	stw	r3,0(r18)
 90886f0:	908794c0 	call	908794c <_fflush_r>
 90886f4:	103fc91e 	bne	r2,zero,908861c <__sfvwrite_r+0x254>
 90886f8:	a469c83a 	sub	r20,r20,r17
 90886fc:	a03fe81e 	bne	r20,zero,90886a0 <__sfvwrite_r+0x2d8>
 9088700:	e009883a 	mov	r4,fp
 9088704:	900b883a 	mov	r5,r18
 9088708:	908794c0 	call	908794c <_fflush_r>
 908870c:	103fc31e 	bne	r2,zero,908861c <__sfvwrite_r+0x254>
 9088710:	d8000015 	stw	zero,0(sp)
 9088714:	003fe206 	br	90886a0 <__sfvwrite_r+0x2d8>
 9088718:	91000017 	ldw	r4,0(r18)
 908871c:	90800417 	ldw	r2,16(r18)
 9088720:	1100022e 	bgeu	r2,r4,908872c <__sfvwrite_r+0x364>
 9088724:	8023883a 	mov	r17,r16
 9088728:	85003136 	bltu	r16,r20,90887f0 <__sfvwrite_r+0x428>
 908872c:	91c00517 	ldw	r7,20(r18)
 9088730:	a1c01836 	bltu	r20,r7,9088794 <__sfvwrite_r+0x3cc>
 9088734:	90c00917 	ldw	r3,36(r18)
 9088738:	91400717 	ldw	r5,28(r18)
 908873c:	e009883a 	mov	r4,fp
 9088740:	b80d883a 	mov	r6,r23
 9088744:	183ee83a 	callr	r3
 9088748:	1021883a 	mov	r16,r2
 908874c:	00bfb30e 	bge	zero,r2,908861c <__sfvwrite_r+0x254>
 9088750:	1023883a 	mov	r17,r2
 9088754:	1027883a 	mov	r19,r2
 9088758:	003f9b06 	br	90885c8 <__sfvwrite_r+0x200>
 908875c:	b80b883a 	mov	r5,r23
 9088760:	800d883a 	mov	r6,r16
 9088764:	90895000 	call	9089500 <memmove>
 9088768:	90c00217 	ldw	r3,8(r18)
 908876c:	90800017 	ldw	r2,0(r18)
 9088770:	8023883a 	mov	r17,r16
 9088774:	1c07c83a 	sub	r3,r3,r16
 9088778:	1405883a 	add	r2,r2,r16
 908877c:	90c00215 	stw	r3,8(r18)
 9088780:	90800015 	stw	r2,0(r18)
 9088784:	003fc406 	br	9088698 <__sfvwrite_r+0x2d0>
 9088788:	a00d883a 	mov	r6,r20
 908878c:	a021883a 	mov	r16,r20
 9088790:	003f8106 	br	9088598 <__sfvwrite_r+0x1d0>
 9088794:	b80b883a 	mov	r5,r23
 9088798:	a00d883a 	mov	r6,r20
 908879c:	90895000 	call	9089500 <memmove>
 90887a0:	90c00217 	ldw	r3,8(r18)
 90887a4:	90800017 	ldw	r2,0(r18)
 90887a8:	a021883a 	mov	r16,r20
 90887ac:	1d07c83a 	sub	r3,r3,r20
 90887b0:	1505883a 	add	r2,r2,r20
 90887b4:	a023883a 	mov	r17,r20
 90887b8:	a027883a 	mov	r19,r20
 90887bc:	90c00215 	stw	r3,8(r18)
 90887c0:	90800015 	stw	r2,0(r18)
 90887c4:	003f8006 	br	90885c8 <__sfvwrite_r+0x200>
 90887c8:	b809883a 	mov	r4,r23
 90887cc:	01400284 	movi	r5,10
 90887d0:	980d883a 	mov	r6,r19
 90887d4:	908937c0 	call	908937c <memchr>
 90887d8:	10001726 	beq	r2,zero,9088838 <__sfvwrite_r+0x470>
 90887dc:	15c5c83a 	sub	r2,r2,r23
 90887e0:	15000044 	addi	r20,r2,1
 90887e4:	00800044 	movi	r2,1
 90887e8:	d8800015 	stw	r2,0(sp)
 90887ec:	003f9806 	br	9088650 <__sfvwrite_r+0x288>
 90887f0:	b80b883a 	mov	r5,r23
 90887f4:	800d883a 	mov	r6,r16
 90887f8:	90895000 	call	9089500 <memmove>
 90887fc:	90c00017 	ldw	r3,0(r18)
 9088800:	e009883a 	mov	r4,fp
 9088804:	900b883a 	mov	r5,r18
 9088808:	1c07883a 	add	r3,r3,r16
 908880c:	90c00015 	stw	r3,0(r18)
 9088810:	8027883a 	mov	r19,r16
 9088814:	908794c0 	call	908794c <_fflush_r>
 9088818:	103f6b26 	beq	r2,zero,90885c8 <__sfvwrite_r+0x200>
 908881c:	003f7f06 	br	908861c <__sfvwrite_r+0x254>
 9088820:	400b883a 	mov	r5,r8
 9088824:	e009883a 	mov	r4,fp
 9088828:	908a5d40 	call	908a5d4 <_realloc_r>
 908882c:	103f7626 	beq	r2,zero,9088608 <__sfvwrite_r+0x240>
 9088830:	1023883a 	mov	r17,r2
 9088834:	003f5006 	br	9088578 <__sfvwrite_r+0x1b0>
 9088838:	00c00044 	movi	r3,1
 908883c:	9d000044 	addi	r20,r19,1
 9088840:	d8c00015 	stw	r3,0(sp)
 9088844:	003f8206 	br	9088650 <__sfvwrite_r+0x288>
 9088848:	9080030b 	ldhu	r2,12(r18)
 908884c:	00c00244 	movi	r3,9
 9088850:	013fffc4 	movi	r4,-1
 9088854:	10801014 	ori	r2,r2,64
 9088858:	9080030d 	sth	r2,12(r18)
 908885c:	e0c00015 	stw	r3,0(fp)
 9088860:	003f0606 	br	908847c <__sfvwrite_r+0xb4>

09088864 <_fwalk_reent>:
 9088864:	defff704 	addi	sp,sp,-36
 9088868:	dcc00315 	stw	r19,12(sp)
 908886c:	24c0b804 	addi	r19,r4,736
 9088870:	dd800615 	stw	r22,24(sp)
 9088874:	dd400515 	stw	r21,20(sp)
 9088878:	dfc00815 	stw	ra,32(sp)
 908887c:	ddc00715 	stw	r23,28(sp)
 9088880:	dd000415 	stw	r20,16(sp)
 9088884:	dc800215 	stw	r18,8(sp)
 9088888:	dc400115 	stw	r17,4(sp)
 908888c:	dc000015 	stw	r16,0(sp)
 9088890:	202b883a 	mov	r21,r4
 9088894:	282d883a 	mov	r22,r5
 9088898:	9087bd40 	call	9087bd4 <__sfp_lock_acquire>
 908889c:	98002126 	beq	r19,zero,9088924 <_fwalk_reent+0xc0>
 90888a0:	002f883a 	mov	r23,zero
 90888a4:	9c800117 	ldw	r18,4(r19)
 90888a8:	9c000217 	ldw	r16,8(r19)
 90888ac:	90bfffc4 	addi	r2,r18,-1
 90888b0:	10000d16 	blt	r2,zero,90888e8 <_fwalk_reent+0x84>
 90888b4:	0023883a 	mov	r17,zero
 90888b8:	053fffc4 	movi	r20,-1
 90888bc:	8080030f 	ldh	r2,12(r16)
 90888c0:	8c400044 	addi	r17,r17,1
 90888c4:	10000626 	beq	r2,zero,90888e0 <_fwalk_reent+0x7c>
 90888c8:	8080038f 	ldh	r2,14(r16)
 90888cc:	800b883a 	mov	r5,r16
 90888d0:	a809883a 	mov	r4,r21
 90888d4:	15000226 	beq	r2,r20,90888e0 <_fwalk_reent+0x7c>
 90888d8:	b03ee83a 	callr	r22
 90888dc:	b8aeb03a 	or	r23,r23,r2
 90888e0:	84001704 	addi	r16,r16,92
 90888e4:	947ff51e 	bne	r18,r17,90888bc <_fwalk_reent+0x58>
 90888e8:	9cc00017 	ldw	r19,0(r19)
 90888ec:	983fed1e 	bne	r19,zero,90888a4 <_fwalk_reent+0x40>
 90888f0:	9087bd80 	call	9087bd8 <__sfp_lock_release>
 90888f4:	b805883a 	mov	r2,r23
 90888f8:	dfc00817 	ldw	ra,32(sp)
 90888fc:	ddc00717 	ldw	r23,28(sp)
 9088900:	dd800617 	ldw	r22,24(sp)
 9088904:	dd400517 	ldw	r21,20(sp)
 9088908:	dd000417 	ldw	r20,16(sp)
 908890c:	dcc00317 	ldw	r19,12(sp)
 9088910:	dc800217 	ldw	r18,8(sp)
 9088914:	dc400117 	ldw	r17,4(sp)
 9088918:	dc000017 	ldw	r16,0(sp)
 908891c:	dec00904 	addi	sp,sp,36
 9088920:	f800283a 	ret
 9088924:	002f883a 	mov	r23,zero
 9088928:	003ff106 	br	90888f0 <_fwalk_reent+0x8c>

0908892c <_fwalk>:
 908892c:	defff804 	addi	sp,sp,-32
 9088930:	dcc00315 	stw	r19,12(sp)
 9088934:	24c0b804 	addi	r19,r4,736
 9088938:	dd400515 	stw	r21,20(sp)
 908893c:	dfc00715 	stw	ra,28(sp)
 9088940:	dd800615 	stw	r22,24(sp)
 9088944:	dd000415 	stw	r20,16(sp)
 9088948:	dc800215 	stw	r18,8(sp)
 908894c:	dc400115 	stw	r17,4(sp)
 9088950:	dc000015 	stw	r16,0(sp)
 9088954:	282b883a 	mov	r21,r5
 9088958:	9087bd40 	call	9087bd4 <__sfp_lock_acquire>
 908895c:	98001f26 	beq	r19,zero,90889dc <_fwalk+0xb0>
 9088960:	002d883a 	mov	r22,zero
 9088964:	9c800117 	ldw	r18,4(r19)
 9088968:	9c000217 	ldw	r16,8(r19)
 908896c:	90bfffc4 	addi	r2,r18,-1
 9088970:	10000c16 	blt	r2,zero,90889a4 <_fwalk+0x78>
 9088974:	0023883a 	mov	r17,zero
 9088978:	053fffc4 	movi	r20,-1
 908897c:	8080030f 	ldh	r2,12(r16)
 9088980:	8c400044 	addi	r17,r17,1
 9088984:	10000526 	beq	r2,zero,908899c <_fwalk+0x70>
 9088988:	8080038f 	ldh	r2,14(r16)
 908898c:	8009883a 	mov	r4,r16
 9088990:	15000226 	beq	r2,r20,908899c <_fwalk+0x70>
 9088994:	a83ee83a 	callr	r21
 9088998:	b0acb03a 	or	r22,r22,r2
 908899c:	84001704 	addi	r16,r16,92
 90889a0:	947ff61e 	bne	r18,r17,908897c <_fwalk+0x50>
 90889a4:	9cc00017 	ldw	r19,0(r19)
 90889a8:	983fee1e 	bne	r19,zero,9088964 <_fwalk+0x38>
 90889ac:	9087bd80 	call	9087bd8 <__sfp_lock_release>
 90889b0:	b005883a 	mov	r2,r22
 90889b4:	dfc00717 	ldw	ra,28(sp)
 90889b8:	dd800617 	ldw	r22,24(sp)
 90889bc:	dd400517 	ldw	r21,20(sp)
 90889c0:	dd000417 	ldw	r20,16(sp)
 90889c4:	dcc00317 	ldw	r19,12(sp)
 90889c8:	dc800217 	ldw	r18,8(sp)
 90889cc:	dc400117 	ldw	r17,4(sp)
 90889d0:	dc000017 	ldw	r16,0(sp)
 90889d4:	dec00804 	addi	sp,sp,32
 90889d8:	f800283a 	ret
 90889dc:	002d883a 	mov	r22,zero
 90889e0:	003ff206 	br	90889ac <_fwalk+0x80>

090889e4 <__locale_charset>:
 90889e4:	d0a00417 	ldw	r2,-32752(gp)
 90889e8:	f800283a 	ret

090889ec <_localeconv_r>:
 90889ec:	00824374 	movhi	r2,2317
 90889f0:	10b57204 	addi	r2,r2,-10808
 90889f4:	f800283a 	ret

090889f8 <localeconv>:
 90889f8:	00824374 	movhi	r2,2317
 90889fc:	108e8604 	addi	r2,r2,14872
 9088a00:	11000017 	ldw	r4,0(r2)
 9088a04:	90889ec1 	jmpi	90889ec <_localeconv_r>

09088a08 <_setlocale_r>:
 9088a08:	defffc04 	addi	sp,sp,-16
 9088a0c:	00c24374 	movhi	r3,2317
 9088a10:	18f35e04 	addi	r3,r3,-12936
 9088a14:	dc800215 	stw	r18,8(sp)
 9088a18:	dc400115 	stw	r17,4(sp)
 9088a1c:	dc000015 	stw	r16,0(sp)
 9088a20:	2023883a 	mov	r17,r4
 9088a24:	2825883a 	mov	r18,r5
 9088a28:	dfc00315 	stw	ra,12(sp)
 9088a2c:	3021883a 	mov	r16,r6
 9088a30:	3009883a 	mov	r4,r6
 9088a34:	180b883a 	mov	r5,r3
 9088a38:	30000926 	beq	r6,zero,9088a60 <_setlocale_r+0x58>
 9088a3c:	908afd40 	call	908afd4 <strcmp>
 9088a40:	8009883a 	mov	r4,r16
 9088a44:	01424374 	movhi	r5,2317
 9088a48:	29755904 	addi	r5,r5,-10908
 9088a4c:	10000b1e 	bne	r2,zero,9088a7c <_setlocale_r+0x74>
 9088a50:	8c000d15 	stw	r16,52(r17)
 9088a54:	8c800c15 	stw	r18,48(r17)
 9088a58:	00c24374 	movhi	r3,2317
 9088a5c:	18f35e04 	addi	r3,r3,-12936
 9088a60:	1805883a 	mov	r2,r3
 9088a64:	dfc00317 	ldw	ra,12(sp)
 9088a68:	dc800217 	ldw	r18,8(sp)
 9088a6c:	dc400117 	ldw	r17,4(sp)
 9088a70:	dc000017 	ldw	r16,0(sp)
 9088a74:	dec00404 	addi	sp,sp,16
 9088a78:	f800283a 	ret
 9088a7c:	908afd40 	call	908afd4 <strcmp>
 9088a80:	0007883a 	mov	r3,zero
 9088a84:	103ff226 	beq	r2,zero,9088a50 <_setlocale_r+0x48>
 9088a88:	003ff506 	br	9088a60 <_setlocale_r+0x58>

09088a8c <setlocale>:
 9088a8c:	01824374 	movhi	r6,2317
 9088a90:	318e8604 	addi	r6,r6,14872
 9088a94:	2007883a 	mov	r3,r4
 9088a98:	31000017 	ldw	r4,0(r6)
 9088a9c:	280d883a 	mov	r6,r5
 9088aa0:	180b883a 	mov	r5,r3
 9088aa4:	9088a081 	jmpi	9088a08 <_setlocale_r>

09088aa8 <__smakebuf_r>:
 9088aa8:	2880030b 	ldhu	r2,12(r5)
 9088aac:	deffed04 	addi	sp,sp,-76
 9088ab0:	dc401015 	stw	r17,64(sp)
 9088ab4:	1080008c 	andi	r2,r2,2
 9088ab8:	dc000f15 	stw	r16,60(sp)
 9088abc:	dfc01215 	stw	ra,72(sp)
 9088ac0:	dc801115 	stw	r18,68(sp)
 9088ac4:	2821883a 	mov	r16,r5
 9088ac8:	2023883a 	mov	r17,r4
 9088acc:	10000b26 	beq	r2,zero,9088afc <__smakebuf_r+0x54>
 9088ad0:	28c010c4 	addi	r3,r5,67
 9088ad4:	00800044 	movi	r2,1
 9088ad8:	28800515 	stw	r2,20(r5)
 9088adc:	28c00415 	stw	r3,16(r5)
 9088ae0:	28c00015 	stw	r3,0(r5)
 9088ae4:	dfc01217 	ldw	ra,72(sp)
 9088ae8:	dc801117 	ldw	r18,68(sp)
 9088aec:	dc401017 	ldw	r17,64(sp)
 9088af0:	dc000f17 	ldw	r16,60(sp)
 9088af4:	dec01304 	addi	sp,sp,76
 9088af8:	f800283a 	ret
 9088afc:	2940038f 	ldh	r5,14(r5)
 9088b00:	28002116 	blt	r5,zero,9088b88 <__smakebuf_r+0xe0>
 9088b04:	d80d883a 	mov	r6,sp
 9088b08:	908b3500 	call	908b350 <_fstat_r>
 9088b0c:	10001e16 	blt	r2,zero,9088b88 <__smakebuf_r+0xe0>
 9088b10:	d8800117 	ldw	r2,4(sp)
 9088b14:	00e00014 	movui	r3,32768
 9088b18:	113c000c 	andi	r4,r2,61440
 9088b1c:	20c03126 	beq	r4,r3,9088be4 <__smakebuf_r+0x13c>
 9088b20:	8080030b 	ldhu	r2,12(r16)
 9088b24:	00c80004 	movi	r3,8192
 9088b28:	10820014 	ori	r2,r2,2048
 9088b2c:	8080030d 	sth	r2,12(r16)
 9088b30:	20c01e26 	beq	r4,r3,9088bac <__smakebuf_r+0x104>
 9088b34:	04810004 	movi	r18,1024
 9088b38:	8809883a 	mov	r4,r17
 9088b3c:	900b883a 	mov	r5,r18
 9088b40:	9088c3c0 	call	9088c3c <_malloc_r>
 9088b44:	1009883a 	mov	r4,r2
 9088b48:	10003126 	beq	r2,zero,9088c10 <__smakebuf_r+0x168>
 9088b4c:	80c0030b 	ldhu	r3,12(r16)
 9088b50:	00824234 	movhi	r2,2312
 9088b54:	109f3204 	addi	r2,r2,31944
 9088b58:	88800f15 	stw	r2,60(r17)
 9088b5c:	18c02014 	ori	r3,r3,128
 9088b60:	84800515 	stw	r18,20(r16)
 9088b64:	80c0030d 	sth	r3,12(r16)
 9088b68:	81000415 	stw	r4,16(r16)
 9088b6c:	81000015 	stw	r4,0(r16)
 9088b70:	dfc01217 	ldw	ra,72(sp)
 9088b74:	dc801117 	ldw	r18,68(sp)
 9088b78:	dc401017 	ldw	r17,64(sp)
 9088b7c:	dc000f17 	ldw	r16,60(sp)
 9088b80:	dec01304 	addi	sp,sp,76
 9088b84:	f800283a 	ret
 9088b88:	80c0030b 	ldhu	r3,12(r16)
 9088b8c:	1880200c 	andi	r2,r3,128
 9088b90:	10000426 	beq	r2,zero,9088ba4 <__smakebuf_r+0xfc>
 9088b94:	04801004 	movi	r18,64
 9088b98:	18820014 	ori	r2,r3,2048
 9088b9c:	8080030d 	sth	r2,12(r16)
 9088ba0:	003fe506 	br	9088b38 <__smakebuf_r+0x90>
 9088ba4:	04810004 	movi	r18,1024
 9088ba8:	003ffb06 	br	9088b98 <__smakebuf_r+0xf0>
 9088bac:	8140038f 	ldh	r5,14(r16)
 9088bb0:	8809883a 	mov	r4,r17
 9088bb4:	908b3c40 	call	908b3c4 <_isatty_r>
 9088bb8:	103fde26 	beq	r2,zero,9088b34 <__smakebuf_r+0x8c>
 9088bbc:	8080030b 	ldhu	r2,12(r16)
 9088bc0:	80c010c4 	addi	r3,r16,67
 9088bc4:	04810004 	movi	r18,1024
 9088bc8:	10800054 	ori	r2,r2,1
 9088bcc:	8080030d 	sth	r2,12(r16)
 9088bd0:	00800044 	movi	r2,1
 9088bd4:	80c00415 	stw	r3,16(r16)
 9088bd8:	80800515 	stw	r2,20(r16)
 9088bdc:	80c00015 	stw	r3,0(r16)
 9088be0:	003fd506 	br	9088b38 <__smakebuf_r+0x90>
 9088be4:	80c00a17 	ldw	r3,40(r16)
 9088be8:	00824274 	movhi	r2,2313
 9088bec:	10aba404 	addi	r2,r2,-20848
 9088bf0:	18bfcb1e 	bne	r3,r2,9088b20 <__smakebuf_r+0x78>
 9088bf4:	8080030b 	ldhu	r2,12(r16)
 9088bf8:	00c10004 	movi	r3,1024
 9088bfc:	1825883a 	mov	r18,r3
 9088c00:	10c4b03a 	or	r2,r2,r3
 9088c04:	8080030d 	sth	r2,12(r16)
 9088c08:	80c01315 	stw	r3,76(r16)
 9088c0c:	003fca06 	br	9088b38 <__smakebuf_r+0x90>
 9088c10:	8100030b 	ldhu	r4,12(r16)
 9088c14:	2080800c 	andi	r2,r4,512
 9088c18:	103fb21e 	bne	r2,zero,9088ae4 <__smakebuf_r+0x3c>
 9088c1c:	80c010c4 	addi	r3,r16,67
 9088c20:	21000094 	ori	r4,r4,2
 9088c24:	00800044 	movi	r2,1
 9088c28:	80800515 	stw	r2,20(r16)
 9088c2c:	8100030d 	sth	r4,12(r16)
 9088c30:	80c00415 	stw	r3,16(r16)
 9088c34:	80c00015 	stw	r3,0(r16)
 9088c38:	003faa06 	br	9088ae4 <__smakebuf_r+0x3c>

09088c3c <_malloc_r>:
 9088c3c:	defff604 	addi	sp,sp,-40
 9088c40:	28c002c4 	addi	r3,r5,11
 9088c44:	00800584 	movi	r2,22
 9088c48:	dc800215 	stw	r18,8(sp)
 9088c4c:	dfc00915 	stw	ra,36(sp)
 9088c50:	df000815 	stw	fp,32(sp)
 9088c54:	ddc00715 	stw	r23,28(sp)
 9088c58:	dd800615 	stw	r22,24(sp)
 9088c5c:	dd400515 	stw	r21,20(sp)
 9088c60:	dd000415 	stw	r20,16(sp)
 9088c64:	dcc00315 	stw	r19,12(sp)
 9088c68:	dc400115 	stw	r17,4(sp)
 9088c6c:	dc000015 	stw	r16,0(sp)
 9088c70:	2025883a 	mov	r18,r4
 9088c74:	10c01236 	bltu	r2,r3,9088cc0 <_malloc_r+0x84>
 9088c78:	04400404 	movi	r17,16
 9088c7c:	8940142e 	bgeu	r17,r5,9088cd0 <_malloc_r+0x94>
 9088c80:	00800304 	movi	r2,12
 9088c84:	0007883a 	mov	r3,zero
 9088c88:	90800015 	stw	r2,0(r18)
 9088c8c:	1805883a 	mov	r2,r3
 9088c90:	dfc00917 	ldw	ra,36(sp)
 9088c94:	df000817 	ldw	fp,32(sp)
 9088c98:	ddc00717 	ldw	r23,28(sp)
 9088c9c:	dd800617 	ldw	r22,24(sp)
 9088ca0:	dd400517 	ldw	r21,20(sp)
 9088ca4:	dd000417 	ldw	r20,16(sp)
 9088ca8:	dcc00317 	ldw	r19,12(sp)
 9088cac:	dc800217 	ldw	r18,8(sp)
 9088cb0:	dc400117 	ldw	r17,4(sp)
 9088cb4:	dc000017 	ldw	r16,0(sp)
 9088cb8:	dec00a04 	addi	sp,sp,40
 9088cbc:	f800283a 	ret
 9088cc0:	00bffe04 	movi	r2,-8
 9088cc4:	18a2703a 	and	r17,r3,r2
 9088cc8:	883fed16 	blt	r17,zero,9088c80 <_malloc_r+0x44>
 9088ccc:	897fec36 	bltu	r17,r5,9088c80 <_malloc_r+0x44>
 9088cd0:	9009883a 	mov	r4,r18
 9088cd4:	908decc0 	call	908decc <__malloc_lock>
 9088cd8:	00807dc4 	movi	r2,503
 9088cdc:	14402b2e 	bgeu	r2,r17,9088d8c <_malloc_r+0x150>
 9088ce0:	8806d27a 	srli	r3,r17,9
 9088ce4:	18003f1e 	bne	r3,zero,9088de4 <_malloc_r+0x1a8>
 9088ce8:	880cd0fa 	srli	r6,r17,3
 9088cec:	300490fa 	slli	r2,r6,3
 9088cf0:	02c24374 	movhi	r11,2317
 9088cf4:	5ac7df04 	addi	r11,r11,8060
 9088cf8:	12cb883a 	add	r5,r2,r11
 9088cfc:	2c000317 	ldw	r16,12(r5)
 9088d00:	580f883a 	mov	r7,r11
 9088d04:	2c00041e 	bne	r5,r16,9088d18 <_malloc_r+0xdc>
 9088d08:	00000a06 	br	9088d34 <_malloc_r+0xf8>
 9088d0c:	1800860e 	bge	r3,zero,9088f28 <_malloc_r+0x2ec>
 9088d10:	84000317 	ldw	r16,12(r16)
 9088d14:	2c000726 	beq	r5,r16,9088d34 <_malloc_r+0xf8>
 9088d18:	80800117 	ldw	r2,4(r16)
 9088d1c:	00ffff04 	movi	r3,-4
 9088d20:	10c8703a 	and	r4,r2,r3
 9088d24:	2447c83a 	sub	r3,r4,r17
 9088d28:	008003c4 	movi	r2,15
 9088d2c:	10fff70e 	bge	r2,r3,9088d0c <_malloc_r+0xd0>
 9088d30:	31bfffc4 	addi	r6,r6,-1
 9088d34:	32400044 	addi	r9,r6,1
 9088d38:	02824374 	movhi	r10,2317
 9088d3c:	5287e104 	addi	r10,r10,8068
 9088d40:	54000217 	ldw	r16,8(r10)
 9088d44:	8280a026 	beq	r16,r10,9088fc8 <_malloc_r+0x38c>
 9088d48:	80800117 	ldw	r2,4(r16)
 9088d4c:	00ffff04 	movi	r3,-4
 9088d50:	10ca703a 	and	r5,r2,r3
 9088d54:	2c4dc83a 	sub	r6,r5,r17
 9088d58:	008003c4 	movi	r2,15
 9088d5c:	11808316 	blt	r2,r6,9088f6c <_malloc_r+0x330>
 9088d60:	52800315 	stw	r10,12(r10)
 9088d64:	52800215 	stw	r10,8(r10)
 9088d68:	30002916 	blt	r6,zero,9088e10 <_malloc_r+0x1d4>
 9088d6c:	8147883a 	add	r3,r16,r5
 9088d70:	18800117 	ldw	r2,4(r3)
 9088d74:	9009883a 	mov	r4,r18
 9088d78:	10800054 	ori	r2,r2,1
 9088d7c:	18800115 	stw	r2,4(r3)
 9088d80:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088d84:	80c00204 	addi	r3,r16,8
 9088d88:	003fc006 	br	9088c8c <_malloc_r+0x50>
 9088d8c:	02c24374 	movhi	r11,2317
 9088d90:	5ac7df04 	addi	r11,r11,8060
 9088d94:	8ac5883a 	add	r2,r17,r11
 9088d98:	14000317 	ldw	r16,12(r2)
 9088d9c:	580f883a 	mov	r7,r11
 9088da0:	8806d0fa 	srli	r3,r17,3
 9088da4:	14006c26 	beq	r2,r16,9088f58 <_malloc_r+0x31c>
 9088da8:	80c00117 	ldw	r3,4(r16)
 9088dac:	00bfff04 	movi	r2,-4
 9088db0:	81800317 	ldw	r6,12(r16)
 9088db4:	1886703a 	and	r3,r3,r2
 9088db8:	80c7883a 	add	r3,r16,r3
 9088dbc:	18800117 	ldw	r2,4(r3)
 9088dc0:	81400217 	ldw	r5,8(r16)
 9088dc4:	9009883a 	mov	r4,r18
 9088dc8:	10800054 	ori	r2,r2,1
 9088dcc:	18800115 	stw	r2,4(r3)
 9088dd0:	31400215 	stw	r5,8(r6)
 9088dd4:	29800315 	stw	r6,12(r5)
 9088dd8:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088ddc:	80c00204 	addi	r3,r16,8
 9088de0:	003faa06 	br	9088c8c <_malloc_r+0x50>
 9088de4:	00800104 	movi	r2,4
 9088de8:	10c0052e 	bgeu	r2,r3,9088e00 <_malloc_r+0x1c4>
 9088dec:	00800504 	movi	r2,20
 9088df0:	10c07836 	bltu	r2,r3,9088fd4 <_malloc_r+0x398>
 9088df4:	198016c4 	addi	r6,r3,91
 9088df8:	300490fa 	slli	r2,r6,3
 9088dfc:	003fbc06 	br	9088cf0 <_malloc_r+0xb4>
 9088e00:	8804d1ba 	srli	r2,r17,6
 9088e04:	11800e04 	addi	r6,r2,56
 9088e08:	300490fa 	slli	r2,r6,3
 9088e0c:	003fb806 	br	9088cf0 <_malloc_r+0xb4>
 9088e10:	00807fc4 	movi	r2,511
 9088e14:	1140bb36 	bltu	r2,r5,9089104 <_malloc_r+0x4c8>
 9088e18:	2806d0fa 	srli	r3,r5,3
 9088e1c:	573ffe04 	addi	fp,r10,-8
 9088e20:	00800044 	movi	r2,1
 9088e24:	180890fa 	slli	r4,r3,3
 9088e28:	1807d0ba 	srai	r3,r3,2
 9088e2c:	e1c00117 	ldw	r7,4(fp)
 9088e30:	5909883a 	add	r4,r11,r4
 9088e34:	21400217 	ldw	r5,8(r4)
 9088e38:	10c4983a 	sll	r2,r2,r3
 9088e3c:	81000315 	stw	r4,12(r16)
 9088e40:	81400215 	stw	r5,8(r16)
 9088e44:	388eb03a 	or	r7,r7,r2
 9088e48:	2c000315 	stw	r16,12(r5)
 9088e4c:	24000215 	stw	r16,8(r4)
 9088e50:	e1c00115 	stw	r7,4(fp)
 9088e54:	4807883a 	mov	r3,r9
 9088e58:	4800cd16 	blt	r9,zero,9089190 <_malloc_r+0x554>
 9088e5c:	1807d0ba 	srai	r3,r3,2
 9088e60:	00800044 	movi	r2,1
 9088e64:	10c8983a 	sll	r4,r2,r3
 9088e68:	39004436 	bltu	r7,r4,9088f7c <_malloc_r+0x340>
 9088e6c:	21c4703a 	and	r2,r4,r7
 9088e70:	10000a1e 	bne	r2,zero,9088e9c <_malloc_r+0x260>
 9088e74:	2109883a 	add	r4,r4,r4
 9088e78:	00bfff04 	movi	r2,-4
 9088e7c:	4884703a 	and	r2,r9,r2
 9088e80:	3906703a 	and	r3,r7,r4
 9088e84:	12400104 	addi	r9,r2,4
 9088e88:	1800041e 	bne	r3,zero,9088e9c <_malloc_r+0x260>
 9088e8c:	2109883a 	add	r4,r4,r4
 9088e90:	3904703a 	and	r2,r7,r4
 9088e94:	4a400104 	addi	r9,r9,4
 9088e98:	103ffc26 	beq	r2,zero,9088e8c <_malloc_r+0x250>
 9088e9c:	480490fa 	slli	r2,r9,3
 9088ea0:	4819883a 	mov	r12,r9
 9088ea4:	023fff04 	movi	r8,-4
 9088ea8:	589b883a 	add	r13,r11,r2
 9088eac:	6807883a 	mov	r3,r13
 9088eb0:	014003c4 	movi	r5,15
 9088eb4:	1c000317 	ldw	r16,12(r3)
 9088eb8:	1c00041e 	bne	r3,r16,9088ecc <_malloc_r+0x290>
 9088ebc:	0000a706 	br	908915c <_malloc_r+0x520>
 9088ec0:	3000ab0e 	bge	r6,zero,9089170 <_malloc_r+0x534>
 9088ec4:	84000317 	ldw	r16,12(r16)
 9088ec8:	1c00a426 	beq	r3,r16,908915c <_malloc_r+0x520>
 9088ecc:	80800117 	ldw	r2,4(r16)
 9088ed0:	1204703a 	and	r2,r2,r8
 9088ed4:	144dc83a 	sub	r6,r2,r17
 9088ed8:	29bff90e 	bge	r5,r6,9088ec0 <_malloc_r+0x284>
 9088edc:	81000317 	ldw	r4,12(r16)
 9088ee0:	80c00217 	ldw	r3,8(r16)
 9088ee4:	89400054 	ori	r5,r17,1
 9088ee8:	8445883a 	add	r2,r16,r17
 9088eec:	20c00215 	stw	r3,8(r4)
 9088ef0:	19000315 	stw	r4,12(r3)
 9088ef4:	81400115 	stw	r5,4(r16)
 9088ef8:	1187883a 	add	r3,r2,r6
 9088efc:	31000054 	ori	r4,r6,1
 9088f00:	50800315 	stw	r2,12(r10)
 9088f04:	50800215 	stw	r2,8(r10)
 9088f08:	19800015 	stw	r6,0(r3)
 9088f0c:	11000115 	stw	r4,4(r2)
 9088f10:	12800215 	stw	r10,8(r2)
 9088f14:	12800315 	stw	r10,12(r2)
 9088f18:	9009883a 	mov	r4,r18
 9088f1c:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088f20:	80c00204 	addi	r3,r16,8
 9088f24:	003f5906 	br	9088c8c <_malloc_r+0x50>
 9088f28:	8109883a 	add	r4,r16,r4
 9088f2c:	20800117 	ldw	r2,4(r4)
 9088f30:	80c00217 	ldw	r3,8(r16)
 9088f34:	81400317 	ldw	r5,12(r16)
 9088f38:	10800054 	ori	r2,r2,1
 9088f3c:	20800115 	stw	r2,4(r4)
 9088f40:	28c00215 	stw	r3,8(r5)
 9088f44:	19400315 	stw	r5,12(r3)
 9088f48:	9009883a 	mov	r4,r18
 9088f4c:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088f50:	80c00204 	addi	r3,r16,8
 9088f54:	003f4d06 	br	9088c8c <_malloc_r+0x50>
 9088f58:	80800204 	addi	r2,r16,8
 9088f5c:	14000317 	ldw	r16,12(r2)
 9088f60:	143f911e 	bne	r2,r16,9088da8 <_malloc_r+0x16c>
 9088f64:	1a400084 	addi	r9,r3,2
 9088f68:	003f7306 	br	9088d38 <_malloc_r+0xfc>
 9088f6c:	88c00054 	ori	r3,r17,1
 9088f70:	8445883a 	add	r2,r16,r17
 9088f74:	80c00115 	stw	r3,4(r16)
 9088f78:	003fdf06 	br	9088ef8 <_malloc_r+0x2bc>
 9088f7c:	e4000217 	ldw	r16,8(fp)
 9088f80:	00bfff04 	movi	r2,-4
 9088f84:	80c00117 	ldw	r3,4(r16)
 9088f88:	802d883a 	mov	r22,r16
 9088f8c:	18aa703a 	and	r21,r3,r2
 9088f90:	ac401636 	bltu	r21,r17,9088fec <_malloc_r+0x3b0>
 9088f94:	ac49c83a 	sub	r4,r21,r17
 9088f98:	008003c4 	movi	r2,15
 9088f9c:	1100130e 	bge	r2,r4,9088fec <_malloc_r+0x3b0>
 9088fa0:	88800054 	ori	r2,r17,1
 9088fa4:	8447883a 	add	r3,r16,r17
 9088fa8:	80800115 	stw	r2,4(r16)
 9088fac:	20800054 	ori	r2,r4,1
 9088fb0:	18800115 	stw	r2,4(r3)
 9088fb4:	e0c00215 	stw	r3,8(fp)
 9088fb8:	9009883a 	mov	r4,r18
 9088fbc:	908dfd40 	call	908dfd4 <__malloc_unlock>
 9088fc0:	80c00204 	addi	r3,r16,8
 9088fc4:	003f3106 	br	9088c8c <_malloc_r+0x50>
 9088fc8:	39c00117 	ldw	r7,4(r7)
 9088fcc:	573ffe04 	addi	fp,r10,-8
 9088fd0:	003fa006 	br	9088e54 <_malloc_r+0x218>
 9088fd4:	00801504 	movi	r2,84
 9088fd8:	10c06736 	bltu	r2,r3,9089178 <_malloc_r+0x53c>
 9088fdc:	8804d33a 	srli	r2,r17,12
 9088fe0:	11801b84 	addi	r6,r2,110
 9088fe4:	300490fa 	slli	r2,r6,3
 9088fe8:	003f4106 	br	9088cf0 <_malloc_r+0xb4>
 9088fec:	d0a06117 	ldw	r2,-32380(gp)
 9088ff0:	d0e00617 	ldw	r3,-32744(gp)
 9088ff4:	053fffc4 	movi	r20,-1
 9088ff8:	10800404 	addi	r2,r2,16
 9088ffc:	88a7883a 	add	r19,r17,r2
 9089000:	1d000326 	beq	r3,r20,9089010 <_malloc_r+0x3d4>
 9089004:	98c3ffc4 	addi	r3,r19,4095
 9089008:	00bc0004 	movi	r2,-4096
 908900c:	18a6703a 	and	r19,r3,r2
 9089010:	9009883a 	mov	r4,r18
 9089014:	980b883a 	mov	r5,r19
 9089018:	908ae180 	call	908ae18 <_sbrk_r>
 908901c:	1009883a 	mov	r4,r2
 9089020:	15000426 	beq	r2,r20,9089034 <_malloc_r+0x3f8>
 9089024:	854b883a 	add	r5,r16,r21
 9089028:	1029883a 	mov	r20,r2
 908902c:	11405a2e 	bgeu	r2,r5,9089198 <_malloc_r+0x55c>
 9089030:	87000c26 	beq	r16,fp,9089064 <_malloc_r+0x428>
 9089034:	e4000217 	ldw	r16,8(fp)
 9089038:	80c00117 	ldw	r3,4(r16)
 908903c:	00bfff04 	movi	r2,-4
 9089040:	1884703a 	and	r2,r3,r2
 9089044:	14400336 	bltu	r2,r17,9089054 <_malloc_r+0x418>
 9089048:	1449c83a 	sub	r4,r2,r17
 908904c:	008003c4 	movi	r2,15
 9089050:	113fd316 	blt	r2,r4,9088fa0 <_malloc_r+0x364>
 9089054:	9009883a 	mov	r4,r18
 9089058:	908dfd40 	call	908dfd4 <__malloc_unlock>
 908905c:	0007883a 	mov	r3,zero
 9089060:	003f0a06 	br	9088c8c <_malloc_r+0x50>
 9089064:	05c24374 	movhi	r23,2317
 9089068:	bdd4e704 	addi	r23,r23,21404
 908906c:	b8800017 	ldw	r2,0(r23)
 9089070:	988d883a 	add	r6,r19,r2
 9089074:	b9800015 	stw	r6,0(r23)
 9089078:	d0e00617 	ldw	r3,-32744(gp)
 908907c:	00bfffc4 	movi	r2,-1
 9089080:	18808e26 	beq	r3,r2,90892bc <_malloc_r+0x680>
 9089084:	2145c83a 	sub	r2,r4,r5
 9089088:	3085883a 	add	r2,r6,r2
 908908c:	b8800015 	stw	r2,0(r23)
 9089090:	20c001cc 	andi	r3,r4,7
 9089094:	18005f1e 	bne	r3,zero,9089214 <_malloc_r+0x5d8>
 9089098:	000b883a 	mov	r5,zero
 908909c:	a4c5883a 	add	r2,r20,r19
 90890a0:	1083ffcc 	andi	r2,r2,4095
 90890a4:	00c40004 	movi	r3,4096
 90890a8:	1887c83a 	sub	r3,r3,r2
 90890ac:	28e7883a 	add	r19,r5,r3
 90890b0:	9009883a 	mov	r4,r18
 90890b4:	980b883a 	mov	r5,r19
 90890b8:	908ae180 	call	908ae18 <_sbrk_r>
 90890bc:	1007883a 	mov	r3,r2
 90890c0:	00bfffc4 	movi	r2,-1
 90890c4:	18807a26 	beq	r3,r2,90892b0 <_malloc_r+0x674>
 90890c8:	1d05c83a 	sub	r2,r3,r20
 90890cc:	9885883a 	add	r2,r19,r2
 90890d0:	10c00054 	ori	r3,r2,1
 90890d4:	b8800017 	ldw	r2,0(r23)
 90890d8:	a021883a 	mov	r16,r20
 90890dc:	a0c00115 	stw	r3,4(r20)
 90890e0:	9885883a 	add	r2,r19,r2
 90890e4:	b8800015 	stw	r2,0(r23)
 90890e8:	e5000215 	stw	r20,8(fp)
 90890ec:	b7003626 	beq	r22,fp,90891c8 <_malloc_r+0x58c>
 90890f0:	018003c4 	movi	r6,15
 90890f4:	35404b36 	bltu	r6,r21,9089224 <_malloc_r+0x5e8>
 90890f8:	00800044 	movi	r2,1
 90890fc:	a0800115 	stw	r2,4(r20)
 9089100:	003fcd06 	br	9089038 <_malloc_r+0x3fc>
 9089104:	2808d27a 	srli	r4,r5,9
 9089108:	2000371e 	bne	r4,zero,90891e8 <_malloc_r+0x5ac>
 908910c:	2808d0fa 	srli	r4,r5,3
 9089110:	200690fa 	slli	r3,r4,3
 9089114:	1ad1883a 	add	r8,r3,r11
 9089118:	41800217 	ldw	r6,8(r8)
 908911c:	41805b26 	beq	r8,r6,908928c <_malloc_r+0x650>
 9089120:	30800117 	ldw	r2,4(r6)
 9089124:	00ffff04 	movi	r3,-4
 9089128:	10c4703a 	and	r2,r2,r3
 908912c:	2880022e 	bgeu	r5,r2,9089138 <_malloc_r+0x4fc>
 9089130:	31800217 	ldw	r6,8(r6)
 9089134:	41bffa1e 	bne	r8,r6,9089120 <_malloc_r+0x4e4>
 9089138:	32000317 	ldw	r8,12(r6)
 908913c:	39c00117 	ldw	r7,4(r7)
 9089140:	82000315 	stw	r8,12(r16)
 9089144:	81800215 	stw	r6,8(r16)
 9089148:	07024374 	movhi	fp,2317
 908914c:	e707df04 	addi	fp,fp,8060
 9089150:	34000315 	stw	r16,12(r6)
 9089154:	44000215 	stw	r16,8(r8)
 9089158:	003f3e06 	br	9088e54 <_malloc_r+0x218>
 908915c:	63000044 	addi	r12,r12,1
 9089160:	608000cc 	andi	r2,r12,3
 9089164:	10005d26 	beq	r2,zero,90892dc <_malloc_r+0x6a0>
 9089168:	18c00204 	addi	r3,r3,8
 908916c:	003f5106 	br	9088eb4 <_malloc_r+0x278>
 9089170:	8089883a 	add	r4,r16,r2
 9089174:	003f6d06 	br	9088f2c <_malloc_r+0x2f0>
 9089178:	00805504 	movi	r2,340
 908917c:	10c02036 	bltu	r2,r3,9089200 <_malloc_r+0x5c4>
 9089180:	8804d3fa 	srli	r2,r17,15
 9089184:	11801dc4 	addi	r6,r2,119
 9089188:	300490fa 	slli	r2,r6,3
 908918c:	003ed806 	br	9088cf0 <_malloc_r+0xb4>
 9089190:	48c000c4 	addi	r3,r9,3
 9089194:	003f3106 	br	9088e5c <_malloc_r+0x220>
 9089198:	05c24374 	movhi	r23,2317
 908919c:	bdd4e704 	addi	r23,r23,21404
 90891a0:	b8800017 	ldw	r2,0(r23)
 90891a4:	988d883a 	add	r6,r19,r2
 90891a8:	b9800015 	stw	r6,0(r23)
 90891ac:	293fb21e 	bne	r5,r4,9089078 <_malloc_r+0x43c>
 90891b0:	2083ffcc 	andi	r2,r4,4095
 90891b4:	103fb01e 	bne	r2,zero,9089078 <_malloc_r+0x43c>
 90891b8:	e4000217 	ldw	r16,8(fp)
 90891bc:	9d45883a 	add	r2,r19,r21
 90891c0:	10800054 	ori	r2,r2,1
 90891c4:	80800115 	stw	r2,4(r16)
 90891c8:	b8c00017 	ldw	r3,0(r23)
 90891cc:	d0a06217 	ldw	r2,-32376(gp)
 90891d0:	10c0012e 	bgeu	r2,r3,90891d8 <_malloc_r+0x59c>
 90891d4:	d0e06215 	stw	r3,-32376(gp)
 90891d8:	d0a06317 	ldw	r2,-32372(gp)
 90891dc:	10ff962e 	bgeu	r2,r3,9089038 <_malloc_r+0x3fc>
 90891e0:	d0e06315 	stw	r3,-32372(gp)
 90891e4:	003f9406 	br	9089038 <_malloc_r+0x3fc>
 90891e8:	00800104 	movi	r2,4
 90891ec:	11001e36 	bltu	r2,r4,9089268 <_malloc_r+0x62c>
 90891f0:	2804d1ba 	srli	r2,r5,6
 90891f4:	11000e04 	addi	r4,r2,56
 90891f8:	200690fa 	slli	r3,r4,3
 90891fc:	003fc506 	br	9089114 <_malloc_r+0x4d8>
 9089200:	00815504 	movi	r2,1364
 9089204:	10c01d2e 	bgeu	r2,r3,908927c <_malloc_r+0x640>
 9089208:	01801f84 	movi	r6,126
 908920c:	0080fc04 	movi	r2,1008
 9089210:	003eb706 	br	9088cf0 <_malloc_r+0xb4>
 9089214:	00800204 	movi	r2,8
 9089218:	10cbc83a 	sub	r5,r2,r3
 908921c:	2169883a 	add	r20,r4,r5
 9089220:	003f9e06 	br	908909c <_malloc_r+0x460>
 9089224:	00bffe04 	movi	r2,-8
 9089228:	a93ffd04 	addi	r4,r21,-12
 908922c:	2088703a 	and	r4,r4,r2
 9089230:	b10b883a 	add	r5,r22,r4
 9089234:	00c00144 	movi	r3,5
 9089238:	28c00215 	stw	r3,8(r5)
 908923c:	28c00115 	stw	r3,4(r5)
 9089240:	b0800117 	ldw	r2,4(r22)
 9089244:	1080004c 	andi	r2,r2,1
 9089248:	2084b03a 	or	r2,r4,r2
 908924c:	b0800115 	stw	r2,4(r22)
 9089250:	313fdd2e 	bgeu	r6,r4,90891c8 <_malloc_r+0x58c>
 9089254:	b1400204 	addi	r5,r22,8
 9089258:	9009883a 	mov	r4,r18
 908925c:	90880b40 	call	90880b4 <_free_r>
 9089260:	e4000217 	ldw	r16,8(fp)
 9089264:	003fd806 	br	90891c8 <_malloc_r+0x58c>
 9089268:	00800504 	movi	r2,20
 908926c:	11001536 	bltu	r2,r4,90892c4 <_malloc_r+0x688>
 9089270:	210016c4 	addi	r4,r4,91
 9089274:	200690fa 	slli	r3,r4,3
 9089278:	003fa606 	br	9089114 <_malloc_r+0x4d8>
 908927c:	8804d4ba 	srli	r2,r17,18
 9089280:	11801f04 	addi	r6,r2,124
 9089284:	300490fa 	slli	r2,r6,3
 9089288:	003e9906 	br	9088cf0 <_malloc_r+0xb4>
 908928c:	2009d0ba 	srai	r4,r4,2
 9089290:	01424374 	movhi	r5,2317
 9089294:	2947df04 	addi	r5,r5,8060
 9089298:	00c00044 	movi	r3,1
 908929c:	28800117 	ldw	r2,4(r5)
 90892a0:	1906983a 	sll	r3,r3,r4
 90892a4:	10c4b03a 	or	r2,r2,r3
 90892a8:	28800115 	stw	r2,4(r5)
 90892ac:	003fa306 	br	908913c <_malloc_r+0x500>
 90892b0:	0027883a 	mov	r19,zero
 90892b4:	00c00044 	movi	r3,1
 90892b8:	003f8606 	br	90890d4 <_malloc_r+0x498>
 90892bc:	d1200615 	stw	r4,-32744(gp)
 90892c0:	003f7306 	br	9089090 <_malloc_r+0x454>
 90892c4:	00801504 	movi	r2,84
 90892c8:	11001936 	bltu	r2,r4,9089330 <_malloc_r+0x6f4>
 90892cc:	2804d33a 	srli	r2,r5,12
 90892d0:	11001b84 	addi	r4,r2,110
 90892d4:	200690fa 	slli	r3,r4,3
 90892d8:	003f8e06 	br	9089114 <_malloc_r+0x4d8>
 90892dc:	480b883a 	mov	r5,r9
 90892e0:	6807883a 	mov	r3,r13
 90892e4:	288000cc 	andi	r2,r5,3
 90892e8:	18fffe04 	addi	r3,r3,-8
 90892ec:	297fffc4 	addi	r5,r5,-1
 90892f0:	10001526 	beq	r2,zero,9089348 <_malloc_r+0x70c>
 90892f4:	18800217 	ldw	r2,8(r3)
 90892f8:	10fffa26 	beq	r2,r3,90892e4 <_malloc_r+0x6a8>
 90892fc:	2109883a 	add	r4,r4,r4
 9089300:	393f1e36 	bltu	r7,r4,9088f7c <_malloc_r+0x340>
 9089304:	203f1d26 	beq	r4,zero,9088f7c <_malloc_r+0x340>
 9089308:	21c4703a 	and	r2,r4,r7
 908930c:	10000226 	beq	r2,zero,9089318 <_malloc_r+0x6dc>
 9089310:	6013883a 	mov	r9,r12
 9089314:	003ee106 	br	9088e9c <_malloc_r+0x260>
 9089318:	2109883a 	add	r4,r4,r4
 908931c:	3904703a 	and	r2,r7,r4
 9089320:	63000104 	addi	r12,r12,4
 9089324:	103ffc26 	beq	r2,zero,9089318 <_malloc_r+0x6dc>
 9089328:	6013883a 	mov	r9,r12
 908932c:	003edb06 	br	9088e9c <_malloc_r+0x260>
 9089330:	00805504 	movi	r2,340
 9089334:	11000836 	bltu	r2,r4,9089358 <_malloc_r+0x71c>
 9089338:	2804d3fa 	srli	r2,r5,15
 908933c:	11001dc4 	addi	r4,r2,119
 9089340:	200690fa 	slli	r3,r4,3
 9089344:	003f7306 	br	9089114 <_malloc_r+0x4d8>
 9089348:	0104303a 	nor	r2,zero,r4
 908934c:	388e703a 	and	r7,r7,r2
 9089350:	e1c00115 	stw	r7,4(fp)
 9089354:	003fe906 	br	90892fc <_malloc_r+0x6c0>
 9089358:	00815504 	movi	r2,1364
 908935c:	1100032e 	bgeu	r2,r4,908936c <_malloc_r+0x730>
 9089360:	01001f84 	movi	r4,126
 9089364:	00c0fc04 	movi	r3,1008
 9089368:	003f6a06 	br	9089114 <_malloc_r+0x4d8>
 908936c:	2804d4ba 	srli	r2,r5,18
 9089370:	11001f04 	addi	r4,r2,124
 9089374:	200690fa 	slli	r3,r4,3
 9089378:	003f6606 	br	9089114 <_malloc_r+0x4d8>

0908937c <memchr>:
 908937c:	008000c4 	movi	r2,3
 9089380:	29403fcc 	andi	r5,r5,255
 9089384:	2007883a 	mov	r3,r4
 9089388:	1180022e 	bgeu	r2,r6,9089394 <memchr+0x18>
 908938c:	2084703a 	and	r2,r4,r2
 9089390:	10000b26 	beq	r2,zero,90893c0 <memchr+0x44>
 9089394:	313fffc4 	addi	r4,r6,-1
 9089398:	3000051e 	bne	r6,zero,90893b0 <memchr+0x34>
 908939c:	00002c06 	br	9089450 <memchr+0xd4>
 90893a0:	213fffc4 	addi	r4,r4,-1
 90893a4:	00bfffc4 	movi	r2,-1
 90893a8:	18c00044 	addi	r3,r3,1
 90893ac:	20802826 	beq	r4,r2,9089450 <memchr+0xd4>
 90893b0:	18800003 	ldbu	r2,0(r3)
 90893b4:	28bffa1e 	bne	r5,r2,90893a0 <memchr+0x24>
 90893b8:	1805883a 	mov	r2,r3
 90893bc:	f800283a 	ret
 90893c0:	0011883a 	mov	r8,zero
 90893c4:	0007883a 	mov	r3,zero
 90893c8:	01c00104 	movi	r7,4
 90893cc:	4004923a 	slli	r2,r8,8
 90893d0:	18c00044 	addi	r3,r3,1
 90893d4:	1151883a 	add	r8,r2,r5
 90893d8:	19fffc1e 	bne	r3,r7,90893cc <memchr+0x50>
 90893dc:	02bfbff4 	movhi	r10,65279
 90893e0:	52bfbfc4 	addi	r10,r10,-257
 90893e4:	02602074 	movhi	r9,32897
 90893e8:	4a602004 	addi	r9,r9,-32640
 90893ec:	02c000c4 	movi	r11,3
 90893f0:	20800017 	ldw	r2,0(r4)
 90893f4:	31bfff04 	addi	r6,r6,-4
 90893f8:	200f883a 	mov	r7,r4
 90893fc:	1204f03a 	xor	r2,r2,r8
 9089400:	1287883a 	add	r3,r2,r10
 9089404:	1a46703a 	and	r3,r3,r9
 9089408:	0084303a 	nor	r2,zero,r2
 908940c:	10c4703a 	and	r2,r2,r3
 9089410:	10000b26 	beq	r2,zero,9089440 <memchr+0xc4>
 9089414:	20800003 	ldbu	r2,0(r4)
 9089418:	28800f26 	beq	r5,r2,9089458 <memchr+0xdc>
 908941c:	20800043 	ldbu	r2,1(r4)
 9089420:	21c00044 	addi	r7,r4,1
 9089424:	28800c26 	beq	r5,r2,9089458 <memchr+0xdc>
 9089428:	20800083 	ldbu	r2,2(r4)
 908942c:	21c00084 	addi	r7,r4,2
 9089430:	28800926 	beq	r5,r2,9089458 <memchr+0xdc>
 9089434:	208000c3 	ldbu	r2,3(r4)
 9089438:	21c000c4 	addi	r7,r4,3
 908943c:	28800626 	beq	r5,r2,9089458 <memchr+0xdc>
 9089440:	21000104 	addi	r4,r4,4
 9089444:	59bfea36 	bltu	r11,r6,90893f0 <memchr+0x74>
 9089448:	2007883a 	mov	r3,r4
 908944c:	003fd106 	br	9089394 <memchr+0x18>
 9089450:	0005883a 	mov	r2,zero
 9089454:	f800283a 	ret
 9089458:	3805883a 	mov	r2,r7
 908945c:	f800283a 	ret

09089460 <memcpy>:
 9089460:	01c003c4 	movi	r7,15
 9089464:	2007883a 	mov	r3,r4
 9089468:	3980032e 	bgeu	r7,r6,9089478 <memcpy+0x18>
 908946c:	2904b03a 	or	r2,r5,r4
 9089470:	108000cc 	andi	r2,r2,3
 9089474:	10000926 	beq	r2,zero,908949c <memcpy+0x3c>
 9089478:	30000626 	beq	r6,zero,9089494 <memcpy+0x34>
 908947c:	30cd883a 	add	r6,r6,r3
 9089480:	28800003 	ldbu	r2,0(r5)
 9089484:	29400044 	addi	r5,r5,1
 9089488:	18800005 	stb	r2,0(r3)
 908948c:	18c00044 	addi	r3,r3,1
 9089490:	30fffb1e 	bne	r6,r3,9089480 <memcpy+0x20>
 9089494:	2005883a 	mov	r2,r4
 9089498:	f800283a 	ret
 908949c:	3811883a 	mov	r8,r7
 90894a0:	200f883a 	mov	r7,r4
 90894a4:	28c00017 	ldw	r3,0(r5)
 90894a8:	31bffc04 	addi	r6,r6,-16
 90894ac:	38c00015 	stw	r3,0(r7)
 90894b0:	28800117 	ldw	r2,4(r5)
 90894b4:	38800115 	stw	r2,4(r7)
 90894b8:	28c00217 	ldw	r3,8(r5)
 90894bc:	38c00215 	stw	r3,8(r7)
 90894c0:	28800317 	ldw	r2,12(r5)
 90894c4:	29400404 	addi	r5,r5,16
 90894c8:	38800315 	stw	r2,12(r7)
 90894cc:	39c00404 	addi	r7,r7,16
 90894d0:	41bff436 	bltu	r8,r6,90894a4 <memcpy+0x44>
 90894d4:	008000c4 	movi	r2,3
 90894d8:	1180072e 	bgeu	r2,r6,90894f8 <memcpy+0x98>
 90894dc:	1007883a 	mov	r3,r2
 90894e0:	28800017 	ldw	r2,0(r5)
 90894e4:	31bfff04 	addi	r6,r6,-4
 90894e8:	29400104 	addi	r5,r5,4
 90894ec:	38800015 	stw	r2,0(r7)
 90894f0:	39c00104 	addi	r7,r7,4
 90894f4:	19bffa36 	bltu	r3,r6,90894e0 <memcpy+0x80>
 90894f8:	3807883a 	mov	r3,r7
 90894fc:	003fde06 	br	9089478 <memcpy+0x18>

09089500 <memmove>:
 9089500:	2807883a 	mov	r3,r5
 9089504:	2011883a 	mov	r8,r4
 9089508:	29000c2e 	bgeu	r5,r4,908953c <memmove+0x3c>
 908950c:	298f883a 	add	r7,r5,r6
 9089510:	21c00a2e 	bgeu	r4,r7,908953c <memmove+0x3c>
 9089514:	30000726 	beq	r6,zero,9089534 <memmove+0x34>
 9089518:	2187883a 	add	r3,r4,r6
 908951c:	198dc83a 	sub	r6,r3,r6
 9089520:	39ffffc4 	addi	r7,r7,-1
 9089524:	38800003 	ldbu	r2,0(r7)
 9089528:	18ffffc4 	addi	r3,r3,-1
 908952c:	18800005 	stb	r2,0(r3)
 9089530:	19bffb1e 	bne	r3,r6,9089520 <memmove+0x20>
 9089534:	2005883a 	mov	r2,r4
 9089538:	f800283a 	ret
 908953c:	01c003c4 	movi	r7,15
 9089540:	39800a36 	bltu	r7,r6,908956c <memmove+0x6c>
 9089544:	303ffb26 	beq	r6,zero,9089534 <memmove+0x34>
 9089548:	400f883a 	mov	r7,r8
 908954c:	320d883a 	add	r6,r6,r8
 9089550:	28800003 	ldbu	r2,0(r5)
 9089554:	29400044 	addi	r5,r5,1
 9089558:	38800005 	stb	r2,0(r7)
 908955c:	39c00044 	addi	r7,r7,1
 9089560:	39bffb1e 	bne	r7,r6,9089550 <memmove+0x50>
 9089564:	2005883a 	mov	r2,r4
 9089568:	f800283a 	ret
 908956c:	1904b03a 	or	r2,r3,r4
 9089570:	108000cc 	andi	r2,r2,3
 9089574:	103ff31e 	bne	r2,zero,9089544 <memmove+0x44>
 9089578:	3811883a 	mov	r8,r7
 908957c:	180b883a 	mov	r5,r3
 9089580:	200f883a 	mov	r7,r4
 9089584:	28c00017 	ldw	r3,0(r5)
 9089588:	31bffc04 	addi	r6,r6,-16
 908958c:	38c00015 	stw	r3,0(r7)
 9089590:	28800117 	ldw	r2,4(r5)
 9089594:	38800115 	stw	r2,4(r7)
 9089598:	28c00217 	ldw	r3,8(r5)
 908959c:	38c00215 	stw	r3,8(r7)
 90895a0:	28800317 	ldw	r2,12(r5)
 90895a4:	29400404 	addi	r5,r5,16
 90895a8:	38800315 	stw	r2,12(r7)
 90895ac:	39c00404 	addi	r7,r7,16
 90895b0:	41bff436 	bltu	r8,r6,9089584 <memmove+0x84>
 90895b4:	008000c4 	movi	r2,3
 90895b8:	1180072e 	bgeu	r2,r6,90895d8 <memmove+0xd8>
 90895bc:	1007883a 	mov	r3,r2
 90895c0:	28800017 	ldw	r2,0(r5)
 90895c4:	31bfff04 	addi	r6,r6,-4
 90895c8:	29400104 	addi	r5,r5,4
 90895cc:	38800015 	stw	r2,0(r7)
 90895d0:	39c00104 	addi	r7,r7,4
 90895d4:	19bffa36 	bltu	r3,r6,90895c0 <memmove+0xc0>
 90895d8:	3811883a 	mov	r8,r7
 90895dc:	003fd906 	br	9089544 <memmove+0x44>

090895e0 <_Bfree>:
 90895e0:	28000826 	beq	r5,zero,9089604 <_Bfree+0x24>
 90895e4:	28800117 	ldw	r2,4(r5)
 90895e8:	21001317 	ldw	r4,76(r4)
 90895ec:	1085883a 	add	r2,r2,r2
 90895f0:	1085883a 	add	r2,r2,r2
 90895f4:	1105883a 	add	r2,r2,r4
 90895f8:	10c00017 	ldw	r3,0(r2)
 90895fc:	28c00015 	stw	r3,0(r5)
 9089600:	11400015 	stw	r5,0(r2)
 9089604:	f800283a 	ret

09089608 <__hi0bits>:
 9089608:	20bfffec 	andhi	r2,r4,65535
 908960c:	10001426 	beq	r2,zero,9089660 <__hi0bits+0x58>
 9089610:	0007883a 	mov	r3,zero
 9089614:	20bfc02c 	andhi	r2,r4,65280
 9089618:	1000021e 	bne	r2,zero,9089624 <__hi0bits+0x1c>
 908961c:	2008923a 	slli	r4,r4,8
 9089620:	18c00204 	addi	r3,r3,8
 9089624:	20bc002c 	andhi	r2,r4,61440
 9089628:	1000021e 	bne	r2,zero,9089634 <__hi0bits+0x2c>
 908962c:	2008913a 	slli	r4,r4,4
 9089630:	18c00104 	addi	r3,r3,4
 9089634:	20b0002c 	andhi	r2,r4,49152
 9089638:	1000031e 	bne	r2,zero,9089648 <__hi0bits+0x40>
 908963c:	2105883a 	add	r2,r4,r4
 9089640:	18c00084 	addi	r3,r3,2
 9089644:	1089883a 	add	r4,r2,r2
 9089648:	20000316 	blt	r4,zero,9089658 <__hi0bits+0x50>
 908964c:	2090002c 	andhi	r2,r4,16384
 9089650:	10000626 	beq	r2,zero,908966c <__hi0bits+0x64>
 9089654:	18c00044 	addi	r3,r3,1
 9089658:	1805883a 	mov	r2,r3
 908965c:	f800283a 	ret
 9089660:	2008943a 	slli	r4,r4,16
 9089664:	00c00404 	movi	r3,16
 9089668:	003fea06 	br	9089614 <__hi0bits+0xc>
 908966c:	00c00804 	movi	r3,32
 9089670:	1805883a 	mov	r2,r3
 9089674:	f800283a 	ret

09089678 <__lo0bits>:
 9089678:	20c00017 	ldw	r3,0(r4)
 908967c:	188001cc 	andi	r2,r3,7
 9089680:	10000a26 	beq	r2,zero,90896ac <__lo0bits+0x34>
 9089684:	1880004c 	andi	r2,r3,1
 9089688:	1005003a 	cmpeq	r2,r2,zero
 908968c:	10002126 	beq	r2,zero,9089714 <__lo0bits+0x9c>
 9089690:	1880008c 	andi	r2,r3,2
 9089694:	1000251e 	bne	r2,zero,908972c <__lo0bits+0xb4>
 9089698:	1804d0ba 	srli	r2,r3,2
 908969c:	01400084 	movi	r5,2
 90896a0:	20800015 	stw	r2,0(r4)
 90896a4:	2805883a 	mov	r2,r5
 90896a8:	f800283a 	ret
 90896ac:	18bfffcc 	andi	r2,r3,65535
 90896b0:	10001526 	beq	r2,zero,9089708 <__lo0bits+0x90>
 90896b4:	000b883a 	mov	r5,zero
 90896b8:	18803fcc 	andi	r2,r3,255
 90896bc:	1000021e 	bne	r2,zero,90896c8 <__lo0bits+0x50>
 90896c0:	1806d23a 	srli	r3,r3,8
 90896c4:	29400204 	addi	r5,r5,8
 90896c8:	188003cc 	andi	r2,r3,15
 90896cc:	1000021e 	bne	r2,zero,90896d8 <__lo0bits+0x60>
 90896d0:	1806d13a 	srli	r3,r3,4
 90896d4:	29400104 	addi	r5,r5,4
 90896d8:	188000cc 	andi	r2,r3,3
 90896dc:	1000021e 	bne	r2,zero,90896e8 <__lo0bits+0x70>
 90896e0:	1806d0ba 	srli	r3,r3,2
 90896e4:	29400084 	addi	r5,r5,2
 90896e8:	1880004c 	andi	r2,r3,1
 90896ec:	1000031e 	bne	r2,zero,90896fc <__lo0bits+0x84>
 90896f0:	1806d07a 	srli	r3,r3,1
 90896f4:	18000a26 	beq	r3,zero,9089720 <__lo0bits+0xa8>
 90896f8:	29400044 	addi	r5,r5,1
 90896fc:	2805883a 	mov	r2,r5
 9089700:	20c00015 	stw	r3,0(r4)
 9089704:	f800283a 	ret
 9089708:	1806d43a 	srli	r3,r3,16
 908970c:	01400404 	movi	r5,16
 9089710:	003fe906 	br	90896b8 <__lo0bits+0x40>
 9089714:	000b883a 	mov	r5,zero
 9089718:	2805883a 	mov	r2,r5
 908971c:	f800283a 	ret
 9089720:	01400804 	movi	r5,32
 9089724:	2805883a 	mov	r2,r5
 9089728:	f800283a 	ret
 908972c:	1804d07a 	srli	r2,r3,1
 9089730:	01400044 	movi	r5,1
 9089734:	20800015 	stw	r2,0(r4)
 9089738:	003fda06 	br	90896a4 <__lo0bits+0x2c>

0908973c <__mcmp>:
 908973c:	20800417 	ldw	r2,16(r4)
 9089740:	28c00417 	ldw	r3,16(r5)
 9089744:	10cfc83a 	sub	r7,r2,r3
 9089748:	38000c1e 	bne	r7,zero,908977c <__mcmp+0x40>
 908974c:	18c5883a 	add	r2,r3,r3
 9089750:	1085883a 	add	r2,r2,r2
 9089754:	10c00504 	addi	r3,r2,20
 9089758:	21000504 	addi	r4,r4,20
 908975c:	28cb883a 	add	r5,r5,r3
 9089760:	2085883a 	add	r2,r4,r2
 9089764:	10bfff04 	addi	r2,r2,-4
 9089768:	297fff04 	addi	r5,r5,-4
 908976c:	11800017 	ldw	r6,0(r2)
 9089770:	28c00017 	ldw	r3,0(r5)
 9089774:	30c0031e 	bne	r6,r3,9089784 <__mcmp+0x48>
 9089778:	20bffa36 	bltu	r4,r2,9089764 <__mcmp+0x28>
 908977c:	3805883a 	mov	r2,r7
 9089780:	f800283a 	ret
 9089784:	30c00336 	bltu	r6,r3,9089794 <__mcmp+0x58>
 9089788:	01c00044 	movi	r7,1
 908978c:	3805883a 	mov	r2,r7
 9089790:	f800283a 	ret
 9089794:	01ffffc4 	movi	r7,-1
 9089798:	003ff806 	br	908977c <__mcmp+0x40>

0908979c <__ulp>:
 908979c:	295ffc2c 	andhi	r5,r5,32752
 90897a0:	013f3034 	movhi	r4,64704
 90897a4:	290b883a 	add	r5,r5,r4
 90897a8:	0145c83a 	sub	r2,zero,r5
 90897ac:	1007d53a 	srai	r3,r2,20
 90897b0:	000d883a 	mov	r6,zero
 90897b4:	0140040e 	bge	zero,r5,90897c8 <__ulp+0x2c>
 90897b8:	280f883a 	mov	r7,r5
 90897bc:	3807883a 	mov	r3,r7
 90897c0:	3005883a 	mov	r2,r6
 90897c4:	f800283a 	ret
 90897c8:	008004c4 	movi	r2,19
 90897cc:	193ffb04 	addi	r4,r3,-20
 90897d0:	10c00c0e 	bge	r2,r3,9089804 <__ulp+0x68>
 90897d4:	008007c4 	movi	r2,31
 90897d8:	1107c83a 	sub	r3,r2,r4
 90897dc:	00800784 	movi	r2,30
 90897e0:	01400044 	movi	r5,1
 90897e4:	11000216 	blt	r2,r4,90897f0 <__ulp+0x54>
 90897e8:	00800044 	movi	r2,1
 90897ec:	10ca983a 	sll	r5,r2,r3
 90897f0:	000f883a 	mov	r7,zero
 90897f4:	280d883a 	mov	r6,r5
 90897f8:	3807883a 	mov	r3,r7
 90897fc:	3005883a 	mov	r2,r6
 9089800:	f800283a 	ret
 9089804:	00800234 	movhi	r2,8
 9089808:	10cfd83a 	sra	r7,r2,r3
 908980c:	000d883a 	mov	r6,zero
 9089810:	3005883a 	mov	r2,r6
 9089814:	3807883a 	mov	r3,r7
 9089818:	f800283a 	ret

0908981c <__b2d>:
 908981c:	20800417 	ldw	r2,16(r4)
 9089820:	defff904 	addi	sp,sp,-28
 9089824:	dd000415 	stw	r20,16(sp)
 9089828:	1085883a 	add	r2,r2,r2
 908982c:	25000504 	addi	r20,r4,20
 9089830:	1085883a 	add	r2,r2,r2
 9089834:	dc000015 	stw	r16,0(sp)
 9089838:	a0a1883a 	add	r16,r20,r2
 908983c:	dd400515 	stw	r21,20(sp)
 9089840:	857fff17 	ldw	r21,-4(r16)
 9089844:	dc400115 	stw	r17,4(sp)
 9089848:	dfc00615 	stw	ra,24(sp)
 908984c:	a809883a 	mov	r4,r21
 9089850:	2823883a 	mov	r17,r5
 9089854:	dcc00315 	stw	r19,12(sp)
 9089858:	dc800215 	stw	r18,8(sp)
 908985c:	90896080 	call	9089608 <__hi0bits>
 9089860:	100b883a 	mov	r5,r2
 9089864:	00800804 	movi	r2,32
 9089868:	1145c83a 	sub	r2,r2,r5
 908986c:	88800015 	stw	r2,0(r17)
 9089870:	00800284 	movi	r2,10
 9089874:	80ffff04 	addi	r3,r16,-4
 9089878:	11401416 	blt	r2,r5,90898cc <__b2d+0xb0>
 908987c:	008002c4 	movi	r2,11
 9089880:	1149c83a 	sub	r4,r2,r5
 9089884:	a0c02736 	bltu	r20,r3,9089924 <__b2d+0x108>
 9089888:	000d883a 	mov	r6,zero
 908988c:	28800544 	addi	r2,r5,21
 9089890:	a906d83a 	srl	r3,r21,r4
 9089894:	a884983a 	sll	r2,r21,r2
 9089898:	1ccffc34 	orhi	r19,r3,16368
 908989c:	11a4b03a 	or	r18,r2,r6
 90898a0:	9005883a 	mov	r2,r18
 90898a4:	9807883a 	mov	r3,r19
 90898a8:	dfc00617 	ldw	ra,24(sp)
 90898ac:	dd400517 	ldw	r21,20(sp)
 90898b0:	dd000417 	ldw	r20,16(sp)
 90898b4:	dcc00317 	ldw	r19,12(sp)
 90898b8:	dc800217 	ldw	r18,8(sp)
 90898bc:	dc400117 	ldw	r17,4(sp)
 90898c0:	dc000017 	ldw	r16,0(sp)
 90898c4:	dec00704 	addi	sp,sp,28
 90898c8:	f800283a 	ret
 90898cc:	a0c00e36 	bltu	r20,r3,9089908 <__b2d+0xec>
 90898d0:	293ffd44 	addi	r4,r5,-11
 90898d4:	000d883a 	mov	r6,zero
 90898d8:	20000f26 	beq	r4,zero,9089918 <__b2d+0xfc>
 90898dc:	00800804 	movi	r2,32
 90898e0:	110bc83a 	sub	r5,r2,r4
 90898e4:	a0c01236 	bltu	r20,r3,9089930 <__b2d+0x114>
 90898e8:	000f883a 	mov	r7,zero
 90898ec:	a904983a 	sll	r2,r21,r4
 90898f0:	3146d83a 	srl	r3,r6,r5
 90898f4:	3108983a 	sll	r4,r6,r4
 90898f8:	108ffc34 	orhi	r2,r2,16368
 90898fc:	18a6b03a 	or	r19,r3,r2
 9089900:	3924b03a 	or	r18,r7,r4
 9089904:	003fe606 	br	90898a0 <__b2d+0x84>
 9089908:	293ffd44 	addi	r4,r5,-11
 908990c:	81bffe17 	ldw	r6,-8(r16)
 9089910:	80fffe04 	addi	r3,r16,-8
 9089914:	203ff11e 	bne	r4,zero,90898dc <__b2d+0xc0>
 9089918:	accffc34 	orhi	r19,r21,16368
 908991c:	3025883a 	mov	r18,r6
 9089920:	003fdf06 	br	90898a0 <__b2d+0x84>
 9089924:	18bfff17 	ldw	r2,-4(r3)
 9089928:	110cd83a 	srl	r6,r2,r4
 908992c:	003fd706 	br	908988c <__b2d+0x70>
 9089930:	18bfff17 	ldw	r2,-4(r3)
 9089934:	114ed83a 	srl	r7,r2,r5
 9089938:	003fec06 	br	90898ec <__b2d+0xd0>

0908993c <__ratio>:
 908993c:	defff904 	addi	sp,sp,-28
 9089940:	dc400215 	stw	r17,8(sp)
 9089944:	2823883a 	mov	r17,r5
 9089948:	d80b883a 	mov	r5,sp
 908994c:	dfc00615 	stw	ra,24(sp)
 9089950:	dd000515 	stw	r20,20(sp)
 9089954:	dcc00415 	stw	r19,16(sp)
 9089958:	dc800315 	stw	r18,12(sp)
 908995c:	2025883a 	mov	r18,r4
 9089960:	908981c0 	call	908981c <__b2d>
 9089964:	8809883a 	mov	r4,r17
 9089968:	d9400104 	addi	r5,sp,4
 908996c:	1027883a 	mov	r19,r2
 9089970:	1829883a 	mov	r20,r3
 9089974:	908981c0 	call	908981c <__b2d>
 9089978:	89000417 	ldw	r4,16(r17)
 908997c:	91c00417 	ldw	r7,16(r18)
 9089980:	d9800117 	ldw	r6,4(sp)
 9089984:	180b883a 	mov	r5,r3
 9089988:	390fc83a 	sub	r7,r7,r4
 908998c:	1009883a 	mov	r4,r2
 9089990:	d8800017 	ldw	r2,0(sp)
 9089994:	380e917a 	slli	r7,r7,5
 9089998:	2011883a 	mov	r8,r4
 908999c:	1185c83a 	sub	r2,r2,r6
 90899a0:	11c5883a 	add	r2,r2,r7
 90899a4:	1006953a 	slli	r3,r2,20
 90899a8:	2813883a 	mov	r9,r5
 90899ac:	00800d0e 	bge	zero,r2,90899e4 <__ratio+0xa8>
 90899b0:	1d29883a 	add	r20,r3,r20
 90899b4:	a00b883a 	mov	r5,r20
 90899b8:	480f883a 	mov	r7,r9
 90899bc:	9809883a 	mov	r4,r19
 90899c0:	400d883a 	mov	r6,r8
 90899c4:	908c9680 	call	908c968 <__divdf3>
 90899c8:	dfc00617 	ldw	ra,24(sp)
 90899cc:	dd000517 	ldw	r20,20(sp)
 90899d0:	dcc00417 	ldw	r19,16(sp)
 90899d4:	dc800317 	ldw	r18,12(sp)
 90899d8:	dc400217 	ldw	r17,8(sp)
 90899dc:	dec00704 	addi	sp,sp,28
 90899e0:	f800283a 	ret
 90899e4:	28d3c83a 	sub	r9,r5,r3
 90899e8:	003ff206 	br	90899b4 <__ratio+0x78>

090899ec <_mprec_log10>:
 90899ec:	defffe04 	addi	sp,sp,-8
 90899f0:	008005c4 	movi	r2,23
 90899f4:	dc000015 	stw	r16,0(sp)
 90899f8:	dfc00115 	stw	ra,4(sp)
 90899fc:	2021883a 	mov	r16,r4
 9089a00:	11000c16 	blt	r2,r4,9089a34 <_mprec_log10+0x48>
 9089a04:	200490fa 	slli	r2,r4,3
 9089a08:	00c24374 	movhi	r3,2317
 9089a0c:	18f57e04 	addi	r3,r3,-10760
 9089a10:	10c5883a 	add	r2,r2,r3
 9089a14:	12400117 	ldw	r9,4(r2)
 9089a18:	12000017 	ldw	r8,0(r2)
 9089a1c:	4807883a 	mov	r3,r9
 9089a20:	4005883a 	mov	r2,r8
 9089a24:	dfc00117 	ldw	ra,4(sp)
 9089a28:	dc000017 	ldw	r16,0(sp)
 9089a2c:	dec00204 	addi	sp,sp,8
 9089a30:	f800283a 	ret
 9089a34:	0011883a 	mov	r8,zero
 9089a38:	024ffc34 	movhi	r9,16368
 9089a3c:	0005883a 	mov	r2,zero
 9089a40:	00d00934 	movhi	r3,16420
 9089a44:	480b883a 	mov	r5,r9
 9089a48:	4009883a 	mov	r4,r8
 9089a4c:	180f883a 	mov	r7,r3
 9089a50:	100d883a 	mov	r6,r2
 9089a54:	908c5b40 	call	908c5b4 <__muldf3>
 9089a58:	843fffc4 	addi	r16,r16,-1
 9089a5c:	1011883a 	mov	r8,r2
 9089a60:	1813883a 	mov	r9,r3
 9089a64:	803ff51e 	bne	r16,zero,9089a3c <_mprec_log10+0x50>
 9089a68:	4005883a 	mov	r2,r8
 9089a6c:	4807883a 	mov	r3,r9
 9089a70:	dfc00117 	ldw	ra,4(sp)
 9089a74:	dc000017 	ldw	r16,0(sp)
 9089a78:	dec00204 	addi	sp,sp,8
 9089a7c:	f800283a 	ret

09089a80 <__copybits>:
 9089a80:	297fffc4 	addi	r5,r5,-1
 9089a84:	30800417 	ldw	r2,16(r6)
 9089a88:	280bd17a 	srai	r5,r5,5
 9089a8c:	31800504 	addi	r6,r6,20
 9089a90:	1085883a 	add	r2,r2,r2
 9089a94:	294b883a 	add	r5,r5,r5
 9089a98:	294b883a 	add	r5,r5,r5
 9089a9c:	1085883a 	add	r2,r2,r2
 9089aa0:	290b883a 	add	r5,r5,r4
 9089aa4:	3087883a 	add	r3,r6,r2
 9089aa8:	29400104 	addi	r5,r5,4
 9089aac:	30c0052e 	bgeu	r6,r3,9089ac4 <__copybits+0x44>
 9089ab0:	30800017 	ldw	r2,0(r6)
 9089ab4:	31800104 	addi	r6,r6,4
 9089ab8:	20800015 	stw	r2,0(r4)
 9089abc:	21000104 	addi	r4,r4,4
 9089ac0:	30fffb36 	bltu	r6,r3,9089ab0 <__copybits+0x30>
 9089ac4:	2140032e 	bgeu	r4,r5,9089ad4 <__copybits+0x54>
 9089ac8:	20000015 	stw	zero,0(r4)
 9089acc:	21000104 	addi	r4,r4,4
 9089ad0:	217ffd36 	bltu	r4,r5,9089ac8 <__copybits+0x48>
 9089ad4:	f800283a 	ret

09089ad8 <__any_on>:
 9089ad8:	20800417 	ldw	r2,16(r4)
 9089adc:	2807d17a 	srai	r3,r5,5
 9089ae0:	21000504 	addi	r4,r4,20
 9089ae4:	10c00d0e 	bge	r2,r3,9089b1c <__any_on+0x44>
 9089ae8:	1085883a 	add	r2,r2,r2
 9089aec:	1085883a 	add	r2,r2,r2
 9089af0:	208d883a 	add	r6,r4,r2
 9089af4:	2180182e 	bgeu	r4,r6,9089b58 <__any_on+0x80>
 9089af8:	30bfff17 	ldw	r2,-4(r6)
 9089afc:	30ffff04 	addi	r3,r6,-4
 9089b00:	1000041e 	bne	r2,zero,9089b14 <__any_on+0x3c>
 9089b04:	20c0142e 	bgeu	r4,r3,9089b58 <__any_on+0x80>
 9089b08:	18ffff04 	addi	r3,r3,-4
 9089b0c:	18800017 	ldw	r2,0(r3)
 9089b10:	103ffc26 	beq	r2,zero,9089b04 <__any_on+0x2c>
 9089b14:	00800044 	movi	r2,1
 9089b18:	f800283a 	ret
 9089b1c:	18800a0e 	bge	r3,r2,9089b48 <__any_on+0x70>
 9089b20:	294007cc 	andi	r5,r5,31
 9089b24:	28000826 	beq	r5,zero,9089b48 <__any_on+0x70>
 9089b28:	18c5883a 	add	r2,r3,r3
 9089b2c:	1085883a 	add	r2,r2,r2
 9089b30:	208d883a 	add	r6,r4,r2
 9089b34:	30c00017 	ldw	r3,0(r6)
 9089b38:	1944d83a 	srl	r2,r3,r5
 9089b3c:	1144983a 	sll	r2,r2,r5
 9089b40:	18bff41e 	bne	r3,r2,9089b14 <__any_on+0x3c>
 9089b44:	003feb06 	br	9089af4 <__any_on+0x1c>
 9089b48:	18c5883a 	add	r2,r3,r3
 9089b4c:	1085883a 	add	r2,r2,r2
 9089b50:	208d883a 	add	r6,r4,r2
 9089b54:	003fe706 	br	9089af4 <__any_on+0x1c>
 9089b58:	0005883a 	mov	r2,zero
 9089b5c:	f800283a 	ret

09089b60 <_Balloc>:
 9089b60:	20c01317 	ldw	r3,76(r4)
 9089b64:	defffb04 	addi	sp,sp,-20
 9089b68:	dcc00315 	stw	r19,12(sp)
 9089b6c:	dc800215 	stw	r18,8(sp)
 9089b70:	dfc00415 	stw	ra,16(sp)
 9089b74:	2825883a 	mov	r18,r5
 9089b78:	dc400115 	stw	r17,4(sp)
 9089b7c:	dc000015 	stw	r16,0(sp)
 9089b80:	2027883a 	mov	r19,r4
 9089b84:	01800404 	movi	r6,16
 9089b88:	01400104 	movi	r5,4
 9089b8c:	18001726 	beq	r3,zero,9089bec <_Balloc+0x8c>
 9089b90:	01400044 	movi	r5,1
 9089b94:	9485883a 	add	r2,r18,r18
 9089b98:	2ca2983a 	sll	r17,r5,r18
 9089b9c:	1085883a 	add	r2,r2,r2
 9089ba0:	10c7883a 	add	r3,r2,r3
 9089ba4:	1c000017 	ldw	r16,0(r3)
 9089ba8:	8c4d883a 	add	r6,r17,r17
 9089bac:	318d883a 	add	r6,r6,r6
 9089bb0:	9809883a 	mov	r4,r19
 9089bb4:	31800504 	addi	r6,r6,20
 9089bb8:	80001226 	beq	r16,zero,9089c04 <_Balloc+0xa4>
 9089bbc:	80800017 	ldw	r2,0(r16)
 9089bc0:	18800015 	stw	r2,0(r3)
 9089bc4:	80000415 	stw	zero,16(r16)
 9089bc8:	80000315 	stw	zero,12(r16)
 9089bcc:	8005883a 	mov	r2,r16
 9089bd0:	dfc00417 	ldw	ra,16(sp)
 9089bd4:	dcc00317 	ldw	r19,12(sp)
 9089bd8:	dc800217 	ldw	r18,8(sp)
 9089bdc:	dc400117 	ldw	r17,4(sp)
 9089be0:	dc000017 	ldw	r16,0(sp)
 9089be4:	dec00504 	addi	sp,sp,20
 9089be8:	f800283a 	ret
 9089bec:	908b1080 	call	908b108 <_calloc_r>
 9089bf0:	1007883a 	mov	r3,r2
 9089bf4:	0021883a 	mov	r16,zero
 9089bf8:	98801315 	stw	r2,76(r19)
 9089bfc:	103fe41e 	bne	r2,zero,9089b90 <_Balloc+0x30>
 9089c00:	003ff206 	br	9089bcc <_Balloc+0x6c>
 9089c04:	908b1080 	call	908b108 <_calloc_r>
 9089c08:	103ff026 	beq	r2,zero,9089bcc <_Balloc+0x6c>
 9089c0c:	1021883a 	mov	r16,r2
 9089c10:	14800115 	stw	r18,4(r2)
 9089c14:	14400215 	stw	r17,8(r2)
 9089c18:	003fea06 	br	9089bc4 <_Balloc+0x64>

09089c1c <__d2b>:
 9089c1c:	defff504 	addi	sp,sp,-44
 9089c20:	dcc00515 	stw	r19,20(sp)
 9089c24:	04c00044 	movi	r19,1
 9089c28:	dc000215 	stw	r16,8(sp)
 9089c2c:	2821883a 	mov	r16,r5
 9089c30:	980b883a 	mov	r5,r19
 9089c34:	ddc00915 	stw	r23,36(sp)
 9089c38:	dd800815 	stw	r22,32(sp)
 9089c3c:	dd400715 	stw	r21,28(sp)
 9089c40:	dd000615 	stw	r20,24(sp)
 9089c44:	dc800415 	stw	r18,16(sp)
 9089c48:	dc400315 	stw	r17,12(sp)
 9089c4c:	dfc00a15 	stw	ra,40(sp)
 9089c50:	3023883a 	mov	r17,r6
 9089c54:	382d883a 	mov	r22,r7
 9089c58:	ddc00b17 	ldw	r23,44(sp)
 9089c5c:	9089b600 	call	9089b60 <_Balloc>
 9089c60:	1025883a 	mov	r18,r2
 9089c64:	00a00034 	movhi	r2,32768
 9089c68:	10bfffc4 	addi	r2,r2,-1
 9089c6c:	8888703a 	and	r4,r17,r2
 9089c70:	202ad53a 	srli	r21,r4,20
 9089c74:	00800434 	movhi	r2,16
 9089c78:	10bfffc4 	addi	r2,r2,-1
 9089c7c:	8886703a 	and	r3,r17,r2
 9089c80:	a829003a 	cmpeq	r20,r21,zero
 9089c84:	800b883a 	mov	r5,r16
 9089c88:	d8c00115 	stw	r3,4(sp)
 9089c8c:	94000504 	addi	r16,r18,20
 9089c90:	a000021e 	bne	r20,zero,9089c9c <__d2b+0x80>
 9089c94:	18c00434 	orhi	r3,r3,16
 9089c98:	d8c00115 	stw	r3,4(sp)
 9089c9c:	28002726 	beq	r5,zero,9089d3c <__d2b+0x120>
 9089ca0:	d809883a 	mov	r4,sp
 9089ca4:	d9400015 	stw	r5,0(sp)
 9089ca8:	90896780 	call	9089678 <__lo0bits>
 9089cac:	100d883a 	mov	r6,r2
 9089cb0:	10003526 	beq	r2,zero,9089d88 <__d2b+0x16c>
 9089cb4:	d8c00117 	ldw	r3,4(sp)
 9089cb8:	00800804 	movi	r2,32
 9089cbc:	1185c83a 	sub	r2,r2,r6
 9089cc0:	d9000017 	ldw	r4,0(sp)
 9089cc4:	1886983a 	sll	r3,r3,r2
 9089cc8:	1906b03a 	or	r3,r3,r4
 9089ccc:	90c00515 	stw	r3,20(r18)
 9089cd0:	d8c00117 	ldw	r3,4(sp)
 9089cd4:	1986d83a 	srl	r3,r3,r6
 9089cd8:	d8c00115 	stw	r3,4(sp)
 9089cdc:	180b003a 	cmpeq	r5,r3,zero
 9089ce0:	00800084 	movi	r2,2
 9089ce4:	114bc83a 	sub	r5,r2,r5
 9089ce8:	80c00115 	stw	r3,4(r16)
 9089cec:	91400415 	stw	r5,16(r18)
 9089cf0:	a0001a1e 	bne	r20,zero,9089d5c <__d2b+0x140>
 9089cf4:	3545883a 	add	r2,r6,r21
 9089cf8:	10bef344 	addi	r2,r2,-1075
 9089cfc:	00c00d44 	movi	r3,53
 9089d00:	b0800015 	stw	r2,0(r22)
 9089d04:	1987c83a 	sub	r3,r3,r6
 9089d08:	b8c00015 	stw	r3,0(r23)
 9089d0c:	9005883a 	mov	r2,r18
 9089d10:	dfc00a17 	ldw	ra,40(sp)
 9089d14:	ddc00917 	ldw	r23,36(sp)
 9089d18:	dd800817 	ldw	r22,32(sp)
 9089d1c:	dd400717 	ldw	r21,28(sp)
 9089d20:	dd000617 	ldw	r20,24(sp)
 9089d24:	dcc00517 	ldw	r19,20(sp)
 9089d28:	dc800417 	ldw	r18,16(sp)
 9089d2c:	dc400317 	ldw	r17,12(sp)
 9089d30:	dc000217 	ldw	r16,8(sp)
 9089d34:	dec00b04 	addi	sp,sp,44
 9089d38:	f800283a 	ret
 9089d3c:	d9000104 	addi	r4,sp,4
 9089d40:	90896780 	call	9089678 <__lo0bits>
 9089d44:	11800804 	addi	r6,r2,32
 9089d48:	d8800117 	ldw	r2,4(sp)
 9089d4c:	94c00415 	stw	r19,16(r18)
 9089d50:	980b883a 	mov	r5,r19
 9089d54:	90800515 	stw	r2,20(r18)
 9089d58:	a03fe626 	beq	r20,zero,9089cf4 <__d2b+0xd8>
 9089d5c:	2945883a 	add	r2,r5,r5
 9089d60:	1085883a 	add	r2,r2,r2
 9089d64:	1405883a 	add	r2,r2,r16
 9089d68:	113fff17 	ldw	r4,-4(r2)
 9089d6c:	30fef384 	addi	r3,r6,-1074
 9089d70:	2820917a 	slli	r16,r5,5
 9089d74:	b0c00015 	stw	r3,0(r22)
 9089d78:	90896080 	call	9089608 <__hi0bits>
 9089d7c:	80a1c83a 	sub	r16,r16,r2
 9089d80:	bc000015 	stw	r16,0(r23)
 9089d84:	003fe106 	br	9089d0c <__d2b+0xf0>
 9089d88:	d8800017 	ldw	r2,0(sp)
 9089d8c:	90800515 	stw	r2,20(r18)
 9089d90:	d8c00117 	ldw	r3,4(sp)
 9089d94:	003fd106 	br	9089cdc <__d2b+0xc0>

09089d98 <__mdiff>:
 9089d98:	defffb04 	addi	sp,sp,-20
 9089d9c:	dc000015 	stw	r16,0(sp)
 9089da0:	2821883a 	mov	r16,r5
 9089da4:	dc800215 	stw	r18,8(sp)
 9089da8:	300b883a 	mov	r5,r6
 9089dac:	2025883a 	mov	r18,r4
 9089db0:	8009883a 	mov	r4,r16
 9089db4:	dc400115 	stw	r17,4(sp)
 9089db8:	dfc00415 	stw	ra,16(sp)
 9089dbc:	dcc00315 	stw	r19,12(sp)
 9089dc0:	3023883a 	mov	r17,r6
 9089dc4:	908973c0 	call	908973c <__mcmp>
 9089dc8:	10004226 	beq	r2,zero,9089ed4 <__mdiff+0x13c>
 9089dcc:	10005016 	blt	r2,zero,9089f10 <__mdiff+0x178>
 9089dd0:	0027883a 	mov	r19,zero
 9089dd4:	81400117 	ldw	r5,4(r16)
 9089dd8:	9009883a 	mov	r4,r18
 9089ddc:	9089b600 	call	9089b60 <_Balloc>
 9089de0:	1019883a 	mov	r12,r2
 9089de4:	82800417 	ldw	r10,16(r16)
 9089de8:	88800417 	ldw	r2,16(r17)
 9089dec:	81800504 	addi	r6,r16,20
 9089df0:	5287883a 	add	r3,r10,r10
 9089df4:	1085883a 	add	r2,r2,r2
 9089df8:	18c7883a 	add	r3,r3,r3
 9089dfc:	1085883a 	add	r2,r2,r2
 9089e00:	8a000504 	addi	r8,r17,20
 9089e04:	64c00315 	stw	r19,12(r12)
 9089e08:	30db883a 	add	r13,r6,r3
 9089e0c:	4097883a 	add	r11,r8,r2
 9089e10:	61c00504 	addi	r7,r12,20
 9089e14:	0013883a 	mov	r9,zero
 9089e18:	31000017 	ldw	r4,0(r6)
 9089e1c:	41400017 	ldw	r5,0(r8)
 9089e20:	42000104 	addi	r8,r8,4
 9089e24:	20bfffcc 	andi	r2,r4,65535
 9089e28:	28ffffcc 	andi	r3,r5,65535
 9089e2c:	10c5c83a 	sub	r2,r2,r3
 9089e30:	1245883a 	add	r2,r2,r9
 9089e34:	2008d43a 	srli	r4,r4,16
 9089e38:	280ad43a 	srli	r5,r5,16
 9089e3c:	1007d43a 	srai	r3,r2,16
 9089e40:	3880000d 	sth	r2,0(r7)
 9089e44:	2149c83a 	sub	r4,r4,r5
 9089e48:	20c9883a 	add	r4,r4,r3
 9089e4c:	3900008d 	sth	r4,2(r7)
 9089e50:	31800104 	addi	r6,r6,4
 9089e54:	39c00104 	addi	r7,r7,4
 9089e58:	2013d43a 	srai	r9,r4,16
 9089e5c:	42ffee36 	bltu	r8,r11,9089e18 <__mdiff+0x80>
 9089e60:	33400c2e 	bgeu	r6,r13,9089e94 <__mdiff+0xfc>
 9089e64:	30800017 	ldw	r2,0(r6)
 9089e68:	31800104 	addi	r6,r6,4
 9089e6c:	10ffffcc 	andi	r3,r2,65535
 9089e70:	1a47883a 	add	r3,r3,r9
 9089e74:	1004d43a 	srli	r2,r2,16
 9089e78:	1809d43a 	srai	r4,r3,16
 9089e7c:	38c0000d 	sth	r3,0(r7)
 9089e80:	1105883a 	add	r2,r2,r4
 9089e84:	3880008d 	sth	r2,2(r7)
 9089e88:	1013d43a 	srai	r9,r2,16
 9089e8c:	39c00104 	addi	r7,r7,4
 9089e90:	337ff436 	bltu	r6,r13,9089e64 <__mdiff+0xcc>
 9089e94:	38bfff17 	ldw	r2,-4(r7)
 9089e98:	38ffff04 	addi	r3,r7,-4
 9089e9c:	1000041e 	bne	r2,zero,9089eb0 <__mdiff+0x118>
 9089ea0:	18ffff04 	addi	r3,r3,-4
 9089ea4:	18800017 	ldw	r2,0(r3)
 9089ea8:	52bfffc4 	addi	r10,r10,-1
 9089eac:	103ffc26 	beq	r2,zero,9089ea0 <__mdiff+0x108>
 9089eb0:	6005883a 	mov	r2,r12
 9089eb4:	62800415 	stw	r10,16(r12)
 9089eb8:	dfc00417 	ldw	ra,16(sp)
 9089ebc:	dcc00317 	ldw	r19,12(sp)
 9089ec0:	dc800217 	ldw	r18,8(sp)
 9089ec4:	dc400117 	ldw	r17,4(sp)
 9089ec8:	dc000017 	ldw	r16,0(sp)
 9089ecc:	dec00504 	addi	sp,sp,20
 9089ed0:	f800283a 	ret
 9089ed4:	9009883a 	mov	r4,r18
 9089ed8:	000b883a 	mov	r5,zero
 9089edc:	9089b600 	call	9089b60 <_Balloc>
 9089ee0:	1019883a 	mov	r12,r2
 9089ee4:	00800044 	movi	r2,1
 9089ee8:	60800415 	stw	r2,16(r12)
 9089eec:	6005883a 	mov	r2,r12
 9089ef0:	60000515 	stw	zero,20(r12)
 9089ef4:	dfc00417 	ldw	ra,16(sp)
 9089ef8:	dcc00317 	ldw	r19,12(sp)
 9089efc:	dc800217 	ldw	r18,8(sp)
 9089f00:	dc400117 	ldw	r17,4(sp)
 9089f04:	dc000017 	ldw	r16,0(sp)
 9089f08:	dec00504 	addi	sp,sp,20
 9089f0c:	f800283a 	ret
 9089f10:	880d883a 	mov	r6,r17
 9089f14:	04c00044 	movi	r19,1
 9089f18:	8023883a 	mov	r17,r16
 9089f1c:	3021883a 	mov	r16,r6
 9089f20:	003fac06 	br	9089dd4 <__mdiff+0x3c>

09089f24 <__lshift>:
 9089f24:	defff904 	addi	sp,sp,-28
 9089f28:	28800417 	ldw	r2,16(r5)
 9089f2c:	dc000015 	stw	r16,0(sp)
 9089f30:	3021d17a 	srai	r16,r6,5
 9089f34:	28c00217 	ldw	r3,8(r5)
 9089f38:	10800044 	addi	r2,r2,1
 9089f3c:	dc400115 	stw	r17,4(sp)
 9089f40:	80a3883a 	add	r17,r16,r2
 9089f44:	dd400515 	stw	r21,20(sp)
 9089f48:	dd000415 	stw	r20,16(sp)
 9089f4c:	dc800215 	stw	r18,8(sp)
 9089f50:	dfc00615 	stw	ra,24(sp)
 9089f54:	2825883a 	mov	r18,r5
 9089f58:	dcc00315 	stw	r19,12(sp)
 9089f5c:	3029883a 	mov	r20,r6
 9089f60:	202b883a 	mov	r21,r4
 9089f64:	29400117 	ldw	r5,4(r5)
 9089f68:	1c40030e 	bge	r3,r17,9089f78 <__lshift+0x54>
 9089f6c:	18c7883a 	add	r3,r3,r3
 9089f70:	29400044 	addi	r5,r5,1
 9089f74:	1c7ffd16 	blt	r3,r17,9089f6c <__lshift+0x48>
 9089f78:	a809883a 	mov	r4,r21
 9089f7c:	9089b600 	call	9089b60 <_Balloc>
 9089f80:	1027883a 	mov	r19,r2
 9089f84:	11400504 	addi	r5,r2,20
 9089f88:	0400090e 	bge	zero,r16,9089fb0 <__lshift+0x8c>
 9089f8c:	2805883a 	mov	r2,r5
 9089f90:	0007883a 	mov	r3,zero
 9089f94:	18c00044 	addi	r3,r3,1
 9089f98:	10000015 	stw	zero,0(r2)
 9089f9c:	10800104 	addi	r2,r2,4
 9089fa0:	80fffc1e 	bne	r16,r3,9089f94 <__lshift+0x70>
 9089fa4:	8405883a 	add	r2,r16,r16
 9089fa8:	1085883a 	add	r2,r2,r2
 9089fac:	288b883a 	add	r5,r5,r2
 9089fb0:	90800417 	ldw	r2,16(r18)
 9089fb4:	91000504 	addi	r4,r18,20
 9089fb8:	a18007cc 	andi	r6,r20,31
 9089fbc:	1085883a 	add	r2,r2,r2
 9089fc0:	1085883a 	add	r2,r2,r2
 9089fc4:	208f883a 	add	r7,r4,r2
 9089fc8:	30001e26 	beq	r6,zero,908a044 <__lshift+0x120>
 9089fcc:	00800804 	movi	r2,32
 9089fd0:	1191c83a 	sub	r8,r2,r6
 9089fd4:	0007883a 	mov	r3,zero
 9089fd8:	20800017 	ldw	r2,0(r4)
 9089fdc:	1184983a 	sll	r2,r2,r6
 9089fe0:	1884b03a 	or	r2,r3,r2
 9089fe4:	28800015 	stw	r2,0(r5)
 9089fe8:	20c00017 	ldw	r3,0(r4)
 9089fec:	21000104 	addi	r4,r4,4
 9089ff0:	29400104 	addi	r5,r5,4
 9089ff4:	1a06d83a 	srl	r3,r3,r8
 9089ff8:	21fff736 	bltu	r4,r7,9089fd8 <__lshift+0xb4>
 9089ffc:	28c00015 	stw	r3,0(r5)
 908a000:	18000126 	beq	r3,zero,908a008 <__lshift+0xe4>
 908a004:	8c400044 	addi	r17,r17,1
 908a008:	88bfffc4 	addi	r2,r17,-1
 908a00c:	98800415 	stw	r2,16(r19)
 908a010:	a809883a 	mov	r4,r21
 908a014:	900b883a 	mov	r5,r18
 908a018:	90895e00 	call	90895e0 <_Bfree>
 908a01c:	9805883a 	mov	r2,r19
 908a020:	dfc00617 	ldw	ra,24(sp)
 908a024:	dd400517 	ldw	r21,20(sp)
 908a028:	dd000417 	ldw	r20,16(sp)
 908a02c:	dcc00317 	ldw	r19,12(sp)
 908a030:	dc800217 	ldw	r18,8(sp)
 908a034:	dc400117 	ldw	r17,4(sp)
 908a038:	dc000017 	ldw	r16,0(sp)
 908a03c:	dec00704 	addi	sp,sp,28
 908a040:	f800283a 	ret
 908a044:	20800017 	ldw	r2,0(r4)
 908a048:	21000104 	addi	r4,r4,4
 908a04c:	28800015 	stw	r2,0(r5)
 908a050:	29400104 	addi	r5,r5,4
 908a054:	21ffec2e 	bgeu	r4,r7,908a008 <__lshift+0xe4>
 908a058:	20800017 	ldw	r2,0(r4)
 908a05c:	21000104 	addi	r4,r4,4
 908a060:	28800015 	stw	r2,0(r5)
 908a064:	29400104 	addi	r5,r5,4
 908a068:	21fff636 	bltu	r4,r7,908a044 <__lshift+0x120>
 908a06c:	003fe606 	br	908a008 <__lshift+0xe4>

0908a070 <__multiply>:
 908a070:	defff904 	addi	sp,sp,-28
 908a074:	dcc00315 	stw	r19,12(sp)
 908a078:	dc800215 	stw	r18,8(sp)
 908a07c:	2cc00417 	ldw	r19,16(r5)
 908a080:	34800417 	ldw	r18,16(r6)
 908a084:	dd000415 	stw	r20,16(sp)
 908a088:	dc400115 	stw	r17,4(sp)
 908a08c:	dfc00615 	stw	ra,24(sp)
 908a090:	dd400515 	stw	r21,20(sp)
 908a094:	dc000015 	stw	r16,0(sp)
 908a098:	2823883a 	mov	r17,r5
 908a09c:	3029883a 	mov	r20,r6
 908a0a0:	9c80040e 	bge	r19,r18,908a0b4 <__multiply+0x44>
 908a0a4:	9027883a 	mov	r19,r18
 908a0a8:	2c800417 	ldw	r18,16(r5)
 908a0ac:	2829883a 	mov	r20,r5
 908a0b0:	3023883a 	mov	r17,r6
 908a0b4:	88800217 	ldw	r2,8(r17)
 908a0b8:	9ca1883a 	add	r16,r19,r18
 908a0bc:	89400117 	ldw	r5,4(r17)
 908a0c0:	1400010e 	bge	r2,r16,908a0c8 <__multiply+0x58>
 908a0c4:	29400044 	addi	r5,r5,1
 908a0c8:	9089b600 	call	9089b60 <_Balloc>
 908a0cc:	102b883a 	mov	r21,r2
 908a0d0:	8405883a 	add	r2,r16,r16
 908a0d4:	1085883a 	add	r2,r2,r2
 908a0d8:	a9000504 	addi	r4,r21,20
 908a0dc:	209d883a 	add	r14,r4,r2
 908a0e0:	2380042e 	bgeu	r4,r14,908a0f4 <__multiply+0x84>
 908a0e4:	2005883a 	mov	r2,r4
 908a0e8:	10000015 	stw	zero,0(r2)
 908a0ec:	10800104 	addi	r2,r2,4
 908a0f0:	13bffd36 	bltu	r2,r14,908a0e8 <__multiply+0x78>
 908a0f4:	9485883a 	add	r2,r18,r18
 908a0f8:	9cc7883a 	add	r3,r19,r19
 908a0fc:	a1800504 	addi	r6,r20,20
 908a100:	1085883a 	add	r2,r2,r2
 908a104:	8b400504 	addi	r13,r17,20
 908a108:	18c7883a 	add	r3,r3,r3
 908a10c:	309f883a 	add	r15,r6,r2
 908a110:	68d7883a 	add	r11,r13,r3
 908a114:	33c03b2e 	bgeu	r6,r15,908a204 <__multiply+0x194>
 908a118:	2019883a 	mov	r12,r4
 908a11c:	30800017 	ldw	r2,0(r6)
 908a120:	127fffcc 	andi	r9,r2,65535
 908a124:	48001826 	beq	r9,zero,908a188 <__multiply+0x118>
 908a128:	6811883a 	mov	r8,r13
 908a12c:	600f883a 	mov	r7,r12
 908a130:	0015883a 	mov	r10,zero
 908a134:	40c00017 	ldw	r3,0(r8)
 908a138:	39400017 	ldw	r5,0(r7)
 908a13c:	42000104 	addi	r8,r8,4
 908a140:	193fffcc 	andi	r4,r3,65535
 908a144:	4909383a 	mul	r4,r9,r4
 908a148:	1806d43a 	srli	r3,r3,16
 908a14c:	28bfffcc 	andi	r2,r5,65535
 908a150:	5085883a 	add	r2,r10,r2
 908a154:	2089883a 	add	r4,r4,r2
 908a158:	48c7383a 	mul	r3,r9,r3
 908a15c:	280ad43a 	srli	r5,r5,16
 908a160:	2004d43a 	srli	r2,r4,16
 908a164:	3900000d 	sth	r4,0(r7)
 908a168:	1947883a 	add	r3,r3,r5
 908a16c:	10c5883a 	add	r2,r2,r3
 908a170:	3880008d 	sth	r2,2(r7)
 908a174:	1014d43a 	srli	r10,r2,16
 908a178:	39c00104 	addi	r7,r7,4
 908a17c:	42ffed36 	bltu	r8,r11,908a134 <__multiply+0xc4>
 908a180:	3a800015 	stw	r10,0(r7)
 908a184:	30800017 	ldw	r2,0(r6)
 908a188:	1012d43a 	srli	r9,r2,16
 908a18c:	48001926 	beq	r9,zero,908a1f4 <__multiply+0x184>
 908a190:	60800017 	ldw	r2,0(r12)
 908a194:	6811883a 	mov	r8,r13
 908a198:	600f883a 	mov	r7,r12
 908a19c:	0015883a 	mov	r10,zero
 908a1a0:	100b883a 	mov	r5,r2
 908a1a4:	41000017 	ldw	r4,0(r8)
 908a1a8:	2806d43a 	srli	r3,r5,16
 908a1ac:	3880000d 	sth	r2,0(r7)
 908a1b0:	20bfffcc 	andi	r2,r4,65535
 908a1b4:	4885383a 	mul	r2,r9,r2
 908a1b8:	50c7883a 	add	r3,r10,r3
 908a1bc:	2008d43a 	srli	r4,r4,16
 908a1c0:	10c5883a 	add	r2,r2,r3
 908a1c4:	3880008d 	sth	r2,2(r7)
 908a1c8:	39c00104 	addi	r7,r7,4
 908a1cc:	39400017 	ldw	r5,0(r7)
 908a1d0:	4909383a 	mul	r4,r9,r4
 908a1d4:	1004d43a 	srli	r2,r2,16
 908a1d8:	28ffffcc 	andi	r3,r5,65535
 908a1dc:	20c9883a 	add	r4,r4,r3
 908a1e0:	1105883a 	add	r2,r2,r4
 908a1e4:	42000104 	addi	r8,r8,4
 908a1e8:	1014d43a 	srli	r10,r2,16
 908a1ec:	42ffed36 	bltu	r8,r11,908a1a4 <__multiply+0x134>
 908a1f0:	38800015 	stw	r2,0(r7)
 908a1f4:	31800104 	addi	r6,r6,4
 908a1f8:	33c0022e 	bgeu	r6,r15,908a204 <__multiply+0x194>
 908a1fc:	63000104 	addi	r12,r12,4
 908a200:	003fc606 	br	908a11c <__multiply+0xac>
 908a204:	0400090e 	bge	zero,r16,908a22c <__multiply+0x1bc>
 908a208:	70bfff17 	ldw	r2,-4(r14)
 908a20c:	70ffff04 	addi	r3,r14,-4
 908a210:	10000326 	beq	r2,zero,908a220 <__multiply+0x1b0>
 908a214:	00000506 	br	908a22c <__multiply+0x1bc>
 908a218:	18800017 	ldw	r2,0(r3)
 908a21c:	1000031e 	bne	r2,zero,908a22c <__multiply+0x1bc>
 908a220:	843fffc4 	addi	r16,r16,-1
 908a224:	18ffff04 	addi	r3,r3,-4
 908a228:	803ffb1e 	bne	r16,zero,908a218 <__multiply+0x1a8>
 908a22c:	a805883a 	mov	r2,r21
 908a230:	ac000415 	stw	r16,16(r21)
 908a234:	dfc00617 	ldw	ra,24(sp)
 908a238:	dd400517 	ldw	r21,20(sp)
 908a23c:	dd000417 	ldw	r20,16(sp)
 908a240:	dcc00317 	ldw	r19,12(sp)
 908a244:	dc800217 	ldw	r18,8(sp)
 908a248:	dc400117 	ldw	r17,4(sp)
 908a24c:	dc000017 	ldw	r16,0(sp)
 908a250:	dec00704 	addi	sp,sp,28
 908a254:	f800283a 	ret

0908a258 <__i2b>:
 908a258:	defffd04 	addi	sp,sp,-12
 908a25c:	dc000015 	stw	r16,0(sp)
 908a260:	04000044 	movi	r16,1
 908a264:	dc800115 	stw	r18,4(sp)
 908a268:	2825883a 	mov	r18,r5
 908a26c:	800b883a 	mov	r5,r16
 908a270:	dfc00215 	stw	ra,8(sp)
 908a274:	9089b600 	call	9089b60 <_Balloc>
 908a278:	14000415 	stw	r16,16(r2)
 908a27c:	14800515 	stw	r18,20(r2)
 908a280:	dfc00217 	ldw	ra,8(sp)
 908a284:	dc800117 	ldw	r18,4(sp)
 908a288:	dc000017 	ldw	r16,0(sp)
 908a28c:	dec00304 	addi	sp,sp,12
 908a290:	f800283a 	ret

0908a294 <__multadd>:
 908a294:	defffa04 	addi	sp,sp,-24
 908a298:	dc800215 	stw	r18,8(sp)
 908a29c:	2c800417 	ldw	r18,16(r5)
 908a2a0:	dd000415 	stw	r20,16(sp)
 908a2a4:	dcc00315 	stw	r19,12(sp)
 908a2a8:	dc000015 	stw	r16,0(sp)
 908a2ac:	dfc00515 	stw	ra,20(sp)
 908a2b0:	3821883a 	mov	r16,r7
 908a2b4:	dc400115 	stw	r17,4(sp)
 908a2b8:	2827883a 	mov	r19,r5
 908a2bc:	2029883a 	mov	r20,r4
 908a2c0:	2a000504 	addi	r8,r5,20
 908a2c4:	000f883a 	mov	r7,zero
 908a2c8:	40800017 	ldw	r2,0(r8)
 908a2cc:	39c00044 	addi	r7,r7,1
 908a2d0:	10ffffcc 	andi	r3,r2,65535
 908a2d4:	1987383a 	mul	r3,r3,r6
 908a2d8:	1004d43a 	srli	r2,r2,16
 908a2dc:	1c07883a 	add	r3,r3,r16
 908a2e0:	180ad43a 	srli	r5,r3,16
 908a2e4:	1185383a 	mul	r2,r2,r6
 908a2e8:	18ffffcc 	andi	r3,r3,65535
 908a2ec:	1145883a 	add	r2,r2,r5
 908a2f0:	1008943a 	slli	r4,r2,16
 908a2f4:	1020d43a 	srli	r16,r2,16
 908a2f8:	20c9883a 	add	r4,r4,r3
 908a2fc:	41000015 	stw	r4,0(r8)
 908a300:	42000104 	addi	r8,r8,4
 908a304:	3cbff016 	blt	r7,r18,908a2c8 <__multadd+0x34>
 908a308:	80000826 	beq	r16,zero,908a32c <__multadd+0x98>
 908a30c:	98800217 	ldw	r2,8(r19)
 908a310:	90800f0e 	bge	r18,r2,908a350 <__multadd+0xbc>
 908a314:	9485883a 	add	r2,r18,r18
 908a318:	1085883a 	add	r2,r2,r2
 908a31c:	14c5883a 	add	r2,r2,r19
 908a320:	90c00044 	addi	r3,r18,1
 908a324:	14000515 	stw	r16,20(r2)
 908a328:	98c00415 	stw	r3,16(r19)
 908a32c:	9805883a 	mov	r2,r19
 908a330:	dfc00517 	ldw	ra,20(sp)
 908a334:	dd000417 	ldw	r20,16(sp)
 908a338:	dcc00317 	ldw	r19,12(sp)
 908a33c:	dc800217 	ldw	r18,8(sp)
 908a340:	dc400117 	ldw	r17,4(sp)
 908a344:	dc000017 	ldw	r16,0(sp)
 908a348:	dec00604 	addi	sp,sp,24
 908a34c:	f800283a 	ret
 908a350:	99400117 	ldw	r5,4(r19)
 908a354:	a009883a 	mov	r4,r20
 908a358:	29400044 	addi	r5,r5,1
 908a35c:	9089b600 	call	9089b60 <_Balloc>
 908a360:	99800417 	ldw	r6,16(r19)
 908a364:	99400304 	addi	r5,r19,12
 908a368:	11000304 	addi	r4,r2,12
 908a36c:	318d883a 	add	r6,r6,r6
 908a370:	318d883a 	add	r6,r6,r6
 908a374:	31800204 	addi	r6,r6,8
 908a378:	1023883a 	mov	r17,r2
 908a37c:	90894600 	call	9089460 <memcpy>
 908a380:	980b883a 	mov	r5,r19
 908a384:	a009883a 	mov	r4,r20
 908a388:	90895e00 	call	90895e0 <_Bfree>
 908a38c:	8827883a 	mov	r19,r17
 908a390:	003fe006 	br	908a314 <__multadd+0x80>

0908a394 <__pow5mult>:
 908a394:	defffa04 	addi	sp,sp,-24
 908a398:	308000cc 	andi	r2,r6,3
 908a39c:	dd000415 	stw	r20,16(sp)
 908a3a0:	dcc00315 	stw	r19,12(sp)
 908a3a4:	dc000015 	stw	r16,0(sp)
 908a3a8:	dfc00515 	stw	ra,20(sp)
 908a3ac:	dc800215 	stw	r18,8(sp)
 908a3b0:	dc400115 	stw	r17,4(sp)
 908a3b4:	3021883a 	mov	r16,r6
 908a3b8:	2027883a 	mov	r19,r4
 908a3bc:	2829883a 	mov	r20,r5
 908a3c0:	10002b1e 	bne	r2,zero,908a470 <__pow5mult+0xdc>
 908a3c4:	8025d0ba 	srai	r18,r16,2
 908a3c8:	90001b26 	beq	r18,zero,908a438 <__pow5mult+0xa4>
 908a3cc:	9c001217 	ldw	r16,72(r19)
 908a3d0:	8000081e 	bne	r16,zero,908a3f4 <__pow5mult+0x60>
 908a3d4:	00003006 	br	908a498 <__pow5mult+0x104>
 908a3d8:	800b883a 	mov	r5,r16
 908a3dc:	800d883a 	mov	r6,r16
 908a3e0:	9809883a 	mov	r4,r19
 908a3e4:	90001426 	beq	r18,zero,908a438 <__pow5mult+0xa4>
 908a3e8:	80800017 	ldw	r2,0(r16)
 908a3ec:	10001b26 	beq	r2,zero,908a45c <__pow5mult+0xc8>
 908a3f0:	1021883a 	mov	r16,r2
 908a3f4:	9080004c 	andi	r2,r18,1
 908a3f8:	1005003a 	cmpeq	r2,r2,zero
 908a3fc:	9025d07a 	srai	r18,r18,1
 908a400:	800d883a 	mov	r6,r16
 908a404:	9809883a 	mov	r4,r19
 908a408:	a00b883a 	mov	r5,r20
 908a40c:	103ff21e 	bne	r2,zero,908a3d8 <__pow5mult+0x44>
 908a410:	908a0700 	call	908a070 <__multiply>
 908a414:	a00b883a 	mov	r5,r20
 908a418:	9809883a 	mov	r4,r19
 908a41c:	1023883a 	mov	r17,r2
 908a420:	90895e00 	call	90895e0 <_Bfree>
 908a424:	8829883a 	mov	r20,r17
 908a428:	800b883a 	mov	r5,r16
 908a42c:	800d883a 	mov	r6,r16
 908a430:	9809883a 	mov	r4,r19
 908a434:	903fec1e 	bne	r18,zero,908a3e8 <__pow5mult+0x54>
 908a438:	a005883a 	mov	r2,r20
 908a43c:	dfc00517 	ldw	ra,20(sp)
 908a440:	dd000417 	ldw	r20,16(sp)
 908a444:	dcc00317 	ldw	r19,12(sp)
 908a448:	dc800217 	ldw	r18,8(sp)
 908a44c:	dc400117 	ldw	r17,4(sp)
 908a450:	dc000017 	ldw	r16,0(sp)
 908a454:	dec00604 	addi	sp,sp,24
 908a458:	f800283a 	ret
 908a45c:	908a0700 	call	908a070 <__multiply>
 908a460:	80800015 	stw	r2,0(r16)
 908a464:	1021883a 	mov	r16,r2
 908a468:	10000015 	stw	zero,0(r2)
 908a46c:	003fe106 	br	908a3f4 <__pow5mult+0x60>
 908a470:	1085883a 	add	r2,r2,r2
 908a474:	00c24374 	movhi	r3,2317
 908a478:	18f5c404 	addi	r3,r3,-10480
 908a47c:	1085883a 	add	r2,r2,r2
 908a480:	10c5883a 	add	r2,r2,r3
 908a484:	11bfff17 	ldw	r6,-4(r2)
 908a488:	000f883a 	mov	r7,zero
 908a48c:	908a2940 	call	908a294 <__multadd>
 908a490:	1029883a 	mov	r20,r2
 908a494:	003fcb06 	br	908a3c4 <__pow5mult+0x30>
 908a498:	9809883a 	mov	r4,r19
 908a49c:	01409c44 	movi	r5,625
 908a4a0:	908a2580 	call	908a258 <__i2b>
 908a4a4:	98801215 	stw	r2,72(r19)
 908a4a8:	1021883a 	mov	r16,r2
 908a4ac:	10000015 	stw	zero,0(r2)
 908a4b0:	003fd006 	br	908a3f4 <__pow5mult+0x60>

0908a4b4 <__s2b>:
 908a4b4:	defff904 	addi	sp,sp,-28
 908a4b8:	dcc00315 	stw	r19,12(sp)
 908a4bc:	dc800215 	stw	r18,8(sp)
 908a4c0:	2827883a 	mov	r19,r5
 908a4c4:	2025883a 	mov	r18,r4
 908a4c8:	01400244 	movi	r5,9
 908a4cc:	39000204 	addi	r4,r7,8
 908a4d0:	dd000415 	stw	r20,16(sp)
 908a4d4:	dc400115 	stw	r17,4(sp)
 908a4d8:	dfc00615 	stw	ra,24(sp)
 908a4dc:	dd400515 	stw	r21,20(sp)
 908a4e0:	dc000015 	stw	r16,0(sp)
 908a4e4:	3829883a 	mov	r20,r7
 908a4e8:	3023883a 	mov	r17,r6
 908a4ec:	908d2480 	call	908d248 <__divsi3>
 908a4f0:	00c00044 	movi	r3,1
 908a4f4:	1880350e 	bge	r3,r2,908a5cc <__s2b+0x118>
 908a4f8:	000b883a 	mov	r5,zero
 908a4fc:	18c7883a 	add	r3,r3,r3
 908a500:	29400044 	addi	r5,r5,1
 908a504:	18bffd16 	blt	r3,r2,908a4fc <__s2b+0x48>
 908a508:	9009883a 	mov	r4,r18
 908a50c:	9089b600 	call	9089b60 <_Balloc>
 908a510:	1011883a 	mov	r8,r2
 908a514:	d8800717 	ldw	r2,28(sp)
 908a518:	00c00044 	movi	r3,1
 908a51c:	01800244 	movi	r6,9
 908a520:	40800515 	stw	r2,20(r8)
 908a524:	40c00415 	stw	r3,16(r8)
 908a528:	3440260e 	bge	r6,r17,908a5c4 <__s2b+0x110>
 908a52c:	3021883a 	mov	r16,r6
 908a530:	99ab883a 	add	r21,r19,r6
 908a534:	9c05883a 	add	r2,r19,r16
 908a538:	11c00007 	ldb	r7,0(r2)
 908a53c:	400b883a 	mov	r5,r8
 908a540:	9009883a 	mov	r4,r18
 908a544:	39fff404 	addi	r7,r7,-48
 908a548:	01800284 	movi	r6,10
 908a54c:	908a2940 	call	908a294 <__multadd>
 908a550:	84000044 	addi	r16,r16,1
 908a554:	1011883a 	mov	r8,r2
 908a558:	8c3ff61e 	bne	r17,r16,908a534 <__s2b+0x80>
 908a55c:	ac45883a 	add	r2,r21,r17
 908a560:	117ffe04 	addi	r5,r2,-8
 908a564:	880d883a 	mov	r6,r17
 908a568:	35000c0e 	bge	r6,r20,908a59c <__s2b+0xe8>
 908a56c:	a185c83a 	sub	r2,r20,r6
 908a570:	2821883a 	mov	r16,r5
 908a574:	28a3883a 	add	r17,r5,r2
 908a578:	81c00007 	ldb	r7,0(r16)
 908a57c:	400b883a 	mov	r5,r8
 908a580:	9009883a 	mov	r4,r18
 908a584:	39fff404 	addi	r7,r7,-48
 908a588:	01800284 	movi	r6,10
 908a58c:	908a2940 	call	908a294 <__multadd>
 908a590:	84000044 	addi	r16,r16,1
 908a594:	1011883a 	mov	r8,r2
 908a598:	847ff71e 	bne	r16,r17,908a578 <__s2b+0xc4>
 908a59c:	4005883a 	mov	r2,r8
 908a5a0:	dfc00617 	ldw	ra,24(sp)
 908a5a4:	dd400517 	ldw	r21,20(sp)
 908a5a8:	dd000417 	ldw	r20,16(sp)
 908a5ac:	dcc00317 	ldw	r19,12(sp)
 908a5b0:	dc800217 	ldw	r18,8(sp)
 908a5b4:	dc400117 	ldw	r17,4(sp)
 908a5b8:	dc000017 	ldw	r16,0(sp)
 908a5bc:	dec00704 	addi	sp,sp,28
 908a5c0:	f800283a 	ret
 908a5c4:	99400284 	addi	r5,r19,10
 908a5c8:	003fe706 	br	908a568 <__s2b+0xb4>
 908a5cc:	000b883a 	mov	r5,zero
 908a5d0:	003fcd06 	br	908a508 <__s2b+0x54>

0908a5d4 <_realloc_r>:
 908a5d4:	defff404 	addi	sp,sp,-48
 908a5d8:	dd800815 	stw	r22,32(sp)
 908a5dc:	dc800415 	stw	r18,16(sp)
 908a5e0:	dc400315 	stw	r17,12(sp)
 908a5e4:	dfc00b15 	stw	ra,44(sp)
 908a5e8:	df000a15 	stw	fp,40(sp)
 908a5ec:	ddc00915 	stw	r23,36(sp)
 908a5f0:	dd400715 	stw	r21,28(sp)
 908a5f4:	dd000615 	stw	r20,24(sp)
 908a5f8:	dcc00515 	stw	r19,20(sp)
 908a5fc:	dc000215 	stw	r16,8(sp)
 908a600:	2825883a 	mov	r18,r5
 908a604:	3023883a 	mov	r17,r6
 908a608:	202d883a 	mov	r22,r4
 908a60c:	2800c926 	beq	r5,zero,908a934 <_realloc_r+0x360>
 908a610:	908decc0 	call	908decc <__malloc_lock>
 908a614:	943ffe04 	addi	r16,r18,-8
 908a618:	88c002c4 	addi	r3,r17,11
 908a61c:	00800584 	movi	r2,22
 908a620:	82000117 	ldw	r8,4(r16)
 908a624:	10c01b2e 	bgeu	r2,r3,908a694 <_realloc_r+0xc0>
 908a628:	00bffe04 	movi	r2,-8
 908a62c:	188e703a 	and	r7,r3,r2
 908a630:	3839883a 	mov	fp,r7
 908a634:	38001a16 	blt	r7,zero,908a6a0 <_realloc_r+0xcc>
 908a638:	e4401936 	bltu	fp,r17,908a6a0 <_realloc_r+0xcc>
 908a63c:	013fff04 	movi	r4,-4
 908a640:	4126703a 	and	r19,r8,r4
 908a644:	99c02616 	blt	r19,r7,908a6e0 <_realloc_r+0x10c>
 908a648:	802b883a 	mov	r21,r16
 908a64c:	9829883a 	mov	r20,r19
 908a650:	84000204 	addi	r16,r16,8
 908a654:	a80f883a 	mov	r7,r21
 908a658:	a70dc83a 	sub	r6,r20,fp
 908a65c:	008003c4 	movi	r2,15
 908a660:	1180c136 	bltu	r2,r6,908a968 <_realloc_r+0x394>
 908a664:	38800117 	ldw	r2,4(r7)
 908a668:	a549883a 	add	r4,r20,r21
 908a66c:	1080004c 	andi	r2,r2,1
 908a670:	a084b03a 	or	r2,r20,r2
 908a674:	38800115 	stw	r2,4(r7)
 908a678:	20c00117 	ldw	r3,4(r4)
 908a67c:	18c00054 	ori	r3,r3,1
 908a680:	20c00115 	stw	r3,4(r4)
 908a684:	b009883a 	mov	r4,r22
 908a688:	908dfd40 	call	908dfd4 <__malloc_unlock>
 908a68c:	8023883a 	mov	r17,r16
 908a690:	00000606 	br	908a6ac <_realloc_r+0xd8>
 908a694:	01c00404 	movi	r7,16
 908a698:	3839883a 	mov	fp,r7
 908a69c:	e47fe72e 	bgeu	fp,r17,908a63c <_realloc_r+0x68>
 908a6a0:	00800304 	movi	r2,12
 908a6a4:	0023883a 	mov	r17,zero
 908a6a8:	b0800015 	stw	r2,0(r22)
 908a6ac:	8805883a 	mov	r2,r17
 908a6b0:	dfc00b17 	ldw	ra,44(sp)
 908a6b4:	df000a17 	ldw	fp,40(sp)
 908a6b8:	ddc00917 	ldw	r23,36(sp)
 908a6bc:	dd800817 	ldw	r22,32(sp)
 908a6c0:	dd400717 	ldw	r21,28(sp)
 908a6c4:	dd000617 	ldw	r20,24(sp)
 908a6c8:	dcc00517 	ldw	r19,20(sp)
 908a6cc:	dc800417 	ldw	r18,16(sp)
 908a6d0:	dc400317 	ldw	r17,12(sp)
 908a6d4:	dc000217 	ldw	r16,8(sp)
 908a6d8:	dec00c04 	addi	sp,sp,48
 908a6dc:	f800283a 	ret
 908a6e0:	00824374 	movhi	r2,2317
 908a6e4:	1087df04 	addi	r2,r2,8060
 908a6e8:	12400217 	ldw	r9,8(r2)
 908a6ec:	84cd883a 	add	r6,r16,r19
 908a6f0:	802b883a 	mov	r21,r16
 908a6f4:	3240b926 	beq	r6,r9,908a9dc <_realloc_r+0x408>
 908a6f8:	31400117 	ldw	r5,4(r6)
 908a6fc:	00bfff84 	movi	r2,-2
 908a700:	2884703a 	and	r2,r5,r2
 908a704:	1185883a 	add	r2,r2,r6
 908a708:	10c00117 	ldw	r3,4(r2)
 908a70c:	18c0004c 	andi	r3,r3,1
 908a710:	1807003a 	cmpeq	r3,r3,zero
 908a714:	1800a326 	beq	r3,zero,908a9a4 <_realloc_r+0x3d0>
 908a718:	2908703a 	and	r4,r5,r4
 908a71c:	9929883a 	add	r20,r19,r4
 908a720:	a1c0a30e 	bge	r20,r7,908a9b0 <_realloc_r+0x3dc>
 908a724:	4080004c 	andi	r2,r8,1
 908a728:	1000551e 	bne	r2,zero,908a880 <_realloc_r+0x2ac>
 908a72c:	80800017 	ldw	r2,0(r16)
 908a730:	80afc83a 	sub	r23,r16,r2
 908a734:	b8c00117 	ldw	r3,4(r23)
 908a738:	00bfff04 	movi	r2,-4
 908a73c:	1884703a 	and	r2,r3,r2
 908a740:	30002e26 	beq	r6,zero,908a7fc <_realloc_r+0x228>
 908a744:	3240b926 	beq	r6,r9,908aa2c <_realloc_r+0x458>
 908a748:	98a9883a 	add	r20,r19,r2
 908a74c:	2509883a 	add	r4,r4,r20
 908a750:	d9000015 	stw	r4,0(sp)
 908a754:	21c02a16 	blt	r4,r7,908a800 <_realloc_r+0x22c>
 908a758:	30800317 	ldw	r2,12(r6)
 908a75c:	30c00217 	ldw	r3,8(r6)
 908a760:	01400904 	movi	r5,36
 908a764:	99bfff04 	addi	r6,r19,-4
 908a768:	18800315 	stw	r2,12(r3)
 908a76c:	10c00215 	stw	r3,8(r2)
 908a770:	b9000317 	ldw	r4,12(r23)
 908a774:	b8800217 	ldw	r2,8(r23)
 908a778:	b82b883a 	mov	r21,r23
 908a77c:	bc000204 	addi	r16,r23,8
 908a780:	20800215 	stw	r2,8(r4)
 908a784:	11000315 	stw	r4,12(r2)
 908a788:	2980e436 	bltu	r5,r6,908ab1c <_realloc_r+0x548>
 908a78c:	008004c4 	movi	r2,19
 908a790:	9009883a 	mov	r4,r18
 908a794:	8011883a 	mov	r8,r16
 908a798:	11800f2e 	bgeu	r2,r6,908a7d8 <_realloc_r+0x204>
 908a79c:	90800017 	ldw	r2,0(r18)
 908a7a0:	ba000404 	addi	r8,r23,16
 908a7a4:	91000204 	addi	r4,r18,8
 908a7a8:	b8800215 	stw	r2,8(r23)
 908a7ac:	90c00117 	ldw	r3,4(r18)
 908a7b0:	008006c4 	movi	r2,27
 908a7b4:	b8c00315 	stw	r3,12(r23)
 908a7b8:	1180072e 	bgeu	r2,r6,908a7d8 <_realloc_r+0x204>
 908a7bc:	90c00217 	ldw	r3,8(r18)
 908a7c0:	ba000604 	addi	r8,r23,24
 908a7c4:	91000404 	addi	r4,r18,16
 908a7c8:	b8c00415 	stw	r3,16(r23)
 908a7cc:	90800317 	ldw	r2,12(r18)
 908a7d0:	b8800515 	stw	r2,20(r23)
 908a7d4:	3140e726 	beq	r6,r5,908ab74 <_realloc_r+0x5a0>
 908a7d8:	20800017 	ldw	r2,0(r4)
 908a7dc:	dd000017 	ldw	r20,0(sp)
 908a7e0:	b80f883a 	mov	r7,r23
 908a7e4:	40800015 	stw	r2,0(r8)
 908a7e8:	20c00117 	ldw	r3,4(r4)
 908a7ec:	40c00115 	stw	r3,4(r8)
 908a7f0:	20800217 	ldw	r2,8(r4)
 908a7f4:	40800215 	stw	r2,8(r8)
 908a7f8:	003f9706 	br	908a658 <_realloc_r+0x84>
 908a7fc:	98a9883a 	add	r20,r19,r2
 908a800:	a1c01f16 	blt	r20,r7,908a880 <_realloc_r+0x2ac>
 908a804:	b8c00317 	ldw	r3,12(r23)
 908a808:	b8800217 	ldw	r2,8(r23)
 908a80c:	99bfff04 	addi	r6,r19,-4
 908a810:	01400904 	movi	r5,36
 908a814:	b82b883a 	mov	r21,r23
 908a818:	18800215 	stw	r2,8(r3)
 908a81c:	10c00315 	stw	r3,12(r2)
 908a820:	bc000204 	addi	r16,r23,8
 908a824:	2980c336 	bltu	r5,r6,908ab34 <_realloc_r+0x560>
 908a828:	008004c4 	movi	r2,19
 908a82c:	9009883a 	mov	r4,r18
 908a830:	8011883a 	mov	r8,r16
 908a834:	11800f2e 	bgeu	r2,r6,908a874 <_realloc_r+0x2a0>
 908a838:	90800017 	ldw	r2,0(r18)
 908a83c:	ba000404 	addi	r8,r23,16
 908a840:	91000204 	addi	r4,r18,8
 908a844:	b8800215 	stw	r2,8(r23)
 908a848:	90c00117 	ldw	r3,4(r18)
 908a84c:	008006c4 	movi	r2,27
 908a850:	b8c00315 	stw	r3,12(r23)
 908a854:	1180072e 	bgeu	r2,r6,908a874 <_realloc_r+0x2a0>
 908a858:	90c00217 	ldw	r3,8(r18)
 908a85c:	ba000604 	addi	r8,r23,24
 908a860:	91000404 	addi	r4,r18,16
 908a864:	b8c00415 	stw	r3,16(r23)
 908a868:	90800317 	ldw	r2,12(r18)
 908a86c:	b8800515 	stw	r2,20(r23)
 908a870:	3140c726 	beq	r6,r5,908ab90 <_realloc_r+0x5bc>
 908a874:	20800017 	ldw	r2,0(r4)
 908a878:	b80f883a 	mov	r7,r23
 908a87c:	003fd906 	br	908a7e4 <_realloc_r+0x210>
 908a880:	880b883a 	mov	r5,r17
 908a884:	b009883a 	mov	r4,r22
 908a888:	9088c3c0 	call	9088c3c <_malloc_r>
 908a88c:	1023883a 	mov	r17,r2
 908a890:	10002526 	beq	r2,zero,908a928 <_realloc_r+0x354>
 908a894:	80800117 	ldw	r2,4(r16)
 908a898:	00ffff84 	movi	r3,-2
 908a89c:	893ffe04 	addi	r4,r17,-8
 908a8a0:	10c4703a 	and	r2,r2,r3
 908a8a4:	8085883a 	add	r2,r16,r2
 908a8a8:	20809526 	beq	r4,r2,908ab00 <_realloc_r+0x52c>
 908a8ac:	99bfff04 	addi	r6,r19,-4
 908a8b0:	01c00904 	movi	r7,36
 908a8b4:	39804536 	bltu	r7,r6,908a9cc <_realloc_r+0x3f8>
 908a8b8:	008004c4 	movi	r2,19
 908a8bc:	9009883a 	mov	r4,r18
 908a8c0:	880b883a 	mov	r5,r17
 908a8c4:	11800f2e 	bgeu	r2,r6,908a904 <_realloc_r+0x330>
 908a8c8:	90800017 	ldw	r2,0(r18)
 908a8cc:	89400204 	addi	r5,r17,8
 908a8d0:	91000204 	addi	r4,r18,8
 908a8d4:	88800015 	stw	r2,0(r17)
 908a8d8:	90c00117 	ldw	r3,4(r18)
 908a8dc:	008006c4 	movi	r2,27
 908a8e0:	88c00115 	stw	r3,4(r17)
 908a8e4:	1180072e 	bgeu	r2,r6,908a904 <_realloc_r+0x330>
 908a8e8:	90c00217 	ldw	r3,8(r18)
 908a8ec:	89400404 	addi	r5,r17,16
 908a8f0:	91000404 	addi	r4,r18,16
 908a8f4:	88c00215 	stw	r3,8(r17)
 908a8f8:	90800317 	ldw	r2,12(r18)
 908a8fc:	88800315 	stw	r2,12(r17)
 908a900:	31c09126 	beq	r6,r7,908ab48 <_realloc_r+0x574>
 908a904:	20800017 	ldw	r2,0(r4)
 908a908:	28800015 	stw	r2,0(r5)
 908a90c:	20c00117 	ldw	r3,4(r4)
 908a910:	28c00115 	stw	r3,4(r5)
 908a914:	20800217 	ldw	r2,8(r4)
 908a918:	28800215 	stw	r2,8(r5)
 908a91c:	900b883a 	mov	r5,r18
 908a920:	b009883a 	mov	r4,r22
 908a924:	90880b40 	call	90880b4 <_free_r>
 908a928:	b009883a 	mov	r4,r22
 908a92c:	908dfd40 	call	908dfd4 <__malloc_unlock>
 908a930:	003f5e06 	br	908a6ac <_realloc_r+0xd8>
 908a934:	300b883a 	mov	r5,r6
 908a938:	dfc00b17 	ldw	ra,44(sp)
 908a93c:	df000a17 	ldw	fp,40(sp)
 908a940:	ddc00917 	ldw	r23,36(sp)
 908a944:	dd800817 	ldw	r22,32(sp)
 908a948:	dd400717 	ldw	r21,28(sp)
 908a94c:	dd000617 	ldw	r20,24(sp)
 908a950:	dcc00517 	ldw	r19,20(sp)
 908a954:	dc800417 	ldw	r18,16(sp)
 908a958:	dc400317 	ldw	r17,12(sp)
 908a95c:	dc000217 	ldw	r16,8(sp)
 908a960:	dec00c04 	addi	sp,sp,48
 908a964:	9088c3c1 	jmpi	9088c3c <_malloc_r>
 908a968:	38800117 	ldw	r2,4(r7)
 908a96c:	e54b883a 	add	r5,fp,r21
 908a970:	31000054 	ori	r4,r6,1
 908a974:	1080004c 	andi	r2,r2,1
 908a978:	1704b03a 	or	r2,r2,fp
 908a97c:	38800115 	stw	r2,4(r7)
 908a980:	29000115 	stw	r4,4(r5)
 908a984:	2987883a 	add	r3,r5,r6
 908a988:	18800117 	ldw	r2,4(r3)
 908a98c:	29400204 	addi	r5,r5,8
 908a990:	b009883a 	mov	r4,r22
 908a994:	10800054 	ori	r2,r2,1
 908a998:	18800115 	stw	r2,4(r3)
 908a99c:	90880b40 	call	90880b4 <_free_r>
 908a9a0:	003f3806 	br	908a684 <_realloc_r+0xb0>
 908a9a4:	000d883a 	mov	r6,zero
 908a9a8:	0009883a 	mov	r4,zero
 908a9ac:	003f5d06 	br	908a724 <_realloc_r+0x150>
 908a9b0:	30c00217 	ldw	r3,8(r6)
 908a9b4:	30800317 	ldw	r2,12(r6)
 908a9b8:	800f883a 	mov	r7,r16
 908a9bc:	84000204 	addi	r16,r16,8
 908a9c0:	10c00215 	stw	r3,8(r2)
 908a9c4:	18800315 	stw	r2,12(r3)
 908a9c8:	003f2306 	br	908a658 <_realloc_r+0x84>
 908a9cc:	8809883a 	mov	r4,r17
 908a9d0:	900b883a 	mov	r5,r18
 908a9d4:	90895000 	call	9089500 <memmove>
 908a9d8:	003fd006 	br	908a91c <_realloc_r+0x348>
 908a9dc:	30800117 	ldw	r2,4(r6)
 908a9e0:	e0c00404 	addi	r3,fp,16
 908a9e4:	1108703a 	and	r4,r2,r4
 908a9e8:	9905883a 	add	r2,r19,r4
 908a9ec:	10ff4d16 	blt	r2,r3,908a724 <_realloc_r+0x150>
 908a9f0:	1705c83a 	sub	r2,r2,fp
 908a9f4:	870b883a 	add	r5,r16,fp
 908a9f8:	10800054 	ori	r2,r2,1
 908a9fc:	28800115 	stw	r2,4(r5)
 908aa00:	80c00117 	ldw	r3,4(r16)
 908aa04:	00824374 	movhi	r2,2317
 908aa08:	1087df04 	addi	r2,r2,8060
 908aa0c:	b009883a 	mov	r4,r22
 908aa10:	18c0004c 	andi	r3,r3,1
 908aa14:	e0c6b03a 	or	r3,fp,r3
 908aa18:	11400215 	stw	r5,8(r2)
 908aa1c:	80c00115 	stw	r3,4(r16)
 908aa20:	908dfd40 	call	908dfd4 <__malloc_unlock>
 908aa24:	84400204 	addi	r17,r16,8
 908aa28:	003f2006 	br	908a6ac <_realloc_r+0xd8>
 908aa2c:	98a9883a 	add	r20,r19,r2
 908aa30:	2509883a 	add	r4,r4,r20
 908aa34:	e0800404 	addi	r2,fp,16
 908aa38:	d9000115 	stw	r4,4(sp)
 908aa3c:	20bf7016 	blt	r4,r2,908a800 <_realloc_r+0x22c>
 908aa40:	b8c00317 	ldw	r3,12(r23)
 908aa44:	b8800217 	ldw	r2,8(r23)
 908aa48:	99bfff04 	addi	r6,r19,-4
 908aa4c:	01400904 	movi	r5,36
 908aa50:	18800215 	stw	r2,8(r3)
 908aa54:	10c00315 	stw	r3,12(r2)
 908aa58:	bc400204 	addi	r17,r23,8
 908aa5c:	29804136 	bltu	r5,r6,908ab64 <_realloc_r+0x590>
 908aa60:	008004c4 	movi	r2,19
 908aa64:	9009883a 	mov	r4,r18
 908aa68:	880f883a 	mov	r7,r17
 908aa6c:	11800f2e 	bgeu	r2,r6,908aaac <_realloc_r+0x4d8>
 908aa70:	90800017 	ldw	r2,0(r18)
 908aa74:	b9c00404 	addi	r7,r23,16
 908aa78:	91000204 	addi	r4,r18,8
 908aa7c:	b8800215 	stw	r2,8(r23)
 908aa80:	90c00117 	ldw	r3,4(r18)
 908aa84:	008006c4 	movi	r2,27
 908aa88:	b8c00315 	stw	r3,12(r23)
 908aa8c:	1180072e 	bgeu	r2,r6,908aaac <_realloc_r+0x4d8>
 908aa90:	90c00217 	ldw	r3,8(r18)
 908aa94:	b9c00604 	addi	r7,r23,24
 908aa98:	91000404 	addi	r4,r18,16
 908aa9c:	b8c00415 	stw	r3,16(r23)
 908aaa0:	90800317 	ldw	r2,12(r18)
 908aaa4:	b8800515 	stw	r2,20(r23)
 908aaa8:	31404026 	beq	r6,r5,908abac <_realloc_r+0x5d8>
 908aaac:	20800017 	ldw	r2,0(r4)
 908aab0:	38800015 	stw	r2,0(r7)
 908aab4:	20c00117 	ldw	r3,4(r4)
 908aab8:	38c00115 	stw	r3,4(r7)
 908aabc:	20800217 	ldw	r2,8(r4)
 908aac0:	38800215 	stw	r2,8(r7)
 908aac4:	d8c00117 	ldw	r3,4(sp)
 908aac8:	bf0b883a 	add	r5,r23,fp
 908aacc:	b009883a 	mov	r4,r22
 908aad0:	1f05c83a 	sub	r2,r3,fp
 908aad4:	10800054 	ori	r2,r2,1
 908aad8:	28800115 	stw	r2,4(r5)
 908aadc:	b8c00117 	ldw	r3,4(r23)
 908aae0:	00824374 	movhi	r2,2317
 908aae4:	1087df04 	addi	r2,r2,8060
 908aae8:	11400215 	stw	r5,8(r2)
 908aaec:	18c0004c 	andi	r3,r3,1
 908aaf0:	e0c6b03a 	or	r3,fp,r3
 908aaf4:	b8c00115 	stw	r3,4(r23)
 908aaf8:	908dfd40 	call	908dfd4 <__malloc_unlock>
 908aafc:	003eeb06 	br	908a6ac <_realloc_r+0xd8>
 908ab00:	20800117 	ldw	r2,4(r4)
 908ab04:	00ffff04 	movi	r3,-4
 908ab08:	800f883a 	mov	r7,r16
 908ab0c:	10c4703a 	and	r2,r2,r3
 908ab10:	98a9883a 	add	r20,r19,r2
 908ab14:	84000204 	addi	r16,r16,8
 908ab18:	003ecf06 	br	908a658 <_realloc_r+0x84>
 908ab1c:	900b883a 	mov	r5,r18
 908ab20:	8009883a 	mov	r4,r16
 908ab24:	90895000 	call	9089500 <memmove>
 908ab28:	dd000017 	ldw	r20,0(sp)
 908ab2c:	b80f883a 	mov	r7,r23
 908ab30:	003ec906 	br	908a658 <_realloc_r+0x84>
 908ab34:	900b883a 	mov	r5,r18
 908ab38:	8009883a 	mov	r4,r16
 908ab3c:	90895000 	call	9089500 <memmove>
 908ab40:	b80f883a 	mov	r7,r23
 908ab44:	003ec406 	br	908a658 <_realloc_r+0x84>
 908ab48:	90c00417 	ldw	r3,16(r18)
 908ab4c:	89400604 	addi	r5,r17,24
 908ab50:	91000604 	addi	r4,r18,24
 908ab54:	88c00415 	stw	r3,16(r17)
 908ab58:	90800517 	ldw	r2,20(r18)
 908ab5c:	88800515 	stw	r2,20(r17)
 908ab60:	003f6806 	br	908a904 <_realloc_r+0x330>
 908ab64:	900b883a 	mov	r5,r18
 908ab68:	8809883a 	mov	r4,r17
 908ab6c:	90895000 	call	9089500 <memmove>
 908ab70:	003fd406 	br	908aac4 <_realloc_r+0x4f0>
 908ab74:	90c00417 	ldw	r3,16(r18)
 908ab78:	91000604 	addi	r4,r18,24
 908ab7c:	ba000804 	addi	r8,r23,32
 908ab80:	b8c00615 	stw	r3,24(r23)
 908ab84:	90800517 	ldw	r2,20(r18)
 908ab88:	b8800715 	stw	r2,28(r23)
 908ab8c:	003f1206 	br	908a7d8 <_realloc_r+0x204>
 908ab90:	90c00417 	ldw	r3,16(r18)
 908ab94:	91000604 	addi	r4,r18,24
 908ab98:	ba000804 	addi	r8,r23,32
 908ab9c:	b8c00615 	stw	r3,24(r23)
 908aba0:	90800517 	ldw	r2,20(r18)
 908aba4:	b8800715 	stw	r2,28(r23)
 908aba8:	003f3206 	br	908a874 <_realloc_r+0x2a0>
 908abac:	90c00417 	ldw	r3,16(r18)
 908abb0:	91000604 	addi	r4,r18,24
 908abb4:	b9c00804 	addi	r7,r23,32
 908abb8:	b8c00615 	stw	r3,24(r23)
 908abbc:	90800517 	ldw	r2,20(r18)
 908abc0:	b8800715 	stw	r2,28(r23)
 908abc4:	003fb906 	br	908aaac <_realloc_r+0x4d8>

0908abc8 <__srefill_r>:
 908abc8:	defffd04 	addi	sp,sp,-12
 908abcc:	dc400115 	stw	r17,4(sp)
 908abd0:	dc000015 	stw	r16,0(sp)
 908abd4:	dfc00215 	stw	ra,8(sp)
 908abd8:	2023883a 	mov	r17,r4
 908abdc:	2821883a 	mov	r16,r5
 908abe0:	20000226 	beq	r4,zero,908abec <__srefill_r+0x24>
 908abe4:	20800e17 	ldw	r2,56(r4)
 908abe8:	10004126 	beq	r2,zero,908acf0 <__srefill_r+0x128>
 908abec:	80c0030b 	ldhu	r3,12(r16)
 908abf0:	80000115 	stw	zero,4(r16)
 908abf4:	1880080c 	andi	r2,r3,32
 908abf8:	1000361e 	bne	r2,zero,908acd4 <__srefill_r+0x10c>
 908abfc:	1880010c 	andi	r2,r3,4
 908ac00:	1000211e 	bne	r2,zero,908ac88 <__srefill_r+0xc0>
 908ac04:	1880040c 	andi	r2,r3,16
 908ac08:	10005026 	beq	r2,zero,908ad4c <__srefill_r+0x184>
 908ac0c:	1880020c 	andi	r2,r3,8
 908ac10:	1000541e 	bne	r2,zero,908ad64 <__srefill_r+0x19c>
 908ac14:	8080030b 	ldhu	r2,12(r16)
 908ac18:	10800114 	ori	r2,r2,4
 908ac1c:	8080030d 	sth	r2,12(r16)
 908ac20:	80800417 	ldw	r2,16(r16)
 908ac24:	10004526 	beq	r2,zero,908ad3c <__srefill_r+0x174>
 908ac28:	8080030b 	ldhu	r2,12(r16)
 908ac2c:	108000cc 	andi	r2,r2,3
 908ac30:	1000361e 	bne	r2,zero,908ad0c <__srefill_r+0x144>
 908ac34:	81800417 	ldw	r6,16(r16)
 908ac38:	80c00817 	ldw	r3,32(r16)
 908ac3c:	81400717 	ldw	r5,28(r16)
 908ac40:	81c00517 	ldw	r7,20(r16)
 908ac44:	8809883a 	mov	r4,r17
 908ac48:	81800015 	stw	r6,0(r16)
 908ac4c:	183ee83a 	callr	r3
 908ac50:	80c0030b 	ldhu	r3,12(r16)
 908ac54:	1009883a 	mov	r4,r2
 908ac58:	80800115 	stw	r2,4(r16)
 908ac5c:	00b7ffc4 	movi	r2,-8193
 908ac60:	1884703a 	and	r2,r3,r2
 908ac64:	8080030d 	sth	r2,12(r16)
 908ac68:	0100230e 	bge	zero,r4,908acf8 <__srefill_r+0x130>
 908ac6c:	0009883a 	mov	r4,zero
 908ac70:	2005883a 	mov	r2,r4
 908ac74:	dfc00217 	ldw	ra,8(sp)
 908ac78:	dc400117 	ldw	r17,4(sp)
 908ac7c:	dc000017 	ldw	r16,0(sp)
 908ac80:	dec00304 	addi	sp,sp,12
 908ac84:	f800283a 	ret
 908ac88:	81400c17 	ldw	r5,48(r16)
 908ac8c:	283fe426 	beq	r5,zero,908ac20 <__srefill_r+0x58>
 908ac90:	80801004 	addi	r2,r16,64
 908ac94:	28800226 	beq	r5,r2,908aca0 <__srefill_r+0xd8>
 908ac98:	8809883a 	mov	r4,r17
 908ac9c:	90880b40 	call	90880b4 <_free_r>
 908aca0:	80800f17 	ldw	r2,60(r16)
 908aca4:	80000c15 	stw	zero,48(r16)
 908aca8:	80800115 	stw	r2,4(r16)
 908acac:	103fdc26 	beq	r2,zero,908ac20 <__srefill_r+0x58>
 908acb0:	80800e17 	ldw	r2,56(r16)
 908acb4:	0009883a 	mov	r4,zero
 908acb8:	80800015 	stw	r2,0(r16)
 908acbc:	2005883a 	mov	r2,r4
 908acc0:	dfc00217 	ldw	ra,8(sp)
 908acc4:	dc400117 	ldw	r17,4(sp)
 908acc8:	dc000017 	ldw	r16,0(sp)
 908accc:	dec00304 	addi	sp,sp,12
 908acd0:	f800283a 	ret
 908acd4:	013fffc4 	movi	r4,-1
 908acd8:	2005883a 	mov	r2,r4
 908acdc:	dfc00217 	ldw	ra,8(sp)
 908ace0:	dc400117 	ldw	r17,4(sp)
 908ace4:	dc000017 	ldw	r16,0(sp)
 908ace8:	dec00304 	addi	sp,sp,12
 908acec:	f800283a 	ret
 908acf0:	9087be40 	call	9087be4 <__sinit>
 908acf4:	003fbd06 	br	908abec <__srefill_r+0x24>
 908acf8:	20000b1e 	bne	r4,zero,908ad28 <__srefill_r+0x160>
 908acfc:	10800814 	ori	r2,r2,32
 908ad00:	013fffc4 	movi	r4,-1
 908ad04:	8080030d 	sth	r2,12(r16)
 908ad08:	003fd906 	br	908ac70 <__srefill_r+0xa8>
 908ad0c:	00824374 	movhi	r2,2317
 908ad10:	108e8704 	addi	r2,r2,14876
 908ad14:	11000017 	ldw	r4,0(r2)
 908ad18:	01424274 	movhi	r5,2313
 908ad1c:	296b6304 	addi	r5,r5,-21108
 908ad20:	908892c0 	call	908892c <_fwalk>
 908ad24:	003fc306 	br	908ac34 <__srefill_r+0x6c>
 908ad28:	10801014 	ori	r2,r2,64
 908ad2c:	013fffc4 	movi	r4,-1
 908ad30:	8080030d 	sth	r2,12(r16)
 908ad34:	80000115 	stw	zero,4(r16)
 908ad38:	003fcd06 	br	908ac70 <__srefill_r+0xa8>
 908ad3c:	8809883a 	mov	r4,r17
 908ad40:	800b883a 	mov	r5,r16
 908ad44:	9088aa80 	call	9088aa8 <__smakebuf_r>
 908ad48:	003fb706 	br	908ac28 <__srefill_r+0x60>
 908ad4c:	18c01014 	ori	r3,r3,64
 908ad50:	00800244 	movi	r2,9
 908ad54:	013fffc4 	movi	r4,-1
 908ad58:	88800015 	stw	r2,0(r17)
 908ad5c:	80c0030d 	sth	r3,12(r16)
 908ad60:	003fc306 	br	908ac70 <__srefill_r+0xa8>
 908ad64:	8809883a 	mov	r4,r17
 908ad68:	800b883a 	mov	r5,r16
 908ad6c:	908794c0 	call	908794c <_fflush_r>
 908ad70:	103fd81e 	bne	r2,zero,908acd4 <__srefill_r+0x10c>
 908ad74:	8080030b 	ldhu	r2,12(r16)
 908ad78:	80000215 	stw	zero,8(r16)
 908ad7c:	80000615 	stw	zero,24(r16)
 908ad80:	10bffdcc 	andi	r2,r2,65527
 908ad84:	8080030d 	sth	r2,12(r16)
 908ad88:	003fa206 	br	908ac14 <__srefill_r+0x4c>

0908ad8c <lflush>:
 908ad8c:	20c0030b 	ldhu	r3,12(r4)
 908ad90:	01400244 	movi	r5,9
 908ad94:	0005883a 	mov	r2,zero
 908ad98:	18c0024c 	andi	r3,r3,9
 908ad9c:	19400126 	beq	r3,r5,908ada4 <lflush+0x18>
 908ada0:	f800283a 	ret
 908ada4:	9087b481 	jmpi	9087b48 <fflush>

0908ada8 <__isinfd>:
 908ada8:	200d883a 	mov	r6,r4
 908adac:	0109c83a 	sub	r4,zero,r4
 908adb0:	2188b03a 	or	r4,r4,r6
 908adb4:	2008d7fa 	srli	r4,r4,31
 908adb8:	00a00034 	movhi	r2,32768
 908adbc:	10bfffc4 	addi	r2,r2,-1
 908adc0:	1144703a 	and	r2,r2,r5
 908adc4:	2088b03a 	or	r4,r4,r2
 908adc8:	009ffc34 	movhi	r2,32752
 908adcc:	1105c83a 	sub	r2,r2,r4
 908add0:	0087c83a 	sub	r3,zero,r2
 908add4:	10c4b03a 	or	r2,r2,r3
 908add8:	1004d7fa 	srli	r2,r2,31
 908addc:	00c00044 	movi	r3,1
 908ade0:	1885c83a 	sub	r2,r3,r2
 908ade4:	f800283a 	ret

0908ade8 <__isnand>:
 908ade8:	200d883a 	mov	r6,r4
 908adec:	0109c83a 	sub	r4,zero,r4
 908adf0:	2188b03a 	or	r4,r4,r6
 908adf4:	2008d7fa 	srli	r4,r4,31
 908adf8:	00a00034 	movhi	r2,32768
 908adfc:	10bfffc4 	addi	r2,r2,-1
 908ae00:	1144703a 	and	r2,r2,r5
 908ae04:	2088b03a 	or	r4,r4,r2
 908ae08:	009ffc34 	movhi	r2,32752
 908ae0c:	1105c83a 	sub	r2,r2,r4
 908ae10:	1004d7fa 	srli	r2,r2,31
 908ae14:	f800283a 	ret

0908ae18 <_sbrk_r>:
 908ae18:	defffd04 	addi	sp,sp,-12
 908ae1c:	dc000015 	stw	r16,0(sp)
 908ae20:	04024374 	movhi	r16,2317
 908ae24:	840ee904 	addi	r16,r16,15268
 908ae28:	dc400115 	stw	r17,4(sp)
 908ae2c:	80000015 	stw	zero,0(r16)
 908ae30:	2023883a 	mov	r17,r4
 908ae34:	2809883a 	mov	r4,r5
 908ae38:	dfc00215 	stw	ra,8(sp)
 908ae3c:	908dd080 	call	908dd08 <sbrk>
 908ae40:	1007883a 	mov	r3,r2
 908ae44:	00bfffc4 	movi	r2,-1
 908ae48:	18800626 	beq	r3,r2,908ae64 <_sbrk_r+0x4c>
 908ae4c:	1805883a 	mov	r2,r3
 908ae50:	dfc00217 	ldw	ra,8(sp)
 908ae54:	dc400117 	ldw	r17,4(sp)
 908ae58:	dc000017 	ldw	r16,0(sp)
 908ae5c:	dec00304 	addi	sp,sp,12
 908ae60:	f800283a 	ret
 908ae64:	80800017 	ldw	r2,0(r16)
 908ae68:	103ff826 	beq	r2,zero,908ae4c <_sbrk_r+0x34>
 908ae6c:	88800015 	stw	r2,0(r17)
 908ae70:	1805883a 	mov	r2,r3
 908ae74:	dfc00217 	ldw	ra,8(sp)
 908ae78:	dc400117 	ldw	r17,4(sp)
 908ae7c:	dc000017 	ldw	r16,0(sp)
 908ae80:	dec00304 	addi	sp,sp,12
 908ae84:	f800283a 	ret

0908ae88 <__sclose>:
 908ae88:	2940038f 	ldh	r5,14(r5)
 908ae8c:	908b1bc1 	jmpi	908b1bc <_close_r>

0908ae90 <__sseek>:
 908ae90:	defffe04 	addi	sp,sp,-8
 908ae94:	dc000015 	stw	r16,0(sp)
 908ae98:	2821883a 	mov	r16,r5
 908ae9c:	2940038f 	ldh	r5,14(r5)
 908aea0:	dfc00115 	stw	ra,4(sp)
 908aea4:	908b4340 	call	908b434 <_lseek_r>
 908aea8:	1007883a 	mov	r3,r2
 908aeac:	00bfffc4 	movi	r2,-1
 908aeb0:	18800926 	beq	r3,r2,908aed8 <__sseek+0x48>
 908aeb4:	8080030b 	ldhu	r2,12(r16)
 908aeb8:	80c01415 	stw	r3,80(r16)
 908aebc:	10840014 	ori	r2,r2,4096
 908aec0:	8080030d 	sth	r2,12(r16)
 908aec4:	1805883a 	mov	r2,r3
 908aec8:	dfc00117 	ldw	ra,4(sp)
 908aecc:	dc000017 	ldw	r16,0(sp)
 908aed0:	dec00204 	addi	sp,sp,8
 908aed4:	f800283a 	ret
 908aed8:	8080030b 	ldhu	r2,12(r16)
 908aedc:	10bbffcc 	andi	r2,r2,61439
 908aee0:	8080030d 	sth	r2,12(r16)
 908aee4:	1805883a 	mov	r2,r3
 908aee8:	dfc00117 	ldw	ra,4(sp)
 908aeec:	dc000017 	ldw	r16,0(sp)
 908aef0:	dec00204 	addi	sp,sp,8
 908aef4:	f800283a 	ret

0908aef8 <__swrite>:
 908aef8:	2880030b 	ldhu	r2,12(r5)
 908aefc:	defffb04 	addi	sp,sp,-20
 908af00:	dcc00315 	stw	r19,12(sp)
 908af04:	1080400c 	andi	r2,r2,256
 908af08:	dc800215 	stw	r18,8(sp)
 908af0c:	dc400115 	stw	r17,4(sp)
 908af10:	dc000015 	stw	r16,0(sp)
 908af14:	3027883a 	mov	r19,r6
 908af18:	3825883a 	mov	r18,r7
 908af1c:	dfc00415 	stw	ra,16(sp)
 908af20:	2821883a 	mov	r16,r5
 908af24:	000d883a 	mov	r6,zero
 908af28:	01c00084 	movi	r7,2
 908af2c:	2023883a 	mov	r17,r4
 908af30:	10000226 	beq	r2,zero,908af3c <__swrite+0x44>
 908af34:	2940038f 	ldh	r5,14(r5)
 908af38:	908b4340 	call	908b434 <_lseek_r>
 908af3c:	8080030b 	ldhu	r2,12(r16)
 908af40:	8140038f 	ldh	r5,14(r16)
 908af44:	8809883a 	mov	r4,r17
 908af48:	10bbffcc 	andi	r2,r2,61439
 908af4c:	980d883a 	mov	r6,r19
 908af50:	900f883a 	mov	r7,r18
 908af54:	8080030d 	sth	r2,12(r16)
 908af58:	dfc00417 	ldw	ra,16(sp)
 908af5c:	dcc00317 	ldw	r19,12(sp)
 908af60:	dc800217 	ldw	r18,8(sp)
 908af64:	dc400117 	ldw	r17,4(sp)
 908af68:	dc000017 	ldw	r16,0(sp)
 908af6c:	dec00504 	addi	sp,sp,20
 908af70:	908b0901 	jmpi	908b090 <_write_r>

0908af74 <__sread>:
 908af74:	defffe04 	addi	sp,sp,-8
 908af78:	dc000015 	stw	r16,0(sp)
 908af7c:	2821883a 	mov	r16,r5
 908af80:	2940038f 	ldh	r5,14(r5)
 908af84:	dfc00115 	stw	ra,4(sp)
 908af88:	908b4ac0 	call	908b4ac <_read_r>
 908af8c:	1007883a 	mov	r3,r2
 908af90:	10000816 	blt	r2,zero,908afb4 <__sread+0x40>
 908af94:	80801417 	ldw	r2,80(r16)
 908af98:	10c5883a 	add	r2,r2,r3
 908af9c:	80801415 	stw	r2,80(r16)
 908afa0:	1805883a 	mov	r2,r3
 908afa4:	dfc00117 	ldw	ra,4(sp)
 908afa8:	dc000017 	ldw	r16,0(sp)
 908afac:	dec00204 	addi	sp,sp,8
 908afb0:	f800283a 	ret
 908afb4:	8080030b 	ldhu	r2,12(r16)
 908afb8:	10bbffcc 	andi	r2,r2,61439
 908afbc:	8080030d 	sth	r2,12(r16)
 908afc0:	1805883a 	mov	r2,r3
 908afc4:	dfc00117 	ldw	ra,4(sp)
 908afc8:	dc000017 	ldw	r16,0(sp)
 908afcc:	dec00204 	addi	sp,sp,8
 908afd0:	f800283a 	ret

0908afd4 <strcmp>:
 908afd4:	2144b03a 	or	r2,r4,r5
 908afd8:	108000cc 	andi	r2,r2,3
 908afdc:	10001d1e 	bne	r2,zero,908b054 <strcmp+0x80>
 908afe0:	200f883a 	mov	r7,r4
 908afe4:	28800017 	ldw	r2,0(r5)
 908afe8:	21000017 	ldw	r4,0(r4)
 908afec:	280d883a 	mov	r6,r5
 908aff0:	2080161e 	bne	r4,r2,908b04c <strcmp+0x78>
 908aff4:	023fbff4 	movhi	r8,65279
 908aff8:	423fbfc4 	addi	r8,r8,-257
 908affc:	2207883a 	add	r3,r4,r8
 908b000:	01602074 	movhi	r5,32897
 908b004:	29602004 	addi	r5,r5,-32640
 908b008:	1946703a 	and	r3,r3,r5
 908b00c:	0104303a 	nor	r2,zero,r4
 908b010:	10c4703a 	and	r2,r2,r3
 908b014:	10001c1e 	bne	r2,zero,908b088 <strcmp+0xb4>
 908b018:	4013883a 	mov	r9,r8
 908b01c:	2811883a 	mov	r8,r5
 908b020:	00000106 	br	908b028 <strcmp+0x54>
 908b024:	1800181e 	bne	r3,zero,908b088 <strcmp+0xb4>
 908b028:	39c00104 	addi	r7,r7,4
 908b02c:	39000017 	ldw	r4,0(r7)
 908b030:	31800104 	addi	r6,r6,4
 908b034:	31400017 	ldw	r5,0(r6)
 908b038:	2245883a 	add	r2,r4,r9
 908b03c:	1204703a 	and	r2,r2,r8
 908b040:	0106303a 	nor	r3,zero,r4
 908b044:	1886703a 	and	r3,r3,r2
 908b048:	217ff626 	beq	r4,r5,908b024 <strcmp+0x50>
 908b04c:	3809883a 	mov	r4,r7
 908b050:	300b883a 	mov	r5,r6
 908b054:	20c00007 	ldb	r3,0(r4)
 908b058:	1800051e 	bne	r3,zero,908b070 <strcmp+0x9c>
 908b05c:	00000606 	br	908b078 <strcmp+0xa4>
 908b060:	21000044 	addi	r4,r4,1
 908b064:	20c00007 	ldb	r3,0(r4)
 908b068:	29400044 	addi	r5,r5,1
 908b06c:	18000226 	beq	r3,zero,908b078 <strcmp+0xa4>
 908b070:	28800007 	ldb	r2,0(r5)
 908b074:	18bffa26 	beq	r3,r2,908b060 <strcmp+0x8c>
 908b078:	20c00003 	ldbu	r3,0(r4)
 908b07c:	28800003 	ldbu	r2,0(r5)
 908b080:	1885c83a 	sub	r2,r3,r2
 908b084:	f800283a 	ret
 908b088:	0005883a 	mov	r2,zero
 908b08c:	f800283a 	ret

0908b090 <_write_r>:
 908b090:	defffd04 	addi	sp,sp,-12
 908b094:	dc000015 	stw	r16,0(sp)
 908b098:	04024374 	movhi	r16,2317
 908b09c:	840ee904 	addi	r16,r16,15268
 908b0a0:	dc400115 	stw	r17,4(sp)
 908b0a4:	80000015 	stw	zero,0(r16)
 908b0a8:	2023883a 	mov	r17,r4
 908b0ac:	2809883a 	mov	r4,r5
 908b0b0:	300b883a 	mov	r5,r6
 908b0b4:	380d883a 	mov	r6,r7
 908b0b8:	dfc00215 	stw	ra,8(sp)
 908b0bc:	90a1d9c0 	call	90a1d9c <write>
 908b0c0:	1007883a 	mov	r3,r2
 908b0c4:	00bfffc4 	movi	r2,-1
 908b0c8:	18800626 	beq	r3,r2,908b0e4 <_write_r+0x54>
 908b0cc:	1805883a 	mov	r2,r3
 908b0d0:	dfc00217 	ldw	ra,8(sp)
 908b0d4:	dc400117 	ldw	r17,4(sp)
 908b0d8:	dc000017 	ldw	r16,0(sp)
 908b0dc:	dec00304 	addi	sp,sp,12
 908b0e0:	f800283a 	ret
 908b0e4:	80800017 	ldw	r2,0(r16)
 908b0e8:	103ff826 	beq	r2,zero,908b0cc <_write_r+0x3c>
 908b0ec:	88800015 	stw	r2,0(r17)
 908b0f0:	1805883a 	mov	r2,r3
 908b0f4:	dfc00217 	ldw	ra,8(sp)
 908b0f8:	dc400117 	ldw	r17,4(sp)
 908b0fc:	dc000017 	ldw	r16,0(sp)
 908b100:	dec00304 	addi	sp,sp,12
 908b104:	f800283a 	ret

0908b108 <_calloc_r>:
 908b108:	298b383a 	mul	r5,r5,r6
 908b10c:	defffe04 	addi	sp,sp,-8
 908b110:	dc000015 	stw	r16,0(sp)
 908b114:	dfc00115 	stw	ra,4(sp)
 908b118:	9088c3c0 	call	9088c3c <_malloc_r>
 908b11c:	1021883a 	mov	r16,r2
 908b120:	01c00904 	movi	r7,36
 908b124:	10000d26 	beq	r2,zero,908b15c <_calloc_r+0x54>
 908b128:	10ffff17 	ldw	r3,-4(r2)
 908b12c:	1009883a 	mov	r4,r2
 908b130:	00bfff04 	movi	r2,-4
 908b134:	1886703a 	and	r3,r3,r2
 908b138:	1887883a 	add	r3,r3,r2
 908b13c:	180d883a 	mov	r6,r3
 908b140:	000b883a 	mov	r5,zero
 908b144:	38c01736 	bltu	r7,r3,908b1a4 <_calloc_r+0x9c>
 908b148:	008004c4 	movi	r2,19
 908b14c:	10c00836 	bltu	r2,r3,908b170 <_calloc_r+0x68>
 908b150:	20000215 	stw	zero,8(r4)
 908b154:	20000015 	stw	zero,0(r4)
 908b158:	20000115 	stw	zero,4(r4)
 908b15c:	8005883a 	mov	r2,r16
 908b160:	dfc00117 	ldw	ra,4(sp)
 908b164:	dc000017 	ldw	r16,0(sp)
 908b168:	dec00204 	addi	sp,sp,8
 908b16c:	f800283a 	ret
 908b170:	008006c4 	movi	r2,27
 908b174:	80000015 	stw	zero,0(r16)
 908b178:	80000115 	stw	zero,4(r16)
 908b17c:	81000204 	addi	r4,r16,8
 908b180:	10fff32e 	bgeu	r2,r3,908b150 <_calloc_r+0x48>
 908b184:	80000215 	stw	zero,8(r16)
 908b188:	80000315 	stw	zero,12(r16)
 908b18c:	81000404 	addi	r4,r16,16
 908b190:	19ffef1e 	bne	r3,r7,908b150 <_calloc_r+0x48>
 908b194:	81000604 	addi	r4,r16,24
 908b198:	80000415 	stw	zero,16(r16)
 908b19c:	80000515 	stw	zero,20(r16)
 908b1a0:	003feb06 	br	908b150 <_calloc_r+0x48>
 908b1a4:	90832780 	call	9083278 <memset>
 908b1a8:	8005883a 	mov	r2,r16
 908b1ac:	dfc00117 	ldw	ra,4(sp)
 908b1b0:	dc000017 	ldw	r16,0(sp)
 908b1b4:	dec00204 	addi	sp,sp,8
 908b1b8:	f800283a 	ret

0908b1bc <_close_r>:
 908b1bc:	defffd04 	addi	sp,sp,-12
 908b1c0:	dc000015 	stw	r16,0(sp)
 908b1c4:	04024374 	movhi	r16,2317
 908b1c8:	840ee904 	addi	r16,r16,15268
 908b1cc:	dc400115 	stw	r17,4(sp)
 908b1d0:	80000015 	stw	zero,0(r16)
 908b1d4:	2023883a 	mov	r17,r4
 908b1d8:	2809883a 	mov	r4,r5
 908b1dc:	dfc00215 	stw	ra,8(sp)
 908b1e0:	90a1b8c0 	call	90a1b8c <close>
 908b1e4:	1007883a 	mov	r3,r2
 908b1e8:	00bfffc4 	movi	r2,-1
 908b1ec:	18800626 	beq	r3,r2,908b208 <_close_r+0x4c>
 908b1f0:	1805883a 	mov	r2,r3
 908b1f4:	dfc00217 	ldw	ra,8(sp)
 908b1f8:	dc400117 	ldw	r17,4(sp)
 908b1fc:	dc000017 	ldw	r16,0(sp)
 908b200:	dec00304 	addi	sp,sp,12
 908b204:	f800283a 	ret
 908b208:	80800017 	ldw	r2,0(r16)
 908b20c:	103ff826 	beq	r2,zero,908b1f0 <_close_r+0x34>
 908b210:	88800015 	stw	r2,0(r17)
 908b214:	1805883a 	mov	r2,r3
 908b218:	dfc00217 	ldw	ra,8(sp)
 908b21c:	dc400117 	ldw	r17,4(sp)
 908b220:	dc000017 	ldw	r16,0(sp)
 908b224:	dec00304 	addi	sp,sp,12
 908b228:	f800283a 	ret

0908b22c <_fclose_r>:
 908b22c:	defffc04 	addi	sp,sp,-16
 908b230:	dc400115 	stw	r17,4(sp)
 908b234:	dc000015 	stw	r16,0(sp)
 908b238:	dfc00315 	stw	ra,12(sp)
 908b23c:	dc800215 	stw	r18,8(sp)
 908b240:	2821883a 	mov	r16,r5
 908b244:	2023883a 	mov	r17,r4
 908b248:	28002926 	beq	r5,zero,908b2f0 <_fclose_r+0xc4>
 908b24c:	9087bd40 	call	9087bd4 <__sfp_lock_acquire>
 908b250:	88000226 	beq	r17,zero,908b25c <_fclose_r+0x30>
 908b254:	88800e17 	ldw	r2,56(r17)
 908b258:	10002d26 	beq	r2,zero,908b310 <_fclose_r+0xe4>
 908b25c:	8080030f 	ldh	r2,12(r16)
 908b260:	10002226 	beq	r2,zero,908b2ec <_fclose_r+0xc0>
 908b264:	8809883a 	mov	r4,r17
 908b268:	800b883a 	mov	r5,r16
 908b26c:	908794c0 	call	908794c <_fflush_r>
 908b270:	1025883a 	mov	r18,r2
 908b274:	80800b17 	ldw	r2,44(r16)
 908b278:	10000426 	beq	r2,zero,908b28c <_fclose_r+0x60>
 908b27c:	81400717 	ldw	r5,28(r16)
 908b280:	8809883a 	mov	r4,r17
 908b284:	103ee83a 	callr	r2
 908b288:	10002a16 	blt	r2,zero,908b334 <_fclose_r+0x108>
 908b28c:	8080030b 	ldhu	r2,12(r16)
 908b290:	1080200c 	andi	r2,r2,128
 908b294:	1000231e 	bne	r2,zero,908b324 <_fclose_r+0xf8>
 908b298:	81400c17 	ldw	r5,48(r16)
 908b29c:	28000526 	beq	r5,zero,908b2b4 <_fclose_r+0x88>
 908b2a0:	80801004 	addi	r2,r16,64
 908b2a4:	28800226 	beq	r5,r2,908b2b0 <_fclose_r+0x84>
 908b2a8:	8809883a 	mov	r4,r17
 908b2ac:	90880b40 	call	90880b4 <_free_r>
 908b2b0:	80000c15 	stw	zero,48(r16)
 908b2b4:	81401117 	ldw	r5,68(r16)
 908b2b8:	28000326 	beq	r5,zero,908b2c8 <_fclose_r+0x9c>
 908b2bc:	8809883a 	mov	r4,r17
 908b2c0:	90880b40 	call	90880b4 <_free_r>
 908b2c4:	80001115 	stw	zero,68(r16)
 908b2c8:	8000030d 	sth	zero,12(r16)
 908b2cc:	9087bd80 	call	9087bd8 <__sfp_lock_release>
 908b2d0:	9005883a 	mov	r2,r18
 908b2d4:	dfc00317 	ldw	ra,12(sp)
 908b2d8:	dc800217 	ldw	r18,8(sp)
 908b2dc:	dc400117 	ldw	r17,4(sp)
 908b2e0:	dc000017 	ldw	r16,0(sp)
 908b2e4:	dec00404 	addi	sp,sp,16
 908b2e8:	f800283a 	ret
 908b2ec:	9087bd80 	call	9087bd8 <__sfp_lock_release>
 908b2f0:	0025883a 	mov	r18,zero
 908b2f4:	9005883a 	mov	r2,r18
 908b2f8:	dfc00317 	ldw	ra,12(sp)
 908b2fc:	dc800217 	ldw	r18,8(sp)
 908b300:	dc400117 	ldw	r17,4(sp)
 908b304:	dc000017 	ldw	r16,0(sp)
 908b308:	dec00404 	addi	sp,sp,16
 908b30c:	f800283a 	ret
 908b310:	8809883a 	mov	r4,r17
 908b314:	9087be40 	call	9087be4 <__sinit>
 908b318:	8080030f 	ldh	r2,12(r16)
 908b31c:	103fd11e 	bne	r2,zero,908b264 <_fclose_r+0x38>
 908b320:	003ff206 	br	908b2ec <_fclose_r+0xc0>
 908b324:	81400417 	ldw	r5,16(r16)
 908b328:	8809883a 	mov	r4,r17
 908b32c:	90880b40 	call	90880b4 <_free_r>
 908b330:	003fd906 	br	908b298 <_fclose_r+0x6c>
 908b334:	04bfffc4 	movi	r18,-1
 908b338:	003fd406 	br	908b28c <_fclose_r+0x60>

0908b33c <fclose>:
 908b33c:	00824374 	movhi	r2,2317
 908b340:	108e8604 	addi	r2,r2,14872
 908b344:	200b883a 	mov	r5,r4
 908b348:	11000017 	ldw	r4,0(r2)
 908b34c:	908b22c1 	jmpi	908b22c <_fclose_r>

0908b350 <_fstat_r>:
 908b350:	defffd04 	addi	sp,sp,-12
 908b354:	dc000015 	stw	r16,0(sp)
 908b358:	04024374 	movhi	r16,2317
 908b35c:	840ee904 	addi	r16,r16,15268
 908b360:	dc400115 	stw	r17,4(sp)
 908b364:	80000015 	stw	zero,0(r16)
 908b368:	2023883a 	mov	r17,r4
 908b36c:	2809883a 	mov	r4,r5
 908b370:	300b883a 	mov	r5,r6
 908b374:	dfc00215 	stw	ra,8(sp)
 908b378:	908d8ac0 	call	908d8ac <fstat>
 908b37c:	1007883a 	mov	r3,r2
 908b380:	00bfffc4 	movi	r2,-1
 908b384:	18800626 	beq	r3,r2,908b3a0 <_fstat_r+0x50>
 908b388:	1805883a 	mov	r2,r3
 908b38c:	dfc00217 	ldw	ra,8(sp)
 908b390:	dc400117 	ldw	r17,4(sp)
 908b394:	dc000017 	ldw	r16,0(sp)
 908b398:	dec00304 	addi	sp,sp,12
 908b39c:	f800283a 	ret
 908b3a0:	80800017 	ldw	r2,0(r16)
 908b3a4:	103ff826 	beq	r2,zero,908b388 <_fstat_r+0x38>
 908b3a8:	88800015 	stw	r2,0(r17)
 908b3ac:	1805883a 	mov	r2,r3
 908b3b0:	dfc00217 	ldw	ra,8(sp)
 908b3b4:	dc400117 	ldw	r17,4(sp)
 908b3b8:	dc000017 	ldw	r16,0(sp)
 908b3bc:	dec00304 	addi	sp,sp,12
 908b3c0:	f800283a 	ret

0908b3c4 <_isatty_r>:
 908b3c4:	defffd04 	addi	sp,sp,-12
 908b3c8:	dc000015 	stw	r16,0(sp)
 908b3cc:	04024374 	movhi	r16,2317
 908b3d0:	840ee904 	addi	r16,r16,15268
 908b3d4:	dc400115 	stw	r17,4(sp)
 908b3d8:	80000015 	stw	zero,0(r16)
 908b3dc:	2023883a 	mov	r17,r4
 908b3e0:	2809883a 	mov	r4,r5
 908b3e4:	dfc00215 	stw	ra,8(sp)
 908b3e8:	908d9e00 	call	908d9e0 <isatty>
 908b3ec:	1007883a 	mov	r3,r2
 908b3f0:	00bfffc4 	movi	r2,-1
 908b3f4:	18800626 	beq	r3,r2,908b410 <_isatty_r+0x4c>
 908b3f8:	1805883a 	mov	r2,r3
 908b3fc:	dfc00217 	ldw	ra,8(sp)
 908b400:	dc400117 	ldw	r17,4(sp)
 908b404:	dc000017 	ldw	r16,0(sp)
 908b408:	dec00304 	addi	sp,sp,12
 908b40c:	f800283a 	ret
 908b410:	80800017 	ldw	r2,0(r16)
 908b414:	103ff826 	beq	r2,zero,908b3f8 <_isatty_r+0x34>
 908b418:	88800015 	stw	r2,0(r17)
 908b41c:	1805883a 	mov	r2,r3
 908b420:	dfc00217 	ldw	ra,8(sp)
 908b424:	dc400117 	ldw	r17,4(sp)
 908b428:	dc000017 	ldw	r16,0(sp)
 908b42c:	dec00304 	addi	sp,sp,12
 908b430:	f800283a 	ret

0908b434 <_lseek_r>:
 908b434:	defffd04 	addi	sp,sp,-12
 908b438:	dc000015 	stw	r16,0(sp)
 908b43c:	04024374 	movhi	r16,2317
 908b440:	840ee904 	addi	r16,r16,15268
 908b444:	dc400115 	stw	r17,4(sp)
 908b448:	80000015 	stw	zero,0(r16)
 908b44c:	2023883a 	mov	r17,r4
 908b450:	2809883a 	mov	r4,r5
 908b454:	300b883a 	mov	r5,r6
 908b458:	380d883a 	mov	r6,r7
 908b45c:	dfc00215 	stw	ra,8(sp)
 908b460:	908db000 	call	908db00 <lseek>
 908b464:	1007883a 	mov	r3,r2
 908b468:	00bfffc4 	movi	r2,-1
 908b46c:	18800626 	beq	r3,r2,908b488 <_lseek_r+0x54>
 908b470:	1805883a 	mov	r2,r3
 908b474:	dfc00217 	ldw	ra,8(sp)
 908b478:	dc400117 	ldw	r17,4(sp)
 908b47c:	dc000017 	ldw	r16,0(sp)
 908b480:	dec00304 	addi	sp,sp,12
 908b484:	f800283a 	ret
 908b488:	80800017 	ldw	r2,0(r16)
 908b48c:	103ff826 	beq	r2,zero,908b470 <_lseek_r+0x3c>
 908b490:	88800015 	stw	r2,0(r17)
 908b494:	1805883a 	mov	r2,r3
 908b498:	dfc00217 	ldw	ra,8(sp)
 908b49c:	dc400117 	ldw	r17,4(sp)
 908b4a0:	dc000017 	ldw	r16,0(sp)
 908b4a4:	dec00304 	addi	sp,sp,12
 908b4a8:	f800283a 	ret

0908b4ac <_read_r>:
 908b4ac:	defffd04 	addi	sp,sp,-12
 908b4b0:	dc000015 	stw	r16,0(sp)
 908b4b4:	04024374 	movhi	r16,2317
 908b4b8:	840ee904 	addi	r16,r16,15268
 908b4bc:	dc400115 	stw	r17,4(sp)
 908b4c0:	80000015 	stw	zero,0(r16)
 908b4c4:	2023883a 	mov	r17,r4
 908b4c8:	2809883a 	mov	r4,r5
 908b4cc:	300b883a 	mov	r5,r6
 908b4d0:	380d883a 	mov	r6,r7
 908b4d4:	dfc00215 	stw	ra,8(sp)
 908b4d8:	90a1d240 	call	90a1d24 <read>
 908b4dc:	1007883a 	mov	r3,r2
 908b4e0:	00bfffc4 	movi	r2,-1
 908b4e4:	18800626 	beq	r3,r2,908b500 <_read_r+0x54>
 908b4e8:	1805883a 	mov	r2,r3
 908b4ec:	dfc00217 	ldw	ra,8(sp)
 908b4f0:	dc400117 	ldw	r17,4(sp)
 908b4f4:	dc000017 	ldw	r16,0(sp)
 908b4f8:	dec00304 	addi	sp,sp,12
 908b4fc:	f800283a 	ret
 908b500:	80800017 	ldw	r2,0(r16)
 908b504:	103ff826 	beq	r2,zero,908b4e8 <_read_r+0x3c>
 908b508:	88800015 	stw	r2,0(r17)
 908b50c:	1805883a 	mov	r2,r3
 908b510:	dfc00217 	ldw	ra,8(sp)
 908b514:	dc400117 	ldw	r17,4(sp)
 908b518:	dc000017 	ldw	r16,0(sp)
 908b51c:	dec00304 	addi	sp,sp,12
 908b520:	f800283a 	ret

0908b524 <__udivdi3>:
 908b524:	defff004 	addi	sp,sp,-64
 908b528:	2005883a 	mov	r2,r4
 908b52c:	3011883a 	mov	r8,r6
 908b530:	df000e15 	stw	fp,56(sp)
 908b534:	dd000a15 	stw	r20,40(sp)
 908b538:	dc000615 	stw	r16,24(sp)
 908b53c:	dfc00f15 	stw	ra,60(sp)
 908b540:	ddc00d15 	stw	r23,52(sp)
 908b544:	dd800c15 	stw	r22,48(sp)
 908b548:	dd400b15 	stw	r21,44(sp)
 908b54c:	dcc00915 	stw	r19,36(sp)
 908b550:	dc800815 	stw	r18,32(sp)
 908b554:	dc400715 	stw	r17,28(sp)
 908b558:	4021883a 	mov	r16,r8
 908b55c:	1039883a 	mov	fp,r2
 908b560:	2829883a 	mov	r20,r5
 908b564:	38003b1e 	bne	r7,zero,908b654 <__udivdi3+0x130>
 908b568:	2a005c36 	bltu	r5,r8,908b6dc <__udivdi3+0x1b8>
 908b56c:	4000a626 	beq	r8,zero,908b808 <__udivdi3+0x2e4>
 908b570:	00bfffd4 	movui	r2,65535
 908b574:	14009e36 	bltu	r2,r16,908b7f0 <__udivdi3+0x2cc>
 908b578:	00803fc4 	movi	r2,255
 908b57c:	14013d36 	bltu	r2,r16,908ba74 <__udivdi3+0x550>
 908b580:	000b883a 	mov	r5,zero
 908b584:	0005883a 	mov	r2,zero
 908b588:	8084d83a 	srl	r2,r16,r2
 908b58c:	01024374 	movhi	r4,2317
 908b590:	2135cc04 	addi	r4,r4,-10448
 908b594:	01800804 	movi	r6,32
 908b598:	1105883a 	add	r2,r2,r4
 908b59c:	10c00003 	ldbu	r3,0(r2)
 908b5a0:	28c7883a 	add	r3,r5,r3
 908b5a4:	30edc83a 	sub	r22,r6,r3
 908b5a8:	b000ee1e 	bne	r22,zero,908b964 <__udivdi3+0x440>
 908b5ac:	802ad43a 	srli	r21,r16,16
 908b5b0:	00800044 	movi	r2,1
 908b5b4:	a423c83a 	sub	r17,r20,r16
 908b5b8:	85ffffcc 	andi	r23,r16,65535
 908b5bc:	d8800315 	stw	r2,12(sp)
 908b5c0:	8809883a 	mov	r4,r17
 908b5c4:	a80b883a 	mov	r5,r21
 908b5c8:	908d3080 	call	908d308 <__udivsi3>
 908b5cc:	8809883a 	mov	r4,r17
 908b5d0:	a80b883a 	mov	r5,r21
 908b5d4:	102d883a 	mov	r22,r2
 908b5d8:	908d3100 	call	908d310 <__umodsi3>
 908b5dc:	1004943a 	slli	r2,r2,16
 908b5e0:	e006d43a 	srli	r3,fp,16
 908b5e4:	bda3383a 	mul	r17,r23,r22
 908b5e8:	10c4b03a 	or	r2,r2,r3
 908b5ec:	1440042e 	bgeu	r2,r17,908b600 <__udivdi3+0xdc>
 908b5f0:	1405883a 	add	r2,r2,r16
 908b5f4:	b5bfffc4 	addi	r22,r22,-1
 908b5f8:	14000136 	bltu	r2,r16,908b600 <__udivdi3+0xdc>
 908b5fc:	14413d36 	bltu	r2,r17,908baf4 <__udivdi3+0x5d0>
 908b600:	1463c83a 	sub	r17,r2,r17
 908b604:	8809883a 	mov	r4,r17
 908b608:	a80b883a 	mov	r5,r21
 908b60c:	908d3080 	call	908d308 <__udivsi3>
 908b610:	8809883a 	mov	r4,r17
 908b614:	a80b883a 	mov	r5,r21
 908b618:	1029883a 	mov	r20,r2
 908b61c:	908d3100 	call	908d310 <__umodsi3>
 908b620:	1004943a 	slli	r2,r2,16
 908b624:	bd09383a 	mul	r4,r23,r20
 908b628:	e0ffffcc 	andi	r3,fp,65535
 908b62c:	10c4b03a 	or	r2,r2,r3
 908b630:	1100042e 	bgeu	r2,r4,908b644 <__udivdi3+0x120>
 908b634:	8085883a 	add	r2,r16,r2
 908b638:	a53fffc4 	addi	r20,r20,-1
 908b63c:	14000136 	bltu	r2,r16,908b644 <__udivdi3+0x120>
 908b640:	11012036 	bltu	r2,r4,908bac4 <__udivdi3+0x5a0>
 908b644:	b004943a 	slli	r2,r22,16
 908b648:	d9000317 	ldw	r4,12(sp)
 908b64c:	a084b03a 	or	r2,r20,r2
 908b650:	00001506 	br	908b6a8 <__udivdi3+0x184>
 908b654:	380d883a 	mov	r6,r7
 908b658:	29c06236 	bltu	r5,r7,908b7e4 <__udivdi3+0x2c0>
 908b65c:	00bfffd4 	movui	r2,65535
 908b660:	11c05a36 	bltu	r2,r7,908b7cc <__udivdi3+0x2a8>
 908b664:	00803fc4 	movi	r2,255
 908b668:	11c0fc36 	bltu	r2,r7,908ba5c <__udivdi3+0x538>
 908b66c:	000b883a 	mov	r5,zero
 908b670:	0005883a 	mov	r2,zero
 908b674:	3084d83a 	srl	r2,r6,r2
 908b678:	01024374 	movhi	r4,2317
 908b67c:	2135cc04 	addi	r4,r4,-10448
 908b680:	01c00804 	movi	r7,32
 908b684:	1105883a 	add	r2,r2,r4
 908b688:	10c00003 	ldbu	r3,0(r2)
 908b68c:	28c7883a 	add	r3,r5,r3
 908b690:	38efc83a 	sub	r23,r7,r3
 908b694:	b800691e 	bne	r23,zero,908b83c <__udivdi3+0x318>
 908b698:	35000136 	bltu	r6,r20,908b6a0 <__udivdi3+0x17c>
 908b69c:	e4005136 	bltu	fp,r16,908b7e4 <__udivdi3+0x2c0>
 908b6a0:	00800044 	movi	r2,1
 908b6a4:	0009883a 	mov	r4,zero
 908b6a8:	2007883a 	mov	r3,r4
 908b6ac:	dfc00f17 	ldw	ra,60(sp)
 908b6b0:	df000e17 	ldw	fp,56(sp)
 908b6b4:	ddc00d17 	ldw	r23,52(sp)
 908b6b8:	dd800c17 	ldw	r22,48(sp)
 908b6bc:	dd400b17 	ldw	r21,44(sp)
 908b6c0:	dd000a17 	ldw	r20,40(sp)
 908b6c4:	dcc00917 	ldw	r19,36(sp)
 908b6c8:	dc800817 	ldw	r18,32(sp)
 908b6cc:	dc400717 	ldw	r17,28(sp)
 908b6d0:	dc000617 	ldw	r16,24(sp)
 908b6d4:	dec01004 	addi	sp,sp,64
 908b6d8:	f800283a 	ret
 908b6dc:	00bfffd4 	movui	r2,65535
 908b6e0:	12005036 	bltu	r2,r8,908b824 <__udivdi3+0x300>
 908b6e4:	00803fc4 	movi	r2,255
 908b6e8:	1200e836 	bltu	r2,r8,908ba8c <__udivdi3+0x568>
 908b6ec:	000b883a 	mov	r5,zero
 908b6f0:	0005883a 	mov	r2,zero
 908b6f4:	8084d83a 	srl	r2,r16,r2
 908b6f8:	01024374 	movhi	r4,2317
 908b6fc:	2135cc04 	addi	r4,r4,-10448
 908b700:	01800804 	movi	r6,32
 908b704:	1105883a 	add	r2,r2,r4
 908b708:	10c00003 	ldbu	r3,0(r2)
 908b70c:	28c7883a 	add	r3,r5,r3
 908b710:	30cbc83a 	sub	r5,r6,r3
 908b714:	28000626 	beq	r5,zero,908b730 <__udivdi3+0x20c>
 908b718:	3145c83a 	sub	r2,r6,r5
 908b71c:	e084d83a 	srl	r2,fp,r2
 908b720:	a146983a 	sll	r3,r20,r5
 908b724:	e178983a 	sll	fp,fp,r5
 908b728:	8160983a 	sll	r16,r16,r5
 908b72c:	18a8b03a 	or	r20,r3,r2
 908b730:	802ad43a 	srli	r21,r16,16
 908b734:	a009883a 	mov	r4,r20
 908b738:	85ffffcc 	andi	r23,r16,65535
 908b73c:	a80b883a 	mov	r5,r21
 908b740:	908d3080 	call	908d308 <__udivsi3>
 908b744:	a009883a 	mov	r4,r20
 908b748:	a80b883a 	mov	r5,r21
 908b74c:	102d883a 	mov	r22,r2
 908b750:	908d3100 	call	908d310 <__umodsi3>
 908b754:	1004943a 	slli	r2,r2,16
 908b758:	e006d43a 	srli	r3,fp,16
 908b75c:	bda3383a 	mul	r17,r23,r22
 908b760:	10c4b03a 	or	r2,r2,r3
 908b764:	1440042e 	bgeu	r2,r17,908b778 <__udivdi3+0x254>
 908b768:	1405883a 	add	r2,r2,r16
 908b76c:	b5bfffc4 	addi	r22,r22,-1
 908b770:	14000136 	bltu	r2,r16,908b778 <__udivdi3+0x254>
 908b774:	1440d536 	bltu	r2,r17,908bacc <__udivdi3+0x5a8>
 908b778:	1463c83a 	sub	r17,r2,r17
 908b77c:	8809883a 	mov	r4,r17
 908b780:	a80b883a 	mov	r5,r21
 908b784:	908d3080 	call	908d308 <__udivsi3>
 908b788:	8809883a 	mov	r4,r17
 908b78c:	a80b883a 	mov	r5,r21
 908b790:	1029883a 	mov	r20,r2
 908b794:	908d3100 	call	908d310 <__umodsi3>
 908b798:	1004943a 	slli	r2,r2,16
 908b79c:	bd09383a 	mul	r4,r23,r20
 908b7a0:	e0ffffcc 	andi	r3,fp,65535
 908b7a4:	10c4b03a 	or	r2,r2,r3
 908b7a8:	1100042e 	bgeu	r2,r4,908b7bc <__udivdi3+0x298>
 908b7ac:	8085883a 	add	r2,r16,r2
 908b7b0:	a53fffc4 	addi	r20,r20,-1
 908b7b4:	14000136 	bltu	r2,r16,908b7bc <__udivdi3+0x298>
 908b7b8:	1100c736 	bltu	r2,r4,908bad8 <__udivdi3+0x5b4>
 908b7bc:	b004943a 	slli	r2,r22,16
 908b7c0:	0009883a 	mov	r4,zero
 908b7c4:	a084b03a 	or	r2,r20,r2
 908b7c8:	003fb706 	br	908b6a8 <__udivdi3+0x184>
 908b7cc:	00804034 	movhi	r2,256
 908b7d0:	10bfffc4 	addi	r2,r2,-1
 908b7d4:	11c0a436 	bltu	r2,r7,908ba68 <__udivdi3+0x544>
 908b7d8:	01400404 	movi	r5,16
 908b7dc:	2805883a 	mov	r2,r5
 908b7e0:	003fa406 	br	908b674 <__udivdi3+0x150>
 908b7e4:	0005883a 	mov	r2,zero
 908b7e8:	0009883a 	mov	r4,zero
 908b7ec:	003fae06 	br	908b6a8 <__udivdi3+0x184>
 908b7f0:	00804034 	movhi	r2,256
 908b7f4:	10bfffc4 	addi	r2,r2,-1
 908b7f8:	1400a136 	bltu	r2,r16,908ba80 <__udivdi3+0x55c>
 908b7fc:	01400404 	movi	r5,16
 908b800:	2805883a 	mov	r2,r5
 908b804:	003f6006 	br	908b588 <__udivdi3+0x64>
 908b808:	01000044 	movi	r4,1
 908b80c:	000b883a 	mov	r5,zero
 908b810:	908d3080 	call	908d308 <__udivsi3>
 908b814:	1021883a 	mov	r16,r2
 908b818:	00bfffd4 	movui	r2,65535
 908b81c:	143ff436 	bltu	r2,r16,908b7f0 <__udivdi3+0x2cc>
 908b820:	003f5506 	br	908b578 <__udivdi3+0x54>
 908b824:	00804034 	movhi	r2,256
 908b828:	10bfffc4 	addi	r2,r2,-1
 908b82c:	12009a36 	bltu	r2,r8,908ba98 <__udivdi3+0x574>
 908b830:	01400404 	movi	r5,16
 908b834:	2805883a 	mov	r2,r5
 908b838:	003fae06 	br	908b6f4 <__udivdi3+0x1d0>
 908b83c:	3dc5c83a 	sub	r2,r7,r23
 908b840:	35c8983a 	sll	r4,r6,r23
 908b844:	8086d83a 	srl	r3,r16,r2
 908b848:	a0a2d83a 	srl	r17,r20,r2
 908b84c:	e084d83a 	srl	r2,fp,r2
 908b850:	20eab03a 	or	r21,r4,r3
 908b854:	a82cd43a 	srli	r22,r21,16
 908b858:	a5c6983a 	sll	r3,r20,r23
 908b85c:	8809883a 	mov	r4,r17
 908b860:	b00b883a 	mov	r5,r22
 908b864:	1886b03a 	or	r3,r3,r2
 908b868:	d8c00215 	stw	r3,8(sp)
 908b86c:	908d3080 	call	908d308 <__udivsi3>
 908b870:	8809883a 	mov	r4,r17
 908b874:	b00b883a 	mov	r5,r22
 908b878:	1029883a 	mov	r20,r2
 908b87c:	908d3100 	call	908d310 <__umodsi3>
 908b880:	a8ffffcc 	andi	r3,r21,65535
 908b884:	d8c00515 	stw	r3,20(sp)
 908b888:	d9000217 	ldw	r4,8(sp)
 908b88c:	d9400517 	ldw	r5,20(sp)
 908b890:	1004943a 	slli	r2,r2,16
 908b894:	2006d43a 	srli	r3,r4,16
 908b898:	85e0983a 	sll	r16,r16,r23
 908b89c:	2d23383a 	mul	r17,r5,r20
 908b8a0:	10c4b03a 	or	r2,r2,r3
 908b8a4:	dc000015 	stw	r16,0(sp)
 908b8a8:	1440032e 	bgeu	r2,r17,908b8b8 <__udivdi3+0x394>
 908b8ac:	1545883a 	add	r2,r2,r21
 908b8b0:	a53fffc4 	addi	r20,r20,-1
 908b8b4:	15407f2e 	bgeu	r2,r21,908bab4 <__udivdi3+0x590>
 908b8b8:	1463c83a 	sub	r17,r2,r17
 908b8bc:	8809883a 	mov	r4,r17
 908b8c0:	b00b883a 	mov	r5,r22
 908b8c4:	908d3080 	call	908d308 <__udivsi3>
 908b8c8:	8809883a 	mov	r4,r17
 908b8cc:	b00b883a 	mov	r5,r22
 908b8d0:	1021883a 	mov	r16,r2
 908b8d4:	908d3100 	call	908d310 <__umodsi3>
 908b8d8:	d8c00517 	ldw	r3,20(sp)
 908b8dc:	d9000217 	ldw	r4,8(sp)
 908b8e0:	1004943a 	slli	r2,r2,16
 908b8e4:	1c0f383a 	mul	r7,r3,r16
 908b8e8:	20ffffcc 	andi	r3,r4,65535
 908b8ec:	10e2b03a 	or	r17,r2,r3
 908b8f0:	89c0032e 	bgeu	r17,r7,908b900 <__udivdi3+0x3dc>
 908b8f4:	8d63883a 	add	r17,r17,r21
 908b8f8:	843fffc4 	addi	r16,r16,-1
 908b8fc:	8d40692e 	bgeu	r17,r21,908baa4 <__udivdi3+0x580>
 908b900:	a008943a 	slli	r4,r20,16
 908b904:	d9400017 	ldw	r5,0(sp)
 908b908:	89e3c83a 	sub	r17,r17,r7
 908b90c:	8110b03a 	or	r8,r16,r4
 908b910:	280cd43a 	srli	r6,r5,16
 908b914:	28ffffcc 	andi	r3,r5,65535
 908b918:	40bfffcc 	andi	r2,r8,65535
 908b91c:	400ad43a 	srli	r5,r8,16
 908b920:	10d3383a 	mul	r9,r2,r3
 908b924:	1185383a 	mul	r2,r2,r6
 908b928:	28c7383a 	mul	r3,r5,r3
 908b92c:	4808d43a 	srli	r4,r9,16
 908b930:	298b383a 	mul	r5,r5,r6
 908b934:	10c5883a 	add	r2,r2,r3
 908b938:	2089883a 	add	r4,r4,r2
 908b93c:	20c0022e 	bgeu	r4,r3,908b948 <__udivdi3+0x424>
 908b940:	00800074 	movhi	r2,1
 908b944:	288b883a 	add	r5,r5,r2
 908b948:	2004d43a 	srli	r2,r4,16
 908b94c:	288b883a 	add	r5,r5,r2
 908b950:	89403f36 	bltu	r17,r5,908ba50 <__udivdi3+0x52c>
 908b954:	89403926 	beq	r17,r5,908ba3c <__udivdi3+0x518>
 908b958:	4005883a 	mov	r2,r8
 908b95c:	0009883a 	mov	r4,zero
 908b960:	003f5106 	br	908b6a8 <__udivdi3+0x184>
 908b964:	85a0983a 	sll	r16,r16,r22
 908b968:	3585c83a 	sub	r2,r6,r22
 908b96c:	a0a2d83a 	srl	r17,r20,r2
 908b970:	802ad43a 	srli	r21,r16,16
 908b974:	e084d83a 	srl	r2,fp,r2
 908b978:	a586983a 	sll	r3,r20,r22
 908b97c:	8809883a 	mov	r4,r17
 908b980:	a80b883a 	mov	r5,r21
 908b984:	1886b03a 	or	r3,r3,r2
 908b988:	d8c00115 	stw	r3,4(sp)
 908b98c:	908d3080 	call	908d308 <__udivsi3>
 908b990:	8809883a 	mov	r4,r17
 908b994:	a80b883a 	mov	r5,r21
 908b998:	d8800415 	stw	r2,16(sp)
 908b99c:	908d3100 	call	908d310 <__umodsi3>
 908b9a0:	d9000117 	ldw	r4,4(sp)
 908b9a4:	d9400417 	ldw	r5,16(sp)
 908b9a8:	1004943a 	slli	r2,r2,16
 908b9ac:	85ffffcc 	andi	r23,r16,65535
 908b9b0:	2006d43a 	srli	r3,r4,16
 908b9b4:	b963383a 	mul	r17,r23,r5
 908b9b8:	10c4b03a 	or	r2,r2,r3
 908b9bc:	1440042e 	bgeu	r2,r17,908b9d0 <__udivdi3+0x4ac>
 908b9c0:	297fffc4 	addi	r5,r5,-1
 908b9c4:	1405883a 	add	r2,r2,r16
 908b9c8:	d9400415 	stw	r5,16(sp)
 908b9cc:	1400442e 	bgeu	r2,r16,908bae0 <__udivdi3+0x5bc>
 908b9d0:	1463c83a 	sub	r17,r2,r17
 908b9d4:	8809883a 	mov	r4,r17
 908b9d8:	a80b883a 	mov	r5,r21
 908b9dc:	908d3080 	call	908d308 <__udivsi3>
 908b9e0:	8809883a 	mov	r4,r17
 908b9e4:	a80b883a 	mov	r5,r21
 908b9e8:	1029883a 	mov	r20,r2
 908b9ec:	908d3100 	call	908d310 <__umodsi3>
 908b9f0:	d9400117 	ldw	r5,4(sp)
 908b9f4:	1004943a 	slli	r2,r2,16
 908b9f8:	bd09383a 	mul	r4,r23,r20
 908b9fc:	28ffffcc 	andi	r3,r5,65535
 908ba00:	10c6b03a 	or	r3,r2,r3
 908ba04:	1900062e 	bgeu	r3,r4,908ba20 <__udivdi3+0x4fc>
 908ba08:	1c07883a 	add	r3,r3,r16
 908ba0c:	a53fffc4 	addi	r20,r20,-1
 908ba10:	1c000336 	bltu	r3,r16,908ba20 <__udivdi3+0x4fc>
 908ba14:	1900022e 	bgeu	r3,r4,908ba20 <__udivdi3+0x4fc>
 908ba18:	a53fffc4 	addi	r20,r20,-1
 908ba1c:	1c07883a 	add	r3,r3,r16
 908ba20:	d9400417 	ldw	r5,16(sp)
 908ba24:	e5b8983a 	sll	fp,fp,r22
 908ba28:	1923c83a 	sub	r17,r3,r4
 908ba2c:	2804943a 	slli	r2,r5,16
 908ba30:	a0a8b03a 	or	r20,r20,r2
 908ba34:	dd000315 	stw	r20,12(sp)
 908ba38:	003ee106 	br	908b5c0 <__udivdi3+0x9c>
 908ba3c:	2004943a 	slli	r2,r4,16
 908ba40:	e5c8983a 	sll	r4,fp,r23
 908ba44:	48ffffcc 	andi	r3,r9,65535
 908ba48:	10c5883a 	add	r2,r2,r3
 908ba4c:	20bfc22e 	bgeu	r4,r2,908b958 <__udivdi3+0x434>
 908ba50:	40bfffc4 	addi	r2,r8,-1
 908ba54:	0009883a 	mov	r4,zero
 908ba58:	003f1306 	br	908b6a8 <__udivdi3+0x184>
 908ba5c:	01400204 	movi	r5,8
 908ba60:	2805883a 	mov	r2,r5
 908ba64:	003f0306 	br	908b674 <__udivdi3+0x150>
 908ba68:	01400604 	movi	r5,24
 908ba6c:	2805883a 	mov	r2,r5
 908ba70:	003f0006 	br	908b674 <__udivdi3+0x150>
 908ba74:	01400204 	movi	r5,8
 908ba78:	2805883a 	mov	r2,r5
 908ba7c:	003ec206 	br	908b588 <__udivdi3+0x64>
 908ba80:	01400604 	movi	r5,24
 908ba84:	2805883a 	mov	r2,r5
 908ba88:	003ebf06 	br	908b588 <__udivdi3+0x64>
 908ba8c:	01400204 	movi	r5,8
 908ba90:	2805883a 	mov	r2,r5
 908ba94:	003f1706 	br	908b6f4 <__udivdi3+0x1d0>
 908ba98:	01400604 	movi	r5,24
 908ba9c:	2805883a 	mov	r2,r5
 908baa0:	003f1406 	br	908b6f4 <__udivdi3+0x1d0>
 908baa4:	89ff962e 	bgeu	r17,r7,908b900 <__udivdi3+0x3dc>
 908baa8:	8d63883a 	add	r17,r17,r21
 908baac:	843fffc4 	addi	r16,r16,-1
 908bab0:	003f9306 	br	908b900 <__udivdi3+0x3dc>
 908bab4:	147f802e 	bgeu	r2,r17,908b8b8 <__udivdi3+0x394>
 908bab8:	a53fffc4 	addi	r20,r20,-1
 908babc:	1545883a 	add	r2,r2,r21
 908bac0:	003f7d06 	br	908b8b8 <__udivdi3+0x394>
 908bac4:	a53fffc4 	addi	r20,r20,-1
 908bac8:	003ede06 	br	908b644 <__udivdi3+0x120>
 908bacc:	b5bfffc4 	addi	r22,r22,-1
 908bad0:	1405883a 	add	r2,r2,r16
 908bad4:	003f2806 	br	908b778 <__udivdi3+0x254>
 908bad8:	a53fffc4 	addi	r20,r20,-1
 908badc:	003f3706 	br	908b7bc <__udivdi3+0x298>
 908bae0:	147fbb2e 	bgeu	r2,r17,908b9d0 <__udivdi3+0x4ac>
 908bae4:	297fffc4 	addi	r5,r5,-1
 908bae8:	1405883a 	add	r2,r2,r16
 908baec:	d9400415 	stw	r5,16(sp)
 908baf0:	003fb706 	br	908b9d0 <__udivdi3+0x4ac>
 908baf4:	b5bfffc4 	addi	r22,r22,-1
 908baf8:	1405883a 	add	r2,r2,r16
 908bafc:	003ec006 	br	908b600 <__udivdi3+0xdc>

0908bb00 <__umoddi3>:
 908bb00:	defff104 	addi	sp,sp,-60
 908bb04:	dd800b15 	stw	r22,44(sp)
 908bb08:	dd000915 	stw	r20,36(sp)
 908bb0c:	dc000515 	stw	r16,20(sp)
 908bb10:	dfc00e15 	stw	ra,56(sp)
 908bb14:	df000d15 	stw	fp,52(sp)
 908bb18:	ddc00c15 	stw	r23,48(sp)
 908bb1c:	dd400a15 	stw	r21,40(sp)
 908bb20:	dcc00815 	stw	r19,32(sp)
 908bb24:	dc800715 	stw	r18,28(sp)
 908bb28:	dc400615 	stw	r17,24(sp)
 908bb2c:	3021883a 	mov	r16,r6
 908bb30:	202d883a 	mov	r22,r4
 908bb34:	2829883a 	mov	r20,r5
 908bb38:	38002b1e 	bne	r7,zero,908bbe8 <__umoddi3+0xe8>
 908bb3c:	29805036 	bltu	r5,r6,908bc80 <__umoddi3+0x180>
 908bb40:	30008a26 	beq	r6,zero,908bd6c <__umoddi3+0x26c>
 908bb44:	00bfffd4 	movui	r2,65535
 908bb48:	14008236 	bltu	r2,r16,908bd54 <__umoddi3+0x254>
 908bb4c:	00803fc4 	movi	r2,255
 908bb50:	14013636 	bltu	r2,r16,908c02c <__umoddi3+0x52c>
 908bb54:	000b883a 	mov	r5,zero
 908bb58:	0005883a 	mov	r2,zero
 908bb5c:	8084d83a 	srl	r2,r16,r2
 908bb60:	01024374 	movhi	r4,2317
 908bb64:	2135cc04 	addi	r4,r4,-10448
 908bb68:	01800804 	movi	r6,32
 908bb6c:	1105883a 	add	r2,r2,r4
 908bb70:	10c00003 	ldbu	r3,0(r2)
 908bb74:	28c7883a 	add	r3,r5,r3
 908bb78:	30efc83a 	sub	r23,r6,r3
 908bb7c:	b800941e 	bne	r23,zero,908bdd0 <__umoddi3+0x2d0>
 908bb80:	802ad43a 	srli	r21,r16,16
 908bb84:	a423c83a 	sub	r17,r20,r16
 908bb88:	0039883a 	mov	fp,zero
 908bb8c:	853fffcc 	andi	r20,r16,65535
 908bb90:	8809883a 	mov	r4,r17
 908bb94:	a80b883a 	mov	r5,r21
 908bb98:	908d3080 	call	908d308 <__udivsi3>
 908bb9c:	8809883a 	mov	r4,r17
 908bba0:	a80b883a 	mov	r5,r21
 908bba4:	a0a3383a 	mul	r17,r20,r2
 908bba8:	908d3100 	call	908d310 <__umodsi3>
 908bbac:	1004943a 	slli	r2,r2,16
 908bbb0:	b006d43a 	srli	r3,r22,16
 908bbb4:	10c4b03a 	or	r2,r2,r3
 908bbb8:	1440032e 	bgeu	r2,r17,908bbc8 <__umoddi3+0xc8>
 908bbbc:	1405883a 	add	r2,r2,r16
 908bbc0:	14000136 	bltu	r2,r16,908bbc8 <__umoddi3+0xc8>
 908bbc4:	14413536 	bltu	r2,r17,908c09c <__umoddi3+0x59c>
 908bbc8:	1463c83a 	sub	r17,r2,r17
 908bbcc:	8809883a 	mov	r4,r17
 908bbd0:	a80b883a 	mov	r5,r21
 908bbd4:	908d3080 	call	908d308 <__udivsi3>
 908bbd8:	8809883a 	mov	r4,r17
 908bbdc:	a0a3383a 	mul	r17,r20,r2
 908bbe0:	a80b883a 	mov	r5,r21
 908bbe4:	00004d06 	br	908bd1c <__umoddi3+0x21c>
 908bbe8:	380d883a 	mov	r6,r7
 908bbec:	29c0102e 	bgeu	r5,r7,908bc30 <__umoddi3+0x130>
 908bbf0:	2011883a 	mov	r8,r4
 908bbf4:	2813883a 	mov	r9,r5
 908bbf8:	4005883a 	mov	r2,r8
 908bbfc:	4807883a 	mov	r3,r9
 908bc00:	dfc00e17 	ldw	ra,56(sp)
 908bc04:	df000d17 	ldw	fp,52(sp)
 908bc08:	ddc00c17 	ldw	r23,48(sp)
 908bc0c:	dd800b17 	ldw	r22,44(sp)
 908bc10:	dd400a17 	ldw	r21,40(sp)
 908bc14:	dd000917 	ldw	r20,36(sp)
 908bc18:	dcc00817 	ldw	r19,32(sp)
 908bc1c:	dc800717 	ldw	r18,28(sp)
 908bc20:	dc400617 	ldw	r17,24(sp)
 908bc24:	dc000517 	ldw	r16,20(sp)
 908bc28:	dec00f04 	addi	sp,sp,60
 908bc2c:	f800283a 	ret
 908bc30:	00bfffd4 	movui	r2,65535
 908bc34:	11c05a36 	bltu	r2,r7,908bda0 <__umoddi3+0x2a0>
 908bc38:	00803fc4 	movi	r2,255
 908bc3c:	11c0fe36 	bltu	r2,r7,908c038 <__umoddi3+0x538>
 908bc40:	000b883a 	mov	r5,zero
 908bc44:	0005883a 	mov	r2,zero
 908bc48:	3084d83a 	srl	r2,r6,r2
 908bc4c:	01024374 	movhi	r4,2317
 908bc50:	2135cc04 	addi	r4,r4,-10448
 908bc54:	01c00804 	movi	r7,32
 908bc58:	1105883a 	add	r2,r2,r4
 908bc5c:	10c00003 	ldbu	r3,0(r2)
 908bc60:	28c7883a 	add	r3,r5,r3
 908bc64:	38ebc83a 	sub	r21,r7,r3
 908bc68:	a800851e 	bne	r21,zero,908be80 <__umoddi3+0x380>
 908bc6c:	35005236 	bltu	r6,r20,908bdb8 <__umoddi3+0x2b8>
 908bc70:	b400512e 	bgeu	r22,r16,908bdb8 <__umoddi3+0x2b8>
 908bc74:	b011883a 	mov	r8,r22
 908bc78:	a013883a 	mov	r9,r20
 908bc7c:	003fde06 	br	908bbf8 <__umoddi3+0xf8>
 908bc80:	00bfffd4 	movui	r2,65535
 908bc84:	11804036 	bltu	r2,r6,908bd88 <__umoddi3+0x288>
 908bc88:	00803fc4 	movi	r2,255
 908bc8c:	1180ed36 	bltu	r2,r6,908c044 <__umoddi3+0x544>
 908bc90:	000b883a 	mov	r5,zero
 908bc94:	0005883a 	mov	r2,zero
 908bc98:	8084d83a 	srl	r2,r16,r2
 908bc9c:	01024374 	movhi	r4,2317
 908bca0:	2135cc04 	addi	r4,r4,-10448
 908bca4:	01800804 	movi	r6,32
 908bca8:	1105883a 	add	r2,r2,r4
 908bcac:	10c00003 	ldbu	r3,0(r2)
 908bcb0:	28c7883a 	add	r3,r5,r3
 908bcb4:	30c7c83a 	sub	r3,r6,r3
 908bcb8:	1800bf1e 	bne	r3,zero,908bfb8 <__umoddi3+0x4b8>
 908bcbc:	0039883a 	mov	fp,zero
 908bcc0:	802ad43a 	srli	r21,r16,16
 908bcc4:	a009883a 	mov	r4,r20
 908bcc8:	85ffffcc 	andi	r23,r16,65535
 908bccc:	a80b883a 	mov	r5,r21
 908bcd0:	908d3080 	call	908d308 <__udivsi3>
 908bcd4:	a009883a 	mov	r4,r20
 908bcd8:	a80b883a 	mov	r5,r21
 908bcdc:	b8a3383a 	mul	r17,r23,r2
 908bce0:	908d3100 	call	908d310 <__umodsi3>
 908bce4:	1004943a 	slli	r2,r2,16
 908bce8:	b006d43a 	srli	r3,r22,16
 908bcec:	10c4b03a 	or	r2,r2,r3
 908bcf0:	1440032e 	bgeu	r2,r17,908bd00 <__umoddi3+0x200>
 908bcf4:	1405883a 	add	r2,r2,r16
 908bcf8:	14000136 	bltu	r2,r16,908bd00 <__umoddi3+0x200>
 908bcfc:	1440e536 	bltu	r2,r17,908c094 <__umoddi3+0x594>
 908bd00:	1463c83a 	sub	r17,r2,r17
 908bd04:	8809883a 	mov	r4,r17
 908bd08:	a80b883a 	mov	r5,r21
 908bd0c:	908d3080 	call	908d308 <__udivsi3>
 908bd10:	8809883a 	mov	r4,r17
 908bd14:	b8a3383a 	mul	r17,r23,r2
 908bd18:	a80b883a 	mov	r5,r21
 908bd1c:	908d3100 	call	908d310 <__umodsi3>
 908bd20:	1004943a 	slli	r2,r2,16
 908bd24:	b0ffffcc 	andi	r3,r22,65535
 908bd28:	10c4b03a 	or	r2,r2,r3
 908bd2c:	1440042e 	bgeu	r2,r17,908bd40 <__umoddi3+0x240>
 908bd30:	1405883a 	add	r2,r2,r16
 908bd34:	14000236 	bltu	r2,r16,908bd40 <__umoddi3+0x240>
 908bd38:	1440012e 	bgeu	r2,r17,908bd40 <__umoddi3+0x240>
 908bd3c:	1405883a 	add	r2,r2,r16
 908bd40:	1445c83a 	sub	r2,r2,r17
 908bd44:	1724d83a 	srl	r18,r2,fp
 908bd48:	0013883a 	mov	r9,zero
 908bd4c:	9011883a 	mov	r8,r18
 908bd50:	003fa906 	br	908bbf8 <__umoddi3+0xf8>
 908bd54:	00804034 	movhi	r2,256
 908bd58:	10bfffc4 	addi	r2,r2,-1
 908bd5c:	1400b036 	bltu	r2,r16,908c020 <__umoddi3+0x520>
 908bd60:	01400404 	movi	r5,16
 908bd64:	2805883a 	mov	r2,r5
 908bd68:	003f7c06 	br	908bb5c <__umoddi3+0x5c>
 908bd6c:	01000044 	movi	r4,1
 908bd70:	000b883a 	mov	r5,zero
 908bd74:	908d3080 	call	908d308 <__udivsi3>
 908bd78:	1021883a 	mov	r16,r2
 908bd7c:	00bfffd4 	movui	r2,65535
 908bd80:	143ff436 	bltu	r2,r16,908bd54 <__umoddi3+0x254>
 908bd84:	003f7106 	br	908bb4c <__umoddi3+0x4c>
 908bd88:	00804034 	movhi	r2,256
 908bd8c:	10bfffc4 	addi	r2,r2,-1
 908bd90:	1180af36 	bltu	r2,r6,908c050 <__umoddi3+0x550>
 908bd94:	01400404 	movi	r5,16
 908bd98:	2805883a 	mov	r2,r5
 908bd9c:	003fbe06 	br	908bc98 <__umoddi3+0x198>
 908bda0:	00804034 	movhi	r2,256
 908bda4:	10bfffc4 	addi	r2,r2,-1
 908bda8:	11c0ac36 	bltu	r2,r7,908c05c <__umoddi3+0x55c>
 908bdac:	01400404 	movi	r5,16
 908bdb0:	2805883a 	mov	r2,r5
 908bdb4:	003fa406 	br	908bc48 <__umoddi3+0x148>
 908bdb8:	b409c83a 	sub	r4,r22,r16
 908bdbc:	b105803a 	cmpltu	r2,r22,r4
 908bdc0:	a187c83a 	sub	r3,r20,r6
 908bdc4:	18a9c83a 	sub	r20,r3,r2
 908bdc8:	202d883a 	mov	r22,r4
 908bdcc:	003fa906 	br	908bc74 <__umoddi3+0x174>
 908bdd0:	85e0983a 	sll	r16,r16,r23
 908bdd4:	35c5c83a 	sub	r2,r6,r23
 908bdd8:	a0a2d83a 	srl	r17,r20,r2
 908bddc:	802ad43a 	srli	r21,r16,16
 908bde0:	b084d83a 	srl	r2,r22,r2
 908bde4:	a5c6983a 	sll	r3,r20,r23
 908bde8:	8809883a 	mov	r4,r17
 908bdec:	a80b883a 	mov	r5,r21
 908bdf0:	1886b03a 	or	r3,r3,r2
 908bdf4:	d8c00115 	stw	r3,4(sp)
 908bdf8:	853fffcc 	andi	r20,r16,65535
 908bdfc:	908d3080 	call	908d308 <__udivsi3>
 908be00:	8809883a 	mov	r4,r17
 908be04:	a80b883a 	mov	r5,r21
 908be08:	a0a3383a 	mul	r17,r20,r2
 908be0c:	908d3100 	call	908d310 <__umodsi3>
 908be10:	d9000117 	ldw	r4,4(sp)
 908be14:	1004943a 	slli	r2,r2,16
 908be18:	b839883a 	mov	fp,r23
 908be1c:	2006d43a 	srli	r3,r4,16
 908be20:	10c4b03a 	or	r2,r2,r3
 908be24:	1440022e 	bgeu	r2,r17,908be30 <__umoddi3+0x330>
 908be28:	1405883a 	add	r2,r2,r16
 908be2c:	1400962e 	bgeu	r2,r16,908c088 <__umoddi3+0x588>
 908be30:	1463c83a 	sub	r17,r2,r17
 908be34:	8809883a 	mov	r4,r17
 908be38:	a80b883a 	mov	r5,r21
 908be3c:	908d3080 	call	908d308 <__udivsi3>
 908be40:	8809883a 	mov	r4,r17
 908be44:	a80b883a 	mov	r5,r21
 908be48:	a0a3383a 	mul	r17,r20,r2
 908be4c:	908d3100 	call	908d310 <__umodsi3>
 908be50:	d9400117 	ldw	r5,4(sp)
 908be54:	1004943a 	slli	r2,r2,16
 908be58:	28ffffcc 	andi	r3,r5,65535
 908be5c:	10c4b03a 	or	r2,r2,r3
 908be60:	1440042e 	bgeu	r2,r17,908be74 <__umoddi3+0x374>
 908be64:	1405883a 	add	r2,r2,r16
 908be68:	14000236 	bltu	r2,r16,908be74 <__umoddi3+0x374>
 908be6c:	1440012e 	bgeu	r2,r17,908be74 <__umoddi3+0x374>
 908be70:	1405883a 	add	r2,r2,r16
 908be74:	b5ec983a 	sll	r22,r22,r23
 908be78:	1463c83a 	sub	r17,r2,r17
 908be7c:	003f4406 	br	908bb90 <__umoddi3+0x90>
 908be80:	3d4fc83a 	sub	r7,r7,r21
 908be84:	3546983a 	sll	r3,r6,r21
 908be88:	81c4d83a 	srl	r2,r16,r7
 908be8c:	a1e2d83a 	srl	r17,r20,r7
 908be90:	a54c983a 	sll	r6,r20,r21
 908be94:	18aeb03a 	or	r23,r3,r2
 908be98:	b828d43a 	srli	r20,r23,16
 908be9c:	b1c4d83a 	srl	r2,r22,r7
 908bea0:	8809883a 	mov	r4,r17
 908bea4:	a00b883a 	mov	r5,r20
 908bea8:	308cb03a 	or	r6,r6,r2
 908beac:	d9c00315 	stw	r7,12(sp)
 908beb0:	d9800215 	stw	r6,8(sp)
 908beb4:	908d3080 	call	908d308 <__udivsi3>
 908beb8:	8809883a 	mov	r4,r17
 908bebc:	a00b883a 	mov	r5,r20
 908bec0:	1039883a 	mov	fp,r2
 908bec4:	908d3100 	call	908d310 <__umodsi3>
 908bec8:	b8ffffcc 	andi	r3,r23,65535
 908becc:	d8c00415 	stw	r3,16(sp)
 908bed0:	d9000217 	ldw	r4,8(sp)
 908bed4:	d9400417 	ldw	r5,16(sp)
 908bed8:	1004943a 	slli	r2,r2,16
 908bedc:	2006d43a 	srli	r3,r4,16
 908bee0:	8560983a 	sll	r16,r16,r21
 908bee4:	2f23383a 	mul	r17,r5,fp
 908bee8:	10c4b03a 	or	r2,r2,r3
 908beec:	dc000015 	stw	r16,0(sp)
 908bef0:	b56c983a 	sll	r22,r22,r21
 908bef4:	1440032e 	bgeu	r2,r17,908bf04 <__umoddi3+0x404>
 908bef8:	15c5883a 	add	r2,r2,r23
 908befc:	e73fffc4 	addi	fp,fp,-1
 908bf00:	15c05d2e 	bgeu	r2,r23,908c078 <__umoddi3+0x578>
 908bf04:	1463c83a 	sub	r17,r2,r17
 908bf08:	8809883a 	mov	r4,r17
 908bf0c:	a00b883a 	mov	r5,r20
 908bf10:	908d3080 	call	908d308 <__udivsi3>
 908bf14:	8809883a 	mov	r4,r17
 908bf18:	a00b883a 	mov	r5,r20
 908bf1c:	1021883a 	mov	r16,r2
 908bf20:	908d3100 	call	908d310 <__umodsi3>
 908bf24:	d8c00417 	ldw	r3,16(sp)
 908bf28:	d9000217 	ldw	r4,8(sp)
 908bf2c:	1004943a 	slli	r2,r2,16
 908bf30:	1c23383a 	mul	r17,r3,r16
 908bf34:	20ffffcc 	andi	r3,r4,65535
 908bf38:	10ceb03a 	or	r7,r2,r3
 908bf3c:	3c40032e 	bgeu	r7,r17,908bf4c <__umoddi3+0x44c>
 908bf40:	3dcf883a 	add	r7,r7,r23
 908bf44:	843fffc4 	addi	r16,r16,-1
 908bf48:	3dc0472e 	bgeu	r7,r23,908c068 <__umoddi3+0x568>
 908bf4c:	e004943a 	slli	r2,fp,16
 908bf50:	d9400017 	ldw	r5,0(sp)
 908bf54:	3c4fc83a 	sub	r7,r7,r17
 908bf58:	8084b03a 	or	r2,r16,r2
 908bf5c:	28ffffcc 	andi	r3,r5,65535
 908bf60:	280cd43a 	srli	r6,r5,16
 908bf64:	100ad43a 	srli	r5,r2,16
 908bf68:	10bfffcc 	andi	r2,r2,65535
 908bf6c:	10d1383a 	mul	r8,r2,r3
 908bf70:	28c7383a 	mul	r3,r5,r3
 908bf74:	1185383a 	mul	r2,r2,r6
 908bf78:	4008d43a 	srli	r4,r8,16
 908bf7c:	298b383a 	mul	r5,r5,r6
 908bf80:	10c5883a 	add	r2,r2,r3
 908bf84:	2089883a 	add	r4,r4,r2
 908bf88:	20c0022e 	bgeu	r4,r3,908bf94 <__umoddi3+0x494>
 908bf8c:	00800074 	movhi	r2,1
 908bf90:	288b883a 	add	r5,r5,r2
 908bf94:	2004d43a 	srli	r2,r4,16
 908bf98:	2008943a 	slli	r4,r4,16
 908bf9c:	40ffffcc 	andi	r3,r8,65535
 908bfa0:	288b883a 	add	r5,r5,r2
 908bfa4:	20c9883a 	add	r4,r4,r3
 908bfa8:	39400b36 	bltu	r7,r5,908bfd8 <__umoddi3+0x4d8>
 908bfac:	39403d26 	beq	r7,r5,908c0a4 <__umoddi3+0x5a4>
 908bfb0:	394bc83a 	sub	r5,r7,r5
 908bfb4:	00000f06 	br	908bff4 <__umoddi3+0x4f4>
 908bfb8:	30c5c83a 	sub	r2,r6,r3
 908bfbc:	1839883a 	mov	fp,r3
 908bfc0:	b084d83a 	srl	r2,r22,r2
 908bfc4:	a0c6983a 	sll	r3,r20,r3
 908bfc8:	8720983a 	sll	r16,r16,fp
 908bfcc:	b72c983a 	sll	r22,r22,fp
 908bfd0:	18a8b03a 	or	r20,r3,r2
 908bfd4:	003f3a06 	br	908bcc0 <__umoddi3+0x1c0>
 908bfd8:	d8c00017 	ldw	r3,0(sp)
 908bfdc:	20c5c83a 	sub	r2,r4,r3
 908bfe0:	2089803a 	cmpltu	r4,r4,r2
 908bfe4:	2dc7c83a 	sub	r3,r5,r23
 908bfe8:	1907c83a 	sub	r3,r3,r4
 908bfec:	38cbc83a 	sub	r5,r7,r3
 908bff0:	1009883a 	mov	r4,r2
 908bff4:	b105c83a 	sub	r2,r22,r4
 908bff8:	b087803a 	cmpltu	r3,r22,r2
 908bffc:	28c7c83a 	sub	r3,r5,r3
 908c000:	d9400317 	ldw	r5,12(sp)
 908c004:	1544d83a 	srl	r2,r2,r21
 908c008:	1948983a 	sll	r4,r3,r5
 908c00c:	1d46d83a 	srl	r3,r3,r21
 908c010:	20a4b03a 	or	r18,r4,r2
 908c014:	9011883a 	mov	r8,r18
 908c018:	1813883a 	mov	r9,r3
 908c01c:	003ef606 	br	908bbf8 <__umoddi3+0xf8>
 908c020:	01400604 	movi	r5,24
 908c024:	2805883a 	mov	r2,r5
 908c028:	003ecc06 	br	908bb5c <__umoddi3+0x5c>
 908c02c:	01400204 	movi	r5,8
 908c030:	2805883a 	mov	r2,r5
 908c034:	003ec906 	br	908bb5c <__umoddi3+0x5c>
 908c038:	01400204 	movi	r5,8
 908c03c:	2805883a 	mov	r2,r5
 908c040:	003f0106 	br	908bc48 <__umoddi3+0x148>
 908c044:	01400204 	movi	r5,8
 908c048:	2805883a 	mov	r2,r5
 908c04c:	003f1206 	br	908bc98 <__umoddi3+0x198>
 908c050:	01400604 	movi	r5,24
 908c054:	2805883a 	mov	r2,r5
 908c058:	003f0f06 	br	908bc98 <__umoddi3+0x198>
 908c05c:	01400604 	movi	r5,24
 908c060:	2805883a 	mov	r2,r5
 908c064:	003ef806 	br	908bc48 <__umoddi3+0x148>
 908c068:	3c7fb82e 	bgeu	r7,r17,908bf4c <__umoddi3+0x44c>
 908c06c:	843fffc4 	addi	r16,r16,-1
 908c070:	3dcf883a 	add	r7,r7,r23
 908c074:	003fb506 	br	908bf4c <__umoddi3+0x44c>
 908c078:	147fa22e 	bgeu	r2,r17,908bf04 <__umoddi3+0x404>
 908c07c:	e73fffc4 	addi	fp,fp,-1
 908c080:	15c5883a 	add	r2,r2,r23
 908c084:	003f9f06 	br	908bf04 <__umoddi3+0x404>
 908c088:	147f692e 	bgeu	r2,r17,908be30 <__umoddi3+0x330>
 908c08c:	1405883a 	add	r2,r2,r16
 908c090:	003f6706 	br	908be30 <__umoddi3+0x330>
 908c094:	1405883a 	add	r2,r2,r16
 908c098:	003f1906 	br	908bd00 <__umoddi3+0x200>
 908c09c:	1405883a 	add	r2,r2,r16
 908c0a0:	003ec906 	br	908bbc8 <__umoddi3+0xc8>
 908c0a4:	b13fcc36 	bltu	r22,r4,908bfd8 <__umoddi3+0x4d8>
 908c0a8:	000b883a 	mov	r5,zero
 908c0ac:	003fd106 	br	908bff4 <__umoddi3+0x4f4>

0908c0b0 <_fpadd_parts>:
 908c0b0:	defff804 	addi	sp,sp,-32
 908c0b4:	dcc00315 	stw	r19,12(sp)
 908c0b8:	2027883a 	mov	r19,r4
 908c0bc:	21000017 	ldw	r4,0(r4)
 908c0c0:	00c00044 	movi	r3,1
 908c0c4:	dd400515 	stw	r21,20(sp)
 908c0c8:	dd000415 	stw	r20,16(sp)
 908c0cc:	ddc00715 	stw	r23,28(sp)
 908c0d0:	dd800615 	stw	r22,24(sp)
 908c0d4:	dc800215 	stw	r18,8(sp)
 908c0d8:	dc400115 	stw	r17,4(sp)
 908c0dc:	dc000015 	stw	r16,0(sp)
 908c0e0:	282b883a 	mov	r21,r5
 908c0e4:	3029883a 	mov	r20,r6
 908c0e8:	1900632e 	bgeu	r3,r4,908c278 <_fpadd_parts+0x1c8>
 908c0ec:	28800017 	ldw	r2,0(r5)
 908c0f0:	1880812e 	bgeu	r3,r2,908c2f8 <_fpadd_parts+0x248>
 908c0f4:	00c00104 	movi	r3,4
 908c0f8:	20c0dc26 	beq	r4,r3,908c46c <_fpadd_parts+0x3bc>
 908c0fc:	10c07e26 	beq	r2,r3,908c2f8 <_fpadd_parts+0x248>
 908c100:	00c00084 	movi	r3,2
 908c104:	10c06726 	beq	r2,r3,908c2a4 <_fpadd_parts+0x1f4>
 908c108:	20c07b26 	beq	r4,r3,908c2f8 <_fpadd_parts+0x248>
 908c10c:	9dc00217 	ldw	r23,8(r19)
 908c110:	28c00217 	ldw	r3,8(r5)
 908c114:	9c400317 	ldw	r17,12(r19)
 908c118:	2bc00317 	ldw	r15,12(r5)
 908c11c:	b8cdc83a 	sub	r6,r23,r3
 908c120:	9c800417 	ldw	r18,16(r19)
 908c124:	2c000417 	ldw	r16,16(r5)
 908c128:	3009883a 	mov	r4,r6
 908c12c:	30009716 	blt	r6,zero,908c38c <_fpadd_parts+0x2dc>
 908c130:	00800fc4 	movi	r2,63
 908c134:	11806b16 	blt	r2,r6,908c2e4 <_fpadd_parts+0x234>
 908c138:	0100a40e 	bge	zero,r4,908c3cc <_fpadd_parts+0x31c>
 908c13c:	35bff804 	addi	r22,r6,-32
 908c140:	b000bc16 	blt	r22,zero,908c434 <_fpadd_parts+0x384>
 908c144:	8596d83a 	srl	r11,r16,r22
 908c148:	0019883a 	mov	r12,zero
 908c14c:	0013883a 	mov	r9,zero
 908c150:	01000044 	movi	r4,1
 908c154:	0015883a 	mov	r10,zero
 908c158:	b000be16 	blt	r22,zero,908c454 <_fpadd_parts+0x3a4>
 908c15c:	2590983a 	sll	r8,r4,r22
 908c160:	000f883a 	mov	r7,zero
 908c164:	00bfffc4 	movi	r2,-1
 908c168:	3889883a 	add	r4,r7,r2
 908c16c:	408b883a 	add	r5,r8,r2
 908c170:	21cd803a 	cmpltu	r6,r4,r7
 908c174:	314b883a 	add	r5,r6,r5
 908c178:	7904703a 	and	r2,r15,r4
 908c17c:	8146703a 	and	r3,r16,r5
 908c180:	10c4b03a 	or	r2,r2,r3
 908c184:	10000226 	beq	r2,zero,908c190 <_fpadd_parts+0xe0>
 908c188:	02400044 	movi	r9,1
 908c18c:	0015883a 	mov	r10,zero
 908c190:	5a5eb03a 	or	r15,r11,r9
 908c194:	62a0b03a 	or	r16,r12,r10
 908c198:	99400117 	ldw	r5,4(r19)
 908c19c:	a8800117 	ldw	r2,4(r21)
 908c1a0:	28806e26 	beq	r5,r2,908c35c <_fpadd_parts+0x2ac>
 908c1a4:	28006626 	beq	r5,zero,908c340 <_fpadd_parts+0x290>
 908c1a8:	7c45c83a 	sub	r2,r15,r17
 908c1ac:	7889803a 	cmpltu	r4,r15,r2
 908c1b0:	8487c83a 	sub	r3,r16,r18
 908c1b4:	1909c83a 	sub	r4,r3,r4
 908c1b8:	100d883a 	mov	r6,r2
 908c1bc:	200f883a 	mov	r7,r4
 908c1c0:	38007716 	blt	r7,zero,908c3a0 <_fpadd_parts+0x2f0>
 908c1c4:	a5c00215 	stw	r23,8(r20)
 908c1c8:	a1c00415 	stw	r7,16(r20)
 908c1cc:	a0000115 	stw	zero,4(r20)
 908c1d0:	a1800315 	stw	r6,12(r20)
 908c1d4:	a2000317 	ldw	r8,12(r20)
 908c1d8:	a2400417 	ldw	r9,16(r20)
 908c1dc:	00bfffc4 	movi	r2,-1
 908c1e0:	408b883a 	add	r5,r8,r2
 908c1e4:	2a09803a 	cmpltu	r4,r5,r8
 908c1e8:	488d883a 	add	r6,r9,r2
 908c1ec:	01c40034 	movhi	r7,4096
 908c1f0:	39ffffc4 	addi	r7,r7,-1
 908c1f4:	218d883a 	add	r6,r4,r6
 908c1f8:	39801736 	bltu	r7,r6,908c258 <_fpadd_parts+0x1a8>
 908c1fc:	31c06526 	beq	r6,r7,908c394 <_fpadd_parts+0x2e4>
 908c200:	a3000217 	ldw	r12,8(r20)
 908c204:	4209883a 	add	r4,r8,r8
 908c208:	00bfffc4 	movi	r2,-1
 908c20c:	220f803a 	cmpltu	r7,r4,r8
 908c210:	4a4b883a 	add	r5,r9,r9
 908c214:	394f883a 	add	r7,r7,r5
 908c218:	2095883a 	add	r10,r4,r2
 908c21c:	3897883a 	add	r11,r7,r2
 908c220:	510d803a 	cmpltu	r6,r10,r4
 908c224:	6099883a 	add	r12,r12,r2
 908c228:	32d7883a 	add	r11,r6,r11
 908c22c:	00840034 	movhi	r2,4096
 908c230:	10bfffc4 	addi	r2,r2,-1
 908c234:	2011883a 	mov	r8,r4
 908c238:	3813883a 	mov	r9,r7
 908c23c:	a1000315 	stw	r4,12(r20)
 908c240:	a1c00415 	stw	r7,16(r20)
 908c244:	a3000215 	stw	r12,8(r20)
 908c248:	12c00336 	bltu	r2,r11,908c258 <_fpadd_parts+0x1a8>
 908c24c:	58bfed1e 	bne	r11,r2,908c204 <_fpadd_parts+0x154>
 908c250:	00bfff84 	movi	r2,-2
 908c254:	12bfeb2e 	bgeu	r2,r10,908c204 <_fpadd_parts+0x154>
 908c258:	a2800417 	ldw	r10,16(r20)
 908c25c:	008000c4 	movi	r2,3
 908c260:	00c80034 	movhi	r3,8192
 908c264:	18ffffc4 	addi	r3,r3,-1
 908c268:	a2400317 	ldw	r9,12(r20)
 908c26c:	a0800015 	stw	r2,0(r20)
 908c270:	1a802336 	bltu	r3,r10,908c300 <_fpadd_parts+0x250>
 908c274:	a027883a 	mov	r19,r20
 908c278:	9805883a 	mov	r2,r19
 908c27c:	ddc00717 	ldw	r23,28(sp)
 908c280:	dd800617 	ldw	r22,24(sp)
 908c284:	dd400517 	ldw	r21,20(sp)
 908c288:	dd000417 	ldw	r20,16(sp)
 908c28c:	dcc00317 	ldw	r19,12(sp)
 908c290:	dc800217 	ldw	r18,8(sp)
 908c294:	dc400117 	ldw	r17,4(sp)
 908c298:	dc000017 	ldw	r16,0(sp)
 908c29c:	dec00804 	addi	sp,sp,32
 908c2a0:	f800283a 	ret
 908c2a4:	20fff41e 	bne	r4,r3,908c278 <_fpadd_parts+0x1c8>
 908c2a8:	31000015 	stw	r4,0(r6)
 908c2ac:	98800117 	ldw	r2,4(r19)
 908c2b0:	30800115 	stw	r2,4(r6)
 908c2b4:	98c00217 	ldw	r3,8(r19)
 908c2b8:	30c00215 	stw	r3,8(r6)
 908c2bc:	98800317 	ldw	r2,12(r19)
 908c2c0:	30800315 	stw	r2,12(r6)
 908c2c4:	98c00417 	ldw	r3,16(r19)
 908c2c8:	30c00415 	stw	r3,16(r6)
 908c2cc:	98800117 	ldw	r2,4(r19)
 908c2d0:	28c00117 	ldw	r3,4(r5)
 908c2d4:	3027883a 	mov	r19,r6
 908c2d8:	10c4703a 	and	r2,r2,r3
 908c2dc:	30800115 	stw	r2,4(r6)
 908c2e0:	003fe506 	br	908c278 <_fpadd_parts+0x1c8>
 908c2e4:	1dc02616 	blt	r3,r23,908c380 <_fpadd_parts+0x2d0>
 908c2e8:	0023883a 	mov	r17,zero
 908c2ec:	182f883a 	mov	r23,r3
 908c2f0:	0025883a 	mov	r18,zero
 908c2f4:	003fa806 	br	908c198 <_fpadd_parts+0xe8>
 908c2f8:	a827883a 	mov	r19,r21
 908c2fc:	003fde06 	br	908c278 <_fpadd_parts+0x1c8>
 908c300:	01800044 	movi	r6,1
 908c304:	500497fa 	slli	r2,r10,31
 908c308:	4808d07a 	srli	r4,r9,1
 908c30c:	518ad83a 	srl	r5,r10,r6
 908c310:	a2000217 	ldw	r8,8(r20)
 908c314:	1108b03a 	or	r4,r2,r4
 908c318:	0007883a 	mov	r3,zero
 908c31c:	4984703a 	and	r2,r9,r6
 908c320:	208cb03a 	or	r6,r4,r2
 908c324:	28ceb03a 	or	r7,r5,r3
 908c328:	42000044 	addi	r8,r8,1
 908c32c:	a027883a 	mov	r19,r20
 908c330:	a1c00415 	stw	r7,16(r20)
 908c334:	a2000215 	stw	r8,8(r20)
 908c338:	a1800315 	stw	r6,12(r20)
 908c33c:	003fce06 	br	908c278 <_fpadd_parts+0x1c8>
 908c340:	8bc5c83a 	sub	r2,r17,r15
 908c344:	8889803a 	cmpltu	r4,r17,r2
 908c348:	9407c83a 	sub	r3,r18,r16
 908c34c:	1909c83a 	sub	r4,r3,r4
 908c350:	100d883a 	mov	r6,r2
 908c354:	200f883a 	mov	r7,r4
 908c358:	003f9906 	br	908c1c0 <_fpadd_parts+0x110>
 908c35c:	7c45883a 	add	r2,r15,r17
 908c360:	13c9803a 	cmpltu	r4,r2,r15
 908c364:	8487883a 	add	r3,r16,r18
 908c368:	20c9883a 	add	r4,r4,r3
 908c36c:	a1400115 	stw	r5,4(r20)
 908c370:	a5c00215 	stw	r23,8(r20)
 908c374:	a0800315 	stw	r2,12(r20)
 908c378:	a1000415 	stw	r4,16(r20)
 908c37c:	003fb606 	br	908c258 <_fpadd_parts+0x1a8>
 908c380:	001f883a 	mov	r15,zero
 908c384:	0021883a 	mov	r16,zero
 908c388:	003f8306 	br	908c198 <_fpadd_parts+0xe8>
 908c38c:	018dc83a 	sub	r6,zero,r6
 908c390:	003f6706 	br	908c130 <_fpadd_parts+0x80>
 908c394:	00bfff84 	movi	r2,-2
 908c398:	117faf36 	bltu	r2,r5,908c258 <_fpadd_parts+0x1a8>
 908c39c:	003f9806 	br	908c200 <_fpadd_parts+0x150>
 908c3a0:	0005883a 	mov	r2,zero
 908c3a4:	1189c83a 	sub	r4,r2,r6
 908c3a8:	1105803a 	cmpltu	r2,r2,r4
 908c3ac:	01cbc83a 	sub	r5,zero,r7
 908c3b0:	2885c83a 	sub	r2,r5,r2
 908c3b4:	01800044 	movi	r6,1
 908c3b8:	a1800115 	stw	r6,4(r20)
 908c3bc:	a5c00215 	stw	r23,8(r20)
 908c3c0:	a1000315 	stw	r4,12(r20)
 908c3c4:	a0800415 	stw	r2,16(r20)
 908c3c8:	003f8206 	br	908c1d4 <_fpadd_parts+0x124>
 908c3cc:	203f7226 	beq	r4,zero,908c198 <_fpadd_parts+0xe8>
 908c3d0:	35bff804 	addi	r22,r6,-32
 908c3d4:	b9af883a 	add	r23,r23,r6
 908c3d8:	b0003116 	blt	r22,zero,908c4a0 <_fpadd_parts+0x3f0>
 908c3dc:	959ad83a 	srl	r13,r18,r22
 908c3e0:	001d883a 	mov	r14,zero
 908c3e4:	000f883a 	mov	r7,zero
 908c3e8:	01000044 	movi	r4,1
 908c3ec:	0011883a 	mov	r8,zero
 908c3f0:	b0002516 	blt	r22,zero,908c488 <_fpadd_parts+0x3d8>
 908c3f4:	2594983a 	sll	r10,r4,r22
 908c3f8:	0013883a 	mov	r9,zero
 908c3fc:	00bfffc4 	movi	r2,-1
 908c400:	4889883a 	add	r4,r9,r2
 908c404:	508b883a 	add	r5,r10,r2
 908c408:	224d803a 	cmpltu	r6,r4,r9
 908c40c:	314b883a 	add	r5,r6,r5
 908c410:	8904703a 	and	r2,r17,r4
 908c414:	9146703a 	and	r3,r18,r5
 908c418:	10c4b03a 	or	r2,r2,r3
 908c41c:	10000226 	beq	r2,zero,908c428 <_fpadd_parts+0x378>
 908c420:	01c00044 	movi	r7,1
 908c424:	0011883a 	mov	r8,zero
 908c428:	69e2b03a 	or	r17,r13,r7
 908c42c:	7224b03a 	or	r18,r14,r8
 908c430:	003f5906 	br	908c198 <_fpadd_parts+0xe8>
 908c434:	8407883a 	add	r3,r16,r16
 908c438:	008007c4 	movi	r2,31
 908c43c:	1185c83a 	sub	r2,r2,r6
 908c440:	1886983a 	sll	r3,r3,r2
 908c444:	7996d83a 	srl	r11,r15,r6
 908c448:	8198d83a 	srl	r12,r16,r6
 908c44c:	1ad6b03a 	or	r11,r3,r11
 908c450:	003f3e06 	br	908c14c <_fpadd_parts+0x9c>
 908c454:	2006d07a 	srli	r3,r4,1
 908c458:	008007c4 	movi	r2,31
 908c45c:	1185c83a 	sub	r2,r2,r6
 908c460:	1890d83a 	srl	r8,r3,r2
 908c464:	218e983a 	sll	r7,r4,r6
 908c468:	003f3e06 	br	908c164 <_fpadd_parts+0xb4>
 908c46c:	113f821e 	bne	r2,r4,908c278 <_fpadd_parts+0x1c8>
 908c470:	28c00117 	ldw	r3,4(r5)
 908c474:	98800117 	ldw	r2,4(r19)
 908c478:	10ff7f26 	beq	r2,r3,908c278 <_fpadd_parts+0x1c8>
 908c47c:	04c24374 	movhi	r19,2317
 908c480:	9cf5c704 	addi	r19,r19,-10468
 908c484:	003f7c06 	br	908c278 <_fpadd_parts+0x1c8>
 908c488:	2006d07a 	srli	r3,r4,1
 908c48c:	008007c4 	movi	r2,31
 908c490:	1185c83a 	sub	r2,r2,r6
 908c494:	1894d83a 	srl	r10,r3,r2
 908c498:	2192983a 	sll	r9,r4,r6
 908c49c:	003fd706 	br	908c3fc <_fpadd_parts+0x34c>
 908c4a0:	9487883a 	add	r3,r18,r18
 908c4a4:	008007c4 	movi	r2,31
 908c4a8:	1185c83a 	sub	r2,r2,r6
 908c4ac:	1886983a 	sll	r3,r3,r2
 908c4b0:	899ad83a 	srl	r13,r17,r6
 908c4b4:	919cd83a 	srl	r14,r18,r6
 908c4b8:	1b5ab03a 	or	r13,r3,r13
 908c4bc:	003fc906 	br	908c3e4 <_fpadd_parts+0x334>

0908c4c0 <__subdf3>:
 908c4c0:	deffea04 	addi	sp,sp,-88
 908c4c4:	dcc01415 	stw	r19,80(sp)
 908c4c8:	dcc00404 	addi	r19,sp,16
 908c4cc:	2011883a 	mov	r8,r4
 908c4d0:	2813883a 	mov	r9,r5
 908c4d4:	dc401315 	stw	r17,76(sp)
 908c4d8:	d809883a 	mov	r4,sp
 908c4dc:	980b883a 	mov	r5,r19
 908c4e0:	dc400904 	addi	r17,sp,36
 908c4e4:	dfc01515 	stw	ra,84(sp)
 908c4e8:	da400115 	stw	r9,4(sp)
 908c4ec:	d9c00315 	stw	r7,12(sp)
 908c4f0:	da000015 	stw	r8,0(sp)
 908c4f4:	d9800215 	stw	r6,8(sp)
 908c4f8:	908d6ac0 	call	908d6ac <__unpack_d>
 908c4fc:	d9000204 	addi	r4,sp,8
 908c500:	880b883a 	mov	r5,r17
 908c504:	908d6ac0 	call	908d6ac <__unpack_d>
 908c508:	d8800a17 	ldw	r2,40(sp)
 908c50c:	880b883a 	mov	r5,r17
 908c510:	9809883a 	mov	r4,r19
 908c514:	d9800e04 	addi	r6,sp,56
 908c518:	1080005c 	xori	r2,r2,1
 908c51c:	d8800a15 	stw	r2,40(sp)
 908c520:	908c0b00 	call	908c0b0 <_fpadd_parts>
 908c524:	1009883a 	mov	r4,r2
 908c528:	908d3980 	call	908d398 <__pack_d>
 908c52c:	dfc01517 	ldw	ra,84(sp)
 908c530:	dcc01417 	ldw	r19,80(sp)
 908c534:	dc401317 	ldw	r17,76(sp)
 908c538:	dec01604 	addi	sp,sp,88
 908c53c:	f800283a 	ret

0908c540 <__adddf3>:
 908c540:	deffea04 	addi	sp,sp,-88
 908c544:	dcc01415 	stw	r19,80(sp)
 908c548:	dcc00404 	addi	r19,sp,16
 908c54c:	2011883a 	mov	r8,r4
 908c550:	2813883a 	mov	r9,r5
 908c554:	dc401315 	stw	r17,76(sp)
 908c558:	d809883a 	mov	r4,sp
 908c55c:	980b883a 	mov	r5,r19
 908c560:	dc400904 	addi	r17,sp,36
 908c564:	dfc01515 	stw	ra,84(sp)
 908c568:	da400115 	stw	r9,4(sp)
 908c56c:	d9c00315 	stw	r7,12(sp)
 908c570:	da000015 	stw	r8,0(sp)
 908c574:	d9800215 	stw	r6,8(sp)
 908c578:	908d6ac0 	call	908d6ac <__unpack_d>
 908c57c:	d9000204 	addi	r4,sp,8
 908c580:	880b883a 	mov	r5,r17
 908c584:	908d6ac0 	call	908d6ac <__unpack_d>
 908c588:	d9800e04 	addi	r6,sp,56
 908c58c:	9809883a 	mov	r4,r19
 908c590:	880b883a 	mov	r5,r17
 908c594:	908c0b00 	call	908c0b0 <_fpadd_parts>
 908c598:	1009883a 	mov	r4,r2
 908c59c:	908d3980 	call	908d398 <__pack_d>
 908c5a0:	dfc01517 	ldw	ra,84(sp)
 908c5a4:	dcc01417 	ldw	r19,80(sp)
 908c5a8:	dc401317 	ldw	r17,76(sp)
 908c5ac:	dec01604 	addi	sp,sp,88
 908c5b0:	f800283a 	ret

0908c5b4 <__muldf3>:
 908c5b4:	deffdd04 	addi	sp,sp,-140
 908c5b8:	df002115 	stw	fp,132(sp)
 908c5bc:	df000404 	addi	fp,sp,16
 908c5c0:	2011883a 	mov	r8,r4
 908c5c4:	2813883a 	mov	r9,r5
 908c5c8:	d809883a 	mov	r4,sp
 908c5cc:	e00b883a 	mov	r5,fp
 908c5d0:	dfc02215 	stw	ra,136(sp)
 908c5d4:	da400115 	stw	r9,4(sp)
 908c5d8:	d9c00315 	stw	r7,12(sp)
 908c5dc:	da000015 	stw	r8,0(sp)
 908c5e0:	d9800215 	stw	r6,8(sp)
 908c5e4:	ddc02015 	stw	r23,128(sp)
 908c5e8:	dd801f15 	stw	r22,124(sp)
 908c5ec:	dd401e15 	stw	r21,120(sp)
 908c5f0:	dd001d15 	stw	r20,116(sp)
 908c5f4:	dcc01c15 	stw	r19,112(sp)
 908c5f8:	dc801b15 	stw	r18,108(sp)
 908c5fc:	dc401a15 	stw	r17,104(sp)
 908c600:	dc001915 	stw	r16,100(sp)
 908c604:	908d6ac0 	call	908d6ac <__unpack_d>
 908c608:	d9000204 	addi	r4,sp,8
 908c60c:	d9400904 	addi	r5,sp,36
 908c610:	908d6ac0 	call	908d6ac <__unpack_d>
 908c614:	d9000417 	ldw	r4,16(sp)
 908c618:	00800044 	movi	r2,1
 908c61c:	1100102e 	bgeu	r2,r4,908c660 <__muldf3+0xac>
 908c620:	d8c00917 	ldw	r3,36(sp)
 908c624:	10c0062e 	bgeu	r2,r3,908c640 <__muldf3+0x8c>
 908c628:	00800104 	movi	r2,4
 908c62c:	20800a26 	beq	r4,r2,908c658 <__muldf3+0xa4>
 908c630:	1880c826 	beq	r3,r2,908c954 <__muldf3+0x3a0>
 908c634:	00800084 	movi	r2,2
 908c638:	20800926 	beq	r4,r2,908c660 <__muldf3+0xac>
 908c63c:	18801a1e 	bne	r3,r2,908c6a8 <__muldf3+0xf4>
 908c640:	d8c00a17 	ldw	r3,40(sp)
 908c644:	d8800517 	ldw	r2,20(sp)
 908c648:	d9000904 	addi	r4,sp,36
 908c64c:	10c4c03a 	cmpne	r2,r2,r3
 908c650:	d8800a15 	stw	r2,40(sp)
 908c654:	00000706 	br	908c674 <__muldf3+0xc0>
 908c658:	00800084 	movi	r2,2
 908c65c:	1880bf26 	beq	r3,r2,908c95c <__muldf3+0x3a8>
 908c660:	d8800517 	ldw	r2,20(sp)
 908c664:	d8c00a17 	ldw	r3,40(sp)
 908c668:	e009883a 	mov	r4,fp
 908c66c:	10c4c03a 	cmpne	r2,r2,r3
 908c670:	d8800515 	stw	r2,20(sp)
 908c674:	908d3980 	call	908d398 <__pack_d>
 908c678:	dfc02217 	ldw	ra,136(sp)
 908c67c:	df002117 	ldw	fp,132(sp)
 908c680:	ddc02017 	ldw	r23,128(sp)
 908c684:	dd801f17 	ldw	r22,124(sp)
 908c688:	dd401e17 	ldw	r21,120(sp)
 908c68c:	dd001d17 	ldw	r20,116(sp)
 908c690:	dcc01c17 	ldw	r19,112(sp)
 908c694:	dc801b17 	ldw	r18,108(sp)
 908c698:	dc401a17 	ldw	r17,104(sp)
 908c69c:	dc001917 	ldw	r16,100(sp)
 908c6a0:	dec02304 	addi	sp,sp,140
 908c6a4:	f800283a 	ret
 908c6a8:	db000c17 	ldw	r12,48(sp)
 908c6ac:	db800717 	ldw	r14,28(sp)
 908c6b0:	dbc00817 	ldw	r15,32(sp)
 908c6b4:	db400d17 	ldw	r13,52(sp)
 908c6b8:	6009883a 	mov	r4,r12
 908c6bc:	000d883a 	mov	r6,zero
 908c6c0:	0011883a 	mov	r8,zero
 908c6c4:	000b883a 	mov	r5,zero
 908c6c8:	0007883a 	mov	r3,zero
 908c6cc:	0019883a 	mov	r12,zero
 908c6d0:	4393383a 	mul	r9,r8,r14
 908c6d4:	d9801415 	stw	r6,80(sp)
 908c6d8:	6111383a 	mul	r8,r12,r4
 908c6dc:	d9801615 	stw	r6,88(sp)
 908c6e0:	1b4f383a 	mul	r7,r3,r13
 908c6e4:	2bcd383a 	mul	r6,r5,r15
 908c6e8:	7361383a 	mul	r16,r14,r13
 908c6ec:	23e5383a 	mul	r18,r4,r15
 908c6f0:	7362383a 	mulxuu	r17,r14,r13
 908c6f4:	23e6383a 	mulxuu	r19,r4,r15
 908c6f8:	3a4f883a 	add	r7,r7,r9
 908c6fc:	320d883a 	add	r6,r6,r8
 908c700:	3c63883a 	add	r17,r7,r17
 908c704:	34e7883a 	add	r19,r6,r19
 908c708:	8495883a 	add	r10,r16,r18
 908c70c:	23aa383a 	mulxuu	r21,r4,r14
 908c710:	540f803a 	cmpltu	r7,r10,r16
 908c714:	8cd7883a 	add	r11,r17,r19
 908c718:	3acf883a 	add	r7,r7,r11
 908c71c:	4a0d883a 	add	r6,r9,r8
 908c720:	db401315 	stw	r13,76(sp)
 908c724:	dbc01515 	stw	r15,84(sp)
 908c728:	23a9383a 	mul	r20,r4,r14
 908c72c:	da801715 	stw	r10,92(sp)
 908c730:	d9c01815 	stw	r7,96(sp)
 908c734:	356b883a 	add	r21,r6,r21
 908c738:	3c40682e 	bgeu	r7,r17,908c8dc <__muldf3+0x328>
 908c73c:	000f883a 	mov	r7,zero
 908c740:	02000044 	movi	r8,1
 908c744:	d9401717 	ldw	r5,92(sp)
 908c748:	0009883a 	mov	r4,zero
 908c74c:	a105883a 	add	r2,r20,r4
 908c750:	150d803a 	cmpltu	r6,r2,r20
 908c754:	a947883a 	add	r3,r21,r5
 908c758:	30cd883a 	add	r6,r6,r3
 908c75c:	101f883a 	mov	r15,r2
 908c760:	3021883a 	mov	r16,r6
 908c764:	35406236 	bltu	r6,r21,908c8f0 <__muldf3+0x33c>
 908c768:	a9806026 	beq	r21,r6,908c8ec <__muldf3+0x338>
 908c76c:	d9801317 	ldw	r6,76(sp)
 908c770:	db001517 	ldw	r12,84(sp)
 908c774:	d8c01417 	ldw	r3,80(sp)
 908c778:	d9401617 	ldw	r5,88(sp)
 908c77c:	6009883a 	mov	r4,r12
 908c780:	1b05383a 	mul	r2,r3,r12
 908c784:	2987383a 	mul	r3,r5,r6
 908c788:	332d383a 	mul	r22,r6,r12
 908c78c:	312e383a 	mulxuu	r23,r6,r4
 908c790:	d9801817 	ldw	r6,96(sp)
 908c794:	10c5883a 	add	r2,r2,r3
 908c798:	15ef883a 	add	r23,r2,r23
 908c79c:	000b883a 	mov	r5,zero
 908c7a0:	b185883a 	add	r2,r22,r6
 908c7a4:	158d803a 	cmpltu	r6,r2,r22
 908c7a8:	b947883a 	add	r3,r23,r5
 908c7ac:	30c7883a 	add	r3,r6,r3
 908c7b0:	40cb883a 	add	r5,r8,r3
 908c7b4:	d8c00617 	ldw	r3,24(sp)
 908c7b8:	3889883a 	add	r4,r7,r2
 908c7bc:	d8800b17 	ldw	r2,44(sp)
 908c7c0:	18c00104 	addi	r3,r3,4
 908c7c4:	21cd803a 	cmpltu	r6,r4,r7
 908c7c8:	10c7883a 	add	r3,r2,r3
 908c7cc:	2013883a 	mov	r9,r4
 908c7d0:	d8800a17 	ldw	r2,40(sp)
 908c7d4:	d9000517 	ldw	r4,20(sp)
 908c7d8:	314d883a 	add	r6,r6,r5
 908c7dc:	3015883a 	mov	r10,r6
 908c7e0:	2088c03a 	cmpne	r4,r4,r2
 908c7e4:	00880034 	movhi	r2,8192
 908c7e8:	10bfffc4 	addi	r2,r2,-1
 908c7ec:	d9000f15 	stw	r4,60(sp)
 908c7f0:	d8c01015 	stw	r3,64(sp)
 908c7f4:	1180162e 	bgeu	r2,r6,908c850 <__muldf3+0x29c>
 908c7f8:	1811883a 	mov	r8,r3
 908c7fc:	1023883a 	mov	r17,r2
 908c800:	800497fa 	slli	r2,r16,31
 908c804:	7816d07a 	srli	r11,r15,1
 908c808:	500697fa 	slli	r3,r10,31
 908c80c:	480cd07a 	srli	r6,r9,1
 908c810:	500ed07a 	srli	r7,r10,1
 908c814:	12d6b03a 	or	r11,r2,r11
 908c818:	00800044 	movi	r2,1
 908c81c:	198cb03a 	or	r6,r3,r6
 908c820:	4888703a 	and	r4,r9,r2
 908c824:	8018d07a 	srli	r12,r16,1
 908c828:	001b883a 	mov	r13,zero
 908c82c:	03a00034 	movhi	r14,32768
 908c830:	3013883a 	mov	r9,r6
 908c834:	3815883a 	mov	r10,r7
 908c838:	4091883a 	add	r8,r8,r2
 908c83c:	20000226 	beq	r4,zero,908c848 <__muldf3+0x294>
 908c840:	5b5eb03a 	or	r15,r11,r13
 908c844:	63a0b03a 	or	r16,r12,r14
 908c848:	8abfed36 	bltu	r17,r10,908c800 <__muldf3+0x24c>
 908c84c:	da001015 	stw	r8,64(sp)
 908c850:	00840034 	movhi	r2,4096
 908c854:	10bfffc4 	addi	r2,r2,-1
 908c858:	12801436 	bltu	r2,r10,908c8ac <__muldf3+0x2f8>
 908c85c:	da001017 	ldw	r8,64(sp)
 908c860:	1023883a 	mov	r17,r2
 908c864:	4a45883a 	add	r2,r9,r9
 908c868:	124d803a 	cmpltu	r6,r2,r9
 908c86c:	5287883a 	add	r3,r10,r10
 908c870:	7bd7883a 	add	r11,r15,r15
 908c874:	5bcf803a 	cmpltu	r7,r11,r15
 908c878:	8419883a 	add	r12,r16,r16
 908c87c:	01000044 	movi	r4,1
 908c880:	30cd883a 	add	r6,r6,r3
 908c884:	3b0f883a 	add	r7,r7,r12
 908c888:	423fffc4 	addi	r8,r8,-1
 908c88c:	1013883a 	mov	r9,r2
 908c890:	3015883a 	mov	r10,r6
 908c894:	111ab03a 	or	r13,r2,r4
 908c898:	80002a16 	blt	r16,zero,908c944 <__muldf3+0x390>
 908c89c:	581f883a 	mov	r15,r11
 908c8a0:	3821883a 	mov	r16,r7
 908c8a4:	8abfef2e 	bgeu	r17,r10,908c864 <__muldf3+0x2b0>
 908c8a8:	da001015 	stw	r8,64(sp)
 908c8ac:	00803fc4 	movi	r2,255
 908c8b0:	488e703a 	and	r7,r9,r2
 908c8b4:	00802004 	movi	r2,128
 908c8b8:	0007883a 	mov	r3,zero
 908c8bc:	0011883a 	mov	r8,zero
 908c8c0:	38801226 	beq	r7,r2,908c90c <__muldf3+0x358>
 908c8c4:	008000c4 	movi	r2,3
 908c8c8:	d9000e04 	addi	r4,sp,56
 908c8cc:	da801215 	stw	r10,72(sp)
 908c8d0:	d8800e15 	stw	r2,56(sp)
 908c8d4:	da401115 	stw	r9,68(sp)
 908c8d8:	003f6606 	br	908c674 <__muldf3+0xc0>
 908c8dc:	89c01b26 	beq	r17,r7,908c94c <__muldf3+0x398>
 908c8e0:	000f883a 	mov	r7,zero
 908c8e4:	0011883a 	mov	r8,zero
 908c8e8:	003f9606 	br	908c744 <__muldf3+0x190>
 908c8ec:	153f9f2e 	bgeu	r2,r20,908c76c <__muldf3+0x1b8>
 908c8f0:	00800044 	movi	r2,1
 908c8f4:	3889883a 	add	r4,r7,r2
 908c8f8:	21cd803a 	cmpltu	r6,r4,r7
 908c8fc:	320d883a 	add	r6,r6,r8
 908c900:	200f883a 	mov	r7,r4
 908c904:	3011883a 	mov	r8,r6
 908c908:	003f9806 	br	908c76c <__muldf3+0x1b8>
 908c90c:	403fed1e 	bne	r8,zero,908c8c4 <__muldf3+0x310>
 908c910:	01004004 	movi	r4,256
 908c914:	4904703a 	and	r2,r9,r4
 908c918:	10c4b03a 	or	r2,r2,r3
 908c91c:	103fe91e 	bne	r2,zero,908c8c4 <__muldf3+0x310>
 908c920:	7c04b03a 	or	r2,r15,r16
 908c924:	103fe726 	beq	r2,zero,908c8c4 <__muldf3+0x310>
 908c928:	49c5883a 	add	r2,r9,r7
 908c92c:	1251803a 	cmpltu	r8,r2,r9
 908c930:	4291883a 	add	r8,r8,r10
 908c934:	013fc004 	movi	r4,-256
 908c938:	1112703a 	and	r9,r2,r4
 908c93c:	4015883a 	mov	r10,r8
 908c940:	003fe006 	br	908c8c4 <__muldf3+0x310>
 908c944:	6813883a 	mov	r9,r13
 908c948:	003fd406 	br	908c89c <__muldf3+0x2e8>
 908c94c:	543f7b36 	bltu	r10,r16,908c73c <__muldf3+0x188>
 908c950:	003fe306 	br	908c8e0 <__muldf3+0x32c>
 908c954:	00800084 	movi	r2,2
 908c958:	20bf391e 	bne	r4,r2,908c640 <__muldf3+0x8c>
 908c95c:	01024374 	movhi	r4,2317
 908c960:	2135c704 	addi	r4,r4,-10468
 908c964:	003f4306 	br	908c674 <__muldf3+0xc0>

0908c968 <__divdf3>:
 908c968:	deffed04 	addi	sp,sp,-76
 908c96c:	dcc01115 	stw	r19,68(sp)
 908c970:	dcc00404 	addi	r19,sp,16
 908c974:	2011883a 	mov	r8,r4
 908c978:	2813883a 	mov	r9,r5
 908c97c:	dc000e15 	stw	r16,56(sp)
 908c980:	d809883a 	mov	r4,sp
 908c984:	980b883a 	mov	r5,r19
 908c988:	dc000904 	addi	r16,sp,36
 908c98c:	dfc01215 	stw	ra,72(sp)
 908c990:	da400115 	stw	r9,4(sp)
 908c994:	d9c00315 	stw	r7,12(sp)
 908c998:	da000015 	stw	r8,0(sp)
 908c99c:	d9800215 	stw	r6,8(sp)
 908c9a0:	dc801015 	stw	r18,64(sp)
 908c9a4:	dc400f15 	stw	r17,60(sp)
 908c9a8:	908d6ac0 	call	908d6ac <__unpack_d>
 908c9ac:	d9000204 	addi	r4,sp,8
 908c9b0:	800b883a 	mov	r5,r16
 908c9b4:	908d6ac0 	call	908d6ac <__unpack_d>
 908c9b8:	d9000417 	ldw	r4,16(sp)
 908c9bc:	00800044 	movi	r2,1
 908c9c0:	11000b2e 	bgeu	r2,r4,908c9f0 <__divdf3+0x88>
 908c9c4:	d9400917 	ldw	r5,36(sp)
 908c9c8:	1140762e 	bgeu	r2,r5,908cba4 <__divdf3+0x23c>
 908c9cc:	d8800517 	ldw	r2,20(sp)
 908c9d0:	d8c00a17 	ldw	r3,40(sp)
 908c9d4:	01800104 	movi	r6,4
 908c9d8:	10c4f03a 	xor	r2,r2,r3
 908c9dc:	d8800515 	stw	r2,20(sp)
 908c9e0:	21800226 	beq	r4,r6,908c9ec <__divdf3+0x84>
 908c9e4:	00800084 	movi	r2,2
 908c9e8:	2080141e 	bne	r4,r2,908ca3c <__divdf3+0xd4>
 908c9ec:	29000926 	beq	r5,r4,908ca14 <__divdf3+0xac>
 908c9f0:	9809883a 	mov	r4,r19
 908c9f4:	908d3980 	call	908d398 <__pack_d>
 908c9f8:	dfc01217 	ldw	ra,72(sp)
 908c9fc:	dcc01117 	ldw	r19,68(sp)
 908ca00:	dc801017 	ldw	r18,64(sp)
 908ca04:	dc400f17 	ldw	r17,60(sp)
 908ca08:	dc000e17 	ldw	r16,56(sp)
 908ca0c:	dec01304 	addi	sp,sp,76
 908ca10:	f800283a 	ret
 908ca14:	01024374 	movhi	r4,2317
 908ca18:	2135c704 	addi	r4,r4,-10468
 908ca1c:	908d3980 	call	908d398 <__pack_d>
 908ca20:	dfc01217 	ldw	ra,72(sp)
 908ca24:	dcc01117 	ldw	r19,68(sp)
 908ca28:	dc801017 	ldw	r18,64(sp)
 908ca2c:	dc400f17 	ldw	r17,60(sp)
 908ca30:	dc000e17 	ldw	r16,56(sp)
 908ca34:	dec01304 	addi	sp,sp,76
 908ca38:	f800283a 	ret
 908ca3c:	29805b26 	beq	r5,r6,908cbac <__divdf3+0x244>
 908ca40:	28802d26 	beq	r5,r2,908caf8 <__divdf3+0x190>
 908ca44:	d8c00617 	ldw	r3,24(sp)
 908ca48:	d8800b17 	ldw	r2,44(sp)
 908ca4c:	d9c00817 	ldw	r7,32(sp)
 908ca50:	dc400d17 	ldw	r17,52(sp)
 908ca54:	188bc83a 	sub	r5,r3,r2
 908ca58:	d9800717 	ldw	r6,28(sp)
 908ca5c:	dc000c17 	ldw	r16,48(sp)
 908ca60:	d9400615 	stw	r5,24(sp)
 908ca64:	3c403836 	bltu	r7,r17,908cb48 <__divdf3+0x1e0>
 908ca68:	89c03626 	beq	r17,r7,908cb44 <__divdf3+0x1dc>
 908ca6c:	0015883a 	mov	r10,zero
 908ca70:	001d883a 	mov	r14,zero
 908ca74:	02c40034 	movhi	r11,4096
 908ca78:	001f883a 	mov	r15,zero
 908ca7c:	003f883a 	mov	ra,zero
 908ca80:	04800f44 	movi	r18,61
 908ca84:	00000f06 	br	908cac4 <__divdf3+0x15c>
 908ca88:	601d883a 	mov	r14,r12
 908ca8c:	681f883a 	mov	r15,r13
 908ca90:	400d883a 	mov	r6,r8
 908ca94:	100f883a 	mov	r7,r2
 908ca98:	3191883a 	add	r8,r6,r6
 908ca9c:	5808d07a 	srli	r4,r11,1
 908caa0:	4185803a 	cmpltu	r2,r8,r6
 908caa4:	39d3883a 	add	r9,r7,r7
 908caa8:	28c6b03a 	or	r3,r5,r3
 908caac:	1245883a 	add	r2,r2,r9
 908cab0:	1815883a 	mov	r10,r3
 908cab4:	2017883a 	mov	r11,r4
 908cab8:	400d883a 	mov	r6,r8
 908cabc:	100f883a 	mov	r7,r2
 908cac0:	fc801726 	beq	ra,r18,908cb20 <__divdf3+0x1b8>
 908cac4:	580a97fa 	slli	r5,r11,31
 908cac8:	5006d07a 	srli	r3,r10,1
 908cacc:	ffc00044 	addi	ra,ra,1
 908cad0:	3c7ff136 	bltu	r7,r17,908ca98 <__divdf3+0x130>
 908cad4:	3411c83a 	sub	r8,r6,r16
 908cad8:	3205803a 	cmpltu	r2,r6,r8
 908cadc:	3c53c83a 	sub	r9,r7,r17
 908cae0:	7298b03a 	or	r12,r14,r10
 908cae4:	7adab03a 	or	r13,r15,r11
 908cae8:	4885c83a 	sub	r2,r9,r2
 908caec:	89ffe61e 	bne	r17,r7,908ca88 <__divdf3+0x120>
 908caf0:	343fe936 	bltu	r6,r16,908ca98 <__divdf3+0x130>
 908caf4:	003fe406 	br	908ca88 <__divdf3+0x120>
 908caf8:	9809883a 	mov	r4,r19
 908cafc:	d9800415 	stw	r6,16(sp)
 908cb00:	908d3980 	call	908d398 <__pack_d>
 908cb04:	dfc01217 	ldw	ra,72(sp)
 908cb08:	dcc01117 	ldw	r19,68(sp)
 908cb0c:	dc801017 	ldw	r18,64(sp)
 908cb10:	dc400f17 	ldw	r17,60(sp)
 908cb14:	dc000e17 	ldw	r16,56(sp)
 908cb18:	dec01304 	addi	sp,sp,76
 908cb1c:	f800283a 	ret
 908cb20:	00803fc4 	movi	r2,255
 908cb24:	7090703a 	and	r8,r14,r2
 908cb28:	00802004 	movi	r2,128
 908cb2c:	0007883a 	mov	r3,zero
 908cb30:	0013883a 	mov	r9,zero
 908cb34:	40800d26 	beq	r8,r2,908cb6c <__divdf3+0x204>
 908cb38:	dbc00815 	stw	r15,32(sp)
 908cb3c:	db800715 	stw	r14,28(sp)
 908cb40:	003fab06 	br	908c9f0 <__divdf3+0x88>
 908cb44:	343fc92e 	bgeu	r6,r16,908ca6c <__divdf3+0x104>
 908cb48:	3185883a 	add	r2,r6,r6
 908cb4c:	1189803a 	cmpltu	r4,r2,r6
 908cb50:	39c7883a 	add	r3,r7,r7
 908cb54:	20c9883a 	add	r4,r4,r3
 908cb58:	297fffc4 	addi	r5,r5,-1
 908cb5c:	100d883a 	mov	r6,r2
 908cb60:	200f883a 	mov	r7,r4
 908cb64:	d9400615 	stw	r5,24(sp)
 908cb68:	003fc006 	br	908ca6c <__divdf3+0x104>
 908cb6c:	483ff21e 	bne	r9,zero,908cb38 <__divdf3+0x1d0>
 908cb70:	01004004 	movi	r4,256
 908cb74:	7104703a 	and	r2,r14,r4
 908cb78:	10c4b03a 	or	r2,r2,r3
 908cb7c:	103fee1e 	bne	r2,zero,908cb38 <__divdf3+0x1d0>
 908cb80:	31c4b03a 	or	r2,r6,r7
 908cb84:	103fec26 	beq	r2,zero,908cb38 <__divdf3+0x1d0>
 908cb88:	7205883a 	add	r2,r14,r8
 908cb8c:	1391803a 	cmpltu	r8,r2,r14
 908cb90:	43d1883a 	add	r8,r8,r15
 908cb94:	013fc004 	movi	r4,-256
 908cb98:	111c703a 	and	r14,r2,r4
 908cb9c:	401f883a 	mov	r15,r8
 908cba0:	003fe506 	br	908cb38 <__divdf3+0x1d0>
 908cba4:	8009883a 	mov	r4,r16
 908cba8:	003f9206 	br	908c9f4 <__divdf3+0x8c>
 908cbac:	9809883a 	mov	r4,r19
 908cbb0:	d8000715 	stw	zero,28(sp)
 908cbb4:	d8000815 	stw	zero,32(sp)
 908cbb8:	d8000615 	stw	zero,24(sp)
 908cbbc:	003f8d06 	br	908c9f4 <__divdf3+0x8c>

0908cbc0 <__eqdf2>:
 908cbc0:	deffef04 	addi	sp,sp,-68
 908cbc4:	dc400f15 	stw	r17,60(sp)
 908cbc8:	dc400404 	addi	r17,sp,16
 908cbcc:	2005883a 	mov	r2,r4
 908cbd0:	2807883a 	mov	r3,r5
 908cbd4:	dc000e15 	stw	r16,56(sp)
 908cbd8:	d809883a 	mov	r4,sp
 908cbdc:	880b883a 	mov	r5,r17
 908cbe0:	dc000904 	addi	r16,sp,36
 908cbe4:	d8c00115 	stw	r3,4(sp)
 908cbe8:	d8800015 	stw	r2,0(sp)
 908cbec:	d9800215 	stw	r6,8(sp)
 908cbf0:	dfc01015 	stw	ra,64(sp)
 908cbf4:	d9c00315 	stw	r7,12(sp)
 908cbf8:	908d6ac0 	call	908d6ac <__unpack_d>
 908cbfc:	d9000204 	addi	r4,sp,8
 908cc00:	800b883a 	mov	r5,r16
 908cc04:	908d6ac0 	call	908d6ac <__unpack_d>
 908cc08:	d8800417 	ldw	r2,16(sp)
 908cc0c:	00c00044 	movi	r3,1
 908cc10:	180d883a 	mov	r6,r3
 908cc14:	1880062e 	bgeu	r3,r2,908cc30 <__eqdf2+0x70>
 908cc18:	d8800917 	ldw	r2,36(sp)
 908cc1c:	8809883a 	mov	r4,r17
 908cc20:	800b883a 	mov	r5,r16
 908cc24:	1880022e 	bgeu	r3,r2,908cc30 <__eqdf2+0x70>
 908cc28:	908d7e40 	call	908d7e4 <__fpcmp_parts_d>
 908cc2c:	100d883a 	mov	r6,r2
 908cc30:	3005883a 	mov	r2,r6
 908cc34:	dfc01017 	ldw	ra,64(sp)
 908cc38:	dc400f17 	ldw	r17,60(sp)
 908cc3c:	dc000e17 	ldw	r16,56(sp)
 908cc40:	dec01104 	addi	sp,sp,68
 908cc44:	f800283a 	ret

0908cc48 <__nedf2>:
 908cc48:	deffef04 	addi	sp,sp,-68
 908cc4c:	dc400f15 	stw	r17,60(sp)
 908cc50:	dc400404 	addi	r17,sp,16
 908cc54:	2005883a 	mov	r2,r4
 908cc58:	2807883a 	mov	r3,r5
 908cc5c:	dc000e15 	stw	r16,56(sp)
 908cc60:	d809883a 	mov	r4,sp
 908cc64:	880b883a 	mov	r5,r17
 908cc68:	dc000904 	addi	r16,sp,36
 908cc6c:	d8c00115 	stw	r3,4(sp)
 908cc70:	d8800015 	stw	r2,0(sp)
 908cc74:	d9800215 	stw	r6,8(sp)
 908cc78:	dfc01015 	stw	ra,64(sp)
 908cc7c:	d9c00315 	stw	r7,12(sp)
 908cc80:	908d6ac0 	call	908d6ac <__unpack_d>
 908cc84:	d9000204 	addi	r4,sp,8
 908cc88:	800b883a 	mov	r5,r16
 908cc8c:	908d6ac0 	call	908d6ac <__unpack_d>
 908cc90:	d8800417 	ldw	r2,16(sp)
 908cc94:	00c00044 	movi	r3,1
 908cc98:	180d883a 	mov	r6,r3
 908cc9c:	1880062e 	bgeu	r3,r2,908ccb8 <__nedf2+0x70>
 908cca0:	d8800917 	ldw	r2,36(sp)
 908cca4:	8809883a 	mov	r4,r17
 908cca8:	800b883a 	mov	r5,r16
 908ccac:	1880022e 	bgeu	r3,r2,908ccb8 <__nedf2+0x70>
 908ccb0:	908d7e40 	call	908d7e4 <__fpcmp_parts_d>
 908ccb4:	100d883a 	mov	r6,r2
 908ccb8:	3005883a 	mov	r2,r6
 908ccbc:	dfc01017 	ldw	ra,64(sp)
 908ccc0:	dc400f17 	ldw	r17,60(sp)
 908ccc4:	dc000e17 	ldw	r16,56(sp)
 908ccc8:	dec01104 	addi	sp,sp,68
 908cccc:	f800283a 	ret

0908ccd0 <__gtdf2>:
 908ccd0:	deffef04 	addi	sp,sp,-68
 908ccd4:	dc400f15 	stw	r17,60(sp)
 908ccd8:	dc400404 	addi	r17,sp,16
 908ccdc:	2005883a 	mov	r2,r4
 908cce0:	2807883a 	mov	r3,r5
 908cce4:	dc000e15 	stw	r16,56(sp)
 908cce8:	d809883a 	mov	r4,sp
 908ccec:	880b883a 	mov	r5,r17
 908ccf0:	dc000904 	addi	r16,sp,36
 908ccf4:	d8c00115 	stw	r3,4(sp)
 908ccf8:	d8800015 	stw	r2,0(sp)
 908ccfc:	d9800215 	stw	r6,8(sp)
 908cd00:	dfc01015 	stw	ra,64(sp)
 908cd04:	d9c00315 	stw	r7,12(sp)
 908cd08:	908d6ac0 	call	908d6ac <__unpack_d>
 908cd0c:	d9000204 	addi	r4,sp,8
 908cd10:	800b883a 	mov	r5,r16
 908cd14:	908d6ac0 	call	908d6ac <__unpack_d>
 908cd18:	d8800417 	ldw	r2,16(sp)
 908cd1c:	00c00044 	movi	r3,1
 908cd20:	01bfffc4 	movi	r6,-1
 908cd24:	1880062e 	bgeu	r3,r2,908cd40 <__gtdf2+0x70>
 908cd28:	d8800917 	ldw	r2,36(sp)
 908cd2c:	8809883a 	mov	r4,r17
 908cd30:	800b883a 	mov	r5,r16
 908cd34:	1880022e 	bgeu	r3,r2,908cd40 <__gtdf2+0x70>
 908cd38:	908d7e40 	call	908d7e4 <__fpcmp_parts_d>
 908cd3c:	100d883a 	mov	r6,r2
 908cd40:	3005883a 	mov	r2,r6
 908cd44:	dfc01017 	ldw	ra,64(sp)
 908cd48:	dc400f17 	ldw	r17,60(sp)
 908cd4c:	dc000e17 	ldw	r16,56(sp)
 908cd50:	dec01104 	addi	sp,sp,68
 908cd54:	f800283a 	ret

0908cd58 <__gedf2>:
 908cd58:	deffef04 	addi	sp,sp,-68
 908cd5c:	dc400f15 	stw	r17,60(sp)
 908cd60:	dc400404 	addi	r17,sp,16
 908cd64:	2005883a 	mov	r2,r4
 908cd68:	2807883a 	mov	r3,r5
 908cd6c:	dc000e15 	stw	r16,56(sp)
 908cd70:	d809883a 	mov	r4,sp
 908cd74:	880b883a 	mov	r5,r17
 908cd78:	dc000904 	addi	r16,sp,36
 908cd7c:	d8c00115 	stw	r3,4(sp)
 908cd80:	d8800015 	stw	r2,0(sp)
 908cd84:	d9800215 	stw	r6,8(sp)
 908cd88:	dfc01015 	stw	ra,64(sp)
 908cd8c:	d9c00315 	stw	r7,12(sp)
 908cd90:	908d6ac0 	call	908d6ac <__unpack_d>
 908cd94:	d9000204 	addi	r4,sp,8
 908cd98:	800b883a 	mov	r5,r16
 908cd9c:	908d6ac0 	call	908d6ac <__unpack_d>
 908cda0:	d8800417 	ldw	r2,16(sp)
 908cda4:	00c00044 	movi	r3,1
 908cda8:	01bfffc4 	movi	r6,-1
 908cdac:	1880062e 	bgeu	r3,r2,908cdc8 <__gedf2+0x70>
 908cdb0:	d8800917 	ldw	r2,36(sp)
 908cdb4:	8809883a 	mov	r4,r17
 908cdb8:	800b883a 	mov	r5,r16
 908cdbc:	1880022e 	bgeu	r3,r2,908cdc8 <__gedf2+0x70>
 908cdc0:	908d7e40 	call	908d7e4 <__fpcmp_parts_d>
 908cdc4:	100d883a 	mov	r6,r2
 908cdc8:	3005883a 	mov	r2,r6
 908cdcc:	dfc01017 	ldw	ra,64(sp)
 908cdd0:	dc400f17 	ldw	r17,60(sp)
 908cdd4:	dc000e17 	ldw	r16,56(sp)
 908cdd8:	dec01104 	addi	sp,sp,68
 908cddc:	f800283a 	ret

0908cde0 <__ltdf2>:
 908cde0:	deffef04 	addi	sp,sp,-68
 908cde4:	dc400f15 	stw	r17,60(sp)
 908cde8:	dc400404 	addi	r17,sp,16
 908cdec:	2005883a 	mov	r2,r4
 908cdf0:	2807883a 	mov	r3,r5
 908cdf4:	dc000e15 	stw	r16,56(sp)
 908cdf8:	d809883a 	mov	r4,sp
 908cdfc:	880b883a 	mov	r5,r17
 908ce00:	dc000904 	addi	r16,sp,36
 908ce04:	d8c00115 	stw	r3,4(sp)
 908ce08:	d8800015 	stw	r2,0(sp)
 908ce0c:	d9800215 	stw	r6,8(sp)
 908ce10:	dfc01015 	stw	ra,64(sp)
 908ce14:	d9c00315 	stw	r7,12(sp)
 908ce18:	908d6ac0 	call	908d6ac <__unpack_d>
 908ce1c:	d9000204 	addi	r4,sp,8
 908ce20:	800b883a 	mov	r5,r16
 908ce24:	908d6ac0 	call	908d6ac <__unpack_d>
 908ce28:	d8800417 	ldw	r2,16(sp)
 908ce2c:	00c00044 	movi	r3,1
 908ce30:	180d883a 	mov	r6,r3
 908ce34:	1880062e 	bgeu	r3,r2,908ce50 <__ltdf2+0x70>
 908ce38:	d8800917 	ldw	r2,36(sp)
 908ce3c:	8809883a 	mov	r4,r17
 908ce40:	800b883a 	mov	r5,r16
 908ce44:	1880022e 	bgeu	r3,r2,908ce50 <__ltdf2+0x70>
 908ce48:	908d7e40 	call	908d7e4 <__fpcmp_parts_d>
 908ce4c:	100d883a 	mov	r6,r2
 908ce50:	3005883a 	mov	r2,r6
 908ce54:	dfc01017 	ldw	ra,64(sp)
 908ce58:	dc400f17 	ldw	r17,60(sp)
 908ce5c:	dc000e17 	ldw	r16,56(sp)
 908ce60:	dec01104 	addi	sp,sp,68
 908ce64:	f800283a 	ret

0908ce68 <__floatsidf>:
 908ce68:	2006d7fa 	srli	r3,r4,31
 908ce6c:	defff604 	addi	sp,sp,-40
 908ce70:	008000c4 	movi	r2,3
 908ce74:	dfc00915 	stw	ra,36(sp)
 908ce78:	dcc00815 	stw	r19,32(sp)
 908ce7c:	dc800715 	stw	r18,28(sp)
 908ce80:	dc400615 	stw	r17,24(sp)
 908ce84:	dc000515 	stw	r16,20(sp)
 908ce88:	d8800015 	stw	r2,0(sp)
 908ce8c:	d8c00115 	stw	r3,4(sp)
 908ce90:	20000f1e 	bne	r4,zero,908ced0 <__floatsidf+0x68>
 908ce94:	00800084 	movi	r2,2
 908ce98:	d8800015 	stw	r2,0(sp)
 908ce9c:	d809883a 	mov	r4,sp
 908cea0:	908d3980 	call	908d398 <__pack_d>
 908cea4:	1009883a 	mov	r4,r2
 908cea8:	180b883a 	mov	r5,r3
 908ceac:	2005883a 	mov	r2,r4
 908ceb0:	2807883a 	mov	r3,r5
 908ceb4:	dfc00917 	ldw	ra,36(sp)
 908ceb8:	dcc00817 	ldw	r19,32(sp)
 908cebc:	dc800717 	ldw	r18,28(sp)
 908cec0:	dc400617 	ldw	r17,24(sp)
 908cec4:	dc000517 	ldw	r16,20(sp)
 908cec8:	dec00a04 	addi	sp,sp,40
 908cecc:	f800283a 	ret
 908ced0:	00800f04 	movi	r2,60
 908ced4:	1807003a 	cmpeq	r3,r3,zero
 908ced8:	d8800215 	stw	r2,8(sp)
 908cedc:	18001126 	beq	r3,zero,908cf24 <__floatsidf+0xbc>
 908cee0:	0027883a 	mov	r19,zero
 908cee4:	2025883a 	mov	r18,r4
 908cee8:	d9000315 	stw	r4,12(sp)
 908ceec:	dcc00415 	stw	r19,16(sp)
 908cef0:	908d3180 	call	908d318 <__clzsi2>
 908cef4:	11000744 	addi	r4,r2,29
 908cef8:	013fe80e 	bge	zero,r4,908ce9c <__floatsidf+0x34>
 908cefc:	10bfff44 	addi	r2,r2,-3
 908cf00:	10000c16 	blt	r2,zero,908cf34 <__floatsidf+0xcc>
 908cf04:	90a2983a 	sll	r17,r18,r2
 908cf08:	0021883a 	mov	r16,zero
 908cf0c:	d8800217 	ldw	r2,8(sp)
 908cf10:	dc400415 	stw	r17,16(sp)
 908cf14:	dc000315 	stw	r16,12(sp)
 908cf18:	1105c83a 	sub	r2,r2,r4
 908cf1c:	d8800215 	stw	r2,8(sp)
 908cf20:	003fde06 	br	908ce9c <__floatsidf+0x34>
 908cf24:	00a00034 	movhi	r2,32768
 908cf28:	20800a26 	beq	r4,r2,908cf54 <__floatsidf+0xec>
 908cf2c:	0109c83a 	sub	r4,zero,r4
 908cf30:	003feb06 	br	908cee0 <__floatsidf+0x78>
 908cf34:	9006d07a 	srli	r3,r18,1
 908cf38:	008007c4 	movi	r2,31
 908cf3c:	1105c83a 	sub	r2,r2,r4
 908cf40:	1886d83a 	srl	r3,r3,r2
 908cf44:	9922983a 	sll	r17,r19,r4
 908cf48:	9120983a 	sll	r16,r18,r4
 908cf4c:	1c62b03a 	or	r17,r3,r17
 908cf50:	003fee06 	br	908cf0c <__floatsidf+0xa4>
 908cf54:	0009883a 	mov	r4,zero
 908cf58:	01707834 	movhi	r5,49632
 908cf5c:	003fd306 	br	908ceac <__floatsidf+0x44>

0908cf60 <__fixdfsi>:
 908cf60:	defff804 	addi	sp,sp,-32
 908cf64:	2005883a 	mov	r2,r4
 908cf68:	2807883a 	mov	r3,r5
 908cf6c:	d809883a 	mov	r4,sp
 908cf70:	d9400204 	addi	r5,sp,8
 908cf74:	d8c00115 	stw	r3,4(sp)
 908cf78:	d8800015 	stw	r2,0(sp)
 908cf7c:	dfc00715 	stw	ra,28(sp)
 908cf80:	908d6ac0 	call	908d6ac <__unpack_d>
 908cf84:	d8c00217 	ldw	r3,8(sp)
 908cf88:	00800084 	movi	r2,2
 908cf8c:	1880051e 	bne	r3,r2,908cfa4 <__fixdfsi+0x44>
 908cf90:	0007883a 	mov	r3,zero
 908cf94:	1805883a 	mov	r2,r3
 908cf98:	dfc00717 	ldw	ra,28(sp)
 908cf9c:	dec00804 	addi	sp,sp,32
 908cfa0:	f800283a 	ret
 908cfa4:	00800044 	movi	r2,1
 908cfa8:	10fff92e 	bgeu	r2,r3,908cf90 <__fixdfsi+0x30>
 908cfac:	00800104 	movi	r2,4
 908cfb0:	18800426 	beq	r3,r2,908cfc4 <__fixdfsi+0x64>
 908cfb4:	d8c00417 	ldw	r3,16(sp)
 908cfb8:	183ff516 	blt	r3,zero,908cf90 <__fixdfsi+0x30>
 908cfbc:	00800784 	movi	r2,30
 908cfc0:	10c0080e 	bge	r2,r3,908cfe4 <__fixdfsi+0x84>
 908cfc4:	d8800317 	ldw	r2,12(sp)
 908cfc8:	1000121e 	bne	r2,zero,908d014 <__fixdfsi+0xb4>
 908cfcc:	00e00034 	movhi	r3,32768
 908cfd0:	18ffffc4 	addi	r3,r3,-1
 908cfd4:	1805883a 	mov	r2,r3
 908cfd8:	dfc00717 	ldw	ra,28(sp)
 908cfdc:	dec00804 	addi	sp,sp,32
 908cfe0:	f800283a 	ret
 908cfe4:	00800f04 	movi	r2,60
 908cfe8:	10d1c83a 	sub	r8,r2,r3
 908cfec:	40bff804 	addi	r2,r8,-32
 908cff0:	d9800517 	ldw	r6,20(sp)
 908cff4:	d9c00617 	ldw	r7,24(sp)
 908cff8:	10000816 	blt	r2,zero,908d01c <__fixdfsi+0xbc>
 908cffc:	3888d83a 	srl	r4,r7,r2
 908d000:	d8800317 	ldw	r2,12(sp)
 908d004:	2007883a 	mov	r3,r4
 908d008:	103fe226 	beq	r2,zero,908cf94 <__fixdfsi+0x34>
 908d00c:	0107c83a 	sub	r3,zero,r4
 908d010:	003fe006 	br	908cf94 <__fixdfsi+0x34>
 908d014:	00e00034 	movhi	r3,32768
 908d018:	003fde06 	br	908cf94 <__fixdfsi+0x34>
 908d01c:	39c7883a 	add	r3,r7,r7
 908d020:	008007c4 	movi	r2,31
 908d024:	1205c83a 	sub	r2,r2,r8
 908d028:	1886983a 	sll	r3,r3,r2
 908d02c:	3208d83a 	srl	r4,r6,r8
 908d030:	1908b03a 	or	r4,r3,r4
 908d034:	003ff206 	br	908d000 <__fixdfsi+0xa0>

0908d038 <__floatunsidf>:
 908d038:	defff204 	addi	sp,sp,-56
 908d03c:	dfc00d15 	stw	ra,52(sp)
 908d040:	ddc00c15 	stw	r23,48(sp)
 908d044:	dd800b15 	stw	r22,44(sp)
 908d048:	dd400a15 	stw	r21,40(sp)
 908d04c:	dd000915 	stw	r20,36(sp)
 908d050:	dcc00815 	stw	r19,32(sp)
 908d054:	dc800715 	stw	r18,28(sp)
 908d058:	dc400615 	stw	r17,24(sp)
 908d05c:	dc000515 	stw	r16,20(sp)
 908d060:	d8000115 	stw	zero,4(sp)
 908d064:	20000f1e 	bne	r4,zero,908d0a4 <__floatunsidf+0x6c>
 908d068:	00800084 	movi	r2,2
 908d06c:	d8800015 	stw	r2,0(sp)
 908d070:	d809883a 	mov	r4,sp
 908d074:	908d3980 	call	908d398 <__pack_d>
 908d078:	dfc00d17 	ldw	ra,52(sp)
 908d07c:	ddc00c17 	ldw	r23,48(sp)
 908d080:	dd800b17 	ldw	r22,44(sp)
 908d084:	dd400a17 	ldw	r21,40(sp)
 908d088:	dd000917 	ldw	r20,36(sp)
 908d08c:	dcc00817 	ldw	r19,32(sp)
 908d090:	dc800717 	ldw	r18,28(sp)
 908d094:	dc400617 	ldw	r17,24(sp)
 908d098:	dc000517 	ldw	r16,20(sp)
 908d09c:	dec00e04 	addi	sp,sp,56
 908d0a0:	f800283a 	ret
 908d0a4:	008000c4 	movi	r2,3
 908d0a8:	00c00f04 	movi	r3,60
 908d0ac:	002f883a 	mov	r23,zero
 908d0b0:	202d883a 	mov	r22,r4
 908d0b4:	d8800015 	stw	r2,0(sp)
 908d0b8:	d8c00215 	stw	r3,8(sp)
 908d0bc:	d9000315 	stw	r4,12(sp)
 908d0c0:	ddc00415 	stw	r23,16(sp)
 908d0c4:	908d3180 	call	908d318 <__clzsi2>
 908d0c8:	12400744 	addi	r9,r2,29
 908d0cc:	48000b16 	blt	r9,zero,908d0fc <__floatunsidf+0xc4>
 908d0d0:	483fe726 	beq	r9,zero,908d070 <__floatunsidf+0x38>
 908d0d4:	10bfff44 	addi	r2,r2,-3
 908d0d8:	10002e16 	blt	r2,zero,908d194 <__floatunsidf+0x15c>
 908d0dc:	b0a2983a 	sll	r17,r22,r2
 908d0e0:	0021883a 	mov	r16,zero
 908d0e4:	d8800217 	ldw	r2,8(sp)
 908d0e8:	dc400415 	stw	r17,16(sp)
 908d0ec:	dc000315 	stw	r16,12(sp)
 908d0f0:	1245c83a 	sub	r2,r2,r9
 908d0f4:	d8800215 	stw	r2,8(sp)
 908d0f8:	003fdd06 	br	908d070 <__floatunsidf+0x38>
 908d0fc:	0255c83a 	sub	r10,zero,r9
 908d100:	51bff804 	addi	r6,r10,-32
 908d104:	30001b16 	blt	r6,zero,908d174 <__floatunsidf+0x13c>
 908d108:	b9a8d83a 	srl	r20,r23,r6
 908d10c:	002b883a 	mov	r21,zero
 908d110:	000f883a 	mov	r7,zero
 908d114:	01000044 	movi	r4,1
 908d118:	0011883a 	mov	r8,zero
 908d11c:	30002516 	blt	r6,zero,908d1b4 <__floatunsidf+0x17c>
 908d120:	21a6983a 	sll	r19,r4,r6
 908d124:	0025883a 	mov	r18,zero
 908d128:	00bfffc4 	movi	r2,-1
 908d12c:	9089883a 	add	r4,r18,r2
 908d130:	988b883a 	add	r5,r19,r2
 908d134:	248d803a 	cmpltu	r6,r4,r18
 908d138:	314b883a 	add	r5,r6,r5
 908d13c:	b104703a 	and	r2,r22,r4
 908d140:	b946703a 	and	r3,r23,r5
 908d144:	10c4b03a 	or	r2,r2,r3
 908d148:	10000226 	beq	r2,zero,908d154 <__floatunsidf+0x11c>
 908d14c:	01c00044 	movi	r7,1
 908d150:	0011883a 	mov	r8,zero
 908d154:	d9000217 	ldw	r4,8(sp)
 908d158:	a1c4b03a 	or	r2,r20,r7
 908d15c:	aa06b03a 	or	r3,r21,r8
 908d160:	2249c83a 	sub	r4,r4,r9
 908d164:	d8c00415 	stw	r3,16(sp)
 908d168:	d9000215 	stw	r4,8(sp)
 908d16c:	d8800315 	stw	r2,12(sp)
 908d170:	003fbf06 	br	908d070 <__floatunsidf+0x38>
 908d174:	bdc7883a 	add	r3,r23,r23
 908d178:	008007c4 	movi	r2,31
 908d17c:	1285c83a 	sub	r2,r2,r10
 908d180:	1886983a 	sll	r3,r3,r2
 908d184:	b2a8d83a 	srl	r20,r22,r10
 908d188:	baaad83a 	srl	r21,r23,r10
 908d18c:	1d28b03a 	or	r20,r3,r20
 908d190:	003fdf06 	br	908d110 <__floatunsidf+0xd8>
 908d194:	b006d07a 	srli	r3,r22,1
 908d198:	008007c4 	movi	r2,31
 908d19c:	1245c83a 	sub	r2,r2,r9
 908d1a0:	1886d83a 	srl	r3,r3,r2
 908d1a4:	ba62983a 	sll	r17,r23,r9
 908d1a8:	b260983a 	sll	r16,r22,r9
 908d1ac:	1c62b03a 	or	r17,r3,r17
 908d1b0:	003fcc06 	br	908d0e4 <__floatunsidf+0xac>
 908d1b4:	2006d07a 	srli	r3,r4,1
 908d1b8:	008007c4 	movi	r2,31
 908d1bc:	1285c83a 	sub	r2,r2,r10
 908d1c0:	18a6d83a 	srl	r19,r3,r2
 908d1c4:	22a4983a 	sll	r18,r4,r10
 908d1c8:	003fd706 	br	908d128 <__floatunsidf+0xf0>

0908d1cc <udivmodsi4>:
 908d1cc:	29001b2e 	bgeu	r5,r4,908d23c <udivmodsi4+0x70>
 908d1d0:	28001a16 	blt	r5,zero,908d23c <udivmodsi4+0x70>
 908d1d4:	00800044 	movi	r2,1
 908d1d8:	0007883a 	mov	r3,zero
 908d1dc:	01c007c4 	movi	r7,31
 908d1e0:	00000306 	br	908d1f0 <udivmodsi4+0x24>
 908d1e4:	19c01326 	beq	r3,r7,908d234 <udivmodsi4+0x68>
 908d1e8:	18c00044 	addi	r3,r3,1
 908d1ec:	28000416 	blt	r5,zero,908d200 <udivmodsi4+0x34>
 908d1f0:	294b883a 	add	r5,r5,r5
 908d1f4:	1085883a 	add	r2,r2,r2
 908d1f8:	293ffa36 	bltu	r5,r4,908d1e4 <udivmodsi4+0x18>
 908d1fc:	10000d26 	beq	r2,zero,908d234 <udivmodsi4+0x68>
 908d200:	0007883a 	mov	r3,zero
 908d204:	21400236 	bltu	r4,r5,908d210 <udivmodsi4+0x44>
 908d208:	2149c83a 	sub	r4,r4,r5
 908d20c:	1886b03a 	or	r3,r3,r2
 908d210:	1004d07a 	srli	r2,r2,1
 908d214:	280ad07a 	srli	r5,r5,1
 908d218:	103ffa1e 	bne	r2,zero,908d204 <udivmodsi4+0x38>
 908d21c:	30000226 	beq	r6,zero,908d228 <udivmodsi4+0x5c>
 908d220:	2005883a 	mov	r2,r4
 908d224:	f800283a 	ret
 908d228:	1809883a 	mov	r4,r3
 908d22c:	2005883a 	mov	r2,r4
 908d230:	f800283a 	ret
 908d234:	0007883a 	mov	r3,zero
 908d238:	003ff806 	br	908d21c <udivmodsi4+0x50>
 908d23c:	00800044 	movi	r2,1
 908d240:	0007883a 	mov	r3,zero
 908d244:	003fef06 	br	908d204 <udivmodsi4+0x38>

0908d248 <__divsi3>:
 908d248:	defffe04 	addi	sp,sp,-8
 908d24c:	dc000015 	stw	r16,0(sp)
 908d250:	dfc00115 	stw	ra,4(sp)
 908d254:	0021883a 	mov	r16,zero
 908d258:	20000c16 	blt	r4,zero,908d28c <__divsi3+0x44>
 908d25c:	000d883a 	mov	r6,zero
 908d260:	28000e16 	blt	r5,zero,908d29c <__divsi3+0x54>
 908d264:	908d1cc0 	call	908d1cc <udivmodsi4>
 908d268:	1007883a 	mov	r3,r2
 908d26c:	8005003a 	cmpeq	r2,r16,zero
 908d270:	1000011e 	bne	r2,zero,908d278 <__divsi3+0x30>
 908d274:	00c7c83a 	sub	r3,zero,r3
 908d278:	1805883a 	mov	r2,r3
 908d27c:	dfc00117 	ldw	ra,4(sp)
 908d280:	dc000017 	ldw	r16,0(sp)
 908d284:	dec00204 	addi	sp,sp,8
 908d288:	f800283a 	ret
 908d28c:	0109c83a 	sub	r4,zero,r4
 908d290:	04000044 	movi	r16,1
 908d294:	000d883a 	mov	r6,zero
 908d298:	283ff20e 	bge	r5,zero,908d264 <__divsi3+0x1c>
 908d29c:	014bc83a 	sub	r5,zero,r5
 908d2a0:	8021003a 	cmpeq	r16,r16,zero
 908d2a4:	003fef06 	br	908d264 <__divsi3+0x1c>

0908d2a8 <__modsi3>:
 908d2a8:	deffff04 	addi	sp,sp,-4
 908d2ac:	dfc00015 	stw	ra,0(sp)
 908d2b0:	01800044 	movi	r6,1
 908d2b4:	2807883a 	mov	r3,r5
 908d2b8:	20000416 	blt	r4,zero,908d2cc <__modsi3+0x24>
 908d2bc:	28000c16 	blt	r5,zero,908d2f0 <__modsi3+0x48>
 908d2c0:	dfc00017 	ldw	ra,0(sp)
 908d2c4:	dec00104 	addi	sp,sp,4
 908d2c8:	908d1cc1 	jmpi	908d1cc <udivmodsi4>
 908d2cc:	0109c83a 	sub	r4,zero,r4
 908d2d0:	28000b16 	blt	r5,zero,908d300 <__modsi3+0x58>
 908d2d4:	180b883a 	mov	r5,r3
 908d2d8:	01800044 	movi	r6,1
 908d2dc:	908d1cc0 	call	908d1cc <udivmodsi4>
 908d2e0:	0085c83a 	sub	r2,zero,r2
 908d2e4:	dfc00017 	ldw	ra,0(sp)
 908d2e8:	dec00104 	addi	sp,sp,4
 908d2ec:	f800283a 	ret
 908d2f0:	014bc83a 	sub	r5,zero,r5
 908d2f4:	dfc00017 	ldw	ra,0(sp)
 908d2f8:	dec00104 	addi	sp,sp,4
 908d2fc:	908d1cc1 	jmpi	908d1cc <udivmodsi4>
 908d300:	0147c83a 	sub	r3,zero,r5
 908d304:	003ff306 	br	908d2d4 <__modsi3+0x2c>

0908d308 <__udivsi3>:
 908d308:	000d883a 	mov	r6,zero
 908d30c:	908d1cc1 	jmpi	908d1cc <udivmodsi4>

0908d310 <__umodsi3>:
 908d310:	01800044 	movi	r6,1
 908d314:	908d1cc1 	jmpi	908d1cc <udivmodsi4>

0908d318 <__clzsi2>:
 908d318:	00bfffd4 	movui	r2,65535
 908d31c:	11000e36 	bltu	r2,r4,908d358 <__clzsi2+0x40>
 908d320:	00803fc4 	movi	r2,255
 908d324:	01400204 	movi	r5,8
 908d328:	0007883a 	mov	r3,zero
 908d32c:	11001036 	bltu	r2,r4,908d370 <__clzsi2+0x58>
 908d330:	000b883a 	mov	r5,zero
 908d334:	20c6d83a 	srl	r3,r4,r3
 908d338:	00824374 	movhi	r2,2317
 908d33c:	10b5cc04 	addi	r2,r2,-10448
 908d340:	1887883a 	add	r3,r3,r2
 908d344:	18800003 	ldbu	r2,0(r3)
 908d348:	00c00804 	movi	r3,32
 908d34c:	2885883a 	add	r2,r5,r2
 908d350:	1885c83a 	sub	r2,r3,r2
 908d354:	f800283a 	ret
 908d358:	01400404 	movi	r5,16
 908d35c:	00804034 	movhi	r2,256
 908d360:	10bfffc4 	addi	r2,r2,-1
 908d364:	2807883a 	mov	r3,r5
 908d368:	113ff22e 	bgeu	r2,r4,908d334 <__clzsi2+0x1c>
 908d36c:	01400604 	movi	r5,24
 908d370:	2807883a 	mov	r3,r5
 908d374:	20c6d83a 	srl	r3,r4,r3
 908d378:	00824374 	movhi	r2,2317
 908d37c:	10b5cc04 	addi	r2,r2,-10448
 908d380:	1887883a 	add	r3,r3,r2
 908d384:	18800003 	ldbu	r2,0(r3)
 908d388:	00c00804 	movi	r3,32
 908d38c:	2885883a 	add	r2,r5,r2
 908d390:	1885c83a 	sub	r2,r3,r2
 908d394:	f800283a 	ret

0908d398 <__pack_d>:
 908d398:	20c00017 	ldw	r3,0(r4)
 908d39c:	defffd04 	addi	sp,sp,-12
 908d3a0:	dc000015 	stw	r16,0(sp)
 908d3a4:	dc800215 	stw	r18,8(sp)
 908d3a8:	dc400115 	stw	r17,4(sp)
 908d3ac:	00800044 	movi	r2,1
 908d3b0:	22000317 	ldw	r8,12(r4)
 908d3b4:	001f883a 	mov	r15,zero
 908d3b8:	22400417 	ldw	r9,16(r4)
 908d3bc:	24000117 	ldw	r16,4(r4)
 908d3c0:	10c0552e 	bgeu	r2,r3,908d518 <__pack_d+0x180>
 908d3c4:	00800104 	movi	r2,4
 908d3c8:	18804f26 	beq	r3,r2,908d508 <__pack_d+0x170>
 908d3cc:	00800084 	movi	r2,2
 908d3d0:	18800226 	beq	r3,r2,908d3dc <__pack_d+0x44>
 908d3d4:	4244b03a 	or	r2,r8,r9
 908d3d8:	10001a1e 	bne	r2,zero,908d444 <__pack_d+0xac>
 908d3dc:	000d883a 	mov	r6,zero
 908d3e0:	000f883a 	mov	r7,zero
 908d3e4:	0011883a 	mov	r8,zero
 908d3e8:	00800434 	movhi	r2,16
 908d3ec:	10bfffc4 	addi	r2,r2,-1
 908d3f0:	301d883a 	mov	r14,r6
 908d3f4:	3884703a 	and	r2,r7,r2
 908d3f8:	400a953a 	slli	r5,r8,20
 908d3fc:	79bffc2c 	andhi	r6,r15,65520
 908d400:	308cb03a 	or	r6,r6,r2
 908d404:	00e00434 	movhi	r3,32784
 908d408:	18ffffc4 	addi	r3,r3,-1
 908d40c:	800497fa 	slli	r2,r16,31
 908d410:	30c6703a 	and	r3,r6,r3
 908d414:	1946b03a 	or	r3,r3,r5
 908d418:	01600034 	movhi	r5,32768
 908d41c:	297fffc4 	addi	r5,r5,-1
 908d420:	194a703a 	and	r5,r3,r5
 908d424:	288ab03a 	or	r5,r5,r2
 908d428:	2807883a 	mov	r3,r5
 908d42c:	7005883a 	mov	r2,r14
 908d430:	dc800217 	ldw	r18,8(sp)
 908d434:	dc400117 	ldw	r17,4(sp)
 908d438:	dc000017 	ldw	r16,0(sp)
 908d43c:	dec00304 	addi	sp,sp,12
 908d440:	f800283a 	ret
 908d444:	21000217 	ldw	r4,8(r4)
 908d448:	00bf0084 	movi	r2,-1022
 908d44c:	20803f16 	blt	r4,r2,908d54c <__pack_d+0x1b4>
 908d450:	0080ffc4 	movi	r2,1023
 908d454:	11002c16 	blt	r2,r4,908d508 <__pack_d+0x170>
 908d458:	00803fc4 	movi	r2,255
 908d45c:	408c703a 	and	r6,r8,r2
 908d460:	00802004 	movi	r2,128
 908d464:	0007883a 	mov	r3,zero
 908d468:	000f883a 	mov	r7,zero
 908d46c:	2280ffc4 	addi	r10,r4,1023
 908d470:	30801e26 	beq	r6,r2,908d4ec <__pack_d+0x154>
 908d474:	00801fc4 	movi	r2,127
 908d478:	4089883a 	add	r4,r8,r2
 908d47c:	220d803a 	cmpltu	r6,r4,r8
 908d480:	324d883a 	add	r6,r6,r9
 908d484:	2011883a 	mov	r8,r4
 908d488:	3013883a 	mov	r9,r6
 908d48c:	00880034 	movhi	r2,8192
 908d490:	10bfffc4 	addi	r2,r2,-1
 908d494:	12400d36 	bltu	r2,r9,908d4cc <__pack_d+0x134>
 908d498:	4804963a 	slli	r2,r9,24
 908d49c:	400cd23a 	srli	r6,r8,8
 908d4a0:	480ed23a 	srli	r7,r9,8
 908d4a4:	013fffc4 	movi	r4,-1
 908d4a8:	118cb03a 	or	r6,r2,r6
 908d4ac:	01400434 	movhi	r5,16
 908d4b0:	297fffc4 	addi	r5,r5,-1
 908d4b4:	3104703a 	and	r2,r6,r4
 908d4b8:	3946703a 	and	r3,r7,r5
 908d4bc:	5201ffcc 	andi	r8,r10,2047
 908d4c0:	100d883a 	mov	r6,r2
 908d4c4:	180f883a 	mov	r7,r3
 908d4c8:	003fc706 	br	908d3e8 <__pack_d+0x50>
 908d4cc:	480897fa 	slli	r4,r9,31
 908d4d0:	4004d07a 	srli	r2,r8,1
 908d4d4:	4806d07a 	srli	r3,r9,1
 908d4d8:	52800044 	addi	r10,r10,1
 908d4dc:	2084b03a 	or	r2,r4,r2
 908d4e0:	1011883a 	mov	r8,r2
 908d4e4:	1813883a 	mov	r9,r3
 908d4e8:	003feb06 	br	908d498 <__pack_d+0x100>
 908d4ec:	383fe11e 	bne	r7,zero,908d474 <__pack_d+0xdc>
 908d4f0:	01004004 	movi	r4,256
 908d4f4:	4104703a 	and	r2,r8,r4
 908d4f8:	10c4b03a 	or	r2,r2,r3
 908d4fc:	103fe326 	beq	r2,zero,908d48c <__pack_d+0xf4>
 908d500:	3005883a 	mov	r2,r6
 908d504:	003fdc06 	br	908d478 <__pack_d+0xe0>
 908d508:	000d883a 	mov	r6,zero
 908d50c:	000f883a 	mov	r7,zero
 908d510:	0201ffc4 	movi	r8,2047
 908d514:	003fb406 	br	908d3e8 <__pack_d+0x50>
 908d518:	0005883a 	mov	r2,zero
 908d51c:	00c00234 	movhi	r3,8
 908d520:	408cb03a 	or	r6,r8,r2
 908d524:	48ceb03a 	or	r7,r9,r3
 908d528:	013fffc4 	movi	r4,-1
 908d52c:	01400434 	movhi	r5,16
 908d530:	297fffc4 	addi	r5,r5,-1
 908d534:	3104703a 	and	r2,r6,r4
 908d538:	3946703a 	and	r3,r7,r5
 908d53c:	100d883a 	mov	r6,r2
 908d540:	180f883a 	mov	r7,r3
 908d544:	0201ffc4 	movi	r8,2047
 908d548:	003fa706 	br	908d3e8 <__pack_d+0x50>
 908d54c:	1109c83a 	sub	r4,r2,r4
 908d550:	00800e04 	movi	r2,56
 908d554:	11004316 	blt	r2,r4,908d664 <__pack_d+0x2cc>
 908d558:	21fff804 	addi	r7,r4,-32
 908d55c:	38004516 	blt	r7,zero,908d674 <__pack_d+0x2dc>
 908d560:	49d8d83a 	srl	r12,r9,r7
 908d564:	001b883a 	mov	r13,zero
 908d568:	0023883a 	mov	r17,zero
 908d56c:	01400044 	movi	r5,1
 908d570:	0025883a 	mov	r18,zero
 908d574:	38004716 	blt	r7,zero,908d694 <__pack_d+0x2fc>
 908d578:	29d6983a 	sll	r11,r5,r7
 908d57c:	0015883a 	mov	r10,zero
 908d580:	00bfffc4 	movi	r2,-1
 908d584:	5089883a 	add	r4,r10,r2
 908d588:	588b883a 	add	r5,r11,r2
 908d58c:	228d803a 	cmpltu	r6,r4,r10
 908d590:	314b883a 	add	r5,r6,r5
 908d594:	4104703a 	and	r2,r8,r4
 908d598:	4946703a 	and	r3,r9,r5
 908d59c:	10c4b03a 	or	r2,r2,r3
 908d5a0:	10000226 	beq	r2,zero,908d5ac <__pack_d+0x214>
 908d5a4:	04400044 	movi	r17,1
 908d5a8:	0025883a 	mov	r18,zero
 908d5ac:	00803fc4 	movi	r2,255
 908d5b0:	644eb03a 	or	r7,r12,r17
 908d5b4:	3892703a 	and	r9,r7,r2
 908d5b8:	00802004 	movi	r2,128
 908d5bc:	6c90b03a 	or	r8,r13,r18
 908d5c0:	0015883a 	mov	r10,zero
 908d5c4:	48801626 	beq	r9,r2,908d620 <__pack_d+0x288>
 908d5c8:	01001fc4 	movi	r4,127
 908d5cc:	3905883a 	add	r2,r7,r4
 908d5d0:	11cd803a 	cmpltu	r6,r2,r7
 908d5d4:	320d883a 	add	r6,r6,r8
 908d5d8:	100f883a 	mov	r7,r2
 908d5dc:	00840034 	movhi	r2,4096
 908d5e0:	10bfffc4 	addi	r2,r2,-1
 908d5e4:	3011883a 	mov	r8,r6
 908d5e8:	0007883a 	mov	r3,zero
 908d5ec:	11801b36 	bltu	r2,r6,908d65c <__pack_d+0x2c4>
 908d5f0:	4004963a 	slli	r2,r8,24
 908d5f4:	3808d23a 	srli	r4,r7,8
 908d5f8:	400ad23a 	srli	r5,r8,8
 908d5fc:	1813883a 	mov	r9,r3
 908d600:	1108b03a 	or	r4,r2,r4
 908d604:	00bfffc4 	movi	r2,-1
 908d608:	00c00434 	movhi	r3,16
 908d60c:	18ffffc4 	addi	r3,r3,-1
 908d610:	208c703a 	and	r6,r4,r2
 908d614:	28ce703a 	and	r7,r5,r3
 908d618:	4a01ffcc 	andi	r8,r9,2047
 908d61c:	003f7206 	br	908d3e8 <__pack_d+0x50>
 908d620:	503fe91e 	bne	r10,zero,908d5c8 <__pack_d+0x230>
 908d624:	01004004 	movi	r4,256
 908d628:	3904703a 	and	r2,r7,r4
 908d62c:	0007883a 	mov	r3,zero
 908d630:	10c4b03a 	or	r2,r2,r3
 908d634:	10000626 	beq	r2,zero,908d650 <__pack_d+0x2b8>
 908d638:	3a45883a 	add	r2,r7,r9
 908d63c:	11cd803a 	cmpltu	r6,r2,r7
 908d640:	320d883a 	add	r6,r6,r8
 908d644:	100f883a 	mov	r7,r2
 908d648:	3011883a 	mov	r8,r6
 908d64c:	0007883a 	mov	r3,zero
 908d650:	00840034 	movhi	r2,4096
 908d654:	10bfffc4 	addi	r2,r2,-1
 908d658:	123fe52e 	bgeu	r2,r8,908d5f0 <__pack_d+0x258>
 908d65c:	00c00044 	movi	r3,1
 908d660:	003fe306 	br	908d5f0 <__pack_d+0x258>
 908d664:	0009883a 	mov	r4,zero
 908d668:	0013883a 	mov	r9,zero
 908d66c:	000b883a 	mov	r5,zero
 908d670:	003fe406 	br	908d604 <__pack_d+0x26c>
 908d674:	4a47883a 	add	r3,r9,r9
 908d678:	008007c4 	movi	r2,31
 908d67c:	1105c83a 	sub	r2,r2,r4
 908d680:	1886983a 	sll	r3,r3,r2
 908d684:	4118d83a 	srl	r12,r8,r4
 908d688:	491ad83a 	srl	r13,r9,r4
 908d68c:	1b18b03a 	or	r12,r3,r12
 908d690:	003fb506 	br	908d568 <__pack_d+0x1d0>
 908d694:	2806d07a 	srli	r3,r5,1
 908d698:	008007c4 	movi	r2,31
 908d69c:	1105c83a 	sub	r2,r2,r4
 908d6a0:	1896d83a 	srl	r11,r3,r2
 908d6a4:	2914983a 	sll	r10,r5,r4
 908d6a8:	003fb506 	br	908d580 <__pack_d+0x1e8>

0908d6ac <__unpack_d>:
 908d6ac:	20c00117 	ldw	r3,4(r4)
 908d6b0:	22400017 	ldw	r9,0(r4)
 908d6b4:	00800434 	movhi	r2,16
 908d6b8:	10bfffc4 	addi	r2,r2,-1
 908d6bc:	1808d53a 	srli	r4,r3,20
 908d6c0:	180cd7fa 	srli	r6,r3,31
 908d6c4:	1894703a 	and	r10,r3,r2
 908d6c8:	2201ffcc 	andi	r8,r4,2047
 908d6cc:	281b883a 	mov	r13,r5
 908d6d0:	4817883a 	mov	r11,r9
 908d6d4:	29800115 	stw	r6,4(r5)
 908d6d8:	5019883a 	mov	r12,r10
 908d6dc:	40001e1e 	bne	r8,zero,908d758 <__unpack_d+0xac>
 908d6e0:	4a84b03a 	or	r2,r9,r10
 908d6e4:	10001926 	beq	r2,zero,908d74c <__unpack_d+0xa0>
 908d6e8:	4804d63a 	srli	r2,r9,24
 908d6ec:	500c923a 	slli	r6,r10,8
 908d6f0:	013f0084 	movi	r4,-1022
 908d6f4:	00c40034 	movhi	r3,4096
 908d6f8:	18ffffc4 	addi	r3,r3,-1
 908d6fc:	118cb03a 	or	r6,r2,r6
 908d700:	008000c4 	movi	r2,3
 908d704:	480a923a 	slli	r5,r9,8
 908d708:	68800015 	stw	r2,0(r13)
 908d70c:	69000215 	stw	r4,8(r13)
 908d710:	19800b36 	bltu	r3,r6,908d740 <__unpack_d+0x94>
 908d714:	200f883a 	mov	r7,r4
 908d718:	1811883a 	mov	r8,r3
 908d71c:	2945883a 	add	r2,r5,r5
 908d720:	1149803a 	cmpltu	r4,r2,r5
 908d724:	3187883a 	add	r3,r6,r6
 908d728:	20c9883a 	add	r4,r4,r3
 908d72c:	100b883a 	mov	r5,r2
 908d730:	200d883a 	mov	r6,r4
 908d734:	39ffffc4 	addi	r7,r7,-1
 908d738:	413ff82e 	bgeu	r8,r4,908d71c <__unpack_d+0x70>
 908d73c:	69c00215 	stw	r7,8(r13)
 908d740:	69800415 	stw	r6,16(r13)
 908d744:	69400315 	stw	r5,12(r13)
 908d748:	f800283a 	ret
 908d74c:	00800084 	movi	r2,2
 908d750:	28800015 	stw	r2,0(r5)
 908d754:	f800283a 	ret
 908d758:	0081ffc4 	movi	r2,2047
 908d75c:	40800f26 	beq	r8,r2,908d79c <__unpack_d+0xf0>
 908d760:	480cd63a 	srli	r6,r9,24
 908d764:	5006923a 	slli	r3,r10,8
 908d768:	4804923a 	slli	r2,r9,8
 908d76c:	0009883a 	mov	r4,zero
 908d770:	30c6b03a 	or	r3,r6,r3
 908d774:	01440034 	movhi	r5,4096
 908d778:	110cb03a 	or	r6,r2,r4
 908d77c:	423f0044 	addi	r8,r8,-1023
 908d780:	194eb03a 	or	r7,r3,r5
 908d784:	008000c4 	movi	r2,3
 908d788:	69c00415 	stw	r7,16(r13)
 908d78c:	6a000215 	stw	r8,8(r13)
 908d790:	68800015 	stw	r2,0(r13)
 908d794:	69800315 	stw	r6,12(r13)
 908d798:	f800283a 	ret
 908d79c:	4a84b03a 	or	r2,r9,r10
 908d7a0:	1000031e 	bne	r2,zero,908d7b0 <__unpack_d+0x104>
 908d7a4:	00800104 	movi	r2,4
 908d7a8:	28800015 	stw	r2,0(r5)
 908d7ac:	f800283a 	ret
 908d7b0:	0009883a 	mov	r4,zero
 908d7b4:	01400234 	movhi	r5,8
 908d7b8:	4904703a 	and	r2,r9,r4
 908d7bc:	5146703a 	and	r3,r10,r5
 908d7c0:	10c4b03a 	or	r2,r2,r3
 908d7c4:	10000526 	beq	r2,zero,908d7dc <__unpack_d+0x130>
 908d7c8:	00800044 	movi	r2,1
 908d7cc:	68800015 	stw	r2,0(r13)
 908d7d0:	6b000415 	stw	r12,16(r13)
 908d7d4:	6ac00315 	stw	r11,12(r13)
 908d7d8:	f800283a 	ret
 908d7dc:	68000015 	stw	zero,0(r13)
 908d7e0:	003ffb06 	br	908d7d0 <__unpack_d+0x124>

0908d7e4 <__fpcmp_parts_d>:
 908d7e4:	21800017 	ldw	r6,0(r4)
 908d7e8:	00c00044 	movi	r3,1
 908d7ec:	19800a2e 	bgeu	r3,r6,908d818 <__fpcmp_parts_d+0x34>
 908d7f0:	28800017 	ldw	r2,0(r5)
 908d7f4:	1880082e 	bgeu	r3,r2,908d818 <__fpcmp_parts_d+0x34>
 908d7f8:	00c00104 	movi	r3,4
 908d7fc:	30c02626 	beq	r6,r3,908d898 <__fpcmp_parts_d+0xb4>
 908d800:	10c02226 	beq	r2,r3,908d88c <__fpcmp_parts_d+0xa8>
 908d804:	00c00084 	movi	r3,2
 908d808:	30c00526 	beq	r6,r3,908d820 <__fpcmp_parts_d+0x3c>
 908d80c:	10c0071e 	bne	r2,r3,908d82c <__fpcmp_parts_d+0x48>
 908d810:	20800117 	ldw	r2,4(r4)
 908d814:	1000091e 	bne	r2,zero,908d83c <__fpcmp_parts_d+0x58>
 908d818:	00800044 	movi	r2,1
 908d81c:	f800283a 	ret
 908d820:	10c01a1e 	bne	r2,r3,908d88c <__fpcmp_parts_d+0xa8>
 908d824:	0005883a 	mov	r2,zero
 908d828:	f800283a 	ret
 908d82c:	22000117 	ldw	r8,4(r4)
 908d830:	28800117 	ldw	r2,4(r5)
 908d834:	40800326 	beq	r8,r2,908d844 <__fpcmp_parts_d+0x60>
 908d838:	403ff726 	beq	r8,zero,908d818 <__fpcmp_parts_d+0x34>
 908d83c:	00bfffc4 	movi	r2,-1
 908d840:	f800283a 	ret
 908d844:	20c00217 	ldw	r3,8(r4)
 908d848:	28800217 	ldw	r2,8(r5)
 908d84c:	10fffa16 	blt	r2,r3,908d838 <__fpcmp_parts_d+0x54>
 908d850:	18800916 	blt	r3,r2,908d878 <__fpcmp_parts_d+0x94>
 908d854:	21c00417 	ldw	r7,16(r4)
 908d858:	28c00417 	ldw	r3,16(r5)
 908d85c:	21800317 	ldw	r6,12(r4)
 908d860:	28800317 	ldw	r2,12(r5)
 908d864:	19fff436 	bltu	r3,r7,908d838 <__fpcmp_parts_d+0x54>
 908d868:	38c00526 	beq	r7,r3,908d880 <__fpcmp_parts_d+0x9c>
 908d86c:	38c00236 	bltu	r7,r3,908d878 <__fpcmp_parts_d+0x94>
 908d870:	19ffec1e 	bne	r3,r7,908d824 <__fpcmp_parts_d+0x40>
 908d874:	30bfeb2e 	bgeu	r6,r2,908d824 <__fpcmp_parts_d+0x40>
 908d878:	403fe71e 	bne	r8,zero,908d818 <__fpcmp_parts_d+0x34>
 908d87c:	003fef06 	br	908d83c <__fpcmp_parts_d+0x58>
 908d880:	11bffa2e 	bgeu	r2,r6,908d86c <__fpcmp_parts_d+0x88>
 908d884:	403fe426 	beq	r8,zero,908d818 <__fpcmp_parts_d+0x34>
 908d888:	003fec06 	br	908d83c <__fpcmp_parts_d+0x58>
 908d88c:	28800117 	ldw	r2,4(r5)
 908d890:	103fe11e 	bne	r2,zero,908d818 <__fpcmp_parts_d+0x34>
 908d894:	003fe906 	br	908d83c <__fpcmp_parts_d+0x58>
 908d898:	11bfdd1e 	bne	r2,r6,908d810 <__fpcmp_parts_d+0x2c>
 908d89c:	28c00117 	ldw	r3,4(r5)
 908d8a0:	20800117 	ldw	r2,4(r4)
 908d8a4:	1885c83a 	sub	r2,r3,r2
 908d8a8:	f800283a 	ret

0908d8ac <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 908d8ac:	defff904 	addi	sp,sp,-28
 908d8b0:	dfc00615 	stw	ra,24(sp)
 908d8b4:	df000515 	stw	fp,20(sp)
 908d8b8:	df000504 	addi	fp,sp,20
 908d8bc:	e13ffc15 	stw	r4,-16(fp)
 908d8c0:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908d8c4:	e0bffc17 	ldw	r2,-16(fp)
 908d8c8:	1004803a 	cmplt	r2,r2,zero
 908d8cc:	1000081e 	bne	r2,zero,908d8f0 <fstat+0x44>
 908d8d0:	e0bffc17 	ldw	r2,-16(fp)
 908d8d4:	10800324 	muli	r2,r2,12
 908d8d8:	1007883a 	mov	r3,r2
 908d8dc:	00824374 	movhi	r2,2317
 908d8e0:	108dc104 	addi	r2,r2,14084
 908d8e4:	1887883a 	add	r3,r3,r2
 908d8e8:	e0ffff15 	stw	r3,-4(fp)
 908d8ec:	00000106 	br	908d8f4 <fstat+0x48>
 908d8f0:	e03fff15 	stw	zero,-4(fp)
 908d8f4:	e0bfff17 	ldw	r2,-4(fp)
 908d8f8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 908d8fc:	e0bffb17 	ldw	r2,-20(fp)
 908d900:	1005003a 	cmpeq	r2,r2,zero
 908d904:	1000121e 	bne	r2,zero,908d950 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 908d908:	e0bffb17 	ldw	r2,-20(fp)
 908d90c:	10800017 	ldw	r2,0(r2)
 908d910:	10800817 	ldw	r2,32(r2)
 908d914:	1005003a 	cmpeq	r2,r2,zero
 908d918:	1000081e 	bne	r2,zero,908d93c <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 908d91c:	e0bffb17 	ldw	r2,-20(fp)
 908d920:	10800017 	ldw	r2,0(r2)
 908d924:	10800817 	ldw	r2,32(r2)
 908d928:	e13ffb17 	ldw	r4,-20(fp)
 908d92c:	e17ffd17 	ldw	r5,-12(fp)
 908d930:	103ee83a 	callr	r2
 908d934:	e0bffe15 	stw	r2,-8(fp)
 908d938:	00000b06 	br	908d968 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 908d93c:	e0fffd17 	ldw	r3,-12(fp)
 908d940:	00880004 	movi	r2,8192
 908d944:	18800115 	stw	r2,4(r3)
      return 0;
 908d948:	e03ffe15 	stw	zero,-8(fp)
 908d94c:	00000606 	br	908d968 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 908d950:	908d9800 	call	908d980 <alt_get_errno>
 908d954:	1007883a 	mov	r3,r2
 908d958:	00801444 	movi	r2,81
 908d95c:	18800015 	stw	r2,0(r3)
    return -1;
 908d960:	00bfffc4 	movi	r2,-1
 908d964:	e0bffe15 	stw	r2,-8(fp)
 908d968:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 908d96c:	e037883a 	mov	sp,fp
 908d970:	dfc00117 	ldw	ra,4(sp)
 908d974:	df000017 	ldw	fp,0(sp)
 908d978:	dec00204 	addi	sp,sp,8
 908d97c:	f800283a 	ret

0908d980 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908d980:	defffd04 	addi	sp,sp,-12
 908d984:	dfc00215 	stw	ra,8(sp)
 908d988:	df000115 	stw	fp,4(sp)
 908d98c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908d990:	00824374 	movhi	r2,2317
 908d994:	108eca04 	addi	r2,r2,15144
 908d998:	10800017 	ldw	r2,0(r2)
 908d99c:	1005003a 	cmpeq	r2,r2,zero
 908d9a0:	1000061e 	bne	r2,zero,908d9bc <alt_get_errno+0x3c>
 908d9a4:	00824374 	movhi	r2,2317
 908d9a8:	108eca04 	addi	r2,r2,15144
 908d9ac:	10800017 	ldw	r2,0(r2)
 908d9b0:	103ee83a 	callr	r2
 908d9b4:	e0bfff15 	stw	r2,-4(fp)
 908d9b8:	00000306 	br	908d9c8 <alt_get_errno+0x48>
 908d9bc:	00824374 	movhi	r2,2317
 908d9c0:	108ee904 	addi	r2,r2,15268
 908d9c4:	e0bfff15 	stw	r2,-4(fp)
 908d9c8:	e0bfff17 	ldw	r2,-4(fp)
}
 908d9cc:	e037883a 	mov	sp,fp
 908d9d0:	dfc00117 	ldw	ra,4(sp)
 908d9d4:	df000017 	ldw	fp,0(sp)
 908d9d8:	dec00204 	addi	sp,sp,8
 908d9dc:	f800283a 	ret

0908d9e0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 908d9e0:	deffeb04 	addi	sp,sp,-84
 908d9e4:	dfc01415 	stw	ra,80(sp)
 908d9e8:	df001315 	stw	fp,76(sp)
 908d9ec:	df001304 	addi	fp,sp,76
 908d9f0:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908d9f4:	e0bffd17 	ldw	r2,-12(fp)
 908d9f8:	1004803a 	cmplt	r2,r2,zero
 908d9fc:	1000081e 	bne	r2,zero,908da20 <isatty+0x40>
 908da00:	e0bffd17 	ldw	r2,-12(fp)
 908da04:	10800324 	muli	r2,r2,12
 908da08:	1007883a 	mov	r3,r2
 908da0c:	00824374 	movhi	r2,2317
 908da10:	108dc104 	addi	r2,r2,14084
 908da14:	1887883a 	add	r3,r3,r2
 908da18:	e0ffff15 	stw	r3,-4(fp)
 908da1c:	00000106 	br	908da24 <isatty+0x44>
 908da20:	e03fff15 	stw	zero,-4(fp)
 908da24:	e0bfff17 	ldw	r2,-4(fp)
 908da28:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 908da2c:	e0bfed17 	ldw	r2,-76(fp)
 908da30:	1005003a 	cmpeq	r2,r2,zero
 908da34:	10000f1e 	bne	r2,zero,908da74 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 908da38:	e0bfed17 	ldw	r2,-76(fp)
 908da3c:	10800017 	ldw	r2,0(r2)
 908da40:	10800817 	ldw	r2,32(r2)
 908da44:	1004c03a 	cmpne	r2,r2,zero
 908da48:	1000031e 	bne	r2,zero,908da58 <isatty+0x78>
    {
      return 1;
 908da4c:	00800044 	movi	r2,1
 908da50:	e0bffe15 	stw	r2,-8(fp)
 908da54:	00000c06 	br	908da88 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 908da58:	e17fee04 	addi	r5,fp,-72
 908da5c:	e13ffd17 	ldw	r4,-12(fp)
 908da60:	908d8ac0 	call	908d8ac <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 908da64:	e0bfef17 	ldw	r2,-68(fp)
 908da68:	10880020 	cmpeqi	r2,r2,8192
 908da6c:	e0bffe15 	stw	r2,-8(fp)
 908da70:	00000506 	br	908da88 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 908da74:	908daa00 	call	908daa0 <alt_get_errno>
 908da78:	1007883a 	mov	r3,r2
 908da7c:	00801444 	movi	r2,81
 908da80:	18800015 	stw	r2,0(r3)
    return 0;
 908da84:	e03ffe15 	stw	zero,-8(fp)
 908da88:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 908da8c:	e037883a 	mov	sp,fp
 908da90:	dfc00117 	ldw	ra,4(sp)
 908da94:	df000017 	ldw	fp,0(sp)
 908da98:	dec00204 	addi	sp,sp,8
 908da9c:	f800283a 	ret

0908daa0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908daa0:	defffd04 	addi	sp,sp,-12
 908daa4:	dfc00215 	stw	ra,8(sp)
 908daa8:	df000115 	stw	fp,4(sp)
 908daac:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908dab0:	00824374 	movhi	r2,2317
 908dab4:	108eca04 	addi	r2,r2,15144
 908dab8:	10800017 	ldw	r2,0(r2)
 908dabc:	1005003a 	cmpeq	r2,r2,zero
 908dac0:	1000061e 	bne	r2,zero,908dadc <alt_get_errno+0x3c>
 908dac4:	00824374 	movhi	r2,2317
 908dac8:	108eca04 	addi	r2,r2,15144
 908dacc:	10800017 	ldw	r2,0(r2)
 908dad0:	103ee83a 	callr	r2
 908dad4:	e0bfff15 	stw	r2,-4(fp)
 908dad8:	00000306 	br	908dae8 <alt_get_errno+0x48>
 908dadc:	00824374 	movhi	r2,2317
 908dae0:	108ee904 	addi	r2,r2,15268
 908dae4:	e0bfff15 	stw	r2,-4(fp)
 908dae8:	e0bfff17 	ldw	r2,-4(fp)
}
 908daec:	e037883a 	mov	sp,fp
 908daf0:	dfc00117 	ldw	ra,4(sp)
 908daf4:	df000017 	ldw	fp,0(sp)
 908daf8:	dec00204 	addi	sp,sp,8
 908dafc:	f800283a 	ret

0908db00 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 908db00:	defff804 	addi	sp,sp,-32
 908db04:	dfc00715 	stw	ra,28(sp)
 908db08:	df000615 	stw	fp,24(sp)
 908db0c:	df000604 	addi	fp,sp,24
 908db10:	e13ffc15 	stw	r4,-16(fp)
 908db14:	e17ffd15 	stw	r5,-12(fp)
 908db18:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 908db1c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 908db20:	e0bffc17 	ldw	r2,-16(fp)
 908db24:	1004803a 	cmplt	r2,r2,zero
 908db28:	1000081e 	bne	r2,zero,908db4c <lseek+0x4c>
 908db2c:	e0bffc17 	ldw	r2,-16(fp)
 908db30:	10800324 	muli	r2,r2,12
 908db34:	1007883a 	mov	r3,r2
 908db38:	00824374 	movhi	r2,2317
 908db3c:	108dc104 	addi	r2,r2,14084
 908db40:	1887883a 	add	r3,r3,r2
 908db44:	e0ffff15 	stw	r3,-4(fp)
 908db48:	00000106 	br	908db50 <lseek+0x50>
 908db4c:	e03fff15 	stw	zero,-4(fp)
 908db50:	e0bfff17 	ldw	r2,-4(fp)
 908db54:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 908db58:	e0bffb17 	ldw	r2,-20(fp)
 908db5c:	1005003a 	cmpeq	r2,r2,zero
 908db60:	1000111e 	bne	r2,zero,908dba8 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 908db64:	e0bffb17 	ldw	r2,-20(fp)
 908db68:	10800017 	ldw	r2,0(r2)
 908db6c:	10800717 	ldw	r2,28(r2)
 908db70:	1005003a 	cmpeq	r2,r2,zero
 908db74:	1000091e 	bne	r2,zero,908db9c <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 908db78:	e0bffb17 	ldw	r2,-20(fp)
 908db7c:	10800017 	ldw	r2,0(r2)
 908db80:	10800717 	ldw	r2,28(r2)
 908db84:	e13ffb17 	ldw	r4,-20(fp)
 908db88:	e17ffd17 	ldw	r5,-12(fp)
 908db8c:	e1bffe17 	ldw	r6,-8(fp)
 908db90:	103ee83a 	callr	r2
 908db94:	e0bffa15 	stw	r2,-24(fp)
 908db98:	00000506 	br	908dbb0 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 908db9c:	00bfde84 	movi	r2,-134
 908dba0:	e0bffa15 	stw	r2,-24(fp)
 908dba4:	00000206 	br	908dbb0 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 908dba8:	00bfebc4 	movi	r2,-81
 908dbac:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 908dbb0:	e0bffa17 	ldw	r2,-24(fp)
 908dbb4:	1004403a 	cmpge	r2,r2,zero
 908dbb8:	1000071e 	bne	r2,zero,908dbd8 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 908dbbc:	908dbf00 	call	908dbf0 <alt_get_errno>
 908dbc0:	1007883a 	mov	r3,r2
 908dbc4:	e0bffa17 	ldw	r2,-24(fp)
 908dbc8:	0085c83a 	sub	r2,zero,r2
 908dbcc:	18800015 	stw	r2,0(r3)
    rc = -1;
 908dbd0:	00bfffc4 	movi	r2,-1
 908dbd4:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 908dbd8:	e0bffa17 	ldw	r2,-24(fp)
}
 908dbdc:	e037883a 	mov	sp,fp
 908dbe0:	dfc00117 	ldw	ra,4(sp)
 908dbe4:	df000017 	ldw	fp,0(sp)
 908dbe8:	dec00204 	addi	sp,sp,8
 908dbec:	f800283a 	ret

0908dbf0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 908dbf0:	defffd04 	addi	sp,sp,-12
 908dbf4:	dfc00215 	stw	ra,8(sp)
 908dbf8:	df000115 	stw	fp,4(sp)
 908dbfc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 908dc00:	00824374 	movhi	r2,2317
 908dc04:	108eca04 	addi	r2,r2,15144
 908dc08:	10800017 	ldw	r2,0(r2)
 908dc0c:	1005003a 	cmpeq	r2,r2,zero
 908dc10:	1000061e 	bne	r2,zero,908dc2c <alt_get_errno+0x3c>
 908dc14:	00824374 	movhi	r2,2317
 908dc18:	108eca04 	addi	r2,r2,15144
 908dc1c:	10800017 	ldw	r2,0(r2)
 908dc20:	103ee83a 	callr	r2
 908dc24:	e0bfff15 	stw	r2,-4(fp)
 908dc28:	00000306 	br	908dc38 <alt_get_errno+0x48>
 908dc2c:	00824374 	movhi	r2,2317
 908dc30:	108ee904 	addi	r2,r2,15268
 908dc34:	e0bfff15 	stw	r2,-4(fp)
 908dc38:	e0bfff17 	ldw	r2,-4(fp)
}
 908dc3c:	e037883a 	mov	sp,fp
 908dc40:	dfc00117 	ldw	ra,4(sp)
 908dc44:	df000017 	ldw	fp,0(sp)
 908dc48:	dec00204 	addi	sp,sp,8
 908dc4c:	f800283a 	ret

0908dc50 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 908dc50:	defffc04 	addi	sp,sp,-16
 908dc54:	dfc00315 	stw	ra,12(sp)
 908dc58:	df000215 	stw	fp,8(sp)
 908dc5c:	df000204 	addi	fp,sp,8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 908dc60:	0009883a 	mov	r4,zero
 908dc64:	90964580 	call	9096458 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 908dc68:	908e9cc0 	call	908e9cc <OSInit>
 908dc6c:	01000044 	movi	r4,1
 908dc70:	90938a80 	call	90938a8 <OSSemCreate>
 908dc74:	1007883a 	mov	r3,r2
 908dc78:	00824374 	movhi	r2,2317
 908dc7c:	108eee04 	addi	r2,r2,15288
 908dc80:	10c00015 	stw	r3,0(r2)
 908dc84:	01000044 	movi	r4,1
 908dc88:	90938a80 	call	90938a8 <OSSemCreate>
 908dc8c:	1007883a 	mov	r3,r2
 908dc90:	00824374 	movhi	r2,2317
 908dc94:	108ef004 	addi	r2,r2,15296
 908dc98:	10c00015 	stw	r3,0(r2)
 908dc9c:	00824374 	movhi	r2,2317
 908dca0:	108f3c04 	addi	r2,r2,15600
 908dca4:	e0bffe15 	stw	r2,-8(fp)
 908dca8:	00800044 	movi	r2,1
 908dcac:	e0bfff0d 	sth	r2,-4(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 908dcb0:	e13fff0b 	ldhu	r4,-4(fp)
 908dcb4:	90938a80 	call	90938a8 <OSSemCreate>
 908dcb8:	1007883a 	mov	r3,r2
 908dcbc:	e0bffe17 	ldw	r2,-8(fp)
 908dcc0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 908dcc4:	909648c0 	call	909648c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 908dcc8:	01024374 	movhi	r4,2317
 908dccc:	21360c04 	addi	r4,r4,-10192
 908dcd0:	01424374 	movhi	r5,2317
 908dcd4:	29760c04 	addi	r5,r5,-10192
 908dcd8:	01824374 	movhi	r6,2317
 908dcdc:	31b60c04 	addi	r6,r6,-10192
 908dce0:	90ba2e80 	call	90ba2e8 <alt_io_redirect>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 908dce4:	d1206517 	ldw	r4,-32364(gp)
 908dce8:	d1606617 	ldw	r5,-32360(gp)
 908dcec:	d1a06717 	ldw	r6,-32356(gp)
 908dcf0:	90817ec0 	call	90817ec <main>
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 908dcf4:	e037883a 	mov	sp,fp
 908dcf8:	dfc00117 	ldw	ra,4(sp)
 908dcfc:	df000017 	ldw	fp,0(sp)
 908dd00:	dec00204 	addi	sp,sp,8
 908dd04:	f800283a 	ret

0908dd08 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 908dd08:	defff804 	addi	sp,sp,-32
 908dd0c:	df000715 	stw	fp,28(sp)
 908dd10:	df000704 	addi	fp,sp,28
 908dd14:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908dd18:	0005303a 	rdctl	r2,status
 908dd1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908dd20:	e0fffb17 	ldw	r3,-20(fp)
 908dd24:	00bfff84 	movi	r2,-2
 908dd28:	1884703a 	and	r2,r3,r2
 908dd2c:	1001703a 	wrctl	status,r2
  
  return context;
 908dd30:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 908dd34:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 908dd38:	d0a00717 	ldw	r2,-32740(gp)
 908dd3c:	10c000c4 	addi	r3,r2,3
 908dd40:	00bfff04 	movi	r2,-4
 908dd44:	1884703a 	and	r2,r3,r2
 908dd48:	d0a00715 	stw	r2,-32740(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 908dd4c:	d0e00717 	ldw	r3,-32740(gp)
 908dd50:	e0bffe17 	ldw	r2,-8(fp)
 908dd54:	1887883a 	add	r3,r3,r2
 908dd58:	00824434 	movhi	r2,2320
 908dd5c:	10800004 	addi	r2,r2,0
 908dd60:	10c0072e 	bgeu	r2,r3,908dd80 <sbrk+0x78>
 908dd64:	e0bffd17 	ldw	r2,-12(fp)
 908dd68:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908dd6c:	e0bffa17 	ldw	r2,-24(fp)
 908dd70:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 908dd74:	00bfffc4 	movi	r2,-1
 908dd78:	e0bfff15 	stw	r2,-4(fp)
 908dd7c:	00000c06 	br	908ddb0 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 908dd80:	d0a00717 	ldw	r2,-32740(gp)
 908dd84:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 908dd88:	d0e00717 	ldw	r3,-32740(gp)
 908dd8c:	e0bffe17 	ldw	r2,-8(fp)
 908dd90:	1885883a 	add	r2,r3,r2
 908dd94:	d0a00715 	stw	r2,-32740(gp)
 908dd98:	e0bffd17 	ldw	r2,-12(fp)
 908dd9c:	e0bff915 	stw	r2,-28(fp)
 908dda0:	e0bff917 	ldw	r2,-28(fp)
 908dda4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 908dda8:	e0bffc17 	ldw	r2,-16(fp)
 908ddac:	e0bfff15 	stw	r2,-4(fp)
 908ddb0:	e0bfff17 	ldw	r2,-4(fp)
} 
 908ddb4:	e037883a 	mov	sp,fp
 908ddb8:	df000017 	ldw	fp,0(sp)
 908ddbc:	dec00104 	addi	sp,sp,4
 908ddc0:	f800283a 	ret

0908ddc4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 908ddc4:	deffdf04 	addi	sp,sp,-132
 908ddc8:	dfc02015 	stw	ra,128(sp)
 908ddcc:	df001f15 	stw	fp,124(sp)
 908ddd0:	df001f04 	addi	fp,sp,124
 908ddd4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 908ddd8:	e17fe204 	addi	r5,fp,-120
 908dddc:	01003fc4 	movi	r4,255
 908dde0:	9095c300 	call	9095c30 <OSTaskQuery>
 908dde4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 908dde8:	e0bffe83 	ldbu	r2,-6(fp)
 908ddec:	10803fcc 	andi	r2,r2,255
 908ddf0:	1004c03a 	cmpne	r2,r2,zero
 908ddf4:	1000191e 	bne	r2,zero,908de5c <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 908ddf8:	e0bfee83 	ldbu	r2,-70(fp)
 908ddfc:	10803fcc 	andi	r2,r2,255
 908de00:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 908de04:	d1206917 	ldw	r4,-32348(gp)
 908de08:	e17ffd04 	addi	r5,fp,-12
 908de0c:	909417c0 	call	909417c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 908de10:	e0bffe43 	ldbu	r2,-7(fp)
 908de14:	10803fcc 	andi	r2,r2,255
 908de18:	1005003a 	cmpeq	r2,r2,zero
 908de1c:	1000071e 	bne	r2,zero,908de3c <__env_lock+0x78>
 908de20:	d0e00817 	ldw	r3,-32736(gp)
 908de24:	e0bfe117 	ldw	r2,-124(fp)
 908de28:	10c0041e 	bne	r2,r3,908de3c <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 908de2c:	d0a06817 	ldw	r2,-32352(gp)
 908de30:	10800044 	addi	r2,r2,1
 908de34:	d0a06815 	stw	r2,-32352(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 908de38:	00000806 	br	908de5c <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 908de3c:	d1206917 	ldw	r4,-32348(gp)
 908de40:	e1bffe84 	addi	r6,fp,-6
 908de44:	000b883a 	mov	r5,zero
 908de48:	9093c5c0 	call	9093c5c <OSSemPend>
    locks  = 1;
 908de4c:	00800044 	movi	r2,1
 908de50:	d0a06815 	stw	r2,-32352(gp)
    lockid = id;
 908de54:	e0bfe117 	ldw	r2,-124(fp)
 908de58:	d0a00815 	stw	r2,-32736(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 908de5c:	e037883a 	mov	sp,fp
 908de60:	dfc00117 	ldw	ra,4(sp)
 908de64:	df000017 	ldw	fp,0(sp)
 908de68:	dec00204 	addi	sp,sp,8
 908de6c:	f800283a 	ret

0908de70 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 908de70:	defffd04 	addi	sp,sp,-12
 908de74:	dfc00215 	stw	ra,8(sp)
 908de78:	df000115 	stw	fp,4(sp)
 908de7c:	df000104 	addi	fp,sp,4
 908de80:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 908de84:	d0a06817 	ldw	r2,-32352(gp)
 908de88:	1005003a 	cmpeq	r2,r2,zero
 908de8c:	10000a1e 	bne	r2,zero,908deb8 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 908de90:	d0a06817 	ldw	r2,-32352(gp)
 908de94:	10bfffc4 	addi	r2,r2,-1
 908de98:	d0a06815 	stw	r2,-32352(gp)
 908de9c:	d0a06817 	ldw	r2,-32352(gp)
 908dea0:	1004c03a 	cmpne	r2,r2,zero
 908dea4:	1000041e 	bne	r2,zero,908deb8 <__env_unlock+0x48>
  {
    lockid = -1;
 908dea8:	00bfffc4 	movi	r2,-1
 908deac:	d0a00815 	stw	r2,-32736(gp)
    OSSemPost( alt_envsem );
 908deb0:	d1206917 	ldw	r4,-32348(gp)
 908deb4:	90940540 	call	9094054 <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 908deb8:	e037883a 	mov	sp,fp
 908debc:	dfc00117 	ldw	ra,4(sp)
 908dec0:	df000017 	ldw	fp,0(sp)
 908dec4:	dec00204 	addi	sp,sp,8
 908dec8:	f800283a 	ret

0908decc <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 908decc:	deffdb04 	addi	sp,sp,-148
 908ded0:	dfc02415 	stw	ra,144(sp)
 908ded4:	df002315 	stw	fp,140(sp)
 908ded8:	df002304 	addi	fp,sp,140
 908dedc:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908dee0:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 908dee4:	00824374 	movhi	r2,2317
 908dee8:	108ef144 	addi	r2,r2,15301
 908deec:	10800003 	ldbu	r2,0(r2)
 908def0:	10803fcc 	andi	r2,r2,255
 908def4:	10800058 	cmpnei	r2,r2,1
 908def8:	1000311e 	bne	r2,zero,908dfc0 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 908defc:	e17fe204 	addi	r5,fp,-120
 908df00:	01003fc4 	movi	r4,255
 908df04:	9095c300 	call	9095c30 <OSTaskQuery>
 908df08:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 908df0c:	e0bffe83 	ldbu	r2,-6(fp)
 908df10:	10803fcc 	andi	r2,r2,255
 908df14:	1004c03a 	cmpne	r2,r2,zero
 908df18:	1000291e 	bne	r2,zero,908dfc0 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 908df1c:	e0bfee83 	ldbu	r2,-70(fp)
 908df20:	10803fcc 	andi	r2,r2,255
 908df24:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 908df28:	d1206b17 	ldw	r4,-32340(gp)
 908df2c:	e17ffd04 	addi	r5,fp,-12
 908df30:	909417c0 	call	909417c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908df34:	0005303a 	rdctl	r2,status
 908df38:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908df3c:	e0ffdf17 	ldw	r3,-132(fp)
 908df40:	00bfff84 	movi	r2,-2
 908df44:	1884703a 	and	r2,r3,r2
 908df48:	1001703a 	wrctl	status,r2
  
  return context;
 908df4c:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 908df50:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 908df54:	e0bffd0b 	ldhu	r2,-12(fp)
 908df58:	10bfffcc 	andi	r2,r2,65535
 908df5c:	1004c03a 	cmpne	r2,r2,zero
 908df60:	10000b1e 	bne	r2,zero,908df90 <__malloc_lock+0xc4>
 908df64:	d0e00917 	ldw	r3,-32732(gp)
 908df68:	e0bfe117 	ldw	r2,-124(fp)
 908df6c:	10c0081e 	bne	r2,r3,908df90 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 908df70:	d0a06a17 	ldw	r2,-32344(gp)
 908df74:	10800044 	addi	r2,r2,1
 908df78:	d0a06a15 	stw	r2,-32344(gp)
 908df7c:	e0bfe017 	ldw	r2,-128(fp)
 908df80:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908df84:	e0bfde17 	ldw	r2,-136(fp)
 908df88:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 908df8c:	00000c06 	br	908dfc0 <__malloc_lock+0xf4>
 908df90:	e0bfe017 	ldw	r2,-128(fp)
 908df94:	e0bfdd15 	stw	r2,-140(fp)
 908df98:	e0bfdd17 	ldw	r2,-140(fp)
 908df9c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 908dfa0:	d1206b17 	ldw	r4,-32340(gp)
 908dfa4:	e1bffe84 	addi	r6,fp,-6
 908dfa8:	000b883a 	mov	r5,zero
 908dfac:	9093c5c0 	call	9093c5c <OSSemPend>
    locks  = 1;
 908dfb0:	00800044 	movi	r2,1
 908dfb4:	d0a06a15 	stw	r2,-32344(gp)
    lockid = id;
 908dfb8:	e0bfe117 	ldw	r2,-124(fp)
 908dfbc:	d0a00915 	stw	r2,-32732(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 908dfc0:	e037883a 	mov	sp,fp
 908dfc4:	dfc00117 	ldw	ra,4(sp)
 908dfc8:	df000017 	ldw	fp,0(sp)
 908dfcc:	dec00204 	addi	sp,sp,8
 908dfd0:	f800283a 	ret

0908dfd4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 908dfd4:	defff804 	addi	sp,sp,-32
 908dfd8:	dfc00715 	stw	ra,28(sp)
 908dfdc:	df000615 	stw	fp,24(sp)
 908dfe0:	df000604 	addi	fp,sp,24
 908dfe4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908dfe8:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 908dfec:	00824374 	movhi	r2,2317
 908dff0:	108ef144 	addi	r2,r2,15301
 908dff4:	10800003 	ldbu	r2,0(r2)
 908dff8:	10803fcc 	andi	r2,r2,255
 908dffc:	10800058 	cmpnei	r2,r2,1
 908e000:	1000231e 	bne	r2,zero,908e090 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908e004:	0005303a 	rdctl	r2,status
 908e008:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908e00c:	e0fffd17 	ldw	r3,-12(fp)
 908e010:	00bfff84 	movi	r2,-2
 908e014:	1884703a 	and	r2,r3,r2
 908e018:	1001703a 	wrctl	status,r2
  
  return context;
 908e01c:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 908e020:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 908e024:	d0a06a17 	ldw	r2,-32344(gp)
 908e028:	1004c03a 	cmpne	r2,r2,zero
 908e02c:	1000051e 	bne	r2,zero,908e044 <__malloc_unlock+0x70>
 908e030:	e0bffe17 	ldw	r2,-8(fp)
 908e034:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e038:	e0bffc17 	ldw	r2,-16(fp)
 908e03c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 908e040:	00001306 	br	908e090 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 908e044:	d0a06a17 	ldw	r2,-32344(gp)
 908e048:	10bfffc4 	addi	r2,r2,-1
 908e04c:	d0a06a15 	stw	r2,-32344(gp)
 908e050:	d0a06a17 	ldw	r2,-32344(gp)
 908e054:	1004c03a 	cmpne	r2,r2,zero
 908e058:	1000091e 	bne	r2,zero,908e080 <__malloc_unlock+0xac>
  {
    lockid = -1;
 908e05c:	00bfffc4 	movi	r2,-1
 908e060:	d0a00915 	stw	r2,-32732(gp)
 908e064:	e0bffe17 	ldw	r2,-8(fp)
 908e068:	e0bffb15 	stw	r2,-20(fp)
 908e06c:	e0bffb17 	ldw	r2,-20(fp)
 908e070:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 908e074:	d1206b17 	ldw	r4,-32340(gp)
 908e078:	90940540 	call	9094054 <OSSemPost>
 908e07c:	00000406 	br	908e090 <__malloc_unlock+0xbc>
 908e080:	e0bffe17 	ldw	r2,-8(fp)
 908e084:	e0bffa15 	stw	r2,-24(fp)
 908e088:	e0bffa17 	ldw	r2,-24(fp)
 908e08c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 908e090:	e037883a 	mov	sp,fp
 908e094:	dfc00117 	ldw	ra,4(sp)
 908e098:	df000017 	ldw	fp,0(sp)
 908e09c:	dec00204 	addi	sp,sp,8
 908e0a0:	f800283a 	ret

0908e0a4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 908e0a4:	defff604 	addi	sp,sp,-40
 908e0a8:	dfc00915 	stw	ra,36(sp)
 908e0ac:	df000815 	stw	fp,32(sp)
 908e0b0:	df000804 	addi	fp,sp,32
 908e0b4:	e13ffc15 	stw	r4,-16(fp)
 908e0b8:	e17ffd15 	stw	r5,-12(fp)
 908e0bc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908e0c0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908e0c4:	e0bffe17 	ldw	r2,-8(fp)
 908e0c8:	1004c03a 	cmpne	r2,r2,zero
 908e0cc:	1000021e 	bne	r2,zero,908e0d8 <OSEventNameGet+0x34>
        return (0);
 908e0d0:	e03fff15 	stw	zero,-4(fp)
 908e0d4:	00003906 	br	908e1bc <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 908e0d8:	e0bffc17 	ldw	r2,-16(fp)
 908e0dc:	1004c03a 	cmpne	r2,r2,zero
 908e0e0:	1000051e 	bne	r2,zero,908e0f8 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 908e0e4:	e0fffe17 	ldw	r3,-8(fp)
 908e0e8:	00800104 	movi	r2,4
 908e0ec:	18800005 	stb	r2,0(r3)
        return (0);
 908e0f0:	e03fff15 	stw	zero,-4(fp)
 908e0f4:	00003106 	br	908e1bc <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908e0f8:	e0bffd17 	ldw	r2,-12(fp)
 908e0fc:	1004c03a 	cmpne	r2,r2,zero
 908e100:	1000051e 	bne	r2,zero,908e118 <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 908e104:	e0fffe17 	ldw	r3,-8(fp)
 908e108:	00800304 	movi	r2,12
 908e10c:	18800005 	stb	r2,0(r3)
        return (0);
 908e110:	e03fff15 	stw	zero,-4(fp)
 908e114:	00002906 	br	908e1bc <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908e118:	d0a07a03 	ldbu	r2,-32280(gp)
 908e11c:	10803fcc 	andi	r2,r2,255
 908e120:	1005003a 	cmpeq	r2,r2,zero
 908e124:	1000051e 	bne	r2,zero,908e13c <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 908e128:	e0fffe17 	ldw	r3,-8(fp)
 908e12c:	00800444 	movi	r2,17
 908e130:	18800005 	stb	r2,0(r3)
        return (0);
 908e134:	e03fff15 	stw	zero,-4(fp)
 908e138:	00002006 	br	908e1bc <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 908e13c:	e0bffc17 	ldw	r2,-16(fp)
 908e140:	10800003 	ldbu	r2,0(r2)
 908e144:	10803fcc 	andi	r2,r2,255
 908e148:	10bfffc4 	addi	r2,r2,-1
 908e14c:	10800128 	cmpgeui	r2,r2,4
 908e150:	1000161e 	bne	r2,zero,908e1ac <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908e154:	0005303a 	rdctl	r2,status
 908e158:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908e15c:	e0fff917 	ldw	r3,-28(fp)
 908e160:	00bfff84 	movi	r2,-2
 908e164:	1884703a 	and	r2,r3,r2
 908e168:	1001703a 	wrctl	status,r2
  
  return context;
 908e16c:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 908e170:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 908e174:	e0bffc17 	ldw	r2,-16(fp)
 908e178:	11400384 	addi	r5,r2,14
 908e17c:	e13ffd17 	ldw	r4,-12(fp)
 908e180:	908fc280 	call	908fc28 <OS_StrCopy>
 908e184:	e0bffb05 	stb	r2,-20(fp)
 908e188:	e0bffa17 	ldw	r2,-24(fp)
 908e18c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e190:	e0bff817 	ldw	r2,-32(fp)
 908e194:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908e198:	e0bffe17 	ldw	r2,-8(fp)
 908e19c:	10000005 	stb	zero,0(r2)
    return (len);
 908e1a0:	e0bffb03 	ldbu	r2,-20(fp)
 908e1a4:	e0bfff15 	stw	r2,-4(fp)
 908e1a8:	00000406 	br	908e1bc <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 908e1ac:	e0fffe17 	ldw	r3,-8(fp)
 908e1b0:	00800044 	movi	r2,1
 908e1b4:	18800005 	stb	r2,0(r3)
             return (0);
 908e1b8:	e03fff15 	stw	zero,-4(fp)
 908e1bc:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 908e1c0:	e037883a 	mov	sp,fp
 908e1c4:	dfc00117 	ldw	ra,4(sp)
 908e1c8:	df000017 	ldw	fp,0(sp)
 908e1cc:	dec00204 	addi	sp,sp,8
 908e1d0:	f800283a 	ret

0908e1d4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 908e1d4:	defff604 	addi	sp,sp,-40
 908e1d8:	dfc00915 	stw	ra,36(sp)
 908e1dc:	df000815 	stw	fp,32(sp)
 908e1e0:	df000804 	addi	fp,sp,32
 908e1e4:	e13ffd15 	stw	r4,-12(fp)
 908e1e8:	e17ffe15 	stw	r5,-8(fp)
 908e1ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908e1f0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 908e1f4:	e0bfff17 	ldw	r2,-4(fp)
 908e1f8:	1005003a 	cmpeq	r2,r2,zero
 908e1fc:	1000411e 	bne	r2,zero,908e304 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 908e200:	e0bffd17 	ldw	r2,-12(fp)
 908e204:	1004c03a 	cmpne	r2,r2,zero
 908e208:	1000041e 	bne	r2,zero,908e21c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 908e20c:	e0ffff17 	ldw	r3,-4(fp)
 908e210:	00800104 	movi	r2,4
 908e214:	18800005 	stb	r2,0(r3)
        return;
 908e218:	00003a06 	br	908e304 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 908e21c:	e0bffe17 	ldw	r2,-8(fp)
 908e220:	1004c03a 	cmpne	r2,r2,zero
 908e224:	1000041e 	bne	r2,zero,908e238 <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 908e228:	e0ffff17 	ldw	r3,-4(fp)
 908e22c:	00800304 	movi	r2,12
 908e230:	18800005 	stb	r2,0(r3)
        return;
 908e234:	00003306 	br	908e304 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 908e238:	d0a07a03 	ldbu	r2,-32280(gp)
 908e23c:	10803fcc 	andi	r2,r2,255
 908e240:	1005003a 	cmpeq	r2,r2,zero
 908e244:	1000041e 	bne	r2,zero,908e258 <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 908e248:	e0ffff17 	ldw	r3,-4(fp)
 908e24c:	00800484 	movi	r2,18
 908e250:	18800005 	stb	r2,0(r3)
        return;
 908e254:	00002b06 	br	908e304 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 908e258:	e0bffd17 	ldw	r2,-12(fp)
 908e25c:	10800003 	ldbu	r2,0(r2)
 908e260:	10803fcc 	andi	r2,r2,255
 908e264:	10bfffc4 	addi	r2,r2,-1
 908e268:	10800128 	cmpgeui	r2,r2,4
 908e26c:	10000f1e 	bne	r2,zero,908e2ac <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908e270:	0005303a 	rdctl	r2,status
 908e274:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908e278:	e0fffa17 	ldw	r3,-24(fp)
 908e27c:	00bfff84 	movi	r2,-2
 908e280:	1884703a 	and	r2,r3,r2
 908e284:	1001703a 	wrctl	status,r2
  
  return context;
 908e288:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 908e28c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 908e290:	e13ffe17 	ldw	r4,-8(fp)
 908e294:	908fca80 	call	908fca8 <OS_StrLen>
 908e298:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 908e29c:	e0bffc03 	ldbu	r2,-16(fp)
 908e2a0:	10800828 	cmpgeui	r2,r2,32
 908e2a4:	1000051e 	bne	r2,zero,908e2bc <OSEventNameSet+0xe8>
 908e2a8:	00000c06 	br	908e2dc <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 908e2ac:	e0ffff17 	ldw	r3,-4(fp)
 908e2b0:	00800044 	movi	r2,1
 908e2b4:	18800005 	stb	r2,0(r3)
             return;
 908e2b8:	00001206 	br	908e304 <OSEventNameSet+0x130>
 908e2bc:	e0bffb17 	ldw	r2,-20(fp)
 908e2c0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e2c4:	e0bff917 	ldw	r2,-28(fp)
 908e2c8:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 908e2cc:	e0ffff17 	ldw	r3,-4(fp)
 908e2d0:	008002c4 	movi	r2,11
 908e2d4:	18800005 	stb	r2,0(r3)
        return;
 908e2d8:	00000a06 	br	908e304 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 908e2dc:	e0bffd17 	ldw	r2,-12(fp)
 908e2e0:	11000384 	addi	r4,r2,14
 908e2e4:	e17ffe17 	ldw	r5,-8(fp)
 908e2e8:	908fc280 	call	908fc28 <OS_StrCopy>
 908e2ec:	e0bffb17 	ldw	r2,-20(fp)
 908e2f0:	e0bff815 	stw	r2,-32(fp)
 908e2f4:	e0bff817 	ldw	r2,-32(fp)
 908e2f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 908e2fc:	e0bfff17 	ldw	r2,-4(fp)
 908e300:	10000005 	stb	zero,0(r2)
}
 908e304:	e037883a 	mov	sp,fp
 908e308:	dfc00117 	ldw	ra,4(sp)
 908e30c:	df000017 	ldw	fp,0(sp)
 908e310:	dec00204 	addi	sp,sp,8
 908e314:	f800283a 	ret

0908e318 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 908e318:	deffe704 	addi	sp,sp,-100
 908e31c:	dfc01815 	stw	ra,96(sp)
 908e320:	df001715 	stw	fp,92(sp)
 908e324:	df001704 	addi	fp,sp,92
 908e328:	e13ff615 	stw	r4,-40(fp)
 908e32c:	e17ff715 	stw	r5,-36(fp)
 908e330:	e1bff815 	stw	r6,-32(fp)
 908e334:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 908e338:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 908e33c:	e0800217 	ldw	r2,8(fp)
 908e340:	1004c03a 	cmpne	r2,r2,zero
 908e344:	1000021e 	bne	r2,zero,908e350 <OSEventPendMulti+0x38>
        return (0);
 908e348:	e03fff15 	stw	zero,-4(fp)
 908e34c:	00019906 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 908e350:	e0bff617 	ldw	r2,-40(fp)
 908e354:	1004c03a 	cmpne	r2,r2,zero
 908e358:	1000051e 	bne	r2,zero,908e370 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 908e35c:	e0c00217 	ldw	r3,8(fp)
 908e360:	00800104 	movi	r2,4
 908e364:	18800005 	stb	r2,0(r3)
        return (0);
 908e368:	e03fff15 	stw	zero,-4(fp)
 908e36c:	00019106 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 908e370:	e0bff717 	ldw	r2,-36(fp)
 908e374:	1004c03a 	cmpne	r2,r2,zero
 908e378:	1000051e 	bne	r2,zero,908e390 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 908e37c:	e0c00217 	ldw	r3,8(fp)
 908e380:	00800104 	movi	r2,4
 908e384:	18800005 	stb	r2,0(r3)
        return (0);
 908e388:	e03fff15 	stw	zero,-4(fp)
 908e38c:	00018906 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 908e390:	e0bff817 	ldw	r2,-32(fp)
 908e394:	1004c03a 	cmpne	r2,r2,zero
 908e398:	1000051e 	bne	r2,zero,908e3b0 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 908e39c:	e0c00217 	ldw	r3,8(fp)
 908e3a0:	00800104 	movi	r2,4
 908e3a4:	18800005 	stb	r2,0(r3)
        return (0);
 908e3a8:	e03fff15 	stw	zero,-4(fp)
 908e3ac:	00018106 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 908e3b0:	e0bff717 	ldw	r2,-36(fp)
 908e3b4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 908e3b8:	e0bff617 	ldw	r2,-40(fp)
 908e3bc:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 908e3c0:	e0bff517 	ldw	r2,-44(fp)
 908e3c4:	10800017 	ldw	r2,0(r2)
 908e3c8:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 908e3cc:	00001806 	br	908e430 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 908e3d0:	e0bff417 	ldw	r2,-48(fp)
 908e3d4:	10800003 	ldbu	r2,0(r2)
 908e3d8:	10803fcc 	andi	r2,r2,255
 908e3dc:	e0bffe15 	stw	r2,-8(fp)
 908e3e0:	e0fffe17 	ldw	r3,-8(fp)
 908e3e4:	188000a0 	cmpeqi	r2,r3,2
 908e3e8:	10000b1e 	bne	r2,zero,908e418 <OSEventPendMulti+0x100>
 908e3ec:	e0fffe17 	ldw	r3,-8(fp)
 908e3f0:	188000e0 	cmpeqi	r2,r3,3
 908e3f4:	1000081e 	bne	r2,zero,908e418 <OSEventPendMulti+0x100>
 908e3f8:	e0fffe17 	ldw	r3,-8(fp)
 908e3fc:	18800060 	cmpeqi	r2,r3,1
 908e400:	1000051e 	bne	r2,zero,908e418 <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 908e404:	e0c00217 	ldw	r3,8(fp)
 908e408:	00800044 	movi	r2,1
 908e40c:	18800005 	stb	r2,0(r3)
                 return (0);
 908e410:	e03fff15 	stw	zero,-4(fp)
 908e414:	00016706 	br	908e9b4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 908e418:	e0bff517 	ldw	r2,-44(fp)
 908e41c:	10800104 	addi	r2,r2,4
 908e420:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 908e424:	e0bff517 	ldw	r2,-44(fp)
 908e428:	10800017 	ldw	r2,0(r2)
 908e42c:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 908e430:	e0bff417 	ldw	r2,-48(fp)
 908e434:	1004c03a 	cmpne	r2,r2,zero
 908e438:	103fe51e 	bne	r2,zero,908e3d0 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 908e43c:	d0a07a03 	ldbu	r2,-32280(gp)
 908e440:	10803fcc 	andi	r2,r2,255
 908e444:	1005003a 	cmpeq	r2,r2,zero
 908e448:	1000051e 	bne	r2,zero,908e460 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 908e44c:	e0c00217 	ldw	r3,8(fp)
 908e450:	00800084 	movi	r2,2
 908e454:	18800005 	stb	r2,0(r3)
        return (0);
 908e458:	e03fff15 	stw	zero,-4(fp)
 908e45c:	00015506 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 908e460:	d0a06c03 	ldbu	r2,-32336(gp)
 908e464:	10803fcc 	andi	r2,r2,255
 908e468:	1005003a 	cmpeq	r2,r2,zero
 908e46c:	1000051e 	bne	r2,zero,908e484 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 908e470:	e0c00217 	ldw	r3,8(fp)
 908e474:	00800344 	movi	r2,13
 908e478:	18800005 	stb	r2,0(r3)
        return (0);
 908e47c:	e03fff15 	stw	zero,-4(fp)
 908e480:	00014c06 	br	908e9b4 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908e484:	0005303a 	rdctl	r2,status
 908e488:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908e48c:	e0ffef17 	ldw	r3,-68(fp)
 908e490:	00bfff84 	movi	r2,-2
 908e494:	1884703a 	and	r2,r3,r2
 908e498:	1001703a 	wrctl	status,r2
  
  return context;
 908e49c:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 908e4a0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 908e4a4:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 908e4a8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 908e4ac:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 908e4b0:	e0bff617 	ldw	r2,-40(fp)
 908e4b4:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 908e4b8:	e0bff517 	ldw	r2,-44(fp)
 908e4bc:	10800017 	ldw	r2,0(r2)
 908e4c0:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 908e4c4:	00008f06 	br	908e704 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 908e4c8:	e0bff417 	ldw	r2,-48(fp)
 908e4cc:	10800003 	ldbu	r2,0(r2)
 908e4d0:	10803fcc 	andi	r2,r2,255
 908e4d4:	e0bffd15 	stw	r2,-12(fp)
 908e4d8:	e0fffd17 	ldw	r3,-12(fp)
 908e4dc:	188000a0 	cmpeqi	r2,r3,2
 908e4e0:	1000441e 	bne	r2,zero,908e5f4 <OSEventPendMulti+0x2dc>
 908e4e4:	e0fffd17 	ldw	r3,-12(fp)
 908e4e8:	188000e0 	cmpeqi	r2,r3,3
 908e4ec:	1000041e 	bne	r2,zero,908e500 <OSEventPendMulti+0x1e8>
 908e4f0:	e0fffd17 	ldw	r3,-12(fp)
 908e4f4:	18800060 	cmpeqi	r2,r3,1
 908e4f8:	1000211e 	bne	r2,zero,908e580 <OSEventPendMulti+0x268>
 908e4fc:	00006f06 	br	908e6bc <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 908e500:	e0bff417 	ldw	r2,-48(fp)
 908e504:	1080020b 	ldhu	r2,8(r2)
 908e508:	10bfffcc 	andi	r2,r2,65535
 908e50c:	1005003a 	cmpeq	r2,r2,zero
 908e510:	1000171e 	bne	r2,zero,908e570 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 908e514:	e0bff417 	ldw	r2,-48(fp)
 908e518:	1080020b 	ldhu	r2,8(r2)
 908e51c:	10bfffc4 	addi	r2,r2,-1
 908e520:	1007883a 	mov	r3,r2
 908e524:	e0bff417 	ldw	r2,-48(fp)
 908e528:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 908e52c:	e0fff717 	ldw	r3,-36(fp)
 908e530:	e0bff417 	ldw	r2,-48(fp)
 908e534:	18800015 	stw	r2,0(r3)
 908e538:	e0bff717 	ldw	r2,-36(fp)
 908e53c:	10800104 	addi	r2,r2,4
 908e540:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 908e544:	00800044 	movi	r2,1
 908e548:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 908e54c:	e0bff817 	ldw	r2,-32(fp)
 908e550:	10000015 	stw	zero,0(r2)
 908e554:	e0bff817 	ldw	r2,-32(fp)
 908e558:	10800104 	addi	r2,r2,4
 908e55c:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 908e560:	e0bff18b 	ldhu	r2,-58(fp)
 908e564:	10800044 	addi	r2,r2,1
 908e568:	e0bff18d 	sth	r2,-58(fp)
 908e56c:	00005f06 	br	908e6ec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 908e570:	e0bff103 	ldbu	r2,-60(fp)
 908e574:	10800054 	ori	r2,r2,1
 908e578:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908e57c:	00005b06 	br	908e6ec <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 908e580:	e0bff417 	ldw	r2,-48(fp)
 908e584:	10800117 	ldw	r2,4(r2)
 908e588:	1005003a 	cmpeq	r2,r2,zero
 908e58c:	1000151e 	bne	r2,zero,908e5e4 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 908e590:	e0bff417 	ldw	r2,-48(fp)
 908e594:	10c00117 	ldw	r3,4(r2)
 908e598:	e0bff817 	ldw	r2,-32(fp)
 908e59c:	10c00015 	stw	r3,0(r2)
 908e5a0:	e0bff817 	ldw	r2,-32(fp)
 908e5a4:	10800104 	addi	r2,r2,4
 908e5a8:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 908e5ac:	e0bff417 	ldw	r2,-48(fp)
 908e5b0:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 908e5b4:	e0fff717 	ldw	r3,-36(fp)
 908e5b8:	e0bff417 	ldw	r2,-48(fp)
 908e5bc:	18800015 	stw	r2,0(r3)
 908e5c0:	e0bff717 	ldw	r2,-36(fp)
 908e5c4:	10800104 	addi	r2,r2,4
 908e5c8:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 908e5cc:	00800044 	movi	r2,1
 908e5d0:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 908e5d4:	e0bff18b 	ldhu	r2,-58(fp)
 908e5d8:	10800044 	addi	r2,r2,1
 908e5dc:	e0bff18d 	sth	r2,-58(fp)
 908e5e0:	00004206 	br	908e6ec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 908e5e4:	e0bff103 	ldbu	r2,-60(fp)
 908e5e8:	10800094 	ori	r2,r2,2
 908e5ec:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908e5f0:	00003e06 	br	908e6ec <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 908e5f4:	e0bff417 	ldw	r2,-48(fp)
 908e5f8:	10800117 	ldw	r2,4(r2)
 908e5fc:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 908e600:	e0bff317 	ldw	r2,-52(fp)
 908e604:	1080058b 	ldhu	r2,22(r2)
 908e608:	10bfffcc 	andi	r2,r2,65535
 908e60c:	1005003a 	cmpeq	r2,r2,zero
 908e610:	1000261e 	bne	r2,zero,908e6ac <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 908e614:	e0bff317 	ldw	r2,-52(fp)
 908e618:	11000417 	ldw	r4,16(r2)
 908e61c:	20c00017 	ldw	r3,0(r4)
 908e620:	e0bff817 	ldw	r2,-32(fp)
 908e624:	10c00015 	stw	r3,0(r2)
 908e628:	e0bff817 	ldw	r2,-32(fp)
 908e62c:	10800104 	addi	r2,r2,4
 908e630:	e0bff815 	stw	r2,-32(fp)
 908e634:	20c00104 	addi	r3,r4,4
 908e638:	e0bff317 	ldw	r2,-52(fp)
 908e63c:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 908e640:	e0bff317 	ldw	r2,-52(fp)
 908e644:	10c00417 	ldw	r3,16(r2)
 908e648:	e0bff317 	ldw	r2,-52(fp)
 908e64c:	10800217 	ldw	r2,8(r2)
 908e650:	1880041e 	bne	r3,r2,908e664 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 908e654:	e0bff317 	ldw	r2,-52(fp)
 908e658:	10c00117 	ldw	r3,4(r2)
 908e65c:	e0bff317 	ldw	r2,-52(fp)
 908e660:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 908e664:	e0bff317 	ldw	r2,-52(fp)
 908e668:	1080058b 	ldhu	r2,22(r2)
 908e66c:	10bfffc4 	addi	r2,r2,-1
 908e670:	1007883a 	mov	r3,r2
 908e674:	e0bff317 	ldw	r2,-52(fp)
 908e678:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 908e67c:	e0fff717 	ldw	r3,-36(fp)
 908e680:	e0bff417 	ldw	r2,-48(fp)
 908e684:	18800015 	stw	r2,0(r3)
 908e688:	e0bff717 	ldw	r2,-36(fp)
 908e68c:	10800104 	addi	r2,r2,4
 908e690:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 908e694:	00800044 	movi	r2,1
 908e698:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 908e69c:	e0bff18b 	ldhu	r2,-58(fp)
 908e6a0:	10800044 	addi	r2,r2,1
 908e6a4:	e0bff18d 	sth	r2,-58(fp)
 908e6a8:	00001006 	br	908e6ec <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 908e6ac:	e0bff103 	ldbu	r2,-60(fp)
 908e6b0:	10800114 	ori	r2,r2,4
 908e6b4:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 908e6b8:	00000c06 	br	908e6ec <OSEventPendMulti+0x3d4>
 908e6bc:	e0bff017 	ldw	r2,-64(fp)
 908e6c0:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e6c4:	e0bfee17 	ldw	r2,-72(fp)
 908e6c8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 908e6cc:	e0bff717 	ldw	r2,-36(fp)
 908e6d0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 908e6d4:	e0c00217 	ldw	r3,8(fp)
 908e6d8:	00800044 	movi	r2,1
 908e6dc:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 908e6e0:	e0bff18b 	ldhu	r2,-58(fp)
 908e6e4:	e0bfff15 	stw	r2,-4(fp)
 908e6e8:	0000b206 	br	908e9b4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 908e6ec:	e0bff517 	ldw	r2,-44(fp)
 908e6f0:	10800104 	addi	r2,r2,4
 908e6f4:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 908e6f8:	e0bff517 	ldw	r2,-44(fp)
 908e6fc:	10800017 	ldw	r2,0(r2)
 908e700:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 908e704:	e0bff417 	ldw	r2,-48(fp)
 908e708:	1004c03a 	cmpne	r2,r2,zero
 908e70c:	103f6e1e 	bne	r2,zero,908e4c8 <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 908e710:	e0bff203 	ldbu	r2,-56(fp)
 908e714:	10800058 	cmpnei	r2,r2,1
 908e718:	10000b1e 	bne	r2,zero,908e748 <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 908e71c:	e0bff717 	ldw	r2,-36(fp)
 908e720:	10000015 	stw	zero,0(r2)
 908e724:	e0bff017 	ldw	r2,-64(fp)
 908e728:	e0bfed15 	stw	r2,-76(fp)
 908e72c:	e0bfed17 	ldw	r2,-76(fp)
 908e730:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 908e734:	e0800217 	ldw	r2,8(fp)
 908e738:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 908e73c:	e0fff18b 	ldhu	r3,-58(fp)
 908e740:	e0ffff15 	stw	r3,-4(fp)
 908e744:	00009b06 	br	908e9b4 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 908e748:	d1207b17 	ldw	r4,-32276(gp)
 908e74c:	d0a07b17 	ldw	r2,-32276(gp)
 908e750:	10c00c03 	ldbu	r3,48(r2)
 908e754:	e0bff103 	ldbu	r2,-60(fp)
 908e758:	1884b03a 	or	r2,r3,r2
 908e75c:	1007883a 	mov	r3,r2
 908e760:	00bfe004 	movi	r2,-128
 908e764:	1884b03a 	or	r2,r3,r2
 908e768:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 908e76c:	d0a07b17 	ldw	r2,-32276(gp)
 908e770:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 908e774:	d0e07b17 	ldw	r3,-32276(gp)
 908e778:	e0bff90b 	ldhu	r2,-28(fp)
 908e77c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 908e780:	e13ff617 	ldw	r4,-40(fp)
 908e784:	908f3480 	call	908f348 <OS_EventTaskWaitMulti>
 908e788:	e0bff017 	ldw	r2,-64(fp)
 908e78c:	e0bfec15 	stw	r2,-80(fp)
 908e790:	e0bfec17 	ldw	r2,-80(fp)
 908e794:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 908e798:	908fae40 	call	908fae4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908e79c:	0005303a 	rdctl	r2,status
 908e7a0:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908e7a4:	e0ffeb17 	ldw	r3,-84(fp)
 908e7a8:	00bfff84 	movi	r2,-2
 908e7ac:	1884703a 	and	r2,r3,r2
 908e7b0:	1001703a 	wrctl	status,r2
  
  return context;
 908e7b4:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 908e7b8:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 908e7bc:	d0a07b17 	ldw	r2,-32276(gp)
 908e7c0:	10800c43 	ldbu	r2,49(r2)
 908e7c4:	10803fcc 	andi	r2,r2,255
 908e7c8:	e0bffc15 	stw	r2,-16(fp)
 908e7cc:	e0fffc17 	ldw	r3,-16(fp)
 908e7d0:	1805003a 	cmpeq	r2,r3,zero
 908e7d4:	1000041e 	bne	r2,zero,908e7e8 <OSEventPendMulti+0x4d0>
 908e7d8:	e0fffc17 	ldw	r3,-16(fp)
 908e7dc:	188000a0 	cmpeqi	r2,r3,2
 908e7e0:	1000011e 	bne	r2,zero,908e7e8 <OSEventPendMulti+0x4d0>
 908e7e4:	00001906 	br	908e84c <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 908e7e8:	d0a07b17 	ldw	r2,-32276(gp)
 908e7ec:	10800717 	ldw	r2,28(r2)
 908e7f0:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 908e7f4:	e0bff417 	ldw	r2,-48(fp)
 908e7f8:	1005003a 	cmpeq	r2,r2,zero
 908e7fc:	10000c1e 	bne	r2,zero,908e830 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 908e800:	e0fff717 	ldw	r3,-36(fp)
 908e804:	e0bff417 	ldw	r2,-48(fp)
 908e808:	18800015 	stw	r2,0(r3)
 908e80c:	e0bff717 	ldw	r2,-36(fp)
 908e810:	10800104 	addi	r2,r2,4
 908e814:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 908e818:	e0bff717 	ldw	r2,-36(fp)
 908e81c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 908e820:	e0bff18b 	ldhu	r2,-58(fp)
 908e824:	10800044 	addi	r2,r2,1
 908e828:	e0bff18d 	sth	r2,-58(fp)
 908e82c:	00000a06 	br	908e858 <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 908e830:	d0a07b17 	ldw	r2,-32276(gp)
 908e834:	00c00044 	movi	r3,1
 908e838:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 908e83c:	d1207b17 	ldw	r4,-32276(gp)
 908e840:	e17ff617 	ldw	r5,-40(fp)
 908e844:	908f5540 	call	908f554 <OS_EventTaskRemoveMulti>
             }
			 break;
 908e848:	00000306 	br	908e858 <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 908e84c:	d1207b17 	ldw	r4,-32276(gp)
 908e850:	e17ff617 	ldw	r5,-40(fp)
 908e854:	908f5540 	call	908f554 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 908e858:	d0a07b17 	ldw	r2,-32276(gp)
 908e85c:	10800c43 	ldbu	r2,49(r2)
 908e860:	10803fcc 	andi	r2,r2,255
 908e864:	e0bffb15 	stw	r2,-20(fp)
 908e868:	e0fffb17 	ldw	r3,-20(fp)
 908e86c:	1805003a 	cmpeq	r2,r3,zero
 908e870:	1000041e 	bne	r2,zero,908e884 <OSEventPendMulti+0x56c>
 908e874:	e0fffb17 	ldw	r3,-20(fp)
 908e878:	188000a0 	cmpeqi	r2,r3,2
 908e87c:	10002c1e 	bne	r2,zero,908e930 <OSEventPendMulti+0x618>
 908e880:	00003406 	br	908e954 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 908e884:	e0bff417 	ldw	r2,-48(fp)
 908e888:	10800003 	ldbu	r2,0(r2)
 908e88c:	10803fcc 	andi	r2,r2,255
 908e890:	e0bffa15 	stw	r2,-24(fp)
 908e894:	e0fffa17 	ldw	r3,-24(fp)
 908e898:	18800050 	cmplti	r2,r3,1
 908e89c:	1000151e 	bne	r2,zero,908e8f4 <OSEventPendMulti+0x5dc>
 908e8a0:	e0fffa17 	ldw	r3,-24(fp)
 908e8a4:	188000d0 	cmplti	r2,r3,3
 908e8a8:	10000a1e 	bne	r2,zero,908e8d4 <OSEventPendMulti+0x5bc>
 908e8ac:	e0fffa17 	ldw	r3,-24(fp)
 908e8b0:	188000e0 	cmpeqi	r2,r3,3
 908e8b4:	1000011e 	bne	r2,zero,908e8bc <OSEventPendMulti+0x5a4>
 908e8b8:	00000e06 	br	908e8f4 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 908e8bc:	e0bff817 	ldw	r2,-32(fp)
 908e8c0:	10000015 	stw	zero,0(r2)
 908e8c4:	e0bff817 	ldw	r2,-32(fp)
 908e8c8:	10800104 	addi	r2,r2,4
 908e8cc:	e0bff815 	stw	r2,-32(fp)
                      break;
 908e8d0:	00001406 	br	908e924 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 908e8d4:	d0a07b17 	ldw	r2,-32276(gp)
 908e8d8:	10c00917 	ldw	r3,36(r2)
 908e8dc:	e0bff817 	ldw	r2,-32(fp)
 908e8e0:	10c00015 	stw	r3,0(r2)
 908e8e4:	e0bff817 	ldw	r2,-32(fp)
 908e8e8:	10800104 	addi	r2,r2,4
 908e8ec:	e0bff815 	stw	r2,-32(fp)
                      break;
 908e8f0:	00000c06 	br	908e924 <OSEventPendMulti+0x60c>
 908e8f4:	e0bff017 	ldw	r2,-64(fp)
 908e8f8:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908e8fc:	e0bfea17 	ldw	r2,-88(fp)
 908e900:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 908e904:	e0bff717 	ldw	r2,-36(fp)
 908e908:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 908e90c:	e0c00217 	ldw	r3,8(fp)
 908e910:	00800044 	movi	r2,1
 908e914:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 908e918:	e0bff18b 	ldhu	r2,-58(fp)
 908e91c:	e0bfff15 	stw	r2,-4(fp)
 908e920:	00002406 	br	908e9b4 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 908e924:	e0800217 	ldw	r2,8(fp)
 908e928:	10000005 	stb	zero,0(r2)
             break;
 908e92c:	00001106 	br	908e974 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 908e930:	e0bff817 	ldw	r2,-32(fp)
 908e934:	10000015 	stw	zero,0(r2)
 908e938:	e0bff817 	ldw	r2,-32(fp)
 908e93c:	10800104 	addi	r2,r2,4
 908e940:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 908e944:	e0c00217 	ldw	r3,8(fp)
 908e948:	00800384 	movi	r2,14
 908e94c:	18800005 	stb	r2,0(r3)
             break;
 908e950:	00000806 	br	908e974 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 908e954:	e0bff817 	ldw	r2,-32(fp)
 908e958:	10000015 	stw	zero,0(r2)
 908e95c:	e0bff817 	ldw	r2,-32(fp)
 908e960:	10800104 	addi	r2,r2,4
 908e964:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 908e968:	e0c00217 	ldw	r3,8(fp)
 908e96c:	00800284 	movi	r2,10
 908e970:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 908e974:	d0a07b17 	ldw	r2,-32276(gp)
 908e978:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 908e97c:	d0a07b17 	ldw	r2,-32276(gp)
 908e980:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 908e984:	d0a07b17 	ldw	r2,-32276(gp)
 908e988:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 908e98c:	d0a07b17 	ldw	r2,-32276(gp)
 908e990:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 908e994:	d0a07b17 	ldw	r2,-32276(gp)
 908e998:	10000915 	stw	zero,36(r2)
 908e99c:	e0bff017 	ldw	r2,-64(fp)
 908e9a0:	e0bfe915 	stw	r2,-92(fp)
 908e9a4:	e0bfe917 	ldw	r2,-92(fp)
 908e9a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 908e9ac:	e0fff18b 	ldhu	r3,-58(fp)
 908e9b0:	e0ffff15 	stw	r3,-4(fp)
 908e9b4:	e0bfff17 	ldw	r2,-4(fp)
}
 908e9b8:	e037883a 	mov	sp,fp
 908e9bc:	dfc00117 	ldw	ra,4(sp)
 908e9c0:	df000017 	ldw	fp,0(sp)
 908e9c4:	dec00204 	addi	sp,sp,8
 908e9c8:	f800283a 	ret

0908e9cc <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 908e9cc:	defffe04 	addi	sp,sp,-8
 908e9d0:	dfc00115 	stw	ra,4(sp)
 908e9d4:	df000015 	stw	fp,0(sp)
 908e9d8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 908e9dc:	90bb20c0 	call	90bb20c <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 908e9e0:	908f79c0 	call	908f79c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 908e9e4:	908f7e00 	call	908f7e0 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 908e9e8:	908f9440 	call	908f944 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 908e9ec:	908f6c00 	call	908f6c0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 908e9f0:	9091a0c0 	call	9091a0c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 908e9f4:	90923e40 	call	90923e4 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 908e9f8:	909373c0 	call	909373c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 908e9fc:	908f84c0 	call	908f84c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 908ea00:	908f8c80 	call	908f8c8 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 908ea04:	90bb2280 	call	90bb228 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 908ea08:	90901e40 	call	90901e4 <OSDebugInit>
#endif
}
 908ea0c:	e037883a 	mov	sp,fp
 908ea10:	dfc00117 	ldw	ra,4(sp)
 908ea14:	df000017 	ldw	fp,0(sp)
 908ea18:	dec00204 	addi	sp,sp,8
 908ea1c:	f800283a 	ret

0908ea20 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 908ea20:	defffc04 	addi	sp,sp,-16
 908ea24:	df000315 	stw	fp,12(sp)
 908ea28:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908ea2c:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 908ea30:	d0a06c43 	ldbu	r2,-32335(gp)
 908ea34:	10803fcc 	andi	r2,r2,255
 908ea38:	10800058 	cmpnei	r2,r2,1
 908ea3c:	1000131e 	bne	r2,zero,908ea8c <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ea40:	0005303a 	rdctl	r2,status
 908ea44:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ea48:	e0fffe17 	ldw	r3,-8(fp)
 908ea4c:	00bfff84 	movi	r2,-2
 908ea50:	1884703a 	and	r2,r3,r2
 908ea54:	1001703a 	wrctl	status,r2
  
  return context;
 908ea58:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908ea5c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 908ea60:	d0a07a03 	ldbu	r2,-32280(gp)
 908ea64:	10803fcc 	andi	r2,r2,255
 908ea68:	10803fe0 	cmpeqi	r2,r2,255
 908ea6c:	1000031e 	bne	r2,zero,908ea7c <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 908ea70:	d0a07a03 	ldbu	r2,-32280(gp)
 908ea74:	10800044 	addi	r2,r2,1
 908ea78:	d0a07a05 	stb	r2,-32280(gp)
 908ea7c:	e0bfff17 	ldw	r2,-4(fp)
 908ea80:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ea84:	e0bffd17 	ldw	r2,-12(fp)
 908ea88:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 908ea8c:	e037883a 	mov	sp,fp
 908ea90:	df000017 	ldw	fp,0(sp)
 908ea94:	dec00104 	addi	sp,sp,4
 908ea98:	f800283a 	ret

0908ea9c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 908ea9c:	defffb04 	addi	sp,sp,-20
 908eaa0:	dfc00415 	stw	ra,16(sp)
 908eaa4:	df000315 	stw	fp,12(sp)
 908eaa8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908eaac:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 908eab0:	d0a06c43 	ldbu	r2,-32335(gp)
 908eab4:	10803fcc 	andi	r2,r2,255
 908eab8:	10800058 	cmpnei	r2,r2,1
 908eabc:	1000321e 	bne	r2,zero,908eb88 <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908eac0:	0005303a 	rdctl	r2,status
 908eac4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908eac8:	e0fffe17 	ldw	r3,-8(fp)
 908eacc:	00bfff84 	movi	r2,-2
 908ead0:	1884703a 	and	r2,r3,r2
 908ead4:	1001703a 	wrctl	status,r2
  
  return context;
 908ead8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908eadc:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 908eae0:	d0a07a03 	ldbu	r2,-32280(gp)
 908eae4:	10803fcc 	andi	r2,r2,255
 908eae8:	1005003a 	cmpeq	r2,r2,zero
 908eaec:	1000031e 	bne	r2,zero,908eafc <OSIntExit+0x60>
            OSIntNesting--;
 908eaf0:	d0a07a03 	ldbu	r2,-32280(gp)
 908eaf4:	10bfffc4 	addi	r2,r2,-1
 908eaf8:	d0a07a05 	stb	r2,-32280(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 908eafc:	d0a07a03 	ldbu	r2,-32280(gp)
 908eb00:	10803fcc 	andi	r2,r2,255
 908eb04:	1004c03a 	cmpne	r2,r2,zero
 908eb08:	10001b1e 	bne	r2,zero,908eb78 <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 908eb0c:	d0a06c03 	ldbu	r2,-32336(gp)
 908eb10:	10803fcc 	andi	r2,r2,255
 908eb14:	1004c03a 	cmpne	r2,r2,zero
 908eb18:	1000171e 	bne	r2,zero,908eb78 <OSIntExit+0xdc>
                OS_SchedNew();
 908eb1c:	908fbb80 	call	908fbb8 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 908eb20:	d0a06e03 	ldbu	r2,-32328(gp)
 908eb24:	d0e06e43 	ldbu	r3,-32327(gp)
 908eb28:	11003fcc 	andi	r4,r2,255
 908eb2c:	18803fcc 	andi	r2,r3,255
 908eb30:	20801126 	beq	r4,r2,908eb78 <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 908eb34:	d0a06e03 	ldbu	r2,-32328(gp)
 908eb38:	10803fcc 	andi	r2,r2,255
 908eb3c:	00c243b4 	movhi	r3,2318
 908eb40:	18f47404 	addi	r3,r3,-11824
 908eb44:	1085883a 	add	r2,r2,r2
 908eb48:	1085883a 	add	r2,r2,r2
 908eb4c:	10c5883a 	add	r2,r2,r3
 908eb50:	10800017 	ldw	r2,0(r2)
 908eb54:	d0a07615 	stw	r2,-32296(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 908eb58:	d0e07617 	ldw	r3,-32296(gp)
 908eb5c:	18800e17 	ldw	r2,56(r3)
 908eb60:	10800044 	addi	r2,r2,1
 908eb64:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 908eb68:	d0a07117 	ldw	r2,-32316(gp)
 908eb6c:	10800044 	addi	r2,r2,1
 908eb70:	d0a07115 	stw	r2,-32316(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 908eb74:	90bad8c0 	call	90bad8c <OSCtxSw>
 908eb78:	e0bfff17 	ldw	r2,-4(fp)
 908eb7c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908eb80:	e0bffd17 	ldw	r2,-12(fp)
 908eb84:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 908eb88:	e037883a 	mov	sp,fp
 908eb8c:	dfc00117 	ldw	ra,4(sp)
 908eb90:	df000017 	ldw	fp,0(sp)
 908eb94:	dec00204 	addi	sp,sp,8
 908eb98:	f800283a 	ret

0908eb9c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 908eb9c:	defffc04 	addi	sp,sp,-16
 908eba0:	df000315 	stw	fp,12(sp)
 908eba4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908eba8:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 908ebac:	d0a06c43 	ldbu	r2,-32335(gp)
 908ebb0:	10803fcc 	andi	r2,r2,255
 908ebb4:	10800058 	cmpnei	r2,r2,1
 908ebb8:	1000171e 	bne	r2,zero,908ec18 <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ebbc:	0005303a 	rdctl	r2,status
 908ebc0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ebc4:	e0fffe17 	ldw	r3,-8(fp)
 908ebc8:	00bfff84 	movi	r2,-2
 908ebcc:	1884703a 	and	r2,r3,r2
 908ebd0:	1001703a 	wrctl	status,r2
  
  return context;
 908ebd4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908ebd8:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 908ebdc:	d0a07a03 	ldbu	r2,-32280(gp)
 908ebe0:	10803fcc 	andi	r2,r2,255
 908ebe4:	1004c03a 	cmpne	r2,r2,zero
 908ebe8:	1000071e 	bne	r2,zero,908ec08 <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 908ebec:	d0a06c03 	ldbu	r2,-32336(gp)
 908ebf0:	10803fcc 	andi	r2,r2,255
 908ebf4:	10803fe0 	cmpeqi	r2,r2,255
 908ebf8:	1000031e 	bne	r2,zero,908ec08 <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 908ebfc:	d0a06c03 	ldbu	r2,-32336(gp)
 908ec00:	10800044 	addi	r2,r2,1
 908ec04:	d0a06c05 	stb	r2,-32336(gp)
 908ec08:	e0bfff17 	ldw	r2,-4(fp)
 908ec0c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ec10:	e0bffd17 	ldw	r2,-12(fp)
 908ec14:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 908ec18:	e037883a 	mov	sp,fp
 908ec1c:	df000017 	ldw	fp,0(sp)
 908ec20:	dec00104 	addi	sp,sp,4
 908ec24:	f800283a 	ret

0908ec28 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 908ec28:	defff804 	addi	sp,sp,-32
 908ec2c:	dfc00715 	stw	ra,28(sp)
 908ec30:	df000615 	stw	fp,24(sp)
 908ec34:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908ec38:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 908ec3c:	d0a06c43 	ldbu	r2,-32335(gp)
 908ec40:	10803fcc 	andi	r2,r2,255
 908ec44:	10800058 	cmpnei	r2,r2,1
 908ec48:	10002b1e 	bne	r2,zero,908ecf8 <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ec4c:	0005303a 	rdctl	r2,status
 908ec50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ec54:	e0fffe17 	ldw	r3,-8(fp)
 908ec58:	00bfff84 	movi	r2,-2
 908ec5c:	1884703a 	and	r2,r3,r2
 908ec60:	1001703a 	wrctl	status,r2
  
  return context;
 908ec64:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 908ec68:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 908ec6c:	d0a06c03 	ldbu	r2,-32336(gp)
 908ec70:	10803fcc 	andi	r2,r2,255
 908ec74:	1005003a 	cmpeq	r2,r2,zero
 908ec78:	10001b1e 	bne	r2,zero,908ece8 <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 908ec7c:	d0a06c03 	ldbu	r2,-32336(gp)
 908ec80:	10bfffc4 	addi	r2,r2,-1
 908ec84:	d0a06c05 	stb	r2,-32336(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 908ec88:	d0a06c03 	ldbu	r2,-32336(gp)
 908ec8c:	10803fcc 	andi	r2,r2,255
 908ec90:	1004c03a 	cmpne	r2,r2,zero
 908ec94:	10000f1e 	bne	r2,zero,908ecd4 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 908ec98:	d0a07a03 	ldbu	r2,-32280(gp)
 908ec9c:	10803fcc 	andi	r2,r2,255
 908eca0:	1004c03a 	cmpne	r2,r2,zero
 908eca4:	1000061e 	bne	r2,zero,908ecc0 <OSSchedUnlock+0x98>
 908eca8:	e0bfff17 	ldw	r2,-4(fp)
 908ecac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ecb0:	e0bffd17 	ldw	r2,-12(fp)
 908ecb4:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 908ecb8:	908fae40 	call	908fae4 <OS_Sched>
 908ecbc:	00000e06 	br	908ecf8 <OSSchedUnlock+0xd0>
 908ecc0:	e0bfff17 	ldw	r2,-4(fp)
 908ecc4:	e0bffc15 	stw	r2,-16(fp)
 908ecc8:	e0bffc17 	ldw	r2,-16(fp)
 908eccc:	1001703a 	wrctl	status,r2
 908ecd0:	00000906 	br	908ecf8 <OSSchedUnlock+0xd0>
 908ecd4:	e0bfff17 	ldw	r2,-4(fp)
 908ecd8:	e0bffb15 	stw	r2,-20(fp)
 908ecdc:	e0bffb17 	ldw	r2,-20(fp)
 908ece0:	1001703a 	wrctl	status,r2
 908ece4:	00000406 	br	908ecf8 <OSSchedUnlock+0xd0>
 908ece8:	e0bfff17 	ldw	r2,-4(fp)
 908ecec:	e0bffa15 	stw	r2,-24(fp)
 908ecf0:	e0bffa17 	ldw	r2,-24(fp)
 908ecf4:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 908ecf8:	e037883a 	mov	sp,fp
 908ecfc:	dfc00117 	ldw	ra,4(sp)
 908ed00:	df000017 	ldw	fp,0(sp)
 908ed04:	dec00204 	addi	sp,sp,8
 908ed08:	f800283a 	ret

0908ed0c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 908ed0c:	defffe04 	addi	sp,sp,-8
 908ed10:	dfc00115 	stw	ra,4(sp)
 908ed14:	df000015 	stw	fp,0(sp)
 908ed18:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 908ed1c:	d0a06c43 	ldbu	r2,-32335(gp)
 908ed20:	10803fcc 	andi	r2,r2,255
 908ed24:	1004c03a 	cmpne	r2,r2,zero
 908ed28:	10000f1e 	bne	r2,zero,908ed68 <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 908ed2c:	908fbb80 	call	908fbb8 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 908ed30:	d0a06e03 	ldbu	r2,-32328(gp)
 908ed34:	d0a06e45 	stb	r2,-32327(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 908ed38:	d0a06e03 	ldbu	r2,-32328(gp)
 908ed3c:	10803fcc 	andi	r2,r2,255
 908ed40:	00c243b4 	movhi	r3,2318
 908ed44:	18f47404 	addi	r3,r3,-11824
 908ed48:	1085883a 	add	r2,r2,r2
 908ed4c:	1085883a 	add	r2,r2,r2
 908ed50:	10c5883a 	add	r2,r2,r3
 908ed54:	10800017 	ldw	r2,0(r2)
 908ed58:	d0a07615 	stw	r2,-32296(gp)
        OSTCBCur      = OSTCBHighRdy;
 908ed5c:	d0a07617 	ldw	r2,-32296(gp)
 908ed60:	d0a07b15 	stw	r2,-32276(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 908ed64:	90bae180 	call	90bae18 <OSStartHighRdy>
    }
}
 908ed68:	e037883a 	mov	sp,fp
 908ed6c:	dfc00117 	ldw	ra,4(sp)
 908ed70:	df000017 	ldw	fp,0(sp)
 908ed74:	dec00204 	addi	sp,sp,8
 908ed78:	f800283a 	ret

0908ed7c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 908ed7c:	defff904 	addi	sp,sp,-28
 908ed80:	dfc00615 	stw	ra,24(sp)
 908ed84:	df000515 	stw	fp,20(sp)
 908ed88:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908ed8c:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 908ed90:	01000084 	movi	r4,2
 908ed94:	9095df00 	call	9095df0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ed98:	0005303a 	rdctl	r2,status
 908ed9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908eda0:	e0fffe17 	ldw	r3,-8(fp)
 908eda4:	00bfff84 	movi	r2,-2
 908eda8:	1884703a 	and	r2,r3,r2
 908edac:	1001703a 	wrctl	status,r2
  
  return context;
 908edb0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 908edb4:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 908edb8:	d0206d15 	stw	zero,-32332(gp)
 908edbc:	e0bfff17 	ldw	r2,-4(fp)
 908edc0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908edc4:	e0bffd17 	ldw	r2,-12(fp)
 908edc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 908edcc:	01000284 	movi	r4,10
 908edd0:	9095df00 	call	9095df0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908edd4:	0005303a 	rdctl	r2,status
 908edd8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908eddc:	e0fffc17 	ldw	r3,-16(fp)
 908ede0:	00bfff84 	movi	r2,-2
 908ede4:	1884703a 	and	r2,r3,r2
 908ede8:	1001703a 	wrctl	status,r2
  
  return context;
 908edec:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 908edf0:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 908edf4:	d0a06d17 	ldw	r2,-32332(gp)
 908edf8:	d0a07215 	stw	r2,-32312(gp)
    OSStatRdy    = OS_TRUE;
 908edfc:	00800044 	movi	r2,1
 908ee00:	d0a07e05 	stb	r2,-32264(gp)
 908ee04:	e0bfff17 	ldw	r2,-4(fp)
 908ee08:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ee0c:	e0bffb17 	ldw	r2,-20(fp)
 908ee10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 908ee14:	e037883a 	mov	sp,fp
 908ee18:	dfc00117 	ldw	ra,4(sp)
 908ee1c:	df000017 	ldw	fp,0(sp)
 908ee20:	dec00204 	addi	sp,sp,8
 908ee24:	f800283a 	ret

0908ee28 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 908ee28:	defff604 	addi	sp,sp,-40
 908ee2c:	dfc00915 	stw	ra,36(sp)
 908ee30:	df000815 	stw	fp,32(sp)
 908ee34:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 908ee38:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 908ee3c:	90bb1e40 	call	90bb1e4 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ee40:	0005303a 	rdctl	r2,status
 908ee44:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ee48:	e0fffb17 	ldw	r3,-20(fp)
 908ee4c:	00bfff84 	movi	r2,-2
 908ee50:	1884703a 	and	r2,r3,r2
 908ee54:	1001703a 	wrctl	status,r2
  
  return context;
 908ee58:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 908ee5c:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 908ee60:	d0a07c17 	ldw	r2,-32272(gp)
 908ee64:	10800044 	addi	r2,r2,1
 908ee68:	d0a07c15 	stw	r2,-32272(gp)
 908ee6c:	e0bffc17 	ldw	r2,-16(fp)
 908ee70:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ee74:	e0bffa17 	ldw	r2,-24(fp)
 908ee78:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 908ee7c:	d0a06c43 	ldbu	r2,-32335(gp)
 908ee80:	10803fcc 	andi	r2,r2,255
 908ee84:	10800058 	cmpnei	r2,r2,1
 908ee88:	1000721e 	bne	r2,zero,908f054 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 908ee8c:	d0a07003 	ldbu	r2,-32320(gp)
 908ee90:	10803fcc 	andi	r2,r2,255
 908ee94:	e0bfff15 	stw	r2,-4(fp)
 908ee98:	e0ffff17 	ldw	r3,-4(fp)
 908ee9c:	18800060 	cmpeqi	r2,r3,1
 908eea0:	10000a1e 	bne	r2,zero,908eecc <OSTimeTick+0xa4>
 908eea4:	e0ffff17 	ldw	r3,-4(fp)
 908eea8:	188000a0 	cmpeqi	r2,r3,2
 908eeac:	1000091e 	bne	r2,zero,908eed4 <OSTimeTick+0xac>
 908eeb0:	e0ffff17 	ldw	r3,-4(fp)
 908eeb4:	1805003a 	cmpeq	r2,r3,zero
 908eeb8:	1000011e 	bne	r2,zero,908eec0 <OSTimeTick+0x98>
 908eebc:	00000a06 	br	908eee8 <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 908eec0:	00800044 	movi	r2,1
 908eec4:	e0bffd05 	stb	r2,-12(fp)
                 break;
 908eec8:	00000a06 	br	908eef4 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 908eecc:	e03ffd05 	stb	zero,-12(fp)
                 break;
 908eed0:	00000806 	br	908eef4 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 908eed4:	00800044 	movi	r2,1
 908eed8:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 908eedc:	00800044 	movi	r2,1
 908eee0:	d0a07005 	stb	r2,-32320(gp)
                 break;
 908eee4:	00000306 	br	908eef4 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 908eee8:	00800044 	movi	r2,1
 908eeec:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 908eef0:	d0207005 	stb	zero,-32320(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 908eef4:	e0bffd03 	ldbu	r2,-12(fp)
 908eef8:	1005003a 	cmpeq	r2,r2,zero
 908eefc:	1000551e 	bne	r2,zero,908f054 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 908ef00:	d0a06f17 	ldw	r2,-32324(gp)
 908ef04:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 908ef08:	00004d06 	br	908f040 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ef0c:	0005303a 	rdctl	r2,status
 908ef10:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ef14:	e0fff917 	ldw	r3,-28(fp)
 908ef18:	00bfff84 	movi	r2,-2
 908ef1c:	1884703a 	and	r2,r3,r2
 908ef20:	1001703a 	wrctl	status,r2
  
  return context;
 908ef24:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 908ef28:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 908ef2c:	e0bffe17 	ldw	r2,-8(fp)
 908ef30:	10800b8b 	ldhu	r2,46(r2)
 908ef34:	10bfffcc 	andi	r2,r2,65535
 908ef38:	1005003a 	cmpeq	r2,r2,zero
 908ef3c:	1000391e 	bne	r2,zero,908f024 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 908ef40:	e0bffe17 	ldw	r2,-8(fp)
 908ef44:	10800b8b 	ldhu	r2,46(r2)
 908ef48:	10bfffc4 	addi	r2,r2,-1
 908ef4c:	1007883a 	mov	r3,r2
 908ef50:	e0bffe17 	ldw	r2,-8(fp)
 908ef54:	10c00b8d 	sth	r3,46(r2)
 908ef58:	e0bffe17 	ldw	r2,-8(fp)
 908ef5c:	10800b8b 	ldhu	r2,46(r2)
 908ef60:	10bfffcc 	andi	r2,r2,65535
 908ef64:	1004c03a 	cmpne	r2,r2,zero
 908ef68:	10002e1e 	bne	r2,zero,908f024 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 908ef6c:	e0bffe17 	ldw	r2,-8(fp)
 908ef70:	10800c03 	ldbu	r2,48(r2)
 908ef74:	10803fcc 	andi	r2,r2,255
 908ef78:	10800dcc 	andi	r2,r2,55
 908ef7c:	1005003a 	cmpeq	r2,r2,zero
 908ef80:	10000b1e 	bne	r2,zero,908efb0 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 908ef84:	e0bffe17 	ldw	r2,-8(fp)
 908ef88:	10c00c03 	ldbu	r3,48(r2)
 908ef8c:	00bff204 	movi	r2,-56
 908ef90:	1884703a 	and	r2,r3,r2
 908ef94:	1007883a 	mov	r3,r2
 908ef98:	e0bffe17 	ldw	r2,-8(fp)
 908ef9c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 908efa0:	e0fffe17 	ldw	r3,-8(fp)
 908efa4:	00800044 	movi	r2,1
 908efa8:	18800c45 	stb	r2,49(r3)
 908efac:	00000206 	br	908efb8 <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 908efb0:	e0bffe17 	ldw	r2,-8(fp)
 908efb4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 908efb8:	e0bffe17 	ldw	r2,-8(fp)
 908efbc:	10800c03 	ldbu	r2,48(r2)
 908efc0:	10803fcc 	andi	r2,r2,255
 908efc4:	1080020c 	andi	r2,r2,8
 908efc8:	1004c03a 	cmpne	r2,r2,zero
 908efcc:	1000151e 	bne	r2,zero,908f024 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 908efd0:	e0bffe17 	ldw	r2,-8(fp)
 908efd4:	10c00d83 	ldbu	r3,54(r2)
 908efd8:	d0a07803 	ldbu	r2,-32288(gp)
 908efdc:	1884b03a 	or	r2,r3,r2
 908efe0:	d0a07805 	stb	r2,-32288(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 908efe4:	e0bffe17 	ldw	r2,-8(fp)
 908efe8:	10800d03 	ldbu	r2,52(r2)
 908efec:	11003fcc 	andi	r4,r2,255
 908eff0:	e0bffe17 	ldw	r2,-8(fp)
 908eff4:	10800d03 	ldbu	r2,52(r2)
 908eff8:	10c03fcc 	andi	r3,r2,255
 908effc:	d0a07844 	addi	r2,gp,-32287
 908f000:	1885883a 	add	r2,r3,r2
 908f004:	10c00003 	ldbu	r3,0(r2)
 908f008:	e0bffe17 	ldw	r2,-8(fp)
 908f00c:	10800d43 	ldbu	r2,53(r2)
 908f010:	1884b03a 	or	r2,r3,r2
 908f014:	1007883a 	mov	r3,r2
 908f018:	d0a07844 	addi	r2,gp,-32287
 908f01c:	2085883a 	add	r2,r4,r2
 908f020:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 908f024:	e0bffe17 	ldw	r2,-8(fp)
 908f028:	10800517 	ldw	r2,20(r2)
 908f02c:	e0bffe15 	stw	r2,-8(fp)
 908f030:	e0bffc17 	ldw	r2,-16(fp)
 908f034:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908f038:	e0bff817 	ldw	r2,-32(fp)
 908f03c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 908f040:	e0bffe17 	ldw	r2,-8(fp)
 908f044:	10800c83 	ldbu	r2,50(r2)
 908f048:	10803fcc 	andi	r2,r2,255
 908f04c:	10800518 	cmpnei	r2,r2,20
 908f050:	103fae1e 	bne	r2,zero,908ef0c <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 908f054:	e037883a 	mov	sp,fp
 908f058:	dfc00117 	ldw	ra,4(sp)
 908f05c:	df000017 	ldw	fp,0(sp)
 908f060:	dec00204 	addi	sp,sp,8
 908f064:	f800283a 	ret

0908f068 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 908f068:	deffff04 	addi	sp,sp,-4
 908f06c:	df000015 	stw	fp,0(sp)
 908f070:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 908f074:	00804784 	movi	r2,286
}
 908f078:	e037883a 	mov	sp,fp
 908f07c:	df000017 	ldw	fp,0(sp)
 908f080:	dec00104 	addi	sp,sp,4
 908f084:	f800283a 	ret

0908f088 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 908f088:	deffff04 	addi	sp,sp,-4
 908f08c:	df000015 	stw	fp,0(sp)
 908f090:	d839883a 	mov	fp,sp
}
 908f094:	e037883a 	mov	sp,fp
 908f098:	df000017 	ldw	fp,0(sp)
 908f09c:	dec00104 	addi	sp,sp,4
 908f0a0:	f800283a 	ret

0908f0a4 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 908f0a4:	defff804 	addi	sp,sp,-32
 908f0a8:	dfc00715 	stw	ra,28(sp)
 908f0ac:	df000615 	stw	fp,24(sp)
 908f0b0:	df000604 	addi	fp,sp,24
 908f0b4:	e13ffc15 	stw	r4,-16(fp)
 908f0b8:	e17ffd15 	stw	r5,-12(fp)
 908f0bc:	e1bffe05 	stb	r6,-8(fp)
 908f0c0:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 908f0c4:	e0bffc17 	ldw	r2,-16(fp)
 908f0c8:	10800283 	ldbu	r2,10(r2)
 908f0cc:	10c03fcc 	andi	r3,r2,255
 908f0d0:	00824374 	movhi	r2,2317
 908f0d4:	10b61004 	addi	r2,r2,-10176
 908f0d8:	10c5883a 	add	r2,r2,r3
 908f0dc:	10800003 	ldbu	r2,0(r2)
 908f0e0:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 908f0e4:	e0fffa83 	ldbu	r3,-22(fp)
 908f0e8:	e0bffc17 	ldw	r2,-16(fp)
 908f0ec:	1885883a 	add	r2,r3,r2
 908f0f0:	10800204 	addi	r2,r2,8
 908f0f4:	108000c3 	ldbu	r2,3(r2)
 908f0f8:	10c03fcc 	andi	r3,r2,255
 908f0fc:	00824374 	movhi	r2,2317
 908f100:	10b61004 	addi	r2,r2,-10176
 908f104:	10c5883a 	add	r2,r2,r3
 908f108:	10800003 	ldbu	r2,0(r2)
 908f10c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 908f110:	e0bffa83 	ldbu	r2,-22(fp)
 908f114:	100490fa 	slli	r2,r2,3
 908f118:	1007883a 	mov	r3,r2
 908f11c:	e0bffa43 	ldbu	r2,-23(fp)
 908f120:	1885883a 	add	r2,r3,r2
 908f124:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 908f128:	e0bffa03 	ldbu	r2,-24(fp)
 908f12c:	00c243b4 	movhi	r3,2318
 908f130:	18f47404 	addi	r3,r3,-11824
 908f134:	1085883a 	add	r2,r2,r2
 908f138:	1085883a 	add	r2,r2,r2
 908f13c:	10c5883a 	add	r2,r2,r3
 908f140:	10800017 	ldw	r2,0(r2)
 908f144:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 908f148:	e0bffb17 	ldw	r2,-20(fp)
 908f14c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 908f150:	e0fffb17 	ldw	r3,-20(fp)
 908f154:	e0bffd17 	ldw	r2,-12(fp)
 908f158:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 908f15c:	e0bffb17 	ldw	r2,-20(fp)
 908f160:	10800c03 	ldbu	r2,48(r2)
 908f164:	1007883a 	mov	r3,r2
 908f168:	e0bffe03 	ldbu	r2,-8(fp)
 908f16c:	0084303a 	nor	r2,zero,r2
 908f170:	1884703a 	and	r2,r3,r2
 908f174:	1007883a 	mov	r3,r2
 908f178:	e0bffb17 	ldw	r2,-20(fp)
 908f17c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 908f180:	e0fffb17 	ldw	r3,-20(fp)
 908f184:	e0bfff03 	ldbu	r2,-4(fp)
 908f188:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 908f18c:	e0bffb17 	ldw	r2,-20(fp)
 908f190:	10800c03 	ldbu	r2,48(r2)
 908f194:	10803fcc 	andi	r2,r2,255
 908f198:	1080020c 	andi	r2,r2,8
 908f19c:	1004c03a 	cmpne	r2,r2,zero
 908f1a0:	1000111e 	bne	r2,zero,908f1e8 <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 908f1a4:	e0bffb17 	ldw	r2,-20(fp)
 908f1a8:	10c00d83 	ldbu	r3,54(r2)
 908f1ac:	d0a07803 	ldbu	r2,-32288(gp)
 908f1b0:	1884b03a 	or	r2,r3,r2
 908f1b4:	d0a07805 	stb	r2,-32288(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 908f1b8:	e13ffa83 	ldbu	r4,-22(fp)
 908f1bc:	e0fffa83 	ldbu	r3,-22(fp)
 908f1c0:	d0a07844 	addi	r2,gp,-32287
 908f1c4:	1885883a 	add	r2,r3,r2
 908f1c8:	10c00003 	ldbu	r3,0(r2)
 908f1cc:	e0bffb17 	ldw	r2,-20(fp)
 908f1d0:	10800d43 	ldbu	r2,53(r2)
 908f1d4:	1884b03a 	or	r2,r3,r2
 908f1d8:	1007883a 	mov	r3,r2
 908f1dc:	d0a07844 	addi	r2,gp,-32287
 908f1e0:	2085883a 	add	r2,r4,r2
 908f1e4:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 908f1e8:	e13ffb17 	ldw	r4,-20(fp)
 908f1ec:	e17ffc17 	ldw	r5,-16(fp)
 908f1f0:	908f49c0 	call	908f49c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 908f1f4:	e0bffb17 	ldw	r2,-20(fp)
 908f1f8:	10800817 	ldw	r2,32(r2)
 908f1fc:	1005003a 	cmpeq	r2,r2,zero
 908f200:	1000071e 	bne	r2,zero,908f220 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 908f204:	e0bffb17 	ldw	r2,-20(fp)
 908f208:	11400817 	ldw	r5,32(r2)
 908f20c:	e13ffb17 	ldw	r4,-20(fp)
 908f210:	908f5540 	call	908f554 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 908f214:	e0fffb17 	ldw	r3,-20(fp)
 908f218:	e0bffc17 	ldw	r2,-16(fp)
 908f21c:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 908f220:	e0bffa03 	ldbu	r2,-24(fp)
}
 908f224:	e037883a 	mov	sp,fp
 908f228:	dfc00117 	ldw	ra,4(sp)
 908f22c:	df000017 	ldw	fp,0(sp)
 908f230:	dec00204 	addi	sp,sp,8
 908f234:	f800283a 	ret

0908f238 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 908f238:	defffd04 	addi	sp,sp,-12
 908f23c:	df000215 	stw	fp,8(sp)
 908f240:	df000204 	addi	fp,sp,8
 908f244:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 908f248:	d0e07b17 	ldw	r3,-32276(gp)
 908f24c:	e0bfff17 	ldw	r2,-4(fp)
 908f250:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 908f254:	d0a07b17 	ldw	r2,-32276(gp)
 908f258:	10800d03 	ldbu	r2,52(r2)
 908f25c:	11003fcc 	andi	r4,r2,255
 908f260:	d0a07b17 	ldw	r2,-32276(gp)
 908f264:	10800d03 	ldbu	r2,52(r2)
 908f268:	10c03fcc 	andi	r3,r2,255
 908f26c:	e0bfff17 	ldw	r2,-4(fp)
 908f270:	1885883a 	add	r2,r3,r2
 908f274:	10800204 	addi	r2,r2,8
 908f278:	10c000c3 	ldbu	r3,3(r2)
 908f27c:	d0a07b17 	ldw	r2,-32276(gp)
 908f280:	10800d43 	ldbu	r2,53(r2)
 908f284:	1884b03a 	or	r2,r3,r2
 908f288:	1007883a 	mov	r3,r2
 908f28c:	e0bfff17 	ldw	r2,-4(fp)
 908f290:	2085883a 	add	r2,r4,r2
 908f294:	10800204 	addi	r2,r2,8
 908f298:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 908f29c:	e0bfff17 	ldw	r2,-4(fp)
 908f2a0:	10c00283 	ldbu	r3,10(r2)
 908f2a4:	d0a07b17 	ldw	r2,-32276(gp)
 908f2a8:	10800d83 	ldbu	r2,54(r2)
 908f2ac:	1884b03a 	or	r2,r3,r2
 908f2b0:	1007883a 	mov	r3,r2
 908f2b4:	e0bfff17 	ldw	r2,-4(fp)
 908f2b8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 908f2bc:	d0a07b17 	ldw	r2,-32276(gp)
 908f2c0:	10800d03 	ldbu	r2,52(r2)
 908f2c4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 908f2c8:	e13ffe03 	ldbu	r4,-8(fp)
 908f2cc:	e0fffe03 	ldbu	r3,-8(fp)
 908f2d0:	d0a07844 	addi	r2,gp,-32287
 908f2d4:	1885883a 	add	r2,r3,r2
 908f2d8:	10800003 	ldbu	r2,0(r2)
 908f2dc:	1007883a 	mov	r3,r2
 908f2e0:	d0a07b17 	ldw	r2,-32276(gp)
 908f2e4:	10800d43 	ldbu	r2,53(r2)
 908f2e8:	0084303a 	nor	r2,zero,r2
 908f2ec:	1884703a 	and	r2,r3,r2
 908f2f0:	1007883a 	mov	r3,r2
 908f2f4:	d0a07844 	addi	r2,gp,-32287
 908f2f8:	2085883a 	add	r2,r4,r2
 908f2fc:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 908f300:	e0fffe03 	ldbu	r3,-8(fp)
 908f304:	d0a07844 	addi	r2,gp,-32287
 908f308:	1885883a 	add	r2,r3,r2
 908f30c:	10800003 	ldbu	r2,0(r2)
 908f310:	10803fcc 	andi	r2,r2,255
 908f314:	1004c03a 	cmpne	r2,r2,zero
 908f318:	1000071e 	bne	r2,zero,908f338 <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 908f31c:	d0a07b17 	ldw	r2,-32276(gp)
 908f320:	10800d83 	ldbu	r2,54(r2)
 908f324:	0084303a 	nor	r2,zero,r2
 908f328:	1007883a 	mov	r3,r2
 908f32c:	d0a07803 	ldbu	r2,-32288(gp)
 908f330:	1884703a 	and	r2,r3,r2
 908f334:	d0a07805 	stb	r2,-32288(gp)
    }
}
 908f338:	e037883a 	mov	sp,fp
 908f33c:	df000017 	ldw	fp,0(sp)
 908f340:	dec00104 	addi	sp,sp,4
 908f344:	f800283a 	ret

0908f348 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 908f348:	defffb04 	addi	sp,sp,-20
 908f34c:	df000415 	stw	fp,16(sp)
 908f350:	df000404 	addi	fp,sp,16
 908f354:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 908f358:	d0a07b17 	ldw	r2,-32276(gp)
 908f35c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 908f360:	d0e07b17 	ldw	r3,-32276(gp)
 908f364:	e0bfff17 	ldw	r2,-4(fp)
 908f368:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 908f36c:	e0bfff17 	ldw	r2,-4(fp)
 908f370:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 908f374:	e0bffe17 	ldw	r2,-8(fp)
 908f378:	10800017 	ldw	r2,0(r2)
 908f37c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 908f380:	00002006 	br	908f404 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 908f384:	d0a07b17 	ldw	r2,-32276(gp)
 908f388:	10800d03 	ldbu	r2,52(r2)
 908f38c:	11003fcc 	andi	r4,r2,255
 908f390:	d0a07b17 	ldw	r2,-32276(gp)
 908f394:	10800d03 	ldbu	r2,52(r2)
 908f398:	10c03fcc 	andi	r3,r2,255
 908f39c:	e0bffd17 	ldw	r2,-12(fp)
 908f3a0:	1885883a 	add	r2,r3,r2
 908f3a4:	10800204 	addi	r2,r2,8
 908f3a8:	10c000c3 	ldbu	r3,3(r2)
 908f3ac:	d0a07b17 	ldw	r2,-32276(gp)
 908f3b0:	10800d43 	ldbu	r2,53(r2)
 908f3b4:	1884b03a 	or	r2,r3,r2
 908f3b8:	1007883a 	mov	r3,r2
 908f3bc:	e0bffd17 	ldw	r2,-12(fp)
 908f3c0:	2085883a 	add	r2,r4,r2
 908f3c4:	10800204 	addi	r2,r2,8
 908f3c8:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 908f3cc:	e0bffd17 	ldw	r2,-12(fp)
 908f3d0:	10c00283 	ldbu	r3,10(r2)
 908f3d4:	d0a07b17 	ldw	r2,-32276(gp)
 908f3d8:	10800d83 	ldbu	r2,54(r2)
 908f3dc:	1884b03a 	or	r2,r3,r2
 908f3e0:	1007883a 	mov	r3,r2
 908f3e4:	e0bffd17 	ldw	r2,-12(fp)
 908f3e8:	10c00285 	stb	r3,10(r2)
        pevents++;
 908f3ec:	e0bffe17 	ldw	r2,-8(fp)
 908f3f0:	10800104 	addi	r2,r2,4
 908f3f4:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 908f3f8:	e0bffe17 	ldw	r2,-8(fp)
 908f3fc:	10800017 	ldw	r2,0(r2)
 908f400:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 908f404:	e0bffd17 	ldw	r2,-12(fp)
 908f408:	1004c03a 	cmpne	r2,r2,zero
 908f40c:	103fdd1e 	bne	r2,zero,908f384 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 908f410:	d0a07b17 	ldw	r2,-32276(gp)
 908f414:	10800d03 	ldbu	r2,52(r2)
 908f418:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 908f41c:	e13ffc03 	ldbu	r4,-16(fp)
 908f420:	e0fffc03 	ldbu	r3,-16(fp)
 908f424:	d0a07844 	addi	r2,gp,-32287
 908f428:	1885883a 	add	r2,r3,r2
 908f42c:	10800003 	ldbu	r2,0(r2)
 908f430:	1007883a 	mov	r3,r2
 908f434:	d0a07b17 	ldw	r2,-32276(gp)
 908f438:	10800d43 	ldbu	r2,53(r2)
 908f43c:	0084303a 	nor	r2,zero,r2
 908f440:	1884703a 	and	r2,r3,r2
 908f444:	1007883a 	mov	r3,r2
 908f448:	d0a07844 	addi	r2,gp,-32287
 908f44c:	2085883a 	add	r2,r4,r2
 908f450:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 908f454:	e0fffc03 	ldbu	r3,-16(fp)
 908f458:	d0a07844 	addi	r2,gp,-32287
 908f45c:	1885883a 	add	r2,r3,r2
 908f460:	10800003 	ldbu	r2,0(r2)
 908f464:	10803fcc 	andi	r2,r2,255
 908f468:	1004c03a 	cmpne	r2,r2,zero
 908f46c:	1000071e 	bne	r2,zero,908f48c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 908f470:	d0a07b17 	ldw	r2,-32276(gp)
 908f474:	10800d83 	ldbu	r2,54(r2)
 908f478:	0084303a 	nor	r2,zero,r2
 908f47c:	1007883a 	mov	r3,r2
 908f480:	d0a07803 	ldbu	r2,-32288(gp)
 908f484:	1884703a 	and	r2,r3,r2
 908f488:	d0a07805 	stb	r2,-32288(gp)
    }
}
 908f48c:	e037883a 	mov	sp,fp
 908f490:	df000017 	ldw	fp,0(sp)
 908f494:	dec00104 	addi	sp,sp,4
 908f498:	f800283a 	ret

0908f49c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 908f49c:	defffc04 	addi	sp,sp,-16
 908f4a0:	df000315 	stw	fp,12(sp)
 908f4a4:	df000304 	addi	fp,sp,12
 908f4a8:	e13ffe15 	stw	r4,-8(fp)
 908f4ac:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 908f4b0:	e0bffe17 	ldw	r2,-8(fp)
 908f4b4:	10800d03 	ldbu	r2,52(r2)
 908f4b8:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 908f4bc:	e13ffd03 	ldbu	r4,-12(fp)
 908f4c0:	e0fffd03 	ldbu	r3,-12(fp)
 908f4c4:	e0bfff17 	ldw	r2,-4(fp)
 908f4c8:	1885883a 	add	r2,r3,r2
 908f4cc:	10800204 	addi	r2,r2,8
 908f4d0:	108000c3 	ldbu	r2,3(r2)
 908f4d4:	1007883a 	mov	r3,r2
 908f4d8:	e0bffe17 	ldw	r2,-8(fp)
 908f4dc:	10800d43 	ldbu	r2,53(r2)
 908f4e0:	0084303a 	nor	r2,zero,r2
 908f4e4:	1884703a 	and	r2,r3,r2
 908f4e8:	1007883a 	mov	r3,r2
 908f4ec:	e0bfff17 	ldw	r2,-4(fp)
 908f4f0:	2085883a 	add	r2,r4,r2
 908f4f4:	10800204 	addi	r2,r2,8
 908f4f8:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 908f4fc:	e0fffd03 	ldbu	r3,-12(fp)
 908f500:	e0bfff17 	ldw	r2,-4(fp)
 908f504:	1885883a 	add	r2,r3,r2
 908f508:	10800204 	addi	r2,r2,8
 908f50c:	108000c3 	ldbu	r2,3(r2)
 908f510:	10803fcc 	andi	r2,r2,255
 908f514:	1004c03a 	cmpne	r2,r2,zero
 908f518:	10000a1e 	bne	r2,zero,908f544 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 908f51c:	e0bfff17 	ldw	r2,-4(fp)
 908f520:	10800283 	ldbu	r2,10(r2)
 908f524:	1007883a 	mov	r3,r2
 908f528:	e0bffe17 	ldw	r2,-8(fp)
 908f52c:	10800d83 	ldbu	r2,54(r2)
 908f530:	0084303a 	nor	r2,zero,r2
 908f534:	1884703a 	and	r2,r3,r2
 908f538:	1007883a 	mov	r3,r2
 908f53c:	e0bfff17 	ldw	r2,-4(fp)
 908f540:	10c00285 	stb	r3,10(r2)
    }
}
 908f544:	e037883a 	mov	sp,fp
 908f548:	df000017 	ldw	fp,0(sp)
 908f54c:	dec00104 	addi	sp,sp,4
 908f550:	f800283a 	ret

0908f554 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 908f554:	defffa04 	addi	sp,sp,-24
 908f558:	df000515 	stw	fp,20(sp)
 908f55c:	df000504 	addi	fp,sp,20
 908f560:	e13ffe15 	stw	r4,-8(fp)
 908f564:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 908f568:	e0bffe17 	ldw	r2,-8(fp)
 908f56c:	10800d03 	ldbu	r2,52(r2)
 908f570:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 908f574:	e0bffe17 	ldw	r2,-8(fp)
 908f578:	10800d83 	ldbu	r2,54(r2)
 908f57c:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 908f580:	e0bffe17 	ldw	r2,-8(fp)
 908f584:	10800d43 	ldbu	r2,53(r2)
 908f588:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 908f58c:	e0bfff17 	ldw	r2,-4(fp)
 908f590:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 908f594:	e0bffd17 	ldw	r2,-12(fp)
 908f598:	10800017 	ldw	r2,0(r2)
 908f59c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 908f5a0:	00002606 	br	908f63c <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 908f5a4:	e13ffb83 	ldbu	r4,-18(fp)
 908f5a8:	e0fffb83 	ldbu	r3,-18(fp)
 908f5ac:	e0bffc17 	ldw	r2,-16(fp)
 908f5b0:	1885883a 	add	r2,r3,r2
 908f5b4:	10800204 	addi	r2,r2,8
 908f5b8:	108000c3 	ldbu	r2,3(r2)
 908f5bc:	1007883a 	mov	r3,r2
 908f5c0:	e0bffb03 	ldbu	r2,-20(fp)
 908f5c4:	0084303a 	nor	r2,zero,r2
 908f5c8:	1884703a 	and	r2,r3,r2
 908f5cc:	1007883a 	mov	r3,r2
 908f5d0:	e0bffc17 	ldw	r2,-16(fp)
 908f5d4:	2085883a 	add	r2,r4,r2
 908f5d8:	10800204 	addi	r2,r2,8
 908f5dc:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 908f5e0:	e0fffb83 	ldbu	r3,-18(fp)
 908f5e4:	e0bffc17 	ldw	r2,-16(fp)
 908f5e8:	1885883a 	add	r2,r3,r2
 908f5ec:	10800204 	addi	r2,r2,8
 908f5f0:	108000c3 	ldbu	r2,3(r2)
 908f5f4:	10803fcc 	andi	r2,r2,255
 908f5f8:	1004c03a 	cmpne	r2,r2,zero
 908f5fc:	1000091e 	bne	r2,zero,908f624 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 908f600:	e0bffc17 	ldw	r2,-16(fp)
 908f604:	10800283 	ldbu	r2,10(r2)
 908f608:	1007883a 	mov	r3,r2
 908f60c:	e0bffb43 	ldbu	r2,-19(fp)
 908f610:	0084303a 	nor	r2,zero,r2
 908f614:	1884703a 	and	r2,r3,r2
 908f618:	1007883a 	mov	r3,r2
 908f61c:	e0bffc17 	ldw	r2,-16(fp)
 908f620:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 908f624:	e0bffd17 	ldw	r2,-12(fp)
 908f628:	10800104 	addi	r2,r2,4
 908f62c:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 908f630:	e0bffd17 	ldw	r2,-12(fp)
 908f634:	10800017 	ldw	r2,0(r2)
 908f638:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 908f63c:	e0bffc17 	ldw	r2,-16(fp)
 908f640:	1004c03a 	cmpne	r2,r2,zero
 908f644:	103fd71e 	bne	r2,zero,908f5a4 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 908f648:	e037883a 	mov	sp,fp
 908f64c:	df000017 	ldw	fp,0(sp)
 908f650:	dec00104 	addi	sp,sp,4
 908f654:	f800283a 	ret

0908f658 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 908f658:	defffc04 	addi	sp,sp,-16
 908f65c:	df000315 	stw	fp,12(sp)
 908f660:	df000304 	addi	fp,sp,12
 908f664:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 908f668:	e0bfff17 	ldw	r2,-4(fp)
 908f66c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 908f670:	e0bfff17 	ldw	r2,-4(fp)
 908f674:	108002c4 	addi	r2,r2,11
 908f678:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 908f67c:	e03ffd05 	stb	zero,-12(fp)
 908f680:	00000806 	br	908f6a4 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 908f684:	e0bffe17 	ldw	r2,-8(fp)
 908f688:	10000005 	stb	zero,0(r2)
 908f68c:	e0bffe17 	ldw	r2,-8(fp)
 908f690:	10800044 	addi	r2,r2,1
 908f694:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 908f698:	e0bffd03 	ldbu	r2,-12(fp)
 908f69c:	10800044 	addi	r2,r2,1
 908f6a0:	e0bffd05 	stb	r2,-12(fp)
 908f6a4:	e0bffd03 	ldbu	r2,-12(fp)
 908f6a8:	108000f0 	cmpltui	r2,r2,3
 908f6ac:	103ff51e 	bne	r2,zero,908f684 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 908f6b0:	e037883a 	mov	sp,fp
 908f6b4:	df000017 	ldw	fp,0(sp)
 908f6b8:	dec00104 	addi	sp,sp,4
 908f6bc:	f800283a 	ret

0908f6c0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 908f6c0:	defffb04 	addi	sp,sp,-20
 908f6c4:	dfc00415 	stw	ra,16(sp)
 908f6c8:	df000315 	stw	fp,12(sp)
 908f6cc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 908f6d0:	010243b4 	movhi	r4,2318
 908f6d4:	21306004 	addi	r4,r4,-16000
 908f6d8:	0142d004 	movi	r5,2880
 908f6dc:	908fa240 	call	908fa24 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 908f6e0:	008243b4 	movhi	r2,2318
 908f6e4:	10b06004 	addi	r2,r2,-16000
 908f6e8:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 908f6ec:	008243b4 	movhi	r2,2318
 908f6f0:	10b06c04 	addi	r2,r2,-15952
 908f6f4:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 908f6f8:	e03fff0d 	sth	zero,-4(fp)
 908f6fc:	00001306 	br	908f74c <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 908f700:	e0bffe17 	ldw	r2,-8(fp)
 908f704:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 908f708:	e0fffe17 	ldw	r3,-8(fp)
 908f70c:	e0bffd17 	ldw	r2,-12(fp)
 908f710:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 908f714:	e0fffe17 	ldw	r3,-8(fp)
 908f718:	00800fc4 	movi	r2,63
 908f71c:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 908f720:	e0bffe17 	ldw	r2,-8(fp)
 908f724:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 908f728:	e0bffe17 	ldw	r2,-8(fp)
 908f72c:	10800c04 	addi	r2,r2,48
 908f730:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 908f734:	e0bffd17 	ldw	r2,-12(fp)
 908f738:	10800c04 	addi	r2,r2,48
 908f73c:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 908f740:	e0bfff0b 	ldhu	r2,-4(fp)
 908f744:	10800044 	addi	r2,r2,1
 908f748:	e0bfff0d 	sth	r2,-4(fp)
 908f74c:	e0bfff0b 	ldhu	r2,-4(fp)
 908f750:	10800ef0 	cmpltui	r2,r2,59
 908f754:	103fea1e 	bne	r2,zero,908f700 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 908f758:	e0bffe17 	ldw	r2,-8(fp)
 908f75c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 908f760:	e0bffe17 	ldw	r2,-8(fp)
 908f764:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 908f768:	e0fffe17 	ldw	r3,-8(fp)
 908f76c:	00800fc4 	movi	r2,63
 908f770:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 908f774:	e0bffe17 	ldw	r2,-8(fp)
 908f778:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 908f77c:	008243b4 	movhi	r2,2318
 908f780:	10b06004 	addi	r2,r2,-16000
 908f784:	d0a07915 	stw	r2,-32284(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 908f788:	e037883a 	mov	sp,fp
 908f78c:	dfc00117 	ldw	ra,4(sp)
 908f790:	df000017 	ldw	fp,0(sp)
 908f794:	dec00204 	addi	sp,sp,8
 908f798:	f800283a 	ret

0908f79c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 908f79c:	deffff04 	addi	sp,sp,-4
 908f7a0:	df000015 	stw	fp,0(sp)
 908f7a4:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 908f7a8:	d0207c15 	stw	zero,-32272(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 908f7ac:	d0207a05 	stb	zero,-32280(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 908f7b0:	d0206c05 	stb	zero,-32336(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 908f7b4:	d0207445 	stb	zero,-32303(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 908f7b8:	d0206c45 	stb	zero,-32335(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 908f7bc:	d0207115 	stw	zero,-32316(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 908f7c0:	d0206d15 	stw	zero,-32332(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 908f7c4:	d0207f15 	stw	zero,-32260(gp)
    OSIdleCtrMax  = 0L;
 908f7c8:	d0207215 	stw	zero,-32312(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 908f7cc:	d0207e05 	stb	zero,-32264(gp)
#endif
}
 908f7d0:	e037883a 	mov	sp,fp
 908f7d4:	df000017 	ldw	fp,0(sp)
 908f7d8:	dec00104 	addi	sp,sp,4
 908f7dc:	f800283a 	ret

0908f7e0 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 908f7e0:	defffd04 	addi	sp,sp,-12
 908f7e4:	df000215 	stw	fp,8(sp)
 908f7e8:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 908f7ec:	d0207805 	stb	zero,-32288(gp)
    prdytbl       = &OSRdyTbl[0];
 908f7f0:	d0a07844 	addi	r2,gp,-32287
 908f7f4:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 908f7f8:	e03fff05 	stb	zero,-4(fp)
 908f7fc:	00000806 	br	908f820 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 908f800:	e0bffe17 	ldw	r2,-8(fp)
 908f804:	10000005 	stb	zero,0(r2)
 908f808:	e0bffe17 	ldw	r2,-8(fp)
 908f80c:	10800044 	addi	r2,r2,1
 908f810:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 908f814:	e0bfff03 	ldbu	r2,-4(fp)
 908f818:	10800044 	addi	r2,r2,1
 908f81c:	e0bfff05 	stb	r2,-4(fp)
 908f820:	e0bfff03 	ldbu	r2,-4(fp)
 908f824:	108000f0 	cmpltui	r2,r2,3
 908f828:	103ff51e 	bne	r2,zero,908f800 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 908f82c:	d0206e45 	stb	zero,-32327(gp)
    OSPrioHighRdy = 0;
 908f830:	d0206e05 	stb	zero,-32328(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 908f834:	d0207615 	stw	zero,-32296(gp)
    OSTCBCur      = (OS_TCB *)0;
 908f838:	d0207b15 	stw	zero,-32276(gp)
}
 908f83c:	e037883a 	mov	sp,fp
 908f840:	df000017 	ldw	fp,0(sp)
 908f844:	dec00104 	addi	sp,sp,4
 908f848:	f800283a 	ret

0908f84c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 908f84c:	defff804 	addi	sp,sp,-32
 908f850:	dfc00715 	stw	ra,28(sp)
 908f854:	df000615 	stw	fp,24(sp)
 908f858:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 908f85c:	018243b4 	movhi	r6,2318
 908f860:	31b05f04 	addi	r6,r6,-16004
 908f864:	00bfffd4 	movui	r2,65535
 908f868:	d8800015 	stw	r2,0(sp)
 908f86c:	008243b4 	movhi	r2,2318
 908f870:	10ae6004 	addi	r2,r2,-18048
 908f874:	d8800115 	stw	r2,4(sp)
 908f878:	00808004 	movi	r2,512
 908f87c:	d8800215 	stw	r2,8(sp)
 908f880:	d8000315 	stw	zero,12(sp)
 908f884:	008000c4 	movi	r2,3
 908f888:	d8800415 	stw	r2,16(sp)
 908f88c:	01024274 	movhi	r4,2313
 908f890:	213f4004 	addi	r4,r4,-768
 908f894:	000b883a 	mov	r5,zero
 908f898:	01c00504 	movi	r7,20
 908f89c:	9094af80 	call	9094af8 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 908f8a0:	01424374 	movhi	r5,2317
 908f8a4:	29765004 	addi	r5,r5,-9920
 908f8a8:	01000504 	movi	r4,20
 908f8ac:	e1bfff04 	addi	r6,fp,-4
 908f8b0:	909542c0 	call	909542c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 908f8b4:	e037883a 	mov	sp,fp
 908f8b8:	dfc00117 	ldw	ra,4(sp)
 908f8bc:	df000017 	ldw	fp,0(sp)
 908f8c0:	dec00204 	addi	sp,sp,8
 908f8c4:	f800283a 	ret

0908f8c8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 908f8c8:	defff804 	addi	sp,sp,-32
 908f8cc:	dfc00715 	stw	ra,28(sp)
 908f8d0:	df000615 	stw	fp,24(sp)
 908f8d4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 908f8d8:	018243b4 	movhi	r6,2318
 908f8dc:	31ade704 	addi	r6,r6,-18532
 908f8e0:	00bfff94 	movui	r2,65534
 908f8e4:	d8800015 	stw	r2,0(sp)
 908f8e8:	008243b4 	movhi	r2,2318
 908f8ec:	10abe804 	addi	r2,r2,-20576
 908f8f0:	d8800115 	stw	r2,4(sp)
 908f8f4:	00808004 	movi	r2,512
 908f8f8:	d8800215 	stw	r2,8(sp)
 908f8fc:	d8000315 	stw	zero,12(sp)
 908f900:	008000c4 	movi	r2,3
 908f904:	d8800415 	stw	r2,16(sp)
 908f908:	01024274 	movhi	r4,2313
 908f90c:	213f5704 	addi	r4,r4,-676
 908f910:	000b883a 	mov	r5,zero
 908f914:	01c004c4 	movi	r7,19
 908f918:	9094af80 	call	9094af8 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 908f91c:	01424374 	movhi	r5,2317
 908f920:	29765404 	addi	r5,r5,-9904
 908f924:	010004c4 	movi	r4,19
 908f928:	e1bfff04 	addi	r6,fp,-4
 908f92c:	909542c0 	call	909542c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 908f930:	e037883a 	mov	sp,fp
 908f934:	dfc00117 	ldw	ra,4(sp)
 908f938:	df000017 	ldw	fp,0(sp)
 908f93c:	dec00204 	addi	sp,sp,8
 908f940:	f800283a 	ret

0908f944 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 908f944:	defffb04 	addi	sp,sp,-20
 908f948:	dfc00415 	stw	ra,16(sp)
 908f94c:	df000315 	stw	fp,12(sp)
 908f950:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 908f954:	010243b4 	movhi	r4,2318
 908f958:	21333004 	addi	r4,r4,-13120
 908f95c:	01414404 	movi	r5,1296
 908f960:	908fa240 	call	908fa24 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 908f964:	010243b4 	movhi	r4,2318
 908f968:	21347404 	addi	r4,r4,-11824
 908f96c:	01401504 	movi	r5,84
 908f970:	908fa240 	call	908fa24 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 908f974:	008243b4 	movhi	r2,2318
 908f978:	10b33004 	addi	r2,r2,-13120
 908f97c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 908f980:	008243b4 	movhi	r2,2318
 908f984:	10b34b04 	addi	r2,r2,-13012
 908f988:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 908f98c:	e03fff05 	stb	zero,-4(fp)
 908f990:	00001106 	br	908f9d8 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 908f994:	e0fffe17 	ldw	r3,-8(fp)
 908f998:	e0bffd17 	ldw	r2,-12(fp)
 908f99c:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 908f9a0:	e0fffe17 	ldw	r3,-8(fp)
 908f9a4:	00800fc4 	movi	r2,63
 908f9a8:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 908f9ac:	e0bffe17 	ldw	r2,-8(fp)
 908f9b0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 908f9b4:	e0bffe17 	ldw	r2,-8(fp)
 908f9b8:	10801b04 	addi	r2,r2,108
 908f9bc:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 908f9c0:	e0bffd17 	ldw	r2,-12(fp)
 908f9c4:	10801b04 	addi	r2,r2,108
 908f9c8:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 908f9cc:	e0bfff03 	ldbu	r2,-4(fp)
 908f9d0:	10800044 	addi	r2,r2,1
 908f9d4:	e0bfff05 	stb	r2,-4(fp)
 908f9d8:	e0bfff03 	ldbu	r2,-4(fp)
 908f9dc:	108002f0 	cmpltui	r2,r2,11
 908f9e0:	103fec1e 	bne	r2,zero,908f994 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 908f9e4:	e0bffe17 	ldw	r2,-8(fp)
 908f9e8:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 908f9ec:	e0fffe17 	ldw	r3,-8(fp)
 908f9f0:	00800fc4 	movi	r2,63
 908f9f4:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 908f9f8:	e0bffe17 	ldw	r2,-8(fp)
 908f9fc:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 908fa00:	d0206f15 	stw	zero,-32324(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 908fa04:	008243b4 	movhi	r2,2318
 908fa08:	10b33004 	addi	r2,r2,-13120
 908fa0c:	d0a07315 	stw	r2,-32308(gp)
}
 908fa10:	e037883a 	mov	sp,fp
 908fa14:	dfc00117 	ldw	ra,4(sp)
 908fa18:	df000017 	ldw	fp,0(sp)
 908fa1c:	dec00204 	addi	sp,sp,8
 908fa20:	f800283a 	ret

0908fa24 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 908fa24:	defffd04 	addi	sp,sp,-12
 908fa28:	df000215 	stw	fp,8(sp)
 908fa2c:	df000204 	addi	fp,sp,8
 908fa30:	e13ffe15 	stw	r4,-8(fp)
 908fa34:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 908fa38:	00000806 	br	908fa5c <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 908fa3c:	e0bffe17 	ldw	r2,-8(fp)
 908fa40:	10000005 	stb	zero,0(r2)
 908fa44:	e0bffe17 	ldw	r2,-8(fp)
 908fa48:	10800044 	addi	r2,r2,1
 908fa4c:	e0bffe15 	stw	r2,-8(fp)
        size--;
 908fa50:	e0bfff0b 	ldhu	r2,-4(fp)
 908fa54:	10bfffc4 	addi	r2,r2,-1
 908fa58:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 908fa5c:	e0bfff0b 	ldhu	r2,-4(fp)
 908fa60:	1004c03a 	cmpne	r2,r2,zero
 908fa64:	103ff51e 	bne	r2,zero,908fa3c <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 908fa68:	e037883a 	mov	sp,fp
 908fa6c:	df000017 	ldw	fp,0(sp)
 908fa70:	dec00104 	addi	sp,sp,4
 908fa74:	f800283a 	ret

0908fa78 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 908fa78:	defffc04 	addi	sp,sp,-16
 908fa7c:	df000315 	stw	fp,12(sp)
 908fa80:	df000304 	addi	fp,sp,12
 908fa84:	e13ffd15 	stw	r4,-12(fp)
 908fa88:	e17ffe15 	stw	r5,-8(fp)
 908fa8c:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 908fa90:	00000d06 	br	908fac8 <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 908fa94:	e0bffe17 	ldw	r2,-8(fp)
 908fa98:	10c00003 	ldbu	r3,0(r2)
 908fa9c:	e0bffd17 	ldw	r2,-12(fp)
 908faa0:	10c00005 	stb	r3,0(r2)
 908faa4:	e0bffd17 	ldw	r2,-12(fp)
 908faa8:	10800044 	addi	r2,r2,1
 908faac:	e0bffd15 	stw	r2,-12(fp)
 908fab0:	e0bffe17 	ldw	r2,-8(fp)
 908fab4:	10800044 	addi	r2,r2,1
 908fab8:	e0bffe15 	stw	r2,-8(fp)
        size--;
 908fabc:	e0bfff0b 	ldhu	r2,-4(fp)
 908fac0:	10bfffc4 	addi	r2,r2,-1
 908fac4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 908fac8:	e0bfff0b 	ldhu	r2,-4(fp)
 908facc:	1004c03a 	cmpne	r2,r2,zero
 908fad0:	103ff01e 	bne	r2,zero,908fa94 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 908fad4:	e037883a 	mov	sp,fp
 908fad8:	df000017 	ldw	fp,0(sp)
 908fadc:	dec00104 	addi	sp,sp,4
 908fae0:	f800283a 	ret

0908fae4 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 908fae4:	defffb04 	addi	sp,sp,-20
 908fae8:	dfc00415 	stw	ra,16(sp)
 908faec:	df000315 	stw	fp,12(sp)
 908faf0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 908faf4:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908faf8:	0005303a 	rdctl	r2,status
 908fafc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fb00:	e0fffe17 	ldw	r3,-8(fp)
 908fb04:	00bfff84 	movi	r2,-2
 908fb08:	1884703a 	and	r2,r3,r2
 908fb0c:	1001703a 	wrctl	status,r2
  
  return context;
 908fb10:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 908fb14:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 908fb18:	d0a07a03 	ldbu	r2,-32280(gp)
 908fb1c:	10803fcc 	andi	r2,r2,255
 908fb20:	1004c03a 	cmpne	r2,r2,zero
 908fb24:	10001b1e 	bne	r2,zero,908fb94 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 908fb28:	d0a06c03 	ldbu	r2,-32336(gp)
 908fb2c:	10803fcc 	andi	r2,r2,255
 908fb30:	1004c03a 	cmpne	r2,r2,zero
 908fb34:	1000171e 	bne	r2,zero,908fb94 <OS_Sched+0xb0>
            OS_SchedNew();
 908fb38:	908fbb80 	call	908fbb8 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 908fb3c:	d0a06e03 	ldbu	r2,-32328(gp)
 908fb40:	d0e06e43 	ldbu	r3,-32327(gp)
 908fb44:	11003fcc 	andi	r4,r2,255
 908fb48:	18803fcc 	andi	r2,r3,255
 908fb4c:	20801126 	beq	r4,r2,908fb94 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 908fb50:	d0a06e03 	ldbu	r2,-32328(gp)
 908fb54:	10803fcc 	andi	r2,r2,255
 908fb58:	00c243b4 	movhi	r3,2318
 908fb5c:	18f47404 	addi	r3,r3,-11824
 908fb60:	1085883a 	add	r2,r2,r2
 908fb64:	1085883a 	add	r2,r2,r2
 908fb68:	10c5883a 	add	r2,r2,r3
 908fb6c:	10800017 	ldw	r2,0(r2)
 908fb70:	d0a07615 	stw	r2,-32296(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 908fb74:	d0e07617 	ldw	r3,-32296(gp)
 908fb78:	18800e17 	ldw	r2,56(r3)
 908fb7c:	10800044 	addi	r2,r2,1
 908fb80:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 908fb84:	d0a07117 	ldw	r2,-32316(gp)
 908fb88:	10800044 	addi	r2,r2,1
 908fb8c:	d0a07115 	stw	r2,-32316(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 908fb90:	90bad8c0 	call	90bad8c <OSCtxSw>
 908fb94:	e0bfff17 	ldw	r2,-4(fp)
 908fb98:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908fb9c:	e0bffd17 	ldw	r2,-12(fp)
 908fba0:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 908fba4:	e037883a 	mov	sp,fp
 908fba8:	dfc00117 	ldw	ra,4(sp)
 908fbac:	df000017 	ldw	fp,0(sp)
 908fbb0:	dec00204 	addi	sp,sp,8
 908fbb4:	f800283a 	ret

0908fbb8 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 908fbb8:	defffe04 	addi	sp,sp,-8
 908fbbc:	df000115 	stw	fp,4(sp)
 908fbc0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 908fbc4:	d0a07803 	ldbu	r2,-32288(gp)
 908fbc8:	10c03fcc 	andi	r3,r2,255
 908fbcc:	00824374 	movhi	r2,2317
 908fbd0:	10b61004 	addi	r2,r2,-10176
 908fbd4:	10c5883a 	add	r2,r2,r3
 908fbd8:	10800003 	ldbu	r2,0(r2)
 908fbdc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 908fbe0:	e0bfff03 	ldbu	r2,-4(fp)
 908fbe4:	100490fa 	slli	r2,r2,3
 908fbe8:	1009883a 	mov	r4,r2
 908fbec:	e0ffff03 	ldbu	r3,-4(fp)
 908fbf0:	d0a07844 	addi	r2,gp,-32287
 908fbf4:	1885883a 	add	r2,r3,r2
 908fbf8:	10800003 	ldbu	r2,0(r2)
 908fbfc:	10c03fcc 	andi	r3,r2,255
 908fc00:	00824374 	movhi	r2,2317
 908fc04:	10b61004 	addi	r2,r2,-10176
 908fc08:	10c5883a 	add	r2,r2,r3
 908fc0c:	10800003 	ldbu	r2,0(r2)
 908fc10:	2085883a 	add	r2,r4,r2
 908fc14:	d0a06e05 	stb	r2,-32328(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 908fc18:	e037883a 	mov	sp,fp
 908fc1c:	df000017 	ldw	fp,0(sp)
 908fc20:	dec00104 	addi	sp,sp,4
 908fc24:	f800283a 	ret

0908fc28 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 908fc28:	defffc04 	addi	sp,sp,-16
 908fc2c:	df000315 	stw	fp,12(sp)
 908fc30:	df000304 	addi	fp,sp,12
 908fc34:	e13ffe15 	stw	r4,-8(fp)
 908fc38:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 908fc3c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 908fc40:	00000d06 	br	908fc78 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 908fc44:	e0bfff17 	ldw	r2,-4(fp)
 908fc48:	10c00003 	ldbu	r3,0(r2)
 908fc4c:	e0bffe17 	ldw	r2,-8(fp)
 908fc50:	10c00005 	stb	r3,0(r2)
 908fc54:	e0bffe17 	ldw	r2,-8(fp)
 908fc58:	10800044 	addi	r2,r2,1
 908fc5c:	e0bffe15 	stw	r2,-8(fp)
 908fc60:	e0bfff17 	ldw	r2,-4(fp)
 908fc64:	10800044 	addi	r2,r2,1
 908fc68:	e0bfff15 	stw	r2,-4(fp)
        len++;
 908fc6c:	e0bffd03 	ldbu	r2,-12(fp)
 908fc70:	10800044 	addi	r2,r2,1
 908fc74:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 908fc78:	e0bfff17 	ldw	r2,-4(fp)
 908fc7c:	10800003 	ldbu	r2,0(r2)
 908fc80:	10803fcc 	andi	r2,r2,255
 908fc84:	1004c03a 	cmpne	r2,r2,zero
 908fc88:	103fee1e 	bne	r2,zero,908fc44 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 908fc8c:	e0bffe17 	ldw	r2,-8(fp)
 908fc90:	10000005 	stb	zero,0(r2)
    return (len);
 908fc94:	e0bffd03 	ldbu	r2,-12(fp)
}
 908fc98:	e037883a 	mov	sp,fp
 908fc9c:	df000017 	ldw	fp,0(sp)
 908fca0:	dec00104 	addi	sp,sp,4
 908fca4:	f800283a 	ret

0908fca8 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 908fca8:	defffd04 	addi	sp,sp,-12
 908fcac:	df000215 	stw	fp,8(sp)
 908fcb0:	df000204 	addi	fp,sp,8
 908fcb4:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 908fcb8:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 908fcbc:	00000606 	br	908fcd8 <OS_StrLen+0x30>
        psrc++;
 908fcc0:	e0bfff17 	ldw	r2,-4(fp)
 908fcc4:	10800044 	addi	r2,r2,1
 908fcc8:	e0bfff15 	stw	r2,-4(fp)
        len++;
 908fccc:	e0bffe03 	ldbu	r2,-8(fp)
 908fcd0:	10800044 	addi	r2,r2,1
 908fcd4:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 908fcd8:	e0bfff17 	ldw	r2,-4(fp)
 908fcdc:	10800003 	ldbu	r2,0(r2)
 908fce0:	10803fcc 	andi	r2,r2,255
 908fce4:	1004c03a 	cmpne	r2,r2,zero
 908fce8:	103ff51e 	bne	r2,zero,908fcc0 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 908fcec:	e0bffe03 	ldbu	r2,-8(fp)
}
 908fcf0:	e037883a 	mov	sp,fp
 908fcf4:	df000017 	ldw	fp,0(sp)
 908fcf8:	dec00104 	addi	sp,sp,4
 908fcfc:	f800283a 	ret

0908fd00 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 908fd00:	defffa04 	addi	sp,sp,-24
 908fd04:	dfc00515 	stw	ra,20(sp)
 908fd08:	df000415 	stw	fp,16(sp)
 908fd0c:	df000404 	addi	fp,sp,16
 908fd10:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908fd14:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908fd18:	0005303a 	rdctl	r2,status
 908fd1c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fd20:	e0fffd17 	ldw	r3,-12(fp)
 908fd24:	00bfff84 	movi	r2,-2
 908fd28:	1884703a 	and	r2,r3,r2
 908fd2c:	1001703a 	wrctl	status,r2
  
  return context;
 908fd30:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 908fd34:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 908fd38:	d0a06d17 	ldw	r2,-32332(gp)
 908fd3c:	10800044 	addi	r2,r2,1
 908fd40:	d0a06d15 	stw	r2,-32332(gp)
 908fd44:	e0bffe17 	ldw	r2,-8(fp)
 908fd48:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908fd4c:	e0bffc17 	ldw	r2,-16(fp)
 908fd50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 908fd54:	90bb2440 	call	90bb244 <OSTaskIdleHook>
    }
 908fd58:	003fef06 	br	908fd18 <OS_TaskIdle+0x18>

0908fd5c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 908fd5c:	defff804 	addi	sp,sp,-32
 908fd60:	dfc00715 	stw	ra,28(sp)
 908fd64:	df000615 	stw	fp,24(sp)
 908fd68:	df000604 	addi	fp,sp,24
 908fd6c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 908fd70:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 908fd74:	00000206 	br	908fd80 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 908fd78:	01000504 	movi	r4,20
 908fd7c:	9095df00 	call	9095df0 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 908fd80:	d0a07e03 	ldbu	r2,-32264(gp)
 908fd84:	10803fcc 	andi	r2,r2,255
 908fd88:	1005003a 	cmpeq	r2,r2,zero
 908fd8c:	103ffa1e 	bne	r2,zero,908fd78 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 908fd90:	d0e07217 	ldw	r3,-32312(gp)
 908fd94:	00947b34 	movhi	r2,20972
 908fd98:	10a147c4 	addi	r2,r2,-31457
 908fd9c:	1889383a 	mul	r4,r3,r2
 908fda0:	e13ffe15 	stw	r4,-8(fp)
 908fda4:	1886383a 	mulxuu	r3,r3,r2
 908fda8:	e0ffff15 	stw	r3,-4(fp)
 908fdac:	e0ffff17 	ldw	r3,-4(fp)
 908fdb0:	1804d17a 	srli	r2,r3,5
 908fdb4:	d0a07215 	stw	r2,-32312(gp)
    if (OSIdleCtrMax == 0L) {
 908fdb8:	d0a07217 	ldw	r2,-32312(gp)
 908fdbc:	1004c03a 	cmpne	r2,r2,zero
 908fdc0:	1000031e 	bne	r2,zero,908fdd0 <OS_TaskStat+0x74>
        OSCPUUsage = 0;
 908fdc4:	d0207405 	stb	zero,-32304(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 908fdc8:	01003fc4 	movi	r4,255
 908fdcc:	9095a040 	call	9095a04 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908fdd0:	0005303a 	rdctl	r2,status
 908fdd4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908fdd8:	e0fffb17 	ldw	r3,-20(fp)
 908fddc:	00bfff84 	movi	r2,-2
 908fde0:	1884703a 	and	r2,r3,r2
 908fde4:	1001703a 	wrctl	status,r2
  
  return context;
 908fde8:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 908fdec:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 908fdf0:	d0a06d17 	ldw	r2,-32332(gp)
 908fdf4:	d0a07f15 	stw	r2,-32260(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 908fdf8:	d0206d15 	stw	zero,-32332(gp)
 908fdfc:	e0bffc17 	ldw	r2,-16(fp)
 908fe00:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908fe04:	e0bffa17 	ldw	r2,-24(fp)
 908fe08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 908fe0c:	d0e07f17 	ldw	r3,-32260(gp)
 908fe10:	d0a07217 	ldw	r2,-32312(gp)
 908fe14:	1885203a 	divu	r2,r3,r2
 908fe18:	1007883a 	mov	r3,r2
 908fe1c:	00801904 	movi	r2,100
 908fe20:	10c5c83a 	sub	r2,r2,r3
 908fe24:	d0a07405 	stb	r2,-32304(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 908fe28:	90bb1c80 	call	90bb1c8 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 908fe2c:	908fe3c0 	call	908fe3c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 908fe30:	01000284 	movi	r4,10
 908fe34:	9095df00 	call	9095df0 <OSTimeDly>
    }
 908fe38:	003fe506 	br	908fdd0 <OS_TaskStat+0x74>

0908fe3c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 908fe3c:	defffa04 	addi	sp,sp,-24
 908fe40:	dfc00515 	stw	ra,20(sp)
 908fe44:	df000415 	stw	fp,16(sp)
 908fe48:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 908fe4c:	e03ffc05 	stb	zero,-16(fp)
 908fe50:	00002406 	br	908fee4 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 908fe54:	e13ffc03 	ldbu	r4,-16(fp)
 908fe58:	e17ffe04 	addi	r5,fp,-8
 908fe5c:	90958080 	call	9095808 <OSTaskStkChk>
 908fe60:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 908fe64:	e0bffc43 	ldbu	r2,-15(fp)
 908fe68:	1004c03a 	cmpne	r2,r2,zero
 908fe6c:	10001a1e 	bne	r2,zero,908fed8 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 908fe70:	e0bffc03 	ldbu	r2,-16(fp)
 908fe74:	00c243b4 	movhi	r3,2318
 908fe78:	18f47404 	addi	r3,r3,-11824
 908fe7c:	1085883a 	add	r2,r2,r2
 908fe80:	1085883a 	add	r2,r2,r2
 908fe84:	10c5883a 	add	r2,r2,r3
 908fe88:	10800017 	ldw	r2,0(r2)
 908fe8c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 908fe90:	e0bffd17 	ldw	r2,-12(fp)
 908fe94:	1005003a 	cmpeq	r2,r2,zero
 908fe98:	10000f1e 	bne	r2,zero,908fed8 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 908fe9c:	e0bffd17 	ldw	r2,-12(fp)
 908fea0:	10800060 	cmpeqi	r2,r2,1
 908fea4:	10000c1e 	bne	r2,zero,908fed8 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 908fea8:	e0bffd17 	ldw	r2,-12(fp)
 908feac:	10c00217 	ldw	r3,8(r2)
 908feb0:	e0bffd17 	ldw	r2,-12(fp)
 908feb4:	10800317 	ldw	r2,12(r2)
 908feb8:	1085883a 	add	r2,r2,r2
 908febc:	1085883a 	add	r2,r2,r2
 908fec0:	1887883a 	add	r3,r3,r2
 908fec4:	e0bffd17 	ldw	r2,-12(fp)
 908fec8:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 908fecc:	e0ffff17 	ldw	r3,-4(fp)
 908fed0:	e0bffd17 	ldw	r2,-12(fp)
 908fed4:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 908fed8:	e0bffc03 	ldbu	r2,-16(fp)
 908fedc:	10800044 	addi	r2,r2,1
 908fee0:	e0bffc05 	stb	r2,-16(fp)
 908fee4:	e0bffc03 	ldbu	r2,-16(fp)
 908fee8:	10800570 	cmpltui	r2,r2,21
 908feec:	103fd91e 	bne	r2,zero,908fe54 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 908fef0:	e037883a 	mov	sp,fp
 908fef4:	dfc00117 	ldw	ra,4(sp)
 908fef8:	df000017 	ldw	fp,0(sp)
 908fefc:	dec00204 	addi	sp,sp,8
 908ff00:	f800283a 	ret

0908ff04 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 908ff04:	defff104 	addi	sp,sp,-60
 908ff08:	dfc00e15 	stw	ra,56(sp)
 908ff0c:	df000d15 	stw	fp,52(sp)
 908ff10:	df000d04 	addi	fp,sp,52
 908ff14:	e17ffb15 	stw	r5,-20(fp)
 908ff18:	e1bffc15 	stw	r6,-16(fp)
 908ff1c:	e0800417 	ldw	r2,16(fp)
 908ff20:	e13ffa05 	stb	r4,-24(fp)
 908ff24:	e1fffd0d 	sth	r7,-12(fp)
 908ff28:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 908ff2c:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 908ff30:	0005303a 	rdctl	r2,status
 908ff34:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 908ff38:	e0fff717 	ldw	r3,-36(fp)
 908ff3c:	00bfff84 	movi	r2,-2
 908ff40:	1884703a 	and	r2,r3,r2
 908ff44:	1001703a 	wrctl	status,r2
  
  return context;
 908ff48:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 908ff4c:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 908ff50:	d0a07317 	ldw	r2,-32308(gp)
 908ff54:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 908ff58:	e0bff917 	ldw	r2,-28(fp)
 908ff5c:	1005003a 	cmpeq	r2,r2,zero
 908ff60:	1000941e 	bne	r2,zero,90901b4 <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 908ff64:	e0bff917 	ldw	r2,-28(fp)
 908ff68:	10800517 	ldw	r2,20(r2)
 908ff6c:	d0a07315 	stw	r2,-32308(gp)
 908ff70:	e0bff817 	ldw	r2,-32(fp)
 908ff74:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 908ff78:	e0bff617 	ldw	r2,-40(fp)
 908ff7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 908ff80:	e0fff917 	ldw	r3,-28(fp)
 908ff84:	e0bffb17 	ldw	r2,-20(fp)
 908ff88:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 908ff8c:	e0fff917 	ldw	r3,-28(fp)
 908ff90:	e0bffa03 	ldbu	r2,-24(fp)
 908ff94:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 908ff98:	e0bff917 	ldw	r2,-28(fp)
 908ff9c:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 908ffa0:	e0bff917 	ldw	r2,-28(fp)
 908ffa4:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 908ffa8:	e0bff917 	ldw	r2,-28(fp)
 908ffac:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 908ffb0:	e0fff917 	ldw	r3,-28(fp)
 908ffb4:	e0800317 	ldw	r2,12(fp)
 908ffb8:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 908ffbc:	e0fff917 	ldw	r3,-28(fp)
 908ffc0:	e0800217 	ldw	r2,8(fp)
 908ffc4:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 908ffc8:	e0fff917 	ldw	r3,-28(fp)
 908ffcc:	e0bffc17 	ldw	r2,-16(fp)
 908ffd0:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 908ffd4:	e0fff917 	ldw	r3,-28(fp)
 908ffd8:	e0bffe0b 	ldhu	r2,-8(fp)
 908ffdc:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 908ffe0:	e0fff917 	ldw	r3,-28(fp)
 908ffe4:	e0bffd0b 	ldhu	r2,-12(fp)
 908ffe8:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 908ffec:	e0bff917 	ldw	r2,-28(fp)
 908fff0:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 908fff4:	e0bffa03 	ldbu	r2,-24(fp)
 908fff8:	1004d0fa 	srli	r2,r2,3
 908fffc:	1007883a 	mov	r3,r2
 9090000:	e0bff917 	ldw	r2,-28(fp)
 9090004:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 9090008:	e0bffa03 	ldbu	r2,-24(fp)
 909000c:	108001cc 	andi	r2,r2,7
 9090010:	1007883a 	mov	r3,r2
 9090014:	e0bff917 	ldw	r2,-28(fp)
 9090018:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 909001c:	e0bff917 	ldw	r2,-28(fp)
 9090020:	10800d03 	ldbu	r2,52(r2)
 9090024:	10c03fcc 	andi	r3,r2,255
 9090028:	00800044 	movi	r2,1
 909002c:	10c4983a 	sll	r2,r2,r3
 9090030:	1007883a 	mov	r3,r2
 9090034:	e0bff917 	ldw	r2,-28(fp)
 9090038:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 909003c:	e0bff917 	ldw	r2,-28(fp)
 9090040:	10800cc3 	ldbu	r2,51(r2)
 9090044:	10c03fcc 	andi	r3,r2,255
 9090048:	00800044 	movi	r2,1
 909004c:	10c4983a 	sll	r2,r2,r3
 9090050:	1007883a 	mov	r3,r2
 9090054:	e0bff917 	ldw	r2,-28(fp)
 9090058:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 909005c:	e0bff917 	ldw	r2,-28(fp)
 9090060:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 9090064:	e0bff917 	ldw	r2,-28(fp)
 9090068:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 909006c:	e0bff917 	ldw	r2,-28(fp)
 9090070:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 9090074:	e0bff917 	ldw	r2,-28(fp)
 9090078:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 909007c:	e0bff917 	ldw	r2,-28(fp)
 9090080:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 9090084:	e0bff917 	ldw	r2,-28(fp)
 9090088:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 909008c:	e0bff917 	ldw	r2,-28(fp)
 9090090:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 9090094:	e0bff917 	ldw	r2,-28(fp)
 9090098:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 909009c:	e0bff917 	ldw	r2,-28(fp)
 90900a0:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 90900a4:	e0fff917 	ldw	r3,-28(fp)
 90900a8:	00800fc4 	movi	r2,63
 90900ac:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 90900b0:	e0bff917 	ldw	r2,-28(fp)
 90900b4:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 90900b8:	e13ff917 	ldw	r4,-28(fp)
 90900bc:	90bb2600 	call	90bb260 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 90900c0:	e13ff917 	ldw	r4,-28(fp)
 90900c4:	90bb16c0 	call	90bb16c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90900c8:	0005303a 	rdctl	r2,status
 90900cc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90900d0:	e0fff517 	ldw	r3,-44(fp)
 90900d4:	00bfff84 	movi	r2,-2
 90900d8:	1884703a 	and	r2,r3,r2
 90900dc:	1001703a 	wrctl	status,r2
  
  return context;
 90900e0:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 90900e4:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 90900e8:	e0bffa03 	ldbu	r2,-24(fp)
 90900ec:	00c243b4 	movhi	r3,2318
 90900f0:	18f47404 	addi	r3,r3,-11824
 90900f4:	1085883a 	add	r2,r2,r2
 90900f8:	1085883a 	add	r2,r2,r2
 90900fc:	10c7883a 	add	r3,r2,r3
 9090100:	e0bff917 	ldw	r2,-28(fp)
 9090104:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 9090108:	d0e06f17 	ldw	r3,-32324(gp)
 909010c:	e0bff917 	ldw	r2,-28(fp)
 9090110:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 9090114:	e0bff917 	ldw	r2,-28(fp)
 9090118:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 909011c:	d0a06f17 	ldw	r2,-32324(gp)
 9090120:	1005003a 	cmpeq	r2,r2,zero
 9090124:	1000031e 	bne	r2,zero,9090134 <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 9090128:	d0e06f17 	ldw	r3,-32324(gp)
 909012c:	e0bff917 	ldw	r2,-28(fp)
 9090130:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 9090134:	e0bff917 	ldw	r2,-28(fp)
 9090138:	d0a06f15 	stw	r2,-32324(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 909013c:	e0bff917 	ldw	r2,-28(fp)
 9090140:	10c00d83 	ldbu	r3,54(r2)
 9090144:	d0a07803 	ldbu	r2,-32288(gp)
 9090148:	1884b03a 	or	r2,r3,r2
 909014c:	d0a07805 	stb	r2,-32288(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9090150:	e0bff917 	ldw	r2,-28(fp)
 9090154:	10800d03 	ldbu	r2,52(r2)
 9090158:	11003fcc 	andi	r4,r2,255
 909015c:	e0bff917 	ldw	r2,-28(fp)
 9090160:	10800d03 	ldbu	r2,52(r2)
 9090164:	10c03fcc 	andi	r3,r2,255
 9090168:	d0a07844 	addi	r2,gp,-32287
 909016c:	1885883a 	add	r2,r3,r2
 9090170:	10c00003 	ldbu	r3,0(r2)
 9090174:	e0bff917 	ldw	r2,-28(fp)
 9090178:	10800d43 	ldbu	r2,53(r2)
 909017c:	1884b03a 	or	r2,r3,r2
 9090180:	1007883a 	mov	r3,r2
 9090184:	d0a07844 	addi	r2,gp,-32287
 9090188:	2085883a 	add	r2,r4,r2
 909018c:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 9090190:	d0a07443 	ldbu	r2,-32303(gp)
 9090194:	10800044 	addi	r2,r2,1
 9090198:	d0a07445 	stb	r2,-32303(gp)
 909019c:	e0bff817 	ldw	r2,-32(fp)
 90901a0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90901a4:	e0bff417 	ldw	r2,-48(fp)
 90901a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 90901ac:	e03fff15 	stw	zero,-4(fp)
 90901b0:	00000606 	br	90901cc <OS_TCBInit+0x2c8>
 90901b4:	e0bff817 	ldw	r2,-32(fp)
 90901b8:	e0bff315 	stw	r2,-52(fp)
 90901bc:	e0bff317 	ldw	r2,-52(fp)
 90901c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 90901c4:	00801084 	movi	r2,66
 90901c8:	e0bfff15 	stw	r2,-4(fp)
 90901cc:	e0bfff17 	ldw	r2,-4(fp)
}
 90901d0:	e037883a 	mov	sp,fp
 90901d4:	dfc00117 	ldw	ra,4(sp)
 90901d8:	df000017 	ldw	fp,0(sp)
 90901dc:	dec00204 	addi	sp,sp,8
 90901e0:	f800283a 	ret

090901e4 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 90901e4:	defffe04 	addi	sp,sp,-8
 90901e8:	df000115 	stw	fp,4(sp)
 90901ec:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 90901f0:	d0a00a04 	addi	r2,gp,-32728
 90901f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 90901f8:	d0a00b04 	addi	r2,gp,-32724
 90901fc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 9090200:	d0a00c84 	addi	r2,gp,-32718
 9090204:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 9090208:	d0a00d04 	addi	r2,gp,-32716
 909020c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 9090210:	d0a00c04 	addi	r2,gp,-32720
 9090214:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 9090218:	d0a00d84 	addi	r2,gp,-32714
 909021c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 9090220:	d0a00e04 	addi	r2,gp,-32712
 9090224:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 9090228:	d0a00e84 	addi	r2,gp,-32710
 909022c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 9090230:	d0a00f04 	addi	r2,gp,-32708
 9090234:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 9090238:	d0a00f84 	addi	r2,gp,-32706
 909023c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 9090240:	d0a01004 	addi	r2,gp,-32704
 9090244:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 9090248:	d0a01084 	addi	r2,gp,-32702
 909024c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 9090250:	d0a01104 	addi	r2,gp,-32700
 9090254:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 9090258:	d0a01184 	addi	r2,gp,-32698
 909025c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 9090260:	d0a01204 	addi	r2,gp,-32696
 9090264:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 9090268:	d0a01284 	addi	r2,gp,-32694
 909026c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 9090270:	d0a01304 	addi	r2,gp,-32692
 9090274:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 9090278:	d0a01384 	addi	r2,gp,-32690
 909027c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 9090280:	d0a01404 	addi	r2,gp,-32688
 9090284:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 9090288:	d0a01484 	addi	r2,gp,-32686
 909028c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 9090290:	d0a01504 	addi	r2,gp,-32684
 9090294:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 9090298:	d0a01584 	addi	r2,gp,-32682
 909029c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 90902a0:	d0a01604 	addi	r2,gp,-32680
 90902a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 90902a8:	d0a01684 	addi	r2,gp,-32678
 90902ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 90902b0:	d0a01704 	addi	r2,gp,-32676
 90902b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 90902b8:	d0a01784 	addi	r2,gp,-32674
 90902bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 90902c0:	d0a01804 	addi	r2,gp,-32672
 90902c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 90902c8:	d0a01884 	addi	r2,gp,-32670
 90902cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 90902d0:	d0a01904 	addi	r2,gp,-32668
 90902d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 90902d8:	d0a01984 	addi	r2,gp,-32666
 90902dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 90902e0:	d0a01a04 	addi	r2,gp,-32664
 90902e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 90902e8:	d0a01a84 	addi	r2,gp,-32662
 90902ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 90902f0:	d0a01b04 	addi	r2,gp,-32660
 90902f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 90902f8:	d0a01b84 	addi	r2,gp,-32658
 90902fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 9090300:	d0a01c04 	addi	r2,gp,-32656
 9090304:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 9090308:	d0a01c84 	addi	r2,gp,-32654
 909030c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 9090310:	d0a01d04 	addi	r2,gp,-32652
 9090314:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 9090318:	d0a01d84 	addi	r2,gp,-32650
 909031c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 9090320:	d0a01e04 	addi	r2,gp,-32648
 9090324:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 9090328:	d0a01e84 	addi	r2,gp,-32646
 909032c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 9090330:	d0a01f04 	addi	r2,gp,-32644
 9090334:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 9090338:	d0a01f84 	addi	r2,gp,-32642
 909033c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 9090340:	d0a02004 	addi	r2,gp,-32640
 9090344:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 9090348:	d0a02084 	addi	r2,gp,-32638
 909034c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 9090350:	d0a02104 	addi	r2,gp,-32636
 9090354:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 9090358:	d0a02604 	addi	r2,gp,-32616
 909035c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 9090360:	e037883a 	mov	sp,fp
 9090364:	df000017 	ldw	fp,0(sp)
 9090368:	dec00104 	addi	sp,sp,4
 909036c:	f800283a 	ret

09090370 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 9090370:	defff104 	addi	sp,sp,-60
 9090374:	df000e15 	stw	fp,56(sp)
 9090378:	df000e04 	addi	fp,sp,56
 909037c:	e13ffa15 	stw	r4,-24(fp)
 9090380:	e1fffd15 	stw	r7,-12(fp)
 9090384:	e17ffb0d 	sth	r5,-20(fp)
 9090388:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 909038c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 9090390:	e0bffd17 	ldw	r2,-12(fp)
 9090394:	1004c03a 	cmpne	r2,r2,zero
 9090398:	1000021e 	bne	r2,zero,90903a4 <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 909039c:	e03fff15 	stw	zero,-4(fp)
 90903a0:	0000bb06 	br	9090690 <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 90903a4:	e0bffa17 	ldw	r2,-24(fp)
 90903a8:	1004c03a 	cmpne	r2,r2,zero
 90903ac:	1000051e 	bne	r2,zero,90903c4 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 90903b0:	e0fffd17 	ldw	r3,-12(fp)
 90903b4:	00801b84 	movi	r2,110
 90903b8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90903bc:	e03fff15 	stw	zero,-4(fp)
 90903c0:	0000b306 	br	9090690 <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 90903c4:	e0bffa17 	ldw	r2,-24(fp)
 90903c8:	10800003 	ldbu	r2,0(r2)
 90903cc:	10803fcc 	andi	r2,r2,255
 90903d0:	10800160 	cmpeqi	r2,r2,5
 90903d4:	1000051e 	bne	r2,zero,90903ec <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 90903d8:	e0fffd17 	ldw	r3,-12(fp)
 90903dc:	00800044 	movi	r2,1
 90903e0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90903e4:	e03fff15 	stw	zero,-4(fp)
 90903e8:	0000a906 	br	9090690 <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 90903ec:	e0fffc03 	ldbu	r3,-16(fp)
 90903f0:	00bfe004 	movi	r2,-128
 90903f4:	1884703a 	and	r2,r3,r2
 90903f8:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 90903fc:	e0bff943 	ldbu	r2,-27(fp)
 9090400:	1005003a 	cmpeq	r2,r2,zero
 9090404:	1000061e 	bne	r2,zero,9090420 <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 9090408:	e0bffc03 	ldbu	r2,-16(fp)
 909040c:	10801fcc 	andi	r2,r2,127
 9090410:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 9090414:	00800044 	movi	r2,1
 9090418:	e0bff905 	stb	r2,-28(fp)
 909041c:	00000106 	br	9090424 <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 9090420:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 9090424:	e0bffd17 	ldw	r2,-12(fp)
 9090428:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909042c:	0005303a 	rdctl	r2,status
 9090430:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090434:	e0fff717 	ldw	r3,-36(fp)
 9090438:	00bfff84 	movi	r2,-2
 909043c:	1884703a 	and	r2,r3,r2
 9090440:	1001703a 	wrctl	status,r2
  
  return context;
 9090444:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 9090448:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 909044c:	e0bffc03 	ldbu	r2,-16(fp)
 9090450:	e0bffe15 	stw	r2,-8(fp)
 9090454:	e0fffe17 	ldw	r3,-8(fp)
 9090458:	18800060 	cmpeqi	r2,r3,1
 909045c:	1000651e 	bne	r2,zero,90905f4 <OSFlagAccept+0x284>
 9090460:	e0fffe17 	ldw	r3,-8(fp)
 9090464:	18800088 	cmpgei	r2,r3,2
 9090468:	1000041e 	bne	r2,zero,909047c <OSFlagAccept+0x10c>
 909046c:	e0fffe17 	ldw	r3,-8(fp)
 9090470:	1805003a 	cmpeq	r2,r3,zero
 9090474:	1000421e 	bne	r2,zero,9090580 <OSFlagAccept+0x210>
 9090478:	00007b06 	br	9090668 <OSFlagAccept+0x2f8>
 909047c:	e0fffe17 	ldw	r3,-8(fp)
 9090480:	188000a0 	cmpeqi	r2,r3,2
 9090484:	1000041e 	bne	r2,zero,9090498 <OSFlagAccept+0x128>
 9090488:	e0fffe17 	ldw	r3,-8(fp)
 909048c:	188000e0 	cmpeqi	r2,r3,3
 9090490:	10001e1e 	bne	r2,zero,909050c <OSFlagAccept+0x19c>
 9090494:	00007406 	br	9090668 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 9090498:	e0bffa17 	ldw	r2,-24(fp)
 909049c:	10c0020b 	ldhu	r3,8(r2)
 90904a0:	e0bffb0b 	ldhu	r2,-20(fp)
 90904a4:	1884703a 	and	r2,r3,r2
 90904a8:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 90904ac:	e0fff98b 	ldhu	r3,-26(fp)
 90904b0:	e0bffb0b 	ldhu	r2,-20(fp)
 90904b4:	18800d1e 	bne	r3,r2,90904ec <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 90904b8:	e0bff903 	ldbu	r2,-28(fp)
 90904bc:	10800058 	cmpnei	r2,r2,1
 90904c0:	10000d1e 	bne	r2,zero,90904f8 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 90904c4:	e0bffa17 	ldw	r2,-24(fp)
 90904c8:	1080020b 	ldhu	r2,8(r2)
 90904cc:	1007883a 	mov	r3,r2
 90904d0:	e0bff98b 	ldhu	r2,-26(fp)
 90904d4:	0084303a 	nor	r2,zero,r2
 90904d8:	1884703a 	and	r2,r3,r2
 90904dc:	1007883a 	mov	r3,r2
 90904e0:	e0bffa17 	ldw	r2,-24(fp)
 90904e4:	10c0020d 	sth	r3,8(r2)
 90904e8:	00000306 	br	90904f8 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 90904ec:	e0fffd17 	ldw	r3,-12(fp)
 90904f0:	00801c04 	movi	r2,112
 90904f4:	18800005 	stb	r2,0(r3)
 90904f8:	e0bff817 	ldw	r2,-32(fp)
 90904fc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090500:	e0bff617 	ldw	r2,-40(fp)
 9090504:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 9090508:	00005f06 	br	9090688 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 909050c:	e0bffa17 	ldw	r2,-24(fp)
 9090510:	10c0020b 	ldhu	r3,8(r2)
 9090514:	e0bffb0b 	ldhu	r2,-20(fp)
 9090518:	1884703a 	and	r2,r3,r2
 909051c:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 9090520:	e0bff98b 	ldhu	r2,-26(fp)
 9090524:	1005003a 	cmpeq	r2,r2,zero
 9090528:	10000d1e 	bne	r2,zero,9090560 <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 909052c:	e0bff903 	ldbu	r2,-28(fp)
 9090530:	10800058 	cmpnei	r2,r2,1
 9090534:	10000d1e 	bne	r2,zero,909056c <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 9090538:	e0bffa17 	ldw	r2,-24(fp)
 909053c:	1080020b 	ldhu	r2,8(r2)
 9090540:	1007883a 	mov	r3,r2
 9090544:	e0bff98b 	ldhu	r2,-26(fp)
 9090548:	0084303a 	nor	r2,zero,r2
 909054c:	1884703a 	and	r2,r3,r2
 9090550:	1007883a 	mov	r3,r2
 9090554:	e0bffa17 	ldw	r2,-24(fp)
 9090558:	10c0020d 	sth	r3,8(r2)
 909055c:	00000306 	br	909056c <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 9090560:	e0fffd17 	ldw	r3,-12(fp)
 9090564:	00801c04 	movi	r2,112
 9090568:	18800005 	stb	r2,0(r3)
 909056c:	e0bff817 	ldw	r2,-32(fp)
 9090570:	e0bff515 	stw	r2,-44(fp)
 9090574:	e0bff517 	ldw	r2,-44(fp)
 9090578:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 909057c:	00004206 	br	9090688 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 9090580:	e0bffa17 	ldw	r2,-24(fp)
 9090584:	1080020b 	ldhu	r2,8(r2)
 9090588:	0084303a 	nor	r2,zero,r2
 909058c:	1007883a 	mov	r3,r2
 9090590:	e0bffb0b 	ldhu	r2,-20(fp)
 9090594:	1884703a 	and	r2,r3,r2
 9090598:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 909059c:	e0fff98b 	ldhu	r3,-26(fp)
 90905a0:	e0bffb0b 	ldhu	r2,-20(fp)
 90905a4:	18800b1e 	bne	r3,r2,90905d4 <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 90905a8:	e0bff903 	ldbu	r2,-28(fp)
 90905ac:	10800058 	cmpnei	r2,r2,1
 90905b0:	10000b1e 	bne	r2,zero,90905e0 <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 90905b4:	e0bffa17 	ldw	r2,-24(fp)
 90905b8:	10c0020b 	ldhu	r3,8(r2)
 90905bc:	e0bff98b 	ldhu	r2,-26(fp)
 90905c0:	1884b03a 	or	r2,r3,r2
 90905c4:	1007883a 	mov	r3,r2
 90905c8:	e0bffa17 	ldw	r2,-24(fp)
 90905cc:	10c0020d 	sth	r3,8(r2)
 90905d0:	00000306 	br	90905e0 <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 90905d4:	e0fffd17 	ldw	r3,-12(fp)
 90905d8:	00801c04 	movi	r2,112
 90905dc:	18800005 	stb	r2,0(r3)
 90905e0:	e0bff817 	ldw	r2,-32(fp)
 90905e4:	e0bff415 	stw	r2,-48(fp)
 90905e8:	e0bff417 	ldw	r2,-48(fp)
 90905ec:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 90905f0:	00002506 	br	9090688 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 90905f4:	e0bffa17 	ldw	r2,-24(fp)
 90905f8:	1080020b 	ldhu	r2,8(r2)
 90905fc:	0084303a 	nor	r2,zero,r2
 9090600:	1007883a 	mov	r3,r2
 9090604:	e0bffb0b 	ldhu	r2,-20(fp)
 9090608:	1884703a 	and	r2,r3,r2
 909060c:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 9090610:	e0bff98b 	ldhu	r2,-26(fp)
 9090614:	1005003a 	cmpeq	r2,r2,zero
 9090618:	10000b1e 	bne	r2,zero,9090648 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 909061c:	e0bff903 	ldbu	r2,-28(fp)
 9090620:	10800058 	cmpnei	r2,r2,1
 9090624:	10000b1e 	bne	r2,zero,9090654 <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 9090628:	e0bffa17 	ldw	r2,-24(fp)
 909062c:	10c0020b 	ldhu	r3,8(r2)
 9090630:	e0bff98b 	ldhu	r2,-26(fp)
 9090634:	1884b03a 	or	r2,r3,r2
 9090638:	1007883a 	mov	r3,r2
 909063c:	e0bffa17 	ldw	r2,-24(fp)
 9090640:	10c0020d 	sth	r3,8(r2)
 9090644:	00000306 	br	9090654 <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 9090648:	e0fffd17 	ldw	r3,-12(fp)
 909064c:	00801c04 	movi	r2,112
 9090650:	18800005 	stb	r2,0(r3)
 9090654:	e0bff817 	ldw	r2,-32(fp)
 9090658:	e0bff315 	stw	r2,-52(fp)
 909065c:	e0bff317 	ldw	r2,-52(fp)
 9090660:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 9090664:	00000806 	br	9090688 <OSFlagAccept+0x318>
 9090668:	e0bff817 	ldw	r2,-32(fp)
 909066c:	e0bff215 	stw	r2,-56(fp)
 9090670:	e0bff217 	ldw	r2,-56(fp)
 9090674:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 9090678:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 909067c:	e0fffd17 	ldw	r3,-12(fp)
 9090680:	00801bc4 	movi	r2,111
 9090684:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 9090688:	e0bff98b 	ldhu	r2,-26(fp)
 909068c:	e0bfff15 	stw	r2,-4(fp)
 9090690:	e0bfff17 	ldw	r2,-4(fp)
}
 9090694:	e037883a 	mov	sp,fp
 9090698:	df000017 	ldw	fp,0(sp)
 909069c:	dec00104 	addi	sp,sp,4
 90906a0:	f800283a 	ret

090906a4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 90906a4:	defff704 	addi	sp,sp,-36
 90906a8:	df000815 	stw	fp,32(sp)
 90906ac:	df000804 	addi	fp,sp,32
 90906b0:	e17ffe15 	stw	r5,-8(fp)
 90906b4:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 90906b8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 90906bc:	e0bffe17 	ldw	r2,-8(fp)
 90906c0:	1004c03a 	cmpne	r2,r2,zero
 90906c4:	1000021e 	bne	r2,zero,90906d0 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 90906c8:	e03fff15 	stw	zero,-4(fp)
 90906cc:	00003f06 	br	90907cc <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 90906d0:	00824374 	movhi	r2,2317
 90906d4:	108eff04 	addi	r2,r2,15356
 90906d8:	10800003 	ldbu	r2,0(r2)
 90906dc:	10803fcc 	andi	r2,r2,255
 90906e0:	1005003a 	cmpeq	r2,r2,zero
 90906e4:	1000051e 	bne	r2,zero,90906fc <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 90906e8:	e0fffe17 	ldw	r3,-8(fp)
 90906ec:	00800404 	movi	r2,16
 90906f0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 90906f4:	e03fff15 	stw	zero,-4(fp)
 90906f8:	00003406 	br	90907cc <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90906fc:	0005303a 	rdctl	r2,status
 9090700:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090704:	e0fffa17 	ldw	r3,-24(fp)
 9090708:	00bfff84 	movi	r2,-2
 909070c:	1884703a 	and	r2,r3,r2
 9090710:	1001703a 	wrctl	status,r2
  
  return context;
 9090714:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9090718:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 909071c:	00824374 	movhi	r2,2317
 9090720:	108f0204 	addi	r2,r2,15368
 9090724:	10800017 	ldw	r2,0(r2)
 9090728:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 909072c:	e0bffc17 	ldw	r2,-16(fp)
 9090730:	1005003a 	cmpeq	r2,r2,zero
 9090734:	10001c1e 	bne	r2,zero,90907a8 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 9090738:	00824374 	movhi	r2,2317
 909073c:	108f0204 	addi	r2,r2,15368
 9090740:	10800017 	ldw	r2,0(r2)
 9090744:	10800117 	ldw	r2,4(r2)
 9090748:	1007883a 	mov	r3,r2
 909074c:	00824374 	movhi	r2,2317
 9090750:	108f0204 	addi	r2,r2,15368
 9090754:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 9090758:	e0fffc17 	ldw	r3,-16(fp)
 909075c:	00800144 	movi	r2,5
 9090760:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 9090764:	e0fffc17 	ldw	r3,-16(fp)
 9090768:	e0bffd0b 	ldhu	r2,-12(fp)
 909076c:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 9090770:	e0bffc17 	ldw	r2,-16(fp)
 9090774:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 9090778:	e0fffc17 	ldw	r3,-16(fp)
 909077c:	00800fc4 	movi	r2,63
 9090780:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 9090784:	e0bffc17 	ldw	r2,-16(fp)
 9090788:	100002c5 	stb	zero,11(r2)
 909078c:	e0bffb17 	ldw	r2,-20(fp)
 9090790:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090794:	e0bff917 	ldw	r2,-28(fp)
 9090798:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 909079c:	e0bffe17 	ldw	r2,-8(fp)
 90907a0:	10000005 	stb	zero,0(r2)
 90907a4:	00000706 	br	90907c4 <OSFlagCreate+0x120>
 90907a8:	e0bffb17 	ldw	r2,-20(fp)
 90907ac:	e0bff815 	stw	r2,-32(fp)
 90907b0:	e0bff817 	ldw	r2,-32(fp)
 90907b4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 90907b8:	e0fffe17 	ldw	r3,-8(fp)
 90907bc:	00801c84 	movi	r2,114
 90907c0:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 90907c4:	e0bffc17 	ldw	r2,-16(fp)
 90907c8:	e0bfff15 	stw	r2,-4(fp)
 90907cc:	e0bfff17 	ldw	r2,-4(fp)
}
 90907d0:	e037883a 	mov	sp,fp
 90907d4:	df000017 	ldw	fp,0(sp)
 90907d8:	dec00104 	addi	sp,sp,4
 90907dc:	f800283a 	ret

090907e0 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 90907e0:	defff004 	addi	sp,sp,-64
 90907e4:	dfc00f15 	stw	ra,60(sp)
 90907e8:	df000e15 	stw	fp,56(sp)
 90907ec:	df000e04 	addi	fp,sp,56
 90907f0:	e13ffb15 	stw	r4,-20(fp)
 90907f4:	e1bffd15 	stw	r6,-12(fp)
 90907f8:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 90907fc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 9090800:	e0bffd17 	ldw	r2,-12(fp)
 9090804:	1004c03a 	cmpne	r2,r2,zero
 9090808:	1000031e 	bne	r2,zero,9090818 <OSFlagDel+0x38>
        return (pgrp);
 909080c:	e0bffb17 	ldw	r2,-20(fp)
 9090810:	e0bfff15 	stw	r2,-4(fp)
 9090814:	00009606 	br	9090a70 <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 9090818:	e0bffb17 	ldw	r2,-20(fp)
 909081c:	1004c03a 	cmpne	r2,r2,zero
 9090820:	1000061e 	bne	r2,zero,909083c <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9090824:	e0fffd17 	ldw	r3,-12(fp)
 9090828:	00801b84 	movi	r2,110
 909082c:	18800005 	stb	r2,0(r3)
        return (pgrp);
 9090830:	e0fffb17 	ldw	r3,-20(fp)
 9090834:	e0ffff15 	stw	r3,-4(fp)
 9090838:	00008d06 	br	9090a70 <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 909083c:	00824374 	movhi	r2,2317
 9090840:	108eff04 	addi	r2,r2,15356
 9090844:	10800003 	ldbu	r2,0(r2)
 9090848:	10803fcc 	andi	r2,r2,255
 909084c:	1005003a 	cmpeq	r2,r2,zero
 9090850:	1000061e 	bne	r2,zero,909086c <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 9090854:	e0fffd17 	ldw	r3,-12(fp)
 9090858:	008003c4 	movi	r2,15
 909085c:	18800005 	stb	r2,0(r3)
        return (pgrp);
 9090860:	e0bffb17 	ldw	r2,-20(fp)
 9090864:	e0bfff15 	stw	r2,-4(fp)
 9090868:	00008106 	br	9090a70 <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 909086c:	e0bffb17 	ldw	r2,-20(fp)
 9090870:	10800003 	ldbu	r2,0(r2)
 9090874:	10803fcc 	andi	r2,r2,255
 9090878:	10800160 	cmpeqi	r2,r2,5
 909087c:	1000061e 	bne	r2,zero,9090898 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 9090880:	e0fffd17 	ldw	r3,-12(fp)
 9090884:	00800044 	movi	r2,1
 9090888:	18800005 	stb	r2,0(r3)
        return (pgrp);
 909088c:	e0fffb17 	ldw	r3,-20(fp)
 9090890:	e0ffff15 	stw	r3,-4(fp)
 9090894:	00007606 	br	9090a70 <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090898:	0005303a 	rdctl	r2,status
 909089c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90908a0:	e0fff617 	ldw	r3,-40(fp)
 90908a4:	00bfff84 	movi	r2,-2
 90908a8:	1884703a 	and	r2,r3,r2
 90908ac:	1001703a 	wrctl	status,r2
  
  return context;
 90908b0:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 90908b4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 90908b8:	e0bffb17 	ldw	r2,-20(fp)
 90908bc:	10800117 	ldw	r2,4(r2)
 90908c0:	1005003a 	cmpeq	r2,r2,zero
 90908c4:	1000031e 	bne	r2,zero,90908d4 <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 90908c8:	00800044 	movi	r2,1
 90908cc:	e0bffa05 	stb	r2,-24(fp)
 90908d0:	00000106 	br	90908d8 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 90908d4:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 90908d8:	e0bffc03 	ldbu	r2,-16(fp)
 90908dc:	e0bffe15 	stw	r2,-8(fp)
 90908e0:	e0fffe17 	ldw	r3,-8(fp)
 90908e4:	1805003a 	cmpeq	r2,r3,zero
 90908e8:	1000041e 	bne	r2,zero,90908fc <OSFlagDel+0x11c>
 90908ec:	e0fffe17 	ldw	r3,-8(fp)
 90908f0:	18800060 	cmpeqi	r2,r3,1
 90908f4:	1000281e 	bne	r2,zero,9090998 <OSFlagDel+0x1b8>
 90908f8:	00005206 	br	9090a44 <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 90908fc:	e0bffa03 	ldbu	r2,-24(fp)
 9090900:	1004c03a 	cmpne	r2,r2,zero
 9090904:	10001a1e 	bne	r2,zero,9090970 <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 9090908:	e0fffb17 	ldw	r3,-20(fp)
 909090c:	00800fc4 	movi	r2,63
 9090910:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 9090914:	e0bffb17 	ldw	r2,-20(fp)
 9090918:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 909091c:	e0bffb17 	ldw	r2,-20(fp)
 9090920:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 9090924:	00824374 	movhi	r2,2317
 9090928:	108f0204 	addi	r2,r2,15368
 909092c:	10c00017 	ldw	r3,0(r2)
 9090930:	e0bffb17 	ldw	r2,-20(fp)
 9090934:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 9090938:	e0bffb17 	ldw	r2,-20(fp)
 909093c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 9090940:	00c24374 	movhi	r3,2317
 9090944:	18cf0204 	addi	r3,r3,15368
 9090948:	e0bffb17 	ldw	r2,-20(fp)
 909094c:	18800015 	stw	r2,0(r3)
 9090950:	e0bff717 	ldw	r2,-36(fp)
 9090954:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090958:	e0bff517 	ldw	r2,-44(fp)
 909095c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 9090960:	e0bffd17 	ldw	r2,-12(fp)
 9090964:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 9090968:	e03ff815 	stw	zero,-32(fp)
 909096c:	00003e06 	br	9090a68 <OSFlagDel+0x288>
 9090970:	e0bff717 	ldw	r2,-36(fp)
 9090974:	e0bff415 	stw	r2,-48(fp)
 9090978:	e0bff417 	ldw	r2,-48(fp)
 909097c:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 9090980:	e0fffd17 	ldw	r3,-12(fp)
 9090984:	00801244 	movi	r2,73
 9090988:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 909098c:	e0bffb17 	ldw	r2,-20(fp)
 9090990:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 9090994:	00003406 	br	9090a68 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 9090998:	e0bffb17 	ldw	r2,-20(fp)
 909099c:	10800117 	ldw	r2,4(r2)
 90909a0:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 90909a4:	00000606 	br	90909c0 <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 90909a8:	e13ff917 	ldw	r4,-28(fp)
 90909ac:	000b883a 	mov	r5,zero
 90909b0:	9091af00 	call	9091af0 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 90909b4:	e0bff917 	ldw	r2,-28(fp)
 90909b8:	10800017 	ldw	r2,0(r2)
 90909bc:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 90909c0:	e0bff917 	ldw	r2,-28(fp)
 90909c4:	1004c03a 	cmpne	r2,r2,zero
 90909c8:	103ff71e 	bne	r2,zero,90909a8 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 90909cc:	e0fffb17 	ldw	r3,-20(fp)
 90909d0:	00800fc4 	movi	r2,63
 90909d4:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 90909d8:	e0bffb17 	ldw	r2,-20(fp)
 90909dc:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 90909e0:	e0bffb17 	ldw	r2,-20(fp)
 90909e4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 90909e8:	00824374 	movhi	r2,2317
 90909ec:	108f0204 	addi	r2,r2,15368
 90909f0:	10c00017 	ldw	r3,0(r2)
 90909f4:	e0bffb17 	ldw	r2,-20(fp)
 90909f8:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 90909fc:	e0bffb17 	ldw	r2,-20(fp)
 9090a00:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 9090a04:	00c24374 	movhi	r3,2317
 9090a08:	18cf0204 	addi	r3,r3,15368
 9090a0c:	e0bffb17 	ldw	r2,-20(fp)
 9090a10:	18800015 	stw	r2,0(r3)
 9090a14:	e0bff717 	ldw	r2,-36(fp)
 9090a18:	e0bff315 	stw	r2,-52(fp)
 9090a1c:	e0bff317 	ldw	r2,-52(fp)
 9090a20:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 9090a24:	e0bffa03 	ldbu	r2,-24(fp)
 9090a28:	10800058 	cmpnei	r2,r2,1
 9090a2c:	1000011e 	bne	r2,zero,9090a34 <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 9090a30:	908fae40 	call	908fae4 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 9090a34:	e0bffd17 	ldw	r2,-12(fp)
 9090a38:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 9090a3c:	e03ff815 	stw	zero,-32(fp)
             break;
 9090a40:	00000906 	br	9090a68 <OSFlagDel+0x288>
 9090a44:	e0bff717 	ldw	r2,-36(fp)
 9090a48:	e0bff215 	stw	r2,-56(fp)
 9090a4c:	e0bff217 	ldw	r2,-56(fp)
 9090a50:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 9090a54:	e0fffd17 	ldw	r3,-12(fp)
 9090a58:	008001c4 	movi	r2,7
 9090a5c:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 9090a60:	e0bffb17 	ldw	r2,-20(fp)
 9090a64:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 9090a68:	e0bff817 	ldw	r2,-32(fp)
 9090a6c:	e0bfff15 	stw	r2,-4(fp)
 9090a70:	e0bfff17 	ldw	r2,-4(fp)
}
 9090a74:	e037883a 	mov	sp,fp
 9090a78:	dfc00117 	ldw	ra,4(sp)
 9090a7c:	df000017 	ldw	fp,0(sp)
 9090a80:	dec00204 	addi	sp,sp,8
 9090a84:	f800283a 	ret

09090a88 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 9090a88:	defff504 	addi	sp,sp,-44
 9090a8c:	dfc00a15 	stw	ra,40(sp)
 9090a90:	df000915 	stw	fp,36(sp)
 9090a94:	df000904 	addi	fp,sp,36
 9090a98:	e13ffc15 	stw	r4,-16(fp)
 9090a9c:	e17ffd15 	stw	r5,-12(fp)
 9090aa0:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9090aa4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9090aa8:	e0bffe17 	ldw	r2,-8(fp)
 9090aac:	1004c03a 	cmpne	r2,r2,zero
 9090ab0:	1000021e 	bne	r2,zero,9090abc <OSFlagNameGet+0x34>
        return (0);
 9090ab4:	e03fff15 	stw	zero,-4(fp)
 9090ab8:	00003e06 	br	9090bb4 <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 9090abc:	e0bffc17 	ldw	r2,-16(fp)
 9090ac0:	1004c03a 	cmpne	r2,r2,zero
 9090ac4:	1000051e 	bne	r2,zero,9090adc <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9090ac8:	e0fffe17 	ldw	r3,-8(fp)
 9090acc:	00801b84 	movi	r2,110
 9090ad0:	18800005 	stb	r2,0(r3)
        return (0);
 9090ad4:	e03fff15 	stw	zero,-4(fp)
 9090ad8:	00003606 	br	9090bb4 <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9090adc:	e0bffd17 	ldw	r2,-12(fp)
 9090ae0:	1004c03a 	cmpne	r2,r2,zero
 9090ae4:	1000051e 	bne	r2,zero,9090afc <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 9090ae8:	e0fffe17 	ldw	r3,-8(fp)
 9090aec:	00800304 	movi	r2,12
 9090af0:	18800005 	stb	r2,0(r3)
        return (0);
 9090af4:	e03fff15 	stw	zero,-4(fp)
 9090af8:	00002e06 	br	9090bb4 <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9090afc:	00824374 	movhi	r2,2317
 9090b00:	108eff04 	addi	r2,r2,15356
 9090b04:	10800003 	ldbu	r2,0(r2)
 9090b08:	10803fcc 	andi	r2,r2,255
 9090b0c:	1005003a 	cmpeq	r2,r2,zero
 9090b10:	1000051e 	bne	r2,zero,9090b28 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 9090b14:	e0fffe17 	ldw	r3,-8(fp)
 9090b18:	00800444 	movi	r2,17
 9090b1c:	18800005 	stb	r2,0(r3)
        return (0);
 9090b20:	e03fff15 	stw	zero,-4(fp)
 9090b24:	00002306 	br	9090bb4 <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090b28:	0005303a 	rdctl	r2,status
 9090b2c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090b30:	e0fff917 	ldw	r3,-28(fp)
 9090b34:	00bfff84 	movi	r2,-2
 9090b38:	1884703a 	and	r2,r3,r2
 9090b3c:	1001703a 	wrctl	status,r2
  
  return context;
 9090b40:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9090b44:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 9090b48:	e0bffc17 	ldw	r2,-16(fp)
 9090b4c:	10800003 	ldbu	r2,0(r2)
 9090b50:	10803fcc 	andi	r2,r2,255
 9090b54:	10800160 	cmpeqi	r2,r2,5
 9090b58:	1000091e 	bne	r2,zero,9090b80 <OSFlagNameGet+0xf8>
 9090b5c:	e0bffa17 	ldw	r2,-24(fp)
 9090b60:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090b64:	e0bff817 	ldw	r2,-32(fp)
 9090b68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 9090b6c:	e0fffe17 	ldw	r3,-8(fp)
 9090b70:	00800044 	movi	r2,1
 9090b74:	18800005 	stb	r2,0(r3)
        return (0);
 9090b78:	e03fff15 	stw	zero,-4(fp)
 9090b7c:	00000d06 	br	9090bb4 <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 9090b80:	e0bffc17 	ldw	r2,-16(fp)
 9090b84:	11400284 	addi	r5,r2,10
 9090b88:	e13ffd17 	ldw	r4,-12(fp)
 9090b8c:	908fc280 	call	908fc28 <OS_StrCopy>
 9090b90:	e0bffb05 	stb	r2,-20(fp)
 9090b94:	e0bffa17 	ldw	r2,-24(fp)
 9090b98:	e0bff715 	stw	r2,-36(fp)
 9090b9c:	e0bff717 	ldw	r2,-36(fp)
 9090ba0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9090ba4:	e0bffe17 	ldw	r2,-8(fp)
 9090ba8:	10000005 	stb	zero,0(r2)
    return (len);
 9090bac:	e0bffb03 	ldbu	r2,-20(fp)
 9090bb0:	e0bfff15 	stw	r2,-4(fp)
 9090bb4:	e0bfff17 	ldw	r2,-4(fp)
}
 9090bb8:	e037883a 	mov	sp,fp
 9090bbc:	dfc00117 	ldw	ra,4(sp)
 9090bc0:	df000017 	ldw	fp,0(sp)
 9090bc4:	dec00204 	addi	sp,sp,8
 9090bc8:	f800283a 	ret

09090bcc <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 9090bcc:	defff504 	addi	sp,sp,-44
 9090bd0:	dfc00a15 	stw	ra,40(sp)
 9090bd4:	df000915 	stw	fp,36(sp)
 9090bd8:	df000904 	addi	fp,sp,36
 9090bdc:	e13ffd15 	stw	r4,-12(fp)
 9090be0:	e17ffe15 	stw	r5,-8(fp)
 9090be4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9090be8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9090bec:	e0bfff17 	ldw	r2,-4(fp)
 9090bf0:	1005003a 	cmpeq	r2,r2,zero
 9090bf4:	1000451e 	bne	r2,zero,9090d0c <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 9090bf8:	e0bffd17 	ldw	r2,-12(fp)
 9090bfc:	1004c03a 	cmpne	r2,r2,zero
 9090c00:	1000041e 	bne	r2,zero,9090c14 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9090c04:	e0ffff17 	ldw	r3,-4(fp)
 9090c08:	00801b84 	movi	r2,110
 9090c0c:	18800005 	stb	r2,0(r3)
        return;
 9090c10:	00003e06 	br	9090d0c <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9090c14:	e0bffe17 	ldw	r2,-8(fp)
 9090c18:	1004c03a 	cmpne	r2,r2,zero
 9090c1c:	1000041e 	bne	r2,zero,9090c30 <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 9090c20:	e0ffff17 	ldw	r3,-4(fp)
 9090c24:	00800304 	movi	r2,12
 9090c28:	18800005 	stb	r2,0(r3)
        return;
 9090c2c:	00003706 	br	9090d0c <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9090c30:	00824374 	movhi	r2,2317
 9090c34:	108eff04 	addi	r2,r2,15356
 9090c38:	10800003 	ldbu	r2,0(r2)
 9090c3c:	10803fcc 	andi	r2,r2,255
 9090c40:	1005003a 	cmpeq	r2,r2,zero
 9090c44:	1000041e 	bne	r2,zero,9090c58 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 9090c48:	e0ffff17 	ldw	r3,-4(fp)
 9090c4c:	00800484 	movi	r2,18
 9090c50:	18800005 	stb	r2,0(r3)
        return;
 9090c54:	00002d06 	br	9090d0c <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090c58:	0005303a 	rdctl	r2,status
 9090c5c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090c60:	e0fffa17 	ldw	r3,-24(fp)
 9090c64:	00bfff84 	movi	r2,-2
 9090c68:	1884703a 	and	r2,r3,r2
 9090c6c:	1001703a 	wrctl	status,r2
  
  return context;
 9090c70:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9090c74:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 9090c78:	e0bffd17 	ldw	r2,-12(fp)
 9090c7c:	10800003 	ldbu	r2,0(r2)
 9090c80:	10803fcc 	andi	r2,r2,255
 9090c84:	10800160 	cmpeqi	r2,r2,5
 9090c88:	1000081e 	bne	r2,zero,9090cac <OSFlagNameSet+0xe0>
 9090c8c:	e0bffb17 	ldw	r2,-20(fp)
 9090c90:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090c94:	e0bff917 	ldw	r2,-28(fp)
 9090c98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 9090c9c:	e0ffff17 	ldw	r3,-4(fp)
 9090ca0:	00800044 	movi	r2,1
 9090ca4:	18800005 	stb	r2,0(r3)
        return;
 9090ca8:	00001806 	br	9090d0c <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 9090cac:	e13ffe17 	ldw	r4,-8(fp)
 9090cb0:	908fca80 	call	908fca8 <OS_StrLen>
 9090cb4:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 9090cb8:	e0bffc03 	ldbu	r2,-16(fp)
 9090cbc:	10800830 	cmpltui	r2,r2,32
 9090cc0:	1000081e 	bne	r2,zero,9090ce4 <OSFlagNameSet+0x118>
 9090cc4:	e0bffb17 	ldw	r2,-20(fp)
 9090cc8:	e0bff815 	stw	r2,-32(fp)
 9090ccc:	e0bff817 	ldw	r2,-32(fp)
 9090cd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 9090cd4:	e0ffff17 	ldw	r3,-4(fp)
 9090cd8:	00801cc4 	movi	r2,115
 9090cdc:	18800005 	stb	r2,0(r3)
        return;
 9090ce0:	00000a06 	br	9090d0c <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 9090ce4:	e0bffd17 	ldw	r2,-12(fp)
 9090ce8:	11000284 	addi	r4,r2,10
 9090cec:	e17ffe17 	ldw	r5,-8(fp)
 9090cf0:	908fc280 	call	908fc28 <OS_StrCopy>
 9090cf4:	e0bffb17 	ldw	r2,-20(fp)
 9090cf8:	e0bff715 	stw	r2,-36(fp)
 9090cfc:	e0bff717 	ldw	r2,-36(fp)
 9090d00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9090d04:	e0bfff17 	ldw	r2,-4(fp)
 9090d08:	10000005 	stb	zero,0(r2)
    return;
}
 9090d0c:	e037883a 	mov	sp,fp
 9090d10:	dfc00117 	ldw	ra,4(sp)
 9090d14:	df000017 	ldw	fp,0(sp)
 9090d18:	dec00204 	addi	sp,sp,8
 9090d1c:	f800283a 	ret

09090d20 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 9090d20:	deffe004 	addi	sp,sp,-128
 9090d24:	dfc01f15 	stw	ra,124(sp)
 9090d28:	df001e15 	stw	fp,120(sp)
 9090d2c:	df001e04 	addi	fp,sp,120
 9090d30:	e13ff915 	stw	r4,-28(fp)
 9090d34:	e17ffa0d 	sth	r5,-24(fp)
 9090d38:	e1bffb05 	stb	r6,-20(fp)
 9090d3c:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 9090d40:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 9090d44:	e0800217 	ldw	r2,8(fp)
 9090d48:	1004c03a 	cmpne	r2,r2,zero
 9090d4c:	1000021e 	bne	r2,zero,9090d58 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 9090d50:	e03fff15 	stw	zero,-4(fp)
 9090d54:	00017d06 	br	909134c <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 9090d58:	e0bff917 	ldw	r2,-28(fp)
 9090d5c:	1004c03a 	cmpne	r2,r2,zero
 9090d60:	1000051e 	bne	r2,zero,9090d78 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9090d64:	e0c00217 	ldw	r3,8(fp)
 9090d68:	00801b84 	movi	r2,110
 9090d6c:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9090d70:	e03fff15 	stw	zero,-4(fp)
 9090d74:	00017506 	br	909134c <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 9090d78:	00824374 	movhi	r2,2317
 9090d7c:	108eff04 	addi	r2,r2,15356
 9090d80:	10800003 	ldbu	r2,0(r2)
 9090d84:	10803fcc 	andi	r2,r2,255
 9090d88:	1005003a 	cmpeq	r2,r2,zero
 9090d8c:	1000051e 	bne	r2,zero,9090da4 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 9090d90:	e0c00217 	ldw	r3,8(fp)
 9090d94:	00800084 	movi	r2,2
 9090d98:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9090d9c:	e03fff15 	stw	zero,-4(fp)
 9090da0:	00016a06 	br	909134c <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 9090da4:	00824374 	movhi	r2,2317
 9090da8:	108ef104 	addi	r2,r2,15300
 9090dac:	10800003 	ldbu	r2,0(r2)
 9090db0:	10803fcc 	andi	r2,r2,255
 9090db4:	1005003a 	cmpeq	r2,r2,zero
 9090db8:	1000051e 	bne	r2,zero,9090dd0 <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 9090dbc:	e0c00217 	ldw	r3,8(fp)
 9090dc0:	00800344 	movi	r2,13
 9090dc4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9090dc8:	e03fff15 	stw	zero,-4(fp)
 9090dcc:	00015f06 	br	909134c <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 9090dd0:	e0bff917 	ldw	r2,-28(fp)
 9090dd4:	10800003 	ldbu	r2,0(r2)
 9090dd8:	10803fcc 	andi	r2,r2,255
 9090ddc:	10800160 	cmpeqi	r2,r2,5
 9090de0:	1000051e 	bne	r2,zero,9090df8 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 9090de4:	e0c00217 	ldw	r3,8(fp)
 9090de8:	00800044 	movi	r2,1
 9090dec:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9090df0:	e03fff15 	stw	zero,-4(fp)
 9090df4:	00015506 	br	909134c <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 9090df8:	e0fffb03 	ldbu	r3,-20(fp)
 9090dfc:	00bfe004 	movi	r2,-128
 9090e00:	1884703a 	and	r2,r3,r2
 9090e04:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 9090e08:	e0bff283 	ldbu	r2,-54(fp)
 9090e0c:	1005003a 	cmpeq	r2,r2,zero
 9090e10:	1000071e 	bne	r2,zero,9090e30 <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 9090e14:	00c01fc4 	movi	r3,127
 9090e18:	e0bffb03 	ldbu	r2,-20(fp)
 9090e1c:	10c4703a 	and	r2,r2,r3
 9090e20:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 9090e24:	00800044 	movi	r2,1
 9090e28:	e0bff205 	stb	r2,-56(fp)
 9090e2c:	00000106 	br	9090e34 <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 9090e30:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9090e34:	0005303a 	rdctl	r2,status
 9090e38:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9090e3c:	e0fff017 	ldw	r3,-64(fp)
 9090e40:	00bfff84 	movi	r2,-2
 9090e44:	1884703a 	and	r2,r3,r2
 9090e48:	1001703a 	wrctl	status,r2
  
  return context;
 9090e4c:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 9090e50:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 9090e54:	e0bffb03 	ldbu	r2,-20(fp)
 9090e58:	e0bffe15 	stw	r2,-8(fp)
 9090e5c:	e0fffe17 	ldw	r3,-8(fp)
 9090e60:	18800060 	cmpeqi	r2,r3,1
 9090e64:	1000981e 	bne	r2,zero,90910c8 <OSFlagPend+0x3a8>
 9090e68:	e0fffe17 	ldw	r3,-8(fp)
 9090e6c:	18800088 	cmpgei	r2,r3,2
 9090e70:	1000041e 	bne	r2,zero,9090e84 <OSFlagPend+0x164>
 9090e74:	e0fffe17 	ldw	r3,-8(fp)
 9090e78:	1805003a 	cmpeq	r2,r3,zero
 9090e7c:	1000641e 	bne	r2,zero,9091010 <OSFlagPend+0x2f0>
 9090e80:	0000bf06 	br	9091180 <OSFlagPend+0x460>
 9090e84:	e0fffe17 	ldw	r3,-8(fp)
 9090e88:	188000a0 	cmpeqi	r2,r3,2
 9090e8c:	1000041e 	bne	r2,zero,9090ea0 <OSFlagPend+0x180>
 9090e90:	e0fffe17 	ldw	r3,-8(fp)
 9090e94:	188000e0 	cmpeqi	r2,r3,3
 9090e98:	10002f1e 	bne	r2,zero,9090f58 <OSFlagPend+0x238>
 9090e9c:	0000b806 	br	9091180 <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 9090ea0:	e0bff917 	ldw	r2,-28(fp)
 9090ea4:	10c0020b 	ldhu	r3,8(r2)
 9090ea8:	e0bffa0b 	ldhu	r2,-24(fp)
 9090eac:	1884703a 	and	r2,r3,r2
 9090eb0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 9090eb4:	e0fff30b 	ldhu	r3,-52(fp)
 9090eb8:	e0bffa0b 	ldhu	r2,-24(fp)
 9090ebc:	18801a1e 	bne	r3,r2,9090f28 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 9090ec0:	e0bff203 	ldbu	r2,-56(fp)
 9090ec4:	10800058 	cmpnei	r2,r2,1
 9090ec8:	1000091e 	bne	r2,zero,9090ef0 <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 9090ecc:	e0bff917 	ldw	r2,-28(fp)
 9090ed0:	1080020b 	ldhu	r2,8(r2)
 9090ed4:	1007883a 	mov	r3,r2
 9090ed8:	e0bff30b 	ldhu	r2,-52(fp)
 9090edc:	0084303a 	nor	r2,zero,r2
 9090ee0:	1884703a 	and	r2,r3,r2
 9090ee4:	1007883a 	mov	r3,r2
 9090ee8:	e0bff917 	ldw	r2,-28(fp)
 9090eec:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9090ef0:	00824374 	movhi	r2,2317
 9090ef4:	108f0004 	addi	r2,r2,15360
 9090ef8:	10c00017 	ldw	r3,0(r2)
 9090efc:	e0bff30b 	ldhu	r2,-52(fp)
 9090f00:	18800b0d 	sth	r2,44(r3)
 9090f04:	e0bff117 	ldw	r2,-60(fp)
 9090f08:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9090f0c:	e0bfef17 	ldw	r2,-68(fp)
 9090f10:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 9090f14:	e0800217 	ldw	r2,8(fp)
 9090f18:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 9090f1c:	e0bff30b 	ldhu	r2,-52(fp)
 9090f20:	e0bfff15 	stw	r2,-4(fp)
 9090f24:	00010906 	br	909134c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 9090f28:	e1bffa0b 	ldhu	r6,-24(fp)
 9090f2c:	e1fffb03 	ldbu	r7,-20(fp)
 9090f30:	e0bffc0b 	ldhu	r2,-16(fp)
 9090f34:	e17ff404 	addi	r5,fp,-48
 9090f38:	d8800015 	stw	r2,0(sp)
 9090f3c:	e13ff917 	ldw	r4,-28(fp)
 9090f40:	90918480 	call	9091848 <OS_FlagBlock>
 9090f44:	e0bff117 	ldw	r2,-60(fp)
 9090f48:	e0bfee15 	stw	r2,-72(fp)
 9090f4c:	e0bfee17 	ldw	r2,-72(fp)
 9090f50:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 9090f54:	00009506 	br	90911ac <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 9090f58:	e0bff917 	ldw	r2,-28(fp)
 9090f5c:	10c0020b 	ldhu	r3,8(r2)
 9090f60:	e0bffa0b 	ldhu	r2,-24(fp)
 9090f64:	1884703a 	and	r2,r3,r2
 9090f68:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 9090f6c:	e0bff30b 	ldhu	r2,-52(fp)
 9090f70:	1005003a 	cmpeq	r2,r2,zero
 9090f74:	10001a1e 	bne	r2,zero,9090fe0 <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 9090f78:	e0bff203 	ldbu	r2,-56(fp)
 9090f7c:	10800058 	cmpnei	r2,r2,1
 9090f80:	1000091e 	bne	r2,zero,9090fa8 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 9090f84:	e0bff917 	ldw	r2,-28(fp)
 9090f88:	1080020b 	ldhu	r2,8(r2)
 9090f8c:	1007883a 	mov	r3,r2
 9090f90:	e0bff30b 	ldhu	r2,-52(fp)
 9090f94:	0084303a 	nor	r2,zero,r2
 9090f98:	1884703a 	and	r2,r3,r2
 9090f9c:	1007883a 	mov	r3,r2
 9090fa0:	e0bff917 	ldw	r2,-28(fp)
 9090fa4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9090fa8:	00824374 	movhi	r2,2317
 9090fac:	108f0004 	addi	r2,r2,15360
 9090fb0:	10c00017 	ldw	r3,0(r2)
 9090fb4:	e0bff30b 	ldhu	r2,-52(fp)
 9090fb8:	18800b0d 	sth	r2,44(r3)
 9090fbc:	e0bff117 	ldw	r2,-60(fp)
 9090fc0:	e0bfed15 	stw	r2,-76(fp)
 9090fc4:	e0bfed17 	ldw	r2,-76(fp)
 9090fc8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 9090fcc:	e0800217 	ldw	r2,8(fp)
 9090fd0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 9090fd4:	e0fff30b 	ldhu	r3,-52(fp)
 9090fd8:	e0ffff15 	stw	r3,-4(fp)
 9090fdc:	0000db06 	br	909134c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 9090fe0:	e1bffa0b 	ldhu	r6,-24(fp)
 9090fe4:	e1fffb03 	ldbu	r7,-20(fp)
 9090fe8:	e0bffc0b 	ldhu	r2,-16(fp)
 9090fec:	e17ff404 	addi	r5,fp,-48
 9090ff0:	d8800015 	stw	r2,0(sp)
 9090ff4:	e13ff917 	ldw	r4,-28(fp)
 9090ff8:	90918480 	call	9091848 <OS_FlagBlock>
 9090ffc:	e0bff117 	ldw	r2,-60(fp)
 9091000:	e0bfec15 	stw	r2,-80(fp)
 9091004:	e0bfec17 	ldw	r2,-80(fp)
 9091008:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 909100c:	00006706 	br	90911ac <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 9091010:	e0bff917 	ldw	r2,-28(fp)
 9091014:	1080020b 	ldhu	r2,8(r2)
 9091018:	0084303a 	nor	r2,zero,r2
 909101c:	1007883a 	mov	r3,r2
 9091020:	e0bffa0b 	ldhu	r2,-24(fp)
 9091024:	1884703a 	and	r2,r3,r2
 9091028:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 909102c:	e0fff30b 	ldhu	r3,-52(fp)
 9091030:	e0bffa0b 	ldhu	r2,-24(fp)
 9091034:	1880181e 	bne	r3,r2,9091098 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 9091038:	e0bff203 	ldbu	r2,-56(fp)
 909103c:	10800058 	cmpnei	r2,r2,1
 9091040:	1000071e 	bne	r2,zero,9091060 <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 9091044:	e0bff917 	ldw	r2,-28(fp)
 9091048:	10c0020b 	ldhu	r3,8(r2)
 909104c:	e0bff30b 	ldhu	r2,-52(fp)
 9091050:	1884b03a 	or	r2,r3,r2
 9091054:	1007883a 	mov	r3,r2
 9091058:	e0bff917 	ldw	r2,-28(fp)
 909105c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9091060:	00824374 	movhi	r2,2317
 9091064:	108f0004 	addi	r2,r2,15360
 9091068:	10c00017 	ldw	r3,0(r2)
 909106c:	e0bff30b 	ldhu	r2,-52(fp)
 9091070:	18800b0d 	sth	r2,44(r3)
 9091074:	e0bff117 	ldw	r2,-60(fp)
 9091078:	e0bfeb15 	stw	r2,-84(fp)
 909107c:	e0bfeb17 	ldw	r2,-84(fp)
 9091080:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 9091084:	e0800217 	ldw	r2,8(fp)
 9091088:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 909108c:	e0bff30b 	ldhu	r2,-52(fp)
 9091090:	e0bfff15 	stw	r2,-4(fp)
 9091094:	0000ad06 	br	909134c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 9091098:	e1bffa0b 	ldhu	r6,-24(fp)
 909109c:	e1fffb03 	ldbu	r7,-20(fp)
 90910a0:	e0bffc0b 	ldhu	r2,-16(fp)
 90910a4:	e17ff404 	addi	r5,fp,-48
 90910a8:	d8800015 	stw	r2,0(sp)
 90910ac:	e13ff917 	ldw	r4,-28(fp)
 90910b0:	90918480 	call	9091848 <OS_FlagBlock>
 90910b4:	e0bff117 	ldw	r2,-60(fp)
 90910b8:	e0bfea15 	stw	r2,-88(fp)
 90910bc:	e0bfea17 	ldw	r2,-88(fp)
 90910c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 90910c4:	00003906 	br	90911ac <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 90910c8:	e0bff917 	ldw	r2,-28(fp)
 90910cc:	1080020b 	ldhu	r2,8(r2)
 90910d0:	0084303a 	nor	r2,zero,r2
 90910d4:	1007883a 	mov	r3,r2
 90910d8:	e0bffa0b 	ldhu	r2,-24(fp)
 90910dc:	1884703a 	and	r2,r3,r2
 90910e0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 90910e4:	e0bff30b 	ldhu	r2,-52(fp)
 90910e8:	1005003a 	cmpeq	r2,r2,zero
 90910ec:	1000181e 	bne	r2,zero,9091150 <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 90910f0:	e0bff203 	ldbu	r2,-56(fp)
 90910f4:	10800058 	cmpnei	r2,r2,1
 90910f8:	1000071e 	bne	r2,zero,9091118 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 90910fc:	e0bff917 	ldw	r2,-28(fp)
 9091100:	10c0020b 	ldhu	r3,8(r2)
 9091104:	e0bff30b 	ldhu	r2,-52(fp)
 9091108:	1884b03a 	or	r2,r3,r2
 909110c:	1007883a 	mov	r3,r2
 9091110:	e0bff917 	ldw	r2,-28(fp)
 9091114:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 9091118:	00824374 	movhi	r2,2317
 909111c:	108f0004 	addi	r2,r2,15360
 9091120:	10c00017 	ldw	r3,0(r2)
 9091124:	e0bff30b 	ldhu	r2,-52(fp)
 9091128:	18800b0d 	sth	r2,44(r3)
 909112c:	e0bff117 	ldw	r2,-60(fp)
 9091130:	e0bfe915 	stw	r2,-92(fp)
 9091134:	e0bfe917 	ldw	r2,-92(fp)
 9091138:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 909113c:	e0800217 	ldw	r2,8(fp)
 9091140:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 9091144:	e0fff30b 	ldhu	r3,-52(fp)
 9091148:	e0ffff15 	stw	r3,-4(fp)
 909114c:	00007f06 	br	909134c <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 9091150:	e1bffa0b 	ldhu	r6,-24(fp)
 9091154:	e1fffb03 	ldbu	r7,-20(fp)
 9091158:	e0bffc0b 	ldhu	r2,-16(fp)
 909115c:	e17ff404 	addi	r5,fp,-48
 9091160:	d8800015 	stw	r2,0(sp)
 9091164:	e13ff917 	ldw	r4,-28(fp)
 9091168:	90918480 	call	9091848 <OS_FlagBlock>
 909116c:	e0bff117 	ldw	r2,-60(fp)
 9091170:	e0bfe815 	stw	r2,-96(fp)
 9091174:	e0bfe817 	ldw	r2,-96(fp)
 9091178:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 909117c:	00000b06 	br	90911ac <OSFlagPend+0x48c>
 9091180:	e0bff117 	ldw	r2,-60(fp)
 9091184:	e0bfe715 	stw	r2,-100(fp)
 9091188:	e0bfe717 	ldw	r2,-100(fp)
 909118c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 9091190:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 9091194:	e0c00217 	ldw	r3,8(fp)
 9091198:	00801bc4 	movi	r2,111
 909119c:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 90911a0:	e0bff30b 	ldhu	r2,-52(fp)
 90911a4:	e0bfff15 	stw	r2,-4(fp)
 90911a8:	00006806 	br	909134c <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 90911ac:	908fae40 	call	908fae4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90911b0:	0005303a 	rdctl	r2,status
 90911b4:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90911b8:	e0ffe617 	ldw	r3,-104(fp)
 90911bc:	00bfff84 	movi	r2,-2
 90911c0:	1884703a 	and	r2,r3,r2
 90911c4:	1001703a 	wrctl	status,r2
  
  return context;
 90911c8:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 90911cc:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 90911d0:	00824374 	movhi	r2,2317
 90911d4:	108f0004 	addi	r2,r2,15360
 90911d8:	10800017 	ldw	r2,0(r2)
 90911dc:	10800c43 	ldbu	r2,49(r2)
 90911e0:	10803fcc 	andi	r2,r2,255
 90911e4:	1005003a 	cmpeq	r2,r2,zero
 90911e8:	1000221e 	bne	r2,zero,9091274 <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 90911ec:	00824374 	movhi	r2,2317
 90911f0:	108f0004 	addi	r2,r2,15360
 90911f4:	10800017 	ldw	r2,0(r2)
 90911f8:	10800c43 	ldbu	r2,49(r2)
 90911fc:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9091200:	00824374 	movhi	r2,2317
 9091204:	108f0004 	addi	r2,r2,15360
 9091208:	10800017 	ldw	r2,0(r2)
 909120c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 9091210:	e13ff404 	addi	r4,fp,-48
 9091214:	9091c000 	call	9091c00 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 9091218:	00824374 	movhi	r2,2317
 909121c:	108f0004 	addi	r2,r2,15360
 9091220:	10800017 	ldw	r2,0(r2)
 9091224:	10000c05 	stb	zero,48(r2)
 9091228:	e0bff117 	ldw	r2,-60(fp)
 909122c:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091230:	e0bfe517 	ldw	r2,-108(fp)
 9091234:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 9091238:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 909123c:	e0bff243 	ldbu	r2,-55(fp)
 9091240:	108000a0 	cmpeqi	r2,r2,2
 9091244:	1000011e 	bne	r2,zero,909124c <OSFlagPend+0x52c>
 9091248:	00000406 	br	909125c <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 909124c:	e0c00217 	ldw	r3,8(fp)
 9091250:	00800384 	movi	r2,14
 9091254:	18800005 	stb	r2,0(r3)
                 break;
 9091258:	00000306 	br	9091268 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 909125c:	e0c00217 	ldw	r3,8(fp)
 9091260:	00800284 	movi	r2,10
 9091264:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 9091268:	e0fff30b 	ldhu	r3,-52(fp)
 909126c:	e0ffff15 	stw	r3,-4(fp)
 9091270:	00003606 	br	909134c <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 9091274:	00824374 	movhi	r2,2317
 9091278:	108f0004 	addi	r2,r2,15360
 909127c:	10800017 	ldw	r2,0(r2)
 9091280:	10800b0b 	ldhu	r2,44(r2)
 9091284:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 9091288:	e0bff203 	ldbu	r2,-56(fp)
 909128c:	10800058 	cmpnei	r2,r2,1
 9091290:	1000261e 	bne	r2,zero,909132c <OSFlagPend+0x60c>
        switch (wait_type) {
 9091294:	e0bffb03 	ldbu	r2,-20(fp)
 9091298:	e0bffd15 	stw	r2,-12(fp)
 909129c:	e0fffd17 	ldw	r3,-12(fp)
 90912a0:	1804803a 	cmplt	r2,r3,zero
 90912a4:	1000181e 	bne	r2,zero,9091308 <OSFlagPend+0x5e8>
 90912a8:	e0fffd17 	ldw	r3,-12(fp)
 90912ac:	18800090 	cmplti	r2,r3,2
 90912b0:	10000d1e 	bne	r2,zero,90912e8 <OSFlagPend+0x5c8>
 90912b4:	e0fffd17 	ldw	r3,-12(fp)
 90912b8:	18800108 	cmpgei	r2,r3,4
 90912bc:	1000121e 	bne	r2,zero,9091308 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 90912c0:	e0bff917 	ldw	r2,-28(fp)
 90912c4:	1080020b 	ldhu	r2,8(r2)
 90912c8:	1007883a 	mov	r3,r2
 90912cc:	e0bff30b 	ldhu	r2,-52(fp)
 90912d0:	0084303a 	nor	r2,zero,r2
 90912d4:	1884703a 	and	r2,r3,r2
 90912d8:	1007883a 	mov	r3,r2
 90912dc:	e0bff917 	ldw	r2,-28(fp)
 90912e0:	10c0020d 	sth	r3,8(r2)
                 break;
 90912e4:	00001106 	br	909132c <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 90912e8:	e0bff917 	ldw	r2,-28(fp)
 90912ec:	10c0020b 	ldhu	r3,8(r2)
 90912f0:	e0bff30b 	ldhu	r2,-52(fp)
 90912f4:	1884b03a 	or	r2,r3,r2
 90912f8:	1007883a 	mov	r3,r2
 90912fc:	e0bff917 	ldw	r2,-28(fp)
 9091300:	10c0020d 	sth	r3,8(r2)
                 break;
 9091304:	00000906 	br	909132c <OSFlagPend+0x60c>
 9091308:	e0bff117 	ldw	r2,-60(fp)
 909130c:	e0bfe415 	stw	r2,-112(fp)
 9091310:	e0bfe417 	ldw	r2,-112(fp)
 9091314:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 9091318:	e0c00217 	ldw	r3,8(fp)
 909131c:	00801bc4 	movi	r2,111
 9091320:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 9091324:	e03fff15 	stw	zero,-4(fp)
 9091328:	00000806 	br	909134c <OSFlagPend+0x62c>
 909132c:	e0bff117 	ldw	r2,-60(fp)
 9091330:	e0bfe315 	stw	r2,-116(fp)
 9091334:	e0bfe317 	ldw	r2,-116(fp)
 9091338:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 909133c:	e0800217 	ldw	r2,8(fp)
 9091340:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 9091344:	e0bff30b 	ldhu	r2,-52(fp)
 9091348:	e0bfff15 	stw	r2,-4(fp)
 909134c:	e0bfff17 	ldw	r2,-4(fp)
}
 9091350:	e037883a 	mov	sp,fp
 9091354:	dfc00117 	ldw	ra,4(sp)
 9091358:	df000017 	ldw	fp,0(sp)
 909135c:	dec00204 	addi	sp,sp,8
 9091360:	f800283a 	ret

09091364 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 9091364:	defffb04 	addi	sp,sp,-20
 9091368:	df000415 	stw	fp,16(sp)
 909136c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 9091370:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091374:	0005303a 	rdctl	r2,status
 9091378:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909137c:	e0fffd17 	ldw	r3,-12(fp)
 9091380:	00bfff84 	movi	r2,-2
 9091384:	1884703a 	and	r2,r3,r2
 9091388:	1001703a 	wrctl	status,r2
  
  return context;
 909138c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 9091390:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 9091394:	00824374 	movhi	r2,2317
 9091398:	108f0004 	addi	r2,r2,15360
 909139c:	10800017 	ldw	r2,0(r2)
 90913a0:	10800b0b 	ldhu	r2,44(r2)
 90913a4:	e0bfff0d 	sth	r2,-4(fp)
 90913a8:	e0bffe17 	ldw	r2,-8(fp)
 90913ac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90913b0:	e0bffc17 	ldw	r2,-16(fp)
 90913b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 90913b8:	e0bfff0b 	ldhu	r2,-4(fp)
}
 90913bc:	e037883a 	mov	sp,fp
 90913c0:	df000017 	ldw	fp,0(sp)
 90913c4:	dec00104 	addi	sp,sp,4
 90913c8:	f800283a 	ret

090913cc <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 90913cc:	deffed04 	addi	sp,sp,-76
 90913d0:	dfc01215 	stw	ra,72(sp)
 90913d4:	df001115 	stw	fp,68(sp)
 90913d8:	df001104 	addi	fp,sp,68
 90913dc:	e13ff915 	stw	r4,-28(fp)
 90913e0:	e1fffc15 	stw	r7,-16(fp)
 90913e4:	e17ffa0d 	sth	r5,-24(fp)
 90913e8:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 90913ec:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 90913f0:	e0bffc17 	ldw	r2,-16(fp)
 90913f4:	1004c03a 	cmpne	r2,r2,zero
 90913f8:	1000021e 	bne	r2,zero,9091404 <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 90913fc:	e03fff15 	stw	zero,-4(fp)
 9091400:	0000d606 	br	909175c <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 9091404:	e0bff917 	ldw	r2,-28(fp)
 9091408:	1004c03a 	cmpne	r2,r2,zero
 909140c:	1000051e 	bne	r2,zero,9091424 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 9091410:	e0fffc17 	ldw	r3,-16(fp)
 9091414:	00801b84 	movi	r2,110
 9091418:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 909141c:	e03fff15 	stw	zero,-4(fp)
 9091420:	0000ce06 	br	909175c <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 9091424:	e0bff917 	ldw	r2,-28(fp)
 9091428:	10800003 	ldbu	r2,0(r2)
 909142c:	10803fcc 	andi	r2,r2,255
 9091430:	10800160 	cmpeqi	r2,r2,5
 9091434:	1000051e 	bne	r2,zero,909144c <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 9091438:	e0fffc17 	ldw	r3,-16(fp)
 909143c:	00800044 	movi	r2,1
 9091440:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 9091444:	e03fff15 	stw	zero,-4(fp)
 9091448:	0000c406 	br	909175c <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909144c:	0005303a 	rdctl	r2,status
 9091450:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091454:	e0fff417 	ldw	r3,-48(fp)
 9091458:	00bfff84 	movi	r2,-2
 909145c:	1884703a 	and	r2,r3,r2
 9091460:	1001703a 	wrctl	status,r2
  
  return context;
 9091464:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 9091468:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 909146c:	e0bffb03 	ldbu	r2,-20(fp)
 9091470:	e0bffe15 	stw	r2,-8(fp)
 9091474:	e0fffe17 	ldw	r3,-8(fp)
 9091478:	1805003a 	cmpeq	r2,r3,zero
 909147c:	1000041e 	bne	r2,zero,9091490 <OSFlagPost+0xc4>
 9091480:	e0fffe17 	ldw	r3,-8(fp)
 9091484:	18800060 	cmpeqi	r2,r3,1
 9091488:	10000b1e 	bne	r2,zero,90914b8 <OSFlagPost+0xec>
 909148c:	00001206 	br	90914d8 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 9091490:	e0bff917 	ldw	r2,-28(fp)
 9091494:	1080020b 	ldhu	r2,8(r2)
 9091498:	1007883a 	mov	r3,r2
 909149c:	e0bffa0b 	ldhu	r2,-24(fp)
 90914a0:	0084303a 	nor	r2,zero,r2
 90914a4:	1884703a 	and	r2,r3,r2
 90914a8:	1007883a 	mov	r3,r2
 90914ac:	e0bff917 	ldw	r2,-28(fp)
 90914b0:	10c0020d 	sth	r3,8(r2)
             break;
 90914b4:	00001106 	br	90914fc <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 90914b8:	e0bff917 	ldw	r2,-28(fp)
 90914bc:	10c0020b 	ldhu	r3,8(r2)
 90914c0:	e0bffa0b 	ldhu	r2,-24(fp)
 90914c4:	1884b03a 	or	r2,r3,r2
 90914c8:	1007883a 	mov	r3,r2
 90914cc:	e0bff917 	ldw	r2,-28(fp)
 90914d0:	10c0020d 	sth	r3,8(r2)
             break;
 90914d4:	00000906 	br	90914fc <OSFlagPost+0x130>
 90914d8:	e0bff517 	ldw	r2,-44(fp)
 90914dc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90914e0:	e0bff317 	ldw	r2,-52(fp)
 90914e4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 90914e8:	e0fffc17 	ldw	r3,-16(fp)
 90914ec:	00801c44 	movi	r2,113
 90914f0:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 90914f4:	e03fff15 	stw	zero,-4(fp)
 90914f8:	00009806 	br	909175c <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 90914fc:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 9091500:	e0bff917 	ldw	r2,-28(fp)
 9091504:	10800117 	ldw	r2,4(r2)
 9091508:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 909150c:	00007506 	br	90916e4 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 9091510:	e0bff817 	ldw	r2,-32(fp)
 9091514:	10800483 	ldbu	r2,18(r2)
 9091518:	10803fcc 	andi	r2,r2,255
 909151c:	e0bffd15 	stw	r2,-12(fp)
 9091520:	e0fffd17 	ldw	r3,-12(fp)
 9091524:	18800060 	cmpeqi	r2,r3,1
 9091528:	10004d1e 	bne	r2,zero,9091660 <OSFlagPost+0x294>
 909152c:	e0fffd17 	ldw	r3,-12(fp)
 9091530:	18800088 	cmpgei	r2,r3,2
 9091534:	1000041e 	bne	r2,zero,9091548 <OSFlagPost+0x17c>
 9091538:	e0fffd17 	ldw	r3,-12(fp)
 909153c:	1805003a 	cmpeq	r2,r3,zero
 9091540:	1000301e 	bne	r2,zero,9091604 <OSFlagPost+0x238>
 9091544:	00005b06 	br	90916b4 <OSFlagPost+0x2e8>
 9091548:	e0fffd17 	ldw	r3,-12(fp)
 909154c:	188000a0 	cmpeqi	r2,r3,2
 9091550:	1000041e 	bne	r2,zero,9091564 <OSFlagPost+0x198>
 9091554:	e0fffd17 	ldw	r3,-12(fp)
 9091558:	188000e0 	cmpeqi	r2,r3,3
 909155c:	1000161e 	bne	r2,zero,90915b8 <OSFlagPost+0x1ec>
 9091560:	00005406 	br	90916b4 <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9091564:	e0bff917 	ldw	r2,-28(fp)
 9091568:	10c0020b 	ldhu	r3,8(r2)
 909156c:	e0bff817 	ldw	r2,-32(fp)
 9091570:	1080040b 	ldhu	r2,16(r2)
 9091574:	1884703a 	and	r2,r3,r2
 9091578:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 909157c:	e0bff817 	ldw	r2,-32(fp)
 9091580:	1080040b 	ldhu	r2,16(r2)
 9091584:	10ffffcc 	andi	r3,r2,65535
 9091588:	e0bff68b 	ldhu	r2,-38(fp)
 909158c:	1880521e 	bne	r3,r2,90916d8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 9091590:	e17ff68b 	ldhu	r5,-38(fp)
 9091594:	e13ff817 	ldw	r4,-32(fp)
 9091598:	9091af00 	call	9091af0 <OS_FlagTaskRdy>
 909159c:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 90915a0:	e0bff603 	ldbu	r2,-40(fp)
 90915a4:	10800058 	cmpnei	r2,r2,1
 90915a8:	10004b1e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 90915ac:	00800044 	movi	r2,1
 90915b0:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 90915b4:	00004806 	br	90916d8 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 90915b8:	e0bff917 	ldw	r2,-28(fp)
 90915bc:	10c0020b 	ldhu	r3,8(r2)
 90915c0:	e0bff817 	ldw	r2,-32(fp)
 90915c4:	1080040b 	ldhu	r2,16(r2)
 90915c8:	1884703a 	and	r2,r3,r2
 90915cc:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 90915d0:	e0bff68b 	ldhu	r2,-38(fp)
 90915d4:	1005003a 	cmpeq	r2,r2,zero
 90915d8:	10003f1e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 90915dc:	e17ff68b 	ldhu	r5,-38(fp)
 90915e0:	e13ff817 	ldw	r4,-32(fp)
 90915e4:	9091af00 	call	9091af0 <OS_FlagTaskRdy>
 90915e8:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 90915ec:	e0bff603 	ldbu	r2,-40(fp)
 90915f0:	10800058 	cmpnei	r2,r2,1
 90915f4:	1000381e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 90915f8:	00800044 	movi	r2,1
 90915fc:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 9091600:	00003506 	br	90916d8 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9091604:	e0bff917 	ldw	r2,-28(fp)
 9091608:	1080020b 	ldhu	r2,8(r2)
 909160c:	0084303a 	nor	r2,zero,r2
 9091610:	1007883a 	mov	r3,r2
 9091614:	e0bff817 	ldw	r2,-32(fp)
 9091618:	1080040b 	ldhu	r2,16(r2)
 909161c:	1884703a 	and	r2,r3,r2
 9091620:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 9091624:	e0bff817 	ldw	r2,-32(fp)
 9091628:	1080040b 	ldhu	r2,16(r2)
 909162c:	10ffffcc 	andi	r3,r2,65535
 9091630:	e0bff68b 	ldhu	r2,-38(fp)
 9091634:	1880281e 	bne	r3,r2,90916d8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 9091638:	e17ff68b 	ldhu	r5,-38(fp)
 909163c:	e13ff817 	ldw	r4,-32(fp)
 9091640:	9091af00 	call	9091af0 <OS_FlagTaskRdy>
 9091644:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 9091648:	e0bff603 	ldbu	r2,-40(fp)
 909164c:	10800058 	cmpnei	r2,r2,1
 9091650:	1000211e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 9091654:	00800044 	movi	r2,1
 9091658:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 909165c:	00001e06 	br	90916d8 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 9091660:	e0bff917 	ldw	r2,-28(fp)
 9091664:	1080020b 	ldhu	r2,8(r2)
 9091668:	0084303a 	nor	r2,zero,r2
 909166c:	1007883a 	mov	r3,r2
 9091670:	e0bff817 	ldw	r2,-32(fp)
 9091674:	1080040b 	ldhu	r2,16(r2)
 9091678:	1884703a 	and	r2,r3,r2
 909167c:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 9091680:	e0bff68b 	ldhu	r2,-38(fp)
 9091684:	1005003a 	cmpeq	r2,r2,zero
 9091688:	1000131e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 909168c:	e17ff68b 	ldhu	r5,-38(fp)
 9091690:	e13ff817 	ldw	r4,-32(fp)
 9091694:	9091af00 	call	9091af0 <OS_FlagTaskRdy>
 9091698:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 909169c:	e0bff603 	ldbu	r2,-40(fp)
 90916a0:	10800058 	cmpnei	r2,r2,1
 90916a4:	10000c1e 	bne	r2,zero,90916d8 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 90916a8:	00800044 	movi	r2,1
 90916ac:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 90916b0:	00000906 	br	90916d8 <OSFlagPost+0x30c>
 90916b4:	e0bff517 	ldw	r2,-44(fp)
 90916b8:	e0bff215 	stw	r2,-56(fp)
 90916bc:	e0bff217 	ldw	r2,-56(fp)
 90916c0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 90916c4:	e0fffc17 	ldw	r3,-16(fp)
 90916c8:	00801bc4 	movi	r2,111
 90916cc:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 90916d0:	e03fff15 	stw	zero,-4(fp)
 90916d4:	00002106 	br	909175c <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 90916d8:	e0bff817 	ldw	r2,-32(fp)
 90916dc:	10800017 	ldw	r2,0(r2)
 90916e0:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 90916e4:	e0bff817 	ldw	r2,-32(fp)
 90916e8:	1004c03a 	cmpne	r2,r2,zero
 90916ec:	103f881e 	bne	r2,zero,9091510 <OSFlagPost+0x144>
 90916f0:	e0bff517 	ldw	r2,-44(fp)
 90916f4:	e0bff115 	stw	r2,-60(fp)
 90916f8:	e0bff117 	ldw	r2,-60(fp)
 90916fc:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 9091700:	e0bff783 	ldbu	r2,-34(fp)
 9091704:	10800058 	cmpnei	r2,r2,1
 9091708:	1000011e 	bne	r2,zero,9091710 <OSFlagPost+0x344>
        OS_Sched();
 909170c:	908fae40 	call	908fae4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091710:	0005303a 	rdctl	r2,status
 9091714:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091718:	e0fff017 	ldw	r3,-64(fp)
 909171c:	00bfff84 	movi	r2,-2
 9091720:	1884703a 	and	r2,r3,r2
 9091724:	1001703a 	wrctl	status,r2
  
  return context;
 9091728:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 909172c:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 9091730:	e0bff917 	ldw	r2,-28(fp)
 9091734:	1080020b 	ldhu	r2,8(r2)
 9091738:	e0bff70d 	sth	r2,-36(fp)
 909173c:	e0bff517 	ldw	r2,-44(fp)
 9091740:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091744:	e0bfef17 	ldw	r2,-68(fp)
 9091748:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 909174c:	e0bffc17 	ldw	r2,-16(fp)
 9091750:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 9091754:	e0bff70b 	ldhu	r2,-36(fp)
 9091758:	e0bfff15 	stw	r2,-4(fp)
 909175c:	e0bfff17 	ldw	r2,-4(fp)
}
 9091760:	e037883a 	mov	sp,fp
 9091764:	dfc00117 	ldw	ra,4(sp)
 9091768:	df000017 	ldw	fp,0(sp)
 909176c:	dec00204 	addi	sp,sp,8
 9091770:	f800283a 	ret

09091774 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 9091774:	defff804 	addi	sp,sp,-32
 9091778:	df000715 	stw	fp,28(sp)
 909177c:	df000704 	addi	fp,sp,28
 9091780:	e13ffd15 	stw	r4,-12(fp)
 9091784:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 9091788:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 909178c:	e0bffe17 	ldw	r2,-8(fp)
 9091790:	1004c03a 	cmpne	r2,r2,zero
 9091794:	1000021e 	bne	r2,zero,90917a0 <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 9091798:	e03fff15 	stw	zero,-4(fp)
 909179c:	00002506 	br	9091834 <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 90917a0:	e0bffd17 	ldw	r2,-12(fp)
 90917a4:	1004c03a 	cmpne	r2,r2,zero
 90917a8:	1000051e 	bne	r2,zero,90917c0 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 90917ac:	e0fffe17 	ldw	r3,-8(fp)
 90917b0:	00801b84 	movi	r2,110
 90917b4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90917b8:	e03fff15 	stw	zero,-4(fp)
 90917bc:	00001d06 	br	9091834 <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 90917c0:	e0bffd17 	ldw	r2,-12(fp)
 90917c4:	10800003 	ldbu	r2,0(r2)
 90917c8:	10803fcc 	andi	r2,r2,255
 90917cc:	10800160 	cmpeqi	r2,r2,5
 90917d0:	1000051e 	bne	r2,zero,90917e8 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 90917d4:	e0fffe17 	ldw	r3,-8(fp)
 90917d8:	00800044 	movi	r2,1
 90917dc:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 90917e0:	e03fff15 	stw	zero,-4(fp)
 90917e4:	00001306 	br	9091834 <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90917e8:	0005303a 	rdctl	r2,status
 90917ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90917f0:	e0fffa17 	ldw	r3,-24(fp)
 90917f4:	00bfff84 	movi	r2,-2
 90917f8:	1884703a 	and	r2,r3,r2
 90917fc:	1001703a 	wrctl	status,r2
  
  return context;
 9091800:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9091804:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 9091808:	e0bffd17 	ldw	r2,-12(fp)
 909180c:	1080020b 	ldhu	r2,8(r2)
 9091810:	e0bffc0d 	sth	r2,-16(fp)
 9091814:	e0bffb17 	ldw	r2,-20(fp)
 9091818:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909181c:	e0bff917 	ldw	r2,-28(fp)
 9091820:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9091824:	e0bffe17 	ldw	r2,-8(fp)
 9091828:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 909182c:	e0bffc0b 	ldhu	r2,-16(fp)
 9091830:	e0bfff15 	stw	r2,-4(fp)
 9091834:	e0bfff17 	ldw	r2,-4(fp)
}
 9091838:	e037883a 	mov	sp,fp
 909183c:	df000017 	ldw	fp,0(sp)
 9091840:	dec00104 	addi	sp,sp,4
 9091844:	f800283a 	ret

09091848 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 9091848:	defff804 	addi	sp,sp,-32
 909184c:	df000715 	stw	fp,28(sp)
 9091850:	df000704 	addi	fp,sp,28
 9091854:	e13ffb15 	stw	r4,-20(fp)
 9091858:	e17ffc15 	stw	r5,-16(fp)
 909185c:	e0800117 	ldw	r2,4(fp)
 9091860:	e1bffd0d 	sth	r6,-12(fp)
 9091864:	e1fffe05 	stb	r7,-8(fp)
 9091868:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 909186c:	00824374 	movhi	r2,2317
 9091870:	108f0004 	addi	r2,r2,15360
 9091874:	10c00017 	ldw	r3,0(r2)
 9091878:	00824374 	movhi	r2,2317
 909187c:	108f0004 	addi	r2,r2,15360
 9091880:	10800017 	ldw	r2,0(r2)
 9091884:	10800c03 	ldbu	r2,48(r2)
 9091888:	10800814 	ori	r2,r2,32
 909188c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 9091890:	00824374 	movhi	r2,2317
 9091894:	108f0004 	addi	r2,r2,15360
 9091898:	10800017 	ldw	r2,0(r2)
 909189c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 90918a0:	00824374 	movhi	r2,2317
 90918a4:	108f0004 	addi	r2,r2,15360
 90918a8:	10c00017 	ldw	r3,0(r2)
 90918ac:	e0bfff0b 	ldhu	r2,-4(fp)
 90918b0:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 90918b4:	00824374 	movhi	r2,2317
 90918b8:	108f0004 	addi	r2,r2,15360
 90918bc:	10c00017 	ldw	r3,0(r2)
 90918c0:	e0bffc17 	ldw	r2,-16(fp)
 90918c4:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 90918c8:	e0fffc17 	ldw	r3,-16(fp)
 90918cc:	e0bffd0b 	ldhu	r2,-12(fp)
 90918d0:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 90918d4:	e0fffc17 	ldw	r3,-16(fp)
 90918d8:	e0bffe03 	ldbu	r2,-8(fp)
 90918dc:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 90918e0:	00824374 	movhi	r2,2317
 90918e4:	108f0004 	addi	r2,r2,15360
 90918e8:	10c00017 	ldw	r3,0(r2)
 90918ec:	e0bffc17 	ldw	r2,-16(fp)
 90918f0:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 90918f4:	e0bffb17 	ldw	r2,-20(fp)
 90918f8:	10c00117 	ldw	r3,4(r2)
 90918fc:	e0bffc17 	ldw	r2,-16(fp)
 9091900:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 9091904:	e0bffc17 	ldw	r2,-16(fp)
 9091908:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 909190c:	e0fffc17 	ldw	r3,-16(fp)
 9091910:	e0bffb17 	ldw	r2,-20(fp)
 9091914:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 9091918:	e0bffb17 	ldw	r2,-20(fp)
 909191c:	10800117 	ldw	r2,4(r2)
 9091920:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 9091924:	e0bffa17 	ldw	r2,-24(fp)
 9091928:	1005003a 	cmpeq	r2,r2,zero
 909192c:	1000031e 	bne	r2,zero,909193c <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 9091930:	e0fffa17 	ldw	r3,-24(fp)
 9091934:	e0bffc17 	ldw	r2,-16(fp)
 9091938:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 909193c:	e0fffb17 	ldw	r3,-20(fp)
 9091940:	e0bffc17 	ldw	r2,-16(fp)
 9091944:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 9091948:	00824374 	movhi	r2,2317
 909194c:	108f0004 	addi	r2,r2,15360
 9091950:	10800017 	ldw	r2,0(r2)
 9091954:	10800d03 	ldbu	r2,52(r2)
 9091958:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 909195c:	e13ff903 	ldbu	r4,-28(fp)
 9091960:	e0fff903 	ldbu	r3,-28(fp)
 9091964:	00824374 	movhi	r2,2317
 9091968:	108efd44 	addi	r2,r2,15349
 909196c:	10c5883a 	add	r2,r2,r3
 9091970:	10800003 	ldbu	r2,0(r2)
 9091974:	1007883a 	mov	r3,r2
 9091978:	00824374 	movhi	r2,2317
 909197c:	108f0004 	addi	r2,r2,15360
 9091980:	10800017 	ldw	r2,0(r2)
 9091984:	10800d43 	ldbu	r2,53(r2)
 9091988:	0084303a 	nor	r2,zero,r2
 909198c:	1884703a 	and	r2,r3,r2
 9091990:	1007883a 	mov	r3,r2
 9091994:	00824374 	movhi	r2,2317
 9091998:	108efd44 	addi	r2,r2,15349
 909199c:	1105883a 	add	r2,r2,r4
 90919a0:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 90919a4:	e0fff903 	ldbu	r3,-28(fp)
 90919a8:	00824374 	movhi	r2,2317
 90919ac:	108efd44 	addi	r2,r2,15349
 90919b0:	10c5883a 	add	r2,r2,r3
 90919b4:	10800003 	ldbu	r2,0(r2)
 90919b8:	10803fcc 	andi	r2,r2,255
 90919bc:	1004c03a 	cmpne	r2,r2,zero
 90919c0:	10000e1e 	bne	r2,zero,90919fc <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 90919c4:	00824374 	movhi	r2,2317
 90919c8:	108f0004 	addi	r2,r2,15360
 90919cc:	10800017 	ldw	r2,0(r2)
 90919d0:	10800d83 	ldbu	r2,54(r2)
 90919d4:	0084303a 	nor	r2,zero,r2
 90919d8:	1007883a 	mov	r3,r2
 90919dc:	00824374 	movhi	r2,2317
 90919e0:	108efd04 	addi	r2,r2,15348
 90919e4:	10800003 	ldbu	r2,0(r2)
 90919e8:	1884703a 	and	r2,r3,r2
 90919ec:	1007883a 	mov	r3,r2
 90919f0:	00824374 	movhi	r2,2317
 90919f4:	108efd04 	addi	r2,r2,15348
 90919f8:	10c00005 	stb	r3,0(r2)
    }
}
 90919fc:	e037883a 	mov	sp,fp
 9091a00:	df000017 	ldw	fp,0(sp)
 9091a04:	dec00104 	addi	sp,sp,4
 9091a08:	f800283a 	ret

09091a0c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 9091a0c:	defffb04 	addi	sp,sp,-20
 9091a10:	dfc00415 	stw	ra,16(sp)
 9091a14:	df000315 	stw	fp,12(sp)
 9091a18:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 9091a1c:	010243b4 	movhi	r4,2318
 9091a20:	21280004 	addi	r4,r4,-24576
 9091a24:	0140dc04 	movi	r5,880
 9091a28:	908fa240 	call	908fa24 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 9091a2c:	008243b4 	movhi	r2,2318
 9091a30:	10a80004 	addi	r2,r2,-24576
 9091a34:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 9091a38:	008243b4 	movhi	r2,2318
 9091a3c:	10a80b04 	addi	r2,r2,-24532
 9091a40:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 9091a44:	e03fff0d 	sth	zero,-4(fp)
 9091a48:	00001306 	br	9091a98 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 9091a4c:	e0bffe17 	ldw	r2,-8(fp)
 9091a50:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 9091a54:	e0fffe17 	ldw	r3,-8(fp)
 9091a58:	e0bffd17 	ldw	r2,-12(fp)
 9091a5c:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 9091a60:	e0fffe17 	ldw	r3,-8(fp)
 9091a64:	00800fc4 	movi	r2,63
 9091a68:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 9091a6c:	e0bffe17 	ldw	r2,-8(fp)
 9091a70:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 9091a74:	e0bffe17 	ldw	r2,-8(fp)
 9091a78:	10800b04 	addi	r2,r2,44
 9091a7c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 9091a80:	e0bffd17 	ldw	r2,-12(fp)
 9091a84:	10800b04 	addi	r2,r2,44
 9091a88:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 9091a8c:	e0bfff0b 	ldhu	r2,-4(fp)
 9091a90:	10800044 	addi	r2,r2,1
 9091a94:	e0bfff0d 	sth	r2,-4(fp)
 9091a98:	e0bfff0b 	ldhu	r2,-4(fp)
 9091a9c:	108004f0 	cmpltui	r2,r2,19
 9091aa0:	103fea1e 	bne	r2,zero,9091a4c <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 9091aa4:	e0bffe17 	ldw	r2,-8(fp)
 9091aa8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 9091aac:	e0bffe17 	ldw	r2,-8(fp)
 9091ab0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 9091ab4:	e0fffe17 	ldw	r3,-8(fp)
 9091ab8:	00800fc4 	movi	r2,63
 9091abc:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 9091ac0:	e0bffe17 	ldw	r2,-8(fp)
 9091ac4:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 9091ac8:	00c24374 	movhi	r3,2317
 9091acc:	18cf0204 	addi	r3,r3,15368
 9091ad0:	008243b4 	movhi	r2,2318
 9091ad4:	10a80004 	addi	r2,r2,-24576
 9091ad8:	18800015 	stw	r2,0(r3)
#endif
}
 9091adc:	e037883a 	mov	sp,fp
 9091ae0:	dfc00117 	ldw	ra,4(sp)
 9091ae4:	df000017 	ldw	fp,0(sp)
 9091ae8:	dec00204 	addi	sp,sp,8
 9091aec:	f800283a 	ret

09091af0 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 9091af0:	defffa04 	addi	sp,sp,-24
 9091af4:	dfc00515 	stw	ra,20(sp)
 9091af8:	df000415 	stw	fp,16(sp)
 9091afc:	df000404 	addi	fp,sp,16
 9091b00:	e13ffe15 	stw	r4,-8(fp)
 9091b04:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 9091b08:	e0bffe17 	ldw	r2,-8(fp)
 9091b0c:	10800217 	ldw	r2,8(r2)
 9091b10:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 9091b14:	e0bffd17 	ldw	r2,-12(fp)
 9091b18:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 9091b1c:	e0fffd17 	ldw	r3,-12(fp)
 9091b20:	e0bfff0b 	ldhu	r2,-4(fp)
 9091b24:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 9091b28:	e0bffd17 	ldw	r2,-12(fp)
 9091b2c:	10c00c03 	ldbu	r3,48(r2)
 9091b30:	00bff7c4 	movi	r2,-33
 9091b34:	1884703a 	and	r2,r3,r2
 9091b38:	1007883a 	mov	r3,r2
 9091b3c:	e0bffd17 	ldw	r2,-12(fp)
 9091b40:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 9091b44:	e0bffd17 	ldw	r2,-12(fp)
 9091b48:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 9091b4c:	e0bffd17 	ldw	r2,-12(fp)
 9091b50:	10800c03 	ldbu	r2,48(r2)
 9091b54:	10803fcc 	andi	r2,r2,255
 9091b58:	1004c03a 	cmpne	r2,r2,zero
 9091b5c:	10001f1e 	bne	r2,zero,9091bdc <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 9091b60:	e0bffd17 	ldw	r2,-12(fp)
 9091b64:	10c00d83 	ldbu	r3,54(r2)
 9091b68:	00824374 	movhi	r2,2317
 9091b6c:	108efd04 	addi	r2,r2,15348
 9091b70:	10800003 	ldbu	r2,0(r2)
 9091b74:	1884b03a 	or	r2,r3,r2
 9091b78:	1007883a 	mov	r3,r2
 9091b7c:	00824374 	movhi	r2,2317
 9091b80:	108efd04 	addi	r2,r2,15348
 9091b84:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9091b88:	e0bffd17 	ldw	r2,-12(fp)
 9091b8c:	10800d03 	ldbu	r2,52(r2)
 9091b90:	11003fcc 	andi	r4,r2,255
 9091b94:	e0bffd17 	ldw	r2,-12(fp)
 9091b98:	10800d03 	ldbu	r2,52(r2)
 9091b9c:	10c03fcc 	andi	r3,r2,255
 9091ba0:	00824374 	movhi	r2,2317
 9091ba4:	108efd44 	addi	r2,r2,15349
 9091ba8:	10c5883a 	add	r2,r2,r3
 9091bac:	10c00003 	ldbu	r3,0(r2)
 9091bb0:	e0bffd17 	ldw	r2,-12(fp)
 9091bb4:	10800d43 	ldbu	r2,53(r2)
 9091bb8:	1884b03a 	or	r2,r3,r2
 9091bbc:	1007883a 	mov	r3,r2
 9091bc0:	00824374 	movhi	r2,2317
 9091bc4:	108efd44 	addi	r2,r2,15349
 9091bc8:	1105883a 	add	r2,r2,r4
 9091bcc:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 9091bd0:	00800044 	movi	r2,1
 9091bd4:	e0bffc05 	stb	r2,-16(fp)
 9091bd8:	00000106 	br	9091be0 <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 9091bdc:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 9091be0:	e13ffe17 	ldw	r4,-8(fp)
 9091be4:	9091c000 	call	9091c00 <OS_FlagUnlink>
    return (sched);
 9091be8:	e0bffc03 	ldbu	r2,-16(fp)
}
 9091bec:	e037883a 	mov	sp,fp
 9091bf0:	dfc00117 	ldw	ra,4(sp)
 9091bf4:	df000017 	ldw	fp,0(sp)
 9091bf8:	dec00204 	addi	sp,sp,8
 9091bfc:	f800283a 	ret

09091c00 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 9091c00:	defffa04 	addi	sp,sp,-24
 9091c04:	df000515 	stw	fp,20(sp)
 9091c08:	df000504 	addi	fp,sp,20
 9091c0c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 9091c10:	e0bfff17 	ldw	r2,-4(fp)
 9091c14:	10800117 	ldw	r2,4(r2)
 9091c18:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 9091c1c:	e0bfff17 	ldw	r2,-4(fp)
 9091c20:	10800017 	ldw	r2,0(r2)
 9091c24:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 9091c28:	e0bffc17 	ldw	r2,-16(fp)
 9091c2c:	1004c03a 	cmpne	r2,r2,zero
 9091c30:	10000c1e 	bne	r2,zero,9091c64 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 9091c34:	e0bfff17 	ldw	r2,-4(fp)
 9091c38:	10800317 	ldw	r2,12(r2)
 9091c3c:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 9091c40:	e0fffd17 	ldw	r3,-12(fp)
 9091c44:	e0bffb17 	ldw	r2,-20(fp)
 9091c48:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 9091c4c:	e0bffb17 	ldw	r2,-20(fp)
 9091c50:	1005003a 	cmpeq	r2,r2,zero
 9091c54:	10000c1e 	bne	r2,zero,9091c88 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 9091c58:	e0bffb17 	ldw	r2,-20(fp)
 9091c5c:	10000115 	stw	zero,4(r2)
 9091c60:	00000906 	br	9091c88 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 9091c64:	e0fffc17 	ldw	r3,-16(fp)
 9091c68:	e0bffb17 	ldw	r2,-20(fp)
 9091c6c:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 9091c70:	e0bffb17 	ldw	r2,-20(fp)
 9091c74:	1005003a 	cmpeq	r2,r2,zero
 9091c78:	1000031e 	bne	r2,zero,9091c88 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 9091c7c:	e0fffb17 	ldw	r3,-20(fp)
 9091c80:	e0bffc17 	ldw	r2,-16(fp)
 9091c84:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 9091c88:	e0bfff17 	ldw	r2,-4(fp)
 9091c8c:	10800217 	ldw	r2,8(r2)
 9091c90:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 9091c94:	e0bffe17 	ldw	r2,-8(fp)
 9091c98:	10000a15 	stw	zero,40(r2)
#endif
}
 9091c9c:	e037883a 	mov	sp,fp
 9091ca0:	df000017 	ldw	fp,0(sp)
 9091ca4:	dec00104 	addi	sp,sp,4
 9091ca8:	f800283a 	ret

09091cac <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 9091cac:	defff304 	addi	sp,sp,-52
 9091cb0:	df000c15 	stw	fp,48(sp)
 9091cb4:	df000c04 	addi	fp,sp,48
 9091cb8:	e13ffb15 	stw	r4,-20(fp)
 9091cbc:	e17ffc15 	stw	r5,-16(fp)
 9091cc0:	e1bffd15 	stw	r6,-12(fp)
 9091cc4:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9091cc8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9091ccc:	e0bffe17 	ldw	r2,-8(fp)
 9091cd0:	1004c03a 	cmpne	r2,r2,zero
 9091cd4:	1000021e 	bne	r2,zero,9091ce0 <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 9091cd8:	e03fff15 	stw	zero,-4(fp)
 9091cdc:	00007506 	br	9091eb4 <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 9091ce0:	e0bffb17 	ldw	r2,-20(fp)
 9091ce4:	1004c03a 	cmpne	r2,r2,zero
 9091ce8:	1000051e 	bne	r2,zero,9091d00 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 9091cec:	e0fffe17 	ldw	r3,-8(fp)
 9091cf0:	00801884 	movi	r2,98
 9091cf4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9091cf8:	e03fff15 	stw	zero,-4(fp)
 9091cfc:	00006d06 	br	9091eb4 <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 9091d00:	e0bffb17 	ldw	r2,-20(fp)
 9091d04:	108000cc 	andi	r2,r2,3
 9091d08:	1005003a 	cmpeq	r2,r2,zero
 9091d0c:	1000051e 	bne	r2,zero,9091d24 <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 9091d10:	e0fffe17 	ldw	r3,-8(fp)
 9091d14:	00801884 	movi	r2,98
 9091d18:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9091d1c:	e03fff15 	stw	zero,-4(fp)
 9091d20:	00006406 	br	9091eb4 <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 9091d24:	e0bffc17 	ldw	r2,-16(fp)
 9091d28:	108000a8 	cmpgeui	r2,r2,2
 9091d2c:	1000051e 	bne	r2,zero,9091d44 <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 9091d30:	e0fffe17 	ldw	r3,-8(fp)
 9091d34:	008016c4 	movi	r2,91
 9091d38:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9091d3c:	e03fff15 	stw	zero,-4(fp)
 9091d40:	00005c06 	br	9091eb4 <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 9091d44:	e0bffd17 	ldw	r2,-12(fp)
 9091d48:	10800128 	cmpgeui	r2,r2,4
 9091d4c:	1000051e 	bne	r2,zero,9091d64 <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 9091d50:	e0fffe17 	ldw	r3,-8(fp)
 9091d54:	00801704 	movi	r2,92
 9091d58:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9091d5c:	e03fff15 	stw	zero,-4(fp)
 9091d60:	00005406 	br	9091eb4 <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091d64:	0005303a 	rdctl	r2,status
 9091d68:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091d6c:	e0fff517 	ldw	r3,-44(fp)
 9091d70:	00bfff84 	movi	r2,-2
 9091d74:	1884703a 	and	r2,r3,r2
 9091d78:	1001703a 	wrctl	status,r2
  
  return context;
 9091d7c:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9091d80:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 9091d84:	00824374 	movhi	r2,2317
 9091d88:	108efa04 	addi	r2,r2,15336
 9091d8c:	10800017 	ldw	r2,0(r2)
 9091d90:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 9091d94:	00824374 	movhi	r2,2317
 9091d98:	108efa04 	addi	r2,r2,15336
 9091d9c:	10800017 	ldw	r2,0(r2)
 9091da0:	1005003a 	cmpeq	r2,r2,zero
 9091da4:	1000081e 	bne	r2,zero,9091dc8 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 9091da8:	00824374 	movhi	r2,2317
 9091dac:	108efa04 	addi	r2,r2,15336
 9091db0:	10800017 	ldw	r2,0(r2)
 9091db4:	10800117 	ldw	r2,4(r2)
 9091db8:	1007883a 	mov	r3,r2
 9091dbc:	00824374 	movhi	r2,2317
 9091dc0:	108efa04 	addi	r2,r2,15336
 9091dc4:	10c00015 	stw	r3,0(r2)
 9091dc8:	e0bff617 	ldw	r2,-40(fp)
 9091dcc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091dd0:	e0bff417 	ldw	r2,-48(fp)
 9091dd4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 9091dd8:	e0bffa17 	ldw	r2,-24(fp)
 9091ddc:	1004c03a 	cmpne	r2,r2,zero
 9091de0:	1000051e 	bne	r2,zero,9091df8 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 9091de4:	e0fffe17 	ldw	r3,-8(fp)
 9091de8:	00801684 	movi	r2,90
 9091dec:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 9091df0:	e03fff15 	stw	zero,-4(fp)
 9091df4:	00002f06 	br	9091eb4 <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 9091df8:	e0bffb17 	ldw	r2,-20(fp)
 9091dfc:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 9091e00:	e0bffb17 	ldw	r2,-20(fp)
 9091e04:	1007883a 	mov	r3,r2
 9091e08:	e0bffd17 	ldw	r2,-12(fp)
 9091e0c:	1885883a 	add	r2,r3,r2
 9091e10:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 9091e14:	e03ff715 	stw	zero,-36(fp)
 9091e18:	00000d06 	br	9091e50 <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 9091e1c:	e0fff817 	ldw	r3,-32(fp)
 9091e20:	e0bff917 	ldw	r2,-28(fp)
 9091e24:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 9091e28:	e0bff917 	ldw	r2,-28(fp)
 9091e2c:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 9091e30:	e0bff917 	ldw	r2,-28(fp)
 9091e34:	1007883a 	mov	r3,r2
 9091e38:	e0bffd17 	ldw	r2,-12(fp)
 9091e3c:	1885883a 	add	r2,r3,r2
 9091e40:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 9091e44:	e0bff717 	ldw	r2,-36(fp)
 9091e48:	10800044 	addi	r2,r2,1
 9091e4c:	e0bff715 	stw	r2,-36(fp)
 9091e50:	e0bffc17 	ldw	r2,-16(fp)
 9091e54:	10ffffc4 	addi	r3,r2,-1
 9091e58:	e0bff717 	ldw	r2,-36(fp)
 9091e5c:	10ffef36 	bltu	r2,r3,9091e1c <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 9091e60:	e0bff817 	ldw	r2,-32(fp)
 9091e64:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 9091e68:	e0fffa17 	ldw	r3,-24(fp)
 9091e6c:	e0bffb17 	ldw	r2,-20(fp)
 9091e70:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 9091e74:	e0fffa17 	ldw	r3,-24(fp)
 9091e78:	e0bffb17 	ldw	r2,-20(fp)
 9091e7c:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 9091e80:	e0fffa17 	ldw	r3,-24(fp)
 9091e84:	e0bffc17 	ldw	r2,-16(fp)
 9091e88:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 9091e8c:	e0fffa17 	ldw	r3,-24(fp)
 9091e90:	e0bffc17 	ldw	r2,-16(fp)
 9091e94:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 9091e98:	e0fffa17 	ldw	r3,-24(fp)
 9091e9c:	e0bffd17 	ldw	r2,-12(fp)
 9091ea0:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 9091ea4:	e0bffe17 	ldw	r2,-8(fp)
 9091ea8:	10000005 	stb	zero,0(r2)
    return (pmem);
 9091eac:	e0bffa17 	ldw	r2,-24(fp)
 9091eb0:	e0bfff15 	stw	r2,-4(fp)
 9091eb4:	e0bfff17 	ldw	r2,-4(fp)
}
 9091eb8:	e037883a 	mov	sp,fp
 9091ebc:	df000017 	ldw	fp,0(sp)
 9091ec0:	dec00104 	addi	sp,sp,4
 9091ec4:	f800283a 	ret

09091ec8 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 9091ec8:	defff704 	addi	sp,sp,-36
 9091ecc:	df000815 	stw	fp,32(sp)
 9091ed0:	df000804 	addi	fp,sp,32
 9091ed4:	e13ffd15 	stw	r4,-12(fp)
 9091ed8:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9091edc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9091ee0:	e0bffe17 	ldw	r2,-8(fp)
 9091ee4:	1004c03a 	cmpne	r2,r2,zero
 9091ee8:	1000021e 	bne	r2,zero,9091ef4 <OSMemGet+0x2c>
        return ((void *)0);
 9091eec:	e03fff15 	stw	zero,-4(fp)
 9091ef0:	00003106 	br	9091fb8 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 9091ef4:	e0bffd17 	ldw	r2,-12(fp)
 9091ef8:	1004c03a 	cmpne	r2,r2,zero
 9091efc:	1000051e 	bne	r2,zero,9091f14 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 9091f00:	e0fffe17 	ldw	r3,-8(fp)
 9091f04:	00801804 	movi	r2,96
 9091f08:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9091f0c:	e03fff15 	stw	zero,-4(fp)
 9091f10:	00002906 	br	9091fb8 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9091f14:	0005303a 	rdctl	r2,status
 9091f18:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9091f1c:	e0fffa17 	ldw	r3,-24(fp)
 9091f20:	00bfff84 	movi	r2,-2
 9091f24:	1884703a 	and	r2,r3,r2
 9091f28:	1001703a 	wrctl	status,r2
  
  return context;
 9091f2c:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9091f30:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 9091f34:	e0bffd17 	ldw	r2,-12(fp)
 9091f38:	10800417 	ldw	r2,16(r2)
 9091f3c:	1005003a 	cmpeq	r2,r2,zero
 9091f40:	1000151e 	bne	r2,zero,9091f98 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 9091f44:	e0bffd17 	ldw	r2,-12(fp)
 9091f48:	10800117 	ldw	r2,4(r2)
 9091f4c:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 9091f50:	e0bffc17 	ldw	r2,-16(fp)
 9091f54:	10c00017 	ldw	r3,0(r2)
 9091f58:	e0bffd17 	ldw	r2,-12(fp)
 9091f5c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 9091f60:	e0bffd17 	ldw	r2,-12(fp)
 9091f64:	10800417 	ldw	r2,16(r2)
 9091f68:	10ffffc4 	addi	r3,r2,-1
 9091f6c:	e0bffd17 	ldw	r2,-12(fp)
 9091f70:	10c00415 	stw	r3,16(r2)
 9091f74:	e0bffb17 	ldw	r2,-20(fp)
 9091f78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9091f7c:	e0bff917 	ldw	r2,-28(fp)
 9091f80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 9091f84:	e0bffe17 	ldw	r2,-8(fp)
 9091f88:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 9091f8c:	e0bffc17 	ldw	r2,-16(fp)
 9091f90:	e0bfff15 	stw	r2,-4(fp)
 9091f94:	00000806 	br	9091fb8 <OSMemGet+0xf0>
 9091f98:	e0bffb17 	ldw	r2,-20(fp)
 9091f9c:	e0bff815 	stw	r2,-32(fp)
 9091fa0:	e0bff817 	ldw	r2,-32(fp)
 9091fa4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 9091fa8:	e0fffe17 	ldw	r3,-8(fp)
 9091fac:	00801744 	movi	r2,93
 9091fb0:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 9091fb4:	e03fff15 	stw	zero,-4(fp)
 9091fb8:	e0bfff17 	ldw	r2,-4(fp)
}
 9091fbc:	e037883a 	mov	sp,fp
 9091fc0:	df000017 	ldw	fp,0(sp)
 9091fc4:	dec00104 	addi	sp,sp,4
 9091fc8:	f800283a 	ret

09091fcc <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 9091fcc:	defff604 	addi	sp,sp,-40
 9091fd0:	dfc00915 	stw	ra,36(sp)
 9091fd4:	df000815 	stw	fp,32(sp)
 9091fd8:	df000804 	addi	fp,sp,32
 9091fdc:	e13ffc15 	stw	r4,-16(fp)
 9091fe0:	e17ffd15 	stw	r5,-12(fp)
 9091fe4:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9091fe8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9091fec:	e0bffe17 	ldw	r2,-8(fp)
 9091ff0:	1004c03a 	cmpne	r2,r2,zero
 9091ff4:	1000021e 	bne	r2,zero,9092000 <OSMemNameGet+0x34>
        return (0);
 9091ff8:	e03fff15 	stw	zero,-4(fp)
 9091ffc:	00003006 	br	90920c0 <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 9092000:	e0bffc17 	ldw	r2,-16(fp)
 9092004:	1004c03a 	cmpne	r2,r2,zero
 9092008:	1000051e 	bne	r2,zero,9092020 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 909200c:	e0fffe17 	ldw	r3,-8(fp)
 9092010:	00801804 	movi	r2,96
 9092014:	18800005 	stb	r2,0(r3)
        return (0);
 9092018:	e03fff15 	stw	zero,-4(fp)
 909201c:	00002806 	br	90920c0 <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9092020:	e0bffd17 	ldw	r2,-12(fp)
 9092024:	1004c03a 	cmpne	r2,r2,zero
 9092028:	1000051e 	bne	r2,zero,9092040 <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 909202c:	e0fffe17 	ldw	r3,-8(fp)
 9092030:	00800304 	movi	r2,12
 9092034:	18800005 	stb	r2,0(r3)
        return (0);
 9092038:	e03fff15 	stw	zero,-4(fp)
 909203c:	00002006 	br	90920c0 <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9092040:	00824374 	movhi	r2,2317
 9092044:	108eff04 	addi	r2,r2,15356
 9092048:	10800003 	ldbu	r2,0(r2)
 909204c:	10803fcc 	andi	r2,r2,255
 9092050:	1005003a 	cmpeq	r2,r2,zero
 9092054:	1000051e 	bne	r2,zero,909206c <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 9092058:	e0fffe17 	ldw	r3,-8(fp)
 909205c:	00800444 	movi	r2,17
 9092060:	18800005 	stb	r2,0(r3)
        return (0);
 9092064:	e03fff15 	stw	zero,-4(fp)
 9092068:	00001506 	br	90920c0 <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909206c:	0005303a 	rdctl	r2,status
 9092070:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092074:	e0fff917 	ldw	r3,-28(fp)
 9092078:	00bfff84 	movi	r2,-2
 909207c:	1884703a 	and	r2,r3,r2
 9092080:	1001703a 	wrctl	status,r2
  
  return context;
 9092084:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9092088:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 909208c:	e0bffc17 	ldw	r2,-16(fp)
 9092090:	11400504 	addi	r5,r2,20
 9092094:	e13ffd17 	ldw	r4,-12(fp)
 9092098:	908fc280 	call	908fc28 <OS_StrCopy>
 909209c:	e0bffb05 	stb	r2,-20(fp)
 90920a0:	e0bffa17 	ldw	r2,-24(fp)
 90920a4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90920a8:	e0bff817 	ldw	r2,-32(fp)
 90920ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90920b0:	e0bffe17 	ldw	r2,-8(fp)
 90920b4:	10000005 	stb	zero,0(r2)
    return (len);
 90920b8:	e0bffb03 	ldbu	r2,-20(fp)
 90920bc:	e0bfff15 	stw	r2,-4(fp)
 90920c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90920c4:	e037883a 	mov	sp,fp
 90920c8:	dfc00117 	ldw	ra,4(sp)
 90920cc:	df000017 	ldw	fp,0(sp)
 90920d0:	dec00204 	addi	sp,sp,8
 90920d4:	f800283a 	ret

090920d8 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 90920d8:	defff604 	addi	sp,sp,-40
 90920dc:	dfc00915 	stw	ra,36(sp)
 90920e0:	df000815 	stw	fp,32(sp)
 90920e4:	df000804 	addi	fp,sp,32
 90920e8:	e13ffd15 	stw	r4,-12(fp)
 90920ec:	e17ffe15 	stw	r5,-8(fp)
 90920f0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 90920f4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 90920f8:	e0bfff17 	ldw	r2,-4(fp)
 90920fc:	1005003a 	cmpeq	r2,r2,zero
 9092100:	1000381e 	bne	r2,zero,90921e4 <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 9092104:	e0bffd17 	ldw	r2,-12(fp)
 9092108:	1004c03a 	cmpne	r2,r2,zero
 909210c:	1000041e 	bne	r2,zero,9092120 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 9092110:	e0ffff17 	ldw	r3,-4(fp)
 9092114:	00801804 	movi	r2,96
 9092118:	18800005 	stb	r2,0(r3)
        return;
 909211c:	00003106 	br	90921e4 <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 9092120:	e0bffe17 	ldw	r2,-8(fp)
 9092124:	1004c03a 	cmpne	r2,r2,zero
 9092128:	1000041e 	bne	r2,zero,909213c <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 909212c:	e0ffff17 	ldw	r3,-4(fp)
 9092130:	00800304 	movi	r2,12
 9092134:	18800005 	stb	r2,0(r3)
        return;
 9092138:	00002a06 	br	90921e4 <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 909213c:	00824374 	movhi	r2,2317
 9092140:	108eff04 	addi	r2,r2,15356
 9092144:	10800003 	ldbu	r2,0(r2)
 9092148:	10803fcc 	andi	r2,r2,255
 909214c:	1005003a 	cmpeq	r2,r2,zero
 9092150:	1000041e 	bne	r2,zero,9092164 <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 9092154:	e0ffff17 	ldw	r3,-4(fp)
 9092158:	00800484 	movi	r2,18
 909215c:	18800005 	stb	r2,0(r3)
        return;
 9092160:	00002006 	br	90921e4 <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092164:	0005303a 	rdctl	r2,status
 9092168:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909216c:	e0fffa17 	ldw	r3,-24(fp)
 9092170:	00bfff84 	movi	r2,-2
 9092174:	1884703a 	and	r2,r3,r2
 9092178:	1001703a 	wrctl	status,r2
  
  return context;
 909217c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9092180:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 9092184:	e13ffe17 	ldw	r4,-8(fp)
 9092188:	908fca80 	call	908fca8 <OS_StrLen>
 909218c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 9092190:	e0bffc03 	ldbu	r2,-16(fp)
 9092194:	10800830 	cmpltui	r2,r2,32
 9092198:	1000081e 	bne	r2,zero,90921bc <OSMemNameSet+0xe4>
 909219c:	e0bffb17 	ldw	r2,-20(fp)
 90921a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90921a4:	e0bff917 	ldw	r2,-28(fp)
 90921a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 90921ac:	e0ffff17 	ldw	r3,-4(fp)
 90921b0:	008018c4 	movi	r2,99
 90921b4:	18800005 	stb	r2,0(r3)
        return;
 90921b8:	00000a06 	br	90921e4 <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 90921bc:	e0bffd17 	ldw	r2,-12(fp)
 90921c0:	11000504 	addi	r4,r2,20
 90921c4:	e17ffe17 	ldw	r5,-8(fp)
 90921c8:	908fc280 	call	908fc28 <OS_StrCopy>
 90921cc:	e0bffb17 	ldw	r2,-20(fp)
 90921d0:	e0bff815 	stw	r2,-32(fp)
 90921d4:	e0bff817 	ldw	r2,-32(fp)
 90921d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90921dc:	e0bfff17 	ldw	r2,-4(fp)
 90921e0:	10000005 	stb	zero,0(r2)
}
 90921e4:	e037883a 	mov	sp,fp
 90921e8:	dfc00117 	ldw	ra,4(sp)
 90921ec:	df000017 	ldw	fp,0(sp)
 90921f0:	dec00204 	addi	sp,sp,8
 90921f4:	f800283a 	ret

090921f8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 90921f8:	defff804 	addi	sp,sp,-32
 90921fc:	df000715 	stw	fp,28(sp)
 9092200:	df000704 	addi	fp,sp,28
 9092204:	e13ffd15 	stw	r4,-12(fp)
 9092208:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 909220c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 9092210:	e0bffd17 	ldw	r2,-12(fp)
 9092214:	1004c03a 	cmpne	r2,r2,zero
 9092218:	1000031e 	bne	r2,zero,9092228 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 909221c:	00801804 	movi	r2,96
 9092220:	e0bfff15 	stw	r2,-4(fp)
 9092224:	00002b06 	br	90922d4 <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 9092228:	e0bffe17 	ldw	r2,-8(fp)
 909222c:	1004c03a 	cmpne	r2,r2,zero
 9092230:	1000031e 	bne	r2,zero,9092240 <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 9092234:	008017c4 	movi	r2,95
 9092238:	e0bfff15 	stw	r2,-4(fp)
 909223c:	00002506 	br	90922d4 <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092240:	0005303a 	rdctl	r2,status
 9092244:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092248:	e0fffb17 	ldw	r3,-20(fp)
 909224c:	00bfff84 	movi	r2,-2
 9092250:	1884703a 	and	r2,r3,r2
 9092254:	1001703a 	wrctl	status,r2
  
  return context;
 9092258:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909225c:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 9092260:	e0bffd17 	ldw	r2,-12(fp)
 9092264:	10c00417 	ldw	r3,16(r2)
 9092268:	e0bffd17 	ldw	r2,-12(fp)
 909226c:	10800317 	ldw	r2,12(r2)
 9092270:	18800736 	bltu	r3,r2,9092290 <OSMemPut+0x98>
 9092274:	e0bffc17 	ldw	r2,-16(fp)
 9092278:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909227c:	e0bffa17 	ldw	r2,-24(fp)
 9092280:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 9092284:	00801784 	movi	r2,94
 9092288:	e0bfff15 	stw	r2,-4(fp)
 909228c:	00001106 	br	90922d4 <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 9092290:	e0fffe17 	ldw	r3,-8(fp)
 9092294:	e0bffd17 	ldw	r2,-12(fp)
 9092298:	10800117 	ldw	r2,4(r2)
 909229c:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 90922a0:	e0fffd17 	ldw	r3,-12(fp)
 90922a4:	e0bffe17 	ldw	r2,-8(fp)
 90922a8:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 90922ac:	e0bffd17 	ldw	r2,-12(fp)
 90922b0:	10800417 	ldw	r2,16(r2)
 90922b4:	10c00044 	addi	r3,r2,1
 90922b8:	e0bffd17 	ldw	r2,-12(fp)
 90922bc:	10c00415 	stw	r3,16(r2)
 90922c0:	e0bffc17 	ldw	r2,-16(fp)
 90922c4:	e0bff915 	stw	r2,-28(fp)
 90922c8:	e0bff917 	ldw	r2,-28(fp)
 90922cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 90922d0:	e03fff15 	stw	zero,-4(fp)
 90922d4:	e0bfff17 	ldw	r2,-4(fp)
}
 90922d8:	e037883a 	mov	sp,fp
 90922dc:	df000017 	ldw	fp,0(sp)
 90922e0:	dec00104 	addi	sp,sp,4
 90922e4:	f800283a 	ret

090922e8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 90922e8:	defff904 	addi	sp,sp,-28
 90922ec:	df000615 	stw	fp,24(sp)
 90922f0:	df000604 	addi	fp,sp,24
 90922f4:	e13ffd15 	stw	r4,-12(fp)
 90922f8:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 90922fc:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 9092300:	e0bffd17 	ldw	r2,-12(fp)
 9092304:	1004c03a 	cmpne	r2,r2,zero
 9092308:	1000031e 	bne	r2,zero,9092318 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 909230c:	00801804 	movi	r2,96
 9092310:	e0bfff15 	stw	r2,-4(fp)
 9092314:	00002e06 	br	90923d0 <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 9092318:	e0bffe17 	ldw	r2,-8(fp)
 909231c:	1004c03a 	cmpne	r2,r2,zero
 9092320:	1000031e 	bne	r2,zero,9092330 <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 9092324:	00801844 	movi	r2,97
 9092328:	e0bfff15 	stw	r2,-4(fp)
 909232c:	00002806 	br	90923d0 <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092330:	0005303a 	rdctl	r2,status
 9092334:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092338:	e0fffb17 	ldw	r3,-20(fp)
 909233c:	00bfff84 	movi	r2,-2
 9092340:	1884703a 	and	r2,r3,r2
 9092344:	1001703a 	wrctl	status,r2
  
  return context;
 9092348:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909234c:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 9092350:	e0bffd17 	ldw	r2,-12(fp)
 9092354:	10c00017 	ldw	r3,0(r2)
 9092358:	e0bffe17 	ldw	r2,-8(fp)
 909235c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 9092360:	e0bffd17 	ldw	r2,-12(fp)
 9092364:	10c00117 	ldw	r3,4(r2)
 9092368:	e0bffe17 	ldw	r2,-8(fp)
 909236c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 9092370:	e0bffd17 	ldw	r2,-12(fp)
 9092374:	10c00217 	ldw	r3,8(r2)
 9092378:	e0bffe17 	ldw	r2,-8(fp)
 909237c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 9092380:	e0bffd17 	ldw	r2,-12(fp)
 9092384:	10c00317 	ldw	r3,12(r2)
 9092388:	e0bffe17 	ldw	r2,-8(fp)
 909238c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 9092390:	e0bffd17 	ldw	r2,-12(fp)
 9092394:	10c00417 	ldw	r3,16(r2)
 9092398:	e0bffe17 	ldw	r2,-8(fp)
 909239c:	10c00415 	stw	r3,16(r2)
 90923a0:	e0bffc17 	ldw	r2,-16(fp)
 90923a4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90923a8:	e0bffa17 	ldw	r2,-24(fp)
 90923ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 90923b0:	e0bffe17 	ldw	r2,-8(fp)
 90923b4:	10c00317 	ldw	r3,12(r2)
 90923b8:	e0bffe17 	ldw	r2,-8(fp)
 90923bc:	10800417 	ldw	r2,16(r2)
 90923c0:	1887c83a 	sub	r3,r3,r2
 90923c4:	e0bffe17 	ldw	r2,-8(fp)
 90923c8:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 90923cc:	e03fff15 	stw	zero,-4(fp)
 90923d0:	e0bfff17 	ldw	r2,-4(fp)
}
 90923d4:	e037883a 	mov	sp,fp
 90923d8:	df000017 	ldw	fp,0(sp)
 90923dc:	dec00104 	addi	sp,sp,4
 90923e0:	f800283a 	ret

090923e4 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 90923e4:	defffc04 	addi	sp,sp,-16
 90923e8:	dfc00315 	stw	ra,12(sp)
 90923ec:	df000215 	stw	fp,8(sp)
 90923f0:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 90923f4:	010243b4 	movhi	r4,2318
 90923f8:	2128dc04 	addi	r4,r4,-23696
 90923fc:	01430c04 	movi	r5,3120
 9092400:	908fa240 	call	908fa24 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 9092404:	008243b4 	movhi	r2,2318
 9092408:	10a8dc04 	addi	r2,r2,-23696
 909240c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 9092410:	e03ffe0d 	sth	zero,-8(fp)
 9092414:	00001306 	br	9092464 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 9092418:	e0bffe0b 	ldhu	r2,-8(fp)
 909241c:	10800d24 	muli	r2,r2,52
 9092420:	1007883a 	mov	r3,r2
 9092424:	008243b4 	movhi	r2,2318
 9092428:	10a8e904 	addi	r2,r2,-23644
 909242c:	1887883a 	add	r3,r3,r2
 9092430:	e0bfff17 	ldw	r2,-4(fp)
 9092434:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 9092438:	e0ffff17 	ldw	r3,-4(fp)
 909243c:	00800fc4 	movi	r2,63
 9092440:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 9092444:	e0bfff17 	ldw	r2,-4(fp)
 9092448:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 909244c:	e0bfff17 	ldw	r2,-4(fp)
 9092450:	10800d04 	addi	r2,r2,52
 9092454:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 9092458:	e0bffe0b 	ldhu	r2,-8(fp)
 909245c:	10800044 	addi	r2,r2,1
 9092460:	e0bffe0d 	sth	r2,-8(fp)
 9092464:	e0bffe0b 	ldhu	r2,-8(fp)
 9092468:	10800ef0 	cmpltui	r2,r2,59
 909246c:	103fea1e 	bne	r2,zero,9092418 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 9092470:	e0bfff17 	ldw	r2,-4(fp)
 9092474:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 9092478:	e0ffff17 	ldw	r3,-4(fp)
 909247c:	00800fc4 	movi	r2,63
 9092480:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 9092484:	e0bfff17 	ldw	r2,-4(fp)
 9092488:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 909248c:	00c24374 	movhi	r3,2317
 9092490:	18cefa04 	addi	r3,r3,15336
 9092494:	008243b4 	movhi	r2,2318
 9092498:	10a8dc04 	addi	r2,r2,-23696
 909249c:	18800015 	stw	r2,0(r3)
#endif
}
 90924a0:	e037883a 	mov	sp,fp
 90924a4:	dfc00117 	ldw	ra,4(sp)
 90924a8:	df000017 	ldw	fp,0(sp)
 90924ac:	dec00204 	addi	sp,sp,8
 90924b0:	f800283a 	ret

090924b4 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 90924b4:	defff704 	addi	sp,sp,-36
 90924b8:	df000815 	stw	fp,32(sp)
 90924bc:	df000804 	addi	fp,sp,32
 90924c0:	e13ffd15 	stw	r4,-12(fp)
 90924c4:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 90924c8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 90924cc:	e0bffe17 	ldw	r2,-8(fp)
 90924d0:	1004c03a 	cmpne	r2,r2,zero
 90924d4:	1000021e 	bne	r2,zero,90924e0 <OSQAccept+0x2c>
        return ((void *)0);
 90924d8:	e03fff15 	stw	zero,-4(fp)
 90924dc:	00004506 	br	90925f4 <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 90924e0:	e0bffd17 	ldw	r2,-12(fp)
 90924e4:	1004c03a 	cmpne	r2,r2,zero
 90924e8:	1000051e 	bne	r2,zero,9092500 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 90924ec:	e0fffe17 	ldw	r3,-8(fp)
 90924f0:	00800104 	movi	r2,4
 90924f4:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 90924f8:	e03fff15 	stw	zero,-4(fp)
 90924fc:	00003d06 	br	90925f4 <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 9092500:	e0bffd17 	ldw	r2,-12(fp)
 9092504:	10800003 	ldbu	r2,0(r2)
 9092508:	10803fcc 	andi	r2,r2,255
 909250c:	108000a0 	cmpeqi	r2,r2,2
 9092510:	1000051e 	bne	r2,zero,9092528 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 9092514:	e0fffe17 	ldw	r3,-8(fp)
 9092518:	00800044 	movi	r2,1
 909251c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9092520:	e03fff15 	stw	zero,-4(fp)
 9092524:	00003306 	br	90925f4 <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092528:	0005303a 	rdctl	r2,status
 909252c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092530:	e0fff917 	ldw	r3,-28(fp)
 9092534:	00bfff84 	movi	r2,-2
 9092538:	1884703a 	and	r2,r3,r2
 909253c:	1001703a 	wrctl	status,r2
  
  return context;
 9092540:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9092544:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 9092548:	e0bffd17 	ldw	r2,-12(fp)
 909254c:	10800117 	ldw	r2,4(r2)
 9092550:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 9092554:	e0bffb17 	ldw	r2,-20(fp)
 9092558:	1080058b 	ldhu	r2,22(r2)
 909255c:	10bfffcc 	andi	r2,r2,65535
 9092560:	1005003a 	cmpeq	r2,r2,zero
 9092564:	1000191e 	bne	r2,zero,90925cc <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 9092568:	e0bffb17 	ldw	r2,-20(fp)
 909256c:	10c00417 	ldw	r3,16(r2)
 9092570:	18800017 	ldw	r2,0(r3)
 9092574:	e0bffc15 	stw	r2,-16(fp)
 9092578:	18c00104 	addi	r3,r3,4
 909257c:	e0bffb17 	ldw	r2,-20(fp)
 9092580:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 9092584:	e0bffb17 	ldw	r2,-20(fp)
 9092588:	1080058b 	ldhu	r2,22(r2)
 909258c:	10bfffc4 	addi	r2,r2,-1
 9092590:	1007883a 	mov	r3,r2
 9092594:	e0bffb17 	ldw	r2,-20(fp)
 9092598:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 909259c:	e0bffb17 	ldw	r2,-20(fp)
 90925a0:	10c00417 	ldw	r3,16(r2)
 90925a4:	e0bffb17 	ldw	r2,-20(fp)
 90925a8:	10800217 	ldw	r2,8(r2)
 90925ac:	1880041e 	bne	r3,r2,90925c0 <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 90925b0:	e0bffb17 	ldw	r2,-20(fp)
 90925b4:	10c00117 	ldw	r3,4(r2)
 90925b8:	e0bffb17 	ldw	r2,-20(fp)
 90925bc:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 90925c0:	e0bffe17 	ldw	r2,-8(fp)
 90925c4:	10000005 	stb	zero,0(r2)
 90925c8:	00000406 	br	90925dc <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 90925cc:	e0fffe17 	ldw	r3,-8(fp)
 90925d0:	008007c4 	movi	r2,31
 90925d4:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 90925d8:	e03ffc15 	stw	zero,-16(fp)
 90925dc:	e0bffa17 	ldw	r2,-24(fp)
 90925e0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90925e4:	e0bff817 	ldw	r2,-32(fp)
 90925e8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 90925ec:	e0bffc17 	ldw	r2,-16(fp)
 90925f0:	e0bfff15 	stw	r2,-4(fp)
 90925f4:	e0bfff17 	ldw	r2,-4(fp)
}
 90925f8:	e037883a 	mov	sp,fp
 90925fc:	df000017 	ldw	fp,0(sp)
 9092600:	dec00104 	addi	sp,sp,4
 9092604:	f800283a 	ret

09092608 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 9092608:	defff304 	addi	sp,sp,-52
 909260c:	dfc00c15 	stw	ra,48(sp)
 9092610:	df000b15 	stw	fp,44(sp)
 9092614:	df000b04 	addi	fp,sp,44
 9092618:	e13ffd15 	stw	r4,-12(fp)
 909261c:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9092620:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 9092624:	00824374 	movhi	r2,2317
 9092628:	108eff04 	addi	r2,r2,15356
 909262c:	10800003 	ldbu	r2,0(r2)
 9092630:	10803fcc 	andi	r2,r2,255
 9092634:	1005003a 	cmpeq	r2,r2,zero
 9092638:	1000021e 	bne	r2,zero,9092644 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 909263c:	e03fff15 	stw	zero,-4(fp)
 9092640:	00007006 	br	9092804 <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092644:	0005303a 	rdctl	r2,status
 9092648:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909264c:	e0fff917 	ldw	r3,-28(fp)
 9092650:	00bfff84 	movi	r2,-2
 9092654:	1884703a 	and	r2,r3,r2
 9092658:	1001703a 	wrctl	status,r2
  
  return context;
 909265c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9092660:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 9092664:	00824374 	movhi	r2,2317
 9092668:	108efe04 	addi	r2,r2,15352
 909266c:	10800017 	ldw	r2,0(r2)
 9092670:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 9092674:	00824374 	movhi	r2,2317
 9092678:	108efe04 	addi	r2,r2,15352
 909267c:	10800017 	ldw	r2,0(r2)
 9092680:	1005003a 	cmpeq	r2,r2,zero
 9092684:	1000081e 	bne	r2,zero,90926a8 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 9092688:	00824374 	movhi	r2,2317
 909268c:	108efe04 	addi	r2,r2,15352
 9092690:	10800017 	ldw	r2,0(r2)
 9092694:	10800117 	ldw	r2,4(r2)
 9092698:	1007883a 	mov	r3,r2
 909269c:	00824374 	movhi	r2,2317
 90926a0:	108efe04 	addi	r2,r2,15352
 90926a4:	10c00015 	stw	r3,0(r2)
 90926a8:	e0bffa17 	ldw	r2,-24(fp)
 90926ac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90926b0:	e0bff817 	ldw	r2,-32(fp)
 90926b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 90926b8:	e0bffc17 	ldw	r2,-16(fp)
 90926bc:	1005003a 	cmpeq	r2,r2,zero
 90926c0:	10004e1e 	bne	r2,zero,90927fc <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90926c4:	0005303a 	rdctl	r2,status
 90926c8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90926cc:	e0fff717 	ldw	r3,-36(fp)
 90926d0:	00bfff84 	movi	r2,-2
 90926d4:	1884703a 	and	r2,r3,r2
 90926d8:	1001703a 	wrctl	status,r2
  
  return context;
 90926dc:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 90926e0:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 90926e4:	00824374 	movhi	r2,2317
 90926e8:	108efc04 	addi	r2,r2,15344
 90926ec:	10800017 	ldw	r2,0(r2)
 90926f0:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 90926f4:	e0bffb17 	ldw	r2,-20(fp)
 90926f8:	1005003a 	cmpeq	r2,r2,zero
 90926fc:	1000311e 	bne	r2,zero,90927c4 <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 9092700:	00824374 	movhi	r2,2317
 9092704:	108efc04 	addi	r2,r2,15344
 9092708:	10800017 	ldw	r2,0(r2)
 909270c:	10c00017 	ldw	r3,0(r2)
 9092710:	00824374 	movhi	r2,2317
 9092714:	108efc04 	addi	r2,r2,15344
 9092718:	10c00015 	stw	r3,0(r2)
 909271c:	e0bffa17 	ldw	r2,-24(fp)
 9092720:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092724:	e0bff617 	ldw	r2,-40(fp)
 9092728:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 909272c:	e0fffb17 	ldw	r3,-20(fp)
 9092730:	e0bffd17 	ldw	r2,-12(fp)
 9092734:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 9092738:	e0bffe0b 	ldhu	r2,-8(fp)
 909273c:	1085883a 	add	r2,r2,r2
 9092740:	1085883a 	add	r2,r2,r2
 9092744:	1007883a 	mov	r3,r2
 9092748:	e0bffd17 	ldw	r2,-12(fp)
 909274c:	1887883a 	add	r3,r3,r2
 9092750:	e0bffb17 	ldw	r2,-20(fp)
 9092754:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 9092758:	e0fffb17 	ldw	r3,-20(fp)
 909275c:	e0bffd17 	ldw	r2,-12(fp)
 9092760:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 9092764:	e0fffb17 	ldw	r3,-20(fp)
 9092768:	e0bffd17 	ldw	r2,-12(fp)
 909276c:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 9092770:	e0fffb17 	ldw	r3,-20(fp)
 9092774:	e0bffe0b 	ldhu	r2,-8(fp)
 9092778:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 909277c:	e0bffb17 	ldw	r2,-20(fp)
 9092780:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 9092784:	e0fffc17 	ldw	r3,-16(fp)
 9092788:	00800084 	movi	r2,2
 909278c:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 9092790:	e0bffc17 	ldw	r2,-16(fp)
 9092794:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 9092798:	e0fffc17 	ldw	r3,-16(fp)
 909279c:	e0bffb17 	ldw	r2,-20(fp)
 90927a0:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 90927a4:	e0fffc17 	ldw	r3,-16(fp)
 90927a8:	00800fc4 	movi	r2,63
 90927ac:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 90927b0:	e0bffc17 	ldw	r2,-16(fp)
 90927b4:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 90927b8:	e13ffc17 	ldw	r4,-16(fp)
 90927bc:	908f6580 	call	908f658 <OS_EventWaitListInit>
 90927c0:	00000e06 	br	90927fc <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 90927c4:	00824374 	movhi	r2,2317
 90927c8:	108efe04 	addi	r2,r2,15352
 90927cc:	10c00017 	ldw	r3,0(r2)
 90927d0:	e0bffc17 	ldw	r2,-16(fp)
 90927d4:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 90927d8:	00c24374 	movhi	r3,2317
 90927dc:	18cefe04 	addi	r3,r3,15352
 90927e0:	e0bffc17 	ldw	r2,-16(fp)
 90927e4:	18800015 	stw	r2,0(r3)
 90927e8:	e0bffa17 	ldw	r2,-24(fp)
 90927ec:	e0bff515 	stw	r2,-44(fp)
 90927f0:	e0bff517 	ldw	r2,-44(fp)
 90927f4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 90927f8:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 90927fc:	e0bffc17 	ldw	r2,-16(fp)
 9092800:	e0bfff15 	stw	r2,-4(fp)
 9092804:	e0bfff17 	ldw	r2,-4(fp)
}
 9092808:	e037883a 	mov	sp,fp
 909280c:	dfc00117 	ldw	ra,4(sp)
 9092810:	df000017 	ldw	fp,0(sp)
 9092814:	dec00204 	addi	sp,sp,8
 9092818:	f800283a 	ret

0909281c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 909281c:	defff004 	addi	sp,sp,-64
 9092820:	dfc00f15 	stw	ra,60(sp)
 9092824:	df000e15 	stw	fp,56(sp)
 9092828:	df000e04 	addi	fp,sp,56
 909282c:	e13ffb15 	stw	r4,-20(fp)
 9092830:	e1bffd15 	stw	r6,-12(fp)
 9092834:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 9092838:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 909283c:	e0bffd17 	ldw	r2,-12(fp)
 9092840:	1004c03a 	cmpne	r2,r2,zero
 9092844:	1000031e 	bne	r2,zero,9092854 <OSQDel+0x38>
        return (pevent);
 9092848:	e0bffb17 	ldw	r2,-20(fp)
 909284c:	e0bfff15 	stw	r2,-4(fp)
 9092850:	0000ac06 	br	9092b04 <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9092854:	e0bffb17 	ldw	r2,-20(fp)
 9092858:	1004c03a 	cmpne	r2,r2,zero
 909285c:	1000061e 	bne	r2,zero,9092878 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 9092860:	e0fffd17 	ldw	r3,-12(fp)
 9092864:	00800104 	movi	r2,4
 9092868:	18800005 	stb	r2,0(r3)
        return (pevent);
 909286c:	e0fffb17 	ldw	r3,-20(fp)
 9092870:	e0ffff15 	stw	r3,-4(fp)
 9092874:	0000a306 	br	9092b04 <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 9092878:	e0bffb17 	ldw	r2,-20(fp)
 909287c:	10800003 	ldbu	r2,0(r2)
 9092880:	10803fcc 	andi	r2,r2,255
 9092884:	108000a0 	cmpeqi	r2,r2,2
 9092888:	1000061e 	bne	r2,zero,90928a4 <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 909288c:	e0fffd17 	ldw	r3,-12(fp)
 9092890:	00800044 	movi	r2,1
 9092894:	18800005 	stb	r2,0(r3)
        return (pevent);
 9092898:	e0bffb17 	ldw	r2,-20(fp)
 909289c:	e0bfff15 	stw	r2,-4(fp)
 90928a0:	00009806 	br	9092b04 <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 90928a4:	00824374 	movhi	r2,2317
 90928a8:	108eff04 	addi	r2,r2,15356
 90928ac:	10800003 	ldbu	r2,0(r2)
 90928b0:	10803fcc 	andi	r2,r2,255
 90928b4:	1005003a 	cmpeq	r2,r2,zero
 90928b8:	1000061e 	bne	r2,zero,90928d4 <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 90928bc:	e0fffd17 	ldw	r3,-12(fp)
 90928c0:	008003c4 	movi	r2,15
 90928c4:	18800005 	stb	r2,0(r3)
        return (pevent);
 90928c8:	e0fffb17 	ldw	r3,-20(fp)
 90928cc:	e0ffff15 	stw	r3,-4(fp)
 90928d0:	00008c06 	br	9092b04 <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90928d4:	0005303a 	rdctl	r2,status
 90928d8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90928dc:	e0fff617 	ldw	r3,-40(fp)
 90928e0:	00bfff84 	movi	r2,-2
 90928e4:	1884703a 	and	r2,r3,r2
 90928e8:	1001703a 	wrctl	status,r2
  
  return context;
 90928ec:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 90928f0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 90928f4:	e0bffb17 	ldw	r2,-20(fp)
 90928f8:	10800283 	ldbu	r2,10(r2)
 90928fc:	10803fcc 	andi	r2,r2,255
 9092900:	1005003a 	cmpeq	r2,r2,zero
 9092904:	1000031e 	bne	r2,zero,9092914 <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 9092908:	00800044 	movi	r2,1
 909290c:	e0bffa05 	stb	r2,-24(fp)
 9092910:	00000106 	br	9092918 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 9092914:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 9092918:	e0bffc03 	ldbu	r2,-16(fp)
 909291c:	e0bffe15 	stw	r2,-8(fp)
 9092920:	e0fffe17 	ldw	r3,-8(fp)
 9092924:	1805003a 	cmpeq	r2,r3,zero
 9092928:	1000041e 	bne	r2,zero,909293c <OSQDel+0x120>
 909292c:	e0fffe17 	ldw	r3,-8(fp)
 9092930:	18800060 	cmpeqi	r2,r3,1
 9092934:	1000391e 	bne	r2,zero,9092a1c <OSQDel+0x200>
 9092938:	00006706 	br	9092ad8 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 909293c:	e0bffa03 	ldbu	r2,-24(fp)
 9092940:	1004c03a 	cmpne	r2,r2,zero
 9092944:	1000261e 	bne	r2,zero,90929e0 <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 9092948:	e0fffb17 	ldw	r3,-20(fp)
 909294c:	00800fc4 	movi	r2,63
 9092950:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 9092954:	e0bffb17 	ldw	r2,-20(fp)
 9092958:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 909295c:	e0bffb17 	ldw	r2,-20(fp)
 9092960:	10800117 	ldw	r2,4(r2)
 9092964:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 9092968:	00824374 	movhi	r2,2317
 909296c:	108efc04 	addi	r2,r2,15344
 9092970:	10c00017 	ldw	r3,0(r2)
 9092974:	e0bff817 	ldw	r2,-32(fp)
 9092978:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 909297c:	00c24374 	movhi	r3,2317
 9092980:	18cefc04 	addi	r3,r3,15344
 9092984:	e0bff817 	ldw	r2,-32(fp)
 9092988:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 909298c:	e0bffb17 	ldw	r2,-20(fp)
 9092990:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 9092994:	00824374 	movhi	r2,2317
 9092998:	108efe04 	addi	r2,r2,15352
 909299c:	10c00017 	ldw	r3,0(r2)
 90929a0:	e0bffb17 	ldw	r2,-20(fp)
 90929a4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 90929a8:	e0bffb17 	ldw	r2,-20(fp)
 90929ac:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 90929b0:	00c24374 	movhi	r3,2317
 90929b4:	18cefe04 	addi	r3,r3,15352
 90929b8:	e0bffb17 	ldw	r2,-20(fp)
 90929bc:	18800015 	stw	r2,0(r3)
 90929c0:	e0bff717 	ldw	r2,-36(fp)
 90929c4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90929c8:	e0bff517 	ldw	r2,-44(fp)
 90929cc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 90929d0:	e0bffd17 	ldw	r2,-12(fp)
 90929d4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 90929d8:	e03ff915 	stw	zero,-28(fp)
 90929dc:	00004706 	br	9092afc <OSQDel+0x2e0>
 90929e0:	e0bff717 	ldw	r2,-36(fp)
 90929e4:	e0bff415 	stw	r2,-48(fp)
 90929e8:	e0bff417 	ldw	r2,-48(fp)
 90929ec:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 90929f0:	e0fffd17 	ldw	r3,-12(fp)
 90929f4:	00801244 	movi	r2,73
 90929f8:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 90929fc:	e0bffb17 	ldw	r2,-20(fp)
 9092a00:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 9092a04:	00003d06 	br	9092afc <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 9092a08:	e13ffb17 	ldw	r4,-20(fp)
 9092a0c:	000b883a 	mov	r5,zero
 9092a10:	01800104 	movi	r6,4
 9092a14:	000f883a 	mov	r7,zero
 9092a18:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 9092a1c:	e0bffb17 	ldw	r2,-20(fp)
 9092a20:	10800283 	ldbu	r2,10(r2)
 9092a24:	10803fcc 	andi	r2,r2,255
 9092a28:	1004c03a 	cmpne	r2,r2,zero
 9092a2c:	103ff61e 	bne	r2,zero,9092a08 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 9092a30:	e0fffb17 	ldw	r3,-20(fp)
 9092a34:	00800fc4 	movi	r2,63
 9092a38:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 9092a3c:	e0bffb17 	ldw	r2,-20(fp)
 9092a40:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 9092a44:	e0bffb17 	ldw	r2,-20(fp)
 9092a48:	10800117 	ldw	r2,4(r2)
 9092a4c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 9092a50:	00824374 	movhi	r2,2317
 9092a54:	108efc04 	addi	r2,r2,15344
 9092a58:	10c00017 	ldw	r3,0(r2)
 9092a5c:	e0bff817 	ldw	r2,-32(fp)
 9092a60:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 9092a64:	00c24374 	movhi	r3,2317
 9092a68:	18cefc04 	addi	r3,r3,15344
 9092a6c:	e0bff817 	ldw	r2,-32(fp)
 9092a70:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9092a74:	e0bffb17 	ldw	r2,-20(fp)
 9092a78:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 9092a7c:	00824374 	movhi	r2,2317
 9092a80:	108efe04 	addi	r2,r2,15352
 9092a84:	10c00017 	ldw	r3,0(r2)
 9092a88:	e0bffb17 	ldw	r2,-20(fp)
 9092a8c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 9092a90:	e0bffb17 	ldw	r2,-20(fp)
 9092a94:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 9092a98:	00c24374 	movhi	r3,2317
 9092a9c:	18cefe04 	addi	r3,r3,15352
 9092aa0:	e0bffb17 	ldw	r2,-20(fp)
 9092aa4:	18800015 	stw	r2,0(r3)
 9092aa8:	e0bff717 	ldw	r2,-36(fp)
 9092aac:	e0bff315 	stw	r2,-52(fp)
 9092ab0:	e0bff317 	ldw	r2,-52(fp)
 9092ab4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 9092ab8:	e0bffa03 	ldbu	r2,-24(fp)
 9092abc:	10800058 	cmpnei	r2,r2,1
 9092ac0:	1000011e 	bne	r2,zero,9092ac8 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 9092ac4:	908fae40 	call	908fae4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 9092ac8:	e0bffd17 	ldw	r2,-12(fp)
 9092acc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 9092ad0:	e03ff915 	stw	zero,-28(fp)
             break;
 9092ad4:	00000906 	br	9092afc <OSQDel+0x2e0>
 9092ad8:	e0bff717 	ldw	r2,-36(fp)
 9092adc:	e0bff215 	stw	r2,-56(fp)
 9092ae0:	e0bff217 	ldw	r2,-56(fp)
 9092ae4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 9092ae8:	e0fffd17 	ldw	r3,-12(fp)
 9092aec:	008001c4 	movi	r2,7
 9092af0:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 9092af4:	e0bffb17 	ldw	r2,-20(fp)
 9092af8:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 9092afc:	e0bff917 	ldw	r2,-28(fp)
 9092b00:	e0bfff15 	stw	r2,-4(fp)
 9092b04:	e0bfff17 	ldw	r2,-4(fp)
}
 9092b08:	e037883a 	mov	sp,fp
 9092b0c:	dfc00117 	ldw	ra,4(sp)
 9092b10:	df000017 	ldw	fp,0(sp)
 9092b14:	dec00204 	addi	sp,sp,8
 9092b18:	f800283a 	ret

09092b1c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 9092b1c:	defff904 	addi	sp,sp,-28
 9092b20:	df000615 	stw	fp,24(sp)
 9092b24:	df000604 	addi	fp,sp,24
 9092b28:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9092b2c:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9092b30:	e0bffe17 	ldw	r2,-8(fp)
 9092b34:	1004c03a 	cmpne	r2,r2,zero
 9092b38:	1000031e 	bne	r2,zero,9092b48 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 9092b3c:	00800104 	movi	r2,4
 9092b40:	e0bfff15 	stw	r2,-4(fp)
 9092b44:	00002206 	br	9092bd0 <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 9092b48:	e0bffe17 	ldw	r2,-8(fp)
 9092b4c:	10800003 	ldbu	r2,0(r2)
 9092b50:	10803fcc 	andi	r2,r2,255
 9092b54:	108000a0 	cmpeqi	r2,r2,2
 9092b58:	1000031e 	bne	r2,zero,9092b68 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 9092b5c:	00800044 	movi	r2,1
 9092b60:	e0bfff15 	stw	r2,-4(fp)
 9092b64:	00001a06 	br	9092bd0 <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092b68:	0005303a 	rdctl	r2,status
 9092b6c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092b70:	e0fffb17 	ldw	r3,-20(fp)
 9092b74:	00bfff84 	movi	r2,-2
 9092b78:	1884703a 	and	r2,r3,r2
 9092b7c:	1001703a 	wrctl	status,r2
  
  return context;
 9092b80:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9092b84:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 9092b88:	e0bffe17 	ldw	r2,-8(fp)
 9092b8c:	10800117 	ldw	r2,4(r2)
 9092b90:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 9092b94:	e0bffd17 	ldw	r2,-12(fp)
 9092b98:	10c00117 	ldw	r3,4(r2)
 9092b9c:	e0bffd17 	ldw	r2,-12(fp)
 9092ba0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 9092ba4:	e0bffd17 	ldw	r2,-12(fp)
 9092ba8:	10c00117 	ldw	r3,4(r2)
 9092bac:	e0bffd17 	ldw	r2,-12(fp)
 9092bb0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 9092bb4:	e0bffd17 	ldw	r2,-12(fp)
 9092bb8:	1000058d 	sth	zero,22(r2)
 9092bbc:	e0bffc17 	ldw	r2,-16(fp)
 9092bc0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092bc4:	e0bffa17 	ldw	r2,-24(fp)
 9092bc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9092bcc:	e03fff15 	stw	zero,-4(fp)
 9092bd0:	e0bfff17 	ldw	r2,-4(fp)
}
 9092bd4:	e037883a 	mov	sp,fp
 9092bd8:	df000017 	ldw	fp,0(sp)
 9092bdc:	dec00104 	addi	sp,sp,4
 9092be0:	f800283a 	ret

09092be4 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 9092be4:	defff104 	addi	sp,sp,-60
 9092be8:	dfc00e15 	stw	ra,56(sp)
 9092bec:	df000d15 	stw	fp,52(sp)
 9092bf0:	df000d04 	addi	fp,sp,52
 9092bf4:	e13ffb15 	stw	r4,-20(fp)
 9092bf8:	e1bffd15 	stw	r6,-12(fp)
 9092bfc:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9092c00:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 9092c04:	e0bffd17 	ldw	r2,-12(fp)
 9092c08:	1004c03a 	cmpne	r2,r2,zero
 9092c0c:	1000021e 	bne	r2,zero,9092c18 <OSQPend+0x34>
        return ((void *)0);
 9092c10:	e03fff15 	stw	zero,-4(fp)
 9092c14:	0000b506 	br	9092eec <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 9092c18:	e0bffb17 	ldw	r2,-20(fp)
 9092c1c:	1004c03a 	cmpne	r2,r2,zero
 9092c20:	1000051e 	bne	r2,zero,9092c38 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9092c24:	e0fffd17 	ldw	r3,-12(fp)
 9092c28:	00800104 	movi	r2,4
 9092c2c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9092c30:	e03fff15 	stw	zero,-4(fp)
 9092c34:	0000ad06 	br	9092eec <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 9092c38:	e0bffb17 	ldw	r2,-20(fp)
 9092c3c:	10800003 	ldbu	r2,0(r2)
 9092c40:	10803fcc 	andi	r2,r2,255
 9092c44:	108000a0 	cmpeqi	r2,r2,2
 9092c48:	1000051e 	bne	r2,zero,9092c60 <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9092c4c:	e0fffd17 	ldw	r3,-12(fp)
 9092c50:	00800044 	movi	r2,1
 9092c54:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9092c58:	e03fff15 	stw	zero,-4(fp)
 9092c5c:	0000a306 	br	9092eec <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 9092c60:	00824374 	movhi	r2,2317
 9092c64:	108eff04 	addi	r2,r2,15356
 9092c68:	10800003 	ldbu	r2,0(r2)
 9092c6c:	10803fcc 	andi	r2,r2,255
 9092c70:	1005003a 	cmpeq	r2,r2,zero
 9092c74:	1000051e 	bne	r2,zero,9092c8c <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 9092c78:	e0fffd17 	ldw	r3,-12(fp)
 9092c7c:	00800084 	movi	r2,2
 9092c80:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9092c84:	e03fff15 	stw	zero,-4(fp)
 9092c88:	00009806 	br	9092eec <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 9092c8c:	00824374 	movhi	r2,2317
 9092c90:	108ef104 	addi	r2,r2,15300
 9092c94:	10800003 	ldbu	r2,0(r2)
 9092c98:	10803fcc 	andi	r2,r2,255
 9092c9c:	1005003a 	cmpeq	r2,r2,zero
 9092ca0:	1000051e 	bne	r2,zero,9092cb8 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 9092ca4:	e0fffd17 	ldw	r3,-12(fp)
 9092ca8:	00800344 	movi	r2,13
 9092cac:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 9092cb0:	e03fff15 	stw	zero,-4(fp)
 9092cb4:	00008d06 	br	9092eec <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092cb8:	0005303a 	rdctl	r2,status
 9092cbc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092cc0:	e0fff717 	ldw	r3,-36(fp)
 9092cc4:	00bfff84 	movi	r2,-2
 9092cc8:	1884703a 	and	r2,r3,r2
 9092ccc:	1001703a 	wrctl	status,r2
  
  return context;
 9092cd0:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9092cd4:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 9092cd8:	e0bffb17 	ldw	r2,-20(fp)
 9092cdc:	10800117 	ldw	r2,4(r2)
 9092ce0:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 9092ce4:	e0bff917 	ldw	r2,-28(fp)
 9092ce8:	1080058b 	ldhu	r2,22(r2)
 9092cec:	10bfffcc 	andi	r2,r2,65535
 9092cf0:	1005003a 	cmpeq	r2,r2,zero
 9092cf4:	10001f1e 	bne	r2,zero,9092d74 <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 9092cf8:	e0bff917 	ldw	r2,-28(fp)
 9092cfc:	10c00417 	ldw	r3,16(r2)
 9092d00:	18800017 	ldw	r2,0(r3)
 9092d04:	e0bffa15 	stw	r2,-24(fp)
 9092d08:	18c00104 	addi	r3,r3,4
 9092d0c:	e0bff917 	ldw	r2,-28(fp)
 9092d10:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 9092d14:	e0bff917 	ldw	r2,-28(fp)
 9092d18:	1080058b 	ldhu	r2,22(r2)
 9092d1c:	10bfffc4 	addi	r2,r2,-1
 9092d20:	1007883a 	mov	r3,r2
 9092d24:	e0bff917 	ldw	r2,-28(fp)
 9092d28:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 9092d2c:	e0bff917 	ldw	r2,-28(fp)
 9092d30:	10c00417 	ldw	r3,16(r2)
 9092d34:	e0bff917 	ldw	r2,-28(fp)
 9092d38:	10800217 	ldw	r2,8(r2)
 9092d3c:	1880041e 	bne	r3,r2,9092d50 <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 9092d40:	e0bff917 	ldw	r2,-28(fp)
 9092d44:	10c00117 	ldw	r3,4(r2)
 9092d48:	e0bff917 	ldw	r2,-28(fp)
 9092d4c:	10c00415 	stw	r3,16(r2)
 9092d50:	e0bff817 	ldw	r2,-32(fp)
 9092d54:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092d58:	e0bff617 	ldw	r2,-40(fp)
 9092d5c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 9092d60:	e0bffd17 	ldw	r2,-12(fp)
 9092d64:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 9092d68:	e0bffa17 	ldw	r2,-24(fp)
 9092d6c:	e0bfff15 	stw	r2,-4(fp)
 9092d70:	00005e06 	br	9092eec <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 9092d74:	00824374 	movhi	r2,2317
 9092d78:	108f0004 	addi	r2,r2,15360
 9092d7c:	10c00017 	ldw	r3,0(r2)
 9092d80:	00824374 	movhi	r2,2317
 9092d84:	108f0004 	addi	r2,r2,15360
 9092d88:	10800017 	ldw	r2,0(r2)
 9092d8c:	10800c03 	ldbu	r2,48(r2)
 9092d90:	10800114 	ori	r2,r2,4
 9092d94:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9092d98:	00824374 	movhi	r2,2317
 9092d9c:	108f0004 	addi	r2,r2,15360
 9092da0:	10800017 	ldw	r2,0(r2)
 9092da4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 9092da8:	00824374 	movhi	r2,2317
 9092dac:	108f0004 	addi	r2,r2,15360
 9092db0:	10c00017 	ldw	r3,0(r2)
 9092db4:	e0bffc0b 	ldhu	r2,-16(fp)
 9092db8:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 9092dbc:	e13ffb17 	ldw	r4,-20(fp)
 9092dc0:	908f2380 	call	908f238 <OS_EventTaskWait>
 9092dc4:	e0bff817 	ldw	r2,-32(fp)
 9092dc8:	e0bff515 	stw	r2,-44(fp)
 9092dcc:	e0bff517 	ldw	r2,-44(fp)
 9092dd0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 9092dd4:	908fae40 	call	908fae4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092dd8:	0005303a 	rdctl	r2,status
 9092ddc:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092de0:	e0fff417 	ldw	r3,-48(fp)
 9092de4:	00bfff84 	movi	r2,-2
 9092de8:	1884703a 	and	r2,r3,r2
 9092dec:	1001703a 	wrctl	status,r2
  
  return context;
 9092df0:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 9092df4:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 9092df8:	00824374 	movhi	r2,2317
 9092dfc:	108f0004 	addi	r2,r2,15360
 9092e00:	10800017 	ldw	r2,0(r2)
 9092e04:	10800c43 	ldbu	r2,49(r2)
 9092e08:	10803fcc 	andi	r2,r2,255
 9092e0c:	e0bffe15 	stw	r2,-8(fp)
 9092e10:	e0fffe17 	ldw	r3,-8(fp)
 9092e14:	1805003a 	cmpeq	r2,r3,zero
 9092e18:	1000041e 	bne	r2,zero,9092e2c <OSQPend+0x248>
 9092e1c:	e0fffe17 	ldw	r3,-8(fp)
 9092e20:	188000a0 	cmpeqi	r2,r3,2
 9092e24:	1000091e 	bne	r2,zero,9092e4c <OSQPend+0x268>
 9092e28:	00000d06 	br	9092e60 <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 9092e2c:	00824374 	movhi	r2,2317
 9092e30:	108f0004 	addi	r2,r2,15360
 9092e34:	10800017 	ldw	r2,0(r2)
 9092e38:	10800917 	ldw	r2,36(r2)
 9092e3c:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 9092e40:	e0bffd17 	ldw	r2,-12(fp)
 9092e44:	10000005 	stb	zero,0(r2)
             break;
 9092e48:	00000e06 	br	9092e84 <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 9092e4c:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 9092e50:	e0fffd17 	ldw	r3,-12(fp)
 9092e54:	00800384 	movi	r2,14
 9092e58:	18800005 	stb	r2,0(r3)
             break;
 9092e5c:	00000906 	br	9092e84 <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 9092e60:	00824374 	movhi	r2,2317
 9092e64:	108f0004 	addi	r2,r2,15360
 9092e68:	11000017 	ldw	r4,0(r2)
 9092e6c:	e17ffb17 	ldw	r5,-20(fp)
 9092e70:	908f49c0 	call	908f49c <OS_EventTaskRemove>
             pmsg = (void *)0;
 9092e74:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 9092e78:	e0fffd17 	ldw	r3,-12(fp)
 9092e7c:	00800284 	movi	r2,10
 9092e80:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 9092e84:	00824374 	movhi	r2,2317
 9092e88:	108f0004 	addi	r2,r2,15360
 9092e8c:	10800017 	ldw	r2,0(r2)
 9092e90:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 9092e94:	00824374 	movhi	r2,2317
 9092e98:	108f0004 	addi	r2,r2,15360
 9092e9c:	10800017 	ldw	r2,0(r2)
 9092ea0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 9092ea4:	00824374 	movhi	r2,2317
 9092ea8:	108f0004 	addi	r2,r2,15360
 9092eac:	10800017 	ldw	r2,0(r2)
 9092eb0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 9092eb4:	00824374 	movhi	r2,2317
 9092eb8:	108f0004 	addi	r2,r2,15360
 9092ebc:	10800017 	ldw	r2,0(r2)
 9092ec0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 9092ec4:	00824374 	movhi	r2,2317
 9092ec8:	108f0004 	addi	r2,r2,15360
 9092ecc:	10800017 	ldw	r2,0(r2)
 9092ed0:	10000915 	stw	zero,36(r2)
 9092ed4:	e0bff817 	ldw	r2,-32(fp)
 9092ed8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9092edc:	e0bff317 	ldw	r2,-52(fp)
 9092ee0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 9092ee4:	e0bffa17 	ldw	r2,-24(fp)
 9092ee8:	e0bfff15 	stw	r2,-4(fp)
 9092eec:	e0bfff17 	ldw	r2,-4(fp)
}
 9092ef0:	e037883a 	mov	sp,fp
 9092ef4:	dfc00117 	ldw	ra,4(sp)
 9092ef8:	df000017 	ldw	fp,0(sp)
 9092efc:	dec00204 	addi	sp,sp,8
 9092f00:	f800283a 	ret

09092f04 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 9092f04:	defff504 	addi	sp,sp,-44
 9092f08:	dfc00a15 	stw	ra,40(sp)
 9092f0c:	df000915 	stw	fp,36(sp)
 9092f10:	df000904 	addi	fp,sp,36
 9092f14:	e13ffc15 	stw	r4,-16(fp)
 9092f18:	e1bffe15 	stw	r6,-8(fp)
 9092f1c:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 9092f20:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 9092f24:	e0bffe17 	ldw	r2,-8(fp)
 9092f28:	1004c03a 	cmpne	r2,r2,zero
 9092f2c:	1000021e 	bne	r2,zero,9092f38 <OSQPendAbort+0x34>
        return (0);
 9092f30:	e03fff15 	stw	zero,-4(fp)
 9092f34:	00004c06 	br	9093068 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9092f38:	e0bffc17 	ldw	r2,-16(fp)
 9092f3c:	1004c03a 	cmpne	r2,r2,zero
 9092f40:	1000051e 	bne	r2,zero,9092f58 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9092f44:	e0fffe17 	ldw	r3,-8(fp)
 9092f48:	00800104 	movi	r2,4
 9092f4c:	18800005 	stb	r2,0(r3)
        return (0);
 9092f50:	e03fff15 	stw	zero,-4(fp)
 9092f54:	00004406 	br	9093068 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 9092f58:	e0bffc17 	ldw	r2,-16(fp)
 9092f5c:	10800003 	ldbu	r2,0(r2)
 9092f60:	10803fcc 	andi	r2,r2,255
 9092f64:	108000a0 	cmpeqi	r2,r2,2
 9092f68:	1000051e 	bne	r2,zero,9092f80 <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9092f6c:	e0fffe17 	ldw	r3,-8(fp)
 9092f70:	00800044 	movi	r2,1
 9092f74:	18800005 	stb	r2,0(r3)
        return (0);
 9092f78:	e03fff15 	stw	zero,-4(fp)
 9092f7c:	00003a06 	br	9093068 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9092f80:	0005303a 	rdctl	r2,status
 9092f84:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9092f88:	e0fff917 	ldw	r3,-28(fp)
 9092f8c:	00bfff84 	movi	r2,-2
 9092f90:	1884703a 	and	r2,r3,r2
 9092f94:	1001703a 	wrctl	status,r2
  
  return context;
 9092f98:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9092f9c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 9092fa0:	e0bffc17 	ldw	r2,-16(fp)
 9092fa4:	10800283 	ldbu	r2,10(r2)
 9092fa8:	10803fcc 	andi	r2,r2,255
 9092fac:	1005003a 	cmpeq	r2,r2,zero
 9092fb0:	1000261e 	bne	r2,zero,909304c <OSQPendAbort+0x148>
        nbr_tasks = 0;
 9092fb4:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 9092fb8:	e0bffd03 	ldbu	r2,-12(fp)
 9092fbc:	10800060 	cmpeqi	r2,r2,1
 9092fc0:	1000091e 	bne	r2,zero,9092fe8 <OSQPendAbort+0xe4>
 9092fc4:	00000e06 	br	9093000 <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 9092fc8:	e13ffc17 	ldw	r4,-16(fp)
 9092fcc:	000b883a 	mov	r5,zero
 9092fd0:	01800104 	movi	r6,4
 9092fd4:	01c00084 	movi	r7,2
 9092fd8:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                     nbr_tasks++;
 9092fdc:	e0bffb03 	ldbu	r2,-20(fp)
 9092fe0:	10800044 	addi	r2,r2,1
 9092fe4:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 9092fe8:	e0bffc17 	ldw	r2,-16(fp)
 9092fec:	10800283 	ldbu	r2,10(r2)
 9092ff0:	10803fcc 	andi	r2,r2,255
 9092ff4:	1004c03a 	cmpne	r2,r2,zero
 9092ff8:	103ff31e 	bne	r2,zero,9092fc8 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 9092ffc:	00000806 	br	9093020 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 9093000:	e13ffc17 	ldw	r4,-16(fp)
 9093004:	000b883a 	mov	r5,zero
 9093008:	01800104 	movi	r6,4
 909300c:	01c00084 	movi	r7,2
 9093010:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                 nbr_tasks++;
 9093014:	e0bffb03 	ldbu	r2,-20(fp)
 9093018:	10800044 	addi	r2,r2,1
 909301c:	e0bffb05 	stb	r2,-20(fp)
 9093020:	e0bffa17 	ldw	r2,-24(fp)
 9093024:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093028:	e0bff817 	ldw	r2,-32(fp)
 909302c:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 9093030:	908fae40 	call	908fae4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 9093034:	e0fffe17 	ldw	r3,-8(fp)
 9093038:	00800384 	movi	r2,14
 909303c:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 9093040:	e0bffb03 	ldbu	r2,-20(fp)
 9093044:	e0bfff15 	stw	r2,-4(fp)
 9093048:	00000706 	br	9093068 <OSQPendAbort+0x164>
 909304c:	e0bffa17 	ldw	r2,-24(fp)
 9093050:	e0bff715 	stw	r2,-36(fp)
 9093054:	e0bff717 	ldw	r2,-36(fp)
 9093058:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 909305c:	e0bffe17 	ldw	r2,-8(fp)
 9093060:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 9093064:	e03fff15 	stw	zero,-4(fp)
 9093068:	e0bfff17 	ldw	r2,-4(fp)
}
 909306c:	e037883a 	mov	sp,fp
 9093070:	dfc00117 	ldw	ra,4(sp)
 9093074:	df000017 	ldw	fp,0(sp)
 9093078:	dec00204 	addi	sp,sp,8
 909307c:	f800283a 	ret

09093080 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 9093080:	defff504 	addi	sp,sp,-44
 9093084:	dfc00a15 	stw	ra,40(sp)
 9093088:	df000915 	stw	fp,36(sp)
 909308c:	df000904 	addi	fp,sp,36
 9093090:	e13ffd15 	stw	r4,-12(fp)
 9093094:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 9093098:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 909309c:	e0bffd17 	ldw	r2,-12(fp)
 90930a0:	1004c03a 	cmpne	r2,r2,zero
 90930a4:	1000031e 	bne	r2,zero,90930b4 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 90930a8:	00800104 	movi	r2,4
 90930ac:	e0bfff15 	stw	r2,-4(fp)
 90930b0:	00004d06 	br	90931e8 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 90930b4:	e0bffd17 	ldw	r2,-12(fp)
 90930b8:	10800003 	ldbu	r2,0(r2)
 90930bc:	10803fcc 	andi	r2,r2,255
 90930c0:	108000a0 	cmpeqi	r2,r2,2
 90930c4:	1000031e 	bne	r2,zero,90930d4 <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 90930c8:	00800044 	movi	r2,1
 90930cc:	e0bfff15 	stw	r2,-4(fp)
 90930d0:	00004506 	br	90931e8 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90930d4:	0005303a 	rdctl	r2,status
 90930d8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90930dc:	e0fffa17 	ldw	r3,-24(fp)
 90930e0:	00bfff84 	movi	r2,-2
 90930e4:	1884703a 	and	r2,r3,r2
 90930e8:	1001703a 	wrctl	status,r2
  
  return context;
 90930ec:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 90930f0:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 90930f4:	e0bffd17 	ldw	r2,-12(fp)
 90930f8:	10800283 	ldbu	r2,10(r2)
 90930fc:	10803fcc 	andi	r2,r2,255
 9093100:	1005003a 	cmpeq	r2,r2,zero
 9093104:	10000c1e 	bne	r2,zero,9093138 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9093108:	e13ffd17 	ldw	r4,-12(fp)
 909310c:	e17ffe17 	ldw	r5,-8(fp)
 9093110:	01800104 	movi	r6,4
 9093114:	000f883a 	mov	r7,zero
 9093118:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
 909311c:	e0bffb17 	ldw	r2,-20(fp)
 9093120:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093124:	e0bff917 	ldw	r2,-28(fp)
 9093128:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 909312c:	908fae40 	call	908fae4 <OS_Sched>
        return (OS_ERR_NONE);
 9093130:	e03fff15 	stw	zero,-4(fp)
 9093134:	00002c06 	br	90931e8 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 9093138:	e0bffd17 	ldw	r2,-12(fp)
 909313c:	10800117 	ldw	r2,4(r2)
 9093140:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 9093144:	e0bffc17 	ldw	r2,-16(fp)
 9093148:	10c0058b 	ldhu	r3,22(r2)
 909314c:	e0bffc17 	ldw	r2,-16(fp)
 9093150:	1080050b 	ldhu	r2,20(r2)
 9093154:	18ffffcc 	andi	r3,r3,65535
 9093158:	10bfffcc 	andi	r2,r2,65535
 909315c:	18800736 	bltu	r3,r2,909317c <OSQPost+0xfc>
 9093160:	e0bffb17 	ldw	r2,-20(fp)
 9093164:	e0bff815 	stw	r2,-32(fp)
 9093168:	e0bff817 	ldw	r2,-32(fp)
 909316c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 9093170:	00800784 	movi	r2,30
 9093174:	e0bfff15 	stw	r2,-4(fp)
 9093178:	00001b06 	br	90931e8 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 909317c:	e0bffc17 	ldw	r2,-16(fp)
 9093180:	10c00317 	ldw	r3,12(r2)
 9093184:	e0bffe17 	ldw	r2,-8(fp)
 9093188:	18800015 	stw	r2,0(r3)
 909318c:	18c00104 	addi	r3,r3,4
 9093190:	e0bffc17 	ldw	r2,-16(fp)
 9093194:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 9093198:	e0bffc17 	ldw	r2,-16(fp)
 909319c:	1080058b 	ldhu	r2,22(r2)
 90931a0:	10800044 	addi	r2,r2,1
 90931a4:	1007883a 	mov	r3,r2
 90931a8:	e0bffc17 	ldw	r2,-16(fp)
 90931ac:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 90931b0:	e0bffc17 	ldw	r2,-16(fp)
 90931b4:	10c00317 	ldw	r3,12(r2)
 90931b8:	e0bffc17 	ldw	r2,-16(fp)
 90931bc:	10800217 	ldw	r2,8(r2)
 90931c0:	1880041e 	bne	r3,r2,90931d4 <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 90931c4:	e0bffc17 	ldw	r2,-16(fp)
 90931c8:	10c00117 	ldw	r3,4(r2)
 90931cc:	e0bffc17 	ldw	r2,-16(fp)
 90931d0:	10c00315 	stw	r3,12(r2)
 90931d4:	e0bffb17 	ldw	r2,-20(fp)
 90931d8:	e0bff715 	stw	r2,-36(fp)
 90931dc:	e0bff717 	ldw	r2,-36(fp)
 90931e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 90931e4:	e03fff15 	stw	zero,-4(fp)
 90931e8:	e0bfff17 	ldw	r2,-4(fp)
}
 90931ec:	e037883a 	mov	sp,fp
 90931f0:	dfc00117 	ldw	ra,4(sp)
 90931f4:	df000017 	ldw	fp,0(sp)
 90931f8:	dec00204 	addi	sp,sp,8
 90931fc:	f800283a 	ret

09093200 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 9093200:	defff504 	addi	sp,sp,-44
 9093204:	dfc00a15 	stw	ra,40(sp)
 9093208:	df000915 	stw	fp,36(sp)
 909320c:	df000904 	addi	fp,sp,36
 9093210:	e13ffd15 	stw	r4,-12(fp)
 9093214:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9093218:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 909321c:	e0bffd17 	ldw	r2,-12(fp)
 9093220:	1004c03a 	cmpne	r2,r2,zero
 9093224:	1000031e 	bne	r2,zero,9093234 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 9093228:	00800104 	movi	r2,4
 909322c:	e0bfff15 	stw	r2,-4(fp)
 9093230:	00004f06 	br	9093370 <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 9093234:	e0bffd17 	ldw	r2,-12(fp)
 9093238:	10800003 	ldbu	r2,0(r2)
 909323c:	10803fcc 	andi	r2,r2,255
 9093240:	108000a0 	cmpeqi	r2,r2,2
 9093244:	1000031e 	bne	r2,zero,9093254 <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 9093248:	00800044 	movi	r2,1
 909324c:	e0bfff15 	stw	r2,-4(fp)
 9093250:	00004706 	br	9093370 <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093254:	0005303a 	rdctl	r2,status
 9093258:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909325c:	e0fffa17 	ldw	r3,-24(fp)
 9093260:	00bfff84 	movi	r2,-2
 9093264:	1884703a 	and	r2,r3,r2
 9093268:	1001703a 	wrctl	status,r2
  
  return context;
 909326c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9093270:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 9093274:	e0bffd17 	ldw	r2,-12(fp)
 9093278:	10800283 	ldbu	r2,10(r2)
 909327c:	10803fcc 	andi	r2,r2,255
 9093280:	1005003a 	cmpeq	r2,r2,zero
 9093284:	10000c1e 	bne	r2,zero,90932b8 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9093288:	e13ffd17 	ldw	r4,-12(fp)
 909328c:	e17ffe17 	ldw	r5,-8(fp)
 9093290:	01800104 	movi	r6,4
 9093294:	000f883a 	mov	r7,zero
 9093298:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
 909329c:	e0bffb17 	ldw	r2,-20(fp)
 90932a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90932a4:	e0bff917 	ldw	r2,-28(fp)
 90932a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 90932ac:	908fae40 	call	908fae4 <OS_Sched>
        return (OS_ERR_NONE);
 90932b0:	e03fff15 	stw	zero,-4(fp)
 90932b4:	00002e06 	br	9093370 <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 90932b8:	e0bffd17 	ldw	r2,-12(fp)
 90932bc:	10800117 	ldw	r2,4(r2)
 90932c0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 90932c4:	e0bffc17 	ldw	r2,-16(fp)
 90932c8:	10c0058b 	ldhu	r3,22(r2)
 90932cc:	e0bffc17 	ldw	r2,-16(fp)
 90932d0:	1080050b 	ldhu	r2,20(r2)
 90932d4:	18ffffcc 	andi	r3,r3,65535
 90932d8:	10bfffcc 	andi	r2,r2,65535
 90932dc:	18800736 	bltu	r3,r2,90932fc <OSQPostFront+0xfc>
 90932e0:	e0bffb17 	ldw	r2,-20(fp)
 90932e4:	e0bff815 	stw	r2,-32(fp)
 90932e8:	e0bff817 	ldw	r2,-32(fp)
 90932ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 90932f0:	00800784 	movi	r2,30
 90932f4:	e0bfff15 	stw	r2,-4(fp)
 90932f8:	00001d06 	br	9093370 <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 90932fc:	e0bffc17 	ldw	r2,-16(fp)
 9093300:	10c00417 	ldw	r3,16(r2)
 9093304:	e0bffc17 	ldw	r2,-16(fp)
 9093308:	10800117 	ldw	r2,4(r2)
 909330c:	1880041e 	bne	r3,r2,9093320 <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 9093310:	e0bffc17 	ldw	r2,-16(fp)
 9093314:	10c00217 	ldw	r3,8(r2)
 9093318:	e0bffc17 	ldw	r2,-16(fp)
 909331c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 9093320:	e0bffc17 	ldw	r2,-16(fp)
 9093324:	10800417 	ldw	r2,16(r2)
 9093328:	10ffff04 	addi	r3,r2,-4
 909332c:	e0bffc17 	ldw	r2,-16(fp)
 9093330:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 9093334:	e0bffc17 	ldw	r2,-16(fp)
 9093338:	10c00417 	ldw	r3,16(r2)
 909333c:	e0bffe17 	ldw	r2,-8(fp)
 9093340:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 9093344:	e0bffc17 	ldw	r2,-16(fp)
 9093348:	1080058b 	ldhu	r2,22(r2)
 909334c:	10800044 	addi	r2,r2,1
 9093350:	1007883a 	mov	r3,r2
 9093354:	e0bffc17 	ldw	r2,-16(fp)
 9093358:	10c0058d 	sth	r3,22(r2)
 909335c:	e0bffb17 	ldw	r2,-20(fp)
 9093360:	e0bff715 	stw	r2,-36(fp)
 9093364:	e0bff717 	ldw	r2,-36(fp)
 9093368:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 909336c:	e03fff15 	stw	zero,-4(fp)
 9093370:	e0bfff17 	ldw	r2,-4(fp)
}
 9093374:	e037883a 	mov	sp,fp
 9093378:	dfc00117 	ldw	ra,4(sp)
 909337c:	df000017 	ldw	fp,0(sp)
 9093380:	dec00204 	addi	sp,sp,8
 9093384:	f800283a 	ret

09093388 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 9093388:	defff404 	addi	sp,sp,-48
 909338c:	dfc00b15 	stw	ra,44(sp)
 9093390:	df000a15 	stw	fp,40(sp)
 9093394:	df000a04 	addi	fp,sp,40
 9093398:	e13ffc15 	stw	r4,-16(fp)
 909339c:	e17ffd15 	stw	r5,-12(fp)
 90933a0:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90933a4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 90933a8:	e0bffc17 	ldw	r2,-16(fp)
 90933ac:	1004c03a 	cmpne	r2,r2,zero
 90933b0:	1000031e 	bne	r2,zero,90933c0 <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 90933b4:	00800104 	movi	r2,4
 90933b8:	e0bfff15 	stw	r2,-4(fp)
 90933bc:	00007906 	br	90935a4 <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 90933c0:	e0bffc17 	ldw	r2,-16(fp)
 90933c4:	10800003 	ldbu	r2,0(r2)
 90933c8:	10803fcc 	andi	r2,r2,255
 90933cc:	108000a0 	cmpeqi	r2,r2,2
 90933d0:	1000031e 	bne	r2,zero,90933e0 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 90933d4:	00800044 	movi	r2,1
 90933d8:	e0bfff15 	stw	r2,-4(fp)
 90933dc:	00007106 	br	90935a4 <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90933e0:	0005303a 	rdctl	r2,status
 90933e4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90933e8:	e0fff917 	ldw	r3,-28(fp)
 90933ec:	00bfff84 	movi	r2,-2
 90933f0:	1884703a 	and	r2,r3,r2
 90933f4:	1001703a 	wrctl	status,r2
  
  return context;
 90933f8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 90933fc:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 9093400:	e0bffc17 	ldw	r2,-16(fp)
 9093404:	10800283 	ldbu	r2,10(r2)
 9093408:	10803fcc 	andi	r2,r2,255
 909340c:	1005003a 	cmpeq	r2,r2,zero
 9093410:	1000211e 	bne	r2,zero,9093498 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 9093414:	e0bffe03 	ldbu	r2,-8(fp)
 9093418:	1080004c 	andi	r2,r2,1
 909341c:	10803fcc 	andi	r2,r2,255
 9093420:	1005003a 	cmpeq	r2,r2,zero
 9093424:	10000c1e 	bne	r2,zero,9093458 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 9093428:	00000506 	br	9093440 <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 909342c:	e13ffc17 	ldw	r4,-16(fp)
 9093430:	e17ffd17 	ldw	r5,-12(fp)
 9093434:	01800104 	movi	r6,4
 9093438:	000f883a 	mov	r7,zero
 909343c:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 9093440:	e0bffc17 	ldw	r2,-16(fp)
 9093444:	10800283 	ldbu	r2,10(r2)
 9093448:	10803fcc 	andi	r2,r2,255
 909344c:	1004c03a 	cmpne	r2,r2,zero
 9093450:	103ff61e 	bne	r2,zero,909342c <OSQPostOpt+0xa4>
 9093454:	00000506 	br	909346c <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 9093458:	e13ffc17 	ldw	r4,-16(fp)
 909345c:	e17ffd17 	ldw	r5,-12(fp)
 9093460:	01800104 	movi	r6,4
 9093464:	000f883a 	mov	r7,zero
 9093468:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
 909346c:	e0bffa17 	ldw	r2,-24(fp)
 9093470:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093474:	e0bff817 	ldw	r2,-32(fp)
 9093478:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 909347c:	e0bffe03 	ldbu	r2,-8(fp)
 9093480:	1080010c 	andi	r2,r2,4
 9093484:	1004c03a 	cmpne	r2,r2,zero
 9093488:	1000011e 	bne	r2,zero,9093490 <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 909348c:	908fae40 	call	908fae4 <OS_Sched>
        }
        return (OS_ERR_NONE);
 9093490:	e03fff15 	stw	zero,-4(fp)
 9093494:	00004306 	br	90935a4 <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 9093498:	e0bffc17 	ldw	r2,-16(fp)
 909349c:	10800117 	ldw	r2,4(r2)
 90934a0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 90934a4:	e0bffb17 	ldw	r2,-20(fp)
 90934a8:	10c0058b 	ldhu	r3,22(r2)
 90934ac:	e0bffb17 	ldw	r2,-20(fp)
 90934b0:	1080050b 	ldhu	r2,20(r2)
 90934b4:	18ffffcc 	andi	r3,r3,65535
 90934b8:	10bfffcc 	andi	r2,r2,65535
 90934bc:	18800736 	bltu	r3,r2,90934dc <OSQPostOpt+0x154>
 90934c0:	e0bffa17 	ldw	r2,-24(fp)
 90934c4:	e0bff715 	stw	r2,-36(fp)
 90934c8:	e0bff717 	ldw	r2,-36(fp)
 90934cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 90934d0:	00800784 	movi	r2,30
 90934d4:	e0bfff15 	stw	r2,-4(fp)
 90934d8:	00003206 	br	90935a4 <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 90934dc:	e0bffe03 	ldbu	r2,-8(fp)
 90934e0:	1080008c 	andi	r2,r2,2
 90934e4:	1005003a 	cmpeq	r2,r2,zero
 90934e8:	1000131e 	bne	r2,zero,9093538 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 90934ec:	e0bffb17 	ldw	r2,-20(fp)
 90934f0:	10c00417 	ldw	r3,16(r2)
 90934f4:	e0bffb17 	ldw	r2,-20(fp)
 90934f8:	10800117 	ldw	r2,4(r2)
 90934fc:	1880041e 	bne	r3,r2,9093510 <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 9093500:	e0bffb17 	ldw	r2,-20(fp)
 9093504:	10c00217 	ldw	r3,8(r2)
 9093508:	e0bffb17 	ldw	r2,-20(fp)
 909350c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 9093510:	e0bffb17 	ldw	r2,-20(fp)
 9093514:	10800417 	ldw	r2,16(r2)
 9093518:	10ffff04 	addi	r3,r2,-4
 909351c:	e0bffb17 	ldw	r2,-20(fp)
 9093520:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 9093524:	e0bffb17 	ldw	r2,-20(fp)
 9093528:	10c00417 	ldw	r3,16(r2)
 909352c:	e0bffd17 	ldw	r2,-12(fp)
 9093530:	18800015 	stw	r2,0(r3)
 9093534:	00001006 	br	9093578 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 9093538:	e0bffb17 	ldw	r2,-20(fp)
 909353c:	10c00317 	ldw	r3,12(r2)
 9093540:	e0bffd17 	ldw	r2,-12(fp)
 9093544:	18800015 	stw	r2,0(r3)
 9093548:	18c00104 	addi	r3,r3,4
 909354c:	e0bffb17 	ldw	r2,-20(fp)
 9093550:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 9093554:	e0bffb17 	ldw	r2,-20(fp)
 9093558:	10c00317 	ldw	r3,12(r2)
 909355c:	e0bffb17 	ldw	r2,-20(fp)
 9093560:	10800217 	ldw	r2,8(r2)
 9093564:	1880041e 	bne	r3,r2,9093578 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 9093568:	e0bffb17 	ldw	r2,-20(fp)
 909356c:	10c00117 	ldw	r3,4(r2)
 9093570:	e0bffb17 	ldw	r2,-20(fp)
 9093574:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 9093578:	e0bffb17 	ldw	r2,-20(fp)
 909357c:	1080058b 	ldhu	r2,22(r2)
 9093580:	10800044 	addi	r2,r2,1
 9093584:	1007883a 	mov	r3,r2
 9093588:	e0bffb17 	ldw	r2,-20(fp)
 909358c:	10c0058d 	sth	r3,22(r2)
 9093590:	e0bffa17 	ldw	r2,-24(fp)
 9093594:	e0bff615 	stw	r2,-40(fp)
 9093598:	e0bff617 	ldw	r2,-40(fp)
 909359c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 90935a0:	e03fff15 	stw	zero,-4(fp)
 90935a4:	e0bfff17 	ldw	r2,-4(fp)
}
 90935a8:	e037883a 	mov	sp,fp
 90935ac:	dfc00117 	ldw	ra,4(sp)
 90935b0:	df000017 	ldw	fp,0(sp)
 90935b4:	dec00204 	addi	sp,sp,8
 90935b8:	f800283a 	ret

090935bc <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 90935bc:	defff504 	addi	sp,sp,-44
 90935c0:	df000a15 	stw	fp,40(sp)
 90935c4:	df000a04 	addi	fp,sp,40
 90935c8:	e13ffd15 	stw	r4,-12(fp)
 90935cc:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 90935d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 90935d4:	e0bffd17 	ldw	r2,-12(fp)
 90935d8:	1004c03a 	cmpne	r2,r2,zero
 90935dc:	1000031e 	bne	r2,zero,90935ec <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 90935e0:	00800104 	movi	r2,4
 90935e4:	e0bfff15 	stw	r2,-4(fp)
 90935e8:	00004f06 	br	9093728 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 90935ec:	e0bffe17 	ldw	r2,-8(fp)
 90935f0:	1004c03a 	cmpne	r2,r2,zero
 90935f4:	1000031e 	bne	r2,zero,9093604 <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 90935f8:	00800244 	movi	r2,9
 90935fc:	e0bfff15 	stw	r2,-4(fp)
 9093600:	00004906 	br	9093728 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 9093604:	e0bffd17 	ldw	r2,-12(fp)
 9093608:	10800003 	ldbu	r2,0(r2)
 909360c:	10803fcc 	andi	r2,r2,255
 9093610:	108000a0 	cmpeqi	r2,r2,2
 9093614:	1000031e 	bne	r2,zero,9093624 <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 9093618:	00800044 	movi	r2,1
 909361c:	e0bfff15 	stw	r2,-4(fp)
 9093620:	00004106 	br	9093728 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093624:	0005303a 	rdctl	r2,status
 9093628:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909362c:	e0fff717 	ldw	r3,-36(fp)
 9093630:	00bfff84 	movi	r2,-2
 9093634:	1884703a 	and	r2,r3,r2
 9093638:	1001703a 	wrctl	status,r2
  
  return context;
 909363c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9093640:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 9093644:	e0bffd17 	ldw	r2,-12(fp)
 9093648:	10c00283 	ldbu	r3,10(r2)
 909364c:	e0bffe17 	ldw	r2,-8(fp)
 9093650:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 9093654:	e0bffd17 	ldw	r2,-12(fp)
 9093658:	108002c4 	addi	r2,r2,11
 909365c:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 9093660:	e0bffe17 	ldw	r2,-8(fp)
 9093664:	10800204 	addi	r2,r2,8
 9093668:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909366c:	e03ffb05 	stb	zero,-20(fp)
 9093670:	00000d06 	br	90936a8 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 9093674:	e0bffa17 	ldw	r2,-24(fp)
 9093678:	10c00003 	ldbu	r3,0(r2)
 909367c:	e0bff917 	ldw	r2,-28(fp)
 9093680:	10c00005 	stb	r3,0(r2)
 9093684:	e0bff917 	ldw	r2,-28(fp)
 9093688:	10800044 	addi	r2,r2,1
 909368c:	e0bff915 	stw	r2,-28(fp)
 9093690:	e0bffa17 	ldw	r2,-24(fp)
 9093694:	10800044 	addi	r2,r2,1
 9093698:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909369c:	e0bffb03 	ldbu	r2,-20(fp)
 90936a0:	10800044 	addi	r2,r2,1
 90936a4:	e0bffb05 	stb	r2,-20(fp)
 90936a8:	e0bffb03 	ldbu	r2,-20(fp)
 90936ac:	108000f0 	cmpltui	r2,r2,3
 90936b0:	103ff01e 	bne	r2,zero,9093674 <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 90936b4:	e0bffd17 	ldw	r2,-12(fp)
 90936b8:	10800117 	ldw	r2,4(r2)
 90936bc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 90936c0:	e0bffc17 	ldw	r2,-16(fp)
 90936c4:	1080058b 	ldhu	r2,22(r2)
 90936c8:	10bfffcc 	andi	r2,r2,65535
 90936cc:	1005003a 	cmpeq	r2,r2,zero
 90936d0:	1000061e 	bne	r2,zero,90936ec <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 90936d4:	e0bffc17 	ldw	r2,-16(fp)
 90936d8:	10800417 	ldw	r2,16(r2)
 90936dc:	10c00017 	ldw	r3,0(r2)
 90936e0:	e0bffe17 	ldw	r2,-8(fp)
 90936e4:	10c00015 	stw	r3,0(r2)
 90936e8:	00000206 	br	90936f4 <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 90936ec:	e0bffe17 	ldw	r2,-8(fp)
 90936f0:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 90936f4:	e0bffc17 	ldw	r2,-16(fp)
 90936f8:	10c0058b 	ldhu	r3,22(r2)
 90936fc:	e0bffe17 	ldw	r2,-8(fp)
 9093700:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 9093704:	e0bffc17 	ldw	r2,-16(fp)
 9093708:	10c0050b 	ldhu	r3,20(r2)
 909370c:	e0bffe17 	ldw	r2,-8(fp)
 9093710:	10c0018d 	sth	r3,6(r2)
 9093714:	e0bff817 	ldw	r2,-32(fp)
 9093718:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909371c:	e0bff617 	ldw	r2,-40(fp)
 9093720:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9093724:	e03fff15 	stw	zero,-4(fp)
 9093728:	e0bfff17 	ldw	r2,-4(fp)
}
 909372c:	e037883a 	mov	sp,fp
 9093730:	df000017 	ldw	fp,0(sp)
 9093734:	dec00104 	addi	sp,sp,4
 9093738:	f800283a 	ret

0909373c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 909373c:	defffb04 	addi	sp,sp,-20
 9093740:	dfc00415 	stw	ra,16(sp)
 9093744:	df000315 	stw	fp,12(sp)
 9093748:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 909374c:	010243b4 	movhi	r4,2318
 9093750:	212de804 	addi	r4,r4,-18528
 9093754:	01407804 	movi	r5,480
 9093758:	908fa240 	call	908fa24 <OS_MemClr>
    pq1 = &OSQTbl[0];
 909375c:	008243b4 	movhi	r2,2318
 9093760:	10ade804 	addi	r2,r2,-18528
 9093764:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 9093768:	008243b4 	movhi	r2,2318
 909376c:	10adee04 	addi	r2,r2,-18504
 9093770:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 9093774:	e03fff0d 	sth	zero,-4(fp)
 9093778:	00000c06 	br	90937ac <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 909377c:	e0fffe17 	ldw	r3,-8(fp)
 9093780:	e0bffd17 	ldw	r2,-12(fp)
 9093784:	18800015 	stw	r2,0(r3)
        pq1++;
 9093788:	e0bffe17 	ldw	r2,-8(fp)
 909378c:	10800604 	addi	r2,r2,24
 9093790:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 9093794:	e0bffd17 	ldw	r2,-12(fp)
 9093798:	10800604 	addi	r2,r2,24
 909379c:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 90937a0:	e0bfff0b 	ldhu	r2,-4(fp)
 90937a4:	10800044 	addi	r2,r2,1
 90937a8:	e0bfff0d 	sth	r2,-4(fp)
 90937ac:	e0bfff0b 	ldhu	r2,-4(fp)
 90937b0:	108004f0 	cmpltui	r2,r2,19
 90937b4:	103ff11e 	bne	r2,zero,909377c <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 90937b8:	e0bffe17 	ldw	r2,-8(fp)
 90937bc:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 90937c0:	00c24374 	movhi	r3,2317
 90937c4:	18cefc04 	addi	r3,r3,15344
 90937c8:	008243b4 	movhi	r2,2318
 90937cc:	10ade804 	addi	r2,r2,-18528
 90937d0:	18800015 	stw	r2,0(r3)
#endif
}
 90937d4:	e037883a 	mov	sp,fp
 90937d8:	dfc00117 	ldw	ra,4(sp)
 90937dc:	df000017 	ldw	fp,0(sp)
 90937e0:	dec00204 	addi	sp,sp,8
 90937e4:	f800283a 	ret

090937e8 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 90937e8:	defff904 	addi	sp,sp,-28
 90937ec:	df000615 	stw	fp,24(sp)
 90937f0:	df000604 	addi	fp,sp,24
 90937f4:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90937f8:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 90937fc:	e0bffe17 	ldw	r2,-8(fp)
 9093800:	1004c03a 	cmpne	r2,r2,zero
 9093804:	1000021e 	bne	r2,zero,9093810 <OSSemAccept+0x28>
        return (0);
 9093808:	e03fff15 	stw	zero,-4(fp)
 909380c:	00002106 	br	9093894 <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9093810:	e0bffe17 	ldw	r2,-8(fp)
 9093814:	10800003 	ldbu	r2,0(r2)
 9093818:	10803fcc 	andi	r2,r2,255
 909381c:	108000e0 	cmpeqi	r2,r2,3
 9093820:	1000021e 	bne	r2,zero,909382c <OSSemAccept+0x44>
        return (0);
 9093824:	e03fff15 	stw	zero,-4(fp)
 9093828:	00001a06 	br	9093894 <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909382c:	0005303a 	rdctl	r2,status
 9093830:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093834:	e0fffb17 	ldw	r3,-20(fp)
 9093838:	00bfff84 	movi	r2,-2
 909383c:	1884703a 	and	r2,r3,r2
 9093840:	1001703a 	wrctl	status,r2
  
  return context;
 9093844:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 9093848:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 909384c:	e0bffe17 	ldw	r2,-8(fp)
 9093850:	1080020b 	ldhu	r2,8(r2)
 9093854:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 9093858:	e0bffd0b 	ldhu	r2,-12(fp)
 909385c:	1005003a 	cmpeq	r2,r2,zero
 9093860:	1000061e 	bne	r2,zero,909387c <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 9093864:	e0bffe17 	ldw	r2,-8(fp)
 9093868:	1080020b 	ldhu	r2,8(r2)
 909386c:	10bfffc4 	addi	r2,r2,-1
 9093870:	1007883a 	mov	r3,r2
 9093874:	e0bffe17 	ldw	r2,-8(fp)
 9093878:	10c0020d 	sth	r3,8(r2)
 909387c:	e0bffc17 	ldw	r2,-16(fp)
 9093880:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093884:	e0bffa17 	ldw	r2,-24(fp)
 9093888:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 909388c:	e0bffd0b 	ldhu	r2,-12(fp)
 9093890:	e0bfff15 	stw	r2,-4(fp)
 9093894:	e0bfff17 	ldw	r2,-4(fp)
}
 9093898:	e037883a 	mov	sp,fp
 909389c:	df000017 	ldw	fp,0(sp)
 90938a0:	dec00104 	addi	sp,sp,4
 90938a4:	f800283a 	ret

090938a8 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 90938a8:	defff804 	addi	sp,sp,-32
 90938ac:	dfc00715 	stw	ra,28(sp)
 90938b0:	df000615 	stw	fp,24(sp)
 90938b4:	df000604 	addi	fp,sp,24
 90938b8:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 90938bc:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 90938c0:	00824374 	movhi	r2,2317
 90938c4:	108eff04 	addi	r2,r2,15356
 90938c8:	10800003 	ldbu	r2,0(r2)
 90938cc:	10803fcc 	andi	r2,r2,255
 90938d0:	1005003a 	cmpeq	r2,r2,zero
 90938d4:	1000021e 	bne	r2,zero,90938e0 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 90938d8:	e03fff15 	stw	zero,-4(fp)
 90938dc:	00003106 	br	90939a4 <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90938e0:	0005303a 	rdctl	r2,status
 90938e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90938e8:	e0fffb17 	ldw	r3,-20(fp)
 90938ec:	00bfff84 	movi	r2,-2
 90938f0:	1884703a 	and	r2,r3,r2
 90938f4:	1001703a 	wrctl	status,r2
  
  return context;
 90938f8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 90938fc:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 9093900:	00824374 	movhi	r2,2317
 9093904:	108efe04 	addi	r2,r2,15352
 9093908:	10800017 	ldw	r2,0(r2)
 909390c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 9093910:	00824374 	movhi	r2,2317
 9093914:	108efe04 	addi	r2,r2,15352
 9093918:	10800017 	ldw	r2,0(r2)
 909391c:	1005003a 	cmpeq	r2,r2,zero
 9093920:	1000081e 	bne	r2,zero,9093944 <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 9093924:	00824374 	movhi	r2,2317
 9093928:	108efe04 	addi	r2,r2,15352
 909392c:	10800017 	ldw	r2,0(r2)
 9093930:	10800117 	ldw	r2,4(r2)
 9093934:	1007883a 	mov	r3,r2
 9093938:	00824374 	movhi	r2,2317
 909393c:	108efe04 	addi	r2,r2,15352
 9093940:	10c00015 	stw	r3,0(r2)
 9093944:	e0bffc17 	ldw	r2,-16(fp)
 9093948:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909394c:	e0bffa17 	ldw	r2,-24(fp)
 9093950:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 9093954:	e0bffd17 	ldw	r2,-12(fp)
 9093958:	1005003a 	cmpeq	r2,r2,zero
 909395c:	10000f1e 	bne	r2,zero,909399c <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 9093960:	e0fffd17 	ldw	r3,-12(fp)
 9093964:	008000c4 	movi	r2,3
 9093968:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 909396c:	e0fffd17 	ldw	r3,-12(fp)
 9093970:	e0bffe0b 	ldhu	r2,-8(fp)
 9093974:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 9093978:	e0bffd17 	ldw	r2,-12(fp)
 909397c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 9093980:	e0fffd17 	ldw	r3,-12(fp)
 9093984:	00800fc4 	movi	r2,63
 9093988:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 909398c:	e0bffd17 	ldw	r2,-12(fp)
 9093990:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 9093994:	e13ffd17 	ldw	r4,-12(fp)
 9093998:	908f6580 	call	908f658 <OS_EventWaitListInit>
    }
    return (pevent);
 909399c:	e0bffd17 	ldw	r2,-12(fp)
 90939a0:	e0bfff15 	stw	r2,-4(fp)
 90939a4:	e0bfff17 	ldw	r2,-4(fp)
}
 90939a8:	e037883a 	mov	sp,fp
 90939ac:	dfc00117 	ldw	ra,4(sp)
 90939b0:	df000017 	ldw	fp,0(sp)
 90939b4:	dec00204 	addi	sp,sp,8
 90939b8:	f800283a 	ret

090939bc <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 90939bc:	defff104 	addi	sp,sp,-60
 90939c0:	dfc00e15 	stw	ra,56(sp)
 90939c4:	df000d15 	stw	fp,52(sp)
 90939c8:	df000d04 	addi	fp,sp,52
 90939cc:	e13ffb15 	stw	r4,-20(fp)
 90939d0:	e1bffd15 	stw	r6,-12(fp)
 90939d4:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 90939d8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 90939dc:	e0bffd17 	ldw	r2,-12(fp)
 90939e0:	1004c03a 	cmpne	r2,r2,zero
 90939e4:	1000031e 	bne	r2,zero,90939f4 <OSSemDel+0x38>
        return (pevent);
 90939e8:	e0bffb17 	ldw	r2,-20(fp)
 90939ec:	e0bfff15 	stw	r2,-4(fp)
 90939f0:	00009406 	br	9093c44 <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 90939f4:	e0bffb17 	ldw	r2,-20(fp)
 90939f8:	1004c03a 	cmpne	r2,r2,zero
 90939fc:	1000061e 	bne	r2,zero,9093a18 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 9093a00:	e0fffd17 	ldw	r3,-12(fp)
 9093a04:	00800104 	movi	r2,4
 9093a08:	18800005 	stb	r2,0(r3)
        return (pevent);
 9093a0c:	e0fffb17 	ldw	r3,-20(fp)
 9093a10:	e0ffff15 	stw	r3,-4(fp)
 9093a14:	00008b06 	br	9093c44 <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 9093a18:	e0bffb17 	ldw	r2,-20(fp)
 9093a1c:	10800003 	ldbu	r2,0(r2)
 9093a20:	10803fcc 	andi	r2,r2,255
 9093a24:	108000e0 	cmpeqi	r2,r2,3
 9093a28:	1000061e 	bne	r2,zero,9093a44 <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 9093a2c:	e0fffd17 	ldw	r3,-12(fp)
 9093a30:	00800044 	movi	r2,1
 9093a34:	18800005 	stb	r2,0(r3)
        return (pevent);
 9093a38:	e0bffb17 	ldw	r2,-20(fp)
 9093a3c:	e0bfff15 	stw	r2,-4(fp)
 9093a40:	00008006 	br	9093c44 <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 9093a44:	00824374 	movhi	r2,2317
 9093a48:	108eff04 	addi	r2,r2,15356
 9093a4c:	10800003 	ldbu	r2,0(r2)
 9093a50:	10803fcc 	andi	r2,r2,255
 9093a54:	1005003a 	cmpeq	r2,r2,zero
 9093a58:	1000061e 	bne	r2,zero,9093a74 <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 9093a5c:	e0fffd17 	ldw	r3,-12(fp)
 9093a60:	008003c4 	movi	r2,15
 9093a64:	18800005 	stb	r2,0(r3)
        return (pevent);
 9093a68:	e0fffb17 	ldw	r3,-20(fp)
 9093a6c:	e0ffff15 	stw	r3,-4(fp)
 9093a70:	00007406 	br	9093c44 <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093a74:	0005303a 	rdctl	r2,status
 9093a78:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093a7c:	e0fff717 	ldw	r3,-36(fp)
 9093a80:	00bfff84 	movi	r2,-2
 9093a84:	1884703a 	and	r2,r3,r2
 9093a88:	1001703a 	wrctl	status,r2
  
  return context;
 9093a8c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 9093a90:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 9093a94:	e0bffb17 	ldw	r2,-20(fp)
 9093a98:	10800283 	ldbu	r2,10(r2)
 9093a9c:	10803fcc 	andi	r2,r2,255
 9093aa0:	1005003a 	cmpeq	r2,r2,zero
 9093aa4:	1000031e 	bne	r2,zero,9093ab4 <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 9093aa8:	00800044 	movi	r2,1
 9093aac:	e0bffa05 	stb	r2,-24(fp)
 9093ab0:	00000106 	br	9093ab8 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 9093ab4:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 9093ab8:	e0bffc03 	ldbu	r2,-16(fp)
 9093abc:	e0bffe15 	stw	r2,-8(fp)
 9093ac0:	e0fffe17 	ldw	r3,-8(fp)
 9093ac4:	1805003a 	cmpeq	r2,r3,zero
 9093ac8:	1000041e 	bne	r2,zero,9093adc <OSSemDel+0x120>
 9093acc:	e0fffe17 	ldw	r3,-8(fp)
 9093ad0:	18800060 	cmpeqi	r2,r3,1
 9093ad4:	10002d1e 	bne	r2,zero,9093b8c <OSSemDel+0x1d0>
 9093ad8:	00004f06 	br	9093c18 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 9093adc:	e0bffa03 	ldbu	r2,-24(fp)
 9093ae0:	1004c03a 	cmpne	r2,r2,zero
 9093ae4:	10001a1e 	bne	r2,zero,9093b50 <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 9093ae8:	e0fffb17 	ldw	r3,-20(fp)
 9093aec:	00800fc4 	movi	r2,63
 9093af0:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 9093af4:	e0bffb17 	ldw	r2,-20(fp)
 9093af8:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9093afc:	e0bffb17 	ldw	r2,-20(fp)
 9093b00:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 9093b04:	00824374 	movhi	r2,2317
 9093b08:	108efe04 	addi	r2,r2,15352
 9093b0c:	10c00017 	ldw	r3,0(r2)
 9093b10:	e0bffb17 	ldw	r2,-20(fp)
 9093b14:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 9093b18:	e0bffb17 	ldw	r2,-20(fp)
 9093b1c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 9093b20:	00c24374 	movhi	r3,2317
 9093b24:	18cefe04 	addi	r3,r3,15352
 9093b28:	e0bffb17 	ldw	r2,-20(fp)
 9093b2c:	18800015 	stw	r2,0(r3)
 9093b30:	e0bff817 	ldw	r2,-32(fp)
 9093b34:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093b38:	e0bff617 	ldw	r2,-40(fp)
 9093b3c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 9093b40:	e0bffd17 	ldw	r2,-12(fp)
 9093b44:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 9093b48:	e03ff915 	stw	zero,-28(fp)
 9093b4c:	00003b06 	br	9093c3c <OSSemDel+0x280>
 9093b50:	e0bff817 	ldw	r2,-32(fp)
 9093b54:	e0bff515 	stw	r2,-44(fp)
 9093b58:	e0bff517 	ldw	r2,-44(fp)
 9093b5c:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 9093b60:	e0fffd17 	ldw	r3,-12(fp)
 9093b64:	00801244 	movi	r2,73
 9093b68:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 9093b6c:	e0bffb17 	ldw	r2,-20(fp)
 9093b70:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 9093b74:	00003106 	br	9093c3c <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 9093b78:	e13ffb17 	ldw	r4,-20(fp)
 9093b7c:	000b883a 	mov	r5,zero
 9093b80:	01800044 	movi	r6,1
 9093b84:	000f883a 	mov	r7,zero
 9093b88:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 9093b8c:	e0bffb17 	ldw	r2,-20(fp)
 9093b90:	10800283 	ldbu	r2,10(r2)
 9093b94:	10803fcc 	andi	r2,r2,255
 9093b98:	1004c03a 	cmpne	r2,r2,zero
 9093b9c:	103ff61e 	bne	r2,zero,9093b78 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 9093ba0:	e0fffb17 	ldw	r3,-20(fp)
 9093ba4:	00800fc4 	movi	r2,63
 9093ba8:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 9093bac:	e0bffb17 	ldw	r2,-20(fp)
 9093bb0:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 9093bb4:	e0bffb17 	ldw	r2,-20(fp)
 9093bb8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 9093bbc:	00824374 	movhi	r2,2317
 9093bc0:	108efe04 	addi	r2,r2,15352
 9093bc4:	10c00017 	ldw	r3,0(r2)
 9093bc8:	e0bffb17 	ldw	r2,-20(fp)
 9093bcc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 9093bd0:	e0bffb17 	ldw	r2,-20(fp)
 9093bd4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 9093bd8:	00c24374 	movhi	r3,2317
 9093bdc:	18cefe04 	addi	r3,r3,15352
 9093be0:	e0bffb17 	ldw	r2,-20(fp)
 9093be4:	18800015 	stw	r2,0(r3)
 9093be8:	e0bff817 	ldw	r2,-32(fp)
 9093bec:	e0bff415 	stw	r2,-48(fp)
 9093bf0:	e0bff417 	ldw	r2,-48(fp)
 9093bf4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 9093bf8:	e0bffa03 	ldbu	r2,-24(fp)
 9093bfc:	10800058 	cmpnei	r2,r2,1
 9093c00:	1000011e 	bne	r2,zero,9093c08 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 9093c04:	908fae40 	call	908fae4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 9093c08:	e0bffd17 	ldw	r2,-12(fp)
 9093c0c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 9093c10:	e03ff915 	stw	zero,-28(fp)
             break;
 9093c14:	00000906 	br	9093c3c <OSSemDel+0x280>
 9093c18:	e0bff817 	ldw	r2,-32(fp)
 9093c1c:	e0bff315 	stw	r2,-52(fp)
 9093c20:	e0bff317 	ldw	r2,-52(fp)
 9093c24:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 9093c28:	e0fffd17 	ldw	r3,-12(fp)
 9093c2c:	008001c4 	movi	r2,7
 9093c30:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 9093c34:	e0bffb17 	ldw	r2,-20(fp)
 9093c38:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 9093c3c:	e0bff917 	ldw	r2,-28(fp)
 9093c40:	e0bfff15 	stw	r2,-4(fp)
 9093c44:	e0bfff17 	ldw	r2,-4(fp)
}
 9093c48:	e037883a 	mov	sp,fp
 9093c4c:	dfc00117 	ldw	ra,4(sp)
 9093c50:	df000017 	ldw	fp,0(sp)
 9093c54:	dec00204 	addi	sp,sp,8
 9093c58:	f800283a 	ret

09093c5c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 9093c5c:	defff404 	addi	sp,sp,-48
 9093c60:	dfc00b15 	stw	ra,44(sp)
 9093c64:	df000a15 	stw	fp,40(sp)
 9093c68:	df000a04 	addi	fp,sp,40
 9093c6c:	e13ffc15 	stw	r4,-16(fp)
 9093c70:	e1bffe15 	stw	r6,-8(fp)
 9093c74:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9093c78:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9093c7c:	e0bffe17 	ldw	r2,-8(fp)
 9093c80:	1005003a 	cmpeq	r2,r2,zero
 9093c84:	10008f1e 	bne	r2,zero,9093ec4 <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9093c88:	e0bffc17 	ldw	r2,-16(fp)
 9093c8c:	1004c03a 	cmpne	r2,r2,zero
 9093c90:	1000041e 	bne	r2,zero,9093ca4 <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 9093c94:	e0fffe17 	ldw	r3,-8(fp)
 9093c98:	00800104 	movi	r2,4
 9093c9c:	18800005 	stb	r2,0(r3)
        return;
 9093ca0:	00008806 	br	9093ec4 <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9093ca4:	e0bffc17 	ldw	r2,-16(fp)
 9093ca8:	10800003 	ldbu	r2,0(r2)
 9093cac:	10803fcc 	andi	r2,r2,255
 9093cb0:	108000e0 	cmpeqi	r2,r2,3
 9093cb4:	1000041e 	bne	r2,zero,9093cc8 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 9093cb8:	e0fffe17 	ldw	r3,-8(fp)
 9093cbc:	00800044 	movi	r2,1
 9093cc0:	18800005 	stb	r2,0(r3)
        return;
 9093cc4:	00007f06 	br	9093ec4 <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 9093cc8:	00824374 	movhi	r2,2317
 9093ccc:	108eff04 	addi	r2,r2,15356
 9093cd0:	10800003 	ldbu	r2,0(r2)
 9093cd4:	10803fcc 	andi	r2,r2,255
 9093cd8:	1005003a 	cmpeq	r2,r2,zero
 9093cdc:	1000041e 	bne	r2,zero,9093cf0 <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 9093ce0:	e0fffe17 	ldw	r3,-8(fp)
 9093ce4:	00800084 	movi	r2,2
 9093ce8:	18800005 	stb	r2,0(r3)
        return;
 9093cec:	00007506 	br	9093ec4 <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 9093cf0:	00824374 	movhi	r2,2317
 9093cf4:	108ef104 	addi	r2,r2,15300
 9093cf8:	10800003 	ldbu	r2,0(r2)
 9093cfc:	10803fcc 	andi	r2,r2,255
 9093d00:	1005003a 	cmpeq	r2,r2,zero
 9093d04:	1000041e 	bne	r2,zero,9093d18 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 9093d08:	e0fffe17 	ldw	r3,-8(fp)
 9093d0c:	00800344 	movi	r2,13
 9093d10:	18800005 	stb	r2,0(r3)
        return;
 9093d14:	00006b06 	br	9093ec4 <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093d18:	0005303a 	rdctl	r2,status
 9093d1c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093d20:	e0fffa17 	ldw	r3,-24(fp)
 9093d24:	00bfff84 	movi	r2,-2
 9093d28:	1884703a 	and	r2,r3,r2
 9093d2c:	1001703a 	wrctl	status,r2
  
  return context;
 9093d30:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 9093d34:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 9093d38:	e0bffc17 	ldw	r2,-16(fp)
 9093d3c:	1080020b 	ldhu	r2,8(r2)
 9093d40:	10bfffcc 	andi	r2,r2,65535
 9093d44:	1005003a 	cmpeq	r2,r2,zero
 9093d48:	10000d1e 	bne	r2,zero,9093d80 <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 9093d4c:	e0bffc17 	ldw	r2,-16(fp)
 9093d50:	1080020b 	ldhu	r2,8(r2)
 9093d54:	10bfffc4 	addi	r2,r2,-1
 9093d58:	1007883a 	mov	r3,r2
 9093d5c:	e0bffc17 	ldw	r2,-16(fp)
 9093d60:	10c0020d 	sth	r3,8(r2)
 9093d64:	e0bffb17 	ldw	r2,-20(fp)
 9093d68:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093d6c:	e0bff917 	ldw	r2,-28(fp)
 9093d70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 9093d74:	e0bffe17 	ldw	r2,-8(fp)
 9093d78:	10000005 	stb	zero,0(r2)
        return;
 9093d7c:	00005106 	br	9093ec4 <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 9093d80:	00824374 	movhi	r2,2317
 9093d84:	108f0004 	addi	r2,r2,15360
 9093d88:	10c00017 	ldw	r3,0(r2)
 9093d8c:	00824374 	movhi	r2,2317
 9093d90:	108f0004 	addi	r2,r2,15360
 9093d94:	10800017 	ldw	r2,0(r2)
 9093d98:	10800c03 	ldbu	r2,48(r2)
 9093d9c:	10800054 	ori	r2,r2,1
 9093da0:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 9093da4:	00824374 	movhi	r2,2317
 9093da8:	108f0004 	addi	r2,r2,15360
 9093dac:	10800017 	ldw	r2,0(r2)
 9093db0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 9093db4:	00824374 	movhi	r2,2317
 9093db8:	108f0004 	addi	r2,r2,15360
 9093dbc:	10c00017 	ldw	r3,0(r2)
 9093dc0:	e0bffd0b 	ldhu	r2,-12(fp)
 9093dc4:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 9093dc8:	e13ffc17 	ldw	r4,-16(fp)
 9093dcc:	908f2380 	call	908f238 <OS_EventTaskWait>
 9093dd0:	e0bffb17 	ldw	r2,-20(fp)
 9093dd4:	e0bff815 	stw	r2,-32(fp)
 9093dd8:	e0bff817 	ldw	r2,-32(fp)
 9093ddc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 9093de0:	908fae40 	call	908fae4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093de4:	0005303a 	rdctl	r2,status
 9093de8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093dec:	e0fff717 	ldw	r3,-36(fp)
 9093df0:	00bfff84 	movi	r2,-2
 9093df4:	1884703a 	and	r2,r3,r2
 9093df8:	1001703a 	wrctl	status,r2
  
  return context;
 9093dfc:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 9093e00:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 9093e04:	00824374 	movhi	r2,2317
 9093e08:	108f0004 	addi	r2,r2,15360
 9093e0c:	10800017 	ldw	r2,0(r2)
 9093e10:	10800c43 	ldbu	r2,49(r2)
 9093e14:	10803fcc 	andi	r2,r2,255
 9093e18:	e0bfff15 	stw	r2,-4(fp)
 9093e1c:	e0ffff17 	ldw	r3,-4(fp)
 9093e20:	1805003a 	cmpeq	r2,r3,zero
 9093e24:	1000041e 	bne	r2,zero,9093e38 <OSSemPend+0x1dc>
 9093e28:	e0ffff17 	ldw	r3,-4(fp)
 9093e2c:	188000a0 	cmpeqi	r2,r3,2
 9093e30:	1000041e 	bne	r2,zero,9093e44 <OSSemPend+0x1e8>
 9093e34:	00000706 	br	9093e54 <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 9093e38:	e0bffe17 	ldw	r2,-8(fp)
 9093e3c:	10000005 	stb	zero,0(r2)
             break;
 9093e40:	00000c06 	br	9093e74 <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 9093e44:	e0fffe17 	ldw	r3,-8(fp)
 9093e48:	00800384 	movi	r2,14
 9093e4c:	18800005 	stb	r2,0(r3)
             break;
 9093e50:	00000806 	br	9093e74 <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 9093e54:	00824374 	movhi	r2,2317
 9093e58:	108f0004 	addi	r2,r2,15360
 9093e5c:	11000017 	ldw	r4,0(r2)
 9093e60:	e17ffc17 	ldw	r5,-16(fp)
 9093e64:	908f49c0 	call	908f49c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 9093e68:	e0fffe17 	ldw	r3,-8(fp)
 9093e6c:	00800284 	movi	r2,10
 9093e70:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 9093e74:	00824374 	movhi	r2,2317
 9093e78:	108f0004 	addi	r2,r2,15360
 9093e7c:	10800017 	ldw	r2,0(r2)
 9093e80:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 9093e84:	00824374 	movhi	r2,2317
 9093e88:	108f0004 	addi	r2,r2,15360
 9093e8c:	10800017 	ldw	r2,0(r2)
 9093e90:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 9093e94:	00824374 	movhi	r2,2317
 9093e98:	108f0004 	addi	r2,r2,15360
 9093e9c:	10800017 	ldw	r2,0(r2)
 9093ea0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 9093ea4:	00824374 	movhi	r2,2317
 9093ea8:	108f0004 	addi	r2,r2,15360
 9093eac:	10800017 	ldw	r2,0(r2)
 9093eb0:	10000815 	stw	zero,32(r2)
 9093eb4:	e0bffb17 	ldw	r2,-20(fp)
 9093eb8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093ebc:	e0bff617 	ldw	r2,-40(fp)
 9093ec0:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 9093ec4:	e037883a 	mov	sp,fp
 9093ec8:	dfc00117 	ldw	ra,4(sp)
 9093ecc:	df000017 	ldw	fp,0(sp)
 9093ed0:	dec00204 	addi	sp,sp,8
 9093ed4:	f800283a 	ret

09093ed8 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 9093ed8:	defff504 	addi	sp,sp,-44
 9093edc:	dfc00a15 	stw	ra,40(sp)
 9093ee0:	df000915 	stw	fp,36(sp)
 9093ee4:	df000904 	addi	fp,sp,36
 9093ee8:	e13ffc15 	stw	r4,-16(fp)
 9093eec:	e1bffe15 	stw	r6,-8(fp)
 9093ef0:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9093ef4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 9093ef8:	e0bffe17 	ldw	r2,-8(fp)
 9093efc:	1004c03a 	cmpne	r2,r2,zero
 9093f00:	1000021e 	bne	r2,zero,9093f0c <OSSemPendAbort+0x34>
        return (0);
 9093f04:	e03fff15 	stw	zero,-4(fp)
 9093f08:	00004c06 	br	909403c <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 9093f0c:	e0bffc17 	ldw	r2,-16(fp)
 9093f10:	1004c03a 	cmpne	r2,r2,zero
 9093f14:	1000051e 	bne	r2,zero,9093f2c <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 9093f18:	e0fffe17 	ldw	r3,-8(fp)
 9093f1c:	00800104 	movi	r2,4
 9093f20:	18800005 	stb	r2,0(r3)
        return (0);
 9093f24:	e03fff15 	stw	zero,-4(fp)
 9093f28:	00004406 	br	909403c <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9093f2c:	e0bffc17 	ldw	r2,-16(fp)
 9093f30:	10800003 	ldbu	r2,0(r2)
 9093f34:	10803fcc 	andi	r2,r2,255
 9093f38:	108000e0 	cmpeqi	r2,r2,3
 9093f3c:	1000051e 	bne	r2,zero,9093f54 <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 9093f40:	e0fffe17 	ldw	r3,-8(fp)
 9093f44:	00800044 	movi	r2,1
 9093f48:	18800005 	stb	r2,0(r3)
        return (0);
 9093f4c:	e03fff15 	stw	zero,-4(fp)
 9093f50:	00003a06 	br	909403c <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9093f54:	0005303a 	rdctl	r2,status
 9093f58:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9093f5c:	e0fff917 	ldw	r3,-28(fp)
 9093f60:	00bfff84 	movi	r2,-2
 9093f64:	1884703a 	and	r2,r3,r2
 9093f68:	1001703a 	wrctl	status,r2
  
  return context;
 9093f6c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 9093f70:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 9093f74:	e0bffc17 	ldw	r2,-16(fp)
 9093f78:	10800283 	ldbu	r2,10(r2)
 9093f7c:	10803fcc 	andi	r2,r2,255
 9093f80:	1005003a 	cmpeq	r2,r2,zero
 9093f84:	1000261e 	bne	r2,zero,9094020 <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 9093f88:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 9093f8c:	e0bffd03 	ldbu	r2,-12(fp)
 9093f90:	10800060 	cmpeqi	r2,r2,1
 9093f94:	1000091e 	bne	r2,zero,9093fbc <OSSemPendAbort+0xe4>
 9093f98:	00000e06 	br	9093fd4 <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 9093f9c:	e13ffc17 	ldw	r4,-16(fp)
 9093fa0:	000b883a 	mov	r5,zero
 9093fa4:	01800044 	movi	r6,1
 9093fa8:	01c00084 	movi	r7,2
 9093fac:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                     nbr_tasks++;
 9093fb0:	e0bffb03 	ldbu	r2,-20(fp)
 9093fb4:	10800044 	addi	r2,r2,1
 9093fb8:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 9093fbc:	e0bffc17 	ldw	r2,-16(fp)
 9093fc0:	10800283 	ldbu	r2,10(r2)
 9093fc4:	10803fcc 	andi	r2,r2,255
 9093fc8:	1004c03a 	cmpne	r2,r2,zero
 9093fcc:	103ff31e 	bne	r2,zero,9093f9c <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 9093fd0:	00000806 	br	9093ff4 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 9093fd4:	e13ffc17 	ldw	r4,-16(fp)
 9093fd8:	000b883a 	mov	r5,zero
 9093fdc:	01800044 	movi	r6,1
 9093fe0:	01c00084 	movi	r7,2
 9093fe4:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
                 nbr_tasks++;
 9093fe8:	e0bffb03 	ldbu	r2,-20(fp)
 9093fec:	10800044 	addi	r2,r2,1
 9093ff0:	e0bffb05 	stb	r2,-20(fp)
 9093ff4:	e0bffa17 	ldw	r2,-24(fp)
 9093ff8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9093ffc:	e0bff817 	ldw	r2,-32(fp)
 9094000:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 9094004:	908fae40 	call	908fae4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 9094008:	e0fffe17 	ldw	r3,-8(fp)
 909400c:	00800384 	movi	r2,14
 9094010:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 9094014:	e0bffb03 	ldbu	r2,-20(fp)
 9094018:	e0bfff15 	stw	r2,-4(fp)
 909401c:	00000706 	br	909403c <OSSemPendAbort+0x164>
 9094020:	e0bffa17 	ldw	r2,-24(fp)
 9094024:	e0bff715 	stw	r2,-36(fp)
 9094028:	e0bff717 	ldw	r2,-36(fp)
 909402c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9094030:	e0bffe17 	ldw	r2,-8(fp)
 9094034:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 9094038:	e03fff15 	stw	zero,-4(fp)
 909403c:	e0bfff17 	ldw	r2,-4(fp)
}
 9094040:	e037883a 	mov	sp,fp
 9094044:	dfc00117 	ldw	ra,4(sp)
 9094048:	df000017 	ldw	fp,0(sp)
 909404c:	dec00204 	addi	sp,sp,8
 9094050:	f800283a 	ret

09094054 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 9094054:	defff704 	addi	sp,sp,-36
 9094058:	dfc00815 	stw	ra,32(sp)
 909405c:	df000715 	stw	fp,28(sp)
 9094060:	df000704 	addi	fp,sp,28
 9094064:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9094068:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 909406c:	e0bffe17 	ldw	r2,-8(fp)
 9094070:	1004c03a 	cmpne	r2,r2,zero
 9094074:	1000031e 	bne	r2,zero,9094084 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 9094078:	00800104 	movi	r2,4
 909407c:	e0bfff15 	stw	r2,-4(fp)
 9094080:	00003806 	br	9094164 <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 9094084:	e0bffe17 	ldw	r2,-8(fp)
 9094088:	10800003 	ldbu	r2,0(r2)
 909408c:	10803fcc 	andi	r2,r2,255
 9094090:	108000e0 	cmpeqi	r2,r2,3
 9094094:	1000031e 	bne	r2,zero,90940a4 <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 9094098:	00800044 	movi	r2,1
 909409c:	e0bfff15 	stw	r2,-4(fp)
 90940a0:	00003006 	br	9094164 <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90940a4:	0005303a 	rdctl	r2,status
 90940a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90940ac:	e0fffc17 	ldw	r3,-16(fp)
 90940b0:	00bfff84 	movi	r2,-2
 90940b4:	1884703a 	and	r2,r3,r2
 90940b8:	1001703a 	wrctl	status,r2
  
  return context;
 90940bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 90940c0:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 90940c4:	e0bffe17 	ldw	r2,-8(fp)
 90940c8:	10800283 	ldbu	r2,10(r2)
 90940cc:	10803fcc 	andi	r2,r2,255
 90940d0:	1005003a 	cmpeq	r2,r2,zero
 90940d4:	10000c1e 	bne	r2,zero,9094108 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 90940d8:	e13ffe17 	ldw	r4,-8(fp)
 90940dc:	000b883a 	mov	r5,zero
 90940e0:	01800044 	movi	r6,1
 90940e4:	000f883a 	mov	r7,zero
 90940e8:	908f0a40 	call	908f0a4 <OS_EventTaskRdy>
 90940ec:	e0bffd17 	ldw	r2,-12(fp)
 90940f0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90940f4:	e0bffb17 	ldw	r2,-20(fp)
 90940f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 90940fc:	908fae40 	call	908fae4 <OS_Sched>
        return (OS_ERR_NONE);
 9094100:	e03fff15 	stw	zero,-4(fp)
 9094104:	00001706 	br	9094164 <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 9094108:	e0bffe17 	ldw	r2,-8(fp)
 909410c:	1080020b 	ldhu	r2,8(r2)
 9094110:	10ffffcc 	andi	r3,r2,65535
 9094114:	00bfffd4 	movui	r2,65535
 9094118:	18800c26 	beq	r3,r2,909414c <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 909411c:	e0bffe17 	ldw	r2,-8(fp)
 9094120:	1080020b 	ldhu	r2,8(r2)
 9094124:	10800044 	addi	r2,r2,1
 9094128:	1007883a 	mov	r3,r2
 909412c:	e0bffe17 	ldw	r2,-8(fp)
 9094130:	10c0020d 	sth	r3,8(r2)
 9094134:	e0bffd17 	ldw	r2,-12(fp)
 9094138:	e0bffa15 	stw	r2,-24(fp)
 909413c:	e0bffa17 	ldw	r2,-24(fp)
 9094140:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 9094144:	e03fff15 	stw	zero,-4(fp)
 9094148:	00000606 	br	9094164 <OSSemPost+0x110>
 909414c:	e0bffd17 	ldw	r2,-12(fp)
 9094150:	e0bff915 	stw	r2,-28(fp)
 9094154:	e0bff917 	ldw	r2,-28(fp)
 9094158:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 909415c:	00800c84 	movi	r2,50
 9094160:	e0bfff15 	stw	r2,-4(fp)
 9094164:	e0bfff17 	ldw	r2,-4(fp)
}
 9094168:	e037883a 	mov	sp,fp
 909416c:	dfc00117 	ldw	ra,4(sp)
 9094170:	df000017 	ldw	fp,0(sp)
 9094174:	dec00204 	addi	sp,sp,8
 9094178:	f800283a 	ret

0909417c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 909417c:	defff604 	addi	sp,sp,-40
 9094180:	df000915 	stw	fp,36(sp)
 9094184:	df000904 	addi	fp,sp,36
 9094188:	e13ffd15 	stw	r4,-12(fp)
 909418c:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 9094190:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 9094194:	e0bffd17 	ldw	r2,-12(fp)
 9094198:	1004c03a 	cmpne	r2,r2,zero
 909419c:	1000031e 	bne	r2,zero,90941ac <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 90941a0:	00800104 	movi	r2,4
 90941a4:	e0bfff15 	stw	r2,-4(fp)
 90941a8:	00003b06 	br	9094298 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 90941ac:	e0bffe17 	ldw	r2,-8(fp)
 90941b0:	1004c03a 	cmpne	r2,r2,zero
 90941b4:	1000031e 	bne	r2,zero,90941c4 <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 90941b8:	00800244 	movi	r2,9
 90941bc:	e0bfff15 	stw	r2,-4(fp)
 90941c0:	00003506 	br	9094298 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 90941c4:	e0bffd17 	ldw	r2,-12(fp)
 90941c8:	10800003 	ldbu	r2,0(r2)
 90941cc:	10803fcc 	andi	r2,r2,255
 90941d0:	108000e0 	cmpeqi	r2,r2,3
 90941d4:	1000031e 	bne	r2,zero,90941e4 <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 90941d8:	00800044 	movi	r2,1
 90941dc:	e0bfff15 	stw	r2,-4(fp)
 90941e0:	00002d06 	br	9094298 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90941e4:	0005303a 	rdctl	r2,status
 90941e8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90941ec:	e0fff817 	ldw	r3,-32(fp)
 90941f0:	00bfff84 	movi	r2,-2
 90941f4:	1884703a 	and	r2,r3,r2
 90941f8:	1001703a 	wrctl	status,r2
  
  return context;
 90941fc:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 9094200:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 9094204:	e0bffd17 	ldw	r2,-12(fp)
 9094208:	10c00283 	ldbu	r3,10(r2)
 909420c:	e0bffe17 	ldw	r2,-8(fp)
 9094210:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 9094214:	e0bffd17 	ldw	r2,-12(fp)
 9094218:	108002c4 	addi	r2,r2,11
 909421c:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 9094220:	e0bffe17 	ldw	r2,-8(fp)
 9094224:	10800084 	addi	r2,r2,2
 9094228:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909422c:	e03ffa05 	stb	zero,-24(fp)
 9094230:	00000d06 	br	9094268 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 9094234:	e0bffc17 	ldw	r2,-16(fp)
 9094238:	10c00003 	ldbu	r3,0(r2)
 909423c:	e0bffb17 	ldw	r2,-20(fp)
 9094240:	10c00005 	stb	r3,0(r2)
 9094244:	e0bffb17 	ldw	r2,-20(fp)
 9094248:	10800044 	addi	r2,r2,1
 909424c:	e0bffb15 	stw	r2,-20(fp)
 9094250:	e0bffc17 	ldw	r2,-16(fp)
 9094254:	10800044 	addi	r2,r2,1
 9094258:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 909425c:	e0bffa03 	ldbu	r2,-24(fp)
 9094260:	10800044 	addi	r2,r2,1
 9094264:	e0bffa05 	stb	r2,-24(fp)
 9094268:	e0bffa03 	ldbu	r2,-24(fp)
 909426c:	108000f0 	cmpltui	r2,r2,3
 9094270:	103ff01e 	bne	r2,zero,9094234 <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 9094274:	e0bffd17 	ldw	r2,-12(fp)
 9094278:	10c0020b 	ldhu	r3,8(r2)
 909427c:	e0bffe17 	ldw	r2,-8(fp)
 9094280:	10c0000d 	sth	r3,0(r2)
 9094284:	e0bff917 	ldw	r2,-28(fp)
 9094288:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909428c:	e0bff717 	ldw	r2,-36(fp)
 9094290:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9094294:	e03fff15 	stw	zero,-4(fp)
 9094298:	e0bfff17 	ldw	r2,-4(fp)
}
 909429c:	e037883a 	mov	sp,fp
 90942a0:	df000017 	ldw	fp,0(sp)
 90942a4:	dec00104 	addi	sp,sp,4
 90942a8:	f800283a 	ret

090942ac <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 90942ac:	defff904 	addi	sp,sp,-28
 90942b0:	df000615 	stw	fp,24(sp)
 90942b4:	df000604 	addi	fp,sp,24
 90942b8:	e13ffd15 	stw	r4,-12(fp)
 90942bc:	e1bfff15 	stw	r6,-4(fp)
 90942c0:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 90942c4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 90942c8:	e0bfff17 	ldw	r2,-4(fp)
 90942cc:	1005003a 	cmpeq	r2,r2,zero
 90942d0:	1000331e 	bne	r2,zero,90943a0 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 90942d4:	e0bffd17 	ldw	r2,-12(fp)
 90942d8:	1004c03a 	cmpne	r2,r2,zero
 90942dc:	1000041e 	bne	r2,zero,90942f0 <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 90942e0:	e0ffff17 	ldw	r3,-4(fp)
 90942e4:	00800104 	movi	r2,4
 90942e8:	18800005 	stb	r2,0(r3)
        return;
 90942ec:	00002c06 	br	90943a0 <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 90942f0:	e0bffd17 	ldw	r2,-12(fp)
 90942f4:	10800003 	ldbu	r2,0(r2)
 90942f8:	10803fcc 	andi	r2,r2,255
 90942fc:	108000e0 	cmpeqi	r2,r2,3
 9094300:	1000041e 	bne	r2,zero,9094314 <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 9094304:	e0ffff17 	ldw	r3,-4(fp)
 9094308:	00800044 	movi	r2,1
 909430c:	18800005 	stb	r2,0(r3)
        return;
 9094310:	00002306 	br	90943a0 <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094314:	0005303a 	rdctl	r2,status
 9094318:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909431c:	e0fffb17 	ldw	r3,-20(fp)
 9094320:	00bfff84 	movi	r2,-2
 9094324:	1884703a 	and	r2,r3,r2
 9094328:	1001703a 	wrctl	status,r2
  
  return context;
 909432c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 9094330:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 9094334:	e0bfff17 	ldw	r2,-4(fp)
 9094338:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 909433c:	e0bffd17 	ldw	r2,-12(fp)
 9094340:	1080020b 	ldhu	r2,8(r2)
 9094344:	10bfffcc 	andi	r2,r2,65535
 9094348:	1005003a 	cmpeq	r2,r2,zero
 909434c:	1000041e 	bne	r2,zero,9094360 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 9094350:	e0fffd17 	ldw	r3,-12(fp)
 9094354:	e0bffe0b 	ldhu	r2,-8(fp)
 9094358:	1880020d 	sth	r2,8(r3)
 909435c:	00000c06 	br	9094390 <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 9094360:	e0bffd17 	ldw	r2,-12(fp)
 9094364:	10800283 	ldbu	r2,10(r2)
 9094368:	10803fcc 	andi	r2,r2,255
 909436c:	1004c03a 	cmpne	r2,r2,zero
 9094370:	1000041e 	bne	r2,zero,9094384 <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 9094374:	e0fffd17 	ldw	r3,-12(fp)
 9094378:	e0bffe0b 	ldhu	r2,-8(fp)
 909437c:	1880020d 	sth	r2,8(r3)
 9094380:	00000306 	br	9094390 <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 9094384:	e0ffff17 	ldw	r3,-4(fp)
 9094388:	00801244 	movi	r2,73
 909438c:	18800005 	stb	r2,0(r3)
 9094390:	e0bffc17 	ldw	r2,-16(fp)
 9094394:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094398:	e0bffa17 	ldw	r2,-24(fp)
 909439c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 90943a0:	e037883a 	mov	sp,fp
 90943a4:	df000017 	ldw	fp,0(sp)
 90943a8:	dec00104 	addi	sp,sp,4
 90943ac:	f800283a 	ret

090943b0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 90943b0:	defff004 	addi	sp,sp,-64
 90943b4:	dfc00f15 	stw	ra,60(sp)
 90943b8:	df000e15 	stw	fp,56(sp)
 90943bc:	df000e04 	addi	fp,sp,56
 90943c0:	e13ffd05 	stb	r4,-12(fp)
 90943c4:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 90943c8:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 90943cc:	e0bffd03 	ldbu	r2,-12(fp)
 90943d0:	10800530 	cmpltui	r2,r2,20
 90943d4:	1000061e 	bne	r2,zero,90943f0 <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 90943d8:	e0bffd03 	ldbu	r2,-12(fp)
 90943dc:	10803fe0 	cmpeqi	r2,r2,255
 90943e0:	1000031e 	bne	r2,zero,90943f0 <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 90943e4:	00800a84 	movi	r2,42
 90943e8:	e0bfff15 	stw	r2,-4(fp)
 90943ec:	00014706 	br	909490c <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 90943f0:	e0bffe03 	ldbu	r2,-8(fp)
 90943f4:	10800530 	cmpltui	r2,r2,20
 90943f8:	1000031e 	bne	r2,zero,9094408 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 90943fc:	00800a84 	movi	r2,42
 9094400:	e0bfff15 	stw	r2,-4(fp)
 9094404:	00014106 	br	909490c <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094408:	0005303a 	rdctl	r2,status
 909440c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094410:	e0fff617 	ldw	r3,-40(fp)
 9094414:	00bfff84 	movi	r2,-2
 9094418:	1884703a 	and	r2,r3,r2
 909441c:	1001703a 	wrctl	status,r2
  
  return context;
 9094420:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9094424:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 9094428:	e0bffe03 	ldbu	r2,-8(fp)
 909442c:	00c243b4 	movhi	r3,2318
 9094430:	18f47404 	addi	r3,r3,-11824
 9094434:	1085883a 	add	r2,r2,r2
 9094438:	1085883a 	add	r2,r2,r2
 909443c:	10c5883a 	add	r2,r2,r3
 9094440:	10800017 	ldw	r2,0(r2)
 9094444:	1005003a 	cmpeq	r2,r2,zero
 9094448:	1000071e 	bne	r2,zero,9094468 <OSTaskChangePrio+0xb8>
 909444c:	e0bff717 	ldw	r2,-36(fp)
 9094450:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094454:	e0bff517 	ldw	r2,-44(fp)
 9094458:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 909445c:	00800a04 	movi	r2,40
 9094460:	e0bfff15 	stw	r2,-4(fp)
 9094464:	00012906 	br	909490c <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 9094468:	e0bffd03 	ldbu	r2,-12(fp)
 909446c:	10803fd8 	cmpnei	r2,r2,255
 9094470:	1000051e 	bne	r2,zero,9094488 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 9094474:	00824374 	movhi	r2,2317
 9094478:	108f0004 	addi	r2,r2,15360
 909447c:	10800017 	ldw	r2,0(r2)
 9094480:	10800c83 	ldbu	r2,50(r2)
 9094484:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 9094488:	e0bffd03 	ldbu	r2,-12(fp)
 909448c:	00c243b4 	movhi	r3,2318
 9094490:	18f47404 	addi	r3,r3,-11824
 9094494:	1085883a 	add	r2,r2,r2
 9094498:	1085883a 	add	r2,r2,r2
 909449c:	10c5883a 	add	r2,r2,r3
 90944a0:	10800017 	ldw	r2,0(r2)
 90944a4:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 90944a8:	e0bffa17 	ldw	r2,-24(fp)
 90944ac:	1004c03a 	cmpne	r2,r2,zero
 90944b0:	1000071e 	bne	r2,zero,90944d0 <OSTaskChangePrio+0x120>
 90944b4:	e0bff717 	ldw	r2,-36(fp)
 90944b8:	e0bff415 	stw	r2,-48(fp)
 90944bc:	e0bff417 	ldw	r2,-48(fp)
 90944c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 90944c4:	00800a44 	movi	r2,41
 90944c8:	e0bfff15 	stw	r2,-4(fp)
 90944cc:	00010f06 	br	909490c <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 90944d0:	e0bffa17 	ldw	r2,-24(fp)
 90944d4:	10800058 	cmpnei	r2,r2,1
 90944d8:	1000071e 	bne	r2,zero,90944f8 <OSTaskChangePrio+0x148>
 90944dc:	e0bff717 	ldw	r2,-36(fp)
 90944e0:	e0bff315 	stw	r2,-52(fp)
 90944e4:	e0bff317 	ldw	r2,-52(fp)
 90944e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 90944ec:	008010c4 	movi	r2,67
 90944f0:	e0bfff15 	stw	r2,-4(fp)
 90944f4:	00010506 	br	909490c <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 90944f8:	e0bffe03 	ldbu	r2,-8(fp)
 90944fc:	1004d0fa 	srli	r2,r2,3
 9094500:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 9094504:	e0bffe03 	ldbu	r2,-8(fp)
 9094508:	108001cc 	andi	r2,r2,7
 909450c:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 9094510:	e0fff983 	ldbu	r3,-26(fp)
 9094514:	00800044 	movi	r2,1
 9094518:	10c4983a 	sll	r2,r2,r3
 909451c:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 9094520:	e0fff943 	ldbu	r3,-27(fp)
 9094524:	00800044 	movi	r2,1
 9094528:	10c4983a 	sll	r2,r2,r3
 909452c:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 9094530:	e0bffd03 	ldbu	r2,-12(fp)
 9094534:	00c243b4 	movhi	r3,2318
 9094538:	18f47404 	addi	r3,r3,-11824
 909453c:	1085883a 	add	r2,r2,r2
 9094540:	1085883a 	add	r2,r2,r2
 9094544:	10c5883a 	add	r2,r2,r3
 9094548:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 909454c:	e0bffe03 	ldbu	r2,-8(fp)
 9094550:	00c243b4 	movhi	r3,2318
 9094554:	18f47404 	addi	r3,r3,-11824
 9094558:	1085883a 	add	r2,r2,r2
 909455c:	1085883a 	add	r2,r2,r2
 9094560:	10c7883a 	add	r3,r2,r3
 9094564:	e0bffa17 	ldw	r2,-24(fp)
 9094568:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 909456c:	e0bffa17 	ldw	r2,-24(fp)
 9094570:	10800d03 	ldbu	r2,52(r2)
 9094574:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 9094578:	e0bffa17 	ldw	r2,-24(fp)
 909457c:	10800d83 	ldbu	r2,54(r2)
 9094580:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 9094584:	e0bffa17 	ldw	r2,-24(fp)
 9094588:	10800d43 	ldbu	r2,53(r2)
 909458c:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 9094590:	e0fff903 	ldbu	r3,-28(fp)
 9094594:	00824374 	movhi	r2,2317
 9094598:	108efd44 	addi	r2,r2,15349
 909459c:	10c5883a 	add	r2,r2,r3
 90945a0:	10c00003 	ldbu	r3,0(r2)
 90945a4:	e0bff803 	ldbu	r2,-32(fp)
 90945a8:	1884703a 	and	r2,r3,r2
 90945ac:	10803fcc 	andi	r2,r2,255
 90945b0:	1005003a 	cmpeq	r2,r2,zero
 90945b4:	1000381e 	bne	r2,zero,9094698 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 90945b8:	e13ff903 	ldbu	r4,-28(fp)
 90945bc:	e0fff903 	ldbu	r3,-28(fp)
 90945c0:	00824374 	movhi	r2,2317
 90945c4:	108efd44 	addi	r2,r2,15349
 90945c8:	10c5883a 	add	r2,r2,r3
 90945cc:	10800003 	ldbu	r2,0(r2)
 90945d0:	1007883a 	mov	r3,r2
 90945d4:	e0bff803 	ldbu	r2,-32(fp)
 90945d8:	0084303a 	nor	r2,zero,r2
 90945dc:	1884703a 	and	r2,r3,r2
 90945e0:	1007883a 	mov	r3,r2
 90945e4:	00824374 	movhi	r2,2317
 90945e8:	108efd44 	addi	r2,r2,15349
 90945ec:	1105883a 	add	r2,r2,r4
 90945f0:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 90945f4:	e0fff903 	ldbu	r3,-28(fp)
 90945f8:	00824374 	movhi	r2,2317
 90945fc:	108efd44 	addi	r2,r2,15349
 9094600:	10c5883a 	add	r2,r2,r3
 9094604:	10800003 	ldbu	r2,0(r2)
 9094608:	10803fcc 	andi	r2,r2,255
 909460c:	1004c03a 	cmpne	r2,r2,zero
 9094610:	10000b1e 	bne	r2,zero,9094640 <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 9094614:	e0bff843 	ldbu	r2,-31(fp)
 9094618:	0084303a 	nor	r2,zero,r2
 909461c:	1007883a 	mov	r3,r2
 9094620:	00824374 	movhi	r2,2317
 9094624:	108efd04 	addi	r2,r2,15348
 9094628:	10800003 	ldbu	r2,0(r2)
 909462c:	1884703a 	and	r2,r3,r2
 9094630:	1007883a 	mov	r3,r2
 9094634:	00824374 	movhi	r2,2317
 9094638:	108efd04 	addi	r2,r2,15348
 909463c:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 9094640:	00824374 	movhi	r2,2317
 9094644:	108efd04 	addi	r2,r2,15348
 9094648:	10c00003 	ldbu	r3,0(r2)
 909464c:	e0bff8c3 	ldbu	r2,-29(fp)
 9094650:	1884b03a 	or	r2,r3,r2
 9094654:	1007883a 	mov	r3,r2
 9094658:	00824374 	movhi	r2,2317
 909465c:	108efd04 	addi	r2,r2,15348
 9094660:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 9094664:	e13ff983 	ldbu	r4,-26(fp)
 9094668:	e0fff983 	ldbu	r3,-26(fp)
 909466c:	00824374 	movhi	r2,2317
 9094670:	108efd44 	addi	r2,r2,15349
 9094674:	10c5883a 	add	r2,r2,r3
 9094678:	10c00003 	ldbu	r3,0(r2)
 909467c:	e0bff883 	ldbu	r2,-30(fp)
 9094680:	1884b03a 	or	r2,r3,r2
 9094684:	1007883a 	mov	r3,r2
 9094688:	00824374 	movhi	r2,2317
 909468c:	108efd44 	addi	r2,r2,15349
 9094690:	1105883a 	add	r2,r2,r4
 9094694:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 9094698:	e0bffa17 	ldw	r2,-24(fp)
 909469c:	10800717 	ldw	r2,28(r2)
 90946a0:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 90946a4:	e0bffc17 	ldw	r2,-16(fp)
 90946a8:	1005003a 	cmpeq	r2,r2,zero
 90946ac:	1000341e 	bne	r2,zero,9094780 <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 90946b0:	e13ff903 	ldbu	r4,-28(fp)
 90946b4:	e0fff903 	ldbu	r3,-28(fp)
 90946b8:	e0bffc17 	ldw	r2,-16(fp)
 90946bc:	1885883a 	add	r2,r3,r2
 90946c0:	10800204 	addi	r2,r2,8
 90946c4:	108000c3 	ldbu	r2,3(r2)
 90946c8:	1007883a 	mov	r3,r2
 90946cc:	e0bff803 	ldbu	r2,-32(fp)
 90946d0:	0084303a 	nor	r2,zero,r2
 90946d4:	1884703a 	and	r2,r3,r2
 90946d8:	1007883a 	mov	r3,r2
 90946dc:	e0bffc17 	ldw	r2,-16(fp)
 90946e0:	2085883a 	add	r2,r4,r2
 90946e4:	10800204 	addi	r2,r2,8
 90946e8:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 90946ec:	e0fff903 	ldbu	r3,-28(fp)
 90946f0:	e0bffc17 	ldw	r2,-16(fp)
 90946f4:	1885883a 	add	r2,r3,r2
 90946f8:	10800204 	addi	r2,r2,8
 90946fc:	108000c3 	ldbu	r2,3(r2)
 9094700:	10803fcc 	andi	r2,r2,255
 9094704:	1004c03a 	cmpne	r2,r2,zero
 9094708:	1000091e 	bne	r2,zero,9094730 <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 909470c:	e0bffc17 	ldw	r2,-16(fp)
 9094710:	10800283 	ldbu	r2,10(r2)
 9094714:	1007883a 	mov	r3,r2
 9094718:	e0bff843 	ldbu	r2,-31(fp)
 909471c:	0084303a 	nor	r2,zero,r2
 9094720:	1884703a 	and	r2,r3,r2
 9094724:	1007883a 	mov	r3,r2
 9094728:	e0bffc17 	ldw	r2,-16(fp)
 909472c:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 9094730:	e0bffc17 	ldw	r2,-16(fp)
 9094734:	10c00283 	ldbu	r3,10(r2)
 9094738:	e0bff8c3 	ldbu	r2,-29(fp)
 909473c:	1884b03a 	or	r2,r3,r2
 9094740:	1007883a 	mov	r3,r2
 9094744:	e0bffc17 	ldw	r2,-16(fp)
 9094748:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 909474c:	e13ff983 	ldbu	r4,-26(fp)
 9094750:	e0fff983 	ldbu	r3,-26(fp)
 9094754:	e0bffc17 	ldw	r2,-16(fp)
 9094758:	1885883a 	add	r2,r3,r2
 909475c:	10800204 	addi	r2,r2,8
 9094760:	10c000c3 	ldbu	r3,3(r2)
 9094764:	e0bff883 	ldbu	r2,-30(fp)
 9094768:	1884b03a 	or	r2,r3,r2
 909476c:	1007883a 	mov	r3,r2
 9094770:	e0bffc17 	ldw	r2,-16(fp)
 9094774:	2085883a 	add	r2,r4,r2
 9094778:	10800204 	addi	r2,r2,8
 909477c:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 9094780:	e0bffa17 	ldw	r2,-24(fp)
 9094784:	10800817 	ldw	r2,32(r2)
 9094788:	1005003a 	cmpeq	r2,r2,zero
 909478c:	1000441e 	bne	r2,zero,90948a0 <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 9094790:	e0bffa17 	ldw	r2,-24(fp)
 9094794:	10800817 	ldw	r2,32(r2)
 9094798:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 909479c:	e0bffb17 	ldw	r2,-20(fp)
 90947a0:	10800017 	ldw	r2,0(r2)
 90947a4:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 90947a8:	00003a06 	br	9094894 <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 90947ac:	e13ff903 	ldbu	r4,-28(fp)
 90947b0:	e0fff903 	ldbu	r3,-28(fp)
 90947b4:	e0bffc17 	ldw	r2,-16(fp)
 90947b8:	1885883a 	add	r2,r3,r2
 90947bc:	10800204 	addi	r2,r2,8
 90947c0:	108000c3 	ldbu	r2,3(r2)
 90947c4:	1007883a 	mov	r3,r2
 90947c8:	e0bff803 	ldbu	r2,-32(fp)
 90947cc:	0084303a 	nor	r2,zero,r2
 90947d0:	1884703a 	and	r2,r3,r2
 90947d4:	1007883a 	mov	r3,r2
 90947d8:	e0bffc17 	ldw	r2,-16(fp)
 90947dc:	2085883a 	add	r2,r4,r2
 90947e0:	10800204 	addi	r2,r2,8
 90947e4:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 90947e8:	e0fff903 	ldbu	r3,-28(fp)
 90947ec:	e0bffc17 	ldw	r2,-16(fp)
 90947f0:	1885883a 	add	r2,r3,r2
 90947f4:	10800204 	addi	r2,r2,8
 90947f8:	108000c3 	ldbu	r2,3(r2)
 90947fc:	10803fcc 	andi	r2,r2,255
 9094800:	1004c03a 	cmpne	r2,r2,zero
 9094804:	1000091e 	bne	r2,zero,909482c <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 9094808:	e0bffc17 	ldw	r2,-16(fp)
 909480c:	10800283 	ldbu	r2,10(r2)
 9094810:	1007883a 	mov	r3,r2
 9094814:	e0bff843 	ldbu	r2,-31(fp)
 9094818:	0084303a 	nor	r2,zero,r2
 909481c:	1884703a 	and	r2,r3,r2
 9094820:	1007883a 	mov	r3,r2
 9094824:	e0bffc17 	ldw	r2,-16(fp)
 9094828:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 909482c:	e0bffc17 	ldw	r2,-16(fp)
 9094830:	10c00283 	ldbu	r3,10(r2)
 9094834:	e0bff8c3 	ldbu	r2,-29(fp)
 9094838:	1884b03a 	or	r2,r3,r2
 909483c:	1007883a 	mov	r3,r2
 9094840:	e0bffc17 	ldw	r2,-16(fp)
 9094844:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 9094848:	e13ff983 	ldbu	r4,-26(fp)
 909484c:	e0fff983 	ldbu	r3,-26(fp)
 9094850:	e0bffc17 	ldw	r2,-16(fp)
 9094854:	1885883a 	add	r2,r3,r2
 9094858:	10800204 	addi	r2,r2,8
 909485c:	10c000c3 	ldbu	r3,3(r2)
 9094860:	e0bff883 	ldbu	r2,-30(fp)
 9094864:	1884b03a 	or	r2,r3,r2
 9094868:	1007883a 	mov	r3,r2
 909486c:	e0bffc17 	ldw	r2,-16(fp)
 9094870:	2085883a 	add	r2,r4,r2
 9094874:	10800204 	addi	r2,r2,8
 9094878:	10c000c5 	stb	r3,3(r2)
            pevents++;
 909487c:	e0bffb17 	ldw	r2,-20(fp)
 9094880:	10800104 	addi	r2,r2,4
 9094884:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 9094888:	e0bffb17 	ldw	r2,-20(fp)
 909488c:	10800017 	ldw	r2,0(r2)
 9094890:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 9094894:	e0bffc17 	ldw	r2,-16(fp)
 9094898:	1004c03a 	cmpne	r2,r2,zero
 909489c:	103fc31e 	bne	r2,zero,90947ac <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 90948a0:	e0fffa17 	ldw	r3,-24(fp)
 90948a4:	e0bffe03 	ldbu	r2,-8(fp)
 90948a8:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 90948ac:	e0fffa17 	ldw	r3,-24(fp)
 90948b0:	e0bff983 	ldbu	r2,-26(fp)
 90948b4:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 90948b8:	e0fffa17 	ldw	r3,-24(fp)
 90948bc:	e0bff943 	ldbu	r2,-27(fp)
 90948c0:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 90948c4:	e0fffa17 	ldw	r3,-24(fp)
 90948c8:	e0bff8c3 	ldbu	r2,-29(fp)
 90948cc:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 90948d0:	e0fffa17 	ldw	r3,-24(fp)
 90948d4:	e0bff883 	ldbu	r2,-30(fp)
 90948d8:	18800d45 	stb	r2,53(r3)
 90948dc:	e0bff717 	ldw	r2,-36(fp)
 90948e0:	e0bff215 	stw	r2,-56(fp)
 90948e4:	e0bff217 	ldw	r2,-56(fp)
 90948e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 90948ec:	00824374 	movhi	r2,2317
 90948f0:	108ef144 	addi	r2,r2,15301
 90948f4:	10800003 	ldbu	r2,0(r2)
 90948f8:	10803fcc 	andi	r2,r2,255
 90948fc:	10800058 	cmpnei	r2,r2,1
 9094900:	1000011e 	bne	r2,zero,9094908 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 9094904:	908fae40 	call	908fae4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 9094908:	e03fff15 	stw	zero,-4(fp)
 909490c:	e0bfff17 	ldw	r2,-4(fp)
}
 9094910:	e037883a 	mov	sp,fp
 9094914:	dfc00117 	ldw	ra,4(sp)
 9094918:	df000017 	ldw	fp,0(sp)
 909491c:	dec00204 	addi	sp,sp,8
 9094920:	f800283a 	ret

09094924 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 9094924:	deffed04 	addi	sp,sp,-76
 9094928:	dfc01215 	stw	ra,72(sp)
 909492c:	df001115 	stw	fp,68(sp)
 9094930:	df001104 	addi	fp,sp,68
 9094934:	e13ffb15 	stw	r4,-20(fp)
 9094938:	e17ffc15 	stw	r5,-16(fp)
 909493c:	e1bffd15 	stw	r6,-12(fp)
 9094940:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 9094944:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 9094948:	e0bffe03 	ldbu	r2,-8(fp)
 909494c:	10800570 	cmpltui	r2,r2,21
 9094950:	1000031e 	bne	r2,zero,9094960 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 9094954:	00800a84 	movi	r2,42
 9094958:	e0bfff15 	stw	r2,-4(fp)
 909495c:	00006006 	br	9094ae0 <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094960:	0005303a 	rdctl	r2,status
 9094964:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094968:	e0fff717 	ldw	r3,-36(fp)
 909496c:	00bfff84 	movi	r2,-2
 9094970:	1884703a 	and	r2,r3,r2
 9094974:	1001703a 	wrctl	status,r2
  
  return context;
 9094978:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909497c:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 9094980:	00824374 	movhi	r2,2317
 9094984:	108eff04 	addi	r2,r2,15356
 9094988:	10800003 	ldbu	r2,0(r2)
 909498c:	10803fcc 	andi	r2,r2,255
 9094990:	1005003a 	cmpeq	r2,r2,zero
 9094994:	1000071e 	bne	r2,zero,90949b4 <OSTaskCreate+0x90>
 9094998:	e0bff817 	ldw	r2,-32(fp)
 909499c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90949a0:	e0bff617 	ldw	r2,-40(fp)
 90949a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 90949a8:	00800f04 	movi	r2,60
 90949ac:	e0bfff15 	stw	r2,-4(fp)
 90949b0:	00004b06 	br	9094ae0 <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 90949b4:	e0bffe03 	ldbu	r2,-8(fp)
 90949b8:	00c243b4 	movhi	r3,2318
 90949bc:	18f47404 	addi	r3,r3,-11824
 90949c0:	1085883a 	add	r2,r2,r2
 90949c4:	1085883a 	add	r2,r2,r2
 90949c8:	10c5883a 	add	r2,r2,r3
 90949cc:	10800017 	ldw	r2,0(r2)
 90949d0:	1004c03a 	cmpne	r2,r2,zero
 90949d4:	10003c1e 	bne	r2,zero,9094ac8 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 90949d8:	e0bffe03 	ldbu	r2,-8(fp)
 90949dc:	00c243b4 	movhi	r3,2318
 90949e0:	18f47404 	addi	r3,r3,-11824
 90949e4:	1085883a 	add	r2,r2,r2
 90949e8:	1085883a 	add	r2,r2,r2
 90949ec:	10c7883a 	add	r3,r2,r3
 90949f0:	00800044 	movi	r2,1
 90949f4:	18800015 	stw	r2,0(r3)
 90949f8:	e0bff817 	ldw	r2,-32(fp)
 90949fc:	e0bff515 	stw	r2,-44(fp)
 9094a00:	e0bff517 	ldw	r2,-44(fp)
 9094a04:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 9094a08:	e13ffb17 	ldw	r4,-20(fp)
 9094a0c:	e17ffc17 	ldw	r5,-16(fp)
 9094a10:	e1bffd17 	ldw	r6,-12(fp)
 9094a14:	000f883a 	mov	r7,zero
 9094a18:	90bae5c0 	call	90bae5c <OSTaskStkInit>
 9094a1c:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 9094a20:	e13ffe03 	ldbu	r4,-8(fp)
 9094a24:	d8000015 	stw	zero,0(sp)
 9094a28:	d8000115 	stw	zero,4(sp)
 9094a2c:	d8000215 	stw	zero,8(sp)
 9094a30:	e17ffa17 	ldw	r5,-24(fp)
 9094a34:	000d883a 	mov	r6,zero
 9094a38:	000f883a 	mov	r7,zero
 9094a3c:	908ff040 	call	908ff04 <OS_TCBInit>
 9094a40:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 9094a44:	e0bff903 	ldbu	r2,-28(fp)
 9094a48:	1004c03a 	cmpne	r2,r2,zero
 9094a4c:	1000081e 	bne	r2,zero,9094a70 <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 9094a50:	00824374 	movhi	r2,2317
 9094a54:	108ef144 	addi	r2,r2,15301
 9094a58:	10800003 	ldbu	r2,0(r2)
 9094a5c:	10803fcc 	andi	r2,r2,255
 9094a60:	10800058 	cmpnei	r2,r2,1
 9094a64:	1000151e 	bne	r2,zero,9094abc <OSTaskCreate+0x198>
                OS_Sched();
 9094a68:	908fae40 	call	908fae4 <OS_Sched>
 9094a6c:	00001306 	br	9094abc <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094a70:	0005303a 	rdctl	r2,status
 9094a74:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094a78:	e0fff417 	ldw	r3,-48(fp)
 9094a7c:	00bfff84 	movi	r2,-2
 9094a80:	1884703a 	and	r2,r3,r2
 9094a84:	1001703a 	wrctl	status,r2
  
  return context;
 9094a88:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 9094a8c:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 9094a90:	e0bffe03 	ldbu	r2,-8(fp)
 9094a94:	00c243b4 	movhi	r3,2318
 9094a98:	18f47404 	addi	r3,r3,-11824
 9094a9c:	1085883a 	add	r2,r2,r2
 9094aa0:	1085883a 	add	r2,r2,r2
 9094aa4:	10c5883a 	add	r2,r2,r3
 9094aa8:	10000015 	stw	zero,0(r2)
 9094aac:	e0bff817 	ldw	r2,-32(fp)
 9094ab0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094ab4:	e0bff317 	ldw	r2,-52(fp)
 9094ab8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 9094abc:	e0bff903 	ldbu	r2,-28(fp)
 9094ac0:	e0bfff15 	stw	r2,-4(fp)
 9094ac4:	00000606 	br	9094ae0 <OSTaskCreate+0x1bc>
 9094ac8:	e0bff817 	ldw	r2,-32(fp)
 9094acc:	e0bff215 	stw	r2,-56(fp)
 9094ad0:	e0bff217 	ldw	r2,-56(fp)
 9094ad4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 9094ad8:	00800a04 	movi	r2,40
 9094adc:	e0bfff15 	stw	r2,-4(fp)
 9094ae0:	e0bfff17 	ldw	r2,-4(fp)
}
 9094ae4:	e037883a 	mov	sp,fp
 9094ae8:	dfc00117 	ldw	ra,4(sp)
 9094aec:	df000017 	ldw	fp,0(sp)
 9094af0:	dec00204 	addi	sp,sp,8
 9094af4:	f800283a 	ret

09094af8 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 9094af8:	deffeb04 	addi	sp,sp,-84
 9094afc:	dfc01415 	stw	ra,80(sp)
 9094b00:	df001315 	stw	fp,76(sp)
 9094b04:	df001304 	addi	fp,sp,76
 9094b08:	e13ff915 	stw	r4,-28(fp)
 9094b0c:	e17ffa15 	stw	r5,-24(fp)
 9094b10:	e1bffb15 	stw	r6,-20(fp)
 9094b14:	e0800217 	ldw	r2,8(fp)
 9094b18:	e0c00617 	ldw	r3,24(fp)
 9094b1c:	e1fffc05 	stb	r7,-16(fp)
 9094b20:	e0bffd0d 	sth	r2,-12(fp)
 9094b24:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 9094b28:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 9094b2c:	e0bffc03 	ldbu	r2,-16(fp)
 9094b30:	10800570 	cmpltui	r2,r2,21
 9094b34:	1000031e 	bne	r2,zero,9094b44 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 9094b38:	00800a84 	movi	r2,42
 9094b3c:	e0bfff15 	stw	r2,-4(fp)
 9094b40:	00006706 	br	9094ce0 <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094b44:	0005303a 	rdctl	r2,status
 9094b48:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094b4c:	e0fff517 	ldw	r3,-44(fp)
 9094b50:	00bfff84 	movi	r2,-2
 9094b54:	1884703a 	and	r2,r3,r2
 9094b58:	1001703a 	wrctl	status,r2
  
  return context;
 9094b5c:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9094b60:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 9094b64:	00824374 	movhi	r2,2317
 9094b68:	108eff04 	addi	r2,r2,15356
 9094b6c:	10800003 	ldbu	r2,0(r2)
 9094b70:	10803fcc 	andi	r2,r2,255
 9094b74:	1005003a 	cmpeq	r2,r2,zero
 9094b78:	1000071e 	bne	r2,zero,9094b98 <OSTaskCreateExt+0xa0>
 9094b7c:	e0bff617 	ldw	r2,-40(fp)
 9094b80:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094b84:	e0bff417 	ldw	r2,-48(fp)
 9094b88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 9094b8c:	00800f04 	movi	r2,60
 9094b90:	e0bfff15 	stw	r2,-4(fp)
 9094b94:	00005206 	br	9094ce0 <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 9094b98:	e0bffc03 	ldbu	r2,-16(fp)
 9094b9c:	00c243b4 	movhi	r3,2318
 9094ba0:	18f47404 	addi	r3,r3,-11824
 9094ba4:	1085883a 	add	r2,r2,r2
 9094ba8:	1085883a 	add	r2,r2,r2
 9094bac:	10c5883a 	add	r2,r2,r3
 9094bb0:	10800017 	ldw	r2,0(r2)
 9094bb4:	1004c03a 	cmpne	r2,r2,zero
 9094bb8:	1000431e 	bne	r2,zero,9094cc8 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 9094bbc:	e0bffc03 	ldbu	r2,-16(fp)
 9094bc0:	00c243b4 	movhi	r3,2318
 9094bc4:	18f47404 	addi	r3,r3,-11824
 9094bc8:	1085883a 	add	r2,r2,r2
 9094bcc:	1085883a 	add	r2,r2,r2
 9094bd0:	10c7883a 	add	r3,r2,r3
 9094bd4:	00800044 	movi	r2,1
 9094bd8:	18800015 	stw	r2,0(r3)
 9094bdc:	e0bff617 	ldw	r2,-40(fp)
 9094be0:	e0bff315 	stw	r2,-52(fp)
 9094be4:	e0bff317 	ldw	r2,-52(fp)
 9094be8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 9094bec:	e1bffe0b 	ldhu	r6,-8(fp)
 9094bf0:	e1000317 	ldw	r4,12(fp)
 9094bf4:	e1400417 	ldw	r5,16(fp)
 9094bf8:	9095d740 	call	9095d74 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 9094bfc:	e1fffe0b 	ldhu	r7,-8(fp)
 9094c00:	e13ff917 	ldw	r4,-28(fp)
 9094c04:	e17ffa17 	ldw	r5,-24(fp)
 9094c08:	e1bffb17 	ldw	r6,-20(fp)
 9094c0c:	90bae5c0 	call	90bae5c <OSTaskStkInit>
 9094c10:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 9094c14:	e13ffc03 	ldbu	r4,-16(fp)
 9094c18:	e1fffd0b 	ldhu	r7,-12(fp)
 9094c1c:	e0fffe0b 	ldhu	r3,-8(fp)
 9094c20:	e0800417 	ldw	r2,16(fp)
 9094c24:	d8800015 	stw	r2,0(sp)
 9094c28:	e0800517 	ldw	r2,20(fp)
 9094c2c:	d8800115 	stw	r2,4(sp)
 9094c30:	d8c00215 	stw	r3,8(sp)
 9094c34:	e17ff817 	ldw	r5,-32(fp)
 9094c38:	e1800317 	ldw	r6,12(fp)
 9094c3c:	908ff040 	call	908ff04 <OS_TCBInit>
 9094c40:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 9094c44:	e0bff703 	ldbu	r2,-36(fp)
 9094c48:	1004c03a 	cmpne	r2,r2,zero
 9094c4c:	1000081e 	bne	r2,zero,9094c70 <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 9094c50:	00824374 	movhi	r2,2317
 9094c54:	108ef144 	addi	r2,r2,15301
 9094c58:	10800003 	ldbu	r2,0(r2)
 9094c5c:	10803fcc 	andi	r2,r2,255
 9094c60:	10800058 	cmpnei	r2,r2,1
 9094c64:	1000151e 	bne	r2,zero,9094cbc <OSTaskCreateExt+0x1c4>
                OS_Sched();
 9094c68:	908fae40 	call	908fae4 <OS_Sched>
 9094c6c:	00001306 	br	9094cbc <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094c70:	0005303a 	rdctl	r2,status
 9094c74:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094c78:	e0fff217 	ldw	r3,-56(fp)
 9094c7c:	00bfff84 	movi	r2,-2
 9094c80:	1884703a 	and	r2,r3,r2
 9094c84:	1001703a 	wrctl	status,r2
  
  return context;
 9094c88:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 9094c8c:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 9094c90:	e0bffc03 	ldbu	r2,-16(fp)
 9094c94:	00c243b4 	movhi	r3,2318
 9094c98:	18f47404 	addi	r3,r3,-11824
 9094c9c:	1085883a 	add	r2,r2,r2
 9094ca0:	1085883a 	add	r2,r2,r2
 9094ca4:	10c5883a 	add	r2,r2,r3
 9094ca8:	10000015 	stw	zero,0(r2)
 9094cac:	e0bff617 	ldw	r2,-40(fp)
 9094cb0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094cb4:	e0bff117 	ldw	r2,-60(fp)
 9094cb8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 9094cbc:	e0bff703 	ldbu	r2,-36(fp)
 9094cc0:	e0bfff15 	stw	r2,-4(fp)
 9094cc4:	00000606 	br	9094ce0 <OSTaskCreateExt+0x1e8>
 9094cc8:	e0bff617 	ldw	r2,-40(fp)
 9094ccc:	e0bff015 	stw	r2,-64(fp)
 9094cd0:	e0bff017 	ldw	r2,-64(fp)
 9094cd4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 9094cd8:	00800a04 	movi	r2,40
 9094cdc:	e0bfff15 	stw	r2,-4(fp)
 9094ce0:	e0bfff17 	ldw	r2,-4(fp)
}
 9094ce4:	e037883a 	mov	sp,fp
 9094ce8:	dfc00117 	ldw	ra,4(sp)
 9094cec:	df000017 	ldw	fp,0(sp)
 9094cf0:	dec00204 	addi	sp,sp,8
 9094cf4:	f800283a 	ret

09094cf8 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 9094cf8:	defff304 	addi	sp,sp,-52
 9094cfc:	dfc00c15 	stw	ra,48(sp)
 9094d00:	df000b15 	stw	fp,44(sp)
 9094d04:	df000b04 	addi	fp,sp,44
 9094d08:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 9094d0c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 9094d10:	00824374 	movhi	r2,2317
 9094d14:	108eff04 	addi	r2,r2,15356
 9094d18:	10800003 	ldbu	r2,0(r2)
 9094d1c:	10803fcc 	andi	r2,r2,255
 9094d20:	1005003a 	cmpeq	r2,r2,zero
 9094d24:	1000031e 	bne	r2,zero,9094d34 <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 9094d28:	00801004 	movi	r2,64
 9094d2c:	e0bfff15 	stw	r2,-4(fp)
 9094d30:	0000ee06 	br	90950ec <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 9094d34:	e0bffe03 	ldbu	r2,-8(fp)
 9094d38:	10800518 	cmpnei	r2,r2,20
 9094d3c:	1000031e 	bne	r2,zero,9094d4c <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 9094d40:	00800f84 	movi	r2,62
 9094d44:	e0bfff15 	stw	r2,-4(fp)
 9094d48:	0000e806 	br	90950ec <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 9094d4c:	e0bffe03 	ldbu	r2,-8(fp)
 9094d50:	10800530 	cmpltui	r2,r2,20
 9094d54:	1000061e 	bne	r2,zero,9094d70 <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 9094d58:	e0bffe03 	ldbu	r2,-8(fp)
 9094d5c:	10803fe0 	cmpeqi	r2,r2,255
 9094d60:	1000031e 	bne	r2,zero,9094d70 <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 9094d64:	00800a84 	movi	r2,42
 9094d68:	e0bfff15 	stw	r2,-4(fp)
 9094d6c:	0000df06 	br	90950ec <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094d70:	0005303a 	rdctl	r2,status
 9094d74:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094d78:	e0fffa17 	ldw	r3,-24(fp)
 9094d7c:	00bfff84 	movi	r2,-2
 9094d80:	1884703a 	and	r2,r3,r2
 9094d84:	1001703a 	wrctl	status,r2
  
  return context;
 9094d88:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 9094d8c:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 9094d90:	e0bffe03 	ldbu	r2,-8(fp)
 9094d94:	10803fd8 	cmpnei	r2,r2,255
 9094d98:	1000051e 	bne	r2,zero,9094db0 <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 9094d9c:	00824374 	movhi	r2,2317
 9094da0:	108f0004 	addi	r2,r2,15360
 9094da4:	10800017 	ldw	r2,0(r2)
 9094da8:	10800c83 	ldbu	r2,50(r2)
 9094dac:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9094db0:	e0bffe03 	ldbu	r2,-8(fp)
 9094db4:	00c243b4 	movhi	r3,2318
 9094db8:	18f47404 	addi	r3,r3,-11824
 9094dbc:	1085883a 	add	r2,r2,r2
 9094dc0:	1085883a 	add	r2,r2,r2
 9094dc4:	10c5883a 	add	r2,r2,r3
 9094dc8:	10800017 	ldw	r2,0(r2)
 9094dcc:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 9094dd0:	e0bffc17 	ldw	r2,-16(fp)
 9094dd4:	1004c03a 	cmpne	r2,r2,zero
 9094dd8:	1000071e 	bne	r2,zero,9094df8 <OSTaskDel+0x100>
 9094ddc:	e0bffb17 	ldw	r2,-20(fp)
 9094de0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9094de4:	e0bff917 	ldw	r2,-28(fp)
 9094de8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9094dec:	008010c4 	movi	r2,67
 9094df0:	e0bfff15 	stw	r2,-4(fp)
 9094df4:	0000bd06 	br	90950ec <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 9094df8:	e0bffc17 	ldw	r2,-16(fp)
 9094dfc:	10800058 	cmpnei	r2,r2,1
 9094e00:	1000071e 	bne	r2,zero,9094e20 <OSTaskDel+0x128>
 9094e04:	e0bffb17 	ldw	r2,-20(fp)
 9094e08:	e0bff815 	stw	r2,-32(fp)
 9094e0c:	e0bff817 	ldw	r2,-32(fp)
 9094e10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 9094e14:	00800f44 	movi	r2,61
 9094e18:	e0bfff15 	stw	r2,-4(fp)
 9094e1c:	0000b306 	br	90950ec <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 9094e20:	e0bffc17 	ldw	r2,-16(fp)
 9094e24:	10800d03 	ldbu	r2,52(r2)
 9094e28:	11003fcc 	andi	r4,r2,255
 9094e2c:	e0bffc17 	ldw	r2,-16(fp)
 9094e30:	10800d03 	ldbu	r2,52(r2)
 9094e34:	10c03fcc 	andi	r3,r2,255
 9094e38:	00824374 	movhi	r2,2317
 9094e3c:	108efd44 	addi	r2,r2,15349
 9094e40:	10c5883a 	add	r2,r2,r3
 9094e44:	10800003 	ldbu	r2,0(r2)
 9094e48:	1007883a 	mov	r3,r2
 9094e4c:	e0bffc17 	ldw	r2,-16(fp)
 9094e50:	10800d43 	ldbu	r2,53(r2)
 9094e54:	0084303a 	nor	r2,zero,r2
 9094e58:	1884703a 	and	r2,r3,r2
 9094e5c:	1007883a 	mov	r3,r2
 9094e60:	00824374 	movhi	r2,2317
 9094e64:	108efd44 	addi	r2,r2,15349
 9094e68:	1105883a 	add	r2,r2,r4
 9094e6c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 9094e70:	e0bffc17 	ldw	r2,-16(fp)
 9094e74:	10800d03 	ldbu	r2,52(r2)
 9094e78:	10c03fcc 	andi	r3,r2,255
 9094e7c:	00824374 	movhi	r2,2317
 9094e80:	108efd44 	addi	r2,r2,15349
 9094e84:	10c5883a 	add	r2,r2,r3
 9094e88:	10800003 	ldbu	r2,0(r2)
 9094e8c:	10803fcc 	andi	r2,r2,255
 9094e90:	1004c03a 	cmpne	r2,r2,zero
 9094e94:	10000c1e 	bne	r2,zero,9094ec8 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 9094e98:	e0bffc17 	ldw	r2,-16(fp)
 9094e9c:	10800d83 	ldbu	r2,54(r2)
 9094ea0:	0084303a 	nor	r2,zero,r2
 9094ea4:	1007883a 	mov	r3,r2
 9094ea8:	00824374 	movhi	r2,2317
 9094eac:	108efd04 	addi	r2,r2,15348
 9094eb0:	10800003 	ldbu	r2,0(r2)
 9094eb4:	1884703a 	and	r2,r3,r2
 9094eb8:	1007883a 	mov	r3,r2
 9094ebc:	00824374 	movhi	r2,2317
 9094ec0:	108efd04 	addi	r2,r2,15348
 9094ec4:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 9094ec8:	e0bffc17 	ldw	r2,-16(fp)
 9094ecc:	10800717 	ldw	r2,28(r2)
 9094ed0:	1005003a 	cmpeq	r2,r2,zero
 9094ed4:	1000041e 	bne	r2,zero,9094ee8 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 9094ed8:	e0bffc17 	ldw	r2,-16(fp)
 9094edc:	11400717 	ldw	r5,28(r2)
 9094ee0:	e13ffc17 	ldw	r4,-16(fp)
 9094ee4:	908f49c0 	call	908f49c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 9094ee8:	e0bffc17 	ldw	r2,-16(fp)
 9094eec:	10800817 	ldw	r2,32(r2)
 9094ef0:	1005003a 	cmpeq	r2,r2,zero
 9094ef4:	1000041e 	bne	r2,zero,9094f08 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 9094ef8:	e0bffc17 	ldw	r2,-16(fp)
 9094efc:	11400817 	ldw	r5,32(r2)
 9094f00:	e13ffc17 	ldw	r4,-16(fp)
 9094f04:	908f5540 	call	908f554 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 9094f08:	e0bffc17 	ldw	r2,-16(fp)
 9094f0c:	10800a17 	ldw	r2,40(r2)
 9094f10:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 9094f14:	e0bffd17 	ldw	r2,-12(fp)
 9094f18:	1005003a 	cmpeq	r2,r2,zero
 9094f1c:	1000021e 	bne	r2,zero,9094f28 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 9094f20:	e13ffd17 	ldw	r4,-12(fp)
 9094f24:	9091c000 	call	9091c00 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 9094f28:	e0bffc17 	ldw	r2,-16(fp)
 9094f2c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 9094f30:	e0bffc17 	ldw	r2,-16(fp)
 9094f34:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 9094f38:	e0bffc17 	ldw	r2,-16(fp)
 9094f3c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 9094f40:	00824374 	movhi	r2,2317
 9094f44:	108ef104 	addi	r2,r2,15300
 9094f48:	10800003 	ldbu	r2,0(r2)
 9094f4c:	10803fcc 	andi	r2,r2,255
 9094f50:	10803fe0 	cmpeqi	r2,r2,255
 9094f54:	1000081e 	bne	r2,zero,9094f78 <OSTaskDel+0x280>
        OSLockNesting++;
 9094f58:	00824374 	movhi	r2,2317
 9094f5c:	108ef104 	addi	r2,r2,15300
 9094f60:	10800003 	ldbu	r2,0(r2)
 9094f64:	10800044 	addi	r2,r2,1
 9094f68:	1007883a 	mov	r3,r2
 9094f6c:	00824374 	movhi	r2,2317
 9094f70:	108ef104 	addi	r2,r2,15300
 9094f74:	10c00005 	stb	r3,0(r2)
 9094f78:	e0bffb17 	ldw	r2,-20(fp)
 9094f7c:	e0bff715 	stw	r2,-36(fp)
 9094f80:	e0bff717 	ldw	r2,-36(fp)
 9094f84:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 9094f88:	908f0880 	call	908f088 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9094f8c:	0005303a 	rdctl	r2,status
 9094f90:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9094f94:	e0fff617 	ldw	r3,-40(fp)
 9094f98:	00bfff84 	movi	r2,-2
 9094f9c:	1884703a 	and	r2,r3,r2
 9094fa0:	1001703a 	wrctl	status,r2
  
  return context;
 9094fa4:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 9094fa8:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 9094fac:	00824374 	movhi	r2,2317
 9094fb0:	108ef104 	addi	r2,r2,15300
 9094fb4:	10800003 	ldbu	r2,0(r2)
 9094fb8:	10803fcc 	andi	r2,r2,255
 9094fbc:	1005003a 	cmpeq	r2,r2,zero
 9094fc0:	1000081e 	bne	r2,zero,9094fe4 <OSTaskDel+0x2ec>
        OSLockNesting--;
 9094fc4:	00824374 	movhi	r2,2317
 9094fc8:	108ef104 	addi	r2,r2,15300
 9094fcc:	10800003 	ldbu	r2,0(r2)
 9094fd0:	10bfffc4 	addi	r2,r2,-1
 9094fd4:	1007883a 	mov	r3,r2
 9094fd8:	00824374 	movhi	r2,2317
 9094fdc:	108ef104 	addi	r2,r2,15300
 9094fe0:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 9094fe4:	e13ffc17 	ldw	r4,-16(fp)
 9094fe8:	90bb18c0 	call	90bb18c <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 9094fec:	00824374 	movhi	r2,2317
 9094ff0:	108ef944 	addi	r2,r2,15333
 9094ff4:	10800003 	ldbu	r2,0(r2)
 9094ff8:	10bfffc4 	addi	r2,r2,-1
 9094ffc:	1007883a 	mov	r3,r2
 9095000:	00824374 	movhi	r2,2317
 9095004:	108ef944 	addi	r2,r2,15333
 9095008:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 909500c:	e0bffe03 	ldbu	r2,-8(fp)
 9095010:	00c243b4 	movhi	r3,2318
 9095014:	18f47404 	addi	r3,r3,-11824
 9095018:	1085883a 	add	r2,r2,r2
 909501c:	1085883a 	add	r2,r2,r2
 9095020:	10c5883a 	add	r2,r2,r3
 9095024:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 9095028:	e0bffc17 	ldw	r2,-16(fp)
 909502c:	10800617 	ldw	r2,24(r2)
 9095030:	1004c03a 	cmpne	r2,r2,zero
 9095034:	1000091e 	bne	r2,zero,909505c <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 9095038:	e0bffc17 	ldw	r2,-16(fp)
 909503c:	10800517 	ldw	r2,20(r2)
 9095040:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 9095044:	e0bffc17 	ldw	r2,-16(fp)
 9095048:	10c00517 	ldw	r3,20(r2)
 909504c:	00824374 	movhi	r2,2317
 9095050:	108ef404 	addi	r2,r2,15312
 9095054:	10c00015 	stw	r3,0(r2)
 9095058:	00000a06 	br	9095084 <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 909505c:	e0bffc17 	ldw	r2,-16(fp)
 9095060:	10c00617 	ldw	r3,24(r2)
 9095064:	e0bffc17 	ldw	r2,-16(fp)
 9095068:	10800517 	ldw	r2,20(r2)
 909506c:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 9095070:	e0bffc17 	ldw	r2,-16(fp)
 9095074:	10c00517 	ldw	r3,20(r2)
 9095078:	e0bffc17 	ldw	r2,-16(fp)
 909507c:	10800617 	ldw	r2,24(r2)
 9095080:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 9095084:	00824374 	movhi	r2,2317
 9095088:	108ef804 	addi	r2,r2,15328
 909508c:	10c00017 	ldw	r3,0(r2)
 9095090:	e0bffc17 	ldw	r2,-16(fp)
 9095094:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 9095098:	00c24374 	movhi	r3,2317
 909509c:	18cef804 	addi	r3,r3,15328
 90950a0:	e0bffc17 	ldw	r2,-16(fp)
 90950a4:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 90950a8:	e0fffc17 	ldw	r3,-16(fp)
 90950ac:	00800fc4 	movi	r2,63
 90950b0:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 90950b4:	e0bffc17 	ldw	r2,-16(fp)
 90950b8:	10001345 	stb	zero,77(r2)
 90950bc:	e0bffb17 	ldw	r2,-20(fp)
 90950c0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90950c4:	e0bff517 	ldw	r2,-44(fp)
 90950c8:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 90950cc:	00824374 	movhi	r2,2317
 90950d0:	108ef144 	addi	r2,r2,15301
 90950d4:	10800003 	ldbu	r2,0(r2)
 90950d8:	10803fcc 	andi	r2,r2,255
 90950dc:	10800058 	cmpnei	r2,r2,1
 90950e0:	1000011e 	bne	r2,zero,90950e8 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 90950e4:	908fae40 	call	908fae4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 90950e8:	e03fff15 	stw	zero,-4(fp)
 90950ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90950f0:	e037883a 	mov	sp,fp
 90950f4:	dfc00117 	ldw	ra,4(sp)
 90950f8:	df000017 	ldw	fp,0(sp)
 90950fc:	dec00204 	addi	sp,sp,8
 9095100:	f800283a 	ret

09095104 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 9095104:	defff404 	addi	sp,sp,-48
 9095108:	df000b15 	stw	fp,44(sp)
 909510c:	df000b04 	addi	fp,sp,44
 9095110:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9095114:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 9095118:	e0bffe03 	ldbu	r2,-8(fp)
 909511c:	10800518 	cmpnei	r2,r2,20
 9095120:	1000031e 	bne	r2,zero,9095130 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 9095124:	00800f84 	movi	r2,62
 9095128:	e0bfff15 	stw	r2,-4(fp)
 909512c:	00004c06 	br	9095260 <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 9095130:	e0bffe03 	ldbu	r2,-8(fp)
 9095134:	10800530 	cmpltui	r2,r2,20
 9095138:	1000061e 	bne	r2,zero,9095154 <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 909513c:	e0bffe03 	ldbu	r2,-8(fp)
 9095140:	10803fe0 	cmpeqi	r2,r2,255
 9095144:	1000031e 	bne	r2,zero,9095154 <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 9095148:	00800a84 	movi	r2,42
 909514c:	e0bfff15 	stw	r2,-4(fp)
 9095150:	00004306 	br	9095260 <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 9095154:	e0bffe03 	ldbu	r2,-8(fp)
 9095158:	10803fd8 	cmpnei	r2,r2,255
 909515c:	1000141e 	bne	r2,zero,90951b0 <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095160:	0005303a 	rdctl	r2,status
 9095164:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095168:	e0fffa17 	ldw	r3,-24(fp)
 909516c:	00bfff84 	movi	r2,-2
 9095170:	1884703a 	and	r2,r3,r2
 9095174:	1001703a 	wrctl	status,r2
  
  return context;
 9095178:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 909517c:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 9095180:	00824374 	movhi	r2,2317
 9095184:	108f0004 	addi	r2,r2,15360
 9095188:	10800017 	ldw	r2,0(r2)
 909518c:	10800dc3 	ldbu	r2,55(r2)
 9095190:	e0bffd05 	stb	r2,-12(fp)
 9095194:	e0bffb17 	ldw	r2,-20(fp)
 9095198:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909519c:	e0bff917 	ldw	r2,-28(fp)
 90951a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 90951a4:	e0bffd03 	ldbu	r2,-12(fp)
 90951a8:	e0bfff15 	stw	r2,-4(fp)
 90951ac:	00002c06 	br	9095260 <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90951b0:	0005303a 	rdctl	r2,status
 90951b4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90951b8:	e0fff817 	ldw	r3,-32(fp)
 90951bc:	00bfff84 	movi	r2,-2
 90951c0:	1884703a 	and	r2,r3,r2
 90951c4:	1001703a 	wrctl	status,r2
  
  return context;
 90951c8:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 90951cc:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 90951d0:	e0bffe03 	ldbu	r2,-8(fp)
 90951d4:	00c243b4 	movhi	r3,2318
 90951d8:	18f47404 	addi	r3,r3,-11824
 90951dc:	1085883a 	add	r2,r2,r2
 90951e0:	1085883a 	add	r2,r2,r2
 90951e4:	10c5883a 	add	r2,r2,r3
 90951e8:	10800017 	ldw	r2,0(r2)
 90951ec:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 90951f0:	e0bffc17 	ldw	r2,-16(fp)
 90951f4:	1004c03a 	cmpne	r2,r2,zero
 90951f8:	1000071e 	bne	r2,zero,9095218 <OSTaskDelReq+0x114>
 90951fc:	e0bffb17 	ldw	r2,-20(fp)
 9095200:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095204:	e0bff717 	ldw	r2,-36(fp)
 9095208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 909520c:	008010c4 	movi	r2,67
 9095210:	e0bfff15 	stw	r2,-4(fp)
 9095214:	00001206 	br	9095260 <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 9095218:	e0bffc17 	ldw	r2,-16(fp)
 909521c:	10800058 	cmpnei	r2,r2,1
 9095220:	1000071e 	bne	r2,zero,9095240 <OSTaskDelReq+0x13c>
 9095224:	e0bffb17 	ldw	r2,-20(fp)
 9095228:	e0bff615 	stw	r2,-40(fp)
 909522c:	e0bff617 	ldw	r2,-40(fp)
 9095230:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 9095234:	00800f44 	movi	r2,61
 9095238:	e0bfff15 	stw	r2,-4(fp)
 909523c:	00000806 	br	9095260 <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 9095240:	e0fffc17 	ldw	r3,-16(fp)
 9095244:	00800fc4 	movi	r2,63
 9095248:	18800dc5 	stb	r2,55(r3)
 909524c:	e0bffb17 	ldw	r2,-20(fp)
 9095250:	e0bff515 	stw	r2,-44(fp)
 9095254:	e0bff517 	ldw	r2,-44(fp)
 9095258:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 909525c:	e03fff15 	stw	zero,-4(fp)
 9095260:	e0bfff17 	ldw	r2,-4(fp)
}
 9095264:	e037883a 	mov	sp,fp
 9095268:	df000017 	ldw	fp,0(sp)
 909526c:	dec00104 	addi	sp,sp,4
 9095270:	f800283a 	ret

09095274 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 9095274:	defff304 	addi	sp,sp,-52
 9095278:	dfc00c15 	stw	ra,48(sp)
 909527c:	df000b15 	stw	fp,44(sp)
 9095280:	df000b04 	addi	fp,sp,44
 9095284:	e17ffd15 	stw	r5,-12(fp)
 9095288:	e1bffe15 	stw	r6,-8(fp)
 909528c:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 9095290:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 9095294:	e0bffe17 	ldw	r2,-8(fp)
 9095298:	1004c03a 	cmpne	r2,r2,zero
 909529c:	1000021e 	bne	r2,zero,90952a8 <OSTaskNameGet+0x34>
        return (0);
 90952a0:	e03fff15 	stw	zero,-4(fp)
 90952a4:	00005b06 	br	9095414 <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 90952a8:	e0bffc03 	ldbu	r2,-16(fp)
 90952ac:	10800570 	cmpltui	r2,r2,21
 90952b0:	1000081e 	bne	r2,zero,90952d4 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 90952b4:	e0bffc03 	ldbu	r2,-16(fp)
 90952b8:	10803fe0 	cmpeqi	r2,r2,255
 90952bc:	1000051e 	bne	r2,zero,90952d4 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 90952c0:	e0fffe17 	ldw	r3,-8(fp)
 90952c4:	00800a84 	movi	r2,42
 90952c8:	18800005 	stb	r2,0(r3)
            return (0);
 90952cc:	e03fff15 	stw	zero,-4(fp)
 90952d0:	00005006 	br	9095414 <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 90952d4:	e0bffd17 	ldw	r2,-12(fp)
 90952d8:	1004c03a 	cmpne	r2,r2,zero
 90952dc:	1000051e 	bne	r2,zero,90952f4 <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 90952e0:	e0fffe17 	ldw	r3,-8(fp)
 90952e4:	00800304 	movi	r2,12
 90952e8:	18800005 	stb	r2,0(r3)
        return (0);
 90952ec:	e03fff15 	stw	zero,-4(fp)
 90952f0:	00004806 	br	9095414 <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 90952f4:	00824374 	movhi	r2,2317
 90952f8:	108eff04 	addi	r2,r2,15356
 90952fc:	10800003 	ldbu	r2,0(r2)
 9095300:	10803fcc 	andi	r2,r2,255
 9095304:	1005003a 	cmpeq	r2,r2,zero
 9095308:	1000051e 	bne	r2,zero,9095320 <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 909530c:	e0fffe17 	ldw	r3,-8(fp)
 9095310:	00800444 	movi	r2,17
 9095314:	18800005 	stb	r2,0(r3)
        return (0);
 9095318:	e03fff15 	stw	zero,-4(fp)
 909531c:	00003d06 	br	9095414 <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095320:	0005303a 	rdctl	r2,status
 9095324:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095328:	e0fff817 	ldw	r3,-32(fp)
 909532c:	00bfff84 	movi	r2,-2
 9095330:	1884703a 	and	r2,r3,r2
 9095334:	1001703a 	wrctl	status,r2
  
  return context;
 9095338:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 909533c:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 9095340:	e0bffc03 	ldbu	r2,-16(fp)
 9095344:	10803fd8 	cmpnei	r2,r2,255
 9095348:	1000051e 	bne	r2,zero,9095360 <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 909534c:	00824374 	movhi	r2,2317
 9095350:	108f0004 	addi	r2,r2,15360
 9095354:	10800017 	ldw	r2,0(r2)
 9095358:	10800c83 	ldbu	r2,50(r2)
 909535c:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9095360:	e0bffc03 	ldbu	r2,-16(fp)
 9095364:	00c243b4 	movhi	r3,2318
 9095368:	18f47404 	addi	r3,r3,-11824
 909536c:	1085883a 	add	r2,r2,r2
 9095370:	1085883a 	add	r2,r2,r2
 9095374:	10c5883a 	add	r2,r2,r3
 9095378:	10800017 	ldw	r2,0(r2)
 909537c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 9095380:	e0bffb17 	ldw	r2,-20(fp)
 9095384:	1004c03a 	cmpne	r2,r2,zero
 9095388:	1000091e 	bne	r2,zero,90953b0 <OSTaskNameGet+0x13c>
 909538c:	e0bff917 	ldw	r2,-28(fp)
 9095390:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095394:	e0bff717 	ldw	r2,-36(fp)
 9095398:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 909539c:	e0fffe17 	ldw	r3,-8(fp)
 90953a0:	008010c4 	movi	r2,67
 90953a4:	18800005 	stb	r2,0(r3)
        return (0);
 90953a8:	e03fff15 	stw	zero,-4(fp)
 90953ac:	00001906 	br	9095414 <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 90953b0:	e0bffb17 	ldw	r2,-20(fp)
 90953b4:	10800058 	cmpnei	r2,r2,1
 90953b8:	1000091e 	bne	r2,zero,90953e0 <OSTaskNameGet+0x16c>
 90953bc:	e0bff917 	ldw	r2,-28(fp)
 90953c0:	e0bff615 	stw	r2,-40(fp)
 90953c4:	e0bff617 	ldw	r2,-40(fp)
 90953c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 90953cc:	e0fffe17 	ldw	r3,-8(fp)
 90953d0:	008010c4 	movi	r2,67
 90953d4:	18800005 	stb	r2,0(r3)
        return (0);
 90953d8:	e03fff15 	stw	zero,-4(fp)
 90953dc:	00000d06 	br	9095414 <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 90953e0:	e0bffb17 	ldw	r2,-20(fp)
 90953e4:	11401304 	addi	r5,r2,76
 90953e8:	e13ffd17 	ldw	r4,-12(fp)
 90953ec:	908fc280 	call	908fc28 <OS_StrCopy>
 90953f0:	e0bffa05 	stb	r2,-24(fp)
 90953f4:	e0bff917 	ldw	r2,-28(fp)
 90953f8:	e0bff515 	stw	r2,-44(fp)
 90953fc:	e0bff517 	ldw	r2,-44(fp)
 9095400:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 9095404:	e0bffe17 	ldw	r2,-8(fp)
 9095408:	10000005 	stb	zero,0(r2)
    return (len);
 909540c:	e0bffa03 	ldbu	r2,-24(fp)
 9095410:	e0bfff15 	stw	r2,-4(fp)
 9095414:	e0bfff17 	ldw	r2,-4(fp)
}
 9095418:	e037883a 	mov	sp,fp
 909541c:	dfc00117 	ldw	ra,4(sp)
 9095420:	df000017 	ldw	fp,0(sp)
 9095424:	dec00204 	addi	sp,sp,8
 9095428:	f800283a 	ret

0909542c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 909542c:	defff304 	addi	sp,sp,-52
 9095430:	dfc00c15 	stw	ra,48(sp)
 9095434:	df000b15 	stw	fp,44(sp)
 9095438:	df000b04 	addi	fp,sp,44
 909543c:	e17ffe15 	stw	r5,-8(fp)
 9095440:	e1bfff15 	stw	r6,-4(fp)
 9095444:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 9095448:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 909544c:	e0bfff17 	ldw	r2,-4(fp)
 9095450:	1005003a 	cmpeq	r2,r2,zero
 9095454:	1000611e 	bne	r2,zero,90955dc <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 9095458:	e0bffd03 	ldbu	r2,-12(fp)
 909545c:	10800570 	cmpltui	r2,r2,21
 9095460:	1000071e 	bne	r2,zero,9095480 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 9095464:	e0bffd03 	ldbu	r2,-12(fp)
 9095468:	10803fe0 	cmpeqi	r2,r2,255
 909546c:	1000041e 	bne	r2,zero,9095480 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 9095470:	e0ffff17 	ldw	r3,-4(fp)
 9095474:	00800a84 	movi	r2,42
 9095478:	18800005 	stb	r2,0(r3)
            return;
 909547c:	00005706 	br	90955dc <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 9095480:	e0bffe17 	ldw	r2,-8(fp)
 9095484:	1004c03a 	cmpne	r2,r2,zero
 9095488:	1000041e 	bne	r2,zero,909549c <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 909548c:	e0ffff17 	ldw	r3,-4(fp)
 9095490:	00800304 	movi	r2,12
 9095494:	18800005 	stb	r2,0(r3)
        return;
 9095498:	00005006 	br	90955dc <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 909549c:	00824374 	movhi	r2,2317
 90954a0:	108eff04 	addi	r2,r2,15356
 90954a4:	10800003 	ldbu	r2,0(r2)
 90954a8:	10803fcc 	andi	r2,r2,255
 90954ac:	1005003a 	cmpeq	r2,r2,zero
 90954b0:	1000041e 	bne	r2,zero,90954c4 <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 90954b4:	e0ffff17 	ldw	r3,-4(fp)
 90954b8:	00800484 	movi	r2,18
 90954bc:	18800005 	stb	r2,0(r3)
        return;
 90954c0:	00004606 	br	90955dc <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90954c4:	0005303a 	rdctl	r2,status
 90954c8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90954cc:	e0fff917 	ldw	r3,-28(fp)
 90954d0:	00bfff84 	movi	r2,-2
 90954d4:	1884703a 	and	r2,r3,r2
 90954d8:	1001703a 	wrctl	status,r2
  
  return context;
 90954dc:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 90954e0:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 90954e4:	e0bffd03 	ldbu	r2,-12(fp)
 90954e8:	10803fd8 	cmpnei	r2,r2,255
 90954ec:	1000051e 	bne	r2,zero,9095504 <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 90954f0:	00824374 	movhi	r2,2317
 90954f4:	108f0004 	addi	r2,r2,15360
 90954f8:	10800017 	ldw	r2,0(r2)
 90954fc:	10800c83 	ldbu	r2,50(r2)
 9095500:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9095504:	e0bffd03 	ldbu	r2,-12(fp)
 9095508:	00c243b4 	movhi	r3,2318
 909550c:	18f47404 	addi	r3,r3,-11824
 9095510:	1085883a 	add	r2,r2,r2
 9095514:	1085883a 	add	r2,r2,r2
 9095518:	10c5883a 	add	r2,r2,r3
 909551c:	10800017 	ldw	r2,0(r2)
 9095520:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 9095524:	e0bffb17 	ldw	r2,-20(fp)
 9095528:	1004c03a 	cmpne	r2,r2,zero
 909552c:	1000081e 	bne	r2,zero,9095550 <OSTaskNameSet+0x124>
 9095530:	e0bffa17 	ldw	r2,-24(fp)
 9095534:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095538:	e0bff817 	ldw	r2,-32(fp)
 909553c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 9095540:	e0ffff17 	ldw	r3,-4(fp)
 9095544:	008010c4 	movi	r2,67
 9095548:	18800005 	stb	r2,0(r3)
        return;
 909554c:	00002306 	br	90955dc <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 9095550:	e0bffb17 	ldw	r2,-20(fp)
 9095554:	10800058 	cmpnei	r2,r2,1
 9095558:	1000081e 	bne	r2,zero,909557c <OSTaskNameSet+0x150>
 909555c:	e0bffa17 	ldw	r2,-24(fp)
 9095560:	e0bff715 	stw	r2,-36(fp)
 9095564:	e0bff717 	ldw	r2,-36(fp)
 9095568:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 909556c:	e0ffff17 	ldw	r3,-4(fp)
 9095570:	008010c4 	movi	r2,67
 9095574:	18800005 	stb	r2,0(r3)
        return;
 9095578:	00001806 	br	90955dc <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 909557c:	e13ffe17 	ldw	r4,-8(fp)
 9095580:	908fca80 	call	908fca8 <OS_StrLen>
 9095584:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 9095588:	e0bffc03 	ldbu	r2,-16(fp)
 909558c:	10800830 	cmpltui	r2,r2,32
 9095590:	1000081e 	bne	r2,zero,90955b4 <OSTaskNameSet+0x188>
 9095594:	e0bffa17 	ldw	r2,-24(fp)
 9095598:	e0bff615 	stw	r2,-40(fp)
 909559c:	e0bff617 	ldw	r2,-40(fp)
 90955a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 90955a4:	e0ffff17 	ldw	r3,-4(fp)
 90955a8:	00801044 	movi	r2,65
 90955ac:	18800005 	stb	r2,0(r3)
        return;
 90955b0:	00000a06 	br	90955dc <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 90955b4:	e0bffb17 	ldw	r2,-20(fp)
 90955b8:	11001304 	addi	r4,r2,76
 90955bc:	e17ffe17 	ldw	r5,-8(fp)
 90955c0:	908fc280 	call	908fc28 <OS_StrCopy>
 90955c4:	e0bffa17 	ldw	r2,-24(fp)
 90955c8:	e0bff515 	stw	r2,-44(fp)
 90955cc:	e0bff517 	ldw	r2,-44(fp)
 90955d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 90955d4:	e0bfff17 	ldw	r2,-4(fp)
 90955d8:	10000005 	stb	zero,0(r2)
}
 90955dc:	e037883a 	mov	sp,fp
 90955e0:	dfc00117 	ldw	ra,4(sp)
 90955e4:	df000017 	ldw	fp,0(sp)
 90955e8:	dec00204 	addi	sp,sp,8
 90955ec:	f800283a 	ret

090955f0 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 90955f0:	defff304 	addi	sp,sp,-52
 90955f4:	dfc00c15 	stw	ra,48(sp)
 90955f8:	df000b15 	stw	fp,44(sp)
 90955fc:	df000b04 	addi	fp,sp,44
 9095600:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 9095604:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 9095608:	e0bffe03 	ldbu	r2,-8(fp)
 909560c:	10800530 	cmpltui	r2,r2,20
 9095610:	1000031e 	bne	r2,zero,9095620 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 9095614:	00800a84 	movi	r2,42
 9095618:	e0bfff15 	stw	r2,-4(fp)
 909561c:	00007406 	br	90957f0 <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095620:	0005303a 	rdctl	r2,status
 9095624:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095628:	e0fffb17 	ldw	r3,-20(fp)
 909562c:	00bfff84 	movi	r2,-2
 9095630:	1884703a 	and	r2,r3,r2
 9095634:	1001703a 	wrctl	status,r2
  
  return context;
 9095638:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 909563c:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 9095640:	e0bffe03 	ldbu	r2,-8(fp)
 9095644:	00c243b4 	movhi	r3,2318
 9095648:	18f47404 	addi	r3,r3,-11824
 909564c:	1085883a 	add	r2,r2,r2
 9095650:	1085883a 	add	r2,r2,r2
 9095654:	10c5883a 	add	r2,r2,r3
 9095658:	10800017 	ldw	r2,0(r2)
 909565c:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 9095660:	e0bffd17 	ldw	r2,-12(fp)
 9095664:	1004c03a 	cmpne	r2,r2,zero
 9095668:	1000071e 	bne	r2,zero,9095688 <OSTaskResume+0x98>
 909566c:	e0bffc17 	ldw	r2,-16(fp)
 9095670:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095674:	e0bffa17 	ldw	r2,-24(fp)
 9095678:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 909567c:	00801184 	movi	r2,70
 9095680:	e0bfff15 	stw	r2,-4(fp)
 9095684:	00005a06 	br	90957f0 <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 9095688:	e0bffd17 	ldw	r2,-12(fp)
 909568c:	10800058 	cmpnei	r2,r2,1
 9095690:	1000071e 	bne	r2,zero,90956b0 <OSTaskResume+0xc0>
 9095694:	e0bffc17 	ldw	r2,-16(fp)
 9095698:	e0bff915 	stw	r2,-28(fp)
 909569c:	e0bff917 	ldw	r2,-28(fp)
 90956a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 90956a4:	008010c4 	movi	r2,67
 90956a8:	e0bfff15 	stw	r2,-4(fp)
 90956ac:	00005006 	br	90957f0 <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 90956b0:	e0bffd17 	ldw	r2,-12(fp)
 90956b4:	10800c03 	ldbu	r2,48(r2)
 90956b8:	10803fcc 	andi	r2,r2,255
 90956bc:	1080020c 	andi	r2,r2,8
 90956c0:	1005003a 	cmpeq	r2,r2,zero
 90956c4:	1000441e 	bne	r2,zero,90957d8 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 90956c8:	e0bffd17 	ldw	r2,-12(fp)
 90956cc:	10c00c03 	ldbu	r3,48(r2)
 90956d0:	00bffdc4 	movi	r2,-9
 90956d4:	1884703a 	and	r2,r3,r2
 90956d8:	1007883a 	mov	r3,r2
 90956dc:	e0bffd17 	ldw	r2,-12(fp)
 90956e0:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 90956e4:	e0bffd17 	ldw	r2,-12(fp)
 90956e8:	10800c03 	ldbu	r2,48(r2)
 90956ec:	10803fcc 	andi	r2,r2,255
 90956f0:	1004c03a 	cmpne	r2,r2,zero
 90956f4:	1000321e 	bne	r2,zero,90957c0 <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 90956f8:	e0bffd17 	ldw	r2,-12(fp)
 90956fc:	10800b8b 	ldhu	r2,46(r2)
 9095700:	10bfffcc 	andi	r2,r2,65535
 9095704:	1004c03a 	cmpne	r2,r2,zero
 9095708:	1000281e 	bne	r2,zero,90957ac <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 909570c:	e0bffd17 	ldw	r2,-12(fp)
 9095710:	10c00d83 	ldbu	r3,54(r2)
 9095714:	00824374 	movhi	r2,2317
 9095718:	108efd04 	addi	r2,r2,15348
 909571c:	10800003 	ldbu	r2,0(r2)
 9095720:	1884b03a 	or	r2,r3,r2
 9095724:	1007883a 	mov	r3,r2
 9095728:	00824374 	movhi	r2,2317
 909572c:	108efd04 	addi	r2,r2,15348
 9095730:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9095734:	e0bffd17 	ldw	r2,-12(fp)
 9095738:	10800d03 	ldbu	r2,52(r2)
 909573c:	11003fcc 	andi	r4,r2,255
 9095740:	e0bffd17 	ldw	r2,-12(fp)
 9095744:	10800d03 	ldbu	r2,52(r2)
 9095748:	10c03fcc 	andi	r3,r2,255
 909574c:	00824374 	movhi	r2,2317
 9095750:	108efd44 	addi	r2,r2,15349
 9095754:	10c5883a 	add	r2,r2,r3
 9095758:	10c00003 	ldbu	r3,0(r2)
 909575c:	e0bffd17 	ldw	r2,-12(fp)
 9095760:	10800d43 	ldbu	r2,53(r2)
 9095764:	1884b03a 	or	r2,r3,r2
 9095768:	1007883a 	mov	r3,r2
 909576c:	00824374 	movhi	r2,2317
 9095770:	108efd44 	addi	r2,r2,15349
 9095774:	1105883a 	add	r2,r2,r4
 9095778:	10c00005 	stb	r3,0(r2)
 909577c:	e0bffc17 	ldw	r2,-16(fp)
 9095780:	e0bff815 	stw	r2,-32(fp)
 9095784:	e0bff817 	ldw	r2,-32(fp)
 9095788:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 909578c:	00824374 	movhi	r2,2317
 9095790:	108ef144 	addi	r2,r2,15301
 9095794:	10800003 	ldbu	r2,0(r2)
 9095798:	10803fcc 	andi	r2,r2,255
 909579c:	10800058 	cmpnei	r2,r2,1
 90957a0:	10000b1e 	bne	r2,zero,90957d0 <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 90957a4:	908fae40 	call	908fae4 <OS_Sched>
 90957a8:	00000906 	br	90957d0 <OSTaskResume+0x1e0>
 90957ac:	e0bffc17 	ldw	r2,-16(fp)
 90957b0:	e0bff715 	stw	r2,-36(fp)
 90957b4:	e0bff717 	ldw	r2,-36(fp)
 90957b8:	1001703a 	wrctl	status,r2
 90957bc:	00000406 	br	90957d0 <OSTaskResume+0x1e0>
 90957c0:	e0bffc17 	ldw	r2,-16(fp)
 90957c4:	e0bff615 	stw	r2,-40(fp)
 90957c8:	e0bff617 	ldw	r2,-40(fp)
 90957cc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 90957d0:	e03fff15 	stw	zero,-4(fp)
 90957d4:	00000606 	br	90957f0 <OSTaskResume+0x200>
 90957d8:	e0bffc17 	ldw	r2,-16(fp)
 90957dc:	e0bff515 	stw	r2,-44(fp)
 90957e0:	e0bff517 	ldw	r2,-44(fp)
 90957e4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 90957e8:	00801104 	movi	r2,68
 90957ec:	e0bfff15 	stw	r2,-4(fp)
 90957f0:	e0bfff17 	ldw	r2,-4(fp)
}
 90957f4:	e037883a 	mov	sp,fp
 90957f8:	dfc00117 	ldw	ra,4(sp)
 90957fc:	df000017 	ldw	fp,0(sp)
 9095800:	dec00204 	addi	sp,sp,8
 9095804:	f800283a 	ret

09095808 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 9095808:	defff204 	addi	sp,sp,-56
 909580c:	df000d15 	stw	fp,52(sp)
 9095810:	df000d04 	addi	fp,sp,52
 9095814:	e17ffe15 	stw	r5,-8(fp)
 9095818:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 909581c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 9095820:	e0bffd03 	ldbu	r2,-12(fp)
 9095824:	10800570 	cmpltui	r2,r2,21
 9095828:	1000061e 	bne	r2,zero,9095844 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 909582c:	e0bffd03 	ldbu	r2,-12(fp)
 9095830:	10803fe0 	cmpeqi	r2,r2,255
 9095834:	1000031e 	bne	r2,zero,9095844 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 9095838:	00800a84 	movi	r2,42
 909583c:	e0bfff15 	stw	r2,-4(fp)
 9095840:	00006b06 	br	90959f0 <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 9095844:	e0bffe17 	ldw	r2,-8(fp)
 9095848:	1004c03a 	cmpne	r2,r2,zero
 909584c:	1000031e 	bne	r2,zero,909585c <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 9095850:	00800244 	movi	r2,9
 9095854:	e0bfff15 	stw	r2,-4(fp)
 9095858:	00006506 	br	90959f0 <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 909585c:	e0bffe17 	ldw	r2,-8(fp)
 9095860:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 9095864:	e0bffe17 	ldw	r2,-8(fp)
 9095868:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909586c:	0005303a 	rdctl	r2,status
 9095870:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095874:	e0fff717 	ldw	r3,-36(fp)
 9095878:	00bfff84 	movi	r2,-2
 909587c:	1884703a 	and	r2,r3,r2
 9095880:	1001703a 	wrctl	status,r2
  
  return context;
 9095884:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 9095888:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 909588c:	e0bffd03 	ldbu	r2,-12(fp)
 9095890:	10803fd8 	cmpnei	r2,r2,255
 9095894:	1000051e 	bne	r2,zero,90958ac <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 9095898:	00824374 	movhi	r2,2317
 909589c:	108f0004 	addi	r2,r2,15360
 90958a0:	10800017 	ldw	r2,0(r2)
 90958a4:	10800c83 	ldbu	r2,50(r2)
 90958a8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 90958ac:	e0bffd03 	ldbu	r2,-12(fp)
 90958b0:	00c243b4 	movhi	r3,2318
 90958b4:	18f47404 	addi	r3,r3,-11824
 90958b8:	1085883a 	add	r2,r2,r2
 90958bc:	1085883a 	add	r2,r2,r2
 90958c0:	10c5883a 	add	r2,r2,r3
 90958c4:	10800017 	ldw	r2,0(r2)
 90958c8:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 90958cc:	e0bffc17 	ldw	r2,-16(fp)
 90958d0:	1004c03a 	cmpne	r2,r2,zero
 90958d4:	1000071e 	bne	r2,zero,90958f4 <OSTaskStkChk+0xec>
 90958d8:	e0bff817 	ldw	r2,-32(fp)
 90958dc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90958e0:	e0bff617 	ldw	r2,-40(fp)
 90958e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 90958e8:	008010c4 	movi	r2,67
 90958ec:	e0bfff15 	stw	r2,-4(fp)
 90958f0:	00003f06 	br	90959f0 <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 90958f4:	e0bffc17 	ldw	r2,-16(fp)
 90958f8:	10800058 	cmpnei	r2,r2,1
 90958fc:	1000071e 	bne	r2,zero,909591c <OSTaskStkChk+0x114>
 9095900:	e0bff817 	ldw	r2,-32(fp)
 9095904:	e0bff515 	stw	r2,-44(fp)
 9095908:	e0bff517 	ldw	r2,-44(fp)
 909590c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9095910:	008010c4 	movi	r2,67
 9095914:	e0bfff15 	stw	r2,-4(fp)
 9095918:	00003506 	br	90959f0 <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 909591c:	e0bffc17 	ldw	r2,-16(fp)
 9095920:	1080040b 	ldhu	r2,16(r2)
 9095924:	10bfffcc 	andi	r2,r2,65535
 9095928:	1080004c 	andi	r2,r2,1
 909592c:	1004c03a 	cmpne	r2,r2,zero
 9095930:	1000071e 	bne	r2,zero,9095950 <OSTaskStkChk+0x148>
 9095934:	e0bff817 	ldw	r2,-32(fp)
 9095938:	e0bff415 	stw	r2,-48(fp)
 909593c:	e0bff417 	ldw	r2,-48(fp)
 9095940:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 9095944:	00801144 	movi	r2,69
 9095948:	e0bfff15 	stw	r2,-4(fp)
 909594c:	00002806 	br	90959f0 <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 9095950:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 9095954:	e0bffc17 	ldw	r2,-16(fp)
 9095958:	10800317 	ldw	r2,12(r2)
 909595c:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 9095960:	e0bffc17 	ldw	r2,-16(fp)
 9095964:	10800217 	ldw	r2,8(r2)
 9095968:	e0bffb15 	stw	r2,-20(fp)
 909596c:	e0bff817 	ldw	r2,-32(fp)
 9095970:	e0bff315 	stw	r2,-52(fp)
 9095974:	e0bff317 	ldw	r2,-52(fp)
 9095978:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 909597c:	00000306 	br	909598c <OSTaskStkChk+0x184>
        nfree++;
 9095980:	e0bffa17 	ldw	r2,-24(fp)
 9095984:	10800044 	addi	r2,r2,1
 9095988:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 909598c:	e0bffb17 	ldw	r2,-20(fp)
 9095990:	10800017 	ldw	r2,0(r2)
 9095994:	1005003a 	cmpeq	r2,r2,zero
 9095998:	1007883a 	mov	r3,r2
 909599c:	e0bffb17 	ldw	r2,-20(fp)
 90959a0:	10800104 	addi	r2,r2,4
 90959a4:	e0bffb15 	stw	r2,-20(fp)
 90959a8:	18803fcc 	andi	r2,r3,255
 90959ac:	1004c03a 	cmpne	r2,r2,zero
 90959b0:	103ff31e 	bne	r2,zero,9095980 <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 90959b4:	e0bffa17 	ldw	r2,-24(fp)
 90959b8:	1085883a 	add	r2,r2,r2
 90959bc:	1085883a 	add	r2,r2,r2
 90959c0:	1007883a 	mov	r3,r2
 90959c4:	e0bffe17 	ldw	r2,-8(fp)
 90959c8:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 90959cc:	e0fff917 	ldw	r3,-28(fp)
 90959d0:	e0bffa17 	ldw	r2,-24(fp)
 90959d4:	1885c83a 	sub	r2,r3,r2
 90959d8:	1085883a 	add	r2,r2,r2
 90959dc:	1085883a 	add	r2,r2,r2
 90959e0:	1007883a 	mov	r3,r2
 90959e4:	e0bffe17 	ldw	r2,-8(fp)
 90959e8:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 90959ec:	e03fff15 	stw	zero,-4(fp)
 90959f0:	e0bfff17 	ldw	r2,-4(fp)
}
 90959f4:	e037883a 	mov	sp,fp
 90959f8:	df000017 	ldw	fp,0(sp)
 90959fc:	dec00104 	addi	sp,sp,4
 9095a00:	f800283a 	ret

09095a04 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 9095a04:	defff404 	addi	sp,sp,-48
 9095a08:	dfc00b15 	stw	ra,44(sp)
 9095a0c:	df000a15 	stw	fp,40(sp)
 9095a10:	df000a04 	addi	fp,sp,40
 9095a14:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9095a18:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 9095a1c:	e0bffe03 	ldbu	r2,-8(fp)
 9095a20:	10800518 	cmpnei	r2,r2,20
 9095a24:	1000031e 	bne	r2,zero,9095a34 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 9095a28:	008011c4 	movi	r2,71
 9095a2c:	e0bfff15 	stw	r2,-4(fp)
 9095a30:	00007906 	br	9095c18 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 9095a34:	e0bffe03 	ldbu	r2,-8(fp)
 9095a38:	10800530 	cmpltui	r2,r2,20
 9095a3c:	1000061e 	bne	r2,zero,9095a58 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 9095a40:	e0bffe03 	ldbu	r2,-8(fp)
 9095a44:	10803fe0 	cmpeqi	r2,r2,255
 9095a48:	1000031e 	bne	r2,zero,9095a58 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 9095a4c:	00800a84 	movi	r2,42
 9095a50:	e0bfff15 	stw	r2,-4(fp)
 9095a54:	00007006 	br	9095c18 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095a58:	0005303a 	rdctl	r2,status
 9095a5c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095a60:	e0fff917 	ldw	r3,-28(fp)
 9095a64:	00bfff84 	movi	r2,-2
 9095a68:	1884703a 	and	r2,r3,r2
 9095a6c:	1001703a 	wrctl	status,r2
  
  return context;
 9095a70:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 9095a74:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 9095a78:	e0bffe03 	ldbu	r2,-8(fp)
 9095a7c:	10803fd8 	cmpnei	r2,r2,255
 9095a80:	1000081e 	bne	r2,zero,9095aa4 <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 9095a84:	00824374 	movhi	r2,2317
 9095a88:	108f0004 	addi	r2,r2,15360
 9095a8c:	10800017 	ldw	r2,0(r2)
 9095a90:	10800c83 	ldbu	r2,50(r2)
 9095a94:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 9095a98:	00800044 	movi	r2,1
 9095a9c:	e0bffd05 	stb	r2,-12(fp)
 9095aa0:	00000b06 	br	9095ad0 <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 9095aa4:	00824374 	movhi	r2,2317
 9095aa8:	108f0004 	addi	r2,r2,15360
 9095aac:	10800017 	ldw	r2,0(r2)
 9095ab0:	10800c83 	ldbu	r2,50(r2)
 9095ab4:	10c03fcc 	andi	r3,r2,255
 9095ab8:	e0bffe03 	ldbu	r2,-8(fp)
 9095abc:	1880031e 	bne	r3,r2,9095acc <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 9095ac0:	00800044 	movi	r2,1
 9095ac4:	e0bffd05 	stb	r2,-12(fp)
 9095ac8:	00000106 	br	9095ad0 <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 9095acc:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9095ad0:	e0bffe03 	ldbu	r2,-8(fp)
 9095ad4:	00c243b4 	movhi	r3,2318
 9095ad8:	18f47404 	addi	r3,r3,-11824
 9095adc:	1085883a 	add	r2,r2,r2
 9095ae0:	1085883a 	add	r2,r2,r2
 9095ae4:	10c5883a 	add	r2,r2,r3
 9095ae8:	10800017 	ldw	r2,0(r2)
 9095aec:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 9095af0:	e0bffc17 	ldw	r2,-16(fp)
 9095af4:	1004c03a 	cmpne	r2,r2,zero
 9095af8:	1000071e 	bne	r2,zero,9095b18 <OSTaskSuspend+0x114>
 9095afc:	e0bffa17 	ldw	r2,-24(fp)
 9095b00:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095b04:	e0bff817 	ldw	r2,-32(fp)
 9095b08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 9095b0c:	00801204 	movi	r2,72
 9095b10:	e0bfff15 	stw	r2,-4(fp)
 9095b14:	00004006 	br	9095c18 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 9095b18:	e0bffc17 	ldw	r2,-16(fp)
 9095b1c:	10800058 	cmpnei	r2,r2,1
 9095b20:	1000071e 	bne	r2,zero,9095b40 <OSTaskSuspend+0x13c>
 9095b24:	e0bffa17 	ldw	r2,-24(fp)
 9095b28:	e0bff715 	stw	r2,-36(fp)
 9095b2c:	e0bff717 	ldw	r2,-36(fp)
 9095b30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9095b34:	008010c4 	movi	r2,67
 9095b38:	e0bfff15 	stw	r2,-4(fp)
 9095b3c:	00003606 	br	9095c18 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 9095b40:	e0bffc17 	ldw	r2,-16(fp)
 9095b44:	10800d03 	ldbu	r2,52(r2)
 9095b48:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 9095b4c:	e13ffb03 	ldbu	r4,-20(fp)
 9095b50:	e0fffb03 	ldbu	r3,-20(fp)
 9095b54:	00824374 	movhi	r2,2317
 9095b58:	108efd44 	addi	r2,r2,15349
 9095b5c:	10c5883a 	add	r2,r2,r3
 9095b60:	10800003 	ldbu	r2,0(r2)
 9095b64:	1007883a 	mov	r3,r2
 9095b68:	e0bffc17 	ldw	r2,-16(fp)
 9095b6c:	10800d43 	ldbu	r2,53(r2)
 9095b70:	0084303a 	nor	r2,zero,r2
 9095b74:	1884703a 	and	r2,r3,r2
 9095b78:	1007883a 	mov	r3,r2
 9095b7c:	00824374 	movhi	r2,2317
 9095b80:	108efd44 	addi	r2,r2,15349
 9095b84:	1105883a 	add	r2,r2,r4
 9095b88:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 9095b8c:	e0fffb03 	ldbu	r3,-20(fp)
 9095b90:	00824374 	movhi	r2,2317
 9095b94:	108efd44 	addi	r2,r2,15349
 9095b98:	10c5883a 	add	r2,r2,r3
 9095b9c:	10800003 	ldbu	r2,0(r2)
 9095ba0:	10803fcc 	andi	r2,r2,255
 9095ba4:	1004c03a 	cmpne	r2,r2,zero
 9095ba8:	10000c1e 	bne	r2,zero,9095bdc <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 9095bac:	e0bffc17 	ldw	r2,-16(fp)
 9095bb0:	10800d83 	ldbu	r2,54(r2)
 9095bb4:	0084303a 	nor	r2,zero,r2
 9095bb8:	1007883a 	mov	r3,r2
 9095bbc:	00824374 	movhi	r2,2317
 9095bc0:	108efd04 	addi	r2,r2,15348
 9095bc4:	10800003 	ldbu	r2,0(r2)
 9095bc8:	1884703a 	and	r2,r3,r2
 9095bcc:	1007883a 	mov	r3,r2
 9095bd0:	00824374 	movhi	r2,2317
 9095bd4:	108efd04 	addi	r2,r2,15348
 9095bd8:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 9095bdc:	e0bffc17 	ldw	r2,-16(fp)
 9095be0:	10800c03 	ldbu	r2,48(r2)
 9095be4:	10800214 	ori	r2,r2,8
 9095be8:	1007883a 	mov	r3,r2
 9095bec:	e0bffc17 	ldw	r2,-16(fp)
 9095bf0:	10c00c05 	stb	r3,48(r2)
 9095bf4:	e0bffa17 	ldw	r2,-24(fp)
 9095bf8:	e0bff615 	stw	r2,-40(fp)
 9095bfc:	e0bff617 	ldw	r2,-40(fp)
 9095c00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 9095c04:	e0bffd03 	ldbu	r2,-12(fp)
 9095c08:	10800058 	cmpnei	r2,r2,1
 9095c0c:	1000011e 	bne	r2,zero,9095c14 <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 9095c10:	908fae40 	call	908fae4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 9095c14:	e03fff15 	stw	zero,-4(fp)
 9095c18:	e0bfff17 	ldw	r2,-4(fp)
}
 9095c1c:	e037883a 	mov	sp,fp
 9095c20:	dfc00117 	ldw	ra,4(sp)
 9095c24:	df000017 	ldw	fp,0(sp)
 9095c28:	dec00204 	addi	sp,sp,8
 9095c2c:	f800283a 	ret

09095c30 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 9095c30:	defff504 	addi	sp,sp,-44
 9095c34:	dfc00a15 	stw	ra,40(sp)
 9095c38:	df000915 	stw	fp,36(sp)
 9095c3c:	df000904 	addi	fp,sp,36
 9095c40:	e17ffe15 	stw	r5,-8(fp)
 9095c44:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9095c48:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 9095c4c:	e0bffd03 	ldbu	r2,-12(fp)
 9095c50:	10800570 	cmpltui	r2,r2,21
 9095c54:	1000061e 	bne	r2,zero,9095c70 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 9095c58:	e0bffd03 	ldbu	r2,-12(fp)
 9095c5c:	10803fe0 	cmpeqi	r2,r2,255
 9095c60:	1000031e 	bne	r2,zero,9095c70 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 9095c64:	00800a84 	movi	r2,42
 9095c68:	e0bfff15 	stw	r2,-4(fp)
 9095c6c:	00003b06 	br	9095d5c <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 9095c70:	e0bffe17 	ldw	r2,-8(fp)
 9095c74:	1004c03a 	cmpne	r2,r2,zero
 9095c78:	1000031e 	bne	r2,zero,9095c88 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 9095c7c:	00800244 	movi	r2,9
 9095c80:	e0bfff15 	stw	r2,-4(fp)
 9095c84:	00003506 	br	9095d5c <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095c88:	0005303a 	rdctl	r2,status
 9095c8c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095c90:	e0fffa17 	ldw	r3,-24(fp)
 9095c94:	00bfff84 	movi	r2,-2
 9095c98:	1884703a 	and	r2,r3,r2
 9095c9c:	1001703a 	wrctl	status,r2
  
  return context;
 9095ca0:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 9095ca4:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 9095ca8:	e0bffd03 	ldbu	r2,-12(fp)
 9095cac:	10803fd8 	cmpnei	r2,r2,255
 9095cb0:	1000051e 	bne	r2,zero,9095cc8 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 9095cb4:	00824374 	movhi	r2,2317
 9095cb8:	108f0004 	addi	r2,r2,15360
 9095cbc:	10800017 	ldw	r2,0(r2)
 9095cc0:	10800c83 	ldbu	r2,50(r2)
 9095cc4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 9095cc8:	e0bffd03 	ldbu	r2,-12(fp)
 9095ccc:	00c243b4 	movhi	r3,2318
 9095cd0:	18f47404 	addi	r3,r3,-11824
 9095cd4:	1085883a 	add	r2,r2,r2
 9095cd8:	1085883a 	add	r2,r2,r2
 9095cdc:	10c5883a 	add	r2,r2,r3
 9095ce0:	10800017 	ldw	r2,0(r2)
 9095ce4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 9095ce8:	e0bffc17 	ldw	r2,-16(fp)
 9095cec:	1004c03a 	cmpne	r2,r2,zero
 9095cf0:	1000071e 	bne	r2,zero,9095d10 <OSTaskQuery+0xe0>
 9095cf4:	e0bffb17 	ldw	r2,-20(fp)
 9095cf8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095cfc:	e0bff917 	ldw	r2,-28(fp)
 9095d00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 9095d04:	00800a44 	movi	r2,41
 9095d08:	e0bfff15 	stw	r2,-4(fp)
 9095d0c:	00001306 	br	9095d5c <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 9095d10:	e0bffc17 	ldw	r2,-16(fp)
 9095d14:	10800058 	cmpnei	r2,r2,1
 9095d18:	1000071e 	bne	r2,zero,9095d38 <OSTaskQuery+0x108>
 9095d1c:	e0bffb17 	ldw	r2,-20(fp)
 9095d20:	e0bff815 	stw	r2,-32(fp)
 9095d24:	e0bff817 	ldw	r2,-32(fp)
 9095d28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 9095d2c:	008010c4 	movi	r2,67
 9095d30:	e0bfff15 	stw	r2,-4(fp)
 9095d34:	00000906 	br	9095d5c <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 9095d38:	e13ffe17 	ldw	r4,-8(fp)
 9095d3c:	e17ffc17 	ldw	r5,-16(fp)
 9095d40:	01801b04 	movi	r6,108
 9095d44:	908fa780 	call	908fa78 <OS_MemCopy>
 9095d48:	e0bffb17 	ldw	r2,-20(fp)
 9095d4c:	e0bff715 	stw	r2,-36(fp)
 9095d50:	e0bff717 	ldw	r2,-36(fp)
 9095d54:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 9095d58:	e03fff15 	stw	zero,-4(fp)
 9095d5c:	e0bfff17 	ldw	r2,-4(fp)
}
 9095d60:	e037883a 	mov	sp,fp
 9095d64:	dfc00117 	ldw	ra,4(sp)
 9095d68:	df000017 	ldw	fp,0(sp)
 9095d6c:	dec00204 	addi	sp,sp,8
 9095d70:	f800283a 	ret

09095d74 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 9095d74:	defffc04 	addi	sp,sp,-16
 9095d78:	df000315 	stw	fp,12(sp)
 9095d7c:	df000304 	addi	fp,sp,12
 9095d80:	e13ffd15 	stw	r4,-12(fp)
 9095d84:	e17ffe15 	stw	r5,-8(fp)
 9095d88:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 9095d8c:	e0bfff0b 	ldhu	r2,-4(fp)
 9095d90:	1080004c 	andi	r2,r2,1
 9095d94:	10803fcc 	andi	r2,r2,255
 9095d98:	1005003a 	cmpeq	r2,r2,zero
 9095d9c:	1000101e 	bne	r2,zero,9095de0 <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 9095da0:	e0bfff0b 	ldhu	r2,-4(fp)
 9095da4:	1080008c 	andi	r2,r2,2
 9095da8:	1005003a 	cmpeq	r2,r2,zero
 9095dac:	10000c1e 	bne	r2,zero,9095de0 <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 9095db0:	00000806 	br	9095dd4 <OS_TaskStkClr+0x60>
                size--;
 9095db4:	e0bffe17 	ldw	r2,-8(fp)
 9095db8:	10bfffc4 	addi	r2,r2,-1
 9095dbc:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 9095dc0:	e0bffd17 	ldw	r2,-12(fp)
 9095dc4:	10000015 	stw	zero,0(r2)
 9095dc8:	e0bffd17 	ldw	r2,-12(fp)
 9095dcc:	10800104 	addi	r2,r2,4
 9095dd0:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 9095dd4:	e0bffe17 	ldw	r2,-8(fp)
 9095dd8:	1004c03a 	cmpne	r2,r2,zero
 9095ddc:	103ff51e 	bne	r2,zero,9095db4 <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 9095de0:	e037883a 	mov	sp,fp
 9095de4:	df000017 	ldw	fp,0(sp)
 9095de8:	dec00104 	addi	sp,sp,4
 9095dec:	f800283a 	ret

09095df0 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 9095df0:	defff904 	addi	sp,sp,-28
 9095df4:	dfc00615 	stw	ra,24(sp)
 9095df8:	df000515 	stw	fp,20(sp)
 9095dfc:	df000504 	addi	fp,sp,20
 9095e00:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9095e04:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9095e08:	00824374 	movhi	r2,2317
 9095e0c:	108eff04 	addi	r2,r2,15356
 9095e10:	10800003 	ldbu	r2,0(r2)
 9095e14:	10803fcc 	andi	r2,r2,255
 9095e18:	1004c03a 	cmpne	r2,r2,zero
 9095e1c:	1000421e 	bne	r2,zero,9095f28 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 9095e20:	e0bfff0b 	ldhu	r2,-4(fp)
 9095e24:	1005003a 	cmpeq	r2,r2,zero
 9095e28:	10003f1e 	bne	r2,zero,9095f28 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9095e2c:	0005303a 	rdctl	r2,status
 9095e30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9095e34:	e0fffc17 	ldw	r3,-16(fp)
 9095e38:	00bfff84 	movi	r2,-2
 9095e3c:	1884703a 	and	r2,r3,r2
 9095e40:	1001703a 	wrctl	status,r2
  
  return context;
 9095e44:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 9095e48:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 9095e4c:	00824374 	movhi	r2,2317
 9095e50:	108f0004 	addi	r2,r2,15360
 9095e54:	10800017 	ldw	r2,0(r2)
 9095e58:	10800d03 	ldbu	r2,52(r2)
 9095e5c:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 9095e60:	e13ffe03 	ldbu	r4,-8(fp)
 9095e64:	e0fffe03 	ldbu	r3,-8(fp)
 9095e68:	00824374 	movhi	r2,2317
 9095e6c:	108efd44 	addi	r2,r2,15349
 9095e70:	10c5883a 	add	r2,r2,r3
 9095e74:	10800003 	ldbu	r2,0(r2)
 9095e78:	1007883a 	mov	r3,r2
 9095e7c:	00824374 	movhi	r2,2317
 9095e80:	108f0004 	addi	r2,r2,15360
 9095e84:	10800017 	ldw	r2,0(r2)
 9095e88:	10800d43 	ldbu	r2,53(r2)
 9095e8c:	0084303a 	nor	r2,zero,r2
 9095e90:	1884703a 	and	r2,r3,r2
 9095e94:	1007883a 	mov	r3,r2
 9095e98:	00824374 	movhi	r2,2317
 9095e9c:	108efd44 	addi	r2,r2,15349
 9095ea0:	1105883a 	add	r2,r2,r4
 9095ea4:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 9095ea8:	e0fffe03 	ldbu	r3,-8(fp)
 9095eac:	00824374 	movhi	r2,2317
 9095eb0:	108efd44 	addi	r2,r2,15349
 9095eb4:	10c5883a 	add	r2,r2,r3
 9095eb8:	10800003 	ldbu	r2,0(r2)
 9095ebc:	10803fcc 	andi	r2,r2,255
 9095ec0:	1004c03a 	cmpne	r2,r2,zero
 9095ec4:	10000e1e 	bne	r2,zero,9095f00 <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 9095ec8:	00824374 	movhi	r2,2317
 9095ecc:	108f0004 	addi	r2,r2,15360
 9095ed0:	10800017 	ldw	r2,0(r2)
 9095ed4:	10800d83 	ldbu	r2,54(r2)
 9095ed8:	0084303a 	nor	r2,zero,r2
 9095edc:	1007883a 	mov	r3,r2
 9095ee0:	00824374 	movhi	r2,2317
 9095ee4:	108efd04 	addi	r2,r2,15348
 9095ee8:	10800003 	ldbu	r2,0(r2)
 9095eec:	1884703a 	and	r2,r3,r2
 9095ef0:	1007883a 	mov	r3,r2
 9095ef4:	00824374 	movhi	r2,2317
 9095ef8:	108efd04 	addi	r2,r2,15348
 9095efc:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 9095f00:	00824374 	movhi	r2,2317
 9095f04:	108f0004 	addi	r2,r2,15360
 9095f08:	10c00017 	ldw	r3,0(r2)
 9095f0c:	e0bfff0b 	ldhu	r2,-4(fp)
 9095f10:	18800b8d 	sth	r2,46(r3)
 9095f14:	e0bffd17 	ldw	r2,-12(fp)
 9095f18:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9095f1c:	e0bffb17 	ldw	r2,-20(fp)
 9095f20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 9095f24:	908fae40 	call	908fae4 <OS_Sched>
    }
}
 9095f28:	e037883a 	mov	sp,fp
 9095f2c:	dfc00117 	ldw	ra,4(sp)
 9095f30:	df000017 	ldw	fp,0(sp)
 9095f34:	dec00204 	addi	sp,sp,8
 9095f38:	f800283a 	ret

09095f3c <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 9095f3c:	defff504 	addi	sp,sp,-44
 9095f40:	dfc00a15 	stw	ra,40(sp)
 9095f44:	df000915 	stw	fp,36(sp)
 9095f48:	dc400815 	stw	r17,32(sp)
 9095f4c:	dc000715 	stw	r16,28(sp)
 9095f50:	df000704 	addi	fp,sp,28
 9095f54:	e13ffb05 	stb	r4,-20(fp)
 9095f58:	e17ffc05 	stb	r5,-16(fp)
 9095f5c:	e1bffd05 	stb	r6,-12(fp)
 9095f60:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 9095f64:	00824374 	movhi	r2,2317
 9095f68:	108eff04 	addi	r2,r2,15356
 9095f6c:	10800003 	ldbu	r2,0(r2)
 9095f70:	10803fcc 	andi	r2,r2,255
 9095f74:	1005003a 	cmpeq	r2,r2,zero
 9095f78:	1000031e 	bne	r2,zero,9095f88 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
 9095f7c:	00801544 	movi	r2,85
 9095f80:	e0bfff15 	stw	r2,-4(fp)
 9095f84:	00007606 	br	9096160 <OSTimeDlyHMSM+0x224>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 9095f88:	e0bffb03 	ldbu	r2,-20(fp)
 9095f8c:	1004c03a 	cmpne	r2,r2,zero
 9095f90:	10000c1e 	bne	r2,zero,9095fc4 <OSTimeDlyHMSM+0x88>
        if (minutes == 0) {
 9095f94:	e0bffc03 	ldbu	r2,-16(fp)
 9095f98:	1004c03a 	cmpne	r2,r2,zero
 9095f9c:	1000091e 	bne	r2,zero,9095fc4 <OSTimeDlyHMSM+0x88>
            if (seconds == 0) {
 9095fa0:	e0bffd03 	ldbu	r2,-12(fp)
 9095fa4:	1004c03a 	cmpne	r2,r2,zero
 9095fa8:	1000061e 	bne	r2,zero,9095fc4 <OSTimeDlyHMSM+0x88>
                if (ms == 0) {
 9095fac:	e0bffe0b 	ldhu	r2,-8(fp)
 9095fb0:	1004c03a 	cmpne	r2,r2,zero
 9095fb4:	1000031e 	bne	r2,zero,9095fc4 <OSTimeDlyHMSM+0x88>
                    return (OS_ERR_TIME_ZERO_DLY);
 9095fb8:	00801504 	movi	r2,84
 9095fbc:	e0bfff15 	stw	r2,-4(fp)
 9095fc0:	00006706 	br	9096160 <OSTimeDlyHMSM+0x224>
                }
            }
        }
    }
    if (minutes > 59) {
 9095fc4:	e0bffc03 	ldbu	r2,-16(fp)
 9095fc8:	10800f30 	cmpltui	r2,r2,60
 9095fcc:	1000031e 	bne	r2,zero,9095fdc <OSTimeDlyHMSM+0xa0>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 9095fd0:	00801444 	movi	r2,81
 9095fd4:	e0bfff15 	stw	r2,-4(fp)
 9095fd8:	00006106 	br	9096160 <OSTimeDlyHMSM+0x224>
    }
    if (seconds > 59) {
 9095fdc:	e0bffd03 	ldbu	r2,-12(fp)
 9095fe0:	10800f30 	cmpltui	r2,r2,60
 9095fe4:	1000031e 	bne	r2,zero,9095ff4 <OSTimeDlyHMSM+0xb8>
        return (OS_ERR_TIME_INVALID_SECONDS);
 9095fe8:	00801484 	movi	r2,82
 9095fec:	e0bfff15 	stw	r2,-4(fp)
 9095ff0:	00005b06 	br	9096160 <OSTimeDlyHMSM+0x224>
    }
    if (ms > 999) {
 9095ff4:	e0bffe0b 	ldhu	r2,-8(fp)
 9095ff8:	1080fa30 	cmpltui	r2,r2,1000
 9095ffc:	1000031e 	bne	r2,zero,909600c <OSTimeDlyHMSM+0xd0>
        return (OS_ERR_TIME_INVALID_MS);
 9096000:	008014c4 	movi	r2,83
 9096004:	e0bfff15 	stw	r2,-4(fp)
 9096008:	00005506 	br	9096160 <OSTimeDlyHMSM+0x224>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 909600c:	e0bffb03 	ldbu	r2,-20(fp)
 9096010:	10c38424 	muli	r3,r2,3600
 9096014:	e0bffc03 	ldbu	r2,-16(fp)
 9096018:	10800f24 	muli	r2,r2,60
 909601c:	1887883a 	add	r3,r3,r2
 9096020:	e0bffd03 	ldbu	r2,-12(fp)
 9096024:	1889883a 	add	r4,r3,r2
 9096028:	908d0380 	call	908d038 <__floatunsidf>
 909602c:	100b883a 	mov	r5,r2
 9096030:	180d883a 	mov	r6,r3
 9096034:	2809883a 	mov	r4,r5
 9096038:	300b883a 	mov	r5,r6
 909603c:	000d883a 	mov	r6,zero
 9096040:	01d01674 	movhi	r7,16473
 9096044:	908c5b40 	call	908c5b4 <__muldf3>
 9096048:	1009883a 	mov	r4,r2
 909604c:	180b883a 	mov	r5,r3
 9096050:	2021883a 	mov	r16,r4
 9096054:	2823883a 	mov	r17,r5
 9096058:	e13ffe0b 	ldhu	r4,-8(fp)
 909605c:	908d0380 	call	908d038 <__floatunsidf>
 9096060:	100b883a 	mov	r5,r2
 9096064:	180d883a 	mov	r6,r3
 9096068:	2809883a 	mov	r4,r5
 909606c:	300b883a 	mov	r5,r6
 9096070:	000d883a 	mov	r6,zero
 9096074:	01d00534 	movhi	r7,16404
 9096078:	908c5400 	call	908c540 <__adddf3>
 909607c:	1009883a 	mov	r4,r2
 9096080:	180b883a 	mov	r5,r3
 9096084:	2005883a 	mov	r2,r4
 9096088:	2807883a 	mov	r3,r5
 909608c:	1009883a 	mov	r4,r2
 9096090:	180b883a 	mov	r5,r3
 9096094:	000d883a 	mov	r6,zero
 9096098:	01d01674 	movhi	r7,16473
 909609c:	908c5b40 	call	908c5b4 <__muldf3>
 90960a0:	1009883a 	mov	r4,r2
 90960a4:	180b883a 	mov	r5,r3
 90960a8:	2005883a 	mov	r2,r4
 90960ac:	2807883a 	mov	r3,r5
 90960b0:	1009883a 	mov	r4,r2
 90960b4:	180b883a 	mov	r5,r3
 90960b8:	000d883a 	mov	r6,zero
 90960bc:	01d023f4 	movhi	r7,16527
 90960c0:	39d00004 	addi	r7,r7,16384
 90960c4:	908c9680 	call	908c968 <__divdf3>
 90960c8:	1009883a 	mov	r4,r2
 90960cc:	180b883a 	mov	r5,r3
 90960d0:	2005883a 	mov	r2,r4
 90960d4:	2807883a 	mov	r3,r5
 90960d8:	8009883a 	mov	r4,r16
 90960dc:	880b883a 	mov	r5,r17
 90960e0:	100d883a 	mov	r6,r2
 90960e4:	180f883a 	mov	r7,r3
 90960e8:	908c5400 	call	908c540 <__adddf3>
 90960ec:	1009883a 	mov	r4,r2
 90960f0:	180b883a 	mov	r5,r3
 90960f4:	2005883a 	mov	r2,r4
 90960f8:	2807883a 	mov	r3,r5
 90960fc:	1009883a 	mov	r4,r2
 9096100:	180b883a 	mov	r5,r3
 9096104:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 9096108:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 909610c:	e0bffa17 	ldw	r2,-24(fp)
 9096110:	1004d43a 	srli	r2,r2,16
 9096114:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 9096118:	e0bffa17 	ldw	r2,-24(fp)
 909611c:	10bfffcc 	andi	r2,r2,65535
 9096120:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 9096124:	e0bffa17 	ldw	r2,-24(fp)
 9096128:	113fffcc 	andi	r4,r2,65535
 909612c:	9095df00 	call	9095df0 <OSTimeDly>
    while (loops > 0) {
 9096130:	00000706 	br	9096150 <OSTimeDlyHMSM+0x214>
        OSTimeDly((INT16U)32768u);
 9096134:	01200014 	movui	r4,32768
 9096138:	9095df00 	call	9095df0 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 909613c:	01200014 	movui	r4,32768
 9096140:	9095df00 	call	9095df0 <OSTimeDly>
        loops--;
 9096144:	e0bff90b 	ldhu	r2,-28(fp)
 9096148:	10bfffc4 	addi	r2,r2,-1
 909614c:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 9096150:	e0bff90b 	ldhu	r2,-28(fp)
 9096154:	1004c03a 	cmpne	r2,r2,zero
 9096158:	103ff61e 	bne	r2,zero,9096134 <OSTimeDlyHMSM+0x1f8>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 909615c:	e03fff15 	stw	zero,-4(fp)
 9096160:	e0bfff17 	ldw	r2,-4(fp)
}
 9096164:	e037883a 	mov	sp,fp
 9096168:	dfc00317 	ldw	ra,12(sp)
 909616c:	df000217 	ldw	fp,8(sp)
 9096170:	dc400117 	ldw	r17,4(sp)
 9096174:	dc000017 	ldw	r16,0(sp)
 9096178:	dec00404 	addi	sp,sp,16
 909617c:	f800283a 	ret

09096180 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 9096180:	defff404 	addi	sp,sp,-48
 9096184:	dfc00b15 	stw	ra,44(sp)
 9096188:	df000a15 	stw	fp,40(sp)
 909618c:	df000a04 	addi	fp,sp,40
 9096190:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 9096194:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 9096198:	e0bffe03 	ldbu	r2,-8(fp)
 909619c:	10800530 	cmpltui	r2,r2,20
 90961a0:	1000031e 	bne	r2,zero,90961b0 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 90961a4:	00800a84 	movi	r2,42
 90961a8:	e0bfff15 	stw	r2,-4(fp)
 90961ac:	00007206 	br	9096378 <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90961b0:	0005303a 	rdctl	r2,status
 90961b4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90961b8:	e0fffb17 	ldw	r3,-20(fp)
 90961bc:	00bfff84 	movi	r2,-2
 90961c0:	1884703a 	and	r2,r3,r2
 90961c4:	1001703a 	wrctl	status,r2
  
  return context;
 90961c8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 90961cc:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 90961d0:	e0bffe03 	ldbu	r2,-8(fp)
 90961d4:	00c243b4 	movhi	r3,2318
 90961d8:	18f47404 	addi	r3,r3,-11824
 90961dc:	1085883a 	add	r2,r2,r2
 90961e0:	1085883a 	add	r2,r2,r2
 90961e4:	10c5883a 	add	r2,r2,r3
 90961e8:	10800017 	ldw	r2,0(r2)
 90961ec:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 90961f0:	e0bffd17 	ldw	r2,-12(fp)
 90961f4:	1004c03a 	cmpne	r2,r2,zero
 90961f8:	1000071e 	bne	r2,zero,9096218 <OSTimeDlyResume+0x98>
 90961fc:	e0bffc17 	ldw	r2,-16(fp)
 9096200:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9096204:	e0bffa17 	ldw	r2,-24(fp)
 9096208:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 909620c:	008010c4 	movi	r2,67
 9096210:	e0bfff15 	stw	r2,-4(fp)
 9096214:	00005806 	br	9096378 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 9096218:	e0bffd17 	ldw	r2,-12(fp)
 909621c:	10800058 	cmpnei	r2,r2,1
 9096220:	1000071e 	bne	r2,zero,9096240 <OSTimeDlyResume+0xc0>
 9096224:	e0bffc17 	ldw	r2,-16(fp)
 9096228:	e0bff915 	stw	r2,-28(fp)
 909622c:	e0bff917 	ldw	r2,-28(fp)
 9096230:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 9096234:	008010c4 	movi	r2,67
 9096238:	e0bfff15 	stw	r2,-4(fp)
 909623c:	00004e06 	br	9096378 <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 9096240:	e0bffd17 	ldw	r2,-12(fp)
 9096244:	10800b8b 	ldhu	r2,46(r2)
 9096248:	10bfffcc 	andi	r2,r2,65535
 909624c:	1004c03a 	cmpne	r2,r2,zero
 9096250:	1000071e 	bne	r2,zero,9096270 <OSTimeDlyResume+0xf0>
 9096254:	e0bffc17 	ldw	r2,-16(fp)
 9096258:	e0bff815 	stw	r2,-32(fp)
 909625c:	e0bff817 	ldw	r2,-32(fp)
 9096260:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 9096264:	00801404 	movi	r2,80
 9096268:	e0bfff15 	stw	r2,-4(fp)
 909626c:	00004206 	br	9096378 <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 9096270:	e0bffd17 	ldw	r2,-12(fp)
 9096274:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 9096278:	e0bffd17 	ldw	r2,-12(fp)
 909627c:	10800c03 	ldbu	r2,48(r2)
 9096280:	10803fcc 	andi	r2,r2,255
 9096284:	10800dcc 	andi	r2,r2,55
 9096288:	1005003a 	cmpeq	r2,r2,zero
 909628c:	10000b1e 	bne	r2,zero,90962bc <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 9096290:	e0bffd17 	ldw	r2,-12(fp)
 9096294:	10c00c03 	ldbu	r3,48(r2)
 9096298:	00bff204 	movi	r2,-56
 909629c:	1884703a 	and	r2,r3,r2
 90962a0:	1007883a 	mov	r3,r2
 90962a4:	e0bffd17 	ldw	r2,-12(fp)
 90962a8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 90962ac:	e0fffd17 	ldw	r3,-12(fp)
 90962b0:	00800044 	movi	r2,1
 90962b4:	18800c45 	stb	r2,49(r3)
 90962b8:	00000206 	br	90962c4 <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 90962bc:	e0bffd17 	ldw	r2,-12(fp)
 90962c0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 90962c4:	e0bffd17 	ldw	r2,-12(fp)
 90962c8:	10800c03 	ldbu	r2,48(r2)
 90962cc:	10803fcc 	andi	r2,r2,255
 90962d0:	1080020c 	andi	r2,r2,8
 90962d4:	1004c03a 	cmpne	r2,r2,zero
 90962d8:	1000221e 	bne	r2,zero,9096364 <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 90962dc:	e0bffd17 	ldw	r2,-12(fp)
 90962e0:	10c00d83 	ldbu	r3,54(r2)
 90962e4:	00824374 	movhi	r2,2317
 90962e8:	108efd04 	addi	r2,r2,15348
 90962ec:	10800003 	ldbu	r2,0(r2)
 90962f0:	1884b03a 	or	r2,r3,r2
 90962f4:	1007883a 	mov	r3,r2
 90962f8:	00824374 	movhi	r2,2317
 90962fc:	108efd04 	addi	r2,r2,15348
 9096300:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 9096304:	e0bffd17 	ldw	r2,-12(fp)
 9096308:	10800d03 	ldbu	r2,52(r2)
 909630c:	11003fcc 	andi	r4,r2,255
 9096310:	e0bffd17 	ldw	r2,-12(fp)
 9096314:	10800d03 	ldbu	r2,52(r2)
 9096318:	10c03fcc 	andi	r3,r2,255
 909631c:	00824374 	movhi	r2,2317
 9096320:	108efd44 	addi	r2,r2,15349
 9096324:	10c5883a 	add	r2,r2,r3
 9096328:	10c00003 	ldbu	r3,0(r2)
 909632c:	e0bffd17 	ldw	r2,-12(fp)
 9096330:	10800d43 	ldbu	r2,53(r2)
 9096334:	1884b03a 	or	r2,r3,r2
 9096338:	1007883a 	mov	r3,r2
 909633c:	00824374 	movhi	r2,2317
 9096340:	108efd44 	addi	r2,r2,15349
 9096344:	1105883a 	add	r2,r2,r4
 9096348:	10c00005 	stb	r3,0(r2)
 909634c:	e0bffc17 	ldw	r2,-16(fp)
 9096350:	e0bff715 	stw	r2,-36(fp)
 9096354:	e0bff717 	ldw	r2,-36(fp)
 9096358:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 909635c:	908fae40 	call	908fae4 <OS_Sched>
 9096360:	00000406 	br	9096374 <OSTimeDlyResume+0x1f4>
 9096364:	e0bffc17 	ldw	r2,-16(fp)
 9096368:	e0bff615 	stw	r2,-40(fp)
 909636c:	e0bff617 	ldw	r2,-40(fp)
 9096370:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 9096374:	e03fff15 	stw	zero,-4(fp)
 9096378:	e0bfff17 	ldw	r2,-4(fp)
}
 909637c:	e037883a 	mov	sp,fp
 9096380:	dfc00117 	ldw	ra,4(sp)
 9096384:	df000017 	ldw	fp,0(sp)
 9096388:	dec00204 	addi	sp,sp,8
 909638c:	f800283a 	ret

09096390 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 9096390:	defffb04 	addi	sp,sp,-20
 9096394:	df000415 	stw	fp,16(sp)
 9096398:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 909639c:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90963a0:	0005303a 	rdctl	r2,status
 90963a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90963a8:	e0fffd17 	ldw	r3,-12(fp)
 90963ac:	00bfff84 	movi	r2,-2
 90963b0:	1884703a 	and	r2,r3,r2
 90963b4:	1001703a 	wrctl	status,r2
  
  return context;
 90963b8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 90963bc:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 90963c0:	00824374 	movhi	r2,2317
 90963c4:	108f0104 	addi	r2,r2,15364
 90963c8:	10800017 	ldw	r2,0(r2)
 90963cc:	e0bfff15 	stw	r2,-4(fp)
 90963d0:	e0bffe17 	ldw	r2,-8(fp)
 90963d4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90963d8:	e0bffc17 	ldw	r2,-16(fp)
 90963dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 90963e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90963e4:	e037883a 	mov	sp,fp
 90963e8:	df000017 	ldw	fp,0(sp)
 90963ec:	dec00104 	addi	sp,sp,4
 90963f0:	f800283a 	ret

090963f4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 90963f4:	defffb04 	addi	sp,sp,-20
 90963f8:	df000415 	stw	fp,16(sp)
 90963fc:	df000404 	addi	fp,sp,16
 9096400:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 9096404:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9096408:	0005303a 	rdctl	r2,status
 909640c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9096410:	e0fffd17 	ldw	r3,-12(fp)
 9096414:	00bfff84 	movi	r2,-2
 9096418:	1884703a 	and	r2,r3,r2
 909641c:	1001703a 	wrctl	status,r2
  
  return context;
 9096420:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 9096424:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 9096428:	00c24374 	movhi	r3,2317
 909642c:	18cf0104 	addi	r3,r3,15364
 9096430:	e0bfff17 	ldw	r2,-4(fp)
 9096434:	18800015 	stw	r2,0(r3)
 9096438:	e0bffe17 	ldw	r2,-8(fp)
 909643c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9096440:	e0bffc17 	ldw	r2,-16(fp)
 9096444:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 9096448:	e037883a 	mov	sp,fp
 909644c:	df000017 	ldw	fp,0(sp)
 9096450:	dec00104 	addi	sp,sp,4
 9096454:	f800283a 	ret

09096458 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 9096458:	defffd04 	addi	sp,sp,-12
 909645c:	dfc00215 	stw	ra,8(sp)
 9096460:	df000115 	stw	fp,4(sp)
 9096464:	df000104 	addi	fp,sp,4
 9096468:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 909646c:	90bad6c0 	call	90bad6c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 9096470:	00800044 	movi	r2,1
 9096474:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 9096478:	e037883a 	mov	sp,fp
 909647c:	dfc00117 	ldw	ra,4(sp)
 9096480:	df000017 	ldw	fp,0(sp)
 9096484:	dec00204 	addi	sp,sp,8
 9096488:	f800283a 	ret

0909648c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 909648c:	defffa04 	addi	sp,sp,-24
 9096490:	dfc00515 	stw	ra,20(sp)
 9096494:	df000415 	stw	fp,16(sp)
 9096498:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 909649c:	01020034 	movhi	r4,2048
 90964a0:	21001804 	addi	r4,r4,96
 90964a4:	000b883a 	mov	r5,zero
 90964a8:	000d883a 	mov	r6,zero
 90964ac:	01c01904 	movi	r7,100
 90964b0:	909b0180 	call	909b018 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 90964b4:	01024374 	movhi	r4,2317
 90964b8:	2108e104 	addi	r4,r4,9092
 90964bc:	90967440 	call	9096744 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 90964c0:	01024374 	movhi	r4,2317
 90964c4:	21092104 	addi	r4,r4,9348
 90964c8:	000b883a 	mov	r5,zero
 90964cc:	01800144 	movi	r6,5
 90964d0:	909860c0 	call	909860c <altera_avalon_jtag_uart_init>
 90964d4:	01024374 	movhi	r4,2317
 90964d8:	21091704 	addi	r4,r4,9308
 90964dc:	909670c0 	call	909670c <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 90964e0:	01024374 	movhi	r4,2317
 90964e4:	210d3c04 	addi	r4,r4,13552
 90964e8:	9099ff00 	call	9099ff0 <altera_avalon_lcd_16207_init>
 90964ec:	01024374 	movhi	r4,2317
 90964f0:	210d3204 	addi	r4,r4,13512
 90964f4:	909670c0 	call	909670c <alt_dev_reg>
    ALTERA_AVALON_PERFORMANCE_COUNTER_INIT ( PERFORMANCE_COUNTER, performance_counter);
 90964f8:	00c20034 	movhi	r3,2048
 90964fc:	00800044 	movi	r2,1
 9096500:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 9096504:	01024374 	movhi	r4,2317
 9096508:	210d7b04 	addi	r4,r4,13804
 909650c:	000b883a 	mov	r5,zero
 9096510:	018000c4 	movi	r6,3
 9096514:	909aefc0 	call	909aefc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 9096518:	01024374 	movhi	r4,2317
 909651c:	210d8704 	addi	r4,r4,13852
 9096520:	000b883a 	mov	r5,zero
 9096524:	01800084 	movi	r6,2
 9096528:	909aefc0 	call	909aefc <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 909652c:	e03fff15 	stw	zero,-4(fp)
 9096530:	00800044 	movi	r2,1
 9096534:	e0bffe15 	stw	r2,-8(fp)
 9096538:	e0bffe17 	ldw	r2,-8(fp)
 909653c:	10800048 	cmpgei	r2,r2,1
 9096540:	1000021e 	bne	r2,zero,909654c <alt_sys_init+0xc0>
 9096544:	00800044 	movi	r2,1
 9096548:	e0bffe15 	stw	r2,-8(fp)
 909654c:	e03fff15 	stw	zero,-4(fp)
 9096550:	00006606 	br	90966ec <alt_sys_init+0x260>
 9096554:	e0bfff17 	ldw	r2,-4(fp)
 9096558:	00c243b4 	movhi	r3,2318
 909655c:	18f48904 	addi	r3,r3,-11740
 9096560:	10800724 	muli	r2,r2,28
 9096564:	10c5883a 	add	r2,r2,r3
 9096568:	10000015 	stw	zero,0(r2)
 909656c:	e0bfff17 	ldw	r2,-4(fp)
 9096570:	00c243b4 	movhi	r3,2318
 9096574:	18f48904 	addi	r3,r3,-11740
 9096578:	10800724 	muli	r2,r2,28
 909657c:	10c5883a 	add	r2,r2,r3
 9096580:	10800104 	addi	r2,r2,4
 9096584:	10000015 	stw	zero,0(r2)
 9096588:	e0bfff17 	ldw	r2,-4(fp)
 909658c:	d1202717 	ldw	r4,-32612(gp)
 9096590:	00c243b4 	movhi	r3,2318
 9096594:	18f48904 	addi	r3,r3,-11740
 9096598:	10800724 	muli	r2,r2,28
 909659c:	10c5883a 	add	r2,r2,r3
 90965a0:	10800204 	addi	r2,r2,8
 90965a4:	11000015 	stw	r4,0(r2)
 90965a8:	e0bfff17 	ldw	r2,-4(fp)
 90965ac:	00c243b4 	movhi	r3,2318
 90965b0:	18f48904 	addi	r3,r3,-11740
 90965b4:	10800724 	muli	r2,r2,28
 90965b8:	10c5883a 	add	r2,r2,r3
 90965bc:	10c00304 	addi	r3,r2,12
 90965c0:	008242b4 	movhi	r2,2314
 90965c4:	1080fa04 	addi	r2,r2,1000
 90965c8:	18800015 	stw	r2,0(r3)
 90965cc:	e0bfff17 	ldw	r2,-4(fp)
 90965d0:	10c00724 	muli	r3,r2,28
 90965d4:	008243b4 	movhi	r2,2318
 90965d8:	10b48904 	addi	r2,r2,-11740
 90965dc:	1887883a 	add	r3,r3,r2
 90965e0:	00824374 	movhi	r2,2317
 90965e4:	108eb104 	addi	r2,r2,15044
 90965e8:	e0bffc15 	stw	r2,-16(fp)
 90965ec:	e0fffd15 	stw	r3,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 90965f0:	e0fffd17 	ldw	r3,-12(fp)
 90965f4:	e0bffc17 	ldw	r2,-16(fp)
 90965f8:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 90965fc:	e0bffc17 	ldw	r2,-16(fp)
 9096600:	10c00017 	ldw	r3,0(r2)
 9096604:	e0bffd17 	ldw	r2,-12(fp)
 9096608:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 909660c:	e0bffc17 	ldw	r2,-16(fp)
 9096610:	10c00017 	ldw	r3,0(r2)
 9096614:	e0bffd17 	ldw	r2,-12(fp)
 9096618:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 909661c:	e0fffc17 	ldw	r3,-16(fp)
 9096620:	e0bffd17 	ldw	r2,-12(fp)
 9096624:	18800015 	stw	r2,0(r3)
 9096628:	00824374 	movhi	r2,2317
 909662c:	108f0604 	addi	r2,r2,15384
 9096630:	10800003 	ldbu	r2,0(r2)
 9096634:	11403fcc 	andi	r5,r2,255
 9096638:	e0bfff17 	ldw	r2,-4(fp)
 909663c:	10c00724 	muli	r3,r2,28
 9096640:	008243b4 	movhi	r2,2318
 9096644:	10b48904 	addi	r2,r2,-11740
 9096648:	1889883a 	add	r4,r3,r2
 909664c:	00c243b4 	movhi	r3,2318
 9096650:	18f4c904 	addi	r3,r3,-11484
 9096654:	28800324 	muli	r2,r5,12
 9096658:	10c5883a 	add	r2,r2,r3
 909665c:	11000015 	stw	r4,0(r2)
 9096660:	00824374 	movhi	r2,2317
 9096664:	108f0604 	addi	r2,r2,15384
 9096668:	10800003 	ldbu	r2,0(r2)
 909666c:	10803fcc 	andi	r2,r2,255
 9096670:	00c243b4 	movhi	r3,2318
 9096674:	18f4c904 	addi	r3,r3,-11484
 9096678:	10800324 	muli	r2,r2,12
 909667c:	10c5883a 	add	r2,r2,r3
 9096680:	10c00104 	addi	r3,r2,4
 9096684:	00824434 	movhi	r2,2320
 9096688:	108c0004 	addi	r2,r2,12288
 909668c:	18800015 	stw	r2,0(r3)
 9096690:	00824374 	movhi	r2,2317
 9096694:	108f0604 	addi	r2,r2,15384
 9096698:	10800003 	ldbu	r2,0(r2)
 909669c:	11003fcc 	andi	r4,r2,255
 90966a0:	e0bfff17 	ldw	r2,-4(fp)
 90966a4:	100b883a 	mov	r5,r2
 90966a8:	00c243b4 	movhi	r3,2318
 90966ac:	18f4c904 	addi	r3,r3,-11484
 90966b0:	20800324 	muli	r2,r4,12
 90966b4:	10c5883a 	add	r2,r2,r3
 90966b8:	10800204 	addi	r2,r2,8
 90966bc:	11400005 	stb	r5,0(r2)
 90966c0:	00824374 	movhi	r2,2317
 90966c4:	108f0604 	addi	r2,r2,15384
 90966c8:	10800003 	ldbu	r2,0(r2)
 90966cc:	10800044 	addi	r2,r2,1
 90966d0:	1007883a 	mov	r3,r2
 90966d4:	00824374 	movhi	r2,2317
 90966d8:	108f0604 	addi	r2,r2,15384
 90966dc:	10c00005 	stb	r3,0(r2)
 90966e0:	e0bfff17 	ldw	r2,-4(fp)
 90966e4:	10800044 	addi	r2,r2,1
 90966e8:	e0bfff15 	stw	r2,-4(fp)
 90966ec:	e0ffff17 	ldw	r3,-4(fp)
 90966f0:	e0bffe17 	ldw	r2,-8(fp)
 90966f4:	18bf9716 	blt	r3,r2,9096554 <alt_sys_init+0xc8>
}
 90966f8:	e037883a 	mov	sp,fp
 90966fc:	dfc00117 	ldw	ra,4(sp)
 9096700:	df000017 	ldw	fp,0(sp)
 9096704:	dec00204 	addi	sp,sp,8
 9096708:	f800283a 	ret

0909670c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 909670c:	defffd04 	addi	sp,sp,-12
 9096710:	dfc00215 	stw	ra,8(sp)
 9096714:	df000115 	stw	fp,4(sp)
 9096718:	df000104 	addi	fp,sp,4
 909671c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 9096720:	e13fff17 	ldw	r4,-4(fp)
 9096724:	01424374 	movhi	r5,2317
 9096728:	294ec704 	addi	r5,r5,15132
 909672c:	90b9ce00 	call	90b9ce0 <alt_dev_llist_insert>
}
 9096730:	e037883a 	mov	sp,fp
 9096734:	dfc00117 	ldw	ra,4(sp)
 9096738:	df000017 	ldw	fp,0(sp)
 909673c:	dec00204 	addi	sp,sp,8
 9096740:	f800283a 	ret

09096744 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 9096744:	defffc04 	addi	sp,sp,-16
 9096748:	dfc00315 	stw	ra,12(sp)
 909674c:	df000215 	stw	fp,8(sp)
 9096750:	df000204 	addi	fp,sp,8
 9096754:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 9096758:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 909675c:	e13fff17 	ldw	r4,-4(fp)
 9096760:	9097c3c0 	call	9097c3c <alt_read_cfi_width>
 9096764:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9096768:	e0bffe17 	ldw	r2,-8(fp)
 909676c:	1004c03a 	cmpne	r2,r2,zero
 9096770:	1000031e 	bne	r2,zero,9096780 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 9096774:	e13fff17 	ldw	r4,-4(fp)
 9096778:	90973540 	call	9097354 <alt_set_flash_width_func>
 909677c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 9096780:	e0bffe17 	ldw	r2,-8(fp)
 9096784:	1004c03a 	cmpne	r2,r2,zero
 9096788:	1000031e 	bne	r2,zero,9096798 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 909678c:	e13fff17 	ldw	r4,-4(fp)
 9096790:	909765c0 	call	909765c <alt_read_cfi_table>
 9096794:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 9096798:	e0bffe17 	ldw	r2,-8(fp)
 909679c:	1004c03a 	cmpne	r2,r2,zero
 90967a0:	1000031e 	bne	r2,zero,90967b0 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 90967a4:	e13fff17 	ldw	r4,-4(fp)
 90967a8:	90975340 	call	9097534 <alt_set_flash_algorithm_func>
 90967ac:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 90967b0:	e0bffe17 	ldw	r2,-8(fp)
 90967b4:	1004c03a 	cmpne	r2,r2,zero
 90967b8:	1000031e 	bne	r2,zero,90967c8 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 90967bc:	e13fff17 	ldw	r4,-4(fp)
 90967c0:	90967e00 	call	90967e0 <alt_flash_device_register>
 90967c4:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 90967c8:	e0bffe17 	ldw	r2,-8(fp)
}
 90967cc:	e037883a 	mov	sp,fp
 90967d0:	dfc00117 	ldw	ra,4(sp)
 90967d4:	df000017 	ldw	fp,0(sp)
 90967d8:	dec00204 	addi	sp,sp,8
 90967dc:	f800283a 	ret

090967e0 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 90967e0:	defffd04 	addi	sp,sp,-12
 90967e4:	dfc00215 	stw	ra,8(sp)
 90967e8:	df000115 	stw	fp,4(sp)
 90967ec:	df000104 	addi	fp,sp,4
 90967f0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 90967f4:	e13fff17 	ldw	r4,-4(fp)
 90967f8:	01424374 	movhi	r5,2317
 90967fc:	294ecb04 	addi	r5,r5,15148
 9096800:	90b9ce00 	call	90b9ce0 <alt_dev_llist_insert>
}
 9096804:	e037883a 	mov	sp,fp
 9096808:	dfc00117 	ldw	ra,4(sp)
 909680c:	df000017 	ldw	fp,0(sp)
 9096810:	dec00204 	addi	sp,sp,8
 9096814:	f800283a 	ret

09096818 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 9096818:	deffef04 	addi	sp,sp,-68
 909681c:	dfc01015 	stw	ra,64(sp)
 9096820:	df000f15 	stw	fp,60(sp)
 9096824:	df000f04 	addi	fp,sp,60
 9096828:	e13ffa15 	stw	r4,-24(fp)
 909682c:	e17ffb15 	stw	r5,-20(fp)
 9096830:	e1bffc15 	stw	r6,-16(fp)
 9096834:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 9096838:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 909683c:	e0bffd17 	ldw	r2,-12(fp)
 9096840:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 9096844:	e0bffb17 	ldw	r2,-20(fp)
 9096848:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 909684c:	e0bffa17 	ldw	r2,-24(fp)
 9096850:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9096854:	e03ff815 	stw	zero,-32(fp)
 9096858:	00008e06 	br	9096a94 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 909685c:	e0bff817 	ldw	r2,-32(fp)
 9096860:	e0fff217 	ldw	r3,-56(fp)
 9096864:	1004913a 	slli	r2,r2,4
 9096868:	10c5883a 	add	r2,r2,r3
 909686c:	10800d04 	addi	r2,r2,52
 9096870:	10c00017 	ldw	r3,0(r2)
 9096874:	e0bffb17 	ldw	r2,-20(fp)
 9096878:	10c08316 	blt	r2,r3,9096a88 <alt_flash_cfi_write+0x270>
 909687c:	e0bff817 	ldw	r2,-32(fp)
 9096880:	e0fff217 	ldw	r3,-56(fp)
 9096884:	1004913a 	slli	r2,r2,4
 9096888:	10c5883a 	add	r2,r2,r3
 909688c:	10800d04 	addi	r2,r2,52
 9096890:	11000017 	ldw	r4,0(r2)
 9096894:	e0bff817 	ldw	r2,-32(fp)
 9096898:	e0fff217 	ldw	r3,-56(fp)
 909689c:	1004913a 	slli	r2,r2,4
 90968a0:	10c5883a 	add	r2,r2,r3
 90968a4:	10800e04 	addi	r2,r2,56
 90968a8:	10800017 	ldw	r2,0(r2)
 90968ac:	2087883a 	add	r3,r4,r2
 90968b0:	e0bffb17 	ldw	r2,-20(fp)
 90968b4:	10c0740e 	bge	r2,r3,9096a88 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 90968b8:	e0bff817 	ldw	r2,-32(fp)
 90968bc:	e0fff217 	ldw	r3,-56(fp)
 90968c0:	1004913a 	slli	r2,r2,4
 90968c4:	10c5883a 	add	r2,r2,r3
 90968c8:	10800d04 	addi	r2,r2,52
 90968cc:	10800017 	ldw	r2,0(r2)
 90968d0:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 90968d4:	e03ff715 	stw	zero,-36(fp)
 90968d8:	00006306 	br	9096a68 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 90968dc:	e0fffb17 	ldw	r3,-20(fp)
 90968e0:	e0bff417 	ldw	r2,-48(fp)
 90968e4:	18805416 	blt	r3,r2,9096a38 <alt_flash_cfi_write+0x220>
 90968e8:	e0bff817 	ldw	r2,-32(fp)
 90968ec:	e0fff217 	ldw	r3,-56(fp)
 90968f0:	1004913a 	slli	r2,r2,4
 90968f4:	10c5883a 	add	r2,r2,r3
 90968f8:	10801004 	addi	r2,r2,64
 90968fc:	10c00017 	ldw	r3,0(r2)
 9096900:	e0bff417 	ldw	r2,-48(fp)
 9096904:	1887883a 	add	r3,r3,r2
 9096908:	e0bffb17 	ldw	r2,-20(fp)
 909690c:	10c04a0e 	bge	r2,r3,9096a38 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 9096910:	e0bff817 	ldw	r2,-32(fp)
 9096914:	e0fff217 	ldw	r3,-56(fp)
 9096918:	1004913a 	slli	r2,r2,4
 909691c:	10c5883a 	add	r2,r2,r3
 9096920:	10801004 	addi	r2,r2,64
 9096924:	10c00017 	ldw	r3,0(r2)
 9096928:	e0bff417 	ldw	r2,-48(fp)
 909692c:	1887883a 	add	r3,r3,r2
 9096930:	e0bffb17 	ldw	r2,-20(fp)
 9096934:	1885c83a 	sub	r2,r3,r2
 9096938:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 909693c:	e0bff617 	ldw	r2,-40(fp)
 9096940:	e0bfff15 	stw	r2,-4(fp)
 9096944:	e0fffd17 	ldw	r3,-12(fp)
 9096948:	e0fffe15 	stw	r3,-8(fp)
 909694c:	e0bfff17 	ldw	r2,-4(fp)
 9096950:	e0fffe17 	ldw	r3,-8(fp)
 9096954:	10c0020e 	bge	r2,r3,9096960 <alt_flash_cfi_write+0x148>
 9096958:	e0bfff17 	ldw	r2,-4(fp)
 909695c:	e0bffe15 	stw	r2,-8(fp)
 9096960:	e0fffe17 	ldw	r3,-8(fp)
 9096964:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 9096968:	e0bff217 	ldw	r2,-56(fp)
 909696c:	10800a17 	ldw	r2,40(r2)
 9096970:	1007883a 	mov	r3,r2
 9096974:	e0bffb17 	ldw	r2,-20(fp)
 9096978:	188b883a 	add	r5,r3,r2
 909697c:	e1bff617 	ldw	r6,-40(fp)
 9096980:	e13ffc17 	ldw	r4,-16(fp)
 9096984:	90cb4540 	call	90cb454 <memcmp>
 9096988:	1005003a 	cmpeq	r2,r2,zero
 909698c:	1000131e 	bne	r2,zero,90969dc <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 9096990:	e0bff217 	ldw	r2,-56(fp)
 9096994:	10800817 	ldw	r2,32(r2)
 9096998:	e13ff217 	ldw	r4,-56(fp)
 909699c:	e17ff417 	ldw	r5,-48(fp)
 90969a0:	103ee83a 	callr	r2
 90969a4:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 90969a8:	e0bff917 	ldw	r2,-28(fp)
 90969ac:	1004c03a 	cmpne	r2,r2,zero
 90969b0:	10000a1e 	bne	r2,zero,90969dc <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 90969b4:	e0bff217 	ldw	r2,-56(fp)
 90969b8:	10c00917 	ldw	r3,36(r2)
 90969bc:	e13ff217 	ldw	r4,-56(fp)
 90969c0:	e0bff617 	ldw	r2,-40(fp)
 90969c4:	d8800015 	stw	r2,0(sp)
 90969c8:	e17ff417 	ldw	r5,-48(fp)
 90969cc:	e1bffb17 	ldw	r6,-20(fp)
 90969d0:	e1fffc17 	ldw	r7,-16(fp)
 90969d4:	183ee83a 	callr	r3
 90969d8:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 90969dc:	e0fffd17 	ldw	r3,-12(fp)
 90969e0:	e0bff617 	ldw	r2,-40(fp)
 90969e4:	18802f26 	beq	r3,r2,9096aa4 <alt_flash_cfi_write+0x28c>
 90969e8:	e0bff917 	ldw	r2,-28(fp)
 90969ec:	1004c03a 	cmpne	r2,r2,zero
 90969f0:	10002c1e 	bne	r2,zero,9096aa4 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 90969f4:	e0fffd17 	ldw	r3,-12(fp)
 90969f8:	e0bff617 	ldw	r2,-40(fp)
 90969fc:	1885c83a 	sub	r2,r3,r2
 9096a00:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 9096a04:	e0bff817 	ldw	r2,-32(fp)
 9096a08:	e0fff217 	ldw	r3,-56(fp)
 9096a0c:	1004913a 	slli	r2,r2,4
 9096a10:	10c5883a 	add	r2,r2,r3
 9096a14:	10801004 	addi	r2,r2,64
 9096a18:	10c00017 	ldw	r3,0(r2)
 9096a1c:	e0bff417 	ldw	r2,-48(fp)
 9096a20:	1885883a 	add	r2,r3,r2
 9096a24:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 9096a28:	e0fffc17 	ldw	r3,-16(fp)
 9096a2c:	e0bff617 	ldw	r2,-40(fp)
 9096a30:	1885883a 	add	r2,r3,r2
 9096a34:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 9096a38:	e0bff817 	ldw	r2,-32(fp)
 9096a3c:	e0fff217 	ldw	r3,-56(fp)
 9096a40:	1004913a 	slli	r2,r2,4
 9096a44:	10c5883a 	add	r2,r2,r3
 9096a48:	10801004 	addi	r2,r2,64
 9096a4c:	10c00017 	ldw	r3,0(r2)
 9096a50:	e0bff417 	ldw	r2,-48(fp)
 9096a54:	10c5883a 	add	r2,r2,r3
 9096a58:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 9096a5c:	e0bff717 	ldw	r2,-36(fp)
 9096a60:	10800044 	addi	r2,r2,1
 9096a64:	e0bff715 	stw	r2,-36(fp)
 9096a68:	e0bff817 	ldw	r2,-32(fp)
 9096a6c:	e0fff217 	ldw	r3,-56(fp)
 9096a70:	1004913a 	slli	r2,r2,4
 9096a74:	10c5883a 	add	r2,r2,r3
 9096a78:	10800f04 	addi	r2,r2,60
 9096a7c:	10c00017 	ldw	r3,0(r2)
 9096a80:	e0bff717 	ldw	r2,-36(fp)
 9096a84:	10ff9516 	blt	r2,r3,90968dc <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 9096a88:	e0bff817 	ldw	r2,-32(fp)
 9096a8c:	10800044 	addi	r2,r2,1
 9096a90:	e0bff815 	stw	r2,-32(fp)
 9096a94:	e0bff217 	ldw	r2,-56(fp)
 9096a98:	10c00c17 	ldw	r3,48(r2)
 9096a9c:	e0bff817 	ldw	r2,-32(fp)
 9096aa0:	10ff6e16 	blt	r2,r3,909685c <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 9096aa4:	e0bff217 	ldw	r2,-56(fp)
 9096aa8:	10800a17 	ldw	r2,40(r2)
 9096aac:	1007883a 	mov	r3,r2
 9096ab0:	e0bff317 	ldw	r2,-52(fp)
 9096ab4:	1889883a 	add	r4,r3,r2
 9096ab8:	e17ff517 	ldw	r5,-44(fp)
 9096abc:	90b9c3c0 	call	90b9c3c <alt_dcache_flush>
  return ret_code;
 9096ac0:	e0bff917 	ldw	r2,-28(fp)
}
 9096ac4:	e037883a 	mov	sp,fp
 9096ac8:	dfc00117 	ldw	ra,4(sp)
 9096acc:	df000017 	ldw	fp,0(sp)
 9096ad0:	dec00204 	addi	sp,sp,8
 9096ad4:	f800283a 	ret

09096ad8 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 9096ad8:	defffa04 	addi	sp,sp,-24
 9096adc:	df000515 	stw	fp,20(sp)
 9096ae0:	df000504 	addi	fp,sp,20
 9096ae4:	e13ffd15 	stw	r4,-12(fp)
 9096ae8:	e17ffe15 	stw	r5,-8(fp)
 9096aec:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 9096af0:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 9096af4:	e0bffd17 	ldw	r2,-12(fp)
 9096af8:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 9096afc:	e0bffb17 	ldw	r2,-20(fp)
 9096b00:	10c00c17 	ldw	r3,48(r2)
 9096b04:	e0bfff17 	ldw	r2,-4(fp)
 9096b08:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 9096b0c:	e0bffb17 	ldw	r2,-20(fp)
 9096b10:	10800c17 	ldw	r2,48(r2)
 9096b14:	1004c03a 	cmpne	r2,r2,zero
 9096b18:	1000031e 	bne	r2,zero,9096b28 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 9096b1c:	00bffec4 	movi	r2,-5
 9096b20:	e0bffc15 	stw	r2,-16(fp)
 9096b24:	00000b06 	br	9096b54 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 9096b28:	e0bffb17 	ldw	r2,-20(fp)
 9096b2c:	10800c17 	ldw	r2,48(r2)
 9096b30:	10800250 	cmplti	r2,r2,9
 9096b34:	1000031e 	bne	r2,zero,9096b44 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 9096b38:	00bffd04 	movi	r2,-12
 9096b3c:	e0bffc15 	stw	r2,-16(fp)
 9096b40:	00000406 	br	9096b54 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 9096b44:	e0bffb17 	ldw	r2,-20(fp)
 9096b48:	10c00d04 	addi	r3,r2,52
 9096b4c:	e0bffe17 	ldw	r2,-8(fp)
 9096b50:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 9096b54:	e0bffc17 	ldw	r2,-16(fp)
}
 9096b58:	e037883a 	mov	sp,fp
 9096b5c:	df000017 	ldw	fp,0(sp)
 9096b60:	dec00104 	addi	sp,sp,4
 9096b64:	f800283a 	ret

09096b68 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 9096b68:	defff904 	addi	sp,sp,-28
 9096b6c:	dfc00615 	stw	ra,24(sp)
 9096b70:	df000515 	stw	fp,20(sp)
 9096b74:	df000504 	addi	fp,sp,20
 9096b78:	e13ffc15 	stw	r4,-16(fp)
 9096b7c:	e17ffd15 	stw	r5,-12(fp)
 9096b80:	e1bffe15 	stw	r6,-8(fp)
 9096b84:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 9096b88:	e0bffc17 	ldw	r2,-16(fp)
 9096b8c:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 9096b90:	e0bffb17 	ldw	r2,-20(fp)
 9096b94:	10800a17 	ldw	r2,40(r2)
 9096b98:	1007883a 	mov	r3,r2
 9096b9c:	e0bffd17 	ldw	r2,-12(fp)
 9096ba0:	1887883a 	add	r3,r3,r2
 9096ba4:	e1bfff17 	ldw	r6,-4(fp)
 9096ba8:	e0bffe17 	ldw	r2,-8(fp)
 9096bac:	1009883a 	mov	r4,r2
 9096bb0:	180b883a 	mov	r5,r3
 9096bb4:	90894600 	call	9089460 <memcpy>
  return 0;
 9096bb8:	0005883a 	mov	r2,zero
}
 9096bbc:	e037883a 	mov	sp,fp
 9096bc0:	dfc00117 	ldw	ra,4(sp)
 9096bc4:	df000017 	ldw	fp,0(sp)
 9096bc8:	dec00204 	addi	sp,sp,8
 9096bcc:	f800283a 	ret

09096bd0 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 9096bd0:	defffa04 	addi	sp,sp,-24
 9096bd4:	df000515 	stw	fp,20(sp)
 9096bd8:	df000504 	addi	fp,sp,20
 9096bdc:	e13ffd15 	stw	r4,-12(fp)
 9096be0:	e17ffe15 	stw	r5,-8(fp)
 9096be4:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 9096be8:	e0bffd17 	ldw	r2,-12(fp)
 9096bec:	10802e17 	ldw	r2,184(r2)
 9096bf0:	10800058 	cmpnei	r2,r2,1
 9096bf4:	10000b1e 	bne	r2,zero,9096c24 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 9096bf8:	e0bffd17 	ldw	r2,-12(fp)
 9096bfc:	10800a17 	ldw	r2,40(r2)
 9096c00:	1007883a 	mov	r3,r2
 9096c04:	e0bffe17 	ldw	r2,-8(fp)
 9096c08:	1889883a 	add	r4,r3,r2
 9096c0c:	e0bfff17 	ldw	r2,-4(fp)
 9096c10:	10800003 	ldbu	r2,0(r2)
 9096c14:	10c03fcc 	andi	r3,r2,255
 9096c18:	2005883a 	mov	r2,r4
 9096c1c:	10c00025 	stbio	r3,0(r2)
 9096c20:	00004006 	br	9096d24 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 9096c24:	e0bffd17 	ldw	r2,-12(fp)
 9096c28:	10802e17 	ldw	r2,184(r2)
 9096c2c:	10800098 	cmpnei	r2,r2,2
 9096c30:	1000151e 	bne	r2,zero,9096c88 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 9096c34:	e0bfff17 	ldw	r2,-4(fp)
 9096c38:	10800003 	ldbu	r2,0(r2)
 9096c3c:	10803fcc 	andi	r2,r2,255
 9096c40:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 9096c44:	e0bfff17 	ldw	r2,-4(fp)
 9096c48:	10800044 	addi	r2,r2,1
 9096c4c:	10800003 	ldbu	r2,0(r2)
 9096c50:	10803fcc 	andi	r2,r2,255
 9096c54:	1004923a 	slli	r2,r2,8
 9096c58:	1007883a 	mov	r3,r2
 9096c5c:	e0bffc0b 	ldhu	r2,-16(fp)
 9096c60:	1884b03a 	or	r2,r3,r2
 9096c64:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 9096c68:	e0bffd17 	ldw	r2,-12(fp)
 9096c6c:	10800a17 	ldw	r2,40(r2)
 9096c70:	1007883a 	mov	r3,r2
 9096c74:	e0bffe17 	ldw	r2,-8(fp)
 9096c78:	1885883a 	add	r2,r3,r2
 9096c7c:	e0fffc0b 	ldhu	r3,-16(fp)
 9096c80:	10c0002d 	sthio	r3,0(r2)
 9096c84:	00002706 	br	9096d24 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 9096c88:	e0bffd17 	ldw	r2,-12(fp)
 9096c8c:	10802e17 	ldw	r2,184(r2)
 9096c90:	10800118 	cmpnei	r2,r2,4
 9096c94:	1000231e 	bne	r2,zero,9096d24 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 9096c98:	e0bfff17 	ldw	r2,-4(fp)
 9096c9c:	10800003 	ldbu	r2,0(r2)
 9096ca0:	10803fcc 	andi	r2,r2,255
 9096ca4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 9096ca8:	e0bfff17 	ldw	r2,-4(fp)
 9096cac:	10800044 	addi	r2,r2,1
 9096cb0:	10800003 	ldbu	r2,0(r2)
 9096cb4:	10803fcc 	andi	r2,r2,255
 9096cb8:	1006923a 	slli	r3,r2,8
 9096cbc:	e0bffb17 	ldw	r2,-20(fp)
 9096cc0:	10c4b03a 	or	r2,r2,r3
 9096cc4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 9096cc8:	e0bfff17 	ldw	r2,-4(fp)
 9096ccc:	10800084 	addi	r2,r2,2
 9096cd0:	10800003 	ldbu	r2,0(r2)
 9096cd4:	10803fcc 	andi	r2,r2,255
 9096cd8:	1006943a 	slli	r3,r2,16
 9096cdc:	e0bffb17 	ldw	r2,-20(fp)
 9096ce0:	10c4b03a 	or	r2,r2,r3
 9096ce4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 9096ce8:	e0bfff17 	ldw	r2,-4(fp)
 9096cec:	108000c4 	addi	r2,r2,3
 9096cf0:	10800003 	ldbu	r2,0(r2)
 9096cf4:	10803fcc 	andi	r2,r2,255
 9096cf8:	1006963a 	slli	r3,r2,24
 9096cfc:	e0bffb17 	ldw	r2,-20(fp)
 9096d00:	10c4b03a 	or	r2,r2,r3
 9096d04:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 9096d08:	e0bffd17 	ldw	r2,-12(fp)
 9096d0c:	10800a17 	ldw	r2,40(r2)
 9096d10:	1007883a 	mov	r3,r2
 9096d14:	e0bffe17 	ldw	r2,-8(fp)
 9096d18:	1885883a 	add	r2,r3,r2
 9096d1c:	e0fffb17 	ldw	r3,-20(fp)
 9096d20:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 9096d24:	e037883a 	mov	sp,fp
 9096d28:	df000017 	ldw	fp,0(sp)
 9096d2c:	dec00104 	addi	sp,sp,4
 9096d30:	f800283a 	ret

09096d34 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 9096d34:	defff304 	addi	sp,sp,-52
 9096d38:	dfc00c15 	stw	ra,48(sp)
 9096d3c:	df000b15 	stw	fp,44(sp)
 9096d40:	df000b04 	addi	fp,sp,44
 9096d44:	e13ffc15 	stw	r4,-16(fp)
 9096d48:	e17ffd15 	stw	r5,-12(fp)
 9096d4c:	e1bffe15 	stw	r6,-8(fp)
 9096d50:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 9096d54:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 9096d58:	e0bffc17 	ldw	r2,-16(fp)
 9096d5c:	10800a17 	ldw	r2,40(r2)
 9096d60:	1007883a 	mov	r3,r2
 9096d64:	e0bffd17 	ldw	r2,-12(fp)
 9096d68:	1885883a 	add	r2,r3,r2
 9096d6c:	1009883a 	mov	r4,r2
 9096d70:	e0bffc17 	ldw	r2,-16(fp)
 9096d74:	10c02e17 	ldw	r3,184(r2)
 9096d78:	20c5283a 	div	r2,r4,r3
 9096d7c:	10c5383a 	mul	r2,r2,r3
 9096d80:	2085c83a 	sub	r2,r4,r2
 9096d84:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 9096d88:	e0bff917 	ldw	r2,-28(fp)
 9096d8c:	1005003a 	cmpeq	r2,r2,zero
 9096d90:	10003a1e 	bne	r2,zero,9096e7c <alt_flash_program_block+0x148>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 9096d94:	e0bffc17 	ldw	r2,-16(fp)
 9096d98:	10c02e17 	ldw	r3,184(r2)
 9096d9c:	e0bff917 	ldw	r2,-28(fp)
 9096da0:	1885c83a 	sub	r2,r3,r2
 9096da4:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9096da8:	e03ff615 	stw	zero,-40(fp)
 9096dac:	00001206 	br	9096df8 <alt_flash_program_block+0xc4>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 9096db0:	e17ff617 	ldw	r5,-40(fp)
 9096db4:	e0bffc17 	ldw	r2,-16(fp)
 9096db8:	10800a17 	ldw	r2,40(r2)
 9096dbc:	1009883a 	mov	r4,r2
 9096dc0:	e0fffd17 	ldw	r3,-12(fp)
 9096dc4:	e0bff917 	ldw	r2,-28(fp)
 9096dc8:	1887c83a 	sub	r3,r3,r2
 9096dcc:	e0bff617 	ldw	r2,-40(fp)
 9096dd0:	1885883a 	add	r2,r3,r2
 9096dd4:	2085883a 	add	r2,r4,r2
 9096dd8:	10800023 	ldbuio	r2,0(r2)
 9096ddc:	1007883a 	mov	r3,r2
 9096de0:	e0bffb04 	addi	r2,fp,-20
 9096de4:	1145883a 	add	r2,r2,r5
 9096de8:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 9096dec:	e0bff617 	ldw	r2,-40(fp)
 9096df0:	10800044 	addi	r2,r2,1
 9096df4:	e0bff615 	stw	r2,-40(fp)
 9096df8:	e0fff617 	ldw	r3,-40(fp)
 9096dfc:	e0bff917 	ldw	r2,-28(fp)
 9096e00:	18bfeb16 	blt	r3,r2,9096db0 <alt_flash_program_block+0x7c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9096e04:	e03ff615 	stw	zero,-40(fp)
 9096e08:	00000e06 	br	9096e44 <alt_flash_program_block+0x110>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 9096e0c:	e0fff917 	ldw	r3,-28(fp)
 9096e10:	e0bff617 	ldw	r2,-40(fp)
 9096e14:	1889883a 	add	r4,r3,r2
 9096e18:	e0bff617 	ldw	r2,-40(fp)
 9096e1c:	1007883a 	mov	r3,r2
 9096e20:	e0bffe17 	ldw	r2,-8(fp)
 9096e24:	1885883a 	add	r2,r3,r2
 9096e28:	10c00003 	ldbu	r3,0(r2)
 9096e2c:	e0bffb04 	addi	r2,fp,-20
 9096e30:	1105883a 	add	r2,r2,r4
 9096e34:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 9096e38:	e0bff617 	ldw	r2,-40(fp)
 9096e3c:	10800044 	addi	r2,r2,1
 9096e40:	e0bff615 	stw	r2,-40(fp)
 9096e44:	e0fff617 	ldw	r3,-40(fp)
 9096e48:	e0bff817 	ldw	r2,-32(fp)
 9096e4c:	18bfef16 	blt	r3,r2,9096e0c <alt_flash_program_block+0xd8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 9096e50:	e0fffd17 	ldw	r3,-12(fp)
 9096e54:	e0bff917 	ldw	r2,-28(fp)
 9096e58:	188bc83a 	sub	r5,r3,r2
 9096e5c:	e1bffb04 	addi	r6,fp,-20
 9096e60:	e0800217 	ldw	r2,8(fp)
 9096e64:	e13ffc17 	ldw	r4,-16(fp)
 9096e68:	103ee83a 	callr	r2
 9096e6c:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 9096e70:	e0bff817 	ldw	r2,-32(fp)
 9096e74:	e0bff615 	stw	r2,-40(fp)
 9096e78:	00000106 	br	9096e80 <alt_flash_program_block+0x14c>
  }
  else
  {
    i = 0;
 9096e7c:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 9096e80:	e0fffd17 	ldw	r3,-12(fp)
 9096e84:	e0bfff17 	ldw	r2,-4(fp)
 9096e88:	1889883a 	add	r4,r3,r2
 9096e8c:	e0bffc17 	ldw	r2,-16(fp)
 9096e90:	10c02e17 	ldw	r3,184(r2)
 9096e94:	20c5283a 	div	r2,r4,r3
 9096e98:	10c5383a 	mul	r2,r2,r3
 9096e9c:	2085c83a 	sub	r2,r4,r2
 9096ea0:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9096ea4:	00001006 	br	9096ee8 <alt_flash_program_block+0x1b4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 9096ea8:	e0fffd17 	ldw	r3,-12(fp)
 9096eac:	e0bff617 	ldw	r2,-40(fp)
 9096eb0:	188b883a 	add	r5,r3,r2
 9096eb4:	e0bff617 	ldw	r2,-40(fp)
 9096eb8:	1007883a 	mov	r3,r2
 9096ebc:	e0bffe17 	ldw	r2,-8(fp)
 9096ec0:	188d883a 	add	r6,r3,r2
 9096ec4:	e0800217 	ldw	r2,8(fp)
 9096ec8:	e13ffc17 	ldw	r4,-16(fp)
 9096ecc:	103ee83a 	callr	r2
 9096ed0:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 9096ed4:	e0bffc17 	ldw	r2,-16(fp)
 9096ed8:	10c02e17 	ldw	r3,184(r2)
 9096edc:	e0bff617 	ldw	r2,-40(fp)
 9096ee0:	10c5883a 	add	r2,r2,r3
 9096ee4:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 9096ee8:	e0bffa17 	ldw	r2,-24(fp)
 9096eec:	1004c03a 	cmpne	r2,r2,zero
 9096ef0:	1000051e 	bne	r2,zero,9096f08 <alt_flash_program_block+0x1d4>
 9096ef4:	e0ffff17 	ldw	r3,-4(fp)
 9096ef8:	e0bff717 	ldw	r2,-36(fp)
 9096efc:	1887c83a 	sub	r3,r3,r2
 9096f00:	e0bff617 	ldw	r2,-40(fp)
 9096f04:	10ffe816 	blt	r2,r3,9096ea8 <alt_flash_program_block+0x174>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 9096f08:	e0bff717 	ldw	r2,-36(fp)
 9096f0c:	1005003a 	cmpeq	r2,r2,zero
 9096f10:	10003c1e 	bne	r2,zero,9097004 <alt_flash_program_block+0x2d0>
 9096f14:	e0bffa17 	ldw	r2,-24(fp)
 9096f18:	1004c03a 	cmpne	r2,r2,zero
 9096f1c:	1000391e 	bne	r2,zero,9097004 <alt_flash_program_block+0x2d0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 9096f20:	e0bffc17 	ldw	r2,-16(fp)
 9096f24:	10c02e17 	ldw	r3,184(r2)
 9096f28:	e0bff717 	ldw	r2,-36(fp)
 9096f2c:	1885c83a 	sub	r2,r3,r2
 9096f30:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 9096f34:	e03ff515 	stw	zero,-44(fp)
 9096f38:	00000e06 	br	9096f74 <alt_flash_program_block+0x240>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 9096f3c:	e13ff517 	ldw	r4,-44(fp)
 9096f40:	e0bff617 	ldw	r2,-40(fp)
 9096f44:	1007883a 	mov	r3,r2
 9096f48:	e0bffe17 	ldw	r2,-8(fp)
 9096f4c:	1887883a 	add	r3,r3,r2
 9096f50:	e0bff517 	ldw	r2,-44(fp)
 9096f54:	1885883a 	add	r2,r3,r2
 9096f58:	10c00003 	ldbu	r3,0(r2)
 9096f5c:	e0bffb04 	addi	r2,fp,-20
 9096f60:	1105883a 	add	r2,r2,r4
 9096f64:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 9096f68:	e0bff517 	ldw	r2,-44(fp)
 9096f6c:	10800044 	addi	r2,r2,1
 9096f70:	e0bff515 	stw	r2,-44(fp)
 9096f74:	e0fff517 	ldw	r3,-44(fp)
 9096f78:	e0bff717 	ldw	r2,-36(fp)
 9096f7c:	18bfef16 	blt	r3,r2,9096f3c <alt_flash_program_block+0x208>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9096f80:	e03ff515 	stw	zero,-44(fp)
 9096f84:	00001406 	br	9096fd8 <alt_flash_program_block+0x2a4>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 9096f88:	e0fff717 	ldw	r3,-36(fp)
 9096f8c:	e0bff517 	ldw	r2,-44(fp)
 9096f90:	188b883a 	add	r5,r3,r2
 9096f94:	e0bffc17 	ldw	r2,-16(fp)
 9096f98:	10800a17 	ldw	r2,40(r2)
 9096f9c:	1009883a 	mov	r4,r2
 9096fa0:	e0fffd17 	ldw	r3,-12(fp)
 9096fa4:	e0bfff17 	ldw	r2,-4(fp)
 9096fa8:	1887883a 	add	r3,r3,r2
 9096fac:	e0bff517 	ldw	r2,-44(fp)
 9096fb0:	1885883a 	add	r2,r3,r2
 9096fb4:	2085883a 	add	r2,r4,r2
 9096fb8:	10800023 	ldbuio	r2,0(r2)
 9096fbc:	1007883a 	mov	r3,r2
 9096fc0:	e0bffb04 	addi	r2,fp,-20
 9096fc4:	1145883a 	add	r2,r2,r5
 9096fc8:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 9096fcc:	e0bff517 	ldw	r2,-44(fp)
 9096fd0:	10800044 	addi	r2,r2,1
 9096fd4:	e0bff515 	stw	r2,-44(fp)
 9096fd8:	e0fff517 	ldw	r3,-44(fp)
 9096fdc:	e0bff917 	ldw	r2,-28(fp)
 9096fe0:	18bfe916 	blt	r3,r2,9096f88 <alt_flash_program_block+0x254>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 9096fe4:	e0fffd17 	ldw	r3,-12(fp)
 9096fe8:	e0bff617 	ldw	r2,-40(fp)
 9096fec:	188b883a 	add	r5,r3,r2
 9096ff0:	e1bffb04 	addi	r6,fp,-20
 9096ff4:	e0800217 	ldw	r2,8(fp)
 9096ff8:	e13ffc17 	ldw	r4,-16(fp)
 9096ffc:	103ee83a 	callr	r2
 9097000:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 9097004:	e0bffa17 	ldw	r2,-24(fp)
}
 9097008:	e037883a 	mov	sp,fp
 909700c:	dfc00117 	ldw	ra,4(sp)
 9097010:	df000017 	ldw	fp,0(sp)
 9097014:	dec00204 	addi	sp,sp,8
 9097018:	f800283a 	ret

0909701c <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 909701c:	defffd04 	addi	sp,sp,-12
 9097020:	df000215 	stw	fp,8(sp)
 9097024:	df000204 	addi	fp,sp,8
 9097028:	e13ffe15 	stw	r4,-8(fp)
 909702c:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 9097030:	e0bffe17 	ldw	r2,-8(fp)
 9097034:	10800a17 	ldw	r2,40(r2)
 9097038:	1007883a 	mov	r3,r2
 909703c:	e0bfff17 	ldw	r2,-4(fp)
 9097040:	1885883a 	add	r2,r3,r2
 9097044:	10800023 	ldbuio	r2,0(r2)
 9097048:	10803fcc 	andi	r2,r2,255
}
 909704c:	e037883a 	mov	sp,fp
 9097050:	df000017 	ldw	fp,0(sp)
 9097054:	dec00104 	addi	sp,sp,4
 9097058:	f800283a 	ret

0909705c <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 909705c:	defffd04 	addi	sp,sp,-12
 9097060:	df000215 	stw	fp,8(sp)
 9097064:	df000204 	addi	fp,sp,8
 9097068:	e13ffe15 	stw	r4,-8(fp)
 909706c:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 9097070:	e0bffe17 	ldw	r2,-8(fp)
 9097074:	10800a17 	ldw	r2,40(r2)
 9097078:	1007883a 	mov	r3,r2
 909707c:	e0bfff17 	ldw	r2,-4(fp)
 9097080:	1085883a 	add	r2,r2,r2
 9097084:	1885883a 	add	r2,r3,r2
 9097088:	1080002b 	ldhuio	r2,0(r2)
 909708c:	10803fcc 	andi	r2,r2,255
}
 9097090:	e037883a 	mov	sp,fp
 9097094:	df000017 	ldw	fp,0(sp)
 9097098:	dec00104 	addi	sp,sp,4
 909709c:	f800283a 	ret

090970a0 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 90970a0:	defffd04 	addi	sp,sp,-12
 90970a4:	df000215 	stw	fp,8(sp)
 90970a8:	df000204 	addi	fp,sp,8
 90970ac:	e13ffe15 	stw	r4,-8(fp)
 90970b0:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 90970b4:	e0bffe17 	ldw	r2,-8(fp)
 90970b8:	10800a17 	ldw	r2,40(r2)
 90970bc:	1007883a 	mov	r3,r2
 90970c0:	e0bfff17 	ldw	r2,-4(fp)
 90970c4:	1085883a 	add	r2,r2,r2
 90970c8:	1085883a 	add	r2,r2,r2
 90970cc:	1885883a 	add	r2,r3,r2
 90970d0:	10800037 	ldwio	r2,0(r2)
 90970d4:	10803fcc 	andi	r2,r2,255
}
 90970d8:	e037883a 	mov	sp,fp
 90970dc:	df000017 	ldw	fp,0(sp)
 90970e0:	dec00104 	addi	sp,sp,4
 90970e4:	f800283a 	ret

090970e8 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90970e8:	defffc04 	addi	sp,sp,-16
 90970ec:	df000315 	stw	fp,12(sp)
 90970f0:	df000304 	addi	fp,sp,12
 90970f4:	e13ffd15 	stw	r4,-12(fp)
 90970f8:	e17ffe15 	stw	r5,-8(fp)
 90970fc:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 9097100:	e0fffd17 	ldw	r3,-12(fp)
 9097104:	e0bffe17 	ldw	r2,-8(fp)
 9097108:	1885883a 	add	r2,r3,r2
 909710c:	e0ffff03 	ldbu	r3,-4(fp)
 9097110:	10c00025 	stbio	r3,0(r2)
  return;
}
 9097114:	e037883a 	mov	sp,fp
 9097118:	df000017 	ldw	fp,0(sp)
 909711c:	dec00104 	addi	sp,sp,4
 9097120:	f800283a 	ret

09097124 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9097124:	defffc04 	addi	sp,sp,-16
 9097128:	df000315 	stw	fp,12(sp)
 909712c:	df000304 	addi	fp,sp,12
 9097130:	e13ffd15 	stw	r4,-12(fp)
 9097134:	e17ffe15 	stw	r5,-8(fp)
 9097138:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 909713c:	e0bffe17 	ldw	r2,-8(fp)
 9097140:	1080004c 	andi	r2,r2,1
 9097144:	10803fcc 	andi	r2,r2,255
 9097148:	1005003a 	cmpeq	r2,r2,zero
 909714c:	1000081e 	bne	r2,zero,9097170 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 9097150:	e0bffe17 	ldw	r2,-8(fp)
 9097154:	1085883a 	add	r2,r2,r2
 9097158:	1007883a 	mov	r3,r2
 909715c:	e0bffd17 	ldw	r2,-12(fp)
 9097160:	1885883a 	add	r2,r3,r2
 9097164:	e0ffff03 	ldbu	r3,-4(fp)
 9097168:	10c00025 	stbio	r3,0(r2)
 909716c:	00000806 	br	9097190 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 9097170:	e0bffe17 	ldw	r2,-8(fp)
 9097174:	1085883a 	add	r2,r2,r2
 9097178:	1007883a 	mov	r3,r2
 909717c:	e0bffd17 	ldw	r2,-12(fp)
 9097180:	1885883a 	add	r2,r3,r2
 9097184:	10800044 	addi	r2,r2,1
 9097188:	e0ffff03 	ldbu	r3,-4(fp)
 909718c:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 9097190:	e037883a 	mov	sp,fp
 9097194:	df000017 	ldw	fp,0(sp)
 9097198:	dec00104 	addi	sp,sp,4
 909719c:	f800283a 	ret

090971a0 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90971a0:	defffc04 	addi	sp,sp,-16
 90971a4:	df000315 	stw	fp,12(sp)
 90971a8:	df000304 	addi	fp,sp,12
 90971ac:	e13ffd15 	stw	r4,-12(fp)
 90971b0:	e17ffe15 	stw	r5,-8(fp)
 90971b4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 90971b8:	e0bffe17 	ldw	r2,-8(fp)
 90971bc:	1085883a 	add	r2,r2,r2
 90971c0:	1085883a 	add	r2,r2,r2
 90971c4:	1007883a 	mov	r3,r2
 90971c8:	e0bffd17 	ldw	r2,-12(fp)
 90971cc:	1885883a 	add	r2,r3,r2
 90971d0:	e0ffff03 	ldbu	r3,-4(fp)
 90971d4:	10c00025 	stbio	r3,0(r2)
  return;
}
 90971d8:	e037883a 	mov	sp,fp
 90971dc:	df000017 	ldw	fp,0(sp)
 90971e0:	dec00104 	addi	sp,sp,4
 90971e4:	f800283a 	ret

090971e8 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 90971e8:	defffc04 	addi	sp,sp,-16
 90971ec:	df000315 	stw	fp,12(sp)
 90971f0:	df000304 	addi	fp,sp,12
 90971f4:	e13ffd15 	stw	r4,-12(fp)
 90971f8:	e17ffe15 	stw	r5,-8(fp)
 90971fc:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 9097200:	e0bffe17 	ldw	r2,-8(fp)
 9097204:	1085883a 	add	r2,r2,r2
 9097208:	1007883a 	mov	r3,r2
 909720c:	e0bffd17 	ldw	r2,-12(fp)
 9097210:	1885883a 	add	r2,r3,r2
 9097214:	e0ffff03 	ldbu	r3,-4(fp)
 9097218:	10c0002d 	sthio	r3,0(r2)
  return;
}
 909721c:	e037883a 	mov	sp,fp
 9097220:	df000017 	ldw	fp,0(sp)
 9097224:	dec00104 	addi	sp,sp,4
 9097228:	f800283a 	ret

0909722c <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 909722c:	defffc04 	addi	sp,sp,-16
 9097230:	df000315 	stw	fp,12(sp)
 9097234:	df000304 	addi	fp,sp,12
 9097238:	e13ffd15 	stw	r4,-12(fp)
 909723c:	e17ffe15 	stw	r5,-8(fp)
 9097240:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 9097244:	e0bffe17 	ldw	r2,-8(fp)
 9097248:	1085883a 	add	r2,r2,r2
 909724c:	1085883a 	add	r2,r2,r2
 9097250:	1007883a 	mov	r3,r2
 9097254:	e0bffd17 	ldw	r2,-12(fp)
 9097258:	1885883a 	add	r2,r3,r2
 909725c:	e0ffff03 	ldbu	r3,-4(fp)
 9097260:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9097264:	e037883a 	mov	sp,fp
 9097268:	df000017 	ldw	fp,0(sp)
 909726c:	dec00104 	addi	sp,sp,4
 9097270:	f800283a 	ret

09097274 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 9097274:	defffc04 	addi	sp,sp,-16
 9097278:	df000315 	stw	fp,12(sp)
 909727c:	df000304 	addi	fp,sp,12
 9097280:	e13ffd15 	stw	r4,-12(fp)
 9097284:	e17ffe15 	stw	r5,-8(fp)
 9097288:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 909728c:	e0bffe17 	ldw	r2,-8(fp)
 9097290:	1085883a 	add	r2,r2,r2
 9097294:	1085883a 	add	r2,r2,r2
 9097298:	1007883a 	mov	r3,r2
 909729c:	e0bffd17 	ldw	r2,-12(fp)
 90972a0:	1885883a 	add	r2,r3,r2
 90972a4:	e0ffff03 	ldbu	r3,-4(fp)
 90972a8:	10c00035 	stwio	r3,0(r2)
  return;
}
 90972ac:	e037883a 	mov	sp,fp
 90972b0:	df000017 	ldw	fp,0(sp)
 90972b4:	dec00104 	addi	sp,sp,4
 90972b8:	f800283a 	ret

090972bc <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 90972bc:	defffd04 	addi	sp,sp,-12
 90972c0:	df000215 	stw	fp,8(sp)
 90972c4:	df000204 	addi	fp,sp,8
 90972c8:	e13ffe15 	stw	r4,-8(fp)
 90972cc:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 90972d0:	e0bfff17 	ldw	r2,-4(fp)
 90972d4:	10c03fcc 	andi	r3,r2,255
 90972d8:	e0bffe17 	ldw	r2,-8(fp)
 90972dc:	10c00025 	stbio	r3,0(r2)
  return;
}
 90972e0:	e037883a 	mov	sp,fp
 90972e4:	df000017 	ldw	fp,0(sp)
 90972e8:	dec00104 	addi	sp,sp,4
 90972ec:	f800283a 	ret

090972f0 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 90972f0:	defffd04 	addi	sp,sp,-12
 90972f4:	df000215 	stw	fp,8(sp)
 90972f8:	df000204 	addi	fp,sp,8
 90972fc:	e13ffe15 	stw	r4,-8(fp)
 9097300:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 9097304:	e0bfff17 	ldw	r2,-4(fp)
 9097308:	10ffffcc 	andi	r3,r2,65535
 909730c:	e0bffe17 	ldw	r2,-8(fp)
 9097310:	10c0002d 	sthio	r3,0(r2)
  return;
}
 9097314:	e037883a 	mov	sp,fp
 9097318:	df000017 	ldw	fp,0(sp)
 909731c:	dec00104 	addi	sp,sp,4
 9097320:	f800283a 	ret

09097324 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 9097324:	defffd04 	addi	sp,sp,-12
 9097328:	df000215 	stw	fp,8(sp)
 909732c:	df000204 	addi	fp,sp,8
 9097330:	e13ffe15 	stw	r4,-8(fp)
 9097334:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 9097338:	e0ffff17 	ldw	r3,-4(fp)
 909733c:	e0bffe17 	ldw	r2,-8(fp)
 9097340:	10c00035 	stwio	r3,0(r2)
  return;
}
 9097344:	e037883a 	mov	sp,fp
 9097348:	df000017 	ldw	fp,0(sp)
 909734c:	dec00104 	addi	sp,sp,4
 9097350:	f800283a 	ret

09097354 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 9097354:	defffb04 	addi	sp,sp,-20
 9097358:	df000415 	stw	fp,16(sp)
 909735c:	df000404 	addi	fp,sp,16
 9097360:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 9097364:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 9097368:	e0bffd17 	ldw	r2,-12(fp)
 909736c:	10802e17 	ldw	r2,184(r2)
 9097370:	e0bfff15 	stw	r2,-4(fp)
 9097374:	e0ffff17 	ldw	r3,-4(fp)
 9097378:	188000a0 	cmpeqi	r2,r3,2
 909737c:	1000261e 	bne	r2,zero,9097418 <alt_set_flash_width_func+0xc4>
 9097380:	e0ffff17 	ldw	r3,-4(fp)
 9097384:	18800120 	cmpeqi	r2,r3,4
 9097388:	1000391e 	bne	r2,zero,9097470 <alt_set_flash_width_func+0x11c>
 909738c:	e0ffff17 	ldw	r3,-4(fp)
 9097390:	18800060 	cmpeqi	r2,r3,1
 9097394:	1000011e 	bne	r2,zero,909739c <alt_set_flash_width_func+0x48>
 9097398:	00003e06 	br	9097494 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 909739c:	e0fffd17 	ldw	r3,-12(fp)
 90973a0:	00824274 	movhi	r2,2313
 90973a4:	109caf04 	addi	r2,r2,29372
 90973a8:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 90973ac:	e0bffd17 	ldw	r2,-12(fp)
 90973b0:	10802f17 	ldw	r2,188(r2)
 90973b4:	10800058 	cmpnei	r2,r2,1
 90973b8:	1000051e 	bne	r2,zero,90973d0 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 90973bc:	e0fffd17 	ldw	r3,-12(fp)
 90973c0:	00824274 	movhi	r2,2313
 90973c4:	109c3a04 	addi	r2,r2,28904
 90973c8:	18803315 	stw	r2,204(r3)
 90973cc:	00003306 	br	909749c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 90973d0:	e0bffd17 	ldw	r2,-12(fp)
 90973d4:	10802f17 	ldw	r2,188(r2)
 90973d8:	10800098 	cmpnei	r2,r2,2
 90973dc:	1000051e 	bne	r2,zero,90973f4 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 90973e0:	e0fffd17 	ldw	r3,-12(fp)
 90973e4:	00824274 	movhi	r2,2313
 90973e8:	109c4904 	addi	r2,r2,28964
 90973ec:	18803315 	stw	r2,204(r3)
 90973f0:	00002a06 	br	909749c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 90973f4:	e0bffd17 	ldw	r2,-12(fp)
 90973f8:	10802f17 	ldw	r2,188(r2)
 90973fc:	10800118 	cmpnei	r2,r2,4
 9097400:	1000261e 	bne	r2,zero,909749c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 9097404:	e0fffd17 	ldw	r3,-12(fp)
 9097408:	00824274 	movhi	r2,2313
 909740c:	109c6804 	addi	r2,r2,29088
 9097410:	18803315 	stw	r2,204(r3)
      }
      break;
 9097414:	00002106 	br	909749c <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 9097418:	e0fffd17 	ldw	r3,-12(fp)
 909741c:	00824274 	movhi	r2,2313
 9097420:	109cbc04 	addi	r2,r2,29424
 9097424:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 9097428:	e0bffd17 	ldw	r2,-12(fp)
 909742c:	10802f17 	ldw	r2,188(r2)
 9097430:	10800098 	cmpnei	r2,r2,2
 9097434:	1000051e 	bne	r2,zero,909744c <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 9097438:	e0fffd17 	ldw	r3,-12(fp)
 909743c:	00824274 	movhi	r2,2313
 9097440:	109c7a04 	addi	r2,r2,29160
 9097444:	18803315 	stw	r2,204(r3)
 9097448:	00001406 	br	909749c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 909744c:	e0bffd17 	ldw	r2,-12(fp)
 9097450:	10802f17 	ldw	r2,188(r2)
 9097454:	10800118 	cmpnei	r2,r2,4
 9097458:	1000101e 	bne	r2,zero,909749c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 909745c:	e0fffd17 	ldw	r3,-12(fp)
 9097460:	00824274 	movhi	r2,2313
 9097464:	109c8b04 	addi	r2,r2,29228
 9097468:	18803315 	stw	r2,204(r3)
      }

      break;
 909746c:	00000b06 	br	909749c <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 9097470:	e0fffd17 	ldw	r3,-12(fp)
 9097474:	00824274 	movhi	r2,2313
 9097478:	109cc904 	addi	r2,r2,29476
 909747c:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 9097480:	e0fffd17 	ldw	r3,-12(fp)
 9097484:	00824274 	movhi	r2,2313
 9097488:	109c9d04 	addi	r2,r2,29300
 909748c:	18803315 	stw	r2,204(r3)
      break;
 9097490:	00000206 	br	909749c <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 9097494:	00bffcc4 	movi	r2,-13
 9097498:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 909749c:	e0bffc17 	ldw	r2,-16(fp)
 90974a0:	1004c03a 	cmpne	r2,r2,zero
 90974a4:	10001e1e 	bne	r2,zero,9097520 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 90974a8:	e0bffd17 	ldw	r2,-12(fp)
 90974ac:	10802f17 	ldw	r2,188(r2)
 90974b0:	e0bffe15 	stw	r2,-8(fp)
 90974b4:	e0fffe17 	ldw	r3,-8(fp)
 90974b8:	188000a0 	cmpeqi	r2,r3,2
 90974bc:	10000c1e 	bne	r2,zero,90974f0 <alt_set_flash_width_func+0x19c>
 90974c0:	e0fffe17 	ldw	r3,-8(fp)
 90974c4:	18800120 	cmpeqi	r2,r3,4
 90974c8:	10000e1e 	bne	r2,zero,9097504 <alt_set_flash_width_func+0x1b0>
 90974cc:	e0fffe17 	ldw	r3,-8(fp)
 90974d0:	18800060 	cmpeqi	r2,r3,1
 90974d4:	1000011e 	bne	r2,zero,90974dc <alt_set_flash_width_func+0x188>
 90974d8:	00000f06 	br	9097518 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 90974dc:	e0fffd17 	ldw	r3,-12(fp)
 90974e0:	00824274 	movhi	r2,2313
 90974e4:	109c0704 	addi	r2,r2,28700
 90974e8:	18803415 	stw	r2,208(r3)
        break;
 90974ec:	00000c06 	br	9097520 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 90974f0:	e0fffd17 	ldw	r3,-12(fp)
 90974f4:	00824274 	movhi	r2,2313
 90974f8:	109c1704 	addi	r2,r2,28764
 90974fc:	18803415 	stw	r2,208(r3)
        break;
 9097500:	00000706 	br	9097520 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 9097504:	e0fffd17 	ldw	r3,-12(fp)
 9097508:	00824274 	movhi	r2,2313
 909750c:	109c2804 	addi	r2,r2,28832
 9097510:	18803415 	stw	r2,208(r3)
        break;
 9097514:	00000206 	br	9097520 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 9097518:	00bffcc4 	movi	r2,-13
 909751c:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 9097520:	e0bffc17 	ldw	r2,-16(fp)
}
 9097524:	e037883a 	mov	sp,fp
 9097528:	df000017 	ldw	fp,0(sp)
 909752c:	dec00104 	addi	sp,sp,4
 9097530:	f800283a 	ret

09097534 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 9097534:	defffc04 	addi	sp,sp,-16
 9097538:	df000315 	stw	fp,12(sp)
 909753c:	df000304 	addi	fp,sp,12
 9097540:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 9097544:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 9097548:	e0bffe17 	ldw	r2,-8(fp)
 909754c:	10802d17 	ldw	r2,180(r2)
 9097550:	e0bfff15 	stw	r2,-4(fp)
 9097554:	e0ffff17 	ldw	r3,-4(fp)
 9097558:	188000a0 	cmpeqi	r2,r3,2
 909755c:	1000071e 	bne	r2,zero,909757c <alt_set_flash_algorithm_func+0x48>
 9097560:	e0ffff17 	ldw	r3,-4(fp)
 9097564:	188000e0 	cmpeqi	r2,r3,3
 9097568:	10000d1e 	bne	r2,zero,90975a0 <alt_set_flash_algorithm_func+0x6c>
 909756c:	e0ffff17 	ldw	r3,-4(fp)
 9097570:	18800060 	cmpeqi	r2,r3,1
 9097574:	10000a1e 	bne	r2,zero,90975a0 <alt_set_flash_algorithm_func+0x6c>
 9097578:	00001206 	br	90975c4 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 909757c:	e0fffe17 	ldw	r3,-8(fp)
 9097580:	00824334 	movhi	r2,2316
 9097584:	10acba04 	addi	r2,r2,-19736
 9097588:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 909758c:	e0fffe17 	ldw	r3,-8(fp)
 9097590:	00824334 	movhi	r2,2316
 9097594:	10aca004 	addi	r2,r2,-19840
 9097598:	18800915 	stw	r2,36(r3)
      break;
 909759c:	00000b06 	br	90975cc <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 90975a0:	e0fffe17 	ldw	r3,-8(fp)
 90975a4:	00824334 	movhi	r2,2316
 90975a8:	10add904 	addi	r2,r2,-18588
 90975ac:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 90975b0:	e0fffe17 	ldw	r3,-8(fp)
 90975b4:	00824334 	movhi	r2,2316
 90975b8:	10adb804 	addi	r2,r2,-18720
 90975bc:	18800915 	stw	r2,36(r3)
      break;
 90975c0:	00000206 	br	90975cc <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 90975c4:	00bffec4 	movi	r2,-5
 90975c8:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 90975cc:	e0bffd17 	ldw	r2,-12(fp)
}
 90975d0:	e037883a 	mov	sp,fp
 90975d4:	df000017 	ldw	fp,0(sp)
 90975d8:	dec00104 	addi	sp,sp,4
 90975dc:	f800283a 	ret

090975e0 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 90975e0:	defffb04 	addi	sp,sp,-20
 90975e4:	dfc00415 	stw	ra,16(sp)
 90975e8:	df000315 	stw	fp,12(sp)
 90975ec:	df000304 	addi	fp,sp,12
 90975f0:	e13ffe15 	stw	r4,-8(fp)
 90975f4:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 90975f8:	e0bffe17 	ldw	r2,-8(fp)
 90975fc:	10803417 	ldw	r2,208(r2)
 9097600:	e13ffe17 	ldw	r4,-8(fp)
 9097604:	e17fff17 	ldw	r5,-4(fp)
 9097608:	103ee83a 	callr	r2
 909760c:	10803fcc 	andi	r2,r2,255
 9097610:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 9097614:	e0bffe17 	ldw	r2,-8(fp)
 9097618:	10c03417 	ldw	r3,208(r2)
 909761c:	e0bfff17 	ldw	r2,-4(fp)
 9097620:	11400044 	addi	r5,r2,1
 9097624:	e13ffe17 	ldw	r4,-8(fp)
 9097628:	183ee83a 	callr	r3
 909762c:	10803fcc 	andi	r2,r2,255
 9097630:	1004923a 	slli	r2,r2,8
 9097634:	1007883a 	mov	r3,r2
 9097638:	e0bffd0b 	ldhu	r2,-12(fp)
 909763c:	1884b03a 	or	r2,r3,r2
 9097640:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 9097644:	e0bffd0b 	ldhu	r2,-12(fp)
}
 9097648:	e037883a 	mov	sp,fp
 909764c:	dfc00117 	ldw	ra,4(sp)
 9097650:	df000017 	ldw	fp,0(sp)
 9097654:	dec00204 	addi	sp,sp,8
 9097658:	f800283a 	ret

0909765c <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 909765c:	defff104 	addi	sp,sp,-60
 9097660:	dfc00e15 	stw	ra,56(sp)
 9097664:	df000d15 	stw	fp,52(sp)
 9097668:	dc000c15 	stw	r16,48(sp)
 909766c:	df000c04 	addi	fp,sp,48
 9097670:	e13ffe15 	stw	r4,-8(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 9097674:	e03ffa15 	stw	zero,-24(fp)
  int   size = 0;
 9097678:	e03ff915 	stw	zero,-28(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 909767c:	e03ff515 	stw	zero,-44(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 9097680:	e13ffe17 	ldw	r4,-8(fp)
 9097684:	90983e80 	call	90983e8 <alt_check_primary_table>
 9097688:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
 909768c:	e0bffa17 	ldw	r2,-24(fp)
 9097690:	1004c03a 	cmpne	r2,r2,zero
 9097694:	1001621e 	bne	r2,zero,9097c20 <alt_read_cfi_table+0x5c4>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 9097698:	e0bffe17 	ldw	r2,-8(fp)
 909769c:	10803417 	ldw	r2,208(r2)
 90976a0:	e13ffe17 	ldw	r4,-8(fp)
 90976a4:	014004c4 	movi	r5,19
 90976a8:	103ee83a 	callr	r2
 90976ac:	10c03fcc 	andi	r3,r2,255
 90976b0:	e0bffe17 	ldw	r2,-8(fp)
 90976b4:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 90976b8:	e0bffe17 	ldw	r2,-8(fp)
 90976bc:	10803417 	ldw	r2,208(r2)
 90976c0:	e13ffe17 	ldw	r4,-8(fp)
 90976c4:	014007c4 	movi	r5,31
 90976c8:	103ee83a 	callr	r2
 90976cc:	10803fcc 	andi	r2,r2,255
 90976d0:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 90976d4:	e0bffe17 	ldw	r2,-8(fp)
 90976d8:	10803417 	ldw	r2,208(r2)
 90976dc:	e13ffe17 	ldw	r4,-8(fp)
 90976e0:	014008c4 	movi	r5,35
 90976e4:	103ee83a 	callr	r2
 90976e8:	10803fcc 	andi	r2,r2,255
 90976ec:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 90976f0:	e0bff717 	ldw	r2,-36(fp)
 90976f4:	1005003a 	cmpeq	r2,r2,zero
 90976f8:	1000031e 	bne	r2,zero,9097708 <alt_read_cfi_table+0xac>
 90976fc:	e0bff617 	ldw	r2,-40(fp)
 9097700:	1004c03a 	cmpne	r2,r2,zero
 9097704:	1000041e 	bne	r2,zero,9097718 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 9097708:	e0fffe17 	ldw	r3,-8(fp)
 909770c:	0080fa04 	movi	r2,1000
 9097710:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 9097714:	00000706 	br	9097734 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 9097718:	00c00044 	movi	r3,1
 909771c:	e0bff717 	ldw	r2,-36(fp)
 9097720:	1886983a 	sll	r3,r3,r2
 9097724:	e0bff617 	ldw	r2,-40(fp)
 9097728:	1886983a 	sll	r3,r3,r2
 909772c:	e0bffe17 	ldw	r2,-8(fp)
 9097730:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 9097734:	e0bffe17 	ldw	r2,-8(fp)
 9097738:	10803417 	ldw	r2,208(r2)
 909773c:	e13ffe17 	ldw	r4,-8(fp)
 9097740:	01400844 	movi	r5,33
 9097744:	103ee83a 	callr	r2
 9097748:	10803fcc 	andi	r2,r2,255
 909774c:	e0bff715 	stw	r2,-36(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 9097750:	e0bffe17 	ldw	r2,-8(fp)
 9097754:	10803417 	ldw	r2,208(r2)
 9097758:	e13ffe17 	ldw	r4,-8(fp)
 909775c:	01400944 	movi	r5,37
 9097760:	103ee83a 	callr	r2
 9097764:	10803fcc 	andi	r2,r2,255
 9097768:	e0bff615 	stw	r2,-40(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 909776c:	e0bff717 	ldw	r2,-36(fp)
 9097770:	1005003a 	cmpeq	r2,r2,zero
 9097774:	1000031e 	bne	r2,zero,9097784 <alt_read_cfi_table+0x128>
 9097778:	e0bff617 	ldw	r2,-40(fp)
 909777c:	1004c03a 	cmpne	r2,r2,zero
 9097780:	1000051e 	bne	r2,zero,9097798 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 9097784:	e0fffe17 	ldw	r3,-8(fp)
 9097788:	00804c74 	movhi	r2,305
 909778c:	108b4004 	addi	r2,r2,11520
 9097790:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 9097794:	00000806 	br	90977b8 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 9097798:	00c00044 	movi	r3,1
 909779c:	e0bff717 	ldw	r2,-36(fp)
 90977a0:	1886983a 	sll	r3,r3,r2
 90977a4:	e0bff617 	ldw	r2,-40(fp)
 90977a8:	1884983a 	sll	r2,r3,r2
 90977ac:	10c0fa24 	muli	r3,r2,1000
 90977b0:	e0bffe17 	ldw	r2,-8(fp)
 90977b4:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 90977b8:	e0bffe17 	ldw	r2,-8(fp)
 90977bc:	10803417 	ldw	r2,208(r2)
 90977c0:	e13ffe17 	ldw	r4,-8(fp)
 90977c4:	014009c4 	movi	r5,39
 90977c8:	103ee83a 	callr	r2
 90977cc:	10c03fcc 	andi	r3,r2,255
 90977d0:	00800044 	movi	r2,1
 90977d4:	10c4983a 	sll	r2,r2,r3
 90977d8:	e0bffb15 	stw	r2,-20(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 90977dc:	e0bffe17 	ldw	r2,-8(fp)
 90977e0:	10803417 	ldw	r2,208(r2)
 90977e4:	e13ffe17 	ldw	r4,-8(fp)
 90977e8:	01400b04 	movi	r5,44
 90977ec:	103ee83a 	callr	r2
 90977f0:	10c03fcc 	andi	r3,r2,255
 90977f4:	e0bffe17 	ldw	r2,-8(fp)
 90977f8:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 90977fc:	e0bffe17 	ldw	r2,-8(fp)
 9097800:	10800c17 	ldw	r2,48(r2)
 9097804:	10800250 	cmplti	r2,r2,9
 9097808:	1000031e 	bne	r2,zero,9097818 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 909780c:	00bffd04 	movi	r2,-12
 9097810:	e0bffa15 	stw	r2,-24(fp)
 9097814:	00005e06 	br	9097990 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 9097818:	e03ffd15 	stw	zero,-12(fp)
 909781c:	00005306 	br	909796c <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 9097820:	e43ffd17 	ldw	r16,-12(fp)
 9097824:	e0bffd17 	ldw	r2,-12(fp)
 9097828:	1085883a 	add	r2,r2,r2
 909782c:	1085883a 	add	r2,r2,r2
 9097830:	11400b44 	addi	r5,r2,45
 9097834:	e13ffe17 	ldw	r4,-8(fp)
 9097838:	90975e00 	call	90975e0 <alt_read_16bit_query_entry>
 909783c:	113fffcc 	andi	r4,r2,65535
 9097840:	e0fffe17 	ldw	r3,-8(fp)
 9097844:	8004913a 	slli	r2,r16,4
 9097848:	10c5883a 	add	r2,r2,r3
 909784c:	10800f04 	addi	r2,r2,60
 9097850:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 9097854:	e17ffd17 	ldw	r5,-12(fp)
 9097858:	e0bffd17 	ldw	r2,-12(fp)
 909785c:	e0fffe17 	ldw	r3,-8(fp)
 9097860:	1004913a 	slli	r2,r2,4
 9097864:	10c5883a 	add	r2,r2,r3
 9097868:	10800f04 	addi	r2,r2,60
 909786c:	10800017 	ldw	r2,0(r2)
 9097870:	11000044 	addi	r4,r2,1
 9097874:	e0fffe17 	ldw	r3,-8(fp)
 9097878:	2804913a 	slli	r2,r5,4
 909787c:	10c5883a 	add	r2,r2,r3
 9097880:	10800f04 	addi	r2,r2,60
 9097884:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 9097888:	e43ffd17 	ldw	r16,-12(fp)
 909788c:	e0bffd17 	ldw	r2,-12(fp)
 9097890:	1085883a 	add	r2,r2,r2
 9097894:	1085883a 	add	r2,r2,r2
 9097898:	11400bc4 	addi	r5,r2,47
 909789c:	e13ffe17 	ldw	r4,-8(fp)
 90978a0:	90975e00 	call	90975e0 <alt_read_16bit_query_entry>
 90978a4:	113fffcc 	andi	r4,r2,65535
 90978a8:	e0fffe17 	ldw	r3,-8(fp)
 90978ac:	8004913a 	slli	r2,r16,4
 90978b0:	10c5883a 	add	r2,r2,r3
 90978b4:	10801004 	addi	r2,r2,64
 90978b8:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 90978bc:	e17ffd17 	ldw	r5,-12(fp)
 90978c0:	e0bffd17 	ldw	r2,-12(fp)
 90978c4:	e0fffe17 	ldw	r3,-8(fp)
 90978c8:	1004913a 	slli	r2,r2,4
 90978cc:	10c5883a 	add	r2,r2,r3
 90978d0:	10801004 	addi	r2,r2,64
 90978d4:	10800017 	ldw	r2,0(r2)
 90978d8:	1008923a 	slli	r4,r2,8
 90978dc:	e0fffe17 	ldw	r3,-8(fp)
 90978e0:	2804913a 	slli	r2,r5,4
 90978e4:	10c5883a 	add	r2,r2,r3
 90978e8:	10801004 	addi	r2,r2,64
 90978ec:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 90978f0:	e17ffd17 	ldw	r5,-12(fp)
 90978f4:	e0bffd17 	ldw	r2,-12(fp)
 90978f8:	e0fffe17 	ldw	r3,-8(fp)
 90978fc:	1004913a 	slli	r2,r2,4
 9097900:	10c5883a 	add	r2,r2,r3
 9097904:	10800f04 	addi	r2,r2,60
 9097908:	11000017 	ldw	r4,0(r2)
 909790c:	e0bffd17 	ldw	r2,-12(fp)
 9097910:	e0fffe17 	ldw	r3,-8(fp)
 9097914:	1004913a 	slli	r2,r2,4
 9097918:	10c5883a 	add	r2,r2,r3
 909791c:	10801004 	addi	r2,r2,64
 9097920:	10800017 	ldw	r2,0(r2)
 9097924:	2089383a 	mul	r4,r4,r2
 9097928:	e0fffe17 	ldw	r3,-8(fp)
 909792c:	2804913a 	slli	r2,r5,4
 9097930:	10c5883a 	add	r2,r2,r3
 9097934:	10800e04 	addi	r2,r2,56
 9097938:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 909793c:	e0bffd17 	ldw	r2,-12(fp)
 9097940:	e0fffe17 	ldw	r3,-8(fp)
 9097944:	1004913a 	slli	r2,r2,4
 9097948:	10c5883a 	add	r2,r2,r3
 909794c:	10800e04 	addi	r2,r2,56
 9097950:	10c00017 	ldw	r3,0(r2)
 9097954:	e0bff917 	ldw	r2,-28(fp)
 9097958:	10c5883a 	add	r2,r2,r3
 909795c:	e0bff915 	stw	r2,-28(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 9097960:	e0bffd17 	ldw	r2,-12(fp)
 9097964:	10800044 	addi	r2,r2,1
 9097968:	e0bffd15 	stw	r2,-12(fp)
 909796c:	e0bffe17 	ldw	r2,-8(fp)
 9097970:	10c00c17 	ldw	r3,48(r2)
 9097974:	e0bffd17 	ldw	r2,-12(fp)
 9097978:	10ffa916 	blt	r2,r3,9097820 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 909797c:	e0fff917 	ldw	r3,-28(fp)
 9097980:	e0bffb17 	ldw	r2,-20(fp)
 9097984:	18800226 	beq	r3,r2,9097990 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 9097988:	00bffb44 	movi	r2,-19
 909798c:	e0bffa15 	stw	r2,-24(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 9097990:	e0bffe17 	ldw	r2,-8(fp)
 9097994:	10c03417 	ldw	r3,208(r2)
 9097998:	e0bffe17 	ldw	r2,-8(fp)
 909799c:	10803217 	ldw	r2,200(r2)
 90979a0:	114003c4 	addi	r5,r2,15
 90979a4:	e13ffe17 	ldw	r4,-8(fp)
 90979a8:	183ee83a 	callr	r3
 90979ac:	e0bff405 	stb	r2,-48(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 90979b0:	e0bffe17 	ldw	r2,-8(fp)
 90979b4:	10802d17 	ldw	r2,180(r2)
 90979b8:	10800098 	cmpnei	r2,r2,2
 90979bc:	1000601e 	bne	r2,zero,9097b40 <alt_read_cfi_table+0x4e4>
 90979c0:	e0bff403 	ldbu	r2,-48(fp)
 90979c4:	108000d8 	cmpnei	r2,r2,3
 90979c8:	10005d1e 	bne	r2,zero,9097b40 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 90979cc:	e0bffe17 	ldw	r2,-8(fp)
 90979d0:	10800c17 	ldw	r2,48(r2)
 90979d4:	10bfffc4 	addi	r2,r2,-1
 90979d8:	e0bffd15 	stw	r2,-12(fp)
 90979dc:	e03ffc15 	stw	zero,-16(fp)
          j<=i;i--,j++)
 90979e0:	00005406 	br	9097b34 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 90979e4:	e0bffd17 	ldw	r2,-12(fp)
 90979e8:	e0fffe17 	ldw	r3,-8(fp)
 90979ec:	1004913a 	slli	r2,r2,4
 90979f0:	10c5883a 	add	r2,r2,r3
 90979f4:	10800e04 	addi	r2,r2,56
 90979f8:	10800017 	ldw	r2,0(r2)
 90979fc:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].region_size =  
 9097a00:	e17ffd17 	ldw	r5,-12(fp)
 9097a04:	e0bffc17 	ldw	r2,-16(fp)
 9097a08:	e0fffe17 	ldw	r3,-8(fp)
 9097a0c:	1004913a 	slli	r2,r2,4
 9097a10:	10c5883a 	add	r2,r2,r3
 9097a14:	10800e04 	addi	r2,r2,56
 9097a18:	11000017 	ldw	r4,0(r2)
 9097a1c:	e0fffe17 	ldw	r3,-8(fp)
 9097a20:	2804913a 	slli	r2,r5,4
 9097a24:	10c5883a 	add	r2,r2,r3
 9097a28:	10800e04 	addi	r2,r2,56
 9097a2c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 9097a30:	e0bffc17 	ldw	r2,-16(fp)
 9097a34:	e0fffe17 	ldw	r3,-8(fp)
 9097a38:	1004913a 	slli	r2,r2,4
 9097a3c:	10c5883a 	add	r2,r2,r3
 9097a40:	10c00e04 	addi	r3,r2,56
 9097a44:	e0bff817 	ldw	r2,-32(fp)
 9097a48:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 9097a4c:	e0bffd17 	ldw	r2,-12(fp)
 9097a50:	e0fffe17 	ldw	r3,-8(fp)
 9097a54:	1004913a 	slli	r2,r2,4
 9097a58:	10c5883a 	add	r2,r2,r3
 9097a5c:	10801004 	addi	r2,r2,64
 9097a60:	10800017 	ldw	r2,0(r2)
 9097a64:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].block_size =  
 9097a68:	e17ffd17 	ldw	r5,-12(fp)
 9097a6c:	e0bffc17 	ldw	r2,-16(fp)
 9097a70:	e0fffe17 	ldw	r3,-8(fp)
 9097a74:	1004913a 	slli	r2,r2,4
 9097a78:	10c5883a 	add	r2,r2,r3
 9097a7c:	10801004 	addi	r2,r2,64
 9097a80:	11000017 	ldw	r4,0(r2)
 9097a84:	e0fffe17 	ldw	r3,-8(fp)
 9097a88:	2804913a 	slli	r2,r5,4
 9097a8c:	10c5883a 	add	r2,r2,r3
 9097a90:	10801004 	addi	r2,r2,64
 9097a94:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 9097a98:	e0bffc17 	ldw	r2,-16(fp)
 9097a9c:	e0fffe17 	ldw	r3,-8(fp)
 9097aa0:	1004913a 	slli	r2,r2,4
 9097aa4:	10c5883a 	add	r2,r2,r3
 9097aa8:	10c01004 	addi	r3,r2,64
 9097aac:	e0bff817 	ldw	r2,-32(fp)
 9097ab0:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 9097ab4:	e0bffd17 	ldw	r2,-12(fp)
 9097ab8:	e0fffe17 	ldw	r3,-8(fp)
 9097abc:	1004913a 	slli	r2,r2,4
 9097ac0:	10c5883a 	add	r2,r2,r3
 9097ac4:	10800f04 	addi	r2,r2,60
 9097ac8:	10800017 	ldw	r2,0(r2)
 9097acc:	e0bff815 	stw	r2,-32(fp)
        flash->dev.region_info[i].number_of_blocks =  
 9097ad0:	e17ffd17 	ldw	r5,-12(fp)
 9097ad4:	e0bffc17 	ldw	r2,-16(fp)
 9097ad8:	e0fffe17 	ldw	r3,-8(fp)
 9097adc:	1004913a 	slli	r2,r2,4
 9097ae0:	10c5883a 	add	r2,r2,r3
 9097ae4:	10800f04 	addi	r2,r2,60
 9097ae8:	11000017 	ldw	r4,0(r2)
 9097aec:	e0fffe17 	ldw	r3,-8(fp)
 9097af0:	2804913a 	slli	r2,r5,4
 9097af4:	10c5883a 	add	r2,r2,r3
 9097af8:	10800f04 	addi	r2,r2,60
 9097afc:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 9097b00:	e0bffc17 	ldw	r2,-16(fp)
 9097b04:	e0fffe17 	ldw	r3,-8(fp)
 9097b08:	1004913a 	slli	r2,r2,4
 9097b0c:	10c5883a 	add	r2,r2,r3
 9097b10:	10c00f04 	addi	r3,r2,60
 9097b14:	e0bff817 	ldw	r2,-32(fp)
 9097b18:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 9097b1c:	e0bffd17 	ldw	r2,-12(fp)
 9097b20:	10bfffc4 	addi	r2,r2,-1
 9097b24:	e0bffd15 	stw	r2,-12(fp)
 9097b28:	e0bffc17 	ldw	r2,-16(fp)
 9097b2c:	10800044 	addi	r2,r2,1
 9097b30:	e0bffc15 	stw	r2,-16(fp)
 9097b34:	e0fffc17 	ldw	r3,-16(fp)
 9097b38:	e0bffd17 	ldw	r2,-12(fp)
 9097b3c:	10ffa90e 	bge	r2,r3,90979e4 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 9097b40:	e03ffd15 	stw	zero,-12(fp)
 9097b44:	00001306 	br	9097b94 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 9097b48:	e0bffd17 	ldw	r2,-12(fp)
 9097b4c:	e0fffe17 	ldw	r3,-8(fp)
 9097b50:	1004913a 	slli	r2,r2,4
 9097b54:	10c5883a 	add	r2,r2,r3
 9097b58:	10c00d04 	addi	r3,r2,52
 9097b5c:	e0bff517 	ldw	r2,-44(fp)
 9097b60:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 9097b64:	e0bffd17 	ldw	r2,-12(fp)
 9097b68:	e0fffe17 	ldw	r3,-8(fp)
 9097b6c:	1004913a 	slli	r2,r2,4
 9097b70:	10c5883a 	add	r2,r2,r3
 9097b74:	10800e04 	addi	r2,r2,56
 9097b78:	10c00017 	ldw	r3,0(r2)
 9097b7c:	e0bff517 	ldw	r2,-44(fp)
 9097b80:	10c5883a 	add	r2,r2,r3
 9097b84:	e0bff515 	stw	r2,-44(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 9097b88:	e0bffd17 	ldw	r2,-12(fp)
 9097b8c:	10800044 	addi	r2,r2,1
 9097b90:	e0bffd15 	stw	r2,-12(fp)
 9097b94:	e0bffe17 	ldw	r2,-8(fp)
 9097b98:	10c00c17 	ldw	r3,48(r2)
 9097b9c:	e0bffd17 	ldw	r2,-12(fp)
 9097ba0:	10ffe916 	blt	r2,r3,9097b48 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
 9097ba4:	e0bffe17 	ldw	r2,-8(fp)
 9097ba8:	10802d17 	ldw	r2,180(r2)
 9097bac:	e0bfff15 	stw	r2,-4(fp)
 9097bb0:	e0ffff17 	ldw	r3,-4(fp)
 9097bb4:	188000a0 	cmpeqi	r2,r3,2
 9097bb8:	1000071e 	bne	r2,zero,9097bd8 <alt_read_cfi_table+0x57c>
 9097bbc:	e0ffff17 	ldw	r3,-4(fp)
 9097bc0:	188000e0 	cmpeqi	r2,r3,3
 9097bc4:	10000c1e 	bne	r2,zero,9097bf8 <alt_read_cfi_table+0x59c>
 9097bc8:	e0ffff17 	ldw	r3,-4(fp)
 9097bcc:	18800060 	cmpeqi	r2,r3,1
 9097bd0:	1000091e 	bne	r2,zero,9097bf8 <alt_read_cfi_table+0x59c>
 9097bd4:	00001006 	br	9097c18 <alt_read_cfi_table+0x5bc>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 9097bd8:	e0bffe17 	ldw	r2,-8(fp)
 9097bdc:	10c03317 	ldw	r3,204(r2)
 9097be0:	e0bffe17 	ldw	r2,-8(fp)
 9097be4:	11000a17 	ldw	r4,40(r2)
 9097be8:	01401544 	movi	r5,85
 9097bec:	01803c04 	movi	r6,240
 9097bf0:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
 9097bf4:	00000a06 	br	9097c20 <alt_read_cfi_table+0x5c4>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
 9097bf8:	e0bffe17 	ldw	r2,-8(fp)
 9097bfc:	10c03317 	ldw	r3,204(r2)
 9097c00:	e0bffe17 	ldw	r2,-8(fp)
 9097c04:	11000a17 	ldw	r4,40(r2)
 9097c08:	01401544 	movi	r5,85
 9097c0c:	01803fc4 	movi	r6,255
 9097c10:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
 9097c14:	00000206 	br	9097c20 <alt_read_cfi_table+0x5c4>
      }
      default:
      {
        ret_code = -EIO;
 9097c18:	00bffec4 	movi	r2,-5
 9097c1c:	e0bffa15 	stw	r2,-24(fp)
      }
    } 
  }  

  return ret_code;
 9097c20:	e0bffa17 	ldw	r2,-24(fp)
}
 9097c24:	e037883a 	mov	sp,fp
 9097c28:	dfc00217 	ldw	ra,8(sp)
 9097c2c:	df000117 	ldw	fp,4(sp)
 9097c30:	dc000017 	ldw	r16,0(sp)
 9097c34:	dec00304 	addi	sp,sp,12
 9097c38:	f800283a 	ret

09097c3c <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 9097c3c:	defff704 	addi	sp,sp,-36
 9097c40:	dfc00815 	stw	ra,32(sp)
 9097c44:	df000715 	stw	fp,28(sp)
 9097c48:	df000704 	addi	fp,sp,28
 9097c4c:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 9097c50:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9097c54:	e0bfff17 	ldw	r2,-4(fp)
 9097c58:	11000a17 	ldw	r4,40(r2)
 9097c5c:	01401544 	movi	r5,85
 9097c60:	01802604 	movi	r6,152
 9097c64:	90970e80 	call	90970e8 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 9097c68:	e03ffb15 	stw	zero,-20(fp)
 9097c6c:	00000f06 	br	9097cac <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 9097c70:	e13ffb17 	ldw	r4,-20(fp)
 9097c74:	e0bfff17 	ldw	r2,-4(fp)
 9097c78:	10800a17 	ldw	r2,40(r2)
 9097c7c:	1007883a 	mov	r3,r2
 9097c80:	e0bffb17 	ldw	r2,-20(fp)
 9097c84:	1885883a 	add	r2,r3,r2
 9097c88:	10800404 	addi	r2,r2,16
 9097c8c:	10800023 	ldbuio	r2,0(r2)
 9097c90:	1007883a 	mov	r3,r2
 9097c94:	e0bffc04 	addi	r2,fp,-16
 9097c98:	1105883a 	add	r2,r2,r4
 9097c9c:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 9097ca0:	e0bffb17 	ldw	r2,-20(fp)
 9097ca4:	10800044 	addi	r2,r2,1
 9097ca8:	e0bffb15 	stw	r2,-20(fp)
 9097cac:	e0bffb17 	ldw	r2,-20(fp)
 9097cb0:	108000d0 	cmplti	r2,r2,3
 9097cb4:	103fee1e 	bne	r2,zero,9097c70 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9097cb8:	e0bffc03 	ldbu	r2,-16(fp)
 9097cbc:	10803fcc 	andi	r2,r2,255
 9097cc0:	10801458 	cmpnei	r2,r2,81
 9097cc4:	10001d1e 	bne	r2,zero,9097d3c <alt_read_cfi_width+0x100>
 9097cc8:	e0bffc43 	ldbu	r2,-15(fp)
 9097ccc:	10803fcc 	andi	r2,r2,255
 9097cd0:	10801498 	cmpnei	r2,r2,82
 9097cd4:	1000191e 	bne	r2,zero,9097d3c <alt_read_cfi_width+0x100>
 9097cd8:	e0bffc83 	ldbu	r2,-14(fp)
 9097cdc:	10803fcc 	andi	r2,r2,255
 9097ce0:	10801658 	cmpnei	r2,r2,89
 9097ce4:	1000151e 	bne	r2,zero,9097d3c <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 9097ce8:	e0ffff17 	ldw	r3,-4(fp)
 9097cec:	00800044 	movi	r2,1
 9097cf0:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 9097cf4:	e0ffff17 	ldw	r3,-4(fp)
 9097cf8:	00800044 	movi	r2,1
 9097cfc:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 9097d00:	e0bfff17 	ldw	r2,-4(fp)
 9097d04:	10800a17 	ldw	r2,40(r2)
 9097d08:	10800a04 	addi	r2,r2,40
 9097d0c:	1080002b 	ldhuio	r2,0(r2)
 9097d10:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 9097d14:	e0bffa0b 	ldhu	r2,-24(fp)
 9097d18:	10800044 	addi	r2,r2,1
 9097d1c:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 9097d20:	e0bffa0b 	ldhu	r2,-24(fp)
 9097d24:	1080004c 	andi	r2,r2,1
 9097d28:	1004c03a 	cmpne	r2,r2,zero
 9097d2c:	1001a81e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 9097d30:	00bffb44 	movi	r2,-19
 9097d34:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 9097d38:	0001a506 	br	90983d0 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9097d3c:	e0bfff17 	ldw	r2,-4(fp)
 9097d40:	11000a17 	ldw	r4,40(r2)
 9097d44:	01401544 	movi	r5,85
 9097d48:	01802604 	movi	r6,152
 9097d4c:	90971240 	call	9097124 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 9097d50:	e03ffb15 	stw	zero,-20(fp)
 9097d54:	00000f06 	br	9097d94 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9097d58:	e13ffb17 	ldw	r4,-20(fp)
 9097d5c:	e0bfff17 	ldw	r2,-4(fp)
 9097d60:	10800a17 	ldw	r2,40(r2)
 9097d64:	1007883a 	mov	r3,r2
 9097d68:	e0bffb17 	ldw	r2,-20(fp)
 9097d6c:	1885883a 	add	r2,r3,r2
 9097d70:	10800804 	addi	r2,r2,32
 9097d74:	10800023 	ldbuio	r2,0(r2)
 9097d78:	1007883a 	mov	r3,r2
 9097d7c:	e0bffc04 	addi	r2,fp,-16
 9097d80:	1105883a 	add	r2,r2,r4
 9097d84:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 9097d88:	e0bffb17 	ldw	r2,-20(fp)
 9097d8c:	10800044 	addi	r2,r2,1
 9097d90:	e0bffb15 	stw	r2,-20(fp)
 9097d94:	e0bffb17 	ldw	r2,-20(fp)
 9097d98:	10800190 	cmplti	r2,r2,6
 9097d9c:	103fee1e 	bne	r2,zero,9097d58 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9097da0:	e0bffc03 	ldbu	r2,-16(fp)
 9097da4:	10803fcc 	andi	r2,r2,255
 9097da8:	10801458 	cmpnei	r2,r2,81
 9097dac:	1000291e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
 9097db0:	e0bffc43 	ldbu	r2,-15(fp)
 9097db4:	10803fcc 	andi	r2,r2,255
 9097db8:	10801458 	cmpnei	r2,r2,81
 9097dbc:	1000251e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
 9097dc0:	e0bffc83 	ldbu	r2,-14(fp)
 9097dc4:	10803fcc 	andi	r2,r2,255
 9097dc8:	10801498 	cmpnei	r2,r2,82
 9097dcc:	1000211e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
 9097dd0:	e0bffcc3 	ldbu	r2,-13(fp)
 9097dd4:	10803fcc 	andi	r2,r2,255
 9097dd8:	10801498 	cmpnei	r2,r2,82
 9097ddc:	10001d1e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
 9097de0:	e0bffd03 	ldbu	r2,-12(fp)
 9097de4:	10803fcc 	andi	r2,r2,255
 9097de8:	10801658 	cmpnei	r2,r2,89
 9097dec:	1000191e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
 9097df0:	e0bffd43 	ldbu	r2,-11(fp)
 9097df4:	10803fcc 	andi	r2,r2,255
 9097df8:	10801658 	cmpnei	r2,r2,89
 9097dfc:	1000151e 	bne	r2,zero,9097e54 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 9097e00:	e0ffff17 	ldw	r3,-4(fp)
 9097e04:	00800044 	movi	r2,1
 9097e08:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 9097e0c:	e0ffff17 	ldw	r3,-4(fp)
 9097e10:	00800084 	movi	r2,2
 9097e14:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9097e18:	e0bfff17 	ldw	r2,-4(fp)
 9097e1c:	10800a17 	ldw	r2,40(r2)
 9097e20:	10801404 	addi	r2,r2,80
 9097e24:	1080002b 	ldhuio	r2,0(r2)
 9097e28:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 9097e2c:	e0bffa0b 	ldhu	r2,-24(fp)
 9097e30:	10800044 	addi	r2,r2,1
 9097e34:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 9097e38:	e0bffa0b 	ldhu	r2,-24(fp)
 9097e3c:	1080004c 	andi	r2,r2,1
 9097e40:	1004c03a 	cmpne	r2,r2,zero
 9097e44:	1001621e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 9097e48:	00bffb44 	movi	r2,-19
 9097e4c:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 9097e50:	00015f06 	br	90983d0 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9097e54:	e0bfff17 	ldw	r2,-4(fp)
 9097e58:	11000a17 	ldw	r4,40(r2)
 9097e5c:	01401544 	movi	r5,85
 9097e60:	01802604 	movi	r6,152
 9097e64:	90971e80 	call	90971e8 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 9097e68:	e03ffb15 	stw	zero,-20(fp)
 9097e6c:	00000f06 	br	9097eac <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 9097e70:	e13ffb17 	ldw	r4,-20(fp)
 9097e74:	e0bfff17 	ldw	r2,-4(fp)
 9097e78:	10800a17 	ldw	r2,40(r2)
 9097e7c:	1007883a 	mov	r3,r2
 9097e80:	e0bffb17 	ldw	r2,-20(fp)
 9097e84:	1885883a 	add	r2,r3,r2
 9097e88:	10800804 	addi	r2,r2,32
 9097e8c:	10800023 	ldbuio	r2,0(r2)
 9097e90:	1007883a 	mov	r3,r2
 9097e94:	e0bffc04 	addi	r2,fp,-16
 9097e98:	1105883a 	add	r2,r2,r4
 9097e9c:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 9097ea0:	e0bffb17 	ldw	r2,-20(fp)
 9097ea4:	10800044 	addi	r2,r2,1
 9097ea8:	e0bffb15 	stw	r2,-20(fp)
 9097eac:	e0bffb17 	ldw	r2,-20(fp)
 9097eb0:	10800190 	cmplti	r2,r2,6
 9097eb4:	103fee1e 	bne	r2,zero,9097e70 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9097eb8:	e0bffc03 	ldbu	r2,-16(fp)
 9097ebc:	10803fcc 	andi	r2,r2,255
 9097ec0:	10801458 	cmpnei	r2,r2,81
 9097ec4:	1000291e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
 9097ec8:	e0bffc43 	ldbu	r2,-15(fp)
 9097ecc:	10803fcc 	andi	r2,r2,255
 9097ed0:	1004c03a 	cmpne	r2,r2,zero
 9097ed4:	1000251e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
 9097ed8:	e0bffc83 	ldbu	r2,-14(fp)
 9097edc:	10803fcc 	andi	r2,r2,255
 9097ee0:	10801498 	cmpnei	r2,r2,82
 9097ee4:	1000211e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
 9097ee8:	e0bffcc3 	ldbu	r2,-13(fp)
 9097eec:	10803fcc 	andi	r2,r2,255
 9097ef0:	1004c03a 	cmpne	r2,r2,zero
 9097ef4:	10001d1e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
 9097ef8:	e0bffd03 	ldbu	r2,-12(fp)
 9097efc:	10803fcc 	andi	r2,r2,255
 9097f00:	10801658 	cmpnei	r2,r2,89
 9097f04:	1000191e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
 9097f08:	e0bffd43 	ldbu	r2,-11(fp)
 9097f0c:	10803fcc 	andi	r2,r2,255
 9097f10:	1004c03a 	cmpne	r2,r2,zero
 9097f14:	1000151e 	bne	r2,zero,9097f6c <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 9097f18:	e0ffff17 	ldw	r3,-4(fp)
 9097f1c:	00800084 	movi	r2,2
 9097f20:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 9097f24:	e0ffff17 	ldw	r3,-4(fp)
 9097f28:	00800084 	movi	r2,2
 9097f2c:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 9097f30:	e0bfff17 	ldw	r2,-4(fp)
 9097f34:	10800a17 	ldw	r2,40(r2)
 9097f38:	10801404 	addi	r2,r2,80
 9097f3c:	1080002b 	ldhuio	r2,0(r2)
 9097f40:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 9097f44:	e0bffa0b 	ldhu	r2,-24(fp)
 9097f48:	10800044 	addi	r2,r2,1
 9097f4c:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 9097f50:	e0bffa0b 	ldhu	r2,-24(fp)
 9097f54:	1080008c 	andi	r2,r2,2
 9097f58:	1004c03a 	cmpne	r2,r2,zero
 9097f5c:	10011c1e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 9097f60:	00bffb44 	movi	r2,-19
 9097f64:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 9097f68:	00011906 	br	90983d0 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 9097f6c:	e0bfff17 	ldw	r2,-4(fp)
 9097f70:	11000a17 	ldw	r4,40(r2)
 9097f74:	01401544 	movi	r5,85
 9097f78:	01802604 	movi	r6,152
 9097f7c:	90972740 	call	9097274 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 9097f80:	e03ffb15 	stw	zero,-20(fp)
 9097f84:	00000f06 	br	9097fc4 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9097f88:	e13ffb17 	ldw	r4,-20(fp)
 9097f8c:	e0bfff17 	ldw	r2,-4(fp)
 9097f90:	10800a17 	ldw	r2,40(r2)
 9097f94:	1007883a 	mov	r3,r2
 9097f98:	e0bffb17 	ldw	r2,-20(fp)
 9097f9c:	1885883a 	add	r2,r3,r2
 9097fa0:	10801004 	addi	r2,r2,64
 9097fa4:	10800023 	ldbuio	r2,0(r2)
 9097fa8:	1007883a 	mov	r3,r2
 9097fac:	e0bffc04 	addi	r2,fp,-16
 9097fb0:	1105883a 	add	r2,r2,r4
 9097fb4:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 9097fb8:	e0bffb17 	ldw	r2,-20(fp)
 9097fbc:	10800044 	addi	r2,r2,1
 9097fc0:	e0bffb15 	stw	r2,-20(fp)
 9097fc4:	e0bffb17 	ldw	r2,-20(fp)
 9097fc8:	10800310 	cmplti	r2,r2,12
 9097fcc:	103fee1e 	bne	r2,zero,9097f88 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 9097fd0:	e0bffc03 	ldbu	r2,-16(fp)
 9097fd4:	10803fcc 	andi	r2,r2,255
 9097fd8:	10801458 	cmpnei	r2,r2,81
 9097fdc:	1000411e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9097fe0:	e0bffc43 	ldbu	r2,-15(fp)
 9097fe4:	10803fcc 	andi	r2,r2,255
 9097fe8:	1004c03a 	cmpne	r2,r2,zero
 9097fec:	10003d1e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9097ff0:	e0bffc83 	ldbu	r2,-14(fp)
 9097ff4:	10803fcc 	andi	r2,r2,255
 9097ff8:	1004c03a 	cmpne	r2,r2,zero
 9097ffc:	1000391e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098000:	e0bffcc3 	ldbu	r2,-13(fp)
 9098004:	10803fcc 	andi	r2,r2,255
 9098008:	1004c03a 	cmpne	r2,r2,zero
 909800c:	1000351e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098010:	e0bffd03 	ldbu	r2,-12(fp)
 9098014:	10803fcc 	andi	r2,r2,255
 9098018:	10801498 	cmpnei	r2,r2,82
 909801c:	1000311e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098020:	e0bffd43 	ldbu	r2,-11(fp)
 9098024:	10803fcc 	andi	r2,r2,255
 9098028:	1004c03a 	cmpne	r2,r2,zero
 909802c:	10002d1e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098030:	e0bffd83 	ldbu	r2,-10(fp)
 9098034:	10803fcc 	andi	r2,r2,255
 9098038:	1004c03a 	cmpne	r2,r2,zero
 909803c:	1000291e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098040:	e0bffdc3 	ldbu	r2,-9(fp)
 9098044:	10803fcc 	andi	r2,r2,255
 9098048:	1004c03a 	cmpne	r2,r2,zero
 909804c:	1000251e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098050:	e0bffe03 	ldbu	r2,-8(fp)
 9098054:	10803fcc 	andi	r2,r2,255
 9098058:	10801658 	cmpnei	r2,r2,89
 909805c:	1000211e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098060:	e0bffe43 	ldbu	r2,-7(fp)
 9098064:	10803fcc 	andi	r2,r2,255
 9098068:	1004c03a 	cmpne	r2,r2,zero
 909806c:	10001d1e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098070:	e0bffe83 	ldbu	r2,-6(fp)
 9098074:	10803fcc 	andi	r2,r2,255
 9098078:	1004c03a 	cmpne	r2,r2,zero
 909807c:	1000191e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
 9098080:	e0bffec3 	ldbu	r2,-5(fp)
 9098084:	10803fcc 	andi	r2,r2,255
 9098088:	1004c03a 	cmpne	r2,r2,zero
 909808c:	1000151e 	bne	r2,zero,90980e4 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 9098090:	e0ffff17 	ldw	r3,-4(fp)
 9098094:	00800104 	movi	r2,4
 9098098:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 909809c:	e0ffff17 	ldw	r3,-4(fp)
 90980a0:	00800104 	movi	r2,4
 90980a4:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 90980a8:	e0bfff17 	ldw	r2,-4(fp)
 90980ac:	10800a17 	ldw	r2,40(r2)
 90980b0:	10802804 	addi	r2,r2,160
 90980b4:	10800037 	ldwio	r2,0(r2)
 90980b8:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 90980bc:	e0bffa0b 	ldhu	r2,-24(fp)
 90980c0:	10800044 	addi	r2,r2,1
 90980c4:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 90980c8:	e0bffa0b 	ldhu	r2,-24(fp)
 90980cc:	1080010c 	andi	r2,r2,4
 90980d0:	1004c03a 	cmpne	r2,r2,zero
 90980d4:	1000be1e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 90980d8:	00bffb44 	movi	r2,-19
 90980dc:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 90980e0:	0000bb06 	br	90983d0 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 90980e4:	e0bfff17 	ldw	r2,-4(fp)
 90980e8:	11000a17 	ldw	r4,40(r2)
 90980ec:	01401544 	movi	r5,85
 90980f0:	01802604 	movi	r6,152
 90980f4:	909722c0 	call	909722c <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 90980f8:	e03ffb15 	stw	zero,-20(fp)
 90980fc:	00000f06 	br	909813c <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9098100:	e13ffb17 	ldw	r4,-20(fp)
 9098104:	e0bfff17 	ldw	r2,-4(fp)
 9098108:	10800a17 	ldw	r2,40(r2)
 909810c:	1007883a 	mov	r3,r2
 9098110:	e0bffb17 	ldw	r2,-20(fp)
 9098114:	1885883a 	add	r2,r3,r2
 9098118:	10801004 	addi	r2,r2,64
 909811c:	10800023 	ldbuio	r2,0(r2)
 9098120:	1007883a 	mov	r3,r2
 9098124:	e0bffc04 	addi	r2,fp,-16
 9098128:	1105883a 	add	r2,r2,r4
 909812c:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 9098130:	e0bffb17 	ldw	r2,-20(fp)
 9098134:	10800044 	addi	r2,r2,1
 9098138:	e0bffb15 	stw	r2,-20(fp)
 909813c:	e0bffb17 	ldw	r2,-20(fp)
 9098140:	10800310 	cmplti	r2,r2,12
 9098144:	103fee1e 	bne	r2,zero,9098100 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9098148:	e0bffc03 	ldbu	r2,-16(fp)
 909814c:	10803fcc 	andi	r2,r2,255
 9098150:	10801458 	cmpnei	r2,r2,81
 9098154:	1000411e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 9098158:	e0bffc43 	ldbu	r2,-15(fp)
 909815c:	10803fcc 	andi	r2,r2,255
 9098160:	1004c03a 	cmpne	r2,r2,zero
 9098164:	10003d1e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 9098168:	e0bffc83 	ldbu	r2,-14(fp)
 909816c:	10803fcc 	andi	r2,r2,255
 9098170:	10801458 	cmpnei	r2,r2,81
 9098174:	1000391e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 9098178:	e0bffcc3 	ldbu	r2,-13(fp)
 909817c:	10803fcc 	andi	r2,r2,255
 9098180:	1004c03a 	cmpne	r2,r2,zero
 9098184:	1000351e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 9098188:	e0bffd03 	ldbu	r2,-12(fp)
 909818c:	10803fcc 	andi	r2,r2,255
 9098190:	10801498 	cmpnei	r2,r2,82
 9098194:	1000311e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 9098198:	e0bffd43 	ldbu	r2,-11(fp)
 909819c:	10803fcc 	andi	r2,r2,255
 90981a0:	1004c03a 	cmpne	r2,r2,zero
 90981a4:	10002d1e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981a8:	e0bffd83 	ldbu	r2,-10(fp)
 90981ac:	10803fcc 	andi	r2,r2,255
 90981b0:	10801498 	cmpnei	r2,r2,82
 90981b4:	1000291e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981b8:	e0bffdc3 	ldbu	r2,-9(fp)
 90981bc:	10803fcc 	andi	r2,r2,255
 90981c0:	1004c03a 	cmpne	r2,r2,zero
 90981c4:	1000251e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981c8:	e0bffe03 	ldbu	r2,-8(fp)
 90981cc:	10803fcc 	andi	r2,r2,255
 90981d0:	10801658 	cmpnei	r2,r2,89
 90981d4:	1000211e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981d8:	e0bffe43 	ldbu	r2,-7(fp)
 90981dc:	10803fcc 	andi	r2,r2,255
 90981e0:	1004c03a 	cmpne	r2,r2,zero
 90981e4:	10001d1e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981e8:	e0bffe83 	ldbu	r2,-6(fp)
 90981ec:	10803fcc 	andi	r2,r2,255
 90981f0:	10801658 	cmpnei	r2,r2,89
 90981f4:	1000191e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
 90981f8:	e0bffec3 	ldbu	r2,-5(fp)
 90981fc:	10803fcc 	andi	r2,r2,255
 9098200:	1004c03a 	cmpne	r2,r2,zero
 9098204:	1000151e 	bne	r2,zero,909825c <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 9098208:	e0ffff17 	ldw	r3,-4(fp)
 909820c:	00800084 	movi	r2,2
 9098210:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 9098214:	e0ffff17 	ldw	r3,-4(fp)
 9098218:	00800104 	movi	r2,4
 909821c:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9098220:	e0bfff17 	ldw	r2,-4(fp)
 9098224:	10800a17 	ldw	r2,40(r2)
 9098228:	10802804 	addi	r2,r2,160
 909822c:	10800037 	ldwio	r2,0(r2)
 9098230:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 9098234:	e0bffa0b 	ldhu	r2,-24(fp)
 9098238:	10800044 	addi	r2,r2,1
 909823c:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 9098240:	e0bffa0b 	ldhu	r2,-24(fp)
 9098244:	1080010c 	andi	r2,r2,4
 9098248:	1004c03a 	cmpne	r2,r2,zero
 909824c:	1000601e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 9098250:	00bffb44 	movi	r2,-19
 9098254:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 9098258:	00005d06 	br	90983d0 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 909825c:	e0bfff17 	ldw	r2,-4(fp)
 9098260:	11000a17 	ldw	r4,40(r2)
 9098264:	01401544 	movi	r5,85
 9098268:	01802604 	movi	r6,152
 909826c:	90971a00 	call	90971a0 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 9098270:	e03ffb15 	stw	zero,-20(fp)
 9098274:	00000f06 	br	90982b4 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 9098278:	e13ffb17 	ldw	r4,-20(fp)
 909827c:	e0bfff17 	ldw	r2,-4(fp)
 9098280:	10800a17 	ldw	r2,40(r2)
 9098284:	1007883a 	mov	r3,r2
 9098288:	e0bffb17 	ldw	r2,-20(fp)
 909828c:	1885883a 	add	r2,r3,r2
 9098290:	10801004 	addi	r2,r2,64
 9098294:	10800023 	ldbuio	r2,0(r2)
 9098298:	1007883a 	mov	r3,r2
 909829c:	e0bffc04 	addi	r2,fp,-16
 90982a0:	1105883a 	add	r2,r2,r4
 90982a4:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 90982a8:	e0bffb17 	ldw	r2,-20(fp)
 90982ac:	10800044 	addi	r2,r2,1
 90982b0:	e0bffb15 	stw	r2,-20(fp)
 90982b4:	e0bffb17 	ldw	r2,-20(fp)
 90982b8:	10800310 	cmplti	r2,r2,12
 90982bc:	103fee1e 	bne	r2,zero,9098278 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 90982c0:	e0bffc03 	ldbu	r2,-16(fp)
 90982c4:	10803fcc 	andi	r2,r2,255
 90982c8:	10801458 	cmpnei	r2,r2,81
 90982cc:	1000401e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 90982d0:	e0bffc43 	ldbu	r2,-15(fp)
 90982d4:	10803fcc 	andi	r2,r2,255
 90982d8:	10801458 	cmpnei	r2,r2,81
 90982dc:	10003c1e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 90982e0:	e0bffc83 	ldbu	r2,-14(fp)
 90982e4:	10803fcc 	andi	r2,r2,255
 90982e8:	10801458 	cmpnei	r2,r2,81
 90982ec:	1000381e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 90982f0:	e0bffcc3 	ldbu	r2,-13(fp)
 90982f4:	10803fcc 	andi	r2,r2,255
 90982f8:	10801458 	cmpnei	r2,r2,81
 90982fc:	1000341e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098300:	e0bffd03 	ldbu	r2,-12(fp)
 9098304:	10803fcc 	andi	r2,r2,255
 9098308:	10801498 	cmpnei	r2,r2,82
 909830c:	1000301e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098310:	e0bffd43 	ldbu	r2,-11(fp)
 9098314:	10803fcc 	andi	r2,r2,255
 9098318:	10801498 	cmpnei	r2,r2,82
 909831c:	10002c1e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098320:	e0bffd83 	ldbu	r2,-10(fp)
 9098324:	10803fcc 	andi	r2,r2,255
 9098328:	10801498 	cmpnei	r2,r2,82
 909832c:	1000281e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098330:	e0bffdc3 	ldbu	r2,-9(fp)
 9098334:	10803fcc 	andi	r2,r2,255
 9098338:	10801498 	cmpnei	r2,r2,82
 909833c:	1000241e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098340:	e0bffe03 	ldbu	r2,-8(fp)
 9098344:	10803fcc 	andi	r2,r2,255
 9098348:	10801658 	cmpnei	r2,r2,89
 909834c:	1000201e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098350:	e0bffe43 	ldbu	r2,-7(fp)
 9098354:	10803fcc 	andi	r2,r2,255
 9098358:	10801658 	cmpnei	r2,r2,89
 909835c:	10001c1e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098360:	e0bffe83 	ldbu	r2,-6(fp)
 9098364:	10803fcc 	andi	r2,r2,255
 9098368:	10801658 	cmpnei	r2,r2,89
 909836c:	1000181e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
 9098370:	e0bffec3 	ldbu	r2,-5(fp)
 9098374:	10803fcc 	andi	r2,r2,255
 9098378:	10801658 	cmpnei	r2,r2,89
 909837c:	1000141e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 9098380:	e0ffff17 	ldw	r3,-4(fp)
 9098384:	00800044 	movi	r2,1
 9098388:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 909838c:	e0ffff17 	ldw	r3,-4(fp)
 9098390:	00800104 	movi	r2,4
 9098394:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 9098398:	e0bfff17 	ldw	r2,-4(fp)
 909839c:	10800a17 	ldw	r2,40(r2)
 90983a0:	10802804 	addi	r2,r2,160
 90983a4:	10800037 	ldwio	r2,0(r2)
 90983a8:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 90983ac:	e0bffa0b 	ldhu	r2,-24(fp)
 90983b0:	10800044 	addi	r2,r2,1
 90983b4:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 90983b8:	e0bffa0b 	ldhu	r2,-24(fp)
 90983bc:	1080010c 	andi	r2,r2,4
 90983c0:	1004c03a 	cmpne	r2,r2,zero
 90983c4:	1000021e 	bne	r2,zero,90983d0 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 90983c8:	00bffb44 	movi	r2,-19
 90983cc:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 90983d0:	e0bff917 	ldw	r2,-28(fp)
}
 90983d4:	e037883a 	mov	sp,fp
 90983d8:	dfc00117 	ldw	ra,4(sp)
 90983dc:	df000017 	ldw	fp,0(sp)
 90983e0:	dec00204 	addi	sp,sp,8
 90983e4:	f800283a 	ret

090983e8 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 90983e8:	defff904 	addi	sp,sp,-28
 90983ec:	dfc00615 	stw	ra,24(sp)
 90983f0:	df000515 	stw	fp,20(sp)
 90983f4:	dc000415 	stw	r16,16(sp)
 90983f8:	df000404 	addi	fp,sp,16
 90983fc:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 9098400:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 9098404:	e13fff17 	ldw	r4,-4(fp)
 9098408:	01400544 	movi	r5,21
 909840c:	90975e00 	call	90975e0 <alt_read_16bit_query_entry>
 9098410:	10ffffcc 	andi	r3,r2,65535
 9098414:	e0bfff17 	ldw	r2,-4(fp)
 9098418:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 909841c:	e03ffd15 	stw	zero,-12(fp)
 9098420:	00001006 	br	9098464 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 9098424:	e43ffd17 	ldw	r16,-12(fp)
 9098428:	e0bfff17 	ldw	r2,-4(fp)
 909842c:	11803417 	ldw	r6,208(r2)
 9098430:	e0bfff17 	ldw	r2,-4(fp)
 9098434:	10c03217 	ldw	r3,200(r2)
 9098438:	e0bffd17 	ldw	r2,-12(fp)
 909843c:	188b883a 	add	r5,r3,r2
 9098440:	e13fff17 	ldw	r4,-4(fp)
 9098444:	303ee83a 	callr	r6
 9098448:	1007883a 	mov	r3,r2
 909844c:	e0bffe04 	addi	r2,fp,-8
 9098450:	1405883a 	add	r2,r2,r16
 9098454:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 9098458:	e0bffd17 	ldw	r2,-12(fp)
 909845c:	10800044 	addi	r2,r2,1
 9098460:	e0bffd15 	stw	r2,-12(fp)
 9098464:	e0bffd17 	ldw	r2,-12(fp)
 9098468:	108000d0 	cmplti	r2,r2,3
 909846c:	103fed1e 	bne	r2,zero,9098424 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 9098470:	e0bffe03 	ldbu	r2,-8(fp)
 9098474:	10803fcc 	andi	r2,r2,255
 9098478:	10801418 	cmpnei	r2,r2,80
 909847c:	1000081e 	bne	r2,zero,90984a0 <alt_check_primary_table+0xb8>
 9098480:	e0bffe43 	ldbu	r2,-7(fp)
 9098484:	10803fcc 	andi	r2,r2,255
 9098488:	10801498 	cmpnei	r2,r2,82
 909848c:	1000041e 	bne	r2,zero,90984a0 <alt_check_primary_table+0xb8>
 9098490:	e0bffe83 	ldbu	r2,-6(fp)
 9098494:	10803fcc 	andi	r2,r2,255
 9098498:	10801260 	cmpeqi	r2,r2,73
 909849c:	1000021e 	bne	r2,zero,90984a8 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 90984a0:	00bffb44 	movi	r2,-19
 90984a4:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 90984a8:	e0bffc17 	ldw	r2,-16(fp)
}
 90984ac:	e037883a 	mov	sp,fp
 90984b0:	dfc00217 	ldw	ra,8(sp)
 90984b4:	df000117 	ldw	fp,4(sp)
 90984b8:	dc000017 	ldw	r16,0(sp)
 90984bc:	dec00304 	addi	sp,sp,12
 90984c0:	f800283a 	ret

090984c4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 90984c4:	defffa04 	addi	sp,sp,-24
 90984c8:	dfc00515 	stw	ra,20(sp)
 90984cc:	df000415 	stw	fp,16(sp)
 90984d0:	df000404 	addi	fp,sp,16
 90984d4:	e13ffd15 	stw	r4,-12(fp)
 90984d8:	e17ffe15 	stw	r5,-8(fp)
 90984dc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 90984e0:	e0bffd17 	ldw	r2,-12(fp)
 90984e4:	10800017 	ldw	r2,0(r2)
 90984e8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 90984ec:	e0bffc17 	ldw	r2,-16(fp)
 90984f0:	11000a04 	addi	r4,r2,40
 90984f4:	e0bffd17 	ldw	r2,-12(fp)
 90984f8:	11c00217 	ldw	r7,8(r2)
 90984fc:	e17ffe17 	ldw	r5,-8(fp)
 9098500:	e1bfff17 	ldw	r6,-4(fp)
 9098504:	9098c840 	call	9098c84 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 9098508:	e037883a 	mov	sp,fp
 909850c:	dfc00117 	ldw	ra,4(sp)
 9098510:	df000017 	ldw	fp,0(sp)
 9098514:	dec00204 	addi	sp,sp,8
 9098518:	f800283a 	ret

0909851c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 909851c:	defffa04 	addi	sp,sp,-24
 9098520:	dfc00515 	stw	ra,20(sp)
 9098524:	df000415 	stw	fp,16(sp)
 9098528:	df000404 	addi	fp,sp,16
 909852c:	e13ffd15 	stw	r4,-12(fp)
 9098530:	e17ffe15 	stw	r5,-8(fp)
 9098534:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9098538:	e0bffd17 	ldw	r2,-12(fp)
 909853c:	10800017 	ldw	r2,0(r2)
 9098540:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 9098544:	e0bffc17 	ldw	r2,-16(fp)
 9098548:	11000a04 	addi	r4,r2,40
 909854c:	e0bffd17 	ldw	r2,-12(fp)
 9098550:	11c00217 	ldw	r7,8(r2)
 9098554:	e17ffe17 	ldw	r5,-8(fp)
 9098558:	e1bfff17 	ldw	r6,-4(fp)
 909855c:	9098f440 	call	9098f44 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 9098560:	e037883a 	mov	sp,fp
 9098564:	dfc00117 	ldw	ra,4(sp)
 9098568:	df000017 	ldw	fp,0(sp)
 909856c:	dec00204 	addi	sp,sp,8
 9098570:	f800283a 	ret

09098574 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 9098574:	defffc04 	addi	sp,sp,-16
 9098578:	dfc00315 	stw	ra,12(sp)
 909857c:	df000215 	stw	fp,8(sp)
 9098580:	df000204 	addi	fp,sp,8
 9098584:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 9098588:	e0bfff17 	ldw	r2,-4(fp)
 909858c:	10800017 	ldw	r2,0(r2)
 9098590:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 9098594:	e0bffe17 	ldw	r2,-8(fp)
 9098598:	11000a04 	addi	r4,r2,40
 909859c:	e0bfff17 	ldw	r2,-4(fp)
 90985a0:	11400217 	ldw	r5,8(r2)
 90985a4:	9098b1c0 	call	9098b1c <altera_avalon_jtag_uart_close>
}
 90985a8:	e037883a 	mov	sp,fp
 90985ac:	dfc00117 	ldw	ra,4(sp)
 90985b0:	df000017 	ldw	fp,0(sp)
 90985b4:	dec00204 	addi	sp,sp,8
 90985b8:	f800283a 	ret

090985bc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 90985bc:	defffa04 	addi	sp,sp,-24
 90985c0:	dfc00515 	stw	ra,20(sp)
 90985c4:	df000415 	stw	fp,16(sp)
 90985c8:	df000404 	addi	fp,sp,16
 90985cc:	e13ffd15 	stw	r4,-12(fp)
 90985d0:	e17ffe15 	stw	r5,-8(fp)
 90985d4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 90985d8:	e0bffd17 	ldw	r2,-12(fp)
 90985dc:	10800017 	ldw	r2,0(r2)
 90985e0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 90985e4:	e0bffc17 	ldw	r2,-16(fp)
 90985e8:	11000a04 	addi	r4,r2,40
 90985ec:	e17ffe17 	ldw	r5,-8(fp)
 90985f0:	e1bfff17 	ldw	r6,-4(fp)
 90985f4:	9098b900 	call	9098b90 <altera_avalon_jtag_uart_ioctl>
}
 90985f8:	e037883a 	mov	sp,fp
 90985fc:	dfc00117 	ldw	ra,4(sp)
 9098600:	df000017 	ldw	fp,0(sp)
 9098604:	dec00204 	addi	sp,sp,8
 9098608:	f800283a 	ret

0909860c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 909860c:	defff404 	addi	sp,sp,-48
 9098610:	dfc00b15 	stw	ra,44(sp)
 9098614:	df000a15 	stw	fp,40(sp)
 9098618:	df000a04 	addi	fp,sp,40
 909861c:	e13ffd15 	stw	r4,-12(fp)
 9098620:	e17ffe15 	stw	r5,-8(fp)
 9098624:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 9098628:	e0bffd17 	ldw	r2,-12(fp)
 909862c:	10800c04 	addi	r2,r2,48
 9098630:	e0bffb15 	stw	r2,-20(fp)
 9098634:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 9098638:	e13ffc0b 	ldhu	r4,-16(fp)
 909863c:	e17ffc84 	addi	r5,fp,-14
 9098640:	90906a40 	call	90906a4 <OSFlagCreate>
 9098644:	1007883a 	mov	r3,r2
 9098648:	e0bffb17 	ldw	r2,-20(fp)
 909864c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 9098650:	e0bffd17 	ldw	r2,-12(fp)
 9098654:	10800a04 	addi	r2,r2,40
 9098658:	e0bff915 	stw	r2,-28(fp)
 909865c:	00800044 	movi	r2,1
 9098660:	e0bffa0d 	sth	r2,-24(fp)
 9098664:	e13ffa0b 	ldhu	r4,-24(fp)
 9098668:	90938a80 	call	90938a8 <OSSemCreate>
 909866c:	1007883a 	mov	r3,r2
 9098670:	e0bff917 	ldw	r2,-28(fp)
 9098674:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 9098678:	e0bffd17 	ldw	r2,-12(fp)
 909867c:	10800b04 	addi	r2,r2,44
 9098680:	e0bff715 	stw	r2,-36(fp)
 9098684:	00800044 	movi	r2,1
 9098688:	e0bff80d 	sth	r2,-32(fp)
 909868c:	e13ff80b 	ldhu	r4,-32(fp)
 9098690:	90938a80 	call	90938a8 <OSSemCreate>
 9098694:	1007883a 	mov	r3,r2
 9098698:	e0bff717 	ldw	r2,-36(fp)
 909869c:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 90986a0:	e0fffd17 	ldw	r3,-12(fp)
 90986a4:	00800044 	movi	r2,1
 90986a8:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 90986ac:	e0bffd17 	ldw	r2,-12(fp)
 90986b0:	10800017 	ldw	r2,0(r2)
 90986b4:	11000104 	addi	r4,r2,4
 90986b8:	e0bffd17 	ldw	r2,-12(fp)
 90986bc:	10800817 	ldw	r2,32(r2)
 90986c0:	1007883a 	mov	r3,r2
 90986c4:	2005883a 	mov	r2,r4
 90986c8:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 90986cc:	e13ffe17 	ldw	r4,-8(fp)
 90986d0:	e17fff17 	ldw	r5,-4(fp)
 90986d4:	d8000015 	stw	zero,0(sp)
 90986d8:	018242b4 	movhi	r6,2314
 90986dc:	31a1d104 	addi	r6,r6,-30908
 90986e0:	e1fffd17 	ldw	r7,-12(fp)
 90986e4:	90b9f580 	call	90b9f58 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 90986e8:	e0bffd17 	ldw	r2,-12(fp)
 90986ec:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 90986f0:	e0bffd17 	ldw	r2,-12(fp)
 90986f4:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 90986f8:	00824374 	movhi	r2,2317
 90986fc:	108f3e04 	addi	r2,r2,15608
 9098700:	10800017 	ldw	r2,0(r2)
 9098704:	100b883a 	mov	r5,r2
 9098708:	018242b4 	movhi	r6,2314
 909870c:	31a28204 	addi	r6,r6,-30200
 9098710:	e1fffd17 	ldw	r7,-12(fp)
 9098714:	90b998c0 	call	90b998c <alt_alarm_start>
 9098718:	1004403a 	cmpge	r2,r2,zero
 909871c:	1000041e 	bne	r2,zero,9098730 <altera_avalon_jtag_uart_init+0x124>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 9098720:	e0fffd17 	ldw	r3,-12(fp)
 9098724:	00a00034 	movhi	r2,32768
 9098728:	10bfffc4 	addi	r2,r2,-1
 909872c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 9098730:	e037883a 	mov	sp,fp
 9098734:	dfc00117 	ldw	ra,4(sp)
 9098738:	df000017 	ldw	fp,0(sp)
 909873c:	dec00204 	addi	sp,sp,8
 9098740:	f800283a 	ret

09098744 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 9098744:	defff204 	addi	sp,sp,-56
 9098748:	dfc00d15 	stw	ra,52(sp)
 909874c:	df000c15 	stw	fp,48(sp)
 9098750:	df000c04 	addi	fp,sp,48
 9098754:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 9098758:	e0bfff17 	ldw	r2,-4(fp)
 909875c:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 9098760:	e0bffd17 	ldw	r2,-12(fp)
 9098764:	10800017 	ldw	r2,0(r2)
 9098768:	e0bffc15 	stw	r2,-16(fp)
 909876c:	00000006 	br	9098770 <altera_avalon_jtag_uart_irq+0x2c>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 9098770:	e0bffc17 	ldw	r2,-16(fp)
 9098774:	10800104 	addi	r2,r2,4
 9098778:	10800037 	ldwio	r2,0(r2)
 909877c:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 9098780:	e0bffb17 	ldw	r2,-20(fp)
 9098784:	1080c00c 	andi	r2,r2,768
 9098788:	1005003a 	cmpeq	r2,r2,zero
 909878c:	1000991e 	bne	r2,zero,90989f4 <altera_avalon_jtag_uart_irq+0x2b0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 9098790:	e0bffb17 	ldw	r2,-20(fp)
 9098794:	1080400c 	andi	r2,r2,256
 9098798:	1005003a 	cmpeq	r2,r2,zero
 909879c:	1000481e 	bne	r2,zero,90988c0 <altera_avalon_jtag_uart_irq+0x17c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 90987a0:	00800074 	movhi	r2,1
 90987a4:	e0bffa15 	stw	r2,-24(fp)
 90987a8:	00000006 	br	90987ac <altera_avalon_jtag_uart_irq+0x68>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 90987ac:	e0bffd17 	ldw	r2,-12(fp)
 90987b0:	10800d17 	ldw	r2,52(r2)
 90987b4:	10800044 	addi	r2,r2,1
 90987b8:	1081ffcc 	andi	r2,r2,2047
 90987bc:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 90987c0:	e0bffd17 	ldw	r2,-12(fp)
 90987c4:	10c00e17 	ldw	r3,56(r2)
 90987c8:	e0bff917 	ldw	r2,-28(fp)
 90987cc:	18802826 	beq	r3,r2,9098870 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 90987d0:	e0bffc17 	ldw	r2,-16(fp)
 90987d4:	10800037 	ldwio	r2,0(r2)
 90987d8:	e0bffa15 	stw	r2,-24(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 90987dc:	e0bffa17 	ldw	r2,-24(fp)
 90987e0:	10a0000c 	andi	r2,r2,32768
 90987e4:	1005003a 	cmpeq	r2,r2,zero
 90987e8:	1000211e 	bne	r2,zero,9098870 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 90987ec:	e0bffd17 	ldw	r2,-12(fp)
 90987f0:	10c00d17 	ldw	r3,52(r2)
 90987f4:	e0bffa17 	ldw	r2,-24(fp)
 90987f8:	1009883a 	mov	r4,r2
 90987fc:	e0bffd17 	ldw	r2,-12(fp)
 9098800:	1885883a 	add	r2,r3,r2
 9098804:	10801104 	addi	r2,r2,68
 9098808:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 909880c:	e0bffd17 	ldw	r2,-12(fp)
 9098810:	10800d17 	ldw	r2,52(r2)
 9098814:	10800044 	addi	r2,r2,1
 9098818:	10c1ffcc 	andi	r3,r2,2047
 909881c:	e0bffd17 	ldw	r2,-12(fp)
 9098820:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 9098824:	e0bffd17 	ldw	r2,-12(fp)
 9098828:	10800c17 	ldw	r2,48(r2)
 909882c:	e0bff615 	stw	r2,-40(fp)
 9098830:	00800044 	movi	r2,1
 9098834:	e0bff70d 	sth	r2,-36(fp)
 9098838:	00800044 	movi	r2,1
 909883c:	e0bff785 	stb	r2,-34(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9098840:	00824374 	movhi	r2,2317
 9098844:	108ef144 	addi	r2,r2,15301
 9098848:	10800003 	ldbu	r2,0(r2)
 909884c:	10803fcc 	andi	r2,r2,255
 9098850:	1005003a 	cmpeq	r2,r2,zero
 9098854:	103fd51e 	bne	r2,zero,90987ac <altera_avalon_jtag_uart_irq+0x68>
  {
    OSFlagPost (group, flags, opt, &err);
 9098858:	e17ff70b 	ldhu	r5,-36(fp)
 909885c:	e1bff783 	ldbu	r6,-34(fp)
 9098860:	e1fffe04 	addi	r7,fp,-8
 9098864:	e13ff617 	ldw	r4,-40(fp)
 9098868:	90913cc0 	call	90913cc <OSFlagPost>
    return err;
 909886c:	003fcf06 	br	90987ac <altera_avalon_jtag_uart_irq+0x68>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 9098870:	e0bffa17 	ldw	r2,-24(fp)
 9098874:	10bfffec 	andhi	r2,r2,65535
 9098878:	1005003a 	cmpeq	r2,r2,zero
 909887c:	1000101e 	bne	r2,zero,90988c0 <altera_avalon_jtag_uart_irq+0x17c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9098880:	e0bffd17 	ldw	r2,-12(fp)
 9098884:	10c00817 	ldw	r3,32(r2)
 9098888:	00bfff84 	movi	r2,-2
 909888c:	1886703a 	and	r3,r3,r2
 9098890:	e0bffd17 	ldw	r2,-12(fp)
 9098894:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 9098898:	e0bffc17 	ldw	r2,-16(fp)
 909889c:	11000104 	addi	r4,r2,4
 90988a0:	e0bffd17 	ldw	r2,-12(fp)
 90988a4:	10800817 	ldw	r2,32(r2)
 90988a8:	1007883a 	mov	r3,r2
 90988ac:	2005883a 	mov	r2,r4
 90988b0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 90988b4:	e0bffc17 	ldw	r2,-16(fp)
 90988b8:	10800104 	addi	r2,r2,4
 90988bc:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 90988c0:	e0bffb17 	ldw	r2,-20(fp)
 90988c4:	1080800c 	andi	r2,r2,512
 90988c8:	1005003a 	cmpeq	r2,r2,zero
 90988cc:	103fa81e 	bne	r2,zero,9098770 <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 90988d0:	e0bffb17 	ldw	r2,-20(fp)
 90988d4:	10bfffec 	andhi	r2,r2,65535
 90988d8:	1004d43a 	srli	r2,r2,16
 90988dc:	e0bff815 	stw	r2,-32(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 90988e0:	00002706 	br	9098980 <altera_avalon_jtag_uart_irq+0x23c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 90988e4:	e13ffc17 	ldw	r4,-16(fp)
 90988e8:	e0bffd17 	ldw	r2,-12(fp)
 90988ec:	10c01017 	ldw	r3,64(r2)
 90988f0:	e0bffd17 	ldw	r2,-12(fp)
 90988f4:	1885883a 	add	r2,r3,r2
 90988f8:	10821104 	addi	r2,r2,2116
 90988fc:	10800003 	ldbu	r2,0(r2)
 9098900:	10c03fcc 	andi	r3,r2,255
 9098904:	18c0201c 	xori	r3,r3,128
 9098908:	18ffe004 	addi	r3,r3,-128
 909890c:	2005883a 	mov	r2,r4
 9098910:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9098914:	e0bffd17 	ldw	r2,-12(fp)
 9098918:	10801017 	ldw	r2,64(r2)
 909891c:	10800044 	addi	r2,r2,1
 9098920:	10c1ffcc 	andi	r3,r2,2047
 9098924:	e0bffd17 	ldw	r2,-12(fp)
 9098928:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 909892c:	e0bffd17 	ldw	r2,-12(fp)
 9098930:	10800c17 	ldw	r2,48(r2)
 9098934:	e0bff415 	stw	r2,-48(fp)
 9098938:	00800084 	movi	r2,2
 909893c:	e0bff50d 	sth	r2,-44(fp)
 9098940:	00800044 	movi	r2,1
 9098944:	e0bff585 	stb	r2,-42(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9098948:	00824374 	movhi	r2,2317
 909894c:	108ef144 	addi	r2,r2,15301
 9098950:	10800003 	ldbu	r2,0(r2)
 9098954:	10803fcc 	andi	r2,r2,255
 9098958:	1005003a 	cmpeq	r2,r2,zero
 909895c:	1000051e 	bne	r2,zero,9098974 <altera_avalon_jtag_uart_irq+0x230>
  {
    OSFlagPost (group, flags, opt, &err);
 9098960:	e17ff50b 	ldhu	r5,-44(fp)
 9098964:	e1bff583 	ldbu	r6,-42(fp)
 9098968:	e1fffe44 	addi	r7,fp,-7
 909896c:	e13ff417 	ldw	r4,-48(fp)
 9098970:	90913cc0 	call	90913cc <OSFlagPost>

        space--;
 9098974:	e0bff817 	ldw	r2,-32(fp)
 9098978:	10bfffc4 	addi	r2,r2,-1
 909897c:	e0bff815 	stw	r2,-32(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 9098980:	e0bff817 	ldw	r2,-32(fp)
 9098984:	1005003a 	cmpeq	r2,r2,zero
 9098988:	1000051e 	bne	r2,zero,90989a0 <altera_avalon_jtag_uart_irq+0x25c>
 909898c:	e0bffd17 	ldw	r2,-12(fp)
 9098990:	10c01017 	ldw	r3,64(r2)
 9098994:	e0bffd17 	ldw	r2,-12(fp)
 9098998:	10800f17 	ldw	r2,60(r2)
 909899c:	18bfd11e 	bne	r3,r2,90988e4 <altera_avalon_jtag_uart_irq+0x1a0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 90989a0:	e0bff817 	ldw	r2,-32(fp)
 90989a4:	1005003a 	cmpeq	r2,r2,zero
 90989a8:	103f711e 	bne	r2,zero,9098770 <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 90989ac:	e0bffd17 	ldw	r2,-12(fp)
 90989b0:	10c00817 	ldw	r3,32(r2)
 90989b4:	00bfff44 	movi	r2,-3
 90989b8:	1886703a 	and	r3,r3,r2
 90989bc:	e0bffd17 	ldw	r2,-12(fp)
 90989c0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 90989c4:	e0bffd17 	ldw	r2,-12(fp)
 90989c8:	10800017 	ldw	r2,0(r2)
 90989cc:	11000104 	addi	r4,r2,4
 90989d0:	e0bffd17 	ldw	r2,-12(fp)
 90989d4:	10800817 	ldw	r2,32(r2)
 90989d8:	1007883a 	mov	r3,r2
 90989dc:	2005883a 	mov	r2,r4
 90989e0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 90989e4:	e0bffc17 	ldw	r2,-16(fp)
 90989e8:	10800104 	addi	r2,r2,4
 90989ec:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 90989f0:	003f5f06 	br	9098770 <altera_avalon_jtag_uart_irq+0x2c>
}
 90989f4:	e037883a 	mov	sp,fp
 90989f8:	dfc00117 	ldw	ra,4(sp)
 90989fc:	df000017 	ldw	fp,0(sp)
 9098a00:	dec00204 	addi	sp,sp,8
 9098a04:	f800283a 	ret

09098a08 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 9098a08:	defff804 	addi	sp,sp,-32
 9098a0c:	dfc00715 	stw	ra,28(sp)
 9098a10:	df000615 	stw	fp,24(sp)
 9098a14:	df000604 	addi	fp,sp,24
 9098a18:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 9098a1c:	e0bfff17 	ldw	r2,-4(fp)
 9098a20:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 9098a24:	e0bffd17 	ldw	r2,-12(fp)
 9098a28:	10800017 	ldw	r2,0(r2)
 9098a2c:	10800104 	addi	r2,r2,4
 9098a30:	10800037 	ldwio	r2,0(r2)
 9098a34:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 9098a38:	e0bffc17 	ldw	r2,-16(fp)
 9098a3c:	1081000c 	andi	r2,r2,1024
 9098a40:	1005003a 	cmpeq	r2,r2,zero
 9098a44:	10000c1e 	bne	r2,zero,9098a78 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 9098a48:	e0bffd17 	ldw	r2,-12(fp)
 9098a4c:	10800017 	ldw	r2,0(r2)
 9098a50:	11000104 	addi	r4,r2,4
 9098a54:	e0bffd17 	ldw	r2,-12(fp)
 9098a58:	10800817 	ldw	r2,32(r2)
 9098a5c:	10810014 	ori	r2,r2,1024
 9098a60:	1007883a 	mov	r3,r2
 9098a64:	2005883a 	mov	r2,r4
 9098a68:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 9098a6c:	e0bffd17 	ldw	r2,-12(fp)
 9098a70:	10000915 	stw	zero,36(r2)
 9098a74:	00002106 	br	9098afc <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 9098a78:	e0bffd17 	ldw	r2,-12(fp)
 9098a7c:	10c00917 	ldw	r3,36(r2)
 9098a80:	00a00034 	movhi	r2,32768
 9098a84:	10bfff04 	addi	r2,r2,-4
 9098a88:	10c01c36 	bltu	r2,r3,9098afc <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 9098a8c:	e0bffd17 	ldw	r2,-12(fp)
 9098a90:	10800917 	ldw	r2,36(r2)
 9098a94:	10c00044 	addi	r3,r2,1
 9098a98:	e0bffd17 	ldw	r2,-12(fp)
 9098a9c:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 9098aa0:	e0bffd17 	ldw	r2,-12(fp)
 9098aa4:	10c00917 	ldw	r3,36(r2)
 9098aa8:	e0bffd17 	ldw	r2,-12(fp)
 9098aac:	10800117 	ldw	r2,4(r2)
 9098ab0:	18801236 	bltu	r3,r2,9098afc <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 9098ab4:	e0bffd17 	ldw	r2,-12(fp)
 9098ab8:	10800c17 	ldw	r2,48(r2)
 9098abc:	e0bffa15 	stw	r2,-24(fp)
 9098ac0:	00800104 	movi	r2,4
 9098ac4:	e0bffb0d 	sth	r2,-20(fp)
 9098ac8:	00800044 	movi	r2,1
 9098acc:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 9098ad0:	00824374 	movhi	r2,2317
 9098ad4:	108ef144 	addi	r2,r2,15301
 9098ad8:	10800003 	ldbu	r2,0(r2)
 9098adc:	10803fcc 	andi	r2,r2,255
 9098ae0:	1005003a 	cmpeq	r2,r2,zero
 9098ae4:	1000051e 	bne	r2,zero,9098afc <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 9098ae8:	e17ffb0b 	ldhu	r5,-20(fp)
 9098aec:	e1bffb83 	ldbu	r6,-18(fp)
 9098af0:	e1fffe04 	addi	r7,fp,-8
 9098af4:	e13ffa17 	ldw	r4,-24(fp)
 9098af8:	90913cc0 	call	90913cc <OSFlagPost>
 9098afc:	00824374 	movhi	r2,2317
 9098b00:	108f3e04 	addi	r2,r2,15608
 9098b04:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 9098b08:	e037883a 	mov	sp,fp
 9098b0c:	dfc00117 	ldw	ra,4(sp)
 9098b10:	df000017 	ldw	fp,0(sp)
 9098b14:	dec00204 	addi	sp,sp,8
 9098b18:	f800283a 	ret

09098b1c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 9098b1c:	defffc04 	addi	sp,sp,-16
 9098b20:	df000315 	stw	fp,12(sp)
 9098b24:	df000304 	addi	fp,sp,12
 9098b28:	e13ffd15 	stw	r4,-12(fp)
 9098b2c:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9098b30:	00000706 	br	9098b50 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 9098b34:	e0bffe17 	ldw	r2,-8(fp)
 9098b38:	1090000c 	andi	r2,r2,16384
 9098b3c:	1005003a 	cmpeq	r2,r2,zero
 9098b40:	1000031e 	bne	r2,zero,9098b50 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 9098b44:	00bffd44 	movi	r2,-11
 9098b48:	e0bfff15 	stw	r2,-4(fp)
 9098b4c:	00000b06 	br	9098b7c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 9098b50:	e0bffd17 	ldw	r2,-12(fp)
 9098b54:	10c01017 	ldw	r3,64(r2)
 9098b58:	e0bffd17 	ldw	r2,-12(fp)
 9098b5c:	10800f17 	ldw	r2,60(r2)
 9098b60:	18800526 	beq	r3,r2,9098b78 <altera_avalon_jtag_uart_close+0x5c>
 9098b64:	e0bffd17 	ldw	r2,-12(fp)
 9098b68:	10c00917 	ldw	r3,36(r2)
 9098b6c:	e0bffd17 	ldw	r2,-12(fp)
 9098b70:	10800117 	ldw	r2,4(r2)
 9098b74:	18bfef36 	bltu	r3,r2,9098b34 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 9098b78:	e03fff15 	stw	zero,-4(fp)
 9098b7c:	e0bfff17 	ldw	r2,-4(fp)
}
 9098b80:	e037883a 	mov	sp,fp
 9098b84:	df000017 	ldw	fp,0(sp)
 9098b88:	dec00104 	addi	sp,sp,4
 9098b8c:	f800283a 	ret

09098b90 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 9098b90:	defff804 	addi	sp,sp,-32
 9098b94:	df000715 	stw	fp,28(sp)
 9098b98:	df000704 	addi	fp,sp,28
 9098b9c:	e13ffb15 	stw	r4,-20(fp)
 9098ba0:	e17ffc15 	stw	r5,-16(fp)
 9098ba4:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 9098ba8:	00bff9c4 	movi	r2,-25
 9098bac:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 9098bb0:	e0bffc17 	ldw	r2,-16(fp)
 9098bb4:	e0bfff15 	stw	r2,-4(fp)
 9098bb8:	e0ffff17 	ldw	r3,-4(fp)
 9098bbc:	189a8060 	cmpeqi	r2,r3,27137
 9098bc0:	1000041e 	bne	r2,zero,9098bd4 <altera_avalon_jtag_uart_ioctl+0x44>
 9098bc4:	e0ffff17 	ldw	r3,-4(fp)
 9098bc8:	189a80a0 	cmpeqi	r2,r3,27138
 9098bcc:	10001b1e 	bne	r2,zero,9098c3c <altera_avalon_jtag_uart_ioctl+0xac>
 9098bd0:	00002706 	br	9098c70 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 9098bd4:	e0bffb17 	ldw	r2,-20(fp)
 9098bd8:	10c00117 	ldw	r3,4(r2)
 9098bdc:	00a00034 	movhi	r2,32768
 9098be0:	10bfffc4 	addi	r2,r2,-1
 9098be4:	18802226 	beq	r3,r2,9098c70 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 9098be8:	e0bffd17 	ldw	r2,-12(fp)
 9098bec:	10800017 	ldw	r2,0(r2)
 9098bf0:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 9098bf4:	e0bff917 	ldw	r2,-28(fp)
 9098bf8:	10800090 	cmplti	r2,r2,2
 9098bfc:	1000071e 	bne	r2,zero,9098c1c <altera_avalon_jtag_uart_ioctl+0x8c>
 9098c00:	e0fff917 	ldw	r3,-28(fp)
 9098c04:	00a00034 	movhi	r2,32768
 9098c08:	10bfffc4 	addi	r2,r2,-1
 9098c0c:	18800326 	beq	r3,r2,9098c1c <altera_avalon_jtag_uart_ioctl+0x8c>
 9098c10:	e0bff917 	ldw	r2,-28(fp)
 9098c14:	e0bffe15 	stw	r2,-8(fp)
 9098c18:	00000306 	br	9098c28 <altera_avalon_jtag_uart_ioctl+0x98>
 9098c1c:	00e00034 	movhi	r3,32768
 9098c20:	18ffff84 	addi	r3,r3,-2
 9098c24:	e0fffe15 	stw	r3,-8(fp)
 9098c28:	e0bffb17 	ldw	r2,-20(fp)
 9098c2c:	e0fffe17 	ldw	r3,-8(fp)
 9098c30:	10c00115 	stw	r3,4(r2)
      rc = 0;
 9098c34:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 9098c38:	00000d06 	br	9098c70 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 9098c3c:	e0bffb17 	ldw	r2,-20(fp)
 9098c40:	10c00117 	ldw	r3,4(r2)
 9098c44:	00a00034 	movhi	r2,32768
 9098c48:	10bfffc4 	addi	r2,r2,-1
 9098c4c:	18800826 	beq	r3,r2,9098c70 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 9098c50:	e13ffd17 	ldw	r4,-12(fp)
 9098c54:	e0bffb17 	ldw	r2,-20(fp)
 9098c58:	10c00917 	ldw	r3,36(r2)
 9098c5c:	e0bffb17 	ldw	r2,-20(fp)
 9098c60:	10800117 	ldw	r2,4(r2)
 9098c64:	1885803a 	cmpltu	r2,r3,r2
 9098c68:	20800015 	stw	r2,0(r4)
      rc = 0;
 9098c6c:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 9098c70:	e0bffa17 	ldw	r2,-24(fp)
}
 9098c74:	e037883a 	mov	sp,fp
 9098c78:	df000017 	ldw	fp,0(sp)
 9098c7c:	dec00104 	addi	sp,sp,4
 9098c80:	f800283a 	ret

09098c84 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 9098c84:	deffeb04 	addi	sp,sp,-84
 9098c88:	dfc01415 	stw	ra,80(sp)
 9098c8c:	df001315 	stw	fp,76(sp)
 9098c90:	df001304 	addi	fp,sp,76
 9098c94:	e13ffb15 	stw	r4,-20(fp)
 9098c98:	e17ffc15 	stw	r5,-16(fp)
 9098c9c:	e1bffd15 	stw	r6,-12(fp)
 9098ca0:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 9098ca4:	e0bffc17 	ldw	r2,-16(fp)
 9098ca8:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 9098cac:	e0bffb17 	ldw	r2,-20(fp)
 9098cb0:	10800a17 	ldw	r2,40(r2)
 9098cb4:	e0bff315 	stw	r2,-52(fp)
 9098cb8:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 9098cbc:	e17ff40b 	ldhu	r5,-48(fp)
 9098cc0:	e1bffa44 	addi	r6,fp,-23
 9098cc4:	e13ff317 	ldw	r4,-52(fp)
 9098cc8:	9093c5c0 	call	9093c5c <OSSemPend>

  while (space > 0)
 9098ccc:	00006406 	br	9098e60 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 9098cd0:	e0bffb17 	ldw	r2,-20(fp)
 9098cd4:	10800d17 	ldw	r2,52(r2)
 9098cd8:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 9098cdc:	e0bffb17 	ldw	r2,-20(fp)
 9098ce0:	10800e17 	ldw	r2,56(r2)
 9098ce4:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 9098ce8:	e0fff617 	ldw	r3,-40(fp)
 9098cec:	e0bff517 	ldw	r2,-44(fp)
 9098cf0:	18800536 	bltu	r3,r2,9098d08 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 9098cf4:	e0bff617 	ldw	r2,-40(fp)
 9098cf8:	e0fff517 	ldw	r3,-44(fp)
 9098cfc:	10c5c83a 	sub	r2,r2,r3
 9098d00:	e0bff715 	stw	r2,-36(fp)
 9098d04:	00000406 	br	9098d18 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 9098d08:	00820004 	movi	r2,2048
 9098d0c:	e0fff517 	ldw	r3,-44(fp)
 9098d10:	10c5c83a 	sub	r2,r2,r3
 9098d14:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 9098d18:	e0bff717 	ldw	r2,-36(fp)
 9098d1c:	1005003a 	cmpeq	r2,r2,zero
 9098d20:	10001f1e 	bne	r2,zero,9098da0 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 9098d24:	e0fffd17 	ldw	r3,-12(fp)
 9098d28:	e0bff717 	ldw	r2,-36(fp)
 9098d2c:	1880022e 	bgeu	r3,r2,9098d38 <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 9098d30:	e0bffd17 	ldw	r2,-12(fp)
 9098d34:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 9098d38:	e0bffb17 	ldw	r2,-20(fp)
 9098d3c:	10c01104 	addi	r3,r2,68
 9098d40:	e0bff517 	ldw	r2,-44(fp)
 9098d44:	1887883a 	add	r3,r3,r2
 9098d48:	e0bff917 	ldw	r2,-28(fp)
 9098d4c:	1009883a 	mov	r4,r2
 9098d50:	180b883a 	mov	r5,r3
 9098d54:	e1bff717 	ldw	r6,-36(fp)
 9098d58:	90894600 	call	9089460 <memcpy>
      ptr   += n;
 9098d5c:	e0fff717 	ldw	r3,-36(fp)
 9098d60:	e0bff917 	ldw	r2,-28(fp)
 9098d64:	10c5883a 	add	r2,r2,r3
 9098d68:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 9098d6c:	e0fffd17 	ldw	r3,-12(fp)
 9098d70:	e0bff717 	ldw	r2,-36(fp)
 9098d74:	1885c83a 	sub	r2,r3,r2
 9098d78:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9098d7c:	e0fff517 	ldw	r3,-44(fp)
 9098d80:	e0bff717 	ldw	r2,-36(fp)
 9098d84:	1885883a 	add	r2,r3,r2
 9098d88:	10c1ffcc 	andi	r3,r2,2047
 9098d8c:	e0bffb17 	ldw	r2,-20(fp)
 9098d90:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 9098d94:	e0bffd17 	ldw	r2,-12(fp)
 9098d98:	10800048 	cmpgei	r2,r2,1
 9098d9c:	103fcc1e 	bne	r2,zero,9098cd0 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 9098da0:	e0fff917 	ldw	r3,-28(fp)
 9098da4:	e0bffc17 	ldw	r2,-16(fp)
 9098da8:	1880301e 	bne	r3,r2,9098e6c <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 9098dac:	e0bffe17 	ldw	r2,-8(fp)
 9098db0:	1090000c 	andi	r2,r2,16384
 9098db4:	1004c03a 	cmpne	r2,r2,zero
 9098db8:	10002c1e 	bne	r2,zero,9098e6c <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 9098dbc:	00824374 	movhi	r2,2317
 9098dc0:	108ef144 	addi	r2,r2,15301
 9098dc4:	10800003 	ldbu	r2,0(r2)
 9098dc8:	10803fcc 	andi	r2,r2,255
 9098dcc:	10800058 	cmpnei	r2,r2,1
 9098dd0:	1000161e 	bne	r2,zero,9098e2c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 9098dd4:	e0bffb17 	ldw	r2,-20(fp)
 9098dd8:	10800c17 	ldw	r2,48(r2)
 9098ddc:	e0bff015 	stw	r2,-64(fp)
 9098de0:	00800144 	movi	r2,5
 9098de4:	e0bff10d 	sth	r2,-60(fp)
 9098de8:	00bfe0c4 	movi	r2,-125
 9098dec:	e0bff185 	stb	r2,-58(fp)
 9098df0:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 9098df4:	00824374 	movhi	r2,2317
 9098df8:	108ef144 	addi	r2,r2,15301
 9098dfc:	10800003 	ldbu	r2,0(r2)
 9098e00:	10803fcc 	andi	r2,r2,255
 9098e04:	1005003a 	cmpeq	r2,r2,zero
 9098e08:	1000111e 	bne	r2,zero,9098e50 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 9098e0c:	e17ff10b 	ldhu	r5,-60(fp)
 9098e10:	e1bff183 	ldbu	r6,-58(fp)
 9098e14:	e1fff20b 	ldhu	r7,-56(fp)
 9098e18:	e0bffa04 	addi	r2,fp,-24
 9098e1c:	d8800015 	stw	r2,0(sp)
 9098e20:	e13ff017 	ldw	r4,-64(fp)
 9098e24:	9090d200 	call	9090d20 <OSFlagPend>
    return err;
 9098e28:	00000906 	br	9098e50 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 9098e2c:	e0bffb17 	ldw	r2,-20(fp)
 9098e30:	10c00d17 	ldw	r3,52(r2)
 9098e34:	e0bff617 	ldw	r2,-40(fp)
 9098e38:	1880051e 	bne	r3,r2,9098e50 <altera_avalon_jtag_uart_read+0x1cc>
 9098e3c:	e0bffb17 	ldw	r2,-20(fp)
 9098e40:	10c00917 	ldw	r3,36(r2)
 9098e44:	e0bffb17 	ldw	r2,-20(fp)
 9098e48:	10800117 	ldw	r2,4(r2)
 9098e4c:	18bff736 	bltu	r3,r2,9098e2c <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 9098e50:	e0bffb17 	ldw	r2,-20(fp)
 9098e54:	10c00d17 	ldw	r3,52(r2)
 9098e58:	e0bff617 	ldw	r2,-40(fp)
 9098e5c:	18800326 	beq	r3,r2,9098e6c <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 9098e60:	e0bffd17 	ldw	r2,-12(fp)
 9098e64:	10800048 	cmpgei	r2,r2,1
 9098e68:	103f991e 	bne	r2,zero,9098cd0 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 9098e6c:	e0bffb17 	ldw	r2,-20(fp)
 9098e70:	11000a17 	ldw	r4,40(r2)
 9098e74:	90940540 	call	9094054 <OSSemPost>

  if (ptr != buffer)
 9098e78:	e0fff917 	ldw	r3,-28(fp)
 9098e7c:	e0bffc17 	ldw	r2,-16(fp)
 9098e80:	18801926 	beq	r3,r2,9098ee8 <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9098e84:	0005303a 	rdctl	r2,status
 9098e88:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9098e8c:	e0ffef17 	ldw	r3,-68(fp)
 9098e90:	00bfff84 	movi	r2,-2
 9098e94:	1884703a 	and	r2,r3,r2
 9098e98:	1001703a 	wrctl	status,r2
  
  return context;
 9098e9c:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 9098ea0:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 9098ea4:	e0bffb17 	ldw	r2,-20(fp)
 9098ea8:	10800817 	ldw	r2,32(r2)
 9098eac:	10c00054 	ori	r3,r2,1
 9098eb0:	e0bffb17 	ldw	r2,-20(fp)
 9098eb4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 9098eb8:	e0bffb17 	ldw	r2,-20(fp)
 9098ebc:	10800017 	ldw	r2,0(r2)
 9098ec0:	11000104 	addi	r4,r2,4
 9098ec4:	e0bffb17 	ldw	r2,-20(fp)
 9098ec8:	10800817 	ldw	r2,32(r2)
 9098ecc:	1007883a 	mov	r3,r2
 9098ed0:	2005883a 	mov	r2,r4
 9098ed4:	10c00035 	stwio	r3,0(r2)
 9098ed8:	e0bff817 	ldw	r2,-32(fp)
 9098edc:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 9098ee0:	e0bfee17 	ldw	r2,-72(fp)
 9098ee4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 9098ee8:	e0fff917 	ldw	r3,-28(fp)
 9098eec:	e0bffc17 	ldw	r2,-16(fp)
 9098ef0:	18800526 	beq	r3,r2,9098f08 <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 9098ef4:	e0fff917 	ldw	r3,-28(fp)
 9098ef8:	e0bffc17 	ldw	r2,-16(fp)
 9098efc:	1887c83a 	sub	r3,r3,r2
 9098f00:	e0ffff15 	stw	r3,-4(fp)
 9098f04:	00000906 	br	9098f2c <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 9098f08:	e0bffe17 	ldw	r2,-8(fp)
 9098f0c:	1090000c 	andi	r2,r2,16384
 9098f10:	1005003a 	cmpeq	r2,r2,zero
 9098f14:	1000031e 	bne	r2,zero,9098f24 <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 9098f18:	00bffd44 	movi	r2,-11
 9098f1c:	e0bfff15 	stw	r2,-4(fp)
 9098f20:	00000206 	br	9098f2c <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 9098f24:	00bffec4 	movi	r2,-5
 9098f28:	e0bfff15 	stw	r2,-4(fp)
 9098f2c:	e0bfff17 	ldw	r2,-4(fp)
}
 9098f30:	e037883a 	mov	sp,fp
 9098f34:	dfc00117 	ldw	ra,4(sp)
 9098f38:	df000017 	ldw	fp,0(sp)
 9098f3c:	dec00204 	addi	sp,sp,8
 9098f40:	f800283a 	ret

09098f44 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 9098f44:	deffeb04 	addi	sp,sp,-84
 9098f48:	dfc01415 	stw	ra,80(sp)
 9098f4c:	df001315 	stw	fp,76(sp)
 9098f50:	df001304 	addi	fp,sp,76
 9098f54:	e13ffb15 	stw	r4,-20(fp)
 9098f58:	e17ffc15 	stw	r5,-16(fp)
 9098f5c:	e1bffd15 	stw	r6,-12(fp)
 9098f60:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 9098f64:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 9098f68:	e0bffc17 	ldw	r2,-16(fp)
 9098f6c:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 9098f70:	e0bffb17 	ldw	r2,-20(fp)
 9098f74:	10800b17 	ldw	r2,44(r2)
 9098f78:	e0bff315 	stw	r2,-52(fp)
 9098f7c:	e03ff40d 	sth	zero,-48(fp)
 9098f80:	e17ff40b 	ldhu	r5,-48(fp)
 9098f84:	e1bffa04 	addi	r6,fp,-24
 9098f88:	e13ff317 	ldw	r4,-52(fp)
 9098f8c:	9093c5c0 	call	9093c5c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 9098f90:	00003a06 	br	909907c <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 9098f94:	e0bffb17 	ldw	r2,-20(fp)
 9098f98:	10800f17 	ldw	r2,60(r2)
 9098f9c:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 9098fa0:	e0bffb17 	ldw	r2,-20(fp)
 9098fa4:	10801017 	ldw	r2,64(r2)
 9098fa8:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 9098fac:	e0fff917 	ldw	r3,-28(fp)
 9098fb0:	e0bff817 	ldw	r2,-32(fp)
 9098fb4:	1880062e 	bgeu	r3,r2,9098fd0 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 9098fb8:	e0fff817 	ldw	r3,-32(fp)
 9098fbc:	e0bff917 	ldw	r2,-28(fp)
 9098fc0:	1885c83a 	sub	r2,r3,r2
 9098fc4:	10bfffc4 	addi	r2,r2,-1
 9098fc8:	e0bff715 	stw	r2,-36(fp)
 9098fcc:	00000c06 	br	9099000 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 9098fd0:	e0bff817 	ldw	r2,-32(fp)
 9098fd4:	1005003a 	cmpeq	r2,r2,zero
 9098fd8:	1000051e 	bne	r2,zero,9098ff0 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 9098fdc:	00820004 	movi	r2,2048
 9098fe0:	e0fff917 	ldw	r3,-28(fp)
 9098fe4:	10c5c83a 	sub	r2,r2,r3
 9098fe8:	e0bff715 	stw	r2,-36(fp)
 9098fec:	00000406 	br	9099000 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 9098ff0:	0081ffc4 	movi	r2,2047
 9098ff4:	e0fff917 	ldw	r3,-28(fp)
 9098ff8:	10c5c83a 	sub	r2,r2,r3
 9098ffc:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 9099000:	e0bff717 	ldw	r2,-36(fp)
 9099004:	1005003a 	cmpeq	r2,r2,zero
 9099008:	10001f1e 	bne	r2,zero,9099088 <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 909900c:	e0fffd17 	ldw	r3,-12(fp)
 9099010:	e0bff717 	ldw	r2,-36(fp)
 9099014:	1880022e 	bgeu	r3,r2,9099020 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 9099018:	e0bffd17 	ldw	r2,-12(fp)
 909901c:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 9099020:	e0bffb17 	ldw	r2,-20(fp)
 9099024:	10c21104 	addi	r3,r2,2116
 9099028:	e0bff917 	ldw	r2,-28(fp)
 909902c:	1885883a 	add	r2,r3,r2
 9099030:	e0fffc17 	ldw	r3,-16(fp)
 9099034:	1009883a 	mov	r4,r2
 9099038:	180b883a 	mov	r5,r3
 909903c:	e1bff717 	ldw	r6,-36(fp)
 9099040:	90894600 	call	9089460 <memcpy>
      ptr   += n;
 9099044:	e0fff717 	ldw	r3,-36(fp)
 9099048:	e0bffc17 	ldw	r2,-16(fp)
 909904c:	10c5883a 	add	r2,r2,r3
 9099050:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 9099054:	e0fffd17 	ldw	r3,-12(fp)
 9099058:	e0bff717 	ldw	r2,-36(fp)
 909905c:	1885c83a 	sub	r2,r3,r2
 9099060:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 9099064:	e0fff917 	ldw	r3,-28(fp)
 9099068:	e0bff717 	ldw	r2,-36(fp)
 909906c:	1885883a 	add	r2,r3,r2
 9099070:	10c1ffcc 	andi	r3,r2,2047
 9099074:	e0bffb17 	ldw	r2,-20(fp)
 9099078:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 909907c:	e0bffd17 	ldw	r2,-12(fp)
 9099080:	10800048 	cmpgei	r2,r2,1
 9099084:	103fc31e 	bne	r2,zero,9098f94 <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 9099088:	0005303a 	rdctl	r2,status
 909908c:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 9099090:	e0fff217 	ldw	r3,-56(fp)
 9099094:	00bfff84 	movi	r2,-2
 9099098:	1884703a 	and	r2,r3,r2
 909909c:	1001703a 	wrctl	status,r2
  
  return context;
 90990a0:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 90990a4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 90990a8:	e0bffb17 	ldw	r2,-20(fp)
 90990ac:	10800817 	ldw	r2,32(r2)
 90990b0:	10c00094 	ori	r3,r2,2
 90990b4:	e0bffb17 	ldw	r2,-20(fp)
 90990b8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 90990bc:	e0bffb17 	ldw	r2,-20(fp)
 90990c0:	10800017 	ldw	r2,0(r2)
 90990c4:	11000104 	addi	r4,r2,4
 90990c8:	e0bffb17 	ldw	r2,-20(fp)
 90990cc:	10800817 	ldw	r2,32(r2)
 90990d0:	1007883a 	mov	r3,r2
 90990d4:	2005883a 	mov	r2,r4
 90990d8:	10c00035 	stwio	r3,0(r2)
 90990dc:	e0bff617 	ldw	r2,-40(fp)
 90990e0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90990e4:	e0bff117 	ldw	r2,-60(fp)
 90990e8:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 90990ec:	e0bffd17 	ldw	r2,-12(fp)
 90990f0:	10800050 	cmplti	r2,r2,1
 90990f4:	10002d1e 	bne	r2,zero,90991ac <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 90990f8:	e0bffe17 	ldw	r2,-8(fp)
 90990fc:	1090000c 	andi	r2,r2,16384
 9099100:	1004c03a 	cmpne	r2,r2,zero
 9099104:	10002c1e 	bne	r2,zero,90991b8 <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 9099108:	00824374 	movhi	r2,2317
 909910c:	108ef144 	addi	r2,r2,15301
 9099110:	10800003 	ldbu	r2,0(r2)
 9099114:	10803fcc 	andi	r2,r2,255
 9099118:	10800058 	cmpnei	r2,r2,1
 909911c:	1000161e 	bne	r2,zero,9099178 <altera_avalon_jtag_uart_write+0x234>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 9099120:	e0bffb17 	ldw	r2,-20(fp)
 9099124:	10800c17 	ldw	r2,48(r2)
 9099128:	e0bfee15 	stw	r2,-72(fp)
 909912c:	00800184 	movi	r2,6
 9099130:	e0bfef0d 	sth	r2,-68(fp)
 9099134:	00bfe0c4 	movi	r2,-125
 9099138:	e0bfef85 	stb	r2,-66(fp)
 909913c:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 9099140:	00824374 	movhi	r2,2317
 9099144:	108ef144 	addi	r2,r2,15301
 9099148:	10800003 	ldbu	r2,0(r2)
 909914c:	10803fcc 	andi	r2,r2,255
 9099150:	1005003a 	cmpeq	r2,r2,zero
 9099154:	1000111e 	bne	r2,zero,909919c <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 9099158:	e17fef0b 	ldhu	r5,-68(fp)
 909915c:	e1bfef83 	ldbu	r6,-66(fp)
 9099160:	e1fff00b 	ldhu	r7,-64(fp)
 9099164:	e0bffa44 	addi	r2,fp,-23
 9099168:	d8800015 	stw	r2,0(sp)
 909916c:	e13fee17 	ldw	r4,-72(fp)
 9099170:	9090d200 	call	9090d20 <OSFlagPend>
    return err;
 9099174:	00000906 	br	909919c <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 9099178:	e0bffb17 	ldw	r2,-20(fp)
 909917c:	10c01017 	ldw	r3,64(r2)
 9099180:	e0bff817 	ldw	r2,-32(fp)
 9099184:	1880051e 	bne	r3,r2,909919c <altera_avalon_jtag_uart_write+0x258>
 9099188:	e0bffb17 	ldw	r2,-20(fp)
 909918c:	10c00917 	ldw	r3,36(r2)
 9099190:	e0bffb17 	ldw	r2,-20(fp)
 9099194:	10800117 	ldw	r2,4(r2)
 9099198:	18bff736 	bltu	r3,r2,9099178 <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 909919c:	e0bffb17 	ldw	r2,-20(fp)
 90991a0:	10c01017 	ldw	r3,64(r2)
 90991a4:	e0bff817 	ldw	r2,-32(fp)
 90991a8:	18800326 	beq	r3,r2,90991b8 <altera_avalon_jtag_uart_write+0x274>
         break;
    }
  }
  while (count > 0);
 90991ac:	e0bffd17 	ldw	r2,-12(fp)
 90991b0:	10800048 	cmpgei	r2,r2,1
 90991b4:	103fb11e 	bne	r2,zero,909907c <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 90991b8:	e0bffb17 	ldw	r2,-20(fp)
 90991bc:	11000b17 	ldw	r4,44(r2)
 90991c0:	90940540 	call	9094054 <OSSemPost>

  if (ptr != start)
 90991c4:	e0fffc17 	ldw	r3,-16(fp)
 90991c8:	e0bff517 	ldw	r2,-44(fp)
 90991cc:	18800526 	beq	r3,r2,90991e4 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 90991d0:	e0fffc17 	ldw	r3,-16(fp)
 90991d4:	e0bff517 	ldw	r2,-44(fp)
 90991d8:	1887c83a 	sub	r3,r3,r2
 90991dc:	e0ffff15 	stw	r3,-4(fp)
 90991e0:	00000906 	br	9099208 <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 90991e4:	e0bffe17 	ldw	r2,-8(fp)
 90991e8:	1090000c 	andi	r2,r2,16384
 90991ec:	1005003a 	cmpeq	r2,r2,zero
 90991f0:	1000031e 	bne	r2,zero,9099200 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 90991f4:	00bffd44 	movi	r2,-11
 90991f8:	e0bfff15 	stw	r2,-4(fp)
 90991fc:	00000206 	br	9099208 <altera_avalon_jtag_uart_write+0x2c4>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 9099200:	00bffec4 	movi	r2,-5
 9099204:	e0bfff15 	stw	r2,-4(fp)
 9099208:	e0bfff17 	ldw	r2,-4(fp)
}
 909920c:	e037883a 	mov	sp,fp
 9099210:	dfc00117 	ldw	ra,4(sp)
 9099214:	df000017 	ldw	fp,0(sp)
 9099218:	dec00204 	addi	sp,sp,8
 909921c:	f800283a 	ret

09099220 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 9099220:	defffa04 	addi	sp,sp,-24
 9099224:	dfc00515 	stw	ra,20(sp)
 9099228:	df000415 	stw	fp,16(sp)
 909922c:	df000404 	addi	fp,sp,16
 9099230:	e13ffe15 	stw	r4,-8(fp)
 9099234:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 9099238:	e0bffe17 	ldw	r2,-8(fp)
 909923c:	10800017 	ldw	r2,0(r2)
 9099240:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 9099244:	008003f4 	movhi	r2,15
 9099248:	10909004 	addi	r2,r2,16960
 909924c:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9099250:	e0bffe17 	ldw	r2,-8(fp)
 9099254:	10800803 	ldbu	r2,32(r2)
 9099258:	10803fcc 	andi	r2,r2,255
 909925c:	1080201c 	xori	r2,r2,128
 9099260:	10bfe004 	addi	r2,r2,-128
 9099264:	1004c03a 	cmpne	r2,r2,zero
 9099268:	1000161e 	bne	r2,zero,90992c4 <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 909926c:	00000a06 	br	9099298 <lcd_write_command+0x78>
    if (--i == 0)
 9099270:	e0bffc17 	ldw	r2,-16(fp)
 9099274:	10bfffc4 	addi	r2,r2,-1
 9099278:	e0bffc15 	stw	r2,-16(fp)
 909927c:	e0bffc17 	ldw	r2,-16(fp)
 9099280:	1004c03a 	cmpne	r2,r2,zero
 9099284:	1000041e 	bne	r2,zero,9099298 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 9099288:	e0fffe17 	ldw	r3,-8(fp)
 909928c:	00800044 	movi	r2,1
 9099290:	18800805 	stb	r2,32(r3)
      return;
 9099294:	00000b06 	br	90992c4 <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9099298:	e0bffd17 	ldw	r2,-12(fp)
 909929c:	10800104 	addi	r2,r2,4
 90992a0:	10800037 	ldwio	r2,0(r2)
 90992a4:	1080200c 	andi	r2,r2,128
 90992a8:	1004c03a 	cmpne	r2,r2,zero
 90992ac:	103ff01e 	bne	r2,zero,9099270 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 90992b0:	01001904 	movi	r4,100
 90992b4:	90baa880 	call	90baa88 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 90992b8:	e0bffd17 	ldw	r2,-12(fp)
 90992bc:	e0ffff03 	ldbu	r3,-4(fp)
 90992c0:	10c00035 	stwio	r3,0(r2)
}
 90992c4:	e037883a 	mov	sp,fp
 90992c8:	dfc00117 	ldw	ra,4(sp)
 90992cc:	df000017 	ldw	fp,0(sp)
 90992d0:	dec00204 	addi	sp,sp,8
 90992d4:	f800283a 	ret

090992d8 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 90992d8:	defffa04 	addi	sp,sp,-24
 90992dc:	dfc00515 	stw	ra,20(sp)
 90992e0:	df000415 	stw	fp,16(sp)
 90992e4:	df000404 	addi	fp,sp,16
 90992e8:	e13ffe15 	stw	r4,-8(fp)
 90992ec:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 90992f0:	e0bffe17 	ldw	r2,-8(fp)
 90992f4:	10800017 	ldw	r2,0(r2)
 90992f8:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 90992fc:	008003f4 	movhi	r2,15
 9099300:	10909004 	addi	r2,r2,16960
 9099304:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 9099308:	e0bffe17 	ldw	r2,-8(fp)
 909930c:	10800803 	ldbu	r2,32(r2)
 9099310:	10803fcc 	andi	r2,r2,255
 9099314:	1080201c 	xori	r2,r2,128
 9099318:	10bfe004 	addi	r2,r2,-128
 909931c:	1004c03a 	cmpne	r2,r2,zero
 9099320:	10001d1e 	bne	r2,zero,9099398 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9099324:	00000a06 	br	9099350 <lcd_write_data+0x78>
    if (--i == 0)
 9099328:	e0bffc17 	ldw	r2,-16(fp)
 909932c:	10bfffc4 	addi	r2,r2,-1
 9099330:	e0bffc15 	stw	r2,-16(fp)
 9099334:	e0bffc17 	ldw	r2,-16(fp)
 9099338:	1004c03a 	cmpne	r2,r2,zero
 909933c:	1000041e 	bne	r2,zero,9099350 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 9099340:	e0fffe17 	ldw	r3,-8(fp)
 9099344:	00800044 	movi	r2,1
 9099348:	18800805 	stb	r2,32(r3)
      return;
 909934c:	00001206 	br	9099398 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 9099350:	e0bffd17 	ldw	r2,-12(fp)
 9099354:	10800104 	addi	r2,r2,4
 9099358:	10800037 	ldwio	r2,0(r2)
 909935c:	1080200c 	andi	r2,r2,128
 9099360:	1004c03a 	cmpne	r2,r2,zero
 9099364:	103ff01e 	bne	r2,zero,9099328 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 9099368:	01001904 	movi	r4,100
 909936c:	90baa880 	call	90baa88 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 9099370:	e0bffd17 	ldw	r2,-12(fp)
 9099374:	10800204 	addi	r2,r2,8
 9099378:	e0ffff03 	ldbu	r3,-4(fp)
 909937c:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 9099380:	e0bffe17 	ldw	r2,-8(fp)
 9099384:	108008c3 	ldbu	r2,35(r2)
 9099388:	10800044 	addi	r2,r2,1
 909938c:	1007883a 	mov	r3,r2
 9099390:	e0bffe17 	ldw	r2,-8(fp)
 9099394:	10c008c5 	stb	r3,35(r2)
}
 9099398:	e037883a 	mov	sp,fp
 909939c:	dfc00117 	ldw	ra,4(sp)
 90993a0:	df000017 	ldw	fp,0(sp)
 90993a4:	dec00204 	addi	sp,sp,8
 90993a8:	f800283a 	ret

090993ac <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 90993ac:	defffc04 	addi	sp,sp,-16
 90993b0:	dfc00315 	stw	ra,12(sp)
 90993b4:	df000215 	stw	fp,8(sp)
 90993b8:	df000204 	addi	fp,sp,8
 90993bc:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 90993c0:	e13fff17 	ldw	r4,-4(fp)
 90993c4:	01400044 	movi	r5,1
 90993c8:	90992200 	call	9099220 <lcd_write_command>

  sp->x = 0;
 90993cc:	e0bfff17 	ldw	r2,-4(fp)
 90993d0:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 90993d4:	e0bfff17 	ldw	r2,-4(fp)
 90993d8:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 90993dc:	e0bfff17 	ldw	r2,-4(fp)
 90993e0:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90993e4:	e03ffe15 	stw	zero,-8(fp)
 90993e8:	00001906 	br	9099450 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 90993ec:	e0bffe17 	ldw	r2,-8(fp)
 90993f0:	108018e4 	muli	r2,r2,99
 90993f4:	10c01004 	addi	r3,r2,64
 90993f8:	e0bfff17 	ldw	r2,-4(fp)
 90993fc:	1889883a 	add	r4,r3,r2
 9099400:	01400804 	movi	r5,32
 9099404:	01801444 	movi	r6,81
 9099408:	90832780 	call	9083278 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 909940c:	e0bffe17 	ldw	r2,-8(fp)
 9099410:	108018e4 	muli	r2,r2,99
 9099414:	10c00c04 	addi	r3,r2,48
 9099418:	e0bfff17 	ldw	r2,-4(fp)
 909941c:	1889883a 	add	r4,r3,r2
 9099420:	01400804 	movi	r5,32
 9099424:	01800404 	movi	r6,16
 9099428:	90832780 	call	9083278 <memset>
    sp->line[y].width = 0;
 909942c:	e0bffe17 	ldw	r2,-8(fp)
 9099430:	e0ffff17 	ldw	r3,-4(fp)
 9099434:	108018e4 	muli	r2,r2,99
 9099438:	10c5883a 	add	r2,r2,r3
 909943c:	10802404 	addi	r2,r2,144
 9099440:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099444:	e0bffe17 	ldw	r2,-8(fp)
 9099448:	10800044 	addi	r2,r2,1
 909944c:	e0bffe15 	stw	r2,-8(fp)
 9099450:	e0bffe17 	ldw	r2,-8(fp)
 9099454:	10800090 	cmplti	r2,r2,2
 9099458:	103fe41e 	bne	r2,zero,90993ec <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 909945c:	e037883a 	mov	sp,fp
 9099460:	dfc00117 	ldw	ra,4(sp)
 9099464:	df000017 	ldw	fp,0(sp)
 9099468:	dec00204 	addi	sp,sp,8
 909946c:	f800283a 	ret

09099470 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 9099470:	defff704 	addi	sp,sp,-36
 9099474:	dfc00815 	stw	ra,32(sp)
 9099478:	df000715 	stw	fp,28(sp)
 909947c:	df000704 	addi	fp,sp,28
 9099480:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 9099484:	e0bfff17 	ldw	r2,-4(fp)
 9099488:	10800943 	ldbu	r2,37(r2)
 909948c:	10803fcc 	andi	r2,r2,255
 9099490:	1080201c 	xori	r2,r2,128
 9099494:	10bfe004 	addi	r2,r2,-128
 9099498:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 909949c:	e03ffe15 	stw	zero,-8(fp)
 90994a0:	00006606 	br	909963c <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
 90994a4:	e0bffe17 	ldw	r2,-8(fp)
 90994a8:	e0ffff17 	ldw	r3,-4(fp)
 90994ac:	108018e4 	muli	r2,r2,99
 90994b0:	10c5883a 	add	r2,r2,r3
 90994b4:	10802404 	addi	r2,r2,144
 90994b8:	10800043 	ldbu	r2,1(r2)
 90994bc:	10803fcc 	andi	r2,r2,255
 90994c0:	1080201c 	xori	r2,r2,128
 90994c4:	10bfe004 	addi	r2,r2,-128
 90994c8:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 90994cc:	e0bffe17 	ldw	r2,-8(fp)
 90994d0:	e0ffff17 	ldw	r3,-4(fp)
 90994d4:	108018e4 	muli	r2,r2,99
 90994d8:	10c5883a 	add	r2,r2,r3
 90994dc:	10802404 	addi	r2,r2,144
 90994e0:	10800083 	ldbu	r2,2(r2)
 90994e4:	10c03fcc 	andi	r3,r2,255
 90994e8:	e0bffc17 	ldw	r2,-16(fp)
 90994ec:	1885383a 	mul	r2,r3,r2
 90994f0:	1005d23a 	srai	r2,r2,8
 90994f4:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 90994f8:	e0fffa17 	ldw	r3,-24(fp)
 90994fc:	e0bffb17 	ldw	r2,-20(fp)
 9099500:	18800116 	blt	r3,r2,9099508 <lcd_repaint_screen+0x98>
      offset = 0;
 9099504:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9099508:	e03ffd15 	stw	zero,-12(fp)
 909950c:	00004506 	br	9099624 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
 9099510:	e17ffe17 	ldw	r5,-8(fp)
 9099514:	e0fffd17 	ldw	r3,-12(fp)
 9099518:	e0bffa17 	ldw	r2,-24(fp)
 909951c:	1889883a 	add	r4,r3,r2
 9099520:	e0bffb17 	ldw	r2,-20(fp)
 9099524:	2087283a 	div	r3,r4,r2
 9099528:	e0bffb17 	ldw	r2,-20(fp)
 909952c:	1885383a 	mul	r2,r3,r2
 9099530:	2089c83a 	sub	r4,r4,r2
 9099534:	e0ffff17 	ldw	r3,-4(fp)
 9099538:	288018e4 	muli	r2,r5,99
 909953c:	10c5883a 	add	r2,r2,r3
 9099540:	1105883a 	add	r2,r2,r4
 9099544:	10801004 	addi	r2,r2,64
 9099548:	10800003 	ldbu	r2,0(r2)
 909954c:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 9099550:	e0bffe17 	ldw	r2,-8(fp)
 9099554:	e13ffd17 	ldw	r4,-12(fp)
 9099558:	e0ffff17 	ldw	r3,-4(fp)
 909955c:	108018e4 	muli	r2,r2,99
 9099560:	10c5883a 	add	r2,r2,r3
 9099564:	1105883a 	add	r2,r2,r4
 9099568:	10800c04 	addi	r2,r2,48
 909956c:	10800003 	ldbu	r2,0(r2)
 9099570:	10c03fcc 	andi	r3,r2,255
 9099574:	18c0201c 	xori	r3,r3,128
 9099578:	18ffe004 	addi	r3,r3,-128
 909957c:	e0bff947 	ldb	r2,-27(fp)
 9099580:	18802526 	beq	r3,r2,9099618 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
 9099584:	e0fffe17 	ldw	r3,-8(fp)
 9099588:	d0a02804 	addi	r2,gp,-32608
 909958c:	1885883a 	add	r2,r3,r2
 9099590:	10800003 	ldbu	r2,0(r2)
 9099594:	1007883a 	mov	r3,r2
 9099598:	e0bffd17 	ldw	r2,-12(fp)
 909959c:	1885883a 	add	r2,r3,r2
 90995a0:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 90995a4:	e0fff903 	ldbu	r3,-28(fp)
 90995a8:	e0bfff17 	ldw	r2,-4(fp)
 90995ac:	108008c3 	ldbu	r2,35(r2)
 90995b0:	10803fcc 	andi	r2,r2,255
 90995b4:	1080201c 	xori	r2,r2,128
 90995b8:	10bfe004 	addi	r2,r2,-128
 90995bc:	18800926 	beq	r3,r2,90995e4 <lcd_repaint_screen+0x174>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 90995c0:	e0fff903 	ldbu	r3,-28(fp)
 90995c4:	00bfe004 	movi	r2,-128
 90995c8:	1884b03a 	or	r2,r3,r2
 90995cc:	11403fcc 	andi	r5,r2,255
 90995d0:	e13fff17 	ldw	r4,-4(fp)
 90995d4:	90992200 	call	9099220 <lcd_write_command>
          sp->address = address;
 90995d8:	e0fff903 	ldbu	r3,-28(fp)
 90995dc:	e0bfff17 	ldw	r2,-4(fp)
 90995e0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 90995e4:	e0bff943 	ldbu	r2,-27(fp)
 90995e8:	11403fcc 	andi	r5,r2,255
 90995ec:	e13fff17 	ldw	r4,-4(fp)
 90995f0:	90992d80 	call	90992d8 <lcd_write_data>
        sp->line[y].visible[x] = c;
 90995f4:	e0bffe17 	ldw	r2,-8(fp)
 90995f8:	e13ffd17 	ldw	r4,-12(fp)
 90995fc:	e0ffff17 	ldw	r3,-4(fp)
 9099600:	108018e4 	muli	r2,r2,99
 9099604:	10c5883a 	add	r2,r2,r3
 9099608:	1105883a 	add	r2,r2,r4
 909960c:	10c00c04 	addi	r3,r2,48
 9099610:	e0bff943 	ldbu	r2,-27(fp)
 9099614:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 9099618:	e0bffd17 	ldw	r2,-12(fp)
 909961c:	10800044 	addi	r2,r2,1
 9099620:	e0bffd15 	stw	r2,-12(fp)
 9099624:	e0bffd17 	ldw	r2,-12(fp)
 9099628:	10800410 	cmplti	r2,r2,16
 909962c:	103fb81e 	bne	r2,zero,9099510 <lcd_repaint_screen+0xa0>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099630:	e0bffe17 	ldw	r2,-8(fp)
 9099634:	10800044 	addi	r2,r2,1
 9099638:	e0bffe15 	stw	r2,-8(fp)
 909963c:	e0bffe17 	ldw	r2,-8(fp)
 9099640:	10800090 	cmplti	r2,r2,2
 9099644:	103f971e 	bne	r2,zero,90994a4 <lcd_repaint_screen+0x34>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 9099648:	e037883a 	mov	sp,fp
 909964c:	dfc00117 	ldw	ra,4(sp)
 9099650:	df000017 	ldw	fp,0(sp)
 9099654:	dec00204 	addi	sp,sp,8
 9099658:	f800283a 	ret

0909965c <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 909965c:	defffc04 	addi	sp,sp,-16
 9099660:	dfc00315 	stw	ra,12(sp)
 9099664:	df000215 	stw	fp,8(sp)
 9099668:	df000204 	addi	fp,sp,8
 909966c:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099670:	e03ffe15 	stw	zero,-8(fp)
 9099674:	00001d06 	br	90996ec <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 9099678:	e0bffe17 	ldw	r2,-8(fp)
 909967c:	10800048 	cmpgei	r2,r2,1
 9099680:	10000f1e 	bne	r2,zero,90996c0 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 9099684:	e0bffe17 	ldw	r2,-8(fp)
 9099688:	108018e4 	muli	r2,r2,99
 909968c:	10c01004 	addi	r3,r2,64
 9099690:	e0bfff17 	ldw	r2,-4(fp)
 9099694:	1889883a 	add	r4,r3,r2
 9099698:	e0bffe17 	ldw	r2,-8(fp)
 909969c:	10800044 	addi	r2,r2,1
 90996a0:	108018e4 	muli	r2,r2,99
 90996a4:	10c01004 	addi	r3,r2,64
 90996a8:	e0bfff17 	ldw	r2,-4(fp)
 90996ac:	1885883a 	add	r2,r3,r2
 90996b0:	100b883a 	mov	r5,r2
 90996b4:	01801404 	movi	r6,80
 90996b8:	90894600 	call	9089460 <memcpy>
 90996bc:	00000806 	br	90996e0 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 90996c0:	e0bffe17 	ldw	r2,-8(fp)
 90996c4:	108018e4 	muli	r2,r2,99
 90996c8:	10c01004 	addi	r3,r2,64
 90996cc:	e0bfff17 	ldw	r2,-4(fp)
 90996d0:	1889883a 	add	r4,r3,r2
 90996d4:	01400804 	movi	r5,32
 90996d8:	01801404 	movi	r6,80
 90996dc:	90832780 	call	9083278 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 90996e0:	e0bffe17 	ldw	r2,-8(fp)
 90996e4:	10800044 	addi	r2,r2,1
 90996e8:	e0bffe15 	stw	r2,-8(fp)
 90996ec:	e0bffe17 	ldw	r2,-8(fp)
 90996f0:	10800090 	cmplti	r2,r2,2
 90996f4:	103fe01e 	bne	r2,zero,9099678 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 90996f8:	e0bfff17 	ldw	r2,-4(fp)
 90996fc:	10800883 	ldbu	r2,34(r2)
 9099700:	10bfffc4 	addi	r2,r2,-1
 9099704:	1007883a 	mov	r3,r2
 9099708:	e0bfff17 	ldw	r2,-4(fp)
 909970c:	10c00885 	stb	r3,34(r2)
}
 9099710:	e037883a 	mov	sp,fp
 9099714:	dfc00117 	ldw	ra,4(sp)
 9099718:	df000017 	ldw	fp,0(sp)
 909971c:	dec00204 	addi	sp,sp,8
 9099720:	f800283a 	ret

09099724 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 9099724:	defff804 	addi	sp,sp,-32
 9099728:	dfc00715 	stw	ra,28(sp)
 909972c:	df000615 	stw	fp,24(sp)
 9099730:	df000604 	addi	fp,sp,24
 9099734:	e13ffd15 	stw	r4,-12(fp)
 9099738:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 909973c:	e03ffc15 	stw	zero,-16(fp)
 9099740:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 9099744:	e0bffd17 	ldw	r2,-12(fp)
 9099748:	10800a03 	ldbu	r2,40(r2)
 909974c:	10803fcc 	andi	r2,r2,255
 9099750:	1080201c 	xori	r2,r2,128
 9099754:	10bfe004 	addi	r2,r2,-128
 9099758:	108016d8 	cmpnei	r2,r2,91
 909975c:	1000491e 	bne	r2,zero,9099884 <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 9099760:	e0bffd17 	ldw	r2,-12(fp)
 9099764:	10800a04 	addi	r2,r2,40
 9099768:	10800044 	addi	r2,r2,1
 909976c:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 9099770:	00000d06 	br	90997a8 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 9099774:	e0bffc17 	ldw	r2,-16(fp)
 9099778:	10c002a4 	muli	r3,r2,10
 909977c:	e0bffa17 	ldw	r2,-24(fp)
 9099780:	10800003 	ldbu	r2,0(r2)
 9099784:	10803fcc 	andi	r2,r2,255
 9099788:	1080201c 	xori	r2,r2,128
 909978c:	10bfe004 	addi	r2,r2,-128
 9099790:	1885883a 	add	r2,r3,r2
 9099794:	10bff404 	addi	r2,r2,-48
 9099798:	e0bffc15 	stw	r2,-16(fp)
 909979c:	e0bffa17 	ldw	r2,-24(fp)
 90997a0:	10800044 	addi	r2,r2,1
 90997a4:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 90997a8:	e0bffa17 	ldw	r2,-24(fp)
 90997ac:	10800003 	ldbu	r2,0(r2)
 90997b0:	10803fcc 	andi	r2,r2,255
 90997b4:	1080201c 	xori	r2,r2,128
 90997b8:	10bfe004 	addi	r2,r2,-128
 90997bc:	1007883a 	mov	r3,r2
 90997c0:	00824374 	movhi	r2,2317
 90997c4:	108e8504 	addi	r2,r2,14868
 90997c8:	10800017 	ldw	r2,0(r2)
 90997cc:	1885883a 	add	r2,r3,r2
 90997d0:	10800003 	ldbu	r2,0(r2)
 90997d4:	10803fcc 	andi	r2,r2,255
 90997d8:	1080010c 	andi	r2,r2,4
 90997dc:	1004c03a 	cmpne	r2,r2,zero
 90997e0:	103fe41e 	bne	r2,zero,9099774 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 90997e4:	e0bffa17 	ldw	r2,-24(fp)
 90997e8:	10800003 	ldbu	r2,0(r2)
 90997ec:	10803fcc 	andi	r2,r2,255
 90997f0:	1080201c 	xori	r2,r2,128
 90997f4:	10bfe004 	addi	r2,r2,-128
 90997f8:	10800ed8 	cmpnei	r2,r2,59
 90997fc:	1000231e 	bne	r2,zero,909988c <lcd_handle_escape+0x168>
    {
      ptr++;
 9099800:	e0bffa17 	ldw	r2,-24(fp)
 9099804:	10800044 	addi	r2,r2,1
 9099808:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 909980c:	00000d06 	br	9099844 <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 9099810:	e0bffb17 	ldw	r2,-20(fp)
 9099814:	10c002a4 	muli	r3,r2,10
 9099818:	e0bffa17 	ldw	r2,-24(fp)
 909981c:	10800003 	ldbu	r2,0(r2)
 9099820:	10803fcc 	andi	r2,r2,255
 9099824:	1080201c 	xori	r2,r2,128
 9099828:	10bfe004 	addi	r2,r2,-128
 909982c:	1885883a 	add	r2,r3,r2
 9099830:	10bff404 	addi	r2,r2,-48
 9099834:	e0bffb15 	stw	r2,-20(fp)
 9099838:	e0bffa17 	ldw	r2,-24(fp)
 909983c:	10800044 	addi	r2,r2,1
 9099840:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 9099844:	e0bffa17 	ldw	r2,-24(fp)
 9099848:	10800003 	ldbu	r2,0(r2)
 909984c:	10803fcc 	andi	r2,r2,255
 9099850:	1080201c 	xori	r2,r2,128
 9099854:	10bfe004 	addi	r2,r2,-128
 9099858:	1007883a 	mov	r3,r2
 909985c:	00824374 	movhi	r2,2317
 9099860:	108e8504 	addi	r2,r2,14868
 9099864:	10800017 	ldw	r2,0(r2)
 9099868:	1885883a 	add	r2,r3,r2
 909986c:	10800003 	ldbu	r2,0(r2)
 9099870:	10803fcc 	andi	r2,r2,255
 9099874:	1080010c 	andi	r2,r2,4
 9099878:	1004c03a 	cmpne	r2,r2,zero
 909987c:	103fe41e 	bne	r2,zero,9099810 <lcd_handle_escape+0xec>
 9099880:	00000206 	br	909988c <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 9099884:	00bfffc4 	movi	r2,-1
 9099888:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 909988c:	e0bffe07 	ldb	r2,-8(fp)
 9099890:	e0bfff15 	stw	r2,-4(fp)
 9099894:	e0ffff17 	ldw	r3,-4(fp)
 9099898:	188012a0 	cmpeqi	r2,r3,74
 909989c:	10002f1e 	bne	r2,zero,909995c <lcd_handle_escape+0x238>
 90998a0:	e0ffff17 	ldw	r3,-4(fp)
 90998a4:	188012c8 	cmpgei	r2,r3,75
 90998a8:	1000041e 	bne	r2,zero,90998bc <lcd_handle_escape+0x198>
 90998ac:	e0ffff17 	ldw	r3,-4(fp)
 90998b0:	18801220 	cmpeqi	r2,r3,72
 90998b4:	1000081e 	bne	r2,zero,90998d8 <lcd_handle_escape+0x1b4>
 90998b8:	00004906 	br	90999e0 <lcd_handle_escape+0x2bc>
 90998bc:	e0ffff17 	ldw	r3,-4(fp)
 90998c0:	188012e0 	cmpeqi	r2,r3,75
 90998c4:	10002b1e 	bne	r2,zero,9099974 <lcd_handle_escape+0x250>
 90998c8:	e0ffff17 	ldw	r3,-4(fp)
 90998cc:	188019a0 	cmpeqi	r2,r3,102
 90998d0:	1000011e 	bne	r2,zero,90998d8 <lcd_handle_escape+0x1b4>
 90998d4:	00004206 	br	90999e0 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 90998d8:	e0bffb17 	ldw	r2,-20(fp)
 90998dc:	10800050 	cmplti	r2,r2,1
 90998e0:	1000051e 	bne	r2,zero,90998f8 <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 90998e4:	e0bffb17 	ldw	r2,-20(fp)
 90998e8:	10bfffc4 	addi	r2,r2,-1
 90998ec:	1007883a 	mov	r3,r2
 90998f0:	e0bffd17 	ldw	r2,-12(fp)
 90998f4:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 90998f8:	e0bffc17 	ldw	r2,-16(fp)
 90998fc:	10800050 	cmplti	r2,r2,1
 9099900:	1000371e 	bne	r2,zero,90999e0 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 9099904:	e0bffc17 	ldw	r2,-16(fp)
 9099908:	10bfffc4 	addi	r2,r2,-1
 909990c:	1007883a 	mov	r3,r2
 9099910:	e0bffd17 	ldw	r2,-12(fp)
 9099914:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 9099918:	e0bffd17 	ldw	r2,-12(fp)
 909991c:	10800883 	ldbu	r2,34(r2)
 9099920:	10803fcc 	andi	r2,r2,255
 9099924:	10800170 	cmpltui	r2,r2,5
 9099928:	1000061e 	bne	r2,zero,9099944 <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 909992c:	e0fffd17 	ldw	r3,-12(fp)
 9099930:	00800104 	movi	r2,4
 9099934:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 9099938:	00000206 	br	9099944 <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 909993c:	e13ffd17 	ldw	r4,-12(fp)
 9099940:	909965c0 	call	909965c <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 9099944:	e0bffd17 	ldw	r2,-12(fp)
 9099948:	10800883 	ldbu	r2,34(r2)
 909994c:	10803fcc 	andi	r2,r2,255
 9099950:	108000e8 	cmpgeui	r2,r2,3
 9099954:	103ff91e 	bne	r2,zero,909993c <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 9099958:	00002106 	br	90999e0 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 909995c:	e0bffc17 	ldw	r2,-16(fp)
 9099960:	10800098 	cmpnei	r2,r2,2
 9099964:	10001e1e 	bne	r2,zero,90999e0 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 9099968:	e13ffd17 	ldw	r4,-12(fp)
 909996c:	90993ac0 	call	90993ac <lcd_clear_screen>
    break;
 9099970:	00001b06 	br	90999e0 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 9099974:	e0bffc17 	ldw	r2,-16(fp)
 9099978:	10800048 	cmpgei	r2,r2,1
 909997c:	1000181e 	bne	r2,zero,90999e0 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9099980:	e0bffd17 	ldw	r2,-12(fp)
 9099984:	10800843 	ldbu	r2,33(r2)
 9099988:	10803fcc 	andi	r2,r2,255
 909998c:	10801428 	cmpgeui	r2,r2,80
 9099990:	1000131e 	bne	r2,zero,90999e0 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 9099994:	e0bffd17 	ldw	r2,-12(fp)
 9099998:	10800883 	ldbu	r2,34(r2)
 909999c:	10803fcc 	andi	r2,r2,255
 90999a0:	108018e4 	muli	r2,r2,99
 90999a4:	10c01004 	addi	r3,r2,64
 90999a8:	e0bffd17 	ldw	r2,-12(fp)
 90999ac:	1887883a 	add	r3,r3,r2
 90999b0:	e0bffd17 	ldw	r2,-12(fp)
 90999b4:	10800843 	ldbu	r2,33(r2)
 90999b8:	10803fcc 	andi	r2,r2,255
 90999bc:	1889883a 	add	r4,r3,r2
 90999c0:	e0bffd17 	ldw	r2,-12(fp)
 90999c4:	10800843 	ldbu	r2,33(r2)
 90999c8:	10c03fcc 	andi	r3,r2,255
 90999cc:	00801404 	movi	r2,80
 90999d0:	10c5c83a 	sub	r2,r2,r3
 90999d4:	100d883a 	mov	r6,r2
 90999d8:	01400804 	movi	r5,32
 90999dc:	90832780 	call	9083278 <memset>
    }
    break;
  }
}
 90999e0:	e037883a 	mov	sp,fp
 90999e4:	dfc00117 	ldw	ra,4(sp)
 90999e8:	df000017 	ldw	fp,0(sp)
 90999ec:	dec00204 	addi	sp,sp,8
 90999f0:	f800283a 	ret

090999f4 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 90999f4:	defff004 	addi	sp,sp,-64
 90999f8:	dfc00f15 	stw	ra,60(sp)
 90999fc:	df000e15 	stw	fp,56(sp)
 9099a00:	df000e04 	addi	fp,sp,56
 9099a04:	e13ffc15 	stw	r4,-16(fp)
 9099a08:	e17ffd15 	stw	r5,-12(fp)
 9099a0c:	e1bffe15 	stw	r6,-8(fp)
 9099a10:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 9099a14:	e0bffe17 	ldw	r2,-8(fp)
 9099a18:	1007883a 	mov	r3,r2
 9099a1c:	e0bffd17 	ldw	r2,-12(fp)
 9099a20:	10c5883a 	add	r2,r2,r3
 9099a24:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 9099a28:	e0bffc17 	ldw	r2,-16(fp)
 9099a2c:	10803e17 	ldw	r2,248(r2)
 9099a30:	e0bff215 	stw	r2,-56(fp)
 9099a34:	e03ff30d 	sth	zero,-52(fp)
 9099a38:	e17ff30b 	ldhu	r5,-52(fp)
 9099a3c:	e1bffb04 	addi	r6,fp,-20
 9099a40:	e13ff217 	ldw	r4,-56(fp)
 9099a44:	9093c5c0 	call	9093c5c <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 9099a48:	e0fffc17 	ldw	r3,-16(fp)
 9099a4c:	00800044 	movi	r2,1
 9099a50:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 9099a54:	0000a206 	br	9099ce0 <altera_avalon_lcd_16207_write+0x2ec>
  {
    char c = *ptr;
 9099a58:	e0bffd17 	ldw	r2,-12(fp)
 9099a5c:	10800003 	ldbu	r2,0(r2)
 9099a60:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 9099a64:	e0bffc17 	ldw	r2,-16(fp)
 9099a68:	10800903 	ldbu	r2,36(r2)
 9099a6c:	10803fcc 	andi	r2,r2,255
 9099a70:	1080201c 	xori	r2,r2,128
 9099a74:	10bfe004 	addi	r2,r2,-128
 9099a78:	1004803a 	cmplt	r2,r2,zero
 9099a7c:	10003b1e 	bne	r2,zero,9099b6c <altera_avalon_lcd_16207_write+0x178>
    {
      unsigned int esccount = sp->esccount;
 9099a80:	e0bffc17 	ldw	r2,-16(fp)
 9099a84:	10800903 	ldbu	r2,36(r2)
 9099a88:	10803fcc 	andi	r2,r2,255
 9099a8c:	1080201c 	xori	r2,r2,128
 9099a90:	10bfe004 	addi	r2,r2,-128
 9099a94:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9099a98:	e0bff617 	ldw	r2,-40(fp)
 9099a9c:	1004c03a 	cmpne	r2,r2,zero
 9099aa0:	1000031e 	bne	r2,zero,9099ab0 <altera_avalon_lcd_16207_write+0xbc>
 9099aa4:	e0bff707 	ldb	r2,-36(fp)
 9099aa8:	108016d8 	cmpnei	r2,r2,91
 9099aac:	1000111e 	bne	r2,zero,9099af4 <altera_avalon_lcd_16207_write+0x100>
 9099ab0:	e0bff617 	ldw	r2,-40(fp)
 9099ab4:	1005003a 	cmpeq	r2,r2,zero
 9099ab8:	10001a1e 	bne	r2,zero,9099b24 <altera_avalon_lcd_16207_write+0x130>
 9099abc:	e0bff707 	ldb	r2,-36(fp)
 9099ac0:	1007883a 	mov	r3,r2
 9099ac4:	00824374 	movhi	r2,2317
 9099ac8:	108e8504 	addi	r2,r2,14868
 9099acc:	10800017 	ldw	r2,0(r2)
 9099ad0:	1885883a 	add	r2,r3,r2
 9099ad4:	10800003 	ldbu	r2,0(r2)
 9099ad8:	10803fcc 	andi	r2,r2,255
 9099adc:	1080010c 	andi	r2,r2,4
 9099ae0:	1004c03a 	cmpne	r2,r2,zero
 9099ae4:	10000f1e 	bne	r2,zero,9099b24 <altera_avalon_lcd_16207_write+0x130>
 9099ae8:	e0bff707 	ldb	r2,-36(fp)
 9099aec:	10800ee0 	cmpeqi	r2,r2,59
 9099af0:	10000c1e 	bne	r2,zero,9099b24 <altera_avalon_lcd_16207_write+0x130>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 9099af4:	e0fff617 	ldw	r3,-40(fp)
 9099af8:	e0bffc17 	ldw	r2,-16(fp)
 9099afc:	1885883a 	add	r2,r3,r2
 9099b00:	10800a04 	addi	r2,r2,40
 9099b04:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 9099b08:	e17ff707 	ldb	r5,-36(fp)
 9099b0c:	e13ffc17 	ldw	r4,-16(fp)
 9099b10:	90997240 	call	9099724 <lcd_handle_escape>

        sp->esccount = -1;
 9099b14:	e0fffc17 	ldw	r3,-16(fp)
 9099b18:	00bfffc4 	movi	r2,-1
 9099b1c:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 9099b20:	00006c06 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 9099b24:	e0bffc17 	ldw	r2,-16(fp)
 9099b28:	10800903 	ldbu	r2,36(r2)
 9099b2c:	10803fcc 	andi	r2,r2,255
 9099b30:	108001e8 	cmpgeui	r2,r2,7
 9099b34:	1000671e 	bne	r2,zero,9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
      {
        sp->escape[esccount] = c;
 9099b38:	e0fff617 	ldw	r3,-40(fp)
 9099b3c:	e0bffc17 	ldw	r2,-16(fp)
 9099b40:	1885883a 	add	r2,r3,r2
 9099b44:	10c00a04 	addi	r3,r2,40
 9099b48:	e0bff703 	ldbu	r2,-36(fp)
 9099b4c:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 9099b50:	e0bffc17 	ldw	r2,-16(fp)
 9099b54:	10800903 	ldbu	r2,36(r2)
 9099b58:	10800044 	addi	r2,r2,1
 9099b5c:	1007883a 	mov	r3,r2
 9099b60:	e0bffc17 	ldw	r2,-16(fp)
 9099b64:	10c00905 	stb	r3,36(r2)
 9099b68:	00005a06 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
      }
    }
    else if (c == 27) /* ESC */
 9099b6c:	e0bff707 	ldb	r2,-36(fp)
 9099b70:	108006d8 	cmpnei	r2,r2,27
 9099b74:	1000031e 	bne	r2,zero,9099b84 <altera_avalon_lcd_16207_write+0x190>
    {
      sp->esccount = 0;
 9099b78:	e0bffc17 	ldw	r2,-16(fp)
 9099b7c:	10000905 	stb	zero,36(r2)
 9099b80:	00005406 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\r')
 9099b84:	e0bff707 	ldb	r2,-36(fp)
 9099b88:	10800358 	cmpnei	r2,r2,13
 9099b8c:	1000031e 	bne	r2,zero,9099b9c <altera_avalon_lcd_16207_write+0x1a8>
    {
      sp->x = 0;
 9099b90:	e0bffc17 	ldw	r2,-16(fp)
 9099b94:	10000845 	stb	zero,33(r2)
 9099b98:	00004e06 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\n')
 9099b9c:	e0bff707 	ldb	r2,-36(fp)
 9099ba0:	10800298 	cmpnei	r2,r2,10
 9099ba4:	1000101e 	bne	r2,zero,9099be8 <altera_avalon_lcd_16207_write+0x1f4>
    {
      sp->x = 0;
 9099ba8:	e0bffc17 	ldw	r2,-16(fp)
 9099bac:	10000845 	stb	zero,33(r2)
      sp->y++;
 9099bb0:	e0bffc17 	ldw	r2,-16(fp)
 9099bb4:	10800883 	ldbu	r2,34(r2)
 9099bb8:	10800044 	addi	r2,r2,1
 9099bbc:	1007883a 	mov	r3,r2
 9099bc0:	e0bffc17 	ldw	r2,-16(fp)
 9099bc4:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 9099bc8:	e0bffc17 	ldw	r2,-16(fp)
 9099bcc:	10800883 	ldbu	r2,34(r2)
 9099bd0:	10803fcc 	andi	r2,r2,255
 9099bd4:	108000f0 	cmpltui	r2,r2,3
 9099bd8:	10003e1e 	bne	r2,zero,9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
        lcd_scroll_up(sp);
 9099bdc:	e13ffc17 	ldw	r4,-16(fp)
 9099be0:	909965c0 	call	909965c <lcd_scroll_up>
 9099be4:	00003b06 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\b')
 9099be8:	e0bff707 	ldb	r2,-36(fp)
 9099bec:	10800218 	cmpnei	r2,r2,8
 9099bf0:	10000c1e 	bne	r2,zero,9099c24 <altera_avalon_lcd_16207_write+0x230>
    {
      if (sp->x > 0)
 9099bf4:	e0bffc17 	ldw	r2,-16(fp)
 9099bf8:	10800843 	ldbu	r2,33(r2)
 9099bfc:	10803fcc 	andi	r2,r2,255
 9099c00:	1005003a 	cmpeq	r2,r2,zero
 9099c04:	1000331e 	bne	r2,zero,9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
        sp->x--;
 9099c08:	e0bffc17 	ldw	r2,-16(fp)
 9099c0c:	10800843 	ldbu	r2,33(r2)
 9099c10:	10bfffc4 	addi	r2,r2,-1
 9099c14:	1007883a 	mov	r3,r2
 9099c18:	e0bffc17 	ldw	r2,-16(fp)
 9099c1c:	10c00845 	stb	r3,33(r2)
 9099c20:	00002c06 	br	9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (isprint(c))
 9099c24:	e0bff707 	ldb	r2,-36(fp)
 9099c28:	1007883a 	mov	r3,r2
 9099c2c:	00824374 	movhi	r2,2317
 9099c30:	108e8504 	addi	r2,r2,14868
 9099c34:	10800017 	ldw	r2,0(r2)
 9099c38:	1885883a 	add	r2,r3,r2
 9099c3c:	10800003 	ldbu	r2,0(r2)
 9099c40:	10803fcc 	andi	r2,r2,255
 9099c44:	1080201c 	xori	r2,r2,128
 9099c48:	10bfe004 	addi	r2,r2,-128
 9099c4c:	108025cc 	andi	r2,r2,151
 9099c50:	1005003a 	cmpeq	r2,r2,zero
 9099c54:	10001f1e 	bne	r2,zero,9099cd4 <altera_avalon_lcd_16207_write+0x2e0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 9099c58:	e0bffc17 	ldw	r2,-16(fp)
 9099c5c:	10800883 	ldbu	r2,34(r2)
 9099c60:	10803fcc 	andi	r2,r2,255
 9099c64:	108000b0 	cmpltui	r2,r2,2
 9099c68:	1000021e 	bne	r2,zero,9099c74 <altera_avalon_lcd_16207_write+0x280>
        lcd_scroll_up(sp);
 9099c6c:	e13ffc17 	ldw	r4,-16(fp)
 9099c70:	909965c0 	call	909965c <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 9099c74:	e0bffc17 	ldw	r2,-16(fp)
 9099c78:	10800843 	ldbu	r2,33(r2)
 9099c7c:	10803fcc 	andi	r2,r2,255
 9099c80:	10801428 	cmpgeui	r2,r2,80
 9099c84:	10000d1e 	bne	r2,zero,9099cbc <altera_avalon_lcd_16207_write+0x2c8>
        sp->line[sp->y].data[sp->x] = c;
 9099c88:	e0bffc17 	ldw	r2,-16(fp)
 9099c8c:	10800883 	ldbu	r2,34(r2)
 9099c90:	11003fcc 	andi	r4,r2,255
 9099c94:	e0bffc17 	ldw	r2,-16(fp)
 9099c98:	10800843 	ldbu	r2,33(r2)
 9099c9c:	11403fcc 	andi	r5,r2,255
 9099ca0:	e0fffc17 	ldw	r3,-16(fp)
 9099ca4:	208018e4 	muli	r2,r4,99
 9099ca8:	10c5883a 	add	r2,r2,r3
 9099cac:	1145883a 	add	r2,r2,r5
 9099cb0:	10c01004 	addi	r3,r2,64
 9099cb4:	e0bff703 	ldbu	r2,-36(fp)
 9099cb8:	18800005 	stb	r2,0(r3)

      sp->x++;
 9099cbc:	e0bffc17 	ldw	r2,-16(fp)
 9099cc0:	10800843 	ldbu	r2,33(r2)
 9099cc4:	10800044 	addi	r2,r2,1
 9099cc8:	1007883a 	mov	r3,r2
 9099ccc:	e0bffc17 	ldw	r2,-16(fp)
 9099cd0:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 9099cd4:	e0bffd17 	ldw	r2,-12(fp)
 9099cd8:	10800044 	addi	r2,r2,1
 9099cdc:	e0bffd15 	stw	r2,-12(fp)
 9099ce0:	e0fffd17 	ldw	r3,-12(fp)
 9099ce4:	e0bffa17 	ldw	r2,-24(fp)
 9099ce8:	18bf5b36 	bltu	r3,r2,9099a58 <altera_avalon_lcd_16207_write+0x64>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 9099cec:	00800404 	movi	r2,16
 9099cf0:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099cf4:	e03ff915 	stw	zero,-28(fp)
 9099cf8:	00003606 	br	9099dd4 <altera_avalon_lcd_16207_write+0x3e0>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 9099cfc:	00801404 	movi	r2,80
 9099d00:	e0bff515 	stw	r2,-44(fp)
 9099d04:	00001106 	br	9099d4c <altera_avalon_lcd_16207_write+0x358>
      if (sp->line[y].data[width-1] != ' ')
 9099d08:	e13ff917 	ldw	r4,-28(fp)
 9099d0c:	e0bff517 	ldw	r2,-44(fp)
 9099d10:	117fffc4 	addi	r5,r2,-1
 9099d14:	e0fffc17 	ldw	r3,-16(fp)
 9099d18:	208018e4 	muli	r2,r4,99
 9099d1c:	10c5883a 	add	r2,r2,r3
 9099d20:	1145883a 	add	r2,r2,r5
 9099d24:	10801004 	addi	r2,r2,64
 9099d28:	10800003 	ldbu	r2,0(r2)
 9099d2c:	10803fcc 	andi	r2,r2,255
 9099d30:	1080201c 	xori	r2,r2,128
 9099d34:	10bfe004 	addi	r2,r2,-128
 9099d38:	10800818 	cmpnei	r2,r2,32
 9099d3c:	1000061e 	bne	r2,zero,9099d58 <altera_avalon_lcd_16207_write+0x364>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 9099d40:	e0bff517 	ldw	r2,-44(fp)
 9099d44:	10bfffc4 	addi	r2,r2,-1
 9099d48:	e0bff515 	stw	r2,-44(fp)
 9099d4c:	e0bff517 	ldw	r2,-44(fp)
 9099d50:	10800048 	cmpgei	r2,r2,1
 9099d54:	103fec1e 	bne	r2,zero,9099d08 <altera_avalon_lcd_16207_write+0x314>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 9099d58:	e0bff517 	ldw	r2,-44(fp)
 9099d5c:	10800448 	cmpgei	r2,r2,17
 9099d60:	1000031e 	bne	r2,zero,9099d70 <altera_avalon_lcd_16207_write+0x37c>
      width = ALT_LCD_WIDTH;
 9099d64:	00800404 	movi	r2,16
 9099d68:	e0bff515 	stw	r2,-44(fp)
 9099d6c:	00000306 	br	9099d7c <altera_avalon_lcd_16207_write+0x388>
    else
      width++;
 9099d70:	e0bff517 	ldw	r2,-44(fp)
 9099d74:	10800044 	addi	r2,r2,1
 9099d78:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 9099d7c:	e13ff917 	ldw	r4,-28(fp)
 9099d80:	e0bff517 	ldw	r2,-44(fp)
 9099d84:	100b883a 	mov	r5,r2
 9099d88:	e0fffc17 	ldw	r3,-16(fp)
 9099d8c:	208018e4 	muli	r2,r4,99
 9099d90:	10c5883a 	add	r2,r2,r3
 9099d94:	10802404 	addi	r2,r2,144
 9099d98:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 9099d9c:	e0fff817 	ldw	r3,-32(fp)
 9099da0:	e0bff517 	ldw	r2,-44(fp)
 9099da4:	1880020e 	bge	r3,r2,9099db0 <altera_avalon_lcd_16207_write+0x3bc>
      widthmax = width;
 9099da8:	e0bff517 	ldw	r2,-44(fp)
 9099dac:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 9099db0:	e0bff917 	ldw	r2,-28(fp)
 9099db4:	e0fffc17 	ldw	r3,-16(fp)
 9099db8:	108018e4 	muli	r2,r2,99
 9099dbc:	10c5883a 	add	r2,r2,r3
 9099dc0:	10802404 	addi	r2,r2,144
 9099dc4:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099dc8:	e0bff917 	ldw	r2,-28(fp)
 9099dcc:	10800044 	addi	r2,r2,1
 9099dd0:	e0bff915 	stw	r2,-28(fp)
 9099dd4:	e0bff917 	ldw	r2,-28(fp)
 9099dd8:	10800090 	cmplti	r2,r2,2
 9099ddc:	103fc71e 	bne	r2,zero,9099cfc <altera_avalon_lcd_16207_write+0x308>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 9099de0:	e0bff817 	ldw	r2,-32(fp)
 9099de4:	10800448 	cmpgei	r2,r2,17
 9099de8:	1000031e 	bne	r2,zero,9099df8 <altera_avalon_lcd_16207_write+0x404>
    sp->scrollmax = 0;
 9099dec:	e0bffc17 	ldw	r2,-16(fp)
 9099df0:	10000985 	stb	zero,38(r2)
 9099df4:	00002d06 	br	9099eac <altera_avalon_lcd_16207_write+0x4b8>
  else
  {
    widthmax *= 2;
 9099df8:	e0bff817 	ldw	r2,-32(fp)
 9099dfc:	1085883a 	add	r2,r2,r2
 9099e00:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 9099e04:	e0bff817 	ldw	r2,-32(fp)
 9099e08:	1007883a 	mov	r3,r2
 9099e0c:	e0bffc17 	ldw	r2,-16(fp)
 9099e10:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099e14:	e03ff915 	stw	zero,-28(fp)
 9099e18:	00002106 	br	9099ea0 <altera_avalon_lcd_16207_write+0x4ac>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 9099e1c:	e0bff917 	ldw	r2,-28(fp)
 9099e20:	e0fffc17 	ldw	r3,-16(fp)
 9099e24:	108018e4 	muli	r2,r2,99
 9099e28:	10c5883a 	add	r2,r2,r3
 9099e2c:	10802404 	addi	r2,r2,144
 9099e30:	10800043 	ldbu	r2,1(r2)
 9099e34:	10803fcc 	andi	r2,r2,255
 9099e38:	1080201c 	xori	r2,r2,128
 9099e3c:	10bfe004 	addi	r2,r2,-128
 9099e40:	10800450 	cmplti	r2,r2,17
 9099e44:	1000131e 	bne	r2,zero,9099e94 <altera_avalon_lcd_16207_write+0x4a0>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 9099e48:	e17ff917 	ldw	r5,-28(fp)
 9099e4c:	e0bff917 	ldw	r2,-28(fp)
 9099e50:	e0fffc17 	ldw	r3,-16(fp)
 9099e54:	108018e4 	muli	r2,r2,99
 9099e58:	10c5883a 	add	r2,r2,r3
 9099e5c:	10802404 	addi	r2,r2,144
 9099e60:	10800043 	ldbu	r2,1(r2)
 9099e64:	10803fcc 	andi	r2,r2,255
 9099e68:	1080201c 	xori	r2,r2,128
 9099e6c:	10bfe004 	addi	r2,r2,-128
 9099e70:	1006923a 	slli	r3,r2,8
 9099e74:	e0bff817 	ldw	r2,-32(fp)
 9099e78:	1885283a 	div	r2,r3,r2
 9099e7c:	1009883a 	mov	r4,r2
 9099e80:	e0fffc17 	ldw	r3,-16(fp)
 9099e84:	288018e4 	muli	r2,r5,99
 9099e88:	10c5883a 	add	r2,r2,r3
 9099e8c:	10802404 	addi	r2,r2,144
 9099e90:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 9099e94:	e0bff917 	ldw	r2,-28(fp)
 9099e98:	10800044 	addi	r2,r2,1
 9099e9c:	e0bff915 	stw	r2,-28(fp)
 9099ea0:	e0bff917 	ldw	r2,-28(fp)
 9099ea4:	10800090 	cmplti	r2,r2,2
 9099ea8:	103fdc1e 	bne	r2,zero,9099e1c <altera_avalon_lcd_16207_write+0x428>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 9099eac:	e0bffc17 	ldw	r2,-16(fp)
 9099eb0:	10800943 	ldbu	r2,37(r2)
 9099eb4:	10803fcc 	andi	r2,r2,255
 9099eb8:	1080201c 	xori	r2,r2,128
 9099ebc:	10bfe004 	addi	r2,r2,-128
 9099ec0:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 9099ec4:	e13ffc17 	ldw	r4,-16(fp)
 9099ec8:	90994700 	call	9099470 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 9099ecc:	e0bffc17 	ldw	r2,-16(fp)
 9099ed0:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 9099ed4:	e0bffc17 	ldw	r2,-16(fp)
 9099ed8:	10800943 	ldbu	r2,37(r2)
 9099edc:	10c03fcc 	andi	r3,r2,255
 9099ee0:	18c0201c 	xori	r3,r3,128
 9099ee4:	18ffe004 	addi	r3,r3,-128
 9099ee8:	e0bff417 	ldw	r2,-48(fp)
 9099eec:	18800426 	beq	r3,r2,9099f00 <altera_avalon_lcd_16207_write+0x50c>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 9099ef0:	e0fffc17 	ldw	r3,-16(fp)
 9099ef4:	00800044 	movi	r2,1
 9099ef8:	188009c5 	stb	r2,39(r3)
  }
 9099efc:	003feb06 	br	9099eac <altera_avalon_lcd_16207_write+0x4b8>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 9099f00:	e0bffc17 	ldw	r2,-16(fp)
 9099f04:	11003e17 	ldw	r4,248(r2)
 9099f08:	90940540 	call	9094054 <OSSemPost>

  return len;
 9099f0c:	e0bffe17 	ldw	r2,-8(fp)
}
 9099f10:	e037883a 	mov	sp,fp
 9099f14:	dfc00117 	ldw	ra,4(sp)
 9099f18:	df000017 	ldw	fp,0(sp)
 9099f1c:	dec00204 	addi	sp,sp,8
 9099f20:	f800283a 	ret

09099f24 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 9099f24:	defffc04 	addi	sp,sp,-16
 9099f28:	dfc00315 	stw	ra,12(sp)
 9099f2c:	df000215 	stw	fp,8(sp)
 9099f30:	df000204 	addi	fp,sp,8
 9099f34:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 9099f38:	e0bfff17 	ldw	r2,-4(fp)
 9099f3c:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 9099f40:	e0bffe17 	ldw	r2,-8(fp)
 9099f44:	10800943 	ldbu	r2,37(r2)
 9099f48:	10803fcc 	andi	r2,r2,255
 9099f4c:	1080201c 	xori	r2,r2,128
 9099f50:	10bfe004 	addi	r2,r2,-128
 9099f54:	10c00044 	addi	r3,r2,1
 9099f58:	e0bffe17 	ldw	r2,-8(fp)
 9099f5c:	10800983 	ldbu	r2,38(r2)
 9099f60:	10803fcc 	andi	r2,r2,255
 9099f64:	1080201c 	xori	r2,r2,128
 9099f68:	10bfe004 	addi	r2,r2,-128
 9099f6c:	18800316 	blt	r3,r2,9099f7c <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 9099f70:	e0bffe17 	ldw	r2,-8(fp)
 9099f74:	10000945 	stb	zero,37(r2)
 9099f78:	00000606 	br	9099f94 <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 9099f7c:	e0bffe17 	ldw	r2,-8(fp)
 9099f80:	10800943 	ldbu	r2,37(r2)
 9099f84:	10800044 	addi	r2,r2,1
 9099f88:	1007883a 	mov	r3,r2
 9099f8c:	e0bffe17 	ldw	r2,-8(fp)
 9099f90:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 9099f94:	e0bffe17 	ldw	r2,-8(fp)
 9099f98:	10800983 	ldbu	r2,38(r2)
 9099f9c:	10803fcc 	andi	r2,r2,255
 9099fa0:	1080201c 	xori	r2,r2,128
 9099fa4:	10bfe004 	addi	r2,r2,-128
 9099fa8:	10800050 	cmplti	r2,r2,1
 9099fac:	1000091e 	bne	r2,zero,9099fd4 <alt_lcd_16207_timeout+0xb0>
 9099fb0:	e0bffe17 	ldw	r2,-8(fp)
 9099fb4:	108009c3 	ldbu	r2,39(r2)
 9099fb8:	10803fcc 	andi	r2,r2,255
 9099fbc:	1080201c 	xori	r2,r2,128
 9099fc0:	10bfe004 	addi	r2,r2,-128
 9099fc4:	1004c03a 	cmpne	r2,r2,zero
 9099fc8:	1000021e 	bne	r2,zero,9099fd4 <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 9099fcc:	e13ffe17 	ldw	r4,-8(fp)
 9099fd0:	90994700 	call	9099470 <lcd_repaint_screen>

  return sp->period;
 9099fd4:	e0bffe17 	ldw	r2,-8(fp)
 9099fd8:	10800717 	ldw	r2,28(r2)
}
 9099fdc:	e037883a 	mov	sp,fp
 9099fe0:	dfc00117 	ldw	ra,4(sp)
 9099fe4:	df000017 	ldw	fp,0(sp)
 9099fe8:	dec00204 	addi	sp,sp,8
 9099fec:	f800283a 	ret

09099ff0 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 9099ff0:	defff804 	addi	sp,sp,-32
 9099ff4:	dfc00715 	stw	ra,28(sp)
 9099ff8:	df000615 	stw	fp,24(sp)
 9099ffc:	df000604 	addi	fp,sp,24
 909a000:	e13ffd15 	stw	r4,-12(fp)
  unsigned int base = sp->base;
 909a004:	e0bffd17 	ldw	r2,-12(fp)
 909a008:	10800017 	ldw	r2,0(r2)
 909a00c:	e0bffc15 	stw	r2,-16(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 909a010:	e0bffd17 	ldw	r2,-12(fp)
 909a014:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 909a018:	e0bffd17 	ldw	r2,-12(fp)
 909a01c:	10803e04 	addi	r2,r2,248
 909a020:	e0bffa15 	stw	r2,-24(fp)
 909a024:	00800044 	movi	r2,1
 909a028:	e0bffb0d 	sth	r2,-20(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 909a02c:	e13ffb0b 	ldhu	r4,-20(fp)
 909a030:	90938a80 	call	90938a8 <OSSemCreate>
 909a034:	1007883a 	mov	r3,r2
 909a038:	e0bffa17 	ldw	r2,-24(fp)
 909a03c:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 909a040:	010ea604 	movi	r4,15000
 909a044:	90baa880 	call	90baa88 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 909a048:	e0bffc17 	ldw	r2,-16(fp)
 909a04c:	1007883a 	mov	r3,r2
 909a050:	00800c04 	movi	r2,48
 909a054:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 909a058:	01040104 	movi	r4,4100
 909a05c:	90baa880 	call	90baa88 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 909a060:	e0bffc17 	ldw	r2,-16(fp)
 909a064:	1007883a 	mov	r3,r2
 909a068:	00800c04 	movi	r2,48
 909a06c:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 909a070:	0100fa04 	movi	r4,1000
 909a074:	90baa880 	call	90baa88 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 909a078:	e0bffc17 	ldw	r2,-16(fp)
 909a07c:	1007883a 	mov	r3,r2
 909a080:	00800c04 	movi	r2,48
 909a084:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 909a088:	e13ffd17 	ldw	r4,-12(fp)
 909a08c:	01400e04 	movi	r5,56
 909a090:	90992200 	call	9099220 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 909a094:	e13ffd17 	ldw	r4,-12(fp)
 909a098:	01400204 	movi	r5,8
 909a09c:	90992200 	call	9099220 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 909a0a0:	e13ffd17 	ldw	r4,-12(fp)
 909a0a4:	90993ac0 	call	90993ac <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 909a0a8:	e13ffd17 	ldw	r4,-12(fp)
 909a0ac:	01400184 	movi	r5,6
 909a0b0:	90992200 	call	9099220 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 909a0b4:	e13ffd17 	ldw	r4,-12(fp)
 909a0b8:	01400304 	movi	r5,12
 909a0bc:	90992200 	call	9099220 <lcd_write_command>

  sp->esccount = -1;
 909a0c0:	e0fffd17 	ldw	r3,-12(fp)
 909a0c4:	00bfffc4 	movi	r2,-1
 909a0c8:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 909a0cc:	e0bffd17 	ldw	r2,-12(fp)
 909a0d0:	11000a04 	addi	r4,r2,40
 909a0d4:	000b883a 	mov	r5,zero
 909a0d8:	01800204 	movi	r6,8
 909a0dc:	90832780 	call	9083278 <memset>

  sp->scrollpos = 0;
 909a0e0:	e0bffd17 	ldw	r2,-12(fp)
 909a0e4:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 909a0e8:	e0bffd17 	ldw	r2,-12(fp)
 909a0ec:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 909a0f0:	e0bffd17 	ldw	r2,-12(fp)
 909a0f4:	100009c5 	stb	zero,39(r2)
 909a0f8:	00824374 	movhi	r2,2317
 909a0fc:	108f3e04 	addi	r2,r2,15608
 909a100:	10800017 	ldw	r2,0(r2)
 909a104:	1007883a 	mov	r3,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 909a108:	00b33374 	movhi	r2,52429
 909a10c:	10b33344 	addi	r2,r2,-13107
 909a110:	1889383a 	mul	r4,r3,r2
 909a114:	e13ffe15 	stw	r4,-8(fp)
 909a118:	1886383a 	mulxuu	r3,r3,r2
 909a11c:	e0ffff15 	stw	r3,-4(fp)
 909a120:	e0ffff17 	ldw	r3,-4(fp)
 909a124:	1804d0fa 	srli	r2,r3,3
 909a128:	1007883a 	mov	r3,r2
 909a12c:	e0bffd17 	ldw	r2,-12(fp)
 909a130:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 909a134:	e0bffd17 	ldw	r2,-12(fp)
 909a138:	11000104 	addi	r4,r2,4
 909a13c:	e0bffd17 	ldw	r2,-12(fp)
 909a140:	10800717 	ldw	r2,28(r2)
 909a144:	100b883a 	mov	r5,r2
 909a148:	018242b4 	movhi	r6,2314
 909a14c:	31a7c904 	addi	r6,r6,-24796
 909a150:	e1fffd17 	ldw	r7,-12(fp)
 909a154:	90b998c0 	call	90b998c <alt_alarm_start>
}
 909a158:	e037883a 	mov	sp,fp
 909a15c:	dfc00117 	ldw	ra,4(sp)
 909a160:	df000017 	ldw	fp,0(sp)
 909a164:	dec00204 	addi	sp,sp,8
 909a168:	f800283a 	ret

0909a16c <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 909a16c:	defffa04 	addi	sp,sp,-24
 909a170:	dfc00515 	stw	ra,20(sp)
 909a174:	df000415 	stw	fp,16(sp)
 909a178:	df000404 	addi	fp,sp,16
 909a17c:	e13ffd15 	stw	r4,-12(fp)
 909a180:	e17ffe15 	stw	r5,-8(fp)
 909a184:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 909a188:	e0bffd17 	ldw	r2,-12(fp)
 909a18c:	10800017 	ldw	r2,0(r2)
 909a190:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 909a194:	e0bffc17 	ldw	r2,-16(fp)
 909a198:	11000a04 	addi	r4,r2,40
 909a19c:	e0bffd17 	ldw	r2,-12(fp)
 909a1a0:	11c00217 	ldw	r7,8(r2)
 909a1a4:	e17ffe17 	ldw	r5,-8(fp)
 909a1a8:	e1bfff17 	ldw	r6,-4(fp)
 909a1ac:	90999f40 	call	90999f4 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 909a1b0:	e037883a 	mov	sp,fp
 909a1b4:	dfc00117 	ldw	ra,4(sp)
 909a1b8:	df000017 	ldw	fp,0(sp)
 909a1bc:	dec00204 	addi	sp,sp,8
 909a1c0:	f800283a 	ret

0909a1c4 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 909a1c4:	defffb04 	addi	sp,sp,-20
 909a1c8:	df000415 	stw	fp,16(sp)
 909a1cc:	df000404 	addi	fp,sp,16
 909a1d0:	e13ffd15 	stw	r4,-12(fp)
 909a1d4:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 909a1d8:	e0bffd17 	ldw	r2,-12(fp)
 909a1dc:	10800317 	ldw	r2,12(r2)
 909a1e0:	10800037 	ldwio	r2,0(r2)
 909a1e4:	1080040c 	andi	r2,r2,16
 909a1e8:	1005003a 	cmpeq	r2,r2,zero
 909a1ec:	1000031e 	bne	r2,zero,909a1fc <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 909a1f0:	00bffc04 	movi	r2,-16
 909a1f4:	e0bfff15 	stw	r2,-4(fp)
 909a1f8:	00003c06 	br	909a2ec <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909a1fc:	e0bffd17 	ldw	r2,-12(fp)
 909a200:	10800317 	ldw	r2,12(r2)
 909a204:	11000404 	addi	r4,r2,16
 909a208:	e0bffd17 	ldw	r2,-12(fp)
 909a20c:	10800317 	ldw	r2,12(r2)
 909a210:	10800404 	addi	r2,r2,16
 909a214:	10c00037 	ldwio	r3,0(r2)
 909a218:	00bff7c4 	movi	r2,-33
 909a21c:	1886703a 	and	r3,r3,r2
 909a220:	2005883a 	mov	r2,r4
 909a224:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 909a228:	e0bffd17 	ldw	r2,-12(fp)
 909a22c:	10800317 	ldw	r2,12(r2)
 909a230:	1007883a 	mov	r3,r2
 909a234:	00803fc4 	movi	r2,255
 909a238:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 909a23c:	e0bffd17 	ldw	r2,-12(fp)
 909a240:	10800317 	ldw	r2,12(r2)
 909a244:	10800804 	addi	r2,r2,32
 909a248:	e0fffe17 	ldw	r3,-8(fp)
 909a24c:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 909a250:	e0bffd17 	ldw	r2,-12(fp)
 909a254:	10800917 	ldw	r2,36(r2)
 909a258:	1005003a 	cmpeq	r2,r2,zero
 909a25c:	1000111e 	bne	r2,zero,909a2a4 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909a260:	e0bffd17 	ldw	r2,-12(fp)
 909a264:	10800317 	ldw	r2,12(r2)
 909a268:	10800404 	addi	r2,r2,16
 909a26c:	10800037 	ldwio	r2,0(r2)
 909a270:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
 909a274:	e0bffd17 	ldw	r2,-12(fp)
 909a278:	10c00b17 	ldw	r3,44(r2)
 909a27c:	e0bffc17 	ldw	r2,-16(fp)
 909a280:	1884b03a 	or	r2,r3,r2
 909a284:	10801814 	ori	r2,r2,96
 909a288:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909a28c:	e0bffd17 	ldw	r2,-12(fp)
 909a290:	10800317 	ldw	r2,12(r2)
 909a294:	10800404 	addi	r2,r2,16
 909a298:	e0fffc17 	ldw	r3,-16(fp)
 909a29c:	10c00035 	stwio	r3,0(r2)
 909a2a0:	00001106 	br	909a2e8 <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909a2a4:	e0bffd17 	ldw	r2,-12(fp)
 909a2a8:	10800317 	ldw	r2,12(r2)
 909a2ac:	10800404 	addi	r2,r2,16
 909a2b0:	10800037 	ldwio	r2,0(r2)
 909a2b4:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 909a2b8:	e0bffc17 	ldw	r2,-16(fp)
 909a2bc:	10801814 	ori	r2,r2,96
 909a2c0:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 909a2c4:	e0fffc17 	ldw	r3,-16(fp)
 909a2c8:	00bffbc4 	movi	r2,-17
 909a2cc:	1884703a 	and	r2,r3,r2
 909a2d0:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909a2d4:	e0bffd17 	ldw	r2,-12(fp)
 909a2d8:	10800317 	ldw	r2,12(r2)
 909a2dc:	10800404 	addi	r2,r2,16
 909a2e0:	e0fffc17 	ldw	r3,-16(fp)
 909a2e4:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 909a2e8:	e03fff15 	stw	zero,-4(fp)
 909a2ec:	e0bfff17 	ldw	r2,-4(fp)
}
 909a2f0:	e037883a 	mov	sp,fp
 909a2f4:	df000017 	ldw	fp,0(sp)
 909a2f8:	dec00104 	addi	sp,sp,4
 909a2fc:	f800283a 	ret

0909a300 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 909a300:	defffc04 	addi	sp,sp,-16
 909a304:	df000315 	stw	fp,12(sp)
 909a308:	df000304 	addi	fp,sp,12
 909a30c:	e13ffe15 	stw	r4,-8(fp)
 909a310:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 909a314:	e0bffe17 	ldw	r2,-8(fp)
 909a318:	10800317 	ldw	r2,12(r2)
 909a31c:	10800037 	ldwio	r2,0(r2)
 909a320:	1080040c 	andi	r2,r2,16
 909a324:	1004c03a 	cmpne	r2,r2,zero
 909a328:	103ffa1e 	bne	r2,zero,909a314 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909a32c:	e0bffe17 	ldw	r2,-8(fp)
 909a330:	10800317 	ldw	r2,12(r2)
 909a334:	11000404 	addi	r4,r2,16
 909a338:	e0bffe17 	ldw	r2,-8(fp)
 909a33c:	10800317 	ldw	r2,12(r2)
 909a340:	10800404 	addi	r2,r2,16
 909a344:	10c00037 	ldwio	r3,0(r2)
 909a348:	00bff7c4 	movi	r2,-33
 909a34c:	1886703a 	and	r3,r3,r2
 909a350:	2005883a 	mov	r2,r4
 909a354:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 909a358:	e0bffe17 	ldw	r2,-8(fp)
 909a35c:	10800317 	ldw	r2,12(r2)
 909a360:	1007883a 	mov	r3,r2
 909a364:	00803fc4 	movi	r2,255
 909a368:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 909a36c:	e0bffe17 	ldw	r2,-8(fp)
 909a370:	10800317 	ldw	r2,12(r2)
 909a374:	10800804 	addi	r2,r2,32
 909a378:	e0ffff17 	ldw	r3,-4(fp)
 909a37c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909a380:	e0bffe17 	ldw	r2,-8(fp)
 909a384:	10800317 	ldw	r2,12(r2)
 909a388:	11000404 	addi	r4,r2,16
 909a38c:	e0bffe17 	ldw	r2,-8(fp)
 909a390:	10800317 	ldw	r2,12(r2)
 909a394:	10800404 	addi	r2,r2,16
 909a398:	10800037 	ldwio	r2,0(r2)
 909a39c:	10c01814 	ori	r3,r2,96
 909a3a0:	2005883a 	mov	r2,r4
 909a3a4:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 909a3a8:	e0bffe17 	ldw	r2,-8(fp)
 909a3ac:	10800317 	ldw	r2,12(r2)
 909a3b0:	10800037 	ldwio	r2,0(r2)
 909a3b4:	1080040c 	andi	r2,r2,16
 909a3b8:	1004c03a 	cmpne	r2,r2,zero
 909a3bc:	103ffa1e 	bne	r2,zero,909a3a8 <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 909a3c0:	e0bffe17 	ldw	r2,-8(fp)
 909a3c4:	10800317 	ldw	r2,12(r2)
 909a3c8:	11000404 	addi	r4,r2,16
 909a3cc:	e0bffe17 	ldw	r2,-8(fp)
 909a3d0:	10800317 	ldw	r2,12(r2)
 909a3d4:	10800404 	addi	r2,r2,16
 909a3d8:	10c00037 	ldwio	r3,0(r2)
 909a3dc:	00bff7c4 	movi	r2,-33
 909a3e0:	1886703a 	and	r3,r3,r2
 909a3e4:	2005883a 	mov	r2,r4
 909a3e8:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 909a3ec:	e0bffe17 	ldw	r2,-8(fp)
 909a3f0:	10800317 	ldw	r2,12(r2)
 909a3f4:	10800037 	ldwio	r2,0(r2)
 909a3f8:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 909a3fc:	e0bffe17 	ldw	r2,-8(fp)
 909a400:	10800317 	ldw	r2,12(r2)
 909a404:	1007883a 	mov	r3,r2
 909a408:	00803fc4 	movi	r2,255
 909a40c:	18800035 	stwio	r2,0(r3)

  return status;
 909a410:	e0bffd03 	ldbu	r2,-12(fp)
}
 909a414:	e037883a 	mov	sp,fp
 909a418:	df000017 	ldw	fp,0(sp)
 909a41c:	dec00104 	addi	sp,sp,4
 909a420:	f800283a 	ret

0909a424 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 909a424:	defff404 	addi	sp,sp,-48
 909a428:	dfc00b15 	stw	ra,44(sp)
 909a42c:	df000a15 	stw	fp,40(sp)
 909a430:	df000a04 	addi	fp,sp,40
 909a434:	e13ffb15 	stw	r4,-20(fp)
 909a438:	e17ffc15 	stw	r5,-16(fp)
 909a43c:	e1bffd15 	stw	r6,-12(fp)
 909a440:	e1fffe15 	stw	r7,-8(fp)
 909a444:	e0800217 	ldw	r2,8(fp)
 909a448:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 909a44c:	e0bfff0b 	ldhu	r2,-4(fp)
 909a450:	d8800015 	stw	r2,0(sp)
 909a454:	e0800317 	ldw	r2,12(fp)
 909a458:	d8800115 	stw	r2,4(sp)
 909a45c:	e0800417 	ldw	r2,16(fp)
 909a460:	d8800215 	stw	r2,8(sp)
 909a464:	d8000315 	stw	zero,12(sp)
 909a468:	d8000415 	stw	zero,16(sp)
 909a46c:	e13ffb17 	ldw	r4,-20(fp)
 909a470:	e17ffc17 	ldw	r5,-16(fp)
 909a474:	e1bffd17 	ldw	r6,-12(fp)
 909a478:	e1fffe17 	ldw	r7,-8(fp)
 909a47c:	909a4940 	call	909a494 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 909a480:	e037883a 	mov	sp,fp
 909a484:	dfc00117 	ldw	ra,4(sp)
 909a488:	df000017 	ldw	fp,0(sp)
 909a48c:	dec00204 	addi	sp,sp,8
 909a490:	f800283a 	ret

0909a494 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 909a494:	defff204 	addi	sp,sp,-56
 909a498:	dfc00d15 	stw	ra,52(sp)
 909a49c:	df000c15 	stw	fp,48(sp)
 909a4a0:	df000c04 	addi	fp,sp,48
 909a4a4:	e13ffb15 	stw	r4,-20(fp)
 909a4a8:	e17ffc15 	stw	r5,-16(fp)
 909a4ac:	e1bffd15 	stw	r6,-12(fp)
 909a4b0:	e1fffe15 	stw	r7,-8(fp)
 909a4b4:	e0800217 	ldw	r2,8(fp)
 909a4b8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 909a4bc:	e0bfff0b 	ldhu	r2,-4(fp)
 909a4c0:	d8800015 	stw	r2,0(sp)
 909a4c4:	d8000115 	stw	zero,4(sp)
 909a4c8:	e0800317 	ldw	r2,12(fp)
 909a4cc:	d8800215 	stw	r2,8(sp)
 909a4d0:	e0800417 	ldw	r2,16(fp)
 909a4d4:	d8800315 	stw	r2,12(sp)
 909a4d8:	e0800517 	ldw	r2,20(fp)
 909a4dc:	d8800415 	stw	r2,16(sp)
 909a4e0:	e0800617 	ldw	r2,24(fp)
 909a4e4:	d8800515 	stw	r2,20(sp)
 909a4e8:	d8000615 	stw	zero,24(sp)
 909a4ec:	e13ffb17 	ldw	r4,-20(fp)
 909a4f0:	e17ffc17 	ldw	r5,-16(fp)
 909a4f4:	e1bffd17 	ldw	r6,-12(fp)
 909a4f8:	e1fffe17 	ldw	r7,-8(fp)
 909a4fc:	909aa540 	call	909aa54 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 909a500:	e037883a 	mov	sp,fp
 909a504:	dfc00117 	ldw	ra,4(sp)
 909a508:	df000017 	ldw	fp,0(sp)
 909a50c:	dec00204 	addi	sp,sp,8
 909a510:	f800283a 	ret

0909a514 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 909a514:	defff804 	addi	sp,sp,-32
 909a518:	dfc00715 	stw	ra,28(sp)
 909a51c:	df000615 	stw	fp,24(sp)
 909a520:	df000604 	addi	fp,sp,24
 909a524:	e13ffc15 	stw	r4,-16(fp)
 909a528:	e17ffd15 	stw	r5,-12(fp)
 909a52c:	e1bffe15 	stw	r6,-8(fp)
 909a530:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 909a534:	e1ffff0b 	ldhu	r7,-4(fp)
 909a538:	e0800217 	ldw	r2,8(fp)
 909a53c:	d8800015 	stw	r2,0(sp)
 909a540:	d8000115 	stw	zero,4(sp)
 909a544:	e13ffc17 	ldw	r4,-16(fp)
 909a548:	e17ffd17 	ldw	r5,-12(fp)
 909a54c:	e1bffe17 	ldw	r6,-8(fp)
 909a550:	909a5680 	call	909a568 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 909a554:	e037883a 	mov	sp,fp
 909a558:	dfc00117 	ldw	ra,4(sp)
 909a55c:	df000017 	ldw	fp,0(sp)
 909a560:	dec00204 	addi	sp,sp,8
 909a564:	f800283a 	ret

0909a568 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 909a568:	defff304 	addi	sp,sp,-52
 909a56c:	dfc00c15 	stw	ra,48(sp)
 909a570:	df000b15 	stw	fp,44(sp)
 909a574:	df000b04 	addi	fp,sp,44
 909a578:	e13ffc15 	stw	r4,-16(fp)
 909a57c:	e17ffd15 	stw	r5,-12(fp)
 909a580:	e1bffe15 	stw	r6,-8(fp)
 909a584:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 909a588:	e0bfff0b 	ldhu	r2,-4(fp)
 909a58c:	d8800015 	stw	r2,0(sp)
 909a590:	d8000115 	stw	zero,4(sp)
 909a594:	d8000215 	stw	zero,8(sp)
 909a598:	e0800217 	ldw	r2,8(fp)
 909a59c:	d8800315 	stw	r2,12(sp)
 909a5a0:	d8000415 	stw	zero,16(sp)
 909a5a4:	e0800317 	ldw	r2,12(fp)
 909a5a8:	d8800515 	stw	r2,20(sp)
 909a5ac:	d8000615 	stw	zero,24(sp)
 909a5b0:	e13ffc17 	ldw	r4,-16(fp)
 909a5b4:	e17ffd17 	ldw	r5,-12(fp)
 909a5b8:	000d883a 	mov	r6,zero
 909a5bc:	e1fffe17 	ldw	r7,-8(fp)
 909a5c0:	909aa540 	call	909aa54 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 909a5c4:	e037883a 	mov	sp,fp
 909a5c8:	dfc00117 	ldw	ra,4(sp)
 909a5cc:	df000017 	ldw	fp,0(sp)
 909a5d0:	dec00204 	addi	sp,sp,8
 909a5d4:	f800283a 	ret

0909a5d8 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 909a5d8:	defff404 	addi	sp,sp,-48
 909a5dc:	dfc00b15 	stw	ra,44(sp)
 909a5e0:	df000a15 	stw	fp,40(sp)
 909a5e4:	df000a04 	addi	fp,sp,40
 909a5e8:	e13ffb15 	stw	r4,-20(fp)
 909a5ec:	e17ffc15 	stw	r5,-16(fp)
 909a5f0:	e1bffd15 	stw	r6,-12(fp)
 909a5f4:	e0800517 	ldw	r2,20(fp)
 909a5f8:	e1fffe0d 	sth	r7,-8(fp)
 909a5fc:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 909a600:	e1fffe0b 	ldhu	r7,-8(fp)
 909a604:	e0ffff03 	ldbu	r3,-4(fp)
 909a608:	e0800217 	ldw	r2,8(fp)
 909a60c:	d8800015 	stw	r2,0(sp)
 909a610:	e0800317 	ldw	r2,12(fp)
 909a614:	d8800115 	stw	r2,4(sp)
 909a618:	e0800417 	ldw	r2,16(fp)
 909a61c:	d8800215 	stw	r2,8(sp)
 909a620:	d8000315 	stw	zero,12(sp)
 909a624:	d8c00415 	stw	r3,16(sp)
 909a628:	e13ffb17 	ldw	r4,-20(fp)
 909a62c:	e17ffc17 	ldw	r5,-16(fp)
 909a630:	e1bffd17 	ldw	r6,-12(fp)
 909a634:	909a64c0 	call	909a64c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 909a638:	e037883a 	mov	sp,fp
 909a63c:	dfc00117 	ldw	ra,4(sp)
 909a640:	df000017 	ldw	fp,0(sp)
 909a644:	dec00204 	addi	sp,sp,8
 909a648:	f800283a 	ret

0909a64c <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 909a64c:	defff204 	addi	sp,sp,-56
 909a650:	dfc00d15 	stw	ra,52(sp)
 909a654:	df000c15 	stw	fp,48(sp)
 909a658:	df000c04 	addi	fp,sp,48
 909a65c:	e13ffb15 	stw	r4,-20(fp)
 909a660:	e17ffc15 	stw	r5,-16(fp)
 909a664:	e1bffd15 	stw	r6,-12(fp)
 909a668:	e0800617 	ldw	r2,24(fp)
 909a66c:	e1fffe0d 	sth	r7,-8(fp)
 909a670:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 909a674:	e0bffe0b 	ldhu	r2,-8(fp)
 909a678:	e0ffff03 	ldbu	r3,-4(fp)
 909a67c:	d8800015 	stw	r2,0(sp)
 909a680:	e0800417 	ldw	r2,16(fp)
 909a684:	d8800115 	stw	r2,4(sp)
 909a688:	e0800217 	ldw	r2,8(fp)
 909a68c:	d8800215 	stw	r2,8(sp)
 909a690:	e0800317 	ldw	r2,12(fp)
 909a694:	d8800315 	stw	r2,12(sp)
 909a698:	e0800517 	ldw	r2,20(fp)
 909a69c:	d8800415 	stw	r2,16(sp)
 909a6a0:	d8000515 	stw	zero,20(sp)
 909a6a4:	d8c00615 	stw	r3,24(sp)
 909a6a8:	e13ffb17 	ldw	r4,-20(fp)
 909a6ac:	e17ffc17 	ldw	r5,-16(fp)
 909a6b0:	e1bffd17 	ldw	r6,-12(fp)
 909a6b4:	000f883a 	mov	r7,zero
 909a6b8:	909aa540 	call	909aa54 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 909a6bc:	e037883a 	mov	sp,fp
 909a6c0:	dfc00117 	ldw	ra,4(sp)
 909a6c4:	df000017 	ldw	fp,0(sp)
 909a6c8:	dec00204 	addi	sp,sp,8
 909a6cc:	f800283a 	ret

0909a6d0 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 909a6d0:	defffb04 	addi	sp,sp,-20
 909a6d4:	df000415 	stw	fp,16(sp)
 909a6d8:	df000404 	addi	fp,sp,16
 909a6dc:	e13ffc15 	stw	r4,-16(fp)
 909a6e0:	e17ffd15 	stw	r5,-12(fp)
 909a6e4:	e1bffe15 	stw	r6,-8(fp)
 909a6e8:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 909a6ec:	e0fffc17 	ldw	r3,-16(fp)
 909a6f0:	e0bffd17 	ldw	r2,-12(fp)
 909a6f4:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
 909a6f8:	e0fffc17 	ldw	r3,-16(fp)
 909a6fc:	e0bfff17 	ldw	r2,-4(fp)
 909a700:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
 909a704:	e0fffc17 	ldw	r3,-16(fp)
 909a708:	e0bffe17 	ldw	r2,-8(fp)
 909a70c:	18800b15 	stw	r2,44(r3)
}
 909a710:	e037883a 	mov	sp,fp
 909a714:	df000017 	ldw	fp,0(sp)
 909a718:	dec00104 	addi	sp,sp,4
 909a71c:	f800283a 	ret

0909a720 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 909a720:	defffd04 	addi	sp,sp,-12
 909a724:	df000215 	stw	fp,8(sp)
 909a728:	df000204 	addi	fp,sp,8
 909a72c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909a730:	e0bfff17 	ldw	r2,-4(fp)
 909a734:	10800317 	ldw	r2,12(r2)
 909a738:	10800404 	addi	r2,r2,16
 909a73c:	10800037 	ldwio	r2,0(r2)
 909a740:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 909a744:	e0bffe17 	ldw	r2,-8(fp)
 909a748:	10800814 	ori	r2,r2,32
 909a74c:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909a750:	e0bfff17 	ldw	r2,-4(fp)
 909a754:	10800317 	ldw	r2,12(r2)
 909a758:	10800404 	addi	r2,r2,16
 909a75c:	e0fffe17 	ldw	r3,-8(fp)
 909a760:	10c00035 	stwio	r3,0(r2)
}
 909a764:	e037883a 	mov	sp,fp
 909a768:	df000017 	ldw	fp,0(sp)
 909a76c:	dec00104 	addi	sp,sp,4
 909a770:	f800283a 	ret

0909a774 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 909a774:	defffd04 	addi	sp,sp,-12
 909a778:	df000215 	stw	fp,8(sp)
 909a77c:	df000204 	addi	fp,sp,8
 909a780:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909a784:	e0bfff17 	ldw	r2,-4(fp)
 909a788:	10800317 	ldw	r2,12(r2)
 909a78c:	10800404 	addi	r2,r2,16
 909a790:	10800037 	ldwio	r2,0(r2)
 909a794:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 909a798:	e0fffe17 	ldw	r3,-8(fp)
 909a79c:	00bff7c4 	movi	r2,-33
 909a7a0:	1884703a 	and	r2,r3,r2
 909a7a4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909a7a8:	e0bfff17 	ldw	r2,-4(fp)
 909a7ac:	10800317 	ldw	r2,12(r2)
 909a7b0:	10800404 	addi	r2,r2,16
 909a7b4:	e0fffe17 	ldw	r3,-8(fp)
 909a7b8:	10c00035 	stwio	r3,0(r2)
}
 909a7bc:	e037883a 	mov	sp,fp
 909a7c0:	df000017 	ldw	fp,0(sp)
 909a7c4:	dec00104 	addi	sp,sp,4
 909a7c8:	f800283a 	ret

0909a7cc <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 909a7cc:	defffd04 	addi	sp,sp,-12
 909a7d0:	df000215 	stw	fp,8(sp)
 909a7d4:	df000204 	addi	fp,sp,8
 909a7d8:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 909a7dc:	e0bffe17 	ldw	r2,-8(fp)
 909a7e0:	10800784 	addi	r2,r2,30
 909a7e4:	10800023 	ldbuio	r2,0(r2)
 909a7e8:	10801fcc 	andi	r2,r2,127
 909a7ec:	1005003a 	cmpeq	r2,r2,zero
 909a7f0:	1000031e 	bne	r2,zero,909a800 <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 909a7f4:	00bffec4 	movi	r2,-5
 909a7f8:	e0bfff15 	stw	r2,-4(fp)
 909a7fc:	00000a06 	br	909a828 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 909a800:	e0bffe17 	ldw	r2,-8(fp)
 909a804:	108007c4 	addi	r2,r2,31
 909a808:	10800023 	ldbuio	r2,0(r2)
 909a80c:	1080200c 	andi	r2,r2,128
 909a810:	1005003a 	cmpeq	r2,r2,zero
 909a814:	1000031e 	bne	r2,zero,909a824 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 909a818:	00bfe244 	movi	r2,-119
 909a81c:	e0bfff15 	stw	r2,-4(fp)
 909a820:	00000106 	br	909a828 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
 909a824:	e03fff15 	stw	zero,-4(fp)
 909a828:	e0bfff17 	ldw	r2,-4(fp)
}
 909a82c:	e037883a 	mov	sp,fp
 909a830:	df000017 	ldw	fp,0(sp)
 909a834:	dec00104 	addi	sp,sp,4
 909a838:	f800283a 	ret

0909a83c <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 909a83c:	defffc04 	addi	sp,sp,-16
 909a840:	dfc00315 	stw	ra,12(sp)
 909a844:	df000215 	stw	fp,8(sp)
 909a848:	df000204 	addi	fp,sp,8
 909a84c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 909a850:	e13fff17 	ldw	r4,-4(fp)
 909a854:	d1602904 	addi	r5,gp,-32604
 909a858:	90b9df40 	call	90b9df4 <alt_find_dev>
 909a85c:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 909a860:	e0bffe17 	ldw	r2,-8(fp)
 909a864:	1004c03a 	cmpne	r2,r2,zero
 909a868:	1000041e 	bne	r2,zero,909a87c <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
 909a86c:	909a8940 	call	909a894 <alt_get_errno>
 909a870:	1007883a 	mov	r3,r2
 909a874:	008004c4 	movi	r2,19
 909a878:	18800015 	stw	r2,0(r3)
  }

  return dev;
 909a87c:	e0bffe17 	ldw	r2,-8(fp)
}
 909a880:	e037883a 	mov	sp,fp
 909a884:	dfc00117 	ldw	ra,4(sp)
 909a888:	df000017 	ldw	fp,0(sp)
 909a88c:	dec00204 	addi	sp,sp,8
 909a890:	f800283a 	ret

0909a894 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 909a894:	defffd04 	addi	sp,sp,-12
 909a898:	dfc00215 	stw	ra,8(sp)
 909a89c:	df000115 	stw	fp,4(sp)
 909a8a0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 909a8a4:	00824374 	movhi	r2,2317
 909a8a8:	108eca04 	addi	r2,r2,15144
 909a8ac:	10800017 	ldw	r2,0(r2)
 909a8b0:	1005003a 	cmpeq	r2,r2,zero
 909a8b4:	1000061e 	bne	r2,zero,909a8d0 <alt_get_errno+0x3c>
 909a8b8:	00824374 	movhi	r2,2317
 909a8bc:	108eca04 	addi	r2,r2,15144
 909a8c0:	10800017 	ldw	r2,0(r2)
 909a8c4:	103ee83a 	callr	r2
 909a8c8:	e0bfff15 	stw	r2,-4(fp)
 909a8cc:	00000306 	br	909a8dc <alt_get_errno+0x48>
 909a8d0:	00824374 	movhi	r2,2317
 909a8d4:	108ee904 	addi	r2,r2,15268
 909a8d8:	e0bfff15 	stw	r2,-4(fp)
 909a8dc:	e0bfff17 	ldw	r2,-4(fp)
}
 909a8e0:	e037883a 	mov	sp,fp
 909a8e4:	dfc00117 	ldw	ra,4(sp)
 909a8e8:	df000017 	ldw	fp,0(sp)
 909a8ec:	dec00204 	addi	sp,sp,8
 909a8f0:	f800283a 	ret

0909a8f4 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 909a8f4:	defff104 	addi	sp,sp,-60
 909a8f8:	dfc00e15 	stw	ra,56(sp)
 909a8fc:	df000d15 	stw	fp,52(sp)
 909a900:	df000d04 	addi	fp,sp,52
 909a904:	e13ffa15 	stw	r4,-24(fp)
 909a908:	e17ffb15 	stw	r5,-20(fp)
 909a90c:	e1bffc15 	stw	r6,-16(fp)
 909a910:	e1fffd15 	stw	r7,-12(fp)
 909a914:	e0800217 	ldw	r2,8(fp)
 909a918:	e0c00617 	ldw	r3,24(fp)
 909a91c:	e0bffe0d 	sth	r2,-8(fp)
 909a920:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 909a924:	e0bffe0b 	ldhu	r2,-8(fp)
 909a928:	e0ffff03 	ldbu	r3,-4(fp)
 909a92c:	d8800015 	stw	r2,0(sp)
 909a930:	e0800317 	ldw	r2,12(fp)
 909a934:	d8800115 	stw	r2,4(sp)
 909a938:	e0800417 	ldw	r2,16(fp)
 909a93c:	d8800215 	stw	r2,8(sp)
 909a940:	e0800517 	ldw	r2,20(fp)
 909a944:	d8800315 	stw	r2,12(sp)
 909a948:	d8000415 	stw	zero,16(sp)
 909a94c:	d8000515 	stw	zero,20(sp)
 909a950:	d8c00615 	stw	r3,24(sp)
 909a954:	e13ffa17 	ldw	r4,-24(fp)
 909a958:	e17ffb17 	ldw	r5,-20(fp)
 909a95c:	e1bffc17 	ldw	r6,-16(fp)
 909a960:	e1fffd17 	ldw	r7,-12(fp)
 909a964:	909aa540 	call	909aa54 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 909a968:	e037883a 	mov	sp,fp
 909a96c:	dfc00117 	ldw	ra,4(sp)
 909a970:	df000017 	ldw	fp,0(sp)
 909a974:	dec00204 	addi	sp,sp,8
 909a978:	f800283a 	ret

0909a97c <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 909a97c:	defffc04 	addi	sp,sp,-16
 909a980:	df000315 	stw	fp,12(sp)
 909a984:	df000304 	addi	fp,sp,12
 909a988:	e13ffe15 	stw	r4,-8(fp)
 909a98c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909a990:	e0bffe17 	ldw	r2,-8(fp)
 909a994:	10800317 	ldw	r2,12(r2)
 909a998:	10800404 	addi	r2,r2,16
 909a99c:	10800037 	ldwio	r2,0(r2)
 909a9a0:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 909a9a4:	e0fffd17 	ldw	r3,-12(fp)
 909a9a8:	00a00434 	movhi	r2,32784
 909a9ac:	10bfffc4 	addi	r2,r2,-1
 909a9b0:	1884703a 	and	r2,r3,r2
 909a9b4:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 909a9b8:	e0bfff17 	ldw	r2,-4(fp)
 909a9bc:	1004953a 	slli	r2,r2,20
 909a9c0:	10dffc2c 	andhi	r3,r2,32752
 909a9c4:	e0bffd17 	ldw	r2,-12(fp)
 909a9c8:	1884b03a 	or	r2,r3,r2
 909a9cc:	10800134 	orhi	r2,r2,4
 909a9d0:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909a9d4:	e0bffe17 	ldw	r2,-8(fp)
 909a9d8:	10800317 	ldw	r2,12(r2)
 909a9dc:	10800404 	addi	r2,r2,16
 909a9e0:	e0fffd17 	ldw	r3,-12(fp)
 909a9e4:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 909a9e8:	e037883a 	mov	sp,fp
 909a9ec:	df000017 	ldw	fp,0(sp)
 909a9f0:	dec00104 	addi	sp,sp,4
 909a9f4:	f800283a 	ret

0909a9f8 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 909a9f8:	defffd04 	addi	sp,sp,-12
 909a9fc:	df000215 	stw	fp,8(sp)
 909aa00:	df000204 	addi	fp,sp,8
 909aa04:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909aa08:	e0bfff17 	ldw	r2,-4(fp)
 909aa0c:	10800317 	ldw	r2,12(r2)
 909aa10:	10800404 	addi	r2,r2,16
 909aa14:	10800037 	ldwio	r2,0(r2)
 909aa18:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 909aa1c:	e0fffe17 	ldw	r3,-8(fp)
 909aa20:	00bfff34 	movhi	r2,65532
 909aa24:	10bfffc4 	addi	r2,r2,-1
 909aa28:	1884703a 	and	r2,r3,r2
 909aa2c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 909aa30:	e0bfff17 	ldw	r2,-4(fp)
 909aa34:	10800317 	ldw	r2,12(r2)
 909aa38:	10800404 	addi	r2,r2,16
 909aa3c:	e0fffe17 	ldw	r3,-8(fp)
 909aa40:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 909aa44:	e037883a 	mov	sp,fp
 909aa48:	df000017 	ldw	fp,0(sp)
 909aa4c:	dec00104 	addi	sp,sp,4
 909aa50:	f800283a 	ret

0909aa54 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 909aa54:	defff204 	addi	sp,sp,-56
 909aa58:	dfc00d15 	stw	ra,52(sp)
 909aa5c:	df000c15 	stw	fp,48(sp)
 909aa60:	df000c04 	addi	fp,sp,48
 909aa64:	e13ff415 	stw	r4,-48(fp)
 909aa68:	e17ff515 	stw	r5,-44(fp)
 909aa6c:	e1bff615 	stw	r6,-40(fp)
 909aa70:	e1fff715 	stw	r7,-36(fp)
 909aa74:	e0800217 	ldw	r2,8(fp)
 909aa78:	e0c00817 	ldw	r3,32(fp)
 909aa7c:	e0bff80d 	sth	r2,-32(fp)
 909aa80:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 909aa84:	e0bff517 	ldw	r2,-44(fp)
 909aa88:	110007c4 	addi	r4,r2,31
 909aa8c:	e0bff517 	ldw	r2,-44(fp)
 909aa90:	108007c3 	ldbu	r2,31(r2)
 909aa94:	10c03fcc 	andi	r3,r2,255
 909aa98:	00bfdfc4 	movi	r2,-129
 909aa9c:	1886703a 	and	r3,r3,r2
 909aaa0:	2005883a 	mov	r2,r4
 909aaa4:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 909aaa8:	e13ff417 	ldw	r4,-48(fp)
 909aaac:	e0bff617 	ldw	r2,-40(fp)
 909aab0:	11403fcc 	andi	r5,r2,255
 909aab4:	20800003 	ldbu	r2,0(r4)
 909aab8:	1004703a 	and	r2,r2,zero
 909aabc:	1007883a 	mov	r3,r2
 909aac0:	2805883a 	mov	r2,r5
 909aac4:	1884b03a 	or	r2,r3,r2
 909aac8:	20800005 	stb	r2,0(r4)
 909aacc:	e0bff617 	ldw	r2,-40(fp)
 909aad0:	1004d23a 	srli	r2,r2,8
 909aad4:	11403fcc 	andi	r5,r2,255
 909aad8:	20800043 	ldbu	r2,1(r4)
 909aadc:	1004703a 	and	r2,r2,zero
 909aae0:	1007883a 	mov	r3,r2
 909aae4:	2805883a 	mov	r2,r5
 909aae8:	1884b03a 	or	r2,r3,r2
 909aaec:	20800045 	stb	r2,1(r4)
 909aaf0:	e0bff617 	ldw	r2,-40(fp)
 909aaf4:	1004d43a 	srli	r2,r2,16
 909aaf8:	11403fcc 	andi	r5,r2,255
 909aafc:	20800083 	ldbu	r2,2(r4)
 909ab00:	1004703a 	and	r2,r2,zero
 909ab04:	1007883a 	mov	r3,r2
 909ab08:	2805883a 	mov	r2,r5
 909ab0c:	1884b03a 	or	r2,r3,r2
 909ab10:	20800085 	stb	r2,2(r4)
 909ab14:	e0bff617 	ldw	r2,-40(fp)
 909ab18:	100ad63a 	srli	r5,r2,24
 909ab1c:	208000c3 	ldbu	r2,3(r4)
 909ab20:	1004703a 	and	r2,r2,zero
 909ab24:	1007883a 	mov	r3,r2
 909ab28:	2805883a 	mov	r2,r5
 909ab2c:	1884b03a 	or	r2,r3,r2
 909ab30:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
 909ab34:	e13ff417 	ldw	r4,-48(fp)
 909ab38:	e0bff717 	ldw	r2,-36(fp)
 909ab3c:	11403fcc 	andi	r5,r2,255
 909ab40:	20800203 	ldbu	r2,8(r4)
 909ab44:	1004703a 	and	r2,r2,zero
 909ab48:	1007883a 	mov	r3,r2
 909ab4c:	2805883a 	mov	r2,r5
 909ab50:	1884b03a 	or	r2,r3,r2
 909ab54:	20800205 	stb	r2,8(r4)
 909ab58:	e0bff717 	ldw	r2,-36(fp)
 909ab5c:	1004d23a 	srli	r2,r2,8
 909ab60:	11403fcc 	andi	r5,r2,255
 909ab64:	20800243 	ldbu	r2,9(r4)
 909ab68:	1004703a 	and	r2,r2,zero
 909ab6c:	1007883a 	mov	r3,r2
 909ab70:	2805883a 	mov	r2,r5
 909ab74:	1884b03a 	or	r2,r3,r2
 909ab78:	20800245 	stb	r2,9(r4)
 909ab7c:	e0bff717 	ldw	r2,-36(fp)
 909ab80:	1004d43a 	srli	r2,r2,16
 909ab84:	11403fcc 	andi	r5,r2,255
 909ab88:	20800283 	ldbu	r2,10(r4)
 909ab8c:	1004703a 	and	r2,r2,zero
 909ab90:	1007883a 	mov	r3,r2
 909ab94:	2805883a 	mov	r2,r5
 909ab98:	1884b03a 	or	r2,r3,r2
 909ab9c:	20800285 	stb	r2,10(r4)
 909aba0:	e0bff717 	ldw	r2,-36(fp)
 909aba4:	100ad63a 	srli	r5,r2,24
 909aba8:	208002c3 	ldbu	r2,11(r4)
 909abac:	1004703a 	and	r2,r2,zero
 909abb0:	1007883a 	mov	r3,r2
 909abb4:	2805883a 	mov	r2,r5
 909abb8:	1884b03a 	or	r2,r3,r2
 909abbc:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
 909abc0:	e1bff517 	ldw	r6,-44(fp)
 909abc4:	e13ff417 	ldw	r4,-48(fp)
 909abc8:	31403fcc 	andi	r5,r6,255
 909abcc:	20800403 	ldbu	r2,16(r4)
 909abd0:	1004703a 	and	r2,r2,zero
 909abd4:	1007883a 	mov	r3,r2
 909abd8:	2805883a 	mov	r2,r5
 909abdc:	1884b03a 	or	r2,r3,r2
 909abe0:	20800405 	stb	r2,16(r4)
 909abe4:	3004d23a 	srli	r2,r6,8
 909abe8:	11403fcc 	andi	r5,r2,255
 909abec:	20800443 	ldbu	r2,17(r4)
 909abf0:	1004703a 	and	r2,r2,zero
 909abf4:	1007883a 	mov	r3,r2
 909abf8:	2805883a 	mov	r2,r5
 909abfc:	1884b03a 	or	r2,r3,r2
 909ac00:	20800445 	stb	r2,17(r4)
 909ac04:	3004d43a 	srli	r2,r6,16
 909ac08:	11403fcc 	andi	r5,r2,255
 909ac0c:	20800483 	ldbu	r2,18(r4)
 909ac10:	1004703a 	and	r2,r2,zero
 909ac14:	1007883a 	mov	r3,r2
 909ac18:	2805883a 	mov	r2,r5
 909ac1c:	1884b03a 	or	r2,r3,r2
 909ac20:	20800485 	stb	r2,18(r4)
 909ac24:	300ad63a 	srli	r5,r6,24
 909ac28:	208004c3 	ldbu	r2,19(r4)
 909ac2c:	1004703a 	and	r2,r2,zero
 909ac30:	1007883a 	mov	r3,r2
 909ac34:	2805883a 	mov	r2,r5
 909ac38:	1884b03a 	or	r2,r3,r2
 909ac3c:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
 909ac40:	e0fff417 	ldw	r3,-48(fp)
 909ac44:	18800103 	ldbu	r2,4(r3)
 909ac48:	1004703a 	and	r2,r2,zero
 909ac4c:	18800105 	stb	r2,4(r3)
 909ac50:	18800143 	ldbu	r2,5(r3)
 909ac54:	1004703a 	and	r2,r2,zero
 909ac58:	18800145 	stb	r2,5(r3)
 909ac5c:	18800183 	ldbu	r2,6(r3)
 909ac60:	1004703a 	and	r2,r2,zero
 909ac64:	18800185 	stb	r2,6(r3)
 909ac68:	188001c3 	ldbu	r2,7(r3)
 909ac6c:	1004703a 	and	r2,r2,zero
 909ac70:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
 909ac74:	e0fff417 	ldw	r3,-48(fp)
 909ac78:	18800303 	ldbu	r2,12(r3)
 909ac7c:	1004703a 	and	r2,r2,zero
 909ac80:	18800305 	stb	r2,12(r3)
 909ac84:	18800343 	ldbu	r2,13(r3)
 909ac88:	1004703a 	and	r2,r2,zero
 909ac8c:	18800345 	stb	r2,13(r3)
 909ac90:	18800383 	ldbu	r2,14(r3)
 909ac94:	1004703a 	and	r2,r2,zero
 909ac98:	18800385 	stb	r2,14(r3)
 909ac9c:	188003c3 	ldbu	r2,15(r3)
 909aca0:	1004703a 	and	r2,r2,zero
 909aca4:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
 909aca8:	e0fff417 	ldw	r3,-48(fp)
 909acac:	18800503 	ldbu	r2,20(r3)
 909acb0:	1004703a 	and	r2,r2,zero
 909acb4:	18800505 	stb	r2,20(r3)
 909acb8:	18800543 	ldbu	r2,21(r3)
 909acbc:	1004703a 	and	r2,r2,zero
 909acc0:	18800545 	stb	r2,21(r3)
 909acc4:	18800583 	ldbu	r2,22(r3)
 909acc8:	1004703a 	and	r2,r2,zero
 909accc:	18800585 	stb	r2,22(r3)
 909acd0:	188005c3 	ldbu	r2,23(r3)
 909acd4:	1004703a 	and	r2,r2,zero
 909acd8:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
 909acdc:	e13ff417 	ldw	r4,-48(fp)
 909ace0:	e0bff80b 	ldhu	r2,-32(fp)
 909ace4:	11403fcc 	andi	r5,r2,255
 909ace8:	20800603 	ldbu	r2,24(r4)
 909acec:	1004703a 	and	r2,r2,zero
 909acf0:	1007883a 	mov	r3,r2
 909acf4:	2805883a 	mov	r2,r5
 909acf8:	1884b03a 	or	r2,r3,r2
 909acfc:	20800605 	stb	r2,24(r4)
 909ad00:	e0bff80b 	ldhu	r2,-32(fp)
 909ad04:	1004d23a 	srli	r2,r2,8
 909ad08:	117fffcc 	andi	r5,r2,65535
 909ad0c:	20800643 	ldbu	r2,25(r4)
 909ad10:	1004703a 	and	r2,r2,zero
 909ad14:	1007883a 	mov	r3,r2
 909ad18:	2805883a 	mov	r2,r5
 909ad1c:	1884b03a 	or	r2,r3,r2
 909ad20:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
 909ad24:	e0fff417 	ldw	r3,-48(fp)
 909ad28:	18800703 	ldbu	r2,28(r3)
 909ad2c:	1004703a 	and	r2,r2,zero
 909ad30:	18800705 	stb	r2,28(r3)
 909ad34:	18800743 	ldbu	r2,29(r3)
 909ad38:	1004703a 	and	r2,r2,zero
 909ad3c:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
 909ad40:	e0bff417 	ldw	r2,-48(fp)
 909ad44:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 909ad48:	e0800617 	ldw	r2,24(fp)
 909ad4c:	1007883a 	mov	r3,r2
 909ad50:	e0bff417 	ldw	r2,-48(fp)
 909ad54:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 909ad58:	e0800717 	ldw	r2,28(fp)
 909ad5c:	1007883a 	mov	r3,r2
 909ad60:	e0bff417 	ldw	r2,-48(fp)
 909ad64:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 909ad68:	e0800317 	ldw	r2,12(fp)
 909ad6c:	1005003a 	cmpeq	r2,r2,zero
 909ad70:	1000031e 	bne	r2,zero,909ad80 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 909ad74:	00bfe044 	movi	r2,-127
 909ad78:	e0bfff05 	stb	r2,-4(fp)
 909ad7c:	00000206 	br	909ad88 <alt_avalon_sgdma_construct_descriptor_burst+0x334>
 909ad80:	00bfe004 	movi	r2,-128
 909ad84:	e0bfff05 	stb	r2,-4(fp)
 909ad88:	e0800417 	ldw	r2,16(fp)
 909ad8c:	1005003a 	cmpeq	r2,r2,zero
 909ad90:	1000031e 	bne	r2,zero,909ada0 <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
 909ad94:	00800084 	movi	r2,2
 909ad98:	e0bffe05 	stb	r2,-8(fp)
 909ad9c:	00000106 	br	909ada4 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
 909ada0:	e03ffe05 	stb	zero,-8(fp)
 909ada4:	e0ffff03 	ldbu	r3,-4(fp)
 909ada8:	e13ffe03 	ldbu	r4,-8(fp)
 909adac:	1904b03a 	or	r2,r3,r4
 909adb0:	e0bffd05 	stb	r2,-12(fp)
 909adb4:	e0800517 	ldw	r2,20(fp)
 909adb8:	1005003a 	cmpeq	r2,r2,zero
 909adbc:	1000031e 	bne	r2,zero,909adcc <alt_avalon_sgdma_construct_descriptor_burst+0x378>
 909adc0:	00800104 	movi	r2,4
 909adc4:	e0bffc05 	stb	r2,-16(fp)
 909adc8:	00000106 	br	909add0 <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
 909adcc:	e03ffc05 	stb	zero,-16(fp)
 909add0:	e0fffd03 	ldbu	r3,-12(fp)
 909add4:	e13ffc03 	ldbu	r4,-16(fp)
 909add8:	1904b03a 	or	r2,r3,r4
 909addc:	e0bffb05 	stb	r2,-20(fp)
 909ade0:	e0bff903 	ldbu	r2,-28(fp)
 909ade4:	1005003a 	cmpeq	r2,r2,zero
 909ade8:	1000051e 	bne	r2,zero,909ae00 <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
 909adec:	e0bff903 	ldbu	r2,-28(fp)
 909adf0:	108003cc 	andi	r2,r2,15
 909adf4:	100490fa 	slli	r2,r2,3
 909adf8:	e0bffa05 	stb	r2,-24(fp)
 909adfc:	00000106 	br	909ae04 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
 909ae00:	e03ffa05 	stb	zero,-24(fp)
 909ae04:	e0fffb03 	ldbu	r3,-20(fp)
 909ae08:	e13ffa03 	ldbu	r4,-24(fp)
 909ae0c:	1904b03a 	or	r2,r3,r4
 909ae10:	1007883a 	mov	r3,r2
 909ae14:	e0bff417 	ldw	r2,-48(fp)
 909ae18:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 909ae1c:	e13ff417 	ldw	r4,-48(fp)
 909ae20:	01400804 	movi	r5,32
 909ae24:	90ba83c0 	call	90ba83c <alt_remap_uncached>
}
 909ae28:	e037883a 	mov	sp,fp
 909ae2c:	dfc00117 	ldw	ra,4(sp)
 909ae30:	df000017 	ldw	fp,0(sp)
 909ae34:	dec00204 	addi	sp,sp,8
 909ae38:	f800283a 	ret

0909ae3c <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 909ae3c:	defff904 	addi	sp,sp,-28
 909ae40:	dfc00615 	stw	ra,24(sp)
 909ae44:	df000515 	stw	fp,20(sp)
 909ae48:	df000504 	addi	fp,sp,20
 909ae4c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 909ae50:	e0bfff17 	ldw	r2,-4(fp)
 909ae54:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 909ae58:	e0bffe17 	ldw	r2,-8(fp)
 909ae5c:	10800317 	ldw	r2,12(r2)
 909ae60:	11000404 	addi	r4,r2,16
 909ae64:	e0bffe17 	ldw	r2,-8(fp)
 909ae68:	10800317 	ldw	r2,12(r2)
 909ae6c:	10800404 	addi	r2,r2,16
 909ae70:	10800037 	ldwio	r2,0(r2)
 909ae74:	10a00034 	orhi	r2,r2,32768
 909ae78:	1007883a 	mov	r3,r2
 909ae7c:	2005883a 	mov	r2,r4
 909ae80:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 909ae84:	e0bffe17 	ldw	r2,-8(fp)
 909ae88:	10800317 	ldw	r2,12(r2)
 909ae8c:	10800404 	addi	r2,r2,16
 909ae90:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 909ae94:	e0bffe17 	ldw	r2,-8(fp)
 909ae98:	10800917 	ldw	r2,36(r2)
 909ae9c:	1005003a 	cmpeq	r2,r2,zero
 909aea0:	1000111e 	bne	r2,zero,909aee8 <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909aea4:	0005303a 	rdctl	r2,status
 909aea8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909aeac:	e0fffc17 	ldw	r3,-16(fp)
 909aeb0:	00bfff84 	movi	r2,-2
 909aeb4:	1884703a 	and	r2,r3,r2
 909aeb8:	1001703a 	wrctl	status,r2
  
  return context;
 909aebc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
 909aec0:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
 909aec4:	e0bffe17 	ldw	r2,-8(fp)
 909aec8:	10c00917 	ldw	r3,36(r2)
 909aecc:	e0bffe17 	ldw	r2,-8(fp)
 909aed0:	11000a17 	ldw	r4,40(r2)
 909aed4:	183ee83a 	callr	r3
 909aed8:	e0bffd17 	ldw	r2,-12(fp)
 909aedc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909aee0:	e0bffb17 	ldw	r2,-20(fp)
 909aee4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 909aee8:	e037883a 	mov	sp,fp
 909aeec:	dfc00117 	ldw	ra,4(sp)
 909aef0:	df000017 	ldw	fp,0(sp)
 909aef4:	dec00204 	addi	sp,sp,8
 909aef8:	f800283a 	ret

0909aefc <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 909aefc:	defffa04 	addi	sp,sp,-24
 909af00:	dfc00515 	stw	ra,20(sp)
 909af04:	df000415 	stw	fp,16(sp)
 909af08:	df000404 	addi	fp,sp,16
 909af0c:	e13ffd15 	stw	r4,-12(fp)
 909af10:	e17ffe15 	stw	r5,-8(fp)
 909af14:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909af18:	e0bffd17 	ldw	r2,-12(fp)
 909af1c:	10800317 	ldw	r2,12(r2)
 909af20:	10800404 	addi	r2,r2,16
 909af24:	1007883a 	mov	r3,r2
 909af28:	00800074 	movhi	r2,1
 909af2c:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 909af30:	e0bffd17 	ldw	r2,-12(fp)
 909af34:	10800317 	ldw	r2,12(r2)
 909af38:	10800404 	addi	r2,r2,16
 909af3c:	1007883a 	mov	r3,r2
 909af40:	00800074 	movhi	r2,1
 909af44:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 909af48:	e0bffd17 	ldw	r2,-12(fp)
 909af4c:	10800317 	ldw	r2,12(r2)
 909af50:	10800404 	addi	r2,r2,16
 909af54:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 909af58:	e0bffd17 	ldw	r2,-12(fp)
 909af5c:	10800317 	ldw	r2,12(r2)
 909af60:	1007883a 	mov	r3,r2
 909af64:	00803fc4 	movi	r2,255
 909af68:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 909af6c:	e13ffd17 	ldw	r4,-12(fp)
 909af70:	d1602904 	addi	r5,gp,-32604
 909af74:	90b9ce00 	call	90b9ce0 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 909af78:	d8000015 	stw	zero,0(sp)
 909af7c:	e13ffe17 	ldw	r4,-8(fp)
 909af80:	e17fff17 	ldw	r5,-4(fp)
 909af84:	018242b4 	movhi	r6,2314
 909af88:	31ab8f04 	addi	r6,r6,-20932
 909af8c:	e1fffd17 	ldw	r7,-12(fp)
 909af90:	90b9f580 	call	90b9f58 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 909af94:	e037883a 	mov	sp,fp
 909af98:	dfc00117 	ldw	ra,4(sp)
 909af9c:	df000017 	ldw	fp,0(sp)
 909afa0:	dec00204 	addi	sp,sp,8
 909afa4:	f800283a 	ret

0909afa8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 909afa8:	defffa04 	addi	sp,sp,-24
 909afac:	dfc00515 	stw	ra,20(sp)
 909afb0:	df000415 	stw	fp,16(sp)
 909afb4:	df000404 	addi	fp,sp,16
 909afb8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 909afbc:	e0bfff17 	ldw	r2,-4(fp)
 909afc0:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 909afc4:	e0bfff17 	ldw	r2,-4(fp)
 909afc8:	10800104 	addi	r2,r2,4
 909afcc:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 909afd0:	0005303a 	rdctl	r2,status
 909afd4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 909afd8:	e0fffd17 	ldw	r3,-12(fp)
 909afdc:	00bfff84 	movi	r2,-2
 909afe0:	1884703a 	and	r2,r3,r2
 909afe4:	1001703a 	wrctl	status,r2
  
  return context;
 909afe8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 909afec:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 909aff0:	90ba9140 	call	90ba914 <alt_tick>
 909aff4:	e0bffe17 	ldw	r2,-8(fp)
 909aff8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 909affc:	e0bffc17 	ldw	r2,-16(fp)
 909b000:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 909b004:	e037883a 	mov	sp,fp
 909b008:	dfc00117 	ldw	ra,4(sp)
 909b00c:	df000017 	ldw	fp,0(sp)
 909b010:	dec00204 	addi	sp,sp,8
 909b014:	f800283a 	ret

0909b018 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 909b018:	defff804 	addi	sp,sp,-32
 909b01c:	dfc00715 	stw	ra,28(sp)
 909b020:	df000615 	stw	fp,24(sp)
 909b024:	df000604 	addi	fp,sp,24
 909b028:	e13ffc15 	stw	r4,-16(fp)
 909b02c:	e17ffd15 	stw	r5,-12(fp)
 909b030:	e1bffe15 	stw	r6,-8(fp)
 909b034:	e1ffff15 	stw	r7,-4(fp)
 909b038:	e0bfff17 	ldw	r2,-4(fp)
 909b03c:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 909b040:	00824374 	movhi	r2,2317
 909b044:	108f3e04 	addi	r2,r2,15608
 909b048:	10800017 	ldw	r2,0(r2)
 909b04c:	1004c03a 	cmpne	r2,r2,zero
 909b050:	1000041e 	bne	r2,zero,909b064 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 909b054:	00c24374 	movhi	r3,2317
 909b058:	18cf3e04 	addi	r3,r3,15608
 909b05c:	e0bffb17 	ldw	r2,-20(fp)
 909b060:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 909b064:	e0bffc17 	ldw	r2,-16(fp)
 909b068:	10800104 	addi	r2,r2,4
 909b06c:	1007883a 	mov	r3,r2
 909b070:	008001c4 	movi	r2,7
 909b074:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 909b078:	d8000015 	stw	zero,0(sp)
 909b07c:	e13ffd17 	ldw	r4,-12(fp)
 909b080:	e17ffe17 	ldw	r5,-8(fp)
 909b084:	018242b4 	movhi	r6,2314
 909b088:	31abea04 	addi	r6,r6,-20568
 909b08c:	e1fffc17 	ldw	r7,-16(fp)
 909b090:	90b9f580 	call	90b9f58 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 909b094:	e037883a 	mov	sp,fp
 909b098:	dfc00117 	ldw	ra,4(sp)
 909b09c:	df000017 	ldw	fp,0(sp)
 909b0a0:	dec00204 	addi	sp,sp,8
 909b0a4:	f800283a 	ret

0909b0a8 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 909b0a8:	defffb04 	addi	sp,sp,-20
 909b0ac:	df000115 	stw	fp,4(sp)
 909b0b0:	df000104 	addi	fp,sp,4
 909b0b4:	e1400115 	stw	r5,4(fp)
 909b0b8:	e1800215 	stw	r6,8(fp)
 909b0bc:	e1c00315 	stw	r7,12(fp)
 909b0c0:	e13fff15 	stw	r4,-4(fp)
 909b0c4:	e037883a 	mov	sp,fp
 909b0c8:	df000017 	ldw	fp,0(sp)
 909b0cc:	dec00404 	addi	sp,sp,16
 909b0d0:	f800283a 	ret

0909b0d4 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 909b0d4:	defffb04 	addi	sp,sp,-20
 909b0d8:	df000415 	stw	fp,16(sp)
 909b0dc:	df000404 	addi	fp,sp,16
 909b0e0:	e13ffc15 	stw	r4,-16(fp)
 909b0e4:	e17ffd15 	stw	r5,-12(fp)
 909b0e8:	e1bffe15 	stw	r6,-8(fp)
 909b0ec:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 909b0f0:	e0fffd17 	ldw	r3,-12(fp)
 909b0f4:	e0bffc17 	ldw	r2,-16(fp)
 909b0f8:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 909b0fc:	e0fffe17 	ldw	r3,-8(fp)
 909b100:	e0bffc17 	ldw	r2,-16(fp)
 909b104:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 909b108:	e0ffff17 	ldw	r3,-4(fp)
 909b10c:	e0bffc17 	ldw	r2,-16(fp)
 909b110:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 909b114:	e0c00117 	ldw	r3,4(fp)
 909b118:	e0bffc17 	ldw	r2,-16(fp)
 909b11c:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 909b120:	0005883a 	mov	r2,zero
}
 909b124:	e037883a 	mov	sp,fp
 909b128:	df000017 	ldw	fp,0(sp)
 909b12c:	dec00104 	addi	sp,sp,4
 909b130:	f800283a 	ret

0909b134 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 909b134:	defff904 	addi	sp,sp,-28
 909b138:	dfc00615 	stw	ra,24(sp)
 909b13c:	df000515 	stw	fp,20(sp)
 909b140:	df000504 	addi	fp,sp,20
 909b144:	e13ffd15 	stw	r4,-12(fp)
 909b148:	e17ffe15 	stw	r5,-8(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 909b14c:	e03ffb85 	stb	zero,-18(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 909b150:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 909b154:	00000d06 	br	909b18c <tse_mac_sTxWrite+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 909b158:	e0bffc17 	ldw	r2,-16(fp)
 909b15c:	10800044 	addi	r2,r2,1
 909b160:	e0bffc15 	stw	r2,-16(fp)
 909b164:	e0fffc17 	ldw	r3,-16(fp)
 909b168:	008003f4 	movhi	r2,15
 909b16c:	10909044 	addi	r2,r2,16961
 909b170:	1880061e 	bne	r3,r2,909b18c <tse_mac_sTxWrite+0x58>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 909b174:	01024374 	movhi	r4,2317
 909b178:	21366f04 	addi	r4,r4,-9796
 909b17c:	90836b80 	call	90836b8 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 909b180:	00bffa84 	movi	r2,-22
 909b184:	e0bfff15 	stw	r2,-4(fp)
 909b188:	00002006 	br	909b20c <tse_mac_sTxWrite+0xd8>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 909b18c:	e0bffd17 	ldw	r2,-12(fp)
 909b190:	10800117 	ldw	r2,4(r2)
 909b194:	10800317 	ldw	r2,12(r2)
 909b198:	10800037 	ldwio	r2,0(r2)
 909b19c:	1080040c 	andi	r2,r2,16
 909b1a0:	1004c03a 	cmpne	r2,r2,zero
 909b1a4:	103fec1e 	bne	r2,zero,909b158 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 909b1a8:	e0bffd17 	ldw	r2,-12(fp)
 909b1ac:	10800117 	ldw	r2,4(r2)
 909b1b0:	10800317 	ldw	r2,12(r2)
 909b1b4:	10800404 	addi	r2,r2,16
 909b1b8:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 909b1bc:	e0bffd17 	ldw	r2,-12(fp)
 909b1c0:	10800117 	ldw	r2,4(r2)
 909b1c4:	10800317 	ldw	r2,12(r2)
 909b1c8:	1007883a 	mov	r3,r2
 909b1cc:	00803fc4 	movi	r2,255
 909b1d0:	18800035 	stwio	r2,0(r3)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 909b1d4:	e0bffd17 	ldw	r2,-12(fp)
 909b1d8:	11000117 	ldw	r4,4(r2)
 909b1dc:	e17ffe17 	ldw	r5,-8(fp)
 909b1e0:	909a3000 	call	909a300 <alt_avalon_sgdma_do_sync_transfer>
 909b1e4:	e0bffb85 	stb	r2,-18(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 909b1e8:	e0bffe17 	ldw	r2,-8(fp)
 909b1ec:	10800704 	addi	r2,r2,28
 909b1f0:	10800037 	ldwio	r2,0(r2)
 909b1f4:	1007883a 	mov	r3,r2
 909b1f8:	00bfffc4 	movi	r2,-1
 909b1fc:	1884703a 	and	r2,r3,r2
 909b200:	e0bffb0d 	sth	r2,-20(fp)

  return actualBytesTransferred;
 909b204:	e0bffb0b 	ldhu	r2,-20(fp)
 909b208:	e0bfff15 	stw	r2,-4(fp)
 909b20c:	e0bfff17 	ldw	r2,-4(fp)
}
 909b210:	e037883a 	mov	sp,fp
 909b214:	dfc00117 	ldw	ra,4(sp)
 909b218:	df000017 	ldw	fp,0(sp)
 909b21c:	dec00204 	addi	sp,sp,8
 909b220:	f800283a 	ret

0909b224 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 909b224:	defff904 	addi	sp,sp,-28
 909b228:	dfc00615 	stw	ra,24(sp)
 909b22c:	df000515 	stw	fp,20(sp)
 909b230:	df000504 	addi	fp,sp,20
 909b234:	e13ffd15 	stw	r4,-12(fp)
 909b238:	e17ffe15 	stw	r5,-8(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 909b23c:	e03ffb05 	stb	zero,-20(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 909b240:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 909b244:	00000d06 	br	909b27c <tse_mac_aRxRead+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 909b248:	e0bffc17 	ldw	r2,-16(fp)
 909b24c:	10800044 	addi	r2,r2,1
 909b250:	e0bffc15 	stw	r2,-16(fp)
 909b254:	e0fffc17 	ldw	r3,-16(fp)
 909b258:	008003f4 	movhi	r2,15
 909b25c:	10909044 	addi	r2,r2,16961
 909b260:	1880061e 	bne	r3,r2,909b27c <tse_mac_aRxRead+0x58>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 909b264:	01024374 	movhi	r4,2317
 909b268:	21367604 	addi	r4,r4,-9768
 909b26c:	90836b80 	call	90836b8 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 909b270:	00bffa84 	movi	r2,-22
 909b274:	e0bfff15 	stw	r2,-4(fp)
 909b278:	00000d06 	br	909b2b0 <tse_mac_aRxRead+0x8c>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 909b27c:	e0bffd17 	ldw	r2,-12(fp)
 909b280:	10800217 	ldw	r2,8(r2)
 909b284:	10800317 	ldw	r2,12(r2)
 909b288:	10800037 	ldwio	r2,0(r2)
 909b28c:	1080040c 	andi	r2,r2,16
 909b290:	1004c03a 	cmpne	r2,r2,zero
 909b294:	103fec1e 	bne	r2,zero,909b248 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 909b298:	e0bffd17 	ldw	r2,-12(fp)
 909b29c:	11000217 	ldw	r4,8(r2)
 909b2a0:	e17ffe17 	ldw	r5,-8(fp)
 909b2a4:	909a1c40 	call	909a1c4 <alt_avalon_sgdma_do_async_transfer>
 909b2a8:	e0bffb05 	stb	r2,-20(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
 909b2ac:	e03fff15 	stw	zero,-4(fp)
 909b2b0:	e0bfff17 	ldw	r2,-4(fp)
}
 909b2b4:	e037883a 	mov	sp,fp
 909b2b8:	dfc00117 	ldw	ra,4(sp)
 909b2bc:	df000017 	ldw	fp,0(sp)
 909b2c0:	dec00204 	addi	sp,sp,8
 909b2c4:	f800283a 	ret

0909b2c8 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 909b2c8:	defffc04 	addi	sp,sp,-16
 909b2cc:	df000315 	stw	fp,12(sp)
 909b2d0:	df000304 	addi	fp,sp,12
 909b2d4:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909b2d8:	e0bfff17 	ldw	r2,-4(fp)
 909b2dc:	10800204 	addi	r2,r2,8
 909b2e0:	10800037 	ldwio	r2,0(r2)
 909b2e4:	e0bffd15 	stw	r2,-12(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 909b2e8:	e0bfff17 	ldw	r2,-4(fp)
 909b2ec:	10800204 	addi	r2,r2,8
 909b2f0:	1007883a 	mov	r3,r2
 909b2f4:	00880204 	movi	r2,8200
 909b2f8:	18800035 	stwio	r2,0(r3)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 909b2fc:	e03ffe15 	stw	zero,-8(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 909b300:	00000306 	br	909b310 <tse_mac_SwReset+0x48>
 909b304:	e0bffe17 	ldw	r2,-8(fp)
 909b308:	10800044 	addi	r2,r2,1
 909b30c:	e0bffe15 	stw	r2,-8(fp)
 909b310:	e0bfff17 	ldw	r2,-4(fp)
 909b314:	10800204 	addi	r2,r2,8
 909b318:	10800037 	ldwio	r2,0(r2)
 909b31c:	1088000c 	andi	r2,r2,8192
 909b320:	1005003a 	cmpeq	r2,r2,zero
 909b324:	1000031e 	bne	r2,zero,909b334 <tse_mac_SwReset+0x6c>
 909b328:	e0bffe17 	ldw	r2,-8(fp)
 909b32c:	1089c410 	cmplti	r2,r2,10000
 909b330:	103ff41e 	bne	r2,zero,909b304 <tse_mac_SwReset+0x3c>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 909b334:	e0bfff17 	ldw	r2,-4(fp)
 909b338:	10800204 	addi	r2,r2,8
 909b33c:	1007883a 	mov	r3,r2
 909b340:	e0bffd17 	ldw	r2,-12(fp)
 909b344:	18800035 	stwio	r2,0(r3)
    return SUCCESS;
 909b348:	0005883a 	mov	r2,zero
}
 909b34c:	e037883a 	mov	sp,fp
 909b350:	df000017 	ldw	fp,0(sp)
 909b354:	dec00104 	addi	sp,sp,4
 909b358:	f800283a 	ret

0909b35c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 909b35c:	defffd04 	addi	sp,sp,-12
 909b360:	df000215 	stw	fp,8(sp)
 909b364:	df000204 	addi	fp,sp,8
 909b368:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909b36c:	e0bfff17 	ldw	r2,-4(fp)
 909b370:	10800204 	addi	r2,r2,8
 909b374:	10800037 	ldwio	r2,0(r2)
 909b378:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 909b37c:	e0fffe17 	ldw	r3,-8(fp)
 909b380:	00bffdc4 	movi	r2,-9
 909b384:	1884703a 	and	r2,r3,r2
 909b388:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 909b38c:	e0bfff17 	ldw	r2,-4(fp)
 909b390:	10800204 	addi	r2,r2,8
 909b394:	1007883a 	mov	r3,r2
 909b398:	e0bffe17 	ldw	r2,-8(fp)
 909b39c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909b3a0:	0005883a 	mov	r2,zero
}
 909b3a4:	e037883a 	mov	sp,fp
 909b3a8:	df000017 	ldw	fp,0(sp)
 909b3ac:	dec00104 	addi	sp,sp,4
 909b3b0:	f800283a 	ret

0909b3b4 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 909b3b4:	defffd04 	addi	sp,sp,-12
 909b3b8:	df000215 	stw	fp,8(sp)
 909b3bc:	df000204 	addi	fp,sp,8
 909b3c0:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909b3c4:	e0bfff17 	ldw	r2,-4(fp)
 909b3c8:	10800204 	addi	r2,r2,8
 909b3cc:	10800037 	ldwio	r2,0(r2)
 909b3d0:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909b3d4:	e0bffe17 	ldw	r2,-8(fp)
 909b3d8:	10800214 	ori	r2,r2,8
 909b3dc:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 909b3e0:	e0bfff17 	ldw	r2,-4(fp)
 909b3e4:	10800204 	addi	r2,r2,8
 909b3e8:	1007883a 	mov	r3,r2
 909b3ec:	e0bffe17 	ldw	r2,-8(fp)
 909b3f0:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909b3f4:	0005883a 	mov	r2,zero
}
 909b3f8:	e037883a 	mov	sp,fp
 909b3fc:	df000017 	ldw	fp,0(sp)
 909b400:	dec00104 	addi	sp,sp,4
 909b404:	f800283a 	ret

0909b408 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 909b408:	defffa04 	addi	sp,sp,-24
 909b40c:	dfc00515 	stw	ra,20(sp)
 909b410:	df000415 	stw	fp,16(sp)
 909b414:	dc000315 	stw	r16,12(sp)
 909b418:	df000304 	addi	fp,sp,12
 909b41c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 909b420:	e03ffd15 	stw	zero,-12(fp)
 909b424:	00002706 	br	909b4c4 <alt_tse_phy_add_profile+0xbc>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 909b428:	e0bffd17 	ldw	r2,-12(fp)
 909b42c:	00c243b4 	movhi	r3,2318
 909b430:	18f4c504 	addi	r3,r3,-11500
 909b434:	1085883a 	add	r2,r2,r2
 909b438:	1085883a 	add	r2,r2,r2
 909b43c:	10c5883a 	add	r2,r2,r3
 909b440:	10800017 	ldw	r2,0(r2)
 909b444:	10c01417 	ldw	r3,80(r2)
 909b448:	e0bffe17 	ldw	r2,-8(fp)
 909b44c:	10801417 	ldw	r2,80(r2)
 909b450:	1880191e 	bne	r3,r2,909b4b8 <alt_tse_phy_add_profile+0xb0>
 909b454:	e0bffd17 	ldw	r2,-12(fp)
 909b458:	00c243b4 	movhi	r3,2318
 909b45c:	18f4c504 	addi	r3,r3,-11500
 909b460:	1085883a 	add	r2,r2,r2
 909b464:	1085883a 	add	r2,r2,r2
 909b468:	10c5883a 	add	r2,r2,r3
 909b46c:	10800017 	ldw	r2,0(r2)
 909b470:	10c01503 	ldbu	r3,84(r2)
 909b474:	e0bffe17 	ldw	r2,-8(fp)
 909b478:	10801503 	ldbu	r2,84(r2)
 909b47c:	18c03fcc 	andi	r3,r3,255
 909b480:	10803fcc 	andi	r2,r2,255
 909b484:	18800c1e 	bne	r3,r2,909b4b8 <alt_tse_phy_add_profile+0xb0>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 909b488:	e0bffe17 	ldw	r2,-8(fp)
 909b48c:	10801417 	ldw	r2,80(r2)
 909b490:	100b883a 	mov	r5,r2
 909b494:	e0bffe17 	ldw	r2,-8(fp)
 909b498:	10801503 	ldbu	r2,84(r2)
 909b49c:	11803fcc 	andi	r6,r2,255
 909b4a0:	01024374 	movhi	r4,2317
 909b4a4:	21367d04 	addi	r4,r4,-9740
 909b4a8:	90833900 	call	9083390 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 909b4ac:	01024374 	movhi	r4,2317
 909b4b0:	21369104 	addi	r4,r4,-9660
 909b4b4:	90836b80 	call	90836b8 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 909b4b8:	e0bffd17 	ldw	r2,-12(fp)
 909b4bc:	10800044 	addi	r2,r2,1
 909b4c0:	e0bffd15 	stw	r2,-12(fp)
 909b4c4:	d0a08003 	ldbu	r2,-32256(gp)
 909b4c8:	10c03fcc 	andi	r3,r2,255
 909b4cc:	e0bffd17 	ldw	r2,-12(fp)
 909b4d0:	10ffd516 	blt	r2,r3,909b428 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 909b4d4:	d0a08003 	ldbu	r2,-32256(gp)
 909b4d8:	14003fcc 	andi	r16,r2,255
 909b4dc:	01001904 	movi	r4,100
 909b4e0:	90cb4400 	call	90cb440 <malloc>
 909b4e4:	1009883a 	mov	r4,r2
 909b4e8:	00c243b4 	movhi	r3,2318
 909b4ec:	18f4c504 	addi	r3,r3,-11500
 909b4f0:	8405883a 	add	r2,r16,r16
 909b4f4:	1085883a 	add	r2,r2,r2
 909b4f8:	10c5883a 	add	r2,r2,r3
 909b4fc:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 909b500:	d0a08003 	ldbu	r2,-32256(gp)
 909b504:	10803fcc 	andi	r2,r2,255
 909b508:	00c243b4 	movhi	r3,2318
 909b50c:	18f4c504 	addi	r3,r3,-11500
 909b510:	1085883a 	add	r2,r2,r2
 909b514:	1085883a 	add	r2,r2,r2
 909b518:	10c5883a 	add	r2,r2,r3
 909b51c:	10800017 	ldw	r2,0(r2)
 909b520:	1004c03a 	cmpne	r2,r2,zero
 909b524:	1000081e 	bne	r2,zero,909b548 <alt_tse_phy_add_profile+0x140>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 909b528:	d0a08003 	ldbu	r2,-32256(gp)
 909b52c:	11403fcc 	andi	r5,r2,255
 909b530:	01024374 	movhi	r4,2317
 909b534:	2136a904 	addi	r4,r4,-9564
 909b538:	90833900 	call	9083390 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 909b53c:	00bfffc4 	movi	r2,-1
 909b540:	e0bfff15 	stw	r2,-4(fp)
 909b544:	00001f06 	br	909b5c4 <alt_tse_phy_add_profile+0x1bc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 909b548:	d0a08003 	ldbu	r2,-32256(gp)
 909b54c:	10803fcc 	andi	r2,r2,255
 909b550:	00c243b4 	movhi	r3,2318
 909b554:	18f4c504 	addi	r3,r3,-11500
 909b558:	1085883a 	add	r2,r2,r2
 909b55c:	1085883a 	add	r2,r2,r2
 909b560:	10c5883a 	add	r2,r2,r3
 909b564:	10800017 	ldw	r2,0(r2)
 909b568:	e0fffe17 	ldw	r3,-8(fp)
 909b56c:	1009883a 	mov	r4,r2
 909b570:	180b883a 	mov	r5,r3
 909b574:	01801904 	movi	r6,100
 909b578:	90894600 	call	9089460 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 909b57c:	d0a08003 	ldbu	r2,-32256(gp)
 909b580:	10803fcc 	andi	r2,r2,255
 909b584:	00c243b4 	movhi	r3,2318
 909b588:	18f4c504 	addi	r3,r3,-11500
 909b58c:	1085883a 	add	r2,r2,r2
 909b590:	1085883a 	add	r2,r2,r2
 909b594:	10c5883a 	add	r2,r2,r3
 909b598:	10800017 	ldw	r2,0(r2)
 909b59c:	1009883a 	mov	r4,r2
 909b5a0:	e17ffe17 	ldw	r5,-8(fp)
 909b5a4:	90cb4c80 	call	90cb4c8 <strcpy>
    
    phy_profile_count++;
 909b5a8:	d0a08003 	ldbu	r2,-32256(gp)
 909b5ac:	10800044 	addi	r2,r2,1
 909b5b0:	d0a08005 	stb	r2,-32256(gp)
    
    return phy_profile_count - 1;
 909b5b4:	d0a08003 	ldbu	r2,-32256(gp)
 909b5b8:	10803fcc 	andi	r2,r2,255
 909b5bc:	10bfffc4 	addi	r2,r2,-1
 909b5c0:	e0bfff15 	stw	r2,-4(fp)
 909b5c4:	e0bfff17 	ldw	r2,-4(fp)
}
 909b5c8:	e037883a 	mov	sp,fp
 909b5cc:	dfc00217 	ldw	ra,8(sp)
 909b5d0:	df000117 	ldw	fp,4(sp)
 909b5d4:	dc000017 	ldw	r16,0(sp)
 909b5d8:	dec00304 	addi	sp,sp,12
 909b5dc:	f800283a 	ret

0909b5e0 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 909b5e0:	defff104 	addi	sp,sp,-60
 909b5e4:	dfc00e15 	stw	ra,56(sp)
 909b5e8:	df000d15 	stw	fp,52(sp)
 909b5ec:	dc000c15 	stw	r16,48(sp)
 909b5f0:	df000c04 	addi	fp,sp,48
 909b5f4:	e13ffb15 	stw	r4,-20(fp)
 909b5f8:	e17ffc15 	stw	r5,-16(fp)
 909b5fc:	e1bffd15 	stw	r6,-12(fp)
 909b600:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 909b604:	e0bffb17 	ldw	r2,-20(fp)
 909b608:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 909b60c:	e0bffc17 	ldw	r2,-16(fp)
 909b610:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 909b614:	e0bffd17 	ldw	r2,-12(fp)
 909b618:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 909b61c:	e0bffe17 	ldw	r2,-8(fp)
 909b620:	e0bff515 	stw	r2,-44(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 909b624:	e0800317 	ldw	r2,12(fp)
 909b628:	e0bff415 	stw	r2,-48(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 909b62c:	e0bff817 	ldw	r2,-32(fp)
 909b630:	10800303 	ldbu	r2,12(r2)
 909b634:	10803fcc 	andi	r2,r2,255
 909b638:	1004c03a 	cmpne	r2,r2,zero
 909b63c:	1000031e 	bne	r2,zero,909b64c <alt_tse_system_add_sys+0x6c>
		loop_end = 1;
 909b640:	00800044 	movi	r2,1
 909b644:	e0bff915 	stw	r2,-28(fp)
 909b648:	00001006 	br	909b68c <alt_tse_system_add_sys+0xac>
	}
	else if(pmac->tse_num_of_channel > 0) {
 909b64c:	e0bff817 	ldw	r2,-32(fp)
 909b650:	10800303 	ldbu	r2,12(r2)
 909b654:	10803fcc 	andi	r2,r2,255
 909b658:	1005003a 	cmpeq	r2,r2,zero
 909b65c:	1000051e 	bne	r2,zero,909b674 <alt_tse_system_add_sys+0x94>
		loop_end = pmac->tse_num_of_channel; 
 909b660:	e0bff817 	ldw	r2,-32(fp)
 909b664:	10800303 	ldbu	r2,12(r2)
 909b668:	10803fcc 	andi	r2,r2,255
 909b66c:	e0bff915 	stw	r2,-28(fp)
 909b670:	00000606 	br	909b68c <alt_tse_system_add_sys+0xac>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 909b674:	01024374 	movhi	r4,2317
 909b678:	2136b804 	addi	r4,r4,-9504
 909b67c:	90836b80 	call	90836b8 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909b680:	00bfffc4 	movi	r2,-1
 909b684:	e0bfff15 	stw	r2,-4(fp)
 909b688:	00025306 	br	909bfd8 <alt_tse_system_add_sys+0x9f8>
	}

	for(i = 0; i < loop_end; i++) {
 909b68c:	e03ffa15 	stw	zero,-24(fp)
 909b690:	00024d06 	br	909bfc8 <alt_tse_system_add_sys+0x9e8>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 909b694:	d0a08083 	ldbu	r2,-32254(gp)
 909b698:	10803fcc 	andi	r2,r2,255
 909b69c:	1080201c 	xori	r2,r2,128
 909b6a0:	10bfe004 	addi	r2,r2,-128
 909b6a4:	10800110 	cmplti	r2,r2,4
 909b6a8:	10000b1e 	bne	r2,zero,909b6d8 <alt_tse_system_add_sys+0xf8>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 909b6ac:	01024374 	movhi	r4,2317
 909b6b0:	2136c404 	addi	r4,r4,-9456
 909b6b4:	90836b80 	call	90836b8 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 909b6b8:	d0a08083 	ldbu	r2,-32254(gp)
 909b6bc:	11803fcc 	andi	r6,r2,255
 909b6c0:	3180201c 	xori	r6,r6,128
 909b6c4:	31bfe004 	addi	r6,r6,-128
 909b6c8:	01024374 	movhi	r4,2317
 909b6cc:	2136d404 	addi	r4,r4,-9392
 909b6d0:	01400104 	movi	r5,4
 909b6d4:	90833900 	call	9083390 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 909b6d8:	e0bff817 	ldw	r2,-32(fp)
 909b6dc:	1004c03a 	cmpne	r2,r2,zero
 909b6e0:	1000091e 	bne	r2,zero,909b708 <alt_tse_system_add_sys+0x128>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 909b6e4:	01024374 	movhi	r4,2317
 909b6e8:	2136e304 	addi	r4,r4,-9332
 909b6ec:	90836b80 	call	90836b8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 909b6f0:	01024374 	movhi	r4,2317
 909b6f4:	2136ed04 	addi	r4,r4,-9292
 909b6f8:	90836b80 	call	90836b8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909b6fc:	00bfffc4 	movi	r2,-1
 909b700:	e0bfff15 	stw	r2,-4(fp)
 909b704:	00023406 	br	909bfd8 <alt_tse_system_add_sys+0x9f8>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 909b708:	d0a08083 	ldbu	r2,-32254(gp)
 909b70c:	11403fcc 	andi	r5,r2,255
 909b710:	2940201c 	xori	r5,r5,128
 909b714:	297fe004 	addi	r5,r5,-128
 909b718:	e0bff817 	ldw	r2,-32(fp)
 909b71c:	10c00017 	ldw	r3,0(r2)
 909b720:	e0bffa17 	ldw	r2,-24(fp)
 909b724:	100492ba 	slli	r2,r2,10
 909b728:	1889883a 	add	r4,r3,r2
 909b72c:	00c24374 	movhi	r3,2317
 909b730:	18c69404 	addi	r3,r3,6736
 909b734:	28801224 	muli	r2,r5,72
 909b738:	10c5883a 	add	r2,r2,r3
 909b73c:	11000015 	stw	r4,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 909b740:	d0a08083 	ldbu	r2,-32254(gp)
 909b744:	11003fcc 	andi	r4,r2,255
 909b748:	2100201c 	xori	r4,r4,128
 909b74c:	213fe004 	addi	r4,r4,-128
 909b750:	e0bff817 	ldw	r2,-32(fp)
 909b754:	1140010b 	ldhu	r5,4(r2)
 909b758:	00c24374 	movhi	r3,2317
 909b75c:	18c69404 	addi	r3,r3,6736
 909b760:	20801224 	muli	r2,r4,72
 909b764:	10c5883a 	add	r2,r2,r3
 909b768:	10800104 	addi	r2,r2,4
 909b76c:	1140000d 	sth	r5,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 909b770:	d0a08083 	ldbu	r2,-32254(gp)
 909b774:	11003fcc 	andi	r4,r2,255
 909b778:	2100201c 	xori	r4,r4,128
 909b77c:	213fe004 	addi	r4,r4,-128
 909b780:	e0bff817 	ldw	r2,-32(fp)
 909b784:	1140018b 	ldhu	r5,6(r2)
 909b788:	00c24374 	movhi	r3,2317
 909b78c:	18c69404 	addi	r3,r3,6736
 909b790:	20801224 	muli	r2,r4,72
 909b794:	10c5883a 	add	r2,r2,r3
 909b798:	10800104 	addi	r2,r2,4
 909b79c:	1140008d 	sth	r5,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 909b7a0:	d0a08083 	ldbu	r2,-32254(gp)
 909b7a4:	11003fcc 	andi	r4,r2,255
 909b7a8:	2100201c 	xori	r4,r4,128
 909b7ac:	213fe004 	addi	r4,r4,-128
 909b7b0:	e0bff817 	ldw	r2,-32(fp)
 909b7b4:	11400203 	ldbu	r5,8(r2)
 909b7b8:	00c24374 	movhi	r3,2317
 909b7bc:	18c69404 	addi	r3,r3,6736
 909b7c0:	20801224 	muli	r2,r4,72
 909b7c4:	10c5883a 	add	r2,r2,r3
 909b7c8:	10800204 	addi	r2,r2,8
 909b7cc:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 909b7d0:	d0a08083 	ldbu	r2,-32254(gp)
 909b7d4:	11003fcc 	andi	r4,r2,255
 909b7d8:	2100201c 	xori	r4,r4,128
 909b7dc:	213fe004 	addi	r4,r4,-128
 909b7e0:	e0bff817 	ldw	r2,-32(fp)
 909b7e4:	11400243 	ldbu	r5,9(r2)
 909b7e8:	00c24374 	movhi	r3,2317
 909b7ec:	18c69404 	addi	r3,r3,6736
 909b7f0:	20801224 	muli	r2,r4,72
 909b7f4:	10c5883a 	add	r2,r2,r3
 909b7f8:	10800204 	addi	r2,r2,8
 909b7fc:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 909b800:	d0a08083 	ldbu	r2,-32254(gp)
 909b804:	11003fcc 	andi	r4,r2,255
 909b808:	2100201c 	xori	r4,r4,128
 909b80c:	213fe004 	addi	r4,r4,-128
 909b810:	e0bff817 	ldw	r2,-32(fp)
 909b814:	11400283 	ldbu	r5,10(r2)
 909b818:	00c24374 	movhi	r3,2317
 909b81c:	18c69404 	addi	r3,r3,6736
 909b820:	20801224 	muli	r2,r4,72
 909b824:	10c5883a 	add	r2,r2,r3
 909b828:	10800204 	addi	r2,r2,8
 909b82c:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 909b830:	d0a08083 	ldbu	r2,-32254(gp)
 909b834:	11003fcc 	andi	r4,r2,255
 909b838:	2100201c 	xori	r4,r4,128
 909b83c:	213fe004 	addi	r4,r4,-128
 909b840:	e0bff817 	ldw	r2,-32(fp)
 909b844:	114002c3 	ldbu	r5,11(r2)
 909b848:	00c24374 	movhi	r3,2317
 909b84c:	18c69404 	addi	r3,r3,6736
 909b850:	20801224 	muli	r2,r4,72
 909b854:	10c5883a 	add	r2,r2,r3
 909b858:	10800204 	addi	r2,r2,8
 909b85c:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 909b860:	d0a08083 	ldbu	r2,-32254(gp)
 909b864:	11003fcc 	andi	r4,r2,255
 909b868:	2100201c 	xori	r4,r4,128
 909b86c:	213fe004 	addi	r4,r4,-128
 909b870:	e0bff817 	ldw	r2,-32(fp)
 909b874:	11400303 	ldbu	r5,12(r2)
 909b878:	00c24374 	movhi	r3,2317
 909b87c:	18c69404 	addi	r3,r3,6736
 909b880:	20801224 	muli	r2,r4,72
 909b884:	10c5883a 	add	r2,r2,r3
 909b888:	10800304 	addi	r2,r2,12
 909b88c:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 909b890:	d0a08083 	ldbu	r2,-32254(gp)
 909b894:	11003fcc 	andi	r4,r2,255
 909b898:	2100201c 	xori	r4,r4,128
 909b89c:	213fe004 	addi	r4,r4,-128
 909b8a0:	e0bff817 	ldw	r2,-32(fp)
 909b8a4:	11400343 	ldbu	r5,13(r2)
 909b8a8:	00c24374 	movhi	r3,2317
 909b8ac:	18c69404 	addi	r3,r3,6736
 909b8b0:	20801224 	muli	r2,r4,72
 909b8b4:	10c5883a 	add	r2,r2,r3
 909b8b8:	10800304 	addi	r2,r2,12
 909b8bc:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 909b8c0:	d0a08083 	ldbu	r2,-32254(gp)
 909b8c4:	11003fcc 	andi	r4,r2,255
 909b8c8:	2100201c 	xori	r4,r4,128
 909b8cc:	213fe004 	addi	r4,r4,-128
 909b8d0:	e0bff817 	ldw	r2,-32(fp)
 909b8d4:	11400383 	ldbu	r5,14(r2)
 909b8d8:	00c24374 	movhi	r3,2317
 909b8dc:	18c69404 	addi	r3,r3,6736
 909b8e0:	20801224 	muli	r2,r4,72
 909b8e4:	10c5883a 	add	r2,r2,r3
 909b8e8:	10800304 	addi	r2,r2,12
 909b8ec:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 909b8f0:	d0a08083 	ldbu	r2,-32254(gp)
 909b8f4:	11003fcc 	andi	r4,r2,255
 909b8f8:	2100201c 	xori	r4,r4,128
 909b8fc:	213fe004 	addi	r4,r4,-128
 909b900:	e0bff817 	ldw	r2,-32(fp)
 909b904:	114003c3 	ldbu	r5,15(r2)
 909b908:	00c24374 	movhi	r3,2317
 909b90c:	18c69404 	addi	r3,r3,6736
 909b910:	20801224 	muli	r2,r4,72
 909b914:	10c5883a 	add	r2,r2,r3
 909b918:	10800304 	addi	r2,r2,12
 909b91c:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 909b920:	d0a08083 	ldbu	r2,-32254(gp)
 909b924:	11003fcc 	andi	r4,r2,255
 909b928:	2100201c 	xori	r4,r4,128
 909b92c:	213fe004 	addi	r4,r4,-128
 909b930:	e0bff817 	ldw	r2,-32(fp)
 909b934:	11400403 	ldbu	r5,16(r2)
 909b938:	00c24374 	movhi	r3,2317
 909b93c:	18c69404 	addi	r3,r3,6736
 909b940:	20801224 	muli	r2,r4,72
 909b944:	10c5883a 	add	r2,r2,r3
 909b948:	10800404 	addi	r2,r2,16
 909b94c:	11400005 	stb	r5,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 909b950:	e0bff717 	ldw	r2,-36(fp)
 909b954:	1004c03a 	cmpne	r2,r2,zero
 909b958:	10000d1e 	bne	r2,zero,909b990 <alt_tse_system_add_sys+0x3b0>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 909b95c:	01024374 	movhi	r4,2317
 909b960:	2136ff04 	addi	r4,r4,-9220
 909b964:	90836b80 	call	90836b8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 909b968:	d0a08083 	ldbu	r2,-32254(gp)
 909b96c:	11403fcc 	andi	r5,r2,255
 909b970:	2940201c 	xori	r5,r5,128
 909b974:	297fe004 	addi	r5,r5,-128
 909b978:	01024374 	movhi	r4,2317
 909b97c:	21370a04 	addi	r4,r4,-9176
 909b980:	90833900 	call	9083390 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909b984:	00bfffc4 	movi	r2,-1
 909b988:	e0bfff15 	stw	r2,-4(fp)
 909b98c:	00019206 	br	909bfd8 <alt_tse_system_add_sys+0x9f8>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 909b990:	d0a08083 	ldbu	r2,-32254(gp)
 909b994:	14003fcc 	andi	r16,r2,255
 909b998:	8400201c 	xori	r16,r16,128
 909b99c:	843fe004 	addi	r16,r16,-128
 909b9a0:	e0bff717 	ldw	r2,-36(fp)
 909b9a4:	11000017 	ldw	r4,0(r2)
 909b9a8:	9083f540 	call	9083f54 <strlen>
 909b9ac:	11000044 	addi	r4,r2,1
 909b9b0:	90cb4400 	call	90cb440 <malloc>
 909b9b4:	1009883a 	mov	r4,r2
 909b9b8:	00c24374 	movhi	r3,2317
 909b9bc:	18c69404 	addi	r3,r3,6736
 909b9c0:	80801224 	muli	r2,r16,72
 909b9c4:	10c5883a 	add	r2,r2,r3
 909b9c8:	10800504 	addi	r2,r2,20
 909b9cc:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 909b9d0:	d0a08083 	ldbu	r2,-32254(gp)
 909b9d4:	10803fcc 	andi	r2,r2,255
 909b9d8:	1080201c 	xori	r2,r2,128
 909b9dc:	10bfe004 	addi	r2,r2,-128
 909b9e0:	00c24374 	movhi	r3,2317
 909b9e4:	18c69404 	addi	r3,r3,6736
 909b9e8:	10801224 	muli	r2,r2,72
 909b9ec:	10c5883a 	add	r2,r2,r3
 909b9f0:	10800504 	addi	r2,r2,20
 909b9f4:	10800017 	ldw	r2,0(r2)
 909b9f8:	1004c03a 	cmpne	r2,r2,zero
 909b9fc:	10000a1e 	bne	r2,zero,909ba28 <alt_tse_system_add_sys+0x448>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 909ba00:	d0a08083 	ldbu	r2,-32254(gp)
 909ba04:	11403fcc 	andi	r5,r2,255
 909ba08:	2940201c 	xori	r5,r5,128
 909ba0c:	297fe004 	addi	r5,r5,-128
 909ba10:	01024374 	movhi	r4,2317
 909ba14:	21372204 	addi	r4,r4,-9080
 909ba18:	90833900 	call	9083390 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 909ba1c:	00bfffc4 	movi	r2,-1
 909ba20:	e0bfff15 	stw	r2,-4(fp)
 909ba24:	00016c06 	br	909bfd8 <alt_tse_system_add_sys+0x9f8>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 909ba28:	d0a08083 	ldbu	r2,-32254(gp)
 909ba2c:	10803fcc 	andi	r2,r2,255
 909ba30:	1080201c 	xori	r2,r2,128
 909ba34:	10bfe004 	addi	r2,r2,-128
 909ba38:	00c24374 	movhi	r3,2317
 909ba3c:	18c69404 	addi	r3,r3,6736
 909ba40:	10801224 	muli	r2,r2,72
 909ba44:	10c5883a 	add	r2,r2,r3
 909ba48:	10800504 	addi	r2,r2,20
 909ba4c:	11000017 	ldw	r4,0(r2)
 909ba50:	e0bff717 	ldw	r2,-36(fp)
 909ba54:	11400017 	ldw	r5,0(r2)
 909ba58:	90cb4c80 	call	90cb4c8 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 909ba5c:	d0a08083 	ldbu	r2,-32254(gp)
 909ba60:	14003fcc 	andi	r16,r2,255
 909ba64:	8400201c 	xori	r16,r16,128
 909ba68:	843fe004 	addi	r16,r16,-128
 909ba6c:	e0bff717 	ldw	r2,-36(fp)
 909ba70:	11000117 	ldw	r4,4(r2)
 909ba74:	9083f540 	call	9083f54 <strlen>
 909ba78:	11000044 	addi	r4,r2,1
 909ba7c:	90cb4400 	call	90cb440 <malloc>
 909ba80:	1009883a 	mov	r4,r2
 909ba84:	00c24374 	movhi	r3,2317
 909ba88:	18c69404 	addi	r3,r3,6736
 909ba8c:	80801224 	muli	r2,r16,72
 909ba90:	10c5883a 	add	r2,r2,r3
 909ba94:	10800604 	addi	r2,r2,24
 909ba98:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 909ba9c:	d0a08083 	ldbu	r2,-32254(gp)
 909baa0:	10803fcc 	andi	r2,r2,255
 909baa4:	1080201c 	xori	r2,r2,128
 909baa8:	10bfe004 	addi	r2,r2,-128
 909baac:	00c24374 	movhi	r3,2317
 909bab0:	18c69404 	addi	r3,r3,6736
 909bab4:	10801224 	muli	r2,r2,72
 909bab8:	10c5883a 	add	r2,r2,r3
 909babc:	10800604 	addi	r2,r2,24
 909bac0:	10800017 	ldw	r2,0(r2)
 909bac4:	1004c03a 	cmpne	r2,r2,zero
 909bac8:	10000a1e 	bne	r2,zero,909baf4 <alt_tse_system_add_sys+0x514>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 909bacc:	d0a08083 	ldbu	r2,-32254(gp)
 909bad0:	11403fcc 	andi	r5,r2,255
 909bad4:	2940201c 	xori	r5,r5,128
 909bad8:	297fe004 	addi	r5,r5,-128
 909badc:	01024374 	movhi	r4,2317
 909bae0:	21373504 	addi	r4,r4,-9004
 909bae4:	90833900 	call	9083390 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 909bae8:	00bfffc4 	movi	r2,-1
 909baec:	e0bfff15 	stw	r2,-4(fp)
 909baf0:	00013906 	br	909bfd8 <alt_tse_system_add_sys+0x9f8>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 909baf4:	d0a08083 	ldbu	r2,-32254(gp)
 909baf8:	10803fcc 	andi	r2,r2,255
 909bafc:	1080201c 	xori	r2,r2,128
 909bb00:	10bfe004 	addi	r2,r2,-128
 909bb04:	00c24374 	movhi	r3,2317
 909bb08:	18c69404 	addi	r3,r3,6736
 909bb0c:	10801224 	muli	r2,r2,72
 909bb10:	10c5883a 	add	r2,r2,r3
 909bb14:	10800604 	addi	r2,r2,24
 909bb18:	11000017 	ldw	r4,0(r2)
 909bb1c:	e0bff717 	ldw	r2,-36(fp)
 909bb20:	11400117 	ldw	r5,4(r2)
 909bb24:	90cb4c80 	call	90cb4c8 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 909bb28:	d0a08083 	ldbu	r2,-32254(gp)
 909bb2c:	11003fcc 	andi	r4,r2,255
 909bb30:	2100201c 	xori	r4,r4,128
 909bb34:	213fe004 	addi	r4,r4,-128
 909bb38:	e0bff717 	ldw	r2,-36(fp)
 909bb3c:	1140020b 	ldhu	r5,8(r2)
 909bb40:	00c24374 	movhi	r3,2317
 909bb44:	18c69404 	addi	r3,r3,6736
 909bb48:	20801224 	muli	r2,r4,72
 909bb4c:	10c5883a 	add	r2,r2,r3
 909bb50:	10800704 	addi	r2,r2,28
 909bb54:	1140000d 	sth	r5,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 909bb58:	e0bff617 	ldw	r2,-40(fp)
 909bb5c:	1004c03a 	cmpne	r2,r2,zero
 909bb60:	1000151e 	bne	r2,zero,909bbb8 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 909bb64:	d0a08083 	ldbu	r2,-32254(gp)
 909bb68:	10803fcc 	andi	r2,r2,255
 909bb6c:	1080201c 	xori	r2,r2,128
 909bb70:	10bfe004 	addi	r2,r2,-128
 909bb74:	00c24374 	movhi	r3,2317
 909bb78:	18c69404 	addi	r3,r3,6736
 909bb7c:	10801224 	muli	r2,r2,72
 909bb80:	10c5883a 	add	r2,r2,r3
 909bb84:	10800704 	addi	r2,r2,28
 909bb88:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 909bb8c:	d0a08083 	ldbu	r2,-32254(gp)
 909bb90:	10803fcc 	andi	r2,r2,255
 909bb94:	1080201c 	xori	r2,r2,128
 909bb98:	10bfe004 	addi	r2,r2,-128
 909bb9c:	00c24374 	movhi	r3,2317
 909bba0:	18c69404 	addi	r3,r3,6736
 909bba4:	10801224 	muli	r2,r2,72
 909bba8:	10c5883a 	add	r2,r2,r3
 909bbac:	10800804 	addi	r2,r2,32
 909bbb0:	10000015 	stw	zero,0(r2)
 909bbb4:	00001806 	br	909bc18 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 909bbb8:	d0a08083 	ldbu	r2,-32254(gp)
 909bbbc:	11003fcc 	andi	r4,r2,255
 909bbc0:	2100201c 	xori	r4,r4,128
 909bbc4:	213fe004 	addi	r4,r4,-128
 909bbc8:	e0bff617 	ldw	r2,-40(fp)
 909bbcc:	11400003 	ldbu	r5,0(r2)
 909bbd0:	00c24374 	movhi	r3,2317
 909bbd4:	18c69404 	addi	r3,r3,6736
 909bbd8:	20801224 	muli	r2,r4,72
 909bbdc:	10c5883a 	add	r2,r2,r3
 909bbe0:	10800704 	addi	r2,r2,28
 909bbe4:	11400085 	stb	r5,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 909bbe8:	d0a08083 	ldbu	r2,-32254(gp)
 909bbec:	11003fcc 	andi	r4,r2,255
 909bbf0:	2100201c 	xori	r4,r4,128
 909bbf4:	213fe004 	addi	r4,r4,-128
 909bbf8:	e0bff617 	ldw	r2,-40(fp)
 909bbfc:	11400117 	ldw	r5,4(r2)
 909bc00:	00c24374 	movhi	r3,2317
 909bc04:	18c69404 	addi	r3,r3,6736
 909bc08:	20801224 	muli	r2,r4,72
 909bc0c:	10c5883a 	add	r2,r2,r3
 909bc10:	10800804 	addi	r2,r2,32
 909bc14:	11400015 	stw	r5,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 909bc18:	e0bff517 	ldw	r2,-44(fp)
 909bc1c:	1004c03a 	cmpne	r2,r2,zero
 909bc20:	1000471e 	bne	r2,zero,909bd40 <alt_tse_system_add_sys+0x760>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 909bc24:	d0a08083 	ldbu	r2,-32254(gp)
 909bc28:	10803fcc 	andi	r2,r2,255
 909bc2c:	1080201c 	xori	r2,r2,128
 909bc30:	10bfe004 	addi	r2,r2,-128
 909bc34:	00c24374 	movhi	r3,2317
 909bc38:	18c69404 	addi	r3,r3,6736
 909bc3c:	10801224 	muli	r2,r2,72
 909bc40:	10c5883a 	add	r2,r2,r3
 909bc44:	10800904 	addi	r2,r2,36
 909bc48:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 909bc4c:	d0a08083 	ldbu	r2,-32254(gp)
 909bc50:	10803fcc 	andi	r2,r2,255
 909bc54:	1080201c 	xori	r2,r2,128
 909bc58:	10bfe004 	addi	r2,r2,-128
 909bc5c:	00c24374 	movhi	r3,2317
 909bc60:	18c69404 	addi	r3,r3,6736
 909bc64:	10801224 	muli	r2,r2,72
 909bc68:	10c5883a 	add	r2,r2,r3
 909bc6c:	10800a04 	addi	r2,r2,40
 909bc70:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 909bc74:	d0a08083 	ldbu	r2,-32254(gp)
 909bc78:	10803fcc 	andi	r2,r2,255
 909bc7c:	1080201c 	xori	r2,r2,128
 909bc80:	10bfe004 	addi	r2,r2,-128
 909bc84:	00c24374 	movhi	r3,2317
 909bc88:	18c69404 	addi	r3,r3,6736
 909bc8c:	10801224 	muli	r2,r2,72
 909bc90:	10c5883a 	add	r2,r2,r3
 909bc94:	10800b04 	addi	r2,r2,44
 909bc98:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 909bc9c:	d0a08083 	ldbu	r2,-32254(gp)
 909bca0:	10803fcc 	andi	r2,r2,255
 909bca4:	1080201c 	xori	r2,r2,128
 909bca8:	10bfe004 	addi	r2,r2,-128
 909bcac:	00c24374 	movhi	r3,2317
 909bcb0:	18c69404 	addi	r3,r3,6736
 909bcb4:	10801224 	muli	r2,r2,72
 909bcb8:	10c5883a 	add	r2,r2,r3
 909bcbc:	10800c04 	addi	r2,r2,48
 909bcc0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 909bcc4:	d0a08083 	ldbu	r2,-32254(gp)
 909bcc8:	10803fcc 	andi	r2,r2,255
 909bccc:	1080201c 	xori	r2,r2,128
 909bcd0:	10bfe004 	addi	r2,r2,-128
 909bcd4:	00c24374 	movhi	r3,2317
 909bcd8:	18c69404 	addi	r3,r3,6736
 909bcdc:	10801224 	muli	r2,r2,72
 909bce0:	10c5883a 	add	r2,r2,r3
 909bce4:	10800d04 	addi	r2,r2,52
 909bce8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 909bcec:	d0a08083 	ldbu	r2,-32254(gp)
 909bcf0:	10803fcc 	andi	r2,r2,255
 909bcf4:	1080201c 	xori	r2,r2,128
 909bcf8:	10bfe004 	addi	r2,r2,-128
 909bcfc:	00c24374 	movhi	r3,2317
 909bd00:	18c69404 	addi	r3,r3,6736
 909bd04:	10801224 	muli	r2,r2,72
 909bd08:	10c5883a 	add	r2,r2,r3
 909bd0c:	10800e04 	addi	r2,r2,56
 909bd10:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 909bd14:	d0a08083 	ldbu	r2,-32254(gp)
 909bd18:	10803fcc 	andi	r2,r2,255
 909bd1c:	1080201c 	xori	r2,r2,128
 909bd20:	10bfe004 	addi	r2,r2,-128
 909bd24:	00c24374 	movhi	r3,2317
 909bd28:	18c69404 	addi	r3,r3,6736
 909bd2c:	10801224 	muli	r2,r2,72
 909bd30:	10c5883a 	add	r2,r2,r3
 909bd34:	10800f04 	addi	r2,r2,60
 909bd38:	10000015 	stw	zero,0(r2)
 909bd3c:	00005406 	br	909be90 <alt_tse_system_add_sys+0x8b0>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 909bd40:	d0a08083 	ldbu	r2,-32254(gp)
 909bd44:	11003fcc 	andi	r4,r2,255
 909bd48:	2100201c 	xori	r4,r4,128
 909bd4c:	213fe004 	addi	r4,r4,-128
 909bd50:	e0bff517 	ldw	r2,-44(fp)
 909bd54:	11400003 	ldbu	r5,0(r2)
 909bd58:	00c24374 	movhi	r3,2317
 909bd5c:	18c69404 	addi	r3,r3,6736
 909bd60:	20801224 	muli	r2,r4,72
 909bd64:	10c5883a 	add	r2,r2,r3
 909bd68:	10800904 	addi	r2,r2,36
 909bd6c:	11400005 	stb	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 909bd70:	d0a08083 	ldbu	r2,-32254(gp)
 909bd74:	11003fcc 	andi	r4,r2,255
 909bd78:	2100201c 	xori	r4,r4,128
 909bd7c:	213fe004 	addi	r4,r4,-128
 909bd80:	e0bff517 	ldw	r2,-44(fp)
 909bd84:	11400117 	ldw	r5,4(r2)
 909bd88:	00c24374 	movhi	r3,2317
 909bd8c:	18c69404 	addi	r3,r3,6736
 909bd90:	20801224 	muli	r2,r4,72
 909bd94:	10c5883a 	add	r2,r2,r3
 909bd98:	10800a04 	addi	r2,r2,40
 909bd9c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 909bda0:	d0a08083 	ldbu	r2,-32254(gp)
 909bda4:	11003fcc 	andi	r4,r2,255
 909bda8:	2100201c 	xori	r4,r4,128
 909bdac:	213fe004 	addi	r4,r4,-128
 909bdb0:	e0bff517 	ldw	r2,-44(fp)
 909bdb4:	11400217 	ldw	r5,8(r2)
 909bdb8:	00c24374 	movhi	r3,2317
 909bdbc:	18c69404 	addi	r3,r3,6736
 909bdc0:	20801224 	muli	r2,r4,72
 909bdc4:	10c5883a 	add	r2,r2,r3
 909bdc8:	10800b04 	addi	r2,r2,44
 909bdcc:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 909bdd0:	d0a08083 	ldbu	r2,-32254(gp)
 909bdd4:	11003fcc 	andi	r4,r2,255
 909bdd8:	2100201c 	xori	r4,r4,128
 909bddc:	213fe004 	addi	r4,r4,-128
 909bde0:	e0bff517 	ldw	r2,-44(fp)
 909bde4:	11400317 	ldw	r5,12(r2)
 909bde8:	00c24374 	movhi	r3,2317
 909bdec:	18c69404 	addi	r3,r3,6736
 909bdf0:	20801224 	muli	r2,r4,72
 909bdf4:	10c5883a 	add	r2,r2,r3
 909bdf8:	10800c04 	addi	r2,r2,48
 909bdfc:	11400015 	stw	r5,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 909be00:	d0a08083 	ldbu	r2,-32254(gp)
 909be04:	11003fcc 	andi	r4,r2,255
 909be08:	2100201c 	xori	r4,r4,128
 909be0c:	213fe004 	addi	r4,r4,-128
 909be10:	e0bff517 	ldw	r2,-44(fp)
 909be14:	11400417 	ldw	r5,16(r2)
 909be18:	00c24374 	movhi	r3,2317
 909be1c:	18c69404 	addi	r3,r3,6736
 909be20:	20801224 	muli	r2,r4,72
 909be24:	10c5883a 	add	r2,r2,r3
 909be28:	10800d04 	addi	r2,r2,52
 909be2c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 909be30:	d0a08083 	ldbu	r2,-32254(gp)
 909be34:	11003fcc 	andi	r4,r2,255
 909be38:	2100201c 	xori	r4,r4,128
 909be3c:	213fe004 	addi	r4,r4,-128
 909be40:	e0bff517 	ldw	r2,-44(fp)
 909be44:	11400517 	ldw	r5,20(r2)
 909be48:	00c24374 	movhi	r3,2317
 909be4c:	18c69404 	addi	r3,r3,6736
 909be50:	20801224 	muli	r2,r4,72
 909be54:	10c5883a 	add	r2,r2,r3
 909be58:	10800e04 	addi	r2,r2,56
 909be5c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 909be60:	d0a08083 	ldbu	r2,-32254(gp)
 909be64:	11003fcc 	andi	r4,r2,255
 909be68:	2100201c 	xori	r4,r4,128
 909be6c:	213fe004 	addi	r4,r4,-128
 909be70:	e0bff517 	ldw	r2,-44(fp)
 909be74:	11400617 	ldw	r5,24(r2)
 909be78:	00c24374 	movhi	r3,2317
 909be7c:	18c69404 	addi	r3,r3,6736
 909be80:	20801224 	muli	r2,r4,72
 909be84:	10c5883a 	add	r2,r2,r3
 909be88:	10800f04 	addi	r2,r2,60
 909be8c:	11400015 	stw	r5,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 909be90:	e0bff417 	ldw	r2,-48(fp)
 909be94:	1004c03a 	cmpne	r2,r2,zero
 909be98:	1000161e 	bne	r2,zero,909bef4 <alt_tse_system_add_sys+0x914>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 909be9c:	d0a08083 	ldbu	r2,-32254(gp)
 909bea0:	10803fcc 	andi	r2,r2,255
 909bea4:	1080201c 	xori	r2,r2,128
 909bea8:	10bfe004 	addi	r2,r2,-128
 909beac:	00c24374 	movhi	r3,2317
 909beb0:	18c69404 	addi	r3,r3,6736
 909beb4:	10801224 	muli	r2,r2,72
 909beb8:	10c5883a 	add	r2,r2,r3
 909bebc:	10c01004 	addi	r3,r2,64
 909bec0:	00bfffc4 	movi	r2,-1
 909bec4:	18800015 	stw	r2,0(r3)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 909bec8:	d0a08083 	ldbu	r2,-32254(gp)
 909becc:	10803fcc 	andi	r2,r2,255
 909bed0:	1080201c 	xori	r2,r2,128
 909bed4:	10bfe004 	addi	r2,r2,-128
 909bed8:	00c24374 	movhi	r3,2317
 909bedc:	18c69404 	addi	r3,r3,6736
 909bee0:	10801224 	muli	r2,r2,72
 909bee4:	10c5883a 	add	r2,r2,r3
 909bee8:	10801104 	addi	r2,r2,68
 909beec:	10000015 	stw	zero,0(r2)
 909bef0:	00001806 	br	909bf54 <alt_tse_system_add_sys+0x974>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 909bef4:	d0a08083 	ldbu	r2,-32254(gp)
 909bef8:	11003fcc 	andi	r4,r2,255
 909befc:	2100201c 	xori	r4,r4,128
 909bf00:	213fe004 	addi	r4,r4,-128
 909bf04:	e0bff417 	ldw	r2,-48(fp)
 909bf08:	11400017 	ldw	r5,0(r2)
 909bf0c:	00c24374 	movhi	r3,2317
 909bf10:	18c69404 	addi	r3,r3,6736
 909bf14:	20801224 	muli	r2,r4,72
 909bf18:	10c5883a 	add	r2,r2,r3
 909bf1c:	10801004 	addi	r2,r2,64
 909bf20:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 909bf24:	d0a08083 	ldbu	r2,-32254(gp)
 909bf28:	11003fcc 	andi	r4,r2,255
 909bf2c:	2100201c 	xori	r4,r4,128
 909bf30:	213fe004 	addi	r4,r4,-128
 909bf34:	e0bff417 	ldw	r2,-48(fp)
 909bf38:	11400117 	ldw	r5,4(r2)
 909bf3c:	00c24374 	movhi	r3,2317
 909bf40:	18c69404 	addi	r3,r3,6736
 909bf44:	20801224 	muli	r2,r4,72
 909bf48:	10c5883a 	add	r2,r2,r3
 909bf4c:	10801104 	addi	r2,r2,68
 909bf50:	11400015 	stw	r5,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 909bf54:	e0bff717 	ldw	r2,-36(fp)
 909bf58:	10800304 	addi	r2,r2,12
 909bf5c:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
 909bf60:	e0bff617 	ldw	r2,-40(fp)
 909bf64:	1005003a 	cmpeq	r2,r2,zero
 909bf68:	1000031e 	bne	r2,zero,909bf78 <alt_tse_system_add_sys+0x998>
 909bf6c:	e0bff617 	ldw	r2,-40(fp)
 909bf70:	10800204 	addi	r2,r2,8
 909bf74:	e0bff615 	stw	r2,-40(fp)
		if(pfifo) pfifo++;
 909bf78:	e0bff517 	ldw	r2,-44(fp)
 909bf7c:	1005003a 	cmpeq	r2,r2,zero
 909bf80:	1000031e 	bne	r2,zero,909bf90 <alt_tse_system_add_sys+0x9b0>
 909bf84:	e0bff517 	ldw	r2,-44(fp)
 909bf88:	10800704 	addi	r2,r2,28
 909bf8c:	e0bff515 	stw	r2,-44(fp)
		if(pphy) pphy++;
 909bf90:	e0bff417 	ldw	r2,-48(fp)
 909bf94:	1005003a 	cmpeq	r2,r2,zero
 909bf98:	1000031e 	bne	r2,zero,909bfa8 <alt_tse_system_add_sys+0x9c8>
 909bf9c:	e0bff417 	ldw	r2,-48(fp)
 909bfa0:	10800204 	addi	r2,r2,8
 909bfa4:	e0bff415 	stw	r2,-48(fp)
		
		tse_system_count++;
 909bfa8:	d0a08083 	ldbu	r2,-32254(gp)
 909bfac:	10800044 	addi	r2,r2,1
 909bfb0:	d0a08085 	stb	r2,-32254(gp)
		max_mac_system = tse_system_count;
 909bfb4:	d0a08083 	ldbu	r2,-32254(gp)
 909bfb8:	d0a02b05 	stb	r2,-32596(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 909bfbc:	e0bffa17 	ldw	r2,-24(fp)
 909bfc0:	10800044 	addi	r2,r2,1
 909bfc4:	e0bffa15 	stw	r2,-24(fp)
 909bfc8:	e0fffa17 	ldw	r3,-24(fp)
 909bfcc:	e0bff917 	ldw	r2,-28(fp)
 909bfd0:	18bdb016 	blt	r3,r2,909b694 <alt_tse_system_add_sys+0xb4>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 909bfd4:	e03fff15 	stw	zero,-4(fp)
 909bfd8:	e0bfff17 	ldw	r2,-4(fp)
	
}
 909bfdc:	e037883a 	mov	sp,fp
 909bfe0:	dfc00217 	ldw	ra,8(sp)
 909bfe4:	df000117 	ldw	fp,4(sp)
 909bfe8:	dc000017 	ldw	r16,0(sp)
 909bfec:	dec00304 	addi	sp,sp,12
 909bff0:	f800283a 	ret

0909bff4 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 909bff4:	defff804 	addi	sp,sp,-32
 909bff8:	dfc00715 	stw	ra,28(sp)
 909bffc:	df000615 	stw	fp,24(sp)
 909c000:	df000604 	addi	fp,sp,24
 909c004:	e13ffd15 	stw	r4,-12(fp)
 909c008:	e17ffe05 	stb	r5,-8(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 909c00c:	e03ffc15 	stw	zero,-16(fp)
 909c010:	00004c06 	br	909c144 <alt_tse_sys_enable_mdio_sharing+0x150>
		psys_mac = psys_mac_list[i];
 909c014:	e0bffc17 	ldw	r2,-16(fp)
 909c018:	1085883a 	add	r2,r2,r2
 909c01c:	1085883a 	add	r2,r2,r2
 909c020:	1007883a 	mov	r3,r2
 909c024:	e0bffd17 	ldw	r2,-12(fp)
 909c028:	1885883a 	add	r2,r3,r2
 909c02c:	10800017 	ldw	r2,0(r2)
 909c030:	e0bffa15 	stw	r2,-24(fp)
		
		if(psys_mac == 0) {
 909c034:	e0bffa17 	ldw	r2,-24(fp)
 909c038:	1004c03a 	cmpne	r2,r2,zero
 909c03c:	1000091e 	bne	r2,zero,909c064 <alt_tse_sys_enable_mdio_sharing+0x70>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 909c040:	01024374 	movhi	r4,2317
 909c044:	2136e304 	addi	r4,r4,-9332
 909c048:	90836b80 	call	90836b8 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 909c04c:	01024374 	movhi	r4,2317
 909c050:	21374804 	addi	r4,r4,-8928
 909c054:	90836b80 	call	90836b8 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909c058:	00bfffc4 	movi	r2,-1
 909c05c:	e0bfff15 	stw	r2,-4(fp)
 909c060:	00003c06 	br	909c154 <alt_tse_sys_enable_mdio_sharing+0x160>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 909c064:	e03ffb15 	stw	zero,-20(fp)
 909c068:	00002f06 	br	909c128 <alt_tse_sys_enable_mdio_sharing+0x134>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 909c06c:	e0bffa17 	ldw	r2,-24(fp)
 909c070:	11000017 	ldw	r4,0(r2)
 909c074:	e0bffb17 	ldw	r2,-20(fp)
 909c078:	00c24374 	movhi	r3,2317
 909c07c:	18c69404 	addi	r3,r3,6736
 909c080:	10801224 	muli	r2,r2,72
 909c084:	10c5883a 	add	r2,r2,r3
 909c088:	10800017 	ldw	r2,0(r2)
 909c08c:	2080231e 	bne	r4,r2,909c11c <alt_tse_sys_enable_mdio_sharing+0x128>
				if(tse_mac_device[j].tse_multichannel_mac) {
 909c090:	e0bffb17 	ldw	r2,-20(fp)
 909c094:	00c24374 	movhi	r3,2317
 909c098:	18c69404 	addi	r3,r3,6736
 909c09c:	10801224 	muli	r2,r2,72
 909c0a0:	10c5883a 	add	r2,r2,r3
 909c0a4:	10800204 	addi	r2,r2,8
 909c0a8:	108000c3 	ldbu	r2,3(r2)
 909c0ac:	10803fcc 	andi	r2,r2,255
 909c0b0:	1005003a 	cmpeq	r2,r2,zero
 909c0b4:	1000091e 	bne	r2,zero,909c0dc <alt_tse_sys_enable_mdio_sharing+0xe8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 909c0b8:	01024374 	movhi	r4,2317
 909c0bc:	21375c04 	addi	r4,r4,-8848
 909c0c0:	90836b80 	call	90836b8 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 909c0c4:	01024374 	movhi	r4,2317
 909c0c8:	21376d04 	addi	r4,r4,-8780
 909c0cc:	90836b80 	call	90836b8 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909c0d0:	00bfffc4 	movi	r2,-1
 909c0d4:	e0bfff15 	stw	r2,-4(fp)
 909c0d8:	00001e06 	br	909c154 <alt_tse_sys_enable_mdio_sharing+0x160>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 909c0dc:	e0bffb17 	ldw	r2,-20(fp)
 909c0e0:	00c24374 	movhi	r3,2317
 909c0e4:	18c69404 	addi	r3,r3,6736
 909c0e8:	10801224 	muli	r2,r2,72
 909c0ec:	10c5883a 	add	r2,r2,r3
 909c0f0:	10c00304 	addi	r3,r2,12
 909c0f4:	00800044 	movi	r2,1
 909c0f8:	18800045 	stb	r2,1(r3)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 909c0fc:	e0bffb17 	ldw	r2,-20(fp)
 909c100:	00c24374 	movhi	r3,2317
 909c104:	18c69404 	addi	r3,r3,6736
 909c108:	10801224 	muli	r2,r2,72
 909c10c:	10c5883a 	add	r2,r2,r3
 909c110:	10c00304 	addi	r3,r2,12
 909c114:	e0bffe03 	ldbu	r2,-8(fp)
 909c118:	18800085 	stb	r2,2(r3)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 909c11c:	e0bffb17 	ldw	r2,-20(fp)
 909c120:	10800044 	addi	r2,r2,1
 909c124:	e0bffb15 	stw	r2,-20(fp)
 909c128:	d0a02b03 	ldbu	r2,-32596(gp)
 909c12c:	10c03fcc 	andi	r3,r2,255
 909c130:	e0bffb17 	ldw	r2,-20(fp)
 909c134:	10ffcd16 	blt	r2,r3,909c06c <alt_tse_sys_enable_mdio_sharing+0x78>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 909c138:	e0bffc17 	ldw	r2,-16(fp)
 909c13c:	10800044 	addi	r2,r2,1
 909c140:	e0bffc15 	stw	r2,-16(fp)
 909c144:	e0fffe03 	ldbu	r3,-8(fp)
 909c148:	e0bffc17 	ldw	r2,-16(fp)
 909c14c:	10ffb116 	blt	r2,r3,909c014 <alt_tse_sys_enable_mdio_sharing+0x20>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 909c150:	e03fff15 	stw	zero,-4(fp)
 909c154:	e0bfff17 	ldw	r2,-4(fp)
}
 909c158:	e037883a 	mov	sp,fp
 909c15c:	dfc00117 	ldw	ra,4(sp)
 909c160:	df000017 	ldw	fp,0(sp)
 909c164:	dec00204 	addi	sp,sp,8
 909c168:	f800283a 	ret

0909c16c <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 909c16c:	defffc04 	addi	sp,sp,-16
 909c170:	dfc00315 	stw	ra,12(sp)
 909c174:	df000215 	stw	fp,8(sp)
 909c178:	df000204 	addi	fp,sp,8
 909c17c:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 909c180:	e13fff17 	ldw	r4,-4(fp)
 909c184:	909c37c0 	call	909c37c <alt_tse_get_mac_info>
 909c188:	10800317 	ldw	r2,12(r2)
 909c18c:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 909c190:	e13ffe17 	ldw	r4,-8(fp)
 909c194:	909f7d80 	call	909f7d8 <alt_tse_phy_get_common_speed>
}
 909c198:	e037883a 	mov	sp,fp
 909c19c:	dfc00117 	ldw	ra,4(sp)
 909c1a0:	df000017 	ldw	fp,0(sp)
 909c1a4:	dec00204 	addi	sp,sp,8
 909c1a8:	f800283a 	ret

0909c1ac <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 909c1ac:	defffb04 	addi	sp,sp,-20
 909c1b0:	dfc00415 	stw	ra,16(sp)
 909c1b4:	df000315 	stw	fp,12(sp)
 909c1b8:	df000304 	addi	fp,sp,12
 909c1bc:	e13ffe15 	stw	r4,-8(fp)
 909c1c0:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 909c1c4:	e13ffe17 	ldw	r4,-8(fp)
 909c1c8:	909c37c0 	call	909c37c <alt_tse_get_mac_info>
 909c1cc:	10800317 	ldw	r2,12(r2)
 909c1d0:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 909c1d4:	e13ffd17 	ldw	r4,-12(fp)
 909c1d8:	e17fff17 	ldw	r5,-4(fp)
 909c1dc:	909faf40 	call	909faf4 <alt_tse_phy_set_common_speed>
}
 909c1e0:	e037883a 	mov	sp,fp
 909c1e4:	dfc00117 	ldw	ra,4(sp)
 909c1e8:	df000017 	ldw	fp,0(sp)
 909c1ec:	dec00204 	addi	sp,sp,8
 909c1f0:	f800283a 	ret

0909c1f4 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 909c1f4:	defffc04 	addi	sp,sp,-16
 909c1f8:	df000315 	stw	fp,12(sp)
 909c1fc:	df000304 	addi	fp,sp,12
 909c200:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 909c204:	e03ffd15 	stw	zero,-12(fp)
 909c208:	00000e06 	br	909c244 <alt_tse_get_system_index+0x50>
        if(psys_info == &tse_mac_device[i]) {
 909c20c:	e0bffd17 	ldw	r2,-12(fp)
 909c210:	10801224 	muli	r2,r2,72
 909c214:	1007883a 	mov	r3,r2
 909c218:	00824374 	movhi	r2,2317
 909c21c:	10869404 	addi	r2,r2,6736
 909c220:	1887883a 	add	r3,r3,r2
 909c224:	e0bffe17 	ldw	r2,-8(fp)
 909c228:	1880031e 	bne	r3,r2,909c238 <alt_tse_get_system_index+0x44>
            return i;
 909c22c:	e0bffd17 	ldw	r2,-12(fp)
 909c230:	e0bfff15 	stw	r2,-4(fp)
 909c234:	00000906 	br	909c25c <alt_tse_get_system_index+0x68>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 909c238:	e0bffd17 	ldw	r2,-12(fp)
 909c23c:	10800044 	addi	r2,r2,1
 909c240:	e0bffd15 	stw	r2,-12(fp)
 909c244:	d0a02b03 	ldbu	r2,-32596(gp)
 909c248:	10c03fcc 	andi	r3,r2,255
 909c24c:	e0bffd17 	ldw	r2,-12(fp)
 909c250:	10ffee16 	blt	r2,r3,909c20c <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 909c254:	00bfffc4 	movi	r2,-1
 909c258:	e0bfff15 	stw	r2,-4(fp)
 909c25c:	e0bfff17 	ldw	r2,-4(fp)
}
 909c260:	e037883a 	mov	sp,fp
 909c264:	df000017 	ldw	fp,0(sp)
 909c268:	dec00104 	addi	sp,sp,4
 909c26c:	f800283a 	ret

0909c270 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 909c270:	defffc04 	addi	sp,sp,-16
 909c274:	df000315 	stw	fp,12(sp)
 909c278:	df000304 	addi	fp,sp,12
 909c27c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 909c280:	e03ffd15 	stw	zero,-12(fp)
 909c284:	00000f06 	br	909c2c4 <alt_tse_get_mac_group_index+0x54>
        if(pmac_group == pmac_groups[i]) {
 909c288:	e0bffd17 	ldw	r2,-12(fp)
 909c28c:	00c243b4 	movhi	r3,2318
 909c290:	18f4c104 	addi	r3,r3,-11516
 909c294:	1085883a 	add	r2,r2,r2
 909c298:	1085883a 	add	r2,r2,r2
 909c29c:	10c5883a 	add	r2,r2,r3
 909c2a0:	10c00017 	ldw	r3,0(r2)
 909c2a4:	e0bffe17 	ldw	r2,-8(fp)
 909c2a8:	1880031e 	bne	r3,r2,909c2b8 <alt_tse_get_mac_group_index+0x48>
            return i;
 909c2ac:	e0bffd17 	ldw	r2,-12(fp)
 909c2b0:	e0bfff15 	stw	r2,-4(fp)
 909c2b4:	00000906 	br	909c2dc <alt_tse_get_mac_group_index+0x6c>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 909c2b8:	e0bffd17 	ldw	r2,-12(fp)
 909c2bc:	10800044 	addi	r2,r2,1
 909c2c0:	e0bffd15 	stw	r2,-12(fp)
 909c2c4:	d0a08043 	ldbu	r2,-32255(gp)
 909c2c8:	10c03fcc 	andi	r3,r2,255
 909c2cc:	e0bffd17 	ldw	r2,-12(fp)
 909c2d0:	10ffed16 	blt	r2,r3,909c288 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 909c2d4:	00bfffc4 	movi	r2,-1
 909c2d8:	e0bfff15 	stw	r2,-4(fp)
 909c2dc:	e0bfff17 	ldw	r2,-4(fp)
}
 909c2e0:	e037883a 	mov	sp,fp
 909c2e4:	df000017 	ldw	fp,0(sp)
 909c2e8:	dec00104 	addi	sp,sp,4
 909c2ec:	f800283a 	ret

0909c2f0 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 909c2f0:	defffc04 	addi	sp,sp,-16
 909c2f4:	df000315 	stw	fp,12(sp)
 909c2f8:	df000304 	addi	fp,sp,12
 909c2fc:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 909c300:	e03ffd15 	stw	zero,-12(fp)
 909c304:	00001006 	br	909c348 <alt_tse_get_mac_info_index+0x58>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 909c308:	e0bffe17 	ldw	r2,-8(fp)
 909c30c:	10c00317 	ldw	r3,12(r2)
 909c310:	e0bffd17 	ldw	r2,-12(fp)
 909c314:	1085883a 	add	r2,r2,r2
 909c318:	1085883a 	add	r2,r2,r2
 909c31c:	10c5883a 	add	r2,r2,r3
 909c320:	10800104 	addi	r2,r2,4
 909c324:	10c00017 	ldw	r3,0(r2)
 909c328:	e0bffe17 	ldw	r2,-8(fp)
 909c32c:	1880031e 	bne	r3,r2,909c33c <alt_tse_get_mac_info_index+0x4c>
            return i;
 909c330:	e0bffd17 	ldw	r2,-12(fp)
 909c334:	e0bfff15 	stw	r2,-4(fp)
 909c338:	00000b06 	br	909c368 <alt_tse_get_mac_info_index+0x78>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 909c33c:	e0bffd17 	ldw	r2,-12(fp)
 909c340:	10800044 	addi	r2,r2,1
 909c344:	e0bffd15 	stw	r2,-12(fp)
 909c348:	e0bffe17 	ldw	r2,-8(fp)
 909c34c:	10800317 	ldw	r2,12(r2)
 909c350:	10800003 	ldbu	r2,0(r2)
 909c354:	10c03fcc 	andi	r3,r2,255
 909c358:	e0bffd17 	ldw	r2,-12(fp)
 909c35c:	10ffea16 	blt	r2,r3,909c308 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 909c360:	00bfffc4 	movi	r2,-1
 909c364:	e0bfff15 	stw	r2,-4(fp)
 909c368:	e0bfff17 	ldw	r2,-4(fp)
}
 909c36c:	e037883a 	mov	sp,fp
 909c370:	df000017 	ldw	fp,0(sp)
 909c374:	dec00104 	addi	sp,sp,4
 909c378:	f800283a 	ret

0909c37c <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 909c37c:	defff904 	addi	sp,sp,-28
 909c380:	df000615 	stw	fp,24(sp)
 909c384:	df000604 	addi	fp,sp,24
 909c388:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 909c38c:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 909c390:	e03ffa15 	stw	zero,-24(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 909c394:	e03ffd15 	stw	zero,-12(fp)
 909c398:	00002606 	br	909c434 <alt_tse_get_mac_info+0xb8>
        pmac_group = pmac_groups[i];
 909c39c:	e0bffd17 	ldw	r2,-12(fp)
 909c3a0:	00c243b4 	movhi	r3,2318
 909c3a4:	18f4c104 	addi	r3,r3,-11516
 909c3a8:	1085883a 	add	r2,r2,r2
 909c3ac:	1085883a 	add	r2,r2,r2
 909c3b0:	10c5883a 	add	r2,r2,r3
 909c3b4:	10800017 	ldw	r2,0(r2)
 909c3b8:	e0bffb15 	stw	r2,-20(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 909c3bc:	e03ffc15 	stw	zero,-16(fp)
 909c3c0:	00001406 	br	909c414 <alt_tse_get_mac_info+0x98>
            pmac_info = pmac_group->pmac_info[j];
 909c3c4:	e0bffc17 	ldw	r2,-16(fp)
 909c3c8:	e0fffb17 	ldw	r3,-20(fp)
 909c3cc:	1085883a 	add	r2,r2,r2
 909c3d0:	1085883a 	add	r2,r2,r2
 909c3d4:	10c5883a 	add	r2,r2,r3
 909c3d8:	10800104 	addi	r2,r2,4
 909c3dc:	10800017 	ldw	r2,0(r2)
 909c3e0:	e0bffa15 	stw	r2,-24(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 909c3e4:	e0bffa17 	ldw	r2,-24(fp)
 909c3e8:	10800217 	ldw	r2,8(r2)
 909c3ec:	10800017 	ldw	r2,0(r2)
 909c3f0:	1007883a 	mov	r3,r2
 909c3f4:	e0bffe17 	ldw	r2,-8(fp)
 909c3f8:	1880031e 	bne	r3,r2,909c408 <alt_tse_get_mac_info+0x8c>
                return pmac_info;
 909c3fc:	e0bffa17 	ldw	r2,-24(fp)
 909c400:	e0bfff15 	stw	r2,-4(fp)
 909c404:	00001006 	br	909c448 <alt_tse_get_mac_info+0xcc>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 909c408:	e0bffc17 	ldw	r2,-16(fp)
 909c40c:	10800044 	addi	r2,r2,1
 909c410:	e0bffc15 	stw	r2,-16(fp)
 909c414:	e0bffb17 	ldw	r2,-20(fp)
 909c418:	10800003 	ldbu	r2,0(r2)
 909c41c:	10c03fcc 	andi	r3,r2,255
 909c420:	e0bffc17 	ldw	r2,-16(fp)
 909c424:	10ffe716 	blt	r2,r3,909c3c4 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 909c428:	e0bffd17 	ldw	r2,-12(fp)
 909c42c:	10800044 	addi	r2,r2,1
 909c430:	e0bffd15 	stw	r2,-12(fp)
 909c434:	d0a08043 	ldbu	r2,-32255(gp)
 909c438:	10c03fcc 	andi	r3,r2,255
 909c43c:	e0bffd17 	ldw	r2,-12(fp)
 909c440:	10ffd616 	blt	r2,r3,909c39c <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 909c444:	e03fff15 	stw	zero,-4(fp)
 909c448:	e0bfff17 	ldw	r2,-4(fp)
}
 909c44c:	e037883a 	mov	sp,fp
 909c450:	df000017 	ldw	fp,0(sp)
 909c454:	dec00104 	addi	sp,sp,4
 909c458:	f800283a 	ret

0909c45c <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 909c45c:	defffb04 	addi	sp,sp,-20
 909c460:	df000415 	stw	fp,16(sp)
 909c464:	df000404 	addi	fp,sp,16
 909c468:	e13ffd15 	stw	r4,-12(fp)
 909c46c:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909c470:	e0bffd17 	ldw	r2,-12(fp)
 909c474:	10800204 	addi	r2,r2,8
 909c478:	10800037 	ldwio	r2,0(r2)
 909c47c:	e0bffc15 	stw	r2,-16(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 909c480:	e0bffe03 	ldbu	r2,-8(fp)
 909c484:	10800098 	cmpnei	r2,r2,2
 909c488:	1000091e 	bne	r2,zero,909c4b0 <alt_tse_mac_set_speed+0x54>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909c48c:	e0bffc17 	ldw	r2,-16(fp)
 909c490:	10800214 	ori	r2,r2,8
 909c494:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909c498:	e0fffc17 	ldw	r3,-16(fp)
 909c49c:	00bf8034 	movhi	r2,65024
 909c4a0:	10bfffc4 	addi	r2,r2,-1
 909c4a4:	1884703a 	and	r2,r3,r2
 909c4a8:	e0bffc15 	stw	r2,-16(fp)
 909c4ac:	00001b06 	br	909c51c <alt_tse_mac_set_speed+0xc0>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 909c4b0:	e0bffe03 	ldbu	r2,-8(fp)
 909c4b4:	10800058 	cmpnei	r2,r2,1
 909c4b8:	10000a1e 	bne	r2,zero,909c4e4 <alt_tse_mac_set_speed+0x88>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909c4bc:	e0fffc17 	ldw	r3,-16(fp)
 909c4c0:	00bffdc4 	movi	r2,-9
 909c4c4:	1884703a 	and	r2,r3,r2
 909c4c8:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909c4cc:	e0fffc17 	ldw	r3,-16(fp)
 909c4d0:	00bf8034 	movhi	r2,65024
 909c4d4:	10bfffc4 	addi	r2,r2,-1
 909c4d8:	1884703a 	and	r2,r3,r2
 909c4dc:	e0bffc15 	stw	r2,-16(fp)
 909c4e0:	00000e06 	br	909c51c <alt_tse_mac_set_speed+0xc0>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 909c4e4:	e0bffe03 	ldbu	r2,-8(fp)
 909c4e8:	1004c03a 	cmpne	r2,r2,zero
 909c4ec:	1000081e 	bne	r2,zero,909c510 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 909c4f0:	e0fffc17 	ldw	r3,-16(fp)
 909c4f4:	00bffdc4 	movi	r2,-9
 909c4f8:	1884703a 	and	r2,r3,r2
 909c4fc:	e0bffc15 	stw	r2,-16(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 909c500:	e0bffc17 	ldw	r2,-16(fp)
 909c504:	10808034 	orhi	r2,r2,512
 909c508:	e0bffc15 	stw	r2,-16(fp)
 909c50c:	00000306 	br	909c51c <alt_tse_mac_set_speed+0xc0>
  }  
  else {
    return ENP_PARAM;
 909c510:	00bffd84 	movi	r2,-10
 909c514:	e0bfff15 	stw	r2,-4(fp)
 909c518:	00000606 	br	909c534 <alt_tse_mac_set_speed+0xd8>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 909c51c:	e0bffd17 	ldw	r2,-12(fp)
 909c520:	10800204 	addi	r2,r2,8
 909c524:	1007883a 	mov	r3,r2
 909c528:	e0bffc17 	ldw	r2,-16(fp)
 909c52c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909c530:	e03fff15 	stw	zero,-4(fp)
 909c534:	e0bfff17 	ldw	r2,-4(fp)
}
 909c538:	e037883a 	mov	sp,fp
 909c53c:	df000017 	ldw	fp,0(sp)
 909c540:	dec00104 	addi	sp,sp,4
 909c544:	f800283a 	ret

0909c548 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 909c548:	defffb04 	addi	sp,sp,-20
 909c54c:	df000415 	stw	fp,16(sp)
 909c550:	df000404 	addi	fp,sp,16
 909c554:	e13ffd15 	stw	r4,-12(fp)
 909c558:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 909c55c:	e0bffd17 	ldw	r2,-12(fp)
 909c560:	10800204 	addi	r2,r2,8
 909c564:	10800037 	ldwio	r2,0(r2)
 909c568:	e0bffc15 	stw	r2,-16(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 909c56c:	e0bffe03 	ldbu	r2,-8(fp)
 909c570:	1004c03a 	cmpne	r2,r2,zero
 909c574:	1000041e 	bne	r2,zero,909c588 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 909c578:	e0bffc17 	ldw	r2,-16(fp)
 909c57c:	10810014 	ori	r2,r2,1024
 909c580:	e0bffc15 	stw	r2,-16(fp)
 909c584:	00000b06 	br	909c5b4 <alt_tse_mac_set_duplex+0x6c>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 909c588:	e0bffe03 	ldbu	r2,-8(fp)
 909c58c:	10800058 	cmpnei	r2,r2,1
 909c590:	1000051e 	bne	r2,zero,909c5a8 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 909c594:	e0bffc17 	ldw	r2,-16(fp)
 909c598:	00feffc4 	movi	r3,-1025
 909c59c:	10c4703a 	and	r2,r2,r3
 909c5a0:	e0bffc15 	stw	r2,-16(fp)
 909c5a4:	00000306 	br	909c5b4 <alt_tse_mac_set_duplex+0x6c>
  }
  else {
    return ENP_PARAM;
 909c5a8:	00bffd84 	movi	r2,-10
 909c5ac:	e0bfff15 	stw	r2,-4(fp)
 909c5b0:	00000606 	br	909c5cc <alt_tse_mac_set_duplex+0x84>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 909c5b4:	e0bffd17 	ldw	r2,-12(fp)
 909c5b8:	10800204 	addi	r2,r2,8
 909c5bc:	1007883a 	mov	r3,r2
 909c5c0:	e0bffc17 	ldw	r2,-16(fp)
 909c5c4:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 909c5c8:	e03fff15 	stw	zero,-4(fp)
 909c5cc:	e0bfff17 	ldw	r2,-4(fp)

}
 909c5d0:	e037883a 	mov	sp,fp
 909c5d4:	df000017 	ldw	fp,0(sp)
 909c5d8:	dec00104 	addi	sp,sp,4
 909c5dc:	f800283a 	ret

0909c5e0 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 909c5e0:	deff9704 	addi	sp,sp,-420
 909c5e4:	dfc06815 	stw	ra,416(sp)
 909c5e8:	df006715 	stw	fp,412(sp)
 909c5ec:	df006704 	addi	fp,sp,412
 909c5f0:	e13fa215 	stw	r4,-376(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909c5f4:	00800044 	movi	r2,1
 909c5f8:	e0bfa145 	stb	r2,-379(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 909c5fc:	00800044 	movi	r2,1
 909c600:	e0bfa105 	stb	r2,-380(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 909c604:	e0bfa103 	ldbu	r2,-380(fp)
 909c608:	1080004c 	andi	r2,r2,1
 909c60c:	e0bfff15 	stw	r2,-4(fp)
 909c610:	e0bfa143 	ldbu	r2,-379(fp)
 909c614:	10800098 	cmpnei	r2,r2,2
 909c618:	1000031e 	bne	r2,zero,909c628 <getPHYSpeed+0x48>
 909c61c:	00800084 	movi	r2,2
 909c620:	e0bffe15 	stw	r2,-8(fp)
 909c624:	00000106 	br	909c62c <getPHYSpeed+0x4c>
 909c628:	e03ffe15 	stw	zero,-8(fp)
 909c62c:	e0ffff17 	ldw	r3,-4(fp)
 909c630:	e13ffe17 	ldw	r4,-8(fp)
 909c634:	1906b03a 	or	r3,r3,r4
 909c638:	e0fffd15 	stw	r3,-12(fp)
 909c63c:	e0bfa143 	ldbu	r2,-379(fp)
 909c640:	10800058 	cmpnei	r2,r2,1
 909c644:	1000031e 	bne	r2,zero,909c654 <getPHYSpeed+0x74>
 909c648:	00800104 	movi	r2,4
 909c64c:	e0bffc15 	stw	r2,-16(fp)
 909c650:	00000106 	br	909c658 <getPHYSpeed+0x78>
 909c654:	e03ffc15 	stw	zero,-16(fp)
 909c658:	e0fffd17 	ldw	r3,-12(fp)
 909c65c:	e13ffc17 	ldw	r4,-16(fp)
 909c660:	1906b03a 	or	r3,r3,r4
 909c664:	e0fffb15 	stw	r3,-20(fp)
 909c668:	e0bfa143 	ldbu	r2,-379(fp)
 909c66c:	1004c03a 	cmpne	r2,r2,zero
 909c670:	1000031e 	bne	r2,zero,909c680 <getPHYSpeed+0xa0>
 909c674:	00800204 	movi	r2,8
 909c678:	e0bffa15 	stw	r2,-24(fp)
 909c67c:	00000106 	br	909c684 <getPHYSpeed+0xa4>
 909c680:	e03ffa15 	stw	zero,-24(fp)
 909c684:	e0fffb17 	ldw	r3,-20(fp)
 909c688:	e13ffa17 	ldw	r4,-24(fp)
 909c68c:	1906b03a 	or	r3,r3,r4
 909c690:	e0fff915 	stw	r3,-28(fp)
 909c694:	e0bfa143 	ldbu	r2,-379(fp)
 909c698:	108000d8 	cmpnei	r2,r2,3
 909c69c:	1000031e 	bne	r2,zero,909c6ac <getPHYSpeed+0xcc>
 909c6a0:	00800074 	movhi	r2,1
 909c6a4:	e0bff815 	stw	r2,-32(fp)
 909c6a8:	00000106 	br	909c6b0 <getPHYSpeed+0xd0>
 909c6ac:	e03ff815 	stw	zero,-32(fp)
 909c6b0:	e0fff917 	ldw	r3,-28(fp)
 909c6b4:	e13ff817 	ldw	r4,-32(fp)
 909c6b8:	1904b03a 	or	r2,r3,r4
 909c6bc:	e0bfa015 	stw	r2,-384(fp)
    
    alt_tse_phy_info *pphy = 0;
 909c6c0:	e03f9f15 	stw	zero,-388(fp)
    alt_tse_mac_info *pmac_info = 0;
 909c6c4:	e03f9e15 	stw	zero,-392(fp)
    alt_tse_mac_group *pmac_group = 0;
 909c6c8:	e03f9d15 	stw	zero,-396(fp)
    alt_tse_system_info *psys = 0;
 909c6cc:	e03f9c15 	stw	zero,-400(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909c6d0:	e03f9b45 	stb	zero,-403(fp)
    alt_8 mac_group_index = 0;
 909c6d4:	e03f9b05 	stb	zero,-404(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 909c6d8:	d0a080c3 	ldbu	r2,-32253(gp)
 909c6dc:	10803fcc 	andi	r2,r2,255
 909c6e0:	1004c03a 	cmpne	r2,r2,zero
 909c6e4:	1000031e 	bne	r2,zero,909c6f4 <getPHYSpeed+0x114>
        alt_tse_phy_init();
 909c6e8:	909e9540 	call	909e954 <alt_tse_phy_init>
        is_init = 1;
 909c6ec:	00800044 	movi	r2,1
 909c6f0:	d0a080c5 	stb	r2,-32253(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 909c6f4:	e13fa217 	ldw	r4,-376(fp)
 909c6f8:	909c37c0 	call	909c37c <alt_tse_get_mac_info>
 909c6fc:	e0bf9e15 	stw	r2,-392(fp)
    
    if(pmac_info == 0) {
 909c700:	e0bf9e17 	ldw	r2,-392(fp)
 909c704:	1004c03a 	cmpne	r2,r2,zero
 909c708:	1000651e 	bne	r2,zero,909c8a0 <getPHYSpeed+0x2c0>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909c70c:	00800044 	movi	r2,1
 909c710:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909c714:	00800044 	movi	r2,1
 909c718:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 909c71c:	e0bfa103 	ldbu	r2,-380(fp)
 909c720:	1080004c 	andi	r2,r2,1
 909c724:	e0bff715 	stw	r2,-36(fp)
 909c728:	e0bfa143 	ldbu	r2,-379(fp)
 909c72c:	10800098 	cmpnei	r2,r2,2
 909c730:	1000031e 	bne	r2,zero,909c740 <getPHYSpeed+0x160>
 909c734:	00800084 	movi	r2,2
 909c738:	e0bff615 	stw	r2,-40(fp)
 909c73c:	00000106 	br	909c744 <getPHYSpeed+0x164>
 909c740:	e03ff615 	stw	zero,-40(fp)
 909c744:	e0fff717 	ldw	r3,-36(fp)
 909c748:	e13ff617 	ldw	r4,-40(fp)
 909c74c:	1906b03a 	or	r3,r3,r4
 909c750:	e0fff515 	stw	r3,-44(fp)
 909c754:	e0bfa143 	ldbu	r2,-379(fp)
 909c758:	10800058 	cmpnei	r2,r2,1
 909c75c:	1000031e 	bne	r2,zero,909c76c <getPHYSpeed+0x18c>
 909c760:	00800104 	movi	r2,4
 909c764:	e0bff415 	stw	r2,-48(fp)
 909c768:	00000106 	br	909c770 <getPHYSpeed+0x190>
 909c76c:	e03ff415 	stw	zero,-48(fp)
 909c770:	e0fff517 	ldw	r3,-44(fp)
 909c774:	e13ff417 	ldw	r4,-48(fp)
 909c778:	1906b03a 	or	r3,r3,r4
 909c77c:	e0fff315 	stw	r3,-52(fp)
 909c780:	e0bfa143 	ldbu	r2,-379(fp)
 909c784:	1004c03a 	cmpne	r2,r2,zero
 909c788:	1000031e 	bne	r2,zero,909c798 <getPHYSpeed+0x1b8>
 909c78c:	00800204 	movi	r2,8
 909c790:	e0bff215 	stw	r2,-56(fp)
 909c794:	00000106 	br	909c79c <getPHYSpeed+0x1bc>
 909c798:	e03ff215 	stw	zero,-56(fp)
 909c79c:	e0fff317 	ldw	r3,-52(fp)
 909c7a0:	e13ff217 	ldw	r4,-56(fp)
 909c7a4:	1906b03a 	or	r3,r3,r4
 909c7a8:	e0fff115 	stw	r3,-60(fp)
 909c7ac:	e0bfa143 	ldbu	r2,-379(fp)
 909c7b0:	108000d8 	cmpnei	r2,r2,3
 909c7b4:	1000031e 	bne	r2,zero,909c7c4 <getPHYSpeed+0x1e4>
 909c7b8:	00800074 	movhi	r2,1
 909c7bc:	e0bff015 	stw	r2,-64(fp)
 909c7c0:	00000106 	br	909c7c8 <getPHYSpeed+0x1e8>
 909c7c4:	e03ff015 	stw	zero,-64(fp)
 909c7c8:	e0fff117 	ldw	r3,-60(fp)
 909c7cc:	e13ff017 	ldw	r4,-64(fp)
 909c7d0:	1904b03a 	or	r2,r3,r4
 909c7d4:	10802034 	orhi	r2,r2,128
 909c7d8:	e0bfa015 	stw	r2,-384(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 909c7dc:	e0bfa143 	ldbu	r2,-379(fp)
 909c7e0:	108000a0 	cmpeqi	r2,r2,2
 909c7e4:	1000161e 	bne	r2,zero,909c840 <getPHYSpeed+0x260>
 909c7e8:	e0bfa143 	ldbu	r2,-379(fp)
 909c7ec:	10800060 	cmpeqi	r2,r2,1
 909c7f0:	10000d1e 	bne	r2,zero,909c828 <getPHYSpeed+0x248>
 909c7f4:	e0bfa143 	ldbu	r2,-379(fp)
 909c7f8:	1004c03a 	cmpne	r2,r2,zero
 909c7fc:	1000041e 	bne	r2,zero,909c810 <getPHYSpeed+0x230>
 909c800:	00824374 	movhi	r2,2317
 909c804:	10b77c04 	addi	r2,r2,-8720
 909c808:	e0bfed15 	stw	r2,-76(fp)
 909c80c:	00000306 	br	909c81c <getPHYSpeed+0x23c>
 909c810:	00c24374 	movhi	r3,2317
 909c814:	18f77d04 	addi	r3,r3,-8716
 909c818:	e0ffed15 	stw	r3,-76(fp)
 909c81c:	e13fed17 	ldw	r4,-76(fp)
 909c820:	e13fee15 	stw	r4,-72(fp)
 909c824:	00000306 	br	909c834 <getPHYSpeed+0x254>
 909c828:	00824374 	movhi	r2,2317
 909c82c:	10b77f04 	addi	r2,r2,-8708
 909c830:	e0bfee15 	stw	r2,-72(fp)
 909c834:	e0ffee17 	ldw	r3,-72(fp)
 909c838:	e0ffef15 	stw	r3,-68(fp)
 909c83c:	00000306 	br	909c84c <getPHYSpeed+0x26c>
 909c840:	01024374 	movhi	r4,2317
 909c844:	21378004 	addi	r4,r4,-8704
 909c848:	e13fef15 	stw	r4,-68(fp)
 909c84c:	e0bfa103 	ldbu	r2,-380(fp)
 909c850:	10800058 	cmpnei	r2,r2,1
 909c854:	1000041e 	bne	r2,zero,909c868 <getPHYSpeed+0x288>
 909c858:	00824374 	movhi	r2,2317
 909c85c:	10b78204 	addi	r2,r2,-8696
 909c860:	e0bfec15 	stw	r2,-80(fp)
 909c864:	00000306 	br	909c874 <getPHYSpeed+0x294>
 909c868:	00c24374 	movhi	r3,2317
 909c86c:	18f78404 	addi	r3,r3,-8688
 909c870:	e0ffec15 	stw	r3,-80(fp)
 909c874:	01024374 	movhi	r4,2317
 909c878:	21378604 	addi	r4,r4,-8680
 909c87c:	e17fef17 	ldw	r5,-68(fp)
 909c880:	e1bfec17 	ldw	r6,-80(fp)
 909c884:	90833900 	call	9083390 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 909c888:	01024374 	movhi	r4,2317
 909c88c:	21379e04 	addi	r4,r4,-8584
 909c890:	90836b80 	call	90836b8 <puts>
        return result;
 909c894:	e13fa017 	ldw	r4,-384(fp)
 909c898:	e13feb15 	stw	r4,-84(fp)
 909c89c:	0002cc06 	br	909d3d0 <getPHYSpeed+0xdf0>
    }
    
    pphy = pmac_info->pphy_info;
 909c8a0:	e0bf9e17 	ldw	r2,-392(fp)
 909c8a4:	10800117 	ldw	r2,4(r2)
 909c8a8:	e0bf9f15 	stw	r2,-388(fp)
    pmac_group = pmac_info->pmac_group;
 909c8ac:	e0bf9e17 	ldw	r2,-392(fp)
 909c8b0:	10800317 	ldw	r2,12(r2)
 909c8b4:	e0bf9d15 	stw	r2,-396(fp)
    psys = pmac_info->psys_info;
 909c8b8:	e0bf9e17 	ldw	r2,-392(fp)
 909c8bc:	10800217 	ldw	r2,8(r2)
 909c8c0:	e0bf9c15 	stw	r2,-400(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909c8c4:	e13f9e17 	ldw	r4,-392(fp)
 909c8c8:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909c8cc:	e0bf9b45 	stb	r2,-403(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909c8d0:	e13f9d17 	ldw	r4,-396(fp)
 909c8d4:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909c8d8:	e0bf9b05 	stb	r2,-404(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 909c8dc:	e0bf9d17 	ldw	r2,-396(fp)
 909c8e0:	10800117 	ldw	r2,4(r2)
 909c8e4:	10800217 	ldw	r2,8(r2)
 909c8e8:	10800203 	ldbu	r2,8(r2)
 909c8ec:	10803fcc 	andi	r2,r2,255
 909c8f0:	1004c03a 	cmpne	r2,r2,zero
 909c8f4:	1000771e 	bne	r2,zero,909cad4 <getPHYSpeed+0x4f4>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909c8f8:	00800044 	movi	r2,1
 909c8fc:	e0bfa145 	stb	r2,-379(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909c900:	00800044 	movi	r2,1
 909c904:	e0bfa105 	stb	r2,-380(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 909c908:	e0bfa103 	ldbu	r2,-380(fp)
 909c90c:	1080004c 	andi	r2,r2,1
 909c910:	e0bfea15 	stw	r2,-88(fp)
 909c914:	e0bfa143 	ldbu	r2,-379(fp)
 909c918:	10800098 	cmpnei	r2,r2,2
 909c91c:	1000031e 	bne	r2,zero,909c92c <getPHYSpeed+0x34c>
 909c920:	00800084 	movi	r2,2
 909c924:	e0bfe915 	stw	r2,-92(fp)
 909c928:	00000106 	br	909c930 <getPHYSpeed+0x350>
 909c92c:	e03fe915 	stw	zero,-92(fp)
 909c930:	e0ffea17 	ldw	r3,-88(fp)
 909c934:	e13fe917 	ldw	r4,-92(fp)
 909c938:	1906b03a 	or	r3,r3,r4
 909c93c:	e0ffe815 	stw	r3,-96(fp)
 909c940:	e0bfa143 	ldbu	r2,-379(fp)
 909c944:	10800058 	cmpnei	r2,r2,1
 909c948:	1000031e 	bne	r2,zero,909c958 <getPHYSpeed+0x378>
 909c94c:	00800104 	movi	r2,4
 909c950:	e0bfe715 	stw	r2,-100(fp)
 909c954:	00000106 	br	909c95c <getPHYSpeed+0x37c>
 909c958:	e03fe715 	stw	zero,-100(fp)
 909c95c:	e0ffe817 	ldw	r3,-96(fp)
 909c960:	e13fe717 	ldw	r4,-100(fp)
 909c964:	1906b03a 	or	r3,r3,r4
 909c968:	e0ffe615 	stw	r3,-104(fp)
 909c96c:	e0bfa143 	ldbu	r2,-379(fp)
 909c970:	1004c03a 	cmpne	r2,r2,zero
 909c974:	1000031e 	bne	r2,zero,909c984 <getPHYSpeed+0x3a4>
 909c978:	00800204 	movi	r2,8
 909c97c:	e0bfe515 	stw	r2,-108(fp)
 909c980:	00000106 	br	909c988 <getPHYSpeed+0x3a8>
 909c984:	e03fe515 	stw	zero,-108(fp)
 909c988:	e0ffe617 	ldw	r3,-104(fp)
 909c98c:	e13fe517 	ldw	r4,-108(fp)
 909c990:	1906b03a 	or	r3,r3,r4
 909c994:	e0ffe415 	stw	r3,-112(fp)
 909c998:	e0bfa143 	ldbu	r2,-379(fp)
 909c99c:	108000d8 	cmpnei	r2,r2,3
 909c9a0:	1000031e 	bne	r2,zero,909c9b0 <getPHYSpeed+0x3d0>
 909c9a4:	00800074 	movhi	r2,1
 909c9a8:	e0bfe315 	stw	r2,-116(fp)
 909c9ac:	00000106 	br	909c9b4 <getPHYSpeed+0x3d4>
 909c9b0:	e03fe315 	stw	zero,-116(fp)
 909c9b4:	e0ffe417 	ldw	r3,-112(fp)
 909c9b8:	e13fe317 	ldw	r4,-116(fp)
 909c9bc:	1904b03a 	or	r2,r3,r4
 909c9c0:	10801034 	orhi	r2,r2,64
 909c9c4:	e0bfa015 	stw	r2,-384(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 909c9c8:	010003f4 	movhi	r4,15
 909c9cc:	21109004 	addi	r4,r4,16960
 909c9d0:	90baa880 	call	90baa88 <usleep>
        if(psys->tse_phy_cfg) {
 909c9d4:	e0bf9c17 	ldw	r2,-400(fp)
 909c9d8:	10801117 	ldw	r2,68(r2)
 909c9dc:	1005003a 	cmpeq	r2,r2,zero
 909c9e0:	10000b1e 	bne	r2,zero,909ca10 <getPHYSpeed+0x430>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 909c9e4:	e17f9b07 	ldb	r5,-404(fp)
 909c9e8:	e1bf9b47 	ldb	r6,-403(fp)
 909c9ec:	01024374 	movhi	r4,2317
 909c9f0:	2137af04 	addi	r4,r4,-8516
 909c9f4:	90833900 	call	9083390 <printf>
        	result = psys->tse_phy_cfg(pmac);
 909c9f8:	e0bf9c17 	ldw	r2,-400(fp)
 909c9fc:	10801117 	ldw	r2,68(r2)
 909ca00:	e13fa217 	ldw	r4,-376(fp)
 909ca04:	103ee83a 	callr	r2
 909ca08:	e0bfa015 	stw	r2,-384(fp)
 909ca0c:	00002e06 	br	909cac8 <getPHYSpeed+0x4e8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909ca10:	e0bf9b07 	ldb	r2,-404(fp)
 909ca14:	e0bfe215 	stw	r2,-120(fp)
 909ca18:	e0bfa143 	ldbu	r2,-379(fp)
 909ca1c:	108000a0 	cmpeqi	r2,r2,2
 909ca20:	1000161e 	bne	r2,zero,909ca7c <getPHYSpeed+0x49c>
 909ca24:	e0bfa143 	ldbu	r2,-379(fp)
 909ca28:	10800060 	cmpeqi	r2,r2,1
 909ca2c:	10000d1e 	bne	r2,zero,909ca64 <getPHYSpeed+0x484>
 909ca30:	e0bfa143 	ldbu	r2,-379(fp)
 909ca34:	1004c03a 	cmpne	r2,r2,zero
 909ca38:	1000041e 	bne	r2,zero,909ca4c <getPHYSpeed+0x46c>
 909ca3c:	00c24374 	movhi	r3,2317
 909ca40:	18f77c04 	addi	r3,r3,-8720
 909ca44:	e0ffdf15 	stw	r3,-132(fp)
 909ca48:	00000306 	br	909ca58 <getPHYSpeed+0x478>
 909ca4c:	01024374 	movhi	r4,2317
 909ca50:	21377d04 	addi	r4,r4,-8716
 909ca54:	e13fdf15 	stw	r4,-132(fp)
 909ca58:	e0bfdf17 	ldw	r2,-132(fp)
 909ca5c:	e0bfe015 	stw	r2,-128(fp)
 909ca60:	00000306 	br	909ca70 <getPHYSpeed+0x490>
 909ca64:	00c24374 	movhi	r3,2317
 909ca68:	18f77f04 	addi	r3,r3,-8708
 909ca6c:	e0ffe015 	stw	r3,-128(fp)
 909ca70:	e13fe017 	ldw	r4,-128(fp)
 909ca74:	e13fe115 	stw	r4,-124(fp)
 909ca78:	00000306 	br	909ca88 <getPHYSpeed+0x4a8>
 909ca7c:	00824374 	movhi	r2,2317
 909ca80:	10b78004 	addi	r2,r2,-8704
 909ca84:	e0bfe115 	stw	r2,-124(fp)
 909ca88:	e0bfa103 	ldbu	r2,-380(fp)
 909ca8c:	10800058 	cmpnei	r2,r2,1
 909ca90:	1000041e 	bne	r2,zero,909caa4 <getPHYSpeed+0x4c4>
 909ca94:	00c24374 	movhi	r3,2317
 909ca98:	18f78204 	addi	r3,r3,-8696
 909ca9c:	e0ffde15 	stw	r3,-136(fp)
 909caa0:	00000306 	br	909cab0 <getPHYSpeed+0x4d0>
 909caa4:	01024374 	movhi	r4,2317
 909caa8:	21378404 	addi	r4,r4,-8688
 909caac:	e13fde15 	stw	r4,-136(fp)
 909cab0:	01024374 	movhi	r4,2317
 909cab4:	2137c104 	addi	r4,r4,-8444
 909cab8:	e17fe217 	ldw	r5,-120(fp)
 909cabc:	e1bfe117 	ldw	r6,-124(fp)
 909cac0:	e1ffde17 	ldw	r7,-136(fp)
 909cac4:	90833900 	call	9083390 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 909cac8:	e0bfa017 	ldw	r2,-384(fp)
 909cacc:	e0bfeb15 	stw	r2,-84(fp)
 909cad0:	00023f06 	br	909d3d0 <getPHYSpeed+0xdf0>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909cad4:	e0bf9d17 	ldw	r2,-396(fp)
 909cad8:	10800117 	ldw	r2,4(r2)
 909cadc:	10800217 	ldw	r2,8(r2)
 909cae0:	10800017 	ldw	r2,0(r2)
 909cae4:	e0bf9a15 	stw	r2,-408(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 909cae8:	e0bf9f17 	ldw	r2,-388(fp)
 909caec:	1004c03a 	cmpne	r2,r2,zero
 909caf0:	1000691e 	bne	r2,zero,909cc98 <getPHYSpeed+0x6b8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909caf4:	00800044 	movi	r2,1
 909caf8:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909cafc:	00800044 	movi	r2,1
 909cb00:	e0bfa105 	stb	r2,-380(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 909cb04:	e0bfa103 	ldbu	r2,-380(fp)
 909cb08:	1080004c 	andi	r2,r2,1
 909cb0c:	e0bfdd15 	stw	r2,-140(fp)
 909cb10:	e0bfa143 	ldbu	r2,-379(fp)
 909cb14:	10800098 	cmpnei	r2,r2,2
 909cb18:	1000031e 	bne	r2,zero,909cb28 <getPHYSpeed+0x548>
 909cb1c:	00c00084 	movi	r3,2
 909cb20:	e0ffdc15 	stw	r3,-144(fp)
 909cb24:	00000106 	br	909cb2c <getPHYSpeed+0x54c>
 909cb28:	e03fdc15 	stw	zero,-144(fp)
 909cb2c:	e13fdd17 	ldw	r4,-140(fp)
 909cb30:	e0bfdc17 	ldw	r2,-144(fp)
 909cb34:	2088b03a 	or	r4,r4,r2
 909cb38:	e13fdb15 	stw	r4,-148(fp)
 909cb3c:	e0bfa143 	ldbu	r2,-379(fp)
 909cb40:	10800058 	cmpnei	r2,r2,1
 909cb44:	1000031e 	bne	r2,zero,909cb54 <getPHYSpeed+0x574>
 909cb48:	00c00104 	movi	r3,4
 909cb4c:	e0ffda15 	stw	r3,-152(fp)
 909cb50:	00000106 	br	909cb58 <getPHYSpeed+0x578>
 909cb54:	e03fda15 	stw	zero,-152(fp)
 909cb58:	e13fdb17 	ldw	r4,-148(fp)
 909cb5c:	e0bfda17 	ldw	r2,-152(fp)
 909cb60:	2088b03a 	or	r4,r4,r2
 909cb64:	e13fd915 	stw	r4,-156(fp)
 909cb68:	e0bfa143 	ldbu	r2,-379(fp)
 909cb6c:	1004c03a 	cmpne	r2,r2,zero
 909cb70:	1000031e 	bne	r2,zero,909cb80 <getPHYSpeed+0x5a0>
 909cb74:	00c00204 	movi	r3,8
 909cb78:	e0ffd815 	stw	r3,-160(fp)
 909cb7c:	00000106 	br	909cb84 <getPHYSpeed+0x5a4>
 909cb80:	e03fd815 	stw	zero,-160(fp)
 909cb84:	e13fd917 	ldw	r4,-156(fp)
 909cb88:	e0bfd817 	ldw	r2,-160(fp)
 909cb8c:	2088b03a 	or	r4,r4,r2
 909cb90:	e13fd715 	stw	r4,-164(fp)
 909cb94:	e0bfa143 	ldbu	r2,-379(fp)
 909cb98:	108000d8 	cmpnei	r2,r2,3
 909cb9c:	1000031e 	bne	r2,zero,909cbac <getPHYSpeed+0x5cc>
 909cba0:	00c00074 	movhi	r3,1
 909cba4:	e0ffd615 	stw	r3,-168(fp)
 909cba8:	00000106 	br	909cbb0 <getPHYSpeed+0x5d0>
 909cbac:	e03fd615 	stw	zero,-168(fp)
 909cbb0:	e13fd717 	ldw	r4,-164(fp)
 909cbb4:	e0ffd617 	ldw	r3,-168(fp)
 909cbb8:	20c4b03a 	or	r2,r4,r3
 909cbbc:	10800834 	orhi	r2,r2,32
 909cbc0:	e0bfa015 	stw	r2,-384(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909cbc4:	e13f9b07 	ldb	r4,-404(fp)
 909cbc8:	e13fd515 	stw	r4,-172(fp)
 909cbcc:	e0bf9b47 	ldb	r2,-403(fp)
 909cbd0:	e0bfd415 	stw	r2,-176(fp)
 909cbd4:	e0bfa143 	ldbu	r2,-379(fp)
 909cbd8:	108000a0 	cmpeqi	r2,r2,2
 909cbdc:	1000161e 	bne	r2,zero,909cc38 <getPHYSpeed+0x658>
 909cbe0:	e0bfa143 	ldbu	r2,-379(fp)
 909cbe4:	10800060 	cmpeqi	r2,r2,1
 909cbe8:	10000d1e 	bne	r2,zero,909cc20 <getPHYSpeed+0x640>
 909cbec:	e0bfa143 	ldbu	r2,-379(fp)
 909cbf0:	1004c03a 	cmpne	r2,r2,zero
 909cbf4:	1000041e 	bne	r2,zero,909cc08 <getPHYSpeed+0x628>
 909cbf8:	00c24374 	movhi	r3,2317
 909cbfc:	18f77c04 	addi	r3,r3,-8720
 909cc00:	e0ffd115 	stw	r3,-188(fp)
 909cc04:	00000306 	br	909cc14 <getPHYSpeed+0x634>
 909cc08:	01024374 	movhi	r4,2317
 909cc0c:	21377d04 	addi	r4,r4,-8716
 909cc10:	e13fd115 	stw	r4,-188(fp)
 909cc14:	e0bfd117 	ldw	r2,-188(fp)
 909cc18:	e0bfd215 	stw	r2,-184(fp)
 909cc1c:	00000306 	br	909cc2c <getPHYSpeed+0x64c>
 909cc20:	00c24374 	movhi	r3,2317
 909cc24:	18f77f04 	addi	r3,r3,-8708
 909cc28:	e0ffd215 	stw	r3,-184(fp)
 909cc2c:	e13fd217 	ldw	r4,-184(fp)
 909cc30:	e13fd315 	stw	r4,-180(fp)
 909cc34:	00000306 	br	909cc44 <getPHYSpeed+0x664>
 909cc38:	00824374 	movhi	r2,2317
 909cc3c:	10b78004 	addi	r2,r2,-8704
 909cc40:	e0bfd315 	stw	r2,-180(fp)
 909cc44:	e0bfa103 	ldbu	r2,-380(fp)
 909cc48:	10800058 	cmpnei	r2,r2,1
 909cc4c:	1000041e 	bne	r2,zero,909cc60 <getPHYSpeed+0x680>
 909cc50:	00c24374 	movhi	r3,2317
 909cc54:	18f78204 	addi	r3,r3,-8696
 909cc58:	e0ffd015 	stw	r3,-192(fp)
 909cc5c:	00000306 	br	909cc6c <getPHYSpeed+0x68c>
 909cc60:	01024374 	movhi	r4,2317
 909cc64:	21378404 	addi	r4,r4,-8688
 909cc68:	e13fd015 	stw	r4,-192(fp)
 909cc6c:	e0bfd017 	ldw	r2,-192(fp)
 909cc70:	d8800015 	stw	r2,0(sp)
 909cc74:	01024374 	movhi	r4,2317
 909cc78:	2137d304 	addi	r4,r4,-8372
 909cc7c:	e17fd517 	ldw	r5,-172(fp)
 909cc80:	e1bfd417 	ldw	r6,-176(fp)
 909cc84:	e1ffd317 	ldw	r7,-180(fp)
 909cc88:	90833900 	call	9083390 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 909cc8c:	e0ffa017 	ldw	r3,-384(fp)
 909cc90:	e0ffeb15 	stw	r3,-84(fp)
 909cc94:	0001ce06 	br	909d3d0 <getPHYSpeed+0xdf0>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 909cc98:	e0bf9e17 	ldw	r2,-392(fp)
 909cc9c:	10800003 	ldbu	r2,0(r2)
 909cca0:	10803fcc 	andi	r2,r2,255
 909cca4:	10800058 	cmpnei	r2,r2,1
 909cca8:	1000081e 	bne	r2,zero,909cccc <getPHYSpeed+0x6ec>
			alt_tse_phy_set_adv_1000(pphy, 0);
 909ccac:	e13f9f17 	ldw	r4,-388(fp)
 909ccb0:	000b883a 	mov	r5,zero
 909ccb4:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909ccb8:	e13f9f17 	ldw	r4,-388(fp)
 909ccbc:	01400134 	movhi	r5,4
 909ccc0:	29742404 	addi	r5,r5,-12144
 909ccc4:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
 909ccc8:	00000f06 	br	909cd08 <getPHYSpeed+0x728>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 909cccc:	e0bf9e17 	ldw	r2,-392(fp)
 909ccd0:	10800003 	ldbu	r2,0(r2)
 909ccd4:	10803fcc 	andi	r2,r2,255
 909ccd8:	10800098 	cmpnei	r2,r2,2
 909ccdc:	10000a1e 	bne	r2,zero,909cd08 <getPHYSpeed+0x728>
			alt_tse_phy_set_adv_100(pphy, 0);
 909cce0:	e13f9f17 	ldw	r4,-388(fp)
 909cce4:	000b883a 	mov	r5,zero
 909cce8:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 909ccec:	e13f9f17 	ldw	r4,-388(fp)
 909ccf0:	000b883a 	mov	r5,zero
 909ccf4:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909ccf8:	e13f9f17 	ldw	r4,-388(fp)
 909ccfc:	01400134 	movhi	r5,4
 909cd00:	29742404 	addi	r5,r5,-12144
 909cd04:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 909cd08:	e13f9f17 	ldw	r4,-388(fp)
 909cd0c:	01400134 	movhi	r5,4
 909cd10:	29742404 	addi	r5,r5,-12144
 909cd14:	909ec180 	call	909ec18 <alt_tse_phy_check_link>
 909cd18:	10bfffd8 	cmpnei	r2,r2,-1
 909cd1c:	1000691e 	bne	r2,zero,909cec4 <getPHYSpeed+0x8e4>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909cd20:	00800044 	movi	r2,1
 909cd24:	e0bfa145 	stb	r2,-379(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909cd28:	00800044 	movi	r2,1
 909cd2c:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 909cd30:	e0bfa103 	ldbu	r2,-380(fp)
 909cd34:	1080004c 	andi	r2,r2,1
 909cd38:	e0bfcf15 	stw	r2,-196(fp)
 909cd3c:	e0bfa143 	ldbu	r2,-379(fp)
 909cd40:	10800098 	cmpnei	r2,r2,2
 909cd44:	1000031e 	bne	r2,zero,909cd54 <getPHYSpeed+0x774>
 909cd48:	01000084 	movi	r4,2
 909cd4c:	e13fce15 	stw	r4,-200(fp)
 909cd50:	00000106 	br	909cd58 <getPHYSpeed+0x778>
 909cd54:	e03fce15 	stw	zero,-200(fp)
 909cd58:	e0bfcf17 	ldw	r2,-196(fp)
 909cd5c:	e0ffce17 	ldw	r3,-200(fp)
 909cd60:	10c4b03a 	or	r2,r2,r3
 909cd64:	e0bfcd15 	stw	r2,-204(fp)
 909cd68:	e0bfa143 	ldbu	r2,-379(fp)
 909cd6c:	10800058 	cmpnei	r2,r2,1
 909cd70:	1000031e 	bne	r2,zero,909cd80 <getPHYSpeed+0x7a0>
 909cd74:	01000104 	movi	r4,4
 909cd78:	e13fcc15 	stw	r4,-208(fp)
 909cd7c:	00000106 	br	909cd84 <getPHYSpeed+0x7a4>
 909cd80:	e03fcc15 	stw	zero,-208(fp)
 909cd84:	e0bfcd17 	ldw	r2,-204(fp)
 909cd88:	e0ffcc17 	ldw	r3,-208(fp)
 909cd8c:	10c4b03a 	or	r2,r2,r3
 909cd90:	e0bfcb15 	stw	r2,-212(fp)
 909cd94:	e0bfa143 	ldbu	r2,-379(fp)
 909cd98:	1004c03a 	cmpne	r2,r2,zero
 909cd9c:	1000031e 	bne	r2,zero,909cdac <getPHYSpeed+0x7cc>
 909cda0:	01000204 	movi	r4,8
 909cda4:	e13fca15 	stw	r4,-216(fp)
 909cda8:	00000106 	br	909cdb0 <getPHYSpeed+0x7d0>
 909cdac:	e03fca15 	stw	zero,-216(fp)
 909cdb0:	e0bfcb17 	ldw	r2,-212(fp)
 909cdb4:	e0ffca17 	ldw	r3,-216(fp)
 909cdb8:	10c4b03a 	or	r2,r2,r3
 909cdbc:	e0bfc915 	stw	r2,-220(fp)
 909cdc0:	e0bfa143 	ldbu	r2,-379(fp)
 909cdc4:	108000d8 	cmpnei	r2,r2,3
 909cdc8:	1000031e 	bne	r2,zero,909cdd8 <getPHYSpeed+0x7f8>
 909cdcc:	01000074 	movhi	r4,1
 909cdd0:	e13fc815 	stw	r4,-224(fp)
 909cdd4:	00000106 	br	909cddc <getPHYSpeed+0x7fc>
 909cdd8:	e03fc815 	stw	zero,-224(fp)
 909cddc:	e0ffc917 	ldw	r3,-220(fp)
 909cde0:	e13fc817 	ldw	r4,-224(fp)
 909cde4:	1904b03a 	or	r2,r3,r4
 909cde8:	10800234 	orhi	r2,r2,8
 909cdec:	e0bfa015 	stw	r2,-384(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909cdf0:	e0bf9b07 	ldb	r2,-404(fp)
 909cdf4:	e0bfc715 	stw	r2,-228(fp)
 909cdf8:	e0ff9b47 	ldb	r3,-403(fp)
 909cdfc:	e0ffc615 	stw	r3,-232(fp)
 909ce00:	e0bfa143 	ldbu	r2,-379(fp)
 909ce04:	108000a0 	cmpeqi	r2,r2,2
 909ce08:	1000161e 	bne	r2,zero,909ce64 <getPHYSpeed+0x884>
 909ce0c:	e0bfa143 	ldbu	r2,-379(fp)
 909ce10:	10800060 	cmpeqi	r2,r2,1
 909ce14:	10000d1e 	bne	r2,zero,909ce4c <getPHYSpeed+0x86c>
 909ce18:	e0bfa143 	ldbu	r2,-379(fp)
 909ce1c:	1004c03a 	cmpne	r2,r2,zero
 909ce20:	1000041e 	bne	r2,zero,909ce34 <getPHYSpeed+0x854>
 909ce24:	01024374 	movhi	r4,2317
 909ce28:	21377c04 	addi	r4,r4,-8720
 909ce2c:	e13fc315 	stw	r4,-244(fp)
 909ce30:	00000306 	br	909ce40 <getPHYSpeed+0x860>
 909ce34:	00824374 	movhi	r2,2317
 909ce38:	10b77d04 	addi	r2,r2,-8716
 909ce3c:	e0bfc315 	stw	r2,-244(fp)
 909ce40:	e0ffc317 	ldw	r3,-244(fp)
 909ce44:	e0ffc415 	stw	r3,-240(fp)
 909ce48:	00000306 	br	909ce58 <getPHYSpeed+0x878>
 909ce4c:	01024374 	movhi	r4,2317
 909ce50:	21377f04 	addi	r4,r4,-8708
 909ce54:	e13fc415 	stw	r4,-240(fp)
 909ce58:	e0bfc417 	ldw	r2,-240(fp)
 909ce5c:	e0bfc515 	stw	r2,-236(fp)
 909ce60:	00000306 	br	909ce70 <getPHYSpeed+0x890>
 909ce64:	00c24374 	movhi	r3,2317
 909ce68:	18f78004 	addi	r3,r3,-8704
 909ce6c:	e0ffc515 	stw	r3,-236(fp)
 909ce70:	e0bfa103 	ldbu	r2,-380(fp)
 909ce74:	10800058 	cmpnei	r2,r2,1
 909ce78:	1000041e 	bne	r2,zero,909ce8c <getPHYSpeed+0x8ac>
 909ce7c:	01024374 	movhi	r4,2317
 909ce80:	21378204 	addi	r4,r4,-8696
 909ce84:	e13fc215 	stw	r4,-248(fp)
 909ce88:	00000306 	br	909ce98 <getPHYSpeed+0x8b8>
 909ce8c:	00824374 	movhi	r2,2317
 909ce90:	10b78404 	addi	r2,r2,-8688
 909ce94:	e0bfc215 	stw	r2,-248(fp)
 909ce98:	e0ffc217 	ldw	r3,-248(fp)
 909ce9c:	d8c00015 	stw	r3,0(sp)
 909cea0:	01024374 	movhi	r4,2317
 909cea4:	2137e404 	addi	r4,r4,-8304
 909cea8:	e17fc717 	ldw	r5,-228(fp)
 909ceac:	e1bfc617 	ldw	r6,-232(fp)
 909ceb0:	e1ffc517 	ldw	r7,-236(fp)
 909ceb4:	90833900 	call	9083390 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 909ceb8:	e13fa017 	ldw	r4,-384(fp)
 909cebc:	e13feb15 	stw	r4,-84(fp)
 909cec0:	00014306 	br	909d3d0 <getPHYSpeed+0xdf0>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 909cec4:	e0bf9a17 	ldw	r2,-408(fp)
 909cec8:	10801004 	addi	r2,r2,64
 909cecc:	1009883a 	mov	r4,r2
 909ced0:	e0bf9f17 	ldw	r2,-388(fp)
 909ced4:	10800003 	ldbu	r2,0(r2)
 909ced8:	10c03fcc 	andi	r3,r2,255
 909cedc:	2005883a 	mov	r2,r4
 909cee0:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 909cee4:	d8000015 	stw	zero,0(sp)
 909cee8:	e13f9f17 	ldw	r4,-388(fp)
 909ceec:	000b883a 	mov	r5,zero
 909cef0:	01800384 	movi	r6,14
 909cef4:	01c00044 	movi	r7,1
 909cef8:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 909cefc:	e0bf9f17 	ldw	r2,-388(fp)
 909cf00:	10800517 	ldw	r2,20(r2)
 909cf04:	1004c03a 	cmpne	r2,r2,zero
 909cf08:	10003a1e 	bne	r2,zero,909cff4 <getPHYSpeed+0xa14>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 909cf0c:	e17f9b07 	ldb	r5,-404(fp)
 909cf10:	e1bf9b47 	ldb	r6,-403(fp)
 909cf14:	01024374 	movhi	r4,2317
 909cf18:	2137f804 	addi	r4,r4,-8224
 909cf1c:	90833900 	call	9083390 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909cf20:	00800044 	movi	r2,1
 909cf24:	e0bfa145 	stb	r2,-379(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909cf28:	00800044 	movi	r2,1
 909cf2c:	e0bfa105 	stb	r2,-380(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 909cf30:	e0bfa103 	ldbu	r2,-380(fp)
 909cf34:	1080004c 	andi	r2,r2,1
 909cf38:	e0bfc115 	stw	r2,-252(fp)
 909cf3c:	e0bfa143 	ldbu	r2,-379(fp)
 909cf40:	10800098 	cmpnei	r2,r2,2
 909cf44:	1000031e 	bne	r2,zero,909cf54 <getPHYSpeed+0x974>
 909cf48:	00800084 	movi	r2,2
 909cf4c:	e0bfc015 	stw	r2,-256(fp)
 909cf50:	00000106 	br	909cf58 <getPHYSpeed+0x978>
 909cf54:	e03fc015 	stw	zero,-256(fp)
 909cf58:	e0ffc117 	ldw	r3,-252(fp)
 909cf5c:	e13fc017 	ldw	r4,-256(fp)
 909cf60:	1906b03a 	or	r3,r3,r4
 909cf64:	e0ffbf15 	stw	r3,-260(fp)
 909cf68:	e0bfa143 	ldbu	r2,-379(fp)
 909cf6c:	10800058 	cmpnei	r2,r2,1
 909cf70:	1000031e 	bne	r2,zero,909cf80 <getPHYSpeed+0x9a0>
 909cf74:	00800104 	movi	r2,4
 909cf78:	e0bfbe15 	stw	r2,-264(fp)
 909cf7c:	00000106 	br	909cf84 <getPHYSpeed+0x9a4>
 909cf80:	e03fbe15 	stw	zero,-264(fp)
 909cf84:	e0ffbf17 	ldw	r3,-260(fp)
 909cf88:	e13fbe17 	ldw	r4,-264(fp)
 909cf8c:	1906b03a 	or	r3,r3,r4
 909cf90:	e0ffbd15 	stw	r3,-268(fp)
 909cf94:	e0bfa143 	ldbu	r2,-379(fp)
 909cf98:	1004c03a 	cmpne	r2,r2,zero
 909cf9c:	1000031e 	bne	r2,zero,909cfac <getPHYSpeed+0x9cc>
 909cfa0:	00800204 	movi	r2,8
 909cfa4:	e0bfbc15 	stw	r2,-272(fp)
 909cfa8:	00000106 	br	909cfb0 <getPHYSpeed+0x9d0>
 909cfac:	e03fbc15 	stw	zero,-272(fp)
 909cfb0:	e0ffbd17 	ldw	r3,-268(fp)
 909cfb4:	e13fbc17 	ldw	r4,-272(fp)
 909cfb8:	1906b03a 	or	r3,r3,r4
 909cfbc:	e0ffbb15 	stw	r3,-276(fp)
 909cfc0:	e0bfa143 	ldbu	r2,-379(fp)
 909cfc4:	108000d8 	cmpnei	r2,r2,3
 909cfc8:	1000031e 	bne	r2,zero,909cfd8 <getPHYSpeed+0x9f8>
 909cfcc:	00800074 	movhi	r2,1
 909cfd0:	e0bfba15 	stw	r2,-280(fp)
 909cfd4:	00000106 	br	909cfdc <getPHYSpeed+0x9fc>
 909cfd8:	e03fba15 	stw	zero,-280(fp)
 909cfdc:	e0ffbb17 	ldw	r3,-276(fp)
 909cfe0:	e13fba17 	ldw	r4,-280(fp)
 909cfe4:	1904b03a 	or	r2,r3,r4
 909cfe8:	10800134 	orhi	r2,r2,4
 909cfec:	e0bfa015 	stw	r2,-384(fp)
 909cff0:	0000c306 	br	909d300 <getPHYSpeed+0xd20>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 909cff4:	e0bf9f17 	ldw	r2,-388(fp)
 909cff8:	10800517 	ldw	r2,20(r2)
 909cffc:	10801817 	ldw	r2,96(r2)
 909d000:	1005003a 	cmpeq	r2,r2,zero
 909d004:	1000371e 	bne	r2,zero,909d0e4 <getPHYSpeed+0xb04>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 909d008:	e0bf9f17 	ldw	r2,-388(fp)
 909d00c:	10800517 	ldw	r2,20(r2)
 909d010:	10801817 	ldw	r2,96(r2)
 909d014:	e13f9a17 	ldw	r4,-408(fp)
 909d018:	103ee83a 	callr	r2
 909d01c:	e0bfa015 	stw	r2,-384(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 909d020:	e0bfa017 	ldw	r2,-384(fp)
 909d024:	1080008c 	andi	r2,r2,2
 909d028:	1004c03a 	cmpne	r2,r2,zero
 909d02c:	1000141e 	bne	r2,zero,909d080 <getPHYSpeed+0xaa0>
 909d030:	e0bfa017 	ldw	r2,-384(fp)
 909d034:	1080010c 	andi	r2,r2,4
 909d038:	1004c03a 	cmpne	r2,r2,zero
 909d03c:	10000b1e 	bne	r2,zero,909d06c <getPHYSpeed+0xa8c>
 909d040:	e0bfa017 	ldw	r2,-384(fp)
 909d044:	1080020c 	andi	r2,r2,8
 909d048:	1005003a 	cmpeq	r2,r2,zero
 909d04c:	1000021e 	bne	r2,zero,909d058 <getPHYSpeed+0xa78>
 909d050:	e03fb945 	stb	zero,-283(fp)
 909d054:	00000206 	br	909d060 <getPHYSpeed+0xa80>
 909d058:	008000c4 	movi	r2,3
 909d05c:	e0bfb945 	stb	r2,-283(fp)
 909d060:	e0ffb943 	ldbu	r3,-283(fp)
 909d064:	e0ffb985 	stb	r3,-282(fp)
 909d068:	00000206 	br	909d074 <getPHYSpeed+0xa94>
 909d06c:	01000044 	movi	r4,1
 909d070:	e13fb985 	stb	r4,-282(fp)
 909d074:	e0bfb983 	ldbu	r2,-282(fp)
 909d078:	e0bfb9c5 	stb	r2,-281(fp)
 909d07c:	00000206 	br	909d088 <getPHYSpeed+0xaa8>
 909d080:	00c00084 	movi	r3,2
 909d084:	e0ffb9c5 	stb	r3,-281(fp)
 909d088:	e13fb9c3 	ldbu	r4,-281(fp)
 909d08c:	e13fa145 	stb	r4,-379(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 909d090:	e0bfa017 	ldw	r2,-384(fp)
 909d094:	1080004c 	andi	r2,r2,1
 909d098:	10803fcc 	andi	r2,r2,255
 909d09c:	1005003a 	cmpeq	r2,r2,zero
 909d0a0:	1000031e 	bne	r2,zero,909d0b0 <getPHYSpeed+0xad0>
 909d0a4:	00800044 	movi	r2,1
 909d0a8:	e0bfb905 	stb	r2,-284(fp)
 909d0ac:	00000106 	br	909d0b4 <getPHYSpeed+0xad4>
 909d0b0:	e03fb905 	stb	zero,-284(fp)
 909d0b4:	e0ffb903 	ldbu	r3,-284(fp)
 909d0b8:	e0ffa105 	stb	r3,-380(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 909d0bc:	e0bfa017 	ldw	r2,-384(fp)
 909d0c0:	1080006c 	andhi	r2,r2,1
 909d0c4:	1005003a 	cmpeq	r2,r2,zero
 909d0c8:	10008d1e 	bne	r2,zero,909d300 <getPHYSpeed+0xd20>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 909d0cc:	e17f9b07 	ldb	r5,-404(fp)
 909d0d0:	e1bf9b47 	ldb	r6,-403(fp)
 909d0d4:	01024374 	movhi	r4,2317
 909d0d8:	21380604 	addi	r4,r4,-8168
 909d0dc:	90833900 	call	9083390 <printf>
 909d0e0:	00008706 	br	909d300 <getPHYSpeed+0xd20>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 909d0e4:	e0bf9f17 	ldw	r2,-388(fp)
 909d0e8:	10800517 	ldw	r2,20(r2)
 909d0ec:	10801583 	ldbu	r2,86(r2)
 909d0f0:	10803fcc 	andi	r2,r2,255
 909d0f4:	1004c03a 	cmpne	r2,r2,zero
 909d0f8:	10003a1e 	bne	r2,zero,909d1e4 <getPHYSpeed+0xc04>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 909d0fc:	e17f9b07 	ldb	r5,-404(fp)
 909d100:	e1bf9b47 	ldb	r6,-403(fp)
 909d104:	01024374 	movhi	r4,2317
 909d108:	21381304 	addi	r4,r4,-8116
 909d10c:	90833900 	call	9083390 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 909d110:	00800044 	movi	r2,1
 909d114:	e0bfa145 	stb	r2,-379(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 909d118:	00800044 	movi	r2,1
 909d11c:	e0bfa105 	stb	r2,-380(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 909d120:	e0bfa103 	ldbu	r2,-380(fp)
 909d124:	1080004c 	andi	r2,r2,1
 909d128:	e0bfb815 	stw	r2,-288(fp)
 909d12c:	e0bfa143 	ldbu	r2,-379(fp)
 909d130:	10800098 	cmpnei	r2,r2,2
 909d134:	1000031e 	bne	r2,zero,909d144 <getPHYSpeed+0xb64>
 909d138:	01000084 	movi	r4,2
 909d13c:	e13fb715 	stw	r4,-292(fp)
 909d140:	00000106 	br	909d148 <getPHYSpeed+0xb68>
 909d144:	e03fb715 	stw	zero,-292(fp)
 909d148:	e0bfb817 	ldw	r2,-288(fp)
 909d14c:	e0ffb717 	ldw	r3,-292(fp)
 909d150:	10c4b03a 	or	r2,r2,r3
 909d154:	e0bfb615 	stw	r2,-296(fp)
 909d158:	e0bfa143 	ldbu	r2,-379(fp)
 909d15c:	10800058 	cmpnei	r2,r2,1
 909d160:	1000031e 	bne	r2,zero,909d170 <getPHYSpeed+0xb90>
 909d164:	01000104 	movi	r4,4
 909d168:	e13fb515 	stw	r4,-300(fp)
 909d16c:	00000106 	br	909d174 <getPHYSpeed+0xb94>
 909d170:	e03fb515 	stw	zero,-300(fp)
 909d174:	e0bfb617 	ldw	r2,-296(fp)
 909d178:	e0ffb517 	ldw	r3,-300(fp)
 909d17c:	10c4b03a 	or	r2,r2,r3
 909d180:	e0bfb415 	stw	r2,-304(fp)
 909d184:	e0bfa143 	ldbu	r2,-379(fp)
 909d188:	1004c03a 	cmpne	r2,r2,zero
 909d18c:	1000031e 	bne	r2,zero,909d19c <getPHYSpeed+0xbbc>
 909d190:	01000204 	movi	r4,8
 909d194:	e13fb315 	stw	r4,-308(fp)
 909d198:	00000106 	br	909d1a0 <getPHYSpeed+0xbc0>
 909d19c:	e03fb315 	stw	zero,-308(fp)
 909d1a0:	e0bfb417 	ldw	r2,-304(fp)
 909d1a4:	e0ffb317 	ldw	r3,-308(fp)
 909d1a8:	10c4b03a 	or	r2,r2,r3
 909d1ac:	e0bfb215 	stw	r2,-312(fp)
 909d1b0:	e0bfa143 	ldbu	r2,-379(fp)
 909d1b4:	108000d8 	cmpnei	r2,r2,3
 909d1b8:	1000031e 	bne	r2,zero,909d1c8 <getPHYSpeed+0xbe8>
 909d1bc:	01000074 	movhi	r4,1
 909d1c0:	e13fb115 	stw	r4,-316(fp)
 909d1c4:	00000106 	br	909d1cc <getPHYSpeed+0xbec>
 909d1c8:	e03fb115 	stw	zero,-316(fp)
 909d1cc:	e0ffb217 	ldw	r3,-312(fp)
 909d1d0:	e13fb117 	ldw	r4,-316(fp)
 909d1d4:	1904b03a 	or	r2,r3,r4
 909d1d8:	108000b4 	orhi	r2,r2,2
 909d1dc:	e0bfa015 	stw	r2,-384(fp)
 909d1e0:	00004706 	br	909d300 <getPHYSpeed+0xd20>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 909d1e4:	e0bf9f17 	ldw	r2,-388(fp)
 909d1e8:	10800517 	ldw	r2,20(r2)
 909d1ec:	10801583 	ldbu	r2,86(r2)
 909d1f0:	11403fcc 	andi	r5,r2,255
 909d1f4:	e0bf9f17 	ldw	r2,-388(fp)
 909d1f8:	10800517 	ldw	r2,20(r2)
 909d1fc:	108015c3 	ldbu	r2,87(r2)
 909d200:	11803fcc 	andi	r6,r2,255
 909d204:	e13f9f17 	ldw	r4,-388(fp)
 909d208:	01c00084 	movi	r7,2
 909d20c:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909d210:	e0bfa145 	stb	r2,-379(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 909d214:	e0bf9f17 	ldw	r2,-388(fp)
 909d218:	10800517 	ldw	r2,20(r2)
 909d21c:	10801583 	ldbu	r2,86(r2)
 909d220:	11403fcc 	andi	r5,r2,255
 909d224:	e0bf9f17 	ldw	r2,-388(fp)
 909d228:	10800517 	ldw	r2,20(r2)
 909d22c:	10801603 	ldbu	r2,88(r2)
 909d230:	11803fcc 	andi	r6,r2,255
 909d234:	e13f9f17 	ldw	r4,-388(fp)
 909d238:	01c00044 	movi	r7,1
 909d23c:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909d240:	e0bfa105 	stb	r2,-380(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 909d244:	e0bfa103 	ldbu	r2,-380(fp)
 909d248:	1080004c 	andi	r2,r2,1
 909d24c:	e0bfb015 	stw	r2,-320(fp)
 909d250:	e0bfa143 	ldbu	r2,-379(fp)
 909d254:	10800098 	cmpnei	r2,r2,2
 909d258:	1000031e 	bne	r2,zero,909d268 <getPHYSpeed+0xc88>
 909d25c:	00800084 	movi	r2,2
 909d260:	e0bfaf15 	stw	r2,-324(fp)
 909d264:	00000106 	br	909d26c <getPHYSpeed+0xc8c>
 909d268:	e03faf15 	stw	zero,-324(fp)
 909d26c:	e0ffb017 	ldw	r3,-320(fp)
 909d270:	e13faf17 	ldw	r4,-324(fp)
 909d274:	1906b03a 	or	r3,r3,r4
 909d278:	e0ffae15 	stw	r3,-328(fp)
 909d27c:	e0bfa143 	ldbu	r2,-379(fp)
 909d280:	10800058 	cmpnei	r2,r2,1
 909d284:	1000031e 	bne	r2,zero,909d294 <getPHYSpeed+0xcb4>
 909d288:	00800104 	movi	r2,4
 909d28c:	e0bfad15 	stw	r2,-332(fp)
 909d290:	00000106 	br	909d298 <getPHYSpeed+0xcb8>
 909d294:	e03fad15 	stw	zero,-332(fp)
 909d298:	e0ffae17 	ldw	r3,-328(fp)
 909d29c:	e13fad17 	ldw	r4,-332(fp)
 909d2a0:	1906b03a 	or	r3,r3,r4
 909d2a4:	e0ffac15 	stw	r3,-336(fp)
 909d2a8:	e0bfa143 	ldbu	r2,-379(fp)
 909d2ac:	1004c03a 	cmpne	r2,r2,zero
 909d2b0:	1000031e 	bne	r2,zero,909d2c0 <getPHYSpeed+0xce0>
 909d2b4:	00800204 	movi	r2,8
 909d2b8:	e0bfab15 	stw	r2,-340(fp)
 909d2bc:	00000106 	br	909d2c4 <getPHYSpeed+0xce4>
 909d2c0:	e03fab15 	stw	zero,-340(fp)
 909d2c4:	e0ffac17 	ldw	r3,-336(fp)
 909d2c8:	e13fab17 	ldw	r4,-340(fp)
 909d2cc:	1906b03a 	or	r3,r3,r4
 909d2d0:	e0ffaa15 	stw	r3,-344(fp)
 909d2d4:	e0bfa143 	ldbu	r2,-379(fp)
 909d2d8:	108000d8 	cmpnei	r2,r2,3
 909d2dc:	1000031e 	bne	r2,zero,909d2ec <getPHYSpeed+0xd0c>
 909d2e0:	00800074 	movhi	r2,1
 909d2e4:	e0bfa915 	stw	r2,-348(fp)
 909d2e8:	00000106 	br	909d2f0 <getPHYSpeed+0xd10>
 909d2ec:	e03fa915 	stw	zero,-348(fp)
 909d2f0:	e0ffaa17 	ldw	r3,-344(fp)
 909d2f4:	e13fa917 	ldw	r4,-348(fp)
 909d2f8:	1904b03a 	or	r2,r3,r4
 909d2fc:	e0bfa015 	stw	r2,-384(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 909d300:	e0bf9b07 	ldb	r2,-404(fp)
 909d304:	e0bfa815 	stw	r2,-352(fp)
 909d308:	e0ff9b47 	ldb	r3,-403(fp)
 909d30c:	e0ffa715 	stw	r3,-356(fp)
 909d310:	e0bfa143 	ldbu	r2,-379(fp)
 909d314:	108000a0 	cmpeqi	r2,r2,2
 909d318:	1000161e 	bne	r2,zero,909d374 <getPHYSpeed+0xd94>
 909d31c:	e0bfa143 	ldbu	r2,-379(fp)
 909d320:	10800060 	cmpeqi	r2,r2,1
 909d324:	10000d1e 	bne	r2,zero,909d35c <getPHYSpeed+0xd7c>
 909d328:	e0bfa143 	ldbu	r2,-379(fp)
 909d32c:	1004c03a 	cmpne	r2,r2,zero
 909d330:	1000041e 	bne	r2,zero,909d344 <getPHYSpeed+0xd64>
 909d334:	01024374 	movhi	r4,2317
 909d338:	21377c04 	addi	r4,r4,-8720
 909d33c:	e13fa415 	stw	r4,-368(fp)
 909d340:	00000306 	br	909d350 <getPHYSpeed+0xd70>
 909d344:	00824374 	movhi	r2,2317
 909d348:	10b77d04 	addi	r2,r2,-8716
 909d34c:	e0bfa415 	stw	r2,-368(fp)
 909d350:	e0ffa417 	ldw	r3,-368(fp)
 909d354:	e0ffa515 	stw	r3,-364(fp)
 909d358:	00000306 	br	909d368 <getPHYSpeed+0xd88>
 909d35c:	01024374 	movhi	r4,2317
 909d360:	21377f04 	addi	r4,r4,-8708
 909d364:	e13fa515 	stw	r4,-364(fp)
 909d368:	e0bfa517 	ldw	r2,-364(fp)
 909d36c:	e0bfa615 	stw	r2,-360(fp)
 909d370:	00000306 	br	909d380 <getPHYSpeed+0xda0>
 909d374:	00c24374 	movhi	r3,2317
 909d378:	18f78004 	addi	r3,r3,-8704
 909d37c:	e0ffa615 	stw	r3,-360(fp)
 909d380:	e0bfa103 	ldbu	r2,-380(fp)
 909d384:	10800058 	cmpnei	r2,r2,1
 909d388:	1000041e 	bne	r2,zero,909d39c <getPHYSpeed+0xdbc>
 909d38c:	01024374 	movhi	r4,2317
 909d390:	21378204 	addi	r4,r4,-8696
 909d394:	e13fa315 	stw	r4,-372(fp)
 909d398:	00000306 	br	909d3a8 <getPHYSpeed+0xdc8>
 909d39c:	00824374 	movhi	r2,2317
 909d3a0:	10b78404 	addi	r2,r2,-8688
 909d3a4:	e0bfa315 	stw	r2,-372(fp)
 909d3a8:	e0ffa317 	ldw	r3,-372(fp)
 909d3ac:	d8c00015 	stw	r3,0(sp)
 909d3b0:	01024374 	movhi	r4,2317
 909d3b4:	21382a04 	addi	r4,r4,-8024
 909d3b8:	e17fa817 	ldw	r5,-352(fp)
 909d3bc:	e1bfa717 	ldw	r6,-356(fp)
 909d3c0:	e1ffa617 	ldw	r7,-360(fp)
 909d3c4:	90833900 	call	9083390 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 909d3c8:	e13fa017 	ldw	r4,-384(fp)
 909d3cc:	e13feb15 	stw	r4,-84(fp)
 909d3d0:	e0bfeb17 	ldw	r2,-84(fp)
}
 909d3d4:	e037883a 	mov	sp,fp
 909d3d8:	dfc00117 	ldw	ra,4(sp)
 909d3dc:	df000017 	ldw	fp,0(sp)
 909d3e0:	dec00204 	addi	sp,sp,8
 909d3e4:	f800283a 	ret

0909d3e8 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 909d3e8:	defffd04 	addi	sp,sp,-12
 909d3ec:	df000215 	stw	fp,8(sp)
 909d3f0:	df000204 	addi	fp,sp,8
 909d3f4:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909d3f8:	e0bfff17 	ldw	r2,-4(fp)
 909d3fc:	10800617 	ldw	r2,24(r2)
 909d400:	10800317 	ldw	r2,12(r2)
 909d404:	10800117 	ldw	r2,4(r2)
 909d408:	10800217 	ldw	r2,8(r2)
 909d40c:	10800017 	ldw	r2,0(r2)
 909d410:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909d414:	e0bffe17 	ldw	r2,-8(fp)
 909d418:	10801004 	addi	r2,r2,64
 909d41c:	10800037 	ldwio	r2,0(r2)
}
 909d420:	e037883a 	mov	sp,fp
 909d424:	df000017 	ldw	fp,0(sp)
 909d428:	dec00104 	addi	sp,sp,4
 909d42c:	f800283a 	ret

0909d430 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 909d430:	defffc04 	addi	sp,sp,-16
 909d434:	df000315 	stw	fp,12(sp)
 909d438:	df000304 	addi	fp,sp,12
 909d43c:	e13ffe15 	stw	r4,-8(fp)
 909d440:	e17fff05 	stb	r5,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909d444:	e0bffe17 	ldw	r2,-8(fp)
 909d448:	10800617 	ldw	r2,24(r2)
 909d44c:	10800317 	ldw	r2,12(r2)
 909d450:	10800117 	ldw	r2,4(r2)
 909d454:	10800217 	ldw	r2,8(r2)
 909d458:	10800017 	ldw	r2,0(r2)
 909d45c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 909d460:	e0bffd17 	ldw	r2,-12(fp)
 909d464:	10801004 	addi	r2,r2,64
 909d468:	e0ffff03 	ldbu	r3,-4(fp)
 909d46c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 909d470:	0005883a 	mov	r2,zero
}
 909d474:	e037883a 	mov	sp,fp
 909d478:	df000017 	ldw	fp,0(sp)
 909d47c:	dec00104 	addi	sp,sp,4
 909d480:	f800283a 	ret

0909d484 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 909d484:	defff704 	addi	sp,sp,-36
 909d488:	df000815 	stw	fp,32(sp)
 909d48c:	df000804 	addi	fp,sp,32
 909d490:	e13ffb15 	stw	r4,-20(fp)
 909d494:	e0800117 	ldw	r2,4(fp)
 909d498:	e17ffc05 	stb	r5,-16(fp)
 909d49c:	e1bffd05 	stb	r6,-12(fp)
 909d4a0:	e1fffe05 	stb	r7,-8(fp)
 909d4a4:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909d4a8:	e0bffb17 	ldw	r2,-20(fp)
 909d4ac:	10800617 	ldw	r2,24(r2)
 909d4b0:	10800317 	ldw	r2,12(r2)
 909d4b4:	10800117 	ldw	r2,4(r2)
 909d4b8:	10800217 	ldw	r2,8(r2)
 909d4bc:	10800017 	ldw	r2,0(r2)
 909d4c0:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 909d4c4:	e03ffa0d 	sth	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909d4c8:	e03ff915 	stw	zero,-28(fp)
 909d4cc:	00000906 	br	909d4f4 <alt_tse_phy_wr_mdio_reg+0x70>
    {
        bit_mask <<= 1;
 909d4d0:	e0bffa0b 	ldhu	r2,-24(fp)
 909d4d4:	1085883a 	add	r2,r2,r2
 909d4d8:	e0bffa0d 	sth	r2,-24(fp)
        bit_mask |= 0x01;        
 909d4dc:	e0bffa0b 	ldhu	r2,-24(fp)
 909d4e0:	10800054 	ori	r2,r2,1
 909d4e4:	e0bffa0d 	sth	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909d4e8:	e0bff917 	ldw	r2,-28(fp)
 909d4ec:	10800044 	addi	r2,r2,1
 909d4f0:	e0bff915 	stw	r2,-28(fp)
 909d4f4:	e0fffe03 	ldbu	r3,-8(fp)
 909d4f8:	e0bff917 	ldw	r2,-28(fp)
 909d4fc:	10fff416 	blt	r2,r3,909d4d0 <alt_tse_phy_wr_mdio_reg+0x4c>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 909d500:	e0fffa0b 	ldhu	r3,-24(fp)
 909d504:	e0bffd03 	ldbu	r2,-12(fp)
 909d508:	1884983a 	sll	r2,r3,r2
 909d50c:	e0bffa0d 	sth	r2,-24(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 909d510:	e0bff817 	ldw	r2,-32(fp)
 909d514:	1080a004 	addi	r2,r2,640
 909d518:	1007883a 	mov	r3,r2
 909d51c:	e0bffc03 	ldbu	r2,-16(fp)
 909d520:	1085883a 	add	r2,r2,r2
 909d524:	1085883a 	add	r2,r2,r2
 909d528:	1885883a 	add	r2,r3,r2
 909d52c:	10800037 	ldwio	r2,0(r2)
 909d530:	e0bffa8d 	sth	r2,-22(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 909d534:	e0bffa0b 	ldhu	r2,-24(fp)
 909d538:	0084303a 	nor	r2,zero,r2
 909d53c:	1007883a 	mov	r3,r2
 909d540:	e0bffa8b 	ldhu	r2,-22(fp)
 909d544:	1884703a 	and	r2,r3,r2
 909d548:	e0bffa8d 	sth	r2,-22(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 909d54c:	e0ffff0b 	ldhu	r3,-4(fp)
 909d550:	e0bffd03 	ldbu	r2,-12(fp)
 909d554:	1884983a 	sll	r2,r3,r2
 909d558:	1007883a 	mov	r3,r2
 909d55c:	e0bffa0b 	ldhu	r2,-24(fp)
 909d560:	1884703a 	and	r2,r3,r2
 909d564:	1007883a 	mov	r3,r2
 909d568:	e0bffa8b 	ldhu	r2,-22(fp)
 909d56c:	1884b03a 	or	r2,r3,r2
 909d570:	e0bffa8d 	sth	r2,-22(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 909d574:	e0bff817 	ldw	r2,-32(fp)
 909d578:	1080a004 	addi	r2,r2,640
 909d57c:	1007883a 	mov	r3,r2
 909d580:	e0bffc03 	ldbu	r2,-16(fp)
 909d584:	1085883a 	add	r2,r2,r2
 909d588:	1085883a 	add	r2,r2,r2
 909d58c:	1885883a 	add	r2,r3,r2
 909d590:	e0fffa8b 	ldhu	r3,-22(fp)
 909d594:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 909d598:	0005883a 	mov	r2,zero
    
}
 909d59c:	e037883a 	mov	sp,fp
 909d5a0:	df000017 	ldw	fp,0(sp)
 909d5a4:	dec00104 	addi	sp,sp,4
 909d5a8:	f800283a 	ret

0909d5ac <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 909d5ac:	defff704 	addi	sp,sp,-36
 909d5b0:	df000815 	stw	fp,32(sp)
 909d5b4:	df000804 	addi	fp,sp,32
 909d5b8:	e13ffc15 	stw	r4,-16(fp)
 909d5bc:	e17ffd05 	stb	r5,-12(fp)
 909d5c0:	e1bffe05 	stb	r6,-8(fp)
 909d5c4:	e1ffff05 	stb	r7,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909d5c8:	e0bffc17 	ldw	r2,-16(fp)
 909d5cc:	10800617 	ldw	r2,24(r2)
 909d5d0:	10800317 	ldw	r2,12(r2)
 909d5d4:	10800117 	ldw	r2,4(r2)
 909d5d8:	10800217 	ldw	r2,8(r2)
 909d5dc:	10800017 	ldw	r2,0(r2)
 909d5e0:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 909d5e4:	e03ffa15 	stw	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909d5e8:	e03ff915 	stw	zero,-28(fp)
 909d5ec:	00000906 	br	909d614 <alt_tse_phy_rd_mdio_reg+0x68>
    {
        bit_mask <<= 1;
 909d5f0:	e0bffa17 	ldw	r2,-24(fp)
 909d5f4:	1085883a 	add	r2,r2,r2
 909d5f8:	e0bffa15 	stw	r2,-24(fp)
        bit_mask |= 0x01;        
 909d5fc:	e0bffa17 	ldw	r2,-24(fp)
 909d600:	10800054 	ori	r2,r2,1
 909d604:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 909d608:	e0bff917 	ldw	r2,-28(fp)
 909d60c:	10800044 	addi	r2,r2,1
 909d610:	e0bff915 	stw	r2,-28(fp)
 909d614:	e0ffff03 	ldbu	r3,-4(fp)
 909d618:	e0bff917 	ldw	r2,-28(fp)
 909d61c:	10fff416 	blt	r2,r3,909d5f0 <alt_tse_phy_rd_mdio_reg+0x44>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 909d620:	e0bff817 	ldw	r2,-32(fp)
 909d624:	1080a004 	addi	r2,r2,640
 909d628:	1007883a 	mov	r3,r2
 909d62c:	e0bffd03 	ldbu	r2,-12(fp)
 909d630:	1085883a 	add	r2,r2,r2
 909d634:	1085883a 	add	r2,r2,r2
 909d638:	1885883a 	add	r2,r3,r2
 909d63c:	10800037 	ldwio	r2,0(r2)
 909d640:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 909d644:	e0fffb0b 	ldhu	r3,-20(fp)
 909d648:	e0bffe03 	ldbu	r2,-8(fp)
 909d64c:	1885d83a 	sra	r2,r3,r2
 909d650:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 909d654:	e0fffb0b 	ldhu	r3,-20(fp)
 909d658:	e0bffa17 	ldw	r2,-24(fp)
 909d65c:	1884703a 	and	r2,r3,r2
}
 909d660:	e037883a 	mov	sp,fp
 909d664:	df000017 	ldw	fp,0(sp)
 909d668:	dec00104 	addi	sp,sp,4
 909d66c:	f800283a 	ret

0909d670 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 909d670:	deff9a04 	addi	sp,sp,-408
 909d674:	dfc06515 	stw	ra,404(sp)
 909d678:	df006415 	stw	fp,400(sp)
 909d67c:	df006404 	addi	fp,sp,400
                            0x11,                   /* Location of Status Register                                   */
                            14,                     /* Location of Speed Status                                      */
                            13,                     /* Location of Duplex Status                                     */
                            10,                     /* Location of Link Status                                       */
                            &marvell_phy_cfg        /* Function pointer to configure Marvell PHY                     */
                           };
 909d680:	e13f9c04 	addi	r4,fp,-400
 909d684:	01801904 	movi	r6,100
 909d688:	000b883a 	mov	r5,zero
 909d68c:	90832780 	call	9083278 <memset>
 909d690:	00c24374 	movhi	r3,2317
 909d694:	18f83604 	addi	r3,r3,-7976
 909d698:	18800017 	ldw	r2,0(r3)
 909d69c:	e0bf9c15 	stw	r2,-400(fp)
 909d6a0:	18800117 	ldw	r2,4(r3)
 909d6a4:	e0bf9d15 	stw	r2,-396(fp)
 909d6a8:	18800217 	ldw	r2,8(r3)
 909d6ac:	e0bf9e15 	stw	r2,-392(fp)
 909d6b0:	18800317 	ldw	r2,12(r3)
 909d6b4:	e0bf9f15 	stw	r2,-388(fp)
 909d6b8:	e13fa004 	addi	r4,fp,-384
 909d6bc:	01801004 	movi	r6,64
 909d6c0:	000b883a 	mov	r5,zero
 909d6c4:	90832780 	call	9083278 <memset>
 909d6c8:	009410c4 	movi	r2,20547
 909d6cc:	e0bfb015 	stw	r2,-320(fp)
 909d6d0:	00800304 	movi	r2,12
 909d6d4:	e0bfb105 	stb	r2,-316(fp)
 909d6d8:	00800084 	movi	r2,2
 909d6dc:	e0bfb145 	stb	r2,-315(fp)
 909d6e0:	00800444 	movi	r2,17
 909d6e4:	e0bfb185 	stb	r2,-314(fp)
 909d6e8:	00800384 	movi	r2,14
 909d6ec:	e0bfb1c5 	stb	r2,-313(fp)
 909d6f0:	00800344 	movi	r2,13
 909d6f4:	e0bfb205 	stb	r2,-312(fp)
 909d6f8:	00800284 	movi	r2,10
 909d6fc:	e0bfb245 	stb	r2,-311(fp)
 909d700:	008242b4 	movhi	r2,2314
 909d704:	10bff604 	addi	r2,r2,-40
 909d708:	e0bfb315 	stw	r2,-308(fp)
                            0x11,                            /* Location of Status Register                                   */
                            14,                              /* Location of Speed Status                                      */
                            13,                              /* Location of Duplex Status                                     */
                            10,                              /* Location of Link Status                                       */
                            &marvell_phy_cfg                 /* Function pointer to configure Marvell PHY                     */
                           };
 909d70c:	e13fb504 	addi	r4,fp,-300
 909d710:	01801904 	movi	r6,100
 909d714:	000b883a 	mov	r5,zero
 909d718:	90832780 	call	9083278 <memset>
 909d71c:	00c24374 	movhi	r3,2317
 909d720:	18f84a04 	addi	r3,r3,-7896
 909d724:	18800017 	ldw	r2,0(r3)
 909d728:	e0bfb515 	stw	r2,-300(fp)
 909d72c:	18800117 	ldw	r2,4(r3)
 909d730:	e0bfb615 	stw	r2,-296(fp)
 909d734:	18800217 	ldw	r2,8(r3)
 909d738:	e0bfb715 	stw	r2,-292(fp)
 909d73c:	18800317 	ldw	r2,12(r3)
 909d740:	e0bfb815 	stw	r2,-288(fp)
 909d744:	18800417 	ldw	r2,16(r3)
 909d748:	e0bfb915 	stw	r2,-284(fp)
 909d74c:	18800517 	ldw	r2,20(r3)
 909d750:	e0bfba15 	stw	r2,-280(fp)
 909d754:	18800603 	ldbu	r2,24(r3)
 909d758:	e0bfbb05 	stb	r2,-276(fp)
 909d75c:	e13fbb44 	addi	r4,fp,-275
 909d760:	01800dc4 	movi	r6,55
 909d764:	000b883a 	mov	r5,zero
 909d768:	90832780 	call	9083278 <memset>
 909d76c:	009410c4 	movi	r2,20547
 909d770:	e0bfc915 	stw	r2,-220(fp)
 909d774:	00800344 	movi	r2,13
 909d778:	e0bfca05 	stb	r2,-216(fp)
 909d77c:	00800084 	movi	r2,2
 909d780:	e0bfca45 	stb	r2,-215(fp)
 909d784:	00800444 	movi	r2,17
 909d788:	e0bfca85 	stb	r2,-214(fp)
 909d78c:	00800384 	movi	r2,14
 909d790:	e0bfcac5 	stb	r2,-213(fp)
 909d794:	00800344 	movi	r2,13
 909d798:	e0bfcb05 	stb	r2,-212(fp)
 909d79c:	00800284 	movi	r2,10
 909d7a0:	e0bfcb45 	stb	r2,-211(fp)
 909d7a4:	008242b4 	movhi	r2,2314
 909d7a8:	10bff604 	addi	r2,r2,-40
 909d7ac:	e0bfcc15 	stw	r2,-208(fp)
                          DP83865_REV,            /* Model Revision Number                            */
                          0x11,                   /* Location of Status Register                      */
                          3,                      /* Location of Speed Status                         */
                          1,                      /* Location of Duplex Status                        */
                          2                       /* Location of Link Status                          */
                         };
 909d7b0:	e13fce04 	addi	r4,fp,-200
 909d7b4:	01801904 	movi	r6,100
 909d7b8:	000b883a 	mov	r5,zero
 909d7bc:	90832780 	call	9083278 <memset>
 909d7c0:	00c24374 	movhi	r3,2317
 909d7c4:	18f85e04 	addi	r3,r3,-7816
 909d7c8:	18800017 	ldw	r2,0(r3)
 909d7cc:	e0bfce15 	stw	r2,-200(fp)
 909d7d0:	18800117 	ldw	r2,4(r3)
 909d7d4:	e0bfcf15 	stw	r2,-196(fp)
 909d7d8:	18800217 	ldw	r2,8(r3)
 909d7dc:	e0bfd015 	stw	r2,-192(fp)
 909d7e0:	18800317 	ldw	r2,12(r3)
 909d7e4:	e0bfd115 	stw	r2,-188(fp)
 909d7e8:	18800403 	ldbu	r2,16(r3)
 909d7ec:	e0bfd205 	stb	r2,-184(fp)
 909d7f0:	e13fd244 	addi	r4,fp,-183
 909d7f4:	01800fc4 	movi	r6,63
 909d7f8:	000b883a 	mov	r5,zero
 909d7fc:	90832780 	call	9083278 <memset>
 909d800:	00800234 	movhi	r2,8
 909d804:	108005c4 	addi	r2,r2,23
 909d808:	e0bfe215 	stw	r2,-120(fp)
 909d80c:	008001c4 	movi	r2,7
 909d810:	e0bfe305 	stb	r2,-116(fp)
 909d814:	00800284 	movi	r2,10
 909d818:	e0bfe345 	stb	r2,-115(fp)
 909d81c:	00800444 	movi	r2,17
 909d820:	e0bfe385 	stb	r2,-114(fp)
 909d824:	008000c4 	movi	r2,3
 909d828:	e0bfe3c5 	stb	r2,-113(fp)
 909d82c:	00800044 	movi	r2,1
 909d830:	e0bfe405 	stb	r2,-112(fp)
 909d834:	00800084 	movi	r2,2
 909d838:	e0bfe445 	stb	r2,-111(fp)
                           0,                              /* Location of Speed Status    (ignored)                      */
                           0,                              /* Location of Duplex Status   (ignored)                      */
                           0,                              /* Location of Link Status     (ignored)                      */
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
 909d83c:	e13fe704 	addi	r4,fp,-100
 909d840:	01801904 	movi	r6,100
 909d844:	000b883a 	mov	r5,zero
 909d848:	90832780 	call	9083278 <memset>
 909d84c:	00c24374 	movhi	r3,2317
 909d850:	18f87204 	addi	r3,r3,-7736
 909d854:	18800017 	ldw	r2,0(r3)
 909d858:	e0bfe715 	stw	r2,-100(fp)
 909d85c:	18800117 	ldw	r2,4(r3)
 909d860:	e0bfe815 	stw	r2,-96(fp)
 909d864:	18800217 	ldw	r2,8(r3)
 909d868:	e0bfe915 	stw	r2,-92(fp)
 909d86c:	18800317 	ldw	r2,12(r3)
 909d870:	e0bfea15 	stw	r2,-88(fp)
 909d874:	1880040b 	ldhu	r2,16(r3)
 909d878:	e0bfeb0d 	sth	r2,-84(fp)
 909d87c:	e13feb84 	addi	r4,fp,-82
 909d880:	01800f84 	movi	r6,62
 909d884:	000b883a 	mov	r5,zero
 909d888:	90832780 	call	9083278 <memset>
 909d88c:	00800234 	movhi	r2,8
 909d890:	108005c4 	addi	r2,r2,23
 909d894:	e0bffb15 	stw	r2,-20(fp)
 909d898:	00800244 	movi	r2,9
 909d89c:	e0bffc05 	stb	r2,-16(fp)
 909d8a0:	008242b4 	movhi	r2,2314
 909d8a4:	1080da04 	addi	r2,r2,872
 909d8a8:	e0bfff15 	stw	r2,-4(fp)
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 909d8ac:	e13f9c04 	addi	r4,fp,-400
 909d8b0:	909b4080 	call	909b408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 909d8b4:	e13fb504 	addi	r4,fp,-300
 909d8b8:	909b4080 	call	909b408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 909d8bc:	e13fce04 	addi	r4,fp,-200
 909d8c0:	909b4080 	call	909b408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 909d8c4:	e13fe704 	addi	r4,fp,-100
 909d8c8:	909b4080 	call	909b408 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 909d8cc:	d0a08003 	ldbu	r2,-32256(gp)
 909d8d0:	10803fcc 	andi	r2,r2,255
}
 909d8d4:	e037883a 	mov	sp,fp
 909d8d8:	dfc00117 	ldw	ra,4(sp)
 909d8dc:	df000017 	ldw	fp,0(sp)
 909d8e0:	dec00204 	addi	sp,sp,8
 909d8e4:	f800283a 	ret

0909d8e8 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 909d8e8:	defffd04 	addi	sp,sp,-12
 909d8ec:	dfc00215 	stw	ra,8(sp)
 909d8f0:	df000115 	stw	fp,4(sp)
 909d8f4:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 909d8f8:	d0a08003 	ldbu	r2,-32256(gp)
 909d8fc:	11403fcc 	andi	r5,r2,255
 909d900:	01024374 	movhi	r4,2317
 909d904:	21388604 	addi	r4,r4,-7656
 909d908:	909b0a80 	call	909b0a8 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 909d90c:	e03fff05 	stb	zero,-4(fp)
 909d910:	00006606 	br	909daac <alt_tse_phy_print_profile+0x1c4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 909d914:	e17fff07 	ldb	r5,-4(fp)
 909d918:	01024374 	movhi	r4,2317
 909d91c:	21389504 	addi	r4,r4,-7596
 909d920:	909b0a80 	call	909b0a8 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 909d924:	e0bfff07 	ldb	r2,-4(fp)
 909d928:	00c243b4 	movhi	r3,2318
 909d92c:	18f4c504 	addi	r3,r3,-11500
 909d930:	1085883a 	add	r2,r2,r2
 909d934:	1085883a 	add	r2,r2,r2
 909d938:	10c5883a 	add	r2,r2,r3
 909d93c:	10800017 	ldw	r2,0(r2)
 909d940:	100b883a 	mov	r5,r2
 909d944:	01024374 	movhi	r4,2317
 909d948:	21389a04 	addi	r4,r4,-7576
 909d94c:	909b0a80 	call	909b0a8 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 909d950:	e0bfff07 	ldb	r2,-4(fp)
 909d954:	00c243b4 	movhi	r3,2318
 909d958:	18f4c504 	addi	r3,r3,-11500
 909d95c:	1085883a 	add	r2,r2,r2
 909d960:	1085883a 	add	r2,r2,r2
 909d964:	10c5883a 	add	r2,r2,r3
 909d968:	10800017 	ldw	r2,0(r2)
 909d96c:	10801417 	ldw	r2,80(r2)
 909d970:	100b883a 	mov	r5,r2
 909d974:	01024374 	movhi	r4,2317
 909d978:	2138a004 	addi	r4,r4,-7552
 909d97c:	909b0a80 	call	909b0a8 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 909d980:	e0bfff07 	ldb	r2,-4(fp)
 909d984:	00c243b4 	movhi	r3,2318
 909d988:	18f4c504 	addi	r3,r3,-11500
 909d98c:	1085883a 	add	r2,r2,r2
 909d990:	1085883a 	add	r2,r2,r2
 909d994:	10c5883a 	add	r2,r2,r3
 909d998:	10800017 	ldw	r2,0(r2)
 909d99c:	10801503 	ldbu	r2,84(r2)
 909d9a0:	11403fcc 	andi	r5,r2,255
 909d9a4:	01024374 	movhi	r4,2317
 909d9a8:	2138a704 	addi	r4,r4,-7524
 909d9ac:	909b0a80 	call	909b0a8 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 909d9b0:	e0bfff07 	ldb	r2,-4(fp)
 909d9b4:	00c243b4 	movhi	r3,2318
 909d9b8:	18f4c504 	addi	r3,r3,-11500
 909d9bc:	1085883a 	add	r2,r2,r2
 909d9c0:	1085883a 	add	r2,r2,r2
 909d9c4:	10c5883a 	add	r2,r2,r3
 909d9c8:	10800017 	ldw	r2,0(r2)
 909d9cc:	10801543 	ldbu	r2,85(r2)
 909d9d0:	11403fcc 	andi	r5,r2,255
 909d9d4:	01024374 	movhi	r4,2317
 909d9d8:	2138ae04 	addi	r4,r4,-7496
 909d9dc:	909b0a80 	call	909b0a8 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 909d9e0:	e0bfff07 	ldb	r2,-4(fp)
 909d9e4:	00c243b4 	movhi	r3,2318
 909d9e8:	18f4c504 	addi	r3,r3,-11500
 909d9ec:	1085883a 	add	r2,r2,r2
 909d9f0:	1085883a 	add	r2,r2,r2
 909d9f4:	10c5883a 	add	r2,r2,r3
 909d9f8:	10800017 	ldw	r2,0(r2)
 909d9fc:	10801583 	ldbu	r2,86(r2)
 909da00:	11403fcc 	andi	r5,r2,255
 909da04:	01024374 	movhi	r4,2317
 909da08:	2138b504 	addi	r4,r4,-7468
 909da0c:	909b0a80 	call	909b0a8 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 909da10:	e0bfff07 	ldb	r2,-4(fp)
 909da14:	00c243b4 	movhi	r3,2318
 909da18:	18f4c504 	addi	r3,r3,-11500
 909da1c:	1085883a 	add	r2,r2,r2
 909da20:	1085883a 	add	r2,r2,r2
 909da24:	10c5883a 	add	r2,r2,r3
 909da28:	10800017 	ldw	r2,0(r2)
 909da2c:	108015c3 	ldbu	r2,87(r2)
 909da30:	11403fcc 	andi	r5,r2,255
 909da34:	01024374 	movhi	r4,2317
 909da38:	2138bc04 	addi	r4,r4,-7440
 909da3c:	909b0a80 	call	909b0a8 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 909da40:	e0bfff07 	ldb	r2,-4(fp)
 909da44:	00c243b4 	movhi	r3,2318
 909da48:	18f4c504 	addi	r3,r3,-11500
 909da4c:	1085883a 	add	r2,r2,r2
 909da50:	1085883a 	add	r2,r2,r2
 909da54:	10c5883a 	add	r2,r2,r3
 909da58:	10800017 	ldw	r2,0(r2)
 909da5c:	10801603 	ldbu	r2,88(r2)
 909da60:	11403fcc 	andi	r5,r2,255
 909da64:	01024374 	movhi	r4,2317
 909da68:	2138c204 	addi	r4,r4,-7416
 909da6c:	909b0a80 	call	909b0a8 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 909da70:	e0bfff07 	ldb	r2,-4(fp)
 909da74:	00c243b4 	movhi	r3,2318
 909da78:	18f4c504 	addi	r3,r3,-11500
 909da7c:	1085883a 	add	r2,r2,r2
 909da80:	1085883a 	add	r2,r2,r2
 909da84:	10c5883a 	add	r2,r2,r3
 909da88:	10800017 	ldw	r2,0(r2)
 909da8c:	10801643 	ldbu	r2,89(r2)
 909da90:	11403fcc 	andi	r5,r2,255
 909da94:	01024374 	movhi	r4,2317
 909da98:	2138c804 	addi	r4,r4,-7392
 909da9c:	909b0a80 	call	909b0a8 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 909daa0:	e0bfff03 	ldbu	r2,-4(fp)
 909daa4:	10800044 	addi	r2,r2,1
 909daa8:	e0bfff05 	stb	r2,-4(fp)
 909daac:	e0bfff07 	ldb	r2,-4(fp)
 909dab0:	d0e08003 	ldbu	r3,-32256(gp)
 909dab4:	18c03fcc 	andi	r3,r3,255
 909dab8:	10ff9616 	blt	r2,r3,909d914 <alt_tse_phy_print_profile+0x2c>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 909dabc:	d0a08003 	ldbu	r2,-32256(gp)
 909dac0:	10803fcc 	andi	r2,r2,255
}
 909dac4:	e037883a 	mov	sp,fp
 909dac8:	dfc00117 	ldw	ra,4(sp)
 909dacc:	df000017 	ldw	fp,0(sp)
 909dad0:	dec00204 	addi	sp,sp,8
 909dad4:	f800283a 	ret

0909dad8 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 909dad8:	defff104 	addi	sp,sp,-60
 909dadc:	dfc00e15 	stw	ra,56(sp)
 909dae0:	df000d15 	stw	fp,52(sp)
 909dae4:	df000d04 	addi	fp,sp,52
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 909dae8:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 909daec:	e03ff415 	stw	zero,-48(fp)
    alt_tse_system_info *psys = 0;
 909daf0:	e03ff315 	stw	zero,-52(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 909daf4:	d0208045 	stb	zero,-32255(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 909daf8:	e03ff645 	stb	zero,-39(fp)
 909dafc:	0001ae06 	br	909e1b8 <alt_tse_mac_group_init+0x6e0>
        psys = &tse_mac_device[i];
 909db00:	e0bff647 	ldb	r2,-39(fp)
 909db04:	10801224 	muli	r2,r2,72
 909db08:	1007883a 	mov	r3,r2
 909db0c:	00824374 	movhi	r2,2317
 909db10:	10869404 	addi	r2,r2,6736
 909db14:	1885883a 	add	r2,r3,r2
 909db18:	e0bff315 	stw	r2,-52(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 909db1c:	e0bff317 	ldw	r2,-52(fp)
 909db20:	10800517 	ldw	r2,20(r2)
 909db24:	1005003a 	cmpeq	r2,r2,zero
 909db28:	1001a01e 	bne	r2,zero,909e1ac <alt_tse_mac_group_init+0x6d4>
 909db2c:	e0bff317 	ldw	r2,-52(fp)
 909db30:	10800617 	ldw	r2,24(r2)
 909db34:	1005003a 	cmpeq	r2,r2,zero
 909db38:	10019c1e 	bne	r2,zero,909e1ac <alt_tse_mac_group_init+0x6d4>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 909db3c:	d0a08043 	ldbu	r2,-32255(gp)
 909db40:	11403fcc 	andi	r5,r2,255
 909db44:	e0bff317 	ldw	r2,-52(fp)
 909db48:	10800017 	ldw	r2,0(r2)
 909db4c:	100d883a 	mov	r6,r2
 909db50:	01024374 	movhi	r4,2317
 909db54:	2138ce04 	addi	r4,r4,-7368
 909db58:	90833900 	call	9083390 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 909db5c:	01000504 	movi	r4,20
 909db60:	90cb4400 	call	90cb440 <malloc>
 909db64:	e0bff515 	stw	r2,-44(fp)
            if(!pmac_group) {
 909db68:	e0bff517 	ldw	r2,-44(fp)
 909db6c:	1004c03a 	cmpne	r2,r2,zero
 909db70:	1000081e 	bne	r2,zero,909db94 <alt_tse_mac_group_init+0xbc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 909db74:	d0a08043 	ldbu	r2,-32255(gp)
 909db78:	11403fcc 	andi	r5,r2,255
 909db7c:	01024374 	movhi	r4,2317
 909db80:	2138da04 	addi	r4,r4,-7320
 909db84:	90833900 	call	9083390 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 909db88:	00bfffc4 	movi	r2,-1
 909db8c:	e0bfff15 	stw	r2,-4(fp)
 909db90:	00018e06 	br	909e1cc <alt_tse_mac_group_init+0x6f4>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 909db94:	e0bff317 	ldw	r2,-52(fp)
 909db98:	108002c3 	ldbu	r2,11(r2)
 909db9c:	10803fcc 	andi	r2,r2,255
 909dba0:	1005003a 	cmpeq	r2,r2,zero
 909dba4:	1000111e 	bne	r2,zero,909dbec <alt_tse_mac_group_init+0x114>
                pmac_group->channel = psys->tse_num_of_channel;
 909dba8:	e0bff317 	ldw	r2,-52(fp)
 909dbac:	10c00303 	ldbu	r3,12(r2)
 909dbb0:	e0bff517 	ldw	r2,-44(fp)
 909dbb4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 909dbb8:	01024374 	movhi	r4,2317
 909dbbc:	2138e804 	addi	r4,r4,-7264
 909dbc0:	909b0a80 	call	909b0a8 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 909dbc4:	e0bff517 	ldw	r2,-44(fp)
 909dbc8:	10800003 	ldbu	r2,0(r2)
 909dbcc:	11403fcc 	andi	r5,r2,255
 909dbd0:	01024374 	movhi	r4,2317
 909dbd4:	2138f304 	addi	r4,r4,-7220
 909dbd8:	909b0a80 	call	909b0a8 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 909dbdc:	01024374 	movhi	r4,2317
 909dbe0:	2138fe04 	addi	r4,r4,-7176
 909dbe4:	909b0a80 	call	909b0a8 <no_printf>
 909dbe8:	00001f06 	br	909dc68 <alt_tse_mac_group_init+0x190>
            }
            else if(psys->tse_mdio_shared) {
 909dbec:	e0bff317 	ldw	r2,-52(fp)
 909dbf0:	10800343 	ldbu	r2,13(r2)
 909dbf4:	10803fcc 	andi	r2,r2,255
 909dbf8:	1005003a 	cmpeq	r2,r2,zero
 909dbfc:	1000111e 	bne	r2,zero,909dc44 <alt_tse_mac_group_init+0x16c>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 909dc00:	e0bff317 	ldw	r2,-52(fp)
 909dc04:	10c00383 	ldbu	r3,14(r2)
 909dc08:	e0bff517 	ldw	r2,-44(fp)
 909dc0c:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 909dc10:	01024374 	movhi	r4,2317
 909dc14:	21390904 	addi	r4,r4,-7132
 909dc18:	909b0a80 	call	909b0a8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 909dc1c:	01024374 	movhi	r4,2317
 909dc20:	2138fe04 	addi	r4,r4,-7176
 909dc24:	909b0a80 	call	909b0a8 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 909dc28:	e0bff517 	ldw	r2,-44(fp)
 909dc2c:	10800003 	ldbu	r2,0(r2)
 909dc30:	11403fcc 	andi	r5,r2,255
 909dc34:	01024374 	movhi	r4,2317
 909dc38:	21391404 	addi	r4,r4,-7088
 909dc3c:	909b0a80 	call	909b0a8 <no_printf>
 909dc40:	00000906 	br	909dc68 <alt_tse_mac_group_init+0x190>
            }
            else {
                pmac_group->channel = 1;
 909dc44:	e0fff517 	ldw	r3,-44(fp)
 909dc48:	00800044 	movi	r2,1
 909dc4c:	18800005 	stb	r2,0(r3)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 909dc50:	01024374 	movhi	r4,2317
 909dc54:	21390904 	addi	r4,r4,-7132
 909dc58:	909b0a80 	call	909b0a8 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 909dc5c:	01024374 	movhi	r4,2317
 909dc60:	21391f04 	addi	r4,r4,-7044
 909dc64:	909b0a80 	call	909b0a8 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 909dc68:	e03ff605 	stb	zero,-40(fp)
 909dc6c:	00013806 	br	909e150 <alt_tse_mac_group_init+0x678>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 909dc70:	01000404 	movi	r4,16
 909dc74:	90cb4400 	call	90cb440 <malloc>
 909dc78:	e0bff415 	stw	r2,-48(fp)
                if(!pmac_info) {
 909dc7c:	e0bff417 	ldw	r2,-48(fp)
 909dc80:	1004c03a 	cmpne	r2,r2,zero
 909dc84:	1000091e 	bne	r2,zero,909dcac <alt_tse_mac_group_init+0x1d4>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 909dc88:	d0a08043 	ldbu	r2,-32255(gp)
 909dc8c:	11403fcc 	andi	r5,r2,255
 909dc90:	e1bff607 	ldb	r6,-40(fp)
 909dc94:	01024374 	movhi	r4,2317
 909dc98:	21392a04 	addi	r4,r4,-7000
 909dc9c:	90833900 	call	9083390 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 909dca0:	00ffffc4 	movi	r3,-1
 909dca4:	e0ffff15 	stw	r3,-4(fp)
 909dca8:	00014806 	br	909e1cc <alt_tse_mac_group_init+0x6f4>
                }
                
                pmac_info->pmac_group = pmac_group;
 909dcac:	e0fff417 	ldw	r3,-48(fp)
 909dcb0:	e0bff517 	ldw	r2,-44(fp)
 909dcb4:	18800315 	stw	r2,12(r3)
                
                pmac_info->pphy_info = 0;
 909dcb8:	e0bff417 	ldw	r2,-48(fp)
 909dcbc:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 909dcc0:	e0fff647 	ldb	r3,-39(fp)
 909dcc4:	e0bff607 	ldb	r2,-40(fp)
 909dcc8:	1885883a 	add	r2,r3,r2
 909dccc:	10801224 	muli	r2,r2,72
 909dcd0:	1007883a 	mov	r3,r2
 909dcd4:	00824374 	movhi	r2,2317
 909dcd8:	10869404 	addi	r2,r2,6736
 909dcdc:	1887883a 	add	r3,r3,r2
 909dce0:	e0bff417 	ldw	r2,-48(fp)
 909dce4:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 909dce8:	e0bff417 	ldw	r2,-48(fp)
 909dcec:	10800217 	ldw	r2,8(r2)
 909dcf0:	10800517 	ldw	r2,20(r2)
 909dcf4:	1005003a 	cmpeq	r2,r2,zero
 909dcf8:	1000051e 	bne	r2,zero,909dd10 <alt_tse_mac_group_init+0x238>
 909dcfc:	e0bff417 	ldw	r2,-48(fp)
 909dd00:	10800217 	ldw	r2,8(r2)
 909dd04:	10800617 	ldw	r2,24(r2)
 909dd08:	1004c03a 	cmpne	r2,r2,zero
 909dd0c:	1000091e 	bne	r2,zero,909dd34 <alt_tse_mac_group_init+0x25c>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 909dd10:	e0bff647 	ldb	r2,-39(fp)
 909dd14:	e0fff607 	ldb	r3,-40(fp)
 909dd18:	10cb883a 	add	r5,r2,r3
 909dd1c:	01024374 	movhi	r4,2317
 909dd20:	21393c04 	addi	r4,r4,-6928
 909dd24:	90833900 	call	9083390 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 909dd28:	00bfffc4 	movi	r2,-1
 909dd2c:	e0bfff15 	stw	r2,-4(fp)
 909dd30:	00012606 	br	909e1cc <alt_tse_mac_group_init+0x6f4>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 909dd34:	e0bff417 	ldw	r2,-48(fp)
 909dd38:	10800217 	ldw	r2,8(r2)
 909dd3c:	10800243 	ldbu	r2,9(r2)
 909dd40:	10803fcc 	andi	r2,r2,255
 909dd44:	1005003a 	cmpeq	r2,r2,zero
 909dd48:	10000e1e 	bne	r2,zero,909dd84 <alt_tse_mac_group_init+0x2ac>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 909dd4c:	e0bff417 	ldw	r2,-48(fp)
 909dd50:	10800217 	ldw	r2,8(r2)
 909dd54:	10800283 	ldbu	r2,10(r2)
 909dd58:	10803fcc 	andi	r2,r2,255
 909dd5c:	1005003a 	cmpeq	r2,r2,zero
 909dd60:	1000041e 	bne	r2,zero,909dd74 <alt_tse_mac_group_init+0x29c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 909dd64:	e0fff417 	ldw	r3,-48(fp)
 909dd68:	00800084 	movi	r2,2
 909dd6c:	18800005 	stb	r2,0(r3)
 909dd70:	00000606 	br	909dd8c <alt_tse_mac_group_init+0x2b4>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 909dd74:	e0fff417 	ldw	r3,-48(fp)
 909dd78:	00800044 	movi	r2,1
 909dd7c:	18800005 	stb	r2,0(r3)
 909dd80:	00000206 	br	909dd8c <alt_tse_mac_group_init+0x2b4>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 909dd84:	e0bff417 	ldw	r2,-48(fp)
 909dd88:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 909dd8c:	e0bff417 	ldw	r2,-48(fp)
 909dd90:	10800217 	ldw	r2,8(r2)
 909dd94:	10800343 	ldbu	r2,13(r2)
 909dd98:	10803fcc 	andi	r2,r2,255
 909dd9c:	1005003a 	cmpeq	r2,r2,zero
 909dda0:	10006d1e 	bne	r2,zero,909df58 <alt_tse_mac_group_init+0x480>
 909dda4:	e0bff417 	ldw	r2,-48(fp)
 909dda8:	10800217 	ldw	r2,8(r2)
 909ddac:	108002c3 	ldbu	r2,11(r2)
 909ddb0:	10803fcc 	andi	r2,r2,255
 909ddb4:	1004c03a 	cmpne	r2,r2,zero
 909ddb8:	1000671e 	bne	r2,zero,909df58 <alt_tse_mac_group_init+0x480>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 909ddbc:	e17ff607 	ldb	r5,-40(fp)
 909ddc0:	e0bff417 	ldw	r2,-48(fp)
 909ddc4:	10800217 	ldw	r2,8(r2)
 909ddc8:	10800017 	ldw	r2,0(r2)
 909ddcc:	100d883a 	mov	r6,r2
 909ddd0:	01024374 	movhi	r4,2317
 909ddd4:	21394b04 	addi	r4,r4,-6868
 909ddd8:	909b0a80 	call	909b0a8 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 909dddc:	e17ff607 	ldb	r5,-40(fp)
 909dde0:	e0fff647 	ldb	r3,-39(fp)
 909dde4:	e0bff607 	ldb	r2,-40(fp)
 909dde8:	188d883a 	add	r6,r3,r2
 909ddec:	01024374 	movhi	r4,2317
 909ddf0:	21395704 	addi	r4,r4,-6820
 909ddf4:	909b0a80 	call	909b0a8 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 909ddf8:	e0bff417 	ldw	r2,-48(fp)
 909ddfc:	10800003 	ldbu	r2,0(r2)
 909de00:	10803fcc 	andi	r2,r2,255
 909de04:	e0bffe15 	stw	r2,-8(fp)
 909de08:	e0fffe17 	ldw	r3,-8(fp)
 909de0c:	18800060 	cmpeqi	r2,r3,1
 909de10:	10000e1e 	bne	r2,zero,909de4c <alt_tse_mac_group_init+0x374>
 909de14:	e0fffe17 	ldw	r3,-8(fp)
 909de18:	188000a0 	cmpeqi	r2,r3,2
 909de1c:	1000041e 	bne	r2,zero,909de30 <alt_tse_mac_group_init+0x358>
 909de20:	e0fffe17 	ldw	r3,-8(fp)
 909de24:	1805003a 	cmpeq	r2,r3,zero
 909de28:	10000f1e 	bne	r2,zero,909de68 <alt_tse_mac_group_init+0x390>
 909de2c:	00001506 	br	909de84 <alt_tse_mac_group_init+0x3ac>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 909de30:	e17ff607 	ldb	r5,-40(fp)
 909de34:	01024374 	movhi	r4,2317
 909de38:	21396604 	addi	r4,r4,-6760
 909de3c:	01824374 	movhi	r6,2317
 909de40:	31b97104 	addi	r6,r6,-6716
 909de44:	909b0a80 	call	909b0a8 <no_printf>
                            break;
 909de48:	00001406 	br	909de9c <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 909de4c:	e17ff607 	ldb	r5,-40(fp)
 909de50:	01024374 	movhi	r4,2317
 909de54:	21396604 	addi	r4,r4,-6760
 909de58:	01824374 	movhi	r6,2317
 909de5c:	31b97604 	addi	r6,r6,-6696
 909de60:	909b0a80 	call	909b0a8 <no_printf>
                            break;
 909de64:	00000d06 	br	909de9c <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 909de68:	e17ff607 	ldb	r5,-40(fp)
 909de6c:	01024374 	movhi	r4,2317
 909de70:	21396604 	addi	r4,r4,-6760
 909de74:	01824374 	movhi	r6,2317
 909de78:	31b97c04 	addi	r6,r6,-6672
 909de7c:	909b0a80 	call	909b0a8 <no_printf>
                            break;
 909de80:	00000606 	br	909de9c <alt_tse_mac_group_init+0x3c4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 909de84:	e17ff607 	ldb	r5,-40(fp)
 909de88:	01024374 	movhi	r4,2317
 909de8c:	21396604 	addi	r4,r4,-6760
 909de90:	01824374 	movhi	r6,2317
 909de94:	31b77d04 	addi	r6,r6,-8716
 909de98:	909b0a80 	call	909b0a8 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 909de9c:	e0bff417 	ldw	r2,-48(fp)
 909dea0:	10800217 	ldw	r2,8(r2)
 909dea4:	108003c3 	ldbu	r2,15(r2)
 909dea8:	10803fcc 	andi	r2,r2,255
 909deac:	1005003a 	cmpeq	r2,r2,zero
 909deb0:	10009c1e 	bne	r2,zero,909e124 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 909deb4:	e0bff607 	ldb	r2,-40(fp)
 909deb8:	e0bffd15 	stw	r2,-12(fp)
 909debc:	e0bff417 	ldw	r2,-48(fp)
 909dec0:	10800217 	ldw	r2,8(r2)
 909dec4:	108003c3 	ldbu	r2,15(r2)
 909dec8:	10803fcc 	andi	r2,r2,255
 909decc:	1005003a 	cmpeq	r2,r2,zero
 909ded0:	1000041e 	bne	r2,zero,909dee4 <alt_tse_mac_group_init+0x40c>
 909ded4:	00c24374 	movhi	r3,2317
 909ded8:	18f98304 	addi	r3,r3,-6644
 909dedc:	e0fffc15 	stw	r3,-16(fp)
 909dee0:	00000306 	br	909def0 <alt_tse_mac_group_init+0x418>
 909dee4:	00824374 	movhi	r2,2317
 909dee8:	10b98404 	addi	r2,r2,-6640
 909deec:	e0bffc15 	stw	r2,-16(fp)
 909def0:	01024374 	movhi	r4,2317
 909def4:	21398504 	addi	r4,r4,-6636
 909def8:	e17ffd17 	ldw	r5,-12(fp)
 909defc:	e1bffc17 	ldw	r6,-16(fp)
 909df00:	909b0a80 	call	909b0a8 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 909df04:	e0fff607 	ldb	r3,-40(fp)
 909df08:	e0fffb15 	stw	r3,-20(fp)
 909df0c:	e0bff417 	ldw	r2,-48(fp)
 909df10:	10800217 	ldw	r2,8(r2)
 909df14:	10800403 	ldbu	r2,16(r2)
 909df18:	10803fcc 	andi	r2,r2,255
 909df1c:	1005003a 	cmpeq	r2,r2,zero
 909df20:	1000041e 	bne	r2,zero,909df34 <alt_tse_mac_group_init+0x45c>
 909df24:	00824374 	movhi	r2,2317
 909df28:	10b98304 	addi	r2,r2,-6644
 909df2c:	e0bffa15 	stw	r2,-24(fp)
 909df30:	00000306 	br	909df40 <alt_tse_mac_group_init+0x468>
 909df34:	00c24374 	movhi	r3,2317
 909df38:	18f98404 	addi	r3,r3,-6640
 909df3c:	e0fffa15 	stw	r3,-24(fp)
 909df40:	01024374 	movhi	r4,2317
 909df44:	21399004 	addi	r4,r4,-6592
 909df48:	e17ffb17 	ldw	r5,-20(fp)
 909df4c:	e1bffa17 	ldw	r6,-24(fp)
 909df50:	909b0a80 	call	909b0a8 <no_printf>
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 909df54:	00007306 	br	909e124 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 909df58:	e0bff607 	ldb	r2,-40(fp)
 909df5c:	1004c03a 	cmpne	r2,r2,zero
 909df60:	10004d1e 	bne	r2,zero,909e098 <alt_tse_mac_group_init+0x5c0>
	                    switch(pmac_info->mac_type) {
 909df64:	e0bff417 	ldw	r2,-48(fp)
 909df68:	10800003 	ldbu	r2,0(r2)
 909df6c:	10803fcc 	andi	r2,r2,255
 909df70:	e0bff915 	stw	r2,-28(fp)
 909df74:	e0fff917 	ldw	r3,-28(fp)
 909df78:	18800060 	cmpeqi	r2,r3,1
 909df7c:	10000d1e 	bne	r2,zero,909dfb4 <alt_tse_mac_group_init+0x4dc>
 909df80:	e0fff917 	ldw	r3,-28(fp)
 909df84:	188000a0 	cmpeqi	r2,r3,2
 909df88:	1000041e 	bne	r2,zero,909df9c <alt_tse_mac_group_init+0x4c4>
 909df8c:	e0fff917 	ldw	r3,-28(fp)
 909df90:	1805003a 	cmpeq	r2,r3,zero
 909df94:	10000d1e 	bne	r2,zero,909dfcc <alt_tse_mac_group_init+0x4f4>
 909df98:	00001206 	br	909dfe4 <alt_tse_mac_group_init+0x50c>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 909df9c:	01024374 	movhi	r4,2317
 909dfa0:	21399b04 	addi	r4,r4,-6548
 909dfa4:	01424374 	movhi	r5,2317
 909dfa8:	29797104 	addi	r5,r5,-6716
 909dfac:	909b0a80 	call	909b0a8 <no_printf>
	                            break;
 909dfb0:	00001106 	br	909dff8 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 909dfb4:	01024374 	movhi	r4,2317
 909dfb8:	21399b04 	addi	r4,r4,-6548
 909dfbc:	01424374 	movhi	r5,2317
 909dfc0:	29797604 	addi	r5,r5,-6696
 909dfc4:	909b0a80 	call	909b0a8 <no_printf>
	                            break;
 909dfc8:	00000b06 	br	909dff8 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 909dfcc:	01024374 	movhi	r4,2317
 909dfd0:	21399b04 	addi	r4,r4,-6548
 909dfd4:	01424374 	movhi	r5,2317
 909dfd8:	29797c04 	addi	r5,r5,-6672
 909dfdc:	909b0a80 	call	909b0a8 <no_printf>
	                            break;
 909dfe0:	00000506 	br	909dff8 <alt_tse_mac_group_init+0x520>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 909dfe4:	01024374 	movhi	r4,2317
 909dfe8:	21399b04 	addi	r4,r4,-6548
 909dfec:	01424374 	movhi	r5,2317
 909dff0:	29777d04 	addi	r5,r5,-8716
 909dff4:	909b0a80 	call	909b0a8 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 909dff8:	e0bff417 	ldw	r2,-48(fp)
 909dffc:	10800217 	ldw	r2,8(r2)
 909e000:	108003c3 	ldbu	r2,15(r2)
 909e004:	10803fcc 	andi	r2,r2,255
 909e008:	1005003a 	cmpeq	r2,r2,zero
 909e00c:	1000221e 	bne	r2,zero,909e098 <alt_tse_mac_group_init+0x5c0>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 909e010:	e0bff417 	ldw	r2,-48(fp)
 909e014:	10800217 	ldw	r2,8(r2)
 909e018:	108003c3 	ldbu	r2,15(r2)
 909e01c:	10803fcc 	andi	r2,r2,255
 909e020:	1005003a 	cmpeq	r2,r2,zero
 909e024:	1000041e 	bne	r2,zero,909e038 <alt_tse_mac_group_init+0x560>
 909e028:	00824374 	movhi	r2,2317
 909e02c:	10b98304 	addi	r2,r2,-6644
 909e030:	e0bff815 	stw	r2,-32(fp)
 909e034:	00000306 	br	909e044 <alt_tse_mac_group_init+0x56c>
 909e038:	00c24374 	movhi	r3,2317
 909e03c:	18f98404 	addi	r3,r3,-6640
 909e040:	e0fff815 	stw	r3,-32(fp)
 909e044:	01024374 	movhi	r4,2317
 909e048:	2139a604 	addi	r4,r4,-6504
 909e04c:	e17ff817 	ldw	r5,-32(fp)
 909e050:	909b0a80 	call	909b0a8 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 909e054:	e0bff417 	ldw	r2,-48(fp)
 909e058:	10800217 	ldw	r2,8(r2)
 909e05c:	10800403 	ldbu	r2,16(r2)
 909e060:	10803fcc 	andi	r2,r2,255
 909e064:	1005003a 	cmpeq	r2,r2,zero
 909e068:	1000041e 	bne	r2,zero,909e07c <alt_tse_mac_group_init+0x5a4>
 909e06c:	00824374 	movhi	r2,2317
 909e070:	10b98304 	addi	r2,r2,-6644
 909e074:	e0bff715 	stw	r2,-36(fp)
 909e078:	00000306 	br	909e088 <alt_tse_mac_group_init+0x5b0>
 909e07c:	00c24374 	movhi	r3,2317
 909e080:	18f98404 	addi	r3,r3,-6640
 909e084:	e0fff715 	stw	r3,-36(fp)
 909e088:	01024374 	movhi	r4,2317
 909e08c:	2139b104 	addi	r4,r4,-6460
 909e090:	e17ff717 	ldw	r5,-36(fp)
 909e094:	909b0a80 	call	909b0a8 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 909e098:	e0bff417 	ldw	r2,-48(fp)
 909e09c:	10800217 	ldw	r2,8(r2)
 909e0a0:	108002c3 	ldbu	r2,11(r2)
 909e0a4:	10803fcc 	andi	r2,r2,255
 909e0a8:	1005003a 	cmpeq	r2,r2,zero
 909e0ac:	1000101e 	bne	r2,zero,909e0f0 <alt_tse_mac_group_init+0x618>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 909e0b0:	e17ff607 	ldb	r5,-40(fp)
 909e0b4:	e0bff417 	ldw	r2,-48(fp)
 909e0b8:	10800217 	ldw	r2,8(r2)
 909e0bc:	10800017 	ldw	r2,0(r2)
 909e0c0:	100d883a 	mov	r6,r2
 909e0c4:	01024374 	movhi	r4,2317
 909e0c8:	2139bc04 	addi	r4,r4,-6416
 909e0cc:	909b0a80 	call	909b0a8 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 909e0d0:	e17ff607 	ldb	r5,-40(fp)
 909e0d4:	e0fff647 	ldb	r3,-39(fp)
 909e0d8:	e0bff607 	ldb	r2,-40(fp)
 909e0dc:	188d883a 	add	r6,r3,r2
 909e0e0:	01024374 	movhi	r4,2317
 909e0e4:	2139c804 	addi	r4,r4,-6368
 909e0e8:	909b0a80 	call	909b0a8 <no_printf>
 909e0ec:	00000d06 	br	909e124 <alt_tse_mac_group_init+0x64c>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 909e0f0:	e0bff417 	ldw	r2,-48(fp)
 909e0f4:	10800217 	ldw	r2,8(r2)
 909e0f8:	10800017 	ldw	r2,0(r2)
 909e0fc:	100b883a 	mov	r5,r2
 909e100:	01024374 	movhi	r4,2317
 909e104:	2139d704 	addi	r4,r4,-6308
 909e108:	909b0a80 	call	909b0a8 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 909e10c:	e0fff647 	ldb	r3,-39(fp)
 909e110:	e0bff607 	ldb	r2,-40(fp)
 909e114:	188b883a 	add	r5,r3,r2
 909e118:	01024374 	movhi	r4,2317
 909e11c:	2139e304 	addi	r4,r4,-6260
 909e120:	909b0a80 	call	909b0a8 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 909e124:	e0bff607 	ldb	r2,-40(fp)
 909e128:	e0fff517 	ldw	r3,-44(fp)
 909e12c:	1085883a 	add	r2,r2,r2
 909e130:	1085883a 	add	r2,r2,r2
 909e134:	10c5883a 	add	r2,r2,r3
 909e138:	10c00104 	addi	r3,r2,4
 909e13c:	e0bff417 	ldw	r2,-48(fp)
 909e140:	18800015 	stw	r2,0(r3)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 909e144:	e0bff603 	ldbu	r2,-40(fp)
 909e148:	10800044 	addi	r2,r2,1
 909e14c:	e0bff605 	stb	r2,-40(fp)
 909e150:	e0fff607 	ldb	r3,-40(fp)
 909e154:	e0bff517 	ldw	r2,-44(fp)
 909e158:	10800003 	ldbu	r2,0(r2)
 909e15c:	10803fcc 	andi	r2,r2,255
 909e160:	18bec316 	blt	r3,r2,909dc70 <alt_tse_mac_group_init+0x198>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 909e164:	d0a08043 	ldbu	r2,-32255(gp)
 909e168:	10803fcc 	andi	r2,r2,255
 909e16c:	00c243b4 	movhi	r3,2318
 909e170:	18f4c104 	addi	r3,r3,-11516
 909e174:	1085883a 	add	r2,r2,r2
 909e178:	1085883a 	add	r2,r2,r2
 909e17c:	10c7883a 	add	r3,r2,r3
 909e180:	e0bff517 	ldw	r2,-44(fp)
 909e184:	18800015 	stw	r2,0(r3)
            
            mac_group_count++;
 909e188:	d0a08043 	ldbu	r2,-32255(gp)
 909e18c:	10800044 	addi	r2,r2,1
 909e190:	d0a08045 	stb	r2,-32255(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 909e194:	e0bff517 	ldw	r2,-44(fp)
 909e198:	10c00003 	ldbu	r3,0(r2)
 909e19c:	e0bff643 	ldbu	r2,-39(fp)
 909e1a0:	1885883a 	add	r2,r3,r2
 909e1a4:	10bfffc4 	addi	r2,r2,-1
 909e1a8:	e0bff645 	stb	r2,-39(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 909e1ac:	e0bff643 	ldbu	r2,-39(fp)
 909e1b0:	10800044 	addi	r2,r2,1
 909e1b4:	e0bff645 	stb	r2,-39(fp)
 909e1b8:	e0bff647 	ldb	r2,-39(fp)
 909e1bc:	d0e02b03 	ldbu	r3,-32596(gp)
 909e1c0:	18c03fcc 	andi	r3,r3,255
 909e1c4:	10fe4e16 	blt	r2,r3,909db00 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 909e1c8:	e03fff15 	stw	zero,-4(fp)
 909e1cc:	e0bfff17 	ldw	r2,-4(fp)
}
 909e1d0:	e037883a 	mov	sp,fp
 909e1d4:	dfc00117 	ldw	ra,4(sp)
 909e1d8:	df000017 	ldw	fp,0(sp)
 909e1dc:	dec00204 	addi	sp,sp,8
 909e1e0:	f800283a 	ret

0909e1e4 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 909e1e4:	deffec04 	addi	sp,sp,-80
 909e1e8:	dfc01315 	stw	ra,76(sp)
 909e1ec:	df001215 	stw	fp,72(sp)
 909e1f0:	df001204 	addi	fp,sp,72
 909e1f4:	e13ffe15 	stw	r4,-8(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 909e1f8:	e03ffc15 	stw	zero,-16(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 909e1fc:	e03ff615 	stw	zero,-40(fp)
    
    alt_8 phy_info_count = 0;
 909e200:	e03ff505 	stb	zero,-44(fp)
    
    alt_tse_phy_info *pphy = 0;
 909e204:	e03ff415 	stw	zero,-48(fp)
    alt_tse_mac_info *pmac_info = 0;
 909e208:	e03ff315 	stw	zero,-52(fp)
    alt_tse_system_info *psys = 0;
 909e20c:	e03ff215 	stw	zero,-56(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909e210:	e0bffe17 	ldw	r2,-8(fp)
 909e214:	10800117 	ldw	r2,4(r2)
 909e218:	10800217 	ldw	r2,8(r2)
 909e21c:	10800017 	ldw	r2,0(r2)
 909e220:	e0bff115 	stw	r2,-60(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909e224:	e0bff117 	ldw	r2,-60(fp)
 909e228:	10801004 	addi	r2,r2,64
 909e22c:	10800037 	ldwio	r2,0(r2)
 909e230:	e0bff015 	stw	r2,-64(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e234:	e13ffe17 	ldw	r4,-8(fp)
 909e238:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909e23c:	e0bfef05 	stb	r2,-68(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 909e240:	e03ffb05 	stb	zero,-20(fp)
 909e244:	0000c806 	br	909e568 <alt_tse_mac_get_phy+0x384>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 909e248:	e0bff117 	ldw	r2,-60(fp)
 909e24c:	10801004 	addi	r2,r2,64
 909e250:	e0fffb03 	ldbu	r3,-20(fp)
 909e254:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 909e258:	e0bff117 	ldw	r2,-60(fp)
 909e25c:	1080a204 	addi	r2,r2,648
 909e260:	10800037 	ldwio	r2,0(r2)
 909e264:	e0bffd15 	stw	r2,-12(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 909e268:	e0bff117 	ldw	r2,-60(fp)
 909e26c:	1080a304 	addi	r2,r2,652
 909e270:	10800037 	ldwio	r2,0(r2)
 909e274:	e0bffc15 	stw	r2,-16(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 909e278:	e0fffd17 	ldw	r3,-12(fp)
 909e27c:	e0bffc17 	ldw	r2,-16(fp)
 909e280:	1880b626 	beq	r3,r2,909e55c <alt_tse_mac_get_phy+0x378>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 909e284:	01000704 	movi	r4,28
 909e288:	90cb4400 	call	90cb440 <malloc>
 909e28c:	e0bff415 	stw	r2,-48(fp)
            if(!pphy) {
 909e290:	e0bff417 	ldw	r2,-48(fp)
 909e294:	1004c03a 	cmpne	r2,r2,zero
 909e298:	1000081e 	bne	r2,zero,909e2bc <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 909e29c:	e17fef07 	ldb	r5,-68(fp)
 909e2a0:	e1bff507 	ldb	r6,-44(fp)
 909e2a4:	01024374 	movhi	r4,2317
 909e2a8:	2139f204 	addi	r4,r4,-6200
 909e2ac:	90833900 	call	9083390 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 909e2b0:	00bfffc4 	movi	r2,-1
 909e2b4:	e0bfff15 	stw	r2,-4(fp)
 909e2b8:	0000ca06 	br	909e5e4 <alt_tse_mac_get_phy+0x400>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 909e2bc:	e0fff417 	ldw	r3,-48(fp)
 909e2c0:	e0bffb03 	ldbu	r2,-20(fp)
 909e2c4:	18800005 	stb	r2,0(r3)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 909e2c8:	e0bffd17 	ldw	r2,-12(fp)
 909e2cc:	100691ba 	slli	r3,r2,6
 909e2d0:	e0bffc17 	ldw	r2,-16(fp)
 909e2d4:	1005d2ba 	srai	r2,r2,10
 909e2d8:	10800fcc 	andi	r2,r2,63
 909e2dc:	1884b03a 	or	r2,r3,r2
 909e2e0:	e0bffa15 	stw	r2,-24(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 909e2e4:	e0bffc17 	ldw	r2,-16(fp)
 909e2e8:	1005d13a 	srai	r2,r2,4
 909e2ec:	10800fcc 	andi	r2,r2,63
 909e2f0:	e0bff945 	stb	r2,-27(fp)
            revision_number = phyid2 & 0x0f;
 909e2f4:	e0bffc17 	ldw	r2,-16(fp)
 909e2f8:	108003cc 	andi	r2,r2,15
 909e2fc:	e0bff905 	stb	r2,-28(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 909e300:	e03ff705 	stb	zero,-36(fp)
            for(i = 0; i < phy_profile_count; i++) {
 909e304:	e03ff815 	stw	zero,-32(fp)
 909e308:	00003106 	br	909e3d0 <alt_tse_mac_get_phy+0x1ec>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 909e30c:	e0bff817 	ldw	r2,-32(fp)
 909e310:	00c243b4 	movhi	r3,2318
 909e314:	18f4c504 	addi	r3,r3,-11500
 909e318:	1085883a 	add	r2,r2,r2
 909e31c:	1085883a 	add	r2,r2,r2
 909e320:	10c5883a 	add	r2,r2,r3
 909e324:	10800017 	ldw	r2,0(r2)
 909e328:	10c01417 	ldw	r3,80(r2)
 909e32c:	e0bffa17 	ldw	r2,-24(fp)
 909e330:	1880241e 	bne	r3,r2,909e3c4 <alt_tse_mac_get_phy+0x1e0>
 909e334:	e0bff817 	ldw	r2,-32(fp)
 909e338:	00c243b4 	movhi	r3,2318
 909e33c:	18f4c504 	addi	r3,r3,-11500
 909e340:	1085883a 	add	r2,r2,r2
 909e344:	1085883a 	add	r2,r2,r2
 909e348:	10c5883a 	add	r2,r2,r3
 909e34c:	10800017 	ldw	r2,0(r2)
 909e350:	10801503 	ldbu	r2,84(r2)
 909e354:	10c03fcc 	andi	r3,r2,255
 909e358:	e0bff943 	ldbu	r2,-27(fp)
 909e35c:	1880191e 	bne	r3,r2,909e3c4 <alt_tse_mac_get_phy+0x1e0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 909e360:	e0bff817 	ldw	r2,-32(fp)
 909e364:	00c243b4 	movhi	r3,2318
 909e368:	18f4c504 	addi	r3,r3,-11500
 909e36c:	1085883a 	add	r2,r2,r2
 909e370:	1085883a 	add	r2,r2,r2
 909e374:	10c5883a 	add	r2,r2,r3
 909e378:	10c00017 	ldw	r3,0(r2)
 909e37c:	e0bff417 	ldw	r2,-48(fp)
 909e380:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 909e384:	e0bff817 	ldw	r2,-32(fp)
 909e388:	00c243b4 	movhi	r3,2318
 909e38c:	18f4c504 	addi	r3,r3,-11500
 909e390:	1085883a 	add	r2,r2,r2
 909e394:	1085883a 	add	r2,r2,r2
 909e398:	10c5883a 	add	r2,r2,r3
 909e39c:	10800017 	ldw	r2,0(r2)
 909e3a0:	100b883a 	mov	r5,r2
 909e3a4:	e1bffb03 	ldbu	r6,-20(fp)
 909e3a8:	e1ffef07 	ldb	r7,-68(fp)
 909e3ac:	01024374 	movhi	r4,2317
 909e3b0:	213a0104 	addi	r4,r4,-6140
 909e3b4:	90833900 	call	9083390 <printf>
                    is_phy_in_profile = 1;
 909e3b8:	00800044 	movi	r2,1
 909e3bc:	e0bff705 	stb	r2,-36(fp)
                    break;
 909e3c0:	00000706 	br	909e3e0 <alt_tse_mac_get_phy+0x1fc>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 909e3c4:	e0bff817 	ldw	r2,-32(fp)
 909e3c8:	10800044 	addi	r2,r2,1
 909e3cc:	e0bff815 	stw	r2,-32(fp)
 909e3d0:	d0a08003 	ldbu	r2,-32256(gp)
 909e3d4:	10c03fcc 	andi	r3,r2,255
 909e3d8:	e0bff817 	ldw	r2,-32(fp)
 909e3dc:	10ffcb16 	blt	r2,r3,909e30c <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 909e3e0:	e0bff703 	ldbu	r2,-36(fp)
 909e3e4:	1004c03a 	cmpne	r2,r2,zero
 909e3e8:	10000d1e 	bne	r2,zero,909e420 <alt_tse_mac_get_phy+0x23c>
                pphy->pphy_profile = 0;
 909e3ec:	e0bff417 	ldw	r2,-48(fp)
 909e3f0:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 909e3f4:	e17ffb03 	ldbu	r5,-20(fp)
 909e3f8:	e1bfef07 	ldb	r6,-68(fp)
 909e3fc:	01024374 	movhi	r4,2317
 909e400:	213a1104 	addi	r4,r4,-6076
 909e404:	90833900 	call	9083390 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 909e408:	01024374 	movhi	r4,2317
 909e40c:	213a2204 	addi	r4,r4,-6008
 909e410:	90836b80 	call	90836b8 <puts>
                return_value++;
 909e414:	e0bff617 	ldw	r2,-40(fp)
 909e418:	10800044 	addi	r2,r2,1
 909e41c:	e0bff615 	stw	r2,-40(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 909e420:	e17ffa17 	ldw	r5,-24(fp)
 909e424:	01024374 	movhi	r4,2317
 909e428:	213a2f04 	addi	r4,r4,-5956
 909e42c:	909b0a80 	call	909b0a8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 909e430:	e17ff943 	ldbu	r5,-27(fp)
 909e434:	01024374 	movhi	r4,2317
 909e438:	213a3a04 	addi	r4,r4,-5912
 909e43c:	909b0a80 	call	909b0a8 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 909e440:	e17ff903 	ldbu	r5,-28(fp)
 909e444:	01024374 	movhi	r4,2317
 909e448:	213a4504 	addi	r4,r4,-5868
 909e44c:	909b0a80 	call	909b0a8 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 909e450:	e13ffe17 	ldw	r4,-8(fp)
 909e454:	e17ff417 	ldw	r5,-48(fp)
 909e458:	909e5fc0 	call	909e5fc <alt_tse_mac_associate_phy>
 909e45c:	1004c03a 	cmpne	r2,r2,zero
 909e460:	1000381e 	bne	r2,zero,909e544 <alt_tse_mac_get_phy+0x360>
            	
            	pmac_info = pphy->pmac_info;
 909e464:	e0bff417 	ldw	r2,-48(fp)
 909e468:	10800617 	ldw	r2,24(r2)
 909e46c:	e0bff315 	stw	r2,-52(fp)
            	psys = pmac_info->psys_info;
 909e470:	e0bff317 	ldw	r2,-52(fp)
 909e474:	10800217 	ldw	r2,8(r2)
 909e478:	e0bff215 	stw	r2,-56(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 909e47c:	d8000015 	stw	zero,0(sp)
 909e480:	e13ff417 	ldw	r4,-48(fp)
 909e484:	000b883a 	mov	r5,zero
 909e488:	01800384 	movi	r6,14
 909e48c:	01c00044 	movi	r7,1
 909e490:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 909e494:	e13ff417 	ldw	r4,-48(fp)
 909e498:	01400044 	movi	r5,1
 909e49c:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 909e4a0:	e13ff417 	ldw	r4,-48(fp)
 909e4a4:	01400044 	movi	r5,1
 909e4a8:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 909e4ac:	e13ff417 	ldw	r4,-48(fp)
 909e4b0:	01400044 	movi	r5,1
 909e4b4:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 909e4b8:	e13ff417 	ldw	r4,-48(fp)
 909e4bc:	014003f4 	movhi	r5,15
 909e4c0:	29509004 	addi	r5,r5,16960
 909e4c4:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 909e4c8:	e0bff417 	ldw	r2,-48(fp)
 909e4cc:	10800517 	ldw	r2,20(r2)
 909e4d0:	1005003a 	cmpeq	r2,r2,zero
 909e4d4:	1000101e 	bne	r2,zero,909e518 <alt_tse_mac_get_phy+0x334>
		            if(pphy->pphy_profile->phy_cfg) {
 909e4d8:	e0bff417 	ldw	r2,-48(fp)
 909e4dc:	10800517 	ldw	r2,20(r2)
 909e4e0:	10801717 	ldw	r2,92(r2)
 909e4e4:	1005003a 	cmpeq	r2,r2,zero
 909e4e8:	10000b1e 	bne	r2,zero,909e518 <alt_tse_mac_get_phy+0x334>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 909e4ec:	e0bff417 	ldw	r2,-48(fp)
 909e4f0:	10800517 	ldw	r2,20(r2)
 909e4f4:	100b883a 	mov	r5,r2
 909e4f8:	01024374 	movhi	r4,2317
 909e4fc:	213a5004 	addi	r4,r4,-5824
 909e500:	909b0a80 	call	909b0a8 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 909e504:	e0bff417 	ldw	r2,-48(fp)
 909e508:	10800517 	ldw	r2,20(r2)
 909e50c:	10801717 	ldw	r2,92(r2)
 909e510:	e13ff117 	ldw	r4,-60(fp)
 909e514:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 909e518:	e0bff217 	ldw	r2,-56(fp)
 909e51c:	10801117 	ldw	r2,68(r2)
 909e520:	1005003a 	cmpeq	r2,r2,zero
 909e524:	1000071e 	bne	r2,zero,909e544 <alt_tse_mac_get_phy+0x360>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 909e528:	01024374 	movhi	r4,2317
 909e52c:	213a5e04 	addi	r4,r4,-5768
 909e530:	909b0a80 	call	909b0a8 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 909e534:	e0bff217 	ldw	r2,-56(fp)
 909e538:	10801117 	ldw	r2,68(r2)
 909e53c:	e13ff117 	ldw	r4,-60(fp)
 909e540:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 909e544:	01024374 	movhi	r4,2317
 909e548:	213a6c04 	addi	r4,r4,-5712
 909e54c:	909b0a80 	call	909b0a8 <no_printf>
	            
            phy_info_count++;
 909e550:	e0bff503 	ldbu	r2,-44(fp)
 909e554:	10800044 	addi	r2,r2,1
 909e558:	e0bff505 	stb	r2,-44(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 909e55c:	e0bffb03 	ldbu	r2,-20(fp)
 909e560:	10800044 	addi	r2,r2,1
 909e564:	e0bffb05 	stb	r2,-20(fp)
 909e568:	e0bffb03 	ldbu	r2,-20(fp)
 909e56c:	10800830 	cmpltui	r2,r2,32
 909e570:	103f351e 	bne	r2,zero,909e248 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 909e574:	e0bffe17 	ldw	r2,-8(fp)
 909e578:	10800003 	ldbu	r2,0(r2)
 909e57c:	10c03fcc 	andi	r3,r2,255
 909e580:	e0bff507 	ldb	r2,-44(fp)
 909e584:	18801026 	beq	r3,r2,909e5c8 <alt_tse_mac_get_phy+0x3e4>
        if(phy_info_count == 0) {
 909e588:	e0bff507 	ldb	r2,-44(fp)
 909e58c:	1004c03a 	cmpne	r2,r2,zero
 909e590:	1000051e 	bne	r2,zero,909e5a8 <alt_tse_mac_get_phy+0x3c4>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 909e594:	e17fef07 	ldb	r5,-68(fp)
 909e598:	01024374 	movhi	r4,2317
 909e59c:	213a6d04 	addi	r4,r4,-5708
 909e5a0:	90833900 	call	9083390 <printf>
 909e5a4:	00000806 	br	909e5c8 <alt_tse_mac_get_phy+0x3e4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 909e5a8:	e17fef07 	ldb	r5,-68(fp)
 909e5ac:	e1bff507 	ldb	r6,-44(fp)
 909e5b0:	e0bffe17 	ldw	r2,-8(fp)
 909e5b4:	10800003 	ldbu	r2,0(r2)
 909e5b8:	11c03fcc 	andi	r7,r2,255
 909e5bc:	01024374 	movhi	r4,2317
 909e5c0:	213a7904 	addi	r4,r4,-5660
 909e5c4:	90833900 	call	9083390 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909e5c8:	e0bff117 	ldw	r2,-60(fp)
 909e5cc:	10801004 	addi	r2,r2,64
 909e5d0:	1007883a 	mov	r3,r2
 909e5d4:	e0bff017 	ldw	r2,-64(fp)
 909e5d8:	18800035 	stwio	r2,0(r3)
    
    return return_value;
 909e5dc:	e0bff617 	ldw	r2,-40(fp)
 909e5e0:	e0bfff15 	stw	r2,-4(fp)
 909e5e4:	e0bfff17 	ldw	r2,-4(fp)
}
 909e5e8:	e037883a 	mov	sp,fp
 909e5ec:	dfc00117 	ldw	ra,4(sp)
 909e5f0:	df000017 	ldw	fp,0(sp)
 909e5f4:	dec00204 	addi	sp,sp,8
 909e5f8:	f800283a 	ret

0909e5fc <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 909e5fc:	defff604 	addi	sp,sp,-40
 909e600:	dfc00915 	stw	ra,36(sp)
 909e604:	df000815 	stw	fp,32(sp)
 909e608:	df000804 	addi	fp,sp,32
 909e60c:	e13ffe15 	stw	r4,-8(fp)
 909e610:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 909e614:	e03ffc15 	stw	zero,-16(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 909e618:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_info *pmac_info = 0;
 909e61c:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909e620:	e03ff885 	stb	zero,-30(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e624:	e13ffe17 	ldw	r4,-8(fp)
 909e628:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909e62c:	e0bff845 	stb	r2,-31(fp)
    alt_8 sys_info_index = 0;
 909e630:	e03ff805 	stb	zero,-32(fp)
    
    is_mapped = 0;
 909e634:	e03ffb05 	stb	zero,-20(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 909e638:	e03ffd15 	stw	zero,-12(fp)
 909e63c:	00002906 	br	909e6e4 <alt_tse_mac_associate_phy+0xe8>
        pmac_info = pmac_group->pmac_info[i];
 909e640:	e0bffd17 	ldw	r2,-12(fp)
 909e644:	e0fffe17 	ldw	r3,-8(fp)
 909e648:	1085883a 	add	r2,r2,r2
 909e64c:	1085883a 	add	r2,r2,r2
 909e650:	10c5883a 	add	r2,r2,r3
 909e654:	10800104 	addi	r2,r2,4
 909e658:	10800017 	ldw	r2,0(r2)
 909e65c:	e0bff915 	stw	r2,-28(fp)
        psys = pmac_info->psys_info;
 909e660:	e0bff917 	ldw	r2,-28(fp)
 909e664:	10800217 	ldw	r2,8(r2)
 909e668:	e0bffa15 	stw	r2,-24(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 909e66c:	e0bffa17 	ldw	r2,-24(fp)
 909e670:	10c01017 	ldw	r3,64(r2)
 909e674:	e0bfff17 	ldw	r2,-4(fp)
 909e678:	10800003 	ldbu	r2,0(r2)
 909e67c:	10803fcc 	andi	r2,r2,255
 909e680:	1880151e 	bne	r3,r2,909e6d8 <alt_tse_mac_associate_phy+0xdc>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e684:	e13ff917 	ldw	r4,-28(fp)
 909e688:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909e68c:	e0bff885 	stb	r2,-30(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 909e690:	e13ffa17 	ldw	r4,-24(fp)
 909e694:	909c1f40 	call	909c1f4 <alt_tse_get_system_index>
 909e698:	e0bff805 	stb	r2,-32(fp)
	        
            pmac_info->pphy_info = pphy;
 909e69c:	e0fff917 	ldw	r3,-28(fp)
 909e6a0:	e0bfff17 	ldw	r2,-4(fp)
 909e6a4:	18800115 	stw	r2,4(r3)
            pphy->pmac_info = pmac_info;
 909e6a8:	e0ffff17 	ldw	r3,-4(fp)
 909e6ac:	e0bff917 	ldw	r2,-28(fp)
 909e6b0:	18800615 	stw	r2,24(r3)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 909e6b4:	e17ff847 	ldb	r5,-31(fp)
 909e6b8:	e1bff887 	ldb	r6,-30(fp)
 909e6bc:	e1fff807 	ldb	r7,-32(fp)
 909e6c0:	01024374 	movhi	r4,2317
 909e6c4:	213a9804 	addi	r4,r4,-5536
 909e6c8:	90833900 	call	9083390 <printf>
            is_mapped = 1;
 909e6cc:	00800044 	movi	r2,1
 909e6d0:	e0bffb05 	stb	r2,-20(fp)
            break;
 909e6d4:	00000806 	br	909e6f8 <alt_tse_mac_associate_phy+0xfc>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 909e6d8:	e0bffd17 	ldw	r2,-12(fp)
 909e6dc:	10800044 	addi	r2,r2,1
 909e6e0:	e0bffd15 	stw	r2,-12(fp)
 909e6e4:	e0bffe17 	ldw	r2,-8(fp)
 909e6e8:	10800003 	ldbu	r2,0(r2)
 909e6ec:	10c03fcc 	andi	r3,r2,255
 909e6f0:	e0bffd17 	ldw	r2,-12(fp)
 909e6f4:	10ffd216 	blt	r2,r3,909e640 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 909e6f8:	e0bffb03 	ldbu	r2,-20(fp)
 909e6fc:	1004c03a 	cmpne	r2,r2,zero
 909e700:	10003b1e 	bne	r2,zero,909e7f0 <alt_tse_mac_associate_phy+0x1f4>
        for(i = 0; i < pmac_group->channel; i++) {
 909e704:	e03ffd15 	stw	zero,-12(fp)
 909e708:	00003406 	br	909e7dc <alt_tse_mac_associate_phy+0x1e0>
            pmac_info = pmac_group->pmac_info[i];
 909e70c:	e0bffd17 	ldw	r2,-12(fp)
 909e710:	e0fffe17 	ldw	r3,-8(fp)
 909e714:	1085883a 	add	r2,r2,r2
 909e718:	1085883a 	add	r2,r2,r2
 909e71c:	10c5883a 	add	r2,r2,r3
 909e720:	10800104 	addi	r2,r2,4
 909e724:	10800017 	ldw	r2,0(r2)
 909e728:	e0bff915 	stw	r2,-28(fp)
            psys = pmac_info->psys_info;
 909e72c:	e0bff917 	ldw	r2,-28(fp)
 909e730:	10800217 	ldw	r2,8(r2)
 909e734:	e0bffa15 	stw	r2,-24(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 909e738:	e0bffa17 	ldw	r2,-24(fp)
 909e73c:	10800517 	ldw	r2,20(r2)
 909e740:	1005003a 	cmpeq	r2,r2,zero
 909e744:	1000221e 	bne	r2,zero,909e7d0 <alt_tse_mac_associate_phy+0x1d4>
 909e748:	e0bffa17 	ldw	r2,-24(fp)
 909e74c:	10800617 	ldw	r2,24(r2)
 909e750:	1005003a 	cmpeq	r2,r2,zero
 909e754:	10001e1e 	bne	r2,zero,909e7d0 <alt_tse_mac_associate_phy+0x1d4>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 909e758:	e0bffa17 	ldw	r2,-24(fp)
 909e75c:	10801017 	ldw	r2,64(r2)
 909e760:	10bfffd8 	cmpnei	r2,r2,-1
 909e764:	10001a1e 	bne	r2,zero,909e7d0 <alt_tse_mac_associate_phy+0x1d4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e768:	e13ff917 	ldw	r4,-28(fp)
 909e76c:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909e770:	e0bff885 	stb	r2,-30(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 909e774:	e13ffa17 	ldw	r4,-24(fp)
 909e778:	909c1f40 	call	909c1f4 <alt_tse_get_system_index>
 909e77c:	e0bff805 	stb	r2,-32(fp)
                
                pmac_info->pphy_info = pphy;
 909e780:	e0fff917 	ldw	r3,-28(fp)
 909e784:	e0bfff17 	ldw	r2,-4(fp)
 909e788:	18800115 	stw	r2,4(r3)
                pphy->pmac_info = pmac_info;
 909e78c:	e0ffff17 	ldw	r3,-4(fp)
 909e790:	e0bff917 	ldw	r2,-28(fp)
 909e794:	18800615 	stw	r2,24(r3)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 909e798:	e0bfff17 	ldw	r2,-4(fp)
 909e79c:	10800003 	ldbu	r2,0(r2)
 909e7a0:	10c03fcc 	andi	r3,r2,255
 909e7a4:	e0bffa17 	ldw	r2,-24(fp)
 909e7a8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 909e7ac:	e17ff847 	ldb	r5,-31(fp)
 909e7b0:	e1bff887 	ldb	r6,-30(fp)
 909e7b4:	e1fff807 	ldb	r7,-32(fp)
 909e7b8:	01024374 	movhi	r4,2317
 909e7bc:	213aa804 	addi	r4,r4,-5472
 909e7c0:	90833900 	call	9083390 <printf>
                is_mapped = 1;
 909e7c4:	00800044 	movi	r2,1
 909e7c8:	e0bffb05 	stb	r2,-20(fp)
                break;
 909e7cc:	00000806 	br	909e7f0 <alt_tse_mac_associate_phy+0x1f4>
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 909e7d0:	e0bffd17 	ldw	r2,-12(fp)
 909e7d4:	10800044 	addi	r2,r2,1
 909e7d8:	e0bffd15 	stw	r2,-12(fp)
 909e7dc:	e0bffe17 	ldw	r2,-8(fp)
 909e7e0:	10800003 	ldbu	r2,0(r2)
 909e7e4:	10c03fcc 	andi	r3,r2,255
 909e7e8:	e0bffd17 	ldw	r2,-12(fp)
 909e7ec:	10ffc716 	blt	r2,r3,909e70c <alt_tse_mac_associate_phy+0x110>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 909e7f0:	e0bffb03 	ldbu	r2,-20(fp)
 909e7f4:	1004c03a 	cmpne	r2,r2,zero
 909e7f8:	1000081e 	bne	r2,zero,909e81c <alt_tse_mac_associate_phy+0x220>
    	pphy->pmac_info = 0;
 909e7fc:	e0bfff17 	ldw	r2,-4(fp)
 909e800:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 909e804:	e17ff847 	ldb	r5,-31(fp)
 909e808:	01024374 	movhi	r4,2317
 909e80c:	213ab904 	addi	r4,r4,-5404
 909e810:	90833900 	call	9083390 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 909e814:	00bfffc4 	movi	r2,-1
 909e818:	e0bffc15 	stw	r2,-16(fp)
    }
    
    return return_value;
 909e81c:	e0bffc17 	ldw	r2,-16(fp)
}
 909e820:	e037883a 	mov	sp,fp
 909e824:	dfc00117 	ldw	ra,4(sp)
 909e828:	df000017 	ldw	fp,0(sp)
 909e82c:	dec00204 	addi	sp,sp,8
 909e830:	f800283a 	ret

0909e834 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 909e834:	defff804 	addi	sp,sp,-32
 909e838:	dfc00715 	stw	ra,28(sp)
 909e83c:	df000615 	stw	fp,24(sp)
 909e840:	df000604 	addi	fp,sp,24
 909e844:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 909e848:	e0bfff17 	ldw	r2,-4(fp)
 909e84c:	10800217 	ldw	r2,8(r2)
 909e850:	e0bffe15 	stw	r2,-8(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 909e854:	e0bffe17 	ldw	r2,-8(fp)
 909e858:	10800017 	ldw	r2,0(r2)
 909e85c:	e0bffd15 	stw	r2,-12(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909e860:	e0bfff17 	ldw	r2,-4(fp)
 909e864:	10800317 	ldw	r2,12(r2)
 909e868:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909e86c:	e13fff17 	ldw	r4,-4(fp)
 909e870:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909e874:	e0bffb45 	stb	r2,-19(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909e878:	e13ffc17 	ldw	r4,-16(fp)
 909e87c:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909e880:	e0bffb05 	stb	r2,-20(fp)

    if(psys->tse_pcs_ena) {
 909e884:	e0bffe17 	ldw	r2,-8(fp)
 909e888:	108003c3 	ldbu	r2,15(r2)
 909e88c:	10803fcc 	andi	r2,r2,255
 909e890:	1005003a 	cmpeq	r2,r2,zero
 909e894:	1000291e 	bne	r2,zero,909e93c <alt_tse_phy_cfg_pcs+0x108>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 909e898:	e17ffb07 	ldb	r5,-20(fp)
 909e89c:	e1bffb47 	ldb	r6,-19(fp)
 909e8a0:	01024374 	movhi	r4,2317
 909e8a4:	213aea04 	addi	r4,r4,-5208
 909e8a8:	90833900 	call	9083390 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 909e8ac:	e0bffd17 	ldw	r2,-12(fp)
 909e8b0:	10808004 	addi	r2,r2,512
 909e8b4:	10801404 	addi	r2,r2,80
 909e8b8:	10800037 	ldwio	r2,0(r2)
 909e8bc:	e0bffa15 	stw	r2,-24(fp)
        
        if(psys->tse_pcs_sgmii) {
 909e8c0:	e0bffe17 	ldw	r2,-8(fp)
 909e8c4:	10800403 	ldbu	r2,16(r2)
 909e8c8:	10803fcc 	andi	r2,r2,255
 909e8cc:	1005003a 	cmpeq	r2,r2,zero
 909e8d0:	10000d1e 	bne	r2,zero,909e908 <alt_tse_phy_cfg_pcs+0xd4>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 909e8d4:	e17ffb07 	ldb	r5,-20(fp)
 909e8d8:	e1bffb47 	ldb	r6,-19(fp)
 909e8dc:	01024374 	movhi	r4,2317
 909e8e0:	213af804 	addi	r4,r4,-5152
 909e8e4:	90833900 	call	9083390 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 909e8e8:	e0bffd17 	ldw	r2,-12(fp)
 909e8ec:	10808004 	addi	r2,r2,512
 909e8f0:	11001404 	addi	r4,r2,80
 909e8f4:	e0bffa17 	ldw	r2,-24(fp)
 909e8f8:	10c000d4 	ori	r3,r2,3
 909e8fc:	2005883a 	mov	r2,r4
 909e900:	10c00035 	stwio	r3,0(r2)
 909e904:	00000d06 	br	909e93c <alt_tse_phy_cfg_pcs+0x108>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 909e908:	e17ffb07 	ldb	r5,-20(fp)
 909e90c:	e1bffb47 	ldb	r6,-19(fp)
 909e910:	01024374 	movhi	r4,2317
 909e914:	213b0404 	addi	r4,r4,-5104
 909e918:	90833900 	call	9083390 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 909e91c:	e0bffd17 	ldw	r2,-12(fp)
 909e920:	10808004 	addi	r2,r2,512
 909e924:	11001404 	addi	r4,r2,80
 909e928:	e0fffa17 	ldw	r3,-24(fp)
 909e92c:	00bfff04 	movi	r2,-4
 909e930:	1886703a 	and	r3,r3,r2
 909e934:	2005883a 	mov	r2,r4
 909e938:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 909e93c:	0005883a 	mov	r2,zero
}
 909e940:	e037883a 	mov	sp,fp
 909e944:	dfc00117 	ldw	ra,4(sp)
 909e948:	df000017 	ldw	fp,0(sp)
 909e94c:	dec00204 	addi	sp,sp,8
 909e950:	f800283a 	ret

0909e954 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 909e954:	defffb04 	addi	sp,sp,-20
 909e958:	dfc00415 	stw	ra,16(sp)
 909e95c:	df000315 	stw	fp,12(sp)
 909e960:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 909e964:	e03fff45 	stb	zero,-3(fp)
	alt_8 j = 0;
 909e968:	e03fff05 	stb	zero,-4(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 909e96c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 909e970:	e03ffd15 	stw	zero,-12(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 909e974:	909d6700 	call	909d670 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 909e978:	909d8e80 	call	909d8e8 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 909e97c:	909dad80 	call	909dad8 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 909e980:	e03fff45 	stb	zero,-3(fp)
 909e984:	00002e06 	br	909ea40 <alt_tse_phy_init+0xec>
        pmac_group = pmac_groups[i];
 909e988:	e0bfff47 	ldb	r2,-3(fp)
 909e98c:	00c243b4 	movhi	r3,2318
 909e990:	18f4c104 	addi	r3,r3,-11516
 909e994:	1085883a 	add	r2,r2,r2
 909e998:	1085883a 	add	r2,r2,r2
 909e99c:	10c5883a 	add	r2,r2,r3
 909e9a0:	10800017 	ldw	r2,0(r2)
 909e9a4:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 909e9a8:	e0bffe17 	ldw	r2,-8(fp)
 909e9ac:	10800117 	ldw	r2,4(r2)
 909e9b0:	10800217 	ldw	r2,8(r2)
 909e9b4:	10800203 	ldbu	r2,8(r2)
 909e9b8:	10803fcc 	andi	r2,r2,255
 909e9bc:	1005003a 	cmpeq	r2,r2,zero
 909e9c0:	1000031e 	bne	r2,zero,909e9d0 <alt_tse_phy_init+0x7c>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 909e9c4:	e13ffe17 	ldw	r4,-8(fp)
 909e9c8:	909e1e40 	call	909e1e4 <alt_tse_mac_get_phy>
 909e9cc:	00000506 	br	909e9e4 <alt_tse_phy_init+0x90>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 909e9d0:	e17fff47 	ldb	r5,-3(fp)
 909e9d4:	e1bfff07 	ldb	r6,-4(fp)
 909e9d8:	01024374 	movhi	r4,2317
 909e9dc:	213b1004 	addi	r4,r4,-5056
 909e9e0:	90833900 	call	9083390 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 909e9e4:	e03fff05 	stb	zero,-4(fp)
 909e9e8:	00000d06 	br	909ea20 <alt_tse_phy_init+0xcc>
            pmac_info = pmac_group->pmac_info[j];
 909e9ec:	e0bfff07 	ldb	r2,-4(fp)
 909e9f0:	e0fffe17 	ldw	r3,-8(fp)
 909e9f4:	1085883a 	add	r2,r2,r2
 909e9f8:	1085883a 	add	r2,r2,r2
 909e9fc:	10c5883a 	add	r2,r2,r3
 909ea00:	10800104 	addi	r2,r2,4
 909ea04:	10800017 	ldw	r2,0(r2)
 909ea08:	e0bffd15 	stw	r2,-12(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 909ea0c:	e13ffd17 	ldw	r4,-12(fp)
 909ea10:	909e8340 	call	909e834 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 909ea14:	e0bfff03 	ldbu	r2,-4(fp)
 909ea18:	10800044 	addi	r2,r2,1
 909ea1c:	e0bfff05 	stb	r2,-4(fp)
 909ea20:	e0ffff07 	ldb	r3,-4(fp)
 909ea24:	e0bffe17 	ldw	r2,-8(fp)
 909ea28:	10800003 	ldbu	r2,0(r2)
 909ea2c:	10803fcc 	andi	r2,r2,255
 909ea30:	18bfee16 	blt	r3,r2,909e9ec <alt_tse_phy_init+0x98>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 909ea34:	e0bfff43 	ldbu	r2,-3(fp)
 909ea38:	10800044 	addi	r2,r2,1
 909ea3c:	e0bfff45 	stb	r2,-3(fp)
 909ea40:	e0bfff47 	ldb	r2,-3(fp)
 909ea44:	d0e08043 	ldbu	r3,-32255(gp)
 909ea48:	18c03fcc 	andi	r3,r3,255
 909ea4c:	10ffce16 	blt	r2,r3,909e988 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 909ea50:	0005883a 	mov	r2,zero
}
 909ea54:	e037883a 	mov	sp,fp
 909ea58:	dfc00117 	ldw	ra,4(sp)
 909ea5c:	df000017 	ldw	fp,0(sp)
 909ea60:	dec00204 	addi	sp,sp,8
 909ea64:	f800283a 	ret

0909ea68 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 909ea68:	defff604 	addi	sp,sp,-40
 909ea6c:	dfc00915 	stw	ra,36(sp)
 909ea70:	df000815 	stw	fp,32(sp)
 909ea74:	df000804 	addi	fp,sp,32
 909ea78:	e13ffd15 	stw	r4,-12(fp)
 909ea7c:	e17ffe15 	stw	r5,-8(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909ea80:	e0bffd17 	ldw	r2,-12(fp)
 909ea84:	10800617 	ldw	r2,24(r2)
 909ea88:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909ea8c:	e0bffc17 	ldw	r2,-16(fp)
 909ea90:	10800317 	ldw	r2,12(r2)
 909ea94:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909ea98:	e13ffc17 	ldw	r4,-16(fp)
 909ea9c:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909eaa0:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909eaa4:	e13ffb17 	ldw	r4,-20(fp)
 909eaa8:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909eaac:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909eab0:	e13ffd17 	ldw	r4,-12(fp)
 909eab4:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909eab8:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909eabc:	e0bffd17 	ldw	r2,-12(fp)
 909eac0:	10800003 	ldbu	r2,0(r2)
 909eac4:	11403fcc 	andi	r5,r2,255
 909eac8:	e13ffd17 	ldw	r4,-12(fp)
 909eacc:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909ead0:	e13ffd17 	ldw	r4,-12(fp)
 909ead4:	01400044 	movi	r5,1
 909ead8:	018000c4 	movi	r6,3
 909eadc:	01c00044 	movi	r7,1
 909eae0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eae4:	1004c03a 	cmpne	r2,r2,zero
 909eae8:	10000b1e 	bne	r2,zero,909eb18 <alt_tse_phy_restart_an+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 909eaec:	e17ffa47 	ldb	r5,-23(fp)
 909eaf0:	e1bffa87 	ldb	r6,-22(fp)
 909eaf4:	01024374 	movhi	r4,2317
 909eaf8:	213b2604 	addi	r4,r4,-4968
 909eafc:	90833900 	call	9083390 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909eb00:	e17ffa03 	ldbu	r5,-24(fp)
 909eb04:	e13ffd17 	ldw	r4,-12(fp)
 909eb08:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 909eb0c:	00bfff84 	movi	r2,-2
 909eb10:	e0bfff15 	stw	r2,-4(fp)
 909eb14:	00003a06 	br	909ec00 <alt_tse_phy_restart_an+0x198>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 909eb18:	00800044 	movi	r2,1
 909eb1c:	d8800015 	stw	r2,0(sp)
 909eb20:	e13ffd17 	ldw	r4,-12(fp)
 909eb24:	000b883a 	mov	r5,zero
 909eb28:	01800304 	movi	r6,12
 909eb2c:	01c00044 	movi	r7,1
 909eb30:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 909eb34:	00800044 	movi	r2,1
 909eb38:	d8800015 	stw	r2,0(sp)
 909eb3c:	e13ffd17 	ldw	r4,-12(fp)
 909eb40:	000b883a 	mov	r5,zero
 909eb44:	01800244 	movi	r6,9
 909eb48:	01c00044 	movi	r7,1
 909eb4c:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 909eb50:	e17ffa47 	ldb	r5,-23(fp)
 909eb54:	e1bffa87 	ldb	r6,-22(fp)
 909eb58:	01024374 	movhi	r4,2317
 909eb5c:	213b3604 	addi	r4,r4,-4904
 909eb60:	90833900 	call	9083390 <printf>
    
    alt_32 timeout = 0;
 909eb64:	e03ff915 	stw	zero,-28(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 909eb68:	00001506 	br	909ebc0 <alt_tse_phy_restart_an+0x158>
        if(timeout++ > timeout_threshold) {
 909eb6c:	e0fff917 	ldw	r3,-28(fp)
 909eb70:	e0bffe17 	ldw	r2,-8(fp)
 909eb74:	10c5803a 	cmpltu	r2,r2,r3
 909eb78:	1007883a 	mov	r3,r2
 909eb7c:	e0bff917 	ldw	r2,-28(fp)
 909eb80:	10800044 	addi	r2,r2,1
 909eb84:	e0bff915 	stw	r2,-28(fp)
 909eb88:	18803fcc 	andi	r2,r3,255
 909eb8c:	1005003a 	cmpeq	r2,r2,zero
 909eb90:	10000b1e 	bne	r2,zero,909ebc0 <alt_tse_phy_restart_an+0x158>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 909eb94:	e17ffa47 	ldb	r5,-23(fp)
 909eb98:	e1bffa87 	ldb	r6,-22(fp)
 909eb9c:	01024374 	movhi	r4,2317
 909eba0:	213b4804 	addi	r4,r4,-4832
 909eba4:	90833900 	call	9083390 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909eba8:	e17ffa03 	ldbu	r5,-24(fp)
 909ebac:	e13ffd17 	ldw	r4,-12(fp)
 909ebb0:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 909ebb4:	00bfffc4 	movi	r2,-1
 909ebb8:	e0bfff15 	stw	r2,-4(fp)
 909ebbc:	00001006 	br	909ec00 <alt_tse_phy_restart_an+0x198>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 909ebc0:	e13ffd17 	ldw	r4,-12(fp)
 909ebc4:	01400044 	movi	r5,1
 909ebc8:	01800144 	movi	r6,5
 909ebcc:	01c00044 	movi	r7,1
 909ebd0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ebd4:	1005003a 	cmpeq	r2,r2,zero
 909ebd8:	103fe41e 	bne	r2,zero,909eb6c <alt_tse_phy_restart_an+0x104>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 909ebdc:	e17ffa47 	ldb	r5,-23(fp)
 909ebe0:	e1bffa87 	ldb	r6,-22(fp)
 909ebe4:	01024374 	movhi	r4,2317
 909ebe8:	213b5404 	addi	r4,r4,-4784
 909ebec:	90833900 	call	9083390 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909ebf0:	e17ffa03 	ldbu	r5,-24(fp)
 909ebf4:	e13ffd17 	ldw	r4,-12(fp)
 909ebf8:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 909ebfc:	e03fff15 	stw	zero,-4(fp)
 909ec00:	e0bfff17 	ldw	r2,-4(fp)
}
 909ec04:	e037883a 	mov	sp,fp
 909ec08:	dfc00117 	ldw	ra,4(sp)
 909ec0c:	df000017 	ldw	fp,0(sp)
 909ec10:	dec00204 	addi	sp,sp,8
 909ec14:	f800283a 	ret

0909ec18 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 909ec18:	defff804 	addi	sp,sp,-32
 909ec1c:	dfc00715 	stw	ra,28(sp)
 909ec20:	df000615 	stw	fp,24(sp)
 909ec24:	df000604 	addi	fp,sp,24
 909ec28:	e13ffd15 	stw	r4,-12(fp)
 909ec2c:	e17ffe15 	stw	r5,-8(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909ec30:	e0bffd17 	ldw	r2,-12(fp)
 909ec34:	10800617 	ldw	r2,24(r2)
 909ec38:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909ec3c:	e0bffc17 	ldw	r2,-16(fp)
 909ec40:	10800317 	ldw	r2,12(r2)
 909ec44:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909ec48:	e13ffc17 	ldw	r4,-16(fp)
 909ec4c:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909ec50:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 909ec54:	e13ffb17 	ldw	r4,-20(fp)
 909ec58:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909ec5c:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909ec60:	e13ffd17 	ldw	r4,-12(fp)
 909ec64:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909ec68:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909ec6c:	e0bffd17 	ldw	r2,-12(fp)
 909ec70:	10800003 	ldbu	r2,0(r2)
 909ec74:	11403fcc 	andi	r5,r2,255
 909ec78:	e13ffd17 	ldw	r4,-12(fp)
 909ec7c:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 909ec80:	e17ffa47 	ldb	r5,-23(fp)
 909ec84:	e1bffa87 	ldb	r6,-22(fp)
 909ec88:	01024374 	movhi	r4,2317
 909ec8c:	213b6004 	addi	r4,r4,-4736
 909ec90:	90833900 	call	9083390 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 909ec94:	e13ffd17 	ldw	r4,-12(fp)
 909ec98:	000b883a 	mov	r5,zero
 909ec9c:	01800384 	movi	r6,14
 909eca0:	01c00044 	movi	r7,1
 909eca4:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eca8:	1004c03a 	cmpne	r2,r2,zero
 909ecac:	1000071e 	bne	r2,zero,909eccc <alt_tse_phy_check_link+0xb4>
 909ecb0:	e13ffd17 	ldw	r4,-12(fp)
 909ecb4:	01400044 	movi	r5,1
 909ecb8:	01800144 	movi	r6,5
 909ecbc:	01c00044 	movi	r7,1
 909ecc0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ecc4:	1004c03a 	cmpne	r2,r2,zero
 909ecc8:	1000151e 	bne	r2,zero,909ed20 <alt_tse_phy_check_link+0x108>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 909eccc:	e17ffa47 	ldb	r5,-23(fp)
 909ecd0:	e1bffa87 	ldb	r6,-22(fp)
 909ecd4:	01024374 	movhi	r4,2317
 909ecd8:	213b6b04 	addi	r4,r4,-4692
 909ecdc:	90833900 	call	9083390 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 909ece0:	e13ffd17 	ldw	r4,-12(fp)
 909ece4:	e17ffe17 	ldw	r5,-8(fp)
 909ece8:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
 909ecec:	10bfffd8 	cmpnei	r2,r2,-1
 909ecf0:	10000b1e 	bne	r2,zero,909ed20 <alt_tse_phy_check_link+0x108>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 909ecf4:	e17ffa47 	ldb	r5,-23(fp)
 909ecf8:	e1bffa87 	ldb	r6,-22(fp)
 909ecfc:	01024374 	movhi	r4,2317
 909ed00:	213b7f04 	addi	r4,r4,-4612
 909ed04:	90833900 	call	9083390 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909ed08:	e17ffa03 	ldbu	r5,-24(fp)
 909ed0c:	e13ffd17 	ldw	r4,-12(fp)
 909ed10:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 909ed14:	00bfffc4 	movi	r2,-1
 909ed18:	e0bfff15 	stw	r2,-4(fp)
 909ed1c:	00000906 	br	909ed44 <alt_tse_phy_check_link+0x12c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 909ed20:	e17ffa47 	ldb	r5,-23(fp)
 909ed24:	e1bffa87 	ldb	r6,-22(fp)
 909ed28:	01024374 	movhi	r4,2317
 909ed2c:	213b8c04 	addi	r4,r4,-4560
 909ed30:	90833900 	call	9083390 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909ed34:	e17ffa03 	ldbu	r5,-24(fp)
 909ed38:	e13ffd17 	ldw	r4,-12(fp)
 909ed3c:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 909ed40:	e03fff15 	stw	zero,-4(fp)
 909ed44:	e0bfff17 	ldw	r2,-4(fp)
}
 909ed48:	e037883a 	mov	sp,fp
 909ed4c:	dfc00117 	ldw	ra,4(sp)
 909ed50:	df000017 	ldw	fp,0(sp)
 909ed54:	dec00204 	addi	sp,sp,8
 909ed58:	f800283a 	ret

0909ed5c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 909ed5c:	defff804 	addi	sp,sp,-32
 909ed60:	dfc00715 	stw	ra,28(sp)
 909ed64:	df000615 	stw	fp,24(sp)
 909ed68:	df000604 	addi	fp,sp,24
 909ed6c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 909ed70:	e03ffd15 	stw	zero,-12(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909ed74:	e0bffe17 	ldw	r2,-8(fp)
 909ed78:	10800617 	ldw	r2,24(r2)
 909ed7c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909ed80:	e0bffc17 	ldw	r2,-16(fp)
 909ed84:	10800317 	ldw	r2,12(r2)
 909ed88:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909ed8c:	e13ffc17 	ldw	r4,-16(fp)
 909ed90:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909ed94:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 909ed98:	e13ffb17 	ldw	r4,-20(fp)
 909ed9c:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909eda0:	e0bffa45 	stb	r2,-23(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909eda4:	e13ffe17 	ldw	r4,-8(fp)
 909eda8:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909edac:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909edb0:	e0bffe17 	ldw	r2,-8(fp)
 909edb4:	10800003 	ldbu	r2,0(r2)
 909edb8:	11403fcc 	andi	r5,r2,255
 909edbc:	e13ffe17 	ldw	r4,-8(fp)
 909edc0:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909edc4:	e13ffe17 	ldw	r4,-8(fp)
 909edc8:	01400044 	movi	r5,1
 909edcc:	018000c4 	movi	r6,3
 909edd0:	01c00044 	movi	r7,1
 909edd4:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909edd8:	1004c03a 	cmpne	r2,r2,zero
 909eddc:	10000b1e 	bne	r2,zero,909ee0c <alt_tse_phy_get_cap+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 909ede0:	e17ffa47 	ldb	r5,-23(fp)
 909ede4:	e1bffa87 	ldb	r6,-22(fp)
 909ede8:	01024374 	movhi	r4,2317
 909edec:	213b2604 	addi	r4,r4,-4968
 909edf0:	90833900 	call	9083390 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909edf4:	e17ffa03 	ldbu	r5,-24(fp)
 909edf8:	e13ffe17 	ldw	r4,-8(fp)
 909edfc:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 909ee00:	00bfff84 	movi	r2,-2
 909ee04:	e0bfff15 	stw	r2,-4(fp)
 909ee08:	00011e06 	br	909f284 <alt_tse_phy_get_cap+0x528>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909ee0c:	e13ffe17 	ldw	r4,-8(fp)
 909ee10:	01400134 	movhi	r5,4
 909ee14:	29742404 	addi	r5,r5,-12144
 909ee18:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 909ee1c:	e13ffe17 	ldw	r4,-8(fp)
 909ee20:	01400044 	movi	r5,1
 909ee24:	01800144 	movi	r6,5
 909ee28:	01c00044 	movi	r7,1
 909ee2c:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ee30:	1004c03a 	cmpne	r2,r2,zero
 909ee34:	1000021e 	bne	r2,zero,909ee40 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 909ee38:	00bfffc4 	movi	r2,-1
 909ee3c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 909ee40:	e13ffe17 	ldw	r4,-8(fp)
 909ee44:	014003c4 	movi	r5,15
 909ee48:	018003c4 	movi	r6,15
 909ee4c:	01c00044 	movi	r7,1
 909ee50:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ee54:	1007883a 	mov	r3,r2
 909ee58:	e0bffe17 	ldw	r2,-8(fp)
 909ee5c:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 909ee60:	e13ffe17 	ldw	r4,-8(fp)
 909ee64:	014003c4 	movi	r5,15
 909ee68:	01800384 	movi	r6,14
 909ee6c:	01c00044 	movi	r7,1
 909ee70:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ee74:	1007883a 	mov	r3,r2
 909ee78:	e0bffe17 	ldw	r2,-8(fp)
 909ee7c:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 909ee80:	e13ffe17 	ldw	r4,-8(fp)
 909ee84:	014003c4 	movi	r5,15
 909ee88:	01800344 	movi	r6,13
 909ee8c:	01c00044 	movi	r7,1
 909ee90:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ee94:	1007883a 	mov	r3,r2
 909ee98:	e0bffe17 	ldw	r2,-8(fp)
 909ee9c:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 909eea0:	e13ffe17 	ldw	r4,-8(fp)
 909eea4:	014003c4 	movi	r5,15
 909eea8:	01800304 	movi	r6,12
 909eeac:	01c00044 	movi	r7,1
 909eeb0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eeb4:	1007883a 	mov	r3,r2
 909eeb8:	e0bffe17 	ldw	r2,-8(fp)
 909eebc:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 909eec0:	e13ffe17 	ldw	r4,-8(fp)
 909eec4:	01400044 	movi	r5,1
 909eec8:	018003c4 	movi	r6,15
 909eecc:	01c00044 	movi	r7,1
 909eed0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eed4:	1007883a 	mov	r3,r2
 909eed8:	e0bffe17 	ldw	r2,-8(fp)
 909eedc:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 909eee0:	e13ffe17 	ldw	r4,-8(fp)
 909eee4:	01400044 	movi	r5,1
 909eee8:	01800384 	movi	r6,14
 909eeec:	01c00044 	movi	r7,1
 909eef0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eef4:	1007883a 	mov	r3,r2
 909eef8:	e0bffe17 	ldw	r2,-8(fp)
 909eefc:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 909ef00:	e13ffe17 	ldw	r4,-8(fp)
 909ef04:	01400044 	movi	r5,1
 909ef08:	01800344 	movi	r6,13
 909ef0c:	01c00044 	movi	r7,1
 909ef10:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ef14:	1007883a 	mov	r3,r2
 909ef18:	e0bffe17 	ldw	r2,-8(fp)
 909ef1c:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 909ef20:	e13ffe17 	ldw	r4,-8(fp)
 909ef24:	01400044 	movi	r5,1
 909ef28:	01800284 	movi	r6,10
 909ef2c:	01c00044 	movi	r7,1
 909ef30:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ef34:	1007883a 	mov	r3,r2
 909ef38:	e0bffe17 	ldw	r2,-8(fp)
 909ef3c:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 909ef40:	e13ffe17 	ldw	r4,-8(fp)
 909ef44:	01400044 	movi	r5,1
 909ef48:	01800244 	movi	r6,9
 909ef4c:	01c00044 	movi	r7,1
 909ef50:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ef54:	1007883a 	mov	r3,r2
 909ef58:	e0bffe17 	ldw	r2,-8(fp)
 909ef5c:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 909ef60:	e13ffe17 	ldw	r4,-8(fp)
 909ef64:	01400044 	movi	r5,1
 909ef68:	01800304 	movi	r6,12
 909ef6c:	01c00044 	movi	r7,1
 909ef70:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ef74:	1007883a 	mov	r3,r2
 909ef78:	e0bffe17 	ldw	r2,-8(fp)
 909ef7c:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 909ef80:	e13ffe17 	ldw	r4,-8(fp)
 909ef84:	01400044 	movi	r5,1
 909ef88:	018002c4 	movi	r6,11
 909ef8c:	01c00044 	movi	r7,1
 909ef90:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909ef94:	1007883a 	mov	r3,r2
 909ef98:	e0bffe17 	ldw	r2,-8(fp)
 909ef9c:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 909efa0:	e13ffe17 	ldw	r4,-8(fp)
 909efa4:	01400284 	movi	r5,10
 909efa8:	018002c4 	movi	r6,11
 909efac:	01c00044 	movi	r7,1
 909efb0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909efb4:	1007883a 	mov	r3,r2
 909efb8:	e0bffe17 	ldw	r2,-8(fp)
 909efbc:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 909efc0:	e13ffe17 	ldw	r4,-8(fp)
 909efc4:	01400284 	movi	r5,10
 909efc8:	01800284 	movi	r6,10
 909efcc:	01c00044 	movi	r7,1
 909efd0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909efd4:	1007883a 	mov	r3,r2
 909efd8:	e0bffe17 	ldw	r2,-8(fp)
 909efdc:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 909efe0:	e13ffe17 	ldw	r4,-8(fp)
 909efe4:	01400144 	movi	r5,5
 909efe8:	01800244 	movi	r6,9
 909efec:	01c00044 	movi	r7,1
 909eff0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909eff4:	1007883a 	mov	r3,r2
 909eff8:	e0bffe17 	ldw	r2,-8(fp)
 909effc:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 909f000:	e13ffe17 	ldw	r4,-8(fp)
 909f004:	01400144 	movi	r5,5
 909f008:	01800204 	movi	r6,8
 909f00c:	01c00044 	movi	r7,1
 909f010:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f014:	1007883a 	mov	r3,r2
 909f018:	e0bffe17 	ldw	r2,-8(fp)
 909f01c:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 909f020:	e13ffe17 	ldw	r4,-8(fp)
 909f024:	01400144 	movi	r5,5
 909f028:	018001c4 	movi	r6,7
 909f02c:	01c00044 	movi	r7,1
 909f030:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f034:	1007883a 	mov	r3,r2
 909f038:	e0bffe17 	ldw	r2,-8(fp)
 909f03c:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 909f040:	e13ffe17 	ldw	r4,-8(fp)
 909f044:	01400144 	movi	r5,5
 909f048:	01800184 	movi	r6,6
 909f04c:	01c00044 	movi	r7,1
 909f050:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f054:	1007883a 	mov	r3,r2
 909f058:	e0bffe17 	ldw	r2,-8(fp)
 909f05c:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 909f060:	e13ffe17 	ldw	r4,-8(fp)
 909f064:	01400144 	movi	r5,5
 909f068:	01800144 	movi	r6,5
 909f06c:	01c00044 	movi	r7,1
 909f070:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f074:	1007883a 	mov	r3,r2
 909f078:	e0bffe17 	ldw	r2,-8(fp)
 909f07c:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 909f080:	e17ffa47 	ldb	r5,-23(fp)
 909f084:	e1bffa87 	ldb	r6,-22(fp)
 909f088:	01024374 	movhi	r4,2317
 909f08c:	213b9704 	addi	r4,r4,-4516
 909f090:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 909f094:	e0bffe17 	ldw	r2,-8(fp)
 909f098:	10800043 	ldbu	r2,1(r2)
 909f09c:	11403fcc 	andi	r5,r2,255
 909f0a0:	01024374 	movhi	r4,2317
 909f0a4:	213ba204 	addi	r4,r4,-4472
 909f0a8:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 909f0ac:	e0bffe17 	ldw	r2,-8(fp)
 909f0b0:	10800083 	ldbu	r2,2(r2)
 909f0b4:	11403fcc 	andi	r5,r2,255
 909f0b8:	01024374 	movhi	r4,2317
 909f0bc:	213bac04 	addi	r4,r4,-4432
 909f0c0:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 909f0c4:	e0bffe17 	ldw	r2,-8(fp)
 909f0c8:	108000c3 	ldbu	r2,3(r2)
 909f0cc:	11403fcc 	andi	r5,r2,255
 909f0d0:	01024374 	movhi	r4,2317
 909f0d4:	213bb604 	addi	r4,r4,-4392
 909f0d8:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 909f0dc:	e0bffe17 	ldw	r2,-8(fp)
 909f0e0:	10800103 	ldbu	r2,4(r2)
 909f0e4:	11403fcc 	andi	r5,r2,255
 909f0e8:	01024374 	movhi	r4,2317
 909f0ec:	213bc004 	addi	r4,r4,-4352
 909f0f0:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 909f0f4:	e0bffe17 	ldw	r2,-8(fp)
 909f0f8:	10800143 	ldbu	r2,5(r2)
 909f0fc:	11403fcc 	andi	r5,r2,255
 909f100:	01024374 	movhi	r4,2317
 909f104:	213bca04 	addi	r4,r4,-4312
 909f108:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 909f10c:	e0bffe17 	ldw	r2,-8(fp)
 909f110:	10800183 	ldbu	r2,6(r2)
 909f114:	11403fcc 	andi	r5,r2,255
 909f118:	01024374 	movhi	r4,2317
 909f11c:	213bd404 	addi	r4,r4,-4272
 909f120:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 909f124:	e0bffe17 	ldw	r2,-8(fp)
 909f128:	108001c3 	ldbu	r2,7(r2)
 909f12c:	11403fcc 	andi	r5,r2,255
 909f130:	01024374 	movhi	r4,2317
 909f134:	213bde04 	addi	r4,r4,-4232
 909f138:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 909f13c:	e0bffe17 	ldw	r2,-8(fp)
 909f140:	10800203 	ldbu	r2,8(r2)
 909f144:	11403fcc 	andi	r5,r2,255
 909f148:	01024374 	movhi	r4,2317
 909f14c:	213be804 	addi	r4,r4,-4192
 909f150:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 909f154:	e0bffe17 	ldw	r2,-8(fp)
 909f158:	10800243 	ldbu	r2,9(r2)
 909f15c:	11403fcc 	andi	r5,r2,255
 909f160:	01024374 	movhi	r4,2317
 909f164:	213bf204 	addi	r4,r4,-4152
 909f168:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 909f16c:	e0bffe17 	ldw	r2,-8(fp)
 909f170:	10800283 	ldbu	r2,10(r2)
 909f174:	11403fcc 	andi	r5,r2,255
 909f178:	01024374 	movhi	r4,2317
 909f17c:	213bfc04 	addi	r4,r4,-4112
 909f180:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 909f184:	e0bffe17 	ldw	r2,-8(fp)
 909f188:	108002c3 	ldbu	r2,11(r2)
 909f18c:	11403fcc 	andi	r5,r2,255
 909f190:	01024374 	movhi	r4,2317
 909f194:	213c0604 	addi	r4,r4,-4072
 909f198:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "\n");
 909f19c:	01024374 	movhi	r4,2317
 909f1a0:	213a6c04 	addi	r4,r4,-5712
 909f1a4:	909b0a80 	call	909b0a8 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 909f1a8:	e17ffa47 	ldb	r5,-23(fp)
 909f1ac:	e1bffa87 	ldb	r6,-22(fp)
 909f1b0:	01024374 	movhi	r4,2317
 909f1b4:	213c1004 	addi	r4,r4,-4032
 909f1b8:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 909f1bc:	e0bffe17 	ldw	r2,-8(fp)
 909f1c0:	10800303 	ldbu	r2,12(r2)
 909f1c4:	11403fcc 	andi	r5,r2,255
 909f1c8:	01024374 	movhi	r4,2317
 909f1cc:	213bb604 	addi	r4,r4,-4392
 909f1d0:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 909f1d4:	e0bffe17 	ldw	r2,-8(fp)
 909f1d8:	10800343 	ldbu	r2,13(r2)
 909f1dc:	11403fcc 	andi	r5,r2,255
 909f1e0:	01024374 	movhi	r4,2317
 909f1e4:	213bc004 	addi	r4,r4,-4352
 909f1e8:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 909f1ec:	e0bffe17 	ldw	r2,-8(fp)
 909f1f0:	10800383 	ldbu	r2,14(r2)
 909f1f4:	11403fcc 	andi	r5,r2,255
 909f1f8:	01024374 	movhi	r4,2317
 909f1fc:	213bca04 	addi	r4,r4,-4312
 909f200:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 909f204:	e0bffe17 	ldw	r2,-8(fp)
 909f208:	108003c3 	ldbu	r2,15(r2)
 909f20c:	11403fcc 	andi	r5,r2,255
 909f210:	01024374 	movhi	r4,2317
 909f214:	213c1d04 	addi	r4,r4,-3980
 909f218:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 909f21c:	e0bffe17 	ldw	r2,-8(fp)
 909f220:	10800403 	ldbu	r2,16(r2)
 909f224:	11403fcc 	andi	r5,r2,255
 909f228:	01024374 	movhi	r4,2317
 909f22c:	213c2704 	addi	r4,r4,-3940
 909f230:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 909f234:	e0bffe17 	ldw	r2,-8(fp)
 909f238:	10800443 	ldbu	r2,17(r2)
 909f23c:	11403fcc 	andi	r5,r2,255
 909f240:	01024374 	movhi	r4,2317
 909f244:	213c3104 	addi	r4,r4,-3900
 909f248:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 909f24c:	e0bffe17 	ldw	r2,-8(fp)
 909f250:	10800483 	ldbu	r2,18(r2)
 909f254:	11403fcc 	andi	r5,r2,255
 909f258:	01024374 	movhi	r4,2317
 909f25c:	213c3b04 	addi	r4,r4,-3860
 909f260:	909b0a80 	call	909b0a8 <no_printf>
    tse_dprintf(6, "\n");
 909f264:	01024374 	movhi	r4,2317
 909f268:	213a6c04 	addi	r4,r4,-5712
 909f26c:	909b0a80 	call	909b0a8 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909f270:	e17ffa03 	ldbu	r5,-24(fp)
 909f274:	e13ffe17 	ldw	r4,-8(fp)
 909f278:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 909f27c:	e0bffd17 	ldw	r2,-12(fp)
 909f280:	e0bfff15 	stw	r2,-4(fp)
 909f284:	e0bfff17 	ldw	r2,-4(fp)
    
}
 909f288:	e037883a 	mov	sp,fp
 909f28c:	dfc00117 	ldw	ra,4(sp)
 909f290:	df000017 	ldw	fp,0(sp)
 909f294:	dec00204 	addi	sp,sp,8
 909f298:	f800283a 	ret

0909f29c <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 909f29c:	defff704 	addi	sp,sp,-36
 909f2a0:	dfc00815 	stw	ra,32(sp)
 909f2a4:	df000715 	stw	fp,28(sp)
 909f2a8:	df000704 	addi	fp,sp,28
 909f2ac:	e13ffe15 	stw	r4,-8(fp)
 909f2b0:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909f2b4:	e0bffe17 	ldw	r2,-8(fp)
 909f2b8:	10800617 	ldw	r2,24(r2)
 909f2bc:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909f2c0:	e0bffc17 	ldw	r2,-16(fp)
 909f2c4:	10800317 	ldw	r2,12(r2)
 909f2c8:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909f2cc:	e13ffc17 	ldw	r4,-16(fp)
 909f2d0:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909f2d4:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909f2d8:	e13ffb17 	ldw	r4,-20(fp)
 909f2dc:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909f2e0:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909f2e4:	e13ffe17 	ldw	r4,-8(fp)
 909f2e8:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909f2ec:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909f2f0:	e0bffe17 	ldw	r2,-8(fp)
 909f2f4:	10800003 	ldbu	r2,0(r2)
 909f2f8:	11403fcc 	andi	r5,r2,255
 909f2fc:	e13ffe17 	ldw	r4,-8(fp)
 909f300:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909f304:	e0bfff03 	ldbu	r2,-4(fp)
 909f308:	1005003a 	cmpeq	r2,r2,zero
 909f30c:	1000271e 	bne	r2,zero,909f3ac <alt_tse_phy_set_adv_1000+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 909f310:	e13ffe17 	ldw	r4,-8(fp)
 909f314:	014003c4 	movi	r5,15
 909f318:	01800344 	movi	r6,13
 909f31c:	01c00044 	movi	r7,1
 909f320:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f324:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 909f328:	e0bffd03 	ldbu	r2,-12(fp)
 909f32c:	d8800015 	stw	r2,0(sp)
 909f330:	e13ffe17 	ldw	r4,-8(fp)
 909f334:	01400244 	movi	r5,9
 909f338:	01800244 	movi	r6,9
 909f33c:	01c00044 	movi	r7,1
 909f340:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f344:	e17ffa47 	ldb	r5,-23(fp)
 909f348:	e1bffa87 	ldb	r6,-22(fp)
 909f34c:	e1fffd03 	ldbu	r7,-12(fp)
 909f350:	01024374 	movhi	r4,2317
 909f354:	213c4504 	addi	r4,r4,-3820
 909f358:	909b0a80 	call	909b0a8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 909f35c:	e13ffe17 	ldw	r4,-8(fp)
 909f360:	014003c4 	movi	r5,15
 909f364:	01800304 	movi	r6,12
 909f368:	01c00044 	movi	r7,1
 909f36c:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f370:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 909f374:	e0bffd03 	ldbu	r2,-12(fp)
 909f378:	d8800015 	stw	r2,0(sp)
 909f37c:	e13ffe17 	ldw	r4,-8(fp)
 909f380:	01400244 	movi	r5,9
 909f384:	01800204 	movi	r6,8
 909f388:	01c00044 	movi	r7,1
 909f38c:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f390:	e17ffa47 	ldb	r5,-23(fp)
 909f394:	e1bffa87 	ldb	r6,-22(fp)
 909f398:	e1fffd03 	ldbu	r7,-12(fp)
 909f39c:	01024374 	movhi	r4,2317
 909f3a0:	213c5804 	addi	r4,r4,-3744
 909f3a4:	909b0a80 	call	909b0a8 <no_printf>
 909f3a8:	00001806 	br	909f40c <alt_tse_phy_set_adv_1000+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 909f3ac:	d8000015 	stw	zero,0(sp)
 909f3b0:	e13ffe17 	ldw	r4,-8(fp)
 909f3b4:	01400244 	movi	r5,9
 909f3b8:	01800244 	movi	r6,9
 909f3bc:	01c00044 	movi	r7,1
 909f3c0:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f3c4:	e17ffa47 	ldb	r5,-23(fp)
 909f3c8:	e1bffa87 	ldb	r6,-22(fp)
 909f3cc:	01024374 	movhi	r4,2317
 909f3d0:	213c4504 	addi	r4,r4,-3820
 909f3d4:	000f883a 	mov	r7,zero
 909f3d8:	909b0a80 	call	909b0a8 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 909f3dc:	d8000015 	stw	zero,0(sp)
 909f3e0:	e13ffe17 	ldw	r4,-8(fp)
 909f3e4:	01400244 	movi	r5,9
 909f3e8:	01800204 	movi	r6,8
 909f3ec:	01c00044 	movi	r7,1
 909f3f0:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f3f4:	e17ffa47 	ldb	r5,-23(fp)
 909f3f8:	e1bffa87 	ldb	r6,-22(fp)
 909f3fc:	01024374 	movhi	r4,2317
 909f400:	213c6b04 	addi	r4,r4,-3668
 909f404:	000f883a 	mov	r7,zero
 909f408:	909b0a80 	call	909b0a8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 909f40c:	e17ffa03 	ldbu	r5,-24(fp)
 909f410:	e13ffe17 	ldw	r4,-8(fp)
 909f414:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 909f418:	0005883a 	mov	r2,zero
}
 909f41c:	e037883a 	mov	sp,fp
 909f420:	dfc00117 	ldw	ra,4(sp)
 909f424:	df000017 	ldw	fp,0(sp)
 909f428:	dec00204 	addi	sp,sp,8
 909f42c:	f800283a 	ret

0909f430 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 909f430:	defff704 	addi	sp,sp,-36
 909f434:	dfc00815 	stw	ra,32(sp)
 909f438:	df000715 	stw	fp,28(sp)
 909f43c:	df000704 	addi	fp,sp,28
 909f440:	e13ffe15 	stw	r4,-8(fp)
 909f444:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909f448:	e0bffe17 	ldw	r2,-8(fp)
 909f44c:	10800617 	ldw	r2,24(r2)
 909f450:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909f454:	e0bffc17 	ldw	r2,-16(fp)
 909f458:	10800317 	ldw	r2,12(r2)
 909f45c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909f460:	e13ffc17 	ldw	r4,-16(fp)
 909f464:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909f468:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909f46c:	e13ffb17 	ldw	r4,-20(fp)
 909f470:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909f474:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909f478:	e13ffe17 	ldw	r4,-8(fp)
 909f47c:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909f480:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909f484:	e0bffe17 	ldw	r2,-8(fp)
 909f488:	10800003 	ldbu	r2,0(r2)
 909f48c:	11403fcc 	andi	r5,r2,255
 909f490:	e13ffe17 	ldw	r4,-8(fp)
 909f494:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909f498:	e0bfff03 	ldbu	r2,-4(fp)
 909f49c:	1005003a 	cmpeq	r2,r2,zero
 909f4a0:	10003a1e 	bne	r2,zero,909f58c <alt_tse_phy_set_adv_100+0x15c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 909f4a4:	e13ffe17 	ldw	r4,-8(fp)
 909f4a8:	01400044 	movi	r5,1
 909f4ac:	018003c4 	movi	r6,15
 909f4b0:	01c00044 	movi	r7,1
 909f4b4:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f4b8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 909f4bc:	e0bffd03 	ldbu	r2,-12(fp)
 909f4c0:	d8800015 	stw	r2,0(sp)
 909f4c4:	e13ffe17 	ldw	r4,-8(fp)
 909f4c8:	01400104 	movi	r5,4
 909f4cc:	01800244 	movi	r6,9
 909f4d0:	01c00044 	movi	r7,1
 909f4d4:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 909f4d8:	e17ffa47 	ldb	r5,-23(fp)
 909f4dc:	e1bffa87 	ldb	r6,-22(fp)
 909f4e0:	e1fffd03 	ldbu	r7,-12(fp)
 909f4e4:	01024374 	movhi	r4,2317
 909f4e8:	213c7d04 	addi	r4,r4,-3596
 909f4ec:	909b0a80 	call	909b0a8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 909f4f0:	e13ffe17 	ldw	r4,-8(fp)
 909f4f4:	01400044 	movi	r5,1
 909f4f8:	01800384 	movi	r6,14
 909f4fc:	01c00044 	movi	r7,1
 909f500:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f504:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 909f508:	e0bffd03 	ldbu	r2,-12(fp)
 909f50c:	d8800015 	stw	r2,0(sp)
 909f510:	e13ffe17 	ldw	r4,-8(fp)
 909f514:	01400104 	movi	r5,4
 909f518:	01800204 	movi	r6,8
 909f51c:	01c00044 	movi	r7,1
 909f520:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f524:	e17ffa47 	ldb	r5,-23(fp)
 909f528:	e1bffa87 	ldb	r6,-22(fp)
 909f52c:	e1fffd03 	ldbu	r7,-12(fp)
 909f530:	01024374 	movhi	r4,2317
 909f534:	213c8d04 	addi	r4,r4,-3532
 909f538:	909b0a80 	call	909b0a8 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 909f53c:	e13ffe17 	ldw	r4,-8(fp)
 909f540:	01400044 	movi	r5,1
 909f544:	01800344 	movi	r6,13
 909f548:	01c00044 	movi	r7,1
 909f54c:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f550:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 909f554:	e0bffd03 	ldbu	r2,-12(fp)
 909f558:	d8800015 	stw	r2,0(sp)
 909f55c:	e13ffe17 	ldw	r4,-8(fp)
 909f560:	01400104 	movi	r5,4
 909f564:	018001c4 	movi	r6,7
 909f568:	01c00044 	movi	r7,1
 909f56c:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f570:	e17ffa47 	ldb	r5,-23(fp)
 909f574:	e1bffa87 	ldb	r6,-22(fp)
 909f578:	e1fffd03 	ldbu	r7,-12(fp)
 909f57c:	01024374 	movhi	r4,2317
 909f580:	213ca004 	addi	r4,r4,-3456
 909f584:	909b0a80 	call	909b0a8 <no_printf>
 909f588:	00002406 	br	909f61c <alt_tse_phy_set_adv_100+0x1ec>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 909f58c:	d8000015 	stw	zero,0(sp)
 909f590:	e13ffe17 	ldw	r4,-8(fp)
 909f594:	01400104 	movi	r5,4
 909f598:	01800244 	movi	r6,9
 909f59c:	01c00044 	movi	r7,1
 909f5a0:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 909f5a4:	e17ffa47 	ldb	r5,-23(fp)
 909f5a8:	e1bffa87 	ldb	r6,-22(fp)
 909f5ac:	01024374 	movhi	r4,2317
 909f5b0:	213c7d04 	addi	r4,r4,-3596
 909f5b4:	000f883a 	mov	r7,zero
 909f5b8:	909b0a80 	call	909b0a8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 909f5bc:	d8000015 	stw	zero,0(sp)
 909f5c0:	e13ffe17 	ldw	r4,-8(fp)
 909f5c4:	01400104 	movi	r5,4
 909f5c8:	01800204 	movi	r6,8
 909f5cc:	01c00044 	movi	r7,1
 909f5d0:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f5d4:	e17ffa47 	ldb	r5,-23(fp)
 909f5d8:	e1bffa87 	ldb	r6,-22(fp)
 909f5dc:	01024374 	movhi	r4,2317
 909f5e0:	213c8d04 	addi	r4,r4,-3532
 909f5e4:	000f883a 	mov	r7,zero
 909f5e8:	909b0a80 	call	909b0a8 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 909f5ec:	d8000015 	stw	zero,0(sp)
 909f5f0:	e13ffe17 	ldw	r4,-8(fp)
 909f5f4:	01400104 	movi	r5,4
 909f5f8:	018001c4 	movi	r6,7
 909f5fc:	01c00044 	movi	r7,1
 909f600:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f604:	e17ffa47 	ldb	r5,-23(fp)
 909f608:	e1bffa87 	ldb	r6,-22(fp)
 909f60c:	01024374 	movhi	r4,2317
 909f610:	213ca004 	addi	r4,r4,-3456
 909f614:	000f883a 	mov	r7,zero
 909f618:	909b0a80 	call	909b0a8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 909f61c:	e17ffa03 	ldbu	r5,-24(fp)
 909f620:	e13ffe17 	ldw	r4,-8(fp)
 909f624:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 909f628:	0005883a 	mov	r2,zero
}
 909f62c:	e037883a 	mov	sp,fp
 909f630:	dfc00117 	ldw	ra,4(sp)
 909f634:	df000017 	ldw	fp,0(sp)
 909f638:	dec00204 	addi	sp,sp,8
 909f63c:	f800283a 	ret

0909f640 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 909f640:	defff504 	addi	sp,sp,-44
 909f644:	dfc00a15 	stw	ra,40(sp)
 909f648:	df000915 	stw	fp,36(sp)
 909f64c:	df000904 	addi	fp,sp,36
 909f650:	e13ffe15 	stw	r4,-8(fp)
 909f654:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 909f658:	e0bffe17 	ldw	r2,-8(fp)
 909f65c:	10800617 	ldw	r2,24(r2)
 909f660:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 909f664:	e0bffc17 	ldw	r2,-16(fp)
 909f668:	10800317 	ldw	r2,12(r2)
 909f66c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909f670:	e13ffc17 	ldw	r4,-16(fp)
 909f674:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909f678:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909f67c:	e13ffb17 	ldw	r4,-20(fp)
 909f680:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909f684:	e0bff915 	stw	r2,-28(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 909f688:	e13ffe17 	ldw	r4,-8(fp)
 909f68c:	909d3e80 	call	909d3e8 <alt_tse_phy_rd_mdio_addr>
 909f690:	e0bff815 	stw	r2,-32(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909f694:	e0bffe17 	ldw	r2,-8(fp)
 909f698:	10800003 	ldbu	r2,0(r2)
 909f69c:	11403fcc 	andi	r5,r2,255
 909f6a0:	e13ffe17 	ldw	r4,-8(fp)
 909f6a4:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 909f6a8:	e0bfff03 	ldbu	r2,-4(fp)
 909f6ac:	1005003a 	cmpeq	r2,r2,zero
 909f6b0:	1000271e 	bne	r2,zero,909f750 <alt_tse_phy_set_adv_10+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 909f6b4:	e13ffe17 	ldw	r4,-8(fp)
 909f6b8:	01400044 	movi	r5,1
 909f6bc:	01800304 	movi	r6,12
 909f6c0:	01c00044 	movi	r7,1
 909f6c4:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f6c8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 909f6cc:	e0bffd03 	ldbu	r2,-12(fp)
 909f6d0:	d8800015 	stw	r2,0(sp)
 909f6d4:	e13ffe17 	ldw	r4,-8(fp)
 909f6d8:	01400104 	movi	r5,4
 909f6dc:	01800184 	movi	r6,6
 909f6e0:	01c00044 	movi	r7,1
 909f6e4:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f6e8:	e1fffd03 	ldbu	r7,-12(fp)
 909f6ec:	01024374 	movhi	r4,2317
 909f6f0:	213cb304 	addi	r4,r4,-3380
 909f6f4:	e17ff917 	ldw	r5,-28(fp)
 909f6f8:	e1bffa17 	ldw	r6,-24(fp)
 909f6fc:	909b0a80 	call	909b0a8 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 909f700:	e13ffe17 	ldw	r4,-8(fp)
 909f704:	01400044 	movi	r5,1
 909f708:	018002c4 	movi	r6,11
 909f70c:	01c00044 	movi	r7,1
 909f710:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909f714:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 909f718:	e0bffd03 	ldbu	r2,-12(fp)
 909f71c:	d8800015 	stw	r2,0(sp)
 909f720:	e13ffe17 	ldw	r4,-8(fp)
 909f724:	01400104 	movi	r5,4
 909f728:	01800144 	movi	r6,5
 909f72c:	01c00044 	movi	r7,1
 909f730:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 909f734:	e1fffd03 	ldbu	r7,-12(fp)
 909f738:	01024374 	movhi	r4,2317
 909f73c:	213cc604 	addi	r4,r4,-3304
 909f740:	e17ff917 	ldw	r5,-28(fp)
 909f744:	e1bffa17 	ldw	r6,-24(fp)
 909f748:	909b0a80 	call	909b0a8 <no_printf>
 909f74c:	00001806 	br	909f7b0 <alt_tse_phy_set_adv_10+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 909f750:	d8000015 	stw	zero,0(sp)
 909f754:	e13ffe17 	ldw	r4,-8(fp)
 909f758:	01400104 	movi	r5,4
 909f75c:	01800184 	movi	r6,6
 909f760:	01c00044 	movi	r7,1
 909f764:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f768:	01024374 	movhi	r4,2317
 909f76c:	213cb304 	addi	r4,r4,-3380
 909f770:	e17ff917 	ldw	r5,-28(fp)
 909f774:	e1bffa17 	ldw	r6,-24(fp)
 909f778:	000f883a 	mov	r7,zero
 909f77c:	909b0a80 	call	909b0a8 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 909f780:	d8000015 	stw	zero,0(sp)
 909f784:	e13ffe17 	ldw	r4,-8(fp)
 909f788:	01400104 	movi	r5,4
 909f78c:	01800144 	movi	r6,5
 909f790:	01c00044 	movi	r7,1
 909f794:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 909f798:	01024374 	movhi	r4,2317
 909f79c:	213cc604 	addi	r4,r4,-3304
 909f7a0:	e17ff917 	ldw	r5,-28(fp)
 909f7a4:	e1bffa17 	ldw	r6,-24(fp)
 909f7a8:	000f883a 	mov	r7,zero
 909f7ac:	909b0a80 	call	909b0a8 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 909f7b0:	e0bff817 	ldw	r2,-32(fp)
 909f7b4:	11403fcc 	andi	r5,r2,255
 909f7b8:	e13ffe17 	ldw	r4,-8(fp)
 909f7bc:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 909f7c0:	0005883a 	mov	r2,zero
}
 909f7c4:	e037883a 	mov	sp,fp
 909f7c8:	dfc00117 	ldw	ra,4(sp)
 909f7cc:	df000017 	ldw	fp,0(sp)
 909f7d0:	dec00204 	addi	sp,sp,8
 909f7d4:	f800283a 	ret

0909f7d8 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 909f7d8:	defff604 	addi	sp,sp,-40
 909f7dc:	dfc00915 	stw	ra,36(sp)
 909f7e0:	df000815 	stw	fp,32(sp)
 909f7e4:	df000804 	addi	fp,sp,32
 909f7e8:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 909f7ec:	00800044 	movi	r2,1
 909f7f0:	e0bffd85 	stb	r2,-10(fp)
	alt_u8 common_100 = 1;
 909f7f4:	00800044 	movi	r2,1
 909f7f8:	e0bffd45 	stb	r2,-11(fp)
	alt_u8 common_10 = 1;
 909f7fc:	00800044 	movi	r2,1
 909f800:	e0bffd05 	stb	r2,-12(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 909f804:	00800044 	movi	r2,1
 909f808:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 909f80c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_phy_info *pphy = 0;
 909f810:	e03ff915 	stw	zero,-28(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909f814:	e13fff17 	ldw	r4,-4(fp)
 909f818:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909f81c:	e0bff805 	stb	r2,-32(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 909f820:	e03ffe15 	stw	zero,-8(fp)
 909f824:	00001d06 	br	909f89c <alt_tse_phy_get_common_speed+0xc4>
        pmac_info = pmac_group->pmac_info[i];
 909f828:	e0bffe17 	ldw	r2,-8(fp)
 909f82c:	e0ffff17 	ldw	r3,-4(fp)
 909f830:	1085883a 	add	r2,r2,r2
 909f834:	1085883a 	add	r2,r2,r2
 909f838:	10c5883a 	add	r2,r2,r3
 909f83c:	10800104 	addi	r2,r2,4
 909f840:	10800017 	ldw	r2,0(r2)
 909f844:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 909f848:	e0bffa17 	ldw	r2,-24(fp)
 909f84c:	10800117 	ldw	r2,4(r2)
 909f850:	e0bff915 	stw	r2,-28(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 909f854:	e0bff917 	ldw	r2,-28(fp)
 909f858:	1005003a 	cmpeq	r2,r2,zero
 909f85c:	1000091e 	bne	r2,zero,909f884 <alt_tse_phy_get_common_speed+0xac>
            alt_tse_phy_set_adv_1000(pphy, 1);
 909f860:	e13ff917 	ldw	r4,-28(fp)
 909f864:	01400044 	movi	r5,1
 909f868:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909f86c:	e13ff917 	ldw	r4,-28(fp)
 909f870:	01400044 	movi	r5,1
 909f874:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909f878:	e13ff917 	ldw	r4,-28(fp)
 909f87c:	01400044 	movi	r5,1
 909f880:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 909f884:	01024374 	movhi	r4,2317
 909f888:	213a6c04 	addi	r4,r4,-5712
 909f88c:	909b0a80 	call	909b0a8 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 909f890:	e0bffe17 	ldw	r2,-8(fp)
 909f894:	10800044 	addi	r2,r2,1
 909f898:	e0bffe15 	stw	r2,-8(fp)
 909f89c:	e0bfff17 	ldw	r2,-4(fp)
 909f8a0:	10800003 	ldbu	r2,0(r2)
 909f8a4:	10c03fcc 	andi	r3,r2,255
 909f8a8:	e0bffe17 	ldw	r2,-8(fp)
 909f8ac:	10ffde16 	blt	r2,r3,909f828 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909f8b0:	e03ffe15 	stw	zero,-8(fp)
 909f8b4:	00005406 	br	909fa08 <alt_tse_phy_get_common_speed+0x230>

        pmac_info = pmac_group->pmac_info[i];
 909f8b8:	e0bffe17 	ldw	r2,-8(fp)
 909f8bc:	e0ffff17 	ldw	r3,-4(fp)
 909f8c0:	1085883a 	add	r2,r2,r2
 909f8c4:	1085883a 	add	r2,r2,r2
 909f8c8:	10c5883a 	add	r2,r2,r3
 909f8cc:	10800104 	addi	r2,r2,4
 909f8d0:	10800017 	ldw	r2,0(r2)
 909f8d4:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 909f8d8:	e0bffa17 	ldw	r2,-24(fp)
 909f8dc:	10800117 	ldw	r2,4(r2)
 909f8e0:	e0bff915 	stw	r2,-28(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 909f8e4:	e0bff917 	ldw	r2,-28(fp)
 909f8e8:	1005003a 	cmpeq	r2,r2,zero
 909f8ec:	1000431e 	bne	r2,zero,909f9fc <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 909f8f0:	e13ff917 	ldw	r4,-28(fp)
 909f8f4:	909ed5c0 	call	909ed5c <alt_tse_phy_get_cap>
 909f8f8:	1004c03a 	cmpne	r2,r2,zero
 909f8fc:	10003f1e 	bne	r2,zero,909f9fc <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 909f900:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 909f904:	e0bffa17 	ldw	r2,-24(fp)
 909f908:	10800003 	ldbu	r2,0(r2)
 909f90c:	10803fcc 	andi	r2,r2,255
 909f910:	10800058 	cmpnei	r2,r2,1
 909f914:	1000021e 	bne	r2,zero,909f920 <alt_tse_phy_get_common_speed+0x148>
            common_1000 = 0;
 909f918:	e03ffd85 	stb	zero,-10(fp)
 909f91c:	00000706 	br	909f93c <alt_tse_phy_get_common_speed+0x164>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 909f920:	e0bffa17 	ldw	r2,-24(fp)
 909f924:	10800003 	ldbu	r2,0(r2)
 909f928:	10803fcc 	andi	r2,r2,255
 909f92c:	10800098 	cmpnei	r2,r2,2
 909f930:	1000021e 	bne	r2,zero,909f93c <alt_tse_phy_get_common_speed+0x164>
            common_100 = 0;
 909f934:	e03ffd45 	stb	zero,-11(fp)
            common_10 = 0;            
 909f938:	e03ffd05 	stb	zero,-12(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 909f93c:	e0bff917 	ldw	r2,-28(fp)
 909f940:	10c000c3 	ldbu	r3,3(r2)
 909f944:	e0bff917 	ldw	r2,-28(fp)
 909f948:	10800303 	ldbu	r2,12(r2)
 909f94c:	1884703a 	and	r2,r3,r2
 909f950:	1007883a 	mov	r3,r2
 909f954:	e0bffd83 	ldbu	r2,-10(fp)
 909f958:	10c4703a 	and	r2,r2,r3
 909f95c:	e0bffd85 	stb	r2,-10(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 909f960:	e0bff917 	ldw	r2,-28(fp)
 909f964:	10c00183 	ldbu	r3,6(r2)
 909f968:	e0bff917 	ldw	r2,-28(fp)
 909f96c:	108003c3 	ldbu	r2,15(r2)
 909f970:	1884703a 	and	r2,r3,r2
 909f974:	1009883a 	mov	r4,r2
 909f978:	e0bff917 	ldw	r2,-28(fp)
 909f97c:	10c001c3 	ldbu	r3,7(r2)
 909f980:	e0bff917 	ldw	r2,-28(fp)
 909f984:	10800403 	ldbu	r2,16(r2)
 909f988:	1884703a 	and	r2,r3,r2
 909f98c:	2084b03a 	or	r2,r4,r2
 909f990:	1009883a 	mov	r4,r2
 909f994:	e0bff917 	ldw	r2,-28(fp)
 909f998:	10c00143 	ldbu	r3,5(r2)
 909f99c:	e0bff917 	ldw	r2,-28(fp)
 909f9a0:	10800383 	ldbu	r2,14(r2)
 909f9a4:	1884703a 	and	r2,r3,r2
 909f9a8:	2084b03a 	or	r2,r4,r2
 909f9ac:	1007883a 	mov	r3,r2
 909f9b0:	e0bffd43 	ldbu	r2,-11(fp)
 909f9b4:	10c4703a 	and	r2,r2,r3
 909f9b8:	e0bffd45 	stb	r2,-11(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 909f9bc:	e0bff917 	ldw	r2,-28(fp)
 909f9c0:	10c00283 	ldbu	r3,10(r2)
 909f9c4:	e0bff917 	ldw	r2,-28(fp)
 909f9c8:	10800443 	ldbu	r2,17(r2)
 909f9cc:	1884703a 	and	r2,r3,r2
 909f9d0:	1009883a 	mov	r4,r2
 909f9d4:	e0bff917 	ldw	r2,-28(fp)
 909f9d8:	10c002c3 	ldbu	r3,11(r2)
 909f9dc:	e0bff917 	ldw	r2,-28(fp)
 909f9e0:	10800483 	ldbu	r2,18(r2)
 909f9e4:	1884703a 	and	r2,r3,r2
 909f9e8:	2084b03a 	or	r2,r4,r2
 909f9ec:	1007883a 	mov	r3,r2
 909f9f0:	e0bffd03 	ldbu	r2,-12(fp)
 909f9f4:	10c4703a 	and	r2,r2,r3
 909f9f8:	e0bffd05 	stb	r2,-12(fp)
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909f9fc:	e0bffe17 	ldw	r2,-8(fp)
 909fa00:	10800044 	addi	r2,r2,1
 909fa04:	e0bffe15 	stw	r2,-8(fp)
 909fa08:	e0bfff17 	ldw	r2,-4(fp)
 909fa0c:	10800003 	ldbu	r2,0(r2)
 909fa10:	10c03fcc 	andi	r3,r2,255
 909fa14:	e0bffe17 	ldw	r2,-8(fp)
 909fa18:	10ffa716 	blt	r2,r3,909f8b8 <alt_tse_phy_get_common_speed+0xe0>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 909fa1c:	e0bffb03 	ldbu	r2,-20(fp)
 909fa20:	10800058 	cmpnei	r2,r2,1
 909fa24:	1000071e 	bne	r2,zero,909fa44 <alt_tse_phy_get_common_speed+0x26c>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 909fa28:	00bfffc4 	movi	r2,-1
 909fa2c:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 909fa30:	e17ff807 	ldb	r5,-32(fp)
 909fa34:	01024374 	movhi	r4,2317
 909fa38:	213cd904 	addi	r4,r4,-3228
 909fa3c:	90833900 	call	9083390 <printf>
 909fa40:	00002606 	br	909fadc <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_1000) {
 909fa44:	e0bffd83 	ldbu	r2,-10(fp)
 909fa48:	1005003a 	cmpeq	r2,r2,zero
 909fa4c:	1000081e 	bne	r2,zero,909fa70 <alt_tse_phy_get_common_speed+0x298>
        common_speed = TSE_PHY_SPEED_1000;
 909fa50:	00800084 	movi	r2,2
 909fa54:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 909fa58:	e17ff807 	ldb	r5,-32(fp)
 909fa5c:	01024374 	movhi	r4,2317
 909fa60:	213ceb04 	addi	r4,r4,-3156
 909fa64:	0180fa04 	movi	r6,1000
 909fa68:	90833900 	call	9083390 <printf>
 909fa6c:	00001b06 	br	909fadc <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_100) {
 909fa70:	e0bffd43 	ldbu	r2,-11(fp)
 909fa74:	1005003a 	cmpeq	r2,r2,zero
 909fa78:	1000081e 	bne	r2,zero,909fa9c <alt_tse_phy_get_common_speed+0x2c4>
        common_speed = TSE_PHY_SPEED_100;
 909fa7c:	00800044 	movi	r2,1
 909fa80:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 909fa84:	e17ff807 	ldb	r5,-32(fp)
 909fa88:	01024374 	movhi	r4,2317
 909fa8c:	213ceb04 	addi	r4,r4,-3156
 909fa90:	01801904 	movi	r6,100
 909fa94:	90833900 	call	9083390 <printf>
 909fa98:	00001006 	br	909fadc <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_10) {
 909fa9c:	e0bffd03 	ldbu	r2,-12(fp)
 909faa0:	1005003a 	cmpeq	r2,r2,zero
 909faa4:	1000071e 	bne	r2,zero,909fac4 <alt_tse_phy_get_common_speed+0x2ec>
        common_speed = TSE_PHY_SPEED_10;
 909faa8:	e03ffc15 	stw	zero,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 909faac:	e17ff807 	ldb	r5,-32(fp)
 909fab0:	01024374 	movhi	r4,2317
 909fab4:	213ceb04 	addi	r4,r4,-3156
 909fab8:	01800284 	movi	r6,10
 909fabc:	90833900 	call	9083390 <printf>
 909fac0:	00000606 	br	909fadc <alt_tse_phy_get_common_speed+0x304>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 909fac4:	00bfffc4 	movi	r2,-1
 909fac8:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 909facc:	e17ff807 	ldb	r5,-32(fp)
 909fad0:	01024374 	movhi	r4,2317
 909fad4:	213cf804 	addi	r4,r4,-3104
 909fad8:	90833900 	call	9083390 <printf>

    return common_speed;
 909fadc:	e0bffc17 	ldw	r2,-16(fp)
}
 909fae0:	e037883a 	mov	sp,fp
 909fae4:	dfc00117 	ldw	ra,4(sp)
 909fae8:	df000017 	ldw	fp,0(sp)
 909faec:	dec00204 	addi	sp,sp,8
 909faf0:	f800283a 	ret

0909faf4 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 909faf4:	deffec04 	addi	sp,sp,-80
 909faf8:	dfc01315 	stw	ra,76(sp)
 909fafc:	df001215 	stw	fp,72(sp)
 909fb00:	dc401115 	stw	r17,68(sp)
 909fb04:	dc001015 	stw	r16,64(sp)
 909fb08:	df001004 	addi	fp,sp,64
 909fb0c:	e13ff915 	stw	r4,-28(fp)
 909fb10:	e17ffa15 	stw	r5,-24(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 909fb14:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 909fb18:	e03ff515 	stw	zero,-44(fp)
    alt_tse_system_info *psys = 0;
 909fb1c:	e03ff415 	stw	zero,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 909fb20:	e03ff345 	stb	zero,-51(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 909fb24:	e13ff917 	ldw	r4,-28(fp)
 909fb28:	909c2700 	call	909c270 <alt_tse_get_mac_group_index>
 909fb2c:	e0bff305 	stb	r2,-52(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 909fb30:	e0bff917 	ldw	r2,-28(fp)
 909fb34:	10800117 	ldw	r2,4(r2)
 909fb38:	10800217 	ldw	r2,8(r2)
 909fb3c:	10800017 	ldw	r2,0(r2)
 909fb40:	e0bff215 	stw	r2,-56(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 909fb44:	e0bff217 	ldw	r2,-56(fp)
 909fb48:	10801004 	addi	r2,r2,64
 909fb4c:	10800037 	ldwio	r2,0(r2)
 909fb50:	e0bff115 	stw	r2,-60(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 909fb54:	e0bffa17 	ldw	r2,-24(fp)
 909fb58:	1004803a 	cmplt	r2,r2,zero
 909fb5c:	1000031e 	bne	r2,zero,909fb6c <alt_tse_phy_set_common_speed+0x78>
 909fb60:	e0bffa17 	ldw	r2,-24(fp)
 909fb64:	108000d0 	cmplti	r2,r2,3
 909fb68:	10000d1e 	bne	r2,zero,909fba0 <alt_tse_phy_set_common_speed+0xac>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 909fb6c:	e17ff307 	ldb	r5,-52(fp)
 909fb70:	01024374 	movhi	r4,2317
 909fb74:	213d0504 	addi	r4,r4,-3052
 909fb78:	e1bffa17 	ldw	r6,-24(fp)
 909fb7c:	90833900 	call	9083390 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909fb80:	e0bff217 	ldw	r2,-56(fp)
 909fb84:	10801004 	addi	r2,r2,64
 909fb88:	1007883a 	mov	r3,r2
 909fb8c:	e0bff117 	ldw	r2,-60(fp)
 909fb90:	18800035 	stwio	r2,0(r3)
        return TSE_PHY_SPEED_NO_COMMON;
 909fb94:	00bfffc4 	movi	r2,-1
 909fb98:	e0bfff15 	stw	r2,-4(fp)
 909fb9c:	00010606 	br	909ffb8 <alt_tse_phy_set_common_speed+0x4c4>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909fba0:	e03ff815 	stw	zero,-32(fp)
 909fba4:	0000dd06 	br	909ff1c <alt_tse_phy_set_common_speed+0x428>
        pmac_info = pmac_group->pmac_info[i];
 909fba8:	e0bff817 	ldw	r2,-32(fp)
 909fbac:	e0fff917 	ldw	r3,-28(fp)
 909fbb0:	1085883a 	add	r2,r2,r2
 909fbb4:	1085883a 	add	r2,r2,r2
 909fbb8:	10c5883a 	add	r2,r2,r3
 909fbbc:	10800104 	addi	r2,r2,4
 909fbc0:	10800017 	ldw	r2,0(r2)
 909fbc4:	e0bff515 	stw	r2,-44(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 909fbc8:	e13ff517 	ldw	r4,-44(fp)
 909fbcc:	909c2f00 	call	909c2f0 <alt_tse_get_mac_info_index>
 909fbd0:	e0bff345 	stb	r2,-51(fp)

        pphy = pmac_info->pphy_info;
 909fbd4:	e0bff517 	ldw	r2,-44(fp)
 909fbd8:	10800117 	ldw	r2,4(r2)
 909fbdc:	e0bff615 	stw	r2,-40(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 909fbe0:	e0bff617 	ldw	r2,-40(fp)
 909fbe4:	1005003a 	cmpeq	r2,r2,zero
 909fbe8:	1000c91e 	bne	r2,zero,909ff10 <alt_tse_phy_set_common_speed+0x41c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 909fbec:	e0bff517 	ldw	r2,-44(fp)
 909fbf0:	10800217 	ldw	r2,8(r2)
 909fbf4:	e0bff415 	stw	r2,-48(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 909fbf8:	e0bff617 	ldw	r2,-40(fp)
 909fbfc:	10800003 	ldbu	r2,0(r2)
 909fc00:	11403fcc 	andi	r5,r2,255
 909fc04:	e13ff617 	ldw	r4,-40(fp)
 909fc08:	909d4300 	call	909d430 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 909fc0c:	e0bff617 	ldw	r2,-40(fp)
 909fc10:	108000c3 	ldbu	r2,3(r2)
 909fc14:	10803fcc 	andi	r2,r2,255
 909fc18:	1004c03a 	cmpne	r2,r2,zero
 909fc1c:	10000f1e 	bne	r2,zero,909fc5c <alt_tse_phy_set_common_speed+0x168>
 909fc20:	e0bff617 	ldw	r2,-40(fp)
 909fc24:	10800103 	ldbu	r2,4(r2)
 909fc28:	10803fcc 	andi	r2,r2,255
 909fc2c:	1004c03a 	cmpne	r2,r2,zero
 909fc30:	10000a1e 	bne	r2,zero,909fc5c <alt_tse_phy_set_common_speed+0x168>
 909fc34:	e0bff617 	ldw	r2,-40(fp)
 909fc38:	10800043 	ldbu	r2,1(r2)
 909fc3c:	10803fcc 	andi	r2,r2,255
 909fc40:	1004c03a 	cmpne	r2,r2,zero
 909fc44:	1000051e 	bne	r2,zero,909fc5c <alt_tse_phy_set_common_speed+0x168>
 909fc48:	e0bff617 	ldw	r2,-40(fp)
 909fc4c:	10800083 	ldbu	r2,2(r2)
 909fc50:	10803fcc 	andi	r2,r2,255
 909fc54:	1005003a 	cmpeq	r2,r2,zero
 909fc58:	1000031e 	bne	r2,zero,909fc68 <alt_tse_phy_set_common_speed+0x174>
 909fc5c:	00800044 	movi	r2,1
 909fc60:	e0bffe15 	stw	r2,-8(fp)
 909fc64:	00000106 	br	909fc6c <alt_tse_phy_set_common_speed+0x178>
 909fc68:	e03ffe15 	stw	zero,-8(fp)
 909fc6c:	e0bffe17 	ldw	r2,-8(fp)
 909fc70:	e0bff705 	stb	r2,-36(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 909fc74:	e0bff703 	ldbu	r2,-36(fp)
 909fc78:	1004c03a 	cmpne	r2,r2,zero
 909fc7c:	1000101e 	bne	r2,zero,909fcc0 <alt_tse_phy_set_common_speed+0x1cc>
 909fc80:	e0bffa17 	ldw	r2,-24(fp)
 909fc84:	10800098 	cmpnei	r2,r2,2
 909fc88:	10000d1e 	bne	r2,zero,909fcc0 <alt_tse_phy_set_common_speed+0x1cc>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 909fc8c:	e17ff307 	ldb	r5,-52(fp)
 909fc90:	e1bff347 	ldb	r6,-51(fp)
 909fc94:	01024374 	movhi	r4,2317
 909fc98:	213d1904 	addi	r4,r4,-2972
 909fc9c:	90833900 	call	9083390 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909fca0:	e0bff217 	ldw	r2,-56(fp)
 909fca4:	10801004 	addi	r2,r2,64
 909fca8:	1007883a 	mov	r3,r2
 909fcac:	e0bff117 	ldw	r2,-60(fp)
 909fcb0:	18800035 	stwio	r2,0(r3)
            return TSE_PHY_SPEED_NO_COMMON;
 909fcb4:	00bfffc4 	movi	r2,-1
 909fcb8:	e0bfff15 	stw	r2,-4(fp)
 909fcbc:	0000be06 	br	909ffb8 <alt_tse_phy_set_common_speed+0x4c4>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 909fcc0:	e13ff617 	ldw	r4,-40(fp)
 909fcc4:	01400044 	movi	r5,1
 909fcc8:	018000c4 	movi	r6,3
 909fccc:	01c00044 	movi	r7,1
 909fcd0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fcd4:	1004c03a 	cmpne	r2,r2,zero
 909fcd8:	1000151e 	bne	r2,zero,909fd30 <alt_tse_phy_set_common_speed+0x23c>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 909fcdc:	e0bff703 	ldbu	r2,-36(fp)
 909fce0:	1005003a 	cmpeq	r2,r2,zero
 909fce4:	1000091e 	bne	r2,zero,909fd0c <alt_tse_phy_set_common_speed+0x218>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 909fce8:	e0bffa17 	ldw	r2,-24(fp)
 909fcec:	1005d07a 	srai	r2,r2,1
 909fcf0:	10bfffcc 	andi	r2,r2,65535
 909fcf4:	d8800015 	stw	r2,0(sp)
 909fcf8:	e13ff617 	ldw	r4,-40(fp)
 909fcfc:	000b883a 	mov	r5,zero
 909fd00:	01800184 	movi	r6,6
 909fd04:	01c00044 	movi	r7,1
 909fd08:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 909fd0c:	e0bffa17 	ldw	r2,-24(fp)
 909fd10:	10bfffcc 	andi	r2,r2,65535
 909fd14:	d8800015 	stw	r2,0(sp)
 909fd18:	e13ff617 	ldw	r4,-40(fp)
 909fd1c:	000b883a 	mov	r5,zero
 909fd20:	01800344 	movi	r6,13
 909fd24:	01c00044 	movi	r7,1
 909fd28:	909d4840 	call	909d484 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 909fd2c:	00007806 	br	909ff10 <alt_tse_phy_set_common_speed+0x41c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 909fd30:	e0bffa17 	ldw	r2,-24(fp)
 909fd34:	10800098 	cmpnei	r2,r2,2
 909fd38:	10000a1e 	bne	r2,zero,909fd64 <alt_tse_phy_set_common_speed+0x270>
            alt_tse_phy_set_adv_1000(pphy, 1);
 909fd3c:	e13ff617 	ldw	r4,-40(fp)
 909fd40:	01400044 	movi	r5,1
 909fd44:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909fd48:	e13ff617 	ldw	r4,-40(fp)
 909fd4c:	01400044 	movi	r5,1
 909fd50:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909fd54:	e13ff617 	ldw	r4,-40(fp)
 909fd58:	01400044 	movi	r5,1
 909fd5c:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
 909fd60:	00002306 	br	909fdf0 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 909fd64:	e0bffa17 	ldw	r2,-24(fp)
 909fd68:	10800058 	cmpnei	r2,r2,1
 909fd6c:	10000a1e 	bne	r2,zero,909fd98 <alt_tse_phy_set_common_speed+0x2a4>
            alt_tse_phy_set_adv_1000(pphy, 0);
 909fd70:	e13ff617 	ldw	r4,-40(fp)
 909fd74:	000b883a 	mov	r5,zero
 909fd78:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 909fd7c:	e13ff617 	ldw	r4,-40(fp)
 909fd80:	01400044 	movi	r5,1
 909fd84:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909fd88:	e13ff617 	ldw	r4,-40(fp)
 909fd8c:	01400044 	movi	r5,1
 909fd90:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
 909fd94:	00001606 	br	909fdf0 <alt_tse_phy_set_common_speed+0x2fc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 909fd98:	e0bffa17 	ldw	r2,-24(fp)
 909fd9c:	1004c03a 	cmpne	r2,r2,zero
 909fda0:	10000a1e 	bne	r2,zero,909fdcc <alt_tse_phy_set_common_speed+0x2d8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 909fda4:	e13ff617 	ldw	r4,-40(fp)
 909fda8:	000b883a 	mov	r5,zero
 909fdac:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 909fdb0:	e13ff617 	ldw	r4,-40(fp)
 909fdb4:	000b883a 	mov	r5,zero
 909fdb8:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 909fdbc:	e13ff617 	ldw	r4,-40(fp)
 909fdc0:	01400044 	movi	r5,1
 909fdc4:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
 909fdc8:	00000906 	br	909fdf0 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 909fdcc:	e13ff617 	ldw	r4,-40(fp)
 909fdd0:	000b883a 	mov	r5,zero
 909fdd4:	909f29c0 	call	909f29c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 909fdd8:	e13ff617 	ldw	r4,-40(fp)
 909fddc:	000b883a 	mov	r5,zero
 909fde0:	909f4300 	call	909f430 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 909fde4:	e13ff617 	ldw	r4,-40(fp)
 909fde8:	000b883a 	mov	r5,zero
 909fdec:	909f6400 	call	909f640 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 909fdf0:	e13ff617 	ldw	r4,-40(fp)
 909fdf4:	01400044 	movi	r5,1
 909fdf8:	01800144 	movi	r6,5
 909fdfc:	01c00044 	movi	r7,1
 909fe00:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fe04:	10800058 	cmpnei	r2,r2,1
 909fe08:	1000341e 	bne	r2,zero,909fedc <alt_tse_phy_set_common_speed+0x3e8>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 909fe0c:	e0bff703 	ldbu	r2,-36(fp)
 909fe10:	1005003a 	cmpeq	r2,r2,zero
 909fe14:	10000d1e 	bne	r2,zero,909fe4c <alt_tse_phy_set_common_speed+0x358>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 909fe18:	e0bff617 	ldw	r2,-40(fp)
 909fe1c:	10800517 	ldw	r2,20(r2)
 909fe20:	10801583 	ldbu	r2,86(r2)
 909fe24:	11403fcc 	andi	r5,r2,255
 909fe28:	e0bff617 	ldw	r2,-40(fp)
 909fe2c:	10800517 	ldw	r2,20(r2)
 909fe30:	108015c3 	ldbu	r2,87(r2)
 909fe34:	11803fcc 	andi	r6,r2,255
 909fe38:	e13ff617 	ldw	r4,-40(fp)
 909fe3c:	01c00084 	movi	r7,2
 909fe40:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fe44:	e0bff785 	stb	r2,-34(fp)
 909fe48:	00000c06 	br	909fe7c <alt_tse_phy_set_common_speed+0x388>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 909fe4c:	e0bff617 	ldw	r2,-40(fp)
 909fe50:	10800517 	ldw	r2,20(r2)
 909fe54:	10801583 	ldbu	r2,86(r2)
 909fe58:	11403fcc 	andi	r5,r2,255
 909fe5c:	e0bff617 	ldw	r2,-40(fp)
 909fe60:	10800517 	ldw	r2,20(r2)
 909fe64:	108015c3 	ldbu	r2,87(r2)
 909fe68:	11803fcc 	andi	r6,r2,255
 909fe6c:	e13ff617 	ldw	r4,-40(fp)
 909fe70:	01c00044 	movi	r7,1
 909fe74:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fe78:	e0bff785 	stb	r2,-34(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 909fe7c:	e0fff783 	ldbu	r3,-34(fp)
 909fe80:	e0bffa17 	ldw	r2,-24(fp)
 909fe84:	18800426 	beq	r3,r2,909fe98 <alt_tse_phy_set_common_speed+0x3a4>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 909fe88:	e13ff617 	ldw	r4,-40(fp)
 909fe8c:	01400134 	movhi	r5,4
 909fe90:	29742404 	addi	r5,r5,-12144
 909fe94:	909ea680 	call	909ea68 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 909fe98:	e0bff617 	ldw	r2,-40(fp)
 909fe9c:	10800517 	ldw	r2,20(r2)
 909fea0:	10801583 	ldbu	r2,86(r2)
 909fea4:	11403fcc 	andi	r5,r2,255
 909fea8:	e0bff617 	ldw	r2,-40(fp)
 909feac:	10800517 	ldw	r2,20(r2)
 909feb0:	10801603 	ldbu	r2,88(r2)
 909feb4:	11803fcc 	andi	r6,r2,255
 909feb8:	e13ff617 	ldw	r4,-40(fp)
 909febc:	01c00044 	movi	r7,1
 909fec0:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fec4:	e0bff745 	stb	r2,-35(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 909fec8:	e0bff417 	ldw	r2,-48(fp)
 909fecc:	10800017 	ldw	r2,0(r2)
 909fed0:	1009883a 	mov	r4,r2
 909fed4:	e17ff743 	ldbu	r5,-35(fp)
 909fed8:	909c5480 	call	909c548 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 909fedc:	e43ff307 	ldb	r16,-52(fp)
 909fee0:	e47ff347 	ldb	r17,-51(fp)
 909fee4:	e13ff617 	ldw	r4,-40(fp)
 909fee8:	01400044 	movi	r5,1
 909feec:	000d883a 	mov	r6,zero
 909fef0:	01c00404 	movi	r7,16
 909fef4:	909d5ac0 	call	909d5ac <alt_tse_phy_rd_mdio_reg>
 909fef8:	100f883a 	mov	r7,r2
 909fefc:	01024374 	movhi	r4,2317
 909ff00:	213d3004 	addi	r4,r4,-2880
 909ff04:	800b883a 	mov	r5,r16
 909ff08:	880d883a 	mov	r6,r17
 909ff0c:	90833900 	call	9083390 <printf>
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 909ff10:	e0bff817 	ldw	r2,-32(fp)
 909ff14:	10800044 	addi	r2,r2,1
 909ff18:	e0bff815 	stw	r2,-32(fp)
 909ff1c:	e0bff917 	ldw	r2,-28(fp)
 909ff20:	10800003 	ldbu	r2,0(r2)
 909ff24:	10c03fcc 	andi	r3,r2,255
 909ff28:	e0bff817 	ldw	r2,-32(fp)
 909ff2c:	10ff1e16 	blt	r2,r3,909fba8 <alt_tse_phy_set_common_speed+0xb4>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 909ff30:	e0bff307 	ldb	r2,-52(fp)
 909ff34:	e0bffd15 	stw	r2,-12(fp)
 909ff38:	e0bffa17 	ldw	r2,-24(fp)
 909ff3c:	108000a0 	cmpeqi	r2,r2,2
 909ff40:	10000b1e 	bne	r2,zero,909ff70 <alt_tse_phy_set_common_speed+0x47c>
 909ff44:	e0bffa17 	ldw	r2,-24(fp)
 909ff48:	10800058 	cmpnei	r2,r2,1
 909ff4c:	1000031e 	bne	r2,zero,909ff5c <alt_tse_phy_set_common_speed+0x468>
 909ff50:	00801904 	movi	r2,100
 909ff54:	e0bffb15 	stw	r2,-20(fp)
 909ff58:	00000206 	br	909ff64 <alt_tse_phy_set_common_speed+0x470>
 909ff5c:	00800284 	movi	r2,10
 909ff60:	e0bffb15 	stw	r2,-20(fp)
 909ff64:	e0bffb17 	ldw	r2,-20(fp)
 909ff68:	e0bffc15 	stw	r2,-16(fp)
 909ff6c:	00000206 	br	909ff78 <alt_tse_phy_set_common_speed+0x484>
 909ff70:	0080fa04 	movi	r2,1000
 909ff74:	e0bffc15 	stw	r2,-16(fp)
 909ff78:	01024374 	movhi	r4,2317
 909ff7c:	213d3c04 	addi	r4,r4,-2832
 909ff80:	e17ffd17 	ldw	r5,-12(fp)
 909ff84:	e1bffc17 	ldw	r6,-16(fp)
 909ff88:	90833900 	call	9083390 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 909ff8c:	e0bffa17 	ldw	r2,-24(fp)
 909ff90:	11403fcc 	andi	r5,r2,255
 909ff94:	e13ff217 	ldw	r4,-56(fp)
 909ff98:	909c45c0 	call	909c45c <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 909ff9c:	e0bff217 	ldw	r2,-56(fp)
 909ffa0:	10801004 	addi	r2,r2,64
 909ffa4:	1007883a 	mov	r3,r2
 909ffa8:	e0bff117 	ldw	r2,-60(fp)
 909ffac:	18800035 	stwio	r2,0(r3)
        
    return common_speed;
 909ffb0:	e0bffa17 	ldw	r2,-24(fp)
 909ffb4:	e0bfff15 	stw	r2,-4(fp)
 909ffb8:	e0bfff17 	ldw	r2,-4(fp)
}
 909ffbc:	e037883a 	mov	sp,fp
 909ffc0:	dfc00317 	ldw	ra,12(sp)
 909ffc4:	df000217 	ldw	fp,8(sp)
 909ffc8:	dc400117 	ldw	r17,4(sp)
 909ffcc:	dc000017 	ldw	r16,0(sp)
 909ffd0:	dec00404 	addi	sp,sp,16
 909ffd4:	f800283a 	ret

0909ffd8 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 909ffd8:	defffc04 	addi	sp,sp,-16
 909ffdc:	dfc00315 	stw	ra,12(sp)
 909ffe0:	df000215 	stw	fp,8(sp)
 909ffe4:	df000204 	addi	fp,sp,8
 909ffe8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 909ffec:	e0bfff17 	ldw	r2,-4(fp)
 909fff0:	1080a104 	addi	r2,r2,644
 909fff4:	10800037 	ldwio	r2,0(r2)
 909fff8:	1080080c 	andi	r2,r2,32
 909fffc:	1004c03a 	cmpne	r2,r2,zero
 90a0000:	1000191e 	bne	r2,zero,90a0068 <marvell_phy_cfg+0x90>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 90a0004:	01024374 	movhi	r4,2317
 90a0008:	213d4d04 	addi	r4,r4,-2764
 90a000c:	90836b80 	call	90836b8 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 90a0010:	e0bfff17 	ldw	r2,-4(fp)
 90a0014:	1080a004 	addi	r2,r2,640
 90a0018:	10801004 	addi	r2,r2,64
 90a001c:	1007883a 	mov	r3,r2
 90a0020:	00801e04 	movi	r2,120
 90a0024:	18800035 	stwio	r2,0(r3)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 90a0028:	01024374 	movhi	r4,2317
 90a002c:	213d5604 	addi	r4,r4,-2728
 90a0030:	90836b80 	call	90836b8 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 90a0034:	e0bfff17 	ldw	r2,-4(fp)
 90a0038:	1080a004 	addi	r2,r2,640
 90a003c:	10800037 	ldwio	r2,0(r2)
 90a0040:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 90a0044:	e0bfff17 	ldw	r2,-4(fp)
 90a0048:	1080a004 	addi	r2,r2,640
 90a004c:	1009883a 	mov	r4,r2
 90a0050:	e0fffe0b 	ldhu	r3,-8(fp)
 90a0054:	00a00004 	movi	r2,-32768
 90a0058:	1884b03a 	or	r2,r3,r2
 90a005c:	10ffffcc 	andi	r3,r2,65535
 90a0060:	2005883a 	mov	r2,r4
 90a0064:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 90a0068:	0005883a 	mov	r2,zero
}
 90a006c:	e037883a 	mov	sp,fp
 90a0070:	dfc00117 	ldw	ra,4(sp)
 90a0074:	df000017 	ldw	fp,0(sp)
 90a0078:	dec00204 	addi	sp,sp,8
 90a007c:	f800283a 	ret

090a0080 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 90a0080:	defffc04 	addi	sp,sp,-16
 90a0084:	dfc00315 	stw	ra,12(sp)
 90a0088:	df000215 	stw	fp,8(sp)
 90a008c:	df000204 	addi	fp,sp,8
 90a0090:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 90a0094:	e0bfff17 	ldw	r2,-4(fp)
 90a0098:	1080bb04 	addi	r2,r2,748
 90a009c:	10800037 	ldwio	r2,0(r2)
 90a00a0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 90a00a4:	00fffc04 	movi	r3,-16
 90a00a8:	e0bffe0b 	ldhu	r2,-8(fp)
 90a00ac:	10c4703a 	and	r2,r2,r3
 90a00b0:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 90a00b4:	01024374 	movhi	r4,2317
 90a00b8:	213d5b04 	addi	r4,r4,-2708
 90a00bc:	90836b80 	call	90836b8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 90a00c0:	e0bfff17 	ldw	r2,-4(fp)
 90a00c4:	1080bb04 	addi	r2,r2,748
 90a00c8:	1009883a 	mov	r4,r2
 90a00cc:	e0bffe0b 	ldhu	r2,-8(fp)
 90a00d0:	108003d4 	ori	r2,r2,15
 90a00d4:	10ffffcc 	andi	r3,r2,65535
 90a00d8:	2005883a 	mov	r2,r4
 90a00dc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 90a00e0:	01024374 	movhi	r4,2317
 90a00e4:	213d6704 	addi	r4,r4,-2660
 90a00e8:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 90a00ec:	e0bfff17 	ldw	r2,-4(fp)
 90a00f0:	1080b404 	addi	r2,r2,720
 90a00f4:	10800037 	ldwio	r2,0(r2)
 90a00f8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 90a00fc:	e0fffe0b 	ldhu	r3,-8(fp)
 90a0100:	00bfdf44 	movi	r2,-131
 90a0104:	1884703a 	and	r2,r3,r2
 90a0108:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 90a010c:	e0bfff17 	ldw	r2,-4(fp)
 90a0110:	1080b404 	addi	r2,r2,720
 90a0114:	e0fffe0b 	ldhu	r3,-8(fp)
 90a0118:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 90a011c:	01024374 	movhi	r4,2317
 90a0120:	213d5604 	addi	r4,r4,-2728
 90a0124:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 90a0128:	e0bfff17 	ldw	r2,-4(fp)
 90a012c:	1080a004 	addi	r2,r2,640
 90a0130:	10800037 	ldwio	r2,0(r2)
 90a0134:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 90a0138:	e0bfff17 	ldw	r2,-4(fp)
 90a013c:	1080a004 	addi	r2,r2,640
 90a0140:	1009883a 	mov	r4,r2
 90a0144:	e0fffe0b 	ldhu	r3,-8(fp)
 90a0148:	00a00004 	movi	r2,-32768
 90a014c:	1884b03a 	or	r2,r3,r2
 90a0150:	10ffffcc 	andi	r3,r2,65535
 90a0154:	2005883a 	mov	r2,r4
 90a0158:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 90a015c:	00800044 	movi	r2,1
}
 90a0160:	e037883a 	mov	sp,fp
 90a0164:	dfc00117 	ldw	ra,4(sp)
 90a0168:	df000017 	ldw	fp,0(sp)
 90a016c:	dec00204 	addi	sp,sp,8
 90a0170:	f800283a 	ret

090a0174 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 90a0174:	defffc04 	addi	sp,sp,-16
 90a0178:	dfc00315 	stw	ra,12(sp)
 90a017c:	df000215 	stw	fp,8(sp)
 90a0180:	df000204 	addi	fp,sp,8
 90a0184:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 90a0188:	e0bfff17 	ldw	r2,-4(fp)
 90a018c:	1080bb04 	addi	r2,r2,748
 90a0190:	10800037 	ldwio	r2,0(r2)
 90a0194:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 90a0198:	00fffc04 	movi	r3,-16
 90a019c:	e0bffe0b 	ldhu	r2,-8(fp)
 90a01a0:	10c4703a 	and	r2,r2,r3
 90a01a4:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 90a01a8:	01024374 	movhi	r4,2317
 90a01ac:	213d7104 	addi	r4,r4,-2620
 90a01b0:	90836b80 	call	90836b8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 90a01b4:	e0bfff17 	ldw	r2,-4(fp)
 90a01b8:	1080bb04 	addi	r2,r2,748
 90a01bc:	1009883a 	mov	r4,r2
 90a01c0:	e0bffe0b 	ldhu	r2,-8(fp)
 90a01c4:	10800114 	ori	r2,r2,4
 90a01c8:	10ffffcc 	andi	r3,r2,65535
 90a01cc:	2005883a 	mov	r2,r4
 90a01d0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 90a01d4:	01024374 	movhi	r4,2317
 90a01d8:	213d6704 	addi	r4,r4,-2660
 90a01dc:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 90a01e0:	e0bfff17 	ldw	r2,-4(fp)
 90a01e4:	1080b404 	addi	r2,r2,720
 90a01e8:	10800037 	ldwio	r2,0(r2)
 90a01ec:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 90a01f0:	e0fffe0b 	ldhu	r3,-8(fp)
 90a01f4:	00bfdf44 	movi	r2,-131
 90a01f8:	1884703a 	and	r2,r3,r2
 90a01fc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 90a0200:	e0bfff17 	ldw	r2,-4(fp)
 90a0204:	1080b404 	addi	r2,r2,720
 90a0208:	e0fffe0b 	ldhu	r3,-8(fp)
 90a020c:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 90a0210:	01024374 	movhi	r4,2317
 90a0214:	213d5604 	addi	r4,r4,-2728
 90a0218:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 90a021c:	e0bfff17 	ldw	r2,-4(fp)
 90a0220:	1080a004 	addi	r2,r2,640
 90a0224:	10800037 	ldwio	r2,0(r2)
 90a0228:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 90a022c:	e0bfff17 	ldw	r2,-4(fp)
 90a0230:	1080a004 	addi	r2,r2,640
 90a0234:	1009883a 	mov	r4,r2
 90a0238:	e0fffe0b 	ldhu	r3,-8(fp)
 90a023c:	00a00004 	movi	r2,-32768
 90a0240:	1884b03a 	or	r2,r3,r2
 90a0244:	10ffffcc 	andi	r3,r2,65535
 90a0248:	2005883a 	mov	r2,r4
 90a024c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 90a0250:	00800044 	movi	r2,1
}
 90a0254:	e037883a 	mov	sp,fp
 90a0258:	dfc00117 	ldw	ra,4(sp)
 90a025c:	df000017 	ldw	fp,0(sp)
 90a0260:	dec00204 	addi	sp,sp,8
 90a0264:	f800283a 	ret

090a0268 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 90a0268:	defffc04 	addi	sp,sp,-16
 90a026c:	dfc00315 	stw	ra,12(sp)
 90a0270:	df000215 	stw	fp,8(sp)
 90a0274:	df000204 	addi	fp,sp,8
 90a0278:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 90a027c:	e0bfff17 	ldw	r2,-4(fp)
 90a0280:	1080bb04 	addi	r2,r2,748
 90a0284:	10800037 	ldwio	r2,0(r2)
 90a0288:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 90a028c:	00fffc04 	movi	r3,-16
 90a0290:	e0bffe0b 	ldhu	r2,-8(fp)
 90a0294:	10c4703a 	and	r2,r2,r3
 90a0298:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 90a029c:	01024374 	movhi	r4,2317
 90a02a0:	213d8604 	addi	r4,r4,-2536
 90a02a4:	90836b80 	call	90836b8 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 90a02a8:	e0bfff17 	ldw	r2,-4(fp)
 90a02ac:	1080bb04 	addi	r2,r2,748
 90a02b0:	1009883a 	mov	r4,r2
 90a02b4:	e0bffe0b 	ldhu	r2,-8(fp)
 90a02b8:	108002d4 	ori	r2,r2,11
 90a02bc:	10ffffcc 	andi	r3,r2,65535
 90a02c0:	2005883a 	mov	r2,r4
 90a02c4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 90a02c8:	01024374 	movhi	r4,2317
 90a02cc:	213d9504 	addi	r4,r4,-2476
 90a02d0:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 90a02d4:	e0bfff17 	ldw	r2,-4(fp)
 90a02d8:	1080b404 	addi	r2,r2,720
 90a02dc:	10800037 	ldwio	r2,0(r2)
 90a02e0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 90a02e4:	e0fffe0b 	ldhu	r3,-8(fp)
 90a02e8:	00bfdf44 	movi	r2,-131
 90a02ec:	1884703a 	and	r2,r3,r2
 90a02f0:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 90a02f4:	e0bffe0b 	ldhu	r2,-8(fp)
 90a02f8:	10802094 	ori	r2,r2,130
 90a02fc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 90a0300:	e0bfff17 	ldw	r2,-4(fp)
 90a0304:	1080b404 	addi	r2,r2,720
 90a0308:	e0fffe0b 	ldhu	r3,-8(fp)
 90a030c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 90a0310:	01024374 	movhi	r4,2317
 90a0314:	213d5604 	addi	r4,r4,-2728
 90a0318:	90836b80 	call	90836b8 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 90a031c:	e0bfff17 	ldw	r2,-4(fp)
 90a0320:	1080a004 	addi	r2,r2,640
 90a0324:	10800037 	ldwio	r2,0(r2)
 90a0328:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 90a032c:	e0bfff17 	ldw	r2,-4(fp)
 90a0330:	1080a004 	addi	r2,r2,640
 90a0334:	1009883a 	mov	r4,r2
 90a0338:	e0fffe0b 	ldhu	r3,-8(fp)
 90a033c:	00a00004 	movi	r2,-32768
 90a0340:	1884b03a 	or	r2,r3,r2
 90a0344:	10ffffcc 	andi	r3,r2,65535
 90a0348:	2005883a 	mov	r2,r4
 90a034c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 90a0350:	00800044 	movi	r2,1
    
}
 90a0354:	e037883a 	mov	sp,fp
 90a0358:	dfc00117 	ldw	ra,4(sp)
 90a035c:	df000017 	ldw	fp,0(sp)
 90a0360:	dec00204 	addi	sp,sp,8
 90a0364:	f800283a 	ret

090a0368 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 90a0368:	defffc04 	addi	sp,sp,-16
 90a036c:	df000315 	stw	fp,12(sp)
 90a0370:	df000304 	addi	fp,sp,12
 90a0374:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 90a0378:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 90a037c:	e0bfff17 	ldw	r2,-4(fp)
 90a0380:	1080b004 	addi	r2,r2,704
 90a0384:	10800037 	ldwio	r2,0(r2)
 90a0388:	e0bffd15 	stw	r2,-12(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 90a038c:	e0bffd17 	ldw	r2,-12(fp)
 90a0390:	1080008c 	andi	r2,r2,2
 90a0394:	1005003a 	cmpeq	r2,r2,zero
 90a0398:	1000041e 	bne	r2,zero,90a03ac <DP83848C_link_status_read+0x44>
		link_status |= 0x8;
 90a039c:	e0bffe17 	ldw	r2,-8(fp)
 90a03a0:	10800214 	ori	r2,r2,8
 90a03a4:	e0bffe15 	stw	r2,-8(fp)
 90a03a8:	00000306 	br	90a03b8 <DP83848C_link_status_read+0x50>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 90a03ac:	e0bffe17 	ldw	r2,-8(fp)
 90a03b0:	10800114 	ori	r2,r2,4
 90a03b4:	e0bffe15 	stw	r2,-8(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 90a03b8:	e0bffd17 	ldw	r2,-12(fp)
 90a03bc:	1080010c 	andi	r2,r2,4
 90a03c0:	1005003a 	cmpeq	r2,r2,zero
 90a03c4:	1000031e 	bne	r2,zero,90a03d4 <DP83848C_link_status_read+0x6c>
		link_status |= 0x1;
 90a03c8:	e0bffe17 	ldw	r2,-8(fp)
 90a03cc:	10800054 	ori	r2,r2,1
 90a03d0:	e0bffe15 	stw	r2,-8(fp)
	}
	
	return link_status;
 90a03d4:	e0bffe17 	ldw	r2,-8(fp)
}
 90a03d8:	e037883a 	mov	sp,fp
 90a03dc:	df000017 	ldw	fp,0(sp)
 90a03e0:	dec00104 	addi	sp,sp,4
 90a03e4:	f800283a 	ret

090a03e8 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 90a03e8:	defff904 	addi	sp,sp,-28
 90a03ec:	dfc00615 	stw	ra,24(sp)
 90a03f0:	df000515 	stw	fp,20(sp)
 90a03f4:	df000504 	addi	fp,sp,20
 90a03f8:	e13ffe15 	stw	r4,-8(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 90a03fc:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_system_info *psys_info = 0;
 90a0400:	e03ffb15 	stw	zero,-20(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 90a0404:	e03ffd15 	stw	zero,-12(fp)
 90a0408:	00001206 	br	90a0454 <altera_eth_tse_init+0x6c>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 90a040c:	e0bffd17 	ldw	r2,-12(fp)
 90a0410:	00c243b4 	movhi	r3,2318
 90a0414:	18f4c904 	addi	r3,r3,-11484
 90a0418:	10800324 	muli	r2,r2,12
 90a041c:	10c5883a 	add	r2,r2,r3
 90a0420:	10c00017 	ldw	r3,0(r2)
 90a0424:	e0bffe17 	ldw	r2,-8(fp)
 90a0428:	1880071e 	bne	r3,r2,90a0448 <altera_eth_tse_init+0x60>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 90a042c:	e0bffd17 	ldw	r2,-12(fp)
 90a0430:	10800324 	muli	r2,r2,12
 90a0434:	1007883a 	mov	r3,r2
 90a0438:	008243b4 	movhi	r2,2318
 90a043c:	10b4c904 	addi	r2,r2,-11484
 90a0440:	1885883a 	add	r2,r3,r2
 90a0444:	e0bffc15 	stw	r2,-16(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 90a0448:	e0bffd17 	ldw	r2,-12(fp)
 90a044c:	10800044 	addi	r2,r2,1
 90a0450:	e0bffd15 	stw	r2,-12(fp)
 90a0454:	d0a08103 	ldbu	r2,-32252(gp)
 90a0458:	10c03fcc 	andi	r3,r2,255
 90a045c:	e0bffd17 	ldw	r2,-12(fp)
 90a0460:	10ffea16 	blt	r2,r3,90a040c <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 90a0464:	e0bffc17 	ldw	r2,-16(fp)
 90a0468:	1004c03a 	cmpne	r2,r2,zero
 90a046c:	1000031e 	bne	r2,zero,90a047c <altera_eth_tse_init+0x94>
        return ENP_HARDWARE;
 90a0470:	00bff744 	movi	r2,-35
 90a0474:	e0bfff15 	stw	r2,-4(fp)
 90a0478:	00002c06 	br	90a052c <altera_eth_tse_init+0x144>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 90a047c:	e03ffd15 	stw	zero,-12(fp)
 90a0480:	00001306 	br	90a04d0 <altera_eth_tse_init+0xe8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 90a0484:	e0bffd17 	ldw	r2,-12(fp)
 90a0488:	00c24374 	movhi	r3,2317
 90a048c:	18c69404 	addi	r3,r3,6736
 90a0490:	10801224 	muli	r2,r2,72
 90a0494:	10c5883a 	add	r2,r2,r3
 90a0498:	10c00017 	ldw	r3,0(r2)
 90a049c:	e0bffc17 	ldw	r2,-16(fp)
 90a04a0:	10800117 	ldw	r2,4(r2)
 90a04a4:	1880071e 	bne	r3,r2,90a04c4 <altera_eth_tse_init+0xdc>
            psys_info = &tse_mac_device[i];
 90a04a8:	e0bffd17 	ldw	r2,-12(fp)
 90a04ac:	10801224 	muli	r2,r2,72
 90a04b0:	1007883a 	mov	r3,r2
 90a04b4:	00824374 	movhi	r2,2317
 90a04b8:	10869404 	addi	r2,r2,6736
 90a04bc:	1885883a 	add	r2,r3,r2
 90a04c0:	e0bffb15 	stw	r2,-20(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 90a04c4:	e0bffd17 	ldw	r2,-12(fp)
 90a04c8:	10800044 	addi	r2,r2,1
 90a04cc:	e0bffd15 	stw	r2,-12(fp)
 90a04d0:	00824374 	movhi	r2,2317
 90a04d4:	108eb004 	addi	r2,r2,15040
 90a04d8:	10800003 	ldbu	r2,0(r2)
 90a04dc:	10c03fcc 	andi	r3,r2,255
 90a04e0:	e0bffd17 	ldw	r2,-12(fp)
 90a04e4:	10ffe716 	blt	r2,r3,90a0484 <altera_eth_tse_init+0x9c>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 90a04e8:	e0bffb17 	ldw	r2,-20(fp)
 90a04ec:	1004c03a 	cmpne	r2,r2,zero
 90a04f0:	1000031e 	bne	r2,zero,90a0500 <altera_eth_tse_init+0x118>
        return ENP_HARDWARE;
 90a04f4:	00bff744 	movi	r2,-35
 90a04f8:	e0bfff15 	stw	r2,-4(fp)
 90a04fc:	00000b06 	br	90a052c <altera_eth_tse_init+0x144>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 90a0500:	e0bffe17 	ldw	r2,-8(fp)
 90a0504:	11000517 	ldw	r4,20(r2)
 90a0508:	e0bffc17 	ldw	r2,-16(fp)
 90a050c:	10800203 	ldbu	r2,8(r2)
 90a0510:	10803fcc 	andi	r2,r2,255
 90a0514:	10801224 	muli	r2,r2,72
 90a0518:	1007883a 	mov	r3,r2
 90a051c:	e0bffb17 	ldw	r2,-20(fp)
 90a0520:	188b883a 	add	r5,r3,r2
 90a0524:	90a05440 	call	90a0544 <prep_tse_mac>
    
    return SUCCESS;
 90a0528:	e03fff15 	stw	zero,-4(fp)
 90a052c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a0530:	e037883a 	mov	sp,fp
 90a0534:	dfc00117 	ldw	ra,4(sp)
 90a0538:	df000017 	ldw	fp,0(sp)
 90a053c:	dec00204 	addi	sp,sp,8
 90a0540:	f800283a 	ret

090a0544 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 90a0544:	defffa04 	addi	sp,sp,-24
 90a0548:	dfc00515 	stw	ra,20(sp)
 90a054c:	df000415 	stw	fp,16(sp)
 90a0550:	dc000315 	stw	r16,12(sp)
 90a0554:	df000304 	addi	fp,sp,12
 90a0558:	e13ffe15 	stw	r4,-8(fp)
 90a055c:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 90a0560:	01024374 	movhi	r4,2317
 90a0564:	213d9f04 	addi	r4,r4,-2436
 90a0568:	e17ffe17 	ldw	r5,-8(fp)
 90a056c:	90833900 	call	9083390 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 90a0570:	e0bffe17 	ldw	r2,-8(fp)
 90a0574:	00c243b4 	movhi	r3,2318
 90a0578:	18f4d504 	addi	r3,r3,-11436
 90a057c:	10801324 	muli	r2,r2,76
 90a0580:	10c5883a 	add	r2,r2,r3
 90a0584:	10800c04 	addi	r2,r2,48
 90a0588:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 90a058c:	e0bffe17 	ldw	r2,-8(fp)
 90a0590:	00c243b4 	movhi	r3,2318
 90a0594:	18f4d504 	addi	r3,r3,-11436
 90a0598:	10801324 	muli	r2,r2,76
 90a059c:	10c5883a 	add	r2,r2,r3
 90a05a0:	10c01204 	addi	r3,r2,72
 90a05a4:	e0bfff17 	ldw	r2,-4(fp)
 90a05a8:	18800015 	stw	r2,0(r3)

        ifp = nets[index];
 90a05ac:	e0bffe17 	ldw	r2,-8(fp)
 90a05b0:	00c243b4 	movhi	r3,2318
 90a05b4:	18f5e604 	addi	r3,r3,-10344
 90a05b8:	1085883a 	add	r2,r2,r2
 90a05bc:	1085883a 	add	r2,r2,r2
 90a05c0:	10c5883a 	add	r2,r2,r3
 90a05c4:	10800017 	ldw	r2,0(r2)
 90a05c8:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 90a05cc:	e0bffd17 	ldw	r2,-12(fp)
 90a05d0:	10c02717 	ldw	r3,156(r2)
 90a05d4:	00800084 	movi	r2,2
 90a05d8:	18800615 	stw	r2,24(r3)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 90a05dc:	e0bffd17 	ldw	r2,-12(fp)
 90a05e0:	10c02717 	ldw	r3,156(r2)
 90a05e4:	00800084 	movi	r2,2
 90a05e8:	18800715 	stw	r2,28(r3)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 90a05ec:	e0bffd17 	ldw	r2,-12(fp)
 90a05f0:	14002717 	ldw	r16,156(r2)
 90a05f4:	00824374 	movhi	r2,2317
 90a05f8:	108f2e04 	addi	r2,r2,15544
 90a05fc:	11000017 	ldw	r4,0(r2)
 90a0600:	908d0380 	call	908d038 <__floatunsidf>
 90a0604:	100b883a 	mov	r5,r2
 90a0608:	180d883a 	mov	r6,r3
 90a060c:	2809883a 	mov	r4,r5
 90a0610:	300b883a 	mov	r5,r6
 90a0614:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90a0618:	80800815 	stw	r2,32(r16)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 90a061c:	e0bffd17 	ldw	r2,-12(fp)
 90a0620:	11002717 	ldw	r4,156(r2)
 90a0624:	e0bffe17 	ldw	r2,-8(fp)
 90a0628:	10801324 	muli	r2,r2,76
 90a062c:	10c00604 	addi	r3,r2,24
 90a0630:	008243b4 	movhi	r2,2318
 90a0634:	10b4d504 	addi	r2,r2,-11436
 90a0638:	1885883a 	add	r2,r3,r2
 90a063c:	20800515 	stw	r2,20(r4)
        ifp->n_mib->ifDescr =       (u_char*)"Altera TSE MAC ethernet";
 90a0640:	e0bffd17 	ldw	r2,-12(fp)
 90a0644:	10c02717 	ldw	r3,156(r2)
 90a0648:	00824374 	movhi	r2,2317
 90a064c:	10bda404 	addi	r2,r2,-2416
 90a0650:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 90a0654:	e0fffd17 	ldw	r3,-12(fp)
 90a0658:	00800404 	movi	r2,16
 90a065c:	18800815 	stw	r2,32(r3)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 90a0660:	e0fffd17 	ldw	r3,-12(fp)
 90a0664:	00800184 	movi	r2,6
 90a0668:	18801115 	stw	r2,68(r3)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 90a066c:	e0bffd17 	ldw	r2,-12(fp)
 90a0670:	10c02717 	ldw	r3,156(r2)
 90a0674:	00800184 	movi	r2,6
 90a0678:	18800215 	stw	r2,8(r3)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 90a067c:	e0fffd17 	ldw	r3,-12(fp)
 90a0680:	00817a84 	movi	r2,1514
 90a0684:	18800915 	stw	r2,36(r3)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 90a0688:	e0fffd17 	ldw	r3,-12(fp)
 90a068c:	008242b4 	movhi	r2,2314
 90a0690:	1081f204 	addi	r2,r2,1992
 90a0694:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 90a0698:	e0bffd17 	ldw	r2,-12(fp)
 90a069c:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 90a06a0:	e0fffd17 	ldw	r3,-12(fp)
 90a06a4:	008242b4 	movhi	r2,2314
 90a06a8:	1084ac04 	addi	r2,r2,4784
 90a06ac:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 90a06b0:	e0fffd17 	ldw	r3,-12(fp)
 90a06b4:	008242b4 	movhi	r2,2314
 90a06b8:	1086a204 	addi	r2,r2,6792
 90a06bc:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 90a06c0:	00c242b4 	movhi	r3,2314
 90a06c4:	18c69204 	addi	r3,r3,6728
 90a06c8:	e0bffd17 	ldw	r2,-12(fp)
 90a06cc:	10c00715 	stw	r3,28(r2)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 90a06d0:	e0bffd17 	ldw	r2,-12(fp)
 90a06d4:	10802a17 	ldw	r2,168(r2)
 90a06d8:	10c00214 	ori	r3,r2,8
 90a06dc:	e0bffd17 	ldw	r2,-12(fp)
 90a06e0:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 90a06e4:	e0bffe17 	ldw	r2,-8(fp)
 90a06e8:	00c243b4 	movhi	r3,2318
 90a06ec:	18f5e604 	addi	r3,r3,-10344
 90a06f0:	1085883a 	add	r2,r2,r2
 90a06f4:	1085883a 	add	r2,r2,r2
 90a06f8:	10c5883a 	add	r2,r2,r3
 90a06fc:	10800017 	ldw	r2,0(r2)
 90a0700:	11002717 	ldw	r4,156(r2)
 90a0704:	e0bffe17 	ldw	r2,-8(fp)
 90a0708:	10801324 	muli	r2,r2,76
 90a070c:	10c00604 	addi	r3,r2,24
 90a0710:	008243b4 	movhi	r2,2318
 90a0714:	10b4d504 	addi	r2,r2,-11436
 90a0718:	1885883a 	add	r2,r3,r2
 90a071c:	20800515 	stw	r2,20(r4)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 90a0720:	e0bffe17 	ldw	r2,-8(fp)
 90a0724:	10801324 	muli	r2,r2,76
 90a0728:	10c00604 	addi	r3,r2,24
 90a072c:	008243b4 	movhi	r2,2318
 90a0730:	10b4d504 	addi	r2,r2,-11436
 90a0734:	1885883a 	add	r2,r3,r2
 90a0738:	100b883a 	mov	r5,r2
 90a073c:	e13ffd17 	ldw	r4,-12(fp)
 90a0740:	90818680 	call	9081868 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 90a0744:	e0bffe17 	ldw	r2,-8(fp)
 90a0748:	00c243b4 	movhi	r3,2318
 90a074c:	18f4d504 	addi	r3,r3,-11436
 90a0750:	10801324 	muli	r2,r2,76
 90a0754:	10c7883a 	add	r3,r2,r3
 90a0758:	e0bffe17 	ldw	r2,-8(fp)
 90a075c:	18800015 	stw	r2,0(r3)
        tse[index].netp = ifp;
 90a0760:	e0bffe17 	ldw	r2,-8(fp)
 90a0764:	00c243b4 	movhi	r3,2318
 90a0768:	18f4d504 	addi	r3,r3,-11436
 90a076c:	10801324 	muli	r2,r2,76
 90a0770:	10c5883a 	add	r2,r2,r3
 90a0774:	10c00804 	addi	r3,r2,32
 90a0778:	e0bffd17 	ldw	r2,-12(fp)
 90a077c:	18800015 	stw	r2,0(r3)
        ifp->n_local = (void*)(&tse[index]);
 90a0780:	e0bffe17 	ldw	r2,-8(fp)
 90a0784:	10801324 	muli	r2,r2,76
 90a0788:	1007883a 	mov	r3,r2
 90a078c:	008243b4 	movhi	r2,2318
 90a0790:	10b4d504 	addi	r2,r2,-11436
 90a0794:	1887883a 	add	r3,r3,r2
 90a0798:	e0bffd17 	ldw	r2,-12(fp)
 90a079c:	10c02815 	stw	r3,160(r2)
    
        index++;
 90a07a0:	e0bffe17 	ldw	r2,-8(fp)
 90a07a4:	10800044 	addi	r2,r2,1
 90a07a8:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 90a07ac:	e0bffe17 	ldw	r2,-8(fp)
}
 90a07b0:	e037883a 	mov	sp,fp
 90a07b4:	dfc00217 	ldw	ra,8(sp)
 90a07b8:	df000117 	ldw	fp,4(sp)
 90a07bc:	dc000017 	ldw	r16,0(sp)
 90a07c0:	dec00304 	addi	sp,sp,12
 90a07c4:	f800283a 	ret

090a07c8 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 90a07c8:	deffee04 	addi	sp,sp,-72
 90a07cc:	dfc01115 	stw	ra,68(sp)
 90a07d0:	df001015 	stw	fp,64(sp)
 90a07d4:	df001004 	addi	fp,sp,64
 90a07d8:	e13ffe15 	stw	r4,-8(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 90a07dc:	e03ff815 	stw	zero,-32(fp)
   
   NET ifp;
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 90a07e0:	e0bffe17 	ldw	r2,-8(fp)
 90a07e4:	00c243b4 	movhi	r3,2318
 90a07e8:	18f4d504 	addi	r3,r3,-11436
 90a07ec:	10801324 	muli	r2,r2,76
 90a07f0:	10c5883a 	add	r2,r2,r3
 90a07f4:	10801204 	addi	r2,r2,72
 90a07f8:	10800017 	ldw	r2,0(r2)
 90a07fc:	e0bff415 	stw	r2,-48(fp)
   
   dprintf("[tse_mac_init]\n");
 90a0800:	01024374 	movhi	r4,2317
 90a0804:	213daa04 	addi	r4,r4,-2392
 90a0808:	90836b80 	call	90836b8 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 90a080c:	e0bff417 	ldw	r2,-48(fp)
 90a0810:	10800783 	ldbu	r2,30(r2)
 90a0814:	10803fcc 	andi	r2,r2,255
 90a0818:	10800058 	cmpnei	r2,r2,1
 90a081c:	10000b1e 	bne	r2,zero,90a084c <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 90a0820:	e13ffe17 	ldw	r4,-8(fp)
 90a0824:	e0bff417 	ldw	r2,-48(fp)
 90a0828:	10800817 	ldw	r2,32(r2)
 90a082c:	100b883a 	mov	r5,r2
 90a0830:	00c243b4 	movhi	r3,2318
 90a0834:	18f4d504 	addi	r3,r3,-11436
 90a0838:	20801324 	muli	r2,r4,76
 90a083c:	10c5883a 	add	r2,r2,r3
 90a0840:	10800f04 	addi	r2,r2,60
 90a0844:	11400015 	stw	r5,0(r2)
 90a0848:	00001306 	br	90a0898 <tse_mac_init+0xd0>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 90a084c:	01002804 	movi	r4,160
 90a0850:	90baa240 	call	90baa24 <alt_uncached_malloc>
 90a0854:	e0bff315 	stw	r2,-52(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 90a0858:	00000306 	br	90a0868 <tse_mac_init+0xa0>
        {
            temp_desc++;
 90a085c:	e0bff317 	ldw	r2,-52(fp)
 90a0860:	10800044 	addi	r2,r2,1
 90a0864:	e0bff315 	stw	r2,-52(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 90a0868:	e0bff317 	ldw	r2,-52(fp)
 90a086c:	108007cc 	andi	r2,r2,31
 90a0870:	1004c03a 	cmpne	r2,r2,zero
 90a0874:	103ff91e 	bne	r2,zero,90a085c <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 90a0878:	e0bffe17 	ldw	r2,-8(fp)
 90a087c:	e13ff317 	ldw	r4,-52(fp)
 90a0880:	00c243b4 	movhi	r3,2318
 90a0884:	18f4d504 	addi	r3,r3,-11436
 90a0888:	10801324 	muli	r2,r2,76
 90a088c:	10c5883a 	add	r2,r2,r3
 90a0890:	10800f04 	addi	r2,r2,60
 90a0894:	11000015 	stw	r4,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 90a0898:	e0bff417 	ldw	r2,-48(fp)
 90a089c:	11000517 	ldw	r4,20(r2)
 90a08a0:	909a83c0 	call	909a83c <alt_avalon_sgdma_open>
 90a08a4:	e0bff615 	stw	r2,-40(fp)
   
   if(!sgdma_tx_dev) {
 90a08a8:	e0bff617 	ldw	r2,-40(fp)
 90a08ac:	1004c03a 	cmpne	r2,r2,zero
 90a08b0:	1000061e 	bne	r2,zero,90a08cc <tse_mac_init+0x104>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 90a08b4:	01024374 	movhi	r4,2317
 90a08b8:	213dae04 	addi	r4,r4,-2376
 90a08bc:	90836b80 	call	90836b8 <puts>
      return ENP_RESOURCE;
 90a08c0:	00bffa84 	movi	r2,-22
 90a08c4:	e0bfff15 	stw	r2,-4(fp)
 90a08c8:	00027306 	br	90a1298 <tse_mac_init+0xad0>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 90a08cc:	e0bff417 	ldw	r2,-48(fp)
 90a08d0:	11000617 	ldw	r4,24(r2)
 90a08d4:	909a83c0 	call	909a83c <alt_avalon_sgdma_open>
 90a08d8:	e0bff515 	stw	r2,-44(fp)
   if(!sgdma_rx_dev) {
 90a08dc:	e0bff517 	ldw	r2,-44(fp)
 90a08e0:	1004c03a 	cmpne	r2,r2,zero
 90a08e4:	1000061e 	bne	r2,zero,90a0900 <tse_mac_init+0x138>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 90a08e8:	01024374 	movhi	r4,2317
 90a08ec:	213dba04 	addi	r4,r4,-2328
 90a08f0:	90836b80 	call	90836b8 <puts>
      return ENP_RESOURCE;
 90a08f4:	00bffa84 	movi	r2,-22
 90a08f8:	e0bfff15 	stw	r2,-4(fp)
 90a08fc:	00026606 	br	90a1298 <tse_mac_init+0xad0>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 90a0900:	e0bffe17 	ldw	r2,-8(fp)
 90a0904:	10801324 	muli	r2,r2,76
 90a0908:	10c00104 	addi	r3,r2,4
 90a090c:	008243b4 	movhi	r2,2318
 90a0910:	10b4d504 	addi	r2,r2,-11436
 90a0914:	1889883a 	add	r4,r3,r2
 90a0918:	e0bff417 	ldw	r2,-48(fp)
 90a091c:	11400017 	ldw	r5,0(r2)
 90a0920:	e0bff617 	ldw	r2,-40(fp)
 90a0924:	100d883a 	mov	r6,r2
 90a0928:	e0bff517 	ldw	r2,-44(fp)
 90a092c:	100f883a 	mov	r7,r2
 90a0930:	d8000015 	stw	zero,0(sp)
 90a0934:	909b0d40 	call	909b0d4 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 90a0938:	e0bffe17 	ldw	r2,-8(fp)
 90a093c:	00c243b4 	movhi	r3,2318
 90a0940:	18f4d504 	addi	r3,r3,-11436
 90a0944:	10801324 	muli	r2,r2,76
 90a0948:	10c5883a 	add	r2,r2,r3
 90a094c:	10800304 	addi	r2,r2,12
 90a0950:	10800017 	ldw	r2,0(r2)
 90a0954:	10800317 	ldw	r2,12(r2)
 90a0958:	10800404 	addi	r2,r2,16
 90a095c:	1007883a 	mov	r3,r2
 90a0960:	00800074 	movhi	r2,1
 90a0964:	18800035 	stwio	r2,0(r3)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 90a0968:	e0bffe17 	ldw	r2,-8(fp)
 90a096c:	00c243b4 	movhi	r3,2318
 90a0970:	18f4d504 	addi	r3,r3,-11436
 90a0974:	10801324 	muli	r2,r2,76
 90a0978:	10c5883a 	add	r2,r2,r3
 90a097c:	10800304 	addi	r2,r2,12
 90a0980:	10800017 	ldw	r2,0(r2)
 90a0984:	10800317 	ldw	r2,12(r2)
 90a0988:	10800404 	addi	r2,r2,16
 90a098c:	10000035 	stwio	zero,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 90a0990:	e13ffe17 	ldw	r4,-8(fp)
 90a0994:	e0bff417 	ldw	r2,-48(fp)
 90a0998:	1080070b 	ldhu	r2,28(r2)
 90a099c:	117fffcc 	andi	r5,r2,65535
 90a09a0:	00c243b4 	movhi	r3,2318
 90a09a4:	18f4d504 	addi	r3,r3,-11436
 90a09a8:	20801324 	muli	r2,r4,76
 90a09ac:	10c5883a 	add	r2,r2,r3
 90a09b0:	10800904 	addi	r2,r2,36
 90a09b4:	11400015 	stw	r5,0(r2)
   ifp = tse[iface].netp;
 90a09b8:	e0bffe17 	ldw	r2,-8(fp)
 90a09bc:	00c243b4 	movhi	r3,2318
 90a09c0:	18f4d504 	addi	r3,r3,-11436
 90a09c4:	10801324 	muli	r2,r2,76
 90a09c8:	10c5883a 	add	r2,r2,r3
 90a09cc:	10800804 	addi	r2,r2,32
 90a09d0:	10800017 	ldw	r2,0(r2)
 90a09d4:	e0bff715 	stw	r2,-36(fp)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 90a09d8:	e0bffe17 	ldw	r2,-8(fp)
 90a09dc:	00c243b4 	movhi	r3,2318
 90a09e0:	18f4d504 	addi	r3,r3,-11436
 90a09e4:	10801324 	muli	r2,r2,76
 90a09e8:	10c5883a 	add	r2,r2,r3
 90a09ec:	10800104 	addi	r2,r2,4
 90a09f0:	11000017 	ldw	r4,0(r2)
 90a09f4:	909c5e00 	call	909c5e0 <getPHYSpeed>
 90a09f8:	e0bffa15 	stw	r2,-24(fp)
   speed = (result >> 1) & 0x07;
 90a09fc:	e0bffa17 	ldw	r2,-24(fp)
 90a0a00:	1005d07a 	srai	r2,r2,1
 90a0a04:	108001cc 	andi	r2,r2,7
 90a0a08:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
 90a0a0c:	e0bffa17 	ldw	r2,-24(fp)
 90a0a10:	1080004c 	andi	r2,r2,1
 90a0a14:	e0bffb15 	stw	r2,-20(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 90a0a18:	e0bffe17 	ldw	r2,-8(fp)
 90a0a1c:	00c243b4 	movhi	r3,2318
 90a0a20:	18f4d504 	addi	r3,r3,-11436
 90a0a24:	10801324 	muli	r2,r2,76
 90a0a28:	10c5883a 	add	r2,r2,r3
 90a0a2c:	10800104 	addi	r2,r2,4
 90a0a30:	10800017 	ldw	r2,0(r2)
 90a0a34:	10800204 	addi	r2,r2,8
 90a0a38:	1007883a 	mov	r3,r2
 90a0a3c:	008800c4 	movi	r2,8195
 90a0a40:	18800035 	stwio	r2,0(r3)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 90a0a44:	e03ff915 	stw	zero,-28(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 90a0a48:	00000906 	br	90a0a70 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 90a0a4c:	e0bff917 	ldw	r2,-28(fp)
 90a0a50:	1089c448 	cmpgei	r2,r2,10001
 90a0a54:	1007883a 	mov	r3,r2
 90a0a58:	e0bff917 	ldw	r2,-28(fp)
 90a0a5c:	10800044 	addi	r2,r2,1
 90a0a60:	e0bff915 	stw	r2,-28(fp)
 90a0a64:	18803fcc 	andi	r2,r3,255
 90a0a68:	1004c03a 	cmpne	r2,r2,zero
 90a0a6c:	10000c1e 	bne	r2,zero,90a0aa0 <tse_mac_init+0x2d8>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 90a0a70:	e0bffe17 	ldw	r2,-8(fp)
 90a0a74:	00c243b4 	movhi	r3,2318
 90a0a78:	18f4d504 	addi	r3,r3,-11436
 90a0a7c:	10801324 	muli	r2,r2,76
 90a0a80:	10c5883a 	add	r2,r2,r3
 90a0a84:	10800104 	addi	r2,r2,4
 90a0a88:	10800017 	ldw	r2,0(r2)
 90a0a8c:	10800204 	addi	r2,r2,8
 90a0a90:	10800037 	ldwio	r2,0(r2)
 90a0a94:	1088000c 	andi	r2,r2,8192
 90a0a98:	1004c03a 	cmpne	r2,r2,zero
 90a0a9c:	103feb1e 	bne	r2,zero,90a0a4c <tse_mac_init+0x284>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
     }
   }
   if(x >= 10000) {
 90a0aa0:	e0bff917 	ldw	r2,-28(fp)
 90a0aa4:	1089c410 	cmplti	r2,r2,10000
 90a0aa8:	1000031e 	bne	r2,zero,90a0ab8 <tse_mac_init+0x2f0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 90a0aac:	01024374 	movhi	r4,2317
 90a0ab0:	213dc604 	addi	r4,r4,-2280
 90a0ab4:	90836b80 	call	90836b8 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 90a0ab8:	e0bffe17 	ldw	r2,-8(fp)
 90a0abc:	00c243b4 	movhi	r3,2318
 90a0ac0:	18f4d504 	addi	r3,r3,-11436
 90a0ac4:	10801324 	muli	r2,r2,76
 90a0ac8:	10c5883a 	add	r2,r2,r3
 90a0acc:	10800104 	addi	r2,r2,4
 90a0ad0:	10800017 	ldw	r2,0(r2)
 90a0ad4:	10800204 	addi	r2,r2,8
 90a0ad8:	10800037 	ldwio	r2,0(r2)
 90a0adc:	e0bffd15 	stw	r2,-12(fp)
   if( (dat & 0x03) != 0 ) {
 90a0ae0:	e0bffd17 	ldw	r2,-12(fp)
 90a0ae4:	108000cc 	andi	r2,r2,3
 90a0ae8:	1005003a 	cmpeq	r2,r2,zero
 90a0aec:	1000051e 	bne	r2,zero,90a0b04 <tse_mac_init+0x33c>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 90a0af0:	01024374 	movhi	r4,2317
 90a0af4:	213dcf04 	addi	r4,r4,-2244
 90a0af8:	e17ffd17 	ldw	r5,-12(fp)
 90a0afc:	90833900 	call	9083390 <printf>
 90a0b00:	00000506 	br	90a0b18 <tse_mac_init+0x350>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 90a0b04:	01024374 	movhi	r4,2317
 90a0b08:	213de304 	addi	r4,r4,-2164
 90a0b0c:	e17ff917 	ldw	r5,-28(fp)
 90a0b10:	e1bffd17 	ldw	r6,-12(fp)
 90a0b14:	90833900 	call	9083390 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 90a0b18:	e0bff417 	ldw	r2,-48(fp)
 90a0b1c:	10800903 	ldbu	r2,36(r2)
 90a0b20:	10803fcc 	andi	r2,r2,255
 90a0b24:	10800058 	cmpnei	r2,r2,1
 90a0b28:	1000351e 	bne	r2,zero,90a0c00 <tse_mac_init+0x438>
      int channel_loop = 0;
 90a0b2c:	e03ff215 	stw	zero,-56(fp)
      int mac_loop = 0;
 90a0b30:	e03ff115 	stw	zero,-60(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 90a0b34:	e03ff215 	stw	zero,-56(fp)
 90a0b38:	00002b06 	br	90a0be8 <tse_mac_init+0x420>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 90a0b3c:	e03ff115 	stw	zero,-60(fp)
 90a0b40:	00001b06 	br	90a0bb0 <tse_mac_init+0x3e8>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 90a0b44:	e0bff217 	ldw	r2,-56(fp)
 90a0b48:	00c243b4 	movhi	r3,2318
 90a0b4c:	18f4c104 	addi	r3,r3,-11516
 90a0b50:	1085883a 	add	r2,r2,r2
 90a0b54:	1085883a 	add	r2,r2,r2
 90a0b58:	10c5883a 	add	r2,r2,r3
 90a0b5c:	10c00017 	ldw	r3,0(r2)
 90a0b60:	e0bff117 	ldw	r2,-60(fp)
 90a0b64:	1085883a 	add	r2,r2,r2
 90a0b68:	1085883a 	add	r2,r2,r2
 90a0b6c:	10c5883a 	add	r2,r2,r3
 90a0b70:	10800104 	addi	r2,r2,4
 90a0b74:	10800017 	ldw	r2,0(r2)
 90a0b78:	10c00217 	ldw	r3,8(r2)
 90a0b7c:	e0bff417 	ldw	r2,-48(fp)
 90a0b80:	1880081e 	bne	r3,r2,90a0ba4 <tse_mac_init+0x3dc>
            tse[iface].channel = mac_loop;
 90a0b84:	e0bffe17 	ldw	r2,-8(fp)
 90a0b88:	00c243b4 	movhi	r3,2318
 90a0b8c:	18f4d504 	addi	r3,r3,-11436
 90a0b90:	10801324 	muli	r2,r2,76
 90a0b94:	10c5883a 	add	r2,r2,r3
 90a0b98:	10c00d04 	addi	r3,r2,52
 90a0b9c:	e0bff117 	ldw	r2,-60(fp)
 90a0ba0:	18800015 	stw	r2,0(r3)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 90a0ba4:	e0bff117 	ldw	r2,-60(fp)
 90a0ba8:	10800044 	addi	r2,r2,1
 90a0bac:	e0bff115 	stw	r2,-60(fp)
 90a0bb0:	e0bff217 	ldw	r2,-56(fp)
 90a0bb4:	00c243b4 	movhi	r3,2318
 90a0bb8:	18f4c104 	addi	r3,r3,-11516
 90a0bbc:	1085883a 	add	r2,r2,r2
 90a0bc0:	1085883a 	add	r2,r2,r2
 90a0bc4:	10c5883a 	add	r2,r2,r3
 90a0bc8:	10800017 	ldw	r2,0(r2)
 90a0bcc:	10800003 	ldbu	r2,0(r2)
 90a0bd0:	10c03fcc 	andi	r3,r2,255
 90a0bd4:	e0bff117 	ldw	r2,-60(fp)
 90a0bd8:	10ffda16 	blt	r2,r3,90a0b44 <tse_mac_init+0x37c>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 90a0bdc:	e0bff217 	ldw	r2,-56(fp)
 90a0be0:	10800044 	addi	r2,r2,1
 90a0be4:	e0bff215 	stw	r2,-56(fp)
 90a0be8:	00824374 	movhi	r2,2317
 90a0bec:	108f0544 	addi	r2,r2,15381
 90a0bf0:	10800003 	ldbu	r2,0(r2)
 90a0bf4:	10c03fcc 	andi	r3,r2,255
 90a0bf8:	e0bff217 	ldw	r2,-56(fp)
 90a0bfc:	10ffcf16 	blt	r2,r3,90a0b3c <tse_mac_init+0x374>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 90a0c00:	e0bff417 	ldw	r2,-48(fp)
 90a0c04:	10800903 	ldbu	r2,36(r2)
 90a0c08:	10803fcc 	andi	r2,r2,255
 90a0c0c:	10800058 	cmpnei	r2,r2,1
 90a0c10:	1000121e 	bne	r2,zero,90a0c5c <tse_mac_init+0x494>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 90a0c14:	e0bff417 	ldw	r2,-48(fp)
 90a0c18:	10800d17 	ldw	r2,52(r2)
 90a0c1c:	1009883a 	mov	r4,r2
 90a0c20:	e0bff417 	ldw	r2,-48(fp)
 90a0c24:	10800f17 	ldw	r2,60(r2)
 90a0c28:	1007883a 	mov	r3,r2
 90a0c2c:	2005883a 	mov	r2,r4
 90a0c30:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 90a0c34:	e0bff417 	ldw	r2,-48(fp)
 90a0c38:	10800d17 	ldw	r2,52(r2)
 90a0c3c:	11000204 	addi	r4,r2,8
 90a0c40:	e0bff417 	ldw	r2,-48(fp)
 90a0c44:	10800f17 	ldw	r2,60(r2)
 90a0c48:	10bfdd04 	addi	r2,r2,-140
 90a0c4c:	1007883a 	mov	r3,r2
 90a0c50:	2005883a 	mov	r2,r4
 90a0c54:	10c00035 	stwio	r3,0(r2)
 90a0c58:	00006506 	br	90a0df0 <tse_mac_init+0x628>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 90a0c5c:	e0bffe17 	ldw	r2,-8(fp)
 90a0c60:	00c243b4 	movhi	r3,2318
 90a0c64:	18f4d504 	addi	r3,r3,-11436
 90a0c68:	10801324 	muli	r2,r2,76
 90a0c6c:	10c5883a 	add	r2,r2,r3
 90a0c70:	10800104 	addi	r2,r2,4
 90a0c74:	10800017 	ldw	r2,0(r2)
 90a0c78:	10800504 	addi	r2,r2,20
 90a0c7c:	1007883a 	mov	r3,r2
 90a0c80:	00817b84 	movi	r2,1518
 90a0c84:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 90a0c88:	e0bffe17 	ldw	r2,-8(fp)
 90a0c8c:	00c243b4 	movhi	r3,2318
 90a0c90:	18f4d504 	addi	r3,r3,-11436
 90a0c94:	10801324 	muli	r2,r2,76
 90a0c98:	10c5883a 	add	r2,r2,r3
 90a0c9c:	10800104 	addi	r2,r2,4
 90a0ca0:	10800017 	ldw	r2,0(r2)
 90a0ca4:	10800b04 	addi	r2,r2,44
 90a0ca8:	1007883a 	mov	r3,r2
 90a0cac:	00800204 	movi	r2,8
 90a0cb0:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 90a0cb4:	e0bffe17 	ldw	r2,-8(fp)
 90a0cb8:	00c243b4 	movhi	r3,2318
 90a0cbc:	18f4d504 	addi	r3,r3,-11436
 90a0cc0:	10801324 	muli	r2,r2,76
 90a0cc4:	10c5883a 	add	r2,r2,r3
 90a0cc8:	10800104 	addi	r2,r2,4
 90a0ccc:	10800017 	ldw	r2,0(r2)
 90a0cd0:	10800c04 	addi	r2,r2,48
 90a0cd4:	1007883a 	mov	r3,r2
 90a0cd8:	00800204 	movi	r2,8
 90a0cdc:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 90a0ce0:	e0bffe17 	ldw	r2,-8(fp)
 90a0ce4:	00c243b4 	movhi	r3,2318
 90a0ce8:	18f4d504 	addi	r3,r3,-11436
 90a0cec:	10801324 	muli	r2,r2,76
 90a0cf0:	10c5883a 	add	r2,r2,r3
 90a0cf4:	10800104 	addi	r2,r2,4
 90a0cf8:	10800017 	ldw	r2,0(r2)
 90a0cfc:	10800d04 	addi	r2,r2,52
 90a0d00:	1007883a 	mov	r3,r2
 90a0d04:	00800204 	movi	r2,8
 90a0d08:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 90a0d0c:	e0bffe17 	ldw	r2,-8(fp)
 90a0d10:	00c243b4 	movhi	r3,2318
 90a0d14:	18f4d504 	addi	r3,r3,-11436
 90a0d18:	10801324 	muli	r2,r2,76
 90a0d1c:	10c5883a 	add	r2,r2,r3
 90a0d20:	10800104 	addi	r2,r2,4
 90a0d24:	10800017 	ldw	r2,0(r2)
 90a0d28:	10800e04 	addi	r2,r2,56
 90a0d2c:	1007883a 	mov	r3,r2
 90a0d30:	008000c4 	movi	r2,3
 90a0d34:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 90a0d38:	e0bffe17 	ldw	r2,-8(fp)
 90a0d3c:	00c243b4 	movhi	r3,2318
 90a0d40:	18f4d504 	addi	r3,r3,-11436
 90a0d44:	10801324 	muli	r2,r2,76
 90a0d48:	10c5883a 	add	r2,r2,r3
 90a0d4c:	10800104 	addi	r2,r2,4
 90a0d50:	10800017 	ldw	r2,0(r2)
 90a0d54:	11000904 	addi	r4,r2,36
 90a0d58:	e0bff417 	ldw	r2,-48(fp)
 90a0d5c:	1080010b 	ldhu	r2,4(r2)
 90a0d60:	10bfffcc 	andi	r2,r2,65535
 90a0d64:	10fffc04 	addi	r3,r2,-16
 90a0d68:	2005883a 	mov	r2,r4
 90a0d6c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 90a0d70:	e0bffe17 	ldw	r2,-8(fp)
 90a0d74:	00c243b4 	movhi	r3,2318
 90a0d78:	18f4d504 	addi	r3,r3,-11436
 90a0d7c:	10801324 	muli	r2,r2,76
 90a0d80:	10c5883a 	add	r2,r2,r3
 90a0d84:	10800104 	addi	r2,r2,4
 90a0d88:	10800017 	ldw	r2,0(r2)
 90a0d8c:	10800a04 	addi	r2,r2,40
 90a0d90:	10000035 	stwio	zero,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 90a0d94:	e0bffe17 	ldw	r2,-8(fp)
 90a0d98:	00c243b4 	movhi	r3,2318
 90a0d9c:	18f4d504 	addi	r3,r3,-11436
 90a0da0:	10801324 	muli	r2,r2,76
 90a0da4:	10c5883a 	add	r2,r2,r3
 90a0da8:	10800104 	addi	r2,r2,4
 90a0dac:	10800017 	ldw	r2,0(r2)
 90a0db0:	11000704 	addi	r4,r2,28
 90a0db4:	e0bff417 	ldw	r2,-48(fp)
 90a0db8:	1080018b 	ldhu	r2,6(r2)
 90a0dbc:	10bfffcc 	andi	r2,r2,65535
 90a0dc0:	10fffc04 	addi	r3,r2,-16
 90a0dc4:	2005883a 	mov	r2,r4
 90a0dc8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 90a0dcc:	e0bffe17 	ldw	r2,-8(fp)
 90a0dd0:	00c243b4 	movhi	r3,2318
 90a0dd4:	18f4d504 	addi	r3,r3,-11436
 90a0dd8:	10801324 	muli	r2,r2,76
 90a0ddc:	10c5883a 	add	r2,r2,r3
 90a0de0:	10800104 	addi	r2,r2,4
 90a0de4:	10800017 	ldw	r2,0(r2)
 90a0de8:	10800804 	addi	r2,r2,32
 90a0dec:	10000035 	stwio	zero,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 90a0df0:	e0bffe17 	ldw	r2,-8(fp)
 90a0df4:	00c243b4 	movhi	r3,2318
 90a0df8:	18f4d504 	addi	r3,r3,-11436
 90a0dfc:	10801324 	muli	r2,r2,76
 90a0e00:	10c5883a 	add	r2,r2,r3
 90a0e04:	10800104 	addi	r2,r2,4
 90a0e08:	10800017 	ldw	r2,0(r2)
 90a0e0c:	10803a04 	addi	r2,r2,232
 90a0e10:	1007883a 	mov	r3,r2
 90a0e14:	00800134 	movhi	r2,4
 90a0e18:	18800035 	stwio	r2,0(r3)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 90a0e1c:	e0bffe17 	ldw	r2,-8(fp)
 90a0e20:	00c243b4 	movhi	r3,2318
 90a0e24:	18f4d504 	addi	r3,r3,-11436
 90a0e28:	10801324 	muli	r2,r2,76
 90a0e2c:	10c5883a 	add	r2,r2,r3
 90a0e30:	10800104 	addi	r2,r2,4
 90a0e34:	10800017 	ldw	r2,0(r2)
 90a0e38:	10803a04 	addi	r2,r2,232
 90a0e3c:	10800037 	ldwio	r2,0(r2)
 90a0e40:	1080012c 	andhi	r2,r2,4
 90a0e44:	1005003a 	cmpeq	r2,r2,zero
 90a0e48:	1000201e 	bne	r2,zero,90a0ecc <tse_mac_init+0x704>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 90a0e4c:	e0bffe17 	ldw	r2,-8(fp)
 90a0e50:	00c243b4 	movhi	r3,2318
 90a0e54:	18f4d504 	addi	r3,r3,-11436
 90a0e58:	10801324 	muli	r2,r2,76
 90a0e5c:	10c5883a 	add	r2,r2,r3
 90a0e60:	10c00a04 	addi	r3,r2,40
 90a0e64:	00800044 	movi	r2,1
 90a0e68:	18800015 	stw	r2,0(r3)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 90a0e6c:	e0bffe17 	ldw	r2,-8(fp)
 90a0e70:	00c243b4 	movhi	r3,2318
 90a0e74:	18f4d504 	addi	r3,r3,-11436
 90a0e78:	10801324 	muli	r2,r2,76
 90a0e7c:	10c5883a 	add	r2,r2,r3
 90a0e80:	10800104 	addi	r2,r2,4
 90a0e84:	10800017 	ldw	r2,0(r2)
 90a0e88:	10803b04 	addi	r2,r2,236
 90a0e8c:	1007883a 	mov	r3,r2
 90a0e90:	00808034 	movhi	r2,512
 90a0e94:	18800035 	stwio	r2,0(r3)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 90a0e98:	e0bffe17 	ldw	r2,-8(fp)
 90a0e9c:	00c243b4 	movhi	r3,2318
 90a0ea0:	18f4d504 	addi	r3,r3,-11436
 90a0ea4:	10801324 	muli	r2,r2,76
 90a0ea8:	10c5883a 	add	r2,r2,r3
 90a0eac:	10800104 	addi	r2,r2,4
 90a0eb0:	10800017 	ldw	r2,0(r2)
 90a0eb4:	10803b04 	addi	r2,r2,236
 90a0eb8:	10800037 	ldwio	r2,0(r2)
 90a0ebc:	1080802c 	andhi	r2,r2,512
 90a0ec0:	1004c03a 	cmpne	r2,r2,zero
 90a0ec4:	10000f1e 	bne	r2,zero,90a0f04 <tse_mac_init+0x73c>
 90a0ec8:	00001d06 	br	90a0f40 <tse_mac_init+0x778>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 90a0ecc:	e0bffe17 	ldw	r2,-8(fp)
 90a0ed0:	00c243b4 	movhi	r3,2318
 90a0ed4:	18f4d504 	addi	r3,r3,-11436
 90a0ed8:	10801324 	muli	r2,r2,76
 90a0edc:	10c5883a 	add	r2,r2,r3
 90a0ee0:	10800a04 	addi	r2,r2,40
 90a0ee4:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 90a0ee8:	01024374 	movhi	r4,2317
 90a0eec:	213deb04 	addi	r4,r4,-2132
 90a0ef0:	01400084 	movi	r5,2
 90a0ef4:	90833900 	call	9083390 <printf>
      return ENP_LOGIC;
 90a0ef8:	00bffd44 	movi	r2,-11
 90a0efc:	e0bfff15 	stw	r2,-4(fp)
 90a0f00:	0000e506 	br	90a1298 <tse_mac_init+0xad0>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 90a0f04:	e0bffe17 	ldw	r2,-8(fp)
 90a0f08:	00c243b4 	movhi	r3,2318
 90a0f0c:	18f4d504 	addi	r3,r3,-11436
 90a0f10:	10801324 	muli	r2,r2,76
 90a0f14:	10c5883a 	add	r2,r2,r3
 90a0f18:	10c00b04 	addi	r3,r2,44
 90a0f1c:	00800044 	movi	r2,1
 90a0f20:	18800015 	stw	r2,0(r3)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 90a0f24:	00810034 	movhi	r2,1024
 90a0f28:	108080c4 	addi	r2,r2,515
 90a0f2c:	e0bffd15 	stw	r2,-12(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 90a0f30:	e0bffc17 	ldw	r2,-16(fp)
 90a0f34:	10800060 	cmpeqi	r2,r2,1
 90a0f38:	10000f1e 	bne	r2,zero,90a0f78 <tse_mac_init+0x7b0>
 90a0f3c:	00001706 	br	90a0f9c <tse_mac_init+0x7d4>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 90a0f40:	e0bffe17 	ldw	r2,-8(fp)
 90a0f44:	00c243b4 	movhi	r3,2318
 90a0f48:	18f4d504 	addi	r3,r3,-11436
 90a0f4c:	10801324 	muli	r2,r2,76
 90a0f50:	10c5883a 	add	r2,r2,r3
 90a0f54:	10800b04 	addi	r2,r2,44
 90a0f58:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 90a0f5c:	01024374 	movhi	r4,2317
 90a0f60:	213e0304 	addi	r4,r4,-2036
 90a0f64:	01400084 	movi	r5,2
 90a0f68:	90833900 	call	9083390 <printf>
      return ENP_LOGIC;
 90a0f6c:	00bffd44 	movi	r2,-11
 90a0f70:	e0bfff15 	stw	r2,-4(fp)
 90a0f74:	0000c806 	br	90a1298 <tse_mac_init+0xad0>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 90a0f78:	e0bffd17 	ldw	r2,-12(fp)
 90a0f7c:	10800214 	ori	r2,r2,8
 90a0f80:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 90a0f84:	e0fffd17 	ldw	r3,-12(fp)
 90a0f88:	00bf8034 	movhi	r2,65024
 90a0f8c:	10bfffc4 	addi	r2,r2,-1
 90a0f90:	1884703a 	and	r2,r3,r2
 90a0f94:	e0bffd15 	stw	r2,-12(fp)
 90a0f98:	00002106 	br	90a1020 <tse_mac_init+0x858>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 90a0f9c:	e0bffc17 	ldw	r2,-16(fp)
 90a0fa0:	10800098 	cmpnei	r2,r2,2
 90a0fa4:	10000a1e 	bne	r2,zero,90a0fd0 <tse_mac_init+0x808>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 90a0fa8:	e0fffd17 	ldw	r3,-12(fp)
 90a0fac:	00bffdc4 	movi	r2,-9
 90a0fb0:	1884703a 	and	r2,r3,r2
 90a0fb4:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 90a0fb8:	e0fffd17 	ldw	r3,-12(fp)
 90a0fbc:	00bf8034 	movhi	r2,65024
 90a0fc0:	10bfffc4 	addi	r2,r2,-1
 90a0fc4:	1884703a 	and	r2,r3,r2
 90a0fc8:	e0bffd15 	stw	r2,-12(fp)
 90a0fcc:	00001406 	br	90a1020 <tse_mac_init+0x858>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 90a0fd0:	e0bffc17 	ldw	r2,-16(fp)
 90a0fd4:	10800118 	cmpnei	r2,r2,4
 90a0fd8:	1000081e 	bne	r2,zero,90a0ffc <tse_mac_init+0x834>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 90a0fdc:	e0fffd17 	ldw	r3,-12(fp)
 90a0fe0:	00bffdc4 	movi	r2,-9
 90a0fe4:	1884703a 	and	r2,r3,r2
 90a0fe8:	e0bffd15 	stw	r2,-12(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 90a0fec:	e0bffd17 	ldw	r2,-12(fp)
 90a0ff0:	10808034 	orhi	r2,r2,512
 90a0ff4:	e0bffd15 	stw	r2,-12(fp)
 90a0ff8:	00000906 	br	90a1020 <tse_mac_init+0x858>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 90a0ffc:	e0fffd17 	ldw	r3,-12(fp)
 90a1000:	00bffdc4 	movi	r2,-9
 90a1004:	1884703a 	and	r2,r3,r2
 90a1008:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 90a100c:	e0fffd17 	ldw	r3,-12(fp)
 90a1010:	00bf8034 	movhi	r2,65024
 90a1014:	10bfffc4 	addi	r2,r2,-1
 90a1018:	1884703a 	and	r2,r3,r2
 90a101c:	e0bffd15 	stw	r2,-12(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 90a1020:	e0bffb17 	ldw	r2,-20(fp)
 90a1024:	1004c03a 	cmpne	r2,r2,zero
 90a1028:	1000041e 	bne	r2,zero,90a103c <tse_mac_init+0x874>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 90a102c:	e0bffd17 	ldw	r2,-12(fp)
 90a1030:	10810014 	ori	r2,r2,1024
 90a1034:	e0bffd15 	stw	r2,-12(fp)
 90a1038:	00000406 	br	90a104c <tse_mac_init+0x884>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 90a103c:	e0bffd17 	ldw	r2,-12(fp)
 90a1040:	00feffc4 	movi	r3,-1025
 90a1044:	10c4703a 	and	r2,r2,r3
 90a1048:	e0bffd15 	stw	r2,-12(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 90a104c:	e0bffe17 	ldw	r2,-8(fp)
 90a1050:	00c243b4 	movhi	r3,2318
 90a1054:	18f4d504 	addi	r3,r3,-11436
 90a1058:	10801324 	muli	r2,r2,76
 90a105c:	10c5883a 	add	r2,r2,r3
 90a1060:	10800104 	addi	r2,r2,4
 90a1064:	10800017 	ldw	r2,0(r2)
 90a1068:	10800204 	addi	r2,r2,8
 90a106c:	1007883a 	mov	r3,r2
 90a1070:	e0bffd17 	ldw	r2,-12(fp)
 90a1074:	18800035 	stwio	r2,0(r3)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 90a1078:	e0bffe17 	ldw	r2,-8(fp)
 90a107c:	00c243b4 	movhi	r3,2318
 90a1080:	18f4d504 	addi	r3,r3,-11436
 90a1084:	10801324 	muli	r2,r2,76
 90a1088:	10c5883a 	add	r2,r2,r3
 90a108c:	10800104 	addi	r2,r2,4
 90a1090:	10800017 	ldw	r2,0(r2)
 90a1094:	10800204 	addi	r2,r2,8
 90a1098:	11400037 	ldwio	r5,0(r2)
 90a109c:	01024374 	movhi	r4,2317
 90a10a0:	213e1b04 	addi	r4,r4,-1940
 90a10a4:	90833900 	call	9083390 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 90a10a8:	e0bffe17 	ldw	r2,-8(fp)
 90a10ac:	00c243b4 	movhi	r3,2318
 90a10b0:	18f4d504 	addi	r3,r3,-11436
 90a10b4:	10801324 	muli	r2,r2,76
 90a10b8:	10c5883a 	add	r2,r2,r3
 90a10bc:	10800104 	addi	r2,r2,4
 90a10c0:	10800017 	ldw	r2,0(r2)
 90a10c4:	11400304 	addi	r5,r2,12
 90a10c8:	e0bffe17 	ldw	r2,-8(fp)
 90a10cc:	00c243b4 	movhi	r3,2318
 90a10d0:	18f4d504 	addi	r3,r3,-11436
 90a10d4:	10801324 	muli	r2,r2,76
 90a10d8:	10c5883a 	add	r2,r2,r3
 90a10dc:	10800604 	addi	r2,r2,24
 90a10e0:	10800003 	ldbu	r2,0(r2)
 90a10e4:	11003fcc 	andi	r4,r2,255
 90a10e8:	e0bffe17 	ldw	r2,-8(fp)
 90a10ec:	00c243b4 	movhi	r3,2318
 90a10f0:	18f4d504 	addi	r3,r3,-11436
 90a10f4:	10801324 	muli	r2,r2,76
 90a10f8:	10c5883a 	add	r2,r2,r3
 90a10fc:	10800644 	addi	r2,r2,25
 90a1100:	10800003 	ldbu	r2,0(r2)
 90a1104:	10803fcc 	andi	r2,r2,255
 90a1108:	1004923a 	slli	r2,r2,8
 90a110c:	2088b03a 	or	r4,r4,r2
 90a1110:	e0bffe17 	ldw	r2,-8(fp)
 90a1114:	00c243b4 	movhi	r3,2318
 90a1118:	18f4d504 	addi	r3,r3,-11436
 90a111c:	10801324 	muli	r2,r2,76
 90a1120:	10c5883a 	add	r2,r2,r3
 90a1124:	10800684 	addi	r2,r2,26
 90a1128:	10800003 	ldbu	r2,0(r2)
 90a112c:	10803fcc 	andi	r2,r2,255
 90a1130:	1004943a 	slli	r2,r2,16
 90a1134:	2088b03a 	or	r4,r4,r2
 90a1138:	e0bffe17 	ldw	r2,-8(fp)
 90a113c:	00c243b4 	movhi	r3,2318
 90a1140:	18f4d504 	addi	r3,r3,-11436
 90a1144:	10801324 	muli	r2,r2,76
 90a1148:	10c5883a 	add	r2,r2,r3
 90a114c:	108006c4 	addi	r2,r2,27
 90a1150:	10800003 	ldbu	r2,0(r2)
 90a1154:	10803fcc 	andi	r2,r2,255
 90a1158:	1004963a 	slli	r2,r2,24
 90a115c:	2086b03a 	or	r3,r4,r2
 90a1160:	2805883a 	mov	r2,r5
 90a1164:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 90a1168:	e0bffe17 	ldw	r2,-8(fp)
 90a116c:	00c243b4 	movhi	r3,2318
 90a1170:	18f4d504 	addi	r3,r3,-11436
 90a1174:	10801324 	muli	r2,r2,76
 90a1178:	10c5883a 	add	r2,r2,r3
 90a117c:	10800104 	addi	r2,r2,4
 90a1180:	10800017 	ldw	r2,0(r2)
 90a1184:	11400404 	addi	r5,r2,16
 90a1188:	e0bffe17 	ldw	r2,-8(fp)
 90a118c:	00c243b4 	movhi	r3,2318
 90a1190:	18f4d504 	addi	r3,r3,-11436
 90a1194:	10801324 	muli	r2,r2,76
 90a1198:	10c5883a 	add	r2,r2,r3
 90a119c:	10800704 	addi	r2,r2,28
 90a11a0:	10800003 	ldbu	r2,0(r2)
 90a11a4:	11003fcc 	andi	r4,r2,255
 90a11a8:	e0bffe17 	ldw	r2,-8(fp)
 90a11ac:	00c243b4 	movhi	r3,2318
 90a11b0:	18f4d504 	addi	r3,r3,-11436
 90a11b4:	10801324 	muli	r2,r2,76
 90a11b8:	10c5883a 	add	r2,r2,r3
 90a11bc:	10800744 	addi	r2,r2,29
 90a11c0:	10800003 	ldbu	r2,0(r2)
 90a11c4:	10803fcc 	andi	r2,r2,255
 90a11c8:	1004923a 	slli	r2,r2,8
 90a11cc:	2084b03a 	or	r2,r4,r2
 90a11d0:	10ffffcc 	andi	r3,r2,65535
 90a11d4:	2805883a 	mov	r2,r5
 90a11d8:	10c00035 	stwio	r3,0(r2)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 90a11dc:	e0bffe17 	ldw	r2,-8(fp)
 90a11e0:	00c243b4 	movhi	r3,2318
 90a11e4:	18f5e604 	addi	r3,r3,-10344
 90a11e8:	1085883a 	add	r2,r2,r2
 90a11ec:	1085883a 	add	r2,r2,r2
 90a11f0:	10c5883a 	add	r2,r2,r3
 90a11f4:	10800017 	ldw	r2,0(r2)
 90a11f8:	10c02717 	ldw	r3,156(r2)
 90a11fc:	00800044 	movi	r2,1
 90a1200:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 90a1204:	e0bffe17 	ldw	r2,-8(fp)
 90a1208:	00c243b4 	movhi	r3,2318
 90a120c:	18f5e604 	addi	r3,r3,-10344
 90a1210:	1085883a 	add	r2,r2,r2
 90a1214:	1085883a 	add	r2,r2,r2
 90a1218:	10c5883a 	add	r2,r2,r3
 90a121c:	10800017 	ldw	r2,0(r2)
 90a1220:	10c02717 	ldw	r3,156(r2)
 90a1224:	00800044 	movi	r2,1
 90a1228:	18800715 	stw	r2,28(r3)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 90a122c:	e0bffe17 	ldw	r2,-8(fp)
 90a1230:	00c243b4 	movhi	r3,2318
 90a1234:	18f4d504 	addi	r3,r3,-11436
 90a1238:	10801324 	muli	r2,r2,76
 90a123c:	10c5883a 	add	r2,r2,r3
 90a1240:	10800304 	addi	r2,r2,12
 90a1244:	11000017 	ldw	r4,0(r2)
 90a1248:	e0bffe17 	ldw	r2,-8(fp)
 90a124c:	10801324 	muli	r2,r2,76
 90a1250:	1007883a 	mov	r3,r2
 90a1254:	008243b4 	movhi	r2,2318
 90a1258:	10b4d504 	addi	r2,r2,-11436
 90a125c:	188f883a 	add	r7,r3,r2
 90a1260:	014242b4 	movhi	r5,2314
 90a1264:	29456a04 	addi	r5,r5,5544
 90a1268:	01800604 	movi	r6,24
 90a126c:	909a6d00 	call	909a6d0 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 90a1270:	e0bffe17 	ldw	r2,-8(fp)
 90a1274:	10801324 	muli	r2,r2,76
 90a1278:	1007883a 	mov	r3,r2
 90a127c:	008243b4 	movhi	r2,2318
 90a1280:	10b4d504 	addi	r2,r2,-11436
 90a1284:	1889883a 	add	r4,r3,r2
 90a1288:	90a16500 	call	90a1650 <tse_sgdma_read_init>
 90a128c:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 90a1290:	e0bff817 	ldw	r2,-32(fp)
 90a1294:	e0bfff15 	stw	r2,-4(fp)
 90a1298:	e0bfff17 	ldw	r2,-4(fp)
}
 90a129c:	e037883a 	mov	sp,fp
 90a12a0:	dfc00117 	ldw	ra,4(sp)
 90a12a4:	df000017 	ldw	fp,0(sp)
 90a12a8:	dec00204 	addi	sp,sp,8
 90a12ac:	f800283a 	ret

090a12b0 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 90a12b0:	defe6304 	addi	sp,sp,-1652
 90a12b4:	dfc19c15 	stw	ra,1648(sp)
 90a12b8:	df019b15 	stw	fp,1644(sp)
 90a12bc:	df019b04 	addi	fp,sp,1644
 90a12c0:	e13ffc15 	stw	r4,-16(fp)
 90a12c4:	e17ffd15 	stw	r5,-12(fp)
 90a12c8:	e1bffe15 	stw	r6,-8(fp)
   int result,i,tx_length;
   unsigned len = data_bytes;
 90a12cc:	e0bffe17 	ldw	r2,-8(fp)
 90a12d0:	e0be7215 	stw	r2,-1592(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 90a12d4:	e0bffc17 	ldw	r2,-16(fp)
 90a12d8:	10802817 	ldw	r2,160(r2)
 90a12dc:	e0be7115 	stw	r2,-1596(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 90a12e0:	e0be7117 	ldw	r2,-1596(fp)
 90a12e4:	10801217 	ldw	r2,72(r2)
 90a12e8:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90a12ec:	0005303a 	rdctl	r2,status
 90a12f0:	e0be6c15 	stw	r2,-1616(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90a12f4:	e0fe6c17 	ldw	r3,-1616(fp)
 90a12f8:	00bfff84 	movi	r2,-2
 90a12fc:	1884703a 	and	r2,r3,r2
 90a1300:	1001703a 	wrctl	status,r2
  
  return context;
 90a1304:	e0be6c17 	ldw	r2,-1616(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 90a1308:	e0be6d15 	stw	r2,-1612(fp)
   mi = &tse_ptr->mi;
 90a130c:	e0be7117 	ldw	r2,-1596(fp)
 90a1310:	10800104 	addi	r2,r2,4
 90a1314:	e0be6f15 	stw	r2,-1604(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 90a1318:	e0be7117 	ldw	r2,-1596(fp)
 90a131c:	10800c17 	ldw	r2,48(r2)
 90a1320:	1005003a 	cmpeq	r2,r2,zero
 90a1324:	10000a1e 	bne	r2,zero,90a1350 <tse_mac_raw_send+0xa0>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 90a1328:	01024374 	movhi	r4,2317
 90a132c:	213e2704 	addi	r4,r4,-1892
 90a1330:	90836b80 	call	90836b8 <puts>
 90a1334:	e0be6d17 	ldw	r2,-1612(fp)
 90a1338:	e0be6b15 	stw	r2,-1620(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90a133c:	e0be6b17 	ldw	r2,-1620(fp)
 90a1340:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 90a1344:	00bffa84 	movi	r2,-22
 90a1348:	e0bfff15 	stw	r2,-4(fp)
 90a134c:	00009006 	br	90a1590 <tse_mac_raw_send+0x2e0>
   }
 
   tse_ptr->sem = 1;  
 90a1350:	e0fe7117 	ldw	r3,-1596(fp)
 90a1354:	00800044 	movi	r2,1
 90a1358:	18800c15 	stw	r2,48(r3)

   if(((unsigned long)data & 0x03) == 0) 
 90a135c:	e0bffd17 	ldw	r2,-12(fp)
 90a1360:	108000cc 	andi	r2,r2,3
 90a1364:	1004c03a 	cmpne	r2,r2,zero
 90a1368:	1000031e 	bne	r2,zero,90a1378 <tse_mac_raw_send+0xc8>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 90a136c:	e0bffd17 	ldw	r2,-12(fp)
 90a1370:	e0be6e15 	stw	r2,-1608(fp)
 90a1374:	00001406 	br	90a13c8 <tse_mac_raw_send+0x118>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 90a1378:	e03e7415 	stw	zero,-1584(fp)
 90a137c:	00000d06 	br	90a13b4 <tse_mac_raw_send+0x104>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 90a1380:	e13e7417 	ldw	r4,-1584(fp)
 90a1384:	e0be7417 	ldw	r2,-1584(fp)
 90a1388:	1007883a 	mov	r3,r2
 90a138c:	e0bffd17 	ldw	r2,-12(fp)
 90a1390:	1885883a 	add	r2,r3,r2
 90a1394:	10800023 	ldbuio	r2,0(r2)
 90a1398:	1007883a 	mov	r3,r2
 90a139c:	e0be7604 	addi	r2,fp,-1576
 90a13a0:	1105883a 	add	r2,r2,r4
 90a13a4:	10c00005 	stb	r3,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 90a13a8:	e0be7417 	ldw	r2,-1584(fp)
 90a13ac:	10800044 	addi	r2,r2,1
 90a13b0:	e0be7415 	stw	r2,-1584(fp)
 90a13b4:	e0fe7417 	ldw	r3,-1584(fp)
 90a13b8:	e0be7217 	ldw	r2,-1592(fp)
 90a13bc:	18bff036 	bltu	r3,r2,90a1380 <tse_mac_raw_send+0xd0>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 90a13c0:	e0be7604 	addi	r2,fp,-1576
 90a13c4:	e0be6e15 	stw	r2,-1608(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 90a13c8:	e13e6e17 	ldw	r4,-1608(fp)
 90a13cc:	01400104 	movi	r5,4
 90a13d0:	90ba8040 	call	90ba804 <alt_remap_cached>
 90a13d4:	e0be6e15 	stw	r2,-1608(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 90a13d8:	e0be7017 	ldw	r2,-1600(fp)
 90a13dc:	10800903 	ldbu	r2,36(r2)
 90a13e0:	10803fcc 	andi	r2,r2,255
 90a13e4:	10800058 	cmpnei	r2,r2,1
 90a13e8:	1000241e 	bne	r2,zero,90a147c <tse_mac_raw_send+0x1cc>
 90a13ec:	e0be7217 	ldw	r2,-1592(fp)
 90a13f0:	108003f0 	cmpltui	r2,r2,15
 90a13f4:	1000211e 	bne	r2,zero,90a147c <tse_mac_raw_send+0x1cc>
 90a13f8:	e0be7017 	ldw	r2,-1600(fp)
 90a13fc:	10800b17 	ldw	r2,44(r2)
 90a1400:	1007883a 	mov	r3,r2
 90a1404:	e0be7117 	ldw	r2,-1596(fp)
 90a1408:	10800d17 	ldw	r2,52(r2)
 90a140c:	1085883a 	add	r2,r2,r2
 90a1410:	1085883a 	add	r2,r2,r2
 90a1414:	1885883a 	add	r2,r3,r2
 90a1418:	10800037 	ldwio	r2,0(r2)
 90a141c:	10800388 	cmpgei	r2,r2,14
 90a1420:	1000161e 	bne	r2,zero,90a147c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 90a1424:	e0be7117 	ldw	r2,-1596(fp)
 90a1428:	11000f17 	ldw	r4,60(r2)
 90a142c:	e0be7117 	ldw	r2,-1596(fp)
 90a1430:	10800f17 	ldw	r2,60(r2)
 90a1434:	11400804 	addi	r5,r2,32
 90a1438:	e1be6e17 	ldw	r6,-1608(fp)
 90a143c:	e0be7217 	ldw	r2,-1592(fp)
 90a1440:	11ffffcc 	andi	r7,r2,65535
 90a1444:	d8000015 	stw	zero,0(sp)
 90a1448:	00800044 	movi	r2,1
 90a144c:	d8800115 	stw	r2,4(sp)
 90a1450:	00800044 	movi	r2,1
 90a1454:	d8800215 	stw	r2,8(sp)
 90a1458:	d8000315 	stw	zero,12(sp)
 90a145c:	909a5d80 	call	909a5d8 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 90a1460:	e0be7117 	ldw	r2,-1596(fp)
 90a1464:	11400f17 	ldw	r5,60(r2)
 90a1468:	e13e6f17 	ldw	r4,-1604(fp)
 90a146c:	909b1340 	call	909b134 <tse_mac_sTxWrite>
 90a1470:	e0be7315 	stw	r2,-1588(fp)
        result = 0;
 90a1474:	e03e7515 	stw	zero,-1580(fp)
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 90a1478:	00001b06 	br	90a14e8 <tse_mac_raw_send+0x238>
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 90a147c:	e0be7217 	ldw	r2,-1592(fp)
 90a1480:	108003f0 	cmpltui	r2,r2,15
 90a1484:	1000161e 	bne	r2,zero,90a14e0 <tse_mac_raw_send+0x230>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 90a1488:	e0be7117 	ldw	r2,-1596(fp)
 90a148c:	11000f17 	ldw	r4,60(r2)
 90a1490:	e0be7117 	ldw	r2,-1596(fp)
 90a1494:	10800f17 	ldw	r2,60(r2)
 90a1498:	11400804 	addi	r5,r2,32
 90a149c:	e1be6e17 	ldw	r6,-1608(fp)
 90a14a0:	e0be7217 	ldw	r2,-1592(fp)
 90a14a4:	11ffffcc 	andi	r7,r2,65535
 90a14a8:	d8000015 	stw	zero,0(sp)
 90a14ac:	00800044 	movi	r2,1
 90a14b0:	d8800115 	stw	r2,4(sp)
 90a14b4:	00800044 	movi	r2,1
 90a14b8:	d8800215 	stw	r2,8(sp)
 90a14bc:	d8000315 	stw	zero,12(sp)
 90a14c0:	909a5d80 	call	909a5d8 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 90a14c4:	e0be7117 	ldw	r2,-1596(fp)
 90a14c8:	11400f17 	ldw	r5,60(r2)
 90a14cc:	e13e6f17 	ldw	r4,-1604(fp)
 90a14d0:	909b1340 	call	909b134 <tse_mac_sTxWrite>
 90a14d4:	e0be7315 	stw	r2,-1588(fp)
       result = 0;
 90a14d8:	e03e7515 	stw	zero,-1580(fp)
 90a14dc:	00000206 	br	90a14e8 <tse_mac_raw_send+0x238>

   } else {
       result = -3;
 90a14e0:	00bfff44 	movi	r2,-3
 90a14e4:	e0be7515 	stw	r2,-1580(fp)
   }

   if(result < 0)   /* SGDMA not available */
 90a14e8:	e0be7517 	ldw	r2,-1580(fp)
 90a14ec:	1004403a 	cmpge	r2,r2,zero
 90a14f0:	1000131e 	bne	r2,zero,90a1540 <tse_mac_raw_send+0x290>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 90a14f4:	01024374 	movhi	r4,2317
 90a14f8:	213e2e04 	addi	r4,r4,-1864
 90a14fc:	e17e7517 	ldw	r5,-1580(fp)
 90a1500:	e1be7217 	ldw	r6,-1592(fp)
 90a1504:	90833900 	call	9083390 <printf>
      net->n_mib->ifOutDiscards++;
 90a1508:	e0bffc17 	ldw	r2,-16(fp)
 90a150c:	10c02717 	ldw	r3,156(r2)
 90a1510:	18801217 	ldw	r2,72(r3)
 90a1514:	10800044 	addi	r2,r2,1
 90a1518:	18801215 	stw	r2,72(r3)
      tse_ptr->sem = 0;
 90a151c:	e0be7117 	ldw	r2,-1596(fp)
 90a1520:	10000c15 	stw	zero,48(r2)
 90a1524:	e0be6d17 	ldw	r2,-1612(fp)
 90a1528:	e0be6a15 	stw	r2,-1624(fp)
 90a152c:	e0be6a17 	ldw	r2,-1624(fp)
 90a1530:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 90a1534:	00bffa84 	movi	r2,-22
 90a1538:	e0bfff15 	stw	r2,-4(fp)
 90a153c:	00001406 	br	90a1590 <tse_mac_raw_send+0x2e0>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 90a1540:	e0bffc17 	ldw	r2,-16(fp)
 90a1544:	11002717 	ldw	r4,156(r2)
 90a1548:	e0bffc17 	ldw	r2,-16(fp)
 90a154c:	10802717 	ldw	r2,156(r2)
 90a1550:	10c00f17 	ldw	r3,60(r2)
 90a1554:	e0bffe17 	ldw	r2,-8(fp)
 90a1558:	1885883a 	add	r2,r3,r2
 90a155c:	20800f15 	stw	r2,60(r4)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 90a1560:	e0bffc17 	ldw	r2,-16(fp)
 90a1564:	10c02717 	ldw	r3,156(r2)
 90a1568:	18801017 	ldw	r2,64(r3)
 90a156c:	10800044 	addi	r2,r2,1
 90a1570:	18801015 	stw	r2,64(r3)
      tse_ptr->sem = 0;
 90a1574:	e0be7117 	ldw	r2,-1596(fp)
 90a1578:	10000c15 	stw	zero,48(r2)
 90a157c:	e0be6d17 	ldw	r2,-1612(fp)
 90a1580:	e0be6915 	stw	r2,-1628(fp)
 90a1584:	e0be6917 	ldw	r2,-1628(fp)
 90a1588:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 90a158c:	e03fff15 	stw	zero,-4(fp)
 90a1590:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a1594:	e037883a 	mov	sp,fp
 90a1598:	dfc00117 	ldw	ra,4(sp)
 90a159c:	df000017 	ldw	fp,0(sp)
 90a15a0:	dec00204 	addi	sp,sp,8
 90a15a4:	f800283a 	ret

090a15a8 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 90a15a8:	defffa04 	addi	sp,sp,-24
 90a15ac:	dfc00515 	stw	ra,20(sp)
 90a15b0:	df000415 	stw	fp,16(sp)
 90a15b4:	df000404 	addi	fp,sp,16
 90a15b8:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 90a15bc:	e0bfff17 	ldw	r2,-4(fp)
 90a15c0:	e0bffe15 	stw	r2,-8(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 90a15c4:	008243b4 	movhi	r2,2318
 90a15c8:	10b52104 	addi	r2,r2,-11132
 90a15cc:	10800217 	ldw	r2,8(r2)
 90a15d0:	e0bffc15 	stw	r2,-16(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 90a15d4:	e0bffe17 	ldw	r2,-8(fp)
 90a15d8:	10800317 	ldw	r2,12(r2)
 90a15dc:	10800317 	ldw	r2,12(r2)
 90a15e0:	10800037 	ldwio	r2,0(r2)
 90a15e4:	e0bffd05 	stb	r2,-12(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 90a15e8:	e0bffd03 	ldbu	r2,-12(fp)
 90a15ec:	1080030c 	andi	r2,r2,12
 90a15f0:	1005003a 	cmpeq	r2,r2,zero
 90a15f4:	1000111e 	bne	r2,zero,90a163c <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 90a15f8:	e13ffe17 	ldw	r4,-8(fp)
 90a15fc:	90a17f80 	call	90a17f8 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 90a1600:	e0bffe17 	ldw	r2,-8(fp)
 90a1604:	11000317 	ldw	r4,12(r2)
 90a1608:	e0bffe17 	ldw	r2,-8(fp)
 90a160c:	10800f17 	ldw	r2,60(r2)
 90a1610:	11401004 	addi	r5,r2,64
 90a1614:	909a1c40 	call	909a1c4 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 90a1618:	008243b4 	movhi	r2,2318
 90a161c:	10b52104 	addi	r2,r2,-11132
 90a1620:	10c00217 	ldw	r3,8(r2)
 90a1624:	e0bffc17 	ldw	r2,-16(fp)
 90a1628:	10c0040e 	bge	r2,r3,90a163c <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 90a162c:	00824374 	movhi	r2,2317
 90a1630:	108f3104 	addi	r2,r2,15556
 90a1634:	11000017 	ldw	r4,0(r2)
 90a1638:	90940540 	call	9094054 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 90a163c:	e037883a 	mov	sp,fp
 90a1640:	dfc00117 	ldw	ra,4(sp)
 90a1644:	df000017 	ldw	fp,0(sp)
 90a1648:	dec00204 	addi	sp,sp,8
 90a164c:	f800283a 	ret

090a1650 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 90a1650:	defff904 	addi	sp,sp,-28
 90a1654:	dfc00615 	stw	ra,24(sp)
 90a1658:	df000515 	stw	fp,20(sp)
 90a165c:	dc000415 	stw	r16,16(sp)
 90a1660:	df000404 	addi	fp,sp,16
 90a1664:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 90a1668:	e0bffe17 	ldw	r2,-8(fp)
 90a166c:	10000e15 	stw	zero,56(r2)
 90a1670:	00004406 	br	90a1784 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 90a1674:	e0bffe17 	ldw	r2,-8(fp)
 90a1678:	14000e17 	ldw	r16,56(r2)
 90a167c:	01017f04 	movi	r4,1532
 90a1680:	90a98340 	call	90a9834 <pk_alloc>
 90a1684:	1009883a 	mov	r4,r2
 90a1688:	e0fffe17 	ldw	r3,-8(fp)
 90a168c:	8405883a 	add	r2,r16,r16
 90a1690:	1085883a 	add	r2,r2,r2
 90a1694:	10c5883a 	add	r2,r2,r3
 90a1698:	10801104 	addi	r2,r2,68
 90a169c:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 90a16a0:	e0bffe17 	ldw	r2,-8(fp)
 90a16a4:	10800e17 	ldw	r2,56(r2)
 90a16a8:	e0fffe17 	ldw	r3,-8(fp)
 90a16ac:	1085883a 	add	r2,r2,r2
 90a16b0:	1085883a 	add	r2,r2,r2
 90a16b4:	10c5883a 	add	r2,r2,r3
 90a16b8:	10801104 	addi	r2,r2,68
 90a16bc:	10800017 	ldw	r2,0(r2)
 90a16c0:	1004c03a 	cmpne	r2,r2,zero
 90a16c4:	10000c1e 	bne	r2,zero,90a16f8 <tse_sgdma_read_init+0xa8>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 90a16c8:	01024374 	movhi	r4,2317
 90a16cc:	213e3a04 	addi	r4,r4,-1816
 90a16d0:	90836b80 	call	90836b8 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 90a16d4:	e0bffe17 	ldw	r2,-8(fp)
 90a16d8:	10800817 	ldw	r2,32(r2)
 90a16dc:	10c02717 	ldw	r3,156(r2)
 90a16e0:	18800c17 	ldw	r2,48(r3)
 90a16e4:	10800044 	addi	r2,r2,1
 90a16e8:	18800c15 	stw	r2,48(r3)
      
      return ENP_NOBUFFER;
 90a16ec:	00bffac4 	movi	r2,-21
 90a16f0:	e0bfff15 	stw	r2,-4(fp)
 90a16f4:	00003906 	br	90a17dc <tse_sgdma_read_init+0x18c>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 90a16f8:	e0bffe17 	ldw	r2,-8(fp)
 90a16fc:	10800e17 	ldw	r2,56(r2)
 90a1700:	e0fffe17 	ldw	r3,-8(fp)
 90a1704:	1085883a 	add	r2,r2,r2
 90a1708:	1085883a 	add	r2,r2,r2
 90a170c:	10c5883a 	add	r2,r2,r3
 90a1710:	10801104 	addi	r2,r2,68
 90a1714:	10800017 	ldw	r2,0(r2)
 90a1718:	11000117 	ldw	r4,4(r2)
 90a171c:	01400104 	movi	r5,4
 90a1720:	90ba8040 	call	90ba804 <alt_remap_cached>
 90a1724:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 90a1728:	e0bffe17 	ldw	r2,-8(fp)
 90a172c:	10c00f17 	ldw	r3,60(r2)
 90a1730:	e0bffe17 	ldw	r2,-8(fp)
 90a1734:	10800e17 	ldw	r2,56(r2)
 90a1738:	1004917a 	slli	r2,r2,5
 90a173c:	1885883a 	add	r2,r3,r2
 90a1740:	11001004 	addi	r4,r2,64
 90a1744:	e0bffe17 	ldw	r2,-8(fp)
 90a1748:	10c00f17 	ldw	r3,60(r2)
 90a174c:	e0bffe17 	ldw	r2,-8(fp)
 90a1750:	10800e17 	ldw	r2,56(r2)
 90a1754:	1004917a 	slli	r2,r2,5
 90a1758:	1885883a 	add	r2,r3,r2
 90a175c:	11401804 	addi	r5,r2,96
 90a1760:	d8000015 	stw	zero,0(sp)
 90a1764:	e1bffd17 	ldw	r6,-12(fp)
 90a1768:	000f883a 	mov	r7,zero
 90a176c:	909a5140 	call	909a514 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 90a1770:	e0bffe17 	ldw	r2,-8(fp)
 90a1774:	10800e17 	ldw	r2,56(r2)
 90a1778:	10c00044 	addi	r3,r2,1
 90a177c:	e0bffe17 	ldw	r2,-8(fp)
 90a1780:	10c00e15 	stw	r3,56(r2)
 90a1784:	e0bffe17 	ldw	r2,-8(fp)
 90a1788:	10800e17 	ldw	r2,56(r2)
 90a178c:	10800050 	cmplti	r2,r2,1
 90a1790:	103fb81e 	bne	r2,zero,90a1674 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 90a1794:	e0bffe17 	ldw	r2,-8(fp)
 90a1798:	11400e17 	ldw	r5,56(r2)
 90a179c:	01024374 	movhi	r4,2317
 90a17a0:	213e4b04 	addi	r4,r4,-1748
 90a17a4:	90833900 	call	9083390 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 90a17a8:	e0bffe17 	ldw	r2,-8(fp)
 90a17ac:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 90a17b0:	e0bffe17 	ldw	r2,-8(fp)
 90a17b4:	10800f17 	ldw	r2,60(r2)
 90a17b8:	10c01004 	addi	r3,r2,64
 90a17bc:	e0bffe17 	ldw	r2,-8(fp)
 90a17c0:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 90a17c4:	e0bffe17 	ldw	r2,-8(fp)
 90a17c8:	11000104 	addi	r4,r2,4
 90a17cc:	e0bffe17 	ldw	r2,-8(fp)
 90a17d0:	11401017 	ldw	r5,64(r2)
 90a17d4:	909b2240 	call	909b224 <tse_mac_aRxRead>
  
  return SUCCESS;
 90a17d8:	e03fff15 	stw	zero,-4(fp)
 90a17dc:	e0bfff17 	ldw	r2,-4(fp)
}
 90a17e0:	e037883a 	mov	sp,fp
 90a17e4:	dfc00217 	ldw	ra,8(sp)
 90a17e8:	df000117 	ldw	fp,4(sp)
 90a17ec:	dc000017 	ldw	r16,0(sp)
 90a17f0:	dec00304 	addi	sp,sp,12
 90a17f4:	f800283a 	ret

090a17f8 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 90a17f8:	defff704 	addi	sp,sp,-36
 90a17fc:	dfc00815 	stw	ra,32(sp)
 90a1800:	df000715 	stw	fp,28(sp)
 90a1804:	df000704 	addi	fp,sp,28
 90a1808:	e13fff15 	stw	r4,-4(fp)
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 90a180c:	e0bfff17 	ldw	r2,-4(fp)
 90a1810:	10c00f17 	ldw	r3,60(r2)
 90a1814:	e0bfff17 	ldw	r2,-4(fp)
 90a1818:	10800e17 	ldw	r2,56(r2)
 90a181c:	1004917a 	slli	r2,r2,5
 90a1820:	1885883a 	add	r2,r3,r2
 90a1824:	10c01004 	addi	r3,r2,64
 90a1828:	e0bfff17 	ldw	r2,-4(fp)
 90a182c:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 90a1830:	e0bfff17 	ldw	r2,-4(fp)
 90a1834:	10801017 	ldw	r2,64(r2)
 90a1838:	10800704 	addi	r2,r2,28
 90a183c:	10800037 	ldwio	r2,0(r2)
 90a1840:	1005d43a 	srai	r2,r2,16
 90a1844:	1007883a 	mov	r3,r2
 90a1848:	00bfffc4 	movi	r2,-1
 90a184c:	1884703a 	and	r2,r3,r2
 90a1850:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 90a1854:	e0bfff17 	ldw	r2,-4(fp)
 90a1858:	10801017 	ldw	r2,64(r2)
 90a185c:	10800704 	addi	r2,r2,28
 90a1860:	1080002b 	ldhuio	r2,0(r2)
 90a1864:	10bfff84 	addi	r2,r2,-2
 90a1868:	e0bffd15 	stw	r2,-12(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 90a186c:	e0bfff17 	ldw	r2,-4(fp)
 90a1870:	10800817 	ldw	r2,32(r2)
 90a1874:	11002717 	ldw	r4,156(r2)
 90a1878:	e0bfff17 	ldw	r2,-4(fp)
 90a187c:	10800817 	ldw	r2,32(r2)
 90a1880:	10802717 	ldw	r2,156(r2)
 90a1884:	10c00917 	ldw	r3,36(r2)
 90a1888:	e0bffd17 	ldw	r2,-12(fp)
 90a188c:	1885883a 	add	r2,r3,r2
 90a1890:	20800915 	stw	r2,36(r4)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 90a1894:	e0bfff17 	ldw	r2,-4(fp)
 90a1898:	10800e17 	ldw	r2,56(r2)
 90a189c:	e0ffff17 	ldw	r3,-4(fp)
 90a18a0:	1085883a 	add	r2,r2,r2
 90a18a4:	1085883a 	add	r2,r2,r2
 90a18a8:	10c5883a 	add	r2,r2,r3
 90a18ac:	10801104 	addi	r2,r2,68
 90a18b0:	10800017 	ldw	r2,0(r2)
 90a18b4:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 90a18b8:	e0bffb17 	ldw	r2,-20(fp)
 90a18bc:	10800117 	ldw	r2,4(r2)
 90a18c0:	10c00404 	addi	r3,r2,16
 90a18c4:	e0bffb17 	ldw	r2,-20(fp)
 90a18c8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 90a18cc:	e0bffd17 	ldw	r2,-12(fp)
 90a18d0:	10bffc84 	addi	r2,r2,-14
 90a18d4:	1007883a 	mov	r3,r2
 90a18d8:	e0bffb17 	ldw	r2,-20(fp)
 90a18dc:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 90a18e0:	00824374 	movhi	r2,2317
 90a18e4:	108f2e04 	addi	r2,r2,15544
 90a18e8:	10800017 	ldw	r2,0(r2)
 90a18ec:	1007883a 	mov	r3,r2
 90a18f0:	e0bffb17 	ldw	r2,-20(fp)
 90a18f4:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 90a18f8:	e0bfff17 	ldw	r2,-4(fp)
 90a18fc:	10c00817 	ldw	r3,32(r2)
 90a1900:	e0bffb17 	ldw	r2,-20(fp)
 90a1904:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 90a1908:	e0bffb17 	ldw	r2,-20(fp)
 90a190c:	10800117 	ldw	r2,4(r2)
 90a1910:	10800084 	addi	r2,r2,2
 90a1914:	e0bffe15 	stw	r2,-8(fp)
    rx_packet->type = eth->e_type;
 90a1918:	e0bffe17 	ldw	r2,-8(fp)
 90a191c:	10c0030b 	ldhu	r3,12(r2)
 90a1920:	e0bffb17 	ldw	r2,-20(fp)
 90a1924:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 90a1928:	e0bff903 	ldbu	r2,-28(fp)
 90a192c:	10801fcc 	andi	r2,r2,127
 90a1930:	1004c03a 	cmpne	r2,r2,zero
 90a1934:	1000251e 	bne	r2,zero,90a19cc <tse_mac_rcv+0x1d4>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 90a1938:	01017f04 	movi	r4,1532
 90a193c:	90a98340 	call	90a9834 <pk_alloc>
 90a1940:	e0bffc15 	stw	r2,-16(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 90a1944:	e0bffc17 	ldw	r2,-16(fp)
 90a1948:	1004c03a 	cmpne	r2,r2,zero
 90a194c:	10000a1e 	bne	r2,zero,90a1978 <tse_mac_rcv+0x180>
        dprintf("No free buffers for rx\n");
 90a1950:	01024374 	movhi	r4,2317
 90a1954:	213e5c04 	addi	r4,r4,-1680
 90a1958:	90836b80 	call	90836b8 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 90a195c:	e0bfff17 	ldw	r2,-4(fp)
 90a1960:	10800817 	ldw	r2,32(r2)
 90a1964:	10c02717 	ldw	r3,156(r2)
 90a1968:	18800c17 	ldw	r2,48(r3)
 90a196c:	10800044 	addi	r2,r2,1
 90a1970:	18800c15 	stw	r2,48(r3)
 90a1974:	00001806 	br	90a19d8 <tse_mac_rcv+0x1e0>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 90a1978:	e0bfff17 	ldw	r2,-4(fp)
 90a197c:	10800e17 	ldw	r2,56(r2)
 90a1980:	e0ffff17 	ldw	r3,-4(fp)
 90a1984:	1085883a 	add	r2,r2,r2
 90a1988:	1085883a 	add	r2,r2,r2
 90a198c:	10c5883a 	add	r2,r2,r3
 90a1990:	10801104 	addi	r2,r2,68
 90a1994:	11400017 	ldw	r5,0(r2)
 90a1998:	010243b4 	movhi	r4,2318
 90a199c:	21352104 	addi	r4,r4,-11132
 90a19a0:	90a9e080 	call	90a9e08 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 90a19a4:	e0bfff17 	ldw	r2,-4(fp)
 90a19a8:	10800e17 	ldw	r2,56(r2)
 90a19ac:	e0ffff17 	ldw	r3,-4(fp)
 90a19b0:	1085883a 	add	r2,r2,r2
 90a19b4:	1085883a 	add	r2,r2,r2
 90a19b8:	10c5883a 	add	r2,r2,r3
 90a19bc:	10c01104 	addi	r3,r2,68
 90a19c0:	e0bffc17 	ldw	r2,-16(fp)
 90a19c4:	18800015 	stw	r2,0(r3)
 90a19c8:	00000306 	br	90a19d8 <tse_mac_rcv+0x1e0>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 90a19cc:	01024374 	movhi	r4,2317
 90a19d0:	213e6204 	addi	r4,r4,-1656
 90a19d4:	90836b80 	call	90836b8 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 90a19d8:	e0bfff17 	ldw	r2,-4(fp)
 90a19dc:	10800e17 	ldw	r2,56(r2)
 90a19e0:	e0ffff17 	ldw	r3,-4(fp)
 90a19e4:	1085883a 	add	r2,r2,r2
 90a19e8:	1085883a 	add	r2,r2,r2
 90a19ec:	10c5883a 	add	r2,r2,r3
 90a19f0:	10801104 	addi	r2,r2,68
 90a19f4:	10800017 	ldw	r2,0(r2)
 90a19f8:	11000117 	ldw	r4,4(r2)
 90a19fc:	01400104 	movi	r5,4
 90a1a00:	90ba8040 	call	90ba804 <alt_remap_cached>
 90a1a04:	e0bffa15 	stw	r2,-24(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 90a1a08:	e0bfff17 	ldw	r2,-4(fp)
 90a1a0c:	10801017 	ldw	r2,64(r2)
 90a1a10:	10800204 	addi	r2,r2,8
 90a1a14:	e0fffa17 	ldw	r3,-24(fp)
 90a1a18:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 90a1a1c:	e0bfff17 	ldw	r2,-4(fp)
 90a1a20:	10801017 	ldw	r2,64(r2)
 90a1a24:	10800704 	addi	r2,r2,28
 90a1a28:	1007883a 	mov	r3,r2
 90a1a2c:	00a04034 	movhi	r2,33024
 90a1a30:	18800035 	stwio	r2,0(r3)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 90a1a34:	e037883a 	mov	sp,fp
 90a1a38:	dfc00117 	ldw	ra,4(sp)
 90a1a3c:	df000017 	ldw	fp,0(sp)
 90a1a40:	dec00204 	addi	sp,sp,8
 90a1a44:	f800283a 	ret

090a1a48 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 90a1a48:	defffc04 	addi	sp,sp,-16
 90a1a4c:	dfc00315 	stw	ra,12(sp)
 90a1a50:	df000215 	stw	fp,8(sp)
 90a1a54:	df000204 	addi	fp,sp,8
 90a1a58:	e13ffe15 	stw	r4,-8(fp)
 90a1a5c:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 90a1a60:	e13ffe17 	ldw	r4,-8(fp)
 90a1a64:	01424374 	movhi	r5,2317
 90a1a68:	297e6e04 	addi	r5,r5,-1608
 90a1a6c:	90a55a40 	call	90a55a4 <ns_printf>
   return SUCCESS;
 90a1a70:	0005883a 	mov	r2,zero
}
 90a1a74:	e037883a 	mov	sp,fp
 90a1a78:	dfc00117 	ldw	ra,4(sp)
 90a1a7c:	df000017 	ldw	fp,0(sp)
 90a1a80:	dec00204 	addi	sp,sp,8
 90a1a84:	f800283a 	ret

090a1a88 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 90a1a88:	defffc04 	addi	sp,sp,-16
 90a1a8c:	dfc00315 	stw	ra,12(sp)
 90a1a90:	df000215 	stw	fp,8(sp)
 90a1a94:	df000204 	addi	fp,sp,8
 90a1a98:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 90a1a9c:	e0bfff17 	ldw	r2,-4(fp)
 90a1aa0:	00c243b4 	movhi	r3,2318
 90a1aa4:	18f5e604 	addi	r3,r3,-10344
 90a1aa8:	1085883a 	add	r2,r2,r2
 90a1aac:	1085883a 	add	r2,r2,r2
 90a1ab0:	10c5883a 	add	r2,r2,r3
 90a1ab4:	10800017 	ldw	r2,0(r2)
 90a1ab8:	10c02717 	ldw	r3,156(r2)
 90a1abc:	00800084 	movi	r2,2
 90a1ac0:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 90a1ac4:	e0bfff17 	ldw	r2,-4(fp)
 90a1ac8:	00c243b4 	movhi	r3,2318
 90a1acc:	18f4d504 	addi	r3,r3,-11436
 90a1ad0:	10801324 	muli	r2,r2,76
 90a1ad4:	10c5883a 	add	r2,r2,r3
 90a1ad8:	10800304 	addi	r2,r2,12
 90a1adc:	11000017 	ldw	r4,0(r2)
 90a1ae0:	000b883a 	mov	r5,zero
 90a1ae4:	000d883a 	mov	r6,zero
 90a1ae8:	000f883a 	mov	r7,zero
 90a1aec:	909a6d00 	call	909a6d0 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 90a1af0:	e0bfff17 	ldw	r2,-4(fp)
 90a1af4:	00c243b4 	movhi	r3,2318
 90a1af8:	18f4d504 	addi	r3,r3,-11436
 90a1afc:	10801324 	muli	r2,r2,76
 90a1b00:	10c5883a 	add	r2,r2,r3
 90a1b04:	10800104 	addi	r2,r2,4
 90a1b08:	10800017 	ldw	r2,0(r2)
 90a1b0c:	10800204 	addi	r2,r2,8
 90a1b10:	10800037 	ldwio	r2,0(r2)
 90a1b14:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 90a1b18:	e0bfff17 	ldw	r2,-4(fp)
 90a1b1c:	00c243b4 	movhi	r3,2318
 90a1b20:	18f4d504 	addi	r3,r3,-11436
 90a1b24:	10801324 	muli	r2,r2,76
 90a1b28:	10c5883a 	add	r2,r2,r3
 90a1b2c:	10800104 	addi	r2,r2,4
 90a1b30:	10800017 	ldw	r2,0(r2)
 90a1b34:	11000204 	addi	r4,r2,8
 90a1b38:	e0fffe17 	ldw	r3,-8(fp)
 90a1b3c:	00bfff44 	movi	r2,-3
 90a1b40:	1886703a 	and	r3,r3,r2
 90a1b44:	2005883a 	mov	r2,r4
 90a1b48:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 90a1b4c:	e0bfff17 	ldw	r2,-4(fp)
 90a1b50:	00c243b4 	movhi	r3,2318
 90a1b54:	18f5e604 	addi	r3,r3,-10344
 90a1b58:	1085883a 	add	r2,r2,r2
 90a1b5c:	1085883a 	add	r2,r2,r2
 90a1b60:	10c5883a 	add	r2,r2,r3
 90a1b64:	10800017 	ldw	r2,0(r2)
 90a1b68:	10c02717 	ldw	r3,156(r2)
 90a1b6c:	00800084 	movi	r2,2
 90a1b70:	18800715 	stw	r2,28(r3)

  return SUCCESS;
 90a1b74:	0005883a 	mov	r2,zero
}
 90a1b78:	e037883a 	mov	sp,fp
 90a1b7c:	dfc00117 	ldw	ra,4(sp)
 90a1b80:	df000017 	ldw	fp,0(sp)
 90a1b84:	dec00204 	addi	sp,sp,8
 90a1b88:	f800283a 	ret

090a1b8c <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 90a1b8c:	defffc04 	addi	sp,sp,-16
 90a1b90:	dfc00315 	stw	ra,12(sp)
 90a1b94:	df000215 	stw	fp,8(sp)
 90a1b98:	df000204 	addi	fp,sp,8
 90a1b9c:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 90a1ba0:	e0bffe17 	ldw	r2,-8(fp)
 90a1ba4:	10800808 	cmpgei	r2,r2,32
 90a1ba8:	1000041e 	bne	r2,zero,90a1bbc <close+0x30>
 90a1bac:	e13ffe17 	ldw	r4,-8(fp)
 90a1bb0:	90b9ae00 	call	90b9ae0 <alt_close>
 90a1bb4:	e0bfff15 	stw	r2,-4(fp)
 90a1bb8:	00000306 	br	90a1bc8 <close+0x3c>
 90a1bbc:	e13ffe17 	ldw	r4,-8(fp)
 90a1bc0:	90aeb200 	call	90aeb20 <t_socketclose>
 90a1bc4:	e0bfff15 	stw	r2,-4(fp)
 90a1bc8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a1bcc:	e037883a 	mov	sp,fp
 90a1bd0:	dfc00117 	ldw	ra,4(sp)
 90a1bd4:	df000017 	ldw	fp,0(sp)
 90a1bd8:	dec00204 	addi	sp,sp,8
 90a1bdc:	f800283a 	ret

090a1be0 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 90a1be0:	defff504 	addi	sp,sp,-44
 90a1be4:	dfc00a15 	stw	ra,40(sp)
 90a1be8:	df000915 	stw	fp,36(sp)
 90a1bec:	df000904 	addi	fp,sp,36
 90a1bf0:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 90a1bf4:	d0a02c17 	ldw	r2,-32592(gp)
 90a1bf8:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 90a1bfc:	d0a02c04 	addi	r2,gp,-32592
 90a1c00:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 90a1c04:	00003e06 	br	90a1d00 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 90a1c08:	e0fffa17 	ldw	r3,-24(fp)
 90a1c0c:	e0bffa17 	ldw	r2,-24(fp)
 90a1c10:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 90a1c14:	e0fffa17 	ldw	r3,-24(fp)
 90a1c18:	e0bfff17 	ldw	r2,-4(fp)
 90a1c1c:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 90a1c20:	e0bffa17 	ldw	r2,-24(fp)
 90a1c24:	10800517 	ldw	r2,20(r2)
 90a1c28:	00c243b4 	movhi	r3,2318
 90a1c2c:	18f5e604 	addi	r3,r3,-10344
 90a1c30:	1085883a 	add	r2,r2,r2
 90a1c34:	1085883a 	add	r2,r2,r2
 90a1c38:	10c5883a 	add	r2,r2,r3
 90a1c3c:	10c00017 	ldw	r3,0(r2)
 90a1c40:	e0bffa17 	ldw	r2,-24(fp)
 90a1c44:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 90a1c48:	e0bffa17 	ldw	r2,-24(fp)
 90a1c4c:	10800317 	ldw	r2,12(r2)
 90a1c50:	e13ffa17 	ldw	r4,-24(fp)
 90a1c54:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 90a1c58:	e0bffa17 	ldw	r2,-24(fp)
 90a1c5c:	10800617 	ldw	r2,24(r2)
 90a1c60:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 90a1c64:	e17ffb04 	addi	r5,fp,-20
 90a1c68:	e1bffc04 	addi	r6,fp,-16
 90a1c6c:	e1fffd04 	addi	r7,fp,-12
 90a1c70:	e0bffe04 	addi	r2,fp,-8
 90a1c74:	d8800015 	stw	r2,0(sp)
 90a1c78:	e13ffa17 	ldw	r4,-24(fp)
 90a1c7c:	90818b80 	call	90818b8 <get_ip_addr>
 90a1c80:	1005003a 	cmpeq	r2,r2,zero
 90a1c84:	1000181e 	bne	r2,zero,90a1ce8 <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 90a1c88:	e0bffe17 	ldw	r2,-8(fp)
 90a1c8c:	1005003a 	cmpeq	r2,r2,zero
 90a1c90:	1000051e 	bne	r2,zero,90a1ca8 <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 90a1c94:	e0bff817 	ldw	r2,-32(fp)
 90a1c98:	10802a17 	ldw	r2,168(r2)
 90a1c9c:	10c04014 	ori	r3,r2,256
 90a1ca0:	e0bff817 	ldw	r2,-32(fp)
 90a1ca4:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 90a1ca8:	e0fffb17 	ldw	r3,-20(fp)
 90a1cac:	e0bff817 	ldw	r2,-32(fp)
 90a1cb0:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 90a1cb4:	e0fffc17 	ldw	r3,-16(fp)
 90a1cb8:	e0bff817 	ldw	r2,-32(fp)
 90a1cbc:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 90a1cc0:	e0fffd17 	ldw	r3,-12(fp)
 90a1cc4:	e0bff817 	ldw	r2,-32(fp)
 90a1cc8:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 90a1ccc:	e0fff817 	ldw	r3,-32(fp)
 90a1cd0:	00824334 	movhi	r2,2316
 90a1cd4:	10afca04 	addi	r2,r2,-16600
 90a1cd8:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 90a1cdc:	e0fff817 	ldw	r3,-32(fp)
 90a1ce0:	00800084 	movi	r2,2
 90a1ce4:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 90a1ce8:	e0bfff17 	ldw	r2,-4(fp)
 90a1cec:	10800044 	addi	r2,r2,1
 90a1cf0:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 90a1cf4:	e0bffa17 	ldw	r2,-24(fp)
 90a1cf8:	10800017 	ldw	r2,0(r2)
 90a1cfc:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 90a1d00:	e0fffa17 	ldw	r3,-24(fp)
 90a1d04:	e0bff917 	ldw	r2,-28(fp)
 90a1d08:	18bfbf1e 	bne	r3,r2,90a1c08 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 90a1d0c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a1d10:	e037883a 	mov	sp,fp
 90a1d14:	dfc00117 	ldw	ra,4(sp)
 90a1d18:	df000017 	ldw	fp,0(sp)
 90a1d1c:	dec00204 	addi	sp,sp,8
 90a1d20:	f800283a 	ret

090a1d24 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 90a1d24:	defff804 	addi	sp,sp,-32
 90a1d28:	dfc00715 	stw	ra,28(sp)
 90a1d2c:	df000615 	stw	fp,24(sp)
 90a1d30:	df000604 	addi	fp,sp,24
 90a1d34:	e13ffc15 	stw	r4,-16(fp)
 90a1d38:	e17ffd15 	stw	r5,-12(fp)
 90a1d3c:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 90a1d40:	e0bffc17 	ldw	r2,-16(fp)
 90a1d44:	10800808 	cmpgei	r2,r2,32
 90a1d48:	1000061e 	bne	r2,zero,90a1d64 <read+0x40>
 90a1d4c:	e13ffc17 	ldw	r4,-16(fp)
 90a1d50:	e17ffd17 	ldw	r5,-12(fp)
 90a1d54:	e1bffe17 	ldw	r6,-8(fp)
 90a1d58:	90ba6240 	call	90ba624 <alt_read>
 90a1d5c:	e0bfff15 	stw	r2,-4(fp)
 90a1d60:	00000806 	br	90a1d84 <read+0x60>
 90a1d64:	e1bffe17 	ldw	r6,-8(fp)
 90a1d68:	d8000015 	stw	zero,0(sp)
 90a1d6c:	d8000115 	stw	zero,4(sp)
 90a1d70:	e13ffc17 	ldw	r4,-16(fp)
 90a1d74:	e17ffd17 	ldw	r5,-12(fp)
 90a1d78:	000f883a 	mov	r7,zero
 90a1d7c:	90a4a2c0 	call	90a4a2c <bsd_recvfrom>
 90a1d80:	e0bfff15 	stw	r2,-4(fp)
 90a1d84:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 90a1d88:	e037883a 	mov	sp,fp
 90a1d8c:	dfc00117 	ldw	ra,4(sp)
 90a1d90:	df000017 	ldw	fp,0(sp)
 90a1d94:	dec00204 	addi	sp,sp,8
 90a1d98:	f800283a 	ret

090a1d9c <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 90a1d9c:	defffa04 	addi	sp,sp,-24
 90a1da0:	dfc00515 	stw	ra,20(sp)
 90a1da4:	df000415 	stw	fp,16(sp)
 90a1da8:	df000404 	addi	fp,sp,16
 90a1dac:	e13ffc15 	stw	r4,-16(fp)
 90a1db0:	e17ffd15 	stw	r5,-12(fp)
 90a1db4:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 90a1db8:	e0bffc17 	ldw	r2,-16(fp)
 90a1dbc:	10800808 	cmpgei	r2,r2,32
 90a1dc0:	1000061e 	bne	r2,zero,90a1ddc <write+0x40>
  {
    return alt_write (fd, ptr, len);
 90a1dc4:	e13ffc17 	ldw	r4,-16(fp)
 90a1dc8:	e17ffd17 	ldw	r5,-12(fp)
 90a1dcc:	e1bffe17 	ldw	r6,-8(fp)
 90a1dd0:	90babec0 	call	90babec <alt_write>
 90a1dd4:	e0bfff15 	stw	r2,-4(fp)
 90a1dd8:	00000606 	br	90a1df4 <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 90a1ddc:	e17ffd17 	ldw	r5,-12(fp)
 90a1de0:	e1bffe17 	ldw	r6,-8(fp)
 90a1de4:	e13ffc17 	ldw	r4,-16(fp)
 90a1de8:	000f883a 	mov	r7,zero
 90a1dec:	90ae8140 	call	90ae814 <t_send>
 90a1df0:	e0bfff15 	stw	r2,-4(fp)
 90a1df4:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 90a1df8:	e037883a 	mov	sp,fp
 90a1dfc:	dfc00117 	ldw	ra,4(sp)
 90a1e00:	df000017 	ldw	fp,0(sp)
 90a1e04:	dec00204 	addi	sp,sp,8
 90a1e08:	f800283a 	ret

090a1e0c <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 90a1e0c:	defff704 	addi	sp,sp,-36
 90a1e10:	dfc00815 	stw	ra,32(sp)
 90a1e14:	df000715 	stw	fp,28(sp)
 90a1e18:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 90a1e1c:	e03ffa15 	stw	zero,-24(fp)
 90a1e20:	00005806 	br	90a1f84 <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 90a1e24:	e0bffa17 	ldw	r2,-24(fp)
 90a1e28:	00c243b4 	movhi	r3,2318
 90a1e2c:	18f5e604 	addi	r3,r3,-10344
 90a1e30:	1085883a 	add	r2,r2,r2
 90a1e34:	1085883a 	add	r2,r2,r2
 90a1e38:	10c5883a 	add	r2,r2,r3
 90a1e3c:	10800017 	ldw	r2,0(r2)
 90a1e40:	10802717 	ldw	r2,156(r2)
 90a1e44:	10800217 	ldw	r2,8(r2)
 90a1e48:	10800198 	cmpnei	r2,r2,6
 90a1e4c:	1000261e 	bne	r2,zero,90a1ee8 <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 90a1e50:	e0bffa17 	ldw	r2,-24(fp)
 90a1e54:	00c243b4 	movhi	r3,2318
 90a1e58:	18f5e604 	addi	r3,r3,-10344
 90a1e5c:	1085883a 	add	r2,r2,r2
 90a1e60:	1085883a 	add	r2,r2,r2
 90a1e64:	10c5883a 	add	r2,r2,r3
 90a1e68:	10800017 	ldw	r2,0(r2)
 90a1e6c:	10800917 	ldw	r2,36(r2)
 90a1e70:	1004c03a 	cmpne	r2,r2,zero
 90a1e74:	1000091e 	bne	r2,zero,90a1e9c <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 90a1e78:	e0bffa17 	ldw	r2,-24(fp)
 90a1e7c:	00c243b4 	movhi	r3,2318
 90a1e80:	18f5e604 	addi	r3,r3,-10344
 90a1e84:	1085883a 	add	r2,r2,r2
 90a1e88:	1085883a 	add	r2,r2,r2
 90a1e8c:	10c5883a 	add	r2,r2,r3
 90a1e90:	10c00017 	ldw	r3,0(r2)
 90a1e94:	00817a84 	movi	r2,1514
 90a1e98:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 90a1e9c:	e0bffa17 	ldw	r2,-24(fp)
 90a1ea0:	00c243b4 	movhi	r3,2318
 90a1ea4:	18f5e604 	addi	r3,r3,-10344
 90a1ea8:	1085883a 	add	r2,r2,r2
 90a1eac:	1085883a 	add	r2,r2,r2
 90a1eb0:	10c5883a 	add	r2,r2,r3
 90a1eb4:	10800017 	ldw	r2,0(r2)
 90a1eb8:	10800817 	ldw	r2,32(r2)
 90a1ebc:	1004c03a 	cmpne	r2,r2,zero
 90a1ec0:	1000091e 	bne	r2,zero,90a1ee8 <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 90a1ec4:	e0bffa17 	ldw	r2,-24(fp)
 90a1ec8:	00c243b4 	movhi	r3,2318
 90a1ecc:	18f5e604 	addi	r3,r3,-10344
 90a1ed0:	1085883a 	add	r2,r2,r2
 90a1ed4:	1085883a 	add	r2,r2,r2
 90a1ed8:	10c5883a 	add	r2,r2,r3
 90a1edc:	10c00017 	ldw	r3,0(r2)
 90a1ee0:	00800404 	movi	r2,16
 90a1ee4:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 90a1ee8:	e0bffa17 	ldw	r2,-24(fp)
 90a1eec:	00c243b4 	movhi	r3,2318
 90a1ef0:	18f5e604 	addi	r3,r3,-10344
 90a1ef4:	1085883a 	add	r2,r2,r2
 90a1ef8:	1085883a 	add	r2,r2,r2
 90a1efc:	10c5883a 	add	r2,r2,r3
 90a1f00:	10800017 	ldw	r2,0(r2)
 90a1f04:	10800817 	ldw	r2,32(r2)
 90a1f08:	d0e08217 	ldw	r3,-32248(gp)
 90a1f0c:	e0ffff15 	stw	r3,-4(fp)
 90a1f10:	e0bffe15 	stw	r2,-8(fp)
 90a1f14:	e0bffe17 	ldw	r2,-8(fp)
 90a1f18:	e0ffff17 	ldw	r3,-4(fp)
 90a1f1c:	10c0020e 	bge	r2,r3,90a1f28 <Netinit+0x11c>
 90a1f20:	e0bfff17 	ldw	r2,-4(fp)
 90a1f24:	e0bffe15 	stw	r2,-8(fp)
 90a1f28:	e0fffe17 	ldw	r3,-8(fp)
 90a1f2c:	d0e08215 	stw	r3,-32248(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 90a1f30:	e0bffa17 	ldw	r2,-24(fp)
 90a1f34:	00c243b4 	movhi	r3,2318
 90a1f38:	18f5e604 	addi	r3,r3,-10344
 90a1f3c:	1085883a 	add	r2,r2,r2
 90a1f40:	1085883a 	add	r2,r2,r2
 90a1f44:	10c5883a 	add	r2,r2,r3
 90a1f48:	10800017 	ldw	r2,0(r2)
 90a1f4c:	10800917 	ldw	r2,36(r2)
 90a1f50:	d0e08317 	ldw	r3,-32244(gp)
 90a1f54:	e0fffd15 	stw	r3,-12(fp)
 90a1f58:	e0bffc15 	stw	r2,-16(fp)
 90a1f5c:	e0bffc17 	ldw	r2,-16(fp)
 90a1f60:	e0fffd17 	ldw	r3,-12(fp)
 90a1f64:	10c0020e 	bge	r2,r3,90a1f70 <Netinit+0x164>
 90a1f68:	e0bffd17 	ldw	r2,-12(fp)
 90a1f6c:	e0bffc15 	stw	r2,-16(fp)
 90a1f70:	e0fffc17 	ldw	r3,-16(fp)
 90a1f74:	d0e08315 	stw	r3,-32244(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 90a1f78:	e0bffa17 	ldw	r2,-24(fp)
 90a1f7c:	10800044 	addi	r2,r2,1
 90a1f80:	e0bffa15 	stw	r2,-24(fp)
 90a1f84:	00824374 	movhi	r2,2317
 90a1f88:	108f0a04 	addi	r2,r2,15400
 90a1f8c:	10800017 	ldw	r2,0(r2)
 90a1f90:	1007883a 	mov	r3,r2
 90a1f94:	e0bffa17 	ldw	r2,-24(fp)
 90a1f98:	10ffa216 	blt	r2,r3,90a1e24 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 90a1f9c:	008243b4 	movhi	r2,2318
 90a1fa0:	10b52104 	addi	r2,r2,-11132
 90a1fa4:	10000115 	stw	zero,4(r2)
 90a1fa8:	008243b4 	movhi	r2,2318
 90a1fac:	10b52104 	addi	r2,r2,-11132
 90a1fb0:	10c00117 	ldw	r3,4(r2)
 90a1fb4:	008243b4 	movhi	r2,2318
 90a1fb8:	10b52104 	addi	r2,r2,-11132
 90a1fbc:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 90a1fc0:	008243b4 	movhi	r2,2318
 90a1fc4:	10b52104 	addi	r2,r2,-11132
 90a1fc8:	10000215 	stw	zero,8(r2)
 90a1fcc:	008243b4 	movhi	r2,2318
 90a1fd0:	10b52104 	addi	r2,r2,-11132
 90a1fd4:	10c00217 	ldw	r3,8(r2)
 90a1fd8:	008243b4 	movhi	r2,2318
 90a1fdc:	10b52104 	addi	r2,r2,-11132
 90a1fe0:	10c00415 	stw	r3,16(r2)
 90a1fe4:	008243b4 	movhi	r2,2318
 90a1fe8:	10b52104 	addi	r2,r2,-11132
 90a1fec:	10c00417 	ldw	r3,16(r2)
 90a1ff0:	008243b4 	movhi	r2,2318
 90a1ff4:	10b52104 	addi	r2,r2,-11132
 90a1ff8:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a1ffc:	01000084 	movi	r4,2
 90a2000:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   e = pk_init();
 90a2004:	90a95a40 	call	90a95a4 <pk_init>
 90a2008:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a200c:	01000084 	movi	r4,2
 90a2010:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 90a2014:	e0bff917 	ldw	r2,-28(fp)
 90a2018:	1005003a 	cmpeq	r2,r2,zero
 90a201c:	1000031e 	bne	r2,zero,90a202c <Netinit+0x220>
      return e;
 90a2020:	e0bff917 	ldw	r2,-28(fp)
 90a2024:	e0bffb15 	stw	r2,-20(fp)
 90a2028:	00010506 	br	90a2440 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 90a202c:	010242b4 	movhi	r4,2314
 90a2030:	21096e04 	addi	r4,r4,9656
 90a2034:	90a2fcc0 	call	90a2fcc <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 90a2038:	e03ffa15 	stw	zero,-24(fp)
 90a203c:	0000f906 	br	90a2424 <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 90a2040:	e0bffa17 	ldw	r2,-24(fp)
 90a2044:	00c243b4 	movhi	r3,2318
 90a2048:	18f5e604 	addi	r3,r3,-10344
 90a204c:	1085883a 	add	r2,r2,r2
 90a2050:	1085883a 	add	r2,r2,r2
 90a2054:	10c5883a 	add	r2,r2,r3
 90a2058:	10800017 	ldw	r2,0(r2)
 90a205c:	10800217 	ldw	r2,8(r2)
 90a2060:	1005003a 	cmpeq	r2,r2,zero
 90a2064:	1000931e 	bne	r2,zero,90a22b4 <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 90a2068:	e0bffa17 	ldw	r2,-24(fp)
 90a206c:	00c243b4 	movhi	r3,2318
 90a2070:	18f5e604 	addi	r3,r3,-10344
 90a2074:	1085883a 	add	r2,r2,r2
 90a2078:	1085883a 	add	r2,r2,r2
 90a207c:	10c5883a 	add	r2,r2,r3
 90a2080:	10800017 	ldw	r2,0(r2)
 90a2084:	10800217 	ldw	r2,8(r2)
 90a2088:	e13ffa17 	ldw	r4,-24(fp)
 90a208c:	103ee83a 	callr	r2
 90a2090:	e0bff915 	stw	r2,-28(fp)
 90a2094:	e0bff917 	ldw	r2,-28(fp)
 90a2098:	1005003a 	cmpeq	r2,r2,zero
 90a209c:	1000101e 	bne	r2,zero,90a20e0 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 90a20a0:	01024374 	movhi	r4,2317
 90a20a4:	213e7a04 	addi	r4,r4,-1560
 90a20a8:	e17ff917 	ldw	r5,-28(fp)
 90a20ac:	e1bffa17 	ldw	r6,-24(fp)
 90a20b0:	90833900 	call	9083390 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 90a20b4:	e0bffa17 	ldw	r2,-24(fp)
 90a20b8:	00c243b4 	movhi	r3,2318
 90a20bc:	18f5e604 	addi	r3,r3,-10344
 90a20c0:	1085883a 	add	r2,r2,r2
 90a20c4:	1085883a 	add	r2,r2,r2
 90a20c8:	10c5883a 	add	r2,r2,r3
 90a20cc:	10800017 	ldw	r2,0(r2)
 90a20d0:	10c02717 	ldw	r3,156(r2)
 90a20d4:	00800084 	movi	r2,2
 90a20d8:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 90a20dc:	0000ce06 	br	90a2418 <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 90a20e0:	e0bffa17 	ldw	r2,-24(fp)
 90a20e4:	00c243b4 	movhi	r3,2318
 90a20e8:	18f5e604 	addi	r3,r3,-10344
 90a20ec:	1085883a 	add	r2,r2,r2
 90a20f0:	1085883a 	add	r2,r2,r2
 90a20f4:	10c5883a 	add	r2,r2,r3
 90a20f8:	10800017 	ldw	r2,0(r2)
 90a20fc:	10802717 	ldw	r2,156(r2)
 90a2100:	10800217 	ldw	r2,8(r2)
 90a2104:	10800198 	cmpnei	r2,r2,6
 90a2108:	1000111e 	bne	r2,zero,90a2150 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 90a210c:	e0bffa17 	ldw	r2,-24(fp)
 90a2110:	00c243b4 	movhi	r3,2318
 90a2114:	18f5e604 	addi	r3,r3,-10344
 90a2118:	1085883a 	add	r2,r2,r2
 90a211c:	1085883a 	add	r2,r2,r2
 90a2120:	10c5883a 	add	r2,r2,r3
 90a2124:	11000017 	ldw	r4,0(r2)
 90a2128:	e0bffa17 	ldw	r2,-24(fp)
 90a212c:	00c243b4 	movhi	r3,2318
 90a2130:	18f5e604 	addi	r3,r3,-10344
 90a2134:	1085883a 	add	r2,r2,r2
 90a2138:	1085883a 	add	r2,r2,r2
 90a213c:	10c5883a 	add	r2,r2,r3
 90a2140:	10800017 	ldw	r2,0(r2)
 90a2144:	10802a17 	ldw	r2,168(r2)
 90a2148:	10800054 	ori	r2,r2,1
 90a214c:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 90a2150:	e0bffa17 	ldw	r2,-24(fp)
 90a2154:	00c243b4 	movhi	r3,2318
 90a2158:	18f5e604 	addi	r3,r3,-10344
 90a215c:	1085883a 	add	r2,r2,r2
 90a2160:	1085883a 	add	r2,r2,r2
 90a2164:	10c5883a 	add	r2,r2,r3
 90a2168:	10800017 	ldw	r2,0(r2)
 90a216c:	10c02717 	ldw	r3,156(r2)
 90a2170:	00800044 	movi	r2,1
 90a2174:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 90a2178:	e0bffa17 	ldw	r2,-24(fp)
 90a217c:	00c243b4 	movhi	r3,2318
 90a2180:	18f5e604 	addi	r3,r3,-10344
 90a2184:	1085883a 	add	r2,r2,r2
 90a2188:	1085883a 	add	r2,r2,r2
 90a218c:	10c5883a 	add	r2,r2,r3
 90a2190:	10800017 	ldw	r2,0(r2)
 90a2194:	10800103 	ldbu	r2,4(r2)
 90a2198:	10803fcc 	andi	r2,r2,255
 90a219c:	1080201c 	xori	r2,r2,128
 90a21a0:	10bfe004 	addi	r2,r2,-128
 90a21a4:	1004c03a 	cmpne	r2,r2,zero
 90a21a8:	1000421e 	bne	r2,zero,90a22b4 <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 90a21ac:	e0bffa17 	ldw	r2,-24(fp)
 90a21b0:	00c243b4 	movhi	r3,2318
 90a21b4:	18f5e604 	addi	r3,r3,-10344
 90a21b8:	1085883a 	add	r2,r2,r2
 90a21bc:	1085883a 	add	r2,r2,r2
 90a21c0:	10c5883a 	add	r2,r2,r3
 90a21c4:	10800017 	ldw	r2,0(r2)
 90a21c8:	10802717 	ldw	r2,156(r2)
 90a21cc:	10800217 	ldw	r2,8(r2)
 90a21d0:	10800198 	cmpnei	r2,r2,6
 90a21d4:	1000131e 	bne	r2,zero,90a2224 <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 90a21d8:	e0bffa17 	ldw	r2,-24(fp)
 90a21dc:	00c243b4 	movhi	r3,2318
 90a21e0:	18f5e604 	addi	r3,r3,-10344
 90a21e4:	1085883a 	add	r2,r2,r2
 90a21e8:	1085883a 	add	r2,r2,r2
 90a21ec:	10c5883a 	add	r2,r2,r3
 90a21f0:	10c00017 	ldw	r3,0(r2)
 90a21f4:	00801944 	movi	r2,101
 90a21f8:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 90a21fc:	e0bffa17 	ldw	r2,-24(fp)
 90a2200:	00c243b4 	movhi	r3,2318
 90a2204:	18f5e604 	addi	r3,r3,-10344
 90a2208:	1085883a 	add	r2,r2,r2
 90a220c:	1085883a 	add	r2,r2,r2
 90a2210:	10c5883a 	add	r2,r2,r3
 90a2214:	10c00017 	ldw	r3,0(r2)
 90a2218:	00801d04 	movi	r2,116
 90a221c:	18800145 	stb	r2,5(r3)
 90a2220:	00001206 	br	90a226c <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 90a2224:	e0bffa17 	ldw	r2,-24(fp)
 90a2228:	00c243b4 	movhi	r3,2318
 90a222c:	18f5e604 	addi	r3,r3,-10344
 90a2230:	1085883a 	add	r2,r2,r2
 90a2234:	1085883a 	add	r2,r2,r2
 90a2238:	10c5883a 	add	r2,r2,r3
 90a223c:	10c00017 	ldw	r3,0(r2)
 90a2240:	00801a44 	movi	r2,105
 90a2244:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 90a2248:	e0bffa17 	ldw	r2,-24(fp)
 90a224c:	00c243b4 	movhi	r3,2318
 90a2250:	18f5e604 	addi	r3,r3,-10344
 90a2254:	1085883a 	add	r2,r2,r2
 90a2258:	1085883a 	add	r2,r2,r2
 90a225c:	10c5883a 	add	r2,r2,r3
 90a2260:	10c00017 	ldw	r3,0(r2)
 90a2264:	00801984 	movi	r2,102
 90a2268:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 90a226c:	e0bffa17 	ldw	r2,-24(fp)
 90a2270:	00c243b4 	movhi	r3,2318
 90a2274:	18f5e604 	addi	r3,r3,-10344
 90a2278:	1085883a 	add	r2,r2,r2
 90a227c:	1085883a 	add	r2,r2,r2
 90a2280:	10c5883a 	add	r2,r2,r3
 90a2284:	10c00017 	ldw	r3,0(r2)
 90a2288:	e0bffa17 	ldw	r2,-24(fp)
 90a228c:	10800c44 	addi	r2,r2,49
 90a2290:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 90a2294:	e0bffa17 	ldw	r2,-24(fp)
 90a2298:	00c243b4 	movhi	r3,2318
 90a229c:	18f5e604 	addi	r3,r3,-10344
 90a22a0:	1085883a 	add	r2,r2,r2
 90a22a4:	1085883a 	add	r2,r2,r2
 90a22a8:	10c5883a 	add	r2,r2,r3
 90a22ac:	10800017 	ldw	r2,0(r2)
 90a22b0:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 90a22b4:	e13ffa17 	ldw	r4,-24(fp)
 90a22b8:	90a24580 	call	90a2458 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 90a22bc:	e0bffa17 	ldw	r2,-24(fp)
 90a22c0:	00c243b4 	movhi	r3,2318
 90a22c4:	18f5e604 	addi	r3,r3,-10344
 90a22c8:	1085883a 	add	r2,r2,r2
 90a22cc:	1085883a 	add	r2,r2,r2
 90a22d0:	10c5883a 	add	r2,r2,r3
 90a22d4:	10800017 	ldw	r2,0(r2)
 90a22d8:	10800a17 	ldw	r2,40(r2)
 90a22dc:	1005003a 	cmpeq	r2,r2,zero
 90a22e0:	10004d1e 	bne	r2,zero,90a2418 <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 90a22e4:	e0bffa17 	ldw	r2,-24(fp)
 90a22e8:	00c243b4 	movhi	r3,2318
 90a22ec:	18f5e604 	addi	r3,r3,-10344
 90a22f0:	1085883a 	add	r2,r2,r2
 90a22f4:	1085883a 	add	r2,r2,r2
 90a22f8:	10c5883a 	add	r2,r2,r3
 90a22fc:	11400017 	ldw	r5,0(r2)
 90a2300:	e0bffa17 	ldw	r2,-24(fp)
 90a2304:	00c243b4 	movhi	r3,2318
 90a2308:	18f5e604 	addi	r3,r3,-10344
 90a230c:	1085883a 	add	r2,r2,r2
 90a2310:	1085883a 	add	r2,r2,r2
 90a2314:	10c5883a 	add	r2,r2,r3
 90a2318:	10800017 	ldw	r2,0(r2)
 90a231c:	11000a17 	ldw	r4,40(r2)
 90a2320:	e0bffa17 	ldw	r2,-24(fp)
 90a2324:	00c243b4 	movhi	r3,2318
 90a2328:	18f5e604 	addi	r3,r3,-10344
 90a232c:	1085883a 	add	r2,r2,r2
 90a2330:	1085883a 	add	r2,r2,r2
 90a2334:	10c5883a 	add	r2,r2,r3
 90a2338:	10800017 	ldw	r2,0(r2)
 90a233c:	10800c17 	ldw	r2,48(r2)
 90a2340:	0084303a 	nor	r2,zero,r2
 90a2344:	2084b03a 	or	r2,r4,r2
 90a2348:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 90a234c:	e0bffa17 	ldw	r2,-24(fp)
 90a2350:	00c243b4 	movhi	r3,2318
 90a2354:	18f5e604 	addi	r3,r3,-10344
 90a2358:	1085883a 	add	r2,r2,r2
 90a235c:	1085883a 	add	r2,r2,r2
 90a2360:	10c5883a 	add	r2,r2,r3
 90a2364:	11400017 	ldw	r5,0(r2)
 90a2368:	e0bffa17 	ldw	r2,-24(fp)
 90a236c:	00c243b4 	movhi	r3,2318
 90a2370:	18f5e604 	addi	r3,r3,-10344
 90a2374:	1085883a 	add	r2,r2,r2
 90a2378:	1085883a 	add	r2,r2,r2
 90a237c:	10c5883a 	add	r2,r2,r3
 90a2380:	10800017 	ldw	r2,0(r2)
 90a2384:	11000a17 	ldw	r4,40(r2)
 90a2388:	e0bffa17 	ldw	r2,-24(fp)
 90a238c:	00c243b4 	movhi	r3,2318
 90a2390:	18f5e604 	addi	r3,r3,-10344
 90a2394:	1085883a 	add	r2,r2,r2
 90a2398:	1085883a 	add	r2,r2,r2
 90a239c:	10c5883a 	add	r2,r2,r3
 90a23a0:	10800017 	ldw	r2,0(r2)
 90a23a4:	10800c17 	ldw	r2,48(r2)
 90a23a8:	2084703a 	and	r2,r4,r2
 90a23ac:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 90a23b0:	e0bffa17 	ldw	r2,-24(fp)
 90a23b4:	00c243b4 	movhi	r3,2318
 90a23b8:	18f5e604 	addi	r3,r3,-10344
 90a23bc:	1085883a 	add	r2,r2,r2
 90a23c0:	1085883a 	add	r2,r2,r2
 90a23c4:	10c5883a 	add	r2,r2,r3
 90a23c8:	11400017 	ldw	r5,0(r2)
 90a23cc:	e0bffa17 	ldw	r2,-24(fp)
 90a23d0:	00c243b4 	movhi	r3,2318
 90a23d4:	18f5e604 	addi	r3,r3,-10344
 90a23d8:	1085883a 	add	r2,r2,r2
 90a23dc:	1085883a 	add	r2,r2,r2
 90a23e0:	10c5883a 	add	r2,r2,r3
 90a23e4:	10800017 	ldw	r2,0(r2)
 90a23e8:	11000a17 	ldw	r4,40(r2)
 90a23ec:	e0bffa17 	ldw	r2,-24(fp)
 90a23f0:	00c243b4 	movhi	r3,2318
 90a23f4:	18f5e604 	addi	r3,r3,-10344
 90a23f8:	1085883a 	add	r2,r2,r2
 90a23fc:	1085883a 	add	r2,r2,r2
 90a2400:	10c5883a 	add	r2,r2,r3
 90a2404:	10800017 	ldw	r2,0(r2)
 90a2408:	10800c17 	ldw	r2,48(r2)
 90a240c:	0084303a 	nor	r2,zero,r2
 90a2410:	2084b03a 	or	r2,r4,r2
 90a2414:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 90a2418:	e0bffa17 	ldw	r2,-24(fp)
 90a241c:	10800044 	addi	r2,r2,1
 90a2420:	e0bffa15 	stw	r2,-24(fp)
 90a2424:	00824374 	movhi	r2,2317
 90a2428:	108f0a04 	addi	r2,r2,15400
 90a242c:	10800017 	ldw	r2,0(r2)
 90a2430:	1007883a 	mov	r3,r2
 90a2434:	e0bffa17 	ldw	r2,-24(fp)
 90a2438:	10ff0116 	blt	r2,r3,90a2040 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 90a243c:	e03ffb15 	stw	zero,-20(fp)
 90a2440:	e0bffb17 	ldw	r2,-20(fp)
}
 90a2444:	e037883a 	mov	sp,fp
 90a2448:	dfc00117 	ldw	ra,4(sp)
 90a244c:	df000017 	ldw	fp,0(sp)
 90a2450:	dec00204 	addi	sp,sp,8
 90a2454:	f800283a 	ret

090a2458 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 90a2458:	defffc04 	addi	sp,sp,-16
 90a245c:	dfc00315 	stw	ra,12(sp)
 90a2460:	df000215 	stw	fp,8(sp)
 90a2464:	df000204 	addi	fp,sp,8
 90a2468:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 90a246c:	e0bfff17 	ldw	r2,-4(fp)
 90a2470:	00c243b4 	movhi	r3,2318
 90a2474:	18f5e604 	addi	r3,r3,-10344
 90a2478:	1085883a 	add	r2,r2,r2
 90a247c:	1085883a 	add	r2,r2,r2
 90a2480:	10c5883a 	add	r2,r2,r3
 90a2484:	10800017 	ldw	r2,0(r2)
 90a2488:	10800c17 	ldw	r2,48(r2)
 90a248c:	1004c03a 	cmpne	r2,r2,zero
 90a2490:	1000441e 	bne	r2,zero,90a25a4 <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 90a2494:	e0bfff17 	ldw	r2,-4(fp)
 90a2498:	00c243b4 	movhi	r3,2318
 90a249c:	18f5e604 	addi	r3,r3,-10344
 90a24a0:	1085883a 	add	r2,r2,r2
 90a24a4:	1085883a 	add	r2,r2,r2
 90a24a8:	10c5883a 	add	r2,r2,r3
 90a24ac:	10800017 	ldw	r2,0(r2)
 90a24b0:	10800a17 	ldw	r2,40(r2)
 90a24b4:	1080200c 	andi	r2,r2,128
 90a24b8:	1004c03a 	cmpne	r2,r2,zero
 90a24bc:	1000031e 	bne	r2,zero,90a24cc <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 90a24c0:	00bfc034 	movhi	r2,65280
 90a24c4:	e0bffe15 	stw	r2,-8(fp)
 90a24c8:	00001f06 	br	90a2548 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 90a24cc:	e0bfff17 	ldw	r2,-4(fp)
 90a24d0:	00c243b4 	movhi	r3,2318
 90a24d4:	18f5e604 	addi	r3,r3,-10344
 90a24d8:	1085883a 	add	r2,r2,r2
 90a24dc:	1085883a 	add	r2,r2,r2
 90a24e0:	10c5883a 	add	r2,r2,r3
 90a24e4:	10800017 	ldw	r2,0(r2)
 90a24e8:	10800a17 	ldw	r2,40(r2)
 90a24ec:	1080300c 	andi	r2,r2,192
 90a24f0:	10802018 	cmpnei	r2,r2,128
 90a24f4:	1000031e 	bne	r2,zero,90a2504 <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 90a24f8:	00bffff4 	movhi	r2,65535
 90a24fc:	e0bffe15 	stw	r2,-8(fp)
 90a2500:	00001106 	br	90a2548 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 90a2504:	e0bfff17 	ldw	r2,-4(fp)
 90a2508:	00c243b4 	movhi	r3,2318
 90a250c:	18f5e604 	addi	r3,r3,-10344
 90a2510:	1085883a 	add	r2,r2,r2
 90a2514:	1085883a 	add	r2,r2,r2
 90a2518:	10c5883a 	add	r2,r2,r3
 90a251c:	10800017 	ldw	r2,0(r2)
 90a2520:	10800a17 	ldw	r2,40(r2)
 90a2524:	1080380c 	andi	r2,r2,224
 90a2528:	10803018 	cmpnei	r2,r2,192
 90a252c:	1000031e 	bne	r2,zero,90a253c <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 90a2530:	00bfc004 	movi	r2,-256
 90a2534:	e0bffe15 	stw	r2,-8(fp)
 90a2538:	00000306 	br	90a2548 <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 90a253c:	90aa4780 	call	90aa478 <dtrap>
      smask = 0xFFFFFF00L;
 90a2540:	00bfc004 	movi	r2,-256
 90a2544:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 90a2548:	e0bfff17 	ldw	r2,-4(fp)
 90a254c:	00c243b4 	movhi	r3,2318
 90a2550:	18f5e604 	addi	r3,r3,-10344
 90a2554:	1085883a 	add	r2,r2,r2
 90a2558:	1085883a 	add	r2,r2,r2
 90a255c:	10c5883a 	add	r2,r2,r3
 90a2560:	11000017 	ldw	r4,0(r2)
 90a2564:	e0bffe17 	ldw	r2,-8(fp)
 90a2568:	1004d63a 	srli	r2,r2,24
 90a256c:	10c03fcc 	andi	r3,r2,255
 90a2570:	e0bffe17 	ldw	r2,-8(fp)
 90a2574:	1004d23a 	srli	r2,r2,8
 90a2578:	10bfc00c 	andi	r2,r2,65280
 90a257c:	1886b03a 	or	r3,r3,r2
 90a2580:	e0bffe17 	ldw	r2,-8(fp)
 90a2584:	10bfc00c 	andi	r2,r2,65280
 90a2588:	1004923a 	slli	r2,r2,8
 90a258c:	1886b03a 	or	r3,r3,r2
 90a2590:	e0bffe17 	ldw	r2,-8(fp)
 90a2594:	10803fcc 	andi	r2,r2,255
 90a2598:	1004963a 	slli	r2,r2,24
 90a259c:	1884b03a 	or	r2,r3,r2
 90a25a0:	20800c15 	stw	r2,48(r4)
}
 90a25a4:	e037883a 	mov	sp,fp
 90a25a8:	dfc00117 	ldw	ra,4(sp)
 90a25ac:	df000017 	ldw	fp,0(sp)
 90a25b0:	dec00204 	addi	sp,sp,8
 90a25b4:	f800283a 	ret

090a25b8 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 90a25b8:	defffc04 	addi	sp,sp,-16
 90a25bc:	dfc00315 	stw	ra,12(sp)
 90a25c0:	df000215 	stw	fp,8(sp)
 90a25c4:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 90a25c8:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 90a25cc:	d0a08417 	ldw	r2,-32240(gp)
 90a25d0:	1080010c 	andi	r2,r2,4
 90a25d4:	1005003a 	cmpeq	r2,r2,zero
 90a25d8:	1000031e 	bne	r2,zero,90a25e8 <netclose+0x30>
 90a25dc:	01024374 	movhi	r4,2317
 90a25e0:	213e8104 	addi	r4,r4,-1532
 90a25e4:	90836b80 	call	90836b8 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 90a25e8:	008243b4 	movhi	r2,2318
 90a25ec:	10b82704 	addi	r2,r2,-8036
 90a25f0:	10800017 	ldw	r2,0(r2)
 90a25f4:	e0bfff15 	stw	r2,-4(fp)
 90a25f8:	00002106 	br	90a2680 <netclose+0xc8>
   {
      if (ifp->n_close)
 90a25fc:	e0bfff17 	ldw	r2,-4(fp)
 90a2600:	10800517 	ldw	r2,20(r2)
 90a2604:	1005003a 	cmpeq	r2,r2,zero
 90a2608:	10000e1e 	bne	r2,zero,90a2644 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 90a260c:	e0bfff17 	ldw	r2,-4(fp)
 90a2610:	10802717 	ldw	r2,156(r2)
 90a2614:	11400117 	ldw	r5,4(r2)
 90a2618:	01024374 	movhi	r4,2317
 90a261c:	213e8604 	addi	r4,r4,-1512
 90a2620:	90833900 	call	9083390 <printf>
         (*(ifp->n_close))(index++);
 90a2624:	e0bfff17 	ldw	r2,-4(fp)
 90a2628:	10c00517 	ldw	r3,20(r2)
 90a262c:	e13ffe17 	ldw	r4,-8(fp)
 90a2630:	e0bffe17 	ldw	r2,-8(fp)
 90a2634:	10800044 	addi	r2,r2,1
 90a2638:	e0bffe15 	stw	r2,-8(fp)
 90a263c:	183ee83a 	callr	r3
 90a2640:	00000c06 	br	90a2674 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 90a2644:	d0a08417 	ldw	r2,-32240(gp)
 90a2648:	1080010c 	andi	r2,r2,4
 90a264c:	1005003a 	cmpeq	r2,r2,zero
 90a2650:	1000051e 	bne	r2,zero,90a2668 <netclose+0xb0>
 90a2654:	e0bfff17 	ldw	r2,-4(fp)
 90a2658:	11400104 	addi	r5,r2,4
 90a265c:	01024374 	movhi	r4,2317
 90a2660:	213e8d04 	addi	r4,r4,-1484
 90a2664:	90833900 	call	9083390 <printf>
#endif
         index++;
 90a2668:	e0bffe17 	ldw	r2,-8(fp)
 90a266c:	10800044 	addi	r2,r2,1
 90a2670:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 90a2674:	e0bfff17 	ldw	r2,-4(fp)
 90a2678:	10800017 	ldw	r2,0(r2)
 90a267c:	e0bfff15 	stw	r2,-4(fp)
 90a2680:	e0bfff17 	ldw	r2,-4(fp)
 90a2684:	1004c03a 	cmpne	r2,r2,zero
 90a2688:	103fdc1e 	bne	r2,zero,90a25fc <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 90a268c:	e037883a 	mov	sp,fp
 90a2690:	dfc00117 	ldw	ra,4(sp)
 90a2694:	df000017 	ldw	fp,0(sp)
 90a2698:	dec00204 	addi	sp,sp,8
 90a269c:	f800283a 	ret

090a26a0 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 90a26a0:	defff804 	addi	sp,sp,-32
 90a26a4:	dfc00715 	stw	ra,28(sp)
 90a26a8:	df000615 	stw	fp,24(sp)
 90a26ac:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 90a26b0:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 90a26b4:	0000e506 	br	90a2a4c <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 90a26b8:	008243b4 	movhi	r2,2318
 90a26bc:	10b68d04 	addi	r2,r2,-9676
 90a26c0:	10c00217 	ldw	r3,8(r2)
 90a26c4:	e0bffb17 	ldw	r2,-20(fp)
 90a26c8:	1884803a 	cmplt	r2,r3,r2
 90a26cc:	1007883a 	mov	r3,r2
 90a26d0:	e0bffb17 	ldw	r2,-20(fp)
 90a26d4:	10800044 	addi	r2,r2,1
 90a26d8:	e0bffb15 	stw	r2,-20(fp)
 90a26dc:	18803fcc 	andi	r2,r3,255
 90a26e0:	1005003a 	cmpeq	r2,r2,zero
 90a26e4:	1000021e 	bne	r2,zero,90a26f0 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 90a26e8:	90a600c0 	call	90a600c <tk_yield>
         pkts = 0;   /* reset counter */
 90a26ec:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 90a26f0:	01000044 	movi	r4,1
 90a26f4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 90a26f8:	010243b4 	movhi	r4,2318
 90a26fc:	21352104 	addi	r4,r4,-11132
 90a2700:	90a9d400 	call	90a9d40 <getq>
 90a2704:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 90a2708:	01000044 	movi	r4,1
 90a270c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 90a2710:	e0bffe17 	ldw	r2,-8(fp)
 90a2714:	1004c03a 	cmpne	r2,r2,zero
 90a2718:	1000031e 	bne	r2,zero,90a2728 <pktdemux+0x88>
 90a271c:	01024374 	movhi	r4,2317
 90a2720:	213e9404 	addi	r4,r4,-1456
 90a2724:	90a537c0 	call	90a537c <panic>
      ifc = pkt->net;
 90a2728:	e0bffe17 	ldw	r2,-8(fp)
 90a272c:	10800617 	ldw	r2,24(r2)
 90a2730:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 90a2734:	e0bffd17 	ldw	r2,-12(fp)
 90a2738:	10802717 	ldw	r2,156(r2)
 90a273c:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 90a2740:	e0bffe17 	ldw	r2,-8(fp)
 90a2744:	10800117 	ldw	r2,4(r2)
 90a2748:	11400084 	addi	r5,r2,2
 90a274c:	e13ffd17 	ldw	r4,-12(fp)
 90a2750:	90bdc900 	call	90bdc90 <isbcast>
 90a2754:	1005003a 	cmpeq	r2,r2,zero
 90a2758:	1000061e 	bne	r2,zero,90a2774 <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 90a275c:	e0bffc17 	ldw	r2,-16(fp)
 90a2760:	10800b17 	ldw	r2,44(r2)
 90a2764:	10c00044 	addi	r3,r2,1
 90a2768:	e0bffc17 	ldw	r2,-16(fp)
 90a276c:	10c00b15 	stw	r3,44(r2)
 90a2770:	00000506 	br	90a2788 <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 90a2774:	e0bffc17 	ldw	r2,-16(fp)
 90a2778:	10800a17 	ldw	r2,40(r2)
 90a277c:	10c00044 	addi	r3,r2,1
 90a2780:	e0bffc17 	ldw	r2,-16(fp)
 90a2784:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 90a2788:	e0bffc17 	ldw	r2,-16(fp)
 90a278c:	10800617 	ldw	r2,24(r2)
 90a2790:	10800098 	cmpnei	r2,r2,2
 90a2794:	10000c1e 	bne	r2,zero,90a27c8 <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2798:	01000084 	movi	r4,2
 90a279c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 90a27a0:	e13ffe17 	ldw	r4,-8(fp)
 90a27a4:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a27a8:	01000084 	movi	r4,2
 90a27ac:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 90a27b0:	e0bffc17 	ldw	r2,-16(fp)
 90a27b4:	10800c17 	ldw	r2,48(r2)
 90a27b8:	10c00044 	addi	r3,r2,1
 90a27bc:	e0bffc17 	ldw	r2,-16(fp)
 90a27c0:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 90a27c4:	0000a106 	br	90a2a4c <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 90a27c8:	e0bffe17 	ldw	r2,-8(fp)
 90a27cc:	10800117 	ldw	r2,4(r2)
 90a27d0:	10bfff04 	addi	r2,r2,-4
 90a27d4:	10800003 	ldbu	r2,0(r2)
 90a27d8:	10803fcc 	andi	r2,r2,255
 90a27dc:	1080201c 	xori	r2,r2,128
 90a27e0:	10bfe004 	addi	r2,r2,-128
 90a27e4:	10801358 	cmpnei	r2,r2,77
 90a27e8:	10000b1e 	bne	r2,zero,90a2818 <pktdemux+0x178>
 90a27ec:	e0bffe17 	ldw	r2,-8(fp)
 90a27f0:	10c00117 	ldw	r3,4(r2)
 90a27f4:	e0bffe17 	ldw	r2,-8(fp)
 90a27f8:	10800217 	ldw	r2,8(r2)
 90a27fc:	1885883a 	add	r2,r3,r2
 90a2800:	10800003 	ldbu	r2,0(r2)
 90a2804:	10803fcc 	andi	r2,r2,255
 90a2808:	1080201c 	xori	r2,r2,128
 90a280c:	10bfe004 	addi	r2,r2,-128
 90a2810:	10801360 	cmpeqi	r2,r2,77
 90a2814:	1000041e 	bne	r2,zero,90a2828 <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 90a2818:	90aa4780 	call	90aa478 <dtrap>
         panic("pktdemux: corrupt pkt");
 90a281c:	01024374 	movhi	r4,2317
 90a2820:	213e9a04 	addi	r4,r4,-1432
 90a2824:	90a537c0 	call	90a537c <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 90a2828:	e0bffd17 	ldw	r2,-12(fp)
 90a282c:	10802a17 	ldw	r2,168(r2)
 90a2830:	1080020c 	andi	r2,r2,8
 90a2834:	1004c03a 	cmpne	r2,r2,zero
 90a2838:	10004d1e 	bne	r2,zero,90a2970 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 90a283c:	e0bffd17 	ldw	r2,-12(fp)
 90a2840:	10802717 	ldw	r2,156(r2)
 90a2844:	10800217 	ldw	r2,8(r2)
 90a2848:	108001a0 	cmpeqi	r2,r2,6
 90a284c:	1000011e 	bne	r2,zero,90a2854 <pktdemux+0x1b4>
 90a2850:	00003a06 	br	90a293c <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 90a2854:	e0bffe17 	ldw	r2,-8(fp)
 90a2858:	10800117 	ldw	r2,4(r2)
 90a285c:	10800084 	addi	r2,r2,2
 90a2860:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 90a2864:	e0bffa17 	ldw	r2,-24(fp)
 90a2868:	10800304 	addi	r2,r2,12
 90a286c:	10800003 	ldbu	r2,0(r2)
 90a2870:	10803fcc 	andi	r2,r2,255
 90a2874:	1080201c 	xori	r2,r2,128
 90a2878:	10bfe004 	addi	r2,r2,-128
 90a287c:	1004923a 	slli	r2,r2,8
 90a2880:	1007883a 	mov	r3,r2
 90a2884:	e0bffa17 	ldw	r2,-24(fp)
 90a2888:	10800344 	addi	r2,r2,13
 90a288c:	10800003 	ldbu	r2,0(r2)
 90a2890:	10803fcc 	andi	r2,r2,255
 90a2894:	1080201c 	xori	r2,r2,128
 90a2898:	10bfe004 	addi	r2,r2,-128
 90a289c:	10803fcc 	andi	r2,r2,255
 90a28a0:	1885883a 	add	r2,r3,r2
 90a28a4:	10bfffcc 	andi	r2,r2,65535
 90a28a8:	1004d23a 	srli	r2,r2,8
 90a28ac:	10803fcc 	andi	r2,r2,255
 90a28b0:	1009883a 	mov	r4,r2
 90a28b4:	e0bffa17 	ldw	r2,-24(fp)
 90a28b8:	10800304 	addi	r2,r2,12
 90a28bc:	10800003 	ldbu	r2,0(r2)
 90a28c0:	10803fcc 	andi	r2,r2,255
 90a28c4:	1080201c 	xori	r2,r2,128
 90a28c8:	10bfe004 	addi	r2,r2,-128
 90a28cc:	1004923a 	slli	r2,r2,8
 90a28d0:	1007883a 	mov	r3,r2
 90a28d4:	e0bffa17 	ldw	r2,-24(fp)
 90a28d8:	10800344 	addi	r2,r2,13
 90a28dc:	10800003 	ldbu	r2,0(r2)
 90a28e0:	10803fcc 	andi	r2,r2,255
 90a28e4:	1080201c 	xori	r2,r2,128
 90a28e8:	10bfe004 	addi	r2,r2,-128
 90a28ec:	10803fcc 	andi	r2,r2,255
 90a28f0:	1885883a 	add	r2,r3,r2
 90a28f4:	10bfffcc 	andi	r2,r2,65535
 90a28f8:	1004923a 	slli	r2,r2,8
 90a28fc:	1007883a 	mov	r3,r2
 90a2900:	00bfc004 	movi	r2,-256
 90a2904:	1884703a 	and	r2,r3,r2
 90a2908:	2084b03a 	or	r2,r4,r2
 90a290c:	1007883a 	mov	r3,r2
 90a2910:	e0bffe17 	ldw	r2,-8(fp)
 90a2914:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 90a2918:	e0bffe17 	ldw	r2,-8(fp)
 90a291c:	10c00117 	ldw	r3,4(r2)
 90a2920:	e0bffe17 	ldw	r2,-8(fp)
 90a2924:	10800617 	ldw	r2,24(r2)
 90a2928:	10800817 	ldw	r2,32(r2)
 90a292c:	1887883a 	add	r3,r3,r2
 90a2930:	e0bffe17 	ldw	r2,-8(fp)
 90a2934:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 90a2938:	00000d06 	br	90a2970 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 90a293c:	e0bffd17 	ldw	r2,-12(fp)
 90a2940:	10802717 	ldw	r2,156(r2)
 90a2944:	11400217 	ldw	r5,8(r2)
 90a2948:	01024374 	movhi	r4,2317
 90a294c:	213ea004 	addi	r4,r4,-1408
 90a2950:	90833900 	call	9083390 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2954:	01000084 	movi	r4,2
 90a2958:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 90a295c:	e13ffe17 	ldw	r4,-8(fp)
 90a2960:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2964:	01000084 	movi	r4,2
 90a2968:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            continue;
 90a296c:	00003706 	br	90a2a4c <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 90a2970:	e0bffe17 	ldw	r2,-8(fp)
 90a2974:	1080080b 	ldhu	r2,32(r2)
 90a2978:	10bfffcc 	andi	r2,r2,65535
 90a297c:	e0bfff15 	stw	r2,-4(fp)
 90a2980:	e0ffff17 	ldw	r3,-4(fp)
 90a2984:	18800220 	cmpeqi	r2,r3,8
 90a2988:	1000041e 	bne	r2,zero,90a299c <pktdemux+0x2fc>
 90a298c:	e0ffff17 	ldw	r3,-4(fp)
 90a2990:	18818220 	cmpeqi	r2,r3,1544
 90a2994:	1000081e 	bne	r2,zero,90a29b8 <pktdemux+0x318>
 90a2998:	00000e06 	br	90a29d4 <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 90a299c:	0009883a 	mov	r4,zero
 90a29a0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 90a29a4:	e13ffe17 	ldw	r4,-8(fp)
 90a29a8:	90c1f500 	call	90c1f50 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 90a29ac:	0009883a 	mov	r4,zero
 90a29b0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         break;
 90a29b4:	00002506 	br	90a2a4c <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 90a29b8:	0009883a 	mov	r4,zero
 90a29bc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 90a29c0:	e13ffe17 	ldw	r4,-8(fp)
 90a29c4:	90bd3700 	call	90bd370 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90a29c8:	0009883a 	mov	r4,zero
 90a29cc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         break;
 90a29d0:	00001e06 	br	90a2a4c <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 90a29d4:	d0a08417 	ldw	r2,-32240(gp)
 90a29d8:	1081000c 	andi	r2,r2,1024
 90a29dc:	1005003a 	cmpeq	r2,r2,zero
 90a29e0:	10000f1e 	bne	r2,zero,90a2a20 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 90a29e4:	e0bffe17 	ldw	r2,-8(fp)
 90a29e8:	1080080b 	ldhu	r2,32(r2)
 90a29ec:	10bfffcc 	andi	r2,r2,65535
 90a29f0:	1004d23a 	srli	r2,r2,8
 90a29f4:	10bfffcc 	andi	r2,r2,65535
 90a29f8:	10c03fcc 	andi	r3,r2,255
 90a29fc:	e0bffe17 	ldw	r2,-8(fp)
 90a2a00:	1080080b 	ldhu	r2,32(r2)
 90a2a04:	10bfffcc 	andi	r2,r2,65535
 90a2a08:	1004923a 	slli	r2,r2,8
 90a2a0c:	10bfc00c 	andi	r2,r2,65280
 90a2a10:	188ab03a 	or	r5,r3,r2
 90a2a14:	01024374 	movhi	r4,2317
 90a2a18:	213ea804 	addi	r4,r4,-1376
 90a2a1c:	90833900 	call	9083390 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 90a2a20:	e0bffd17 	ldw	r2,-12(fp)
 90a2a24:	10c02717 	ldw	r3,156(r2)
 90a2a28:	18800e17 	ldw	r2,56(r3)
 90a2a2c:	10800044 	addi	r2,r2,1
 90a2a30:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2a34:	01000084 	movi	r4,2
 90a2a38:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 90a2a3c:	e13ffe17 	ldw	r4,-8(fp)
 90a2a40:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2a44:	01000084 	movi	r4,2
 90a2a48:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 90a2a4c:	008243b4 	movhi	r2,2318
 90a2a50:	10b52104 	addi	r2,r2,-11132
 90a2a54:	10800217 	ldw	r2,8(r2)
 90a2a58:	1004c03a 	cmpne	r2,r2,zero
 90a2a5c:	103f161e 	bne	r2,zero,90a26b8 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 90a2a60:	e037883a 	mov	sp,fp
 90a2a64:	dfc00117 	ldw	ra,4(sp)
 90a2a68:	df000017 	ldw	fp,0(sp)
 90a2a6c:	dec00204 	addi	sp,sp,8
 90a2a70:	f800283a 	ret

090a2a74 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 90a2a74:	defffc04 	addi	sp,sp,-16
 90a2a78:	df000315 	stw	fp,12(sp)
 90a2a7c:	df000304 	addi	fp,sp,12
 90a2a80:	e13ffd15 	stw	r4,-12(fp)
 90a2a84:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 90a2a88:	00824374 	movhi	r2,2317
 90a2a8c:	108f2e04 	addi	r2,r2,15544
 90a2a90:	10800017 	ldw	r2,0(r2)
 90a2a94:	1004403a 	cmpge	r2,r2,zero
 90a2a98:	1000141e 	bne	r2,zero,90a2aec <c_older+0x78>
 90a2a9c:	00824374 	movhi	r2,2317
 90a2aa0:	108f2e04 	addi	r2,r2,15544
 90a2aa4:	10c00017 	ldw	r3,0(r2)
 90a2aa8:	e0bffd17 	ldw	r2,-12(fp)
 90a2aac:	18800536 	bltu	r3,r2,90a2ac4 <c_older+0x50>
 90a2ab0:	00824374 	movhi	r2,2317
 90a2ab4:	108f2e04 	addi	r2,r2,15544
 90a2ab8:	10c00017 	ldw	r3,0(r2)
 90a2abc:	e0bffe17 	ldw	r2,-8(fp)
 90a2ac0:	18800a2e 	bgeu	r3,r2,90a2aec <c_older+0x78>
 90a2ac4:	00824374 	movhi	r2,2317
 90a2ac8:	108f2e04 	addi	r2,r2,15544
 90a2acc:	10c00017 	ldw	r3,0(r2)
 90a2ad0:	e0bffd17 	ldw	r2,-12(fp)
 90a2ad4:	10c00e36 	bltu	r2,r3,90a2b10 <c_older+0x9c>
 90a2ad8:	00824374 	movhi	r2,2317
 90a2adc:	108f2e04 	addi	r2,r2,15544
 90a2ae0:	10c00017 	ldw	r3,0(r2)
 90a2ae4:	e0bffe17 	ldw	r2,-8(fp)
 90a2ae8:	10c00936 	bltu	r2,r3,90a2b10 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 90a2aec:	e0fffd17 	ldw	r3,-12(fp)
 90a2af0:	e0bffe17 	ldw	r2,-8(fp)
 90a2af4:	1880032e 	bgeu	r3,r2,90a2b04 <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 90a2af8:	e0bffd17 	ldw	r2,-12(fp)
 90a2afc:	e0bfff15 	stw	r2,-4(fp)
 90a2b00:	00000b06 	br	90a2b30 <c_older+0xbc>
      else 
         return(ct2);
 90a2b04:	e0bffe17 	ldw	r2,-8(fp)
 90a2b08:	e0bfff15 	stw	r2,-4(fp)
 90a2b0c:	00000806 	br	90a2b30 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 90a2b10:	e0fffd17 	ldw	r3,-12(fp)
 90a2b14:	e0bffe17 	ldw	r2,-8(fp)
 90a2b18:	18800336 	bltu	r3,r2,90a2b28 <c_older+0xb4>
      return(ct1);
 90a2b1c:	e0bffd17 	ldw	r2,-12(fp)
 90a2b20:	e0bfff15 	stw	r2,-4(fp)
 90a2b24:	00000206 	br	90a2b30 <c_older+0xbc>
   else
      return(ct2);
 90a2b28:	e0bffe17 	ldw	r2,-8(fp)
 90a2b2c:	e0bfff15 	stw	r2,-4(fp)
 90a2b30:	e0bfff17 	ldw	r2,-4(fp)
}
 90a2b34:	e037883a 	mov	sp,fp
 90a2b38:	df000017 	ldw	fp,0(sp)
 90a2b3c:	dec00104 	addi	sp,sp,4
 90a2b40:	f800283a 	ret

090a2b44 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 90a2b44:	defffa04 	addi	sp,sp,-24
 90a2b48:	dfc00515 	stw	ra,20(sp)
 90a2b4c:	df000415 	stw	fp,16(sp)
 90a2b50:	df000404 	addi	fp,sp,16
 90a2b54:	e13ffd15 	stw	r4,-12(fp)
 90a2b58:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 90a2b5c:	e0bffd17 	ldw	r2,-12(fp)
 90a2b60:	10800617 	ldw	r2,24(r2)
 90a2b64:	10802717 	ldw	r2,156(r2)
 90a2b68:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 90a2b6c:	e0bffc17 	ldw	r2,-16(fp)
 90a2b70:	10800617 	ldw	r2,24(r2)
 90a2b74:	10800098 	cmpnei	r2,r2,2
 90a2b78:	1000091e 	bne	r2,zero,90a2ba0 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2b7c:	01000084 	movi	r4,2
 90a2b80:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90a2b84:	e13ffd17 	ldw	r4,-12(fp)
 90a2b88:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2b8c:	01000084 	movi	r4,2
 90a2b90:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 90a2b94:	00bff7c4 	movi	r2,-33
 90a2b98:	e0bfff15 	stw	r2,-4(fp)
 90a2b9c:	00004c06 	br	90a2cd0 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 90a2ba0:	e0bffd17 	ldw	r2,-12(fp)
 90a2ba4:	10800617 	ldw	r2,24(r2)
 90a2ba8:	10800817 	ldw	r2,32(r2)
 90a2bac:	1005003a 	cmpeq	r2,r2,zero
 90a2bb0:	1000081e 	bne	r2,zero,90a2bd4 <ip2mac+0x90>
 90a2bb4:	e0bffc17 	ldw	r2,-16(fp)
 90a2bb8:	10800217 	ldw	r2,8(r2)
 90a2bbc:	108005e0 	cmpeqi	r2,r2,23
 90a2bc0:	1000041e 	bne	r2,zero,90a2bd4 <ip2mac+0x90>
 90a2bc4:	e0bffc17 	ldw	r2,-16(fp)
 90a2bc8:	10800217 	ldw	r2,8(r2)
 90a2bcc:	10800718 	cmpnei	r2,r2,28
 90a2bd0:	1000291e 	bne	r2,zero,90a2c78 <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 90a2bd4:	e0bffc17 	ldw	r2,-16(fp)
 90a2bd8:	10801017 	ldw	r2,64(r2)
 90a2bdc:	10c00044 	addi	r3,r2,1
 90a2be0:	e0bffc17 	ldw	r2,-16(fp)
 90a2be4:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 90a2be8:	e0bffc17 	ldw	r2,-16(fp)
 90a2bec:	10c00f17 	ldw	r3,60(r2)
 90a2bf0:	e0bffd17 	ldw	r2,-12(fp)
 90a2bf4:	10800417 	ldw	r2,16(r2)
 90a2bf8:	1887883a 	add	r3,r3,r2
 90a2bfc:	e0bffc17 	ldw	r2,-16(fp)
 90a2c00:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 90a2c04:	e0bffd17 	ldw	r2,-12(fp)
 90a2c08:	10800617 	ldw	r2,24(r2)
 90a2c0c:	10800417 	ldw	r2,16(r2)
 90a2c10:	1005003a 	cmpeq	r2,r2,zero
 90a2c14:	1000061e 	bne	r2,zero,90a2c30 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 90a2c18:	e0bffd17 	ldw	r2,-12(fp)
 90a2c1c:	10800617 	ldw	r2,24(r2)
 90a2c20:	10800417 	ldw	r2,16(r2)
 90a2c24:	e13ffd17 	ldw	r4,-12(fp)
 90a2c28:	103ee83a 	callr	r2
 90a2c2c:	00001006 	br	90a2c70 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 90a2c30:	e0bffd17 	ldw	r2,-12(fp)
 90a2c34:	10800617 	ldw	r2,24(r2)
 90a2c38:	10c00317 	ldw	r3,12(r2)
 90a2c3c:	e0bffd17 	ldw	r2,-12(fp)
 90a2c40:	11000617 	ldw	r4,24(r2)
 90a2c44:	e0bffd17 	ldw	r2,-12(fp)
 90a2c48:	11400317 	ldw	r5,12(r2)
 90a2c4c:	e0bffd17 	ldw	r2,-12(fp)
 90a2c50:	11800417 	ldw	r6,16(r2)
 90a2c54:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2c58:	01000084 	movi	r4,2
 90a2c5c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90a2c60:	e13ffd17 	ldw	r4,-12(fp)
 90a2c64:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2c68:	01000084 	movi	r4,2
 90a2c6c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 90a2c70:	e03fff15 	stw	zero,-4(fp)
 90a2c74:	00001606 	br	90a2cd0 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 90a2c78:	e0bffd17 	ldw	r2,-12(fp)
 90a2c7c:	10800617 	ldw	r2,24(r2)
 90a2c80:	10800a17 	ldw	r2,40(r2)
 90a2c84:	1004c03a 	cmpne	r2,r2,zero
 90a2c88:	10000d1e 	bne	r2,zero,90a2cc0 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 90a2c8c:	e0bffd17 	ldw	r2,-12(fp)
 90a2c90:	10800717 	ldw	r2,28(r2)
 90a2c94:	10bfffe0 	cmpeqi	r2,r2,-1
 90a2c98:	1000091e 	bne	r2,zero,90a2cc0 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90a2c9c:	01000084 	movi	r4,2
 90a2ca0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90a2ca4:	e13ffd17 	ldw	r4,-12(fp)
 90a2ca8:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a2cac:	01000084 	movi	r4,2
 90a2cb0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 90a2cb4:	00bff884 	movi	r2,-30
 90a2cb8:	e0bfff15 	stw	r2,-4(fp)
 90a2cbc:	00000406 	br	90a2cd0 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 90a2cc0:	e13ffd17 	ldw	r4,-12(fp)
 90a2cc4:	e17ffe17 	ldw	r5,-8(fp)
 90a2cc8:	90bd5d00 	call	90bd5d0 <send_via_arp>
 90a2ccc:	e0bfff15 	stw	r2,-4(fp)
 90a2cd0:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 90a2cd4:	e037883a 	mov	sp,fp
 90a2cd8:	dfc00117 	ldw	ra,4(sp)
 90a2cdc:	df000017 	ldw	fp,0(sp)
 90a2ce0:	dec00204 	addi	sp,sp,8
 90a2ce4:	f800283a 	ret

090a2ce8 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 90a2ce8:	defffb04 	addi	sp,sp,-20
 90a2cec:	dfc00415 	stw	ra,16(sp)
 90a2cf0:	df000315 	stw	fp,12(sp)
 90a2cf4:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 90a2cf8:	e03ffd15 	stw	zero,-12(fp)
 90a2cfc:	00002a06 	br	90a2da8 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 90a2d00:	e13ffd17 	ldw	r4,-12(fp)
 90a2d04:	e0bffd17 	ldw	r2,-12(fp)
 90a2d08:	10803024 	muli	r2,r2,192
 90a2d0c:	1007883a 	mov	r3,r2
 90a2d10:	008243b4 	movhi	r2,2318
 90a2d14:	10b52604 	addi	r2,r2,-11112
 90a2d18:	188b883a 	add	r5,r3,r2
 90a2d1c:	00c243b4 	movhi	r3,2318
 90a2d20:	18f5e604 	addi	r3,r3,-10344
 90a2d24:	2105883a 	add	r2,r4,r4
 90a2d28:	1085883a 	add	r2,r2,r2
 90a2d2c:	10c5883a 	add	r2,r2,r3
 90a2d30:	11400015 	stw	r5,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 90a2d34:	e0bffd17 	ldw	r2,-12(fp)
 90a2d38:	00c243b4 	movhi	r3,2318
 90a2d3c:	18f5e604 	addi	r3,r3,-10344
 90a2d40:	1085883a 	add	r2,r2,r2
 90a2d44:	1085883a 	add	r2,r2,r2
 90a2d48:	10c5883a 	add	r2,r2,r3
 90a2d4c:	11000017 	ldw	r4,0(r2)
 90a2d50:	e0bffd17 	ldw	r2,-12(fp)
 90a2d54:	00c243b4 	movhi	r3,2318
 90a2d58:	18f5e604 	addi	r3,r3,-10344
 90a2d5c:	1085883a 	add	r2,r2,r2
 90a2d60:	1085883a 	add	r2,r2,r2
 90a2d64:	10c5883a 	add	r2,r2,r3
 90a2d68:	10800017 	ldw	r2,0(r2)
 90a2d6c:	10801204 	addi	r2,r2,72
 90a2d70:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 90a2d74:	e0bffd17 	ldw	r2,-12(fp)
 90a2d78:	00c243b4 	movhi	r3,2318
 90a2d7c:	18f5e604 	addi	r3,r3,-10344
 90a2d80:	1085883a 	add	r2,r2,r2
 90a2d84:	1085883a 	add	r2,r2,r2
 90a2d88:	10c5883a 	add	r2,r2,r3
 90a2d8c:	11400017 	ldw	r5,0(r2)
 90a2d90:	010243b4 	movhi	r4,2318
 90a2d94:	21382704 	addi	r4,r4,-8036
 90a2d98:	90a9e080 	call	90a9e08 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 90a2d9c:	e0bffd17 	ldw	r2,-12(fp)
 90a2da0:	10800044 	addi	r2,r2,1
 90a2da4:	e0bffd15 	stw	r2,-12(fp)
 90a2da8:	e0bffd17 	ldw	r2,-12(fp)
 90a2dac:	10800110 	cmplti	r2,r2,4
 90a2db0:	103fd31e 	bne	r2,zero,90a2d00 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 90a2db4:	d0a08517 	ldw	r2,-32236(gp)
 90a2db8:	1009883a 	mov	r4,r2
 90a2dbc:	90c307c0 	call	90c307c <prep_ifaces>
 90a2dc0:	d0a08515 	stw	r2,-32236(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 90a2dc4:	d0a08517 	ldw	r2,-32236(gp)
 90a2dc8:	1004c03a 	cmpne	r2,r2,zero
 90a2dcc:	1000041e 	bne	r2,zero,90a2de0 <ip_startup+0xf8>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 90a2dd0:	00824374 	movhi	r2,2317
 90a2dd4:	10beb904 	addi	r2,r2,-1308
 90a2dd8:	e0bfff15 	stw	r2,-4(fp)
 90a2ddc:	00007506 	br	90a2fb4 <ip_startup+0x2cc>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 90a2de0:	d0a08517 	ldw	r2,-32236(gp)
 90a2de4:	e0bffd15 	stw	r2,-12(fp)
 90a2de8:	00001506 	br	90a2e40 <ip_startup+0x158>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 90a2dec:	e0bffd17 	ldw	r2,-12(fp)
 90a2df0:	00c243b4 	movhi	r3,2318
 90a2df4:	18f5e604 	addi	r3,r3,-10344
 90a2df8:	1085883a 	add	r2,r2,r2
 90a2dfc:	1085883a 	add	r2,r2,r2
 90a2e00:	10c5883a 	add	r2,r2,r3
 90a2e04:	10800017 	ldw	r2,0(r2)
 90a2e08:	100b883a 	mov	r5,r2
 90a2e0c:	010243b4 	movhi	r4,2318
 90a2e10:	21382704 	addi	r4,r4,-8036
 90a2e14:	90a9eb80 	call	90a9eb8 <qdel>
      nets[i] = NULL;               /* remove from array */
 90a2e18:	e0bffd17 	ldw	r2,-12(fp)
 90a2e1c:	00c243b4 	movhi	r3,2318
 90a2e20:	18f5e604 	addi	r3,r3,-10344
 90a2e24:	1085883a 	add	r2,r2,r2
 90a2e28:	1085883a 	add	r2,r2,r2
 90a2e2c:	10c5883a 	add	r2,r2,r3
 90a2e30:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 90a2e34:	e0bffd17 	ldw	r2,-12(fp)
 90a2e38:	10800044 	addi	r2,r2,1
 90a2e3c:	e0bffd15 	stw	r2,-12(fp)
 90a2e40:	e0bffd17 	ldw	r2,-12(fp)
 90a2e44:	10800110 	cmplti	r2,r2,4
 90a2e48:	103fe81e 	bne	r2,zero,90a2dec <ip_startup+0x104>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 90a2e4c:	90aa5b40 	call	90aa5b4 <clock_init>
   exit_hook(clock_c);
 90a2e50:	010242f4 	movhi	r4,2315
 90a2e54:	21297c04 	addi	r4,r4,-23056
 90a2e58:	90a2fcc0 	call	90a2fcc <exit_hook>

   e = Netinit();    /* start net interface(s) */
 90a2e5c:	90a1e0c0 	call	90a1e0c <Netinit>
 90a2e60:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a2e64:	e0bffe17 	ldw	r2,-8(fp)
 90a2e68:	1005003a 	cmpeq	r2,r2,zero
 90a2e6c:	1000041e 	bne	r2,zero,90a2e80 <ip_startup+0x198>
   {
      return("unable to initialize net");
 90a2e70:	00824374 	movhi	r2,2317
 90a2e74:	10bec304 	addi	r2,r2,-1268
 90a2e78:	e0bfff15 	stw	r2,-4(fp)
 90a2e7c:	00004d06 	br	90a2fb4 <ip_startup+0x2cc>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 90a2e80:	90bc6700 	call	90bc670 <etainit>
 90a2e84:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a2e88:	e0bffe17 	ldw	r2,-8(fp)
 90a2e8c:	1005003a 	cmpeq	r2,r2,zero
 90a2e90:	1000051e 	bne	r2,zero,90a2ea8 <ip_startup+0x1c0>
   {
      ip_exit();
 90a2e94:	90a30380 	call	90a3038 <ip_exit>
      return("unable to initialize arp");
 90a2e98:	00824374 	movhi	r2,2317
 90a2e9c:	10beca04 	addi	r2,r2,-1240
 90a2ea0:	e0bfff15 	stw	r2,-4(fp)
 90a2ea4:	00004306 	br	90a2fb4 <ip_startup+0x2cc>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 90a2ea8:	90bdea40 	call	90bdea4 <ip_init>
 90a2eac:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a2eb0:	e0bffe17 	ldw	r2,-8(fp)
 90a2eb4:	1005003a 	cmpeq	r2,r2,zero
 90a2eb8:	1000051e 	bne	r2,zero,90a2ed0 <ip_startup+0x1e8>
   {
      ip_exit();
 90a2ebc:	90a30380 	call	90a3038 <ip_exit>
      return("unable to initialize IP");
 90a2ec0:	00824374 	movhi	r2,2317
 90a2ec4:	10bed104 	addi	r2,r2,-1212
 90a2ec8:	e0bfff15 	stw	r2,-4(fp)
 90a2ecc:	00003906 	br	90a2fb4 <ip_startup+0x2cc>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 90a2ed0:	90a31980 	call	90a3198 <igmp_init>
 90a2ed4:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a2ed8:	e0bffe17 	ldw	r2,-8(fp)
 90a2edc:	1005003a 	cmpeq	r2,r2,zero
 90a2ee0:	1000041e 	bne	r2,zero,90a2ef4 <ip_startup+0x20c>
   {
      ip_exit();
 90a2ee4:	90a30380 	call	90a3038 <ip_exit>
      return(ipmcfail_str);
 90a2ee8:	d0a02e17 	ldw	r2,-32584(gp)
 90a2eec:	e0bfff15 	stw	r2,-4(fp)
 90a2ef0:	00003006 	br	90a2fb4 <ip_startup+0x2cc>
   }

   for (i = 0; i < (int)ifNumber; i++)
 90a2ef4:	e03ffd15 	stw	zero,-12(fp)
 90a2ef8:	00001e06 	br	90a2f74 <ip_startup+0x28c>
   {
      if (nets[i]->n_mcastlist != NULL)
 90a2efc:	e0bffd17 	ldw	r2,-12(fp)
 90a2f00:	00c243b4 	movhi	r3,2318
 90a2f04:	18f5e604 	addi	r3,r3,-10344
 90a2f08:	1085883a 	add	r2,r2,r2
 90a2f0c:	1085883a 	add	r2,r2,r2
 90a2f10:	10c5883a 	add	r2,r2,r3
 90a2f14:	10800017 	ldw	r2,0(r2)
 90a2f18:	10802b17 	ldw	r2,172(r2)
 90a2f1c:	1005003a 	cmpeq	r2,r2,zero
 90a2f20:	1000111e 	bne	r2,zero,90a2f68 <ip_startup+0x280>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 90a2f24:	e0bffd17 	ldw	r2,-12(fp)
 90a2f28:	00c243b4 	movhi	r3,2318
 90a2f2c:	18f5e604 	addi	r3,r3,-10344
 90a2f30:	1085883a 	add	r2,r2,r2
 90a2f34:	1085883a 	add	r2,r2,r2
 90a2f38:	10c5883a 	add	r2,r2,r3
 90a2f3c:	11400017 	ldw	r5,0(r2)
 90a2f40:	01024374 	movhi	r4,2317
 90a2f44:	210f0e04 	addi	r4,r4,15416
 90a2f48:	01800104 	movi	r6,4
 90a2f4c:	90c2d8c0 	call	90c2d8c <in_addmulti>
 90a2f50:	1004c03a 	cmpne	r2,r2,zero
 90a2f54:	1000041e 	bne	r2,zero,90a2f68 <ip_startup+0x280>
      {
         ip_exit();
 90a2f58:	90a30380 	call	90a3038 <ip_exit>
         return(ipmcfail_str);
 90a2f5c:	d0a02e17 	ldw	r2,-32584(gp)
 90a2f60:	e0bfff15 	stw	r2,-4(fp)
 90a2f64:	00001306 	br	90a2fb4 <ip_startup+0x2cc>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 90a2f68:	e0bffd17 	ldw	r2,-12(fp)
 90a2f6c:	10800044 	addi	r2,r2,1
 90a2f70:	e0bffd15 	stw	r2,-12(fp)
 90a2f74:	d0a08517 	ldw	r2,-32236(gp)
 90a2f78:	1007883a 	mov	r3,r2
 90a2f7c:	e0bffd17 	ldw	r2,-12(fp)
 90a2f80:	10ffde16 	blt	r2,r3,90a2efc <ip_startup+0x214>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 90a2f84:	90b8c200 	call	90b8c20 <tcpinit>
 90a2f88:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90a2f8c:	e0bffe17 	ldw	r2,-8(fp)
 90a2f90:	1005003a 	cmpeq	r2,r2,zero
 90a2f94:	1000051e 	bne	r2,zero,90a2fac <ip_startup+0x2c4>
   {
      ip_exit();
 90a2f98:	90a30380 	call	90a3038 <ip_exit>
      return("unable to initialize TCP");
 90a2f9c:	00824374 	movhi	r2,2317
 90a2fa0:	10bed704 	addi	r2,r2,-1188
 90a2fa4:	e0bfff15 	stw	r2,-4(fp)
 90a2fa8:	00000206 	br	90a2fb4 <ip_startup+0x2cc>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 90a2fac:	90c31380 	call	90c3138 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 90a2fb0:	e03fff15 	stw	zero,-4(fp)
 90a2fb4:	e0bfff17 	ldw	r2,-4(fp)
}
 90a2fb8:	e037883a 	mov	sp,fp
 90a2fbc:	dfc00117 	ldw	ra,4(sp)
 90a2fc0:	df000017 	ldw	fp,0(sp)
 90a2fc4:	dec00204 	addi	sp,sp,8
 90a2fc8:	f800283a 	ret

090a2fcc <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 90a2fcc:	defffd04 	addi	sp,sp,-12
 90a2fd0:	dfc00215 	stw	ra,8(sp)
 90a2fd4:	df000115 	stw	fp,4(sp)
 90a2fd8:	df000104 	addi	fp,sp,4
 90a2fdc:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 90a2fe0:	d0a08617 	ldw	r2,-32232(gp)
 90a2fe4:	10800390 	cmplti	r2,r2,14
 90a2fe8:	1000031e 	bne	r2,zero,90a2ff8 <exit_hook+0x2c>
      panic("exit_hook");
 90a2fec:	01024374 	movhi	r4,2317
 90a2ff0:	213ede04 	addi	r4,r4,-1160
 90a2ff4:	90a537c0 	call	90a537c <panic>

   closers[++nclosers] = func;
 90a2ff8:	d0a08617 	ldw	r2,-32232(gp)
 90a2ffc:	10800044 	addi	r2,r2,1
 90a3000:	d0a08615 	stw	r2,-32232(gp)
 90a3004:	d0a08617 	ldw	r2,-32232(gp)
 90a3008:	00c24374 	movhi	r3,2317
 90a300c:	18d4f104 	addi	r3,r3,21444
 90a3010:	1085883a 	add	r2,r2,r2
 90a3014:	1085883a 	add	r2,r2,r2
 90a3018:	10c7883a 	add	r3,r2,r3
 90a301c:	e0bfff17 	ldw	r2,-4(fp)
 90a3020:	18800015 	stw	r2,0(r3)
}
 90a3024:	e037883a 	mov	sp,fp
 90a3028:	dfc00117 	ldw	ra,4(sp)
 90a302c:	df000017 	ldw	fp,0(sp)
 90a3030:	dec00204 	addi	sp,sp,8
 90a3034:	f800283a 	ret

090a3038 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 90a3038:	defffd04 	addi	sp,sp,-12
 90a303c:	dfc00215 	stw	ra,8(sp)
 90a3040:	df000115 	stw	fp,4(sp)
 90a3044:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 90a3048:	d0a08617 	ldw	r2,-32232(gp)
 90a304c:	e0bfff15 	stw	r2,-4(fp)
 90a3050:	00002506 	br	90a30e8 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 90a3054:	e0bfff17 	ldw	r2,-4(fp)
 90a3058:	00c24374 	movhi	r3,2317
 90a305c:	18d4f104 	addi	r3,r3,21444
 90a3060:	1085883a 	add	r2,r2,r2
 90a3064:	1085883a 	add	r2,r2,r2
 90a3068:	10c5883a 	add	r2,r2,r3
 90a306c:	11400017 	ldw	r5,0(r2)
 90a3070:	01024374 	movhi	r4,2317
 90a3074:	213ee104 	addi	r4,r4,-1148
 90a3078:	90833900 	call	9083390 <printf>
#endif
      if(closers[n])
 90a307c:	e0bfff17 	ldw	r2,-4(fp)
 90a3080:	00c24374 	movhi	r3,2317
 90a3084:	18d4f104 	addi	r3,r3,21444
 90a3088:	1085883a 	add	r2,r2,r2
 90a308c:	1085883a 	add	r2,r2,r2
 90a3090:	10c5883a 	add	r2,r2,r3
 90a3094:	10800017 	ldw	r2,0(r2)
 90a3098:	1005003a 	cmpeq	r2,r2,zero
 90a309c:	10000f1e 	bne	r2,zero,90a30dc <ip_exit+0xa4>
      {
         (*closers[n])();
 90a30a0:	e0bfff17 	ldw	r2,-4(fp)
 90a30a4:	00c24374 	movhi	r3,2317
 90a30a8:	18d4f104 	addi	r3,r3,21444
 90a30ac:	1085883a 	add	r2,r2,r2
 90a30b0:	1085883a 	add	r2,r2,r2
 90a30b4:	10c5883a 	add	r2,r2,r3
 90a30b8:	10800017 	ldw	r2,0(r2)
 90a30bc:	103ee83a 	callr	r2
         closers[n] = NULL;
 90a30c0:	e0bfff17 	ldw	r2,-4(fp)
 90a30c4:	00c24374 	movhi	r3,2317
 90a30c8:	18d4f104 	addi	r3,r3,21444
 90a30cc:	1085883a 	add	r2,r2,r2
 90a30d0:	1085883a 	add	r2,r2,r2
 90a30d4:	10c5883a 	add	r2,r2,r3
 90a30d8:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 90a30dc:	e0bfff17 	ldw	r2,-4(fp)
 90a30e0:	10bfffc4 	addi	r2,r2,-1
 90a30e4:	e0bfff15 	stw	r2,-4(fp)
 90a30e8:	e0bfff17 	ldw	r2,-4(fp)
 90a30ec:	1004c03a 	cmpne	r2,r2,zero
 90a30f0:	103fd81e 	bne	r2,zero,90a3054 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 90a30f4:	e037883a 	mov	sp,fp
 90a30f8:	dfc00117 	ldw	ra,4(sp)
 90a30fc:	df000017 	ldw	fp,0(sp)
 90a3100:	dec00204 	addi	sp,sp,8
 90a3104:	f800283a 	ret

090a3108 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 90a3108:	defffa04 	addi	sp,sp,-24
 90a310c:	dfc00515 	stw	ra,20(sp)
 90a3110:	df000415 	stw	fp,16(sp)
 90a3114:	df000404 	addi	fp,sp,16
 90a3118:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 90a311c:	008243b4 	movhi	r2,2318
 90a3120:	10b82704 	addi	r2,r2,-8036
 90a3124:	10800017 	ldw	r2,0(r2)
 90a3128:	e0bffc15 	stw	r2,-16(fp)
 90a312c:	e03ffd15 	stw	zero,-12(fp)
 90a3130:	00000c06 	br	90a3164 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 90a3134:	e0fffc17 	ldw	r3,-16(fp)
 90a3138:	e0bffe17 	ldw	r2,-8(fp)
 90a313c:	1880031e 	bne	r3,r2,90a314c <if_netnumber+0x44>
        return (int)i;
 90a3140:	e0bffd17 	ldw	r2,-12(fp)
 90a3144:	e0bfff15 	stw	r2,-4(fp)
 90a3148:	00000d06 	br	90a3180 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 90a314c:	e0bffc17 	ldw	r2,-16(fp)
 90a3150:	10800017 	ldw	r2,0(r2)
 90a3154:	e0bffc15 	stw	r2,-16(fp)
 90a3158:	e0bffd17 	ldw	r2,-12(fp)
 90a315c:	10800044 	addi	r2,r2,1
 90a3160:	e0bffd15 	stw	r2,-12(fp)
 90a3164:	e0bffc17 	ldw	r2,-16(fp)
 90a3168:	1004c03a 	cmpne	r2,r2,zero
 90a316c:	103ff11e 	bne	r2,zero,90a3134 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 90a3170:	01024374 	movhi	r4,2317
 90a3174:	213ee804 	addi	r4,r4,-1120
 90a3178:	90a537c0 	call	90a537c <panic>
   return 0;
 90a317c:	e03fff15 	stw	zero,-4(fp)
 90a3180:	e0bfff17 	ldw	r2,-4(fp)
}
 90a3184:	e037883a 	mov	sp,fp
 90a3188:	dfc00117 	ldw	ra,4(sp)
 90a318c:	df000017 	ldw	fp,0(sp)
 90a3190:	dec00204 	addi	sp,sp,8
 90a3194:	f800283a 	ret

090a3198 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 90a3198:	defffd04 	addi	sp,sp,-12
 90a319c:	dfc00215 	stw	ra,8(sp)
 90a31a0:	df000115 	stw	fp,4(sp)
 90a31a4:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 90a31a8:	00804034 	movhi	r2,256
 90a31ac:	10803804 	addi	r2,r2,224
 90a31b0:	d0a08915 	stw	r2,-32220(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 90a31b4:	00808034 	movhi	r2,512
 90a31b8:	10803804 	addi	r2,r2,224
 90a31bc:	d0a08a15 	stw	r2,-32216(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 90a31c0:	008243b4 	movhi	r2,2318
 90a31c4:	10b82704 	addi	r2,r2,-8036
 90a31c8:	10800017 	ldw	r2,0(r2)
 90a31cc:	e0bfff15 	stw	r2,-4(fp)
 90a31d0:	00001006 	br	90a3214 <igmp_init+0x7c>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 90a31d4:	e0bfff17 	ldw	r2,-4(fp)
 90a31d8:	10802f03 	ldbu	r2,188(r2)
 90a31dc:	10803fcc 	andi	r2,r2,255
 90a31e0:	10800058 	cmpnei	r2,r2,1
 90a31e4:	1000041e 	bne	r2,zero,90a31f8 <igmp_init+0x60>
      {
         ifp->igmpv1_rtr_present = 1;
 90a31e8:	e0ffff17 	ldw	r3,-4(fp)
 90a31ec:	00800044 	movi	r2,1
 90a31f0:	18802d05 	stb	r2,180(r3)
 90a31f4:	00000406 	br	90a3208 <igmp_init+0x70>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 90a31f8:	e0bfff17 	ldw	r2,-4(fp)
 90a31fc:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 90a3200:	e0bfff17 	ldw	r2,-4(fp)
 90a3204:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 90a3208:	e0bfff17 	ldw	r2,-4(fp)
 90a320c:	10800017 	ldw	r2,0(r2)
 90a3210:	e0bfff15 	stw	r2,-4(fp)
 90a3214:	e0bfff17 	ldw	r2,-4(fp)
 90a3218:	1004c03a 	cmpne	r2,r2,zero
 90a321c:	103fed1e 	bne	r2,zero,90a31d4 <igmp_init+0x3c>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 90a3220:	00824374 	movhi	r2,2317
 90a3224:	108f2e04 	addi	r2,r2,15544
 90a3228:	11000017 	ldw	r4,0(r2)
 90a322c:	908d0380 	call	908d038 <__floatunsidf>
 90a3230:	100b883a 	mov	r5,r2
 90a3234:	180d883a 	mov	r6,r3
 90a3238:	2809883a 	mov	r4,r5
 90a323c:	300b883a 	mov	r5,r6
 90a3240:	000d883a 	mov	r6,zero
 90a3244:	01d00d34 	movhi	r7,16436
 90a3248:	908c5400 	call	908c540 <__adddf3>
 90a324c:	1009883a 	mov	r4,r2
 90a3250:	180b883a 	mov	r5,r3
 90a3254:	2005883a 	mov	r2,r4
 90a3258:	2807883a 	mov	r3,r5
 90a325c:	1009883a 	mov	r4,r2
 90a3260:	180b883a 	mov	r5,r3
 90a3264:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90a3268:	d0a08815 	stw	r2,-32224(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 90a326c:	d0208715 	stw	zero,-32228(gp)

   return IGMP_OK;
 90a3270:	0005883a 	mov	r2,zero
}
 90a3274:	e037883a 	mov	sp,fp
 90a3278:	dfc00117 	ldw	ra,4(sp)
 90a327c:	df000017 	ldw	fp,0(sp)
 90a3280:	dec00204 	addi	sp,sp,8
 90a3284:	f800283a 	ret

090a3288 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 90a3288:	defff904 	addi	sp,sp,-28
 90a328c:	dfc00615 	stw	ra,24(sp)
 90a3290:	df000515 	stw	fp,20(sp)
 90a3294:	df000504 	addi	fp,sp,20
 90a3298:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 90a329c:	008243b4 	movhi	r2,2318
 90a32a0:	10b5ea04 	addi	r2,r2,-10328
 90a32a4:	10800017 	ldw	r2,0(r2)
 90a32a8:	10c00044 	addi	r3,r2,1
 90a32ac:	008243b4 	movhi	r2,2318
 90a32b0:	10b5ea04 	addi	r2,r2,-10328
 90a32b4:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 90a32b8:	e13ffd17 	ldw	r4,-12(fp)
 90a32bc:	90a3b540 	call	90a3b54 <igmp_validate>
 90a32c0:	e0bffb15 	stw	r2,-20(fp)
 90a32c4:	e0bffb17 	ldw	r2,-20(fp)
 90a32c8:	1004c03a 	cmpne	r2,r2,zero
 90a32cc:	10001e1e 	bne	r2,zero,90a3348 <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 90a32d0:	e0bffd17 	ldw	r2,-12(fp)
 90a32d4:	10800617 	ldw	r2,24(r2)
 90a32d8:	10802f03 	ldbu	r2,188(r2)
 90a32dc:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 90a32e0:	e0bffc03 	ldbu	r2,-16(fp)
 90a32e4:	e0bfff15 	stw	r2,-4(fp)
 90a32e8:	e0ffff17 	ldw	r3,-4(fp)
 90a32ec:	18800060 	cmpeqi	r2,r3,1
 90a32f0:	1000041e 	bne	r2,zero,90a3304 <igmp_input+0x7c>
 90a32f4:	e0ffff17 	ldw	r3,-4(fp)
 90a32f8:	188000a0 	cmpeqi	r2,r3,2
 90a32fc:	1000051e 	bne	r2,zero,90a3314 <igmp_input+0x8c>
 90a3300:	00000806 	br	90a3324 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 90a3304:	e13ffd17 	ldw	r4,-12(fp)
 90a3308:	90c4bdc0 	call	90c4bdc <igmpv1_input>
 90a330c:	e0bffe15 	stw	r2,-8(fp)
 90a3310:	00001506 	br	90a3368 <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 90a3314:	e13ffd17 	ldw	r4,-12(fp)
 90a3318:	90c4ecc0 	call	90c4ecc <igmpv2_input>
 90a331c:	e0bffe15 	stw	r2,-8(fp)
 90a3320:	00001106 	br	90a3368 <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 90a3324:	008243b4 	movhi	r2,2318
 90a3328:	10b5ea04 	addi	r2,r2,-10328
 90a332c:	10800d17 	ldw	r2,52(r2)
 90a3330:	10c00044 	addi	r3,r2,1
 90a3334:	008243b4 	movhi	r2,2318
 90a3338:	10b5ea04 	addi	r2,r2,-10328
 90a333c:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 90a3340:	00bfffc4 	movi	r2,-1
 90a3344:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a3348:	01000084 	movi	r4,2
 90a334c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90a3350:	e13ffd17 	ldw	r4,-12(fp)
 90a3354:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a3358:	01000084 	movi	r4,2
 90a335c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      
   return rc;
 90a3360:	e0bffb17 	ldw	r2,-20(fp)
 90a3364:	e0bffe15 	stw	r2,-8(fp)
 90a3368:	e0bffe17 	ldw	r2,-8(fp)
}
 90a336c:	e037883a 	mov	sp,fp
 90a3370:	dfc00117 	ldw	ra,4(sp)
 90a3374:	df000017 	ldw	fp,0(sp)
 90a3378:	dec00204 	addi	sp,sp,8
 90a337c:	f800283a 	ret

090a3380 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 90a3380:	defffa04 	addi	sp,sp,-24
 90a3384:	dfc00515 	stw	ra,20(sp)
 90a3388:	df000415 	stw	fp,16(sp)
 90a338c:	dc400315 	stw	r17,12(sp)
 90a3390:	dc000215 	stw	r16,8(sp)
 90a3394:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 90a3398:	0009883a 	mov	r4,zero
 90a339c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 90a33a0:	d0a08717 	ldw	r2,-32228(gp)
 90a33a4:	1004c03a 	cmpne	r2,r2,zero
 90a33a8:	1000031e 	bne	r2,zero,90a33b8 <igmp_fasttimo+0x38>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 90a33ac:	0009883a 	mov	r4,zero
 90a33b0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return;
 90a33b4:	00007806 	br	90a3598 <igmp_fasttimo+0x218>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a33b8:	008243b4 	movhi	r2,2318
 90a33bc:	10b82704 	addi	r2,r2,-8036
 90a33c0:	10800017 	ldw	r2,0(r2)
 90a33c4:	e0bffe15 	stw	r2,-8(fp)
 90a33c8:	00005b06 	br	90a3538 <igmp_fasttimo+0x1b8>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 90a33cc:	e0bffe17 	ldw	r2,-8(fp)
 90a33d0:	10802c17 	ldw	r2,176(r2)
 90a33d4:	e0bfff15 	stw	r2,-4(fp)
 90a33d8:	00005106 	br	90a3520 <igmp_fasttimo+0x1a0>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 90a33dc:	e0bfff17 	ldw	r2,-4(fp)
 90a33e0:	10800017 	ldw	r2,0(r2)
 90a33e4:	1005003a 	cmpeq	r2,r2,zero
 90a33e8:	10004a1e 	bne	r2,zero,90a3514 <igmp_fasttimo+0x194>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 90a33ec:	e0bfff17 	ldw	r2,-4(fp)
 90a33f0:	10800317 	ldw	r2,12(r2)
 90a33f4:	1005003a 	cmpeq	r2,r2,zero
 90a33f8:	1000461e 	bne	r2,zero,90a3514 <igmp_fasttimo+0x194>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 90a33fc:	e0bfff17 	ldw	r2,-4(fp)
 90a3400:	10800317 	ldw	r2,12(r2)
 90a3404:	10ffffc4 	addi	r3,r2,-1
 90a3408:	e0bfff17 	ldw	r2,-4(fp)
 90a340c:	10c00315 	stw	r3,12(r2)
 90a3410:	e0bfff17 	ldw	r2,-4(fp)
 90a3414:	10800317 	ldw	r2,12(r2)
 90a3418:	1004c03a 	cmpne	r2,r2,zero
 90a341c:	10003d1e 	bne	r2,zero,90a3514 <igmp_fasttimo+0x194>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 90a3420:	e0bffe17 	ldw	r2,-8(fp)
 90a3424:	10802d03 	ldbu	r2,180(r2)
 90a3428:	10803fcc 	andi	r2,r2,255
 90a342c:	1005003a 	cmpeq	r2,r2,zero
 90a3430:	1000041e 	bne	r2,zero,90a3444 <igmp_fasttimo+0xc4>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 90a3434:	01000484 	movi	r4,18
 90a3438:	e17fff17 	ldw	r5,-4(fp)
 90a343c:	90a35b40 	call	90a35b4 <igmp_send>
 90a3440:	00000306 	br	90a3450 <igmp_fasttimo+0xd0>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 90a3444:	01000584 	movi	r4,22
 90a3448:	e17fff17 	ldw	r5,-4(fp)
 90a344c:	90a35b40 	call	90a35b4 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a3450:	e0bffe17 	ldw	r2,-8(fp)
 90a3454:	10802f03 	ldbu	r2,188(r2)
 90a3458:	10803fcc 	andi	r2,r2,255
 90a345c:	10800098 	cmpnei	r2,r2,2
 90a3460:	1000291e 	bne	r2,zero,90a3508 <igmp_fasttimo+0x188>
            {
               inm->last2send_report = IGMP_TRUE;
 90a3464:	e0ffff17 	ldw	r3,-4(fp)
 90a3468:	00800044 	movi	r2,1
 90a346c:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 90a3470:	e0bffe17 	ldw	r2,-8(fp)
 90a3474:	10802d03 	ldbu	r2,180(r2)
 90a3478:	10803fcc 	andi	r2,r2,255
 90a347c:	1005003a 	cmpeq	r2,r2,zero
 90a3480:	1000211e 	bne	r2,zero,90a3508 <igmp_fasttimo+0x188>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 90a3484:	00824374 	movhi	r2,2317
 90a3488:	108f2e04 	addi	r2,r2,15544
 90a348c:	11000017 	ldw	r4,0(r2)
 90a3490:	908d0380 	call	908d038 <__floatunsidf>
 90a3494:	1021883a 	mov	r16,r2
 90a3498:	1823883a 	mov	r17,r3
 90a349c:	e0bffe17 	ldw	r2,-8(fp)
 90a34a0:	11002e17 	ldw	r4,184(r2)
 90a34a4:	908d0380 	call	908d038 <__floatunsidf>
 90a34a8:	100b883a 	mov	r5,r2
 90a34ac:	180d883a 	mov	r6,r3
 90a34b0:	2809883a 	mov	r4,r5
 90a34b4:	300b883a 	mov	r5,r6
 90a34b8:	000d883a 	mov	r6,zero
 90a34bc:	01d03934 	movhi	r7,16612
 90a34c0:	39e20004 	addi	r7,r7,-30720
 90a34c4:	908c5400 	call	908c540 <__adddf3>
 90a34c8:	1009883a 	mov	r4,r2
 90a34cc:	180b883a 	mov	r5,r3
 90a34d0:	2005883a 	mov	r2,r4
 90a34d4:	2807883a 	mov	r3,r5
 90a34d8:	8009883a 	mov	r4,r16
 90a34dc:	880b883a 	mov	r5,r17
 90a34e0:	100d883a 	mov	r6,r2
 90a34e4:	180f883a 	mov	r7,r3
 90a34e8:	908ccd00 	call	908ccd0 <__gtdf2>
 90a34ec:	10800048 	cmpgei	r2,r2,1
 90a34f0:	1000011e 	bne	r2,zero,90a34f8 <igmp_fasttimo+0x178>
 90a34f4:	00000406 	br	90a3508 <igmp_fasttimo+0x188>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 90a34f8:	e0bffe17 	ldw	r2,-8(fp)
 90a34fc:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 90a3500:	e0bffe17 	ldw	r2,-8(fp)
 90a3504:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 90a3508:	d0a08717 	ldw	r2,-32228(gp)
 90a350c:	10bfffc4 	addi	r2,r2,-1
 90a3510:	d0a08715 	stw	r2,-32228(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 90a3514:	e0bfff17 	ldw	r2,-4(fp)
 90a3518:	10800517 	ldw	r2,20(r2)
 90a351c:	e0bfff15 	stw	r2,-4(fp)
 90a3520:	e0bfff17 	ldw	r2,-4(fp)
 90a3524:	1004c03a 	cmpne	r2,r2,zero
 90a3528:	103fac1e 	bne	r2,zero,90a33dc <igmp_fasttimo+0x5c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a352c:	e0bffe17 	ldw	r2,-8(fp)
 90a3530:	10800017 	ldw	r2,0(r2)
 90a3534:	e0bffe15 	stw	r2,-8(fp)
 90a3538:	e0bffe17 	ldw	r2,-8(fp)
 90a353c:	1004c03a 	cmpne	r2,r2,zero
 90a3540:	103fa21e 	bne	r2,zero,90a33cc <igmp_fasttimo+0x4c>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 90a3544:	00824374 	movhi	r2,2317
 90a3548:	108f2e04 	addi	r2,r2,15544
 90a354c:	11000017 	ldw	r4,0(r2)
 90a3550:	908d0380 	call	908d038 <__floatunsidf>
 90a3554:	100b883a 	mov	r5,r2
 90a3558:	180d883a 	mov	r6,r3
 90a355c:	2809883a 	mov	r4,r5
 90a3560:	300b883a 	mov	r5,r6
 90a3564:	000d883a 	mov	r6,zero
 90a3568:	01d00d34 	movhi	r7,16436
 90a356c:	908c5400 	call	908c540 <__adddf3>
 90a3570:	1009883a 	mov	r4,r2
 90a3574:	180b883a 	mov	r5,r3
 90a3578:	2005883a 	mov	r2,r4
 90a357c:	2807883a 	mov	r3,r5
 90a3580:	1009883a 	mov	r4,r2
 90a3584:	180b883a 	mov	r5,r3
 90a3588:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90a358c:	d0a08815 	stw	r2,-32224(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90a3590:	0009883a 	mov	r4,zero
 90a3594:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   
   return;
}
 90a3598:	e037883a 	mov	sp,fp
 90a359c:	dfc00317 	ldw	ra,12(sp)
 90a35a0:	df000217 	ldw	fp,8(sp)
 90a35a4:	dc400117 	ldw	r17,4(sp)
 90a35a8:	dc000017 	ldw	r16,0(sp)
 90a35ac:	dec00404 	addi	sp,sp,16
 90a35b0:	f800283a 	ret

090a35b4 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 90a35b4:	deffdd04 	addi	sp,sp,-140
 90a35b8:	dfc02215 	stw	ra,136(sp)
 90a35bc:	df002115 	stw	fp,132(sp)
 90a35c0:	df002104 	addi	fp,sp,132
 90a35c4:	e17fff15 	stw	r5,-4(fp)
 90a35c8:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 90a35cc:	00800504 	movi	r2,20
 90a35d0:	e0bffd05 	stb	r2,-12(fp)
 90a35d4:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 90a35d8:	00824374 	movhi	r2,2317
 90a35dc:	108f0704 	addi	r2,r2,15388
 90a35e0:	10800017 	ldw	r2,0(r2)
 90a35e4:	10800704 	addi	r2,r2,28
 90a35e8:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a35ec:	e0bffe03 	ldbu	r2,-8(fp)
 90a35f0:	108005e0 	cmpeqi	r2,r2,23
 90a35f4:	1000031e 	bne	r2,zero,90a3604 <igmp_send+0x50>
 90a35f8:	e0bffe03 	ldbu	r2,-8(fp)
 90a35fc:	10800598 	cmpnei	r2,r2,22
 90a3600:	1000031e 	bne	r2,zero,90a3610 <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 90a3604:	e0bfdf03 	ldbu	r2,-132(fp)
 90a3608:	10800104 	addi	r2,r2,4
 90a360c:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 90a3610:	01000084 	movi	r4,2
 90a3614:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 90a3618:	e13fdf03 	ldbu	r4,-132(fp)
 90a361c:	90a98340 	call	90a9834 <pk_alloc>
 90a3620:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90a3624:	01000084 	movi	r4,2
 90a3628:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 90a362c:	e0bfe617 	ldw	r2,-104(fp)
 90a3630:	1004c03a 	cmpne	r2,r2,zero
 90a3634:	1000081e 	bne	r2,zero,90a3658 <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 90a3638:	008243b4 	movhi	r2,2318
 90a363c:	10b5ea04 	addi	r2,r2,-10328
 90a3640:	10800c17 	ldw	r2,48(r2)
 90a3644:	10c00044 	addi	r3,r2,1
 90a3648:	008243b4 	movhi	r2,2318
 90a364c:	10b5ea04 	addi	r2,r2,-10328
 90a3650:	10c00c15 	stw	r3,48(r2)
      return;
 90a3654:	00007c06 	br	90a3848 <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 90a3658:	e0bfe617 	ldw	r2,-104(fp)
 90a365c:	10800317 	ldw	r2,12(r2)
 90a3660:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 90a3664:	e0bfff17 	ldw	r2,-4(fp)
 90a3668:	10800117 	ldw	r2,4(r2)
 90a366c:	10c00a17 	ldw	r3,40(r2)
 90a3670:	e0bfe317 	ldw	r2,-116(fp)
 90a3674:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 90a3678:	e0bffe03 	ldbu	r2,-8(fp)
 90a367c:	108005d8 	cmpnei	r2,r2,23
 90a3680:	1000041e 	bne	r2,zero,90a3694 <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 90a3684:	d0e08a17 	ldw	r3,-32216(gp)
 90a3688:	e0bfe317 	ldw	r2,-116(fp)
 90a368c:	10c00415 	stw	r3,16(r2)
 90a3690:	00000406 	br	90a36a4 <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 90a3694:	e0bfff17 	ldw	r2,-4(fp)
 90a3698:	10c00017 	ldw	r3,0(r2)
 90a369c:	e0bfe317 	ldw	r2,-116(fp)
 90a36a0:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 90a36a4:	e0bfe317 	ldw	r2,-116(fp)
 90a36a8:	10c00417 	ldw	r3,16(r2)
 90a36ac:	e0bfe617 	ldw	r2,-104(fp)
 90a36b0:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 90a36b4:	e0bfe617 	ldw	r2,-104(fp)
 90a36b8:	10800317 	ldw	r2,12(r2)
 90a36bc:	10800504 	addi	r2,r2,20
 90a36c0:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a36c4:	e0bffe03 	ldbu	r2,-8(fp)
 90a36c8:	108005e0 	cmpeqi	r2,r2,23
 90a36cc:	1000031e 	bne	r2,zero,90a36dc <igmp_send+0x128>
 90a36d0:	e0bffe03 	ldbu	r2,-8(fp)
 90a36d4:	10800598 	cmpnei	r2,r2,22
 90a36d8:	1000061e 	bne	r2,zero,90a36f4 <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 90a36dc:	e0bfe117 	ldw	r2,-124(fp)
 90a36e0:	10800104 	addi	r2,r2,4
 90a36e4:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 90a36e8:	e0bffd04 	addi	r2,fp,-12
 90a36ec:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a36f0:	00000306 	br	90a3700 <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 90a36f4:	e0bffd04 	addi	r2,fp,-12
 90a36f8:	10800044 	addi	r2,r2,1
 90a36fc:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 90a3700:	e0bfe117 	ldw	r2,-124(fp)
 90a3704:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 90a3708:	e0ffe517 	ldw	r3,-108(fp)
 90a370c:	e0bffe03 	ldbu	r2,-8(fp)
 90a3710:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 90a3714:	e0bfe517 	ldw	r2,-108(fp)
 90a3718:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 90a371c:	e0bfff17 	ldw	r2,-4(fp)
 90a3720:	10c00017 	ldw	r3,0(r2)
 90a3724:	e0bfe517 	ldw	r2,-108(fp)
 90a3728:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 90a372c:	e0bfe517 	ldw	r2,-108(fp)
 90a3730:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 90a3734:	e13fe517 	ldw	r4,-108(fp)
 90a3738:	01400104 	movi	r5,4
 90a373c:	90a4ef40 	call	90a4ef4 <cksum>
 90a3740:	0084303a 	nor	r2,zero,r2
 90a3744:	1007883a 	mov	r3,r2
 90a3748:	e0bfe517 	ldw	r2,-108(fp)
 90a374c:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 90a3750:	e0bfe704 	addi	r2,fp,-100
 90a3754:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 90a3758:	e0bfe417 	ldw	r2,-112(fp)
 90a375c:	1009883a 	mov	r4,r2
 90a3760:	01801604 	movi	r6,88
 90a3764:	000b883a 	mov	r5,zero
 90a3768:	90832780 	call	9083278 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 90a376c:	e0bfff17 	ldw	r2,-4(fp)
 90a3770:	10c00117 	ldw	r3,4(r2)
 90a3774:	e0bfe417 	ldw	r2,-112(fp)
 90a3778:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 90a377c:	e0ffe417 	ldw	r3,-112(fp)
 90a3780:	00800044 	movi	r2,1
 90a3784:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 90a3788:	e0bfe417 	ldw	r2,-112(fp)
 90a378c:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 90a3790:	e0ffe117 	ldw	r3,-124(fp)
 90a3794:	e0bfe617 	ldw	r2,-104(fp)
 90a3798:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 90a379c:	e0ffe617 	ldw	r3,-104(fp)
 90a37a0:	00800204 	movi	r2,8
 90a37a4:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 90a37a8:	e0ffe617 	ldw	r3,-104(fp)
 90a37ac:	e0bfe417 	ldw	r2,-112(fp)
 90a37b0:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 90a37b4:	01000084 	movi	r4,2
 90a37b8:	e17fe617 	ldw	r5,-104(fp)
 90a37bc:	e1bfe017 	ldw	r6,-128(fp)
 90a37c0:	90beb0c0 	call	90beb0c <ip_write2>
 90a37c4:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 90a37c8:	e0bffe03 	ldbu	r2,-8(fp)
 90a37cc:	108005d8 	cmpnei	r2,r2,23
 90a37d0:	1000081e 	bne	r2,zero,90a37f4 <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 90a37d4:	008243b4 	movhi	r2,2318
 90a37d8:	10b5ea04 	addi	r2,r2,-10328
 90a37dc:	10801717 	ldw	r2,92(r2)
 90a37e0:	10c00044 	addi	r3,r2,1
 90a37e4:	008243b4 	movhi	r2,2318
 90a37e8:	10b5ea04 	addi	r2,r2,-10328
 90a37ec:	10c01715 	stw	r3,92(r2)
 90a37f0:	00001506 	br	90a3848 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 90a37f4:	e0bffe03 	ldbu	r2,-8(fp)
 90a37f8:	10800598 	cmpnei	r2,r2,22
 90a37fc:	1000081e 	bne	r2,zero,90a3820 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 90a3800:	008243b4 	movhi	r2,2318
 90a3804:	10b5ea04 	addi	r2,r2,-10328
 90a3808:	10801817 	ldw	r2,96(r2)
 90a380c:	10c00044 	addi	r3,r2,1
 90a3810:	008243b4 	movhi	r2,2318
 90a3814:	10b5ea04 	addi	r2,r2,-10328
 90a3818:	10c01815 	stw	r3,96(r2)
 90a381c:	00000a06 	br	90a3848 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 90a3820:	e0bffe03 	ldbu	r2,-8(fp)
 90a3824:	10800498 	cmpnei	r2,r2,18
 90a3828:	1000071e 	bne	r2,zero,90a3848 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 90a382c:	008243b4 	movhi	r2,2318
 90a3830:	10b5ea04 	addi	r2,r2,-10328
 90a3834:	10801617 	ldw	r2,88(r2)
 90a3838:	10c00044 	addi	r3,r2,1
 90a383c:	008243b4 	movhi	r2,2318
 90a3840:	10b5ea04 	addi	r2,r2,-10328
 90a3844:	10c01615 	stw	r3,88(r2)
}
 90a3848:	e037883a 	mov	sp,fp
 90a384c:	dfc00117 	ldw	ra,4(sp)
 90a3850:	df000017 	ldw	fp,0(sp)
 90a3854:	dec00204 	addi	sp,sp,8
 90a3858:	f800283a 	ret

090a385c <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 90a385c:	defffc04 	addi	sp,sp,-16
 90a3860:	dfc00315 	stw	ra,12(sp)
 90a3864:	df000215 	stw	fp,8(sp)
 90a3868:	df000204 	addi	fp,sp,8
 90a386c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 90a3870:	e0bfff17 	ldw	r2,-4(fp)
 90a3874:	10800117 	ldw	r2,4(r2)
 90a3878:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 90a387c:	e0bfff17 	ldw	r2,-4(fp)
 90a3880:	10c00017 	ldw	r3,0(r2)
 90a3884:	d0a08917 	ldw	r2,-32220(gp)
 90a3888:	1880031e 	bne	r3,r2,90a3898 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 90a388c:	e0bfff17 	ldw	r2,-4(fp)
 90a3890:	10000315 	stw	zero,12(r2)
 90a3894:	00008b06 	br	90a3ac4 <igmp_joingroup+0x268>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 90a3898:	e0bffe17 	ldw	r2,-8(fp)
 90a389c:	10802d03 	ldbu	r2,180(r2)
 90a38a0:	10803fcc 	andi	r2,r2,255
 90a38a4:	1005003a 	cmpeq	r2,r2,zero
 90a38a8:	10003e1e 	bne	r2,zero,90a39a4 <igmp_joingroup+0x148>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 90a38ac:	01000484 	movi	r4,18
 90a38b0:	e17fff17 	ldw	r5,-4(fp)
 90a38b4:	90a35b40 	call	90a35b4 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 90a38b8:	008243b4 	movhi	r2,2318
 90a38bc:	10b82c04 	addi	r2,r2,-8016
 90a38c0:	11000217 	ldw	r4,8(r2)
 90a38c4:	008243b4 	movhi	r2,2318
 90a38c8:	10b5e604 	addi	r2,r2,-10344
 90a38cc:	10800017 	ldw	r2,0(r2)
 90a38d0:	10800a17 	ldw	r2,40(r2)
 90a38d4:	1004d63a 	srli	r2,r2,24
 90a38d8:	10c03fcc 	andi	r3,r2,255
 90a38dc:	008243b4 	movhi	r2,2318
 90a38e0:	10b5e604 	addi	r2,r2,-10344
 90a38e4:	10800017 	ldw	r2,0(r2)
 90a38e8:	10800a17 	ldw	r2,40(r2)
 90a38ec:	1004d23a 	srli	r2,r2,8
 90a38f0:	10bfc00c 	andi	r2,r2,65280
 90a38f4:	1886b03a 	or	r3,r3,r2
 90a38f8:	008243b4 	movhi	r2,2318
 90a38fc:	10b5e604 	addi	r2,r2,-10344
 90a3900:	10800017 	ldw	r2,0(r2)
 90a3904:	10800a17 	ldw	r2,40(r2)
 90a3908:	10bfc00c 	andi	r2,r2,65280
 90a390c:	1004923a 	slli	r2,r2,8
 90a3910:	1886b03a 	or	r3,r3,r2
 90a3914:	008243b4 	movhi	r2,2318
 90a3918:	10b5e604 	addi	r2,r2,-10344
 90a391c:	10800017 	ldw	r2,0(r2)
 90a3920:	10800a17 	ldw	r2,40(r2)
 90a3924:	10803fcc 	andi	r2,r2,255
 90a3928:	1004963a 	slli	r2,r2,24
 90a392c:	1884b03a 	or	r2,r3,r2
 90a3930:	2089883a 	add	r4,r4,r2
 90a3934:	e0bfff17 	ldw	r2,-4(fp)
 90a3938:	10800017 	ldw	r2,0(r2)
 90a393c:	1004d63a 	srli	r2,r2,24
 90a3940:	10c03fcc 	andi	r3,r2,255
 90a3944:	e0bfff17 	ldw	r2,-4(fp)
 90a3948:	10800017 	ldw	r2,0(r2)
 90a394c:	1004d23a 	srli	r2,r2,8
 90a3950:	10bfc00c 	andi	r2,r2,65280
 90a3954:	1886b03a 	or	r3,r3,r2
 90a3958:	e0bfff17 	ldw	r2,-4(fp)
 90a395c:	10800017 	ldw	r2,0(r2)
 90a3960:	10bfc00c 	andi	r2,r2,65280
 90a3964:	1004923a 	slli	r2,r2,8
 90a3968:	1886b03a 	or	r3,r3,r2
 90a396c:	e0bfff17 	ldw	r2,-4(fp)
 90a3970:	10800017 	ldw	r2,0(r2)
 90a3974:	10803fcc 	andi	r2,r2,255
 90a3978:	1004963a 	slli	r2,r2,24
 90a397c:	1884b03a 	or	r2,r3,r2
 90a3980:	2087883a 	add	r3,r4,r2
 90a3984:	00800c84 	movi	r2,50
 90a3988:	1885203a 	divu	r2,r3,r2
 90a398c:	10800ca4 	muli	r2,r2,50
 90a3990:	1885c83a 	sub	r2,r3,r2
 90a3994:	10c00044 	addi	r3,r2,1
 90a3998:	e0bfff17 	ldw	r2,-4(fp)
 90a399c:	10c00315 	stw	r3,12(r2)
 90a39a0:	00003d06 	br	90a3a98 <igmp_joingroup+0x23c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 90a39a4:	01000584 	movi	r4,22
 90a39a8:	e17fff17 	ldw	r5,-4(fp)
 90a39ac:	90a35b40 	call	90a35b4 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 90a39b0:	008243b4 	movhi	r2,2318
 90a39b4:	10b82c04 	addi	r2,r2,-8016
 90a39b8:	11000217 	ldw	r4,8(r2)
 90a39bc:	008243b4 	movhi	r2,2318
 90a39c0:	10b5e604 	addi	r2,r2,-10344
 90a39c4:	10800017 	ldw	r2,0(r2)
 90a39c8:	10800a17 	ldw	r2,40(r2)
 90a39cc:	1004d63a 	srli	r2,r2,24
 90a39d0:	10c03fcc 	andi	r3,r2,255
 90a39d4:	008243b4 	movhi	r2,2318
 90a39d8:	10b5e604 	addi	r2,r2,-10344
 90a39dc:	10800017 	ldw	r2,0(r2)
 90a39e0:	10800a17 	ldw	r2,40(r2)
 90a39e4:	1004d23a 	srli	r2,r2,8
 90a39e8:	10bfc00c 	andi	r2,r2,65280
 90a39ec:	1886b03a 	or	r3,r3,r2
 90a39f0:	008243b4 	movhi	r2,2318
 90a39f4:	10b5e604 	addi	r2,r2,-10344
 90a39f8:	10800017 	ldw	r2,0(r2)
 90a39fc:	10800a17 	ldw	r2,40(r2)
 90a3a00:	10bfc00c 	andi	r2,r2,65280
 90a3a04:	1004923a 	slli	r2,r2,8
 90a3a08:	1886b03a 	or	r3,r3,r2
 90a3a0c:	008243b4 	movhi	r2,2318
 90a3a10:	10b5e604 	addi	r2,r2,-10344
 90a3a14:	10800017 	ldw	r2,0(r2)
 90a3a18:	10800a17 	ldw	r2,40(r2)
 90a3a1c:	10803fcc 	andi	r2,r2,255
 90a3a20:	1004963a 	slli	r2,r2,24
 90a3a24:	1884b03a 	or	r2,r3,r2
 90a3a28:	2089883a 	add	r4,r4,r2
 90a3a2c:	e0bfff17 	ldw	r2,-4(fp)
 90a3a30:	10800017 	ldw	r2,0(r2)
 90a3a34:	1004d63a 	srli	r2,r2,24
 90a3a38:	10c03fcc 	andi	r3,r2,255
 90a3a3c:	e0bfff17 	ldw	r2,-4(fp)
 90a3a40:	10800017 	ldw	r2,0(r2)
 90a3a44:	1004d23a 	srli	r2,r2,8
 90a3a48:	10bfc00c 	andi	r2,r2,65280
 90a3a4c:	1886b03a 	or	r3,r3,r2
 90a3a50:	e0bfff17 	ldw	r2,-4(fp)
 90a3a54:	10800017 	ldw	r2,0(r2)
 90a3a58:	10bfc00c 	andi	r2,r2,65280
 90a3a5c:	1004923a 	slli	r2,r2,8
 90a3a60:	1886b03a 	or	r3,r3,r2
 90a3a64:	e0bfff17 	ldw	r2,-4(fp)
 90a3a68:	10800017 	ldw	r2,0(r2)
 90a3a6c:	10803fcc 	andi	r2,r2,255
 90a3a70:	1004963a 	slli	r2,r2,24
 90a3a74:	1884b03a 	or	r2,r3,r2
 90a3a78:	2087883a 	add	r3,r4,r2
 90a3a7c:	00800c84 	movi	r2,50
 90a3a80:	1885203a 	divu	r2,r3,r2
 90a3a84:	10800ca4 	muli	r2,r2,50
 90a3a88:	1885c83a 	sub	r2,r3,r2
 90a3a8c:	10c00044 	addi	r3,r2,1
 90a3a90:	e0bfff17 	ldw	r2,-4(fp)
 90a3a94:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a3a98:	e0bffe17 	ldw	r2,-8(fp)
 90a3a9c:	10802f03 	ldbu	r2,188(r2)
 90a3aa0:	10803fcc 	andi	r2,r2,255
 90a3aa4:	10800098 	cmpnei	r2,r2,2
 90a3aa8:	1000031e 	bne	r2,zero,90a3ab8 <igmp_joingroup+0x25c>
      {
         inm->last2send_report = IGMP_TRUE;
 90a3aac:	e0ffff17 	ldw	r3,-4(fp)
 90a3ab0:	00800044 	movi	r2,1
 90a3ab4:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 90a3ab8:	d0a08717 	ldw	r2,-32228(gp)
 90a3abc:	10800044 	addi	r2,r2,1
 90a3ac0:	d0a08715 	stw	r2,-32228(gp)
   }
   
   return;
}     
 90a3ac4:	e037883a 	mov	sp,fp
 90a3ac8:	dfc00117 	ldw	ra,4(sp)
 90a3acc:	df000017 	ldw	fp,0(sp)
 90a3ad0:	dec00204 	addi	sp,sp,8
 90a3ad4:	f800283a 	ret

090a3ad8 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 90a3ad8:	defffc04 	addi	sp,sp,-16
 90a3adc:	dfc00315 	stw	ra,12(sp)
 90a3ae0:	df000215 	stw	fp,8(sp)
 90a3ae4:	df000204 	addi	fp,sp,8
 90a3ae8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 90a3aec:	e0bfff17 	ldw	r2,-4(fp)
 90a3af0:	10800117 	ldw	r2,4(r2)
 90a3af4:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 90a3af8:	e0bffe17 	ldw	r2,-8(fp)
 90a3afc:	10802f03 	ldbu	r2,188(r2)
 90a3b00:	10803fcc 	andi	r2,r2,255
 90a3b04:	10800098 	cmpnei	r2,r2,2
 90a3b08:	10000d1e 	bne	r2,zero,90a3b40 <igmp_leavegroup+0x68>
 90a3b0c:	e0bffe17 	ldw	r2,-8(fp)
 90a3b10:	10802d03 	ldbu	r2,180(r2)
 90a3b14:	10803fcc 	andi	r2,r2,255
 90a3b18:	1004c03a 	cmpne	r2,r2,zero
 90a3b1c:	1000081e 	bne	r2,zero,90a3b40 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 90a3b20:	e0bfff17 	ldw	r2,-4(fp)
 90a3b24:	10800403 	ldbu	r2,16(r2)
 90a3b28:	10803fcc 	andi	r2,r2,255
 90a3b2c:	10800058 	cmpnei	r2,r2,1
 90a3b30:	1000031e 	bne	r2,zero,90a3b40 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 90a3b34:	010005c4 	movi	r4,23
 90a3b38:	e17fff17 	ldw	r5,-4(fp)
 90a3b3c:	90a35b40 	call	90a35b4 <igmp_send>
   }
   
   return;
}
 90a3b40:	e037883a 	mov	sp,fp
 90a3b44:	dfc00117 	ldw	ra,4(sp)
 90a3b48:	df000017 	ldw	fp,0(sp)
 90a3b4c:	dec00204 	addi	sp,sp,8
 90a3b50:	f800283a 	ret

090a3b54 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 90a3b54:	defff504 	addi	sp,sp,-44
 90a3b58:	dfc00a15 	stw	ra,40(sp)
 90a3b5c:	df000915 	stw	fp,36(sp)
 90a3b60:	df000904 	addi	fp,sp,36
 90a3b64:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 90a3b68:	e0bffe17 	ldw	r2,-8(fp)
 90a3b6c:	10800317 	ldw	r2,12(r2)
 90a3b70:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 90a3b74:	e0bffe17 	ldw	r2,-8(fp)
 90a3b78:	10c00417 	ldw	r3,16(r2)
 90a3b7c:	e0bffd17 	ldw	r2,-12(fp)
 90a3b80:	10800003 	ldbu	r2,0(r2)
 90a3b84:	10803fcc 	andi	r2,r2,255
 90a3b88:	108003cc 	andi	r2,r2,15
 90a3b8c:	1085883a 	add	r2,r2,r2
 90a3b90:	1085883a 	add	r2,r2,r2
 90a3b94:	1885c83a 	sub	r2,r3,r2
 90a3b98:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 90a3b9c:	e0bffc17 	ldw	r2,-16(fp)
 90a3ba0:	10800220 	cmpeqi	r2,r2,8
 90a3ba4:	10000a1e 	bne	r2,zero,90a3bd0 <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 90a3ba8:	008243b4 	movhi	r2,2318
 90a3bac:	10b5ea04 	addi	r2,r2,-10328
 90a3bb0:	10800a17 	ldw	r2,40(r2)
 90a3bb4:	10c00044 	addi	r3,r2,1
 90a3bb8:	008243b4 	movhi	r2,2318
 90a3bbc:	10b5ea04 	addi	r2,r2,-10328
 90a3bc0:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 90a3bc4:	00bff804 	movi	r2,-32
 90a3bc8:	e0bfff15 	stw	r2,-4(fp)
 90a3bcc:	0000b206 	br	90a3e98 <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 90a3bd0:	e0bffd17 	ldw	r2,-12(fp)
 90a3bd4:	10800003 	ldbu	r2,0(r2)
 90a3bd8:	10803fcc 	andi	r2,r2,255
 90a3bdc:	108003cc 	andi	r2,r2,15
 90a3be0:	1085883a 	add	r2,r2,r2
 90a3be4:	1085883a 	add	r2,r2,r2
 90a3be8:	1007883a 	mov	r3,r2
 90a3bec:	e0bffd17 	ldw	r2,-12(fp)
 90a3bf0:	1885883a 	add	r2,r3,r2
 90a3bf4:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 90a3bf8:	e0bffb17 	ldw	r2,-20(fp)
 90a3bfc:	1080008b 	ldhu	r2,2(r2)
 90a3c00:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 90a3c04:	e0bffb17 	ldw	r2,-20(fp)
 90a3c08:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 90a3c0c:	e0bffc17 	ldw	r2,-16(fp)
 90a3c10:	1005d07a 	srai	r2,r2,1
 90a3c14:	100b883a 	mov	r5,r2
 90a3c18:	e13ffb17 	ldw	r4,-20(fp)
 90a3c1c:	90a4ef40 	call	90a4ef4 <cksum>
 90a3c20:	0084303a 	nor	r2,zero,r2
 90a3c24:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 90a3c28:	e0fff98b 	ldhu	r3,-26(fp)
 90a3c2c:	e0bffa0b 	ldhu	r2,-24(fp)
 90a3c30:	18800d26 	beq	r3,r2,90a3c68 <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 90a3c34:	e0fffb17 	ldw	r3,-20(fp)
 90a3c38:	e0bffa0b 	ldhu	r2,-24(fp)
 90a3c3c:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 90a3c40:	008243b4 	movhi	r2,2318
 90a3c44:	10b5ea04 	addi	r2,r2,-10328
 90a3c48:	10800b17 	ldw	r2,44(r2)
 90a3c4c:	10c00044 	addi	r3,r2,1
 90a3c50:	008243b4 	movhi	r2,2318
 90a3c54:	10b5ea04 	addi	r2,r2,-10328
 90a3c58:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 90a3c5c:	00bff804 	movi	r2,-32
 90a3c60:	e0bfff15 	stw	r2,-4(fp)
 90a3c64:	00008c06 	br	90a3e98 <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 90a3c68:	e0bffb17 	ldw	r2,-20(fp)
 90a3c6c:	10800003 	ldbu	r2,0(r2)
 90a3c70:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 90a3c74:	e0bffb17 	ldw	r2,-20(fp)
 90a3c78:	10800117 	ldw	r2,4(r2)
 90a3c7c:	1004d63a 	srli	r2,r2,24
 90a3c80:	10c03fcc 	andi	r3,r2,255
 90a3c84:	e0bffb17 	ldw	r2,-20(fp)
 90a3c88:	10800117 	ldw	r2,4(r2)
 90a3c8c:	1004d23a 	srli	r2,r2,8
 90a3c90:	10bfc00c 	andi	r2,r2,65280
 90a3c94:	1886b03a 	or	r3,r3,r2
 90a3c98:	e0bffb17 	ldw	r2,-20(fp)
 90a3c9c:	10800117 	ldw	r2,4(r2)
 90a3ca0:	10bfc00c 	andi	r2,r2,65280
 90a3ca4:	1004923a 	slli	r2,r2,8
 90a3ca8:	1886b03a 	or	r3,r3,r2
 90a3cac:	e0bffb17 	ldw	r2,-20(fp)
 90a3cb0:	10800117 	ldw	r2,4(r2)
 90a3cb4:	10803fcc 	andi	r2,r2,255
 90a3cb8:	1004963a 	slli	r2,r2,24
 90a3cbc:	1884b03a 	or	r2,r3,r2
 90a3cc0:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 90a3cc4:	e0bffb17 	ldw	r2,-20(fp)
 90a3cc8:	10800043 	ldbu	r2,1(r2)
 90a3ccc:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 90a3cd0:	e0bff903 	ldbu	r2,-28(fp)
 90a3cd4:	10800458 	cmpnei	r2,r2,17
 90a3cd8:	1000381e 	bne	r2,zero,90a3dbc <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 90a3cdc:	e0bff703 	ldbu	r2,-36(fp)
 90a3ce0:	1005003a 	cmpeq	r2,r2,zero
 90a3ce4:	1000061e 	bne	r2,zero,90a3d00 <igmp_validate+0x1ac>
 90a3ce8:	e0bff703 	ldbu	r2,-36(fp)
 90a3cec:	1005003a 	cmpeq	r2,r2,zero
 90a3cf0:	1000111e 	bne	r2,zero,90a3d38 <igmp_validate+0x1e4>
 90a3cf4:	e0bff817 	ldw	r2,-32(fp)
 90a3cf8:	1004c03a 	cmpne	r2,r2,zero
 90a3cfc:	10000e1e 	bne	r2,zero,90a3d38 <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 90a3d00:	e0bffd17 	ldw	r2,-12(fp)
 90a3d04:	10c00417 	ldw	r3,16(r2)
 90a3d08:	d0a08917 	ldw	r2,-32220(gp)
 90a3d0c:	18800a26 	beq	r3,r2,90a3d38 <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 90a3d10:	008243b4 	movhi	r2,2318
 90a3d14:	10b5ea04 	addi	r2,r2,-10328
 90a3d18:	10800e17 	ldw	r2,56(r2)
 90a3d1c:	10c00044 	addi	r3,r2,1
 90a3d20:	008243b4 	movhi	r2,2318
 90a3d24:	10b5ea04 	addi	r2,r2,-10328
 90a3d28:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 90a3d2c:	00bff804 	movi	r2,-32
 90a3d30:	e0bfff15 	stw	r2,-4(fp)
 90a3d34:	00005806 	br	90a3e98 <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 90a3d38:	e0bff703 	ldbu	r2,-36(fp)
 90a3d3c:	1005003a 	cmpeq	r2,r2,zero
 90a3d40:	10001e1e 	bne	r2,zero,90a3dbc <igmp_validate+0x268>
 90a3d44:	e0bff817 	ldw	r2,-32(fp)
 90a3d48:	1005003a 	cmpeq	r2,r2,zero
 90a3d4c:	10001b1e 	bne	r2,zero,90a3dbc <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 90a3d50:	e0bffe17 	ldw	r2,-8(fp)
 90a3d54:	10800617 	ldw	r2,24(r2)
 90a3d58:	10802f03 	ldbu	r2,188(r2)
 90a3d5c:	10803fcc 	andi	r2,r2,255
 90a3d60:	10800058 	cmpnei	r2,r2,1
 90a3d64:	1000031e 	bne	r2,zero,90a3d74 <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 90a3d68:	00bff804 	movi	r2,-32
 90a3d6c:	e0bfff15 	stw	r2,-4(fp)
 90a3d70:	00004906 	br	90a3e98 <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 90a3d74:	e0bff817 	ldw	r2,-32(fp)
 90a3d78:	10fc002c 	andhi	r3,r2,61440
 90a3d7c:	00b80034 	movhi	r2,57344
 90a3d80:	1880041e 	bne	r3,r2,90a3d94 <igmp_validate+0x240>
 90a3d84:	e0bffb17 	ldw	r2,-20(fp)
 90a3d88:	10c00117 	ldw	r3,4(r2)
 90a3d8c:	d0a08917 	ldw	r2,-32220(gp)
 90a3d90:	18800a1e 	bne	r3,r2,90a3dbc <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 90a3d94:	008243b4 	movhi	r2,2318
 90a3d98:	10b5ea04 	addi	r2,r2,-10328
 90a3d9c:	10801117 	ldw	r2,68(r2)
 90a3da0:	10c00044 	addi	r3,r2,1
 90a3da4:	008243b4 	movhi	r2,2318
 90a3da8:	10b5ea04 	addi	r2,r2,-10328
 90a3dac:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 90a3db0:	00bff804 	movi	r2,-32
 90a3db4:	e0bfff15 	stw	r2,-4(fp)
 90a3db8:	00003706 	br	90a3e98 <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 90a3dbc:	e0bff903 	ldbu	r2,-28(fp)
 90a3dc0:	108004a0 	cmpeqi	r2,r2,18
 90a3dc4:	1000031e 	bne	r2,zero,90a3dd4 <igmp_validate+0x280>
 90a3dc8:	e0bff903 	ldbu	r2,-28(fp)
 90a3dcc:	10800598 	cmpnei	r2,r2,22
 90a3dd0:	1000131e 	bne	r2,zero,90a3e20 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 90a3dd4:	e0bffb17 	ldw	r2,-20(fp)
 90a3dd8:	10c00117 	ldw	r3,4(r2)
 90a3ddc:	e0bffd17 	ldw	r2,-12(fp)
 90a3de0:	10800417 	ldw	r2,16(r2)
 90a3de4:	1880041e 	bne	r3,r2,90a3df8 <igmp_validate+0x2a4>
 90a3de8:	e0bff817 	ldw	r2,-32(fp)
 90a3dec:	10fc002c 	andhi	r3,r2,61440
 90a3df0:	00b80034 	movhi	r2,57344
 90a3df4:	18800a26 	beq	r3,r2,90a3e20 <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 90a3df8:	008243b4 	movhi	r2,2318
 90a3dfc:	10b5ea04 	addi	r2,r2,-10328
 90a3e00:	10800f17 	ldw	r2,60(r2)
 90a3e04:	10c00044 	addi	r3,r2,1
 90a3e08:	008243b4 	movhi	r2,2318
 90a3e0c:	10b5ea04 	addi	r2,r2,-10328
 90a3e10:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 90a3e14:	00bff804 	movi	r2,-32
 90a3e18:	e0bfff15 	stw	r2,-4(fp)
 90a3e1c:	00001e06 	br	90a3e98 <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 90a3e20:	e0bff903 	ldbu	r2,-28(fp)
 90a3e24:	108005e0 	cmpeqi	r2,r2,23
 90a3e28:	10000b1e 	bne	r2,zero,90a3e58 <igmp_validate+0x304>
 90a3e2c:	e0bff903 	ldbu	r2,-28(fp)
 90a3e30:	108005a0 	cmpeqi	r2,r2,22
 90a3e34:	1000081e 	bne	r2,zero,90a3e58 <igmp_validate+0x304>
 90a3e38:	e0bff903 	ldbu	r2,-28(fp)
 90a3e3c:	10800458 	cmpnei	r2,r2,17
 90a3e40:	1000141e 	bne	r2,zero,90a3e94 <igmp_validate+0x340>
 90a3e44:	e0bffb17 	ldw	r2,-20(fp)
 90a3e48:	10800043 	ldbu	r2,1(r2)
 90a3e4c:	10803fcc 	andi	r2,r2,255
 90a3e50:	1005003a 	cmpeq	r2,r2,zero
 90a3e54:	10000f1e 	bne	r2,zero,90a3e94 <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 90a3e58:	e13ffd17 	ldw	r4,-12(fp)
 90a3e5c:	90c551c0 	call	90c551c <igmpv2_chk4_rtr_alert_opt>
 90a3e60:	10803fcc 	andi	r2,r2,255
 90a3e64:	1004c03a 	cmpne	r2,r2,zero
 90a3e68:	10000a1e 	bne	r2,zero,90a3e94 <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 90a3e6c:	008243b4 	movhi	r2,2318
 90a3e70:	10b5ea04 	addi	r2,r2,-10328
 90a3e74:	10801417 	ldw	r2,80(r2)
 90a3e78:	10c00044 	addi	r3,r2,1
 90a3e7c:	008243b4 	movhi	r2,2318
 90a3e80:	10b5ea04 	addi	r2,r2,-10328
 90a3e84:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 90a3e88:	00bff804 	movi	r2,-32
 90a3e8c:	e0bfff15 	stw	r2,-4(fp)
 90a3e90:	00000106 	br	90a3e98 <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 90a3e94:	e03fff15 	stw	zero,-4(fp)
 90a3e98:	e0bfff17 	ldw	r2,-4(fp)
}
 90a3e9c:	e037883a 	mov	sp,fp
 90a3ea0:	dfc00117 	ldw	ra,4(sp)
 90a3ea4:	df000017 	ldw	fp,0(sp)
 90a3ea8:	dec00204 	addi	sp,sp,8
 90a3eac:	f800283a 	ret

090a3eb0 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 90a3eb0:	defff504 	addi	sp,sp,-44
 90a3eb4:	dfc00a15 	stw	ra,40(sp)
 90a3eb8:	df000915 	stw	fp,36(sp)
 90a3ebc:	df000904 	addi	fp,sp,36
 90a3ec0:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a3ec4:	008243b4 	movhi	r2,2318
 90a3ec8:	10b82704 	addi	r2,r2,-8036
 90a3ecc:	10800017 	ldw	r2,0(r2)
 90a3ed0:	e0bff915 	stw	r2,-28(fp)
 90a3ed4:	00004506 	br	90a3fec <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 90a3ed8:	e0bff917 	ldw	r2,-28(fp)
 90a3edc:	10800104 	addi	r2,r2,4
 90a3ee0:	e0bfff15 	stw	r2,-4(fp)
 90a3ee4:	e0bff917 	ldw	r2,-28(fp)
 90a3ee8:	10802f03 	ldbu	r2,188(r2)
 90a3eec:	10803fcc 	andi	r2,r2,255
 90a3ef0:	e0bffe15 	stw	r2,-8(fp)
 90a3ef4:	e0bff917 	ldw	r2,-28(fp)
 90a3ef8:	10802f03 	ldbu	r2,188(r2)
 90a3efc:	10803fcc 	andi	r2,r2,255
 90a3f00:	10800058 	cmpnei	r2,r2,1
 90a3f04:	1000041e 	bne	r2,zero,90a3f18 <igmp_print_stats+0x68>
 90a3f08:	00824374 	movhi	r2,2317
 90a3f0c:	10beeb04 	addi	r2,r2,-1108
 90a3f10:	e0bffd15 	stw	r2,-12(fp)
 90a3f14:	00000306 	br	90a3f24 <igmp_print_stats+0x74>
 90a3f18:	00824374 	movhi	r2,2317
 90a3f1c:	10beec04 	addi	r2,r2,-1104
 90a3f20:	e0bffd15 	stw	r2,-12(fp)
 90a3f24:	e0bffd17 	ldw	r2,-12(fp)
 90a3f28:	d8800015 	stw	r2,0(sp)
 90a3f2c:	e13ffa17 	ldw	r4,-24(fp)
 90a3f30:	01424374 	movhi	r5,2317
 90a3f34:	297eed04 	addi	r5,r5,-1100
 90a3f38:	e1bfff17 	ldw	r6,-4(fp)
 90a3f3c:	e1fffe17 	ldw	r7,-8(fp)
 90a3f40:	90a55a40 	call	90a55a4 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 90a3f44:	e0bff917 	ldw	r2,-28(fp)
 90a3f48:	10802f03 	ldbu	r2,188(r2)
 90a3f4c:	10803fcc 	andi	r2,r2,255
 90a3f50:	10800098 	cmpnei	r2,r2,2
 90a3f54:	10001e1e 	bne	r2,zero,90a3fd0 <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 90a3f58:	e0bff917 	ldw	r2,-28(fp)
 90a3f5c:	10802d03 	ldbu	r2,180(r2)
 90a3f60:	10803fcc 	andi	r2,r2,255
 90a3f64:	e0bffc15 	stw	r2,-16(fp)
 90a3f68:	e0bff917 	ldw	r2,-28(fp)
 90a3f6c:	10802d03 	ldbu	r2,180(r2)
 90a3f70:	10803fcc 	andi	r2,r2,255
 90a3f74:	10800058 	cmpnei	r2,r2,1
 90a3f78:	1000041e 	bne	r2,zero,90a3f8c <igmp_print_stats+0xdc>
 90a3f7c:	00824374 	movhi	r2,2317
 90a3f80:	10bef204 	addi	r2,r2,-1080
 90a3f84:	e0bffb15 	stw	r2,-20(fp)
 90a3f88:	00000306 	br	90a3f98 <igmp_print_stats+0xe8>
 90a3f8c:	00824374 	movhi	r2,2317
 90a3f90:	10bef404 	addi	r2,r2,-1072
 90a3f94:	e0bffb15 	stw	r2,-20(fp)
 90a3f98:	e0bff917 	ldw	r2,-28(fp)
 90a3f9c:	10c02e17 	ldw	r3,184(r2)
 90a3fa0:	00824374 	movhi	r2,2317
 90a3fa4:	108f2e04 	addi	r2,r2,15544
 90a3fa8:	10800017 	ldw	r2,0(r2)
 90a3fac:	d8c00015 	stw	r3,0(sp)
 90a3fb0:	d8800115 	stw	r2,4(sp)
 90a3fb4:	e13ffa17 	ldw	r4,-24(fp)
 90a3fb8:	01424374 	movhi	r5,2317
 90a3fbc:	297ef604 	addi	r5,r5,-1064
 90a3fc0:	e1bffc17 	ldw	r6,-16(fp)
 90a3fc4:	e1fffb17 	ldw	r7,-20(fp)
 90a3fc8:	90a55a40 	call	90a55a4 <ns_printf>
 90a3fcc:	00000406 	br	90a3fe0 <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 90a3fd0:	e13ffa17 	ldw	r4,-24(fp)
 90a3fd4:	01424374 	movhi	r5,2317
 90a3fd8:	297f0104 	addi	r5,r5,-1020
 90a3fdc:	90a55a40 	call	90a55a4 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90a3fe0:	e0bff917 	ldw	r2,-28(fp)
 90a3fe4:	10800017 	ldw	r2,0(r2)
 90a3fe8:	e0bff915 	stw	r2,-28(fp)
 90a3fec:	e0bff917 	ldw	r2,-28(fp)
 90a3ff0:	1004c03a 	cmpne	r2,r2,zero
 90a3ff4:	103fb81e 	bne	r2,zero,90a3ed8 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 90a3ff8:	008243b4 	movhi	r2,2318
 90a3ffc:	10b5ea04 	addi	r2,r2,-10328
 90a4000:	11800017 	ldw	r6,0(r2)
 90a4004:	d1e08717 	ldw	r7,-32228(gp)
 90a4008:	e13ffa17 	ldw	r4,-24(fp)
 90a400c:	01424374 	movhi	r5,2317
 90a4010:	297f0204 	addi	r5,r5,-1016
 90a4014:	90a55a40 	call	90a55a4 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 90a4018:	008243b4 	movhi	r2,2318
 90a401c:	10b5ea04 	addi	r2,r2,-10328
 90a4020:	11800117 	ldw	r6,4(r2)
 90a4024:	e13ffa17 	ldw	r4,-24(fp)
 90a4028:	01424374 	movhi	r5,2317
 90a402c:	297f0f04 	addi	r5,r5,-964
 90a4030:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 90a4034:	008243b4 	movhi	r2,2318
 90a4038:	10b5ea04 	addi	r2,r2,-10328
 90a403c:	11800217 	ldw	r6,8(r2)
 90a4040:	e13ffa17 	ldw	r4,-24(fp)
 90a4044:	01424374 	movhi	r5,2317
 90a4048:	297f2004 	addi	r5,r5,-896
 90a404c:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 90a4050:	008243b4 	movhi	r2,2318
 90a4054:	10b5ea04 	addi	r2,r2,-10328
 90a4058:	11800317 	ldw	r6,12(r2)
 90a405c:	e13ffa17 	ldw	r4,-24(fp)
 90a4060:	01424374 	movhi	r5,2317
 90a4064:	297f2c04 	addi	r5,r5,-848
 90a4068:	90a55a40 	call	90a55a4 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 90a406c:	008243b4 	movhi	r2,2318
 90a4070:	10b5ea04 	addi	r2,r2,-10328
 90a4074:	11800417 	ldw	r6,16(r2)
 90a4078:	e13ffa17 	ldw	r4,-24(fp)
 90a407c:	01424374 	movhi	r5,2317
 90a4080:	297f3f04 	addi	r5,r5,-772
 90a4084:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 90a4088:	008243b4 	movhi	r2,2318
 90a408c:	10b5ea04 	addi	r2,r2,-10328
 90a4090:	11800517 	ldw	r6,20(r2)
 90a4094:	008243b4 	movhi	r2,2318
 90a4098:	10b5ea04 	addi	r2,r2,-10328
 90a409c:	11c00617 	ldw	r7,24(r2)
 90a40a0:	e13ffa17 	ldw	r4,-24(fp)
 90a40a4:	01424374 	movhi	r5,2317
 90a40a8:	297f5004 	addi	r5,r5,-704
 90a40ac:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 90a40b0:	008243b4 	movhi	r2,2318
 90a40b4:	10b5ea04 	addi	r2,r2,-10328
 90a40b8:	11800717 	ldw	r6,28(r2)
 90a40bc:	e13ffa17 	ldw	r4,-24(fp)
 90a40c0:	01424374 	movhi	r5,2317
 90a40c4:	297f2c04 	addi	r5,r5,-848
 90a40c8:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 90a40cc:	008243b4 	movhi	r2,2318
 90a40d0:	10b5ea04 	addi	r2,r2,-10328
 90a40d4:	11800817 	ldw	r6,32(r2)
 90a40d8:	e13ffa17 	ldw	r4,-24(fp)
 90a40dc:	01424374 	movhi	r5,2317
 90a40e0:	297f6304 	addi	r5,r5,-628
 90a40e4:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 90a40e8:	008243b4 	movhi	r2,2318
 90a40ec:	10b5ea04 	addi	r2,r2,-10328
 90a40f0:	11800917 	ldw	r6,36(r2)
 90a40f4:	e13ffa17 	ldw	r4,-24(fp)
 90a40f8:	01424374 	movhi	r5,2317
 90a40fc:	297f7404 	addi	r5,r5,-560
 90a4100:	90a55a40 	call	90a55a4 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 90a4104:	008243b4 	movhi	r2,2318
 90a4108:	10b5ea04 	addi	r2,r2,-10328
 90a410c:	11801717 	ldw	r6,92(r2)
 90a4110:	008243b4 	movhi	r2,2318
 90a4114:	10b5ea04 	addi	r2,r2,-10328
 90a4118:	11c01817 	ldw	r7,96(r2)
 90a411c:	e13ffa17 	ldw	r4,-24(fp)
 90a4120:	01424374 	movhi	r5,2317
 90a4124:	297f8004 	addi	r5,r5,-512
 90a4128:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 90a412c:	008243b4 	movhi	r2,2318
 90a4130:	10b5ea04 	addi	r2,r2,-10328
 90a4134:	11801617 	ldw	r6,88(r2)
 90a4138:	e13ffa17 	ldw	r4,-24(fp)
 90a413c:	01424374 	movhi	r5,2317
 90a4140:	297f9304 	addi	r5,r5,-436
 90a4144:	90a55a40 	call	90a55a4 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 90a4148:	008243b4 	movhi	r2,2318
 90a414c:	10b5ea04 	addi	r2,r2,-10328
 90a4150:	11800a17 	ldw	r6,40(r2)
 90a4154:	e13ffa17 	ldw	r4,-24(fp)
 90a4158:	01424374 	movhi	r5,2317
 90a415c:	297f9f04 	addi	r5,r5,-388
 90a4160:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 90a4164:	008243b4 	movhi	r2,2318
 90a4168:	10b5ea04 	addi	r2,r2,-10328
 90a416c:	11800b17 	ldw	r6,44(r2)
 90a4170:	e13ffa17 	ldw	r4,-24(fp)
 90a4174:	01424374 	movhi	r5,2317
 90a4178:	297fab04 	addi	r5,r5,-340
 90a417c:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 90a4180:	008243b4 	movhi	r2,2318
 90a4184:	10b5ea04 	addi	r2,r2,-10328
 90a4188:	11800c17 	ldw	r6,48(r2)
 90a418c:	008243b4 	movhi	r2,2318
 90a4190:	10b5ea04 	addi	r2,r2,-10328
 90a4194:	11c00d17 	ldw	r7,52(r2)
 90a4198:	e13ffa17 	ldw	r4,-24(fp)
 90a419c:	01424374 	movhi	r5,2317
 90a41a0:	297fb704 	addi	r5,r5,-292
 90a41a4:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 90a41a8:	008243b4 	movhi	r2,2318
 90a41ac:	10b5ea04 	addi	r2,r2,-10328
 90a41b0:	11800e17 	ldw	r6,56(r2)
 90a41b4:	008243b4 	movhi	r2,2318
 90a41b8:	10b5ea04 	addi	r2,r2,-10328
 90a41bc:	11c00f17 	ldw	r7,60(r2)
 90a41c0:	e13ffa17 	ldw	r4,-24(fp)
 90a41c4:	01424374 	movhi	r5,2317
 90a41c8:	297fcb04 	addi	r5,r5,-212
 90a41cc:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 90a41d0:	008243b4 	movhi	r2,2318
 90a41d4:	10b5ea04 	addi	r2,r2,-10328
 90a41d8:	11801117 	ldw	r6,68(r2)
 90a41dc:	e13ffa17 	ldw	r4,-24(fp)
 90a41e0:	01424374 	movhi	r5,2317
 90a41e4:	297fdb04 	addi	r5,r5,-148
 90a41e8:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 90a41ec:	008243b4 	movhi	r2,2318
 90a41f0:	10b5ea04 	addi	r2,r2,-10328
 90a41f4:	11801217 	ldw	r6,72(r2)
 90a41f8:	e13ffa17 	ldw	r4,-24(fp)
 90a41fc:	01424374 	movhi	r5,2317
 90a4200:	297fe804 	addi	r5,r5,-96
 90a4204:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 90a4208:	008243b4 	movhi	r2,2318
 90a420c:	10b5ea04 	addi	r2,r2,-10328
 90a4210:	11801317 	ldw	r6,76(r2)
 90a4214:	e13ffa17 	ldw	r4,-24(fp)
 90a4218:	01424374 	movhi	r5,2317
 90a421c:	297ffb04 	addi	r5,r5,-20
 90a4220:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 90a4224:	008243b4 	movhi	r2,2318
 90a4228:	10b5ea04 	addi	r2,r2,-10328
 90a422c:	11801417 	ldw	r6,80(r2)
 90a4230:	e13ffa17 	ldw	r4,-24(fp)
 90a4234:	01424374 	movhi	r5,2317
 90a4238:	29400c04 	addi	r5,r5,48
 90a423c:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 90a4240:	008243b4 	movhi	r2,2318
 90a4244:	10b5ea04 	addi	r2,r2,-10328
 90a4248:	11801017 	ldw	r6,64(r2)
 90a424c:	e13ffa17 	ldw	r4,-24(fp)
 90a4250:	01424374 	movhi	r5,2317
 90a4254:	29401e04 	addi	r5,r5,120
 90a4258:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 90a425c:	008243b4 	movhi	r2,2318
 90a4260:	10b5ea04 	addi	r2,r2,-10328
 90a4264:	11801517 	ldw	r6,84(r2)
 90a4268:	e13ffa17 	ldw	r4,-24(fp)
 90a426c:	01424374 	movhi	r5,2317
 90a4270:	29402e04 	addi	r5,r5,184
 90a4274:	90a55a40 	call	90a55a4 <ns_printf>
   
   return IGMP_OK;
 90a4278:	0005883a 	mov	r2,zero
}
 90a427c:	e037883a 	mov	sp,fp
 90a4280:	dfc00117 	ldw	ra,4(sp)
 90a4284:	df000017 	ldw	fp,0(sp)
 90a4288:	dec00204 	addi	sp,sp,8
 90a428c:	f800283a 	ret

090a4290 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 90a4290:	defff304 	addi	sp,sp,-52
 90a4294:	dfc00c15 	stw	ra,48(sp)
 90a4298:	df000b15 	stw	fp,44(sp)
 90a429c:	df000b04 	addi	fp,sp,44
 90a42a0:	e13ffc15 	stw	r4,-16(fp)
 90a42a4:	e17ffd15 	stw	r5,-12(fp)
 90a42a8:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 90a42ac:	e0bffc17 	ldw	r2,-16(fp)
 90a42b0:	10bff804 	addi	r2,r2,-32
 90a42b4:	1085883a 	add	r2,r2,r2
 90a42b8:	1085883a 	add	r2,r2,r2
 90a42bc:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 90a42c0:	008243b4 	movhi	r2,2318
 90a42c4:	10b72304 	addi	r2,r2,-9076
 90a42c8:	e0bff515 	stw	r2,-44(fp)
 90a42cc:	00000606 	br	90a42e8 <bsd_accept+0x58>
 90a42d0:	e0fff517 	ldw	r3,-44(fp)
 90a42d4:	e0bff717 	ldw	r2,-36(fp)
 90a42d8:	18800626 	beq	r3,r2,90a42f4 <bsd_accept+0x64>
 90a42dc:	e0bff517 	ldw	r2,-44(fp)
 90a42e0:	10800017 	ldw	r2,0(r2)
 90a42e4:	e0bff515 	stw	r2,-44(fp)
 90a42e8:	e0bff517 	ldw	r2,-44(fp)
 90a42ec:	1004c03a 	cmpne	r2,r2,zero
 90a42f0:	103ff71e 	bne	r2,zero,90a42d0 <bsd_accept+0x40>
 90a42f4:	e0fff517 	ldw	r3,-44(fp)
 90a42f8:	e0bff717 	ldw	r2,-36(fp)
 90a42fc:	18800426 	beq	r3,r2,90a4310 <bsd_accept+0x80>
 90a4300:	90aa4780 	call	90aa478 <dtrap>
 90a4304:	00bfffc4 	movi	r2,-1
 90a4308:	e0bfff15 	stw	r2,-4(fp)
 90a430c:	00002806 	br	90a43b0 <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 90a4310:	e0bffd17 	ldw	r2,-12(fp)
 90a4314:	1005003a 	cmpeq	r2,r2,zero
 90a4318:	1000091e 	bne	r2,zero,90a4340 <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 90a431c:	e0bffe17 	ldw	r2,-8(fp)
 90a4320:	1004c03a 	cmpne	r2,r2,zero
 90a4324:	1000061e 	bne	r2,zero,90a4340 <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 90a4328:	e0fff717 	ldw	r3,-36(fp)
 90a432c:	00800384 	movi	r2,14
 90a4330:	18800615 	stw	r2,24(r3)
         return -1;
 90a4334:	00bfffc4 	movi	r2,-1
 90a4338:	e0bfff15 	stw	r2,-4(fp)
 90a433c:	00001c06 	br	90a43b0 <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 90a4340:	e17ff804 	addi	r5,fp,-32
 90a4344:	e13ffc17 	ldw	r4,-16(fp)
 90a4348:	e1bffe17 	ldw	r6,-8(fp)
 90a434c:	90ad8640 	call	90ad864 <t_accept>
 90a4350:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 90a4354:	e0bff617 	ldw	r2,-40(fp)
 90a4358:	10bfffe0 	cmpeqi	r2,r2,-1
 90a435c:	1000121e 	bne	r2,zero,90a43a8 <bsd_accept+0x118>
 90a4360:	e0bffd17 	ldw	r2,-12(fp)
 90a4364:	1005003a 	cmpeq	r2,r2,zero
 90a4368:	10000f1e 	bne	r2,zero,90a43a8 <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 90a436c:	e0bffe17 	ldw	r2,-8(fp)
 90a4370:	10800017 	ldw	r2,0(r2)
 90a4374:	10800470 	cmpltui	r2,r2,17
 90a4378:	1000031e 	bne	r2,zero,90a4388 <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 90a437c:	e0fffe17 	ldw	r3,-8(fp)
 90a4380:	00800404 	movi	r2,16
 90a4384:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 90a4388:	e0bffe17 	ldw	r2,-8(fp)
 90a438c:	10800017 	ldw	r2,0(r2)
 90a4390:	100d883a 	mov	r6,r2
 90a4394:	e0bffd17 	ldw	r2,-12(fp)
 90a4398:	e0fff804 	addi	r3,fp,-32
 90a439c:	1009883a 	mov	r4,r2
 90a43a0:	180b883a 	mov	r5,r3
 90a43a4:	90894600 	call	9089460 <memcpy>
   }

   return lret;
 90a43a8:	e0bff617 	ldw	r2,-40(fp)
 90a43ac:	e0bfff15 	stw	r2,-4(fp)
 90a43b0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a43b4:	e037883a 	mov	sp,fp
 90a43b8:	dfc00117 	ldw	ra,4(sp)
 90a43bc:	df000017 	ldw	fp,0(sp)
 90a43c0:	dec00204 	addi	sp,sp,8
 90a43c4:	f800283a 	ret

090a43c8 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 90a43c8:	defff204 	addi	sp,sp,-56
 90a43cc:	dfc00d15 	stw	ra,52(sp)
 90a43d0:	df000c15 	stw	fp,48(sp)
 90a43d4:	df000c04 	addi	fp,sp,48
 90a43d8:	e13ffc15 	stw	r4,-16(fp)
 90a43dc:	e17ffd15 	stw	r5,-12(fp)
 90a43e0:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 90a43e4:	e0bffc17 	ldw	r2,-16(fp)
 90a43e8:	10bff804 	addi	r2,r2,-32
 90a43ec:	1085883a 	add	r2,r2,r2
 90a43f0:	1085883a 	add	r2,r2,r2
 90a43f4:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 90a43f8:	008243b4 	movhi	r2,2318
 90a43fc:	10b72304 	addi	r2,r2,-9076
 90a4400:	e0bff415 	stw	r2,-48(fp)
 90a4404:	00000606 	br	90a4420 <bsd_getpeername+0x58>
 90a4408:	e0fff417 	ldw	r3,-48(fp)
 90a440c:	e0bff617 	ldw	r2,-40(fp)
 90a4410:	18800626 	beq	r3,r2,90a442c <bsd_getpeername+0x64>
 90a4414:	e0bff417 	ldw	r2,-48(fp)
 90a4418:	10800017 	ldw	r2,0(r2)
 90a441c:	e0bff415 	stw	r2,-48(fp)
 90a4420:	e0bff417 	ldw	r2,-48(fp)
 90a4424:	1004c03a 	cmpne	r2,r2,zero
 90a4428:	103ff71e 	bne	r2,zero,90a4408 <bsd_getpeername+0x40>
 90a442c:	e0fff417 	ldw	r3,-48(fp)
 90a4430:	e0bff617 	ldw	r2,-40(fp)
 90a4434:	18800426 	beq	r3,r2,90a4448 <bsd_getpeername+0x80>
 90a4438:	90aa4780 	call	90aa478 <dtrap>
 90a443c:	00bfffc4 	movi	r2,-1
 90a4440:	e0bfff15 	stw	r2,-4(fp)
 90a4444:	00002506 	br	90a44dc <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 90a4448:	e0bffe17 	ldw	r2,-8(fp)
 90a444c:	1004c03a 	cmpne	r2,r2,zero
 90a4450:	1000061e 	bne	r2,zero,90a446c <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 90a4454:	e0fff617 	ldw	r3,-40(fp)
 90a4458:	00800384 	movi	r2,14
 90a445c:	18800615 	stw	r2,24(r3)
      return -1;
 90a4460:	00bfffc4 	movi	r2,-1
 90a4464:	e0bfff15 	stw	r2,-4(fp)
 90a4468:	00001c06 	br	90a44dc <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 90a446c:	e0bffe17 	ldw	r2,-8(fp)
 90a4470:	10800017 	ldw	r2,0(r2)
 90a4474:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 90a4478:	e17ff704 	addi	r5,fp,-36
 90a447c:	e1bffb04 	addi	r6,fp,-20
 90a4480:	e13ffc17 	ldw	r4,-16(fp)
 90a4484:	90adda40 	call	90adda4 <t_getpeername>
 90a4488:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 90a448c:	e0bff517 	ldw	r2,-44(fp)
 90a4490:	10bfffe0 	cmpeqi	r2,r2,-1
 90a4494:	10000f1e 	bne	r2,zero,90a44d4 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 90a4498:	e0bffb17 	ldw	r2,-20(fp)
 90a449c:	10800470 	cmpltui	r2,r2,17
 90a44a0:	1000021e 	bne	r2,zero,90a44ac <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 90a44a4:	00800404 	movi	r2,16
 90a44a8:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 90a44ac:	e0bffb17 	ldw	r2,-20(fp)
 90a44b0:	100d883a 	mov	r6,r2
 90a44b4:	e0bffd17 	ldw	r2,-12(fp)
 90a44b8:	e0fff704 	addi	r3,fp,-36
 90a44bc:	1009883a 	mov	r4,r2
 90a44c0:	180b883a 	mov	r5,r3
 90a44c4:	90894600 	call	9089460 <memcpy>
      *namelen = lnamelen;
 90a44c8:	e0fffb17 	ldw	r3,-20(fp)
 90a44cc:	e0bffe17 	ldw	r2,-8(fp)
 90a44d0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a44d4:	e0bff517 	ldw	r2,-44(fp)
 90a44d8:	e0bfff15 	stw	r2,-4(fp)
 90a44dc:	e0bfff17 	ldw	r2,-4(fp)
}
 90a44e0:	e037883a 	mov	sp,fp
 90a44e4:	dfc00117 	ldw	ra,4(sp)
 90a44e8:	df000017 	ldw	fp,0(sp)
 90a44ec:	dec00204 	addi	sp,sp,8
 90a44f0:	f800283a 	ret

090a44f4 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 90a44f4:	defff204 	addi	sp,sp,-56
 90a44f8:	dfc00d15 	stw	ra,52(sp)
 90a44fc:	df000c15 	stw	fp,48(sp)
 90a4500:	df000c04 	addi	fp,sp,48
 90a4504:	e13ffc15 	stw	r4,-16(fp)
 90a4508:	e17ffd15 	stw	r5,-12(fp)
 90a450c:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 90a4510:	e0bffc17 	ldw	r2,-16(fp)
 90a4514:	10bff804 	addi	r2,r2,-32
 90a4518:	1085883a 	add	r2,r2,r2
 90a451c:	1085883a 	add	r2,r2,r2
 90a4520:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 90a4524:	008243b4 	movhi	r2,2318
 90a4528:	10b72304 	addi	r2,r2,-9076
 90a452c:	e0bff415 	stw	r2,-48(fp)
 90a4530:	00000606 	br	90a454c <bsd_getsockname+0x58>
 90a4534:	e0fff417 	ldw	r3,-48(fp)
 90a4538:	e0bff617 	ldw	r2,-40(fp)
 90a453c:	18800626 	beq	r3,r2,90a4558 <bsd_getsockname+0x64>
 90a4540:	e0bff417 	ldw	r2,-48(fp)
 90a4544:	10800017 	ldw	r2,0(r2)
 90a4548:	e0bff415 	stw	r2,-48(fp)
 90a454c:	e0bff417 	ldw	r2,-48(fp)
 90a4550:	1004c03a 	cmpne	r2,r2,zero
 90a4554:	103ff71e 	bne	r2,zero,90a4534 <bsd_getsockname+0x40>
 90a4558:	e0fff417 	ldw	r3,-48(fp)
 90a455c:	e0bff617 	ldw	r2,-40(fp)
 90a4560:	18800426 	beq	r3,r2,90a4574 <bsd_getsockname+0x80>
 90a4564:	90aa4780 	call	90aa478 <dtrap>
 90a4568:	00bfffc4 	movi	r2,-1
 90a456c:	e0bfff15 	stw	r2,-4(fp)
 90a4570:	00002506 	br	90a4608 <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 90a4574:	e0bffe17 	ldw	r2,-8(fp)
 90a4578:	1004c03a 	cmpne	r2,r2,zero
 90a457c:	1000061e 	bne	r2,zero,90a4598 <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 90a4580:	e0fff617 	ldw	r3,-40(fp)
 90a4584:	00800384 	movi	r2,14
 90a4588:	18800615 	stw	r2,24(r3)
      return -1;
 90a458c:	00bfffc4 	movi	r2,-1
 90a4590:	e0bfff15 	stw	r2,-4(fp)
 90a4594:	00001c06 	br	90a4608 <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 90a4598:	e0bffe17 	ldw	r2,-8(fp)
 90a459c:	10800017 	ldw	r2,0(r2)
 90a45a0:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 90a45a4:	e17ff704 	addi	r5,fp,-36
 90a45a8:	e1bffb04 	addi	r6,fp,-20
 90a45ac:	e13ffc17 	ldw	r4,-16(fp)
 90a45b0:	90adde80 	call	90adde8 <t_getsockname>
 90a45b4:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 90a45b8:	e0bff517 	ldw	r2,-44(fp)
 90a45bc:	10bfffe0 	cmpeqi	r2,r2,-1
 90a45c0:	10000f1e 	bne	r2,zero,90a4600 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 90a45c4:	e0bffb17 	ldw	r2,-20(fp)
 90a45c8:	10800470 	cmpltui	r2,r2,17
 90a45cc:	1000021e 	bne	r2,zero,90a45d8 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 90a45d0:	00800404 	movi	r2,16
 90a45d4:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 90a45d8:	e0bffb17 	ldw	r2,-20(fp)
 90a45dc:	100d883a 	mov	r6,r2
 90a45e0:	e0bffd17 	ldw	r2,-12(fp)
 90a45e4:	e0fff704 	addi	r3,fp,-36
 90a45e8:	1009883a 	mov	r4,r2
 90a45ec:	180b883a 	mov	r5,r3
 90a45f0:	90894600 	call	9089460 <memcpy>
      *namelen = lnamelen;
 90a45f4:	e0fffb17 	ldw	r3,-20(fp)
 90a45f8:	e0bffe17 	ldw	r2,-8(fp)
 90a45fc:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a4600:	e0bff517 	ldw	r2,-44(fp)
 90a4604:	e0bfff15 	stw	r2,-4(fp)
 90a4608:	e0bfff17 	ldw	r2,-4(fp)
}
 90a460c:	e037883a 	mov	sp,fp
 90a4610:	dfc00117 	ldw	ra,4(sp)
 90a4614:	df000017 	ldw	fp,0(sp)
 90a4618:	dec00204 	addi	sp,sp,8
 90a461c:	f800283a 	ret

090a4620 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 90a4620:	defffb04 	addi	sp,sp,-20
 90a4624:	df000415 	stw	fp,16(sp)
 90a4628:	df000404 	addi	fp,sp,16
 90a462c:	e13ffc15 	stw	r4,-16(fp)
 90a4630:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 90a4634:	e0bffd17 	ldw	r2,-12(fp)
 90a4638:	e0bfff15 	stw	r2,-4(fp)
 90a463c:	e0ffff17 	ldw	r3,-4(fp)
 90a4640:	18802020 	cmpeqi	r2,r3,128
 90a4644:	1000491e 	bne	r2,zero,90a476c <bsd_i_sockoptlen+0x14c>
 90a4648:	e0ffff17 	ldw	r3,-4(fp)
 90a464c:	18802048 	cmpgei	r2,r3,129
 90a4650:	1000251e 	bne	r2,zero,90a46e8 <bsd_i_sockoptlen+0xc8>
 90a4654:	e0ffff17 	ldw	r3,-4(fp)
 90a4658:	18800308 	cmpgei	r2,r3,12
 90a465c:	1000141e 	bne	r2,zero,90a46b0 <bsd_i_sockoptlen+0x90>
 90a4660:	e0ffff17 	ldw	r3,-4(fp)
 90a4664:	18800288 	cmpgei	r2,r3,10
 90a4668:	10004c1e 	bne	r2,zero,90a479c <bsd_i_sockoptlen+0x17c>
 90a466c:	e0ffff17 	ldw	r3,-4(fp)
 90a4670:	18800120 	cmpeqi	r2,r3,4
 90a4674:	1000431e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a4678:	e0ffff17 	ldw	r3,-4(fp)
 90a467c:	18800148 	cmpgei	r2,r3,5
 90a4680:	1000041e 	bne	r2,zero,90a4694 <bsd_i_sockoptlen+0x74>
 90a4684:	e0ffff17 	ldw	r3,-4(fp)
 90a4688:	188000e0 	cmpeqi	r2,r3,3
 90a468c:	1000491e 	bne	r2,zero,90a47b4 <bsd_i_sockoptlen+0x194>
 90a4690:	00004b06 	br	90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a4694:	e0ffff17 	ldw	r3,-4(fp)
 90a4698:	18800220 	cmpeqi	r2,r3,8
 90a469c:	1000391e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a46a0:	e0ffff17 	ldw	r3,-4(fp)
 90a46a4:	18800260 	cmpeqi	r2,r3,9
 90a46a8:	1000391e 	bne	r2,zero,90a4790 <bsd_i_sockoptlen+0x170>
 90a46ac:	00004406 	br	90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a46b0:	e0ffff17 	ldw	r3,-4(fp)
 90a46b4:	18800420 	cmpeqi	r2,r3,16
 90a46b8:	1000321e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a46bc:	e0ffff17 	ldw	r3,-4(fp)
 90a46c0:	18800448 	cmpgei	r2,r3,17
 90a46c4:	1000041e 	bne	r2,zero,90a46d8 <bsd_i_sockoptlen+0xb8>
 90a46c8:	e0ffff17 	ldw	r3,-4(fp)
 90a46cc:	18800388 	cmpgei	r2,r3,14
 90a46d0:	10003b1e 	bne	r2,zero,90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a46d4:	00003406 	br	90a47a8 <bsd_i_sockoptlen+0x188>
 90a46d8:	e0ffff17 	ldw	r3,-4(fp)
 90a46dc:	18800820 	cmpeqi	r2,r3,32
 90a46e0:	1000281e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a46e4:	00003606 	br	90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a46e8:	e0ffff17 	ldw	r3,-4(fp)
 90a46ec:	188401c8 	cmpgei	r2,r3,4103
 90a46f0:	10000e1e 	bne	r2,zero,90a472c <bsd_i_sockoptlen+0x10c>
 90a46f4:	e0ffff17 	ldw	r3,-4(fp)
 90a46f8:	18840148 	cmpgei	r2,r3,4101
 90a46fc:	10001e1e 	bne	r2,zero,90a4778 <bsd_i_sockoptlen+0x158>
 90a4700:	e0ffff17 	ldw	r3,-4(fp)
 90a4704:	18804020 	cmpeqi	r2,r3,256
 90a4708:	10001e1e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a470c:	e0ffff17 	ldw	r3,-4(fp)
 90a4710:	18804010 	cmplti	r2,r3,256
 90a4714:	10002a1e 	bne	r2,zero,90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a4718:	e0ffff17 	ldw	r3,-4(fp)
 90a471c:	18bbffc4 	addi	r2,r3,-4097
 90a4720:	108000a8 	cmpgeui	r2,r2,2
 90a4724:	1000261e 	bne	r2,zero,90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a4728:	00001606 	br	90a4784 <bsd_i_sockoptlen+0x164>
 90a472c:	e0ffff17 	ldw	r3,-4(fp)
 90a4730:	18840588 	cmpgei	r2,r3,4118
 90a4734:	1000071e 	bne	r2,zero,90a4754 <bsd_i_sockoptlen+0x134>
 90a4738:	e0ffff17 	ldw	r3,-4(fp)
 90a473c:	18840508 	cmpgei	r2,r3,4116
 90a4740:	1000081e 	bne	r2,zero,90a4764 <bsd_i_sockoptlen+0x144>
 90a4744:	e0ffff17 	ldw	r3,-4(fp)
 90a4748:	18840248 	cmpgei	r2,r3,4105
 90a474c:	10001c1e 	bne	r2,zero,90a47c0 <bsd_i_sockoptlen+0x1a0>
 90a4750:	00000c06 	br	90a4784 <bsd_i_sockoptlen+0x164>
 90a4754:	e0ffff17 	ldw	r3,-4(fp)
 90a4758:	188405a0 	cmpeqi	r2,r3,4118
 90a475c:	1000091e 	bne	r2,zero,90a4784 <bsd_i_sockoptlen+0x164>
 90a4760:	00001706 	br	90a47c0 <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 90a4764:	e03ffe15 	stw	zero,-8(fp)
 90a4768:	00001606 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 90a476c:	00800204 	movi	r2,8
 90a4770:	e0bffe15 	stw	r2,-8(fp)
 90a4774:	00001306 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 90a4778:	00c00084 	movi	r3,2
 90a477c:	e0fffe15 	stw	r3,-8(fp)
 90a4780:	00001006 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 90a4784:	00800104 	movi	r2,4
 90a4788:	e0bffe15 	stw	r2,-8(fp)
 90a478c:	00000d06 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 90a4790:	00c00104 	movi	r3,4
 90a4794:	e0fffe15 	stw	r3,-8(fp)
 90a4798:	00000a06 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 90a479c:	00800044 	movi	r2,1
 90a47a0:	e0bffe15 	stw	r2,-8(fp)
 90a47a4:	00000706 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 90a47a8:	00c00204 	movi	r3,8
 90a47ac:	e0fffe15 	stw	r3,-8(fp)
 90a47b0:	00000406 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 90a47b4:	00800104 	movi	r2,4
 90a47b8:	e0bffe15 	stw	r2,-8(fp)
 90a47bc:	00000106 	br	90a47c4 <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 90a47c0:	e03ffe15 	stw	zero,-8(fp)
 90a47c4:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 90a47c8:	e037883a 	mov	sp,fp
 90a47cc:	df000017 	ldw	fp,0(sp)
 90a47d0:	dec00104 	addi	sp,sp,4
 90a47d4:	f800283a 	ret

090a47d8 <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 90a47d8:	defff404 	addi	sp,sp,-48
 90a47dc:	dfc00b15 	stw	ra,44(sp)
 90a47e0:	df000a15 	stw	fp,40(sp)
 90a47e4:	df000a04 	addi	fp,sp,40
 90a47e8:	e13ffb15 	stw	r4,-20(fp)
 90a47ec:	e17ffc15 	stw	r5,-16(fp)
 90a47f0:	e1bffd15 	stw	r6,-12(fp)
 90a47f4:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 90a47f8:	e0bffb17 	ldw	r2,-20(fp)
 90a47fc:	10bff804 	addi	r2,r2,-32
 90a4800:	1085883a 	add	r2,r2,r2
 90a4804:	1085883a 	add	r2,r2,r2
 90a4808:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a480c:	008243b4 	movhi	r2,2318
 90a4810:	10b72304 	addi	r2,r2,-9076
 90a4814:	e0bff715 	stw	r2,-36(fp)
 90a4818:	00000606 	br	90a4834 <bsd_getsockopt+0x5c>
 90a481c:	e0fff717 	ldw	r3,-36(fp)
 90a4820:	e0bffa17 	ldw	r2,-24(fp)
 90a4824:	18800626 	beq	r3,r2,90a4840 <bsd_getsockopt+0x68>
 90a4828:	e0bff717 	ldw	r2,-36(fp)
 90a482c:	10800017 	ldw	r2,0(r2)
 90a4830:	e0bff715 	stw	r2,-36(fp)
 90a4834:	e0bff717 	ldw	r2,-36(fp)
 90a4838:	1004c03a 	cmpne	r2,r2,zero
 90a483c:	103ff71e 	bne	r2,zero,90a481c <bsd_getsockopt+0x44>
 90a4840:	e0fff717 	ldw	r3,-36(fp)
 90a4844:	e0bffa17 	ldw	r2,-24(fp)
 90a4848:	18800426 	beq	r3,r2,90a485c <bsd_getsockopt+0x84>
 90a484c:	90aa4780 	call	90aa478 <dtrap>
 90a4850:	00bfffc4 	movi	r2,-1
 90a4854:	e0bfff15 	stw	r2,-4(fp)
 90a4858:	00002106 	br	90a48e0 <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 90a485c:	e13ffc17 	ldw	r4,-16(fp)
 90a4860:	e17ffd17 	ldw	r5,-12(fp)
 90a4864:	90a46200 	call	90a4620 <bsd_i_sockoptlen>
 90a4868:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 90a486c:	e0800217 	ldw	r2,8(fp)
 90a4870:	1005003a 	cmpeq	r2,r2,zero
 90a4874:	1000041e 	bne	r2,zero,90a4888 <bsd_getsockopt+0xb0>
 90a4878:	e0800217 	ldw	r2,8(fp)
 90a487c:	10c00017 	ldw	r3,0(r2)
 90a4880:	e0bff917 	ldw	r2,-28(fp)
 90a4884:	1880060e 	bge	r3,r2,90a48a0 <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 90a4888:	e0fffa17 	ldw	r3,-24(fp)
 90a488c:	00800384 	movi	r2,14
 90a4890:	18800615 	stw	r2,24(r3)
      return -1;
 90a4894:	00bfffc4 	movi	r2,-1
 90a4898:	e0bfff15 	stw	r2,-4(fp)
 90a489c:	00001006 	br	90a48e0 <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 90a48a0:	e0bff917 	ldw	r2,-28(fp)
 90a48a4:	d8800015 	stw	r2,0(sp)
 90a48a8:	e13ffb17 	ldw	r4,-20(fp)
 90a48ac:	e17ffc17 	ldw	r5,-16(fp)
 90a48b0:	e1bffd17 	ldw	r6,-12(fp)
 90a48b4:	e1fffe17 	ldw	r7,-8(fp)
 90a48b8:	90ae2040 	call	90ae204 <t_getsockopt>
 90a48bc:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 90a48c0:	e0bff817 	ldw	r2,-32(fp)
 90a48c4:	1004c03a 	cmpne	r2,r2,zero
 90a48c8:	1000031e 	bne	r2,zero,90a48d8 <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 90a48cc:	e0c00217 	ldw	r3,8(fp)
 90a48d0:	e0bff917 	ldw	r2,-28(fp)
 90a48d4:	18800015 	stw	r2,0(r3)
   }

   return e;
 90a48d8:	e0bff817 	ldw	r2,-32(fp)
 90a48dc:	e0bfff15 	stw	r2,-4(fp)
 90a48e0:	e0bfff17 	ldw	r2,-4(fp)
   
}
 90a48e4:	e037883a 	mov	sp,fp
 90a48e8:	dfc00117 	ldw	ra,4(sp)
 90a48ec:	df000017 	ldw	fp,0(sp)
 90a48f0:	dec00204 	addi	sp,sp,8
 90a48f4:	f800283a 	ret

090a48f8 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 90a48f8:	defff404 	addi	sp,sp,-48
 90a48fc:	dfc00915 	stw	ra,36(sp)
 90a4900:	df000815 	stw	fp,32(sp)
 90a4904:	df000804 	addi	fp,sp,32
 90a4908:	e13ffd15 	stw	r4,-12(fp)
 90a490c:	e1800215 	stw	r6,8(fp)
 90a4910:	e1c00315 	stw	r7,12(fp)
 90a4914:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 90a4918:	e0bffd17 	ldw	r2,-12(fp)
 90a491c:	10bff804 	addi	r2,r2,-32
 90a4920:	1085883a 	add	r2,r2,r2
 90a4924:	1085883a 	add	r2,r2,r2
 90a4928:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a492c:	008243b4 	movhi	r2,2318
 90a4930:	10b72304 	addi	r2,r2,-9076
 90a4934:	e0bff915 	stw	r2,-28(fp)
 90a4938:	00000606 	br	90a4954 <bsd_ioctl+0x5c>
 90a493c:	e0fff917 	ldw	r3,-28(fp)
 90a4940:	e0bffa17 	ldw	r2,-24(fp)
 90a4944:	18800626 	beq	r3,r2,90a4960 <bsd_ioctl+0x68>
 90a4948:	e0bff917 	ldw	r2,-28(fp)
 90a494c:	10800017 	ldw	r2,0(r2)
 90a4950:	e0bff915 	stw	r2,-28(fp)
 90a4954:	e0bff917 	ldw	r2,-28(fp)
 90a4958:	1004c03a 	cmpne	r2,r2,zero
 90a495c:	103ff71e 	bne	r2,zero,90a493c <bsd_ioctl+0x44>
 90a4960:	e0fff917 	ldw	r3,-28(fp)
 90a4964:	e0bffa17 	ldw	r2,-24(fp)
 90a4968:	18800426 	beq	r3,r2,90a497c <bsd_ioctl+0x84>
 90a496c:	90aa4780 	call	90aa478 <dtrap>
 90a4970:	00bfffc4 	movi	r2,-1
 90a4974:	e0bfff15 	stw	r2,-4(fp)
 90a4978:	00001a06 	br	90a49e4 <bsd_ioctl+0xec>

   va_start(argptr, request);
 90a497c:	e0800204 	addi	r2,fp,8
 90a4980:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 90a4984:	e0bffe17 	ldw	r2,-8(fp)
 90a4988:	108405a0 	cmpeqi	r2,r2,4118
 90a498c:	1000011e 	bne	r2,zero,90a4994 <bsd_ioctl+0x9c>
 90a4990:	00000f06 	br	90a49d0 <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 90a4994:	e0fffb17 	ldw	r3,-20(fp)
 90a4998:	18800104 	addi	r2,r3,4
 90a499c:	e0bffb15 	stw	r2,-20(fp)
 90a49a0:	1805883a 	mov	r2,r3
 90a49a4:	10800017 	ldw	r2,0(r2)
 90a49a8:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 90a49ac:	e1fffc04 	addi	r7,fp,-16
 90a49b0:	00800104 	movi	r2,4
 90a49b4:	d8800015 	stw	r2,0(sp)
 90a49b8:	e13ffd17 	ldw	r4,-12(fp)
 90a49bc:	017fffc4 	movi	r5,-1
 90a49c0:	01840584 	movi	r6,4118
 90a49c4:	90ae0280 	call	90ae028 <t_setsockopt>
 90a49c8:	e0bfff15 	stw	r2,-4(fp)
 90a49cc:	00000506 	br	90a49e4 <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 90a49d0:	e0fffa17 	ldw	r3,-24(fp)
 90a49d4:	00800584 	movi	r2,22
 90a49d8:	18800615 	stw	r2,24(r3)
      return -1;
 90a49dc:	00bfffc4 	movi	r2,-1
 90a49e0:	e0bfff15 	stw	r2,-4(fp)
 90a49e4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a49e8:	e037883a 	mov	sp,fp
 90a49ec:	dfc00117 	ldw	ra,4(sp)
 90a49f0:	df000017 	ldw	fp,0(sp)
 90a49f4:	dec00404 	addi	sp,sp,16
 90a49f8:	f800283a 	ret

090a49fc <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 90a49fc:	defffd04 	addi	sp,sp,-12
 90a4a00:	dfc00215 	stw	ra,8(sp)
 90a4a04:	df000115 	stw	fp,4(sp)
 90a4a08:	df000104 	addi	fp,sp,4
 90a4a0c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 90a4a10:	e13fff17 	ldw	r4,-4(fp)
 90a4a14:	90a514c0 	call	90a514c <print_ipad>
}
 90a4a18:	e037883a 	mov	sp,fp
 90a4a1c:	dfc00117 	ldw	ra,4(sp)
 90a4a20:	df000017 	ldw	fp,0(sp)
 90a4a24:	dec00204 	addi	sp,sp,8
 90a4a28:	f800283a 	ret

090a4a2c <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 90a4a2c:	deffef04 	addi	sp,sp,-68
 90a4a30:	dfc01015 	stw	ra,64(sp)
 90a4a34:	df000f15 	stw	fp,60(sp)
 90a4a38:	df000f04 	addi	fp,sp,60
 90a4a3c:	e13ffb15 	stw	r4,-20(fp)
 90a4a40:	e17ffc15 	stw	r5,-16(fp)
 90a4a44:	e1bffd15 	stw	r6,-12(fp)
 90a4a48:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 90a4a4c:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 90a4a50:	e0bffb17 	ldw	r2,-20(fp)
 90a4a54:	10bff804 	addi	r2,r2,-32
 90a4a58:	1085883a 	add	r2,r2,r2
 90a4a5c:	1085883a 	add	r2,r2,r2
 90a4a60:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 90a4a64:	008243b4 	movhi	r2,2318
 90a4a68:	10b72304 	addi	r2,r2,-9076
 90a4a6c:	e0bff315 	stw	r2,-52(fp)
 90a4a70:	00000606 	br	90a4a8c <bsd_recvfrom+0x60>
 90a4a74:	e0fff317 	ldw	r3,-52(fp)
 90a4a78:	e0bff517 	ldw	r2,-44(fp)
 90a4a7c:	18800626 	beq	r3,r2,90a4a98 <bsd_recvfrom+0x6c>
 90a4a80:	e0bff317 	ldw	r2,-52(fp)
 90a4a84:	10800017 	ldw	r2,0(r2)
 90a4a88:	e0bff315 	stw	r2,-52(fp)
 90a4a8c:	e0bff317 	ldw	r2,-52(fp)
 90a4a90:	1004c03a 	cmpne	r2,r2,zero
 90a4a94:	103ff71e 	bne	r2,zero,90a4a74 <bsd_recvfrom+0x48>
 90a4a98:	e0fff317 	ldw	r3,-52(fp)
 90a4a9c:	e0bff517 	ldw	r2,-44(fp)
 90a4aa0:	18800426 	beq	r3,r2,90a4ab4 <bsd_recvfrom+0x88>
 90a4aa4:	90aa4780 	call	90aa478 <dtrap>
 90a4aa8:	00bfffc4 	movi	r2,-1
 90a4aac:	e0bfff15 	stw	r2,-4(fp)
 90a4ab0:	00003006 	br	90a4b74 <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 90a4ab4:	e0800217 	ldw	r2,8(fp)
 90a4ab8:	1005003a 	cmpeq	r2,r2,zero
 90a4abc:	10000c1e 	bne	r2,zero,90a4af0 <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 90a4ac0:	e0800317 	ldw	r2,12(fp)
 90a4ac4:	1004c03a 	cmpne	r2,r2,zero
 90a4ac8:	1000061e 	bne	r2,zero,90a4ae4 <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 90a4acc:	e0fff517 	ldw	r3,-44(fp)
 90a4ad0:	00800384 	movi	r2,14
 90a4ad4:	18800615 	stw	r2,24(r3)
         return -1;
 90a4ad8:	00bfffc4 	movi	r2,-1
 90a4adc:	e0bfff15 	stw	r2,-4(fp)
 90a4ae0:	00002406 	br	90a4b74 <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 90a4ae4:	e0800317 	ldw	r2,12(fp)
 90a4ae8:	10800017 	ldw	r2,0(r2)
 90a4aec:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 90a4af0:	e17ffc17 	ldw	r5,-16(fp)
 90a4af4:	e0bff604 	addi	r2,fp,-40
 90a4af8:	d8800015 	stw	r2,0(sp)
 90a4afc:	e0bffa04 	addi	r2,fp,-24
 90a4b00:	d8800115 	stw	r2,4(sp)
 90a4b04:	e13ffb17 	ldw	r4,-20(fp)
 90a4b08:	e1bffd17 	ldw	r6,-12(fp)
 90a4b0c:	e1fffe17 	ldw	r7,-8(fp)
 90a4b10:	90ae4980 	call	90ae498 <t_recvfrom>
 90a4b14:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 90a4b18:	e0bff417 	ldw	r2,-48(fp)
 90a4b1c:	10bfffe0 	cmpeqi	r2,r2,-1
 90a4b20:	1000121e 	bne	r2,zero,90a4b6c <bsd_recvfrom+0x140>
 90a4b24:	e0800217 	ldw	r2,8(fp)
 90a4b28:	1005003a 	cmpeq	r2,r2,zero
 90a4b2c:	10000f1e 	bne	r2,zero,90a4b6c <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 90a4b30:	e0bffa17 	ldw	r2,-24(fp)
 90a4b34:	10800470 	cmpltui	r2,r2,17
 90a4b38:	1000021e 	bne	r2,zero,90a4b44 <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 90a4b3c:	00800404 	movi	r2,16
 90a4b40:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 90a4b44:	e0bffa17 	ldw	r2,-24(fp)
 90a4b48:	100d883a 	mov	r6,r2
 90a4b4c:	e0800217 	ldw	r2,8(fp)
 90a4b50:	e0fff604 	addi	r3,fp,-40
 90a4b54:	1009883a 	mov	r4,r2
 90a4b58:	180b883a 	mov	r5,r3
 90a4b5c:	90894600 	call	9089460 <memcpy>
      *fromlen = lfromlen;
 90a4b60:	e0fffa17 	ldw	r3,-24(fp)
 90a4b64:	e0800317 	ldw	r2,12(fp)
 90a4b68:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 90a4b6c:	e0bff417 	ldw	r2,-48(fp)
 90a4b70:	e0bfff15 	stw	r2,-4(fp)
 90a4b74:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4b78:	e037883a 	mov	sp,fp
 90a4b7c:	dfc00117 	ldw	ra,4(sp)
 90a4b80:	df000017 	ldw	fp,0(sp)
 90a4b84:	dec00204 	addi	sp,sp,8
 90a4b88:	f800283a 	ret

090a4b8c <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 90a4b8c:	defff604 	addi	sp,sp,-40
 90a4b90:	dfc00915 	stw	ra,36(sp)
 90a4b94:	df000815 	stw	fp,32(sp)
 90a4b98:	dc400715 	stw	r17,28(sp)
 90a4b9c:	dc000615 	stw	r16,24(sp)
 90a4ba0:	df000604 	addi	fp,sp,24
 90a4ba4:	e13ffc15 	stw	r4,-16(fp)
 90a4ba8:	e17ffd15 	stw	r5,-12(fp)
 90a4bac:	e1bffe15 	stw	r6,-8(fp)
 90a4bb0:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 90a4bb4:	e0800417 	ldw	r2,16(fp)
 90a4bb8:	1005003a 	cmpeq	r2,r2,zero
 90a4bbc:	1000581e 	bne	r2,zero,90a4d20 <bsd_select+0x194>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 90a4bc0:	00801904 	movi	r2,100
 90a4bc4:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 90a4bc8:	e0bffa17 	ldw	r2,-24(fp)
 90a4bcc:	1080fa10 	cmplti	r2,r2,1000
 90a4bd0:	10000b1e 	bne	r2,zero,90a4c00 <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 90a4bd4:	e0800417 	ldw	r2,16(fp)
 90a4bd8:	10800117 	ldw	r2,4(r2)
 90a4bdc:	10c00c84 	addi	r3,r2,50
 90a4be0:	00801904 	movi	r2,100
 90a4be4:	1887283a 	div	r3,r3,r2
 90a4be8:	e0bffa17 	ldw	r2,-24(fp)
 90a4bec:	1887383a 	mul	r3,r3,r2
 90a4bf0:	0089c404 	movi	r2,10000
 90a4bf4:	1885283a 	div	r2,r3,r2
 90a4bf8:	e0bffb15 	stw	r2,-20(fp)
 90a4bfc:	00002806 	br	90a4ca0 <bsd_select+0x114>
      }
      else if (tps >= 100)
 90a4c00:	e0bffa17 	ldw	r2,-24(fp)
 90a4c04:	10801910 	cmplti	r2,r2,100
 90a4c08:	10000b1e 	bne	r2,zero,90a4c38 <bsd_select+0xac>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 90a4c0c:	e0800417 	ldw	r2,16(fp)
 90a4c10:	10800117 	ldw	r2,4(r2)
 90a4c14:	10c07d04 	addi	r3,r2,500
 90a4c18:	0080fa04 	movi	r2,1000
 90a4c1c:	1887283a 	div	r3,r3,r2
 90a4c20:	e0bffa17 	ldw	r2,-24(fp)
 90a4c24:	1887383a 	mul	r3,r3,r2
 90a4c28:	0080fa04 	movi	r2,1000
 90a4c2c:	1885283a 	div	r2,r3,r2
 90a4c30:	e0bffb15 	stw	r2,-20(fp)
 90a4c34:	00001a06 	br	90a4ca0 <bsd_select+0x114>
      }
      else if (tps >= 10)
 90a4c38:	e0bffa17 	ldw	r2,-24(fp)
 90a4c3c:	10800290 	cmplti	r2,r2,10
 90a4c40:	10000b1e 	bne	r2,zero,90a4c70 <bsd_select+0xe4>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 90a4c44:	e0800417 	ldw	r2,16(fp)
 90a4c48:	10800117 	ldw	r2,4(r2)
 90a4c4c:	10c4e204 	addi	r3,r2,5000
 90a4c50:	0089c404 	movi	r2,10000
 90a4c54:	1887283a 	div	r3,r3,r2
 90a4c58:	e0bffa17 	ldw	r2,-24(fp)
 90a4c5c:	1887383a 	mul	r3,r3,r2
 90a4c60:	00801904 	movi	r2,100
 90a4c64:	1885283a 	div	r2,r3,r2
 90a4c68:	e0bffb15 	stw	r2,-20(fp)
 90a4c6c:	00000c06 	br	90a4ca0 <bsd_select+0x114>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 90a4c70:	e0800417 	ldw	r2,16(fp)
 90a4c74:	10c00117 	ldw	r3,4(r2)
 90a4c78:	00b0d414 	movui	r2,50000
 90a4c7c:	1887883a 	add	r3,r3,r2
 90a4c80:	008000b4 	movhi	r2,2
 90a4c84:	10a1a804 	addi	r2,r2,-31072
 90a4c88:	1887283a 	div	r3,r3,r2
 90a4c8c:	e0bffa17 	ldw	r2,-24(fp)
 90a4c90:	1887383a 	mul	r3,r3,r2
 90a4c94:	00800284 	movi	r2,10
 90a4c98:	1885283a 	div	r2,r3,r2
 90a4c9c:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 90a4ca0:	e13ffb17 	ldw	r4,-20(fp)
 90a4ca4:	908ce680 	call	908ce68 <__floatsidf>
 90a4ca8:	1021883a 	mov	r16,r2
 90a4cac:	1823883a 	mov	r17,r3
 90a4cb0:	e0800417 	ldw	r2,16(fp)
 90a4cb4:	11000017 	ldw	r4,0(r2)
 90a4cb8:	908ce680 	call	908ce68 <__floatsidf>
 90a4cbc:	100b883a 	mov	r5,r2
 90a4cc0:	180d883a 	mov	r6,r3
 90a4cc4:	2809883a 	mov	r4,r5
 90a4cc8:	300b883a 	mov	r5,r6
 90a4ccc:	000d883a 	mov	r6,zero
 90a4cd0:	01d01674 	movhi	r7,16473
 90a4cd4:	908c5b40 	call	908c5b4 <__muldf3>
 90a4cd8:	1009883a 	mov	r4,r2
 90a4cdc:	180b883a 	mov	r5,r3
 90a4ce0:	2005883a 	mov	r2,r4
 90a4ce4:	2807883a 	mov	r3,r5
 90a4ce8:	8009883a 	mov	r4,r16
 90a4cec:	880b883a 	mov	r5,r17
 90a4cf0:	100d883a 	mov	r6,r2
 90a4cf4:	180f883a 	mov	r7,r3
 90a4cf8:	908c5400 	call	908c540 <__adddf3>
 90a4cfc:	1009883a 	mov	r4,r2
 90a4d00:	180b883a 	mov	r5,r3
 90a4d04:	2005883a 	mov	r2,r4
 90a4d08:	2807883a 	mov	r3,r5
 90a4d0c:	1009883a 	mov	r4,r2
 90a4d10:	180b883a 	mov	r5,r3
 90a4d14:	908cf600 	call	908cf60 <__fixdfsi>
 90a4d18:	e0bffb15 	stw	r2,-20(fp)
 90a4d1c:	00000206 	br	90a4d28 <bsd_select+0x19c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 90a4d20:	00bfffc4 	movi	r2,-1
 90a4d24:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 90a4d28:	e13ffd17 	ldw	r4,-12(fp)
 90a4d2c:	e17ffe17 	ldw	r5,-8(fp)
 90a4d30:	e1bfff17 	ldw	r6,-4(fp)
 90a4d34:	e1fffb17 	ldw	r7,-20(fp)
 90a4d38:	90b24240 	call	90b2424 <t_select>
}
 90a4d3c:	e037883a 	mov	sp,fp
 90a4d40:	dfc00317 	ldw	ra,12(sp)
 90a4d44:	df000217 	ldw	fp,8(sp)
 90a4d48:	dc400117 	ldw	r17,4(sp)
 90a4d4c:	dc000017 	ldw	r16,0(sp)
 90a4d50:	dec00404 	addi	sp,sp,16
 90a4d54:	f800283a 	ret

090a4d58 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 90a4d58:	defff604 	addi	sp,sp,-40
 90a4d5c:	dfc00915 	stw	ra,36(sp)
 90a4d60:	df000815 	stw	fp,32(sp)
 90a4d64:	df000804 	addi	fp,sp,32
 90a4d68:	e13ffb15 	stw	r4,-20(fp)
 90a4d6c:	e17ffc15 	stw	r5,-16(fp)
 90a4d70:	e1bffd15 	stw	r6,-12(fp)
 90a4d74:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 90a4d78:	e0bffb17 	ldw	r2,-20(fp)
 90a4d7c:	10bff804 	addi	r2,r2,-32
 90a4d80:	1085883a 	add	r2,r2,r2
 90a4d84:	1085883a 	add	r2,r2,r2
 90a4d88:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90a4d8c:	008243b4 	movhi	r2,2318
 90a4d90:	10b72304 	addi	r2,r2,-9076
 90a4d94:	e0bff915 	stw	r2,-28(fp)
 90a4d98:	00000606 	br	90a4db4 <bsd_setsockopt+0x5c>
 90a4d9c:	e0fff917 	ldw	r3,-28(fp)
 90a4da0:	e0bffa17 	ldw	r2,-24(fp)
 90a4da4:	18800626 	beq	r3,r2,90a4dc0 <bsd_setsockopt+0x68>
 90a4da8:	e0bff917 	ldw	r2,-28(fp)
 90a4dac:	10800017 	ldw	r2,0(r2)
 90a4db0:	e0bff915 	stw	r2,-28(fp)
 90a4db4:	e0bff917 	ldw	r2,-28(fp)
 90a4db8:	1004c03a 	cmpne	r2,r2,zero
 90a4dbc:	103ff71e 	bne	r2,zero,90a4d9c <bsd_setsockopt+0x44>
 90a4dc0:	e0fff917 	ldw	r3,-28(fp)
 90a4dc4:	e0bffa17 	ldw	r2,-24(fp)
 90a4dc8:	18800426 	beq	r3,r2,90a4ddc <bsd_setsockopt+0x84>
 90a4dcc:	90aa4780 	call	90aa478 <dtrap>
 90a4dd0:	00bfffc4 	movi	r2,-1
 90a4dd4:	e0bfff15 	stw	r2,-4(fp)
 90a4dd8:	00001406 	br	90a4e2c <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 90a4ddc:	e13ffc17 	ldw	r4,-16(fp)
 90a4de0:	e17ffd17 	ldw	r5,-12(fp)
 90a4de4:	90a46200 	call	90a4620 <bsd_i_sockoptlen>
 90a4de8:	1007883a 	mov	r3,r2
 90a4dec:	e0800217 	ldw	r2,8(fp)
 90a4df0:	10c0060e 	bge	r2,r3,90a4e0c <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 90a4df4:	e0fffa17 	ldw	r3,-24(fp)
 90a4df8:	00800384 	movi	r2,14
 90a4dfc:	18800615 	stw	r2,24(r3)
      return -1;
 90a4e00:	00bfffc4 	movi	r2,-1
 90a4e04:	e0bfff15 	stw	r2,-4(fp)
 90a4e08:	00000806 	br	90a4e2c <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 90a4e0c:	e0800217 	ldw	r2,8(fp)
 90a4e10:	d8800015 	stw	r2,0(sp)
 90a4e14:	e13ffb17 	ldw	r4,-20(fp)
 90a4e18:	e17ffc17 	ldw	r5,-16(fp)
 90a4e1c:	e1bffd17 	ldw	r6,-12(fp)
 90a4e20:	e1fffe17 	ldw	r7,-8(fp)
 90a4e24:	90ae0280 	call	90ae028 <t_setsockopt>
 90a4e28:	e0bfff15 	stw	r2,-4(fp)
 90a4e2c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4e30:	e037883a 	mov	sp,fp
 90a4e34:	dfc00117 	ldw	ra,4(sp)
 90a4e38:	df000017 	ldw	fp,0(sp)
 90a4e3c:	dec00204 	addi	sp,sp,8
 90a4e40:	f800283a 	ret

090a4e44 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 90a4e44:	defffa04 	addi	sp,sp,-24
 90a4e48:	df000515 	stw	fp,20(sp)
 90a4e4c:	df000504 	addi	fp,sp,20
 90a4e50:	e13ffe15 	stw	r4,-8(fp)
 90a4e54:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 90a4e58:	e0bffe17 	ldw	r2,-8(fp)
 90a4e5c:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 90a4e60:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 90a4e64:	e0bfff17 	ldw	r2,-4(fp)
 90a4e68:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 90a4e6c:	00000906 	br	90a4e94 <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 90a4e70:	e0bffd17 	ldw	r2,-12(fp)
 90a4e74:	1080000b 	ldhu	r2,0(r2)
 90a4e78:	10ffffcc 	andi	r3,r2,65535
 90a4e7c:	e0bffc17 	ldw	r2,-16(fp)
 90a4e80:	10c5883a 	add	r2,r2,r3
 90a4e84:	e0bffc15 	stw	r2,-16(fp)
 90a4e88:	e0bffd17 	ldw	r2,-12(fp)
 90a4e8c:	10800084 	addi	r2,r2,2
 90a4e90:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 90a4e94:	e0bffb17 	ldw	r2,-20(fp)
 90a4e98:	10bfffc4 	addi	r2,r2,-1
 90a4e9c:	e0bffb15 	stw	r2,-20(fp)
 90a4ea0:	e0bffb17 	ldw	r2,-20(fp)
 90a4ea4:	1004403a 	cmpge	r2,r2,zero
 90a4ea8:	103ff11e 	bne	r2,zero,90a4e70 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 90a4eac:	e0bffc17 	ldw	r2,-16(fp)
 90a4eb0:	10ffffcc 	andi	r3,r2,65535
 90a4eb4:	e0bffc17 	ldw	r2,-16(fp)
 90a4eb8:	1004d43a 	srli	r2,r2,16
 90a4ebc:	1885883a 	add	r2,r3,r2
 90a4ec0:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 90a4ec4:	e0bffc17 	ldw	r2,-16(fp)
 90a4ec8:	10ffffcc 	andi	r3,r2,65535
 90a4ecc:	e0bffc17 	ldw	r2,-16(fp)
 90a4ed0:	1004d43a 	srli	r2,r2,16
 90a4ed4:	1885883a 	add	r2,r3,r2
 90a4ed8:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 90a4edc:	e0bffc17 	ldw	r2,-16(fp)
 90a4ee0:	10bfffcc 	andi	r2,r2,65535
}
 90a4ee4:	e037883a 	mov	sp,fp
 90a4ee8:	df000017 	ldw	fp,0(sp)
 90a4eec:	dec00104 	addi	sp,sp,4
 90a4ef0:	f800283a 	ret

090a4ef4 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 90a4ef4:	defffb04 	addi	sp,sp,-20
 90a4ef8:	dfc00415 	stw	ra,16(sp)
 90a4efc:	df000315 	stw	fp,12(sp)
 90a4f00:	df000304 	addi	fp,sp,12
 90a4f04:	e13ffd15 	stw	r4,-12(fp)
 90a4f08:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 90a4f0c:	d0a02f17 	ldw	r2,-32580(gp)
 90a4f10:	108000a0 	cmpeqi	r2,r2,2
 90a4f14:	1000061e 	bne	r2,zero,90a4f30 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 90a4f18:	e13ffd17 	ldw	r4,-12(fp)
 90a4f1c:	e17ffe17 	ldw	r5,-8(fp)
 90a4f20:	90a4e440 	call	90a4e44 <ccksum>
 90a4f24:	10bfffcc 	andi	r2,r2,65535
 90a4f28:	e0bfff15 	stw	r2,-4(fp)
 90a4f2c:	00000506 	br	90a4f44 <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 90a4f30:	e13ffd17 	ldw	r4,-12(fp)
 90a4f34:	e17ffe17 	ldw	r5,-8(fp)
 90a4f38:	90aa2e40 	call	90aa2e4 <asm_cksum>
 90a4f3c:	10bfffcc 	andi	r2,r2,65535
 90a4f40:	e0bfff15 	stw	r2,-4(fp)
 90a4f44:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 90a4f48:	e037883a 	mov	sp,fp
 90a4f4c:	dfc00117 	ldw	ra,4(sp)
 90a4f50:	df000017 	ldw	fp,0(sp)
 90a4f54:	dec00204 	addi	sp,sp,8
 90a4f58:	f800283a 	ret

090a4f5c <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 90a4f5c:	defffe04 	addi	sp,sp,-8
 90a4f60:	dfc00115 	stw	ra,4(sp)
 90a4f64:	df000015 	stw	fp,0(sp)
 90a4f68:	d839883a 	mov	fp,sp
   dtrap();
 90a4f6c:	90aa4780 	call	90aa478 <dtrap>
   return 0;
 90a4f70:	0005883a 	mov	r2,zero
}
 90a4f74:	e037883a 	mov	sp,fp
 90a4f78:	dfc00117 	ldw	ra,4(sp)
 90a4f7c:	df000017 	ldw	fp,0(sp)
 90a4f80:	dec00204 	addi	sp,sp,8
 90a4f84:	f800283a 	ret

090a4f88 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 90a4f88:	defffe04 	addi	sp,sp,-8
 90a4f8c:	df000115 	stw	fp,4(sp)
 90a4f90:	df000104 	addi	fp,sp,4
 90a4f94:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 90a4f98:	00000306 	br	90a4fa8 <nextarg+0x20>
 90a4f9c:	e0bfff17 	ldw	r2,-4(fp)
 90a4fa0:	10800044 	addi	r2,r2,1
 90a4fa4:	e0bfff15 	stw	r2,-4(fp)
 90a4fa8:	e0bfff17 	ldw	r2,-4(fp)
 90a4fac:	10800003 	ldbu	r2,0(r2)
 90a4fb0:	10803fcc 	andi	r2,r2,255
 90a4fb4:	1080201c 	xori	r2,r2,128
 90a4fb8:	10bfe004 	addi	r2,r2,-128
 90a4fbc:	10800848 	cmpgei	r2,r2,33
 90a4fc0:	103ff61e 	bne	r2,zero,90a4f9c <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 90a4fc4:	00000306 	br	90a4fd4 <nextarg+0x4c>
 90a4fc8:	e0bfff17 	ldw	r2,-4(fp)
 90a4fcc:	10800044 	addi	r2,r2,1
 90a4fd0:	e0bfff15 	stw	r2,-4(fp)
 90a4fd4:	e0bfff17 	ldw	r2,-4(fp)
 90a4fd8:	10800003 	ldbu	r2,0(r2)
 90a4fdc:	10803fcc 	andi	r2,r2,255
 90a4fe0:	1080201c 	xori	r2,r2,128
 90a4fe4:	10bfe004 	addi	r2,r2,-128
 90a4fe8:	10800820 	cmpeqi	r2,r2,32
 90a4fec:	103ff61e 	bne	r2,zero,90a4fc8 <nextarg+0x40>
      return (argp);
 90a4ff0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a4ff4:	e037883a 	mov	sp,fp
 90a4ff8:	df000017 	ldw	fp,0(sp)
 90a4ffc:	dec00104 	addi	sp,sp,4
 90a5000:	f800283a 	ret

090a5004 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 90a5004:	defff704 	addi	sp,sp,-36
 90a5008:	dfc00815 	stw	ra,32(sp)
 90a500c:	df000715 	stw	fp,28(sp)
 90a5010:	df000704 	addi	fp,sp,28
 90a5014:	e13ffc15 	stw	r4,-16(fp)
 90a5018:	e17ffd15 	stw	r5,-12(fp)
 90a501c:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 90a5020:	e0bffd17 	ldw	r2,-12(fp)
 90a5024:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 90a5028:	00004006 	br	90a512c <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a502c:	e03ffa15 	stw	zero,-24(fp)
 90a5030:	00000c06 	br	90a5064 <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 90a5034:	e0fffa17 	ldw	r3,-24(fp)
 90a5038:	e0bffb17 	ldw	r2,-20(fp)
 90a503c:	1885883a 	add	r2,r3,r2
 90a5040:	10800003 	ldbu	r2,0(r2)
 90a5044:	11803fcc 	andi	r6,r2,255
 90a5048:	e13ffc17 	ldw	r4,-16(fp)
 90a504c:	01424374 	movhi	r5,2317
 90a5050:	29403e04 	addi	r5,r5,248
 90a5054:	90a55a40 	call	90a55a4 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a5058:	e0bffa17 	ldw	r2,-24(fp)
 90a505c:	10800044 	addi	r2,r2,1
 90a5060:	e0bffa15 	stw	r2,-24(fp)
 90a5064:	e0bffa17 	ldw	r2,-24(fp)
 90a5068:	10800428 	cmpgeui	r2,r2,16
 90a506c:	1000031e 	bne	r2,zero,90a507c <hexdump+0x78>
 90a5070:	e0fffa17 	ldw	r3,-24(fp)
 90a5074:	e0bffe17 	ldw	r2,-8(fp)
 90a5078:	18bfee36 	bltu	r3,r2,90a5034 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a507c:	e03ffa15 	stw	zero,-24(fp)
 90a5080:	00001806 	br	90a50e4 <hexdump+0xe0>
      {
         c = *(data + count);
 90a5084:	e0fffa17 	ldw	r3,-24(fp)
 90a5088:	e0bffb17 	ldw	r2,-20(fp)
 90a508c:	1885883a 	add	r2,r3,r2
 90a5090:	10800003 	ldbu	r2,0(r2)
 90a5094:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 90a5098:	e0bff907 	ldb	r2,-28(fp)
 90a509c:	10800810 	cmplti	r2,r2,32
 90a50a0:	1000061e 	bne	r2,zero,90a50bc <hexdump+0xb8>
 90a50a4:	e0bff907 	ldb	r2,-28(fp)
 90a50a8:	10801fe0 	cmpeqi	r2,r2,127
 90a50ac:	1000031e 	bne	r2,zero,90a50bc <hexdump+0xb8>
 90a50b0:	e0bff907 	ldb	r2,-28(fp)
 90a50b4:	e0bfff15 	stw	r2,-4(fp)
 90a50b8:	00000206 	br	90a50c4 <hexdump+0xc0>
 90a50bc:	00800b84 	movi	r2,46
 90a50c0:	e0bfff15 	stw	r2,-4(fp)
 90a50c4:	e13ffc17 	ldw	r4,-16(fp)
 90a50c8:	01424374 	movhi	r5,2317
 90a50cc:	29404004 	addi	r5,r5,256
 90a50d0:	e1bfff17 	ldw	r6,-4(fp)
 90a50d4:	90a55a40 	call	90a55a4 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 90a50d8:	e0bffa17 	ldw	r2,-24(fp)
 90a50dc:	10800044 	addi	r2,r2,1
 90a50e0:	e0bffa15 	stw	r2,-24(fp)
 90a50e4:	e0bffa17 	ldw	r2,-24(fp)
 90a50e8:	10800428 	cmpgeui	r2,r2,16
 90a50ec:	1000031e 	bne	r2,zero,90a50fc <hexdump+0xf8>
 90a50f0:	e0fffa17 	ldw	r3,-24(fp)
 90a50f4:	e0bffe17 	ldw	r2,-8(fp)
 90a50f8:	18bfe236 	bltu	r3,r2,90a5084 <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 90a50fc:	e13ffc17 	ldw	r4,-16(fp)
 90a5100:	01424374 	movhi	r5,2317
 90a5104:	29404104 	addi	r5,r5,260
 90a5108:	90a55a40 	call	90a55a4 <ns_printf>
      len -= count;
 90a510c:	e0fffe17 	ldw	r3,-8(fp)
 90a5110:	e0bffa17 	ldw	r2,-24(fp)
 90a5114:	1885c83a 	sub	r2,r3,r2
 90a5118:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 90a511c:	e0fffa17 	ldw	r3,-24(fp)
 90a5120:	e0bffb17 	ldw	r2,-20(fp)
 90a5124:	10c5883a 	add	r2,r2,r3
 90a5128:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 90a512c:	e0bffe17 	ldw	r2,-8(fp)
 90a5130:	1004c03a 	cmpne	r2,r2,zero
 90a5134:	103fbd1e 	bne	r2,zero,90a502c <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 90a5138:	e037883a 	mov	sp,fp
 90a513c:	dfc00117 	ldw	ra,4(sp)
 90a5140:	df000017 	ldw	fp,0(sp)
 90a5144:	dec00204 	addi	sp,sp,8
 90a5148:	f800283a 	ret

090a514c <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 90a514c:	defffa04 	addi	sp,sp,-24
 90a5150:	dfc00515 	stw	ra,20(sp)
 90a5154:	df000415 	stw	fp,16(sp)
 90a5158:	df000404 	addi	fp,sp,16
 90a515c:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 90a5160:	e0bfff17 	ldw	r2,-4(fp)
 90a5164:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 90a5168:	e0bffe03 	ldbu	r2,-8(fp)
 90a516c:	11803fcc 	andi	r6,r2,255
 90a5170:	e0bffe43 	ldbu	r2,-7(fp)
 90a5174:	11c03fcc 	andi	r7,r2,255
 90a5178:	e0bffe83 	ldbu	r2,-6(fp)
 90a517c:	10c03fcc 	andi	r3,r2,255
 90a5180:	e0bffec3 	ldbu	r2,-5(fp)
 90a5184:	10803fcc 	andi	r2,r2,255
 90a5188:	d8c00015 	stw	r3,0(sp)
 90a518c:	d8800115 	stw	r2,4(sp)
 90a5190:	010243b4 	movhi	r4,2318
 90a5194:	21360784 	addi	r4,r4,-10210
 90a5198:	01424374 	movhi	r5,2317
 90a519c:	29404204 	addi	r5,r5,264
 90a51a0:	908372c0 	call	908372c <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 90a51a4:	008243b4 	movhi	r2,2318
 90a51a8:	10b60784 	addi	r2,r2,-10210
}
 90a51ac:	e037883a 	mov	sp,fp
 90a51b0:	dfc00117 	ldw	ra,4(sp)
 90a51b4:	df000017 	ldw	fp,0(sp)
 90a51b8:	dec00204 	addi	sp,sp,8
 90a51bc:	f800283a 	ret

090a51c0 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 90a51c0:	deffee04 	addi	sp,sp,-72
 90a51c4:	dfc01115 	stw	ra,68(sp)
 90a51c8:	df001015 	stw	fp,64(sp)
 90a51cc:	df001004 	addi	fp,sp,64
 90a51d0:	e13ff515 	stw	r4,-44(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 90a51d4:	e0fff517 	ldw	r3,-44(fp)
 90a51d8:	00947b34 	movhi	r2,20972
 90a51dc:	10a147c4 	addi	r2,r2,-31457
 90a51e0:	1889383a 	mul	r4,r3,r2
 90a51e4:	e13ff615 	stw	r4,-40(fp)
 90a51e8:	1886383a 	mulxuu	r3,r3,r2
 90a51ec:	e0fff715 	stw	r3,-36(fp)
 90a51f0:	e0fff717 	ldw	r3,-36(fp)
 90a51f4:	1804d17a 	srli	r2,r3,5
 90a51f8:	e0bff515 	stw	r2,-44(fp)
   seconds = (unsigned)(timetick%60);
 90a51fc:	e0fff517 	ldw	r3,-44(fp)
 90a5200:	00800f04 	movi	r2,60
 90a5204:	1885203a 	divu	r2,r3,r2
 90a5208:	10800f24 	muli	r2,r2,60
 90a520c:	1885c83a 	sub	r2,r3,r2
 90a5210:	e0bff415 	stw	r2,-48(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 90a5214:	e0fff517 	ldw	r3,-44(fp)
 90a5218:	00a22274 	movhi	r2,34953
 90a521c:	10a22244 	addi	r2,r2,-30583
 90a5220:	1889383a 	mul	r4,r3,r2
 90a5224:	e13ff815 	stw	r4,-32(fp)
 90a5228:	1886383a 	mulxuu	r3,r3,r2
 90a522c:	e0fff915 	stw	r3,-28(fp)
 90a5230:	e0fff917 	ldw	r3,-28(fp)
 90a5234:	1804d17a 	srli	r2,r3,5
 90a5238:	e0bff515 	stw	r2,-44(fp)
   minutes = (unsigned)(timetick%60);
 90a523c:	e0fff517 	ldw	r3,-44(fp)
 90a5240:	00a22274 	movhi	r2,34953
 90a5244:	10a22244 	addi	r2,r2,-30583
 90a5248:	1889383a 	mul	r4,r3,r2
 90a524c:	e13ffa15 	stw	r4,-24(fp)
 90a5250:	1884383a 	mulxuu	r2,r3,r2
 90a5254:	e0bffb15 	stw	r2,-20(fp)
 90a5258:	e13ffb17 	ldw	r4,-20(fp)
 90a525c:	2004d17a 	srli	r2,r4,5
 90a5260:	10800f24 	muli	r2,r2,60
 90a5264:	1885c83a 	sub	r2,r3,r2
 90a5268:	e0bff315 	stw	r2,-52(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 90a526c:	e0fff517 	ldw	r3,-44(fp)
 90a5270:	00a22274 	movhi	r2,34953
 90a5274:	10a22244 	addi	r2,r2,-30583
 90a5278:	1889383a 	mul	r4,r3,r2
 90a527c:	e13ffc15 	stw	r4,-16(fp)
 90a5280:	1886383a 	mulxuu	r3,r3,r2
 90a5284:	e0fffd15 	stw	r3,-12(fp)
 90a5288:	e0fffd17 	ldw	r3,-12(fp)
 90a528c:	1804d17a 	srli	r2,r3,5
 90a5290:	e0bff515 	stw	r2,-44(fp)
   hours = (unsigned)(timetick%24);
 90a5294:	e0fff517 	ldw	r3,-44(fp)
 90a5298:	00800604 	movi	r2,24
 90a529c:	1885203a 	divu	r2,r3,r2
 90a52a0:	10800624 	muli	r2,r2,24
 90a52a4:	1885c83a 	sub	r2,r3,r2
 90a52a8:	e0bff215 	stw	r2,-56(fp)
   timetick = timetick/24;    /* turn timetick into days */
 90a52ac:	e0fff517 	ldw	r3,-44(fp)
 90a52b0:	00aaaaf4 	movhi	r2,43691
 90a52b4:	10aaaac4 	addi	r2,r2,-21845
 90a52b8:	1889383a 	mul	r4,r3,r2
 90a52bc:	e13ffe15 	stw	r4,-8(fp)
 90a52c0:	1886383a 	mulxuu	r3,r3,r2
 90a52c4:	e0ffff15 	stw	r3,-4(fp)
 90a52c8:	e0ffff17 	ldw	r3,-4(fp)
 90a52cc:	1804d13a 	srli	r2,r3,4
 90a52d0:	e0bff515 	stw	r2,-44(fp)

   if (timetick)  /* Is there a whole number of days? */
 90a52d4:	e0bff517 	ldw	r2,-44(fp)
 90a52d8:	1005003a 	cmpeq	r2,r2,zero
 90a52dc:	10000c1e 	bne	r2,zero,90a5310 <print_uptime+0x150>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 90a52e0:	e0bff317 	ldw	r2,-52(fp)
 90a52e4:	d8800015 	stw	r2,0(sp)
 90a52e8:	e0bff417 	ldw	r2,-48(fp)
 90a52ec:	d8800115 	stw	r2,4(sp)
 90a52f0:	01024374 	movhi	r4,2317
 90a52f4:	21150004 	addi	r4,r4,21504
 90a52f8:	01424374 	movhi	r5,2317
 90a52fc:	29404504 	addi	r5,r5,276
 90a5300:	e1bff517 	ldw	r6,-44(fp)
 90a5304:	e1fff217 	ldw	r7,-56(fp)
 90a5308:	908372c0 	call	908372c <sprintf>
 90a530c:	00001406 	br	90a5360 <print_uptime+0x1a0>
    timetick, hours, minutes, seconds);
   else if (hours)
 90a5310:	e0bff217 	ldw	r2,-56(fp)
 90a5314:	1005003a 	cmpeq	r2,r2,zero
 90a5318:	10000a1e 	bne	r2,zero,90a5344 <print_uptime+0x184>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 90a531c:	e0bff417 	ldw	r2,-48(fp)
 90a5320:	d8800015 	stw	r2,0(sp)
 90a5324:	01024374 	movhi	r4,2317
 90a5328:	21150004 	addi	r4,r4,21504
 90a532c:	01424374 	movhi	r5,2317
 90a5330:	29404b04 	addi	r5,r5,300
 90a5334:	e1bff217 	ldw	r6,-56(fp)
 90a5338:	e1fff317 	ldw	r7,-52(fp)
 90a533c:	908372c0 	call	908372c <sprintf>
 90a5340:	00000706 	br	90a5360 <print_uptime+0x1a0>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 90a5344:	01024374 	movhi	r4,2317
 90a5348:	21150004 	addi	r4,r4,21504
 90a534c:	01424374 	movhi	r5,2317
 90a5350:	29405004 	addi	r5,r5,320
 90a5354:	e1bff317 	ldw	r6,-52(fp)
 90a5358:	e1fff417 	ldw	r7,-48(fp)
 90a535c:	908372c0 	call	908372c <sprintf>
   return tistring;
 90a5360:	00824374 	movhi	r2,2317
 90a5364:	10950004 	addi	r2,r2,21504
}
 90a5368:	e037883a 	mov	sp,fp
 90a536c:	dfc00117 	ldw	ra,4(sp)
 90a5370:	df000017 	ldw	fp,0(sp)
 90a5374:	dec00204 	addi	sp,sp,8
 90a5378:	f800283a 	ret

090a537c <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 90a537c:	defffd04 	addi	sp,sp,-12
 90a5380:	dfc00215 	stw	ra,8(sp)
 90a5384:	df000115 	stw	fp,4(sp)
 90a5388:	df000104 	addi	fp,sp,4
 90a538c:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 90a5390:	01024374 	movhi	r4,2317
 90a5394:	21005504 	addi	r4,r4,340
 90a5398:	e17fff17 	ldw	r5,-4(fp)
 90a539c:	90833900 	call	9083390 <printf>
   dtrap();                   /* try to hook debugger */
 90a53a0:	90aa4780 	call	90aa478 <dtrap>
   netexit(1);                /* try to clean up */
 90a53a4:	01000044 	movi	r4,1
 90a53a8:	90c31100 	call	90c3110 <netexit>
}
 90a53ac:	e037883a 	mov	sp,fp
 90a53b0:	dfc00117 	ldw	ra,4(sp)
 90a53b4:	df000017 	ldw	fp,0(sp)
 90a53b8:	dec00204 	addi	sp,sp,8
 90a53bc:	f800283a 	ret

090a53c0 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 90a53c0:	defffb04 	addi	sp,sp,-20
 90a53c4:	df000415 	stw	fp,16(sp)
 90a53c8:	df000404 	addi	fp,sp,16
 90a53cc:	e13ffe15 	stw	r4,-8(fp)
 90a53d0:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 90a53d4:	008243b4 	movhi	r2,2318
 90a53d8:	10b60304 	addi	r2,r2,-10228
 90a53dc:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 90a53e0:	e03ffd15 	stw	zero,-12(fp)
 90a53e4:	00004406 	br	90a54f8 <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 90a53e8:	e0bffe17 	ldw	r2,-8(fp)
 90a53ec:	10800003 	ldbu	r2,0(r2)
 90a53f0:	10803fcc 	andi	r2,r2,255
 90a53f4:	1080201c 	xori	r2,r2,128
 90a53f8:	10bfe004 	addi	r2,r2,-128
 90a53fc:	1005d13a 	srai	r2,r2,4
 90a5400:	108003cc 	andi	r2,r2,15
 90a5404:	10800c04 	addi	r2,r2,48
 90a5408:	1007883a 	mov	r3,r2
 90a540c:	e0bffc17 	ldw	r2,-16(fp)
 90a5410:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 90a5414:	e0bffc17 	ldw	r2,-16(fp)
 90a5418:	10800003 	ldbu	r2,0(r2)
 90a541c:	10803fcc 	andi	r2,r2,255
 90a5420:	1080201c 	xori	r2,r2,128
 90a5424:	10bfe004 	addi	r2,r2,-128
 90a5428:	10800e90 	cmplti	r2,r2,58
 90a542c:	1000061e 	bne	r2,zero,90a5448 <print_eth+0x88>
         (*out) += 7;
 90a5430:	e0bffc17 	ldw	r2,-16(fp)
 90a5434:	10800003 	ldbu	r2,0(r2)
 90a5438:	108001c4 	addi	r2,r2,7
 90a543c:	1007883a 	mov	r3,r2
 90a5440:	e0bffc17 	ldw	r2,-16(fp)
 90a5444:	10c00005 	stb	r3,0(r2)
      out++;
 90a5448:	e0bffc17 	ldw	r2,-16(fp)
 90a544c:	10800044 	addi	r2,r2,1
 90a5450:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 90a5454:	e0bffe17 	ldw	r2,-8(fp)
 90a5458:	10800003 	ldbu	r2,0(r2)
 90a545c:	108003cc 	andi	r2,r2,15
 90a5460:	10800c04 	addi	r2,r2,48
 90a5464:	1007883a 	mov	r3,r2
 90a5468:	e0bffc17 	ldw	r2,-16(fp)
 90a546c:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 90a5470:	e0bffc17 	ldw	r2,-16(fp)
 90a5474:	10800003 	ldbu	r2,0(r2)
 90a5478:	10803fcc 	andi	r2,r2,255
 90a547c:	1080201c 	xori	r2,r2,128
 90a5480:	10bfe004 	addi	r2,r2,-128
 90a5484:	10800e90 	cmplti	r2,r2,58
 90a5488:	1000061e 	bne	r2,zero,90a54a4 <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 90a548c:	e0bffc17 	ldw	r2,-16(fp)
 90a5490:	10800003 	ldbu	r2,0(r2)
 90a5494:	108001c4 	addi	r2,r2,7
 90a5498:	1007883a 	mov	r3,r2
 90a549c:	e0bffc17 	ldw	r2,-16(fp)
 90a54a0:	10c00005 	stb	r3,0(r2)
      out++;
 90a54a4:	e0bffc17 	ldw	r2,-16(fp)
 90a54a8:	10800044 	addi	r2,r2,1
 90a54ac:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 90a54b0:	e0bfff07 	ldb	r2,-4(fp)
 90a54b4:	1005003a 	cmpeq	r2,r2,zero
 90a54b8:	1000091e 	bne	r2,zero,90a54e0 <print_eth+0x120>
 90a54bc:	e0bffd17 	ldw	r2,-12(fp)
 90a54c0:	10800148 	cmpgei	r2,r2,5
 90a54c4:	1000061e 	bne	r2,zero,90a54e0 <print_eth+0x120>
         *out++ = spacer;
 90a54c8:	e0fffc17 	ldw	r3,-16(fp)
 90a54cc:	e0bfff03 	ldbu	r2,-4(fp)
 90a54d0:	18800005 	stb	r2,0(r3)
 90a54d4:	e0bffc17 	ldw	r2,-16(fp)
 90a54d8:	10800044 	addi	r2,r2,1
 90a54dc:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 90a54e0:	e0bffe17 	ldw	r2,-8(fp)
 90a54e4:	10800044 	addi	r2,r2,1
 90a54e8:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 90a54ec:	e0bffd17 	ldw	r2,-12(fp)
 90a54f0:	10800044 	addi	r2,r2,1
 90a54f4:	e0bffd15 	stw	r2,-12(fp)
 90a54f8:	e0bffd17 	ldw	r2,-12(fp)
 90a54fc:	10800190 	cmplti	r2,r2,6
 90a5500:	103fb91e 	bne	r2,zero,90a53e8 <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 90a5504:	e0bffc17 	ldw	r2,-16(fp)
 90a5508:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 90a550c:	008243b4 	movhi	r2,2318
 90a5510:	10b60304 	addi	r2,r2,-10228
}
 90a5514:	e037883a 	mov	sp,fp
 90a5518:	df000017 	ldw	fp,0(sp)
 90a551c:	dec00104 	addi	sp,sp,4
 90a5520:	f800283a 	ret

090a5524 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 90a5524:	defffd04 	addi	sp,sp,-12
 90a5528:	df000215 	stw	fp,8(sp)
 90a552c:	df000204 	addi	fp,sp,8
 90a5530:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 90a5534:	e0bfff17 	ldw	r2,-4(fp)
 90a5538:	e0bffe15 	stw	r2,-8(fp)
 90a553c:	00000d06 	br	90a5574 <uslash+0x50>
      if (*cp == '\\')
 90a5540:	e0bffe17 	ldw	r2,-8(fp)
 90a5544:	10800003 	ldbu	r2,0(r2)
 90a5548:	10803fcc 	andi	r2,r2,255
 90a554c:	1080201c 	xori	r2,r2,128
 90a5550:	10bfe004 	addi	r2,r2,-128
 90a5554:	10801718 	cmpnei	r2,r2,92
 90a5558:	1000031e 	bne	r2,zero,90a5568 <uslash+0x44>
      *cp = '/';
 90a555c:	e0fffe17 	ldw	r3,-8(fp)
 90a5560:	00800bc4 	movi	r2,47
 90a5564:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 90a5568:	e0bffe17 	ldw	r2,-8(fp)
 90a556c:	10800044 	addi	r2,r2,1
 90a5570:	e0bffe15 	stw	r2,-8(fp)
 90a5574:	e0bffe17 	ldw	r2,-8(fp)
 90a5578:	10800003 	ldbu	r2,0(r2)
 90a557c:	10803fcc 	andi	r2,r2,255
 90a5580:	1080201c 	xori	r2,r2,128
 90a5584:	10bfe004 	addi	r2,r2,-128
 90a5588:	1004c03a 	cmpne	r2,r2,zero
 90a558c:	103fec1e 	bne	r2,zero,90a5540 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 90a5590:	e0bfff17 	ldw	r2,-4(fp)
}
 90a5594:	e037883a 	mov	sp,fp
 90a5598:	df000017 	ldw	fp,0(sp)
 90a559c:	dec00104 	addi	sp,sp,4
 90a55a0:	f800283a 	ret

090a55a4 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 90a55a4:	defff204 	addi	sp,sp,-56
 90a55a8:	dfc00b15 	stw	ra,44(sp)
 90a55ac:	df000a15 	stw	fp,40(sp)
 90a55b0:	dc400915 	stw	r17,36(sp)
 90a55b4:	dc000815 	stw	r16,32(sp)
 90a55b8:	df000804 	addi	fp,sp,32
 90a55bc:	e13ffd15 	stw	r4,-12(fp)
 90a55c0:	e1800415 	stw	r6,16(fp)
 90a55c4:	e1c00515 	stw	r7,20(fp)
 90a55c8:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 90a55cc:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 90a55d0:	00802704 	movi	r2,156
 90a55d4:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 90a55d8:	e0bffd17 	ldw	r2,-12(fp)
 90a55dc:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 90a55e0:	e0bff817 	ldw	r2,-32(fp)
 90a55e4:	1004c03a 	cmpne	r2,r2,zero
 90a55e8:	1000091e 	bne	r2,zero,90a5610 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 90a55ec:	e0800404 	addi	r2,fp,16
 90a55f0:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 90a55f4:	e17ffc17 	ldw	r5,-16(fp)
 90a55f8:	e13ffe17 	ldw	r4,-8(fp)
 90a55fc:	90cb97c0 	call	90cb97c <vprintf>
 90a5600:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 90a5604:	e0bffa17 	ldw	r2,-24(fp)
 90a5608:	e0bfff15 	stw	r2,-4(fp)
 90a560c:	00003e06 	br	90a5708 <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 90a5610:	e0bff817 	ldw	r2,-32(fp)
 90a5614:	10800117 	ldw	r2,4(r2)
 90a5618:	1004c03a 	cmpne	r2,r2,zero
 90a561c:	1000031e 	bne	r2,zero,90a562c <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 90a5620:	00bfffc4 	movi	r2,-1
 90a5624:	e0bfff15 	stw	r2,-4(fp)
 90a5628:	00003706 	br	90a5708 <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 90a562c:	e13ffe17 	ldw	r4,-8(fp)
 90a5630:	9083f540 	call	9083f54 <strlen>
 90a5634:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 90a5638:	e0bffa17 	ldw	r2,-24(fp)
 90a563c:	10802710 	cmplti	r2,r2,156
 90a5640:	1000041e 	bne	r2,zero,90a5654 <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 90a5644:	e0bff917 	ldw	r2,-28(fp)
 90a5648:	e0fffa17 	ldw	r3,-24(fp)
 90a564c:	10c5883a 	add	r2,r2,r3
 90a5650:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 90a5654:	e13ff917 	ldw	r4,-28(fp)
 90a5658:	90aaefc0 	call	90aaefc <npalloc>
 90a565c:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 90a5660:	e0bffb17 	ldw	r2,-20(fp)
 90a5664:	1004c03a 	cmpne	r2,r2,zero
 90a5668:	1000031e 	bne	r2,zero,90a5678 <ns_printf+0xd4>
   {
      return -2;
 90a566c:	00bfff84 	movi	r2,-2
 90a5670:	e0bfff15 	stw	r2,-4(fp)
 90a5674:	00002406 	br	90a5708 <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 90a5678:	e0800404 	addi	r2,fp,16
 90a567c:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 90a5680:	e1bffc17 	ldw	r6,-16(fp)
 90a5684:	e13ffb17 	ldw	r4,-20(fp)
 90a5688:	e17ffe17 	ldw	r5,-8(fp)
 90a568c:	90cb9ec0 	call	90cb9ec <vsprintf>
 90a5690:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 90a5694:	e13ffb17 	ldw	r4,-20(fp)
 90a5698:	9083f540 	call	9083f54 <strlen>
 90a569c:	1007883a 	mov	r3,r2
 90a56a0:	e0bff917 	ldw	r2,-28(fp)
 90a56a4:	10c0080e 	bge	r2,r3,90a56c8 <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 90a56a8:	01024374 	movhi	r4,2317
 90a56ac:	21005804 	addi	r4,r4,352
 90a56b0:	90a537c0 	call	90a537c <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 90a56b4:	e0fff917 	ldw	r3,-28(fp)
 90a56b8:	e0bffb17 	ldw	r2,-20(fp)
 90a56bc:	1885883a 	add	r2,r3,r2
 90a56c0:	10bfffc4 	addi	r2,r2,-1
 90a56c4:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 90a56c8:	e0bff817 	ldw	r2,-32(fp)
 90a56cc:	14400117 	ldw	r17,4(r2)
 90a56d0:	e0bff817 	ldw	r2,-32(fp)
 90a56d4:	14000217 	ldw	r16,8(r2)
 90a56d8:	e13ffb17 	ldw	r4,-20(fp)
 90a56dc:	9083f540 	call	9083f54 <strlen>
 90a56e0:	100d883a 	mov	r6,r2
 90a56e4:	8009883a 	mov	r4,r16
 90a56e8:	e17ffb17 	ldw	r5,-20(fp)
 90a56ec:	883ee83a 	callr	r17
 90a56f0:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 90a56f4:	e13ffb17 	ldw	r4,-20(fp)
 90a56f8:	90aaff00 	call	90aaff0 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 90a56fc:	90a600c0 	call	90a600c <tk_yield>

   return ret_value ;
 90a5700:	e0bffa17 	ldw	r2,-24(fp)
 90a5704:	e0bfff15 	stw	r2,-4(fp)
 90a5708:	e0bfff17 	ldw	r2,-4(fp)
}
 90a570c:	e037883a 	mov	sp,fp
 90a5710:	dfc00317 	ldw	ra,12(sp)
 90a5714:	df000217 	ldw	fp,8(sp)
 90a5718:	dc400117 	ldw	r17,4(sp)
 90a571c:	dc000017 	ldw	r16,0(sp)
 90a5720:	dec00604 	addi	sp,sp,24
 90a5724:	f800283a 	ret

090a5728 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 90a5728:	defffb04 	addi	sp,sp,-20
 90a572c:	dfc00415 	stw	ra,16(sp)
 90a5730:	df000315 	stw	fp,12(sp)
 90a5734:	df000304 	addi	fp,sp,12
 90a5738:	e13ffd15 	stw	r4,-12(fp)
 90a573c:	e17ffe15 	stw	r5,-8(fp)
 90a5740:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 90a5744:	01024374 	movhi	r4,2317
 90a5748:	21005f04 	addi	r4,r4,380
 90a574c:	e17ffe17 	ldw	r5,-8(fp)
 90a5750:	90833900 	call	9083390 <printf>
   USE_ARG(s);
   return len;
 90a5754:	e0bfff17 	ldw	r2,-4(fp)
}
 90a5758:	e037883a 	mov	sp,fp
 90a575c:	dfc00117 	ldw	ra,4(sp)
 90a5760:	df000017 	ldw	fp,0(sp)
 90a5764:	dec00204 	addi	sp,sp,8
 90a5768:	f800283a 	ret

090a576c <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 90a576c:	defff904 	addi	sp,sp,-28
 90a5770:	dfc00615 	stw	ra,24(sp)
 90a5774:	df000515 	stw	fp,20(sp)
 90a5778:	df000504 	addi	fp,sp,20
 90a577c:	e13ffd15 	stw	r4,-12(fp)
 90a5780:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 90a5784:	e0bffd17 	ldw	r2,-12(fp)
 90a5788:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 90a578c:	e0fffe17 	ldw	r3,-8(fp)
 90a5790:	00800504 	movi	r2,20
 90a5794:	1885283a 	div	r2,r3,r2
 90a5798:	10800524 	muli	r2,r2,20
 90a579c:	1885c83a 	sub	r2,r3,r2
 90a57a0:	1004c03a 	cmpne	r2,r2,zero
 90a57a4:	1000281e 	bne	r2,zero,90a5848 <con_page+0xdc>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 90a57a8:	e0bffb17 	ldw	r2,-20(fp)
 90a57ac:	1005003a 	cmpeq	r2,r2,zero
 90a57b0:	1000251e 	bne	r2,zero,90a5848 <con_page+0xdc>
 90a57b4:	e0bffb17 	ldw	r2,-20(fp)
 90a57b8:	10800317 	ldw	r2,12(r2)
 90a57bc:	1005003a 	cmpeq	r2,r2,zero
 90a57c0:	1000211e 	bne	r2,zero,90a5848 <con_page+0xdc>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 90a57c4:	e13ffb17 	ldw	r4,-20(fp)
 90a57c8:	01424374 	movhi	r5,2317
 90a57cc:	29406004 	addi	r5,r5,384
 90a57d0:	90a55a40 	call	90a55a4 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 90a57d4:	e0bffb17 	ldw	r2,-20(fp)
 90a57d8:	10c00317 	ldw	r3,12(r2)
 90a57dc:	e0bffb17 	ldw	r2,-20(fp)
 90a57e0:	11000217 	ldw	r4,8(r2)
 90a57e4:	183ee83a 	callr	r3
 90a57e8:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 90a57ec:	e0bffc17 	ldw	r2,-16(fp)
 90a57f0:	1004c03a 	cmpne	r2,r2,zero
 90a57f4:	1000011e 	bne	r2,zero,90a57fc <con_page+0x90>
               tk_yield();    /* Give timeslice to other processes */
 90a57f8:	90a600c0 	call	90a600c <tk_yield>
         } while (ch == 0) ;
 90a57fc:	e0bffc17 	ldw	r2,-16(fp)
 90a5800:	1005003a 	cmpeq	r2,r2,zero
 90a5804:	103ff31e 	bne	r2,zero,90a57d4 <con_page+0x68>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 90a5808:	e0bffc17 	ldw	r2,-16(fp)
 90a580c:	10bfffd8 	cmpnei	r2,r2,-1
 90a5810:	1000031e 	bne	r2,zero,90a5820 <con_page+0xb4>
            return 1 ;
 90a5814:	00800044 	movi	r2,1
 90a5818:	e0bfff15 	stw	r2,-4(fp)
 90a581c:	00000b06 	br	90a584c <con_page+0xe0>

         ns_printf(pio,"\n");
 90a5820:	e13ffb17 	ldw	r4,-20(fp)
 90a5824:	01424374 	movhi	r5,2317
 90a5828:	29404104 	addi	r5,r5,260
 90a582c:	90a55a40 	call	90a55a4 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 90a5830:	e0bffc17 	ldw	r2,-16(fp)
 90a5834:	108006d8 	cmpnei	r2,r2,27
 90a5838:	1000031e 	bne	r2,zero,90a5848 <con_page+0xdc>
            return 1 ;
 90a583c:	00800044 	movi	r2,1
 90a5840:	e0bfff15 	stw	r2,-4(fp)
 90a5844:	00000106 	br	90a584c <con_page+0xe0>
      }
   }
   return  0;
 90a5848:	e03fff15 	stw	zero,-4(fp)
 90a584c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a5850:	e037883a 	mov	sp,fp
 90a5854:	dfc00117 	ldw	ra,4(sp)
 90a5858:	df000017 	ldw	fp,0(sp)
 90a585c:	dec00204 	addi	sp,sp,8
 90a5860:	f800283a 	ret

090a5864 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 90a5864:	defff604 	addi	sp,sp,-40
 90a5868:	dfc00915 	stw	ra,36(sp)
 90a586c:	df000815 	stw	fp,32(sp)
 90a5870:	df000804 	addi	fp,sp,32
 90a5874:	e13ffc15 	stw	r4,-16(fp)
 90a5878:	e17ffd15 	stw	r5,-12(fp)
 90a587c:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 90a5880:	e0bffc17 	ldw	r2,-16(fp)
 90a5884:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 90a5888:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 90a588c:	e0bffe17 	ldw	r2,-8(fp)
 90a5890:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 90a5894:	e0bffc17 	ldw	r2,-16(fp)
 90a5898:	1004c03a 	cmpne	r2,r2,zero
 90a589c:	1000021e 	bne	r2,zero,90a58a8 <parse_args+0x44>
   {
      return (NULL);
 90a58a0:	e03fff15 	stw	zero,-4(fp)
 90a58a4:	00007406 	br	90a5a78 <parse_args+0x214>
   }
   len = strlen(buf);
 90a58a8:	e13ffc17 	ldw	r4,-16(fp)
 90a58ac:	9083f540 	call	9083f54 <strlen>
 90a58b0:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 90a58b4:	e0bffa17 	ldw	r2,-24(fp)
 90a58b8:	10800048 	cmpgei	r2,r2,1
 90a58bc:	1000021e 	bne	r2,zero,90a58c8 <parse_args+0x64>
   {
      return (NULL);
 90a58c0:	e03fff15 	stw	zero,-4(fp)
 90a58c4:	00006c06 	br	90a5a78 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 90a58c8:	e0bffd17 	ldw	r2,-12(fp)
 90a58cc:	1085883a 	add	r2,r2,r2
 90a58d0:	1085883a 	add	r2,r2,r2
 90a58d4:	1009883a 	mov	r4,r2
 90a58d8:	90aaefc0 	call	90aaefc <npalloc>
 90a58dc:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 90a58e0:	e0bff817 	ldw	r2,-32(fp)
 90a58e4:	1004c03a 	cmpne	r2,r2,zero
 90a58e8:	1000051e 	bne	r2,zero,90a5900 <parse_args+0x9c>
   {
      return (NULL);
 90a58ec:	e03fff15 	stw	zero,-4(fp)
 90a58f0:	00006106 	br	90a5a78 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 90a58f4:	e0bff917 	ldw	r2,-28(fp)
 90a58f8:	10800044 	addi	r2,r2,1
 90a58fc:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 90a5900:	e0bff917 	ldw	r2,-28(fp)
 90a5904:	10800003 	ldbu	r2,0(r2)
 90a5908:	10803fcc 	andi	r2,r2,255
 90a590c:	1080201c 	xori	r2,r2,128
 90a5910:	10bfe004 	addi	r2,r2,-128
 90a5914:	10800820 	cmpeqi	r2,r2,32
 90a5918:	103ff61e 	bne	r2,zero,90a58f4 <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 90a591c:	00003206 	br	90a59e8 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 90a5920:	e0bffe17 	ldw	r2,-8(fp)
 90a5924:	10800017 	ldw	r2,0(r2)
 90a5928:	1085883a 	add	r2,r2,r2
 90a592c:	1085883a 	add	r2,r2,r2
 90a5930:	1007883a 	mov	r3,r2
 90a5934:	e0bff817 	ldw	r2,-32(fp)
 90a5938:	1887883a 	add	r3,r3,r2
 90a593c:	e0bff917 	ldw	r2,-28(fp)
 90a5940:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 90a5944:	e0bffe17 	ldw	r2,-8(fp)
 90a5948:	10800017 	ldw	r2,0(r2)
 90a594c:	10c00044 	addi	r3,r2,1
 90a5950:	e0bffe17 	ldw	r2,-8(fp)
 90a5954:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 90a5958:	00000306 	br	90a5968 <parse_args+0x104>
      {
         bp++; 
 90a595c:	e0bff917 	ldw	r2,-28(fp)
 90a5960:	10800044 	addi	r2,r2,1
 90a5964:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 90a5968:	e0bff917 	ldw	r2,-28(fp)
 90a596c:	10800003 	ldbu	r2,0(r2)
 90a5970:	10803fcc 	andi	r2,r2,255
 90a5974:	1080201c 	xori	r2,r2,128
 90a5978:	10bfe004 	addi	r2,r2,-128
 90a597c:	10800820 	cmpeqi	r2,r2,32
 90a5980:	10000b1e 	bne	r2,zero,90a59b0 <parse_args+0x14c>
 90a5984:	e0bff917 	ldw	r2,-28(fp)
 90a5988:	10800003 	ldbu	r2,0(r2)
 90a598c:	10803fcc 	andi	r2,r2,255
 90a5990:	1080201c 	xori	r2,r2,128
 90a5994:	10bfe004 	addi	r2,r2,-128
 90a5998:	1004c03a 	cmpne	r2,r2,zero
 90a599c:	103fef1e 	bne	r2,zero,90a595c <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 90a59a0:	00000306 	br	90a59b0 <parse_args+0x14c>
      {
         bp++; 
 90a59a4:	e0bff917 	ldw	r2,-28(fp)
 90a59a8:	10800044 	addi	r2,r2,1
 90a59ac:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 90a59b0:	e0bff917 	ldw	r2,-28(fp)
 90a59b4:	10800003 	ldbu	r2,0(r2)
 90a59b8:	10803fcc 	andi	r2,r2,255
 90a59bc:	1080201c 	xori	r2,r2,128
 90a59c0:	10bfe004 	addi	r2,r2,-128
 90a59c4:	10800818 	cmpnei	r2,r2,32
 90a59c8:	1000071e 	bne	r2,zero,90a59e8 <parse_args+0x184>
 90a59cc:	e0bff917 	ldw	r2,-28(fp)
 90a59d0:	10800003 	ldbu	r2,0(r2)
 90a59d4:	10803fcc 	andi	r2,r2,255
 90a59d8:	1080201c 	xori	r2,r2,128
 90a59dc:	10bfe004 	addi	r2,r2,-128
 90a59e0:	1004c03a 	cmpne	r2,r2,zero
 90a59e4:	103fef1e 	bne	r2,zero,90a59a4 <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 90a59e8:	e0bff917 	ldw	r2,-28(fp)
 90a59ec:	10800003 	ldbu	r2,0(r2)
 90a59f0:	10803fcc 	andi	r2,r2,255
 90a59f4:	1080201c 	xori	r2,r2,128
 90a59f8:	10bfe004 	addi	r2,r2,-128
 90a59fc:	1005003a 	cmpeq	r2,r2,zero
 90a5a00:	1000041e 	bne	r2,zero,90a5a14 <parse_args+0x1b0>
 90a5a04:	e0bffe17 	ldw	r2,-8(fp)
 90a5a08:	10c00017 	ldw	r3,0(r2)
 90a5a0c:	e0bffd17 	ldw	r2,-12(fp)
 90a5a10:	18bfc316 	blt	r3,r2,90a5920 <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 90a5a14:	e03ffb15 	stw	zero,-20(fp)
 90a5a18:	00001206 	br	90a5a64 <parse_args+0x200>
   {
      if (buf[i] == ' ')
 90a5a1c:	e0bffb17 	ldw	r2,-20(fp)
 90a5a20:	1007883a 	mov	r3,r2
 90a5a24:	e0bffc17 	ldw	r2,-16(fp)
 90a5a28:	1885883a 	add	r2,r3,r2
 90a5a2c:	10800003 	ldbu	r2,0(r2)
 90a5a30:	10803fcc 	andi	r2,r2,255
 90a5a34:	1080201c 	xori	r2,r2,128
 90a5a38:	10bfe004 	addi	r2,r2,-128
 90a5a3c:	10800818 	cmpnei	r2,r2,32
 90a5a40:	1000051e 	bne	r2,zero,90a5a58 <parse_args+0x1f4>
         buf[i] = '\0';
 90a5a44:	e0bffb17 	ldw	r2,-20(fp)
 90a5a48:	1007883a 	mov	r3,r2
 90a5a4c:	e0bffc17 	ldw	r2,-16(fp)
 90a5a50:	1885883a 	add	r2,r3,r2
 90a5a54:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 90a5a58:	e0bffb17 	ldw	r2,-20(fp)
 90a5a5c:	10800044 	addi	r2,r2,1
 90a5a60:	e0bffb15 	stw	r2,-20(fp)
 90a5a64:	e0fffb17 	ldw	r3,-20(fp)
 90a5a68:	e0bffa17 	ldw	r2,-24(fp)
 90a5a6c:	18bfeb16 	blt	r3,r2,90a5a1c <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 90a5a70:	e0bff817 	ldw	r2,-32(fp)
 90a5a74:	e0bfff15 	stw	r2,-4(fp)
 90a5a78:	e0bfff17 	ldw	r2,-4(fp)
}
 90a5a7c:	e037883a 	mov	sp,fp
 90a5a80:	dfc00117 	ldw	ra,4(sp)
 90a5a84:	df000017 	ldw	fp,0(sp)
 90a5a88:	dec00204 	addi	sp,sp,8
 90a5a8c:	f800283a 	ret

090a5a90 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 90a5a90:	defffb04 	addi	sp,sp,-20
 90a5a94:	dfc00415 	stw	ra,16(sp)
 90a5a98:	df000315 	stw	fp,12(sp)
 90a5a9c:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 90a5aa0:	d0208d15 	stw	zero,-32204(gp)

   e = prep_modules();
 90a5aa4:	90bbf4c0 	call	90bbf4c <prep_modules>
 90a5aa8:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 90a5aac:	e03ffe15 	stw	zero,-8(fp)
 90a5ab0:	00001c06 	br	90a5b24 <netmain+0x94>
   {
      e = TK_NEWTASK(&nettasks[i]);
 90a5ab4:	e0bffe17 	ldw	r2,-8(fp)
 90a5ab8:	10800624 	muli	r2,r2,24
 90a5abc:	1007883a 	mov	r3,r2
 90a5ac0:	00824374 	movhi	r2,2317
 90a5ac4:	108d9304 	addi	r2,r2,13900
 90a5ac8:	1889883a 	add	r4,r3,r2
 90a5acc:	90aa8a00 	call	90aa8a0 <TK_NEWTASK>
 90a5ad0:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 90a5ad4:	e0bffd17 	ldw	r2,-12(fp)
 90a5ad8:	1005003a 	cmpeq	r2,r2,zero
 90a5adc:	10000e1e 	bne	r2,zero,90a5b18 <netmain+0x88>
      {
         dprintf("task create error\n");
 90a5ae0:	01024374 	movhi	r4,2317
 90a5ae4:	21007204 	addi	r4,r4,456
 90a5ae8:	90836b80 	call	90836b8 <puts>
         panic((char *)&nettasks[i].name);
 90a5aec:	e0bffe17 	ldw	r2,-8(fp)
 90a5af0:	10800624 	muli	r2,r2,24
 90a5af4:	10c00104 	addi	r3,r2,4
 90a5af8:	00824374 	movhi	r2,2317
 90a5afc:	108d9304 	addi	r2,r2,13900
 90a5b00:	1885883a 	add	r2,r3,r2
 90a5b04:	1009883a 	mov	r4,r2
 90a5b08:	90a537c0 	call	90a537c <panic>
         return -1;  /* compiler warnings */
 90a5b0c:	00bfffc4 	movi	r2,-1
 90a5b10:	e0bfff15 	stw	r2,-4(fp)
 90a5b14:	00001506 	br	90a5b6c <netmain+0xdc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 90a5b18:	e0bffe17 	ldw	r2,-8(fp)
 90a5b1c:	10800044 	addi	r2,r2,1
 90a5b20:	e0bffe15 	stw	r2,-8(fp)
 90a5b24:	d0e03017 	ldw	r3,-32576(gp)
 90a5b28:	e0bffe17 	ldw	r2,-8(fp)
 90a5b2c:	10ffe116 	blt	r2,r3,90a5ab4 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 90a5b30:	90bc51c0 	call	90bc51c <create_apptasks>
 90a5b34:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 90a5b38:	e0bffd17 	ldw	r2,-12(fp)
 90a5b3c:	1005003a 	cmpeq	r2,r2,zero
 90a5b40:	1000091e 	bne	r2,zero,90a5b68 <netmain+0xd8>
   {
      dprintf("task create error\n");
 90a5b44:	01024374 	movhi	r4,2317
 90a5b48:	21007204 	addi	r4,r4,456
 90a5b4c:	90836b80 	call	90836b8 <puts>
      panic("netmain");
 90a5b50:	01024374 	movhi	r4,2317
 90a5b54:	21007704 	addi	r4,r4,476
 90a5b58:	90a537c0 	call	90a537c <panic>
      return -1;  /* compiler warnings */
 90a5b5c:	00bfffc4 	movi	r2,-1
 90a5b60:	e0bfff15 	stw	r2,-4(fp)
 90a5b64:	00000106 	br	90a5b6c <netmain+0xdc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 90a5b68:	e03fff15 	stw	zero,-4(fp)
 90a5b6c:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 90a5b70:	e037883a 	mov	sp,fp
 90a5b74:	dfc00117 	ldw	ra,4(sp)
 90a5b78:	df000017 	ldw	fp,0(sp)
 90a5b7c:	dec00204 	addi	sp,sp,8
 90a5b80:	f800283a 	ret

090a5b84 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 90a5b84:	defffc04 	addi	sp,sp,-16
 90a5b88:	dfc00315 	stw	ra,12(sp)
 90a5b8c:	df000215 	stw	fp,8(sp)
 90a5b90:	df000204 	addi	fp,sp,8
 90a5b94:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 90a5b98:	90bbb400 	call	90bbb40 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 90a5b9c:	00800044 	movi	r2,1
 90a5ba0:	d0a08d15 	stw	r2,-32204(gp)
 90a5ba4:	00000006 	br	90a5ba8 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 90a5ba8:	00824374 	movhi	r2,2317
 90a5bac:	108f3104 	addi	r2,r2,15556
 90a5bb0:	11000017 	ldw	r4,0(r2)
 90a5bb4:	01401904 	movi	r5,100
 90a5bb8:	e1bffe04 	addi	r6,fp,-8
 90a5bbc:	9093c5c0 	call	9093c5c <OSSemPend>
 90a5bc0:	e0bffe03 	ldbu	r2,-8(fp)
 90a5bc4:	10803fcc 	andi	r2,r2,255
 90a5bc8:	1005003a 	cmpeq	r2,r2,zero
 90a5bcc:	1000051e 	bne	r2,zero,90a5be4 <tk_netmain+0x60>
 90a5bd0:	e0bffe03 	ldbu	r2,-8(fp)
 90a5bd4:	10803fcc 	andi	r2,r2,255
 90a5bd8:	108002a0 	cmpeqi	r2,r2,10
 90a5bdc:	1000011e 	bne	r2,zero,90a5be4 <tk_netmain+0x60>
 90a5be0:	90aa4780 	call	90aa478 <dtrap>
      netmain_wakes++;  /* count wakeups */
 90a5be4:	d0a08b17 	ldw	r2,-32212(gp)
 90a5be8:	10800044 	addi	r2,r2,1
 90a5bec:	d0a08b15 	stw	r2,-32212(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 90a5bf0:	008243b4 	movhi	r2,2318
 90a5bf4:	10b52104 	addi	r2,r2,-11132
 90a5bf8:	10800217 	ldw	r2,8(r2)
 90a5bfc:	1005003a 	cmpeq	r2,r2,zero
 90a5c00:	103fe91e 	bne	r2,zero,90a5ba8 <tk_netmain+0x24>
         pktdemux();
 90a5c04:	90a26a00 	call	90a26a0 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 90a5c08:	003fe706 	br	90a5ba8 <tk_netmain+0x24>

090a5c0c <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 90a5c0c:	defffd04 	addi	sp,sp,-12
 90a5c10:	dfc00215 	stw	ra,8(sp)
 90a5c14:	df000115 	stw	fp,4(sp)
 90a5c18:	df000104 	addi	fp,sp,4
 90a5c1c:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 90a5c20:	00000306 	br	90a5c30 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 90a5c24:	90a87900 	call	90a8790 <dhc_second>
#endif
      TK_SLEEP(1);
 90a5c28:	01000084 	movi	r4,2
 90a5c2c:	9095df00 	call	9095df0 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 90a5c30:	d0a08d17 	ldw	r2,-32204(gp)
 90a5c34:	1005003a 	cmpeq	r2,r2,zero
 90a5c38:	103ffa1e 	bne	r2,zero,90a5c24 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 90a5c3c:	01000084 	movi	r4,2
 90a5c40:	9095df00 	call	9095df0 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 90a5c44:	d0a08c17 	ldw	r2,-32208(gp)
 90a5c48:	10800044 	addi	r2,r2,1
 90a5c4c:	d0a08c15 	stw	r2,-32208(gp)
      inet_timer();  /* let various timeouts occur */
 90a5c50:	90bbfa40 	call	90bbfa4 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 90a5c54:	003ff906 	br	90a5c3c <tk_nettick+0x30>

090a5c58 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 90a5c58:	defffe04 	addi	sp,sp,-8
 90a5c5c:	dfc00115 	stw	ra,4(sp)
 90a5c60:	df000015 	stw	fp,0(sp)
 90a5c64:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 90a5c68:	01000084 	movi	r4,2
 90a5c6c:	9095df00 	call	9095df0 <OSTimeDly>
}
 90a5c70:	e037883a 	mov	sp,fp
 90a5c74:	dfc00117 	ldw	ra,4(sp)
 90a5c78:	df000017 	ldw	fp,0(sp)
 90a5c7c:	dec00204 	addi	sp,sp,8
 90a5c80:	f800283a 	ret

090a5c84 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 90a5c84:	defffc04 	addi	sp,sp,-16
 90a5c88:	dfc00315 	stw	ra,12(sp)
 90a5c8c:	df000215 	stw	fp,8(sp)
 90a5c90:	df000204 	addi	fp,sp,8
 90a5c94:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 90a5c98:	e0bfff17 	ldw	r2,-4(fp)
 90a5c9c:	10800003 	ldbu	r2,0(r2)
 90a5ca0:	11003fcc 	andi	r4,r2,255
 90a5ca4:	90955f00 	call	90955f0 <OSTaskResume>
 90a5ca8:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 90a5cac:	e0bffe03 	ldbu	r2,-8(fp)
 90a5cb0:	1005003a 	cmpeq	r2,r2,zero
 90a5cb4:	10000a1e 	bne	r2,zero,90a5ce0 <TK_OSTaskResume+0x5c>
 90a5cb8:	e0bffe03 	ldbu	r2,-8(fp)
 90a5cbc:	10801120 	cmpeqi	r2,r2,68
 90a5cc0:	1000071e 	bne	r2,zero,90a5ce0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 90a5cc4:	01024374 	movhi	r4,2317
 90a5cc8:	21007904 	addi	r4,r4,484
 90a5ccc:	90836b80 	call	90836b8 <puts>
      dtrap();
 90a5cd0:	90aa4780 	call	90aa478 <dtrap>
      panic("TK_OSTaskResume");      
 90a5cd4:	01024374 	movhi	r4,2317
 90a5cd8:	21008604 	addi	r4,r4,536
 90a5cdc:	90a537c0 	call	90a537c <panic>
   }
#endif
}
 90a5ce0:	e037883a 	mov	sp,fp
 90a5ce4:	dfc00117 	ldw	ra,4(sp)
 90a5ce8:	df000017 	ldw	fp,0(sp)
 90a5cec:	dec00204 	addi	sp,sp,8
 90a5cf0:	f800283a 	ret

090a5cf4 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 90a5cf4:	defffb04 	addi	sp,sp,-20
 90a5cf8:	dfc00415 	stw	ra,16(sp)
 90a5cfc:	df000315 	stw	fp,12(sp)
 90a5d00:	df000304 	addi	fp,sp,12
 90a5d04:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a5d08:	e03ffd15 	stw	zero,-12(fp)
 90a5d0c:	00005006 	br	90a5e50 <tcp_sleep+0x15c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 90a5d10:	e0bffd17 	ldw	r2,-12(fp)
 90a5d14:	00c243b4 	movhi	r3,2318
 90a5d18:	18f6d104 	addi	r3,r3,-9404
 90a5d1c:	10800324 	muli	r2,r2,12
 90a5d20:	10c5883a 	add	r2,r2,r3
 90a5d24:	10800104 	addi	r2,r2,4
 90a5d28:	10800017 	ldw	r2,0(r2)
 90a5d2c:	1004c03a 	cmpne	r2,r2,zero
 90a5d30:	1000441e 	bne	r2,zero,90a5e44 <tcp_sleep+0x150>
      {
         global_TCPwakeup_set[i].soc_event = event;
 90a5d34:	e0bffd17 	ldw	r2,-12(fp)
 90a5d38:	00c243b4 	movhi	r3,2318
 90a5d3c:	18f6d104 	addi	r3,r3,-9404
 90a5d40:	10800324 	muli	r2,r2,12
 90a5d44:	10c5883a 	add	r2,r2,r3
 90a5d48:	10c00104 	addi	r3,r2,4
 90a5d4c:	e0bfff17 	ldw	r2,-4(fp)
 90a5d50:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 90a5d54:	e13ffd17 	ldw	r4,-12(fp)
 90a5d58:	00824374 	movhi	r2,2317
 90a5d5c:	108f2e04 	addi	r2,r2,15544
 90a5d60:	11400017 	ldw	r5,0(r2)
 90a5d64:	00c243b4 	movhi	r3,2318
 90a5d68:	18f6d104 	addi	r3,r3,-9404
 90a5d6c:	20800324 	muli	r2,r4,12
 90a5d70:	10c5883a 	add	r2,r2,r3
 90a5d74:	11400015 	stw	r5,0(r2)
         if (i > global_TCPwakeup_setIndx)
 90a5d78:	00824374 	movhi	r2,2317
 90a5d7c:	108f2d04 	addi	r2,r2,15540
 90a5d80:	10c00017 	ldw	r3,0(r2)
 90a5d84:	e0bffd17 	ldw	r2,-12(fp)
 90a5d88:	1880040e 	bge	r3,r2,90a5d9c <tcp_sleep+0xa8>
            global_TCPwakeup_setIndx = i;
 90a5d8c:	00c24374 	movhi	r3,2317
 90a5d90:	18cf2d04 	addi	r3,r3,15540
 90a5d94:	e0bffd17 	ldw	r2,-12(fp)
 90a5d98:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 90a5d9c:	00824374 	movhi	r2,2317
 90a5da0:	108f2904 	addi	r2,r2,15524
 90a5da4:	10800017 	ldw	r2,0(r2)
 90a5da8:	10c00044 	addi	r3,r2,1
 90a5dac:	00824374 	movhi	r2,2317
 90a5db0:	108f2904 	addi	r2,r2,15524
 90a5db4:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 90a5db8:	0009883a 	mov	r4,zero
 90a5dbc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 90a5dc0:	e0bffd17 	ldw	r2,-12(fp)
 90a5dc4:	00c243b4 	movhi	r3,2318
 90a5dc8:	18f6d104 	addi	r3,r3,-9404
 90a5dcc:	10800324 	muli	r2,r2,12
 90a5dd0:	10c5883a 	add	r2,r2,r3
 90a5dd4:	10800204 	addi	r2,r2,8
 90a5dd8:	11000017 	ldw	r4,0(r2)
 90a5ddc:	e1bffe04 	addi	r6,fp,-8
 90a5de0:	01401904 	movi	r5,100
 90a5de4:	9093c5c0 	call	9093c5c <OSSemPend>
         if (err == 10)
 90a5de8:	e0bffe03 	ldbu	r2,-8(fp)
 90a5dec:	10803fcc 	andi	r2,r2,255
 90a5df0:	10800298 	cmpnei	r2,r2,10
 90a5df4:	1000101e 	bne	r2,zero,90a5e38 <tcp_sleep+0x144>
         {
            ++tcp_sleep_timeout;
 90a5df8:	d0a08f17 	ldw	r2,-32196(gp)
 90a5dfc:	10800044 	addi	r2,r2,1
 90a5e00:	d0a08f15 	stw	r2,-32196(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 90a5e04:	e0bffd17 	ldw	r2,-12(fp)
 90a5e08:	00c243b4 	movhi	r3,2318
 90a5e0c:	18f6d104 	addi	r3,r3,-9404
 90a5e10:	10800324 	muli	r2,r2,12
 90a5e14:	10c5883a 	add	r2,r2,r3
 90a5e18:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 90a5e1c:	e0bffd17 	ldw	r2,-12(fp)
 90a5e20:	00c243b4 	movhi	r3,2318
 90a5e24:	18f6d104 	addi	r3,r3,-9404
 90a5e28:	10800324 	muli	r2,r2,12
 90a5e2c:	10c5883a 	add	r2,r2,r3
 90a5e30:	10800104 	addi	r2,r2,4
 90a5e34:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 90a5e38:	0009883a 	mov	r4,zero
 90a5e3c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         return;
 90a5e40:	00000f06 	br	90a5e80 <tcp_sleep+0x18c>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a5e44:	e0bffd17 	ldw	r2,-12(fp)
 90a5e48:	10800044 	addi	r2,r2,1
 90a5e4c:	e0bffd15 	stw	r2,-12(fp)
 90a5e50:	e0bffd17 	ldw	r2,-12(fp)
 90a5e54:	10800510 	cmplti	r2,r2,20
 90a5e58:	103fad1e 	bne	r2,zero,90a5d10 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 90a5e5c:	00c24374 	movhi	r3,2317
 90a5e60:	18cf2d04 	addi	r3,r3,15540
 90a5e64:	e0bffd17 	ldw	r2,-12(fp)
 90a5e68:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 90a5e6c:	0009883a 	mov	r4,zero
 90a5e70:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 90a5e74:	90a600c0 	call	90a600c <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 90a5e78:	0009883a 	mov	r4,zero
 90a5e7c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
}
 90a5e80:	e037883a 	mov	sp,fp
 90a5e84:	dfc00117 	ldw	ra,4(sp)
 90a5e88:	df000017 	ldw	fp,0(sp)
 90a5e8c:	dec00204 	addi	sp,sp,8
 90a5e90:	f800283a 	ret

090a5e94 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 90a5e94:	defffc04 	addi	sp,sp,-16
 90a5e98:	dfc00315 	stw	ra,12(sp)
 90a5e9c:	df000215 	stw	fp,8(sp)
 90a5ea0:	df000204 	addi	fp,sp,8
 90a5ea4:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 90a5ea8:	908eb9c0 	call	908eb9c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a5eac:	e03ffe15 	stw	zero,-8(fp)
 90a5eb0:	00003006 	br	90a5f74 <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 90a5eb4:	e0bffe17 	ldw	r2,-8(fp)
 90a5eb8:	00c243b4 	movhi	r3,2318
 90a5ebc:	18f6d104 	addi	r3,r3,-9404
 90a5ec0:	10800324 	muli	r2,r2,12
 90a5ec4:	10c5883a 	add	r2,r2,r3
 90a5ec8:	10800017 	ldw	r2,0(r2)
 90a5ecc:	1005003a 	cmpeq	r2,r2,zero
 90a5ed0:	1000251e 	bne	r2,zero,90a5f68 <tcp_wakeup+0xd4>
 90a5ed4:	e0bffe17 	ldw	r2,-8(fp)
 90a5ed8:	00c243b4 	movhi	r3,2318
 90a5edc:	18f6d104 	addi	r3,r3,-9404
 90a5ee0:	10800324 	muli	r2,r2,12
 90a5ee4:	10c5883a 	add	r2,r2,r3
 90a5ee8:	10800104 	addi	r2,r2,4
 90a5eec:	10c00017 	ldw	r3,0(r2)
 90a5ef0:	e0bfff17 	ldw	r2,-4(fp)
 90a5ef4:	18801c1e 	bne	r3,r2,90a5f68 <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 90a5ef8:	e0bffe17 	ldw	r2,-8(fp)
 90a5efc:	00c243b4 	movhi	r3,2318
 90a5f00:	18f6d104 	addi	r3,r3,-9404
 90a5f04:	10800324 	muli	r2,r2,12
 90a5f08:	10c5883a 	add	r2,r2,r3
 90a5f0c:	10800204 	addi	r2,r2,8
 90a5f10:	11000017 	ldw	r4,0(r2)
 90a5f14:	90940540 	call	9094054 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 90a5f18:	e0bffe17 	ldw	r2,-8(fp)
 90a5f1c:	00c243b4 	movhi	r3,2318
 90a5f20:	18f6d104 	addi	r3,r3,-9404
 90a5f24:	10800324 	muli	r2,r2,12
 90a5f28:	10c5883a 	add	r2,r2,r3
 90a5f2c:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 90a5f30:	e0bffe17 	ldw	r2,-8(fp)
 90a5f34:	00c243b4 	movhi	r3,2318
 90a5f38:	18f6d104 	addi	r3,r3,-9404
 90a5f3c:	10800324 	muli	r2,r2,12
 90a5f40:	10c5883a 	add	r2,r2,r3
 90a5f44:	10800104 	addi	r2,r2,4
 90a5f48:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 90a5f4c:	00824374 	movhi	r2,2317
 90a5f50:	108f2a04 	addi	r2,r2,15528
 90a5f54:	10800017 	ldw	r2,0(r2)
 90a5f58:	10c00044 	addi	r3,r2,1
 90a5f5c:	00824374 	movhi	r2,2317
 90a5f60:	108f2a04 	addi	r2,r2,15528
 90a5f64:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 90a5f68:	e0bffe17 	ldw	r2,-8(fp)
 90a5f6c:	10800044 	addi	r2,r2,1
 90a5f70:	e0bffe15 	stw	r2,-8(fp)
 90a5f74:	e0bffe17 	ldw	r2,-8(fp)
 90a5f78:	10800510 	cmplti	r2,r2,20
 90a5f7c:	103fcd1e 	bne	r2,zero,90a5eb4 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 90a5f80:	908ec280 	call	908ec28 <OSSchedUnlock>
}
 90a5f84:	e037883a 	mov	sp,fp
 90a5f88:	dfc00117 	ldw	ra,4(sp)
 90a5f8c:	df000017 	ldw	fp,0(sp)
 90a5f90:	dec00204 	addi	sp,sp,8
 90a5f94:	f800283a 	ret

090a5f98 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 90a5f98:	deffe104 	addi	sp,sp,-124
 90a5f9c:	dfc01e15 	stw	ra,120(sp)
 90a5fa0:	df001d15 	stw	fp,116(sp)
 90a5fa4:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 90a5fa8:	e17fe404 	addi	r5,fp,-112
 90a5fac:	01003fc4 	movi	r4,255
 90a5fb0:	9095c300 	call	9095c30 <OSTaskQuery>
 90a5fb4:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 90a5fb8:	e0bfe343 	ldbu	r2,-115(fp)
 90a5fbc:	1004c03a 	cmpne	r2,r2,zero
 90a5fc0:	1000051e 	bne	r2,zero,90a5fd8 <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 90a5fc4:	e0bff083 	ldbu	r2,-62(fp)
 90a5fc8:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 90a5fcc:	e0bfe303 	ldbu	r2,-116(fp)
 90a5fd0:	e0bfff15 	stw	r2,-4(fp)
 90a5fd4:	00000706 	br	90a5ff4 <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 90a5fd8:	01024374 	movhi	r4,2317
 90a5fdc:	21008a04 	addi	r4,r4,552
 90a5fe0:	90833900 	call	9083390 <printf>
      panic("TK_OSTaskQuery");
 90a5fe4:	01024374 	movhi	r4,2317
 90a5fe8:	21009704 	addi	r4,r4,604
 90a5fec:	90a537c0 	call	90a537c <panic>
      return 0;
 90a5ff0:	e03fff15 	stw	zero,-4(fp)
 90a5ff4:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 90a5ff8:	e037883a 	mov	sp,fp
 90a5ffc:	dfc00117 	ldw	ra,4(sp)
 90a6000:	df000017 	ldw	fp,0(sp)
 90a6004:	dec00204 	addi	sp,sp,8
 90a6008:	f800283a 	ret

090a600c <tk_yield>:



void
tk_yield(void)
{
 90a600c:	defffe04 	addi	sp,sp,-8
 90a6010:	dfc00115 	stw	ra,4(sp)
 90a6014:	df000015 	stw	fp,0(sp)
 90a6018:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 90a601c:	01000044 	movi	r4,1
 90a6020:	9095df00 	call	9095df0 <OSTimeDly>
}
 90a6024:	e037883a 	mov	sp,fp
 90a6028:	dfc00117 	ldw	ra,4(sp)
 90a602c:	df000017 	ldw	fp,0(sp)
 90a6030:	dec00204 	addi	sp,sp,8
 90a6034:	f800283a 	ret

090a6038 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 90a6038:	deffef04 	addi	sp,sp,-68
 90a603c:	dfc01015 	stw	ra,64(sp)
 90a6040:	df000f15 	stw	fp,60(sp)
 90a6044:	df000f04 	addi	fp,sp,60
 90a6048:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 90a604c:	e13fff17 	ldw	r4,-4(fp)
 90a6050:	01424374 	movhi	r5,2317
 90a6054:	29409b04 	addi	r5,r5,620
 90a6058:	90a55a40 	call	90a55a4 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 90a605c:	00824374 	movhi	r2,2317
 90a6060:	108ef604 	addi	r2,r2,15320
 90a6064:	11800017 	ldw	r6,0(r2)
 90a6068:	e13fff17 	ldw	r4,-4(fp)
 90a606c:	01424374 	movhi	r5,2317
 90a6070:	2940a104 	addi	r5,r5,644
 90a6074:	90a55a40 	call	90a55a4 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 90a6078:	e13fff17 	ldw	r4,-4(fp)
 90a607c:	01424374 	movhi	r5,2317
 90a6080:	2940a904 	addi	r5,r5,676
 90a6084:	90a55a40 	call	90a55a4 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 90a6088:	e03ff515 	stw	zero,-44(fp)
 90a608c:	00005106 	br	90a61d4 <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 90a6090:	e0bff517 	ldw	r2,-44(fp)
 90a6094:	00c243b4 	movhi	r3,2318
 90a6098:	18f47404 	addi	r3,r3,-11824
 90a609c:	1085883a 	add	r2,r2,r2
 90a60a0:	1085883a 	add	r2,r2,r2
 90a60a4:	10c5883a 	add	r2,r2,r3
 90a60a8:	10800017 	ldw	r2,0(r2)
 90a60ac:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 90a60b0:	e0bff417 	ldw	r2,-48(fp)
 90a60b4:	1005003a 	cmpeq	r2,r2,zero
 90a60b8:	1000431e 	bne	r2,zero,90a61c8 <tk_stats+0x190>
 90a60bc:	e0bff417 	ldw	r2,-48(fp)
 90a60c0:	10800060 	cmpeqi	r2,r2,1
 90a60c4:	1000401e 	bne	r2,zero,90a61c8 <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 90a60c8:	e0bff417 	ldw	r2,-48(fp)
 90a60cc:	10800c83 	ldbu	r2,50(r2)
 90a60d0:	11003fcc 	andi	r4,r2,255
 90a60d4:	e17ff604 	addi	r5,fp,-40
 90a60d8:	e1bffe44 	addi	r6,fp,-7
 90a60dc:	90952740 	call	9095274 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 90a60e0:	e0bff417 	ldw	r2,-48(fp)
 90a60e4:	10800c83 	ldbu	r2,50(r2)
 90a60e8:	11c03fcc 	andi	r7,r2,255
 90a60ec:	e0bff417 	ldw	r2,-48(fp)
 90a60f0:	10800c03 	ldbu	r2,48(r2)
 90a60f4:	10803fcc 	andi	r2,r2,255
 90a60f8:	e1bff604 	addi	r6,fp,-40
 90a60fc:	d8800015 	stw	r2,0(sp)
 90a6100:	e13fff17 	ldw	r4,-4(fp)
 90a6104:	01424374 	movhi	r5,2317
 90a6108:	2940b904 	addi	r5,r5,740
 90a610c:	90a55a40 	call	90a55a4 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 90a6110:	e0bff417 	ldw	r2,-48(fp)
 90a6114:	10800217 	ldw	r2,8(r2)
 90a6118:	1005003a 	cmpeq	r2,r2,zero
 90a611c:	1000261e 	bne	r2,zero,90a61b8 <tk_stats+0x180>
 90a6120:	e0bff417 	ldw	r2,-48(fp)
 90a6124:	10800317 	ldw	r2,12(r2)
 90a6128:	1005003a 	cmpeq	r2,r2,zero
 90a612c:	1000221e 	bne	r2,zero,90a61b8 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 90a6130:	e0bff417 	ldw	r2,-48(fp)
 90a6134:	10800217 	ldw	r2,8(r2)
 90a6138:	10800104 	addi	r2,r2,4
 90a613c:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 90a6140:	00000306 	br	90a6150 <tk_stats+0x118>
            sp++;
 90a6144:	e0bff317 	ldw	r2,-52(fp)
 90a6148:	10800104 	addi	r2,r2,4
 90a614c:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 90a6150:	e0bff317 	ldw	r2,-52(fp)
 90a6154:	10800017 	ldw	r2,0(r2)
 90a6158:	1005003a 	cmpeq	r2,r2,zero
 90a615c:	103ff91e 	bne	r2,zero,90a6144 <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 90a6160:	e0bff417 	ldw	r2,-48(fp)
 90a6164:	11000317 	ldw	r4,12(r2)
 90a6168:	e0fff317 	ldw	r3,-52(fp)
 90a616c:	e0bff417 	ldw	r2,-48(fp)
 90a6170:	10800217 	ldw	r2,8(r2)
 90a6174:	1885c83a 	sub	r2,r3,r2
 90a6178:	1005d0ba 	srai	r2,r2,2
 90a617c:	2085c83a 	sub	r2,r4,r2
 90a6180:	1085883a 	add	r2,r2,r2
 90a6184:	1085883a 	add	r2,r2,r2
 90a6188:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 90a618c:	e0bff417 	ldw	r2,-48(fp)
 90a6190:	10800317 	ldw	r2,12(r2)
 90a6194:	1085883a 	add	r2,r2,r2
 90a6198:	1085883a 	add	r2,r2,r2
 90a619c:	100d883a 	mov	r6,r2
 90a61a0:	e13fff17 	ldw	r4,-4(fp)
 90a61a4:	01424374 	movhi	r5,2317
 90a61a8:	2940c104 	addi	r5,r5,772
 90a61ac:	e1fff217 	ldw	r7,-56(fp)
 90a61b0:	90a55a40 	call	90a55a4 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 90a61b4:	00000406 	br	90a61c8 <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 90a61b8:	e13fff17 	ldw	r4,-4(fp)
 90a61bc:	01424374 	movhi	r5,2317
 90a61c0:	2940c504 	addi	r5,r5,788
 90a61c4:	90a55a40 	call	90a55a4 <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 90a61c8:	e0bff517 	ldw	r2,-44(fp)
 90a61cc:	10800044 	addi	r2,r2,1
 90a61d0:	e0bff515 	stw	r2,-44(fp)
 90a61d4:	e0bff517 	ldw	r2,-44(fp)
 90a61d8:	10800550 	cmplti	r2,r2,21
 90a61dc:	103fac1e 	bne	r2,zero,90a6090 <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 90a61e0:	00824374 	movhi	r2,2317
 90a61e4:	108f2904 	addi	r2,r2,15524
 90a61e8:	11800017 	ldw	r6,0(r2)
 90a61ec:	00824374 	movhi	r2,2317
 90a61f0:	108f2a04 	addi	r2,r2,15528
 90a61f4:	11c00017 	ldw	r7,0(r2)
 90a61f8:	e13fff17 	ldw	r4,-4(fp)
 90a61fc:	01424374 	movhi	r5,2317
 90a6200:	2940c904 	addi	r5,r5,804
 90a6204:	90a55a40 	call	90a55a4 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 90a6208:	00824374 	movhi	r2,2317
 90a620c:	108f2d04 	addi	r2,r2,15540
 90a6210:	11800017 	ldw	r6,0(r2)
 90a6214:	d1e08f17 	ldw	r7,-32196(gp)
 90a6218:	e13fff17 	ldw	r4,-4(fp)
 90a621c:	01424374 	movhi	r5,2317
 90a6220:	2940d504 	addi	r5,r5,852
 90a6224:	90a55a40 	call	90a55a4 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 90a6228:	0005883a 	mov	r2,zero
}
 90a622c:	e037883a 	mov	sp,fp
 90a6230:	dfc00117 	ldw	ra,4(sp)
 90a6234:	df000017 	ldw	fp,0(sp)
 90a6238:	dec00204 	addi	sp,sp,8
 90a623c:	f800283a 	ret

090a6240 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 90a6240:	defffa04 	addi	sp,sp,-24
 90a6244:	dfc00515 	stw	ra,20(sp)
 90a6248:	df000415 	stw	fp,16(sp)
 90a624c:	df000404 	addi	fp,sp,16
 90a6250:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 90a6254:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 90a6258:	01000d84 	movi	r4,54
 90a625c:	e17fff17 	ldw	r5,-4(fp)
 90a6260:	90a94d80 	call	90a94d8 <find_opt>
 90a6264:	e0bffe15 	stw	r2,-8(fp)
 90a6268:	e0bffe17 	ldw	r2,-8(fp)
 90a626c:	1005003a 	cmpeq	r2,r2,zero
 90a6270:	1000111e 	bne	r2,zero,90a62b8 <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 90a6274:	e0bffe17 	ldw	r2,-8(fp)
 90a6278:	10800044 	addi	r2,r2,1
 90a627c:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 90a6280:	e0bffe17 	ldw	r2,-8(fp)
 90a6284:	10800003 	ldbu	r2,0(r2)
 90a6288:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 90a628c:	e0bffe17 	ldw	r2,-8(fp)
 90a6290:	10800044 	addi	r2,r2,1
 90a6294:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 90a6298:	e13ffe17 	ldw	r4,-8(fp)
 90a629c:	90a84080 	call	90a8408 <dh_getlong>
 90a62a0:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 90a62a4:	e0bffd03 	ldbu	r2,-12(fp)
 90a62a8:	1007883a 	mov	r3,r2
 90a62ac:	e0bffe17 	ldw	r2,-8(fp)
 90a62b0:	10c5883a 	add	r2,r2,r3
 90a62b4:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 90a62b8:	e0bffc17 	ldw	r2,-16(fp)
} 
 90a62bc:	e037883a 	mov	sp,fp
 90a62c0:	dfc00117 	ldw	ra,4(sp)
 90a62c4:	df000017 	ldw	fp,0(sp)
 90a62c8:	dec00204 	addi	sp,sp,8
 90a62cc:	f800283a 	ret

090a62d0 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 90a62d0:	defffb04 	addi	sp,sp,-20
 90a62d4:	dfc00415 	stw	ra,16(sp)
 90a62d8:	df000315 	stw	fp,12(sp)
 90a62dc:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 90a62e0:	00bfff44 	movi	r2,-3
 90a62e4:	d8800015 	stw	r2,0(sp)
 90a62e8:	0009883a 	mov	r4,zero
 90a62ec:	014010c4 	movi	r5,67
 90a62f0:	01801104 	movi	r6,68
 90a62f4:	01c242b4 	movhi	r7,2314
 90a62f8:	39d8f404 	addi	r7,r7,25552
 90a62fc:	90a9fc80 	call	90a9fc8 <udp_open>
 90a6300:	d0a09015 	stw	r2,-32192(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 90a6304:	d0a09017 	ldw	r2,-32192(gp)
 90a6308:	1004c03a 	cmpne	r2,r2,zero
 90a630c:	1000031e 	bne	r2,zero,90a631c <dhc_init+0x4c>
      return ENP_RESOURCE;
 90a6310:	00bffa84 	movi	r2,-22
 90a6314:	e0bfff15 	stw	r2,-4(fp)
 90a6318:	00001606 	br	90a6374 <dhc_init+0xa4>

   for (i = 0; i < MAXNETS; i++)
 90a631c:	e03ffe15 	stw	zero,-8(fp)
 90a6320:	00001006 	br	90a6364 <dhc_init+0x94>
   {
      dhc_states[i].state = DHCS_UNUSED;
 90a6324:	e0bffe17 	ldw	r2,-8(fp)
 90a6328:	00c243b4 	movhi	r3,2318
 90a632c:	18f60c04 	addi	r3,r3,-10192
 90a6330:	10800f24 	muli	r2,r2,60
 90a6334:	10c5883a 	add	r2,r2,r3
 90a6338:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 90a633c:	e0bffe17 	ldw	r2,-8(fp)
 90a6340:	00c243b4 	movhi	r3,2318
 90a6344:	18f60c04 	addi	r3,r3,-10192
 90a6348:	10800f24 	muli	r2,r2,60
 90a634c:	10c5883a 	add	r2,r2,r3
 90a6350:	10800104 	addi	r2,r2,4
 90a6354:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 90a6358:	e0bffe17 	ldw	r2,-8(fp)
 90a635c:	10800044 	addi	r2,r2,1
 90a6360:	e0bffe15 	stw	r2,-8(fp)
 90a6364:	e0bffe17 	ldw	r2,-8(fp)
 90a6368:	10800110 	cmplti	r2,r2,4
 90a636c:	103fed1e 	bne	r2,zero,90a6324 <dhc_init+0x54>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 90a6370:	e03fff15 	stw	zero,-4(fp)
 90a6374:	e0bfff17 	ldw	r2,-4(fp)
}
 90a6378:	e037883a 	mov	sp,fp
 90a637c:	dfc00117 	ldw	ra,4(sp)
 90a6380:	df000017 	ldw	fp,0(sp)
 90a6384:	dec00204 	addi	sp,sp,8
 90a6388:	f800283a 	ret

090a638c <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 90a638c:	defffd04 	addi	sp,sp,-12
 90a6390:	df000215 	stw	fp,8(sp)
 90a6394:	df000204 	addi	fp,sp,8
 90a6398:	e13ffe15 	stw	r4,-8(fp)
 90a639c:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 90a63a0:	e0bffe17 	ldw	r2,-8(fp)
 90a63a4:	00c243b4 	movhi	r3,2318
 90a63a8:	18f60c04 	addi	r3,r3,-10192
 90a63ac:	10800f24 	muli	r2,r2,60
 90a63b0:	10c5883a 	add	r2,r2,r3
 90a63b4:	10c00e04 	addi	r3,r2,56
 90a63b8:	e0bfff17 	ldw	r2,-4(fp)
 90a63bc:	18800015 	stw	r2,0(r3)
}
 90a63c0:	e037883a 	mov	sp,fp
 90a63c4:	df000017 	ldw	fp,0(sp)
 90a63c8:	dec00104 	addi	sp,sp,4
 90a63cc:	f800283a 	ret

090a63d0 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 90a63d0:	defff204 	addi	sp,sp,-56
 90a63d4:	dfc00d15 	stw	ra,52(sp)
 90a63d8:	df000c15 	stw	fp,48(sp)
 90a63dc:	dc000b15 	stw	r16,44(sp)
 90a63e0:	df000b04 	addi	fp,sp,44
 90a63e4:	e13ffb15 	stw	r4,-20(fp)
 90a63e8:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 90a63ec:	e0bffb17 	ldw	r2,-20(fp)
 90a63f0:	10800417 	ldw	r2,16(r2)
 90a63f4:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 90a63f8:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 90a63fc:	e0bffc17 	ldw	r2,-16(fp)
 90a6400:	10bfff60 	cmpeqi	r2,r2,-3
 90a6404:	1000041e 	bne	r2,zero,90a6418 <dhc_upcall+0x48>
   {
      dtrap();
 90a6408:	90aa4780 	call	90aa478 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 90a640c:	00bffd44 	movi	r2,-11
 90a6410:	e0bffe15 	stw	r2,-8(fp)
 90a6414:	0001f306 	br	90a6be4 <dhc_upcall+0x814>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 90a6418:	e0bffb17 	ldw	r2,-20(fp)
 90a641c:	11000617 	ldw	r4,24(r2)
 90a6420:	90a31080 	call	90a3108 <if_netnumber>
 90a6424:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 90a6428:	e0bff617 	ldw	r2,-40(fp)
 90a642c:	00c243b4 	movhi	r3,2318
 90a6430:	18f60c04 	addi	r3,r3,-10192
 90a6434:	10800f24 	muli	r2,r2,60
 90a6438:	10c5883a 	add	r2,r2,r3
 90a643c:	10800017 	ldw	r2,0(r2)
 90a6440:	1004c03a 	cmpne	r2,r2,zero
 90a6444:	1000031e 	bne	r2,zero,90a6454 <dhc_upcall+0x84>
      return ENP_NOT_MINE;
 90a6448:	00c00084 	movi	r3,2
 90a644c:	e0fffe15 	stw	r3,-8(fp)
 90a6450:	0001e406 	br	90a6be4 <dhc_upcall+0x814>

   bp = (struct bootp *)pkt->nb_prot;
 90a6454:	e0bffb17 	ldw	r2,-20(fp)
 90a6458:	10800317 	ldw	r2,12(r2)
 90a645c:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 90a6460:	e0bff917 	ldw	r2,-28(fp)
 90a6464:	10803b30 	cmpltui	r2,r2,236
 90a6468:	10000b1e 	bne	r2,zero,90a6498 <dhc_upcall+0xc8>
 90a646c:	e0bffa17 	ldw	r2,-24(fp)
 90a6470:	10800003 	ldbu	r2,0(r2)
 90a6474:	10803fcc 	andi	r2,r2,255
 90a6478:	10800098 	cmpnei	r2,r2,2
 90a647c:	1000061e 	bne	r2,zero,90a6498 <dhc_upcall+0xc8>
 90a6480:	e0bffa17 	ldw	r2,-24(fp)
 90a6484:	10803b04 	addi	r2,r2,236
 90a6488:	10c00017 	ldw	r3,0(r2)
 90a648c:	0098d534 	movhi	r2,25428
 90a6490:	10a098c4 	addi	r2,r2,-32157
 90a6494:	18800726 	beq	r3,r2,90a64b4 <dhc_upcall+0xe4>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 90a6498:	90aa4780 	call	90aa478 <dtrap>
      dsc_errors++;
 90a649c:	d0a09117 	ldw	r2,-32188(gp)
 90a64a0:	10800044 	addi	r2,r2,1
 90a64a4:	d0a09115 	stw	r2,-32188(gp)
      return ENP_NOT_MINE;
 90a64a8:	01000084 	movi	r4,2
 90a64ac:	e13ffe15 	stw	r4,-8(fp)
 90a64b0:	0001cc06 	br	90a6be4 <dhc_upcall+0x814>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 90a64b4:	e0bffa17 	ldw	r2,-24(fp)
 90a64b8:	11000704 	addi	r4,r2,28
 90a64bc:	e0bffb17 	ldw	r2,-20(fp)
 90a64c0:	10800617 	ldw	r2,24(r2)
 90a64c4:	11401717 	ldw	r5,92(r2)
 90a64c8:	e0bffb17 	ldw	r2,-20(fp)
 90a64cc:	10800617 	ldw	r2,24(r2)
 90a64d0:	11801117 	ldw	r6,68(r2)
 90a64d4:	90cb4540 	call	90cb454 <memcmp>
 90a64d8:	1005003a 	cmpeq	r2,r2,zero
 90a64dc:	1000031e 	bne	r2,zero,90a64ec <dhc_upcall+0x11c>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 90a64e0:	00800084 	movi	r2,2
 90a64e4:	e0bffe15 	stw	r2,-8(fp)
 90a64e8:	0001be06 	br	90a6be4 <dhc_upcall+0x814>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 90a64ec:	e0bffa17 	ldw	r2,-24(fp)
 90a64f0:	10803b04 	addi	r2,r2,236
 90a64f4:	11400104 	addi	r5,r2,4
 90a64f8:	01000d44 	movi	r4,53
 90a64fc:	90a94d80 	call	90a94d8 <find_opt>
 90a6500:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 90a6504:	e0bff517 	ldw	r2,-44(fp)
 90a6508:	1005003a 	cmpeq	r2,r2,zero
 90a650c:	1000101e 	bne	r2,zero,90a6550 <dhc_upcall+0x180>
 90a6510:	e0bff517 	ldw	r2,-44(fp)
 90a6514:	10800003 	ldbu	r2,0(r2)
 90a6518:	10803fcc 	andi	r2,r2,255
 90a651c:	10800d58 	cmpnei	r2,r2,53
 90a6520:	10000b1e 	bne	r2,zero,90a6550 <dhc_upcall+0x180>
   {
      dhcptype = *(opts+2);
 90a6524:	e0bff517 	ldw	r2,-44(fp)
 90a6528:	10800084 	addi	r2,r2,2
 90a652c:	10800003 	ldbu	r2,0(r2)
 90a6530:	10803fcc 	andi	r2,r2,255
 90a6534:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 90a6538:	e0bffa17 	ldw	r2,-24(fp)
 90a653c:	10800003 	ldbu	r2,0(r2)
 90a6540:	10800114 	ori	r2,r2,4
 90a6544:	1007883a 	mov	r3,r2
 90a6548:	e0bffa17 	ldw	r2,-24(fp)
 90a654c:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 90a6550:	e0bffa17 	ldw	r2,-24(fp)
 90a6554:	10800003 	ldbu	r2,0(r2)
 90a6558:	10803fcc 	andi	r2,r2,255
 90a655c:	1080010c 	andi	r2,r2,4
 90a6560:	1005003a 	cmpeq	r2,r2,zero
 90a6564:	10017e1e 	bne	r2,zero,90a6b60 <dhc_upcall+0x790>
   {
      switch (dhcptype)
 90a6568:	e0fff817 	ldw	r3,-32(fp)
 90a656c:	e0ffff15 	stw	r3,-4(fp)
 90a6570:	e13fff17 	ldw	r4,-4(fp)
 90a6574:	20800148 	cmpgei	r2,r4,5
 90a6578:	1000071e 	bne	r2,zero,90a6598 <dhc_upcall+0x1c8>
 90a657c:	e0ffff17 	ldw	r3,-4(fp)
 90a6580:	188000c8 	cmpgei	r2,r3,3
 90a6584:	1000081e 	bne	r2,zero,90a65a8 <dhc_upcall+0x1d8>
 90a6588:	e13fff17 	ldw	r4,-4(fp)
 90a658c:	20800060 	cmpeqi	r2,r4,1
 90a6590:	1000051e 	bne	r2,zero,90a65a8 <dhc_upcall+0x1d8>
 90a6594:	00000a06 	br	90a65c0 <dhc_upcall+0x1f0>
 90a6598:	e0ffff17 	ldw	r3,-4(fp)
 90a659c:	188001e0 	cmpeqi	r2,r3,7
 90a65a0:	1000011e 	bne	r2,zero,90a65a8 <dhc_upcall+0x1d8>
 90a65a4:	00000606 	br	90a65c0 <dhc_upcall+0x1f0>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 90a65a8:	d0a09117 	ldw	r2,-32188(gp)
 90a65ac:	10800044 	addi	r2,r2,1
 90a65b0:	d0a09115 	stw	r2,-32188(gp)
         return ENP_NOT_MINE;
 90a65b4:	01000084 	movi	r4,2
 90a65b8:	e13ffe15 	stw	r4,-8(fp)
 90a65bc:	00018906 	br	90a6be4 <dhc_upcall+0x814>
      }

      switch (dhc_states[iface].state)
 90a65c0:	e0bff617 	ldw	r2,-40(fp)
 90a65c4:	00c243b4 	movhi	r3,2318
 90a65c8:	18f60c04 	addi	r3,r3,-10192
 90a65cc:	10800f24 	muli	r2,r2,60
 90a65d0:	10c5883a 	add	r2,r2,r3
 90a65d4:	10800017 	ldw	r2,0(r2)
 90a65d8:	e0bffd15 	stw	r2,-12(fp)
 90a65dc:	e0fffd17 	ldw	r3,-12(fp)
 90a65e0:	18800268 	cmpgeui	r2,r3,9
 90a65e4:	1001541e 	bne	r2,zero,90a6b38 <dhc_upcall+0x768>
 90a65e8:	e13ffd17 	ldw	r4,-12(fp)
 90a65ec:	e13ffd17 	ldw	r4,-12(fp)
 90a65f0:	2105883a 	add	r2,r4,r4
 90a65f4:	1087883a 	add	r3,r2,r2
 90a65f8:	008242b4 	movhi	r2,2314
 90a65fc:	10998304 	addi	r2,r2,26124
 90a6600:	1885883a 	add	r2,r3,r2
 90a6604:	10800017 	ldw	r2,0(r2)
 90a6608:	1000683a 	jmp	r2
 90a660c:	090a6b38 	rdprs	r4,at,10668
 90a6610:	090a6630 	cmpltui	r4,at,10648
 90a6614:	090a6630 	cmpltui	r4,at,10648
 90a6618:	090a6884 	addi	r4,at,10658
 90a661c:	090a6648 	cmpgei	r4,at,10649
 90a6620:	090a67cc 	andi	r4,at,10655
 90a6624:	090a6630 	cmpltui	r4,at,10648
 90a6628:	090a67cc 	andi	r4,at,10655
 90a662c:	090a67cc 	andi	r4,at,10655
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 90a6630:	d0a09117 	ldw	r2,-32188(gp)
 90a6634:	10800044 	addi	r2,r2,1
 90a6638:	d0a09115 	stw	r2,-32188(gp)
         return ENP_NOT_MINE;
 90a663c:	00800084 	movi	r2,2
 90a6640:	e0bffe15 	stw	r2,-8(fp)
 90a6644:	00016706 	br	90a6be4 <dhc_upcall+0x814>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 90a6648:	e0bff817 	ldw	r2,-32(fp)
 90a664c:	10800098 	cmpnei	r2,r2,2
 90a6650:	1000521e 	bne	r2,zero,90a679c <dhc_upcall+0x3cc>
         {
            dsc_offers++;
 90a6654:	d0a09317 	ldw	r2,-32180(gp)
 90a6658:	10800044 	addi	r2,r2,1
 90a665c:	d0a09315 	stw	r2,-32180(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 90a6660:	e43ff617 	ldw	r16,-40(fp)
 90a6664:	e0bffa17 	ldw	r2,-24(fp)
 90a6668:	10803b04 	addi	r2,r2,236
 90a666c:	11000104 	addi	r4,r2,4
 90a6670:	90a62400 	call	90a6240 <dhc_get_srv_ipaddr>
 90a6674:	1009883a 	mov	r4,r2
 90a6678:	00c243b4 	movhi	r3,2318
 90a667c:	18f60c04 	addi	r3,r3,-10192
 90a6680:	80800f24 	muli	r2,r16,60
 90a6684:	10c5883a 	add	r2,r2,r3
 90a6688:	10800d04 	addi	r2,r2,52
 90a668c:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 90a6690:	e0bff617 	ldw	r2,-40(fp)
 90a6694:	00c243b4 	movhi	r3,2318
 90a6698:	18f60c04 	addi	r3,r3,-10192
 90a669c:	10800f24 	muli	r2,r2,60
 90a66a0:	10c5883a 	add	r2,r2,r3
 90a66a4:	10800d04 	addi	r2,r2,52
 90a66a8:	10800017 	ldw	r2,0(r2)
 90a66ac:	1004c03a 	cmpne	r2,r2,zero
 90a66b0:	10000d1e 	bne	r2,zero,90a66e8 <dhc_upcall+0x318>
            {
               dtrap(); /* didn't receive server-identifier option */
 90a66b4:	90aa4780 	call	90aa478 <dtrap>
               dsc_errors++;
 90a66b8:	d0a09117 	ldw	r2,-32188(gp)
 90a66bc:	10800044 	addi	r2,r2,1
 90a66c0:	d0a09115 	stw	r2,-32188(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 90a66c4:	e13ff617 	ldw	r4,-40(fp)
 90a66c8:	e0bffb17 	ldw	r2,-20(fp)
 90a66cc:	11400717 	ldw	r5,28(r2)
 90a66d0:	00c243b4 	movhi	r3,2318
 90a66d4:	18f60c04 	addi	r3,r3,-10192
 90a66d8:	20800f24 	muli	r2,r4,60
 90a66dc:	10c5883a 	add	r2,r2,r3
 90a66e0:	10800d04 	addi	r2,r2,52
 90a66e4:	11400015 	stw	r5,0(r2)
            }

            if (bp->hops)
 90a66e8:	e0bffa17 	ldw	r2,-24(fp)
 90a66ec:	108000c3 	ldbu	r2,3(r2)
 90a66f0:	10803fcc 	andi	r2,r2,255
 90a66f4:	1005003a 	cmpeq	r2,r2,zero
 90a66f8:	10000a1e 	bne	r2,zero,90a6724 <dhc_upcall+0x354>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 90a66fc:	e13ff617 	ldw	r4,-40(fp)
 90a6700:	e0bffb17 	ldw	r2,-20(fp)
 90a6704:	11400717 	ldw	r5,28(r2)
 90a6708:	00c243b4 	movhi	r3,2318
 90a670c:	18f60c04 	addi	r3,r3,-10192
 90a6710:	20800f24 	muli	r2,r4,60
 90a6714:	10c5883a 	add	r2,r2,r3
 90a6718:	10800c04 	addi	r2,r2,48
 90a671c:	11400015 	stw	r5,0(r2)
 90a6720:	00000706 	br	90a6740 <dhc_upcall+0x370>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 90a6724:	e0bff617 	ldw	r2,-40(fp)
 90a6728:	00c243b4 	movhi	r3,2318
 90a672c:	18f60c04 	addi	r3,r3,-10192
 90a6730:	10800f24 	muli	r2,r2,60
 90a6734:	10c5883a 	add	r2,r2,r3
 90a6738:	10800c04 	addi	r2,r2,48
 90a673c:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 90a6740:	e0bffb17 	ldw	r2,-20(fp)
 90a6744:	11800417 	ldw	r6,16(r2)
 90a6748:	e13ff617 	ldw	r4,-40(fp)
 90a674c:	e17ffa17 	ldw	r5,-24(fp)
 90a6750:	90a734c0 	call	90a734c <dhc_rx_offer>
 90a6754:	e0bff715 	stw	r2,-36(fp)
            if (e)
 90a6758:	e0bff717 	ldw	r2,-36(fp)
 90a675c:	1005003a 	cmpeq	r2,r2,zero
 90a6760:	10000a1e 	bne	r2,zero,90a678c <dhc_upcall+0x3bc>
            {
               dsc_errors++;
 90a6764:	d0a09117 	ldw	r2,-32188(gp)
 90a6768:	10800044 	addi	r2,r2,1
 90a676c:	d0a09115 	stw	r2,-32188(gp)
               dhc_set_state(iface,DHCS_INIT);
 90a6770:	e13ff617 	ldw	r4,-40(fp)
 90a6774:	01400044 	movi	r5,1
 90a6778:	90a94280 	call	90a9428 <dhc_set_state>
               dtrap();
 90a677c:	90aa4780 	call	90aa478 <dtrap>
               return ENP_NOT_MINE;
 90a6780:	00c00084 	movi	r3,2
 90a6784:	e0fffe15 	stw	r3,-8(fp)
 90a6788:	00011606 	br	90a6be4 <dhc_upcall+0x814>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 90a678c:	e13ff617 	ldw	r4,-40(fp)
 90a6790:	01400144 	movi	r5,5
 90a6794:	90a94280 	call	90a9428 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 90a6798:	00010f06 	br	90a6bd8 <dhc_upcall+0x808>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 90a679c:	d0a09117 	ldw	r2,-32188(gp)
 90a67a0:	10800044 	addi	r2,r2,1
 90a67a4:	d0a09115 	stw	r2,-32188(gp)
            if ( dhcptype == DHCP_NAK ) 
 90a67a8:	e0bff817 	ldw	r2,-32(fp)
 90a67ac:	10800198 	cmpnei	r2,r2,6
 90a67b0:	1000031e 	bne	r2,zero,90a67c0 <dhc_upcall+0x3f0>
               dsc_naks++;
 90a67b4:	d0a09917 	ldw	r2,-32156(gp)
 90a67b8:	10800044 	addi	r2,r2,1
 90a67bc:	d0a09915 	stw	r2,-32156(gp)
            return ENP_NOT_MINE;
 90a67c0:	01000084 	movi	r4,2
 90a67c4:	e13ffe15 	stw	r4,-8(fp)
 90a67c8:	00010606 	br	90a6be4 <dhc_upcall+0x814>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 90a67cc:	e0bff617 	ldw	r2,-40(fp)
 90a67d0:	00c243b4 	movhi	r3,2318
 90a67d4:	18f60c04 	addi	r3,r3,-10192
 90a67d8:	10800f24 	muli	r2,r2,60
 90a67dc:	10c5883a 	add	r2,r2,r3
 90a67e0:	10800d04 	addi	r2,r2,52
 90a67e4:	14000017 	ldw	r16,0(r2)
 90a67e8:	e0bffa17 	ldw	r2,-24(fp)
 90a67ec:	10803b04 	addi	r2,r2,236
 90a67f0:	11000104 	addi	r4,r2,4
 90a67f4:	90a62400 	call	90a6240 <dhc_get_srv_ipaddr>
 90a67f8:	80800626 	beq	r16,r2,90a6814 <dhc_upcall+0x444>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 90a67fc:	d0a09117 	ldw	r2,-32188(gp)
 90a6800:	10800044 	addi	r2,r2,1
 90a6804:	d0a09115 	stw	r2,-32188(gp)
            return ENP_NOT_MINE;
 90a6808:	00800084 	movi	r2,2
 90a680c:	e0bffe15 	stw	r2,-8(fp)
 90a6810:	0000f406 	br	90a6be4 <dhc_upcall+0x814>
         }
         if (dhc_states[iface].rly_ipaddr &&
 90a6814:	e0bff617 	ldw	r2,-40(fp)
 90a6818:	00c243b4 	movhi	r3,2318
 90a681c:	18f60c04 	addi	r3,r3,-10192
 90a6820:	10800f24 	muli	r2,r2,60
 90a6824:	10c5883a 	add	r2,r2,r3
 90a6828:	10800c04 	addi	r2,r2,48
 90a682c:	10800017 	ldw	r2,0(r2)
 90a6830:	1005003a 	cmpeq	r2,r2,zero
 90a6834:	1000131e 	bne	r2,zero,90a6884 <dhc_upcall+0x4b4>
 90a6838:	e0bff617 	ldw	r2,-40(fp)
 90a683c:	00c243b4 	movhi	r3,2318
 90a6840:	18f60c04 	addi	r3,r3,-10192
 90a6844:	10800f24 	muli	r2,r2,60
 90a6848:	10c5883a 	add	r2,r2,r3
 90a684c:	10800c04 	addi	r2,r2,48
 90a6850:	10c00017 	ldw	r3,0(r2)
 90a6854:	e0bffb17 	ldw	r2,-20(fp)
 90a6858:	10800717 	ldw	r2,28(r2)
 90a685c:	18800926 	beq	r3,r2,90a6884 <dhc_upcall+0x4b4>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 90a6860:	d0a09c17 	ldw	r2,-32144(gp)
 90a6864:	10800044 	addi	r2,r2,1
 90a6868:	d0a09c15 	stw	r2,-32144(gp)
            dsc_errors++;
 90a686c:	d0a09117 	ldw	r2,-32188(gp)
 90a6870:	10800044 	addi	r2,r2,1
 90a6874:	d0a09115 	stw	r2,-32188(gp)
            return ENP_NOT_MINE;
 90a6878:	00c00084 	movi	r3,2
 90a687c:	e0fffe15 	stw	r3,-8(fp)
 90a6880:	0000d806 	br	90a6be4 <dhc_upcall+0x814>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 90a6884:	e0bff817 	ldw	r2,-32(fp)
 90a6888:	10800158 	cmpnei	r2,r2,5
 90a688c:	1000891e 	bne	r2,zero,90a6ab4 <dhc_upcall+0x6e4>
         {
            dsc_acks++;
 90a6890:	d0a09517 	ldw	r2,-32172(gp)
 90a6894:	10800044 	addi	r2,r2,1
 90a6898:	d0a09515 	stw	r2,-32172(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 90a689c:	e0bffa17 	ldw	r2,-24(fp)
 90a68a0:	10803b04 	addi	r2,r2,236
 90a68a4:	11400104 	addi	r5,r2,4
 90a68a8:	e13ff617 	ldw	r4,-40(fp)
 90a68ac:	90a84d40 	call	90a84d4 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 90a68b0:	e0bff617 	ldw	r2,-40(fp)
 90a68b4:	00c243b4 	movhi	r3,2318
 90a68b8:	18f60c04 	addi	r3,r3,-10192
 90a68bc:	10800f24 	muli	r2,r2,60
 90a68c0:	10c5883a 	add	r2,r2,r3
 90a68c4:	10800504 	addi	r2,r2,20
 90a68c8:	10800017 	ldw	r2,0(r2)
 90a68cc:	10bfffd8 	cmpnei	r2,r2,-1
 90a68d0:	1000111e 	bne	r2,zero,90a6918 <dhc_upcall+0x548>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 90a68d4:	e0bff617 	ldw	r2,-40(fp)
 90a68d8:	00c243b4 	movhi	r3,2318
 90a68dc:	18f60c04 	addi	r3,r3,-10192
 90a68e0:	10800f24 	muli	r2,r2,60
 90a68e4:	10c5883a 	add	r2,r2,r3
 90a68e8:	10c00604 	addi	r3,r2,24
 90a68ec:	00bfffc4 	movi	r2,-1
 90a68f0:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 90a68f4:	e0bff617 	ldw	r2,-40(fp)
 90a68f8:	00c243b4 	movhi	r3,2318
 90a68fc:	18f60c04 	addi	r3,r3,-10192
 90a6900:	10800f24 	muli	r2,r2,60
 90a6904:	10c5883a 	add	r2,r2,r3
 90a6908:	10c00704 	addi	r3,r2,28
 90a690c:	00bfffc4 	movi	r2,-1
 90a6910:	18800015 	stw	r2,0(r3)
 90a6914:	00001f06 	br	90a6994 <dhc_upcall+0x5c4>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 90a6918:	e17ff617 	ldw	r5,-40(fp)
 90a691c:	e0bff617 	ldw	r2,-40(fp)
 90a6920:	00c243b4 	movhi	r3,2318
 90a6924:	18f60c04 	addi	r3,r3,-10192
 90a6928:	10800f24 	muli	r2,r2,60
 90a692c:	10c5883a 	add	r2,r2,r3
 90a6930:	10800504 	addi	r2,r2,20
 90a6934:	10800017 	ldw	r2,0(r2)
 90a6938:	1008d07a 	srli	r4,r2,1
 90a693c:	00c243b4 	movhi	r3,2318
 90a6940:	18f60c04 	addi	r3,r3,-10192
 90a6944:	28800f24 	muli	r2,r5,60
 90a6948:	10c5883a 	add	r2,r2,r3
 90a694c:	10800604 	addi	r2,r2,24
 90a6950:	11000015 	stw	r4,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 90a6954:	e17ff617 	ldw	r5,-40(fp)
 90a6958:	e0bff617 	ldw	r2,-40(fp)
 90a695c:	00c243b4 	movhi	r3,2318
 90a6960:	18f60c04 	addi	r3,r3,-10192
 90a6964:	10800f24 	muli	r2,r2,60
 90a6968:	10c5883a 	add	r2,r2,r3
 90a696c:	10800504 	addi	r2,r2,20
 90a6970:	10800017 	ldw	r2,0(r2)
 90a6974:	1004d0fa 	srli	r2,r2,3
 90a6978:	110001e4 	muli	r4,r2,7
 90a697c:	00c243b4 	movhi	r3,2318
 90a6980:	18f60c04 	addi	r3,r3,-10192
 90a6984:	28800f24 	muli	r2,r5,60
 90a6988:	10c5883a 	add	r2,r2,r3
 90a698c:	10800704 	addi	r2,r2,28
 90a6990:	11000015 	stw	r4,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 90a6994:	e13ff617 	ldw	r4,-40(fp)
 90a6998:	00824374 	movhi	r2,2317
 90a699c:	108f2e04 	addi	r2,r2,15544
 90a69a0:	11400017 	ldw	r5,0(r2)
 90a69a4:	00c243b4 	movhi	r3,2318
 90a69a8:	18f60c04 	addi	r3,r3,-10192
 90a69ac:	20800f24 	muli	r2,r4,60
 90a69b0:	10c5883a 	add	r2,r2,r3
 90a69b4:	10800804 	addi	r2,r2,32
 90a69b8:	11400015 	stw	r5,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 90a69bc:	e43ff617 	ldw	r16,-40(fp)
 90a69c0:	e0bffa17 	ldw	r2,-24(fp)
 90a69c4:	10803b04 	addi	r2,r2,236
 90a69c8:	11000104 	addi	r4,r2,4
 90a69cc:	90a62400 	call	90a6240 <dhc_get_srv_ipaddr>
 90a69d0:	1009883a 	mov	r4,r2
 90a69d4:	00c243b4 	movhi	r3,2318
 90a69d8:	18f60c04 	addi	r3,r3,-10192
 90a69dc:	80800f24 	muli	r2,r16,60
 90a69e0:	10c5883a 	add	r2,r2,r3
 90a69e4:	10800d04 	addi	r2,r2,52
 90a69e8:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 90a69ec:	e0bff617 	ldw	r2,-40(fp)
 90a69f0:	00c243b4 	movhi	r3,2318
 90a69f4:	18f60c04 	addi	r3,r3,-10192
 90a69f8:	10800f24 	muli	r2,r2,60
 90a69fc:	10c5883a 	add	r2,r2,r3
 90a6a00:	10800d04 	addi	r2,r2,52
 90a6a04:	10800017 	ldw	r2,0(r2)
 90a6a08:	1004c03a 	cmpne	r2,r2,zero
 90a6a0c:	10000d1e 	bne	r2,zero,90a6a44 <dhc_upcall+0x674>
            {
               dtrap(); /* didn't receive server-identifier option */
 90a6a10:	90aa4780 	call	90aa478 <dtrap>
               dsc_errors++;
 90a6a14:	d0a09117 	ldw	r2,-32188(gp)
 90a6a18:	10800044 	addi	r2,r2,1
 90a6a1c:	d0a09115 	stw	r2,-32188(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 90a6a20:	e13ff617 	ldw	r4,-40(fp)
 90a6a24:	e0bffb17 	ldw	r2,-20(fp)
 90a6a28:	11400717 	ldw	r5,28(r2)
 90a6a2c:	00c243b4 	movhi	r3,2318
 90a6a30:	18f60c04 	addi	r3,r3,-10192
 90a6a34:	20800f24 	muli	r2,r4,60
 90a6a38:	10c5883a 	add	r2,r2,r3
 90a6a3c:	10800d04 	addi	r2,r2,52
 90a6a40:	11400015 	stw	r5,0(r2)
            }
            if (bp->hops)
 90a6a44:	e0bffa17 	ldw	r2,-24(fp)
 90a6a48:	108000c3 	ldbu	r2,3(r2)
 90a6a4c:	10803fcc 	andi	r2,r2,255
 90a6a50:	1005003a 	cmpeq	r2,r2,zero
 90a6a54:	10000a1e 	bne	r2,zero,90a6a80 <dhc_upcall+0x6b0>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 90a6a58:	e13ff617 	ldw	r4,-40(fp)
 90a6a5c:	e0bffb17 	ldw	r2,-20(fp)
 90a6a60:	11400717 	ldw	r5,28(r2)
 90a6a64:	00c243b4 	movhi	r3,2318
 90a6a68:	18f60c04 	addi	r3,r3,-10192
 90a6a6c:	20800f24 	muli	r2,r4,60
 90a6a70:	10c5883a 	add	r2,r2,r3
 90a6a74:	10800c04 	addi	r2,r2,48
 90a6a78:	11400015 	stw	r5,0(r2)
 90a6a7c:	00000706 	br	90a6a9c <dhc_upcall+0x6cc>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 90a6a80:	e0bff617 	ldw	r2,-40(fp)
 90a6a84:	00c243b4 	movhi	r3,2318
 90a6a88:	18f60c04 	addi	r3,r3,-10192
 90a6a8c:	10800f24 	muli	r2,r2,60
 90a6a90:	10c5883a 	add	r2,r2,r3
 90a6a94:	10800c04 	addi	r2,r2,48
 90a6a98:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 90a6a9c:	e13ff617 	ldw	r4,-40(fp)
 90a6aa0:	90a7f8c0 	call	90a7f8c <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 90a6aa4:	e13ff617 	ldw	r4,-40(fp)
 90a6aa8:	01400184 	movi	r5,6
 90a6aac:	90a94280 	call	90a9428 <dhc_set_state>
 90a6ab0:	00004906 	br	90a6bd8 <dhc_upcall+0x808>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 90a6ab4:	e0bff817 	ldw	r2,-32(fp)
 90a6ab8:	10800198 	cmpnei	r2,r2,6
 90a6abc:	1000071e 	bne	r2,zero,90a6adc <dhc_upcall+0x70c>
         {
            dhc_set_state(iface,DHCS_INIT);
 90a6ac0:	e13ff617 	ldw	r4,-40(fp)
 90a6ac4:	01400044 	movi	r5,1
 90a6ac8:	90a94280 	call	90a9428 <dhc_set_state>
            dsc_naks++;
 90a6acc:	d0a09917 	ldw	r2,-32156(gp)
 90a6ad0:	10800044 	addi	r2,r2,1
 90a6ad4:	d0a09915 	stw	r2,-32156(gp)
 90a6ad8:	00003f06 	br	90a6bd8 <dhc_upcall+0x808>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 90a6adc:	e0bff617 	ldw	r2,-40(fp)
 90a6ae0:	00c243b4 	movhi	r3,2318
 90a6ae4:	18f60c04 	addi	r3,r3,-10192
 90a6ae8:	10800f24 	muli	r2,r2,60
 90a6aec:	10c5883a 	add	r2,r2,r3
 90a6af0:	10800017 	ldw	r2,0(r2)
 90a6af4:	10800158 	cmpnei	r2,r2,5
 90a6af8:	1000091e 	bne	r2,zero,90a6b20 <dhc_upcall+0x750>
 90a6afc:	e0bff817 	ldw	r2,-32(fp)
 90a6b00:	10800098 	cmpnei	r2,r2,2
 90a6b04:	1000061e 	bne	r2,zero,90a6b20 <dhc_upcall+0x750>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 90a6b08:	d0a09317 	ldw	r2,-32180(gp)
 90a6b0c:	10800044 	addi	r2,r2,1
 90a6b10:	d0a09315 	stw	r2,-32180(gp)
               return ENP_NOT_MINE;
 90a6b14:	01000084 	movi	r4,2
 90a6b18:	e13ffe15 	stw	r4,-8(fp)
 90a6b1c:	00003106 	br	90a6be4 <dhc_upcall+0x814>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 90a6b20:	d0a09117 	ldw	r2,-32188(gp)
 90a6b24:	10800044 	addi	r2,r2,1
 90a6b28:	d0a09115 	stw	r2,-32188(gp)
            return ENP_NOT_MINE;
 90a6b2c:	00800084 	movi	r2,2
 90a6b30:	e0bffe15 	stw	r2,-8(fp)
 90a6b34:	00002b06 	br	90a6be4 <dhc_upcall+0x814>
         }
         break;
      default:    /* bad state */
         dtrap();
 90a6b38:	90aa4780 	call	90aa478 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 90a6b3c:	e13ff617 	ldw	r4,-40(fp)
 90a6b40:	01400044 	movi	r5,1
 90a6b44:	90a94280 	call	90a9428 <dhc_set_state>
         dsc_errors++;
 90a6b48:	d0a09117 	ldw	r2,-32188(gp)
 90a6b4c:	10800044 	addi	r2,r2,1
 90a6b50:	d0a09115 	stw	r2,-32188(gp)
         return -1;
 90a6b54:	00ffffc4 	movi	r3,-1
 90a6b58:	e0fffe15 	stw	r3,-8(fp)
 90a6b5c:	00002106 	br	90a6be4 <dhc_upcall+0x814>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 90a6b60:	d0a09617 	ldw	r2,-32168(gp)
 90a6b64:	10800044 	addi	r2,r2,1
 90a6b68:	d0a09615 	stw	r2,-32168(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 90a6b6c:	e0bffa17 	ldw	r2,-24(fp)
 90a6b70:	10803b04 	addi	r2,r2,236
 90a6b74:	11400104 	addi	r5,r2,4
 90a6b78:	e13ff617 	ldw	r4,-40(fp)
 90a6b7c:	90a84d40 	call	90a84d4 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 90a6b80:	e13ff617 	ldw	r4,-40(fp)
 90a6b84:	e0bffa17 	ldw	r2,-24(fp)
 90a6b88:	11400417 	ldw	r5,16(r2)
 90a6b8c:	00c243b4 	movhi	r3,2318
 90a6b90:	18f60c04 	addi	r3,r3,-10192
 90a6b94:	20800f24 	muli	r2,r4,60
 90a6b98:	10c5883a 	add	r2,r2,r3
 90a6b9c:	10800904 	addi	r2,r2,36
 90a6ba0:	11400015 	stw	r5,0(r2)
      dhc_setip(iface);
 90a6ba4:	e13ff617 	ldw	r4,-40(fp)
 90a6ba8:	90a7f8c0 	call	90a7f8c <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 90a6bac:	e13ff617 	ldw	r4,-40(fp)
 90a6bb0:	01400184 	movi	r5,6
 90a6bb4:	90a94280 	call	90a9428 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 90a6bb8:	e0bff617 	ldw	r2,-40(fp)
 90a6bbc:	00c243b4 	movhi	r3,2318
 90a6bc0:	18f60c04 	addi	r3,r3,-10192
 90a6bc4:	10800f24 	muli	r2,r2,60
 90a6bc8:	10c5883a 	add	r2,r2,r3
 90a6bcc:	10c00604 	addi	r3,r2,24
 90a6bd0:	00bfffc4 	movi	r2,-1
 90a6bd4:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 90a6bd8:	e13ffb17 	ldw	r4,-20(fp)
 90a6bdc:	90c4b9c0 	call	90c4b9c <udp_free>
   return 0;
 90a6be0:	e03ffe15 	stw	zero,-8(fp)
 90a6be4:	e0bffe17 	ldw	r2,-8(fp)
}
 90a6be8:	e037883a 	mov	sp,fp
 90a6bec:	dfc00217 	ldw	ra,8(sp)
 90a6bf0:	df000117 	ldw	fp,4(sp)
 90a6bf4:	dc000017 	ldw	r16,0(sp)
 90a6bf8:	dec00304 	addi	sp,sp,12
 90a6bfc:	f800283a 	ret

090a6c00 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 90a6c00:	defff804 	addi	sp,sp,-32
 90a6c04:	dfc00715 	stw	ra,28(sp)
 90a6c08:	df000615 	stw	fp,24(sp)
 90a6c0c:	df000604 	addi	fp,sp,24
 90a6c10:	e13ffb15 	stw	r4,-20(fp)
 90a6c14:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 90a6c18:	e0bffc17 	ldw	r2,-16(fp)
 90a6c1c:	1009883a 	mov	r4,r2
 90a6c20:	01804b04 	movi	r6,300
 90a6c24:	000b883a 	mov	r5,zero
 90a6c28:	90832780 	call	9083278 <memset>
   outbp->op = BOOTREQUEST;
 90a6c2c:	e0fffc17 	ldw	r3,-16(fp)
 90a6c30:	00800044 	movi	r2,1
 90a6c34:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 90a6c38:	e0bffb17 	ldw	r2,-20(fp)
 90a6c3c:	00c243b4 	movhi	r3,2318
 90a6c40:	18f5e604 	addi	r3,r3,-10344
 90a6c44:	1085883a 	add	r2,r2,r2
 90a6c48:	1085883a 	add	r2,r2,r2
 90a6c4c:	10c5883a 	add	r2,r2,r3
 90a6c50:	10800017 	ldw	r2,0(r2)
 90a6c54:	10802717 	ldw	r2,156(r2)
 90a6c58:	10800217 	ldw	r2,8(r2)
 90a6c5c:	e0bfff15 	stw	r2,-4(fp)
 90a6c60:	e0ffff17 	ldw	r3,-4(fp)
 90a6c64:	188005e0 	cmpeqi	r2,r3,23
 90a6c68:	10000b1e 	bne	r2,zero,90a6c98 <dhc_buildheader+0x98>
 90a6c6c:	e0ffff17 	ldw	r3,-4(fp)
 90a6c70:	18800720 	cmpeqi	r2,r3,28
 90a6c74:	1000081e 	bne	r2,zero,90a6c98 <dhc_buildheader+0x98>
 90a6c78:	e0ffff17 	ldw	r3,-4(fp)
 90a6c7c:	188001a0 	cmpeqi	r2,r3,6
 90a6c80:	1000011e 	bne	r2,zero,90a6c88 <dhc_buildheader+0x88>
 90a6c84:	00000806 	br	90a6ca8 <dhc_buildheader+0xa8>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 90a6c88:	e0fffc17 	ldw	r3,-16(fp)
 90a6c8c:	00800044 	movi	r2,1
 90a6c90:	18800045 	stb	r2,1(r3)
   break;
 90a6c94:	00000806 	br	90a6cb8 <dhc_buildheader+0xb8>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 90a6c98:	e0fffc17 	ldw	r3,-16(fp)
 90a6c9c:	00800504 	movi	r2,20
 90a6ca0:	18800045 	stb	r2,1(r3)
   break;
 90a6ca4:	00000406 	br	90a6cb8 <dhc_buildheader+0xb8>
      default:
      dtrap();
 90a6ca8:	90aa4780 	call	90aa478 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 90a6cac:	00bffd44 	movi	r2,-11
 90a6cb0:	e0bffe15 	stw	r2,-8(fp)
 90a6cb4:	00005306 	br	90a6e04 <dhc_buildheader+0x204>
   }

   addrlen = min(16, nets[iface]->n_hal);
 90a6cb8:	e0bffb17 	ldw	r2,-20(fp)
 90a6cbc:	00c243b4 	movhi	r3,2318
 90a6cc0:	18f5e604 	addi	r3,r3,-10344
 90a6cc4:	1085883a 	add	r2,r2,r2
 90a6cc8:	1085883a 	add	r2,r2,r2
 90a6ccc:	10c5883a 	add	r2,r2,r3
 90a6cd0:	10800017 	ldw	r2,0(r2)
 90a6cd4:	10801117 	ldw	r2,68(r2)
 90a6cd8:	e0bffd15 	stw	r2,-12(fp)
 90a6cdc:	e0fffd17 	ldw	r3,-12(fp)
 90a6ce0:	18800470 	cmpltui	r2,r3,17
 90a6ce4:	1000021e 	bne	r2,zero,90a6cf0 <dhc_buildheader+0xf0>
 90a6ce8:	00800404 	movi	r2,16
 90a6cec:	e0bffd15 	stw	r2,-12(fp)
 90a6cf0:	e0fffd17 	ldw	r3,-12(fp)
 90a6cf4:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 90a6cf8:	e0bffa17 	ldw	r2,-24(fp)
 90a6cfc:	1007883a 	mov	r3,r2
 90a6d00:	e0bffc17 	ldw	r2,-16(fp)
 90a6d04:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 90a6d08:	e0bffc17 	ldw	r2,-16(fp)
 90a6d0c:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 90a6d10:	e0bffb17 	ldw	r2,-20(fp)
 90a6d14:	00c243b4 	movhi	r3,2318
 90a6d18:	18f60c04 	addi	r3,r3,-10192
 90a6d1c:	10800f24 	muli	r2,r2,60
 90a6d20:	10c5883a 	add	r2,r2,r3
 90a6d24:	10800017 	ldw	r2,0(r2)
 90a6d28:	108001d8 	cmpnei	r2,r2,7
 90a6d2c:	1000031e 	bne	r2,zero,90a6d3c <dhc_buildheader+0x13c>
      outbp->flags = 0; /* Renewing needs unicast */
 90a6d30:	e0bffc17 	ldw	r2,-16(fp)
 90a6d34:	1000028d 	sth	zero,10(r2)
 90a6d38:	00000306 	br	90a6d48 <dhc_buildheader+0x148>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 90a6d3c:	e0fffc17 	ldw	r3,-16(fp)
 90a6d40:	00802004 	movi	r2,128
 90a6d44:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 90a6d48:	e0bffb17 	ldw	r2,-20(fp)
 90a6d4c:	00c243b4 	movhi	r3,2318
 90a6d50:	18f60c04 	addi	r3,r3,-10192
 90a6d54:	10800f24 	muli	r2,r2,60
 90a6d58:	10c5883a 	add	r2,r2,r3
 90a6d5c:	10800204 	addi	r2,r2,8
 90a6d60:	10c00017 	ldw	r3,0(r2)
 90a6d64:	e0bffc17 	ldw	r2,-16(fp)
 90a6d68:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 90a6d6c:	e0bffb17 	ldw	r2,-20(fp)
 90a6d70:	00c243b4 	movhi	r3,2318
 90a6d74:	18f60c04 	addi	r3,r3,-10192
 90a6d78:	10800f24 	muli	r2,r2,60
 90a6d7c:	10c5883a 	add	r2,r2,r3
 90a6d80:	10800304 	addi	r2,r2,12
 90a6d84:	10c0000b 	ldhu	r3,0(r2)
 90a6d88:	e0bffc17 	ldw	r2,-16(fp)
 90a6d8c:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 90a6d90:	e0bffb17 	ldw	r2,-20(fp)
 90a6d94:	00c243b4 	movhi	r3,2318
 90a6d98:	18f5e604 	addi	r3,r3,-10344
 90a6d9c:	1085883a 	add	r2,r2,r2
 90a6da0:	1085883a 	add	r2,r2,r2
 90a6da4:	10c5883a 	add	r2,r2,r3
 90a6da8:	10800017 	ldw	r2,0(r2)
 90a6dac:	10801717 	ldw	r2,92(r2)
 90a6db0:	1004c03a 	cmpne	r2,r2,zero
 90a6db4:	1000041e 	bne	r2,zero,90a6dc8 <dhc_buildheader+0x1c8>
   {
      dtrap();
 90a6db8:	90aa4780 	call	90aa478 <dtrap>
      return ENP_LOGIC;
 90a6dbc:	00bffd44 	movi	r2,-11
 90a6dc0:	e0bffe15 	stw	r2,-8(fp)
 90a6dc4:	00000f06 	br	90a6e04 <dhc_buildheader+0x204>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 90a6dc8:	e0bffc17 	ldw	r2,-16(fp)
 90a6dcc:	11000704 	addi	r4,r2,28
 90a6dd0:	e0bffb17 	ldw	r2,-20(fp)
 90a6dd4:	00c243b4 	movhi	r3,2318
 90a6dd8:	18f5e604 	addi	r3,r3,-10344
 90a6ddc:	1085883a 	add	r2,r2,r2
 90a6de0:	1085883a 	add	r2,r2,r2
 90a6de4:	10c5883a 	add	r2,r2,r3
 90a6de8:	10800017 	ldw	r2,0(r2)
 90a6dec:	10801717 	ldw	r2,92(r2)
 90a6df0:	e0fffa17 	ldw	r3,-24(fp)
 90a6df4:	100b883a 	mov	r5,r2
 90a6df8:	180d883a 	mov	r6,r3
 90a6dfc:	90894600 	call	9089460 <memcpy>

   /* return success */
   return 0;
 90a6e00:	e03ffe15 	stw	zero,-8(fp)
 90a6e04:	e0bffe17 	ldw	r2,-8(fp)
}
 90a6e08:	e037883a 	mov	sp,fp
 90a6e0c:	dfc00117 	ldw	ra,4(sp)
 90a6e10:	df000017 	ldw	fp,0(sp)
 90a6e14:	dec00204 	addi	sp,sp,8
 90a6e18:	f800283a 	ret

090a6e1c <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 90a6e1c:	defff204 	addi	sp,sp,-56
 90a6e20:	dfc00d15 	stw	ra,52(sp)
 90a6e24:	df000c15 	stw	fp,48(sp)
 90a6e28:	dc000b15 	stw	r16,44(sp)
 90a6e2c:	df000b04 	addi	fp,sp,44
 90a6e30:	e13ffc15 	stw	r4,-16(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 90a6e34:	01004b04 	movi	r4,300
 90a6e38:	000b883a 	mov	r5,zero
 90a6e3c:	90c4ab00 	call	90c4ab0 <udp_alloc>
 90a6e40:	e0bff915 	stw	r2,-28(fp)
   if (!pkt) 
 90a6e44:	e0bff917 	ldw	r2,-28(fp)
 90a6e48:	1004c03a 	cmpne	r2,r2,zero
 90a6e4c:	1000031e 	bne	r2,zero,90a6e5c <dhc_discover+0x40>
      return ENP_NOMEM;
 90a6e50:	00bffb04 	movi	r2,-20
 90a6e54:	e0bffd15 	stw	r2,-12(fp)
 90a6e58:	00013506 	br	90a7330 <dhc_discover+0x514>
   pkt->nb_plen = sizeof(struct bootp);
 90a6e5c:	e0fff917 	ldw	r3,-28(fp)
 90a6e60:	00804b04 	movi	r2,300
 90a6e64:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 90a6e68:	e0bffc17 	ldw	r2,-16(fp)
 90a6e6c:	d1203117 	ldw	r4,-32572(gp)
 90a6e70:	200b883a 	mov	r5,r4
 90a6e74:	00c243b4 	movhi	r3,2318
 90a6e78:	18f60c04 	addi	r3,r3,-10192
 90a6e7c:	10800f24 	muli	r2,r2,60
 90a6e80:	10c5883a 	add	r2,r2,r3
 90a6e84:	10800204 	addi	r2,r2,8
 90a6e88:	11400015 	stw	r5,0(r2)
 90a6e8c:	20800044 	addi	r2,r4,1
 90a6e90:	d0a03115 	stw	r2,-32572(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 90a6e94:	e43ffc17 	ldw	r16,-16(fp)
 90a6e98:	90bbe4c0 	call	90bbe4c <sysuptime>
 90a6e9c:	1007883a 	mov	r3,r2
 90a6ea0:	00947b34 	movhi	r2,20972
 90a6ea4:	10a147c4 	addi	r2,r2,-31457
 90a6ea8:	1889383a 	mul	r4,r3,r2
 90a6eac:	e13ffe15 	stw	r4,-8(fp)
 90a6eb0:	1886383a 	mulxuu	r3,r3,r2
 90a6eb4:	e0ffff15 	stw	r3,-4(fp)
 90a6eb8:	e0ffff17 	ldw	r3,-4(fp)
 90a6ebc:	1804d17a 	srli	r2,r3,5
 90a6ec0:	1009883a 	mov	r4,r2
 90a6ec4:	00c243b4 	movhi	r3,2318
 90a6ec8:	18f60c04 	addi	r3,r3,-10192
 90a6ecc:	80800f24 	muli	r2,r16,60
 90a6ed0:	10c5883a 	add	r2,r2,r3
 90a6ed4:	10800304 	addi	r2,r2,12
 90a6ed8:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 90a6edc:	e0bff917 	ldw	r2,-28(fp)
 90a6ee0:	10800317 	ldw	r2,12(r2)
 90a6ee4:	e0bff815 	stw	r2,-32(fp)
   e = dhc_buildheader(iface,outbp);
 90a6ee8:	e13ffc17 	ldw	r4,-16(fp)
 90a6eec:	e17ff817 	ldw	r5,-32(fp)
 90a6ef0:	90a6c000 	call	90a6c00 <dhc_buildheader>
 90a6ef4:	e0bff615 	stw	r2,-40(fp)
   if (e)
 90a6ef8:	e0bff617 	ldw	r2,-40(fp)
 90a6efc:	1005003a 	cmpeq	r2,r2,zero
 90a6f00:	1000031e 	bne	r2,zero,90a6f10 <dhc_discover+0xf4>
      return e;
 90a6f04:	e13ff617 	ldw	r4,-40(fp)
 90a6f08:	e13ffd15 	stw	r4,-12(fp)
 90a6f0c:	00010806 	br	90a7330 <dhc_discover+0x514>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 90a6f10:	e0bff817 	ldw	r2,-32(fp)
 90a6f14:	10803b04 	addi	r2,r2,236
 90a6f18:	1007883a 	mov	r3,r2
 90a6f1c:	0098d534 	movhi	r2,25428
 90a6f20:	10a098c4 	addi	r2,r2,-32157
 90a6f24:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 90a6f28:	e0bff817 	ldw	r2,-32(fp)
 90a6f2c:	10803b04 	addi	r2,r2,236
 90a6f30:	10800104 	addi	r2,r2,4
 90a6f34:	e0bff715 	stw	r2,-36(fp)
   *opts++ = DHOP_TYPE;
 90a6f38:	e0fff717 	ldw	r3,-36(fp)
 90a6f3c:	00800d44 	movi	r2,53
 90a6f40:	18800005 	stb	r2,0(r3)
 90a6f44:	e0bff717 	ldw	r2,-36(fp)
 90a6f48:	10800044 	addi	r2,r2,1
 90a6f4c:	e0bff715 	stw	r2,-36(fp)
   *opts++ = 1;   /* length of option field */
 90a6f50:	e0fff717 	ldw	r3,-36(fp)
 90a6f54:	00800044 	movi	r2,1
 90a6f58:	18800005 	stb	r2,0(r3)
 90a6f5c:	e0bff717 	ldw	r2,-36(fp)
 90a6f60:	10800044 	addi	r2,r2,1
 90a6f64:	e0bff715 	stw	r2,-36(fp)
   *opts++ = DHCP_DISCOVER;
 90a6f68:	e0fff717 	ldw	r3,-36(fp)
 90a6f6c:	00800044 	movi	r2,1
 90a6f70:	18800005 	stb	r2,0(r3)
 90a6f74:	e0bff717 	ldw	r2,-36(fp)
 90a6f78:	10800044 	addi	r2,r2,1
 90a6f7c:	e0bff715 	stw	r2,-36(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 90a6f80:	00bfffc4 	movi	r2,-1
 90a6f84:	e0bffa15 	stw	r2,-24(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 90a6f88:	e0fff717 	ldw	r3,-36(fp)
 90a6f8c:	00800cc4 	movi	r2,51
 90a6f90:	18800005 	stb	r2,0(r3)
 90a6f94:	e0bff717 	ldw	r2,-36(fp)
 90a6f98:	10800044 	addi	r2,r2,1
 90a6f9c:	e0bff715 	stw	r2,-36(fp)
 90a6fa0:	e0fff717 	ldw	r3,-36(fp)
 90a6fa4:	00800104 	movi	r2,4
 90a6fa8:	18800005 	stb	r2,0(r3)
 90a6fac:	e0bff717 	ldw	r2,-36(fp)
 90a6fb0:	10800044 	addi	r2,r2,1
 90a6fb4:	e0bff715 	stw	r2,-36(fp)
 90a6fb8:	e0bff717 	ldw	r2,-36(fp)
 90a6fbc:	10c000c4 	addi	r3,r2,3
 90a6fc0:	e0bffa04 	addi	r2,fp,-24
 90a6fc4:	10800003 	ldbu	r2,0(r2)
 90a6fc8:	18800005 	stb	r2,0(r3)
 90a6fcc:	e0bff717 	ldw	r2,-36(fp)
 90a6fd0:	10c00084 	addi	r3,r2,2
 90a6fd4:	e0bffa04 	addi	r2,fp,-24
 90a6fd8:	10800044 	addi	r2,r2,1
 90a6fdc:	10800003 	ldbu	r2,0(r2)
 90a6fe0:	18800005 	stb	r2,0(r3)
 90a6fe4:	e0bff717 	ldw	r2,-36(fp)
 90a6fe8:	10c00044 	addi	r3,r2,1
 90a6fec:	e0bffa04 	addi	r2,fp,-24
 90a6ff0:	10800084 	addi	r2,r2,2
 90a6ff4:	10800003 	ldbu	r2,0(r2)
 90a6ff8:	18800005 	stb	r2,0(r3)
 90a6ffc:	e0bffa04 	addi	r2,fp,-24
 90a7000:	108000c4 	addi	r2,r2,3
 90a7004:	10800003 	ldbu	r2,0(r2)
 90a7008:	1007883a 	mov	r3,r2
 90a700c:	e0bff717 	ldw	r2,-36(fp)
 90a7010:	10c00005 	stb	r3,0(r2)
 90a7014:	e0bff717 	ldw	r2,-36(fp)
 90a7018:	10800104 	addi	r2,r2,4
 90a701c:	e0bff715 	stw	r2,-36(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 90a7020:	e0bffc17 	ldw	r2,-16(fp)
 90a7024:	00c243b4 	movhi	r3,2318
 90a7028:	18f5e604 	addi	r3,r3,-10344
 90a702c:	1085883a 	add	r2,r2,r2
 90a7030:	1085883a 	add	r2,r2,r2
 90a7034:	10c5883a 	add	r2,r2,r3
 90a7038:	10800017 	ldw	r2,0(r2)
 90a703c:	10800a17 	ldw	r2,40(r2)
 90a7040:	1005003a 	cmpeq	r2,r2,zero
 90a7044:	1000521e 	bne	r2,zero,90a7190 <dhc_discover+0x374>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 90a7048:	e0bffc17 	ldw	r2,-16(fp)
 90a704c:	00c243b4 	movhi	r3,2318
 90a7050:	18f5e604 	addi	r3,r3,-10344
 90a7054:	1085883a 	add	r2,r2,r2
 90a7058:	1085883a 	add	r2,r2,r2
 90a705c:	10c5883a 	add	r2,r2,r3
 90a7060:	10800017 	ldw	r2,0(r2)
 90a7064:	10800a17 	ldw	r2,40(r2)
 90a7068:	1004d63a 	srli	r2,r2,24
 90a706c:	11003fcc 	andi	r4,r2,255
 90a7070:	e0bffc17 	ldw	r2,-16(fp)
 90a7074:	00c243b4 	movhi	r3,2318
 90a7078:	18f5e604 	addi	r3,r3,-10344
 90a707c:	1085883a 	add	r2,r2,r2
 90a7080:	1085883a 	add	r2,r2,r2
 90a7084:	10c5883a 	add	r2,r2,r3
 90a7088:	10800017 	ldw	r2,0(r2)
 90a708c:	10800a17 	ldw	r2,40(r2)
 90a7090:	1004d23a 	srli	r2,r2,8
 90a7094:	10bfc00c 	andi	r2,r2,65280
 90a7098:	2088b03a 	or	r4,r4,r2
 90a709c:	e0bffc17 	ldw	r2,-16(fp)
 90a70a0:	00c243b4 	movhi	r3,2318
 90a70a4:	18f5e604 	addi	r3,r3,-10344
 90a70a8:	1085883a 	add	r2,r2,r2
 90a70ac:	1085883a 	add	r2,r2,r2
 90a70b0:	10c5883a 	add	r2,r2,r3
 90a70b4:	10800017 	ldw	r2,0(r2)
 90a70b8:	10800a17 	ldw	r2,40(r2)
 90a70bc:	10bfc00c 	andi	r2,r2,65280
 90a70c0:	1004923a 	slli	r2,r2,8
 90a70c4:	2088b03a 	or	r4,r4,r2
 90a70c8:	e0bffc17 	ldw	r2,-16(fp)
 90a70cc:	00c243b4 	movhi	r3,2318
 90a70d0:	18f5e604 	addi	r3,r3,-10344
 90a70d4:	1085883a 	add	r2,r2,r2
 90a70d8:	1085883a 	add	r2,r2,r2
 90a70dc:	10c5883a 	add	r2,r2,r3
 90a70e0:	10800017 	ldw	r2,0(r2)
 90a70e4:	10800a17 	ldw	r2,40(r2)
 90a70e8:	10803fcc 	andi	r2,r2,255
 90a70ec:	1004963a 	slli	r2,r2,24
 90a70f0:	2084b03a 	or	r2,r4,r2
 90a70f4:	e0bffb15 	stw	r2,-20(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 90a70f8:	e0fff717 	ldw	r3,-36(fp)
 90a70fc:	00800c84 	movi	r2,50
 90a7100:	18800005 	stb	r2,0(r3)
 90a7104:	e0bff717 	ldw	r2,-36(fp)
 90a7108:	10800044 	addi	r2,r2,1
 90a710c:	e0bff715 	stw	r2,-36(fp)
 90a7110:	e0fff717 	ldw	r3,-36(fp)
 90a7114:	00800104 	movi	r2,4
 90a7118:	18800005 	stb	r2,0(r3)
 90a711c:	e0bff717 	ldw	r2,-36(fp)
 90a7120:	10800044 	addi	r2,r2,1
 90a7124:	e0bff715 	stw	r2,-36(fp)
 90a7128:	e0bff717 	ldw	r2,-36(fp)
 90a712c:	10c000c4 	addi	r3,r2,3
 90a7130:	e0bffb04 	addi	r2,fp,-20
 90a7134:	10800003 	ldbu	r2,0(r2)
 90a7138:	18800005 	stb	r2,0(r3)
 90a713c:	e0bff717 	ldw	r2,-36(fp)
 90a7140:	10c00084 	addi	r3,r2,2
 90a7144:	e0bffb04 	addi	r2,fp,-20
 90a7148:	10800044 	addi	r2,r2,1
 90a714c:	10800003 	ldbu	r2,0(r2)
 90a7150:	18800005 	stb	r2,0(r3)
 90a7154:	e0bff717 	ldw	r2,-36(fp)
 90a7158:	10c00044 	addi	r3,r2,1
 90a715c:	e0bffb04 	addi	r2,fp,-20
 90a7160:	10800084 	addi	r2,r2,2
 90a7164:	10800003 	ldbu	r2,0(r2)
 90a7168:	18800005 	stb	r2,0(r3)
 90a716c:	e0bffb04 	addi	r2,fp,-20
 90a7170:	108000c4 	addi	r2,r2,3
 90a7174:	10800003 	ldbu	r2,0(r2)
 90a7178:	1007883a 	mov	r3,r2
 90a717c:	e0bff717 	ldw	r2,-36(fp)
 90a7180:	10c00005 	stb	r3,0(r2)
 90a7184:	e0bff717 	ldw	r2,-36(fp)
 90a7188:	10800104 	addi	r2,r2,4
 90a718c:	e0bff715 	stw	r2,-36(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 90a7190:	d0a03317 	ldw	r2,-32564(gp)
 90a7194:	10800050 	cmplti	r2,r2,1
 90a7198:	10001e1e 	bne	r2,zero,90a7214 <dhc_discover+0x3f8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 90a719c:	e0fff717 	ldw	r3,-36(fp)
 90a71a0:	00800dc4 	movi	r2,55
 90a71a4:	18800005 	stb	r2,0(r3)
 90a71a8:	e0bff717 	ldw	r2,-36(fp)
 90a71ac:	10800044 	addi	r2,r2,1
 90a71b0:	e0bff715 	stw	r2,-36(fp)
      *opts++ = (u_char)reqlist_len ;
 90a71b4:	d0a03317 	ldw	r2,-32564(gp)
 90a71b8:	1007883a 	mov	r3,r2
 90a71bc:	e0bff717 	ldw	r2,-36(fp)
 90a71c0:	10c00005 	stb	r3,0(r2)
 90a71c4:	e0bff717 	ldw	r2,-36(fp)
 90a71c8:	10800044 	addi	r2,r2,1
 90a71cc:	e0bff715 	stw	r2,-36(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 90a71d0:	e03ff515 	stw	zero,-44(fp)
 90a71d4:	00000c06 	br	90a7208 <dhc_discover+0x3ec>
         *opts++ = reqlist[i];
 90a71d8:	e0fff517 	ldw	r3,-44(fp)
 90a71dc:	d0a03204 	addi	r2,gp,-32568
 90a71e0:	1885883a 	add	r2,r3,r2
 90a71e4:	10c00003 	ldbu	r3,0(r2)
 90a71e8:	e0bff717 	ldw	r2,-36(fp)
 90a71ec:	10c00005 	stb	r3,0(r2)
 90a71f0:	e0bff717 	ldw	r2,-36(fp)
 90a71f4:	10800044 	addi	r2,r2,1
 90a71f8:	e0bff715 	stw	r2,-36(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 90a71fc:	e0bff517 	ldw	r2,-44(fp)
 90a7200:	10800044 	addi	r2,r2,1
 90a7204:	e0bff515 	stw	r2,-44(fp)
 90a7208:	d0e03317 	ldw	r3,-32564(gp)
 90a720c:	e0bff517 	ldw	r2,-44(fp)
 90a7210:	10fff116 	blt	r2,r3,90a71d8 <dhc_discover+0x3bc>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 90a7214:	e0fff717 	ldw	r3,-36(fp)
 90a7218:	00bfffc4 	movi	r2,-1
 90a721c:	18800005 	stb	r2,0(r3)
 90a7220:	e0bff717 	ldw	r2,-36(fp)
 90a7224:	10800044 	addi	r2,r2,1
 90a7228:	e0bff715 	stw	r2,-36(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 90a722c:	e13ffc17 	ldw	r4,-16(fp)
 90a7230:	00824374 	movhi	r2,2317
 90a7234:	108f2e04 	addi	r2,r2,15544
 90a7238:	11400017 	ldw	r5,0(r2)
 90a723c:	00c243b4 	movhi	r3,2318
 90a7240:	18f60c04 	addi	r3,r3,-10192
 90a7244:	20800f24 	muli	r2,r4,60
 90a7248:	10c5883a 	add	r2,r2,r3
 90a724c:	10800404 	addi	r2,r2,16
 90a7250:	11400015 	stw	r5,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 90a7254:	e0fff917 	ldw	r3,-28(fp)
 90a7258:	00bfffc4 	movi	r2,-1
 90a725c:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 90a7260:	e0bffc17 	ldw	r2,-16(fp)
 90a7264:	00c243b4 	movhi	r3,2318
 90a7268:	18f5e604 	addi	r3,r3,-10344
 90a726c:	1085883a 	add	r2,r2,r2
 90a7270:	1085883a 	add	r2,r2,r2
 90a7274:	10c5883a 	add	r2,r2,r3
 90a7278:	10c00017 	ldw	r3,0(r2)
 90a727c:	e0bff917 	ldw	r2,-28(fp)
 90a7280:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 90a7284:	e0bffc17 	ldw	r2,-16(fp)
 90a7288:	00c243b4 	movhi	r3,2318
 90a728c:	18f60c04 	addi	r3,r3,-10192
 90a7290:	10800f24 	muli	r2,r2,60
 90a7294:	10c5883a 	add	r2,r2,r3
 90a7298:	10800017 	ldw	r2,0(r2)
 90a729c:	10800120 	cmpeqi	r2,r2,4
 90a72a0:	1000031e 	bne	r2,zero,90a72b0 <dhc_discover+0x494>
      dhc_set_state(iface, DHCS_SELECTING);
 90a72a4:	e13ffc17 	ldw	r4,-16(fp)
 90a72a8:	01400104 	movi	r5,4
 90a72ac:	90a94280 	call	90a9428 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a72b0:	010010c4 	movi	r4,67
 90a72b4:	01401104 	movi	r5,68
 90a72b8:	e1bff917 	ldw	r6,-28(fp)
 90a72bc:	90c45f80 	call	90c45f8 <udp_send>
   dsc_discovers++;
 90a72c0:	d0a09217 	ldw	r2,-32184(gp)
 90a72c4:	10800044 	addi	r2,r2,1
 90a72c8:	d0a09215 	stw	r2,-32184(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 90a72cc:	e13ffc17 	ldw	r4,-16(fp)
 90a72d0:	00824374 	movhi	r2,2317
 90a72d4:	108f2e04 	addi	r2,r2,15544
 90a72d8:	11400017 	ldw	r5,0(r2)
 90a72dc:	00c243b4 	movhi	r3,2318
 90a72e0:	18f60c04 	addi	r3,r3,-10192
 90a72e4:	20800f24 	muli	r2,r4,60
 90a72e8:	10c5883a 	add	r2,r2,r3
 90a72ec:	10800404 	addi	r2,r2,16
 90a72f0:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 90a72f4:	e17ffc17 	ldw	r5,-16(fp)
 90a72f8:	00c243b4 	movhi	r3,2318
 90a72fc:	18f60c04 	addi	r3,r3,-10192
 90a7300:	28800f24 	muli	r2,r5,60
 90a7304:	10c5883a 	add	r2,r2,r3
 90a7308:	10800104 	addi	r2,r2,4
 90a730c:	10800017 	ldw	r2,0(r2)
 90a7310:	11000044 	addi	r4,r2,1
 90a7314:	00c243b4 	movhi	r3,2318
 90a7318:	18f60c04 	addi	r3,r3,-10192
 90a731c:	28800f24 	muli	r2,r5,60
 90a7320:	10c5883a 	add	r2,r2,r3
 90a7324:	10800104 	addi	r2,r2,4
 90a7328:	11000015 	stw	r4,0(r2)

   return 0;
 90a732c:	e03ffd15 	stw	zero,-12(fp)
 90a7330:	e0bffd17 	ldw	r2,-12(fp)
}
 90a7334:	e037883a 	mov	sp,fp
 90a7338:	dfc00217 	ldw	ra,8(sp)
 90a733c:	df000117 	ldw	fp,4(sp)
 90a7340:	dc000017 	ldw	r16,0(sp)
 90a7344:	dec00304 	addi	sp,sp,12
 90a7348:	f800283a 	ret

090a734c <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 90a734c:	defff804 	addi	sp,sp,-32
 90a7350:	dfc00715 	stw	ra,28(sp)
 90a7354:	df000615 	stw	fp,24(sp)
 90a7358:	df000604 	addi	fp,sp,24
 90a735c:	e13ffc15 	stw	r4,-16(fp)
 90a7360:	e17ffd15 	stw	r5,-12(fp)
 90a7364:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 90a7368:	e0bffc17 	ldw	r2,-16(fp)
 90a736c:	00c243b4 	movhi	r3,2318
 90a7370:	18f60c04 	addi	r3,r3,-10192
 90a7374:	10800f24 	muli	r2,r2,60
 90a7378:	10c5883a 	add	r2,r2,r3
 90a737c:	10800204 	addi	r2,r2,8
 90a7380:	10c00017 	ldw	r3,0(r2)
 90a7384:	e0bffd17 	ldw	r2,-12(fp)
 90a7388:	10800117 	ldw	r2,4(r2)
 90a738c:	18800326 	beq	r3,r2,90a739c <dhc_rx_offer+0x50>
      return ENP_NOT_MINE;
 90a7390:	00800084 	movi	r2,2
 90a7394:	e0bfff15 	stw	r2,-4(fp)
 90a7398:	00002706 	br	90a7438 <dhc_rx_offer+0xec>

   opts = &bp->options[4];    /* examine options after cookie */
 90a739c:	e0bffd17 	ldw	r2,-12(fp)
 90a73a0:	10803b04 	addi	r2,r2,236
 90a73a4:	10800104 	addi	r2,r2,4
 90a73a8:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 90a73ac:	e13ffc17 	ldw	r4,-16(fp)
 90a73b0:	e17ffb17 	ldw	r5,-20(fp)
 90a73b4:	90a84d40 	call	90a84d4 <dhc_extract_opts>
 90a73b8:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 90a73bc:	e0bffa17 	ldw	r2,-24(fp)
 90a73c0:	1005003a 	cmpeq	r2,r2,zero
 90a73c4:	1000041e 	bne	r2,zero,90a73d8 <dhc_rx_offer+0x8c>
   {
      dtrap();
 90a73c8:	90aa4780 	call	90aa478 <dtrap>
      return e;
 90a73cc:	e0bffa17 	ldw	r2,-24(fp)
 90a73d0:	e0bfff15 	stw	r2,-4(fp)
 90a73d4:	00001806 	br	90a7438 <dhc_rx_offer+0xec>
   }
   if (!bp->yiaddr)  /* require an IP address */
 90a73d8:	e0bffd17 	ldw	r2,-12(fp)
 90a73dc:	10800417 	ldw	r2,16(r2)
 90a73e0:	1004c03a 	cmpne	r2,r2,zero
 90a73e4:	1000071e 	bne	r2,zero,90a7404 <dhc_rx_offer+0xb8>
   {
      dhc_decline(iface,bp, bplen);
 90a73e8:	e13ffc17 	ldw	r4,-16(fp)
 90a73ec:	e17ffd17 	ldw	r5,-12(fp)
 90a73f0:	e1bffe17 	ldw	r6,-8(fp)
 90a73f4:	90a82f00 	call	90a82f0 <dhc_decline>
      return ENP_NOT_MINE;
 90a73f8:	00800084 	movi	r2,2
 90a73fc:	e0bfff15 	stw	r2,-4(fp)
 90a7400:	00000d06 	br	90a7438 <dhc_rx_offer+0xec>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 90a7404:	e13ffc17 	ldw	r4,-16(fp)
 90a7408:	e0bffd17 	ldw	r2,-12(fp)
 90a740c:	11400417 	ldw	r5,16(r2)
 90a7410:	00c243b4 	movhi	r3,2318
 90a7414:	18f60c04 	addi	r3,r3,-10192
 90a7418:	20800f24 	muli	r2,r4,60
 90a741c:	10c5883a 	add	r2,r2,r3
 90a7420:	10800904 	addi	r2,r2,36
 90a7424:	11400015 	stw	r5,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 90a7428:	e13ffc17 	ldw	r4,-16(fp)
 90a742c:	000b883a 	mov	r5,zero
 90a7430:	90a74500 	call	90a7450 <dhc_request>
 90a7434:	e0bfff15 	stw	r2,-4(fp)
 90a7438:	e0bfff17 	ldw	r2,-4(fp)
}
 90a743c:	e037883a 	mov	sp,fp
 90a7440:	dfc00117 	ldw	ra,4(sp)
 90a7444:	df000017 	ldw	fp,0(sp)
 90a7448:	dec00204 	addi	sp,sp,8
 90a744c:	f800283a 	ret

090a7450 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 90a7450:	defff304 	addi	sp,sp,-52
 90a7454:	dfc00c15 	stw	ra,48(sp)
 90a7458:	df000b15 	stw	fp,44(sp)
 90a745c:	df000b04 	addi	fp,sp,44
 90a7460:	e13ffd15 	stw	r4,-12(fp)
 90a7464:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 90a7468:	01008904 	movi	r4,548
 90a746c:	000b883a 	mov	r5,zero
 90a7470:	90c4ab00 	call	90c4ab0 <udp_alloc>
 90a7474:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 90a7478:	e0bffa17 	ldw	r2,-24(fp)
 90a747c:	1004c03a 	cmpne	r2,r2,zero
 90a7480:	1000031e 	bne	r2,zero,90a7490 <dhc_request+0x40>
      return ENP_NOMEM;
 90a7484:	00bffb04 	movi	r2,-20
 90a7488:	e0bfff15 	stw	r2,-4(fp)
 90a748c:	0002b906 	br	90a7f74 <dhc_request+0xb24>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 90a7490:	e0fffa17 	ldw	r3,-24(fp)
 90a7494:	00803b04 	movi	r2,236
 90a7498:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 90a749c:	e0bffe17 	ldw	r2,-8(fp)
 90a74a0:	10800058 	cmpnei	r2,r2,1
 90a74a4:	1000121e 	bne	r2,zero,90a74f0 <dhc_request+0xa0>
   {
      dhc_states[iface].xid  = xids++;
 90a74a8:	e0bffd17 	ldw	r2,-12(fp)
 90a74ac:	d1203117 	ldw	r4,-32572(gp)
 90a74b0:	200b883a 	mov	r5,r4
 90a74b4:	00c243b4 	movhi	r3,2318
 90a74b8:	18f60c04 	addi	r3,r3,-10192
 90a74bc:	10800f24 	muli	r2,r2,60
 90a74c0:	10c5883a 	add	r2,r2,r3
 90a74c4:	10800204 	addi	r2,r2,8
 90a74c8:	11400015 	stw	r5,0(r2)
 90a74cc:	20800044 	addi	r2,r4,1
 90a74d0:	d0a03115 	stw	r2,-32572(gp)
      dhc_states[iface].secs = 0;
 90a74d4:	e0bffd17 	ldw	r2,-12(fp)
 90a74d8:	00c243b4 	movhi	r3,2318
 90a74dc:	18f60c04 	addi	r3,r3,-10192
 90a74e0:	10800f24 	muli	r2,r2,60
 90a74e4:	10c5883a 	add	r2,r2,r3
 90a74e8:	10800304 	addi	r2,r2,12
 90a74ec:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 90a74f0:	e0bffa17 	ldw	r2,-24(fp)
 90a74f4:	10800317 	ldw	r2,12(r2)
 90a74f8:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 90a74fc:	e13ffd17 	ldw	r4,-12(fp)
 90a7500:	e17ffb17 	ldw	r5,-20(fp)
 90a7504:	90a6c000 	call	90a6c00 <dhc_buildheader>
 90a7508:	e0bff815 	stw	r2,-32(fp)
   if (e)
 90a750c:	e0bff817 	ldw	r2,-32(fp)
 90a7510:	1005003a 	cmpeq	r2,r2,zero
 90a7514:	1000031e 	bne	r2,zero,90a7524 <dhc_request+0xd4>
      return e;
 90a7518:	e0bff817 	ldw	r2,-32(fp)
 90a751c:	e0bfff15 	stw	r2,-4(fp)
 90a7520:	00029406 	br	90a7f74 <dhc_request+0xb24>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 90a7524:	e0bffb17 	ldw	r2,-20(fp)
 90a7528:	10803b04 	addi	r2,r2,236
 90a752c:	1007883a 	mov	r3,r2
 90a7530:	0098d534 	movhi	r2,25428
 90a7534:	10a098c4 	addi	r2,r2,-32157
 90a7538:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 90a753c:	e0bffb17 	ldw	r2,-20(fp)
 90a7540:	10803b04 	addi	r2,r2,236
 90a7544:	10800104 	addi	r2,r2,4
 90a7548:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 90a754c:	e0fff917 	ldw	r3,-28(fp)
 90a7550:	00800d44 	movi	r2,53
 90a7554:	18800005 	stb	r2,0(r3)
 90a7558:	e0bff917 	ldw	r2,-28(fp)
 90a755c:	10800044 	addi	r2,r2,1
 90a7560:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 90a7564:	e0fff917 	ldw	r3,-28(fp)
 90a7568:	00800044 	movi	r2,1
 90a756c:	18800005 	stb	r2,0(r3)
 90a7570:	e0bff917 	ldw	r2,-28(fp)
 90a7574:	10800044 	addi	r2,r2,1
 90a7578:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 90a757c:	e0fff917 	ldw	r3,-28(fp)
 90a7580:	008000c4 	movi	r2,3
 90a7584:	18800005 	stb	r2,0(r3)
 90a7588:	e0bff917 	ldw	r2,-28(fp)
 90a758c:	10800044 	addi	r2,r2,1
 90a7590:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 90a7594:	e0bffd17 	ldw	r2,-12(fp)
 90a7598:	00c243b4 	movhi	r3,2318
 90a759c:	18f60c04 	addi	r3,r3,-10192
 90a75a0:	10800f24 	muli	r2,r2,60
 90a75a4:	10c5883a 	add	r2,r2,r3
 90a75a8:	10800017 	ldw	r2,0(r2)
 90a75ac:	10800120 	cmpeqi	r2,r2,4
 90a75b0:	1000181e 	bne	r2,zero,90a7614 <dhc_request+0x1c4>
 90a75b4:	e0bffd17 	ldw	r2,-12(fp)
 90a75b8:	00c243b4 	movhi	r3,2318
 90a75bc:	18f60c04 	addi	r3,r3,-10192
 90a75c0:	10800f24 	muli	r2,r2,60
 90a75c4:	10c5883a 	add	r2,r2,r3
 90a75c8:	10800017 	ldw	r2,0(r2)
 90a75cc:	10800160 	cmpeqi	r2,r2,5
 90a75d0:	1000101e 	bne	r2,zero,90a7614 <dhc_request+0x1c4>
 90a75d4:	e0bffd17 	ldw	r2,-12(fp)
 90a75d8:	00c243b4 	movhi	r3,2318
 90a75dc:	18f60c04 	addi	r3,r3,-10192
 90a75e0:	10800f24 	muli	r2,r2,60
 90a75e4:	10c5883a 	add	r2,r2,r3
 90a75e8:	10800017 	ldw	r2,0(r2)
 90a75ec:	108000e0 	cmpeqi	r2,r2,3
 90a75f0:	1000081e 	bne	r2,zero,90a7614 <dhc_request+0x1c4>
 90a75f4:	e0bffd17 	ldw	r2,-12(fp)
 90a75f8:	00c243b4 	movhi	r3,2318
 90a75fc:	18f60c04 	addi	r3,r3,-10192
 90a7600:	10800f24 	muli	r2,r2,60
 90a7604:	10c5883a 	add	r2,r2,r3
 90a7608:	10800017 	ldw	r2,0(r2)
 90a760c:	10800098 	cmpnei	r2,r2,2
 90a7610:	10004e1e 	bne	r2,zero,90a774c <dhc_request+0x2fc>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 90a7614:	e0bffd17 	ldw	r2,-12(fp)
 90a7618:	00c243b4 	movhi	r3,2318
 90a761c:	18f60c04 	addi	r3,r3,-10192
 90a7620:	10800f24 	muli	r2,r2,60
 90a7624:	10c5883a 	add	r2,r2,r3
 90a7628:	10800904 	addi	r2,r2,36
 90a762c:	10800017 	ldw	r2,0(r2)
 90a7630:	1004d63a 	srli	r2,r2,24
 90a7634:	11003fcc 	andi	r4,r2,255
 90a7638:	e0bffd17 	ldw	r2,-12(fp)
 90a763c:	00c243b4 	movhi	r3,2318
 90a7640:	18f60c04 	addi	r3,r3,-10192
 90a7644:	10800f24 	muli	r2,r2,60
 90a7648:	10c5883a 	add	r2,r2,r3
 90a764c:	10800904 	addi	r2,r2,36
 90a7650:	10800017 	ldw	r2,0(r2)
 90a7654:	1004d23a 	srli	r2,r2,8
 90a7658:	10bfc00c 	andi	r2,r2,65280
 90a765c:	2088b03a 	or	r4,r4,r2
 90a7660:	e0bffd17 	ldw	r2,-12(fp)
 90a7664:	00c243b4 	movhi	r3,2318
 90a7668:	18f60c04 	addi	r3,r3,-10192
 90a766c:	10800f24 	muli	r2,r2,60
 90a7670:	10c5883a 	add	r2,r2,r3
 90a7674:	10800904 	addi	r2,r2,36
 90a7678:	10800017 	ldw	r2,0(r2)
 90a767c:	10bfc00c 	andi	r2,r2,65280
 90a7680:	1004923a 	slli	r2,r2,8
 90a7684:	2088b03a 	or	r4,r4,r2
 90a7688:	e0bffd17 	ldw	r2,-12(fp)
 90a768c:	00c243b4 	movhi	r3,2318
 90a7690:	18f60c04 	addi	r3,r3,-10192
 90a7694:	10800f24 	muli	r2,r2,60
 90a7698:	10c5883a 	add	r2,r2,r3
 90a769c:	10800904 	addi	r2,r2,36
 90a76a0:	10800017 	ldw	r2,0(r2)
 90a76a4:	10803fcc 	andi	r2,r2,255
 90a76a8:	1004963a 	slli	r2,r2,24
 90a76ac:	2084b03a 	or	r2,r4,r2
 90a76b0:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 90a76b4:	e0fff917 	ldw	r3,-28(fp)
 90a76b8:	00800c84 	movi	r2,50
 90a76bc:	18800005 	stb	r2,0(r3)
 90a76c0:	e0bff917 	ldw	r2,-28(fp)
 90a76c4:	10800044 	addi	r2,r2,1
 90a76c8:	e0bff915 	stw	r2,-28(fp)
 90a76cc:	e0fff917 	ldw	r3,-28(fp)
 90a76d0:	00800104 	movi	r2,4
 90a76d4:	18800005 	stb	r2,0(r3)
 90a76d8:	e0bff917 	ldw	r2,-28(fp)
 90a76dc:	10800044 	addi	r2,r2,1
 90a76e0:	e0bff915 	stw	r2,-28(fp)
 90a76e4:	e0bff917 	ldw	r2,-28(fp)
 90a76e8:	10c000c4 	addi	r3,r2,3
 90a76ec:	e0bffc04 	addi	r2,fp,-16
 90a76f0:	10800003 	ldbu	r2,0(r2)
 90a76f4:	18800005 	stb	r2,0(r3)
 90a76f8:	e0bff917 	ldw	r2,-28(fp)
 90a76fc:	10c00084 	addi	r3,r2,2
 90a7700:	e0bffc04 	addi	r2,fp,-16
 90a7704:	10800044 	addi	r2,r2,1
 90a7708:	10800003 	ldbu	r2,0(r2)
 90a770c:	18800005 	stb	r2,0(r3)
 90a7710:	e0bff917 	ldw	r2,-28(fp)
 90a7714:	10c00044 	addi	r3,r2,1
 90a7718:	e0bffc04 	addi	r2,fp,-16
 90a771c:	10800084 	addi	r2,r2,2
 90a7720:	10800003 	ldbu	r2,0(r2)
 90a7724:	18800005 	stb	r2,0(r3)
 90a7728:	e0bffc04 	addi	r2,fp,-16
 90a772c:	108000c4 	addi	r2,r2,3
 90a7730:	10800003 	ldbu	r2,0(r2)
 90a7734:	1007883a 	mov	r3,r2
 90a7738:	e0bff917 	ldw	r2,-28(fp)
 90a773c:	10c00005 	stb	r3,0(r2)
 90a7740:	e0bff917 	ldw	r2,-28(fp)
 90a7744:	10800104 	addi	r2,r2,4
 90a7748:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 90a774c:	e0bffd17 	ldw	r2,-12(fp)
 90a7750:	00c243b4 	movhi	r3,2318
 90a7754:	18f60c04 	addi	r3,r3,-10192
 90a7758:	10800f24 	muli	r2,r2,60
 90a775c:	10c5883a 	add	r2,r2,r3
 90a7760:	10800a04 	addi	r2,r2,40
 90a7764:	10800017 	ldw	r2,0(r2)
 90a7768:	1005003a 	cmpeq	r2,r2,zero
 90a776c:	10004e1e 	bne	r2,zero,90a78a8 <dhc_request+0x458>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 90a7770:	e0bffd17 	ldw	r2,-12(fp)
 90a7774:	00c243b4 	movhi	r3,2318
 90a7778:	18f60c04 	addi	r3,r3,-10192
 90a777c:	10800f24 	muli	r2,r2,60
 90a7780:	10c5883a 	add	r2,r2,r3
 90a7784:	10800a04 	addi	r2,r2,40
 90a7788:	10800017 	ldw	r2,0(r2)
 90a778c:	1004d63a 	srli	r2,r2,24
 90a7790:	11003fcc 	andi	r4,r2,255
 90a7794:	e0bffd17 	ldw	r2,-12(fp)
 90a7798:	00c243b4 	movhi	r3,2318
 90a779c:	18f60c04 	addi	r3,r3,-10192
 90a77a0:	10800f24 	muli	r2,r2,60
 90a77a4:	10c5883a 	add	r2,r2,r3
 90a77a8:	10800a04 	addi	r2,r2,40
 90a77ac:	10800017 	ldw	r2,0(r2)
 90a77b0:	1004d23a 	srli	r2,r2,8
 90a77b4:	10bfc00c 	andi	r2,r2,65280
 90a77b8:	2088b03a 	or	r4,r4,r2
 90a77bc:	e0bffd17 	ldw	r2,-12(fp)
 90a77c0:	00c243b4 	movhi	r3,2318
 90a77c4:	18f60c04 	addi	r3,r3,-10192
 90a77c8:	10800f24 	muli	r2,r2,60
 90a77cc:	10c5883a 	add	r2,r2,r3
 90a77d0:	10800a04 	addi	r2,r2,40
 90a77d4:	10800017 	ldw	r2,0(r2)
 90a77d8:	10bfc00c 	andi	r2,r2,65280
 90a77dc:	1004923a 	slli	r2,r2,8
 90a77e0:	2088b03a 	or	r4,r4,r2
 90a77e4:	e0bffd17 	ldw	r2,-12(fp)
 90a77e8:	00c243b4 	movhi	r3,2318
 90a77ec:	18f60c04 	addi	r3,r3,-10192
 90a77f0:	10800f24 	muli	r2,r2,60
 90a77f4:	10c5883a 	add	r2,r2,r3
 90a77f8:	10800a04 	addi	r2,r2,40
 90a77fc:	10800017 	ldw	r2,0(r2)
 90a7800:	10803fcc 	andi	r2,r2,255
 90a7804:	1004963a 	slli	r2,r2,24
 90a7808:	2084b03a 	or	r2,r4,r2
 90a780c:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 90a7810:	e0fff917 	ldw	r3,-28(fp)
 90a7814:	00800044 	movi	r2,1
 90a7818:	18800005 	stb	r2,0(r3)
 90a781c:	e0bff917 	ldw	r2,-28(fp)
 90a7820:	10800044 	addi	r2,r2,1
 90a7824:	e0bff915 	stw	r2,-28(fp)
 90a7828:	e0fff917 	ldw	r3,-28(fp)
 90a782c:	00800104 	movi	r2,4
 90a7830:	18800005 	stb	r2,0(r3)
 90a7834:	e0bff917 	ldw	r2,-28(fp)
 90a7838:	10800044 	addi	r2,r2,1
 90a783c:	e0bff915 	stw	r2,-28(fp)
 90a7840:	e0bff917 	ldw	r2,-28(fp)
 90a7844:	10c000c4 	addi	r3,r2,3
 90a7848:	e0bffc04 	addi	r2,fp,-16
 90a784c:	10800003 	ldbu	r2,0(r2)
 90a7850:	18800005 	stb	r2,0(r3)
 90a7854:	e0bff917 	ldw	r2,-28(fp)
 90a7858:	10c00084 	addi	r3,r2,2
 90a785c:	e0bffc04 	addi	r2,fp,-16
 90a7860:	10800044 	addi	r2,r2,1
 90a7864:	10800003 	ldbu	r2,0(r2)
 90a7868:	18800005 	stb	r2,0(r3)
 90a786c:	e0bff917 	ldw	r2,-28(fp)
 90a7870:	10c00044 	addi	r3,r2,1
 90a7874:	e0bffc04 	addi	r2,fp,-16
 90a7878:	10800084 	addi	r2,r2,2
 90a787c:	10800003 	ldbu	r2,0(r2)
 90a7880:	18800005 	stb	r2,0(r3)
 90a7884:	e0bffc04 	addi	r2,fp,-16
 90a7888:	108000c4 	addi	r2,r2,3
 90a788c:	10800003 	ldbu	r2,0(r2)
 90a7890:	1007883a 	mov	r3,r2
 90a7894:	e0bff917 	ldw	r2,-28(fp)
 90a7898:	10c00005 	stb	r3,0(r2)
 90a789c:	e0bff917 	ldw	r2,-28(fp)
 90a78a0:	10800104 	addi	r2,r2,4
 90a78a4:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 90a78a8:	e0bffd17 	ldw	r2,-12(fp)
 90a78ac:	00c243b4 	movhi	r3,2318
 90a78b0:	18f60c04 	addi	r3,r3,-10192
 90a78b4:	10800f24 	muli	r2,r2,60
 90a78b8:	10c5883a 	add	r2,r2,r3
 90a78bc:	10800b04 	addi	r2,r2,44
 90a78c0:	10800017 	ldw	r2,0(r2)
 90a78c4:	1005003a 	cmpeq	r2,r2,zero
 90a78c8:	10004e1e 	bne	r2,zero,90a7a04 <dhc_request+0x5b4>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 90a78cc:	e0bffd17 	ldw	r2,-12(fp)
 90a78d0:	00c243b4 	movhi	r3,2318
 90a78d4:	18f60c04 	addi	r3,r3,-10192
 90a78d8:	10800f24 	muli	r2,r2,60
 90a78dc:	10c5883a 	add	r2,r2,r3
 90a78e0:	10800b04 	addi	r2,r2,44
 90a78e4:	10800017 	ldw	r2,0(r2)
 90a78e8:	1004d63a 	srli	r2,r2,24
 90a78ec:	11003fcc 	andi	r4,r2,255
 90a78f0:	e0bffd17 	ldw	r2,-12(fp)
 90a78f4:	00c243b4 	movhi	r3,2318
 90a78f8:	18f60c04 	addi	r3,r3,-10192
 90a78fc:	10800f24 	muli	r2,r2,60
 90a7900:	10c5883a 	add	r2,r2,r3
 90a7904:	10800b04 	addi	r2,r2,44
 90a7908:	10800017 	ldw	r2,0(r2)
 90a790c:	1004d23a 	srli	r2,r2,8
 90a7910:	10bfc00c 	andi	r2,r2,65280
 90a7914:	2088b03a 	or	r4,r4,r2
 90a7918:	e0bffd17 	ldw	r2,-12(fp)
 90a791c:	00c243b4 	movhi	r3,2318
 90a7920:	18f60c04 	addi	r3,r3,-10192
 90a7924:	10800f24 	muli	r2,r2,60
 90a7928:	10c5883a 	add	r2,r2,r3
 90a792c:	10800b04 	addi	r2,r2,44
 90a7930:	10800017 	ldw	r2,0(r2)
 90a7934:	10bfc00c 	andi	r2,r2,65280
 90a7938:	1004923a 	slli	r2,r2,8
 90a793c:	2088b03a 	or	r4,r4,r2
 90a7940:	e0bffd17 	ldw	r2,-12(fp)
 90a7944:	00c243b4 	movhi	r3,2318
 90a7948:	18f60c04 	addi	r3,r3,-10192
 90a794c:	10800f24 	muli	r2,r2,60
 90a7950:	10c5883a 	add	r2,r2,r3
 90a7954:	10800b04 	addi	r2,r2,44
 90a7958:	10800017 	ldw	r2,0(r2)
 90a795c:	10803fcc 	andi	r2,r2,255
 90a7960:	1004963a 	slli	r2,r2,24
 90a7964:	2084b03a 	or	r2,r4,r2
 90a7968:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 90a796c:	e0fff917 	ldw	r3,-28(fp)
 90a7970:	008000c4 	movi	r2,3
 90a7974:	18800005 	stb	r2,0(r3)
 90a7978:	e0bff917 	ldw	r2,-28(fp)
 90a797c:	10800044 	addi	r2,r2,1
 90a7980:	e0bff915 	stw	r2,-28(fp)
 90a7984:	e0fff917 	ldw	r3,-28(fp)
 90a7988:	00800104 	movi	r2,4
 90a798c:	18800005 	stb	r2,0(r3)
 90a7990:	e0bff917 	ldw	r2,-28(fp)
 90a7994:	10800044 	addi	r2,r2,1
 90a7998:	e0bff915 	stw	r2,-28(fp)
 90a799c:	e0bff917 	ldw	r2,-28(fp)
 90a79a0:	10c000c4 	addi	r3,r2,3
 90a79a4:	e0bffc04 	addi	r2,fp,-16
 90a79a8:	10800003 	ldbu	r2,0(r2)
 90a79ac:	18800005 	stb	r2,0(r3)
 90a79b0:	e0bff917 	ldw	r2,-28(fp)
 90a79b4:	10c00084 	addi	r3,r2,2
 90a79b8:	e0bffc04 	addi	r2,fp,-16
 90a79bc:	10800044 	addi	r2,r2,1
 90a79c0:	10800003 	ldbu	r2,0(r2)
 90a79c4:	18800005 	stb	r2,0(r3)
 90a79c8:	e0bff917 	ldw	r2,-28(fp)
 90a79cc:	10c00044 	addi	r3,r2,1
 90a79d0:	e0bffc04 	addi	r2,fp,-16
 90a79d4:	10800084 	addi	r2,r2,2
 90a79d8:	10800003 	ldbu	r2,0(r2)
 90a79dc:	18800005 	stb	r2,0(r3)
 90a79e0:	e0bffc04 	addi	r2,fp,-16
 90a79e4:	108000c4 	addi	r2,r2,3
 90a79e8:	10800003 	ldbu	r2,0(r2)
 90a79ec:	1007883a 	mov	r3,r2
 90a79f0:	e0bff917 	ldw	r2,-28(fp)
 90a79f4:	10c00005 	stb	r3,0(r2)
 90a79f8:	e0bff917 	ldw	r2,-28(fp)
 90a79fc:	10800104 	addi	r2,r2,4
 90a7a00:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 90a7a04:	e0bffd17 	ldw	r2,-12(fp)
 90a7a08:	00c243b4 	movhi	r3,2318
 90a7a0c:	18f60c04 	addi	r3,r3,-10192
 90a7a10:	10800f24 	muli	r2,r2,60
 90a7a14:	10c5883a 	add	r2,r2,r3
 90a7a18:	10800504 	addi	r2,r2,20
 90a7a1c:	10800017 	ldw	r2,0(r2)
 90a7a20:	1005003a 	cmpeq	r2,r2,zero
 90a7a24:	10003a1e 	bne	r2,zero,90a7b10 <dhc_request+0x6c0>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 90a7a28:	e0fff917 	ldw	r3,-28(fp)
 90a7a2c:	00800cc4 	movi	r2,51
 90a7a30:	18800005 	stb	r2,0(r3)
 90a7a34:	e0bff917 	ldw	r2,-28(fp)
 90a7a38:	10800044 	addi	r2,r2,1
 90a7a3c:	e0bff915 	stw	r2,-28(fp)
 90a7a40:	e0fff917 	ldw	r3,-28(fp)
 90a7a44:	00800104 	movi	r2,4
 90a7a48:	18800005 	stb	r2,0(r3)
 90a7a4c:	e0bff917 	ldw	r2,-28(fp)
 90a7a50:	10800044 	addi	r2,r2,1
 90a7a54:	e0bff915 	stw	r2,-28(fp)
 90a7a58:	e0bff917 	ldw	r2,-28(fp)
 90a7a5c:	110000c4 	addi	r4,r2,3
 90a7a60:	e0bffd17 	ldw	r2,-12(fp)
 90a7a64:	10800f24 	muli	r2,r2,60
 90a7a68:	10c00504 	addi	r3,r2,20
 90a7a6c:	008243b4 	movhi	r2,2318
 90a7a70:	10b60c04 	addi	r2,r2,-10192
 90a7a74:	1885883a 	add	r2,r3,r2
 90a7a78:	10800003 	ldbu	r2,0(r2)
 90a7a7c:	20800005 	stb	r2,0(r4)
 90a7a80:	e0bff917 	ldw	r2,-28(fp)
 90a7a84:	11000084 	addi	r4,r2,2
 90a7a88:	e0bffd17 	ldw	r2,-12(fp)
 90a7a8c:	10800f24 	muli	r2,r2,60
 90a7a90:	10c00504 	addi	r3,r2,20
 90a7a94:	008243b4 	movhi	r2,2318
 90a7a98:	10b60c04 	addi	r2,r2,-10192
 90a7a9c:	1885883a 	add	r2,r3,r2
 90a7aa0:	10800044 	addi	r2,r2,1
 90a7aa4:	10800003 	ldbu	r2,0(r2)
 90a7aa8:	20800005 	stb	r2,0(r4)
 90a7aac:	e0bff917 	ldw	r2,-28(fp)
 90a7ab0:	11000044 	addi	r4,r2,1
 90a7ab4:	e0bffd17 	ldw	r2,-12(fp)
 90a7ab8:	10800f24 	muli	r2,r2,60
 90a7abc:	10c00504 	addi	r3,r2,20
 90a7ac0:	008243b4 	movhi	r2,2318
 90a7ac4:	10b60c04 	addi	r2,r2,-10192
 90a7ac8:	1885883a 	add	r2,r3,r2
 90a7acc:	10800084 	addi	r2,r2,2
 90a7ad0:	10800003 	ldbu	r2,0(r2)
 90a7ad4:	20800005 	stb	r2,0(r4)
 90a7ad8:	e0bffd17 	ldw	r2,-12(fp)
 90a7adc:	10800f24 	muli	r2,r2,60
 90a7ae0:	10c00504 	addi	r3,r2,20
 90a7ae4:	008243b4 	movhi	r2,2318
 90a7ae8:	10b60c04 	addi	r2,r2,-10192
 90a7aec:	1885883a 	add	r2,r3,r2
 90a7af0:	108000c4 	addi	r2,r2,3
 90a7af4:	10800003 	ldbu	r2,0(r2)
 90a7af8:	1007883a 	mov	r3,r2
 90a7afc:	e0bff917 	ldw	r2,-28(fp)
 90a7b00:	10c00005 	stb	r3,0(r2)
 90a7b04:	e0bff917 	ldw	r2,-28(fp)
 90a7b08:	10800104 	addi	r2,r2,4
 90a7b0c:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 90a7b10:	d0a03317 	ldw	r2,-32564(gp)
 90a7b14:	10800050 	cmplti	r2,r2,1
 90a7b18:	10001e1e 	bne	r2,zero,90a7b94 <dhc_request+0x744>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 90a7b1c:	e0fff917 	ldw	r3,-28(fp)
 90a7b20:	00800dc4 	movi	r2,55
 90a7b24:	18800005 	stb	r2,0(r3)
 90a7b28:	e0bff917 	ldw	r2,-28(fp)
 90a7b2c:	10800044 	addi	r2,r2,1
 90a7b30:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 90a7b34:	d0a03317 	ldw	r2,-32564(gp)
 90a7b38:	1007883a 	mov	r3,r2
 90a7b3c:	e0bff917 	ldw	r2,-28(fp)
 90a7b40:	10c00005 	stb	r3,0(r2)
 90a7b44:	e0bff917 	ldw	r2,-28(fp)
 90a7b48:	10800044 	addi	r2,r2,1
 90a7b4c:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 90a7b50:	e03ff715 	stw	zero,-36(fp)
 90a7b54:	00000c06 	br	90a7b88 <dhc_request+0x738>
         *opts++ = reqlist[i];
 90a7b58:	e0fff717 	ldw	r3,-36(fp)
 90a7b5c:	d0a03204 	addi	r2,gp,-32568
 90a7b60:	1885883a 	add	r2,r3,r2
 90a7b64:	10c00003 	ldbu	r3,0(r2)
 90a7b68:	e0bff917 	ldw	r2,-28(fp)
 90a7b6c:	10c00005 	stb	r3,0(r2)
 90a7b70:	e0bff917 	ldw	r2,-28(fp)
 90a7b74:	10800044 	addi	r2,r2,1
 90a7b78:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 90a7b7c:	e0bff717 	ldw	r2,-36(fp)
 90a7b80:	10800044 	addi	r2,r2,1
 90a7b84:	e0bff715 	stw	r2,-36(fp)
 90a7b88:	d0e03317 	ldw	r3,-32564(gp)
 90a7b8c:	e0bff717 	ldw	r2,-36(fp)
 90a7b90:	10fff116 	blt	r2,r3,90a7b58 <dhc_request+0x708>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 90a7b94:	e0bffd17 	ldw	r2,-12(fp)
 90a7b98:	00c243b4 	movhi	r3,2318
 90a7b9c:	18f60c04 	addi	r3,r3,-10192
 90a7ba0:	10800f24 	muli	r2,r2,60
 90a7ba4:	10c5883a 	add	r2,r2,r3
 90a7ba8:	10800017 	ldw	r2,0(r2)
 90a7bac:	108001e0 	cmpeqi	r2,r2,7
 90a7bb0:	1000081e 	bne	r2,zero,90a7bd4 <dhc_request+0x784>
 90a7bb4:	e0bffd17 	ldw	r2,-12(fp)
 90a7bb8:	00c243b4 	movhi	r3,2318
 90a7bbc:	18f60c04 	addi	r3,r3,-10192
 90a7bc0:	10800f24 	muli	r2,r2,60
 90a7bc4:	10c5883a 	add	r2,r2,r3
 90a7bc8:	10800017 	ldw	r2,0(r2)
 90a7bcc:	10800218 	cmpnei	r2,r2,8
 90a7bd0:	10000a1e 	bne	r2,zero,90a7bfc <dhc_request+0x7ac>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 90a7bd4:	e0bffd17 	ldw	r2,-12(fp)
 90a7bd8:	00c243b4 	movhi	r3,2318
 90a7bdc:	18f5e604 	addi	r3,r3,-10344
 90a7be0:	1085883a 	add	r2,r2,r2
 90a7be4:	1085883a 	add	r2,r2,r2
 90a7be8:	10c5883a 	add	r2,r2,r3
 90a7bec:	10800017 	ldw	r2,0(r2)
 90a7bf0:	10c00a17 	ldw	r3,40(r2)
 90a7bf4:	e0bffb17 	ldw	r2,-20(fp)
 90a7bf8:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 90a7bfc:	e0bffd17 	ldw	r2,-12(fp)
 90a7c00:	00c243b4 	movhi	r3,2318
 90a7c04:	18f60c04 	addi	r3,r3,-10192
 90a7c08:	10800f24 	muli	r2,r2,60
 90a7c0c:	10c5883a 	add	r2,r2,r3
 90a7c10:	10800017 	ldw	r2,0(r2)
 90a7c14:	10800120 	cmpeqi	r2,r2,4
 90a7c18:	1000081e 	bne	r2,zero,90a7c3c <dhc_request+0x7ec>
 90a7c1c:	e0bffd17 	ldw	r2,-12(fp)
 90a7c20:	00c243b4 	movhi	r3,2318
 90a7c24:	18f60c04 	addi	r3,r3,-10192
 90a7c28:	10800f24 	muli	r2,r2,60
 90a7c2c:	10c5883a 	add	r2,r2,r3
 90a7c30:	10800017 	ldw	r2,0(r2)
 90a7c34:	10800158 	cmpnei	r2,r2,5
 90a7c38:	10004e1e 	bne	r2,zero,90a7d74 <dhc_request+0x924>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 90a7c3c:	e0bffd17 	ldw	r2,-12(fp)
 90a7c40:	00c243b4 	movhi	r3,2318
 90a7c44:	18f60c04 	addi	r3,r3,-10192
 90a7c48:	10800f24 	muli	r2,r2,60
 90a7c4c:	10c5883a 	add	r2,r2,r3
 90a7c50:	10800d04 	addi	r2,r2,52
 90a7c54:	10800017 	ldw	r2,0(r2)
 90a7c58:	1004d63a 	srli	r2,r2,24
 90a7c5c:	11003fcc 	andi	r4,r2,255
 90a7c60:	e0bffd17 	ldw	r2,-12(fp)
 90a7c64:	00c243b4 	movhi	r3,2318
 90a7c68:	18f60c04 	addi	r3,r3,-10192
 90a7c6c:	10800f24 	muli	r2,r2,60
 90a7c70:	10c5883a 	add	r2,r2,r3
 90a7c74:	10800d04 	addi	r2,r2,52
 90a7c78:	10800017 	ldw	r2,0(r2)
 90a7c7c:	1004d23a 	srli	r2,r2,8
 90a7c80:	10bfc00c 	andi	r2,r2,65280
 90a7c84:	2088b03a 	or	r4,r4,r2
 90a7c88:	e0bffd17 	ldw	r2,-12(fp)
 90a7c8c:	00c243b4 	movhi	r3,2318
 90a7c90:	18f60c04 	addi	r3,r3,-10192
 90a7c94:	10800f24 	muli	r2,r2,60
 90a7c98:	10c5883a 	add	r2,r2,r3
 90a7c9c:	10800d04 	addi	r2,r2,52
 90a7ca0:	10800017 	ldw	r2,0(r2)
 90a7ca4:	10bfc00c 	andi	r2,r2,65280
 90a7ca8:	1004923a 	slli	r2,r2,8
 90a7cac:	2088b03a 	or	r4,r4,r2
 90a7cb0:	e0bffd17 	ldw	r2,-12(fp)
 90a7cb4:	00c243b4 	movhi	r3,2318
 90a7cb8:	18f60c04 	addi	r3,r3,-10192
 90a7cbc:	10800f24 	muli	r2,r2,60
 90a7cc0:	10c5883a 	add	r2,r2,r3
 90a7cc4:	10800d04 	addi	r2,r2,52
 90a7cc8:	10800017 	ldw	r2,0(r2)
 90a7ccc:	10803fcc 	andi	r2,r2,255
 90a7cd0:	1004963a 	slli	r2,r2,24
 90a7cd4:	2084b03a 	or	r2,r4,r2
 90a7cd8:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 90a7cdc:	e0fff917 	ldw	r3,-28(fp)
 90a7ce0:	00800d84 	movi	r2,54
 90a7ce4:	18800005 	stb	r2,0(r3)
 90a7ce8:	e0bff917 	ldw	r2,-28(fp)
 90a7cec:	10800044 	addi	r2,r2,1
 90a7cf0:	e0bff915 	stw	r2,-28(fp)
 90a7cf4:	e0fff917 	ldw	r3,-28(fp)
 90a7cf8:	00800104 	movi	r2,4
 90a7cfc:	18800005 	stb	r2,0(r3)
 90a7d00:	e0bff917 	ldw	r2,-28(fp)
 90a7d04:	10800044 	addi	r2,r2,1
 90a7d08:	e0bff915 	stw	r2,-28(fp)
 90a7d0c:	e0bff917 	ldw	r2,-28(fp)
 90a7d10:	10c000c4 	addi	r3,r2,3
 90a7d14:	e0bffc04 	addi	r2,fp,-16
 90a7d18:	10800003 	ldbu	r2,0(r2)
 90a7d1c:	18800005 	stb	r2,0(r3)
 90a7d20:	e0bff917 	ldw	r2,-28(fp)
 90a7d24:	10c00084 	addi	r3,r2,2
 90a7d28:	e0bffc04 	addi	r2,fp,-16
 90a7d2c:	10800044 	addi	r2,r2,1
 90a7d30:	10800003 	ldbu	r2,0(r2)
 90a7d34:	18800005 	stb	r2,0(r3)
 90a7d38:	e0bff917 	ldw	r2,-28(fp)
 90a7d3c:	10c00044 	addi	r3,r2,1
 90a7d40:	e0bffc04 	addi	r2,fp,-16
 90a7d44:	10800084 	addi	r2,r2,2
 90a7d48:	10800003 	ldbu	r2,0(r2)
 90a7d4c:	18800005 	stb	r2,0(r3)
 90a7d50:	e0bffc04 	addi	r2,fp,-16
 90a7d54:	108000c4 	addi	r2,r2,3
 90a7d58:	10800003 	ldbu	r2,0(r2)
 90a7d5c:	1007883a 	mov	r3,r2
 90a7d60:	e0bff917 	ldw	r2,-28(fp)
 90a7d64:	10c00005 	stb	r3,0(r2)
 90a7d68:	e0bff917 	ldw	r2,-28(fp)
 90a7d6c:	10800104 	addi	r2,r2,4
 90a7d70:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 90a7d74:	e0fff917 	ldw	r3,-28(fp)
 90a7d78:	00801444 	movi	r2,81
 90a7d7c:	18800005 	stb	r2,0(r3)
 90a7d80:	e0bff917 	ldw	r2,-28(fp)
 90a7d84:	10800044 	addi	r2,r2,1
 90a7d88:	e0bff915 	stw	r2,-28(fp)
 90a7d8c:	00800184 	movi	r2,6
 90a7d90:	e0bff615 	stw	r2,-40(fp)
 90a7d94:	e0bff617 	ldw	r2,-40(fp)
 90a7d98:	1007883a 	mov	r3,r2
 90a7d9c:	e0bff917 	ldw	r2,-28(fp)
 90a7da0:	10c00005 	stb	r3,0(r2)
 90a7da4:	e0bff917 	ldw	r2,-28(fp)
 90a7da8:	10800044 	addi	r2,r2,1
 90a7dac:	e0bff915 	stw	r2,-28(fp)
 90a7db0:	e13ff917 	ldw	r4,-28(fp)
 90a7db4:	e1bff617 	ldw	r6,-40(fp)
 90a7db8:	01424374 	movhi	r5,2317
 90a7dbc:	2940e304 	addi	r5,r5,908
 90a7dc0:	90cb6440 	call	90cb644 <strncpy>
 90a7dc4:	e0bff617 	ldw	r2,-40(fp)
 90a7dc8:	1007883a 	mov	r3,r2
 90a7dcc:	e0bff917 	ldw	r2,-28(fp)
 90a7dd0:	10c5883a 	add	r2,r2,r3
 90a7dd4:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 90a7dd8:	e0fff917 	ldw	r3,-28(fp)
 90a7ddc:	00800f04 	movi	r2,60
 90a7de0:	18800005 	stb	r2,0(r3)
 90a7de4:	e0bff917 	ldw	r2,-28(fp)
 90a7de8:	10800044 	addi	r2,r2,1
 90a7dec:	e0bff915 	stw	r2,-28(fp)
 90a7df0:	00824374 	movhi	r2,2317
 90a7df4:	108ed004 	addi	r2,r2,15168
 90a7df8:	11000017 	ldw	r4,0(r2)
 90a7dfc:	9083f540 	call	9083f54 <strlen>
 90a7e00:	e0bff515 	stw	r2,-44(fp)
 90a7e04:	e0bff517 	ldw	r2,-44(fp)
 90a7e08:	1007883a 	mov	r3,r2
 90a7e0c:	e0bff917 	ldw	r2,-28(fp)
 90a7e10:	10c00005 	stb	r3,0(r2)
 90a7e14:	e0bff917 	ldw	r2,-28(fp)
 90a7e18:	10800044 	addi	r2,r2,1
 90a7e1c:	e0bff915 	stw	r2,-28(fp)
 90a7e20:	e13ff917 	ldw	r4,-28(fp)
 90a7e24:	00824374 	movhi	r2,2317
 90a7e28:	108ed004 	addi	r2,r2,15168
 90a7e2c:	11400017 	ldw	r5,0(r2)
 90a7e30:	e1bff517 	ldw	r6,-44(fp)
 90a7e34:	90cb6440 	call	90cb644 <strncpy>
 90a7e38:	e0bff517 	ldw	r2,-44(fp)
 90a7e3c:	1007883a 	mov	r3,r2
 90a7e40:	e0bff917 	ldw	r2,-28(fp)
 90a7e44:	10c5883a 	add	r2,r2,r3
 90a7e48:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 90a7e4c:	e0fff917 	ldw	r3,-28(fp)
 90a7e50:	00bfffc4 	movi	r2,-1
 90a7e54:	18800005 	stb	r2,0(r3)
 90a7e58:	e0bff917 	ldw	r2,-28(fp)
 90a7e5c:	10800044 	addi	r2,r2,1
 90a7e60:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 90a7e64:	e0bffd17 	ldw	r2,-12(fp)
 90a7e68:	00c243b4 	movhi	r3,2318
 90a7e6c:	18f60c04 	addi	r3,r3,-10192
 90a7e70:	10800f24 	muli	r2,r2,60
 90a7e74:	10c5883a 	add	r2,r2,r3
 90a7e78:	10800017 	ldw	r2,0(r2)
 90a7e7c:	108001d8 	cmpnei	r2,r2,7
 90a7e80:	10000a1e 	bne	r2,zero,90a7eac <dhc_request+0xa5c>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 90a7e84:	e0bffd17 	ldw	r2,-12(fp)
 90a7e88:	00c243b4 	movhi	r3,2318
 90a7e8c:	18f60c04 	addi	r3,r3,-10192
 90a7e90:	10800f24 	muli	r2,r2,60
 90a7e94:	10c5883a 	add	r2,r2,r3
 90a7e98:	10800d04 	addi	r2,r2,52
 90a7e9c:	10c00017 	ldw	r3,0(r2)
 90a7ea0:	e0bffa17 	ldw	r2,-24(fp)
 90a7ea4:	10c00715 	stw	r3,28(r2)
 90a7ea8:	00000306 	br	90a7eb8 <dhc_request+0xa68>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 90a7eac:	e0fffa17 	ldw	r3,-24(fp)
 90a7eb0:	00bfffc4 	movi	r2,-1
 90a7eb4:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 90a7eb8:	e0bffd17 	ldw	r2,-12(fp)
 90a7ebc:	00c243b4 	movhi	r3,2318
 90a7ec0:	18f5e604 	addi	r3,r3,-10344
 90a7ec4:	1085883a 	add	r2,r2,r2
 90a7ec8:	1085883a 	add	r2,r2,r2
 90a7ecc:	10c5883a 	add	r2,r2,r3
 90a7ed0:	10c00017 	ldw	r3,0(r2)
 90a7ed4:	e0bffa17 	ldw	r2,-24(fp)
 90a7ed8:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 90a7edc:	e0fff917 	ldw	r3,-28(fp)
 90a7ee0:	e0bffb17 	ldw	r2,-20(fp)
 90a7ee4:	1885c83a 	sub	r2,r3,r2
 90a7ee8:	1007883a 	mov	r3,r2
 90a7eec:	e0bffa17 	ldw	r2,-24(fp)
 90a7ef0:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a7ef4:	010010c4 	movi	r4,67
 90a7ef8:	01401104 	movi	r5,68
 90a7efc:	e1bffa17 	ldw	r6,-24(fp)
 90a7f00:	90c45f80 	call	90c45f8 <udp_send>
   dsc_requests++;
 90a7f04:	d0a09417 	ldw	r2,-32176(gp)
 90a7f08:	10800044 	addi	r2,r2,1
 90a7f0c:	d0a09415 	stw	r2,-32176(gp)

   dhc_states[iface].last_tick = cticks;
 90a7f10:	e13ffd17 	ldw	r4,-12(fp)
 90a7f14:	00824374 	movhi	r2,2317
 90a7f18:	108f2e04 	addi	r2,r2,15544
 90a7f1c:	11400017 	ldw	r5,0(r2)
 90a7f20:	00c243b4 	movhi	r3,2318
 90a7f24:	18f60c04 	addi	r3,r3,-10192
 90a7f28:	20800f24 	muli	r2,r4,60
 90a7f2c:	10c5883a 	add	r2,r2,r3
 90a7f30:	10800404 	addi	r2,r2,16
 90a7f34:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 90a7f38:	e17ffd17 	ldw	r5,-12(fp)
 90a7f3c:	00c243b4 	movhi	r3,2318
 90a7f40:	18f60c04 	addi	r3,r3,-10192
 90a7f44:	28800f24 	muli	r2,r5,60
 90a7f48:	10c5883a 	add	r2,r2,r3
 90a7f4c:	10800104 	addi	r2,r2,4
 90a7f50:	10800017 	ldw	r2,0(r2)
 90a7f54:	11000044 	addi	r4,r2,1
 90a7f58:	00c243b4 	movhi	r3,2318
 90a7f5c:	18f60c04 	addi	r3,r3,-10192
 90a7f60:	28800f24 	muli	r2,r5,60
 90a7f64:	10c5883a 	add	r2,r2,r3
 90a7f68:	10800104 	addi	r2,r2,4
 90a7f6c:	11000015 	stw	r4,0(r2)

   return 0;   /* return OK code */
 90a7f70:	e03fff15 	stw	zero,-4(fp)
 90a7f74:	e0bfff17 	ldw	r2,-4(fp)
}
 90a7f78:	e037883a 	mov	sp,fp
 90a7f7c:	dfc00117 	ldw	ra,4(sp)
 90a7f80:	df000017 	ldw	fp,0(sp)
 90a7f84:	dec00204 	addi	sp,sp,8
 90a7f88:	f800283a 	ret

090a7f8c <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 90a7f8c:	defffd04 	addi	sp,sp,-12
 90a7f90:	dfc00215 	stw	ra,8(sp)
 90a7f94:	df000115 	stw	fp,4(sp)
 90a7f98:	df000104 	addi	fp,sp,4
 90a7f9c:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 90a7fa0:	e0bfff17 	ldw	r2,-4(fp)
 90a7fa4:	00c243b4 	movhi	r3,2318
 90a7fa8:	18f5e604 	addi	r3,r3,-10344
 90a7fac:	1085883a 	add	r2,r2,r2
 90a7fb0:	1085883a 	add	r2,r2,r2
 90a7fb4:	10c5883a 	add	r2,r2,r3
 90a7fb8:	11000017 	ldw	r4,0(r2)
 90a7fbc:	e0bfff17 	ldw	r2,-4(fp)
 90a7fc0:	00c243b4 	movhi	r3,2318
 90a7fc4:	18f60c04 	addi	r3,r3,-10192
 90a7fc8:	10800f24 	muli	r2,r2,60
 90a7fcc:	10c5883a 	add	r2,r2,r3
 90a7fd0:	10800904 	addi	r2,r2,36
 90a7fd4:	10800017 	ldw	r2,0(r2)
 90a7fd8:	20800a15 	stw	r2,40(r4)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 90a7fdc:	e0bfff17 	ldw	r2,-4(fp)
 90a7fe0:	00c243b4 	movhi	r3,2318
 90a7fe4:	18f5e604 	addi	r3,r3,-10344
 90a7fe8:	1085883a 	add	r2,r2,r2
 90a7fec:	1085883a 	add	r2,r2,r2
 90a7ff0:	10c5883a 	add	r2,r2,r3
 90a7ff4:	11000017 	ldw	r4,0(r2)
 90a7ff8:	e0bfff17 	ldw	r2,-4(fp)
 90a7ffc:	00c243b4 	movhi	r3,2318
 90a8000:	18f60c04 	addi	r3,r3,-10192
 90a8004:	10800f24 	muli	r2,r2,60
 90a8008:	10c5883a 	add	r2,r2,r3
 90a800c:	10800a04 	addi	r2,r2,40
 90a8010:	10800017 	ldw	r2,0(r2)
 90a8014:	20800c15 	stw	r2,48(r4)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 90a8018:	e0bfff17 	ldw	r2,-4(fp)
 90a801c:	00c243b4 	movhi	r3,2318
 90a8020:	18f5e604 	addi	r3,r3,-10344
 90a8024:	1085883a 	add	r2,r2,r2
 90a8028:	1085883a 	add	r2,r2,r2
 90a802c:	10c5883a 	add	r2,r2,r3
 90a8030:	11000017 	ldw	r4,0(r2)
 90a8034:	e0bfff17 	ldw	r2,-4(fp)
 90a8038:	00c243b4 	movhi	r3,2318
 90a803c:	18f60c04 	addi	r3,r3,-10192
 90a8040:	10800f24 	muli	r2,r2,60
 90a8044:	10c5883a 	add	r2,r2,r3
 90a8048:	10800b04 	addi	r2,r2,44
 90a804c:	10800017 	ldw	r2,0(r2)
 90a8050:	20800d15 	stw	r2,52(r4)

   if ( nets[iface]->snmask == 0 )
 90a8054:	e0bfff17 	ldw	r2,-4(fp)
 90a8058:	00c243b4 	movhi	r3,2318
 90a805c:	18f5e604 	addi	r3,r3,-10344
 90a8060:	1085883a 	add	r2,r2,r2
 90a8064:	1085883a 	add	r2,r2,r2
 90a8068:	10c5883a 	add	r2,r2,r3
 90a806c:	10800017 	ldw	r2,0(r2)
 90a8070:	10800c17 	ldw	r2,48(r2)
 90a8074:	1004c03a 	cmpne	r2,r2,zero
 90a8078:	1000111e 	bne	r2,zero,90a80c0 <dhc_setip+0x134>
   {
      fixup_subnet_mask(iface);
 90a807c:	e13fff17 	ldw	r4,-4(fp)
 90a8080:	90a24580 	call	90a2458 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 90a8084:	e17fff17 	ldw	r5,-4(fp)
 90a8088:	e0bfff17 	ldw	r2,-4(fp)
 90a808c:	00c243b4 	movhi	r3,2318
 90a8090:	18f5e604 	addi	r3,r3,-10344
 90a8094:	1085883a 	add	r2,r2,r2
 90a8098:	1085883a 	add	r2,r2,r2
 90a809c:	10c5883a 	add	r2,r2,r3
 90a80a0:	10800017 	ldw	r2,0(r2)
 90a80a4:	11000c17 	ldw	r4,48(r2)
 90a80a8:	00c243b4 	movhi	r3,2318
 90a80ac:	18f60c04 	addi	r3,r3,-10192
 90a80b0:	28800f24 	muli	r2,r5,60
 90a80b4:	10c5883a 	add	r2,r2,r3
 90a80b8:	10800a04 	addi	r2,r2,40
 90a80bc:	11000015 	stw	r4,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 90a80c0:	e0bfff17 	ldw	r2,-4(fp)
 90a80c4:	00c243b4 	movhi	r3,2318
 90a80c8:	18f5e604 	addi	r3,r3,-10344
 90a80cc:	1085883a 	add	r2,r2,r2
 90a80d0:	1085883a 	add	r2,r2,r2
 90a80d4:	10c5883a 	add	r2,r2,r3
 90a80d8:	11400017 	ldw	r5,0(r2)
 90a80dc:	e0bfff17 	ldw	r2,-4(fp)
 90a80e0:	00c243b4 	movhi	r3,2318
 90a80e4:	18f5e604 	addi	r3,r3,-10344
 90a80e8:	1085883a 	add	r2,r2,r2
 90a80ec:	1085883a 	add	r2,r2,r2
 90a80f0:	10c5883a 	add	r2,r2,r3
 90a80f4:	10800017 	ldw	r2,0(r2)
 90a80f8:	11000a17 	ldw	r4,40(r2)
 90a80fc:	e0bfff17 	ldw	r2,-4(fp)
 90a8100:	00c243b4 	movhi	r3,2318
 90a8104:	18f5e604 	addi	r3,r3,-10344
 90a8108:	1085883a 	add	r2,r2,r2
 90a810c:	1085883a 	add	r2,r2,r2
 90a8110:	10c5883a 	add	r2,r2,r3
 90a8114:	10800017 	ldw	r2,0(r2)
 90a8118:	10800c17 	ldw	r2,48(r2)
 90a811c:	0084303a 	nor	r2,zero,r2
 90a8120:	2084b03a 	or	r2,r4,r2
 90a8124:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 90a8128:	e0bfff17 	ldw	r2,-4(fp)
 90a812c:	00c243b4 	movhi	r3,2318
 90a8130:	18f5e604 	addi	r3,r3,-10344
 90a8134:	1085883a 	add	r2,r2,r2
 90a8138:	1085883a 	add	r2,r2,r2
 90a813c:	10c5883a 	add	r2,r2,r3
 90a8140:	11400017 	ldw	r5,0(r2)
 90a8144:	e0bfff17 	ldw	r2,-4(fp)
 90a8148:	00c243b4 	movhi	r3,2318
 90a814c:	18f5e604 	addi	r3,r3,-10344
 90a8150:	1085883a 	add	r2,r2,r2
 90a8154:	1085883a 	add	r2,r2,r2
 90a8158:	10c5883a 	add	r2,r2,r3
 90a815c:	10800017 	ldw	r2,0(r2)
 90a8160:	11000a17 	ldw	r4,40(r2)
 90a8164:	e0bfff17 	ldw	r2,-4(fp)
 90a8168:	00c243b4 	movhi	r3,2318
 90a816c:	18f5e604 	addi	r3,r3,-10344
 90a8170:	1085883a 	add	r2,r2,r2
 90a8174:	1085883a 	add	r2,r2,r2
 90a8178:	10c5883a 	add	r2,r2,r3
 90a817c:	10800017 	ldw	r2,0(r2)
 90a8180:	10800c17 	ldw	r2,48(r2)
 90a8184:	2084703a 	and	r2,r4,r2
 90a8188:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 90a818c:	e0bfff17 	ldw	r2,-4(fp)
 90a8190:	00c243b4 	movhi	r3,2318
 90a8194:	18f5e604 	addi	r3,r3,-10344
 90a8198:	1085883a 	add	r2,r2,r2
 90a819c:	1085883a 	add	r2,r2,r2
 90a81a0:	10c5883a 	add	r2,r2,r3
 90a81a4:	11400017 	ldw	r5,0(r2)
 90a81a8:	e0bfff17 	ldw	r2,-4(fp)
 90a81ac:	00c243b4 	movhi	r3,2318
 90a81b0:	18f5e604 	addi	r3,r3,-10344
 90a81b4:	1085883a 	add	r2,r2,r2
 90a81b8:	1085883a 	add	r2,r2,r2
 90a81bc:	10c5883a 	add	r2,r2,r3
 90a81c0:	10800017 	ldw	r2,0(r2)
 90a81c4:	11000a17 	ldw	r4,40(r2)
 90a81c8:	e0bfff17 	ldw	r2,-4(fp)
 90a81cc:	00c243b4 	movhi	r3,2318
 90a81d0:	18f5e604 	addi	r3,r3,-10344
 90a81d4:	1085883a 	add	r2,r2,r2
 90a81d8:	1085883a 	add	r2,r2,r2
 90a81dc:	10c5883a 	add	r2,r2,r3
 90a81e0:	10800017 	ldw	r2,0(r2)
 90a81e4:	10800c17 	ldw	r2,48(r2)
 90a81e8:	0084303a 	nor	r2,zero,r2
 90a81ec:	2084b03a 	or	r2,r4,r2
 90a81f0:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 90a81f4:	0005883a 	mov	r2,zero
}
 90a81f8:	e037883a 	mov	sp,fp
 90a81fc:	dfc00117 	ldw	ra,4(sp)
 90a8200:	df000017 	ldw	fp,0(sp)
 90a8204:	dec00204 	addi	sp,sp,8
 90a8208:	f800283a 	ret

090a820c <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 90a820c:	defffe04 	addi	sp,sp,-8
 90a8210:	df000115 	stw	fp,4(sp)
 90a8214:	df000104 	addi	fp,sp,4
 90a8218:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 90a821c:	e0bfff17 	ldw	r2,-4(fp)
 90a8220:	00c243b4 	movhi	r3,2318
 90a8224:	18f5e604 	addi	r3,r3,-10344
 90a8228:	1085883a 	add	r2,r2,r2
 90a822c:	1085883a 	add	r2,r2,r2
 90a8230:	10c5883a 	add	r2,r2,r3
 90a8234:	10800017 	ldw	r2,0(r2)
 90a8238:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 90a823c:	e0bfff17 	ldw	r2,-4(fp)
 90a8240:	00c243b4 	movhi	r3,2318
 90a8244:	18f5e604 	addi	r3,r3,-10344
 90a8248:	1085883a 	add	r2,r2,r2
 90a824c:	1085883a 	add	r2,r2,r2
 90a8250:	10c5883a 	add	r2,r2,r3
 90a8254:	10800017 	ldw	r2,0(r2)
 90a8258:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 90a825c:	e0bfff17 	ldw	r2,-4(fp)
 90a8260:	00c243b4 	movhi	r3,2318
 90a8264:	18f5e604 	addi	r3,r3,-10344
 90a8268:	1085883a 	add	r2,r2,r2
 90a826c:	1085883a 	add	r2,r2,r2
 90a8270:	10c5883a 	add	r2,r2,r3
 90a8274:	10800017 	ldw	r2,0(r2)
 90a8278:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 90a827c:	e0bfff17 	ldw	r2,-4(fp)
 90a8280:	00c243b4 	movhi	r3,2318
 90a8284:	18f5e604 	addi	r3,r3,-10344
 90a8288:	1085883a 	add	r2,r2,r2
 90a828c:	1085883a 	add	r2,r2,r2
 90a8290:	10c5883a 	add	r2,r2,r3
 90a8294:	10800017 	ldw	r2,0(r2)
 90a8298:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 90a829c:	e0bfff17 	ldw	r2,-4(fp)
 90a82a0:	00c243b4 	movhi	r3,2318
 90a82a4:	18f5e604 	addi	r3,r3,-10344
 90a82a8:	1085883a 	add	r2,r2,r2
 90a82ac:	1085883a 	add	r2,r2,r2
 90a82b0:	10c5883a 	add	r2,r2,r3
 90a82b4:	10800017 	ldw	r2,0(r2)
 90a82b8:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 90a82bc:	e0bfff17 	ldw	r2,-4(fp)
 90a82c0:	00c243b4 	movhi	r3,2318
 90a82c4:	18f5e604 	addi	r3,r3,-10344
 90a82c8:	1085883a 	add	r2,r2,r2
 90a82cc:	1085883a 	add	r2,r2,r2
 90a82d0:	10c5883a 	add	r2,r2,r3
 90a82d4:	10800017 	ldw	r2,0(r2)
 90a82d8:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 90a82dc:	0005883a 	mov	r2,zero
}
 90a82e0:	e037883a 	mov	sp,fp
 90a82e4:	df000017 	ldw	fp,0(sp)
 90a82e8:	dec00104 	addi	sp,sp,4
 90a82ec:	f800283a 	ret

090a82f0 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 90a82f0:	defff704 	addi	sp,sp,-36
 90a82f4:	dfc00815 	stw	ra,32(sp)
 90a82f8:	df000715 	stw	fp,28(sp)
 90a82fc:	df000704 	addi	fp,sp,28
 90a8300:	e13ffc15 	stw	r4,-16(fp)
 90a8304:	e17ffd15 	stw	r5,-12(fp)
 90a8308:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 90a830c:	e13ffe17 	ldw	r4,-8(fp)
 90a8310:	000b883a 	mov	r5,zero
 90a8314:	90c4ab00 	call	90c4ab0 <udp_alloc>
 90a8318:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 90a831c:	e0bffa17 	ldw	r2,-24(fp)
 90a8320:	1004c03a 	cmpne	r2,r2,zero
 90a8324:	1000031e 	bne	r2,zero,90a8334 <dhc_decline+0x44>
      return ENP_NOMEM;
 90a8328:	00bffb04 	movi	r2,-20
 90a832c:	e0bfff15 	stw	r2,-4(fp)
 90a8330:	00002f06 	br	90a83f0 <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 90a8334:	e0fffa17 	ldw	r3,-24(fp)
 90a8338:	e0bffe17 	ldw	r2,-8(fp)
 90a833c:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 90a8340:	e0bffa17 	ldw	r2,-24(fp)
 90a8344:	10800317 	ldw	r2,12(r2)
 90a8348:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 90a834c:	e0bffb17 	ldw	r2,-20(fp)
 90a8350:	e0fffd17 	ldw	r3,-12(fp)
 90a8354:	1009883a 	mov	r4,r2
 90a8358:	180b883a 	mov	r5,r3
 90a835c:	e1bffe17 	ldw	r6,-8(fp)
 90a8360:	90894600 	call	9089460 <memcpy>
   outbp->op = BOOTREQUEST;
 90a8364:	e0fffb17 	ldw	r3,-20(fp)
 90a8368:	00800044 	movi	r2,1
 90a836c:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 90a8370:	e0bffb17 	ldw	r2,-20(fp)
 90a8374:	10803b04 	addi	r2,r2,236
 90a8378:	11400104 	addi	r5,r2,4
 90a837c:	01000d44 	movi	r4,53
 90a8380:	90a94d80 	call	90a94d8 <find_opt>
 90a8384:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 90a8388:	e0bff917 	ldw	r2,-28(fp)
 90a838c:	10800084 	addi	r2,r2,2
 90a8390:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 90a8394:	e0fff917 	ldw	r3,-28(fp)
 90a8398:	00800104 	movi	r2,4
 90a839c:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 90a83a0:	e0fffa17 	ldw	r3,-24(fp)
 90a83a4:	00bfffc4 	movi	r2,-1
 90a83a8:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 90a83ac:	e0bffc17 	ldw	r2,-16(fp)
 90a83b0:	00c243b4 	movhi	r3,2318
 90a83b4:	18f5e604 	addi	r3,r3,-10344
 90a83b8:	1085883a 	add	r2,r2,r2
 90a83bc:	1085883a 	add	r2,r2,r2
 90a83c0:	10c5883a 	add	r2,r2,r3
 90a83c4:	10c00017 	ldw	r3,0(r2)
 90a83c8:	e0bffa17 	ldw	r2,-24(fp)
 90a83cc:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 90a83d0:	010010c4 	movi	r4,67
 90a83d4:	01401104 	movi	r5,68
 90a83d8:	e1bffa17 	ldw	r6,-24(fp)
 90a83dc:	90c45f80 	call	90c45f8 <udp_send>
   dsc_declines++;   /* count declines sent */
 90a83e0:	d0a09717 	ldw	r2,-32164(gp)
 90a83e4:	10800044 	addi	r2,r2,1
 90a83e8:	d0a09715 	stw	r2,-32164(gp)
   return 0;
 90a83ec:	e03fff15 	stw	zero,-4(fp)
 90a83f0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a83f4:	e037883a 	mov	sp,fp
 90a83f8:	dfc00117 	ldw	ra,4(sp)
 90a83fc:	df000017 	ldw	fp,0(sp)
 90a8400:	dec00204 	addi	sp,sp,8
 90a8404:	f800283a 	ret

090a8408 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 90a8408:	defffc04 	addi	sp,sp,-16
 90a840c:	df000315 	stw	fp,12(sp)
 90a8410:	df000304 	addi	fp,sp,12
 90a8414:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 90a8418:	e0bffe04 	addi	r2,fp,-8
 90a841c:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 90a8420:	e0bfff17 	ldw	r2,-4(fp)
 90a8424:	10c00003 	ldbu	r3,0(r2)
 90a8428:	e0bffd17 	ldw	r2,-12(fp)
 90a842c:	10c00005 	stb	r3,0(r2)
 90a8430:	e0bffd17 	ldw	r2,-12(fp)
 90a8434:	10800044 	addi	r2,r2,1
 90a8438:	e0bffd15 	stw	r2,-12(fp)
 90a843c:	e0bfff17 	ldw	r2,-4(fp)
 90a8440:	10800044 	addi	r2,r2,1
 90a8444:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a8448:	e0bfff17 	ldw	r2,-4(fp)
 90a844c:	10c00003 	ldbu	r3,0(r2)
 90a8450:	e0bffd17 	ldw	r2,-12(fp)
 90a8454:	10c00005 	stb	r3,0(r2)
 90a8458:	e0bffd17 	ldw	r2,-12(fp)
 90a845c:	10800044 	addi	r2,r2,1
 90a8460:	e0bffd15 	stw	r2,-12(fp)
 90a8464:	e0bfff17 	ldw	r2,-4(fp)
 90a8468:	10800044 	addi	r2,r2,1
 90a846c:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a8470:	e0bfff17 	ldw	r2,-4(fp)
 90a8474:	10c00003 	ldbu	r3,0(r2)
 90a8478:	e0bffd17 	ldw	r2,-12(fp)
 90a847c:	10c00005 	stb	r3,0(r2)
 90a8480:	e0bffd17 	ldw	r2,-12(fp)
 90a8484:	10800044 	addi	r2,r2,1
 90a8488:	e0bffd15 	stw	r2,-12(fp)
 90a848c:	e0bfff17 	ldw	r2,-4(fp)
 90a8490:	10800044 	addi	r2,r2,1
 90a8494:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 90a8498:	e0bfff17 	ldw	r2,-4(fp)
 90a849c:	10c00003 	ldbu	r3,0(r2)
 90a84a0:	e0bffd17 	ldw	r2,-12(fp)
 90a84a4:	10c00005 	stb	r3,0(r2)
 90a84a8:	e0bffd17 	ldw	r2,-12(fp)
 90a84ac:	10800044 	addi	r2,r2,1
 90a84b0:	e0bffd15 	stw	r2,-12(fp)
 90a84b4:	e0bfff17 	ldw	r2,-4(fp)
 90a84b8:	10800044 	addi	r2,r2,1
 90a84bc:	e0bfff15 	stw	r2,-4(fp)

   return v;
 90a84c0:	e0bffe17 	ldw	r2,-8(fp)
}
 90a84c4:	e037883a 	mov	sp,fp
 90a84c8:	df000017 	ldw	fp,0(sp)
 90a84cc:	dec00104 	addi	sp,sp,4
 90a84d0:	f800283a 	ret

090a84d4 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 90a84d4:	defff604 	addi	sp,sp,-40
 90a84d8:	dfc00915 	stw	ra,36(sp)
 90a84dc:	df000815 	stw	fp,32(sp)
 90a84e0:	dc400715 	stw	r17,28(sp)
 90a84e4:	dc000615 	stw	r16,24(sp)
 90a84e8:	df000604 	addi	fp,sp,24
 90a84ec:	e13ffc15 	stw	r4,-16(fp)
 90a84f0:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 90a84f4:	e0bffd17 	ldw	r2,-12(fp)
 90a84f8:	10804e04 	addi	r2,r2,312
 90a84fc:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 90a8500:	e0bffc17 	ldw	r2,-16(fp)
 90a8504:	00c243b4 	movhi	r3,2318
 90a8508:	18f60c04 	addi	r3,r3,-10192
 90a850c:	10800f24 	muli	r2,r2,60
 90a8510:	10c5883a 	add	r2,r2,r3
 90a8514:	10800a04 	addi	r2,r2,40
 90a8518:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 90a851c:	e0bffc17 	ldw	r2,-16(fp)
 90a8520:	00c243b4 	movhi	r3,2318
 90a8524:	18f60c04 	addi	r3,r3,-10192
 90a8528:	10800f24 	muli	r2,r2,60
 90a852c:	10c5883a 	add	r2,r2,r3
 90a8530:	10800b04 	addi	r2,r2,44
 90a8534:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 90a8538:	e0bffc17 	ldw	r2,-16(fp)
 90a853c:	00c243b4 	movhi	r3,2318
 90a8540:	18f60c04 	addi	r3,r3,-10192
 90a8544:	10800f24 	muli	r2,r2,60
 90a8548:	10c5883a 	add	r2,r2,r3
 90a854c:	10800504 	addi	r2,r2,20
 90a8550:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 90a8554:	00008006 	br	90a8758 <dhc_extract_opts+0x284>
   {
      switch (*opts++)
 90a8558:	e0bffd17 	ldw	r2,-12(fp)
 90a855c:	10800003 	ldbu	r2,0(r2)
 90a8560:	10803fcc 	andi	r2,r2,255
 90a8564:	e0bfff15 	stw	r2,-4(fp)
 90a8568:	e0bffd17 	ldw	r2,-12(fp)
 90a856c:	10800044 	addi	r2,r2,1
 90a8570:	e0bffd15 	stw	r2,-12(fp)
 90a8574:	e0ffff17 	ldw	r3,-4(fp)
 90a8578:	188000e0 	cmpeqi	r2,r3,3
 90a857c:	1000271e 	bne	r2,zero,90a861c <dhc_extract_opts+0x148>
 90a8580:	e0ffff17 	ldw	r3,-4(fp)
 90a8584:	18800108 	cmpgei	r2,r3,4
 90a8588:	1000071e 	bne	r2,zero,90a85a8 <dhc_extract_opts+0xd4>
 90a858c:	e0ffff17 	ldw	r3,-4(fp)
 90a8590:	1805003a 	cmpeq	r2,r3,zero
 90a8594:	1000701e 	bne	r2,zero,90a8758 <dhc_extract_opts+0x284>
 90a8598:	e0ffff17 	ldw	r3,-4(fp)
 90a859c:	18800060 	cmpeqi	r2,r3,1
 90a85a0:	10000d1e 	bne	r2,zero,90a85d8 <dhc_extract_opts+0x104>
 90a85a4:	00006406 	br	90a8738 <dhc_extract_opts+0x264>
 90a85a8:	e0ffff17 	ldw	r3,-4(fp)
 90a85ac:	18800ce0 	cmpeqi	r2,r3,51
 90a85b0:	1000331e 	bne	r2,zero,90a8680 <dhc_extract_opts+0x1ac>
 90a85b4:	e0ffff17 	ldw	r3,-4(fp)
 90a85b8:	18803fe0 	cmpeqi	r2,r3,255
 90a85bc:	1000041e 	bne	r2,zero,90a85d0 <dhc_extract_opts+0xfc>
 90a85c0:	e0ffff17 	ldw	r3,-4(fp)
 90a85c4:	188001a0 	cmpeqi	r2,r3,6
 90a85c8:	10004f1e 	bne	r2,zero,90a8708 <dhc_extract_opts+0x234>
 90a85cc:	00005a06 	br	90a8738 <dhc_extract_opts+0x264>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 90a85d0:	e03ffe15 	stw	zero,-8(fp)
 90a85d4:	00006606 	br	90a8770 <dhc_extract_opts+0x29c>
      case DHOP_SNMASK:
         opts++;
 90a85d8:	e0bffd17 	ldw	r2,-12(fp)
 90a85dc:	10800044 	addi	r2,r2,1
 90a85e0:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 90a85e4:	e43ffc17 	ldw	r16,-16(fp)
 90a85e8:	e13ffd17 	ldw	r4,-12(fp)
 90a85ec:	90a84080 	call	90a8408 <dh_getlong>
 90a85f0:	1009883a 	mov	r4,r2
 90a85f4:	00c243b4 	movhi	r3,2318
 90a85f8:	18f60c04 	addi	r3,r3,-10192
 90a85fc:	80800f24 	muli	r2,r16,60
 90a8600:	10c5883a 	add	r2,r2,r3
 90a8604:	10800a04 	addi	r2,r2,40
 90a8608:	11000015 	stw	r4,0(r2)
         opts += 4;
 90a860c:	e0bffd17 	ldw	r2,-12(fp)
 90a8610:	10800104 	addi	r2,r2,4
 90a8614:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a8618:	00004f06 	br	90a8758 <dhc_extract_opts+0x284>
      case DHOP_ROUTER:
         optlen = *opts++;
 90a861c:	e0bffd17 	ldw	r2,-12(fp)
 90a8620:	10800003 	ldbu	r2,0(r2)
 90a8624:	e0bffa05 	stb	r2,-24(fp)
 90a8628:	e0bffd17 	ldw	r2,-12(fp)
 90a862c:	10800044 	addi	r2,r2,1
 90a8630:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 90a8634:	e0bffa03 	ldbu	r2,-24(fp)
 90a8638:	10800130 	cmpltui	r2,r2,4
 90a863c:	10000a1e 	bne	r2,zero,90a8668 <dhc_extract_opts+0x194>
            dhc_states[iface].defgw = dh_getlong(opts);
 90a8640:	e43ffc17 	ldw	r16,-16(fp)
 90a8644:	e13ffd17 	ldw	r4,-12(fp)
 90a8648:	90a84080 	call	90a8408 <dh_getlong>
 90a864c:	1009883a 	mov	r4,r2
 90a8650:	00c243b4 	movhi	r3,2318
 90a8654:	18f60c04 	addi	r3,r3,-10192
 90a8658:	80800f24 	muli	r2,r16,60
 90a865c:	10c5883a 	add	r2,r2,r3
 90a8660:	10800b04 	addi	r2,r2,44
 90a8664:	11000015 	stw	r4,0(r2)
         opts += optlen;
 90a8668:	e0bffa03 	ldbu	r2,-24(fp)
 90a866c:	1007883a 	mov	r3,r2
 90a8670:	e0bffd17 	ldw	r2,-12(fp)
 90a8674:	10c5883a 	add	r2,r2,r3
 90a8678:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a867c:	00003606 	br	90a8758 <dhc_extract_opts+0x284>
      case DHOP_LEASE:
         opts++;
 90a8680:	e0bffd17 	ldw	r2,-12(fp)
 90a8684:	10800044 	addi	r2,r2,1
 90a8688:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 90a868c:	e47ffc17 	ldw	r17,-16(fp)
 90a8690:	e13ffd17 	ldw	r4,-12(fp)
 90a8694:	90a84080 	call	90a8408 <dh_getlong>
 90a8698:	1005d63a 	srai	r2,r2,24
 90a869c:	14003fcc 	andi	r16,r2,255
 90a86a0:	e13ffd17 	ldw	r4,-12(fp)
 90a86a4:	90a84080 	call	90a8408 <dh_getlong>
 90a86a8:	1005d23a 	srai	r2,r2,8
 90a86ac:	10bfc00c 	andi	r2,r2,65280
 90a86b0:	80a0b03a 	or	r16,r16,r2
 90a86b4:	e13ffd17 	ldw	r4,-12(fp)
 90a86b8:	90a84080 	call	90a8408 <dh_getlong>
 90a86bc:	10bfc00c 	andi	r2,r2,65280
 90a86c0:	1004923a 	slli	r2,r2,8
 90a86c4:	80a0b03a 	or	r16,r16,r2
 90a86c8:	e13ffd17 	ldw	r4,-12(fp)
 90a86cc:	90a84080 	call	90a8408 <dh_getlong>
 90a86d0:	10803fcc 	andi	r2,r2,255
 90a86d4:	1004963a 	slli	r2,r2,24
 90a86d8:	8084b03a 	or	r2,r16,r2
 90a86dc:	1009883a 	mov	r4,r2
 90a86e0:	00c243b4 	movhi	r3,2318
 90a86e4:	18f60c04 	addi	r3,r3,-10192
 90a86e8:	88800f24 	muli	r2,r17,60
 90a86ec:	10c5883a 	add	r2,r2,r3
 90a86f0:	10800504 	addi	r2,r2,20
 90a86f4:	11000015 	stw	r4,0(r2)
         opts += 4;
 90a86f8:	e0bffd17 	ldw	r2,-12(fp)
 90a86fc:	10800104 	addi	r2,r2,4
 90a8700:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a8704:	00001406 	br	90a8758 <dhc_extract_opts+0x284>
      case DHOP_DNSRV:
         optlen = *opts++;
 90a8708:	e0bffd17 	ldw	r2,-12(fp)
 90a870c:	10800003 	ldbu	r2,0(r2)
 90a8710:	e0bffa05 	stb	r2,-24(fp)
 90a8714:	e0bffd17 	ldw	r2,-12(fp)
 90a8718:	10800044 	addi	r2,r2,1
 90a871c:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 90a8720:	e0bffa03 	ldbu	r2,-24(fp)
 90a8724:	1007883a 	mov	r3,r2
 90a8728:	e0bffd17 	ldw	r2,-12(fp)
 90a872c:	10c5883a 	add	r2,r2,r3
 90a8730:	e0bffd15 	stw	r2,-12(fp)
         break;
 90a8734:	00000806 	br	90a8758 <dhc_extract_opts+0x284>
      default:
         opts += ((*opts) + 1);
 90a8738:	e0bffd17 	ldw	r2,-12(fp)
 90a873c:	10800003 	ldbu	r2,0(r2)
 90a8740:	10803fcc 	andi	r2,r2,255
 90a8744:	1007883a 	mov	r3,r2
 90a8748:	e0bffd17 	ldw	r2,-12(fp)
 90a874c:	1885883a 	add	r2,r3,r2
 90a8750:	10800044 	addi	r2,r2,1
 90a8754:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 90a8758:	e0fffd17 	ldw	r3,-12(fp)
 90a875c:	e0bffb17 	ldw	r2,-20(fp)
 90a8760:	10ff7d2e 	bgeu	r2,r3,90a8558 <dhc_extract_opts+0x84>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 90a8764:	90aa4780 	call	90aa478 <dtrap>
   return -1;
 90a8768:	00bfffc4 	movi	r2,-1
 90a876c:	e0bffe15 	stw	r2,-8(fp)
 90a8770:	e0bffe17 	ldw	r2,-8(fp)
}
 90a8774:	e037883a 	mov	sp,fp
 90a8778:	dfc00317 	ldw	ra,12(sp)
 90a877c:	df000217 	ldw	fp,8(sp)
 90a8780:	dc400117 	ldw	r17,4(sp)
 90a8784:	dc000017 	ldw	r16,0(sp)
 90a8788:	dec00404 	addi	sp,sp,16
 90a878c:	f800283a 	ret

090a8790 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 90a8790:	defff504 	addi	sp,sp,-44
 90a8794:	dfc00a15 	stw	ra,40(sp)
 90a8798:	df000915 	stw	fp,36(sp)
 90a879c:	dc400815 	stw	r17,32(sp)
 90a87a0:	dc000715 	stw	r16,28(sp)
 90a87a4:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 90a87a8:	e03ffc15 	stw	zero,-16(fp)
 90a87ac:	00022306 	br	90a903c <dhc_second+0x8ac>
   {
      switch (dhc_states[iface].state)
 90a87b0:	e0bffc17 	ldw	r2,-16(fp)
 90a87b4:	00c243b4 	movhi	r3,2318
 90a87b8:	18f60c04 	addi	r3,r3,-10192
 90a87bc:	10800f24 	muli	r2,r2,60
 90a87c0:	10c5883a 	add	r2,r2,r3
 90a87c4:	10800017 	ldw	r2,0(r2)
 90a87c8:	e0bfff15 	stw	r2,-4(fp)
 90a87cc:	e0ffff17 	ldw	r3,-4(fp)
 90a87d0:	18800268 	cmpgeui	r2,r3,9
 90a87d4:	1002161e 	bne	r2,zero,90a9030 <dhc_second+0x8a0>
 90a87d8:	e13fff17 	ldw	r4,-4(fp)
 90a87dc:	e13fff17 	ldw	r4,-4(fp)
 90a87e0:	2105883a 	add	r2,r4,r4
 90a87e4:	1087883a 	add	r3,r2,r2
 90a87e8:	008242f4 	movhi	r2,2315
 90a87ec:	10a1ff04 	addi	r2,r2,-30724
 90a87f0:	1885883a 	add	r2,r3,r2
 90a87f4:	10800017 	ldw	r2,0(r2)
 90a87f8:	1000683a 	jmp	r2
 90a87fc:	090a9030 	cmpltui	r4,at,10816
 90a8800:	090a8820 	cmpeqi	r4,at,10784
 90a8804:	090a8858 	cmpnei	r4,at,10785
 90a8808:	090a8890 	cmplti	r4,at,10786
 90a880c:	090a8890 	cmplti	r4,at,10786
 90a8810:	090a8890 	cmplti	r4,at,10786
 90a8814:	090a8c4c 	andi	r4,at,10801
 90a8818:	090a8d84 	addi	r4,at,10806
 90a881c:	090a89c0 	call	90a89c <OSCtxSw_SWITCH_PC+0x90a85c>
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 90a8820:	e13ffc17 	ldw	r4,-16(fp)
 90a8824:	90a6e1c0 	call	90a6e1c <dhc_discover>
 90a8828:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 90a882c:	e0bffa17 	ldw	r2,-24(fp)
 90a8830:	1005003a 	cmpeq	r2,r2,zero
 90a8834:	1000041e 	bne	r2,zero,90a8848 <dhc_second+0xb8>
         {
            dtrap();
 90a8838:	90aa4780 	call	90aa478 <dtrap>
            return e;
 90a883c:	e0bffa17 	ldw	r2,-24(fp)
 90a8840:	e0bffe15 	stw	r2,-8(fp)
 90a8844:	00020106 	br	90a904c <dhc_second+0x8bc>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 90a8848:	e13ffc17 	ldw	r4,-16(fp)
 90a884c:	01400104 	movi	r5,4
 90a8850:	90a94280 	call	90a9428 <dhc_set_state>
         break;
 90a8854:	0001f606 	br	90a9030 <dhc_second+0x8a0>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 90a8858:	e13ffc17 	ldw	r4,-16(fp)
 90a885c:	90a90f40 	call	90a90f4 <dhc_reclaim>
 90a8860:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 90a8864:	e0bffa17 	ldw	r2,-24(fp)
 90a8868:	1005003a 	cmpeq	r2,r2,zero
 90a886c:	1000041e 	bne	r2,zero,90a8880 <dhc_second+0xf0>
         {
            dtrap();
 90a8870:	90aa4780 	call	90aa478 <dtrap>
            return e;
 90a8874:	e0fffa17 	ldw	r3,-24(fp)
 90a8878:	e0fffe15 	stw	r3,-8(fp)
 90a887c:	0001f306 	br	90a904c <dhc_second+0x8bc>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 90a8880:	e13ffc17 	ldw	r4,-16(fp)
 90a8884:	014000c4 	movi	r5,3
 90a8888:	90a94280 	call	90a9428 <dhc_set_state>
         break;
 90a888c:	0001e806 	br	90a9030 <dhc_second+0x8a0>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 90a8890:	e0bffc17 	ldw	r2,-16(fp)
 90a8894:	00c243b4 	movhi	r3,2318
 90a8898:	18f60c04 	addi	r3,r3,-10192
 90a889c:	10800f24 	muli	r2,r2,60
 90a88a0:	10c5883a 	add	r2,r2,r3
 90a88a4:	10800104 	addi	r2,r2,4
 90a88a8:	10800017 	ldw	r2,0(r2)
 90a88ac:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 90a88b0:	e0bffb17 	ldw	r2,-20(fp)
 90a88b4:	10800110 	cmplti	r2,r2,4
 90a88b8:	1000021e 	bne	r2,zero,90a88c4 <dhc_second+0x134>
            tries= DHC_MAX_TRIES;
 90a88bc:	00800104 	movi	r2,4
 90a88c0:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 90a88c4:	e0bffc17 	ldw	r2,-16(fp)
 90a88c8:	00c243b4 	movhi	r3,2318
 90a88cc:	18f60c04 	addi	r3,r3,-10192
 90a88d0:	10800f24 	muli	r2,r2,60
 90a88d4:	10c5883a 	add	r2,r2,r3
 90a88d8:	10800404 	addi	r2,r2,16
 90a88dc:	11000017 	ldw	r4,0(r2)
 90a88e0:	00c06404 	movi	r3,400
 90a88e4:	e0bffb17 	ldw	r2,-20(fp)
 90a88e8:	1884983a 	sll	r2,r3,r2
 90a88ec:	2087883a 	add	r3,r4,r2
 90a88f0:	00824374 	movhi	r2,2317
 90a88f4:	108f2e04 	addi	r2,r2,15544
 90a88f8:	10800017 	ldw	r2,0(r2)
 90a88fc:	18801c2e 	bgeu	r3,r2,90a8970 <dhc_second+0x1e0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 90a8900:	e0bffc17 	ldw	r2,-16(fp)
 90a8904:	00c243b4 	movhi	r3,2318
 90a8908:	18f60c04 	addi	r3,r3,-10192
 90a890c:	10800f24 	muli	r2,r2,60
 90a8910:	10c5883a 	add	r2,r2,r3
 90a8914:	10800017 	ldw	r2,0(r2)
 90a8918:	e0bffd15 	stw	r2,-12(fp)
 90a891c:	e13ffd17 	ldw	r4,-12(fp)
 90a8920:	20800120 	cmpeqi	r2,r4,4
 90a8924:	1000071e 	bne	r2,zero,90a8944 <dhc_second+0x1b4>
 90a8928:	e0fffd17 	ldw	r3,-12(fp)
 90a892c:	18800160 	cmpeqi	r2,r3,5
 90a8930:	1000071e 	bne	r2,zero,90a8950 <dhc_second+0x1c0>
 90a8934:	e13ffd17 	ldw	r4,-12(fp)
 90a8938:	208000e0 	cmpeqi	r2,r4,3
 90a893c:	1000081e 	bne	r2,zero,90a8960 <dhc_second+0x1d0>
 90a8940:	00000a06 	br	90a896c <dhc_second+0x1dc>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 90a8944:	e13ffc17 	ldw	r4,-16(fp)
 90a8948:	90a6e1c0 	call	90a6e1c <dhc_discover>
               break;
 90a894c:	00000806 	br	90a8970 <dhc_second+0x1e0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 90a8950:	e13ffc17 	ldw	r4,-16(fp)
 90a8954:	000b883a 	mov	r5,zero
 90a8958:	90a74500 	call	90a7450 <dhc_request>
               break;
 90a895c:	00000406 	br	90a8970 <dhc_second+0x1e0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 90a8960:	e13ffc17 	ldw	r4,-16(fp)
 90a8964:	90a90f40 	call	90a90f4 <dhc_reclaim>
               break;
 90a8968:	00000106 	br	90a8970 <dhc_second+0x1e0>
            default:
               dtrap(); /* bogus state */
 90a896c:	90aa4780 	call	90aa478 <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 90a8970:	e0bffb17 	ldw	r2,-20(fp)
 90a8974:	10800118 	cmpnei	r2,r2,4
 90a8978:	1001ad1e 	bne	r2,zero,90a9030 <dhc_second+0x8a0>
 90a897c:	e0bffc17 	ldw	r2,-16(fp)
 90a8980:	00c243b4 	movhi	r3,2318
 90a8984:	18f60c04 	addi	r3,r3,-10192
 90a8988:	10800f24 	muli	r2,r2,60
 90a898c:	10c5883a 	add	r2,r2,r3
 90a8990:	10800017 	ldw	r2,0(r2)
 90a8994:	10800120 	cmpeqi	r2,r2,4
 90a8998:	1001a51e 	bne	r2,zero,90a9030 <dhc_second+0x8a0>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 90a899c:	e13ffc17 	ldw	r4,-16(fp)
 90a89a0:	01400244 	movi	r5,9
 90a89a4:	90a94280 	call	90a9428 <dhc_set_state>
            dhc_resetip(iface);
 90a89a8:	e13ffc17 	ldw	r4,-16(fp)
 90a89ac:	90a820c0 	call	90a820c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 90a89b0:	e13ffc17 	ldw	r4,-16(fp)
 90a89b4:	01400044 	movi	r5,1
 90a89b8:	90a94280 	call	90a9428 <dhc_set_state>
         }
         break;
 90a89bc:	00019c06 	br	90a9030 <dhc_second+0x8a0>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 90a89c0:	e0bffc17 	ldw	r2,-16(fp)
 90a89c4:	00c243b4 	movhi	r3,2318
 90a89c8:	18f60c04 	addi	r3,r3,-10192
 90a89cc:	10800f24 	muli	r2,r2,60
 90a89d0:	10c5883a 	add	r2,r2,r3
 90a89d4:	10800504 	addi	r2,r2,20
 90a89d8:	11000017 	ldw	r4,0(r2)
 90a89dc:	908d0380 	call	908d038 <__floatunsidf>
 90a89e0:	100b883a 	mov	r5,r2
 90a89e4:	180d883a 	mov	r6,r3
 90a89e8:	2809883a 	mov	r4,r5
 90a89ec:	300b883a 	mov	r5,r6
 90a89f0:	000d883a 	mov	r6,zero
 90a89f4:	01d01674 	movhi	r7,16473
 90a89f8:	908c5b40 	call	908c5b4 <__muldf3>
 90a89fc:	1009883a 	mov	r4,r2
 90a8a00:	180b883a 	mov	r5,r3
 90a8a04:	2021883a 	mov	r16,r4
 90a8a08:	2823883a 	mov	r17,r5
 90a8a0c:	e0bffc17 	ldw	r2,-16(fp)
 90a8a10:	00c243b4 	movhi	r3,2318
 90a8a14:	18f60c04 	addi	r3,r3,-10192
 90a8a18:	10800f24 	muli	r2,r2,60
 90a8a1c:	10c5883a 	add	r2,r2,r3
 90a8a20:	10800804 	addi	r2,r2,32
 90a8a24:	11000017 	ldw	r4,0(r2)
 90a8a28:	908d0380 	call	908d038 <__floatunsidf>
 90a8a2c:	100f883a 	mov	r7,r2
 90a8a30:	1811883a 	mov	r8,r3
 90a8a34:	8009883a 	mov	r4,r16
 90a8a38:	880b883a 	mov	r5,r17
 90a8a3c:	380d883a 	mov	r6,r7
 90a8a40:	400f883a 	mov	r7,r8
 90a8a44:	908c5400 	call	908c540 <__adddf3>
 90a8a48:	1009883a 	mov	r4,r2
 90a8a4c:	180b883a 	mov	r5,r3
 90a8a50:	2021883a 	mov	r16,r4
 90a8a54:	2823883a 	mov	r17,r5
 90a8a58:	00824374 	movhi	r2,2317
 90a8a5c:	108f2e04 	addi	r2,r2,15544
 90a8a60:	11000017 	ldw	r4,0(r2)
 90a8a64:	908d0380 	call	908d038 <__floatunsidf>
 90a8a68:	100f883a 	mov	r7,r2
 90a8a6c:	1811883a 	mov	r8,r3
 90a8a70:	8009883a 	mov	r4,r16
 90a8a74:	880b883a 	mov	r5,r17
 90a8a78:	380d883a 	mov	r6,r7
 90a8a7c:	400f883a 	mov	r7,r8
 90a8a80:	908ccd00 	call	908ccd0 <__gtdf2>
 90a8a84:	10800048 	cmpgei	r2,r2,1
 90a8a88:	1000011e 	bne	r2,zero,90a8a90 <dhc_second+0x300>
 90a8a8c:	00006606 	br	90a8c28 <dhc_second+0x498>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 90a8a90:	e0bffc17 	ldw	r2,-16(fp)
 90a8a94:	00c243b4 	movhi	r3,2318
 90a8a98:	18f60c04 	addi	r3,r3,-10192
 90a8a9c:	10800f24 	muli	r2,r2,60
 90a8aa0:	10c5883a 	add	r2,r2,r3
 90a8aa4:	10800804 	addi	r2,r2,32
 90a8aa8:	11000017 	ldw	r4,0(r2)
 90a8aac:	908d0380 	call	908d038 <__floatunsidf>
 90a8ab0:	1021883a 	mov	r16,r2
 90a8ab4:	1823883a 	mov	r17,r3
 90a8ab8:	e0bffc17 	ldw	r2,-16(fp)
 90a8abc:	00c243b4 	movhi	r3,2318
 90a8ac0:	18f60c04 	addi	r3,r3,-10192
 90a8ac4:	10800f24 	muli	r2,r2,60
 90a8ac8:	10c5883a 	add	r2,r2,r3
 90a8acc:	10800504 	addi	r2,r2,20
 90a8ad0:	11000017 	ldw	r4,0(r2)
 90a8ad4:	908d0380 	call	908d038 <__floatunsidf>
 90a8ad8:	100b883a 	mov	r5,r2
 90a8adc:	180d883a 	mov	r6,r3
 90a8ae0:	2809883a 	mov	r4,r5
 90a8ae4:	300b883a 	mov	r5,r6
 90a8ae8:	000d883a 	mov	r6,zero
 90a8aec:	01d01674 	movhi	r7,16473
 90a8af0:	908c5b40 	call	908c5b4 <__muldf3>
 90a8af4:	1009883a 	mov	r4,r2
 90a8af8:	180b883a 	mov	r5,r3
 90a8afc:	2005883a 	mov	r2,r4
 90a8b00:	2807883a 	mov	r3,r5
 90a8b04:	8009883a 	mov	r4,r16
 90a8b08:	880b883a 	mov	r5,r17
 90a8b0c:	100d883a 	mov	r6,r2
 90a8b10:	180f883a 	mov	r7,r3
 90a8b14:	908c5400 	call	908c540 <__adddf3>
 90a8b18:	1009883a 	mov	r4,r2
 90a8b1c:	180b883a 	mov	r5,r3
 90a8b20:	2021883a 	mov	r16,r4
 90a8b24:	2823883a 	mov	r17,r5
 90a8b28:	e0bffc17 	ldw	r2,-16(fp)
 90a8b2c:	00c243b4 	movhi	r3,2318
 90a8b30:	18f60c04 	addi	r3,r3,-10192
 90a8b34:	10800f24 	muli	r2,r2,60
 90a8b38:	10c5883a 	add	r2,r2,r3
 90a8b3c:	10800404 	addi	r2,r2,16
 90a8b40:	11000017 	ldw	r4,0(r2)
 90a8b44:	908d0380 	call	908d038 <__floatunsidf>
 90a8b48:	100f883a 	mov	r7,r2
 90a8b4c:	1811883a 	mov	r8,r3
 90a8b50:	8009883a 	mov	r4,r16
 90a8b54:	880b883a 	mov	r5,r17
 90a8b58:	380d883a 	mov	r6,r7
 90a8b5c:	400f883a 	mov	r7,r8
 90a8b60:	908c4c00 	call	908c4c0 <__subdf3>
 90a8b64:	1009883a 	mov	r4,r2
 90a8b68:	180b883a 	mov	r5,r3
 90a8b6c:	2005883a 	mov	r2,r4
 90a8b70:	2807883a 	mov	r3,r5
 90a8b74:	1009883a 	mov	r4,r2
 90a8b78:	180b883a 	mov	r5,r3
 90a8b7c:	000d883a 	mov	r6,zero
 90a8b80:	01d00034 	movhi	r7,16384
 90a8b84:	908c9680 	call	908c968 <__divdf3>
 90a8b88:	1009883a 	mov	r4,r2
 90a8b8c:	180b883a 	mov	r5,r3
 90a8b90:	2005883a 	mov	r2,r4
 90a8b94:	2807883a 	mov	r3,r5
 90a8b98:	1009883a 	mov	r4,r2
 90a8b9c:	180b883a 	mov	r5,r3
 90a8ba0:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90a8ba4:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 90a8ba8:	e13ff917 	ldw	r4,-28(fp)
 90a8bac:	908d0380 	call	908d038 <__floatunsidf>
 90a8bb0:	100b883a 	mov	r5,r2
 90a8bb4:	180d883a 	mov	r6,r3
 90a8bb8:	2809883a 	mov	r4,r5
 90a8bbc:	300b883a 	mov	r5,r6
 90a8bc0:	000d883a 	mov	r6,zero
 90a8bc4:	01d02df4 	movhi	r7,16567
 90a8bc8:	39dc0004 	addi	r7,r7,28672
 90a8bcc:	908cde00 	call	908cde0 <__ltdf2>
 90a8bd0:	1004803a 	cmplt	r2,r2,zero
 90a8bd4:	1000011e 	bne	r2,zero,90a8bdc <dhc_second+0x44c>
 90a8bd8:	00000206 	br	90a8be4 <dhc_second+0x454>
               half_time = 60*TPS;
 90a8bdc:	0085dc04 	movi	r2,6000
 90a8be0:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 90a8be4:	e0bffc17 	ldw	r2,-16(fp)
 90a8be8:	00c243b4 	movhi	r3,2318
 90a8bec:	18f60c04 	addi	r3,r3,-10192
 90a8bf0:	10800f24 	muli	r2,r2,60
 90a8bf4:	10c5883a 	add	r2,r2,r3
 90a8bf8:	10800404 	addi	r2,r2,16
 90a8bfc:	10c00017 	ldw	r3,0(r2)
 90a8c00:	e0bff917 	ldw	r2,-28(fp)
 90a8c04:	1887883a 	add	r3,r3,r2
 90a8c08:	00824374 	movhi	r2,2317
 90a8c0c:	108f2e04 	addi	r2,r2,15544
 90a8c10:	10800017 	ldw	r2,0(r2)
 90a8c14:	1881062e 	bgeu	r3,r2,90a9030 <dhc_second+0x8a0>
            {
               dhc_request(iface,FALSE);
 90a8c18:	e13ffc17 	ldw	r4,-16(fp)
 90a8c1c:	000b883a 	mov	r5,zero
 90a8c20:	90a74500 	call	90a7450 <dhc_request>
 90a8c24:	00010206 	br	90a9030 <dhc_second+0x8a0>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 90a8c28:	e13ffc17 	ldw	r4,-16(fp)
 90a8c2c:	01400244 	movi	r5,9
 90a8c30:	90a94280 	call	90a9428 <dhc_set_state>
            dhc_resetip(iface);
 90a8c34:	e13ffc17 	ldw	r4,-16(fp)
 90a8c38:	90a820c0 	call	90a820c <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 90a8c3c:	e13ffc17 	ldw	r4,-16(fp)
 90a8c40:	01400044 	movi	r5,1
 90a8c44:	90a94280 	call	90a9428 <dhc_set_state>
         }
         break;
 90a8c48:	0000f906 	br	90a9030 <dhc_second+0x8a0>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 90a8c4c:	e0bffc17 	ldw	r2,-16(fp)
 90a8c50:	00c243b4 	movhi	r3,2318
 90a8c54:	18f60c04 	addi	r3,r3,-10192
 90a8c58:	10800f24 	muli	r2,r2,60
 90a8c5c:	10c5883a 	add	r2,r2,r3
 90a8c60:	10800604 	addi	r2,r2,24
 90a8c64:	10800017 	ldw	r2,0(r2)
 90a8c68:	10bfffe0 	cmpeqi	r2,r2,-1
 90a8c6c:	1000f01e 	bne	r2,zero,90a9030 <dhc_second+0x8a0>
 90a8c70:	e0bffc17 	ldw	r2,-16(fp)
 90a8c74:	00c243b4 	movhi	r3,2318
 90a8c78:	18f60c04 	addi	r3,r3,-10192
 90a8c7c:	10800f24 	muli	r2,r2,60
 90a8c80:	10c5883a 	add	r2,r2,r3
 90a8c84:	10800604 	addi	r2,r2,24
 90a8c88:	11000017 	ldw	r4,0(r2)
 90a8c8c:	908d0380 	call	908d038 <__floatunsidf>
 90a8c90:	100b883a 	mov	r5,r2
 90a8c94:	180d883a 	mov	r6,r3
 90a8c98:	2809883a 	mov	r4,r5
 90a8c9c:	300b883a 	mov	r5,r6
 90a8ca0:	000d883a 	mov	r6,zero
 90a8ca4:	01d01674 	movhi	r7,16473
 90a8ca8:	908c5b40 	call	908c5b4 <__muldf3>
 90a8cac:	1009883a 	mov	r4,r2
 90a8cb0:	180b883a 	mov	r5,r3
 90a8cb4:	2021883a 	mov	r16,r4
 90a8cb8:	2823883a 	mov	r17,r5
 90a8cbc:	e0bffc17 	ldw	r2,-16(fp)
 90a8cc0:	00c243b4 	movhi	r3,2318
 90a8cc4:	18f60c04 	addi	r3,r3,-10192
 90a8cc8:	10800f24 	muli	r2,r2,60
 90a8ccc:	10c5883a 	add	r2,r2,r3
 90a8cd0:	10800804 	addi	r2,r2,32
 90a8cd4:	11000017 	ldw	r4,0(r2)
 90a8cd8:	908d0380 	call	908d038 <__floatunsidf>
 90a8cdc:	100f883a 	mov	r7,r2
 90a8ce0:	1811883a 	mov	r8,r3
 90a8ce4:	8009883a 	mov	r4,r16
 90a8ce8:	880b883a 	mov	r5,r17
 90a8cec:	380d883a 	mov	r6,r7
 90a8cf0:	400f883a 	mov	r7,r8
 90a8cf4:	908c5400 	call	908c540 <__adddf3>
 90a8cf8:	1009883a 	mov	r4,r2
 90a8cfc:	180b883a 	mov	r5,r3
 90a8d00:	2021883a 	mov	r16,r4
 90a8d04:	2823883a 	mov	r17,r5
 90a8d08:	00824374 	movhi	r2,2317
 90a8d0c:	108f2e04 	addi	r2,r2,15544
 90a8d10:	11000017 	ldw	r4,0(r2)
 90a8d14:	908d0380 	call	908d038 <__floatunsidf>
 90a8d18:	100f883a 	mov	r7,r2
 90a8d1c:	1811883a 	mov	r8,r3
 90a8d20:	8009883a 	mov	r4,r16
 90a8d24:	880b883a 	mov	r5,r17
 90a8d28:	380d883a 	mov	r6,r7
 90a8d2c:	400f883a 	mov	r7,r8
 90a8d30:	908cde00 	call	908cde0 <__ltdf2>
 90a8d34:	1004803a 	cmplt	r2,r2,zero
 90a8d38:	1000011e 	bne	r2,zero,90a8d40 <dhc_second+0x5b0>
 90a8d3c:	0000bc06 	br	90a9030 <dhc_second+0x8a0>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 90a8d40:	e13ffc17 	ldw	r4,-16(fp)
 90a8d44:	014001c4 	movi	r5,7
 90a8d48:	90a94280 	call	90a9428 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 90a8d4c:	e13ffc17 	ldw	r4,-16(fp)
 90a8d50:	90a90f40 	call	90a90f4 <dhc_reclaim>
 90a8d54:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 90a8d58:	e0bffa17 	ldw	r2,-24(fp)
 90a8d5c:	1005003a 	cmpeq	r2,r2,zero
 90a8d60:	1000041e 	bne	r2,zero,90a8d74 <dhc_second+0x5e4>
            {
               dtrap();
 90a8d64:	90aa4780 	call	90aa478 <dtrap>
               return e;
 90a8d68:	e0bffa17 	ldw	r2,-24(fp)
 90a8d6c:	e0bffe15 	stw	r2,-8(fp)
 90a8d70:	0000b606 	br	90a904c <dhc_second+0x8bc>
            }
            dsc_renew++;
 90a8d74:	d0a09a17 	ldw	r2,-32152(gp)
 90a8d78:	10800044 	addi	r2,r2,1
 90a8d7c:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 90a8d80:	0000ab06 	br	90a9030 <dhc_second+0x8a0>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 90a8d84:	e0bffc17 	ldw	r2,-16(fp)
 90a8d88:	00c243b4 	movhi	r3,2318
 90a8d8c:	18f60c04 	addi	r3,r3,-10192
 90a8d90:	10800f24 	muli	r2,r2,60
 90a8d94:	10c5883a 	add	r2,r2,r3
 90a8d98:	10800704 	addi	r2,r2,28
 90a8d9c:	11000017 	ldw	r4,0(r2)
 90a8da0:	908d0380 	call	908d038 <__floatunsidf>
 90a8da4:	100b883a 	mov	r5,r2
 90a8da8:	180d883a 	mov	r6,r3
 90a8dac:	2809883a 	mov	r4,r5
 90a8db0:	300b883a 	mov	r5,r6
 90a8db4:	000d883a 	mov	r6,zero
 90a8db8:	01d01674 	movhi	r7,16473
 90a8dbc:	908c5b40 	call	908c5b4 <__muldf3>
 90a8dc0:	1009883a 	mov	r4,r2
 90a8dc4:	180b883a 	mov	r5,r3
 90a8dc8:	2021883a 	mov	r16,r4
 90a8dcc:	2823883a 	mov	r17,r5
 90a8dd0:	e0bffc17 	ldw	r2,-16(fp)
 90a8dd4:	00c243b4 	movhi	r3,2318
 90a8dd8:	18f60c04 	addi	r3,r3,-10192
 90a8ddc:	10800f24 	muli	r2,r2,60
 90a8de0:	10c5883a 	add	r2,r2,r3
 90a8de4:	10800804 	addi	r2,r2,32
 90a8de8:	11000017 	ldw	r4,0(r2)
 90a8dec:	908d0380 	call	908d038 <__floatunsidf>
 90a8df0:	100f883a 	mov	r7,r2
 90a8df4:	1811883a 	mov	r8,r3
 90a8df8:	8009883a 	mov	r4,r16
 90a8dfc:	880b883a 	mov	r5,r17
 90a8e00:	380d883a 	mov	r6,r7
 90a8e04:	400f883a 	mov	r7,r8
 90a8e08:	908c5400 	call	908c540 <__adddf3>
 90a8e0c:	1009883a 	mov	r4,r2
 90a8e10:	180b883a 	mov	r5,r3
 90a8e14:	2021883a 	mov	r16,r4
 90a8e18:	2823883a 	mov	r17,r5
 90a8e1c:	00824374 	movhi	r2,2317
 90a8e20:	108f2e04 	addi	r2,r2,15544
 90a8e24:	11000017 	ldw	r4,0(r2)
 90a8e28:	908d0380 	call	908d038 <__floatunsidf>
 90a8e2c:	100f883a 	mov	r7,r2
 90a8e30:	1811883a 	mov	r8,r3
 90a8e34:	8009883a 	mov	r4,r16
 90a8e38:	880b883a 	mov	r5,r17
 90a8e3c:	380d883a 	mov	r6,r7
 90a8e40:	400f883a 	mov	r7,r8
 90a8e44:	908ccd00 	call	908ccd0 <__gtdf2>
 90a8e48:	10800048 	cmpgei	r2,r2,1
 90a8e4c:	1000011e 	bne	r2,zero,90a8e54 <dhc_second+0x6c4>
 90a8e50:	00006606 	br	90a8fec <dhc_second+0x85c>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 90a8e54:	e0bffc17 	ldw	r2,-16(fp)
 90a8e58:	00c243b4 	movhi	r3,2318
 90a8e5c:	18f60c04 	addi	r3,r3,-10192
 90a8e60:	10800f24 	muli	r2,r2,60
 90a8e64:	10c5883a 	add	r2,r2,r3
 90a8e68:	10800804 	addi	r2,r2,32
 90a8e6c:	11000017 	ldw	r4,0(r2)
 90a8e70:	908d0380 	call	908d038 <__floatunsidf>
 90a8e74:	1021883a 	mov	r16,r2
 90a8e78:	1823883a 	mov	r17,r3
 90a8e7c:	e0bffc17 	ldw	r2,-16(fp)
 90a8e80:	00c243b4 	movhi	r3,2318
 90a8e84:	18f60c04 	addi	r3,r3,-10192
 90a8e88:	10800f24 	muli	r2,r2,60
 90a8e8c:	10c5883a 	add	r2,r2,r3
 90a8e90:	10800704 	addi	r2,r2,28
 90a8e94:	11000017 	ldw	r4,0(r2)
 90a8e98:	908d0380 	call	908d038 <__floatunsidf>
 90a8e9c:	100b883a 	mov	r5,r2
 90a8ea0:	180d883a 	mov	r6,r3
 90a8ea4:	2809883a 	mov	r4,r5
 90a8ea8:	300b883a 	mov	r5,r6
 90a8eac:	000d883a 	mov	r6,zero
 90a8eb0:	01d01674 	movhi	r7,16473
 90a8eb4:	908c5b40 	call	908c5b4 <__muldf3>
 90a8eb8:	1009883a 	mov	r4,r2
 90a8ebc:	180b883a 	mov	r5,r3
 90a8ec0:	2005883a 	mov	r2,r4
 90a8ec4:	2807883a 	mov	r3,r5
 90a8ec8:	8009883a 	mov	r4,r16
 90a8ecc:	880b883a 	mov	r5,r17
 90a8ed0:	100d883a 	mov	r6,r2
 90a8ed4:	180f883a 	mov	r7,r3
 90a8ed8:	908c5400 	call	908c540 <__adddf3>
 90a8edc:	1009883a 	mov	r4,r2
 90a8ee0:	180b883a 	mov	r5,r3
 90a8ee4:	2021883a 	mov	r16,r4
 90a8ee8:	2823883a 	mov	r17,r5
 90a8eec:	e0bffc17 	ldw	r2,-16(fp)
 90a8ef0:	00c243b4 	movhi	r3,2318
 90a8ef4:	18f60c04 	addi	r3,r3,-10192
 90a8ef8:	10800f24 	muli	r2,r2,60
 90a8efc:	10c5883a 	add	r2,r2,r3
 90a8f00:	10800404 	addi	r2,r2,16
 90a8f04:	11000017 	ldw	r4,0(r2)
 90a8f08:	908d0380 	call	908d038 <__floatunsidf>
 90a8f0c:	100f883a 	mov	r7,r2
 90a8f10:	1811883a 	mov	r8,r3
 90a8f14:	8009883a 	mov	r4,r16
 90a8f18:	880b883a 	mov	r5,r17
 90a8f1c:	380d883a 	mov	r6,r7
 90a8f20:	400f883a 	mov	r7,r8
 90a8f24:	908c4c00 	call	908c4c0 <__subdf3>
 90a8f28:	1009883a 	mov	r4,r2
 90a8f2c:	180b883a 	mov	r5,r3
 90a8f30:	2005883a 	mov	r2,r4
 90a8f34:	2807883a 	mov	r3,r5
 90a8f38:	1009883a 	mov	r4,r2
 90a8f3c:	180b883a 	mov	r5,r3
 90a8f40:	000d883a 	mov	r6,zero
 90a8f44:	01d00034 	movhi	r7,16384
 90a8f48:	908c9680 	call	908c968 <__divdf3>
 90a8f4c:	1009883a 	mov	r4,r2
 90a8f50:	180b883a 	mov	r5,r3
 90a8f54:	2005883a 	mov	r2,r4
 90a8f58:	2807883a 	mov	r3,r5
 90a8f5c:	1009883a 	mov	r4,r2
 90a8f60:	180b883a 	mov	r5,r3
 90a8f64:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90a8f68:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 90a8f6c:	e13ff917 	ldw	r4,-28(fp)
 90a8f70:	908d0380 	call	908d038 <__floatunsidf>
 90a8f74:	100b883a 	mov	r5,r2
 90a8f78:	180d883a 	mov	r6,r3
 90a8f7c:	2809883a 	mov	r4,r5
 90a8f80:	300b883a 	mov	r5,r6
 90a8f84:	000d883a 	mov	r6,zero
 90a8f88:	01d02df4 	movhi	r7,16567
 90a8f8c:	39dc0004 	addi	r7,r7,28672
 90a8f90:	908cde00 	call	908cde0 <__ltdf2>
 90a8f94:	1004803a 	cmplt	r2,r2,zero
 90a8f98:	1000011e 	bne	r2,zero,90a8fa0 <dhc_second+0x810>
 90a8f9c:	00000206 	br	90a8fa8 <dhc_second+0x818>
               half_time = 60*TPS;
 90a8fa0:	0085dc04 	movi	r2,6000
 90a8fa4:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 90a8fa8:	e0bffc17 	ldw	r2,-16(fp)
 90a8fac:	00c243b4 	movhi	r3,2318
 90a8fb0:	18f60c04 	addi	r3,r3,-10192
 90a8fb4:	10800f24 	muli	r2,r2,60
 90a8fb8:	10c5883a 	add	r2,r2,r3
 90a8fbc:	10800404 	addi	r2,r2,16
 90a8fc0:	10c00017 	ldw	r3,0(r2)
 90a8fc4:	e0bff917 	ldw	r2,-28(fp)
 90a8fc8:	1887883a 	add	r3,r3,r2
 90a8fcc:	00824374 	movhi	r2,2317
 90a8fd0:	108f2e04 	addi	r2,r2,15544
 90a8fd4:	10800017 	ldw	r2,0(r2)
 90a8fd8:	1880152e 	bgeu	r3,r2,90a9030 <dhc_second+0x8a0>
            {
               dhc_request(iface,FALSE);
 90a8fdc:	e13ffc17 	ldw	r4,-16(fp)
 90a8fe0:	000b883a 	mov	r5,zero
 90a8fe4:	90a74500 	call	90a7450 <dhc_request>
 90a8fe8:	00001106 	br	90a9030 <dhc_second+0x8a0>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 90a8fec:	e13ffc17 	ldw	r4,-16(fp)
 90a8ff0:	01400204 	movi	r5,8
 90a8ff4:	90a94280 	call	90a9428 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 90a8ff8:	e13ffc17 	ldw	r4,-16(fp)
 90a8ffc:	01400044 	movi	r5,1
 90a9000:	90a74500 	call	90a7450 <dhc_request>
 90a9004:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 90a9008:	e0bffa17 	ldw	r2,-24(fp)
 90a900c:	1005003a 	cmpeq	r2,r2,zero
 90a9010:	1000041e 	bne	r2,zero,90a9024 <dhc_second+0x894>
            {
               dtrap();
 90a9014:	90aa4780 	call	90aa478 <dtrap>
               return e;
 90a9018:	e0fffa17 	ldw	r3,-24(fp)
 90a901c:	e0fffe15 	stw	r3,-8(fp)
 90a9020:	00000a06 	br	90a904c <dhc_second+0x8bc>
            }
            dsc_rebind++;
 90a9024:	d0a09b17 	ldw	r2,-32148(gp)
 90a9028:	10800044 	addi	r2,r2,1
 90a902c:	d0a09b15 	stw	r2,-32148(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 90a9030:	e0bffc17 	ldw	r2,-16(fp)
 90a9034:	10800044 	addi	r2,r2,1
 90a9038:	e0bffc15 	stw	r2,-16(fp)
 90a903c:	e0bffc17 	ldw	r2,-16(fp)
 90a9040:	10800110 	cmplti	r2,r2,4
 90a9044:	103dda1e 	bne	r2,zero,90a87b0 <dhc_second+0x20>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 90a9048:	e03ffe15 	stw	zero,-8(fp)
 90a904c:	e0bffe17 	ldw	r2,-8(fp)
}
 90a9050:	e037883a 	mov	sp,fp
 90a9054:	dfc00317 	ldw	ra,12(sp)
 90a9058:	df000217 	ldw	fp,8(sp)
 90a905c:	dc400117 	ldw	r17,4(sp)
 90a9060:	dc000017 	ldw	r16,0(sp)
 90a9064:	dec00404 	addi	sp,sp,16
 90a9068:	f800283a 	ret

090a906c <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 90a906c:	defffd04 	addi	sp,sp,-12
 90a9070:	dfc00215 	stw	ra,8(sp)
 90a9074:	df000115 	stw	fp,4(sp)
 90a9078:	df000104 	addi	fp,sp,4
 90a907c:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 90a9080:	e0bfff17 	ldw	r2,-4(fp)
 90a9084:	1004803a 	cmplt	r2,r2,zero
 90a9088:	1000031e 	bne	r2,zero,90a9098 <dhc_halt+0x2c>
 90a908c:	e0bfff17 	ldw	r2,-4(fp)
 90a9090:	10800150 	cmplti	r2,r2,5
 90a9094:	1000021e 	bne	r2,zero,90a90a0 <dhc_halt+0x34>
   {
      dtrap();
 90a9098:	90aa4780 	call	90aa478 <dtrap>
      return;
 90a909c:	00001006 	br	90a90e0 <dhc_halt+0x74>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 90a90a0:	e0bfff17 	ldw	r2,-4(fp)
 90a90a4:	10800f24 	muli	r2,r2,60
 90a90a8:	1007883a 	mov	r3,r2
 90a90ac:	008243b4 	movhi	r2,2318
 90a90b0:	10b60c04 	addi	r2,r2,-10192
 90a90b4:	1885883a 	add	r2,r3,r2
 90a90b8:	1009883a 	mov	r4,r2
 90a90bc:	01800f04 	movi	r6,60
 90a90c0:	000b883a 	mov	r5,zero
 90a90c4:	90832780 	call	9083278 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 90a90c8:	e0bfff17 	ldw	r2,-4(fp)
 90a90cc:	00c243b4 	movhi	r3,2318
 90a90d0:	18f60c04 	addi	r3,r3,-10192
 90a90d4:	10800f24 	muli	r2,r2,60
 90a90d8:	10c5883a 	add	r2,r2,r3
 90a90dc:	10000015 	stw	zero,0(r2)
}
 90a90e0:	e037883a 	mov	sp,fp
 90a90e4:	dfc00117 	ldw	ra,4(sp)
 90a90e8:	df000017 	ldw	fp,0(sp)
 90a90ec:	dec00204 	addi	sp,sp,8
 90a90f0:	f800283a 	ret

090a90f4 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 90a90f4:	defffb04 	addi	sp,sp,-20
 90a90f8:	dfc00415 	stw	ra,16(sp)
 90a90fc:	df000315 	stw	fp,12(sp)
 90a9100:	df000304 	addi	fp,sp,12
 90a9104:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 90a9108:	e0bffe17 	ldw	r2,-8(fp)
 90a910c:	00c243b4 	movhi	r3,2318
 90a9110:	18f5e604 	addi	r3,r3,-10344
 90a9114:	1085883a 	add	r2,r2,r2
 90a9118:	1085883a 	add	r2,r2,r2
 90a911c:	10c5883a 	add	r2,r2,r3
 90a9120:	10800017 	ldw	r2,0(r2)
 90a9124:	10800a17 	ldw	r2,40(r2)
 90a9128:	1004c03a 	cmpne	r2,r2,zero
 90a912c:	1000041e 	bne	r2,zero,90a9140 <dhc_reclaim+0x4c>
   {
      dtrap();    /* programming bug? */
 90a9130:	90aa4780 	call	90aa478 <dtrap>
      return ENP_LOGIC;
 90a9134:	00bffd44 	movi	r2,-11
 90a9138:	e0bfff15 	stw	r2,-4(fp)
 90a913c:	00005b06 	br	90a92ac <dhc_reclaim+0x1b8>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 90a9140:	e17ffe17 	ldw	r5,-8(fp)
 90a9144:	e0bffe17 	ldw	r2,-8(fp)
 90a9148:	00c243b4 	movhi	r3,2318
 90a914c:	18f5e604 	addi	r3,r3,-10344
 90a9150:	1085883a 	add	r2,r2,r2
 90a9154:	1085883a 	add	r2,r2,r2
 90a9158:	10c5883a 	add	r2,r2,r3
 90a915c:	10800017 	ldw	r2,0(r2)
 90a9160:	11000a17 	ldw	r4,40(r2)
 90a9164:	00c243b4 	movhi	r3,2318
 90a9168:	18f60c04 	addi	r3,r3,-10192
 90a916c:	28800f24 	muli	r2,r5,60
 90a9170:	10c5883a 	add	r2,r2,r3
 90a9174:	10800904 	addi	r2,r2,36
 90a9178:	11000015 	stw	r4,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 90a917c:	e17ffe17 	ldw	r5,-8(fp)
 90a9180:	e0bffe17 	ldw	r2,-8(fp)
 90a9184:	00c243b4 	movhi	r3,2318
 90a9188:	18f5e604 	addi	r3,r3,-10344
 90a918c:	1085883a 	add	r2,r2,r2
 90a9190:	1085883a 	add	r2,r2,r2
 90a9194:	10c5883a 	add	r2,r2,r3
 90a9198:	10800017 	ldw	r2,0(r2)
 90a919c:	11000c17 	ldw	r4,48(r2)
 90a91a0:	00c243b4 	movhi	r3,2318
 90a91a4:	18f60c04 	addi	r3,r3,-10192
 90a91a8:	28800f24 	muli	r2,r5,60
 90a91ac:	10c5883a 	add	r2,r2,r3
 90a91b0:	10800a04 	addi	r2,r2,40
 90a91b4:	11000015 	stw	r4,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 90a91b8:	e17ffe17 	ldw	r5,-8(fp)
 90a91bc:	e0bffe17 	ldw	r2,-8(fp)
 90a91c0:	00c243b4 	movhi	r3,2318
 90a91c4:	18f5e604 	addi	r3,r3,-10344
 90a91c8:	1085883a 	add	r2,r2,r2
 90a91cc:	1085883a 	add	r2,r2,r2
 90a91d0:	10c5883a 	add	r2,r2,r3
 90a91d4:	10800017 	ldw	r2,0(r2)
 90a91d8:	11000d17 	ldw	r4,52(r2)
 90a91dc:	00c243b4 	movhi	r3,2318
 90a91e0:	18f60c04 	addi	r3,r3,-10192
 90a91e4:	28800f24 	muli	r2,r5,60
 90a91e8:	10c5883a 	add	r2,r2,r3
 90a91ec:	10800b04 	addi	r2,r2,44
 90a91f0:	11000015 	stw	r4,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 90a91f4:	e0bffe17 	ldw	r2,-8(fp)
 90a91f8:	00c243b4 	movhi	r3,2318
 90a91fc:	18f60c04 	addi	r3,r3,-10192
 90a9200:	10800f24 	muli	r2,r2,60
 90a9204:	10c5883a 	add	r2,r2,r3
 90a9208:	10800c04 	addi	r2,r2,48
 90a920c:	10800017 	ldw	r2,0(r2)
 90a9210:	1005003a 	cmpeq	r2,r2,zero
 90a9214:	1000211e 	bne	r2,zero,90a929c <dhc_reclaim+0x1a8>
   {
      if (dhc_states[iface].srv_ipaddr)
 90a9218:	e0bffe17 	ldw	r2,-8(fp)
 90a921c:	00c243b4 	movhi	r3,2318
 90a9220:	18f60c04 	addi	r3,r3,-10192
 90a9224:	10800f24 	muli	r2,r2,60
 90a9228:	10c5883a 	add	r2,r2,r3
 90a922c:	10800d04 	addi	r2,r2,52
 90a9230:	10800017 	ldw	r2,0(r2)
 90a9234:	1005003a 	cmpeq	r2,r2,zero
 90a9238:	1000171e 	bne	r2,zero,90a9298 <dhc_reclaim+0x1a4>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 90a923c:	e0bffe17 	ldw	r2,-8(fp)
 90a9240:	00c243b4 	movhi	r3,2318
 90a9244:	18f60c04 	addi	r3,r3,-10192
 90a9248:	10800f24 	muli	r2,r2,60
 90a924c:	10c5883a 	add	r2,r2,r3
 90a9250:	10800d04 	addi	r2,r2,52
 90a9254:	11000017 	ldw	r4,0(r2)
 90a9258:	e0bffe17 	ldw	r2,-8(fp)
 90a925c:	00c243b4 	movhi	r3,2318
 90a9260:	18f60c04 	addi	r3,r3,-10192
 90a9264:	10800f24 	muli	r2,r2,60
 90a9268:	10c5883a 	add	r2,r2,r3
 90a926c:	10800c04 	addi	r2,r2,48
 90a9270:	11800017 	ldw	r6,0(r2)
 90a9274:	00800084 	movi	r2,2
 90a9278:	d8800015 	stw	r2,0(sp)
 90a927c:	017fffc4 	movi	r5,-1
 90a9280:	e1fffe17 	ldw	r7,-8(fp)
 90a9284:	90c38340 	call	90c3834 <add_route>
 90a9288:	1004c03a 	cmpne	r2,r2,zero
 90a928c:	1000031e 	bne	r2,zero,90a929c <dhc_reclaim+0x1a8>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 90a9290:	90aa4780 	call	90aa478 <dtrap>
 90a9294:	00000106 	br	90a929c <dhc_reclaim+0x1a8>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 90a9298:	90aa4780 	call	90aa478 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 90a929c:	e13ffe17 	ldw	r4,-8(fp)
 90a92a0:	01400044 	movi	r5,1
 90a92a4:	90a74500 	call	90a7450 <dhc_request>
 90a92a8:	e0bfff15 	stw	r2,-4(fp)
 90a92ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90a92b0:	e037883a 	mov	sp,fp
 90a92b4:	dfc00117 	ldw	ra,4(sp)
 90a92b8:	df000017 	ldw	fp,0(sp)
 90a92bc:	dec00204 	addi	sp,sp,8
 90a92c0:	f800283a 	ret

090a92c4 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 90a92c4:	defffa04 	addi	sp,sp,-24
 90a92c8:	dfc00515 	stw	ra,20(sp)
 90a92cc:	df000415 	stw	fp,16(sp)
 90a92d0:	df000404 	addi	fp,sp,16
 90a92d4:	e13ffd15 	stw	r4,-12(fp)
 90a92d8:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 90a92dc:	e0bffe17 	ldw	r2,-8(fp)
 90a92e0:	10800058 	cmpnei	r2,r2,1
 90a92e4:	1000031e 	bne	r2,zero,90a92f4 <dhc_state_init+0x30>
 90a92e8:	00800044 	movi	r2,1
 90a92ec:	e0bfff15 	stw	r2,-4(fp)
 90a92f0:	00000206 	br	90a92fc <dhc_state_init+0x38>
 90a92f4:	00800084 	movi	r2,2
 90a92f8:	e0bfff15 	stw	r2,-4(fp)
 90a92fc:	e0bfff17 	ldw	r2,-4(fp)
 90a9300:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 90a9304:	e13ffd17 	ldw	r4,-12(fp)
 90a9308:	e17ffc17 	ldw	r5,-16(fp)
 90a930c:	90a94280 	call	90a9428 <dhc_set_state>
}
 90a9310:	e037883a 	mov	sp,fp
 90a9314:	dfc00117 	ldw	ra,4(sp)
 90a9318:	df000017 	ldw	fp,0(sp)
 90a931c:	dec00204 	addi	sp,sp,8
 90a9320:	f800283a 	ret

090a9324 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 90a9324:	defffd04 	addi	sp,sp,-12
 90a9328:	df000215 	stw	fp,8(sp)
 90a932c:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 90a9330:	e03ffe15 	stw	zero,-8(fp)
 90a9334:	00001506 	br	90a938c <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 90a9338:	e0bffe17 	ldw	r2,-8(fp)
 90a933c:	00c243b4 	movhi	r3,2318
 90a9340:	18f60c04 	addi	r3,r3,-10192
 90a9344:	10800f24 	muli	r2,r2,60
 90a9348:	10c5883a 	add	r2,r2,r3
 90a934c:	10800017 	ldw	r2,0(r2)
 90a9350:	1005003a 	cmpeq	r2,r2,zero
 90a9354:	10000a1e 	bne	r2,zero,90a9380 <dhc_alldone+0x5c>
 90a9358:	e0bffe17 	ldw	r2,-8(fp)
 90a935c:	00c243b4 	movhi	r3,2318
 90a9360:	18f60c04 	addi	r3,r3,-10192
 90a9364:	10800f24 	muli	r2,r2,60
 90a9368:	10c5883a 	add	r2,r2,r3
 90a936c:	10800017 	ldw	r2,0(r2)
 90a9370:	108001a0 	cmpeqi	r2,r2,6
 90a9374:	1000021e 	bne	r2,zero,90a9380 <dhc_alldone+0x5c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 90a9378:	e03fff15 	stw	zero,-4(fp)
 90a937c:	00000806 	br	90a93a0 <dhc_alldone+0x7c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 90a9380:	e0bffe17 	ldw	r2,-8(fp)
 90a9384:	10800044 	addi	r2,r2,1
 90a9388:	e0bffe15 	stw	r2,-8(fp)
 90a938c:	e0bffe17 	ldw	r2,-8(fp)
 90a9390:	10800110 	cmplti	r2,r2,4
 90a9394:	103fe81e 	bne	r2,zero,90a9338 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 90a9398:	00800044 	movi	r2,1
 90a939c:	e0bfff15 	stw	r2,-4(fp)
 90a93a0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a93a4:	e037883a 	mov	sp,fp
 90a93a8:	df000017 	ldw	fp,0(sp)
 90a93ac:	dec00104 	addi	sp,sp,4
 90a93b0:	f800283a 	ret

090a93b4 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 90a93b4:	defffd04 	addi	sp,sp,-12
 90a93b8:	df000215 	stw	fp,8(sp)
 90a93bc:	df000204 	addi	fp,sp,8
 90a93c0:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 90a93c4:	e0bffe17 	ldw	r2,-8(fp)
 90a93c8:	00c243b4 	movhi	r3,2318
 90a93cc:	18f60c04 	addi	r3,r3,-10192
 90a93d0:	10800f24 	muli	r2,r2,60
 90a93d4:	10c5883a 	add	r2,r2,r3
 90a93d8:	10800017 	ldw	r2,0(r2)
 90a93dc:	1005003a 	cmpeq	r2,r2,zero
 90a93e0:	1000081e 	bne	r2,zero,90a9404 <dhc_ifacedone+0x50>
 90a93e4:	e0bffe17 	ldw	r2,-8(fp)
 90a93e8:	00c243b4 	movhi	r3,2318
 90a93ec:	18f60c04 	addi	r3,r3,-10192
 90a93f0:	10800f24 	muli	r2,r2,60
 90a93f4:	10c5883a 	add	r2,r2,r3
 90a93f8:	10800017 	ldw	r2,0(r2)
 90a93fc:	10800198 	cmpnei	r2,r2,6
 90a9400:	1000031e 	bne	r2,zero,90a9410 <dhc_ifacedone+0x5c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 90a9404:	00800044 	movi	r2,1
 90a9408:	e0bfff15 	stw	r2,-4(fp)
 90a940c:	00000106 	br	90a9414 <dhc_ifacedone+0x60>
   }
   else
   {
      return FALSE ;
 90a9410:	e03fff15 	stw	zero,-4(fp)
 90a9414:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90a9418:	e037883a 	mov	sp,fp
 90a941c:	df000017 	ldw	fp,0(sp)
 90a9420:	dec00104 	addi	sp,sp,4
 90a9424:	f800283a 	ret

090a9428 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 90a9428:	defffc04 	addi	sp,sp,-16
 90a942c:	dfc00315 	stw	ra,12(sp)
 90a9430:	df000215 	stw	fp,8(sp)
 90a9434:	df000204 	addi	fp,sp,8
 90a9438:	e13ffe15 	stw	r4,-8(fp)
 90a943c:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 90a9440:	e0bffe17 	ldw	r2,-8(fp)
 90a9444:	e13fff17 	ldw	r4,-4(fp)
 90a9448:	00c243b4 	movhi	r3,2318
 90a944c:	18f60c04 	addi	r3,r3,-10192
 90a9450:	10800f24 	muli	r2,r2,60
 90a9454:	10c5883a 	add	r2,r2,r3
 90a9458:	11000015 	stw	r4,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 90a945c:	e0bffe17 	ldw	r2,-8(fp)
 90a9460:	00c243b4 	movhi	r3,2318
 90a9464:	18f60c04 	addi	r3,r3,-10192
 90a9468:	10800f24 	muli	r2,r2,60
 90a946c:	10c5883a 	add	r2,r2,r3
 90a9470:	10800104 	addi	r2,r2,4
 90a9474:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 90a9478:	e0bffe17 	ldw	r2,-8(fp)
 90a947c:	00c243b4 	movhi	r3,2318
 90a9480:	18f60c04 	addi	r3,r3,-10192
 90a9484:	10800f24 	muli	r2,r2,60
 90a9488:	10c5883a 	add	r2,r2,r3
 90a948c:	10800e04 	addi	r2,r2,56
 90a9490:	10800017 	ldw	r2,0(r2)
 90a9494:	1005003a 	cmpeq	r2,r2,zero
 90a9498:	10000a1e 	bne	r2,zero,90a94c4 <dhc_set_state+0x9c>
      dhc_states[iface].callback(iface,state);
 90a949c:	e0bffe17 	ldw	r2,-8(fp)
 90a94a0:	00c243b4 	movhi	r3,2318
 90a94a4:	18f60c04 	addi	r3,r3,-10192
 90a94a8:	10800f24 	muli	r2,r2,60
 90a94ac:	10c5883a 	add	r2,r2,r3
 90a94b0:	10800e04 	addi	r2,r2,56
 90a94b4:	10800017 	ldw	r2,0(r2)
 90a94b8:	e13ffe17 	ldw	r4,-8(fp)
 90a94bc:	e17fff17 	ldw	r5,-4(fp)
 90a94c0:	103ee83a 	callr	r2
}
 90a94c4:	e037883a 	mov	sp,fp
 90a94c8:	dfc00117 	ldw	ra,4(sp)
 90a94cc:	df000017 	ldw	fp,0(sp)
 90a94d0:	dec00204 	addi	sp,sp,8
 90a94d4:	f800283a 	ret

090a94d8 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 90a94d8:	defffb04 	addi	sp,sp,-20
 90a94dc:	df000415 	stw	fp,16(sp)
 90a94e0:	df000404 	addi	fp,sp,16
 90a94e4:	e17ffe15 	stw	r5,-8(fp)
 90a94e8:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 90a94ec:	e0bffe17 	ldw	r2,-8(fp)
 90a94f0:	10804e04 	addi	r2,r2,312
 90a94f4:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 90a94f8:	00002106 	br	90a9580 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 90a94fc:	e0bffe17 	ldw	r2,-8(fp)
 90a9500:	10800003 	ldbu	r2,0(r2)
 90a9504:	10c03fcc 	andi	r3,r2,255
 90a9508:	e0bffd03 	ldbu	r2,-12(fp)
 90a950c:	1880031e 	bne	r3,r2,90a951c <find_opt+0x44>
         return opts;
 90a9510:	e0bffe17 	ldw	r2,-8(fp)
 90a9514:	e0bfff15 	stw	r2,-4(fp)
 90a9518:	00001d06 	br	90a9590 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 90a951c:	e0bffe17 	ldw	r2,-8(fp)
 90a9520:	10800003 	ldbu	r2,0(r2)
 90a9524:	10803fcc 	andi	r2,r2,255
 90a9528:	10803fd8 	cmpnei	r2,r2,255
 90a952c:	1000021e 	bne	r2,zero,90a9538 <find_opt+0x60>
         return NULL;
 90a9530:	e03fff15 	stw	zero,-4(fp)
 90a9534:	00001606 	br	90a9590 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 90a9538:	e0bffe17 	ldw	r2,-8(fp)
 90a953c:	10800003 	ldbu	r2,0(r2)
 90a9540:	10803fcc 	andi	r2,r2,255
 90a9544:	1004c03a 	cmpne	r2,r2,zero
 90a9548:	1000041e 	bne	r2,zero,90a955c <find_opt+0x84>
         opts++;
 90a954c:	e0bffe17 	ldw	r2,-8(fp)
 90a9550:	10800044 	addi	r2,r2,1
 90a9554:	e0bffe15 	stw	r2,-8(fp)
 90a9558:	00000906 	br	90a9580 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 90a955c:	e0bffe17 	ldw	r2,-8(fp)
 90a9560:	10800044 	addi	r2,r2,1
 90a9564:	10800003 	ldbu	r2,0(r2)
 90a9568:	10803fcc 	andi	r2,r2,255
 90a956c:	1007883a 	mov	r3,r2
 90a9570:	e0bffe17 	ldw	r2,-8(fp)
 90a9574:	1885883a 	add	r2,r3,r2
 90a9578:	10800084 	addi	r2,r2,2
 90a957c:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 90a9580:	e0fffe17 	ldw	r3,-8(fp)
 90a9584:	e0bffc17 	ldw	r2,-16(fp)
 90a9588:	18bfdc36 	bltu	r3,r2,90a94fc <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 90a958c:	e03fff15 	stw	zero,-4(fp)
 90a9590:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9594:	e037883a 	mov	sp,fp
 90a9598:	df000017 	ldw	fp,0(sp)
 90a959c:	dec00104 	addi	sp,sp,4
 90a95a0:	f800283a 	ret

090a95a4 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 90a95a4:	defff704 	addi	sp,sp,-36
 90a95a8:	dfc00815 	stw	ra,32(sp)
 90a95ac:	df000715 	stw	fp,28(sp)
 90a95b0:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 90a95b4:	d0a03617 	ldw	r2,-32552(gp)
 90a95b8:	d0e03417 	ldw	r3,-32560(gp)
 90a95bc:	10c5883a 	add	r2,r2,r3
 90a95c0:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 90a95c4:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 90a95c8:	e03ffd15 	stw	zero,-12(fp)
 90a95cc:	00007e06 	br	90a97c8 <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 90a95d0:	01000d04 	movi	r4,52
 90a95d4:	90aaefc0 	call	90aaefc <npalloc>
 90a95d8:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 90a95dc:	e0bffe17 	ldw	r2,-8(fp)
 90a95e0:	1005003a 	cmpeq	r2,r2,zero
 90a95e4:	1000871e 	bne	r2,zero,90a9804 <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 90a95e8:	e0bffd17 	ldw	r2,-12(fp)
 90a95ec:	10800f30 	cmpltui	r2,r2,60
 90a95f0:	1000061e 	bne	r2,zero,90a960c <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 90a95f4:	01024374 	movhi	r4,2317
 90a95f8:	2100e504 	addi	r4,r4,916
 90a95fc:	90836b80 	call	90836b8 <puts>
         return -1;
 90a9600:	00bfffc4 	movi	r2,-1
 90a9604:	e0bfff15 	stw	r2,-4(fp)
 90a9608:	00008406 	br	90a981c <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 90a960c:	e0bffd17 	ldw	r2,-12(fp)
 90a9610:	00c243b4 	movhi	r3,2318
 90a9614:	18f65104 	addi	r3,r3,-9916
 90a9618:	1085883a 	add	r2,r2,r2
 90a961c:	1085883a 	add	r2,r2,r2
 90a9620:	10c7883a 	add	r3,r2,r3
 90a9624:	e0bffe17 	ldw	r2,-8(fp)
 90a9628:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 90a962c:	e0bffe17 	ldw	r2,-8(fp)
 90a9630:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 90a9634:	d0e03617 	ldw	r3,-32552(gp)
 90a9638:	e0bffd17 	ldw	r2,-12(fp)
 90a963c:	10c0302e 	bgeu	r2,r3,90a9700 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 90a9640:	d0a03717 	ldw	r2,-32548(gp)
 90a9644:	11000144 	addi	r4,r2,5
 90a9648:	90ab0a80 	call	90ab0a8 <ncpalloc>
 90a964c:	1007883a 	mov	r3,r2
 90a9650:	e0bffe17 	ldw	r2,-8(fp)
 90a9654:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 90a9658:	e0bffe17 	ldw	r2,-8(fp)
 90a965c:	10800117 	ldw	r2,4(r2)
 90a9660:	1005003a 	cmpeq	r2,r2,zero
 90a9664:	1000671e 	bne	r2,zero,90a9804 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a9668:	e03ffa15 	stw	zero,-24(fp)
 90a966c:	00000906 	br	90a9694 <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 90a9670:	e0bffe17 	ldw	r2,-8(fp)
 90a9674:	10c00117 	ldw	r3,4(r2)
 90a9678:	e0bffa17 	ldw	r2,-24(fp)
 90a967c:	1887883a 	add	r3,r3,r2
 90a9680:	00801344 	movi	r2,77
 90a9684:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a9688:	e0bffa17 	ldw	r2,-24(fp)
 90a968c:	10800044 	addi	r2,r2,1
 90a9690:	e0bffa15 	stw	r2,-24(fp)
 90a9694:	e0bffa17 	ldw	r2,-24(fp)
 90a9698:	10800110 	cmplti	r2,r2,4
 90a969c:	103ff41e 	bne	r2,zero,90a9670 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 90a96a0:	e0bffe17 	ldw	r2,-8(fp)
 90a96a4:	10c00117 	ldw	r3,4(r2)
 90a96a8:	d0a03717 	ldw	r2,-32548(gp)
 90a96ac:	1885883a 	add	r2,r3,r2
 90a96b0:	10c00104 	addi	r3,r2,4
 90a96b4:	00801344 	movi	r2,77
 90a96b8:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 90a96bc:	e0bffe17 	ldw	r2,-8(fp)
 90a96c0:	10800117 	ldw	r2,4(r2)
 90a96c4:	10c00104 	addi	r3,r2,4
 90a96c8:	e0bffe17 	ldw	r2,-8(fp)
 90a96cc:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 90a96d0:	e0bffe17 	ldw	r2,-8(fp)
 90a96d4:	10800117 	ldw	r2,4(r2)
 90a96d8:	1005003a 	cmpeq	r2,r2,zero
 90a96dc:	1000491e 	bne	r2,zero,90a9804 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 90a96e0:	d0e03717 	ldw	r3,-32548(gp)
 90a96e4:	e0bffe17 	ldw	r2,-8(fp)
 90a96e8:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 90a96ec:	010243b4 	movhi	r4,2318
 90a96f0:	21368d04 	addi	r4,r4,-9676
 90a96f4:	e17ffe17 	ldw	r5,-8(fp)
 90a96f8:	90a9e080 	call	90a9e08 <putq>
 90a96fc:	00002f06 	br	90a97bc <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 90a9700:	d0a03517 	ldw	r2,-32556(gp)
 90a9704:	11000144 	addi	r4,r2,5
 90a9708:	90ab0a80 	call	90ab0a8 <ncpalloc>
 90a970c:	1007883a 	mov	r3,r2
 90a9710:	e0bffe17 	ldw	r2,-8(fp)
 90a9714:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 90a9718:	e0bffe17 	ldw	r2,-8(fp)
 90a971c:	10800117 	ldw	r2,4(r2)
 90a9720:	1005003a 	cmpeq	r2,r2,zero
 90a9724:	1000371e 	bne	r2,zero,90a9804 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a9728:	e03ff915 	stw	zero,-28(fp)
 90a972c:	00000906 	br	90a9754 <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 90a9730:	e0bffe17 	ldw	r2,-8(fp)
 90a9734:	10c00117 	ldw	r3,4(r2)
 90a9738:	e0bff917 	ldw	r2,-28(fp)
 90a973c:	1887883a 	add	r3,r3,r2
 90a9740:	00801344 	movi	r2,77
 90a9744:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 90a9748:	e0bff917 	ldw	r2,-28(fp)
 90a974c:	10800044 	addi	r2,r2,1
 90a9750:	e0bff915 	stw	r2,-28(fp)
 90a9754:	e0bff917 	ldw	r2,-28(fp)
 90a9758:	10800110 	cmplti	r2,r2,4
 90a975c:	103ff41e 	bne	r2,zero,90a9730 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 90a9760:	e0bffe17 	ldw	r2,-8(fp)
 90a9764:	10c00117 	ldw	r3,4(r2)
 90a9768:	d0a03517 	ldw	r2,-32556(gp)
 90a976c:	1885883a 	add	r2,r3,r2
 90a9770:	10c00104 	addi	r3,r2,4
 90a9774:	00801344 	movi	r2,77
 90a9778:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 90a977c:	e0bffe17 	ldw	r2,-8(fp)
 90a9780:	10800117 	ldw	r2,4(r2)
 90a9784:	10c00104 	addi	r3,r2,4
 90a9788:	e0bffe17 	ldw	r2,-8(fp)
 90a978c:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 90a9790:	e0bffe17 	ldw	r2,-8(fp)
 90a9794:	10800117 	ldw	r2,4(r2)
 90a9798:	1005003a 	cmpeq	r2,r2,zero
 90a979c:	1000191e 	bne	r2,zero,90a9804 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 90a97a0:	d0e03517 	ldw	r3,-32556(gp)
 90a97a4:	e0bffe17 	ldw	r2,-8(fp)
 90a97a8:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 90a97ac:	010243b4 	movhi	r4,2318
 90a97b0:	21364804 	addi	r4,r4,-9952
 90a97b4:	e17ffe17 	ldw	r5,-8(fp)
 90a97b8:	90a9e080 	call	90a9e08 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 90a97bc:	e0bffd17 	ldw	r2,-12(fp)
 90a97c0:	10800044 	addi	r2,r2,1
 90a97c4:	e0bffd15 	stw	r2,-12(fp)
 90a97c8:	e0fffd17 	ldw	r3,-12(fp)
 90a97cc:	e0bffc17 	ldw	r2,-16(fp)
 90a97d0:	18bf7f36 	bltu	r3,r2,90a95d0 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 90a97d4:	d0a03617 	ldw	r2,-32552(gp)
 90a97d8:	1007883a 	mov	r3,r2
 90a97dc:	008243b4 	movhi	r2,2318
 90a97e0:	10b68d04 	addi	r2,r2,-9676
 90a97e4:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 90a97e8:	d0a03417 	ldw	r2,-32560(gp)
 90a97ec:	1007883a 	mov	r3,r2
 90a97f0:	008243b4 	movhi	r2,2318
 90a97f4:	10b64804 	addi	r2,r2,-9952
 90a97f8:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 90a97fc:	e03fff15 	stw	zero,-4(fp)
 90a9800:	00000606 	br	90a981c <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 90a9804:	01024374 	movhi	r4,2317
 90a9808:	2100ea04 	addi	r4,r4,936
 90a980c:	e17ffd17 	ldw	r5,-12(fp)
 90a9810:	90833900 	call	9083390 <printf>
#endif
   return(-1);
 90a9814:	00bfffc4 	movi	r2,-1
 90a9818:	e0bfff15 	stw	r2,-4(fp)
 90a981c:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9820:	e037883a 	mov	sp,fp
 90a9824:	dfc00117 	ldw	ra,4(sp)
 90a9828:	df000017 	ldw	fp,0(sp)
 90a982c:	dec00204 	addi	sp,sp,8
 90a9830:	f800283a 	ret

090a9834 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 90a9834:	defffb04 	addi	sp,sp,-20
 90a9838:	dfc00415 	stw	ra,16(sp)
 90a983c:	df000315 	stw	fp,12(sp)
 90a9840:	df000304 	addi	fp,sp,12
 90a9844:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 90a9848:	d0e03717 	ldw	r3,-32548(gp)
 90a984c:	e0bffe17 	ldw	r2,-8(fp)
 90a9850:	1880022e 	bgeu	r3,r2,90a985c <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 90a9854:	e03fff15 	stw	zero,-4(fp)
 90a9858:	00002706 	br	90a98f8 <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 90a985c:	d0e03517 	ldw	r3,-32556(gp)
 90a9860:	e0bffe17 	ldw	r2,-8(fp)
 90a9864:	18800536 	bltu	r3,r2,90a987c <pk_alloc+0x48>
 90a9868:	008243b4 	movhi	r2,2318
 90a986c:	10b64804 	addi	r2,r2,-9952
 90a9870:	10800217 	ldw	r2,8(r2)
 90a9874:	1004c03a 	cmpne	r2,r2,zero
 90a9878:	1000051e 	bne	r2,zero,90a9890 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 90a987c:	010243b4 	movhi	r4,2318
 90a9880:	21368d04 	addi	r4,r4,-9676
 90a9884:	90a9d400 	call	90a9d40 <getq>
 90a9888:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 90a988c:	00000406 	br	90a98a0 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 90a9890:	010243b4 	movhi	r4,2318
 90a9894:	21364804 	addi	r4,r4,-9952
 90a9898:	90a9d400 	call	90a9d40 <getq>
 90a989c:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 90a98a0:	e0bffd17 	ldw	r2,-12(fp)
 90a98a4:	1004c03a 	cmpne	r2,r2,zero
 90a98a8:	1000021e 	bne	r2,zero,90a98b4 <pk_alloc+0x80>
         return NULL;
 90a98ac:	e03fff15 	stw	zero,-4(fp)
 90a98b0:	00001106 	br	90a98f8 <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 90a98b4:	e0bffd17 	ldw	r2,-12(fp)
 90a98b8:	10c00117 	ldw	r3,4(r2)
 90a98bc:	00824374 	movhi	r2,2317
 90a98c0:	108f0704 	addi	r2,r2,15388
 90a98c4:	10800017 	ldw	r2,0(r2)
 90a98c8:	1887883a 	add	r3,r3,r2
 90a98cc:	e0bffd17 	ldw	r2,-12(fp)
 90a98d0:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 90a98d4:	e0bffd17 	ldw	r2,-12(fp)
 90a98d8:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 90a98dc:	e0bffd17 	ldw	r2,-12(fp)
 90a98e0:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 90a98e4:	e0fffd17 	ldw	r3,-12(fp)
 90a98e8:	00800044 	movi	r2,1
 90a98ec:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 90a98f0:	e0bffd17 	ldw	r2,-12(fp)
 90a98f4:	e0bfff15 	stw	r2,-4(fp)
 90a98f8:	e0bfff17 	ldw	r2,-4(fp)
}
 90a98fc:	e037883a 	mov	sp,fp
 90a9900:	dfc00117 	ldw	ra,4(sp)
 90a9904:	df000017 	ldw	fp,0(sp)
 90a9908:	dec00204 	addi	sp,sp,8
 90a990c:	f800283a 	ret

090a9910 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 90a9910:	defffa04 	addi	sp,sp,-24
 90a9914:	dfc00515 	stw	ra,20(sp)
 90a9918:	df000415 	stw	fp,16(sp)
 90a991c:	df000404 	addi	fp,sp,16
 90a9920:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 90a9924:	e0bffe17 	ldw	r2,-8(fp)
 90a9928:	10800017 	ldw	r2,0(r2)
 90a992c:	1005003a 	cmpeq	r2,r2,zero
 90a9930:	1000101e 	bne	r2,zero,90a9974 <pk_validate+0x64>
 90a9934:	e0bffe17 	ldw	r2,-8(fp)
 90a9938:	10800917 	ldw	r2,36(r2)
 90a993c:	1005003a 	cmpeq	r2,r2,zero
 90a9940:	10000c1e 	bne	r2,zero,90a9974 <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 90a9944:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a9948:	008243b4 	movhi	r2,2318
 90a994c:	10b64d04 	addi	r2,r2,-9932
 90a9950:	10800317 	ldw	r2,12(r2)
 90a9954:	10c00044 	addi	r3,r2,1
 90a9958:	008243b4 	movhi	r2,2318
 90a995c:	10b64d04 	addi	r2,r2,-9932
 90a9960:	10c00315 	stw	r3,12(r2)
 90a9964:	90aa7140 	call	90aa714 <irq_Unmask>
      return -1;
 90a9968:	00bfffc4 	movi	r2,-1
 90a996c:	e0bfff15 	stw	r2,-4(fp)
 90a9970:	00008f06 	br	90a9bb0 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 90a9974:	e0bffe17 	ldw	r2,-8(fp)
 90a9978:	10c00217 	ldw	r3,8(r2)
 90a997c:	d0a03717 	ldw	r2,-32548(gp)
 90a9980:	1880221e 	bne	r3,r2,90a9a0c <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 90a9984:	90aa6b80 	call	90aa6b8 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 90a9988:	008243b4 	movhi	r2,2318
 90a998c:	10b68d04 	addi	r2,r2,-9676
 90a9990:	10800017 	ldw	r2,0(r2)
 90a9994:	e0bffd15 	stw	r2,-12(fp)
 90a9998:	00001706 	br	90a99f8 <pk_validate+0xe8>
            if (p == pkt)
 90a999c:	e0fffd17 	ldw	r3,-12(fp)
 90a99a0:	e0bffe17 	ldw	r2,-8(fp)
 90a99a4:	1880111e 	bne	r3,r2,90a99ec <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 90a99a8:	01024374 	movhi	r4,2317
 90a99ac:	2100f504 	addi	r4,r4,980
 90a99b0:	e17ffe17 	ldw	r5,-8(fp)
 90a99b4:	90833900 	call	9083390 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 90a99b8:	90aa7140 	call	90aa714 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 90a99bc:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a99c0:	008243b4 	movhi	r2,2318
 90a99c4:	10b64d04 	addi	r2,r2,-9932
 90a99c8:	10800217 	ldw	r2,8(r2)
 90a99cc:	10c00044 	addi	r3,r2,1
 90a99d0:	008243b4 	movhi	r2,2318
 90a99d4:	10b64d04 	addi	r2,r2,-9932
 90a99d8:	10c00215 	stw	r3,8(r2)
 90a99dc:	90aa7140 	call	90aa714 <irq_Unmask>
               return -1;
 90a99e0:	00bfffc4 	movi	r2,-1
 90a99e4:	e0bfff15 	stw	r2,-4(fp)
 90a99e8:	00007106 	br	90a9bb0 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 90a99ec:	e0bffd17 	ldw	r2,-12(fp)
 90a99f0:	10800017 	ldw	r2,0(r2)
 90a99f4:	e0bffd15 	stw	r2,-12(fp)
 90a99f8:	e0bffd17 	ldw	r2,-12(fp)
 90a99fc:	1004c03a 	cmpne	r2,r2,zero
 90a9a00:	103fe61e 	bne	r2,zero,90a999c <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 90a9a04:	90aa7140 	call	90aa714 <irq_Unmask>
 90a9a08:	00003206 	br	90a9ad4 <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 90a9a0c:	e0bffe17 	ldw	r2,-8(fp)
 90a9a10:	10c00217 	ldw	r3,8(r2)
 90a9a14:	d0a03517 	ldw	r2,-32556(gp)
 90a9a18:	1880221e 	bne	r3,r2,90a9aa4 <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 90a9a1c:	90aa6b80 	call	90aa6b8 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 90a9a20:	008243b4 	movhi	r2,2318
 90a9a24:	10b64804 	addi	r2,r2,-9952
 90a9a28:	10800017 	ldw	r2,0(r2)
 90a9a2c:	e0bffd15 	stw	r2,-12(fp)
 90a9a30:	00001706 	br	90a9a90 <pk_validate+0x180>
            if (p == pkt)
 90a9a34:	e0fffd17 	ldw	r3,-12(fp)
 90a9a38:	e0bffe17 	ldw	r2,-8(fp)
 90a9a3c:	1880111e 	bne	r3,r2,90a9a84 <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 90a9a40:	01024374 	movhi	r4,2317
 90a9a44:	2100ff04 	addi	r4,r4,1020
 90a9a48:	e17ffe17 	ldw	r5,-8(fp)
 90a9a4c:	90833900 	call	9083390 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 90a9a50:	90aa7140 	call	90aa714 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 90a9a54:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a9a58:	008243b4 	movhi	r2,2318
 90a9a5c:	10b64d04 	addi	r2,r2,-9932
 90a9a60:	10800217 	ldw	r2,8(r2)
 90a9a64:	10c00044 	addi	r3,r2,1
 90a9a68:	008243b4 	movhi	r2,2318
 90a9a6c:	10b64d04 	addi	r2,r2,-9932
 90a9a70:	10c00215 	stw	r3,8(r2)
 90a9a74:	90aa7140 	call	90aa714 <irq_Unmask>
            return -1;
 90a9a78:	00bfffc4 	movi	r2,-1
 90a9a7c:	e0bfff15 	stw	r2,-4(fp)
 90a9a80:	00004b06 	br	90a9bb0 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 90a9a84:	e0bffd17 	ldw	r2,-12(fp)
 90a9a88:	10800017 	ldw	r2,0(r2)
 90a9a8c:	e0bffd15 	stw	r2,-12(fp)
 90a9a90:	e0bffd17 	ldw	r2,-12(fp)
 90a9a94:	1004c03a 	cmpne	r2,r2,zero
 90a9a98:	103fe61e 	bne	r2,zero,90a9a34 <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 90a9a9c:	90aa7140 	call	90aa714 <irq_Unmask>
 90a9aa0:	00000c06 	br	90a9ad4 <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 90a9aa4:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a9aa8:	008243b4 	movhi	r2,2318
 90a9aac:	10b64d04 	addi	r2,r2,-9932
 90a9ab0:	10800017 	ldw	r2,0(r2)
 90a9ab4:	10c00044 	addi	r3,r2,1
 90a9ab8:	008243b4 	movhi	r2,2318
 90a9abc:	10b64d04 	addi	r2,r2,-9932
 90a9ac0:	10c00015 	stw	r3,0(r2)
 90a9ac4:	90aa7140 	call	90aa714 <irq_Unmask>
         return -1;
 90a9ac8:	00bfffc4 	movi	r2,-1
 90a9acc:	e0bfff15 	stw	r2,-4(fp)
 90a9ad0:	00003706 	br	90a9bb0 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 90a9ad4:	00800104 	movi	r2,4
 90a9ad8:	e0bffc15 	stw	r2,-16(fp)
 90a9adc:	00001906 	br	90a9b44 <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 90a9ae0:	e0bffe17 	ldw	r2,-8(fp)
 90a9ae4:	10c00117 	ldw	r3,4(r2)
 90a9ae8:	e0bffc17 	ldw	r2,-16(fp)
 90a9aec:	1885c83a 	sub	r2,r3,r2
 90a9af0:	10800003 	ldbu	r2,0(r2)
 90a9af4:	10803fcc 	andi	r2,r2,255
 90a9af8:	1080201c 	xori	r2,r2,128
 90a9afc:	10bfe004 	addi	r2,r2,-128
 90a9b00:	10801360 	cmpeqi	r2,r2,77
 90a9b04:	10000c1e 	bne	r2,zero,90a9b38 <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 90a9b08:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a9b0c:	008243b4 	movhi	r2,2318
 90a9b10:	10b64d04 	addi	r2,r2,-9932
 90a9b14:	10800117 	ldw	r2,4(r2)
 90a9b18:	10c00044 	addi	r3,r2,1
 90a9b1c:	008243b4 	movhi	r2,2318
 90a9b20:	10b64d04 	addi	r2,r2,-9932
 90a9b24:	10c00115 	stw	r3,4(r2)
 90a9b28:	90aa7140 	call	90aa714 <irq_Unmask>
         return -1;
 90a9b2c:	00bfffc4 	movi	r2,-1
 90a9b30:	e0bfff15 	stw	r2,-4(fp)
 90a9b34:	00001e06 	br	90a9bb0 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 90a9b38:	e0bffc17 	ldw	r2,-16(fp)
 90a9b3c:	10bfffc4 	addi	r2,r2,-1
 90a9b40:	e0bffc15 	stw	r2,-16(fp)
 90a9b44:	e0bffc17 	ldw	r2,-16(fp)
 90a9b48:	10800048 	cmpgei	r2,r2,1
 90a9b4c:	103fe41e 	bne	r2,zero,90a9ae0 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 90a9b50:	e0bffe17 	ldw	r2,-8(fp)
 90a9b54:	10c00117 	ldw	r3,4(r2)
 90a9b58:	e0bffe17 	ldw	r2,-8(fp)
 90a9b5c:	10800217 	ldw	r2,8(r2)
 90a9b60:	1885883a 	add	r2,r3,r2
 90a9b64:	10800003 	ldbu	r2,0(r2)
 90a9b68:	10803fcc 	andi	r2,r2,255
 90a9b6c:	1080201c 	xori	r2,r2,128
 90a9b70:	10bfe004 	addi	r2,r2,-128
 90a9b74:	10801360 	cmpeqi	r2,r2,77
 90a9b78:	10000c1e 	bne	r2,zero,90a9bac <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 90a9b7c:	90aa6b80 	call	90aa6b8 <irq_Mask>
 90a9b80:	008243b4 	movhi	r2,2318
 90a9b84:	10b64d04 	addi	r2,r2,-9932
 90a9b88:	10800117 	ldw	r2,4(r2)
 90a9b8c:	10c00044 	addi	r3,r2,1
 90a9b90:	008243b4 	movhi	r2,2318
 90a9b94:	10b64d04 	addi	r2,r2,-9932
 90a9b98:	10c00115 	stw	r3,4(r2)
 90a9b9c:	90aa7140 	call	90aa714 <irq_Unmask>
      return -1;
 90a9ba0:	00bfffc4 	movi	r2,-1
 90a9ba4:	e0bfff15 	stw	r2,-4(fp)
 90a9ba8:	00000106 	br	90a9bb0 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 90a9bac:	e03fff15 	stw	zero,-4(fp)
 90a9bb0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9bb4:	e037883a 	mov	sp,fp
 90a9bb8:	dfc00117 	ldw	ra,4(sp)
 90a9bbc:	df000017 	ldw	fp,0(sp)
 90a9bc0:	dec00204 	addi	sp,sp,8
 90a9bc4:	f800283a 	ret

090a9bc8 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 90a9bc8:	defffc04 	addi	sp,sp,-16
 90a9bcc:	dfc00315 	stw	ra,12(sp)
 90a9bd0:	df000215 	stw	fp,8(sp)
 90a9bd4:	df000204 	addi	fp,sp,8
 90a9bd8:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 90a9bdc:	e13fff17 	ldw	r4,-4(fp)
 90a9be0:	90a99100 	call	90a9910 <pk_validate>
 90a9be4:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 90a9be8:	e0bffe17 	ldw	r2,-8(fp)
 90a9bec:	1004c03a 	cmpne	r2,r2,zero
 90a9bf0:	10001b1e 	bne	r2,zero,90a9c60 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 90a9bf4:	e0bfff17 	ldw	r2,-4(fp)
 90a9bf8:	10c00917 	ldw	r3,36(r2)
 90a9bfc:	188000a8 	cmpgeui	r2,r3,2
 90a9c00:	1009883a 	mov	r4,r2
 90a9c04:	18ffffc4 	addi	r3,r3,-1
 90a9c08:	e0bfff17 	ldw	r2,-4(fp)
 90a9c0c:	10c00915 	stw	r3,36(r2)
 90a9c10:	20803fcc 	andi	r2,r4,255
 90a9c14:	1004c03a 	cmpne	r2,r2,zero
 90a9c18:	1000111e 	bne	r2,zero,90a9c60 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 90a9c1c:	e0bfff17 	ldw	r2,-4(fp)
 90a9c20:	10c00217 	ldw	r3,8(r2)
 90a9c24:	d0a03717 	ldw	r2,-32548(gp)
 90a9c28:	1880051e 	bne	r3,r2,90a9c40 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 90a9c2c:	e17fff17 	ldw	r5,-4(fp)
 90a9c30:	010243b4 	movhi	r4,2318
 90a9c34:	21368d04 	addi	r4,r4,-9676
 90a9c38:	90a9e080 	call	90a9e08 <putq>
 90a9c3c:	00000806 	br	90a9c60 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 90a9c40:	e0bfff17 	ldw	r2,-4(fp)
 90a9c44:	10c00217 	ldw	r3,8(r2)
 90a9c48:	d0a03517 	ldw	r2,-32556(gp)
 90a9c4c:	1880041e 	bne	r3,r2,90a9c60 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 90a9c50:	e17fff17 	ldw	r5,-4(fp)
 90a9c54:	010243b4 	movhi	r4,2318
 90a9c58:	21364804 	addi	r4,r4,-9952
 90a9c5c:	90a9e080 	call	90a9e08 <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 90a9c60:	e037883a 	mov	sp,fp
 90a9c64:	dfc00117 	ldw	ra,4(sp)
 90a9c68:	df000017 	ldw	fp,0(sp)
 90a9c6c:	dec00204 	addi	sp,sp,8
 90a9c70:	f800283a 	ret

090a9c74 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 90a9c74:	deffff04 	addi	sp,sp,-4
 90a9c78:	df000015 	stw	fp,0(sp)
 90a9c7c:	d839883a 	mov	fp,sp
   return bigbufsiz;
 90a9c80:	d0a03717 	ldw	r2,-32548(gp)
}
 90a9c84:	e037883a 	mov	sp,fp
 90a9c88:	df000017 	ldw	fp,0(sp)
 90a9c8c:	dec00104 	addi	sp,sp,4
 90a9c90:	f800283a 	ret

090a9c94 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 90a9c94:	defff904 	addi	sp,sp,-28
 90a9c98:	dfc00615 	stw	ra,24(sp)
 90a9c9c:	df000515 	stw	fp,20(sp)
 90a9ca0:	df000504 	addi	fp,sp,20
 90a9ca4:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90a9ca8:	01000084 	movi	r4,2
 90a9cac:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 90a9cb0:	90aa6b80 	call	90aa6b8 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 90a9cb4:	00c243b4 	movhi	r3,2318
 90a9cb8:	18f64d04 	addi	r3,r3,-9932
 90a9cbc:	18800017 	ldw	r2,0(r3)
 90a9cc0:	e0bffb15 	stw	r2,-20(fp)
 90a9cc4:	18800117 	ldw	r2,4(r3)
 90a9cc8:	e0bffc15 	stw	r2,-16(fp)
 90a9ccc:	18800217 	ldw	r2,8(r3)
 90a9cd0:	e0bffd15 	stw	r2,-12(fp)
 90a9cd4:	18800317 	ldw	r2,12(r3)
 90a9cd8:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 90a9cdc:	90aa7140 	call	90aa714 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90a9ce0:	01000084 	movi	r4,2
 90a9ce4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 90a9ce8:	e13fff17 	ldw	r4,-4(fp)
 90a9cec:	01424374 	movhi	r5,2317
 90a9cf0:	29410904 	addi	r5,r5,1060
 90a9cf4:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 90a9cf8:	e1bffb17 	ldw	r6,-20(fp)
 90a9cfc:	e1fffc17 	ldw	r7,-16(fp)
 90a9d00:	e13fff17 	ldw	r4,-4(fp)
 90a9d04:	01424374 	movhi	r5,2317
 90a9d08:	29411204 	addi	r5,r5,1096
 90a9d0c:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 90a9d10:	e1bffd17 	ldw	r6,-12(fp)
 90a9d14:	e1fffe17 	ldw	r7,-8(fp)
 90a9d18:	e13fff17 	ldw	r4,-4(fp)
 90a9d1c:	01424374 	movhi	r5,2317
 90a9d20:	29411f04 	addi	r5,r5,1148
 90a9d24:	90a55a40 	call	90a55a4 <ns_printf>

   return 0;
 90a9d28:	0005883a 	mov	r2,zero
}
 90a9d2c:	e037883a 	mov	sp,fp
 90a9d30:	dfc00117 	ldw	ra,4(sp)
 90a9d34:	df000017 	ldw	fp,0(sp)
 90a9d38:	dec00204 	addi	sp,sp,8
 90a9d3c:	f800283a 	ret

090a9d40 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 90a9d40:	defffb04 	addi	sp,sp,-20
 90a9d44:	dfc00415 	stw	ra,16(sp)
 90a9d48:	df000315 	stw	fp,12(sp)
 90a9d4c:	df000304 	addi	fp,sp,12
 90a9d50:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 90a9d54:	90aa6b80 	call	90aa6b8 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 90a9d58:	e0bffe17 	ldw	r2,-8(fp)
 90a9d5c:	10800017 	ldw	r2,0(r2)
 90a9d60:	e0bffd15 	stw	r2,-12(fp)
 90a9d64:	e0bffd17 	ldw	r2,-12(fp)
 90a9d68:	1004c03a 	cmpne	r2,r2,zero
 90a9d6c:	1000031e 	bne	r2,zero,90a9d7c <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 90a9d70:	90aa7140 	call	90aa714 <irq_Unmask>
      return (0);             /* yes, show none */
 90a9d74:	e03fff15 	stw	zero,-4(fp)
 90a9d78:	00001d06 	br	90a9df0 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 90a9d7c:	e0bffd17 	ldw	r2,-12(fp)
 90a9d80:	10c00017 	ldw	r3,0(r2)
 90a9d84:	e0bffe17 	ldw	r2,-8(fp)
 90a9d88:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 90a9d8c:	e0bffd17 	ldw	r2,-12(fp)
 90a9d90:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 90a9d94:	e0bffe17 	ldw	r2,-8(fp)
 90a9d98:	10800017 	ldw	r2,0(r2)
 90a9d9c:	1004c03a 	cmpne	r2,r2,zero
 90a9da0:	1000021e 	bne	r2,zero,90a9dac <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 90a9da4:	e0bffe17 	ldw	r2,-8(fp)
 90a9da8:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 90a9dac:	e0bffe17 	ldw	r2,-8(fp)
 90a9db0:	10800217 	ldw	r2,8(r2)
 90a9db4:	10ffffc4 	addi	r3,r2,-1
 90a9db8:	e0bffe17 	ldw	r2,-8(fp)
 90a9dbc:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 90a9dc0:	e0bffe17 	ldw	r2,-8(fp)
 90a9dc4:	10c00217 	ldw	r3,8(r2)
 90a9dc8:	e0bffe17 	ldw	r2,-8(fp)
 90a9dcc:	10800417 	ldw	r2,16(r2)
 90a9dd0:	1880040e 	bge	r3,r2,90a9de4 <getq+0xa4>
      q->q_min = q->q_len;
 90a9dd4:	e0bffe17 	ldw	r2,-8(fp)
 90a9dd8:	10c00217 	ldw	r3,8(r2)
 90a9ddc:	e0bffe17 	ldw	r2,-8(fp)
 90a9de0:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 90a9de4:	90aa7140 	call	90aa714 <irq_Unmask>

   return ((void*)temp);
 90a9de8:	e0bffd17 	ldw	r2,-12(fp)
 90a9dec:	e0bfff15 	stw	r2,-4(fp)
 90a9df0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9df4:	e037883a 	mov	sp,fp
 90a9df8:	dfc00117 	ldw	ra,4(sp)
 90a9dfc:	df000017 	ldw	fp,0(sp)
 90a9e00:	dec00204 	addi	sp,sp,8
 90a9e04:	f800283a 	ret

090a9e08 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 90a9e08:	defffc04 	addi	sp,sp,-16
 90a9e0c:	dfc00315 	stw	ra,12(sp)
 90a9e10:	df000215 	stw	fp,8(sp)
 90a9e14:	df000204 	addi	fp,sp,8
 90a9e18:	e13ffe15 	stw	r4,-8(fp)
 90a9e1c:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 90a9e20:	90aa6b80 	call	90aa6b8 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 90a9e24:	e0bfff17 	ldw	r2,-4(fp)
 90a9e28:	10000015 	stw	zero,0(r2)
 90a9e2c:	e0bffe17 	ldw	r2,-8(fp)
 90a9e30:	10800017 	ldw	r2,0(r2)
 90a9e34:	1004c03a 	cmpne	r2,r2,zero
 90a9e38:	1000041e 	bne	r2,zero,90a9e4c <putq+0x44>
 90a9e3c:	e0ffff17 	ldw	r3,-4(fp)
 90a9e40:	e0bffe17 	ldw	r2,-8(fp)
 90a9e44:	10c00015 	stw	r3,0(r2)
 90a9e48:	00000406 	br	90a9e5c <putq+0x54>
 90a9e4c:	e0bffe17 	ldw	r2,-8(fp)
 90a9e50:	10c00117 	ldw	r3,4(r2)
 90a9e54:	e0bfff17 	ldw	r2,-4(fp)
 90a9e58:	18800015 	stw	r2,0(r3)
 90a9e5c:	e0ffff17 	ldw	r3,-4(fp)
 90a9e60:	e0bffe17 	ldw	r2,-8(fp)
 90a9e64:	10c00115 	stw	r3,4(r2)
 90a9e68:	e0bffe17 	ldw	r2,-8(fp)
 90a9e6c:	10800217 	ldw	r2,8(r2)
 90a9e70:	10c00044 	addi	r3,r2,1
 90a9e74:	e0bffe17 	ldw	r2,-8(fp)
 90a9e78:	10c00215 	stw	r3,8(r2)
 90a9e7c:	e0bffe17 	ldw	r2,-8(fp)
 90a9e80:	10c00217 	ldw	r3,8(r2)
 90a9e84:	e0bffe17 	ldw	r2,-8(fp)
 90a9e88:	10800317 	ldw	r2,12(r2)
 90a9e8c:	10c0040e 	bge	r2,r3,90a9ea0 <putq+0x98>
 90a9e90:	e0bffe17 	ldw	r2,-8(fp)
 90a9e94:	10c00217 	ldw	r3,8(r2)
 90a9e98:	e0bffe17 	ldw	r2,-8(fp)
 90a9e9c:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 90a9ea0:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90a9ea4:	e037883a 	mov	sp,fp
 90a9ea8:	dfc00117 	ldw	ra,4(sp)
 90a9eac:	df000017 	ldw	fp,0(sp)
 90a9eb0:	dec00204 	addi	sp,sp,8
 90a9eb4:	f800283a 	ret

090a9eb8 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 90a9eb8:	defff904 	addi	sp,sp,-28
 90a9ebc:	dfc00615 	stw	ra,24(sp)
 90a9ec0:	df000515 	stw	fp,20(sp)
 90a9ec4:	df000504 	addi	fp,sp,20
 90a9ec8:	e13ffd15 	stw	r4,-12(fp)
 90a9ecc:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 90a9ed0:	90aa6b80 	call	90aa6b8 <irq_Mask>
   qptr = q->q_head;
 90a9ed4:	e0bffd17 	ldw	r2,-12(fp)
 90a9ed8:	10800017 	ldw	r2,0(r2)
 90a9edc:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 90a9ee0:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 90a9ee4:	00002d06 	br	90a9f9c <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 90a9ee8:	e0fffe17 	ldw	r3,-8(fp)
 90a9eec:	e0bffc17 	ldw	r2,-16(fp)
 90a9ef0:	10c0251e 	bne	r2,r3,90a9f88 <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 90a9ef4:	e0bffb17 	ldw	r2,-20(fp)
 90a9ef8:	1005003a 	cmpeq	r2,r2,zero
 90a9efc:	1000051e 	bne	r2,zero,90a9f14 <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 90a9f00:	e0bffc17 	ldw	r2,-16(fp)
 90a9f04:	10c00017 	ldw	r3,0(r2)
 90a9f08:	e0bffb17 	ldw	r2,-20(fp)
 90a9f0c:	10c00015 	stw	r3,0(r2)
 90a9f10:	00000406 	br	90a9f24 <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 90a9f14:	e0bffc17 	ldw	r2,-16(fp)
 90a9f18:	10c00017 	ldw	r3,0(r2)
 90a9f1c:	e0bffd17 	ldw	r2,-12(fp)
 90a9f20:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 90a9f24:	e0bffd17 	ldw	r2,-12(fp)
 90a9f28:	10c00117 	ldw	r3,4(r2)
 90a9f2c:	e0bffe17 	ldw	r2,-8(fp)
 90a9f30:	1880031e 	bne	r3,r2,90a9f40 <qdel+0x88>
            q->q_tail = qlast;
 90a9f34:	e0fffd17 	ldw	r3,-12(fp)
 90a9f38:	e0bffb17 	ldw	r2,-20(fp)
 90a9f3c:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 90a9f40:	e0bffd17 	ldw	r2,-12(fp)
 90a9f44:	10800217 	ldw	r2,8(r2)
 90a9f48:	10ffffc4 	addi	r3,r2,-1
 90a9f4c:	e0bffd17 	ldw	r2,-12(fp)
 90a9f50:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 90a9f54:	e0bffd17 	ldw	r2,-12(fp)
 90a9f58:	10c00217 	ldw	r3,8(r2)
 90a9f5c:	e0bffd17 	ldw	r2,-12(fp)
 90a9f60:	10800417 	ldw	r2,16(r2)
 90a9f64:	1880040e 	bge	r3,r2,90a9f78 <qdel+0xc0>
            q->q_min = q->q_len;
 90a9f68:	e0bffd17 	ldw	r2,-12(fp)
 90a9f6c:	10c00217 	ldw	r3,8(r2)
 90a9f70:	e0bffd17 	ldw	r2,-12(fp)
 90a9f74:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 90a9f78:	90aa7140 	call	90aa714 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 90a9f7c:	e0bffe17 	ldw	r2,-8(fp)
 90a9f80:	e0bfff15 	stw	r2,-4(fp)
 90a9f84:	00000a06 	br	90a9fb0 <qdel+0xf8>
      }
      qlast = qptr;
 90a9f88:	e0bffc17 	ldw	r2,-16(fp)
 90a9f8c:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 90a9f90:	e0bffc17 	ldw	r2,-16(fp)
 90a9f94:	10800017 	ldw	r2,0(r2)
 90a9f98:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 90a9f9c:	e0bffc17 	ldw	r2,-16(fp)
 90a9fa0:	1004c03a 	cmpne	r2,r2,zero
 90a9fa4:	103fd01e 	bne	r2,zero,90a9ee8 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 90a9fa8:	90aa7140 	call	90aa714 <irq_Unmask>
   return NULL;   /* item not found in queue */
 90a9fac:	e03fff15 	stw	zero,-4(fp)
 90a9fb0:	e0bfff17 	ldw	r2,-4(fp)
}
 90a9fb4:	e037883a 	mov	sp,fp
 90a9fb8:	dfc00117 	ldw	ra,4(sp)
 90a9fbc:	df000017 	ldw	fp,0(sp)
 90a9fc0:	dec00204 	addi	sp,sp,8
 90a9fc4:	f800283a 	ret

090a9fc8 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 90a9fc8:	defff304 	addi	sp,sp,-52
 90a9fcc:	dfc00c15 	stw	ra,48(sp)
 90a9fd0:	df000b15 	stw	fp,44(sp)
 90a9fd4:	df000b04 	addi	fp,sp,44
 90a9fd8:	e13ffb15 	stw	r4,-20(fp)
 90a9fdc:	e1fffe15 	stw	r7,-8(fp)
 90a9fe0:	e17ffc0d 	sth	r5,-16(fp)
 90a9fe4:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 90a9fe8:	00824374 	movhi	r2,2317
 90a9fec:	108f0904 	addi	r2,r2,15396
 90a9ff0:	10800017 	ldw	r2,0(r2)
 90a9ff4:	1080010c 	andi	r2,r2,4
 90a9ff8:	1005003a 	cmpeq	r2,r2,zero
 90a9ffc:	1000171e 	bne	r2,zero,90aa05c <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 90aa000:	e0bffb17 	ldw	r2,-20(fp)
 90aa004:	11803fcc 	andi	r6,r2,255
 90aa008:	e0bffb17 	ldw	r2,-20(fp)
 90aa00c:	1004d23a 	srli	r2,r2,8
 90aa010:	11c03fcc 	andi	r7,r2,255
 90aa014:	e0bffb17 	ldw	r2,-20(fp)
 90aa018:	1004d43a 	srli	r2,r2,16
 90aa01c:	12003fcc 	andi	r8,r2,255
 90aa020:	e0bffb17 	ldw	r2,-20(fp)
 90aa024:	1006d63a 	srli	r3,r2,24
 90aa028:	e13ffd0b 	ldhu	r4,-12(fp)
 90aa02c:	e17ffc0b 	ldhu	r5,-16(fp)
 90aa030:	e0800217 	ldw	r2,8(fp)
 90aa034:	d8c00015 	stw	r3,0(sp)
 90aa038:	d9000115 	stw	r4,4(sp)
 90aa03c:	d9400215 	stw	r5,8(sp)
 90aa040:	d8800315 	stw	r2,12(sp)
 90aa044:	01024374 	movhi	r4,2317
 90aa048:	21012b04 	addi	r4,r4,1196
 90aa04c:	300b883a 	mov	r5,r6
 90aa050:	380d883a 	mov	r6,r7
 90aa054:	400f883a 	mov	r7,r8
 90aa058:	90833900 	call	9083390 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 90aa05c:	0009883a 	mov	r4,zero
 90aa060:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   ocon = NULL;
 90aa064:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 90aa068:	d0a09d17 	ldw	r2,-32140(gp)
 90aa06c:	e0bffa15 	stw	r2,-24(fp)
 90aa070:	00002406 	br	90aa104 <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 90aa074:	e0bffa17 	ldw	r2,-24(fp)
 90aa078:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 90aa07c:	e0bffa17 	ldw	r2,-24(fp)
 90aa080:	1080018b 	ldhu	r2,6(r2)
 90aa084:	10ffffcc 	andi	r3,r2,65535
 90aa088:	e0bffd0b 	ldhu	r2,-12(fp)
 90aa08c:	18801a1e 	bne	r3,r2,90aa0f8 <udp_open+0x130>
 90aa090:	e0bffa17 	ldw	r2,-24(fp)
 90aa094:	1080020b 	ldhu	r2,8(r2)
 90aa098:	10ffffcc 	andi	r3,r2,65535
 90aa09c:	e0bffc0b 	ldhu	r2,-16(fp)
 90aa0a0:	1880151e 	bne	r3,r2,90aa0f8 <udp_open+0x130>
 90aa0a4:	e0bffa17 	ldw	r2,-24(fp)
 90aa0a8:	10800317 	ldw	r2,12(r2)
 90aa0ac:	1004c03a 	cmpne	r2,r2,zero
 90aa0b0:	1000111e 	bne	r2,zero,90aa0f8 <udp_open+0x130>
 90aa0b4:	e0bffa17 	ldw	r2,-24(fp)
 90aa0b8:	10c00417 	ldw	r3,16(r2)
 90aa0bc:	e0bffb17 	ldw	r2,-20(fp)
 90aa0c0:	18800d1e 	bne	r3,r2,90aa0f8 <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 90aa0c4:	00824374 	movhi	r2,2317
 90aa0c8:	108f0904 	addi	r2,r2,15396
 90aa0cc:	10800017 	ldw	r2,0(r2)
 90aa0d0:	1080050c 	andi	r2,r2,20
 90aa0d4:	1005003a 	cmpeq	r2,r2,zero
 90aa0d8:	1000031e 	bne	r2,zero,90aa0e8 <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 90aa0dc:	01024374 	movhi	r4,2317
 90aa0e0:	21013a04 	addi	r4,r4,1256
 90aa0e4:	90836b80 	call	90836b8 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 90aa0e8:	0009883a 	mov	r4,zero
 90aa0ec:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return(NULL);
 90aa0f0:	e03fff15 	stw	zero,-4(fp)
 90aa0f4:	00003c06 	br	90aa1e8 <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 90aa0f8:	e0bffa17 	ldw	r2,-24(fp)
 90aa0fc:	10800017 	ldw	r2,0(r2)
 90aa100:	e0bffa15 	stw	r2,-24(fp)
 90aa104:	e0bffa17 	ldw	r2,-24(fp)
 90aa108:	1004c03a 	cmpne	r2,r2,zero
 90aa10c:	103fd91e 	bne	r2,zero,90aa074 <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 90aa110:	01000804 	movi	r4,32
 90aa114:	90aaefc0 	call	90aaefc <npalloc>
 90aa118:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 90aa11c:	e0bffa17 	ldw	r2,-24(fp)
 90aa120:	1004c03a 	cmpne	r2,r2,zero
 90aa124:	10000d1e 	bne	r2,zero,90aa15c <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 90aa128:	00824374 	movhi	r2,2317
 90aa12c:	108f0904 	addi	r2,r2,15396
 90aa130:	10800017 	ldw	r2,0(r2)
 90aa134:	1080010c 	andi	r2,r2,4
 90aa138:	1005003a 	cmpeq	r2,r2,zero
 90aa13c:	1000031e 	bne	r2,zero,90aa14c <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 90aa140:	01024374 	movhi	r4,2317
 90aa144:	21014204 	addi	r4,r4,1288
 90aa148:	90836b80 	call	90836b8 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90aa14c:	0009883a 	mov	r4,zero
 90aa150:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return(NULL);
 90aa154:	e03fff15 	stw	zero,-4(fp)
 90aa158:	00002306 	br	90aa1e8 <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 90aa15c:	e0bff917 	ldw	r2,-28(fp)
 90aa160:	1005003a 	cmpeq	r2,r2,zero
 90aa164:	1000041e 	bne	r2,zero,90aa178 <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 90aa168:	e0fff917 	ldw	r3,-28(fp)
 90aa16c:	e0bffa17 	ldw	r2,-24(fp)
 90aa170:	18800015 	stw	r2,0(r3)
 90aa174:	00000206 	br	90aa180 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 90aa178:	e0bffa17 	ldw	r2,-24(fp)
 90aa17c:	d0a09d15 	stw	r2,-32140(gp)

   con->u_next = 0;
 90aa180:	e0bffa17 	ldw	r2,-24(fp)
 90aa184:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 90aa188:	e0fffa17 	ldw	r3,-24(fp)
 90aa18c:	e0bffd0b 	ldhu	r2,-12(fp)
 90aa190:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 90aa194:	e0fffa17 	ldw	r3,-24(fp)
 90aa198:	e0bffc0b 	ldhu	r2,-16(fp)
 90aa19c:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 90aa1a0:	e0bffa17 	ldw	r2,-24(fp)
 90aa1a4:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 90aa1a8:	e0fffa17 	ldw	r3,-24(fp)
 90aa1ac:	e0bffb17 	ldw	r2,-20(fp)
 90aa1b0:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 90aa1b4:	e0fffa17 	ldw	r3,-24(fp)
 90aa1b8:	e0bffe17 	ldw	r2,-8(fp)
 90aa1bc:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 90aa1c0:	e0fffa17 	ldw	r3,-24(fp)
 90aa1c4:	e0800217 	ldw	r2,8(fp)
 90aa1c8:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 90aa1cc:	e0fffa17 	ldw	r3,-24(fp)
 90aa1d0:	00800044 	movi	r2,1
 90aa1d4:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 90aa1d8:	0009883a 	mov	r4,zero
 90aa1dc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return(con);
 90aa1e0:	e0bffa17 	ldw	r2,-24(fp)
 90aa1e4:	e0bfff15 	stw	r2,-4(fp)
 90aa1e8:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa1ec:	e037883a 	mov	sp,fp
 90aa1f0:	dfc00117 	ldw	ra,4(sp)
 90aa1f4:	df000017 	ldw	fp,0(sp)
 90aa1f8:	dec00204 	addi	sp,sp,8
 90aa1fc:	f800283a 	ret

090aa200 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 90aa200:	defffb04 	addi	sp,sp,-20
 90aa204:	dfc00415 	stw	ra,16(sp)
 90aa208:	df000315 	stw	fp,12(sp)
 90aa20c:	df000304 	addi	fp,sp,12
 90aa210:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 90aa214:	e0bfff17 	ldw	r2,-4(fp)
 90aa218:	1005003a 	cmpeq	r2,r2,zero
 90aa21c:	1000031e 	bne	r2,zero,90aa22c <udp_close+0x2c>
 90aa220:	d0a09d17 	ldw	r2,-32140(gp)
 90aa224:	1004c03a 	cmpne	r2,r2,zero
 90aa228:	1000021e 	bne	r2,zero,90aa234 <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 90aa22c:	90aa4780 	call	90aa478 <dtrap>
      return;
 90aa230:	00002706 	br	90aa2d0 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 90aa234:	0009883a 	mov	r4,zero
 90aa238:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 90aa23c:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 90aa240:	d0a09d17 	ldw	r2,-32140(gp)
 90aa244:	e0bffe15 	stw	r2,-8(fp)
 90aa248:	00000806 	br	90aa26c <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 90aa24c:	e0fffe17 	ldw	r3,-8(fp)
 90aa250:	e0bfff17 	ldw	r2,-4(fp)
 90aa254:	18800826 	beq	r3,r2,90aa278 <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 90aa258:	e0bffe17 	ldw	r2,-8(fp)
 90aa25c:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 90aa260:	e0bffe17 	ldw	r2,-8(fp)
 90aa264:	10800017 	ldw	r2,0(r2)
 90aa268:	e0bffe15 	stw	r2,-8(fp)
 90aa26c:	e0bffe17 	ldw	r2,-8(fp)
 90aa270:	1004c03a 	cmpne	r2,r2,zero
 90aa274:	103ff51e 	bne	r2,zero,90aa24c <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 90aa278:	e0bffe17 	ldw	r2,-8(fp)
 90aa27c:	1004c03a 	cmpne	r2,r2,zero
 90aa280:	1000041e 	bne	r2,zero,90aa294 <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 90aa284:	90aa4780 	call	90aa478 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 90aa288:	0009883a 	mov	r4,zero
 90aa28c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return;
 90aa290:	00000f06 	br	90aa2d0 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 90aa294:	e0bffd17 	ldw	r2,-12(fp)
 90aa298:	1005003a 	cmpeq	r2,r2,zero
 90aa29c:	1000051e 	bne	r2,zero,90aa2b4 <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 90aa2a0:	e0bfff17 	ldw	r2,-4(fp)
 90aa2a4:	10c00017 	ldw	r3,0(r2)
 90aa2a8:	e0bffd17 	ldw	r2,-12(fp)
 90aa2ac:	10c00015 	stw	r3,0(r2)
 90aa2b0:	00000306 	br	90aa2c0 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 90aa2b4:	e0bfff17 	ldw	r2,-4(fp)
 90aa2b8:	10800017 	ldw	r2,0(r2)
 90aa2bc:	d0a09d15 	stw	r2,-32140(gp)

   UC_FREE(con);  /* free memory for structure */
 90aa2c0:	e13fff17 	ldw	r4,-4(fp)
 90aa2c4:	90aaff00 	call	90aaff0 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90aa2c8:	0009883a 	mov	r4,zero
 90aa2cc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
}
 90aa2d0:	e037883a 	mov	sp,fp
 90aa2d4:	dfc00117 	ldw	ra,4(sp)
 90aa2d8:	df000017 	ldw	fp,0(sp)
 90aa2dc:	dec00204 	addi	sp,sp,8
 90aa2e0:	f800283a 	ret

090aa2e4 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 90aa2e4:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 90aa2e8:	0140620e 	bge	zero,r5,90aa474 <done>

      mov   r6, zero		       /* carry accumulator */
 90aa2ec:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 90aa2f0:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 90aa2f4:	18000326 	beq	r3,zero,90aa304 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 90aa2f8:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 90aa2fc:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 90aa300:	297fffc4 	addi	r5,r5,-1

090aa304 <asm1>:
 90aa304:	02c242f4 	movhi	r11,2315
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 90aa308:	5ae90c04 	addi	r11,r11,-23504
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 90aa30c:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 90aa310:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 90aa314:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 90aa318:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 90aa31c:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 90aa320:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 90aa324:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 90aa328:	5800683a 	jmp	r11

090aa32c <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 90aa32c:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 90aa330:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 90aa334:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa338:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa33c:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 90aa340:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 90aa344:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa348:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa34c:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 90aa350:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 90aa354:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa358:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa35c:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 90aa360:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 90aa364:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa368:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa36c:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 90aa370:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 90aa374:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa378:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa37c:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 90aa380:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 90aa384:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa388:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa38c:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 90aa390:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 90aa394:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa398:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa39c:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 90aa3a0:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 90aa3a4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3a8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3ac:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 90aa3b0:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 90aa3b4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3b8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3bc:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 90aa3c0:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 90aa3c4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3c8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3cc:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 90aa3d0:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 90aa3d4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3d8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3dc:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 90aa3e0:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 90aa3e4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3e8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3ec:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 90aa3f0:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 90aa3f4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa3f8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa3fc:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 90aa400:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 90aa404:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa408:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa40c:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 90aa410:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 90aa414:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa418:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa41c:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 90aa420:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 90aa424:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa428:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa42c:	418d883a 	add	r6,r8,r6

090aa430 <loop0>:
loop0:
      subi  r5, r5, 16
 90aa430:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 90aa434:	283fbd0e 	bge	r5,zero,90aa32c <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 90aa438:	48000426 	beq	r9,zero,90aa44c <fold>
      ldhu  r7, 0(r4)
 90aa43c:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 90aa440:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 90aa444:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 90aa448:	418d883a 	add	r6,r8,r6

090aa44c <fold>:
      
fold:
      srli  r7, r2, 16
 90aa44c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90aa450:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 90aa454:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 90aa458:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 90aa45c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90aa460:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 90aa464:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 90aa468:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 90aa46c:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 90aa470:	3885883a 	add	r2,r7,r2

090aa474 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 90aa474:	f800283a 	ret

090aa478 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 90aa478:	defffe04 	addi	sp,sp,-8
 90aa47c:	dfc00115 	stw	ra,4(sp)
 90aa480:	df000015 	stw	fp,0(sp)
 90aa484:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 90aa488:	01024374 	movhi	r4,2317
 90aa48c:	21014c04 	addi	r4,r4,1328
 90aa490:	90836b80 	call	90836b8 <puts>
}
 90aa494:	e037883a 	mov	sp,fp
 90aa498:	dfc00117 	ldw	ra,4(sp)
 90aa49c:	df000017 	ldw	fp,0(sp)
 90aa4a0:	dec00204 	addi	sp,sp,8
 90aa4a4:	f800283a 	ret

090aa4a8 <kbhit>:

int
kbhit()
{
 90aa4a8:	defffc04 	addi	sp,sp,-16
 90aa4ac:	dfc00315 	stw	ra,12(sp)
 90aa4b0:	df000215 	stw	fp,8(sp)
 90aa4b4:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 90aa4b8:	d0a09e17 	ldw	r2,-32136(gp)
 90aa4bc:	1004c03a 	cmpne	r2,r2,zero
 90aa4c0:	10000c1e 	bne	r2,zero,90aa4f4 <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 90aa4c4:	0009883a 	mov	r4,zero
 90aa4c8:	01400104 	movi	r5,4
 90aa4cc:	01900004 	movi	r6,16384
 90aa4d0:	90bc5c00 	call	90bc5c0 <fcntl>
 90aa4d4:	1005003a 	cmpeq	r2,r2,zero
 90aa4d8:	1000041e 	bne	r2,zero,90aa4ec <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 90aa4dc:	01024374 	movhi	r4,2317
 90aa4e0:	21015304 	addi	r4,r4,1356
 90aa4e4:	90836b80 	call	90836b8 <puts>
         dtrap();
 90aa4e8:	90aa4780 	call	90aa478 <dtrap>
      }
      kbd_init = 1; 
 90aa4ec:	00800044 	movi	r2,1
 90aa4f0:	d0a09e15 	stw	r2,-32136(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 90aa4f4:	d0a03817 	ldw	r2,-32544(gp)
 90aa4f8:	10bfffd8 	cmpnei	r2,r2,-1
 90aa4fc:	10000d1e 	bne	r2,zero,90aa534 <kbhit+0x8c>
   {
      kb = getchar();
 90aa500:	00824374 	movhi	r2,2317
 90aa504:	108e8604 	addi	r2,r2,14872
 90aa508:	10800017 	ldw	r2,0(r2)
 90aa50c:	11000117 	ldw	r4,4(r2)
 90aa510:	90831500 	call	9083150 <getc>
 90aa514:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 90aa518:	e0bffe17 	ldw	r2,-8(fp)
 90aa51c:	1004403a 	cmpge	r2,r2,zero
 90aa520:	1000021e 	bne	r2,zero,90aa52c <kbhit+0x84>
         return (FALSE);
 90aa524:	e03fff15 	stw	zero,-4(fp)
 90aa528:	00000406 	br	90aa53c <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 90aa52c:	e0bffe17 	ldw	r2,-8(fp)
 90aa530:	d0a03815 	stw	r2,-32544(gp)
   }

   return (TRUE);
 90aa534:	00800044 	movi	r2,1
 90aa538:	e0bfff15 	stw	r2,-4(fp)
 90aa53c:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa540:	e037883a 	mov	sp,fp
 90aa544:	dfc00117 	ldw	ra,4(sp)
 90aa548:	df000017 	ldw	fp,0(sp)
 90aa54c:	dec00204 	addi	sp,sp,8
 90aa550:	f800283a 	ret

090aa554 <getch>:

int 
getch()
{
 90aa554:	defffd04 	addi	sp,sp,-12
 90aa558:	dfc00215 	stw	ra,8(sp)
 90aa55c:	df000115 	stw	fp,4(sp)
 90aa560:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 90aa564:	d0a03817 	ldw	r2,-32544(gp)
 90aa568:	10bfffe0 	cmpeqi	r2,r2,-1
 90aa56c:	1000051e 	bne	r2,zero,90aa584 <getch+0x30>
   {
      chr = kb_last;
 90aa570:	d0a03817 	ldw	r2,-32544(gp)
 90aa574:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 90aa578:	00bfffc4 	movi	r2,-1
 90aa57c:	d0a03815 	stw	r2,-32544(gp)
 90aa580:	00000606 	br	90aa59c <getch+0x48>
   }
   else
      chr = getchar();
 90aa584:	00824374 	movhi	r2,2317
 90aa588:	108e8604 	addi	r2,r2,14872
 90aa58c:	10800017 	ldw	r2,0(r2)
 90aa590:	11000117 	ldw	r4,4(r2)
 90aa594:	90831500 	call	9083150 <getc>
 90aa598:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 90aa59c:	e0bfff17 	ldw	r2,-4(fp)
}
 90aa5a0:	e037883a 	mov	sp,fp
 90aa5a4:	dfc00117 	ldw	ra,4(sp)
 90aa5a8:	df000017 	ldw	fp,0(sp)
 90aa5ac:	dec00204 	addi	sp,sp,8
 90aa5b0:	f800283a 	ret

090aa5b4 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 90aa5b4:	deffff04 	addi	sp,sp,-4
 90aa5b8:	df000015 	stw	fp,0(sp)
 90aa5bc:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 90aa5c0:	00801904 	movi	r2,100
 90aa5c4:	d0a0a315 	stw	r2,-32116(gp)
   cticks_factor = 0;
 90aa5c8:	d020a215 	stw	zero,-32120(gp)
   cticks = 0;
 90aa5cc:	00824374 	movhi	r2,2317
 90aa5d0:	108f2e04 	addi	r2,r2,15544
 90aa5d4:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 90aa5d8:	00800044 	movi	r2,1
 90aa5dc:	d0a09f15 	stw	r2,-32132(gp)
}
 90aa5e0:	e037883a 	mov	sp,fp
 90aa5e4:	df000017 	ldw	fp,0(sp)
 90aa5e8:	dec00104 	addi	sp,sp,4
 90aa5ec:	f800283a 	ret

090aa5f0 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 90aa5f0:	deffff04 	addi	sp,sp,-4
 90aa5f4:	df000015 	stw	fp,0(sp)
 90aa5f8:	d839883a 	mov	fp,sp
   /* null */ ;
}
 90aa5fc:	e037883a 	mov	sp,fp
 90aa600:	df000017 	ldw	fp,0(sp)
 90aa604:	dec00104 	addi	sp,sp,4
 90aa608:	f800283a 	ret

090aa60c <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 90aa60c:	defffe04 	addi	sp,sp,-8
 90aa610:	dfc00115 	stw	ra,4(sp)
 90aa614:	df000015 	stw	fp,0(sp)
 90aa618:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 90aa61c:	d0a09f17 	ldw	r2,-32132(gp)
 90aa620:	1005003a 	cmpeq	r2,r2,zero
 90aa624:	10001f1e 	bne	r2,zero,90aa6a4 <cticks_hook+0x98>
   {
      cticks_factor += TPS;
 90aa628:	d120a217 	ldw	r4,-32120(gp)
 90aa62c:	908ce680 	call	908ce68 <__floatsidf>
 90aa630:	100b883a 	mov	r5,r2
 90aa634:	180d883a 	mov	r6,r3
 90aa638:	2809883a 	mov	r4,r5
 90aa63c:	300b883a 	mov	r5,r6
 90aa640:	000d883a 	mov	r6,zero
 90aa644:	01d01674 	movhi	r7,16473
 90aa648:	908c5400 	call	908c540 <__adddf3>
 90aa64c:	1009883a 	mov	r4,r2
 90aa650:	180b883a 	mov	r5,r3
 90aa654:	2005883a 	mov	r2,r4
 90aa658:	2807883a 	mov	r3,r5
 90aa65c:	1009883a 	mov	r4,r2
 90aa660:	180b883a 	mov	r5,r3
 90aa664:	908cf600 	call	908cf60 <__fixdfsi>
 90aa668:	d0a0a215 	stw	r2,-32120(gp)
      if (cticks_factor >= OS_TPS)
 90aa66c:	d0e0a217 	ldw	r3,-32120(gp)
 90aa670:	d0a0a317 	ldw	r2,-32116(gp)
 90aa674:	18800b16 	blt	r3,r2,90aa6a4 <cticks_hook+0x98>
      {
         cticks++;
 90aa678:	00824374 	movhi	r2,2317
 90aa67c:	108f2e04 	addi	r2,r2,15544
 90aa680:	10800017 	ldw	r2,0(r2)
 90aa684:	10c00044 	addi	r3,r2,1
 90aa688:	00824374 	movhi	r2,2317
 90aa68c:	108f2e04 	addi	r2,r2,15544
 90aa690:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 90aa694:	d0e0a217 	ldw	r3,-32120(gp)
 90aa698:	d0a0a317 	ldw	r2,-32116(gp)
 90aa69c:	1885c83a 	sub	r2,r3,r2
 90aa6a0:	d0a0a215 	stw	r2,-32120(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 90aa6a4:	e037883a 	mov	sp,fp
 90aa6a8:	dfc00117 	ldw	ra,4(sp)
 90aa6ac:	df000017 	ldw	fp,0(sp)
 90aa6b0:	dec00204 	addi	sp,sp,8
 90aa6b4:	f800283a 	ret

090aa6b8 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 90aa6b8:	defffd04 	addi	sp,sp,-12
 90aa6bc:	df000215 	stw	fp,8(sp)
 90aa6c0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90aa6c4:	0005303a 	rdctl	r2,status
 90aa6c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90aa6cc:	e0fffe17 	ldw	r3,-8(fp)
 90aa6d0:	00bfff84 	movi	r2,-2
 90aa6d4:	1884703a 	and	r2,r3,r2
 90aa6d8:	1001703a 	wrctl	status,r2
  
  return context;
 90aa6dc:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 90aa6e0:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 90aa6e4:	d0a0a017 	ldw	r2,-32128(gp)
 90aa6e8:	10800044 	addi	r2,r2,1
 90aa6ec:	d0a0a015 	stw	r2,-32128(gp)
 90aa6f0:	d0a0a017 	ldw	r2,-32128(gp)
 90aa6f4:	10800058 	cmpnei	r2,r2,1
 90aa6f8:	1000021e 	bne	r2,zero,90aa704 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 90aa6fc:	e0bfff17 	ldw	r2,-4(fp)
 90aa700:	d0a0a115 	stw	r2,-32124(gp)
   }
}
 90aa704:	e037883a 	mov	sp,fp
 90aa708:	df000017 	ldw	fp,0(sp)
 90aa70c:	dec00104 	addi	sp,sp,4
 90aa710:	f800283a 	ret

090aa714 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 90aa714:	defffe04 	addi	sp,sp,-8
 90aa718:	df000115 	stw	fp,4(sp)
 90aa71c:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 90aa720:	d0a0a017 	ldw	r2,-32128(gp)
 90aa724:	10bfffc4 	addi	r2,r2,-1
 90aa728:	d0a0a015 	stw	r2,-32128(gp)
 90aa72c:	d0a0a017 	ldw	r2,-32128(gp)
 90aa730:	1004c03a 	cmpne	r2,r2,zero
 90aa734:	1000041e 	bne	r2,zero,90aa748 <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 90aa738:	d0a0a117 	ldw	r2,-32124(gp)
 90aa73c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90aa740:	e0bfff17 	ldw	r2,-4(fp)
 90aa744:	1001703a 	wrctl	status,r2
   }
}
 90aa748:	e037883a 	mov	sp,fp
 90aa74c:	df000017 	ldw	fp,0(sp)
 90aa750:	dec00104 	addi	sp,sp,4
 90aa754:	f800283a 	ret

090aa758 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 90aa758:	defffb04 	addi	sp,sp,-20
 90aa75c:	dfc00415 	stw	ra,16(sp)
 90aa760:	df000315 	stw	fp,12(sp)
 90aa764:	df000304 	addi	fp,sp,12
 90aa768:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90aa76c:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 90aa770:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 90aa774:	e0bfff17 	ldw	r2,-4(fp)
 90aa778:	1004803a 	cmplt	r2,r2,zero
 90aa77c:	1000201e 	bne	r2,zero,90aa800 <LOCK_NET_RESOURCE+0xa8>
 90aa780:	e0bfff17 	ldw	r2,-4(fp)
 90aa784:	10800408 	cmpgei	r2,r2,16
 90aa788:	10001d1e 	bne	r2,zero,90aa800 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 90aa78c:	e0bfff17 	ldw	r2,-4(fp)
 90aa790:	00c243b4 	movhi	r3,2318
 90aa794:	18f70d04 	addi	r3,r3,-9164
 90aa798:	1085883a 	add	r2,r2,r2
 90aa79c:	1085883a 	add	r2,r2,r2
 90aa7a0:	10c5883a 	add	r2,r2,r3
 90aa7a4:	11000017 	ldw	r4,0(r2)
 90aa7a8:	e1bffe04 	addi	r6,fp,-8
 90aa7ac:	000b883a 	mov	r5,zero
 90aa7b0:	9093c5c0 	call	9093c5c <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 90aa7b4:	e0bffe03 	ldbu	r2,-8(fp)
 90aa7b8:	10803fcc 	andi	r2,r2,255
 90aa7bc:	10800298 	cmpnei	r2,r2,10
 90aa7c0:	10000a1e 	bne	r2,zero,90aa7ec <LOCK_NET_RESOURCE+0x94>
 90aa7c4:	e0bffd17 	ldw	r2,-12(fp)
 90aa7c8:	10800044 	addi	r2,r2,1
 90aa7cc:	e0bffd15 	stw	r2,-12(fp)
 90aa7d0:	e0bffd17 	ldw	r2,-12(fp)
 90aa7d4:	1080fa50 	cmplti	r2,r2,1001
 90aa7d8:	1000041e 	bne	r2,zero,90aa7ec <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 90aa7dc:	01024374 	movhi	r4,2317
 90aa7e0:	21015704 	addi	r4,r4,1372
 90aa7e4:	90a537c0 	call	90a537c <panic>
            return;
 90aa7e8:	00000606 	br	90aa804 <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 90aa7ec:	e0bffe03 	ldbu	r2,-8(fp)
 90aa7f0:	10803fcc 	andi	r2,r2,255
 90aa7f4:	108002a0 	cmpeqi	r2,r2,10
 90aa7f8:	103fe41e 	bne	r2,zero,90aa78c <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 90aa7fc:	00000106 	br	90aa804 <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 90aa800:	90aa4780 	call	90aa478 <dtrap>
}
 90aa804:	e037883a 	mov	sp,fp
 90aa808:	dfc00117 	ldw	ra,4(sp)
 90aa80c:	df000017 	ldw	fp,0(sp)
 90aa810:	dec00204 	addi	sp,sp,8
 90aa814:	f800283a 	ret

090aa818 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 90aa818:	defffc04 	addi	sp,sp,-16
 90aa81c:	dfc00315 	stw	ra,12(sp)
 90aa820:	df000215 	stw	fp,8(sp)
 90aa824:	df000204 	addi	fp,sp,8
 90aa828:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90aa82c:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 90aa830:	e0bfff17 	ldw	r2,-4(fp)
 90aa834:	1004803a 	cmplt	r2,r2,zero
 90aa838:	1000131e 	bne	r2,zero,90aa888 <UNLOCK_NET_RESOURCE+0x70>
 90aa83c:	e0bfff17 	ldw	r2,-4(fp)
 90aa840:	10800408 	cmpgei	r2,r2,16
 90aa844:	1000101e 	bne	r2,zero,90aa888 <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 90aa848:	e0bfff17 	ldw	r2,-4(fp)
 90aa84c:	00c243b4 	movhi	r3,2318
 90aa850:	18f70d04 	addi	r3,r3,-9164
 90aa854:	1085883a 	add	r2,r2,r2
 90aa858:	1085883a 	add	r2,r2,r2
 90aa85c:	10c5883a 	add	r2,r2,r3
 90aa860:	11000017 	ldw	r4,0(r2)
 90aa864:	90940540 	call	9094054 <OSSemPost>
 90aa868:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 90aa86c:	e0bffe03 	ldbu	r2,-8(fp)
 90aa870:	1005003a 	cmpeq	r2,r2,zero
 90aa874:	1000051e 	bne	r2,zero,90aa88c <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 90aa878:	01024374 	movhi	r4,2317
 90aa87c:	21015a04 	addi	r4,r4,1384
 90aa880:	90a537c0 	call	90a537c <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 90aa884:	00000106 	br	90aa88c <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 90aa888:	90aa4780 	call	90aa478 <dtrap>
}
 90aa88c:	e037883a 	mov	sp,fp
 90aa890:	dfc00117 	ldw	ra,4(sp)
 90aa894:	df000017 	ldw	fp,0(sp)
 90aa898:	dec00204 	addi	sp,sp,8
 90aa89c:	f800283a 	ret

090aa8a0 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 90aa8a0:	deffed04 	addi	sp,sp,-76
 90aa8a4:	dfc01215 	stw	ra,72(sp)
 90aa8a8:	df001115 	stw	fp,68(sp)
 90aa8ac:	df001104 	addi	fp,sp,68
 90aa8b0:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 90aa8b4:	e0bffe17 	ldw	r2,-8(fp)
 90aa8b8:	10800417 	ldw	r2,16(r2)
 90aa8bc:	1009883a 	mov	r4,r2
 90aa8c0:	90aaefc0 	call	90aaefc <npalloc>
 90aa8c4:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 90aa8c8:	e0bff417 	ldw	r2,-48(fp)
 90aa8cc:	1004c03a 	cmpne	r2,r2,zero
 90aa8d0:	1000031e 	bne	r2,zero,90aa8e0 <TK_NEWTASK+0x40>
      panic("stack alloc");
 90aa8d4:	01024374 	movhi	r4,2317
 90aa8d8:	21015d04 	addi	r4,r4,1396
 90aa8dc:	90a537c0 	call	90a537c <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 90aa8e0:	e0bffe17 	ldw	r2,-8(fp)
 90aa8e4:	11400217 	ldw	r5,8(r2)
 90aa8e8:	e0bffe17 	ldw	r2,-8(fp)
 90aa8ec:	10800417 	ldw	r2,16(r2)
 90aa8f0:	1004d0ba 	srli	r2,r2,2
 90aa8f4:	1085883a 	add	r2,r2,r2
 90aa8f8:	1085883a 	add	r2,r2,r2
 90aa8fc:	1007883a 	mov	r3,r2
 90aa900:	e0bff417 	ldw	r2,-48(fp)
 90aa904:	1885883a 	add	r2,r3,r2
 90aa908:	11bfff04 	addi	r6,r2,-4
 90aa90c:	e0bffe17 	ldw	r2,-8(fp)
 90aa910:	10800317 	ldw	r2,12(r2)
 90aa914:	11c03fcc 	andi	r7,r2,255
 90aa918:	e0bffe17 	ldw	r2,-8(fp)
 90aa91c:	10800317 	ldw	r2,12(r2)
 90aa920:	10ffffcc 	andi	r3,r2,65535
 90aa924:	e0bffe17 	ldw	r2,-8(fp)
 90aa928:	10800417 	ldw	r2,16(r2)
 90aa92c:	1008d0ba 	srli	r4,r2,2
 90aa930:	d8c00015 	stw	r3,0(sp)
 90aa934:	e0bff417 	ldw	r2,-48(fp)
 90aa938:	d8800115 	stw	r2,4(sp)
 90aa93c:	d9000215 	stw	r4,8(sp)
 90aa940:	d8000315 	stw	zero,12(sp)
 90aa944:	008000c4 	movi	r2,3
 90aa948:	d8800415 	stw	r2,16(sp)
 90aa94c:	2809883a 	mov	r4,r5
 90aa950:	000b883a 	mov	r5,zero
 90aa954:	9094af80 	call	9094af8 <OSTaskCreateExt>
 90aa958:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 90aa95c:	e0bff503 	ldbu	r2,-44(fp)
 90aa960:	10803fcc 	andi	r2,r2,255
 90aa964:	10800a18 	cmpnei	r2,r2,40
 90aa968:	1000161e 	bne	r2,zero,90aa9c4 <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 90aa96c:	e0bffe17 	ldw	r2,-8(fp)
 90aa970:	10800317 	ldw	r2,12(r2)
 90aa974:	11003fcc 	andi	r4,r2,255
 90aa978:	e17ff584 	addi	r5,fp,-42
 90aa97c:	e1bff544 	addi	r6,fp,-43
 90aa980:	90952740 	call	9095274 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 90aa984:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 90aa988:	e0bffe17 	ldw	r2,-8(fp)
 90aa98c:	11400117 	ldw	r5,4(r2)
 90aa990:	e0bffe17 	ldw	r2,-8(fp)
 90aa994:	11800317 	ldw	r6,12(r2)
 90aa998:	e0bffe17 	ldw	r2,-8(fp)
 90aa99c:	10800317 	ldw	r2,12(r2)
 90aa9a0:	e1fff584 	addi	r7,fp,-42
 90aa9a4:	d8800015 	stw	r2,0(sp)
 90aa9a8:	01024374 	movhi	r4,2317
 90aa9ac:	21016004 	addi	r4,r4,1408
 90aa9b0:	90833900 	call	9083390 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 90aa9b4:	01024374 	movhi	r4,2317
 90aa9b8:	21017804 	addi	r4,r4,1504
 90aa9bc:	90836b80 	call	90836b8 <puts>
 90aa9c0:	00001e06 	br	90aaa3c <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 90aa9c4:	e0bff503 	ldbu	r2,-44(fp)
 90aa9c8:	10803fcc 	andi	r2,r2,255
 90aa9cc:	10800a98 	cmpnei	r2,r2,42
 90aa9d0:	10000c1e 	bne	r2,zero,90aaa04 <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 90aa9d4:	e0bffe17 	ldw	r2,-8(fp)
 90aa9d8:	11400117 	ldw	r5,4(r2)
 90aa9dc:	e0bffe17 	ldw	r2,-8(fp)
 90aa9e0:	11800317 	ldw	r6,12(r2)
 90aa9e4:	01024374 	movhi	r4,2317
 90aa9e8:	2101a004 	addi	r4,r4,1664
 90aa9ec:	01c00504 	movi	r7,20
 90aa9f0:	90833900 	call	9083390 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 90aa9f4:	01024374 	movhi	r4,2317
 90aa9f8:	2101bd04 	addi	r4,r4,1780
 90aa9fc:	90836b80 	call	90836b8 <puts>
 90aaa00:	00000e06 	br	90aaa3c <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 90aaa04:	e0bff503 	ldbu	r2,-44(fp)
 90aaa08:	10803fcc 	andi	r2,r2,255
 90aaa0c:	1005003a 	cmpeq	r2,r2,zero
 90aaa10:	10000a1e 	bne	r2,zero,90aaa3c <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 90aaa14:	e0bff503 	ldbu	r2,-44(fp)
 90aaa18:	11403fcc 	andi	r5,r2,255
 90aaa1c:	e0bffe17 	ldw	r2,-8(fp)
 90aaa20:	11800117 	ldw	r6,4(r2)
 90aaa24:	01024374 	movhi	r4,2317
 90aaa28:	2101dc04 	addi	r4,r4,1904
 90aaa2c:	90833900 	call	9083390 <printf>
             error, nettask->name);
      return (-1);
 90aaa30:	00bfffc4 	movi	r2,-1
 90aaa34:	e0bfff15 	stw	r2,-4(fp)
 90aaa38:	00001806 	br	90aaa9c <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 90aaa3c:	e0bffe17 	ldw	r2,-8(fp)
 90aaa40:	10800317 	ldw	r2,12(r2)
 90aaa44:	11003fcc 	andi	r4,r2,255
 90aaa48:	e0bffe17 	ldw	r2,-8(fp)
 90aaa4c:	10800117 	ldw	r2,4(r2)
 90aaa50:	100b883a 	mov	r5,r2
 90aaa54:	e1bff504 	addi	r6,fp,-44
 90aaa58:	909542c0 	call	909542c <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 90aaa5c:	e0fff417 	ldw	r3,-48(fp)
 90aaa60:	e0bffe17 	ldw	r2,-8(fp)
 90aaa64:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 90aaa68:	e0bffe17 	ldw	r2,-8(fp)
 90aaa6c:	10c00017 	ldw	r3,0(r2)
 90aaa70:	e0bffe17 	ldw	r2,-8(fp)
 90aaa74:	10800317 	ldw	r2,12(r2)
 90aaa78:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 90aaa7c:	e0bffe17 	ldw	r2,-8(fp)
 90aaa80:	11400117 	ldw	r5,4(r2)
 90aaa84:	e0bffe17 	ldw	r2,-8(fp)
 90aaa88:	11800317 	ldw	r6,12(r2)
 90aaa8c:	01024374 	movhi	r4,2317
 90aaa90:	2101ea04 	addi	r4,r4,1960
 90aaa94:	90833900 	call	9083390 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 90aaa98:	e03fff15 	stw	zero,-4(fp)
 90aaa9c:	e0bfff17 	ldw	r2,-4(fp)
}
 90aaaa0:	e037883a 	mov	sp,fp
 90aaaa4:	dfc00117 	ldw	ra,4(sp)
 90aaaa8:	df000017 	ldw	fp,0(sp)
 90aaaac:	dec00204 	addi	sp,sp,8
 90aaab0:	f800283a 	ret

090aaab4 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 90aaab4:	defffb04 	addi	sp,sp,-20
 90aaab8:	dfc00415 	stw	ra,16(sp)
 90aaabc:	df000315 	stw	fp,12(sp)
 90aaac0:	df000304 	addi	fp,sp,12
 90aaac4:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 90aaac8:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 90aaacc:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 90aaad0:	e0bfff17 	ldw	r2,-4(fp)
 90aaad4:	108001a8 	cmpgeui	r2,r2,6
 90aaad8:	10001d1e 	bne	r2,zero,90aab50 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 90aaadc:	e0bfff17 	ldw	r2,-4(fp)
 90aaae0:	00c243b4 	movhi	r3,2318
 90aaae4:	18f71d04 	addi	r3,r3,-9100
 90aaae8:	1085883a 	add	r2,r2,r2
 90aaaec:	1085883a 	add	r2,r2,r2
 90aaaf0:	10c5883a 	add	r2,r2,r3
 90aaaf4:	11000017 	ldw	r4,0(r2)
 90aaaf8:	e1bffe04 	addi	r6,fp,-8
 90aaafc:	000b883a 	mov	r5,zero
 90aab00:	9093c5c0 	call	9093c5c <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 90aab04:	e0bffe03 	ldbu	r2,-8(fp)
 90aab08:	10803fcc 	andi	r2,r2,255
 90aab0c:	10800298 	cmpnei	r2,r2,10
 90aab10:	10000a1e 	bne	r2,zero,90aab3c <wait_app_sem+0x88>
 90aab14:	e0bffd17 	ldw	r2,-12(fp)
 90aab18:	10800044 	addi	r2,r2,1
 90aab1c:	e0bffd15 	stw	r2,-12(fp)
 90aab20:	e0bffd17 	ldw	r2,-12(fp)
 90aab24:	1080fa50 	cmplti	r2,r2,1001
 90aab28:	1000041e 	bne	r2,zero,90aab3c <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 90aab2c:	01024374 	movhi	r4,2317
 90aab30:	21015704 	addi	r4,r4,1372
 90aab34:	90a537c0 	call	90a537c <panic>
            return;
 90aab38:	00000606 	br	90aab54 <wait_app_sem+0xa0>
         }
      } while (error == 10);
 90aab3c:	e0bffe03 	ldbu	r2,-8(fp)
 90aab40:	10803fcc 	andi	r2,r2,255
 90aab44:	108002a0 	cmpeqi	r2,r2,10
 90aab48:	103fe41e 	bne	r2,zero,90aaadc <wait_app_sem+0x28>
 90aab4c:	00000106 	br	90aab54 <wait_app_sem+0xa0>
   }
   else
      dtrap();
 90aab50:	90aa4780 	call	90aa478 <dtrap>
}
 90aab54:	e037883a 	mov	sp,fp
 90aab58:	dfc00117 	ldw	ra,4(sp)
 90aab5c:	df000017 	ldw	fp,0(sp)
 90aab60:	dec00204 	addi	sp,sp,8
 90aab64:	f800283a 	ret

090aab68 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 90aab68:	defffc04 	addi	sp,sp,-16
 90aab6c:	dfc00315 	stw	ra,12(sp)
 90aab70:	df000215 	stw	fp,8(sp)
 90aab74:	df000204 	addi	fp,sp,8
 90aab78:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 90aab7c:	e0bfff17 	ldw	r2,-4(fp)
 90aab80:	108001a8 	cmpgeui	r2,r2,6
 90aab84:	1000101e 	bne	r2,zero,90aabc8 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 90aab88:	e0bfff17 	ldw	r2,-4(fp)
 90aab8c:	00c243b4 	movhi	r3,2318
 90aab90:	18f71d04 	addi	r3,r3,-9100
 90aab94:	1085883a 	add	r2,r2,r2
 90aab98:	1085883a 	add	r2,r2,r2
 90aab9c:	10c5883a 	add	r2,r2,r3
 90aaba0:	11000017 	ldw	r4,0(r2)
 90aaba4:	90940540 	call	9094054 <OSSemPost>
 90aaba8:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 90aabac:	e0bffe03 	ldbu	r2,-8(fp)
 90aabb0:	1005003a 	cmpeq	r2,r2,zero
 90aabb4:	1000051e 	bne	r2,zero,90aabcc <post_app_sem+0x64>
      {
         panic("unlock NET");
 90aabb8:	01024374 	movhi	r4,2317
 90aabbc:	21015a04 	addi	r4,r4,1384
 90aabc0:	90a537c0 	call	90a537c <panic>
 90aabc4:	00000106 	br	90aabcc <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 90aabc8:	90aa4780 	call	90aa478 <dtrap>
}
 90aabcc:	e037883a 	mov	sp,fp
 90aabd0:	dfc00117 	ldw	ra,4(sp)
 90aabd4:	df000017 	ldw	fp,0(sp)
 90aabd8:	dec00204 	addi	sp,sp,8
 90aabdc:	f800283a 	ret

090aabe0 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 90aabe0:	defffc04 	addi	sp,sp,-16
 90aabe4:	dfc00315 	stw	ra,12(sp)
 90aabe8:	df000215 	stw	fp,8(sp)
 90aabec:	dc000115 	stw	r16,4(sp)
 90aabf0:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 90aabf4:	01000044 	movi	r4,1
 90aabf8:	90938a80 	call	90938a8 <OSSemCreate>
 90aabfc:	d0a0ab15 	stw	r2,-32084(gp)
   if (!mheap_sem_ptr)
 90aac00:	d0a0ab17 	ldw	r2,-32084(gp)
 90aac04:	1004c03a 	cmpne	r2,r2,zero
 90aac08:	1000031e 	bne	r2,zero,90aac18 <alt_iniche_init+0x38>
      panic("mheap_sem_ptr create err"); 
 90aac0c:	01024374 	movhi	r4,2317
 90aac10:	2101f204 	addi	r4,r4,1992
 90aac14:	90a537c0 	call	90a537c <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 90aac18:	0009883a 	mov	r4,zero
 90aac1c:	90938a80 	call	90938a8 <OSSemCreate>
 90aac20:	d0a0ac15 	stw	r2,-32080(gp)
   if (!rcvdq_sem_ptr)
 90aac24:	d0a0ac17 	ldw	r2,-32080(gp)
 90aac28:	1004c03a 	cmpne	r2,r2,zero
 90aac2c:	1000031e 	bne	r2,zero,90aac3c <alt_iniche_init+0x5c>
      panic("rcvdq_sem_ptr create err"); 
 90aac30:	01024374 	movhi	r4,2317
 90aac34:	2101f904 	addi	r4,r4,2020
 90aac38:	90a537c0 	call	90a537c <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 90aac3c:	e03fff15 	stw	zero,-4(fp)
 90aac40:	00001906 	br	90aaca8 <alt_iniche_init+0xc8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 90aac44:	e43fff17 	ldw	r16,-4(fp)
 90aac48:	01000044 	movi	r4,1
 90aac4c:	90938a80 	call	90938a8 <OSSemCreate>
 90aac50:	1009883a 	mov	r4,r2
 90aac54:	00c243b4 	movhi	r3,2318
 90aac58:	18f70d04 	addi	r3,r3,-9164
 90aac5c:	8405883a 	add	r2,r16,r16
 90aac60:	1085883a 	add	r2,r2,r2
 90aac64:	10c5883a 	add	r2,r2,r3
 90aac68:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 90aac6c:	e0bfff17 	ldw	r2,-4(fp)
 90aac70:	00c243b4 	movhi	r3,2318
 90aac74:	18f70d04 	addi	r3,r3,-9164
 90aac78:	1085883a 	add	r2,r2,r2
 90aac7c:	1085883a 	add	r2,r2,r2
 90aac80:	10c5883a 	add	r2,r2,r3
 90aac84:	10800017 	ldw	r2,0(r2)
 90aac88:	1004c03a 	cmpne	r2,r2,zero
 90aac8c:	1000031e 	bne	r2,zero,90aac9c <alt_iniche_init+0xbc>
         panic("resid_semaphore create err");  
 90aac90:	01024374 	movhi	r4,2317
 90aac94:	21020004 	addi	r4,r4,2048
 90aac98:	90a537c0 	call	90a537c <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 90aac9c:	e0bfff17 	ldw	r2,-4(fp)
 90aaca0:	10800044 	addi	r2,r2,1
 90aaca4:	e0bfff15 	stw	r2,-4(fp)
 90aaca8:	e0bfff17 	ldw	r2,-4(fp)
 90aacac:	10800410 	cmplti	r2,r2,16
 90aacb0:	103fe41e 	bne	r2,zero,90aac44 <alt_iniche_init+0x64>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 90aacb4:	e03fff15 	stw	zero,-4(fp)
 90aacb8:	00001906 	br	90aad20 <alt_iniche_init+0x140>
   {
      app_semaphore[i] = OSSemCreate(1);
 90aacbc:	e43fff17 	ldw	r16,-4(fp)
 90aacc0:	01000044 	movi	r4,1
 90aacc4:	90938a80 	call	90938a8 <OSSemCreate>
 90aacc8:	1009883a 	mov	r4,r2
 90aaccc:	00c243b4 	movhi	r3,2318
 90aacd0:	18f71d04 	addi	r3,r3,-9100
 90aacd4:	8405883a 	add	r2,r16,r16
 90aacd8:	1085883a 	add	r2,r2,r2
 90aacdc:	10c5883a 	add	r2,r2,r3
 90aace0:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 90aace4:	e0bfff17 	ldw	r2,-4(fp)
 90aace8:	00c243b4 	movhi	r3,2318
 90aacec:	18f71d04 	addi	r3,r3,-9100
 90aacf0:	1085883a 	add	r2,r2,r2
 90aacf4:	1085883a 	add	r2,r2,r2
 90aacf8:	10c5883a 	add	r2,r2,r3
 90aacfc:	10800017 	ldw	r2,0(r2)
 90aad00:	1004c03a 	cmpne	r2,r2,zero
 90aad04:	1000031e 	bne	r2,zero,90aad14 <alt_iniche_init+0x134>
         panic("app_semaphore create err");  
 90aad08:	01024374 	movhi	r4,2317
 90aad0c:	21020704 	addi	r4,r4,2076
 90aad10:	90a537c0 	call	90a537c <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 90aad14:	e0bfff17 	ldw	r2,-4(fp)
 90aad18:	10800044 	addi	r2,r2,1
 90aad1c:	e0bfff15 	stw	r2,-4(fp)
 90aad20:	e0bfff17 	ldw	r2,-4(fp)
 90aad24:	10800190 	cmplti	r2,r2,6
 90aad28:	103fe41e 	bne	r2,zero,90aacbc <alt_iniche_init+0xdc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 90aad2c:	e03fff15 	stw	zero,-4(fp)
 90aad30:	00002606 	br	90aadcc <alt_iniche_init+0x1ec>
   {
      global_TCPwakeup_set[i].ctick = 0;
 90aad34:	e0bfff17 	ldw	r2,-4(fp)
 90aad38:	00c243b4 	movhi	r3,2318
 90aad3c:	18f6d104 	addi	r3,r3,-9404
 90aad40:	10800324 	muli	r2,r2,12
 90aad44:	10c5883a 	add	r2,r2,r3
 90aad48:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 90aad4c:	e0bfff17 	ldw	r2,-4(fp)
 90aad50:	00c243b4 	movhi	r3,2318
 90aad54:	18f6d104 	addi	r3,r3,-9404
 90aad58:	10800324 	muli	r2,r2,12
 90aad5c:	10c5883a 	add	r2,r2,r3
 90aad60:	10800104 	addi	r2,r2,4
 90aad64:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 90aad68:	e43fff17 	ldw	r16,-4(fp)
 90aad6c:	0009883a 	mov	r4,zero
 90aad70:	90938a80 	call	90938a8 <OSSemCreate>
 90aad74:	1009883a 	mov	r4,r2
 90aad78:	00c243b4 	movhi	r3,2318
 90aad7c:	18f6d104 	addi	r3,r3,-9404
 90aad80:	80800324 	muli	r2,r16,12
 90aad84:	10c5883a 	add	r2,r2,r3
 90aad88:	10800204 	addi	r2,r2,8
 90aad8c:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 90aad90:	e0bfff17 	ldw	r2,-4(fp)
 90aad94:	00c243b4 	movhi	r3,2318
 90aad98:	18f6d104 	addi	r3,r3,-9404
 90aad9c:	10800324 	muli	r2,r2,12
 90aada0:	10c5883a 	add	r2,r2,r3
 90aada4:	10800204 	addi	r2,r2,8
 90aada8:	10800017 	ldw	r2,0(r2)
 90aadac:	1004c03a 	cmpne	r2,r2,zero
 90aadb0:	1000031e 	bne	r2,zero,90aadc0 <alt_iniche_init+0x1e0>
         panic("globwake_semaphore create err");  
 90aadb4:	01024374 	movhi	r4,2317
 90aadb8:	21020e04 	addi	r4,r4,2104
 90aadbc:	90a537c0 	call	90a537c <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 90aadc0:	e0bfff17 	ldw	r2,-4(fp)
 90aadc4:	10800044 	addi	r2,r2,1
 90aadc8:	e0bfff15 	stw	r2,-4(fp)
 90aadcc:	e0bfff17 	ldw	r2,-4(fp)
 90aadd0:	10800510 	cmplti	r2,r2,20
 90aadd4:	103fd71e 	bne	r2,zero,90aad34 <alt_iniche_init+0x154>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 90aadd8:	00824374 	movhi	r2,2317
 90aaddc:	108f2d04 	addi	r2,r2,15540
 90aade0:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 90aade4:	e037883a 	mov	sp,fp
 90aade8:	dfc00217 	ldw	ra,8(sp)
 90aadec:	df000117 	ldw	fp,4(sp)
 90aadf0:	dc000017 	ldw	r16,0(sp)
 90aadf4:	dec00304 	addi	sp,sp,12
 90aadf8:	f800283a 	ret

090aadfc <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 90aadfc:	deffff04 	addi	sp,sp,-4
 90aae00:	df000015 	stw	fp,0(sp)
 90aae04:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 90aae08:	00c24374 	movhi	r3,2317
 90aae0c:	18cebb04 	addi	r3,r3,15084
 90aae10:	00800784 	movi	r2,30
 90aae14:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 90aae18:	00c24374 	movhi	r3,2317
 90aae1c:	18ceb904 	addi	r3,r3,15076
 90aae20:	00800784 	movi	r2,30
 90aae24:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 90aae28:	00c24374 	movhi	r3,2317
 90aae2c:	18cebc04 	addi	r3,r3,15088
 90aae30:	00818004 	movi	r2,1536
 90aae34:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 90aae38:	00c24374 	movhi	r3,2317
 90aae3c:	18ceba04 	addi	r3,r3,15080
 90aae40:	00802004 	movi	r2,128
 90aae44:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 90aae48:	00c24374 	movhi	r3,2317
 90aae4c:	18cf5004 	addi	r3,r3,15680
 90aae50:	008242f4 	movhi	r2,2315
 90aae54:	10aba404 	addi	r2,r2,-20848
 90aae58:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 90aae5c:	0005883a 	mov	r2,zero
}
 90aae60:	e037883a 	mov	sp,fp
 90aae64:	df000017 	ldw	fp,0(sp)
 90aae68:	dec00104 	addi	sp,sp,4
 90aae6c:	f800283a 	ret

090aae70 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 90aae70:	deffff04 	addi	sp,sp,-4
 90aae74:	df000015 	stw	fp,0(sp)
 90aae78:	d839883a 	mov	fp,sp
   return NULL;
 90aae7c:	0005883a 	mov	r2,zero
}
 90aae80:	e037883a 	mov	sp,fp
 90aae84:	df000017 	ldw	fp,0(sp)
 90aae88:	dec00104 	addi	sp,sp,4
 90aae8c:	f800283a 	ret

090aae90 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 90aae90:	defffd04 	addi	sp,sp,-12
 90aae94:	dfc00215 	stw	ra,8(sp)
 90aae98:	df000115 	stw	fp,4(sp)
 90aae9c:	df000104 	addi	fp,sp,4
 90aaea0:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 90aaea4:	e13fff17 	ldw	r4,-4(fp)
 90aaea8:	90a1be00 	call	90a1be0 <iniche_devices_init>
 90aaeac:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 90aaeb0:	e0bfff17 	ldw	r2,-4(fp)
}
 90aaeb4:	e037883a 	mov	sp,fp
 90aaeb8:	dfc00117 	ldw	ra,4(sp)
 90aaebc:	df000017 	ldw	fp,0(sp)
 90aaec0:	dec00204 	addi	sp,sp,8
 90aaec4:	f800283a 	ret

090aaec8 <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 90aaec8:	defffd04 	addi	sp,sp,-12
 90aaecc:	dfc00215 	stw	ra,8(sp)
 90aaed0:	df000115 	stw	fp,4(sp)
 90aaed4:	df000104 	addi	fp,sp,4
 90aaed8:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 90aaedc:	01000044 	movi	r4,1
 90aaee0:	e17fff17 	ldw	r5,-4(fp)
 90aaee4:	90cb3d80 	call	90cb3d8 <calloc>
}
 90aaee8:	e037883a 	mov	sp,fp
 90aaeec:	dfc00117 	ldw	ra,4(sp)
 90aaef0:	df000017 	ldw	fp,0(sp)
 90aaef4:	dec00204 	addi	sp,sp,8
 90aaef8:	f800283a 	ret

090aaefc <npalloc>:


char *
npalloc(unsigned size)
{
 90aaefc:	defff904 	addi	sp,sp,-28
 90aaf00:	dfc00615 	stw	ra,24(sp)
 90aaf04:	df000515 	stw	fp,20(sp)
 90aaf08:	df000504 	addi	fp,sp,20
 90aaf0c:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 90aaf10:	d120ab17 	ldw	r4,-32084(gp)
 90aaf14:	e1bffd04 	addi	r6,fp,-12
 90aaf18:	000b883a 	mov	r5,zero
 90aaf1c:	9093c5c0 	call	9093c5c <OSSemPend>
   if(err)
 90aaf20:	e0bffd03 	ldbu	r2,-12(fp)
 90aaf24:	10803fcc 	andi	r2,r2,255
 90aaf28:	1005003a 	cmpeq	r2,r2,zero
 90aaf2c:	1000181e 	bne	r2,zero,90aaf90 <npalloc+0x94>
   {
      int errct = 0;
 90aaf30:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 90aaf34:	00001206 	br	90aaf80 <npalloc+0x84>
      {
         if(errct++ > 1000)
 90aaf38:	e0bffb17 	ldw	r2,-20(fp)
 90aaf3c:	1080fa48 	cmpgei	r2,r2,1001
 90aaf40:	1007883a 	mov	r3,r2
 90aaf44:	e0bffb17 	ldw	r2,-20(fp)
 90aaf48:	10800044 	addi	r2,r2,1
 90aaf4c:	e0bffb15 	stw	r2,-20(fp)
 90aaf50:	18803fcc 	andi	r2,r3,255
 90aaf54:	1005003a 	cmpeq	r2,r2,zero
 90aaf58:	1000051e 	bne	r2,zero,90aaf70 <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 90aaf5c:	01024374 	movhi	r4,2317
 90aaf60:	21021604 	addi	r4,r4,2136
 90aaf64:	90a537c0 	call	90a537c <panic>
            return NULL;
 90aaf68:	e03fff15 	stw	zero,-4(fp)
 90aaf6c:	00001a06 	br	90aafd8 <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 90aaf70:	d120ab17 	ldw	r4,-32084(gp)
 90aaf74:	e1bffd04 	addi	r6,fp,-12
 90aaf78:	000b883a 	mov	r5,zero
 90aaf7c:	9093c5c0 	call	9093c5c <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 90aaf80:	e0bffd03 	ldbu	r2,-12(fp)
 90aaf84:	10803fcc 	andi	r2,r2,255
 90aaf88:	108002a0 	cmpeqi	r2,r2,10
 90aaf8c:	103fea1e 	bne	r2,zero,90aaf38 <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 90aaf90:	e13ffe17 	ldw	r4,-8(fp)
 90aaf94:	90aaec80 	call	90aaec8 <calloc2>
 90aaf98:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 90aaf9c:	d120ab17 	ldw	r4,-32084(gp)
 90aafa0:	90940540 	call	9094054 <OSSemPost>
 90aafa4:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 90aafa8:	e0bffc17 	ldw	r2,-16(fp)
 90aafac:	1004c03a 	cmpne	r2,r2,zero
 90aafb0:	1000021e 	bne	r2,zero,90aafbc <npalloc+0xc0>
      return NULL;
 90aafb4:	e03fff15 	stw	zero,-4(fp)
 90aafb8:	00000706 	br	90aafd8 <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 90aafbc:	e0bffc17 	ldw	r2,-16(fp)
 90aafc0:	1009883a 	mov	r4,r2
 90aafc4:	e1bffe17 	ldw	r6,-8(fp)
 90aafc8:	000b883a 	mov	r5,zero
 90aafcc:	90832780 	call	9083278 <memset>
   return ptr;      
 90aafd0:	e0bffc17 	ldw	r2,-16(fp)
 90aafd4:	e0bfff15 	stw	r2,-4(fp)
 90aafd8:	e0bfff17 	ldw	r2,-4(fp)
}
 90aafdc:	e037883a 	mov	sp,fp
 90aafe0:	dfc00117 	ldw	ra,4(sp)
 90aafe4:	df000017 	ldw	fp,0(sp)
 90aafe8:	dec00204 	addi	sp,sp,8
 90aafec:	f800283a 	ret

090aaff0 <npfree>:

void
npfree(void * ptr)
{
 90aaff0:	defffb04 	addi	sp,sp,-20
 90aaff4:	dfc00415 	stw	ra,16(sp)
 90aaff8:	df000315 	stw	fp,12(sp)
 90aaffc:	df000304 	addi	fp,sp,12
 90ab000:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 90ab004:	d120ab17 	ldw	r4,-32084(gp)
 90ab008:	e1bffe04 	addi	r6,fp,-8
 90ab00c:	000b883a 	mov	r5,zero
 90ab010:	9093c5c0 	call	9093c5c <OSSemPend>
   if (err)
 90ab014:	e0bffe03 	ldbu	r2,-8(fp)
 90ab018:	10803fcc 	andi	r2,r2,255
 90ab01c:	1005003a 	cmpeq	r2,r2,zero
 90ab020:	1000171e 	bne	r2,zero,90ab080 <npfree+0x90>
   {
      int errct = 0;
 90ab024:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 90ab028:	00001106 	br	90ab070 <npfree+0x80>
      {
         if (errct++ > 1000)
 90ab02c:	e0bffd17 	ldw	r2,-12(fp)
 90ab030:	1080fa48 	cmpgei	r2,r2,1001
 90ab034:	1007883a 	mov	r3,r2
 90ab038:	e0bffd17 	ldw	r2,-12(fp)
 90ab03c:	10800044 	addi	r2,r2,1
 90ab040:	e0bffd15 	stw	r2,-12(fp)
 90ab044:	18803fcc 	andi	r2,r3,255
 90ab048:	1005003a 	cmpeq	r2,r2,zero
 90ab04c:	1000041e 	bne	r2,zero,90ab060 <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 90ab050:	01024374 	movhi	r4,2317
 90ab054:	21021804 	addi	r4,r4,2144
 90ab058:	90a537c0 	call	90a537c <panic>
            return;
 90ab05c:	00000d06 	br	90ab094 <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 90ab060:	d120ab17 	ldw	r4,-32084(gp)
 90ab064:	e1bffe04 	addi	r6,fp,-8
 90ab068:	000b883a 	mov	r5,zero
 90ab06c:	9093c5c0 	call	9093c5c <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 90ab070:	e0bffe03 	ldbu	r2,-8(fp)
 90ab074:	10803fcc 	andi	r2,r2,255
 90ab078:	108002a0 	cmpeqi	r2,r2,10
 90ab07c:	103feb1e 	bne	r2,zero,90ab02c <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 90ab080:	e13fff17 	ldw	r4,-4(fp)
 90ab084:	90cb42c0 	call	90cb42c <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 90ab088:	d120ab17 	ldw	r4,-32084(gp)
 90ab08c:	90940540 	call	9094054 <OSSemPost>
 90ab090:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 90ab094:	e037883a 	mov	sp,fp
 90ab098:	dfc00117 	ldw	ra,4(sp)
 90ab09c:	df000017 	ldw	fp,0(sp)
 90ab0a0:	dec00204 	addi	sp,sp,8
 90ab0a4:	f800283a 	ret

090ab0a8 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 90ab0a8:	defffc04 	addi	sp,sp,-16
 90ab0ac:	dfc00315 	stw	ra,12(sp)
 90ab0b0:	df000215 	stw	fp,8(sp)
 90ab0b4:	df000204 	addi	fp,sp,8
 90ab0b8:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 90ab0bc:	e13fff17 	ldw	r4,-4(fp)
 90ab0c0:	90aaefc0 	call	90aaefc <npalloc>
 90ab0c4:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 90ab0c8:	e0bffe17 	ldw	r2,-8(fp)
 90ab0cc:	1005003a 	cmpeq	r2,r2,zero
 90ab0d0:	1000041e 	bne	r2,zero,90ab0e4 <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 90ab0d4:	e13ffe17 	ldw	r4,-8(fp)
 90ab0d8:	e17fff17 	ldw	r5,-4(fp)
 90ab0dc:	90ba83c0 	call	90ba83c <alt_remap_uncached>
 90ab0e0:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 90ab0e4:	e0bffe17 	ldw	r2,-8(fp)
}
 90ab0e8:	e037883a 	mov	sp,fp
 90ab0ec:	dfc00117 	ldw	ra,4(sp)
 90ab0f0:	df000017 	ldw	fp,0(sp)
 90ab0f4:	dec00204 	addi	sp,sp,8
 90ab0f8:	f800283a 	ret

090ab0fc <ncpfree>:

void ncpfree(void *ptr)
{
 90ab0fc:	defffd04 	addi	sp,sp,-12
 90ab100:	dfc00215 	stw	ra,8(sp)
 90ab104:	df000115 	stw	fp,4(sp)
 90ab108:	df000104 	addi	fp,sp,4
 90ab10c:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 90ab110:	e0bfff17 	ldw	r2,-4(fp)
 90ab114:	1005003a 	cmpeq	r2,r2,zero
 90ab118:	1000061e 	bne	r2,zero,90ab134 <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 90ab11c:	e13fff17 	ldw	r4,-4(fp)
 90ab120:	01400104 	movi	r5,4
 90ab124:	90ba8040 	call	90ba804 <alt_remap_cached>
 90ab128:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 90ab12c:	e13fff17 	ldw	r4,-4(fp)
 90ab130:	90aaff00 	call	90aaff0 <npfree>
   }
}
 90ab134:	e037883a 	mov	sp,fp
 90ab138:	dfc00117 	ldw	ra,4(sp)
 90ab13c:	df000017 	ldw	fp,0(sp)
 90ab140:	dec00204 	addi	sp,sp,8
 90ab144:	f800283a 	ret

090ab148 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 90ab148:	defffb04 	addi	sp,sp,-20
 90ab14c:	dfc00415 	stw	ra,16(sp)
 90ab150:	df000315 	stw	fp,12(sp)
 90ab154:	df000304 	addi	fp,sp,12
 90ab158:	e13ffd15 	stw	r4,-12(fp)
 90ab15c:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 90ab160:	e0bffd17 	ldw	r2,-12(fp)
 90ab164:	108000a0 	cmpeqi	r2,r2,2
 90ab168:	1000031e 	bne	r2,zero,90ab178 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 90ab16c:	90aa4780 	call	90aa478 <dtrap>
         return NULL;
 90ab170:	e03fff15 	stw	zero,-4(fp)
 90ab174:	00001606 	br	90ab1d0 <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 90ab178:	e0bffe17 	ldw	r2,-8(fp)
 90ab17c:	10800058 	cmpnei	r2,r2,1
 90ab180:	1000041e 	bne	r2,zero,90ab194 <pffindtype+0x4c>
      return &tcp_protosw;
 90ab184:	00824374 	movhi	r2,2317
 90ab188:	108d9f04 	addi	r2,r2,13948
 90ab18c:	e0bfff15 	stw	r2,-4(fp)
 90ab190:	00000f06 	br	90ab1d0 <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 90ab194:	e0bffe17 	ldw	r2,-8(fp)
 90ab198:	10800098 	cmpnei	r2,r2,2
 90ab19c:	1000041e 	bne	r2,zero,90ab1b0 <pffindtype+0x68>
      return &udp_protosw;
 90ab1a0:	00824374 	movhi	r2,2317
 90ab1a4:	108da504 	addi	r2,r2,13972
 90ab1a8:	e0bfff15 	stw	r2,-4(fp)
 90ab1ac:	00000806 	br	90ab1d0 <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 90ab1b0:	e0bffe17 	ldw	r2,-8(fp)
 90ab1b4:	108000d8 	cmpnei	r2,r2,3
 90ab1b8:	1000041e 	bne	r2,zero,90ab1cc <pffindtype+0x84>
      return &rawip_protosw;
 90ab1bc:	00824374 	movhi	r2,2317
 90ab1c0:	108dab04 	addi	r2,r2,13996
 90ab1c4:	e0bfff15 	stw	r2,-4(fp)
 90ab1c8:	00000106 	br	90ab1d0 <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 90ab1cc:	e03fff15 	stw	zero,-4(fp)
 90ab1d0:	e0bfff17 	ldw	r2,-4(fp)
}
 90ab1d4:	e037883a 	mov	sp,fp
 90ab1d8:	dfc00117 	ldw	ra,4(sp)
 90ab1dc:	df000017 	ldw	fp,0(sp)
 90ab1e0:	dec00204 	addi	sp,sp,8
 90ab1e4:	f800283a 	ret

090ab1e8 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 90ab1e8:	defff904 	addi	sp,sp,-28
 90ab1ec:	dfc00615 	stw	ra,24(sp)
 90ab1f0:	df000515 	stw	fp,20(sp)
 90ab1f4:	df000504 	addi	fp,sp,20
 90ab1f8:	e13ffb15 	stw	r4,-20(fp)
 90ab1fc:	e17ffc15 	stw	r5,-16(fp)
 90ab200:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 90ab204:	e0bffd17 	ldw	r2,-12(fp)
 90ab208:	108000d8 	cmpnei	r2,r2,3
 90ab20c:	1000051e 	bne	r2,zero,90ab224 <pffindproto+0x3c>
      return(pffindtype(domain, type));
 90ab210:	e13ffb17 	ldw	r4,-20(fp)
 90ab214:	e17ffd17 	ldw	r5,-12(fp)
 90ab218:	90ab1480 	call	90ab148 <pffindtype>
 90ab21c:	e0bffe15 	stw	r2,-8(fp)
 90ab220:	00001f06 	br	90ab2a0 <pffindproto+0xb8>
#endif

   switch (protocol)
 90ab224:	e0bffc17 	ldw	r2,-16(fp)
 90ab228:	e0bfff15 	stw	r2,-4(fp)
 90ab22c:	e0ffff17 	ldw	r3,-4(fp)
 90ab230:	188001a0 	cmpeqi	r2,r3,6
 90ab234:	1000071e 	bne	r2,zero,90ab254 <pffindproto+0x6c>
 90ab238:	e0ffff17 	ldw	r3,-4(fp)
 90ab23c:	18800460 	cmpeqi	r2,r3,17
 90ab240:	10000a1e 	bne	r2,zero,90ab26c <pffindproto+0x84>
 90ab244:	e0ffff17 	ldw	r3,-4(fp)
 90ab248:	1805003a 	cmpeq	r2,r3,zero
 90ab24c:	1000101e 	bne	r2,zero,90ab290 <pffindproto+0xa8>
 90ab250:	00000c06 	br	90ab284 <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 90ab254:	e0bffd17 	ldw	r2,-12(fp)
 90ab258:	10800060 	cmpeqi	r2,r2,1
 90ab25c:	10000c1e 	bne	r2,zero,90ab290 <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 90ab260:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90ab264:	e03ffe15 	stw	zero,-8(fp)
 90ab268:	00000d06 	br	90ab2a0 <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 90ab26c:	e0bffd17 	ldw	r2,-12(fp)
 90ab270:	108000a0 	cmpeqi	r2,r2,2
 90ab274:	1000061e 	bne	r2,zero,90ab290 <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 90ab278:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90ab27c:	e03ffe15 	stw	zero,-8(fp)
 90ab280:	00000706 	br	90ab2a0 <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 90ab284:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90ab288:	e03ffe15 	stw	zero,-8(fp)
 90ab28c:	00000406 	br	90ab2a0 <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 90ab290:	e13ffb17 	ldw	r4,-20(fp)
 90ab294:	e17ffd17 	ldw	r5,-12(fp)
 90ab298:	90ab1480 	call	90ab148 <pffindtype>
 90ab29c:	e0bffe15 	stw	r2,-8(fp)
 90ab2a0:	e0bffe17 	ldw	r2,-8(fp)
}
 90ab2a4:	e037883a 	mov	sp,fp
 90ab2a8:	dfc00117 	ldw	ra,4(sp)
 90ab2ac:	df000017 	ldw	fp,0(sp)
 90ab2b0:	dec00204 	addi	sp,sp,8
 90ab2b4:	f800283a 	ret

090ab2b8 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 90ab2b8:	defff904 	addi	sp,sp,-28
 90ab2bc:	dfc00615 	stw	ra,24(sp)
 90ab2c0:	df000515 	stw	fp,20(sp)
 90ab2c4:	df000504 	addi	fp,sp,20
 90ab2c8:	e13ffd15 	stw	r4,-12(fp)
 90ab2cc:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 90ab2d0:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 90ab2d4:	e0bffd17 	ldw	r2,-12(fp)
 90ab2d8:	10800050 	cmplti	r2,r2,1
 90ab2dc:	1000031e 	bne	r2,zero,90ab2ec <m_getnbuf+0x34>
 90ab2e0:	e0bffd17 	ldw	r2,-12(fp)
 90ab2e4:	10800390 	cmplti	r2,r2,14
 90ab2e8:	1000011e 	bne	r2,zero,90ab2f0 <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 90ab2ec:	90aa4780 	call	90aa478 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 90ab2f0:	e0bffe17 	ldw	r2,-8(fp)
 90ab2f4:	1005003a 	cmpeq	r2,r2,zero
 90ab2f8:	10000e1e 	bne	r2,zero,90ab334 <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90ab2fc:	01000084 	movi	r4,2
 90ab300:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 90ab304:	e0bffe17 	ldw	r2,-8(fp)
 90ab308:	10800e04 	addi	r2,r2,56
 90ab30c:	1009883a 	mov	r4,r2
 90ab310:	90a98340 	call	90a9834 <pk_alloc>
 90ab314:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ab318:	01000084 	movi	r4,2
 90ab31c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 90ab320:	e0bffb17 	ldw	r2,-20(fp)
 90ab324:	1004c03a 	cmpne	r2,r2,zero
 90ab328:	1000021e 	bne	r2,zero,90ab334 <m_getnbuf+0x7c>
         return NULL;
 90ab32c:	e03fff15 	stw	zero,-4(fp)
 90ab330:	00004506 	br	90ab448 <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 90ab334:	010243b4 	movhi	r4,2318
 90ab338:	21373c04 	addi	r4,r4,-8976
 90ab33c:	90a9d400 	call	90a9d40 <getq>
 90ab340:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 90ab344:	e0bffc17 	ldw	r2,-16(fp)
 90ab348:	1004c03a 	cmpne	r2,r2,zero
 90ab34c:	10000b1e 	bne	r2,zero,90ab37c <m_getnbuf+0xc4>
   {
      if (pkt) 
 90ab350:	e0bffb17 	ldw	r2,-20(fp)
 90ab354:	1005003a 	cmpeq	r2,r2,zero
 90ab358:	1000061e 	bne	r2,zero,90ab374 <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90ab35c:	01000084 	movi	r4,2
 90ab360:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90ab364:	e13ffb17 	ldw	r4,-20(fp)
 90ab368:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ab36c:	01000084 	movi	r4,2
 90ab370:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 90ab374:	e03fff15 	stw	zero,-4(fp)
 90ab378:	00003306 	br	90ab448 <m_getnbuf+0x190>
   }
   m->m_type = type;
 90ab37c:	e0fffc17 	ldw	r3,-16(fp)
 90ab380:	e0bffd17 	ldw	r2,-12(fp)
 90ab384:	18800815 	stw	r2,32(r3)
   if (len == 0)
 90ab388:	e0bffe17 	ldw	r2,-8(fp)
 90ab38c:	1004c03a 	cmpne	r2,r2,zero
 90ab390:	1000071e 	bne	r2,zero,90ab3b0 <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 90ab394:	e0bffc17 	ldw	r2,-16(fp)
 90ab398:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 90ab39c:	e0bffc17 	ldw	r2,-16(fp)
 90ab3a0:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 90ab3a4:	e0bffc17 	ldw	r2,-16(fp)
 90ab3a8:	10000515 	stw	zero,20(r2)
 90ab3ac:	00001506 	br	90ab404 <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 90ab3b0:	e0fffc17 	ldw	r3,-16(fp)
 90ab3b4:	e0bffb17 	ldw	r2,-20(fp)
 90ab3b8:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 90ab3bc:	e0bffb17 	ldw	r2,-20(fp)
 90ab3c0:	10800117 	ldw	r2,4(r2)
 90ab3c4:	10c00e04 	addi	r3,r2,56
 90ab3c8:	e0bffb17 	ldw	r2,-20(fp)
 90ab3cc:	10c00315 	stw	r3,12(r2)
 90ab3d0:	e0bffb17 	ldw	r2,-20(fp)
 90ab3d4:	10c00317 	ldw	r3,12(r2)
 90ab3d8:	e0bffc17 	ldw	r2,-16(fp)
 90ab3dc:	10c00315 	stw	r3,12(r2)
 90ab3e0:	e0bffc17 	ldw	r2,-16(fp)
 90ab3e4:	10c00317 	ldw	r3,12(r2)
 90ab3e8:	e0bffc17 	ldw	r2,-16(fp)
 90ab3ec:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 90ab3f0:	e0bffb17 	ldw	r2,-20(fp)
 90ab3f4:	10800217 	ldw	r2,8(r2)
 90ab3f8:	10fff204 	addi	r3,r2,-56
 90ab3fc:	e0bffc17 	ldw	r2,-16(fp)
 90ab400:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 90ab404:	e0bffc17 	ldw	r2,-16(fp)
 90ab408:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 90ab40c:	e0bffc17 	ldw	r2,-16(fp)
 90ab410:	10000715 	stw	zero,28(r2)
 90ab414:	e0bffc17 	ldw	r2,-16(fp)
 90ab418:	10c00717 	ldw	r3,28(r2)
 90ab41c:	e0bffc17 	ldw	r2,-16(fp)
 90ab420:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 90ab424:	d0a0af17 	ldw	r2,-32068(gp)
 90ab428:	10800044 	addi	r2,r2,1
 90ab42c:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mbufq, (qp)m);
 90ab430:	e17ffc17 	ldw	r5,-16(fp)
 90ab434:	010243b4 	movhi	r4,2318
 90ab438:	21373704 	addi	r4,r4,-8996
 90ab43c:	90a9e080 	call	90a9e08 <putq>
   return m;
 90ab440:	e0bffc17 	ldw	r2,-16(fp)
 90ab444:	e0bfff15 	stw	r2,-4(fp)
 90ab448:	e0bfff17 	ldw	r2,-4(fp)
}
 90ab44c:	e037883a 	mov	sp,fp
 90ab450:	dfc00117 	ldw	ra,4(sp)
 90ab454:	df000017 	ldw	fp,0(sp)
 90ab458:	dec00204 	addi	sp,sp,8
 90ab45c:	f800283a 	ret

090ab460 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 90ab460:	defffb04 	addi	sp,sp,-20
 90ab464:	dfc00415 	stw	ra,16(sp)
 90ab468:	df000315 	stw	fp,12(sp)
 90ab46c:	df000304 	addi	fp,sp,12
 90ab470:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 90ab474:	008243b4 	movhi	r2,2318
 90ab478:	10b73704 	addi	r2,r2,-8996
 90ab47c:	10800217 	ldw	r2,8(r2)
 90ab480:	10800048 	cmpgei	r2,r2,1
 90ab484:	1000031e 	bne	r2,zero,90ab494 <m_free+0x34>
      panic("mfree: q_len");
 90ab488:	01024374 	movhi	r4,2317
 90ab48c:	21021a04 	addi	r4,r4,2152
 90ab490:	90a537c0 	call	90a537c <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 90ab494:	e0bffe17 	ldw	r2,-8(fp)
 90ab498:	10800817 	ldw	r2,32(r2)
 90ab49c:	10800050 	cmplti	r2,r2,1
 90ab4a0:	1000041e 	bne	r2,zero,90ab4b4 <m_free+0x54>
 90ab4a4:	e0bffe17 	ldw	r2,-8(fp)
 90ab4a8:	10800817 	ldw	r2,32(r2)
 90ab4ac:	10800390 	cmplti	r2,r2,14
 90ab4b0:	10000c1e 	bne	r2,zero,90ab4e4 <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 90ab4b4:	e0bffe17 	ldw	r2,-8(fp)
 90ab4b8:	10800817 	ldw	r2,32(r2)
 90ab4bc:	1004c03a 	cmpne	r2,r2,zero
 90ab4c0:	1000051e 	bne	r2,zero,90ab4d8 <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 90ab4c4:	90aa4780 	call	90aa478 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 90ab4c8:	e0bffe17 	ldw	r2,-8(fp)
 90ab4cc:	10800617 	ldw	r2,24(r2)
 90ab4d0:	e0bfff15 	stw	r2,-4(fp)
 90ab4d4:	00002906 	br	90ab57c <m_free+0x11c>
      }
      else
         panic("m_free: type");
 90ab4d8:	01024374 	movhi	r4,2317
 90ab4dc:	21021e04 	addi	r4,r4,2168
 90ab4e0:	90a537c0 	call	90a537c <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 90ab4e4:	e0bffe17 	ldw	r2,-8(fp)
 90ab4e8:	10800617 	ldw	r2,24(r2)
 90ab4ec:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 90ab4f0:	010243b4 	movhi	r4,2318
 90ab4f4:	21373704 	addi	r4,r4,-8996
 90ab4f8:	e17ffe17 	ldw	r5,-8(fp)
 90ab4fc:	90a9eb80 	call	90a9eb8 <qdel>
 90ab500:	1004c03a 	cmpne	r2,r2,zero
 90ab504:	1000031e 	bne	r2,zero,90ab514 <m_free+0xb4>
      panic("m_free: missing");
 90ab508:	01024374 	movhi	r4,2317
 90ab50c:	21022204 	addi	r4,r4,2184
 90ab510:	90a537c0 	call	90a537c <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 90ab514:	e0bffe17 	ldw	r2,-8(fp)
 90ab518:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 90ab51c:	e0bffe17 	ldw	r2,-8(fp)
 90ab520:	10800117 	ldw	r2,4(r2)
 90ab524:	1005003a 	cmpeq	r2,r2,zero
 90ab528:	1000071e 	bne	r2,zero,90ab548 <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90ab52c:	01000084 	movi	r4,2
 90ab530:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 90ab534:	e0bffe17 	ldw	r2,-8(fp)
 90ab538:	11000117 	ldw	r4,4(r2)
 90ab53c:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ab540:	01000084 	movi	r4,2
 90ab544:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 90ab548:	00824374 	movhi	r2,2317
 90ab54c:	108f3504 	addi	r2,r2,15572
 90ab550:	10800017 	ldw	r2,0(r2)
 90ab554:	10c00044 	addi	r3,r2,1
 90ab558:	00824374 	movhi	r2,2317
 90ab55c:	108f3504 	addi	r2,r2,15572
 90ab560:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 90ab564:	e17ffe17 	ldw	r5,-8(fp)
 90ab568:	010243b4 	movhi	r4,2318
 90ab56c:	21373c04 	addi	r4,r4,-8976
 90ab570:	90a9e080 	call	90a9e08 <putq>
   return nextptr;
 90ab574:	e0bffd17 	ldw	r2,-12(fp)
 90ab578:	e0bfff15 	stw	r2,-4(fp)
 90ab57c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ab580:	e037883a 	mov	sp,fp
 90ab584:	dfc00117 	ldw	ra,4(sp)
 90ab588:	df000017 	ldw	fp,0(sp)
 90ab58c:	dec00204 	addi	sp,sp,8
 90ab590:	f800283a 	ret

090ab594 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 90ab594:	defffd04 	addi	sp,sp,-12
 90ab598:	dfc00215 	stw	ra,8(sp)
 90ab59c:	df000115 	stw	fp,4(sp)
 90ab5a0:	df000104 	addi	fp,sp,4
 90ab5a4:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 90ab5a8:	00000306 	br	90ab5b8 <m_freem+0x24>
      m = m_free(m);
 90ab5ac:	e13fff17 	ldw	r4,-4(fp)
 90ab5b0:	90ab4600 	call	90ab460 <m_free>
 90ab5b4:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 90ab5b8:	e0bfff17 	ldw	r2,-4(fp)
 90ab5bc:	1004c03a 	cmpne	r2,r2,zero
 90ab5c0:	103ffa1e 	bne	r2,zero,90ab5ac <m_freem+0x18>
      m = m_free(m);
}
 90ab5c4:	e037883a 	mov	sp,fp
 90ab5c8:	dfc00117 	ldw	ra,4(sp)
 90ab5cc:	df000017 	ldw	fp,0(sp)
 90ab5d0:	dec00204 	addi	sp,sp,8
 90ab5d4:	f800283a 	ret

090ab5d8 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 90ab5d8:	defff404 	addi	sp,sp,-48
 90ab5dc:	dfc00b15 	stw	ra,44(sp)
 90ab5e0:	df000a15 	stw	fp,40(sp)
 90ab5e4:	df000a04 	addi	fp,sp,40
 90ab5e8:	e13ffa15 	stw	r4,-24(fp)
 90ab5ec:	e17ffb15 	stw	r5,-20(fp)
 90ab5f0:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 90ab5f4:	e0bffc17 	ldw	r2,-16(fp)
 90ab5f8:	1004c03a 	cmpne	r2,r2,zero
 90ab5fc:	1000021e 	bne	r2,zero,90ab608 <m_copy+0x30>
      return NULL;
 90ab600:	e03ffd15 	stw	zero,-12(fp)
 90ab604:	0000b706 	br	90ab8e4 <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 90ab608:	e0bffb17 	ldw	r2,-20(fp)
 90ab60c:	1004803a 	cmplt	r2,r2,zero
 90ab610:	1000061e 	bne	r2,zero,90ab62c <m_copy+0x54>
 90ab614:	e0bffc17 	ldw	r2,-16(fp)
 90ab618:	1004403a 	cmpge	r2,r2,zero
 90ab61c:	1000191e 	bne	r2,zero,90ab684 <m_copy+0xac>
 90ab620:	e0bffc17 	ldw	r2,-16(fp)
 90ab624:	10bfffe0 	cmpeqi	r2,r2,-1
 90ab628:	1000161e 	bne	r2,zero,90ab684 <m_copy+0xac>
   {
      dtrap();
 90ab62c:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90ab630:	e03ffd15 	stw	zero,-12(fp)
 90ab634:	0000ab06 	br	90ab8e4 <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 90ab638:	e0bffa17 	ldw	r2,-24(fp)
 90ab63c:	1004c03a 	cmpne	r2,r2,zero
 90ab640:	1000031e 	bne	r2,zero,90ab650 <m_copy+0x78>
      {
         dtrap();
 90ab644:	90aa4780 	call	90aa478 <dtrap>
         return NULL;
 90ab648:	e03ffd15 	stw	zero,-12(fp)
 90ab64c:	0000a506 	br	90ab8e4 <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 90ab650:	e0bffa17 	ldw	r2,-24(fp)
 90ab654:	10800217 	ldw	r2,8(r2)
 90ab658:	1007883a 	mov	r3,r2
 90ab65c:	e0bffb17 	ldw	r2,-20(fp)
 90ab660:	10c00b16 	blt	r2,r3,90ab690 <m_copy+0xb8>
         break;
      off -= m->m_len;
 90ab664:	e0fffb17 	ldw	r3,-20(fp)
 90ab668:	e0bffa17 	ldw	r2,-24(fp)
 90ab66c:	10800217 	ldw	r2,8(r2)
 90ab670:	1885c83a 	sub	r2,r3,r2
 90ab674:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 90ab678:	e0bffa17 	ldw	r2,-24(fp)
 90ab67c:	10800617 	ldw	r2,24(r2)
 90ab680:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 90ab684:	e0bffb17 	ldw	r2,-20(fp)
 90ab688:	10800048 	cmpgei	r2,r2,1
 90ab68c:	103fea1e 	bne	r2,zero,90ab638 <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 90ab690:	e03ff715 	stw	zero,-36(fp)
 90ab694:	e0bff717 	ldw	r2,-36(fp)
 90ab698:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 90ab69c:	00008806 	br	90ab8c0 <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 90ab6a0:	e0bffa17 	ldw	r2,-24(fp)
 90ab6a4:	1004c03a 	cmpne	r2,r2,zero
 90ab6a8:	1000051e 	bne	r2,zero,90ab6c0 <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 90ab6ac:	01024374 	movhi	r4,2317
 90ab6b0:	21022604 	addi	r4,r4,2200
 90ab6b4:	90a537c0 	call	90a537c <panic>
         return NULL;
 90ab6b8:	e03ffd15 	stw	zero,-12(fp)
 90ab6bc:	00008906 	br	90ab8e4 <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 90ab6c0:	e0bffa17 	ldw	r2,-24(fp)
 90ab6c4:	10c00217 	ldw	r3,8(r2)
 90ab6c8:	e0bffb17 	ldw	r2,-20(fp)
 90ab6cc:	1885c83a 	sub	r2,r3,r2
 90ab6d0:	e0fffc17 	ldw	r3,-16(fp)
 90ab6d4:	e0ffff15 	stw	r3,-4(fp)
 90ab6d8:	e0bffe15 	stw	r2,-8(fp)
 90ab6dc:	e0bfff17 	ldw	r2,-4(fp)
 90ab6e0:	e0fffe17 	ldw	r3,-8(fp)
 90ab6e4:	10c0020e 	bge	r2,r3,90ab6f0 <m_copy+0x118>
 90ab6e8:	e0bfff17 	ldw	r2,-4(fp)
 90ab6ec:	e0bffe15 	stw	r2,-8(fp)
 90ab6f0:	e0fffe17 	ldw	r3,-8(fp)
 90ab6f4:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 90ab6f8:	e0bffb17 	ldw	r2,-20(fp)
 90ab6fc:	108000cc 	andi	r2,r2,3
 90ab700:	1004c03a 	cmpne	r2,r2,zero
 90ab704:	1000051e 	bne	r2,zero,90ab71c <m_copy+0x144>
 90ab708:	e0bffa17 	ldw	r2,-24(fp)
 90ab70c:	10800117 	ldw	r2,4(r2)
 90ab710:	10800917 	ldw	r2,36(r2)
 90ab714:	10800060 	cmpeqi	r2,r2,1
 90ab718:	1000251e 	bne	r2,zero,90ab7b0 <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 90ab71c:	e0bffa17 	ldw	r2,-24(fp)
 90ab720:	11000817 	ldw	r4,32(r2)
 90ab724:	e17ff617 	ldw	r5,-40(fp)
 90ab728:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90ab72c:	e0bff915 	stw	r2,-28(fp)
 90ab730:	e0bff917 	ldw	r2,-28(fp)
 90ab734:	1005003a 	cmpeq	r2,r2,zero
 90ab738:	1000671e 	bne	r2,zero,90ab8d8 <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 90ab73c:	e0bff917 	ldw	r2,-28(fp)
 90ab740:	11000317 	ldw	r4,12(r2)
 90ab744:	e0bffa17 	ldw	r2,-24(fp)
 90ab748:	10c00317 	ldw	r3,12(r2)
 90ab74c:	e0bffb17 	ldw	r2,-20(fp)
 90ab750:	1885883a 	add	r2,r3,r2
 90ab754:	e0fff617 	ldw	r3,-40(fp)
 90ab758:	100b883a 	mov	r5,r2
 90ab75c:	180d883a 	mov	r6,r3
 90ab760:	90894600 	call	9089460 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 90ab764:	e0fff617 	ldw	r3,-40(fp)
 90ab768:	e0bff917 	ldw	r2,-28(fp)
 90ab76c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 90ab770:	008243b4 	movhi	r2,2318
 90ab774:	10b75604 	addi	r2,r2,-8872
 90ab778:	10802e17 	ldw	r2,184(r2)
 90ab77c:	10c00044 	addi	r3,r2,1
 90ab780:	008243b4 	movhi	r2,2318
 90ab784:	10b75604 	addi	r2,r2,-8872
 90ab788:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 90ab78c:	008243b4 	movhi	r2,2318
 90ab790:	10b75604 	addi	r2,r2,-8872
 90ab794:	10c03017 	ldw	r3,192(r2)
 90ab798:	e0bff617 	ldw	r2,-40(fp)
 90ab79c:	1887883a 	add	r3,r3,r2
 90ab7a0:	008243b4 	movhi	r2,2318
 90ab7a4:	10b75604 	addi	r2,r2,-8872
 90ab7a8:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 90ab7ac:	00003106 	br	90ab874 <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 90ab7b0:	e0bffa17 	ldw	r2,-24(fp)
 90ab7b4:	11000817 	ldw	r4,32(r2)
 90ab7b8:	000b883a 	mov	r5,zero
 90ab7bc:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90ab7c0:	e0bff915 	stw	r2,-28(fp)
 90ab7c4:	e0bff917 	ldw	r2,-28(fp)
 90ab7c8:	1005003a 	cmpeq	r2,r2,zero
 90ab7cc:	1000421e 	bne	r2,zero,90ab8d8 <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 90ab7d0:	e0bffa17 	ldw	r2,-24(fp)
 90ab7d4:	10c00117 	ldw	r3,4(r2)
 90ab7d8:	18800917 	ldw	r2,36(r3)
 90ab7dc:	10800044 	addi	r2,r2,1
 90ab7e0:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 90ab7e4:	e0bffa17 	ldw	r2,-24(fp)
 90ab7e8:	10c00117 	ldw	r3,4(r2)
 90ab7ec:	e0bff917 	ldw	r2,-28(fp)
 90ab7f0:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 90ab7f4:	e0bffa17 	ldw	r2,-24(fp)
 90ab7f8:	10c00417 	ldw	r3,16(r2)
 90ab7fc:	e0bff917 	ldw	r2,-28(fp)
 90ab800:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 90ab804:	e0bffa17 	ldw	r2,-24(fp)
 90ab808:	10c00517 	ldw	r3,20(r2)
 90ab80c:	e0bff917 	ldw	r2,-28(fp)
 90ab810:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 90ab814:	e0bffa17 	ldw	r2,-24(fp)
 90ab818:	10c00317 	ldw	r3,12(r2)
 90ab81c:	e0bffb17 	ldw	r2,-20(fp)
 90ab820:	1887883a 	add	r3,r3,r2
 90ab824:	e0bff917 	ldw	r2,-28(fp)
 90ab828:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 90ab82c:	e0fff617 	ldw	r3,-40(fp)
 90ab830:	e0bff917 	ldw	r2,-28(fp)
 90ab834:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 90ab838:	008243b4 	movhi	r2,2318
 90ab83c:	10b75604 	addi	r2,r2,-8872
 90ab840:	10802f17 	ldw	r2,188(r2)
 90ab844:	10c00044 	addi	r3,r2,1
 90ab848:	008243b4 	movhi	r2,2318
 90ab84c:	10b75604 	addi	r2,r2,-8872
 90ab850:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 90ab854:	008243b4 	movhi	r2,2318
 90ab858:	10b75604 	addi	r2,r2,-8872
 90ab85c:	10c03117 	ldw	r3,196(r2)
 90ab860:	e0bff617 	ldw	r2,-40(fp)
 90ab864:	1887883a 	add	r3,r3,r2
 90ab868:	008243b4 	movhi	r2,2318
 90ab86c:	10b75604 	addi	r2,r2,-8872
 90ab870:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 90ab874:	e0fffc17 	ldw	r3,-16(fp)
 90ab878:	e0bff617 	ldw	r2,-40(fp)
 90ab87c:	1885c83a 	sub	r2,r3,r2
 90ab880:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 90ab884:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 90ab888:	e0bff717 	ldw	r2,-36(fp)
 90ab88c:	1005003a 	cmpeq	r2,r2,zero
 90ab890:	1000041e 	bne	r2,zero,90ab8a4 <m_copy+0x2cc>
         tail->m_next = nb;
 90ab894:	e0fff717 	ldw	r3,-36(fp)
 90ab898:	e0bff917 	ldw	r2,-28(fp)
 90ab89c:	18800615 	stw	r2,24(r3)
 90ab8a0:	00000206 	br	90ab8ac <m_copy+0x2d4>
      else
         head = nb;
 90ab8a4:	e0bff917 	ldw	r2,-28(fp)
 90ab8a8:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 90ab8ac:	e0bff917 	ldw	r2,-28(fp)
 90ab8b0:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 90ab8b4:	e0bffa17 	ldw	r2,-24(fp)
 90ab8b8:	10800617 	ldw	r2,24(r2)
 90ab8bc:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 90ab8c0:	e0bffc17 	ldw	r2,-16(fp)
 90ab8c4:	10800048 	cmpgei	r2,r2,1
 90ab8c8:	103f751e 	bne	r2,zero,90ab6a0 <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 90ab8cc:	e0bff817 	ldw	r2,-32(fp)
 90ab8d0:	e0bffd15 	stw	r2,-12(fp)
 90ab8d4:	00000306 	br	90ab8e4 <m_copy+0x30c>

nospace:
   m_freem (head);
 90ab8d8:	e13ff817 	ldw	r4,-32(fp)
 90ab8dc:	90ab5940 	call	90ab594 <m_freem>
   return NULL;
 90ab8e0:	e03ffd15 	stw	zero,-12(fp)
 90ab8e4:	e0bffd17 	ldw	r2,-12(fp)
}
 90ab8e8:	e037883a 	mov	sp,fp
 90ab8ec:	dfc00117 	ldw	ra,4(sp)
 90ab8f0:	df000017 	ldw	fp,0(sp)
 90ab8f4:	dec00204 	addi	sp,sp,8
 90ab8f8:	f800283a 	ret

090ab8fc <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 90ab8fc:	defffb04 	addi	sp,sp,-20
 90ab900:	df000415 	stw	fp,16(sp)
 90ab904:	df000404 	addi	fp,sp,16
 90ab908:	e13ffe15 	stw	r4,-8(fp)
 90ab90c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 90ab910:	e0bffe17 	ldw	r2,-8(fp)
 90ab914:	e0bffd15 	stw	r2,-12(fp)
 90ab918:	e0bffd17 	ldw	r2,-12(fp)
 90ab91c:	1005003a 	cmpeq	r2,r2,zero
 90ab920:	1000661e 	bne	r2,zero,90ababc <m_adj+0x1c0>
      return;

   if (len >= 0) 
 90ab924:	e0bfff17 	ldw	r2,-4(fp)
 90ab928:	1004803a 	cmplt	r2,r2,zero
 90ab92c:	1000241e 	bne	r2,zero,90ab9c0 <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 90ab930:	00001c06 	br	90ab9a4 <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 90ab934:	e0bffd17 	ldw	r2,-12(fp)
 90ab938:	10c00217 	ldw	r3,8(r2)
 90ab93c:	e0bfff17 	ldw	r2,-4(fp)
 90ab940:	10c00b36 	bltu	r2,r3,90ab970 <m_adj+0x74>
         {
            len -= m->m_len;
 90ab944:	e0ffff17 	ldw	r3,-4(fp)
 90ab948:	e0bffd17 	ldw	r2,-12(fp)
 90ab94c:	10800217 	ldw	r2,8(r2)
 90ab950:	1885c83a 	sub	r2,r3,r2
 90ab954:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 90ab958:	e0bffd17 	ldw	r2,-12(fp)
 90ab95c:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 90ab960:	e0bffd17 	ldw	r2,-12(fp)
 90ab964:	10800617 	ldw	r2,24(r2)
 90ab968:	e0bffd15 	stw	r2,-12(fp)
 90ab96c:	00000d06 	br	90ab9a4 <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 90ab970:	e0bffd17 	ldw	r2,-12(fp)
 90ab974:	10c00217 	ldw	r3,8(r2)
 90ab978:	e0bfff17 	ldw	r2,-4(fp)
 90ab97c:	1887c83a 	sub	r3,r3,r2
 90ab980:	e0bffd17 	ldw	r2,-12(fp)
 90ab984:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 90ab988:	e0bffd17 	ldw	r2,-12(fp)
 90ab98c:	10c00317 	ldw	r3,12(r2)
 90ab990:	e0bfff17 	ldw	r2,-4(fp)
 90ab994:	1887883a 	add	r3,r3,r2
 90ab998:	e0bffd17 	ldw	r2,-12(fp)
 90ab99c:	10c00315 	stw	r3,12(r2)
            break;
 90ab9a0:	00004606 	br	90ababc <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 90ab9a4:	e0bffd17 	ldw	r2,-12(fp)
 90ab9a8:	1005003a 	cmpeq	r2,r2,zero
 90ab9ac:	1000431e 	bne	r2,zero,90ababc <m_adj+0x1c0>
 90ab9b0:	e0bfff17 	ldw	r2,-4(fp)
 90ab9b4:	10800048 	cmpgei	r2,r2,1
 90ab9b8:	103fde1e 	bne	r2,zero,90ab934 <m_adj+0x38>
 90ab9bc:	00003f06 	br	90ababc <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 90ab9c0:	e0bfff17 	ldw	r2,-4(fp)
 90ab9c4:	0085c83a 	sub	r2,zero,r2
 90ab9c8:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 90ab9cc:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 90ab9d0:	e0bffd17 	ldw	r2,-12(fp)
 90ab9d4:	10c00217 	ldw	r3,8(r2)
 90ab9d8:	e0bffc17 	ldw	r2,-16(fp)
 90ab9dc:	1885883a 	add	r2,r3,r2
 90ab9e0:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 90ab9e4:	e0bffd17 	ldw	r2,-12(fp)
 90ab9e8:	10800617 	ldw	r2,24(r2)
 90ab9ec:	1005003a 	cmpeq	r2,r2,zero
 90ab9f0:	1000041e 	bne	r2,zero,90aba04 <m_adj+0x108>
            break;
         m = m->m_next;
 90ab9f4:	e0bffd17 	ldw	r2,-12(fp)
 90ab9f8:	10800617 	ldw	r2,24(r2)
 90ab9fc:	e0bffd15 	stw	r2,-12(fp)
      }
 90aba00:	003ff306 	br	90ab9d0 <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 90aba04:	e0bffd17 	ldw	r2,-12(fp)
 90aba08:	10c00217 	ldw	r3,8(r2)
 90aba0c:	e0bfff17 	ldw	r2,-4(fp)
 90aba10:	18800736 	bltu	r3,r2,90aba30 <m_adj+0x134>
      {
         m->m_len -= len;
 90aba14:	e0bffd17 	ldw	r2,-12(fp)
 90aba18:	10c00217 	ldw	r3,8(r2)
 90aba1c:	e0bfff17 	ldw	r2,-4(fp)
 90aba20:	1887c83a 	sub	r3,r3,r2
 90aba24:	e0bffd17 	ldw	r2,-12(fp)
 90aba28:	10c00215 	stw	r3,8(r2)
         return;
 90aba2c:	00002306 	br	90ababc <m_adj+0x1c0>
      }
      count -= len;
 90aba30:	e0fffc17 	ldw	r3,-16(fp)
 90aba34:	e0bfff17 	ldw	r2,-4(fp)
 90aba38:	1885c83a 	sub	r2,r3,r2
 90aba3c:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 90aba40:	e0bffe17 	ldw	r2,-8(fp)
 90aba44:	e0bffd15 	stw	r2,-12(fp)
 90aba48:	00001006 	br	90aba8c <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 90aba4c:	e0bffd17 	ldw	r2,-12(fp)
 90aba50:	10c00217 	ldw	r3,8(r2)
 90aba54:	e0bffc17 	ldw	r2,-16(fp)
 90aba58:	18800436 	bltu	r3,r2,90aba6c <m_adj+0x170>
         {
            m->m_len = count;
 90aba5c:	e0fffc17 	ldw	r3,-16(fp)
 90aba60:	e0bffd17 	ldw	r2,-12(fp)
 90aba64:	10c00215 	stw	r3,8(r2)
            break;
 90aba68:	00000e06 	br	90abaa4 <m_adj+0x1a8>
         }
         count -= m->m_len;
 90aba6c:	e0fffc17 	ldw	r3,-16(fp)
 90aba70:	e0bffd17 	ldw	r2,-12(fp)
 90aba74:	10800217 	ldw	r2,8(r2)
 90aba78:	1885c83a 	sub	r2,r3,r2
 90aba7c:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 90aba80:	e0bffd17 	ldw	r2,-12(fp)
 90aba84:	10800617 	ldw	r2,24(r2)
 90aba88:	e0bffd15 	stw	r2,-12(fp)
 90aba8c:	e0bffd17 	ldw	r2,-12(fp)
 90aba90:	1004c03a 	cmpne	r2,r2,zero
 90aba94:	103fed1e 	bne	r2,zero,90aba4c <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 90aba98:	00000206 	br	90abaa4 <m_adj+0x1a8>
         m->m_len = 0;
 90aba9c:	e0bffd17 	ldw	r2,-12(fp)
 90abaa0:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 90abaa4:	e0bffd17 	ldw	r2,-12(fp)
 90abaa8:	10800617 	ldw	r2,24(r2)
 90abaac:	e0bffd15 	stw	r2,-12(fp)
 90abab0:	e0bffd17 	ldw	r2,-12(fp)
 90abab4:	1004c03a 	cmpne	r2,r2,zero
 90abab8:	103ff81e 	bne	r2,zero,90aba9c <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 90ababc:	e037883a 	mov	sp,fp
 90abac0:	df000017 	ldw	fp,0(sp)
 90abac4:	dec00104 	addi	sp,sp,4
 90abac8:	f800283a 	ret

090abacc <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 90abacc:	defffd04 	addi	sp,sp,-12
 90abad0:	df000215 	stw	fp,8(sp)
 90abad4:	df000204 	addi	fp,sp,8
 90abad8:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 90abadc:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 90abae0:	00000806 	br	90abb04 <mbuf_len+0x38>
   {
      len += m->m_len;
 90abae4:	e0bfff17 	ldw	r2,-4(fp)
 90abae8:	10c00217 	ldw	r3,8(r2)
 90abaec:	e0bffe17 	ldw	r2,-8(fp)
 90abaf0:	1885883a 	add	r2,r3,r2
 90abaf4:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 90abaf8:	e0bfff17 	ldw	r2,-4(fp)
 90abafc:	10800617 	ldw	r2,24(r2)
 90abb00:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 90abb04:	e0bfff17 	ldw	r2,-4(fp)
 90abb08:	1004c03a 	cmpne	r2,r2,zero
 90abb0c:	103ff51e 	bne	r2,zero,90abae4 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 90abb10:	e0bffe17 	ldw	r2,-8(fp)
}
 90abb14:	e037883a 	mov	sp,fp
 90abb18:	df000017 	ldw	fp,0(sp)
 90abb1c:	dec00104 	addi	sp,sp,4
 90abb20:	f800283a 	ret

090abb24 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 90abb24:	defffa04 	addi	sp,sp,-24
 90abb28:	dfc00515 	stw	ra,20(sp)
 90abb2c:	df000415 	stw	fp,16(sp)
 90abb30:	df000404 	addi	fp,sp,16
 90abb34:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 90abb38:	008243b4 	movhi	r2,2318
 90abb3c:	10b73704 	addi	r2,r2,-8996
 90abb40:	10800017 	ldw	r2,0(r2)
 90abb44:	e0bffd15 	stw	r2,-12(fp)
 90abb48:	00001306 	br	90abb98 <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 90abb4c:	e0bffd17 	ldw	r2,-12(fp)
 90abb50:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 90abb54:	e0bffc17 	ldw	r2,-16(fp)
 90abb58:	10c00417 	ldw	r3,16(r2)
 90abb5c:	e0bffe17 	ldw	r2,-8(fp)
 90abb60:	10c00a36 	bltu	r2,r3,90abb8c <dtom+0x68>
 90abb64:	e0bffc17 	ldw	r2,-16(fp)
 90abb68:	10c00417 	ldw	r3,16(r2)
 90abb6c:	e0bffc17 	ldw	r2,-16(fp)
 90abb70:	10800517 	ldw	r2,20(r2)
 90abb74:	1887883a 	add	r3,r3,r2
 90abb78:	e0bffe17 	ldw	r2,-8(fp)
 90abb7c:	10c0032e 	bgeu	r2,r3,90abb8c <dtom+0x68>
         return (struct mbuf *)qptr;
 90abb80:	e0bffd17 	ldw	r2,-12(fp)
 90abb84:	e0bfff15 	stw	r2,-4(fp)
 90abb88:	00000a06 	br	90abbb4 <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 90abb8c:	e0bffd17 	ldw	r2,-12(fp)
 90abb90:	10800017 	ldw	r2,0(r2)
 90abb94:	e0bffd15 	stw	r2,-12(fp)
 90abb98:	e0bffd17 	ldw	r2,-12(fp)
 90abb9c:	1004c03a 	cmpne	r2,r2,zero
 90abba0:	103fea1e 	bne	r2,zero,90abb4c <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 90abba4:	01024374 	movhi	r4,2317
 90abba8:	21022a04 	addi	r4,r4,2216
 90abbac:	90a537c0 	call	90a537c <panic>
   return NULL;
 90abbb0:	e03fff15 	stw	zero,-4(fp)
 90abbb4:	e0bfff17 	ldw	r2,-4(fp)
}
 90abbb8:	e037883a 	mov	sp,fp
 90abbbc:	dfc00117 	ldw	ra,4(sp)
 90abbc0:	df000017 	ldw	fp,0(sp)
 90abbc4:	dec00204 	addi	sp,sp,8
 90abbc8:	f800283a 	ret

090abbcc <remque>:
};


void
remque (void * arg)
{
 90abbcc:	defffd04 	addi	sp,sp,-12
 90abbd0:	df000215 	stw	fp,8(sp)
 90abbd4:	df000204 	addi	fp,sp,8
 90abbd8:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 90abbdc:	e0bfff17 	ldw	r2,-4(fp)
 90abbe0:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 90abbe4:	e0bffe17 	ldw	r2,-8(fp)
 90abbe8:	10800117 	ldw	r2,4(r2)
 90abbec:	1005003a 	cmpeq	r2,r2,zero
 90abbf0:	10000e1e 	bne	r2,zero,90abc2c <remque+0x60>
      old->prev->next = old->next;
 90abbf4:	e0bffe17 	ldw	r2,-8(fp)
 90abbf8:	10c00117 	ldw	r3,4(r2)
 90abbfc:	e0bffe17 	ldw	r2,-8(fp)
 90abc00:	10800017 	ldw	r2,0(r2)
 90abc04:	18800015 	stw	r2,0(r3)
   if (old->next)
 90abc08:	e0bffe17 	ldw	r2,-8(fp)
 90abc0c:	10800017 	ldw	r2,0(r2)
 90abc10:	1005003a 	cmpeq	r2,r2,zero
 90abc14:	1000051e 	bne	r2,zero,90abc2c <remque+0x60>
      old->next->prev = old->prev;
 90abc18:	e0bffe17 	ldw	r2,-8(fp)
 90abc1c:	10c00017 	ldw	r3,0(r2)
 90abc20:	e0bffe17 	ldw	r2,-8(fp)
 90abc24:	10800117 	ldw	r2,4(r2)
 90abc28:	18800115 	stw	r2,4(r3)
}
 90abc2c:	e037883a 	mov	sp,fp
 90abc30:	df000017 	ldw	fp,0(sp)
 90abc34:	dec00104 	addi	sp,sp,4
 90abc38:	f800283a 	ret

090abc3c <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 90abc3c:	defffb04 	addi	sp,sp,-20
 90abc40:	df000415 	stw	fp,16(sp)
 90abc44:	df000404 	addi	fp,sp,16
 90abc48:	e13ffe15 	stw	r4,-8(fp)
 90abc4c:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 90abc50:	e0bffe17 	ldw	r2,-8(fp)
 90abc54:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 90abc58:	e0bfff17 	ldw	r2,-4(fp)
 90abc5c:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 90abc60:	e0bffc17 	ldw	r2,-16(fp)
 90abc64:	10c00017 	ldw	r3,0(r2)
 90abc68:	e0bffd17 	ldw	r2,-12(fp)
 90abc6c:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 90abc70:	e0fffd17 	ldw	r3,-12(fp)
 90abc74:	e0bffc17 	ldw	r2,-16(fp)
 90abc78:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 90abc7c:	e0fffc17 	ldw	r3,-16(fp)
 90abc80:	e0bffd17 	ldw	r2,-12(fp)
 90abc84:	18800015 	stw	r2,0(r3)
   if (newe->next)
 90abc88:	e0bffd17 	ldw	r2,-12(fp)
 90abc8c:	10800017 	ldw	r2,0(r2)
 90abc90:	1005003a 	cmpeq	r2,r2,zero
 90abc94:	1000041e 	bne	r2,zero,90abca8 <insque+0x6c>
      newe->next->prev = newe;
 90abc98:	e0bffd17 	ldw	r2,-12(fp)
 90abc9c:	10c00017 	ldw	r3,0(r2)
 90abca0:	e0bffd17 	ldw	r2,-12(fp)
 90abca4:	18800115 	stw	r2,4(r3)
}
 90abca8:	e037883a 	mov	sp,fp
 90abcac:	df000017 	ldw	fp,0(sp)
 90abcb0:	dec00104 	addi	sp,sp,4
 90abcb4:	f800283a 	ret

090abcb8 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 90abcb8:	defffb04 	addi	sp,sp,-20
 90abcbc:	dfc00415 	stw	ra,16(sp)
 90abcc0:	df000315 	stw	fp,12(sp)
 90abcc4:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 90abcc8:	00824374 	movhi	r2,2317
 90abccc:	108eb904 	addi	r2,r2,15076
 90abcd0:	10c00017 	ldw	r3,0(r2)
 90abcd4:	00824374 	movhi	r2,2317
 90abcd8:	108ebb04 	addi	r2,r2,15084
 90abcdc:	10800017 	ldw	r2,0(r2)
 90abce0:	1885883a 	add	r2,r3,r2
 90abce4:	1085883a 	add	r2,r2,r2
 90abce8:	108000c4 	addi	r2,r2,3
 90abcec:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 90abcf0:	008243b4 	movhi	r2,2318
 90abcf4:	10b72304 	addi	r2,r2,-9076
 90abcf8:	10000015 	stw	zero,0(r2)
 90abcfc:	10000115 	stw	zero,4(r2)
 90abd00:	10000215 	stw	zero,8(r2)
 90abd04:	10000315 	stw	zero,12(r2)
 90abd08:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 90abd0c:	008243b4 	movhi	r2,2318
 90abd10:	10b73704 	addi	r2,r2,-8996
 90abd14:	10000015 	stw	zero,0(r2)
 90abd18:	10000115 	stw	zero,4(r2)
 90abd1c:	10000215 	stw	zero,8(r2)
 90abd20:	10000315 	stw	zero,12(r2)
 90abd24:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 90abd28:	008243b4 	movhi	r2,2318
 90abd2c:	10b73c04 	addi	r2,r2,-8976
 90abd30:	10000015 	stw	zero,0(r2)
 90abd34:	10000115 	stw	zero,4(r2)
 90abd38:	10000215 	stw	zero,8(r2)
 90abd3c:	10000315 	stw	zero,12(r2)
 90abd40:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 90abd44:	e03fff15 	stw	zero,-4(fp)
 90abd48:	00001606 	br	90abda4 <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 90abd4c:	01000904 	movi	r4,36
 90abd50:	90aaefc0 	call	90aaefc <npalloc>
 90abd54:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 90abd58:	e0bffd17 	ldw	r2,-12(fp)
 90abd5c:	1004c03a 	cmpne	r2,r2,zero
 90abd60:	1000031e 	bne	r2,zero,90abd70 <nptcp_init+0xb8>
         panic("tcpinit");
 90abd64:	01024374 	movhi	r4,2317
 90abd68:	21022c04 	addi	r4,r4,2224
 90abd6c:	90a537c0 	call	90a537c <panic>
      m->m_type = MT_FREE;
 90abd70:	e0bffd17 	ldw	r2,-12(fp)
 90abd74:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 90abd78:	e0bffd17 	ldw	r2,-12(fp)
 90abd7c:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 90abd80:	e0bffd17 	ldw	r2,-12(fp)
 90abd84:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 90abd88:	e17ffd17 	ldw	r5,-12(fp)
 90abd8c:	010243b4 	movhi	r4,2318
 90abd90:	21373c04 	addi	r4,r4,-8976
 90abd94:	90a9e080 	call	90a9e08 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 90abd98:	e0bfff17 	ldw	r2,-4(fp)
 90abd9c:	10800044 	addi	r2,r2,1
 90abda0:	e0bfff15 	stw	r2,-4(fp)
 90abda4:	e0fffe17 	ldw	r3,-8(fp)
 90abda8:	e0bfff17 	ldw	r2,-4(fp)
 90abdac:	10ffe716 	blt	r2,r3,90abd4c <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 90abdb0:	e0fffe17 	ldw	r3,-8(fp)
 90abdb4:	008243b4 	movhi	r2,2318
 90abdb8:	10b73c04 	addi	r2,r2,-8976
 90abdbc:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 90abdc0:	90b70b40 	call	90b70b4 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 90abdc4:	0005883a 	mov	r2,zero
}
 90abdc8:	e037883a 	mov	sp,fp
 90abdcc:	dfc00117 	ldw	ra,4(sp)
 90abdd0:	df000017 	ldw	fp,0(sp)
 90abdd4:	dec00204 	addi	sp,sp,8
 90abdd8:	f800283a 	ret

090abddc <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 90abddc:	defff804 	addi	sp,sp,-32
 90abde0:	dfc00715 	stw	ra,28(sp)
 90abde4:	df000615 	stw	fp,24(sp)
 90abde8:	df000604 	addi	fp,sp,24
 90abdec:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 90abdf0:	e0bffe17 	ldw	r2,-8(fp)
 90abdf4:	10800317 	ldw	r2,12(r2)
 90abdf8:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 90abdfc:	e0bffc17 	ldw	r2,-16(fp)
 90abe00:	1080008b 	ldhu	r2,2(r2)
 90abe04:	10bfffcc 	andi	r2,r2,65535
 90abe08:	1004d23a 	srli	r2,r2,8
 90abe0c:	10803fcc 	andi	r2,r2,255
 90abe10:	1009883a 	mov	r4,r2
 90abe14:	e0bffc17 	ldw	r2,-16(fp)
 90abe18:	1080008b 	ldhu	r2,2(r2)
 90abe1c:	10bfffcc 	andi	r2,r2,65535
 90abe20:	1004923a 	slli	r2,r2,8
 90abe24:	1007883a 	mov	r3,r2
 90abe28:	00bfc004 	movi	r2,-256
 90abe2c:	1884703a 	and	r2,r3,r2
 90abe30:	2084b03a 	or	r2,r4,r2
 90abe34:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 90abe38:	e0bffc17 	ldw	r2,-16(fp)
 90abe3c:	10800003 	ldbu	r2,0(r2)
 90abe40:	10803fcc 	andi	r2,r2,255
 90abe44:	108003cc 	andi	r2,r2,15
 90abe48:	1085883a 	add	r2,r2,r2
 90abe4c:	1085883a 	add	r2,r2,r2
 90abe50:	1007883a 	mov	r3,r2
 90abe54:	e0bffc17 	ldw	r2,-16(fp)
 90abe58:	1885883a 	add	r2,r3,r2
 90abe5c:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 90abe60:	e13ffc17 	ldw	r4,-16(fp)
 90abe64:	90c765c0 	call	90c765c <tcp_cksum>
 90abe68:	1007883a 	mov	r3,r2
 90abe6c:	e0bffb17 	ldw	r2,-20(fp)
 90abe70:	1080040b 	ldhu	r2,16(r2)
 90abe74:	18ffffcc 	andi	r3,r3,65535
 90abe78:	10bfffcc 	andi	r2,r2,65535
 90abe7c:	18801726 	beq	r3,r2,90abedc <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 90abe80:	008243b4 	movhi	r2,2318
 90abe84:	10b72804 	addi	r2,r2,-9056
 90abe88:	10800d17 	ldw	r2,52(r2)
 90abe8c:	10c00044 	addi	r3,r2,1
 90abe90:	008243b4 	movhi	r2,2318
 90abe94:	10b72804 	addi	r2,r2,-9056
 90abe98:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 90abe9c:	008243b4 	movhi	r2,2318
 90abea0:	10b75604 	addi	r2,r2,-8872
 90abea4:	10801c17 	ldw	r2,112(r2)
 90abea8:	10c00044 	addi	r3,r2,1
 90abeac:	008243b4 	movhi	r2,2318
 90abeb0:	10b75604 	addi	r2,r2,-8872
 90abeb4:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90abeb8:	01000084 	movi	r4,2
 90abebc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 90abec0:	e13ffe17 	ldw	r4,-8(fp)
 90abec4:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90abec8:	01000084 	movi	r4,2
 90abecc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 90abed0:	00bff804 	movi	r2,-32
 90abed4:	e0bfff15 	stw	r2,-4(fp)
 90abed8:	00003506 	br	90abfb0 <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 90abedc:	01000044 	movi	r4,1
 90abee0:	000b883a 	mov	r5,zero
 90abee4:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90abee8:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 90abeec:	e0bffd17 	ldw	r2,-12(fp)
 90abef0:	1004c03a 	cmpne	r2,r2,zero
 90abef4:	1000091e 	bne	r2,zero,90abf1c <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90abef8:	01000084 	movi	r4,2
 90abefc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90abf00:	e13ffe17 	ldw	r4,-8(fp)
 90abf04:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90abf08:	01000084 	movi	r4,2
 90abf0c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 90abf10:	00bffa84 	movi	r2,-22
 90abf14:	e0bfff15 	stw	r2,-4(fp)
 90abf18:	00002506 	br	90abfb0 <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 90abf1c:	e0bffc17 	ldw	r2,-16(fp)
 90abf20:	10800003 	ldbu	r2,0(r2)
 90abf24:	10803fcc 	andi	r2,r2,255
 90abf28:	108003cc 	andi	r2,r2,15
 90abf2c:	1085883a 	add	r2,r2,r2
 90abf30:	1085883a 	add	r2,r2,r2
 90abf34:	1007883a 	mov	r3,r2
 90abf38:	e0bffa0b 	ldhu	r2,-24(fp)
 90abf3c:	10c5c83a 	sub	r2,r2,r3
 90abf40:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 90abf44:	e0fffc17 	ldw	r3,-16(fp)
 90abf48:	e0bffa0b 	ldhu	r2,-24(fp)
 90abf4c:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 90abf50:	e0fffd17 	ldw	r3,-12(fp)
 90abf54:	e0bffe17 	ldw	r2,-8(fp)
 90abf58:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 90abf5c:	e0bffe17 	ldw	r2,-8(fp)
 90abf60:	10c00317 	ldw	r3,12(r2)
 90abf64:	e0bffd17 	ldw	r2,-12(fp)
 90abf68:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90abf6c:	e0bffe17 	ldw	r2,-8(fp)
 90abf70:	10c00417 	ldw	r3,16(r2)
 90abf74:	e0bffd17 	ldw	r2,-12(fp)
 90abf78:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 90abf7c:	e0bffe17 	ldw	r2,-8(fp)
 90abf80:	10c00117 	ldw	r3,4(r2)
 90abf84:	e0bffd17 	ldw	r2,-12(fp)
 90abf88:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 90abf8c:	e0bffe17 	ldw	r2,-8(fp)
 90abf90:	10c00217 	ldw	r3,8(r2)
 90abf94:	e0bffd17 	ldw	r2,-12(fp)
 90abf98:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 90abf9c:	e0bffe17 	ldw	r2,-8(fp)
 90abfa0:	11400617 	ldw	r5,24(r2)
 90abfa4:	e13ffd17 	ldw	r4,-12(fp)
 90abfa8:	90b31400 	call	90b3140 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 90abfac:	e03fff15 	stw	zero,-4(fp)
 90abfb0:	e0bfff17 	ldw	r2,-4(fp)
}
 90abfb4:	e037883a 	mov	sp,fp
 90abfb8:	dfc00117 	ldw	ra,4(sp)
 90abfbc:	df000017 	ldw	fp,0(sp)
 90abfc0:	dec00204 	addi	sp,sp,8
 90abfc4:	f800283a 	ret

090abfc8 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 90abfc8:	defff304 	addi	sp,sp,-52
 90abfcc:	dfc00c15 	stw	ra,48(sp)
 90abfd0:	df000b15 	stw	fp,44(sp)
 90abfd4:	df000b04 	addi	fp,sp,44
 90abfd8:	e13ffd15 	stw	r4,-12(fp)
 90abfdc:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 90abfe0:	e0bffd17 	ldw	r2,-12(fp)
 90abfe4:	10800617 	ldw	r2,24(r2)
 90abfe8:	1005003a 	cmpeq	r2,r2,zero
 90abfec:	1001101e 	bne	r2,zero,90ac430 <ip_output+0x468>
   {
      m1 = data;
 90abff0:	e0bffd17 	ldw	r2,-12(fp)
 90abff4:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 90abff8:	e0bffd17 	ldw	r2,-12(fp)
 90abffc:	10800617 	ldw	r2,24(r2)
 90ac000:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 90ac004:	00003406 	br	90ac0d8 <ip_output+0x110>
      {
         pkt = m1->pkt;
 90ac008:	e0bff917 	ldw	r2,-28(fp)
 90ac00c:	10800117 	ldw	r2,4(r2)
 90ac010:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 90ac014:	e0bffa17 	ldw	r2,-24(fp)
 90ac018:	10c00117 	ldw	r3,4(r2)
 90ac01c:	e0bffa17 	ldw	r2,-24(fp)
 90ac020:	10800217 	ldw	r2,8(r2)
 90ac024:	1889883a 	add	r4,r3,r2
 90ac028:	e0bff917 	ldw	r2,-28(fp)
 90ac02c:	10c00317 	ldw	r3,12(r2)
 90ac030:	e0bff917 	ldw	r2,-28(fp)
 90ac034:	10800217 	ldw	r2,8(r2)
 90ac038:	1887883a 	add	r3,r3,r2
 90ac03c:	e0bff817 	ldw	r2,-32(fp)
 90ac040:	10800217 	ldw	r2,8(r2)
 90ac044:	1885883a 	add	r2,r3,r2
 90ac048:	1100822e 	bgeu	r2,r4,90ac254 <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 90ac04c:	e0bff917 	ldw	r2,-28(fp)
 90ac050:	10c00317 	ldw	r3,12(r2)
 90ac054:	e0bff917 	ldw	r2,-28(fp)
 90ac058:	10800217 	ldw	r2,8(r2)
 90ac05c:	1887883a 	add	r3,r3,r2
 90ac060:	e0bff817 	ldw	r2,-32(fp)
 90ac064:	11400317 	ldw	r5,12(r2)
 90ac068:	e0bff817 	ldw	r2,-32(fp)
 90ac06c:	10800217 	ldw	r2,8(r2)
 90ac070:	1809883a 	mov	r4,r3
 90ac074:	100d883a 	mov	r6,r2
 90ac078:	90894600 	call	9089460 <memcpy>
            m1->m_len += m2->m_len;
 90ac07c:	e0bff917 	ldw	r2,-28(fp)
 90ac080:	10c00217 	ldw	r3,8(r2)
 90ac084:	e0bff817 	ldw	r2,-32(fp)
 90ac088:	10800217 	ldw	r2,8(r2)
 90ac08c:	1887883a 	add	r3,r3,r2
 90ac090:	e0bff917 	ldw	r2,-28(fp)
 90ac094:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 90ac098:	e0bff817 	ldw	r2,-32(fp)
 90ac09c:	10c00617 	ldw	r3,24(r2)
 90ac0a0:	e0bff917 	ldw	r2,-28(fp)
 90ac0a4:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 90ac0a8:	e13ff817 	ldw	r4,-32(fp)
 90ac0ac:	90ab4600 	call	90ab460 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 90ac0b0:	e0bff917 	ldw	r2,-28(fp)
 90ac0b4:	10800617 	ldw	r2,24(r2)
 90ac0b8:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 90ac0bc:	008243b4 	movhi	r2,2318
 90ac0c0:	10b75604 	addi	r2,r2,-8872
 90ac0c4:	10803317 	ldw	r2,204(r2)
 90ac0c8:	10c00044 	addi	r3,r2,1
 90ac0cc:	008243b4 	movhi	r2,2318
 90ac0d0:	10b75604 	addi	r2,r2,-8872
 90ac0d4:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 90ac0d8:	e0bff817 	ldw	r2,-32(fp)
 90ac0dc:	1005003a 	cmpeq	r2,r2,zero
 90ac0e0:	10005c1e 	bne	r2,zero,90ac254 <ip_output+0x28c>
 90ac0e4:	e0bff817 	ldw	r2,-32(fp)
 90ac0e8:	10800217 	ldw	r2,8(r2)
 90ac0ec:	108002b0 	cmpltui	r2,r2,10
 90ac0f0:	103fc51e 	bne	r2,zero,90ac008 <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 90ac0f4:	00005706 	br	90ac254 <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 90ac0f8:	e0bff817 	ldw	r2,-32(fp)
 90ac0fc:	10800317 	ldw	r2,12(r2)
 90ac100:	1007883a 	mov	r3,r2
 90ac104:	e0bff817 	ldw	r2,-32(fp)
 90ac108:	10800117 	ldw	r2,4(r2)
 90ac10c:	10800117 	ldw	r2,4(r2)
 90ac110:	1885c83a 	sub	r2,r3,r2
 90ac114:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 90ac118:	00824374 	movhi	r2,2317
 90ac11c:	108f0704 	addi	r2,r2,15388
 90ac120:	10c00017 	ldw	r3,0(r2)
 90ac124:	e0bff617 	ldw	r2,-40(fp)
 90ac128:	10c00a0e 	bge	r2,r3,90ac154 <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 90ac12c:	00824374 	movhi	r2,2317
 90ac130:	108f0704 	addi	r2,r2,15388
 90ac134:	11400017 	ldw	r5,0(r2)
 90ac138:	01024374 	movhi	r4,2317
 90ac13c:	21022e04 	addi	r4,r4,2232
 90ac140:	e1bff617 	ldw	r6,-40(fp)
 90ac144:	90833900 	call	9083390 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 90ac148:	01024374 	movhi	r4,2317
 90ac14c:	21023404 	addi	r4,r4,2256
 90ac150:	90a537c0 	call	90a537c <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 90ac154:	e0bff917 	ldw	r2,-28(fp)
 90ac158:	11000217 	ldw	r4,8(r2)
 90ac15c:	00824374 	movhi	r2,2317
 90ac160:	108f0704 	addi	r2,r2,15388
 90ac164:	10c00017 	ldw	r3,0(r2)
 90ac168:	e0bff617 	ldw	r2,-40(fp)
 90ac16c:	10c5c83a 	sub	r2,r2,r3
 90ac170:	20803b2e 	bgeu	r4,r2,90ac260 <ip_output+0x298>
 90ac174:	e0bff917 	ldw	r2,-28(fp)
 90ac178:	10800217 	ldw	r2,8(r2)
 90ac17c:	108000cc 	andi	r2,r2,3
 90ac180:	1004c03a 	cmpne	r2,r2,zero
 90ac184:	1000361e 	bne	r2,zero,90ac260 <ip_output+0x298>
 90ac188:	e0bff817 	ldw	r2,-32(fp)
 90ac18c:	10800317 	ldw	r2,12(r2)
 90ac190:	1007883a 	mov	r3,r2
 90ac194:	e0bff817 	ldw	r2,-32(fp)
 90ac198:	10800117 	ldw	r2,4(r2)
 90ac19c:	10800117 	ldw	r2,4(r2)
 90ac1a0:	1885c83a 	sub	r2,r3,r2
 90ac1a4:	10800e18 	cmpnei	r2,r2,56
 90ac1a8:	10002d1e 	bne	r2,zero,90ac260 <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 90ac1ac:	e0bff817 	ldw	r2,-32(fp)
 90ac1b0:	10c00317 	ldw	r3,12(r2)
 90ac1b4:	e0bff917 	ldw	r2,-28(fp)
 90ac1b8:	10800217 	ldw	r2,8(r2)
 90ac1bc:	1887c83a 	sub	r3,r3,r2
 90ac1c0:	e0bff917 	ldw	r2,-28(fp)
 90ac1c4:	11400317 	ldw	r5,12(r2)
 90ac1c8:	e0bff917 	ldw	r2,-28(fp)
 90ac1cc:	10800217 	ldw	r2,8(r2)
 90ac1d0:	1809883a 	mov	r4,r3
 90ac1d4:	100d883a 	mov	r6,r2
 90ac1d8:	90894600 	call	9089460 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 90ac1dc:	e0bff817 	ldw	r2,-32(fp)
 90ac1e0:	10c00317 	ldw	r3,12(r2)
 90ac1e4:	e0bff917 	ldw	r2,-28(fp)
 90ac1e8:	10800217 	ldw	r2,8(r2)
 90ac1ec:	1887c83a 	sub	r3,r3,r2
 90ac1f0:	e0bff817 	ldw	r2,-32(fp)
 90ac1f4:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 90ac1f8:	e0bff817 	ldw	r2,-32(fp)
 90ac1fc:	10c00217 	ldw	r3,8(r2)
 90ac200:	e0bff917 	ldw	r2,-28(fp)
 90ac204:	10800217 	ldw	r2,8(r2)
 90ac208:	1887883a 	add	r3,r3,r2
 90ac20c:	e0bff817 	ldw	r2,-32(fp)
 90ac210:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 90ac214:	e13ff917 	ldw	r4,-28(fp)
 90ac218:	90ab4600 	call	90ab460 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 90ac21c:	e0bff817 	ldw	r2,-32(fp)
 90ac220:	e0bff915 	stw	r2,-28(fp)
 90ac224:	e0bff917 	ldw	r2,-28(fp)
 90ac228:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 90ac22c:	e0bff817 	ldw	r2,-32(fp)
 90ac230:	10800617 	ldw	r2,24(r2)
 90ac234:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 90ac238:	008243b4 	movhi	r2,2318
 90ac23c:	10b75604 	addi	r2,r2,-8872
 90ac240:	10803217 	ldw	r2,200(r2)
 90ac244:	10c00044 	addi	r3,r2,1
 90ac248:	008243b4 	movhi	r2,2318
 90ac24c:	10b75604 	addi	r2,r2,-8872
 90ac250:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 90ac254:	e0bff817 	ldw	r2,-32(fp)
 90ac258:	1004c03a 	cmpne	r2,r2,zero
 90ac25c:	103fa61e 	bne	r2,zero,90ac0f8 <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 90ac260:	e0bff817 	ldw	r2,-32(fp)
 90ac264:	1005003a 	cmpeq	r2,r2,zero
 90ac268:	1000711e 	bne	r2,zero,90ac430 <ip_output+0x468>
      {
         total = 0;
 90ac26c:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 90ac270:	e0bff917 	ldw	r2,-28(fp)
 90ac274:	e0bff715 	stw	r2,-36(fp)
 90ac278:	00000806 	br	90ac29c <ip_output+0x2d4>
            total += mtmp->m_len;
 90ac27c:	e0bff717 	ldw	r2,-36(fp)
 90ac280:	10c00217 	ldw	r3,8(r2)
 90ac284:	e0bff517 	ldw	r2,-44(fp)
 90ac288:	1885883a 	add	r2,r3,r2
 90ac28c:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 90ac290:	e0bff717 	ldw	r2,-36(fp)
 90ac294:	10800617 	ldw	r2,24(r2)
 90ac298:	e0bff715 	stw	r2,-36(fp)
 90ac29c:	e0bff717 	ldw	r2,-36(fp)
 90ac2a0:	1004c03a 	cmpne	r2,r2,zero
 90ac2a4:	103ff51e 	bne	r2,zero,90ac27c <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90ac2a8:	01000084 	movi	r4,2
 90ac2ac:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 90ac2b0:	e0bff517 	ldw	r2,-44(fp)
 90ac2b4:	10800e04 	addi	r2,r2,56
 90ac2b8:	1009883a 	mov	r4,r2
 90ac2bc:	90a98340 	call	90a9834 <pk_alloc>
 90ac2c0:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ac2c4:	01000084 	movi	r4,2
 90ac2c8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 90ac2cc:	e0bffa17 	ldw	r2,-24(fp)
 90ac2d0:	1004c03a 	cmpne	r2,r2,zero
 90ac2d4:	1000031e 	bne	r2,zero,90ac2e4 <ip_output+0x31c>
            return ENOBUFS;
 90ac2d8:	00801a44 	movi	r2,105
 90ac2dc:	e0bfff15 	stw	r2,-4(fp)
 90ac2e0:	0000b106 	br	90ac5a8 <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 90ac2e4:	e0bffa17 	ldw	r2,-24(fp)
 90ac2e8:	10c00117 	ldw	r3,4(r2)
 90ac2ec:	00824374 	movhi	r2,2317
 90ac2f0:	108f0704 	addi	r2,r2,15388
 90ac2f4:	10800017 	ldw	r2,0(r2)
 90ac2f8:	1887883a 	add	r3,r3,r2
 90ac2fc:	e0bffa17 	ldw	r2,-24(fp)
 90ac300:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 90ac304:	e0bff917 	ldw	r2,-28(fp)
 90ac308:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 90ac30c:	00002806 	br	90ac3b0 <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 90ac310:	e0bffa17 	ldw	r2,-24(fp)
 90ac314:	10c00317 	ldw	r3,12(r2)
 90ac318:	e0bff717 	ldw	r2,-36(fp)
 90ac31c:	11400317 	ldw	r5,12(r2)
 90ac320:	e0bff717 	ldw	r2,-36(fp)
 90ac324:	10800217 	ldw	r2,8(r2)
 90ac328:	1809883a 	mov	r4,r3
 90ac32c:	100d883a 	mov	r6,r2
 90ac330:	90894600 	call	9089460 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 90ac334:	e0bffa17 	ldw	r2,-24(fp)
 90ac338:	10c00317 	ldw	r3,12(r2)
 90ac33c:	e0bff717 	ldw	r2,-36(fp)
 90ac340:	10800217 	ldw	r2,8(r2)
 90ac344:	1887883a 	add	r3,r3,r2
 90ac348:	e0bffa17 	ldw	r2,-24(fp)
 90ac34c:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 90ac350:	e0bffa17 	ldw	r2,-24(fp)
 90ac354:	10c00417 	ldw	r3,16(r2)
 90ac358:	e0bff717 	ldw	r2,-36(fp)
 90ac35c:	10800217 	ldw	r2,8(r2)
 90ac360:	1887883a 	add	r3,r3,r2
 90ac364:	e0bffa17 	ldw	r2,-24(fp)
 90ac368:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 90ac36c:	e0bff717 	ldw	r2,-36(fp)
 90ac370:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 90ac374:	e0bff717 	ldw	r2,-36(fp)
 90ac378:	10800617 	ldw	r2,24(r2)
 90ac37c:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 90ac380:	e0fff817 	ldw	r3,-32(fp)
 90ac384:	e0bffd17 	ldw	r2,-12(fp)
 90ac388:	18800226 	beq	r3,r2,90ac394 <ip_output+0x3cc>
               m_free(m2);
 90ac38c:	e13ff817 	ldw	r4,-32(fp)
 90ac390:	90ab4600 	call	90ab460 <m_free>
            tcpstat.tcps_ocopies++;
 90ac394:	008243b4 	movhi	r2,2318
 90ac398:	10b75604 	addi	r2,r2,-8872
 90ac39c:	10803417 	ldw	r2,208(r2)
 90ac3a0:	10c00044 	addi	r3,r2,1
 90ac3a4:	008243b4 	movhi	r2,2318
 90ac3a8:	10b75604 	addi	r2,r2,-8872
 90ac3ac:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 90ac3b0:	e0bff717 	ldw	r2,-36(fp)
 90ac3b4:	1004c03a 	cmpne	r2,r2,zero
 90ac3b8:	103fd51e 	bne	r2,zero,90ac310 <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 90ac3bc:	e0bffa17 	ldw	r2,-24(fp)
 90ac3c0:	10c00317 	ldw	r3,12(r2)
 90ac3c4:	e0bff517 	ldw	r2,-44(fp)
 90ac3c8:	1887c83a 	sub	r3,r3,r2
 90ac3cc:	e0bffa17 	ldw	r2,-24(fp)
 90ac3d0:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90ac3d4:	01000084 	movi	r4,2
 90ac3d8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 90ac3dc:	e0bffd17 	ldw	r2,-12(fp)
 90ac3e0:	11000117 	ldw	r4,4(r2)
 90ac3e4:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ac3e8:	01000084 	movi	r4,2
 90ac3ec:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 90ac3f0:	e0fffd17 	ldw	r3,-12(fp)
 90ac3f4:	e0bffa17 	ldw	r2,-24(fp)
 90ac3f8:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 90ac3fc:	e0bffa17 	ldw	r2,-24(fp)
 90ac400:	10c00417 	ldw	r3,16(r2)
 90ac404:	e0bffd17 	ldw	r2,-12(fp)
 90ac408:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 90ac40c:	e0bffd17 	ldw	r2,-12(fp)
 90ac410:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 90ac414:	e0bffa17 	ldw	r2,-24(fp)
 90ac418:	10c00317 	ldw	r3,12(r2)
 90ac41c:	e0bffd17 	ldw	r2,-12(fp)
 90ac420:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 90ac424:	e0fff517 	ldw	r3,-44(fp)
 90ac428:	e0bffd17 	ldw	r2,-12(fp)
 90ac42c:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 90ac430:	e0bffd17 	ldw	r2,-12(fp)
 90ac434:	11000317 	ldw	r4,12(r2)
 90ac438:	e0bffd17 	ldw	r2,-12(fp)
 90ac43c:	10800117 	ldw	r2,4(r2)
 90ac440:	10c00117 	ldw	r3,4(r2)
 90ac444:	00824374 	movhi	r2,2317
 90ac448:	108f0704 	addi	r2,r2,15388
 90ac44c:	10800017 	ldw	r2,0(r2)
 90ac450:	1885883a 	add	r2,r3,r2
 90ac454:	2080032e 	bgeu	r4,r2,90ac464 <ip_output+0x49c>
      panic("ip_output: overflow");
 90ac458:	01024374 	movhi	r4,2317
 90ac45c:	21023904 	addi	r4,r4,2276
 90ac460:	90a537c0 	call	90a537c <panic>

   pkt = data->pkt;
 90ac464:	e0bffd17 	ldw	r2,-12(fp)
 90ac468:	10800117 	ldw	r2,4(r2)
 90ac46c:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 90ac470:	e0bffe17 	ldw	r2,-8(fp)
 90ac474:	1005003a 	cmpeq	r2,r2,zero
 90ac478:	1000031e 	bne	r2,zero,90ac488 <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 90ac47c:	e0fffa17 	ldw	r3,-24(fp)
 90ac480:	e0bffe17 	ldw	r2,-8(fp)
 90ac484:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 90ac488:	e0bffd17 	ldw	r2,-12(fp)
 90ac48c:	10800317 	ldw	r2,12(r2)
 90ac490:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 90ac494:	e0bffc17 	ldw	r2,-16(fp)
 90ac498:	10c00417 	ldw	r3,16(r2)
 90ac49c:	e0bffa17 	ldw	r2,-24(fp)
 90ac4a0:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 90ac4a4:	e0fffc17 	ldw	r3,-16(fp)
 90ac4a8:	00801144 	movi	r2,69
 90ac4ac:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 90ac4b0:	e0bffc17 	ldw	r2,-16(fp)
 90ac4b4:	1080008b 	ldhu	r2,2(r2)
 90ac4b8:	10bfffcc 	andi	r2,r2,65535
 90ac4bc:	1004d23a 	srli	r2,r2,8
 90ac4c0:	10803fcc 	andi	r2,r2,255
 90ac4c4:	1009883a 	mov	r4,r2
 90ac4c8:	e0bffc17 	ldw	r2,-16(fp)
 90ac4cc:	1080008b 	ldhu	r2,2(r2)
 90ac4d0:	10bfffcc 	andi	r2,r2,65535
 90ac4d4:	1004923a 	slli	r2,r2,8
 90ac4d8:	1007883a 	mov	r3,r2
 90ac4dc:	00bfc004 	movi	r2,-256
 90ac4e0:	1884703a 	and	r2,r3,r2
 90ac4e4:	2084b03a 	or	r2,r4,r2
 90ac4e8:	1007883a 	mov	r3,r2
 90ac4ec:	e0bffc17 	ldw	r2,-16(fp)
 90ac4f0:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 90ac4f4:	e0bffc17 	ldw	r2,-16(fp)
 90ac4f8:	10800003 	ldbu	r2,0(r2)
 90ac4fc:	10803fcc 	andi	r2,r2,255
 90ac500:	108003cc 	andi	r2,r2,15
 90ac504:	1085883a 	add	r2,r2,r2
 90ac508:	1085883a 	add	r2,r2,r2
 90ac50c:	1007883a 	mov	r3,r2
 90ac510:	e0bffc17 	ldw	r2,-16(fp)
 90ac514:	1885883a 	add	r2,r3,r2
 90ac518:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 90ac51c:	e13ffc17 	ldw	r4,-16(fp)
 90ac520:	90c765c0 	call	90c765c <tcp_cksum>
 90ac524:	1007883a 	mov	r3,r2
 90ac528:	e0bffb17 	ldw	r2,-20(fp)
 90ac52c:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 90ac530:	e0bffc17 	ldw	r2,-16(fp)
 90ac534:	10800504 	addi	r2,r2,20
 90ac538:	1007883a 	mov	r3,r2
 90ac53c:	e0bffa17 	ldw	r2,-24(fp)
 90ac540:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 90ac544:	e0bffd17 	ldw	r2,-12(fp)
 90ac548:	10800217 	ldw	r2,8(r2)
 90ac54c:	10fffb04 	addi	r3,r2,-20
 90ac550:	e0bffa17 	ldw	r2,-24(fp)
 90ac554:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 90ac558:	01000184 	movi	r4,6
 90ac55c:	e17ffa17 	ldw	r5,-24(fp)
 90ac560:	90be8c40 	call	90be8c4 <ip_write>
 90ac564:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 90ac568:	e0bffd17 	ldw	r2,-12(fp)
 90ac56c:	10000115 	stw	zero,4(r2)
   m_freem(data);
 90ac570:	e13ffd17 	ldw	r4,-12(fp)
 90ac574:	90ab5940 	call	90ab594 <m_freem>

   if (e < 0)
 90ac578:	e0bff617 	ldw	r2,-40(fp)
 90ac57c:	1004403a 	cmpge	r2,r2,zero
 90ac580:	1000081e 	bne	r2,zero,90ac5a4 <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 90ac584:	e0bff617 	ldw	r2,-40(fp)
 90ac588:	10bffa98 	cmpnei	r2,r2,-22
 90ac58c:	1000021e 	bne	r2,zero,90ac598 <ip_output+0x5d0>
         return 0;
 90ac590:	e03fff15 	stw	zero,-4(fp)
 90ac594:	00000406 	br	90ac5a8 <ip_output+0x5e0>
      return e;
 90ac598:	e0bff617 	ldw	r2,-40(fp)
 90ac59c:	e0bfff15 	stw	r2,-4(fp)
 90ac5a0:	00000106 	br	90ac5a8 <ip_output+0x5e0>
   }
   else
      return 0;
 90ac5a4:	e03fff15 	stw	zero,-4(fp)
 90ac5a8:	e0bfff17 	ldw	r2,-4(fp)
}
 90ac5ac:	e037883a 	mov	sp,fp
 90ac5b0:	dfc00117 	ldw	ra,4(sp)
 90ac5b4:	df000017 	ldw	fp,0(sp)
 90ac5b8:	dec00204 	addi	sp,sp,8
 90ac5bc:	f800283a 	ret

090ac5c0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 90ac5c0:	defffd04 	addi	sp,sp,-12
 90ac5c4:	df000215 	stw	fp,8(sp)
 90ac5c8:	df000204 	addi	fp,sp,8
 90ac5cc:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 90ac5d0:	e0bffe17 	ldw	r2,-8(fp)
 90ac5d4:	10bfffd8 	cmpnei	r2,r2,-1
 90ac5d8:	1000031e 	bne	r2,zero,90ac5e8 <in_broadcast+0x28>
      return TRUE;
 90ac5dc:	00800044 	movi	r2,1
 90ac5e0:	e0bfff15 	stw	r2,-4(fp)
 90ac5e4:	00000106 	br	90ac5ec <in_broadcast+0x2c>

   return FALSE;
 90ac5e8:	e03fff15 	stw	zero,-4(fp)
 90ac5ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90ac5f0:	e037883a 	mov	sp,fp
 90ac5f4:	df000017 	ldw	fp,0(sp)
 90ac5f8:	dec00104 	addi	sp,sp,4
 90ac5fc:	f800283a 	ret

090ac600 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 90ac600:	defffb04 	addi	sp,sp,-20
 90ac604:	dfc00415 	stw	ra,16(sp)
 90ac608:	df000315 	stw	fp,12(sp)
 90ac60c:	df000304 	addi	fp,sp,12
 90ac610:	e13ffe15 	stw	r4,-8(fp)
 90ac614:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 90ac618:	e0bffe17 	ldw	r2,-8(fp)
 90ac61c:	10800003 	ldbu	r2,0(r2)
 90ac620:	10803fcc 	andi	r2,r2,255
 90ac624:	108003cc 	andi	r2,r2,15
 90ac628:	1085883a 	add	r2,r2,r2
 90ac62c:	1085883a 	add	r2,r2,r2
 90ac630:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 90ac634:	e0bffd17 	ldw	r2,-12(fp)
 90ac638:	10800550 	cmplti	r2,r2,21
 90ac63c:	1000251e 	bne	r2,zero,90ac6d4 <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 90ac640:	e0bffd17 	ldw	r2,-12(fp)
 90ac644:	10bffb04 	addi	r2,r2,-20
 90ac648:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 90ac64c:	e0bffe17 	ldw	r2,-8(fp)
 90ac650:	10c0008b 	ldhu	r3,2(r2)
 90ac654:	e0bffd17 	ldw	r2,-12(fp)
 90ac658:	1885c83a 	sub	r2,r3,r2
 90ac65c:	1007883a 	mov	r3,r2
 90ac660:	e0bffe17 	ldw	r2,-8(fp)
 90ac664:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 90ac668:	e0bffe17 	ldw	r2,-8(fp)
 90ac66c:	10800003 	ldbu	r2,0(r2)
 90ac670:	1007883a 	mov	r3,r2
 90ac674:	00bffc04 	movi	r2,-16
 90ac678:	1884703a 	and	r2,r3,r2
 90ac67c:	10800154 	ori	r2,r2,5
 90ac680:	1007883a 	mov	r3,r2
 90ac684:	e0bffe17 	ldw	r2,-8(fp)
 90ac688:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 90ac68c:	e0fffe17 	ldw	r3,-8(fp)
 90ac690:	e0bffd17 	ldw	r2,-12(fp)
 90ac694:	1889883a 	add	r4,r3,r2
 90ac698:	e17ffe17 	ldw	r5,-8(fp)
 90ac69c:	01800504 	movi	r6,20
 90ac6a0:	90895000 	call	9089500 <memmove>
   m->m_len -= ihlen;
 90ac6a4:	e0bfff17 	ldw	r2,-4(fp)
 90ac6a8:	10c00217 	ldw	r3,8(r2)
 90ac6ac:	e0bffd17 	ldw	r2,-12(fp)
 90ac6b0:	1887c83a 	sub	r3,r3,r2
 90ac6b4:	e0bfff17 	ldw	r2,-4(fp)
 90ac6b8:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 90ac6bc:	e0bfff17 	ldw	r2,-4(fp)
 90ac6c0:	10c00317 	ldw	r3,12(r2)
 90ac6c4:	e0bffd17 	ldw	r2,-12(fp)
 90ac6c8:	1887883a 	add	r3,r3,r2
 90ac6cc:	e0bfff17 	ldw	r2,-4(fp)
 90ac6d0:	10c00315 	stw	r3,12(r2)
}
 90ac6d4:	e037883a 	mov	sp,fp
 90ac6d8:	dfc00117 	ldw	ra,4(sp)
 90ac6dc:	df000017 	ldw	fp,0(sp)
 90ac6e0:	dec00204 	addi	sp,sp,8
 90ac6e4:	f800283a 	ret

090ac6e8 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 90ac6e8:	defff304 	addi	sp,sp,-52
 90ac6ec:	dfc00c15 	stw	ra,48(sp)
 90ac6f0:	df000b15 	stw	fp,44(sp)
 90ac6f4:	df000b04 	addi	fp,sp,44
 90ac6f8:	e13ffe15 	stw	r4,-8(fp)
 90ac6fc:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 90ac700:	e0bfff17 	ldw	r2,-4(fp)
 90ac704:	10800617 	ldw	r2,24(r2)
 90ac708:	1004d63a 	srli	r2,r2,24
 90ac70c:	10c03fcc 	andi	r3,r2,255
 90ac710:	e0bfff17 	ldw	r2,-4(fp)
 90ac714:	10800617 	ldw	r2,24(r2)
 90ac718:	1004d23a 	srli	r2,r2,8
 90ac71c:	10bfc00c 	andi	r2,r2,65280
 90ac720:	1886b03a 	or	r3,r3,r2
 90ac724:	e0bfff17 	ldw	r2,-4(fp)
 90ac728:	10800617 	ldw	r2,24(r2)
 90ac72c:	10bfc00c 	andi	r2,r2,65280
 90ac730:	1004923a 	slli	r2,r2,8
 90ac734:	1886b03a 	or	r3,r3,r2
 90ac738:	e0bfff17 	ldw	r2,-4(fp)
 90ac73c:	10800617 	ldw	r2,24(r2)
 90ac740:	10803fcc 	andi	r2,r2,255
 90ac744:	1004963a 	slli	r2,r2,24
 90ac748:	1884b03a 	or	r2,r3,r2
 90ac74c:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 90ac750:	e0bfff17 	ldw	r2,-4(fp)
 90ac754:	10800517 	ldw	r2,20(r2)
 90ac758:	1004d63a 	srli	r2,r2,24
 90ac75c:	10c03fcc 	andi	r3,r2,255
 90ac760:	e0bfff17 	ldw	r2,-4(fp)
 90ac764:	10800517 	ldw	r2,20(r2)
 90ac768:	1004d23a 	srli	r2,r2,8
 90ac76c:	10bfc00c 	andi	r2,r2,65280
 90ac770:	1886b03a 	or	r3,r3,r2
 90ac774:	e0bfff17 	ldw	r2,-4(fp)
 90ac778:	10800517 	ldw	r2,20(r2)
 90ac77c:	10bfc00c 	andi	r2,r2,65280
 90ac780:	1004923a 	slli	r2,r2,8
 90ac784:	1886b03a 	or	r3,r3,r2
 90ac788:	e0bfff17 	ldw	r2,-4(fp)
 90ac78c:	10800517 	ldw	r2,20(r2)
 90ac790:	10803fcc 	andi	r2,r2,255
 90ac794:	1004963a 	slli	r2,r2,24
 90ac798:	1884b03a 	or	r2,r3,r2
 90ac79c:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 90ac7a0:	e0bfff17 	ldw	r2,-4(fp)
 90ac7a4:	10800704 	addi	r2,r2,28
 90ac7a8:	1080000b 	ldhu	r2,0(r2)
 90ac7ac:	10bfffcc 	andi	r2,r2,65535
 90ac7b0:	1004d23a 	srli	r2,r2,8
 90ac7b4:	10803fcc 	andi	r2,r2,255
 90ac7b8:	1009883a 	mov	r4,r2
 90ac7bc:	e0bfff17 	ldw	r2,-4(fp)
 90ac7c0:	10800704 	addi	r2,r2,28
 90ac7c4:	1080000b 	ldhu	r2,0(r2)
 90ac7c8:	10bfffcc 	andi	r2,r2,65535
 90ac7cc:	1004923a 	slli	r2,r2,8
 90ac7d0:	1007883a 	mov	r3,r2
 90ac7d4:	00bfc004 	movi	r2,-256
 90ac7d8:	1884703a 	and	r2,r3,r2
 90ac7dc:	2084b03a 	or	r2,r4,r2
 90ac7e0:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 90ac7e4:	e0bfff17 	ldw	r2,-4(fp)
 90ac7e8:	10800704 	addi	r2,r2,28
 90ac7ec:	10800084 	addi	r2,r2,2
 90ac7f0:	1080000b 	ldhu	r2,0(r2)
 90ac7f4:	10bfffcc 	andi	r2,r2,65535
 90ac7f8:	1004d23a 	srli	r2,r2,8
 90ac7fc:	10803fcc 	andi	r2,r2,255
 90ac800:	1009883a 	mov	r4,r2
 90ac804:	e0bfff17 	ldw	r2,-4(fp)
 90ac808:	10800704 	addi	r2,r2,28
 90ac80c:	10800084 	addi	r2,r2,2
 90ac810:	1080000b 	ldhu	r2,0(r2)
 90ac814:	10bfffcc 	andi	r2,r2,65535
 90ac818:	1004923a 	slli	r2,r2,8
 90ac81c:	1007883a 	mov	r3,r2
 90ac820:	00bfc004 	movi	r2,-256
 90ac824:	1884703a 	and	r2,r3,r2
 90ac828:	2084b03a 	or	r2,r4,r2
 90ac82c:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 90ac830:	e0bfff17 	ldw	r2,-4(fp)
 90ac834:	10800043 	ldbu	r2,1(r2)
 90ac838:	10803fcc 	andi	r2,r2,255
 90ac83c:	1080201c 	xori	r2,r2,128
 90ac840:	10bfe004 	addi	r2,r2,-128
 90ac844:	10800120 	cmpeqi	r2,r2,4
 90ac848:	1000721e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 90ac84c:	e0bfff17 	ldw	r2,-4(fp)
 90ac850:	10800443 	ldbu	r2,17(r2)
 90ac854:	10803fcc 	andi	r2,r2,255
 90ac858:	10800198 	cmpnei	r2,r2,6
 90ac85c:	1000241e 	bne	r2,zero,90ac8f0 <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 90ac860:	e1bffb8b 	ldhu	r6,-18(fp)
 90ac864:	e0bffb0b 	ldhu	r2,-20(fp)
 90ac868:	d8800015 	stw	r2,0(sp)
 90ac86c:	00800044 	movi	r2,1
 90ac870:	d8800115 	stw	r2,4(sp)
 90ac874:	010243b4 	movhi	r4,2318
 90ac878:	21374b04 	addi	r4,r4,-8916
 90ac87c:	e17ffc17 	ldw	r5,-16(fp)
 90ac880:	e1fffd17 	ldw	r7,-12(fp)
 90ac884:	90c7ecc0 	call	90c7ecc <in_pcblookup>
 90ac888:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 90ac88c:	e0bffa17 	ldw	r2,-24(fp)
 90ac890:	1005003a 	cmpeq	r2,r2,zero
 90ac894:	10005f1e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 90ac898:	e0bffa17 	ldw	r2,-24(fp)
 90ac89c:	10800817 	ldw	r2,32(r2)
 90ac8a0:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 90ac8a4:	e0bff917 	ldw	r2,-28(fp)
 90ac8a8:	1005003a 	cmpeq	r2,r2,zero
 90ac8ac:	1000591e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 90ac8b0:	e0bffa17 	ldw	r2,-24(fp)
 90ac8b4:	10800917 	ldw	r2,36(r2)
 90ac8b8:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 90ac8bc:	e0bff817 	ldw	r2,-32(fp)
 90ac8c0:	1005003a 	cmpeq	r2,r2,zero
 90ac8c4:	1000061e 	bne	r2,zero,90ac8e0 <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 90ac8c8:	e0bff817 	ldw	r2,-32(fp)
 90ac8cc:	10800217 	ldw	r2,8(r2)
 90ac8d0:	10800090 	cmplti	r2,r2,2
 90ac8d4:	10004f1e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 90ac8d8:	e13ff817 	ldw	r4,-32(fp)
 90ac8dc:	90b78700 	call	90b7870 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 90ac8e0:	e0fff917 	ldw	r3,-28(fp)
 90ac8e4:	00801bc4 	movi	r2,111
 90ac8e8:	18800615 	stw	r2,24(r3)
 90ac8ec:	00004906 	br	90aca14 <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 90ac8f0:	e0bfff17 	ldw	r2,-4(fp)
 90ac8f4:	10800443 	ldbu	r2,17(r2)
 90ac8f8:	10803fcc 	andi	r2,r2,255
 90ac8fc:	10800458 	cmpnei	r2,r2,17
 90ac900:	1000441e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90ac904:	00824374 	movhi	r2,2317
 90ac908:	108f2204 	addi	r2,r2,15496
 90ac90c:	10800017 	ldw	r2,0(r2)
 90ac910:	e0bff715 	stw	r2,-36(fp)
 90ac914:	00002406 	br	90ac9a8 <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 90ac918:	e0bff717 	ldw	r2,-36(fp)
 90ac91c:	1080020b 	ldhu	r2,8(r2)
 90ac920:	10ffffcc 	andi	r3,r2,65535
 90ac924:	e0bffb8b 	ldhu	r2,-18(fp)
 90ac928:	18800526 	beq	r3,r2,90ac940 <so_icmpdu+0x258>
 90ac92c:	e0bff717 	ldw	r2,-36(fp)
 90ac930:	1080020b 	ldhu	r2,8(r2)
 90ac934:	10bfffcc 	andi	r2,r2,65535
 90ac938:	1004c03a 	cmpne	r2,r2,zero
 90ac93c:	1000171e 	bne	r2,zero,90ac99c <so_icmpdu+0x2b4>
 90ac940:	e0bff717 	ldw	r2,-36(fp)
 90ac944:	11000417 	ldw	r4,16(r2)
 90ac948:	e0bffc17 	ldw	r2,-16(fp)
 90ac94c:	1004d63a 	srli	r2,r2,24
 90ac950:	10c03fcc 	andi	r3,r2,255
 90ac954:	e0bffc17 	ldw	r2,-16(fp)
 90ac958:	1004d23a 	srli	r2,r2,8
 90ac95c:	10bfc00c 	andi	r2,r2,65280
 90ac960:	1886b03a 	or	r3,r3,r2
 90ac964:	e0bffc17 	ldw	r2,-16(fp)
 90ac968:	10bfc00c 	andi	r2,r2,65280
 90ac96c:	1004923a 	slli	r2,r2,8
 90ac970:	1886b03a 	or	r3,r3,r2
 90ac974:	e0bffc17 	ldw	r2,-16(fp)
 90ac978:	10803fcc 	andi	r2,r2,255
 90ac97c:	1004963a 	slli	r2,r2,24
 90ac980:	1884b03a 	or	r2,r3,r2
 90ac984:	2080051e 	bne	r4,r2,90ac99c <so_icmpdu+0x2b4>
 90ac988:	e0bff717 	ldw	r2,-36(fp)
 90ac98c:	1080018b 	ldhu	r2,6(r2)
 90ac990:	10ffffcc 	andi	r3,r2,65535
 90ac994:	e0bffb0b 	ldhu	r2,-20(fp)
 90ac998:	18800626 	beq	r3,r2,90ac9b4 <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90ac99c:	e0bff717 	ldw	r2,-36(fp)
 90ac9a0:	10800017 	ldw	r2,0(r2)
 90ac9a4:	e0bff715 	stw	r2,-36(fp)
 90ac9a8:	e0bff717 	ldw	r2,-36(fp)
 90ac9ac:	1004c03a 	cmpne	r2,r2,zero
 90ac9b0:	103fd91e 	bne	r2,zero,90ac918 <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 90ac9b4:	e0bff717 	ldw	r2,-36(fp)
 90ac9b8:	1005003a 	cmpeq	r2,r2,zero
 90ac9bc:	1000151e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 90ac9c0:	e0bff717 	ldw	r2,-36(fp)
 90ac9c4:	10800617 	ldw	r2,24(r2)
 90ac9c8:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 90ac9cc:	e0bff917 	ldw	r2,-28(fp)
 90ac9d0:	10800983 	ldbu	r2,38(r2)
 90ac9d4:	10803fcc 	andi	r2,r2,255
 90ac9d8:	1080201c 	xori	r2,r2,128
 90ac9dc:	10bfe004 	addi	r2,r2,-128
 90ac9e0:	10800098 	cmpnei	r2,r2,2
 90ac9e4:	10000b1e 	bne	r2,zero,90aca14 <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 90ac9e8:	e0fff917 	ldw	r3,-28(fp)
 90ac9ec:	00801bc4 	movi	r2,111
 90ac9f0:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 90ac9f4:	e0bff917 	ldw	r2,-28(fp)
 90ac9f8:	11400a04 	addi	r5,r2,40
 90ac9fc:	e13ff917 	ldw	r4,-28(fp)
 90aca00:	90b18e40 	call	90b18e4 <sbwakeup>
      sowwakeup(so);
 90aca04:	e0bff917 	ldw	r2,-28(fp)
 90aca08:	11401204 	addi	r5,r2,72
 90aca0c:	e13ff917 	ldw	r4,-28(fp)
 90aca10:	90b18e40 	call	90b18e4 <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90aca14:	01000084 	movi	r4,2
 90aca18:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 90aca1c:	e13ffe17 	ldw	r4,-8(fp)
 90aca20:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90aca24:	01000084 	movi	r4,2
 90aca28:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return;
}
 90aca2c:	e037883a 	mov	sp,fp
 90aca30:	dfc00117 	ldw	ra,4(sp)
 90aca34:	df000017 	ldw	fp,0(sp)
 90aca38:	dec00204 	addi	sp,sp,8
 90aca3c:	f800283a 	ret

090aca40 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 90aca40:	defffe04 	addi	sp,sp,-8
 90aca44:	dfc00115 	stw	ra,4(sp)
 90aca48:	df000015 	stw	fp,0(sp)
 90aca4c:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 90aca50:	d0a0ae17 	ldw	r2,-32072(gp)
 90aca54:	1004c03a 	cmpne	r2,r2,zero
 90aca58:	1000231e 	bne	r2,zero,90acae8 <tcp_tick+0xa8>
      return;
   in_tcptick++;
 90aca5c:	d0a0ae17 	ldw	r2,-32072(gp)
 90aca60:	10800044 	addi	r2,r2,1
 90aca64:	d0a0ae15 	stw	r2,-32072(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 90aca68:	0009883a 	mov	r4,zero
 90aca6c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 90aca70:	00824374 	movhi	r2,2317
 90aca74:	108f2e04 	addi	r2,r2,15544
 90aca78:	10c00017 	ldw	r3,0(r2)
 90aca7c:	d0a0ad17 	ldw	r2,-32076(gp)
 90aca80:	18801436 	bltu	r3,r2,90acad4 <tcp_tick+0x94>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 90aca84:	90b7a9c0 	call	90b7a9c <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 90aca88:	00824374 	movhi	r2,2317
 90aca8c:	108f2e04 	addi	r2,r2,15544
 90aca90:	11000017 	ldw	r4,0(r2)
 90aca94:	908d0380 	call	908d038 <__floatunsidf>
 90aca98:	100b883a 	mov	r5,r2
 90aca9c:	180d883a 	mov	r6,r3
 90acaa0:	2809883a 	mov	r4,r5
 90acaa4:	300b883a 	mov	r5,r6
 90acaa8:	000d883a 	mov	r6,zero
 90acaac:	01d01274 	movhi	r7,16457
 90acab0:	908c5400 	call	908c540 <__adddf3>
 90acab4:	1009883a 	mov	r4,r2
 90acab8:	180b883a 	mov	r5,r3
 90acabc:	2005883a 	mov	r2,r4
 90acac0:	2807883a 	mov	r3,r5
 90acac4:	1009883a 	mov	r4,r2
 90acac8:	180b883a 	mov	r5,r3
 90acacc:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90acad0:	d0a0ad15 	stw	r2,-32076(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 90acad4:	0009883a 	mov	r4,zero
 90acad8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 90acadc:	d0a0ae17 	ldw	r2,-32072(gp)
 90acae0:	10bfffc4 	addi	r2,r2,-1
 90acae4:	d0a0ae15 	stw	r2,-32072(gp)
}
 90acae8:	e037883a 	mov	sp,fp
 90acaec:	dfc00117 	ldw	ra,4(sp)
 90acaf0:	df000017 	ldw	fp,0(sp)
 90acaf4:	dec00204 	addi	sp,sp,8
 90acaf8:	f800283a 	ret

090acafc <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 90acafc:	defffc04 	addi	sp,sp,-16
 90acb00:	df000315 	stw	fp,12(sp)
 90acb04:	df000304 	addi	fp,sp,12
 90acb08:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 90acb0c:	00824374 	movhi	r2,2317
 90acb10:	108f5504 	addi	r2,r2,15700
 90acb14:	10800017 	ldw	r2,0(r2)
 90acb18:	e0bffd15 	stw	r2,-12(fp)
 90acb1c:	00000a06 	br	90acb48 <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 90acb20:	e0bffd17 	ldw	r2,-12(fp)
 90acb24:	10c00417 	ldw	r3,16(r2)
 90acb28:	e0bffe17 	ldw	r2,-8(fp)
 90acb2c:	1880031e 	bne	r3,r2,90acb3c <rawip_lookup+0x40>
      return (tmp);
 90acb30:	e0bffd17 	ldw	r2,-12(fp)
 90acb34:	e0bfff15 	stw	r2,-4(fp)
 90acb38:	00000706 	br	90acb58 <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 90acb3c:	e0bffd17 	ldw	r2,-12(fp)
 90acb40:	10800017 	ldw	r2,0(r2)
 90acb44:	e0bffd15 	stw	r2,-12(fp)
 90acb48:	e0bffd17 	ldw	r2,-12(fp)
 90acb4c:	1004c03a 	cmpne	r2,r2,zero
 90acb50:	103ff31e 	bne	r2,zero,90acb20 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 90acb54:	e03fff15 	stw	zero,-4(fp)
 90acb58:	e0bfff17 	ldw	r2,-4(fp)
}
 90acb5c:	e037883a 	mov	sp,fp
 90acb60:	df000017 	ldw	fp,0(sp)
 90acb64:	dec00104 	addi	sp,sp,4
 90acb68:	f800283a 	ret

090acb6c <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 90acb6c:	defff404 	addi	sp,sp,-48
 90acb70:	dfc00b15 	stw	ra,44(sp)
 90acb74:	df000a15 	stw	fp,40(sp)
 90acb78:	df000a04 	addi	fp,sp,40
 90acb7c:	e13ffd15 	stw	r4,-12(fp)
 90acb80:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 90acb84:	e0bffe17 	ldw	r2,-8(fp)
 90acb88:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 90acb8c:	0009883a 	mov	r4,zero
 90acb90:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 90acb94:	e0bff717 	ldw	r2,-36(fp)
 90acb98:	10c00a17 	ldw	r3,40(r2)
 90acb9c:	e0bffd17 	ldw	r2,-12(fp)
 90acba0:	10800417 	ldw	r2,16(r2)
 90acba4:	1887883a 	add	r3,r3,r2
 90acba8:	e0bff717 	ldw	r2,-36(fp)
 90acbac:	10800b17 	ldw	r2,44(r2)
 90acbb0:	18800536 	bltu	r3,r2,90acbc8 <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90acbb4:	0009883a 	mov	r4,zero
 90acbb8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90acbbc:	00801a44 	movi	r2,105
 90acbc0:	e0bfff15 	stw	r2,-4(fp)
 90acbc4:	00005806 	br	90acd28 <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 90acbc8:	01000044 	movi	r4,1
 90acbcc:	000b883a 	mov	r5,zero
 90acbd0:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90acbd4:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 90acbd8:	e0bff817 	ldw	r2,-32(fp)
 90acbdc:	1004c03a 	cmpne	r2,r2,zero
 90acbe0:	1000051e 	bne	r2,zero,90acbf8 <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90acbe4:	0009883a 	mov	r4,zero
 90acbe8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90acbec:	00801a44 	movi	r2,105
 90acbf0:	e0bfff15 	stw	r2,-4(fp)
 90acbf4:	00004c06 	br	90acd28 <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 90acbf8:	e0fff817 	ldw	r3,-32(fp)
 90acbfc:	e0bffd17 	ldw	r2,-12(fp)
 90acc00:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 90acc04:	e0bffd17 	ldw	r2,-12(fp)
 90acc08:	10c00117 	ldw	r3,4(r2)
 90acc0c:	e0bff817 	ldw	r2,-32(fp)
 90acc10:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 90acc14:	e0bffd17 	ldw	r2,-12(fp)
 90acc18:	10c00217 	ldw	r3,8(r2)
 90acc1c:	e0bff817 	ldw	r2,-32(fp)
 90acc20:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 90acc24:	e0bffd17 	ldw	r2,-12(fp)
 90acc28:	10c00317 	ldw	r3,12(r2)
 90acc2c:	e0bff817 	ldw	r2,-32(fp)
 90acc30:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90acc34:	e0bffd17 	ldw	r2,-12(fp)
 90acc38:	10c00417 	ldw	r3,16(r2)
 90acc3c:	e0bff817 	ldw	r2,-32(fp)
 90acc40:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 90acc44:	e0bff717 	ldw	r2,-36(fp)
 90acc48:	10800417 	ldw	r2,16(r2)
 90acc4c:	1088000c 	andi	r2,r2,8192
 90acc50:	1004c03a 	cmpne	r2,r2,zero
 90acc54:	1000141e 	bne	r2,zero,90acca8 <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 90acc58:	e0bffd17 	ldw	r2,-12(fp)
 90acc5c:	10800317 	ldw	r2,12(r2)
 90acc60:	10800003 	ldbu	r2,0(r2)
 90acc64:	10803fcc 	andi	r2,r2,255
 90acc68:	108003cc 	andi	r2,r2,15
 90acc6c:	1085883a 	add	r2,r2,r2
 90acc70:	1085883a 	add	r2,r2,r2
 90acc74:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 90acc78:	e0bff817 	ldw	r2,-32(fp)
 90acc7c:	10c00317 	ldw	r3,12(r2)
 90acc80:	e0bff617 	ldw	r2,-40(fp)
 90acc84:	1887883a 	add	r3,r3,r2
 90acc88:	e0bff817 	ldw	r2,-32(fp)
 90acc8c:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 90acc90:	e0bff817 	ldw	r2,-32(fp)
 90acc94:	10c00217 	ldw	r3,8(r2)
 90acc98:	e0bff617 	ldw	r2,-40(fp)
 90acc9c:	1887c83a 	sub	r3,r3,r2
 90acca0:	e0bff817 	ldw	r2,-32(fp)
 90acca4:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 90acca8:	e0bffd17 	ldw	r2,-12(fp)
 90accac:	10800717 	ldw	r2,28(r2)
 90accb0:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 90accb4:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 90accb8:	00800084 	movi	r2,2
 90accbc:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 90accc0:	e0bff717 	ldw	r2,-36(fp)
 90accc4:	11000a04 	addi	r4,r2,40
 90accc8:	e17ff904 	addi	r5,fp,-28
 90acccc:	e1bff817 	ldw	r6,-32(fp)
 90accd0:	90b1c300 	call	90b1c30 <sbappendaddr>
 90accd4:	1004c03a 	cmpne	r2,r2,zero
 90accd8:	1000091e 	bne	r2,zero,90acd00 <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 90accdc:	e0bff817 	ldw	r2,-32(fp)
 90acce0:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 90acce4:	e13ff817 	ldw	r4,-32(fp)
 90acce8:	90ab4600 	call	90ab460 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90accec:	0009883a 	mov	r4,zero
 90accf0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90accf4:	00801a44 	movi	r2,105
 90accf8:	e0bfff15 	stw	r2,-4(fp)
 90accfc:	00000a06 	br	90acd28 <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 90acd00:	e0bff717 	ldw	r2,-36(fp)
 90acd04:	11000a04 	addi	r4,r2,40
 90acd08:	90a5e940 	call	90a5e94 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 90acd0c:	e0bff717 	ldw	r2,-36(fp)
 90acd10:	11400a04 	addi	r5,r2,40
 90acd14:	e13ff717 	ldw	r4,-36(fp)
 90acd18:	90b18e40 	call	90b18e4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90acd1c:	0009883a 	mov	r4,zero
 90acd20:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return 0;
 90acd24:	e03fff15 	stw	zero,-4(fp)
 90acd28:	e0bfff17 	ldw	r2,-4(fp)
}
 90acd2c:	e037883a 	mov	sp,fp
 90acd30:	dfc00117 	ldw	ra,4(sp)
 90acd34:	df000017 	ldw	fp,0(sp)
 90acd38:	dec00204 	addi	sp,sp,8
 90acd3c:	f800283a 	ret

090acd40 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90acd40:	deffee04 	addi	sp,sp,-72
 90acd44:	dfc01115 	stw	ra,68(sp)
 90acd48:	df001015 	stw	fp,64(sp)
 90acd4c:	dc000f15 	stw	r16,60(sp)
 90acd50:	df000f04 	addi	fp,sp,60
 90acd54:	e13ffc15 	stw	r4,-16(fp)
 90acd58:	e17ffd15 	stw	r5,-12(fp)
 90acd5c:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 90acd60:	e0bffc17 	ldw	r2,-16(fp)
 90acd64:	10800717 	ldw	r2,28(r2)
 90acd68:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 90acd6c:	e0bff317 	ldw	r2,-52(fp)
 90acd70:	10800468 	cmpgeui	r2,r2,17
 90acd74:	1001e31e 	bne	r2,zero,90ad504 <rawip_usrreq+0x7c4>
 90acd78:	e0bff317 	ldw	r2,-52(fp)
 90acd7c:	1085883a 	add	r2,r2,r2
 90acd80:	1087883a 	add	r3,r2,r2
 90acd84:	008242f4 	movhi	r2,2315
 90acd88:	10b36604 	addi	r2,r2,-12904
 90acd8c:	1885883a 	add	r2,r3,r2
 90acd90:	10800017 	ldw	r2,0(r2)
 90acd94:	1000683a 	jmp	r2
 90acd98:	090acddc 	xori	r4,at,11063
 90acd9c:	090ace64 	muli	r4,at,11065
 90acda0:	090acea8 	cmpgeui	r4,at,11066
 90acda4:	090ad504 	addi	r4,at,11092
 90acda8:	090acea8 	cmpgeui	r4,at,11066
 90acdac:	090ad504 	addi	r4,at,11092
 90acdb0:	090ad4f8 	rdprs	r4,at,11091
 90acdb4:	090ad504 	addi	r4,at,11092
 90acdb8:	090ad4f8 	rdprs	r4,at,11091
 90acdbc:	090ad05c 	xori	r4,at,11073
 90acdc0:	090ad504 	addi	r4,at,11092
 90acdc4:	090ad504 	addi	r4,at,11092
 90acdc8:	090ad504 	addi	r4,at,11092
 90acdcc:	090ad504 	addi	r4,at,11092
 90acdd0:	090ad504 	addi	r4,at,11092
 90acdd4:	090ad44c 	andi	r4,at,11089
 90acdd8:	090ad44c 	andi	r4,at,11089
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 90acddc:	e0bffc17 	ldw	r2,-16(fp)
 90acde0:	10800417 	ldw	r2,16(r2)
 90acde4:	1108000c 	andi	r4,r2,8192
 90acde8:	90c36540 	call	90c3654 <ip_raw_maxalloc>
 90acdec:	1007883a 	mov	r3,r2
 90acdf0:	e0bffc17 	ldw	r2,-16(fp)
 90acdf4:	10c01315 	stw	r3,76(r2)
 90acdf8:	e0bffc17 	ldw	r2,-16(fp)
 90acdfc:	10c01317 	ldw	r3,76(r2)
 90ace00:	e0bffc17 	ldw	r2,-16(fp)
 90ace04:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 90ace08:	e0bffe17 	ldw	r2,-8(fp)
 90ace0c:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ace10:	0009883a 	mov	r4,zero
 90ace14:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 90ace18:	e13ff503 	ldbu	r4,-44(fp)
 90ace1c:	e0bffc17 	ldw	r2,-16(fp)
 90ace20:	d8800015 	stw	r2,0(sp)
 90ace24:	000b883a 	mov	r5,zero
 90ace28:	000d883a 	mov	r6,zero
 90ace2c:	01c242f4 	movhi	r7,2315
 90ace30:	39f2db04 	addi	r7,r7,-13460
 90ace34:	90c31600 	call	90c3160 <ip_raw_open>
 90ace38:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 90ace3c:	0009883a 	mov	r4,zero
 90ace40:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      if (!ep)
 90ace44:	e0bff817 	ldw	r2,-32(fp)
 90ace48:	1004c03a 	cmpne	r2,r2,zero
 90ace4c:	1000031e 	bne	r2,zero,90ace5c <rawip_usrreq+0x11c>
         return(EINVAL);
 90ace50:	00800584 	movi	r2,22
 90ace54:	e0bfff15 	stw	r2,-4(fp)
 90ace58:	0001ac06 	br	90ad50c <rawip_usrreq+0x7cc>
      return 0;
 90ace5c:	e03fff15 	stw	zero,-4(fp)
 90ace60:	0001aa06 	br	90ad50c <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 90ace64:	e13ffc17 	ldw	r4,-16(fp)
 90ace68:	90acafc0 	call	90acafc <rawip_lookup>
 90ace6c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90ace70:	e0bff817 	ldw	r2,-32(fp)
 90ace74:	1004c03a 	cmpne	r2,r2,zero
 90ace78:	1000031e 	bne	r2,zero,90ace88 <rawip_usrreq+0x148>
         return(EINVAL);
 90ace7c:	00800584 	movi	r2,22
 90ace80:	e0bfff15 	stw	r2,-4(fp)
 90ace84:	0001a106 	br	90ad50c <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ace88:	0009883a 	mov	r4,zero
 90ace8c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 90ace90:	e13ff817 	ldw	r4,-32(fp)
 90ace94:	90c32500 	call	90c3250 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 90ace98:	0009883a 	mov	r4,zero
 90ace9c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      return 0;
 90acea0:	e03fff15 	stw	zero,-4(fp)
 90acea4:	00019906 	br	90ad50c <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 90acea8:	e0bffe17 	ldw	r2,-8(fp)
 90aceac:	1004c03a 	cmpne	r2,r2,zero
 90aceb0:	1000031e 	bne	r2,zero,90acec0 <rawip_usrreq+0x180>
         return(EINVAL);
 90aceb4:	00800584 	movi	r2,22
 90aceb8:	e0bfff15 	stw	r2,-4(fp)
 90acebc:	00019306 	br	90ad50c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 90acec0:	e0bffe17 	ldw	r2,-8(fp)
 90acec4:	10800317 	ldw	r2,12(r2)
 90acec8:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 90acecc:	e0bff917 	ldw	r2,-28(fp)
 90aced0:	1004c03a 	cmpne	r2,r2,zero
 90aced4:	1000031e 	bne	r2,zero,90acee4 <rawip_usrreq+0x1a4>
         return(EINVAL);
 90aced8:	00800584 	movi	r2,22
 90acedc:	e0bfff15 	stw	r2,-4(fp)
 90acee0:	00018a06 	br	90ad50c <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 90acee4:	e0bffe17 	ldw	r2,-8(fp)
 90acee8:	10800217 	ldw	r2,8(r2)
 90aceec:	10800420 	cmpeqi	r2,r2,16
 90acef0:	1000031e 	bne	r2,zero,90acf00 <rawip_usrreq+0x1c0>
         return(EINVAL);
 90acef4:	00800584 	movi	r2,22
 90acef8:	e0bfff15 	stw	r2,-4(fp)
 90acefc:	00018306 	br	90ad50c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 90acf00:	e13ffc17 	ldw	r4,-16(fp)
 90acf04:	90acafc0 	call	90acafc <rawip_lookup>
 90acf08:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90acf0c:	e0bff817 	ldw	r2,-32(fp)
 90acf10:	1004c03a 	cmpne	r2,r2,zero
 90acf14:	1000031e 	bne	r2,zero,90acf24 <rawip_usrreq+0x1e4>
         return(EINVAL);
 90acf18:	00800584 	movi	r2,22
 90acf1c:	e0bfff15 	stw	r2,-4(fp)
 90acf20:	00017a06 	br	90ad50c <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 90acf24:	e0bff317 	ldw	r2,-52(fp)
 90acf28:	10800098 	cmpnei	r2,r2,2
 90acf2c:	1000221e 	bne	r2,zero,90acfb8 <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 90acf30:	e0bff917 	ldw	r2,-28(fp)
 90acf34:	10800117 	ldw	r2,4(r2)
 90acf38:	1004c03a 	cmpne	r2,r2,zero
 90acf3c:	1000021e 	bne	r2,zero,90acf48 <rawip_usrreq+0x208>
         {
            lhost = 0L;
 90acf40:	e03ff615 	stw	zero,-40(fp)
 90acf44:	00001806 	br	90acfa8 <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 90acf48:	e0bff917 	ldw	r2,-28(fp)
 90acf4c:	10800117 	ldw	r2,4(r2)
 90acf50:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90acf54:	008243b4 	movhi	r2,2318
 90acf58:	10b82704 	addi	r2,r2,-8036
 90acf5c:	10800017 	ldw	r2,0(r2)
 90acf60:	e0bff215 	stw	r2,-56(fp)
 90acf64:	00000706 	br	90acf84 <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 90acf68:	e0bff217 	ldw	r2,-56(fp)
 90acf6c:	10c00a17 	ldw	r3,40(r2)
 90acf70:	e0bff617 	ldw	r2,-40(fp)
 90acf74:	18800626 	beq	r3,r2,90acf90 <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90acf78:	e0bff217 	ldw	r2,-56(fp)
 90acf7c:	10800017 	ldw	r2,0(r2)
 90acf80:	e0bff215 	stw	r2,-56(fp)
 90acf84:	e0bff217 	ldw	r2,-56(fp)
 90acf88:	1004c03a 	cmpne	r2,r2,zero
 90acf8c:	103ff61e 	bne	r2,zero,90acf68 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 90acf90:	e0bff217 	ldw	r2,-56(fp)
 90acf94:	1004c03a 	cmpne	r2,r2,zero
 90acf98:	1000031e 	bne	r2,zero,90acfa8 <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 90acf9c:	00801f44 	movi	r2,125
 90acfa0:	e0bfff15 	stw	r2,-4(fp)
 90acfa4:	00015906 	br	90ad50c <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 90acfa8:	e0fff817 	ldw	r3,-32(fp)
 90acfac:	e0bff617 	ldw	r2,-40(fp)
 90acfb0:	18800115 	stw	r2,4(r3)
 90acfb4:	00002706 	br	90ad054 <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 90acfb8:	e0bff917 	ldw	r2,-28(fp)
 90acfbc:	10800117 	ldw	r2,4(r2)
 90acfc0:	1004c03a 	cmpne	r2,r2,zero
 90acfc4:	1000021e 	bne	r2,zero,90acfd0 <rawip_usrreq+0x290>
            fhost = 0L;
 90acfc8:	e03ff715 	stw	zero,-36(fp)
 90acfcc:	00000306 	br	90acfdc <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 90acfd0:	e0bff917 	ldw	r2,-28(fp)
 90acfd4:	10800117 	ldw	r2,4(r2)
 90acfd8:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 90acfdc:	e0fff817 	ldw	r3,-32(fp)
 90acfe0:	e0bff717 	ldw	r2,-36(fp)
 90acfe4:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 90acfe8:	e0bff717 	ldw	r2,-36(fp)
 90acfec:	1005003a 	cmpeq	r2,r2,zero
 90acff0:	10000e1e 	bne	r2,zero,90ad02c <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90acff4:	e0bffc17 	ldw	r2,-16(fp)
 90acff8:	10c0088b 	ldhu	r3,34(r2)
 90acffc:	00bffcc4 	movi	r2,-13
 90ad000:	1884703a 	and	r2,r3,r2
 90ad004:	1007883a 	mov	r3,r2
 90ad008:	e0bffc17 	ldw	r2,-16(fp)
 90ad00c:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 90ad010:	e0bffc17 	ldw	r2,-16(fp)
 90ad014:	1080088b 	ldhu	r2,34(r2)
 90ad018:	10800094 	ori	r2,r2,2
 90ad01c:	1007883a 	mov	r3,r2
 90ad020:	e0bffc17 	ldw	r2,-16(fp)
 90ad024:	10c0088d 	sth	r3,34(r2)
 90ad028:	00000706 	br	90ad048 <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 90ad02c:	e0bffc17 	ldw	r2,-16(fp)
 90ad030:	10c0088b 	ldhu	r3,34(r2)
 90ad034:	00bfff44 	movi	r2,-3
 90ad038:	1884703a 	and	r2,r3,r2
 90ad03c:	1007883a 	mov	r3,r2
 90ad040:	e0bffc17 	ldw	r2,-16(fp)
 90ad044:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 90ad048:	e0bffc17 	ldw	r2,-16(fp)
 90ad04c:	11000a04 	addi	r4,r2,40
 90ad050:	90b20200 	call	90b2020 <sbflush>
      }
      return 0;
 90ad054:	e03fff15 	stw	zero,-4(fp)
 90ad058:	00012c06 	br	90ad50c <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 90ad05c:	e0bffd17 	ldw	r2,-12(fp)
 90ad060:	1004c03a 	cmpne	r2,r2,zero
 90ad064:	1000031e 	bne	r2,zero,90ad074 <rawip_usrreq+0x334>
         return(EINVAL);
 90ad068:	00800584 	movi	r2,22
 90ad06c:	e0bfff15 	stw	r2,-4(fp)
 90ad070:	00012606 	br	90ad50c <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 90ad074:	e13ffc17 	ldw	r4,-16(fp)
 90ad078:	90acafc0 	call	90acafc <rawip_lookup>
 90ad07c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90ad080:	e0bff817 	ldw	r2,-32(fp)
 90ad084:	1004c03a 	cmpne	r2,r2,zero
 90ad088:	1000051e 	bne	r2,zero,90ad0a0 <rawip_usrreq+0x360>
      {
         m_free(m);
 90ad08c:	e13ffd17 	ldw	r4,-12(fp)
 90ad090:	90ab4600 	call	90ab460 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 90ad094:	00801bc4 	movi	r2,111
 90ad098:	e0bfff15 	stw	r2,-4(fp)
 90ad09c:	00011b06 	br	90ad50c <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 90ad0a0:	e0bffe17 	ldw	r2,-8(fp)
 90ad0a4:	1004c03a 	cmpne	r2,r2,zero
 90ad0a8:	10000d1e 	bne	r2,zero,90ad0e0 <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 90ad0ac:	e0bffc17 	ldw	r2,-16(fp)
 90ad0b0:	1080088b 	ldhu	r2,34(r2)
 90ad0b4:	10bfffcc 	andi	r2,r2,65535
 90ad0b8:	1080008c 	andi	r2,r2,2
 90ad0bc:	1004c03a 	cmpne	r2,r2,zero
 90ad0c0:	1000031e 	bne	r2,zero,90ad0d0 <rawip_usrreq+0x390>
            return (ENOTCONN);
 90ad0c4:	00802004 	movi	r2,128
 90ad0c8:	e0bfff15 	stw	r2,-4(fp)
 90ad0cc:	00010f06 	br	90ad50c <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 90ad0d0:	e0bff817 	ldw	r2,-32(fp)
 90ad0d4:	10800217 	ldw	r2,8(r2)
 90ad0d8:	e0bff715 	stw	r2,-36(fp)
 90ad0dc:	00001706 	br	90ad13c <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 90ad0e0:	e0bffc17 	ldw	r2,-16(fp)
 90ad0e4:	1080088b 	ldhu	r2,34(r2)
 90ad0e8:	10bfffcc 	andi	r2,r2,65535
 90ad0ec:	1080008c 	andi	r2,r2,2
 90ad0f0:	1005003a 	cmpeq	r2,r2,zero
 90ad0f4:	1000031e 	bne	r2,zero,90ad104 <rawip_usrreq+0x3c4>
            return (EISCONN);
 90ad0f8:	00801fc4 	movi	r2,127
 90ad0fc:	e0bfff15 	stw	r2,-4(fp)
 90ad100:	00010206 	br	90ad50c <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 90ad104:	e0bffe17 	ldw	r2,-8(fp)
 90ad108:	10800217 	ldw	r2,8(r2)
 90ad10c:	10800420 	cmpeqi	r2,r2,16
 90ad110:	1000041e 	bne	r2,zero,90ad124 <rawip_usrreq+0x3e4>
         {
            dtrap();
 90ad114:	90aa4780 	call	90aa478 <dtrap>
            return (EINVAL);
 90ad118:	00800584 	movi	r2,22
 90ad11c:	e0bfff15 	stw	r2,-4(fp)
 90ad120:	0000fa06 	br	90ad50c <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 90ad124:	e0bffe17 	ldw	r2,-8(fp)
 90ad128:	10800317 	ldw	r2,12(r2)
 90ad12c:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 90ad130:	e0bff917 	ldw	r2,-28(fp)
 90ad134:	10800117 	ldw	r2,4(r2)
 90ad138:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 90ad13c:	e0bffd17 	ldw	r2,-12(fp)
 90ad140:	14000217 	ldw	r16,8(r2)
 90ad144:	e0bffc17 	ldw	r2,-16(fp)
 90ad148:	10800417 	ldw	r2,16(r2)
 90ad14c:	1108000c 	andi	r4,r2,8192
 90ad150:	90c36540 	call	90c3654 <ip_raw_maxalloc>
 90ad154:	1400042e 	bgeu	r2,r16,90ad168 <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 90ad158:	90aa4780 	call	90aa478 <dtrap>
         return EMSGSIZE;  /* try to recover */
 90ad15c:	00801e84 	movi	r2,122
 90ad160:	e0bfff15 	stw	r2,-4(fp)
 90ad164:	0000e906 	br	90ad50c <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 90ad168:	e0bffd17 	ldw	r2,-12(fp)
 90ad16c:	10800217 	ldw	r2,8(r2)
 90ad170:	1009883a 	mov	r4,r2
 90ad174:	e0bffc17 	ldw	r2,-16(fp)
 90ad178:	10800417 	ldw	r2,16(r2)
 90ad17c:	1148000c 	andi	r5,r2,8192
 90ad180:	90c35480 	call	90c3548 <ip_raw_alloc>
 90ad184:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 90ad188:	e0bffa17 	ldw	r2,-24(fp)
 90ad18c:	1004c03a 	cmpne	r2,r2,zero
 90ad190:	1000051e 	bne	r2,zero,90ad1a8 <rawip_usrreq+0x468>
      {
         m_free(m);
 90ad194:	e13ffd17 	ldw	r4,-12(fp)
 90ad198:	90ab4600 	call	90ab460 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 90ad19c:	00801a44 	movi	r2,105
 90ad1a0:	e0bfff15 	stw	r2,-4(fp)
 90ad1a4:	0000d906 	br	90ad50c <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 90ad1a8:	e0bffa17 	ldw	r2,-24(fp)
 90ad1ac:	10c00317 	ldw	r3,12(r2)
 90ad1b0:	e0bffd17 	ldw	r2,-12(fp)
 90ad1b4:	11400317 	ldw	r5,12(r2)
 90ad1b8:	e0bffd17 	ldw	r2,-12(fp)
 90ad1bc:	10800217 	ldw	r2,8(r2)
 90ad1c0:	1809883a 	mov	r4,r3
 90ad1c4:	100d883a 	mov	r6,r2
 90ad1c8:	90894600 	call	9089460 <memcpy>
      pkt->nb_plen = m->m_len;
 90ad1cc:	e0bffd17 	ldw	r2,-12(fp)
 90ad1d0:	10c00217 	ldw	r3,8(r2)
 90ad1d4:	e0bffa17 	ldw	r2,-24(fp)
 90ad1d8:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 90ad1dc:	e13ffd17 	ldw	r4,-12(fp)
 90ad1e0:	90ab4600 	call	90ab460 <m_free>
      pkt->fhost = fhost;
 90ad1e4:	e0fffa17 	ldw	r3,-24(fp)
 90ad1e8:	e0bff717 	ldw	r2,-36(fp)
 90ad1ec:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 90ad1f0:	e0bff717 	ldw	r2,-36(fp)
 90ad1f4:	10bfffd8 	cmpnei	r2,r2,-1
 90ad1f8:	10004f1e 	bne	r2,zero,90ad338 <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 90ad1fc:	e0bff817 	ldw	r2,-32(fp)
 90ad200:	10800117 	ldw	r2,4(r2)
 90ad204:	1005003a 	cmpeq	r2,r2,zero
 90ad208:	1000111e 	bne	r2,zero,90ad250 <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad20c:	008243b4 	movhi	r2,2318
 90ad210:	10b82704 	addi	r2,r2,-8036
 90ad214:	10800017 	ldw	r2,0(r2)
 90ad218:	e0bff215 	stw	r2,-56(fp)
 90ad21c:	00000806 	br	90ad240 <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 90ad220:	e0bff217 	ldw	r2,-56(fp)
 90ad224:	10c00a17 	ldw	r3,40(r2)
 90ad228:	e0bff817 	ldw	r2,-32(fp)
 90ad22c:	10800117 	ldw	r2,4(r2)
 90ad230:	18802126 	beq	r3,r2,90ad2b8 <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad234:	e0bff217 	ldw	r2,-56(fp)
 90ad238:	10800017 	ldw	r2,0(r2)
 90ad23c:	e0bff215 	stw	r2,-56(fp)
 90ad240:	e0bff217 	ldw	r2,-56(fp)
 90ad244:	1004c03a 	cmpne	r2,r2,zero
 90ad248:	103ff51e 	bne	r2,zero,90ad220 <rawip_usrreq+0x4e0>
 90ad24c:	00001a06 	br	90ad2b8 <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad250:	008243b4 	movhi	r2,2318
 90ad254:	10b82704 	addi	r2,r2,-8036
 90ad258:	10800017 	ldw	r2,0(r2)
 90ad25c:	e0bff215 	stw	r2,-56(fp)
 90ad260:	00001206 	br	90ad2ac <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 90ad264:	e0bff217 	ldw	r2,-56(fp)
 90ad268:	10802a17 	ldw	r2,168(r2)
 90ad26c:	1080004c 	andi	r2,r2,1
 90ad270:	10803fcc 	andi	r2,r2,255
 90ad274:	1005003a 	cmpeq	r2,r2,zero
 90ad278:	1000091e 	bne	r2,zero,90ad2a0 <rawip_usrreq+0x560>
 90ad27c:	e0bff217 	ldw	r2,-56(fp)
 90ad280:	10802717 	ldw	r2,156(r2)
 90ad284:	1005003a 	cmpeq	r2,r2,zero
 90ad288:	1000051e 	bne	r2,zero,90ad2a0 <rawip_usrreq+0x560>
 90ad28c:	e0bff217 	ldw	r2,-56(fp)
 90ad290:	10802717 	ldw	r2,156(r2)
 90ad294:	10800617 	ldw	r2,24(r2)
 90ad298:	10800060 	cmpeqi	r2,r2,1
 90ad29c:	1000061e 	bne	r2,zero,90ad2b8 <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad2a0:	e0bff217 	ldw	r2,-56(fp)
 90ad2a4:	10800017 	ldw	r2,0(r2)
 90ad2a8:	e0bff215 	stw	r2,-56(fp)
 90ad2ac:	e0bff217 	ldw	r2,-56(fp)
 90ad2b0:	1004c03a 	cmpne	r2,r2,zero
 90ad2b4:	103feb1e 	bne	r2,zero,90ad264 <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 90ad2b8:	e0bff217 	ldw	r2,-56(fp)
 90ad2bc:	1004c03a 	cmpne	r2,r2,zero
 90ad2c0:	10001a1e 	bne	r2,zero,90ad32c <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad2c4:	008243b4 	movhi	r2,2318
 90ad2c8:	10b82704 	addi	r2,r2,-8036
 90ad2cc:	10800017 	ldw	r2,0(r2)
 90ad2d0:	e0bff215 	stw	r2,-56(fp)
 90ad2d4:	00000c06 	br	90ad308 <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 90ad2d8:	e0bff217 	ldw	r2,-56(fp)
 90ad2dc:	10802717 	ldw	r2,156(r2)
 90ad2e0:	1005003a 	cmpeq	r2,r2,zero
 90ad2e4:	1000051e 	bne	r2,zero,90ad2fc <rawip_usrreq+0x5bc>
 90ad2e8:	e0bff217 	ldw	r2,-56(fp)
 90ad2ec:	10802717 	ldw	r2,156(r2)
 90ad2f0:	10800617 	ldw	r2,24(r2)
 90ad2f4:	10800060 	cmpeqi	r2,r2,1
 90ad2f8:	1000061e 	bne	r2,zero,90ad314 <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90ad2fc:	e0bff217 	ldw	r2,-56(fp)
 90ad300:	10800017 	ldw	r2,0(r2)
 90ad304:	e0bff215 	stw	r2,-56(fp)
 90ad308:	e0bff217 	ldw	r2,-56(fp)
 90ad30c:	1004c03a 	cmpne	r2,r2,zero
 90ad310:	103ff11e 	bne	r2,zero,90ad2d8 <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 90ad314:	e0bff217 	ldw	r2,-56(fp)
 90ad318:	1004c03a 	cmpne	r2,r2,zero
 90ad31c:	1000031e 	bne	r2,zero,90ad32c <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 90ad320:	00801f44 	movi	r2,125
 90ad324:	e0bfff15 	stw	r2,-4(fp)
 90ad328:	00007806 	br	90ad50c <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 90ad32c:	e0fffa17 	ldw	r3,-24(fp)
 90ad330:	e0bff217 	ldw	r2,-56(fp)
 90ad334:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 90ad338:	e0bffc17 	ldw	r2,-16(fp)
 90ad33c:	10800317 	ldw	r2,12(r2)
 90ad340:	1005003a 	cmpeq	r2,r2,zero
 90ad344:	1000041e 	bne	r2,zero,90ad358 <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 90ad348:	e0bffc17 	ldw	r2,-16(fp)
 90ad34c:	10c00317 	ldw	r3,12(r2)
 90ad350:	e0bffa17 	ldw	r2,-24(fp)
 90ad354:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 90ad358:	e0bffc17 	ldw	r2,-16(fp)
 90ad35c:	10800417 	ldw	r2,16(r2)
 90ad360:	1088000c 	andi	r2,r2,8192
 90ad364:	1005003a 	cmpeq	r2,r2,zero
 90ad368:	1000081e 	bne	r2,zero,90ad38c <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ad36c:	0009883a 	mov	r4,zero
 90ad370:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 90ad374:	e13ffa17 	ldw	r4,-24(fp)
 90ad378:	90beebc0 	call	90beebc <ip_raw_write>
 90ad37c:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90ad380:	0009883a 	mov	r4,zero
 90ad384:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
 90ad388:	00002806 	br	90ad42c <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 90ad38c:	e0bffa17 	ldw	r2,-24(fp)
 90ad390:	10800317 	ldw	r2,12(r2)
 90ad394:	10bffb04 	addi	r2,r2,-20
 90ad398:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 90ad39c:	e0bff817 	ldw	r2,-32(fp)
 90ad3a0:	10800117 	ldw	r2,4(r2)
 90ad3a4:	1005003a 	cmpeq	r2,r2,zero
 90ad3a8:	1000051e 	bne	r2,zero,90ad3c0 <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 90ad3ac:	e0bff817 	ldw	r2,-32(fp)
 90ad3b0:	10c00117 	ldw	r3,4(r2)
 90ad3b4:	e0bff417 	ldw	r2,-48(fp)
 90ad3b8:	10c00315 	stw	r3,12(r2)
 90ad3bc:	00000e06 	br	90ad3f8 <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 90ad3c0:	e0bff717 	ldw	r2,-36(fp)
 90ad3c4:	10bfffd8 	cmpnei	r2,r2,-1
 90ad3c8:	1000061e 	bne	r2,zero,90ad3e4 <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 90ad3cc:	e0bffa17 	ldw	r2,-24(fp)
 90ad3d0:	10800617 	ldw	r2,24(r2)
 90ad3d4:	10c00a17 	ldw	r3,40(r2)
 90ad3d8:	e0bff417 	ldw	r2,-48(fp)
 90ad3dc:	10c00315 	stw	r3,12(r2)
 90ad3e0:	00000506 	br	90ad3f8 <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 90ad3e4:	e13ff717 	ldw	r4,-36(fp)
 90ad3e8:	90bfa480 	call	90bfa48 <ip_mymach>
 90ad3ec:	1007883a 	mov	r3,r2
 90ad3f0:	e0bff417 	ldw	r2,-48(fp)
 90ad3f4:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 90ad3f8:	e0fff417 	ldw	r3,-48(fp)
 90ad3fc:	e0bff717 	ldw	r2,-36(fp)
 90ad400:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ad404:	0009883a 	mov	r4,zero
 90ad408:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 90ad40c:	e0bff817 	ldw	r2,-32(fp)
 90ad410:	10800503 	ldbu	r2,20(r2)
 90ad414:	11003fcc 	andi	r4,r2,255
 90ad418:	e17ffa17 	ldw	r5,-24(fp)
 90ad41c:	90be8c40 	call	90be8c4 <ip_write>
 90ad420:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90ad424:	0009883a 	mov	r4,zero
 90ad428:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 90ad42c:	e0bffb17 	ldw	r2,-20(fp)
 90ad430:	1004403a 	cmpge	r2,r2,zero
 90ad434:	1000031e 	bne	r2,zero,90ad444 <rawip_usrreq+0x704>
         return(e);
 90ad438:	e0bffb17 	ldw	r2,-20(fp)
 90ad43c:	e0bfff15 	stw	r2,-4(fp)
 90ad440:	00003206 	br	90ad50c <rawip_usrreq+0x7cc>
      return 0;
 90ad444:	e03fff15 	stw	zero,-4(fp)
 90ad448:	00003006 	br	90ad50c <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 90ad44c:	e0bffe17 	ldw	r2,-8(fp)
 90ad450:	1004c03a 	cmpne	r2,r2,zero
 90ad454:	1000031e 	bne	r2,zero,90ad464 <rawip_usrreq+0x724>
         return(EINVAL);
 90ad458:	00800584 	movi	r2,22
 90ad45c:	e0bfff15 	stw	r2,-4(fp)
 90ad460:	00002a06 	br	90ad50c <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 90ad464:	e0bffe17 	ldw	r2,-8(fp)
 90ad468:	10800317 	ldw	r2,12(r2)
 90ad46c:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 90ad470:	e0bff917 	ldw	r2,-28(fp)
 90ad474:	1004c03a 	cmpne	r2,r2,zero
 90ad478:	1000031e 	bne	r2,zero,90ad488 <rawip_usrreq+0x748>
         return(EINVAL);
 90ad47c:	00800584 	movi	r2,22
 90ad480:	e0bfff15 	stw	r2,-4(fp)
 90ad484:	00002106 	br	90ad50c <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 90ad488:	e13ffc17 	ldw	r4,-16(fp)
 90ad48c:	90acafc0 	call	90acafc <rawip_lookup>
 90ad490:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 90ad494:	e0bff817 	ldw	r2,-32(fp)
 90ad498:	1004c03a 	cmpne	r2,r2,zero
 90ad49c:	1000031e 	bne	r2,zero,90ad4ac <rawip_usrreq+0x76c>
         return(EINVAL);
 90ad4a0:	00800584 	movi	r2,22
 90ad4a4:	e0bfff15 	stw	r2,-4(fp)
 90ad4a8:	00001806 	br	90ad50c <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 90ad4ac:	e0bff917 	ldw	r2,-28(fp)
 90ad4b0:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 90ad4b4:	e0fffe17 	ldw	r3,-8(fp)
 90ad4b8:	00800404 	movi	r2,16
 90ad4bc:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 90ad4c0:	e0bff317 	ldw	r2,-52(fp)
 90ad4c4:	108003d8 	cmpnei	r2,r2,15
 90ad4c8:	1000051e 	bne	r2,zero,90ad4e0 <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 90ad4cc:	e0bff817 	ldw	r2,-32(fp)
 90ad4d0:	10c00117 	ldw	r3,4(r2)
 90ad4d4:	e0bff917 	ldw	r2,-28(fp)
 90ad4d8:	10c00115 	stw	r3,4(r2)
 90ad4dc:	00000406 	br	90ad4f0 <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 90ad4e0:	e0bff817 	ldw	r2,-32(fp)
 90ad4e4:	10c00217 	ldw	r3,8(r2)
 90ad4e8:	e0bff917 	ldw	r2,-28(fp)
 90ad4ec:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 90ad4f0:	e03fff15 	stw	zero,-4(fp)
 90ad4f4:	00000506 	br	90ad50c <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 90ad4f8:	90aa4780 	call	90aa478 <dtrap>
      return 0;
 90ad4fc:	e03fff15 	stw	zero,-4(fp)
 90ad500:	00000206 	br	90ad50c <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 90ad504:	008017c4 	movi	r2,95
 90ad508:	e0bfff15 	stw	r2,-4(fp)
 90ad50c:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90ad510:	e037883a 	mov	sp,fp
 90ad514:	dfc00217 	ldw	ra,8(sp)
 90ad518:	df000117 	ldw	fp,4(sp)
 90ad51c:	dc000017 	ldw	r16,0(sp)
 90ad520:	dec00304 	addi	sp,sp,12
 90ad524:	f800283a 	ret

090ad528 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 90ad528:	defffc04 	addi	sp,sp,-16
 90ad52c:	dfc00315 	stw	ra,12(sp)
 90ad530:	df000215 	stw	fp,8(sp)
 90ad534:	df000204 	addi	fp,sp,8
 90ad538:	e13ffe15 	stw	r4,-8(fp)
 90ad53c:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 90ad540:	e0bffe17 	ldw	r2,-8(fp)
 90ad544:	10800517 	ldw	r2,20(r2)
 90ad548:	10800098 	cmpnei	r2,r2,2
 90ad54c:	1000041e 	bne	r2,zero,90ad560 <DOMAIN_CHECK+0x38>
 90ad550:	e0bfff17 	ldw	r2,-4(fp)
 90ad554:	10800428 	cmpgeui	r2,r2,16
 90ad558:	1000011e 	bne	r2,zero,90ad560 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 90ad55c:	90aa4780 	call	90aa478 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 90ad560:	e037883a 	mov	sp,fp
 90ad564:	dfc00117 	ldw	ra,4(sp)
 90ad568:	df000017 	ldw	fp,0(sp)
 90ad56c:	dec00204 	addi	sp,sp,8
 90ad570:	f800283a 	ret

090ad574 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 90ad574:	defff904 	addi	sp,sp,-28
 90ad578:	dfc00615 	stw	ra,24(sp)
 90ad57c:	df000515 	stw	fp,20(sp)
 90ad580:	df000504 	addi	fp,sp,20
 90ad584:	e13ffc15 	stw	r4,-16(fp)
 90ad588:	e17ffd15 	stw	r5,-12(fp)
 90ad58c:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 90ad590:	0009883a 	mov	r4,zero
 90ad594:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 90ad598:	e13ffc17 	ldw	r4,-16(fp)
 90ad59c:	e17ffd17 	ldw	r5,-12(fp)
 90ad5a0:	e1bffe17 	ldw	r6,-8(fp)
 90ad5a4:	90aed240 	call	90aed24 <socreate>
 90ad5a8:	e0bffb15 	stw	r2,-20(fp)
 90ad5ac:	e0bffb17 	ldw	r2,-20(fp)
 90ad5b0:	1004c03a 	cmpne	r2,r2,zero
 90ad5b4:	1000051e 	bne	r2,zero,90ad5cc <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ad5b8:	0009883a 	mov	r4,zero
 90ad5bc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90ad5c0:	00bfffc4 	movi	r2,-1
 90ad5c4:	e0bfff15 	stw	r2,-4(fp)
 90ad5c8:	00000806 	br	90ad5ec <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 90ad5cc:	e0bffb17 	ldw	r2,-20(fp)
 90ad5d0:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad5d4:	0009883a 	mov	r4,zero
 90ad5d8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 90ad5dc:	e0bffb17 	ldw	r2,-20(fp)
 90ad5e0:	1004d0ba 	srli	r2,r2,2
 90ad5e4:	10800804 	addi	r2,r2,32
 90ad5e8:	e0bfff15 	stw	r2,-4(fp)
 90ad5ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad5f0:	e037883a 	mov	sp,fp
 90ad5f4:	dfc00117 	ldw	ra,4(sp)
 90ad5f8:	df000017 	ldw	fp,0(sp)
 90ad5fc:	dec00204 	addi	sp,sp,8
 90ad600:	f800283a 	ret

090ad604 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 90ad604:	defff104 	addi	sp,sp,-60
 90ad608:	dfc00e15 	stw	ra,56(sp)
 90ad60c:	df000d15 	stw	fp,52(sp)
 90ad610:	df000d04 	addi	fp,sp,52
 90ad614:	e13ffc15 	stw	r4,-16(fp)
 90ad618:	e17ffd15 	stw	r5,-12(fp)
 90ad61c:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 90ad620:	e0bffc17 	ldw	r2,-16(fp)
 90ad624:	10bff804 	addi	r2,r2,-32
 90ad628:	1085883a 	add	r2,r2,r2
 90ad62c:	1085883a 	add	r2,r2,r2
 90ad630:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 90ad634:	008243b4 	movhi	r2,2318
 90ad638:	10b72304 	addi	r2,r2,-9076
 90ad63c:	e0bff315 	stw	r2,-52(fp)
 90ad640:	00000606 	br	90ad65c <t_bind+0x58>
 90ad644:	e0fff317 	ldw	r3,-52(fp)
 90ad648:	e0bff517 	ldw	r2,-44(fp)
 90ad64c:	18800626 	beq	r3,r2,90ad668 <t_bind+0x64>
 90ad650:	e0bff317 	ldw	r2,-52(fp)
 90ad654:	10800017 	ldw	r2,0(r2)
 90ad658:	e0bff315 	stw	r2,-52(fp)
 90ad65c:	e0bff317 	ldw	r2,-52(fp)
 90ad660:	1004c03a 	cmpne	r2,r2,zero
 90ad664:	103ff71e 	bne	r2,zero,90ad644 <t_bind+0x40>
 90ad668:	e0fff317 	ldw	r3,-52(fp)
 90ad66c:	e0bff517 	ldw	r2,-44(fp)
 90ad670:	18800426 	beq	r3,r2,90ad684 <t_bind+0x80>
 90ad674:	90aa4780 	call	90aa478 <dtrap>
 90ad678:	00bfffc4 	movi	r2,-1
 90ad67c:	e0bfff15 	stw	r2,-4(fp)
 90ad680:	00003906 	br	90ad768 <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 90ad684:	e13ff517 	ldw	r4,-44(fp)
 90ad688:	e17ffe17 	ldw	r5,-8(fp)
 90ad68c:	90ad5280 	call	90ad528 <DOMAIN_CHECK>

   so->so_error = 0;
 90ad690:	e0bff517 	ldw	r2,-44(fp)
 90ad694:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 90ad698:	e0bffd17 	ldw	r2,-12(fp)
 90ad69c:	1004c03a 	cmpne	r2,r2,zero
 90ad6a0:	10000d1e 	bne	r2,zero,90ad6d8 <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 90ad6a4:	e0bff804 	addi	r2,fp,-32
 90ad6a8:	10000015 	stw	zero,0(r2)
 90ad6ac:	10000115 	stw	zero,4(r2)
 90ad6b0:	10000215 	stw	zero,8(r2)
 90ad6b4:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 90ad6b8:	00800404 	movi	r2,16
 90ad6bc:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 90ad6c0:	e0bff517 	ldw	r2,-44(fp)
 90ad6c4:	10800517 	ldw	r2,20(r2)
 90ad6c8:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 90ad6cc:	e0bff804 	addi	r2,fp,-32
 90ad6d0:	e0bff615 	stw	r2,-40(fp)
 90ad6d4:	00000206 	br	90ad6e0 <t_bind+0xdc>
   } else
      sap = addr;
 90ad6d8:	e0bffd17 	ldw	r2,-12(fp)
 90ad6dc:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 90ad6e0:	e13ff617 	ldw	r4,-40(fp)
 90ad6e4:	e17ffe17 	ldw	r5,-8(fp)
 90ad6e8:	01800244 	movi	r6,9
 90ad6ec:	90aebf00 	call	90aebf0 <sockargs>
 90ad6f0:	e0bff715 	stw	r2,-36(fp)
 90ad6f4:	e0bff717 	ldw	r2,-36(fp)
 90ad6f8:	1004c03a 	cmpne	r2,r2,zero
 90ad6fc:	1000061e 	bne	r2,zero,90ad718 <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 90ad700:	e0fff517 	ldw	r3,-44(fp)
 90ad704:	00800304 	movi	r2,12
 90ad708:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad70c:	00bfffc4 	movi	r2,-1
 90ad710:	e0bfff15 	stw	r2,-4(fp)
 90ad714:	00001406 	br	90ad768 <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90ad718:	0009883a 	mov	r4,zero
 90ad71c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 90ad720:	e13ff517 	ldw	r4,-44(fp)
 90ad724:	e17ff717 	ldw	r5,-36(fp)
 90ad728:	90aeef00 	call	90aeef0 <sobind>
 90ad72c:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 90ad730:	e13ff717 	ldw	r4,-36(fp)
 90ad734:	90ab5940 	call	90ab594 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad738:	0009883a 	mov	r4,zero
 90ad73c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (err) 
 90ad740:	e0bff417 	ldw	r2,-48(fp)
 90ad744:	1005003a 	cmpeq	r2,r2,zero
 90ad748:	1000061e 	bne	r2,zero,90ad764 <t_bind+0x160>
   {
      so->so_error = err;
 90ad74c:	e0fff517 	ldw	r3,-44(fp)
 90ad750:	e0bff417 	ldw	r2,-48(fp)
 90ad754:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad758:	00bfffc4 	movi	r2,-1
 90ad75c:	e0bfff15 	stw	r2,-4(fp)
 90ad760:	00000106 	br	90ad768 <t_bind+0x164>
   }
   return 0;
 90ad764:	e03fff15 	stw	zero,-4(fp)
 90ad768:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad76c:	e037883a 	mov	sp,fp
 90ad770:	dfc00117 	ldw	ra,4(sp)
 90ad774:	df000017 	ldw	fp,0(sp)
 90ad778:	dec00204 	addi	sp,sp,8
 90ad77c:	f800283a 	ret

090ad780 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 90ad780:	defff804 	addi	sp,sp,-32
 90ad784:	dfc00715 	stw	ra,28(sp)
 90ad788:	df000615 	stw	fp,24(sp)
 90ad78c:	df000604 	addi	fp,sp,24
 90ad790:	e13ffd15 	stw	r4,-12(fp)
 90ad794:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 90ad798:	e0bffd17 	ldw	r2,-12(fp)
 90ad79c:	10bff804 	addi	r2,r2,-32
 90ad7a0:	1085883a 	add	r2,r2,r2
 90ad7a4:	1085883a 	add	r2,r2,r2
 90ad7a8:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 90ad7ac:	008243b4 	movhi	r2,2318
 90ad7b0:	10b72304 	addi	r2,r2,-9076
 90ad7b4:	e0bffa15 	stw	r2,-24(fp)
 90ad7b8:	00000606 	br	90ad7d4 <t_listen+0x54>
 90ad7bc:	e0fffa17 	ldw	r3,-24(fp)
 90ad7c0:	e0bffc17 	ldw	r2,-16(fp)
 90ad7c4:	18800626 	beq	r3,r2,90ad7e0 <t_listen+0x60>
 90ad7c8:	e0bffa17 	ldw	r2,-24(fp)
 90ad7cc:	10800017 	ldw	r2,0(r2)
 90ad7d0:	e0bffa15 	stw	r2,-24(fp)
 90ad7d4:	e0bffa17 	ldw	r2,-24(fp)
 90ad7d8:	1004c03a 	cmpne	r2,r2,zero
 90ad7dc:	103ff71e 	bne	r2,zero,90ad7bc <t_listen+0x3c>
 90ad7e0:	e0fffa17 	ldw	r3,-24(fp)
 90ad7e4:	e0bffc17 	ldw	r2,-16(fp)
 90ad7e8:	18800426 	beq	r3,r2,90ad7fc <t_listen+0x7c>
 90ad7ec:	90aa4780 	call	90aa478 <dtrap>
 90ad7f0:	00bfffc4 	movi	r2,-1
 90ad7f4:	e0bfff15 	stw	r2,-4(fp)
 90ad7f8:	00001406 	br	90ad84c <t_listen+0xcc>
   so->so_error = 0;
 90ad7fc:	e0bffc17 	ldw	r2,-16(fp)
 90ad800:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 90ad804:	0009883a 	mov	r4,zero
 90ad808:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 90ad80c:	e13ffc17 	ldw	r4,-16(fp)
 90ad810:	e17ffe17 	ldw	r5,-8(fp)
 90ad814:	90aef4c0 	call	90aef4c <solisten>
 90ad818:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ad81c:	0009883a 	mov	r4,zero
 90ad820:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 90ad824:	e0bffb17 	ldw	r2,-20(fp)
 90ad828:	1005003a 	cmpeq	r2,r2,zero
 90ad82c:	1000061e 	bne	r2,zero,90ad848 <t_listen+0xc8>
   {
      so->so_error = err;
 90ad830:	e0fffc17 	ldw	r3,-16(fp)
 90ad834:	e0bffb17 	ldw	r2,-20(fp)
 90ad838:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ad83c:	00bfffc4 	movi	r2,-1
 90ad840:	e0bfff15 	stw	r2,-4(fp)
 90ad844:	00000106 	br	90ad84c <t_listen+0xcc>
   }
   return 0;
 90ad848:	e03fff15 	stw	zero,-4(fp)
 90ad84c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ad850:	e037883a 	mov	sp,fp
 90ad854:	dfc00117 	ldw	ra,4(sp)
 90ad858:	df000017 	ldw	fp,0(sp)
 90ad85c:	dec00204 	addi	sp,sp,8
 90ad860:	f800283a 	ret

090ad864 <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 90ad864:	defff604 	addi	sp,sp,-40
 90ad868:	dfc00915 	stw	ra,36(sp)
 90ad86c:	df000815 	stw	fp,32(sp)
 90ad870:	df000804 	addi	fp,sp,32
 90ad874:	e13ffc15 	stw	r4,-16(fp)
 90ad878:	e17ffd15 	stw	r5,-12(fp)
 90ad87c:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 90ad880:	e0bffc17 	ldw	r2,-16(fp)
 90ad884:	10bff804 	addi	r2,r2,-32
 90ad888:	1085883a 	add	r2,r2,r2
 90ad88c:	1085883a 	add	r2,r2,r2
 90ad890:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 90ad894:	008243b4 	movhi	r2,2318
 90ad898:	10b72304 	addi	r2,r2,-9076
 90ad89c:	e0bff915 	stw	r2,-28(fp)
 90ad8a0:	00000606 	br	90ad8bc <t_accept+0x58>
 90ad8a4:	e0fff917 	ldw	r3,-28(fp)
 90ad8a8:	e0bffb17 	ldw	r2,-20(fp)
 90ad8ac:	18800626 	beq	r3,r2,90ad8c8 <t_accept+0x64>
 90ad8b0:	e0bff917 	ldw	r2,-28(fp)
 90ad8b4:	10800017 	ldw	r2,0(r2)
 90ad8b8:	e0bff915 	stw	r2,-28(fp)
 90ad8bc:	e0bff917 	ldw	r2,-28(fp)
 90ad8c0:	1004c03a 	cmpne	r2,r2,zero
 90ad8c4:	103ff71e 	bne	r2,zero,90ad8a4 <t_accept+0x40>
 90ad8c8:	e0fff917 	ldw	r3,-28(fp)
 90ad8cc:	e0bffb17 	ldw	r2,-20(fp)
 90ad8d0:	18800426 	beq	r3,r2,90ad8e4 <t_accept+0x80>
 90ad8d4:	90aa4780 	call	90aa478 <dtrap>
 90ad8d8:	00bfffc4 	movi	r2,-1
 90ad8dc:	e0bfff15 	stw	r2,-4(fp)
 90ad8e0:	00008006 	br	90adae4 <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 90ad8e4:	e0bffe17 	ldw	r2,-8(fp)
 90ad8e8:	11400017 	ldw	r5,0(r2)
 90ad8ec:	e13ffb17 	ldw	r4,-20(fp)
 90ad8f0:	90ad5280 	call	90ad528 <DOMAIN_CHECK>

   so->so_error = 0;
 90ad8f4:	e0bffb17 	ldw	r2,-20(fp)
 90ad8f8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 90ad8fc:	e0bffb17 	ldw	r2,-20(fp)
 90ad900:	10800417 	ldw	r2,16(r2)
 90ad904:	1080008c 	andi	r2,r2,2
 90ad908:	1004c03a 	cmpne	r2,r2,zero
 90ad90c:	1000061e 	bne	r2,zero,90ad928 <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 90ad910:	e0fffb17 	ldw	r3,-20(fp)
 90ad914:	00800584 	movi	r2,22
 90ad918:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ad91c:	00bfffc4 	movi	r2,-1
 90ad920:	e0bfff15 	stw	r2,-4(fp)
 90ad924:	00006f06 	br	90adae4 <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 90ad928:	e0bffb17 	ldw	r2,-20(fp)
 90ad92c:	1080088b 	ldhu	r2,34(r2)
 90ad930:	10bfffcc 	andi	r2,r2,65535
 90ad934:	1080400c 	andi	r2,r2,256
 90ad938:	1005003a 	cmpeq	r2,r2,zero
 90ad93c:	10000d1e 	bne	r2,zero,90ad974 <t_accept+0x110>
 90ad940:	e0bffb17 	ldw	r2,-20(fp)
 90ad944:	10801e43 	ldbu	r2,121(r2)
 90ad948:	10803fcc 	andi	r2,r2,255
 90ad94c:	1080201c 	xori	r2,r2,128
 90ad950:	10bfe004 	addi	r2,r2,-128
 90ad954:	1004c03a 	cmpne	r2,r2,zero
 90ad958:	1000061e 	bne	r2,zero,90ad974 <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 90ad95c:	e0fffb17 	ldw	r3,-20(fp)
 90ad960:	008002c4 	movi	r2,11
 90ad964:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ad968:	00bfffc4 	movi	r2,-1
 90ad96c:	e0bfff15 	stw	r2,-4(fp)
 90ad970:	00005c06 	br	90adae4 <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90ad974:	0009883a 	mov	r4,zero
 90ad978:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 90ad97c:	00001206 	br	90ad9c8 <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 90ad980:	e0bffb17 	ldw	r2,-20(fp)
 90ad984:	1080088b 	ldhu	r2,34(r2)
 90ad988:	10bfffcc 	andi	r2,r2,65535
 90ad98c:	1080080c 	andi	r2,r2,32
 90ad990:	1005003a 	cmpeq	r2,r2,zero
 90ad994:	1000081e 	bne	r2,zero,90ad9b8 <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 90ad998:	e0fffb17 	ldw	r3,-20(fp)
 90ad99c:	00801c44 	movi	r2,113
 90ad9a0:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 90ad9a4:	0009883a 	mov	r4,zero
 90ad9a8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ad9ac:	00bfffc4 	movi	r2,-1
 90ad9b0:	e0bfff15 	stw	r2,-4(fp)
 90ad9b4:	00004b06 	br	90adae4 <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 90ad9b8:	e0bffb17 	ldw	r2,-20(fp)
 90ad9bc:	10800904 	addi	r2,r2,36
 90ad9c0:	1009883a 	mov	r4,r2
 90ad9c4:	90a5cf40 	call	90a5cf4 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 90ad9c8:	e0bffb17 	ldw	r2,-20(fp)
 90ad9cc:	10801e43 	ldbu	r2,121(r2)
 90ad9d0:	10803fcc 	andi	r2,r2,255
 90ad9d4:	1080201c 	xori	r2,r2,128
 90ad9d8:	10bfe004 	addi	r2,r2,-128
 90ad9dc:	1004c03a 	cmpne	r2,r2,zero
 90ad9e0:	1000041e 	bne	r2,zero,90ad9f4 <t_accept+0x190>
 90ad9e4:	e0bffb17 	ldw	r2,-20(fp)
 90ad9e8:	10800617 	ldw	r2,24(r2)
 90ad9ec:	1005003a 	cmpeq	r2,r2,zero
 90ad9f0:	103fe31e 	bne	r2,zero,90ad980 <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 90ad9f4:	e0bffb17 	ldw	r2,-20(fp)
 90ad9f8:	10800617 	ldw	r2,24(r2)
 90ad9fc:	1005003a 	cmpeq	r2,r2,zero
 90ada00:	1000051e 	bne	r2,zero,90ada18 <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ada04:	0009883a 	mov	r4,zero
 90ada08:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90ada0c:	00bfffc4 	movi	r2,-1
 90ada10:	e0bfff15 	stw	r2,-4(fp)
 90ada14:	00003306 	br	90adae4 <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90ada18:	01000244 	movi	r4,9
 90ada1c:	01400404 	movi	r5,16
 90ada20:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90ada24:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 90ada28:	e0bffa17 	ldw	r2,-24(fp)
 90ada2c:	1004c03a 	cmpne	r2,r2,zero
 90ada30:	1000081e 	bne	r2,zero,90ada54 <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ada34:	0009883a 	mov	r4,zero
 90ada38:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 90ada3c:	e0fffb17 	ldw	r3,-20(fp)
 90ada40:	00800304 	movi	r2,12
 90ada44:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ada48:	00bfffc4 	movi	r2,-1
 90ada4c:	e0bfff15 	stw	r2,-4(fp)
 90ada50:	00002406 	br	90adae4 <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 90ada54:	e0bffb17 	ldw	r2,-20(fp)
 90ada58:	10801d17 	ldw	r2,116(r2)
 90ada5c:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 90ada60:	e13ff817 	ldw	r4,-32(fp)
 90ada64:	01400044 	movi	r5,1
 90ada68:	90b16840 	call	90b1684 <soqremque>
 90ada6c:	1004c03a 	cmpne	r2,r2,zero
 90ada70:	1000031e 	bne	r2,zero,90ada80 <t_accept+0x21c>
         panic("accept");
 90ada74:	01024374 	movhi	r4,2317
 90ada78:	21023e04 	addi	r4,r4,2296
 90ada7c:	90a537c0 	call	90a537c <panic>
      so = aso;
 90ada80:	e0bff817 	ldw	r2,-32(fp)
 90ada84:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 90ada88:	e13ffb17 	ldw	r4,-20(fp)
 90ada8c:	e17ffa17 	ldw	r5,-24(fp)
 90ada90:	90af5240 	call	90af524 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 90ada94:	e0bffd17 	ldw	r2,-12(fp)
 90ada98:	1005003a 	cmpeq	r2,r2,zero
 90ada9c:	1000091e 	bne	r2,zero,90adac4 <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 90adaa0:	e0bffa17 	ldw	r2,-24(fp)
 90adaa4:	11400317 	ldw	r5,12(r2)
 90adaa8:	e0bffe17 	ldw	r2,-8(fp)
 90adaac:	10800017 	ldw	r2,0(r2)
 90adab0:	1007883a 	mov	r3,r2
 90adab4:	e0bffd17 	ldw	r2,-12(fp)
 90adab8:	1009883a 	mov	r4,r2
 90adabc:	180d883a 	mov	r6,r3
 90adac0:	90894600 	call	9089460 <memcpy>
   m_freem (nam);
 90adac4:	e13ffa17 	ldw	r4,-24(fp)
 90adac8:	90ab5940 	call	90ab594 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90adacc:	0009883a 	mov	r4,zero
 90adad0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 90adad4:	e0bffb17 	ldw	r2,-20(fp)
 90adad8:	1004d0ba 	srli	r2,r2,2
 90adadc:	10800804 	addi	r2,r2,32
 90adae0:	e0bfff15 	stw	r2,-4(fp)
 90adae4:	e0bfff17 	ldw	r2,-4(fp)
}
 90adae8:	e037883a 	mov	sp,fp
 90adaec:	dfc00117 	ldw	ra,4(sp)
 90adaf0:	df000017 	ldw	fp,0(sp)
 90adaf4:	dec00204 	addi	sp,sp,8
 90adaf8:	f800283a 	ret

090adafc <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 90adafc:	defff704 	addi	sp,sp,-36
 90adb00:	dfc00815 	stw	ra,32(sp)
 90adb04:	df000715 	stw	fp,28(sp)
 90adb08:	df000704 	addi	fp,sp,28
 90adb0c:	e13ffc15 	stw	r4,-16(fp)
 90adb10:	e17ffd15 	stw	r5,-12(fp)
 90adb14:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 90adb18:	e0bffc17 	ldw	r2,-16(fp)
 90adb1c:	10bff804 	addi	r2,r2,-32
 90adb20:	1085883a 	add	r2,r2,r2
 90adb24:	1085883a 	add	r2,r2,r2
 90adb28:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 90adb2c:	008243b4 	movhi	r2,2318
 90adb30:	10b72304 	addi	r2,r2,-9076
 90adb34:	e0bff915 	stw	r2,-28(fp)
 90adb38:	00000606 	br	90adb54 <t_connect+0x58>
 90adb3c:	e0fff917 	ldw	r3,-28(fp)
 90adb40:	e0bffb17 	ldw	r2,-20(fp)
 90adb44:	18800626 	beq	r3,r2,90adb60 <t_connect+0x64>
 90adb48:	e0bff917 	ldw	r2,-28(fp)
 90adb4c:	10800017 	ldw	r2,0(r2)
 90adb50:	e0bff915 	stw	r2,-28(fp)
 90adb54:	e0bff917 	ldw	r2,-28(fp)
 90adb58:	1004c03a 	cmpne	r2,r2,zero
 90adb5c:	103ff71e 	bne	r2,zero,90adb3c <t_connect+0x40>
 90adb60:	e0fff917 	ldw	r3,-28(fp)
 90adb64:	e0bffb17 	ldw	r2,-20(fp)
 90adb68:	18800426 	beq	r3,r2,90adb7c <t_connect+0x80>
 90adb6c:	90aa4780 	call	90aa478 <dtrap>
 90adb70:	00bfffc4 	movi	r2,-1
 90adb74:	e0bfff15 	stw	r2,-4(fp)
 90adb78:	00008406 	br	90add8c <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 90adb7c:	e13ffb17 	ldw	r4,-20(fp)
 90adb80:	e17ffe17 	ldw	r5,-8(fp)
 90adb84:	90ad5280 	call	90ad528 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 90adb88:	e0bffb17 	ldw	r2,-20(fp)
 90adb8c:	1080088b 	ldhu	r2,34(r2)
 90adb90:	10bfffcc 	andi	r2,r2,65535
 90adb94:	1080400c 	andi	r2,r2,256
 90adb98:	1005003a 	cmpeq	r2,r2,zero
 90adb9c:	10002a1e 	bne	r2,zero,90adc48 <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 90adba0:	e0bffb17 	ldw	r2,-20(fp)
 90adba4:	1080088b 	ldhu	r2,34(r2)
 90adba8:	10bfffcc 	andi	r2,r2,65535
 90adbac:	1080010c 	andi	r2,r2,4
 90adbb0:	1005003a 	cmpeq	r2,r2,zero
 90adbb4:	1000061e 	bne	r2,zero,90adbd0 <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 90adbb8:	e0fffb17 	ldw	r3,-20(fp)
 90adbbc:	00801dc4 	movi	r2,119
 90adbc0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90adbc4:	00bfffc4 	movi	r2,-1
 90adbc8:	e0bfff15 	stw	r2,-4(fp)
 90adbcc:	00006f06 	br	90add8c <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 90adbd0:	e0bffb17 	ldw	r2,-20(fp)
 90adbd4:	1080088b 	ldhu	r2,34(r2)
 90adbd8:	10bfffcc 	andi	r2,r2,65535
 90adbdc:	1080008c 	andi	r2,r2,2
 90adbe0:	1005003a 	cmpeq	r2,r2,zero
 90adbe4:	1000041e 	bne	r2,zero,90adbf8 <t_connect+0xfc>
      {
         so->so_error = 0;
 90adbe8:	e0bffb17 	ldw	r2,-20(fp)
 90adbec:	10000615 	stw	zero,24(r2)
         return 0;
 90adbf0:	e03fff15 	stw	zero,-4(fp)
 90adbf4:	00006506 	br	90add8c <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 90adbf8:	e0bffb17 	ldw	r2,-20(fp)
 90adbfc:	1080088b 	ldhu	r2,34(r2)
 90adc00:	10bfffcc 	andi	r2,r2,65535
 90adc04:	1088000c 	andi	r2,r2,8192
 90adc08:	1005003a 	cmpeq	r2,r2,zero
 90adc0c:	10000e1e 	bne	r2,zero,90adc48 <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 90adc10:	e0bffb17 	ldw	r2,-20(fp)
 90adc14:	10c0088b 	ldhu	r3,34(r2)
 90adc18:	00b7ffc4 	movi	r2,-8193
 90adc1c:	1884703a 	and	r2,r3,r2
 90adc20:	1007883a 	mov	r3,r2
 90adc24:	e0bffb17 	ldw	r2,-20(fp)
 90adc28:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 90adc2c:	e0bffb17 	ldw	r2,-20(fp)
 90adc30:	10800617 	ldw	r2,24(r2)
 90adc34:	1005003a 	cmpeq	r2,r2,zero
 90adc38:	1000031e 	bne	r2,zero,90adc48 <t_connect+0x14c>
            return SOCKET_ERROR;
 90adc3c:	00bfffc4 	movi	r2,-1
 90adc40:	e0bfff15 	stw	r2,-4(fp)
 90adc44:	00005106 	br	90add8c <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 90adc48:	e0bffb17 	ldw	r2,-20(fp)
 90adc4c:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 90adc50:	e13ffd17 	ldw	r4,-12(fp)
 90adc54:	e17ffe17 	ldw	r5,-8(fp)
 90adc58:	01800244 	movi	r6,9
 90adc5c:	90aebf00 	call	90aebf0 <sockargs>
 90adc60:	e0bffa15 	stw	r2,-24(fp)
 90adc64:	e0bffa17 	ldw	r2,-24(fp)
 90adc68:	1004c03a 	cmpne	r2,r2,zero
 90adc6c:	1000061e 	bne	r2,zero,90adc88 <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 90adc70:	e0fffb17 	ldw	r3,-20(fp)
 90adc74:	00800304 	movi	r2,12
 90adc78:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90adc7c:	00bfffc4 	movi	r2,-1
 90adc80:	e0bfff15 	stw	r2,-4(fp)
 90adc84:	00004106 	br	90add8c <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 90adc88:	0009883a 	mov	r4,zero
 90adc8c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 90adc90:	e13ffb17 	ldw	r4,-20(fp)
 90adc94:	e17ffa17 	ldw	r5,-24(fp)
 90adc98:	90af5c00 	call	90af5c0 <soconnect>
 90adc9c:	1007883a 	mov	r3,r2
 90adca0:	e0bffb17 	ldw	r2,-20(fp)
 90adca4:	10c00615 	stw	r3,24(r2)
 90adca8:	e0bffb17 	ldw	r2,-20(fp)
 90adcac:	10800617 	ldw	r2,24(r2)
 90adcb0:	1004c03a 	cmpne	r2,r2,zero
 90adcb4:	10001e1e 	bne	r2,zero,90add30 <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 90adcb8:	e0bffb17 	ldw	r2,-20(fp)
 90adcbc:	1080088b 	ldhu	r2,34(r2)
 90adcc0:	10bfffcc 	andi	r2,r2,65535
 90adcc4:	1080400c 	andi	r2,r2,256
 90adcc8:	1005003a 	cmpeq	r2,r2,zero
 90adccc:	10000e1e 	bne	r2,zero,90add08 <t_connect+0x20c>
 90adcd0:	e0bffb17 	ldw	r2,-20(fp)
 90adcd4:	1080088b 	ldhu	r2,34(r2)
 90adcd8:	10bfffcc 	andi	r2,r2,65535
 90adcdc:	1080010c 	andi	r2,r2,4
 90adce0:	1005003a 	cmpeq	r2,r2,zero
 90adce4:	1000081e 	bne	r2,zero,90add08 <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 90adce8:	e0fffb17 	ldw	r3,-20(fp)
 90adcec:	00801dc4 	movi	r2,119
 90adcf0:	18800615 	stw	r2,24(r3)
      goto bad;
 90adcf4:	00000e06 	br	90add30 <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 90adcf8:	e0bffb17 	ldw	r2,-20(fp)
 90adcfc:	10800904 	addi	r2,r2,36
 90add00:	1009883a 	mov	r4,r2
 90add04:	90a5cf40 	call	90a5cf4 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 90add08:	e0bffb17 	ldw	r2,-20(fp)
 90add0c:	1080088b 	ldhu	r2,34(r2)
 90add10:	10bfffcc 	andi	r2,r2,65535
 90add14:	1080010c 	andi	r2,r2,4
 90add18:	1005003a 	cmpeq	r2,r2,zero
 90add1c:	1000041e 	bne	r2,zero,90add30 <t_connect+0x234>
 90add20:	e0bffb17 	ldw	r2,-20(fp)
 90add24:	10800617 	ldw	r2,24(r2)
 90add28:	1005003a 	cmpeq	r2,r2,zero
 90add2c:	103ff21e 	bne	r2,zero,90adcf8 <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 90add30:	e0bffb17 	ldw	r2,-20(fp)
 90add34:	10800617 	ldw	r2,24(r2)
 90add38:	10801de0 	cmpeqi	r2,r2,119
 90add3c:	1000071e 	bne	r2,zero,90add5c <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 90add40:	e0bffb17 	ldw	r2,-20(fp)
 90add44:	10c0088b 	ldhu	r3,34(r2)
 90add48:	00b7fec4 	movi	r2,-8197
 90add4c:	1884703a 	and	r2,r3,r2
 90add50:	1007883a 	mov	r3,r2
 90add54:	e0bffb17 	ldw	r2,-20(fp)
 90add58:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 90add5c:	e13ffa17 	ldw	r4,-24(fp)
 90add60:	90ab5940 	call	90ab594 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90add64:	0009883a 	mov	r4,zero
 90add68:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 90add6c:	e0bffb17 	ldw	r2,-20(fp)
 90add70:	10800617 	ldw	r2,24(r2)
 90add74:	1005003a 	cmpeq	r2,r2,zero
 90add78:	1000031e 	bne	r2,zero,90add88 <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 90add7c:	00bfffc4 	movi	r2,-1
 90add80:	e0bfff15 	stw	r2,-4(fp)
 90add84:	00000106 	br	90add8c <t_connect+0x290>

   }
      return 0;
 90add88:	e03fff15 	stw	zero,-4(fp)
 90add8c:	e0bfff17 	ldw	r2,-4(fp)
}
 90add90:	e037883a 	mov	sp,fp
 90add94:	dfc00117 	ldw	ra,4(sp)
 90add98:	df000017 	ldw	fp,0(sp)
 90add9c:	dec00204 	addi	sp,sp,8
 90adda0:	f800283a 	ret

090adda4 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 90adda4:	defffb04 	addi	sp,sp,-20
 90adda8:	dfc00415 	stw	ra,16(sp)
 90addac:	df000315 	stw	fp,12(sp)
 90addb0:	df000304 	addi	fp,sp,12
 90addb4:	e13ffd15 	stw	r4,-12(fp)
 90addb8:	e17ffe15 	stw	r5,-8(fp)
 90addbc:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 90addc0:	e13ffd17 	ldw	r4,-12(fp)
 90addc4:	e17ffe17 	ldw	r5,-8(fp)
 90addc8:	e1bfff17 	ldw	r6,-4(fp)
 90addcc:	01c00404 	movi	r7,16
 90addd0:	90ade2c0 	call	90ade2c <t_getname>
}
 90addd4:	e037883a 	mov	sp,fp
 90addd8:	dfc00117 	ldw	ra,4(sp)
 90adddc:	df000017 	ldw	fp,0(sp)
 90adde0:	dec00204 	addi	sp,sp,8
 90adde4:	f800283a 	ret

090adde8 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 90adde8:	defffb04 	addi	sp,sp,-20
 90addec:	dfc00415 	stw	ra,16(sp)
 90addf0:	df000315 	stw	fp,12(sp)
 90addf4:	df000304 	addi	fp,sp,12
 90addf8:	e13ffd15 	stw	r4,-12(fp)
 90addfc:	e17ffe15 	stw	r5,-8(fp)
 90ade00:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 90ade04:	e13ffd17 	ldw	r4,-12(fp)
 90ade08:	e17ffe17 	ldw	r5,-8(fp)
 90ade0c:	e1bfff17 	ldw	r6,-4(fp)
 90ade10:	01c003c4 	movi	r7,15
 90ade14:	90ade2c0 	call	90ade2c <t_getname>
}
 90ade18:	e037883a 	mov	sp,fp
 90ade1c:	dfc00117 	ldw	ra,4(sp)
 90ade20:	df000017 	ldw	fp,0(sp)
 90ade24:	dec00204 	addi	sp,sp,8
 90ade28:	f800283a 	ret

090ade2c <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 90ade2c:	defff504 	addi	sp,sp,-44
 90ade30:	dfc00a15 	stw	ra,40(sp)
 90ade34:	df000915 	stw	fp,36(sp)
 90ade38:	df000904 	addi	fp,sp,36
 90ade3c:	e13ffb15 	stw	r4,-20(fp)
 90ade40:	e17ffc15 	stw	r5,-16(fp)
 90ade44:	e1bffd15 	stw	r6,-12(fp)
 90ade48:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 90ade4c:	e0bffb17 	ldw	r2,-20(fp)
 90ade50:	10bff804 	addi	r2,r2,-32
 90ade54:	1085883a 	add	r2,r2,r2
 90ade58:	1085883a 	add	r2,r2,r2
 90ade5c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ade60:	008243b4 	movhi	r2,2318
 90ade64:	10b72304 	addi	r2,r2,-9076
 90ade68:	e0bff715 	stw	r2,-36(fp)
 90ade6c:	00000606 	br	90ade88 <t_getname+0x5c>
 90ade70:	e0fff717 	ldw	r3,-36(fp)
 90ade74:	e0bffa17 	ldw	r2,-24(fp)
 90ade78:	18800626 	beq	r3,r2,90ade94 <t_getname+0x68>
 90ade7c:	e0bff717 	ldw	r2,-36(fp)
 90ade80:	10800017 	ldw	r2,0(r2)
 90ade84:	e0bff715 	stw	r2,-36(fp)
 90ade88:	e0bff717 	ldw	r2,-36(fp)
 90ade8c:	1004c03a 	cmpne	r2,r2,zero
 90ade90:	103ff71e 	bne	r2,zero,90ade70 <t_getname+0x44>
 90ade94:	e0fff717 	ldw	r3,-36(fp)
 90ade98:	e0bffa17 	ldw	r2,-24(fp)
 90ade9c:	18800426 	beq	r3,r2,90adeb0 <t_getname+0x84>
 90adea0:	90aa4780 	call	90aa478 <dtrap>
 90adea4:	00bfffc4 	movi	r2,-1
 90adea8:	e0bfff15 	stw	r2,-4(fp)
 90adeac:	00005806 	br	90ae010 <t_getname+0x1e4>

   so->so_error = 0;
 90adeb0:	e0bffa17 	ldw	r2,-24(fp)
 90adeb4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 90adeb8:	e0bffe17 	ldw	r2,-8(fp)
 90adebc:	10800418 	cmpnei	r2,r2,16
 90adec0:	10000c1e 	bne	r2,zero,90adef4 <t_getname+0xc8>
 90adec4:	e0bffa17 	ldw	r2,-24(fp)
 90adec8:	1080088b 	ldhu	r2,34(r2)
 90adecc:	10bfffcc 	andi	r2,r2,65535
 90aded0:	1080008c 	andi	r2,r2,2
 90aded4:	1004c03a 	cmpne	r2,r2,zero
 90aded8:	1000061e 	bne	r2,zero,90adef4 <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 90adedc:	e0fffa17 	ldw	r3,-24(fp)
 90adee0:	00802004 	movi	r2,128
 90adee4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90adee8:	00bfffc4 	movi	r2,-1
 90adeec:	e0bfff15 	stw	r2,-4(fp)
 90adef0:	00004706 	br	90ae010 <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 90adef4:	0009883a 	mov	r4,zero
 90adef8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90adefc:	01000244 	movi	r4,9
 90adf00:	01400404 	movi	r5,16
 90adf04:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90adf08:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 90adf0c:	e0bff917 	ldw	r2,-28(fp)
 90adf10:	1004c03a 	cmpne	r2,r2,zero
 90adf14:	1000081e 	bne	r2,zero,90adf38 <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 90adf18:	e0fffa17 	ldw	r3,-24(fp)
 90adf1c:	00800304 	movi	r2,12
 90adf20:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90adf24:	0009883a 	mov	r4,zero
 90adf28:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 90adf2c:	00bfffc4 	movi	r2,-1
 90adf30:	e0bfff15 	stw	r2,-4(fp)
 90adf34:	00003606 	br	90ae010 <t_getname+0x1e4>
   }
   so->so_req = opcode;
 90adf38:	e0fffa17 	ldw	r3,-24(fp)
 90adf3c:	e0bffe17 	ldw	r2,-8(fp)
 90adf40:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 90adf44:	e0bffa17 	ldw	r2,-24(fp)
 90adf48:	10800217 	ldw	r2,8(r2)
 90adf4c:	10800317 	ldw	r2,12(r2)
 90adf50:	e13ffa17 	ldw	r4,-24(fp)
 90adf54:	000b883a 	mov	r5,zero
 90adf58:	e1bff917 	ldw	r6,-28(fp)
 90adf5c:	103ee83a 	callr	r2
 90adf60:	e0bff815 	stw	r2,-32(fp)
 90adf64:	e0bff817 	ldw	r2,-32(fp)
 90adf68:	1004c03a 	cmpne	r2,r2,zero
 90adf6c:	10001a1e 	bne	r2,zero,90adfd8 <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 90adf70:	e0bffa17 	ldw	r2,-24(fp)
 90adf74:	10800517 	ldw	r2,20(r2)
 90adf78:	10800098 	cmpnei	r2,r2,2
 90adf7c:	1000161e 	bne	r2,zero,90adfd8 <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 90adf80:	e0bffd17 	ldw	r2,-12(fp)
 90adf84:	10800017 	ldw	r2,0(r2)
 90adf88:	10800428 	cmpgeui	r2,r2,16
 90adf8c:	1000081e 	bne	r2,zero,90adfb0 <t_getname+0x184>
      {
         dtrap();    /* programming error */
 90adf90:	90aa4780 	call	90aa478 <dtrap>
         m_freem(m);
 90adf94:	e13ff917 	ldw	r4,-28(fp)
 90adf98:	90ab5940 	call	90ab594 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90adf9c:	0009883a 	mov	r4,zero
 90adfa0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 90adfa4:	00800584 	movi	r2,22
 90adfa8:	e0bfff15 	stw	r2,-4(fp)
 90adfac:	00001806 	br	90ae010 <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 90adfb0:	e0bff917 	ldw	r2,-28(fp)
 90adfb4:	10c00317 	ldw	r3,12(r2)
 90adfb8:	e0bffc17 	ldw	r2,-16(fp)
 90adfbc:	1009883a 	mov	r4,r2
 90adfc0:	180b883a 	mov	r5,r3
 90adfc4:	01800404 	movi	r6,16
 90adfc8:	90894600 	call	9089460 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 90adfcc:	e0fffd17 	ldw	r3,-12(fp)
 90adfd0:	00800404 	movi	r2,16
 90adfd4:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 90adfd8:	e13ff917 	ldw	r4,-28(fp)
 90adfdc:	90ab5940 	call	90ab594 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 90adfe0:	0009883a 	mov	r4,zero
 90adfe4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (err) 
 90adfe8:	e0bff817 	ldw	r2,-32(fp)
 90adfec:	1005003a 	cmpeq	r2,r2,zero
 90adff0:	1000061e 	bne	r2,zero,90ae00c <t_getname+0x1e0>
   {
      so->so_error = err;
 90adff4:	e0fffa17 	ldw	r3,-24(fp)
 90adff8:	e0bff817 	ldw	r2,-32(fp)
 90adffc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae000:	00bfffc4 	movi	r2,-1
 90ae004:	e0bfff15 	stw	r2,-4(fp)
 90ae008:	00000106 	br	90ae010 <t_getname+0x1e4>
   }
   return 0;
 90ae00c:	e03fff15 	stw	zero,-4(fp)
 90ae010:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae014:	e037883a 	mov	sp,fp
 90ae018:	dfc00117 	ldw	ra,4(sp)
 90ae01c:	df000017 	ldw	fp,0(sp)
 90ae020:	dec00204 	addi	sp,sp,8
 90ae024:	f800283a 	ret

090ae028 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 90ae028:	defff604 	addi	sp,sp,-40
 90ae02c:	dfc00915 	stw	ra,36(sp)
 90ae030:	df000815 	stw	fp,32(sp)
 90ae034:	df000804 	addi	fp,sp,32
 90ae038:	e13ffb15 	stw	r4,-20(fp)
 90ae03c:	e17ffc15 	stw	r5,-16(fp)
 90ae040:	e1bffd15 	stw	r6,-12(fp)
 90ae044:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90ae048:	e0bffb17 	ldw	r2,-20(fp)
 90ae04c:	10bff804 	addi	r2,r2,-32
 90ae050:	1085883a 	add	r2,r2,r2
 90ae054:	1085883a 	add	r2,r2,r2
 90ae058:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ae05c:	008243b4 	movhi	r2,2318
 90ae060:	10b72304 	addi	r2,r2,-9076
 90ae064:	e0bff815 	stw	r2,-32(fp)
 90ae068:	00000606 	br	90ae084 <t_setsockopt+0x5c>
 90ae06c:	e0fff817 	ldw	r3,-32(fp)
 90ae070:	e0bffa17 	ldw	r2,-24(fp)
 90ae074:	18800626 	beq	r3,r2,90ae090 <t_setsockopt+0x68>
 90ae078:	e0bff817 	ldw	r2,-32(fp)
 90ae07c:	10800017 	ldw	r2,0(r2)
 90ae080:	e0bff815 	stw	r2,-32(fp)
 90ae084:	e0bff817 	ldw	r2,-32(fp)
 90ae088:	1004c03a 	cmpne	r2,r2,zero
 90ae08c:	103ff71e 	bne	r2,zero,90ae06c <t_setsockopt+0x44>
 90ae090:	e0fff817 	ldw	r3,-32(fp)
 90ae094:	e0bffa17 	ldw	r2,-24(fp)
 90ae098:	18800426 	beq	r3,r2,90ae0ac <t_setsockopt+0x84>
 90ae09c:	90aa4780 	call	90aa478 <dtrap>
 90ae0a0:	00bfffc4 	movi	r2,-1
 90ae0a4:	e0bfff15 	stw	r2,-4(fp)
 90ae0a8:	00005006 	br	90ae1ec <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 90ae0ac:	0009883a 	mov	r4,zero
 90ae0b0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 90ae0b4:	e0bffa17 	ldw	r2,-24(fp)
 90ae0b8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 90ae0bc:	e0bffc17 	ldw	r2,-16(fp)
 90ae0c0:	10800060 	cmpeqi	r2,r2,1
 90ae0c4:	1000101e 	bne	r2,zero,90ae108 <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 90ae0c8:	e13ffa17 	ldw	r4,-24(fp)
 90ae0cc:	e17ffd17 	ldw	r5,-12(fp)
 90ae0d0:	e1bffe17 	ldw	r6,-8(fp)
 90ae0d4:	90b06c80 	call	90b06c8 <sosetopt>
 90ae0d8:	e0bff915 	stw	r2,-28(fp)
 90ae0dc:	e0bff917 	ldw	r2,-28(fp)
 90ae0e0:	1005003a 	cmpeq	r2,r2,zero
 90ae0e4:	10003e1e 	bne	r2,zero,90ae1e0 <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 90ae0e8:	e0fffa17 	ldw	r3,-24(fp)
 90ae0ec:	e0bff917 	ldw	r2,-28(fp)
 90ae0f0:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ae0f4:	0009883a 	mov	r4,zero
 90ae0f8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ae0fc:	00bfffc4 	movi	r2,-1
 90ae100:	e0bfff15 	stw	r2,-4(fp)
 90ae104:	00003906 	br	90ae1ec <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 90ae108:	e0bffa17 	ldw	r2,-24(fp)
 90ae10c:	10801f17 	ldw	r2,124(r2)
 90ae110:	1004c03a 	cmpne	r2,r2,zero
 90ae114:	1000111e 	bne	r2,zero,90ae15c <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 90ae118:	01000104 	movi	r4,4
 90ae11c:	90aaefc0 	call	90aaefc <npalloc>
 90ae120:	1007883a 	mov	r3,r2
 90ae124:	e0bffa17 	ldw	r2,-24(fp)
 90ae128:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 90ae12c:	e0bffa17 	ldw	r2,-24(fp)
 90ae130:	10801f17 	ldw	r2,124(r2)
 90ae134:	1004c03a 	cmpne	r2,r2,zero
 90ae138:	1000081e 	bne	r2,zero,90ae15c <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 90ae13c:	e0fffa17 	ldw	r3,-24(fp)
 90ae140:	00800304 	movi	r2,12
 90ae144:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 90ae148:	0009883a 	mov	r4,zero
 90ae14c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 90ae150:	00bfffc4 	movi	r2,-1
 90ae154:	e0bfff15 	stw	r2,-4(fp)
 90ae158:	00002406 	br	90ae1ec <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 90ae15c:	e0bffd17 	ldw	r2,-12(fp)
 90ae160:	10800118 	cmpnei	r2,r2,4
 90ae164:	1000061e 	bne	r2,zero,90ae180 <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 90ae168:	e0bffa17 	ldw	r2,-24(fp)
 90ae16c:	10c01f17 	ldw	r3,124(r2)
 90ae170:	e0bffe17 	ldw	r2,-8(fp)
 90ae174:	10800017 	ldw	r2,0(r2)
 90ae178:	18800045 	stb	r2,1(r3)
 90ae17c:	00001806 	br	90ae1e0 <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 90ae180:	e0bffd17 	ldw	r2,-12(fp)
 90ae184:	108000d8 	cmpnei	r2,r2,3
 90ae188:	1000061e 	bne	r2,zero,90ae1a4 <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 90ae18c:	e0bffa17 	ldw	r2,-24(fp)
 90ae190:	10c01f17 	ldw	r3,124(r2)
 90ae194:	e0bffe17 	ldw	r2,-8(fp)
 90ae198:	10800017 	ldw	r2,0(r2)
 90ae19c:	18800005 	stb	r2,0(r3)
 90ae1a0:	00000f06 	br	90ae1e0 <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 90ae1a4:	e0bffd17 	ldw	r2,-12(fp)
 90ae1a8:	10800398 	cmpnei	r2,r2,14
 90ae1ac:	1000071e 	bne	r2,zero,90ae1cc <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 90ae1b0:	e0bffa17 	ldw	r2,-24(fp)
 90ae1b4:	10c01f17 	ldw	r3,124(r2)
 90ae1b8:	e0bffe17 	ldw	r2,-8(fp)
 90ae1bc:	10800017 	ldw	r2,0(r2)
 90ae1c0:	10803fcc 	andi	r2,r2,255
 90ae1c4:	18800115 	stw	r2,4(r3)
 90ae1c8:	00000506 	br	90ae1e0 <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ae1cc:	0009883a 	mov	r4,zero
 90ae1d0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ae1d4:	00bfffc4 	movi	r2,-1
 90ae1d8:	e0bfff15 	stw	r2,-4(fp)
 90ae1dc:	00000306 	br	90ae1ec <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 90ae1e0:	0009883a 	mov	r4,zero
 90ae1e4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return 0;
 90ae1e8:	e03fff15 	stw	zero,-4(fp)
 90ae1ec:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae1f0:	e037883a 	mov	sp,fp
 90ae1f4:	dfc00117 	ldw	ra,4(sp)
 90ae1f8:	df000017 	ldw	fp,0(sp)
 90ae1fc:	dec00204 	addi	sp,sp,8
 90ae200:	f800283a 	ret

090ae204 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 90ae204:	defff604 	addi	sp,sp,-40
 90ae208:	dfc00915 	stw	ra,36(sp)
 90ae20c:	df000815 	stw	fp,32(sp)
 90ae210:	df000804 	addi	fp,sp,32
 90ae214:	e13ffb15 	stw	r4,-20(fp)
 90ae218:	e17ffc15 	stw	r5,-16(fp)
 90ae21c:	e1bffd15 	stw	r6,-12(fp)
 90ae220:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90ae224:	e0bffb17 	ldw	r2,-20(fp)
 90ae228:	10bff804 	addi	r2,r2,-32
 90ae22c:	1085883a 	add	r2,r2,r2
 90ae230:	1085883a 	add	r2,r2,r2
 90ae234:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 90ae238:	008243b4 	movhi	r2,2318
 90ae23c:	10b72304 	addi	r2,r2,-9076
 90ae240:	e0bff815 	stw	r2,-32(fp)
 90ae244:	00000606 	br	90ae260 <t_getsockopt+0x5c>
 90ae248:	e0fff817 	ldw	r3,-32(fp)
 90ae24c:	e0bffa17 	ldw	r2,-24(fp)
 90ae250:	18800626 	beq	r3,r2,90ae26c <t_getsockopt+0x68>
 90ae254:	e0bff817 	ldw	r2,-32(fp)
 90ae258:	10800017 	ldw	r2,0(r2)
 90ae25c:	e0bff815 	stw	r2,-32(fp)
 90ae260:	e0bff817 	ldw	r2,-32(fp)
 90ae264:	1004c03a 	cmpne	r2,r2,zero
 90ae268:	103ff71e 	bne	r2,zero,90ae248 <t_getsockopt+0x44>
 90ae26c:	e0fff817 	ldw	r3,-32(fp)
 90ae270:	e0bffa17 	ldw	r2,-24(fp)
 90ae274:	18800426 	beq	r3,r2,90ae288 <t_getsockopt+0x84>
 90ae278:	90aa4780 	call	90aa478 <dtrap>
 90ae27c:	00bfffc4 	movi	r2,-1
 90ae280:	e0bfff15 	stw	r2,-4(fp)
 90ae284:	00004206 	br	90ae390 <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 90ae288:	0009883a 	mov	r4,zero
 90ae28c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 90ae290:	e0bffc17 	ldw	r2,-16(fp)
 90ae294:	10800060 	cmpeqi	r2,r2,1
 90ae298:	1000101e 	bne	r2,zero,90ae2dc <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 90ae29c:	e13ffa17 	ldw	r4,-24(fp)
 90ae2a0:	e17ffd17 	ldw	r5,-12(fp)
 90ae2a4:	e1bffe17 	ldw	r6,-8(fp)
 90ae2a8:	90b0b880 	call	90b0b88 <sogetopt>
 90ae2ac:	e0bff915 	stw	r2,-28(fp)
 90ae2b0:	e0bff917 	ldw	r2,-28(fp)
 90ae2b4:	1005003a 	cmpeq	r2,r2,zero
 90ae2b8:	1000301e 	bne	r2,zero,90ae37c <t_getsockopt+0x178>
      {
         so->so_error = err;
 90ae2bc:	e0fffa17 	ldw	r3,-24(fp)
 90ae2c0:	e0bff917 	ldw	r2,-28(fp)
 90ae2c4:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ae2c8:	0009883a 	mov	r4,zero
 90ae2cc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ae2d0:	00bfffc4 	movi	r2,-1
 90ae2d4:	e0bfff15 	stw	r2,-4(fp)
 90ae2d8:	00002d06 	br	90ae390 <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 90ae2dc:	e0bffd17 	ldw	r2,-12(fp)
 90ae2e0:	10800118 	cmpnei	r2,r2,4
 90ae2e4:	10000f1e 	bne	r2,zero,90ae324 <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 90ae2e8:	e0bffa17 	ldw	r2,-24(fp)
 90ae2ec:	10801f17 	ldw	r2,124(r2)
 90ae2f0:	1004c03a 	cmpne	r2,r2,zero
 90ae2f4:	1000041e 	bne	r2,zero,90ae308 <t_getsockopt+0x104>
 90ae2f8:	e0fffe17 	ldw	r3,-8(fp)
 90ae2fc:	00801004 	movi	r2,64
 90ae300:	18800015 	stw	r2,0(r3)
 90ae304:	00001d06 	br	90ae37c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 90ae308:	e0fffe17 	ldw	r3,-8(fp)
 90ae30c:	e0bffa17 	ldw	r2,-24(fp)
 90ae310:	10801f17 	ldw	r2,124(r2)
 90ae314:	10800043 	ldbu	r2,1(r2)
 90ae318:	10803fcc 	andi	r2,r2,255
 90ae31c:	18800015 	stw	r2,0(r3)
 90ae320:	00001606 	br	90ae37c <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 90ae324:	e0bffd17 	ldw	r2,-12(fp)
 90ae328:	108000d8 	cmpnei	r2,r2,3
 90ae32c:	10000e1e 	bne	r2,zero,90ae368 <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 90ae330:	e0bffa17 	ldw	r2,-24(fp)
 90ae334:	10801f17 	ldw	r2,124(r2)
 90ae338:	1004c03a 	cmpne	r2,r2,zero
 90ae33c:	1000031e 	bne	r2,zero,90ae34c <t_getsockopt+0x148>
 90ae340:	e0bffe17 	ldw	r2,-8(fp)
 90ae344:	10000015 	stw	zero,0(r2)
 90ae348:	00000c06 	br	90ae37c <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 90ae34c:	e0fffe17 	ldw	r3,-8(fp)
 90ae350:	e0bffa17 	ldw	r2,-24(fp)
 90ae354:	10801f17 	ldw	r2,124(r2)
 90ae358:	10800003 	ldbu	r2,0(r2)
 90ae35c:	10803fcc 	andi	r2,r2,255
 90ae360:	18800015 	stw	r2,0(r3)
 90ae364:	00000506 	br	90ae37c <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 90ae368:	0009883a 	mov	r4,zero
 90ae36c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 90ae370:	00bfffc4 	movi	r2,-1
 90ae374:	e0bfff15 	stw	r2,-4(fp)
 90ae378:	00000506 	br	90ae390 <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 90ae37c:	e0bffa17 	ldw	r2,-24(fp)
 90ae380:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90ae384:	0009883a 	mov	r4,zero
 90ae388:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return 0;
 90ae38c:	e03fff15 	stw	zero,-4(fp)
 90ae390:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae394:	e037883a 	mov	sp,fp
 90ae398:	dfc00117 	ldw	ra,4(sp)
 90ae39c:	df000017 	ldw	fp,0(sp)
 90ae3a0:	dec00204 	addi	sp,sp,8
 90ae3a4:	f800283a 	ret

090ae3a8 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 90ae3a8:	defff504 	addi	sp,sp,-44
 90ae3ac:	dfc00a15 	stw	ra,40(sp)
 90ae3b0:	df000915 	stw	fp,36(sp)
 90ae3b4:	df000904 	addi	fp,sp,36
 90ae3b8:	e13ffb15 	stw	r4,-20(fp)
 90ae3bc:	e17ffc15 	stw	r5,-16(fp)
 90ae3c0:	e1bffd15 	stw	r6,-12(fp)
 90ae3c4:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 90ae3c8:	e0bffd17 	ldw	r2,-12(fp)
 90ae3cc:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 90ae3d0:	e0bffb17 	ldw	r2,-20(fp)
 90ae3d4:	10bff804 	addi	r2,r2,-32
 90ae3d8:	1085883a 	add	r2,r2,r2
 90ae3dc:	1085883a 	add	r2,r2,r2
 90ae3e0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 90ae3e4:	e0bffa17 	ldw	r2,-24(fp)
 90ae3e8:	1080088b 	ldhu	r2,34(r2)
 90ae3ec:	10bfffcc 	andi	r2,r2,65535
 90ae3f0:	1080038c 	andi	r2,r2,14
 90ae3f4:	108000a0 	cmpeqi	r2,r2,2
 90ae3f8:	1000061e 	bne	r2,zero,90ae414 <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 90ae3fc:	e0fffa17 	ldw	r3,-24(fp)
 90ae400:	00800804 	movi	r2,32
 90ae404:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ae408:	00bfffc4 	movi	r2,-1
 90ae40c:	e0bfff15 	stw	r2,-4(fp)
 90ae410:	00001b06 	br	90ae480 <t_recv+0xd8>
   }
   so->so_error = 0;
 90ae414:	e0bffa17 	ldw	r2,-24(fp)
 90ae418:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 90ae41c:	0009883a 	mov	r4,zero
 90ae420:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 90ae424:	e1fffd04 	addi	r7,fp,-12
 90ae428:	e0bffe17 	ldw	r2,-8(fp)
 90ae42c:	d8800015 	stw	r2,0(sp)
 90ae430:	e13ffa17 	ldw	r4,-24(fp)
 90ae434:	000b883a 	mov	r5,zero
 90ae438:	e1bffc17 	ldw	r6,-16(fp)
 90ae43c:	90afd3c0 	call	90afd3c <soreceive>
 90ae440:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90ae444:	0009883a 	mov	r4,zero
 90ae448:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if(err)
 90ae44c:	e0bff917 	ldw	r2,-28(fp)
 90ae450:	1005003a 	cmpeq	r2,r2,zero
 90ae454:	1000061e 	bne	r2,zero,90ae470 <t_recv+0xc8>
   {
      so->so_error = err;
 90ae458:	e0fffa17 	ldw	r3,-24(fp)
 90ae45c:	e0bff917 	ldw	r2,-28(fp)
 90ae460:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 90ae464:	00bfffc4 	movi	r2,-1
 90ae468:	e0bfff15 	stw	r2,-4(fp)
 90ae46c:	00000406 	br	90ae480 <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 90ae470:	e0fffd17 	ldw	r3,-12(fp)
 90ae474:	e0bff817 	ldw	r2,-32(fp)
 90ae478:	10c5c83a 	sub	r2,r2,r3
 90ae47c:	e0bfff15 	stw	r2,-4(fp)
 90ae480:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae484:	e037883a 	mov	sp,fp
 90ae488:	dfc00117 	ldw	ra,4(sp)
 90ae48c:	df000017 	ldw	fp,0(sp)
 90ae490:	dec00204 	addi	sp,sp,8
 90ae494:	f800283a 	ret

090ae498 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 90ae498:	defff304 	addi	sp,sp,-52
 90ae49c:	dfc00c15 	stw	ra,48(sp)
 90ae4a0:	df000b15 	stw	fp,44(sp)
 90ae4a4:	df000b04 	addi	fp,sp,44
 90ae4a8:	e13ffb15 	stw	r4,-20(fp)
 90ae4ac:	e17ffc15 	stw	r5,-16(fp)
 90ae4b0:	e1bffd15 	stw	r6,-12(fp)
 90ae4b4:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 90ae4b8:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 90ae4bc:	e0bffd17 	ldw	r2,-12(fp)
 90ae4c0:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 90ae4c4:	e0bffb17 	ldw	r2,-20(fp)
 90ae4c8:	10bff804 	addi	r2,r2,-32
 90ae4cc:	1085883a 	add	r2,r2,r2
 90ae4d0:	1085883a 	add	r2,r2,r2
 90ae4d4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 90ae4d8:	008243b4 	movhi	r2,2318
 90ae4dc:	10b72304 	addi	r2,r2,-9076
 90ae4e0:	e0bff615 	stw	r2,-40(fp)
 90ae4e4:	00000606 	br	90ae500 <t_recvfrom+0x68>
 90ae4e8:	e0fff617 	ldw	r3,-40(fp)
 90ae4ec:	e0bff917 	ldw	r2,-28(fp)
 90ae4f0:	18800626 	beq	r3,r2,90ae50c <t_recvfrom+0x74>
 90ae4f4:	e0bff617 	ldw	r2,-40(fp)
 90ae4f8:	10800017 	ldw	r2,0(r2)
 90ae4fc:	e0bff615 	stw	r2,-40(fp)
 90ae500:	e0bff617 	ldw	r2,-40(fp)
 90ae504:	1004c03a 	cmpne	r2,r2,zero
 90ae508:	103ff71e 	bne	r2,zero,90ae4e8 <t_recvfrom+0x50>
 90ae50c:	e0fff617 	ldw	r3,-40(fp)
 90ae510:	e0bff917 	ldw	r2,-28(fp)
 90ae514:	18800426 	beq	r3,r2,90ae528 <t_recvfrom+0x90>
 90ae518:	90aa4780 	call	90aa478 <dtrap>
 90ae51c:	00bfffc4 	movi	r2,-1
 90ae520:	e0bfff15 	stw	r2,-4(fp)
 90ae524:	00002a06 	br	90ae5d0 <t_recvfrom+0x138>
   so->so_error = 0;
 90ae528:	e0bff917 	ldw	r2,-28(fp)
 90ae52c:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 90ae530:	0009883a 	mov	r4,zero
 90ae534:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 90ae538:	e17ffa04 	addi	r5,fp,-24
 90ae53c:	e1fffd04 	addi	r7,fp,-12
 90ae540:	e0bffe17 	ldw	r2,-8(fp)
 90ae544:	d8800015 	stw	r2,0(sp)
 90ae548:	e13ff917 	ldw	r4,-28(fp)
 90ae54c:	e1bffc17 	ldw	r6,-16(fp)
 90ae550:	90afd3c0 	call	90afd3c <soreceive>
 90ae554:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 90ae558:	e0bffa17 	ldw	r2,-24(fp)
 90ae55c:	1005003a 	cmpeq	r2,r2,zero
 90ae560:	10000c1e 	bne	r2,zero,90ae594 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 90ae564:	e0bffa17 	ldw	r2,-24(fp)
 90ae568:	10800317 	ldw	r2,12(r2)
 90ae56c:	100b883a 	mov	r5,r2
 90ae570:	e0800317 	ldw	r2,12(fp)
 90ae574:	10800017 	ldw	r2,0(r2)
 90ae578:	1007883a 	mov	r3,r2
 90ae57c:	e0800217 	ldw	r2,8(fp)
 90ae580:	1009883a 	mov	r4,r2
 90ae584:	180d883a 	mov	r6,r3
 90ae588:	90894600 	call	9089460 <memcpy>
      m_freem (sender);
 90ae58c:	e13ffa17 	ldw	r4,-24(fp)
 90ae590:	90ab5940 	call	90ab594 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 90ae594:	0009883a 	mov	r4,zero
 90ae598:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if(err)
 90ae59c:	e0bff817 	ldw	r2,-32(fp)
 90ae5a0:	1005003a 	cmpeq	r2,r2,zero
 90ae5a4:	1000061e 	bne	r2,zero,90ae5c0 <t_recvfrom+0x128>
   {
      so->so_error = err;
 90ae5a8:	e0fff917 	ldw	r3,-28(fp)
 90ae5ac:	e0bff817 	ldw	r2,-32(fp)
 90ae5b0:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae5b4:	00bfffc4 	movi	r2,-1
 90ae5b8:	e0bfff15 	stw	r2,-4(fp)
 90ae5bc:	00000406 	br	90ae5d0 <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 90ae5c0:	e0fffd17 	ldw	r3,-12(fp)
 90ae5c4:	e0bff717 	ldw	r2,-36(fp)
 90ae5c8:	10c5c83a 	sub	r2,r2,r3
 90ae5cc:	e0bfff15 	stw	r2,-4(fp)
 90ae5d0:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae5d4:	e037883a 	mov	sp,fp
 90ae5d8:	dfc00117 	ldw	ra,4(sp)
 90ae5dc:	df000017 	ldw	fp,0(sp)
 90ae5e0:	dec00204 	addi	sp,sp,8
 90ae5e4:	f800283a 	ret

090ae5e8 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 90ae5e8:	defff204 	addi	sp,sp,-56
 90ae5ec:	dfc00d15 	stw	ra,52(sp)
 90ae5f0:	df000c15 	stw	fp,48(sp)
 90ae5f4:	df000c04 	addi	fp,sp,48
 90ae5f8:	e13ffa15 	stw	r4,-24(fp)
 90ae5fc:	e17ffb15 	stw	r5,-20(fp)
 90ae600:	e1bffc15 	stw	r6,-16(fp)
 90ae604:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 90ae608:	e0bffa17 	ldw	r2,-24(fp)
 90ae60c:	10bff804 	addi	r2,r2,-32
 90ae610:	1085883a 	add	r2,r2,r2
 90ae614:	1085883a 	add	r2,r2,r2
 90ae618:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 90ae61c:	008243b4 	movhi	r2,2318
 90ae620:	10b72304 	addi	r2,r2,-9076
 90ae624:	e0bff515 	stw	r2,-44(fp)
 90ae628:	00000606 	br	90ae644 <t_sendto+0x5c>
 90ae62c:	e0fff517 	ldw	r3,-44(fp)
 90ae630:	e0bff817 	ldw	r2,-32(fp)
 90ae634:	18800626 	beq	r3,r2,90ae650 <t_sendto+0x68>
 90ae638:	e0bff517 	ldw	r2,-44(fp)
 90ae63c:	10800017 	ldw	r2,0(r2)
 90ae640:	e0bff515 	stw	r2,-44(fp)
 90ae644:	e0bff517 	ldw	r2,-44(fp)
 90ae648:	1004c03a 	cmpne	r2,r2,zero
 90ae64c:	103ff71e 	bne	r2,zero,90ae62c <t_sendto+0x44>
 90ae650:	e0fff517 	ldw	r3,-44(fp)
 90ae654:	e0bff817 	ldw	r2,-32(fp)
 90ae658:	18800426 	beq	r3,r2,90ae66c <t_sendto+0x84>
 90ae65c:	90aa4780 	call	90aa478 <dtrap>
 90ae660:	00bfffc4 	movi	r2,-1
 90ae664:	e0bfff15 	stw	r2,-4(fp)
 90ae668:	00006406 	br	90ae7fc <t_sendto+0x214>
   so->so_error = 0;
 90ae66c:	e0bff817 	ldw	r2,-32(fp)
 90ae670:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 90ae674:	e0bff817 	ldw	r2,-32(fp)
 90ae678:	10800983 	ldbu	r2,38(r2)
 90ae67c:	10803fcc 	andi	r2,r2,255
 90ae680:	1080201c 	xori	r2,r2,128
 90ae684:	10bfe004 	addi	r2,r2,-128
 90ae688:	e0bffe15 	stw	r2,-8(fp)
 90ae68c:	e0fffe17 	ldw	r3,-8(fp)
 90ae690:	188000a0 	cmpeqi	r2,r3,2
 90ae694:	10000e1e 	bne	r2,zero,90ae6d0 <t_sendto+0xe8>
 90ae698:	e0fffe17 	ldw	r3,-8(fp)
 90ae69c:	188000e0 	cmpeqi	r2,r3,3
 90ae6a0:	10000e1e 	bne	r2,zero,90ae6dc <t_sendto+0xf4>
 90ae6a4:	e0fffe17 	ldw	r3,-8(fp)
 90ae6a8:	18800060 	cmpeqi	r2,r3,1
 90ae6ac:	1000011e 	bne	r2,zero,90ae6b4 <t_sendto+0xcc>
 90ae6b0:	00001006 	br	90ae6f4 <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 90ae6b4:	e13ffa17 	ldw	r4,-24(fp)
 90ae6b8:	e17ffb17 	ldw	r5,-20(fp)
 90ae6bc:	e1bffc17 	ldw	r6,-16(fp)
 90ae6c0:	e1fffd17 	ldw	r7,-12(fp)
 90ae6c4:	90ae8140 	call	90ae814 <t_send>
 90ae6c8:	e0bfff15 	stw	r2,-4(fp)
 90ae6cc:	00004b06 	br	90ae7fc <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 90ae6d0:	90c4b700 	call	90c4b70 <udp_maxalloc>
 90ae6d4:	e0bff915 	stw	r2,-28(fp)
      break;
 90ae6d8:	00000d06 	br	90ae710 <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 90ae6dc:	e0bff817 	ldw	r2,-32(fp)
 90ae6e0:	10800417 	ldw	r2,16(r2)
 90ae6e4:	1108000c 	andi	r4,r2,8192
 90ae6e8:	90c36540 	call	90c3654 <ip_raw_maxalloc>
 90ae6ec:	e0bff915 	stw	r2,-28(fp)
      break;
 90ae6f0:	00000706 	br	90ae710 <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 90ae6f4:	90aa4780 	call	90aa478 <dtrap>
      so->so_error = EFAULT;
 90ae6f8:	e0fff817 	ldw	r3,-32(fp)
 90ae6fc:	00800384 	movi	r2,14
 90ae700:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae704:	00bfffc4 	movi	r2,-1
 90ae708:	e0bfff15 	stw	r2,-4(fp)
 90ae70c:	00003b06 	br	90ae7fc <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 90ae710:	e0fff917 	ldw	r3,-28(fp)
 90ae714:	e0bffc17 	ldw	r2,-16(fp)
 90ae718:	1880060e 	bge	r3,r2,90ae734 <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 90ae71c:	e0fff817 	ldw	r3,-32(fp)
 90ae720:	00801e84 	movi	r2,122
 90ae724:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae728:	00ffffc4 	movi	r3,-1
 90ae72c:	e0ffff15 	stw	r3,-4(fp)
 90ae730:	00003206 	br	90ae7fc <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 90ae734:	e0800217 	ldw	r2,8(fp)
 90ae738:	1005003a 	cmpeq	r2,r2,zero
 90ae73c:	10000e1e 	bne	r2,zero,90ae778 <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 90ae740:	e1000217 	ldw	r4,8(fp)
 90ae744:	e1400317 	ldw	r5,12(fp)
 90ae748:	01800244 	movi	r6,9
 90ae74c:	90aebf00 	call	90aebf0 <sockargs>
 90ae750:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 90ae754:	e0bff617 	ldw	r2,-40(fp)
 90ae758:	1004c03a 	cmpne	r2,r2,zero
 90ae75c:	1000071e 	bne	r2,zero,90ae77c <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 90ae760:	e0fff817 	ldw	r3,-32(fp)
 90ae764:	00800304 	movi	r2,12
 90ae768:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90ae76c:	00bfffc4 	movi	r2,-1
 90ae770:	e0bfff15 	stw	r2,-4(fp)
 90ae774:	00002106 	br	90ae7fc <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 90ae778:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 90ae77c:	e0bffc17 	ldw	r2,-16(fp)
 90ae780:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 90ae784:	0009883a 	mov	r4,zero
 90ae788:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 90ae78c:	e1fff904 	addi	r7,fp,-28
 90ae790:	e0bffd17 	ldw	r2,-12(fp)
 90ae794:	d8800015 	stw	r2,0(sp)
 90ae798:	e13ff817 	ldw	r4,-32(fp)
 90ae79c:	e17ff617 	ldw	r5,-40(fp)
 90ae7a0:	e1bffb17 	ldw	r6,-20(fp)
 90ae7a4:	90af7340 	call	90af734 <sosend>
 90ae7a8:	e0bff715 	stw	r2,-36(fp)

   if (name)
 90ae7ac:	e0bff617 	ldw	r2,-40(fp)
 90ae7b0:	1005003a 	cmpeq	r2,r2,zero
 90ae7b4:	1000021e 	bne	r2,zero,90ae7c0 <t_sendto+0x1d8>
      m_freem(name);
 90ae7b8:	e13ff617 	ldw	r4,-40(fp)
 90ae7bc:	90ab5940 	call	90ab594 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90ae7c0:	0009883a 	mov	r4,zero
 90ae7c4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 90ae7c8:	e0bff717 	ldw	r2,-36(fp)
 90ae7cc:	1005003a 	cmpeq	r2,r2,zero
 90ae7d0:	1000061e 	bne	r2,zero,90ae7ec <t_sendto+0x204>
   {
      so->so_error = err;
 90ae7d4:	e0fff817 	ldw	r3,-32(fp)
 90ae7d8:	e0bff717 	ldw	r2,-36(fp)
 90ae7dc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae7e0:	00ffffc4 	movi	r3,-1
 90ae7e4:	e0ffff15 	stw	r3,-4(fp)
 90ae7e8:	00000406 	br	90ae7fc <t_sendto+0x214>
   }

   return (len - sendlen);
 90ae7ec:	e0fff917 	ldw	r3,-28(fp)
 90ae7f0:	e0bffc17 	ldw	r2,-16(fp)
 90ae7f4:	10c5c83a 	sub	r2,r2,r3
 90ae7f8:	e0bfff15 	stw	r2,-4(fp)
 90ae7fc:	e0bfff17 	ldw	r2,-4(fp)
}
 90ae800:	e037883a 	mov	sp,fp
 90ae804:	dfc00117 	ldw	ra,4(sp)
 90ae808:	df000017 	ldw	fp,0(sp)
 90ae80c:	dec00204 	addi	sp,sp,8
 90ae810:	f800283a 	ret

090ae814 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 90ae814:	defff004 	addi	sp,sp,-64
 90ae818:	dfc00f15 	stw	ra,60(sp)
 90ae81c:	df000e15 	stw	fp,56(sp)
 90ae820:	df000e04 	addi	fp,sp,56
 90ae824:	e13ffb15 	stw	r4,-20(fp)
 90ae828:	e17ffc15 	stw	r5,-16(fp)
 90ae82c:	e1bffd15 	stw	r6,-12(fp)
 90ae830:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 90ae834:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 90ae838:	e0bffb17 	ldw	r2,-20(fp)
 90ae83c:	10bff804 	addi	r2,r2,-32
 90ae840:	1085883a 	add	r2,r2,r2
 90ae844:	1085883a 	add	r2,r2,r2
 90ae848:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 90ae84c:	e0bff917 	ldw	r2,-28(fp)
 90ae850:	1080088b 	ldhu	r2,34(r2)
 90ae854:	10bfffcc 	andi	r2,r2,65535
 90ae858:	1080038c 	andi	r2,r2,14
 90ae85c:	108000a0 	cmpeqi	r2,r2,2
 90ae860:	1000061e 	bne	r2,zero,90ae87c <t_send+0x68>
   {
      so->so_error = EPIPE;
 90ae864:	e0fff917 	ldw	r3,-28(fp)
 90ae868:	00800804 	movi	r2,32
 90ae86c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90ae870:	00bfffc4 	movi	r2,-1
 90ae874:	e0bfff15 	stw	r2,-4(fp)
 90ae878:	00006a06 	br	90aea24 <t_send+0x210>
   }
   so->so_error = 0;
 90ae87c:	e0bff917 	ldw	r2,-28(fp)
 90ae880:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 90ae884:	e0bff917 	ldw	r2,-28(fp)
 90ae888:	10800983 	ldbu	r2,38(r2)
 90ae88c:	10803fcc 	andi	r2,r2,255
 90ae890:	1080201c 	xori	r2,r2,128
 90ae894:	10bfe004 	addi	r2,r2,-128
 90ae898:	10800060 	cmpeqi	r2,r2,1
 90ae89c:	1000091e 	bne	r2,zero,90ae8c4 <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 90ae8a0:	d8000015 	stw	zero,0(sp)
 90ae8a4:	d8000115 	stw	zero,4(sp)
 90ae8a8:	e13ffb17 	ldw	r4,-20(fp)
 90ae8ac:	e17ffc17 	ldw	r5,-16(fp)
 90ae8b0:	e1bffd17 	ldw	r6,-12(fp)
 90ae8b4:	e1fffe17 	ldw	r7,-8(fp)
 90ae8b8:	90ae5e80 	call	90ae5e8 <t_sendto>
 90ae8bc:	e0bfff15 	stw	r2,-4(fp)
 90ae8c0:	00005806 	br	90aea24 <t_send+0x210>

   maxpkt = TCP_MSS;
 90ae8c4:	00816d04 	movi	r2,1460
 90ae8c8:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 90ae8cc:	e0bff917 	ldw	r2,-28(fp)
 90ae8d0:	10800117 	ldw	r2,4(r2)
 90ae8d4:	1005003a 	cmpeq	r2,r2,zero
 90ae8d8:	10004d1e 	bne	r2,zero,90aea10 <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 90ae8dc:	e0bff917 	ldw	r2,-28(fp)
 90ae8e0:	10800117 	ldw	r2,4(r2)
 90ae8e4:	10800917 	ldw	r2,36(r2)
 90ae8e8:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 90ae8ec:	e0bff417 	ldw	r2,-48(fp)
 90ae8f0:	10800a0b 	ldhu	r2,40(r2)
 90ae8f4:	10bfffcc 	andi	r2,r2,65535
 90ae8f8:	1005003a 	cmpeq	r2,r2,zero
 90ae8fc:	1000441e 	bne	r2,zero,90aea10 <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 90ae900:	e0bff417 	ldw	r2,-48(fp)
 90ae904:	10800a0b 	ldhu	r2,40(r2)
 90ae908:	10bfffcc 	andi	r2,r2,65535
 90ae90c:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 90ae910:	00003f06 	br	90aea10 <t_send+0x1fc>
   {
      if (len > maxpkt)
 90ae914:	e0fffd17 	ldw	r3,-12(fp)
 90ae918:	e0bff617 	ldw	r2,-40(fp)
 90ae91c:	10c0030e 	bge	r2,r3,90ae92c <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 90ae920:	e0bff617 	ldw	r2,-40(fp)
 90ae924:	e0bffa15 	stw	r2,-24(fp)
 90ae928:	00000206 	br	90ae934 <t_send+0x120>
      else
         sendlen = len;
 90ae92c:	e0bffd17 	ldw	r2,-12(fp)
 90ae930:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 90ae934:	e0bffa17 	ldw	r2,-24(fp)
 90ae938:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 90ae93c:	0009883a 	mov	r4,zero
 90ae940:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 90ae944:	e1fffa04 	addi	r7,fp,-24
 90ae948:	e0bffe17 	ldw	r2,-8(fp)
 90ae94c:	d8800015 	stw	r2,0(sp)
 90ae950:	e13ff917 	ldw	r4,-28(fp)
 90ae954:	000b883a 	mov	r5,zero
 90ae958:	e1bffc17 	ldw	r6,-16(fp)
 90ae95c:	90af7340 	call	90af734 <sosend>
 90ae960:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90ae964:	0009883a 	mov	r4,zero
 90ae968:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 90ae96c:	e0bff817 	ldw	r2,-32(fp)
 90ae970:	1005003a 	cmpeq	r2,r2,zero
 90ae974:	1000121e 	bne	r2,zero,90ae9c0 <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 90ae978:	e0bff817 	ldw	r2,-32(fp)
 90ae97c:	10801a60 	cmpeqi	r2,r2,105
 90ae980:	1000031e 	bne	r2,zero,90ae990 <t_send+0x17c>
 90ae984:	e0bff817 	ldw	r2,-32(fp)
 90ae988:	108002d8 	cmpnei	r2,r2,11
 90ae98c:	1000061e 	bne	r2,zero,90ae9a8 <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 90ae990:	e0bff717 	ldw	r2,-36(fp)
 90ae994:	1005003a 	cmpeq	r2,r2,zero
 90ae998:	1000031e 	bne	r2,zero,90ae9a8 <t_send+0x194>
            {
               so->so_error = 0;
 90ae99c:	e0bff917 	ldw	r2,-28(fp)
 90ae9a0:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 90ae9a4:	00001d06 	br	90aea1c <t_send+0x208>
            }
         }
         so->so_error = e;
 90ae9a8:	e0fff917 	ldw	r3,-28(fp)
 90ae9ac:	e0bff817 	ldw	r2,-32(fp)
 90ae9b0:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 90ae9b4:	00bfffc4 	movi	r2,-1
 90ae9b8:	e0bfff15 	stw	r2,-4(fp)
 90ae9bc:	00001906 	br	90aea24 <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 90ae9c0:	e0bffa17 	ldw	r2,-24(fp)
 90ae9c4:	1004c03a 	cmpne	r2,r2,zero
 90ae9c8:	1000141e 	bne	r2,zero,90aea1c <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 90ae9cc:	e0fffa17 	ldw	r3,-24(fp)
 90ae9d0:	e0bff517 	ldw	r2,-44(fp)
 90ae9d4:	10c5c83a 	sub	r2,r2,r3
 90ae9d8:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 90ae9dc:	e0bff517 	ldw	r2,-44(fp)
 90ae9e0:	1007883a 	mov	r3,r2
 90ae9e4:	e0bffc17 	ldw	r2,-16(fp)
 90ae9e8:	10c5883a 	add	r2,r2,r3
 90ae9ec:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 90ae9f0:	e0fffd17 	ldw	r3,-12(fp)
 90ae9f4:	e0bff517 	ldw	r2,-44(fp)
 90ae9f8:	1885c83a 	sub	r2,r3,r2
 90ae9fc:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 90aea00:	e0fff717 	ldw	r3,-36(fp)
 90aea04:	e0bff517 	ldw	r2,-44(fp)
 90aea08:	1885883a 	add	r2,r3,r2
 90aea0c:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 90aea10:	e0bffd17 	ldw	r2,-12(fp)
 90aea14:	1004c03a 	cmpne	r2,r2,zero
 90aea18:	103fbe1e 	bne	r2,zero,90ae914 <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 90aea1c:	e0bff717 	ldw	r2,-36(fp)
 90aea20:	e0bfff15 	stw	r2,-4(fp)
 90aea24:	e0bfff17 	ldw	r2,-4(fp)
}
 90aea28:	e037883a 	mov	sp,fp
 90aea2c:	dfc00117 	ldw	ra,4(sp)
 90aea30:	df000017 	ldw	fp,0(sp)
 90aea34:	dec00204 	addi	sp,sp,8
 90aea38:	f800283a 	ret

090aea3c <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 90aea3c:	defff804 	addi	sp,sp,-32
 90aea40:	dfc00715 	stw	ra,28(sp)
 90aea44:	df000615 	stw	fp,24(sp)
 90aea48:	df000604 	addi	fp,sp,24
 90aea4c:	e13ffd15 	stw	r4,-12(fp)
 90aea50:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 90aea54:	e0bffd17 	ldw	r2,-12(fp)
 90aea58:	10bff804 	addi	r2,r2,-32
 90aea5c:	1085883a 	add	r2,r2,r2
 90aea60:	1085883a 	add	r2,r2,r2
 90aea64:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 90aea68:	008243b4 	movhi	r2,2318
 90aea6c:	10b72304 	addi	r2,r2,-9076
 90aea70:	e0bffa15 	stw	r2,-24(fp)
 90aea74:	00000606 	br	90aea90 <t_shutdown+0x54>
 90aea78:	e0fffa17 	ldw	r3,-24(fp)
 90aea7c:	e0bffc17 	ldw	r2,-16(fp)
 90aea80:	18800626 	beq	r3,r2,90aea9c <t_shutdown+0x60>
 90aea84:	e0bffa17 	ldw	r2,-24(fp)
 90aea88:	10800017 	ldw	r2,0(r2)
 90aea8c:	e0bffa15 	stw	r2,-24(fp)
 90aea90:	e0bffa17 	ldw	r2,-24(fp)
 90aea94:	1004c03a 	cmpne	r2,r2,zero
 90aea98:	103ff71e 	bne	r2,zero,90aea78 <t_shutdown+0x3c>
 90aea9c:	e0fffa17 	ldw	r3,-24(fp)
 90aeaa0:	e0bffc17 	ldw	r2,-16(fp)
 90aeaa4:	18800426 	beq	r3,r2,90aeab8 <t_shutdown+0x7c>
 90aeaa8:	90aa4780 	call	90aa478 <dtrap>
 90aeaac:	00bfffc4 	movi	r2,-1
 90aeab0:	e0bfff15 	stw	r2,-4(fp)
 90aeab4:	00001406 	br	90aeb08 <t_shutdown+0xcc>
   so->so_error = 0;
 90aeab8:	e0bffc17 	ldw	r2,-16(fp)
 90aeabc:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 90aeac0:	0009883a 	mov	r4,zero
 90aeac4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 90aeac8:	e13ffc17 	ldw	r4,-16(fp)
 90aeacc:	e17ffe17 	ldw	r5,-8(fp)
 90aead0:	90b05200 	call	90b0520 <soshutdown>
 90aead4:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90aead8:	0009883a 	mov	r4,zero
 90aeadc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 90aeae0:	e0bffb17 	ldw	r2,-20(fp)
 90aeae4:	1005003a 	cmpeq	r2,r2,zero
 90aeae8:	1000061e 	bne	r2,zero,90aeb04 <t_shutdown+0xc8>
   {
      so->so_error = err;
 90aeaec:	e0fffc17 	ldw	r3,-16(fp)
 90aeaf0:	e0bffb17 	ldw	r2,-20(fp)
 90aeaf4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 90aeaf8:	00bfffc4 	movi	r2,-1
 90aeafc:	e0bfff15 	stw	r2,-4(fp)
 90aeb00:	00000106 	br	90aeb08 <t_shutdown+0xcc>
   }
   return 0;
 90aeb04:	e03fff15 	stw	zero,-4(fp)
 90aeb08:	e0bfff17 	ldw	r2,-4(fp)
}
 90aeb0c:	e037883a 	mov	sp,fp
 90aeb10:	dfc00117 	ldw	ra,4(sp)
 90aeb14:	df000017 	ldw	fp,0(sp)
 90aeb18:	dec00204 	addi	sp,sp,8
 90aeb1c:	f800283a 	ret

090aeb20 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 90aeb20:	defff904 	addi	sp,sp,-28
 90aeb24:	dfc00615 	stw	ra,24(sp)
 90aeb28:	df000515 	stw	fp,20(sp)
 90aeb2c:	df000504 	addi	fp,sp,20
 90aeb30:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 90aeb34:	e0bffe17 	ldw	r2,-8(fp)
 90aeb38:	10bff804 	addi	r2,r2,-32
 90aeb3c:	1085883a 	add	r2,r2,r2
 90aeb40:	1085883a 	add	r2,r2,r2
 90aeb44:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 90aeb48:	008243b4 	movhi	r2,2318
 90aeb4c:	10b72304 	addi	r2,r2,-9076
 90aeb50:	e0bffb15 	stw	r2,-20(fp)
 90aeb54:	00000606 	br	90aeb70 <t_socketclose+0x50>
 90aeb58:	e0fffb17 	ldw	r3,-20(fp)
 90aeb5c:	e0bffd17 	ldw	r2,-12(fp)
 90aeb60:	18800626 	beq	r3,r2,90aeb7c <t_socketclose+0x5c>
 90aeb64:	e0bffb17 	ldw	r2,-20(fp)
 90aeb68:	10800017 	ldw	r2,0(r2)
 90aeb6c:	e0bffb15 	stw	r2,-20(fp)
 90aeb70:	e0bffb17 	ldw	r2,-20(fp)
 90aeb74:	1004c03a 	cmpne	r2,r2,zero
 90aeb78:	103ff71e 	bne	r2,zero,90aeb58 <t_socketclose+0x38>
 90aeb7c:	e0fffb17 	ldw	r3,-20(fp)
 90aeb80:	e0bffd17 	ldw	r2,-12(fp)
 90aeb84:	18800426 	beq	r3,r2,90aeb98 <t_socketclose+0x78>
 90aeb88:	90aa4780 	call	90aa478 <dtrap>
 90aeb8c:	00bfffc4 	movi	r2,-1
 90aeb90:	e0bfff15 	stw	r2,-4(fp)
 90aeb94:	00001006 	br	90aebd8 <t_socketclose+0xb8>
   so->so_error = 0;
 90aeb98:	e0bffd17 	ldw	r2,-12(fp)
 90aeb9c:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 90aeba0:	0009883a 	mov	r4,zero
 90aeba4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   err = soclose(so);
 90aeba8:	e13ffd17 	ldw	r4,-12(fp)
 90aebac:	90af16c0 	call	90af16c <soclose>
 90aebb0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90aebb4:	0009883a 	mov	r4,zero
 90aebb8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 90aebbc:	e0bffc17 	ldw	r2,-16(fp)
 90aebc0:	1005003a 	cmpeq	r2,r2,zero
 90aebc4:	1000031e 	bne	r2,zero,90aebd4 <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 90aebc8:	00bfffc4 	movi	r2,-1
 90aebcc:	e0bfff15 	stw	r2,-4(fp)
 90aebd0:	00000106 	br	90aebd8 <t_socketclose+0xb8>
   }
   return 0;
 90aebd4:	e03fff15 	stw	zero,-4(fp)
 90aebd8:	e0bfff17 	ldw	r2,-4(fp)
}
 90aebdc:	e037883a 	mov	sp,fp
 90aebe0:	dfc00117 	ldw	ra,4(sp)
 90aebe4:	df000017 	ldw	fp,0(sp)
 90aebe8:	dec00204 	addi	sp,sp,8
 90aebec:	f800283a 	ret

090aebf0 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 90aebf0:	defff904 	addi	sp,sp,-28
 90aebf4:	dfc00615 	stw	ra,24(sp)
 90aebf8:	df000515 	stw	fp,20(sp)
 90aebfc:	df000504 	addi	fp,sp,20
 90aec00:	e13ffc15 	stw	r4,-16(fp)
 90aec04:	e17ffd15 	stw	r5,-12(fp)
 90aec08:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 90aec0c:	0009883a 	mov	r4,zero
 90aec10:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 90aec14:	e13ffe17 	ldw	r4,-8(fp)
 90aec18:	e17ffd17 	ldw	r5,-12(fp)
 90aec1c:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90aec20:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90aec24:	0009883a 	mov	r4,zero
 90aec28:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 90aec2c:	e0bffb17 	ldw	r2,-20(fp)
 90aec30:	1004c03a 	cmpne	r2,r2,zero
 90aec34:	1000021e 	bne	r2,zero,90aec40 <sockargs+0x50>
      return NULL;
 90aec38:	e03fff15 	stw	zero,-4(fp)
 90aec3c:	00000c06 	br	90aec70 <sockargs+0x80>
   m->m_len = arglen;
 90aec40:	e0fffd17 	ldw	r3,-12(fp)
 90aec44:	e0bffb17 	ldw	r2,-20(fp)
 90aec48:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 90aec4c:	e0bffb17 	ldw	r2,-20(fp)
 90aec50:	10c00317 	ldw	r3,12(r2)
 90aec54:	e1bffd17 	ldw	r6,-12(fp)
 90aec58:	e0bffc17 	ldw	r2,-16(fp)
 90aec5c:	1809883a 	mov	r4,r3
 90aec60:	100b883a 	mov	r5,r2
 90aec64:	90894600 	call	9089460 <memcpy>
   return m;
 90aec68:	e0bffb17 	ldw	r2,-20(fp)
 90aec6c:	e0bfff15 	stw	r2,-4(fp)
 90aec70:	e0bfff17 	ldw	r2,-4(fp)
}
 90aec74:	e037883a 	mov	sp,fp
 90aec78:	dfc00117 	ldw	ra,4(sp)
 90aec7c:	df000017 	ldw	fp,0(sp)
 90aec80:	dec00204 	addi	sp,sp,8
 90aec84:	f800283a 	ret

090aec88 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 90aec88:	defffa04 	addi	sp,sp,-24
 90aec8c:	dfc00515 	stw	ra,20(sp)
 90aec90:	df000415 	stw	fp,16(sp)
 90aec94:	df000404 	addi	fp,sp,16
 90aec98:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 90aec9c:	e0bfff17 	ldw	r2,-4(fp)
 90aeca0:	10bff804 	addi	r2,r2,-32
 90aeca4:	1085883a 	add	r2,r2,r2
 90aeca8:	1085883a 	add	r2,r2,r2
 90aecac:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 90aecb0:	00801b04 	movi	r2,108
 90aecb4:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 90aecb8:	0009883a 	mov	r4,zero
 90aecbc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 90aecc0:	008243b4 	movhi	r2,2318
 90aecc4:	10b72304 	addi	r2,r2,-9076
 90aecc8:	e0bffd15 	stw	r2,-12(fp)
 90aeccc:	00000a06 	br	90aecf8 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 90aecd0:	e0fffd17 	ldw	r3,-12(fp)
 90aecd4:	e0bffe17 	ldw	r2,-8(fp)
 90aecd8:	1880041e 	bne	r3,r2,90aecec <t_errno+0x64>
      {
         errcode = so->so_error;
 90aecdc:	e0bffe17 	ldw	r2,-8(fp)
 90aece0:	10800617 	ldw	r2,24(r2)
 90aece4:	e0bffc15 	stw	r2,-16(fp)
         break;
 90aece8:	00000606 	br	90aed04 <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 90aecec:	e0bffd17 	ldw	r2,-12(fp)
 90aecf0:	10800017 	ldw	r2,0(r2)
 90aecf4:	e0bffd15 	stw	r2,-12(fp)
 90aecf8:	e0bffd17 	ldw	r2,-12(fp)
 90aecfc:	1004c03a 	cmpne	r2,r2,zero
 90aed00:	103ff31e 	bne	r2,zero,90aecd0 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 90aed04:	0009883a 	mov	r4,zero
 90aed08:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   return errcode;
 90aed0c:	e0bffc17 	ldw	r2,-16(fp)
}
 90aed10:	e037883a 	mov	sp,fp
 90aed14:	dfc00117 	ldw	ra,4(sp)
 90aed18:	df000017 	ldw	fp,0(sp)
 90aed1c:	dec00204 	addi	sp,sp,8
 90aed20:	f800283a 	ret

090aed24 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 90aed24:	defff604 	addi	sp,sp,-40
 90aed28:	dfc00915 	stw	ra,36(sp)
 90aed2c:	df000815 	stw	fp,32(sp)
 90aed30:	df000804 	addi	fp,sp,32
 90aed34:	e13ffc15 	stw	r4,-16(fp)
 90aed38:	e17ffd15 	stw	r5,-12(fp)
 90aed3c:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 90aed40:	e0bffe17 	ldw	r2,-8(fp)
 90aed44:	1005003a 	cmpeq	r2,r2,zero
 90aed48:	1000061e 	bne	r2,zero,90aed64 <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 90aed4c:	e13ffc17 	ldw	r4,-16(fp)
 90aed50:	e17ffe17 	ldw	r5,-8(fp)
 90aed54:	e1bffd17 	ldw	r6,-12(fp)
 90aed58:	90ab1e80 	call	90ab1e8 <pffindproto>
 90aed5c:	e0bffb15 	stw	r2,-20(fp)
 90aed60:	00000406 	br	90aed74 <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 90aed64:	e13ffc17 	ldw	r4,-16(fp)
 90aed68:	e17ffd17 	ldw	r5,-12(fp)
 90aed6c:	90ab1480 	call	90ab148 <pffindtype>
 90aed70:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 90aed74:	e0bffb17 	ldw	r2,-20(fp)
 90aed78:	1004c03a 	cmpne	r2,r2,zero
 90aed7c:	1000021e 	bne	r2,zero,90aed88 <socreate+0x64>
      return NULL;
 90aed80:	e03fff15 	stw	zero,-4(fp)
 90aed84:	00005406 	br	90aeed8 <socreate+0x1b4>
   if (prp->pr_type != type)
 90aed88:	e0bffb17 	ldw	r2,-20(fp)
 90aed8c:	1080000b 	ldhu	r2,0(r2)
 90aed90:	10ffffcc 	andi	r3,r2,65535
 90aed94:	18e0001c 	xori	r3,r3,32768
 90aed98:	18e00004 	addi	r3,r3,-32768
 90aed9c:	e0bffd17 	ldw	r2,-12(fp)
 90aeda0:	18800226 	beq	r3,r2,90aedac <socreate+0x88>
      return NULL;
 90aeda4:	e03fff15 	stw	zero,-4(fp)
 90aeda8:	00004b06 	br	90aeed8 <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 90aedac:	01002104 	movi	r4,132
 90aedb0:	90aaefc0 	call	90aaefc <npalloc>
 90aedb4:	e0bffa15 	stw	r2,-24(fp)
 90aedb8:	e0bffa17 	ldw	r2,-24(fp)
 90aedbc:	1004c03a 	cmpne	r2,r2,zero
 90aedc0:	1000021e 	bne	r2,zero,90aedcc <socreate+0xa8>
      return NULL;
 90aedc4:	e03fff15 	stw	zero,-4(fp)
 90aedc8:	00004306 	br	90aeed8 <socreate+0x1b4>
   so->next = NULL;
 90aedcc:	e0bffa17 	ldw	r2,-24(fp)
 90aedd0:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 90aedd4:	e17ffa17 	ldw	r5,-24(fp)
 90aedd8:	010243b4 	movhi	r4,2318
 90aeddc:	21372304 	addi	r4,r4,-9076
 90aede0:	90a9e080 	call	90a9e08 <putq>

   so->so_options = socket_defaults;
 90aede4:	d0a03a0b 	ldhu	r2,-32536(gp)
 90aede8:	10ffffcc 	andi	r3,r2,65535
 90aedec:	e0bffa17 	ldw	r2,-24(fp)
 90aedf0:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 90aedf4:	e0fffa17 	ldw	r3,-24(fp)
 90aedf8:	e0bffc17 	ldw	r2,-16(fp)
 90aedfc:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 90aee00:	e0bffa17 	ldw	r2,-24(fp)
 90aee04:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 90aee08:	e0bffd17 	ldw	r2,-12(fp)
 90aee0c:	1007883a 	mov	r3,r2
 90aee10:	e0bffa17 	ldw	r2,-24(fp)
 90aee14:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 90aee18:	e0fffa17 	ldw	r3,-24(fp)
 90aee1c:	e0bffb17 	ldw	r2,-20(fp)
 90aee20:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 90aee24:	e0bffa17 	ldw	r2,-24(fp)
 90aee28:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 90aee2c:	e0bffa17 	ldw	r2,-24(fp)
 90aee30:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 90aee34:	e0bffb17 	ldw	r2,-20(fp)
 90aee38:	10800317 	ldw	r2,12(r2)
 90aee3c:	e1bffe17 	ldw	r6,-8(fp)
 90aee40:	e13ffa17 	ldw	r4,-24(fp)
 90aee44:	000b883a 	mov	r5,zero
 90aee48:	103ee83a 	callr	r2
 90aee4c:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 90aee50:	e0bff917 	ldw	r2,-28(fp)
 90aee54:	1004c03a 	cmpne	r2,r2,zero
 90aee58:	10000f1e 	bne	r2,zero,90aee98 <socreate+0x174>

   if (so_evtmap)
 90aee5c:	00824374 	movhi	r2,2317
 90aee60:	108f5404 	addi	r2,r2,15696
 90aee64:	10800003 	ldbu	r2,0(r2)
 90aee68:	10803fcc 	andi	r2,r2,255
 90aee6c:	1005003a 	cmpeq	r2,r2,zero
 90aee70:	1000171e 	bne	r2,zero,90aeed0 <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 90aee74:	00824374 	movhi	r2,2317
 90aee78:	108f5204 	addi	r2,r2,15688
 90aee7c:	10800017 	ldw	r2,0(r2)
 90aee80:	e13ffa17 	ldw	r4,-24(fp)
 90aee84:	103ee83a 	callr	r2
 90aee88:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 90aee8c:	e0bff817 	ldw	r2,-32(fp)
 90aee90:	1005003a 	cmpeq	r2,r2,zero
 90aee94:	10000a1e 	bne	r2,zero,90aeec0 <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 90aee98:	e0bffa17 	ldw	r2,-24(fp)
 90aee9c:	1080088b 	ldhu	r2,34(r2)
 90aeea0:	10800054 	ori	r2,r2,1
 90aeea4:	1007883a 	mov	r3,r2
 90aeea8:	e0bffa17 	ldw	r2,-24(fp)
 90aeeac:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 90aeeb0:	e13ffa17 	ldw	r4,-24(fp)
 90aeeb4:	90af03c0 	call	90af03c <sofree>
         return NULL;   
 90aeeb8:	e03fff15 	stw	zero,-4(fp)
 90aeebc:	00000606 	br	90aeed8 <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 90aeec0:	90a5f980 	call	90a5f98 <TK_OSTaskQuery>
 90aeec4:	1007883a 	mov	r3,r2
 90aeec8:	e0bffa17 	ldw	r2,-24(fp)
 90aeecc:	10c02005 	stb	r3,128(r2)
   }

   return so;
 90aeed0:	e0bffa17 	ldw	r2,-24(fp)
 90aeed4:	e0bfff15 	stw	r2,-4(fp)
 90aeed8:	e0bfff17 	ldw	r2,-4(fp)
}
 90aeedc:	e037883a 	mov	sp,fp
 90aeee0:	dfc00117 	ldw	ra,4(sp)
 90aeee4:	df000017 	ldw	fp,0(sp)
 90aeee8:	dec00204 	addi	sp,sp,8
 90aeeec:	f800283a 	ret

090aeef0 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 90aeef0:	defffb04 	addi	sp,sp,-20
 90aeef4:	dfc00415 	stw	ra,16(sp)
 90aeef8:	df000315 	stw	fp,12(sp)
 90aeefc:	df000304 	addi	fp,sp,12
 90aef00:	e13ffe15 	stw	r4,-8(fp)
 90aef04:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 90aef08:	e0fffe17 	ldw	r3,-8(fp)
 90aef0c:	00800084 	movi	r2,2
 90aef10:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90aef14:	e0bffe17 	ldw	r2,-8(fp)
 90aef18:	10800217 	ldw	r2,8(r2)
 90aef1c:	10800317 	ldw	r2,12(r2)
 90aef20:	e13ffe17 	ldw	r4,-8(fp)
 90aef24:	000b883a 	mov	r5,zero
 90aef28:	e1bfff17 	ldw	r6,-4(fp)
 90aef2c:	103ee83a 	callr	r2
 90aef30:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 90aef34:	e0bffd17 	ldw	r2,-12(fp)
}
 90aef38:	e037883a 	mov	sp,fp
 90aef3c:	dfc00117 	ldw	ra,4(sp)
 90aef40:	df000017 	ldw	fp,0(sp)
 90aef44:	dec00204 	addi	sp,sp,8
 90aef48:	f800283a 	ret

090aef4c <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 90aef4c:	defff904 	addi	sp,sp,-28
 90aef50:	dfc00615 	stw	ra,24(sp)
 90aef54:	df000515 	stw	fp,20(sp)
 90aef58:	df000504 	addi	fp,sp,20
 90aef5c:	e13ffc15 	stw	r4,-16(fp)
 90aef60:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 90aef64:	e0fffc17 	ldw	r3,-16(fp)
 90aef68:	008000c4 	movi	r2,3
 90aef6c:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 90aef70:	e0bffc17 	ldw	r2,-16(fp)
 90aef74:	10800217 	ldw	r2,8(r2)
 90aef78:	10800317 	ldw	r2,12(r2)
 90aef7c:	e13ffc17 	ldw	r4,-16(fp)
 90aef80:	000b883a 	mov	r5,zero
 90aef84:	000d883a 	mov	r6,zero
 90aef88:	103ee83a 	callr	r2
 90aef8c:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 90aef90:	e0bffb17 	ldw	r2,-20(fp)
 90aef94:	1005003a 	cmpeq	r2,r2,zero
 90aef98:	1000031e 	bne	r2,zero,90aefa8 <solisten+0x5c>
   {
      return (error);
 90aef9c:	e0bffb17 	ldw	r2,-20(fp)
 90aefa0:	e0bfff15 	stw	r2,-4(fp)
 90aefa4:	00001f06 	br	90af024 <solisten+0xd8>
   }
   if (so->so_q == 0) 
 90aefa8:	e0bffc17 	ldw	r2,-16(fp)
 90aefac:	10801d17 	ldw	r2,116(r2)
 90aefb0:	1004c03a 	cmpne	r2,r2,zero
 90aefb4:	10000b1e 	bne	r2,zero,90aefe4 <solisten+0x98>
   {
      so->so_q = so;
 90aefb8:	e0fffc17 	ldw	r3,-16(fp)
 90aefbc:	e0bffc17 	ldw	r2,-16(fp)
 90aefc0:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 90aefc4:	e0fffc17 	ldw	r3,-16(fp)
 90aefc8:	e0bffc17 	ldw	r2,-16(fp)
 90aefcc:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 90aefd0:	e0bffc17 	ldw	r2,-16(fp)
 90aefd4:	10800417 	ldw	r2,16(r2)
 90aefd8:	10c00094 	ori	r3,r2,2
 90aefdc:	e0bffc17 	ldw	r2,-16(fp)
 90aefe0:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 90aefe4:	e0bffd17 	ldw	r2,-12(fp)
 90aefe8:	1004403a 	cmpge	r2,r2,zero
 90aefec:	1000011e 	bne	r2,zero,90aeff4 <solisten+0xa8>
      backlog = 0;
 90aeff0:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 90aeff4:	e0fffd17 	ldw	r3,-12(fp)
 90aeff8:	e0fffe15 	stw	r3,-8(fp)
 90aeffc:	e0fffe17 	ldw	r3,-8(fp)
 90af000:	18800190 	cmplti	r2,r3,6
 90af004:	1000021e 	bne	r2,zero,90af010 <solisten+0xc4>
 90af008:	00800144 	movi	r2,5
 90af00c:	e0bffe15 	stw	r2,-8(fp)
 90af010:	e0bffe17 	ldw	r2,-8(fp)
 90af014:	1007883a 	mov	r3,r2
 90af018:	e0bffc17 	ldw	r2,-16(fp)
 90af01c:	10c01e85 	stb	r3,122(r2)
   return 0;
 90af020:	e03fff15 	stw	zero,-4(fp)
 90af024:	e0bfff17 	ldw	r2,-4(fp)
}
 90af028:	e037883a 	mov	sp,fp
 90af02c:	dfc00117 	ldw	ra,4(sp)
 90af030:	df000017 	ldw	fp,0(sp)
 90af034:	dec00204 	addi	sp,sp,8
 90af038:	f800283a 	ret

090af03c <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 90af03c:	defffd04 	addi	sp,sp,-12
 90af040:	dfc00215 	stw	ra,8(sp)
 90af044:	df000115 	stw	fp,4(sp)
 90af048:	df000104 	addi	fp,sp,4
 90af04c:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 90af050:	e0bfff17 	ldw	r2,-4(fp)
 90af054:	10800117 	ldw	r2,4(r2)
 90af058:	1004c03a 	cmpne	r2,r2,zero
 90af05c:	10003e1e 	bne	r2,zero,90af158 <sofree+0x11c>
 90af060:	e0bfff17 	ldw	r2,-4(fp)
 90af064:	1080088b 	ldhu	r2,34(r2)
 90af068:	10bfffcc 	andi	r2,r2,65535
 90af06c:	1080004c 	andi	r2,r2,1
 90af070:	1004c03a 	cmpne	r2,r2,zero
 90af074:	1000011e 	bne	r2,zero,90af07c <sofree+0x40>
      return;
 90af078:	00003706 	br	90af158 <sofree+0x11c>
   if (so->so_head) 
 90af07c:	e0bfff17 	ldw	r2,-4(fp)
 90af080:	10801b17 	ldw	r2,108(r2)
 90af084:	1005003a 	cmpeq	r2,r2,zero
 90af088:	10000f1e 	bne	r2,zero,90af0c8 <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 90af08c:	e13fff17 	ldw	r4,-4(fp)
 90af090:	000b883a 	mov	r5,zero
 90af094:	90b16840 	call	90b1684 <soqremque>
 90af098:	1004c03a 	cmpne	r2,r2,zero
 90af09c:	1000081e 	bne	r2,zero,90af0c0 <sofree+0x84>
 90af0a0:	e13fff17 	ldw	r4,-4(fp)
 90af0a4:	01400044 	movi	r5,1
 90af0a8:	90b16840 	call	90b1684 <soqremque>
 90af0ac:	1004c03a 	cmpne	r2,r2,zero
 90af0b0:	1000031e 	bne	r2,zero,90af0c0 <sofree+0x84>
         panic("sofree");
 90af0b4:	01024374 	movhi	r4,2317
 90af0b8:	21024004 	addi	r4,r4,2304
 90af0bc:	90a537c0 	call	90a537c <panic>
      so->so_head = 0;
 90af0c0:	e0bfff17 	ldw	r2,-4(fp)
 90af0c4:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 90af0c8:	e0bfff17 	ldw	r2,-4(fp)
 90af0cc:	11001204 	addi	r4,r2,72
 90af0d0:	90b1a600 	call	90b1a60 <sbrelease>
   sorflush(so);
 90af0d4:	e13fff17 	ldw	r4,-4(fp)
 90af0d8:	90b05c80 	call	90b05c8 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 90af0dc:	e0bfff17 	ldw	r2,-4(fp)
 90af0e0:	10800317 	ldw	r2,12(r2)
 90af0e4:	1005003a 	cmpeq	r2,r2,zero
 90af0e8:	1000031e 	bne	r2,zero,90af0f8 <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 90af0ec:	e0bfff17 	ldw	r2,-4(fp)
 90af0f0:	11000317 	ldw	r4,12(r2)
 90af0f4:	90c5f040 	call	90c5f04 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 90af0f8:	e0bfff17 	ldw	r2,-4(fp)
 90af0fc:	10801f17 	ldw	r2,124(r2)
 90af100:	1005003a 	cmpeq	r2,r2,zero
 90af104:	1000031e 	bne	r2,zero,90af114 <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 90af108:	e0bfff17 	ldw	r2,-4(fp)
 90af10c:	11001f17 	ldw	r4,124(r2)
 90af110:	90aaff00 	call	90aaff0 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 90af114:	010243b4 	movhi	r4,2318
 90af118:	21372304 	addi	r4,r4,-9076
 90af11c:	e17fff17 	ldw	r5,-4(fp)
 90af120:	90a9eb80 	call	90a9eb8 <qdel>
   
   if (so_evtmap)  
 90af124:	00824374 	movhi	r2,2317
 90af128:	108f5404 	addi	r2,r2,15696
 90af12c:	10800003 	ldbu	r2,0(r2)
 90af130:	10803fcc 	andi	r2,r2,255
 90af134:	1005003a 	cmpeq	r2,r2,zero
 90af138:	1000051e 	bne	r2,zero,90af150 <sofree+0x114>
      (*so_evtmap_delete) (so);
 90af13c:	00824374 	movhi	r2,2317
 90af140:	108f5304 	addi	r2,r2,15692
 90af144:	10800017 	ldw	r2,0(r2)
 90af148:	e13fff17 	ldw	r4,-4(fp)
 90af14c:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 90af150:	e13fff17 	ldw	r4,-4(fp)
 90af154:	90aaff00 	call	90aaff0 <npfree>
}
 90af158:	e037883a 	mov	sp,fp
 90af15c:	dfc00117 	ldw	ra,4(sp)
 90af160:	df000017 	ldw	fp,0(sp)
 90af164:	dec00204 	addi	sp,sp,8
 90af168:	f800283a 	ret

090af16c <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 90af16c:	defff604 	addi	sp,sp,-40
 90af170:	dfc00915 	stw	ra,36(sp)
 90af174:	df000815 	stw	fp,32(sp)
 90af178:	dc400715 	stw	r17,28(sp)
 90af17c:	dc000615 	stw	r16,24(sp)
 90af180:	df000604 	addi	fp,sp,24
 90af184:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 90af188:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 90af18c:	008243b4 	movhi	r2,2318
 90af190:	10b72304 	addi	r2,r2,-9076
 90af194:	10800017 	ldw	r2,0(r2)
 90af198:	e0bffc15 	stw	r2,-16(fp)
 90af19c:	00000606 	br	90af1b8 <soclose+0x4c>
   {
      if (so == tmpso)
 90af1a0:	e0fffe17 	ldw	r3,-8(fp)
 90af1a4:	e0bffc17 	ldw	r2,-16(fp)
 90af1a8:	18800626 	beq	r3,r2,90af1c4 <soclose+0x58>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 90af1ac:	e0bffc17 	ldw	r2,-16(fp)
 90af1b0:	10800017 	ldw	r2,0(r2)
 90af1b4:	e0bffc15 	stw	r2,-16(fp)
 90af1b8:	e0bffc17 	ldw	r2,-16(fp)
 90af1bc:	1004c03a 	cmpne	r2,r2,zero
 90af1c0:	103ff71e 	bne	r2,zero,90af1a0 <soclose+0x34>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 90af1c4:	e0bffc17 	ldw	r2,-16(fp)
 90af1c8:	1004c03a 	cmpne	r2,r2,zero
 90af1cc:	1000031e 	bne	r2,zero,90af1dc <soclose+0x70>
      return EINVAL;
 90af1d0:	00800584 	movi	r2,22
 90af1d4:	e0bfff15 	stw	r2,-4(fp)
 90af1d8:	0000b606 	br	90af4b4 <soclose+0x348>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 90af1dc:	e0bffe17 	ldw	r2,-8(fp)
 90af1e0:	10800417 	ldw	r2,16(r2)
 90af1e4:	1080008c 	andi	r2,r2,2
 90af1e8:	1005003a 	cmpeq	r2,r2,zero
 90af1ec:	1000101e 	bne	r2,zero,90af230 <soclose+0xc4>
   {
      while (so->so_q0 != so)
 90af1f0:	00000306 	br	90af200 <soclose+0x94>
         (void) soabort(so->so_q0);
 90af1f4:	e0bffe17 	ldw	r2,-8(fp)
 90af1f8:	11001c17 	ldw	r4,112(r2)
 90af1fc:	90af4d40 	call	90af4d4 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 90af200:	e0bffe17 	ldw	r2,-8(fp)
 90af204:	10c01c17 	ldw	r3,112(r2)
 90af208:	e0bffe17 	ldw	r2,-8(fp)
 90af20c:	18bff91e 	bne	r3,r2,90af1f4 <soclose+0x88>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 90af210:	00000306 	br	90af220 <soclose+0xb4>
         (void) soabort(so->so_q);
 90af214:	e0bffe17 	ldw	r2,-8(fp)
 90af218:	11001d17 	ldw	r4,116(r2)
 90af21c:	90af4d40 	call	90af4d4 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 90af220:	e0bffe17 	ldw	r2,-8(fp)
 90af224:	10c01d17 	ldw	r3,116(r2)
 90af228:	e0bffe17 	ldw	r2,-8(fp)
 90af22c:	18bff91e 	bne	r3,r2,90af214 <soclose+0xa8>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 90af230:	e0bffe17 	ldw	r2,-8(fp)
 90af234:	10800983 	ldbu	r2,38(r2)
 90af238:	10803fcc 	andi	r2,r2,255
 90af23c:	1080201c 	xori	r2,r2,128
 90af240:	10bfe004 	addi	r2,r2,-128
 90af244:	10800060 	cmpeqi	r2,r2,1
 90af248:	10000c1e 	bne	r2,zero,90af27c <soclose+0x110>
   { 
      so->so_req = PRU_DETACH;
 90af24c:	e0fffe17 	ldw	r3,-8(fp)
 90af250:	00800044 	movi	r2,1
 90af254:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 90af258:	e0bffe17 	ldw	r2,-8(fp)
 90af25c:	10800217 	ldw	r2,8(r2)
 90af260:	10800317 	ldw	r2,12(r2)
 90af264:	e13ffe17 	ldw	r4,-8(fp)
 90af268:	000b883a 	mov	r5,zero
 90af26c:	000d883a 	mov	r6,zero
 90af270:	103ee83a 	callr	r2
 90af274:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 90af278:	00007c06 	br	90af46c <soclose+0x300>
   }

   if (so->so_pcb == 0)
 90af27c:	e0bffe17 	ldw	r2,-8(fp)
 90af280:	10800117 	ldw	r2,4(r2)
 90af284:	1005003a 	cmpeq	r2,r2,zero
 90af288:	1000781e 	bne	r2,zero,90af46c <soclose+0x300>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 90af28c:	e0bffe17 	ldw	r2,-8(fp)
 90af290:	1080088b 	ldhu	r2,34(r2)
 90af294:	10bfffcc 	andi	r2,r2,65535
 90af298:	1080008c 	andi	r2,r2,2
 90af29c:	1005003a 	cmpeq	r2,r2,zero
 90af2a0:	10005e1e 	bne	r2,zero,90af41c <soclose+0x2b0>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 90af2a4:	e0bffe17 	ldw	r2,-8(fp)
 90af2a8:	1080088b 	ldhu	r2,34(r2)
 90af2ac:	10bfffcc 	andi	r2,r2,65535
 90af2b0:	1080020c 	andi	r2,r2,8
 90af2b4:	1004c03a 	cmpne	r2,r2,zero
 90af2b8:	1000061e 	bne	r2,zero,90af2d4 <soclose+0x168>
      {
         error = sodisconnect(so);
 90af2bc:	e13ffe17 	ldw	r4,-8(fp)
 90af2c0:	90af6940 	call	90af694 <sodisconnect>
 90af2c4:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 90af2c8:	e0bffd17 	ldw	r2,-12(fp)
 90af2cc:	1004c03a 	cmpne	r2,r2,zero
 90af2d0:	1000521e 	bne	r2,zero,90af41c <soclose+0x2b0>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 90af2d4:	e0bffe17 	ldw	r2,-8(fp)
 90af2d8:	10800417 	ldw	r2,16(r2)
 90af2dc:	1080200c 	andi	r2,r2,128
 90af2e0:	1005003a 	cmpeq	r2,r2,zero
 90af2e4:	1000411e 	bne	r2,zero,90af3ec <soclose+0x280>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 90af2e8:	e0bffe17 	ldw	r2,-8(fp)
 90af2ec:	1080088b 	ldhu	r2,34(r2)
 90af2f0:	10bfffcc 	andi	r2,r2,65535
 90af2f4:	1080020c 	andi	r2,r2,8
 90af2f8:	1005003a 	cmpeq	r2,r2,zero
 90af2fc:	1000061e 	bne	r2,zero,90af318 <soclose+0x1ac>
 90af300:	e0bffe17 	ldw	r2,-8(fp)
 90af304:	1080088b 	ldhu	r2,34(r2)
 90af308:	10bfffcc 	andi	r2,r2,65535
 90af30c:	1080400c 	andi	r2,r2,256
 90af310:	1004c03a 	cmpne	r2,r2,zero
 90af314:	1000411e 	bne	r2,zero,90af41c <soclose+0x2b0>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 90af318:	00824374 	movhi	r2,2317
 90af31c:	108f2e04 	addi	r2,r2,15544
 90af320:	11000017 	ldw	r4,0(r2)
 90af324:	908d0380 	call	908d038 <__floatunsidf>
 90af328:	1021883a 	mov	r16,r2
 90af32c:	1823883a 	mov	r17,r3
 90af330:	e0bffe17 	ldw	r2,-8(fp)
 90af334:	1080080b 	ldhu	r2,32(r2)
 90af338:	113fffcc 	andi	r4,r2,65535
 90af33c:	2120001c 	xori	r4,r4,32768
 90af340:	21200004 	addi	r4,r4,-32768
 90af344:	908d0380 	call	908d038 <__floatunsidf>
 90af348:	100b883a 	mov	r5,r2
 90af34c:	180d883a 	mov	r6,r3
 90af350:	2809883a 	mov	r4,r5
 90af354:	300b883a 	mov	r5,r6
 90af358:	000d883a 	mov	r6,zero
 90af35c:	01d01674 	movhi	r7,16473
 90af360:	908c5b40 	call	908c5b4 <__muldf3>
 90af364:	1009883a 	mov	r4,r2
 90af368:	180b883a 	mov	r5,r3
 90af36c:	2005883a 	mov	r2,r4
 90af370:	2807883a 	mov	r3,r5
 90af374:	8009883a 	mov	r4,r16
 90af378:	880b883a 	mov	r5,r17
 90af37c:	100d883a 	mov	r6,r2
 90af380:	180f883a 	mov	r7,r3
 90af384:	908c5400 	call	908c540 <__adddf3>
 90af388:	1009883a 	mov	r4,r2
 90af38c:	180b883a 	mov	r5,r3
 90af390:	2005883a 	mov	r2,r4
 90af394:	2807883a 	mov	r3,r5
 90af398:	1009883a 	mov	r4,r2
 90af39c:	180b883a 	mov	r5,r3
 90af3a0:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90af3a4:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 90af3a8:	00000406 	br	90af3bc <soclose+0x250>
         {
            tcp_sleep((char *)&so->so_timeo);
 90af3ac:	e0bffe17 	ldw	r2,-8(fp)
 90af3b0:	10800904 	addi	r2,r2,36
 90af3b4:	1009883a 	mov	r4,r2
 90af3b8:	90a5cf40 	call	90a5cf4 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 90af3bc:	e0bffe17 	ldw	r2,-8(fp)
 90af3c0:	1080088b 	ldhu	r2,34(r2)
 90af3c4:	10bfffcc 	andi	r2,r2,65535
 90af3c8:	1080008c 	andi	r2,r2,2
 90af3cc:	1005003a 	cmpeq	r2,r2,zero
 90af3d0:	1000121e 	bne	r2,zero,90af41c <soclose+0x2b0>
 90af3d4:	00824374 	movhi	r2,2317
 90af3d8:	108f2e04 	addi	r2,r2,15544
 90af3dc:	10c00017 	ldw	r3,0(r2)
 90af3e0:	e0bffb17 	ldw	r2,-20(fp)
 90af3e4:	18bff136 	bltu	r3,r2,90af3ac <soclose+0x240>
 90af3e8:	00000c06 	br	90af41c <soclose+0x2b0>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 90af3ec:	e0bffe17 	ldw	r2,-8(fp)
 90af3f0:	10801217 	ldw	r2,72(r2)
 90af3f4:	1005003a 	cmpeq	r2,r2,zero
 90af3f8:	1000081e 	bne	r2,zero,90af41c <soclose+0x2b0>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 90af3fc:	e0bffe17 	ldw	r2,-8(fp)
 90af400:	1080088b 	ldhu	r2,34(r2)
 90af404:	10800054 	ori	r2,r2,1
 90af408:	1007883a 	mov	r3,r2
 90af40c:	e0bffe17 	ldw	r2,-8(fp)
 90af410:	10c0088d 	sth	r3,34(r2)
            return 0;
 90af414:	e03fff15 	stw	zero,-4(fp)
 90af418:	00002606 	br	90af4b4 <soclose+0x348>
         }
      }
   }
drop:
   if (so->so_pcb) 
 90af41c:	e0bffe17 	ldw	r2,-8(fp)
 90af420:	10800117 	ldw	r2,4(r2)
 90af424:	1005003a 	cmpeq	r2,r2,zero
 90af428:	1000101e 	bne	r2,zero,90af46c <soclose+0x300>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 90af42c:	e0fffe17 	ldw	r3,-8(fp)
 90af430:	00800044 	movi	r2,1
 90af434:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 90af438:	e0bffe17 	ldw	r2,-8(fp)
 90af43c:	10800217 	ldw	r2,8(r2)
 90af440:	10800317 	ldw	r2,12(r2)
 90af444:	e13ffe17 	ldw	r4,-8(fp)
 90af448:	000b883a 	mov	r5,zero
 90af44c:	000d883a 	mov	r6,zero
 90af450:	103ee83a 	callr	r2
 90af454:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 90af458:	e0bffd17 	ldw	r2,-12(fp)
 90af45c:	1004c03a 	cmpne	r2,r2,zero
 90af460:	1000021e 	bne	r2,zero,90af46c <soclose+0x300>
         error = error2;
 90af464:	e0bffa17 	ldw	r2,-24(fp)
 90af468:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 90af46c:	e0bffe17 	ldw	r2,-8(fp)
 90af470:	1080088b 	ldhu	r2,34(r2)
 90af474:	10bfffcc 	andi	r2,r2,65535
 90af478:	1080004c 	andi	r2,r2,1
 90af47c:	10803fcc 	andi	r2,r2,255
 90af480:	1005003a 	cmpeq	r2,r2,zero
 90af484:	1000011e 	bne	r2,zero,90af48c <soclose+0x320>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 90af488:	90aa4780 	call	90aa478 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 90af48c:	e0bffe17 	ldw	r2,-8(fp)
 90af490:	1080088b 	ldhu	r2,34(r2)
 90af494:	10800054 	ori	r2,r2,1
 90af498:	1007883a 	mov	r3,r2
 90af49c:	e0bffe17 	ldw	r2,-8(fp)
 90af4a0:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 90af4a4:	e13ffe17 	ldw	r4,-8(fp)
 90af4a8:	90af03c0 	call	90af03c <sofree>
   return (error);
 90af4ac:	e0bffd17 	ldw	r2,-12(fp)
 90af4b0:	e0bfff15 	stw	r2,-4(fp)
 90af4b4:	e0bfff17 	ldw	r2,-4(fp)
}
 90af4b8:	e037883a 	mov	sp,fp
 90af4bc:	dfc00317 	ldw	ra,12(sp)
 90af4c0:	df000217 	ldw	fp,8(sp)
 90af4c4:	dc400117 	ldw	r17,4(sp)
 90af4c8:	dc000017 	ldw	r16,0(sp)
 90af4cc:	dec00404 	addi	sp,sp,16
 90af4d0:	f800283a 	ret

090af4d4 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 90af4d4:	defffd04 	addi	sp,sp,-12
 90af4d8:	dfc00215 	stw	ra,8(sp)
 90af4dc:	df000115 	stw	fp,4(sp)
 90af4e0:	df000104 	addi	fp,sp,4
 90af4e4:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 90af4e8:	e0ffff17 	ldw	r3,-4(fp)
 90af4ec:	00800284 	movi	r2,10
 90af4f0:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 90af4f4:	e0bfff17 	ldw	r2,-4(fp)
 90af4f8:	10800217 	ldw	r2,8(r2)
 90af4fc:	10800317 	ldw	r2,12(r2)
 90af500:	e13fff17 	ldw	r4,-4(fp)
 90af504:	000b883a 	mov	r5,zero
 90af508:	000d883a 	mov	r6,zero
 90af50c:	103ee83a 	callr	r2
}
 90af510:	e037883a 	mov	sp,fp
 90af514:	dfc00117 	ldw	ra,4(sp)
 90af518:	df000017 	ldw	fp,0(sp)
 90af51c:	dec00204 	addi	sp,sp,8
 90af520:	f800283a 	ret

090af524 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 90af524:	defffb04 	addi	sp,sp,-20
 90af528:	dfc00415 	stw	ra,16(sp)
 90af52c:	df000315 	stw	fp,12(sp)
 90af530:	df000304 	addi	fp,sp,12
 90af534:	e13ffe15 	stw	r4,-8(fp)
 90af538:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 90af53c:	e0bffe17 	ldw	r2,-8(fp)
 90af540:	1080088b 	ldhu	r2,34(r2)
 90af544:	10bfffcc 	andi	r2,r2,65535
 90af548:	1080004c 	andi	r2,r2,1
 90af54c:	1004c03a 	cmpne	r2,r2,zero
 90af550:	1000031e 	bne	r2,zero,90af560 <soaccept+0x3c>
      panic("soaccept");
 90af554:	01024374 	movhi	r4,2317
 90af558:	21024204 	addi	r4,r4,2312
 90af55c:	90a537c0 	call	90a537c <panic>
   so->so_state &= ~SS_NOFDREF;
 90af560:	e0bffe17 	ldw	r2,-8(fp)
 90af564:	10c0088b 	ldhu	r3,34(r2)
 90af568:	00bfff84 	movi	r2,-2
 90af56c:	1884703a 	and	r2,r3,r2
 90af570:	1007883a 	mov	r3,r2
 90af574:	e0bffe17 	ldw	r2,-8(fp)
 90af578:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 90af57c:	e0fffe17 	ldw	r3,-8(fp)
 90af580:	00800144 	movi	r2,5
 90af584:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90af588:	e0bffe17 	ldw	r2,-8(fp)
 90af58c:	10800217 	ldw	r2,8(r2)
 90af590:	10800317 	ldw	r2,12(r2)
 90af594:	e13ffe17 	ldw	r4,-8(fp)
 90af598:	000b883a 	mov	r5,zero
 90af59c:	e1bfff17 	ldw	r6,-4(fp)
 90af5a0:	103ee83a 	callr	r2
 90af5a4:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 90af5a8:	e0bffd17 	ldw	r2,-12(fp)
}
 90af5ac:	e037883a 	mov	sp,fp
 90af5b0:	dfc00117 	ldw	ra,4(sp)
 90af5b4:	df000017 	ldw	fp,0(sp)
 90af5b8:	dec00204 	addi	sp,sp,8
 90af5bc:	f800283a 	ret

090af5c0 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 90af5c0:	defffa04 	addi	sp,sp,-24
 90af5c4:	dfc00515 	stw	ra,20(sp)
 90af5c8:	df000415 	stw	fp,16(sp)
 90af5cc:	df000404 	addi	fp,sp,16
 90af5d0:	e13ffd15 	stw	r4,-12(fp)
 90af5d4:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 90af5d8:	e0bffd17 	ldw	r2,-12(fp)
 90af5dc:	10800417 	ldw	r2,16(r2)
 90af5e0:	1080008c 	andi	r2,r2,2
 90af5e4:	1005003a 	cmpeq	r2,r2,zero
 90af5e8:	1000031e 	bne	r2,zero,90af5f8 <soconnect+0x38>
      return (EOPNOTSUPP);
 90af5ec:	008017c4 	movi	r2,95
 90af5f0:	e0bfff15 	stw	r2,-4(fp)
 90af5f4:	00002106 	br	90af67c <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 90af5f8:	e0bffd17 	ldw	r2,-12(fp)
 90af5fc:	1080088b 	ldhu	r2,34(r2)
 90af600:	10bfffcc 	andi	r2,r2,65535
 90af604:	1080018c 	andi	r2,r2,6
 90af608:	1005003a 	cmpeq	r2,r2,zero
 90af60c:	10000e1e 	bne	r2,zero,90af648 <soconnect+0x88>
 90af610:	e0bffd17 	ldw	r2,-12(fp)
 90af614:	10800217 	ldw	r2,8(r2)
 90af618:	1080010b 	ldhu	r2,4(r2)
 90af61c:	10bfffcc 	andi	r2,r2,65535
 90af620:	1080010c 	andi	r2,r2,4
 90af624:	1004c03a 	cmpne	r2,r2,zero
 90af628:	1000041e 	bne	r2,zero,90af63c <soconnect+0x7c>
 90af62c:	e13ffd17 	ldw	r4,-12(fp)
 90af630:	90af6940 	call	90af694 <sodisconnect>
 90af634:	1005003a 	cmpeq	r2,r2,zero
 90af638:	1000031e 	bne	r2,zero,90af648 <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 90af63c:	00801fc4 	movi	r2,127
 90af640:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 90af644:	00000b06 	br	90af674 <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 90af648:	e0fffd17 	ldw	r3,-12(fp)
 90af64c:	00800104 	movi	r2,4
 90af650:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 90af654:	e0bffd17 	ldw	r2,-12(fp)
 90af658:	10800217 	ldw	r2,8(r2)
 90af65c:	10800317 	ldw	r2,12(r2)
 90af660:	e13ffd17 	ldw	r4,-12(fp)
 90af664:	000b883a 	mov	r5,zero
 90af668:	e1bffe17 	ldw	r6,-8(fp)
 90af66c:	103ee83a 	callr	r2
 90af670:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 90af674:	e0bffc17 	ldw	r2,-16(fp)
 90af678:	e0bfff15 	stw	r2,-4(fp)
 90af67c:	e0bfff17 	ldw	r2,-4(fp)
}
 90af680:	e037883a 	mov	sp,fp
 90af684:	dfc00117 	ldw	ra,4(sp)
 90af688:	df000017 	ldw	fp,0(sp)
 90af68c:	dec00204 	addi	sp,sp,8
 90af690:	f800283a 	ret

090af694 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 90af694:	defffc04 	addi	sp,sp,-16
 90af698:	dfc00315 	stw	ra,12(sp)
 90af69c:	df000215 	stw	fp,8(sp)
 90af6a0:	df000204 	addi	fp,sp,8
 90af6a4:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 90af6a8:	e0bfff17 	ldw	r2,-4(fp)
 90af6ac:	1080088b 	ldhu	r2,34(r2)
 90af6b0:	10bfffcc 	andi	r2,r2,65535
 90af6b4:	1080008c 	andi	r2,r2,2
 90af6b8:	1004c03a 	cmpne	r2,r2,zero
 90af6bc:	1000031e 	bne	r2,zero,90af6cc <sodisconnect+0x38>
   {
      error = ENOTCONN;
 90af6c0:	00802004 	movi	r2,128
 90af6c4:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 90af6c8:	00001406 	br	90af71c <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 90af6cc:	e0bfff17 	ldw	r2,-4(fp)
 90af6d0:	1080088b 	ldhu	r2,34(r2)
 90af6d4:	10bfffcc 	andi	r2,r2,65535
 90af6d8:	1080020c 	andi	r2,r2,8
 90af6dc:	1005003a 	cmpeq	r2,r2,zero
 90af6e0:	1000031e 	bne	r2,zero,90af6f0 <sodisconnect+0x5c>
   {
      error = EALREADY;
 90af6e4:	00801e04 	movi	r2,120
 90af6e8:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 90af6ec:	00000b06 	br	90af71c <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 90af6f0:	e0ffff17 	ldw	r3,-4(fp)
 90af6f4:	00800184 	movi	r2,6
 90af6f8:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 90af6fc:	e0bfff17 	ldw	r2,-4(fp)
 90af700:	10800217 	ldw	r2,8(r2)
 90af704:	10800317 	ldw	r2,12(r2)
 90af708:	e13fff17 	ldw	r4,-4(fp)
 90af70c:	000b883a 	mov	r5,zero
 90af710:	000d883a 	mov	r6,zero
 90af714:	103ee83a 	callr	r2
 90af718:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 90af71c:	e0bffe17 	ldw	r2,-8(fp)
}
 90af720:	e037883a 	mov	sp,fp
 90af724:	dfc00117 	ldw	ra,4(sp)
 90af728:	df000017 	ldw	fp,0(sp)
 90af72c:	dec00204 	addi	sp,sp,8
 90af730:	f800283a 	ret

090af734 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 90af734:	deffee04 	addi	sp,sp,-72
 90af738:	dfc01115 	stw	ra,68(sp)
 90af73c:	df001015 	stw	fp,64(sp)
 90af740:	df001004 	addi	fp,sp,64
 90af744:	e13ff815 	stw	r4,-32(fp)
 90af748:	e17ff915 	stw	r5,-28(fp)
 90af74c:	e1bffa15 	stw	r6,-24(fp)
 90af750:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 90af754:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 90af758:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 90af75c:	00800044 	movi	r2,1
 90af760:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 90af764:	e0bffb17 	ldw	r2,-20(fp)
 90af768:	10800017 	ldw	r2,0(r2)
 90af76c:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 90af770:	e0bff417 	ldw	r2,-48(fp)
 90af774:	1004403a 	cmpge	r2,r2,zero
 90af778:	1000031e 	bne	r2,zero,90af788 <sosend+0x54>
      return (EINVAL);
 90af77c:	00800584 	movi	r2,22
 90af780:	e0bfff15 	stw	r2,-4(fp)
 90af784:	00016706 	br	90afd24 <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 90af788:	e0bff817 	ldw	r2,-32(fp)
 90af78c:	10800217 	ldw	r2,8(r2)
 90af790:	1080010b 	ldhu	r2,4(r2)
 90af794:	10bfffcc 	andi	r2,r2,65535
 90af798:	1080004c 	andi	r2,r2,1
 90af79c:	10803fcc 	andi	r2,r2,255
 90af7a0:	1005003a 	cmpeq	r2,r2,zero
 90af7a4:	1000081e 	bne	r2,zero,90af7c8 <sosend+0x94>
 90af7a8:	e0bff817 	ldw	r2,-32(fp)
 90af7ac:	10801317 	ldw	r2,76(r2)
 90af7b0:	1007883a 	mov	r3,r2
 90af7b4:	e0bff417 	ldw	r2,-48(fp)
 90af7b8:	1880030e 	bge	r3,r2,90af7c8 <sosend+0x94>
      return (EMSGSIZE);
 90af7bc:	00c01e84 	movi	r3,122
 90af7c0:	e0ffff15 	stw	r3,-4(fp)
 90af7c4:	00015706 	br	90afd24 <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 90af7c8:	e0800217 	ldw	r2,8(fp)
 90af7cc:	1080010c 	andi	r2,r2,4
 90af7d0:	1005003a 	cmpeq	r2,r2,zero
 90af7d4:	1000111e 	bne	r2,zero,90af81c <sosend+0xe8>
 90af7d8:	e0bff817 	ldw	r2,-32(fp)
 90af7dc:	10800417 	ldw	r2,16(r2)
 90af7e0:	1080040c 	andi	r2,r2,16
 90af7e4:	1004c03a 	cmpne	r2,r2,zero
 90af7e8:	10000c1e 	bne	r2,zero,90af81c <sosend+0xe8>
 90af7ec:	e0bff817 	ldw	r2,-32(fp)
 90af7f0:	10800217 	ldw	r2,8(r2)
 90af7f4:	1080010b 	ldhu	r2,4(r2)
 90af7f8:	10bfffcc 	andi	r2,r2,65535
 90af7fc:	1080004c 	andi	r2,r2,1
 90af800:	1080005c 	xori	r2,r2,1
 90af804:	10803fcc 	andi	r2,r2,255
 90af808:	1004c03a 	cmpne	r2,r2,zero
 90af80c:	1000031e 	bne	r2,zero,90af81c <sosend+0xe8>
 90af810:	00800044 	movi	r2,1
 90af814:	e0bffe15 	stw	r2,-8(fp)
 90af818:	00000106 	br	90af820 <sosend+0xec>
 90af81c:	e03ffe15 	stw	zero,-8(fp)
 90af820:	e0fffe17 	ldw	r3,-8(fp)
 90af824:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 90af828:	00000406 	br	90af83c <sosend+0x108>
 90af82c:	e0bff817 	ldw	r2,-32(fp)
 90af830:	10801904 	addi	r2,r2,100
 90af834:	1009883a 	mov	r4,r2
 90af838:	90a5cf40 	call	90a5cf4 <tcp_sleep>
 90af83c:	e0bff817 	ldw	r2,-32(fp)
 90af840:	1080190b 	ldhu	r2,100(r2)
 90af844:	10bfffcc 	andi	r2,r2,65535
 90af848:	1080004c 	andi	r2,r2,1
 90af84c:	10803fcc 	andi	r2,r2,255
 90af850:	1004c03a 	cmpne	r2,r2,zero
 90af854:	103ff51e 	bne	r2,zero,90af82c <sosend+0xf8>
 90af858:	e0bff817 	ldw	r2,-32(fp)
 90af85c:	1080190b 	ldhu	r2,100(r2)
 90af860:	10800054 	ori	r2,r2,1
 90af864:	1007883a 	mov	r3,r2
 90af868:	e0bff817 	ldw	r2,-32(fp)
 90af86c:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 90af870:	e0bff817 	ldw	r2,-32(fp)
 90af874:	10800617 	ldw	r2,24(r2)
 90af878:	1005003a 	cmpeq	r2,r2,zero
 90af87c:	1000061e 	bne	r2,zero,90af898 <sosend+0x164>
      {
         error = so->so_error;
 90af880:	e0bff817 	ldw	r2,-32(fp)
 90af884:	10800617 	ldw	r2,24(r2)
 90af888:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 90af88c:	e0bff817 	ldw	r2,-32(fp)
 90af890:	10000615 	stw	zero,24(r2)
         goto release;
 90af894:	00011106 	br	90afcdc <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 90af898:	e0bff817 	ldw	r2,-32(fp)
 90af89c:	1080088b 	ldhu	r2,34(r2)
 90af8a0:	10bfffcc 	andi	r2,r2,65535
 90af8a4:	1080040c 	andi	r2,r2,16
 90af8a8:	1005003a 	cmpeq	r2,r2,zero
 90af8ac:	1000031e 	bne	r2,zero,90af8bc <sosend+0x188>
         snderr(EPIPE);
 90af8b0:	00800804 	movi	r2,32
 90af8b4:	e0bff215 	stw	r2,-56(fp)
 90af8b8:	00010806 	br	90afcdc <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 90af8bc:	e0bff817 	ldw	r2,-32(fp)
 90af8c0:	1080088b 	ldhu	r2,34(r2)
 90af8c4:	10bfffcc 	andi	r2,r2,65535
 90af8c8:	1080008c 	andi	r2,r2,2
 90af8cc:	1004c03a 	cmpne	r2,r2,zero
 90af8d0:	1000101e 	bne	r2,zero,90af914 <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 90af8d4:	e0bff817 	ldw	r2,-32(fp)
 90af8d8:	10800217 	ldw	r2,8(r2)
 90af8dc:	1080010b 	ldhu	r2,4(r2)
 90af8e0:	10bfffcc 	andi	r2,r2,65535
 90af8e4:	1080010c 	andi	r2,r2,4
 90af8e8:	1005003a 	cmpeq	r2,r2,zero
 90af8ec:	1000031e 	bne	r2,zero,90af8fc <sosend+0x1c8>
            snderr(ENOTCONN);
 90af8f0:	00802004 	movi	r2,128
 90af8f4:	e0bff215 	stw	r2,-56(fp)
 90af8f8:	0000f806 	br	90afcdc <sosend+0x5a8>
         if (nam == 0)
 90af8fc:	e0bff917 	ldw	r2,-28(fp)
 90af900:	1004c03a 	cmpne	r2,r2,zero
 90af904:	1000031e 	bne	r2,zero,90af914 <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 90af908:	00801e44 	movi	r2,121
 90af90c:	e0bff215 	stw	r2,-56(fp)
 90af910:	0000f206 	br	90afcdc <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 90af914:	e0800217 	ldw	r2,8(fp)
 90af918:	1080004c 	andi	r2,r2,1
 90af91c:	10803fcc 	andi	r2,r2,255
 90af920:	1005003a 	cmpeq	r2,r2,zero
 90af924:	1000031e 	bne	r2,zero,90af934 <sosend+0x200>
         space = 1024;
 90af928:	00810004 	movi	r2,1024
 90af92c:	e0bff515 	stw	r2,-44(fp)
 90af930:	00005106 	br	90afa78 <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 90af934:	e0bff817 	ldw	r2,-32(fp)
 90af938:	10801317 	ldw	r2,76(r2)
 90af93c:	1007883a 	mov	r3,r2
 90af940:	e0bff817 	ldw	r2,-32(fp)
 90af944:	10801217 	ldw	r2,72(r2)
 90af948:	1885c83a 	sub	r2,r3,r2
 90af94c:	1004803a 	cmplt	r2,r2,zero
 90af950:	1000071e 	bne	r2,zero,90af970 <sosend+0x23c>
 90af954:	e0bff817 	ldw	r2,-32(fp)
 90af958:	10c01317 	ldw	r3,76(r2)
 90af95c:	e0bff817 	ldw	r2,-32(fp)
 90af960:	10801217 	ldw	r2,72(r2)
 90af964:	1885c83a 	sub	r2,r3,r2
 90af968:	e0bffd15 	stw	r2,-12(fp)
 90af96c:	00000106 	br	90af974 <sosend+0x240>
 90af970:	e03ffd15 	stw	zero,-12(fp)
 90af974:	e0bffd17 	ldw	r2,-12(fp)
 90af978:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 90af97c:	e0bff817 	ldw	r2,-32(fp)
 90af980:	10800217 	ldw	r2,8(r2)
 90af984:	1080010b 	ldhu	r2,4(r2)
 90af988:	10bfffcc 	andi	r2,r2,65535
 90af98c:	1080004c 	andi	r2,r2,1
 90af990:	1080005c 	xori	r2,r2,1
 90af994:	10803fcc 	andi	r2,r2,255
 90af998:	1004c03a 	cmpne	r2,r2,zero
 90af99c:	1000031e 	bne	r2,zero,90af9ac <sosend+0x278>
 90af9a0:	e0fff517 	ldw	r3,-44(fp)
 90af9a4:	e0bff417 	ldw	r2,-48(fp)
 90af9a8:	18801416 	blt	r3,r2,90af9fc <sosend+0x2c8>
 90af9ac:	e0bff417 	ldw	r2,-48(fp)
 90af9b0:	10815e10 	cmplti	r2,r2,1400
 90af9b4:	1000301e 	bne	r2,zero,90afa78 <sosend+0x344>
 90af9b8:	e0bff517 	ldw	r2,-44(fp)
 90af9bc:	10815e08 	cmpgei	r2,r2,1400
 90af9c0:	10002d1e 	bne	r2,zero,90afa78 <sosend+0x344>
 90af9c4:	e0bff817 	ldw	r2,-32(fp)
 90af9c8:	10801217 	ldw	r2,72(r2)
 90af9cc:	10815e30 	cmpltui	r2,r2,1400
 90af9d0:	1000291e 	bne	r2,zero,90afa78 <sosend+0x344>
 90af9d4:	e0bff817 	ldw	r2,-32(fp)
 90af9d8:	1080088b 	ldhu	r2,34(r2)
 90af9dc:	10bfffcc 	andi	r2,r2,65535
 90af9e0:	1080400c 	andi	r2,r2,256
 90af9e4:	1004c03a 	cmpne	r2,r2,zero
 90af9e8:	1000231e 	bne	r2,zero,90afa78 <sosend+0x344>
 90af9ec:	e0800217 	ldw	r2,8(fp)
 90af9f0:	1080080c 	andi	r2,r2,32
 90af9f4:	1004c03a 	cmpne	r2,r2,zero
 90af9f8:	10001f1e 	bne	r2,zero,90afa78 <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 90af9fc:	e0bff817 	ldw	r2,-32(fp)
 90afa00:	1080088b 	ldhu	r2,34(r2)
 90afa04:	10bfffcc 	andi	r2,r2,65535
 90afa08:	1080400c 	andi	r2,r2,256
 90afa0c:	1004c03a 	cmpne	r2,r2,zero
 90afa10:	1000041e 	bne	r2,zero,90afa24 <sosend+0x2f0>
 90afa14:	e0800217 	ldw	r2,8(fp)
 90afa18:	1080080c 	andi	r2,r2,32
 90afa1c:	1005003a 	cmpeq	r2,r2,zero
 90afa20:	1000061e 	bne	r2,zero,90afa3c <sosend+0x308>
            {
               if (first)
 90afa24:	e0bff017 	ldw	r2,-64(fp)
 90afa28:	1005003a 	cmpeq	r2,r2,zero
 90afa2c:	1000ab1e 	bne	r2,zero,90afcdc <sosend+0x5a8>
                  error = EWOULDBLOCK;
 90afa30:	008002c4 	movi	r2,11
 90afa34:	e0bff215 	stw	r2,-56(fp)
               goto release;
 90afa38:	0000a806 	br	90afcdc <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 90afa3c:	e0bff817 	ldw	r2,-32(fp)
 90afa40:	10c0190b 	ldhu	r3,100(r2)
 90afa44:	00bfff84 	movi	r2,-2
 90afa48:	1884703a 	and	r2,r3,r2
 90afa4c:	1007883a 	mov	r3,r2
 90afa50:	e0bff817 	ldw	r2,-32(fp)
 90afa54:	10c0190d 	sth	r3,100(r2)
 90afa58:	e0bff817 	ldw	r2,-32(fp)
 90afa5c:	10801904 	addi	r2,r2,100
 90afa60:	1009883a 	mov	r4,r2
 90afa64:	90a5e940 	call	90a5e94 <tcp_wakeup>
            sbwait(&so->so_snd);
 90afa68:	e0bff817 	ldw	r2,-32(fp)
 90afa6c:	11001204 	addi	r4,r2,72
 90afa70:	90b187c0 	call	90b187c <sbwait>
            goto restart;
 90afa74:	003f7106 	br	90af83c <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 90afa78:	e0bff517 	ldw	r2,-44(fp)
 90afa7c:	10800048 	cmpgei	r2,r2,1
 90afa80:	1000651e 	bne	r2,zero,90afc18 <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 90afa84:	e0bff817 	ldw	r2,-32(fp)
 90afa88:	1080088b 	ldhu	r2,34(r2)
 90afa8c:	10bfffcc 	andi	r2,r2,65535
 90afa90:	1080400c 	andi	r2,r2,256
 90afa94:	1004c03a 	cmpne	r2,r2,zero
 90afa98:	1000041e 	bne	r2,zero,90afaac <sosend+0x378>
 90afa9c:	e0800217 	ldw	r2,8(fp)
 90afaa0:	1080080c 	andi	r2,r2,32
 90afaa4:	1005003a 	cmpeq	r2,r2,zero
 90afaa8:	1000061e 	bne	r2,zero,90afac4 <sosend+0x390>
         {
            if (first)     /* report first error */
 90afaac:	e0bff017 	ldw	r2,-64(fp)
 90afab0:	1005003a 	cmpeq	r2,r2,zero
 90afab4:	1000891e 	bne	r2,zero,90afcdc <sosend+0x5a8>
               error = EWOULDBLOCK;
 90afab8:	008002c4 	movi	r2,11
 90afabc:	e0bff215 	stw	r2,-56(fp)
            goto release;
 90afac0:	00008606 	br	90afcdc <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 90afac4:	e0bff817 	ldw	r2,-32(fp)
 90afac8:	10c0190b 	ldhu	r3,100(r2)
 90afacc:	00bfff84 	movi	r2,-2
 90afad0:	1884703a 	and	r2,r3,r2
 90afad4:	1007883a 	mov	r3,r2
 90afad8:	e0bff817 	ldw	r2,-32(fp)
 90afadc:	10c0190d 	sth	r3,100(r2)
 90afae0:	e0bff817 	ldw	r2,-32(fp)
 90afae4:	10801904 	addi	r2,r2,100
 90afae8:	1009883a 	mov	r4,r2
 90afaec:	90a5e940 	call	90a5e94 <tcp_wakeup>
         sbwait(&so->so_snd);
 90afaf0:	e0bff817 	ldw	r2,-32(fp)
 90afaf4:	11001204 	addi	r4,r2,72
 90afaf8:	90b187c0 	call	90b187c <sbwait>
         goto restart;
 90afafc:	003f4f06 	br	90af83c <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 90afb00:	e0bff417 	ldw	r2,-48(fp)
 90afb04:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 90afb08:	e0bff817 	ldw	r2,-32(fp)
 90afb0c:	10800983 	ldbu	r2,38(r2)
 90afb10:	10803fcc 	andi	r2,r2,255
 90afb14:	1080201c 	xori	r2,r2,128
 90afb18:	10bfe004 	addi	r2,r2,-128
 90afb1c:	10800058 	cmpnei	r2,r2,1
 90afb20:	1000181e 	bne	r2,zero,90afb84 <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 90afb24:	01000084 	movi	r4,2
 90afb28:	e17ff317 	ldw	r5,-52(fp)
 90afb2c:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90afb30:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 90afb34:	e0bff617 	ldw	r2,-40(fp)
 90afb38:	1004c03a 	cmpne	r2,r2,zero
 90afb3c:	1000031e 	bne	r2,zero,90afb4c <sosend+0x418>
               snderr(ENOBUFS);
 90afb40:	00801a44 	movi	r2,105
 90afb44:	e0bff215 	stw	r2,-56(fp)
 90afb48:	00006406 	br	90afcdc <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 90afb4c:	e0bff617 	ldw	r2,-40(fp)
 90afb50:	10c00317 	ldw	r3,12(r2)
 90afb54:	e1bff317 	ldw	r6,-52(fp)
 90afb58:	e0bffa17 	ldw	r2,-24(fp)
 90afb5c:	1809883a 	mov	r4,r3
 90afb60:	100b883a 	mov	r5,r2
 90afb64:	90894600 	call	9089460 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 90afb68:	e0bff817 	ldw	r2,-32(fp)
 90afb6c:	1080190b 	ldhu	r2,100(r2)
 90afb70:	10802014 	ori	r2,r2,128
 90afb74:	1007883a 	mov	r3,r2
 90afb78:	e0bff817 	ldw	r2,-32(fp)
 90afb7c:	10c0190d 	sth	r3,100(r2)
 90afb80:	00000706 	br	90afba0 <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 90afb84:	01000084 	movi	r4,2
 90afb88:	000b883a 	mov	r5,zero
 90afb8c:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90afb90:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 90afb94:	e0fff617 	ldw	r3,-40(fp)
 90afb98:	e0bffa17 	ldw	r2,-24(fp)
 90afb9c:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 90afba0:	e0bffb17 	ldw	r2,-20(fp)
 90afba4:	10c00017 	ldw	r3,0(r2)
 90afba8:	e0bff317 	ldw	r2,-52(fp)
 90afbac:	1887c83a 	sub	r3,r3,r2
 90afbb0:	e0bffb17 	ldw	r2,-20(fp)
 90afbb4:	10c00015 	stw	r3,0(r2)
         resid -= len;
 90afbb8:	e0fff417 	ldw	r3,-48(fp)
 90afbbc:	e0bff317 	ldw	r2,-52(fp)
 90afbc0:	1885c83a 	sub	r2,r3,r2
 90afbc4:	e0bff415 	stw	r2,-48(fp)
         data += len;
 90afbc8:	e0bff317 	ldw	r2,-52(fp)
 90afbcc:	1007883a 	mov	r3,r2
 90afbd0:	e0bffa17 	ldw	r2,-24(fp)
 90afbd4:	10c5883a 	add	r2,r2,r3
 90afbd8:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 90afbdc:	e0fff317 	ldw	r3,-52(fp)
 90afbe0:	e0bff617 	ldw	r2,-40(fp)
 90afbe4:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 90afbe8:	e0bff717 	ldw	r2,-36(fp)
 90afbec:	1004c03a 	cmpne	r2,r2,zero
 90afbf0:	1000021e 	bne	r2,zero,90afbfc <sosend+0x4c8>
            head = m;
 90afbf4:	e0bff617 	ldw	r2,-40(fp)
 90afbf8:	e0bff715 	stw	r2,-36(fp)
         if (error)
 90afbfc:	e0bff217 	ldw	r2,-56(fp)
 90afc00:	1004c03a 	cmpne	r2,r2,zero
 90afc04:	1000351e 	bne	r2,zero,90afcdc <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 90afc08:	e0bffb17 	ldw	r2,-20(fp)
 90afc0c:	10800017 	ldw	r2,0(r2)
 90afc10:	10800050 	cmplti	r2,r2,1
 90afc14:	1000031e 	bne	r2,zero,90afc24 <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 90afc18:	e0bff517 	ldw	r2,-44(fp)
 90afc1c:	10800048 	cmpgei	r2,r2,1
 90afc20:	103fb71e 	bne	r2,zero,90afb00 <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 90afc24:	e0bff117 	ldw	r2,-60(fp)
 90afc28:	1005003a 	cmpeq	r2,r2,zero
 90afc2c:	1000051e 	bne	r2,zero,90afc44 <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 90afc30:	e0bff817 	ldw	r2,-32(fp)
 90afc34:	10800417 	ldw	r2,16(r2)
 90afc38:	10c00414 	ori	r3,r2,16
 90afc3c:	e0bff817 	ldw	r2,-32(fp)
 90afc40:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 90afc44:	e0800217 	ldw	r2,8(fp)
 90afc48:	1080004c 	andi	r2,r2,1
 90afc4c:	10803fcc 	andi	r2,r2,255
 90afc50:	1005003a 	cmpeq	r2,r2,zero
 90afc54:	1000031e 	bne	r2,zero,90afc64 <sosend+0x530>
 90afc58:	00c00384 	movi	r3,14
 90afc5c:	e0fffc15 	stw	r3,-16(fp)
 90afc60:	00000206 	br	90afc6c <sosend+0x538>
 90afc64:	00800244 	movi	r2,9
 90afc68:	e0bffc15 	stw	r2,-16(fp)
 90afc6c:	e0bff817 	ldw	r2,-32(fp)
 90afc70:	e0fffc17 	ldw	r3,-16(fp)
 90afc74:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 90afc78:	e0bff817 	ldw	r2,-32(fp)
 90afc7c:	10800217 	ldw	r2,8(r2)
 90afc80:	10800317 	ldw	r2,12(r2)
 90afc84:	e13ff817 	ldw	r4,-32(fp)
 90afc88:	e17ff717 	ldw	r5,-36(fp)
 90afc8c:	e1bff917 	ldw	r6,-28(fp)
 90afc90:	103ee83a 	callr	r2
 90afc94:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 90afc98:	e0bff117 	ldw	r2,-60(fp)
 90afc9c:	1005003a 	cmpeq	r2,r2,zero
 90afca0:	1000061e 	bne	r2,zero,90afcbc <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 90afca4:	e0bff817 	ldw	r2,-32(fp)
 90afca8:	10c00417 	ldw	r3,16(r2)
 90afcac:	00bffbc4 	movi	r2,-17
 90afcb0:	1886703a 	and	r3,r3,r2
 90afcb4:	e0bff817 	ldw	r2,-32(fp)
 90afcb8:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 90afcbc:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 90afcc0:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 90afcc4:	e0bff417 	ldw	r2,-48(fp)
 90afcc8:	1005003a 	cmpeq	r2,r2,zero
 90afccc:	1000031e 	bne	r2,zero,90afcdc <sosend+0x5a8>
 90afcd0:	e0bff217 	ldw	r2,-56(fp)
 90afcd4:	1005003a 	cmpeq	r2,r2,zero
 90afcd8:	103ee51e 	bne	r2,zero,90af870 <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 90afcdc:	e0bff817 	ldw	r2,-32(fp)
 90afce0:	10c0190b 	ldhu	r3,100(r2)
 90afce4:	00bfff84 	movi	r2,-2
 90afce8:	1884703a 	and	r2,r3,r2
 90afcec:	1007883a 	mov	r3,r2
 90afcf0:	e0bff817 	ldw	r2,-32(fp)
 90afcf4:	10c0190d 	sth	r3,100(r2)
 90afcf8:	e0bff817 	ldw	r2,-32(fp)
 90afcfc:	10801904 	addi	r2,r2,100
 90afd00:	1009883a 	mov	r4,r2
 90afd04:	90a5e940 	call	90a5e94 <tcp_wakeup>
   if (head)
 90afd08:	e0bff717 	ldw	r2,-36(fp)
 90afd0c:	1005003a 	cmpeq	r2,r2,zero
 90afd10:	1000021e 	bne	r2,zero,90afd1c <sosend+0x5e8>
      m_freem(head);
 90afd14:	e13ff717 	ldw	r4,-36(fp)
 90afd18:	90ab5940 	call	90ab594 <m_freem>
   return error;
 90afd1c:	e0bff217 	ldw	r2,-56(fp)
 90afd20:	e0bfff15 	stw	r2,-4(fp)
 90afd24:	e0bfff17 	ldw	r2,-4(fp)
}
 90afd28:	e037883a 	mov	sp,fp
 90afd2c:	dfc00117 	ldw	ra,4(sp)
 90afd30:	df000017 	ldw	fp,0(sp)
 90afd34:	dec00204 	addi	sp,sp,8
 90afd38:	f800283a 	ret

090afd3c <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 90afd3c:	defff104 	addi	sp,sp,-60
 90afd40:	dfc00e15 	stw	ra,56(sp)
 90afd44:	df000d15 	stw	fp,52(sp)
 90afd48:	df000d04 	addi	fp,sp,52
 90afd4c:	e13ffb15 	stw	r4,-20(fp)
 90afd50:	e17ffc15 	stw	r5,-16(fp)
 90afd54:	e1bffd15 	stw	r6,-12(fp)
 90afd58:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 90afd5c:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 90afd60:	e0bffb17 	ldw	r2,-20(fp)
 90afd64:	10800217 	ldw	r2,8(r2)
 90afd68:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 90afd6c:	e0bffc17 	ldw	r2,-16(fp)
 90afd70:	1005003a 	cmpeq	r2,r2,zero
 90afd74:	1000021e 	bne	r2,zero,90afd80 <soreceive+0x44>
      *aname = 0;
 90afd78:	e0bffc17 	ldw	r2,-16(fp)
 90afd7c:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 90afd80:	e0800217 	ldw	r2,8(fp)
 90afd84:	1080004c 	andi	r2,r2,1
 90afd88:	10803fcc 	andi	r2,r2,255
 90afd8c:	1005003a 	cmpeq	r2,r2,zero
 90afd90:	10004d1e 	bne	r2,zero,90afec8 <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 90afd94:	01000044 	movi	r4,1
 90afd98:	000b883a 	mov	r5,zero
 90afd9c:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90afda0:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 90afda4:	e0bffa17 	ldw	r2,-24(fp)
 90afda8:	1004c03a 	cmpne	r2,r2,zero
 90afdac:	1000031e 	bne	r2,zero,90afdbc <soreceive+0x80>
         return ENOBUFS;
 90afdb0:	00801a44 	movi	r2,105
 90afdb4:	e0bfff15 	stw	r2,-4(fp)
 90afdb8:	0001d306 	br	90b0508 <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 90afdbc:	e0800217 	ldw	r2,8(fp)
 90afdc0:	1080008c 	andi	r2,r2,2
 90afdc4:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 90afdc8:	e0fffb17 	ldw	r3,-20(fp)
 90afdcc:	00800344 	movi	r2,13
 90afdd0:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 90afdd4:	e0bff617 	ldw	r2,-40(fp)
 90afdd8:	10800317 	ldw	r2,12(r2)
 90afddc:	e1bff317 	ldw	r6,-52(fp)
 90afde0:	e13ffb17 	ldw	r4,-20(fp)
 90afde4:	e17ffa17 	ldw	r5,-24(fp)
 90afde8:	103ee83a 	callr	r2
 90afdec:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 90afdf0:	e0bff817 	ldw	r2,-32(fp)
 90afdf4:	1004c03a 	cmpne	r2,r2,zero
 90afdf8:	1000271e 	bne	r2,zero,90afe98 <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 90afdfc:	e0bffe17 	ldw	r2,-8(fp)
 90afe00:	10800017 	ldw	r2,0(r2)
 90afe04:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 90afe08:	e0bffa17 	ldw	r2,-24(fp)
 90afe0c:	10800217 	ldw	r2,8(r2)
 90afe10:	1007883a 	mov	r3,r2
 90afe14:	e0bff917 	ldw	r2,-28(fp)
 90afe18:	1880030e 	bge	r3,r2,90afe28 <soreceive+0xec>
               len = m->m_len;
 90afe1c:	e0bffa17 	ldw	r2,-24(fp)
 90afe20:	10800217 	ldw	r2,8(r2)
 90afe24:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 90afe28:	e0bffa17 	ldw	r2,-24(fp)
 90afe2c:	10c00317 	ldw	r3,12(r2)
 90afe30:	e1bff917 	ldw	r6,-28(fp)
 90afe34:	e0bffd17 	ldw	r2,-12(fp)
 90afe38:	1009883a 	mov	r4,r2
 90afe3c:	180b883a 	mov	r5,r3
 90afe40:	90894600 	call	9089460 <memcpy>
            data += len;
 90afe44:	e0bff917 	ldw	r2,-28(fp)
 90afe48:	1007883a 	mov	r3,r2
 90afe4c:	e0bffd17 	ldw	r2,-12(fp)
 90afe50:	10c5883a 	add	r2,r2,r3
 90afe54:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 90afe58:	e0fffe17 	ldw	r3,-8(fp)
 90afe5c:	e0bff917 	ldw	r2,-28(fp)
 90afe60:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 90afe64:	e13ffa17 	ldw	r4,-24(fp)
 90afe68:	90ab4600 	call	90ab460 <m_free>
 90afe6c:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 90afe70:	e0bffe17 	ldw	r2,-8(fp)
 90afe74:	10800017 	ldw	r2,0(r2)
 90afe78:	1005003a 	cmpeq	r2,r2,zero
 90afe7c:	1000061e 	bne	r2,zero,90afe98 <soreceive+0x15c>
 90afe80:	e0bff817 	ldw	r2,-32(fp)
 90afe84:	1004c03a 	cmpne	r2,r2,zero
 90afe88:	1000031e 	bne	r2,zero,90afe98 <soreceive+0x15c>
 90afe8c:	e0bffa17 	ldw	r2,-24(fp)
 90afe90:	1004c03a 	cmpne	r2,r2,zero
 90afe94:	103fd91e 	bne	r2,zero,90afdfc <soreceive+0xc0>
      }

      if (m)
 90afe98:	e0bffa17 	ldw	r2,-24(fp)
 90afe9c:	1005003a 	cmpeq	r2,r2,zero
 90afea0:	1000021e 	bne	r2,zero,90afeac <soreceive+0x170>
         m_freem(m);
 90afea4:	e13ffa17 	ldw	r4,-24(fp)
 90afea8:	90ab5940 	call	90ab594 <m_freem>
      return (error);
 90afeac:	e0bff817 	ldw	r2,-32(fp)
 90afeb0:	e0bfff15 	stw	r2,-4(fp)
 90afeb4:	00019406 	br	90b0508 <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 90afeb8:	e0bffb17 	ldw	r2,-20(fp)
 90afebc:	10801104 	addi	r2,r2,68
 90afec0:	1009883a 	mov	r4,r2
 90afec4:	90a5cf40 	call	90a5cf4 <tcp_sleep>
 90afec8:	e0bffb17 	ldw	r2,-20(fp)
 90afecc:	1080110b 	ldhu	r2,68(r2)
 90afed0:	10bfffcc 	andi	r2,r2,65535
 90afed4:	1080004c 	andi	r2,r2,1
 90afed8:	10803fcc 	andi	r2,r2,255
 90afedc:	1004c03a 	cmpne	r2,r2,zero
 90afee0:	103ff51e 	bne	r2,zero,90afeb8 <soreceive+0x17c>
 90afee4:	e0bffb17 	ldw	r2,-20(fp)
 90afee8:	1080110b 	ldhu	r2,68(r2)
 90afeec:	10800054 	ori	r2,r2,1
 90afef0:	1007883a 	mov	r3,r2
 90afef4:	e0bffb17 	ldw	r2,-20(fp)
 90afef8:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 90afefc:	e0bffb17 	ldw	r2,-20(fp)
 90aff00:	10800a17 	ldw	r2,40(r2)
 90aff04:	1004c03a 	cmpne	r2,r2,zero
 90aff08:	1000401e 	bne	r2,zero,90b000c <soreceive+0x2d0>
   {
      if (so->so_error) 
 90aff0c:	e0bffb17 	ldw	r2,-20(fp)
 90aff10:	10800617 	ldw	r2,24(r2)
 90aff14:	1005003a 	cmpeq	r2,r2,zero
 90aff18:	1000061e 	bne	r2,zero,90aff34 <soreceive+0x1f8>
      {
         error = so->so_error;
 90aff1c:	e0bffb17 	ldw	r2,-20(fp)
 90aff20:	10800617 	ldw	r2,24(r2)
 90aff24:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 90aff28:	e0bffb17 	ldw	r2,-20(fp)
 90aff2c:	10000615 	stw	zero,24(r2)
         goto release;
 90aff30:	00016806 	br	90b04d4 <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 90aff34:	e0bffb17 	ldw	r2,-20(fp)
 90aff38:	1080088b 	ldhu	r2,34(r2)
 90aff3c:	10bfffcc 	andi	r2,r2,65535
 90aff40:	1080080c 	andi	r2,r2,32
 90aff44:	1004c03a 	cmpne	r2,r2,zero
 90aff48:	1001621e 	bne	r2,zero,90b04d4 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 90aff4c:	e0bffb17 	ldw	r2,-20(fp)
 90aff50:	1080088b 	ldhu	r2,34(r2)
 90aff54:	10bfffcc 	andi	r2,r2,65535
 90aff58:	1080008c 	andi	r2,r2,2
 90aff5c:	1004c03a 	cmpne	r2,r2,zero
 90aff60:	10000a1e 	bne	r2,zero,90aff8c <soreceive+0x250>
 90aff64:	e0bffb17 	ldw	r2,-20(fp)
 90aff68:	10800217 	ldw	r2,8(r2)
 90aff6c:	1080010b 	ldhu	r2,4(r2)
 90aff70:	10bfffcc 	andi	r2,r2,65535
 90aff74:	1080010c 	andi	r2,r2,4
 90aff78:	1005003a 	cmpeq	r2,r2,zero
 90aff7c:	1000031e 	bne	r2,zero,90aff8c <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 90aff80:	00802004 	movi	r2,128
 90aff84:	e0bff815 	stw	r2,-32(fp)
         goto release;
 90aff88:	00015206 	br	90b04d4 <soreceive+0x798>
      }
      if (*datalen == 0)
 90aff8c:	e0bffe17 	ldw	r2,-8(fp)
 90aff90:	10800017 	ldw	r2,0(r2)
 90aff94:	1005003a 	cmpeq	r2,r2,zero
 90aff98:	10014e1e 	bne	r2,zero,90b04d4 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 90aff9c:	e0bffb17 	ldw	r2,-20(fp)
 90affa0:	1080088b 	ldhu	r2,34(r2)
 90affa4:	10bfffcc 	andi	r2,r2,65535
 90affa8:	1080400c 	andi	r2,r2,256
 90affac:	1004c03a 	cmpne	r2,r2,zero
 90affb0:	1000041e 	bne	r2,zero,90affc4 <soreceive+0x288>
 90affb4:	e0800217 	ldw	r2,8(fp)
 90affb8:	1080080c 	andi	r2,r2,32
 90affbc:	1005003a 	cmpeq	r2,r2,zero
 90affc0:	1000031e 	bne	r2,zero,90affd0 <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 90affc4:	008002c4 	movi	r2,11
 90affc8:	e0bff815 	stw	r2,-32(fp)
         goto release;
 90affcc:	00014106 	br	90b04d4 <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 90affd0:	e0bffb17 	ldw	r2,-20(fp)
 90affd4:	10c0110b 	ldhu	r3,68(r2)
 90affd8:	00bfff84 	movi	r2,-2
 90affdc:	1884703a 	and	r2,r3,r2
 90affe0:	1007883a 	mov	r3,r2
 90affe4:	e0bffb17 	ldw	r2,-20(fp)
 90affe8:	10c0110d 	sth	r3,68(r2)
 90affec:	e0bffb17 	ldw	r2,-20(fp)
 90afff0:	10801104 	addi	r2,r2,68
 90afff4:	1009883a 	mov	r4,r2
 90afff8:	90a5e940 	call	90a5e94 <tcp_wakeup>
      sbwait(&so->so_rcv);
 90afffc:	e0bffb17 	ldw	r2,-20(fp)
 90b0000:	11000a04 	addi	r4,r2,40
 90b0004:	90b187c0 	call	90b187c <sbwait>
      goto restart;
 90b0008:	003faf06 	br	90afec8 <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 90b000c:	e0bffb17 	ldw	r2,-20(fp)
 90b0010:	10801017 	ldw	r2,64(r2)
 90b0014:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 90b0018:	e0bffa17 	ldw	r2,-24(fp)
 90b001c:	1004c03a 	cmpne	r2,r2,zero
 90b0020:	1000031e 	bne	r2,zero,90b0030 <soreceive+0x2f4>
      panic("sorecv 1");
 90b0024:	01024374 	movhi	r4,2317
 90b0028:	21024504 	addi	r4,r4,2324
 90b002c:	90a537c0 	call	90a537c <panic>
   nextrecord = m->m_act;
 90b0030:	e0bffa17 	ldw	r2,-24(fp)
 90b0034:	10800717 	ldw	r2,28(r2)
 90b0038:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 90b003c:	e0bff617 	ldw	r2,-40(fp)
 90b0040:	1080010b 	ldhu	r2,4(r2)
 90b0044:	10bfffcc 	andi	r2,r2,65535
 90b0048:	1080008c 	andi	r2,r2,2
 90b004c:	1005003a 	cmpeq	r2,r2,zero
 90b0050:	1000451e 	bne	r2,zero,90b0168 <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 90b0054:	e0bffa17 	ldw	r2,-24(fp)
 90b0058:	10800817 	ldw	r2,32(r2)
 90b005c:	10800260 	cmpeqi	r2,r2,9
 90b0060:	1000081e 	bne	r2,zero,90b0084 <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 90b0064:	e0bffa17 	ldw	r2,-24(fp)
 90b0068:	11400817 	ldw	r5,32(r2)
 90b006c:	01024374 	movhi	r4,2317
 90b0070:	21024804 	addi	r4,r4,2336
 90b0074:	90833900 	call	9083390 <printf>
         panic("sorecv 2");
 90b0078:	01024374 	movhi	r4,2317
 90b007c:	21024e04 	addi	r4,r4,2360
 90b0080:	90a537c0 	call	90a537c <panic>
      }
      if (flags & MSG_PEEK) 
 90b0084:	e0800217 	ldw	r2,8(fp)
 90b0088:	1080008c 	andi	r2,r2,2
 90b008c:	1005003a 	cmpeq	r2,r2,zero
 90b0090:	1000101e 	bne	r2,zero,90b00d4 <soreceive+0x398>
      {
         if (aname)
 90b0094:	e0bffc17 	ldw	r2,-16(fp)
 90b0098:	1005003a 	cmpeq	r2,r2,zero
 90b009c:	1000091e 	bne	r2,zero,90b00c4 <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 90b00a0:	e0bffa17 	ldw	r2,-24(fp)
 90b00a4:	10800217 	ldw	r2,8(r2)
 90b00a8:	100d883a 	mov	r6,r2
 90b00ac:	e13ffa17 	ldw	r4,-24(fp)
 90b00b0:	000b883a 	mov	r5,zero
 90b00b4:	90ab5d80 	call	90ab5d8 <m_copy>
 90b00b8:	1007883a 	mov	r3,r2
 90b00bc:	e0bffc17 	ldw	r2,-16(fp)
 90b00c0:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 90b00c4:	e0bffa17 	ldw	r2,-24(fp)
 90b00c8:	10800617 	ldw	r2,24(r2)
 90b00cc:	e0bffa15 	stw	r2,-24(fp)
 90b00d0:	00002506 	br	90b0168 <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 90b00d4:	e0bffb17 	ldw	r2,-20(fp)
 90b00d8:	10c00a17 	ldw	r3,40(r2)
 90b00dc:	e0bffa17 	ldw	r2,-24(fp)
 90b00e0:	10800217 	ldw	r2,8(r2)
 90b00e4:	1887c83a 	sub	r3,r3,r2
 90b00e8:	e0bffb17 	ldw	r2,-20(fp)
 90b00ec:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 90b00f0:	e0bffc17 	ldw	r2,-16(fp)
 90b00f4:	1005003a 	cmpeq	r2,r2,zero
 90b00f8:	10000d1e 	bne	r2,zero,90b0130 <soreceive+0x3f4>
         {
            *aname = m;
 90b00fc:	e0fffc17 	ldw	r3,-16(fp)
 90b0100:	e0bffa17 	ldw	r2,-24(fp)
 90b0104:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 90b0108:	e0bffa17 	ldw	r2,-24(fp)
 90b010c:	10800617 	ldw	r2,24(r2)
 90b0110:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 90b0114:	e0bffc17 	ldw	r2,-16(fp)
 90b0118:	10800017 	ldw	r2,0(r2)
 90b011c:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 90b0120:	e0fffb17 	ldw	r3,-20(fp)
 90b0124:	e0bffa17 	ldw	r2,-24(fp)
 90b0128:	18801015 	stw	r2,64(r3)
 90b012c:	00000806 	br	90b0150 <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 90b0130:	e13ffa17 	ldw	r4,-24(fp)
 90b0134:	90ab4600 	call	90ab460 <m_free>
 90b0138:	1007883a 	mov	r3,r2
 90b013c:	e0bffb17 	ldw	r2,-20(fp)
 90b0140:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 90b0144:	e0bffb17 	ldw	r2,-20(fp)
 90b0148:	10801017 	ldw	r2,64(r2)
 90b014c:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 90b0150:	e0bffa17 	ldw	r2,-24(fp)
 90b0154:	1005003a 	cmpeq	r2,r2,zero
 90b0158:	1000031e 	bne	r2,zero,90b0168 <soreceive+0x42c>
            m->m_act = nextrecord;
 90b015c:	e0fffa17 	ldw	r3,-24(fp)
 90b0160:	e0bff517 	ldw	r2,-44(fp)
 90b0164:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 90b0168:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 90b016c:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 90b0170:	0000a606 	br	90b040c <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 90b0174:	e0bffa17 	ldw	r2,-24(fp)
 90b0178:	10800817 	ldw	r2,32(r2)
 90b017c:	10800060 	cmpeqi	r2,r2,1
 90b0180:	1000071e 	bne	r2,zero,90b01a0 <soreceive+0x464>
 90b0184:	e0bffa17 	ldw	r2,-24(fp)
 90b0188:	10800817 	ldw	r2,32(r2)
 90b018c:	108000e0 	cmpeqi	r2,r2,3
 90b0190:	1000031e 	bne	r2,zero,90b01a0 <soreceive+0x464>
         panic("sorecv 3");
 90b0194:	01024374 	movhi	r4,2317
 90b0198:	21025104 	addi	r4,r4,2372
 90b019c:	90a537c0 	call	90a537c <panic>
      len = *datalen;
 90b01a0:	e0bffe17 	ldw	r2,-8(fp)
 90b01a4:	10800017 	ldw	r2,0(r2)
 90b01a8:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 90b01ac:	e0bffb17 	ldw	r2,-20(fp)
 90b01b0:	10c0088b 	ldhu	r3,34(r2)
 90b01b4:	00bfefc4 	movi	r2,-65
 90b01b8:	1884703a 	and	r2,r3,r2
 90b01bc:	1007883a 	mov	r3,r2
 90b01c0:	e0bffb17 	ldw	r2,-20(fp)
 90b01c4:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 90b01c8:	e0bffb17 	ldw	r2,-20(fp)
 90b01cc:	10801a17 	ldw	r2,104(r2)
 90b01d0:	1005003a 	cmpeq	r2,r2,zero
 90b01d4:	10000c1e 	bne	r2,zero,90b0208 <soreceive+0x4cc>
 90b01d8:	e0bffb17 	ldw	r2,-20(fp)
 90b01dc:	10c01a17 	ldw	r3,104(r2)
 90b01e0:	e0bff717 	ldw	r2,-36(fp)
 90b01e4:	1885c83a 	sub	r2,r3,r2
 90b01e8:	1007883a 	mov	r3,r2
 90b01ec:	e0bff917 	ldw	r2,-28(fp)
 90b01f0:	1880050e 	bge	r3,r2,90b0208 <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 90b01f4:	e0bffb17 	ldw	r2,-20(fp)
 90b01f8:	10c01a17 	ldw	r3,104(r2)
 90b01fc:	e0bff717 	ldw	r2,-36(fp)
 90b0200:	1885c83a 	sub	r2,r3,r2
 90b0204:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 90b0208:	e0bffa17 	ldw	r2,-24(fp)
 90b020c:	10c00217 	ldw	r3,8(r2)
 90b0210:	e0bff417 	ldw	r2,-48(fp)
 90b0214:	1885c83a 	sub	r2,r3,r2
 90b0218:	1007883a 	mov	r3,r2
 90b021c:	e0bff917 	ldw	r2,-28(fp)
 90b0220:	1880050e 	bge	r3,r2,90b0238 <soreceive+0x4fc>
         len = m->m_len - moff;
 90b0224:	e0bffa17 	ldw	r2,-24(fp)
 90b0228:	10c00217 	ldw	r3,8(r2)
 90b022c:	e0bff417 	ldw	r2,-48(fp)
 90b0230:	1885c83a 	sub	r2,r3,r2
 90b0234:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 90b0238:	e0bffa17 	ldw	r2,-24(fp)
 90b023c:	10c00317 	ldw	r3,12(r2)
 90b0240:	e0bff417 	ldw	r2,-48(fp)
 90b0244:	1887883a 	add	r3,r3,r2
 90b0248:	e1bff917 	ldw	r6,-28(fp)
 90b024c:	e0bffd17 	ldw	r2,-12(fp)
 90b0250:	1009883a 	mov	r4,r2
 90b0254:	180b883a 	mov	r5,r3
 90b0258:	90894600 	call	9089460 <memcpy>
      data += len;
 90b025c:	e0bff917 	ldw	r2,-28(fp)
 90b0260:	1007883a 	mov	r3,r2
 90b0264:	e0bffd17 	ldw	r2,-12(fp)
 90b0268:	10c5883a 	add	r2,r2,r3
 90b026c:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 90b0270:	e0bffe17 	ldw	r2,-8(fp)
 90b0274:	10c00017 	ldw	r3,0(r2)
 90b0278:	e0bff917 	ldw	r2,-28(fp)
 90b027c:	1887c83a 	sub	r3,r3,r2
 90b0280:	e0bffe17 	ldw	r2,-8(fp)
 90b0284:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 90b0288:	e0bffa17 	ldw	r2,-24(fp)
 90b028c:	10c00217 	ldw	r3,8(r2)
 90b0290:	e0bff417 	ldw	r2,-48(fp)
 90b0294:	1885c83a 	sub	r2,r3,r2
 90b0298:	1007883a 	mov	r3,r2
 90b029c:	e0bff917 	ldw	r2,-28(fp)
 90b02a0:	1880221e 	bne	r3,r2,90b032c <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 90b02a4:	e0800217 	ldw	r2,8(fp)
 90b02a8:	1080008c 	andi	r2,r2,2
 90b02ac:	1005003a 	cmpeq	r2,r2,zero
 90b02b0:	1000051e 	bne	r2,zero,90b02c8 <soreceive+0x58c>
         {
            m = m->m_next;
 90b02b4:	e0bffa17 	ldw	r2,-24(fp)
 90b02b8:	10800617 	ldw	r2,24(r2)
 90b02bc:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 90b02c0:	e03ff415 	stw	zero,-48(fp)
 90b02c4:	00003406 	br	90b0398 <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 90b02c8:	e0bffa17 	ldw	r2,-24(fp)
 90b02cc:	10800717 	ldw	r2,28(r2)
 90b02d0:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 90b02d4:	e0bffb17 	ldw	r2,-20(fp)
 90b02d8:	10c00a17 	ldw	r3,40(r2)
 90b02dc:	e0bffa17 	ldw	r2,-24(fp)
 90b02e0:	10800217 	ldw	r2,8(r2)
 90b02e4:	1887c83a 	sub	r3,r3,r2
 90b02e8:	e0bffb17 	ldw	r2,-20(fp)
 90b02ec:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 90b02f0:	e13ffa17 	ldw	r4,-24(fp)
 90b02f4:	90ab4600 	call	90ab460 <m_free>
 90b02f8:	1007883a 	mov	r3,r2
 90b02fc:	e0bffb17 	ldw	r2,-20(fp)
 90b0300:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 90b0304:	e0bffb17 	ldw	r2,-20(fp)
 90b0308:	10801017 	ldw	r2,64(r2)
 90b030c:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 90b0310:	e0bffa17 	ldw	r2,-24(fp)
 90b0314:	1005003a 	cmpeq	r2,r2,zero
 90b0318:	10001f1e 	bne	r2,zero,90b0398 <soreceive+0x65c>
               m->m_act = nextrecord;
 90b031c:	e0fffa17 	ldw	r3,-24(fp)
 90b0320:	e0bff517 	ldw	r2,-44(fp)
 90b0324:	18800715 	stw	r2,28(r3)
 90b0328:	00001b06 	br	90b0398 <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 90b032c:	e0800217 	ldw	r2,8(fp)
 90b0330:	1080008c 	andi	r2,r2,2
 90b0334:	1005003a 	cmpeq	r2,r2,zero
 90b0338:	1000051e 	bne	r2,zero,90b0350 <soreceive+0x614>
            moff += len;
 90b033c:	e0bff417 	ldw	r2,-48(fp)
 90b0340:	e0fff917 	ldw	r3,-28(fp)
 90b0344:	10c5883a 	add	r2,r2,r3
 90b0348:	e0bff415 	stw	r2,-48(fp)
 90b034c:	00001206 	br	90b0398 <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 90b0350:	e0bffa17 	ldw	r2,-24(fp)
 90b0354:	10c00317 	ldw	r3,12(r2)
 90b0358:	e0bff917 	ldw	r2,-28(fp)
 90b035c:	1887883a 	add	r3,r3,r2
 90b0360:	e0bffa17 	ldw	r2,-24(fp)
 90b0364:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 90b0368:	e0bffa17 	ldw	r2,-24(fp)
 90b036c:	10c00217 	ldw	r3,8(r2)
 90b0370:	e0bff917 	ldw	r2,-28(fp)
 90b0374:	1887c83a 	sub	r3,r3,r2
 90b0378:	e0bffa17 	ldw	r2,-24(fp)
 90b037c:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 90b0380:	e0bffb17 	ldw	r2,-20(fp)
 90b0384:	10c00a17 	ldw	r3,40(r2)
 90b0388:	e0bff917 	ldw	r2,-28(fp)
 90b038c:	1887c83a 	sub	r3,r3,r2
 90b0390:	e0bffb17 	ldw	r2,-20(fp)
 90b0394:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 90b0398:	e0bffb17 	ldw	r2,-20(fp)
 90b039c:	10801a17 	ldw	r2,104(r2)
 90b03a0:	1005003a 	cmpeq	r2,r2,zero
 90b03a4:	1000191e 	bne	r2,zero,90b040c <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 90b03a8:	e0800217 	ldw	r2,8(fp)
 90b03ac:	1080008c 	andi	r2,r2,2
 90b03b0:	1004c03a 	cmpne	r2,r2,zero
 90b03b4:	1000111e 	bne	r2,zero,90b03fc <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 90b03b8:	e0bffb17 	ldw	r2,-20(fp)
 90b03bc:	10c01a17 	ldw	r3,104(r2)
 90b03c0:	e0bff917 	ldw	r2,-28(fp)
 90b03c4:	1887c83a 	sub	r3,r3,r2
 90b03c8:	e0bffb17 	ldw	r2,-20(fp)
 90b03cc:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 90b03d0:	e0bffb17 	ldw	r2,-20(fp)
 90b03d4:	10801a17 	ldw	r2,104(r2)
 90b03d8:	1004c03a 	cmpne	r2,r2,zero
 90b03dc:	10000b1e 	bne	r2,zero,90b040c <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 90b03e0:	e0bffb17 	ldw	r2,-20(fp)
 90b03e4:	1080088b 	ldhu	r2,34(r2)
 90b03e8:	10801014 	ori	r2,r2,64
 90b03ec:	1007883a 	mov	r3,r2
 90b03f0:	e0bffb17 	ldw	r2,-20(fp)
 90b03f4:	10c0088d 	sth	r3,34(r2)
               break;
 90b03f8:	00000e06 	br	90b0434 <soreceive+0x6f8>
            }
         } else
            offset += len;
 90b03fc:	e0bff717 	ldw	r2,-36(fp)
 90b0400:	e0fff917 	ldw	r3,-28(fp)
 90b0404:	10c5883a 	add	r2,r2,r3
 90b0408:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 90b040c:	e0bffa17 	ldw	r2,-24(fp)
 90b0410:	1005003a 	cmpeq	r2,r2,zero
 90b0414:	1000071e 	bne	r2,zero,90b0434 <soreceive+0x6f8>
 90b0418:	e0bffe17 	ldw	r2,-8(fp)
 90b041c:	10800017 	ldw	r2,0(r2)
 90b0420:	10800050 	cmplti	r2,r2,1
 90b0424:	1000031e 	bne	r2,zero,90b0434 <soreceive+0x6f8>
 90b0428:	e0bff817 	ldw	r2,-32(fp)
 90b042c:	1005003a 	cmpeq	r2,r2,zero
 90b0430:	103f501e 	bne	r2,zero,90b0174 <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 90b0434:	e0800217 	ldw	r2,8(fp)
 90b0438:	1080008c 	andi	r2,r2,2
 90b043c:	1004c03a 	cmpne	r2,r2,zero
 90b0440:	1000241e 	bne	r2,zero,90b04d4 <soreceive+0x798>
   {
      if (m == 0)
 90b0444:	e0bffa17 	ldw	r2,-24(fp)
 90b0448:	1004c03a 	cmpne	r2,r2,zero
 90b044c:	1000041e 	bne	r2,zero,90b0460 <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 90b0450:	e0fffb17 	ldw	r3,-20(fp)
 90b0454:	e0bff517 	ldw	r2,-44(fp)
 90b0458:	18801015 	stw	r2,64(r3)
 90b045c:	00000a06 	br	90b0488 <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 90b0460:	e0bff617 	ldw	r2,-40(fp)
 90b0464:	1080010b 	ldhu	r2,4(r2)
 90b0468:	10bfffcc 	andi	r2,r2,65535
 90b046c:	1080004c 	andi	r2,r2,1
 90b0470:	10803fcc 	andi	r2,r2,255
 90b0474:	1005003a 	cmpeq	r2,r2,zero
 90b0478:	1000031e 	bne	r2,zero,90b0488 <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 90b047c:	e0bffb17 	ldw	r2,-20(fp)
 90b0480:	11000a04 	addi	r4,r2,40
 90b0484:	90b23900 	call	90b2390 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 90b0488:	e0bff617 	ldw	r2,-40(fp)
 90b048c:	1080010b 	ldhu	r2,4(r2)
 90b0490:	10bfffcc 	andi	r2,r2,65535
 90b0494:	1080020c 	andi	r2,r2,8
 90b0498:	1005003a 	cmpeq	r2,r2,zero
 90b049c:	10000d1e 	bne	r2,zero,90b04d4 <soreceive+0x798>
 90b04a0:	e0bffb17 	ldw	r2,-20(fp)
 90b04a4:	10800117 	ldw	r2,4(r2)
 90b04a8:	1005003a 	cmpeq	r2,r2,zero
 90b04ac:	1000091e 	bne	r2,zero,90b04d4 <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 90b04b0:	e0fffb17 	ldw	r3,-20(fp)
 90b04b4:	00800204 	movi	r2,8
 90b04b8:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 90b04bc:	e0bff617 	ldw	r2,-40(fp)
 90b04c0:	10800317 	ldw	r2,12(r2)
 90b04c4:	e13ffb17 	ldw	r4,-20(fp)
 90b04c8:	000b883a 	mov	r5,zero
 90b04cc:	000d883a 	mov	r6,zero
 90b04d0:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 90b04d4:	e0bffb17 	ldw	r2,-20(fp)
 90b04d8:	10c0110b 	ldhu	r3,68(r2)
 90b04dc:	00bfff84 	movi	r2,-2
 90b04e0:	1884703a 	and	r2,r3,r2
 90b04e4:	1007883a 	mov	r3,r2
 90b04e8:	e0bffb17 	ldw	r2,-20(fp)
 90b04ec:	10c0110d 	sth	r3,68(r2)
 90b04f0:	e0bffb17 	ldw	r2,-20(fp)
 90b04f4:	10801104 	addi	r2,r2,68
 90b04f8:	1009883a 	mov	r4,r2
 90b04fc:	90a5e940 	call	90a5e94 <tcp_wakeup>
   return (error);
 90b0500:	e0bff817 	ldw	r2,-32(fp)
 90b0504:	e0bfff15 	stw	r2,-4(fp)
 90b0508:	e0bfff17 	ldw	r2,-4(fp)
}
 90b050c:	e037883a 	mov	sp,fp
 90b0510:	dfc00117 	ldw	ra,4(sp)
 90b0514:	df000017 	ldw	fp,0(sp)
 90b0518:	dec00204 	addi	sp,sp,8
 90b051c:	f800283a 	ret

090b0520 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 90b0520:	defffb04 	addi	sp,sp,-20
 90b0524:	dfc00415 	stw	ra,16(sp)
 90b0528:	df000315 	stw	fp,12(sp)
 90b052c:	df000304 	addi	fp,sp,12
 90b0530:	e13ffd15 	stw	r4,-12(fp)
 90b0534:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 90b0538:	e0bffe17 	ldw	r2,-8(fp)
 90b053c:	10800044 	addi	r2,r2,1
 90b0540:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 90b0544:	e0bffe17 	ldw	r2,-8(fp)
 90b0548:	1080004c 	andi	r2,r2,1
 90b054c:	10803fcc 	andi	r2,r2,255
 90b0550:	1005003a 	cmpeq	r2,r2,zero
 90b0554:	1000021e 	bne	r2,zero,90b0560 <soshutdown+0x40>
      sorflush(so);
 90b0558:	e13ffd17 	ldw	r4,-12(fp)
 90b055c:	90b05c80 	call	90b05c8 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 90b0560:	e0bffe17 	ldw	r2,-8(fp)
 90b0564:	1080008c 	andi	r2,r2,2
 90b0568:	1005003a 	cmpeq	r2,r2,zero
 90b056c:	10000f1e 	bne	r2,zero,90b05ac <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 90b0570:	e0bffd17 	ldw	r2,-12(fp)
 90b0574:	11001204 	addi	r4,r2,72
 90b0578:	90b20200 	call	90b2020 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 90b057c:	e0fffd17 	ldw	r3,-12(fp)
 90b0580:	008001c4 	movi	r2,7
 90b0584:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 90b0588:	e0bffd17 	ldw	r2,-12(fp)
 90b058c:	10800217 	ldw	r2,8(r2)
 90b0590:	10800317 	ldw	r2,12(r2)
 90b0594:	e13ffd17 	ldw	r4,-12(fp)
 90b0598:	000b883a 	mov	r5,zero
 90b059c:	000d883a 	mov	r6,zero
 90b05a0:	103ee83a 	callr	r2
 90b05a4:	e0bfff15 	stw	r2,-4(fp)
 90b05a8:	00000106 	br	90b05b0 <soshutdown+0x90>
   }

   return 0;
 90b05ac:	e03fff15 	stw	zero,-4(fp)
 90b05b0:	e0bfff17 	ldw	r2,-4(fp)
}
 90b05b4:	e037883a 	mov	sp,fp
 90b05b8:	dfc00117 	ldw	ra,4(sp)
 90b05bc:	df000017 	ldw	fp,0(sp)
 90b05c0:	dec00204 	addi	sp,sp,8
 90b05c4:	f800283a 	ret

090b05c8 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 90b05c8:	defffb04 	addi	sp,sp,-20
 90b05cc:	dfc00415 	stw	ra,16(sp)
 90b05d0:	df000315 	stw	fp,12(sp)
 90b05d4:	df000304 	addi	fp,sp,12
 90b05d8:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 90b05dc:	e0bfff17 	ldw	r2,-4(fp)
 90b05e0:	10800a04 	addi	r2,r2,40
 90b05e4:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 90b05e8:	00000406 	br	90b05fc <sorflush+0x34>
 90b05ec:	e0bffe17 	ldw	r2,-8(fp)
 90b05f0:	10800704 	addi	r2,r2,28
 90b05f4:	1009883a 	mov	r4,r2
 90b05f8:	90a5cf40 	call	90a5cf4 <tcp_sleep>
 90b05fc:	e0bffe17 	ldw	r2,-8(fp)
 90b0600:	1080070b 	ldhu	r2,28(r2)
 90b0604:	10bfffcc 	andi	r2,r2,65535
 90b0608:	1080004c 	andi	r2,r2,1
 90b060c:	10803fcc 	andi	r2,r2,255
 90b0610:	1004c03a 	cmpne	r2,r2,zero
 90b0614:	103ff51e 	bne	r2,zero,90b05ec <sorflush+0x24>
 90b0618:	e0bffe17 	ldw	r2,-8(fp)
 90b061c:	1080070b 	ldhu	r2,28(r2)
 90b0620:	10800054 	ori	r2,r2,1
 90b0624:	1007883a 	mov	r3,r2
 90b0628:	e0bffe17 	ldw	r2,-8(fp)
 90b062c:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 90b0630:	e13fff17 	ldw	r4,-4(fp)
 90b0634:	90b17f40 	call	90b17f4 <socantrcvmore>
   sbunlock(sb);
 90b0638:	e0bffe17 	ldw	r2,-8(fp)
 90b063c:	10c0070b 	ldhu	r3,28(r2)
 90b0640:	00bfff84 	movi	r2,-2
 90b0644:	1884703a 	and	r2,r3,r2
 90b0648:	1007883a 	mov	r3,r2
 90b064c:	e0bffe17 	ldw	r2,-8(fp)
 90b0650:	10c0070d 	sth	r3,28(r2)
 90b0654:	e0bffe17 	ldw	r2,-8(fp)
 90b0658:	10800704 	addi	r2,r2,28
 90b065c:	1009883a 	mov	r4,r2
 90b0660:	90a5e940 	call	90a5e94 <tcp_wakeup>
   sbrelease(sb);
 90b0664:	e13ffe17 	ldw	r4,-8(fp)
 90b0668:	90b1a600 	call	90b1a60 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 90b066c:	e0bffe17 	ldw	r2,-8(fp)
 90b0670:	1009883a 	mov	r4,r2
 90b0674:	01800804 	movi	r6,32
 90b0678:	000b883a 	mov	r5,zero
 90b067c:	90832780 	call	9083278 <memset>
   s = so->so_error;
 90b0680:	e0bfff17 	ldw	r2,-4(fp)
 90b0684:	10800617 	ldw	r2,24(r2)
 90b0688:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 90b068c:	e0ffff17 	ldw	r3,-4(fp)
 90b0690:	00801b84 	movi	r2,110
 90b0694:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 90b0698:	e0bfff17 	ldw	r2,-4(fp)
 90b069c:	11400a04 	addi	r5,r2,40
 90b06a0:	e13fff17 	ldw	r4,-4(fp)
 90b06a4:	90b18e40 	call	90b18e4 <sbwakeup>
   so->so_error = s;
 90b06a8:	e0ffff17 	ldw	r3,-4(fp)
 90b06ac:	e0bffd17 	ldw	r2,-12(fp)
 90b06b0:	18800615 	stw	r2,24(r3)
}
 90b06b4:	e037883a 	mov	sp,fp
 90b06b8:	dfc00117 	ldw	ra,4(sp)
 90b06bc:	df000017 	ldw	fp,0(sp)
 90b06c0:	dec00204 	addi	sp,sp,8
 90b06c4:	f800283a 	ret

090b06c8 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 90b06c8:	defff404 	addi	sp,sp,-48
 90b06cc:	dfc00b15 	stw	ra,44(sp)
 90b06d0:	df000a15 	stw	fp,40(sp)
 90b06d4:	df000a04 	addi	fp,sp,40
 90b06d8:	e13ffb15 	stw	r4,-20(fp)
 90b06dc:	e17ffc15 	stw	r5,-16(fp)
 90b06e0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90b06e4:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 90b06e8:	e0bffc17 	ldw	r2,-16(fp)
 90b06ec:	e0bfff15 	stw	r2,-4(fp)
 90b06f0:	e0ffff17 	ldw	r3,-4(fp)
 90b06f4:	18808020 	cmpeqi	r2,r3,512
 90b06f8:	1000521e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b06fc:	e0ffff17 	ldw	r3,-4(fp)
 90b0700:	18808048 	cmpgei	r2,r3,513
 90b0704:	1000211e 	bne	r2,zero,90b078c <sosetopt+0xc4>
 90b0708:	e0ffff17 	ldw	r3,-4(fp)
 90b070c:	18800388 	cmpgei	r2,r3,14
 90b0710:	10000d1e 	bne	r2,zero,90b0748 <sosetopt+0x80>
 90b0714:	e0ffff17 	ldw	r3,-4(fp)
 90b0718:	18800248 	cmpgei	r2,r3,9
 90b071c:	10009d1e 	bne	r2,zero,90b0994 <sosetopt+0x2cc>
 90b0720:	e0ffff17 	ldw	r3,-4(fp)
 90b0724:	18800120 	cmpeqi	r2,r3,4
 90b0728:	1000461e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b072c:	e0ffff17 	ldw	r3,-4(fp)
 90b0730:	18800220 	cmpeqi	r2,r3,8
 90b0734:	1000431e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b0738:	e0ffff17 	ldw	r3,-4(fp)
 90b073c:	188000a0 	cmpeqi	r2,r3,2
 90b0740:	10009a1e 	bne	r2,zero,90b09ac <sosetopt+0x2e4>
 90b0744:	00010806 	br	90b0b68 <sosetopt+0x4a0>
 90b0748:	e0ffff17 	ldw	r3,-4(fp)
 90b074c:	18800820 	cmpeqi	r2,r3,32
 90b0750:	10003c1e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b0754:	e0ffff17 	ldw	r3,-4(fp)
 90b0758:	18800848 	cmpgei	r2,r3,33
 90b075c:	1000041e 	bne	r2,zero,90b0770 <sosetopt+0xa8>
 90b0760:	e0ffff17 	ldw	r3,-4(fp)
 90b0764:	18800420 	cmpeqi	r2,r3,16
 90b0768:	1000361e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b076c:	0000fe06 	br	90b0b68 <sosetopt+0x4a0>
 90b0770:	e0ffff17 	ldw	r3,-4(fp)
 90b0774:	18802020 	cmpeqi	r2,r3,128
 90b0778:	10002d1e 	bne	r2,zero,90b0830 <sosetopt+0x168>
 90b077c:	e0ffff17 	ldw	r3,-4(fp)
 90b0780:	18804020 	cmpeqi	r2,r3,256
 90b0784:	10002f1e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b0788:	0000f706 	br	90b0b68 <sosetopt+0x4a0>
 90b078c:	e0ffff17 	ldw	r3,-4(fp)
 90b0790:	18840520 	cmpeqi	r2,r3,4116
 90b0794:	1000571e 	bne	r2,zero,90b08f4 <sosetopt+0x22c>
 90b0798:	e0ffff17 	ldw	r3,-4(fp)
 90b079c:	18840548 	cmpgei	r2,r3,4117
 90b07a0:	10000f1e 	bne	r2,zero,90b07e0 <sosetopt+0x118>
 90b07a4:	e0ffff17 	ldw	r3,-4(fp)
 90b07a8:	188401a0 	cmpeqi	r2,r3,4102
 90b07ac:	10004c1e 	bne	r2,zero,90b08e0 <sosetopt+0x218>
 90b07b0:	e0ffff17 	ldw	r3,-4(fp)
 90b07b4:	188401c8 	cmpgei	r2,r3,4103
 90b07b8:	1000051e 	bne	r2,zero,90b07d0 <sosetopt+0x108>
 90b07bc:	e0ffff17 	ldw	r3,-4(fp)
 90b07c0:	18bbffc4 	addi	r2,r3,-4097
 90b07c4:	108000a8 	cmpgeui	r2,r2,2
 90b07c8:	1000e71e 	bne	r2,zero,90b0b68 <sosetopt+0x4a0>
 90b07cc:	00003006 	br	90b0890 <sosetopt+0x1c8>
 90b07d0:	e0ffff17 	ldw	r3,-4(fp)
 90b07d4:	18840420 	cmpeqi	r2,r3,4112
 90b07d8:	1000ba1e 	bne	r2,zero,90b0ac4 <sosetopt+0x3fc>
 90b07dc:	0000e206 	br	90b0b68 <sosetopt+0x4a0>
 90b07e0:	e0ffff17 	ldw	r3,-4(fp)
 90b07e4:	188800e0 	cmpeqi	r2,r3,8195
 90b07e8:	1000b61e 	bne	r2,zero,90b0ac4 <sosetopt+0x3fc>
 90b07ec:	e0ffff17 	ldw	r3,-4(fp)
 90b07f0:	18880108 	cmpgei	r2,r3,8196
 90b07f4:	1000071e 	bne	r2,zero,90b0814 <sosetopt+0x14c>
 90b07f8:	e0ffff17 	ldw	r3,-4(fp)
 90b07fc:	18840560 	cmpeqi	r2,r3,4117
 90b0800:	1000431e 	bne	r2,zero,90b0910 <sosetopt+0x248>
 90b0804:	e0ffff17 	ldw	r3,-4(fp)
 90b0808:	188405a0 	cmpeqi	r2,r3,4118
 90b080c:	1000481e 	bne	r2,zero,90b0930 <sosetopt+0x268>
 90b0810:	0000d506 	br	90b0b68 <sosetopt+0x4a0>
 90b0814:	e0ffff17 	ldw	r3,-4(fp)
 90b0818:	18880120 	cmpeqi	r2,r3,8196
 90b081c:	10007a1e 	bne	r2,zero,90b0a08 <sosetopt+0x340>
 90b0820:	e0ffff17 	ldw	r3,-4(fp)
 90b0824:	18900020 	cmpeqi	r2,r3,16384
 90b0828:	1000061e 	bne	r2,zero,90b0844 <sosetopt+0x17c>
 90b082c:	0000ce06 	br	90b0b68 <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 90b0830:	e0bffd17 	ldw	r2,-12(fp)
 90b0834:	10800117 	ldw	r2,4(r2)
 90b0838:	1007883a 	mov	r3,r2
 90b083c:	e0bffb17 	ldw	r2,-20(fp)
 90b0840:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 90b0844:	e0bffd17 	ldw	r2,-12(fp)
 90b0848:	10800017 	ldw	r2,0(r2)
 90b084c:	1005003a 	cmpeq	r2,r2,zero
 90b0850:	1000071e 	bne	r2,zero,90b0870 <sosetopt+0x1a8>
         so->so_options |= optname;
 90b0854:	e0bffb17 	ldw	r2,-20(fp)
 90b0858:	10c00417 	ldw	r3,16(r2)
 90b085c:	e0bffc17 	ldw	r2,-16(fp)
 90b0860:	1886b03a 	or	r3,r3,r2
 90b0864:	e0bffb17 	ldw	r2,-20(fp)
 90b0868:	10c00415 	stw	r3,16(r2)
 90b086c:	0000c006 	br	90b0b70 <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 90b0870:	e0bffb17 	ldw	r2,-20(fp)
 90b0874:	10c00417 	ldw	r3,16(r2)
 90b0878:	e0bffc17 	ldw	r2,-16(fp)
 90b087c:	0084303a 	nor	r2,zero,r2
 90b0880:	1886703a 	and	r3,r3,r2
 90b0884:	e0bffb17 	ldw	r2,-20(fp)
 90b0888:	10c00415 	stw	r3,16(r2)
      break;
 90b088c:	0000b806 	br	90b0b70 <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 90b0890:	e0bffc17 	ldw	r2,-16(fp)
 90b0894:	10840058 	cmpnei	r2,r2,4097
 90b0898:	1000041e 	bne	r2,zero,90b08ac <sosetopt+0x1e4>
 90b089c:	e0bffb17 	ldw	r2,-20(fp)
 90b08a0:	10801204 	addi	r2,r2,72
 90b08a4:	e0bffe15 	stw	r2,-8(fp)
 90b08a8:	00000306 	br	90b08b8 <sosetopt+0x1f0>
 90b08ac:	e0bffb17 	ldw	r2,-20(fp)
 90b08b0:	10800a04 	addi	r2,r2,40
 90b08b4:	e0bffe15 	stw	r2,-8(fp)
 90b08b8:	e0bffd17 	ldw	r2,-12(fp)
 90b08bc:	10800017 	ldw	r2,0(r2)
 90b08c0:	100b883a 	mov	r5,r2
 90b08c4:	e13ffe17 	ldw	r4,-8(fp)
 90b08c8:	90b1a000 	call	90b1a00 <sbreserve>
 90b08cc:	1004c03a 	cmpne	r2,r2,zero
 90b08d0:	1000a71e 	bne	r2,zero,90b0b70 <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 90b08d4:	00801a44 	movi	r2,105
 90b08d8:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 90b08dc:	0000a406 	br	90b0b70 <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 90b08e0:	e0bffd17 	ldw	r2,-12(fp)
 90b08e4:	10c0000b 	ldhu	r3,0(r2)
 90b08e8:	e0bffb17 	ldw	r2,-20(fp)
 90b08ec:	10c0118d 	sth	r3,70(r2)
      break;
 90b08f0:	00009f06 	br	90b0b70 <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 90b08f4:	e0bffb17 	ldw	r2,-20(fp)
 90b08f8:	1080088b 	ldhu	r2,34(r2)
 90b08fc:	10804014 	ori	r2,r2,256
 90b0900:	1007883a 	mov	r3,r2
 90b0904:	e0bffb17 	ldw	r2,-20(fp)
 90b0908:	10c0088d 	sth	r3,34(r2)
      break;
 90b090c:	00009806 	br	90b0b70 <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 90b0910:	e0bffb17 	ldw	r2,-20(fp)
 90b0914:	10c0088b 	ldhu	r3,34(r2)
 90b0918:	00bfbfc4 	movi	r2,-257
 90b091c:	1884703a 	and	r2,r3,r2
 90b0920:	1007883a 	mov	r3,r2
 90b0924:	e0bffb17 	ldw	r2,-20(fp)
 90b0928:	10c0088d 	sth	r3,34(r2)
      break;
 90b092c:	00009006 	br	90b0b70 <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 90b0930:	e0bffd17 	ldw	r2,-12(fp)
 90b0934:	1004c03a 	cmpne	r2,r2,zero
 90b0938:	1000031e 	bne	r2,zero,90b0948 <sosetopt+0x280>
      {
         error = ENP_PARAM;
 90b093c:	00bffd84 	movi	r2,-10
 90b0940:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0944:	00008a06 	br	90b0b70 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 90b0948:	e0bffd17 	ldw	r2,-12(fp)
 90b094c:	10800017 	ldw	r2,0(r2)
 90b0950:	1005003a 	cmpeq	r2,r2,zero
 90b0954:	1000071e 	bne	r2,zero,90b0974 <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 90b0958:	e0bffb17 	ldw	r2,-20(fp)
 90b095c:	1080088b 	ldhu	r2,34(r2)
 90b0960:	10804014 	ori	r2,r2,256
 90b0964:	1007883a 	mov	r3,r2
 90b0968:	e0bffb17 	ldw	r2,-20(fp)
 90b096c:	10c0088d 	sth	r3,34(r2)
 90b0970:	00007f06 	br	90b0b70 <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 90b0974:	e0bffb17 	ldw	r2,-20(fp)
 90b0978:	10c0088b 	ldhu	r3,34(r2)
 90b097c:	00bfbfc4 	movi	r2,-257
 90b0980:	1884703a 	and	r2,r3,r2
 90b0984:	1007883a 	mov	r3,r2
 90b0988:	e0bffb17 	ldw	r2,-20(fp)
 90b098c:	10c0088d 	sth	r3,34(r2)
      break;
 90b0990:	00007706 	br	90b0b70 <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 90b0994:	e13ffc17 	ldw	r4,-16(fp)
 90b0998:	e17ffb17 	ldw	r5,-20(fp)
 90b099c:	e1bffd17 	ldw	r6,-12(fp)
 90b09a0:	90c57d40 	call	90c57d4 <ip_setmoptions>
 90b09a4:	e0bffa15 	stw	r2,-24(fp)
      break;
 90b09a8:	00007106 	br	90b0b70 <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 90b09ac:	e0bffd17 	ldw	r2,-12(fp)
 90b09b0:	1004c03a 	cmpne	r2,r2,zero
 90b09b4:	1000031e 	bne	r2,zero,90b09c4 <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 90b09b8:	00bffd84 	movi	r2,-10
 90b09bc:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b09c0:	00006b06 	br	90b0b70 <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 90b09c4:	e0bffd17 	ldw	r2,-12(fp)
 90b09c8:	10800017 	ldw	r2,0(r2)
 90b09cc:	1005003a 	cmpeq	r2,r2,zero
 90b09d0:	1000061e 	bne	r2,zero,90b09ec <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 90b09d4:	e0bffb17 	ldw	r2,-20(fp)
 90b09d8:	10800417 	ldw	r2,16(r2)
 90b09dc:	10c80014 	ori	r3,r2,8192
 90b09e0:	e0bffb17 	ldw	r2,-20(fp)
 90b09e4:	10c00415 	stw	r3,16(r2)
 90b09e8:	00006106 	br	90b0b70 <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 90b09ec:	e0bffb17 	ldw	r2,-20(fp)
 90b09f0:	10c00417 	ldw	r3,16(r2)
 90b09f4:	00b7ffc4 	movi	r2,-8193
 90b09f8:	1886703a 	and	r3,r3,r2
 90b09fc:	e0bffb17 	ldw	r2,-20(fp)
 90b0a00:	10c00415 	stw	r3,16(r2)
      break;
 90b0a04:	00005a06 	br	90b0b70 <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90b0a08:	e0bffb17 	ldw	r2,-20(fp)
 90b0a0c:	10800983 	ldbu	r2,38(r2)
 90b0a10:	10803fcc 	andi	r2,r2,255
 90b0a14:	1080201c 	xori	r2,r2,128
 90b0a18:	10bfe004 	addi	r2,r2,-128
 90b0a1c:	10800060 	cmpeqi	r2,r2,1
 90b0a20:	1000031e 	bne	r2,zero,90b0a30 <sosetopt+0x368>
      {
         error = EINVAL;
 90b0a24:	00800584 	movi	r2,22
 90b0a28:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0a2c:	00005006 	br	90b0b70 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90b0a30:	e0bffb17 	ldw	r2,-20(fp)
 90b0a34:	10800117 	ldw	r2,4(r2)
 90b0a38:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 90b0a3c:	e0bff917 	ldw	r2,-28(fp)
 90b0a40:	10800917 	ldw	r2,36(r2)
 90b0a44:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 90b0a48:	e0bff817 	ldw	r2,-32(fp)
 90b0a4c:	1004c03a 	cmpne	r2,r2,zero
 90b0a50:	1000031e 	bne	r2,zero,90b0a60 <sosetopt+0x398>
      {
         error = ENOTCONN;
 90b0a54:	00802004 	movi	r2,128
 90b0a58:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0a5c:	00004406 	br	90b0b70 <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 90b0a60:	e0bffd17 	ldw	r2,-12(fp)
 90b0a64:	1004c03a 	cmpne	r2,r2,zero
 90b0a68:	1000031e 	bne	r2,zero,90b0a78 <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 90b0a6c:	00bffd84 	movi	r2,-10
 90b0a70:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0a74:	00003e06 	br	90b0b70 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 90b0a78:	e0bffd17 	ldw	r2,-12(fp)
 90b0a7c:	10800017 	ldw	r2,0(r2)
 90b0a80:	1005003a 	cmpeq	r2,r2,zero
 90b0a84:	1000071e 	bne	r2,zero,90b0aa4 <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 90b0a88:	e0bff817 	ldw	r2,-32(fp)
 90b0a8c:	10800b0b 	ldhu	r2,44(r2)
 90b0a90:	10800114 	ori	r2,r2,4
 90b0a94:	1007883a 	mov	r3,r2
 90b0a98:	e0bff817 	ldw	r2,-32(fp)
 90b0a9c:	10c00b0d 	sth	r3,44(r2)
 90b0aa0:	00003306 	br	90b0b70 <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 90b0aa4:	e0bff817 	ldw	r2,-32(fp)
 90b0aa8:	10c00b0b 	ldhu	r3,44(r2)
 90b0aac:	00bffec4 	movi	r2,-5
 90b0ab0:	1884703a 	and	r2,r3,r2
 90b0ab4:	1007883a 	mov	r3,r2
 90b0ab8:	e0bff817 	ldw	r2,-32(fp)
 90b0abc:	10c00b0d 	sth	r3,44(r2)

      break;
 90b0ac0:	00002b06 	br	90b0b70 <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90b0ac4:	e0bffb17 	ldw	r2,-20(fp)
 90b0ac8:	10800983 	ldbu	r2,38(r2)
 90b0acc:	10803fcc 	andi	r2,r2,255
 90b0ad0:	1080201c 	xori	r2,r2,128
 90b0ad4:	10bfe004 	addi	r2,r2,-128
 90b0ad8:	10800060 	cmpeqi	r2,r2,1
 90b0adc:	1000031e 	bne	r2,zero,90b0aec <sosetopt+0x424>
      {
         error = EINVAL;
 90b0ae0:	00800584 	movi	r2,22
 90b0ae4:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0ae8:	00002106 	br	90b0b70 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90b0aec:	e0bffb17 	ldw	r2,-20(fp)
 90b0af0:	10800117 	ldw	r2,4(r2)
 90b0af4:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 90b0af8:	e0bff717 	ldw	r2,-36(fp)
 90b0afc:	10800917 	ldw	r2,36(r2)
 90b0b00:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 90b0b04:	e0bff617 	ldw	r2,-40(fp)
 90b0b08:	1004c03a 	cmpne	r2,r2,zero
 90b0b0c:	1000031e 	bne	r2,zero,90b0b1c <sosetopt+0x454>
      {
         error = ENOTCONN;
 90b0b10:	00802004 	movi	r2,128
 90b0b14:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0b18:	00001506 	br	90b0b70 <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 90b0b1c:	e0bff617 	ldw	r2,-40(fp)
 90b0b20:	10800217 	ldw	r2,8(r2)
 90b0b24:	1005003a 	cmpeq	r2,r2,zero
 90b0b28:	1000031e 	bne	r2,zero,90b0b38 <sosetopt+0x470>
      {
         error = EINVAL;
 90b0b2c:	00800584 	movi	r2,22
 90b0b30:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0b34:	00000e06 	br	90b0b70 <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 90b0b38:	e0bffd17 	ldw	r2,-12(fp)
 90b0b3c:	10800017 	ldw	r2,0(r2)
 90b0b40:	1007883a 	mov	r3,r2
 90b0b44:	e0bff617 	ldw	r2,-40(fp)
 90b0b48:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 90b0b4c:	e0bff617 	ldw	r2,-40(fp)
 90b0b50:	10800b0b 	ldhu	r2,44(r2)
 90b0b54:	10810014 	ori	r2,r2,1024
 90b0b58:	1007883a 	mov	r3,r2
 90b0b5c:	e0bff617 	ldw	r2,-40(fp)
 90b0b60:	10c00b0d 	sth	r3,44(r2)
      break;
 90b0b64:	00000206 	br	90b0b70 <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 90b0b68:	00801b44 	movi	r2,109
 90b0b6c:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 90b0b70:	e0bffa17 	ldw	r2,-24(fp)
}
 90b0b74:	e037883a 	mov	sp,fp
 90b0b78:	dfc00117 	ldw	ra,4(sp)
 90b0b7c:	df000017 	ldw	fp,0(sp)
 90b0b80:	dec00204 	addi	sp,sp,8
 90b0b84:	f800283a 	ret

090b0b88 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 90b0b88:	defff304 	addi	sp,sp,-52
 90b0b8c:	dfc00c15 	stw	ra,48(sp)
 90b0b90:	df000b15 	stw	fp,44(sp)
 90b0b94:	df000b04 	addi	fp,sp,44
 90b0b98:	e13ffb15 	stw	r4,-20(fp)
 90b0b9c:	e17ffc15 	stw	r5,-16(fp)
 90b0ba0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90b0ba4:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 90b0ba8:	e0bffd17 	ldw	r2,-12(fp)
 90b0bac:	1004c03a 	cmpne	r2,r2,zero
 90b0bb0:	1000031e 	bne	r2,zero,90b0bc0 <sogetopt+0x38>
   {
      return ENP_PARAM;
 90b0bb4:	00bffd84 	movi	r2,-10
 90b0bb8:	e0bffe15 	stw	r2,-8(fp)
 90b0bbc:	00013c06 	br	90b10b0 <sogetopt+0x528>
   }

   switch (optname) 
 90b0bc0:	e0fffc17 	ldw	r3,-16(fp)
 90b0bc4:	e0ffff15 	stw	r3,-4(fp)
 90b0bc8:	e0ffff17 	ldw	r3,-4(fp)
 90b0bcc:	188400e0 	cmpeqi	r2,r3,4099
 90b0bd0:	10008f1e 	bne	r2,zero,90b0e10 <sogetopt+0x288>
 90b0bd4:	e0ffff17 	ldw	r3,-4(fp)
 90b0bd8:	18840108 	cmpgei	r2,r3,4100
 90b0bdc:	10002e1e 	bne	r2,zero,90b0c98 <sogetopt+0x110>
 90b0be0:	e0ffff17 	ldw	r3,-4(fp)
 90b0be4:	18800420 	cmpeqi	r2,r3,16
 90b0be8:	1000821e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0bec:	e0ffff17 	ldw	r3,-4(fp)
 90b0bf0:	18800448 	cmpgei	r2,r3,17
 90b0bf4:	1000111e 	bne	r2,zero,90b0c3c <sogetopt+0xb4>
 90b0bf8:	e0ffff17 	ldw	r3,-4(fp)
 90b0bfc:	18800220 	cmpeqi	r2,r3,8
 90b0c00:	10007c1e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0c04:	e0ffff17 	ldw	r3,-4(fp)
 90b0c08:	18800248 	cmpgei	r2,r3,9
 90b0c0c:	1000071e 	bne	r2,zero,90b0c2c <sogetopt+0xa4>
 90b0c10:	e0ffff17 	ldw	r3,-4(fp)
 90b0c14:	188000a0 	cmpeqi	r2,r3,2
 90b0c18:	1000eb1e 	bne	r2,zero,90b0fc8 <sogetopt+0x440>
 90b0c1c:	e0ffff17 	ldw	r3,-4(fp)
 90b0c20:	18800120 	cmpeqi	r2,r3,4
 90b0c24:	1000731e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0c28:	00011c06 	br	90b109c <sogetopt+0x514>
 90b0c2c:	e0ffff17 	ldw	r3,-4(fp)
 90b0c30:	18800308 	cmpgei	r2,r3,12
 90b0c34:	1001191e 	bne	r2,zero,90b109c <sogetopt+0x514>
 90b0c38:	0000dd06 	br	90b0fb0 <sogetopt+0x428>
 90b0c3c:	e0ffff17 	ldw	r3,-4(fp)
 90b0c40:	18804020 	cmpeqi	r2,r3,256
 90b0c44:	10006b1e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0c48:	e0ffff17 	ldw	r3,-4(fp)
 90b0c4c:	18804048 	cmpgei	r2,r3,257
 90b0c50:	1000071e 	bne	r2,zero,90b0c70 <sogetopt+0xe8>
 90b0c54:	e0ffff17 	ldw	r3,-4(fp)
 90b0c58:	18800820 	cmpeqi	r2,r3,32
 90b0c5c:	1000651e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0c60:	e0ffff17 	ldw	r3,-4(fp)
 90b0c64:	18802020 	cmpeqi	r2,r3,128
 90b0c68:	1000531e 	bne	r2,zero,90b0db8 <sogetopt+0x230>
 90b0c6c:	00010b06 	br	90b109c <sogetopt+0x514>
 90b0c70:	e0ffff17 	ldw	r3,-4(fp)
 90b0c74:	18840060 	cmpeqi	r2,r3,4097
 90b0c78:	10006f1e 	bne	r2,zero,90b0e38 <sogetopt+0x2b0>
 90b0c7c:	e0ffff17 	ldw	r3,-4(fp)
 90b0c80:	18840088 	cmpgei	r2,r3,4098
 90b0c84:	1000711e 	bne	r2,zero,90b0e4c <sogetopt+0x2c4>
 90b0c88:	e0ffff17 	ldw	r3,-4(fp)
 90b0c8c:	18808020 	cmpeqi	r2,r3,512
 90b0c90:	1000581e 	bne	r2,zero,90b0df4 <sogetopt+0x26c>
 90b0c94:	00010106 	br	90b109c <sogetopt+0x514>
 90b0c98:	e0ffff17 	ldw	r3,-4(fp)
 90b0c9c:	18840420 	cmpeqi	r2,r3,4112
 90b0ca0:	1000881e 	bne	r2,zero,90b0ec4 <sogetopt+0x33c>
 90b0ca4:	e0ffff17 	ldw	r3,-4(fp)
 90b0ca8:	18840448 	cmpgei	r2,r3,4113
 90b0cac:	1000171e 	bne	r2,zero,90b0d0c <sogetopt+0x184>
 90b0cb0:	e0ffff17 	ldw	r3,-4(fp)
 90b0cb4:	188401a0 	cmpeqi	r2,r3,4102
 90b0cb8:	1000a31e 	bne	r2,zero,90b0f48 <sogetopt+0x3c0>
 90b0cbc:	e0ffff17 	ldw	r3,-4(fp)
 90b0cc0:	188401c8 	cmpgei	r2,r3,4103
 90b0cc4:	1000071e 	bne	r2,zero,90b0ce4 <sogetopt+0x15c>
 90b0cc8:	e0ffff17 	ldw	r3,-4(fp)
 90b0ccc:	18840120 	cmpeqi	r2,r3,4100
 90b0cd0:	1000541e 	bne	r2,zero,90b0e24 <sogetopt+0x29c>
 90b0cd4:	e0ffff17 	ldw	r3,-4(fp)
 90b0cd8:	18840160 	cmpeqi	r2,r3,4101
 90b0cdc:	1000951e 	bne	r2,zero,90b0f34 <sogetopt+0x3ac>
 90b0ce0:	0000ee06 	br	90b109c <sogetopt+0x514>
 90b0ce4:	e0ffff17 	ldw	r3,-4(fp)
 90b0ce8:	18840220 	cmpeqi	r2,r3,4104
 90b0cec:	1000661e 	bne	r2,zero,90b0e88 <sogetopt+0x300>
 90b0cf0:	e0ffff17 	ldw	r3,-4(fp)
 90b0cf4:	18840210 	cmplti	r2,r3,4104
 90b0cf8:	10006b1e 	bne	r2,zero,90b0ea8 <sogetopt+0x320>
 90b0cfc:	e0ffff17 	ldw	r3,-4(fp)
 90b0d00:	18840260 	cmpeqi	r2,r3,4105
 90b0d04:	1000951e 	bne	r2,zero,90b0f5c <sogetopt+0x3d4>
 90b0d08:	0000e406 	br	90b109c <sogetopt+0x514>
 90b0d0c:	e0ffff17 	ldw	r3,-4(fp)
 90b0d10:	188404e0 	cmpeqi	r2,r3,4115
 90b0d14:	1000141e 	bne	r2,zero,90b0d68 <sogetopt+0x1e0>
 90b0d18:	e0ffff17 	ldw	r3,-4(fp)
 90b0d1c:	18840508 	cmpgei	r2,r3,4116
 90b0d20:	1000071e 	bne	r2,zero,90b0d40 <sogetopt+0x1b8>
 90b0d24:	e0ffff17 	ldw	r3,-4(fp)
 90b0d28:	18840460 	cmpeqi	r2,r3,4113
 90b0d2c:	10004c1e 	bne	r2,zero,90b0e60 <sogetopt+0x2d8>
 90b0d30:	e0ffff17 	ldw	r3,-4(fp)
 90b0d34:	188404a0 	cmpeqi	r2,r3,4114
 90b0d38:	10004e1e 	bne	r2,zero,90b0e74 <sogetopt+0x2ec>
 90b0d3c:	0000d706 	br	90b109c <sogetopt+0x514>
 90b0d40:	e0ffff17 	ldw	r3,-4(fp)
 90b0d44:	188800e0 	cmpeqi	r2,r3,8195
 90b0d48:	10005e1e 	bne	r2,zero,90b0ec4 <sogetopt+0x33c>
 90b0d4c:	e0ffff17 	ldw	r3,-4(fp)
 90b0d50:	18880120 	cmpeqi	r2,r3,8196
 90b0d54:	1000a81e 	bne	r2,zero,90b0ff8 <sogetopt+0x470>
 90b0d58:	e0ffff17 	ldw	r3,-4(fp)
 90b0d5c:	188405a0 	cmpeqi	r2,r3,4118
 90b0d60:	1000861e 	bne	r2,zero,90b0f7c <sogetopt+0x3f4>
 90b0d64:	0000cd06 	br	90b109c <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 90b0d68:	e0bffb17 	ldw	r2,-20(fp)
 90b0d6c:	1080088b 	ldhu	r2,34(r2)
 90b0d70:	10bfffcc 	andi	r2,r2,65535
 90b0d74:	1080008c 	andi	r2,r2,2
 90b0d78:	1005003a 	cmpeq	r2,r2,zero
 90b0d7c:	1000071e 	bne	r2,zero,90b0d9c <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 90b0d80:	e0fffd17 	ldw	r3,-12(fp)
 90b0d84:	e0bffb17 	ldw	r2,-20(fp)
 90b0d88:	10800117 	ldw	r2,4(r2)
 90b0d8c:	10800a17 	ldw	r2,40(r2)
 90b0d90:	10800a17 	ldw	r2,40(r2)
 90b0d94:	18800015 	stw	r2,0(r3)
 90b0d98:	0000c306 	br	90b10a8 <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 90b0d9c:	e0fffd17 	ldw	r3,-12(fp)
 90b0da0:	008243b4 	movhi	r2,2318
 90b0da4:	10b5e604 	addi	r2,r2,-10344
 90b0da8:	10800017 	ldw	r2,0(r2)
 90b0dac:	10800a17 	ldw	r2,40(r2)
 90b0db0:	18800015 	stw	r2,0(r3)
      break;
 90b0db4:	0000bc06 	br	90b10a8 <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 90b0db8:	e0bffd17 	ldw	r2,-12(fp)
 90b0dbc:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 90b0dc0:	e0bffb17 	ldw	r2,-20(fp)
 90b0dc4:	10800417 	ldw	r2,16(r2)
 90b0dc8:	10c0200c 	andi	r3,r2,128
 90b0dcc:	e0bff917 	ldw	r2,-28(fp)
 90b0dd0:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 90b0dd4:	e0bffb17 	ldw	r2,-20(fp)
 90b0dd8:	1080080b 	ldhu	r2,32(r2)
 90b0ddc:	10ffffcc 	andi	r3,r2,65535
 90b0de0:	18e0001c 	xori	r3,r3,32768
 90b0de4:	18e00004 	addi	r3,r3,-32768
 90b0de8:	e0bff917 	ldw	r2,-28(fp)
 90b0dec:	10c00115 	stw	r3,4(r2)
      }
      break;
 90b0df0:	0000ad06 	br	90b10a8 <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 90b0df4:	e13ffd17 	ldw	r4,-12(fp)
 90b0df8:	e0bffb17 	ldw	r2,-20(fp)
 90b0dfc:	10c00417 	ldw	r3,16(r2)
 90b0e00:	e0bffc17 	ldw	r2,-16(fp)
 90b0e04:	1884703a 	and	r2,r3,r2
 90b0e08:	20800015 	stw	r2,0(r4)
      break;
 90b0e0c:	0000a606 	br	90b10a8 <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 90b0e10:	e0fffd17 	ldw	r3,-12(fp)
 90b0e14:	e0bffb17 	ldw	r2,-20(fp)
 90b0e18:	10801617 	ldw	r2,88(r2)
 90b0e1c:	18800015 	stw	r2,0(r3)
      break;
 90b0e20:	0000a106 	br	90b10a8 <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 90b0e24:	e0fffd17 	ldw	r3,-12(fp)
 90b0e28:	e0bffb17 	ldw	r2,-20(fp)
 90b0e2c:	10800e17 	ldw	r2,56(r2)
 90b0e30:	18800015 	stw	r2,0(r3)
      break;
 90b0e34:	00009c06 	br	90b10a8 <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 90b0e38:	e0fffd17 	ldw	r3,-12(fp)
 90b0e3c:	e0bffb17 	ldw	r2,-20(fp)
 90b0e40:	10801317 	ldw	r2,76(r2)
 90b0e44:	18800015 	stw	r2,0(r3)
      break;
 90b0e48:	00009706 	br	90b10a8 <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 90b0e4c:	e0fffd17 	ldw	r3,-12(fp)
 90b0e50:	e0bffb17 	ldw	r2,-20(fp)
 90b0e54:	10800b17 	ldw	r2,44(r2)
 90b0e58:	18800015 	stw	r2,0(r3)
      break;
 90b0e5c:	00009206 	br	90b10a8 <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 90b0e60:	e0fffd17 	ldw	r3,-12(fp)
 90b0e64:	e0bffb17 	ldw	r2,-20(fp)
 90b0e68:	10800a17 	ldw	r2,40(r2)
 90b0e6c:	18800015 	stw	r2,0(r3)
      break;
 90b0e70:	00008d06 	br	90b10a8 <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 90b0e74:	e0fffd17 	ldw	r3,-12(fp)
 90b0e78:	e0bffb17 	ldw	r2,-20(fp)
 90b0e7c:	10801217 	ldw	r2,72(r2)
 90b0e80:	18800015 	stw	r2,0(r3)
      break;
 90b0e84:	00008806 	br	90b10a8 <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 90b0e88:	e0fffd17 	ldw	r3,-12(fp)
 90b0e8c:	e0bffb17 	ldw	r2,-20(fp)
 90b0e90:	10800983 	ldbu	r2,38(r2)
 90b0e94:	10803fcc 	andi	r2,r2,255
 90b0e98:	1080201c 	xori	r2,r2,128
 90b0e9c:	10bfe004 	addi	r2,r2,-128
 90b0ea0:	18800015 	stw	r2,0(r3)
      break;
 90b0ea4:	00008006 	br	90b10a8 <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 90b0ea8:	e0fffd17 	ldw	r3,-12(fp)
 90b0eac:	e0bffb17 	ldw	r2,-20(fp)
 90b0eb0:	10800617 	ldw	r2,24(r2)
 90b0eb4:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 90b0eb8:	e0bffb17 	ldw	r2,-20(fp)
 90b0ebc:	10000615 	stw	zero,24(r2)
      break;
 90b0ec0:	00007906 	br	90b10a8 <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90b0ec4:	e0bffb17 	ldw	r2,-20(fp)
 90b0ec8:	10800983 	ldbu	r2,38(r2)
 90b0ecc:	10803fcc 	andi	r2,r2,255
 90b0ed0:	1080201c 	xori	r2,r2,128
 90b0ed4:	10bfe004 	addi	r2,r2,-128
 90b0ed8:	10800060 	cmpeqi	r2,r2,1
 90b0edc:	1000031e 	bne	r2,zero,90b0eec <sogetopt+0x364>
      {
         error = EINVAL;
 90b0ee0:	00800584 	movi	r2,22
 90b0ee4:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0ee8:	00006f06 	br	90b10a8 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90b0eec:	e0bffb17 	ldw	r2,-20(fp)
 90b0ef0:	10800117 	ldw	r2,4(r2)
 90b0ef4:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 90b0ef8:	e0bff817 	ldw	r2,-32(fp)
 90b0efc:	10800917 	ldw	r2,36(r2)
 90b0f00:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 90b0f04:	e0bff717 	ldw	r2,-36(fp)
 90b0f08:	1004c03a 	cmpne	r2,r2,zero
 90b0f0c:	1000031e 	bne	r2,zero,90b0f1c <sogetopt+0x394>
      {
         error = ENOTCONN;
 90b0f10:	00802004 	movi	r2,128
 90b0f14:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b0f18:	00006306 	br	90b10a8 <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 90b0f1c:	e0fffd17 	ldw	r3,-12(fp)
 90b0f20:	e0bff717 	ldw	r2,-36(fp)
 90b0f24:	10800a0b 	ldhu	r2,40(r2)
 90b0f28:	10bfffcc 	andi	r2,r2,65535
 90b0f2c:	18800015 	stw	r2,0(r3)
      break;
 90b0f30:	00005d06 	br	90b10a8 <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 90b0f34:	e0bffd17 	ldw	r2,-12(fp)
 90b0f38:	e0fffb17 	ldw	r3,-20(fp)
 90b0f3c:	18c0198b 	ldhu	r3,102(r3)
 90b0f40:	10c0000d 	sth	r3,0(r2)
      break;
 90b0f44:	00005806 	br	90b10a8 <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 90b0f48:	e0bffd17 	ldw	r2,-12(fp)
 90b0f4c:	e0fffb17 	ldw	r3,-20(fp)
 90b0f50:	18c0118b 	ldhu	r3,70(r3)
 90b0f54:	10c0000d 	sth	r3,0(r2)
      break;
 90b0f58:	00005306 	br	90b10a8 <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 90b0f5c:	e0fffd17 	ldw	r3,-12(fp)
 90b0f60:	e0bffb17 	ldw	r2,-20(fp)
 90b0f64:	108009c3 	ldbu	r2,39(r2)
 90b0f68:	10803fcc 	andi	r2,r2,255
 90b0f6c:	1080201c 	xori	r2,r2,128
 90b0f70:	10bfe004 	addi	r2,r2,-128
 90b0f74:	18800015 	stw	r2,0(r3)
      break;
 90b0f78:	00004b06 	br	90b10a8 <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 90b0f7c:	e0bffb17 	ldw	r2,-20(fp)
 90b0f80:	1080088b 	ldhu	r2,34(r2)
 90b0f84:	10bfffcc 	andi	r2,r2,65535
 90b0f88:	1080400c 	andi	r2,r2,256
 90b0f8c:	1005003a 	cmpeq	r2,r2,zero
 90b0f90:	1000041e 	bne	r2,zero,90b0fa4 <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 90b0f94:	e0fffd17 	ldw	r3,-12(fp)
 90b0f98:	00800044 	movi	r2,1
 90b0f9c:	18800015 	stw	r2,0(r3)
 90b0fa0:	00004106 	br	90b10a8 <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 90b0fa4:	e0bffd17 	ldw	r2,-12(fp)
 90b0fa8:	10000015 	stw	zero,0(r2)
      break;
 90b0fac:	00003e06 	br	90b10a8 <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 90b0fb0:	e13ffc17 	ldw	r4,-16(fp)
 90b0fb4:	e17ffb17 	ldw	r5,-20(fp)
 90b0fb8:	e1bffd17 	ldw	r6,-12(fp)
 90b0fbc:	90c5dc40 	call	90c5dc4 <ip_getmoptions>
 90b0fc0:	e0bffa15 	stw	r2,-24(fp)
      break;
 90b0fc4:	00003806 	br	90b10a8 <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 90b0fc8:	e0bffb17 	ldw	r2,-20(fp)
 90b0fcc:	10800417 	ldw	r2,16(r2)
 90b0fd0:	1088000c 	andi	r2,r2,8192
 90b0fd4:	1005003a 	cmpeq	r2,r2,zero
 90b0fd8:	1000041e 	bne	r2,zero,90b0fec <sogetopt+0x464>
         *(int *)val = 1;
 90b0fdc:	e0fffd17 	ldw	r3,-12(fp)
 90b0fe0:	00800044 	movi	r2,1
 90b0fe4:	18800015 	stw	r2,0(r3)
 90b0fe8:	00002f06 	br	90b10a8 <sogetopt+0x520>
      else
         *(int *)val = 0;
 90b0fec:	e0bffd17 	ldw	r2,-12(fp)
 90b0ff0:	10000015 	stw	zero,0(r2)
      break;
 90b0ff4:	00002c06 	br	90b10a8 <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 90b0ff8:	e0bffb17 	ldw	r2,-20(fp)
 90b0ffc:	10800983 	ldbu	r2,38(r2)
 90b1000:	10803fcc 	andi	r2,r2,255
 90b1004:	1080201c 	xori	r2,r2,128
 90b1008:	10bfe004 	addi	r2,r2,-128
 90b100c:	10800060 	cmpeqi	r2,r2,1
 90b1010:	1000031e 	bne	r2,zero,90b1020 <sogetopt+0x498>
      {
         error = EINVAL;
 90b1014:	00800584 	movi	r2,22
 90b1018:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b101c:	00002206 	br	90b10a8 <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 90b1020:	e0bffb17 	ldw	r2,-20(fp)
 90b1024:	10800117 	ldw	r2,4(r2)
 90b1028:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 90b102c:	e0bff617 	ldw	r2,-40(fp)
 90b1030:	10800917 	ldw	r2,36(r2)
 90b1034:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 90b1038:	e0bff517 	ldw	r2,-44(fp)
 90b103c:	1004c03a 	cmpne	r2,r2,zero
 90b1040:	1000031e 	bne	r2,zero,90b1050 <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 90b1044:	00802004 	movi	r2,128
 90b1048:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b104c:	00001606 	br	90b10a8 <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 90b1050:	e0bffd17 	ldw	r2,-12(fp)
 90b1054:	1004c03a 	cmpne	r2,r2,zero
 90b1058:	1000031e 	bne	r2,zero,90b1068 <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 90b105c:	00bffd84 	movi	r2,-10
 90b1060:	e0bffa15 	stw	r2,-24(fp)
         break;
 90b1064:	00001006 	br	90b10a8 <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 90b1068:	e0bff517 	ldw	r2,-44(fp)
 90b106c:	10800b0b 	ldhu	r2,44(r2)
 90b1070:	10bfffcc 	andi	r2,r2,65535
 90b1074:	1080010c 	andi	r2,r2,4
 90b1078:	1005003a 	cmpeq	r2,r2,zero
 90b107c:	1000041e 	bne	r2,zero,90b1090 <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 90b1080:	e0fffd17 	ldw	r3,-12(fp)
 90b1084:	00800044 	movi	r2,1
 90b1088:	18800015 	stw	r2,0(r3)
 90b108c:	00000606 	br	90b10a8 <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 90b1090:	e0bffd17 	ldw	r2,-12(fp)
 90b1094:	10000015 	stw	zero,0(r2)

      break;
 90b1098:	00000306 	br	90b10a8 <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 90b109c:	00801b44 	movi	r2,109
 90b10a0:	e0bffe15 	stw	r2,-8(fp)
 90b10a4:	00000206 	br	90b10b0 <sogetopt+0x528>
   }
   return error;     /* no error */
 90b10a8:	e0fffa17 	ldw	r3,-24(fp)
 90b10ac:	e0fffe15 	stw	r3,-8(fp)
 90b10b0:	e0bffe17 	ldw	r2,-8(fp)
}
 90b10b4:	e037883a 	mov	sp,fp
 90b10b8:	dfc00117 	ldw	ra,4(sp)
 90b10bc:	df000017 	ldw	fp,0(sp)
 90b10c0:	dec00204 	addi	sp,sp,8
 90b10c4:	f800283a 	ret

090b10c8 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 90b10c8:	defffd04 	addi	sp,sp,-12
 90b10cc:	dfc00215 	stw	ra,8(sp)
 90b10d0:	df000115 	stw	fp,4(sp)
 90b10d4:	df000104 	addi	fp,sp,4
 90b10d8:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 90b10dc:	e0ffff17 	ldw	r3,-4(fp)
 90b10e0:	00803644 	movi	r2,217
 90b10e4:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 90b10e8:	e0bfff17 	ldw	r2,-4(fp)
 90b10ec:	11400a04 	addi	r5,r2,40
 90b10f0:	e13fff17 	ldw	r4,-4(fp)
 90b10f4:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b10f8:	e037883a 	mov	sp,fp
 90b10fc:	dfc00117 	ldw	ra,4(sp)
 90b1100:	df000017 	ldw	fp,0(sp)
 90b1104:	dec00204 	addi	sp,sp,8
 90b1108:	f800283a 	ret

090b110c <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 90b110c:	defffd04 	addi	sp,sp,-12
 90b1110:	dfc00215 	stw	ra,8(sp)
 90b1114:	df000115 	stw	fp,4(sp)
 90b1118:	df000104 	addi	fp,sp,4
 90b111c:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 90b1120:	e0bfff17 	ldw	r2,-4(fp)
 90b1124:	10c0088b 	ldhu	r3,34(r2)
 90b1128:	00bffd44 	movi	r2,-11
 90b112c:	1884703a 	and	r2,r3,r2
 90b1130:	1007883a 	mov	r3,r2
 90b1134:	e0bfff17 	ldw	r2,-4(fp)
 90b1138:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 90b113c:	e0bfff17 	ldw	r2,-4(fp)
 90b1140:	1080088b 	ldhu	r2,34(r2)
 90b1144:	10800114 	ori	r2,r2,4
 90b1148:	1007883a 	mov	r3,r2
 90b114c:	e0bfff17 	ldw	r2,-4(fp)
 90b1150:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 90b1154:	e0bfff17 	ldw	r2,-4(fp)
 90b1158:	10800904 	addi	r2,r2,36
 90b115c:	1009883a 	mov	r4,r2
 90b1160:	90a5e940 	call	90a5e94 <tcp_wakeup>
}
 90b1164:	e037883a 	mov	sp,fp
 90b1168:	dfc00117 	ldw	ra,4(sp)
 90b116c:	df000017 	ldw	fp,0(sp)
 90b1170:	dec00204 	addi	sp,sp,8
 90b1174:	f800283a 	ret

090b1178 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 90b1178:	defffc04 	addi	sp,sp,-16
 90b117c:	dfc00315 	stw	ra,12(sp)
 90b1180:	df000215 	stw	fp,8(sp)
 90b1184:	df000204 	addi	fp,sp,8
 90b1188:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 90b118c:	e0bfff17 	ldw	r2,-4(fp)
 90b1190:	10801b17 	ldw	r2,108(r2)
 90b1194:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 90b1198:	e0bffe17 	ldw	r2,-8(fp)
 90b119c:	1005003a 	cmpeq	r2,r2,zero
 90b11a0:	1000141e 	bne	r2,zero,90b11f4 <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 90b11a4:	e13fff17 	ldw	r4,-4(fp)
 90b11a8:	000b883a 	mov	r5,zero
 90b11ac:	90b16840 	call	90b1684 <soqremque>
 90b11b0:	1004c03a 	cmpne	r2,r2,zero
 90b11b4:	1000031e 	bne	r2,zero,90b11c4 <soisconnected+0x4c>
         panic("soisconnected");
 90b11b8:	01024374 	movhi	r4,2317
 90b11bc:	21025404 	addi	r4,r4,2384
 90b11c0:	90a537c0 	call	90a537c <panic>
      soqinsque(head, so, 1);
 90b11c4:	e13ffe17 	ldw	r4,-8(fp)
 90b11c8:	e17fff17 	ldw	r5,-4(fp)
 90b11cc:	01800044 	movi	r6,1
 90b11d0:	90b15d80 	call	90b15d8 <soqinsque>
      sorwakeup(head);
 90b11d4:	e0bffe17 	ldw	r2,-8(fp)
 90b11d8:	11400a04 	addi	r5,r2,40
 90b11dc:	e13ffe17 	ldw	r4,-8(fp)
 90b11e0:	90b18e40 	call	90b18e4 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 90b11e4:	e0bffe17 	ldw	r2,-8(fp)
 90b11e8:	10800904 	addi	r2,r2,36
 90b11ec:	1009883a 	mov	r4,r2
 90b11f0:	90a5e940 	call	90a5e94 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90b11f4:	e0bfff17 	ldw	r2,-4(fp)
 90b11f8:	10c0088b 	ldhu	r3,34(r2)
 90b11fc:	00bffcc4 	movi	r2,-13
 90b1200:	1884703a 	and	r2,r3,r2
 90b1204:	1007883a 	mov	r3,r2
 90b1208:	e0bfff17 	ldw	r2,-4(fp)
 90b120c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 90b1210:	e0bfff17 	ldw	r2,-4(fp)
 90b1214:	1080088b 	ldhu	r2,34(r2)
 90b1218:	10800094 	ori	r2,r2,2
 90b121c:	1007883a 	mov	r3,r2
 90b1220:	e0bfff17 	ldw	r2,-4(fp)
 90b1224:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 90b1228:	e0bfff17 	ldw	r2,-4(fp)
 90b122c:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 90b1230:	e0bfff17 	ldw	r2,-4(fp)
 90b1234:	10800904 	addi	r2,r2,36
 90b1238:	1009883a 	mov	r4,r2
 90b123c:	90a5e940 	call	90a5e94 <tcp_wakeup>
   sorwakeup (so);
 90b1240:	e0bfff17 	ldw	r2,-4(fp)
 90b1244:	11400a04 	addi	r5,r2,40
 90b1248:	e13fff17 	ldw	r4,-4(fp)
 90b124c:	90b18e40 	call	90b18e4 <sbwakeup>
   sowwakeup (so);
 90b1250:	e0bfff17 	ldw	r2,-4(fp)
 90b1254:	11401204 	addi	r5,r2,72
 90b1258:	e13fff17 	ldw	r4,-4(fp)
 90b125c:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b1260:	e037883a 	mov	sp,fp
 90b1264:	dfc00117 	ldw	ra,4(sp)
 90b1268:	df000017 	ldw	fp,0(sp)
 90b126c:	dec00204 	addi	sp,sp,8
 90b1270:	f800283a 	ret

090b1274 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 90b1274:	defffd04 	addi	sp,sp,-12
 90b1278:	dfc00215 	stw	ra,8(sp)
 90b127c:	df000115 	stw	fp,4(sp)
 90b1280:	df000104 	addi	fp,sp,4
 90b1284:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 90b1288:	e0bfff17 	ldw	r2,-4(fp)
 90b128c:	10c0088b 	ldhu	r3,34(r2)
 90b1290:	00bffec4 	movi	r2,-5
 90b1294:	1884703a 	and	r2,r3,r2
 90b1298:	1007883a 	mov	r3,r2
 90b129c:	e0bfff17 	ldw	r2,-4(fp)
 90b12a0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 90b12a4:	e0bfff17 	ldw	r2,-4(fp)
 90b12a8:	1080088b 	ldhu	r2,34(r2)
 90b12ac:	10800e14 	ori	r2,r2,56
 90b12b0:	1007883a 	mov	r3,r2
 90b12b4:	e0bfff17 	ldw	r2,-4(fp)
 90b12b8:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 90b12bc:	e0bfff17 	ldw	r2,-4(fp)
 90b12c0:	10800904 	addi	r2,r2,36
 90b12c4:	1009883a 	mov	r4,r2
 90b12c8:	90a5e940 	call	90a5e94 <tcp_wakeup>
   sowwakeup (so);
 90b12cc:	e0bfff17 	ldw	r2,-4(fp)
 90b12d0:	11401204 	addi	r5,r2,72
 90b12d4:	e13fff17 	ldw	r4,-4(fp)
 90b12d8:	90b18e40 	call	90b18e4 <sbwakeup>
   sorwakeup (so);
 90b12dc:	e0bfff17 	ldw	r2,-4(fp)
 90b12e0:	11400a04 	addi	r5,r2,40
 90b12e4:	e13fff17 	ldw	r4,-4(fp)
 90b12e8:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b12ec:	e037883a 	mov	sp,fp
 90b12f0:	dfc00117 	ldw	ra,4(sp)
 90b12f4:	df000017 	ldw	fp,0(sp)
 90b12f8:	dec00204 	addi	sp,sp,8
 90b12fc:	f800283a 	ret

090b1300 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 90b1300:	defffd04 	addi	sp,sp,-12
 90b1304:	dfc00215 	stw	ra,8(sp)
 90b1308:	df000115 	stw	fp,4(sp)
 90b130c:	df000104 	addi	fp,sp,4
 90b1310:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 90b1314:	e0bfff17 	ldw	r2,-4(fp)
 90b1318:	1080088b 	ldhu	r2,34(r2)
 90b131c:	10bfffcc 	andi	r2,r2,65535
 90b1320:	1080010c 	andi	r2,r2,4
 90b1324:	1005003a 	cmpeq	r2,r2,zero
 90b1328:	1000061e 	bne	r2,zero,90b1344 <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 90b132c:	e0bfff17 	ldw	r2,-4(fp)
 90b1330:	1080088b 	ldhu	r2,34(r2)
 90b1334:	10880014 	ori	r2,r2,8192
 90b1338:	1007883a 	mov	r3,r2
 90b133c:	e0bfff17 	ldw	r2,-4(fp)
 90b1340:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 90b1344:	e0bfff17 	ldw	r2,-4(fp)
 90b1348:	10c0088b 	ldhu	r3,34(r2)
 90b134c:	00bffc44 	movi	r2,-15
 90b1350:	1884703a 	and	r2,r3,r2
 90b1354:	1007883a 	mov	r3,r2
 90b1358:	e0bfff17 	ldw	r2,-4(fp)
 90b135c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 90b1360:	e0bfff17 	ldw	r2,-4(fp)
 90b1364:	1080088b 	ldhu	r2,34(r2)
 90b1368:	10800c14 	ori	r2,r2,48
 90b136c:	1007883a 	mov	r3,r2
 90b1370:	e0bfff17 	ldw	r2,-4(fp)
 90b1374:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 90b1378:	e0bfff17 	ldw	r2,-4(fp)
 90b137c:	10800904 	addi	r2,r2,36
 90b1380:	1009883a 	mov	r4,r2
 90b1384:	90a5e940 	call	90a5e94 <tcp_wakeup>
   sowwakeup (so);
 90b1388:	e0bfff17 	ldw	r2,-4(fp)
 90b138c:	11401204 	addi	r5,r2,72
 90b1390:	e13fff17 	ldw	r4,-4(fp)
 90b1394:	90b18e40 	call	90b18e4 <sbwakeup>
   sorwakeup (so);
 90b1398:	e0bfff17 	ldw	r2,-4(fp)
 90b139c:	11400a04 	addi	r5,r2,40
 90b13a0:	e13fff17 	ldw	r4,-4(fp)
 90b13a4:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b13a8:	e037883a 	mov	sp,fp
 90b13ac:	dfc00117 	ldw	ra,4(sp)
 90b13b0:	df000017 	ldw	fp,0(sp)
 90b13b4:	dec00204 	addi	sp,sp,8
 90b13b8:	f800283a 	ret

090b13bc <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 90b13bc:	defffa04 	addi	sp,sp,-24
 90b13c0:	dfc00515 	stw	ra,20(sp)
 90b13c4:	df000415 	stw	fp,16(sp)
 90b13c8:	df000404 	addi	fp,sp,16
 90b13cc:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 90b13d0:	e0bffe17 	ldw	r2,-8(fp)
 90b13d4:	10801e43 	ldbu	r2,121(r2)
 90b13d8:	10c03fcc 	andi	r3,r2,255
 90b13dc:	18c0201c 	xori	r3,r3,128
 90b13e0:	18ffe004 	addi	r3,r3,-128
 90b13e4:	e0bffe17 	ldw	r2,-8(fp)
 90b13e8:	10801e03 	ldbu	r2,120(r2)
 90b13ec:	10803fcc 	andi	r2,r2,255
 90b13f0:	1080201c 	xori	r2,r2,128
 90b13f4:	10bfe004 	addi	r2,r2,-128
 90b13f8:	1889883a 	add	r4,r3,r2
 90b13fc:	e0bffe17 	ldw	r2,-8(fp)
 90b1400:	10801e83 	ldbu	r2,122(r2)
 90b1404:	10c03fcc 	andi	r3,r2,255
 90b1408:	18c0201c 	xori	r3,r3,128
 90b140c:	18ffe004 	addi	r3,r3,-128
 90b1410:	1805883a 	mov	r2,r3
 90b1414:	1085883a 	add	r2,r2,r2
 90b1418:	10c7883a 	add	r3,r2,r3
 90b141c:	1804d7fa 	srli	r2,r3,31
 90b1420:	10c5883a 	add	r2,r2,r3
 90b1424:	1005d07a 	srai	r2,r2,1
 90b1428:	11006416 	blt	r2,r4,90b15bc <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 90b142c:	01002104 	movi	r4,132
 90b1430:	90aaefc0 	call	90aaefc <npalloc>
 90b1434:	e0bffd15 	stw	r2,-12(fp)
 90b1438:	e0bffd17 	ldw	r2,-12(fp)
 90b143c:	1005003a 	cmpeq	r2,r2,zero
 90b1440:	10005e1e 	bne	r2,zero,90b15bc <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 90b1444:	e0bffd17 	ldw	r2,-12(fp)
 90b1448:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 90b144c:	e17ffd17 	ldw	r5,-12(fp)
 90b1450:	010243b4 	movhi	r4,2318
 90b1454:	21372304 	addi	r4,r4,-9076
 90b1458:	90a9e080 	call	90a9e08 <putq>
   so->so_type = head->so_type;
 90b145c:	e0bffe17 	ldw	r2,-8(fp)
 90b1460:	10c00983 	ldbu	r3,38(r2)
 90b1464:	e0bffd17 	ldw	r2,-12(fp)
 90b1468:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 90b146c:	e0bffe17 	ldw	r2,-8(fp)
 90b1470:	10c00417 	ldw	r3,16(r2)
 90b1474:	00bfff44 	movi	r2,-3
 90b1478:	1886703a 	and	r3,r3,r2
 90b147c:	e0bffd17 	ldw	r2,-12(fp)
 90b1480:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 90b1484:	e0bffe17 	ldw	r2,-8(fp)
 90b1488:	10c0080b 	ldhu	r3,32(r2)
 90b148c:	e0bffd17 	ldw	r2,-12(fp)
 90b1490:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 90b1494:	e0bffe17 	ldw	r2,-8(fp)
 90b1498:	1080088b 	ldhu	r2,34(r2)
 90b149c:	10800054 	ori	r2,r2,1
 90b14a0:	1007883a 	mov	r3,r2
 90b14a4:	e0bffd17 	ldw	r2,-12(fp)
 90b14a8:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 90b14ac:	e0bffe17 	ldw	r2,-8(fp)
 90b14b0:	10c00217 	ldw	r3,8(r2)
 90b14b4:	e0bffd17 	ldw	r2,-12(fp)
 90b14b8:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 90b14bc:	e0bffe17 	ldw	r2,-8(fp)
 90b14c0:	10c0090b 	ldhu	r3,36(r2)
 90b14c4:	e0bffd17 	ldw	r2,-12(fp)
 90b14c8:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 90b14cc:	00824374 	movhi	r2,2317
 90b14d0:	108ec404 	addi	r2,r2,15120
 90b14d4:	10c00017 	ldw	r3,0(r2)
 90b14d8:	e0bffd17 	ldw	r2,-12(fp)
 90b14dc:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 90b14e0:	00824374 	movhi	r2,2317
 90b14e4:	108ec304 	addi	r2,r2,15116
 90b14e8:	10c00017 	ldw	r3,0(r2)
 90b14ec:	e0bffd17 	ldw	r2,-12(fp)
 90b14f0:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 90b14f4:	e13ffe17 	ldw	r4,-8(fp)
 90b14f8:	e17ffd17 	ldw	r5,-12(fp)
 90b14fc:	000d883a 	mov	r6,zero
 90b1500:	90b15d80 	call	90b15d8 <soqinsque>
   so->so_req = PRU_ATTACH;
 90b1504:	e0bffd17 	ldw	r2,-12(fp)
 90b1508:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 90b150c:	e0bffe17 	ldw	r2,-8(fp)
 90b1510:	10c00517 	ldw	r3,20(r2)
 90b1514:	e0bffd17 	ldw	r2,-12(fp)
 90b1518:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 90b151c:	e0bffd17 	ldw	r2,-12(fp)
 90b1520:	10800217 	ldw	r2,8(r2)
 90b1524:	10800317 	ldw	r2,12(r2)
 90b1528:	e13ffd17 	ldw	r4,-12(fp)
 90b152c:	000b883a 	mov	r5,zero
 90b1530:	000d883a 	mov	r6,zero
 90b1534:	103ee83a 	callr	r2
 90b1538:	1004c03a 	cmpne	r2,r2,zero
 90b153c:	1000161e 	bne	r2,zero,90b1598 <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 90b1540:	00824374 	movhi	r2,2317
 90b1544:	108f5404 	addi	r2,r2,15696
 90b1548:	10800003 	ldbu	r2,0(r2)
 90b154c:	10803fcc 	andi	r2,r2,255
 90b1550:	1005003a 	cmpeq	r2,r2,zero
 90b1554:	10000d1e 	bne	r2,zero,90b158c <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 90b1558:	00824374 	movhi	r2,2317
 90b155c:	108f5204 	addi	r2,r2,15688
 90b1560:	10800017 	ldw	r2,0(r2)
 90b1564:	e13ffd17 	ldw	r4,-12(fp)
 90b1568:	103ee83a 	callr	r2
 90b156c:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 90b1570:	e0bffc17 	ldw	r2,-16(fp)
 90b1574:	1004c03a 	cmpne	r2,r2,zero
 90b1578:	1000071e 	bne	r2,zero,90b1598 <sonewconn+0x1dc>
      so->owner = head->owner;
 90b157c:	e0bffe17 	ldw	r2,-8(fp)
 90b1580:	10c02003 	ldbu	r3,128(r2)
 90b1584:	e0bffd17 	ldw	r2,-12(fp)
 90b1588:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 90b158c:	e0bffd17 	ldw	r2,-12(fp)
 90b1590:	e0bfff15 	stw	r2,-4(fp)
 90b1594:	00000a06 	br	90b15c0 <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 90b1598:	e13ffd17 	ldw	r4,-12(fp)
 90b159c:	000b883a 	mov	r5,zero
 90b15a0:	90b16840 	call	90b1684 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 90b15a4:	010243b4 	movhi	r4,2318
 90b15a8:	21372304 	addi	r4,r4,-9076
 90b15ac:	e17ffd17 	ldw	r5,-12(fp)
 90b15b0:	90a9eb80 	call	90a9eb8 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 90b15b4:	e13ffd17 	ldw	r4,-12(fp)
 90b15b8:	90aaff00 	call	90aaff0 <npfree>
bad:
   return ((struct socket *)0);
 90b15bc:	e03fff15 	stw	zero,-4(fp)
 90b15c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90b15c4:	e037883a 	mov	sp,fp
 90b15c8:	dfc00117 	ldw	ra,4(sp)
 90b15cc:	df000017 	ldw	fp,0(sp)
 90b15d0:	dec00204 	addi	sp,sp,8
 90b15d4:	f800283a 	ret

090b15d8 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 90b15d8:	defffc04 	addi	sp,sp,-16
 90b15dc:	df000315 	stw	fp,12(sp)
 90b15e0:	df000304 	addi	fp,sp,12
 90b15e4:	e13ffd15 	stw	r4,-12(fp)
 90b15e8:	e17ffe15 	stw	r5,-8(fp)
 90b15ec:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 90b15f0:	e0fffe17 	ldw	r3,-8(fp)
 90b15f4:	e0bffd17 	ldw	r2,-12(fp)
 90b15f8:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 90b15fc:	e0bfff17 	ldw	r2,-4(fp)
 90b1600:	1004c03a 	cmpne	r2,r2,zero
 90b1604:	10000e1e 	bne	r2,zero,90b1640 <soqinsque+0x68>
   {
      head->so_q0len++;
 90b1608:	e0bffd17 	ldw	r2,-12(fp)
 90b160c:	10801e03 	ldbu	r2,120(r2)
 90b1610:	10800044 	addi	r2,r2,1
 90b1614:	1007883a 	mov	r3,r2
 90b1618:	e0bffd17 	ldw	r2,-12(fp)
 90b161c:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 90b1620:	e0bffd17 	ldw	r2,-12(fp)
 90b1624:	10c01c17 	ldw	r3,112(r2)
 90b1628:	e0bffe17 	ldw	r2,-8(fp)
 90b162c:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 90b1630:	e0fffd17 	ldw	r3,-12(fp)
 90b1634:	e0bffe17 	ldw	r2,-8(fp)
 90b1638:	18801c15 	stw	r2,112(r3)
 90b163c:	00000d06 	br	90b1674 <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 90b1640:	e0bffd17 	ldw	r2,-12(fp)
 90b1644:	10801e43 	ldbu	r2,121(r2)
 90b1648:	10800044 	addi	r2,r2,1
 90b164c:	1007883a 	mov	r3,r2
 90b1650:	e0bffd17 	ldw	r2,-12(fp)
 90b1654:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 90b1658:	e0bffd17 	ldw	r2,-12(fp)
 90b165c:	10c01d17 	ldw	r3,116(r2)
 90b1660:	e0bffe17 	ldw	r2,-8(fp)
 90b1664:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 90b1668:	e0fffd17 	ldw	r3,-12(fp)
 90b166c:	e0bffe17 	ldw	r2,-8(fp)
 90b1670:	18801d15 	stw	r2,116(r3)
   }
}
 90b1674:	e037883a 	mov	sp,fp
 90b1678:	df000017 	ldw	fp,0(sp)
 90b167c:	dec00104 	addi	sp,sp,4
 90b1680:	f800283a 	ret

090b1684 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 90b1684:	defff804 	addi	sp,sp,-32
 90b1688:	df000715 	stw	fp,28(sp)
 90b168c:	df000704 	addi	fp,sp,28
 90b1690:	e13ffc15 	stw	r4,-16(fp)
 90b1694:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 90b1698:	e0bffc17 	ldw	r2,-16(fp)
 90b169c:	10801b17 	ldw	r2,108(r2)
 90b16a0:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 90b16a4:	e0bffb17 	ldw	r2,-20(fp)
 90b16a8:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 90b16ac:	e0bffd17 	ldw	r2,-12(fp)
 90b16b0:	1005003a 	cmpeq	r2,r2,zero
 90b16b4:	1000041e 	bne	r2,zero,90b16c8 <soqremque+0x44>
 90b16b8:	e0bffa17 	ldw	r2,-24(fp)
 90b16bc:	10801d17 	ldw	r2,116(r2)
 90b16c0:	e0bfff15 	stw	r2,-4(fp)
 90b16c4:	00000306 	br	90b16d4 <soqremque+0x50>
 90b16c8:	e0bffa17 	ldw	r2,-24(fp)
 90b16cc:	10801c17 	ldw	r2,112(r2)
 90b16d0:	e0bfff15 	stw	r2,-4(fp)
 90b16d4:	e0bfff17 	ldw	r2,-4(fp)
 90b16d8:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 90b16dc:	e0fff917 	ldw	r3,-28(fp)
 90b16e0:	e0bffc17 	ldw	r2,-16(fp)
 90b16e4:	18800826 	beq	r3,r2,90b1708 <soqremque+0x84>
         break;
      if (next == head)
 90b16e8:	e0fff917 	ldw	r3,-28(fp)
 90b16ec:	e0bffb17 	ldw	r2,-20(fp)
 90b16f0:	1880021e 	bne	r3,r2,90b16fc <soqremque+0x78>
         return (0);
 90b16f4:	e03ffe15 	stw	zero,-8(fp)
 90b16f8:	00002506 	br	90b1790 <soqremque+0x10c>
      prev = next;
 90b16fc:	e0bff917 	ldw	r2,-28(fp)
 90b1700:	e0bffa15 	stw	r2,-24(fp)
   }
 90b1704:	003fe906 	br	90b16ac <soqremque+0x28>
   if (q == 0) 
 90b1708:	e0bffd17 	ldw	r2,-12(fp)
 90b170c:	1004c03a 	cmpne	r2,r2,zero
 90b1710:	10000b1e 	bne	r2,zero,90b1740 <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 90b1714:	e0bff917 	ldw	r2,-28(fp)
 90b1718:	10c01c17 	ldw	r3,112(r2)
 90b171c:	e0bffa17 	ldw	r2,-24(fp)
 90b1720:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 90b1724:	e0bffb17 	ldw	r2,-20(fp)
 90b1728:	10801e03 	ldbu	r2,120(r2)
 90b172c:	10bfffc4 	addi	r2,r2,-1
 90b1730:	1007883a 	mov	r3,r2
 90b1734:	e0bffb17 	ldw	r2,-20(fp)
 90b1738:	10c01e05 	stb	r3,120(r2)
 90b173c:	00000a06 	br	90b1768 <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 90b1740:	e0bff917 	ldw	r2,-28(fp)
 90b1744:	10c01d17 	ldw	r3,116(r2)
 90b1748:	e0bffa17 	ldw	r2,-24(fp)
 90b174c:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 90b1750:	e0bffb17 	ldw	r2,-20(fp)
 90b1754:	10801e43 	ldbu	r2,121(r2)
 90b1758:	10bfffc4 	addi	r2,r2,-1
 90b175c:	1007883a 	mov	r3,r2
 90b1760:	e0bffb17 	ldw	r2,-20(fp)
 90b1764:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 90b1768:	e0bff917 	ldw	r2,-28(fp)
 90b176c:	10001d15 	stw	zero,116(r2)
 90b1770:	e0bff917 	ldw	r2,-28(fp)
 90b1774:	10c01d17 	ldw	r3,116(r2)
 90b1778:	e0bff917 	ldw	r2,-28(fp)
 90b177c:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 90b1780:	e0bff917 	ldw	r2,-28(fp)
 90b1784:	10001b15 	stw	zero,108(r2)
   return 1;
 90b1788:	00800044 	movi	r2,1
 90b178c:	e0bffe15 	stw	r2,-8(fp)
 90b1790:	e0bffe17 	ldw	r2,-8(fp)
}
 90b1794:	e037883a 	mov	sp,fp
 90b1798:	df000017 	ldw	fp,0(sp)
 90b179c:	dec00104 	addi	sp,sp,4
 90b17a0:	f800283a 	ret

090b17a4 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 90b17a4:	defffd04 	addi	sp,sp,-12
 90b17a8:	dfc00215 	stw	ra,8(sp)
 90b17ac:	df000115 	stw	fp,4(sp)
 90b17b0:	df000104 	addi	fp,sp,4
 90b17b4:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 90b17b8:	e0bfff17 	ldw	r2,-4(fp)
 90b17bc:	1080088b 	ldhu	r2,34(r2)
 90b17c0:	10800414 	ori	r2,r2,16
 90b17c4:	1007883a 	mov	r3,r2
 90b17c8:	e0bfff17 	ldw	r2,-4(fp)
 90b17cc:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 90b17d0:	e0bfff17 	ldw	r2,-4(fp)
 90b17d4:	11401204 	addi	r5,r2,72
 90b17d8:	e13fff17 	ldw	r4,-4(fp)
 90b17dc:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b17e0:	e037883a 	mov	sp,fp
 90b17e4:	dfc00117 	ldw	ra,4(sp)
 90b17e8:	df000017 	ldw	fp,0(sp)
 90b17ec:	dec00204 	addi	sp,sp,8
 90b17f0:	f800283a 	ret

090b17f4 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 90b17f4:	defffd04 	addi	sp,sp,-12
 90b17f8:	dfc00215 	stw	ra,8(sp)
 90b17fc:	df000115 	stw	fp,4(sp)
 90b1800:	df000104 	addi	fp,sp,4
 90b1804:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 90b1808:	e0bfff17 	ldw	r2,-4(fp)
 90b180c:	1080088b 	ldhu	r2,34(r2)
 90b1810:	10800814 	ori	r2,r2,32
 90b1814:	1007883a 	mov	r3,r2
 90b1818:	e0bfff17 	ldw	r2,-4(fp)
 90b181c:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 90b1820:	e0bfff17 	ldw	r2,-4(fp)
 90b1824:	11400a04 	addi	r5,r2,40
 90b1828:	e13fff17 	ldw	r4,-4(fp)
 90b182c:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b1830:	e037883a 	mov	sp,fp
 90b1834:	dfc00117 	ldw	ra,4(sp)
 90b1838:	df000017 	ldw	fp,0(sp)
 90b183c:	dec00204 	addi	sp,sp,8
 90b1840:	f800283a 	ret

090b1844 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 90b1844:	defffe04 	addi	sp,sp,-8
 90b1848:	df000115 	stw	fp,4(sp)
 90b184c:	df000104 	addi	fp,sp,4
 90b1850:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 90b1854:	e0bfff17 	ldw	r2,-4(fp)
 90b1858:	1080070b 	ldhu	r2,28(r2)
 90b185c:	10800214 	ori	r2,r2,8
 90b1860:	1007883a 	mov	r3,r2
 90b1864:	e0bfff17 	ldw	r2,-4(fp)
 90b1868:	10c0070d 	sth	r3,28(r2)
}
 90b186c:	e037883a 	mov	sp,fp
 90b1870:	df000017 	ldw	fp,0(sp)
 90b1874:	dec00104 	addi	sp,sp,4
 90b1878:	f800283a 	ret

090b187c <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 90b187c:	defffd04 	addi	sp,sp,-12
 90b1880:	dfc00215 	stw	ra,8(sp)
 90b1884:	df000115 	stw	fp,4(sp)
 90b1888:	df000104 	addi	fp,sp,4
 90b188c:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 90b1890:	e0bfff17 	ldw	r2,-4(fp)
 90b1894:	1080070b 	ldhu	r2,28(r2)
 90b1898:	10800114 	ori	r2,r2,4
 90b189c:	1007883a 	mov	r3,r2
 90b18a0:	e0bfff17 	ldw	r2,-4(fp)
 90b18a4:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 90b18a8:	e0bfff17 	ldw	r2,-4(fp)
 90b18ac:	1009883a 	mov	r4,r2
 90b18b0:	90a5cf40 	call	90a5cf4 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 90b18b4:	e0bfff17 	ldw	r2,-4(fp)
 90b18b8:	10c0070b 	ldhu	r3,28(r2)
 90b18bc:	00bffec4 	movi	r2,-5
 90b18c0:	1884703a 	and	r2,r3,r2
 90b18c4:	1007883a 	mov	r3,r2
 90b18c8:	e0bfff17 	ldw	r2,-4(fp)
 90b18cc:	10c0070d 	sth	r3,28(r2)
}
 90b18d0:	e037883a 	mov	sp,fp
 90b18d4:	dfc00117 	ldw	ra,4(sp)
 90b18d8:	df000017 	ldw	fp,0(sp)
 90b18dc:	dec00204 	addi	sp,sp,8
 90b18e0:	f800283a 	ret

090b18e4 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 90b18e4:	defffc04 	addi	sp,sp,-16
 90b18e8:	dfc00315 	stw	ra,12(sp)
 90b18ec:	df000215 	stw	fp,8(sp)
 90b18f0:	df000204 	addi	fp,sp,8
 90b18f4:	e13ffe15 	stw	r4,-8(fp)
 90b18f8:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 90b18fc:	e0bfff17 	ldw	r2,-4(fp)
 90b1900:	1080070b 	ldhu	r2,28(r2)
 90b1904:	10bfffcc 	andi	r2,r2,65535
 90b1908:	1080020c 	andi	r2,r2,8
 90b190c:	1005003a 	cmpeq	r2,r2,zero
 90b1910:	10000d1e 	bne	r2,zero,90b1948 <sbwakeup+0x64>
   {
      select_wait = 0;
 90b1914:	00824374 	movhi	r2,2317
 90b1918:	108f3604 	addi	r2,r2,15576
 90b191c:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 90b1920:	01024374 	movhi	r4,2317
 90b1924:	210f3604 	addi	r4,r4,15576
 90b1928:	90a5e940 	call	90a5e94 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 90b192c:	e0bfff17 	ldw	r2,-4(fp)
 90b1930:	10c0070b 	ldhu	r3,28(r2)
 90b1934:	00bffdc4 	movi	r2,-9
 90b1938:	1884703a 	and	r2,r3,r2
 90b193c:	1007883a 	mov	r3,r2
 90b1940:	e0bfff17 	ldw	r2,-4(fp)
 90b1944:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 90b1948:	e0bfff17 	ldw	r2,-4(fp)
 90b194c:	1080070b 	ldhu	r2,28(r2)
 90b1950:	10bfffcc 	andi	r2,r2,65535
 90b1954:	1080010c 	andi	r2,r2,4
 90b1958:	1005003a 	cmpeq	r2,r2,zero
 90b195c:	1000031e 	bne	r2,zero,90b196c <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 90b1960:	e0bfff17 	ldw	r2,-4(fp)
 90b1964:	1009883a 	mov	r4,r2
 90b1968:	90a5e940 	call	90a5e94 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 90b196c:	e037883a 	mov	sp,fp
 90b1970:	dfc00117 	ldw	ra,4(sp)
 90b1974:	df000017 	ldw	fp,0(sp)
 90b1978:	dec00204 	addi	sp,sp,8
 90b197c:	f800283a 	ret

090b1980 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 90b1980:	defffa04 	addi	sp,sp,-24
 90b1984:	dfc00515 	stw	ra,20(sp)
 90b1988:	df000415 	stw	fp,16(sp)
 90b198c:	df000404 	addi	fp,sp,16
 90b1990:	e13ffc15 	stw	r4,-16(fp)
 90b1994:	e17ffd15 	stw	r5,-12(fp)
 90b1998:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 90b199c:	e0bffc17 	ldw	r2,-16(fp)
 90b19a0:	11001204 	addi	r4,r2,72
 90b19a4:	e17ffd17 	ldw	r5,-12(fp)
 90b19a8:	90b1a000 	call	90b1a00 <sbreserve>
 90b19ac:	1005003a 	cmpeq	r2,r2,zero
 90b19b0:	10000b1e 	bne	r2,zero,90b19e0 <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 90b19b4:	e0bffc17 	ldw	r2,-16(fp)
 90b19b8:	11000a04 	addi	r4,r2,40
 90b19bc:	e17ffe17 	ldw	r5,-8(fp)
 90b19c0:	90b1a000 	call	90b1a00 <sbreserve>
 90b19c4:	1005003a 	cmpeq	r2,r2,zero
 90b19c8:	1000021e 	bne	r2,zero,90b19d4 <soreserve+0x54>
      goto bad2;
   return (0);
 90b19cc:	e03fff15 	stw	zero,-4(fp)
 90b19d0:	00000506 	br	90b19e8 <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 90b19d4:	e0bffc17 	ldw	r2,-16(fp)
 90b19d8:	11001204 	addi	r4,r2,72
 90b19dc:	90b1a600 	call	90b1a60 <sbrelease>
bad:
   return (ENOBUFS);
 90b19e0:	00801a44 	movi	r2,105
 90b19e4:	e0bfff15 	stw	r2,-4(fp)
 90b19e8:	e0bfff17 	ldw	r2,-4(fp)
}
 90b19ec:	e037883a 	mov	sp,fp
 90b19f0:	dfc00117 	ldw	ra,4(sp)
 90b19f4:	df000017 	ldw	fp,0(sp)
 90b19f8:	dec00204 	addi	sp,sp,8
 90b19fc:	f800283a 	ret

090b1a00 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 90b1a00:	defffc04 	addi	sp,sp,-16
 90b1a04:	df000315 	stw	fp,12(sp)
 90b1a08:	df000304 	addi	fp,sp,12
 90b1a0c:	e13ffd15 	stw	r4,-12(fp)
 90b1a10:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 90b1a14:	e0fffd17 	ldw	r3,-12(fp)
 90b1a18:	e0bffe17 	ldw	r2,-8(fp)
 90b1a1c:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 90b1a20:	e0bffe17 	ldw	r2,-8(fp)
 90b1a24:	1085883a 	add	r2,r2,r2
 90b1a28:	e0bfff15 	stw	r2,-4(fp)
 90b1a2c:	e0ffff17 	ldw	r3,-4(fp)
 90b1a30:	18900070 	cmpltui	r2,r3,16385
 90b1a34:	1000021e 	bne	r2,zero,90b1a40 <sbreserve+0x40>
 90b1a38:	00900004 	movi	r2,16384
 90b1a3c:	e0bfff15 	stw	r2,-4(fp)
 90b1a40:	e0bffd17 	ldw	r2,-12(fp)
 90b1a44:	e0ffff17 	ldw	r3,-4(fp)
 90b1a48:	10c00315 	stw	r3,12(r2)
   return (1);
 90b1a4c:	00800044 	movi	r2,1
}
 90b1a50:	e037883a 	mov	sp,fp
 90b1a54:	df000017 	ldw	fp,0(sp)
 90b1a58:	dec00104 	addi	sp,sp,4
 90b1a5c:	f800283a 	ret

090b1a60 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 90b1a60:	defffd04 	addi	sp,sp,-12
 90b1a64:	dfc00215 	stw	ra,8(sp)
 90b1a68:	df000115 	stw	fp,4(sp)
 90b1a6c:	df000104 	addi	fp,sp,4
 90b1a70:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 90b1a74:	e13fff17 	ldw	r4,-4(fp)
 90b1a78:	90b20200 	call	90b2020 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 90b1a7c:	e0bfff17 	ldw	r2,-4(fp)
 90b1a80:	10000315 	stw	zero,12(r2)
 90b1a84:	e0bfff17 	ldw	r2,-4(fp)
 90b1a88:	10c00317 	ldw	r3,12(r2)
 90b1a8c:	e0bfff17 	ldw	r2,-4(fp)
 90b1a90:	10c00115 	stw	r3,4(r2)
}
 90b1a94:	e037883a 	mov	sp,fp
 90b1a98:	dfc00117 	ldw	ra,4(sp)
 90b1a9c:	df000017 	ldw	fp,0(sp)
 90b1aa0:	dec00204 	addi	sp,sp,8
 90b1aa4:	f800283a 	ret

090b1aa8 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 90b1aa8:	defffb04 	addi	sp,sp,-20
 90b1aac:	dfc00415 	stw	ra,16(sp)
 90b1ab0:	df000315 	stw	fp,12(sp)
 90b1ab4:	df000304 	addi	fp,sp,12
 90b1ab8:	e13ffe15 	stw	r4,-8(fp)
 90b1abc:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 90b1ac0:	e0bfff17 	ldw	r2,-4(fp)
 90b1ac4:	1005003a 	cmpeq	r2,r2,zero
 90b1ac8:	10001c1e 	bne	r2,zero,90b1b3c <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 90b1acc:	90aa6b80 	call	90aa6b8 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 90b1ad0:	e0bffe17 	ldw	r2,-8(fp)
 90b1ad4:	10800617 	ldw	r2,24(r2)
 90b1ad8:	e0bffd15 	stw	r2,-12(fp)
 90b1adc:	e0bffd17 	ldw	r2,-12(fp)
 90b1ae0:	1005003a 	cmpeq	r2,r2,zero
 90b1ae4:	1000101e 	bne	r2,zero,90b1b28 <sbappend+0x80>
   {
      while (n->m_act)
 90b1ae8:	00000306 	br	90b1af8 <sbappend+0x50>
         n = n->m_act;
 90b1aec:	e0bffd17 	ldw	r2,-12(fp)
 90b1af0:	10800717 	ldw	r2,28(r2)
 90b1af4:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 90b1af8:	e0bffd17 	ldw	r2,-12(fp)
 90b1afc:	10800717 	ldw	r2,28(r2)
 90b1b00:	1004c03a 	cmpne	r2,r2,zero
 90b1b04:	103ff91e 	bne	r2,zero,90b1aec <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 90b1b08:	00000306 	br	90b1b18 <sbappend+0x70>
         n = n->m_next;
 90b1b0c:	e0bffd17 	ldw	r2,-12(fp)
 90b1b10:	10800617 	ldw	r2,24(r2)
 90b1b14:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 90b1b18:	e0bffd17 	ldw	r2,-12(fp)
 90b1b1c:	10800617 	ldw	r2,24(r2)
 90b1b20:	1004c03a 	cmpne	r2,r2,zero
 90b1b24:	103ff91e 	bne	r2,zero,90b1b0c <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 90b1b28:	e13ffe17 	ldw	r4,-8(fp)
 90b1b2c:	e17fff17 	ldw	r5,-4(fp)
 90b1b30:	e1bffd17 	ldw	r6,-12(fp)
 90b1b34:	90b1e380 	call	90b1e38 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 90b1b38:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b1b3c:	e037883a 	mov	sp,fp
 90b1b40:	dfc00117 	ldw	ra,4(sp)
 90b1b44:	df000017 	ldw	fp,0(sp)
 90b1b48:	dec00204 	addi	sp,sp,8
 90b1b4c:	f800283a 	ret

090b1b50 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 90b1b50:	defffb04 	addi	sp,sp,-20
 90b1b54:	dfc00415 	stw	ra,16(sp)
 90b1b58:	df000315 	stw	fp,12(sp)
 90b1b5c:	df000304 	addi	fp,sp,12
 90b1b60:	e13ffe15 	stw	r4,-8(fp)
 90b1b64:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 90b1b68:	e0bfff17 	ldw	r2,-4(fp)
 90b1b6c:	1005003a 	cmpeq	r2,r2,zero
 90b1b70:	10002a1e 	bne	r2,zero,90b1c1c <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 90b1b74:	90aa6b80 	call	90aa6b8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 90b1b78:	e0bffe17 	ldw	r2,-8(fp)
 90b1b7c:	10800617 	ldw	r2,24(r2)
 90b1b80:	e0bffd15 	stw	r2,-12(fp)
 90b1b84:	e0bffd17 	ldw	r2,-12(fp)
 90b1b88:	1005003a 	cmpeq	r2,r2,zero
 90b1b8c:	1000081e 	bne	r2,zero,90b1bb0 <sbappendrecord+0x60>
      while (m->m_act)
 90b1b90:	00000306 	br	90b1ba0 <sbappendrecord+0x50>
      m = m->m_act;
 90b1b94:	e0bffd17 	ldw	r2,-12(fp)
 90b1b98:	10800717 	ldw	r2,28(r2)
 90b1b9c:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 90b1ba0:	e0bffd17 	ldw	r2,-12(fp)
 90b1ba4:	10800717 	ldw	r2,28(r2)
 90b1ba8:	1004c03a 	cmpne	r2,r2,zero
 90b1bac:	103ff91e 	bne	r2,zero,90b1b94 <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 90b1bb0:	e0bffe17 	ldw	r2,-8(fp)
 90b1bb4:	10c00017 	ldw	r3,0(r2)
 90b1bb8:	e0bfff17 	ldw	r2,-4(fp)
 90b1bbc:	10800217 	ldw	r2,8(r2)
 90b1bc0:	1887883a 	add	r3,r3,r2
 90b1bc4:	e0bffe17 	ldw	r2,-8(fp)
 90b1bc8:	10c00015 	stw	r3,0(r2)
   if (m)
 90b1bcc:	e0bffd17 	ldw	r2,-12(fp)
 90b1bd0:	1005003a 	cmpeq	r2,r2,zero
 90b1bd4:	1000041e 	bne	r2,zero,90b1be8 <sbappendrecord+0x98>
      m->m_act = m0;
 90b1bd8:	e0fffd17 	ldw	r3,-12(fp)
 90b1bdc:	e0bfff17 	ldw	r2,-4(fp)
 90b1be0:	18800715 	stw	r2,28(r3)
 90b1be4:	00000306 	br	90b1bf4 <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 90b1be8:	e0fffe17 	ldw	r3,-8(fp)
 90b1bec:	e0bfff17 	ldw	r2,-4(fp)
 90b1bf0:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 90b1bf4:	e0bfff17 	ldw	r2,-4(fp)
 90b1bf8:	10800617 	ldw	r2,24(r2)
 90b1bfc:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 90b1c00:	e0bfff17 	ldw	r2,-4(fp)
 90b1c04:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 90b1c08:	e13ffe17 	ldw	r4,-8(fp)
 90b1c0c:	e17ffd17 	ldw	r5,-12(fp)
 90b1c10:	e1bfff17 	ldw	r6,-4(fp)
 90b1c14:	90b1e380 	call	90b1e38 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 90b1c18:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b1c1c:	e037883a 	mov	sp,fp
 90b1c20:	dfc00117 	ldw	ra,4(sp)
 90b1c24:	df000017 	ldw	fp,0(sp)
 90b1c28:	dec00204 	addi	sp,sp,8
 90b1c2c:	f800283a 	ret

090b1c30 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 90b1c30:	defff604 	addi	sp,sp,-40
 90b1c34:	dfc00915 	stw	ra,36(sp)
 90b1c38:	df000815 	stw	fp,32(sp)
 90b1c3c:	df000804 	addi	fp,sp,32
 90b1c40:	e13ffb15 	stw	r4,-20(fp)
 90b1c44:	e17ffc15 	stw	r5,-16(fp)
 90b1c48:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 90b1c4c:	00800404 	movi	r2,16
 90b1c50:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 90b1c54:	90aa6b80 	call	90aa6b8 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 90b1c58:	e0bffd17 	ldw	r2,-12(fp)
 90b1c5c:	e0bffa15 	stw	r2,-24(fp)
 90b1c60:	00000806 	br	90b1c84 <sbappendaddr+0x54>
      space += m->m_len;
 90b1c64:	e0bffa17 	ldw	r2,-24(fp)
 90b1c68:	10c00217 	ldw	r3,8(r2)
 90b1c6c:	e0bff817 	ldw	r2,-32(fp)
 90b1c70:	1885883a 	add	r2,r3,r2
 90b1c74:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 90b1c78:	e0bffa17 	ldw	r2,-24(fp)
 90b1c7c:	10800617 	ldw	r2,24(r2)
 90b1c80:	e0bffa15 	stw	r2,-24(fp)
 90b1c84:	e0bffa17 	ldw	r2,-24(fp)
 90b1c88:	1004c03a 	cmpne	r2,r2,zero
 90b1c8c:	103ff51e 	bne	r2,zero,90b1c64 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 90b1c90:	e0bffb17 	ldw	r2,-20(fp)
 90b1c94:	10800117 	ldw	r2,4(r2)
 90b1c98:	1007883a 	mov	r3,r2
 90b1c9c:	e0bffb17 	ldw	r2,-20(fp)
 90b1ca0:	10800017 	ldw	r2,0(r2)
 90b1ca4:	1885c83a 	sub	r2,r3,r2
 90b1ca8:	1004803a 	cmplt	r2,r2,zero
 90b1cac:	1000071e 	bne	r2,zero,90b1ccc <sbappendaddr+0x9c>
 90b1cb0:	e0bffb17 	ldw	r2,-20(fp)
 90b1cb4:	10c00117 	ldw	r3,4(r2)
 90b1cb8:	e0bffb17 	ldw	r2,-20(fp)
 90b1cbc:	10800017 	ldw	r2,0(r2)
 90b1cc0:	1885c83a 	sub	r2,r3,r2
 90b1cc4:	e0bfff15 	stw	r2,-4(fp)
 90b1cc8:	00000106 	br	90b1cd0 <sbappendaddr+0xa0>
 90b1ccc:	e03fff15 	stw	zero,-4(fp)
 90b1cd0:	e0bff817 	ldw	r2,-32(fp)
 90b1cd4:	e0ffff17 	ldw	r3,-4(fp)
 90b1cd8:	1880030e 	bge	r3,r2,90b1ce8 <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 90b1cdc:	90aa7140 	call	90aa714 <irq_Unmask>
      return (0);
 90b1ce0:	e03ffe15 	stw	zero,-8(fp)
 90b1ce4:	00004e06 	br	90b1e20 <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 90b1ce8:	01000244 	movi	r4,9
 90b1cec:	01400404 	movi	r5,16
 90b1cf0:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b1cf4:	e0bffa15 	stw	r2,-24(fp)
 90b1cf8:	e0bffa17 	ldw	r2,-24(fp)
 90b1cfc:	1004c03a 	cmpne	r2,r2,zero
 90b1d00:	1000031e 	bne	r2,zero,90b1d10 <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 90b1d04:	90aa7140 	call	90aa714 <irq_Unmask>
      return 0;
 90b1d08:	e03ffe15 	stw	zero,-8(fp)
 90b1d0c:	00004406 	br	90b1e20 <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 90b1d10:	e0bffa17 	ldw	r2,-24(fp)
 90b1d14:	10800317 	ldw	r2,12(r2)
 90b1d18:	1009883a 	mov	r4,r2
 90b1d1c:	e0fffc17 	ldw	r3,-16(fp)
 90b1d20:	1880000b 	ldhu	r2,0(r3)
 90b1d24:	2080000d 	sth	r2,0(r4)
 90b1d28:	1880008b 	ldhu	r2,2(r3)
 90b1d2c:	2080008d 	sth	r2,2(r4)
 90b1d30:	1880010b 	ldhu	r2,4(r3)
 90b1d34:	2080010d 	sth	r2,4(r4)
 90b1d38:	1880018b 	ldhu	r2,6(r3)
 90b1d3c:	2080018d 	sth	r2,6(r4)
 90b1d40:	1880020b 	ldhu	r2,8(r3)
 90b1d44:	2080020d 	sth	r2,8(r4)
 90b1d48:	1880028b 	ldhu	r2,10(r3)
 90b1d4c:	2080028d 	sth	r2,10(r4)
 90b1d50:	1880030b 	ldhu	r2,12(r3)
 90b1d54:	2080030d 	sth	r2,12(r4)
 90b1d58:	1880038b 	ldhu	r2,14(r3)
 90b1d5c:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 90b1d60:	e0fffa17 	ldw	r3,-24(fp)
 90b1d64:	00800404 	movi	r2,16
 90b1d68:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 90b1d6c:	e0bffb17 	ldw	r2,-20(fp)
 90b1d70:	10c00017 	ldw	r3,0(r2)
 90b1d74:	e0bffa17 	ldw	r2,-24(fp)
 90b1d78:	10800217 	ldw	r2,8(r2)
 90b1d7c:	1887883a 	add	r3,r3,r2
 90b1d80:	e0bffb17 	ldw	r2,-20(fp)
 90b1d84:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 90b1d88:	e0bffb17 	ldw	r2,-20(fp)
 90b1d8c:	10800617 	ldw	r2,24(r2)
 90b1d90:	e0bff915 	stw	r2,-28(fp)
 90b1d94:	e0bff917 	ldw	r2,-28(fp)
 90b1d98:	1005003a 	cmpeq	r2,r2,zero
 90b1d9c:	10000c1e 	bne	r2,zero,90b1dd0 <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 90b1da0:	00000306 	br	90b1db0 <sbappendaddr+0x180>
         n = n->m_act;
 90b1da4:	e0bff917 	ldw	r2,-28(fp)
 90b1da8:	10800717 	ldw	r2,28(r2)
 90b1dac:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 90b1db0:	e0bff917 	ldw	r2,-28(fp)
 90b1db4:	10800717 	ldw	r2,28(r2)
 90b1db8:	1004c03a 	cmpne	r2,r2,zero
 90b1dbc:	103ff91e 	bne	r2,zero,90b1da4 <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 90b1dc0:	e0fff917 	ldw	r3,-28(fp)
 90b1dc4:	e0bffa17 	ldw	r2,-24(fp)
 90b1dc8:	18800715 	stw	r2,28(r3)
 90b1dcc:	00000306 	br	90b1ddc <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 90b1dd0:	e0fffb17 	ldw	r3,-20(fp)
 90b1dd4:	e0bffa17 	ldw	r2,-24(fp)
 90b1dd8:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 90b1ddc:	e0bffa17 	ldw	r2,-24(fp)
 90b1de0:	10800617 	ldw	r2,24(r2)
 90b1de4:	1005003a 	cmpeq	r2,r2,zero
 90b1de8:	1000031e 	bne	r2,zero,90b1df8 <sbappendaddr+0x1c8>
      m = m->m_next;
 90b1dec:	e0bffa17 	ldw	r2,-24(fp)
 90b1df0:	10800617 	ldw	r2,24(r2)
 90b1df4:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 90b1df8:	e0bffd17 	ldw	r2,-12(fp)
 90b1dfc:	1005003a 	cmpeq	r2,r2,zero
 90b1e00:	1000041e 	bne	r2,zero,90b1e14 <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 90b1e04:	e13ffb17 	ldw	r4,-20(fp)
 90b1e08:	e17ffd17 	ldw	r5,-12(fp)
 90b1e0c:	e1bffa17 	ldw	r6,-24(fp)
 90b1e10:	90b1e380 	call	90b1e38 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 90b1e14:	90aa7140 	call	90aa714 <irq_Unmask>
   return (1);
 90b1e18:	00800044 	movi	r2,1
 90b1e1c:	e0bffe15 	stw	r2,-8(fp)
 90b1e20:	e0bffe17 	ldw	r2,-8(fp)
}
 90b1e24:	e037883a 	mov	sp,fp
 90b1e28:	dfc00117 	ldw	ra,4(sp)
 90b1e2c:	df000017 	ldw	fp,0(sp)
 90b1e30:	dec00204 	addi	sp,sp,8
 90b1e34:	f800283a 	ret

090b1e38 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 90b1e38:	defffb04 	addi	sp,sp,-20
 90b1e3c:	dfc00415 	stw	ra,16(sp)
 90b1e40:	df000315 	stw	fp,12(sp)
 90b1e44:	df000304 	addi	fp,sp,12
 90b1e48:	e13ffd15 	stw	r4,-12(fp)
 90b1e4c:	e17ffe15 	stw	r5,-8(fp)
 90b1e50:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 90b1e54:	00006a06 	br	90b2000 <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 90b1e58:	e0bffe17 	ldw	r2,-8(fp)
 90b1e5c:	10800217 	ldw	r2,8(r2)
 90b1e60:	1004c03a 	cmpne	r2,r2,zero
 90b1e64:	1000041e 	bne	r2,zero,90b1e78 <sbcompress+0x40>
      {
         m = m_free(m);
 90b1e68:	e13ffe17 	ldw	r4,-8(fp)
 90b1e6c:	90ab4600 	call	90ab460 <m_free>
 90b1e70:	e0bffe15 	stw	r2,-8(fp)
         continue;
 90b1e74:	00006206 	br	90b2000 <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 90b1e78:	e0bffe17 	ldw	r2,-8(fp)
 90b1e7c:	10800817 	ldw	r2,32(r2)
 90b1e80:	10800060 	cmpeqi	r2,r2,1
 90b1e84:	1000101e 	bne	r2,zero,90b1ec8 <sbcompress+0x90>
 90b1e88:	e0bffe17 	ldw	r2,-8(fp)
 90b1e8c:	10800817 	ldw	r2,32(r2)
 90b1e90:	108000a0 	cmpeqi	r2,r2,2
 90b1e94:	10000c1e 	bne	r2,zero,90b1ec8 <sbcompress+0x90>
 90b1e98:	e0bffe17 	ldw	r2,-8(fp)
 90b1e9c:	10800817 	ldw	r2,32(r2)
 90b1ea0:	10800260 	cmpeqi	r2,r2,9
 90b1ea4:	1000081e 	bne	r2,zero,90b1ec8 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 90b1ea8:	e0bffe17 	ldw	r2,-8(fp)
 90b1eac:	11400817 	ldw	r5,32(r2)
 90b1eb0:	01024374 	movhi	r4,2317
 90b1eb4:	21025804 	addi	r4,r4,2400
 90b1eb8:	90833900 	call	9083390 <printf>
         panic ("sbcomp:bad");
 90b1ebc:	01024374 	movhi	r4,2317
 90b1ec0:	21025d04 	addi	r4,r4,2420
 90b1ec4:	90a537c0 	call	90a537c <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 90b1ec8:	e0bfff17 	ldw	r2,-4(fp)
 90b1ecc:	1005003a 	cmpeq	r2,r2,zero
 90b1ed0:	1000331e 	bne	r2,zero,90b1fa0 <sbcompress+0x168>
 90b1ed4:	e0bffd17 	ldw	r2,-12(fp)
 90b1ed8:	1080070b 	ldhu	r2,28(r2)
 90b1edc:	10bfffcc 	andi	r2,r2,65535
 90b1ee0:	1080200c 	andi	r2,r2,128
 90b1ee4:	1005003a 	cmpeq	r2,r2,zero
 90b1ee8:	10002d1e 	bne	r2,zero,90b1fa0 <sbcompress+0x168>
 90b1eec:	e0bfff17 	ldw	r2,-4(fp)
 90b1ef0:	10c00217 	ldw	r3,8(r2)
 90b1ef4:	e0bffe17 	ldw	r2,-8(fp)
 90b1ef8:	10800217 	ldw	r2,8(r2)
 90b1efc:	188b883a 	add	r5,r3,r2
 90b1f00:	e0bfff17 	ldw	r2,-4(fp)
 90b1f04:	11000517 	ldw	r4,20(r2)
 90b1f08:	e0bfff17 	ldw	r2,-4(fp)
 90b1f0c:	10800317 	ldw	r2,12(r2)
 90b1f10:	1007883a 	mov	r3,r2
 90b1f14:	e0bfff17 	ldw	r2,-4(fp)
 90b1f18:	10800417 	ldw	r2,16(r2)
 90b1f1c:	1885c83a 	sub	r2,r3,r2
 90b1f20:	2085c83a 	sub	r2,r4,r2
 90b1f24:	28801e2e 	bgeu	r5,r2,90b1fa0 <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 90b1f28:	e0bfff17 	ldw	r2,-4(fp)
 90b1f2c:	10c00317 	ldw	r3,12(r2)
 90b1f30:	e0bfff17 	ldw	r2,-4(fp)
 90b1f34:	10800217 	ldw	r2,8(r2)
 90b1f38:	1887883a 	add	r3,r3,r2
 90b1f3c:	e0bffe17 	ldw	r2,-8(fp)
 90b1f40:	11400317 	ldw	r5,12(r2)
 90b1f44:	e0bffe17 	ldw	r2,-8(fp)
 90b1f48:	10800217 	ldw	r2,8(r2)
 90b1f4c:	1809883a 	mov	r4,r3
 90b1f50:	100d883a 	mov	r6,r2
 90b1f54:	90894600 	call	9089460 <memcpy>
         sballoc(sb, m);
 90b1f58:	e0bffd17 	ldw	r2,-12(fp)
 90b1f5c:	10c00017 	ldw	r3,0(r2)
 90b1f60:	e0bffe17 	ldw	r2,-8(fp)
 90b1f64:	10800217 	ldw	r2,8(r2)
 90b1f68:	1887883a 	add	r3,r3,r2
 90b1f6c:	e0bffd17 	ldw	r2,-12(fp)
 90b1f70:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 90b1f74:	e0bfff17 	ldw	r2,-4(fp)
 90b1f78:	10c00217 	ldw	r3,8(r2)
 90b1f7c:	e0bffe17 	ldw	r2,-8(fp)
 90b1f80:	10800217 	ldw	r2,8(r2)
 90b1f84:	1887883a 	add	r3,r3,r2
 90b1f88:	e0bfff17 	ldw	r2,-4(fp)
 90b1f8c:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 90b1f90:	e13ffe17 	ldw	r4,-8(fp)
 90b1f94:	90ab4600 	call	90ab460 <m_free>
 90b1f98:	e0bffe15 	stw	r2,-8(fp)
         continue;
 90b1f9c:	00001806 	br	90b2000 <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 90b1fa0:	e0bffd17 	ldw	r2,-12(fp)
 90b1fa4:	10c00017 	ldw	r3,0(r2)
 90b1fa8:	e0bffe17 	ldw	r2,-8(fp)
 90b1fac:	10800217 	ldw	r2,8(r2)
 90b1fb0:	1887883a 	add	r3,r3,r2
 90b1fb4:	e0bffd17 	ldw	r2,-12(fp)
 90b1fb8:	10c00015 	stw	r3,0(r2)
      if (n)
 90b1fbc:	e0bfff17 	ldw	r2,-4(fp)
 90b1fc0:	1005003a 	cmpeq	r2,r2,zero
 90b1fc4:	1000041e 	bne	r2,zero,90b1fd8 <sbcompress+0x1a0>
         n->m_next = m;
 90b1fc8:	e0ffff17 	ldw	r3,-4(fp)
 90b1fcc:	e0bffe17 	ldw	r2,-8(fp)
 90b1fd0:	18800615 	stw	r2,24(r3)
 90b1fd4:	00000306 	br	90b1fe4 <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 90b1fd8:	e0fffd17 	ldw	r3,-12(fp)
 90b1fdc:	e0bffe17 	ldw	r2,-8(fp)
 90b1fe0:	18800615 	stw	r2,24(r3)
      n = m;
 90b1fe4:	e0bffe17 	ldw	r2,-8(fp)
 90b1fe8:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 90b1fec:	e0bffe17 	ldw	r2,-8(fp)
 90b1ff0:	10800617 	ldw	r2,24(r2)
 90b1ff4:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 90b1ff8:	e0bfff17 	ldw	r2,-4(fp)
 90b1ffc:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 90b2000:	e0bffe17 	ldw	r2,-8(fp)
 90b2004:	1004c03a 	cmpne	r2,r2,zero
 90b2008:	103f931e 	bne	r2,zero,90b1e58 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 90b200c:	e037883a 	mov	sp,fp
 90b2010:	dfc00117 	ldw	ra,4(sp)
 90b2014:	df000017 	ldw	fp,0(sp)
 90b2018:	dec00204 	addi	sp,sp,8
 90b201c:	f800283a 	ret

090b2020 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 90b2020:	defffd04 	addi	sp,sp,-12
 90b2024:	dfc00215 	stw	ra,8(sp)
 90b2028:	df000115 	stw	fp,4(sp)
 90b202c:	df000104 	addi	fp,sp,4
 90b2030:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 90b2034:	90aa6b80 	call	90aa6b8 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 90b2038:	e0bfff17 	ldw	r2,-4(fp)
 90b203c:	1080070b 	ldhu	r2,28(r2)
 90b2040:	10bfffcc 	andi	r2,r2,65535
 90b2044:	1080004c 	andi	r2,r2,1
 90b2048:	10803fcc 	andi	r2,r2,255
 90b204c:	1005003a 	cmpeq	r2,r2,zero
 90b2050:	1000091e 	bne	r2,zero,90b2078 <sbflush+0x58>
      panic("sbflush");
 90b2054:	01024374 	movhi	r4,2317
 90b2058:	21026004 	addi	r4,r4,2432
 90b205c:	90a537c0 	call	90a537c <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 90b2060:	00000506 	br	90b2078 <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 90b2064:	e0bfff17 	ldw	r2,-4(fp)
 90b2068:	10800017 	ldw	r2,0(r2)
 90b206c:	100b883a 	mov	r5,r2
 90b2070:	e13fff17 	ldw	r4,-4(fp)
 90b2074:	90b20b00 	call	90b20b0 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 90b2078:	e0bfff17 	ldw	r2,-4(fp)
 90b207c:	10800217 	ldw	r2,8(r2)
 90b2080:	1004c03a 	cmpne	r2,r2,zero
 90b2084:	103ff71e 	bne	r2,zero,90b2064 <sbflush+0x44>
 90b2088:	e0bfff17 	ldw	r2,-4(fp)
 90b208c:	10800017 	ldw	r2,0(r2)
 90b2090:	1004c03a 	cmpne	r2,r2,zero
 90b2094:	103ff31e 	bne	r2,zero,90b2064 <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 90b2098:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b209c:	e037883a 	mov	sp,fp
 90b20a0:	dfc00117 	ldw	ra,4(sp)
 90b20a4:	df000017 	ldw	fp,0(sp)
 90b20a8:	dec00204 	addi	sp,sp,8
 90b20ac:	f800283a 	ret

090b20b0 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 90b20b0:	defff904 	addi	sp,sp,-28
 90b20b4:	dfc00615 	stw	ra,24(sp)
 90b20b8:	df000515 	stw	fp,20(sp)
 90b20bc:	df000504 	addi	fp,sp,20
 90b20c0:	e13ffe15 	stw	r4,-8(fp)
 90b20c4:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 90b20c8:	90aa6b80 	call	90aa6b8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 90b20cc:	e0bffe17 	ldw	r2,-8(fp)
 90b20d0:	10800617 	ldw	r2,24(r2)
 90b20d4:	e0bffd15 	stw	r2,-12(fp)
 90b20d8:	e0bffd17 	ldw	r2,-12(fp)
 90b20dc:	1005003a 	cmpeq	r2,r2,zero
 90b20e0:	1000041e 	bne	r2,zero,90b20f4 <sbdrop+0x44>
      next = m->m_act;
 90b20e4:	e0bffd17 	ldw	r2,-12(fp)
 90b20e8:	10800717 	ldw	r2,28(r2)
 90b20ec:	e0bffb15 	stw	r2,-20(fp)
 90b20f0:	00003906 	br	90b21d8 <sbdrop+0x128>
   else
      next = NULL;
 90b20f4:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 90b20f8:	00003706 	br	90b21d8 <sbdrop+0x128>
   {
      if (m == 0) 
 90b20fc:	e0bffd17 	ldw	r2,-12(fp)
 90b2100:	1004c03a 	cmpne	r2,r2,zero
 90b2104:	10000c1e 	bne	r2,zero,90b2138 <sbdrop+0x88>
      {
         if (next == 0)
 90b2108:	e0bffb17 	ldw	r2,-20(fp)
 90b210c:	1004c03a 	cmpne	r2,r2,zero
 90b2110:	1000031e 	bne	r2,zero,90b2120 <sbdrop+0x70>
            panic("sbdrop");
 90b2114:	01024374 	movhi	r4,2317
 90b2118:	21026204 	addi	r4,r4,2440
 90b211c:	90a537c0 	call	90a537c <panic>
         m = next;
 90b2120:	e0bffb17 	ldw	r2,-20(fp)
 90b2124:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 90b2128:	e0bffd17 	ldw	r2,-12(fp)
 90b212c:	10800717 	ldw	r2,28(r2)
 90b2130:	e0bffb15 	stw	r2,-20(fp)
         continue;
 90b2134:	00002806 	br	90b21d8 <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 90b2138:	e0bffd17 	ldw	r2,-12(fp)
 90b213c:	10c00217 	ldw	r3,8(r2)
 90b2140:	e0bfff17 	ldw	r2,-4(fp)
 90b2144:	10c0132e 	bgeu	r2,r3,90b2194 <sbdrop+0xe4>
      {
         m->m_len -= len;
 90b2148:	e0bffd17 	ldw	r2,-12(fp)
 90b214c:	10c00217 	ldw	r3,8(r2)
 90b2150:	e0bfff17 	ldw	r2,-4(fp)
 90b2154:	1887c83a 	sub	r3,r3,r2
 90b2158:	e0bffd17 	ldw	r2,-12(fp)
 90b215c:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 90b2160:	e0bffd17 	ldw	r2,-12(fp)
 90b2164:	10c00317 	ldw	r3,12(r2)
 90b2168:	e0bfff17 	ldw	r2,-4(fp)
 90b216c:	1887883a 	add	r3,r3,r2
 90b2170:	e0bffd17 	ldw	r2,-12(fp)
 90b2174:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 90b2178:	e0bffe17 	ldw	r2,-8(fp)
 90b217c:	10c00017 	ldw	r3,0(r2)
 90b2180:	e0bfff17 	ldw	r2,-4(fp)
 90b2184:	1887c83a 	sub	r3,r3,r2
 90b2188:	e0bffe17 	ldw	r2,-8(fp)
 90b218c:	10c00015 	stw	r3,0(r2)
         break;
 90b2190:	00002106 	br	90b2218 <sbdrop+0x168>
      }
      len -= m->m_len;
 90b2194:	e0ffff17 	ldw	r3,-4(fp)
 90b2198:	e0bffd17 	ldw	r2,-12(fp)
 90b219c:	10800217 	ldw	r2,8(r2)
 90b21a0:	1885c83a 	sub	r2,r3,r2
 90b21a4:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 90b21a8:	e0bffe17 	ldw	r2,-8(fp)
 90b21ac:	10c00017 	ldw	r3,0(r2)
 90b21b0:	e0bffd17 	ldw	r2,-12(fp)
 90b21b4:	10800217 	ldw	r2,8(r2)
 90b21b8:	1887c83a 	sub	r3,r3,r2
 90b21bc:	e0bffe17 	ldw	r2,-8(fp)
 90b21c0:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 90b21c4:	e13ffd17 	ldw	r4,-12(fp)
 90b21c8:	90ab4600 	call	90ab460 <m_free>
 90b21cc:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 90b21d0:	e0bffc17 	ldw	r2,-16(fp)
 90b21d4:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 90b21d8:	e0bfff17 	ldw	r2,-4(fp)
 90b21dc:	10800048 	cmpgei	r2,r2,1
 90b21e0:	103fc61e 	bne	r2,zero,90b20fc <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 90b21e4:	00000c06 	br	90b2218 <sbdrop+0x168>
   {
      sbfree(sb, m);
 90b21e8:	e0bffe17 	ldw	r2,-8(fp)
 90b21ec:	10c00017 	ldw	r3,0(r2)
 90b21f0:	e0bffd17 	ldw	r2,-12(fp)
 90b21f4:	10800217 	ldw	r2,8(r2)
 90b21f8:	1887c83a 	sub	r3,r3,r2
 90b21fc:	e0bffe17 	ldw	r2,-8(fp)
 90b2200:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 90b2204:	e13ffd17 	ldw	r4,-12(fp)
 90b2208:	90ab4600 	call	90ab460 <m_free>
 90b220c:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 90b2210:	e0bffc17 	ldw	r2,-16(fp)
 90b2214:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 90b2218:	e0bffd17 	ldw	r2,-12(fp)
 90b221c:	1005003a 	cmpeq	r2,r2,zero
 90b2220:	1000041e 	bne	r2,zero,90b2234 <sbdrop+0x184>
 90b2224:	e0bffd17 	ldw	r2,-12(fp)
 90b2228:	10800217 	ldw	r2,8(r2)
 90b222c:	1005003a 	cmpeq	r2,r2,zero
 90b2230:	103fed1e 	bne	r2,zero,90b21e8 <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 90b2234:	e0bffd17 	ldw	r2,-12(fp)
 90b2238:	1005003a 	cmpeq	r2,r2,zero
 90b223c:	1000071e 	bne	r2,zero,90b225c <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 90b2240:	e0fffe17 	ldw	r3,-8(fp)
 90b2244:	e0bffd17 	ldw	r2,-12(fp)
 90b2248:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 90b224c:	e0fffd17 	ldw	r3,-12(fp)
 90b2250:	e0bffb17 	ldw	r2,-20(fp)
 90b2254:	18800715 	stw	r2,28(r3)
 90b2258:	00000306 	br	90b2268 <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 90b225c:	e0fffe17 	ldw	r3,-8(fp)
 90b2260:	e0bffb17 	ldw	r2,-20(fp)
 90b2264:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 90b2268:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b226c:	e037883a 	mov	sp,fp
 90b2270:	dfc00117 	ldw	ra,4(sp)
 90b2274:	df000017 	ldw	fp,0(sp)
 90b2278:	dec00204 	addi	sp,sp,8
 90b227c:	f800283a 	ret

090b2280 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 90b2280:	defff904 	addi	sp,sp,-28
 90b2284:	dfc00615 	stw	ra,24(sp)
 90b2288:	df000515 	stw	fp,20(sp)
 90b228c:	df000504 	addi	fp,sp,20
 90b2290:	e13ffe15 	stw	r4,-8(fp)
 90b2294:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 90b2298:	90aa6b80 	call	90aa6b8 <irq_Mask>
   len = mbuf_len(m);
 90b229c:	e13fff17 	ldw	r4,-4(fp)
 90b22a0:	90abacc0 	call	90abacc <mbuf_len>
 90b22a4:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 90b22a8:	e0bffb17 	ldw	r2,-20(fp)
 90b22ac:	10800050 	cmplti	r2,r2,1
 90b22b0:	1000051e 	bne	r2,zero,90b22c8 <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 90b22b4:	e0bffe17 	ldw	r2,-8(fp)
 90b22b8:	11000617 	ldw	r4,24(r2)
 90b22bc:	e0bffb17 	ldw	r2,-20(fp)
 90b22c0:	008bc83a 	sub	r5,zero,r2
 90b22c4:	90ab8fc0 	call	90ab8fc <m_adj>
   nmb = sb->sb_mb;
 90b22c8:	e0bffe17 	ldw	r2,-8(fp)
 90b22cc:	10800617 	ldw	r2,24(r2)
 90b22d0:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 90b22d4:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 90b22d8:	e0bffe17 	ldw	r2,-8(fp)
 90b22dc:	10800617 	ldw	r2,24(r2)
 90b22e0:	10800217 	ldw	r2,8(r2)
 90b22e4:	1004c03a 	cmpne	r2,r2,zero
 90b22e8:	1000081e 	bne	r2,zero,90b230c <sbdropend+0x8c>
      sb->sb_mb = NULL;
 90b22ec:	e0bffe17 	ldw	r2,-8(fp)
 90b22f0:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 90b22f4:	00000506 	br	90b230c <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 90b22f8:	e0bffd17 	ldw	r2,-12(fp)
 90b22fc:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 90b2300:	e0bffd17 	ldw	r2,-12(fp)
 90b2304:	10800617 	ldw	r2,24(r2)
 90b2308:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 90b230c:	e0bffd17 	ldw	r2,-12(fp)
 90b2310:	1005003a 	cmpeq	r2,r2,zero
 90b2314:	1000041e 	bne	r2,zero,90b2328 <sbdropend+0xa8>
 90b2318:	e0bffd17 	ldw	r2,-12(fp)
 90b231c:	10800217 	ldw	r2,8(r2)
 90b2320:	1004c03a 	cmpne	r2,r2,zero
 90b2324:	103ff41e 	bne	r2,zero,90b22f8 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 90b2328:	e0bffd17 	ldw	r2,-12(fp)
 90b232c:	1005003a 	cmpeq	r2,r2,zero
 90b2330:	10000b1e 	bne	r2,zero,90b2360 <sbdropend+0xe0>
 90b2334:	e0bffd17 	ldw	r2,-12(fp)
 90b2338:	10800217 	ldw	r2,8(r2)
 90b233c:	1004c03a 	cmpne	r2,r2,zero
 90b2340:	1000071e 	bne	r2,zero,90b2360 <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 90b2344:	e0bffc17 	ldw	r2,-16(fp)
 90b2348:	1005003a 	cmpeq	r2,r2,zero
 90b234c:	1000021e 	bne	r2,zero,90b2358 <sbdropend+0xd8>
         pmb->m_next = NULL;
 90b2350:	e0bffc17 	ldw	r2,-16(fp)
 90b2354:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 90b2358:	e13ffd17 	ldw	r4,-12(fp)
 90b235c:	90ab5940 	call	90ab594 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 90b2360:	e0bffe17 	ldw	r2,-8(fp)
 90b2364:	10c00017 	ldw	r3,0(r2)
 90b2368:	e0bffb17 	ldw	r2,-20(fp)
 90b236c:	1887c83a 	sub	r3,r3,r2
 90b2370:	e0bffe17 	ldw	r2,-8(fp)
 90b2374:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 90b2378:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b237c:	e037883a 	mov	sp,fp
 90b2380:	dfc00117 	ldw	ra,4(sp)
 90b2384:	df000017 	ldw	fp,0(sp)
 90b2388:	dec00204 	addi	sp,sp,8
 90b238c:	f800283a 	ret

090b2390 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 90b2390:	defffb04 	addi	sp,sp,-20
 90b2394:	dfc00415 	stw	ra,16(sp)
 90b2398:	df000315 	stw	fp,12(sp)
 90b239c:	df000304 	addi	fp,sp,12
 90b23a0:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 90b23a4:	90aa6b80 	call	90aa6b8 <irq_Mask>
   m = sb->sb_mb;
 90b23a8:	e0bfff17 	ldw	r2,-4(fp)
 90b23ac:	10800617 	ldw	r2,24(r2)
 90b23b0:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 90b23b4:	e0bffe17 	ldw	r2,-8(fp)
 90b23b8:	1005003a 	cmpeq	r2,r2,zero
 90b23bc:	1000131e 	bne	r2,zero,90b240c <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 90b23c0:	e0bffe17 	ldw	r2,-8(fp)
 90b23c4:	10c00717 	ldw	r3,28(r2)
 90b23c8:	e0bfff17 	ldw	r2,-4(fp)
 90b23cc:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 90b23d0:	e0bfff17 	ldw	r2,-4(fp)
 90b23d4:	10c00017 	ldw	r3,0(r2)
 90b23d8:	e0bffe17 	ldw	r2,-8(fp)
 90b23dc:	10800217 	ldw	r2,8(r2)
 90b23e0:	1887c83a 	sub	r3,r3,r2
 90b23e4:	e0bfff17 	ldw	r2,-4(fp)
 90b23e8:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 90b23ec:	e13ffe17 	ldw	r4,-8(fp)
 90b23f0:	90ab4600 	call	90ab460 <m_free>
 90b23f4:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 90b23f8:	e0bffd17 	ldw	r2,-12(fp)
 90b23fc:	e0bffe15 	stw	r2,-8(fp)
 90b2400:	e0bffe17 	ldw	r2,-8(fp)
 90b2404:	1004c03a 	cmpne	r2,r2,zero
 90b2408:	103ff11e 	bne	r2,zero,90b23d0 <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 90b240c:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90b2410:	e037883a 	mov	sp,fp
 90b2414:	dfc00117 	ldw	ra,4(sp)
 90b2418:	df000017 	ldw	fp,0(sp)
 90b241c:	dec00204 	addi	sp,sp,8
 90b2420:	f800283a 	ret

090b2424 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 90b2424:	defe7204 	addi	sp,sp,-1592
 90b2428:	dfc18d15 	stw	ra,1588(sp)
 90b242c:	df018c15 	stw	fp,1584(sp)
 90b2430:	df018c04 	addi	fp,sp,1584
 90b2434:	e13ffc15 	stw	r4,-16(fp)
 90b2438:	e17ffd15 	stw	r5,-12(fp)
 90b243c:	e1bffe15 	stw	r6,-8(fp)
 90b2440:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 90b2444:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 90b2448:	e0be7604 	addi	r2,fp,-1576
 90b244c:	1009883a 	mov	r4,r2
 90b2450:	0180c304 	movi	r6,780
 90b2454:	000b883a 	mov	r5,zero
 90b2458:	90832780 	call	9083278 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 90b245c:	e0bf3904 	addi	r2,fp,-796
 90b2460:	1009883a 	mov	r4,r2
 90b2464:	0180c304 	movi	r6,780
 90b2468:	000b883a 	mov	r5,zero
 90b246c:	90832780 	call	9083278 <memset>

   if (in)
 90b2470:	e0bffc17 	ldw	r2,-16(fp)
 90b2474:	1005003a 	cmpeq	r2,r2,zero
 90b2478:	1000061e 	bne	r2,zero,90b2494 <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 90b247c:	e0bf3904 	addi	r2,fp,-796
 90b2480:	e0fffc17 	ldw	r3,-16(fp)
 90b2484:	1009883a 	mov	r4,r2
 90b2488:	180b883a 	mov	r5,r3
 90b248c:	01804104 	movi	r6,260
 90b2490:	90894600 	call	9089460 <memcpy>
   if (out)
 90b2494:	e0bffd17 	ldw	r2,-12(fp)
 90b2498:	1005003a 	cmpeq	r2,r2,zero
 90b249c:	1000071e 	bne	r2,zero,90b24bc <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 90b24a0:	e0bf3904 	addi	r2,fp,-796
 90b24a4:	10804104 	addi	r2,r2,260
 90b24a8:	e0fffd17 	ldw	r3,-12(fp)
 90b24ac:	1009883a 	mov	r4,r2
 90b24b0:	180b883a 	mov	r5,r3
 90b24b4:	01804104 	movi	r6,260
 90b24b8:	90894600 	call	9089460 <memcpy>
   if (ex)
 90b24bc:	e0bffe17 	ldw	r2,-8(fp)
 90b24c0:	1005003a 	cmpeq	r2,r2,zero
 90b24c4:	1000071e 	bne	r2,zero,90b24e4 <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 90b24c8:	e0bf3904 	addi	r2,fp,-796
 90b24cc:	10808204 	addi	r2,r2,520
 90b24d0:	e0fffe17 	ldw	r3,-8(fp)
 90b24d4:	1009883a 	mov	r4,r2
 90b24d8:	180b883a 	mov	r5,r3
 90b24dc:	01804104 	movi	r6,260
 90b24e0:	90894600 	call	9089460 <memcpy>
   tmo = cticks + tv;
 90b24e4:	00824374 	movhi	r2,2317
 90b24e8:	108f2e04 	addi	r2,r2,15544
 90b24ec:	10c00017 	ldw	r3,0(r2)
 90b24f0:	e0bfff17 	ldw	r2,-4(fp)
 90b24f4:	1885883a 	add	r2,r3,r2
 90b24f8:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 90b24fc:	e0bf3917 	ldw	r2,-796(fp)
 90b2500:	1004c03a 	cmpne	r2,r2,zero
 90b2504:	10000e1e 	bne	r2,zero,90b2540 <t_select+0x11c>
 90b2508:	e0bf7a17 	ldw	r2,-536(fp)
 90b250c:	1004c03a 	cmpne	r2,r2,zero
 90b2510:	10000b1e 	bne	r2,zero,90b2540 <t_select+0x11c>
 90b2514:	e0bfbb17 	ldw	r2,-276(fp)
 90b2518:	1004c03a 	cmpne	r2,r2,zero
 90b251c:	1000081e 	bne	r2,zero,90b2540 <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 90b2520:	e0bfff17 	ldw	r2,-4(fp)
 90b2524:	10800050 	cmplti	r2,r2,1
 90b2528:	1000201e 	bne	r2,zero,90b25ac <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 90b252c:	e0bfff17 	ldw	r2,-4(fp)
 90b2530:	10800044 	addi	r2,r2,1
 90b2534:	113fffcc 	andi	r4,r2,65535
 90b2538:	9095df00 	call	9095df0 <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 90b253c:	00001b06 	br	90b25ac <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 90b2540:	0009883a 	mov	r4,zero
 90b2544:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 90b2548:	00000f06 	br	90b2588 <t_select+0x164>
      {
         if (tv != -1L) 
 90b254c:	e0bfff17 	ldw	r2,-4(fp)
 90b2550:	10bfffe0 	cmpeqi	r2,r2,-1
 90b2554:	1000051e 	bne	r2,zero,90b256c <t_select+0x148>
         {
            if (tmo <= cticks)
 90b2558:	00824374 	movhi	r2,2317
 90b255c:	108f2e04 	addi	r2,r2,15544
 90b2560:	10c00017 	ldw	r3,0(r2)
 90b2564:	e0be7517 	ldw	r2,-1580(fp)
 90b2568:	18800e2e 	bgeu	r3,r2,90b25a4 <t_select+0x180>
               break;
         }
         select_wait = 1;
 90b256c:	00c24374 	movhi	r3,2317
 90b2570:	18cf3604 	addi	r3,r3,15576
 90b2574:	00800044 	movi	r2,1
 90b2578:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 90b257c:	01024374 	movhi	r4,2317
 90b2580:	210f3604 	addi	r4,r4,15576
 90b2584:	90a5cf40 	call	90a5cf4 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 90b2588:	e13f3904 	addi	r4,fp,-796
 90b258c:	e17e7604 	addi	r5,fp,-1576
 90b2590:	90b26440 	call	90b2644 <sock_selscan>
 90b2594:	e0be7415 	stw	r2,-1584(fp)
 90b2598:	e0be7417 	ldw	r2,-1584(fp)
 90b259c:	1005003a 	cmpeq	r2,r2,zero
 90b25a0:	103fea1e 	bne	r2,zero,90b254c <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b25a4:	0009883a 	mov	r4,zero
 90b25a8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 90b25ac:	e0be7417 	ldw	r2,-1584(fp)
 90b25b0:	1004803a 	cmplt	r2,r2,zero
 90b25b4:	10001d1e 	bne	r2,zero,90b262c <t_select+0x208>
   {
      if (in)
 90b25b8:	e0bffc17 	ldw	r2,-16(fp)
 90b25bc:	1005003a 	cmpeq	r2,r2,zero
 90b25c0:	1000061e 	bne	r2,zero,90b25dc <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 90b25c4:	e0bffc17 	ldw	r2,-16(fp)
 90b25c8:	e0fe7604 	addi	r3,fp,-1576
 90b25cc:	1009883a 	mov	r4,r2
 90b25d0:	180b883a 	mov	r5,r3
 90b25d4:	01804104 	movi	r6,260
 90b25d8:	90894600 	call	9089460 <memcpy>
      if (out)
 90b25dc:	e0bffd17 	ldw	r2,-12(fp)
 90b25e0:	1005003a 	cmpeq	r2,r2,zero
 90b25e4:	1000071e 	bne	r2,zero,90b2604 <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 90b25e8:	e0be7604 	addi	r2,fp,-1576
 90b25ec:	10c04104 	addi	r3,r2,260
 90b25f0:	e0bffd17 	ldw	r2,-12(fp)
 90b25f4:	1009883a 	mov	r4,r2
 90b25f8:	180b883a 	mov	r5,r3
 90b25fc:	01804104 	movi	r6,260
 90b2600:	90894600 	call	9089460 <memcpy>
      if (ex)
 90b2604:	e0bffe17 	ldw	r2,-8(fp)
 90b2608:	1005003a 	cmpeq	r2,r2,zero
 90b260c:	1000071e 	bne	r2,zero,90b262c <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 90b2610:	e0be7604 	addi	r2,fp,-1576
 90b2614:	10c08204 	addi	r3,r2,520
 90b2618:	e0bffe17 	ldw	r2,-8(fp)
 90b261c:	1009883a 	mov	r4,r2
 90b2620:	180b883a 	mov	r5,r3
 90b2624:	01804104 	movi	r6,260
 90b2628:	90894600 	call	9089460 <memcpy>
   }
   return retval;
 90b262c:	e0be7417 	ldw	r2,-1584(fp)
}
 90b2630:	e037883a 	mov	sp,fp
 90b2634:	dfc00117 	ldw	ra,4(sp)
 90b2638:	df000017 	ldw	fp,0(sp)
 90b263c:	dec00204 	addi	sp,sp,8
 90b2640:	f800283a 	ret

090b2644 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 90b2644:	defff504 	addi	sp,sp,-44
 90b2648:	dfc00a15 	stw	ra,40(sp)
 90b264c:	df000915 	stw	fp,36(sp)
 90b2650:	df000904 	addi	fp,sp,36
 90b2654:	e13ffd15 	stw	r4,-12(fp)
 90b2658:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 90b265c:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 90b2660:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 90b2664:	e03ffa15 	stw	zero,-24(fp)
 90b2668:	00004306 	br	90b2778 <sock_selscan+0x134>
   {
      switch (which)
 90b266c:	e0bffa17 	ldw	r2,-24(fp)
 90b2670:	e0bfff15 	stw	r2,-4(fp)
 90b2674:	e0ffff17 	ldw	r3,-4(fp)
 90b2678:	18800060 	cmpeqi	r2,r3,1
 90b267c:	10000a1e 	bne	r2,zero,90b26a8 <sock_selscan+0x64>
 90b2680:	e0ffff17 	ldw	r3,-4(fp)
 90b2684:	188000a0 	cmpeqi	r2,r3,2
 90b2688:	10000a1e 	bne	r2,zero,90b26b4 <sock_selscan+0x70>
 90b268c:	e0ffff17 	ldw	r3,-4(fp)
 90b2690:	1805003a 	cmpeq	r2,r3,zero
 90b2694:	1000011e 	bne	r2,zero,90b269c <sock_selscan+0x58>
 90b2698:	00000706 	br	90b26b8 <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 90b269c:	00800044 	movi	r2,1
 90b26a0:	e0bff815 	stw	r2,-32(fp)
 90b26a4:	00000406 	br	90b26b8 <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 90b26a8:	00800084 	movi	r2,2
 90b26ac:	e0bff815 	stw	r2,-32(fp)
 90b26b0:	00000106 	br	90b26b8 <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 90b26b4:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 90b26b8:	e0bffa17 	ldw	r2,-24(fp)
 90b26bc:	10804124 	muli	r2,r2,260
 90b26c0:	1007883a 	mov	r3,r2
 90b26c4:	e0bffd17 	ldw	r2,-12(fp)
 90b26c8:	1885883a 	add	r2,r3,r2
 90b26cc:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 90b26d0:	e0bffa17 	ldw	r2,-24(fp)
 90b26d4:	10804124 	muli	r2,r2,260
 90b26d8:	1007883a 	mov	r3,r2
 90b26dc:	e0bffe17 	ldw	r2,-8(fp)
 90b26e0:	1885883a 	add	r2,r3,r2
 90b26e4:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 90b26e8:	e03ff915 	stw	zero,-28(fp)
 90b26ec:	00001a06 	br	90b2758 <sock_selscan+0x114>
      {
         if (sock_select (in->fd_array[sock], flag))
 90b26f0:	e0bff917 	ldw	r2,-28(fp)
 90b26f4:	e0fffc17 	ldw	r3,-16(fp)
 90b26f8:	1085883a 	add	r2,r2,r2
 90b26fc:	1085883a 	add	r2,r2,r2
 90b2700:	10c5883a 	add	r2,r2,r3
 90b2704:	10800104 	addi	r2,r2,4
 90b2708:	11000017 	ldw	r4,0(r2)
 90b270c:	e17ff817 	ldw	r5,-32(fp)
 90b2710:	90b279c0 	call	90b279c <sock_select>
 90b2714:	1005003a 	cmpeq	r2,r2,zero
 90b2718:	10000c1e 	bne	r2,zero,90b274c <sock_selscan+0x108>
         {
            FD_SET(in->fd_array[sock], out);
 90b271c:	e0bff917 	ldw	r2,-28(fp)
 90b2720:	e0fffc17 	ldw	r3,-16(fp)
 90b2724:	1085883a 	add	r2,r2,r2
 90b2728:	1085883a 	add	r2,r2,r2
 90b272c:	10c5883a 	add	r2,r2,r3
 90b2730:	10800104 	addi	r2,r2,4
 90b2734:	11000017 	ldw	r4,0(r2)
 90b2738:	e17ffb17 	ldw	r5,-20(fp)
 90b273c:	90b2bd40 	call	90b2bd4 <ifd_set>
            num_sel++;
 90b2740:	e0bff717 	ldw	r2,-36(fp)
 90b2744:	10800044 	addi	r2,r2,1
 90b2748:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 90b274c:	e0bff917 	ldw	r2,-28(fp)
 90b2750:	10800044 	addi	r2,r2,1
 90b2754:	e0bff915 	stw	r2,-28(fp)
 90b2758:	e0bffc17 	ldw	r2,-16(fp)
 90b275c:	10800017 	ldw	r2,0(r2)
 90b2760:	1007883a 	mov	r3,r2
 90b2764:	e0bff917 	ldw	r2,-28(fp)
 90b2768:	10ffe116 	blt	r2,r3,90b26f0 <sock_selscan+0xac>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 90b276c:	e0bffa17 	ldw	r2,-24(fp)
 90b2770:	10800044 	addi	r2,r2,1
 90b2774:	e0bffa15 	stw	r2,-24(fp)
 90b2778:	e0bffa17 	ldw	r2,-24(fp)
 90b277c:	108000d0 	cmplti	r2,r2,3
 90b2780:	103fba1e 	bne	r2,zero,90b266c <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 90b2784:	e0bff717 	ldw	r2,-36(fp)
}
 90b2788:	e037883a 	mov	sp,fp
 90b278c:	dfc00117 	ldw	ra,4(sp)
 90b2790:	df000017 	ldw	fp,0(sp)
 90b2794:	dec00204 	addi	sp,sp,8
 90b2798:	f800283a 	ret

090b279c <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 90b279c:	defff904 	addi	sp,sp,-28
 90b27a0:	dfc00615 	stw	ra,24(sp)
 90b27a4:	df000515 	stw	fp,20(sp)
 90b27a8:	df000504 	addi	fp,sp,20
 90b27ac:	e13ffd15 	stw	r4,-12(fp)
 90b27b0:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 90b27b4:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 90b27b8:	e0bffd17 	ldw	r2,-12(fp)
 90b27bc:	10bff804 	addi	r2,r2,-32
 90b27c0:	1085883a 	add	r2,r2,r2
 90b27c4:	1085883a 	add	r2,r2,r2
 90b27c8:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 90b27cc:	e0bffe17 	ldw	r2,-8(fp)
 90b27d0:	e0bfff15 	stw	r2,-4(fp)
 90b27d4:	e0ffff17 	ldw	r3,-4(fp)
 90b27d8:	18800060 	cmpeqi	r2,r3,1
 90b27dc:	1000071e 	bne	r2,zero,90b27fc <sock_select+0x60>
 90b27e0:	e0ffff17 	ldw	r3,-4(fp)
 90b27e4:	188000a0 	cmpeqi	r2,r3,2
 90b27e8:	1000251e 	bne	r2,zero,90b2880 <sock_select+0xe4>
 90b27ec:	e0ffff17 	ldw	r3,-4(fp)
 90b27f0:	1805003a 	cmpeq	r2,r3,zero
 90b27f4:	1000491e 	bne	r2,zero,90b291c <sock_select+0x180>
 90b27f8:	00006706 	br	90b2998 <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 90b27fc:	e0bffc17 	ldw	r2,-16(fp)
 90b2800:	10800a17 	ldw	r2,40(r2)
 90b2804:	1005003a 	cmpeq	r2,r2,zero
 90b2808:	1000031e 	bne	r2,zero,90b2818 <sock_select+0x7c>
      {
         ready = 1;
 90b280c:	00800044 	movi	r2,1
 90b2810:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b2814:	00006006 	br	90b2998 <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 90b2818:	e0bffc17 	ldw	r2,-16(fp)
 90b281c:	1080088b 	ldhu	r2,34(r2)
 90b2820:	10bfffcc 	andi	r2,r2,65535
 90b2824:	1080080c 	andi	r2,r2,32
 90b2828:	1005003a 	cmpeq	r2,r2,zero
 90b282c:	1000031e 	bne	r2,zero,90b283c <sock_select+0xa0>
      {  ready = 1;
 90b2830:	00800044 	movi	r2,1
 90b2834:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b2838:	00005706 	br	90b2998 <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 90b283c:	e0bffc17 	ldw	r2,-16(fp)
 90b2840:	10801e43 	ldbu	r2,121(r2)
 90b2844:	10803fcc 	andi	r2,r2,255
 90b2848:	1080201c 	xori	r2,r2,128
 90b284c:	10bfe004 	addi	r2,r2,-128
 90b2850:	1005003a 	cmpeq	r2,r2,zero
 90b2854:	1000031e 	bne	r2,zero,90b2864 <sock_select+0xc8>
      {
         ready = 1;
 90b2858:	00800044 	movi	r2,1
 90b285c:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b2860:	00004d06 	br	90b2998 <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 90b2864:	e0bffc17 	ldw	r2,-16(fp)
 90b2868:	1080110b 	ldhu	r2,68(r2)
 90b286c:	10800214 	ori	r2,r2,8
 90b2870:	1007883a 	mov	r3,r2
 90b2874:	e0bffc17 	ldw	r2,-16(fp)
 90b2878:	10c0110d 	sth	r3,68(r2)
      break;
 90b287c:	00004606 	br	90b2998 <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 90b2880:	e0bffc17 	ldw	r2,-16(fp)
 90b2884:	10801317 	ldw	r2,76(r2)
 90b2888:	1007883a 	mov	r3,r2
 90b288c:	e0bffc17 	ldw	r2,-16(fp)
 90b2890:	10801217 	ldw	r2,72(r2)
 90b2894:	1885c83a 	sub	r2,r3,r2
 90b2898:	1004803a 	cmplt	r2,r2,zero
 90b289c:	10001b1e 	bne	r2,zero,90b290c <sock_select+0x170>
 90b28a0:	e0bffc17 	ldw	r2,-16(fp)
 90b28a4:	10c01317 	ldw	r3,76(r2)
 90b28a8:	e0bffc17 	ldw	r2,-16(fp)
 90b28ac:	10801217 	ldw	r2,72(r2)
 90b28b0:	18801626 	beq	r3,r2,90b290c <sock_select+0x170>
 90b28b4:	e0bffc17 	ldw	r2,-16(fp)
 90b28b8:	1080088b 	ldhu	r2,34(r2)
 90b28bc:	10bfffcc 	andi	r2,r2,65535
 90b28c0:	1080008c 	andi	r2,r2,2
 90b28c4:	1004c03a 	cmpne	r2,r2,zero
 90b28c8:	10000d1e 	bne	r2,zero,90b2900 <sock_select+0x164>
 90b28cc:	e0bffc17 	ldw	r2,-16(fp)
 90b28d0:	10800217 	ldw	r2,8(r2)
 90b28d4:	1080010b 	ldhu	r2,4(r2)
 90b28d8:	10bfffcc 	andi	r2,r2,65535
 90b28dc:	1080010c 	andi	r2,r2,4
 90b28e0:	1005003a 	cmpeq	r2,r2,zero
 90b28e4:	1000061e 	bne	r2,zero,90b2900 <sock_select+0x164>
 90b28e8:	e0bffc17 	ldw	r2,-16(fp)
 90b28ec:	1080088b 	ldhu	r2,34(r2)
 90b28f0:	10bfffcc 	andi	r2,r2,65535
 90b28f4:	1080040c 	andi	r2,r2,16
 90b28f8:	1005003a 	cmpeq	r2,r2,zero
 90b28fc:	1000031e 	bne	r2,zero,90b290c <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 90b2900:	00800044 	movi	r2,1
 90b2904:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b2908:	00002306 	br	90b2998 <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 90b290c:	e0bffc17 	ldw	r2,-16(fp)
 90b2910:	11001204 	addi	r4,r2,72
 90b2914:	90b18440 	call	90b1844 <sbselqueue>
      break;
 90b2918:	00001f06 	br	90b2998 <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 90b291c:	e0bffc17 	ldw	r2,-16(fp)
 90b2920:	10801a17 	ldw	r2,104(r2)
 90b2924:	1004c03a 	cmpne	r2,r2,zero
 90b2928:	1000061e 	bne	r2,zero,90b2944 <sock_select+0x1a8>
 90b292c:	e0bffc17 	ldw	r2,-16(fp)
 90b2930:	1080088b 	ldhu	r2,34(r2)
 90b2934:	10bfffcc 	andi	r2,r2,65535
 90b2938:	1080100c 	andi	r2,r2,64
 90b293c:	1005003a 	cmpeq	r2,r2,zero
 90b2940:	1000031e 	bne	r2,zero,90b2950 <sock_select+0x1b4>
      {
         ready = 1;
 90b2944:	00800044 	movi	r2,1
 90b2948:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b294c:	00001206 	br	90b2998 <sock_select+0x1fc>
      }
      if (so->so_error &&
 90b2950:	e0bffc17 	ldw	r2,-16(fp)
 90b2954:	10800617 	ldw	r2,24(r2)
 90b2958:	1005003a 	cmpeq	r2,r2,zero
 90b295c:	10000b1e 	bne	r2,zero,90b298c <sock_select+0x1f0>
 90b2960:	e0bffc17 	ldw	r2,-16(fp)
 90b2964:	10800617 	ldw	r2,24(r2)
 90b2968:	10801de0 	cmpeqi	r2,r2,119
 90b296c:	1000071e 	bne	r2,zero,90b298c <sock_select+0x1f0>
 90b2970:	e0bffc17 	ldw	r2,-16(fp)
 90b2974:	10800617 	ldw	r2,24(r2)
 90b2978:	108002e0 	cmpeqi	r2,r2,11
 90b297c:	1000031e 	bne	r2,zero,90b298c <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 90b2980:	00800044 	movi	r2,1
 90b2984:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b2988:	00000306 	br	90b2998 <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 90b298c:	e0bffc17 	ldw	r2,-16(fp)
 90b2990:	11000a04 	addi	r4,r2,40
 90b2994:	90b18440 	call	90b1844 <sbselqueue>
      break;
   }

   return ready;
 90b2998:	e0bffb17 	ldw	r2,-20(fp)
}
 90b299c:	e037883a 	mov	sp,fp
 90b29a0:	dfc00117 	ldw	ra,4(sp)
 90b29a4:	df000017 	ldw	fp,0(sp)
 90b29a8:	dec00204 	addi	sp,sp,8
 90b29ac:	f800283a 	ret

090b29b0 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 90b29b0:	defff804 	addi	sp,sp,-32
 90b29b4:	dfc00715 	stw	ra,28(sp)
 90b29b8:	df000615 	stw	fp,24(sp)
 90b29bc:	df000604 	addi	fp,sp,24
 90b29c0:	e13ffc15 	stw	r4,-16(fp)
 90b29c4:	e17ffd15 	stw	r5,-12(fp)
 90b29c8:	e1bffe15 	stw	r6,-8(fp)
 90b29cc:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 90b29d0:	e0bffc17 	ldw	r2,-16(fp)
 90b29d4:	10800017 	ldw	r2,0(r2)
 90b29d8:	e0bffb15 	stw	r2,-20(fp)
 90b29dc:	00001f06 	br	90b2a5c <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 90b29e0:	e0bffb17 	ldw	r2,-20(fp)
 90b29e4:	10c00317 	ldw	r3,12(r2)
 90b29e8:	e0bffd17 	ldw	r2,-12(fp)
 90b29ec:	10800017 	ldw	r2,0(r2)
 90b29f0:	1880041e 	bne	r3,r2,90b2a04 <in_pcbnotify+0x54>
 90b29f4:	e0bffb17 	ldw	r2,-20(fp)
 90b29f8:	10800817 	ldw	r2,32(r2)
 90b29fc:	1004c03a 	cmpne	r2,r2,zero
 90b2a00:	1000041e 	bne	r2,zero,90b2a14 <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 90b2a04:	e0bffb17 	ldw	r2,-20(fp)
 90b2a08:	10800017 	ldw	r2,0(r2)
 90b2a0c:	e0bffb15 	stw	r2,-20(fp)
         continue;
 90b2a10:	00001206 	br	90b2a5c <in_pcbnotify+0xac>
      }
      if (errnum) 
 90b2a14:	e0bffe17 	ldw	r2,-8(fp)
 90b2a18:	1005003a 	cmpeq	r2,r2,zero
 90b2a1c:	1000041e 	bne	r2,zero,90b2a30 <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 90b2a20:	e0bffb17 	ldw	r2,-20(fp)
 90b2a24:	10c00817 	ldw	r3,32(r2)
 90b2a28:	e0bffe17 	ldw	r2,-8(fp)
 90b2a2c:	18800615 	stw	r2,24(r3)
      oinp = inp;
 90b2a30:	e0bffb17 	ldw	r2,-20(fp)
 90b2a34:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 90b2a38:	e0bffb17 	ldw	r2,-20(fp)
 90b2a3c:	10800017 	ldw	r2,0(r2)
 90b2a40:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 90b2a44:	e0bfff17 	ldw	r2,-4(fp)
 90b2a48:	1005003a 	cmpeq	r2,r2,zero
 90b2a4c:	1000031e 	bne	r2,zero,90b2a5c <in_pcbnotify+0xac>
         (*notify)(oinp);
 90b2a50:	e0bfff17 	ldw	r2,-4(fp)
 90b2a54:	e13ffa17 	ldw	r4,-24(fp)
 90b2a58:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 90b2a5c:	e0fffb17 	ldw	r3,-20(fp)
 90b2a60:	e0bffc17 	ldw	r2,-16(fp)
 90b2a64:	18bfde1e 	bne	r3,r2,90b29e0 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 90b2a68:	e037883a 	mov	sp,fp
 90b2a6c:	dfc00117 	ldw	ra,4(sp)
 90b2a70:	df000017 	ldw	fp,0(sp)
 90b2a74:	dec00204 	addi	sp,sp,8
 90b2a78:	f800283a 	ret

090b2a7c <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 90b2a7c:	defffd04 	addi	sp,sp,-12
 90b2a80:	dfc00215 	stw	ra,8(sp)
 90b2a84:	df000115 	stw	fp,4(sp)
 90b2a88:	df000104 	addi	fp,sp,4
 90b2a8c:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 90b2a90:	e0bfff17 	ldw	r2,-4(fp)
 90b2a94:	10800817 	ldw	r2,32(r2)
 90b2a98:	11000904 	addi	r4,r2,36
 90b2a9c:	90a5e940 	call	90a5e94 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 90b2aa0:	e0bfff17 	ldw	r2,-4(fp)
 90b2aa4:	11000817 	ldw	r4,32(r2)
 90b2aa8:	e0bfff17 	ldw	r2,-4(fp)
 90b2aac:	10800817 	ldw	r2,32(r2)
 90b2ab0:	11400a04 	addi	r5,r2,40
 90b2ab4:	90b18e40 	call	90b18e4 <sbwakeup>
   sowwakeup(inp->inp_socket);
 90b2ab8:	e0bfff17 	ldw	r2,-4(fp)
 90b2abc:	11000817 	ldw	r4,32(r2)
 90b2ac0:	e0bfff17 	ldw	r2,-4(fp)
 90b2ac4:	10800817 	ldw	r2,32(r2)
 90b2ac8:	11401204 	addi	r5,r2,72
 90b2acc:	90b18e40 	call	90b18e4 <sbwakeup>
}
 90b2ad0:	e037883a 	mov	sp,fp
 90b2ad4:	dfc00117 	ldw	ra,4(sp)
 90b2ad8:	df000017 	ldw	fp,0(sp)
 90b2adc:	dec00204 	addi	sp,sp,8
 90b2ae0:	f800283a 	ret

090b2ae4 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 90b2ae4:	defffb04 	addi	sp,sp,-20
 90b2ae8:	dfc00415 	stw	ra,16(sp)
 90b2aec:	df000315 	stw	fp,12(sp)
 90b2af0:	df000304 	addi	fp,sp,12
 90b2af4:	e13ffe15 	stw	r4,-8(fp)
 90b2af8:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 90b2afc:	e03ffd15 	stw	zero,-12(fp)
 90b2b00:	00002a06 	br	90b2bac <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 90b2b04:	e0bffd17 	ldw	r2,-12(fp)
 90b2b08:	e0ffff17 	ldw	r3,-4(fp)
 90b2b0c:	1085883a 	add	r2,r2,r2
 90b2b10:	1085883a 	add	r2,r2,r2
 90b2b14:	10c5883a 	add	r2,r2,r3
 90b2b18:	10800104 	addi	r2,r2,4
 90b2b1c:	10c00017 	ldw	r3,0(r2)
 90b2b20:	e0bffe17 	ldw	r2,-8(fp)
 90b2b24:	18801e1e 	bne	r3,r2,90b2ba0 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 90b2b28:	00001206 	br	90b2b74 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 90b2b2c:	e13ffd17 	ldw	r4,-12(fp)
 90b2b30:	e0bffd17 	ldw	r2,-12(fp)
 90b2b34:	10800044 	addi	r2,r2,1
 90b2b38:	e0ffff17 	ldw	r3,-4(fp)
 90b2b3c:	1085883a 	add	r2,r2,r2
 90b2b40:	1085883a 	add	r2,r2,r2
 90b2b44:	10c5883a 	add	r2,r2,r3
 90b2b48:	10800104 	addi	r2,r2,4
 90b2b4c:	11400017 	ldw	r5,0(r2)
 90b2b50:	e0ffff17 	ldw	r3,-4(fp)
 90b2b54:	2105883a 	add	r2,r4,r4
 90b2b58:	1085883a 	add	r2,r2,r2
 90b2b5c:	10c5883a 	add	r2,r2,r3
 90b2b60:	10800104 	addi	r2,r2,4
 90b2b64:	11400015 	stw	r5,0(r2)
            i++;
 90b2b68:	e0bffd17 	ldw	r2,-12(fp)
 90b2b6c:	10800044 	addi	r2,r2,1
 90b2b70:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 90b2b74:	e0bffd17 	ldw	r2,-12(fp)
 90b2b78:	10c00044 	addi	r3,r2,1
 90b2b7c:	e0bfff17 	ldw	r2,-4(fp)
 90b2b80:	10800017 	ldw	r2,0(r2)
 90b2b84:	18bfe936 	bltu	r3,r2,90b2b2c <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 90b2b88:	e0bfff17 	ldw	r2,-4(fp)
 90b2b8c:	10800017 	ldw	r2,0(r2)
 90b2b90:	10ffffc4 	addi	r3,r2,-1
 90b2b94:	e0bfff17 	ldw	r2,-4(fp)
 90b2b98:	10c00015 	stw	r3,0(r2)
         return;
 90b2b9c:	00000806 	br	90b2bc0 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 90b2ba0:	e0bffd17 	ldw	r2,-12(fp)
 90b2ba4:	10800044 	addi	r2,r2,1
 90b2ba8:	e0bffd15 	stw	r2,-12(fp)
 90b2bac:	e0bfff17 	ldw	r2,-4(fp)
 90b2bb0:	10c00017 	ldw	r3,0(r2)
 90b2bb4:	e0bffd17 	ldw	r2,-12(fp)
 90b2bb8:	10ffd236 	bltu	r2,r3,90b2b04 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 90b2bbc:	90aa4780 	call	90aa478 <dtrap>
#endif
}
 90b2bc0:	e037883a 	mov	sp,fp
 90b2bc4:	dfc00117 	ldw	ra,4(sp)
 90b2bc8:	df000017 	ldw	fp,0(sp)
 90b2bcc:	dec00204 	addi	sp,sp,8
 90b2bd0:	f800283a 	ret

090b2bd4 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 90b2bd4:	defffc04 	addi	sp,sp,-16
 90b2bd8:	dfc00315 	stw	ra,12(sp)
 90b2bdc:	df000215 	stw	fp,8(sp)
 90b2be0:	df000204 	addi	fp,sp,8
 90b2be4:	e13ffe15 	stw	r4,-8(fp)
 90b2be8:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 90b2bec:	e0bfff17 	ldw	r2,-4(fp)
 90b2bf0:	10800017 	ldw	r2,0(r2)
 90b2bf4:	10801028 	cmpgeui	r2,r2,64
 90b2bf8:	10000d1e 	bne	r2,zero,90b2c30 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 90b2bfc:	e0bfff17 	ldw	r2,-4(fp)
 90b2c00:	10c00017 	ldw	r3,0(r2)
 90b2c04:	e13fff17 	ldw	r4,-4(fp)
 90b2c08:	18c5883a 	add	r2,r3,r3
 90b2c0c:	1085883a 	add	r2,r2,r2
 90b2c10:	1105883a 	add	r2,r2,r4
 90b2c14:	11000104 	addi	r4,r2,4
 90b2c18:	e0bffe17 	ldw	r2,-8(fp)
 90b2c1c:	20800015 	stw	r2,0(r4)
 90b2c20:	18c00044 	addi	r3,r3,1
 90b2c24:	e0bfff17 	ldw	r2,-4(fp)
 90b2c28:	10c00015 	stw	r3,0(r2)
 90b2c2c:	00000106 	br	90b2c34 <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 90b2c30:	90aa4780 	call	90aa478 <dtrap>
#endif
}
 90b2c34:	e037883a 	mov	sp,fp
 90b2c38:	dfc00117 	ldw	ra,4(sp)
 90b2c3c:	df000017 	ldw	fp,0(sp)
 90b2c40:	dec00204 	addi	sp,sp,8
 90b2c44:	f800283a 	ret

090b2c48 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 90b2c48:	defffb04 	addi	sp,sp,-20
 90b2c4c:	df000415 	stw	fp,16(sp)
 90b2c50:	df000404 	addi	fp,sp,16
 90b2c54:	e13ffd15 	stw	r4,-12(fp)
 90b2c58:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 90b2c5c:	e03ffc15 	stw	zero,-16(fp)
 90b2c60:	00000f06 	br	90b2ca0 <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 90b2c64:	e0bffc17 	ldw	r2,-16(fp)
 90b2c68:	e0fffe17 	ldw	r3,-8(fp)
 90b2c6c:	1085883a 	add	r2,r2,r2
 90b2c70:	1085883a 	add	r2,r2,r2
 90b2c74:	10c5883a 	add	r2,r2,r3
 90b2c78:	10800104 	addi	r2,r2,4
 90b2c7c:	10c00017 	ldw	r3,0(r2)
 90b2c80:	e0bffd17 	ldw	r2,-12(fp)
 90b2c84:	1880031e 	bne	r3,r2,90b2c94 <ifd_isset+0x4c>
         return TRUE;
 90b2c88:	00800044 	movi	r2,1
 90b2c8c:	e0bfff15 	stw	r2,-4(fp)
 90b2c90:	00000806 	br	90b2cb4 <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 90b2c94:	e0bffc17 	ldw	r2,-16(fp)
 90b2c98:	10800044 	addi	r2,r2,1
 90b2c9c:	e0bffc15 	stw	r2,-16(fp)
 90b2ca0:	e0bffe17 	ldw	r2,-8(fp)
 90b2ca4:	10c00017 	ldw	r3,0(r2)
 90b2ca8:	e0bffc17 	ldw	r2,-16(fp)
 90b2cac:	10ffed36 	bltu	r2,r3,90b2c64 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 90b2cb0:	e03fff15 	stw	zero,-4(fp)
 90b2cb4:	e0bfff17 	ldw	r2,-4(fp)
}
 90b2cb8:	e037883a 	mov	sp,fp
 90b2cbc:	df000017 	ldw	fp,0(sp)
 90b2cc0:	dec00104 	addi	sp,sp,4
 90b2cc4:	f800283a 	ret

090b2cc8 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 90b2cc8:	defffb04 	addi	sp,sp,-20
 90b2ccc:	dfc00415 	stw	ra,16(sp)
 90b2cd0:	df000315 	stw	fp,12(sp)
 90b2cd4:	df000304 	addi	fp,sp,12
 90b2cd8:	e13ffd15 	stw	r4,-12(fp)
 90b2cdc:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 90b2ce0:	e0bffe17 	ldw	r2,-8(fp)
 90b2ce4:	10c00017 	ldw	r3,0(r2)
 90b2ce8:	e0bffd17 	ldw	r2,-12(fp)
 90b2cec:	10c0092e 	bgeu	r2,r3,90b2d14 <ifd_get+0x4c>
      return set->fd_array[i];
 90b2cf0:	e0bffd17 	ldw	r2,-12(fp)
 90b2cf4:	e0fffe17 	ldw	r3,-8(fp)
 90b2cf8:	1085883a 	add	r2,r2,r2
 90b2cfc:	1085883a 	add	r2,r2,r2
 90b2d00:	10c5883a 	add	r2,r2,r3
 90b2d04:	10800104 	addi	r2,r2,4
 90b2d08:	10800017 	ldw	r2,0(r2)
 90b2d0c:	e0bfff15 	stw	r2,-4(fp)
 90b2d10:	00000306 	br	90b2d20 <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 90b2d14:	90aa4780 	call	90aa478 <dtrap>
#endif
      return INVALID_SOCKET;
 90b2d18:	00bfffc4 	movi	r2,-1
 90b2d1c:	e0bfff15 	stw	r2,-4(fp)
 90b2d20:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90b2d24:	e037883a 	mov	sp,fp
 90b2d28:	dfc00117 	ldw	ra,4(sp)
 90b2d2c:	df000017 	ldw	fp,0(sp)
 90b2d30:	dec00204 	addi	sp,sp,8
 90b2d34:	f800283a 	ret

090b2d38 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 90b2d38:	defff404 	addi	sp,sp,-48
 90b2d3c:	dfc00b15 	stw	ra,44(sp)
 90b2d40:	df000a15 	stw	fp,40(sp)
 90b2d44:	df000a04 	addi	fp,sp,40
 90b2d48:	e13ffc15 	stw	r4,-16(fp)
 90b2d4c:	e17ffd15 	stw	r5,-12(fp)
 90b2d50:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b2d54:	e0bffc17 	ldw	r2,-16(fp)
 90b2d58:	10800d17 	ldw	r2,52(r2)
 90b2d5c:	10800817 	ldw	r2,32(r2)
 90b2d60:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 90b2d64:	e0bffd17 	ldw	r2,-12(fp)
 90b2d68:	1005003a 	cmpeq	r2,r2,zero
 90b2d6c:	10009c1e 	bne	r2,zero,90b2fe0 <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 90b2d70:	e0bffc17 	ldw	r2,-16(fp)
 90b2d74:	10800017 	ldw	r2,0(r2)
 90b2d78:	e0bffb15 	stw	r2,-20(fp)
 90b2d7c:	00000a06 	br	90b2da8 <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 90b2d80:	e0bffb17 	ldw	r2,-20(fp)
 90b2d84:	10c00617 	ldw	r3,24(r2)
 90b2d88:	e0bffd17 	ldw	r2,-12(fp)
 90b2d8c:	10800617 	ldw	r2,24(r2)
 90b2d90:	1885c83a 	sub	r2,r3,r2
 90b2d94:	10800048 	cmpgei	r2,r2,1
 90b2d98:	1000061e 	bne	r2,zero,90b2db4 <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 90b2d9c:	e0bffb17 	ldw	r2,-20(fp)
 90b2da0:	10800017 	ldw	r2,0(r2)
 90b2da4:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 90b2da8:	e0fffc17 	ldw	r3,-16(fp)
 90b2dac:	e0bffb17 	ldw	r2,-20(fp)
 90b2db0:	10fff31e 	bne	r2,r3,90b2d80 <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 90b2db4:	e0bffb17 	ldw	r2,-20(fp)
 90b2db8:	10800117 	ldw	r2,4(r2)
 90b2dbc:	1007883a 	mov	r3,r2
 90b2dc0:	e0bffc17 	ldw	r2,-16(fp)
 90b2dc4:	18803c26 	beq	r3,r2,90b2eb8 <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 90b2dc8:	e0bffb17 	ldw	r2,-20(fp)
 90b2dcc:	10800117 	ldw	r2,4(r2)
 90b2dd0:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 90b2dd4:	e0bffb17 	ldw	r2,-20(fp)
 90b2dd8:	10c00617 	ldw	r3,24(r2)
 90b2ddc:	e0bffb17 	ldw	r2,-20(fp)
 90b2de0:	1080028b 	ldhu	r2,10(r2)
 90b2de4:	10bfffcc 	andi	r2,r2,65535
 90b2de8:	1887883a 	add	r3,r3,r2
 90b2dec:	e0bffd17 	ldw	r2,-12(fp)
 90b2df0:	10800617 	ldw	r2,24(r2)
 90b2df4:	1885c83a 	sub	r2,r3,r2
 90b2df8:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 90b2dfc:	e0bff717 	ldw	r2,-36(fp)
 90b2e00:	10800050 	cmplti	r2,r2,1
 90b2e04:	1000291e 	bne	r2,zero,90b2eac <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 90b2e08:	e0bffd17 	ldw	r2,-12(fp)
 90b2e0c:	1080028b 	ldhu	r2,10(r2)
 90b2e10:	10ffffcc 	andi	r3,r2,65535
 90b2e14:	e0bff717 	ldw	r2,-36(fp)
 90b2e18:	10c01416 	blt	r2,r3,90b2e6c <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 90b2e1c:	008243b4 	movhi	r2,2318
 90b2e20:	10b75604 	addi	r2,r2,-8872
 90b2e24:	10801f17 	ldw	r2,124(r2)
 90b2e28:	10c00044 	addi	r3,r2,1
 90b2e2c:	008243b4 	movhi	r2,2318
 90b2e30:	10b75604 	addi	r2,r2,-8872
 90b2e34:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 90b2e38:	008243b4 	movhi	r2,2318
 90b2e3c:	10b75604 	addi	r2,r2,-8872
 90b2e40:	10c02017 	ldw	r3,128(r2)
 90b2e44:	e0bffd17 	ldw	r2,-12(fp)
 90b2e48:	1080028b 	ldhu	r2,10(r2)
 90b2e4c:	10bfffcc 	andi	r2,r2,65535
 90b2e50:	1887883a 	add	r3,r3,r2
 90b2e54:	008243b4 	movhi	r2,2318
 90b2e58:	10b75604 	addi	r2,r2,-8872
 90b2e5c:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 90b2e60:	008025c4 	movi	r2,151
 90b2e64:	d0a0b315 	stw	r2,-32052(gp)
 90b2e68:	0000ac06 	br	90b311c <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 90b2e6c:	e13ffe17 	ldw	r4,-8(fp)
 90b2e70:	e17ff717 	ldw	r5,-36(fp)
 90b2e74:	90ab8fc0 	call	90ab8fc <m_adj>
         ti->ti_len -= (short)i;
 90b2e78:	e0bffd17 	ldw	r2,-12(fp)
 90b2e7c:	10c0028b 	ldhu	r3,10(r2)
 90b2e80:	e0bff717 	ldw	r2,-36(fp)
 90b2e84:	1885c83a 	sub	r2,r3,r2
 90b2e88:	1007883a 	mov	r3,r2
 90b2e8c:	e0bffd17 	ldw	r2,-12(fp)
 90b2e90:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 90b2e94:	e0bffd17 	ldw	r2,-12(fp)
 90b2e98:	10c00617 	ldw	r3,24(r2)
 90b2e9c:	e0bff717 	ldw	r2,-36(fp)
 90b2ea0:	1887883a 	add	r3,r3,r2
 90b2ea4:	e0bffd17 	ldw	r2,-12(fp)
 90b2ea8:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 90b2eac:	e0bffb17 	ldw	r2,-20(fp)
 90b2eb0:	10800017 	ldw	r2,0(r2)
 90b2eb4:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 90b2eb8:	008243b4 	movhi	r2,2318
 90b2ebc:	10b75604 	addi	r2,r2,-8872
 90b2ec0:	10802317 	ldw	r2,140(r2)
 90b2ec4:	10c00044 	addi	r3,r2,1
 90b2ec8:	008243b4 	movhi	r2,2318
 90b2ecc:	10b75604 	addi	r2,r2,-8872
 90b2ed0:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 90b2ed4:	008243b4 	movhi	r2,2318
 90b2ed8:	10b75604 	addi	r2,r2,-8872
 90b2edc:	10c02417 	ldw	r3,144(r2)
 90b2ee0:	e0bffd17 	ldw	r2,-12(fp)
 90b2ee4:	1080028b 	ldhu	r2,10(r2)
 90b2ee8:	10bfffcc 	andi	r2,r2,65535
 90b2eec:	1887883a 	add	r3,r3,r2
 90b2ef0:	008243b4 	movhi	r2,2318
 90b2ef4:	10b75604 	addi	r2,r2,-8872
 90b2ef8:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 90b2efc:	00003106 	br	90b2fc4 <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 90b2f00:	e0bffd17 	ldw	r2,-12(fp)
 90b2f04:	10c00617 	ldw	r3,24(r2)
 90b2f08:	e0bffd17 	ldw	r2,-12(fp)
 90b2f0c:	1080028b 	ldhu	r2,10(r2)
 90b2f10:	10bfffcc 	andi	r2,r2,65535
 90b2f14:	1887883a 	add	r3,r3,r2
 90b2f18:	e0bffb17 	ldw	r2,-20(fp)
 90b2f1c:	10800617 	ldw	r2,24(r2)
 90b2f20:	1885c83a 	sub	r2,r3,r2
 90b2f24:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 90b2f28:	e0bff617 	ldw	r2,-40(fp)
 90b2f2c:	10800050 	cmplti	r2,r2,1
 90b2f30:	1000271e 	bne	r2,zero,90b2fd0 <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 90b2f34:	e0bffb17 	ldw	r2,-20(fp)
 90b2f38:	1080028b 	ldhu	r2,10(r2)
 90b2f3c:	10ffffcc 	andi	r3,r2,65535
 90b2f40:	e0bff617 	ldw	r2,-40(fp)
 90b2f44:	10c0130e 	bge	r2,r3,90b2f94 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 90b2f48:	e0bffb17 	ldw	r2,-20(fp)
 90b2f4c:	10c00617 	ldw	r3,24(r2)
 90b2f50:	e0bff617 	ldw	r2,-40(fp)
 90b2f54:	1887883a 	add	r3,r3,r2
 90b2f58:	e0bffb17 	ldw	r2,-20(fp)
 90b2f5c:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 90b2f60:	e0bffb17 	ldw	r2,-20(fp)
 90b2f64:	10c0028b 	ldhu	r3,10(r2)
 90b2f68:	e0bff617 	ldw	r2,-40(fp)
 90b2f6c:	1885c83a 	sub	r2,r3,r2
 90b2f70:	1007883a 	mov	r3,r2
 90b2f74:	e0bffb17 	ldw	r2,-20(fp)
 90b2f78:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 90b2f7c:	e13ffb17 	ldw	r4,-20(fp)
 90b2f80:	90abb240 	call	90abb24 <dtom>
 90b2f84:	1009883a 	mov	r4,r2
 90b2f88:	e17ff617 	ldw	r5,-40(fp)
 90b2f8c:	90ab8fc0 	call	90ab8fc <m_adj>
         break;
 90b2f90:	00000f06 	br	90b2fd0 <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 90b2f94:	e0bffb17 	ldw	r2,-20(fp)
 90b2f98:	10800017 	ldw	r2,0(r2)
 90b2f9c:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 90b2fa0:	e0bffb17 	ldw	r2,-20(fp)
 90b2fa4:	11000117 	ldw	r4,4(r2)
 90b2fa8:	90abb240 	call	90abb24 <dtom>
 90b2fac:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 90b2fb0:	e0bffb17 	ldw	r2,-20(fp)
 90b2fb4:	11000117 	ldw	r4,4(r2)
 90b2fb8:	90abbcc0 	call	90abbcc <remque>
      m_freem (m);
 90b2fbc:	e13ff917 	ldw	r4,-28(fp)
 90b2fc0:	90ab5940 	call	90ab594 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 90b2fc4:	e0fffc17 	ldw	r3,-16(fp)
 90b2fc8:	e0bffb17 	ldw	r2,-20(fp)
 90b2fcc:	10ffcc1e 	bne	r2,r3,90b2f00 <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 90b2fd0:	e0bffb17 	ldw	r2,-20(fp)
 90b2fd4:	11400117 	ldw	r5,4(r2)
 90b2fd8:	e13ffd17 	ldw	r4,-12(fp)
 90b2fdc:	90abc3c0 	call	90abc3c <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 90b2fe0:	e0bffc17 	ldw	r2,-16(fp)
 90b2fe4:	10800217 	ldw	r2,8(r2)
 90b2fe8:	108000c8 	cmpgei	r2,r2,3
 90b2fec:	1000021e 	bne	r2,zero,90b2ff8 <tcp_reass+0x2c0>
      return (0);
 90b2ff0:	e03fff15 	stw	zero,-4(fp)
 90b2ff4:	00004c06 	br	90b3128 <tcp_reass+0x3f0>
   ti = tp->seg_next;
 90b2ff8:	e0bffc17 	ldw	r2,-16(fp)
 90b2ffc:	10800017 	ldw	r2,0(r2)
 90b3000:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 90b3004:	e0fffc17 	ldw	r3,-16(fp)
 90b3008:	e0bffd17 	ldw	r2,-12(fp)
 90b300c:	10c00526 	beq	r2,r3,90b3024 <tcp_reass+0x2ec>
 90b3010:	e0bffd17 	ldw	r2,-12(fp)
 90b3014:	10c00617 	ldw	r3,24(r2)
 90b3018:	e0bffc17 	ldw	r2,-16(fp)
 90b301c:	10801617 	ldw	r2,88(r2)
 90b3020:	18800226 	beq	r3,r2,90b302c <tcp_reass+0x2f4>
      return (0);
 90b3024:	e03fff15 	stw	zero,-4(fp)
 90b3028:	00003f06 	br	90b3128 <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 90b302c:	e0bffc17 	ldw	r2,-16(fp)
 90b3030:	10800217 	ldw	r2,8(r2)
 90b3034:	108000d8 	cmpnei	r2,r2,3
 90b3038:	1000071e 	bne	r2,zero,90b3058 <tcp_reass+0x320>
 90b303c:	e0bffd17 	ldw	r2,-12(fp)
 90b3040:	1080028b 	ldhu	r2,10(r2)
 90b3044:	10bfffcc 	andi	r2,r2,65535
 90b3048:	1005003a 	cmpeq	r2,r2,zero
 90b304c:	1000021e 	bne	r2,zero,90b3058 <tcp_reass+0x320>
      return (0);
 90b3050:	e03fff15 	stw	zero,-4(fp)
 90b3054:	00003406 	br	90b3128 <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 90b3058:	e0bffc17 	ldw	r2,-16(fp)
 90b305c:	10c01617 	ldw	r3,88(r2)
 90b3060:	e0bffd17 	ldw	r2,-12(fp)
 90b3064:	1080028b 	ldhu	r2,10(r2)
 90b3068:	10bfffcc 	andi	r2,r2,65535
 90b306c:	1887883a 	add	r3,r3,r2
 90b3070:	e0bffc17 	ldw	r2,-16(fp)
 90b3074:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 90b3078:	e0bffd17 	ldw	r2,-12(fp)
 90b307c:	10800843 	ldbu	r2,33(r2)
 90b3080:	10803fcc 	andi	r2,r2,255
 90b3084:	1080004c 	andi	r2,r2,1
 90b3088:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 90b308c:	e13ffd17 	ldw	r4,-12(fp)
 90b3090:	90abbcc0 	call	90abbcc <remque>
      m = dtom(ti);
 90b3094:	e13ffd17 	ldw	r4,-12(fp)
 90b3098:	90abb240 	call	90abb24 <dtom>
 90b309c:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 90b30a0:	e0bffd17 	ldw	r2,-12(fp)
 90b30a4:	10800017 	ldw	r2,0(r2)
 90b30a8:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 90b30ac:	e0bffa17 	ldw	r2,-24(fp)
 90b30b0:	1080088b 	ldhu	r2,34(r2)
 90b30b4:	10bfffcc 	andi	r2,r2,65535
 90b30b8:	1080080c 	andi	r2,r2,32
 90b30bc:	1005003a 	cmpeq	r2,r2,zero
 90b30c0:	1000031e 	bne	r2,zero,90b30d0 <tcp_reass+0x398>
         m_freem (m);
 90b30c4:	e13ff917 	ldw	r4,-28(fp)
 90b30c8:	90ab5940 	call	90ab594 <m_freem>
 90b30cc:	00000406 	br	90b30e0 <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 90b30d0:	e0bffa17 	ldw	r2,-24(fp)
 90b30d4:	11000a04 	addi	r4,r2,40
 90b30d8:	e17ff917 	ldw	r5,-28(fp)
 90b30dc:	90b1aa80 	call	90b1aa8 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 90b30e0:	e0fffc17 	ldw	r3,-16(fp)
 90b30e4:	e0bffd17 	ldw	r2,-12(fp)
 90b30e8:	10c00526 	beq	r2,r3,90b3100 <tcp_reass+0x3c8>
 90b30ec:	e0bffd17 	ldw	r2,-12(fp)
 90b30f0:	10c00617 	ldw	r3,24(r2)
 90b30f4:	e0bffc17 	ldw	r2,-16(fp)
 90b30f8:	10801617 	ldw	r2,88(r2)
 90b30fc:	18bfd626 	beq	r3,r2,90b3058 <tcp_reass+0x320>
      sorwakeup(so);
 90b3100:	e0bffa17 	ldw	r2,-24(fp)
 90b3104:	11400a04 	addi	r5,r2,40
 90b3108:	e13ffa17 	ldw	r4,-24(fp)
 90b310c:	90b18e40 	call	90b18e4 <sbwakeup>
   return (flags);
 90b3110:	e0bff817 	ldw	r2,-32(fp)
 90b3114:	e0bfff15 	stw	r2,-4(fp)
 90b3118:	00000306 	br	90b3128 <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 90b311c:	e13ffe17 	ldw	r4,-8(fp)
 90b3120:	90ab5940 	call	90ab594 <m_freem>
   return (0);
 90b3124:	e03fff15 	stw	zero,-4(fp)
 90b3128:	e0bfff17 	ldw	r2,-4(fp)
}
 90b312c:	e037883a 	mov	sp,fp
 90b3130:	dfc00117 	ldw	ra,4(sp)
 90b3134:	df000017 	ldw	fp,0(sp)
 90b3138:	dec00204 	addi	sp,sp,8
 90b313c:	f800283a 	ret

090b3140 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 90b3140:	deffd004 	addi	sp,sp,-192
 90b3144:	dfc02f15 	stw	ra,188(sp)
 90b3148:	df002e15 	stw	fp,184(sp)
 90b314c:	df002e04 	addi	fp,sp,184
 90b3150:	e13ff015 	stw	r4,-64(fp)
 90b3154:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 90b3158:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 90b315c:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 90b3160:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 90b3164:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 90b3168:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 90b316c:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 90b3170:	008243b4 	movhi	r2,2318
 90b3174:	10b75604 	addi	r2,r2,-8872
 90b3178:	10801917 	ldw	r2,100(r2)
 90b317c:	10c00044 	addi	r3,r2,1
 90b3180:	008243b4 	movhi	r2,2318
 90b3184:	10b75604 	addi	r2,r2,-8872
 90b3188:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 90b318c:	008243b4 	movhi	r2,2318
 90b3190:	10b72804 	addi	r2,r2,-9056
 90b3194:	10800917 	ldw	r2,36(r2)
 90b3198:	10c00044 	addi	r3,r2,1
 90b319c:	008243b4 	movhi	r2,2318
 90b31a0:	10b72804 	addi	r2,r2,-9056
 90b31a4:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 90b31a8:	e0bff017 	ldw	r2,-64(fp)
 90b31ac:	10800317 	ldw	r2,12(r2)
 90b31b0:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 90b31b4:	e0bfee17 	ldw	r2,-72(fp)
 90b31b8:	10800003 	ldbu	r2,0(r2)
 90b31bc:	10803fcc 	andi	r2,r2,255
 90b31c0:	108011b0 	cmpltui	r2,r2,70
 90b31c4:	1000061e 	bne	r2,zero,90b31e0 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 90b31c8:	e13fee17 	ldw	r4,-72(fp)
 90b31cc:	e17ff017 	ldw	r5,-64(fp)
 90b31d0:	90ac6000 	call	90ac600 <np_stripoptions>
         pip = mtod(m, struct ip *);
 90b31d4:	e0bff017 	ldw	r2,-64(fp)
 90b31d8:	10800317 	ldw	r2,12(r2)
 90b31dc:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 90b31e0:	e0bff017 	ldw	r2,-64(fp)
 90b31e4:	10800217 	ldw	r2,8(r2)
 90b31e8:	10800a28 	cmpgeui	r2,r2,40
 90b31ec:	1000081e 	bne	r2,zero,90b3210 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 90b31f0:	008243b4 	movhi	r2,2318
 90b31f4:	10b75604 	addi	r2,r2,-8872
 90b31f8:	10801e17 	ldw	r2,120(r2)
 90b31fc:	10c00044 	addi	r3,r2,1
 90b3200:	008243b4 	movhi	r2,2318
 90b3204:	10b75604 	addi	r2,r2,-8872
 90b3208:	10c01e15 	stw	r3,120(r2)
         return;
 90b320c:	00091c06 	br	90b5680 <tcp_input+0x2540>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 90b3210:	e0bfee17 	ldw	r2,-72(fp)
 90b3214:	1080008b 	ldhu	r2,2(r2)
 90b3218:	10bfffcc 	andi	r2,r2,65535
 90b321c:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 90b3220:	e0bff017 	ldw	r2,-64(fp)
 90b3224:	10800317 	ldw	r2,12(r2)
 90b3228:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 90b322c:	e0bff017 	ldw	r2,-64(fp)
 90b3230:	10800117 	ldw	r2,4(r2)
 90b3234:	10c00117 	ldw	r3,4(r2)
 90b3238:	e0bfed17 	ldw	r2,-76(fp)
 90b323c:	10c0032e 	bgeu	r2,r3,90b324c <tcp_input+0x10c>
      {
         panic("tcp_input");
 90b3240:	01024374 	movhi	r4,2317
 90b3244:	21026404 	addi	r4,r4,2448
 90b3248:	90a537c0 	call	90a537c <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 90b324c:	e0bfed17 	ldw	r2,-76(fp)
 90b3250:	10800803 	ldbu	r2,32(r2)
 90b3254:	10803fcc 	andi	r2,r2,255
 90b3258:	1004d13a 	srli	r2,r2,4
 90b325c:	10803fcc 	andi	r2,r2,255
 90b3260:	1085883a 	add	r2,r2,r2
 90b3264:	1085883a 	add	r2,r2,r2
 90b3268:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 90b326c:	e0bfe817 	ldw	r2,-96(fp)
 90b3270:	10800530 	cmpltui	r2,r2,20
 90b3274:	1000031e 	bne	r2,zero,90b3284 <tcp_input+0x144>
 90b3278:	e0ffe817 	ldw	r3,-96(fp)
 90b327c:	e0bfe917 	ldw	r2,-92(fp)
 90b3280:	10c0110e 	bge	r2,r3,90b32c8 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 90b3284:	008243b4 	movhi	r2,2318
 90b3288:	10b75604 	addi	r2,r2,-8872
 90b328c:	10801d17 	ldw	r2,116(r2)
 90b3290:	10c00044 	addi	r3,r2,1
 90b3294:	008243b4 	movhi	r2,2318
 90b3298:	10b75604 	addi	r2,r2,-8872
 90b329c:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 90b32a0:	008243b4 	movhi	r2,2318
 90b32a4:	10b72804 	addi	r2,r2,-9056
 90b32a8:	10800d17 	ldw	r2,52(r2)
 90b32ac:	10c00044 	addi	r3,r2,1
 90b32b0:	008243b4 	movhi	r2,2318
 90b32b4:	10b72804 	addi	r2,r2,-9056
 90b32b8:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 90b32bc:	00805784 	movi	r2,350
 90b32c0:	d0a0b315 	stw	r2,-32052(gp)
 90b32c4:	0008e206 	br	90b5650 <tcp_input+0x2510>
   }
   tlen -= (int)off;
 90b32c8:	e0ffe917 	ldw	r3,-92(fp)
 90b32cc:	e0bfe817 	ldw	r2,-96(fp)
 90b32d0:	1885c83a 	sub	r2,r3,r2
 90b32d4:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 90b32d8:	e0bfe917 	ldw	r2,-92(fp)
 90b32dc:	1007883a 	mov	r3,r2
 90b32e0:	e0bfed17 	ldw	r2,-76(fp)
 90b32e4:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 90b32e8:	e0bfe817 	ldw	r2,-96(fp)
 90b32ec:	10800570 	cmpltui	r2,r2,21
 90b32f0:	1000341e 	bne	r2,zero,90b33c4 <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 90b32f4:	e0bfe817 	ldw	r2,-96(fp)
 90b32f8:	10bffb04 	addi	r2,r2,-20
 90b32fc:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 90b3300:	01000044 	movi	r4,1
 90b3304:	e17fdd17 	ldw	r5,-140(fp)
 90b3308:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b330c:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 90b3310:	e0bfeb17 	ldw	r2,-84(fp)
 90b3314:	1004c03a 	cmpne	r2,r2,zero
 90b3318:	1000031e 	bne	r2,zero,90b3328 <tcp_input+0x1e8>
         GOTO_DROP;
 90b331c:	00805a84 	movi	r2,362
 90b3320:	d0a0b315 	stw	r2,-32052(gp)
 90b3324:	0008ca06 	br	90b5650 <tcp_input+0x2510>
      om->m_len = olen;       /* set mbuf length */
 90b3328:	e0ffdd17 	ldw	r3,-140(fp)
 90b332c:	e0bfeb17 	ldw	r2,-84(fp)
 90b3330:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 90b3334:	e0bff017 	ldw	r2,-64(fp)
 90b3338:	10800117 	ldw	r2,4(r2)
 90b333c:	1080080b 	ldhu	r2,32(r2)
 90b3340:	10ffffcc 	andi	r3,r2,65535
 90b3344:	00b76194 	movui	r2,56710
 90b3348:	1880051e 	bne	r3,r2,90b3360 <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 90b334c:	e0bff017 	ldw	r2,-64(fp)
 90b3350:	10800317 	ldw	r2,12(r2)
 90b3354:	10800504 	addi	r2,r2,20
 90b3358:	e0bfdc15 	stw	r2,-144(fp)
 90b335c:	00000406 	br	90b3370 <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 90b3360:	e0bff017 	ldw	r2,-64(fp)
 90b3364:	10800317 	ldw	r2,12(r2)
 90b3368:	10800a04 	addi	r2,r2,40
 90b336c:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 90b3370:	e0bfeb17 	ldw	r2,-84(fp)
 90b3374:	10c00317 	ldw	r3,12(r2)
 90b3378:	e1bfdd17 	ldw	r6,-140(fp)
 90b337c:	e0bfdc17 	ldw	r2,-144(fp)
 90b3380:	1809883a 	mov	r4,r3
 90b3384:	100b883a 	mov	r5,r2
 90b3388:	90894600 	call	9089460 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 90b338c:	e0bff017 	ldw	r2,-64(fp)
 90b3390:	10c00317 	ldw	r3,12(r2)
 90b3394:	e0bfeb17 	ldw	r2,-84(fp)
 90b3398:	10800217 	ldw	r2,8(r2)
 90b339c:	1887883a 	add	r3,r3,r2
 90b33a0:	e0bff017 	ldw	r2,-64(fp)
 90b33a4:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 90b33a8:	e0bff017 	ldw	r2,-64(fp)
 90b33ac:	10c00217 	ldw	r3,8(r2)
 90b33b0:	e0bfeb17 	ldw	r2,-84(fp)
 90b33b4:	10800217 	ldw	r2,8(r2)
 90b33b8:	1887c83a 	sub	r3,r3,r2
 90b33bc:	e0bff017 	ldw	r2,-64(fp)
 90b33c0:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 90b33c4:	e0bfed17 	ldw	r2,-76(fp)
 90b33c8:	10800843 	ldbu	r2,33(r2)
 90b33cc:	10803fcc 	andi	r2,r2,255
 90b33d0:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 90b33d4:	e0bfed17 	ldw	r2,-76(fp)
 90b33d8:	10800617 	ldw	r2,24(r2)
 90b33dc:	1004d63a 	srli	r2,r2,24
 90b33e0:	10c03fcc 	andi	r3,r2,255
 90b33e4:	e0bfed17 	ldw	r2,-76(fp)
 90b33e8:	10800617 	ldw	r2,24(r2)
 90b33ec:	1004d23a 	srli	r2,r2,8
 90b33f0:	10bfc00c 	andi	r2,r2,65280
 90b33f4:	1886b03a 	or	r3,r3,r2
 90b33f8:	e0bfed17 	ldw	r2,-76(fp)
 90b33fc:	10800617 	ldw	r2,24(r2)
 90b3400:	10bfc00c 	andi	r2,r2,65280
 90b3404:	1004923a 	slli	r2,r2,8
 90b3408:	1886b03a 	or	r3,r3,r2
 90b340c:	e0bfed17 	ldw	r2,-76(fp)
 90b3410:	10800617 	ldw	r2,24(r2)
 90b3414:	10803fcc 	andi	r2,r2,255
 90b3418:	1004963a 	slli	r2,r2,24
 90b341c:	1886b03a 	or	r3,r3,r2
 90b3420:	e0bfed17 	ldw	r2,-76(fp)
 90b3424:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 90b3428:	e0bfed17 	ldw	r2,-76(fp)
 90b342c:	10800717 	ldw	r2,28(r2)
 90b3430:	1004d63a 	srli	r2,r2,24
 90b3434:	10c03fcc 	andi	r3,r2,255
 90b3438:	e0bfed17 	ldw	r2,-76(fp)
 90b343c:	10800717 	ldw	r2,28(r2)
 90b3440:	1004d23a 	srli	r2,r2,8
 90b3444:	10bfc00c 	andi	r2,r2,65280
 90b3448:	1886b03a 	or	r3,r3,r2
 90b344c:	e0bfed17 	ldw	r2,-76(fp)
 90b3450:	10800717 	ldw	r2,28(r2)
 90b3454:	10bfc00c 	andi	r2,r2,65280
 90b3458:	1004923a 	slli	r2,r2,8
 90b345c:	1886b03a 	or	r3,r3,r2
 90b3460:	e0bfed17 	ldw	r2,-76(fp)
 90b3464:	10800717 	ldw	r2,28(r2)
 90b3468:	10803fcc 	andi	r2,r2,255
 90b346c:	1004963a 	slli	r2,r2,24
 90b3470:	1886b03a 	or	r3,r3,r2
 90b3474:	e0bfed17 	ldw	r2,-76(fp)
 90b3478:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 90b347c:	e0bfed17 	ldw	r2,-76(fp)
 90b3480:	1080098b 	ldhu	r2,38(r2)
 90b3484:	10bfffcc 	andi	r2,r2,65535
 90b3488:	1004d23a 	srli	r2,r2,8
 90b348c:	10803fcc 	andi	r2,r2,255
 90b3490:	1009883a 	mov	r4,r2
 90b3494:	e0bfed17 	ldw	r2,-76(fp)
 90b3498:	1080098b 	ldhu	r2,38(r2)
 90b349c:	10bfffcc 	andi	r2,r2,65535
 90b34a0:	1004923a 	slli	r2,r2,8
 90b34a4:	1007883a 	mov	r3,r2
 90b34a8:	00bfc004 	movi	r2,-256
 90b34ac:	1884703a 	and	r2,r3,r2
 90b34b0:	2084b03a 	or	r2,r4,r2
 90b34b4:	1007883a 	mov	r3,r2
 90b34b8:	e0bfed17 	ldw	r2,-76(fp)
 90b34bc:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 90b34c0:	e0bff017 	ldw	r2,-64(fp)
 90b34c4:	10800117 	ldw	r2,4(r2)
 90b34c8:	1080080b 	ldhu	r2,32(r2)
 90b34cc:	10bfffcc 	andi	r2,r2,65535
 90b34d0:	10800220 	cmpeqi	r2,r2,8
 90b34d4:	1000011e 	bne	r2,zero,90b34dc <tcp_input+0x39c>
 90b34d8:	00001f06 	br	90b3558 <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 90b34dc:	e0bff017 	ldw	r2,-64(fp)
 90b34e0:	10800317 	ldw	r2,12(r2)
 90b34e4:	10c00a04 	addi	r3,r2,40
 90b34e8:	e0bff017 	ldw	r2,-64(fp)
 90b34ec:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 90b34f0:	e0bff017 	ldw	r2,-64(fp)
 90b34f4:	10800217 	ldw	r2,8(r2)
 90b34f8:	10fff604 	addi	r3,r2,-40
 90b34fc:	e0bff017 	ldw	r2,-64(fp)
 90b3500:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 90b3504:	e0bfed17 	ldw	r2,-76(fp)
 90b3508:	11400317 	ldw	r5,12(r2)
 90b350c:	e0bfed17 	ldw	r2,-76(fp)
 90b3510:	1080050b 	ldhu	r2,20(r2)
 90b3514:	11bfffcc 	andi	r6,r2,65535
 90b3518:	e0bfed17 	ldw	r2,-76(fp)
 90b351c:	11c00417 	ldw	r7,16(r2)
 90b3520:	e0bfed17 	ldw	r2,-76(fp)
 90b3524:	1080058b 	ldhu	r2,22(r2)
 90b3528:	10bfffcc 	andi	r2,r2,65535
 90b352c:	d8800015 	stw	r2,0(sp)
 90b3530:	00800044 	movi	r2,1
 90b3534:	d8800115 	stw	r2,4(sp)
 90b3538:	010243b4 	movhi	r4,2318
 90b353c:	21374b04 	addi	r4,r4,-8916
 90b3540:	90c7ecc0 	call	90c7ecc <in_pcblookup>
 90b3544:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 90b3548:	e0bfec17 	ldw	r2,-80(fp)
 90b354c:	1005003a 	cmpeq	r2,r2,zero
 90b3550:	1000031e 	bne	r2,zero,90b3560 <tcp_input+0x420>
 90b3554:	00000506 	br	90b356c <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 90b3558:	90aa4780 	call	90aa478 <dtrap>
      return;
 90b355c:	00084806 	br	90b5680 <tcp_input+0x2540>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 90b3560:	00806b04 	movi	r2,428
 90b3564:	d0a0b315 	stw	r2,-32052(gp)
 90b3568:	0007f506 	br	90b5540 <tcp_input+0x2400>
   tp = intotcpcb (inp);
 90b356c:	e0bfec17 	ldw	r2,-80(fp)
 90b3570:	10800917 	ldw	r2,36(r2)
 90b3574:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 90b3578:	e0bfe717 	ldw	r2,-100(fp)
 90b357c:	1004c03a 	cmpne	r2,r2,zero
 90b3580:	1000031e 	bne	r2,zero,90b3590 <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 90b3584:	00806bc4 	movi	r2,431
 90b3588:	d0a0b315 	stw	r2,-32052(gp)
 90b358c:	0007ec06 	br	90b5540 <tcp_input+0x2400>
   if (tp->t_state == TCPS_CLOSED)
 90b3590:	e0bfe717 	ldw	r2,-100(fp)
 90b3594:	10800217 	ldw	r2,8(r2)
 90b3598:	1004c03a 	cmpne	r2,r2,zero
 90b359c:	1000031e 	bne	r2,zero,90b35ac <tcp_input+0x46c>
      GOTO_DROP;
 90b35a0:	00806c44 	movi	r2,433
 90b35a4:	d0a0b315 	stw	r2,-32052(gp)
 90b35a8:	00082906 	br	90b5650 <tcp_input+0x2510>
   so = inp->inp_socket;
 90b35ac:	e0bfec17 	ldw	r2,-80(fp)
 90b35b0:	10800817 	ldw	r2,32(r2)
 90b35b4:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 90b35b8:	e0bfed17 	ldw	r2,-76(fp)
 90b35bc:	1080088b 	ldhu	r2,34(r2)
 90b35c0:	10bfffcc 	andi	r2,r2,65535
 90b35c4:	1004d23a 	srli	r2,r2,8
 90b35c8:	10bfffcc 	andi	r2,r2,65535
 90b35cc:	10c03fcc 	andi	r3,r2,255
 90b35d0:	e0bfed17 	ldw	r2,-76(fp)
 90b35d4:	1080088b 	ldhu	r2,34(r2)
 90b35d8:	10bfffcc 	andi	r2,r2,65535
 90b35dc:	1004923a 	slli	r2,r2,8
 90b35e0:	10bfc00c 	andi	r2,r2,65280
 90b35e4:	1884b03a 	or	r2,r3,r2
 90b35e8:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 90b35ec:	e0bfe517 	ldw	r2,-108(fp)
 90b35f0:	10800417 	ldw	r2,16(r2)
 90b35f4:	1080008c 	andi	r2,r2,2
 90b35f8:	1005003a 	cmpeq	r2,r2,zero
 90b35fc:	10002d1e 	bne	r2,zero,90b36b4 <tcp_input+0x574>
   {
      so = sonewconn(so);
 90b3600:	e13fe517 	ldw	r4,-108(fp)
 90b3604:	90b13bc0 	call	90b13bc <sonewconn>
 90b3608:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 90b360c:	e0bfe517 	ldw	r2,-108(fp)
 90b3610:	1004c03a 	cmpne	r2,r2,zero
 90b3614:	1000031e 	bne	r2,zero,90b3624 <tcp_input+0x4e4>
         GOTO_DROP;
 90b3618:	00807344 	movi	r2,461
 90b361c:	d0a0b315 	stw	r2,-32052(gp)
 90b3620:	00080b06 	br	90b5650 <tcp_input+0x2510>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 90b3624:	e0bfe017 	ldw	r2,-128(fp)
 90b3628:	10800044 	addi	r2,r2,1
 90b362c:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 90b3630:	e0bfe517 	ldw	r2,-108(fp)
 90b3634:	10800117 	ldw	r2,4(r2)
 90b3638:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 90b363c:	e0ffec17 	ldw	r3,-80(fp)
 90b3640:	e0bff117 	ldw	r2,-60(fp)
 90b3644:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 90b3648:	e0bfe517 	ldw	r2,-108(fp)
 90b364c:	10800517 	ldw	r2,20(r2)
 90b3650:	108000a0 	cmpeqi	r2,r2,2
 90b3654:	1000011e 	bne	r2,zero,90b365c <tcp_input+0x51c>
 90b3658:	00000c06 	br	90b368c <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 90b365c:	e0bfed17 	ldw	r2,-76(fp)
 90b3660:	10c00417 	ldw	r3,16(r2)
 90b3664:	e0bfec17 	ldw	r2,-80(fp)
 90b3668:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 90b366c:	e0bff117 	ldw	r2,-60(fp)
 90b3670:	10c00917 	ldw	r3,36(r2)
 90b3674:	e0bff117 	ldw	r2,-60(fp)
 90b3678:	10800817 	ldw	r2,32(r2)
 90b367c:	1885c83a 	sub	r2,r3,r2
 90b3680:	10fff604 	addi	r3,r2,-40
 90b3684:	e0bfec17 	ldw	r2,-80(fp)
 90b3688:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 90b368c:	e0bfed17 	ldw	r2,-76(fp)
 90b3690:	10c0058b 	ldhu	r3,22(r2)
 90b3694:	e0bfec17 	ldw	r2,-80(fp)
 90b3698:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 90b369c:	e0bfec17 	ldw	r2,-80(fp)
 90b36a0:	10800917 	ldw	r2,36(r2)
 90b36a4:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 90b36a8:	e0ffe717 	ldw	r3,-100(fp)
 90b36ac:	00800044 	movi	r2,1
 90b36b0:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 90b36b4:	e0bfe717 	ldw	r2,-100(fp)
 90b36b8:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 90b36bc:	00824374 	movhi	r2,2317
 90b36c0:	108ec104 	addi	r2,r2,15108
 90b36c4:	10c00017 	ldw	r3,0(r2)
 90b36c8:	e0bfe717 	ldw	r2,-100(fp)
 90b36cc:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 90b36d0:	e0bfeb17 	ldw	r2,-84(fp)
 90b36d4:	1005003a 	cmpeq	r2,r2,zero
 90b36d8:	1000091e 	bne	r2,zero,90b3700 <tcp_input+0x5c0>
 90b36dc:	e0bfe717 	ldw	r2,-100(fp)
 90b36e0:	10800217 	ldw	r2,8(r2)
 90b36e4:	10800060 	cmpeqi	r2,r2,1
 90b36e8:	1000051e 	bne	r2,zero,90b3700 <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 90b36ec:	e13fe717 	ldw	r4,-100(fp)
 90b36f0:	e17feb17 	ldw	r5,-84(fp)
 90b36f4:	e1bfed17 	ldw	r6,-76(fp)
 90b36f8:	90b56940 	call	90b5694 <tcp_dooptions>
      om = 0;
 90b36fc:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 90b3700:	e0bfed17 	ldw	r2,-76(fp)
 90b3704:	10c00717 	ldw	r3,28(r2)
 90b3708:	e0bfe717 	ldw	r2,-100(fp)
 90b370c:	10800e17 	ldw	r2,56(r2)
 90b3710:	1885c83a 	sub	r2,r3,r2
 90b3714:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 90b3718:	e0bfe517 	ldw	r2,-108(fp)
 90b371c:	10800b17 	ldw	r2,44(r2)
 90b3720:	1007883a 	mov	r3,r2
 90b3724:	e0bfe517 	ldw	r2,-108(fp)
 90b3728:	10800a17 	ldw	r2,40(r2)
 90b372c:	1885c83a 	sub	r2,r3,r2
 90b3730:	1004803a 	cmplt	r2,r2,zero
 90b3734:	1000071e 	bne	r2,zero,90b3754 <tcp_input+0x614>
 90b3738:	e0bfe517 	ldw	r2,-108(fp)
 90b373c:	10c00b17 	ldw	r3,44(r2)
 90b3740:	e0bfe517 	ldw	r2,-108(fp)
 90b3744:	10800a17 	ldw	r2,40(r2)
 90b3748:	1885c83a 	sub	r2,r3,r2
 90b374c:	e0bffd15 	stw	r2,-12(fp)
 90b3750:	00000106 	br	90b3758 <tcp_input+0x618>
 90b3754:	e03ffd15 	stw	zero,-12(fp)
 90b3758:	e0bffd17 	ldw	r2,-12(fp)
 90b375c:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 90b3760:	e0bfdb17 	ldw	r2,-148(fp)
 90b3764:	1004403a 	cmpge	r2,r2,zero
 90b3768:	1000011e 	bne	r2,zero,90b3770 <tcp_input+0x630>
         win = 0;
 90b376c:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 90b3770:	e0bfe717 	ldw	r2,-100(fp)
 90b3774:	10c01917 	ldw	r3,100(r2)
 90b3778:	e0bfe717 	ldw	r2,-100(fp)
 90b377c:	10801617 	ldw	r2,88(r2)
 90b3780:	1885c83a 	sub	r2,r3,r2
 90b3784:	e0ffdb17 	ldw	r3,-148(fp)
 90b3788:	e0fffc15 	stw	r3,-16(fp)
 90b378c:	e0bffb15 	stw	r2,-20(fp)
 90b3790:	e13ffb17 	ldw	r4,-20(fp)
 90b3794:	e0bffc17 	ldw	r2,-16(fp)
 90b3798:	2080022e 	bgeu	r4,r2,90b37a4 <tcp_input+0x664>
 90b379c:	e0fffc17 	ldw	r3,-16(fp)
 90b37a0:	e0fffb15 	stw	r3,-20(fp)
 90b37a4:	e0bfe717 	ldw	r2,-100(fp)
 90b37a8:	e13ffb17 	ldw	r4,-20(fp)
 90b37ac:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 90b37b0:	e0bfe717 	ldw	r2,-100(fp)
 90b37b4:	10800217 	ldw	r2,8(r2)
 90b37b8:	10800118 	cmpnei	r2,r2,4
 90b37bc:	10010f1e 	bne	r2,zero,90b3bfc <tcp_input+0xabc>
 90b37c0:	e0bfe617 	ldw	r2,-104(fp)
 90b37c4:	10800dcc 	andi	r2,r2,55
 90b37c8:	10800418 	cmpnei	r2,r2,16
 90b37cc:	10010b1e 	bne	r2,zero,90b3bfc <tcp_input+0xabc>
 90b37d0:	e0bfed17 	ldw	r2,-76(fp)
 90b37d4:	10c00617 	ldw	r3,24(r2)
 90b37d8:	e0bfe717 	ldw	r2,-100(fp)
 90b37dc:	10801617 	ldw	r2,88(r2)
 90b37e0:	1881061e 	bne	r3,r2,90b3bfc <tcp_input+0xabc>
 90b37e4:	e0bfde17 	ldw	r2,-136(fp)
 90b37e8:	1005003a 	cmpeq	r2,r2,zero
 90b37ec:	1001031e 	bne	r2,zero,90b3bfc <tcp_input+0xabc>
 90b37f0:	e0bfe717 	ldw	r2,-100(fp)
 90b37f4:	10c01417 	ldw	r3,80(r2)
 90b37f8:	e0bfde17 	ldw	r2,-136(fp)
 90b37fc:	1880ff1e 	bne	r3,r2,90b3bfc <tcp_input+0xabc>
 90b3800:	e0bfe717 	ldw	r2,-100(fp)
 90b3804:	10c00f17 	ldw	r3,60(r2)
 90b3808:	e0bfe717 	ldw	r2,-100(fp)
 90b380c:	10801a17 	ldw	r2,104(r2)
 90b3810:	1880fa1e 	bne	r3,r2,90b3bfc <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 90b3814:	e0bfed17 	ldw	r2,-76(fp)
 90b3818:	1080028b 	ldhu	r2,10(r2)
 90b381c:	10bfffcc 	andi	r2,r2,65535
 90b3820:	1004c03a 	cmpne	r2,r2,zero
 90b3824:	1000651e 	bne	r2,zero,90b39bc <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 90b3828:	e0bfed17 	ldw	r2,-76(fp)
 90b382c:	10c00717 	ldw	r3,28(r2)
 90b3830:	e0bfe717 	ldw	r2,-100(fp)
 90b3834:	10800e17 	ldw	r2,56(r2)
 90b3838:	1885c83a 	sub	r2,r3,r2
 90b383c:	10800050 	cmplti	r2,r2,1
 90b3840:	1000ee1e 	bne	r2,zero,90b3bfc <tcp_input+0xabc>
 90b3844:	e0bfed17 	ldw	r2,-76(fp)
 90b3848:	10c00717 	ldw	r3,28(r2)
 90b384c:	e0bfe717 	ldw	r2,-100(fp)
 90b3850:	10801a17 	ldw	r2,104(r2)
 90b3854:	1885c83a 	sub	r2,r3,r2
 90b3858:	10800048 	cmpgei	r2,r2,1
 90b385c:	1000e71e 	bne	r2,zero,90b3bfc <tcp_input+0xabc>
 90b3860:	e0bfe717 	ldw	r2,-100(fp)
 90b3864:	10c01b17 	ldw	r3,108(r2)
 90b3868:	e0bfe717 	ldw	r2,-100(fp)
 90b386c:	10801417 	ldw	r2,80(r2)
 90b3870:	1880e236 	bltu	r3,r2,90b3bfc <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 90b3874:	008243b4 	movhi	r2,2318
 90b3878:	10b75604 	addi	r2,r2,-8872
 90b387c:	10803517 	ldw	r2,212(r2)
 90b3880:	10c00044 	addi	r3,r2,1
 90b3884:	008243b4 	movhi	r2,2318
 90b3888:	10b75604 	addi	r2,r2,-8872
 90b388c:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 90b3890:	e0bfe717 	ldw	r2,-100(fp)
 90b3894:	10801e17 	ldw	r2,120(r2)
 90b3898:	1005003a 	cmpeq	r2,r2,zero
 90b389c:	1000091e 	bne	r2,zero,90b38c4 <tcp_input+0x784>
 90b38a0:	e0bfed17 	ldw	r2,-76(fp)
 90b38a4:	10c00717 	ldw	r3,28(r2)
 90b38a8:	e0bfe717 	ldw	r2,-100(fp)
 90b38ac:	10801f17 	ldw	r2,124(r2)
 90b38b0:	1885c83a 	sub	r2,r3,r2
 90b38b4:	10800050 	cmplti	r2,r2,1
 90b38b8:	1000021e 	bne	r2,zero,90b38c4 <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 90b38bc:	e13fe717 	ldw	r4,-100(fp)
 90b38c0:	90b59500 	call	90b5950 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 90b38c4:	008243b4 	movhi	r2,2318
 90b38c8:	10b75604 	addi	r2,r2,-8872
 90b38cc:	10802b17 	ldw	r2,172(r2)
 90b38d0:	10c00044 	addi	r3,r2,1
 90b38d4:	008243b4 	movhi	r2,2318
 90b38d8:	10b75604 	addi	r2,r2,-8872
 90b38dc:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 90b38e0:	008243b4 	movhi	r2,2318
 90b38e4:	10b75604 	addi	r2,r2,-8872
 90b38e8:	10c02c17 	ldw	r3,176(r2)
 90b38ec:	e0bfe317 	ldw	r2,-116(fp)
 90b38f0:	1887883a 	add	r3,r3,r2
 90b38f4:	008243b4 	movhi	r2,2318
 90b38f8:	10b75604 	addi	r2,r2,-8872
 90b38fc:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 90b3900:	e0bfe517 	ldw	r2,-108(fp)
 90b3904:	11001204 	addi	r4,r2,72
 90b3908:	e17fe317 	ldw	r5,-116(fp)
 90b390c:	90b20b00 	call	90b20b0 <sbdrop>
            tp->snd_una = ti->ti_ack;
 90b3910:	e0bfed17 	ldw	r2,-76(fp)
 90b3914:	10c00717 	ldw	r3,28(r2)
 90b3918:	e0bfe717 	ldw	r2,-100(fp)
 90b391c:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 90b3920:	e13ff017 	ldw	r4,-64(fp)
 90b3924:	90ab5940 	call	90ab594 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 90b3928:	e0bfe717 	ldw	r2,-100(fp)
 90b392c:	10c00e17 	ldw	r3,56(r2)
 90b3930:	e0bfe717 	ldw	r2,-100(fp)
 90b3934:	10801a17 	ldw	r2,104(r2)
 90b3938:	1880031e 	bne	r3,r2,90b3948 <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 90b393c:	e0bfe717 	ldw	r2,-100(fp)
 90b3940:	10000315 	stw	zero,12(r2)
 90b3944:	00000806 	br	90b3968 <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 90b3948:	e0bfe717 	ldw	r2,-100(fp)
 90b394c:	10800417 	ldw	r2,16(r2)
 90b3950:	1004c03a 	cmpne	r2,r2,zero
 90b3954:	1000041e 	bne	r2,zero,90b3968 <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b3958:	e0bfe717 	ldw	r2,-100(fp)
 90b395c:	10c00817 	ldw	r3,32(r2)
 90b3960:	e0bfe717 	ldw	r2,-100(fp)
 90b3964:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 90b3968:	e0bfe517 	ldw	r2,-108(fp)
 90b396c:	1080190b 	ldhu	r2,100(r2)
 90b3970:	10bfffcc 	andi	r2,r2,65535
 90b3974:	1080030c 	andi	r2,r2,12
 90b3978:	1005003a 	cmpeq	r2,r2,zero
 90b397c:	1000041e 	bne	r2,zero,90b3990 <tcp_input+0x850>
               sowwakeup(so);
 90b3980:	e0bfe517 	ldw	r2,-108(fp)
 90b3984:	11401204 	addi	r5,r2,72
 90b3988:	e13fe517 	ldw	r4,-108(fp)
 90b398c:	90b18e40 	call	90b18e4 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 90b3990:	e0bfe517 	ldw	r2,-108(fp)
 90b3994:	11001217 	ldw	r4,72(r2)
 90b3998:	e0bfe717 	ldw	r2,-100(fp)
 90b399c:	10c00f17 	ldw	r3,60(r2)
 90b39a0:	e0bfe717 	ldw	r2,-100(fp)
 90b39a4:	10800e17 	ldw	r2,56(r2)
 90b39a8:	1885c83a 	sub	r2,r3,r2
 90b39ac:	1107342e 	bgeu	r2,r4,90b5680 <tcp_input+0x2540>
               (void) tcp_output(tp);
 90b39b0:	e13fe717 	ldw	r4,-100(fp)
 90b39b4:	90b5d540 	call	90b5d54 <tcp_output>
            return;
 90b39b8:	00073106 	br	90b5680 <tcp_input+0x2540>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 90b39bc:	e0bfed17 	ldw	r2,-76(fp)
 90b39c0:	10c00717 	ldw	r3,28(r2)
 90b39c4:	e0bfe717 	ldw	r2,-100(fp)
 90b39c8:	10800e17 	ldw	r2,56(r2)
 90b39cc:	18808b1e 	bne	r3,r2,90b3bfc <tcp_input+0xabc>
 90b39d0:	e0bfe717 	ldw	r2,-100(fp)
 90b39d4:	10c00017 	ldw	r3,0(r2)
 90b39d8:	e0bfe717 	ldw	r2,-100(fp)
 90b39dc:	1880871e 	bne	r3,r2,90b3bfc <tcp_input+0xabc>
 90b39e0:	e0bfed17 	ldw	r2,-76(fp)
 90b39e4:	1080028b 	ldhu	r2,10(r2)
 90b39e8:	10bfffcc 	andi	r2,r2,65535
 90b39ec:	e0bffa15 	stw	r2,-24(fp)
 90b39f0:	e0bfe517 	ldw	r2,-108(fp)
 90b39f4:	10800b17 	ldw	r2,44(r2)
 90b39f8:	1007883a 	mov	r3,r2
 90b39fc:	e0bfe517 	ldw	r2,-108(fp)
 90b3a00:	10800a17 	ldw	r2,40(r2)
 90b3a04:	1885c83a 	sub	r2,r3,r2
 90b3a08:	1004803a 	cmplt	r2,r2,zero
 90b3a0c:	1000071e 	bne	r2,zero,90b3a2c <tcp_input+0x8ec>
 90b3a10:	e0bfe517 	ldw	r2,-108(fp)
 90b3a14:	10c00b17 	ldw	r3,44(r2)
 90b3a18:	e0bfe517 	ldw	r2,-108(fp)
 90b3a1c:	10800a17 	ldw	r2,40(r2)
 90b3a20:	1887c83a 	sub	r3,r3,r2
 90b3a24:	e0fff915 	stw	r3,-28(fp)
 90b3a28:	00000106 	br	90b3a30 <tcp_input+0x8f0>
 90b3a2c:	e03ff915 	stw	zero,-28(fp)
 90b3a30:	e0bff917 	ldw	r2,-28(fp)
 90b3a34:	e0fffa17 	ldw	r3,-24(fp)
 90b3a38:	10c07036 	bltu	r2,r3,90b3bfc <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 90b3a3c:	e0bfe717 	ldw	r2,-100(fp)
 90b3a40:	10801517 	ldw	r2,84(r2)
 90b3a44:	1004c03a 	cmpne	r2,r2,zero
 90b3a48:	10000c1e 	bne	r2,zero,90b3a7c <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 90b3a4c:	008243b4 	movhi	r2,2318
 90b3a50:	10b75604 	addi	r2,r2,-8872
 90b3a54:	10802817 	ldw	r2,160(r2)
 90b3a58:	10c00044 	addi	r3,r2,1
 90b3a5c:	008243b4 	movhi	r2,2318
 90b3a60:	10b75604 	addi	r2,r2,-8872
 90b3a64:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 90b3a68:	e13ff017 	ldw	r4,-64(fp)
 90b3a6c:	90ab5940 	call	90ab594 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 90b3a70:	e13fe717 	ldw	r4,-100(fp)
 90b3a74:	90b5d540 	call	90b5d54 <tcp_output>
            return;
 90b3a78:	00070106 	br	90b5680 <tcp_input+0x2540>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 90b3a7c:	008243b4 	movhi	r2,2318
 90b3a80:	10b75604 	addi	r2,r2,-8872
 90b3a84:	10803617 	ldw	r2,216(r2)
 90b3a88:	10c00044 	addi	r3,r2,1
 90b3a8c:	008243b4 	movhi	r2,2318
 90b3a90:	10b75604 	addi	r2,r2,-8872
 90b3a94:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 90b3a98:	e0bfe717 	ldw	r2,-100(fp)
 90b3a9c:	10c01617 	ldw	r3,88(r2)
 90b3aa0:	e0bfed17 	ldw	r2,-76(fp)
 90b3aa4:	1080028b 	ldhu	r2,10(r2)
 90b3aa8:	10bfffcc 	andi	r2,r2,65535
 90b3aac:	1887883a 	add	r3,r3,r2
 90b3ab0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ab4:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 90b3ab8:	008243b4 	movhi	r2,2318
 90b3abc:	10b75604 	addi	r2,r2,-8872
 90b3ac0:	10801a17 	ldw	r2,104(r2)
 90b3ac4:	10c00044 	addi	r3,r2,1
 90b3ac8:	008243b4 	movhi	r2,2318
 90b3acc:	10b75604 	addi	r2,r2,-8872
 90b3ad0:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 90b3ad4:	008243b4 	movhi	r2,2318
 90b3ad8:	10b75604 	addi	r2,r2,-8872
 90b3adc:	10c01b17 	ldw	r3,108(r2)
 90b3ae0:	e0bfed17 	ldw	r2,-76(fp)
 90b3ae4:	1080028b 	ldhu	r2,10(r2)
 90b3ae8:	10bfffcc 	andi	r2,r2,65535
 90b3aec:	1887883a 	add	r3,r3,r2
 90b3af0:	008243b4 	movhi	r2,2318
 90b3af4:	10b75604 	addi	r2,r2,-8872
 90b3af8:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 90b3afc:	e0bfe517 	ldw	r2,-108(fp)
 90b3b00:	11000a04 	addi	r4,r2,40
 90b3b04:	e17ff017 	ldw	r5,-64(fp)
 90b3b08:	90b1aa80 	call	90b1aa8 <sbappend>
         sorwakeup(so);
 90b3b0c:	e0bfe517 	ldw	r2,-108(fp)
 90b3b10:	11400a04 	addi	r5,r2,40
 90b3b14:	e13fe517 	ldw	r4,-108(fp)
 90b3b18:	90b18e40 	call	90b18e4 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 90b3b1c:	e0bfe617 	ldw	r2,-104(fp)
 90b3b20:	1080020c 	andi	r2,r2,8
 90b3b24:	1005003a 	cmpeq	r2,r2,zero
 90b3b28:	1000071e 	bne	r2,zero,90b3b48 <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 90b3b2c:	e0bfe717 	ldw	r2,-100(fp)
 90b3b30:	10800b0b 	ldhu	r2,44(r2)
 90b3b34:	10800054 	ori	r2,r2,1
 90b3b38:	1007883a 	mov	r3,r2
 90b3b3c:	e0bfe717 	ldw	r2,-100(fp)
 90b3b40:	10c00b0d 	sth	r3,44(r2)
 90b3b44:	00000606 	br	90b3b60 <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 90b3b48:	e0bfe717 	ldw	r2,-100(fp)
 90b3b4c:	10800b0b 	ldhu	r2,44(r2)
 90b3b50:	10800094 	ori	r2,r2,2
 90b3b54:	1007883a 	mov	r3,r2
 90b3b58:	e0bfe717 	ldw	r2,-100(fp)
 90b3b5c:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 90b3b60:	e0bfe717 	ldw	r2,-100(fp)
 90b3b64:	11001517 	ldw	r4,84(r2)
 90b3b68:	e0bfe717 	ldw	r2,-100(fp)
 90b3b6c:	10c01917 	ldw	r3,100(r2)
 90b3b70:	e0bfe717 	ldw	r2,-100(fp)
 90b3b74:	10801617 	ldw	r2,88(r2)
 90b3b78:	1885c83a 	sub	r2,r3,r2
 90b3b7c:	2085c83a 	sub	r2,r4,r2
 90b3b80:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 90b3b84:	e0bfe717 	ldw	r2,-100(fp)
 90b3b88:	10800a0b 	ldhu	r2,40(r2)
 90b3b8c:	10bfffcc 	andi	r2,r2,65535
 90b3b90:	1085883a 	add	r2,r2,r2
 90b3b94:	1007883a 	mov	r3,r2
 90b3b98:	e0bfda17 	ldw	r2,-152(fp)
 90b3b9c:	10c0070e 	bge	r2,r3,90b3bbc <tcp_input+0xa7c>
 90b3ba0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ba4:	10800b0b 	ldhu	r2,44(r2)
 90b3ba8:	10bfffcc 	andi	r2,r2,65535
 90b3bac:	1080004c 	andi	r2,r2,1
 90b3bb0:	10803fcc 	andi	r2,r2,255
 90b3bb4:	1005003a 	cmpeq	r2,r2,zero
 90b3bb8:	1006b11e 	bne	r2,zero,90b5680 <tcp_input+0x2540>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 90b3bbc:	e0bfe717 	ldw	r2,-100(fp)
 90b3bc0:	10800b0b 	ldhu	r2,44(r2)
 90b3bc4:	10800054 	ori	r2,r2,1
 90b3bc8:	1007883a 	mov	r3,r2
 90b3bcc:	e0bfe717 	ldw	r2,-100(fp)
 90b3bd0:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 90b3bd4:	e0bfe717 	ldw	r2,-100(fp)
 90b3bd8:	10c00b0b 	ldhu	r3,44(r2)
 90b3bdc:	00bfff44 	movi	r2,-3
 90b3be0:	1884703a 	and	r2,r3,r2
 90b3be4:	1007883a 	mov	r3,r2
 90b3be8:	e0bfe717 	ldw	r2,-100(fp)
 90b3bec:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 90b3bf0:	e13fe717 	ldw	r4,-100(fp)
 90b3bf4:	90b5d540 	call	90b5d54 <tcp_output>
         }

         return;
 90b3bf8:	0006a106 	br	90b5680 <tcp_input+0x2540>
      }
   }

   switch (tp->t_state) 
 90b3bfc:	e0bfe717 	ldw	r2,-100(fp)
 90b3c00:	10800217 	ldw	r2,8(r2)
 90b3c04:	e0bff815 	stw	r2,-32(fp)
 90b3c08:	e13ff817 	ldw	r4,-32(fp)
 90b3c0c:	20800060 	cmpeqi	r2,r4,1
 90b3c10:	1000041e 	bne	r2,zero,90b3c24 <tcp_input+0xae4>
 90b3c14:	e0fff817 	ldw	r3,-32(fp)
 90b3c18:	188000a0 	cmpeqi	r2,r3,2
 90b3c1c:	1000b91e 	bne	r2,zero,90b3f04 <tcp_input+0xdc4>
 90b3c20:	00019806 	br	90b4284 <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 90b3c24:	e0bfe617 	ldw	r2,-104(fp)
 90b3c28:	1080010c 	andi	r2,r2,4
 90b3c2c:	1005003a 	cmpeq	r2,r2,zero
 90b3c30:	1000031e 	bne	r2,zero,90b3c40 <tcp_input+0xb00>
            GOTO_DROP;
 90b3c34:	0080bec4 	movi	r2,763
 90b3c38:	d0a0b315 	stw	r2,-32052(gp)
 90b3c3c:	00068406 	br	90b5650 <tcp_input+0x2510>
         if (tiflags & TH_ACK)
 90b3c40:	e0bfe617 	ldw	r2,-104(fp)
 90b3c44:	1080040c 	andi	r2,r2,16
 90b3c48:	1005003a 	cmpeq	r2,r2,zero
 90b3c4c:	1000031e 	bne	r2,zero,90b3c5c <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 90b3c50:	0080bf44 	movi	r2,765
 90b3c54:	d0a0b315 	stw	r2,-32052(gp)
 90b3c58:	00063906 	br	90b5540 <tcp_input+0x2400>
         if ((tiflags & TH_SYN) == 0)
 90b3c5c:	e0bfe617 	ldw	r2,-104(fp)
 90b3c60:	1080008c 	andi	r2,r2,2
 90b3c64:	1004c03a 	cmpne	r2,r2,zero
 90b3c68:	1000031e 	bne	r2,zero,90b3c78 <tcp_input+0xb38>
            GOTO_DROP;
 90b3c6c:	0080bfc4 	movi	r2,767
 90b3c70:	d0a0b315 	stw	r2,-32052(gp)
 90b3c74:	00067606 	br	90b5650 <tcp_input+0x2510>
         if(in_broadcast(ti->ti_dst.s_addr))
 90b3c78:	e0bfed17 	ldw	r2,-76(fp)
 90b3c7c:	11000417 	ldw	r4,16(r2)
 90b3c80:	90ac5c00 	call	90ac5c0 <in_broadcast>
 90b3c84:	1005003a 	cmpeq	r2,r2,zero
 90b3c88:	1000031e 	bne	r2,zero,90b3c98 <tcp_input+0xb58>
            GOTO_DROP;
 90b3c8c:	0080c044 	movi	r2,769
 90b3c90:	d0a0b315 	stw	r2,-32052(gp)
 90b3c94:	00066e06 	br	90b5650 <tcp_input+0x2510>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 90b3c98:	01000244 	movi	r4,9
 90b3c9c:	01400404 	movi	r5,16
 90b3ca0:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b3ca4:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 90b3ca8:	e0bfd917 	ldw	r2,-156(fp)
 90b3cac:	1004c03a 	cmpne	r2,r2,zero
 90b3cb0:	1000031e 	bne	r2,zero,90b3cc0 <tcp_input+0xb80>
            GOTO_DROP;
 90b3cb4:	0080c104 	movi	r2,772
 90b3cb8:	d0a0b315 	stw	r2,-32052(gp)
 90b3cbc:	00066406 	br	90b5650 <tcp_input+0x2510>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 90b3cc0:	e0bfec17 	ldw	r2,-80(fp)
 90b3cc4:	10800817 	ldw	r2,32(r2)
 90b3cc8:	10800517 	ldw	r2,20(r2)
 90b3ccc:	10800098 	cmpnei	r2,r2,2
 90b3cd0:	10002e1e 	bne	r2,zero,90b3d8c <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 90b3cd4:	e0ffd917 	ldw	r3,-156(fp)
 90b3cd8:	00800404 	movi	r2,16
 90b3cdc:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 90b3ce0:	e0bfd917 	ldw	r2,-156(fp)
 90b3ce4:	10800317 	ldw	r2,12(r2)
 90b3ce8:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 90b3cec:	e0ffd817 	ldw	r3,-160(fp)
 90b3cf0:	00800084 	movi	r2,2
 90b3cf4:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 90b3cf8:	e0bfed17 	ldw	r2,-76(fp)
 90b3cfc:	10c00317 	ldw	r3,12(r2)
 90b3d00:	e0bfd817 	ldw	r2,-160(fp)
 90b3d04:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 90b3d08:	e0bfed17 	ldw	r2,-76(fp)
 90b3d0c:	10c0050b 	ldhu	r3,20(r2)
 90b3d10:	e0bfd817 	ldw	r2,-160(fp)
 90b3d14:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 90b3d18:	e0bfec17 	ldw	r2,-80(fp)
 90b3d1c:	10800417 	ldw	r2,16(r2)
 90b3d20:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 90b3d24:	e0bfec17 	ldw	r2,-80(fp)
 90b3d28:	10800417 	ldw	r2,16(r2)
 90b3d2c:	1004c03a 	cmpne	r2,r2,zero
 90b3d30:	1000041e 	bne	r2,zero,90b3d44 <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 90b3d34:	e0bfed17 	ldw	r2,-76(fp)
 90b3d38:	10c00417 	ldw	r3,16(r2)
 90b3d3c:	e0bfec17 	ldw	r2,-80(fp)
 90b3d40:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 90b3d44:	e13fec17 	ldw	r4,-80(fp)
 90b3d48:	e17fd917 	ldw	r5,-156(fp)
 90b3d4c:	90c7b640 	call	90c7b64 <in_pcbconnect>
 90b3d50:	1005003a 	cmpeq	r2,r2,zero
 90b3d54:	1000081e 	bne	r2,zero,90b3d78 <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 90b3d58:	e0bfec17 	ldw	r2,-80(fp)
 90b3d5c:	e0ffef17 	ldw	r3,-68(fp)
 90b3d60:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 90b3d64:	e13fd917 	ldw	r4,-156(fp)
 90b3d68:	90ab4600 	call	90ab460 <m_free>
            GOTO_DROP;
 90b3d6c:	0080c684 	movi	r2,794
 90b3d70:	d0a0b315 	stw	r2,-32052(gp)
 90b3d74:	00063606 	br	90b5650 <tcp_input+0x2510>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 90b3d78:	e0ffec17 	ldw	r3,-80(fp)
 90b3d7c:	e0bff117 	ldw	r2,-60(fp)
 90b3d80:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 90b3d84:	e13fd917 	ldw	r4,-156(fp)
 90b3d88:	90ab4600 	call	90ab460 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 90b3d8c:	e13fe717 	ldw	r4,-100(fp)
 90b3d90:	90b710c0 	call	90b710c <tcp_template>
 90b3d94:	1007883a 	mov	r3,r2
 90b3d98:	e0bfe717 	ldw	r2,-100(fp)
 90b3d9c:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 90b3da0:	e0bfe717 	ldw	r2,-100(fp)
 90b3da4:	10800c17 	ldw	r2,48(r2)
 90b3da8:	1004c03a 	cmpne	r2,r2,zero
 90b3dac:	1000071e 	bne	r2,zero,90b3dcc <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 90b3db0:	e13fe717 	ldw	r4,-100(fp)
 90b3db4:	01401a44 	movi	r5,105
 90b3db8:	90b77c40 	call	90b77c4 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 90b3dbc:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 90b3dc0:	0080d1c4 	movi	r2,839
 90b3dc4:	d0a0b315 	stw	r2,-32052(gp)
 90b3dc8:	00062106 	br	90b5650 <tcp_input+0x2510>
         }
         if (om) 
 90b3dcc:	e0bfeb17 	ldw	r2,-84(fp)
 90b3dd0:	1005003a 	cmpeq	r2,r2,zero
 90b3dd4:	1000051e 	bne	r2,zero,90b3dec <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 90b3dd8:	e13fe717 	ldw	r4,-100(fp)
 90b3ddc:	e17feb17 	ldw	r5,-84(fp)
 90b3de0:	e1bfed17 	ldw	r6,-76(fp)
 90b3de4:	90b56940 	call	90b5694 <tcp_dooptions>
            om = 0;
 90b3de8:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 90b3dec:	e0bfdf17 	ldw	r2,-132(fp)
 90b3df0:	1005003a 	cmpeq	r2,r2,zero
 90b3df4:	1000041e 	bne	r2,zero,90b3e08 <tcp_input+0xcc8>
            tp->iss = iss;
 90b3df8:	e0ffdf17 	ldw	r3,-132(fp)
 90b3dfc:	e0bfe717 	ldw	r2,-100(fp)
 90b3e00:	10c01315 	stw	r3,76(r2)
 90b3e04:	00000506 	br	90b3e1c <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 90b3e08:	00824374 	movhi	r2,2317
 90b3e0c:	108f3b04 	addi	r2,r2,15596
 90b3e10:	10c00017 	ldw	r3,0(r2)
 90b3e14:	e0bfe717 	ldw	r2,-100(fp)
 90b3e18:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 90b3e1c:	00824374 	movhi	r2,2317
 90b3e20:	108f3b04 	addi	r2,r2,15596
 90b3e24:	10c00017 	ldw	r3,0(r2)
 90b3e28:	00be9fd4 	movui	r2,64127
 90b3e2c:	1887883a 	add	r3,r3,r2
 90b3e30:	00824374 	movhi	r2,2317
 90b3e34:	108f3b04 	addi	r2,r2,15596
 90b3e38:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 90b3e3c:	e0bfed17 	ldw	r2,-76(fp)
 90b3e40:	10c00617 	ldw	r3,24(r2)
 90b3e44:	e0bfe717 	ldw	r2,-100(fp)
 90b3e48:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 90b3e4c:	e0bfe717 	ldw	r2,-100(fp)
 90b3e50:	10c01317 	ldw	r3,76(r2)
 90b3e54:	e0bfe717 	ldw	r2,-100(fp)
 90b3e58:	10c01015 	stw	r3,64(r2)
 90b3e5c:	e0bfe717 	ldw	r2,-100(fp)
 90b3e60:	10c01017 	ldw	r3,64(r2)
 90b3e64:	e0bfe717 	ldw	r2,-100(fp)
 90b3e68:	10c01a15 	stw	r3,104(r2)
 90b3e6c:	e0bfe717 	ldw	r2,-100(fp)
 90b3e70:	10c01a17 	ldw	r3,104(r2)
 90b3e74:	e0bfe717 	ldw	r2,-100(fp)
 90b3e78:	10c00f15 	stw	r3,60(r2)
 90b3e7c:	e0bfe717 	ldw	r2,-100(fp)
 90b3e80:	10c00f17 	ldw	r3,60(r2)
 90b3e84:	e0bfe717 	ldw	r2,-100(fp)
 90b3e88:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 90b3e8c:	e0bfe717 	ldw	r2,-100(fp)
 90b3e90:	10801817 	ldw	r2,96(r2)
 90b3e94:	10c00044 	addi	r3,r2,1
 90b3e98:	e0bfe717 	ldw	r2,-100(fp)
 90b3e9c:	10c01615 	stw	r3,88(r2)
 90b3ea0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ea4:	10c01617 	ldw	r3,88(r2)
 90b3ea8:	e0bfe717 	ldw	r2,-100(fp)
 90b3eac:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 90b3eb0:	e0bfe717 	ldw	r2,-100(fp)
 90b3eb4:	10800b0b 	ldhu	r2,44(r2)
 90b3eb8:	10800054 	ori	r2,r2,1
 90b3ebc:	1007883a 	mov	r3,r2
 90b3ec0:	e0bfe717 	ldw	r2,-100(fp)
 90b3ec4:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 90b3ec8:	e0ffe717 	ldw	r3,-100(fp)
 90b3ecc:	008000c4 	movi	r2,3
 90b3ed0:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 90b3ed4:	e0ffe717 	ldw	r3,-100(fp)
 90b3ed8:	00802584 	movi	r2,150
 90b3edc:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 90b3ee0:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 90b3ee4:	008243b4 	movhi	r2,2318
 90b3ee8:	10b75604 	addi	r2,r2,-8872
 90b3eec:	10800117 	ldw	r2,4(r2)
 90b3ef0:	10c00044 	addi	r3,r2,1
 90b3ef4:	008243b4 	movhi	r2,2318
 90b3ef8:	10b75604 	addi	r2,r2,-8872
 90b3efc:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 90b3f00:	00009d06 	br	90b4178 <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 90b3f04:	e0ffec17 	ldw	r3,-80(fp)
 90b3f08:	e0bff117 	ldw	r2,-60(fp)
 90b3f0c:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 90b3f10:	e0bfe617 	ldw	r2,-104(fp)
 90b3f14:	1080040c 	andi	r2,r2,16
 90b3f18:	1005003a 	cmpeq	r2,r2,zero
 90b3f1c:	1000111e 	bne	r2,zero,90b3f64 <tcp_input+0xe24>
 90b3f20:	e0bfed17 	ldw	r2,-76(fp)
 90b3f24:	10c00717 	ldw	r3,28(r2)
 90b3f28:	e0bfe717 	ldw	r2,-100(fp)
 90b3f2c:	10801317 	ldw	r2,76(r2)
 90b3f30:	1885c83a 	sub	r2,r3,r2
 90b3f34:	10800050 	cmplti	r2,r2,1
 90b3f38:	1000071e 	bne	r2,zero,90b3f58 <tcp_input+0xe18>
 90b3f3c:	e0bfed17 	ldw	r2,-76(fp)
 90b3f40:	10c00717 	ldw	r3,28(r2)
 90b3f44:	e0bfe717 	ldw	r2,-100(fp)
 90b3f48:	10801a17 	ldw	r2,104(r2)
 90b3f4c:	1885c83a 	sub	r2,r3,r2
 90b3f50:	10800050 	cmplti	r2,r2,1
 90b3f54:	1000031e 	bne	r2,zero,90b3f64 <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 90b3f58:	0080dc04 	movi	r2,880
 90b3f5c:	d0a0b315 	stw	r2,-32052(gp)
 90b3f60:	00057706 	br	90b5540 <tcp_input+0x2400>
      }
      if (tiflags & TH_RST) 
 90b3f64:	e0bfe617 	ldw	r2,-104(fp)
 90b3f68:	1080010c 	andi	r2,r2,4
 90b3f6c:	1005003a 	cmpeq	r2,r2,zero
 90b3f70:	10000a1e 	bne	r2,zero,90b3f9c <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 90b3f74:	e0bfe617 	ldw	r2,-104(fp)
 90b3f78:	1080040c 	andi	r2,r2,16
 90b3f7c:	1005003a 	cmpeq	r2,r2,zero
 90b3f80:	1000031e 	bne	r2,zero,90b3f90 <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 90b3f84:	e13fe717 	ldw	r4,-100(fp)
 90b3f88:	01401bc4 	movi	r5,111
 90b3f8c:	90b77c40 	call	90b77c4 <tcp_drop>
         GOTO_DROP;
 90b3f90:	0080dd84 	movi	r2,886
 90b3f94:	d0a0b315 	stw	r2,-32052(gp)
 90b3f98:	0005ad06 	br	90b5650 <tcp_input+0x2510>
      }
      if ((tiflags & TH_SYN) == 0)
 90b3f9c:	e0bfe617 	ldw	r2,-104(fp)
 90b3fa0:	1080008c 	andi	r2,r2,2
 90b3fa4:	1004c03a 	cmpne	r2,r2,zero
 90b3fa8:	1000031e 	bne	r2,zero,90b3fb8 <tcp_input+0xe78>
         GOTO_DROP;
 90b3fac:	0080de44 	movi	r2,889
 90b3fb0:	d0a0b315 	stw	r2,-32052(gp)
 90b3fb4:	0005a606 	br	90b5650 <tcp_input+0x2510>
      if (tiflags & TH_ACK) 
 90b3fb8:	e0bfe617 	ldw	r2,-104(fp)
 90b3fbc:	1080040c 	andi	r2,r2,16
 90b3fc0:	1005003a 	cmpeq	r2,r2,zero
 90b3fc4:	10000f1e 	bne	r2,zero,90b4004 <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 90b3fc8:	e0bfed17 	ldw	r2,-76(fp)
 90b3fcc:	10c00717 	ldw	r3,28(r2)
 90b3fd0:	e0bfe717 	ldw	r2,-100(fp)
 90b3fd4:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 90b3fd8:	e0bfe717 	ldw	r2,-100(fp)
 90b3fdc:	10c00f17 	ldw	r3,60(r2)
 90b3fe0:	e0bfe717 	ldw	r2,-100(fp)
 90b3fe4:	10800e17 	ldw	r2,56(r2)
 90b3fe8:	1885c83a 	sub	r2,r3,r2
 90b3fec:	1004403a 	cmpge	r2,r2,zero
 90b3ff0:	1000041e 	bne	r2,zero,90b4004 <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 90b3ff4:	e0bfe717 	ldw	r2,-100(fp)
 90b3ff8:	10c00e17 	ldw	r3,56(r2)
 90b3ffc:	e0bfe717 	ldw	r2,-100(fp)
 90b4000:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 90b4004:	e0bfe717 	ldw	r2,-100(fp)
 90b4008:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 90b400c:	e0bfed17 	ldw	r2,-76(fp)
 90b4010:	10c00617 	ldw	r3,24(r2)
 90b4014:	e0bfe717 	ldw	r2,-100(fp)
 90b4018:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 90b401c:	e0bfe717 	ldw	r2,-100(fp)
 90b4020:	10801817 	ldw	r2,96(r2)
 90b4024:	10c00044 	addi	r3,r2,1
 90b4028:	e0bfe717 	ldw	r2,-100(fp)
 90b402c:	10c01615 	stw	r3,88(r2)
 90b4030:	e0bfe717 	ldw	r2,-100(fp)
 90b4034:	10c01617 	ldw	r3,88(r2)
 90b4038:	e0bfe717 	ldw	r2,-100(fp)
 90b403c:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 90b4040:	e0bfec17 	ldw	r2,-80(fp)
 90b4044:	10c00417 	ldw	r3,16(r2)
 90b4048:	e0bfed17 	ldw	r2,-76(fp)
 90b404c:	10800417 	ldw	r2,16(r2)
 90b4050:	18801926 	beq	r3,r2,90b40b8 <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 90b4054:	e0bff017 	ldw	r2,-64(fp)
 90b4058:	10800117 	ldw	r2,4(r2)
 90b405c:	10800617 	ldw	r2,24(r2)
 90b4060:	1005003a 	cmpeq	r2,r2,zero
 90b4064:	1000141e 	bne	r2,zero,90b40b8 <tcp_input+0xf78>
 90b4068:	e0bff017 	ldw	r2,-64(fp)
 90b406c:	10800117 	ldw	r2,4(r2)
 90b4070:	10800617 	ldw	r2,24(r2)
 90b4074:	10c00a17 	ldw	r3,40(r2)
 90b4078:	e0bfed17 	ldw	r2,-76(fp)
 90b407c:	10800417 	ldw	r2,16(r2)
 90b4080:	18800d1e 	bne	r3,r2,90b40b8 <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 90b4084:	e0bfed17 	ldw	r2,-76(fp)
 90b4088:	10c00417 	ldw	r3,16(r2)
 90b408c:	e0bfec17 	ldw	r2,-80(fp)
 90b4090:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 90b4094:	e0bfe717 	ldw	r2,-100(fp)
 90b4098:	10800c17 	ldw	r2,48(r2)
 90b409c:	1005003a 	cmpeq	r2,r2,zero
 90b40a0:	1000051e 	bne	r2,zero,90b40b8 <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 90b40a4:	e0bfe717 	ldw	r2,-100(fp)
 90b40a8:	10c00c17 	ldw	r3,48(r2)
 90b40ac:	e0bfed17 	ldw	r2,-76(fp)
 90b40b0:	10800417 	ldw	r2,16(r2)
 90b40b4:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 90b40b8:	e0bfe717 	ldw	r2,-100(fp)
 90b40bc:	10800b0b 	ldhu	r2,44(r2)
 90b40c0:	10800054 	ori	r2,r2,1
 90b40c4:	1007883a 	mov	r3,r2
 90b40c8:	e0bfe717 	ldw	r2,-100(fp)
 90b40cc:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 90b40d0:	e0bfe617 	ldw	r2,-104(fp)
 90b40d4:	1080040c 	andi	r2,r2,16
 90b40d8:	1005003a 	cmpeq	r2,r2,zero
 90b40dc:	1000231e 	bne	r2,zero,90b416c <tcp_input+0x102c>
 90b40e0:	e0bfe717 	ldw	r2,-100(fp)
 90b40e4:	10c00e17 	ldw	r3,56(r2)
 90b40e8:	e0bfe717 	ldw	r2,-100(fp)
 90b40ec:	10801317 	ldw	r2,76(r2)
 90b40f0:	1885c83a 	sub	r2,r3,r2
 90b40f4:	10800050 	cmplti	r2,r2,1
 90b40f8:	10001c1e 	bne	r2,zero,90b416c <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 90b40fc:	008243b4 	movhi	r2,2318
 90b4100:	10b75604 	addi	r2,r2,-8872
 90b4104:	10800217 	ldw	r2,8(r2)
 90b4108:	10c00044 	addi	r3,r2,1
 90b410c:	008243b4 	movhi	r2,2318
 90b4110:	10b75604 	addi	r2,r2,-8872
 90b4114:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 90b4118:	e0ffe717 	ldw	r3,-100(fp)
 90b411c:	00800104 	movi	r2,4
 90b4120:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 90b4124:	e13fe517 	ldw	r4,-108(fp)
 90b4128:	90b11780 	call	90b1178 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 90b412c:	e13fe517 	ldw	r4,-108(fp)
 90b4130:	90b5c380 	call	90b5c38 <tcp_mss>
 90b4134:	1007883a 	mov	r3,r2
 90b4138:	e0bfe717 	ldw	r2,-100(fp)
 90b413c:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 90b4140:	e13fe717 	ldw	r4,-100(fp)
 90b4144:	000b883a 	mov	r5,zero
 90b4148:	e1bff017 	ldw	r6,-64(fp)
 90b414c:	90b2d380 	call	90b2d38 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 90b4150:	e0bfe717 	ldw	r2,-100(fp)
 90b4154:	10801e17 	ldw	r2,120(r2)
 90b4158:	1005003a 	cmpeq	r2,r2,zero
 90b415c:	1000061e 	bne	r2,zero,90b4178 <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 90b4160:	e13fe717 	ldw	r4,-100(fp)
 90b4164:	90b59500 	call	90b5950 <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 90b4168:	00000306 	br	90b4178 <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 90b416c:	e0ffe717 	ldw	r3,-100(fp)
 90b4170:	008000c4 	movi	r2,3
 90b4174:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 90b4178:	e0bfed17 	ldw	r2,-76(fp)
 90b417c:	10800617 	ldw	r2,24(r2)
 90b4180:	10c00044 	addi	r3,r2,1
 90b4184:	e0bfed17 	ldw	r2,-76(fp)
 90b4188:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 90b418c:	e0bfed17 	ldw	r2,-76(fp)
 90b4190:	1080028b 	ldhu	r2,10(r2)
 90b4194:	10ffffcc 	andi	r3,r2,65535
 90b4198:	e0bfe717 	ldw	r2,-100(fp)
 90b419c:	10801517 	ldw	r2,84(r2)
 90b41a0:	10c02e2e 	bgeu	r2,r3,90b425c <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 90b41a4:	e0bfed17 	ldw	r2,-76(fp)
 90b41a8:	1080028b 	ldhu	r2,10(r2)
 90b41ac:	10ffffcc 	andi	r3,r2,65535
 90b41b0:	e0bfe717 	ldw	r2,-100(fp)
 90b41b4:	10801517 	ldw	r2,84(r2)
 90b41b8:	10bfffcc 	andi	r2,r2,65535
 90b41bc:	1885c83a 	sub	r2,r3,r2
 90b41c0:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 90b41c4:	e0bff017 	ldw	r2,-64(fp)
 90b41c8:	10800217 	ldw	r2,8(r2)
 90b41cc:	1005003a 	cmpeq	r2,r2,zero
 90b41d0:	1000051e 	bne	r2,zero,90b41e8 <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 90b41d4:	e0bfe417 	ldw	r2,-112(fp)
 90b41d8:	008bc83a 	sub	r5,zero,r2
 90b41dc:	e13ff017 	ldw	r4,-64(fp)
 90b41e0:	90ab8fc0 	call	90ab8fc <m_adj>
 90b41e4:	00000506 	br	90b41fc <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 90b41e8:	e0bff017 	ldw	r2,-64(fp)
 90b41ec:	11000617 	ldw	r4,24(r2)
 90b41f0:	e0bfe417 	ldw	r2,-112(fp)
 90b41f4:	008bc83a 	sub	r5,zero,r2
 90b41f8:	90ab8fc0 	call	90ab8fc <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 90b41fc:	e0bfe717 	ldw	r2,-100(fp)
 90b4200:	10801517 	ldw	r2,84(r2)
 90b4204:	1007883a 	mov	r3,r2
 90b4208:	e0bfed17 	ldw	r2,-76(fp)
 90b420c:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 90b4210:	e0ffe617 	ldw	r3,-104(fp)
 90b4214:	00bfff84 	movi	r2,-2
 90b4218:	1884703a 	and	r2,r3,r2
 90b421c:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 90b4220:	008243b4 	movhi	r2,2318
 90b4224:	10b75604 	addi	r2,r2,-8872
 90b4228:	10802517 	ldw	r2,148(r2)
 90b422c:	10c00044 	addi	r3,r2,1
 90b4230:	008243b4 	movhi	r2,2318
 90b4234:	10b75604 	addi	r2,r2,-8872
 90b4238:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 90b423c:	008243b4 	movhi	r2,2318
 90b4240:	10b75604 	addi	r2,r2,-8872
 90b4244:	10c02617 	ldw	r3,152(r2)
 90b4248:	e0bfe417 	ldw	r2,-112(fp)
 90b424c:	1887883a 	add	r3,r3,r2
 90b4250:	008243b4 	movhi	r2,2318
 90b4254:	10b75604 	addi	r2,r2,-8872
 90b4258:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 90b425c:	e0bfed17 	ldw	r2,-76(fp)
 90b4260:	10800617 	ldw	r2,24(r2)
 90b4264:	10ffffc4 	addi	r3,r2,-1
 90b4268:	e0bfe717 	ldw	r2,-100(fp)
 90b426c:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 90b4270:	e0bfed17 	ldw	r2,-76(fp)
 90b4274:	10c00617 	ldw	r3,24(r2)
 90b4278:	e0bfe717 	ldw	r2,-100(fp)
 90b427c:	10c01715 	stw	r3,92(r2)
      goto step6;
 90b4280:	00032406 	br	90b4f14 <tcp_input+0x1dd4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 90b4284:	e0bfe717 	ldw	r2,-100(fp)
 90b4288:	10c01617 	ldw	r3,88(r2)
 90b428c:	e0bfed17 	ldw	r2,-76(fp)
 90b4290:	10800617 	ldw	r2,24(r2)
 90b4294:	1885c83a 	sub	r2,r3,r2
 90b4298:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 90b429c:	e0bfe417 	ldw	r2,-112(fp)
 90b42a0:	10800050 	cmplti	r2,r2,1
 90b42a4:	1000971e 	bne	r2,zero,90b4504 <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 90b42a8:	e0bfe617 	ldw	r2,-104(fp)
 90b42ac:	1080008c 	andi	r2,r2,2
 90b42b0:	1005003a 	cmpeq	r2,r2,zero
 90b42b4:	10001c1e 	bne	r2,zero,90b4328 <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 90b42b8:	e0ffe617 	ldw	r3,-104(fp)
 90b42bc:	00bfff44 	movi	r2,-3
 90b42c0:	1884703a 	and	r2,r3,r2
 90b42c4:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 90b42c8:	e0bfed17 	ldw	r2,-76(fp)
 90b42cc:	10800617 	ldw	r2,24(r2)
 90b42d0:	10c00044 	addi	r3,r2,1
 90b42d4:	e0bfed17 	ldw	r2,-76(fp)
 90b42d8:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 90b42dc:	e0bfed17 	ldw	r2,-76(fp)
 90b42e0:	1080098b 	ldhu	r2,38(r2)
 90b42e4:	10bfffcc 	andi	r2,r2,65535
 90b42e8:	108000b0 	cmpltui	r2,r2,2
 90b42ec:	1000071e 	bne	r2,zero,90b430c <tcp_input+0x11cc>
            ti->ti_urp--;
 90b42f0:	e0bfed17 	ldw	r2,-76(fp)
 90b42f4:	1080098b 	ldhu	r2,38(r2)
 90b42f8:	10bfffc4 	addi	r2,r2,-1
 90b42fc:	1007883a 	mov	r3,r2
 90b4300:	e0bfed17 	ldw	r2,-76(fp)
 90b4304:	10c0098d 	sth	r3,38(r2)
 90b4308:	00000406 	br	90b431c <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 90b430c:	e0bfe617 	ldw	r2,-104(fp)
 90b4310:	00fff7c4 	movi	r3,-33
 90b4314:	10c4703a 	and	r2,r2,r3
 90b4318:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 90b431c:	e0bfe417 	ldw	r2,-112(fp)
 90b4320:	10bfffc4 	addi	r2,r2,-1
 90b4324:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 90b4328:	e0bfed17 	ldw	r2,-76(fp)
 90b432c:	1080028b 	ldhu	r2,10(r2)
 90b4330:	10ffffcc 	andi	r3,r2,65535
 90b4334:	e0bfe417 	ldw	r2,-112(fp)
 90b4338:	18800916 	blt	r3,r2,90b4360 <tcp_input+0x1220>
 90b433c:	e0bfed17 	ldw	r2,-76(fp)
 90b4340:	1080028b 	ldhu	r2,10(r2)
 90b4344:	10ffffcc 	andi	r3,r2,65535
 90b4348:	e0bfe417 	ldw	r2,-112(fp)
 90b434c:	18803a1e 	bne	r3,r2,90b4438 <tcp_input+0x12f8>
 90b4350:	e0bfe617 	ldw	r2,-104(fp)
 90b4354:	1080004c 	andi	r2,r2,1
 90b4358:	1004c03a 	cmpne	r2,r2,zero
 90b435c:	1000361e 	bne	r2,zero,90b4438 <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 90b4360:	008243b4 	movhi	r2,2318
 90b4364:	10b75604 	addi	r2,r2,-8872
 90b4368:	10801f17 	ldw	r2,124(r2)
 90b436c:	10c00044 	addi	r3,r2,1
 90b4370:	008243b4 	movhi	r2,2318
 90b4374:	10b75604 	addi	r2,r2,-8872
 90b4378:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 90b437c:	008243b4 	movhi	r2,2318
 90b4380:	10b75604 	addi	r2,r2,-8872
 90b4384:	10c02017 	ldw	r3,128(r2)
 90b4388:	e0bfed17 	ldw	r2,-76(fp)
 90b438c:	1080028b 	ldhu	r2,10(r2)
 90b4390:	10bfffcc 	andi	r2,r2,65535
 90b4394:	1887883a 	add	r3,r3,r2
 90b4398:	008243b4 	movhi	r2,2318
 90b439c:	10b75604 	addi	r2,r2,-8872
 90b43a0:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 90b43a4:	e0bfe617 	ldw	r2,-104(fp)
 90b43a8:	1080004c 	andi	r2,r2,1
 90b43ac:	1080005c 	xori	r2,r2,1
 90b43b0:	10803fcc 	andi	r2,r2,255
 90b43b4:	1004c03a 	cmpne	r2,r2,zero
 90b43b8:	1000061e 	bne	r2,zero,90b43d4 <tcp_input+0x1294>
 90b43bc:	e0bfed17 	ldw	r2,-76(fp)
 90b43c0:	1080028b 	ldhu	r2,10(r2)
 90b43c4:	10bfffcc 	andi	r2,r2,65535
 90b43c8:	10c00044 	addi	r3,r2,1
 90b43cc:	e0bfe417 	ldw	r2,-112(fp)
 90b43d0:	18800a26 	beq	r3,r2,90b43fc <tcp_input+0x12bc>
 90b43d4:	e0bfe617 	ldw	r2,-104(fp)
 90b43d8:	1080010c 	andi	r2,r2,4
 90b43dc:	1005003a 	cmpeq	r2,r2,zero
 90b43e0:	1004451e 	bne	r2,zero,90b54f8 <tcp_input+0x23b8>
 90b43e4:	e0bfed17 	ldw	r2,-76(fp)
 90b43e8:	10c00617 	ldw	r3,24(r2)
 90b43ec:	e0bfe717 	ldw	r2,-100(fp)
 90b43f0:	10801617 	ldw	r2,88(r2)
 90b43f4:	10bfffc4 	addi	r2,r2,-1
 90b43f8:	18843f1e 	bne	r3,r2,90b54f8 <tcp_input+0x23b8>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 90b43fc:	e0bfed17 	ldw	r2,-76(fp)
 90b4400:	1080028b 	ldhu	r2,10(r2)
 90b4404:	10bfffcc 	andi	r2,r2,65535
 90b4408:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 90b440c:	e0ffe617 	ldw	r3,-104(fp)
 90b4410:	00bfff84 	movi	r2,-2
 90b4414:	1884703a 	and	r2,r3,r2
 90b4418:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 90b441c:	e0bfe717 	ldw	r2,-100(fp)
 90b4420:	10800b0b 	ldhu	r2,44(r2)
 90b4424:	10800054 	ori	r2,r2,1
 90b4428:	1007883a 	mov	r3,r2
 90b442c:	e0bfe717 	ldw	r2,-100(fp)
 90b4430:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 90b4434:	00000f06 	br	90b4474 <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 90b4438:	008243b4 	movhi	r2,2318
 90b443c:	10b75604 	addi	r2,r2,-8872
 90b4440:	10802117 	ldw	r2,132(r2)
 90b4444:	10c00044 	addi	r3,r2,1
 90b4448:	008243b4 	movhi	r2,2318
 90b444c:	10b75604 	addi	r2,r2,-8872
 90b4450:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 90b4454:	008243b4 	movhi	r2,2318
 90b4458:	10b75604 	addi	r2,r2,-8872
 90b445c:	10c02217 	ldw	r3,136(r2)
 90b4460:	e0bfe417 	ldw	r2,-112(fp)
 90b4464:	1887883a 	add	r3,r3,r2
 90b4468:	008243b4 	movhi	r2,2318
 90b446c:	10b75604 	addi	r2,r2,-8872
 90b4470:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 90b4474:	e13ff017 	ldw	r4,-64(fp)
 90b4478:	e17fe417 	ldw	r5,-112(fp)
 90b447c:	90ab8fc0 	call	90ab8fc <m_adj>
      ti->ti_seq += todrop;
 90b4480:	e0bfed17 	ldw	r2,-76(fp)
 90b4484:	10c00617 	ldw	r3,24(r2)
 90b4488:	e0bfe417 	ldw	r2,-112(fp)
 90b448c:	1887883a 	add	r3,r3,r2
 90b4490:	e0bfed17 	ldw	r2,-76(fp)
 90b4494:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 90b4498:	e0bfed17 	ldw	r2,-76(fp)
 90b449c:	10c0028b 	ldhu	r3,10(r2)
 90b44a0:	e0bfe417 	ldw	r2,-112(fp)
 90b44a4:	1885c83a 	sub	r2,r3,r2
 90b44a8:	1007883a 	mov	r3,r2
 90b44ac:	e0bfed17 	ldw	r2,-76(fp)
 90b44b0:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 90b44b4:	e0bfed17 	ldw	r2,-76(fp)
 90b44b8:	10c0098b 	ldhu	r3,38(r2)
 90b44bc:	e0bfe417 	ldw	r2,-112(fp)
 90b44c0:	18ffffcc 	andi	r3,r3,65535
 90b44c4:	10bfffcc 	andi	r2,r2,65535
 90b44c8:	10c0082e 	bgeu	r2,r3,90b44ec <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 90b44cc:	e0bfed17 	ldw	r2,-76(fp)
 90b44d0:	10c0098b 	ldhu	r3,38(r2)
 90b44d4:	e0bfe417 	ldw	r2,-112(fp)
 90b44d8:	1885c83a 	sub	r2,r3,r2
 90b44dc:	1007883a 	mov	r3,r2
 90b44e0:	e0bfed17 	ldw	r2,-76(fp)
 90b44e4:	10c0098d 	sth	r3,38(r2)
 90b44e8:	00000606 	br	90b4504 <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 90b44ec:	e0ffe617 	ldw	r3,-104(fp)
 90b44f0:	00bff7c4 	movi	r2,-33
 90b44f4:	1884703a 	and	r2,r3,r2
 90b44f8:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 90b44fc:	e0bfed17 	ldw	r2,-76(fp)
 90b4500:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 90b4504:	e0bfe517 	ldw	r2,-108(fp)
 90b4508:	1080088b 	ldhu	r2,34(r2)
 90b450c:	10bfffcc 	andi	r2,r2,65535
 90b4510:	1080004c 	andi	r2,r2,1
 90b4514:	10803fcc 	andi	r2,r2,255
 90b4518:	1005003a 	cmpeq	r2,r2,zero
 90b451c:	1000161e 	bne	r2,zero,90b4578 <tcp_input+0x1438>
 90b4520:	e0bfe717 	ldw	r2,-100(fp)
 90b4524:	10800217 	ldw	r2,8(r2)
 90b4528:	10800190 	cmplti	r2,r2,6
 90b452c:	1000121e 	bne	r2,zero,90b4578 <tcp_input+0x1438>
 90b4530:	e0bfed17 	ldw	r2,-76(fp)
 90b4534:	1080028b 	ldhu	r2,10(r2)
 90b4538:	10bfffcc 	andi	r2,r2,65535
 90b453c:	1005003a 	cmpeq	r2,r2,zero
 90b4540:	10000d1e 	bne	r2,zero,90b4578 <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 90b4544:	e13fe717 	ldw	r4,-100(fp)
 90b4548:	90b78700 	call	90b7870 <tcp_close>
 90b454c:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 90b4550:	008243b4 	movhi	r2,2318
 90b4554:	10b75604 	addi	r2,r2,-8872
 90b4558:	10802717 	ldw	r2,156(r2)
 90b455c:	10c00044 	addi	r3,r2,1
 90b4560:	008243b4 	movhi	r2,2318
 90b4564:	10b75604 	addi	r2,r2,-8872
 90b4568:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 90b456c:	00810444 	movi	r2,1041
 90b4570:	d0a0b315 	stw	r2,-32052(gp)
 90b4574:	0003f206 	br	90b5540 <tcp_input+0x2400>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 90b4578:	e0bfed17 	ldw	r2,-76(fp)
 90b457c:	10c00617 	ldw	r3,24(r2)
 90b4580:	e0bfed17 	ldw	r2,-76(fp)
 90b4584:	1080028b 	ldhu	r2,10(r2)
 90b4588:	10bfffcc 	andi	r2,r2,65535
 90b458c:	10a0001c 	xori	r2,r2,32768
 90b4590:	10a00004 	addi	r2,r2,-32768
 90b4594:	1889883a 	add	r4,r3,r2
 90b4598:	e0bfe717 	ldw	r2,-100(fp)
 90b459c:	10c01617 	ldw	r3,88(r2)
 90b45a0:	e0bfe717 	ldw	r2,-100(fp)
 90b45a4:	10801517 	ldw	r2,84(r2)
 90b45a8:	1885883a 	add	r2,r3,r2
 90b45ac:	2085c83a 	sub	r2,r4,r2
 90b45b0:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 90b45b4:	e0bfe417 	ldw	r2,-112(fp)
 90b45b8:	10800050 	cmplti	r2,r2,1
 90b45bc:	10006b1e 	bne	r2,zero,90b476c <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 90b45c0:	008243b4 	movhi	r2,2318
 90b45c4:	10b75604 	addi	r2,r2,-8872
 90b45c8:	10802517 	ldw	r2,148(r2)
 90b45cc:	10c00044 	addi	r3,r2,1
 90b45d0:	008243b4 	movhi	r2,2318
 90b45d4:	10b75604 	addi	r2,r2,-8872
 90b45d8:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 90b45dc:	e0bfed17 	ldw	r2,-76(fp)
 90b45e0:	1080028b 	ldhu	r2,10(r2)
 90b45e4:	10ffffcc 	andi	r3,r2,65535
 90b45e8:	e0bfe417 	ldw	r2,-112(fp)
 90b45ec:	10c03e16 	blt	r2,r3,90b46e8 <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 90b45f0:	008243b4 	movhi	r2,2318
 90b45f4:	10b75604 	addi	r2,r2,-8872
 90b45f8:	10c02617 	ldw	r3,152(r2)
 90b45fc:	e0bfed17 	ldw	r2,-76(fp)
 90b4600:	1080028b 	ldhu	r2,10(r2)
 90b4604:	10bfffcc 	andi	r2,r2,65535
 90b4608:	1887883a 	add	r3,r3,r2
 90b460c:	008243b4 	movhi	r2,2318
 90b4610:	10b75604 	addi	r2,r2,-8872
 90b4614:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 90b4618:	e0bfe617 	ldw	r2,-104(fp)
 90b461c:	1080008c 	andi	r2,r2,2
 90b4620:	1005003a 	cmpeq	r2,r2,zero
 90b4624:	1000191e 	bne	r2,zero,90b468c <tcp_input+0x154c>
 90b4628:	e0bfe717 	ldw	r2,-100(fp)
 90b462c:	10800217 	ldw	r2,8(r2)
 90b4630:	10800298 	cmpnei	r2,r2,10
 90b4634:	1000151e 	bne	r2,zero,90b468c <tcp_input+0x154c>
 90b4638:	e0bfed17 	ldw	r2,-76(fp)
 90b463c:	10c00617 	ldw	r3,24(r2)
 90b4640:	e0bfe717 	ldw	r2,-100(fp)
 90b4644:	10801617 	ldw	r2,88(r2)
 90b4648:	1885c83a 	sub	r2,r3,r2
 90b464c:	10800050 	cmplti	r2,r2,1
 90b4650:	10000e1e 	bne	r2,zero,90b468c <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 90b4654:	e0bfe717 	ldw	r2,-100(fp)
 90b4658:	10c01617 	ldw	r3,88(r2)
 90b465c:	008000b4 	movhi	r2,2
 90b4660:	10bd3fc4 	addi	r2,r2,-2817
 90b4664:	1885883a 	add	r2,r3,r2
 90b4668:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 90b466c:	e0bfdf17 	ldw	r2,-132(fp)
 90b4670:	10bfc02c 	andhi	r2,r2,65280
 90b4674:	1005003a 	cmpeq	r2,r2,zero
 90b4678:	1000011e 	bne	r2,zero,90b4680 <tcp_input+0x1540>
            {
               iss = 0L;
 90b467c:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 90b4680:	e13fe717 	ldw	r4,-100(fp)
 90b4684:	90b78700 	call	90b7870 <tcp_close>
            goto findpcb;
 90b4688:	003b8d06 	br	90b34c0 <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 90b468c:	e0bfe717 	ldw	r2,-100(fp)
 90b4690:	10801517 	ldw	r2,84(r2)
 90b4694:	1004c03a 	cmpne	r2,r2,zero
 90b4698:	1003971e 	bne	r2,zero,90b54f8 <tcp_input+0x23b8>
 90b469c:	e0bfed17 	ldw	r2,-76(fp)
 90b46a0:	10c00617 	ldw	r3,24(r2)
 90b46a4:	e0bfe717 	ldw	r2,-100(fp)
 90b46a8:	10801617 	ldw	r2,88(r2)
 90b46ac:	1883921e 	bne	r3,r2,90b54f8 <tcp_input+0x23b8>
         {
            tp->t_flags |= TF_ACKNOW;
 90b46b0:	e0bfe717 	ldw	r2,-100(fp)
 90b46b4:	10800b0b 	ldhu	r2,44(r2)
 90b46b8:	10800054 	ori	r2,r2,1
 90b46bc:	1007883a 	mov	r3,r2
 90b46c0:	e0bfe717 	ldw	r2,-100(fp)
 90b46c4:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 90b46c8:	008243b4 	movhi	r2,2318
 90b46cc:	10b75604 	addi	r2,r2,-8872
 90b46d0:	10802817 	ldw	r2,160(r2)
 90b46d4:	10c00044 	addi	r3,r2,1
 90b46d8:	008243b4 	movhi	r2,2318
 90b46dc:	10b75604 	addi	r2,r2,-8872
 90b46e0:	10c02815 	stw	r3,160(r2)
 90b46e4:	00000806 	br	90b4708 <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 90b46e8:	008243b4 	movhi	r2,2318
 90b46ec:	10b75604 	addi	r2,r2,-8872
 90b46f0:	10c02617 	ldw	r3,152(r2)
 90b46f4:	e0bfe417 	ldw	r2,-112(fp)
 90b46f8:	1887883a 	add	r3,r3,r2
 90b46fc:	008243b4 	movhi	r2,2318
 90b4700:	10b75604 	addi	r2,r2,-8872
 90b4704:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 90b4708:	e0bff017 	ldw	r2,-64(fp)
 90b470c:	10800217 	ldw	r2,8(r2)
 90b4710:	1005003a 	cmpeq	r2,r2,zero
 90b4714:	1000051e 	bne	r2,zero,90b472c <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 90b4718:	e0bfe417 	ldw	r2,-112(fp)
 90b471c:	008bc83a 	sub	r5,zero,r2
 90b4720:	e13ff017 	ldw	r4,-64(fp)
 90b4724:	90ab8fc0 	call	90ab8fc <m_adj>
 90b4728:	00000506 	br	90b4740 <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 90b472c:	e0bff017 	ldw	r2,-64(fp)
 90b4730:	11000617 	ldw	r4,24(r2)
 90b4734:	e0bfe417 	ldw	r2,-112(fp)
 90b4738:	008bc83a 	sub	r5,zero,r2
 90b473c:	90ab8fc0 	call	90ab8fc <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 90b4740:	e0bfed17 	ldw	r2,-76(fp)
 90b4744:	10c0028b 	ldhu	r3,10(r2)
 90b4748:	e0bfe417 	ldw	r2,-112(fp)
 90b474c:	1885c83a 	sub	r2,r3,r2
 90b4750:	1007883a 	mov	r3,r2
 90b4754:	e0bfed17 	ldw	r2,-76(fp)
 90b4758:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 90b475c:	e0ffe617 	ldw	r3,-104(fp)
 90b4760:	00bffd84 	movi	r2,-10
 90b4764:	1884703a 	and	r2,r3,r2
 90b4768:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 90b476c:	e0bfe617 	ldw	r2,-104(fp)
 90b4770:	1080010c 	andi	r2,r2,4
 90b4774:	1005003a 	cmpeq	r2,r2,zero
 90b4778:	1000391e 	bne	r2,zero,90b4860 <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 90b477c:	e0bfe717 	ldw	r2,-100(fp)
 90b4780:	10800217 	ldw	r2,8(r2)
 90b4784:	10bfff44 	addi	r2,r2,-3
 90b4788:	e0bffe15 	stw	r2,-8(fp)
 90b478c:	e13ffe17 	ldw	r4,-8(fp)
 90b4790:	20800228 	cmpgeui	r2,r4,8
 90b4794:	1000321e 	bne	r2,zero,90b4860 <tcp_input+0x1720>
 90b4798:	e0fffe17 	ldw	r3,-8(fp)
 90b479c:	e0fffe17 	ldw	r3,-8(fp)
 90b47a0:	18c5883a 	add	r2,r3,r3
 90b47a4:	1087883a 	add	r3,r2,r2
 90b47a8:	008242f4 	movhi	r2,2315
 90b47ac:	1091ef04 	addi	r2,r2,18364
 90b47b0:	1885883a 	add	r2,r3,r2
 90b47b4:	10800017 	ldw	r2,0(r2)
 90b47b8:	1000683a 	jmp	r2
 90b47bc:	090b47dc 	xori	r4,at,11551
 90b47c0:	090b47ec 	andhi	r4,at,11551
 90b47c4:	090b4808 	cmpgei	r4,at,11552
 90b47c8:	090b4808 	cmpgei	r4,at,11552
 90b47cc:	090b484c 	andi	r4,at,11553
 90b47d0:	090b484c 	andi	r4,at,11553
 90b47d4:	090b4808 	cmpgei	r4,at,11552
 90b47d8:	090b484c 	andi	r4,at,11553
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 90b47dc:	e0ffe517 	ldw	r3,-108(fp)
 90b47e0:	00801bc4 	movi	r2,111
 90b47e4:	18800615 	stw	r2,24(r3)
         goto close;
 90b47e8:	00000a06 	br	90b4814 <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 90b47ec:	008243b4 	movhi	r2,2318
 90b47f0:	10b72804 	addi	r2,r2,-9056
 90b47f4:	10800717 	ldw	r2,28(r2)
 90b47f8:	10c00044 	addi	r3,r2,1
 90b47fc:	008243b4 	movhi	r2,2318
 90b4800:	10b72804 	addi	r2,r2,-9056
 90b4804:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 90b4808:	e0ffe517 	ldw	r3,-108(fp)
 90b480c:	00801a04 	movi	r2,104
 90b4810:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 90b4814:	e0bfe717 	ldw	r2,-100(fp)
 90b4818:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 90b481c:	008243b4 	movhi	r2,2318
 90b4820:	10b75604 	addi	r2,r2,-8872
 90b4824:	10800317 	ldw	r2,12(r2)
 90b4828:	10c00044 	addi	r3,r2,1
 90b482c:	008243b4 	movhi	r2,2318
 90b4830:	10b75604 	addi	r2,r2,-8872
 90b4834:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 90b4838:	e13fe717 	ldw	r4,-100(fp)
 90b483c:	90b78700 	call	90b7870 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 90b4840:	00812204 	movi	r2,1160
 90b4844:	d0a0b315 	stw	r2,-32052(gp)
 90b4848:	00038106 	br	90b5650 <tcp_input+0x2510>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 90b484c:	e13fe717 	ldw	r4,-100(fp)
 90b4850:	90b78700 	call	90b7870 <tcp_close>
         GOTO_DROP;
 90b4854:	00812384 	movi	r2,1166
 90b4858:	d0a0b315 	stw	r2,-32052(gp)
 90b485c:	00037c06 	br	90b5650 <tcp_input+0x2510>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 90b4860:	e0bfe617 	ldw	r2,-104(fp)
 90b4864:	1080008c 	andi	r2,r2,2
 90b4868:	1005003a 	cmpeq	r2,r2,zero
 90b486c:	1000071e 	bne	r2,zero,90b488c <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 90b4870:	e13fe717 	ldw	r4,-100(fp)
 90b4874:	01401a04 	movi	r5,104
 90b4878:	90b77c40 	call	90b77c4 <tcp_drop>
 90b487c:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 90b4880:	00812b04 	movi	r2,1196
 90b4884:	d0a0b315 	stw	r2,-32052(gp)
 90b4888:	00032d06 	br	90b5540 <tcp_input+0x2400>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 90b488c:	e0bfe617 	ldw	r2,-104(fp)
 90b4890:	1080040c 	andi	r2,r2,16
 90b4894:	1004c03a 	cmpne	r2,r2,zero
 90b4898:	1000031e 	bne	r2,zero,90b48a8 <tcp_input+0x1768>
      GOTO_DROP;
 90b489c:	00812d04 	movi	r2,1204
 90b48a0:	d0a0b315 	stw	r2,-32052(gp)
 90b48a4:	00036a06 	br	90b5650 <tcp_input+0x2510>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 90b48a8:	e0bfe717 	ldw	r2,-100(fp)
 90b48ac:	10800217 	ldw	r2,8(r2)
 90b48b0:	e0bff715 	stw	r2,-36(fp)
 90b48b4:	e13ff717 	ldw	r4,-36(fp)
 90b48b8:	208000e0 	cmpeqi	r2,r4,3
 90b48bc:	1000071e 	bne	r2,zero,90b48dc <tcp_input+0x179c>
 90b48c0:	e0fff717 	ldw	r3,-36(fp)
 90b48c4:	188000d0 	cmplti	r2,r3,3
 90b48c8:	1001921e 	bne	r2,zero,90b4f14 <tcp_input+0x1dd4>
 90b48cc:	e13ff717 	ldw	r4,-36(fp)
 90b48d0:	208002c8 	cmpgei	r2,r4,11
 90b48d4:	10018f1e 	bne	r2,zero,90b4f14 <tcp_input+0x1dd4>
 90b48d8:	00003206 	br	90b49a4 <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 90b48dc:	e0bfe717 	ldw	r2,-100(fp)
 90b48e0:	10c00e17 	ldw	r3,56(r2)
 90b48e4:	e0bfed17 	ldw	r2,-76(fp)
 90b48e8:	10800717 	ldw	r2,28(r2)
 90b48ec:	1885c83a 	sub	r2,r3,r2
 90b48f0:	10800048 	cmpgei	r2,r2,1
 90b48f4:	1000071e 	bne	r2,zero,90b4914 <tcp_input+0x17d4>
 90b48f8:	e0bfed17 	ldw	r2,-76(fp)
 90b48fc:	10c00717 	ldw	r3,28(r2)
 90b4900:	e0bfe717 	ldw	r2,-100(fp)
 90b4904:	10801a17 	ldw	r2,104(r2)
 90b4908:	1885c83a 	sub	r2,r3,r2
 90b490c:	10800050 	cmplti	r2,r2,1
 90b4910:	10000a1e 	bne	r2,zero,90b493c <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 90b4914:	008243b4 	movhi	r2,2318
 90b4918:	10b72804 	addi	r2,r2,-9056
 90b491c:	10800717 	ldw	r2,28(r2)
 90b4920:	10c00044 	addi	r3,r2,1
 90b4924:	008243b4 	movhi	r2,2318
 90b4928:	10b72804 	addi	r2,r2,-9056
 90b492c:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 90b4930:	00813184 	movi	r2,1222
 90b4934:	d0a0b315 	stw	r2,-32052(gp)
 90b4938:	00030106 	br	90b5540 <tcp_input+0x2400>
      }
      tcpstat.tcps_connects++;
 90b493c:	008243b4 	movhi	r2,2318
 90b4940:	10b75604 	addi	r2,r2,-8872
 90b4944:	10800217 	ldw	r2,8(r2)
 90b4948:	10c00044 	addi	r3,r2,1
 90b494c:	008243b4 	movhi	r2,2318
 90b4950:	10b75604 	addi	r2,r2,-8872
 90b4954:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 90b4958:	e0ffe717 	ldw	r3,-100(fp)
 90b495c:	00800104 	movi	r2,4
 90b4960:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 90b4964:	e13fe517 	ldw	r4,-108(fp)
 90b4968:	90b11780 	call	90b1178 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 90b496c:	e13fe517 	ldw	r4,-108(fp)
 90b4970:	90b5c380 	call	90b5c38 <tcp_mss>
 90b4974:	1007883a 	mov	r3,r2
 90b4978:	e0bfe717 	ldw	r2,-100(fp)
 90b497c:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 90b4980:	e13fe717 	ldw	r4,-100(fp)
 90b4984:	000b883a 	mov	r5,zero
 90b4988:	e1bff017 	ldw	r6,-64(fp)
 90b498c:	90b2d380 	call	90b2d38 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 90b4990:	e0bfed17 	ldw	r2,-76(fp)
 90b4994:	10800617 	ldw	r2,24(r2)
 90b4998:	10ffffc4 	addi	r3,r2,-1
 90b499c:	e0bfe717 	ldw	r2,-100(fp)
 90b49a0:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 90b49a4:	e0bfed17 	ldw	r2,-76(fp)
 90b49a8:	10c00717 	ldw	r3,28(r2)
 90b49ac:	e0bfe717 	ldw	r2,-100(fp)
 90b49b0:	10800e17 	ldw	r2,56(r2)
 90b49b4:	1885c83a 	sub	r2,r3,r2
 90b49b8:	10800048 	cmpgei	r2,r2,1
 90b49bc:	1000671e 	bne	r2,zero,90b4b5c <tcp_input+0x1a1c>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 90b49c0:	e0bfed17 	ldw	r2,-76(fp)
 90b49c4:	1080028b 	ldhu	r2,10(r2)
 90b49c8:	10bfffcc 	andi	r2,r2,65535
 90b49cc:	1004c03a 	cmpne	r2,r2,zero
 90b49d0:	10005f1e 	bne	r2,zero,90b4b50 <tcp_input+0x1a10>
 90b49d4:	e0bfe717 	ldw	r2,-100(fp)
 90b49d8:	10c01417 	ldw	r3,80(r2)
 90b49dc:	e0bfde17 	ldw	r2,-136(fp)
 90b49e0:	18805b1e 	bne	r3,r2,90b4b50 <tcp_input+0x1a10>
         {
            tcpstat.tcps_rcvdupack++;
 90b49e4:	008243b4 	movhi	r2,2318
 90b49e8:	10b75604 	addi	r2,r2,-8872
 90b49ec:	10802917 	ldw	r2,164(r2)
 90b49f0:	10c00044 	addi	r3,r2,1
 90b49f4:	008243b4 	movhi	r2,2318
 90b49f8:	10b75604 	addi	r2,r2,-8872
 90b49fc:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 90b4a00:	e0bfe717 	ldw	r2,-100(fp)
 90b4a04:	10800317 	ldw	r2,12(r2)
 90b4a08:	1005003a 	cmpeq	r2,r2,zero
 90b4a0c:	1000051e 	bne	r2,zero,90b4a24 <tcp_input+0x18e4>
 90b4a10:	e0bfed17 	ldw	r2,-76(fp)
 90b4a14:	10c00717 	ldw	r3,28(r2)
 90b4a18:	e0bfe717 	ldw	r2,-100(fp)
 90b4a1c:	10800e17 	ldw	r2,56(r2)
 90b4a20:	18800326 	beq	r3,r2,90b4a30 <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 90b4a24:	e0bfe717 	ldw	r2,-100(fp)
 90b4a28:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 90b4a2c:	00013906 	br	90b4f14 <tcp_input+0x1dd4>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 90b4a30:	e0bfe717 	ldw	r2,-100(fp)
 90b4a34:	10800917 	ldw	r2,36(r2)
 90b4a38:	10c00044 	addi	r3,r2,1
 90b4a3c:	e0bfe717 	ldw	r2,-100(fp)
 90b4a40:	10c00915 	stw	r3,36(r2)
 90b4a44:	e0bfe717 	ldw	r2,-100(fp)
 90b4a48:	10c00917 	ldw	r3,36(r2)
 90b4a4c:	d0a03a83 	ldbu	r2,-32534(gp)
 90b4a50:	10803fcc 	andi	r2,r2,255
 90b4a54:	1080201c 	xori	r2,r2,128
 90b4a58:	10bfe004 	addi	r2,r2,-128
 90b4a5c:	18812d1e 	bne	r3,r2,90b4f14 <tcp_input+0x1dd4>
            {
               tcp_seq onxt = tp->snd_nxt;
 90b4a60:	e0bfe717 	ldw	r2,-100(fp)
 90b4a64:	10800f17 	ldw	r2,60(r2)
 90b4a68:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 90b4a6c:	e0bfe717 	ldw	r2,-100(fp)
 90b4a70:	10c01417 	ldw	r3,80(r2)
 90b4a74:	e0bfe717 	ldw	r2,-100(fp)
 90b4a78:	10801b17 	ldw	r2,108(r2)
 90b4a7c:	e0bff615 	stw	r2,-40(fp)
 90b4a80:	e0fff515 	stw	r3,-44(fp)
 90b4a84:	e0bff617 	ldw	r2,-40(fp)
 90b4a88:	e0fff517 	ldw	r3,-44(fp)
 90b4a8c:	10c0022e 	bgeu	r2,r3,90b4a98 <tcp_input+0x1958>
 90b4a90:	e13ff617 	ldw	r4,-40(fp)
 90b4a94:	e13ff515 	stw	r4,-44(fp)
 90b4a98:	e0bff517 	ldw	r2,-44(fp)
 90b4a9c:	1006d07a 	srli	r3,r2,1
 90b4aa0:	e0bfe717 	ldw	r2,-100(fp)
 90b4aa4:	10800a0b 	ldhu	r2,40(r2)
 90b4aa8:	10bfffcc 	andi	r2,r2,65535
 90b4aac:	1885203a 	divu	r2,r3,r2
 90b4ab0:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 90b4ab4:	e0bfd60b 	ldhu	r2,-168(fp)
 90b4ab8:	108000a8 	cmpgeui	r2,r2,2
 90b4abc:	1000021e 	bne	r2,zero,90b4ac8 <tcp_input+0x1988>
                  win = 2;
 90b4ac0:	00800084 	movi	r2,2
 90b4ac4:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 90b4ac8:	e0bfe717 	ldw	r2,-100(fp)
 90b4acc:	10c00a0b 	ldhu	r3,40(r2)
 90b4ad0:	e0bfd60b 	ldhu	r2,-168(fp)
 90b4ad4:	1885383a 	mul	r2,r3,r2
 90b4ad8:	10ffffcc 	andi	r3,r2,65535
 90b4adc:	e0bfe717 	ldw	r2,-100(fp)
 90b4ae0:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 90b4ae4:	e0bfe717 	ldw	r2,-100(fp)
 90b4ae8:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 90b4aec:	e0bfe717 	ldw	r2,-100(fp)
 90b4af0:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 90b4af4:	e0bfed17 	ldw	r2,-76(fp)
 90b4af8:	10c00717 	ldw	r3,28(r2)
 90b4afc:	e0bfe717 	ldw	r2,-100(fp)
 90b4b00:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 90b4b04:	e0bfe717 	ldw	r2,-100(fp)
 90b4b08:	10800a0b 	ldhu	r2,40(r2)
 90b4b0c:	10ffffcc 	andi	r3,r2,65535
 90b4b10:	e0bfe717 	ldw	r2,-100(fp)
 90b4b14:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 90b4b18:	e13fe717 	ldw	r4,-100(fp)
 90b4b1c:	90b5d540 	call	90b5d54 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 90b4b20:	e0bfe717 	ldw	r2,-100(fp)
 90b4b24:	10c00f17 	ldw	r3,60(r2)
 90b4b28:	e0bfd717 	ldw	r2,-164(fp)
 90b4b2c:	10c5c83a 	sub	r2,r2,r3
 90b4b30:	10800050 	cmplti	r2,r2,1
 90b4b34:	1000031e 	bne	r2,zero,90b4b44 <tcp_input+0x1a04>
                  tp->snd_nxt = onxt;
 90b4b38:	e0ffe717 	ldw	r3,-100(fp)
 90b4b3c:	e0bfd717 	ldw	r2,-164(fp)
 90b4b40:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 90b4b44:	00814544 	movi	r2,1301
 90b4b48:	d0a0b315 	stw	r2,-32052(gp)
 90b4b4c:	0002c006 	br	90b5650 <tcp_input+0x2510>
            }
         } else
            tp->t_dupacks = 0;
 90b4b50:	e0bfe717 	ldw	r2,-100(fp)
 90b4b54:	10000915 	stw	zero,36(r2)
         break;
 90b4b58:	0000ee06 	br	90b4f14 <tcp_input+0x1dd4>
      }
      tp->t_dupacks = 0;
 90b4b5c:	e0bfe717 	ldw	r2,-100(fp)
 90b4b60:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 90b4b64:	e0bfed17 	ldw	r2,-76(fp)
 90b4b68:	10c00717 	ldw	r3,28(r2)
 90b4b6c:	e0bfe717 	ldw	r2,-100(fp)
 90b4b70:	10801a17 	ldw	r2,104(r2)
 90b4b74:	1885c83a 	sub	r2,r3,r2
 90b4b78:	10800050 	cmplti	r2,r2,1
 90b4b7c:	1000081e 	bne	r2,zero,90b4ba0 <tcp_input+0x1a60>
      {
         tcpstat.tcps_rcvacktoomuch++;
 90b4b80:	008243b4 	movhi	r2,2318
 90b4b84:	10b75604 	addi	r2,r2,-8872
 90b4b88:	10802a17 	ldw	r2,168(r2)
 90b4b8c:	10c00044 	addi	r3,r2,1
 90b4b90:	008243b4 	movhi	r2,2318
 90b4b94:	10b75604 	addi	r2,r2,-8872
 90b4b98:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 90b4b9c:	00025606 	br	90b54f8 <tcp_input+0x23b8>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 90b4ba0:	e0bfed17 	ldw	r2,-76(fp)
 90b4ba4:	10c00717 	ldw	r3,28(r2)
 90b4ba8:	e0bfe717 	ldw	r2,-100(fp)
 90b4bac:	10800e17 	ldw	r2,56(r2)
 90b4bb0:	1885c83a 	sub	r2,r3,r2
 90b4bb4:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 90b4bb8:	008243b4 	movhi	r2,2318
 90b4bbc:	10b75604 	addi	r2,r2,-8872
 90b4bc0:	10802b17 	ldw	r2,172(r2)
 90b4bc4:	10c00044 	addi	r3,r2,1
 90b4bc8:	008243b4 	movhi	r2,2318
 90b4bcc:	10b75604 	addi	r2,r2,-8872
 90b4bd0:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 90b4bd4:	008243b4 	movhi	r2,2318
 90b4bd8:	10b75604 	addi	r2,r2,-8872
 90b4bdc:	10c02c17 	ldw	r3,176(r2)
 90b4be0:	e0bfe317 	ldw	r2,-116(fp)
 90b4be4:	1887883a 	add	r3,r3,r2
 90b4be8:	008243b4 	movhi	r2,2318
 90b4bec:	10b75604 	addi	r2,r2,-8872
 90b4bf0:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 90b4bf4:	e0bfe717 	ldw	r2,-100(fp)
 90b4bf8:	10801e17 	ldw	r2,120(r2)
 90b4bfc:	1005003a 	cmpeq	r2,r2,zero
 90b4c00:	1000091e 	bne	r2,zero,90b4c28 <tcp_input+0x1ae8>
 90b4c04:	e0bfed17 	ldw	r2,-76(fp)
 90b4c08:	10c00717 	ldw	r3,28(r2)
 90b4c0c:	e0bfe717 	ldw	r2,-100(fp)
 90b4c10:	10801f17 	ldw	r2,124(r2)
 90b4c14:	1885c83a 	sub	r2,r3,r2
 90b4c18:	10800050 	cmplti	r2,r2,1
 90b4c1c:	1000021e 	bne	r2,zero,90b4c28 <tcp_input+0x1ae8>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 90b4c20:	e13fe717 	ldw	r4,-100(fp)
 90b4c24:	90b59500 	call	90b5950 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 90b4c28:	e0bfed17 	ldw	r2,-76(fp)
 90b4c2c:	10c00717 	ldw	r3,28(r2)
 90b4c30:	e0bfe717 	ldw	r2,-100(fp)
 90b4c34:	10801a17 	ldw	r2,104(r2)
 90b4c38:	1880051e 	bne	r3,r2,90b4c50 <tcp_input+0x1b10>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 90b4c3c:	e0bfe717 	ldw	r2,-100(fp)
 90b4c40:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 90b4c44:	00800044 	movi	r2,1
 90b4c48:	e0bfe115 	stw	r2,-124(fp)
 90b4c4c:	00000806 	br	90b4c70 <tcp_input+0x1b30>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 90b4c50:	e0bfe717 	ldw	r2,-100(fp)
 90b4c54:	10800417 	ldw	r2,16(r2)
 90b4c58:	1004c03a 	cmpne	r2,r2,zero
 90b4c5c:	1000041e 	bne	r2,zero,90b4c70 <tcp_input+0x1b30>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b4c60:	e0bfe717 	ldw	r2,-100(fp)
 90b4c64:	10c00817 	ldw	r3,32(r2)
 90b4c68:	e0bfe717 	ldw	r2,-100(fp)
 90b4c6c:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 90b4c70:	e0bfe717 	ldw	r2,-100(fp)
 90b4c74:	10801b17 	ldw	r2,108(r2)
 90b4c78:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 90b4c7c:	e0bfe717 	ldw	r2,-100(fp)
 90b4c80:	10800a0b 	ldhu	r2,40(r2)
 90b4c84:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 90b4c88:	e0bfe717 	ldw	r2,-100(fp)
 90b4c8c:	10c01c17 	ldw	r3,112(r2)
 90b4c90:	e0bfd517 	ldw	r2,-172(fp)
 90b4c94:	18800e2e 	bgeu	r3,r2,90b4cd0 <tcp_input+0x1b90>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 90b4c98:	e0ffd40b 	ldhu	r3,-176(fp)
 90b4c9c:	e0bfd40b 	ldhu	r2,-176(fp)
 90b4ca0:	1885383a 	mul	r2,r3,r2
 90b4ca4:	1007883a 	mov	r3,r2
 90b4ca8:	e0bfd517 	ldw	r2,-172(fp)
 90b4cac:	1885203a 	divu	r2,r3,r2
 90b4cb0:	e0bff415 	stw	r2,-48(fp)
 90b4cb4:	e0fff417 	ldw	r3,-48(fp)
 90b4cb8:	18800428 	cmpgeui	r2,r3,16
 90b4cbc:	1000021e 	bne	r2,zero,90b4cc8 <tcp_input+0x1b88>
 90b4cc0:	01000404 	movi	r4,16
 90b4cc4:	e13ff415 	stw	r4,-48(fp)
 90b4cc8:	e0bff417 	ldw	r2,-48(fp)
 90b4ccc:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 90b4cd0:	e0ffd40b 	ldhu	r3,-176(fp)
 90b4cd4:	e0bfd517 	ldw	r2,-172(fp)
 90b4cd8:	1885883a 	add	r2,r3,r2
 90b4cdc:	e0bff315 	stw	r2,-52(fp)
 90b4ce0:	e0fff317 	ldw	r3,-52(fp)
 90b4ce4:	18980070 	cmpltui	r2,r3,24577
 90b4ce8:	1000021e 	bne	r2,zero,90b4cf4 <tcp_input+0x1bb4>
 90b4cec:	01180004 	movi	r4,24576
 90b4cf0:	e13ff315 	stw	r4,-52(fp)
 90b4cf4:	e0bfe717 	ldw	r2,-100(fp)
 90b4cf8:	e0fff317 	ldw	r3,-52(fp)
 90b4cfc:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 90b4d00:	e0bfe517 	ldw	r2,-108(fp)
 90b4d04:	10801217 	ldw	r2,72(r2)
 90b4d08:	1007883a 	mov	r3,r2
 90b4d0c:	e0bfe317 	ldw	r2,-116(fp)
 90b4d10:	1880110e 	bge	r3,r2,90b4d58 <tcp_input+0x1c18>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 90b4d14:	e0bfe717 	ldw	r2,-100(fp)
 90b4d18:	10c01417 	ldw	r3,80(r2)
 90b4d1c:	e0bfe517 	ldw	r2,-108(fp)
 90b4d20:	10801217 	ldw	r2,72(r2)
 90b4d24:	10bfffcc 	andi	r2,r2,65535
 90b4d28:	1887c83a 	sub	r3,r3,r2
 90b4d2c:	e0bfe717 	ldw	r2,-100(fp)
 90b4d30:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 90b4d34:	e0bfe517 	ldw	r2,-108(fp)
 90b4d38:	11001204 	addi	r4,r2,72
 90b4d3c:	e0bfe517 	ldw	r2,-108(fp)
 90b4d40:	10801217 	ldw	r2,72(r2)
 90b4d44:	100b883a 	mov	r5,r2
 90b4d48:	90b20b00 	call	90b20b0 <sbdrop>
         ourfinisacked = 1;
 90b4d4c:	00800044 	movi	r2,1
 90b4d50:	e0bfe215 	stw	r2,-120(fp)
 90b4d54:	00000c06 	br	90b4d88 <tcp_input+0x1c48>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 90b4d58:	e0bfe517 	ldw	r2,-108(fp)
 90b4d5c:	11001204 	addi	r4,r2,72
 90b4d60:	e17fe317 	ldw	r5,-116(fp)
 90b4d64:	90b20b00 	call	90b20b0 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 90b4d68:	e0bfe717 	ldw	r2,-100(fp)
 90b4d6c:	10c01417 	ldw	r3,80(r2)
 90b4d70:	e0bfe317 	ldw	r2,-116(fp)
 90b4d74:	10bfffcc 	andi	r2,r2,65535
 90b4d78:	1887c83a 	sub	r3,r3,r2
 90b4d7c:	e0bfe717 	ldw	r2,-100(fp)
 90b4d80:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 90b4d84:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 90b4d88:	e0bfe517 	ldw	r2,-108(fp)
 90b4d8c:	1080190b 	ldhu	r2,100(r2)
 90b4d90:	10bfffcc 	andi	r2,r2,65535
 90b4d94:	1080030c 	andi	r2,r2,12
 90b4d98:	1005003a 	cmpeq	r2,r2,zero
 90b4d9c:	1000041e 	bne	r2,zero,90b4db0 <tcp_input+0x1c70>
         sowwakeup(so);
 90b4da0:	e0bfe517 	ldw	r2,-108(fp)
 90b4da4:	11401204 	addi	r5,r2,72
 90b4da8:	e13fe517 	ldw	r4,-108(fp)
 90b4dac:	90b18e40 	call	90b18e4 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 90b4db0:	e0bfed17 	ldw	r2,-76(fp)
 90b4db4:	10c00717 	ldw	r3,28(r2)
 90b4db8:	e0bfe717 	ldw	r2,-100(fp)
 90b4dbc:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 90b4dc0:	e0bfe717 	ldw	r2,-100(fp)
 90b4dc4:	10c00f17 	ldw	r3,60(r2)
 90b4dc8:	e0bfe717 	ldw	r2,-100(fp)
 90b4dcc:	10800e17 	ldw	r2,56(r2)
 90b4dd0:	1885c83a 	sub	r2,r3,r2
 90b4dd4:	1004403a 	cmpge	r2,r2,zero
 90b4dd8:	1000041e 	bne	r2,zero,90b4dec <tcp_input+0x1cac>
         tp->snd_nxt = tp->snd_una;
 90b4ddc:	e0bfe717 	ldw	r2,-100(fp)
 90b4de0:	10c00e17 	ldw	r3,56(r2)
 90b4de4:	e0bfe717 	ldw	r2,-100(fp)
 90b4de8:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 90b4dec:	e0bfe717 	ldw	r2,-100(fp)
 90b4df0:	10800217 	ldw	r2,8(r2)
 90b4df4:	e0bff215 	stw	r2,-56(fp)
 90b4df8:	e13ff217 	ldw	r4,-56(fp)
 90b4dfc:	208001e0 	cmpeqi	r2,r4,7
 90b4e00:	1000221e 	bne	r2,zero,90b4e8c <tcp_input+0x1d4c>
 90b4e04:	e0fff217 	ldw	r3,-56(fp)
 90b4e08:	18800208 	cmpgei	r2,r3,8
 90b4e0c:	1000041e 	bne	r2,zero,90b4e20 <tcp_input+0x1ce0>
 90b4e10:	e13ff217 	ldw	r4,-56(fp)
 90b4e14:	208001a0 	cmpeqi	r2,r4,6
 90b4e18:	1000081e 	bne	r2,zero,90b4e3c <tcp_input+0x1cfc>
 90b4e1c:	00003d06 	br	90b4f14 <tcp_input+0x1dd4>
 90b4e20:	e0fff217 	ldw	r3,-56(fp)
 90b4e24:	18800220 	cmpeqi	r2,r3,8
 90b4e28:	10002a1e 	bne	r2,zero,90b4ed4 <tcp_input+0x1d94>
 90b4e2c:	e13ff217 	ldw	r4,-56(fp)
 90b4e30:	208002a0 	cmpeqi	r2,r4,10
 90b4e34:	10002f1e 	bne	r2,zero,90b4ef4 <tcp_input+0x1db4>
 90b4e38:	00003606 	br	90b4f14 <tcp_input+0x1dd4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 90b4e3c:	e0bfe217 	ldw	r2,-120(fp)
 90b4e40:	1005003a 	cmpeq	r2,r2,zero
 90b4e44:	1000331e 	bne	r2,zero,90b4f14 <tcp_input+0x1dd4>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 90b4e48:	e0bfe517 	ldw	r2,-108(fp)
 90b4e4c:	1080088b 	ldhu	r2,34(r2)
 90b4e50:	10bfffcc 	andi	r2,r2,65535
 90b4e54:	1080080c 	andi	r2,r2,32
 90b4e58:	1005003a 	cmpeq	r2,r2,zero
 90b4e5c:	1000071e 	bne	r2,zero,90b4e7c <tcp_input+0x1d3c>
            {
               soisdisconnected(so);
 90b4e60:	e13fe517 	ldw	r4,-108(fp)
 90b4e64:	90b13000 	call	90b1300 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 90b4e68:	00824374 	movhi	r2,2317
 90b4e6c:	108f3a04 	addi	r2,r2,15592
 90b4e70:	10c00017 	ldw	r3,0(r2)
 90b4e74:	e0bfe717 	ldw	r2,-100(fp)
 90b4e78:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 90b4e7c:	e0ffe717 	ldw	r3,-100(fp)
 90b4e80:	00800244 	movi	r2,9
 90b4e84:	18800215 	stw	r2,8(r3)
         }
         break;
 90b4e88:	00002206 	br	90b4f14 <tcp_input+0x1dd4>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 90b4e8c:	e0bfe217 	ldw	r2,-120(fp)
 90b4e90:	1005003a 	cmpeq	r2,r2,zero
 90b4e94:	10001f1e 	bne	r2,zero,90b4f14 <tcp_input+0x1dd4>
         {
            tp->t_state = TCPS_TIME_WAIT;
 90b4e98:	e0ffe717 	ldw	r3,-100(fp)
 90b4e9c:	00800284 	movi	r2,10
 90b4ea0:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 90b4ea4:	e13fe717 	ldw	r4,-100(fp)
 90b4ea8:	90b7d3c0 	call	90b7d3c <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b4eac:	00824374 	movhi	r2,2317
 90b4eb0:	108ebe04 	addi	r2,r2,15096
 90b4eb4:	10800017 	ldw	r2,0(r2)
 90b4eb8:	1085883a 	add	r2,r2,r2
 90b4ebc:	1007883a 	mov	r3,r2
 90b4ec0:	e0bfe717 	ldw	r2,-100(fp)
 90b4ec4:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 90b4ec8:	e13fe517 	ldw	r4,-108(fp)
 90b4ecc:	90b13000 	call	90b1300 <soisdisconnected>
         }
         break;
 90b4ed0:	00001006 	br	90b4f14 <tcp_input+0x1dd4>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 90b4ed4:	e0bfe217 	ldw	r2,-120(fp)
 90b4ed8:	1005003a 	cmpeq	r2,r2,zero
 90b4edc:	10000d1e 	bne	r2,zero,90b4f14 <tcp_input+0x1dd4>
         {
            SETTP(tp, tcp_close(tp));
 90b4ee0:	e13fe717 	ldw	r4,-100(fp)
 90b4ee4:	90b78700 	call	90b7870 <tcp_close>
            GOTO_DROP;
 90b4ee8:	00816644 	movi	r2,1433
 90b4eec:	d0a0b315 	stw	r2,-32052(gp)
 90b4ef0:	0001d706 	br	90b5650 <tcp_input+0x2510>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b4ef4:	00824374 	movhi	r2,2317
 90b4ef8:	108ebe04 	addi	r2,r2,15096
 90b4efc:	10800017 	ldw	r2,0(r2)
 90b4f00:	1085883a 	add	r2,r2,r2
 90b4f04:	1007883a 	mov	r3,r2
 90b4f08:	e0bfe717 	ldw	r2,-100(fp)
 90b4f0c:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 90b4f10:	00017906 	br	90b54f8 <tcp_input+0x23b8>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 90b4f14:	e0bfe617 	ldw	r2,-104(fp)
 90b4f18:	1080040c 	andi	r2,r2,16
 90b4f1c:	1005003a 	cmpeq	r2,r2,zero
 90b4f20:	1000471e 	bne	r2,zero,90b5040 <tcp_input+0x1f00>
 90b4f24:	e0bfe717 	ldw	r2,-100(fp)
 90b4f28:	10c01117 	ldw	r3,68(r2)
 90b4f2c:	e0bfed17 	ldw	r2,-76(fp)
 90b4f30:	10800617 	ldw	r2,24(r2)
 90b4f34:	1885c83a 	sub	r2,r3,r2
 90b4f38:	1004803a 	cmplt	r2,r2,zero
 90b4f3c:	1000151e 	bne	r2,zero,90b4f94 <tcp_input+0x1e54>
 90b4f40:	e0bfe717 	ldw	r2,-100(fp)
 90b4f44:	10c01117 	ldw	r3,68(r2)
 90b4f48:	e0bfed17 	ldw	r2,-76(fp)
 90b4f4c:	10800617 	ldw	r2,24(r2)
 90b4f50:	18803b1e 	bne	r3,r2,90b5040 <tcp_input+0x1f00>
 90b4f54:	e0bfe717 	ldw	r2,-100(fp)
 90b4f58:	10c01217 	ldw	r3,72(r2)
 90b4f5c:	e0bfed17 	ldw	r2,-76(fp)
 90b4f60:	10800717 	ldw	r2,28(r2)
 90b4f64:	1885c83a 	sub	r2,r3,r2
 90b4f68:	1004803a 	cmplt	r2,r2,zero
 90b4f6c:	1000091e 	bne	r2,zero,90b4f94 <tcp_input+0x1e54>
 90b4f70:	e0bfe717 	ldw	r2,-100(fp)
 90b4f74:	10c01217 	ldw	r3,72(r2)
 90b4f78:	e0bfed17 	ldw	r2,-76(fp)
 90b4f7c:	10800717 	ldw	r2,28(r2)
 90b4f80:	18802f1e 	bne	r3,r2,90b5040 <tcp_input+0x1f00>
 90b4f84:	e0bfe717 	ldw	r2,-100(fp)
 90b4f88:	10c01417 	ldw	r3,80(r2)
 90b4f8c:	e0bfde17 	ldw	r2,-136(fp)
 90b4f90:	18802b2e 	bgeu	r3,r2,90b5040 <tcp_input+0x1f00>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 90b4f94:	e0bfed17 	ldw	r2,-76(fp)
 90b4f98:	1080028b 	ldhu	r2,10(r2)
 90b4f9c:	10bfffcc 	andi	r2,r2,65535
 90b4fa0:	1004c03a 	cmpne	r2,r2,zero
 90b4fa4:	1000101e 	bne	r2,zero,90b4fe8 <tcp_input+0x1ea8>
 90b4fa8:	e0bfe717 	ldw	r2,-100(fp)
 90b4fac:	10c01217 	ldw	r3,72(r2)
 90b4fb0:	e0bfed17 	ldw	r2,-76(fp)
 90b4fb4:	10800717 	ldw	r2,28(r2)
 90b4fb8:	18800b1e 	bne	r3,r2,90b4fe8 <tcp_input+0x1ea8>
 90b4fbc:	e0bfe717 	ldw	r2,-100(fp)
 90b4fc0:	10c01417 	ldw	r3,80(r2)
 90b4fc4:	e0bfde17 	ldw	r2,-136(fp)
 90b4fc8:	1880072e 	bgeu	r3,r2,90b4fe8 <tcp_input+0x1ea8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 90b4fcc:	008243b4 	movhi	r2,2318
 90b4fd0:	10b75604 	addi	r2,r2,-8872
 90b4fd4:	10802d17 	ldw	r2,180(r2)
 90b4fd8:	10c00044 	addi	r3,r2,1
 90b4fdc:	008243b4 	movhi	r2,2318
 90b4fe0:	10b75604 	addi	r2,r2,-8872
 90b4fe4:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 90b4fe8:	e0ffe717 	ldw	r3,-100(fp)
 90b4fec:	e0bfde17 	ldw	r2,-136(fp)
 90b4ff0:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 90b4ff4:	e0bfed17 	ldw	r2,-76(fp)
 90b4ff8:	10c00617 	ldw	r3,24(r2)
 90b4ffc:	e0bfe717 	ldw	r2,-100(fp)
 90b5000:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 90b5004:	e0bfed17 	ldw	r2,-76(fp)
 90b5008:	10c00717 	ldw	r3,28(r2)
 90b500c:	e0bfe717 	ldw	r2,-100(fp)
 90b5010:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 90b5014:	e0bfe717 	ldw	r2,-100(fp)
 90b5018:	10c01417 	ldw	r3,80(r2)
 90b501c:	e0bfe717 	ldw	r2,-100(fp)
 90b5020:	10802317 	ldw	r2,140(r2)
 90b5024:	10c0042e 	bgeu	r2,r3,90b5038 <tcp_input+0x1ef8>
         tp->max_sndwnd = tp->snd_wnd;
 90b5028:	e0bfe717 	ldw	r2,-100(fp)
 90b502c:	10c01417 	ldw	r3,80(r2)
 90b5030:	e0bfe717 	ldw	r2,-100(fp)
 90b5034:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 90b5038:	00800044 	movi	r2,1
 90b503c:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 90b5040:	e0bfe617 	ldw	r2,-104(fp)
 90b5044:	1080080c 	andi	r2,r2,32
 90b5048:	1005003a 	cmpeq	r2,r2,zero
 90b504c:	10005a1e 	bne	r2,zero,90b51b8 <tcp_input+0x2078>
 90b5050:	e0bfed17 	ldw	r2,-76(fp)
 90b5054:	1080098b 	ldhu	r2,38(r2)
 90b5058:	10bfffcc 	andi	r2,r2,65535
 90b505c:	1005003a 	cmpeq	r2,r2,zero
 90b5060:	1000551e 	bne	r2,zero,90b51b8 <tcp_input+0x2078>
 90b5064:	e0bfe717 	ldw	r2,-100(fp)
 90b5068:	10800217 	ldw	r2,8(r2)
 90b506c:	10800288 	cmpgei	r2,r2,10
 90b5070:	1000511e 	bne	r2,zero,90b51b8 <tcp_input+0x2078>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 90b5074:	e0bfed17 	ldw	r2,-76(fp)
 90b5078:	1080098b 	ldhu	r2,38(r2)
 90b507c:	10ffffcc 	andi	r3,r2,65535
 90b5080:	e0bfe517 	ldw	r2,-108(fp)
 90b5084:	10800a17 	ldw	r2,40(r2)
 90b5088:	1885883a 	add	r2,r3,r2
 90b508c:	10900070 	cmpltui	r2,r2,16385
 90b5090:	1000071e 	bne	r2,zero,90b50b0 <tcp_input+0x1f70>
      {
         ti->ti_urp = 0;         /* XXX */
 90b5094:	e0bfed17 	ldw	r2,-76(fp)
 90b5098:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 90b509c:	e0ffe617 	ldw	r3,-104(fp)
 90b50a0:	00bff7c4 	movi	r2,-33
 90b50a4:	1884703a 	and	r2,r3,r2
 90b50a8:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 90b50ac:	00004d06 	br	90b51e4 <tcp_input+0x20a4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 90b50b0:	e0bfed17 	ldw	r2,-76(fp)
 90b50b4:	10c00617 	ldw	r3,24(r2)
 90b50b8:	e0bfed17 	ldw	r2,-76(fp)
 90b50bc:	1080098b 	ldhu	r2,38(r2)
 90b50c0:	10bfffcc 	andi	r2,r2,65535
 90b50c4:	1887883a 	add	r3,r3,r2
 90b50c8:	e0bfe717 	ldw	r2,-100(fp)
 90b50cc:	10801717 	ldw	r2,92(r2)
 90b50d0:	1885c83a 	sub	r2,r3,r2
 90b50d4:	10800050 	cmplti	r2,r2,1
 90b50d8:	1000261e 	bne	r2,zero,90b5174 <tcp_input+0x2034>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 90b50dc:	e0bfed17 	ldw	r2,-76(fp)
 90b50e0:	10c00617 	ldw	r3,24(r2)
 90b50e4:	e0bfed17 	ldw	r2,-76(fp)
 90b50e8:	1080098b 	ldhu	r2,38(r2)
 90b50ec:	10bfffcc 	andi	r2,r2,65535
 90b50f0:	1887883a 	add	r3,r3,r2
 90b50f4:	e0bfe717 	ldw	r2,-100(fp)
 90b50f8:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 90b50fc:	e0bfe517 	ldw	r2,-108(fp)
 90b5100:	11000a17 	ldw	r4,40(r2)
 90b5104:	e0bfe717 	ldw	r2,-100(fp)
 90b5108:	10c01717 	ldw	r3,92(r2)
 90b510c:	e0bfe717 	ldw	r2,-100(fp)
 90b5110:	10801617 	ldw	r2,88(r2)
 90b5114:	1885c83a 	sub	r2,r3,r2
 90b5118:	2085883a 	add	r2,r4,r2
 90b511c:	10ffffc4 	addi	r3,r2,-1
 90b5120:	e0bfe517 	ldw	r2,-108(fp)
 90b5124:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 90b5128:	e0bfe517 	ldw	r2,-108(fp)
 90b512c:	10801a17 	ldw	r2,104(r2)
 90b5130:	1004c03a 	cmpne	r2,r2,zero
 90b5134:	1000061e 	bne	r2,zero,90b5150 <tcp_input+0x2010>
            so->so_state |= SS_RCVATMARK;
 90b5138:	e0bfe517 	ldw	r2,-108(fp)
 90b513c:	1080088b 	ldhu	r2,34(r2)
 90b5140:	10801014 	ori	r2,r2,64
 90b5144:	1007883a 	mov	r3,r2
 90b5148:	e0bfe517 	ldw	r2,-108(fp)
 90b514c:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 90b5150:	e13fe517 	ldw	r4,-108(fp)
 90b5154:	90b10c80 	call	90b10c8 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 90b5158:	e0bfe717 	ldw	r2,-100(fp)
 90b515c:	10c02403 	ldbu	r3,144(r2)
 90b5160:	00bfff04 	movi	r2,-4
 90b5164:	1884703a 	and	r2,r3,r2
 90b5168:	1007883a 	mov	r3,r2
 90b516c:	e0bfe717 	ldw	r2,-100(fp)
 90b5170:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 90b5174:	e0bfed17 	ldw	r2,-76(fp)
 90b5178:	10c0098b 	ldhu	r3,38(r2)
 90b517c:	e0bfed17 	ldw	r2,-76(fp)
 90b5180:	1080028b 	ldhu	r2,10(r2)
 90b5184:	18ffffcc 	andi	r3,r3,65535
 90b5188:	10bfffcc 	andi	r2,r2,65535
 90b518c:	10c01536 	bltu	r2,r3,90b51e4 <tcp_input+0x20a4>
 90b5190:	e0bfe517 	ldw	r2,-108(fp)
 90b5194:	10800417 	ldw	r2,16(r2)
 90b5198:	1080400c 	andi	r2,r2,256
 90b519c:	1004c03a 	cmpne	r2,r2,zero
 90b51a0:	1000101e 	bne	r2,zero,90b51e4 <tcp_input+0x20a4>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 90b51a4:	e13fe517 	ldw	r4,-108(fp)
 90b51a8:	e17fed17 	ldw	r5,-76(fp)
 90b51ac:	e1bff017 	ldw	r6,-64(fp)
 90b51b0:	90b58240 	call	90b5824 <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 90b51b4:	00000b06 	br	90b51e4 <tcp_input+0x20a4>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 90b51b8:	e0bfe717 	ldw	r2,-100(fp)
 90b51bc:	10c01617 	ldw	r3,88(r2)
 90b51c0:	e0bfe717 	ldw	r2,-100(fp)
 90b51c4:	10801717 	ldw	r2,92(r2)
 90b51c8:	1885c83a 	sub	r2,r3,r2
 90b51cc:	10800050 	cmplti	r2,r2,1
 90b51d0:	1000041e 	bne	r2,zero,90b51e4 <tcp_input+0x20a4>
      tp->rcv_up = tp->rcv_nxt;
 90b51d4:	e0bfe717 	ldw	r2,-100(fp)
 90b51d8:	10c01617 	ldw	r3,88(r2)
 90b51dc:	e0bfe717 	ldw	r2,-100(fp)
 90b51e0:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 90b51e4:	e0bfed17 	ldw	r2,-76(fp)
 90b51e8:	1080028b 	ldhu	r2,10(r2)
 90b51ec:	10bfffcc 	andi	r2,r2,65535
 90b51f0:	1004c03a 	cmpne	r2,r2,zero
 90b51f4:	1000051e 	bne	r2,zero,90b520c <tcp_input+0x20cc>
 90b51f8:	e0bfe617 	ldw	r2,-104(fp)
 90b51fc:	1080004c 	andi	r2,r2,1
 90b5200:	10803fcc 	andi	r2,r2,255
 90b5204:	1005003a 	cmpeq	r2,r2,zero
 90b5208:	10005c1e 	bne	r2,zero,90b537c <tcp_input+0x223c>
 90b520c:	e0bfe717 	ldw	r2,-100(fp)
 90b5210:	10800217 	ldw	r2,8(r2)
 90b5214:	10800288 	cmpgei	r2,r2,10
 90b5218:	1000581e 	bne	r2,zero,90b537c <tcp_input+0x223c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 90b521c:	e0bfed17 	ldw	r2,-76(fp)
 90b5220:	10c00617 	ldw	r3,24(r2)
 90b5224:	e0bfe717 	ldw	r2,-100(fp)
 90b5228:	10801617 	ldw	r2,88(r2)
 90b522c:	1880351e 	bne	r3,r2,90b5304 <tcp_input+0x21c4>
 90b5230:	e0bfe717 	ldw	r2,-100(fp)
 90b5234:	10c00017 	ldw	r3,0(r2)
 90b5238:	e0bfe717 	ldw	r2,-100(fp)
 90b523c:	1880311e 	bne	r3,r2,90b5304 <tcp_input+0x21c4>
 90b5240:	e0bfe717 	ldw	r2,-100(fp)
 90b5244:	10800217 	ldw	r2,8(r2)
 90b5248:	10800118 	cmpnei	r2,r2,4
 90b524c:	10002d1e 	bne	r2,zero,90b5304 <tcp_input+0x21c4>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 90b5250:	e0bfe717 	ldw	r2,-100(fp)
 90b5254:	10800b0b 	ldhu	r2,44(r2)
 90b5258:	10800054 	ori	r2,r2,1
 90b525c:	1007883a 	mov	r3,r2
 90b5260:	e0bfe717 	ldw	r2,-100(fp)
 90b5264:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 90b5268:	e0bfe717 	ldw	r2,-100(fp)
 90b526c:	10c01617 	ldw	r3,88(r2)
 90b5270:	e0bfed17 	ldw	r2,-76(fp)
 90b5274:	1080028b 	ldhu	r2,10(r2)
 90b5278:	10bfffcc 	andi	r2,r2,65535
 90b527c:	1887883a 	add	r3,r3,r2
 90b5280:	e0bfe717 	ldw	r2,-100(fp)
 90b5284:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 90b5288:	e0bfed17 	ldw	r2,-76(fp)
 90b528c:	10800843 	ldbu	r2,33(r2)
 90b5290:	10803fcc 	andi	r2,r2,255
 90b5294:	1080004c 	andi	r2,r2,1
 90b5298:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 90b529c:	008243b4 	movhi	r2,2318
 90b52a0:	10b75604 	addi	r2,r2,-8872
 90b52a4:	10801a17 	ldw	r2,104(r2)
 90b52a8:	10c00044 	addi	r3,r2,1
 90b52ac:	008243b4 	movhi	r2,2318
 90b52b0:	10b75604 	addi	r2,r2,-8872
 90b52b4:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 90b52b8:	008243b4 	movhi	r2,2318
 90b52bc:	10b75604 	addi	r2,r2,-8872
 90b52c0:	10c01b17 	ldw	r3,108(r2)
 90b52c4:	e0bfed17 	ldw	r2,-76(fp)
 90b52c8:	1080028b 	ldhu	r2,10(r2)
 90b52cc:	10bfffcc 	andi	r2,r2,65535
 90b52d0:	1887883a 	add	r3,r3,r2
 90b52d4:	008243b4 	movhi	r2,2318
 90b52d8:	10b75604 	addi	r2,r2,-8872
 90b52dc:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 90b52e0:	e0bfe517 	ldw	r2,-108(fp)
 90b52e4:	11000a04 	addi	r4,r2,40
 90b52e8:	e17ff017 	ldw	r5,-64(fp)
 90b52ec:	90b1aa80 	call	90b1aa8 <sbappend>
         sorwakeup(so);
 90b52f0:	e0bfe517 	ldw	r2,-108(fp)
 90b52f4:	11400a04 	addi	r5,r2,40
 90b52f8:	e13fe517 	ldw	r4,-108(fp)
 90b52fc:	90b18e40 	call	90b18e4 <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 90b5300:	00000b06 	br	90b5330 <tcp_input+0x21f0>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 90b5304:	e13fe717 	ldw	r4,-100(fp)
 90b5308:	e17fed17 	ldw	r5,-76(fp)
 90b530c:	e1bff017 	ldw	r6,-64(fp)
 90b5310:	90b2d380 	call	90b2d38 <tcp_reass>
 90b5314:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 90b5318:	e0bfe717 	ldw	r2,-100(fp)
 90b531c:	10800b0b 	ldhu	r2,44(r2)
 90b5320:	10800054 	ori	r2,r2,1
 90b5324:	1007883a 	mov	r3,r2
 90b5328:	e0bfe717 	ldw	r2,-100(fp)
 90b532c:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 90b5330:	e0bfe517 	ldw	r2,-108(fp)
 90b5334:	11000b17 	ldw	r4,44(r2)
 90b5338:	e0bfe717 	ldw	r2,-100(fp)
 90b533c:	10c01917 	ldw	r3,100(r2)
 90b5340:	e0bfe717 	ldw	r2,-100(fp)
 90b5344:	10801617 	ldw	r2,88(r2)
 90b5348:	1885c83a 	sub	r2,r3,r2
 90b534c:	2085c83a 	sub	r2,r4,r2
 90b5350:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 90b5354:	e0bfe717 	ldw	r2,-100(fp)
 90b5358:	10802217 	ldw	r2,136(r2)
 90b535c:	1007883a 	mov	r3,r2
 90b5360:	e0bfea17 	ldw	r2,-88(fp)
 90b5364:	18800b0e 	bge	r3,r2,90b5394 <tcp_input+0x2254>
         tp->max_rcvd = (u_short)len;
 90b5368:	e0bfea17 	ldw	r2,-88(fp)
 90b536c:	10ffffcc 	andi	r3,r2,65535
 90b5370:	e0bfe717 	ldw	r2,-100(fp)
 90b5374:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 90b5378:	00000606 	br	90b5394 <tcp_input+0x2254>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 90b537c:	e13ff017 	ldw	r4,-64(fp)
 90b5380:	90ab5940 	call	90ab594 <m_freem>
      tiflags &= ~TH_FIN;
 90b5384:	e0bfe617 	ldw	r2,-104(fp)
 90b5388:	00ffff84 	movi	r3,-2
 90b538c:	10c4703a 	and	r2,r2,r3
 90b5390:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 90b5394:	e0bfe617 	ldw	r2,-104(fp)
 90b5398:	1080004c 	andi	r2,r2,1
 90b539c:	10803fcc 	andi	r2,r2,255
 90b53a0:	1005003a 	cmpeq	r2,r2,zero
 90b53a4:	1000471e 	bne	r2,zero,90b54c4 <tcp_input+0x2384>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 90b53a8:	e0bfe717 	ldw	r2,-100(fp)
 90b53ac:	10800217 	ldw	r2,8(r2)
 90b53b0:	10800288 	cmpgei	r2,r2,10
 90b53b4:	10000d1e 	bne	r2,zero,90b53ec <tcp_input+0x22ac>
      {
         socantrcvmore(so);
 90b53b8:	e13fe517 	ldw	r4,-108(fp)
 90b53bc:	90b17f40 	call	90b17f4 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 90b53c0:	e0bfe717 	ldw	r2,-100(fp)
 90b53c4:	10800b0b 	ldhu	r2,44(r2)
 90b53c8:	10800054 	ori	r2,r2,1
 90b53cc:	1007883a 	mov	r3,r2
 90b53d0:	e0bfe717 	ldw	r2,-100(fp)
 90b53d4:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 90b53d8:	e0bfe717 	ldw	r2,-100(fp)
 90b53dc:	10801617 	ldw	r2,88(r2)
 90b53e0:	10c00044 	addi	r3,r2,1
 90b53e4:	e0bfe717 	ldw	r2,-100(fp)
 90b53e8:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 90b53ec:	e0bfe717 	ldw	r2,-100(fp)
 90b53f0:	10800217 	ldw	r2,8(r2)
 90b53f4:	10bfff44 	addi	r2,r2,-3
 90b53f8:	e0bfff15 	stw	r2,-4(fp)
 90b53fc:	e0ffff17 	ldw	r3,-4(fp)
 90b5400:	18800228 	cmpgeui	r2,r3,8
 90b5404:	10002f1e 	bne	r2,zero,90b54c4 <tcp_input+0x2384>
 90b5408:	e13fff17 	ldw	r4,-4(fp)
 90b540c:	e13fff17 	ldw	r4,-4(fp)
 90b5410:	2105883a 	add	r2,r4,r4
 90b5414:	1087883a 	add	r3,r2,r2
 90b5418:	008242f4 	movhi	r2,2315
 90b541c:	10950b04 	addi	r2,r2,21548
 90b5420:	1885883a 	add	r2,r3,r2
 90b5424:	10800017 	ldw	r2,0(r2)
 90b5428:	1000683a 	jmp	r2
 90b542c:	090b544c 	andi	r4,at,11601
 90b5430:	090b544c 	andi	r4,at,11601
 90b5434:	090b54c4 	addi	r4,at,11603
 90b5438:	090b545c 	xori	r4,at,11601
 90b543c:	090b54c4 	addi	r4,at,11603
 90b5440:	090b54c4 	addi	r4,at,11603
 90b5444:	090b546c 	andhi	r4,at,11601
 90b5448:	090b54a8 	cmpgeui	r4,at,11602
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 90b544c:	e0ffe717 	ldw	r3,-100(fp)
 90b5450:	00800144 	movi	r2,5
 90b5454:	18800215 	stw	r2,8(r3)
         break;
 90b5458:	00001a06 	br	90b54c4 <tcp_input+0x2384>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 90b545c:	e0ffe717 	ldw	r3,-100(fp)
 90b5460:	008001c4 	movi	r2,7
 90b5464:	18800215 	stw	r2,8(r3)
         break;
 90b5468:	00001606 	br	90b54c4 <tcp_input+0x2384>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 90b546c:	e0ffe717 	ldw	r3,-100(fp)
 90b5470:	00800284 	movi	r2,10
 90b5474:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 90b5478:	e13fe717 	ldw	r4,-100(fp)
 90b547c:	90b7d3c0 	call	90b7d3c <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b5480:	00824374 	movhi	r2,2317
 90b5484:	108ebe04 	addi	r2,r2,15096
 90b5488:	10800017 	ldw	r2,0(r2)
 90b548c:	1085883a 	add	r2,r2,r2
 90b5490:	1007883a 	mov	r3,r2
 90b5494:	e0bfe717 	ldw	r2,-100(fp)
 90b5498:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 90b549c:	e13fe517 	ldw	r4,-108(fp)
 90b54a0:	90b13000 	call	90b1300 <soisdisconnected>
         break;
 90b54a4:	00000706 	br	90b54c4 <tcp_input+0x2384>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 90b54a8:	00824374 	movhi	r2,2317
 90b54ac:	108ebe04 	addi	r2,r2,15096
 90b54b0:	10800017 	ldw	r2,0(r2)
 90b54b4:	1085883a 	add	r2,r2,r2
 90b54b8:	1007883a 	mov	r3,r2
 90b54bc:	e0bfe717 	ldw	r2,-100(fp)
 90b54c0:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 90b54c4:	e0bfe117 	ldw	r2,-124(fp)
 90b54c8:	1004c03a 	cmpne	r2,r2,zero
 90b54cc:	1000071e 	bne	r2,zero,90b54ec <tcp_input+0x23ac>
 90b54d0:	e0bfe717 	ldw	r2,-100(fp)
 90b54d4:	10800b0b 	ldhu	r2,44(r2)
 90b54d8:	10bfffcc 	andi	r2,r2,65535
 90b54dc:	1080004c 	andi	r2,r2,1
 90b54e0:	10803fcc 	andi	r2,r2,255
 90b54e4:	1005003a 	cmpeq	r2,r2,zero
 90b54e8:	1000651e 	bne	r2,zero,90b5680 <tcp_input+0x2540>
      (void) tcp_output(tp);
 90b54ec:	e13fe717 	ldw	r4,-100(fp)
 90b54f0:	90b5d540 	call	90b5d54 <tcp_output>
   return;
 90b54f4:	00006206 	br	90b5680 <tcp_input+0x2540>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 90b54f8:	e0bfe617 	ldw	r2,-104(fp)
 90b54fc:	1080010c 	andi	r2,r2,4
 90b5500:	1005003a 	cmpeq	r2,r2,zero
 90b5504:	1000031e 	bne	r2,zero,90b5514 <tcp_input+0x23d4>
      GOTO_DROP;
 90b5508:	0081a904 	movi	r2,1700
 90b550c:	d0a0b315 	stw	r2,-32052(gp)
 90b5510:	00004f06 	br	90b5650 <tcp_input+0x2510>
   m_freem (m);
 90b5514:	e13ff017 	ldw	r4,-64(fp)
 90b5518:	90ab5940 	call	90ab594 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 90b551c:	e0bfe717 	ldw	r2,-100(fp)
 90b5520:	10800b0b 	ldhu	r2,44(r2)
 90b5524:	10800054 	ori	r2,r2,1
 90b5528:	1007883a 	mov	r3,r2
 90b552c:	e0bfe717 	ldw	r2,-100(fp)
 90b5530:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 90b5534:	e13fe717 	ldw	r4,-100(fp)
 90b5538:	90b5d540 	call	90b5d54 <tcp_output>
   return;
 90b553c:	00005006 	br	90b5680 <tcp_input+0x2540>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 90b5540:	008243b4 	movhi	r2,2318
 90b5544:	10b72804 	addi	r2,r2,-9056
 90b5548:	10800d17 	ldw	r2,52(r2)
 90b554c:	10c00044 	addi	r3,r2,1
 90b5550:	008243b4 	movhi	r2,2318
 90b5554:	10b72804 	addi	r2,r2,-9056
 90b5558:	10c00d15 	stw	r3,52(r2)
   if (om) 
 90b555c:	e0bfeb17 	ldw	r2,-84(fp)
 90b5560:	1005003a 	cmpeq	r2,r2,zero
 90b5564:	1000031e 	bne	r2,zero,90b5574 <tcp_input+0x2434>
   {
      (void) m_free(om);
 90b5568:	e13feb17 	ldw	r4,-84(fp)
 90b556c:	90ab4600 	call	90ab460 <m_free>
      om = 0;
 90b5570:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 90b5574:	e0bfe617 	ldw	r2,-104(fp)
 90b5578:	1080010c 	andi	r2,r2,4
 90b557c:	1005003a 	cmpeq	r2,r2,zero
 90b5580:	1000031e 	bne	r2,zero,90b5590 <tcp_input+0x2450>
      GOTO_DROP;
 90b5584:	0081ad04 	movi	r2,1716
 90b5588:	d0a0b315 	stw	r2,-32052(gp)
 90b558c:	00003006 	br	90b5650 <tcp_input+0x2510>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 90b5590:	e0bfed17 	ldw	r2,-76(fp)
 90b5594:	11000417 	ldw	r4,16(r2)
 90b5598:	90ac5c00 	call	90ac5c0 <in_broadcast>
 90b559c:	1005003a 	cmpeq	r2,r2,zero
 90b55a0:	1000031e 	bne	r2,zero,90b55b0 <tcp_input+0x2470>
      GOTO_DROP;
 90b55a4:	0081af44 	movi	r2,1725
 90b55a8:	d0a0b315 	stw	r2,-32052(gp)
 90b55ac:	00002806 	br	90b5650 <tcp_input+0x2510>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 90b55b0:	e0bfe617 	ldw	r2,-104(fp)
 90b55b4:	1080040c 	andi	r2,r2,16
 90b55b8:	1005003a 	cmpeq	r2,r2,zero
 90b55bc:	10000b1e 	bne	r2,zero,90b55ec <tcp_input+0x24ac>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 90b55c0:	e0bfed17 	ldw	r2,-76(fp)
 90b55c4:	11c00717 	ldw	r7,28(r2)
 90b55c8:	00800104 	movi	r2,4
 90b55cc:	d8800015 	stw	r2,0(sp)
 90b55d0:	e0bff017 	ldw	r2,-64(fp)
 90b55d4:	d8800115 	stw	r2,4(sp)
 90b55d8:	e13fe717 	ldw	r4,-100(fp)
 90b55dc:	e17fed17 	ldw	r5,-76(fp)
 90b55e0:	000d883a 	mov	r6,zero
 90b55e4:	90b72240 	call	90b7224 <tcp_respond>
 90b55e8:	00001306 	br	90b5638 <tcp_input+0x24f8>
   else
   {
      if (tiflags & TH_SYN)
 90b55ec:	e0bfe617 	ldw	r2,-104(fp)
 90b55f0:	1080008c 	andi	r2,r2,2
 90b55f4:	1005003a 	cmpeq	r2,r2,zero
 90b55f8:	1000051e 	bne	r2,zero,90b5610 <tcp_input+0x24d0>
         ti->ti_seq++;
 90b55fc:	e0bfed17 	ldw	r2,-76(fp)
 90b5600:	10800617 	ldw	r2,24(r2)
 90b5604:	10c00044 	addi	r3,r2,1
 90b5608:	e0bfed17 	ldw	r2,-76(fp)
 90b560c:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 90b5610:	e0bfed17 	ldw	r2,-76(fp)
 90b5614:	11800617 	ldw	r6,24(r2)
 90b5618:	00800504 	movi	r2,20
 90b561c:	d8800015 	stw	r2,0(sp)
 90b5620:	e0bff017 	ldw	r2,-64(fp)
 90b5624:	d8800115 	stw	r2,4(sp)
 90b5628:	e13fe717 	ldw	r4,-100(fp)
 90b562c:	e17fed17 	ldw	r5,-76(fp)
 90b5630:	000f883a 	mov	r7,zero
 90b5634:	90b72240 	call	90b7224 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 90b5638:	e0bfe017 	ldw	r2,-128(fp)
 90b563c:	1005003a 	cmpeq	r2,r2,zero
 90b5640:	10000f1e 	bne	r2,zero,90b5680 <tcp_input+0x2540>
      (void) soabort(so);
 90b5644:	e13fe517 	ldw	r4,-108(fp)
 90b5648:	90af4d40 	call	90af4d4 <soabort>
   return;
 90b564c:	00000c06 	br	90b5680 <tcp_input+0x2540>

drop:
   if (om)
 90b5650:	e0bfeb17 	ldw	r2,-84(fp)
 90b5654:	1005003a 	cmpeq	r2,r2,zero
 90b5658:	1000021e 	bne	r2,zero,90b5664 <tcp_input+0x2524>
      (void) m_free(om);
 90b565c:	e13feb17 	ldw	r4,-84(fp)
 90b5660:	90ab4600 	call	90ab460 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 90b5664:	e13ff017 	ldw	r4,-64(fp)
 90b5668:	90ab5940 	call	90ab594 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 90b566c:	e0bfe017 	ldw	r2,-128(fp)
 90b5670:	1005003a 	cmpeq	r2,r2,zero
 90b5674:	1000021e 	bne	r2,zero,90b5680 <tcp_input+0x2540>
      (void) soabort(so);
 90b5678:	e13fe517 	ldw	r4,-108(fp)
 90b567c:	90af4d40 	call	90af4d4 <soabort>
   return;
}
 90b5680:	e037883a 	mov	sp,fp
 90b5684:	dfc00117 	ldw	ra,4(sp)
 90b5688:	df000017 	ldw	fp,0(sp)
 90b568c:	dec00204 	addi	sp,sp,8
 90b5690:	f800283a 	ret

090b5694 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 90b5694:	defff404 	addi	sp,sp,-48
 90b5698:	dfc00b15 	stw	ra,44(sp)
 90b569c:	df000a15 	stw	fp,40(sp)
 90b56a0:	df000a04 	addi	fp,sp,40
 90b56a4:	e13ffc15 	stw	r4,-16(fp)
 90b56a8:	e17ffd15 	stw	r5,-12(fp)
 90b56ac:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 90b56b0:	e0bffc17 	ldw	r2,-16(fp)
 90b56b4:	10800d17 	ldw	r2,52(r2)
 90b56b8:	10800817 	ldw	r2,32(r2)
 90b56bc:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 90b56c0:	e0bffd17 	ldw	r2,-12(fp)
 90b56c4:	10800317 	ldw	r2,12(r2)
 90b56c8:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 90b56cc:	e0bffd17 	ldw	r2,-12(fp)
 90b56d0:	10800217 	ldw	r2,8(r2)
 90b56d4:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 90b56d8:	00004806 	br	90b57fc <tcp_dooptions+0x168>
   {
      opt = cp[0];
 90b56dc:	e0bffb17 	ldw	r2,-20(fp)
 90b56e0:	10800003 	ldbu	r2,0(r2)
 90b56e4:	10803fcc 	andi	r2,r2,255
 90b56e8:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 90b56ec:	e0bffa17 	ldw	r2,-24(fp)
 90b56f0:	1005003a 	cmpeq	r2,r2,zero
 90b56f4:	1000441e 	bne	r2,zero,90b5808 <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 90b56f8:	e0bffa17 	ldw	r2,-24(fp)
 90b56fc:	10800058 	cmpnei	r2,r2,1
 90b5700:	1000031e 	bne	r2,zero,90b5710 <tcp_dooptions+0x7c>
         optlen = 1;
 90b5704:	00800044 	movi	r2,1
 90b5708:	e0bff915 	stw	r2,-28(fp)
 90b570c:	00000806 	br	90b5730 <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 90b5710:	e0bffb17 	ldw	r2,-20(fp)
 90b5714:	10800044 	addi	r2,r2,1
 90b5718:	10800003 	ldbu	r2,0(r2)
 90b571c:	10803fcc 	andi	r2,r2,255
 90b5720:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 90b5724:	e0bff917 	ldw	r2,-28(fp)
 90b5728:	10800050 	cmplti	r2,r2,1
 90b572c:	1000361e 	bne	r2,zero,90b5808 <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 90b5730:	e0bffa17 	ldw	r2,-24(fp)
 90b5734:	108000a0 	cmpeqi	r2,r2,2
 90b5738:	1000011e 	bne	r2,zero,90b5740 <tcp_dooptions+0xac>
 90b573c:	00002606 	br	90b57d8 <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 90b5740:	e0bff917 	ldw	r2,-28(fp)
 90b5744:	10800118 	cmpnei	r2,r2,4
 90b5748:	1000231e 	bne	r2,zero,90b57d8 <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 90b574c:	e0bffe17 	ldw	r2,-8(fp)
 90b5750:	10800843 	ldbu	r2,33(r2)
 90b5754:	10803fcc 	andi	r2,r2,255
 90b5758:	1080008c 	andi	r2,r2,2
 90b575c:	1005003a 	cmpeq	r2,r2,zero
 90b5760:	10001d1e 	bne	r2,zero,90b57d8 <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 90b5764:	e0bffb17 	ldw	r2,-20(fp)
 90b5768:	10800084 	addi	r2,r2,2
 90b576c:	1080000b 	ldhu	r2,0(r2)
 90b5770:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 90b5774:	e0bff60b 	ldhu	r2,-40(fp)
 90b5778:	1004d23a 	srli	r2,r2,8
 90b577c:	10803fcc 	andi	r2,r2,255
 90b5780:	1009883a 	mov	r4,r2
 90b5784:	e0bff60b 	ldhu	r2,-40(fp)
 90b5788:	1004923a 	slli	r2,r2,8
 90b578c:	1007883a 	mov	r3,r2
 90b5790:	00bfc004 	movi	r2,-256
 90b5794:	1884703a 	and	r2,r3,r2
 90b5798:	2084b03a 	or	r2,r4,r2
 90b579c:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 90b57a0:	e13ff717 	ldw	r4,-36(fp)
 90b57a4:	90b5c380 	call	90b5c38 <tcp_mss>
 90b57a8:	10ffffcc 	andi	r3,r2,65535
 90b57ac:	e0bff60b 	ldhu	r2,-40(fp)
 90b57b0:	1880042e 	bgeu	r3,r2,90b57c4 <tcp_dooptions+0x130>
 90b57b4:	e13ff717 	ldw	r4,-36(fp)
 90b57b8:	90b5c380 	call	90b5c38 <tcp_mss>
 90b57bc:	e0bfff0d 	sth	r2,-4(fp)
 90b57c0:	00000206 	br	90b57cc <tcp_dooptions+0x138>
 90b57c4:	e0bff60b 	ldhu	r2,-40(fp)
 90b57c8:	e0bfff0d 	sth	r2,-4(fp)
 90b57cc:	e0bffc17 	ldw	r2,-16(fp)
 90b57d0:	e0ffff0b 	ldhu	r3,-4(fp)
 90b57d4:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 90b57d8:	e0fff817 	ldw	r3,-32(fp)
 90b57dc:	e0bff917 	ldw	r2,-28(fp)
 90b57e0:	1885c83a 	sub	r2,r3,r2
 90b57e4:	e0bff815 	stw	r2,-32(fp)
 90b57e8:	e0bff917 	ldw	r2,-28(fp)
 90b57ec:	1007883a 	mov	r3,r2
 90b57f0:	e0bffb17 	ldw	r2,-20(fp)
 90b57f4:	10c5883a 	add	r2,r2,r3
 90b57f8:	e0bffb15 	stw	r2,-20(fp)
 90b57fc:	e0bff817 	ldw	r2,-32(fp)
 90b5800:	10800048 	cmpgei	r2,r2,1
 90b5804:	103fb51e 	bne	r2,zero,90b56dc <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 90b5808:	e13ffd17 	ldw	r4,-12(fp)
 90b580c:	90ab4600 	call	90ab460 <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 90b5810:	e037883a 	mov	sp,fp
 90b5814:	dfc00117 	ldw	ra,4(sp)
 90b5818:	df000017 	ldw	fp,0(sp)
 90b581c:	dec00204 	addi	sp,sp,8
 90b5820:	f800283a 	ret

090b5824 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 90b5824:	defff804 	addi	sp,sp,-32
 90b5828:	dfc00715 	stw	ra,28(sp)
 90b582c:	df000615 	stw	fp,24(sp)
 90b5830:	df000604 	addi	fp,sp,24
 90b5834:	e13ffd15 	stw	r4,-12(fp)
 90b5838:	e17ffe15 	stw	r5,-8(fp)
 90b583c:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 90b5840:	e0bffe17 	ldw	r2,-8(fp)
 90b5844:	1080098b 	ldhu	r2,38(r2)
 90b5848:	10bfffcc 	andi	r2,r2,65535
 90b584c:	10bfffc4 	addi	r2,r2,-1
 90b5850:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 90b5854:	00003306 	br	90b5924 <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 90b5858:	e0bfff17 	ldw	r2,-4(fp)
 90b585c:	10c00217 	ldw	r3,8(r2)
 90b5860:	e0bffc17 	ldw	r2,-16(fp)
 90b5864:	10c0242e 	bgeu	r2,r3,90b58f8 <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 90b5868:	e0bfff17 	ldw	r2,-4(fp)
 90b586c:	10c00317 	ldw	r3,12(r2)
 90b5870:	e0bffc17 	ldw	r2,-16(fp)
 90b5874:	1885883a 	add	r2,r3,r2
 90b5878:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 90b587c:	e0bffd17 	ldw	r2,-12(fp)
 90b5880:	10800117 	ldw	r2,4(r2)
 90b5884:	10800917 	ldw	r2,36(r2)
 90b5888:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 90b588c:	e0bffb17 	ldw	r2,-20(fp)
 90b5890:	10c00003 	ldbu	r3,0(r2)
 90b5894:	e0bffa17 	ldw	r2,-24(fp)
 90b5898:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 90b589c:	e0bffa17 	ldw	r2,-24(fp)
 90b58a0:	10802403 	ldbu	r2,144(r2)
 90b58a4:	10800054 	ori	r2,r2,1
 90b58a8:	1007883a 	mov	r3,r2
 90b58ac:	e0bffa17 	ldw	r2,-24(fp)
 90b58b0:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 90b58b4:	e0bffb17 	ldw	r2,-20(fp)
 90b58b8:	11400044 	addi	r5,r2,1
 90b58bc:	e0bfff17 	ldw	r2,-4(fp)
 90b58c0:	10c00217 	ldw	r3,8(r2)
 90b58c4:	e0bffc17 	ldw	r2,-16(fp)
 90b58c8:	1885c83a 	sub	r2,r3,r2
 90b58cc:	10ffffc4 	addi	r3,r2,-1
 90b58d0:	e0bffb17 	ldw	r2,-20(fp)
 90b58d4:	1009883a 	mov	r4,r2
 90b58d8:	180d883a 	mov	r6,r3
 90b58dc:	90894600 	call	9089460 <memcpy>
         m->m_len--;
 90b58e0:	e0bfff17 	ldw	r2,-4(fp)
 90b58e4:	10800217 	ldw	r2,8(r2)
 90b58e8:	10ffffc4 	addi	r3,r2,-1
 90b58ec:	e0bfff17 	ldw	r2,-4(fp)
 90b58f0:	10c00215 	stw	r3,8(r2)
         return;
 90b58f4:	00001106 	br	90b593c <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 90b58f8:	e0fffc17 	ldw	r3,-16(fp)
 90b58fc:	e0bfff17 	ldw	r2,-4(fp)
 90b5900:	10800217 	ldw	r2,8(r2)
 90b5904:	1885c83a 	sub	r2,r3,r2
 90b5908:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 90b590c:	e0bfff17 	ldw	r2,-4(fp)
 90b5910:	10800617 	ldw	r2,24(r2)
 90b5914:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 90b5918:	e0bfff17 	ldw	r2,-4(fp)
 90b591c:	1005003a 	cmpeq	r2,r2,zero
 90b5920:	1000031e 	bne	r2,zero,90b5930 <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 90b5924:	e0bffc17 	ldw	r2,-16(fp)
 90b5928:	1004403a 	cmpge	r2,r2,zero
 90b592c:	103fca1e 	bne	r2,zero,90b5858 <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 90b5930:	01024374 	movhi	r4,2317
 90b5934:	21026704 	addi	r4,r4,2460
 90b5938:	90a537c0 	call	90a537c <panic>
}
 90b593c:	e037883a 	mov	sp,fp
 90b5940:	dfc00117 	ldw	ra,4(sp)
 90b5944:	df000017 	ldw	fp,0(sp)
 90b5948:	dec00204 	addi	sp,sp,8
 90b594c:	f800283a 	ret

090b5950 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 90b5950:	defffb04 	addi	sp,sp,-20
 90b5954:	dfc00415 	stw	ra,16(sp)
 90b5958:	df000315 	stw	fp,12(sp)
 90b595c:	df000304 	addi	fp,sp,12
 90b5960:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 90b5964:	e0bfff17 	ldw	r2,-4(fp)
 90b5968:	10801e17 	ldw	r2,120(r2)
 90b596c:	1004c03a 	cmpne	r2,r2,zero
 90b5970:	1000021e 	bne	r2,zero,90b597c <tcp_xmit_timer+0x2c>
 90b5974:	90aa4780 	call	90aa478 <dtrap>
 90b5978:	00009806 	br	90b5bdc <tcp_xmit_timer+0x28c>
#endif

   tcpstat.tcps_rttupdated++;
 90b597c:	008243b4 	movhi	r2,2318
 90b5980:	10b75604 	addi	r2,r2,-8872
 90b5984:	10800717 	ldw	r2,28(r2)
 90b5988:	10c00044 	addi	r3,r2,1
 90b598c:	008243b4 	movhi	r2,2318
 90b5990:	10b75604 	addi	r2,r2,-8872
 90b5994:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 90b5998:	00824374 	movhi	r2,2317
 90b599c:	108f2e04 	addi	r2,r2,15544
 90b59a0:	10c00017 	ldw	r3,0(r2)
 90b59a4:	e0bfff17 	ldw	r2,-4(fp)
 90b59a8:	10801e17 	ldw	r2,120(r2)
 90b59ac:	1889c83a 	sub	r4,r3,r2
 90b59b0:	908d0380 	call	908d038 <__floatunsidf>
 90b59b4:	100b883a 	mov	r5,r2
 90b59b8:	180d883a 	mov	r6,r3
 90b59bc:	2809883a 	mov	r4,r5
 90b59c0:	300b883a 	mov	r5,r6
 90b59c4:	000d883a 	mov	r6,zero
 90b59c8:	01d01274 	movhi	r7,16457
 90b59cc:	908c9680 	call	908c968 <__divdf3>
 90b59d0:	1009883a 	mov	r4,r2
 90b59d4:	180b883a 	mov	r5,r3
 90b59d8:	2005883a 	mov	r2,r4
 90b59dc:	2807883a 	mov	r3,r5
 90b59e0:	1009883a 	mov	r4,r2
 90b59e4:	180b883a 	mov	r5,r3
 90b59e8:	908cf600 	call	908cf60 <__fixdfsi>
 90b59ec:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 90b59f0:	e0bfff17 	ldw	r2,-4(fp)
 90b59f4:	10802017 	ldw	r2,128(r2)
 90b59f8:	1005003a 	cmpeq	r2,r2,zero
 90b59fc:	10004a1e 	bne	r2,zero,90b5b28 <tcp_xmit_timer+0x1d8>
   {
      if(rtt == 0)      /* fast path for small round trip */
 90b5a00:	e0bffd17 	ldw	r2,-12(fp)
 90b5a04:	1004c03a 	cmpne	r2,r2,zero
 90b5a08:	1000131e 	bne	r2,zero,90b5a58 <tcp_xmit_timer+0x108>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 90b5a0c:	e0bfff17 	ldw	r2,-4(fp)
 90b5a10:	10802017 	ldw	r2,128(r2)
 90b5a14:	10800090 	cmplti	r2,r2,2
 90b5a18:	1000051e 	bne	r2,zero,90b5a30 <tcp_xmit_timer+0xe0>
            tp->t_srtt--;
 90b5a1c:	e0bfff17 	ldw	r2,-4(fp)
 90b5a20:	10802017 	ldw	r2,128(r2)
 90b5a24:	10ffffc4 	addi	r3,r2,-1
 90b5a28:	e0bfff17 	ldw	r2,-4(fp)
 90b5a2c:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 90b5a30:	e0bfff17 	ldw	r2,-4(fp)
 90b5a34:	10802117 	ldw	r2,132(r2)
 90b5a38:	10800090 	cmplti	r2,r2,2
 90b5a3c:	1000481e 	bne	r2,zero,90b5b60 <tcp_xmit_timer+0x210>
            tp->t_rttvar--;
 90b5a40:	e0bfff17 	ldw	r2,-4(fp)
 90b5a44:	10802117 	ldw	r2,132(r2)
 90b5a48:	10ffffc4 	addi	r3,r2,-1
 90b5a4c:	e0bfff17 	ldw	r2,-4(fp)
 90b5a50:	10c02115 	stw	r3,132(r2)
 90b5a54:	00004206 	br	90b5b60 <tcp_xmit_timer+0x210>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 90b5a58:	e0bffd17 	ldw	r2,-12(fp)
 90b5a5c:	10bfffc4 	addi	r2,r2,-1
 90b5a60:	1085883a 	add	r2,r2,r2
 90b5a64:	1085883a 	add	r2,r2,r2
 90b5a68:	1007883a 	mov	r3,r2
 90b5a6c:	e0bfff17 	ldw	r2,-4(fp)
 90b5a70:	10802017 	ldw	r2,128(r2)
 90b5a74:	1005d0fa 	srai	r2,r2,3
 90b5a78:	1885c83a 	sub	r2,r3,r2
 90b5a7c:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 90b5a80:	e0bfff17 	ldw	r2,-4(fp)
 90b5a84:	10c02017 	ldw	r3,128(r2)
 90b5a88:	e0bffe17 	ldw	r2,-8(fp)
 90b5a8c:	1887883a 	add	r3,r3,r2
 90b5a90:	e0bfff17 	ldw	r2,-4(fp)
 90b5a94:	10c02015 	stw	r3,128(r2)
 90b5a98:	e0bfff17 	ldw	r2,-4(fp)
 90b5a9c:	10802017 	ldw	r2,128(r2)
 90b5aa0:	10800048 	cmpgei	r2,r2,1
 90b5aa4:	1000031e 	bne	r2,zero,90b5ab4 <tcp_xmit_timer+0x164>
         tp->t_srtt = 1;
 90b5aa8:	e0ffff17 	ldw	r3,-4(fp)
 90b5aac:	00800044 	movi	r2,1
 90b5ab0:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 90b5ab4:	e0bffe17 	ldw	r2,-8(fp)
 90b5ab8:	1004403a 	cmpge	r2,r2,zero
 90b5abc:	1000031e 	bne	r2,zero,90b5acc <tcp_xmit_timer+0x17c>
         delta = -delta;
 90b5ac0:	e0bffe17 	ldw	r2,-8(fp)
 90b5ac4:	0085c83a 	sub	r2,zero,r2
 90b5ac8:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 90b5acc:	e0bfff17 	ldw	r2,-4(fp)
 90b5ad0:	10802117 	ldw	r2,132(r2)
 90b5ad4:	1005d07a 	srai	r2,r2,1
 90b5ad8:	10ffffcc 	andi	r3,r2,65535
 90b5adc:	18e0001c 	xori	r3,r3,32768
 90b5ae0:	18e00004 	addi	r3,r3,-32768
 90b5ae4:	e0bffe17 	ldw	r2,-8(fp)
 90b5ae8:	10c5c83a 	sub	r2,r2,r3
 90b5aec:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 90b5af0:	e0bfff17 	ldw	r2,-4(fp)
 90b5af4:	10c02117 	ldw	r3,132(r2)
 90b5af8:	e0bffe17 	ldw	r2,-8(fp)
 90b5afc:	1887883a 	add	r3,r3,r2
 90b5b00:	e0bfff17 	ldw	r2,-4(fp)
 90b5b04:	10c02115 	stw	r3,132(r2)
 90b5b08:	e0bfff17 	ldw	r2,-4(fp)
 90b5b0c:	10802117 	ldw	r2,132(r2)
 90b5b10:	10800048 	cmpgei	r2,r2,1
 90b5b14:	1000121e 	bne	r2,zero,90b5b60 <tcp_xmit_timer+0x210>
         tp->t_rttvar = 1;
 90b5b18:	e0ffff17 	ldw	r3,-4(fp)
 90b5b1c:	00800044 	movi	r2,1
 90b5b20:	18802115 	stw	r2,132(r3)
 90b5b24:	00000e06 	br	90b5b60 <tcp_xmit_timer+0x210>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 90b5b28:	e0bffd17 	ldw	r2,-12(fp)
 90b5b2c:	10800048 	cmpgei	r2,r2,1
 90b5b30:	1000021e 	bne	r2,zero,90b5b3c <tcp_xmit_timer+0x1ec>
         rtt = 1;
 90b5b34:	00800044 	movi	r2,1
 90b5b38:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 90b5b3c:	e0bffd17 	ldw	r2,-12(fp)
 90b5b40:	100690fa 	slli	r3,r2,3
 90b5b44:	e0bfff17 	ldw	r2,-4(fp)
 90b5b48:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 90b5b4c:	e0bffd17 	ldw	r2,-12(fp)
 90b5b50:	1085883a 	add	r2,r2,r2
 90b5b54:	1007883a 	mov	r3,r2
 90b5b58:	e0bfff17 	ldw	r2,-4(fp)
 90b5b5c:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 90b5b60:	e0bfff17 	ldw	r2,-4(fp)
 90b5b64:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 90b5b68:	e0bfff17 	ldw	r2,-4(fp)
 90b5b6c:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 90b5b70:	e0bfff17 	ldw	r2,-4(fp)
 90b5b74:	10802017 	ldw	r2,128(r2)
 90b5b78:	1007d0ba 	srai	r3,r2,2
 90b5b7c:	e0bfff17 	ldw	r2,-4(fp)
 90b5b80:	10802117 	ldw	r2,132(r2)
 90b5b84:	1885883a 	add	r2,r3,r2
 90b5b88:	1005d07a 	srai	r2,r2,1
 90b5b8c:	10ffffcc 	andi	r3,r2,65535
 90b5b90:	18e0001c 	xori	r3,r3,32768
 90b5b94:	18e00004 	addi	r3,r3,-32768
 90b5b98:	e0bfff17 	ldw	r2,-4(fp)
 90b5b9c:	10c00815 	stw	r3,32(r2)
 90b5ba0:	e0bfff17 	ldw	r2,-4(fp)
 90b5ba4:	10800817 	ldw	r2,32(r2)
 90b5ba8:	10800088 	cmpgei	r2,r2,2
 90b5bac:	1000041e 	bne	r2,zero,90b5bc0 <tcp_xmit_timer+0x270>
 90b5bb0:	e0ffff17 	ldw	r3,-4(fp)
 90b5bb4:	00800084 	movi	r2,2
 90b5bb8:	18800815 	stw	r2,32(r3)
 90b5bbc:	00000706 	br	90b5bdc <tcp_xmit_timer+0x28c>
 90b5bc0:	e0bfff17 	ldw	r2,-4(fp)
 90b5bc4:	10800817 	ldw	r2,32(r2)
 90b5bc8:	10802050 	cmplti	r2,r2,129
 90b5bcc:	1000031e 	bne	r2,zero,90b5bdc <tcp_xmit_timer+0x28c>
 90b5bd0:	e0ffff17 	ldw	r3,-4(fp)
 90b5bd4:	00802004 	movi	r2,128
 90b5bd8:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 90b5bdc:	e037883a 	mov	sp,fp
 90b5be0:	dfc00117 	ldw	ra,4(sp)
 90b5be4:	df000017 	ldw	fp,0(sp)
 90b5be8:	dec00204 	addi	sp,sp,8
 90b5bec:	f800283a 	ret

090b5bf0 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 90b5bf0:	defffd04 	addi	sp,sp,-12
 90b5bf4:	df000215 	stw	fp,8(sp)
 90b5bf8:	df000204 	addi	fp,sp,8
 90b5bfc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 90b5c00:	e0bfff17 	ldw	r2,-4(fp)
 90b5c04:	10800117 	ldw	r2,4(r2)
 90b5c08:	10800a17 	ldw	r2,40(r2)
 90b5c0c:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 90b5c10:	e0bffe17 	ldw	r2,-8(fp)
 90b5c14:	10c00917 	ldw	r3,36(r2)
 90b5c18:	e0bffe17 	ldw	r2,-8(fp)
 90b5c1c:	10800817 	ldw	r2,32(r2)
 90b5c20:	1885c83a 	sub	r2,r3,r2
 90b5c24:	10bff604 	addi	r2,r2,-40
}
 90b5c28:	e037883a 	mov	sp,fp
 90b5c2c:	df000017 	ldw	fp,0(sp)
 90b5c30:	dec00104 	addi	sp,sp,4
 90b5c34:	f800283a 	ret

090b5c38 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 90b5c38:	defff904 	addi	sp,sp,-28
 90b5c3c:	dfc00615 	stw	ra,24(sp)
 90b5c40:	df000515 	stw	fp,20(sp)
 90b5c44:	df000504 	addi	fp,sp,20
 90b5c48:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 90b5c4c:	e0bffe17 	ldw	r2,-8(fp)
 90b5c50:	1005003a 	cmpeq	r2,r2,zero
 90b5c54:	1000091e 	bne	r2,zero,90b5c7c <tcp_mss+0x44>
 90b5c58:	e0bffe17 	ldw	r2,-8(fp)
 90b5c5c:	10800117 	ldw	r2,4(r2)
 90b5c60:	1005003a 	cmpeq	r2,r2,zero
 90b5c64:	1000051e 	bne	r2,zero,90b5c7c <tcp_mss+0x44>
 90b5c68:	e0bffe17 	ldw	r2,-8(fp)
 90b5c6c:	10800117 	ldw	r2,4(r2)
 90b5c70:	10800a17 	ldw	r2,40(r2)
 90b5c74:	1004c03a 	cmpne	r2,r2,zero
 90b5c78:	1000071e 	bne	r2,zero,90b5c98 <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 90b5c7c:	e0bffe17 	ldw	r2,-8(fp)
 90b5c80:	10800517 	ldw	r2,20(r2)
 90b5c84:	10800098 	cmpnei	r2,r2,2
 90b5c88:	1000031e 	bne	r2,zero,90b5c98 <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 90b5c8c:	00816d04 	movi	r2,1460
 90b5c90:	e0bfff15 	stw	r2,-4(fp)
 90b5c94:	00002906 	br	90b5d3c <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 90b5c98:	e13ffe17 	ldw	r4,-8(fp)
 90b5c9c:	90b5bf00 	call	90b5bf0 <ip4_tcpmss>
 90b5ca0:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 90b5ca4:	e0bffd17 	ldw	r2,-12(fp)
 90b5ca8:	10816d50 	cmplti	r2,r2,1461
 90b5cac:	1000021e 	bne	r2,zero,90b5cb8 <tcp_mss+0x80>
      mss = TCP_MSS;
 90b5cb0:	00816d04 	movi	r2,1460
 90b5cb4:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 90b5cb8:	e0bffe17 	ldw	r2,-8(fp)
 90b5cbc:	10800117 	ldw	r2,4(r2)
 90b5cc0:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 90b5cc4:	e0bffc17 	ldw	r2,-16(fp)
 90b5cc8:	10800917 	ldw	r2,36(r2)
 90b5ccc:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 90b5cd0:	e0bffb17 	ldw	r2,-20(fp)
 90b5cd4:	10800b0b 	ldhu	r2,44(r2)
 90b5cd8:	10bfffcc 	andi	r2,r2,65535
 90b5cdc:	1081000c 	andi	r2,r2,1024
 90b5ce0:	1005003a 	cmpeq	r2,r2,zero
 90b5ce4:	1000051e 	bne	r2,zero,90b5cfc <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 90b5ce8:	e0bffb17 	ldw	r2,-20(fp)
 90b5cec:	10800a0b 	ldhu	r2,40(r2)
 90b5cf0:	10bfffcc 	andi	r2,r2,65535
 90b5cf4:	e0bfff15 	stw	r2,-4(fp)
 90b5cf8:	00001006 	br	90b5d3c <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 90b5cfc:	e0bffb17 	ldw	r2,-20(fp)
 90b5d00:	10800a0b 	ldhu	r2,40(r2)
 90b5d04:	10bfffcc 	andi	r2,r2,65535
 90b5d08:	1005003a 	cmpeq	r2,r2,zero
 90b5d0c:	1000091e 	bne	r2,zero,90b5d34 <tcp_mss+0xfc>
 90b5d10:	e0bffb17 	ldw	r2,-20(fp)
 90b5d14:	10800a0b 	ldhu	r2,40(r2)
 90b5d18:	10ffffcc 	andi	r3,r2,65535
 90b5d1c:	e0bffd17 	ldw	r2,-12(fp)
 90b5d20:	1880040e 	bge	r3,r2,90b5d34 <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 90b5d24:	e0bffb17 	ldw	r2,-20(fp)
 90b5d28:	10800a0b 	ldhu	r2,40(r2)
 90b5d2c:	10bfffcc 	andi	r2,r2,65535
 90b5d30:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 90b5d34:	e0bffd17 	ldw	r2,-12(fp)
 90b5d38:	e0bfff15 	stw	r2,-4(fp)
 90b5d3c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b5d40:	e037883a 	mov	sp,fp
 90b5d44:	dfc00117 	ldw	ra,4(sp)
 90b5d48:	df000017 	ldw	fp,0(sp)
 90b5d4c:	dec00204 	addi	sp,sp,8
 90b5d50:	f800283a 	ret

090b5d54 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 90b5d54:	deffe004 	addi	sp,sp,-128
 90b5d58:	dfc01f15 	stw	ra,124(sp)
 90b5d5c:	df001e15 	stw	fp,120(sp)
 90b5d60:	df001e04 	addi	fp,sp,120
 90b5d64:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b5d68:	e0bff717 	ldw	r2,-36(fp)
 90b5d6c:	10800d17 	ldw	r2,52(r2)
 90b5d70:	10800817 	ldw	r2,32(r2)
 90b5d74:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 90b5d78:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 90b5d7c:	e0bff717 	ldw	r2,-36(fp)
 90b5d80:	10c01a17 	ldw	r3,104(r2)
 90b5d84:	e0bff717 	ldw	r2,-36(fp)
 90b5d88:	10800e17 	ldw	r2,56(r2)
 90b5d8c:	1885003a 	cmpeq	r2,r3,r2
 90b5d90:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 90b5d94:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 90b5d98:	e0bff717 	ldw	r2,-36(fp)
 90b5d9c:	10c00f17 	ldw	r3,60(r2)
 90b5da0:	e0bff717 	ldw	r2,-36(fp)
 90b5da4:	10800e17 	ldw	r2,56(r2)
 90b5da8:	1885c83a 	sub	r2,r3,r2
 90b5dac:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 90b5db0:	e0bff717 	ldw	r2,-36(fp)
 90b5db4:	10801417 	ldw	r2,80(r2)
 90b5db8:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 90b5dbc:	e0bff717 	ldw	r2,-36(fp)
 90b5dc0:	10801b17 	ldw	r2,108(r2)
 90b5dc4:	1007883a 	mov	r3,r2
 90b5dc8:	e0bff317 	ldw	r2,-52(fp)
 90b5dcc:	1880060e 	bge	r3,r2,90b5de8 <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 90b5dd0:	e0bff717 	ldw	r2,-36(fp)
 90b5dd4:	10801b17 	ldw	r2,108(r2)
 90b5dd8:	1007883a 	mov	r3,r2
 90b5ddc:	00bfff04 	movi	r2,-4
 90b5de0:	1884703a 	and	r2,r3,r2
 90b5de4:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 90b5de8:	e0bff717 	ldw	r2,-36(fp)
 90b5dec:	10800a83 	ldbu	r2,42(r2)
 90b5df0:	10803fcc 	andi	r2,r2,255
 90b5df4:	1080201c 	xori	r2,r2,128
 90b5df8:	10bfe004 	addi	r2,r2,-128
 90b5dfc:	1005003a 	cmpeq	r2,r2,zero
 90b5e00:	10000a1e 	bne	r2,zero,90b5e2c <tcp_output+0xd8>
   {
      if (win == 0)
 90b5e04:	e0bff317 	ldw	r2,-52(fp)
 90b5e08:	1004c03a 	cmpne	r2,r2,zero
 90b5e0c:	1000031e 	bne	r2,zero,90b5e1c <tcp_output+0xc8>
         win = 1;
 90b5e10:	00800044 	movi	r2,1
 90b5e14:	e0bff315 	stw	r2,-52(fp)
 90b5e18:	00000406 	br	90b5e2c <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 90b5e1c:	e0bff717 	ldw	r2,-36(fp)
 90b5e20:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 90b5e24:	e0bff717 	ldw	r2,-36(fp)
 90b5e28:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 90b5e2c:	e0bff517 	ldw	r2,-44(fp)
 90b5e30:	10801217 	ldw	r2,72(r2)
 90b5e34:	e0fff317 	ldw	r3,-52(fp)
 90b5e38:	e0fffb15 	stw	r3,-20(fp)
 90b5e3c:	e0bffa15 	stw	r2,-24(fp)
 90b5e40:	e0bffb17 	ldw	r2,-20(fp)
 90b5e44:	e0fffa17 	ldw	r3,-24(fp)
 90b5e48:	10c0022e 	bgeu	r2,r3,90b5e54 <tcp_output+0x100>
 90b5e4c:	e0bffb17 	ldw	r2,-20(fp)
 90b5e50:	e0bffa15 	stw	r2,-24(fp)
 90b5e54:	e0fffa17 	ldw	r3,-24(fp)
 90b5e58:	e0bff217 	ldw	r2,-56(fp)
 90b5e5c:	1885c83a 	sub	r2,r3,r2
 90b5e60:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 90b5e64:	e0bff717 	ldw	r2,-36(fp)
 90b5e68:	10c00217 	ldw	r3,8(r2)
 90b5e6c:	00824374 	movhi	r2,2317
 90b5e70:	108db104 	addi	r2,r2,14020
 90b5e74:	10c5883a 	add	r2,r2,r3
 90b5e78:	10800003 	ldbu	r2,0(r2)
 90b5e7c:	10803fcc 	andi	r2,r2,255
 90b5e80:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 90b5e84:	e0bff117 	ldw	r2,-60(fp)
 90b5e88:	1080008c 	andi	r2,r2,2
 90b5e8c:	1005003a 	cmpeq	r2,r2,zero
 90b5e90:	1000081e 	bne	r2,zero,90b5eb4 <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 90b5e94:	e0ffed17 	ldw	r3,-76(fp)
 90b5e98:	d0a0b404 	addi	r2,gp,-32048
 90b5e9c:	188b883a 	add	r5,r3,r2
 90b5ea0:	e13ff717 	ldw	r4,-36(fp)
 90b5ea4:	e1bff117 	ldw	r6,-60(fp)
 90b5ea8:	e1fff517 	ldw	r7,-44(fp)
 90b5eac:	90b6fcc0 	call	90b6fcc <bld_options>
 90b5eb0:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 90b5eb4:	e0bff417 	ldw	r2,-48(fp)
 90b5eb8:	1004403a 	cmpge	r2,r2,zero
 90b5ebc:	10000a1e 	bne	r2,zero,90b5ee8 <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 90b5ec0:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 90b5ec4:	e0bff317 	ldw	r2,-52(fp)
 90b5ec8:	1004c03a 	cmpne	r2,r2,zero
 90b5ecc:	1000061e 	bne	r2,zero,90b5ee8 <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 90b5ed0:	e0bff717 	ldw	r2,-36(fp)
 90b5ed4:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 90b5ed8:	e0bff717 	ldw	r2,-36(fp)
 90b5edc:	10c00e17 	ldw	r3,56(r2)
 90b5ee0:	e0bff717 	ldw	r2,-36(fp)
 90b5ee4:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 90b5ee8:	e0bff717 	ldw	r2,-36(fp)
 90b5eec:	10800a0b 	ldhu	r2,40(r2)
 90b5ef0:	10ffffcc 	andi	r3,r2,65535
 90b5ef4:	e0bff417 	ldw	r2,-48(fp)
 90b5ef8:	1880060e 	bge	r3,r2,90b5f14 <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 90b5efc:	e0bff717 	ldw	r2,-36(fp)
 90b5f00:	10800a0b 	ldhu	r2,40(r2)
 90b5f04:	10bfffcc 	andi	r2,r2,65535
 90b5f08:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 90b5f0c:	00800044 	movi	r2,1
 90b5f10:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 90b5f14:	e0bff717 	ldw	r2,-36(fp)
 90b5f18:	10c00f17 	ldw	r3,60(r2)
 90b5f1c:	e0bff417 	ldw	r2,-48(fp)
 90b5f20:	1889883a 	add	r4,r3,r2
 90b5f24:	e0bff717 	ldw	r2,-36(fp)
 90b5f28:	10c00e17 	ldw	r3,56(r2)
 90b5f2c:	e0bff517 	ldw	r2,-44(fp)
 90b5f30:	10801217 	ldw	r2,72(r2)
 90b5f34:	1885883a 	add	r2,r3,r2
 90b5f38:	2085c83a 	sub	r2,r4,r2
 90b5f3c:	1004403a 	cmpge	r2,r2,zero
 90b5f40:	1000041e 	bne	r2,zero,90b5f54 <tcp_output+0x200>
      flags &= ~TH_FIN;
 90b5f44:	e0bff117 	ldw	r2,-60(fp)
 90b5f48:	00ffff84 	movi	r3,-2
 90b5f4c:	10c4703a 	and	r2,r2,r3
 90b5f50:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 90b5f54:	e0bff517 	ldw	r2,-44(fp)
 90b5f58:	10800b17 	ldw	r2,44(r2)
 90b5f5c:	1007883a 	mov	r3,r2
 90b5f60:	e0bff517 	ldw	r2,-44(fp)
 90b5f64:	10800a17 	ldw	r2,40(r2)
 90b5f68:	1885c83a 	sub	r2,r3,r2
 90b5f6c:	1004803a 	cmplt	r2,r2,zero
 90b5f70:	1000071e 	bne	r2,zero,90b5f90 <tcp_output+0x23c>
 90b5f74:	e0bff517 	ldw	r2,-44(fp)
 90b5f78:	10c00b17 	ldw	r3,44(r2)
 90b5f7c:	e0bff517 	ldw	r2,-44(fp)
 90b5f80:	10800a17 	ldw	r2,40(r2)
 90b5f84:	1885c83a 	sub	r2,r3,r2
 90b5f88:	e0bff915 	stw	r2,-28(fp)
 90b5f8c:	00000106 	br	90b5f94 <tcp_output+0x240>
 90b5f90:	e03ff915 	stw	zero,-28(fp)
 90b5f94:	e0fff917 	ldw	r3,-28(fp)
 90b5f98:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 90b5f9c:	e0bff117 	ldw	r2,-60(fp)
 90b5fa0:	1080004c 	andi	r2,r2,1
 90b5fa4:	10803fcc 	andi	r2,r2,255
 90b5fa8:	1005003a 	cmpeq	r2,r2,zero
 90b5fac:	10000f1e 	bne	r2,zero,90b5fec <tcp_output+0x298>
 90b5fb0:	e0bff517 	ldw	r2,-44(fp)
 90b5fb4:	10801217 	ldw	r2,72(r2)
 90b5fb8:	1004c03a 	cmpne	r2,r2,zero
 90b5fbc:	10000b1e 	bne	r2,zero,90b5fec <tcp_output+0x298>
 90b5fc0:	e0bff717 	ldw	r2,-36(fp)
 90b5fc4:	10800b0b 	ldhu	r2,44(r2)
 90b5fc8:	10bfffcc 	andi	r2,r2,65535
 90b5fcc:	1080040c 	andi	r2,r2,16
 90b5fd0:	1005003a 	cmpeq	r2,r2,zero
 90b5fd4:	1000721e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
 90b5fd8:	e0bff717 	ldw	r2,-36(fp)
 90b5fdc:	10c00f17 	ldw	r3,60(r2)
 90b5fe0:	e0bff717 	ldw	r2,-36(fp)
 90b5fe4:	10800e17 	ldw	r2,56(r2)
 90b5fe8:	18806d26 	beq	r3,r2,90b61a0 <tcp_output+0x44c>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 90b5fec:	e0bff717 	ldw	r2,-36(fp)
 90b5ff0:	10800b0b 	ldhu	r2,44(r2)
 90b5ff4:	10bfffcc 	andi	r2,r2,65535
 90b5ff8:	1080004c 	andi	r2,r2,1
 90b5ffc:	10803fcc 	andi	r2,r2,255
 90b6000:	1004c03a 	cmpne	r2,r2,zero
 90b6004:	1000661e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 90b6008:	e0bff117 	ldw	r2,-60(fp)
 90b600c:	1080018c 	andi	r2,r2,6
 90b6010:	1004c03a 	cmpne	r2,r2,zero
 90b6014:	1000621e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 90b6018:	e0bff717 	ldw	r2,-36(fp)
 90b601c:	10c01017 	ldw	r3,64(r2)
 90b6020:	e0bff717 	ldw	r2,-36(fp)
 90b6024:	10800e17 	ldw	r2,56(r2)
 90b6028:	1885c83a 	sub	r2,r3,r2
 90b602c:	10800048 	cmpgei	r2,r2,1
 90b6030:	10005b1e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 90b6034:	e0bff417 	ldw	r2,-48(fp)
 90b6038:	1005003a 	cmpeq	r2,r2,zero
 90b603c:	1000281e 	bne	r2,zero,90b60e0 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 90b6040:	e0bff717 	ldw	r2,-36(fp)
 90b6044:	10800a0b 	ldhu	r2,40(r2)
 90b6048:	10ffffcc 	andi	r3,r2,65535
 90b604c:	e0bff417 	ldw	r2,-48(fp)
 90b6050:	18805326 	beq	r3,r2,90b61a0 <tcp_output+0x44c>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 90b6054:	e0bfec17 	ldw	r2,-80(fp)
 90b6058:	1004c03a 	cmpne	r2,r2,zero
 90b605c:	1000061e 	bne	r2,zero,90b6078 <tcp_output+0x324>
 90b6060:	e0bff717 	ldw	r2,-36(fp)
 90b6064:	10800b0b 	ldhu	r2,44(r2)
 90b6068:	10bfffcc 	andi	r2,r2,65535
 90b606c:	1080010c 	andi	r2,r2,4
 90b6070:	1005003a 	cmpeq	r2,r2,zero
 90b6074:	1000061e 	bne	r2,zero,90b6090 <tcp_output+0x33c>
 90b6078:	e0fff417 	ldw	r3,-48(fp)
 90b607c:	e0bff217 	ldw	r2,-56(fp)
 90b6080:	1887883a 	add	r3,r3,r2
 90b6084:	e0bff517 	ldw	r2,-44(fp)
 90b6088:	10801217 	ldw	r2,72(r2)
 90b608c:	1880440e 	bge	r3,r2,90b61a0 <tcp_output+0x44c>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 90b6090:	e0bff717 	ldw	r2,-36(fp)
 90b6094:	10800a83 	ldbu	r2,42(r2)
 90b6098:	10803fcc 	andi	r2,r2,255
 90b609c:	1080201c 	xori	r2,r2,128
 90b60a0:	10bfe004 	addi	r2,r2,-128
 90b60a4:	1004c03a 	cmpne	r2,r2,zero
 90b60a8:	10003d1e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 90b60ac:	e0bff717 	ldw	r2,-36(fp)
 90b60b0:	10802317 	ldw	r2,140(r2)
 90b60b4:	1004d07a 	srli	r2,r2,1
 90b60b8:	1007883a 	mov	r3,r2
 90b60bc:	e0bff417 	ldw	r2,-48(fp)
 90b60c0:	10c0370e 	bge	r2,r3,90b61a0 <tcp_output+0x44c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 90b60c4:	e0bff717 	ldw	r2,-36(fp)
 90b60c8:	10c00f17 	ldw	r3,60(r2)
 90b60cc:	e0bff717 	ldw	r2,-36(fp)
 90b60d0:	10801a17 	ldw	r2,104(r2)
 90b60d4:	1885c83a 	sub	r2,r3,r2
 90b60d8:	1004803a 	cmplt	r2,r2,zero
 90b60dc:	1000301e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 90b60e0:	e0bff317 	ldw	r2,-52(fp)
 90b60e4:	10800050 	cmplti	r2,r2,1
 90b60e8:	10001b1e 	bne	r2,zero,90b6158 <tcp_output+0x404>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 90b60ec:	e0bff717 	ldw	r2,-36(fp)
 90b60f0:	10c01917 	ldw	r3,100(r2)
 90b60f4:	e0bff717 	ldw	r2,-36(fp)
 90b60f8:	10801617 	ldw	r2,88(r2)
 90b60fc:	1885c83a 	sub	r2,r3,r2
 90b6100:	1007883a 	mov	r3,r2
 90b6104:	e0bff317 	ldw	r2,-52(fp)
 90b6108:	10c5c83a 	sub	r2,r2,r3
 90b610c:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 90b6110:	e0bff517 	ldw	r2,-44(fp)
 90b6114:	10800a17 	ldw	r2,40(r2)
 90b6118:	1004c03a 	cmpne	r2,r2,zero
 90b611c:	1000071e 	bne	r2,zero,90b613c <tcp_output+0x3e8>
 90b6120:	e0bff717 	ldw	r2,-36(fp)
 90b6124:	10800a0b 	ldhu	r2,40(r2)
 90b6128:	10bfffcc 	andi	r2,r2,65535
 90b612c:	1085883a 	add	r2,r2,r2
 90b6130:	1007883a 	mov	r3,r2
 90b6134:	e0bfe717 	ldw	r2,-100(fp)
 90b6138:	10c0190e 	bge	r2,r3,90b61a0 <tcp_output+0x44c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 90b613c:	e0bfe717 	ldw	r2,-100(fp)
 90b6140:	10c01924 	muli	r3,r2,100
 90b6144:	e0bff517 	ldw	r2,-44(fp)
 90b6148:	10800b17 	ldw	r2,44(r2)
 90b614c:	1885203a 	divu	r2,r3,r2
 90b6150:	108008e8 	cmpgeui	r2,r2,35
 90b6154:	1000121e 	bne	r2,zero,90b61a0 <tcp_output+0x44c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 90b6158:	e0bff517 	ldw	r2,-44(fp)
 90b615c:	10801217 	ldw	r2,72(r2)
 90b6160:	1005003a 	cmpeq	r2,r2,zero
 90b6164:	10000c1e 	bne	r2,zero,90b6198 <tcp_output+0x444>
 90b6168:	e0bff717 	ldw	r2,-36(fp)
 90b616c:	10800317 	ldw	r2,12(r2)
 90b6170:	1004c03a 	cmpne	r2,r2,zero
 90b6174:	1000081e 	bne	r2,zero,90b6198 <tcp_output+0x444>
 90b6178:	e0bff717 	ldw	r2,-36(fp)
 90b617c:	10800417 	ldw	r2,16(r2)
 90b6180:	1004c03a 	cmpne	r2,r2,zero
 90b6184:	1000041e 	bne	r2,zero,90b6198 <tcp_output+0x444>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 90b6188:	e0bff717 	ldw	r2,-36(fp)
 90b618c:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 90b6190:	e13ff717 	ldw	r4,-36(fp)
 90b6194:	90b6ed00 	call	90b6ed0 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 90b6198:	e03ff815 	stw	zero,-32(fp)
 90b619c:	00034606 	br	90b6eb8 <tcp_output+0x1164>

send:
   ENTER_CRIT_SECTION(tp);
 90b61a0:	90aa6b80 	call	90aa6b8 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 90b61a4:	e0bff217 	ldw	r2,-56(fp)
 90b61a8:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 90b61ac:	e0bff517 	ldw	r2,-44(fp)
 90b61b0:	10801817 	ldw	r2,96(r2)
 90b61b4:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 90b61b8:	e0bff417 	ldw	r2,-48(fp)
 90b61bc:	1005003a 	cmpeq	r2,r2,zero
 90b61c0:	10006b1e 	bne	r2,zero,90b6370 <tcp_output+0x61c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 90b61c4:	00000b06 	br	90b61f4 <tcp_output+0x4a0>
      {
         bufoff -= sendm->m_len;
 90b61c8:	e0ffe817 	ldw	r3,-96(fp)
 90b61cc:	e0bfea17 	ldw	r2,-88(fp)
 90b61d0:	10800217 	ldw	r2,8(r2)
 90b61d4:	1885c83a 	sub	r2,r3,r2
 90b61d8:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 90b61dc:	e0bfe817 	ldw	r2,-96(fp)
 90b61e0:	1004803a 	cmplt	r2,r2,zero
 90b61e4:	1000061e 	bne	r2,zero,90b6200 <tcp_output+0x4ac>
            break;
         sendm = sendm->m_next;
 90b61e8:	e0bfea17 	ldw	r2,-88(fp)
 90b61ec:	10800617 	ldw	r2,24(r2)
 90b61f0:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 90b61f4:	e0bfea17 	ldw	r2,-88(fp)
 90b61f8:	1004c03a 	cmpne	r2,r2,zero
 90b61fc:	103ff21e 	bne	r2,zero,90b61c8 <tcp_output+0x474>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 90b6200:	e0bfea17 	ldw	r2,-88(fp)
 90b6204:	1004c03a 	cmpne	r2,r2,zero
 90b6208:	1000011e 	bne	r2,zero,90b6210 <tcp_output+0x4bc>
 90b620c:	90aa4780 	call	90aa478 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 90b6210:	e0bfea17 	ldw	r2,-88(fp)
 90b6214:	10c00217 	ldw	r3,8(r2)
 90b6218:	e0bfe817 	ldw	r2,-96(fp)
 90b621c:	1885883a 	add	r2,r3,r2
 90b6220:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 90b6224:	e0bfea17 	ldw	r2,-88(fp)
 90b6228:	10800617 	ldw	r2,24(r2)
 90b622c:	1005003a 	cmpeq	r2,r2,zero
 90b6230:	10000b1e 	bne	r2,zero,90b6260 <tcp_output+0x50c>
 90b6234:	e0bfea17 	ldw	r2,-88(fp)
 90b6238:	10800217 	ldw	r2,8(r2)
 90b623c:	1007883a 	mov	r3,r2
 90b6240:	e0bff417 	ldw	r2,-48(fp)
 90b6244:	1880060e 	bge	r3,r2,90b6260 <tcp_output+0x50c>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 90b6248:	e0fff117 	ldw	r3,-60(fp)
 90b624c:	00bfff84 	movi	r2,-2
 90b6250:	1884703a 	and	r2,r3,r2
 90b6254:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 90b6258:	00800044 	movi	r2,1
 90b625c:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 90b6260:	e0bff117 	ldw	r2,-60(fp)
 90b6264:	1080004c 	andi	r2,r2,1
 90b6268:	10803fcc 	andi	r2,r2,255
 90b626c:	1005003a 	cmpeq	r2,r2,zero
 90b6270:	1000081e 	bne	r2,zero,90b6294 <tcp_output+0x540>
 90b6274:	e0bff517 	ldw	r2,-44(fp)
 90b6278:	10c01217 	ldw	r3,72(r2)
 90b627c:	e0bff417 	ldw	r2,-48(fp)
 90b6280:	10c0042e 	bgeu	r2,r3,90b6294 <tcp_output+0x540>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 90b6284:	e0bff117 	ldw	r2,-60(fp)
 90b6288:	00ffff84 	movi	r3,-2
 90b628c:	10c4703a 	and	r2,r2,r3
 90b6290:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 90b6294:	e0bfea17 	ldw	r2,-88(fp)
 90b6298:	10800217 	ldw	r2,8(r2)
 90b629c:	e0fff417 	ldw	r3,-48(fp)
 90b62a0:	e0fffd15 	stw	r3,-12(fp)
 90b62a4:	e0bffc15 	stw	r2,-16(fp)
 90b62a8:	e0bffd17 	ldw	r2,-12(fp)
 90b62ac:	e0fffc17 	ldw	r3,-16(fp)
 90b62b0:	10c0020e 	bge	r2,r3,90b62bc <tcp_output+0x568>
 90b62b4:	e0bffd17 	ldw	r2,-12(fp)
 90b62b8:	e0bffc15 	stw	r2,-16(fp)
 90b62bc:	e0fffc17 	ldw	r3,-16(fp)
 90b62c0:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 90b62c4:	e0bfe817 	ldw	r2,-96(fp)
 90b62c8:	1004c03a 	cmpne	r2,r2,zero
 90b62cc:	1000091e 	bne	r2,zero,90b62f4 <tcp_output+0x5a0>
 90b62d0:	e0bfea17 	ldw	r2,-88(fp)
 90b62d4:	10800317 	ldw	r2,12(r2)
 90b62d8:	1007883a 	mov	r3,r2
 90b62dc:	e0bfea17 	ldw	r2,-88(fp)
 90b62e0:	10800417 	ldw	r2,16(r2)
 90b62e4:	1885c83a 	sub	r2,r3,r2
 90b62e8:	108000cc 	andi	r2,r2,3
 90b62ec:	1005003a 	cmpeq	r2,r2,zero
 90b62f0:	10001f1e 	bne	r2,zero,90b6370 <tcp_output+0x61c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 90b62f4:	e0bfea17 	ldw	r2,-88(fp)
 90b62f8:	10c00217 	ldw	r3,8(r2)
 90b62fc:	e0bfe817 	ldw	r2,-96(fp)
 90b6300:	1885c83a 	sub	r2,r3,r2
 90b6304:	e0fff417 	ldw	r3,-48(fp)
 90b6308:	e0ffff15 	stw	r3,-4(fp)
 90b630c:	e0bffe15 	stw	r2,-8(fp)
 90b6310:	e0bfff17 	ldw	r2,-4(fp)
 90b6314:	e0fffe17 	ldw	r3,-8(fp)
 90b6318:	10c0020e 	bge	r2,r3,90b6324 <tcp_output+0x5d0>
 90b631c:	e0bfff17 	ldw	r2,-4(fp)
 90b6320:	e0bffe15 	stw	r2,-8(fp)
 90b6324:	e0fffe17 	ldw	r3,-8(fp)
 90b6328:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 90b632c:	00824374 	movhi	r2,2317
 90b6330:	108eba04 	addi	r2,r2,15080
 90b6334:	10800017 	ldw	r2,0(r2)
 90b6338:	10bff204 	addi	r2,r2,-56
 90b633c:	1007883a 	mov	r3,r2
 90b6340:	e0bff417 	ldw	r2,-48(fp)
 90b6344:	18800a0e 	bge	r3,r2,90b6370 <tcp_output+0x61c>
 90b6348:	008243b4 	movhi	r2,2318
 90b634c:	10b68d04 	addi	r2,r2,-9676
 90b6350:	10800217 	ldw	r2,8(r2)
 90b6354:	10800088 	cmpgei	r2,r2,2
 90b6358:	1000051e 	bne	r2,zero,90b6370 <tcp_output+0x61c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 90b635c:	00824374 	movhi	r2,2317
 90b6360:	108eba04 	addi	r2,r2,15080
 90b6364:	10800017 	ldw	r2,0(r2)
 90b6368:	10bff204 	addi	r2,r2,-56
 90b636c:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 90b6370:	e0bff417 	ldw	r2,-48(fp)
 90b6374:	1005003a 	cmpeq	r2,r2,zero
 90b6378:	10003b1e 	bne	r2,zero,90b6468 <tcp_output+0x714>
 90b637c:	e0bfe817 	ldw	r2,-96(fp)
 90b6380:	1004c03a 	cmpne	r2,r2,zero
 90b6384:	1000381e 	bne	r2,zero,90b6468 <tcp_output+0x714>
 90b6388:	e0bfea17 	ldw	r2,-88(fp)
 90b638c:	10800117 	ldw	r2,4(r2)
 90b6390:	10800917 	ldw	r2,36(r2)
 90b6394:	10800058 	cmpnei	r2,r2,1
 90b6398:	1000331e 	bne	r2,zero,90b6468 <tcp_output+0x714>
 90b639c:	e0bfea17 	ldw	r2,-88(fp)
 90b63a0:	10800317 	ldw	r2,12(r2)
 90b63a4:	1007883a 	mov	r3,r2
 90b63a8:	e0bfea17 	ldw	r2,-88(fp)
 90b63ac:	10800417 	ldw	r2,16(r2)
 90b63b0:	1885c83a 	sub	r2,r3,r2
 90b63b4:	108000cc 	andi	r2,r2,3
 90b63b8:	1004c03a 	cmpne	r2,r2,zero
 90b63bc:	10002a1e 	bne	r2,zero,90b6468 <tcp_output+0x714>
 90b63c0:	e0bfed17 	ldw	r2,-76(fp)
 90b63c4:	1004c03a 	cmpne	r2,r2,zero
 90b63c8:	1000271e 	bne	r2,zero,90b6468 <tcp_output+0x714>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 90b63cc:	01000084 	movi	r4,2
 90b63d0:	000b883a 	mov	r5,zero
 90b63d4:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b63d8:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 90b63dc:	e0bfef17 	ldw	r2,-68(fp)
 90b63e0:	1004c03a 	cmpne	r2,r2,zero
 90b63e4:	1000041e 	bne	r2,zero,90b63f8 <tcp_output+0x6a4>
      {
         EXIT_CRIT_SECTION(tp);
 90b63e8:	90aa7140 	call	90aa714 <irq_Unmask>
         return (ENOBUFS);
 90b63ec:	00801a44 	movi	r2,105
 90b63f0:	e0bff815 	stw	r2,-32(fp)
 90b63f4:	0002b006 	br	90b6eb8 <tcp_output+0x1164>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 90b63f8:	e0bfea17 	ldw	r2,-88(fp)
 90b63fc:	10c00117 	ldw	r3,4(r2)
 90b6400:	e0bfef17 	ldw	r2,-68(fp)
 90b6404:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 90b6408:	e0bfef17 	ldw	r2,-68(fp)
 90b640c:	10c00117 	ldw	r3,4(r2)
 90b6410:	18800917 	ldw	r2,36(r3)
 90b6414:	10800044 	addi	r2,r2,1
 90b6418:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 90b641c:	e0bfea17 	ldw	r2,-88(fp)
 90b6420:	10c00417 	ldw	r3,16(r2)
 90b6424:	e0bfef17 	ldw	r2,-68(fp)
 90b6428:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 90b642c:	e0bfea17 	ldw	r2,-88(fp)
 90b6430:	10c00517 	ldw	r3,20(r2)
 90b6434:	e0bfef17 	ldw	r2,-68(fp)
 90b6438:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 90b643c:	e0bff417 	ldw	r2,-48(fp)
 90b6440:	10800a04 	addi	r2,r2,40
 90b6444:	1007883a 	mov	r3,r2
 90b6448:	e0bfef17 	ldw	r2,-68(fp)
 90b644c:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 90b6450:	e0bfea17 	ldw	r2,-88(fp)
 90b6454:	10800317 	ldw	r2,12(r2)
 90b6458:	10fff604 	addi	r3,r2,-40
 90b645c:	e0bfef17 	ldw	r2,-68(fp)
 90b6460:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 90b6464:	00002e06 	br	90b6520 <tcp_output+0x7cc>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 90b6468:	00824374 	movhi	r2,2317
 90b646c:	108f0704 	addi	r2,r2,15388
 90b6470:	10800017 	ldw	r2,0(r2)
 90b6474:	11400a04 	addi	r5,r2,40
 90b6478:	010000c4 	movi	r4,3
 90b647c:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b6480:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 90b6484:	e0bfef17 	ldw	r2,-68(fp)
 90b6488:	1004c03a 	cmpne	r2,r2,zero
 90b648c:	1000041e 	bne	r2,zero,90b64a0 <tcp_output+0x74c>
      {
         EXIT_CRIT_SECTION(tp);
 90b6490:	90aa7140 	call	90aa714 <irq_Unmask>
         return ENOBUFS;
 90b6494:	00c01a44 	movi	r3,105
 90b6498:	e0fff815 	stw	r3,-32(fp)
 90b649c:	00028606 	br	90b6eb8 <tcp_output+0x1164>
      }

      m->m_len = TCPIPHDRSZ;
 90b64a0:	e0ffef17 	ldw	r3,-68(fp)
 90b64a4:	00800a04 	movi	r2,40
 90b64a8:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 90b64ac:	e0bfef17 	ldw	r2,-68(fp)
 90b64b0:	10c00317 	ldw	r3,12(r2)
 90b64b4:	00824374 	movhi	r2,2317
 90b64b8:	108f0704 	addi	r2,r2,15388
 90b64bc:	10800017 	ldw	r2,0(r2)
 90b64c0:	1887883a 	add	r3,r3,r2
 90b64c4:	e0bfef17 	ldw	r2,-68(fp)
 90b64c8:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 90b64cc:	e0bff417 	ldw	r2,-48(fp)
 90b64d0:	1005003a 	cmpeq	r2,r2,zero
 90b64d4:	1000121e 	bne	r2,zero,90b6520 <tcp_output+0x7cc>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 90b64d8:	e0bff517 	ldw	r2,-44(fp)
 90b64dc:	11001817 	ldw	r4,96(r2)
 90b64e0:	e17ff217 	ldw	r5,-56(fp)
 90b64e4:	e1bff417 	ldw	r6,-48(fp)
 90b64e8:	90ab5d80 	call	90ab5d8 <m_copy>
 90b64ec:	1007883a 	mov	r3,r2
 90b64f0:	e0bfef17 	ldw	r2,-68(fp)
 90b64f4:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 90b64f8:	e0bfef17 	ldw	r2,-68(fp)
 90b64fc:	10800617 	ldw	r2,24(r2)
 90b6500:	1004c03a 	cmpne	r2,r2,zero
 90b6504:	1000061e 	bne	r2,zero,90b6520 <tcp_output+0x7cc>
         {
            m_freem(m);
 90b6508:	e13fef17 	ldw	r4,-68(fp)
 90b650c:	90ab5940 	call	90ab594 <m_freem>
            EXIT_CRIT_SECTION(tp);
 90b6510:	90aa7140 	call	90aa714 <irq_Unmask>
            return ENOBUFS;
 90b6514:	00801a44 	movi	r2,105
 90b6518:	e0bff815 	stw	r2,-32(fp)
 90b651c:	00026606 	br	90b6eb8 <tcp_output+0x1164>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 90b6520:	90aa7140 	call	90aa714 <irq_Unmask>

   if (len) 
 90b6524:	e0bff417 	ldw	r2,-48(fp)
 90b6528:	1005003a 	cmpeq	r2,r2,zero
 90b652c:	1000391e 	bne	r2,zero,90b6614 <tcp_output+0x8c0>
   {
      if (tp->t_force && len == 1)
 90b6530:	e0bff717 	ldw	r2,-36(fp)
 90b6534:	10800a83 	ldbu	r2,42(r2)
 90b6538:	10803fcc 	andi	r2,r2,255
 90b653c:	1080201c 	xori	r2,r2,128
 90b6540:	10bfe004 	addi	r2,r2,-128
 90b6544:	1005003a 	cmpeq	r2,r2,zero
 90b6548:	10000b1e 	bne	r2,zero,90b6578 <tcp_output+0x824>
 90b654c:	e0bff417 	ldw	r2,-48(fp)
 90b6550:	10800058 	cmpnei	r2,r2,1
 90b6554:	1000081e 	bne	r2,zero,90b6578 <tcp_output+0x824>
         tcpstat.tcps_sndprobe++;
 90b6558:	008243b4 	movhi	r2,2318
 90b655c:	10b75604 	addi	r2,r2,-8872
 90b6560:	10801517 	ldw	r2,84(r2)
 90b6564:	10c00044 	addi	r3,r2,1
 90b6568:	008243b4 	movhi	r2,2318
 90b656c:	10b75604 	addi	r2,r2,-8872
 90b6570:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 90b6574:	00005806 	br	90b66d8 <tcp_output+0x984>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 90b6578:	e0bff717 	ldw	r2,-36(fp)
 90b657c:	10c00f17 	ldw	r3,60(r2)
 90b6580:	e0bff717 	ldw	r2,-36(fp)
 90b6584:	10801a17 	ldw	r2,104(r2)
 90b6588:	1885c83a 	sub	r2,r3,r2
 90b658c:	1004403a 	cmpge	r2,r2,zero
 90b6590:	1000101e 	bne	r2,zero,90b65d4 <tcp_output+0x880>
      {
         tcpstat.tcps_sndrexmitpack++;
 90b6594:	008243b4 	movhi	r2,2318
 90b6598:	10b75604 	addi	r2,r2,-8872
 90b659c:	10801217 	ldw	r2,72(r2)
 90b65a0:	10c00044 	addi	r3,r2,1
 90b65a4:	008243b4 	movhi	r2,2318
 90b65a8:	10b75604 	addi	r2,r2,-8872
 90b65ac:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 90b65b0:	008243b4 	movhi	r2,2318
 90b65b4:	10b75604 	addi	r2,r2,-8872
 90b65b8:	10c01317 	ldw	r3,76(r2)
 90b65bc:	e0bff417 	ldw	r2,-48(fp)
 90b65c0:	1887883a 	add	r3,r3,r2
 90b65c4:	008243b4 	movhi	r2,2318
 90b65c8:	10b75604 	addi	r2,r2,-8872
 90b65cc:	10c01315 	stw	r3,76(r2)
 90b65d0:	00004106 	br	90b66d8 <tcp_output+0x984>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 90b65d4:	008243b4 	movhi	r2,2318
 90b65d8:	10b75604 	addi	r2,r2,-8872
 90b65dc:	10801017 	ldw	r2,64(r2)
 90b65e0:	10c00044 	addi	r3,r2,1
 90b65e4:	008243b4 	movhi	r2,2318
 90b65e8:	10b75604 	addi	r2,r2,-8872
 90b65ec:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 90b65f0:	008243b4 	movhi	r2,2318
 90b65f4:	10b75604 	addi	r2,r2,-8872
 90b65f8:	10c01117 	ldw	r3,68(r2)
 90b65fc:	e0bff417 	ldw	r2,-48(fp)
 90b6600:	1887883a 	add	r3,r3,r2
 90b6604:	008243b4 	movhi	r2,2318
 90b6608:	10b75604 	addi	r2,r2,-8872
 90b660c:	10c01115 	stw	r3,68(r2)
 90b6610:	00003106 	br	90b66d8 <tcp_output+0x984>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 90b6614:	e0bff717 	ldw	r2,-36(fp)
 90b6618:	10800b0b 	ldhu	r2,44(r2)
 90b661c:	10bfffcc 	andi	r2,r2,65535
 90b6620:	1080004c 	andi	r2,r2,1
 90b6624:	10803fcc 	andi	r2,r2,255
 90b6628:	1005003a 	cmpeq	r2,r2,zero
 90b662c:	1000081e 	bne	r2,zero,90b6650 <tcp_output+0x8fc>
   {
      tcpstat.tcps_sndacks++;
 90b6630:	008243b4 	movhi	r2,2318
 90b6634:	10b75604 	addi	r2,r2,-8872
 90b6638:	10801417 	ldw	r2,80(r2)
 90b663c:	10c00044 	addi	r3,r2,1
 90b6640:	008243b4 	movhi	r2,2318
 90b6644:	10b75604 	addi	r2,r2,-8872
 90b6648:	10c01415 	stw	r3,80(r2)
 90b664c:	00002206 	br	90b66d8 <tcp_output+0x984>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 90b6650:	e0bff117 	ldw	r2,-60(fp)
 90b6654:	108001cc 	andi	r2,r2,7
 90b6658:	1005003a 	cmpeq	r2,r2,zero
 90b665c:	1000081e 	bne	r2,zero,90b6680 <tcp_output+0x92c>
      tcpstat.tcps_sndctrl++;
 90b6660:	008243b4 	movhi	r2,2318
 90b6664:	10b75604 	addi	r2,r2,-8872
 90b6668:	10801817 	ldw	r2,96(r2)
 90b666c:	10c00044 	addi	r3,r2,1
 90b6670:	008243b4 	movhi	r2,2318
 90b6674:	10b75604 	addi	r2,r2,-8872
 90b6678:	10c01815 	stw	r3,96(r2)
 90b667c:	00001606 	br	90b66d8 <tcp_output+0x984>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 90b6680:	e0bff717 	ldw	r2,-36(fp)
 90b6684:	10c01017 	ldw	r3,64(r2)
 90b6688:	e0bff717 	ldw	r2,-36(fp)
 90b668c:	10800e17 	ldw	r2,56(r2)
 90b6690:	1885c83a 	sub	r2,r3,r2
 90b6694:	10800050 	cmplti	r2,r2,1
 90b6698:	1000081e 	bne	r2,zero,90b66bc <tcp_output+0x968>
      tcpstat.tcps_sndurg++;
 90b669c:	008243b4 	movhi	r2,2318
 90b66a0:	10b75604 	addi	r2,r2,-8872
 90b66a4:	10801617 	ldw	r2,88(r2)
 90b66a8:	10c00044 	addi	r3,r2,1
 90b66ac:	008243b4 	movhi	r2,2318
 90b66b0:	10b75604 	addi	r2,r2,-8872
 90b66b4:	10c01615 	stw	r3,88(r2)
 90b66b8:	00000706 	br	90b66d8 <tcp_output+0x984>
   else
      tcpstat.tcps_sndwinup++;
 90b66bc:	008243b4 	movhi	r2,2318
 90b66c0:	10b75604 	addi	r2,r2,-8872
 90b66c4:	10801717 	ldw	r2,92(r2)
 90b66c8:	10c00044 	addi	r3,r2,1
 90b66cc:	008243b4 	movhi	r2,2318
 90b66d0:	10b75604 	addi	r2,r2,-8872
 90b66d4:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 90b66d8:	e0bfef17 	ldw	r2,-68(fp)
 90b66dc:	10800317 	ldw	r2,12(r2)
 90b66e0:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 90b66e4:	e0bfef17 	ldw	r2,-68(fp)
 90b66e8:	10800117 	ldw	r2,4(r2)
 90b66ec:	10c00117 	ldw	r3,4(r2)
 90b66f0:	e0bfee17 	ldw	r2,-72(fp)
 90b66f4:	10c0032e 	bgeu	r2,r3,90b6704 <tcp_output+0x9b0>
   {
      panic("tcp_out- packet ptr underflow\n");
 90b66f8:	01024374 	movhi	r4,2317
 90b66fc:	21026c04 	addi	r4,r4,2480
 90b6700:	90a537c0 	call	90a537c <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 90b6704:	e0bfef17 	ldw	r2,-68(fp)
 90b6708:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 90b670c:	e0bff717 	ldw	r2,-36(fp)
 90b6710:	10800c17 	ldw	r2,48(r2)
 90b6714:	1004c03a 	cmpne	r2,r2,zero
 90b6718:	1000031e 	bne	r2,zero,90b6728 <tcp_output+0x9d4>
      panic("tcp_output");
 90b671c:	01024374 	movhi	r4,2317
 90b6720:	21027404 	addi	r4,r4,2512
 90b6724:	90a537c0 	call	90a537c <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 90b6728:	e0ffee17 	ldw	r3,-72(fp)
 90b672c:	e0bff717 	ldw	r2,-36(fp)
 90b6730:	10800c17 	ldw	r2,48(r2)
 90b6734:	1809883a 	mov	r4,r3
 90b6738:	100b883a 	mov	r5,r2
 90b673c:	01800a04 	movi	r6,40
 90b6740:	90894600 	call	9089460 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 90b6744:	e0bff117 	ldw	r2,-60(fp)
 90b6748:	1080004c 	andi	r2,r2,1
 90b674c:	10803fcc 	andi	r2,r2,255
 90b6750:	1005003a 	cmpeq	r2,r2,zero
 90b6754:	1000101e 	bne	r2,zero,90b6798 <tcp_output+0xa44>
 90b6758:	e0bff717 	ldw	r2,-36(fp)
 90b675c:	10800b0b 	ldhu	r2,44(r2)
 90b6760:	10bfffcc 	andi	r2,r2,65535
 90b6764:	1080040c 	andi	r2,r2,16
 90b6768:	1005003a 	cmpeq	r2,r2,zero
 90b676c:	10000a1e 	bne	r2,zero,90b6798 <tcp_output+0xa44>
 90b6770:	e0bff717 	ldw	r2,-36(fp)
 90b6774:	10c00f17 	ldw	r3,60(r2)
 90b6778:	e0bff717 	ldw	r2,-36(fp)
 90b677c:	10801a17 	ldw	r2,104(r2)
 90b6780:	1880051e 	bne	r3,r2,90b6798 <tcp_output+0xa44>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 90b6784:	e0bff717 	ldw	r2,-36(fp)
 90b6788:	10800f17 	ldw	r2,60(r2)
 90b678c:	10ffffc4 	addi	r3,r2,-1
 90b6790:	e0bff717 	ldw	r2,-36(fp)
 90b6794:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 90b6798:	e0bff717 	ldw	r2,-36(fp)
 90b679c:	10800f17 	ldw	r2,60(r2)
 90b67a0:	1004d63a 	srli	r2,r2,24
 90b67a4:	10c03fcc 	andi	r3,r2,255
 90b67a8:	e0bff717 	ldw	r2,-36(fp)
 90b67ac:	10800f17 	ldw	r2,60(r2)
 90b67b0:	1004d23a 	srli	r2,r2,8
 90b67b4:	10bfc00c 	andi	r2,r2,65280
 90b67b8:	1886b03a 	or	r3,r3,r2
 90b67bc:	e0bff717 	ldw	r2,-36(fp)
 90b67c0:	10800f17 	ldw	r2,60(r2)
 90b67c4:	10bfc00c 	andi	r2,r2,65280
 90b67c8:	1004923a 	slli	r2,r2,8
 90b67cc:	1886b03a 	or	r3,r3,r2
 90b67d0:	e0bff717 	ldw	r2,-36(fp)
 90b67d4:	10800f17 	ldw	r2,60(r2)
 90b67d8:	10803fcc 	andi	r2,r2,255
 90b67dc:	1004963a 	slli	r2,r2,24
 90b67e0:	1886b03a 	or	r3,r3,r2
 90b67e4:	e0bfee17 	ldw	r2,-72(fp)
 90b67e8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 90b67ec:	e0bff717 	ldw	r2,-36(fp)
 90b67f0:	10801617 	ldw	r2,88(r2)
 90b67f4:	1004d63a 	srli	r2,r2,24
 90b67f8:	10c03fcc 	andi	r3,r2,255
 90b67fc:	e0bff717 	ldw	r2,-36(fp)
 90b6800:	10801617 	ldw	r2,88(r2)
 90b6804:	1004d23a 	srli	r2,r2,8
 90b6808:	10bfc00c 	andi	r2,r2,65280
 90b680c:	1886b03a 	or	r3,r3,r2
 90b6810:	e0bff717 	ldw	r2,-36(fp)
 90b6814:	10801617 	ldw	r2,88(r2)
 90b6818:	10bfc00c 	andi	r2,r2,65280
 90b681c:	1004923a 	slli	r2,r2,8
 90b6820:	1886b03a 	or	r3,r3,r2
 90b6824:	e0bff717 	ldw	r2,-36(fp)
 90b6828:	10801617 	ldw	r2,88(r2)
 90b682c:	10803fcc 	andi	r2,r2,255
 90b6830:	1004963a 	slli	r2,r2,24
 90b6834:	1886b03a 	or	r3,r3,r2
 90b6838:	e0bfee17 	ldw	r2,-72(fp)
 90b683c:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 90b6840:	e0bff117 	ldw	r2,-60(fp)
 90b6844:	1080008c 	andi	r2,r2,2
 90b6848:	1005003a 	cmpeq	r2,r2,zero
 90b684c:	1000221e 	bne	r2,zero,90b68d8 <tcp_output+0xb84>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 90b6850:	e0bff517 	ldw	r2,-44(fp)
 90b6854:	10800117 	ldw	r2,4(r2)
 90b6858:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 90b685c:	e0bff517 	ldw	r2,-44(fp)
 90b6860:	10800517 	ldw	r2,20(r2)
 90b6864:	108000a0 	cmpeqi	r2,r2,2
 90b6868:	1000011e 	bne	r2,zero,90b6870 <tcp_output+0xb1c>
 90b686c:	00001906 	br	90b68d4 <tcp_output+0xb80>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 90b6870:	e0bff117 	ldw	r2,-60(fp)
 90b6874:	1080040c 	andi	r2,r2,16
 90b6878:	1004c03a 	cmpne	r2,r2,zero
 90b687c:	1000161e 	bne	r2,zero,90b68d8 <tcp_output+0xb84>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 90b6880:	e0bfee17 	ldw	r2,-72(fp)
 90b6884:	11000417 	ldw	r4,16(r2)
 90b6888:	e17ff604 	addi	r5,fp,-40
 90b688c:	90bfdac0 	call	90bfdac <iproute>
 90b6890:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 90b6894:	e0bfe517 	ldw	r2,-108(fp)
 90b6898:	1005003a 	cmpeq	r2,r2,zero
 90b689c:	1000091e 	bne	r2,zero,90b68c4 <tcp_output+0xb70>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 90b68a0:	e0bfe517 	ldw	r2,-108(fp)
 90b68a4:	10c00917 	ldw	r3,36(r2)
 90b68a8:	e0bfe517 	ldw	r2,-108(fp)
 90b68ac:	10800817 	ldw	r2,32(r2)
 90b68b0:	1885c83a 	sub	r2,r3,r2
 90b68b4:	10fff604 	addi	r3,r2,-40
 90b68b8:	e0bfe617 	ldw	r2,-104(fp)
 90b68bc:	10c00615 	stw	r3,24(r2)
 90b68c0:	00000506 	br	90b68d8 <tcp_output+0xb84>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 90b68c4:	e0ffe617 	ldw	r3,-104(fp)
 90b68c8:	00809104 	movi	r2,580
 90b68cc:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 90b68d0:	00000106 	br	90b68d8 <tcp_output+0xb84>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 90b68d4:	90aa4780 	call	90aa478 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 90b68d8:	e0bfed17 	ldw	r2,-76(fp)
 90b68dc:	1005003a 	cmpeq	r2,r2,zero
 90b68e0:	10002f1e 	bne	r2,zero,90b69a0 <tcp_output+0xc4c>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 90b68e4:	01000084 	movi	r4,2
 90b68e8:	01404004 	movi	r5,256
 90b68ec:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b68f0:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 90b68f4:	e0bfe417 	ldw	r2,-112(fp)
 90b68f8:	1004c03a 	cmpne	r2,r2,zero
 90b68fc:	1000051e 	bne	r2,zero,90b6914 <tcp_output+0xbc0>
      {
         m_freem(m);
 90b6900:	e13fef17 	ldw	r4,-68(fp)
 90b6904:	90ab5940 	call	90ab594 <m_freem>
         return (ENOBUFS);
 90b6908:	00c01a44 	movi	r3,105
 90b690c:	e0fff815 	stw	r3,-32(fp)
 90b6910:	00016906 	br	90b6eb8 <tcp_output+0x1164>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 90b6914:	e0bfe917 	ldw	r2,-92(fp)
 90b6918:	10c00617 	ldw	r3,24(r2)
 90b691c:	e0bfe417 	ldw	r2,-112(fp)
 90b6920:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 90b6924:	e0ffe917 	ldw	r3,-92(fp)
 90b6928:	e0bfe417 	ldw	r2,-112(fp)
 90b692c:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 90b6930:	00000706 	br	90b6950 <tcp_output+0xbfc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 90b6934:	e0ffed17 	ldw	r3,-76(fp)
 90b6938:	d0a0b404 	addi	r2,gp,-32048
 90b693c:	1885883a 	add	r2,r3,r2
 90b6940:	10000005 	stb	zero,0(r2)
 90b6944:	e0bfed17 	ldw	r2,-76(fp)
 90b6948:	10800044 	addi	r2,r2,1
 90b694c:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 90b6950:	e0bfed17 	ldw	r2,-76(fp)
 90b6954:	108000cc 	andi	r2,r2,3
 90b6958:	1004c03a 	cmpne	r2,r2,zero
 90b695c:	103ff51e 	bne	r2,zero,90b6934 <tcp_output+0xbe0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 90b6960:	e0bfe417 	ldw	r2,-112(fp)
 90b6964:	10800317 	ldw	r2,12(r2)
 90b6968:	1009883a 	mov	r4,r2
 90b696c:	d160b404 	addi	r5,gp,-32048
 90b6970:	e1bfed17 	ldw	r6,-76(fp)
 90b6974:	90894600 	call	9089460 <memcpy>
      mopt->m_len = optlen;
 90b6978:	e0ffe417 	ldw	r3,-112(fp)
 90b697c:	e0bfed17 	ldw	r2,-76(fp)
 90b6980:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 90b6984:	e0bfed17 	ldw	r2,-76(fp)
 90b6988:	10800504 	addi	r2,r2,20
 90b698c:	1004d0ba 	srli	r2,r2,2
 90b6990:	1004913a 	slli	r2,r2,4
 90b6994:	1007883a 	mov	r3,r2
 90b6998:	e0bfee17 	ldw	r2,-72(fp)
 90b699c:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 90b69a0:	e0bff117 	ldw	r2,-60(fp)
 90b69a4:	1007883a 	mov	r3,r2
 90b69a8:	e0bfee17 	ldw	r2,-72(fp)
 90b69ac:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 90b69b0:	e0bff517 	ldw	r2,-44(fp)
 90b69b4:	10800b17 	ldw	r2,44(r2)
 90b69b8:	1004d0ba 	srli	r2,r2,2
 90b69bc:	1007883a 	mov	r3,r2
 90b69c0:	e0bff317 	ldw	r2,-52(fp)
 90b69c4:	10c0060e 	bge	r2,r3,90b69e0 <tcp_output+0xc8c>
 90b69c8:	e0bff717 	ldw	r2,-36(fp)
 90b69cc:	10800a0b 	ldhu	r2,40(r2)
 90b69d0:	10ffffcc 	andi	r3,r2,65535
 90b69d4:	e0bff317 	ldw	r2,-52(fp)
 90b69d8:	10c0010e 	bge	r2,r3,90b69e0 <tcp_output+0xc8c>
      win = 0;
 90b69dc:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 90b69e0:	e0bff717 	ldw	r2,-36(fp)
 90b69e4:	10c01917 	ldw	r3,100(r2)
 90b69e8:	e0bff717 	ldw	r2,-36(fp)
 90b69ec:	10801617 	ldw	r2,88(r2)
 90b69f0:	1885c83a 	sub	r2,r3,r2
 90b69f4:	1007883a 	mov	r3,r2
 90b69f8:	e0bff317 	ldw	r2,-52(fp)
 90b69fc:	10c0060e 	bge	r2,r3,90b6a18 <tcp_output+0xcc4>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 90b6a00:	e0bff717 	ldw	r2,-36(fp)
 90b6a04:	10c01917 	ldw	r3,100(r2)
 90b6a08:	e0bff717 	ldw	r2,-36(fp)
 90b6a0c:	10801617 	ldw	r2,88(r2)
 90b6a10:	1885c83a 	sub	r2,r3,r2
 90b6a14:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 90b6a18:	008243b4 	movhi	r2,2318
 90b6a1c:	10b68d04 	addi	r2,r2,-9676
 90b6a20:	10800217 	ldw	r2,8(r2)
 90b6a24:	1004c03a 	cmpne	r2,r2,zero
 90b6a28:	1000021e 	bne	r2,zero,90b6a34 <tcp_output+0xce0>
   {
      win = 0;
 90b6a2c:	e03ff315 	stw	zero,-52(fp)
 90b6a30:	00001406 	br	90b6a84 <tcp_output+0xd30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 90b6a34:	008243b4 	movhi	r2,2318
 90b6a38:	10b68d04 	addi	r2,r2,-9676
 90b6a3c:	10800217 	ldw	r2,8(r2)
 90b6a40:	10ffffc4 	addi	r3,r2,-1
 90b6a44:	00824374 	movhi	r2,2317
 90b6a48:	108ebc04 	addi	r2,r2,15088
 90b6a4c:	10800017 	ldw	r2,0(r2)
 90b6a50:	1887383a 	mul	r3,r3,r2
 90b6a54:	e0bff317 	ldw	r2,-52(fp)
 90b6a58:	18800a0e 	bge	r3,r2,90b6a84 <tcp_output+0xd30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 90b6a5c:	008243b4 	movhi	r2,2318
 90b6a60:	10b68d04 	addi	r2,r2,-9676
 90b6a64:	10800217 	ldw	r2,8(r2)
 90b6a68:	10bfffc4 	addi	r2,r2,-1
 90b6a6c:	1007883a 	mov	r3,r2
 90b6a70:	00824374 	movhi	r2,2317
 90b6a74:	108ebc04 	addi	r2,r2,15088
 90b6a78:	10800017 	ldw	r2,0(r2)
 90b6a7c:	1885383a 	mul	r2,r3,r2
 90b6a80:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 90b6a84:	e0bff317 	ldw	r2,-52(fp)
 90b6a88:	10bfffcc 	andi	r2,r2,65535
 90b6a8c:	1004d23a 	srli	r2,r2,8
 90b6a90:	10803fcc 	andi	r2,r2,255
 90b6a94:	1009883a 	mov	r4,r2
 90b6a98:	e0bff317 	ldw	r2,-52(fp)
 90b6a9c:	10bfffcc 	andi	r2,r2,65535
 90b6aa0:	1004923a 	slli	r2,r2,8
 90b6aa4:	1007883a 	mov	r3,r2
 90b6aa8:	00bfc004 	movi	r2,-256
 90b6aac:	1884703a 	and	r2,r3,r2
 90b6ab0:	2084b03a 	or	r2,r4,r2
 90b6ab4:	1007883a 	mov	r3,r2
 90b6ab8:	e0bfee17 	ldw	r2,-72(fp)
 90b6abc:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 90b6ac0:	e0bff717 	ldw	r2,-36(fp)
 90b6ac4:	10c01017 	ldw	r3,64(r2)
 90b6ac8:	e0bff717 	ldw	r2,-36(fp)
 90b6acc:	10800f17 	ldw	r2,60(r2)
 90b6ad0:	1885c83a 	sub	r2,r3,r2
 90b6ad4:	10800050 	cmplti	r2,r2,1
 90b6ad8:	1000201e 	bne	r2,zero,90b6b5c <tcp_output+0xe08>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 90b6adc:	e0bff717 	ldw	r2,-36(fp)
 90b6ae0:	10801017 	ldw	r2,64(r2)
 90b6ae4:	1007883a 	mov	r3,r2
 90b6ae8:	e0bff717 	ldw	r2,-36(fp)
 90b6aec:	10800f17 	ldw	r2,60(r2)
 90b6af0:	1885c83a 	sub	r2,r3,r2
 90b6af4:	10bfffcc 	andi	r2,r2,65535
 90b6af8:	1004d23a 	srli	r2,r2,8
 90b6afc:	10803fcc 	andi	r2,r2,255
 90b6b00:	1009883a 	mov	r4,r2
 90b6b04:	e0bff717 	ldw	r2,-36(fp)
 90b6b08:	10801017 	ldw	r2,64(r2)
 90b6b0c:	1007883a 	mov	r3,r2
 90b6b10:	e0bff717 	ldw	r2,-36(fp)
 90b6b14:	10800f17 	ldw	r2,60(r2)
 90b6b18:	1885c83a 	sub	r2,r3,r2
 90b6b1c:	10bfffcc 	andi	r2,r2,65535
 90b6b20:	1004923a 	slli	r2,r2,8
 90b6b24:	1007883a 	mov	r3,r2
 90b6b28:	00bfc004 	movi	r2,-256
 90b6b2c:	1884703a 	and	r2,r3,r2
 90b6b30:	2084b03a 	or	r2,r4,r2
 90b6b34:	1007883a 	mov	r3,r2
 90b6b38:	e0bfee17 	ldw	r2,-72(fp)
 90b6b3c:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 90b6b40:	e0bfee17 	ldw	r2,-72(fp)
 90b6b44:	10800843 	ldbu	r2,33(r2)
 90b6b48:	10800814 	ori	r2,r2,32
 90b6b4c:	1007883a 	mov	r3,r2
 90b6b50:	e0bfee17 	ldw	r2,-72(fp)
 90b6b54:	10c00845 	stb	r3,33(r2)
 90b6b58:	00000406 	br	90b6b6c <tcp_output+0xe18>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 90b6b5c:	e0bff717 	ldw	r2,-36(fp)
 90b6b60:	10c00e17 	ldw	r3,56(r2)
 90b6b64:	e0bff717 	ldw	r2,-36(fp)
 90b6b68:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 90b6b6c:	e0bff417 	ldw	r2,-48(fp)
 90b6b70:	1005003a 	cmpeq	r2,r2,zero
 90b6b74:	10000c1e 	bne	r2,zero,90b6ba8 <tcp_output+0xe54>
 90b6b78:	e0fff217 	ldw	r3,-56(fp)
 90b6b7c:	e0bff417 	ldw	r2,-48(fp)
 90b6b80:	1887883a 	add	r3,r3,r2
 90b6b84:	e0bff517 	ldw	r2,-44(fp)
 90b6b88:	10801217 	ldw	r2,72(r2)
 90b6b8c:	1880061e 	bne	r3,r2,90b6ba8 <tcp_output+0xe54>
      ti->ti_flags |= TH_PUSH;
 90b6b90:	e0bfee17 	ldw	r2,-72(fp)
 90b6b94:	10800843 	ldbu	r2,33(r2)
 90b6b98:	10800214 	ori	r2,r2,8
 90b6b9c:	1007883a 	mov	r3,r2
 90b6ba0:	e0bfee17 	ldw	r2,-72(fp)
 90b6ba4:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 90b6ba8:	e0bff717 	ldw	r2,-36(fp)
 90b6bac:	10800a83 	ldbu	r2,42(r2)
 90b6bb0:	10803fcc 	andi	r2,r2,255
 90b6bb4:	1080201c 	xori	r2,r2,128
 90b6bb8:	10bfe004 	addi	r2,r2,-128
 90b6bbc:	1005003a 	cmpeq	r2,r2,zero
 90b6bc0:	1000041e 	bne	r2,zero,90b6bd4 <tcp_output+0xe80>
 90b6bc4:	e0bff717 	ldw	r2,-36(fp)
 90b6bc8:	10800417 	ldw	r2,16(r2)
 90b6bcc:	1004c03a 	cmpne	r2,r2,zero
 90b6bd0:	1000561e 	bne	r2,zero,90b6d2c <tcp_output+0xfd8>
   {
      tcp_seq startseq = tp->snd_nxt;
 90b6bd4:	e0bff717 	ldw	r2,-36(fp)
 90b6bd8:	10800f17 	ldw	r2,60(r2)
 90b6bdc:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 90b6be0:	e0bff117 	ldw	r2,-60(fp)
 90b6be4:	1080008c 	andi	r2,r2,2
 90b6be8:	1005003a 	cmpeq	r2,r2,zero
 90b6bec:	1000051e 	bne	r2,zero,90b6c04 <tcp_output+0xeb0>
         tp->snd_nxt++;
 90b6bf0:	e0bff717 	ldw	r2,-36(fp)
 90b6bf4:	10800f17 	ldw	r2,60(r2)
 90b6bf8:	10c00044 	addi	r3,r2,1
 90b6bfc:	e0bff717 	ldw	r2,-36(fp)
 90b6c00:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 90b6c04:	e0bff117 	ldw	r2,-60(fp)
 90b6c08:	1080004c 	andi	r2,r2,1
 90b6c0c:	10803fcc 	andi	r2,r2,255
 90b6c10:	1005003a 	cmpeq	r2,r2,zero
 90b6c14:	10000b1e 	bne	r2,zero,90b6c44 <tcp_output+0xef0>
      {
         tp->snd_nxt++;
 90b6c18:	e0bff717 	ldw	r2,-36(fp)
 90b6c1c:	10800f17 	ldw	r2,60(r2)
 90b6c20:	10c00044 	addi	r3,r2,1
 90b6c24:	e0bff717 	ldw	r2,-36(fp)
 90b6c28:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 90b6c2c:	e0bff717 	ldw	r2,-36(fp)
 90b6c30:	10800b0b 	ldhu	r2,44(r2)
 90b6c34:	10800414 	ori	r2,r2,16
 90b6c38:	1007883a 	mov	r3,r2
 90b6c3c:	e0bff717 	ldw	r2,-36(fp)
 90b6c40:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 90b6c44:	e0bff717 	ldw	r2,-36(fp)
 90b6c48:	10c00f17 	ldw	r3,60(r2)
 90b6c4c:	e0bff417 	ldw	r2,-48(fp)
 90b6c50:	1887883a 	add	r3,r3,r2
 90b6c54:	e0bff717 	ldw	r2,-36(fp)
 90b6c58:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 90b6c5c:	e0bff717 	ldw	r2,-36(fp)
 90b6c60:	10c00f17 	ldw	r3,60(r2)
 90b6c64:	e0bff717 	ldw	r2,-36(fp)
 90b6c68:	10801a17 	ldw	r2,104(r2)
 90b6c6c:	1885c83a 	sub	r2,r3,r2
 90b6c70:	10800050 	cmplti	r2,r2,1
 90b6c74:	1000171e 	bne	r2,zero,90b6cd4 <tcp_output+0xf80>
      {
         tp->snd_max = tp->snd_nxt;
 90b6c78:	e0bff717 	ldw	r2,-36(fp)
 90b6c7c:	10c00f17 	ldw	r3,60(r2)
 90b6c80:	e0bff717 	ldw	r2,-36(fp)
 90b6c84:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 90b6c88:	e0bff717 	ldw	r2,-36(fp)
 90b6c8c:	10801e17 	ldw	r2,120(r2)
 90b6c90:	1004c03a 	cmpne	r2,r2,zero
 90b6c94:	10000f1e 	bne	r2,zero,90b6cd4 <tcp_output+0xf80>
         {
            tp->t_rttick = cticks;
 90b6c98:	00824374 	movhi	r2,2317
 90b6c9c:	108f2e04 	addi	r2,r2,15544
 90b6ca0:	10c00017 	ldw	r3,0(r2)
 90b6ca4:	e0bff717 	ldw	r2,-36(fp)
 90b6ca8:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 90b6cac:	e0fff717 	ldw	r3,-36(fp)
 90b6cb0:	e0bfe317 	ldw	r2,-116(fp)
 90b6cb4:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 90b6cb8:	008243b4 	movhi	r2,2318
 90b6cbc:	10b75604 	addi	r2,r2,-8872
 90b6cc0:	10800617 	ldw	r2,24(r2)
 90b6cc4:	10c00044 	addi	r3,r2,1
 90b6cc8:	008243b4 	movhi	r2,2318
 90b6ccc:	10b75604 	addi	r2,r2,-8872
 90b6cd0:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 90b6cd4:	e0bff717 	ldw	r2,-36(fp)
 90b6cd8:	10800317 	ldw	r2,12(r2)
 90b6cdc:	1004c03a 	cmpne	r2,r2,zero
 90b6ce0:	1000211e 	bne	r2,zero,90b6d68 <tcp_output+0x1014>
 90b6ce4:	e0bff717 	ldw	r2,-36(fp)
 90b6ce8:	10c00f17 	ldw	r3,60(r2)
 90b6cec:	e0bff717 	ldw	r2,-36(fp)
 90b6cf0:	10800e17 	ldw	r2,56(r2)
 90b6cf4:	18801c26 	beq	r3,r2,90b6d68 <tcp_output+0x1014>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b6cf8:	e0bff717 	ldw	r2,-36(fp)
 90b6cfc:	10c00817 	ldw	r3,32(r2)
 90b6d00:	e0bff717 	ldw	r2,-36(fp)
 90b6d04:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 90b6d08:	e0bff717 	ldw	r2,-36(fp)
 90b6d0c:	10800417 	ldw	r2,16(r2)
 90b6d10:	1005003a 	cmpeq	r2,r2,zero
 90b6d14:	1000141e 	bne	r2,zero,90b6d68 <tcp_output+0x1014>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 90b6d18:	e0bff717 	ldw	r2,-36(fp)
 90b6d1c:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 90b6d20:	e0bff717 	ldw	r2,-36(fp)
 90b6d24:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 90b6d28:	00000f06 	br	90b6d68 <tcp_output+0x1014>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 90b6d2c:	e0bff717 	ldw	r2,-36(fp)
 90b6d30:	10c00f17 	ldw	r3,60(r2)
 90b6d34:	e0bff417 	ldw	r2,-48(fp)
 90b6d38:	1887883a 	add	r3,r3,r2
 90b6d3c:	e0bff717 	ldw	r2,-36(fp)
 90b6d40:	10801a17 	ldw	r2,104(r2)
 90b6d44:	1885c83a 	sub	r2,r3,r2
 90b6d48:	10800050 	cmplti	r2,r2,1
 90b6d4c:	1000061e 	bne	r2,zero,90b6d68 <tcp_output+0x1014>
         tp->snd_max = tp->snd_nxt + len;
 90b6d50:	e0bff717 	ldw	r2,-36(fp)
 90b6d54:	10c00f17 	ldw	r3,60(r2)
 90b6d58:	e0bff417 	ldw	r2,-48(fp)
 90b6d5c:	1887883a 	add	r3,r3,r2
 90b6d60:	e0bff717 	ldw	r2,-36(fp)
 90b6d64:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 90b6d68:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 90b6d6c:	e0bfef17 	ldw	r2,-68(fp)
 90b6d70:	10800317 	ldw	r2,12(r2)
 90b6d74:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 90b6d78:	e0bfed17 	ldw	r2,-76(fp)
 90b6d7c:	1007883a 	mov	r3,r2
 90b6d80:	e0bff417 	ldw	r2,-48(fp)
 90b6d84:	1885883a 	add	r2,r3,r2
 90b6d88:	10800a04 	addi	r2,r2,40
 90b6d8c:	1007883a 	mov	r3,r2
 90b6d90:	e0bfe217 	ldw	r2,-120(fp)
 90b6d94:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 90b6d98:	e0bff517 	ldw	r2,-44(fp)
 90b6d9c:	11401f17 	ldw	r5,124(r2)
 90b6da0:	e13fef17 	ldw	r4,-68(fp)
 90b6da4:	90abfc80 	call	90abfc8 <ip_output>
 90b6da8:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 90b6dac:	e0bff017 	ldw	r2,-64(fp)
 90b6db0:	1005003a 	cmpeq	r2,r2,zero
 90b6db4:	1000151e 	bne	r2,zero,90b6e0c <tcp_output+0x10b8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 90b6db8:	e0bff017 	ldw	r2,-64(fp)
 90b6dbc:	10801a58 	cmpnei	r2,r2,105
 90b6dc0:	10000f1e 	bne	r2,zero,90b6e00 <tcp_output+0x10ac>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 90b6dc4:	e0bfef17 	ldw	r2,-68(fp)
 90b6dc8:	10800817 	ldw	r2,32(r2)
 90b6dcc:	1004c03a 	cmpne	r2,r2,zero
 90b6dd0:	1000031e 	bne	r2,zero,90b6de0 <tcp_output+0x108c>
            m = m->m_next;
 90b6dd4:	e0bfef17 	ldw	r2,-68(fp)
 90b6dd8:	10800617 	ldw	r2,24(r2)
 90b6ddc:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 90b6de0:	e13fef17 	ldw	r4,-68(fp)
 90b6de4:	90ab5940 	call	90ab594 <m_freem>
         tcp_quench(tp->t_inpcb);
 90b6de8:	e0bff717 	ldw	r2,-36(fp)
 90b6dec:	11000d17 	ldw	r4,52(r2)
 90b6df0:	90b79580 	call	90b7958 <tcp_quench>
         return (error);
 90b6df4:	e0bff017 	ldw	r2,-64(fp)
 90b6df8:	e0bff815 	stw	r2,-32(fp)
 90b6dfc:	00002e06 	br	90b6eb8 <tcp_output+0x1164>
      }
      return (error);
 90b6e00:	e0fff017 	ldw	r3,-64(fp)
 90b6e04:	e0fff815 	stw	r3,-32(fp)
 90b6e08:	00002b06 	br	90b6eb8 <tcp_output+0x1164>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 90b6e0c:	008243b4 	movhi	r2,2318
 90b6e10:	10b72804 	addi	r2,r2,-9056
 90b6e14:	10800a17 	ldw	r2,40(r2)
 90b6e18:	10c00044 	addi	r3,r2,1
 90b6e1c:	008243b4 	movhi	r2,2318
 90b6e20:	10b72804 	addi	r2,r2,-9056
 90b6e24:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 90b6e28:	008243b4 	movhi	r2,2318
 90b6e2c:	10b75604 	addi	r2,r2,-8872
 90b6e30:	10800f17 	ldw	r2,60(r2)
 90b6e34:	10c00044 	addi	r3,r2,1
 90b6e38:	008243b4 	movhi	r2,2318
 90b6e3c:	10b75604 	addi	r2,r2,-8872
 90b6e40:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 90b6e44:	e0bff317 	ldw	r2,-52(fp)
 90b6e48:	10800050 	cmplti	r2,r2,1
 90b6e4c:	10000f1e 	bne	r2,zero,90b6e8c <tcp_output+0x1138>
 90b6e50:	e0bff717 	ldw	r2,-36(fp)
 90b6e54:	10c01617 	ldw	r3,88(r2)
 90b6e58:	e0bff317 	ldw	r2,-52(fp)
 90b6e5c:	1887883a 	add	r3,r3,r2
 90b6e60:	e0bff717 	ldw	r2,-36(fp)
 90b6e64:	10801917 	ldw	r2,100(r2)
 90b6e68:	1885c83a 	sub	r2,r3,r2
 90b6e6c:	10800050 	cmplti	r2,r2,1
 90b6e70:	1000061e 	bne	r2,zero,90b6e8c <tcp_output+0x1138>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 90b6e74:	e0bff717 	ldw	r2,-36(fp)
 90b6e78:	10c01617 	ldw	r3,88(r2)
 90b6e7c:	e0bff317 	ldw	r2,-52(fp)
 90b6e80:	1887883a 	add	r3,r3,r2
 90b6e84:	e0bff717 	ldw	r2,-36(fp)
 90b6e88:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 90b6e8c:	e0bff717 	ldw	r2,-36(fp)
 90b6e90:	10c00b0b 	ldhu	r3,44(r2)
 90b6e94:	00bfef04 	movi	r2,-68
 90b6e98:	1884703a 	and	r2,r3,r2
 90b6e9c:	1007883a 	mov	r3,r2
 90b6ea0:	e0bff717 	ldw	r2,-36(fp)
 90b6ea4:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 90b6ea8:	e0bfeb17 	ldw	r2,-84(fp)
 90b6eac:	1004c03a 	cmpne	r2,r2,zero
 90b6eb0:	103bb81e 	bne	r2,zero,90b5d94 <tcp_output+0x40>
      goto again;
   return (0);
 90b6eb4:	e03ff815 	stw	zero,-32(fp)
 90b6eb8:	e0bff817 	ldw	r2,-32(fp)
}
 90b6ebc:	e037883a 	mov	sp,fp
 90b6ec0:	dfc00117 	ldw	ra,4(sp)
 90b6ec4:	df000017 	ldw	fp,0(sp)
 90b6ec8:	dec00204 	addi	sp,sp,8
 90b6ecc:	f800283a 	ret

090b6ed0 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 90b6ed0:	defffc04 	addi	sp,sp,-16
 90b6ed4:	dfc00315 	stw	ra,12(sp)
 90b6ed8:	df000215 	stw	fp,8(sp)
 90b6edc:	df000204 	addi	fp,sp,8
 90b6ee0:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 90b6ee4:	e0bfff17 	ldw	r2,-4(fp)
 90b6ee8:	10802017 	ldw	r2,128(r2)
 90b6eec:	1007d0ba 	srai	r3,r2,2
 90b6ef0:	e0bfff17 	ldw	r2,-4(fp)
 90b6ef4:	10802117 	ldw	r2,132(r2)
 90b6ef8:	1885883a 	add	r2,r3,r2
 90b6efc:	1005d07a 	srai	r2,r2,1
 90b6f00:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 90b6f04:	e0bfff17 	ldw	r2,-4(fp)
 90b6f08:	10800317 	ldw	r2,12(r2)
 90b6f0c:	1005003a 	cmpeq	r2,r2,zero
 90b6f10:	1000031e 	bne	r2,zero,90b6f20 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 90b6f14:	01024374 	movhi	r4,2317
 90b6f18:	21027704 	addi	r4,r4,2524
 90b6f1c:	90a537c0 	call	90a537c <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 90b6f20:	e0bfff17 	ldw	r2,-4(fp)
 90b6f24:	10c00717 	ldw	r3,28(r2)
 90b6f28:	00824374 	movhi	r2,2317
 90b6f2c:	108db3c4 	addi	r2,r2,14031
 90b6f30:	10c5883a 	add	r2,r2,r3
 90b6f34:	10800003 	ldbu	r2,0(r2)
 90b6f38:	10c03fcc 	andi	r3,r2,255
 90b6f3c:	e0bffe17 	ldw	r2,-8(fp)
 90b6f40:	1885383a 	mul	r2,r3,r2
 90b6f44:	10ffffcc 	andi	r3,r2,65535
 90b6f48:	18e0001c 	xori	r3,r3,32768
 90b6f4c:	18e00004 	addi	r3,r3,-32768
 90b6f50:	e0bfff17 	ldw	r2,-4(fp)
 90b6f54:	10c00415 	stw	r3,16(r2)
 90b6f58:	e0bfff17 	ldw	r2,-4(fp)
 90b6f5c:	10800417 	ldw	r2,16(r2)
 90b6f60:	10800288 	cmpgei	r2,r2,10
 90b6f64:	1000041e 	bne	r2,zero,90b6f78 <tcp_setpersist+0xa8>
 90b6f68:	e0ffff17 	ldw	r3,-4(fp)
 90b6f6c:	00800284 	movi	r2,10
 90b6f70:	18800415 	stw	r2,16(r3)
 90b6f74:	00000706 	br	90b6f94 <tcp_setpersist+0xc4>
 90b6f78:	e0bfff17 	ldw	r2,-4(fp)
 90b6f7c:	10800417 	ldw	r2,16(r2)
 90b6f80:	10801e50 	cmplti	r2,r2,121
 90b6f84:	1000031e 	bne	r2,zero,90b6f94 <tcp_setpersist+0xc4>
 90b6f88:	e0ffff17 	ldw	r3,-4(fp)
 90b6f8c:	00801e04 	movi	r2,120
 90b6f90:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 90b6f94:	e0bfff17 	ldw	r2,-4(fp)
 90b6f98:	10800717 	ldw	r2,28(r2)
 90b6f9c:	10800308 	cmpgei	r2,r2,12
 90b6fa0:	1000051e 	bne	r2,zero,90b6fb8 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 90b6fa4:	e0bfff17 	ldw	r2,-4(fp)
 90b6fa8:	10800717 	ldw	r2,28(r2)
 90b6fac:	10c00044 	addi	r3,r2,1
 90b6fb0:	e0bfff17 	ldw	r2,-4(fp)
 90b6fb4:	10c00715 	stw	r3,28(r2)

}
 90b6fb8:	e037883a 	mov	sp,fp
 90b6fbc:	dfc00117 	ldw	ra,4(sp)
 90b6fc0:	df000017 	ldw	fp,0(sp)
 90b6fc4:	dec00204 	addi	sp,sp,8
 90b6fc8:	f800283a 	ret

090b6fcc <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 90b6fcc:	defff704 	addi	sp,sp,-36
 90b6fd0:	dfc00815 	stw	ra,32(sp)
 90b6fd4:	df000715 	stw	fp,28(sp)
 90b6fd8:	df000704 	addi	fp,sp,28
 90b6fdc:	e13ffb15 	stw	r4,-20(fp)
 90b6fe0:	e17ffc15 	stw	r5,-16(fp)
 90b6fe4:	e1bffd15 	stw	r6,-12(fp)
 90b6fe8:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 90b6fec:	e0bffb17 	ldw	r2,-20(fp)
 90b6ff0:	10800b0b 	ldhu	r2,44(r2)
 90b6ff4:	10bfffcc 	andi	r2,r2,65535
 90b6ff8:	1080020c 	andi	r2,r2,8
 90b6ffc:	1005003a 	cmpeq	r2,r2,zero
 90b7000:	1000021e 	bne	r2,zero,90b700c <bld_options+0x40>
      return 0;
 90b7004:	e03fff15 	stw	zero,-4(fp)
 90b7008:	00002406 	br	90b709c <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 90b700c:	e0bffd17 	ldw	r2,-12(fp)
 90b7010:	1080008c 	andi	r2,r2,2
 90b7014:	1005003a 	cmpeq	r2,r2,zero
 90b7018:	10001d1e 	bne	r2,zero,90b7090 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 90b701c:	e13ffe17 	ldw	r4,-8(fp)
 90b7020:	90b5c380 	call	90b5c38 <tcp_mss>
 90b7024:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 90b7028:	e0fffc17 	ldw	r3,-16(fp)
 90b702c:	00800084 	movi	r2,2
 90b7030:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 90b7034:	e0bffc17 	ldw	r2,-16(fp)
 90b7038:	10c00044 	addi	r3,r2,1
 90b703c:	00800104 	movi	r2,4
 90b7040:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 90b7044:	e0bffc17 	ldw	r2,-16(fp)
 90b7048:	10c00084 	addi	r3,r2,2
 90b704c:	e0bff90b 	ldhu	r2,-28(fp)
 90b7050:	10bfc00c 	andi	r2,r2,65280
 90b7054:	1005d23a 	srai	r2,r2,8
 90b7058:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 90b705c:	e0bffc17 	ldw	r2,-16(fp)
 90b7060:	110000c4 	addi	r4,r2,3
 90b7064:	e0bff90b 	ldhu	r2,-28(fp)
 90b7068:	1007883a 	mov	r3,r2
 90b706c:	00bfffc4 	movi	r2,-1
 90b7070:	1884703a 	and	r2,r3,r2
 90b7074:	20800005 	stb	r2,0(r4)
      len = 4;
 90b7078:	00800104 	movi	r2,4
 90b707c:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 90b7080:	e0bffc17 	ldw	r2,-16(fp)
 90b7084:	10800104 	addi	r2,r2,4
 90b7088:	e0bffc15 	stw	r2,-16(fp)
 90b708c:	00000106 	br	90b7094 <bld_options+0xc8>
   }
   else
      len = 0;
 90b7090:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 90b7094:	e0bffa17 	ldw	r2,-24(fp)
 90b7098:	e0bfff15 	stw	r2,-4(fp)
 90b709c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b70a0:	e037883a 	mov	sp,fp
 90b70a4:	dfc00117 	ldw	ra,4(sp)
 90b70a8:	df000017 	ldw	fp,0(sp)
 90b70ac:	dec00204 	addi	sp,sp,8
 90b70b0:	f800283a 	ret

090b70b4 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 90b70b4:	deffff04 	addi	sp,sp,-4
 90b70b8:	df000015 	stw	fp,0(sp)
 90b70bc:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 90b70c0:	00c24374 	movhi	r3,2317
 90b70c4:	18cf3b04 	addi	r3,r3,15596
 90b70c8:	00800044 	movi	r2,1
 90b70cc:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 90b70d0:	00c243b4 	movhi	r3,2318
 90b70d4:	18f74b04 	addi	r3,r3,-8916
 90b70d8:	008243b4 	movhi	r2,2318
 90b70dc:	10b74b04 	addi	r2,r2,-8916
 90b70e0:	18800115 	stw	r2,4(r3)
 90b70e4:	008243b4 	movhi	r2,2318
 90b70e8:	10b74b04 	addi	r2,r2,-8916
 90b70ec:	10c00117 	ldw	r3,4(r2)
 90b70f0:	008243b4 	movhi	r2,2318
 90b70f4:	10b74b04 	addi	r2,r2,-8916
 90b70f8:	10c00015 	stw	r3,0(r2)
}
 90b70fc:	e037883a 	mov	sp,fp
 90b7100:	df000017 	ldw	fp,0(sp)
 90b7104:	dec00104 	addi	sp,sp,4
 90b7108:	f800283a 	ret

090b710c <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 90b710c:	defffa04 	addi	sp,sp,-24
 90b7110:	dfc00515 	stw	ra,20(sp)
 90b7114:	df000415 	stw	fp,16(sp)
 90b7118:	df000404 	addi	fp,sp,16
 90b711c:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 90b7120:	e0bffe17 	ldw	r2,-8(fp)
 90b7124:	10800d17 	ldw	r2,52(r2)
 90b7128:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 90b712c:	e0bffe17 	ldw	r2,-8(fp)
 90b7130:	10800c17 	ldw	r2,48(r2)
 90b7134:	e0bffc15 	stw	r2,-16(fp)
 90b7138:	e0bffc17 	ldw	r2,-16(fp)
 90b713c:	1004c03a 	cmpne	r2,r2,zero
 90b7140:	1000081e 	bne	r2,zero,90b7164 <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 90b7144:	01000a04 	movi	r4,40
 90b7148:	90aaefc0 	call	90aaefc <npalloc>
 90b714c:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 90b7150:	e0bffc17 	ldw	r2,-16(fp)
 90b7154:	1004c03a 	cmpne	r2,r2,zero
 90b7158:	1000021e 	bne	r2,zero,90b7164 <tcp_template+0x58>
         return (0);
 90b715c:	e03fff15 	stw	zero,-4(fp)
 90b7160:	00002a06 	br	90b720c <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 90b7164:	e0bffc17 	ldw	r2,-16(fp)
 90b7168:	10000115 	stw	zero,4(r2)
 90b716c:	e0bffc17 	ldw	r2,-16(fp)
 90b7170:	10c00117 	ldw	r3,4(r2)
 90b7174:	e0bffc17 	ldw	r2,-16(fp)
 90b7178:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 90b717c:	e0fffc17 	ldw	r3,-16(fp)
 90b7180:	00850004 	movi	r2,5120
 90b7184:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 90b7188:	e0bffd17 	ldw	r2,-12(fp)
 90b718c:	10c00417 	ldw	r3,16(r2)
 90b7190:	e0bffc17 	ldw	r2,-16(fp)
 90b7194:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 90b7198:	e0bffd17 	ldw	r2,-12(fp)
 90b719c:	10c00317 	ldw	r3,12(r2)
 90b71a0:	e0bffc17 	ldw	r2,-16(fp)
 90b71a4:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 90b71a8:	e0bffd17 	ldw	r2,-12(fp)
 90b71ac:	10c0078b 	ldhu	r3,30(r2)
 90b71b0:	e0bffc17 	ldw	r2,-16(fp)
 90b71b4:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 90b71b8:	e0bffd17 	ldw	r2,-12(fp)
 90b71bc:	10c0070b 	ldhu	r3,28(r2)
 90b71c0:	e0bffc17 	ldw	r2,-16(fp)
 90b71c4:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 90b71c8:	e0bffc17 	ldw	r2,-16(fp)
 90b71cc:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 90b71d0:	e0bffc17 	ldw	r2,-16(fp)
 90b71d4:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 90b71d8:	e0fffc17 	ldw	r3,-16(fp)
 90b71dc:	00801404 	movi	r2,80
 90b71e0:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 90b71e4:	e0bffc17 	ldw	r2,-16(fp)
 90b71e8:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 90b71ec:	e0bffc17 	ldw	r2,-16(fp)
 90b71f0:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 90b71f4:	e0bffc17 	ldw	r2,-16(fp)
 90b71f8:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 90b71fc:	e0bffc17 	ldw	r2,-16(fp)
 90b7200:	1000098d 	sth	zero,38(r2)
   return (n);
 90b7204:	e0bffc17 	ldw	r2,-16(fp)
 90b7208:	e0bfff15 	stw	r2,-4(fp)
 90b720c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b7210:	e037883a 	mov	sp,fp
 90b7214:	dfc00117 	ldw	ra,4(sp)
 90b7218:	df000017 	ldw	fp,0(sp)
 90b721c:	dec00204 	addi	sp,sp,8
 90b7220:	f800283a 	ret

090b7224 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 90b7224:	defff104 	addi	sp,sp,-60
 90b7228:	dfc00e15 	stw	ra,56(sp)
 90b722c:	df000d15 	stw	fp,52(sp)
 90b7230:	df000d04 	addi	fp,sp,52
 90b7234:	e13ffb15 	stw	r4,-20(fp)
 90b7238:	e17ffc15 	stw	r5,-16(fp)
 90b723c:	e1bffd15 	stw	r6,-12(fp)
 90b7240:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 90b7244:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 90b7248:	e0bffb17 	ldw	r2,-20(fp)
 90b724c:	1005003a 	cmpeq	r2,r2,zero
 90b7250:	10001a1e 	bne	r2,zero,90b72bc <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 90b7254:	e0bffb17 	ldw	r2,-20(fp)
 90b7258:	10800d17 	ldw	r2,52(r2)
 90b725c:	10800817 	ldw	r2,32(r2)
 90b7260:	10800b17 	ldw	r2,44(r2)
 90b7264:	1007883a 	mov	r3,r2
 90b7268:	e0bffb17 	ldw	r2,-20(fp)
 90b726c:	10800d17 	ldw	r2,52(r2)
 90b7270:	10800817 	ldw	r2,32(r2)
 90b7274:	10800a17 	ldw	r2,40(r2)
 90b7278:	1885c83a 	sub	r2,r3,r2
 90b727c:	1004803a 	cmplt	r2,r2,zero
 90b7280:	10000b1e 	bne	r2,zero,90b72b0 <tcp_respond+0x8c>
 90b7284:	e0bffb17 	ldw	r2,-20(fp)
 90b7288:	10800d17 	ldw	r2,52(r2)
 90b728c:	10800817 	ldw	r2,32(r2)
 90b7290:	10c00b17 	ldw	r3,44(r2)
 90b7294:	e0bffb17 	ldw	r2,-20(fp)
 90b7298:	10800d17 	ldw	r2,52(r2)
 90b729c:	10800817 	ldw	r2,32(r2)
 90b72a0:	10800a17 	ldw	r2,40(r2)
 90b72a4:	1885c83a 	sub	r2,r3,r2
 90b72a8:	e0bfff15 	stw	r2,-4(fp)
 90b72ac:	00000106 	br	90b72b4 <tcp_respond+0x90>
 90b72b0:	e03fff15 	stw	zero,-4(fp)
 90b72b4:	e0bfff17 	ldw	r2,-4(fp)
 90b72b8:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 90b72bc:	e0800217 	ldw	r2,8(fp)
 90b72c0:	1004c03a 	cmpne	r2,r2,zero
 90b72c4:	1000391e 	bne	r2,zero,90b73ac <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 90b72c8:	010000c4 	movi	r4,3
 90b72cc:	01401004 	movi	r5,64
 90b72d0:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b72d4:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 90b72d8:	e0bff717 	ldw	r2,-36(fp)
 90b72dc:	1005003a 	cmpeq	r2,r2,zero
 90b72e0:	1000ed1e 	bne	r2,zero,90b7698 <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 90b72e4:	00800044 	movi	r2,1
 90b72e8:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 90b72ec:	e0bffa17 	ldw	r2,-24(fp)
 90b72f0:	10800a04 	addi	r2,r2,40
 90b72f4:	1007883a 	mov	r3,r2
 90b72f8:	e0bff717 	ldw	r2,-36(fp)
 90b72fc:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 90b7300:	e0bff717 	ldw	r2,-36(fp)
 90b7304:	10800317 	ldw	r2,12(r2)
 90b7308:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 90b730c:	e0bff717 	ldw	r2,-36(fp)
 90b7310:	10800117 	ldw	r2,4(r2)
 90b7314:	10c00117 	ldw	r3,4(r2)
 90b7318:	e0bff617 	ldw	r2,-40(fp)
 90b731c:	10c0032e 	bgeu	r2,r3,90b732c <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 90b7320:	01024374 	movhi	r4,2317
 90b7324:	21027c04 	addi	r4,r4,2544
 90b7328:	90a537c0 	call	90a537c <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 90b732c:	e13ff617 	ldw	r4,-40(fp)
 90b7330:	e0fffc17 	ldw	r3,-16(fp)
 90b7334:	18800017 	ldw	r2,0(r3)
 90b7338:	20800015 	stw	r2,0(r4)
 90b733c:	18800117 	ldw	r2,4(r3)
 90b7340:	20800115 	stw	r2,4(r4)
 90b7344:	18800217 	ldw	r2,8(r3)
 90b7348:	20800215 	stw	r2,8(r4)
 90b734c:	18800317 	ldw	r2,12(r3)
 90b7350:	20800315 	stw	r2,12(r4)
 90b7354:	18800417 	ldw	r2,16(r3)
 90b7358:	20800415 	stw	r2,16(r4)
 90b735c:	18800517 	ldw	r2,20(r3)
 90b7360:	20800515 	stw	r2,20(r4)
 90b7364:	18800617 	ldw	r2,24(r3)
 90b7368:	20800615 	stw	r2,24(r4)
 90b736c:	18800717 	ldw	r2,28(r3)
 90b7370:	20800715 	stw	r2,28(r4)
 90b7374:	18800817 	ldw	r2,32(r3)
 90b7378:	20800815 	stw	r2,32(r4)
 90b737c:	18800917 	ldw	r2,36(r3)
 90b7380:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 90b7384:	e0bff617 	ldw	r2,-40(fp)
 90b7388:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 90b738c:	00800404 	movi	r2,16
 90b7390:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 90b7394:	e0bffb17 	ldw	r2,-20(fp)
 90b7398:	10800d17 	ldw	r2,52(r2)
 90b739c:	10800817 	ldw	r2,32(r2)
 90b73a0:	10800517 	ldw	r2,20(r2)
 90b73a4:	e0bff915 	stw	r2,-28(fp)
 90b73a8:	00003b06 	br	90b7498 <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 90b73ac:	e0800317 	ldw	r2,12(fp)
 90b73b0:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 90b73b4:	e0bff717 	ldw	r2,-36(fp)
 90b73b8:	10800117 	ldw	r2,4(r2)
 90b73bc:	1080080b 	ldhu	r2,32(r2)
 90b73c0:	10bfffcc 	andi	r2,r2,65535
 90b73c4:	10800218 	cmpnei	r2,r2,8
 90b73c8:	1000031e 	bne	r2,zero,90b73d8 <tcp_respond+0x1b4>
         domain = AF_INET;
 90b73cc:	00800084 	movi	r2,2
 90b73d0:	e0bff915 	stw	r2,-28(fp)
 90b73d4:	00000206 	br	90b73e0 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 90b73d8:	008000c4 	movi	r2,3
 90b73dc:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 90b73e0:	e0bff717 	ldw	r2,-36(fp)
 90b73e4:	11000617 	ldw	r4,24(r2)
 90b73e8:	90ab5940 	call	90ab594 <m_freem>
      m->m_next = 0;
 90b73ec:	e0bff717 	ldw	r2,-36(fp)
 90b73f0:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 90b73f4:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 90b73f8:	e0fff717 	ldw	r3,-36(fp)
 90b73fc:	00800a04 	movi	r2,40
 90b7400:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 90b7404:	e0bffc17 	ldw	r2,-16(fp)
 90b7408:	1080058b 	ldhu	r2,22(r2)
 90b740c:	e0bff50d 	sth	r2,-44(fp)
 90b7410:	e0bffc17 	ldw	r2,-16(fp)
 90b7414:	10c0050b 	ldhu	r3,20(r2)
 90b7418:	e0bffc17 	ldw	r2,-16(fp)
 90b741c:	10c0058d 	sth	r3,22(r2)
 90b7420:	e0fffc17 	ldw	r3,-16(fp)
 90b7424:	e0bff50b 	ldhu	r2,-44(fp)
 90b7428:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 90b742c:	e0bff717 	ldw	r2,-36(fp)
 90b7430:	10800117 	ldw	r2,4(r2)
 90b7434:	1080080b 	ldhu	r2,32(r2)
 90b7438:	10bfffcc 	andi	r2,r2,65535
 90b743c:	10800218 	cmpnei	r2,r2,8
 90b7440:	10000a1e 	bne	r2,zero,90b746c <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 90b7444:	e0bffc17 	ldw	r2,-16(fp)
 90b7448:	10800417 	ldw	r2,16(r2)
 90b744c:	e0bff415 	stw	r2,-48(fp)
 90b7450:	e0bffc17 	ldw	r2,-16(fp)
 90b7454:	10c00317 	ldw	r3,12(r2)
 90b7458:	e0bffc17 	ldw	r2,-16(fp)
 90b745c:	10c00415 	stw	r3,16(r2)
 90b7460:	e0fffc17 	ldw	r3,-16(fp)
 90b7464:	e0bff417 	ldw	r2,-48(fp)
 90b7468:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 90b746c:	e0800217 	ldw	r2,8(fp)
 90b7470:	1080010c 	andi	r2,r2,4
 90b7474:	1005003a 	cmpeq	r2,r2,zero
 90b7478:	1000071e 	bne	r2,zero,90b7498 <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 90b747c:	008243b4 	movhi	r2,2318
 90b7480:	10b72804 	addi	r2,r2,-9056
 90b7484:	10800e17 	ldw	r2,56(r2)
 90b7488:	10c00044 	addi	r3,r2,1
 90b748c:	008243b4 	movhi	r2,2318
 90b7490:	10b72804 	addi	r2,r2,-9056
 90b7494:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 90b7498:	e0bffe17 	ldw	r2,-8(fp)
 90b749c:	1004d63a 	srli	r2,r2,24
 90b74a0:	10c03fcc 	andi	r3,r2,255
 90b74a4:	e0bffe17 	ldw	r2,-8(fp)
 90b74a8:	1004d23a 	srli	r2,r2,8
 90b74ac:	10bfc00c 	andi	r2,r2,65280
 90b74b0:	1886b03a 	or	r3,r3,r2
 90b74b4:	e0bffe17 	ldw	r2,-8(fp)
 90b74b8:	10bfc00c 	andi	r2,r2,65280
 90b74bc:	1004923a 	slli	r2,r2,8
 90b74c0:	1886b03a 	or	r3,r3,r2
 90b74c4:	e0bffe17 	ldw	r2,-8(fp)
 90b74c8:	10803fcc 	andi	r2,r2,255
 90b74cc:	1004963a 	slli	r2,r2,24
 90b74d0:	1886b03a 	or	r3,r3,r2
 90b74d4:	e0bffc17 	ldw	r2,-16(fp)
 90b74d8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 90b74dc:	e0bffd17 	ldw	r2,-12(fp)
 90b74e0:	1004d63a 	srli	r2,r2,24
 90b74e4:	10c03fcc 	andi	r3,r2,255
 90b74e8:	e0bffd17 	ldw	r2,-12(fp)
 90b74ec:	1004d23a 	srli	r2,r2,8
 90b74f0:	10bfc00c 	andi	r2,r2,65280
 90b74f4:	1886b03a 	or	r3,r3,r2
 90b74f8:	e0bffd17 	ldw	r2,-12(fp)
 90b74fc:	10bfc00c 	andi	r2,r2,65280
 90b7500:	1004923a 	slli	r2,r2,8
 90b7504:	1886b03a 	or	r3,r3,r2
 90b7508:	e0bffd17 	ldw	r2,-12(fp)
 90b750c:	10803fcc 	andi	r2,r2,255
 90b7510:	1004963a 	slli	r2,r2,24
 90b7514:	1886b03a 	or	r3,r3,r2
 90b7518:	e0bffc17 	ldw	r2,-16(fp)
 90b751c:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 90b7520:	e0fffc17 	ldw	r3,-16(fp)
 90b7524:	00801404 	movi	r2,80
 90b7528:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 90b752c:	e0800217 	ldw	r2,8(fp)
 90b7530:	1007883a 	mov	r3,r2
 90b7534:	e0bffc17 	ldw	r2,-16(fp)
 90b7538:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 90b753c:	e0bff817 	ldw	r2,-32(fp)
 90b7540:	10bfffcc 	andi	r2,r2,65535
 90b7544:	1004d23a 	srli	r2,r2,8
 90b7548:	10803fcc 	andi	r2,r2,255
 90b754c:	1009883a 	mov	r4,r2
 90b7550:	e0bff817 	ldw	r2,-32(fp)
 90b7554:	10bfffcc 	andi	r2,r2,65535
 90b7558:	1004923a 	slli	r2,r2,8
 90b755c:	1007883a 	mov	r3,r2
 90b7560:	00bfc004 	movi	r2,-256
 90b7564:	1884703a 	and	r2,r3,r2
 90b7568:	2084b03a 	or	r2,r4,r2
 90b756c:	1007883a 	mov	r3,r2
 90b7570:	e0bffc17 	ldw	r2,-16(fp)
 90b7574:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 90b7578:	e0bffc17 	ldw	r2,-16(fp)
 90b757c:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 90b7580:	e0bff917 	ldw	r2,-28(fp)
 90b7584:	108000a0 	cmpeqi	r2,r2,2
 90b7588:	1000011e 	bne	r2,zero,90b7590 <tcp_respond+0x36c>
 90b758c:	00004106 	br	90b7694 <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 90b7590:	e0bffc17 	ldw	r2,-16(fp)
 90b7594:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 90b7598:	e0bffa17 	ldw	r2,-24(fp)
 90b759c:	10800a04 	addi	r2,r2,40
 90b75a0:	1007883a 	mov	r3,r2
 90b75a4:	e0bff317 	ldw	r2,-52(fp)
 90b75a8:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 90b75ac:	e0bff717 	ldw	r2,-36(fp)
 90b75b0:	10800117 	ldw	r2,4(r2)
 90b75b4:	10c00117 	ldw	r3,4(r2)
 90b75b8:	00824374 	movhi	r2,2317
 90b75bc:	108f0704 	addi	r2,r2,15388
 90b75c0:	10800017 	ldw	r2,0(r2)
 90b75c4:	1885883a 	add	r2,r3,r2
 90b75c8:	1007883a 	mov	r3,r2
 90b75cc:	e0bff317 	ldw	r2,-52(fp)
 90b75d0:	10c00436 	bltu	r2,r3,90b75e4 <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 90b75d4:	e0fff317 	ldw	r3,-52(fp)
 90b75d8:	e0bff717 	ldw	r2,-36(fp)
 90b75dc:	10c00315 	stw	r3,12(r2)
 90b75e0:	00001206 	br	90b762c <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 90b75e4:	e0bff717 	ldw	r2,-36(fp)
 90b75e8:	11000117 	ldw	r4,4(r2)
 90b75ec:	e0bff717 	ldw	r2,-36(fp)
 90b75f0:	10800117 	ldw	r2,4(r2)
 90b75f4:	10c00117 	ldw	r3,4(r2)
 90b75f8:	00824374 	movhi	r2,2317
 90b75fc:	108f0704 	addi	r2,r2,15388
 90b7600:	10800017 	ldw	r2,0(r2)
 90b7604:	1885883a 	add	r2,r3,r2
 90b7608:	20800315 	stw	r2,12(r4)
 90b760c:	20c00317 	ldw	r3,12(r4)
 90b7610:	e0bff717 	ldw	r2,-36(fp)
 90b7614:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 90b7618:	e0bff717 	ldw	r2,-36(fp)
 90b761c:	11000317 	ldw	r4,12(r2)
 90b7620:	e17ff317 	ldw	r5,-52(fp)
 90b7624:	01800a04 	movi	r6,40
 90b7628:	90895000 	call	9089500 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 90b762c:	e0bffb17 	ldw	r2,-20(fp)
 90b7630:	1004c03a 	cmpne	r2,r2,zero
 90b7634:	1000031e 	bne	r2,zero,90b7644 <tcp_respond+0x420>
              m_freem(m);
 90b7638:	e13ff717 	ldw	r4,-36(fp)
 90b763c:	90ab5940 	call	90ab594 <m_freem>
 90b7640:	00001506 	br	90b7698 <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 90b7644:	e0bffb17 	ldw	r2,-20(fp)
 90b7648:	10800d17 	ldw	r2,52(r2)
 90b764c:	1005003a 	cmpeq	r2,r2,zero
 90b7650:	10000c1e 	bne	r2,zero,90b7684 <tcp_respond+0x460>
 90b7654:	e0bffb17 	ldw	r2,-20(fp)
 90b7658:	10800d17 	ldw	r2,52(r2)
 90b765c:	10800817 	ldw	r2,32(r2)
 90b7660:	1005003a 	cmpeq	r2,r2,zero
 90b7664:	1000071e 	bne	r2,zero,90b7684 <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 90b7668:	e0bffb17 	ldw	r2,-20(fp)
 90b766c:	10800d17 	ldw	r2,52(r2)
 90b7670:	10800817 	ldw	r2,32(r2)
 90b7674:	11401f17 	ldw	r5,124(r2)
 90b7678:	e13ff717 	ldw	r4,-36(fp)
 90b767c:	90abfc80 	call	90abfc8 <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 90b7680:	00000506 	br	90b7698 <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 90b7684:	e13ff717 	ldw	r4,-36(fp)
 90b7688:	000b883a 	mov	r5,zero
 90b768c:	90abfc80 	call	90abfc8 <ip_output>
		 }

         break;
 90b7690:	00000106 	br	90b7698 <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 90b7694:	90aa4780 	call	90aa478 <dtrap>
         break;
   }
   return;
}
 90b7698:	e037883a 	mov	sp,fp
 90b769c:	dfc00117 	ldw	ra,4(sp)
 90b76a0:	df000017 	ldw	fp,0(sp)
 90b76a4:	dec00204 	addi	sp,sp,8
 90b76a8:	f800283a 	ret

090b76ac <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 90b76ac:	defffa04 	addi	sp,sp,-24
 90b76b0:	dfc00515 	stw	ra,20(sp)
 90b76b4:	df000415 	stw	fp,16(sp)
 90b76b8:	df000404 	addi	fp,sp,16
 90b76bc:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 90b76c0:	01002504 	movi	r4,148
 90b76c4:	90aaefc0 	call	90aaefc <npalloc>
 90b76c8:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 90b76cc:	e0bffd17 	ldw	r2,-12(fp)
 90b76d0:	1004c03a 	cmpne	r2,r2,zero
 90b76d4:	1000021e 	bne	r2,zero,90b76e0 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 90b76d8:	e03fff15 	stw	zero,-4(fp)
 90b76dc:	00003306 	br	90b77ac <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 90b76e0:	e0fffd17 	ldw	r3,-12(fp)
 90b76e4:	e0bffd17 	ldw	r2,-12(fp)
 90b76e8:	10c00115 	stw	r3,4(r2)
 90b76ec:	e0bffd17 	ldw	r2,-12(fp)
 90b76f0:	10c00117 	ldw	r3,4(r2)
 90b76f4:	e0bffd17 	ldw	r2,-12(fp)
 90b76f8:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 90b76fc:	e0fffd17 	ldw	r3,-12(fp)
 90b7700:	00816d04 	movi	r2,1460
 90b7704:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 90b7708:	e0bffd17 	ldw	r2,-12(fp)
 90b770c:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 90b7710:	e0fffd17 	ldw	r3,-12(fp)
 90b7714:	e0bffe17 	ldw	r2,-8(fp)
 90b7718:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 90b771c:	e0bffd17 	ldw	r2,-12(fp)
 90b7720:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 90b7724:	e0fffd17 	ldw	r3,-12(fp)
 90b7728:	00800604 	movi	r2,24
 90b772c:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 90b7730:	00800304 	movi	r2,12
 90b7734:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 90b7738:	e0fffc0f 	ldh	r3,-16(fp)
 90b773c:	e0bffd17 	ldw	r2,-12(fp)
 90b7740:	10c00815 	stw	r3,32(r2)
 90b7744:	e0bffd17 	ldw	r2,-12(fp)
 90b7748:	10800817 	ldw	r2,32(r2)
 90b774c:	10800088 	cmpgei	r2,r2,2
 90b7750:	1000041e 	bne	r2,zero,90b7764 <tcp_newtcpcb+0xb8>
 90b7754:	e0fffd17 	ldw	r3,-12(fp)
 90b7758:	00800084 	movi	r2,2
 90b775c:	18800815 	stw	r2,32(r3)
 90b7760:	00000706 	br	90b7780 <tcp_newtcpcb+0xd4>
 90b7764:	e0bffd17 	ldw	r2,-12(fp)
 90b7768:	10800817 	ldw	r2,32(r2)
 90b776c:	10802050 	cmplti	r2,r2,129
 90b7770:	1000031e 	bne	r2,zero,90b7780 <tcp_newtcpcb+0xd4>
 90b7774:	e0fffd17 	ldw	r3,-12(fp)
 90b7778:	00802004 	movi	r2,128
 90b777c:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 90b7780:	e0fffd17 	ldw	r3,-12(fp)
 90b7784:	0082da04 	movi	r2,2920
 90b7788:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 90b778c:	e0fffd17 	ldw	r3,-12(fp)
 90b7790:	00bfffd4 	movui	r2,65535
 90b7794:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 90b7798:	e0fffd17 	ldw	r3,-12(fp)
 90b779c:	e0bffe17 	ldw	r2,-8(fp)
 90b77a0:	10c00915 	stw	r3,36(r2)
   return (tp);
 90b77a4:	e0bffd17 	ldw	r2,-12(fp)
 90b77a8:	e0bfff15 	stw	r2,-4(fp)
 90b77ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90b77b0:	e037883a 	mov	sp,fp
 90b77b4:	dfc00117 	ldw	ra,4(sp)
 90b77b8:	df000017 	ldw	fp,0(sp)
 90b77bc:	dec00204 	addi	sp,sp,8
 90b77c0:	f800283a 	ret

090b77c4 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 90b77c4:	defffb04 	addi	sp,sp,-20
 90b77c8:	dfc00415 	stw	ra,16(sp)
 90b77cc:	df000315 	stw	fp,12(sp)
 90b77d0:	df000304 	addi	fp,sp,12
 90b77d4:	e13ffe15 	stw	r4,-8(fp)
 90b77d8:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b77dc:	e0bffe17 	ldw	r2,-8(fp)
 90b77e0:	10800d17 	ldw	r2,52(r2)
 90b77e4:	10800817 	ldw	r2,32(r2)
 90b77e8:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 90b77ec:	e0bffe17 	ldw	r2,-8(fp)
 90b77f0:	10800217 	ldw	r2,8(r2)
 90b77f4:	108000d0 	cmplti	r2,r2,3
 90b77f8:	10000c1e 	bne	r2,zero,90b782c <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 90b77fc:	e0bffe17 	ldw	r2,-8(fp)
 90b7800:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 90b7804:	e13ffe17 	ldw	r4,-8(fp)
 90b7808:	90b5d540 	call	90b5d54 <tcp_output>
      tcpstat.tcps_drops++;
 90b780c:	008243b4 	movhi	r2,2318
 90b7810:	10b75604 	addi	r2,r2,-8872
 90b7814:	10800317 	ldw	r2,12(r2)
 90b7818:	10c00044 	addi	r3,r2,1
 90b781c:	008243b4 	movhi	r2,2318
 90b7820:	10b75604 	addi	r2,r2,-8872
 90b7824:	10c00315 	stw	r3,12(r2)
 90b7828:	00000706 	br	90b7848 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 90b782c:	008243b4 	movhi	r2,2318
 90b7830:	10b75604 	addi	r2,r2,-8872
 90b7834:	10800417 	ldw	r2,16(r2)
 90b7838:	10c00044 	addi	r3,r2,1
 90b783c:	008243b4 	movhi	r2,2318
 90b7840:	10b75604 	addi	r2,r2,-8872
 90b7844:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 90b7848:	e0fffd17 	ldw	r3,-12(fp)
 90b784c:	e0bfff17 	ldw	r2,-4(fp)
 90b7850:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 90b7854:	e13ffe17 	ldw	r4,-8(fp)
 90b7858:	90b78700 	call	90b7870 <tcp_close>
}
 90b785c:	e037883a 	mov	sp,fp
 90b7860:	dfc00117 	ldw	ra,4(sp)
 90b7864:	df000017 	ldw	fp,0(sp)
 90b7868:	dec00204 	addi	sp,sp,8
 90b786c:	f800283a 	ret

090b7870 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 90b7870:	defff904 	addi	sp,sp,-28
 90b7874:	dfc00615 	stw	ra,24(sp)
 90b7878:	df000515 	stw	fp,20(sp)
 90b787c:	df000504 	addi	fp,sp,20
 90b7880:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 90b7884:	e0bfff17 	ldw	r2,-4(fp)
 90b7888:	10800d17 	ldw	r2,52(r2)
 90b788c:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 90b7890:	e0bffd17 	ldw	r2,-12(fp)
 90b7894:	10800817 	ldw	r2,32(r2)
 90b7898:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 90b789c:	e0bfff17 	ldw	r2,-4(fp)
 90b78a0:	10800017 	ldw	r2,0(r2)
 90b78a4:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 90b78a8:	00000c06 	br	90b78dc <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 90b78ac:	e0bffe17 	ldw	r2,-8(fp)
 90b78b0:	10800017 	ldw	r2,0(r2)
 90b78b4:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 90b78b8:	e0bffe17 	ldw	r2,-8(fp)
 90b78bc:	11000117 	ldw	r4,4(r2)
 90b78c0:	90abb240 	call	90abb24 <dtom>
 90b78c4:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 90b78c8:	e0bffe17 	ldw	r2,-8(fp)
 90b78cc:	11000117 	ldw	r4,4(r2)
 90b78d0:	90abbcc0 	call	90abbcc <remque>
      m_freem (m);
 90b78d4:	e13ffb17 	ldw	r4,-20(fp)
 90b78d8:	90ab5940 	call	90ab594 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 90b78dc:	e0ffff17 	ldw	r3,-4(fp)
 90b78e0:	e0bffe17 	ldw	r2,-8(fp)
 90b78e4:	10fff11e 	bne	r2,r3,90b78ac <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 90b78e8:	e0bfff17 	ldw	r2,-4(fp)
 90b78ec:	10800c17 	ldw	r2,48(r2)
 90b78f0:	1005003a 	cmpeq	r2,r2,zero
 90b78f4:	1000031e 	bne	r2,zero,90b7904 <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 90b78f8:	e0bfff17 	ldw	r2,-4(fp)
 90b78fc:	11000c17 	ldw	r4,48(r2)
 90b7900:	90aaff00 	call	90aaff0 <npfree>
   TCB_FREE (tp);
 90b7904:	e13fff17 	ldw	r4,-4(fp)
 90b7908:	90aaff00 	call	90aaff0 <npfree>
   inp->inp_ppcb = 0;
 90b790c:	e0bffd17 	ldw	r2,-12(fp)
 90b7910:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 90b7914:	e13ffc17 	ldw	r4,-16(fp)
 90b7918:	90b13000 	call	90b1300 <soisdisconnected>
   in_pcbdetach(inp);
 90b791c:	e13ffd17 	ldw	r4,-12(fp)
 90b7920:	90c78bc0 	call	90c78bc <in_pcbdetach>
   tcpstat.tcps_closed++;
 90b7924:	008243b4 	movhi	r2,2318
 90b7928:	10b75604 	addi	r2,r2,-8872
 90b792c:	10800517 	ldw	r2,20(r2)
 90b7930:	10c00044 	addi	r3,r2,1
 90b7934:	008243b4 	movhi	r2,2318
 90b7938:	10b75604 	addi	r2,r2,-8872
 90b793c:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 90b7940:	0005883a 	mov	r2,zero
}
 90b7944:	e037883a 	mov	sp,fp
 90b7948:	dfc00117 	ldw	ra,4(sp)
 90b794c:	df000017 	ldw	fp,0(sp)
 90b7950:	dec00204 	addi	sp,sp,8
 90b7954:	f800283a 	ret

090b7958 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 90b7958:	defffd04 	addi	sp,sp,-12
 90b795c:	df000215 	stw	fp,8(sp)
 90b7960:	df000204 	addi	fp,sp,8
 90b7964:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 90b7968:	e0bfff17 	ldw	r2,-4(fp)
 90b796c:	10800917 	ldw	r2,36(r2)
 90b7970:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 90b7974:	e0bffe17 	ldw	r2,-8(fp)
 90b7978:	1005003a 	cmpeq	r2,r2,zero
 90b797c:	1000051e 	bne	r2,zero,90b7994 <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 90b7980:	e0bffe17 	ldw	r2,-8(fp)
 90b7984:	10800a0b 	ldhu	r2,40(r2)
 90b7988:	10ffffcc 	andi	r3,r2,65535
 90b798c:	e0bffe17 	ldw	r2,-8(fp)
 90b7990:	10c01b15 	stw	r3,108(r2)
}
 90b7994:	e037883a 	mov	sp,fp
 90b7998:	df000017 	ldw	fp,0(sp)
 90b799c:	dec00104 	addi	sp,sp,4
 90b79a0:	f800283a 	ret

090b79a4 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 90b79a4:	defffc04 	addi	sp,sp,-16
 90b79a8:	df000315 	stw	fp,12(sp)
 90b79ac:	df000304 	addi	fp,sp,12
 90b79b0:	e13ffe15 	stw	r4,-8(fp)
 90b79b4:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 90b79b8:	e0bffe17 	ldw	r2,-8(fp)
 90b79bc:	108000c4 	addi	r2,r2,3
 90b79c0:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 90b79c4:	e03ffd15 	stw	zero,-12(fp)
 90b79c8:	00000d06 	br	90b7a00 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 90b79cc:	e0bfff17 	ldw	r2,-4(fp)
 90b79d0:	1007883a 	mov	r3,r2
 90b79d4:	e0bffe17 	ldw	r2,-8(fp)
 90b79d8:	10c00005 	stb	r3,0(r2)
 90b79dc:	e0bffe17 	ldw	r2,-8(fp)
 90b79e0:	10bfffc4 	addi	r2,r2,-1
 90b79e4:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 90b79e8:	e0bfff17 	ldw	r2,-4(fp)
 90b79ec:	1004d23a 	srli	r2,r2,8
 90b79f0:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 90b79f4:	e0bffd17 	ldw	r2,-12(fp)
 90b79f8:	10800044 	addi	r2,r2,1
 90b79fc:	e0bffd15 	stw	r2,-12(fp)
 90b7a00:	e0bffd17 	ldw	r2,-12(fp)
 90b7a04:	10800110 	cmplti	r2,r2,4
 90b7a08:	103ff01e 	bne	r2,zero,90b79cc <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 90b7a0c:	e0bffe17 	ldw	r2,-8(fp)
 90b7a10:	10800144 	addi	r2,r2,5
}
 90b7a14:	e037883a 	mov	sp,fp
 90b7a18:	df000017 	ldw	fp,0(sp)
 90b7a1c:	dec00104 	addi	sp,sp,4
 90b7a20:	f800283a 	ret

090b7a24 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 90b7a24:	defffc04 	addi	sp,sp,-16
 90b7a28:	df000315 	stw	fp,12(sp)
 90b7a2c:	df000304 	addi	fp,sp,12
 90b7a30:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 90b7a34:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 90b7a38:	e03ffe15 	stw	zero,-8(fp)
 90b7a3c:	00000f06 	br	90b7a7c <tcp_getseq+0x58>
   {
      seq <<= 8;
 90b7a40:	e0bffd17 	ldw	r2,-12(fp)
 90b7a44:	1004923a 	slli	r2,r2,8
 90b7a48:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 90b7a4c:	e0bfff17 	ldw	r2,-4(fp)
 90b7a50:	10800003 	ldbu	r2,0(r2)
 90b7a54:	10c03fcc 	andi	r3,r2,255
 90b7a58:	e0bffd17 	ldw	r2,-12(fp)
 90b7a5c:	10c5883a 	add	r2,r2,r3
 90b7a60:	e0bffd15 	stw	r2,-12(fp)
 90b7a64:	e0bfff17 	ldw	r2,-4(fp)
 90b7a68:	10800044 	addi	r2,r2,1
 90b7a6c:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 90b7a70:	e0bffe17 	ldw	r2,-8(fp)
 90b7a74:	10800044 	addi	r2,r2,1
 90b7a78:	e0bffe15 	stw	r2,-8(fp)
 90b7a7c:	e0bffe17 	ldw	r2,-8(fp)
 90b7a80:	10800110 	cmplti	r2,r2,4
 90b7a84:	103fee1e 	bne	r2,zero,90b7a40 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 90b7a88:	e0bffd17 	ldw	r2,-12(fp)
}
 90b7a8c:	e037883a 	mov	sp,fp
 90b7a90:	df000017 	ldw	fp,0(sp)
 90b7a94:	dec00104 	addi	sp,sp,4
 90b7a98:	f800283a 	ret

090b7a9c <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 90b7a9c:	defff704 	addi	sp,sp,-36
 90b7aa0:	dfc00815 	stw	ra,32(sp)
 90b7aa4:	df000715 	stw	fp,28(sp)
 90b7aa8:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 90b7aac:	d0a03d17 	ldw	r2,-32524(gp)
 90b7ab0:	100490fa 	slli	r2,r2,3
 90b7ab4:	d0a0b515 	stw	r2,-32044(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 90b7ab8:	008243b4 	movhi	r2,2318
 90b7abc:	10b72304 	addi	r2,r2,-9076
 90b7ac0:	10800017 	ldw	r2,0(r2)
 90b7ac4:	e0bffb15 	stw	r2,-20(fp)
 90b7ac8:	00008306 	br	90b7cd8 <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 90b7acc:	e0bffb17 	ldw	r2,-20(fp)
 90b7ad0:	10800017 	ldw	r2,0(r2)
 90b7ad4:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 90b7ad8:	e0bffb17 	ldw	r2,-20(fp)
 90b7adc:	10800983 	ldbu	r2,38(r2)
 90b7ae0:	10803fcc 	andi	r2,r2,255
 90b7ae4:	1080201c 	xori	r2,r2,128
 90b7ae8:	10bfe004 	addi	r2,r2,-128
 90b7aec:	10800058 	cmpnei	r2,r2,1
 90b7af0:	1000471e 	bne	r2,zero,90b7c10 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 90b7af4:	e0bffb17 	ldw	r2,-20(fp)
 90b7af8:	10800117 	ldw	r2,4(r2)
 90b7afc:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 90b7b00:	e0bfff17 	ldw	r2,-4(fp)
 90b7b04:	1005003a 	cmpeq	r2,r2,zero
 90b7b08:	1000711e 	bne	r2,zero,90b7cd0 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 90b7b0c:	e0bfff17 	ldw	r2,-4(fp)
 90b7b10:	10800017 	ldw	r2,0(r2)
 90b7b14:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 90b7b18:	e0bffb17 	ldw	r2,-20(fp)
 90b7b1c:	10800117 	ldw	r2,4(r2)
 90b7b20:	10800917 	ldw	r2,36(r2)
 90b7b24:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 90b7b28:	e0bffd17 	ldw	r2,-12(fp)
 90b7b2c:	1005003a 	cmpeq	r2,r2,zero
 90b7b30:	1000671e 	bne	r2,zero,90b7cd0 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 90b7b34:	e03ffc15 	stw	zero,-16(fp)
 90b7b38:	00002d06 	br	90b7bf0 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 90b7b3c:	e0bffc17 	ldw	r2,-16(fp)
 90b7b40:	e0fffd17 	ldw	r3,-12(fp)
 90b7b44:	1085883a 	add	r2,r2,r2
 90b7b48:	1085883a 	add	r2,r2,r2
 90b7b4c:	10c5883a 	add	r2,r2,r3
 90b7b50:	10800304 	addi	r2,r2,12
 90b7b54:	10800017 	ldw	r2,0(r2)
 90b7b58:	1005003a 	cmpeq	r2,r2,zero
 90b7b5c:	1000211e 	bne	r2,zero,90b7be4 <tcp_slowtimo+0x148>
 90b7b60:	e0fffc17 	ldw	r3,-16(fp)
 90b7b64:	e13ffd17 	ldw	r4,-12(fp)
 90b7b68:	18c5883a 	add	r2,r3,r3
 90b7b6c:	1085883a 	add	r2,r2,r2
 90b7b70:	1105883a 	add	r2,r2,r4
 90b7b74:	10800304 	addi	r2,r2,12
 90b7b78:	10800017 	ldw	r2,0(r2)
 90b7b7c:	117fffc4 	addi	r5,r2,-1
 90b7b80:	e13ffd17 	ldw	r4,-12(fp)
 90b7b84:	18c5883a 	add	r2,r3,r3
 90b7b88:	1085883a 	add	r2,r2,r2
 90b7b8c:	1105883a 	add	r2,r2,r4
 90b7b90:	10800304 	addi	r2,r2,12
 90b7b94:	11400015 	stw	r5,0(r2)
 90b7b98:	e13ffd17 	ldw	r4,-12(fp)
 90b7b9c:	18c5883a 	add	r2,r3,r3
 90b7ba0:	1085883a 	add	r2,r2,r2
 90b7ba4:	1105883a 	add	r2,r2,r4
 90b7ba8:	10800304 	addi	r2,r2,12
 90b7bac:	10800017 	ldw	r2,0(r2)
 90b7bb0:	1004c03a 	cmpne	r2,r2,zero
 90b7bb4:	10000b1e 	bne	r2,zero,90b7be4 <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 90b7bb8:	e0fffb17 	ldw	r3,-20(fp)
 90b7bbc:	008004c4 	movi	r2,19
 90b7bc0:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 90b7bc4:	e1bffc17 	ldw	r6,-16(fp)
 90b7bc8:	e13ffb17 	ldw	r4,-20(fp)
 90b7bcc:	000b883a 	mov	r5,zero
 90b7bd0:	90b82340 	call	90b8234 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 90b7bd4:	e0bffe17 	ldw	r2,-8(fp)
 90b7bd8:	10c00117 	ldw	r3,4(r2)
 90b7bdc:	e0bfff17 	ldw	r2,-4(fp)
 90b7be0:	18803b1e 	bne	r3,r2,90b7cd0 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 90b7be4:	e0bffc17 	ldw	r2,-16(fp)
 90b7be8:	10800044 	addi	r2,r2,1
 90b7bec:	e0bffc15 	stw	r2,-16(fp)
 90b7bf0:	e0bffc17 	ldw	r2,-16(fp)
 90b7bf4:	10800110 	cmplti	r2,r2,4
 90b7bf8:	103fd01e 	bne	r2,zero,90b7b3c <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 90b7bfc:	e0bffd17 	ldw	r2,-12(fp)
 90b7c00:	10801d17 	ldw	r2,116(r2)
 90b7c04:	10c00044 	addi	r3,r2,1
 90b7c08:	e0bffd17 	ldw	r2,-12(fp)
 90b7c0c:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 90b7c10:	e0bffb17 	ldw	r2,-20(fp)
 90b7c14:	10800a04 	addi	r2,r2,40
 90b7c18:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 90b7c1c:	e0bff917 	ldw	r2,-28(fp)
 90b7c20:	1080070b 	ldhu	r2,28(r2)
 90b7c24:	10bfffcc 	andi	r2,r2,65535
 90b7c28:	1080020c 	andi	r2,r2,8
 90b7c2c:	1005003a 	cmpeq	r2,r2,zero
 90b7c30:	10000d1e 	bne	r2,zero,90b7c68 <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 90b7c34:	00824374 	movhi	r2,2317
 90b7c38:	108f3604 	addi	r2,r2,15576
 90b7c3c:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 90b7c40:	01024374 	movhi	r4,2317
 90b7c44:	210f3604 	addi	r4,r4,15576
 90b7c48:	90a5e940 	call	90a5e94 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 90b7c4c:	e0bff917 	ldw	r2,-28(fp)
 90b7c50:	10c0070b 	ldhu	r3,28(r2)
 90b7c54:	00bffdc4 	movi	r2,-9
 90b7c58:	1884703a 	and	r2,r3,r2
 90b7c5c:	1007883a 	mov	r3,r2
 90b7c60:	e0bff917 	ldw	r2,-28(fp)
 90b7c64:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 90b7c68:	e0bffb17 	ldw	r2,-20(fp)
 90b7c6c:	10801204 	addi	r2,r2,72
 90b7c70:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 90b7c74:	e0bff917 	ldw	r2,-28(fp)
 90b7c78:	1080070b 	ldhu	r2,28(r2)
 90b7c7c:	10bfffcc 	andi	r2,r2,65535
 90b7c80:	1080020c 	andi	r2,r2,8
 90b7c84:	1005003a 	cmpeq	r2,r2,zero
 90b7c88:	10000d1e 	bne	r2,zero,90b7cc0 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 90b7c8c:	00824374 	movhi	r2,2317
 90b7c90:	108f3604 	addi	r2,r2,15576
 90b7c94:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 90b7c98:	01024374 	movhi	r4,2317
 90b7c9c:	210f3604 	addi	r4,r4,15576
 90b7ca0:	90a5e940 	call	90a5e94 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 90b7ca4:	e0bff917 	ldw	r2,-28(fp)
 90b7ca8:	10c0070b 	ldhu	r3,28(r2)
 90b7cac:	00bffdc4 	movi	r2,-9
 90b7cb0:	1884703a 	and	r2,r3,r2
 90b7cb4:	1007883a 	mov	r3,r2
 90b7cb8:	e0bff917 	ldw	r2,-28(fp)
 90b7cbc:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 90b7cc0:	e0bffb17 	ldw	r2,-20(fp)
 90b7cc4:	10800904 	addi	r2,r2,36
 90b7cc8:	1009883a 	mov	r4,r2
 90b7ccc:	90a5e940 	call	90a5e94 <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 90b7cd0:	e0bffa17 	ldw	r2,-24(fp)
 90b7cd4:	e0bffb15 	stw	r2,-20(fp)
 90b7cd8:	e0bffb17 	ldw	r2,-20(fp)
 90b7cdc:	1004c03a 	cmpne	r2,r2,zero
 90b7ce0:	103f7a1e 	bne	r2,zero,90b7acc <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 90b7ce4:	00824374 	movhi	r2,2317
 90b7ce8:	108f3b04 	addi	r2,r2,15596
 90b7cec:	10c00017 	ldw	r3,0(r2)
 90b7cf0:	00be9fd4 	movui	r2,64127
 90b7cf4:	1887883a 	add	r3,r3,r2
 90b7cf8:	00824374 	movhi	r2,2317
 90b7cfc:	108f3b04 	addi	r2,r2,15596
 90b7d00:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 90b7d04:	00824374 	movhi	r2,2317
 90b7d08:	108f3b04 	addi	r2,r2,15596
 90b7d0c:	10800017 	ldw	r2,0(r2)
 90b7d10:	10bfc02c 	andhi	r2,r2,65280
 90b7d14:	1005003a 	cmpeq	r2,r2,zero
 90b7d18:	1000031e 	bne	r2,zero,90b7d28 <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 90b7d1c:	00824374 	movhi	r2,2317
 90b7d20:	108f3b04 	addi	r2,r2,15596
 90b7d24:	10000015 	stw	zero,0(r2)
}
 90b7d28:	e037883a 	mov	sp,fp
 90b7d2c:	dfc00117 	ldw	ra,4(sp)
 90b7d30:	df000017 	ldw	fp,0(sp)
 90b7d34:	dec00204 	addi	sp,sp,8
 90b7d38:	f800283a 	ret

090b7d3c <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 90b7d3c:	defffd04 	addi	sp,sp,-12
 90b7d40:	df000215 	stw	fp,8(sp)
 90b7d44:	df000204 	addi	fp,sp,8
 90b7d48:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 90b7d4c:	e03ffe15 	stw	zero,-8(fp)
 90b7d50:	00000a06 	br	90b7d7c <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 90b7d54:	e0bffe17 	ldw	r2,-8(fp)
 90b7d58:	e0ffff17 	ldw	r3,-4(fp)
 90b7d5c:	1085883a 	add	r2,r2,r2
 90b7d60:	1085883a 	add	r2,r2,r2
 90b7d64:	10c5883a 	add	r2,r2,r3
 90b7d68:	10800304 	addi	r2,r2,12
 90b7d6c:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 90b7d70:	e0bffe17 	ldw	r2,-8(fp)
 90b7d74:	10800044 	addi	r2,r2,1
 90b7d78:	e0bffe15 	stw	r2,-8(fp)
 90b7d7c:	e0bffe17 	ldw	r2,-8(fp)
 90b7d80:	10800110 	cmplti	r2,r2,4
 90b7d84:	103ff31e 	bne	r2,zero,90b7d54 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 90b7d88:	e037883a 	mov	sp,fp
 90b7d8c:	df000017 	ldw	fp,0(sp)
 90b7d90:	dec00104 	addi	sp,sp,4
 90b7d94:	f800283a 	ret

090b7d98 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 90b7d98:	defff504 	addi	sp,sp,-44
 90b7d9c:	dfc00a15 	stw	ra,40(sp)
 90b7da0:	df000915 	stw	fp,36(sp)
 90b7da4:	df000904 	addi	fp,sp,36
 90b7da8:	e13ffb15 	stw	r4,-20(fp)
 90b7dac:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 90b7db0:	e0bffc17 	ldw	r2,-16(fp)
 90b7db4:	e0bffe15 	stw	r2,-8(fp)
 90b7db8:	e0fffe17 	ldw	r3,-8(fp)
 90b7dbc:	18800060 	cmpeqi	r2,r3,1
 90b7dc0:	1000bd1e 	bne	r2,zero,90b80b8 <tcp_timers+0x320>
 90b7dc4:	e0fffe17 	ldw	r3,-8(fp)
 90b7dc8:	18800088 	cmpgei	r2,r3,2
 90b7dcc:	1000041e 	bne	r2,zero,90b7de0 <tcp_timers+0x48>
 90b7dd0:	e0fffe17 	ldw	r3,-8(fp)
 90b7dd4:	1805003a 	cmpeq	r2,r3,zero
 90b7dd8:	10001b1e 	bne	r2,zero,90b7e48 <tcp_timers+0xb0>
 90b7ddc:	00010f06 	br	90b821c <tcp_timers+0x484>
 90b7de0:	e0fffe17 	ldw	r3,-8(fp)
 90b7de4:	188000a0 	cmpeqi	r2,r3,2
 90b7de8:	1000c41e 	bne	r2,zero,90b80fc <tcp_timers+0x364>
 90b7dec:	e0fffe17 	ldw	r3,-8(fp)
 90b7df0:	188000e0 	cmpeqi	r2,r3,3
 90b7df4:	1000011e 	bne	r2,zero,90b7dfc <tcp_timers+0x64>
 90b7df8:	00010806 	br	90b821c <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 90b7dfc:	e0bffb17 	ldw	r2,-20(fp)
 90b7e00:	10800217 	ldw	r2,8(r2)
 90b7e04:	108002a0 	cmpeqi	r2,r2,10
 90b7e08:	10000b1e 	bne	r2,zero,90b7e38 <tcp_timers+0xa0>
 90b7e0c:	e0bffb17 	ldw	r2,-20(fp)
 90b7e10:	10c01d17 	ldw	r3,116(r2)
 90b7e14:	d0a0b517 	ldw	r2,-32044(gp)
 90b7e18:	10c00716 	blt	r2,r3,90b7e38 <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 90b7e1c:	d0a03d17 	ldw	r2,-32524(gp)
 90b7e20:	10ffffcc 	andi	r3,r2,65535
 90b7e24:	18e0001c 	xori	r3,r3,32768
 90b7e28:	18e00004 	addi	r3,r3,-32768
 90b7e2c:	e0bffb17 	ldw	r2,-20(fp)
 90b7e30:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 90b7e34:	0000f906 	br	90b821c <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 90b7e38:	e13ffb17 	ldw	r4,-20(fp)
 90b7e3c:	90b78700 	call	90b7870 <tcp_close>
 90b7e40:	e0bffb15 	stw	r2,-20(fp)
      break;
 90b7e44:	0000f506 	br	90b821c <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 90b7e48:	008243b4 	movhi	r2,2318
 90b7e4c:	10b72804 	addi	r2,r2,-9056
 90b7e50:	10800b17 	ldw	r2,44(r2)
 90b7e54:	10c00044 	addi	r3,r2,1
 90b7e58:	008243b4 	movhi	r2,2318
 90b7e5c:	10b72804 	addi	r2,r2,-9056
 90b7e60:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 90b7e64:	e0bffb17 	ldw	r2,-20(fp)
 90b7e68:	10800717 	ldw	r2,28(r2)
 90b7e6c:	10c00044 	addi	r3,r2,1
 90b7e70:	e0bffb17 	ldw	r2,-20(fp)
 90b7e74:	10c00715 	stw	r3,28(r2)
 90b7e78:	e0bffb17 	ldw	r2,-20(fp)
 90b7e7c:	10800717 	ldw	r2,28(r2)
 90b7e80:	10800350 	cmplti	r2,r2,13
 90b7e84:	10000f1e 	bne	r2,zero,90b7ec4 <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 90b7e88:	e0fffb17 	ldw	r3,-20(fp)
 90b7e8c:	00800304 	movi	r2,12
 90b7e90:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 90b7e94:	008243b4 	movhi	r2,2318
 90b7e98:	10b75604 	addi	r2,r2,-8872
 90b7e9c:	10800917 	ldw	r2,36(r2)
 90b7ea0:	10c00044 	addi	r3,r2,1
 90b7ea4:	008243b4 	movhi	r2,2318
 90b7ea8:	10b75604 	addi	r2,r2,-8872
 90b7eac:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 90b7eb0:	e13ffb17 	ldw	r4,-20(fp)
 90b7eb4:	01401d04 	movi	r5,116
 90b7eb8:	90b77c40 	call	90b77c4 <tcp_drop>
 90b7ebc:	e0bffb15 	stw	r2,-20(fp)
         break;
 90b7ec0:	0000d606 	br	90b821c <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 90b7ec4:	008243b4 	movhi	r2,2318
 90b7ec8:	10b75604 	addi	r2,r2,-8872
 90b7ecc:	10800a17 	ldw	r2,40(r2)
 90b7ed0:	10c00044 	addi	r3,r2,1
 90b7ed4:	008243b4 	movhi	r2,2318
 90b7ed8:	10b75604 	addi	r2,r2,-8872
 90b7edc:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 90b7ee0:	e0bffb17 	ldw	r2,-20(fp)
 90b7ee4:	10802017 	ldw	r2,128(r2)
 90b7ee8:	1007d0ba 	srai	r3,r2,2
 90b7eec:	e0bffb17 	ldw	r2,-20(fp)
 90b7ef0:	10802117 	ldw	r2,132(r2)
 90b7ef4:	1885883a 	add	r2,r3,r2
 90b7ef8:	1005d07a 	srai	r2,r2,1
 90b7efc:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 90b7f00:	e0bffb17 	ldw	r2,-20(fp)
 90b7f04:	10c00717 	ldw	r3,28(r2)
 90b7f08:	00824374 	movhi	r2,2317
 90b7f0c:	108db3c4 	addi	r2,r2,14031
 90b7f10:	10c5883a 	add	r2,r2,r3
 90b7f14:	10800003 	ldbu	r2,0(r2)
 90b7f18:	10c03fcc 	andi	r3,r2,255
 90b7f1c:	e0bffa17 	ldw	r2,-24(fp)
 90b7f20:	10c5383a 	mul	r2,r2,r3
 90b7f24:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 90b7f28:	e0bffa17 	ldw	r2,-24(fp)
 90b7f2c:	10ffffcc 	andi	r3,r2,65535
 90b7f30:	18e0001c 	xori	r3,r3,32768
 90b7f34:	18e00004 	addi	r3,r3,-32768
 90b7f38:	e0bffb17 	ldw	r2,-20(fp)
 90b7f3c:	10c00815 	stw	r3,32(r2)
 90b7f40:	e0bffb17 	ldw	r2,-20(fp)
 90b7f44:	10800817 	ldw	r2,32(r2)
 90b7f48:	10800088 	cmpgei	r2,r2,2
 90b7f4c:	1000041e 	bne	r2,zero,90b7f60 <tcp_timers+0x1c8>
 90b7f50:	e0fffb17 	ldw	r3,-20(fp)
 90b7f54:	00800084 	movi	r2,2
 90b7f58:	18800815 	stw	r2,32(r3)
 90b7f5c:	00000706 	br	90b7f7c <tcp_timers+0x1e4>
 90b7f60:	e0bffb17 	ldw	r2,-20(fp)
 90b7f64:	10800817 	ldw	r2,32(r2)
 90b7f68:	10802050 	cmplti	r2,r2,129
 90b7f6c:	1000031e 	bne	r2,zero,90b7f7c <tcp_timers+0x1e4>
 90b7f70:	e0fffb17 	ldw	r3,-20(fp)
 90b7f74:	00802004 	movi	r2,128
 90b7f78:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 90b7f7c:	e0bffb17 	ldw	r2,-20(fp)
 90b7f80:	10c00817 	ldw	r3,32(r2)
 90b7f84:	e0bffb17 	ldw	r2,-20(fp)
 90b7f88:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 90b7f8c:	e0bffb17 	ldw	r2,-20(fp)
 90b7f90:	10800717 	ldw	r2,28(r2)
 90b7f94:	10800110 	cmplti	r2,r2,4
 90b7f98:	1000101e 	bne	r2,zero,90b7fdc <tcp_timers+0x244>
 90b7f9c:	e0bffb17 	ldw	r2,-20(fp)
 90b7fa0:	10800b0b 	ldhu	r2,44(r2)
 90b7fa4:	10bfffcc 	andi	r2,r2,65535
 90b7fa8:	1080400c 	andi	r2,r2,256
 90b7fac:	1004c03a 	cmpne	r2,r2,zero
 90b7fb0:	10000a1e 	bne	r2,zero,90b7fdc <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 90b7fb4:	e0bffb17 	ldw	r2,-20(fp)
 90b7fb8:	10c02117 	ldw	r3,132(r2)
 90b7fbc:	e0bffb17 	ldw	r2,-20(fp)
 90b7fc0:	10802017 	ldw	r2,128(r2)
 90b7fc4:	1005d0ba 	srai	r2,r2,2
 90b7fc8:	1887883a 	add	r3,r3,r2
 90b7fcc:	e0bffb17 	ldw	r2,-20(fp)
 90b7fd0:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 90b7fd4:	e0bffb17 	ldw	r2,-20(fp)
 90b7fd8:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 90b7fdc:	e0bffb17 	ldw	r2,-20(fp)
 90b7fe0:	10c00e17 	ldw	r3,56(r2)
 90b7fe4:	e0bffb17 	ldw	r2,-20(fp)
 90b7fe8:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 90b7fec:	e0bffb17 	ldw	r2,-20(fp)
 90b7ff0:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 90b7ff4:	e0bffb17 	ldw	r2,-20(fp)
 90b7ff8:	10800d17 	ldw	r2,52(r2)
 90b7ffc:	10800817 	ldw	r2,32(r2)
 90b8000:	10800417 	ldw	r2,16(r2)
 90b8004:	1090000c 	andi	r2,r2,16384
 90b8008:	1004c03a 	cmpne	r2,r2,zero
 90b800c:	1000271e 	bne	r2,zero,90b80ac <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 90b8010:	e0bffb17 	ldw	r2,-20(fp)
 90b8014:	10c01417 	ldw	r3,80(r2)
 90b8018:	e0bffb17 	ldw	r2,-20(fp)
 90b801c:	10801b17 	ldw	r2,108(r2)
 90b8020:	e0bffd15 	stw	r2,-12(fp)
 90b8024:	e0ffff15 	stw	r3,-4(fp)
 90b8028:	e0bffd17 	ldw	r2,-12(fp)
 90b802c:	e0ffff17 	ldw	r3,-4(fp)
 90b8030:	10c0022e 	bgeu	r2,r3,90b803c <tcp_timers+0x2a4>
 90b8034:	e0bffd17 	ldw	r2,-12(fp)
 90b8038:	e0bfff15 	stw	r2,-4(fp)
 90b803c:	e0ffff17 	ldw	r3,-4(fp)
 90b8040:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 90b8044:	e0bff917 	ldw	r2,-28(fp)
 90b8048:	1006d07a 	srli	r3,r2,1
 90b804c:	e0bffb17 	ldw	r2,-20(fp)
 90b8050:	10800a0b 	ldhu	r2,40(r2)
 90b8054:	10bfffcc 	andi	r2,r2,65535
 90b8058:	1885203a 	divu	r2,r3,r2
 90b805c:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 90b8060:	e0bff917 	ldw	r2,-28(fp)
 90b8064:	108000a8 	cmpgeui	r2,r2,2
 90b8068:	1000021e 	bne	r2,zero,90b8074 <tcp_timers+0x2dc>
            win = 2;
 90b806c:	00800084 	movi	r2,2
 90b8070:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 90b8074:	e0bffb17 	ldw	r2,-20(fp)
 90b8078:	10800a0b 	ldhu	r2,40(r2)
 90b807c:	10ffffcc 	andi	r3,r2,65535
 90b8080:	e0bffb17 	ldw	r2,-20(fp)
 90b8084:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 90b8088:	e0bff917 	ldw	r2,-28(fp)
 90b808c:	10ffffcc 	andi	r3,r2,65535
 90b8090:	e0bffb17 	ldw	r2,-20(fp)
 90b8094:	10800a0b 	ldhu	r2,40(r2)
 90b8098:	10bfffcc 	andi	r2,r2,65535
 90b809c:	1885383a 	mul	r2,r3,r2
 90b80a0:	1007883a 	mov	r3,r2
 90b80a4:	e0bffb17 	ldw	r2,-20(fp)
 90b80a8:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 90b80ac:	e13ffb17 	ldw	r4,-20(fp)
 90b80b0:	90b5d540 	call	90b5d54 <tcp_output>
      break;
 90b80b4:	00005906 	br	90b821c <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 90b80b8:	008243b4 	movhi	r2,2318
 90b80bc:	10b75604 	addi	r2,r2,-8872
 90b80c0:	10800b17 	ldw	r2,44(r2)
 90b80c4:	10c00044 	addi	r3,r2,1
 90b80c8:	008243b4 	movhi	r2,2318
 90b80cc:	10b75604 	addi	r2,r2,-8872
 90b80d0:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 90b80d4:	e13ffb17 	ldw	r4,-20(fp)
 90b80d8:	90b6ed00 	call	90b6ed0 <tcp_setpersist>
      tp->t_force = 1;
 90b80dc:	e0fffb17 	ldw	r3,-20(fp)
 90b80e0:	00800044 	movi	r2,1
 90b80e4:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 90b80e8:	e13ffb17 	ldw	r4,-20(fp)
 90b80ec:	90b5d540 	call	90b5d54 <tcp_output>
      tp->t_force = 0;
 90b80f0:	e0bffb17 	ldw	r2,-20(fp)
 90b80f4:	10000a85 	stb	zero,42(r2)
      break;
 90b80f8:	00004806 	br	90b821c <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 90b80fc:	008243b4 	movhi	r2,2318
 90b8100:	10b75604 	addi	r2,r2,-8872
 90b8104:	10800c17 	ldw	r2,48(r2)
 90b8108:	10c00044 	addi	r3,r2,1
 90b810c:	008243b4 	movhi	r2,2318
 90b8110:	10b75604 	addi	r2,r2,-8872
 90b8114:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 90b8118:	e0bffb17 	ldw	r2,-20(fp)
 90b811c:	10800217 	ldw	r2,8(r2)
 90b8120:	10800110 	cmplti	r2,r2,4
 90b8124:	1000321e 	bne	r2,zero,90b81f0 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 90b8128:	e0bffb17 	ldw	r2,-20(fp)
 90b812c:	10800d17 	ldw	r2,52(r2)
 90b8130:	10800817 	ldw	r2,32(r2)
 90b8134:	10800417 	ldw	r2,16(r2)
 90b8138:	1080020c 	andi	r2,r2,8
 90b813c:	1005003a 	cmpeq	r2,r2,zero
 90b8140:	1000241e 	bne	r2,zero,90b81d4 <tcp_timers+0x43c>
 90b8144:	e0bffb17 	ldw	r2,-20(fp)
 90b8148:	10800217 	ldw	r2,8(r2)
 90b814c:	10800188 	cmpgei	r2,r2,6
 90b8150:	1000201e 	bne	r2,zero,90b81d4 <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 90b8154:	e0bffb17 	ldw	r2,-20(fp)
 90b8158:	11001d17 	ldw	r4,116(r2)
 90b815c:	d0e03c17 	ldw	r3,-32528(gp)
 90b8160:	d0a0b517 	ldw	r2,-32044(gp)
 90b8164:	1885883a 	add	r2,r3,r2
 90b8168:	2080210e 	bge	r4,r2,90b81f0 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 90b816c:	008243b4 	movhi	r2,2318
 90b8170:	10b75604 	addi	r2,r2,-8872
 90b8174:	10800d17 	ldw	r2,52(r2)
 90b8178:	10c00044 	addi	r3,r2,1
 90b817c:	008243b4 	movhi	r2,2318
 90b8180:	10b75604 	addi	r2,r2,-8872
 90b8184:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 90b8188:	e0bffb17 	ldw	r2,-20(fp)
 90b818c:	11400c17 	ldw	r5,48(r2)
 90b8190:	e0bffb17 	ldw	r2,-20(fp)
 90b8194:	10801617 	ldw	r2,88(r2)
 90b8198:	11bfffc4 	addi	r6,r2,-1
 90b819c:	e0bffb17 	ldw	r2,-20(fp)
 90b81a0:	10800e17 	ldw	r2,56(r2)
 90b81a4:	11ffffc4 	addi	r7,r2,-1
 90b81a8:	d8000015 	stw	zero,0(sp)
 90b81ac:	d8000115 	stw	zero,4(sp)
 90b81b0:	e13ffb17 	ldw	r4,-20(fp)
 90b81b4:	90b72240 	call	90b7224 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 90b81b8:	d0a03d17 	ldw	r2,-32524(gp)
 90b81bc:	10ffffcc 	andi	r3,r2,65535
 90b81c0:	18e0001c 	xori	r3,r3,32768
 90b81c4:	18e00004 	addi	r3,r3,-32768
 90b81c8:	e0bffb17 	ldw	r2,-20(fp)
 90b81cc:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 90b81d0:	00001206 	br	90b821c <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 90b81d4:	d0a03c17 	ldw	r2,-32528(gp)
 90b81d8:	10ffffcc 	andi	r3,r2,65535
 90b81dc:	18e0001c 	xori	r3,r3,32768
 90b81e0:	18e00004 	addi	r3,r3,-32768
 90b81e4:	e0bffb17 	ldw	r2,-20(fp)
 90b81e8:	10c00515 	stw	r3,20(r2)
      break;
 90b81ec:	00000b06 	br	90b821c <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 90b81f0:	008243b4 	movhi	r2,2318
 90b81f4:	10b75604 	addi	r2,r2,-8872
 90b81f8:	10800e17 	ldw	r2,56(r2)
 90b81fc:	10c00044 	addi	r3,r2,1
 90b8200:	008243b4 	movhi	r2,2318
 90b8204:	10b75604 	addi	r2,r2,-8872
 90b8208:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 90b820c:	e13ffb17 	ldw	r4,-20(fp)
 90b8210:	01401d04 	movi	r5,116
 90b8214:	90b77c40 	call	90b77c4 <tcp_drop>
 90b8218:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 90b821c:	e0bffb17 	ldw	r2,-20(fp)
}
 90b8220:	e037883a 	mov	sp,fp
 90b8224:	dfc00117 	ldw	ra,4(sp)
 90b8228:	df000017 	ldw	fp,0(sp)
 90b822c:	dec00204 	addi	sp,sp,8
 90b8230:	f800283a 	ret

090b8234 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90b8234:	defff504 	addi	sp,sp,-44
 90b8238:	dfc00a15 	stw	ra,40(sp)
 90b823c:	df000915 	stw	fp,36(sp)
 90b8240:	df000904 	addi	fp,sp,36
 90b8244:	e13ffc15 	stw	r4,-16(fp)
 90b8248:	e17ffd15 	stw	r5,-12(fp)
 90b824c:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 90b8250:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 90b8254:	e0bffc17 	ldw	r2,-16(fp)
 90b8258:	10800717 	ldw	r2,28(r2)
 90b825c:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 90b8260:	e0bffc17 	ldw	r2,-16(fp)
 90b8264:	10800117 	ldw	r2,4(r2)
 90b8268:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 90b826c:	e0bffb17 	ldw	r2,-20(fp)
 90b8270:	1004c03a 	cmpne	r2,r2,zero
 90b8274:	1000061e 	bne	r2,zero,90b8290 <tcp_usrreq+0x5c>
 90b8278:	e0bff817 	ldw	r2,-32(fp)
 90b827c:	1005003a 	cmpeq	r2,r2,zero
 90b8280:	1000031e 	bne	r2,zero,90b8290 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 90b8284:	00800584 	movi	r2,22
 90b8288:	e0bfff15 	stw	r2,-4(fp)
 90b828c:	0001a406 	br	90b8920 <tcp_usrreq+0x6ec>
   }

   if (inp)
 90b8290:	e0bffb17 	ldw	r2,-20(fp)
 90b8294:	1005003a 	cmpeq	r2,r2,zero
 90b8298:	1000041e 	bne	r2,zero,90b82ac <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 90b829c:	e0bffb17 	ldw	r2,-20(fp)
 90b82a0:	10800917 	ldw	r2,36(r2)
 90b82a4:	e0bffa15 	stw	r2,-24(fp)
 90b82a8:	00000906 	br	90b82d0 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 90b82ac:	e0bff817 	ldw	r2,-32(fp)
 90b82b0:	1004c03a 	cmpne	r2,r2,zero
 90b82b4:	1000021e 	bne	r2,zero,90b82c0 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 90b82b8:	e03ffa15 	stw	zero,-24(fp)
 90b82bc:	00000406 	br	90b82d0 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 90b82c0:	90aa4780 	call	90aa478 <dtrap>
         return EINVAL;
 90b82c4:	00800584 	movi	r2,22
 90b82c8:	e0bfff15 	stw	r2,-4(fp)
 90b82cc:	00019406 	br	90b8920 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 90b82d0:	e0bff817 	ldw	r2,-32(fp)
 90b82d4:	10800528 	cmpgeui	r2,r2,20
 90b82d8:	10018c1e 	bne	r2,zero,90b890c <tcp_usrreq+0x6d8>
 90b82dc:	e0bff817 	ldw	r2,-32(fp)
 90b82e0:	1085883a 	add	r2,r2,r2
 90b82e4:	1087883a 	add	r3,r2,r2
 90b82e8:	00824334 	movhi	r2,2316
 90b82ec:	10a0bf04 	addi	r2,r2,-32004
 90b82f0:	1885883a 	add	r2,r3,r2
 90b82f4:	10800017 	ldw	r2,0(r2)
 90b82f8:	1000683a 	jmp	r2
 90b82fc:	090b834c 	andi	r4,at,11789
 90b8300:	090b83bc 	xorhi	r4,at,11790
 90b8304:	090b83e4 	muli	r4,at,11791
 90b8308:	090b841c 	xori	r4,at,11792
 90b830c:	090b845c 	xori	r4,at,11793
 90b8310:	090b85e0 	cmpeqi	r4,at,11799
 90b8314:	090b85d4 	ori	r4,at,11799
 90b8318:	090b868c 	andi	r4,at,11802
 90b831c:	090b86bc 	xorhi	r4,at,11802
 90b8320:	090b86c8 	cmpgei	r4,at,11803
 90b8324:	090b8720 	cmpeqi	r4,at,11804
 90b8328:	090b890c 	andi	r4,at,11812
 90b832c:	090b8730 	cmpltui	r4,at,11804
 90b8330:	090b873c 	xorhi	r4,at,11804
 90b8334:	090b880c 	andi	r4,at,11808
 90b8338:	090b88dc 	xori	r4,at,11811
 90b833c:	090b88ec 	andhi	r4,at,11811
 90b8340:	090b85c8 	cmpgei	r4,at,11799
 90b8344:	090b890c 	andi	r4,at,11812
 90b8348:	090b88fc 	xorhi	r4,at,11811
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 90b834c:	e0bffb17 	ldw	r2,-20(fp)
 90b8350:	1005003a 	cmpeq	r2,r2,zero
 90b8354:	1000031e 	bne	r2,zero,90b8364 <tcp_usrreq+0x130>
      {
         error = EISCONN;
 90b8358:	00801fc4 	movi	r2,127
 90b835c:	e0bff915 	stw	r2,-28(fp)
         break;
 90b8360:	00016d06 	br	90b8918 <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 90b8364:	e13ffc17 	ldw	r4,-16(fp)
 90b8368:	90b89380 	call	90b8938 <tcp_attach>
 90b836c:	e0bff915 	stw	r2,-28(fp)
      if (error)
 90b8370:	e0bff917 	ldw	r2,-28(fp)
 90b8374:	1004c03a 	cmpne	r2,r2,zero
 90b8378:	1001671e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b837c:	e0bffc17 	ldw	r2,-16(fp)
 90b8380:	10800417 	ldw	r2,16(r2)
 90b8384:	1080200c 	andi	r2,r2,128
 90b8388:	1005003a 	cmpeq	r2,r2,zero
 90b838c:	1001621e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
 90b8390:	e0bffc17 	ldw	r2,-16(fp)
 90b8394:	1080080b 	ldhu	r2,32(r2)
 90b8398:	10bfffcc 	andi	r2,r2,65535
 90b839c:	10a0001c 	xori	r2,r2,32768
 90b83a0:	10a00004 	addi	r2,r2,-32768
 90b83a4:	1004c03a 	cmpne	r2,r2,zero
 90b83a8:	10015b1e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 90b83ac:	e0fffc17 	ldw	r3,-16(fp)
 90b83b0:	00801e04 	movi	r2,120
 90b83b4:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 90b83b8:	00015706 	br	90b8918 <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 90b83bc:	e0bffa17 	ldw	r2,-24(fp)
 90b83c0:	10800217 	ldw	r2,8(r2)
 90b83c4:	10800090 	cmplti	r2,r2,2
 90b83c8:	1000031e 	bne	r2,zero,90b83d8 <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 90b83cc:	e13ffa17 	ldw	r4,-24(fp)
 90b83d0:	90b8a6c0 	call	90b8a6c <tcp_disconnect>
 90b83d4:	00015006 	br	90b8918 <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 90b83d8:	e13ffa17 	ldw	r4,-24(fp)
 90b83dc:	90b78700 	call	90b7870 <tcp_close>
      break;
 90b83e0:	00014d06 	br	90b8918 <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 90b83e4:	e0bffb17 	ldw	r2,-20(fp)
 90b83e8:	10800817 	ldw	r2,32(r2)
 90b83ec:	10800517 	ldw	r2,20(r2)
 90b83f0:	10800098 	cmpnei	r2,r2,2
 90b83f4:	1000051e 	bne	r2,zero,90b840c <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 90b83f8:	e13ffb17 	ldw	r4,-20(fp)
 90b83fc:	e17ffe17 	ldw	r5,-8(fp)
 90b8400:	90c79100 	call	90c7910 <in_pcbbind>
 90b8404:	e0bff915 	stw	r2,-28(fp)
         break;
 90b8408:	00014306 	br	90b8918 <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 90b840c:	90aa4780 	call	90aa478 <dtrap>
      error = EINVAL;
 90b8410:	00800584 	movi	r2,22
 90b8414:	e0bff915 	stw	r2,-28(fp)
      break;
 90b8418:	00013f06 	br	90b8918 <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 90b841c:	e0bffb17 	ldw	r2,-20(fp)
 90b8420:	1080078b 	ldhu	r2,30(r2)
 90b8424:	10bfffcc 	andi	r2,r2,65535
 90b8428:	1004c03a 	cmpne	r2,r2,zero
 90b842c:	1000041e 	bne	r2,zero,90b8440 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 90b8430:	e13ffb17 	ldw	r4,-20(fp)
 90b8434:	000b883a 	mov	r5,zero
 90b8438:	90c79100 	call	90c7910 <in_pcbbind>
 90b843c:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 90b8440:	e0bff917 	ldw	r2,-28(fp)
 90b8444:	1004c03a 	cmpne	r2,r2,zero
 90b8448:	1001331e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 90b844c:	e0fffa17 	ldw	r3,-24(fp)
 90b8450:	00800044 	movi	r2,1
 90b8454:	18800215 	stw	r2,8(r3)
      break;
 90b8458:	00012f06 	br	90b8918 <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 90b845c:	e0bffb17 	ldw	r2,-20(fp)
 90b8460:	1080078b 	ldhu	r2,30(r2)
 90b8464:	10bfffcc 	andi	r2,r2,65535
 90b8468:	1004c03a 	cmpne	r2,r2,zero
 90b846c:	1000071e 	bne	r2,zero,90b848c <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 90b8470:	e13ffb17 	ldw	r4,-20(fp)
 90b8474:	000b883a 	mov	r5,zero
 90b8478:	90c79100 	call	90c7910 <in_pcbbind>
 90b847c:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 90b8480:	e0bff917 	ldw	r2,-28(fp)
 90b8484:	1004c03a 	cmpne	r2,r2,zero
 90b8488:	1001231e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 90b848c:	e13ffb17 	ldw	r4,-20(fp)
 90b8490:	e17ffe17 	ldw	r5,-8(fp)
 90b8494:	90c7b640 	call	90c7b64 <in_pcbconnect>
 90b8498:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 90b849c:	e0bff917 	ldw	r2,-28(fp)
 90b84a0:	1004c03a 	cmpne	r2,r2,zero
 90b84a4:	10011c1e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 90b84a8:	e13ffa17 	ldw	r4,-24(fp)
 90b84ac:	90b710c0 	call	90b710c <tcp_template>
 90b84b0:	1007883a 	mov	r3,r2
 90b84b4:	e0bffa17 	ldw	r2,-24(fp)
 90b84b8:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 90b84bc:	e0bffa17 	ldw	r2,-24(fp)
 90b84c0:	10800c17 	ldw	r2,48(r2)
 90b84c4:	1004c03a 	cmpne	r2,r2,zero
 90b84c8:	1000051e 	bne	r2,zero,90b84e0 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 90b84cc:	e13ffb17 	ldw	r4,-20(fp)
 90b84d0:	90c7d740 	call	90c7d74 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 90b84d4:	00801a44 	movi	r2,105
 90b84d8:	e0bff915 	stw	r2,-28(fp)
         break;
 90b84dc:	00010e06 	br	90b8918 <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 90b84e0:	e13ffc17 	ldw	r4,-16(fp)
 90b84e4:	90b110c0 	call	90b110c <soisconnecting>
      tcpstat.tcps_connattempt++;
 90b84e8:	008243b4 	movhi	r2,2318
 90b84ec:	10b75604 	addi	r2,r2,-8872
 90b84f0:	10800017 	ldw	r2,0(r2)
 90b84f4:	10c00044 	addi	r3,r2,1
 90b84f8:	008243b4 	movhi	r2,2318
 90b84fc:	10b75604 	addi	r2,r2,-8872
 90b8500:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 90b8504:	e0fffa17 	ldw	r3,-24(fp)
 90b8508:	00800084 	movi	r2,2
 90b850c:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 90b8510:	e0fffa17 	ldw	r3,-24(fp)
 90b8514:	00802584 	movi	r2,150
 90b8518:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 90b851c:	00824374 	movhi	r2,2317
 90b8520:	108f3b04 	addi	r2,r2,15596
 90b8524:	10c00017 	ldw	r3,0(r2)
 90b8528:	e0bffa17 	ldw	r2,-24(fp)
 90b852c:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 90b8530:	00824374 	movhi	r2,2317
 90b8534:	108f3b04 	addi	r2,r2,15596
 90b8538:	10c00017 	ldw	r3,0(r2)
 90b853c:	00be9fd4 	movui	r2,64127
 90b8540:	1887883a 	add	r3,r3,r2
 90b8544:	00824374 	movhi	r2,2317
 90b8548:	108f3b04 	addi	r2,r2,15596
 90b854c:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 90b8550:	e0bffa17 	ldw	r2,-24(fp)
 90b8554:	10c01317 	ldw	r3,76(r2)
 90b8558:	e0bffa17 	ldw	r2,-24(fp)
 90b855c:	10c01015 	stw	r3,64(r2)
 90b8560:	e0bffa17 	ldw	r2,-24(fp)
 90b8564:	10c01017 	ldw	r3,64(r2)
 90b8568:	e0bffa17 	ldw	r2,-24(fp)
 90b856c:	10c01a15 	stw	r3,104(r2)
 90b8570:	e0bffa17 	ldw	r2,-24(fp)
 90b8574:	10c01a17 	ldw	r3,104(r2)
 90b8578:	e0bffa17 	ldw	r2,-24(fp)
 90b857c:	10c00f15 	stw	r3,60(r2)
 90b8580:	e0bffa17 	ldw	r2,-24(fp)
 90b8584:	10c00f17 	ldw	r3,60(r2)
 90b8588:	e0bffa17 	ldw	r2,-24(fp)
 90b858c:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 90b8590:	e13ffa17 	ldw	r4,-24(fp)
 90b8594:	90b5d540 	call	90b5d54 <tcp_output>
 90b8598:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 90b859c:	e0bff917 	ldw	r2,-28(fp)
 90b85a0:	1004c03a 	cmpne	r2,r2,zero
 90b85a4:	1000dc1e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 90b85a8:	008243b4 	movhi	r2,2318
 90b85ac:	10b72804 	addi	r2,r2,-9056
 90b85b0:	10800417 	ldw	r2,16(r2)
 90b85b4:	10c00044 	addi	r3,r2,1
 90b85b8:	008243b4 	movhi	r2,2318
 90b85bc:	10b72804 	addi	r2,r2,-9056
 90b85c0:	10c00415 	stw	r3,16(r2)
      break;
 90b85c4:	0000d406 	br	90b8918 <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 90b85c8:	008017c4 	movi	r2,95
 90b85cc:	e0bff915 	stw	r2,-28(fp)
      break;
 90b85d0:	0000d106 	br	90b8918 <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 90b85d4:	e13ffa17 	ldw	r4,-24(fp)
 90b85d8:	90b8a6c0 	call	90b8a6c <tcp_disconnect>
      break;
 90b85dc:	0000ce06 	br	90b8918 <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 90b85e0:	e0bffe17 	ldw	r2,-8(fp)
 90b85e4:	10800317 	ldw	r2,12(r2)
 90b85e8:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 90b85ec:	e0bffc17 	ldw	r2,-16(fp)
 90b85f0:	10800517 	ldw	r2,20(r2)
 90b85f4:	10800098 	cmpnei	r2,r2,2
 90b85f8:	10000e1e 	bne	r2,zero,90b8634 <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 90b85fc:	e0fffe17 	ldw	r3,-8(fp)
 90b8600:	00800404 	movi	r2,16
 90b8604:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 90b8608:	e0fff717 	ldw	r3,-36(fp)
 90b860c:	00800084 	movi	r2,2
 90b8610:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 90b8614:	e0bffb17 	ldw	r2,-20(fp)
 90b8618:	10c0070b 	ldhu	r3,28(r2)
 90b861c:	e0bff717 	ldw	r2,-36(fp)
 90b8620:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 90b8624:	e0bffb17 	ldw	r2,-20(fp)
 90b8628:	10c00317 	ldw	r3,12(r2)
 90b862c:	e0bff717 	ldw	r2,-36(fp)
 90b8630:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 90b8634:	e0bffc17 	ldw	r2,-16(fp)
 90b8638:	10800517 	ldw	r2,20(r2)
 90b863c:	108000a0 	cmpeqi	r2,r2,2
 90b8640:	10000a1e 	bne	r2,zero,90b866c <tcp_usrreq+0x438>
 90b8644:	e0bffc17 	ldw	r2,-16(fp)
 90b8648:	10800517 	ldw	r2,20(r2)
 90b864c:	108000e0 	cmpeqi	r2,r2,3
 90b8650:	1000061e 	bne	r2,zero,90b866c <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 90b8654:	e0bffc17 	ldw	r2,-16(fp)
 90b8658:	11400517 	ldw	r5,20(r2)
 90b865c:	01024374 	movhi	r4,2317
 90b8660:	21028504 	addi	r4,r4,2580
 90b8664:	90833900 	call	9083390 <printf>
            dtrap();
 90b8668:	90aa4780 	call	90aa478 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 90b866c:	008243b4 	movhi	r2,2318
 90b8670:	10b72804 	addi	r2,r2,-9056
 90b8674:	10800517 	ldw	r2,20(r2)
 90b8678:	10c00044 	addi	r3,r2,1
 90b867c:	008243b4 	movhi	r2,2318
 90b8680:	10b72804 	addi	r2,r2,-9056
 90b8684:	10c00515 	stw	r3,20(r2)
         break;
 90b8688:	0000a306 	br	90b8918 <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 90b868c:	e13ffc17 	ldw	r4,-16(fp)
 90b8690:	90b17a40 	call	90b17a4 <socantsendmore>
      tp = tcp_usrclosed(tp);
 90b8694:	e13ffa17 	ldw	r4,-24(fp)
 90b8698:	90b8b400 	call	90b8b40 <tcp_usrclosed>
 90b869c:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 90b86a0:	e0bffa17 	ldw	r2,-24(fp)
 90b86a4:	1005003a 	cmpeq	r2,r2,zero
 90b86a8:	10009b1e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 90b86ac:	e13ffa17 	ldw	r4,-24(fp)
 90b86b0:	90b5d540 	call	90b5d54 <tcp_output>
 90b86b4:	e0bff915 	stw	r2,-28(fp)
      break;
 90b86b8:	00009706 	br	90b8918 <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 90b86bc:	e13ffa17 	ldw	r4,-24(fp)
 90b86c0:	90b5d540 	call	90b5d54 <tcp_output>
      break;
 90b86c4:	00009406 	br	90b8918 <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 90b86c8:	e0bffc17 	ldw	r2,-16(fp)
 90b86cc:	10800117 	ldw	r2,4(r2)
 90b86d0:	1004c03a 	cmpne	r2,r2,zero
 90b86d4:	1000031e 	bne	r2,zero,90b86e4 <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 90b86d8:	00800804 	movi	r2,32
 90b86dc:	e0bff915 	stw	r2,-28(fp)
         break;
 90b86e0:	00008d06 	br	90b8918 <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 90b86e4:	e0bffc17 	ldw	r2,-16(fp)
 90b86e8:	11001204 	addi	r4,r2,72
 90b86ec:	e17ffd17 	ldw	r5,-12(fp)
 90b86f0:	90b1aa80 	call	90b1aa8 <sbappend>
      error = tcp_output(tp);
 90b86f4:	e13ffa17 	ldw	r4,-24(fp)
 90b86f8:	90b5d540 	call	90b5d54 <tcp_output>
 90b86fc:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 90b8700:	e0bff917 	ldw	r2,-28(fp)
 90b8704:	10801a58 	cmpnei	r2,r2,105
 90b8708:	1000831e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 90b870c:	e0bffc17 	ldw	r2,-16(fp)
 90b8710:	11001204 	addi	r4,r2,72
 90b8714:	e17ffd17 	ldw	r5,-12(fp)
 90b8718:	90b22800 	call	90b2280 <sbdropend>
      break;
 90b871c:	00007e06 	br	90b8918 <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 90b8720:	e13ffa17 	ldw	r4,-24(fp)
 90b8724:	01401c44 	movi	r5,113
 90b8728:	90b77c40 	call	90b77c4 <tcp_drop>
      break;
 90b872c:	00007a06 	br	90b8918 <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 90b8730:	90aa4780 	call	90aa478 <dtrap>
      return (0);
 90b8734:	e03fff15 	stw	zero,-4(fp)
 90b8738:	00007906 	br	90b8920 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 90b873c:	e0bffc17 	ldw	r2,-16(fp)
 90b8740:	10801a17 	ldw	r2,104(r2)
 90b8744:	1004c03a 	cmpne	r2,r2,zero
 90b8748:	1000061e 	bne	r2,zero,90b8764 <tcp_usrreq+0x530>
 90b874c:	e0bffc17 	ldw	r2,-16(fp)
 90b8750:	1080088b 	ldhu	r2,34(r2)
 90b8754:	10bfffcc 	andi	r2,r2,65535
 90b8758:	1080100c 	andi	r2,r2,64
 90b875c:	1005003a 	cmpeq	r2,r2,zero
 90b8760:	10000b1e 	bne	r2,zero,90b8790 <tcp_usrreq+0x55c>
 90b8764:	e0bffc17 	ldw	r2,-16(fp)
 90b8768:	10800417 	ldw	r2,16(r2)
 90b876c:	1080400c 	andi	r2,r2,256
 90b8770:	1004c03a 	cmpne	r2,r2,zero
 90b8774:	1000061e 	bne	r2,zero,90b8790 <tcp_usrreq+0x55c>
 90b8778:	e0bffa17 	ldw	r2,-24(fp)
 90b877c:	10802403 	ldbu	r2,144(r2)
 90b8780:	10803fcc 	andi	r2,r2,255
 90b8784:	1080008c 	andi	r2,r2,2
 90b8788:	1005003a 	cmpeq	r2,r2,zero
 90b878c:	1000031e 	bne	r2,zero,90b879c <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 90b8790:	00800584 	movi	r2,22
 90b8794:	e0bff915 	stw	r2,-28(fp)
         break;
 90b8798:	00005f06 	br	90b8918 <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 90b879c:	e0bffa17 	ldw	r2,-24(fp)
 90b87a0:	10802403 	ldbu	r2,144(r2)
 90b87a4:	10803fcc 	andi	r2,r2,255
 90b87a8:	1080004c 	andi	r2,r2,1
 90b87ac:	1004c03a 	cmpne	r2,r2,zero
 90b87b0:	1000031e 	bne	r2,zero,90b87c0 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 90b87b4:	008002c4 	movi	r2,11
 90b87b8:	e0bff915 	stw	r2,-28(fp)
         break;
 90b87bc:	00005606 	br	90b8918 <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 90b87c0:	e0fffd17 	ldw	r3,-12(fp)
 90b87c4:	00800044 	movi	r2,1
 90b87c8:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 90b87cc:	e0bffd17 	ldw	r2,-12(fp)
 90b87d0:	10c00317 	ldw	r3,12(r2)
 90b87d4:	e0bffa17 	ldw	r2,-24(fp)
 90b87d8:	10802443 	ldbu	r2,145(r2)
 90b87dc:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 90b87e0:	e0bffe17 	ldw	r2,-8(fp)
 90b87e4:	1080008c 	andi	r2,r2,2
 90b87e8:	1004c03a 	cmpne	r2,r2,zero
 90b87ec:	10004a1e 	bne	r2,zero,90b8918 <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 90b87f0:	e0bffa17 	ldw	r2,-24(fp)
 90b87f4:	10802403 	ldbu	r2,144(r2)
 90b87f8:	108000dc 	xori	r2,r2,3
 90b87fc:	1007883a 	mov	r3,r2
 90b8800:	e0bffa17 	ldw	r2,-24(fp)
 90b8804:	10c02405 	stb	r3,144(r2)
      break;
 90b8808:	00004306 	br	90b8918 <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 90b880c:	e0bffc17 	ldw	r2,-16(fp)
 90b8810:	10800117 	ldw	r2,4(r2)
 90b8814:	1004c03a 	cmpne	r2,r2,zero
 90b8818:	1000031e 	bne	r2,zero,90b8828 <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 90b881c:	00800804 	movi	r2,32
 90b8820:	e0bff915 	stw	r2,-28(fp)
         break;
 90b8824:	00003c06 	br	90b8918 <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 90b8828:	e0bffc17 	ldw	r2,-16(fp)
 90b882c:	10801317 	ldw	r2,76(r2)
 90b8830:	1007883a 	mov	r3,r2
 90b8834:	e0bffc17 	ldw	r2,-16(fp)
 90b8838:	10801217 	ldw	r2,72(r2)
 90b883c:	1885c83a 	sub	r2,r3,r2
 90b8840:	1004803a 	cmplt	r2,r2,zero
 90b8844:	1000051e 	bne	r2,zero,90b885c <tcp_usrreq+0x628>
 90b8848:	e0bffc17 	ldw	r2,-16(fp)
 90b884c:	10c01317 	ldw	r3,76(r2)
 90b8850:	e0bffc17 	ldw	r2,-16(fp)
 90b8854:	10801217 	ldw	r2,72(r2)
 90b8858:	1880051e 	bne	r3,r2,90b8870 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 90b885c:	e13ffd17 	ldw	r4,-12(fp)
 90b8860:	90ab5940 	call	90ab594 <m_freem>
         error = ENOBUFS;
 90b8864:	00801a44 	movi	r2,105
 90b8868:	e0bff915 	stw	r2,-28(fp)
         break;
 90b886c:	00002a06 	br	90b8918 <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 90b8870:	e0bffc17 	ldw	r2,-16(fp)
 90b8874:	11001204 	addi	r4,r2,72
 90b8878:	e17ffd17 	ldw	r5,-12(fp)
 90b887c:	90b1aa80 	call	90b1aa8 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 90b8880:	e0bffa17 	ldw	r2,-24(fp)
 90b8884:	10c00e17 	ldw	r3,56(r2)
 90b8888:	e0bffc17 	ldw	r2,-16(fp)
 90b888c:	10801217 	ldw	r2,72(r2)
 90b8890:	1887883a 	add	r3,r3,r2
 90b8894:	e0bffa17 	ldw	r2,-24(fp)
 90b8898:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 90b889c:	e0fffa17 	ldw	r3,-24(fp)
 90b88a0:	00800044 	movi	r2,1
 90b88a4:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 90b88a8:	e13ffa17 	ldw	r4,-24(fp)
 90b88ac:	90b5d540 	call	90b5d54 <tcp_output>
 90b88b0:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 90b88b4:	e0bff917 	ldw	r2,-28(fp)
 90b88b8:	10801a58 	cmpnei	r2,r2,105
 90b88bc:	1000041e 	bne	r2,zero,90b88d0 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 90b88c0:	e0bffc17 	ldw	r2,-16(fp)
 90b88c4:	11001204 	addi	r4,r2,72
 90b88c8:	e17ffd17 	ldw	r5,-12(fp)
 90b88cc:	90b22800 	call	90b2280 <sbdropend>
      tp->t_force = 0;
 90b88d0:	e0bffa17 	ldw	r2,-24(fp)
 90b88d4:	10000a85 	stb	zero,42(r2)
      break;
 90b88d8:	00000f06 	br	90b8918 <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 90b88dc:	e13ffb17 	ldw	r4,-20(fp)
 90b88e0:	e17ffe17 	ldw	r5,-8(fp)
 90b88e4:	90c7dd40 	call	90c7dd4 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 90b88e8:	00000b06 	br	90b8918 <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 90b88ec:	e13ffb17 	ldw	r4,-20(fp)
 90b88f0:	e17ffe17 	ldw	r5,-8(fp)
 90b88f4:	90c7e500 	call	90c7e50 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 90b88f8:	00000706 	br	90b8918 <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 90b88fc:	e17ffe17 	ldw	r5,-8(fp)
 90b8900:	e13ffa17 	ldw	r4,-24(fp)
 90b8904:	90b7d980 	call	90b7d98 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 90b8908:	00000306 	br	90b8918 <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 90b890c:	01024374 	movhi	r4,2317
 90b8910:	21028d04 	addi	r4,r4,2612
 90b8914:	90a537c0 	call	90a537c <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 90b8918:	e0bff917 	ldw	r2,-28(fp)
 90b891c:	e0bfff15 	stw	r2,-4(fp)
 90b8920:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8924:	e037883a 	mov	sp,fp
 90b8928:	dfc00117 	ldw	ra,4(sp)
 90b892c:	df000017 	ldw	fp,0(sp)
 90b8930:	dec00204 	addi	sp,sp,8
 90b8934:	f800283a 	ret

090b8938 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 90b8938:	defff804 	addi	sp,sp,-32
 90b893c:	dfc00715 	stw	ra,28(sp)
 90b8940:	df000615 	stw	fp,24(sp)
 90b8944:	df000604 	addi	fp,sp,24
 90b8948:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 90b894c:	e0bffe17 	ldw	r2,-8(fp)
 90b8950:	10801317 	ldw	r2,76(r2)
 90b8954:	1005003a 	cmpeq	r2,r2,zero
 90b8958:	1000041e 	bne	r2,zero,90b896c <tcp_attach+0x34>
 90b895c:	e0bffe17 	ldw	r2,-8(fp)
 90b8960:	10800b17 	ldw	r2,44(r2)
 90b8964:	1004c03a 	cmpne	r2,r2,zero
 90b8968:	10000b1e 	bne	r2,zero,90b8998 <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 90b896c:	d1603e17 	ldw	r5,-32520(gp)
 90b8970:	d1a03f17 	ldw	r6,-32516(gp)
 90b8974:	e13ffe17 	ldw	r4,-8(fp)
 90b8978:	90b19800 	call	90b1980 <soreserve>
 90b897c:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 90b8980:	e0bffb17 	ldw	r2,-20(fp)
 90b8984:	1005003a 	cmpeq	r2,r2,zero
 90b8988:	1000031e 	bne	r2,zero,90b8998 <tcp_attach+0x60>
         return (error);
 90b898c:	e0bffb17 	ldw	r2,-20(fp)
 90b8990:	e0bfff15 	stw	r2,-4(fp)
 90b8994:	00002f06 	br	90b8a54 <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 90b8998:	e13ffe17 	ldw	r4,-8(fp)
 90b899c:	014243b4 	movhi	r5,2318
 90b89a0:	29774b04 	addi	r5,r5,-8916
 90b89a4:	90c78280 	call	90c7828 <in_pcballoc>
 90b89a8:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 90b89ac:	e0bffb17 	ldw	r2,-20(fp)
 90b89b0:	1005003a 	cmpeq	r2,r2,zero
 90b89b4:	1000031e 	bne	r2,zero,90b89c4 <tcp_attach+0x8c>
      return (error);
 90b89b8:	e0bffb17 	ldw	r2,-20(fp)
 90b89bc:	e0bfff15 	stw	r2,-4(fp)
 90b89c0:	00002406 	br	90b8a54 <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 90b89c4:	e0bffe17 	ldw	r2,-8(fp)
 90b89c8:	10800117 	ldw	r2,4(r2)
 90b89cc:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 90b89d0:	e13ffc17 	ldw	r4,-16(fp)
 90b89d4:	90b76ac0 	call	90b76ac <tcp_newtcpcb>
 90b89d8:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 90b89dc:	e0bffd17 	ldw	r2,-12(fp)
 90b89e0:	1004c03a 	cmpne	r2,r2,zero
 90b89e4:	1000181e 	bne	r2,zero,90b8a48 <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 90b89e8:	e0bffe17 	ldw	r2,-8(fp)
 90b89ec:	1080088b 	ldhu	r2,34(r2)
 90b89f0:	10bfffcc 	andi	r2,r2,65535
 90b89f4:	1080004c 	andi	r2,r2,1
 90b89f8:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 90b89fc:	e0bffe17 	ldw	r2,-8(fp)
 90b8a00:	10c0088b 	ldhu	r3,34(r2)
 90b8a04:	00bfff84 	movi	r2,-2
 90b8a08:	1884703a 	and	r2,r3,r2
 90b8a0c:	1007883a 	mov	r3,r2
 90b8a10:	e0bffe17 	ldw	r2,-8(fp)
 90b8a14:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 90b8a18:	e13ffc17 	ldw	r4,-16(fp)
 90b8a1c:	90c78bc0 	call	90c78bc <in_pcbdetach>
      so->so_state |= nofd;
 90b8a20:	e0bffe17 	ldw	r2,-8(fp)
 90b8a24:	10c0088b 	ldhu	r3,34(r2)
 90b8a28:	e0bffa17 	ldw	r2,-24(fp)
 90b8a2c:	1884b03a 	or	r2,r3,r2
 90b8a30:	1007883a 	mov	r3,r2
 90b8a34:	e0bffe17 	ldw	r2,-8(fp)
 90b8a38:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 90b8a3c:	00801a44 	movi	r2,105
 90b8a40:	e0bfff15 	stw	r2,-4(fp)
 90b8a44:	00000306 	br	90b8a54 <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 90b8a48:	e0bffd17 	ldw	r2,-12(fp)
 90b8a4c:	10000215 	stw	zero,8(r2)
   return (0);
 90b8a50:	e03fff15 	stw	zero,-4(fp)
 90b8a54:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8a58:	e037883a 	mov	sp,fp
 90b8a5c:	dfc00117 	ldw	ra,4(sp)
 90b8a60:	df000017 	ldw	fp,0(sp)
 90b8a64:	dec00204 	addi	sp,sp,8
 90b8a68:	f800283a 	ret

090b8a6c <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 90b8a6c:	defffc04 	addi	sp,sp,-16
 90b8a70:	dfc00315 	stw	ra,12(sp)
 90b8a74:	df000215 	stw	fp,8(sp)
 90b8a78:	df000204 	addi	fp,sp,8
 90b8a7c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 90b8a80:	e0bfff17 	ldw	r2,-4(fp)
 90b8a84:	10800d17 	ldw	r2,52(r2)
 90b8a88:	10800817 	ldw	r2,32(r2)
 90b8a8c:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 90b8a90:	e0bfff17 	ldw	r2,-4(fp)
 90b8a94:	10800217 	ldw	r2,8(r2)
 90b8a98:	10800108 	cmpgei	r2,r2,4
 90b8a9c:	1000041e 	bne	r2,zero,90b8ab0 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 90b8aa0:	e13fff17 	ldw	r4,-4(fp)
 90b8aa4:	90b78700 	call	90b7870 <tcp_close>
 90b8aa8:	e0bfff15 	stw	r2,-4(fp)
 90b8aac:	00001e06 	br	90b8b28 <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b8ab0:	e0bffe17 	ldw	r2,-8(fp)
 90b8ab4:	10800417 	ldw	r2,16(r2)
 90b8ab8:	1080200c 	andi	r2,r2,128
 90b8abc:	1005003a 	cmpeq	r2,r2,zero
 90b8ac0:	10000c1e 	bne	r2,zero,90b8af4 <tcp_disconnect+0x88>
 90b8ac4:	e0bffe17 	ldw	r2,-8(fp)
 90b8ac8:	1080080b 	ldhu	r2,32(r2)
 90b8acc:	10bfffcc 	andi	r2,r2,65535
 90b8ad0:	10a0001c 	xori	r2,r2,32768
 90b8ad4:	10a00004 	addi	r2,r2,-32768
 90b8ad8:	1004c03a 	cmpne	r2,r2,zero
 90b8adc:	1000051e 	bne	r2,zero,90b8af4 <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 90b8ae0:	e13fff17 	ldw	r4,-4(fp)
 90b8ae4:	000b883a 	mov	r5,zero
 90b8ae8:	90b77c40 	call	90b77c4 <tcp_drop>
 90b8aec:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 90b8af0:	00000d06 	br	90b8b28 <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 90b8af4:	e13ffe17 	ldw	r4,-8(fp)
 90b8af8:	90b12740 	call	90b1274 <soisdisconnecting>
      sbflush(&so->so_rcv);
 90b8afc:	e0bffe17 	ldw	r2,-8(fp)
 90b8b00:	11000a04 	addi	r4,r2,40
 90b8b04:	90b20200 	call	90b2020 <sbflush>
      tp = tcp_usrclosed(tp);
 90b8b08:	e13fff17 	ldw	r4,-4(fp)
 90b8b0c:	90b8b400 	call	90b8b40 <tcp_usrclosed>
 90b8b10:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 90b8b14:	e0bfff17 	ldw	r2,-4(fp)
 90b8b18:	1005003a 	cmpeq	r2,r2,zero
 90b8b1c:	1000021e 	bne	r2,zero,90b8b28 <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 90b8b20:	e13fff17 	ldw	r4,-4(fp)
 90b8b24:	90b5d540 	call	90b5d54 <tcp_output>
   }
   return (tp);
 90b8b28:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8b2c:	e037883a 	mov	sp,fp
 90b8b30:	dfc00117 	ldw	ra,4(sp)
 90b8b34:	df000017 	ldw	fp,0(sp)
 90b8b38:	dec00204 	addi	sp,sp,8
 90b8b3c:	f800283a 	ret

090b8b40 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 90b8b40:	defffc04 	addi	sp,sp,-16
 90b8b44:	dfc00315 	stw	ra,12(sp)
 90b8b48:	df000215 	stw	fp,8(sp)
 90b8b4c:	df000204 	addi	fp,sp,8
 90b8b50:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 90b8b54:	e0bffe17 	ldw	r2,-8(fp)
 90b8b58:	10800217 	ldw	r2,8(r2)
 90b8b5c:	e0bfff15 	stw	r2,-4(fp)
 90b8b60:	e0ffff17 	ldw	r3,-4(fp)
 90b8b64:	188001a8 	cmpgeui	r2,r3,6
 90b8b68:	10001c1e 	bne	r2,zero,90b8bdc <tcp_usrclosed+0x9c>
 90b8b6c:	e13fff17 	ldw	r4,-4(fp)
 90b8b70:	e13fff17 	ldw	r4,-4(fp)
 90b8b74:	2105883a 	add	r2,r4,r4
 90b8b78:	1087883a 	add	r3,r2,r2
 90b8b7c:	00824334 	movhi	r2,2316
 90b8b80:	10a2e404 	addi	r2,r2,-29808
 90b8b84:	1885883a 	add	r2,r3,r2
 90b8b88:	10800017 	ldw	r2,0(r2)
 90b8b8c:	1000683a 	jmp	r2
 90b8b90:	090b8ba8 	cmpgeui	r4,at,11822
 90b8b94:	090b8ba8 	cmpgeui	r4,at,11822
 90b8b98:	090b8ba8 	cmpgeui	r4,at,11822
 90b8b9c:	090b8bc0 	call	90b8bc <OSCtxSw_SWITCH_PC+0x90b87c>
 90b8ba0:	090b8bc0 	call	90b8bc <OSCtxSw_SWITCH_PC+0x90b87c>
 90b8ba4:	090b8bd0 	cmplti	r4,at,11823
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 90b8ba8:	e0bffe17 	ldw	r2,-8(fp)
 90b8bac:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 90b8bb0:	e13ffe17 	ldw	r4,-8(fp)
 90b8bb4:	90b78700 	call	90b7870 <tcp_close>
 90b8bb8:	e0bffe15 	stw	r2,-8(fp)
      break;
 90b8bbc:	00000706 	br	90b8bdc <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 90b8bc0:	e0fffe17 	ldw	r3,-8(fp)
 90b8bc4:	00800184 	movi	r2,6
 90b8bc8:	18800215 	stw	r2,8(r3)
      break;
 90b8bcc:	00000306 	br	90b8bdc <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 90b8bd0:	e0fffe17 	ldw	r3,-8(fp)
 90b8bd4:	00800204 	movi	r2,8
 90b8bd8:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 90b8bdc:	e0bffe17 	ldw	r2,-8(fp)
 90b8be0:	1005003a 	cmpeq	r2,r2,zero
 90b8be4:	1000081e 	bne	r2,zero,90b8c08 <tcp_usrclosed+0xc8>
 90b8be8:	e0bffe17 	ldw	r2,-8(fp)
 90b8bec:	10800217 	ldw	r2,8(r2)
 90b8bf0:	10800250 	cmplti	r2,r2,9
 90b8bf4:	1000041e 	bne	r2,zero,90b8c08 <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 90b8bf8:	e0bffe17 	ldw	r2,-8(fp)
 90b8bfc:	10800d17 	ldw	r2,52(r2)
 90b8c00:	11000817 	ldw	r4,32(r2)
 90b8c04:	90b13000 	call	90b1300 <soisdisconnected>
   return (tp);
 90b8c08:	e0bffe17 	ldw	r2,-8(fp)
}
 90b8c0c:	e037883a 	mov	sp,fp
 90b8c10:	dfc00117 	ldw	ra,4(sp)
 90b8c14:	df000017 	ldw	fp,0(sp)
 90b8c18:	dec00204 	addi	sp,sp,8
 90b8c1c:	f800283a 	ret

090b8c20 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 90b8c20:	defffc04 	addi	sp,sp,-16
 90b8c24:	dfc00315 	stw	ra,12(sp)
 90b8c28:	df000215 	stw	fp,8(sp)
 90b8c2c:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 90b8c30:	90abcb80 	call	90abcb8 <nptcp_init>
 90b8c34:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 90b8c38:	e0bffe17 	ldw	r2,-8(fp)
 90b8c3c:	1005003a 	cmpeq	r2,r2,zero
 90b8c40:	1000031e 	bne	r2,zero,90b8c50 <tcpinit+0x30>
      return e;
 90b8c44:	e0bffe17 	ldw	r2,-8(fp)
 90b8c48:	e0bfff15 	stw	r2,-4(fp)
 90b8c4c:	00000106 	br	90b8c54 <tcpinit+0x34>

   return 0;   /* good return */
 90b8c50:	e03fff15 	stw	zero,-4(fp)
 90b8c54:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8c58:	e037883a 	mov	sp,fp
 90b8c5c:	dfc00117 	ldw	ra,4(sp)
 90b8c60:	df000017 	ldw	fp,0(sp)
 90b8c64:	dec00204 	addi	sp,sp,8
 90b8c68:	f800283a 	ret

090b8c6c <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 90b8c6c:	defffc04 	addi	sp,sp,-16
 90b8c70:	df000315 	stw	fp,12(sp)
 90b8c74:	df000304 	addi	fp,sp,12
 90b8c78:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90b8c7c:	00824374 	movhi	r2,2317
 90b8c80:	108f2204 	addi	r2,r2,15496
 90b8c84:	10800017 	ldw	r2,0(r2)
 90b8c88:	e0bffd15 	stw	r2,-12(fp)
 90b8c8c:	00000a06 	br	90b8cb8 <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 90b8c90:	e0bffd17 	ldw	r2,-12(fp)
 90b8c94:	10c00617 	ldw	r3,24(r2)
 90b8c98:	e0bffe17 	ldw	r2,-8(fp)
 90b8c9c:	1880031e 	bne	r3,r2,90b8cac <udp_lookup+0x40>
      return (tmp);
 90b8ca0:	e0bffd17 	ldw	r2,-12(fp)
 90b8ca4:	e0bfff15 	stw	r2,-4(fp)
 90b8ca8:	00000706 	br	90b8cc8 <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90b8cac:	e0bffd17 	ldw	r2,-12(fp)
 90b8cb0:	10800017 	ldw	r2,0(r2)
 90b8cb4:	e0bffd15 	stw	r2,-12(fp)
 90b8cb8:	e0bffd17 	ldw	r2,-12(fp)
 90b8cbc:	1004c03a 	cmpne	r2,r2,zero
 90b8cc0:	103ff31e 	bne	r2,zero,90b8c90 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 90b8cc4:	e03fff15 	stw	zero,-4(fp)
 90b8cc8:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8ccc:	e037883a 	mov	sp,fp
 90b8cd0:	df000017 	ldw	fp,0(sp)
 90b8cd4:	dec00104 	addi	sp,sp,4
 90b8cd8:	f800283a 	ret

090b8cdc <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 90b8cdc:	defff404 	addi	sp,sp,-48
 90b8ce0:	dfc00b15 	stw	ra,44(sp)
 90b8ce4:	df000a15 	stw	fp,40(sp)
 90b8ce8:	df000a04 	addi	fp,sp,40
 90b8cec:	e13ffd15 	stw	r4,-12(fp)
 90b8cf0:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 90b8cf4:	e0bffe17 	ldw	r2,-8(fp)
 90b8cf8:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 90b8cfc:	0009883a 	mov	r4,zero
 90b8d00:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 90b8d04:	e0bff717 	ldw	r2,-36(fp)
 90b8d08:	10c00a17 	ldw	r3,40(r2)
 90b8d0c:	e0bffd17 	ldw	r2,-12(fp)
 90b8d10:	10800417 	ldw	r2,16(r2)
 90b8d14:	1887883a 	add	r3,r3,r2
 90b8d18:	e0bff717 	ldw	r2,-36(fp)
 90b8d1c:	10800b17 	ldw	r2,44(r2)
 90b8d20:	18800536 	bltu	r3,r2,90b8d38 <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b8d24:	0009883a 	mov	r4,zero
 90b8d28:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b8d2c:	00801a44 	movi	r2,105
 90b8d30:	e0bfff15 	stw	r2,-4(fp)
 90b8d34:	00005106 	br	90b8e7c <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 90b8d38:	01000044 	movi	r4,1
 90b8d3c:	000b883a 	mov	r5,zero
 90b8d40:	90ab2b80 	call	90ab2b8 <m_getnbuf>
 90b8d44:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 90b8d48:	e0bff817 	ldw	r2,-32(fp)
 90b8d4c:	1004c03a 	cmpne	r2,r2,zero
 90b8d50:	1000051e 	bne	r2,zero,90b8d68 <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b8d54:	0009883a 	mov	r4,zero
 90b8d58:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b8d5c:	00801a44 	movi	r2,105
 90b8d60:	e0bfff15 	stw	r2,-4(fp)
 90b8d64:	00004506 	br	90b8e7c <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 90b8d68:	e0fff817 	ldw	r3,-32(fp)
 90b8d6c:	e0bffd17 	ldw	r2,-12(fp)
 90b8d70:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 90b8d74:	e0bffd17 	ldw	r2,-12(fp)
 90b8d78:	10c00317 	ldw	r3,12(r2)
 90b8d7c:	e0bff817 	ldw	r2,-32(fp)
 90b8d80:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 90b8d84:	e0bffd17 	ldw	r2,-12(fp)
 90b8d88:	10c00417 	ldw	r3,16(r2)
 90b8d8c:	e0bff817 	ldw	r2,-32(fp)
 90b8d90:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 90b8d94:	e0bffd17 	ldw	r2,-12(fp)
 90b8d98:	10c00117 	ldw	r3,4(r2)
 90b8d9c:	e0bff817 	ldw	r2,-32(fp)
 90b8da0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 90b8da4:	e0bffd17 	ldw	r2,-12(fp)
 90b8da8:	10c00217 	ldw	r3,8(r2)
 90b8dac:	e0bff817 	ldw	r2,-32(fp)
 90b8db0:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 90b8db4:	e0bffd17 	ldw	r2,-12(fp)
 90b8db8:	10800717 	ldw	r2,28(r2)
 90b8dbc:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 90b8dc0:	e0bffd17 	ldw	r2,-12(fp)
 90b8dc4:	10800317 	ldw	r2,12(r2)
 90b8dc8:	10bffe04 	addi	r2,r2,-8
 90b8dcc:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 90b8dd0:	e0bff617 	ldw	r2,-40(fp)
 90b8dd4:	1080000b 	ldhu	r2,0(r2)
 90b8dd8:	10bfffcc 	andi	r2,r2,65535
 90b8ddc:	1004d23a 	srli	r2,r2,8
 90b8de0:	10803fcc 	andi	r2,r2,255
 90b8de4:	1009883a 	mov	r4,r2
 90b8de8:	e0bff617 	ldw	r2,-40(fp)
 90b8dec:	1080000b 	ldhu	r2,0(r2)
 90b8df0:	10bfffcc 	andi	r2,r2,65535
 90b8df4:	1004923a 	slli	r2,r2,8
 90b8df8:	1007883a 	mov	r3,r2
 90b8dfc:	00bfc004 	movi	r2,-256
 90b8e00:	1884703a 	and	r2,r3,r2
 90b8e04:	2084b03a 	or	r2,r4,r2
 90b8e08:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 90b8e0c:	00800084 	movi	r2,2
 90b8e10:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 90b8e14:	e0bff717 	ldw	r2,-36(fp)
 90b8e18:	11000a04 	addi	r4,r2,40
 90b8e1c:	e17ff904 	addi	r5,fp,-28
 90b8e20:	e1bff817 	ldw	r6,-32(fp)
 90b8e24:	90b1c300 	call	90b1c30 <sbappendaddr>
 90b8e28:	1004c03a 	cmpne	r2,r2,zero
 90b8e2c:	1000091e 	bne	r2,zero,90b8e54 <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 90b8e30:	e0bff817 	ldw	r2,-32(fp)
 90b8e34:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 90b8e38:	e13ff817 	ldw	r4,-32(fp)
 90b8e3c:	90ab4600 	call	90ab460 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b8e40:	0009883a 	mov	r4,zero
 90b8e44:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 90b8e48:	00801a44 	movi	r2,105
 90b8e4c:	e0bfff15 	stw	r2,-4(fp)
 90b8e50:	00000a06 	br	90b8e7c <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 90b8e54:	e0bff717 	ldw	r2,-36(fp)
 90b8e58:	11000a04 	addi	r4,r2,40
 90b8e5c:	90a5e940 	call	90a5e94 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 90b8e60:	e0bff717 	ldw	r2,-36(fp)
 90b8e64:	11400a04 	addi	r5,r2,40
 90b8e68:	e13ff717 	ldw	r4,-36(fp)
 90b8e6c:	90b18e40 	call	90b18e4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 90b8e70:	0009883a 	mov	r4,zero
 90b8e74:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return 0;
 90b8e78:	e03fff15 	stw	zero,-4(fp)
 90b8e7c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b8e80:	e037883a 	mov	sp,fp
 90b8e84:	dfc00117 	ldw	ra,4(sp)
 90b8e88:	df000017 	ldw	fp,0(sp)
 90b8e8c:	dec00204 	addi	sp,sp,8
 90b8e90:	f800283a 	ret

090b8e94 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 90b8e94:	defff704 	addi	sp,sp,-36
 90b8e98:	dfc00815 	stw	ra,32(sp)
 90b8e9c:	df000715 	stw	fp,28(sp)
 90b8ea0:	df000704 	addi	fp,sp,28
 90b8ea4:	e13ffc15 	stw	r4,-16(fp)
 90b8ea8:	e17ffd15 	stw	r5,-12(fp)
 90b8eac:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 90b8eb0:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 90b8eb4:	e0bffc17 	ldw	r2,-16(fp)
 90b8eb8:	10800717 	ldw	r2,28(r2)
 90b8ebc:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 90b8ec0:	e0bffa17 	ldw	r2,-24(fp)
 90b8ec4:	10800468 	cmpgeui	r2,r2,17
 90b8ec8:	10008b1e 	bne	r2,zero,90b90f8 <udp_usrreq+0x264>
 90b8ecc:	e0bffa17 	ldw	r2,-24(fp)
 90b8ed0:	1085883a 	add	r2,r2,r2
 90b8ed4:	1087883a 	add	r3,r2,r2
 90b8ed8:	00824334 	movhi	r2,2316
 90b8edc:	10a3bb04 	addi	r2,r2,-28948
 90b8ee0:	1885883a 	add	r2,r3,r2
 90b8ee4:	10800017 	ldw	r2,0(r2)
 90b8ee8:	1000683a 	jmp	r2
 90b8eec:	090b8f30 	cmpltui	r4,at,11836
 90b8ef0:	090b8fb8 	rdprs	r4,at,11838
 90b8ef4:	090b8ffc 	xorhi	r4,at,11839
 90b8ef8:	090b90f8 	rdprs	r4,at,11843
 90b8efc:	090b8ffc 	xorhi	r4,at,11839
 90b8f00:	090b90f8 	rdprs	r4,at,11843
 90b8f04:	090b90ec 	andhi	r4,at,11843
 90b8f08:	090b90f8 	rdprs	r4,at,11843
 90b8f0c:	090b90ec 	andhi	r4,at,11843
 90b8f10:	090b904c 	andi	r4,at,11841
 90b8f14:	090b90f8 	rdprs	r4,at,11843
 90b8f18:	090b90f8 	rdprs	r4,at,11843
 90b8f1c:	090b90f8 	rdprs	r4,at,11843
 90b8f20:	090b90f8 	rdprs	r4,at,11843
 90b8f24:	090b90f8 	rdprs	r4,at,11843
 90b8f28:	090b909c 	xori	r4,at,11842
 90b8f2c:	090b909c 	xori	r4,at,11842
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 90b8f30:	90c4b700 	call	90c4b70 <udp_maxalloc>
 90b8f34:	1007883a 	mov	r3,r2
 90b8f38:	e0bffc17 	ldw	r2,-16(fp)
 90b8f3c:	10c01315 	stw	r3,76(r2)
 90b8f40:	e0bffc17 	ldw	r2,-16(fp)
 90b8f44:	10c01317 	ldw	r3,76(r2)
 90b8f48:	e0bffc17 	ldw	r2,-16(fp)
 90b8f4c:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 90b8f50:	e0bffc17 	ldw	r2,-16(fp)
 90b8f54:	10800517 	ldw	r2,20(r2)
 90b8f58:	10800098 	cmpnei	r2,r2,2
 90b8f5c:	10000e1e 	bne	r2,zero,90b8f98 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 90b8f60:	0009883a 	mov	r4,zero
 90b8f64:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 90b8f68:	90c49e00 	call	90c49e0 <udp_socket>
 90b8f6c:	11bfffcc 	andi	r6,r2,65535
 90b8f70:	e0bffc17 	ldw	r2,-16(fp)
 90b8f74:	d8800015 	stw	r2,0(sp)
 90b8f78:	0009883a 	mov	r4,zero
 90b8f7c:	000b883a 	mov	r5,zero
 90b8f80:	01c24334 	movhi	r7,2316
 90b8f84:	39e33704 	addi	r7,r7,-29476
 90b8f88:	90a9fc80 	call	90a9fc8 <udp_open>
 90b8f8c:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 90b8f90:	0009883a 	mov	r4,zero
 90b8f94:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 90b8f98:	e0bffb17 	ldw	r2,-20(fp)
 90b8f9c:	1004c03a 	cmpne	r2,r2,zero
 90b8fa0:	1000031e 	bne	r2,zero,90b8fb0 <udp_usrreq+0x11c>
         return(EINVAL);
 90b8fa4:	00800584 	movi	r2,22
 90b8fa8:	e0bfff15 	stw	r2,-4(fp)
 90b8fac:	00005406 	br	90b9100 <udp_usrreq+0x26c>
      return 0;
 90b8fb0:	e03fff15 	stw	zero,-4(fp)
 90b8fb4:	00005206 	br	90b9100 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 90b8fb8:	e13ffc17 	ldw	r4,-16(fp)
 90b8fbc:	90b8c6c0 	call	90b8c6c <udp_lookup>
 90b8fc0:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 90b8fc4:	e0bffb17 	ldw	r2,-20(fp)
 90b8fc8:	1004c03a 	cmpne	r2,r2,zero
 90b8fcc:	1000031e 	bne	r2,zero,90b8fdc <udp_usrreq+0x148>
         return(EINVAL);
 90b8fd0:	00800584 	movi	r2,22
 90b8fd4:	e0bfff15 	stw	r2,-4(fp)
 90b8fd8:	00004906 	br	90b9100 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90b8fdc:	0009883a 	mov	r4,zero
 90b8fe0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 90b8fe4:	e13ffb17 	ldw	r4,-20(fp)
 90b8fe8:	90aa2000 	call	90aa200 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 90b8fec:	0009883a 	mov	r4,zero
 90b8ff0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      return 0;
 90b8ff4:	e03fff15 	stw	zero,-4(fp)
 90b8ff8:	00004106 	br	90b9100 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 90b8ffc:	e0bffe17 	ldw	r2,-8(fp)
 90b9000:	1004c03a 	cmpne	r2,r2,zero
 90b9004:	1000031e 	bne	r2,zero,90b9014 <udp_usrreq+0x180>
         return(EINVAL);
 90b9008:	00800584 	movi	r2,22
 90b900c:	e0bfff15 	stw	r2,-4(fp)
 90b9010:	00003b06 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b9014:	e0bffc17 	ldw	r2,-16(fp)
 90b9018:	10800517 	ldw	r2,20(r2)
 90b901c:	10800098 	cmpnei	r2,r2,2
 90b9020:	1000061e 	bne	r2,zero,90b903c <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 90b9024:	e13ffc17 	ldw	r4,-16(fp)
 90b9028:	e17ffe17 	ldw	r5,-8(fp)
 90b902c:	e1bffa17 	ldw	r6,-24(fp)
 90b9030:	90b91180 	call	90b9118 <udp4_sockbind>
 90b9034:	e0bfff15 	stw	r2,-4(fp)
 90b9038:	00003106 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 90b903c:	90aa4780 	call	90aa478 <dtrap>
      return EINVAL;
 90b9040:	00800584 	movi	r2,22
 90b9044:	e0bfff15 	stw	r2,-4(fp)
 90b9048:	00002d06 	br	90b9100 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 90b904c:	e0bffd17 	ldw	r2,-12(fp)
 90b9050:	1004c03a 	cmpne	r2,r2,zero
 90b9054:	1000031e 	bne	r2,zero,90b9064 <udp_usrreq+0x1d0>
         return(EINVAL);
 90b9058:	00800584 	movi	r2,22
 90b905c:	e0bfff15 	stw	r2,-4(fp)
 90b9060:	00002706 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b9064:	e0bffc17 	ldw	r2,-16(fp)
 90b9068:	10800517 	ldw	r2,20(r2)
 90b906c:	10800098 	cmpnei	r2,r2,2
 90b9070:	1000061e 	bne	r2,zero,90b908c <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 90b9074:	e13ffc17 	ldw	r4,-16(fp)
 90b9078:	e17ffd17 	ldw	r5,-12(fp)
 90b907c:	e1bffe17 	ldw	r6,-8(fp)
 90b9080:	90b94540 	call	90b9454 <udp4_socksend>
 90b9084:	e0bfff15 	stw	r2,-4(fp)
 90b9088:	00001d06 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 90b908c:	90aa4780 	call	90aa478 <dtrap>
      return EINVAL;
 90b9090:	00800584 	movi	r2,22
 90b9094:	e0bfff15 	stw	r2,-4(fp)
 90b9098:	00001906 	br	90b9100 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 90b909c:	e0bffe17 	ldw	r2,-8(fp)
 90b90a0:	1004c03a 	cmpne	r2,r2,zero
 90b90a4:	1000031e 	bne	r2,zero,90b90b4 <udp_usrreq+0x220>
         return(EINVAL);
 90b90a8:	00800584 	movi	r2,22
 90b90ac:	e0bfff15 	stw	r2,-4(fp)
 90b90b0:	00001306 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 90b90b4:	e0bffc17 	ldw	r2,-16(fp)
 90b90b8:	10800517 	ldw	r2,20(r2)
 90b90bc:	10800098 	cmpnei	r2,r2,2
 90b90c0:	1000061e 	bne	r2,zero,90b90dc <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 90b90c4:	e13ffc17 	ldw	r4,-16(fp)
 90b90c8:	e17ffe17 	ldw	r5,-8(fp)
 90b90cc:	e1bffa17 	ldw	r6,-24(fp)
 90b90d0:	90b98300 	call	90b9830 <udp4_sockaddr>
 90b90d4:	e0bfff15 	stw	r2,-4(fp)
 90b90d8:	00000906 	br	90b9100 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 90b90dc:	90aa4780 	call	90aa478 <dtrap>
      return EINVAL;
 90b90e0:	00800584 	movi	r2,22
 90b90e4:	e0bfff15 	stw	r2,-4(fp)
 90b90e8:	00000506 	br	90b9100 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 90b90ec:	90aa4780 	call	90aa478 <dtrap>
      return 0;
 90b90f0:	e03fff15 	stw	zero,-4(fp)
 90b90f4:	00000206 	br	90b9100 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 90b90f8:	008017c4 	movi	r2,95
 90b90fc:	e0bfff15 	stw	r2,-4(fp)
 90b9100:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90b9104:	e037883a 	mov	sp,fp
 90b9108:	dfc00117 	ldw	ra,4(sp)
 90b910c:	df000017 	ldw	fp,0(sp)
 90b9110:	dec00204 	addi	sp,sp,8
 90b9114:	f800283a 	ret

090b9118 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 90b9118:	defff304 	addi	sp,sp,-52
 90b911c:	dfc00c15 	stw	ra,48(sp)
 90b9120:	df000b15 	stw	fp,44(sp)
 90b9124:	df000b04 	addi	fp,sp,44
 90b9128:	e13ffc15 	stw	r4,-16(fp)
 90b912c:	e17ffd15 	stw	r5,-12(fp)
 90b9130:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 90b9134:	e0bffd17 	ldw	r2,-12(fp)
 90b9138:	10800317 	ldw	r2,12(r2)
 90b913c:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 90b9140:	e0bffb17 	ldw	r2,-20(fp)
 90b9144:	1004c03a 	cmpne	r2,r2,zero
 90b9148:	1000031e 	bne	r2,zero,90b9158 <udp4_sockbind+0x40>
    return(EINVAL);
 90b914c:	00800584 	movi	r2,22
 90b9150:	e0bfff15 	stw	r2,-4(fp)
 90b9154:	0000b906 	br	90b943c <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 90b9158:	e0bffd17 	ldw	r2,-12(fp)
 90b915c:	10800217 	ldw	r2,8(r2)
 90b9160:	10800420 	cmpeqi	r2,r2,16
 90b9164:	1000031e 	bne	r2,zero,90b9174 <udp4_sockbind+0x5c>
    return(EINVAL);
 90b9168:	00800584 	movi	r2,22
 90b916c:	e0bfff15 	stw	r2,-4(fp)
 90b9170:	0000b206 	br	90b943c <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 90b9174:	e13ffc17 	ldw	r4,-16(fp)
 90b9178:	90b8c6c0 	call	90b8c6c <udp_lookup>
 90b917c:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 90b9180:	e0bffa17 	ldw	r2,-24(fp)
 90b9184:	1004c03a 	cmpne	r2,r2,zero
 90b9188:	1000031e 	bne	r2,zero,90b9198 <udp4_sockbind+0x80>
     return(EINVAL);
 90b918c:	00800584 	movi	r2,22
 90b9190:	e0bfff15 	stw	r2,-4(fp)
 90b9194:	0000a906 	br	90b943c <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 90b9198:	e0bffe17 	ldw	r2,-8(fp)
 90b919c:	10800098 	cmpnei	r2,r2,2
 90b91a0:	1000601e 	bne	r2,zero,90b9324 <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 90b91a4:	e0bffb17 	ldw	r2,-20(fp)
 90b91a8:	1080008b 	ldhu	r2,2(r2)
 90b91ac:	10bfffcc 	andi	r2,r2,65535
 90b91b0:	1004c03a 	cmpne	r2,r2,zero
 90b91b4:	10000c1e 	bne	r2,zero,90b91e8 <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 90b91b8:	e0bffa17 	ldw	r2,-24(fp)
 90b91bc:	1080018b 	ldhu	r2,6(r2)
 90b91c0:	10bfffcc 	andi	r2,r2,65535
 90b91c4:	1005003a 	cmpeq	r2,r2,zero
 90b91c8:	1000041e 	bne	r2,zero,90b91dc <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 90b91cc:	e0bffa17 	ldw	r2,-24(fp)
 90b91d0:	1080018b 	ldhu	r2,6(r2)
 90b91d4:	e0bff80d 	sth	r2,-32(fp)
 90b91d8:	00001206 	br	90b9224 <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 90b91dc:	90c49e00 	call	90c49e0 <udp_socket>
 90b91e0:	e0bff80d 	sth	r2,-32(fp)
 90b91e4:	00000f06 	br	90b9224 <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 90b91e8:	e0bffb17 	ldw	r2,-20(fp)
 90b91ec:	1080008b 	ldhu	r2,2(r2)
 90b91f0:	10bfffcc 	andi	r2,r2,65535
 90b91f4:	1004d23a 	srli	r2,r2,8
 90b91f8:	10803fcc 	andi	r2,r2,255
 90b91fc:	1009883a 	mov	r4,r2
 90b9200:	e0bffb17 	ldw	r2,-20(fp)
 90b9204:	1080008b 	ldhu	r2,2(r2)
 90b9208:	10bfffcc 	andi	r2,r2,65535
 90b920c:	1004923a 	slli	r2,r2,8
 90b9210:	1007883a 	mov	r3,r2
 90b9214:	00bfc004 	movi	r2,-256
 90b9218:	1884703a 	and	r2,r3,r2
 90b921c:	2084b03a 	or	r2,r4,r2
 90b9220:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 90b9224:	e0bffb17 	ldw	r2,-20(fp)
 90b9228:	10800117 	ldw	r2,4(r2)
 90b922c:	1004c03a 	cmpne	r2,r2,zero
 90b9230:	1000021e 	bne	r2,zero,90b923c <udp4_sockbind+0x124>
    {
      lhost = 0L;
 90b9234:	e03ff615 	stw	zero,-40(fp)
 90b9238:	00001806 	br	90b929c <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 90b923c:	e0bffb17 	ldw	r2,-20(fp)
 90b9240:	10800117 	ldw	r2,4(r2)
 90b9244:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b9248:	008243b4 	movhi	r2,2318
 90b924c:	10b82704 	addi	r2,r2,-8036
 90b9250:	10800017 	ldw	r2,0(r2)
 90b9254:	e0bff515 	stw	r2,-44(fp)
 90b9258:	00000706 	br	90b9278 <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 90b925c:	e0bff517 	ldw	r2,-44(fp)
 90b9260:	10c00a17 	ldw	r3,40(r2)
 90b9264:	e0bff617 	ldw	r2,-40(fp)
 90b9268:	18800626 	beq	r3,r2,90b9284 <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b926c:	e0bff517 	ldw	r2,-44(fp)
 90b9270:	10800017 	ldw	r2,0(r2)
 90b9274:	e0bff515 	stw	r2,-44(fp)
 90b9278:	e0bff517 	ldw	r2,-44(fp)
 90b927c:	1004c03a 	cmpne	r2,r2,zero
 90b9280:	103ff61e 	bne	r2,zero,90b925c <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 90b9284:	e0bff517 	ldw	r2,-44(fp)
 90b9288:	1004c03a 	cmpne	r2,r2,zero
 90b928c:	1000031e 	bne	r2,zero,90b929c <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 90b9290:	00801f44 	movi	r2,125
 90b9294:	e0bfff15 	stw	r2,-4(fp)
 90b9298:	00006806 	br	90b943c <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 90b929c:	e0bffc17 	ldw	r2,-16(fp)
 90b92a0:	10800417 	ldw	r2,16(r2)
 90b92a4:	1080010c 	andi	r2,r2,4
 90b92a8:	1004c03a 	cmpne	r2,r2,zero
 90b92ac:	1000161e 	bne	r2,zero,90b9308 <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 90b92b0:	00824374 	movhi	r2,2317
 90b92b4:	108f2204 	addi	r2,r2,15496
 90b92b8:	10800017 	ldw	r2,0(r2)
 90b92bc:	e0bff915 	stw	r2,-28(fp)
 90b92c0:	00000e06 	br	90b92fc <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 90b92c4:	e0bff917 	ldw	r2,-28(fp)
 90b92c8:	1080018b 	ldhu	r2,6(r2)
 90b92cc:	10ffffcc 	andi	r3,r2,65535
 90b92d0:	e0bff80b 	ldhu	r2,-32(fp)
 90b92d4:	1880061e 	bne	r3,r2,90b92f0 <udp4_sockbind+0x1d8>
 90b92d8:	e0fff917 	ldw	r3,-28(fp)
 90b92dc:	e0bffa17 	ldw	r2,-24(fp)
 90b92e0:	18800326 	beq	r3,r2,90b92f0 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 90b92e4:	00801c04 	movi	r2,112
 90b92e8:	e0bfff15 	stw	r2,-4(fp)
 90b92ec:	00005306 	br	90b943c <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 90b92f0:	e0bff917 	ldw	r2,-28(fp)
 90b92f4:	10800017 	ldw	r2,0(r2)
 90b92f8:	e0bff915 	stw	r2,-28(fp)
 90b92fc:	e0bff917 	ldw	r2,-28(fp)
 90b9300:	1004c03a 	cmpne	r2,r2,zero
 90b9304:	103fef1e 	bne	r2,zero,90b92c4 <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 90b9308:	e0fffa17 	ldw	r3,-24(fp)
 90b930c:	e0bff80b 	ldhu	r2,-32(fp)
 90b9310:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 90b9314:	e0fffa17 	ldw	r3,-24(fp)
 90b9318:	e0bff617 	ldw	r2,-40(fp)
 90b931c:	18800315 	stw	r2,12(r3)
 90b9320:	00004506 	br	90b9438 <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 90b9324:	e0bffb17 	ldw	r2,-20(fp)
 90b9328:	1080008b 	ldhu	r2,2(r2)
 90b932c:	10bfffcc 	andi	r2,r2,65535
 90b9330:	1004d23a 	srli	r2,r2,8
 90b9334:	10803fcc 	andi	r2,r2,255
 90b9338:	1009883a 	mov	r4,r2
 90b933c:	e0bffb17 	ldw	r2,-20(fp)
 90b9340:	1080008b 	ldhu	r2,2(r2)
 90b9344:	10bfffcc 	andi	r2,r2,65535
 90b9348:	1004923a 	slli	r2,r2,8
 90b934c:	1007883a 	mov	r3,r2
 90b9350:	00bfc004 	movi	r2,-256
 90b9354:	1884703a 	and	r2,r3,r2
 90b9358:	2084b03a 	or	r2,r4,r2
 90b935c:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 90b9360:	e0bffb17 	ldw	r2,-20(fp)
 90b9364:	10800117 	ldw	r2,4(r2)
 90b9368:	1004c03a 	cmpne	r2,r2,zero
 90b936c:	1000021e 	bne	r2,zero,90b9378 <udp4_sockbind+0x260>
      fhost = 0L;
 90b9370:	e03ff715 	stw	zero,-36(fp)
 90b9374:	00000306 	br	90b9384 <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 90b9378:	e0bffb17 	ldw	r2,-20(fp)
 90b937c:	10800117 	ldw	r2,4(r2)
 90b9380:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 90b9384:	e13ff717 	ldw	r4,-36(fp)
 90b9388:	90bfa480 	call	90bfa48 <ip_mymach>
 90b938c:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 90b9390:	e0bff617 	ldw	r2,-40(fp)
 90b9394:	1004c03a 	cmpne	r2,r2,zero
 90b9398:	1000031e 	bne	r2,zero,90b93a8 <udp4_sockbind+0x290>
      return(ENETUNREACH);
 90b939c:	00801c84 	movi	r2,114
 90b93a0:	e0bfff15 	stw	r2,-4(fp)
 90b93a4:	00002506 	br	90b943c <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 90b93a8:	e0bffa17 	ldw	r2,-24(fp)
 90b93ac:	1080018b 	ldhu	r2,6(r2)
 90b93b0:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 90b93b4:	e0bff80b 	ldhu	r2,-32(fp)
 90b93b8:	1004c03a 	cmpne	r2,r2,zero
 90b93bc:	1000021e 	bne	r2,zero,90b93c8 <udp4_sockbind+0x2b0>
      lport = udp_socket();
 90b93c0:	90c49e00 	call	90c49e0 <udp_socket>
 90b93c4:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 90b93c8:	e0fffa17 	ldw	r3,-24(fp)
 90b93cc:	e0bff617 	ldw	r2,-40(fp)
 90b93d0:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 90b93d4:	e0fffa17 	ldw	r3,-24(fp)
 90b93d8:	e0bff80b 	ldhu	r2,-32(fp)
 90b93dc:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 90b93e0:	e0fffa17 	ldw	r3,-24(fp)
 90b93e4:	e0bff717 	ldw	r2,-36(fp)
 90b93e8:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 90b93ec:	e0fffa17 	ldw	r3,-24(fp)
 90b93f0:	e0bff88b 	ldhu	r2,-30(fp)
 90b93f4:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 90b93f8:	e0bffc17 	ldw	r2,-16(fp)
 90b93fc:	10c0088b 	ldhu	r3,34(r2)
 90b9400:	00bffcc4 	movi	r2,-13
 90b9404:	1884703a 	and	r2,r3,r2
 90b9408:	1007883a 	mov	r3,r2
 90b940c:	e0bffc17 	ldw	r2,-16(fp)
 90b9410:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 90b9414:	e0bffc17 	ldw	r2,-16(fp)
 90b9418:	1080088b 	ldhu	r2,34(r2)
 90b941c:	10800094 	ori	r2,r2,2
 90b9420:	1007883a 	mov	r3,r2
 90b9424:	e0bffc17 	ldw	r2,-16(fp)
 90b9428:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 90b942c:	e0bffc17 	ldw	r2,-16(fp)
 90b9430:	11000a04 	addi	r4,r2,40
 90b9434:	90b20200 	call	90b2020 <sbflush>
  }
  return 0;
 90b9438:	e03fff15 	stw	zero,-4(fp)
 90b943c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9440:	e037883a 	mov	sp,fp
 90b9444:	dfc00117 	ldw	ra,4(sp)
 90b9448:	df000017 	ldw	fp,0(sp)
 90b944c:	dec00204 	addi	sp,sp,8
 90b9450:	f800283a 	ret

090b9454 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 90b9454:	defff204 	addi	sp,sp,-56
 90b9458:	dfc00d15 	stw	ra,52(sp)
 90b945c:	df000c15 	stw	fp,48(sp)
 90b9460:	dc000b15 	stw	r16,44(sp)
 90b9464:	df000b04 	addi	fp,sp,44
 90b9468:	e13ffc15 	stw	r4,-16(fp)
 90b946c:	e17ffd15 	stw	r5,-12(fp)
 90b9470:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 90b9474:	e13ffc17 	ldw	r4,-16(fp)
 90b9478:	90b8c6c0 	call	90b8c6c <udp_lookup>
 90b947c:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 90b9480:	e0bff917 	ldw	r2,-28(fp)
 90b9484:	1004c03a 	cmpne	r2,r2,zero
 90b9488:	1000051e 	bne	r2,zero,90b94a0 <udp4_socksend+0x4c>
  {
    m_free(m);
 90b948c:	e13ffd17 	ldw	r4,-12(fp)
 90b9490:	90ab4600 	call	90ab460 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 90b9494:	00801bc4 	movi	r2,111
 90b9498:	e0bfff15 	stw	r2,-4(fp)
 90b949c:	0000dd06 	br	90b9814 <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 90b94a0:	e0bffe17 	ldw	r2,-8(fp)
 90b94a4:	1004c03a 	cmpne	r2,r2,zero
 90b94a8:	1000101e 	bne	r2,zero,90b94ec <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 90b94ac:	e0bffc17 	ldw	r2,-16(fp)
 90b94b0:	1080088b 	ldhu	r2,34(r2)
 90b94b4:	10bfffcc 	andi	r2,r2,65535
 90b94b8:	1080008c 	andi	r2,r2,2
 90b94bc:	1005003a 	cmpeq	r2,r2,zero
 90b94c0:	1000071e 	bne	r2,zero,90b94e0 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 90b94c4:	e0bff917 	ldw	r2,-28(fp)
 90b94c8:	1080020b 	ldhu	r2,8(r2)
 90b94cc:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 90b94d0:	e0bff917 	ldw	r2,-28(fp)
 90b94d4:	10800417 	ldw	r2,16(r2)
 90b94d8:	e0bff715 	stw	r2,-36(fp)
 90b94dc:	00003106 	br	90b95a4 <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 90b94e0:	00800584 	movi	r2,22
 90b94e4:	e0bfff15 	stw	r2,-4(fp)
 90b94e8:	0000ca06 	br	90b9814 <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 90b94ec:	e0bffe17 	ldw	r2,-8(fp)
 90b94f0:	10800217 	ldw	r2,8(r2)
 90b94f4:	10800420 	cmpeqi	r2,r2,16
 90b94f8:	1000041e 	bne	r2,zero,90b950c <udp4_socksend+0xb8>
  {
    dtrap();
 90b94fc:	90aa4780 	call	90aa478 <dtrap>
    return (EINVAL);
 90b9500:	00800584 	movi	r2,22
 90b9504:	e0bfff15 	stw	r2,-4(fp)
 90b9508:	0000c206 	br	90b9814 <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 90b950c:	e0bffe17 	ldw	r2,-8(fp)
 90b9510:	10800317 	ldw	r2,12(r2)
 90b9514:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 90b9518:	e0bffa17 	ldw	r2,-24(fp)
 90b951c:	10800117 	ldw	r2,4(r2)
 90b9520:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 90b9524:	e0bffa17 	ldw	r2,-24(fp)
 90b9528:	1080008b 	ldhu	r2,2(r2)
 90b952c:	10bfffcc 	andi	r2,r2,65535
 90b9530:	1005003a 	cmpeq	r2,r2,zero
 90b9534:	1000101e 	bne	r2,zero,90b9578 <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 90b9538:	e0bffa17 	ldw	r2,-24(fp)
 90b953c:	1080008b 	ldhu	r2,2(r2)
 90b9540:	10bfffcc 	andi	r2,r2,65535
 90b9544:	1004d23a 	srli	r2,r2,8
 90b9548:	10803fcc 	andi	r2,r2,255
 90b954c:	1009883a 	mov	r4,r2
 90b9550:	e0bffa17 	ldw	r2,-24(fp)
 90b9554:	1080008b 	ldhu	r2,2(r2)
 90b9558:	10bfffcc 	andi	r2,r2,65535
 90b955c:	1004923a 	slli	r2,r2,8
 90b9560:	1007883a 	mov	r3,r2
 90b9564:	00bfc004 	movi	r2,-256
 90b9568:	1884703a 	and	r2,r3,r2
 90b956c:	2084b03a 	or	r2,r4,r2
 90b9570:	e0bff80d 	sth	r2,-32(fp)
 90b9574:	00000b06 	br	90b95a4 <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 90b9578:	e0bff917 	ldw	r2,-28(fp)
 90b957c:	1080020b 	ldhu	r2,8(r2)
 90b9580:	10bfffcc 	andi	r2,r2,65535
 90b9584:	1004c03a 	cmpne	r2,r2,zero
 90b9588:	1000031e 	bne	r2,zero,90b9598 <udp4_socksend+0x144>
        return (EINVAL);
 90b958c:	00800584 	movi	r2,22
 90b9590:	e0bfff15 	stw	r2,-4(fp)
 90b9594:	00009f06 	br	90b9814 <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 90b9598:	e0bff917 	ldw	r2,-28(fp)
 90b959c:	1080020b 	ldhu	r2,8(r2)
 90b95a0:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 90b95a4:	e0bffd17 	ldw	r2,-12(fp)
 90b95a8:	14000217 	ldw	r16,8(r2)
 90b95ac:	90c4b700 	call	90c4b70 <udp_maxalloc>
 90b95b0:	1400042e 	bgeu	r2,r16,90b95c4 <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 90b95b4:	90aa4780 	call	90aa478 <dtrap>
    return EMSGSIZE;  /* try to recover */
 90b95b8:	00801e84 	movi	r2,122
 90b95bc:	e0bfff15 	stw	r2,-4(fp)
 90b95c0:	00009406 	br	90b9814 <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 90b95c4:	e0bffd17 	ldw	r2,-12(fp)
 90b95c8:	10800217 	ldw	r2,8(r2)
 90b95cc:	1009883a 	mov	r4,r2
 90b95d0:	000b883a 	mov	r5,zero
 90b95d4:	90c4ab00 	call	90c4ab0 <udp_alloc>
 90b95d8:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 90b95dc:	e0bff617 	ldw	r2,-40(fp)
 90b95e0:	1004c03a 	cmpne	r2,r2,zero
 90b95e4:	1000051e 	bne	r2,zero,90b95fc <udp4_socksend+0x1a8>
  {
    m_free(m);
 90b95e8:	e13ffd17 	ldw	r4,-12(fp)
 90b95ec:	90ab4600 	call	90ab460 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 90b95f0:	00801a44 	movi	r2,105
 90b95f4:	e0bfff15 	stw	r2,-4(fp)
 90b95f8:	00008606 	br	90b9814 <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 90b95fc:	e0bff617 	ldw	r2,-40(fp)
 90b9600:	10c00317 	ldw	r3,12(r2)
 90b9604:	e0bffd17 	ldw	r2,-12(fp)
 90b9608:	11400317 	ldw	r5,12(r2)
 90b960c:	e0bffd17 	ldw	r2,-12(fp)
 90b9610:	10800217 	ldw	r2,8(r2)
 90b9614:	1809883a 	mov	r4,r3
 90b9618:	100d883a 	mov	r6,r2
 90b961c:	90894600 	call	9089460 <memcpy>
  pkt->nb_plen = m->m_len;
 90b9620:	e0bffd17 	ldw	r2,-12(fp)
 90b9624:	10c00217 	ldw	r3,8(r2)
 90b9628:	e0bff617 	ldw	r2,-40(fp)
 90b962c:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 90b9630:	e13ffd17 	ldw	r4,-12(fp)
 90b9634:	90ab4600 	call	90ab460 <m_free>
  pkt->fhost = fhost;
 90b9638:	e0fff617 	ldw	r3,-40(fp)
 90b963c:	e0bff717 	ldw	r2,-36(fp)
 90b9640:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 90b9644:	e0bff717 	ldw	r2,-36(fp)
 90b9648:	10bfffd8 	cmpnei	r2,r2,-1
 90b964c:	10004f1e 	bne	r2,zero,90b978c <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 90b9650:	e0bff917 	ldw	r2,-28(fp)
 90b9654:	10800317 	ldw	r2,12(r2)
 90b9658:	1005003a 	cmpeq	r2,r2,zero
 90b965c:	1000111e 	bne	r2,zero,90b96a4 <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b9660:	008243b4 	movhi	r2,2318
 90b9664:	10b82704 	addi	r2,r2,-8036
 90b9668:	10800017 	ldw	r2,0(r2)
 90b966c:	e0bff515 	stw	r2,-44(fp)
 90b9670:	00000806 	br	90b9694 <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 90b9674:	e0bff517 	ldw	r2,-44(fp)
 90b9678:	10c00a17 	ldw	r3,40(r2)
 90b967c:	e0bff917 	ldw	r2,-28(fp)
 90b9680:	10800317 	ldw	r2,12(r2)
 90b9684:	18802126 	beq	r3,r2,90b970c <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b9688:	e0bff517 	ldw	r2,-44(fp)
 90b968c:	10800017 	ldw	r2,0(r2)
 90b9690:	e0bff515 	stw	r2,-44(fp)
 90b9694:	e0bff517 	ldw	r2,-44(fp)
 90b9698:	1004c03a 	cmpne	r2,r2,zero
 90b969c:	103ff51e 	bne	r2,zero,90b9674 <udp4_socksend+0x220>
 90b96a0:	00001a06 	br	90b970c <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b96a4:	008243b4 	movhi	r2,2318
 90b96a8:	10b82704 	addi	r2,r2,-8036
 90b96ac:	10800017 	ldw	r2,0(r2)
 90b96b0:	e0bff515 	stw	r2,-44(fp)
 90b96b4:	00001206 	br	90b9700 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 90b96b8:	e0bff517 	ldw	r2,-44(fp)
 90b96bc:	10802a17 	ldw	r2,168(r2)
 90b96c0:	1080004c 	andi	r2,r2,1
 90b96c4:	10803fcc 	andi	r2,r2,255
 90b96c8:	1005003a 	cmpeq	r2,r2,zero
 90b96cc:	1000091e 	bne	r2,zero,90b96f4 <udp4_socksend+0x2a0>
 90b96d0:	e0bff517 	ldw	r2,-44(fp)
 90b96d4:	10802717 	ldw	r2,156(r2)
 90b96d8:	1005003a 	cmpeq	r2,r2,zero
 90b96dc:	1000051e 	bne	r2,zero,90b96f4 <udp4_socksend+0x2a0>
 90b96e0:	e0bff517 	ldw	r2,-44(fp)
 90b96e4:	10802717 	ldw	r2,156(r2)
 90b96e8:	10800617 	ldw	r2,24(r2)
 90b96ec:	10800060 	cmpeqi	r2,r2,1
 90b96f0:	1000061e 	bne	r2,zero,90b970c <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b96f4:	e0bff517 	ldw	r2,-44(fp)
 90b96f8:	10800017 	ldw	r2,0(r2)
 90b96fc:	e0bff515 	stw	r2,-44(fp)
 90b9700:	e0bff517 	ldw	r2,-44(fp)
 90b9704:	1004c03a 	cmpne	r2,r2,zero
 90b9708:	103feb1e 	bne	r2,zero,90b96b8 <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 90b970c:	e0bff517 	ldw	r2,-44(fp)
 90b9710:	1004c03a 	cmpne	r2,r2,zero
 90b9714:	10001a1e 	bne	r2,zero,90b9780 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b9718:	008243b4 	movhi	r2,2318
 90b971c:	10b82704 	addi	r2,r2,-8036
 90b9720:	10800017 	ldw	r2,0(r2)
 90b9724:	e0bff515 	stw	r2,-44(fp)
 90b9728:	00000c06 	br	90b975c <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 90b972c:	e0bff517 	ldw	r2,-44(fp)
 90b9730:	10802717 	ldw	r2,156(r2)
 90b9734:	1005003a 	cmpeq	r2,r2,zero
 90b9738:	1000051e 	bne	r2,zero,90b9750 <udp4_socksend+0x2fc>
 90b973c:	e0bff517 	ldw	r2,-44(fp)
 90b9740:	10802717 	ldw	r2,156(r2)
 90b9744:	10800617 	ldw	r2,24(r2)
 90b9748:	10800060 	cmpeqi	r2,r2,1
 90b974c:	1000061e 	bne	r2,zero,90b9768 <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90b9750:	e0bff517 	ldw	r2,-44(fp)
 90b9754:	10800017 	ldw	r2,0(r2)
 90b9758:	e0bff515 	stw	r2,-44(fp)
 90b975c:	e0bff517 	ldw	r2,-44(fp)
 90b9760:	1004c03a 	cmpne	r2,r2,zero
 90b9764:	103ff11e 	bne	r2,zero,90b972c <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 90b9768:	e0bff517 	ldw	r2,-44(fp)
 90b976c:	1004c03a 	cmpne	r2,r2,zero
 90b9770:	1000031e 	bne	r2,zero,90b9780 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 90b9774:	00801f44 	movi	r2,125
 90b9778:	e0bfff15 	stw	r2,-4(fp)
 90b977c:	00002506 	br	90b9814 <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 90b9780:	e0fff617 	ldw	r3,-40(fp)
 90b9784:	e0bff517 	ldw	r2,-44(fp)
 90b9788:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 90b978c:	e0bffc17 	ldw	r2,-16(fp)
 90b9790:	10800317 	ldw	r2,12(r2)
 90b9794:	1005003a 	cmpeq	r2,r2,zero
 90b9798:	1000041e 	bne	r2,zero,90b97ac <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 90b979c:	e0bffc17 	ldw	r2,-16(fp)
 90b97a0:	10c00317 	ldw	r3,12(r2)
 90b97a4:	e0bff617 	ldw	r2,-40(fp)
 90b97a8:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 90b97ac:	e0bffc17 	ldw	r2,-16(fp)
 90b97b0:	10801f17 	ldw	r2,124(r2)
 90b97b4:	1005003a 	cmpeq	r2,r2,zero
 90b97b8:	1000041e 	bne	r2,zero,90b97cc <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 90b97bc:	e0bffc17 	ldw	r2,-16(fp)
 90b97c0:	10c01f17 	ldw	r3,124(r2)
 90b97c4:	e0bff617 	ldw	r2,-40(fp)
 90b97c8:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 90b97cc:	0009883a 	mov	r4,zero
 90b97d0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 90b97d4:	e13ff80b 	ldhu	r4,-32(fp)
 90b97d8:	e0bff917 	ldw	r2,-28(fp)
 90b97dc:	1080018b 	ldhu	r2,6(r2)
 90b97e0:	117fffcc 	andi	r5,r2,65535
 90b97e4:	e1bff617 	ldw	r6,-40(fp)
 90b97e8:	90c45f80 	call	90c45f8 <udp_send>
 90b97ec:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 90b97f0:	0009883a 	mov	r4,zero
 90b97f4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
  if (e < 0) 
 90b97f8:	e0bffb17 	ldw	r2,-20(fp)
 90b97fc:	1004403a 	cmpge	r2,r2,zero
 90b9800:	1000031e 	bne	r2,zero,90b9810 <udp4_socksend+0x3bc>
     return(e);
 90b9804:	e0bffb17 	ldw	r2,-20(fp)
 90b9808:	e0bfff15 	stw	r2,-4(fp)
 90b980c:	00000106 	br	90b9814 <udp4_socksend+0x3c0>
  return 0;
 90b9810:	e03fff15 	stw	zero,-4(fp)
 90b9814:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9818:	e037883a 	mov	sp,fp
 90b981c:	dfc00217 	ldw	ra,8(sp)
 90b9820:	df000117 	ldw	fp,4(sp)
 90b9824:	dc000017 	ldw	r16,0(sp)
 90b9828:	dec00304 	addi	sp,sp,12
 90b982c:	f800283a 	ret

090b9830 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 90b9830:	defff804 	addi	sp,sp,-32
 90b9834:	dfc00715 	stw	ra,28(sp)
 90b9838:	df000615 	stw	fp,24(sp)
 90b983c:	df000604 	addi	fp,sp,24
 90b9840:	e13ffc15 	stw	r4,-16(fp)
 90b9844:	e17ffd15 	stw	r5,-12(fp)
 90b9848:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 90b984c:	e0bffd17 	ldw	r2,-12(fp)
 90b9850:	10800317 	ldw	r2,12(r2)
 90b9854:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 90b9858:	e0bffb17 	ldw	r2,-20(fp)
 90b985c:	1004c03a 	cmpne	r2,r2,zero
 90b9860:	1000031e 	bne	r2,zero,90b9870 <udp4_sockaddr+0x40>
     return(EINVAL);
 90b9864:	00800584 	movi	r2,22
 90b9868:	e0bfff15 	stw	r2,-4(fp)
 90b986c:	00004106 	br	90b9974 <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 90b9870:	e13ffc17 	ldw	r4,-16(fp)
 90b9874:	90b8c6c0 	call	90b8c6c <udp_lookup>
 90b9878:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 90b987c:	e0bffa17 	ldw	r2,-24(fp)
 90b9880:	1004c03a 	cmpne	r2,r2,zero
 90b9884:	1000031e 	bne	r2,zero,90b9894 <udp4_sockaddr+0x64>
     return(EINVAL);
 90b9888:	00800584 	movi	r2,22
 90b988c:	e0bfff15 	stw	r2,-4(fp)
 90b9890:	00003806 	br	90b9974 <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 90b9894:	e0fffd17 	ldw	r3,-12(fp)
 90b9898:	00800404 	movi	r2,16
 90b989c:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 90b98a0:	e0bffe17 	ldw	r2,-8(fp)
 90b98a4:	108003d8 	cmpnei	r2,r2,15
 90b98a8:	1000191e 	bne	r2,zero,90b9910 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 90b98ac:	e0fffb17 	ldw	r3,-20(fp)
 90b98b0:	00800084 	movi	r2,2
 90b98b4:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 90b98b8:	e0bffa17 	ldw	r2,-24(fp)
 90b98bc:	1080018b 	ldhu	r2,6(r2)
 90b98c0:	10bfffcc 	andi	r2,r2,65535
 90b98c4:	1004d23a 	srli	r2,r2,8
 90b98c8:	10803fcc 	andi	r2,r2,255
 90b98cc:	1009883a 	mov	r4,r2
 90b98d0:	e0bffa17 	ldw	r2,-24(fp)
 90b98d4:	1080018b 	ldhu	r2,6(r2)
 90b98d8:	10bfffcc 	andi	r2,r2,65535
 90b98dc:	1004923a 	slli	r2,r2,8
 90b98e0:	1007883a 	mov	r3,r2
 90b98e4:	00bfc004 	movi	r2,-256
 90b98e8:	1884703a 	and	r2,r3,r2
 90b98ec:	2084b03a 	or	r2,r4,r2
 90b98f0:	1007883a 	mov	r3,r2
 90b98f4:	e0bffb17 	ldw	r2,-20(fp)
 90b98f8:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 90b98fc:	e0bffa17 	ldw	r2,-24(fp)
 90b9900:	10c00317 	ldw	r3,12(r2)
 90b9904:	e0bffb17 	ldw	r2,-20(fp)
 90b9908:	10c00115 	stw	r3,4(r2)
 90b990c:	00001806 	br	90b9970 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 90b9910:	e0fffb17 	ldw	r3,-20(fp)
 90b9914:	00800084 	movi	r2,2
 90b9918:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 90b991c:	e0bffa17 	ldw	r2,-24(fp)
 90b9920:	1080020b 	ldhu	r2,8(r2)
 90b9924:	10bfffcc 	andi	r2,r2,65535
 90b9928:	1004d23a 	srli	r2,r2,8
 90b992c:	10803fcc 	andi	r2,r2,255
 90b9930:	1009883a 	mov	r4,r2
 90b9934:	e0bffa17 	ldw	r2,-24(fp)
 90b9938:	1080020b 	ldhu	r2,8(r2)
 90b993c:	10bfffcc 	andi	r2,r2,65535
 90b9940:	1004923a 	slli	r2,r2,8
 90b9944:	1007883a 	mov	r3,r2
 90b9948:	00bfc004 	movi	r2,-256
 90b994c:	1884703a 	and	r2,r3,r2
 90b9950:	2084b03a 	or	r2,r4,r2
 90b9954:	1007883a 	mov	r3,r2
 90b9958:	e0bffb17 	ldw	r2,-20(fp)
 90b995c:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 90b9960:	e0bffa17 	ldw	r2,-24(fp)
 90b9964:	10c00417 	ldw	r3,16(r2)
 90b9968:	e0bffb17 	ldw	r2,-20(fp)
 90b996c:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 90b9970:	e03fff15 	stw	zero,-4(fp)
 90b9974:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9978:	e037883a 	mov	sp,fp
 90b997c:	dfc00117 	ldw	ra,4(sp)
 90b9980:	df000017 	ldw	fp,0(sp)
 90b9984:	dec00204 	addi	sp,sp,8
 90b9988:	f800283a 	ret

090b998c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 90b998c:	defff404 	addi	sp,sp,-48
 90b9990:	df000b15 	stw	fp,44(sp)
 90b9994:	df000b04 	addi	fp,sp,44
 90b9998:	e13ffb15 	stw	r4,-20(fp)
 90b999c:	e17ffc15 	stw	r5,-16(fp)
 90b99a0:	e1bffd15 	stw	r6,-12(fp)
 90b99a4:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 90b99a8:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 90b99ac:	00824374 	movhi	r2,2317
 90b99b0:	108f3e04 	addi	r2,r2,15608
 90b99b4:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 90b99b8:	1005003a 	cmpeq	r2,r2,zero
 90b99bc:	1000411e 	bne	r2,zero,90b9ac4 <alt_alarm_start+0x138>
  {
    if (alarm)
 90b99c0:	e0bffb17 	ldw	r2,-20(fp)
 90b99c4:	1005003a 	cmpeq	r2,r2,zero
 90b99c8:	10003b1e 	bne	r2,zero,90b9ab8 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 90b99cc:	e0fffb17 	ldw	r3,-20(fp)
 90b99d0:	e0bffd17 	ldw	r2,-12(fp)
 90b99d4:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 90b99d8:	e0fffb17 	ldw	r3,-20(fp)
 90b99dc:	e0bffe17 	ldw	r2,-8(fp)
 90b99e0:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b99e4:	0005303a 	rdctl	r2,status
 90b99e8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b99ec:	e0fff817 	ldw	r3,-32(fp)
 90b99f0:	00bfff84 	movi	r2,-2
 90b99f4:	1884703a 	and	r2,r3,r2
 90b99f8:	1001703a 	wrctl	status,r2
  
  return context;
 90b99fc:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 90b9a00:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 90b9a04:	00824374 	movhi	r2,2317
 90b9a08:	108f3f04 	addi	r2,r2,15612
 90b9a0c:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 90b9a10:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 90b9a14:	e0fffc17 	ldw	r3,-16(fp)
 90b9a18:	e0bff917 	ldw	r2,-28(fp)
 90b9a1c:	1885883a 	add	r2,r3,r2
 90b9a20:	10c00044 	addi	r3,r2,1
 90b9a24:	e0bffb17 	ldw	r2,-20(fp)
 90b9a28:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 90b9a2c:	e0bffb17 	ldw	r2,-20(fp)
 90b9a30:	10c00217 	ldw	r3,8(r2)
 90b9a34:	e0bff917 	ldw	r2,-28(fp)
 90b9a38:	1880042e 	bgeu	r3,r2,90b9a4c <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 90b9a3c:	e0fffb17 	ldw	r3,-20(fp)
 90b9a40:	00800044 	movi	r2,1
 90b9a44:	18800405 	stb	r2,16(r3)
 90b9a48:	00000206 	br	90b9a54 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 90b9a4c:	e0bffb17 	ldw	r2,-20(fp)
 90b9a50:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 90b9a54:	e0fffb17 	ldw	r3,-20(fp)
 90b9a58:	00824374 	movhi	r2,2317
 90b9a5c:	108ece04 	addi	r2,r2,15160
 90b9a60:	e0bff615 	stw	r2,-40(fp)
 90b9a64:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 90b9a68:	e0fff717 	ldw	r3,-36(fp)
 90b9a6c:	e0bff617 	ldw	r2,-40(fp)
 90b9a70:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 90b9a74:	e0bff617 	ldw	r2,-40(fp)
 90b9a78:	10c00017 	ldw	r3,0(r2)
 90b9a7c:	e0bff717 	ldw	r2,-36(fp)
 90b9a80:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 90b9a84:	e0bff617 	ldw	r2,-40(fp)
 90b9a88:	10c00017 	ldw	r3,0(r2)
 90b9a8c:	e0bff717 	ldw	r2,-36(fp)
 90b9a90:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 90b9a94:	e0fff617 	ldw	r3,-40(fp)
 90b9a98:	e0bff717 	ldw	r2,-36(fp)
 90b9a9c:	18800015 	stw	r2,0(r3)
 90b9aa0:	e0bffa17 	ldw	r2,-24(fp)
 90b9aa4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90b9aa8:	e0bff517 	ldw	r2,-44(fp)
 90b9aac:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 90b9ab0:	e03fff15 	stw	zero,-4(fp)
 90b9ab4:	00000506 	br	90b9acc <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 90b9ab8:	00bffa84 	movi	r2,-22
 90b9abc:	e0bfff15 	stw	r2,-4(fp)
 90b9ac0:	00000206 	br	90b9acc <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 90b9ac4:	00bfde84 	movi	r2,-134
 90b9ac8:	e0bfff15 	stw	r2,-4(fp)
 90b9acc:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 90b9ad0:	e037883a 	mov	sp,fp
 90b9ad4:	df000017 	ldw	fp,0(sp)
 90b9ad8:	dec00104 	addi	sp,sp,4
 90b9adc:	f800283a 	ret

090b9ae0 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 90b9ae0:	defff804 	addi	sp,sp,-32
 90b9ae4:	dfc00715 	stw	ra,28(sp)
 90b9ae8:	df000615 	stw	fp,24(sp)
 90b9aec:	df000604 	addi	fp,sp,24
 90b9af0:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 90b9af4:	e0bffc17 	ldw	r2,-16(fp)
 90b9af8:	1004803a 	cmplt	r2,r2,zero
 90b9afc:	1000081e 	bne	r2,zero,90b9b20 <alt_close+0x40>
 90b9b00:	e0bffc17 	ldw	r2,-16(fp)
 90b9b04:	10800324 	muli	r2,r2,12
 90b9b08:	1007883a 	mov	r3,r2
 90b9b0c:	00824374 	movhi	r2,2317
 90b9b10:	108dc104 	addi	r2,r2,14084
 90b9b14:	1887883a 	add	r3,r3,r2
 90b9b18:	e0ffff15 	stw	r3,-4(fp)
 90b9b1c:	00000106 	br	90b9b24 <alt_close+0x44>
 90b9b20:	e03fff15 	stw	zero,-4(fp)
 90b9b24:	e0bfff17 	ldw	r2,-4(fp)
 90b9b28:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 90b9b2c:	e0bffb17 	ldw	r2,-20(fp)
 90b9b30:	1005003a 	cmpeq	r2,r2,zero
 90b9b34:	10001d1e 	bne	r2,zero,90b9bac <alt_close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 90b9b38:	e0bffb17 	ldw	r2,-20(fp)
 90b9b3c:	10800017 	ldw	r2,0(r2)
 90b9b40:	10800417 	ldw	r2,16(r2)
 90b9b44:	1005003a 	cmpeq	r2,r2,zero
 90b9b48:	1000071e 	bne	r2,zero,90b9b68 <alt_close+0x88>
 90b9b4c:	e0bffb17 	ldw	r2,-20(fp)
 90b9b50:	10800017 	ldw	r2,0(r2)
 90b9b54:	10800417 	ldw	r2,16(r2)
 90b9b58:	e13ffb17 	ldw	r4,-20(fp)
 90b9b5c:	103ee83a 	callr	r2
 90b9b60:	e0bffe15 	stw	r2,-8(fp)
 90b9b64:	00000106 	br	90b9b6c <alt_close+0x8c>
 90b9b68:	e03ffe15 	stw	zero,-8(fp)
 90b9b6c:	e0bffe17 	ldw	r2,-8(fp)
 90b9b70:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 90b9b74:	e13ffc17 	ldw	r4,-16(fp)
 90b9b78:	90ba7a40 	call	90ba7a4 <alt_release_fd>
    if (rval < 0)
 90b9b7c:	e0bffa17 	ldw	r2,-24(fp)
 90b9b80:	1004403a 	cmpge	r2,r2,zero
 90b9b84:	1000071e 	bne	r2,zero,90b9ba4 <alt_close+0xc4>
    {
      ALT_ERRNO = -rval;
 90b9b88:	90b9bdc0 	call	90b9bdc <alt_get_errno>
 90b9b8c:	e0fffa17 	ldw	r3,-24(fp)
 90b9b90:	00c7c83a 	sub	r3,zero,r3
 90b9b94:	10c00015 	stw	r3,0(r2)
      return -1;
 90b9b98:	00bfffc4 	movi	r2,-1
 90b9b9c:	e0bffd15 	stw	r2,-12(fp)
 90b9ba0:	00000806 	br	90b9bc4 <alt_close+0xe4>
    }
    return 0;
 90b9ba4:	e03ffd15 	stw	zero,-12(fp)
 90b9ba8:	00000606 	br	90b9bc4 <alt_close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 90b9bac:	90b9bdc0 	call	90b9bdc <alt_get_errno>
 90b9bb0:	1007883a 	mov	r3,r2
 90b9bb4:	00801444 	movi	r2,81
 90b9bb8:	18800015 	stw	r2,0(r3)
    return -1;
 90b9bbc:	00bfffc4 	movi	r2,-1
 90b9bc0:	e0bffd15 	stw	r2,-12(fp)
 90b9bc4:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 90b9bc8:	e037883a 	mov	sp,fp
 90b9bcc:	dfc00117 	ldw	ra,4(sp)
 90b9bd0:	df000017 	ldw	fp,0(sp)
 90b9bd4:	dec00204 	addi	sp,sp,8
 90b9bd8:	f800283a 	ret

090b9bdc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b9bdc:	defffd04 	addi	sp,sp,-12
 90b9be0:	dfc00215 	stw	ra,8(sp)
 90b9be4:	df000115 	stw	fp,4(sp)
 90b9be8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b9bec:	00824374 	movhi	r2,2317
 90b9bf0:	108eca04 	addi	r2,r2,15144
 90b9bf4:	10800017 	ldw	r2,0(r2)
 90b9bf8:	1005003a 	cmpeq	r2,r2,zero
 90b9bfc:	1000061e 	bne	r2,zero,90b9c18 <alt_get_errno+0x3c>
 90b9c00:	00824374 	movhi	r2,2317
 90b9c04:	108eca04 	addi	r2,r2,15144
 90b9c08:	10800017 	ldw	r2,0(r2)
 90b9c0c:	103ee83a 	callr	r2
 90b9c10:	e0bfff15 	stw	r2,-4(fp)
 90b9c14:	00000306 	br	90b9c24 <alt_get_errno+0x48>
 90b9c18:	00824374 	movhi	r2,2317
 90b9c1c:	108ee904 	addi	r2,r2,15268
 90b9c20:	e0bfff15 	stw	r2,-4(fp)
 90b9c24:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9c28:	e037883a 	mov	sp,fp
 90b9c2c:	dfc00117 	ldw	ra,4(sp)
 90b9c30:	df000017 	ldw	fp,0(sp)
 90b9c34:	dec00204 	addi	sp,sp,8
 90b9c38:	f800283a 	ret

090b9c3c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 90b9c3c:	defffb04 	addi	sp,sp,-20
 90b9c40:	df000415 	stw	fp,16(sp)
 90b9c44:	df000404 	addi	fp,sp,16
 90b9c48:	e13ffe15 	stw	r4,-8(fp)
 90b9c4c:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 90b9c50:	e0fffe17 	ldw	r3,-8(fp)
 90b9c54:	e0bfff17 	ldw	r2,-4(fp)
 90b9c58:	1885883a 	add	r2,r3,r2
 90b9c5c:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 90b9c60:	e0bffe17 	ldw	r2,-8(fp)
 90b9c64:	e0bffd15 	stw	r2,-12(fp)
 90b9c68:	00000506 	br	90b9c80 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 90b9c6c:	e0bffd17 	ldw	r2,-12(fp)
 90b9c70:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 90b9c74:	e0bffd17 	ldw	r2,-12(fp)
 90b9c78:	10800804 	addi	r2,r2,32
 90b9c7c:	e0bffd15 	stw	r2,-12(fp)
 90b9c80:	e0fffd17 	ldw	r3,-12(fp)
 90b9c84:	e0bffc17 	ldw	r2,-16(fp)
 90b9c88:	18bff836 	bltu	r3,r2,90b9c6c <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 90b9c8c:	e0bffe17 	ldw	r2,-8(fp)
 90b9c90:	108007cc 	andi	r2,r2,31
 90b9c94:	1005003a 	cmpeq	r2,r2,zero
 90b9c98:	1000021e 	bne	r2,zero,90b9ca4 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 90b9c9c:	e0bffd17 	ldw	r2,-12(fp)
 90b9ca0:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 90b9ca4:	e037883a 	mov	sp,fp
 90b9ca8:	df000017 	ldw	fp,0(sp)
 90b9cac:	dec00104 	addi	sp,sp,4
 90b9cb0:	f800283a 	ret

090b9cb4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 90b9cb4:	defffc04 	addi	sp,sp,-16
 90b9cb8:	df000315 	stw	fp,12(sp)
 90b9cbc:	df000304 	addi	fp,sp,12
 90b9cc0:	e13ffd15 	stw	r4,-12(fp)
 90b9cc4:	e17ffe15 	stw	r5,-8(fp)
 90b9cc8:	e1bfff15 	stw	r6,-4(fp)
  return len;
 90b9ccc:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9cd0:	e037883a 	mov	sp,fp
 90b9cd4:	df000017 	ldw	fp,0(sp)
 90b9cd8:	dec00104 	addi	sp,sp,4
 90b9cdc:	f800283a 	ret

090b9ce0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 90b9ce0:	defff904 	addi	sp,sp,-28
 90b9ce4:	dfc00615 	stw	ra,24(sp)
 90b9ce8:	df000515 	stw	fp,20(sp)
 90b9cec:	df000504 	addi	fp,sp,20
 90b9cf0:	e13ffd15 	stw	r4,-12(fp)
 90b9cf4:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 90b9cf8:	e0bffd17 	ldw	r2,-12(fp)
 90b9cfc:	1005003a 	cmpeq	r2,r2,zero
 90b9d00:	1000041e 	bne	r2,zero,90b9d14 <alt_dev_llist_insert+0x34>
 90b9d04:	e0bffd17 	ldw	r2,-12(fp)
 90b9d08:	10800217 	ldw	r2,8(r2)
 90b9d0c:	1004c03a 	cmpne	r2,r2,zero
 90b9d10:	1000071e 	bne	r2,zero,90b9d30 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 90b9d14:	90b9d940 	call	90b9d94 <alt_get_errno>
 90b9d18:	1007883a 	mov	r3,r2
 90b9d1c:	00800584 	movi	r2,22
 90b9d20:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 90b9d24:	00bffa84 	movi	r2,-22
 90b9d28:	e0bfff15 	stw	r2,-4(fp)
 90b9d2c:	00001306 	br	90b9d7c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 90b9d30:	e0fffd17 	ldw	r3,-12(fp)
 90b9d34:	e0bffe17 	ldw	r2,-8(fp)
 90b9d38:	e0bffb15 	stw	r2,-20(fp)
 90b9d3c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 90b9d40:	e0fffc17 	ldw	r3,-16(fp)
 90b9d44:	e0bffb17 	ldw	r2,-20(fp)
 90b9d48:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 90b9d4c:	e0bffb17 	ldw	r2,-20(fp)
 90b9d50:	10c00017 	ldw	r3,0(r2)
 90b9d54:	e0bffc17 	ldw	r2,-16(fp)
 90b9d58:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 90b9d5c:	e0bffb17 	ldw	r2,-20(fp)
 90b9d60:	10c00017 	ldw	r3,0(r2)
 90b9d64:	e0bffc17 	ldw	r2,-16(fp)
 90b9d68:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 90b9d6c:	e0fffb17 	ldw	r3,-20(fp)
 90b9d70:	e0bffc17 	ldw	r2,-16(fp)
 90b9d74:	18800015 	stw	r2,0(r3)

  return 0;  
 90b9d78:	e03fff15 	stw	zero,-4(fp)
 90b9d7c:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9d80:	e037883a 	mov	sp,fp
 90b9d84:	dfc00117 	ldw	ra,4(sp)
 90b9d88:	df000017 	ldw	fp,0(sp)
 90b9d8c:	dec00204 	addi	sp,sp,8
 90b9d90:	f800283a 	ret

090b9d94 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90b9d94:	defffd04 	addi	sp,sp,-12
 90b9d98:	dfc00215 	stw	ra,8(sp)
 90b9d9c:	df000115 	stw	fp,4(sp)
 90b9da0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90b9da4:	00824374 	movhi	r2,2317
 90b9da8:	108eca04 	addi	r2,r2,15144
 90b9dac:	10800017 	ldw	r2,0(r2)
 90b9db0:	1005003a 	cmpeq	r2,r2,zero
 90b9db4:	1000061e 	bne	r2,zero,90b9dd0 <alt_get_errno+0x3c>
 90b9db8:	00824374 	movhi	r2,2317
 90b9dbc:	108eca04 	addi	r2,r2,15144
 90b9dc0:	10800017 	ldw	r2,0(r2)
 90b9dc4:	103ee83a 	callr	r2
 90b9dc8:	e0bfff15 	stw	r2,-4(fp)
 90b9dcc:	00000306 	br	90b9ddc <alt_get_errno+0x48>
 90b9dd0:	00824374 	movhi	r2,2317
 90b9dd4:	108ee904 	addi	r2,r2,15268
 90b9dd8:	e0bfff15 	stw	r2,-4(fp)
 90b9ddc:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9de0:	e037883a 	mov	sp,fp
 90b9de4:	dfc00117 	ldw	ra,4(sp)
 90b9de8:	df000017 	ldw	fp,0(sp)
 90b9dec:	dec00204 	addi	sp,sp,8
 90b9df0:	f800283a 	ret

090b9df4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 90b9df4:	defff904 	addi	sp,sp,-28
 90b9df8:	dfc00615 	stw	ra,24(sp)
 90b9dfc:	df000515 	stw	fp,20(sp)
 90b9e00:	df000504 	addi	fp,sp,20
 90b9e04:	e13ffd15 	stw	r4,-12(fp)
 90b9e08:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 90b9e0c:	e0bffe17 	ldw	r2,-8(fp)
 90b9e10:	10800017 	ldw	r2,0(r2)
 90b9e14:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 90b9e18:	e13ffd17 	ldw	r4,-12(fp)
 90b9e1c:	9083f540 	call	9083f54 <strlen>
 90b9e20:	10800044 	addi	r2,r2,1
 90b9e24:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 90b9e28:	00000d06 	br	90b9e60 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 90b9e2c:	e0bffc17 	ldw	r2,-16(fp)
 90b9e30:	11000217 	ldw	r4,8(r2)
 90b9e34:	e1bffb17 	ldw	r6,-20(fp)
 90b9e38:	e17ffd17 	ldw	r5,-12(fp)
 90b9e3c:	90cb4540 	call	90cb454 <memcmp>
 90b9e40:	1004c03a 	cmpne	r2,r2,zero
 90b9e44:	1000031e 	bne	r2,zero,90b9e54 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 90b9e48:	e0bffc17 	ldw	r2,-16(fp)
 90b9e4c:	e0bfff15 	stw	r2,-4(fp)
 90b9e50:	00000706 	br	90b9e70 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 90b9e54:	e0bffc17 	ldw	r2,-16(fp)
 90b9e58:	10800017 	ldw	r2,0(r2)
 90b9e5c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 90b9e60:	e0fffe17 	ldw	r3,-8(fp)
 90b9e64:	e0bffc17 	ldw	r2,-16(fp)
 90b9e68:	10fff01e 	bne	r2,r3,90b9e2c <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 90b9e6c:	e03fff15 	stw	zero,-4(fp)
 90b9e70:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9e74:	e037883a 	mov	sp,fp
 90b9e78:	dfc00117 	ldw	ra,4(sp)
 90b9e7c:	df000017 	ldw	fp,0(sp)
 90b9e80:	dec00204 	addi	sp,sp,8
 90b9e84:	f800283a 	ret

090b9e88 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 90b9e88:	defffb04 	addi	sp,sp,-20
 90b9e8c:	dfc00415 	stw	ra,16(sp)
 90b9e90:	df000315 	stw	fp,12(sp)
 90b9e94:	df000304 	addi	fp,sp,12
 90b9e98:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 90b9e9c:	e13ffe17 	ldw	r4,-8(fp)
 90b9ea0:	d1604604 	addi	r5,gp,-32488
 90b9ea4:	90b9df40 	call	90b9df4 <alt_find_dev>
 90b9ea8:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 90b9eac:	e0bffd17 	ldw	r2,-12(fp)
 90b9eb0:	1005003a 	cmpeq	r2,r2,zero
 90b9eb4:	10000b1e 	bne	r2,zero,90b9ee4 <alt_flash_open_dev+0x5c>
 90b9eb8:	e0bffd17 	ldw	r2,-12(fp)
 90b9ebc:	10800317 	ldw	r2,12(r2)
 90b9ec0:	1005003a 	cmpeq	r2,r2,zero
 90b9ec4:	1000071e 	bne	r2,zero,90b9ee4 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 90b9ec8:	e0bffd17 	ldw	r2,-12(fp)
 90b9ecc:	10800317 	ldw	r2,12(r2)
 90b9ed0:	e13ffd17 	ldw	r4,-12(fp)
 90b9ed4:	e17ffe17 	ldw	r5,-8(fp)
 90b9ed8:	103ee83a 	callr	r2
 90b9edc:	e0bfff15 	stw	r2,-4(fp)
 90b9ee0:	00000206 	br	90b9eec <alt_flash_open_dev+0x64>
  }

  return dev;
 90b9ee4:	e0bffd17 	ldw	r2,-12(fp)
 90b9ee8:	e0bfff15 	stw	r2,-4(fp)
 90b9eec:	e0bfff17 	ldw	r2,-4(fp)
}
 90b9ef0:	e037883a 	mov	sp,fp
 90b9ef4:	dfc00117 	ldw	ra,4(sp)
 90b9ef8:	df000017 	ldw	fp,0(sp)
 90b9efc:	dec00204 	addi	sp,sp,8
 90b9f00:	f800283a 	ret

090b9f04 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 90b9f04:	defffd04 	addi	sp,sp,-12
 90b9f08:	dfc00215 	stw	ra,8(sp)
 90b9f0c:	df000115 	stw	fp,4(sp)
 90b9f10:	df000104 	addi	fp,sp,4
 90b9f14:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 90b9f18:	e0bfff17 	ldw	r2,-4(fp)
 90b9f1c:	1005003a 	cmpeq	r2,r2,zero
 90b9f20:	1000081e 	bne	r2,zero,90b9f44 <alt_flash_close_dev+0x40>
 90b9f24:	e0bfff17 	ldw	r2,-4(fp)
 90b9f28:	10800417 	ldw	r2,16(r2)
 90b9f2c:	1005003a 	cmpeq	r2,r2,zero
 90b9f30:	1000041e 	bne	r2,zero,90b9f44 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 90b9f34:	e0bfff17 	ldw	r2,-4(fp)
 90b9f38:	10800417 	ldw	r2,16(r2)
 90b9f3c:	e13fff17 	ldw	r4,-4(fp)
 90b9f40:	103ee83a 	callr	r2
  }
  return;
}
 90b9f44:	e037883a 	mov	sp,fp
 90b9f48:	dfc00117 	ldw	ra,4(sp)
 90b9f4c:	df000017 	ldw	fp,0(sp)
 90b9f50:	dec00204 	addi	sp,sp,8
 90b9f54:	f800283a 	ret

090b9f58 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 90b9f58:	defff904 	addi	sp,sp,-28
 90b9f5c:	dfc00615 	stw	ra,24(sp)
 90b9f60:	df000515 	stw	fp,20(sp)
 90b9f64:	df000504 	addi	fp,sp,20
 90b9f68:	e13ffc15 	stw	r4,-16(fp)
 90b9f6c:	e17ffd15 	stw	r5,-12(fp)
 90b9f70:	e1bffe15 	stw	r6,-8(fp)
 90b9f74:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 90b9f78:	e0800217 	ldw	r2,8(fp)
 90b9f7c:	d8800015 	stw	r2,0(sp)
 90b9f80:	e13ffc17 	ldw	r4,-16(fp)
 90b9f84:	e17ffd17 	ldw	r5,-12(fp)
 90b9f88:	e1bffe17 	ldw	r6,-8(fp)
 90b9f8c:	e1ffff17 	ldw	r7,-4(fp)
 90b9f90:	90ba12c0 	call	90ba12c <alt_iic_isr_register>
}  
 90b9f94:	e037883a 	mov	sp,fp
 90b9f98:	dfc00117 	ldw	ra,4(sp)
 90b9f9c:	df000017 	ldw	fp,0(sp)
 90b9fa0:	dec00204 	addi	sp,sp,8
 90b9fa4:	f800283a 	ret

090b9fa8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 90b9fa8:	defff904 	addi	sp,sp,-28
 90b9fac:	df000615 	stw	fp,24(sp)
 90b9fb0:	df000604 	addi	fp,sp,24
 90b9fb4:	e13ffe15 	stw	r4,-8(fp)
 90b9fb8:	e17fff15 	stw	r5,-4(fp)
 90b9fbc:	e0bfff17 	ldw	r2,-4(fp)
 90b9fc0:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90b9fc4:	0005303a 	rdctl	r2,status
 90b9fc8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90b9fcc:	e0fffb17 	ldw	r3,-20(fp)
 90b9fd0:	00bfff84 	movi	r2,-2
 90b9fd4:	1884703a 	and	r2,r3,r2
 90b9fd8:	1001703a 	wrctl	status,r2
  
  return context;
 90b9fdc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 90b9fe0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 90b9fe4:	e0fffc17 	ldw	r3,-16(fp)
 90b9fe8:	00800044 	movi	r2,1
 90b9fec:	10c4983a 	sll	r2,r2,r3
 90b9ff0:	1007883a 	mov	r3,r2
 90b9ff4:	00824374 	movhi	r2,2317
 90b9ff8:	108f3d04 	addi	r2,r2,15604
 90b9ffc:	10800017 	ldw	r2,0(r2)
 90ba000:	1886b03a 	or	r3,r3,r2
 90ba004:	00824374 	movhi	r2,2317
 90ba008:	108f3d04 	addi	r2,r2,15604
 90ba00c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 90ba010:	00824374 	movhi	r2,2317
 90ba014:	108f3d04 	addi	r2,r2,15604
 90ba018:	10800017 	ldw	r2,0(r2)
 90ba01c:	100170fa 	wrctl	ienable,r2
 90ba020:	e0bffd17 	ldw	r2,-12(fp)
 90ba024:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90ba028:	e0bffa17 	ldw	r2,-24(fp)
 90ba02c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 90ba030:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 90ba034:	e037883a 	mov	sp,fp
 90ba038:	df000017 	ldw	fp,0(sp)
 90ba03c:	dec00104 	addi	sp,sp,4
 90ba040:	f800283a 	ret

090ba044 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 90ba044:	defff904 	addi	sp,sp,-28
 90ba048:	df000615 	stw	fp,24(sp)
 90ba04c:	df000604 	addi	fp,sp,24
 90ba050:	e13ffe15 	stw	r4,-8(fp)
 90ba054:	e17fff15 	stw	r5,-4(fp)
 90ba058:	e0bfff17 	ldw	r2,-4(fp)
 90ba05c:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90ba060:	0005303a 	rdctl	r2,status
 90ba064:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90ba068:	e0fffb17 	ldw	r3,-20(fp)
 90ba06c:	00bfff84 	movi	r2,-2
 90ba070:	1884703a 	and	r2,r3,r2
 90ba074:	1001703a 	wrctl	status,r2
  
  return context;
 90ba078:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 90ba07c:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 90ba080:	e0fffc17 	ldw	r3,-16(fp)
 90ba084:	00800044 	movi	r2,1
 90ba088:	10c4983a 	sll	r2,r2,r3
 90ba08c:	0084303a 	nor	r2,zero,r2
 90ba090:	1007883a 	mov	r3,r2
 90ba094:	00824374 	movhi	r2,2317
 90ba098:	108f3d04 	addi	r2,r2,15604
 90ba09c:	10800017 	ldw	r2,0(r2)
 90ba0a0:	1886703a 	and	r3,r3,r2
 90ba0a4:	00824374 	movhi	r2,2317
 90ba0a8:	108f3d04 	addi	r2,r2,15604
 90ba0ac:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 90ba0b0:	00824374 	movhi	r2,2317
 90ba0b4:	108f3d04 	addi	r2,r2,15604
 90ba0b8:	10800017 	ldw	r2,0(r2)
 90ba0bc:	100170fa 	wrctl	ienable,r2
 90ba0c0:	e0bffd17 	ldw	r2,-12(fp)
 90ba0c4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90ba0c8:	e0bffa17 	ldw	r2,-24(fp)
 90ba0cc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 90ba0d0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 90ba0d4:	e037883a 	mov	sp,fp
 90ba0d8:	df000017 	ldw	fp,0(sp)
 90ba0dc:	dec00104 	addi	sp,sp,4
 90ba0e0:	f800283a 	ret

090ba0e4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 90ba0e4:	defffc04 	addi	sp,sp,-16
 90ba0e8:	df000315 	stw	fp,12(sp)
 90ba0ec:	df000304 	addi	fp,sp,12
 90ba0f0:	e13ffe15 	stw	r4,-8(fp)
 90ba0f4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 90ba0f8:	000530fa 	rdctl	r2,ienable
 90ba0fc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 90ba100:	e0ffff17 	ldw	r3,-4(fp)
 90ba104:	00800044 	movi	r2,1
 90ba108:	10c4983a 	sll	r2,r2,r3
 90ba10c:	1007883a 	mov	r3,r2
 90ba110:	e0bffd17 	ldw	r2,-12(fp)
 90ba114:	1884703a 	and	r2,r3,r2
 90ba118:	1004c03a 	cmpne	r2,r2,zero
}
 90ba11c:	e037883a 	mov	sp,fp
 90ba120:	df000017 	ldw	fp,0(sp)
 90ba124:	dec00104 	addi	sp,sp,4
 90ba128:	f800283a 	ret

090ba12c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 90ba12c:	defff404 	addi	sp,sp,-48
 90ba130:	dfc00b15 	stw	ra,44(sp)
 90ba134:	df000a15 	stw	fp,40(sp)
 90ba138:	df000a04 	addi	fp,sp,40
 90ba13c:	e13ffb15 	stw	r4,-20(fp)
 90ba140:	e17ffc15 	stw	r5,-16(fp)
 90ba144:	e1bffd15 	stw	r6,-12(fp)
 90ba148:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 90ba14c:	00bffa84 	movi	r2,-22
 90ba150:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 90ba154:	e0bffc17 	ldw	r2,-16(fp)
 90ba158:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 90ba15c:	e0bff917 	ldw	r2,-28(fp)
 90ba160:	10800808 	cmpgei	r2,r2,32
 90ba164:	1000291e 	bne	r2,zero,90ba20c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90ba168:	0005303a 	rdctl	r2,status
 90ba16c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90ba170:	e0fff717 	ldw	r3,-36(fp)
 90ba174:	00bfff84 	movi	r2,-2
 90ba178:	1884703a 	and	r2,r3,r2
 90ba17c:	1001703a 	wrctl	status,r2
  
  return context;
 90ba180:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 90ba184:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 90ba188:	e0bff917 	ldw	r2,-28(fp)
 90ba18c:	00c243b4 	movhi	r3,2318
 90ba190:	18f78e04 	addi	r3,r3,-8648
 90ba194:	100490fa 	slli	r2,r2,3
 90ba198:	10c7883a 	add	r3,r2,r3
 90ba19c:	e0bffd17 	ldw	r2,-12(fp)
 90ba1a0:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 90ba1a4:	e0bff917 	ldw	r2,-28(fp)
 90ba1a8:	00c243b4 	movhi	r3,2318
 90ba1ac:	18f78e04 	addi	r3,r3,-8648
 90ba1b0:	100490fa 	slli	r2,r2,3
 90ba1b4:	10c5883a 	add	r2,r2,r3
 90ba1b8:	10c00104 	addi	r3,r2,4
 90ba1bc:	e0bffe17 	ldw	r2,-8(fp)
 90ba1c0:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 90ba1c4:	e0bffd17 	ldw	r2,-12(fp)
 90ba1c8:	1005003a 	cmpeq	r2,r2,zero
 90ba1cc:	1000051e 	bne	r2,zero,90ba1e4 <alt_iic_isr_register+0xb8>
 90ba1d0:	e17ff917 	ldw	r5,-28(fp)
 90ba1d4:	e13ffb17 	ldw	r4,-20(fp)
 90ba1d8:	90b9fa80 	call	90b9fa8 <alt_ic_irq_enable>
 90ba1dc:	e0bfff15 	stw	r2,-4(fp)
 90ba1e0:	00000406 	br	90ba1f4 <alt_iic_isr_register+0xc8>
 90ba1e4:	e17ff917 	ldw	r5,-28(fp)
 90ba1e8:	e13ffb17 	ldw	r4,-20(fp)
 90ba1ec:	90ba0440 	call	90ba044 <alt_ic_irq_disable>
 90ba1f0:	e0bfff15 	stw	r2,-4(fp)
 90ba1f4:	e0bfff17 	ldw	r2,-4(fp)
 90ba1f8:	e0bffa15 	stw	r2,-24(fp)
 90ba1fc:	e0bff817 	ldw	r2,-32(fp)
 90ba200:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90ba204:	e0bff617 	ldw	r2,-40(fp)
 90ba208:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 90ba20c:	e0bffa17 	ldw	r2,-24(fp)
}
 90ba210:	e037883a 	mov	sp,fp
 90ba214:	dfc00117 	ldw	ra,4(sp)
 90ba218:	df000017 	ldw	fp,0(sp)
 90ba21c:	dec00204 	addi	sp,sp,8
 90ba220:	f800283a 	ret

090ba224 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 90ba224:	defff904 	addi	sp,sp,-28
 90ba228:	dfc00615 	stw	ra,24(sp)
 90ba22c:	df000515 	stw	fp,20(sp)
 90ba230:	df000504 	addi	fp,sp,20
 90ba234:	e13ffc15 	stw	r4,-16(fp)
 90ba238:	e17ffd15 	stw	r5,-12(fp)
 90ba23c:	e1bffe15 	stw	r6,-8(fp)
 90ba240:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 90ba244:	e13ffd17 	ldw	r4,-12(fp)
 90ba248:	e17ffe17 	ldw	r5,-8(fp)
 90ba24c:	e1bfff17 	ldw	r6,-4(fp)
 90ba250:	90ba43c0 	call	90ba43c <open>
 90ba254:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 90ba258:	e0bffb17 	ldw	r2,-20(fp)
 90ba25c:	1004803a 	cmplt	r2,r2,zero
 90ba260:	10001c1e 	bne	r2,zero,90ba2d4 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 90ba264:	e0bffb17 	ldw	r2,-20(fp)
 90ba268:	00c24374 	movhi	r3,2317
 90ba26c:	18cdc104 	addi	r3,r3,14084
 90ba270:	10800324 	muli	r2,r2,12
 90ba274:	10c5883a 	add	r2,r2,r3
 90ba278:	10c00017 	ldw	r3,0(r2)
 90ba27c:	e0bffc17 	ldw	r2,-16(fp)
 90ba280:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 90ba284:	e0bffb17 	ldw	r2,-20(fp)
 90ba288:	00c24374 	movhi	r3,2317
 90ba28c:	18cdc104 	addi	r3,r3,14084
 90ba290:	10800324 	muli	r2,r2,12
 90ba294:	10c5883a 	add	r2,r2,r3
 90ba298:	10800104 	addi	r2,r2,4
 90ba29c:	10c00017 	ldw	r3,0(r2)
 90ba2a0:	e0bffc17 	ldw	r2,-16(fp)
 90ba2a4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 90ba2a8:	e0bffb17 	ldw	r2,-20(fp)
 90ba2ac:	00c24374 	movhi	r3,2317
 90ba2b0:	18cdc104 	addi	r3,r3,14084
 90ba2b4:	10800324 	muli	r2,r2,12
 90ba2b8:	10c5883a 	add	r2,r2,r3
 90ba2bc:	10800204 	addi	r2,r2,8
 90ba2c0:	10c00017 	ldw	r3,0(r2)
 90ba2c4:	e0bffc17 	ldw	r2,-16(fp)
 90ba2c8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 90ba2cc:	e13ffb17 	ldw	r4,-20(fp)
 90ba2d0:	90ba7a40 	call	90ba7a4 <alt_release_fd>
  }
} 
 90ba2d4:	e037883a 	mov	sp,fp
 90ba2d8:	dfc00117 	ldw	ra,4(sp)
 90ba2dc:	df000017 	ldw	fp,0(sp)
 90ba2e0:	dec00204 	addi	sp,sp,8
 90ba2e4:	f800283a 	ret

090ba2e8 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 90ba2e8:	defffb04 	addi	sp,sp,-20
 90ba2ec:	dfc00415 	stw	ra,16(sp)
 90ba2f0:	df000315 	stw	fp,12(sp)
 90ba2f4:	df000304 	addi	fp,sp,12
 90ba2f8:	e13ffd15 	stw	r4,-12(fp)
 90ba2fc:	e17ffe15 	stw	r5,-8(fp)
 90ba300:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 90ba304:	01024374 	movhi	r4,2317
 90ba308:	210dc404 	addi	r4,r4,14096
 90ba30c:	e17ffd17 	ldw	r5,-12(fp)
 90ba310:	01800044 	movi	r6,1
 90ba314:	01c07fc4 	movi	r7,511
 90ba318:	90ba2240 	call	90ba224 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 90ba31c:	01024374 	movhi	r4,2317
 90ba320:	210dc104 	addi	r4,r4,14084
 90ba324:	e17ffe17 	ldw	r5,-8(fp)
 90ba328:	000d883a 	mov	r6,zero
 90ba32c:	01c07fc4 	movi	r7,511
 90ba330:	90ba2240 	call	90ba224 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 90ba334:	01024374 	movhi	r4,2317
 90ba338:	210dc704 	addi	r4,r4,14108
 90ba33c:	e17fff17 	ldw	r5,-4(fp)
 90ba340:	01800044 	movi	r6,1
 90ba344:	01c07fc4 	movi	r7,511
 90ba348:	90ba2240 	call	90ba224 <alt_open_fd>
}  
 90ba34c:	e037883a 	mov	sp,fp
 90ba350:	dfc00117 	ldw	ra,4(sp)
 90ba354:	df000017 	ldw	fp,0(sp)
 90ba358:	dec00204 	addi	sp,sp,8
 90ba35c:	f800283a 	ret

090ba360 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 90ba360:	defffc04 	addi	sp,sp,-16
 90ba364:	df000315 	stw	fp,12(sp)
 90ba368:	df000304 	addi	fp,sp,12
 90ba36c:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 90ba370:	e0bffe17 	ldw	r2,-8(fp)
 90ba374:	10800217 	ldw	r2,8(r2)
 90ba378:	10d00034 	orhi	r3,r2,16384
 90ba37c:	e0bffe17 	ldw	r2,-8(fp)
 90ba380:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 90ba384:	e03ffd15 	stw	zero,-12(fp)
 90ba388:	00002006 	br	90ba40c <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 90ba38c:	e0bffd17 	ldw	r2,-12(fp)
 90ba390:	00c24374 	movhi	r3,2317
 90ba394:	18cdc104 	addi	r3,r3,14084
 90ba398:	10800324 	muli	r2,r2,12
 90ba39c:	10c5883a 	add	r2,r2,r3
 90ba3a0:	10c00017 	ldw	r3,0(r2)
 90ba3a4:	e0bffe17 	ldw	r2,-8(fp)
 90ba3a8:	10800017 	ldw	r2,0(r2)
 90ba3ac:	1880141e 	bne	r3,r2,90ba400 <alt_file_locked+0xa0>
 90ba3b0:	e0bffd17 	ldw	r2,-12(fp)
 90ba3b4:	00c24374 	movhi	r3,2317
 90ba3b8:	18cdc104 	addi	r3,r3,14084
 90ba3bc:	10800324 	muli	r2,r2,12
 90ba3c0:	10c5883a 	add	r2,r2,r3
 90ba3c4:	10800204 	addi	r2,r2,8
 90ba3c8:	10800017 	ldw	r2,0(r2)
 90ba3cc:	1004403a 	cmpge	r2,r2,zero
 90ba3d0:	10000b1e 	bne	r2,zero,90ba400 <alt_file_locked+0xa0>
 90ba3d4:	e0bffd17 	ldw	r2,-12(fp)
 90ba3d8:	10800324 	muli	r2,r2,12
 90ba3dc:	1007883a 	mov	r3,r2
 90ba3e0:	00824374 	movhi	r2,2317
 90ba3e4:	108dc104 	addi	r2,r2,14084
 90ba3e8:	1887883a 	add	r3,r3,r2
 90ba3ec:	e0bffe17 	ldw	r2,-8(fp)
 90ba3f0:	18800326 	beq	r3,r2,90ba400 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 90ba3f4:	00bffcc4 	movi	r2,-13
 90ba3f8:	e0bfff15 	stw	r2,-4(fp)
 90ba3fc:	00000a06 	br	90ba428 <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 90ba400:	e0bffd17 	ldw	r2,-12(fp)
 90ba404:	10800044 	addi	r2,r2,1
 90ba408:	e0bffd15 	stw	r2,-12(fp)
 90ba40c:	00824374 	movhi	r2,2317
 90ba410:	108ec904 	addi	r2,r2,15140
 90ba414:	10800017 	ldw	r2,0(r2)
 90ba418:	1007883a 	mov	r3,r2
 90ba41c:	e0bffd17 	ldw	r2,-12(fp)
 90ba420:	18bfda2e 	bgeu	r3,r2,90ba38c <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 90ba424:	e03fff15 	stw	zero,-4(fp)
 90ba428:	e0bfff17 	ldw	r2,-4(fp)
}
 90ba42c:	e037883a 	mov	sp,fp
 90ba430:	df000017 	ldw	fp,0(sp)
 90ba434:	dec00104 	addi	sp,sp,4
 90ba438:	f800283a 	ret

090ba43c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 90ba43c:	defff404 	addi	sp,sp,-48
 90ba440:	dfc00b15 	stw	ra,44(sp)
 90ba444:	df000a15 	stw	fp,40(sp)
 90ba448:	df000a04 	addi	fp,sp,40
 90ba44c:	e13ffb15 	stw	r4,-20(fp)
 90ba450:	e17ffc15 	stw	r5,-16(fp)
 90ba454:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 90ba458:	00bfffc4 	movi	r2,-1
 90ba45c:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 90ba460:	00bffb44 	movi	r2,-19
 90ba464:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 90ba468:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 90ba46c:	e13ffb17 	ldw	r4,-20(fp)
 90ba470:	01424374 	movhi	r5,2317
 90ba474:	294ec704 	addi	r5,r5,15132
 90ba478:	90b9df40 	call	90b9df4 <alt_find_dev>
 90ba47c:	e0bffa15 	stw	r2,-24(fp)
 90ba480:	e0bffa17 	ldw	r2,-24(fp)
 90ba484:	1004c03a 	cmpne	r2,r2,zero
 90ba488:	1000051e 	bne	r2,zero,90ba4a0 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 90ba48c:	e13ffb17 	ldw	r4,-20(fp)
 90ba490:	90c9ea00 	call	90c9ea0 <alt_find_file>
 90ba494:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 90ba498:	00800044 	movi	r2,1
 90ba49c:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 90ba4a0:	e0bffa17 	ldw	r2,-24(fp)
 90ba4a4:	1005003a 	cmpeq	r2,r2,zero
 90ba4a8:	1000301e 	bne	r2,zero,90ba56c <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 90ba4ac:	e13ffa17 	ldw	r4,-24(fp)
 90ba4b0:	90c9fc00 	call	90c9fc0 <alt_get_fd>
 90ba4b4:	e0bff815 	stw	r2,-32(fp)
 90ba4b8:	e0bff817 	ldw	r2,-32(fp)
 90ba4bc:	1004403a 	cmpge	r2,r2,zero
 90ba4c0:	1000031e 	bne	r2,zero,90ba4d0 <open+0x94>
    {
      status = index;
 90ba4c4:	e0bff817 	ldw	r2,-32(fp)
 90ba4c8:	e0bff715 	stw	r2,-36(fp)
 90ba4cc:	00002906 	br	90ba574 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 90ba4d0:	e0bff817 	ldw	r2,-32(fp)
 90ba4d4:	10800324 	muli	r2,r2,12
 90ba4d8:	1007883a 	mov	r3,r2
 90ba4dc:	00824374 	movhi	r2,2317
 90ba4e0:	108dc104 	addi	r2,r2,14084
 90ba4e4:	1885883a 	add	r2,r3,r2
 90ba4e8:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 90ba4ec:	e0fffc17 	ldw	r3,-16(fp)
 90ba4f0:	00900034 	movhi	r2,16384
 90ba4f4:	10bfffc4 	addi	r2,r2,-1
 90ba4f8:	1886703a 	and	r3,r3,r2
 90ba4fc:	e0bff917 	ldw	r2,-28(fp)
 90ba500:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 90ba504:	e0bff617 	ldw	r2,-40(fp)
 90ba508:	1004c03a 	cmpne	r2,r2,zero
 90ba50c:	1000061e 	bne	r2,zero,90ba528 <open+0xec>
 90ba510:	e13ff917 	ldw	r4,-28(fp)
 90ba514:	90ba3600 	call	90ba360 <alt_file_locked>
 90ba518:	e0bff715 	stw	r2,-36(fp)
 90ba51c:	e0bff717 	ldw	r2,-36(fp)
 90ba520:	1004803a 	cmplt	r2,r2,zero
 90ba524:	1000131e 	bne	r2,zero,90ba574 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 90ba528:	e0bffa17 	ldw	r2,-24(fp)
 90ba52c:	10800317 	ldw	r2,12(r2)
 90ba530:	1005003a 	cmpeq	r2,r2,zero
 90ba534:	1000091e 	bne	r2,zero,90ba55c <open+0x120>
 90ba538:	e0bffa17 	ldw	r2,-24(fp)
 90ba53c:	10800317 	ldw	r2,12(r2)
 90ba540:	e13ff917 	ldw	r4,-28(fp)
 90ba544:	e17ffb17 	ldw	r5,-20(fp)
 90ba548:	e1bffc17 	ldw	r6,-16(fp)
 90ba54c:	e1fffd17 	ldw	r7,-12(fp)
 90ba550:	103ee83a 	callr	r2
 90ba554:	e0bfff15 	stw	r2,-4(fp)
 90ba558:	00000106 	br	90ba560 <open+0x124>
 90ba55c:	e03fff15 	stw	zero,-4(fp)
 90ba560:	e0bfff17 	ldw	r2,-4(fp)
 90ba564:	e0bff715 	stw	r2,-36(fp)
 90ba568:	00000206 	br	90ba574 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 90ba56c:	00bffb44 	movi	r2,-19
 90ba570:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 90ba574:	e0bff717 	ldw	r2,-36(fp)
 90ba578:	1004403a 	cmpge	r2,r2,zero
 90ba57c:	1000091e 	bne	r2,zero,90ba5a4 <open+0x168>
  {
    alt_release_fd (index);  
 90ba580:	e13ff817 	ldw	r4,-32(fp)
 90ba584:	90ba7a40 	call	90ba7a4 <alt_release_fd>
    ALT_ERRNO = -status;
 90ba588:	90ba5c40 	call	90ba5c4 <alt_get_errno>
 90ba58c:	e0fff717 	ldw	r3,-36(fp)
 90ba590:	00c7c83a 	sub	r3,zero,r3
 90ba594:	10c00015 	stw	r3,0(r2)
    return -1;
 90ba598:	00bfffc4 	movi	r2,-1
 90ba59c:	e0bffe15 	stw	r2,-8(fp)
 90ba5a0:	00000206 	br	90ba5ac <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 90ba5a4:	e0bff817 	ldw	r2,-32(fp)
 90ba5a8:	e0bffe15 	stw	r2,-8(fp)
 90ba5ac:	e0bffe17 	ldw	r2,-8(fp)
}
 90ba5b0:	e037883a 	mov	sp,fp
 90ba5b4:	dfc00117 	ldw	ra,4(sp)
 90ba5b8:	df000017 	ldw	fp,0(sp)
 90ba5bc:	dec00204 	addi	sp,sp,8
 90ba5c0:	f800283a 	ret

090ba5c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90ba5c4:	defffd04 	addi	sp,sp,-12
 90ba5c8:	dfc00215 	stw	ra,8(sp)
 90ba5cc:	df000115 	stw	fp,4(sp)
 90ba5d0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90ba5d4:	00824374 	movhi	r2,2317
 90ba5d8:	108eca04 	addi	r2,r2,15144
 90ba5dc:	10800017 	ldw	r2,0(r2)
 90ba5e0:	1005003a 	cmpeq	r2,r2,zero
 90ba5e4:	1000061e 	bne	r2,zero,90ba600 <alt_get_errno+0x3c>
 90ba5e8:	00824374 	movhi	r2,2317
 90ba5ec:	108eca04 	addi	r2,r2,15144
 90ba5f0:	10800017 	ldw	r2,0(r2)
 90ba5f4:	103ee83a 	callr	r2
 90ba5f8:	e0bfff15 	stw	r2,-4(fp)
 90ba5fc:	00000306 	br	90ba60c <alt_get_errno+0x48>
 90ba600:	00824374 	movhi	r2,2317
 90ba604:	108ee904 	addi	r2,r2,15268
 90ba608:	e0bfff15 	stw	r2,-4(fp)
 90ba60c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ba610:	e037883a 	mov	sp,fp
 90ba614:	dfc00117 	ldw	ra,4(sp)
 90ba618:	df000017 	ldw	fp,0(sp)
 90ba61c:	dec00204 	addi	sp,sp,8
 90ba620:	f800283a 	ret

090ba624 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 90ba624:	defff704 	addi	sp,sp,-36
 90ba628:	dfc00815 	stw	ra,32(sp)
 90ba62c:	df000715 	stw	fp,28(sp)
 90ba630:	df000704 	addi	fp,sp,28
 90ba634:	e13ffb15 	stw	r4,-20(fp)
 90ba638:	e17ffc15 	stw	r5,-16(fp)
 90ba63c:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90ba640:	e0bffb17 	ldw	r2,-20(fp)
 90ba644:	1004803a 	cmplt	r2,r2,zero
 90ba648:	1000081e 	bne	r2,zero,90ba66c <alt_read+0x48>
 90ba64c:	e0bffb17 	ldw	r2,-20(fp)
 90ba650:	10800324 	muli	r2,r2,12
 90ba654:	1007883a 	mov	r3,r2
 90ba658:	00824374 	movhi	r2,2317
 90ba65c:	108dc104 	addi	r2,r2,14084
 90ba660:	1887883a 	add	r3,r3,r2
 90ba664:	e0ffff15 	stw	r3,-4(fp)
 90ba668:	00000106 	br	90ba670 <alt_read+0x4c>
 90ba66c:	e03fff15 	stw	zero,-4(fp)
 90ba670:	e0bfff17 	ldw	r2,-4(fp)
 90ba674:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 90ba678:	e0bffa17 	ldw	r2,-24(fp)
 90ba67c:	1005003a 	cmpeq	r2,r2,zero
 90ba680:	1000241e 	bne	r2,zero,90ba714 <alt_read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 90ba684:	e0bffa17 	ldw	r2,-24(fp)
 90ba688:	10800217 	ldw	r2,8(r2)
 90ba68c:	108000cc 	andi	r2,r2,3
 90ba690:	10800060 	cmpeqi	r2,r2,1
 90ba694:	10001a1e 	bne	r2,zero,90ba700 <alt_read+0xdc>
 90ba698:	e0bffa17 	ldw	r2,-24(fp)
 90ba69c:	10800017 	ldw	r2,0(r2)
 90ba6a0:	10800517 	ldw	r2,20(r2)
 90ba6a4:	1005003a 	cmpeq	r2,r2,zero
 90ba6a8:	1000151e 	bne	r2,zero,90ba700 <alt_read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 90ba6ac:	e0bffa17 	ldw	r2,-24(fp)
 90ba6b0:	10800017 	ldw	r2,0(r2)
 90ba6b4:	10800517 	ldw	r2,20(r2)
 90ba6b8:	e17ffc17 	ldw	r5,-16(fp)
 90ba6bc:	e1bffd17 	ldw	r6,-12(fp)
 90ba6c0:	e13ffa17 	ldw	r4,-24(fp)
 90ba6c4:	103ee83a 	callr	r2
 90ba6c8:	e0bff915 	stw	r2,-28(fp)
 90ba6cc:	e0bff917 	ldw	r2,-28(fp)
 90ba6d0:	1004403a 	cmpge	r2,r2,zero
 90ba6d4:	1000071e 	bne	r2,zero,90ba6f4 <alt_read+0xd0>
        {
          ALT_ERRNO = -rval;
 90ba6d8:	90ba7440 	call	90ba744 <alt_get_errno>
 90ba6dc:	e0fff917 	ldw	r3,-28(fp)
 90ba6e0:	00c7c83a 	sub	r3,zero,r3
 90ba6e4:	10c00015 	stw	r3,0(r2)
          return -1;
 90ba6e8:	00bfffc4 	movi	r2,-1
 90ba6ec:	e0bffe15 	stw	r2,-8(fp)
 90ba6f0:	00000e06 	br	90ba72c <alt_read+0x108>
        }
        return rval;
 90ba6f4:	e0bff917 	ldw	r2,-28(fp)
 90ba6f8:	e0bffe15 	stw	r2,-8(fp)
 90ba6fc:	00000b06 	br	90ba72c <alt_read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 90ba700:	90ba7440 	call	90ba744 <alt_get_errno>
 90ba704:	1007883a 	mov	r3,r2
 90ba708:	00800344 	movi	r2,13
 90ba70c:	18800015 	stw	r2,0(r3)
 90ba710:	00000406 	br	90ba724 <alt_read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 90ba714:	90ba7440 	call	90ba744 <alt_get_errno>
 90ba718:	1007883a 	mov	r3,r2
 90ba71c:	00801444 	movi	r2,81
 90ba720:	18800015 	stw	r2,0(r3)
  }
  return -1;
 90ba724:	00bfffc4 	movi	r2,-1
 90ba728:	e0bffe15 	stw	r2,-8(fp)
 90ba72c:	e0bffe17 	ldw	r2,-8(fp)
}
 90ba730:	e037883a 	mov	sp,fp
 90ba734:	dfc00117 	ldw	ra,4(sp)
 90ba738:	df000017 	ldw	fp,0(sp)
 90ba73c:	dec00204 	addi	sp,sp,8
 90ba740:	f800283a 	ret

090ba744 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90ba744:	defffd04 	addi	sp,sp,-12
 90ba748:	dfc00215 	stw	ra,8(sp)
 90ba74c:	df000115 	stw	fp,4(sp)
 90ba750:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90ba754:	00824374 	movhi	r2,2317
 90ba758:	108eca04 	addi	r2,r2,15144
 90ba75c:	10800017 	ldw	r2,0(r2)
 90ba760:	1005003a 	cmpeq	r2,r2,zero
 90ba764:	1000061e 	bne	r2,zero,90ba780 <alt_get_errno+0x3c>
 90ba768:	00824374 	movhi	r2,2317
 90ba76c:	108eca04 	addi	r2,r2,15144
 90ba770:	10800017 	ldw	r2,0(r2)
 90ba774:	103ee83a 	callr	r2
 90ba778:	e0bfff15 	stw	r2,-4(fp)
 90ba77c:	00000306 	br	90ba78c <alt_get_errno+0x48>
 90ba780:	00824374 	movhi	r2,2317
 90ba784:	108ee904 	addi	r2,r2,15268
 90ba788:	e0bfff15 	stw	r2,-4(fp)
 90ba78c:	e0bfff17 	ldw	r2,-4(fp)
}
 90ba790:	e037883a 	mov	sp,fp
 90ba794:	dfc00117 	ldw	ra,4(sp)
 90ba798:	df000017 	ldw	fp,0(sp)
 90ba79c:	dec00204 	addi	sp,sp,8
 90ba7a0:	f800283a 	ret

090ba7a4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 90ba7a4:	defffe04 	addi	sp,sp,-8
 90ba7a8:	df000115 	stw	fp,4(sp)
 90ba7ac:	df000104 	addi	fp,sp,4
 90ba7b0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 90ba7b4:	e0bfff17 	ldw	r2,-4(fp)
 90ba7b8:	108000d0 	cmplti	r2,r2,3
 90ba7bc:	10000d1e 	bne	r2,zero,90ba7f4 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 90ba7c0:	e0bfff17 	ldw	r2,-4(fp)
 90ba7c4:	00c24374 	movhi	r3,2317
 90ba7c8:	18cdc104 	addi	r3,r3,14084
 90ba7cc:	10800324 	muli	r2,r2,12
 90ba7d0:	10c5883a 	add	r2,r2,r3
 90ba7d4:	10800204 	addi	r2,r2,8
 90ba7d8:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 90ba7dc:	e0bfff17 	ldw	r2,-4(fp)
 90ba7e0:	00c24374 	movhi	r3,2317
 90ba7e4:	18cdc104 	addi	r3,r3,14084
 90ba7e8:	10800324 	muli	r2,r2,12
 90ba7ec:	10c5883a 	add	r2,r2,r3
 90ba7f0:	10000015 	stw	zero,0(r2)
  }
}
 90ba7f4:	e037883a 	mov	sp,fp
 90ba7f8:	df000017 	ldw	fp,0(sp)
 90ba7fc:	dec00104 	addi	sp,sp,4
 90ba800:	f800283a 	ret

090ba804 <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 90ba804:	defffd04 	addi	sp,sp,-12
 90ba808:	df000215 	stw	fp,8(sp)
 90ba80c:	df000204 	addi	fp,sp,8
 90ba810:	e13ffe15 	stw	r4,-8(fp)
 90ba814:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 90ba818:	e0bffe17 	ldw	r2,-8(fp)
 90ba81c:	1007883a 	mov	r3,r2
 90ba820:	00a00034 	movhi	r2,32768
 90ba824:	10bfffc4 	addi	r2,r2,-1
 90ba828:	1884703a 	and	r2,r3,r2
}
 90ba82c:	e037883a 	mov	sp,fp
 90ba830:	df000017 	ldw	fp,0(sp)
 90ba834:	dec00104 	addi	sp,sp,4
 90ba838:	f800283a 	ret

090ba83c <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 90ba83c:	defffc04 	addi	sp,sp,-16
 90ba840:	dfc00315 	stw	ra,12(sp)
 90ba844:	df000215 	stw	fp,8(sp)
 90ba848:	df000204 	addi	fp,sp,8
 90ba84c:	e13ffe15 	stw	r4,-8(fp)
 90ba850:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 90ba854:	e13ffe17 	ldw	r4,-8(fp)
 90ba858:	e17fff17 	ldw	r5,-4(fp)
 90ba85c:	90b9c3c0 	call	90b9c3c <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 90ba860:	e0bffe17 	ldw	r2,-8(fp)
 90ba864:	10a00034 	orhi	r2,r2,32768
}
 90ba868:	e037883a 	mov	sp,fp
 90ba86c:	dfc00117 	ldw	ra,4(sp)
 90ba870:	df000017 	ldw	fp,0(sp)
 90ba874:	dec00204 	addi	sp,sp,8
 90ba878:	f800283a 	ret

090ba87c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 90ba87c:	defffa04 	addi	sp,sp,-24
 90ba880:	df000515 	stw	fp,20(sp)
 90ba884:	df000504 	addi	fp,sp,20
 90ba888:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 90ba88c:	0005303a 	rdctl	r2,status
 90ba890:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 90ba894:	e0fffd17 	ldw	r3,-12(fp)
 90ba898:	00bfff84 	movi	r2,-2
 90ba89c:	1884703a 	and	r2,r3,r2
 90ba8a0:	1001703a 	wrctl	status,r2
  
  return context;
 90ba8a4:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 90ba8a8:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 90ba8ac:	e0bfff17 	ldw	r2,-4(fp)
 90ba8b0:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 90ba8b4:	e0bffc17 	ldw	r2,-16(fp)
 90ba8b8:	10c00017 	ldw	r3,0(r2)
 90ba8bc:	e0bffc17 	ldw	r2,-16(fp)
 90ba8c0:	10800117 	ldw	r2,4(r2)
 90ba8c4:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 90ba8c8:	e0bffc17 	ldw	r2,-16(fp)
 90ba8cc:	10c00117 	ldw	r3,4(r2)
 90ba8d0:	e0bffc17 	ldw	r2,-16(fp)
 90ba8d4:	10800017 	ldw	r2,0(r2)
 90ba8d8:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 90ba8dc:	e0fffc17 	ldw	r3,-16(fp)
 90ba8e0:	e0bffc17 	ldw	r2,-16(fp)
 90ba8e4:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 90ba8e8:	e0fffc17 	ldw	r3,-16(fp)
 90ba8ec:	e0bffc17 	ldw	r2,-16(fp)
 90ba8f0:	18800015 	stw	r2,0(r3)
 90ba8f4:	e0bffe17 	ldw	r2,-8(fp)
 90ba8f8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 90ba8fc:	e0bffb17 	ldw	r2,-20(fp)
 90ba900:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 90ba904:	e037883a 	mov	sp,fp
 90ba908:	df000017 	ldw	fp,0(sp)
 90ba90c:	dec00104 	addi	sp,sp,4
 90ba910:	f800283a 	ret

090ba914 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 90ba914:	defffb04 	addi	sp,sp,-20
 90ba918:	dfc00415 	stw	ra,16(sp)
 90ba91c:	df000315 	stw	fp,12(sp)
 90ba920:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 90ba924:	d0a04917 	ldw	r2,-32476(gp)
 90ba928:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 90ba92c:	d0a0ba17 	ldw	r2,-32024(gp)
 90ba930:	10800044 	addi	r2,r2,1
 90ba934:	d0a0ba15 	stw	r2,-32024(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 90ba938:	00003106 	br	90baa00 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 90ba93c:	e0bffe17 	ldw	r2,-8(fp)
 90ba940:	10800017 	ldw	r2,0(r2)
 90ba944:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 90ba948:	e0bffe17 	ldw	r2,-8(fp)
 90ba94c:	10800403 	ldbu	r2,16(r2)
 90ba950:	10803fcc 	andi	r2,r2,255
 90ba954:	1005003a 	cmpeq	r2,r2,zero
 90ba958:	1000051e 	bne	r2,zero,90ba970 <alt_tick+0x5c>
 90ba95c:	d0a0ba17 	ldw	r2,-32024(gp)
 90ba960:	1004c03a 	cmpne	r2,r2,zero
 90ba964:	1000021e 	bne	r2,zero,90ba970 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 90ba968:	e0bffe17 	ldw	r2,-8(fp)
 90ba96c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 90ba970:	e0bffe17 	ldw	r2,-8(fp)
 90ba974:	10c00217 	ldw	r3,8(r2)
 90ba978:	d0a0ba17 	ldw	r2,-32024(gp)
 90ba97c:	10c01e36 	bltu	r2,r3,90ba9f8 <alt_tick+0xe4>
 90ba980:	e0bffe17 	ldw	r2,-8(fp)
 90ba984:	10800403 	ldbu	r2,16(r2)
 90ba988:	10803fcc 	andi	r2,r2,255
 90ba98c:	1004c03a 	cmpne	r2,r2,zero
 90ba990:	1000191e 	bne	r2,zero,90ba9f8 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 90ba994:	e0bffe17 	ldw	r2,-8(fp)
 90ba998:	10c00317 	ldw	r3,12(r2)
 90ba99c:	e0bffe17 	ldw	r2,-8(fp)
 90ba9a0:	11000517 	ldw	r4,20(r2)
 90ba9a4:	183ee83a 	callr	r3
 90ba9a8:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 90ba9ac:	e0bffd17 	ldw	r2,-12(fp)
 90ba9b0:	1004c03a 	cmpne	r2,r2,zero
 90ba9b4:	1000031e 	bne	r2,zero,90ba9c4 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 90ba9b8:	e13ffe17 	ldw	r4,-8(fp)
 90ba9bc:	90ba87c0 	call	90ba87c <alt_alarm_stop>
 90ba9c0:	00000d06 	br	90ba9f8 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 90ba9c4:	e0bffe17 	ldw	r2,-8(fp)
 90ba9c8:	10c00217 	ldw	r3,8(r2)
 90ba9cc:	e0bffd17 	ldw	r2,-12(fp)
 90ba9d0:	1887883a 	add	r3,r3,r2
 90ba9d4:	e0bffe17 	ldw	r2,-8(fp)
 90ba9d8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 90ba9dc:	e0bffe17 	ldw	r2,-8(fp)
 90ba9e0:	10c00217 	ldw	r3,8(r2)
 90ba9e4:	d0a0ba17 	ldw	r2,-32024(gp)
 90ba9e8:	1880032e 	bgeu	r3,r2,90ba9f8 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 90ba9ec:	e0fffe17 	ldw	r3,-8(fp)
 90ba9f0:	00800044 	movi	r2,1
 90ba9f4:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 90ba9f8:	e0bfff17 	ldw	r2,-4(fp)
 90ba9fc:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 90baa00:	d0e04904 	addi	r3,gp,-32476
 90baa04:	e0bffe17 	ldw	r2,-8(fp)
 90baa08:	10ffcc1e 	bne	r2,r3,90ba93c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 90baa0c:	908ee280 	call	908ee28 <OSTimeTick>
}
 90baa10:	e037883a 	mov	sp,fp
 90baa14:	dfc00117 	ldw	ra,4(sp)
 90baa18:	df000017 	ldw	fp,0(sp)
 90baa1c:	dec00204 	addi	sp,sp,8
 90baa20:	f800283a 	ret

090baa24 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 90baa24:	defffb04 	addi	sp,sp,-20
 90baa28:	dfc00415 	stw	ra,16(sp)
 90baa2c:	df000315 	stw	fp,12(sp)
 90baa30:	df000304 	addi	fp,sp,12
 90baa34:	e13ffe15 	stw	r4,-8(fp)
  void* ptr;

  ptr = malloc (size);
 90baa38:	e13ffe17 	ldw	r4,-8(fp)
 90baa3c:	90cb4400 	call	90cb440 <malloc>
 90baa40:	e0bffd15 	stw	r2,-12(fp)

  alt_dcache_flush (ptr, size);
 90baa44:	e13ffd17 	ldw	r4,-12(fp)
 90baa48:	e17ffe17 	ldw	r5,-8(fp)
 90baa4c:	90b9c3c0 	call	90b9c3c <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 90baa50:	e0bffd17 	ldw	r2,-12(fp)
 90baa54:	1005003a 	cmpeq	r2,r2,zero
 90baa58:	1000041e 	bne	r2,zero,90baa6c <alt_uncached_malloc+0x48>
 90baa5c:	e0bffd17 	ldw	r2,-12(fp)
 90baa60:	10a00034 	orhi	r2,r2,32768
 90baa64:	e0bfff15 	stw	r2,-4(fp)
 90baa68:	00000106 	br	90baa70 <alt_uncached_malloc+0x4c>
 90baa6c:	e03fff15 	stw	zero,-4(fp)
 90baa70:	e0bfff17 	ldw	r2,-4(fp)
}
 90baa74:	e037883a 	mov	sp,fp
 90baa78:	dfc00117 	ldw	ra,4(sp)
 90baa7c:	df000017 	ldw	fp,0(sp)
 90baa80:	dec00204 	addi	sp,sp,8
 90baa84:	f800283a 	ret

090baa88 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 90baa88:	defff304 	addi	sp,sp,-52
 90baa8c:	dfc00c15 	stw	ra,48(sp)
 90baa90:	df000b15 	stw	fp,44(sp)
 90baa94:	df000b04 	addi	fp,sp,44
 90baa98:	e13ff715 	stw	r4,-36(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 90baa9c:	00824374 	movhi	r2,2317
 90baaa0:	108ef144 	addi	r2,r2,15301
 90baaa4:	10800003 	ldbu	r2,0(r2)
 90baaa8:	10803fcc 	andi	r2,r2,255
 90baaac:	1004c03a 	cmpne	r2,r2,zero
 90baab0:	1000041e 	bne	r2,zero,90baac4 <usleep+0x3c>
  {
    return alt_busy_sleep (us);
 90baab4:	e13ff717 	ldw	r4,-36(fp)
 90baab8:	90c9bc00 	call	90c9bc0 <alt_busy_sleep>
 90baabc:	e0bff915 	stw	r2,-28(fp)
 90baac0:	00004406 	br	90babd4 <usleep+0x14c>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 90baac4:	00824374 	movhi	r2,2317
 90baac8:	108f3e04 	addi	r2,r2,15608
 90baacc:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 90baad0:	e0bff515 	stw	r2,-44(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 90baad4:	e0fff717 	ldw	r3,-36(fp)
 90baad8:	0090c734 	movhi	r2,17180
 90baadc:	10b7a0c4 	addi	r2,r2,-8573
 90baae0:	1889383a 	mul	r4,r3,r2
 90baae4:	e13ffa15 	stw	r4,-24(fp)
 90baae8:	1886383a 	mulxuu	r3,r3,r2
 90baaec:	e0fffb15 	stw	r3,-20(fp)
 90baaf0:	e17ffb17 	ldw	r5,-20(fp)
 90baaf4:	2806d4ba 	srli	r3,r5,18
 90baaf8:	e0bff517 	ldw	r2,-44(fp)
 90baafc:	1889383a 	mul	r4,r3,r2
 90bab00:	e0fff717 	ldw	r3,-36(fp)
 90bab04:	0090c734 	movhi	r2,17180
 90bab08:	10b7a0c4 	addi	r2,r2,-8573
 90bab0c:	188b383a 	mul	r5,r3,r2
 90bab10:	e17ffc15 	stw	r5,-16(fp)
 90bab14:	1884383a 	mulxuu	r2,r3,r2
 90bab18:	e0bffd15 	stw	r2,-12(fp)
 90bab1c:	e0bffd17 	ldw	r2,-12(fp)
 90bab20:	1004d4ba 	srli	r2,r2,18
 90bab24:	e0bff815 	stw	r2,-32(fp)
 90bab28:	008003f4 	movhi	r2,15
 90bab2c:	10909004 	addi	r2,r2,16960
 90bab30:	e17ff817 	ldw	r5,-32(fp)
 90bab34:	2885383a 	mul	r2,r5,r2
 90bab38:	1887c83a 	sub	r3,r3,r2
 90bab3c:	e0fff815 	stw	r3,-32(fp)
 90bab40:	e0bff517 	ldw	r2,-44(fp)
 90bab44:	e17ff817 	ldw	r5,-32(fp)
 90bab48:	2887383a 	mul	r3,r5,r2
 90bab4c:	0090c734 	movhi	r2,17180
 90bab50:	10b7a0c4 	addi	r2,r2,-8573
 90bab54:	188b383a 	mul	r5,r3,r2
 90bab58:	e17ffe15 	stw	r5,-8(fp)
 90bab5c:	1886383a 	mulxuu	r3,r3,r2
 90bab60:	e0ffff15 	stw	r3,-4(fp)
 90bab64:	e0ffff17 	ldw	r3,-4(fp)
 90bab68:	1804d4ba 	srli	r2,r3,18
 90bab6c:	2085883a 	add	r2,r4,r2
 90bab70:	e0bff615 	stw	r2,-40(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 90bab74:	00000706 	br	90bab94 <usleep+0x10c>
  {
    OSTimeDly(0xffff);
 90bab78:	013fffd4 	movui	r4,65535
 90bab7c:	9095df00 	call	9095df0 <OSTimeDly>
    ticks -= 0xffff;
 90bab80:	e0bff617 	ldw	r2,-40(fp)
 90bab84:	00fffff4 	movhi	r3,65535
 90bab88:	18c00044 	addi	r3,r3,1
 90bab8c:	10c5883a 	add	r2,r2,r3
 90bab90:	e0bff615 	stw	r2,-40(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 90bab94:	e0fff617 	ldw	r3,-40(fp)
 90bab98:	00bfffd4 	movui	r2,65535
 90bab9c:	10fff636 	bltu	r2,r3,90bab78 <usleep+0xf0>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 90baba0:	e0bff617 	ldw	r2,-40(fp)
 90baba4:	113fffcc 	andi	r4,r2,65535
 90baba8:	9095df00 	call	9095df0 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 90babac:	00c003f4 	movhi	r3,15
 90babb0:	18d09004 	addi	r3,r3,16960
 90babb4:	e0bff517 	ldw	r2,-44(fp)
 90babb8:	1887203a 	divu	r3,r3,r2
 90babbc:	e13ff717 	ldw	r4,-36(fp)
 90babc0:	20c5203a 	divu	r2,r4,r3
 90babc4:	10c5383a 	mul	r2,r2,r3
 90babc8:	2089c83a 	sub	r4,r4,r2
 90babcc:	90c9bc00 	call	90c9bc0 <alt_busy_sleep>

  return 0;  
 90babd0:	e03ff915 	stw	zero,-28(fp)
 90babd4:	e0bff917 	ldw	r2,-28(fp)
}
 90babd8:	e037883a 	mov	sp,fp
 90babdc:	dfc00117 	ldw	ra,4(sp)
 90babe0:	df000017 	ldw	fp,0(sp)
 90babe4:	dec00204 	addi	sp,sp,8
 90babe8:	f800283a 	ret

090babec <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 90babec:	defff704 	addi	sp,sp,-36
 90babf0:	dfc00815 	stw	ra,32(sp)
 90babf4:	df000715 	stw	fp,28(sp)
 90babf8:	df000704 	addi	fp,sp,28
 90babfc:	e13ffb15 	stw	r4,-20(fp)
 90bac00:	e17ffc15 	stw	r5,-16(fp)
 90bac04:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90bac08:	e0bffb17 	ldw	r2,-20(fp)
 90bac0c:	1004803a 	cmplt	r2,r2,zero
 90bac10:	1000081e 	bne	r2,zero,90bac34 <alt_write+0x48>
 90bac14:	e0bffb17 	ldw	r2,-20(fp)
 90bac18:	10800324 	muli	r2,r2,12
 90bac1c:	1007883a 	mov	r3,r2
 90bac20:	00824374 	movhi	r2,2317
 90bac24:	108dc104 	addi	r2,r2,14084
 90bac28:	1887883a 	add	r3,r3,r2
 90bac2c:	e0ffff15 	stw	r3,-4(fp)
 90bac30:	00000106 	br	90bac38 <alt_write+0x4c>
 90bac34:	e03fff15 	stw	zero,-4(fp)
 90bac38:	e0bfff17 	ldw	r2,-4(fp)
 90bac3c:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 90bac40:	e0bffa17 	ldw	r2,-24(fp)
 90bac44:	1005003a 	cmpeq	r2,r2,zero
 90bac48:	1000241e 	bne	r2,zero,90bacdc <alt_write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 90bac4c:	e0bffa17 	ldw	r2,-24(fp)
 90bac50:	10800217 	ldw	r2,8(r2)
 90bac54:	108000cc 	andi	r2,r2,3
 90bac58:	1005003a 	cmpeq	r2,r2,zero
 90bac5c:	10001a1e 	bne	r2,zero,90bacc8 <alt_write+0xdc>
 90bac60:	e0bffa17 	ldw	r2,-24(fp)
 90bac64:	10800017 	ldw	r2,0(r2)
 90bac68:	10800617 	ldw	r2,24(r2)
 90bac6c:	1005003a 	cmpeq	r2,r2,zero
 90bac70:	1000151e 	bne	r2,zero,90bacc8 <alt_write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 90bac74:	e0bffa17 	ldw	r2,-24(fp)
 90bac78:	10800017 	ldw	r2,0(r2)
 90bac7c:	10800617 	ldw	r2,24(r2)
 90bac80:	e17ffc17 	ldw	r5,-16(fp)
 90bac84:	e1bffd17 	ldw	r6,-12(fp)
 90bac88:	e13ffa17 	ldw	r4,-24(fp)
 90bac8c:	103ee83a 	callr	r2
 90bac90:	e0bff915 	stw	r2,-28(fp)
 90bac94:	e0bff917 	ldw	r2,-28(fp)
 90bac98:	1004403a 	cmpge	r2,r2,zero
 90bac9c:	1000071e 	bne	r2,zero,90bacbc <alt_write+0xd0>
      {
        ALT_ERRNO = -rval;
 90baca0:	90bad0c0 	call	90bad0c <alt_get_errno>
 90baca4:	e0fff917 	ldw	r3,-28(fp)
 90baca8:	00c7c83a 	sub	r3,zero,r3
 90bacac:	10c00015 	stw	r3,0(r2)
        return -1;
 90bacb0:	00bfffc4 	movi	r2,-1
 90bacb4:	e0bffe15 	stw	r2,-8(fp)
 90bacb8:	00000e06 	br	90bacf4 <alt_write+0x108>
      }
      return rval;
 90bacbc:	e0bff917 	ldw	r2,-28(fp)
 90bacc0:	e0bffe15 	stw	r2,-8(fp)
 90bacc4:	00000b06 	br	90bacf4 <alt_write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 90bacc8:	90bad0c0 	call	90bad0c <alt_get_errno>
 90baccc:	1007883a 	mov	r3,r2
 90bacd0:	00800344 	movi	r2,13
 90bacd4:	18800015 	stw	r2,0(r3)
 90bacd8:	00000406 	br	90bacec <alt_write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 90bacdc:	90bad0c0 	call	90bad0c <alt_get_errno>
 90bace0:	1007883a 	mov	r3,r2
 90bace4:	00801444 	movi	r2,81
 90bace8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 90bacec:	00bfffc4 	movi	r2,-1
 90bacf0:	e0bffe15 	stw	r2,-8(fp)
 90bacf4:	e0bffe17 	ldw	r2,-8(fp)
}
 90bacf8:	e037883a 	mov	sp,fp
 90bacfc:	dfc00117 	ldw	ra,4(sp)
 90bad00:	df000017 	ldw	fp,0(sp)
 90bad04:	dec00204 	addi	sp,sp,8
 90bad08:	f800283a 	ret

090bad0c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90bad0c:	defffd04 	addi	sp,sp,-12
 90bad10:	dfc00215 	stw	ra,8(sp)
 90bad14:	df000115 	stw	fp,4(sp)
 90bad18:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90bad1c:	00824374 	movhi	r2,2317
 90bad20:	108eca04 	addi	r2,r2,15144
 90bad24:	10800017 	ldw	r2,0(r2)
 90bad28:	1005003a 	cmpeq	r2,r2,zero
 90bad2c:	1000061e 	bne	r2,zero,90bad48 <alt_get_errno+0x3c>
 90bad30:	00824374 	movhi	r2,2317
 90bad34:	108eca04 	addi	r2,r2,15144
 90bad38:	10800017 	ldw	r2,0(r2)
 90bad3c:	103ee83a 	callr	r2
 90bad40:	e0bfff15 	stw	r2,-4(fp)
 90bad44:	00000306 	br	90bad54 <alt_get_errno+0x48>
 90bad48:	00824374 	movhi	r2,2317
 90bad4c:	108ee904 	addi	r2,r2,15268
 90bad50:	e0bfff15 	stw	r2,-4(fp)
 90bad54:	e0bfff17 	ldw	r2,-4(fp)
}
 90bad58:	e037883a 	mov	sp,fp
 90bad5c:	dfc00117 	ldw	ra,4(sp)
 90bad60:	df000017 	ldw	fp,0(sp)
 90bad64:	dec00204 	addi	sp,sp,8
 90bad68:	f800283a 	ret

090bad6c <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 90bad6c:	deffff04 	addi	sp,sp,-4
 90bad70:	df000015 	stw	fp,0(sp)
 90bad74:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 90bad78:	000170fa 	wrctl	ienable,zero
}
 90bad7c:	e037883a 	mov	sp,fp
 90bad80:	df000017 	ldw	fp,0(sp)
 90bad84:	dec00104 	addi	sp,sp,4
 90bad88:	f800283a 	ret

090bad8c <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 90bad8c:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 90bad90:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 90bad94:	d1207b17 	ldw	r4,-32276(gp)

      stw ra,  0(sp)
 90bad98:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 90bad9c:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 90bada0:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 90bada4:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 90bada8:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 90badac:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 90badb0:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 90badb4:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 90badb8:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 90badbc:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 90badc0:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 90badc4:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 90badc8:	90bb1ac0 	call	90bb1ac <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 90badcc:	d1207617 	ldw	r4,-32296(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 90badd0:	d1606e07 	ldb	r5,-32328(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 90badd4:	d1207b15 	stw	r4,-32276(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 90badd8:	d1606e45 	stb	r5,-32327(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 90baddc:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 90bade0:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 90bade4:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 90bade8:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 90badec:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 90badf0:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 90badf4:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 90badf8:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 90badfc:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 90bae00:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 90bae04:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 90bae08:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 90bae0c:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 90bae10:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 90bae14:	f800283a 	ret

090bae18 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 90bae18:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 90bae1c:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 90bae20:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 90bae24:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 90bae28:	90bb1ac0 	call	90bb1ac <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 90bae2c:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 90bae30:	d4a06c45 	stb	r18,-32335(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 90bae34:	003fe506 	br	90badcc <OSCtxSw+0x40>

090bae38 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 90bae38:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 90bae3c:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 90bae40:	10800054 	ori	r2,r2,1
      wrctl status, r2
 90bae44:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 90bae48:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 90bae4c:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 90bae50:	dec00204 	addi	sp,sp,8

      callr r2
 90bae54:	103ee83a 	callr	r2

      nop
 90bae58:	0001883a 	nop

090bae5c <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 90bae5c:	defff704 	addi	sp,sp,-36
 90bae60:	dfc00815 	stw	ra,32(sp)
 90bae64:	df000715 	stw	fp,28(sp)
 90bae68:	df000704 	addi	fp,sp,28
 90bae6c:	e13ffc15 	stw	r4,-16(fp)
 90bae70:	e17ffd15 	stw	r5,-12(fp)
 90bae74:	e1bffe15 	stw	r6,-8(fp)
 90bae78:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 90bae7c:	e0bffe17 	ldw	r2,-8(fp)
 90bae80:	1007883a 	mov	r3,r2
 90bae84:	00bfff04 	movi	r2,-4
 90bae88:	1884703a 	and	r2,r3,r2
 90bae8c:	10bf0004 	addi	r2,r2,-1024
 90bae90:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 90bae94:	e0bff917 	ldw	r2,-28(fp)
 90bae98:	10000015 	stw	zero,0(r2)
 90bae9c:	e0bff917 	ldw	r2,-28(fp)
 90baea0:	10c0bb04 	addi	r3,r2,748
 90baea4:	e0bff917 	ldw	r2,-28(fp)
 90baea8:	10c00115 	stw	r3,4(r2)
 90baeac:	e0bff917 	ldw	r2,-28(fp)
 90baeb0:	1080bb04 	addi	r2,r2,748
 90baeb4:	10c01704 	addi	r3,r2,92
 90baeb8:	e0bff917 	ldw	r2,-28(fp)
 90baebc:	10c00215 	stw	r3,8(r2)
 90baec0:	e0bff917 	ldw	r2,-28(fp)
 90baec4:	1080bb04 	addi	r2,r2,748
 90baec8:	10c02e04 	addi	r3,r2,184
 90baecc:	e0bff917 	ldw	r2,-28(fp)
 90baed0:	10c00315 	stw	r3,12(r2)
 90baed4:	e0bff917 	ldw	r2,-28(fp)
 90baed8:	10000415 	stw	zero,16(r2)
 90baedc:	e0bff917 	ldw	r2,-28(fp)
 90baee0:	10800504 	addi	r2,r2,20
 90baee4:	1009883a 	mov	r4,r2
 90baee8:	01800644 	movi	r6,25
 90baeec:	000b883a 	mov	r5,zero
 90baef0:	90832780 	call	9083278 <memset>
 90baef4:	e0bff917 	ldw	r2,-28(fp)
 90baef8:	10000c15 	stw	zero,48(r2)
 90baefc:	e0fff917 	ldw	r3,-28(fp)
 90baf00:	00824374 	movhi	r2,2317
 90baf04:	10829304 	addi	r2,r2,2636
 90baf08:	18800d15 	stw	r2,52(r3)
 90baf0c:	e0bff917 	ldw	r2,-28(fp)
 90baf10:	10000e15 	stw	zero,56(r2)
 90baf14:	e0bff917 	ldw	r2,-28(fp)
 90baf18:	10000f15 	stw	zero,60(r2)
 90baf1c:	e0bff917 	ldw	r2,-28(fp)
 90baf20:	10001015 	stw	zero,64(r2)
 90baf24:	e0bff917 	ldw	r2,-28(fp)
 90baf28:	10001115 	stw	zero,68(r2)
 90baf2c:	e0bff917 	ldw	r2,-28(fp)
 90baf30:	10001215 	stw	zero,72(r2)
 90baf34:	e0bff917 	ldw	r2,-28(fp)
 90baf38:	10001315 	stw	zero,76(r2)
 90baf3c:	e0bff917 	ldw	r2,-28(fp)
 90baf40:	10001415 	stw	zero,80(r2)
 90baf44:	e0bff917 	ldw	r2,-28(fp)
 90baf48:	10001515 	stw	zero,84(r2)
 90baf4c:	e0bff917 	ldw	r2,-28(fp)
 90baf50:	10001615 	stw	zero,88(r2)
 90baf54:	e0bff917 	ldw	r2,-28(fp)
 90baf58:	10001715 	stw	zero,92(r2)
 90baf5c:	e0bff917 	ldw	r2,-28(fp)
 90baf60:	10001805 	stb	zero,96(r2)
 90baf64:	e0bff917 	ldw	r2,-28(fp)
 90baf68:	10801f04 	addi	r2,r2,124
 90baf6c:	10000015 	stw	zero,0(r2)
 90baf70:	10000115 	stw	zero,4(r2)
 90baf74:	10000215 	stw	zero,8(r2)
 90baf78:	10000315 	stw	zero,12(r2)
 90baf7c:	10000415 	stw	zero,16(r2)
 90baf80:	10000515 	stw	zero,20(r2)
 90baf84:	10000615 	stw	zero,24(r2)
 90baf88:	10000715 	stw	zero,28(r2)
 90baf8c:	10000815 	stw	zero,32(r2)
 90baf90:	e0bff917 	ldw	r2,-28(fp)
 90baf94:	10002815 	stw	zero,160(r2)
 90baf98:	e0fff917 	ldw	r3,-28(fp)
 90baf9c:	00800044 	movi	r2,1
 90bafa0:	18802915 	stw	r2,164(r3)
 90bafa4:	18002a15 	stw	zero,168(r3)
 90bafa8:	e0fff917 	ldw	r3,-28(fp)
 90bafac:	008cc384 	movi	r2,13070
 90bafb0:	18802b0d 	sth	r2,172(r3)
 90bafb4:	e0fff917 	ldw	r3,-28(fp)
 90bafb8:	00aaf344 	movi	r2,-21555
 90bafbc:	18802b8d 	sth	r2,174(r3)
 90bafc0:	e0fff917 	ldw	r3,-28(fp)
 90bafc4:	00848d04 	movi	r2,4660
 90bafc8:	18802c0d 	sth	r2,176(r3)
 90bafcc:	e0fff917 	ldw	r3,-28(fp)
 90bafd0:	00b99b44 	movi	r2,-6547
 90bafd4:	18802c8d 	sth	r2,178(r3)
 90bafd8:	e0fff917 	ldw	r3,-28(fp)
 90bafdc:	00b7bb04 	movi	r2,-8468
 90bafe0:	18802d0d 	sth	r2,180(r3)
 90bafe4:	e0fff917 	ldw	r3,-28(fp)
 90bafe8:	00800144 	movi	r2,5
 90bafec:	18802d8d 	sth	r2,182(r3)
 90baff0:	e0fff917 	ldw	r3,-28(fp)
 90baff4:	008002c4 	movi	r2,11
 90baff8:	18802e0d 	sth	r2,184(r3)
 90baffc:	e0bff917 	ldw	r2,-28(fp)
 90bb000:	10002f15 	stw	zero,188(r2)
 90bb004:	e0bff917 	ldw	r2,-28(fp)
 90bb008:	10003015 	stw	zero,192(r2)
 90bb00c:	e0bff917 	ldw	r2,-28(fp)
 90bb010:	10003115 	stw	zero,196(r2)
 90bb014:	e0bff917 	ldw	r2,-28(fp)
 90bb018:	10003215 	stw	zero,200(r2)
 90bb01c:	e0bff917 	ldw	r2,-28(fp)
 90bb020:	10003315 	stw	zero,204(r2)
 90bb024:	e0bff917 	ldw	r2,-28(fp)
 90bb028:	10003415 	stw	zero,208(r2)
 90bb02c:	e0bff917 	ldw	r2,-28(fp)
 90bb030:	10003e15 	stw	zero,248(r2)
 90bb034:	e0bff917 	ldw	r2,-28(fp)
 90bb038:	10003f15 	stw	zero,252(r2)
 90bb03c:	e0bff917 	ldw	r2,-28(fp)
 90bb040:	10004015 	stw	zero,256(r2)
 90bb044:	e0bff917 	ldw	r2,-28(fp)
 90bb048:	10004115 	stw	zero,260(r2)
 90bb04c:	e0bff917 	ldw	r2,-28(fp)
 90bb050:	10004215 	stw	zero,264(r2)
 90bb054:	e0bff917 	ldw	r2,-28(fp)
 90bb058:	10004315 	stw	zero,268(r2)
 90bb05c:	e0bff917 	ldw	r2,-28(fp)
 90bb060:	10004415 	stw	zero,272(r2)
 90bb064:	e0bff917 	ldw	r2,-28(fp)
 90bb068:	10004515 	stw	zero,276(r2)
 90bb06c:	e0bff917 	ldw	r2,-28(fp)
 90bb070:	10004615 	stw	zero,280(r2)
 90bb074:	e0bff917 	ldw	r2,-28(fp)
 90bb078:	10004715 	stw	zero,284(r2)
 90bb07c:	e0bff917 	ldw	r2,-28(fp)
 90bb080:	10003505 	stb	zero,212(r2)
 90bb084:	e0bff917 	ldw	r2,-28(fp)
 90bb088:	10003705 	stb	zero,220(r2)
 90bb08c:	e0bff917 	ldw	r2,-28(fp)
 90bb090:	10003d15 	stw	zero,244(r2)
 90bb094:	e0bff917 	ldw	r2,-28(fp)
 90bb098:	10005215 	stw	zero,328(r2)
 90bb09c:	e0bff917 	ldw	r2,-28(fp)
 90bb0a0:	10005315 	stw	zero,332(r2)
 90bb0a4:	e0bff917 	ldw	r2,-28(fp)
 90bb0a8:	10005415 	stw	zero,336(r2)
 90bb0ac:	e0bff917 	ldw	r2,-28(fp)
 90bb0b0:	10005515 	stw	zero,340(r2)
 90bb0b4:	e0bff917 	ldw	r2,-28(fp)
 90bb0b8:	1000b515 	stw	zero,724(r2)
 90bb0bc:	e0bff917 	ldw	r2,-28(fp)
 90bb0c0:	10007515 	stw	zero,468(r2)
 90bb0c4:	e0bff917 	ldw	r2,-28(fp)
 90bb0c8:	1000b715 	stw	zero,732(r2)
 90bb0cc:	e0bff917 	ldw	r2,-28(fp)
 90bb0d0:	1000b815 	stw	zero,736(r2)
 90bb0d4:	e0bff917 	ldw	r2,-28(fp)
 90bb0d8:	1000b915 	stw	zero,740(r2)
 90bb0dc:	e0bff917 	ldw	r2,-28(fp)
 90bb0e0:	1000ba15 	stw	zero,744(r2)
 90bb0e4:	e0bff917 	ldw	r2,-28(fp)
 90bb0e8:	1080bb04 	addi	r2,r2,748
 90bb0ec:	1009883a 	mov	r4,r2
 90bb0f0:	01804504 	movi	r6,276
 90bb0f4:	000b883a 	mov	r5,zero
 90bb0f8:	90832780 	call	9083278 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 90bb0fc:	e0bff917 	ldw	r2,-28(fp)
 90bb100:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 90bb104:	e0bffb17 	ldw	r2,-20(fp)
 90bb108:	10bff304 	addi	r2,r2,-52
 90bb10c:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 90bb110:	e0bffa17 	ldw	r2,-24(fp)
 90bb114:	10c00c04 	addi	r3,r2,48
 90bb118:	e0bffc17 	ldw	r2,-16(fp)
 90bb11c:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 90bb120:	e0bffa17 	ldw	r2,-24(fp)
 90bb124:	10c00b04 	addi	r3,r2,44
 90bb128:	e0bffd17 	ldw	r2,-12(fp)
 90bb12c:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 90bb130:	e0bffa17 	ldw	r2,-24(fp)
 90bb134:	10c00a04 	addi	r3,r2,40
 90bb138:	e0bff917 	ldw	r2,-28(fp)
 90bb13c:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 90bb140:	00824334 	movhi	r2,2316
 90bb144:	10ab8e04 	addi	r2,r2,-20936
 90bb148:	10c00104 	addi	r3,r2,4
 90bb14c:	e0bffa17 	ldw	r2,-24(fp)
 90bb150:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 90bb154:	e0bffa17 	ldw	r2,-24(fp)
}
 90bb158:	e037883a 	mov	sp,fp
 90bb15c:	dfc00117 	ldw	ra,4(sp)
 90bb160:	df000017 	ldw	fp,0(sp)
 90bb164:	dec00204 	addi	sp,sp,8
 90bb168:	f800283a 	ret

090bb16c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 90bb16c:	defffe04 	addi	sp,sp,-8
 90bb170:	df000115 	stw	fp,4(sp)
 90bb174:	df000104 	addi	fp,sp,4
 90bb178:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 90bb17c:	e037883a 	mov	sp,fp
 90bb180:	df000017 	ldw	fp,0(sp)
 90bb184:	dec00104 	addi	sp,sp,4
 90bb188:	f800283a 	ret

090bb18c <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 90bb18c:	defffe04 	addi	sp,sp,-8
 90bb190:	df000115 	stw	fp,4(sp)
 90bb194:	df000104 	addi	fp,sp,4
 90bb198:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 90bb19c:	e037883a 	mov	sp,fp
 90bb1a0:	df000017 	ldw	fp,0(sp)
 90bb1a4:	dec00104 	addi	sp,sp,4
 90bb1a8:	f800283a 	ret

090bb1ac <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 90bb1ac:	deffff04 	addi	sp,sp,-4
 90bb1b0:	df000015 	stw	fp,0(sp)
 90bb1b4:	d839883a 	mov	fp,sp
}
 90bb1b8:	e037883a 	mov	sp,fp
 90bb1bc:	df000017 	ldw	fp,0(sp)
 90bb1c0:	dec00104 	addi	sp,sp,4
 90bb1c4:	f800283a 	ret

090bb1c8 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 90bb1c8:	deffff04 	addi	sp,sp,-4
 90bb1cc:	df000015 	stw	fp,0(sp)
 90bb1d0:	d839883a 	mov	fp,sp
}
 90bb1d4:	e037883a 	mov	sp,fp
 90bb1d8:	df000017 	ldw	fp,0(sp)
 90bb1dc:	dec00104 	addi	sp,sp,4
 90bb1e0:	f800283a 	ret

090bb1e4 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 90bb1e4:	defffe04 	addi	sp,sp,-8
 90bb1e8:	dfc00115 	stw	ra,4(sp)
 90bb1ec:	df000015 	stw	fp,0(sp)
 90bb1f0:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 90bb1f4:	90aa60c0 	call	90aa60c <cticks_hook>
#endif
}
 90bb1f8:	e037883a 	mov	sp,fp
 90bb1fc:	dfc00117 	ldw	ra,4(sp)
 90bb200:	df000017 	ldw	fp,0(sp)
 90bb204:	dec00204 	addi	sp,sp,8
 90bb208:	f800283a 	ret

090bb20c <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 90bb20c:	deffff04 	addi	sp,sp,-4
 90bb210:	df000015 	stw	fp,0(sp)
 90bb214:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 90bb218:	e037883a 	mov	sp,fp
 90bb21c:	df000017 	ldw	fp,0(sp)
 90bb220:	dec00104 	addi	sp,sp,4
 90bb224:	f800283a 	ret

090bb228 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 90bb228:	deffff04 	addi	sp,sp,-4
 90bb22c:	df000015 	stw	fp,0(sp)
 90bb230:	d839883a 	mov	fp,sp
}
 90bb234:	e037883a 	mov	sp,fp
 90bb238:	df000017 	ldw	fp,0(sp)
 90bb23c:	dec00104 	addi	sp,sp,4
 90bb240:	f800283a 	ret

090bb244 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 90bb244:	deffff04 	addi	sp,sp,-4
 90bb248:	df000015 	stw	fp,0(sp)
 90bb24c:	d839883a 	mov	fp,sp
}
 90bb250:	e037883a 	mov	sp,fp
 90bb254:	df000017 	ldw	fp,0(sp)
 90bb258:	dec00104 	addi	sp,sp,4
 90bb25c:	f800283a 	ret

090bb260 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 90bb260:	defffe04 	addi	sp,sp,-8
 90bb264:	df000115 	stw	fp,4(sp)
 90bb268:	df000104 	addi	fp,sp,4
 90bb26c:	e13fff15 	stw	r4,-4(fp)
}
 90bb270:	e037883a 	mov	sp,fp
 90bb274:	df000017 	ldw	fp,0(sp)
 90bb278:	dec00104 	addi	sp,sp,4
 90bb27c:	f800283a 	ret

090bb280 <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 90bb280:	defff704 	addi	sp,sp,-36
 90bb284:	dfc00815 	stw	ra,32(sp)
 90bb288:	df000715 	stw	fp,28(sp)
 90bb28c:	df000704 	addi	fp,sp,28
 90bb290:	e13ffc15 	stw	r4,-16(fp)
 90bb294:	e17ffd15 	stw	r5,-12(fp)
 90bb298:	e1bffe15 	stw	r6,-8(fp)
 90bb29c:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 90bb2a0:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90bb2a4:	e0bffc17 	ldw	r2,-16(fp)
 90bb2a8:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 90bb2ac:	e1bfff17 	ldw	r6,-4(fp)
 90bb2b0:	00824334 	movhi	r2,2316
 90bb2b4:	10ad8904 	addi	r2,r2,-18908
 90bb2b8:	d8800015 	stw	r2,0(sp)
 90bb2bc:	e13ffa17 	ldw	r4,-24(fp)
 90bb2c0:	e17ffe17 	ldw	r5,-8(fp)
 90bb2c4:	e1c00217 	ldw	r7,8(fp)
 90bb2c8:	9096d340 	call	9096d34 <alt_flash_program_block>
 90bb2cc:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 90bb2d0:	e0bffb17 	ldw	r2,-20(fp)
}
 90bb2d4:	e037883a 	mov	sp,fp
 90bb2d8:	dfc00117 	ldw	ra,4(sp)
 90bb2dc:	df000017 	ldw	fp,0(sp)
 90bb2e0:	dec00204 	addi	sp,sp,8
 90bb2e4:	f800283a 	ret

090bb2e8 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 90bb2e8:	defff804 	addi	sp,sp,-32
 90bb2ec:	dfc00715 	stw	ra,28(sp)
 90bb2f0:	df000615 	stw	fp,24(sp)
 90bb2f4:	df000604 	addi	fp,sp,24
 90bb2f8:	e13ffe15 	stw	r4,-8(fp)
 90bb2fc:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 90bb300:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90bb304:	e0bffe17 	ldw	r2,-8(fp)
 90bb308:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90bb30c:	e0bffa17 	ldw	r2,-24(fp)
 90bb310:	10c03317 	ldw	r3,204(r2)
 90bb314:	e0bffa17 	ldw	r2,-24(fp)
 90bb318:	11000a17 	ldw	r4,40(r2)
 90bb31c:	01415544 	movi	r5,1365
 90bb320:	01802a84 	movi	r6,170
 90bb324:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90bb328:	e0bffa17 	ldw	r2,-24(fp)
 90bb32c:	10c03317 	ldw	r3,204(r2)
 90bb330:	e0bffa17 	ldw	r2,-24(fp)
 90bb334:	11000a17 	ldw	r4,40(r2)
 90bb338:	0140aa84 	movi	r5,682
 90bb33c:	01801544 	movi	r6,85
 90bb340:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 90bb344:	e0bffa17 	ldw	r2,-24(fp)
 90bb348:	10c03317 	ldw	r3,204(r2)
 90bb34c:	e0bffa17 	ldw	r2,-24(fp)
 90bb350:	11000a17 	ldw	r4,40(r2)
 90bb354:	01415544 	movi	r5,1365
 90bb358:	01802004 	movi	r6,128
 90bb35c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90bb360:	e0bffa17 	ldw	r2,-24(fp)
 90bb364:	10c03317 	ldw	r3,204(r2)
 90bb368:	e0bffa17 	ldw	r2,-24(fp)
 90bb36c:	11000a17 	ldw	r4,40(r2)
 90bb370:	01415544 	movi	r5,1365
 90bb374:	01802a84 	movi	r6,170
 90bb378:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90bb37c:	e0bffa17 	ldw	r2,-24(fp)
 90bb380:	10c03317 	ldw	r3,204(r2)
 90bb384:	e0bffa17 	ldw	r2,-24(fp)
 90bb388:	11000a17 	ldw	r4,40(r2)
 90bb38c:	0140aa84 	movi	r5,682
 90bb390:	01801544 	movi	r6,85
 90bb394:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 90bb398:	e0bffa17 	ldw	r2,-24(fp)
 90bb39c:	11803517 	ldw	r6,212(r2)
 90bb3a0:	e0bffa17 	ldw	r2,-24(fp)
 90bb3a4:	10800a17 	ldw	r2,40(r2)
 90bb3a8:	1007883a 	mov	r3,r2
 90bb3ac:	e0bfff17 	ldw	r2,-4(fp)
 90bb3b0:	1889883a 	add	r4,r3,r2
 90bb3b4:	01400c04 	movi	r5,48
 90bb3b8:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 90bb3bc:	0109c404 	movi	r4,10000
 90bb3c0:	90baa880 	call	90baa88 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 90bb3c4:	00800c84 	movi	r2,50
 90bb3c8:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90bb3cc:	e0bffa17 	ldw	r2,-24(fp)
 90bb3d0:	10800a17 	ldw	r2,40(r2)
 90bb3d4:	1007883a 	mov	r3,r2
 90bb3d8:	e0bfff17 	ldw	r2,-4(fp)
 90bb3dc:	1885883a 	add	r2,r3,r2
 90bb3e0:	10800023 	ldbuio	r2,0(r2)
 90bb3e4:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 90bb3e8:	0100fa04 	movi	r4,1000
 90bb3ec:	90baa880 	call	90baa88 <usleep>
    timeout--;
 90bb3f0:	e0bffb17 	ldw	r2,-20(fp)
 90bb3f4:	10bfffc4 	addi	r2,r2,-1
 90bb3f8:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 90bb3fc:	e0bffd03 	ldbu	r2,-12(fp)
 90bb400:	10803fcc 	andi	r2,r2,255
 90bb404:	1080020c 	andi	r2,r2,8
 90bb408:	1004c03a 	cmpne	r2,r2,zero
 90bb40c:	1000031e 	bne	r2,zero,90bb41c <alt_erase_block_amd+0x134>
 90bb410:	e0bffb17 	ldw	r2,-20(fp)
 90bb414:	10800048 	cmpgei	r2,r2,1
 90bb418:	103fec1e 	bne	r2,zero,90bb3cc <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 90bb41c:	e0bffa17 	ldw	r2,-24(fp)
 90bb420:	10803117 	ldw	r2,196(r2)
 90bb424:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 90bb428:	00001706 	br	90bb488 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90bb42c:	e0bffa17 	ldw	r2,-24(fp)
 90bb430:	10800a17 	ldw	r2,40(r2)
 90bb434:	1007883a 	mov	r3,r2
 90bb438:	e0bfff17 	ldw	r2,-4(fp)
 90bb43c:	1885883a 	add	r2,r3,r2
 90bb440:	10800023 	ldbuio	r2,0(r2)
 90bb444:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 90bb448:	e0bffd03 	ldbu	r2,-12(fp)
 90bb44c:	10803fcc 	andi	r2,r2,255
 90bb450:	1080201c 	xori	r2,r2,128
 90bb454:	10bfe004 	addi	r2,r2,-128
 90bb458:	1004803a 	cmplt	r2,r2,zero
 90bb45c:	10000d1e 	bne	r2,zero,90bb494 <alt_erase_block_amd+0x1ac>
 90bb460:	e0bffd03 	ldbu	r2,-12(fp)
 90bb464:	10803fcc 	andi	r2,r2,255
 90bb468:	1080080c 	andi	r2,r2,32
 90bb46c:	1004c03a 	cmpne	r2,r2,zero
 90bb470:	1000081e 	bne	r2,zero,90bb494 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 90bb474:	0100fa04 	movi	r4,1000
 90bb478:	90baa880 	call	90baa88 <usleep>
    timeout -= 1000;
 90bb47c:	e0bffb17 	ldw	r2,-20(fp)
 90bb480:	10bf0604 	addi	r2,r2,-1000
 90bb484:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 90bb488:	e0bffb17 	ldw	r2,-20(fp)
 90bb48c:	10800048 	cmpgei	r2,r2,1
 90bb490:	103fe61e 	bne	r2,zero,90bb42c <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 90bb494:	e0bffb17 	ldw	r2,-20(fp)
 90bb498:	10800048 	cmpgei	r2,r2,1
 90bb49c:	1000031e 	bne	r2,zero,90bb4ac <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 90bb4a0:	00bfe304 	movi	r2,-116
 90bb4a4:	e0bffc15 	stw	r2,-16(fp)
 90bb4a8:	00000f06 	br	90bb4e8 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 90bb4ac:	e0bffa17 	ldw	r2,-24(fp)
 90bb4b0:	10800a17 	ldw	r2,40(r2)
 90bb4b4:	1007883a 	mov	r3,r2
 90bb4b8:	e0bfff17 	ldw	r2,-4(fp)
 90bb4bc:	1885883a 	add	r2,r3,r2
 90bb4c0:	10800023 	ldbuio	r2,0(r2)
 90bb4c4:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 90bb4c8:	e0bffd03 	ldbu	r2,-12(fp)
 90bb4cc:	10803fcc 	andi	r2,r2,255
 90bb4d0:	1080201c 	xori	r2,r2,128
 90bb4d4:	10bfe004 	addi	r2,r2,-128
 90bb4d8:	1004803a 	cmplt	r2,r2,zero
 90bb4dc:	1000021e 	bne	r2,zero,90bb4e8 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 90bb4e0:	00bffec4 	movi	r2,-5
 90bb4e4:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 90bb4e8:	e0bffc17 	ldw	r2,-16(fp)
}
 90bb4ec:	e037883a 	mov	sp,fp
 90bb4f0:	dfc00117 	ldw	ra,4(sp)
 90bb4f4:	df000017 	ldw	fp,0(sp)
 90bb4f8:	dec00204 	addi	sp,sp,8
 90bb4fc:	f800283a 	ret

090bb500 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 90bb500:	defff804 	addi	sp,sp,-32
 90bb504:	dfc00715 	stw	ra,28(sp)
 90bb508:	df000615 	stw	fp,24(sp)
 90bb50c:	df000604 	addi	fp,sp,24
 90bb510:	e13ffd15 	stw	r4,-12(fp)
 90bb514:	e17ffe15 	stw	r5,-8(fp)
 90bb518:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 90bb51c:	e0bffd17 	ldw	r2,-12(fp)
 90bb520:	10803017 	ldw	r2,192(r2)
 90bb524:	10801924 	muli	r2,r2,100
 90bb528:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 90bb52c:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90bb530:	e0bffd17 	ldw	r2,-12(fp)
 90bb534:	10800a17 	ldw	r2,40(r2)
 90bb538:	1007883a 	mov	r3,r2
 90bb53c:	e0bffe17 	ldw	r2,-8(fp)
 90bb540:	1885883a 	add	r2,r3,r2
 90bb544:	10800023 	ldbuio	r2,0(r2)
 90bb548:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 90bb54c:	00001706 	br	90bb5ac <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 90bb550:	e0bffc03 	ldbu	r2,-16(fp)
 90bb554:	10803fcc 	andi	r2,r2,255
 90bb558:	10c0200c 	andi	r3,r2,128
 90bb55c:	e0bfff03 	ldbu	r2,-4(fp)
 90bb560:	1080200c 	andi	r2,r2,128
 90bb564:	18801426 	beq	r3,r2,90bb5b8 <alt_wait_for_command_to_complete_amd+0xb8>
 90bb568:	e0bffc03 	ldbu	r2,-16(fp)
 90bb56c:	10803fcc 	andi	r2,r2,255
 90bb570:	1080080c 	andi	r2,r2,32
 90bb574:	1004c03a 	cmpne	r2,r2,zero
 90bb578:	10000f1e 	bne	r2,zero,90bb5b8 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 90bb57c:	01000044 	movi	r4,1
 90bb580:	90baa880 	call	90baa88 <usleep>
    timeout--;
 90bb584:	e0bffb17 	ldw	r2,-20(fp)
 90bb588:	10bfffc4 	addi	r2,r2,-1
 90bb58c:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90bb590:	e0bffd17 	ldw	r2,-12(fp)
 90bb594:	10800a17 	ldw	r2,40(r2)
 90bb598:	1007883a 	mov	r3,r2
 90bb59c:	e0bffe17 	ldw	r2,-8(fp)
 90bb5a0:	1885883a 	add	r2,r3,r2
 90bb5a4:	10800023 	ldbuio	r2,0(r2)
 90bb5a8:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 90bb5ac:	e0bffb17 	ldw	r2,-20(fp)
 90bb5b0:	10800048 	cmpgei	r2,r2,1
 90bb5b4:	103fe61e 	bne	r2,zero,90bb550 <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 90bb5b8:	e0bffb17 	ldw	r2,-20(fp)
 90bb5bc:	1004c03a 	cmpne	r2,r2,zero
 90bb5c0:	1000031e 	bne	r2,zero,90bb5d0 <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 90bb5c4:	00bfe304 	movi	r2,-116
 90bb5c8:	e0bffa15 	stw	r2,-24(fp)
 90bb5cc:	00000f06 	br	90bb60c <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 90bb5d0:	e0bffd17 	ldw	r2,-12(fp)
 90bb5d4:	10800a17 	ldw	r2,40(r2)
 90bb5d8:	1007883a 	mov	r3,r2
 90bb5dc:	e0bffe17 	ldw	r2,-8(fp)
 90bb5e0:	1885883a 	add	r2,r3,r2
 90bb5e4:	10800023 	ldbuio	r2,0(r2)
 90bb5e8:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 90bb5ec:	e0bffc03 	ldbu	r2,-16(fp)
 90bb5f0:	10803fcc 	andi	r2,r2,255
 90bb5f4:	10c0200c 	andi	r3,r2,128
 90bb5f8:	e0bfff03 	ldbu	r2,-4(fp)
 90bb5fc:	1080200c 	andi	r2,r2,128
 90bb600:	18800226 	beq	r3,r2,90bb60c <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 90bb604:	00bffec4 	movi	r2,-5
 90bb608:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 90bb60c:	e0bffa17 	ldw	r2,-24(fp)
}
 90bb610:	e037883a 	mov	sp,fp
 90bb614:	dfc00117 	ldw	ra,4(sp)
 90bb618:	df000017 	ldw	fp,0(sp)
 90bb61c:	dec00204 	addi	sp,sp,8
 90bb620:	f800283a 	ret

090bb624 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 90bb624:	defff904 	addi	sp,sp,-28
 90bb628:	dfc00615 	stw	ra,24(sp)
 90bb62c:	df000515 	stw	fp,20(sp)
 90bb630:	df000504 	addi	fp,sp,20
 90bb634:	e13ffd15 	stw	r4,-12(fp)
 90bb638:	e17ffe15 	stw	r5,-8(fp)
 90bb63c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 90bb640:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 90bb644:	e0bffd17 	ldw	r2,-12(fp)
 90bb648:	10c03317 	ldw	r3,204(r2)
 90bb64c:	e0bffd17 	ldw	r2,-12(fp)
 90bb650:	11000a17 	ldw	r4,40(r2)
 90bb654:	01415544 	movi	r5,1365
 90bb658:	01802a84 	movi	r6,170
 90bb65c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 90bb660:	e0bffd17 	ldw	r2,-12(fp)
 90bb664:	10c03317 	ldw	r3,204(r2)
 90bb668:	e0bffd17 	ldw	r2,-12(fp)
 90bb66c:	11000a17 	ldw	r4,40(r2)
 90bb670:	0140aa84 	movi	r5,682
 90bb674:	01801544 	movi	r6,85
 90bb678:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 90bb67c:	e0bffd17 	ldw	r2,-12(fp)
 90bb680:	10c03317 	ldw	r3,204(r2)
 90bb684:	e0bffd17 	ldw	r2,-12(fp)
 90bb688:	11000a17 	ldw	r4,40(r2)
 90bb68c:	01415544 	movi	r5,1365
 90bb690:	01802804 	movi	r6,160
 90bb694:	183ee83a 	callr	r3
  
  value = *src_addr;
 90bb698:	e0bfff17 	ldw	r2,-4(fp)
 90bb69c:	10800003 	ldbu	r2,0(r2)
 90bb6a0:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 90bb6a4:	e13ffd17 	ldw	r4,-12(fp)
 90bb6a8:	e17ffe17 	ldw	r5,-8(fp)
 90bb6ac:	e1bfff17 	ldw	r6,-4(fp)
 90bb6b0:	9096bd00 	call	9096bd0 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 90bb6b4:	e1bffb03 	ldbu	r6,-20(fp)
 90bb6b8:	e13ffd17 	ldw	r4,-12(fp)
 90bb6bc:	e17ffe17 	ldw	r5,-8(fp)
 90bb6c0:	90bb5000 	call	90bb500 <alt_wait_for_command_to_complete_amd>
 90bb6c4:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 90bb6c8:	e0bffc17 	ldw	r2,-16(fp)
  
}
 90bb6cc:	e037883a 	mov	sp,fp
 90bb6d0:	dfc00117 	ldw	ra,4(sp)
 90bb6d4:	df000017 	ldw	fp,0(sp)
 90bb6d8:	dec00204 	addi	sp,sp,8
 90bb6dc:	f800283a 	ret

090bb6e0 <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 90bb6e0:	defff704 	addi	sp,sp,-36
 90bb6e4:	dfc00815 	stw	ra,32(sp)
 90bb6e8:	df000715 	stw	fp,28(sp)
 90bb6ec:	df000704 	addi	fp,sp,28
 90bb6f0:	e13ffc15 	stw	r4,-16(fp)
 90bb6f4:	e17ffd15 	stw	r5,-12(fp)
 90bb6f8:	e1bffe15 	stw	r6,-8(fp)
 90bb6fc:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 90bb700:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90bb704:	e0bffc17 	ldw	r2,-16(fp)
 90bb708:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 90bb70c:	e13ffa17 	ldw	r4,-24(fp)
 90bb710:	e17ffd17 	ldw	r5,-12(fp)
 90bb714:	90bb8d80 	call	90bb8d8 <alt_unlock_block_intel>
 90bb718:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 90bb71c:	e0bffb17 	ldw	r2,-20(fp)
 90bb720:	1004c03a 	cmpne	r2,r2,zero
 90bb724:	1000091e 	bne	r2,zero,90bb74c <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 90bb728:	e1bfff17 	ldw	r6,-4(fp)
 90bb72c:	00824334 	movhi	r2,2316
 90bb730:	10ae9904 	addi	r2,r2,-17820
 90bb734:	d8800015 	stw	r2,0(sp)
 90bb738:	e13ffa17 	ldw	r4,-24(fp)
 90bb73c:	e17ffe17 	ldw	r5,-8(fp)
 90bb740:	e1c00217 	ldw	r7,8(fp)
 90bb744:	9096d340 	call	9096d34 <alt_flash_program_block>
 90bb748:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 90bb74c:	e0bffb17 	ldw	r2,-20(fp)
}
 90bb750:	e037883a 	mov	sp,fp
 90bb754:	dfc00117 	ldw	ra,4(sp)
 90bb758:	df000017 	ldw	fp,0(sp)
 90bb75c:	dec00204 	addi	sp,sp,8
 90bb760:	f800283a 	ret

090bb764 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 90bb764:	defff804 	addi	sp,sp,-32
 90bb768:	dfc00715 	stw	ra,28(sp)
 90bb76c:	df000615 	stw	fp,24(sp)
 90bb770:	df000604 	addi	fp,sp,24
 90bb774:	e13ffe15 	stw	r4,-8(fp)
 90bb778:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 90bb77c:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 90bb780:	e0bffe17 	ldw	r2,-8(fp)
 90bb784:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 90bb788:	e0bffb17 	ldw	r2,-20(fp)
 90bb78c:	10803117 	ldw	r2,196(r2)
 90bb790:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 90bb794:	e13ffb17 	ldw	r4,-20(fp)
 90bb798:	e17fff17 	ldw	r5,-4(fp)
 90bb79c:	90bb8d80 	call	90bb8d8 <alt_unlock_block_intel>
 90bb7a0:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 90bb7a4:	e0bffc17 	ldw	r2,-16(fp)
 90bb7a8:	1004c03a 	cmpne	r2,r2,zero
 90bb7ac:	1000441e 	bne	r2,zero,90bb8c0 <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 90bb7b0:	e0bffb17 	ldw	r2,-20(fp)
 90bb7b4:	11803517 	ldw	r6,212(r2)
 90bb7b8:	e0bffb17 	ldw	r2,-20(fp)
 90bb7bc:	10800a17 	ldw	r2,40(r2)
 90bb7c0:	1007883a 	mov	r3,r2
 90bb7c4:	e0bfff17 	ldw	r2,-4(fp)
 90bb7c8:	1889883a 	add	r4,r3,r2
 90bb7cc:	01400804 	movi	r5,32
 90bb7d0:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 90bb7d4:	e0bffb17 	ldw	r2,-20(fp)
 90bb7d8:	11803517 	ldw	r6,212(r2)
 90bb7dc:	e0bffb17 	ldw	r2,-20(fp)
 90bb7e0:	10800a17 	ldw	r2,40(r2)
 90bb7e4:	1007883a 	mov	r3,r2
 90bb7e8:	e0bfff17 	ldw	r2,-4(fp)
 90bb7ec:	1889883a 	add	r4,r3,r2
 90bb7f0:	01403404 	movi	r5,208
 90bb7f4:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90bb7f8:	e0bffb17 	ldw	r2,-20(fp)
 90bb7fc:	10800a17 	ldw	r2,40(r2)
 90bb800:	1007883a 	mov	r3,r2
 90bb804:	e0bfff17 	ldw	r2,-4(fp)
 90bb808:	1885883a 	add	r2,r3,r2
 90bb80c:	10800023 	ldbuio	r2,0(r2)
 90bb810:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 90bb814:	e0bffd03 	ldbu	r2,-12(fp)
 90bb818:	10803fcc 	andi	r2,r2,255
 90bb81c:	1080201c 	xori	r2,r2,128
 90bb820:	10bfe004 	addi	r2,r2,-128
 90bb824:	1004803a 	cmplt	r2,r2,zero
 90bb828:	1000081e 	bne	r2,zero,90bb84c <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 90bb82c:	0100fa04 	movi	r4,1000
 90bb830:	90baa880 	call	90baa88 <usleep>
      timeout -= 1000;
 90bb834:	e0bffa17 	ldw	r2,-24(fp)
 90bb838:	10bf0604 	addi	r2,r2,-1000
 90bb83c:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 90bb840:	e0bffa17 	ldw	r2,-24(fp)
 90bb844:	10800048 	cmpgei	r2,r2,1
 90bb848:	103feb1e 	bne	r2,zero,90bb7f8 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 90bb84c:	e0bffa17 	ldw	r2,-24(fp)
 90bb850:	10800048 	cmpgei	r2,r2,1
 90bb854:	1000031e 	bne	r2,zero,90bb864 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 90bb858:	00bfe304 	movi	r2,-116
 90bb85c:	e0bffc15 	stw	r2,-16(fp)
 90bb860:	00000e06 	br	90bb89c <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 90bb864:	e0bffd03 	ldbu	r2,-12(fp)
 90bb868:	10803fcc 	andi	r2,r2,255
 90bb86c:	10801fcc 	andi	r2,r2,127
 90bb870:	1005003a 	cmpeq	r2,r2,zero
 90bb874:	1000091e 	bne	r2,zero,90bb89c <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 90bb878:	00bffec4 	movi	r2,-5
 90bb87c:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90bb880:	e0bffb17 	ldw	r2,-20(fp)
 90bb884:	10800a17 	ldw	r2,40(r2)
 90bb888:	1007883a 	mov	r3,r2
 90bb88c:	e0bfff17 	ldw	r2,-4(fp)
 90bb890:	1885883a 	add	r2,r3,r2
 90bb894:	10800023 	ldbuio	r2,0(r2)
 90bb898:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 90bb89c:	e0bffb17 	ldw	r2,-20(fp)
 90bb8a0:	11803517 	ldw	r6,212(r2)
 90bb8a4:	e0bffb17 	ldw	r2,-20(fp)
 90bb8a8:	10800a17 	ldw	r2,40(r2)
 90bb8ac:	1007883a 	mov	r3,r2
 90bb8b0:	e0bfff17 	ldw	r2,-4(fp)
 90bb8b4:	1889883a 	add	r4,r3,r2
 90bb8b8:	01403fc4 	movi	r5,255
 90bb8bc:	303ee83a 	callr	r6
  }
  
  return ret_code;
 90bb8c0:	e0bffc17 	ldw	r2,-16(fp)
}
 90bb8c4:	e037883a 	mov	sp,fp
 90bb8c8:	dfc00117 	ldw	ra,4(sp)
 90bb8cc:	df000017 	ldw	fp,0(sp)
 90bb8d0:	dec00204 	addi	sp,sp,8
 90bb8d4:	f800283a 	ret

090bb8d8 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 90bb8d8:	defff904 	addi	sp,sp,-28
 90bb8dc:	dfc00615 	stw	ra,24(sp)
 90bb8e0:	df000515 	stw	fp,20(sp)
 90bb8e4:	df000504 	addi	fp,sp,20
 90bb8e8:	e13ffe15 	stw	r4,-8(fp)
 90bb8ec:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 90bb8f0:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 90bb8f4:	e0bffe17 	ldw	r2,-8(fp)
 90bb8f8:	10803017 	ldw	r2,192(r2)
 90bb8fc:	10801924 	muli	r2,r2,100
 90bb900:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 90bb904:	e0bffe17 	ldw	r2,-8(fp)
 90bb908:	11803517 	ldw	r6,212(r2)
 90bb90c:	e0bffe17 	ldw	r2,-8(fp)
 90bb910:	10800a17 	ldw	r2,40(r2)
 90bb914:	1007883a 	mov	r3,r2
 90bb918:	e0bfff17 	ldw	r2,-4(fp)
 90bb91c:	1889883a 	add	r4,r3,r2
 90bb920:	01402404 	movi	r5,144
 90bb924:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 90bb928:	e0bffe17 	ldw	r2,-8(fp)
 90bb92c:	10800a17 	ldw	r2,40(r2)
 90bb930:	1007883a 	mov	r3,r2
 90bb934:	e0bfff17 	ldw	r2,-4(fp)
 90bb938:	1885883a 	add	r2,r3,r2
 90bb93c:	10800104 	addi	r2,r2,4
 90bb940:	10800023 	ldbuio	r2,0(r2)
 90bb944:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 90bb948:	e0bffd43 	ldbu	r2,-11(fp)
 90bb94c:	1080004c 	andi	r2,r2,1
 90bb950:	10803fcc 	andi	r2,r2,255
 90bb954:	1005003a 	cmpeq	r2,r2,zero
 90bb958:	1000331e 	bne	r2,zero,90bba28 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 90bb95c:	e0bffe17 	ldw	r2,-8(fp)
 90bb960:	11803517 	ldw	r6,212(r2)
 90bb964:	e0bffe17 	ldw	r2,-8(fp)
 90bb968:	10800a17 	ldw	r2,40(r2)
 90bb96c:	1007883a 	mov	r3,r2
 90bb970:	e0bfff17 	ldw	r2,-4(fp)
 90bb974:	1889883a 	add	r4,r3,r2
 90bb978:	01401804 	movi	r5,96
 90bb97c:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 90bb980:	e0bffe17 	ldw	r2,-8(fp)
 90bb984:	11803517 	ldw	r6,212(r2)
 90bb988:	e0bffe17 	ldw	r2,-8(fp)
 90bb98c:	10800a17 	ldw	r2,40(r2)
 90bb990:	1007883a 	mov	r3,r2
 90bb994:	e0bfff17 	ldw	r2,-4(fp)
 90bb998:	1889883a 	add	r4,r3,r2
 90bb99c:	01403404 	movi	r5,208
 90bb9a0:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 90bb9a4:	e0bffe17 	ldw	r2,-8(fp)
 90bb9a8:	10800a17 	ldw	r2,40(r2)
 90bb9ac:	1007883a 	mov	r3,r2
 90bb9b0:	e0bfff17 	ldw	r2,-4(fp)
 90bb9b4:	1885883a 	add	r2,r3,r2
 90bb9b8:	10800023 	ldbuio	r2,0(r2)
 90bb9bc:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 90bb9c0:	e0bffd03 	ldbu	r2,-12(fp)
 90bb9c4:	10803fcc 	andi	r2,r2,255
 90bb9c8:	1080201c 	xori	r2,r2,128
 90bb9cc:	10bfe004 	addi	r2,r2,-128
 90bb9d0:	1004803a 	cmplt	r2,r2,zero
 90bb9d4:	1000081e 	bne	r2,zero,90bb9f8 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 90bb9d8:	e0bffb17 	ldw	r2,-20(fp)
 90bb9dc:	10bfffc4 	addi	r2,r2,-1
 90bb9e0:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 90bb9e4:	01000044 	movi	r4,1
 90bb9e8:	90baa880 	call	90baa88 <usleep>
    }while(timeout > 0);
 90bb9ec:	e0bffb17 	ldw	r2,-20(fp)
 90bb9f0:	10800048 	cmpgei	r2,r2,1
 90bb9f4:	103feb1e 	bne	r2,zero,90bb9a4 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 90bb9f8:	e0bffb17 	ldw	r2,-20(fp)
 90bb9fc:	1004c03a 	cmpne	r2,r2,zero
 90bba00:	1000031e 	bne	r2,zero,90bba10 <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 90bba04:	00bfe304 	movi	r2,-116
 90bba08:	e0bffc15 	stw	r2,-16(fp)
 90bba0c:	00000606 	br	90bba28 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 90bba10:	e0bffd03 	ldbu	r2,-12(fp)
 90bba14:	10801fcc 	andi	r2,r2,127
 90bba18:	1005003a 	cmpeq	r2,r2,zero
 90bba1c:	1000021e 	bne	r2,zero,90bba28 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 90bba20:	00bffec4 	movi	r2,-5
 90bba24:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 90bba28:	e0bffe17 	ldw	r2,-8(fp)
 90bba2c:	11803517 	ldw	r6,212(r2)
 90bba30:	e0bffe17 	ldw	r2,-8(fp)
 90bba34:	10800a17 	ldw	r2,40(r2)
 90bba38:	1007883a 	mov	r3,r2
 90bba3c:	e0bfff17 	ldw	r2,-4(fp)
 90bba40:	1889883a 	add	r4,r3,r2
 90bba44:	01403fc4 	movi	r5,255
 90bba48:	303ee83a 	callr	r6

  return ret_code;
 90bba4c:	e0bffc17 	ldw	r2,-16(fp)
}
 90bba50:	e037883a 	mov	sp,fp
 90bba54:	dfc00117 	ldw	ra,4(sp)
 90bba58:	df000017 	ldw	fp,0(sp)
 90bba5c:	dec00204 	addi	sp,sp,8
 90bba60:	f800283a 	ret

090bba64 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 90bba64:	defff904 	addi	sp,sp,-28
 90bba68:	dfc00615 	stw	ra,24(sp)
 90bba6c:	df000515 	stw	fp,20(sp)
 90bba70:	df000504 	addi	fp,sp,20
 90bba74:	e13ffd15 	stw	r4,-12(fp)
 90bba78:	e17ffe15 	stw	r5,-8(fp)
 90bba7c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 90bba80:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 90bba84:	e0bffd17 	ldw	r2,-12(fp)
 90bba88:	11803517 	ldw	r6,212(r2)
 90bba8c:	e0bffd17 	ldw	r2,-12(fp)
 90bba90:	10800a17 	ldw	r2,40(r2)
 90bba94:	1007883a 	mov	r3,r2
 90bba98:	e0bffe17 	ldw	r2,-8(fp)
 90bba9c:	1889883a 	add	r4,r3,r2
 90bbaa0:	01401004 	movi	r5,64
 90bbaa4:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 90bbaa8:	e13ffd17 	ldw	r4,-12(fp)
 90bbaac:	e17ffe17 	ldw	r5,-8(fp)
 90bbab0:	e1bfff17 	ldw	r6,-4(fp)
 90bbab4:	9096bd00 	call	9096bd0 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 90bbab8:	e0bffd17 	ldw	r2,-12(fp)
 90bbabc:	10800a17 	ldw	r2,40(r2)
 90bbac0:	1007883a 	mov	r3,r2
 90bbac4:	e0bffe17 	ldw	r2,-8(fp)
 90bbac8:	1885883a 	add	r2,r3,r2
 90bbacc:	10800023 	ldbuio	r2,0(r2)
 90bbad0:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 90bbad4:	e0bffb03 	ldbu	r2,-20(fp)
 90bbad8:	10803fcc 	andi	r2,r2,255
 90bbadc:	1080201c 	xori	r2,r2,128
 90bbae0:	10bfe004 	addi	r2,r2,-128
 90bbae4:	1004403a 	cmpge	r2,r2,zero
 90bbae8:	103ff31e 	bne	r2,zero,90bbab8 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 90bbaec:	e0bffb03 	ldbu	r2,-20(fp)
 90bbaf0:	10801fcc 	andi	r2,r2,127
 90bbaf4:	1005003a 	cmpeq	r2,r2,zero
 90bbaf8:	1000021e 	bne	r2,zero,90bbb04 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 90bbafc:	00bffec4 	movi	r2,-5
 90bbb00:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 90bbb04:	e0bffd17 	ldw	r2,-12(fp)
 90bbb08:	11803517 	ldw	r6,212(r2)
 90bbb0c:	e0bffd17 	ldw	r2,-12(fp)
 90bbb10:	10800a17 	ldw	r2,40(r2)
 90bbb14:	1007883a 	mov	r3,r2
 90bbb18:	e0bffe17 	ldw	r2,-8(fp)
 90bbb1c:	1889883a 	add	r4,r3,r2
 90bbb20:	01403fc4 	movi	r5,255
 90bbb24:	303ee83a 	callr	r6
  
  return ret_code;
 90bbb28:	e0bffc17 	ldw	r2,-16(fp)
}
 90bbb2c:	e037883a 	mov	sp,fp
 90bbb30:	dfc00117 	ldw	ra,4(sp)
 90bbb34:	df000017 	ldw	fp,0(sp)
 90bbb38:	dec00204 	addi	sp,sp,8
 90bbb3c:	f800283a 	ret

090bbb40 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 90bbb40:	defffb04 	addi	sp,sp,-20
 90bbb44:	dfc00415 	stw	ra,16(sp)
 90bbb48:	df000315 	stw	fp,12(sp)
 90bbb4c:	dc000215 	stw	r16,8(sp)
 90bbb50:	df000204 	addi	fp,sp,8
   int   e = 0;
 90bbb54:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 90bbb58:	d1204b17 	ldw	r4,-32468(gp)
 90bbb5c:	90836b80 	call	90836b8 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 90bbb60:	01024374 	movhi	r4,2317
 90bbb64:	21029f04 	addi	r4,r4,2684
 90bbb68:	90836b80 	call	90836b8 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 90bbb6c:	90aadfc0 	call	90aadfc <pre_task_setup>
 90bbb70:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bbb74:	e0bffe17 	ldw	r2,-8(fp)
 90bbb78:	1005003a 	cmpeq	r2,r2,zero
 90bbb7c:	1000021e 	bne	r2,zero,90bbb88 <netmain_init+0x48>
      panic(msg);
 90bbb80:	e13ffe17 	ldw	r4,-8(fp)
 90bbb84:	90a537c0 	call	90a537c <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 90bbb88:	90a2ce80 	call	90a2ce8 <ip_startup>
 90bbb8c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bbb90:	e0bffe17 	ldw	r2,-8(fp)
 90bbb94:	1005003a 	cmpeq	r2,r2,zero
 90bbb98:	1000071e 	bne	r2,zero,90bbbb8 <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 90bbb9c:	01024374 	movhi	r4,2317
 90bbba0:	2102b104 	addi	r4,r4,2756
 90bbba4:	e17ffe17 	ldw	r5,-8(fp)
 90bbba8:	90833900 	call	9083390 <printf>
      panic("IP");
 90bbbac:	01024374 	movhi	r4,2317
 90bbbb0:	2102b704 	addi	r4,r4,2780
 90bbbb4:	90a537c0 	call	90a537c <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 90bbbb8:	90c6a400 	call	90c6a40 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 90bbbbc:	90c5f880 	call	90c5f88 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 90bbbc0:	00824374 	movhi	r2,2317
 90bbbc4:	108f0904 	addi	r2,r2,15396
 90bbbc8:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 90bbbcc:	008243b4 	movhi	r2,2318
 90bbbd0:	10b82704 	addi	r2,r2,-8036
 90bbbd4:	10800017 	ldw	r2,0(r2)
 90bbbd8:	14000104 	addi	r16,r2,4
 90bbbdc:	008243b4 	movhi	r2,2318
 90bbbe0:	10b82704 	addi	r2,r2,-8036
 90bbbe4:	10800017 	ldw	r2,0(r2)
 90bbbe8:	11000a17 	ldw	r4,40(r2)
 90bbbec:	90a514c0 	call	90a514c <print_ipad>
 90bbbf0:	100d883a 	mov	r6,r2
 90bbbf4:	01024374 	movhi	r4,2317
 90bbbf8:	2102b804 	addi	r4,r4,2784
 90bbbfc:	800b883a 	mov	r5,r16
 90bbc00:	90833900 	call	9083390 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 90bbc04:	90aae700 	call	90aae70 <post_task_setup>
 90bbc08:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 90bbc0c:	e0bffe17 	ldw	r2,-8(fp)
 90bbc10:	1005003a 	cmpeq	r2,r2,zero
 90bbc14:	1000021e 	bne	r2,zero,90bbc20 <netmain_init+0xe0>
      panic(msg);
 90bbc18:	e13ffe17 	ldw	r4,-8(fp)
 90bbc1c:	90a537c0 	call	90a537c <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 90bbc20:	90c66700 	call	90c6670 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 90bbc24:	e037883a 	mov	sp,fp
 90bbc28:	dfc00217 	ldw	ra,8(sp)
 90bbc2c:	df000117 	ldw	fp,4(sp)
 90bbc30:	dc000017 	ldw	r16,0(sp)
 90bbc34:	dec00304 	addi	sp,sp,12
 90bbc38:	f800283a 	ret

090bbc3c <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 90bbc3c:	defffb04 	addi	sp,sp,-20
 90bbc40:	dfc00415 	stw	ra,16(sp)
 90bbc44:	df000315 	stw	fp,12(sp)
 90bbc48:	dc000215 	stw	r16,8(sp)
 90bbc4c:	df000204 	addi	fp,sp,8
 90bbc50:	e13ffe15 	stw	r4,-8(fp)
 90bbc54:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 90bbc58:	e0bfff17 	ldw	r2,-4(fp)
 90bbc5c:	10800003 	ldbu	r2,0(r2)
 90bbc60:	10803fcc 	andi	r2,r2,255
 90bbc64:	1080201c 	xori	r2,r2,128
 90bbc68:	10bfe004 	addi	r2,r2,-128
 90bbc6c:	00c24374 	movhi	r3,2317
 90bbc70:	18ce2104 	addi	r3,r3,14468
 90bbc74:	1085883a 	add	r2,r2,r2
 90bbc78:	1085883a 	add	r2,r2,r2
 90bbc7c:	10c5883a 	add	r2,r2,r3
 90bbc80:	14000017 	ldw	r16,0(r2)
 90bbc84:	e0bffe17 	ldw	r2,-8(fp)
 90bbc88:	11000717 	ldw	r4,28(r2)
 90bbc8c:	90a514c0 	call	90a514c <print_ipad>
 90bbc90:	100d883a 	mov	r6,r2
 90bbc94:	01024374 	movhi	r4,2317
 90bbc98:	2102c804 	addi	r4,r4,2848
 90bbc9c:	800b883a 	mov	r5,r16
 90bbca0:	90833900 	call	9083390 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 90bbca4:	d1204c17 	ldw	r4,-32464(gp)
 90bbca8:	90833900 	call	9083390 <printf>
}
 90bbcac:	e037883a 	mov	sp,fp
 90bbcb0:	dfc00217 	ldw	ra,8(sp)
 90bbcb4:	df000117 	ldw	fp,4(sp)
 90bbcb8:	dc000017 	ldw	r16,0(sp)
 90bbcbc:	dec00304 	addi	sp,sp,12
 90bbcc0:	f800283a 	ret

090bbcc4 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 90bbcc4:	defff904 	addi	sp,sp,-28
 90bbcc8:	dfc00615 	stw	ra,24(sp)
 90bbccc:	df000515 	stw	fp,20(sp)
 90bbcd0:	dc000415 	stw	r16,16(sp)
 90bbcd4:	df000404 	addi	fp,sp,16
 90bbcd8:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 90bbcdc:	e03ffe15 	stw	zero,-8(fp)
 90bbce0:	008243b4 	movhi	r2,2318
 90bbce4:	10b82704 	addi	r2,r2,-8036
 90bbce8:	10800017 	ldw	r2,0(r2)
 90bbcec:	e0bffd15 	stw	r2,-12(fp)
 90bbcf0:	00002206 	br	90bbd7c <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 90bbcf4:	e0bffd17 	ldw	r2,-12(fp)
 90bbcf8:	14000104 	addi	r16,r2,4
 90bbcfc:	e0bffd17 	ldw	r2,-12(fp)
 90bbd00:	11000a17 	ldw	r4,40(r2)
 90bbd04:	90a514c0 	call	90a514c <print_ipad>
 90bbd08:	d8800015 	stw	r2,0(sp)
 90bbd0c:	e13fff17 	ldw	r4,-4(fp)
 90bbd10:	01424374 	movhi	r5,2317
 90bbd14:	2942d104 	addi	r5,r5,2884
 90bbd18:	e1bffe17 	ldw	r6,-8(fp)
 90bbd1c:	800f883a 	mov	r7,r16
 90bbd20:	90a55a40 	call	90a55a4 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 90bbd24:	e0bffd17 	ldw	r2,-12(fp)
 90bbd28:	11000c17 	ldw	r4,48(r2)
 90bbd2c:	90a514c0 	call	90a514c <print_ipad>
 90bbd30:	100d883a 	mov	r6,r2
 90bbd34:	e13fff17 	ldw	r4,-4(fp)
 90bbd38:	01424374 	movhi	r5,2317
 90bbd3c:	2942d804 	addi	r5,r5,2912
 90bbd40:	90a55a40 	call	90a55a4 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 90bbd44:	e0bffd17 	ldw	r2,-12(fp)
 90bbd48:	11000d17 	ldw	r4,52(r2)
 90bbd4c:	90a514c0 	call	90a514c <print_ipad>
 90bbd50:	100d883a 	mov	r6,r2
 90bbd54:	e13fff17 	ldw	r4,-4(fp)
 90bbd58:	01424374 	movhi	r5,2317
 90bbd5c:	2942db04 	addi	r5,r5,2924
 90bbd60:	90a55a40 	call	90a55a4 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 90bbd64:	e0bffd17 	ldw	r2,-12(fp)
 90bbd68:	10800017 	ldw	r2,0(r2)
 90bbd6c:	e0bffd15 	stw	r2,-12(fp)
 90bbd70:	e0bffe17 	ldw	r2,-8(fp)
 90bbd74:	10800044 	addi	r2,r2,1
 90bbd78:	e0bffe15 	stw	r2,-8(fp)
 90bbd7c:	e0bffd17 	ldw	r2,-12(fp)
 90bbd80:	1004c03a 	cmpne	r2,r2,zero
 90bbd84:	103fdb1e 	bne	r2,zero,90bbcf4 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 90bbd88:	00824374 	movhi	r2,2317
 90bbd8c:	108f2e04 	addi	r2,r2,15544
 90bbd90:	11800017 	ldw	r6,0(r2)
 90bbd94:	e13fff17 	ldw	r4,-4(fp)
 90bbd98:	01424374 	movhi	r5,2317
 90bbd9c:	2942de04 	addi	r5,r5,2936
 90bbda0:	90a55a40 	call	90a55a4 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 90bbda4:	d4204d17 	ldw	r16,-32460(gp)
 90bbda8:	d1204d17 	ldw	r4,-32460(gp)
 90bbdac:	908d0380 	call	908d038 <__floatunsidf>
 90bbdb0:	100b883a 	mov	r5,r2
 90bbdb4:	180d883a 	mov	r6,r3
 90bbdb8:	2809883a 	mov	r4,r5
 90bbdbc:	300b883a 	mov	r5,r6
 90bbdc0:	000d883a 	mov	r6,zero
 90bbdc4:	01d00934 	movhi	r7,16420
 90bbdc8:	908c5b40 	call	908c5b4 <__muldf3>
 90bbdcc:	1009883a 	mov	r4,r2
 90bbdd0:	180b883a 	mov	r5,r3
 90bbdd4:	2005883a 	mov	r2,r4
 90bbdd8:	2807883a 	mov	r3,r5
 90bbddc:	d8c00015 	stw	r3,0(sp)
 90bbde0:	100f883a 	mov	r7,r2
 90bbde4:	e13fff17 	ldw	r4,-4(fp)
 90bbde8:	01424374 	movhi	r5,2317
 90bbdec:	2942e404 	addi	r5,r5,2960
 90bbdf0:	800d883a 	mov	r6,r16
 90bbdf4:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 90bbdf8:	d120bb17 	ldw	r4,-32020(gp)
 90bbdfc:	90a514c0 	call	90a514c <print_ipad>
 90bbe00:	100d883a 	mov	r6,r2
 90bbe04:	e13fff17 	ldw	r4,-4(fp)
 90bbe08:	01424374 	movhi	r5,2317
 90bbe0c:	2942f004 	addi	r5,r5,3008
 90bbe10:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 90bbe14:	d1a04e17 	ldw	r6,-32456(gp)
 90bbe18:	e13fff17 	ldw	r4,-4(fp)
 90bbe1c:	01424374 	movhi	r5,2317
 90bbe20:	2942f704 	addi	r5,r5,3036
 90bbe24:	90a55a40 	call	90a55a4 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 90bbe28:	e13fff17 	ldw	r4,-4(fp)
 90bbe2c:	90bc5400 	call	90bc540 <task_stats>

   return 0;
 90bbe30:	0005883a 	mov	r2,zero
}
 90bbe34:	e037883a 	mov	sp,fp
 90bbe38:	dfc00217 	ldw	ra,8(sp)
 90bbe3c:	df000117 	ldw	fp,4(sp)
 90bbe40:	dc000017 	ldw	r16,0(sp)
 90bbe44:	dec00304 	addi	sp,sp,12
 90bbe48:	f800283a 	ret

090bbe4c <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 90bbe4c:	defffe04 	addi	sp,sp,-8
 90bbe50:	dfc00115 	stw	ra,4(sp)
 90bbe54:	df000015 	stw	fp,0(sp)
 90bbe58:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 90bbe5c:	00824374 	movhi	r2,2317
 90bbe60:	108f2e04 	addi	r2,r2,15544
 90bbe64:	11000017 	ldw	r4,0(r2)
 90bbe68:	908d0380 	call	908d038 <__floatunsidf>
 90bbe6c:	100b883a 	mov	r5,r2
 90bbe70:	180d883a 	mov	r6,r3
 90bbe74:	2809883a 	mov	r4,r5
 90bbe78:	300b883a 	mov	r5,r6
 90bbe7c:	000d883a 	mov	r6,zero
 90bbe80:	01d01674 	movhi	r7,16473
 90bbe84:	908c9680 	call	908c968 <__divdf3>
 90bbe88:	1009883a 	mov	r4,r2
 90bbe8c:	180b883a 	mov	r5,r3
 90bbe90:	2005883a 	mov	r2,r4
 90bbe94:	2807883a 	mov	r3,r5
 90bbe98:	1009883a 	mov	r4,r2
 90bbe9c:	180b883a 	mov	r5,r3
 90bbea0:	000d883a 	mov	r6,zero
 90bbea4:	01d01674 	movhi	r7,16473
 90bbea8:	908c5b40 	call	908c5b4 <__muldf3>
 90bbeac:	1009883a 	mov	r4,r2
 90bbeb0:	180b883a 	mov	r5,r3
 90bbeb4:	2005883a 	mov	r2,r4
 90bbeb8:	2807883a 	mov	r3,r5
 90bbebc:	1009883a 	mov	r4,r2
 90bbec0:	180b883a 	mov	r5,r3
 90bbec4:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
}
 90bbec8:	e037883a 	mov	sp,fp
 90bbecc:	dfc00117 	ldw	ra,4(sp)
 90bbed0:	df000017 	ldw	fp,0(sp)
 90bbed4:	dec00204 	addi	sp,sp,8
 90bbed8:	f800283a 	ret

090bbedc <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 90bbedc:	defffe04 	addi	sp,sp,-8
 90bbee0:	dfc00115 	stw	ra,4(sp)
 90bbee4:	df000015 	stw	fp,0(sp)
 90bbee8:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 90bbeec:	d0a0bc17 	ldw	r2,-32016(gp)
 90bbef0:	1004c03a 	cmpne	r2,r2,zero
 90bbef4:	1000071e 	bne	r2,zero,90bbf14 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 90bbef8:	d0a0bc17 	ldw	r2,-32016(gp)
 90bbefc:	10800044 	addi	r2,r2,1
 90bbf00:	d0a0bc15 	stw	r2,-32016(gp)
   pktdemux();          /* process low level packet input */
 90bbf04:	90a26a00 	call	90a26a0 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 90bbf08:	d0a0bc17 	ldw	r2,-32016(gp)
 90bbf0c:	10bfffc4 	addi	r2,r2,-1
 90bbf10:	d0a0bc15 	stw	r2,-32016(gp)
}
 90bbf14:	e037883a 	mov	sp,fp
 90bbf18:	dfc00117 	ldw	ra,4(sp)
 90bbf1c:	df000017 	ldw	fp,0(sp)
 90bbf20:	dec00204 	addi	sp,sp,8
 90bbf24:	f800283a 	ret

090bbf28 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 90bbf28:	defffe04 	addi	sp,sp,-8
 90bbf2c:	df000115 	stw	fp,4(sp)
 90bbf30:	df000104 	addi	fp,sp,4
 90bbf34:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 90bbf38:	0005883a 	mov	r2,zero
}
 90bbf3c:	e037883a 	mov	sp,fp
 90bbf40:	df000017 	ldw	fp,0(sp)
 90bbf44:	dec00104 	addi	sp,sp,4
 90bbf48:	f800283a 	ret

090bbf4c <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 90bbf4c:	defffd04 	addi	sp,sp,-12
 90bbf50:	dfc00215 	stw	ra,8(sp)
 90bbf54:	df000115 	stw	fp,4(sp)
 90bbf58:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 90bbf5c:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 90bbf60:	90c9b9c0 	call	90c9b9c <prep_vfs>
 90bbf64:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 90bbf68:	e0bfff17 	ldw	r2,-4(fp)
 90bbf6c:	1005003a 	cmpeq	r2,r2,zero
 90bbf70:	1000061e 	bne	r2,zero,90bbf8c <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 90bbf74:	01024374 	movhi	r4,2317
 90bbf78:	2102ff04 	addi	r4,r4,3068
 90bbf7c:	90836b80 	call	90836b8 <puts>
      panic("prep_modules");
 90bbf80:	01024374 	movhi	r4,2317
 90bbf84:	21030504 	addi	r4,r4,3092
 90bbf88:	90a537c0 	call	90a537c <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 90bbf8c:	0005883a 	mov	r2,zero
}
 90bbf90:	e037883a 	mov	sp,fp
 90bbf94:	dfc00117 	ldw	ra,4(sp)
 90bbf98:	df000017 	ldw	fp,0(sp)
 90bbf9c:	dec00204 	addi	sp,sp,8
 90bbfa0:	f800283a 	ret

090bbfa4 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 90bbfa4:	defffc04 	addi	sp,sp,-16
 90bbfa8:	dfc00315 	stw	ra,12(sp)
 90bbfac:	df000215 	stw	fp,8(sp)
 90bbfb0:	dc400115 	stw	r17,4(sp)
 90bbfb4:	dc000015 	stw	r16,0(sp)
 90bbfb8:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 90bbfbc:	00824374 	movhi	r2,2317
 90bbfc0:	108f4f04 	addi	r2,r2,15676
 90bbfc4:	10c00017 	ldw	r3,0(r2)
 90bbfc8:	00824374 	movhi	r2,2317
 90bbfcc:	108f2e04 	addi	r2,r2,15544
 90bbfd0:	10800017 	ldw	r2,0(r2)
 90bbfd4:	1880012e 	bgeu	r3,r2,90bbfdc <inet_timer+0x38>
      ip_reasm_process_timer_tick ();
 90bbfd8:	90c17500 	call	90c1750 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 90bbfdc:	90aca400 	call	90aca40 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 90bbfe0:	90bc1080 	call	90bc108 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 90bbfe4:	00824374 	movhi	r2,2317
 90bbfe8:	108f0d04 	addi	r2,r2,15412
 90bbfec:	10c00017 	ldw	r3,0(r2)
 90bbff0:	00824374 	movhi	r2,2317
 90bbff4:	108f2e04 	addi	r2,r2,15544
 90bbff8:	10800017 	ldw	r2,0(r2)
 90bbffc:	1880012e 	bgeu	r3,r2,90bc004 <inet_timer+0x60>
      igmp_fasttimo();
 90bc000:	90a33800 	call	90a3380 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 90bc004:	d0a0bd17 	ldw	r2,-32012(gp)
 90bc008:	00c24374 	movhi	r3,2317
 90bc00c:	18cf2e04 	addi	r3,r3,15544
 90bc010:	18c00017 	ldw	r3,0(r3)
 90bc014:	10c01c36 	bltu	r2,r3,90bc088 <inet_timer+0xe4>
 90bc018:	d120bd17 	ldw	r4,-32012(gp)
 90bc01c:	908d0380 	call	908d038 <__floatunsidf>
 90bc020:	1021883a 	mov	r16,r2
 90bc024:	1823883a 	mov	r17,r3
 90bc028:	00824374 	movhi	r2,2317
 90bc02c:	108f2e04 	addi	r2,r2,15544
 90bc030:	11000017 	ldw	r4,0(r2)
 90bc034:	908d0380 	call	908d038 <__floatunsidf>
 90bc038:	100b883a 	mov	r5,r2
 90bc03c:	180d883a 	mov	r6,r3
 90bc040:	2809883a 	mov	r4,r5
 90bc044:	300b883a 	mov	r5,r6
 90bc048:	000d883a 	mov	r6,zero
 90bc04c:	01d023f4 	movhi	r7,16527
 90bc050:	39d00004 	addi	r7,r7,16384
 90bc054:	908c5400 	call	908c540 <__adddf3>
 90bc058:	1009883a 	mov	r4,r2
 90bc05c:	180b883a 	mov	r5,r3
 90bc060:	2005883a 	mov	r2,r4
 90bc064:	2807883a 	mov	r3,r5
 90bc068:	8009883a 	mov	r4,r16
 90bc06c:	880b883a 	mov	r5,r17
 90bc070:	100d883a 	mov	r6,r2
 90bc074:	180f883a 	mov	r7,r3
 90bc078:	908ccd00 	call	908ccd0 <__gtdf2>
 90bc07c:	10800048 	cmpgei	r2,r2,1
 90bc080:	1000011e 	bne	r2,zero,90bc088 <inet_timer+0xe4>
 90bc084:	00001906 	br	90bc0ec <inet_timer+0x148>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 90bc088:	00824374 	movhi	r2,2317
 90bc08c:	108f2e04 	addi	r2,r2,15544
 90bc090:	11000017 	ldw	r4,0(r2)
 90bc094:	908d0380 	call	908d038 <__floatunsidf>
 90bc098:	100b883a 	mov	r5,r2
 90bc09c:	180d883a 	mov	r6,r3
 90bc0a0:	2809883a 	mov	r4,r5
 90bc0a4:	300b883a 	mov	r5,r6
 90bc0a8:	000d883a 	mov	r6,zero
 90bc0ac:	01d01674 	movhi	r7,16473
 90bc0b0:	908c5400 	call	908c540 <__adddf3>
 90bc0b4:	1009883a 	mov	r4,r2
 90bc0b8:	180b883a 	mov	r5,r3
 90bc0bc:	2005883a 	mov	r2,r4
 90bc0c0:	2807883a 	mov	r3,r5
 90bc0c4:	1009883a 	mov	r4,r2
 90bc0c8:	180b883a 	mov	r5,r3
 90bc0cc:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90bc0d0:	d0a0bd15 	stw	r2,-32012(gp)

      if (port_1s_callout != NULL)
 90bc0d4:	d0a0be17 	ldw	r2,-32008(gp)
 90bc0d8:	1005003a 	cmpeq	r2,r2,zero
 90bc0dc:	1000021e 	bne	r2,zero,90bc0e8 <inet_timer+0x144>
         (*port_1s_callout)();
 90bc0e0:	d0a0be17 	ldw	r2,-32008(gp)
 90bc0e4:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 90bc0e8:	90a87900 	call	90a8790 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 90bc0ec:	e037883a 	mov	sp,fp
 90bc0f0:	dfc00317 	ldw	ra,12(sp)
 90bc0f4:	df000217 	ldw	fp,8(sp)
 90bc0f8:	dc400117 	ldw	r17,4(sp)
 90bc0fc:	dc000017 	ldw	r16,0(sp)
 90bc100:	dec00404 	addi	sp,sp,16
 90bc104:	f800283a 	ret

090bc108 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 90bc108:	defffc04 	addi	sp,sp,-16
 90bc10c:	dfc00315 	stw	ra,12(sp)
 90bc110:	df000215 	stw	fp,8(sp)
 90bc114:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 90bc118:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 90bc11c:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc120:	10800050 	cmplti	r2,r2,1
 90bc124:	1000591e 	bne	r2,zero,90bc28c <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 90bc128:	e03fff15 	stw	zero,-4(fp)
 90bc12c:	00005406 	br	90bc280 <check_interval_timers+0x178>
      {
         if (intimers[i].callback)   /* is this timer active? */
 90bc130:	e0bfff17 	ldw	r2,-4(fp)
 90bc134:	00c243b4 	movhi	r3,2318
 90bc138:	18f7ce04 	addi	r3,r3,-8392
 90bc13c:	10800524 	muli	r2,r2,20
 90bc140:	10c5883a 	add	r2,r2,r3
 90bc144:	10800017 	ldw	r2,0(r2)
 90bc148:	1005003a 	cmpeq	r2,r2,zero
 90bc14c:	1000491e 	bne	r2,zero,90bc274 <check_interval_timers+0x16c>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 90bc150:	e0bfff17 	ldw	r2,-4(fp)
 90bc154:	00c243b4 	movhi	r3,2318
 90bc158:	18f7ce04 	addi	r3,r3,-8392
 90bc15c:	10800524 	muli	r2,r2,20
 90bc160:	10c5883a 	add	r2,r2,r3
 90bc164:	10800304 	addi	r2,r2,12
 90bc168:	10c00017 	ldw	r3,0(r2)
 90bc16c:	00824374 	movhi	r2,2317
 90bc170:	108f2e04 	addi	r2,r2,15544
 90bc174:	10800017 	ldw	r2,0(r2)
 90bc178:	1880382e 	bgeu	r3,r2,90bc25c <check_interval_timers+0x154>
 90bc17c:	e0bfff17 	ldw	r2,-4(fp)
 90bc180:	00c243b4 	movhi	r3,2318
 90bc184:	18f7ce04 	addi	r3,r3,-8392
 90bc188:	10800524 	muli	r2,r2,20
 90bc18c:	10c5883a 	add	r2,r2,r3
 90bc190:	10800404 	addi	r2,r2,16
 90bc194:	10800017 	ldw	r2,0(r2)
 90bc198:	1004c03a 	cmpne	r2,r2,zero
 90bc19c:	10002f1e 	bne	r2,zero,90bc25c <check_interval_timers+0x154>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 90bc1a0:	e17fff17 	ldw	r5,-4(fp)
 90bc1a4:	e0bfff17 	ldw	r2,-4(fp)
 90bc1a8:	00c243b4 	movhi	r3,2318
 90bc1ac:	18f7ce04 	addi	r3,r3,-8392
 90bc1b0:	10800524 	muli	r2,r2,20
 90bc1b4:	10c5883a 	add	r2,r2,r3
 90bc1b8:	10800204 	addi	r2,r2,8
 90bc1bc:	10c00017 	ldw	r3,0(r2)
 90bc1c0:	00824374 	movhi	r2,2317
 90bc1c4:	108f2e04 	addi	r2,r2,15544
 90bc1c8:	10800017 	ldw	r2,0(r2)
 90bc1cc:	1889883a 	add	r4,r3,r2
 90bc1d0:	00c243b4 	movhi	r3,2318
 90bc1d4:	18f7ce04 	addi	r3,r3,-8392
 90bc1d8:	28800524 	muli	r2,r5,20
 90bc1dc:	10c5883a 	add	r2,r2,r3
 90bc1e0:	10800304 	addi	r2,r2,12
 90bc1e4:	11000015 	stw	r4,0(r2)
               intimers[i].inuse = TRUE;
 90bc1e8:	e0bfff17 	ldw	r2,-4(fp)
 90bc1ec:	00c243b4 	movhi	r3,2318
 90bc1f0:	18f7ce04 	addi	r3,r3,-8392
 90bc1f4:	10800524 	muli	r2,r2,20
 90bc1f8:	10c5883a 	add	r2,r2,r3
 90bc1fc:	10c00404 	addi	r3,r2,16
 90bc200:	00800044 	movi	r2,1
 90bc204:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 90bc208:	e0bfff17 	ldw	r2,-4(fp)
 90bc20c:	00c243b4 	movhi	r3,2318
 90bc210:	18f7ce04 	addi	r3,r3,-8392
 90bc214:	10800524 	muli	r2,r2,20
 90bc218:	10c5883a 	add	r2,r2,r3
 90bc21c:	11400017 	ldw	r5,0(r2)
 90bc220:	e0bfff17 	ldw	r2,-4(fp)
 90bc224:	00c243b4 	movhi	r3,2318
 90bc228:	18f7ce04 	addi	r3,r3,-8392
 90bc22c:	10800524 	muli	r2,r2,20
 90bc230:	10c5883a 	add	r2,r2,r3
 90bc234:	10800104 	addi	r2,r2,4
 90bc238:	11000017 	ldw	r4,0(r2)
 90bc23c:	283ee83a 	callr	r5
               intimers[i].inuse = FALSE;
 90bc240:	e0bfff17 	ldw	r2,-4(fp)
 90bc244:	00c243b4 	movhi	r3,2318
 90bc248:	18f7ce04 	addi	r3,r3,-8392
 90bc24c:	10800524 	muli	r2,r2,20
 90bc250:	10c5883a 	add	r2,r2,r3
 90bc254:	10800404 	addi	r2,r2,16
 90bc258:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 90bc25c:	e0bffe17 	ldw	r2,-8(fp)
 90bc260:	10800044 	addi	r2,r2,1
 90bc264:	e0bffe15 	stw	r2,-8(fp)
 90bc268:	d0e0bf17 	ldw	r3,-32004(gp)
 90bc26c:	e0bffe17 	ldw	r2,-8(fp)
 90bc270:	10c0060e 	bge	r2,r3,90bc28c <check_interval_timers+0x184>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 90bc274:	e0bfff17 	ldw	r2,-4(fp)
 90bc278:	10800044 	addi	r2,r2,1
 90bc27c:	e0bfff15 	stw	r2,-4(fp)
 90bc280:	e0bfff17 	ldw	r2,-4(fp)
 90bc284:	10800150 	cmplti	r2,r2,5
 90bc288:	103fa91e 	bne	r2,zero,90bc130 <check_interval_timers+0x28>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 90bc28c:	e037883a 	mov	sp,fp
 90bc290:	dfc00117 	ldw	ra,4(sp)
 90bc294:	df000017 	ldw	fp,0(sp)
 90bc298:	dec00204 	addi	sp,sp,8
 90bc29c:	f800283a 	ret

090bc2a0 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 90bc2a0:	defff804 	addi	sp,sp,-32
 90bc2a4:	dfc00715 	stw	ra,28(sp)
 90bc2a8:	df000615 	stw	fp,24(sp)
 90bc2ac:	dc000515 	stw	r16,20(sp)
 90bc2b0:	df000504 	addi	fp,sp,20
 90bc2b4:	e13ffc15 	stw	r4,-16(fp)
 90bc2b8:	e17ffd15 	stw	r5,-12(fp)
 90bc2bc:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bc2c0:	e03ffb15 	stw	zero,-20(fp)
 90bc2c4:	00006006 	br	90bc448 <in_timerset+0x1a8>
   {
      if(intimers[i].callback == NULL)
 90bc2c8:	e0bffb17 	ldw	r2,-20(fp)
 90bc2cc:	00c243b4 	movhi	r3,2318
 90bc2d0:	18f7ce04 	addi	r3,r3,-8392
 90bc2d4:	10800524 	muli	r2,r2,20
 90bc2d8:	10c5883a 	add	r2,r2,r3
 90bc2dc:	10800017 	ldw	r2,0(r2)
 90bc2e0:	1004c03a 	cmpne	r2,r2,zero
 90bc2e4:	1000551e 	bne	r2,zero,90bc43c <in_timerset+0x19c>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 90bc2e8:	e0bffb17 	ldw	r2,-20(fp)
 90bc2ec:	00c243b4 	movhi	r3,2318
 90bc2f0:	18f7ce04 	addi	r3,r3,-8392
 90bc2f4:	10800524 	muli	r2,r2,20
 90bc2f8:	10c7883a 	add	r3,r2,r3
 90bc2fc:	e0bffc17 	ldw	r2,-16(fp)
 90bc300:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 90bc304:	e0bffb17 	ldw	r2,-20(fp)
 90bc308:	00c243b4 	movhi	r3,2318
 90bc30c:	18f7ce04 	addi	r3,r3,-8392
 90bc310:	10800524 	muli	r2,r2,20
 90bc314:	10c5883a 	add	r2,r2,r3
 90bc318:	10c00104 	addi	r3,r2,4
 90bc31c:	e0bffe17 	ldw	r2,-8(fp)
 90bc320:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 90bc324:	e43ffb17 	ldw	r16,-20(fp)
 90bc328:	e13ffd17 	ldw	r4,-12(fp)
 90bc32c:	908ce680 	call	908ce68 <__floatsidf>
 90bc330:	100b883a 	mov	r5,r2
 90bc334:	180d883a 	mov	r6,r3
 90bc338:	2809883a 	mov	r4,r5
 90bc33c:	300b883a 	mov	r5,r6
 90bc340:	000d883a 	mov	r6,zero
 90bc344:	01d01674 	movhi	r7,16473
 90bc348:	908c5b40 	call	908c5b4 <__muldf3>
 90bc34c:	1009883a 	mov	r4,r2
 90bc350:	180b883a 	mov	r5,r3
 90bc354:	2005883a 	mov	r2,r4
 90bc358:	2807883a 	mov	r3,r5
 90bc35c:	1009883a 	mov	r4,r2
 90bc360:	180b883a 	mov	r5,r3
 90bc364:	000d883a 	mov	r6,zero
 90bc368:	01d023f4 	movhi	r7,16527
 90bc36c:	39d00004 	addi	r7,r7,16384
 90bc370:	908c9680 	call	908c968 <__divdf3>
 90bc374:	1009883a 	mov	r4,r2
 90bc378:	180b883a 	mov	r5,r3
 90bc37c:	2005883a 	mov	r2,r4
 90bc380:	2807883a 	mov	r3,r5
 90bc384:	1009883a 	mov	r4,r2
 90bc388:	180b883a 	mov	r5,r3
 90bc38c:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90bc390:	1009883a 	mov	r4,r2
 90bc394:	00c243b4 	movhi	r3,2318
 90bc398:	18f7ce04 	addi	r3,r3,-8392
 90bc39c:	80800524 	muli	r2,r16,20
 90bc3a0:	10c5883a 	add	r2,r2,r3
 90bc3a4:	10800204 	addi	r2,r2,8
 90bc3a8:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 90bc3ac:	e17ffb17 	ldw	r5,-20(fp)
 90bc3b0:	e0bffb17 	ldw	r2,-20(fp)
 90bc3b4:	00c243b4 	movhi	r3,2318
 90bc3b8:	18f7ce04 	addi	r3,r3,-8392
 90bc3bc:	10800524 	muli	r2,r2,20
 90bc3c0:	10c5883a 	add	r2,r2,r3
 90bc3c4:	10800204 	addi	r2,r2,8
 90bc3c8:	10c00017 	ldw	r3,0(r2)
 90bc3cc:	00824374 	movhi	r2,2317
 90bc3d0:	108f2e04 	addi	r2,r2,15544
 90bc3d4:	10800017 	ldw	r2,0(r2)
 90bc3d8:	1889883a 	add	r4,r3,r2
 90bc3dc:	00c243b4 	movhi	r3,2318
 90bc3e0:	18f7ce04 	addi	r3,r3,-8392
 90bc3e4:	28800524 	muli	r2,r5,20
 90bc3e8:	10c5883a 	add	r2,r2,r3
 90bc3ec:	10800304 	addi	r2,r2,12
 90bc3f0:	11000015 	stw	r4,0(r2)
		 intimers[i].inuse = FALSE;
 90bc3f4:	e0bffb17 	ldw	r2,-20(fp)
 90bc3f8:	00c243b4 	movhi	r3,2318
 90bc3fc:	18f7ce04 	addi	r3,r3,-8392
 90bc400:	10800524 	muli	r2,r2,20
 90bc404:	10c5883a 	add	r2,r2,r3
 90bc408:	10800404 	addi	r2,r2,16
 90bc40c:	10000015 	stw	zero,0(r2)
         numtimers++;
 90bc410:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc414:	10800044 	addi	r2,r2,1
 90bc418:	d0a0bf15 	stw	r2,-32004(gp)
         return (long)&intimers[i];
 90bc41c:	e0bffb17 	ldw	r2,-20(fp)
 90bc420:	10800524 	muli	r2,r2,20
 90bc424:	1007883a 	mov	r3,r2
 90bc428:	008243b4 	movhi	r2,2318
 90bc42c:	10b7ce04 	addi	r2,r2,-8392
 90bc430:	1885883a 	add	r2,r3,r2
 90bc434:	e0bfff15 	stw	r2,-4(fp)
 90bc438:	00000706 	br	90bc458 <in_timerset+0x1b8>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bc43c:	e0bffb17 	ldw	r2,-20(fp)
 90bc440:	10800044 	addi	r2,r2,1
 90bc444:	e0bffb15 	stw	r2,-20(fp)
 90bc448:	e0bffb17 	ldw	r2,-20(fp)
 90bc44c:	10800150 	cmplti	r2,r2,5
 90bc450:	103f9d1e 	bne	r2,zero,90bc2c8 <in_timerset+0x28>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 90bc454:	e03fff15 	stw	zero,-4(fp)
 90bc458:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc45c:	e037883a 	mov	sp,fp
 90bc460:	dfc00217 	ldw	ra,8(sp)
 90bc464:	df000117 	ldw	fp,4(sp)
 90bc468:	dc000017 	ldw	r16,0(sp)
 90bc46c:	dec00304 	addi	sp,sp,12
 90bc470:	f800283a 	ret

090bc474 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 90bc474:	defffb04 	addi	sp,sp,-20
 90bc478:	dfc00415 	stw	ra,16(sp)
 90bc47c:	df000315 	stw	fp,12(sp)
 90bc480:	df000304 	addi	fp,sp,12
 90bc484:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bc488:	e03ffd15 	stw	zero,-12(fp)
 90bc48c:	00001706 	br	90bc4ec <in_timerkill+0x78>
   {
      if(timer == (long)&intimers[i])
 90bc490:	e0bffd17 	ldw	r2,-12(fp)
 90bc494:	10800524 	muli	r2,r2,20
 90bc498:	1007883a 	mov	r3,r2
 90bc49c:	008243b4 	movhi	r2,2318
 90bc4a0:	10b7ce04 	addi	r2,r2,-8392
 90bc4a4:	1885883a 	add	r2,r3,r2
 90bc4a8:	1007883a 	mov	r3,r2
 90bc4ac:	e0bffe17 	ldw	r2,-8(fp)
 90bc4b0:	18800b1e 	bne	r3,r2,90bc4e0 <in_timerkill+0x6c>
      {
         intimers[i].callback = NULL;
 90bc4b4:	e0bffd17 	ldw	r2,-12(fp)
 90bc4b8:	00c243b4 	movhi	r3,2318
 90bc4bc:	18f7ce04 	addi	r3,r3,-8392
 90bc4c0:	10800524 	muli	r2,r2,20
 90bc4c4:	10c5883a 	add	r2,r2,r3
 90bc4c8:	10000015 	stw	zero,0(r2)
         numtimers--;
 90bc4cc:	d0a0bf17 	ldw	r2,-32004(gp)
 90bc4d0:	10bfffc4 	addi	r2,r2,-1
 90bc4d4:	d0a0bf15 	stw	r2,-32004(gp)
         return 0;      /* OK return */
 90bc4d8:	e03fff15 	stw	zero,-4(fp)
 90bc4dc:	00000906 	br	90bc504 <in_timerkill+0x90>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 90bc4e0:	e0bffd17 	ldw	r2,-12(fp)
 90bc4e4:	10800044 	addi	r2,r2,1
 90bc4e8:	e0bffd15 	stw	r2,-12(fp)
 90bc4ec:	e0bffd17 	ldw	r2,-12(fp)
 90bc4f0:	10800150 	cmplti	r2,r2,5
 90bc4f4:	103fe61e 	bne	r2,zero,90bc490 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 90bc4f8:	90aa4780 	call	90aa478 <dtrap>
   return ENP_PARAM;
 90bc4fc:	00bffd84 	movi	r2,-10
 90bc500:	e0bfff15 	stw	r2,-4(fp)
 90bc504:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc508:	e037883a 	mov	sp,fp
 90bc50c:	dfc00117 	ldw	ra,4(sp)
 90bc510:	df000017 	ldw	fp,0(sp)
 90bc514:	dec00204 	addi	sp,sp,8
 90bc518:	f800283a 	ret

090bc51c <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 90bc51c:	defffe04 	addi	sp,sp,-8
 90bc520:	df000115 	stw	fp,4(sp)
 90bc524:	df000104 	addi	fp,sp,4
int e = 0;
 90bc528:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 90bc52c:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc530:	e037883a 	mov	sp,fp
 90bc534:	df000017 	ldw	fp,0(sp)
 90bc538:	dec00104 	addi	sp,sp,4
 90bc53c:	f800283a 	ret

090bc540 <task_stats>:
 */


void
task_stats(void * pio)
{
 90bc540:	defffd04 	addi	sp,sp,-12
 90bc544:	dfc00215 	stw	ra,8(sp)
 90bc548:	df000115 	stw	fp,4(sp)
 90bc54c:	df000104 	addi	fp,sp,4
 90bc550:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 90bc554:	e13fff17 	ldw	r4,-4(fp)
 90bc558:	01424374 	movhi	r5,2317
 90bc55c:	29430904 	addi	r5,r5,3108
 90bc560:	90a55a40 	call	90a55a4 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 90bc564:	00824374 	movhi	r2,2317
 90bc568:	108f1004 	addi	r2,r2,15424
 90bc56c:	11800017 	ldw	r6,0(r2)
 90bc570:	e13fff17 	ldw	r4,-4(fp)
 90bc574:	01424374 	movhi	r5,2317
 90bc578:	29430d04 	addi	r5,r5,3124
 90bc57c:	90a55a40 	call	90a55a4 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 90bc580:	00824374 	movhi	r2,2317
 90bc584:	108f1104 	addi	r2,r2,15428
 90bc588:	11800017 	ldw	r6,0(r2)
 90bc58c:	e13fff17 	ldw	r4,-4(fp)
 90bc590:	01424374 	movhi	r5,2317
 90bc594:	29431104 	addi	r5,r5,3140
 90bc598:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 90bc59c:	e13fff17 	ldw	r4,-4(fp)
 90bc5a0:	01424374 	movhi	r5,2317
 90bc5a4:	29431504 	addi	r5,r5,3156
 90bc5a8:	90a55a40 	call	90a55a4 <ns_printf>
}
 90bc5ac:	e037883a 	mov	sp,fp
 90bc5b0:	dfc00117 	ldw	ra,4(sp)
 90bc5b4:	df000017 	ldw	fp,0(sp)
 90bc5b8:	dec00204 	addi	sp,sp,8
 90bc5bc:	f800283a 	ret

090bc5c0 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 90bc5c0:	defff704 	addi	sp,sp,-36
 90bc5c4:	dfc00615 	stw	ra,24(sp)
 90bc5c8:	df000515 	stw	fp,20(sp)
 90bc5cc:	df000504 	addi	fp,sp,20
 90bc5d0:	e13ffd15 	stw	r4,-12(fp)
 90bc5d4:	e1800215 	stw	r6,8(fp)
 90bc5d8:	e1c00315 	stw	r7,12(fp)
 90bc5dc:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 90bc5e0:	e0bffd17 	ldw	r2,-12(fp)
 90bc5e4:	10800808 	cmpgei	r2,r2,32
 90bc5e8:	10000e1e 	bne	r2,zero,90bc624 <fcntl+0x64>
  {
    va_start(argp, cmd);
 90bc5ec:	e0800204 	addi	r2,fp,8
 90bc5f0:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 90bc5f4:	e0fffc17 	ldw	r3,-16(fp)
 90bc5f8:	18800104 	addi	r2,r3,4
 90bc5fc:	e0bffc15 	stw	r2,-16(fp)
 90bc600:	1805883a 	mov	r2,r3
 90bc604:	10800017 	ldw	r2,0(r2)
 90bc608:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 90bc60c:	e13ffd17 	ldw	r4,-12(fp)
 90bc610:	e17ffe17 	ldw	r5,-8(fp)
 90bc614:	e1bffb17 	ldw	r6,-20(fp)
 90bc618:	90c9cec0 	call	90c9cec <alt_fcntl>
 90bc61c:	e0bfff15 	stw	r2,-4(fp)
 90bc620:	00000d06 	br	90bc658 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 90bc624:	e0800204 	addi	r2,fp,8
 90bc628:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 90bc62c:	e0fffc17 	ldw	r3,-16(fp)
 90bc630:	18800104 	addi	r2,r3,4
 90bc634:	e0bffc15 	stw	r2,-16(fp)
 90bc638:	1805883a 	mov	r2,r3
 90bc63c:	10800017 	ldw	r2,0(r2)
 90bc640:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 90bc644:	e17ffe17 	ldw	r5,-8(fp)
 90bc648:	e13ffd17 	ldw	r4,-12(fp)
 90bc64c:	e1bffb17 	ldw	r6,-20(fp)
 90bc650:	90a48f80 	call	90a48f8 <bsd_ioctl>
 90bc654:	e0bfff15 	stw	r2,-4(fp)
 90bc658:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 90bc65c:	e037883a 	mov	sp,fp
 90bc660:	dfc00117 	ldw	ra,4(sp)
 90bc664:	df000017 	ldw	fp,0(sp)
 90bc668:	dec00404 	addi	sp,sp,16
 90bc66c:	f800283a 	ret

090bc670 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 90bc670:	defffd04 	addi	sp,sp,-12
 90bc674:	dfc00215 	stw	ra,8(sp)
 90bc678:	df000115 	stw	fp,4(sp)
 90bc67c:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 90bc680:	01018204 	movi	r4,1544
 90bc684:	90bdd700 	call	90bdd70 <reg_type>
 90bc688:	1005003a 	cmpeq	r2,r2,zero
 90bc68c:	1000061e 	bne	r2,zero,90bc6a8 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 90bc690:	01024374 	movhi	r4,2317
 90bc694:	21031604 	addi	r4,r4,3160
 90bc698:	90836b80 	call	90836b8 <puts>
#endif
      return (1);
 90bc69c:	00800044 	movi	r2,1
 90bc6a0:	e0bfff15 	stw	r2,-4(fp)
 90bc6a4:	00000106 	br	90bc6ac <etainit+0x3c>
   }
   return (0);
 90bc6a8:	e03fff15 	stw	zero,-4(fp)
 90bc6ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90bc6b0:	e037883a 	mov	sp,fp
 90bc6b4:	dfc00117 	ldw	ra,4(sp)
 90bc6b8:	df000017 	ldw	fp,0(sp)
 90bc6bc:	dec00204 	addi	sp,sp,8
 90bc6c0:	f800283a 	ret

090bc6c4 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 90bc6c4:	defff904 	addi	sp,sp,-28
 90bc6c8:	dfc00615 	stw	ra,24(sp)
 90bc6cc:	df000515 	stw	fp,20(sp)
 90bc6d0:	df000504 	addi	fp,sp,20
 90bc6d4:	e13ffe15 	stw	r4,-8(fp)
 90bc6d8:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 90bc6dc:	e0bffe17 	ldw	r2,-8(fp)
 90bc6e0:	10800617 	ldw	r2,24(r2)
 90bc6e4:	10802717 	ldw	r2,156(r2)
 90bc6e8:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 90bc6ec:	00824374 	movhi	r2,2317
 90bc6f0:	108f2e04 	addi	r2,r2,15544
 90bc6f4:	10c00017 	ldw	r3,0(r2)
 90bc6f8:	e0bfff17 	ldw	r2,-4(fp)
 90bc6fc:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 90bc700:	e0bffe17 	ldw	r2,-8(fp)
 90bc704:	10800317 	ldw	r2,12(r2)
 90bc708:	10fffc04 	addi	r3,r2,-16
 90bc70c:	e0bffe17 	ldw	r2,-8(fp)
 90bc710:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 90bc714:	e0bffe17 	ldw	r2,-8(fp)
 90bc718:	10800417 	ldw	r2,16(r2)
 90bc71c:	10c00404 	addi	r3,r2,16
 90bc720:	e0bffe17 	ldw	r2,-8(fp)
 90bc724:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 90bc728:	e0bffe17 	ldw	r2,-8(fp)
 90bc72c:	10800317 	ldw	r2,12(r2)
 90bc730:	10800084 	addi	r2,r2,2
 90bc734:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 90bc738:	e0bffe17 	ldw	r2,-8(fp)
 90bc73c:	10c00117 	ldw	r3,4(r2)
 90bc740:	e0bffd17 	ldw	r2,-12(fp)
 90bc744:	10c0032e 	bgeu	r2,r3,90bc754 <et_send+0x90>
      panic("et_send: prepend");
 90bc748:	01024374 	movhi	r4,2317
 90bc74c:	21032204 	addi	r4,r4,3208
 90bc750:	90a537c0 	call	90a537c <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 90bc754:	e0bfff17 	ldw	r2,-4(fp)
 90bc758:	11400104 	addi	r5,r2,4
 90bc75c:	e13ffd17 	ldw	r4,-12(fp)
 90bc760:	01800184 	movi	r6,6
 90bc764:	90895000 	call	9089500 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 90bc768:	e0bffd17 	ldw	r2,-12(fp)
 90bc76c:	11000184 	addi	r4,r2,6
 90bc770:	e0bffc17 	ldw	r2,-16(fp)
 90bc774:	11400517 	ldw	r5,20(r2)
 90bc778:	01800184 	movi	r6,6
 90bc77c:	90895000 	call	9089500 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 90bc780:	e0bfff17 	ldw	r2,-4(fp)
 90bc784:	1080070b 	ldhu	r2,28(r2)
 90bc788:	10bfffcc 	andi	r2,r2,65535
 90bc78c:	108000cc 	andi	r2,r2,3
 90bc790:	108000a0 	cmpeqi	r2,r2,2
 90bc794:	1000041e 	bne	r2,zero,90bc7a8 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 90bc798:	e0bffd17 	ldw	r2,-12(fp)
 90bc79c:	10c00304 	addi	r3,r2,12
 90bc7a0:	00800204 	movi	r2,8
 90bc7a4:	18800005 	stb	r2,0(r3)
 90bc7a8:	e0bffd17 	ldw	r2,-12(fp)
 90bc7ac:	10800344 	addi	r2,r2,13
 90bc7b0:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 90bc7b4:	e0bffe17 	ldw	r2,-8(fp)
 90bc7b8:	10800617 	ldw	r2,24(r2)
 90bc7bc:	10800417 	ldw	r2,16(r2)
 90bc7c0:	1005003a 	cmpeq	r2,r2,zero
 90bc7c4:	1000071e 	bne	r2,zero,90bc7e4 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 90bc7c8:	e0bffe17 	ldw	r2,-8(fp)
 90bc7cc:	10800617 	ldw	r2,24(r2)
 90bc7d0:	10800417 	ldw	r2,16(r2)
 90bc7d4:	e13ffe17 	ldw	r4,-8(fp)
 90bc7d8:	103ee83a 	callr	r2
 90bc7dc:	e0bffb15 	stw	r2,-20(fp)
 90bc7e0:	00001106 	br	90bc828 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 90bc7e4:	e0bffe17 	ldw	r2,-8(fp)
 90bc7e8:	10800617 	ldw	r2,24(r2)
 90bc7ec:	10c00317 	ldw	r3,12(r2)
 90bc7f0:	e0bffe17 	ldw	r2,-8(fp)
 90bc7f4:	11000617 	ldw	r4,24(r2)
 90bc7f8:	e0bffe17 	ldw	r2,-8(fp)
 90bc7fc:	11400317 	ldw	r5,12(r2)
 90bc800:	e0bffe17 	ldw	r2,-8(fp)
 90bc804:	11800417 	ldw	r6,16(r2)
 90bc808:	183ee83a 	callr	r3
 90bc80c:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc810:	01000084 	movi	r4,2
 90bc814:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bc818:	e13ffe17 	ldw	r4,-8(fp)
 90bc81c:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc820:	01000084 	movi	r4,2
 90bc824:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 90bc828:	e0bffb17 	ldw	r2,-20(fp)
}
 90bc82c:	e037883a 	mov	sp,fp
 90bc830:	dfc00117 	ldw	ra,4(sp)
 90bc834:	df000017 	ldw	fp,0(sp)
 90bc838:	dec00204 	addi	sp,sp,8
 90bc83c:	f800283a 	ret

090bc840 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 90bc840:	defffb04 	addi	sp,sp,-20
 90bc844:	dfc00415 	stw	ra,16(sp)
 90bc848:	df000315 	stw	fp,12(sp)
 90bc84c:	df000304 	addi	fp,sp,12
 90bc850:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 90bc854:	e0bfff17 	ldw	r2,-4(fp)
 90bc858:	10800417 	ldw	r2,16(r2)
 90bc85c:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 90bc860:	e0bfff17 	ldw	r2,-4(fp)
 90bc864:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bc868:	01000084 	movi	r4,2
 90bc86c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 90bc870:	00000906 	br	90bc898 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 90bc874:	e0bffe17 	ldw	r2,-8(fp)
 90bc878:	10800017 	ldw	r2,0(r2)
 90bc87c:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 90bc880:	e0bffe17 	ldw	r2,-8(fp)
 90bc884:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 90bc888:	e13ffe17 	ldw	r4,-8(fp)
 90bc88c:	90a9bc80 	call	90a9bc8 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 90bc890:	e0bffd17 	ldw	r2,-12(fp)
 90bc894:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 90bc898:	e0bffe17 	ldw	r2,-8(fp)
 90bc89c:	1004c03a 	cmpne	r2,r2,zero
 90bc8a0:	103ff41e 	bne	r2,zero,90bc874 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 90bc8a4:	e0bfff17 	ldw	r2,-4(fp)
 90bc8a8:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bc8ac:	01000084 	movi	r4,2
 90bc8b0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
}
 90bc8b4:	e037883a 	mov	sp,fp
 90bc8b8:	dfc00117 	ldw	ra,4(sp)
 90bc8bc:	df000017 	ldw	fp,0(sp)
 90bc8c0:	dec00204 	addi	sp,sp,8
 90bc8c4:	f800283a 	ret

090bc8c8 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 90bc8c8:	defffc04 	addi	sp,sp,-16
 90bc8cc:	dfc00315 	stw	ra,12(sp)
 90bc8d0:	df000215 	stw	fp,8(sp)
 90bc8d4:	df000204 	addi	fp,sp,8
 90bc8d8:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 90bc8dc:	e0bfff17 	ldw	r2,-4(fp)
 90bc8e0:	10800417 	ldw	r2,16(r2)
 90bc8e4:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 90bc8e8:	00000906 	br	90bc910 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 90bc8ec:	e0bffe17 	ldw	r2,-8(fp)
 90bc8f0:	10c00017 	ldw	r3,0(r2)
 90bc8f4:	e0bfff17 	ldw	r2,-4(fp)
 90bc8f8:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 90bc8fc:	e0bffe17 	ldw	r2,-8(fp)
 90bc900:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 90bc904:	e13ffe17 	ldw	r4,-8(fp)
 90bc908:	e17fff17 	ldw	r5,-4(fp)
 90bc90c:	90bc6c40 	call	90bc6c4 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 90bc910:	e0bfff17 	ldw	r2,-4(fp)
 90bc914:	10800417 	ldw	r2,16(r2)
 90bc918:	e0bffe15 	stw	r2,-8(fp)
 90bc91c:	e0bffe17 	ldw	r2,-8(fp)
 90bc920:	1004c03a 	cmpne	r2,r2,zero
 90bc924:	103ff11e 	bne	r2,zero,90bc8ec <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 90bc928:	e037883a 	mov	sp,fp
 90bc92c:	dfc00117 	ldw	ra,4(sp)
 90bc930:	df000017 	ldw	fp,0(sp)
 90bc934:	dec00204 	addi	sp,sp,8
 90bc938:	f800283a 	ret

090bc93c <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 90bc93c:	defff304 	addi	sp,sp,-52
 90bc940:	dfc00c15 	stw	ra,48(sp)
 90bc944:	df000b15 	stw	fp,44(sp)
 90bc948:	df000b04 	addi	fp,sp,44
 90bc94c:	e13ffd15 	stw	r4,-12(fp)
 90bc950:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 90bc954:	e0bffd17 	ldw	r2,-12(fp)
 90bc958:	10800617 	ldw	r2,24(r2)
 90bc95c:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 90bc960:	e0bffd17 	ldw	r2,-12(fp)
 90bc964:	10800617 	ldw	r2,24(r2)
 90bc968:	10802717 	ldw	r2,156(r2)
 90bc96c:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 90bc970:	e0bffe17 	ldw	r2,-8(fp)
 90bc974:	10bfffe0 	cmpeqi	r2,r2,-1
 90bc978:	10001b1e 	bne	r2,zero,90bc9e8 <send_arp+0xac>
 90bc97c:	e0bff917 	ldw	r2,-28(fp)
 90bc980:	10800c17 	ldw	r2,48(r2)
 90bc984:	0086303a 	nor	r3,zero,r2
 90bc988:	e0bffe17 	ldw	r2,-8(fp)
 90bc98c:	1886703a 	and	r3,r3,r2
 90bc990:	e0bff917 	ldw	r2,-28(fp)
 90bc994:	10800c17 	ldw	r2,48(r2)
 90bc998:	0084303a 	nor	r2,zero,r2
 90bc99c:	18801226 	beq	r3,r2,90bc9e8 <send_arp+0xac>
 90bc9a0:	e0bffe17 	ldw	r2,-8(fp)
 90bc9a4:	1004d63a 	srli	r2,r2,24
 90bc9a8:	10c03fcc 	andi	r3,r2,255
 90bc9ac:	e0bffe17 	ldw	r2,-8(fp)
 90bc9b0:	1004d23a 	srli	r2,r2,8
 90bc9b4:	10bfc00c 	andi	r2,r2,65280
 90bc9b8:	1886b03a 	or	r3,r3,r2
 90bc9bc:	e0bffe17 	ldw	r2,-8(fp)
 90bc9c0:	10bfc00c 	andi	r2,r2,65280
 90bc9c4:	1004923a 	slli	r2,r2,8
 90bc9c8:	1886b03a 	or	r3,r3,r2
 90bc9cc:	e0bffe17 	ldw	r2,-8(fp)
 90bc9d0:	10803fcc 	andi	r2,r2,255
 90bc9d4:	1004963a 	slli	r2,r2,24
 90bc9d8:	1884b03a 	or	r2,r3,r2
 90bc9dc:	10fc002c 	andhi	r3,r2,61440
 90bc9e0:	00b80034 	movhi	r2,57344
 90bc9e4:	1880441e 	bne	r3,r2,90bcaf8 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 90bc9e8:	e0bffd17 	ldw	r2,-12(fp)
 90bc9ec:	11400617 	ldw	r5,24(r2)
 90bc9f0:	e13ffe17 	ldw	r4,-8(fp)
 90bc9f4:	90bcfc80 	call	90bcfc8 <make_arp_entry>
 90bc9f8:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 90bc9fc:	e0bffb17 	ldw	r2,-20(fp)
 90bca00:	10c00104 	addi	r3,r2,4
 90bca04:	00bfffc4 	movi	r2,-1
 90bca08:	18800005 	stb	r2,0(r3)
 90bca0c:	00bfffc4 	movi	r2,-1
 90bca10:	18800045 	stb	r2,1(r3)
 90bca14:	00bfffc4 	movi	r2,-1
 90bca18:	18800085 	stb	r2,2(r3)
 90bca1c:	00bfffc4 	movi	r2,-1
 90bca20:	188000c5 	stb	r2,3(r3)
 90bca24:	00bfffc4 	movi	r2,-1
 90bca28:	18800105 	stb	r2,4(r3)
 90bca2c:	00bfffc4 	movi	r2,-1
 90bca30:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 90bca34:	e0bffd17 	ldw	r2,-12(fp)
 90bca38:	10800617 	ldw	r2,24(r2)
 90bca3c:	10802b17 	ldw	r2,172(r2)
 90bca40:	1005003a 	cmpeq	r2,r2,zero
 90bca44:	1000271e 	bne	r2,zero,90bcae4 <send_arp+0x1a8>
 90bca48:	e0bffe17 	ldw	r2,-8(fp)
 90bca4c:	1004d63a 	srli	r2,r2,24
 90bca50:	10c03fcc 	andi	r3,r2,255
 90bca54:	e0bffe17 	ldw	r2,-8(fp)
 90bca58:	1004d23a 	srli	r2,r2,8
 90bca5c:	10bfc00c 	andi	r2,r2,65280
 90bca60:	1886b03a 	or	r3,r3,r2
 90bca64:	e0bffe17 	ldw	r2,-8(fp)
 90bca68:	10bfc00c 	andi	r2,r2,65280
 90bca6c:	1004923a 	slli	r2,r2,8
 90bca70:	1886b03a 	or	r3,r3,r2
 90bca74:	e0bffe17 	ldw	r2,-8(fp)
 90bca78:	10803fcc 	andi	r2,r2,255
 90bca7c:	1004963a 	slli	r2,r2,24
 90bca80:	1884b03a 	or	r2,r3,r2
 90bca84:	10fc002c 	andhi	r3,r2,61440
 90bca88:	00b80034 	movhi	r2,57344
 90bca8c:	1880151e 	bne	r3,r2,90bcae4 <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 90bca90:	e0bffe17 	ldw	r2,-8(fp)
 90bca94:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 90bca98:	e0fffb17 	ldw	r3,-20(fp)
 90bca9c:	00800044 	movi	r2,1
 90bcaa0:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 90bcaa4:	e0bffb17 	ldw	r2,-20(fp)
 90bcaa8:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 90bcaac:	e0fffb17 	ldw	r3,-20(fp)
 90bcab0:	00801784 	movi	r2,94
 90bcab4:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 90bcab8:	e0bffc43 	ldbu	r2,-15(fp)
 90bcabc:	10801fcc 	andi	r2,r2,127
 90bcac0:	1007883a 	mov	r3,r2
 90bcac4:	e0bffb17 	ldw	r2,-20(fp)
 90bcac8:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 90bcacc:	e0fffc83 	ldbu	r3,-14(fp)
 90bcad0:	e0bffb17 	ldw	r2,-20(fp)
 90bcad4:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 90bcad8:	e0fffcc3 	ldbu	r3,-13(fp)
 90bcadc:	e0bffb17 	ldw	r2,-20(fp)
 90bcae0:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 90bcae4:	e13ffd17 	ldw	r4,-12(fp)
 90bcae8:	e17ffb17 	ldw	r5,-20(fp)
 90bcaec:	90bc6c40 	call	90bc6c4 <et_send>
 90bcaf0:	e0bfff15 	stw	r2,-4(fp)
 90bcaf4:	0000b106 	br	90bcdbc <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 90bcaf8:	e0bffd17 	ldw	r2,-12(fp)
 90bcafc:	10c00717 	ldw	r3,28(r2)
 90bcb00:	e0bffd17 	ldw	r2,-12(fp)
 90bcb04:	10800617 	ldw	r2,24(r2)
 90bcb08:	10800a17 	ldw	r2,40(r2)
 90bcb0c:	18800e1e 	bne	r3,r2,90bcb48 <send_arp+0x20c>
 90bcb10:	e0bffd17 	ldw	r2,-12(fp)
 90bcb14:	10800717 	ldw	r2,28(r2)
 90bcb18:	10803fcc 	andi	r2,r2,255
 90bcb1c:	10801fe0 	cmpeqi	r2,r2,127
 90bcb20:	1000091e 	bne	r2,zero,90bcb48 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bcb24:	01000084 	movi	r4,2
 90bcb28:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bcb2c:	e13ffd17 	ldw	r4,-12(fp)
 90bcb30:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bcb34:	01000084 	movi	r4,2
 90bcb38:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 90bcb3c:	00bff7c4 	movi	r2,-33
 90bcb40:	e0bfff15 	stw	r2,-4(fp)
 90bcb44:	00009d06 	br	90bcdbc <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 90bcb48:	01000084 	movi	r4,2
 90bcb4c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 90bcb50:	01000c04 	movi	r4,48
 90bcb54:	90a98340 	call	90a9834 <pk_alloc>
 90bcb58:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 90bcb5c:	e0bff617 	ldw	r2,-40(fp)
 90bcb60:	1004c03a 	cmpne	r2,r2,zero
 90bcb64:	1000071e 	bne	r2,zero,90bcb84 <send_arp+0x248>
   {
      pk_free(pkt);
 90bcb68:	e13ffd17 	ldw	r4,-12(fp)
 90bcb6c:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bcb70:	01000084 	movi	r4,2
 90bcb74:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 90bcb78:	00bffa84 	movi	r2,-22
 90bcb7c:	e0bfff15 	stw	r2,-4(fp)
 90bcb80:	00008e06 	br	90bcdbc <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bcb84:	01000084 	movi	r4,2
 90bcb88:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 90bcb8c:	e0bff617 	ldw	r2,-40(fp)
 90bcb90:	10c00117 	ldw	r3,4(r2)
 90bcb94:	e0bff617 	ldw	r2,-40(fp)
 90bcb98:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 90bcb9c:	e0fff617 	ldw	r3,-40(fp)
 90bcba0:	00800c04 	movi	r2,48
 90bcba4:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 90bcba8:	e0bffd17 	ldw	r2,-12(fp)
 90bcbac:	10c00617 	ldw	r3,24(r2)
 90bcbb0:	e0bff617 	ldw	r2,-40(fp)
 90bcbb4:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 90bcbb8:	e0bffd17 	ldw	r2,-12(fp)
 90bcbbc:	11400617 	ldw	r5,24(r2)
 90bcbc0:	e13ffe17 	ldw	r4,-8(fp)
 90bcbc4:	90bcfc80 	call	90bcfc8 <make_arp_entry>
 90bcbc8:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 90bcbcc:	e0fffb17 	ldw	r3,-20(fp)
 90bcbd0:	e0bffd17 	ldw	r2,-12(fp)
 90bcbd4:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 90bcbd8:	e0bff617 	ldw	r2,-40(fp)
 90bcbdc:	10800117 	ldw	r2,4(r2)
 90bcbe0:	10800084 	addi	r2,r2,2
 90bcbe4:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 90bcbe8:	e0bff617 	ldw	r2,-40(fp)
 90bcbec:	10800117 	ldw	r2,4(r2)
 90bcbf0:	10800404 	addi	r2,r2,16
 90bcbf4:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bcbf8:	e0fff817 	ldw	r3,-32(fp)
 90bcbfc:	00804004 	movi	r2,256
 90bcc00:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 90bcc04:	e0fff817 	ldw	r3,-32(fp)
 90bcc08:	00800204 	movi	r2,8
 90bcc0c:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 90bcc10:	e0fff817 	ldw	r3,-32(fp)
 90bcc14:	00800184 	movi	r2,6
 90bcc18:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 90bcc1c:	e0fff817 	ldw	r3,-32(fp)
 90bcc20:	00800104 	movi	r2,4
 90bcc24:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 90bcc28:	e0fff817 	ldw	r3,-32(fp)
 90bcc2c:	00804004 	movi	r2,256
 90bcc30:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 90bcc34:	e0fff817 	ldw	r3,-32(fp)
 90bcc38:	e0bffe17 	ldw	r2,-8(fp)
 90bcc3c:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 90bcc40:	e0bffd17 	ldw	r2,-12(fp)
 90bcc44:	10800617 	ldw	r2,24(r2)
 90bcc48:	10c00a17 	ldw	r3,40(r2)
 90bcc4c:	e0bff817 	ldw	r2,-32(fp)
 90bcc50:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 90bcc54:	e0bff817 	ldw	r2,-32(fp)
 90bcc58:	11000204 	addi	r4,r2,8
 90bcc5c:	e0bff717 	ldw	r2,-36(fp)
 90bcc60:	11400517 	ldw	r5,20(r2)
 90bcc64:	01800184 	movi	r6,6
 90bcc68:	90895000 	call	9089500 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 90bcc6c:	e0fffa17 	ldw	r3,-24(fp)
 90bcc70:	00bfffc4 	movi	r2,-1
 90bcc74:	18800005 	stb	r2,0(r3)
 90bcc78:	00bfffc4 	movi	r2,-1
 90bcc7c:	18800045 	stb	r2,1(r3)
 90bcc80:	00bfffc4 	movi	r2,-1
 90bcc84:	18800085 	stb	r2,2(r3)
 90bcc88:	00bfffc4 	movi	r2,-1
 90bcc8c:	188000c5 	stb	r2,3(r3)
 90bcc90:	00bfffc4 	movi	r2,-1
 90bcc94:	18800105 	stb	r2,4(r3)
 90bcc98:	00bfffc4 	movi	r2,-1
 90bcc9c:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 90bcca0:	e0bffa17 	ldw	r2,-24(fp)
 90bcca4:	11000184 	addi	r4,r2,6
 90bcca8:	e0bff717 	ldw	r2,-36(fp)
 90bccac:	11400517 	ldw	r5,20(r2)
 90bccb0:	01800184 	movi	r6,6
 90bccb4:	90895000 	call	9089500 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 90bccb8:	e0bffa17 	ldw	r2,-24(fp)
 90bccbc:	10c00304 	addi	r3,r2,12
 90bccc0:	00800204 	movi	r2,8
 90bccc4:	18800005 	stb	r2,0(r3)
 90bccc8:	e0bffa17 	ldw	r2,-24(fp)
 90bcccc:	10c00344 	addi	r3,r2,13
 90bccd0:	00800184 	movi	r2,6
 90bccd4:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bccd8:	e0bff817 	ldw	r2,-32(fp)
 90bccdc:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 90bcce0:	e0bff517 	ldw	r2,-44(fp)
 90bcce4:	11000204 	addi	r4,r2,8
 90bcce8:	e0bff817 	ldw	r2,-32(fp)
 90bccec:	11400204 	addi	r5,r2,8
 90bccf0:	01800184 	movi	r6,6
 90bccf4:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 90bccf8:	e0bff517 	ldw	r2,-44(fp)
 90bccfc:	10800204 	addi	r2,r2,8
 90bcd00:	11000184 	addi	r4,r2,6
 90bcd04:	e0bff817 	ldw	r2,-32(fp)
 90bcd08:	11400404 	addi	r5,r2,16
 90bcd0c:	01800104 	movi	r6,4
 90bcd10:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 90bcd14:	e0bff517 	ldw	r2,-44(fp)
 90bcd18:	10800204 	addi	r2,r2,8
 90bcd1c:	11000284 	addi	r4,r2,10
 90bcd20:	e0bff817 	ldw	r2,-32(fp)
 90bcd24:	11400504 	addi	r5,r2,20
 90bcd28:	01800184 	movi	r6,6
 90bcd2c:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 90bcd30:	e0bff517 	ldw	r2,-44(fp)
 90bcd34:	10800204 	addi	r2,r2,8
 90bcd38:	11000404 	addi	r4,r2,16
 90bcd3c:	e0bff817 	ldw	r2,-32(fp)
 90bcd40:	11400704 	addi	r5,r2,28
 90bcd44:	01800104 	movi	r6,4
 90bcd48:	90895000 	call	9089500 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 90bcd4c:	e0bff917 	ldw	r2,-28(fp)
 90bcd50:	10800417 	ldw	r2,16(r2)
 90bcd54:	1005003a 	cmpeq	r2,r2,zero
 90bcd58:	1000051e 	bne	r2,zero,90bcd70 <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 90bcd5c:	e0bff917 	ldw	r2,-28(fp)
 90bcd60:	10800417 	ldw	r2,16(r2)
 90bcd64:	e13ff617 	ldw	r4,-40(fp)
 90bcd68:	103ee83a 	callr	r2
 90bcd6c:	00000e06 	br	90bcda8 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 90bcd70:	e0bff917 	ldw	r2,-28(fp)
 90bcd74:	10c00317 	ldw	r3,12(r2)
 90bcd78:	e0bff617 	ldw	r2,-40(fp)
 90bcd7c:	11000617 	ldw	r4,24(r2)
 90bcd80:	e0bff617 	ldw	r2,-40(fp)
 90bcd84:	11400117 	ldw	r5,4(r2)
 90bcd88:	01800c04 	movi	r6,48
 90bcd8c:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bcd90:	01000084 	movi	r4,2
 90bcd94:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 90bcd98:	e13ff617 	ldw	r4,-40(fp)
 90bcd9c:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bcda0:	01000084 	movi	r4,2
 90bcda4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 90bcda8:	d0a0c317 	ldw	r2,-31988(gp)
 90bcdac:	10800044 	addi	r2,r2,1
 90bcdb0:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 90bcdb4:	00800044 	movi	r2,1
 90bcdb8:	e0bfff15 	stw	r2,-4(fp)
 90bcdbc:	e0bfff17 	ldw	r2,-4(fp)
}
 90bcdc0:	e037883a 	mov	sp,fp
 90bcdc4:	dfc00117 	ldw	ra,4(sp)
 90bcdc8:	df000017 	ldw	fp,0(sp)
 90bcdcc:	dec00204 	addi	sp,sp,8
 90bcdd0:	f800283a 	ret

090bcdd4 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 90bcdd4:	defff604 	addi	sp,sp,-40
 90bcdd8:	dfc00915 	stw	ra,36(sp)
 90bcddc:	df000815 	stw	fp,32(sp)
 90bcde0:	df000804 	addi	fp,sp,32
 90bcde4:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 90bcde8:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 90bcdec:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 90bcdf0:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 90bcdf4:	00824374 	movhi	r2,2317
 90bcdf8:	108f2e04 	addi	r2,r2,15544
 90bcdfc:	10800017 	ldw	r2,0(r2)
 90bce00:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bce04:	008243b4 	movhi	r2,2318
 90bce08:	10b7e704 	addi	r2,r2,-8292
 90bce0c:	e0bffc15 	stw	r2,-16(fp)
 90bce10:	00005306 	br	90bcf60 <find_oldest_arp+0x18c>
   {
      /* age out old, pending entries */
      if (tp->pending)
 90bce14:	e0bffc17 	ldw	r2,-16(fp)
 90bce18:	10800417 	ldw	r2,16(r2)
 90bce1c:	1005003a 	cmpeq	r2,r2,zero
 90bce20:	1000141e 	bne	r2,zero,90bce74 <find_oldest_arp+0xa0>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 90bce24:	e0bffc17 	ldw	r2,-16(fp)
 90bce28:	10c00517 	ldw	r3,20(r2)
 90bce2c:	e0bff817 	ldw	r2,-32(fp)
 90bce30:	10c9c83a 	sub	r4,r2,r3
 90bce34:	908d0380 	call	908d038 <__floatunsidf>
 90bce38:	100b883a 	mov	r5,r2
 90bce3c:	180d883a 	mov	r6,r3
 90bce40:	2809883a 	mov	r4,r5
 90bce44:	300b883a 	mov	r5,r6
 90bce48:	000d883a 	mov	r6,zero
 90bce4c:	01d01674 	movhi	r7,16473
 90bce50:	908ccd00 	call	908ccd0 <__gtdf2>
 90bce54:	10800048 	cmpgei	r2,r2,1
 90bce58:	1000011e 	bne	r2,zero,90bce60 <find_oldest_arp+0x8c>
 90bce5c:	00002206 	br	90bcee8 <find_oldest_arp+0x114>
         {
            arp_free_pending(tp);   /* free pending packets */
 90bce60:	e13ffc17 	ldw	r4,-16(fp)
 90bce64:	90bc8400 	call	90bc840 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bce68:	e0bffc17 	ldw	r2,-16(fp)
 90bce6c:	10000015 	stw	zero,0(r2)
 90bce70:	00001d06 	br	90bcee8 <find_oldest_arp+0x114>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 90bce74:	e0bffc17 	ldw	r2,-16(fp)
 90bce78:	10800017 	ldw	r2,0(r2)
 90bce7c:	1005003a 	cmpeq	r2,r2,zero
 90bce80:	1000191e 	bne	r2,zero,90bcee8 <find_oldest_arp+0x114>
 90bce84:	e0bffc17 	ldw	r2,-16(fp)
 90bce88:	10c00517 	ldw	r3,20(r2)
 90bce8c:	e0bff817 	ldw	r2,-32(fp)
 90bce90:	10c5c83a 	sub	r2,r2,r3
 90bce94:	1007883a 	mov	r3,r2
 90bce98:	d0a04f17 	ldw	r2,-32452(gp)
 90bce9c:	18801216 	blt	r3,r2,90bcee8 <find_oldest_arp+0x114>
 90bcea0:	e0bffc17 	ldw	r2,-16(fp)
 90bcea4:	10c00617 	ldw	r3,24(r2)
 90bcea8:	e0bff817 	ldw	r2,-32(fp)
 90bceac:	10c5c83a 	sub	r2,r2,r3
 90bceb0:	1009883a 	mov	r4,r2
 90bceb4:	908ce680 	call	908ce68 <__floatsidf>
 90bceb8:	100b883a 	mov	r5,r2
 90bcebc:	180d883a 	mov	r6,r3
 90bcec0:	2809883a 	mov	r4,r5
 90bcec4:	300b883a 	mov	r5,r6
 90bcec8:	000d883a 	mov	r6,zero
 90bcecc:	01d01674 	movhi	r7,16473
 90bced0:	908cd580 	call	908cd58 <__gedf2>
 90bced4:	1004403a 	cmpge	r2,r2,zero
 90bced8:	1000011e 	bne	r2,zero,90bcee0 <find_oldest_arp+0x10c>
 90bcedc:	00000206 	br	90bcee8 <find_oldest_arp+0x114>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bcee0:	e0bffc17 	ldw	r2,-16(fp)
 90bcee4:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 90bcee8:	e0bffc17 	ldw	r2,-16(fp)
 90bceec:	10c00017 	ldw	r3,0(r2)
 90bcef0:	e0bffd17 	ldw	r2,-12(fp)
 90bcef4:	1880031e 	bne	r3,r2,90bcf04 <find_oldest_arp+0x130>
      {
         exact = tp;
 90bcef8:	e0bffc17 	ldw	r2,-16(fp)
 90bcefc:	e0bffb15 	stw	r2,-20(fp)
 90bcf00:	00001406 	br	90bcf54 <find_oldest_arp+0x180>
      }
      else if (tp->t_pro_addr != 0)
 90bcf04:	e0bffc17 	ldw	r2,-16(fp)
 90bcf08:	10800017 	ldw	r2,0(r2)
 90bcf0c:	1005003a 	cmpeq	r2,r2,zero
 90bcf10:	10000b1e 	bne	r2,zero,90bcf40 <find_oldest_arp+0x16c>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 90bcf14:	e0bffa17 	ldw	r2,-24(fp)
 90bcf18:	1005003a 	cmpeq	r2,r2,zero
 90bcf1c:	1000051e 	bne	r2,zero,90bcf34 <find_oldest_arp+0x160>
 90bcf20:	e0bffc17 	ldw	r2,-16(fp)
 90bcf24:	10c00617 	ldw	r3,24(r2)
 90bcf28:	e0bffa17 	ldw	r2,-24(fp)
 90bcf2c:	10800617 	ldw	r2,24(r2)
 90bcf30:	1880082e 	bgeu	r3,r2,90bcf54 <find_oldest_arp+0x180>
            oldest = tp;
 90bcf34:	e0bffc17 	ldw	r2,-16(fp)
 90bcf38:	e0bffa15 	stw	r2,-24(fp)
 90bcf3c:	00000506 	br	90bcf54 <find_oldest_arp+0x180>
      }
      else if (!empty)
 90bcf40:	e0bff917 	ldw	r2,-28(fp)
 90bcf44:	1004c03a 	cmpne	r2,r2,zero
 90bcf48:	1000021e 	bne	r2,zero,90bcf54 <find_oldest_arp+0x180>
         empty = tp;          /* grab first empty slot */
 90bcf4c:	e0bffc17 	ldw	r2,-16(fp)
 90bcf50:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bcf54:	e0bffc17 	ldw	r2,-16(fp)
 90bcf58:	10800804 	addi	r2,r2,32
 90bcf5c:	e0bffc15 	stw	r2,-16(fp)
 90bcf60:	00c243b4 	movhi	r3,2318
 90bcf64:	18f82704 	addi	r3,r3,-8036
 90bcf68:	e0bffc17 	ldw	r2,-16(fp)
 90bcf6c:	10ffa936 	bltu	r2,r3,90bce14 <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 90bcf70:	e0bffb17 	ldw	r2,-20(fp)
 90bcf74:	1004c03a 	cmpne	r2,r2,zero
 90bcf78:	10000b1e 	bne	r2,zero,90bcfa8 <find_oldest_arp+0x1d4>
 90bcf7c:	e0bff917 	ldw	r2,-28(fp)
 90bcf80:	1005003a 	cmpeq	r2,r2,zero
 90bcf84:	1000031e 	bne	r2,zero,90bcf94 <find_oldest_arp+0x1c0>
 90bcf88:	e0bff917 	ldw	r2,-28(fp)
 90bcf8c:	e0bffe15 	stw	r2,-8(fp)
 90bcf90:	00000206 	br	90bcf9c <find_oldest_arp+0x1c8>
 90bcf94:	e0bffa17 	ldw	r2,-24(fp)
 90bcf98:	e0bffe15 	stw	r2,-8(fp)
 90bcf9c:	e0bffe17 	ldw	r2,-8(fp)
 90bcfa0:	e0bfff15 	stw	r2,-4(fp)
 90bcfa4:	00000206 	br	90bcfb0 <find_oldest_arp+0x1dc>
 90bcfa8:	e0bffb17 	ldw	r2,-20(fp)
 90bcfac:	e0bfff15 	stw	r2,-4(fp)
 90bcfb0:	e0bfff17 	ldw	r2,-4(fp)
}
 90bcfb4:	e037883a 	mov	sp,fp
 90bcfb8:	dfc00117 	ldw	ra,4(sp)
 90bcfbc:	df000017 	ldw	fp,0(sp)
 90bcfc0:	dec00204 	addi	sp,sp,8
 90bcfc4:	f800283a 	ret

090bcfc8 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 90bcfc8:	defffa04 	addi	sp,sp,-24
 90bcfcc:	dfc00515 	stw	ra,20(sp)
 90bcfd0:	df000415 	stw	fp,16(sp)
 90bcfd4:	df000404 	addi	fp,sp,16
 90bcfd8:	e13ffe15 	stw	r4,-8(fp)
 90bcfdc:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 90bcfe0:	00824374 	movhi	r2,2317
 90bcfe4:	108f2e04 	addi	r2,r2,15544
 90bcfe8:	10800017 	ldw	r2,0(r2)
 90bcfec:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 90bcff0:	e13ffe17 	ldw	r4,-8(fp)
 90bcff4:	90bcdd40 	call	90bcdd4 <find_oldest_arp>
 90bcff8:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 90bcffc:	e0bffd17 	ldw	r2,-12(fp)
 90bd000:	10800417 	ldw	r2,16(r2)
 90bd004:	1005003a 	cmpeq	r2,r2,zero
 90bd008:	1000061e 	bne	r2,zero,90bd024 <make_arp_entry+0x5c>
 90bd00c:	e0bffd17 	ldw	r2,-12(fp)
 90bd010:	10c00017 	ldw	r3,0(r2)
 90bd014:	e0bffe17 	ldw	r2,-8(fp)
 90bd018:	18800226 	beq	r3,r2,90bd024 <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 90bd01c:	e13ffd17 	ldw	r4,-12(fp)
 90bd020:	90bc8400 	call	90bc840 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 90bd024:	e0fffd17 	ldw	r3,-12(fp)
 90bd028:	e0bffe17 	ldw	r2,-8(fp)
 90bd02c:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 90bd030:	e0fffd17 	ldw	r3,-12(fp)
 90bd034:	e0bfff17 	ldw	r2,-4(fp)
 90bd038:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 90bd03c:	e0bffd17 	ldw	r2,-12(fp)
 90bd040:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 90bd044:	e0bffd17 	ldw	r2,-12(fp)
 90bd048:	10800104 	addi	r2,r2,4
 90bd04c:	10000005 	stb	zero,0(r2)
 90bd050:	10000045 	stb	zero,1(r2)
 90bd054:	10000085 	stb	zero,2(r2)
 90bd058:	100000c5 	stb	zero,3(r2)
 90bd05c:	10000105 	stb	zero,4(r2)
 90bd060:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 90bd064:	e0fffd17 	ldw	r3,-12(fp)
 90bd068:	e0bffc17 	ldw	r2,-16(fp)
 90bd06c:	18800615 	stw	r2,24(r3)
 90bd070:	e0bffd17 	ldw	r2,-12(fp)
 90bd074:	10c00617 	ldw	r3,24(r2)
 90bd078:	e0bffd17 	ldw	r2,-12(fp)
 90bd07c:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 90bd080:	d0a0c017 	ldw	r2,-32000(gp)
 90bd084:	1004c03a 	cmpne	r2,r2,zero
 90bd088:	1000071e 	bne	r2,zero,90bd0a8 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 90bd08c:	01024334 	movhi	r4,2316
 90bd090:	2135e704 	addi	r4,r4,-10340
 90bd094:	0149c404 	movi	r5,10000
 90bd098:	000d883a 	mov	r6,zero
 90bd09c:	90bc2a00 	call	90bc2a0 <in_timerset>
 90bd0a0:	d0a0c015 	stw	r2,-32000(gp)
 90bd0a4:	00000706 	br	90bd0c4 <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 90bd0a8:	d0a0c017 	ldw	r2,-32000(gp)
 90bd0ac:	1009883a 	mov	r4,r2
 90bd0b0:	d0a0c017 	ldw	r2,-32000(gp)
 90bd0b4:	10c00217 	ldw	r3,8(r2)
 90bd0b8:	e0bffc17 	ldw	r2,-16(fp)
 90bd0bc:	1885883a 	add	r2,r3,r2
 90bd0c0:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 90bd0c4:	e0bffd17 	ldw	r2,-12(fp)
}
 90bd0c8:	e037883a 	mov	sp,fp
 90bd0cc:	dfc00117 	ldw	ra,4(sp)
 90bd0d0:	df000017 	ldw	fp,0(sp)
 90bd0d4:	dec00204 	addi	sp,sp,8
 90bd0d8:	f800283a 	ret

090bd0dc <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 90bd0dc:	defff704 	addi	sp,sp,-36
 90bd0e0:	dfc00815 	stw	ra,32(sp)
 90bd0e4:	df000715 	stw	fp,28(sp)
 90bd0e8:	df000704 	addi	fp,sp,28
 90bd0ec:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd0f0:	01000084 	movi	r4,2
 90bd0f4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 90bd0f8:	01000c04 	movi	r4,48
 90bd0fc:	90a98340 	call	90a9834 <pk_alloc>
 90bd100:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd104:	01000084 	movi	r4,2
 90bd108:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 90bd10c:	e0bffe17 	ldw	r2,-8(fp)
 90bd110:	1004c03a 	cmpne	r2,r2,zero
 90bd114:	1000021e 	bne	r2,zero,90bd120 <arpReply+0x44>
   {
      dtrap();
 90bd118:	90aa4780 	call	90aa478 <dtrap>
      return;
 90bd11c:	00008f06 	br	90bd35c <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 90bd120:	e0bfff17 	ldw	r2,-4(fp)
 90bd124:	10c00617 	ldw	r3,24(r2)
 90bd128:	e0bffe17 	ldw	r2,-8(fp)
 90bd12c:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 90bd130:	e0bfff17 	ldw	r2,-4(fp)
 90bd134:	10800317 	ldw	r2,12(r2)
 90bd138:	10bffc84 	addi	r2,r2,-14
 90bd13c:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 90bd140:	e0bffe17 	ldw	r2,-8(fp)
 90bd144:	10800117 	ldw	r2,4(r2)
 90bd148:	10800084 	addi	r2,r2,2
 90bd14c:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 90bd150:	e0bffb17 	ldw	r2,-20(fp)
 90bd154:	10c00304 	addi	r3,r2,12
 90bd158:	00800204 	movi	r2,8
 90bd15c:	18800005 	stb	r2,0(r3)
 90bd160:	e0bffb17 	ldw	r2,-20(fp)
 90bd164:	10c00344 	addi	r3,r2,13
 90bd168:	00800184 	movi	r2,6
 90bd16c:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 90bd170:	e0bfff17 	ldw	r2,-4(fp)
 90bd174:	10800317 	ldw	r2,12(r2)
 90bd178:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 90bd17c:	e0bffe17 	ldw	r2,-8(fp)
 90bd180:	10800117 	ldw	r2,4(r2)
 90bd184:	10800404 	addi	r2,r2,16
 90bd188:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 90bd18c:	e0fffe17 	ldw	r3,-8(fp)
 90bd190:	00800c04 	movi	r2,48
 90bd194:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bd198:	e0fffc17 	ldw	r3,-16(fp)
 90bd19c:	00804004 	movi	r2,256
 90bd1a0:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 90bd1a4:	e0fffc17 	ldw	r3,-16(fp)
 90bd1a8:	00800204 	movi	r2,8
 90bd1ac:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 90bd1b0:	e0fffc17 	ldw	r3,-16(fp)
 90bd1b4:	00800184 	movi	r2,6
 90bd1b8:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 90bd1bc:	e0fffc17 	ldw	r3,-16(fp)
 90bd1c0:	00800104 	movi	r2,4
 90bd1c4:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 90bd1c8:	e0fffc17 	ldw	r3,-16(fp)
 90bd1cc:	00808004 	movi	r2,512
 90bd1d0:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 90bd1d4:	e0bffd17 	ldw	r2,-12(fp)
 90bd1d8:	10c00417 	ldw	r3,16(r2)
 90bd1dc:	e0bffc17 	ldw	r2,-16(fp)
 90bd1e0:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 90bd1e4:	e0bffd17 	ldw	r2,-12(fp)
 90bd1e8:	10c00717 	ldw	r3,28(r2)
 90bd1ec:	e0bffc17 	ldw	r2,-16(fp)
 90bd1f0:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 90bd1f4:	e0bffc17 	ldw	r2,-16(fp)
 90bd1f8:	11000504 	addi	r4,r2,20
 90bd1fc:	e0bffd17 	ldw	r2,-12(fp)
 90bd200:	11400204 	addi	r5,r2,8
 90bd204:	01800184 	movi	r6,6
 90bd208:	90895000 	call	9089500 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 90bd20c:	e0bffc17 	ldw	r2,-16(fp)
 90bd210:	11000204 	addi	r4,r2,8
 90bd214:	e0bffe17 	ldw	r2,-8(fp)
 90bd218:	10800617 	ldw	r2,24(r2)
 90bd21c:	10802717 	ldw	r2,156(r2)
 90bd220:	11400517 	ldw	r5,20(r2)
 90bd224:	01800184 	movi	r6,6
 90bd228:	90895000 	call	9089500 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 90bd22c:	e0bffa17 	ldw	r2,-24(fp)
 90bd230:	11400184 	addi	r5,r2,6
 90bd234:	e13ffb17 	ldw	r4,-20(fp)
 90bd238:	01800184 	movi	r6,6
 90bd23c:	90895000 	call	9089500 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 90bd240:	e0bffb17 	ldw	r2,-20(fp)
 90bd244:	11000184 	addi	r4,r2,6
 90bd248:	e0bffe17 	ldw	r2,-8(fp)
 90bd24c:	10800617 	ldw	r2,24(r2)
 90bd250:	10802717 	ldw	r2,156(r2)
 90bd254:	11400517 	ldw	r5,20(r2)
 90bd258:	01800184 	movi	r6,6
 90bd25c:	90895000 	call	9089500 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 90bd260:	e0bffc17 	ldw	r2,-16(fp)
 90bd264:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 90bd268:	e0bff917 	ldw	r2,-28(fp)
 90bd26c:	11000204 	addi	r4,r2,8
 90bd270:	e0bffc17 	ldw	r2,-16(fp)
 90bd274:	11400204 	addi	r5,r2,8
 90bd278:	01800184 	movi	r6,6
 90bd27c:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 90bd280:	e0bff917 	ldw	r2,-28(fp)
 90bd284:	10800204 	addi	r2,r2,8
 90bd288:	11000184 	addi	r4,r2,6
 90bd28c:	e0bffc17 	ldw	r2,-16(fp)
 90bd290:	11400404 	addi	r5,r2,16
 90bd294:	01800104 	movi	r6,4
 90bd298:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 90bd29c:	e0bff917 	ldw	r2,-28(fp)
 90bd2a0:	10800204 	addi	r2,r2,8
 90bd2a4:	11000284 	addi	r4,r2,10
 90bd2a8:	e0bffc17 	ldw	r2,-16(fp)
 90bd2ac:	11400504 	addi	r5,r2,20
 90bd2b0:	01800184 	movi	r6,6
 90bd2b4:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 90bd2b8:	e0bff917 	ldw	r2,-28(fp)
 90bd2bc:	10800204 	addi	r2,r2,8
 90bd2c0:	11000404 	addi	r4,r2,16
 90bd2c4:	e0bffc17 	ldw	r2,-16(fp)
 90bd2c8:	11400704 	addi	r5,r2,28
 90bd2cc:	01800104 	movi	r6,4
 90bd2d0:	90895000 	call	9089500 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 90bd2d4:	e0bffe17 	ldw	r2,-8(fp)
 90bd2d8:	10800617 	ldw	r2,24(r2)
 90bd2dc:	10800417 	ldw	r2,16(r2)
 90bd2e0:	1005003a 	cmpeq	r2,r2,zero
 90bd2e4:	10000a1e 	bne	r2,zero,90bd310 <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 90bd2e8:	e0bffe17 	ldw	r2,-8(fp)
 90bd2ec:	10c00117 	ldw	r3,4(r2)
 90bd2f0:	e0bffe17 	ldw	r2,-8(fp)
 90bd2f4:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 90bd2f8:	e0bffe17 	ldw	r2,-8(fp)
 90bd2fc:	10800617 	ldw	r2,24(r2)
 90bd300:	10800417 	ldw	r2,16(r2)
 90bd304:	e13ffe17 	ldw	r4,-8(fp)
 90bd308:	103ee83a 	callr	r2
 90bd30c:	00001006 	br	90bd350 <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 90bd310:	e0bffe17 	ldw	r2,-8(fp)
 90bd314:	10800617 	ldw	r2,24(r2)
 90bd318:	10c00317 	ldw	r3,12(r2)
 90bd31c:	e0bfff17 	ldw	r2,-4(fp)
 90bd320:	11000617 	ldw	r4,24(r2)
 90bd324:	e0bffe17 	ldw	r2,-8(fp)
 90bd328:	11400117 	ldw	r5,4(r2)
 90bd32c:	e0bffe17 	ldw	r2,-8(fp)
 90bd330:	11800417 	ldw	r6,16(r2)
 90bd334:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd338:	01000084 	movi	r4,2
 90bd33c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 90bd340:	e13ffe17 	ldw	r4,-8(fp)
 90bd344:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd348:	01000084 	movi	r4,2
 90bd34c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 90bd350:	d0a0c517 	ldw	r2,-31980(gp)
 90bd354:	10800044 	addi	r2,r2,1
 90bd358:	d0a0c515 	stw	r2,-31980(gp)
}
 90bd35c:	e037883a 	mov	sp,fp
 90bd360:	dfc00117 	ldw	ra,4(sp)
 90bd364:	df000017 	ldw	fp,0(sp)
 90bd368:	dec00204 	addi	sp,sp,8
 90bd36c:	f800283a 	ret

090bd370 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 90bd370:	defff804 	addi	sp,sp,-32
 90bd374:	dfc00715 	stw	ra,28(sp)
 90bd378:	df000615 	stw	fp,24(sp)
 90bd37c:	df000604 	addi	fp,sp,24
 90bd380:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 90bd384:	e0bffe17 	ldw	r2,-8(fp)
 90bd388:	10800317 	ldw	r2,12(r2)
 90bd38c:	10bffc84 	addi	r2,r2,-14
 90bd390:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 90bd394:	e0bffe17 	ldw	r2,-8(fp)
 90bd398:	10800317 	ldw	r2,12(r2)
 90bd39c:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bd3a0:	e0bffd17 	ldw	r2,-12(fp)
 90bd3a4:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 90bd3a8:	e0bffd17 	ldw	r2,-12(fp)
 90bd3ac:	11000704 	addi	r4,r2,28
 90bd3b0:	e0bffa17 	ldw	r2,-24(fp)
 90bd3b4:	10800204 	addi	r2,r2,8
 90bd3b8:	11400404 	addi	r5,r2,16
 90bd3bc:	01800104 	movi	r6,4
 90bd3c0:	90895000 	call	9089500 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 90bd3c4:	e0bffd17 	ldw	r2,-12(fp)
 90bd3c8:	11000504 	addi	r4,r2,20
 90bd3cc:	e0bffa17 	ldw	r2,-24(fp)
 90bd3d0:	10800204 	addi	r2,r2,8
 90bd3d4:	11400284 	addi	r5,r2,10
 90bd3d8:	01800184 	movi	r6,6
 90bd3dc:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 90bd3e0:	e0bffd17 	ldw	r2,-12(fp)
 90bd3e4:	11000404 	addi	r4,r2,16
 90bd3e8:	e0bffa17 	ldw	r2,-24(fp)
 90bd3ec:	10800204 	addi	r2,r2,8
 90bd3f0:	11400184 	addi	r5,r2,6
 90bd3f4:	01800104 	movi	r6,4
 90bd3f8:	90895000 	call	9089500 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 90bd3fc:	e0bffd17 	ldw	r2,-12(fp)
 90bd400:	11000204 	addi	r4,r2,8
 90bd404:	e0bffa17 	ldw	r2,-24(fp)
 90bd408:	11400204 	addi	r5,r2,8
 90bd40c:	01800184 	movi	r6,6
 90bd410:	90895000 	call	9089500 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 90bd414:	e0bffd17 	ldw	r2,-12(fp)
 90bd418:	10c00717 	ldw	r3,28(r2)
 90bd41c:	e0bffe17 	ldw	r2,-8(fp)
 90bd420:	10800617 	ldw	r2,24(r2)
 90bd424:	10800a17 	ldw	r2,40(r2)
 90bd428:	18801f26 	beq	r3,r2,90bd4a8 <arprcv+0x138>
 90bd42c:	e0bffd17 	ldw	r2,-12(fp)
 90bd430:	10800717 	ldw	r2,28(r2)
 90bd434:	1004d63a 	srli	r2,r2,24
 90bd438:	10c03fcc 	andi	r3,r2,255
 90bd43c:	e0bffd17 	ldw	r2,-12(fp)
 90bd440:	10800717 	ldw	r2,28(r2)
 90bd444:	1004d23a 	srli	r2,r2,8
 90bd448:	10bfc00c 	andi	r2,r2,65280
 90bd44c:	1886b03a 	or	r3,r3,r2
 90bd450:	e0bffd17 	ldw	r2,-12(fp)
 90bd454:	10800717 	ldw	r2,28(r2)
 90bd458:	10bfc00c 	andi	r2,r2,65280
 90bd45c:	1004923a 	slli	r2,r2,8
 90bd460:	1886b03a 	or	r3,r3,r2
 90bd464:	e0bffd17 	ldw	r2,-12(fp)
 90bd468:	10800717 	ldw	r2,28(r2)
 90bd46c:	10803fcc 	andi	r2,r2,255
 90bd470:	1004963a 	slli	r2,r2,24
 90bd474:	1884b03a 	or	r2,r3,r2
 90bd478:	10fc002c 	andhi	r3,r2,61440
 90bd47c:	00b80034 	movhi	r2,57344
 90bd480:	18800926 	beq	r3,r2,90bd4a8 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd484:	01000084 	movi	r4,2
 90bd488:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 90bd48c:	e13ffe17 	ldw	r4,-8(fp)
 90bd490:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd494:	01000084 	movi	r4,2
 90bd498:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 90bd49c:	00800084 	movi	r2,2
 90bd4a0:	e0bfff15 	stw	r2,-4(fp)
 90bd4a4:	00004406 	br	90bd5b8 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 90bd4a8:	e0bffd17 	ldw	r2,-12(fp)
 90bd4ac:	1080018b 	ldhu	r2,6(r2)
 90bd4b0:	10bfffcc 	andi	r2,r2,65535
 90bd4b4:	10804018 	cmpnei	r2,r2,256
 90bd4b8:	10000b1e 	bne	r2,zero,90bd4e8 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 90bd4bc:	d0a0c217 	ldw	r2,-31992(gp)
 90bd4c0:	10800044 	addi	r2,r2,1
 90bd4c4:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 90bd4c8:	e13ffe17 	ldw	r4,-8(fp)
 90bd4cc:	90bd0dc0 	call	90bd0dc <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 90bd4d0:	e0bffd17 	ldw	r2,-12(fp)
 90bd4d4:	11000417 	ldw	r4,16(r2)
 90bd4d8:	e0bffe17 	ldw	r2,-8(fp)
 90bd4dc:	11400617 	ldw	r5,24(r2)
 90bd4e0:	90bcfc80 	call	90bcfc8 <make_arp_entry>
 90bd4e4:	00000306 	br	90bd4f4 <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 90bd4e8:	d0a0c417 	ldw	r2,-31984(gp)
 90bd4ec:	10800044 	addi	r2,r2,1
 90bd4f0:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bd4f4:	008243b4 	movhi	r2,2318
 90bd4f8:	10b7e704 	addi	r2,r2,-8292
 90bd4fc:	e0bffc15 	stw	r2,-16(fp)
 90bd500:	00002106 	br	90bd588 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 90bd504:	e0bffc17 	ldw	r2,-16(fp)
 90bd508:	10c00017 	ldw	r3,0(r2)
 90bd50c:	e0bffd17 	ldw	r2,-12(fp)
 90bd510:	10800417 	ldw	r2,16(r2)
 90bd514:	1880191e 	bne	r3,r2,90bd57c <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 90bd518:	e0bffc17 	ldw	r2,-16(fp)
 90bd51c:	11000104 	addi	r4,r2,4
 90bd520:	e0bffd17 	ldw	r2,-12(fp)
 90bd524:	11400204 	addi	r5,r2,8
 90bd528:	01800184 	movi	r6,6
 90bd52c:	90895000 	call	9089500 <memmove>
         tp->lasttime = cticks;
 90bd530:	00824374 	movhi	r2,2317
 90bd534:	108f2e04 	addi	r2,r2,15544
 90bd538:	10c00017 	ldw	r3,0(r2)
 90bd53c:	e0bffc17 	ldw	r2,-16(fp)
 90bd540:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 90bd544:	e0bffc17 	ldw	r2,-16(fp)
 90bd548:	10800417 	ldw	r2,16(r2)
 90bd54c:	1005003a 	cmpeq	r2,r2,zero
 90bd550:	1000021e 	bne	r2,zero,90bd55c <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 90bd554:	e13ffc17 	ldw	r4,-16(fp)
 90bd558:	90bc8c80 	call	90bc8c8 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd55c:	01000084 	movi	r4,2
 90bd560:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 90bd564:	e13ffe17 	ldw	r4,-8(fp)
 90bd568:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd56c:	01000084 	movi	r4,2
 90bd570:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

         return (0);
 90bd574:	e03fff15 	stw	zero,-4(fp)
 90bd578:	00000f06 	br	90bd5b8 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bd57c:	e0bffc17 	ldw	r2,-16(fp)
 90bd580:	10800804 	addi	r2,r2,32
 90bd584:	e0bffc15 	stw	r2,-16(fp)
 90bd588:	00c243b4 	movhi	r3,2318
 90bd58c:	18f82704 	addi	r3,r3,-8036
 90bd590:	e0bffc17 	ldw	r2,-16(fp)
 90bd594:	10ffdb36 	bltu	r2,r3,90bd504 <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd598:	01000084 	movi	r4,2
 90bd59c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 90bd5a0:	e13ffe17 	ldw	r4,-8(fp)
 90bd5a4:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd5a8:	01000084 	movi	r4,2
 90bd5ac:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 90bd5b0:	00800084 	movi	r2,2
 90bd5b4:	e0bfff15 	stw	r2,-4(fp)
 90bd5b8:	e0bfff17 	ldw	r2,-4(fp)
}
 90bd5bc:	e037883a 	mov	sp,fp
 90bd5c0:	dfc00117 	ldw	ra,4(sp)
 90bd5c4:	df000017 	ldw	fp,0(sp)
 90bd5c8:	dec00204 	addi	sp,sp,8
 90bd5cc:	f800283a 	ret

090bd5d0 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 90bd5d0:	defff704 	addi	sp,sp,-36
 90bd5d4:	dfc00815 	stw	ra,32(sp)
 90bd5d8:	df000715 	stw	fp,28(sp)
 90bd5dc:	df000704 	addi	fp,sp,28
 90bd5e0:	e13ffd15 	stw	r4,-12(fp)
 90bd5e4:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 90bd5e8:	00824374 	movhi	r2,2317
 90bd5ec:	108f2e04 	addi	r2,r2,15544
 90bd5f0:	10800017 	ldw	r2,0(r2)
 90bd5f4:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 90bd5f8:	e0bffe17 	ldw	r2,-8(fp)
 90bd5fc:	1004c03a 	cmpne	r2,r2,zero
 90bd600:	1000091e 	bne	r2,zero,90bd628 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd604:	01000084 	movi	r4,2
 90bd608:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 90bd60c:	e13ffd17 	ldw	r4,-12(fp)
 90bd610:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd614:	01000084 	movi	r4,2
 90bd618:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 90bd61c:	00bffa84 	movi	r2,-22
 90bd620:	e0bfff15 	stw	r2,-4(fp)
 90bd624:	00005706 	br	90bd784 <send_via_arp+0x1b4>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 90bd628:	d0e0c617 	ldw	r3,-31976(gp)
 90bd62c:	e0bffb17 	ldw	r2,-20(fp)
 90bd630:	10c9c83a 	sub	r4,r2,r3
 90bd634:	908d0380 	call	908d038 <__floatunsidf>
 90bd638:	100b883a 	mov	r5,r2
 90bd63c:	180d883a 	mov	r6,r3
 90bd640:	2809883a 	mov	r4,r5
 90bd644:	300b883a 	mov	r5,r6
 90bd648:	000d883a 	mov	r6,zero
 90bd64c:	01d01674 	movhi	r7,16473
 90bd650:	908ccd00 	call	908ccd0 <__gtdf2>
 90bd654:	10800048 	cmpgei	r2,r2,1
 90bd658:	1000011e 	bne	r2,zero,90bd660 <send_via_arp+0x90>
 90bd65c:	00000106 	br	90bd664 <send_via_arp+0x94>
      arpcache = (struct arptabent *)NULL;
 90bd660:	d020c115 	stw	zero,-31996(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 90bd664:	d0a0c117 	ldw	r2,-31996(gp)
 90bd668:	1005003a 	cmpeq	r2,r2,zero
 90bd66c:	1000071e 	bne	r2,zero,90bd68c <send_via_arp+0xbc>
 90bd670:	d0a0c117 	ldw	r2,-31996(gp)
 90bd674:	10c00017 	ldw	r3,0(r2)
 90bd678:	e0bffe17 	ldw	r2,-8(fp)
 90bd67c:	1880031e 	bne	r3,r2,90bd68c <send_via_arp+0xbc>
      tp = arpcache;
 90bd680:	d0a0c117 	ldw	r2,-31996(gp)
 90bd684:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 90bd688:	00000306 	br	90bd698 <send_via_arp+0xc8>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 90bd68c:	e13ffe17 	ldw	r4,-8(fp)
 90bd690:	90bcdd40 	call	90bcdd4 <find_oldest_arp>
 90bd694:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 90bd698:	e0bffc17 	ldw	r2,-16(fp)
 90bd69c:	10c00017 	ldw	r3,0(r2)
 90bd6a0:	e0bffe17 	ldw	r2,-8(fp)
 90bd6a4:	1880311e 	bne	r3,r2,90bd76c <send_via_arp+0x19c>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 90bd6a8:	e0bffc17 	ldw	r2,-16(fp)
 90bd6ac:	10800417 	ldw	r2,16(r2)
 90bd6b0:	1005003a 	cmpeq	r2,r2,zero
 90bd6b4:	1000241e 	bne	r2,zero,90bd748 <send_via_arp+0x178>
      {
         if (lilfreeq.q_len < 2)
 90bd6b8:	008243b4 	movhi	r2,2318
 90bd6bc:	10b64804 	addi	r2,r2,-9952
 90bd6c0:	10800217 	ldw	r2,8(r2)
 90bd6c4:	10800088 	cmpgei	r2,r2,2
 90bd6c8:	1000091e 	bne	r2,zero,90bd6f0 <send_via_arp+0x120>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bd6cc:	01000084 	movi	r4,2
 90bd6d0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 90bd6d4:	e13ffd17 	ldw	r4,-12(fp)
 90bd6d8:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd6dc:	01000084 	movi	r4,2
 90bd6e0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 90bd6e4:	00bffa84 	movi	r2,-22
 90bd6e8:	e0bffa15 	stw	r2,-24(fp)
 90bd6ec:	00002306 	br	90bd77c <send_via_arp+0x1ac>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 90bd6f0:	e0bffc17 	ldw	r2,-16(fp)
 90bd6f4:	10800417 	ldw	r2,16(r2)
 90bd6f8:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 90bd6fc:	00000306 	br	90bd70c <send_via_arp+0x13c>
               tmppkt = tmppkt->next;
 90bd700:	e0bff917 	ldw	r2,-28(fp)
 90bd704:	10800017 	ldw	r2,0(r2)
 90bd708:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 90bd70c:	e0bff917 	ldw	r2,-28(fp)
 90bd710:	10800017 	ldw	r2,0(r2)
 90bd714:	1004c03a 	cmpne	r2,r2,zero
 90bd718:	103ff91e 	bne	r2,zero,90bd700 <send_via_arp+0x130>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 90bd71c:	e0fff917 	ldw	r3,-28(fp)
 90bd720:	e0bffd17 	ldw	r2,-12(fp)
 90bd724:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 90bd728:	e0bffd17 	ldw	r2,-12(fp)
 90bd72c:	10800017 	ldw	r2,0(r2)
 90bd730:	1005003a 	cmpeq	r2,r2,zero
 90bd734:	1000011e 	bne	r2,zero,90bd73c <send_via_arp+0x16c>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 90bd738:	90aa4780 	call	90aa478 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 90bd73c:	00800044 	movi	r2,1
 90bd740:	e0bffa15 	stw	r2,-24(fp)
 90bd744:	00000d06 	br	90bd77c <send_via_arp+0x1ac>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 90bd748:	e0bffc17 	ldw	r2,-16(fp)
 90bd74c:	d0a0c115 	stw	r2,-31996(gp)
         cachetime = lticks;  /* mark time we cached */
 90bd750:	e0bffb17 	ldw	r2,-20(fp)
 90bd754:	d0a0c615 	stw	r2,-31976(gp)
         err = et_send(pkt, tp);
 90bd758:	e13ffd17 	ldw	r4,-12(fp)
 90bd75c:	e17ffc17 	ldw	r5,-16(fp)
 90bd760:	90bc6c40 	call	90bc6c4 <et_send>
 90bd764:	e0bffa15 	stw	r2,-24(fp)
 90bd768:	00000406 	br	90bd77c <send_via_arp+0x1ac>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 90bd76c:	e13ffd17 	ldw	r4,-12(fp)
 90bd770:	e17ffe17 	ldw	r5,-8(fp)
 90bd774:	90bc93c0 	call	90bc93c <send_arp>
 90bd778:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 90bd77c:	e0bffa17 	ldw	r2,-24(fp)
 90bd780:	e0bfff15 	stw	r2,-4(fp)
 90bd784:	e0bfff17 	ldw	r2,-4(fp)
}
 90bd788:	e037883a 	mov	sp,fp
 90bd78c:	dfc00117 	ldw	ra,4(sp)
 90bd790:	df000017 	ldw	fp,0(sp)
 90bd794:	dec00204 	addi	sp,sp,8
 90bd798:	f800283a 	ret

090bd79c <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 90bd79c:	defff804 	addi	sp,sp,-32
 90bd7a0:	dfc00715 	stw	ra,28(sp)
 90bd7a4:	df000615 	stw	fp,24(sp)
 90bd7a8:	df000604 	addi	fp,sp,24
 90bd7ac:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   int arp_count = 0;
 90bd7b0:	e03ffb15 	stw	zero,-20(fp)
   unsigned long lticks = cticks;
 90bd7b4:	00824374 	movhi	r2,2317
 90bd7b8:	108f2e04 	addi	r2,r2,15544
 90bd7bc:	10800017 	ldw	r2,0(r2)
 90bd7c0:	e0bffa15 	stw	r2,-24(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bd7c4:	008243b4 	movhi	r2,2318
 90bd7c8:	10b7e704 	addi	r2,r2,-8292
 90bd7cc:	e0bffc15 	stw	r2,-16(fp)
 90bd7d0:	00004c06 	br	90bd904 <cb_arpent_tmo+0x168>
   {
      if (tp->t_pro_addr != 0)
 90bd7d4:	e0bffc17 	ldw	r2,-16(fp)
 90bd7d8:	10800017 	ldw	r2,0(r2)
 90bd7dc:	1005003a 	cmpeq	r2,r2,zero
 90bd7e0:	1000451e 	bne	r2,zero,90bd8f8 <cb_arpent_tmo+0x15c>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 90bd7e4:	e0bffc17 	ldw	r2,-16(fp)
 90bd7e8:	10800417 	ldw	r2,16(r2)
 90bd7ec:	1005003a 	cmpeq	r2,r2,zero
 90bd7f0:	10001c1e 	bne	r2,zero,90bd864 <cb_arpent_tmo+0xc8>
 90bd7f4:	e0bffc17 	ldw	r2,-16(fp)
 90bd7f8:	10c00517 	ldw	r3,20(r2)
 90bd7fc:	e0bffa17 	ldw	r2,-24(fp)
 90bd800:	10c9c83a 	sub	r4,r2,r3
 90bd804:	908d0380 	call	908d038 <__floatunsidf>
 90bd808:	100b883a 	mov	r5,r2
 90bd80c:	180d883a 	mov	r6,r3
 90bd810:	e03fff05 	stb	zero,-4(fp)
 90bd814:	2809883a 	mov	r4,r5
 90bd818:	300b883a 	mov	r5,r6
 90bd81c:	000d883a 	mov	r6,zero
 90bd820:	01d01674 	movhi	r7,16473
 90bd824:	908ccd00 	call	908ccd0 <__gtdf2>
 90bd828:	10800048 	cmpgei	r2,r2,1
 90bd82c:	1000011e 	bne	r2,zero,90bd834 <cb_arpent_tmo+0x98>
 90bd830:	00000206 	br	90bd83c <cb_arpent_tmo+0xa0>
 90bd834:	00800044 	movi	r2,1
 90bd838:	e0bfff05 	stb	r2,-4(fp)
 90bd83c:	e0ffff03 	ldbu	r3,-4(fp)
 90bd840:	1880005c 	xori	r2,r3,1
 90bd844:	10803fcc 	andi	r2,r2,255
 90bd848:	1004c03a 	cmpne	r2,r2,zero
 90bd84c:	1000051e 	bne	r2,zero,90bd864 <cb_arpent_tmo+0xc8>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 90bd850:	e13ffc17 	ldw	r4,-16(fp)
 90bd854:	90bc8400 	call	90bc840 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bd858:	e0bffc17 	ldw	r2,-16(fp)
 90bd85c:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 90bd860:	00002506 	br	90bd8f8 <cb_arpent_tmo+0x15c>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 90bd864:	e0bffc17 	ldw	r2,-16(fp)
 90bd868:	10c00517 	ldw	r3,20(r2)
 90bd86c:	e0bffa17 	ldw	r2,-24(fp)
 90bd870:	10c5c83a 	sub	r2,r2,r3
 90bd874:	1007883a 	mov	r3,r2
 90bd878:	d0a04f17 	ldw	r2,-32452(gp)
 90bd87c:	18801b16 	blt	r3,r2,90bd8ec <cb_arpent_tmo+0x150>
 90bd880:	e0bffc17 	ldw	r2,-16(fp)
 90bd884:	10c00617 	ldw	r3,24(r2)
 90bd888:	e0bffa17 	ldw	r2,-24(fp)
 90bd88c:	10c5c83a 	sub	r2,r2,r3
 90bd890:	1009883a 	mov	r4,r2
 90bd894:	908ce680 	call	908ce68 <__floatsidf>
 90bd898:	100b883a 	mov	r5,r2
 90bd89c:	180d883a 	mov	r6,r3
 90bd8a0:	e03ffe05 	stb	zero,-8(fp)
 90bd8a4:	2809883a 	mov	r4,r5
 90bd8a8:	300b883a 	mov	r5,r6
 90bd8ac:	000d883a 	mov	r6,zero
 90bd8b0:	01d01674 	movhi	r7,16473
 90bd8b4:	908cd580 	call	908cd58 <__gedf2>
 90bd8b8:	1004403a 	cmpge	r2,r2,zero
 90bd8bc:	1000011e 	bne	r2,zero,90bd8c4 <cb_arpent_tmo+0x128>
 90bd8c0:	00000206 	br	90bd8cc <cb_arpent_tmo+0x130>
 90bd8c4:	00800044 	movi	r2,1
 90bd8c8:	e0bffe05 	stb	r2,-8(fp)
 90bd8cc:	e0fffe03 	ldbu	r3,-8(fp)
 90bd8d0:	1880005c 	xori	r2,r3,1
 90bd8d4:	10803fcc 	andi	r2,r2,255
 90bd8d8:	1004c03a 	cmpne	r2,r2,zero
 90bd8dc:	1000031e 	bne	r2,zero,90bd8ec <cb_arpent_tmo+0x150>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 90bd8e0:	e0bffc17 	ldw	r2,-16(fp)
 90bd8e4:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 90bd8e8:	00000306 	br	90bd8f8 <cb_arpent_tmo+0x15c>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 90bd8ec:	e0bffb17 	ldw	r2,-20(fp)
 90bd8f0:	10800044 	addi	r2,r2,1
 90bd8f4:	e0bffb15 	stw	r2,-20(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 90bd8f8:	e0bffc17 	ldw	r2,-16(fp)
 90bd8fc:	10800804 	addi	r2,r2,32
 90bd900:	e0bffc15 	stw	r2,-16(fp)
 90bd904:	00c243b4 	movhi	r3,2318
 90bd908:	18f82704 	addi	r3,r3,-8036
 90bd90c:	e0bffc17 	ldw	r2,-16(fp)
 90bd910:	10ffb036 	bltu	r2,r3,90bd7d4 <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 90bd914:	e0bffb17 	ldw	r2,-20(fp)
 90bd918:	1004c03a 	cmpne	r2,r2,zero
 90bd91c:	1000031e 	bne	r2,zero,90bd92c <cb_arpent_tmo+0x190>
   {
      in_timerkill(arp_timer);
 90bd920:	d120c017 	ldw	r4,-32000(gp)
 90bd924:	90bc4740 	call	90bc474 <in_timerkill>
      arp_timer = 0;
 90bd928:	d020c015 	stw	zero,-32000(gp)
   }
      
   USE_ARG(arg);
}
 90bd92c:	e037883a 	mov	sp,fp
 90bd930:	dfc00117 	ldw	ra,4(sp)
 90bd934:	df000017 	ldw	fp,0(sp)
 90bd938:	dec00204 	addi	sp,sp,8
 90bd93c:	f800283a 	ret

090bd940 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 90bd940:	defff604 	addi	sp,sp,-40
 90bd944:	dfc00915 	stw	ra,36(sp)
 90bd948:	df000815 	stw	fp,32(sp)
 90bd94c:	df000804 	addi	fp,sp,32
 90bd950:	e13ffd15 	stw	r4,-12(fp)
 90bd954:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 90bd958:	e0bffd17 	ldw	r2,-12(fp)
 90bd95c:	10802717 	ldw	r2,156(r2)
 90bd960:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 90bd964:	01000084 	movi	r4,2
 90bd968:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 90bd96c:	01000c04 	movi	r4,48
 90bd970:	90a98340 	call	90a9834 <pk_alloc>
 90bd974:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 90bd978:	e0bff917 	ldw	r2,-28(fp)
 90bd97c:	1004c03a 	cmpne	r2,r2,zero
 90bd980:	1000051e 	bne	r2,zero,90bd998 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd984:	01000084 	movi	r4,2
 90bd988:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 90bd98c:	00bffa84 	movi	r2,-22
 90bd990:	e0bfff15 	stw	r2,-4(fp)
 90bd994:	00009706 	br	90bdbf4 <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bd998:	01000084 	movi	r4,2
 90bd99c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 90bd9a0:	e0bff917 	ldw	r2,-28(fp)
 90bd9a4:	10c00117 	ldw	r3,4(r2)
 90bd9a8:	e0bff917 	ldw	r2,-28(fp)
 90bd9ac:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 90bd9b0:	e0fff917 	ldw	r3,-28(fp)
 90bd9b4:	00800c04 	movi	r2,48
 90bd9b8:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 90bd9bc:	e0fff917 	ldw	r3,-28(fp)
 90bd9c0:	e0bffd17 	ldw	r2,-12(fp)
 90bd9c4:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 90bd9c8:	e0bff917 	ldw	r2,-28(fp)
 90bd9cc:	10800117 	ldw	r2,4(r2)
 90bd9d0:	10800084 	addi	r2,r2,2
 90bd9d4:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 90bd9d8:	e0bff917 	ldw	r2,-28(fp)
 90bd9dc:	10800117 	ldw	r2,4(r2)
 90bd9e0:	10800404 	addi	r2,r2,16
 90bd9e4:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 90bd9e8:	e0fffb17 	ldw	r3,-20(fp)
 90bd9ec:	00804004 	movi	r2,256
 90bd9f0:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 90bd9f4:	e0fffb17 	ldw	r3,-20(fp)
 90bd9f8:	00800204 	movi	r2,8
 90bd9fc:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 90bda00:	e0fffb17 	ldw	r3,-20(fp)
 90bda04:	00800184 	movi	r2,6
 90bda08:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 90bda0c:	e0fffb17 	ldw	r3,-20(fp)
 90bda10:	00800104 	movi	r2,4
 90bda14:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 90bda18:	e0bffe17 	ldw	r2,-8(fp)
 90bda1c:	1004c03a 	cmpne	r2,r2,zero
 90bda20:	1000041e 	bne	r2,zero,90bda34 <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 90bda24:	e0fffb17 	ldw	r3,-20(fp)
 90bda28:	00804004 	movi	r2,256
 90bda2c:	1880018d 	sth	r2,6(r3)
 90bda30:	00000306 	br	90bda40 <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 90bda34:	e0fffb17 	ldw	r3,-20(fp)
 90bda38:	00808004 	movi	r2,512
 90bda3c:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 90bda40:	e0bffd17 	ldw	r2,-12(fp)
 90bda44:	10c00a17 	ldw	r3,40(r2)
 90bda48:	e0bffb17 	ldw	r2,-20(fp)
 90bda4c:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 90bda50:	e0bffd17 	ldw	r2,-12(fp)
 90bda54:	10c00a17 	ldw	r3,40(r2)
 90bda58:	e0bffb17 	ldw	r2,-20(fp)
 90bda5c:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 90bda60:	e0bffb17 	ldw	r2,-20(fp)
 90bda64:	11000204 	addi	r4,r2,8
 90bda68:	e0bffa17 	ldw	r2,-24(fp)
 90bda6c:	11400517 	ldw	r5,20(r2)
 90bda70:	01800184 	movi	r6,6
 90bda74:	90895000 	call	9089500 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 90bda78:	e0fffc17 	ldw	r3,-16(fp)
 90bda7c:	00bfffc4 	movi	r2,-1
 90bda80:	18800005 	stb	r2,0(r3)
 90bda84:	00bfffc4 	movi	r2,-1
 90bda88:	18800045 	stb	r2,1(r3)
 90bda8c:	00bfffc4 	movi	r2,-1
 90bda90:	18800085 	stb	r2,2(r3)
 90bda94:	00bfffc4 	movi	r2,-1
 90bda98:	188000c5 	stb	r2,3(r3)
 90bda9c:	00bfffc4 	movi	r2,-1
 90bdaa0:	18800105 	stb	r2,4(r3)
 90bdaa4:	00bfffc4 	movi	r2,-1
 90bdaa8:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 90bdaac:	e0bffc17 	ldw	r2,-16(fp)
 90bdab0:	11000184 	addi	r4,r2,6
 90bdab4:	e0bffa17 	ldw	r2,-24(fp)
 90bdab8:	11400517 	ldw	r5,20(r2)
 90bdabc:	01800184 	movi	r6,6
 90bdac0:	90895000 	call	9089500 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 90bdac4:	e0bffc17 	ldw	r2,-16(fp)
 90bdac8:	10c00304 	addi	r3,r2,12
 90bdacc:	00800204 	movi	r2,8
 90bdad0:	18800005 	stb	r2,0(r3)
 90bdad4:	e0bffc17 	ldw	r2,-16(fp)
 90bdad8:	10c00344 	addi	r3,r2,13
 90bdadc:	00800184 	movi	r2,6
 90bdae0:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 90bdae4:	e0bffb17 	ldw	r2,-20(fp)
 90bdae8:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 90bdaec:	e0bff817 	ldw	r2,-32(fp)
 90bdaf0:	11000204 	addi	r4,r2,8
 90bdaf4:	e0bffb17 	ldw	r2,-20(fp)
 90bdaf8:	11400204 	addi	r5,r2,8
 90bdafc:	01800184 	movi	r6,6
 90bdb00:	90895000 	call	9089500 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 90bdb04:	e0bff817 	ldw	r2,-32(fp)
 90bdb08:	10800204 	addi	r2,r2,8
 90bdb0c:	11000184 	addi	r4,r2,6
 90bdb10:	e0bffb17 	ldw	r2,-20(fp)
 90bdb14:	11400404 	addi	r5,r2,16
 90bdb18:	01800104 	movi	r6,4
 90bdb1c:	90895000 	call	9089500 <memmove>

   /* ARP req? */
   if (flag == 0)
 90bdb20:	e0bffe17 	ldw	r2,-8(fp)
 90bdb24:	1004c03a 	cmpne	r2,r2,zero
 90bdb28:	1000081e 	bne	r2,zero,90bdb4c <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 90bdb2c:	e0bff817 	ldw	r2,-32(fp)
 90bdb30:	10800204 	addi	r2,r2,8
 90bdb34:	11000284 	addi	r4,r2,10
 90bdb38:	e0bffb17 	ldw	r2,-20(fp)
 90bdb3c:	11400504 	addi	r5,r2,20
 90bdb40:	01800184 	movi	r6,6
 90bdb44:	90895000 	call	9089500 <memmove>
 90bdb48:	00000706 	br	90bdb68 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 90bdb4c:	e0bff817 	ldw	r2,-32(fp)
 90bdb50:	10800204 	addi	r2,r2,8
 90bdb54:	11000284 	addi	r4,r2,10
 90bdb58:	e0bffb17 	ldw	r2,-20(fp)
 90bdb5c:	11400204 	addi	r5,r2,8
 90bdb60:	01800184 	movi	r6,6
 90bdb64:	90895000 	call	9089500 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 90bdb68:	e0bff817 	ldw	r2,-32(fp)
 90bdb6c:	10800204 	addi	r2,r2,8
 90bdb70:	11000404 	addi	r4,r2,16
 90bdb74:	e0bffb17 	ldw	r2,-20(fp)
 90bdb78:	11400704 	addi	r5,r2,28
 90bdb7c:	01800104 	movi	r6,4
 90bdb80:	90895000 	call	9089500 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 90bdb84:	e0bffd17 	ldw	r2,-12(fp)
 90bdb88:	10800417 	ldw	r2,16(r2)
 90bdb8c:	1005003a 	cmpeq	r2,r2,zero
 90bdb90:	1000051e 	bne	r2,zero,90bdba8 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 90bdb94:	e0bffd17 	ldw	r2,-12(fp)
 90bdb98:	10800417 	ldw	r2,16(r2)
 90bdb9c:	e13ff917 	ldw	r4,-28(fp)
 90bdba0:	103ee83a 	callr	r2
 90bdba4:	00000e06 	br	90bdbe0 <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 90bdba8:	e0bffd17 	ldw	r2,-12(fp)
 90bdbac:	10c00317 	ldw	r3,12(r2)
 90bdbb0:	e0bff917 	ldw	r2,-28(fp)
 90bdbb4:	11000617 	ldw	r4,24(r2)
 90bdbb8:	e0bff917 	ldw	r2,-28(fp)
 90bdbbc:	11400117 	ldw	r5,4(r2)
 90bdbc0:	01800c04 	movi	r6,48
 90bdbc4:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bdbc8:	01000084 	movi	r4,2
 90bdbcc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 90bdbd0:	e13ff917 	ldw	r4,-28(fp)
 90bdbd4:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bdbd8:	01000084 	movi	r4,2
 90bdbdc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 90bdbe0:	d0a0c317 	ldw	r2,-31988(gp)
 90bdbe4:	10800044 	addi	r2,r2,1
 90bdbe8:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 90bdbec:	00800044 	movi	r2,1
 90bdbf0:	e0bfff15 	stw	r2,-4(fp)
 90bdbf4:	e0bfff17 	ldw	r2,-4(fp)
}
 90bdbf8:	e037883a 	mov	sp,fp
 90bdbfc:	dfc00117 	ldw	ra,4(sp)
 90bdc00:	df000017 	ldw	fp,0(sp)
 90bdc04:	dec00204 	addi	sp,sp,8
 90bdc08:	f800283a 	ret

090bdc0c <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 90bdc0c:	defffb04 	addi	sp,sp,-20
 90bdc10:	dfc00415 	stw	ra,16(sp)
 90bdc14:	df000315 	stw	fp,12(sp)
 90bdc18:	df000304 	addi	fp,sp,12
 90bdc1c:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bdc20:	008243b4 	movhi	r2,2318
 90bdc24:	10b82704 	addi	r2,r2,-8036
 90bdc28:	10800017 	ldw	r2,0(r2)
 90bdc2c:	e0bffd15 	stw	r2,-12(fp)
 90bdc30:	00000c06 	br	90bdc64 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 90bdc34:	e0bffe17 	ldw	r2,-8(fp)
 90bdc38:	10bfffc4 	addi	r2,r2,-1
 90bdc3c:	e0bffe15 	stw	r2,-8(fp)
 90bdc40:	e0bffe17 	ldw	r2,-8(fp)
 90bdc44:	10bfffd8 	cmpnei	r2,r2,-1
 90bdc48:	1000031e 	bne	r2,zero,90bdc58 <if_getbynum+0x4c>
         return ifp;
 90bdc4c:	e0bffd17 	ldw	r2,-12(fp)
 90bdc50:	e0bfff15 	stw	r2,-4(fp)
 90bdc54:	00000806 	br	90bdc78 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bdc58:	e0bffd17 	ldw	r2,-12(fp)
 90bdc5c:	10800017 	ldw	r2,0(r2)
 90bdc60:	e0bffd15 	stw	r2,-12(fp)
 90bdc64:	e0bffd17 	ldw	r2,-12(fp)
 90bdc68:	1004c03a 	cmpne	r2,r2,zero
 90bdc6c:	103ff11e 	bne	r2,zero,90bdc34 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 90bdc70:	90aa4780 	call	90aa478 <dtrap>
   return NULL;   /* list is not long enough */
 90bdc74:	e03fff15 	stw	zero,-4(fp)
 90bdc78:	e0bfff17 	ldw	r2,-4(fp)
}
 90bdc7c:	e037883a 	mov	sp,fp
 90bdc80:	dfc00117 	ldw	ra,4(sp)
 90bdc84:	df000017 	ldw	fp,0(sp)
 90bdc88:	dec00204 	addi	sp,sp,8
 90bdc8c:	f800283a 	ret

090bdc90 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 90bdc90:	defffc04 	addi	sp,sp,-16
 90bdc94:	df000315 	stw	fp,12(sp)
 90bdc98:	df000304 	addi	fp,sp,12
 90bdc9c:	e13ffd15 	stw	r4,-12(fp)
 90bdca0:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 90bdca4:	e0bffe17 	ldw	r2,-8(fp)
 90bdca8:	108000cc 	andi	r2,r2,3
 90bdcac:	1005003a 	cmpeq	r2,r2,zero
 90bdcb0:	10000e1e 	bne	r2,zero,90bdcec <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 90bdcb4:	e0bffe17 	ldw	r2,-8(fp)
 90bdcb8:	1080000b 	ldhu	r2,0(r2)
 90bdcbc:	10ffffcc 	andi	r3,r2,65535
 90bdcc0:	00bfffd4 	movui	r2,65535
 90bdcc4:	18800226 	beq	r3,r2,90bdcd0 <isbcast+0x40>
         return(FALSE);
 90bdcc8:	e03fff15 	stw	zero,-4(fp)
 90bdccc:	00002306 	br	90bdd5c <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 90bdcd0:	e0bffe17 	ldw	r2,-8(fp)
 90bdcd4:	10800084 	addi	r2,r2,2
 90bdcd8:	10800017 	ldw	r2,0(r2)
 90bdcdc:	10bfffe0 	cmpeqi	r2,r2,-1
 90bdce0:	1000101e 	bne	r2,zero,90bdd24 <isbcast+0x94>
         return FALSE;
 90bdce4:	e03fff15 	stw	zero,-4(fp)
 90bdce8:	00001c06 	br	90bdd5c <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 90bdcec:	e0bffe17 	ldw	r2,-8(fp)
 90bdcf0:	10800017 	ldw	r2,0(r2)
 90bdcf4:	10bfffe0 	cmpeqi	r2,r2,-1
 90bdcf8:	1000021e 	bne	r2,zero,90bdd04 <isbcast+0x74>
         return FALSE;
 90bdcfc:	e03fff15 	stw	zero,-4(fp)
 90bdd00:	00001606 	br	90bdd5c <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 90bdd04:	e0bffe17 	ldw	r2,-8(fp)
 90bdd08:	10800104 	addi	r2,r2,4
 90bdd0c:	1080000b 	ldhu	r2,0(r2)
 90bdd10:	10ffffcc 	andi	r3,r2,65535
 90bdd14:	00bfffd4 	movui	r2,65535
 90bdd18:	18800226 	beq	r3,r2,90bdd24 <isbcast+0x94>
         return(FALSE);
 90bdd1c:	e03fff15 	stw	zero,-4(fp)
 90bdd20:	00000e06 	br	90bdd5c <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 90bdd24:	e0bffd17 	ldw	r2,-12(fp)
 90bdd28:	10802717 	ldw	r2,156(r2)
 90bdd2c:	10800217 	ldw	r2,8(r2)
 90bdd30:	108005e0 	cmpeqi	r2,r2,23
 90bdd34:	1000051e 	bne	r2,zero,90bdd4c <isbcast+0xbc>
 90bdd38:	e0bffd17 	ldw	r2,-12(fp)
 90bdd3c:	10802717 	ldw	r2,156(r2)
 90bdd40:	10800217 	ldw	r2,8(r2)
 90bdd44:	10800718 	cmpnei	r2,r2,28
 90bdd48:	1000021e 	bne	r2,zero,90bdd54 <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 90bdd4c:	e03fff15 	stw	zero,-4(fp)
 90bdd50:	00000206 	br	90bdd5c <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 90bdd54:	00800044 	movi	r2,1
 90bdd58:	e0bfff15 	stw	r2,-4(fp)
 90bdd5c:	e0bfff17 	ldw	r2,-4(fp)
}
 90bdd60:	e037883a 	mov	sp,fp
 90bdd64:	df000017 	ldw	fp,0(sp)
 90bdd68:	dec00104 	addi	sp,sp,4
 90bdd6c:	f800283a 	ret

090bdd70 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 90bdd70:	defffa04 	addi	sp,sp,-24
 90bdd74:	dfc00515 	stw	ra,20(sp)
 90bdd78:	df000415 	stw	fp,16(sp)
 90bdd7c:	df000404 	addi	fp,sp,16
 90bdd80:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bdd84:	008243b4 	movhi	r2,2318
 90bdd88:	10b82704 	addi	r2,r2,-8036
 90bdd8c:	10800017 	ldw	r2,0(r2)
 90bdd90:	e0bffd15 	stw	r2,-12(fp)
 90bdd94:	00001306 	br	90bdde4 <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 90bdd98:	e0bffd17 	ldw	r2,-12(fp)
 90bdd9c:	10800617 	ldw	r2,24(r2)
 90bdda0:	1005003a 	cmpeq	r2,r2,zero
 90bdda4:	10000c1e 	bne	r2,zero,90bddd8 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 90bdda8:	e0bffd17 	ldw	r2,-12(fp)
 90bddac:	10800617 	ldw	r2,24(r2)
 90bddb0:	e13ffe0b 	ldhu	r4,-8(fp)
 90bddb4:	e17ffd17 	ldw	r5,-12(fp)
 90bddb8:	103ee83a 	callr	r2
 90bddbc:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 90bddc0:	e0bffc17 	ldw	r2,-16(fp)
 90bddc4:	1005003a 	cmpeq	r2,r2,zero
 90bddc8:	1000031e 	bne	r2,zero,90bddd8 <reg_type+0x68>
            return e;   /* bails out if error */
 90bddcc:	e0bffc17 	ldw	r2,-16(fp)
 90bddd0:	e0bfff15 	stw	r2,-4(fp)
 90bddd4:	00000706 	br	90bddf4 <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 90bddd8:	e0bffd17 	ldw	r2,-12(fp)
 90bdddc:	10800017 	ldw	r2,0(r2)
 90bdde0:	e0bffd15 	stw	r2,-12(fp)
 90bdde4:	e0bffd17 	ldw	r2,-12(fp)
 90bdde8:	1004c03a 	cmpne	r2,r2,zero
 90bddec:	103fea1e 	bne	r2,zero,90bdd98 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 90bddf0:	e03fff15 	stw	zero,-4(fp)
 90bddf4:	e0bfff17 	ldw	r2,-4(fp)
}
 90bddf8:	e037883a 	mov	sp,fp
 90bddfc:	dfc00117 	ldw	ra,4(sp)
 90bde00:	df000017 	ldw	fp,0(sp)
 90bde04:	dec00204 	addi	sp,sp,8
 90bde08:	f800283a 	ret

090bde0c <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 90bde0c:	defffa04 	addi	sp,sp,-24
 90bde10:	dfc00515 	stw	ra,20(sp)
 90bde14:	df000415 	stw	fp,16(sp)
 90bde18:	df000404 	addi	fp,sp,16
 90bde1c:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 90bde20:	008243b4 	movhi	r2,2318
 90bde24:	10b72304 	addi	r2,r2,-9076
 90bde28:	10800017 	ldw	r2,0(r2)
 90bde2c:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 90bde30:	00001406 	br	90bde84 <if_killsocks+0x78>
   {
      if(so->so_pcb)
 90bde34:	e0bffe17 	ldw	r2,-8(fp)
 90bde38:	10800117 	ldw	r2,4(r2)
 90bde3c:	1005003a 	cmpeq	r2,r2,zero
 90bde40:	1000051e 	bne	r2,zero,90bde58 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 90bde44:	e0bffe17 	ldw	r2,-8(fp)
 90bde48:	10800117 	ldw	r2,4(r2)
 90bde4c:	10800a17 	ldw	r2,40(r2)
 90bde50:	e0bffc15 	stw	r2,-16(fp)
 90bde54:	00000106 	br	90bde5c <if_killsocks+0x50>
      else
         so_ifp = NULL;
 90bde58:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 90bde5c:	e0bffe17 	ldw	r2,-8(fp)
 90bde60:	10800017 	ldw	r2,0(r2)
 90bde64:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 90bde68:	e0fffc17 	ldw	r3,-16(fp)
 90bde6c:	e0bfff17 	ldw	r2,-4(fp)
 90bde70:	1880021e 	bne	r3,r2,90bde7c <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 90bde74:	e13ffe17 	ldw	r4,-8(fp)
 90bde78:	90af4d40 	call	90af4d4 <soabort>
      }
      so = next;
 90bde7c:	e0bffd17 	ldw	r2,-12(fp)
 90bde80:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 90bde84:	e0bffe17 	ldw	r2,-8(fp)
 90bde88:	1004c03a 	cmpne	r2,r2,zero
 90bde8c:	103fe91e 	bne	r2,zero,90bde34 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 90bde90:	e037883a 	mov	sp,fp
 90bde94:	dfc00117 	ldw	ra,4(sp)
 90bde98:	df000017 	ldw	fp,0(sp)
 90bde9c:	dec00204 	addi	sp,sp,8
 90bdea0:	f800283a 	ret

090bdea4 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 90bdea4:	defffd04 	addi	sp,sp,-12
 90bdea8:	dfc00215 	stw	ra,8(sp)
 90bdeac:	df000115 	stw	fp,4(sp)
 90bdeb0:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 90bdeb4:	01000204 	movi	r4,8
 90bdeb8:	90bdd700 	call	90bdd70 <reg_type>
 90bdebc:	1005003a 	cmpeq	r2,r2,zero
 90bdec0:	1000061e 	bne	r2,zero,90bdedc <ip_init+0x38>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 90bdec4:	01024374 	movhi	r4,2317
 90bdec8:	21032704 	addi	r4,r4,3228
 90bdecc:	90836b80 	call	90836b8 <puts>
#endif
      return(1);
 90bded0:	00800044 	movi	r2,1
 90bded4:	e0bfff15 	stw	r2,-4(fp)
 90bded8:	00002b06 	br	90bdf88 <ip_init+0xe4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 90bdedc:	008243b4 	movhi	r2,2318
 90bdee0:	10b82c04 	addi	r2,r2,-8016
 90bdee4:	1009883a 	mov	r4,r2
 90bdee8:	01801404 	movi	r6,80
 90bdeec:	000b883a 	mov	r5,zero
 90bdef0:	90832780 	call	9083278 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 90bdef4:	00c243b4 	movhi	r3,2318
 90bdef8:	18f82c04 	addi	r3,r3,-8016
 90bdefc:	00800084 	movi	r2,2
 90bdf00:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 90bdf04:	00c243b4 	movhi	r3,2318
 90bdf08:	18f82c04 	addi	r3,r3,-8016
 90bdf0c:	00801004 	movi	r2,64
 90bdf10:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 90bdf14:	d0a05117 	ldw	r2,-32444(gp)
 90bdf18:	11000f24 	muli	r4,r2,60
 90bdf1c:	90aaefc0 	call	90aaefc <npalloc>
 90bdf20:	d0a0c715 	stw	r2,-31972(gp)
   if (!rt_mib)
 90bdf24:	d0a0c717 	ldw	r2,-31972(gp)
 90bdf28:	1004c03a 	cmpne	r2,r2,zero
 90bdf2c:	1000061e 	bne	r2,zero,90bdf48 <ip_init+0xa4>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 90bdf30:	01024374 	movhi	r4,2317
 90bdf34:	21033404 	addi	r4,r4,3280
 90bdf38:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 90bdf3c:	00bffb04 	movi	r2,-20
 90bdf40:	e0bfff15 	stw	r2,-4(fp)
 90bdf44:	00001006 	br	90bdf88 <ip_init+0xe4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 90bdf48:	d0e0c717 	ldw	r3,-31972(gp)
 90bdf4c:	d0a05117 	ldw	r2,-32444(gp)
 90bdf50:	10800f24 	muli	r2,r2,60
 90bdf54:	1809883a 	mov	r4,r3
 90bdf58:	100d883a 	mov	r6,r2
 90bdf5c:	000b883a 	mov	r5,zero
 90bdf60:	90832780 	call	9083278 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 90bdf64:	00c243b4 	movhi	r3,2318
 90bdf68:	18f82c04 	addi	r3,r3,-8016
 90bdf6c:	00800044 	movi	r2,1
 90bdf70:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 90bdf74:	00c243b4 	movhi	r3,2318
 90bdf78:	18f82c04 	addi	r3,r3,-8016
 90bdf7c:	00801e04 	movi	r2,120
 90bdf80:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 90bdf84:	e03fff15 	stw	zero,-4(fp)
 90bdf88:	e0bfff17 	ldw	r2,-4(fp)
}
 90bdf8c:	e037883a 	mov	sp,fp
 90bdf90:	dfc00117 	ldw	ra,4(sp)
 90bdf94:	df000017 	ldw	fp,0(sp)
 90bdf98:	dec00204 	addi	sp,sp,8
 90bdf9c:	f800283a 	ret

090bdfa0 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 90bdfa0:	defff804 	addi	sp,sp,-32
 90bdfa4:	dfc00715 	stw	ra,28(sp)
 90bdfa8:	df000615 	stw	fp,24(sp)
 90bdfac:	df000604 	addi	fp,sp,24
 90bdfb0:	e13ffc15 	stw	r4,-16(fp)
 90bdfb4:	e17ffd15 	stw	r5,-12(fp)
 90bdfb8:	e1bffe05 	stb	r6,-8(fp)
 90bdfbc:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 90bdfc0:	e0bffc17 	ldw	r2,-16(fp)
 90bdfc4:	10800317 	ldw	r2,12(r2)
 90bdfc8:	10fffb04 	addi	r3,r2,-20
 90bdfcc:	e0bffc17 	ldw	r2,-16(fp)
 90bdfd0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 90bdfd4:	e0bffc17 	ldw	r2,-16(fp)
 90bdfd8:	10800417 	ldw	r2,16(r2)
 90bdfdc:	10c00504 	addi	r3,r2,20
 90bdfe0:	e0bffc17 	ldw	r2,-16(fp)
 90bdfe4:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 90bdfe8:	e0bffc17 	ldw	r2,-16(fp)
 90bdfec:	10800317 	ldw	r2,12(r2)
 90bdff0:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 90bdff4:	e0fffb17 	ldw	r3,-20(fp)
 90bdff8:	00801144 	movi	r2,69
 90bdffc:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 90be000:	e0fffb17 	ldw	r3,-20(fp)
 90be004:	e0bfff0b 	ldhu	r2,-4(fp)
 90be008:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 90be00c:	e0bffd17 	ldw	r2,-12(fp)
 90be010:	10bfffcc 	andi	r2,r2,65535
 90be014:	1004d23a 	srli	r2,r2,8
 90be018:	10803fcc 	andi	r2,r2,255
 90be01c:	1009883a 	mov	r4,r2
 90be020:	e0bffd17 	ldw	r2,-12(fp)
 90be024:	10bfffcc 	andi	r2,r2,65535
 90be028:	1004923a 	slli	r2,r2,8
 90be02c:	1007883a 	mov	r3,r2
 90be030:	00bfc004 	movi	r2,-256
 90be034:	1884703a 	and	r2,r3,r2
 90be038:	2084b03a 	or	r2,r4,r2
 90be03c:	1007883a 	mov	r3,r2
 90be040:	e0bffb17 	ldw	r2,-20(fp)
 90be044:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 90be048:	e0bffc17 	ldw	r2,-16(fp)
 90be04c:	10800417 	ldw	r2,16(r2)
 90be050:	10bfffcc 	andi	r2,r2,65535
 90be054:	1004d23a 	srli	r2,r2,8
 90be058:	10803fcc 	andi	r2,r2,255
 90be05c:	1009883a 	mov	r4,r2
 90be060:	e0bffc17 	ldw	r2,-16(fp)
 90be064:	10800417 	ldw	r2,16(r2)
 90be068:	10bfffcc 	andi	r2,r2,65535
 90be06c:	1004923a 	slli	r2,r2,8
 90be070:	1007883a 	mov	r3,r2
 90be074:	00bfc004 	movi	r2,-256
 90be078:	1884703a 	and	r2,r3,r2
 90be07c:	2084b03a 	or	r2,r4,r2
 90be080:	1007883a 	mov	r3,r2
 90be084:	e0bffb17 	ldw	r2,-20(fp)
 90be088:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 90be08c:	e0fffb17 	ldw	r3,-20(fp)
 90be090:	e0bffe03 	ldbu	r2,-8(fp)
 90be094:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 90be098:	e0bffc17 	ldw	r2,-16(fp)
 90be09c:	10800c17 	ldw	r2,48(r2)
 90be0a0:	e0bffa15 	stw	r2,-24(fp)
 90be0a4:	e0bffa17 	ldw	r2,-24(fp)
 90be0a8:	1005003a 	cmpeq	r2,r2,zero
 90be0ac:	1000121e 	bne	r2,zero,90be0f8 <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 90be0b0:	e0bffa17 	ldw	r2,-24(fp)
 90be0b4:	10800043 	ldbu	r2,1(r2)
 90be0b8:	10803fcc 	andi	r2,r2,255
 90be0bc:	1005003a 	cmpeq	r2,r2,zero
 90be0c0:	1000051e 	bne	r2,zero,90be0d8 <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 90be0c4:	e0bffa17 	ldw	r2,-24(fp)
 90be0c8:	10c00043 	ldbu	r3,1(r2)
 90be0cc:	e0bffb17 	ldw	r2,-20(fp)
 90be0d0:	10c00205 	stb	r3,8(r2)
 90be0d4:	00000306 	br	90be0e4 <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 90be0d8:	e0fffb17 	ldw	r3,-20(fp)
 90be0dc:	00801004 	movi	r2,64
 90be0e0:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90be0e4:	e0bffa17 	ldw	r2,-24(fp)
 90be0e8:	10c00003 	ldbu	r3,0(r2)
 90be0ec:	e0bffb17 	ldw	r2,-20(fp)
 90be0f0:	10c00045 	stb	r3,1(r2)
 90be0f4:	00000506 	br	90be10c <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 90be0f8:	e0bffb17 	ldw	r2,-20(fp)
 90be0fc:	00c01004 	movi	r3,64
 90be100:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90be104:	e0bffb17 	ldw	r2,-20(fp)
 90be108:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 90be10c:	e0bffb17 	ldw	r2,-20(fp)
 90be110:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 90be114:	e13ffb17 	ldw	r4,-20(fp)
 90be118:	01400284 	movi	r5,10
 90be11c:	90a4ef40 	call	90a4ef4 <cksum>
 90be120:	0084303a 	nor	r2,zero,r2
 90be124:	1007883a 	mov	r3,r2
 90be128:	e0bffb17 	ldw	r2,-20(fp)
 90be12c:	10c0028d 	sth	r3,10(r2)
}
 90be130:	e037883a 	mov	sp,fp
 90be134:	dfc00117 	ldw	ra,4(sp)
 90be138:	df000017 	ldw	fp,0(sp)
 90be13c:	dec00204 	addi	sp,sp,8
 90be140:	f800283a 	ret

090be144 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 90be144:	deffed04 	addi	sp,sp,-76
 90be148:	dfc01215 	stw	ra,72(sp)
 90be14c:	df001115 	stw	fp,68(sp)
 90be150:	df001104 	addi	fp,sp,68
 90be154:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 90be158:	e0bffc17 	ldw	r2,-16(fp)
 90be15c:	10800717 	ldw	r2,28(r2)
 90be160:	1004d63a 	srli	r2,r2,24
 90be164:	10c03fcc 	andi	r3,r2,255
 90be168:	e0bffc17 	ldw	r2,-16(fp)
 90be16c:	10800717 	ldw	r2,28(r2)
 90be170:	1004d23a 	srli	r2,r2,8
 90be174:	10bfc00c 	andi	r2,r2,65280
 90be178:	1886b03a 	or	r3,r3,r2
 90be17c:	e0bffc17 	ldw	r2,-16(fp)
 90be180:	10800717 	ldw	r2,28(r2)
 90be184:	10bfc00c 	andi	r2,r2,65280
 90be188:	1004923a 	slli	r2,r2,8
 90be18c:	1886b03a 	or	r3,r3,r2
 90be190:	e0bffc17 	ldw	r2,-16(fp)
 90be194:	10800717 	ldw	r2,28(r2)
 90be198:	10803fcc 	andi	r2,r2,255
 90be19c:	1004963a 	slli	r2,r2,24
 90be1a0:	1884b03a 	or	r2,r3,r2
 90be1a4:	10fc002c 	andhi	r3,r2,61440
 90be1a8:	00b80034 	movhi	r2,57344
 90be1ac:	1880b31e 	bne	r3,r2,90be47c <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 90be1b0:	e0bffc17 	ldw	r2,-16(fp)
 90be1b4:	10800b17 	ldw	r2,44(r2)
 90be1b8:	1005003a 	cmpeq	r2,r2,zero
 90be1bc:	1000131e 	bne	r2,zero,90be20c <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 90be1c0:	e0bffc17 	ldw	r2,-16(fp)
 90be1c4:	10800b17 	ldw	r2,44(r2)
 90be1c8:	10800017 	ldw	r2,0(r2)
 90be1cc:	1005003a 	cmpeq	r2,r2,zero
 90be1d0:	1000061e 	bne	r2,zero,90be1ec <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 90be1d4:	e0bffc17 	ldw	r2,-16(fp)
 90be1d8:	10800b17 	ldw	r2,44(r2)
 90be1dc:	10c00017 	ldw	r3,0(r2)
 90be1e0:	e0bffc17 	ldw	r2,-16(fp)
 90be1e4:	10c00615 	stw	r3,24(r2)
 90be1e8:	00002606 	br	90be284 <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 90be1ec:	e0bffc17 	ldw	r2,-16(fp)
 90be1f0:	11000717 	ldw	r4,28(r2)
 90be1f4:	e17ffb04 	addi	r5,fp,-20
 90be1f8:	90bfdac0 	call	90bfdac <iproute>
 90be1fc:	1007883a 	mov	r3,r2
 90be200:	e0bffc17 	ldw	r2,-16(fp)
 90be204:	10c00615 	stw	r3,24(r2)
 90be208:	00001e06 	br	90be284 <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 90be20c:	e03ff815 	stw	zero,-32(fp)
 90be210:	00001706 	br	90be270 <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 90be214:	e0bff817 	ldw	r2,-32(fp)
 90be218:	00c243b4 	movhi	r3,2318
 90be21c:	18f5e604 	addi	r3,r3,-10344
 90be220:	1085883a 	add	r2,r2,r2
 90be224:	1085883a 	add	r2,r2,r2
 90be228:	10c5883a 	add	r2,r2,r3
 90be22c:	10800017 	ldw	r2,0(r2)
 90be230:	10802b17 	ldw	r2,172(r2)
 90be234:	1005003a 	cmpeq	r2,r2,zero
 90be238:	10000a1e 	bne	r2,zero,90be264 <ip_write_internal+0x120>
            {
               p->net = nets[i];
 90be23c:	e0bff817 	ldw	r2,-32(fp)
 90be240:	00c243b4 	movhi	r3,2318
 90be244:	18f5e604 	addi	r3,r3,-10344
 90be248:	1085883a 	add	r2,r2,r2
 90be24c:	1085883a 	add	r2,r2,r2
 90be250:	10c5883a 	add	r2,r2,r3
 90be254:	10c00017 	ldw	r3,0(r2)
 90be258:	e0bffc17 	ldw	r2,-16(fp)
 90be25c:	10c00615 	stw	r3,24(r2)
               break;
 90be260:	00000806 	br	90be284 <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 90be264:	e0bff817 	ldw	r2,-32(fp)
 90be268:	10800044 	addi	r2,r2,1
 90be26c:	e0bff815 	stw	r2,-32(fp)
 90be270:	00824374 	movhi	r2,2317
 90be274:	108f0a04 	addi	r2,r2,15400
 90be278:	10c00017 	ldw	r3,0(r2)
 90be27c:	e0bff817 	ldw	r2,-32(fp)
 90be280:	10ffe436 	bltu	r2,r3,90be214 <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 90be284:	e0bffc17 	ldw	r2,-16(fp)
 90be288:	10800617 	ldw	r2,24(r2)
 90be28c:	1005003a 	cmpeq	r2,r2,zero
 90be290:	1000051e 	bne	r2,zero,90be2a8 <ip_write_internal+0x164>
 90be294:	e0bffc17 	ldw	r2,-16(fp)
 90be298:	10800617 	ldw	r2,24(r2)
 90be29c:	10802b17 	ldw	r2,172(r2)
 90be2a0:	1004c03a 	cmpne	r2,r2,zero
 90be2a4:	10002e1e 	bne	r2,zero,90be360 <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 90be2a8:	00824374 	movhi	r2,2317
 90be2ac:	108f0904 	addi	r2,r2,15396
 90be2b0:	10800017 	ldw	r2,0(r2)
 90be2b4:	1080840c 	andi	r2,r2,528
 90be2b8:	1005003a 	cmpeq	r2,r2,zero
 90be2bc:	1000181e 	bne	r2,zero,90be320 <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 90be2c0:	e0bffc17 	ldw	r2,-16(fp)
 90be2c4:	11800417 	ldw	r6,16(r2)
 90be2c8:	e0bffc17 	ldw	r2,-16(fp)
 90be2cc:	10800717 	ldw	r2,28(r2)
 90be2d0:	11c03fcc 	andi	r7,r2,255
 90be2d4:	e0bffc17 	ldw	r2,-16(fp)
 90be2d8:	10800717 	ldw	r2,28(r2)
 90be2dc:	1004d23a 	srli	r2,r2,8
 90be2e0:	11003fcc 	andi	r4,r2,255
 90be2e4:	e0bffc17 	ldw	r2,-16(fp)
 90be2e8:	10800717 	ldw	r2,28(r2)
 90be2ec:	1004d43a 	srli	r2,r2,16
 90be2f0:	10c03fcc 	andi	r3,r2,255
 90be2f4:	e0bffc17 	ldw	r2,-16(fp)
 90be2f8:	10800717 	ldw	r2,28(r2)
 90be2fc:	1004d63a 	srli	r2,r2,24
 90be300:	d9000015 	stw	r4,0(sp)
 90be304:	d8c00115 	stw	r3,4(sp)
 90be308:	d8800215 	stw	r2,8(sp)
 90be30c:	01024374 	movhi	r4,2317
 90be310:	21033e04 	addi	r4,r4,3320
 90be314:	e17ffc17 	ldw	r5,-16(fp)
 90be318:	90833900 	call	9083390 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 90be31c:	90aa4780 	call	90aa478 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 90be320:	008243b4 	movhi	r2,2318
 90be324:	10b82c04 	addi	r2,r2,-8016
 90be328:	10800b17 	ldw	r2,44(r2)
 90be32c:	10c00044 	addi	r3,r2,1
 90be330:	008243b4 	movhi	r2,2318
 90be334:	10b82c04 	addi	r2,r2,-8016
 90be338:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be33c:	01000084 	movi	r4,2
 90be340:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90be344:	e13ffc17 	ldw	r4,-16(fp)
 90be348:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be34c:	01000084 	movi	r4,2
 90be350:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 90be354:	00bff7c4 	movi	r2,-33
 90be358:	e0bffd15 	stw	r2,-12(fp)
 90be35c:	00015306 	br	90be8ac <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 90be360:	e0bffc17 	ldw	r2,-16(fp)
 90be364:	11000717 	ldw	r4,28(r2)
 90be368:	e0bffc17 	ldw	r2,-16(fp)
 90be36c:	11400617 	ldw	r5,24(r2)
 90be370:	90c300c0 	call	90c300c <lookup_mcast>
 90be374:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 90be378:	e0bff917 	ldw	r2,-28(fp)
 90be37c:	1005003a 	cmpeq	r2,r2,zero
 90be380:	10001f1e 	bne	r2,zero,90be400 <ip_write_internal+0x2bc>
 90be384:	e0bffc17 	ldw	r2,-16(fp)
 90be388:	10800b17 	ldw	r2,44(r2)
 90be38c:	1005003a 	cmpeq	r2,r2,zero
 90be390:	1000061e 	bne	r2,zero,90be3ac <ip_write_internal+0x268>
 90be394:	e0bffc17 	ldw	r2,-16(fp)
 90be398:	10800b17 	ldw	r2,44(r2)
 90be39c:	10800143 	ldbu	r2,5(r2)
 90be3a0:	10803fcc 	andi	r2,r2,255
 90be3a4:	1005003a 	cmpeq	r2,r2,zero
 90be3a8:	1000151e 	bne	r2,zero,90be400 <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 90be3ac:	e0fffc17 	ldw	r3,-16(fp)
 90be3b0:	00800204 	movi	r2,8
 90be3b4:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 90be3b8:	e13ffc17 	ldw	r4,-16(fp)
 90be3bc:	90c00180 	call	90c0018 <ip_copypkt>
 90be3c0:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 90be3c4:	e0bffa17 	ldw	r2,-24(fp)
 90be3c8:	1005003a 	cmpeq	r2,r2,zero
 90be3cc:	10000c1e 	bne	r2,zero,90be400 <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 90be3d0:	01000044 	movi	r4,1
 90be3d4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 90be3d8:	e17ffa17 	ldw	r5,-24(fp)
 90be3dc:	010243b4 	movhi	r4,2318
 90be3e0:	21352104 	addi	r4,r4,-11132
 90be3e4:	90a9e080 	call	90a9e08 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 90be3e8:	01000044 	movi	r4,1
 90be3ec:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 90be3f0:	00824374 	movhi	r2,2317
 90be3f4:	108f3104 	addi	r2,r2,15556
 90be3f8:	11000017 	ldw	r4,0(r2)
 90be3fc:	90940540 	call	9094054 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 90be400:	e0bffc17 	ldw	r2,-16(fp)
 90be404:	10800317 	ldw	r2,12(r2)
 90be408:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 90be40c:	e0bff717 	ldw	r2,-36(fp)
 90be410:	10800203 	ldbu	r2,8(r2)
 90be414:	10803fcc 	andi	r2,r2,255
 90be418:	1005003a 	cmpeq	r2,r2,zero
 90be41c:	10000b1e 	bne	r2,zero,90be44c <ip_write_internal+0x308>
 90be420:	e0bffc17 	ldw	r2,-16(fp)
 90be424:	10800717 	ldw	r2,28(r2)
 90be428:	10803fcc 	andi	r2,r2,255
 90be42c:	10801fe0 	cmpeqi	r2,r2,127
 90be430:	1000061e 	bne	r2,zero,90be44c <ip_write_internal+0x308>
 90be434:	e0bffc17 	ldw	r2,-16(fp)
 90be438:	10c00717 	ldw	r3,28(r2)
 90be43c:	e0bffc17 	ldw	r2,-16(fp)
 90be440:	10800617 	ldw	r2,24(r2)
 90be444:	10800a17 	ldw	r2,40(r2)
 90be448:	1880081e 	bne	r3,r2,90be46c <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be44c:	01000084 	movi	r4,2
 90be450:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90be454:	e13ffc17 	ldw	r4,-16(fp)
 90be458:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be45c:	01000084 	movi	r4,2
 90be460:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 90be464:	e03ffd15 	stw	zero,-12(fp)
 90be468:	00011006 	br	90be8ac <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 90be46c:	e0bffc17 	ldw	r2,-16(fp)
 90be470:	10800717 	ldw	r2,28(r2)
 90be474:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 90be478:	00004106 	br	90be580 <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 90be47c:	e0bffc17 	ldw	r2,-16(fp)
 90be480:	10800717 	ldw	r2,28(r2)
 90be484:	10bfffd8 	cmpnei	r2,r2,-1
 90be488:	1000041e 	bne	r2,zero,90be49c <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 90be48c:	e0bffc17 	ldw	r2,-16(fp)
 90be490:	10800717 	ldw	r2,28(r2)
 90be494:	e0bffb15 	stw	r2,-20(fp)
 90be498:	00003906 	br	90be580 <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 90be49c:	e0bffc17 	ldw	r2,-16(fp)
 90be4a0:	11000717 	ldw	r4,28(r2)
 90be4a4:	e17ffb04 	addi	r5,fp,-20
 90be4a8:	90bfdac0 	call	90bfdac <iproute>
 90be4ac:	1007883a 	mov	r3,r2
 90be4b0:	e0bffc17 	ldw	r2,-16(fp)
 90be4b4:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 90be4b8:	e0bffc17 	ldw	r2,-16(fp)
 90be4bc:	10800617 	ldw	r2,24(r2)
 90be4c0:	1004c03a 	cmpne	r2,r2,zero
 90be4c4:	10002e1e 	bne	r2,zero,90be580 <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 90be4c8:	00824374 	movhi	r2,2317
 90be4cc:	108f0904 	addi	r2,r2,15396
 90be4d0:	10800017 	ldw	r2,0(r2)
 90be4d4:	1080840c 	andi	r2,r2,528
 90be4d8:	1005003a 	cmpeq	r2,r2,zero
 90be4dc:	1000181e 	bne	r2,zero,90be540 <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 90be4e0:	e0bffc17 	ldw	r2,-16(fp)
 90be4e4:	11800417 	ldw	r6,16(r2)
 90be4e8:	e0bffc17 	ldw	r2,-16(fp)
 90be4ec:	10800717 	ldw	r2,28(r2)
 90be4f0:	11c03fcc 	andi	r7,r2,255
 90be4f4:	e0bffc17 	ldw	r2,-16(fp)
 90be4f8:	10800717 	ldw	r2,28(r2)
 90be4fc:	1004d23a 	srli	r2,r2,8
 90be500:	11003fcc 	andi	r4,r2,255
 90be504:	e0bffc17 	ldw	r2,-16(fp)
 90be508:	10800717 	ldw	r2,28(r2)
 90be50c:	1004d43a 	srli	r2,r2,16
 90be510:	10c03fcc 	andi	r3,r2,255
 90be514:	e0bffc17 	ldw	r2,-16(fp)
 90be518:	10800717 	ldw	r2,28(r2)
 90be51c:	1004d63a 	srli	r2,r2,24
 90be520:	d9000015 	stw	r4,0(sp)
 90be524:	d8c00115 	stw	r3,4(sp)
 90be528:	d8800215 	stw	r2,8(sp)
 90be52c:	01024374 	movhi	r4,2317
 90be530:	21033e04 	addi	r4,r4,3320
 90be534:	e17ffc17 	ldw	r5,-16(fp)
 90be538:	90833900 	call	9083390 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 90be53c:	90aa4780 	call	90aa478 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 90be540:	008243b4 	movhi	r2,2318
 90be544:	10b82c04 	addi	r2,r2,-8016
 90be548:	10800b17 	ldw	r2,44(r2)
 90be54c:	10c00044 	addi	r3,r2,1
 90be550:	008243b4 	movhi	r2,2318
 90be554:	10b82c04 	addi	r2,r2,-8016
 90be558:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be55c:	01000084 	movi	r4,2
 90be560:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90be564:	e13ffc17 	ldw	r4,-16(fp)
 90be568:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be56c:	01000084 	movi	r4,2
 90be570:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 90be574:	00fff7c4 	movi	r3,-33
 90be578:	e0fffd15 	stw	r3,-12(fp)
 90be57c:	0000cb06 	br	90be8ac <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 90be580:	00824374 	movhi	r2,2317
 90be584:	108f0904 	addi	r2,r2,15396
 90be588:	10800017 	ldw	r2,0(r2)
 90be58c:	1080800c 	andi	r2,r2,512
 90be590:	1005003a 	cmpeq	r2,r2,zero
 90be594:	1000231e 	bne	r2,zero,90be624 <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 90be598:	e0bffc17 	ldw	r2,-16(fp)
 90be59c:	11400417 	ldw	r5,16(r2)
 90be5a0:	e0bffc17 	ldw	r2,-16(fp)
 90be5a4:	10800717 	ldw	r2,28(r2)
 90be5a8:	11803fcc 	andi	r6,r2,255
 90be5ac:	e0bffc17 	ldw	r2,-16(fp)
 90be5b0:	10800717 	ldw	r2,28(r2)
 90be5b4:	1004d23a 	srli	r2,r2,8
 90be5b8:	11c03fcc 	andi	r7,r2,255
 90be5bc:	e0bffc17 	ldw	r2,-16(fp)
 90be5c0:	10800717 	ldw	r2,28(r2)
 90be5c4:	1004d43a 	srli	r2,r2,16
 90be5c8:	10c03fcc 	andi	r3,r2,255
 90be5cc:	e0bffc17 	ldw	r2,-16(fp)
 90be5d0:	10800717 	ldw	r2,28(r2)
 90be5d4:	1004d63a 	srli	r2,r2,24
 90be5d8:	d8c00015 	stw	r3,0(sp)
 90be5dc:	d8800115 	stw	r2,4(sp)
 90be5e0:	01024374 	movhi	r4,2317
 90be5e4:	21034e04 	addi	r4,r4,3384
 90be5e8:	90833900 	call	9083390 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 90be5ec:	e0bffb17 	ldw	r2,-20(fp)
 90be5f0:	11403fcc 	andi	r5,r2,255
 90be5f4:	e0bffb17 	ldw	r2,-20(fp)
 90be5f8:	1004d23a 	srli	r2,r2,8
 90be5fc:	11803fcc 	andi	r6,r2,255
 90be600:	e0bffb17 	ldw	r2,-20(fp)
 90be604:	1004d43a 	srli	r2,r2,16
 90be608:	11c03fcc 	andi	r7,r2,255
 90be60c:	e0bffb17 	ldw	r2,-20(fp)
 90be610:	1004d63a 	srli	r2,r2,24
 90be614:	d8800015 	stw	r2,0(sp)
 90be618:	01024374 	movhi	r4,2317
 90be61c:	21035704 	addi	r4,r4,3420
 90be620:	90833900 	call	9083390 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 90be624:	e0bffc17 	ldw	r2,-16(fp)
 90be628:	10800617 	ldw	r2,24(r2)
 90be62c:	10c00a17 	ldw	r3,40(r2)
 90be630:	e0bffc17 	ldw	r2,-16(fp)
 90be634:	10800717 	ldw	r2,28(r2)
 90be638:	18802a1e 	bne	r3,r2,90be6e4 <ip_write_internal+0x5a0>
 90be63c:	e0bffc17 	ldw	r2,-16(fp)
 90be640:	10800717 	ldw	r2,28(r2)
 90be644:	10803fcc 	andi	r2,r2,255
 90be648:	10801fe0 	cmpeqi	r2,r2,127
 90be64c:	1000251e 	bne	r2,zero,90be6e4 <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 90be650:	e0bffc17 	ldw	r2,-16(fp)
 90be654:	10800617 	ldw	r2,24(r2)
 90be658:	10802a17 	ldw	r2,168(r2)
 90be65c:	1080020c 	andi	r2,r2,8
 90be660:	1004c03a 	cmpne	r2,r2,zero
 90be664:	10000a1e 	bne	r2,zero,90be690 <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 90be668:	90aa4780 	call	90aa478 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be66c:	01000084 	movi	r4,2
 90be670:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90be674:	e13ffc17 	ldw	r4,-16(fp)
 90be678:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be67c:	01000084 	movi	r4,2
 90be680:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 90be684:	00bffd44 	movi	r2,-11
 90be688:	e0bffd15 	stw	r2,-12(fp)
 90be68c:	00008706 	br	90be8ac <ip_write_internal+0x768>
      }
      p->type = IPTP;
 90be690:	e0fffc17 	ldw	r3,-16(fp)
 90be694:	00800204 	movi	r2,8
 90be698:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 90be69c:	0009883a 	mov	r4,zero
 90be6a0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 90be6a4:	01000044 	movi	r4,1
 90be6a8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 90be6ac:	e17ffc17 	ldw	r5,-16(fp)
 90be6b0:	010243b4 	movhi	r4,2318
 90be6b4:	21352104 	addi	r4,r4,-11132
 90be6b8:	90a9e080 	call	90a9e08 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 90be6bc:	01000044 	movi	r4,1
 90be6c0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 90be6c4:	0009883a 	mov	r4,zero
 90be6c8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 90be6cc:	00824374 	movhi	r2,2317
 90be6d0:	108f3104 	addi	r2,r2,15556
 90be6d4:	11000017 	ldw	r4,0(r2)
 90be6d8:	90940540 	call	9094054 <OSSemPost>

      return SUCCESS;
 90be6dc:	e03ffd15 	stw	zero,-12(fp)
 90be6e0:	00007206 	br	90be8ac <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 90be6e4:	e0bffc17 	ldw	r2,-16(fp)
 90be6e8:	10800a17 	ldw	r2,40(r2)
 90be6ec:	1080040c 	andi	r2,r2,16
 90be6f0:	1005003a 	cmpeq	r2,r2,zero
 90be6f4:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 90be6f8:	90a9c740 	call	90a9c74 <pk_get_max_intrsafe_buf_len>
 90be6fc:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 90be700:	e0bff603 	ldbu	r2,-40(fp)
 90be704:	1004c03a 	cmpne	r2,r2,zero
 90be708:	10000e1e 	bne	r2,zero,90be744 <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 90be70c:	e0bffc17 	ldw	r2,-16(fp)
 90be710:	10800617 	ldw	r2,24(r2)
 90be714:	10800917 	ldw	r2,36(r2)
 90be718:	e0fff317 	ldw	r3,-52(fp)
 90be71c:	e0ffff15 	stw	r3,-4(fp)
 90be720:	e0bffe15 	stw	r2,-8(fp)
 90be724:	e0bfff17 	ldw	r2,-4(fp)
 90be728:	e0fffe17 	ldw	r3,-8(fp)
 90be72c:	10c0022e 	bgeu	r2,r3,90be738 <ip_write_internal+0x5f4>
 90be730:	e0bfff17 	ldw	r2,-4(fp)
 90be734:	e0bffe15 	stw	r2,-8(fp)
 90be738:	e0fffe17 	ldw	r3,-8(fp)
 90be73c:	e0fff515 	stw	r3,-44(fp)
 90be740:	00000406 	br	90be754 <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 90be744:	e0bffc17 	ldw	r2,-16(fp)
 90be748:	10800617 	ldw	r2,24(r2)
 90be74c:	10800917 	ldw	r2,36(r2)
 90be750:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 90be754:	e0bffc17 	ldw	r2,-16(fp)
 90be758:	10c00417 	ldw	r3,16(r2)
 90be75c:	e0bffc17 	ldw	r2,-16(fp)
 90be760:	10800617 	ldw	r2,24(r2)
 90be764:	10800817 	ldw	r2,32(r2)
 90be768:	1887883a 	add	r3,r3,r2
 90be76c:	e0bff517 	ldw	r2,-44(fp)
 90be770:	10c0072e 	bgeu	r2,r3,90be790 <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 90be774:	e17ffb17 	ldw	r5,-20(fp)
 90be778:	e13ffc17 	ldw	r4,-16(fp)
 90be77c:	90bf41c0 	call	90bf41c <ip_fragment>
 90be780:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 90be784:	e0bff217 	ldw	r2,-56(fp)
 90be788:	e0bffd15 	stw	r2,-12(fp)
 90be78c:	00004706 	br	90be8ac <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 90be790:	e0bff603 	ldbu	r2,-40(fp)
 90be794:	1004c03a 	cmpne	r2,r2,zero
 90be798:	1000401e 	bne	r2,zero,90be89c <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90be79c:	01000084 	movi	r4,2
 90be7a0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 90be7a4:	e0bffc17 	ldw	r2,-16(fp)
 90be7a8:	10c00417 	ldw	r3,16(r2)
 90be7ac:	e0bffc17 	ldw	r2,-16(fp)
 90be7b0:	10800617 	ldw	r2,24(r2)
 90be7b4:	10800817 	ldw	r2,32(r2)
 90be7b8:	1889883a 	add	r4,r3,r2
 90be7bc:	90a98340 	call	90a9834 <pk_alloc>
 90be7c0:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be7c4:	01000084 	movi	r4,2
 90be7c8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 90be7cc:	e0bff417 	ldw	r2,-48(fp)
 90be7d0:	1004c03a 	cmpne	r2,r2,zero
 90be7d4:	1000091e 	bne	r2,zero,90be7fc <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90be7d8:	01000084 	movi	r4,2
 90be7dc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90be7e0:	e13ffc17 	ldw	r4,-16(fp)
 90be7e4:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be7e8:	01000084 	movi	r4,2
 90be7ec:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 90be7f0:	00fffac4 	movi	r3,-21
 90be7f4:	e0fffd15 	stw	r3,-12(fp)
 90be7f8:	00002c06 	br	90be8ac <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 90be7fc:	e0bff417 	ldw	r2,-48(fp)
 90be800:	10c00117 	ldw	r3,4(r2)
 90be804:	e0bffc17 	ldw	r2,-16(fp)
 90be808:	10800617 	ldw	r2,24(r2)
 90be80c:	10800817 	ldw	r2,32(r2)
 90be810:	1887883a 	add	r3,r3,r2
 90be814:	e0bff417 	ldw	r2,-48(fp)
 90be818:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 90be81c:	e0bff417 	ldw	r2,-48(fp)
 90be820:	10c00317 	ldw	r3,12(r2)
 90be824:	e0bffc17 	ldw	r2,-16(fp)
 90be828:	11400317 	ldw	r5,12(r2)
 90be82c:	e0bffc17 	ldw	r2,-16(fp)
 90be830:	10800417 	ldw	r2,16(r2)
 90be834:	1809883a 	mov	r4,r3
 90be838:	100d883a 	mov	r6,r2
 90be83c:	90894600 	call	9089460 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 90be840:	e0bffc17 	ldw	r2,-16(fp)
 90be844:	10c00417 	ldw	r3,16(r2)
 90be848:	e0bff417 	ldw	r2,-48(fp)
 90be84c:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 90be850:	e0bffc17 	ldw	r2,-16(fp)
 90be854:	10c00617 	ldw	r3,24(r2)
 90be858:	e0bff417 	ldw	r2,-48(fp)
 90be85c:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 90be860:	e0bffc17 	ldw	r2,-16(fp)
 90be864:	10c00717 	ldw	r3,28(r2)
 90be868:	e0bff417 	ldw	r2,-48(fp)
 90be86c:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90be870:	01000084 	movi	r4,2
 90be874:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90be878:	e13ffc17 	ldw	r4,-16(fp)
 90be87c:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90be880:	01000084 	movi	r4,2
 90be884:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 90be888:	e17ffb17 	ldw	r5,-20(fp)
 90be88c:	e13ff417 	ldw	r4,-48(fp)
 90be890:	90a2b440 	call	90a2b44 <ip2mac>
 90be894:	e0bffd15 	stw	r2,-12(fp)
 90be898:	00000406 	br	90be8ac <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 90be89c:	e17ffb17 	ldw	r5,-20(fp)
 90be8a0:	e13ffc17 	ldw	r4,-16(fp)
 90be8a4:	90a2b440 	call	90a2b44 <ip2mac>
 90be8a8:	e0bffd15 	stw	r2,-12(fp)
 90be8ac:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 90be8b0:	e037883a 	mov	sp,fp
 90be8b4:	dfc00117 	ldw	ra,4(sp)
 90be8b8:	df000017 	ldw	fp,0(sp)
 90be8bc:	dec00204 	addi	sp,sp,8
 90be8c0:	f800283a 	ret

090be8c4 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 90be8c4:	defff904 	addi	sp,sp,-28
 90be8c8:	dfc00615 	stw	ra,24(sp)
 90be8cc:	df000515 	stw	fp,20(sp)
 90be8d0:	df000504 	addi	fp,sp,20
 90be8d4:	e17fff15 	stw	r5,-4(fp)
 90be8d8:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90be8dc:	008243b4 	movhi	r2,2318
 90be8e0:	10b82c04 	addi	r2,r2,-8016
 90be8e4:	10800917 	ldw	r2,36(r2)
 90be8e8:	10c00044 	addi	r3,r2,1
 90be8ec:	008243b4 	movhi	r2,2318
 90be8f0:	10b82c04 	addi	r2,r2,-8016
 90be8f4:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 90be8f8:	e0bfff17 	ldw	r2,-4(fp)
 90be8fc:	10800317 	ldw	r2,12(r2)
 90be900:	10fffb04 	addi	r3,r2,-20
 90be904:	e0bfff17 	ldw	r2,-4(fp)
 90be908:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 90be90c:	e0bfff17 	ldw	r2,-4(fp)
 90be910:	10800417 	ldw	r2,16(r2)
 90be914:	10c00504 	addi	r3,r2,20
 90be918:	e0bfff17 	ldw	r2,-4(fp)
 90be91c:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 90be920:	e0bfff17 	ldw	r2,-4(fp)
 90be924:	10800317 	ldw	r2,12(r2)
 90be928:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 90be92c:	e0fffd17 	ldw	r3,-12(fp)
 90be930:	00801144 	movi	r2,69
 90be934:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 90be938:	e0bffd17 	ldw	r2,-12(fp)
 90be93c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 90be940:	d0a05017 	ldw	r2,-32448(gp)
 90be944:	10bfffcc 	andi	r2,r2,65535
 90be948:	1004d23a 	srli	r2,r2,8
 90be94c:	10803fcc 	andi	r2,r2,255
 90be950:	1009883a 	mov	r4,r2
 90be954:	d0a05017 	ldw	r2,-32448(gp)
 90be958:	10bfffcc 	andi	r2,r2,65535
 90be95c:	1004923a 	slli	r2,r2,8
 90be960:	1007883a 	mov	r3,r2
 90be964:	00bfc004 	movi	r2,-256
 90be968:	1884703a 	and	r2,r3,r2
 90be96c:	2084b03a 	or	r2,r4,r2
 90be970:	1007883a 	mov	r3,r2
 90be974:	e0bffd17 	ldw	r2,-12(fp)
 90be978:	10c0010d 	sth	r3,4(r2)
   uid++;
 90be97c:	d0a05017 	ldw	r2,-32448(gp)
 90be980:	10800044 	addi	r2,r2,1
 90be984:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 90be988:	e0bfff17 	ldw	r2,-4(fp)
 90be98c:	10800417 	ldw	r2,16(r2)
 90be990:	10bfffcc 	andi	r2,r2,65535
 90be994:	1004d23a 	srli	r2,r2,8
 90be998:	10803fcc 	andi	r2,r2,255
 90be99c:	1009883a 	mov	r4,r2
 90be9a0:	e0bfff17 	ldw	r2,-4(fp)
 90be9a4:	10800417 	ldw	r2,16(r2)
 90be9a8:	10bfffcc 	andi	r2,r2,65535
 90be9ac:	1004923a 	slli	r2,r2,8
 90be9b0:	1007883a 	mov	r3,r2
 90be9b4:	00bfc004 	movi	r2,-256
 90be9b8:	1884703a 	and	r2,r3,r2
 90be9bc:	2084b03a 	or	r2,r4,r2
 90be9c0:	1007883a 	mov	r3,r2
 90be9c4:	e0bffd17 	ldw	r2,-12(fp)
 90be9c8:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 90be9cc:	e0fffd17 	ldw	r3,-12(fp)
 90be9d0:	e0bffe03 	ldbu	r2,-8(fp)
 90be9d4:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90be9d8:	e0bffd17 	ldw	r2,-12(fp)
 90be9dc:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 90be9e0:	00801004 	movi	r2,64
 90be9e4:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 90be9e8:	e0bfff17 	ldw	r2,-4(fp)
 90be9ec:	10800717 	ldw	r2,28(r2)
 90be9f0:	1004d63a 	srli	r2,r2,24
 90be9f4:	10c03fcc 	andi	r3,r2,255
 90be9f8:	e0bfff17 	ldw	r2,-4(fp)
 90be9fc:	10800717 	ldw	r2,28(r2)
 90bea00:	1004d23a 	srli	r2,r2,8
 90bea04:	10bfc00c 	andi	r2,r2,65280
 90bea08:	1886b03a 	or	r3,r3,r2
 90bea0c:	e0bfff17 	ldw	r2,-4(fp)
 90bea10:	10800717 	ldw	r2,28(r2)
 90bea14:	10bfc00c 	andi	r2,r2,65280
 90bea18:	1004923a 	slli	r2,r2,8
 90bea1c:	1886b03a 	or	r3,r3,r2
 90bea20:	e0bfff17 	ldw	r2,-4(fp)
 90bea24:	10800717 	ldw	r2,28(r2)
 90bea28:	10803fcc 	andi	r2,r2,255
 90bea2c:	1004963a 	slli	r2,r2,24
 90bea30:	1884b03a 	or	r2,r3,r2
 90bea34:	10fc002c 	andhi	r3,r2,61440
 90bea38:	00b80034 	movhi	r2,57344
 90bea3c:	1880081e 	bne	r3,r2,90bea60 <ip_write+0x19c>
 90bea40:	e0bfff17 	ldw	r2,-4(fp)
 90bea44:	10800b17 	ldw	r2,44(r2)
 90bea48:	1005003a 	cmpeq	r2,r2,zero
 90bea4c:	1000041e 	bne	r2,zero,90bea60 <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 90bea50:	e0bfff17 	ldw	r2,-4(fp)
 90bea54:	10800b17 	ldw	r2,44(r2)
 90bea58:	10800103 	ldbu	r2,4(r2)
 90bea5c:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 90bea60:	e0bfff17 	ldw	r2,-4(fp)
 90bea64:	10800c17 	ldw	r2,48(r2)
 90bea68:	e0bffb15 	stw	r2,-20(fp)
 90bea6c:	e0bffb17 	ldw	r2,-20(fp)
 90bea70:	1005003a 	cmpeq	r2,r2,zero
 90bea74:	1000121e 	bne	r2,zero,90beac0 <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 90bea78:	e0bffb17 	ldw	r2,-20(fp)
 90bea7c:	10800043 	ldbu	r2,1(r2)
 90bea80:	10803fcc 	andi	r2,r2,255
 90bea84:	1005003a 	cmpeq	r2,r2,zero
 90bea88:	1000051e 	bne	r2,zero,90beaa0 <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 90bea8c:	e0bffb17 	ldw	r2,-20(fp)
 90bea90:	10c00043 	ldbu	r3,1(r2)
 90bea94:	e0bffd17 	ldw	r2,-12(fp)
 90bea98:	10c00205 	stb	r3,8(r2)
 90bea9c:	00000306 	br	90beaac <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 90beaa0:	e0fffd17 	ldw	r3,-12(fp)
 90beaa4:	e0bffc03 	ldbu	r2,-16(fp)
 90beaa8:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90beaac:	e0bffb17 	ldw	r2,-20(fp)
 90beab0:	10c00003 	ldbu	r3,0(r2)
 90beab4:	e0bffd17 	ldw	r2,-12(fp)
 90beab8:	10c00045 	stb	r3,1(r2)
 90beabc:	00000506 	br	90bead4 <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 90beac0:	e0bffd17 	ldw	r2,-12(fp)
 90beac4:	e0fffc03 	ldbu	r3,-16(fp)
 90beac8:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90beacc:	e0bffd17 	ldw	r2,-12(fp)
 90bead0:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 90bead4:	e13ffd17 	ldw	r4,-12(fp)
 90bead8:	01400284 	movi	r5,10
 90beadc:	90a4ef40 	call	90a4ef4 <cksum>
 90beae0:	0084303a 	nor	r2,zero,r2
 90beae4:	1007883a 	mov	r3,r2
 90beae8:	e0bffd17 	ldw	r2,-12(fp)
 90beaec:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 90beaf0:	e13fff17 	ldw	r4,-4(fp)
 90beaf4:	90be1440 	call	90be144 <ip_write_internal>
}
 90beaf8:	e037883a 	mov	sp,fp
 90beafc:	dfc00117 	ldw	ra,4(sp)
 90beb00:	df000017 	ldw	fp,0(sp)
 90beb04:	dec00204 	addi	sp,sp,8
 90beb08:	f800283a 	ret

090beb0c <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 90beb0c:	defff504 	addi	sp,sp,-44
 90beb10:	dfc00a15 	stw	ra,40(sp)
 90beb14:	df000915 	stw	fp,36(sp)
 90beb18:	df000904 	addi	fp,sp,36
 90beb1c:	e17ffe15 	stw	r5,-8(fp)
 90beb20:	e1bfff15 	stw	r6,-4(fp)
 90beb24:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 90beb28:	00800504 	movi	r2,20
 90beb2c:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90beb30:	008243b4 	movhi	r2,2318
 90beb34:	10b82c04 	addi	r2,r2,-8016
 90beb38:	10800917 	ldw	r2,36(r2)
 90beb3c:	10c00044 	addi	r3,r2,1
 90beb40:	008243b4 	movhi	r2,2318
 90beb44:	10b82c04 	addi	r2,r2,-8016
 90beb48:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 90beb4c:	e0bfff17 	ldw	r2,-4(fp)
 90beb50:	e0bff815 	stw	r2,-32(fp)
 90beb54:	00000c06 	br	90beb88 <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 90beb58:	e0bff817 	ldw	r2,-32(fp)
 90beb5c:	10800003 	ldbu	r2,0(r2)
 90beb60:	10803fcc 	andi	r2,r2,255
 90beb64:	10800520 	cmpeqi	r2,r2,20
 90beb68:	1000011e 	bne	r2,zero,90beb70 <ip_write2+0x64>
 90beb6c:	00000306 	br	90beb7c <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 90beb70:	e0bff903 	ldbu	r2,-28(fp)
 90beb74:	10800104 	addi	r2,r2,4
 90beb78:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 90beb7c:	e0bff817 	ldw	r2,-32(fp)
 90beb80:	10800044 	addi	r2,r2,1
 90beb84:	e0bff815 	stw	r2,-32(fp)
 90beb88:	e0bff817 	ldw	r2,-32(fp)
 90beb8c:	10800003 	ldbu	r2,0(r2)
 90beb90:	10803fcc 	andi	r2,r2,255
 90beb94:	1004c03a 	cmpne	r2,r2,zero
 90beb98:	103fef1e 	bne	r2,zero,90beb58 <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 90beb9c:	e0bff903 	ldbu	r2,-28(fp)
 90beba0:	108000cc 	andi	r2,r2,3
 90beba4:	1005003a 	cmpeq	r2,r2,zero
 90beba8:	1000071e 	bne	r2,zero,90bebc8 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 90bebac:	e0bff903 	ldbu	r2,-28(fp)
 90bebb0:	108000cc 	andi	r2,r2,3
 90bebb4:	1007883a 	mov	r3,r2
 90bebb8:	00800104 	movi	r2,4
 90bebbc:	10c5c83a 	sub	r2,r2,r3
 90bebc0:	e0bff745 	stb	r2,-35(fp)
 90bebc4:	00000106 	br	90bebcc <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 90bebc8:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 90bebcc:	e0bffe17 	ldw	r2,-8(fp)
 90bebd0:	11000317 	ldw	r4,12(r2)
 90bebd4:	e0fff903 	ldbu	r3,-28(fp)
 90bebd8:	e0bff743 	ldbu	r2,-35(fp)
 90bebdc:	1885883a 	add	r2,r3,r2
 90bebe0:	2087c83a 	sub	r3,r4,r2
 90bebe4:	e0bffe17 	ldw	r2,-8(fp)
 90bebe8:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 90bebec:	e0bffe17 	ldw	r2,-8(fp)
 90bebf0:	11000417 	ldw	r4,16(r2)
 90bebf4:	e0fff903 	ldbu	r3,-28(fp)
 90bebf8:	e0bff743 	ldbu	r2,-35(fp)
 90bebfc:	1885883a 	add	r2,r3,r2
 90bec00:	2087883a 	add	r3,r4,r2
 90bec04:	e0bffe17 	ldw	r2,-8(fp)
 90bec08:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 90bec0c:	e0bffe17 	ldw	r2,-8(fp)
 90bec10:	10800317 	ldw	r2,12(r2)
 90bec14:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 90bec18:	e0fff903 	ldbu	r3,-28(fp)
 90bec1c:	e0bff743 	ldbu	r2,-35(fp)
 90bec20:	1885883a 	add	r2,r3,r2
 90bec24:	1005d0ba 	srai	r2,r2,2
 90bec28:	10801014 	ori	r2,r2,64
 90bec2c:	1007883a 	mov	r3,r2
 90bec30:	e0bffc17 	ldw	r2,-16(fp)
 90bec34:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 90bec38:	e0bffc17 	ldw	r2,-16(fp)
 90bec3c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 90bec40:	d0a05017 	ldw	r2,-32448(gp)
 90bec44:	10bfffcc 	andi	r2,r2,65535
 90bec48:	1004d23a 	srli	r2,r2,8
 90bec4c:	10803fcc 	andi	r2,r2,255
 90bec50:	1009883a 	mov	r4,r2
 90bec54:	d0a05017 	ldw	r2,-32448(gp)
 90bec58:	10bfffcc 	andi	r2,r2,65535
 90bec5c:	1004923a 	slli	r2,r2,8
 90bec60:	1007883a 	mov	r3,r2
 90bec64:	00bfc004 	movi	r2,-256
 90bec68:	1884703a 	and	r2,r3,r2
 90bec6c:	2084b03a 	or	r2,r4,r2
 90bec70:	1007883a 	mov	r3,r2
 90bec74:	e0bffc17 	ldw	r2,-16(fp)
 90bec78:	10c0010d 	sth	r3,4(r2)
   uid++;
 90bec7c:	d0a05017 	ldw	r2,-32448(gp)
 90bec80:	10800044 	addi	r2,r2,1
 90bec84:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 90bec88:	e0bffe17 	ldw	r2,-8(fp)
 90bec8c:	10800417 	ldw	r2,16(r2)
 90bec90:	10bfffcc 	andi	r2,r2,65535
 90bec94:	1004d23a 	srli	r2,r2,8
 90bec98:	10803fcc 	andi	r2,r2,255
 90bec9c:	1009883a 	mov	r4,r2
 90beca0:	e0bffe17 	ldw	r2,-8(fp)
 90beca4:	10800417 	ldw	r2,16(r2)
 90beca8:	10bfffcc 	andi	r2,r2,65535
 90becac:	1004923a 	slli	r2,r2,8
 90becb0:	1007883a 	mov	r3,r2
 90becb4:	00bfc004 	movi	r2,-256
 90becb8:	1884703a 	and	r2,r3,r2
 90becbc:	2084b03a 	or	r2,r4,r2
 90becc0:	1007883a 	mov	r3,r2
 90becc4:	e0bffc17 	ldw	r2,-16(fp)
 90becc8:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 90beccc:	e0fffc17 	ldw	r3,-16(fp)
 90becd0:	e0bffd03 	ldbu	r2,-12(fp)
 90becd4:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90becd8:	e0bffc17 	ldw	r2,-16(fp)
 90becdc:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 90bece0:	00801004 	movi	r2,64
 90bece4:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 90bece8:	e0bffe17 	ldw	r2,-8(fp)
 90becec:	10800717 	ldw	r2,28(r2)
 90becf0:	1004d63a 	srli	r2,r2,24
 90becf4:	10c03fcc 	andi	r3,r2,255
 90becf8:	e0bffe17 	ldw	r2,-8(fp)
 90becfc:	10800717 	ldw	r2,28(r2)
 90bed00:	1004d23a 	srli	r2,r2,8
 90bed04:	10bfc00c 	andi	r2,r2,65280
 90bed08:	1886b03a 	or	r3,r3,r2
 90bed0c:	e0bffe17 	ldw	r2,-8(fp)
 90bed10:	10800717 	ldw	r2,28(r2)
 90bed14:	10bfc00c 	andi	r2,r2,65280
 90bed18:	1004923a 	slli	r2,r2,8
 90bed1c:	1886b03a 	or	r3,r3,r2
 90bed20:	e0bffe17 	ldw	r2,-8(fp)
 90bed24:	10800717 	ldw	r2,28(r2)
 90bed28:	10803fcc 	andi	r2,r2,255
 90bed2c:	1004963a 	slli	r2,r2,24
 90bed30:	1884b03a 	or	r2,r3,r2
 90bed34:	10fc002c 	andhi	r3,r2,61440
 90bed38:	00b80034 	movhi	r2,57344
 90bed3c:	1880081e 	bne	r3,r2,90bed60 <ip_write2+0x254>
 90bed40:	e0bffe17 	ldw	r2,-8(fp)
 90bed44:	10800b17 	ldw	r2,44(r2)
 90bed48:	1005003a 	cmpeq	r2,r2,zero
 90bed4c:	1000041e 	bne	r2,zero,90bed60 <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 90bed50:	e0bffe17 	ldw	r2,-8(fp)
 90bed54:	10800b17 	ldw	r2,44(r2)
 90bed58:	10800103 	ldbu	r2,4(r2)
 90bed5c:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 90bed60:	e0bffe17 	ldw	r2,-8(fp)
 90bed64:	10800c17 	ldw	r2,48(r2)
 90bed68:	e0bffa15 	stw	r2,-24(fp)
 90bed6c:	e0bffa17 	ldw	r2,-24(fp)
 90bed70:	1005003a 	cmpeq	r2,r2,zero
 90bed74:	1000121e 	bne	r2,zero,90bedc0 <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 90bed78:	e0bffa17 	ldw	r2,-24(fp)
 90bed7c:	10800043 	ldbu	r2,1(r2)
 90bed80:	10803fcc 	andi	r2,r2,255
 90bed84:	1005003a 	cmpeq	r2,r2,zero
 90bed88:	1000051e 	bne	r2,zero,90beda0 <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 90bed8c:	e0bffa17 	ldw	r2,-24(fp)
 90bed90:	10c00043 	ldbu	r3,1(r2)
 90bed94:	e0bffc17 	ldw	r2,-16(fp)
 90bed98:	10c00205 	stb	r3,8(r2)
 90bed9c:	00000306 	br	90bedac <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 90beda0:	e0fffc17 	ldw	r3,-16(fp)
 90beda4:	e0bffb03 	ldbu	r2,-20(fp)
 90beda8:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 90bedac:	e0bffa17 	ldw	r2,-24(fp)
 90bedb0:	10c00003 	ldbu	r3,0(r2)
 90bedb4:	e0bffc17 	ldw	r2,-16(fp)
 90bedb8:	10c00045 	stb	r3,1(r2)
 90bedbc:	00000506 	br	90bedd4 <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 90bedc0:	e0bffc17 	ldw	r2,-16(fp)
 90bedc4:	e0fffb03 	ldbu	r3,-20(fp)
 90bedc8:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 90bedcc:	e0bffc17 	ldw	r2,-16(fp)
 90bedd0:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 90bedd4:	e0bffe17 	ldw	r2,-8(fp)
 90bedd8:	10800317 	ldw	r2,12(r2)
 90beddc:	10800504 	addi	r2,r2,20
 90bede0:	e0bff815 	stw	r2,-32(fp)
 90bede4:	00000f06 	br	90bee24 <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 90bede8:	e0bfff17 	ldw	r2,-4(fp)
 90bedec:	10800003 	ldbu	r2,0(r2)
 90bedf0:	10803fcc 	andi	r2,r2,255
 90bedf4:	10800520 	cmpeqi	r2,r2,20
 90bedf8:	1000011e 	bne	r2,zero,90bee00 <ip_write2+0x2f4>
 90bedfc:	00000606 	br	90bee18 <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 90bee00:	e0fff817 	ldw	r3,-32(fp)
 90bee04:	00812504 	movi	r2,1172
 90bee08:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 90bee0c:	e0bff817 	ldw	r2,-32(fp)
 90bee10:	10800104 	addi	r2,r2,4
 90bee14:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 90bee18:	e0bfff17 	ldw	r2,-4(fp)
 90bee1c:	10800044 	addi	r2,r2,1
 90bee20:	e0bfff15 	stw	r2,-4(fp)
 90bee24:	e0bfff17 	ldw	r2,-4(fp)
 90bee28:	10800003 	ldbu	r2,0(r2)
 90bee2c:	10803fcc 	andi	r2,r2,255
 90bee30:	1004c03a 	cmpne	r2,r2,zero
 90bee34:	103fec1e 	bne	r2,zero,90bede8 <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 90bee38:	e03ff705 	stb	zero,-36(fp)
 90bee3c:	00000806 	br	90bee60 <ip_write2+0x354>
 90bee40:	e0bff703 	ldbu	r2,-36(fp)
 90bee44:	1007883a 	mov	r3,r2
 90bee48:	e0bff817 	ldw	r2,-32(fp)
 90bee4c:	1885883a 	add	r2,r3,r2
 90bee50:	10000005 	stb	zero,0(r2)
 90bee54:	e0bff703 	ldbu	r2,-36(fp)
 90bee58:	10800044 	addi	r2,r2,1
 90bee5c:	e0bff705 	stb	r2,-36(fp)
 90bee60:	e0fff703 	ldbu	r3,-36(fp)
 90bee64:	e0bff743 	ldbu	r2,-35(fp)
 90bee68:	18bff536 	bltu	r3,r2,90bee40 <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 90bee6c:	e0fff903 	ldbu	r3,-28(fp)
 90bee70:	e0bff743 	ldbu	r2,-35(fp)
 90bee74:	1887883a 	add	r3,r3,r2
 90bee78:	1804d7fa 	srli	r2,r3,31
 90bee7c:	10c5883a 	add	r2,r2,r3
 90bee80:	1005d07a 	srai	r2,r2,1
 90bee84:	100b883a 	mov	r5,r2
 90bee88:	e13ffc17 	ldw	r4,-16(fp)
 90bee8c:	90a4ef40 	call	90a4ef4 <cksum>
 90bee90:	0084303a 	nor	r2,zero,r2
 90bee94:	1007883a 	mov	r3,r2
 90bee98:	e0bffc17 	ldw	r2,-16(fp)
 90bee9c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 90beea0:	e13ffe17 	ldw	r4,-8(fp)
 90beea4:	90be1440 	call	90be144 <ip_write_internal>
}
 90beea8:	e037883a 	mov	sp,fp
 90beeac:	dfc00117 	ldw	ra,4(sp)
 90beeb0:	df000017 	ldw	fp,0(sp)
 90beeb4:	dec00204 	addi	sp,sp,8
 90beeb8:	f800283a 	ret

090beebc <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 90beebc:	defffc04 	addi	sp,sp,-16
 90beec0:	dfc00315 	stw	ra,12(sp)
 90beec4:	df000215 	stw	fp,8(sp)
 90beec8:	df000204 	addi	fp,sp,8
 90beecc:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 90beed0:	008243b4 	movhi	r2,2318
 90beed4:	10b82c04 	addi	r2,r2,-8016
 90beed8:	10800917 	ldw	r2,36(r2)
 90beedc:	10c00044 	addi	r3,r2,1
 90beee0:	008243b4 	movhi	r2,2318
 90beee4:	10b82c04 	addi	r2,r2,-8016
 90beee8:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 90beeec:	e0bfff17 	ldw	r2,-4(fp)
 90beef0:	10800317 	ldw	r2,12(r2)
 90beef4:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 90beef8:	e0bffe17 	ldw	r2,-8(fp)
 90beefc:	1080010b 	ldhu	r2,4(r2)
 90bef00:	10bfffcc 	andi	r2,r2,65535
 90bef04:	1004c03a 	cmpne	r2,r2,zero
 90bef08:	1000121e 	bne	r2,zero,90bef54 <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 90bef0c:	d0a05017 	ldw	r2,-32448(gp)
 90bef10:	10bfffcc 	andi	r2,r2,65535
 90bef14:	1004d23a 	srli	r2,r2,8
 90bef18:	10803fcc 	andi	r2,r2,255
 90bef1c:	1009883a 	mov	r4,r2
 90bef20:	d0a05017 	ldw	r2,-32448(gp)
 90bef24:	10bfffcc 	andi	r2,r2,65535
 90bef28:	1004923a 	slli	r2,r2,8
 90bef2c:	1007883a 	mov	r3,r2
 90bef30:	00bfc004 	movi	r2,-256
 90bef34:	1884703a 	and	r2,r3,r2
 90bef38:	2084b03a 	or	r2,r4,r2
 90bef3c:	1007883a 	mov	r3,r2
 90bef40:	e0bffe17 	ldw	r2,-8(fp)
 90bef44:	10c0010d 	sth	r3,4(r2)
      uid++;
 90bef48:	d0a05017 	ldw	r2,-32448(gp)
 90bef4c:	10800044 	addi	r2,r2,1
 90bef50:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 90bef54:	e0bffe17 	ldw	r2,-8(fp)
 90bef58:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 90bef5c:	e13ffe17 	ldw	r4,-8(fp)
 90bef60:	01400284 	movi	r5,10
 90bef64:	90a4ef40 	call	90a4ef4 <cksum>
 90bef68:	0084303a 	nor	r2,zero,r2
 90bef6c:	1007883a 	mov	r3,r2
 90bef70:	e0bffe17 	ldw	r2,-8(fp)
 90bef74:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 90bef78:	e13fff17 	ldw	r4,-4(fp)
 90bef7c:	90be1440 	call	90be144 <ip_write_internal>
}
 90bef80:	e037883a 	mov	sp,fp
 90bef84:	dfc00117 	ldw	ra,4(sp)
 90bef88:	df000017 	ldw	fp,0(sp)
 90bef8c:	dec00204 	addi	sp,sp,8
 90bef90:	f800283a 	ret

090bef94 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 90bef94:	deffed04 	addi	sp,sp,-76
 90bef98:	dfc01215 	stw	ra,72(sp)
 90bef9c:	df001115 	stw	fp,68(sp)
 90befa0:	df001104 	addi	fp,sp,68
 90befa4:	e13ffa15 	stw	r4,-24(fp)
 90befa8:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 90befac:	008243b4 	movhi	r2,2318
 90befb0:	10b82c04 	addi	r2,r2,-8016
 90befb4:	10801017 	ldw	r2,64(r2)
 90befb8:	10c00044 	addi	r3,r2,1
 90befbc:	008243b4 	movhi	r2,2318
 90befc0:	10b82c04 	addi	r2,r2,-8016
 90befc4:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 90befc8:	e0bffa17 	ldw	r2,-24(fp)
 90befcc:	10800317 	ldw	r2,12(r2)
 90befd0:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 90befd4:	e0bff117 	ldw	r2,-60(fp)
 90befd8:	10800003 	ldbu	r2,0(r2)
 90befdc:	10803fcc 	andi	r2,r2,255
 90befe0:	108003cc 	andi	r2,r2,15
 90befe4:	1085883a 	add	r2,r2,r2
 90befe8:	1085883a 	add	r2,r2,r2
 90befec:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 90beff0:	e0bffa17 	ldw	r2,-24(fp)
 90beff4:	10800417 	ldw	r2,16(r2)
 90beff8:	1007883a 	mov	r3,r2
 90beffc:	e0bff017 	ldw	r2,-64(fp)
 90bf000:	1885c83a 	sub	r2,r3,r2
 90bf004:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 90bf008:	e0bffa17 	ldw	r2,-24(fp)
 90bf00c:	10800617 	ldw	r2,24(r2)
 90bf010:	11000917 	ldw	r4,36(r2)
 90bf014:	e0bffa17 	ldw	r2,-24(fp)
 90bf018:	10800617 	ldw	r2,24(r2)
 90bf01c:	10c00817 	ldw	r3,32(r2)
 90bf020:	e0bff017 	ldw	r2,-64(fp)
 90bf024:	1885883a 	add	r2,r3,r2
 90bf028:	2085c83a 	sub	r2,r4,r2
 90bf02c:	10bffe04 	addi	r2,r2,-8
 90bf030:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 90bf034:	e0bff817 	ldw	r2,-32(fp)
 90bf038:	10801028 	cmpgeui	r2,r2,64
 90bf03c:	1000041e 	bne	r2,zero,90bf050 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 90bf040:	90aa4780 	call	90aa478 <dtrap>
      return ENP_LOGIC;
 90bf044:	00bffd44 	movi	r2,-11
 90bf048:	e0bffe15 	stw	r2,-8(fp)
 90bf04c:	0000ed06 	br	90bf404 <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 90bf050:	e0bffa17 	ldw	r2,-24(fp)
 90bf054:	10c00417 	ldw	r3,16(r2)
 90bf058:	e0bff817 	ldw	r2,-32(fp)
 90bf05c:	1885203a 	divu	r2,r3,r2
 90bf060:	10800044 	addi	r2,r2,1
 90bf064:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 90bf068:	e0bffa17 	ldw	r2,-24(fp)
 90bf06c:	10c00417 	ldw	r3,16(r2)
 90bf070:	e0bff717 	ldw	r2,-36(fp)
 90bf074:	1885883a 	add	r2,r3,r2
 90bf078:	10ffffc4 	addi	r3,r2,-1
 90bf07c:	e0bff717 	ldw	r2,-36(fp)
 90bf080:	1885203a 	divu	r2,r3,r2
 90bf084:	10c001c4 	addi	r3,r2,7
 90bf088:	00bffe04 	movi	r2,-8
 90bf08c:	1884703a 	and	r2,r3,r2
 90bf090:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 90bf094:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 90bf098:	e0bff117 	ldw	r2,-60(fp)
 90bf09c:	1080018b 	ldhu	r2,6(r2)
 90bf0a0:	10bfffcc 	andi	r2,r2,65535
 90bf0a4:	1004d23a 	srli	r2,r2,8
 90bf0a8:	10803fcc 	andi	r2,r2,255
 90bf0ac:	1009883a 	mov	r4,r2
 90bf0b0:	e0bff117 	ldw	r2,-60(fp)
 90bf0b4:	1080018b 	ldhu	r2,6(r2)
 90bf0b8:	10bfffcc 	andi	r2,r2,65535
 90bf0bc:	1004923a 	slli	r2,r2,8
 90bf0c0:	1007883a 	mov	r3,r2
 90bf0c4:	00bfc004 	movi	r2,-256
 90bf0c8:	1884703a 	and	r2,r3,r2
 90bf0cc:	2084b03a 	or	r2,r4,r2
 90bf0d0:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 90bf0d4:	e0ffef0b 	ldhu	r3,-68(fp)
 90bf0d8:	00bffff4 	movhi	r2,65535
 90bf0dc:	1087ffc4 	addi	r2,r2,8191
 90bf0e0:	1884703a 	and	r2,r3,r2
 90bf0e4:	1005003a 	cmpeq	r2,r2,zero
 90bf0e8:	1000081e 	bne	r2,zero,90bf10c <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 90bf0ec:	e0ffef0b 	ldhu	r3,-68(fp)
 90bf0f0:	00bffff4 	movhi	r2,65535
 90bf0f4:	1087ffc4 	addi	r2,r2,8191
 90bf0f8:	1884703a 	and	r2,r3,r2
 90bf0fc:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 90bf100:	e0bff617 	ldw	r2,-40(fp)
 90bf104:	100490fa 	slli	r2,r2,3
 90bf108:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 90bf10c:	e0bffa17 	ldw	r2,-24(fp)
 90bf110:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 90bf114:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 90bf118:	0000b506 	br	90bf3f0 <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 90bf11c:	e0bff317 	ldw	r2,-52(fp)
 90bf120:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 90bf124:	e0bffa17 	ldw	r2,-24(fp)
 90bf128:	10800317 	ldw	r2,12(r2)
 90bf12c:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 90bf130:	e0bff917 	ldw	r2,-28(fp)
 90bf134:	e0fff417 	ldw	r3,-48(fp)
 90bf138:	e0ffff15 	stw	r3,-4(fp)
 90bf13c:	e0bffd15 	stw	r2,-12(fp)
 90bf140:	e0bfff17 	ldw	r2,-4(fp)
 90bf144:	e0fffd17 	ldw	r3,-12(fp)
 90bf148:	10c0020e 	bge	r2,r3,90bf154 <ip_fragment_lc+0x1c0>
 90bf14c:	e0bfff17 	ldw	r2,-4(fp)
 90bf150:	e0bffd15 	stw	r2,-12(fp)
 90bf154:	e0bff017 	ldw	r2,-64(fp)
 90bf158:	e0fffd17 	ldw	r3,-12(fp)
 90bf15c:	1885883a 	add	r2,r3,r2
 90bf160:	1007883a 	mov	r3,r2
 90bf164:	e0bffa17 	ldw	r2,-24(fp)
 90bf168:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 90bf16c:	e0fff417 	ldw	r3,-48(fp)
 90bf170:	e0bff917 	ldw	r2,-28(fp)
 90bf174:	1885c83a 	sub	r2,r3,r2
 90bf178:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 90bf17c:	e0bffa17 	ldw	r2,-24(fp)
 90bf180:	10800417 	ldw	r2,16(r2)
 90bf184:	10bfffcc 	andi	r2,r2,65535
 90bf188:	1004d23a 	srli	r2,r2,8
 90bf18c:	10803fcc 	andi	r2,r2,255
 90bf190:	1009883a 	mov	r4,r2
 90bf194:	e0bffa17 	ldw	r2,-24(fp)
 90bf198:	10800417 	ldw	r2,16(r2)
 90bf19c:	10bfffcc 	andi	r2,r2,65535
 90bf1a0:	1004923a 	slli	r2,r2,8
 90bf1a4:	1007883a 	mov	r3,r2
 90bf1a8:	00bfc004 	movi	r2,-256
 90bf1ac:	1884703a 	and	r2,r3,r2
 90bf1b0:	2084b03a 	or	r2,r4,r2
 90bf1b4:	1007883a 	mov	r3,r2
 90bf1b8:	e0bff117 	ldw	r2,-60(fp)
 90bf1bc:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 90bf1c0:	e0bff617 	ldw	r2,-40(fp)
 90bf1c4:	1004d0fa 	srli	r2,r2,3
 90bf1c8:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 90bf1cc:	e0bff417 	ldw	r2,-48(fp)
 90bf1d0:	10800090 	cmplti	r2,r2,2
 90bf1d4:	1000031e 	bne	r2,zero,90bf1e4 <ip_fragment_lc+0x250>
 90bf1d8:	00880004 	movi	r2,8192
 90bf1dc:	e0bffc0d 	sth	r2,-16(fp)
 90bf1e0:	00000106 	br	90bf1e8 <ip_fragment_lc+0x254>
 90bf1e4:	e03ffc0d 	sth	zero,-16(fp)
 90bf1e8:	e0bff50b 	ldhu	r2,-44(fp)
 90bf1ec:	e0fffc0b 	ldhu	r3,-16(fp)
 90bf1f0:	1884b03a 	or	r2,r3,r2
 90bf1f4:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 90bf1f8:	e0bfef0b 	ldhu	r2,-68(fp)
 90bf1fc:	1088000c 	andi	r2,r2,8192
 90bf200:	1005003a 	cmpeq	r2,r2,zero
 90bf204:	1000031e 	bne	r2,zero,90bf214 <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 90bf208:	e0bff50b 	ldhu	r2,-44(fp)
 90bf20c:	10880014 	ori	r2,r2,8192
 90bf210:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 90bf214:	e0bff50b 	ldhu	r2,-44(fp)
 90bf218:	1004d23a 	srli	r2,r2,8
 90bf21c:	10803fcc 	andi	r2,r2,255
 90bf220:	1009883a 	mov	r4,r2
 90bf224:	e0bff50b 	ldhu	r2,-44(fp)
 90bf228:	1004923a 	slli	r2,r2,8
 90bf22c:	1007883a 	mov	r3,r2
 90bf230:	00bfc004 	movi	r2,-256
 90bf234:	1884703a 	and	r2,r3,r2
 90bf238:	2084b03a 	or	r2,r4,r2
 90bf23c:	1007883a 	mov	r3,r2
 90bf240:	e0bff117 	ldw	r2,-60(fp)
 90bf244:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 90bf248:	e0bff417 	ldw	r2,-48(fp)
 90bf24c:	10800090 	cmplti	r2,r2,2
 90bf250:	1000401e 	bne	r2,zero,90bf354 <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf254:	01000084 	movi	r4,2
 90bf258:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 90bf25c:	e0fff417 	ldw	r3,-48(fp)
 90bf260:	e0bff017 	ldw	r2,-64(fp)
 90bf264:	1887883a 	add	r3,r3,r2
 90bf268:	00824374 	movhi	r2,2317
 90bf26c:	108f0704 	addi	r2,r2,15388
 90bf270:	10800017 	ldw	r2,0(r2)
 90bf274:	1885883a 	add	r2,r3,r2
 90bf278:	1009883a 	mov	r4,r2
 90bf27c:	90a98340 	call	90a9834 <pk_alloc>
 90bf280:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf284:	01000084 	movi	r4,2
 90bf288:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 90bf28c:	e0bff317 	ldw	r2,-52(fp)
 90bf290:	1004c03a 	cmpne	r2,r2,zero
 90bf294:	1000111e 	bne	r2,zero,90bf2dc <ip_fragment_lc+0x348>
         {
            dtrap();
 90bf298:	90aa4780 	call	90aa478 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf29c:	01000084 	movi	r4,2
 90bf2a0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90bf2a4:	e13ffa17 	ldw	r4,-24(fp)
 90bf2a8:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf2ac:	01000084 	movi	r4,2
 90bf2b0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 90bf2b4:	008243b4 	movhi	r2,2318
 90bf2b8:	10b82c04 	addi	r2,r2,-8016
 90bf2bc:	10801117 	ldw	r2,68(r2)
 90bf2c0:	10c00044 	addi	r3,r2,1
 90bf2c4:	008243b4 	movhi	r2,2318
 90bf2c8:	10b82c04 	addi	r2,r2,-8016
 90bf2cc:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 90bf2d0:	00bffa84 	movi	r2,-22
 90bf2d4:	e0bffe15 	stw	r2,-8(fp)
 90bf2d8:	00004a06 	br	90bf404 <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 90bf2dc:	e0bffa17 	ldw	r2,-24(fp)
 90bf2e0:	10c00617 	ldw	r3,24(r2)
 90bf2e4:	e0bff317 	ldw	r2,-52(fp)
 90bf2e8:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 90bf2ec:	e0bffa17 	ldw	r2,-24(fp)
 90bf2f0:	10c00717 	ldw	r3,28(r2)
 90bf2f4:	e0bff317 	ldw	r2,-52(fp)
 90bf2f8:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 90bf2fc:	e0bff317 	ldw	r2,-52(fp)
 90bf300:	11000317 	ldw	r4,12(r2)
 90bf304:	e0bffa17 	ldw	r2,-24(fp)
 90bf308:	10800317 	ldw	r2,12(r2)
 90bf30c:	e0fff017 	ldw	r3,-64(fp)
 90bf310:	100b883a 	mov	r5,r2
 90bf314:	180d883a 	mov	r6,r3
 90bf318:	90894600 	call	9089460 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 90bf31c:	e0bff317 	ldw	r2,-52(fp)
 90bf320:	10c00317 	ldw	r3,12(r2)
 90bf324:	e0bff017 	ldw	r2,-64(fp)
 90bf328:	1889883a 	add	r4,r3,r2
 90bf32c:	e0bffa17 	ldw	r2,-24(fp)
 90bf330:	10c00317 	ldw	r3,12(r2)
 90bf334:	e0bff017 	ldw	r2,-64(fp)
 90bf338:	1887883a 	add	r3,r3,r2
 90bf33c:	e0bff917 	ldw	r2,-28(fp)
 90bf340:	1885883a 	add	r2,r3,r2
 90bf344:	e0fff417 	ldw	r3,-48(fp)
 90bf348:	100b883a 	mov	r5,r2
 90bf34c:	180d883a 	mov	r6,r3
 90bf350:	90894600 	call	9089460 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 90bf354:	e0bff117 	ldw	r2,-60(fp)
 90bf358:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 90bf35c:	e13ff117 	ldw	r4,-60(fp)
 90bf360:	01400284 	movi	r5,10
 90bf364:	90a4ef40 	call	90a4ef4 <cksum>
 90bf368:	0084303a 	nor	r2,zero,r2
 90bf36c:	1007883a 	mov	r3,r2
 90bf370:	e0bff117 	ldw	r2,-60(fp)
 90bf374:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 90bf378:	e13ffa17 	ldw	r4,-24(fp)
 90bf37c:	e17ffb17 	ldw	r5,-20(fp)
 90bf380:	90a2b440 	call	90a2b44 <ip2mac>
 90bf384:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 90bf388:	008243b4 	movhi	r2,2318
 90bf38c:	10b82c04 	addi	r2,r2,-8016
 90bf390:	10801217 	ldw	r2,72(r2)
 90bf394:	10c00044 	addi	r3,r2,1
 90bf398:	008243b4 	movhi	r2,2318
 90bf39c:	10b82c04 	addi	r2,r2,-8016
 90bf3a0:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 90bf3a4:	e0bff217 	ldw	r2,-56(fp)
 90bf3a8:	1004403a 	cmpge	r2,r2,zero
 90bf3ac:	10000c1e 	bne	r2,zero,90bf3e0 <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 90bf3b0:	e0bff417 	ldw	r2,-48(fp)
 90bf3b4:	10800090 	cmplti	r2,r2,2
 90bf3b8:	1000061e 	bne	r2,zero,90bf3d4 <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf3bc:	01000084 	movi	r4,2
 90bf3c0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 90bf3c4:	e13ff317 	ldw	r4,-52(fp)
 90bf3c8:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf3cc:	01000084 	movi	r4,2
 90bf3d0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         }
         return e;
 90bf3d4:	e0fff217 	ldw	r3,-56(fp)
 90bf3d8:	e0fffe15 	stw	r3,-8(fp)
 90bf3dc:	00000906 	br	90bf404 <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 90bf3e0:	e0bff617 	ldw	r2,-40(fp)
 90bf3e4:	e0fff917 	ldw	r3,-28(fp)
 90bf3e8:	10c5883a 	add	r2,r2,r3
 90bf3ec:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 90bf3f0:	e0bff417 	ldw	r2,-48(fp)
 90bf3f4:	10800088 	cmpgei	r2,r2,2
 90bf3f8:	103f481e 	bne	r2,zero,90bf11c <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 90bf3fc:	e0bff217 	ldw	r2,-56(fp)
 90bf400:	e0bffe15 	stw	r2,-8(fp)
 90bf404:	e0bffe17 	ldw	r2,-8(fp)
}
 90bf408:	e037883a 	mov	sp,fp
 90bf40c:	dfc00117 	ldw	ra,4(sp)
 90bf410:	df000017 	ldw	fp,0(sp)
 90bf414:	dec00204 	addi	sp,sp,8
 90bf418:	f800283a 	ret

090bf41c <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 90bf41c:	deffed04 	addi	sp,sp,-76
 90bf420:	dfc01215 	stw	ra,72(sp)
 90bf424:	df001115 	stw	fp,68(sp)
 90bf428:	df001104 	addi	fp,sp,68
 90bf42c:	e13ffa15 	stw	r4,-24(fp)
 90bf430:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 90bf434:	e0bffa17 	ldw	r2,-24(fp)
 90bf438:	10800317 	ldw	r2,12(r2)
 90bf43c:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 90bf440:	e0bff817 	ldw	r2,-32(fp)
 90bf444:	1080018b 	ldhu	r2,6(r2)
 90bf448:	10bfffcc 	andi	r2,r2,65535
 90bf44c:	1004d23a 	srli	r2,r2,8
 90bf450:	10bfffcc 	andi	r2,r2,65535
 90bf454:	10c03fcc 	andi	r3,r2,255
 90bf458:	e0bff817 	ldw	r2,-32(fp)
 90bf45c:	1080018b 	ldhu	r2,6(r2)
 90bf460:	10bfffcc 	andi	r2,r2,65535
 90bf464:	1004923a 	slli	r2,r2,8
 90bf468:	10bfc00c 	andi	r2,r2,65280
 90bf46c:	1884b03a 	or	r2,r3,r2
 90bf470:	1090000c 	andi	r2,r2,16384
 90bf474:	1005003a 	cmpeq	r2,r2,zero
 90bf478:	10001a1e 	bne	r2,zero,90bf4e4 <ip_fragment+0xc8>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf47c:	01000084 	movi	r4,2
 90bf480:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90bf484:	e13ffa17 	ldw	r4,-24(fp)
 90bf488:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf48c:	01000084 	movi	r4,2
 90bf490:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 90bf494:	008243b4 	movhi	r2,2318
 90bf498:	10b82c04 	addi	r2,r2,-8016
 90bf49c:	10801117 	ldw	r2,68(r2)
 90bf4a0:	10c00044 	addi	r3,r2,1
 90bf4a4:	008243b4 	movhi	r2,2318
 90bf4a8:	10b82c04 	addi	r2,r2,-8016
 90bf4ac:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 90bf4b0:	e0bff817 	ldw	r2,-32(fp)
 90bf4b4:	11000317 	ldw	r4,12(r2)
 90bf4b8:	e0bffa17 	ldw	r2,-24(fp)
 90bf4bc:	10800617 	ldw	r2,24(r2)
 90bf4c0:	11400a17 	ldw	r5,40(r2)
 90bf4c4:	e0bffa17 	ldw	r2,-24(fp)
 90bf4c8:	10800617 	ldw	r2,24(r2)
 90bf4cc:	d8800015 	stw	r2,0(sp)
 90bf4d0:	e1bff817 	ldw	r6,-32(fp)
 90bf4d4:	01c00104 	movi	r7,4
 90bf4d8:	90cace80 	call	90cace8 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 90bf4dc:	e03ffe15 	stw	zero,-8(fp)
 90bf4e0:	00015306 	br	90bfa30 <ip_fragment+0x614>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 90bf4e4:	90a9c740 	call	90a9c74 <pk_get_max_intrsafe_buf_len>
 90bf4e8:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 90bf4ec:	e0bffa17 	ldw	r2,-24(fp)
 90bf4f0:	10800617 	ldw	r2,24(r2)
 90bf4f4:	10800917 	ldw	r2,36(r2)
 90bf4f8:	e0fff917 	ldw	r3,-28(fp)
 90bf4fc:	e0ffff15 	stw	r3,-4(fp)
 90bf500:	e0bffd15 	stw	r2,-12(fp)
 90bf504:	e0bfff17 	ldw	r2,-4(fp)
 90bf508:	e0fffd17 	ldw	r3,-12(fp)
 90bf50c:	10c0022e 	bgeu	r2,r3,90bf518 <ip_fragment+0xfc>
 90bf510:	e0bfff17 	ldw	r2,-4(fp)
 90bf514:	e0bffd15 	stw	r2,-12(fp)
 90bf518:	e0fffd17 	ldw	r3,-12(fp)
 90bf51c:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 90bf520:	e0bff817 	ldw	r2,-32(fp)
 90bf524:	10800003 	ldbu	r2,0(r2)
 90bf528:	108003cc 	andi	r2,r2,15
 90bf52c:	1085883a 	add	r2,r2,r2
 90bf530:	1085883a 	add	r2,r2,r2
 90bf534:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 90bf538:	e0bffa17 	ldw	r2,-24(fp)
 90bf53c:	10800617 	ldw	r2,24(r2)
 90bf540:	10800817 	ldw	r2,32(r2)
 90bf544:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 90bf548:	e0fff7c3 	ldbu	r3,-33(fp)
 90bf54c:	e0bff58b 	ldhu	r2,-42(fp)
 90bf550:	10c5c83a 	sub	r2,r2,r3
 90bf554:	1007883a 	mov	r3,r2
 90bf558:	e0bff783 	ldbu	r2,-34(fp)
 90bf55c:	1885c83a 	sub	r2,r3,r2
 90bf560:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 90bf564:	e0fff70b 	ldhu	r3,-36(fp)
 90bf568:	00bffe04 	movi	r2,-8
 90bf56c:	1884703a 	and	r2,r3,r2
 90bf570:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 90bf574:	e0bff817 	ldw	r2,-32(fp)
 90bf578:	1080008b 	ldhu	r2,2(r2)
 90bf57c:	10bfffcc 	andi	r2,r2,65535
 90bf580:	1004d23a 	srli	r2,r2,8
 90bf584:	10803fcc 	andi	r2,r2,255
 90bf588:	1009883a 	mov	r4,r2
 90bf58c:	e0bff817 	ldw	r2,-32(fp)
 90bf590:	1080008b 	ldhu	r2,2(r2)
 90bf594:	10bfffcc 	andi	r2,r2,65535
 90bf598:	1004923a 	slli	r2,r2,8
 90bf59c:	1007883a 	mov	r3,r2
 90bf5a0:	00bfc004 	movi	r2,-256
 90bf5a4:	1884703a 	and	r2,r3,r2
 90bf5a8:	2084b03a 	or	r2,r4,r2
 90bf5ac:	1007883a 	mov	r3,r2
 90bf5b0:	e0bff7c3 	ldbu	r2,-33(fp)
 90bf5b4:	1885c83a 	sub	r2,r3,r2
 90bf5b8:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 90bf5bc:	e0fff68b 	ldhu	r3,-38(fp)
 90bf5c0:	e0bff70b 	ldhu	r2,-36(fp)
 90bf5c4:	1885203a 	divu	r2,r3,r2
 90bf5c8:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 90bf5cc:	e13ff68b 	ldhu	r4,-38(fp)
 90bf5d0:	e0fff70b 	ldhu	r3,-36(fp)
 90bf5d4:	20c5203a 	divu	r2,r4,r3
 90bf5d8:	10c5383a 	mul	r2,r2,r3
 90bf5dc:	2085c83a 	sub	r2,r4,r2
 90bf5e0:	e0bff60d 	sth	r2,-40(fp)
 90bf5e4:	e0bff60b 	ldhu	r2,-40(fp)
 90bf5e8:	1005003a 	cmpeq	r2,r2,zero
 90bf5ec:	1000031e 	bne	r2,zero,90bf5fc <ip_fragment+0x1e0>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 90bf5f0:	e0bff50b 	ldhu	r2,-44(fp)
 90bf5f4:	10800044 	addi	r2,r2,1
 90bf5f8:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 90bf5fc:	e0bff50b 	ldhu	r2,-44(fp)
 90bf600:	10800128 	cmpgeui	r2,r2,4
 90bf604:	10000a1e 	bne	r2,zero,90bf630 <ip_fragment+0x214>
 90bf608:	e0bffa17 	ldw	r2,-24(fp)
 90bf60c:	10800a17 	ldw	r2,40(r2)
 90bf610:	1080040c 	andi	r2,r2,16
 90bf614:	1004c03a 	cmpne	r2,r2,zero
 90bf618:	1000051e 	bne	r2,zero,90bf630 <ip_fragment+0x214>
   {
      return (ip_fragment_lc (p, firsthop));
 90bf61c:	e13ffa17 	ldw	r4,-24(fp)
 90bf620:	e17ffb17 	ldw	r5,-20(fp)
 90bf624:	90bef940 	call	90bef94 <ip_fragment_lc>
 90bf628:	e0bffe15 	stw	r2,-8(fp)
 90bf62c:	00010006 	br	90bfa30 <ip_fragment+0x614>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90bf630:	e0bff817 	ldw	r2,-32(fp)
 90bf634:	1080018b 	ldhu	r2,6(r2)
 90bf638:	10bfffcc 	andi	r2,r2,65535
 90bf63c:	1004d23a 	srli	r2,r2,8
 90bf640:	10803fcc 	andi	r2,r2,255
 90bf644:	1009883a 	mov	r4,r2
 90bf648:	e0bff817 	ldw	r2,-32(fp)
 90bf64c:	1080018b 	ldhu	r2,6(r2)
 90bf650:	10bfffcc 	andi	r2,r2,65535
 90bf654:	1004923a 	slli	r2,r2,8
 90bf658:	1007883a 	mov	r3,r2
 90bf65c:	00bfc004 	movi	r2,-256
 90bf660:	1884703a 	and	r2,r3,r2
 90bf664:	2084b03a 	or	r2,r4,r2
 90bf668:	1087ffcc 	andi	r2,r2,8191
 90bf66c:	100490fa 	slli	r2,r2,3
 90bf670:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 90bf674:	e0bff817 	ldw	r2,-32(fp)
 90bf678:	1080018b 	ldhu	r2,6(r2)
 90bf67c:	10bfffcc 	andi	r2,r2,65535
 90bf680:	1004d23a 	srli	r2,r2,8
 90bf684:	10803fcc 	andi	r2,r2,255
 90bf688:	1009883a 	mov	r4,r2
 90bf68c:	e0bff817 	ldw	r2,-32(fp)
 90bf690:	1080018b 	ldhu	r2,6(r2)
 90bf694:	10bfffcc 	andi	r2,r2,65535
 90bf698:	1004923a 	slli	r2,r2,8
 90bf69c:	1007883a 	mov	r3,r2
 90bf6a0:	00bfc004 	movi	r2,-256
 90bf6a4:	1884703a 	and	r2,r3,r2
 90bf6a8:	2084b03a 	or	r2,r4,r2
 90bf6ac:	1088000c 	andi	r2,r2,8192
 90bf6b0:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 90bf6b4:	e03ff48d 	sth	zero,-46(fp)
 90bf6b8:	0000cc06 	br	90bf9ec <ip_fragment+0x5d0>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf6bc:	01000084 	movi	r4,2
 90bf6c0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 90bf6c4:	e0fff70b 	ldhu	r3,-36(fp)
 90bf6c8:	e0bff7c3 	ldbu	r2,-33(fp)
 90bf6cc:	1887883a 	add	r3,r3,r2
 90bf6d0:	e0bff783 	ldbu	r2,-34(fp)
 90bf6d4:	1885883a 	add	r2,r3,r2
 90bf6d8:	1009883a 	mov	r4,r2
 90bf6dc:	90a98340 	call	90a9834 <pk_alloc>
 90bf6e0:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf6e4:	01000084 	movi	r4,2
 90bf6e8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 90bf6ec:	e0bff217 	ldw	r2,-56(fp)
 90bf6f0:	1004c03a 	cmpne	r2,r2,zero
 90bf6f4:	1000101e 	bne	r2,zero,90bf738 <ip_fragment+0x31c>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf6f8:	01000084 	movi	r4,2
 90bf6fc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90bf700:	e13ffa17 	ldw	r4,-24(fp)
 90bf704:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf708:	01000084 	movi	r4,2
 90bf70c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 90bf710:	008243b4 	movhi	r2,2318
 90bf714:	10b82c04 	addi	r2,r2,-8016
 90bf718:	10801117 	ldw	r2,68(r2)
 90bf71c:	10c00044 	addi	r3,r2,1
 90bf720:	008243b4 	movhi	r2,2318
 90bf724:	10b82c04 	addi	r2,r2,-8016
 90bf728:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 90bf72c:	00bffac4 	movi	r2,-21
 90bf730:	e0bffe15 	stw	r2,-8(fp)
 90bf734:	0000be06 	br	90bfa30 <ip_fragment+0x614>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 90bf738:	e0bff217 	ldw	r2,-56(fp)
 90bf73c:	10c00117 	ldw	r3,4(r2)
 90bf740:	e0bff783 	ldbu	r2,-34(fp)
 90bf744:	1889883a 	add	r4,r3,r2
 90bf748:	e0bffa17 	ldw	r2,-24(fp)
 90bf74c:	10800317 	ldw	r2,12(r2)
 90bf750:	e0fff7c3 	ldbu	r3,-33(fp)
 90bf754:	100b883a 	mov	r5,r2
 90bf758:	180d883a 	mov	r6,r3
 90bf75c:	90894600 	call	9089460 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 90bf760:	e0fff48b 	ldhu	r3,-46(fp)
 90bf764:	e0bff50b 	ldhu	r2,-44(fp)
 90bf768:	10bfffc4 	addi	r2,r2,-1
 90bf76c:	1880030e 	bge	r3,r2,90bf77c <ip_fragment+0x360>
         {
            amt_to_copy = useable_payload_len;
 90bf770:	e0bff70b 	ldhu	r2,-36(fp)
 90bf774:	e0bff40d 	sth	r2,-48(fp)
 90bf778:	00000a06 	br	90bf7a4 <ip_fragment+0x388>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 90bf77c:	e0bff60b 	ldhu	r2,-40(fp)
 90bf780:	1004c03a 	cmpne	r2,r2,zero
 90bf784:	1000031e 	bne	r2,zero,90bf794 <ip_fragment+0x378>
 90bf788:	e0fff70b 	ldhu	r3,-36(fp)
 90bf78c:	e0fffc0d 	sth	r3,-16(fp)
 90bf790:	00000206 	br	90bf79c <ip_fragment+0x380>
 90bf794:	e0bff60b 	ldhu	r2,-40(fp)
 90bf798:	e0bffc0d 	sth	r2,-16(fp)
 90bf79c:	e0fffc0b 	ldhu	r3,-16(fp)
 90bf7a0:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 90bf7a4:	e0bff217 	ldw	r2,-56(fp)
 90bf7a8:	10c00117 	ldw	r3,4(r2)
 90bf7ac:	e0bff783 	ldbu	r2,-34(fp)
 90bf7b0:	1887883a 	add	r3,r3,r2
 90bf7b4:	e0bff7c3 	ldbu	r2,-33(fp)
 90bf7b8:	188b883a 	add	r5,r3,r2
 90bf7bc:	e0bffa17 	ldw	r2,-24(fp)
 90bf7c0:	10c00317 	ldw	r3,12(r2)
 90bf7c4:	e0bff7c3 	ldbu	r2,-33(fp)
 90bf7c8:	1889883a 	add	r4,r3,r2
 90bf7cc:	e0fff70b 	ldhu	r3,-36(fp)
 90bf7d0:	e0bff48b 	ldhu	r2,-46(fp)
 90bf7d4:	1885383a 	mul	r2,r3,r2
 90bf7d8:	2085883a 	add	r2,r4,r2
 90bf7dc:	e0fff40b 	ldhu	r3,-48(fp)
 90bf7e0:	2809883a 	mov	r4,r5
 90bf7e4:	100b883a 	mov	r5,r2
 90bf7e8:	180d883a 	mov	r6,r3
 90bf7ec:	90894600 	call	9089460 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 90bf7f0:	e0bff217 	ldw	r2,-56(fp)
 90bf7f4:	10c00117 	ldw	r3,4(r2)
 90bf7f8:	e0bff783 	ldbu	r2,-34(fp)
 90bf7fc:	1887883a 	add	r3,r3,r2
 90bf800:	e0bff217 	ldw	r2,-56(fp)
 90bf804:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 90bf808:	e0fff7c3 	ldbu	r3,-33(fp)
 90bf80c:	e0bff40b 	ldhu	r2,-48(fp)
 90bf810:	1885883a 	add	r2,r3,r2
 90bf814:	1007883a 	mov	r3,r2
 90bf818:	e0bff217 	ldw	r2,-56(fp)
 90bf81c:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 90bf820:	e0bffa17 	ldw	r2,-24(fp)
 90bf824:	10c00617 	ldw	r3,24(r2)
 90bf828:	e0bff217 	ldw	r2,-56(fp)
 90bf82c:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 90bf830:	e0bffa17 	ldw	r2,-24(fp)
 90bf834:	10c00717 	ldw	r3,28(r2)
 90bf838:	e0bff217 	ldw	r2,-56(fp)
 90bf83c:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 90bf840:	e0fff217 	ldw	r3,-56(fp)
 90bf844:	00820004 	movi	r2,2048
 90bf848:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 90bf84c:	e0bff217 	ldw	r2,-56(fp)
 90bf850:	10800317 	ldw	r2,12(r2)
 90bf854:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 90bf858:	e0bff217 	ldw	r2,-56(fp)
 90bf85c:	10800417 	ldw	r2,16(r2)
 90bf860:	1004d23a 	srli	r2,r2,8
 90bf864:	10803fcc 	andi	r2,r2,255
 90bf868:	1009883a 	mov	r4,r2
 90bf86c:	e0bff217 	ldw	r2,-56(fp)
 90bf870:	10800417 	ldw	r2,16(r2)
 90bf874:	1004923a 	slli	r2,r2,8
 90bf878:	1007883a 	mov	r3,r2
 90bf87c:	00bfc004 	movi	r2,-256
 90bf880:	1884703a 	and	r2,r3,r2
 90bf884:	2084b03a 	or	r2,r4,r2
 90bf888:	1007883a 	mov	r3,r2
 90bf88c:	e0bff117 	ldw	r2,-60(fp)
 90bf890:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 90bf894:	e13ff38b 	ldhu	r4,-50(fp)
 90bf898:	e0fff70b 	ldhu	r3,-36(fp)
 90bf89c:	e0bff48b 	ldhu	r2,-46(fp)
 90bf8a0:	1885383a 	mul	r2,r3,r2
 90bf8a4:	2085883a 	add	r2,r4,r2
 90bf8a8:	1005d2fa 	srai	r2,r2,11
 90bf8ac:	10803fcc 	andi	r2,r2,255
 90bf8b0:	100b883a 	mov	r5,r2
 90bf8b4:	e13ff38b 	ldhu	r4,-50(fp)
 90bf8b8:	e0fff70b 	ldhu	r3,-36(fp)
 90bf8bc:	e0bff48b 	ldhu	r2,-46(fp)
 90bf8c0:	1885383a 	mul	r2,r3,r2
 90bf8c4:	2085883a 	add	r2,r4,r2
 90bf8c8:	1005d0fa 	srai	r2,r2,3
 90bf8cc:	1004923a 	slli	r2,r2,8
 90bf8d0:	1007883a 	mov	r3,r2
 90bf8d4:	00bfc004 	movi	r2,-256
 90bf8d8:	1884703a 	and	r2,r3,r2
 90bf8dc:	2884b03a 	or	r2,r5,r2
 90bf8e0:	1007883a 	mov	r3,r2
 90bf8e4:	e0bff117 	ldw	r2,-60(fp)
 90bf8e8:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 90bf8ec:	e0fff48b 	ldhu	r3,-46(fp)
 90bf8f0:	e0bff50b 	ldhu	r2,-44(fp)
 90bf8f4:	10bfffc4 	addi	r2,r2,-1
 90bf8f8:	1880070e 	bge	r3,r2,90bf918 <ip_fragment+0x4fc>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 90bf8fc:	e0bff117 	ldw	r2,-60(fp)
 90bf900:	1080018b 	ldhu	r2,6(r2)
 90bf904:	10800814 	ori	r2,r2,32
 90bf908:	1007883a 	mov	r3,r2
 90bf90c:	e0bff117 	ldw	r2,-60(fp)
 90bf910:	10c0018d 	sth	r3,6(r2)
 90bf914:	00000906 	br	90bf93c <ip_fragment+0x520>
         }
         else
         {
            if (parent_mf)
 90bf918:	e0bff30b 	ldhu	r2,-52(fp)
 90bf91c:	1005003a 	cmpeq	r2,r2,zero
 90bf920:	1000061e 	bne	r2,zero,90bf93c <ip_fragment+0x520>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 90bf924:	e0bff117 	ldw	r2,-60(fp)
 90bf928:	1080018b 	ldhu	r2,6(r2)
 90bf92c:	10800814 	ori	r2,r2,32
 90bf930:	1007883a 	mov	r3,r2
 90bf934:	e0bff117 	ldw	r2,-60(fp)
 90bf938:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 90bf93c:	e0bff117 	ldw	r2,-60(fp)
 90bf940:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 90bf944:	e0bff7c3 	ldbu	r2,-33(fp)
 90bf948:	1004d07a 	srli	r2,r2,1
 90bf94c:	11403fcc 	andi	r5,r2,255
 90bf950:	e13ff117 	ldw	r4,-60(fp)
 90bf954:	90a4ef40 	call	90a4ef4 <cksum>
 90bf958:	0084303a 	nor	r2,zero,r2
 90bf95c:	1007883a 	mov	r3,r2
 90bf960:	e0bff117 	ldw	r2,-60(fp)
 90bf964:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 90bf968:	008243b4 	movhi	r2,2318
 90bf96c:	10b82c04 	addi	r2,r2,-8016
 90bf970:	10801217 	ldw	r2,72(r2)
 90bf974:	10c00044 	addi	r3,r2,1
 90bf978:	008243b4 	movhi	r2,2318
 90bf97c:	10b82c04 	addi	r2,r2,-8016
 90bf980:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 90bf984:	e13ff217 	ldw	r4,-56(fp)
 90bf988:	e17ffb17 	ldw	r5,-20(fp)
 90bf98c:	90a2b440 	call	90a2b44 <ip2mac>
 90bf990:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 90bf994:	e0bff017 	ldw	r2,-64(fp)
 90bf998:	1004403a 	cmpge	r2,r2,zero
 90bf99c:	1000101e 	bne	r2,zero,90bf9e0 <ip_fragment+0x5c4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf9a0:	01000084 	movi	r4,2
 90bf9a4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90bf9a8:	e13ffa17 	ldw	r4,-24(fp)
 90bf9ac:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bf9b0:	01000084 	movi	r4,2
 90bf9b4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 90bf9b8:	008243b4 	movhi	r2,2318
 90bf9bc:	10b82c04 	addi	r2,r2,-8016
 90bf9c0:	10801117 	ldw	r2,68(r2)
 90bf9c4:	10c00044 	addi	r3,r2,1
 90bf9c8:	008243b4 	movhi	r2,2318
 90bf9cc:	10b82c04 	addi	r2,r2,-8016
 90bf9d0:	10c01115 	stw	r3,68(r2)
            return e;
 90bf9d4:	e0bff017 	ldw	r2,-64(fp)
 90bf9d8:	e0bffe15 	stw	r2,-8(fp)
 90bf9dc:	00001406 	br	90bfa30 <ip_fragment+0x614>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 90bf9e0:	e0bff48b 	ldhu	r2,-46(fp)
 90bf9e4:	10800044 	addi	r2,r2,1
 90bf9e8:	e0bff48d 	sth	r2,-46(fp)
 90bf9ec:	e0fff48b 	ldhu	r3,-46(fp)
 90bf9f0:	e0bff50b 	ldhu	r2,-44(fp)
 90bf9f4:	18bf3136 	bltu	r3,r2,90bf6bc <ip_fragment+0x2a0>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90bf9f8:	01000084 	movi	r4,2
 90bf9fc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90bfa00:	e13ffa17 	ldw	r4,-24(fp)
 90bfa04:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90bfa08:	01000084 	movi	r4,2
 90bfa0c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 90bfa10:	008243b4 	movhi	r2,2318
 90bfa14:	10b82c04 	addi	r2,r2,-8016
 90bfa18:	10801017 	ldw	r2,64(r2)
 90bfa1c:	10c00044 	addi	r3,r2,1
 90bfa20:	008243b4 	movhi	r2,2318
 90bfa24:	10b82c04 	addi	r2,r2,-8016
 90bfa28:	10c01015 	stw	r3,64(r2)

   return 0;
 90bfa2c:	e03ffe15 	stw	zero,-8(fp)
 90bfa30:	e0bffe17 	ldw	r2,-8(fp)
}
 90bfa34:	e037883a 	mov	sp,fp
 90bfa38:	dfc00117 	ldw	ra,4(sp)
 90bfa3c:	df000017 	ldw	fp,0(sp)
 90bfa40:	dec00204 	addi	sp,sp,8
 90bfa44:	f800283a 	ret

090bfa48 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 90bfa48:	defff904 	addi	sp,sp,-28
 90bfa4c:	dfc00615 	stw	ra,24(sp)
 90bfa50:	df000515 	stw	fp,20(sp)
 90bfa54:	df000504 	addi	fp,sp,20
 90bfa58:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 90bfa5c:	e17ffd04 	addi	r5,fp,-12
 90bfa60:	e13ffe17 	ldw	r4,-8(fp)
 90bfa64:	90bfdac0 	call	90bfdac <iproute>
 90bfa68:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 90bfa6c:	e0bffc17 	ldw	r2,-16(fp)
 90bfa70:	1004c03a 	cmpne	r2,r2,zero
 90bfa74:	1000161e 	bne	r2,zero,90bfad0 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 90bfa78:	00824374 	movhi	r2,2317
 90bfa7c:	108f0904 	addi	r2,r2,15396
 90bfa80:	10800017 	ldw	r2,0(r2)
 90bfa84:	1080050c 	andi	r2,r2,20
 90bfa88:	1005003a 	cmpeq	r2,r2,zero
 90bfa8c:	10000e1e 	bne	r2,zero,90bfac8 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90bfa90:	e0bffe17 	ldw	r2,-8(fp)
 90bfa94:	11403fcc 	andi	r5,r2,255
 90bfa98:	e0bffe17 	ldw	r2,-8(fp)
 90bfa9c:	1004d23a 	srli	r2,r2,8
 90bfaa0:	11803fcc 	andi	r6,r2,255
 90bfaa4:	e0bffe17 	ldw	r2,-8(fp)
 90bfaa8:	1004d43a 	srli	r2,r2,16
 90bfaac:	11c03fcc 	andi	r7,r2,255
 90bfab0:	e0bffe17 	ldw	r2,-8(fp)
 90bfab4:	1004d63a 	srli	r2,r2,24
 90bfab8:	d8800015 	stw	r2,0(sp)
 90bfabc:	01024374 	movhi	r4,2317
 90bfac0:	21035c04 	addi	r4,r4,3440
 90bfac4:	90833900 	call	9083390 <printf>
#endif   /* NPDEBUG */
      return 0L;
 90bfac8:	e03fff15 	stw	zero,-4(fp)
 90bfacc:	00000306 	br	90bfadc <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 90bfad0:	e0bffc17 	ldw	r2,-16(fp)
 90bfad4:	10800a17 	ldw	r2,40(r2)
 90bfad8:	e0bfff15 	stw	r2,-4(fp)
 90bfadc:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 90bfae0:	e037883a 	mov	sp,fp
 90bfae4:	dfc00117 	ldw	ra,4(sp)
 90bfae8:	df000017 	ldw	fp,0(sp)
 90bfaec:	dec00204 	addi	sp,sp,8
 90bfaf0:	f800283a 	ret

090bfaf4 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 90bfaf4:	defff204 	addi	sp,sp,-56
 90bfaf8:	dfc00d15 	stw	ra,52(sp)
 90bfafc:	df000c15 	stw	fp,48(sp)
 90bfb00:	df000c04 	addi	fp,sp,48
 90bfb04:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 90bfb08:	e0bffa17 	ldw	r2,-24(fp)
 90bfb0c:	10800317 	ldw	r2,12(r2)
 90bfb10:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 90bfb14:	e0bff917 	ldw	r2,-28(fp)
 90bfb18:	1080028b 	ldhu	r2,10(r2)
 90bfb1c:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 90bfb20:	e0bff917 	ldw	r2,-28(fp)
 90bfb24:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 90bfb28:	e0bff917 	ldw	r2,-28(fp)
 90bfb2c:	10800003 	ldbu	r2,0(r2)
 90bfb30:	10803fcc 	andi	r2,r2,255
 90bfb34:	108003cc 	andi	r2,r2,15
 90bfb38:	1085883a 	add	r2,r2,r2
 90bfb3c:	1085883a 	add	r2,r2,r2
 90bfb40:	1005d07a 	srai	r2,r2,1
 90bfb44:	100b883a 	mov	r5,r2
 90bfb48:	e13ff917 	ldw	r4,-28(fp)
 90bfb4c:	90a4ef40 	call	90a4ef4 <cksum>
 90bfb50:	0084303a 	nor	r2,zero,r2
 90bfb54:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 90bfb58:	e0fff70b 	ldhu	r3,-36(fp)
 90bfb5c:	e0bff78b 	ldhu	r2,-34(fp)
 90bfb60:	18800126 	beq	r3,r2,90bfb68 <ip_dump+0x74>
   {
      dtrap();
 90bfb64:	90aa4780 	call	90aa478 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 90bfb68:	0009883a 	mov	r4,zero
 90bfb6c:	01424374 	movhi	r5,2317
 90bfb70:	29436504 	addi	r5,r5,3476
 90bfb74:	90a55a40 	call	90a55a4 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 90bfb78:	e0bff917 	ldw	r2,-28(fp)
 90bfb7c:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 90bfb80:	e0bff817 	ldw	r2,-32(fp)
 90bfb84:	10800003 	ldbu	r2,0(r2)
 90bfb88:	11803fcc 	andi	r6,r2,255
 90bfb8c:	e0bff817 	ldw	r2,-32(fp)
 90bfb90:	10800044 	addi	r2,r2,1
 90bfb94:	10800003 	ldbu	r2,0(r2)
 90bfb98:	11c03fcc 	andi	r7,r2,255
 90bfb9c:	e0bff917 	ldw	r2,-28(fp)
 90bfba0:	1080008b 	ldhu	r2,2(r2)
 90bfba4:	10bfffcc 	andi	r2,r2,65535
 90bfba8:	1004d23a 	srli	r2,r2,8
 90bfbac:	10bfffcc 	andi	r2,r2,65535
 90bfbb0:	10c03fcc 	andi	r3,r2,255
 90bfbb4:	e0bff917 	ldw	r2,-28(fp)
 90bfbb8:	1080008b 	ldhu	r2,2(r2)
 90bfbbc:	10bfffcc 	andi	r2,r2,65535
 90bfbc0:	1004923a 	slli	r2,r2,8
 90bfbc4:	10bfc00c 	andi	r2,r2,65280
 90bfbc8:	1888b03a 	or	r4,r3,r2
 90bfbcc:	e0bff917 	ldw	r2,-28(fp)
 90bfbd0:	1080010b 	ldhu	r2,4(r2)
 90bfbd4:	10bfffcc 	andi	r2,r2,65535
 90bfbd8:	1004d23a 	srli	r2,r2,8
 90bfbdc:	10bfffcc 	andi	r2,r2,65535
 90bfbe0:	10c03fcc 	andi	r3,r2,255
 90bfbe4:	e0bff917 	ldw	r2,-28(fp)
 90bfbe8:	1080010b 	ldhu	r2,4(r2)
 90bfbec:	10bfffcc 	andi	r2,r2,65535
 90bfbf0:	1004923a 	slli	r2,r2,8
 90bfbf4:	10bfc00c 	andi	r2,r2,65280
 90bfbf8:	1884b03a 	or	r2,r3,r2
 90bfbfc:	d9000015 	stw	r4,0(sp)
 90bfc00:	d8800115 	stw	r2,4(sp)
 90bfc04:	0009883a 	mov	r4,zero
 90bfc08:	01424374 	movhi	r5,2317
 90bfc0c:	29436a04 	addi	r5,r5,3496
 90bfc10:	90a55a40 	call	90a55a4 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 90bfc14:	e0bff817 	ldw	r2,-32(fp)
 90bfc18:	10800184 	addi	r2,r2,6
 90bfc1c:	1080000b 	ldhu	r2,0(r2)
 90bfc20:	10bfffcc 	andi	r2,r2,65535
 90bfc24:	1004d23a 	srli	r2,r2,8
 90bfc28:	10bfffcc 	andi	r2,r2,65535
 90bfc2c:	10c03fcc 	andi	r3,r2,255
 90bfc30:	e0bff817 	ldw	r2,-32(fp)
 90bfc34:	10800184 	addi	r2,r2,6
 90bfc38:	1080000b 	ldhu	r2,0(r2)
 90bfc3c:	10bfffcc 	andi	r2,r2,65535
 90bfc40:	1004923a 	slli	r2,r2,8
 90bfc44:	10bfc00c 	andi	r2,r2,65280
 90bfc48:	1886b03a 	or	r3,r3,r2
 90bfc4c:	e0ffff15 	stw	r3,-4(fp)
 90bfc50:	e0bff917 	ldw	r2,-28(fp)
 90bfc54:	10800203 	ldbu	r2,8(r2)
 90bfc58:	10803fcc 	andi	r2,r2,255
 90bfc5c:	e0bffe15 	stw	r2,-8(fp)
 90bfc60:	e0bff917 	ldw	r2,-28(fp)
 90bfc64:	10800243 	ldbu	r2,9(r2)
 90bfc68:	10803fcc 	andi	r2,r2,255
 90bfc6c:	e0bffd15 	stw	r2,-12(fp)
 90bfc70:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc74:	1004d23a 	srli	r2,r2,8
 90bfc78:	10bfffcc 	andi	r2,r2,65535
 90bfc7c:	10c03fcc 	andi	r3,r2,255
 90bfc80:	e0bff70b 	ldhu	r2,-36(fp)
 90bfc84:	1004923a 	slli	r2,r2,8
 90bfc88:	10bfc00c 	andi	r2,r2,65280
 90bfc8c:	1886b03a 	or	r3,r3,r2
 90bfc90:	e0fffc15 	stw	r3,-16(fp)
 90bfc94:	e0fff70b 	ldhu	r3,-36(fp)
 90bfc98:	e0bff78b 	ldhu	r2,-34(fp)
 90bfc9c:	1880041e 	bne	r3,r2,90bfcb0 <ip_dump+0x1bc>
 90bfca0:	00824374 	movhi	r2,2317
 90bfca4:	10837604 	addi	r2,r2,3544
 90bfca8:	e0bffb15 	stw	r2,-20(fp)
 90bfcac:	00000306 	br	90bfcbc <ip_dump+0x1c8>
 90bfcb0:	00824374 	movhi	r2,2317
 90bfcb4:	10837704 	addi	r2,r2,3548
 90bfcb8:	e0bffb15 	stw	r2,-20(fp)
 90bfcbc:	e0bffd17 	ldw	r2,-12(fp)
 90bfcc0:	d8800015 	stw	r2,0(sp)
 90bfcc4:	e0bffc17 	ldw	r2,-16(fp)
 90bfcc8:	d8800115 	stw	r2,4(sp)
 90bfccc:	e0bffb17 	ldw	r2,-20(fp)
 90bfcd0:	d8800215 	stw	r2,8(sp)
 90bfcd4:	0009883a 	mov	r4,zero
 90bfcd8:	01424374 	movhi	r5,2317
 90bfcdc:	29437804 	addi	r5,r5,3552
 90bfce0:	e1bfff17 	ldw	r6,-4(fp)
 90bfce4:	e1fffe17 	ldw	r7,-8(fp)
 90bfce8:	90a55a40 	call	90a55a4 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 90bfcec:	e0bff917 	ldw	r2,-28(fp)
 90bfcf0:	10800317 	ldw	r2,12(r2)
 90bfcf4:	11803fcc 	andi	r6,r2,255
 90bfcf8:	e0bff917 	ldw	r2,-28(fp)
 90bfcfc:	10800317 	ldw	r2,12(r2)
 90bfd00:	1004d23a 	srli	r2,r2,8
 90bfd04:	11c03fcc 	andi	r7,r2,255
 90bfd08:	e0bff917 	ldw	r2,-28(fp)
 90bfd0c:	10800317 	ldw	r2,12(r2)
 90bfd10:	1004d43a 	srli	r2,r2,16
 90bfd14:	10c03fcc 	andi	r3,r2,255
 90bfd18:	e0bff917 	ldw	r2,-28(fp)
 90bfd1c:	10800317 	ldw	r2,12(r2)
 90bfd20:	1004d63a 	srli	r2,r2,24
 90bfd24:	d8c00015 	stw	r3,0(sp)
 90bfd28:	d8800115 	stw	r2,4(sp)
 90bfd2c:	0009883a 	mov	r4,zero
 90bfd30:	01424374 	movhi	r5,2317
 90bfd34:	29438804 	addi	r5,r5,3616
 90bfd38:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 90bfd3c:	e0bff917 	ldw	r2,-28(fp)
 90bfd40:	10800417 	ldw	r2,16(r2)
 90bfd44:	11803fcc 	andi	r6,r2,255
 90bfd48:	e0bff917 	ldw	r2,-28(fp)
 90bfd4c:	10800417 	ldw	r2,16(r2)
 90bfd50:	1004d23a 	srli	r2,r2,8
 90bfd54:	11c03fcc 	andi	r7,r2,255
 90bfd58:	e0bff917 	ldw	r2,-28(fp)
 90bfd5c:	10800417 	ldw	r2,16(r2)
 90bfd60:	1004d43a 	srli	r2,r2,16
 90bfd64:	10c03fcc 	andi	r3,r2,255
 90bfd68:	e0bff917 	ldw	r2,-28(fp)
 90bfd6c:	10800417 	ldw	r2,16(r2)
 90bfd70:	1004d63a 	srli	r2,r2,24
 90bfd74:	d8c00015 	stw	r3,0(sp)
 90bfd78:	d8800115 	stw	r2,4(sp)
 90bfd7c:	0009883a 	mov	r4,zero
 90bfd80:	01424374 	movhi	r5,2317
 90bfd84:	29438d04 	addi	r5,r5,3636
 90bfd88:	90a55a40 	call	90a55a4 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 90bfd8c:	e0fff917 	ldw	r3,-28(fp)
 90bfd90:	e0bff70b 	ldhu	r2,-36(fp)
 90bfd94:	1880028d 	sth	r2,10(r3)
}
 90bfd98:	e037883a 	mov	sp,fp
 90bfd9c:	dfc00117 	ldw	ra,4(sp)
 90bfda0:	df000017 	ldw	fp,0(sp)
 90bfda4:	dec00204 	addi	sp,sp,8
 90bfda8:	f800283a 	ret

090bfdac <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 90bfdac:	defff704 	addi	sp,sp,-36
 90bfdb0:	dfc00815 	stw	ra,32(sp)
 90bfdb4:	df000715 	stw	fp,28(sp)
 90bfdb8:	df000704 	addi	fp,sp,28
 90bfdbc:	e13ffd15 	stw	r4,-12(fp)
 90bfdc0:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 90bfdc4:	e0bffd17 	ldw	r2,-12(fp)
 90bfdc8:	1004c03a 	cmpne	r2,r2,zero
 90bfdcc:	1000021e 	bne	r2,zero,90bfdd8 <iproute+0x2c>
      return NULL;
 90bfdd0:	e03fff15 	stw	zero,-4(fp)
 90bfdd4:	00008a06 	br	90c0000 <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 90bfdd8:	d0a0c717 	ldw	r2,-31972(gp)
 90bfddc:	1004c03a 	cmpne	r2,r2,zero
 90bfde0:	1000021e 	bne	r2,zero,90bfdec <iproute+0x40>
      return NULL;
 90bfde4:	e03fff15 	stw	zero,-4(fp)
 90bfde8:	00008506 	br	90c0000 <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 90bfdec:	00824374 	movhi	r2,2317
 90bfdf0:	108f5604 	addi	r2,r2,15704
 90bfdf4:	10800017 	ldw	r2,0(r2)
 90bfdf8:	1005003a 	cmpeq	r2,r2,zero
 90bfdfc:	1000191e 	bne	r2,zero,90bfe64 <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 90bfe00:	00824374 	movhi	r2,2317
 90bfe04:	108f5604 	addi	r2,r2,15704
 90bfe08:	10800017 	ldw	r2,0(r2)
 90bfe0c:	10c00017 	ldw	r3,0(r2)
 90bfe10:	e0bffd17 	ldw	r2,-12(fp)
 90bfe14:	1880131e 	bne	r3,r2,90bfe64 <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 90bfe18:	00824374 	movhi	r2,2317
 90bfe1c:	108f5604 	addi	r2,r2,15704
 90bfe20:	10800017 	ldw	r2,0(r2)
 90bfe24:	10c00617 	ldw	r3,24(r2)
 90bfe28:	e0bffe17 	ldw	r2,-8(fp)
 90bfe2c:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 90bfe30:	00824374 	movhi	r2,2317
 90bfe34:	108f5604 	addi	r2,r2,15704
 90bfe38:	10c00017 	ldw	r3,0(r2)
 90bfe3c:	00824374 	movhi	r2,2317
 90bfe40:	108f2e04 	addi	r2,r2,15544
 90bfe44:	10800017 	ldw	r2,0(r2)
 90bfe48:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 90bfe4c:	00824374 	movhi	r2,2317
 90bfe50:	108f5604 	addi	r2,r2,15704
 90bfe54:	10800017 	ldw	r2,0(r2)
 90bfe58:	10800e17 	ldw	r2,56(r2)
 90bfe5c:	e0bfff15 	stw	r2,-4(fp)
 90bfe60:	00006706 	br	90c0000 <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 90bfe64:	e13ffd17 	ldw	r4,-12(fp)
 90bfe68:	90c36b00 	call	90c36b0 <rt_lookup>
 90bfe6c:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 90bfe70:	e0bffa17 	ldw	r2,-24(fp)
 90bfe74:	1005003a 	cmpeq	r2,r2,zero
 90bfe78:	10000c1e 	bne	r2,zero,90bfeac <iproute+0x100>
   {
      cachedRoute = rtp;
 90bfe7c:	00c24374 	movhi	r3,2317
 90bfe80:	18cf5604 	addi	r3,r3,15704
 90bfe84:	e0bffa17 	ldw	r2,-24(fp)
 90bfe88:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 90bfe8c:	e0bffa17 	ldw	r2,-24(fp)
 90bfe90:	10c00617 	ldw	r3,24(r2)
 90bfe94:	e0bffe17 	ldw	r2,-8(fp)
 90bfe98:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 90bfe9c:	e0bffa17 	ldw	r2,-24(fp)
 90bfea0:	10800e17 	ldw	r2,56(r2)
 90bfea4:	e0bfff15 	stw	r2,-4(fp)
 90bfea8:	00005506 	br	90c0000 <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 90bfeac:	008243b4 	movhi	r2,2318
 90bfeb0:	10b82704 	addi	r2,r2,-8036
 90bfeb4:	10800017 	ldw	r2,0(r2)
 90bfeb8:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 90bfebc:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 90bfec0:	00002f06 	br	90bff80 <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 90bfec4:	e0bffb17 	ldw	r2,-20(fp)
 90bfec8:	10800c17 	ldw	r2,48(r2)
 90bfecc:	1005003a 	cmpeq	r2,r2,zero
 90bfed0:	1000251e 	bne	r2,zero,90bff68 <iproute+0x1bc>
 90bfed4:	e0bffb17 	ldw	r2,-20(fp)
 90bfed8:	10800a17 	ldw	r2,40(r2)
 90bfedc:	1005003a 	cmpeq	r2,r2,zero
 90bfee0:	1000211e 	bne	r2,zero,90bff68 <iproute+0x1bc>
 90bfee4:	e0bffb17 	ldw	r2,-20(fp)
 90bfee8:	10c00a17 	ldw	r3,40(r2)
 90bfeec:	e0bffb17 	ldw	r2,-20(fp)
 90bfef0:	10800c17 	ldw	r2,48(r2)
 90bfef4:	1888703a 	and	r4,r3,r2
 90bfef8:	e0bffb17 	ldw	r2,-20(fp)
 90bfefc:	10c00c17 	ldw	r3,48(r2)
 90bff00:	e0bffd17 	ldw	r2,-12(fp)
 90bff04:	1884703a 	and	r2,r3,r2
 90bff08:	2080171e 	bne	r4,r2,90bff68 <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 90bff0c:	00800044 	movi	r2,1
 90bff10:	d8800015 	stw	r2,0(sp)
 90bff14:	e13ffd17 	ldw	r4,-12(fp)
 90bff18:	017fffc4 	movi	r5,-1
 90bff1c:	e1bffd17 	ldw	r6,-12(fp)
 90bff20:	e1fffc17 	ldw	r7,-16(fp)
 90bff24:	90c38340 	call	90c3834 <add_route>
 90bff28:	1007883a 	mov	r3,r2
 90bff2c:	00824374 	movhi	r2,2317
 90bff30:	108f5604 	addi	r2,r2,15704
 90bff34:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 90bff38:	00824374 	movhi	r2,2317
 90bff3c:	108f5604 	addi	r2,r2,15704
 90bff40:	10800017 	ldw	r2,0(r2)
 90bff44:	1004c03a 	cmpne	r2,r2,zero
 90bff48:	1000011e 	bne	r2,zero,90bff50 <iproute+0x1a4>
            dtrap();
 90bff4c:	90aa4780 	call	90aa478 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 90bff50:	e0fffe17 	ldw	r3,-8(fp)
 90bff54:	e0bffd17 	ldw	r2,-12(fp)
 90bff58:	18800015 	stw	r2,0(r3)
         return ifp;
 90bff5c:	e0bffb17 	ldw	r2,-20(fp)
 90bff60:	e0bfff15 	stw	r2,-4(fp)
 90bff64:	00002606 	br	90c0000 <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 90bff68:	e0bffb17 	ldw	r2,-20(fp)
 90bff6c:	10800017 	ldw	r2,0(r2)
 90bff70:	e0bffb15 	stw	r2,-20(fp)
 90bff74:	e0bffc17 	ldw	r2,-16(fp)
 90bff78:	10800044 	addi	r2,r2,1
 90bff7c:	e0bffc15 	stw	r2,-16(fp)
 90bff80:	e0bffb17 	ldw	r2,-20(fp)
 90bff84:	1004c03a 	cmpne	r2,r2,zero
 90bff88:	103fce1e 	bne	r2,zero,90bfec4 <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 90bff8c:	008243b4 	movhi	r2,2318
 90bff90:	10b82704 	addi	r2,r2,-8036
 90bff94:	10800017 	ldw	r2,0(r2)
 90bff98:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 90bff9c:	00000e06 	br	90bffd8 <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 90bffa0:	e0bffb17 	ldw	r2,-20(fp)
 90bffa4:	10800d17 	ldw	r2,52(r2)
 90bffa8:	1005003a 	cmpeq	r2,r2,zero
 90bffac:	1000071e 	bne	r2,zero,90bffcc <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 90bffb0:	e0bffb17 	ldw	r2,-20(fp)
 90bffb4:	10c00d17 	ldw	r3,52(r2)
 90bffb8:	e0bffe17 	ldw	r2,-8(fp)
 90bffbc:	10c00015 	stw	r3,0(r2)
         return ifp;
 90bffc0:	e0bffb17 	ldw	r2,-20(fp)
 90bffc4:	e0bfff15 	stw	r2,-4(fp)
 90bffc8:	00000d06 	br	90c0000 <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 90bffcc:	e0bffb17 	ldw	r2,-20(fp)
 90bffd0:	10800017 	ldw	r2,0(r2)
 90bffd4:	e0bffb15 	stw	r2,-20(fp)
 90bffd8:	e0bffb17 	ldw	r2,-20(fp)
 90bffdc:	1004c03a 	cmpne	r2,r2,zero
 90bffe0:	103fef1e 	bne	r2,zero,90bffa0 <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 90bffe4:	e0fffe17 	ldw	r3,-8(fp)
 90bffe8:	e0bffd17 	ldw	r2,-12(fp)
 90bffec:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 90bfff0:	008243b4 	movhi	r2,2318
 90bfff4:	10b82704 	addi	r2,r2,-8036
 90bfff8:	10800017 	ldw	r2,0(r2)
 90bfffc:	e0bfff15 	stw	r2,-4(fp)
 90c0000:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 90c0004:	e037883a 	mov	sp,fp
 90c0008:	dfc00117 	ldw	ra,4(sp)
 90c000c:	df000017 	ldw	fp,0(sp)
 90c0010:	dec00204 	addi	sp,sp,8
 90c0014:	f800283a 	ret

090c0018 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 90c0018:	defffa04 	addi	sp,sp,-24
 90c001c:	dfc00515 	stw	ra,20(sp)
 90c0020:	df000415 	stw	fp,16(sp)
 90c0024:	df000404 	addi	fp,sp,16
 90c0028:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 90c002c:	e0bffe17 	ldw	r2,-8(fp)
 90c0030:	11000417 	ldw	r4,16(r2)
 90c0034:	e0bffe17 	ldw	r2,-8(fp)
 90c0038:	10800317 	ldw	r2,12(r2)
 90c003c:	1007883a 	mov	r3,r2
 90c0040:	e0bffe17 	ldw	r2,-8(fp)
 90c0044:	10800117 	ldw	r2,4(r2)
 90c0048:	1885c83a 	sub	r2,r3,r2
 90c004c:	2085883a 	add	r2,r4,r2
 90c0050:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c0054:	01000084 	movi	r4,2
 90c0058:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 90c005c:	e13ffc17 	ldw	r4,-16(fp)
 90c0060:	90a98340 	call	90a9834 <pk_alloc>
 90c0064:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c0068:	01000084 	movi	r4,2
 90c006c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 90c0070:	e0bffd17 	ldw	r2,-12(fp)
 90c0074:	1004c03a 	cmpne	r2,r2,zero
 90c0078:	1000061e 	bne	r2,zero,90c0094 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 90c007c:	01024374 	movhi	r4,2317
 90c0080:	21039204 	addi	r4,r4,3656
 90c0084:	e17ffc17 	ldw	r5,-16(fp)
 90c0088:	90833900 	call	9083390 <printf>
#endif
      return NULL;
 90c008c:	e03fff15 	stw	zero,-4(fp)
 90c0090:	00002906 	br	90c0138 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 90c0094:	e0bffd17 	ldw	r2,-12(fp)
 90c0098:	11000117 	ldw	r4,4(r2)
 90c009c:	e0bffe17 	ldw	r2,-8(fp)
 90c00a0:	10800117 	ldw	r2,4(r2)
 90c00a4:	e0fffc17 	ldw	r3,-16(fp)
 90c00a8:	100b883a 	mov	r5,r2
 90c00ac:	180d883a 	mov	r6,r3
 90c00b0:	90894600 	call	9089460 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 90c00b4:	e0bffd17 	ldw	r2,-12(fp)
 90c00b8:	11000117 	ldw	r4,4(r2)
 90c00bc:	e0bffe17 	ldw	r2,-8(fp)
 90c00c0:	10800317 	ldw	r2,12(r2)
 90c00c4:	1007883a 	mov	r3,r2
 90c00c8:	e0bffe17 	ldw	r2,-8(fp)
 90c00cc:	10800117 	ldw	r2,4(r2)
 90c00d0:	1885c83a 	sub	r2,r3,r2
 90c00d4:	2087883a 	add	r3,r4,r2
 90c00d8:	e0bffd17 	ldw	r2,-12(fp)
 90c00dc:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 90c00e0:	e0bffe17 	ldw	r2,-8(fp)
 90c00e4:	10c00417 	ldw	r3,16(r2)
 90c00e8:	e0bffd17 	ldw	r2,-12(fp)
 90c00ec:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 90c00f0:	e0bffe17 	ldw	r2,-8(fp)
 90c00f4:	10c00617 	ldw	r3,24(r2)
 90c00f8:	e0bffd17 	ldw	r2,-12(fp)
 90c00fc:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 90c0100:	e0bffe17 	ldw	r2,-8(fp)
 90c0104:	10c00717 	ldw	r3,28(r2)
 90c0108:	e0bffd17 	ldw	r2,-12(fp)
 90c010c:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 90c0110:	e0bffe17 	ldw	r2,-8(fp)
 90c0114:	10c0080b 	ldhu	r3,32(r2)
 90c0118:	e0bffd17 	ldw	r2,-12(fp)
 90c011c:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 90c0120:	e0bffe17 	ldw	r2,-8(fp)
 90c0124:	10c00517 	ldw	r3,20(r2)
 90c0128:	e0bffd17 	ldw	r2,-12(fp)
 90c012c:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 90c0130:	e0bffd17 	ldw	r2,-12(fp)
 90c0134:	e0bfff15 	stw	r2,-4(fp)
 90c0138:	e0bfff17 	ldw	r2,-4(fp)
}
 90c013c:	e037883a 	mov	sp,fp
 90c0140:	dfc00117 	ldw	ra,4(sp)
 90c0144:	df000017 	ldw	fp,0(sp)
 90c0148:	dec00204 	addi	sp,sp,8
 90c014c:	f800283a 	ret

090c0150 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 90c0150:	defff904 	addi	sp,sp,-28
 90c0154:	df000615 	stw	fp,24(sp)
 90c0158:	df000604 	addi	fp,sp,24
 90c015c:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 90c0160:	e0bffe17 	ldw	r2,-8(fp)
 90c0164:	10800317 	ldw	r2,12(r2)
 90c0168:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 90c016c:	e0bffe17 	ldw	r2,-8(fp)
 90c0170:	10800417 	ldw	r2,16(r2)
 90c0174:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 90c0178:	e0bffe17 	ldw	r2,-8(fp)
 90c017c:	10800243 	ldbu	r2,9(r2)
 90c0180:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 90c0184:	e0bffe17 	ldw	r2,-8(fp)
 90c0188:	1080010b 	ldhu	r2,4(r2)
 90c018c:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c0190:	d0a0c917 	ldw	r2,-31964(gp)
 90c0194:	e0bffa15 	stw	r2,-24(fp)
 90c0198:	00001806 	br	90c01fc <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 90c019c:	e0bffa17 	ldw	r2,-24(fp)
 90c01a0:	10c00117 	ldw	r3,4(r2)
 90c01a4:	e0bffd17 	ldw	r2,-12(fp)
 90c01a8:	1880111e 	bne	r3,r2,90c01f0 <ip_reasm_match_frag_with_ire+0xa0>
 90c01ac:	e0bffa17 	ldw	r2,-24(fp)
 90c01b0:	10c00217 	ldw	r3,8(r2)
 90c01b4:	e0bffc17 	ldw	r2,-16(fp)
 90c01b8:	18800d1e 	bne	r3,r2,90c01f0 <ip_reasm_match_frag_with_ire+0xa0>
 90c01bc:	e0bffa17 	ldw	r2,-24(fp)
 90c01c0:	10800383 	ldbu	r2,14(r2)
 90c01c4:	10c03fcc 	andi	r3,r2,255
 90c01c8:	e0bffb83 	ldbu	r2,-18(fp)
 90c01cc:	1880081e 	bne	r3,r2,90c01f0 <ip_reasm_match_frag_with_ire+0xa0>
 90c01d0:	e0bffa17 	ldw	r2,-24(fp)
 90c01d4:	1080030b 	ldhu	r2,12(r2)
 90c01d8:	10ffffcc 	andi	r3,r2,65535
 90c01dc:	e0bffb0b 	ldhu	r2,-20(fp)
 90c01e0:	1880031e 	bne	r3,r2,90c01f0 <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 90c01e4:	e0bffa17 	ldw	r2,-24(fp)
 90c01e8:	e0bfff15 	stw	r2,-4(fp)
 90c01ec:	00000706 	br	90c020c <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c01f0:	e0bffa17 	ldw	r2,-24(fp)
 90c01f4:	10800017 	ldw	r2,0(r2)
 90c01f8:	e0bffa15 	stw	r2,-24(fp)
 90c01fc:	e0bffa17 	ldw	r2,-24(fp)
 90c0200:	1004c03a 	cmpne	r2,r2,zero
 90c0204:	103fe51e 	bne	r2,zero,90c019c <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 90c0208:	e03fff15 	stw	zero,-4(fp)
 90c020c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0210:	e037883a 	mov	sp,fp
 90c0214:	df000017 	ldw	fp,0(sp)
 90c0218:	dec00104 	addi	sp,sp,4
 90c021c:	f800283a 	ret

090c0220 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 90c0220:	defffc04 	addi	sp,sp,-16
 90c0224:	df000315 	stw	fp,12(sp)
 90c0228:	df000304 	addi	fp,sp,12
 90c022c:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 90c0230:	e0bfff17 	ldw	r2,-4(fp)
 90c0234:	1080018b 	ldhu	r2,6(r2)
 90c0238:	10bfffcc 	andi	r2,r2,65535
 90c023c:	1004d23a 	srli	r2,r2,8
 90c0240:	10bfffcc 	andi	r2,r2,65535
 90c0244:	10c03fcc 	andi	r3,r2,255
 90c0248:	e0bfff17 	ldw	r2,-4(fp)
 90c024c:	1080018b 	ldhu	r2,6(r2)
 90c0250:	10bfffcc 	andi	r2,r2,65535
 90c0254:	1004923a 	slli	r2,r2,8
 90c0258:	10bfc00c 	andi	r2,r2,65280
 90c025c:	1884b03a 	or	r2,r3,r2
 90c0260:	1088000c 	andi	r2,r2,8192
 90c0264:	1005d37a 	srai	r2,r2,13
 90c0268:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 90c026c:	e0bfff17 	ldw	r2,-4(fp)
 90c0270:	1080018b 	ldhu	r2,6(r2)
 90c0274:	10bfffcc 	andi	r2,r2,65535
 90c0278:	1004d23a 	srli	r2,r2,8
 90c027c:	10803fcc 	andi	r2,r2,255
 90c0280:	1009883a 	mov	r4,r2
 90c0284:	e0bfff17 	ldw	r2,-4(fp)
 90c0288:	1080018b 	ldhu	r2,6(r2)
 90c028c:	10bfffcc 	andi	r2,r2,65535
 90c0290:	1004923a 	slli	r2,r2,8
 90c0294:	1007883a 	mov	r3,r2
 90c0298:	00bfc004 	movi	r2,-256
 90c029c:	1884703a 	and	r2,r3,r2
 90c02a0:	2084b03a 	or	r2,r4,r2
 90c02a4:	1087ffcc 	andi	r2,r2,8191
 90c02a8:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 90c02ac:	e0bffe8b 	ldhu	r2,-6(fp)
 90c02b0:	1004c03a 	cmpne	r2,r2,zero
 90c02b4:	1000081e 	bne	r2,zero,90c02d8 <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 90c02b8:	e0bffe0b 	ldhu	r2,-8(fp)
 90c02bc:	1004c03a 	cmpne	r2,r2,zero
 90c02c0:	1000021e 	bne	r2,zero,90c02cc <ip_reasm_determine_type_of_frag+0xac>
 90c02c4:	e03ffd15 	stw	zero,-12(fp)
 90c02c8:	00000b06 	br	90c02f8 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 90c02cc:	00800144 	movi	r2,5
 90c02d0:	e0bffd15 	stw	r2,-12(fp)
 90c02d4:	00000806 	br	90c02f8 <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 90c02d8:	e0bffe0b 	ldhu	r2,-8(fp)
 90c02dc:	1004c03a 	cmpne	r2,r2,zero
 90c02e0:	1000031e 	bne	r2,zero,90c02f0 <ip_reasm_determine_type_of_frag+0xd0>
 90c02e4:	00800044 	movi	r2,1
 90c02e8:	e0bffd15 	stw	r2,-12(fp)
 90c02ec:	00000206 	br	90c02f8 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 90c02f0:	008000c4 	movi	r2,3
 90c02f4:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 90c02f8:	e0bffd17 	ldw	r2,-12(fp)
}
 90c02fc:	e037883a 	mov	sp,fp
 90c0300:	df000017 	ldw	fp,0(sp)
 90c0304:	dec00104 	addi	sp,sp,4
 90c0308:	f800283a 	ret

090c030c <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 90c030c:	defffd04 	addi	sp,sp,-12
 90c0310:	df000215 	stw	fp,8(sp)
 90c0314:	df000204 	addi	fp,sp,8
 90c0318:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90c031c:	d0e0c817 	ldw	r3,-31968(gp)
 90c0320:	008001b4 	movhi	r2,6
 90c0324:	10c0072e 	bgeu	r2,r3,90c0344 <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90c0328:	008243b4 	movhi	r2,2318
 90c032c:	10b84004 	addi	r2,r2,-7936
 90c0330:	10800217 	ldw	r2,8(r2)
 90c0334:	10c00044 	addi	r3,r2,1
 90c0338:	008243b4 	movhi	r2,2318
 90c033c:	10b84004 	addi	r2,r2,-7936
 90c0340:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 90c0344:	d0e0c817 	ldw	r3,-31968(gp)
 90c0348:	008001b4 	movhi	r2,6
 90c034c:	18800526 	beq	r3,r2,90c0364 <ip_reasm_check_mem_useage+0x58>
 90c0350:	e0fffe0b 	ldhu	r3,-8(fp)
 90c0354:	d0a0c817 	ldw	r2,-31968(gp)
 90c0358:	1887883a 	add	r3,r3,r2
 90c035c:	008001b4 	movhi	r2,6
 90c0360:	10c00a2e 	bgeu	r2,r3,90c038c <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 90c0364:	008243b4 	movhi	r2,2318
 90c0368:	10b84004 	addi	r2,r2,-7936
 90c036c:	10800317 	ldw	r2,12(r2)
 90c0370:	10c00044 	addi	r3,r2,1
 90c0374:	008243b4 	movhi	r2,2318
 90c0378:	10b84004 	addi	r2,r2,-7936
 90c037c:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 90c0380:	00bffa84 	movi	r2,-22
 90c0384:	e0bfff15 	stw	r2,-4(fp)
 90c0388:	00000106 	br	90c0390 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 90c038c:	e03fff15 	stw	zero,-4(fp)
 90c0390:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0394:	e037883a 	mov	sp,fp
 90c0398:	df000017 	ldw	fp,0(sp)
 90c039c:	dec00104 	addi	sp,sp,4
 90c03a0:	f800283a 	ret

090c03a4 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 90c03a4:	defffd04 	addi	sp,sp,-12
 90c03a8:	df000215 	stw	fp,8(sp)
 90c03ac:	df000204 	addi	fp,sp,8
 90c03b0:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90c03b4:	d0e0c817 	ldw	r3,-31968(gp)
 90c03b8:	008001b4 	movhi	r2,6
 90c03bc:	10c00a2e 	bgeu	r2,r3,90c03e8 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90c03c0:	008243b4 	movhi	r2,2318
 90c03c4:	10b84004 	addi	r2,r2,-7936
 90c03c8:	10800217 	ldw	r2,8(r2)
 90c03cc:	10c00044 	addi	r3,r2,1
 90c03d0:	008243b4 	movhi	r2,2318
 90c03d4:	10b84004 	addi	r2,r2,-7936
 90c03d8:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 90c03dc:	00bffa84 	movi	r2,-22
 90c03e0:	e0bfff15 	stw	r2,-4(fp)
 90c03e4:	00001406 	br	90c0438 <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 90c03e8:	e0fffe0b 	ldhu	r3,-8(fp)
 90c03ec:	d0a0c817 	ldw	r2,-31968(gp)
 90c03f0:	1887883a 	add	r3,r3,r2
 90c03f4:	008001b4 	movhi	r2,6
 90c03f8:	10c00a2e 	bgeu	r2,r3,90c0424 <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 90c03fc:	008243b4 	movhi	r2,2318
 90c0400:	10b84004 	addi	r2,r2,-7936
 90c0404:	10800417 	ldw	r2,16(r2)
 90c0408:	10c00044 	addi	r3,r2,1
 90c040c:	008243b4 	movhi	r2,2318
 90c0410:	10b84004 	addi	r2,r2,-7936
 90c0414:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 90c0418:	00bffa84 	movi	r2,-22
 90c041c:	e0bfff15 	stw	r2,-4(fp)
 90c0420:	00000506 	br	90c0438 <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 90c0424:	e0bffe0b 	ldhu	r2,-8(fp)
 90c0428:	d0e0c817 	ldw	r3,-31968(gp)
 90c042c:	10c5883a 	add	r2,r2,r3
 90c0430:	d0a0c815 	stw	r2,-31968(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 90c0434:	e03fff15 	stw	zero,-4(fp)
 90c0438:	e0bfff17 	ldw	r2,-4(fp)
}
 90c043c:	e037883a 	mov	sp,fp
 90c0440:	df000017 	ldw	fp,0(sp)
 90c0444:	dec00104 	addi	sp,sp,4
 90c0448:	f800283a 	ret

090c044c <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 90c044c:	defffd04 	addi	sp,sp,-12
 90c0450:	df000215 	stw	fp,8(sp)
 90c0454:	df000204 	addi	fp,sp,8
 90c0458:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 90c045c:	d0e0c817 	ldw	r3,-31968(gp)
 90c0460:	008001b4 	movhi	r2,6
 90c0464:	10c00a2e 	bgeu	r2,r3,90c0490 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 90c0468:	008243b4 	movhi	r2,2318
 90c046c:	10b84004 	addi	r2,r2,-7936
 90c0470:	10800217 	ldw	r2,8(r2)
 90c0474:	10c00044 	addi	r3,r2,1
 90c0478:	008243b4 	movhi	r2,2318
 90c047c:	10b84004 	addi	r2,r2,-7936
 90c0480:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 90c0484:	00bffa84 	movi	r2,-22
 90c0488:	e0bfff15 	stw	r2,-4(fp)
 90c048c:	00001206 	br	90c04d8 <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 90c0490:	e0fffe0b 	ldhu	r3,-8(fp)
 90c0494:	d0a0c817 	ldw	r2,-31968(gp)
 90c0498:	10c00a2e 	bgeu	r2,r3,90c04c4 <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 90c049c:	008243b4 	movhi	r2,2318
 90c04a0:	10b84004 	addi	r2,r2,-7936
 90c04a4:	10800517 	ldw	r2,20(r2)
 90c04a8:	10c00044 	addi	r3,r2,1
 90c04ac:	008243b4 	movhi	r2,2318
 90c04b0:	10b84004 	addi	r2,r2,-7936
 90c04b4:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 90c04b8:	00bffa84 	movi	r2,-22
 90c04bc:	e0bfff15 	stw	r2,-4(fp)
 90c04c0:	00000506 	br	90c04d8 <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 90c04c4:	d0a0c817 	ldw	r2,-31968(gp)
 90c04c8:	e0fffe0b 	ldhu	r3,-8(fp)
 90c04cc:	10c5c83a 	sub	r2,r2,r3
 90c04d0:	d0a0c815 	stw	r2,-31968(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 90c04d4:	e03fff15 	stw	zero,-4(fp)
 90c04d8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c04dc:	e037883a 	mov	sp,fp
 90c04e0:	df000017 	ldw	fp,0(sp)
 90c04e4:	dec00104 	addi	sp,sp,4
 90c04e8:	f800283a 	ret

090c04ec <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 90c04ec:	defff604 	addi	sp,sp,-40
 90c04f0:	dfc00915 	stw	ra,36(sp)
 90c04f4:	df000815 	stw	fp,32(sp)
 90c04f8:	df000804 	addi	fp,sp,32
 90c04fc:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 90c0500:	e0bffe17 	ldw	r2,-8(fp)
 90c0504:	10800217 	ldw	r2,8(r2)
 90c0508:	10802204 	addi	r2,r2,136
 90c050c:	113fffcc 	andi	r4,r2,65535
 90c0510:	90c030c0 	call	90c030c <ip_reasm_check_mem_useage>
 90c0514:	e0bff815 	stw	r2,-32(fp)
 90c0518:	e0bff817 	ldw	r2,-32(fp)
 90c051c:	1005003a 	cmpeq	r2,r2,zero
 90c0520:	1000101e 	bne	r2,zero,90c0564 <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0524:	01000084 	movi	r4,2
 90c0528:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c052c:	e13ffe17 	ldw	r4,-8(fp)
 90c0530:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0534:	01000084 	movi	r4,2
 90c0538:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90c053c:	008243b4 	movhi	r2,2318
 90c0540:	10b82c04 	addi	r2,r2,-8016
 90c0544:	10800f17 	ldw	r2,60(r2)
 90c0548:	10c00044 	addi	r3,r2,1
 90c054c:	008243b4 	movhi	r2,2318
 90c0550:	10b82c04 	addi	r2,r2,-8016
 90c0554:	10c00f15 	stw	r3,60(r2)
      return rc;
 90c0558:	e0bff817 	ldw	r2,-32(fp)
 90c055c:	e0bfff15 	stw	r2,-4(fp)
 90c0560:	00009406 	br	90c07b4 <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 90c0564:	01002204 	movi	r4,136
 90c0568:	90aaefc0 	call	90aaefc <npalloc>
 90c056c:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 90c0570:	e0bffc17 	ldw	r2,-16(fp)
 90c0574:	1004c03a 	cmpne	r2,r2,zero
 90c0578:	1000101e 	bne	r2,zero,90c05bc <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c057c:	01000084 	movi	r4,2
 90c0580:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c0584:	e13ffe17 	ldw	r4,-8(fp)
 90c0588:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c058c:	01000084 	movi	r4,2
 90c0590:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90c0594:	008243b4 	movhi	r2,2318
 90c0598:	10b82c04 	addi	r2,r2,-8016
 90c059c:	10800f17 	ldw	r2,60(r2)
 90c05a0:	10c00044 	addi	r3,r2,1
 90c05a4:	008243b4 	movhi	r2,2318
 90c05a8:	10b82c04 	addi	r2,r2,-8016
 90c05ac:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 90c05b0:	00bffa84 	movi	r2,-22
 90c05b4:	e0bfff15 	stw	r2,-4(fp)
 90c05b8:	00007e06 	br	90c07b4 <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 90c05bc:	e0bffe17 	ldw	r2,-8(fp)
 90c05c0:	10800317 	ldw	r2,12(r2)
 90c05c4:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 90c05c8:	e0bffd17 	ldw	r2,-12(fp)
 90c05cc:	10800003 	ldbu	r2,0(r2)
 90c05d0:	108003cc 	andi	r2,r2,15
 90c05d4:	1085883a 	add	r2,r2,r2
 90c05d8:	1085883a 	add	r2,r2,r2
 90c05dc:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 90c05e0:	e13ffd17 	ldw	r4,-12(fp)
 90c05e4:	90c02200 	call	90c0220 <ip_reasm_determine_type_of_frag>
 90c05e8:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90c05ec:	e0bffd17 	ldw	r2,-12(fp)
 90c05f0:	1080018b 	ldhu	r2,6(r2)
 90c05f4:	10bfffcc 	andi	r2,r2,65535
 90c05f8:	1004d23a 	srli	r2,r2,8
 90c05fc:	10803fcc 	andi	r2,r2,255
 90c0600:	1009883a 	mov	r4,r2
 90c0604:	e0bffd17 	ldw	r2,-12(fp)
 90c0608:	1080018b 	ldhu	r2,6(r2)
 90c060c:	10bfffcc 	andi	r2,r2,65535
 90c0610:	1004923a 	slli	r2,r2,8
 90c0614:	1007883a 	mov	r3,r2
 90c0618:	00bfc004 	movi	r2,-256
 90c061c:	1884703a 	and	r2,r3,r2
 90c0620:	2084b03a 	or	r2,r4,r2
 90c0624:	1087ffcc 	andi	r2,r2,8191
 90c0628:	100490fa 	slli	r2,r2,3
 90c062c:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 90c0630:	e0bffd17 	ldw	r2,-12(fp)
 90c0634:	1080008b 	ldhu	r2,2(r2)
 90c0638:	10bfffcc 	andi	r2,r2,65535
 90c063c:	1004d23a 	srli	r2,r2,8
 90c0640:	10803fcc 	andi	r2,r2,255
 90c0644:	1009883a 	mov	r4,r2
 90c0648:	e0bffd17 	ldw	r2,-12(fp)
 90c064c:	1080008b 	ldhu	r2,2(r2)
 90c0650:	10bfffcc 	andi	r2,r2,65535
 90c0654:	1004923a 	slli	r2,r2,8
 90c0658:	1007883a 	mov	r3,r2
 90c065c:	00bfc004 	movi	r2,-256
 90c0660:	1884703a 	and	r2,r3,r2
 90c0664:	2084b03a 	or	r2,r4,r2
 90c0668:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 90c066c:	e0bffd17 	ldw	r2,-12(fp)
 90c0670:	10c00317 	ldw	r3,12(r2)
 90c0674:	e0bffc17 	ldw	r2,-16(fp)
 90c0678:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 90c067c:	e0bffd17 	ldw	r2,-12(fp)
 90c0680:	10c00417 	ldw	r3,16(r2)
 90c0684:	e0bffc17 	ldw	r2,-16(fp)
 90c0688:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 90c068c:	e0bffd17 	ldw	r2,-12(fp)
 90c0690:	10c00243 	ldbu	r3,9(r2)
 90c0694:	e0bffc17 	ldw	r2,-16(fp)
 90c0698:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 90c069c:	e0bffd17 	ldw	r2,-12(fp)
 90c06a0:	10c0010b 	ldhu	r3,4(r2)
 90c06a4:	e0bffc17 	ldw	r2,-16(fp)
 90c06a8:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 90c06ac:	e0bffb17 	ldw	r2,-20(fp)
 90c06b0:	10800158 	cmpnei	r2,r2,5
 90c06b4:	10000a1e 	bne	r2,zero,90c06e0 <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 90c06b8:	e0fffa03 	ldbu	r3,-24(fp)
 90c06bc:	e0bff90b 	ldhu	r2,-28(fp)
 90c06c0:	10c5c83a 	sub	r2,r2,r3
 90c06c4:	1007883a 	mov	r3,r2
 90c06c8:	e0bff98b 	ldhu	r2,-26(fp)
 90c06cc:	1885883a 	add	r2,r3,r2
 90c06d0:	1007883a 	mov	r3,r2
 90c06d4:	e0bffc17 	ldw	r2,-16(fp)
 90c06d8:	10c0040d 	sth	r3,16(r2)
 90c06dc:	00000a06 	br	90c0708 <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 90c06e0:	e0bffb17 	ldw	r2,-20(fp)
 90c06e4:	10800058 	cmpnei	r2,r2,1
 90c06e8:	1000071e 	bne	r2,zero,90c0708 <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 90c06ec:	e0bffe17 	ldw	r2,-8(fp)
 90c06f0:	10c00117 	ldw	r3,4(r2)
 90c06f4:	e0bffc17 	ldw	r2,-16(fp)
 90c06f8:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 90c06fc:	e0fffd17 	ldw	r3,-12(fp)
 90c0700:	e0bffc17 	ldw	r2,-16(fp)
 90c0704:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 90c0708:	e0fffa03 	ldbu	r3,-24(fp)
 90c070c:	e0bff90b 	ldhu	r2,-28(fp)
 90c0710:	10c5c83a 	sub	r2,r2,r3
 90c0714:	1007883a 	mov	r3,r2
 90c0718:	e0bffc17 	ldw	r2,-16(fp)
 90c071c:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 90c0720:	e0bffc17 	ldw	r2,-16(fp)
 90c0724:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 90c0728:	e0bffc17 	ldw	r2,-16(fp)
 90c072c:	10802103 	ldbu	r2,132(r2)
 90c0730:	10800054 	ori	r2,r2,1
 90c0734:	1007883a 	mov	r3,r2
 90c0738:	e0bffc17 	ldw	r2,-16(fp)
 90c073c:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 90c0740:	e0fffc17 	ldw	r3,-16(fp)
 90c0744:	e0bffe17 	ldw	r2,-8(fp)
 90c0748:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 90c074c:	e0fffc17 	ldw	r3,-16(fp)
 90c0750:	e0bff98b 	ldhu	r2,-26(fp)
 90c0754:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 90c0758:	e0bffe17 	ldw	r2,-8(fp)
 90c075c:	10c00317 	ldw	r3,12(r2)
 90c0760:	e0bffa03 	ldbu	r2,-24(fp)
 90c0764:	1887883a 	add	r3,r3,r2
 90c0768:	e0bffe17 	ldw	r2,-8(fp)
 90c076c:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 90c0770:	e0bffe17 	ldw	r2,-8(fp)
 90c0774:	10c00417 	ldw	r3,16(r2)
 90c0778:	e0bffa03 	ldbu	r2,-24(fp)
 90c077c:	1887c83a 	sub	r3,r3,r2
 90c0780:	e0bffe17 	ldw	r2,-8(fp)
 90c0784:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 90c0788:	d0e0c917 	ldw	r3,-31964(gp)
 90c078c:	e0bffc17 	ldw	r2,-16(fp)
 90c0790:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 90c0794:	e0bffc17 	ldw	r2,-16(fp)
 90c0798:	d0a0c915 	stw	r2,-31964(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 90c079c:	e0bffe17 	ldw	r2,-8(fp)
 90c07a0:	10800217 	ldw	r2,8(r2)
 90c07a4:	10802204 	addi	r2,r2,136
 90c07a8:	113fffcc 	andi	r4,r2,65535
 90c07ac:	90c03a40 	call	90c03a4 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 90c07b0:	e03fff15 	stw	zero,-4(fp)
 90c07b4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c07b8:	e037883a 	mov	sp,fp
 90c07bc:	dfc00117 	ldw	ra,4(sp)
 90c07c0:	df000017 	ldw	fp,0(sp)
 90c07c4:	dec00204 	addi	sp,sp,8
 90c07c8:	f800283a 	ret

090c07cc <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 90c07cc:	defff804 	addi	sp,sp,-32
 90c07d0:	dfc00715 	stw	ra,28(sp)
 90c07d4:	df000615 	stw	fp,24(sp)
 90c07d8:	df000604 	addi	fp,sp,24
 90c07dc:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 90c07e0:	e0bffe17 	ldw	r2,-8(fp)
 90c07e4:	10800317 	ldw	r2,12(r2)
 90c07e8:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 90c07ec:	e13ffc17 	ldw	r4,-16(fp)
 90c07f0:	90c01500 	call	90c0150 <ip_reasm_match_frag_with_ire>
 90c07f4:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 90c07f8:	e0bffd17 	ldw	r2,-12(fp)
 90c07fc:	1004c03a 	cmpne	r2,r2,zero
 90c0800:	1000091e 	bne	r2,zero,90c0828 <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 90c0804:	e13ffe17 	ldw	r4,-8(fp)
 90c0808:	90c04ec0 	call	90c04ec <ip_reasm_process_first_fragment>
 90c080c:	e0bffb15 	stw	r2,-20(fp)
 90c0810:	e0bffb17 	ldw	r2,-20(fp)
 90c0814:	1005003a 	cmpeq	r2,r2,zero
 90c0818:	10000d1e 	bne	r2,zero,90c0850 <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 90c081c:	e0bffb17 	ldw	r2,-20(fp)
 90c0820:	e0bfff15 	stw	r2,-4(fp)
 90c0824:	00000b06 	br	90c0854 <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 90c0828:	e13ffe17 	ldw	r4,-8(fp)
 90c082c:	e17ffd17 	ldw	r5,-12(fp)
 90c0830:	90c0dfc0 	call	90c0dfc <ip_reasm_process_subsequent_fragments>
 90c0834:	e0bffa15 	stw	r2,-24(fp)
 90c0838:	e0bffa17 	ldw	r2,-24(fp)
 90c083c:	1005003a 	cmpeq	r2,r2,zero
 90c0840:	1000031e 	bne	r2,zero,90c0850 <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 90c0844:	e0bffa17 	ldw	r2,-24(fp)
 90c0848:	e0bfff15 	stw	r2,-4(fp)
 90c084c:	00000106 	br	90c0854 <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 90c0850:	e03fff15 	stw	zero,-4(fp)
 90c0854:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0858:	e037883a 	mov	sp,fp
 90c085c:	dfc00117 	ldw	ra,4(sp)
 90c0860:	df000017 	ldw	fp,0(sp)
 90c0864:	dec00204 	addi	sp,sp,8
 90c0868:	f800283a 	ret

090c086c <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 90c086c:	defff204 	addi	sp,sp,-56
 90c0870:	dfc00d15 	stw	ra,52(sp)
 90c0874:	df000c15 	stw	fp,48(sp)
 90c0878:	df000c04 	addi	fp,sp,48
 90c087c:	e13ffb15 	stw	r4,-20(fp)
 90c0880:	e17ffc15 	stw	r5,-16(fp)
 90c0884:	e1bffd15 	stw	r6,-12(fp)
 90c0888:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90c088c:	e13ffc17 	ldw	r4,-16(fp)
 90c0890:	90c13900 	call	90c1390 <ip_reasm_find_ire>
 90c0894:	10803fcc 	andi	r2,r2,255
 90c0898:	10800060 	cmpeqi	r2,r2,1
 90c089c:	1000101e 	bne	r2,zero,90c08e0 <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 90c08a0:	008243b4 	movhi	r2,2318
 90c08a4:	10b84004 	addi	r2,r2,-7936
 90c08a8:	10800017 	ldw	r2,0(r2)
 90c08ac:	10c00044 	addi	r3,r2,1
 90c08b0:	008243b4 	movhi	r2,2318
 90c08b4:	10b84004 	addi	r2,r2,-7936
 90c08b8:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c08bc:	01000084 	movi	r4,2
 90c08c0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c08c4:	e13ffb17 	ldw	r4,-20(fp)
 90c08c8:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c08cc:	01000084 	movi	r4,2
 90c08d0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 90c08d4:	00800044 	movi	r2,1
 90c08d8:	e0bfff15 	stw	r2,-4(fp)
 90c08dc:	00014106 	br	90c0de4 <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 90c08e0:	e0bffb17 	ldw	r2,-20(fp)
 90c08e4:	10800317 	ldw	r2,12(r2)
 90c08e8:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 90c08ec:	e0bff817 	ldw	r2,-32(fp)
 90c08f0:	10800003 	ldbu	r2,0(r2)
 90c08f4:	108003cc 	andi	r2,r2,15
 90c08f8:	1085883a 	add	r2,r2,r2
 90c08fc:	1085883a 	add	r2,r2,r2
 90c0900:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 90c0904:	e0bff817 	ldw	r2,-32(fp)
 90c0908:	1080018b 	ldhu	r2,6(r2)
 90c090c:	10bfffcc 	andi	r2,r2,65535
 90c0910:	1004d23a 	srli	r2,r2,8
 90c0914:	10803fcc 	andi	r2,r2,255
 90c0918:	1009883a 	mov	r4,r2
 90c091c:	e0bff817 	ldw	r2,-32(fp)
 90c0920:	1080018b 	ldhu	r2,6(r2)
 90c0924:	10bfffcc 	andi	r2,r2,65535
 90c0928:	1004923a 	slli	r2,r2,8
 90c092c:	1007883a 	mov	r3,r2
 90c0930:	00bfc004 	movi	r2,-256
 90c0934:	1884703a 	and	r2,r3,r2
 90c0938:	2084b03a 	or	r2,r4,r2
 90c093c:	1087ffcc 	andi	r2,r2,8191
 90c0940:	100490fa 	slli	r2,r2,3
 90c0944:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 90c0948:	e0bff817 	ldw	r2,-32(fp)
 90c094c:	1080008b 	ldhu	r2,2(r2)
 90c0950:	10bfffcc 	andi	r2,r2,65535
 90c0954:	1004d23a 	srli	r2,r2,8
 90c0958:	10803fcc 	andi	r2,r2,255
 90c095c:	1009883a 	mov	r4,r2
 90c0960:	e0bff817 	ldw	r2,-32(fp)
 90c0964:	1080008b 	ldhu	r2,2(r2)
 90c0968:	10bfffcc 	andi	r2,r2,65535
 90c096c:	1004923a 	slli	r2,r2,8
 90c0970:	1007883a 	mov	r3,r2
 90c0974:	00bfc004 	movi	r2,-256
 90c0978:	1884703a 	and	r2,r3,r2
 90c097c:	2084b03a 	or	r2,r4,r2
 90c0980:	1007883a 	mov	r3,r2
 90c0984:	e0bff483 	ldbu	r2,-46(fp)
 90c0988:	1885c83a 	sub	r2,r3,r2
 90c098c:	1007883a 	mov	r3,r2
 90c0990:	e0bff70b 	ldhu	r2,-36(fp)
 90c0994:	1885883a 	add	r2,r3,r2
 90c0998:	10bfffc4 	addi	r2,r2,-1
 90c099c:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 90c09a0:	e0bffb17 	ldw	r2,-20(fp)
 90c09a4:	10c00317 	ldw	r3,12(r2)
 90c09a8:	e0bff483 	ldbu	r2,-46(fp)
 90c09ac:	1887883a 	add	r3,r3,r2
 90c09b0:	e0bffb17 	ldw	r2,-20(fp)
 90c09b4:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 90c09b8:	e0bffb17 	ldw	r2,-20(fp)
 90c09bc:	10c00417 	ldw	r3,16(r2)
 90c09c0:	e0bff483 	ldbu	r2,-46(fp)
 90c09c4:	1887c83a 	sub	r3,r3,r2
 90c09c8:	e0bffb17 	ldw	r2,-20(fp)
 90c09cc:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 90c09d0:	e0c00217 	ldw	r3,8(fp)
 90c09d4:	e0bff70b 	ldhu	r2,-36(fp)
 90c09d8:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 90c09dc:	e0fffd17 	ldw	r3,-12(fp)
 90c09e0:	00800404 	movi	r2,16
 90c09e4:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 90c09e8:	e0bffe17 	ldw	r2,-8(fp)
 90c09ec:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 90c09f0:	e0800317 	ldw	r2,12(fp)
 90c09f4:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 90c09f8:	e0bffc17 	ldw	r2,-16(fp)
 90c09fc:	10800604 	addi	r2,r2,24
 90c0a00:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 90c0a04:	0000ef06 	br	90c0dc4 <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0a08:	e03ff40d 	sth	zero,-48(fp)
 90c0a0c:	0000df06 	br	90c0d8c <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 90c0a10:	e0bff40b 	ldhu	r2,-48(fp)
 90c0a14:	e0fffa17 	ldw	r3,-24(fp)
 90c0a18:	1085883a 	add	r2,r2,r2
 90c0a1c:	1085883a 	add	r2,r2,r2
 90c0a20:	10c5883a 	add	r2,r2,r3
 90c0a24:	10800104 	addi	r2,r2,4
 90c0a28:	10800017 	ldw	r2,0(r2)
 90c0a2c:	e0bff915 	stw	r2,-28(fp)
 90c0a30:	e0bff917 	ldw	r2,-28(fp)
 90c0a34:	1005003a 	cmpeq	r2,r2,zero
 90c0a38:	1000bf1e 	bne	r2,zero,90c0d38 <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 90c0a3c:	e0bff40b 	ldhu	r2,-48(fp)
 90c0a40:	e0fffa17 	ldw	r3,-24(fp)
 90c0a44:	1085883a 	add	r2,r2,r2
 90c0a48:	10c5883a 	add	r2,r2,r3
 90c0a4c:	10801104 	addi	r2,r2,68
 90c0a50:	1080000b 	ldhu	r2,0(r2)
 90c0a54:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 90c0a58:	e0bff917 	ldw	r2,-28(fp)
 90c0a5c:	10800417 	ldw	r2,16(r2)
 90c0a60:	1007883a 	mov	r3,r2
 90c0a64:	e0bff60b 	ldhu	r2,-40(fp)
 90c0a68:	1885883a 	add	r2,r3,r2
 90c0a6c:	10bfffc4 	addi	r2,r2,-1
 90c0a70:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 90c0a74:	e0fff60b 	ldhu	r3,-40(fp)
 90c0a78:	e0bff70b 	ldhu	r2,-36(fp)
 90c0a7c:	18802b2e 	bgeu	r3,r2,90c0b2c <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 90c0a80:	e0fff58b 	ldhu	r3,-42(fp)
 90c0a84:	e0bff68b 	ldhu	r2,-38(fp)
 90c0a88:	1880202e 	bgeu	r3,r2,90c0b0c <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 90c0a8c:	e0fff58b 	ldhu	r3,-42(fp)
 90c0a90:	e0bff70b 	ldhu	r2,-36(fp)
 90c0a94:	1880ba36 	bltu	r3,r2,90c0d80 <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 90c0a98:	e0fff58b 	ldhu	r3,-42(fp)
 90c0a9c:	e0bff70b 	ldhu	r2,-36(fp)
 90c0aa0:	1885c83a 	sub	r2,r3,r2
 90c0aa4:	10800044 	addi	r2,r2,1
 90c0aa8:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 90c0aac:	e0bffb17 	ldw	r2,-20(fp)
 90c0ab0:	10c00317 	ldw	r3,12(r2)
 90c0ab4:	e0bff50b 	ldhu	r2,-44(fp)
 90c0ab8:	1887883a 	add	r3,r3,r2
 90c0abc:	e0bffb17 	ldw	r2,-20(fp)
 90c0ac0:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 90c0ac4:	e0bffb17 	ldw	r2,-20(fp)
 90c0ac8:	10c00417 	ldw	r3,16(r2)
 90c0acc:	e0bff50b 	ldhu	r2,-44(fp)
 90c0ad0:	1887c83a 	sub	r3,r3,r2
 90c0ad4:	e0bffb17 	ldw	r2,-20(fp)
 90c0ad8:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 90c0adc:	e0fff70b 	ldhu	r3,-36(fp)
 90c0ae0:	e0bff50b 	ldhu	r2,-44(fp)
 90c0ae4:	1885883a 	add	r2,r3,r2
 90c0ae8:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 90c0aec:	e0bffb17 	ldw	r2,-20(fp)
 90c0af0:	10800417 	ldw	r2,16(r2)
 90c0af4:	1007883a 	mov	r3,r2
 90c0af8:	e0bff70b 	ldhu	r2,-36(fp)
 90c0afc:	1885883a 	add	r2,r3,r2
 90c0b00:	10bfffc4 	addi	r2,r2,-1
 90c0b04:	e0bff68d 	sth	r2,-38(fp)
 90c0b08:	00009d06 	br	90c0d80 <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0b0c:	01000084 	movi	r4,2
 90c0b10:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90c0b14:	e13ffb17 	ldw	r4,-20(fp)
 90c0b18:	90a9bc80 	call	90a9bc8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0b1c:	01000084 	movi	r4,2
 90c0b20:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90c0b24:	e03fff15 	stw	zero,-4(fp)
 90c0b28:	0000ae06 	br	90c0de4 <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 90c0b2c:	e0fff60b 	ldhu	r3,-40(fp)
 90c0b30:	e0bff70b 	ldhu	r2,-36(fp)
 90c0b34:	10c04d2e 	bgeu	r2,r3,90c0c6c <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 90c0b38:	e0fff58b 	ldhu	r3,-42(fp)
 90c0b3c:	e0bff68b 	ldhu	r2,-38(fp)
 90c0b40:	10c0112e 	bgeu	r2,r3,90c0b88 <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 90c0b44:	e0fff60b 	ldhu	r3,-40(fp)
 90c0b48:	e0bff68b 	ldhu	r2,-38(fp)
 90c0b4c:	10c08c36 	bltu	r2,r3,90c0d80 <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 90c0b50:	e0fff60b 	ldhu	r3,-40(fp)
 90c0b54:	e0bff70b 	ldhu	r2,-36(fp)
 90c0b58:	1885c83a 	sub	r2,r3,r2
 90c0b5c:	1007883a 	mov	r3,r2
 90c0b60:	e0bffb17 	ldw	r2,-20(fp)
 90c0b64:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 90c0b68:	e0bffb17 	ldw	r2,-20(fp)
 90c0b6c:	10800417 	ldw	r2,16(r2)
 90c0b70:	1007883a 	mov	r3,r2
 90c0b74:	e0bff70b 	ldhu	r2,-36(fp)
 90c0b78:	1885883a 	add	r2,r3,r2
 90c0b7c:	10bfffc4 	addi	r2,r2,-1
 90c0b80:	e0bff68d 	sth	r2,-38(fp)
 90c0b84:	00007e06 	br	90c0d80 <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 90c0b88:	e0fff58b 	ldhu	r3,-42(fp)
 90c0b8c:	e0bff68b 	ldhu	r2,-38(fp)
 90c0b90:	18800e1e 	bne	r3,r2,90c0bcc <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 90c0b94:	e0fff60b 	ldhu	r3,-40(fp)
 90c0b98:	e0bff70b 	ldhu	r2,-36(fp)
 90c0b9c:	1885c83a 	sub	r2,r3,r2
 90c0ba0:	1007883a 	mov	r3,r2
 90c0ba4:	e0bffb17 	ldw	r2,-20(fp)
 90c0ba8:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 90c0bac:	e0bffb17 	ldw	r2,-20(fp)
 90c0bb0:	10800417 	ldw	r2,16(r2)
 90c0bb4:	1007883a 	mov	r3,r2
 90c0bb8:	e0bff70b 	ldhu	r2,-36(fp)
 90c0bbc:	1885883a 	add	r2,r3,r2
 90c0bc0:	10bfffc4 	addi	r2,r2,-1
 90c0bc4:	e0bff68d 	sth	r2,-38(fp)
 90c0bc8:	00006d06 	br	90c0d80 <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 90c0bcc:	e0bff917 	ldw	r2,-28(fp)
 90c0bd0:	10800217 	ldw	r2,8(r2)
 90c0bd4:	113fffcc 	andi	r4,r2,65535
 90c0bd8:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 90c0bdc:	e0bffc17 	ldw	r2,-16(fp)
 90c0be0:	10c0048b 	ldhu	r3,18(r2)
 90c0be4:	e0bff917 	ldw	r2,-28(fp)
 90c0be8:	10800417 	ldw	r2,16(r2)
 90c0bec:	1885c83a 	sub	r2,r3,r2
 90c0bf0:	1007883a 	mov	r3,r2
 90c0bf4:	e0bffc17 	ldw	r2,-16(fp)
 90c0bf8:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0bfc:	01000084 	movi	r4,2
 90c0c00:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 90c0c04:	e13ff917 	ldw	r4,-28(fp)
 90c0c08:	90a9bc80 	call	90a9bc8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0c0c:	01000084 	movi	r4,2
 90c0c10:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 90c0c14:	e0bff40b 	ldhu	r2,-48(fp)
 90c0c18:	e0fffa17 	ldw	r3,-24(fp)
 90c0c1c:	1085883a 	add	r2,r2,r2
 90c0c20:	1085883a 	add	r2,r2,r2
 90c0c24:	10c5883a 	add	r2,r2,r3
 90c0c28:	10800104 	addi	r2,r2,4
 90c0c2c:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 90c0c30:	e0bffd17 	ldw	r2,-12(fp)
 90c0c34:	1080000b 	ldhu	r2,0(r2)
 90c0c38:	10bfffcc 	andi	r2,r2,65535
 90c0c3c:	10800418 	cmpnei	r2,r2,16
 90c0c40:	1000061e 	bne	r2,zero,90c0c5c <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 90c0c44:	e0fffd17 	ldw	r3,-12(fp)
 90c0c48:	e0bff40b 	ldhu	r2,-48(fp)
 90c0c4c:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 90c0c50:	e0fffe17 	ldw	r3,-8(fp)
 90c0c54:	e0bffa17 	ldw	r2,-24(fp)
 90c0c58:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 90c0c5c:	e0c00317 	ldw	r3,12(fp)
 90c0c60:	00800044 	movi	r2,1
 90c0c64:	18800005 	stb	r2,0(r3)
 90c0c68:	00004506 	br	90c0d80 <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 90c0c6c:	e0fff58b 	ldhu	r3,-42(fp)
 90c0c70:	e0bff68b 	ldhu	r2,-38(fp)
 90c0c74:	1880081e 	bne	r3,r2,90c0c98 <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0c78:	01000084 	movi	r4,2
 90c0c7c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90c0c80:	e13ffb17 	ldw	r4,-20(fp)
 90c0c84:	90a9bc80 	call	90a9bc8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0c88:	01000084 	movi	r4,2
 90c0c8c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90c0c90:	e03fff15 	stw	zero,-4(fp)
 90c0c94:	00005306 	br	90c0de4 <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 90c0c98:	e0fff58b 	ldhu	r3,-42(fp)
 90c0c9c:	e0bff68b 	ldhu	r2,-38(fp)
 90c0ca0:	10c0082e 	bgeu	r2,r3,90c0cc4 <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0ca4:	01000084 	movi	r4,2
 90c0ca8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
                  pk_free (p);
 90c0cac:	e13ffb17 	ldw	r4,-20(fp)
 90c0cb0:	90a9bc80 	call	90a9bc8 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0cb4:	01000084 	movi	r4,2
 90c0cb8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 90c0cbc:	e03fff15 	stw	zero,-4(fp)
 90c0cc0:	00004806 	br	90c0de4 <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 90c0cc4:	e0fff58b 	ldhu	r3,-42(fp)
 90c0cc8:	e0bff70b 	ldhu	r2,-36(fp)
 90c0ccc:	1885c83a 	sub	r2,r3,r2
 90c0cd0:	10800044 	addi	r2,r2,1
 90c0cd4:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 90c0cd8:	e0bffb17 	ldw	r2,-20(fp)
 90c0cdc:	10c00317 	ldw	r3,12(r2)
 90c0ce0:	e0bff50b 	ldhu	r2,-44(fp)
 90c0ce4:	1887883a 	add	r3,r3,r2
 90c0ce8:	e0bffb17 	ldw	r2,-20(fp)
 90c0cec:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 90c0cf0:	e0bffb17 	ldw	r2,-20(fp)
 90c0cf4:	10c00417 	ldw	r3,16(r2)
 90c0cf8:	e0bff50b 	ldhu	r2,-44(fp)
 90c0cfc:	1887c83a 	sub	r3,r3,r2
 90c0d00:	e0bffb17 	ldw	r2,-20(fp)
 90c0d04:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 90c0d08:	e0fff70b 	ldhu	r3,-36(fp)
 90c0d0c:	e0bff50b 	ldhu	r2,-44(fp)
 90c0d10:	1885883a 	add	r2,r3,r2
 90c0d14:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 90c0d18:	e0bffb17 	ldw	r2,-20(fp)
 90c0d1c:	10800417 	ldw	r2,16(r2)
 90c0d20:	1007883a 	mov	r3,r2
 90c0d24:	e0bff70b 	ldhu	r2,-36(fp)
 90c0d28:	1885883a 	add	r2,r3,r2
 90c0d2c:	10bfffc4 	addi	r2,r2,-1
 90c0d30:	e0bff68d 	sth	r2,-38(fp)
 90c0d34:	00001206 	br	90c0d80 <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 90c0d38:	e0bffd17 	ldw	r2,-12(fp)
 90c0d3c:	1080000b 	ldhu	r2,0(r2)
 90c0d40:	10bfffcc 	andi	r2,r2,65535
 90c0d44:	10800418 	cmpnei	r2,r2,16
 90c0d48:	1000061e 	bne	r2,zero,90c0d64 <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 90c0d4c:	e0fffd17 	ldw	r3,-12(fp)
 90c0d50:	e0bff40b 	ldhu	r2,-48(fp)
 90c0d54:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 90c0d58:	e0fffe17 	ldw	r3,-8(fp)
 90c0d5c:	e0bffa17 	ldw	r2,-24(fp)
 90c0d60:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 90c0d64:	e0bffc17 	ldw	r2,-16(fp)
 90c0d68:	10802103 	ldbu	r2,132(r2)
 90c0d6c:	10803fcc 	andi	r2,r2,255
 90c0d70:	1080004c 	andi	r2,r2,1
 90c0d74:	10803fcc 	andi	r2,r2,255
 90c0d78:	1004c03a 	cmpne	r2,r2,zero
 90c0d7c:	1000061e 	bne	r2,zero,90c0d98 <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c0d80:	e0bff40b 	ldhu	r2,-48(fp)
 90c0d84:	10800044 	addi	r2,r2,1
 90c0d88:	e0bff40d 	sth	r2,-48(fp)
 90c0d8c:	e0bff40b 	ldhu	r2,-48(fp)
 90c0d90:	10800430 	cmpltui	r2,r2,16
 90c0d94:	103f1e1e 	bne	r2,zero,90c0a10 <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 90c0d98:	e0bffd17 	ldw	r2,-12(fp)
 90c0d9c:	1080000b 	ldhu	r2,0(r2)
 90c0da0:	10bfffcc 	andi	r2,r2,65535
 90c0da4:	10800418 	cmpnei	r2,r2,16
 90c0da8:	1000031e 	bne	r2,zero,90c0db8 <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 90c0dac:	e0fffe17 	ldw	r3,-8(fp)
 90c0db0:	e0bffa17 	ldw	r2,-24(fp)
 90c0db4:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 90c0db8:	e0bffa17 	ldw	r2,-24(fp)
 90c0dbc:	10800017 	ldw	r2,0(r2)
 90c0dc0:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 90c0dc4:	e0bffa17 	ldw	r2,-24(fp)
 90c0dc8:	1004c03a 	cmpne	r2,r2,zero
 90c0dcc:	103f0e1e 	bne	r2,zero,90c0a08 <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 90c0dd0:	e0c00217 	ldw	r3,8(fp)
 90c0dd4:	e0bff70b 	ldhu	r2,-36(fp)
 90c0dd8:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 90c0ddc:	00800084 	movi	r2,2
 90c0de0:	e0bfff15 	stw	r2,-4(fp)
 90c0de4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c0de8:	e037883a 	mov	sp,fp
 90c0dec:	dfc00117 	ldw	ra,4(sp)
 90c0df0:	df000017 	ldw	fp,0(sp)
 90c0df4:	dec00204 	addi	sp,sp,8
 90c0df8:	f800283a 	ret

090c0dfc <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 90c0dfc:	deffed04 	addi	sp,sp,-76
 90c0e00:	dfc01215 	stw	ra,72(sp)
 90c0e04:	df001115 	stw	fp,68(sp)
 90c0e08:	df001104 	addi	fp,sp,68
 90c0e0c:	e13ffa15 	stw	r4,-24(fp)
 90c0e10:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 90c0e14:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90c0e18:	e13ffb17 	ldw	r4,-20(fp)
 90c0e1c:	90c13900 	call	90c1390 <ip_reasm_find_ire>
 90c0e20:	10803fcc 	andi	r2,r2,255
 90c0e24:	10800060 	cmpeqi	r2,r2,1
 90c0e28:	1000171e 	bne	r2,zero,90c0e88 <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 90c0e2c:	008243b4 	movhi	r2,2318
 90c0e30:	10b84004 	addi	r2,r2,-7936
 90c0e34:	10800017 	ldw	r2,0(r2)
 90c0e38:	10c00044 	addi	r3,r2,1
 90c0e3c:	008243b4 	movhi	r2,2318
 90c0e40:	10b84004 	addi	r2,r2,-7936
 90c0e44:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c0e48:	01000084 	movi	r4,2
 90c0e4c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c0e50:	e13ffa17 	ldw	r4,-24(fp)
 90c0e54:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c0e58:	01000084 	movi	r4,2
 90c0e5c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 90c0e60:	008243b4 	movhi	r2,2318
 90c0e64:	10b82c04 	addi	r2,r2,-8016
 90c0e68:	10800f17 	ldw	r2,60(r2)
 90c0e6c:	10c00044 	addi	r3,r2,1
 90c0e70:	008243b4 	movhi	r2,2318
 90c0e74:	10b82c04 	addi	r2,r2,-8016
 90c0e78:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 90c0e7c:	00bffd84 	movi	r2,-10
 90c0e80:	e0bffe15 	stw	r2,-8(fp)
 90c0e84:	00013c06 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 90c0e88:	e0bffa17 	ldw	r2,-24(fp)
 90c0e8c:	10800317 	ldw	r2,12(r2)
 90c0e90:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 90c0e94:	e13ff517 	ldw	r4,-44(fp)
 90c0e98:	90c02200 	call	90c0220 <ip_reasm_determine_type_of_frag>
 90c0e9c:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 90c0ea0:	e0bff217 	ldw	r2,-56(fp)
 90c0ea4:	10800158 	cmpnei	r2,r2,5
 90c0ea8:	10002c1e 	bne	r2,zero,90c0f5c <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 90c0eac:	e0bff517 	ldw	r2,-44(fp)
 90c0eb0:	1080018b 	ldhu	r2,6(r2)
 90c0eb4:	10bfffcc 	andi	r2,r2,65535
 90c0eb8:	1004d23a 	srli	r2,r2,8
 90c0ebc:	10803fcc 	andi	r2,r2,255
 90c0ec0:	1009883a 	mov	r4,r2
 90c0ec4:	e0bff517 	ldw	r2,-44(fp)
 90c0ec8:	1080018b 	ldhu	r2,6(r2)
 90c0ecc:	10bfffcc 	andi	r2,r2,65535
 90c0ed0:	1004923a 	slli	r2,r2,8
 90c0ed4:	1007883a 	mov	r3,r2
 90c0ed8:	00bfc004 	movi	r2,-256
 90c0edc:	1884703a 	and	r2,r3,r2
 90c0ee0:	2084b03a 	or	r2,r4,r2
 90c0ee4:	1087ffcc 	andi	r2,r2,8191
 90c0ee8:	100490fa 	slli	r2,r2,3
 90c0eec:	100b883a 	mov	r5,r2
 90c0ef0:	e0bff517 	ldw	r2,-44(fp)
 90c0ef4:	1080008b 	ldhu	r2,2(r2)
 90c0ef8:	10bfffcc 	andi	r2,r2,65535
 90c0efc:	1004d23a 	srli	r2,r2,8
 90c0f00:	10803fcc 	andi	r2,r2,255
 90c0f04:	1009883a 	mov	r4,r2
 90c0f08:	e0bff517 	ldw	r2,-44(fp)
 90c0f0c:	1080008b 	ldhu	r2,2(r2)
 90c0f10:	10bfffcc 	andi	r2,r2,65535
 90c0f14:	1004923a 	slli	r2,r2,8
 90c0f18:	1007883a 	mov	r3,r2
 90c0f1c:	00bfc004 	movi	r2,-256
 90c0f20:	1884703a 	and	r2,r3,r2
 90c0f24:	2084b03a 	or	r2,r4,r2
 90c0f28:	1007883a 	mov	r3,r2
 90c0f2c:	e0bff517 	ldw	r2,-44(fp)
 90c0f30:	10800003 	ldbu	r2,0(r2)
 90c0f34:	10803fcc 	andi	r2,r2,255
 90c0f38:	108003cc 	andi	r2,r2,15
 90c0f3c:	1085883a 	add	r2,r2,r2
 90c0f40:	1085883a 	add	r2,r2,r2
 90c0f44:	1885c83a 	sub	r2,r3,r2
 90c0f48:	2885883a 	add	r2,r5,r2
 90c0f4c:	1007883a 	mov	r3,r2
 90c0f50:	e0bffb17 	ldw	r2,-20(fp)
 90c0f54:	10c0040d 	sth	r3,16(r2)
 90c0f58:	00000a06 	br	90c0f84 <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 90c0f5c:	e0bff217 	ldw	r2,-56(fp)
 90c0f60:	10800058 	cmpnei	r2,r2,1
 90c0f64:	1000071e 	bne	r2,zero,90c0f84 <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 90c0f68:	e0bffa17 	ldw	r2,-24(fp)
 90c0f6c:	10c00117 	ldw	r3,4(r2)
 90c0f70:	e0bffb17 	ldw	r2,-20(fp)
 90c0f74:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 90c0f78:	e0fff517 	ldw	r3,-44(fp)
 90c0f7c:	e0bffb17 	ldw	r2,-20(fp)
 90c0f80:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 90c0f84:	e1bff704 	addi	r6,fp,-36
 90c0f88:	e1fff804 	addi	r7,fp,-32
 90c0f8c:	e0bff904 	addi	r2,fp,-28
 90c0f90:	d8800015 	stw	r2,0(sp)
 90c0f94:	e0bff984 	addi	r2,fp,-26
 90c0f98:	d8800115 	stw	r2,4(sp)
 90c0f9c:	e13ffa17 	ldw	r4,-24(fp)
 90c0fa0:	e17ffb17 	ldw	r5,-20(fp)
 90c0fa4:	90c086c0 	call	90c086c <ip_reasm_compute_overlap>
 90c0fa8:	e0bff115 	stw	r2,-60(fp)
 90c0fac:	e0bff117 	ldw	r2,-60(fp)
 90c0fb0:	108000a0 	cmpeqi	r2,r2,2
 90c0fb4:	10000e1e 	bne	r2,zero,90c0ff0 <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 90c0fb8:	e0fff117 	ldw	r3,-60(fp)
 90c0fbc:	e0ffff15 	stw	r3,-4(fp)
 90c0fc0:	e13fff17 	ldw	r4,-4(fp)
 90c0fc4:	2005003a 	cmpeq	r2,r4,zero
 90c0fc8:	1000041e 	bne	r2,zero,90c0fdc <ip_reasm_process_subsequent_fragments+0x1e0>
 90c0fcc:	e0ffff17 	ldw	r3,-4(fp)
 90c0fd0:	18800060 	cmpeqi	r2,r3,1
 90c0fd4:	1000031e 	bne	r2,zero,90c0fe4 <ip_reasm_process_subsequent_fragments+0x1e8>
 90c0fd8:	00000506 	br	90c0ff0 <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 90c0fdc:	e03ffe15 	stw	zero,-8(fp)
 90c0fe0:	0000e506 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 90c0fe4:	013ffd84 	movi	r4,-10
 90c0fe8:	e13ffe15 	stw	r4,-8(fp)
 90c0fec:	0000e206 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 90c0ff0:	e0bffa17 	ldw	r2,-24(fp)
 90c0ff4:	10800217 	ldw	r2,8(r2)
 90c0ff8:	113fffcc 	andi	r4,r2,65535
 90c0ffc:	90c030c0 	call	90c030c <ip_reasm_check_mem_useage>
 90c1000:	e0bff315 	stw	r2,-52(fp)
 90c1004:	e0bff317 	ldw	r2,-52(fp)
 90c1008:	1005003a 	cmpeq	r2,r2,zero
 90c100c:	1000121e 	bne	r2,zero,90c1058 <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 90c1010:	01000084 	movi	r4,2
 90c1014:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free (p);
 90c1018:	e13ffa17 	ldw	r4,-24(fp)
 90c101c:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c1020:	01000084 	movi	r4,2
 90c1024:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 90c1028:	e13ffb17 	ldw	r4,-20(fp)
 90c102c:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 90c1030:	008243b4 	movhi	r2,2318
 90c1034:	10b82c04 	addi	r2,r2,-8016
 90c1038:	10800f17 	ldw	r2,60(r2)
 90c103c:	10c00044 	addi	r3,r2,1
 90c1040:	008243b4 	movhi	r2,2318
 90c1044:	10b82c04 	addi	r2,r2,-8016
 90c1048:	10c00f15 	stw	r3,60(r2)
      return rc;
 90c104c:	e0bff317 	ldw	r2,-52(fp)
 90c1050:	e0bffe15 	stw	r2,-8(fp)
 90c1054:	0000c806 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 90c1058:	e0bff70b 	ldhu	r2,-36(fp)
 90c105c:	10bfffcc 	andi	r2,r2,65535
 90c1060:	10800420 	cmpeqi	r2,r2,16
 90c1064:	1000121e 	bne	r2,zero,90c10b0 <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 90c1068:	e0fff817 	ldw	r3,-32(fp)
 90c106c:	e0bff70b 	ldhu	r2,-36(fp)
 90c1070:	10bfffcc 	andi	r2,r2,65535
 90c1074:	1085883a 	add	r2,r2,r2
 90c1078:	1085883a 	add	r2,r2,r2
 90c107c:	10c5883a 	add	r2,r2,r3
 90c1080:	10c00104 	addi	r3,r2,4
 90c1084:	e0bffa17 	ldw	r2,-24(fp)
 90c1088:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 90c108c:	e0fff817 	ldw	r3,-32(fp)
 90c1090:	e0bff70b 	ldhu	r2,-36(fp)
 90c1094:	10bfffcc 	andi	r2,r2,65535
 90c1098:	e13ff90b 	ldhu	r4,-28(fp)
 90c109c:	1085883a 	add	r2,r2,r2
 90c10a0:	10c5883a 	add	r2,r2,r3
 90c10a4:	10801104 	addi	r2,r2,68
 90c10a8:	1100000d 	sth	r4,0(r2)
 90c10ac:	00003c06 	br	90c11a0 <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 90c10b0:	e0bffa17 	ldw	r2,-24(fp)
 90c10b4:	10800217 	ldw	r2,8(r2)
 90c10b8:	10801904 	addi	r2,r2,100
 90c10bc:	113fffcc 	andi	r4,r2,65535
 90c10c0:	90c030c0 	call	90c030c <ip_reasm_check_mem_useage>
 90c10c4:	e0bff315 	stw	r2,-52(fp)
 90c10c8:	e0bff317 	ldw	r2,-52(fp)
 90c10cc:	1005003a 	cmpeq	r2,r2,zero
 90c10d0:	1000121e 	bne	r2,zero,90c111c <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c10d4:	01000084 	movi	r4,2
 90c10d8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free (p);
 90c10dc:	e13ffa17 	ldw	r4,-24(fp)
 90c10e0:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c10e4:	01000084 	movi	r4,2
 90c10e8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 90c10ec:	e13ffb17 	ldw	r4,-20(fp)
 90c10f0:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c10f4:	008243b4 	movhi	r2,2318
 90c10f8:	10b82c04 	addi	r2,r2,-8016
 90c10fc:	10800f17 	ldw	r2,60(r2)
 90c1100:	10c00044 	addi	r3,r2,1
 90c1104:	008243b4 	movhi	r2,2318
 90c1108:	10b82c04 	addi	r2,r2,-8016
 90c110c:	10c00f15 	stw	r3,60(r2)
         return rc;
 90c1110:	e0fff317 	ldw	r3,-52(fp)
 90c1114:	e0fffe15 	stw	r3,-8(fp)
 90c1118:	00009706 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 90c111c:	01001904 	movi	r4,100
 90c1120:	90aaefc0 	call	90aaefc <npalloc>
 90c1124:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 90c1128:	e0bff417 	ldw	r2,-48(fp)
 90c112c:	1004c03a 	cmpne	r2,r2,zero
 90c1130:	1000121e 	bne	r2,zero,90c117c <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c1134:	01000084 	movi	r4,2
 90c1138:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free (p);
 90c113c:	e13ffa17 	ldw	r4,-24(fp)
 90c1140:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c1144:	01000084 	movi	r4,2
 90c1148:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 90c114c:	e13ffb17 	ldw	r4,-20(fp)
 90c1150:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c1154:	008243b4 	movhi	r2,2318
 90c1158:	10b82c04 	addi	r2,r2,-8016
 90c115c:	10800f17 	ldw	r2,60(r2)
 90c1160:	10c00044 	addi	r3,r2,1
 90c1164:	008243b4 	movhi	r2,2318
 90c1168:	10b82c04 	addi	r2,r2,-8016
 90c116c:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 90c1170:	013ffa84 	movi	r4,-22
 90c1174:	e13ffe15 	stw	r4,-8(fp)
 90c1178:	00007f06 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 90c117c:	e0fff417 	ldw	r3,-48(fp)
 90c1180:	e0bffa17 	ldw	r2,-24(fp)
 90c1184:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 90c1188:	e0fff90b 	ldhu	r3,-28(fp)
 90c118c:	e0bff417 	ldw	r2,-48(fp)
 90c1190:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 90c1194:	e0fff817 	ldw	r3,-32(fp)
 90c1198:	e0bff417 	ldw	r2,-48(fp)
 90c119c:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 90c11a0:	e0bff983 	ldbu	r2,-26(fp)
 90c11a4:	10803fcc 	andi	r2,r2,255
 90c11a8:	1005003a 	cmpeq	r2,r2,zero
 90c11ac:	1000161e 	bne	r2,zero,90c1208 <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 90c11b0:	e13ffb17 	ldw	r4,-20(fp)
 90c11b4:	90c1a340 	call	90c1a34 <ip_reasm_mark_compact_rfq>
 90c11b8:	e0bff315 	stw	r2,-52(fp)
 90c11bc:	e0bff317 	ldw	r2,-52(fp)
 90c11c0:	1005003a 	cmpeq	r2,r2,zero
 90c11c4:	1000101e 	bne	r2,zero,90c1208 <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 90c11c8:	01000084 	movi	r4,2
 90c11cc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free (p);
 90c11d0:	e13ffa17 	ldw	r4,-24(fp)
 90c11d4:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c11d8:	01000084 	movi	r4,2
 90c11dc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 90c11e0:	008243b4 	movhi	r2,2318
 90c11e4:	10b82c04 	addi	r2,r2,-8016
 90c11e8:	10800f17 	ldw	r2,60(r2)
 90c11ec:	10c00044 	addi	r3,r2,1
 90c11f0:	008243b4 	movhi	r2,2318
 90c11f4:	10b82c04 	addi	r2,r2,-8016
 90c11f8:	10c00f15 	stw	r3,60(r2)
            return rc;
 90c11fc:	e0bff317 	ldw	r2,-52(fp)
 90c1200:	e0bffe15 	stw	r2,-8(fp)
 90c1204:	00005c06 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 90c1208:	e0bffb17 	ldw	r2,-20(fp)
 90c120c:	10c0048b 	ldhu	r3,18(r2)
 90c1210:	e0bffa17 	ldw	r2,-24(fp)
 90c1214:	10800417 	ldw	r2,16(r2)
 90c1218:	1885883a 	add	r2,r3,r2
 90c121c:	1007883a 	mov	r3,r2
 90c1220:	e0bffb17 	ldw	r2,-20(fp)
 90c1224:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 90c1228:	e0bffa17 	ldw	r2,-24(fp)
 90c122c:	10800217 	ldw	r2,8(r2)
 90c1230:	e0bffd0d 	sth	r2,-12(fp)
 90c1234:	e0bff417 	ldw	r2,-48(fp)
 90c1238:	1004c03a 	cmpne	r2,r2,zero
 90c123c:	1000021e 	bne	r2,zero,90c1248 <ip_reasm_process_subsequent_fragments+0x44c>
 90c1240:	e03ffc0d 	sth	zero,-16(fp)
 90c1244:	00000206 	br	90c1250 <ip_reasm_process_subsequent_fragments+0x454>
 90c1248:	00c01904 	movi	r3,100
 90c124c:	e0fffc0d 	sth	r3,-16(fp)
 90c1250:	e13ffd0b 	ldhu	r4,-12(fp)
 90c1254:	e0fffc0b 	ldhu	r3,-16(fp)
 90c1258:	20c5883a 	add	r2,r4,r3
 90c125c:	113fffcc 	andi	r4,r2,65535
 90c1260:	90c03a40 	call	90c03a4 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 90c1264:	e0bffb17 	ldw	r2,-20(fp)
 90c1268:	1080040b 	ldhu	r2,16(r2)
 90c126c:	10bfffcc 	andi	r2,r2,65535
 90c1270:	1005003a 	cmpeq	r2,r2,zero
 90c1274:	10003f1e 	bne	r2,zero,90c1374 <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 90c1278:	e0bffb17 	ldw	r2,-20(fp)
 90c127c:	10c0048b 	ldhu	r3,18(r2)
 90c1280:	e0bffb17 	ldw	r2,-20(fp)
 90c1284:	1080040b 	ldhu	r2,16(r2)
 90c1288:	18ffffcc 	andi	r3,r3,65535
 90c128c:	10bfffcc 	andi	r2,r2,65535
 90c1290:	1880381e 	bne	r3,r2,90c1374 <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 90c1294:	e0bffb17 	ldw	r2,-20(fp)
 90c1298:	10802017 	ldw	r2,128(r2)
 90c129c:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 90c12a0:	01000084 	movi	r4,2
 90c12a4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 90c12a8:	e0bffb17 	ldw	r2,-20(fp)
 90c12ac:	1080040b 	ldhu	r2,16(r2)
 90c12b0:	113fffcc 	andi	r4,r2,65535
 90c12b4:	e0bffb17 	ldw	r2,-20(fp)
 90c12b8:	10802017 	ldw	r2,128(r2)
 90c12bc:	1007883a 	mov	r3,r2
 90c12c0:	e0bffb17 	ldw	r2,-20(fp)
 90c12c4:	10801f17 	ldw	r2,124(r2)
 90c12c8:	1885c83a 	sub	r2,r3,r2
 90c12cc:	2087883a 	add	r3,r4,r2
 90c12d0:	e0bff517 	ldw	r2,-44(fp)
 90c12d4:	10800003 	ldbu	r2,0(r2)
 90c12d8:	10803fcc 	andi	r2,r2,255
 90c12dc:	108003cc 	andi	r2,r2,15
 90c12e0:	1085883a 	add	r2,r2,r2
 90c12e4:	1085883a 	add	r2,r2,r2
 90c12e8:	1885883a 	add	r2,r3,r2
 90c12ec:	1009883a 	mov	r4,r2
 90c12f0:	90a98340 	call	90a9834 <pk_alloc>
 90c12f4:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c12f8:	01000084 	movi	r4,2
 90c12fc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 90c1300:	e0bff617 	ldw	r2,-40(fp)
 90c1304:	1004c03a 	cmpne	r2,r2,zero
 90c1308:	10000c1e 	bne	r2,zero,90c133c <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 90c130c:	e13ffb17 	ldw	r4,-20(fp)
 90c1310:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 90c1314:	008243b4 	movhi	r2,2318
 90c1318:	10b82c04 	addi	r2,r2,-8016
 90c131c:	10800f17 	ldw	r2,60(r2)
 90c1320:	10c00044 	addi	r3,r2,1
 90c1324:	008243b4 	movhi	r2,2318
 90c1328:	10b82c04 	addi	r2,r2,-8016
 90c132c:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 90c1330:	013ffac4 	movi	r4,-21
 90c1334:	e13ffe15 	stw	r4,-8(fp)
 90c1338:	00000f06 	br	90c1378 <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 90c133c:	e13ff617 	ldw	r4,-40(fp)
 90c1340:	e17ffb17 	ldw	r5,-20(fp)
 90c1344:	90c13f40 	call	90c13f4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 90c1348:	e13ffb17 	ldw	r4,-20(fp)
 90c134c:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 90c1350:	008243b4 	movhi	r2,2318
 90c1354:	10b82c04 	addi	r2,r2,-8016
 90c1358:	10800e17 	ldw	r2,56(r2)
 90c135c:	10c00044 	addi	r3,r2,1
 90c1360:	008243b4 	movhi	r2,2318
 90c1364:	10b82c04 	addi	r2,r2,-8016
 90c1368:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 90c136c:	e13ff617 	ldw	r4,-40(fp)
 90c1370:	90c295c0 	call	90c295c <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 90c1374:	e03ffe15 	stw	zero,-8(fp)
 90c1378:	e0bffe17 	ldw	r2,-8(fp)
}
 90c137c:	e037883a 	mov	sp,fp
 90c1380:	dfc00117 	ldw	ra,4(sp)
 90c1384:	df000017 	ldw	fp,0(sp)
 90c1388:	dec00204 	addi	sp,sp,8
 90c138c:	f800283a 	ret

090c1390 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 90c1390:	defffc04 	addi	sp,sp,-16
 90c1394:	df000315 	stw	fp,12(sp)
 90c1398:	df000304 	addi	fp,sp,12
 90c139c:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c13a0:	d0a0c917 	ldw	r2,-31964(gp)
 90c13a4:	e0bffd15 	stw	r2,-12(fp)
 90c13a8:	00000906 	br	90c13d0 <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 90c13ac:	e0fffd17 	ldw	r3,-12(fp)
 90c13b0:	e0bffe17 	ldw	r2,-8(fp)
 90c13b4:	1880031e 	bne	r3,r2,90c13c4 <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 90c13b8:	00800044 	movi	r2,1
 90c13bc:	e0bfff15 	stw	r2,-4(fp)
 90c13c0:	00000706 	br	90c13e0 <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c13c4:	e0bffd17 	ldw	r2,-12(fp)
 90c13c8:	10800017 	ldw	r2,0(r2)
 90c13cc:	e0bffd15 	stw	r2,-12(fp)
 90c13d0:	e0bffd17 	ldw	r2,-12(fp)
 90c13d4:	1004c03a 	cmpne	r2,r2,zero
 90c13d8:	103ff41e 	bne	r2,zero,90c13ac <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 90c13dc:	e03fff15 	stw	zero,-4(fp)
 90c13e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90c13e4:	e037883a 	mov	sp,fp
 90c13e8:	df000017 	ldw	fp,0(sp)
 90c13ec:	dec00104 	addi	sp,sp,4
 90c13f0:	f800283a 	ret

090c13f4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 90c13f4:	defff404 	addi	sp,sp,-48
 90c13f8:	dfc00b15 	stw	ra,44(sp)
 90c13fc:	df000a15 	stw	fp,40(sp)
 90c1400:	df000a04 	addi	fp,sp,40
 90c1404:	e13ffe15 	stw	r4,-8(fp)
 90c1408:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 90c140c:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 90c1410:	e0bfff17 	ldw	r2,-4(fp)
 90c1414:	10802017 	ldw	r2,128(r2)
 90c1418:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 90c141c:	e0bffd17 	ldw	r2,-12(fp)
 90c1420:	10800003 	ldbu	r2,0(r2)
 90c1424:	108003cc 	andi	r2,r2,15
 90c1428:	1085883a 	add	r2,r2,r2
 90c142c:	1085883a 	add	r2,r2,r2
 90c1430:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 90c1434:	e0bfff17 	ldw	r2,-4(fp)
 90c1438:	10802017 	ldw	r2,128(r2)
 90c143c:	1007883a 	mov	r3,r2
 90c1440:	e0bfff17 	ldw	r2,-4(fp)
 90c1444:	10801f17 	ldw	r2,124(r2)
 90c1448:	1885c83a 	sub	r2,r3,r2
 90c144c:	1007883a 	mov	r3,r2
 90c1450:	e0bff803 	ldbu	r2,-32(fp)
 90c1454:	1885883a 	add	r2,r3,r2
 90c1458:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 90c145c:	e0bffe17 	ldw	r2,-8(fp)
 90c1460:	11000117 	ldw	r4,4(r2)
 90c1464:	e0bfff17 	ldw	r2,-4(fp)
 90c1468:	10801f17 	ldw	r2,124(r2)
 90c146c:	e0fffc03 	ldbu	r3,-16(fp)
 90c1470:	100b883a 	mov	r5,r2
 90c1474:	180d883a 	mov	r6,r3
 90c1478:	90894600 	call	9089460 <memcpy>

   rfqp = &(irep->rfq);
 90c147c:	e0bfff17 	ldw	r2,-4(fp)
 90c1480:	10800604 	addi	r2,r2,24
 90c1484:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 90c1488:	e0bffe17 	ldw	r2,-8(fp)
 90c148c:	10c00117 	ldw	r3,4(r2)
 90c1490:	e0bffc03 	ldbu	r2,-16(fp)
 90c1494:	1885883a 	add	r2,r3,r2
 90c1498:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 90c149c:	00004606 	br	90c15b8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c14a0:	e03ffa0d 	sth	zero,-24(fp)
 90c14a4:	00003e06 	br	90c15a0 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 90c14a8:	e0bffa0b 	ldhu	r2,-24(fp)
 90c14ac:	e0fffb17 	ldw	r3,-20(fp)
 90c14b0:	1085883a 	add	r2,r2,r2
 90c14b4:	1085883a 	add	r2,r2,r2
 90c14b8:	10c5883a 	add	r2,r2,r3
 90c14bc:	10800104 	addi	r2,r2,4
 90c14c0:	10800017 	ldw	r2,0(r2)
 90c14c4:	e0bff915 	stw	r2,-28(fp)
 90c14c8:	e0bff917 	ldw	r2,-28(fp)
 90c14cc:	1005003a 	cmpeq	r2,r2,zero
 90c14d0:	1000291e 	bne	r2,zero,90c1578 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 90c14d4:	e0bffa0b 	ldhu	r2,-24(fp)
 90c14d8:	e0fffb17 	ldw	r3,-20(fp)
 90c14dc:	1085883a 	add	r2,r2,r2
 90c14e0:	10c5883a 	add	r2,r2,r3
 90c14e4:	10801104 	addi	r2,r2,68
 90c14e8:	1080000b 	ldhu	r2,0(r2)
 90c14ec:	10bfffcc 	andi	r2,r2,65535
 90c14f0:	1007883a 	mov	r3,r2
 90c14f4:	e0bff717 	ldw	r2,-36(fp)
 90c14f8:	1887883a 	add	r3,r3,r2
 90c14fc:	e0bff917 	ldw	r2,-28(fp)
 90c1500:	11400317 	ldw	r5,12(r2)
 90c1504:	e0bff917 	ldw	r2,-28(fp)
 90c1508:	10800417 	ldw	r2,16(r2)
 90c150c:	1809883a 	mov	r4,r3
 90c1510:	100d883a 	mov	r6,r2
 90c1514:	90894600 	call	9089460 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 90c1518:	e0bff617 	ldw	r2,-40(fp)
 90c151c:	1004c03a 	cmpne	r2,r2,zero
 90c1520:	1000031e 	bne	r2,zero,90c1530 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 90c1524:	e0bff917 	ldw	r2,-28(fp)
 90c1528:	e0bff615 	stw	r2,-40(fp)
 90c152c:	00000a06 	br	90c1558 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 90c1530:	e0bff917 	ldw	r2,-28(fp)
 90c1534:	10800217 	ldw	r2,8(r2)
 90c1538:	113fffcc 	andi	r4,r2,65535
 90c153c:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 90c1540:	01000084 	movi	r4,2
 90c1544:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
               pk_free (p);
 90c1548:	e13ff917 	ldw	r4,-28(fp)
 90c154c:	90a9bc80 	call	90a9bc8 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c1550:	01000084 	movi	r4,2
 90c1554:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 90c1558:	e0bffa0b 	ldhu	r2,-24(fp)
 90c155c:	e0fffb17 	ldw	r3,-20(fp)
 90c1560:	1085883a 	add	r2,r2,r2
 90c1564:	1085883a 	add	r2,r2,r2
 90c1568:	10c5883a 	add	r2,r2,r3
 90c156c:	10800104 	addi	r2,r2,4
 90c1570:	10000015 	stw	zero,0(r2)
 90c1574:	00000706 	br	90c1594 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 90c1578:	e0bfff17 	ldw	r2,-4(fp)
 90c157c:	10802103 	ldbu	r2,132(r2)
 90c1580:	10803fcc 	andi	r2,r2,255
 90c1584:	1080004c 	andi	r2,r2,1
 90c1588:	10803fcc 	andi	r2,r2,255
 90c158c:	1004c03a 	cmpne	r2,r2,zero
 90c1590:	1000061e 	bne	r2,zero,90c15ac <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1594:	e0bffa0b 	ldhu	r2,-24(fp)
 90c1598:	10800044 	addi	r2,r2,1
 90c159c:	e0bffa0d 	sth	r2,-24(fp)
 90c15a0:	e0bffa0b 	ldhu	r2,-24(fp)
 90c15a4:	10800430 	cmpltui	r2,r2,16
 90c15a8:	103fbf1e 	bne	r2,zero,90c14a8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 90c15ac:	e0bffb17 	ldw	r2,-20(fp)
 90c15b0:	10800017 	ldw	r2,0(r2)
 90c15b4:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 90c15b8:	e0bffb17 	ldw	r2,-20(fp)
 90c15bc:	1004c03a 	cmpne	r2,r2,zero
 90c15c0:	103fb71e 	bne	r2,zero,90c14a0 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 90c15c4:	e0bffe17 	ldw	r2,-8(fp)
 90c15c8:	11000117 	ldw	r4,4(r2)
 90c15cc:	e0bfff17 	ldw	r2,-4(fp)
 90c15d0:	10802017 	ldw	r2,128(r2)
 90c15d4:	1007883a 	mov	r3,r2
 90c15d8:	e0bfff17 	ldw	r2,-4(fp)
 90c15dc:	10801f17 	ldw	r2,124(r2)
 90c15e0:	1885c83a 	sub	r2,r3,r2
 90c15e4:	2087883a 	add	r3,r4,r2
 90c15e8:	e0bffe17 	ldw	r2,-8(fp)
 90c15ec:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 90c15f0:	e0bfff17 	ldw	r2,-4(fp)
 90c15f4:	1080040b 	ldhu	r2,16(r2)
 90c15f8:	10ffffcc 	andi	r3,r2,65535
 90c15fc:	e0bff803 	ldbu	r2,-32(fp)
 90c1600:	1885883a 	add	r2,r3,r2
 90c1604:	1007883a 	mov	r3,r2
 90c1608:	e0bffe17 	ldw	r2,-8(fp)
 90c160c:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 90c1610:	00824374 	movhi	r2,2317
 90c1614:	108f2e04 	addi	r2,r2,15544
 90c1618:	10800017 	ldw	r2,0(r2)
 90c161c:	1007883a 	mov	r3,r2
 90c1620:	e0bffe17 	ldw	r2,-8(fp)
 90c1624:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 90c1628:	e0bffe17 	ldw	r2,-8(fp)
 90c162c:	10c00a17 	ldw	r3,40(r2)
 90c1630:	e0bff617 	ldw	r2,-40(fp)
 90c1634:	10800a17 	ldw	r2,40(r2)
 90c1638:	108000cc 	andi	r2,r2,3
 90c163c:	1886b03a 	or	r3,r3,r2
 90c1640:	e0bffe17 	ldw	r2,-8(fp)
 90c1644:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 90c1648:	e0bff617 	ldw	r2,-40(fp)
 90c164c:	10c00617 	ldw	r3,24(r2)
 90c1650:	e0bffe17 	ldw	r2,-8(fp)
 90c1654:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 90c1658:	e0bff617 	ldw	r2,-40(fp)
 90c165c:	10c0080b 	ldhu	r3,32(r2)
 90c1660:	e0bffe17 	ldw	r2,-8(fp)
 90c1664:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 90c1668:	e0bff617 	ldw	r2,-40(fp)
 90c166c:	10800217 	ldw	r2,8(r2)
 90c1670:	113fffcc 	andi	r4,r2,65535
 90c1674:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 90c1678:	01000084 	movi	r4,2
 90c167c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 90c1680:	e13ff617 	ldw	r4,-40(fp)
 90c1684:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 90c1688:	01000084 	movi	r4,2
 90c168c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 90c1690:	e0bffe17 	ldw	r2,-8(fp)
 90c1694:	10800317 	ldw	r2,12(r2)
 90c1698:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 90c169c:	e0bffe17 	ldw	r2,-8(fp)
 90c16a0:	10800417 	ldw	r2,16(r2)
 90c16a4:	1004d23a 	srli	r2,r2,8
 90c16a8:	10803fcc 	andi	r2,r2,255
 90c16ac:	1009883a 	mov	r4,r2
 90c16b0:	e0bffe17 	ldw	r2,-8(fp)
 90c16b4:	10800417 	ldw	r2,16(r2)
 90c16b8:	1004923a 	slli	r2,r2,8
 90c16bc:	1007883a 	mov	r3,r2
 90c16c0:	00bfc004 	movi	r2,-256
 90c16c4:	1884703a 	and	r2,r3,r2
 90c16c8:	2084b03a 	or	r2,r4,r2
 90c16cc:	1007883a 	mov	r3,r2
 90c16d0:	e0bffd17 	ldw	r2,-12(fp)
 90c16d4:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 90c16d8:	e0bffd17 	ldw	r2,-12(fp)
 90c16dc:	10c0018b 	ldhu	r3,6(r2)
 90c16e0:	00bff7c4 	movi	r2,-33
 90c16e4:	1884703a 	and	r2,r3,r2
 90c16e8:	1007883a 	mov	r3,r2
 90c16ec:	e0bffd17 	ldw	r2,-12(fp)
 90c16f0:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 90c16f4:	e0bffd17 	ldw	r2,-12(fp)
 90c16f8:	1080018b 	ldhu	r2,6(r2)
 90c16fc:	1080380c 	andi	r2,r2,224
 90c1700:	1007883a 	mov	r3,r2
 90c1704:	e0bffd17 	ldw	r2,-12(fp)
 90c1708:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 90c170c:	e0bffd17 	ldw	r2,-12(fp)
 90c1710:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 90c1714:	e0bff803 	ldbu	r2,-32(fp)
 90c1718:	1004d07a 	srli	r2,r2,1
 90c171c:	11403fcc 	andi	r5,r2,255
 90c1720:	e13ffd17 	ldw	r4,-12(fp)
 90c1724:	90a4ef40 	call	90a4ef4 <cksum>
 90c1728:	0084303a 	nor	r2,zero,r2
 90c172c:	1007883a 	mov	r3,r2
 90c1730:	e0bffd17 	ldw	r2,-12(fp)
 90c1734:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 90c1738:	0005883a 	mov	r2,zero
}
 90c173c:	e037883a 	mov	sp,fp
 90c1740:	dfc00117 	ldw	ra,4(sp)
 90c1744:	df000017 	ldw	fp,0(sp)
 90c1748:	dec00204 	addi	sp,sp,8
 90c174c:	f800283a 	ret

090c1750 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 90c1750:	defffc04 	addi	sp,sp,-16
 90c1754:	dfc00315 	stw	ra,12(sp)
 90c1758:	df000215 	stw	fp,8(sp)
 90c175c:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 90c1760:	0009883a 	mov	r4,zero
 90c1764:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 90c1768:	d0a0c917 	ldw	r2,-31964(gp)
 90c176c:	e0bfff15 	stw	r2,-4(fp)
 90c1770:	00002006 	br	90c17f4 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 90c1774:	e0bfff17 	ldw	r2,-4(fp)
 90c1778:	10800017 	ldw	r2,0(r2)
 90c177c:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 90c1780:	e0bfff17 	ldw	r2,-4(fp)
 90c1784:	10800517 	ldw	r2,20(r2)
 90c1788:	10c00044 	addi	r3,r2,1
 90c178c:	e0bfff17 	ldw	r2,-4(fp)
 90c1790:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 90c1794:	e0bfff17 	ldw	r2,-4(fp)
 90c1798:	10800517 	ldw	r2,20(r2)
 90c179c:	10801e18 	cmpnei	r2,r2,120
 90c17a0:	1000121e 	bne	r2,zero,90c17ec <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 90c17a4:	008243b4 	movhi	r2,2318
 90c17a8:	10b84004 	addi	r2,r2,-7936
 90c17ac:	10800117 	ldw	r2,4(r2)
 90c17b0:	10c00044 	addi	r3,r2,1
 90c17b4:	008243b4 	movhi	r2,2318
 90c17b8:	10b84004 	addi	r2,r2,-7936
 90c17bc:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 90c17c0:	e13fff17 	ldw	r4,-4(fp)
 90c17c4:	90c1efc0 	call	90c1efc <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 90c17c8:	e13fff17 	ldw	r4,-4(fp)
 90c17cc:	90c186c0 	call	90c186c <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 90c17d0:	008243b4 	movhi	r2,2318
 90c17d4:	10b82c04 	addi	r2,r2,-8016
 90c17d8:	10800f17 	ldw	r2,60(r2)
 90c17dc:	10c00044 	addi	r3,r2,1
 90c17e0:	008243b4 	movhi	r2,2318
 90c17e4:	10b82c04 	addi	r2,r2,-8016
 90c17e8:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 90c17ec:	e0bffe17 	ldw	r2,-8(fp)
 90c17f0:	e0bfff15 	stw	r2,-4(fp)
 90c17f4:	e0bfff17 	ldw	r2,-4(fp)
 90c17f8:	1004c03a 	cmpne	r2,r2,zero
 90c17fc:	103fdd1e 	bne	r2,zero,90c1774 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 90c1800:	00824374 	movhi	r2,2317
 90c1804:	108f2e04 	addi	r2,r2,15544
 90c1808:	11000017 	ldw	r4,0(r2)
 90c180c:	908d0380 	call	908d038 <__floatunsidf>
 90c1810:	100b883a 	mov	r5,r2
 90c1814:	180d883a 	mov	r6,r3
 90c1818:	2809883a 	mov	r4,r5
 90c181c:	300b883a 	mov	r5,r6
 90c1820:	000d883a 	mov	r6,zero
 90c1824:	01d01674 	movhi	r7,16473
 90c1828:	908c5400 	call	908c540 <__adddf3>
 90c182c:	1009883a 	mov	r4,r2
 90c1830:	180b883a 	mov	r5,r3
 90c1834:	2005883a 	mov	r2,r4
 90c1838:	2807883a 	mov	r3,r5
 90c183c:	1009883a 	mov	r4,r2
 90c1840:	180b883a 	mov	r5,r3
 90c1844:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90c1848:	d0a0ca15 	stw	r2,-31960(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 90c184c:	0009883a 	mov	r4,zero
 90c1850:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 90c1854:	0005883a 	mov	r2,zero
}
 90c1858:	e037883a 	mov	sp,fp
 90c185c:	dfc00117 	ldw	ra,4(sp)
 90c1860:	df000017 	ldw	fp,0(sp)
 90c1864:	dec00204 	addi	sp,sp,8
 90c1868:	f800283a 	ret

090c186c <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 90c186c:	defff504 	addi	sp,sp,-44
 90c1870:	dfc00a15 	stw	ra,40(sp)
 90c1874:	df000915 	stw	fp,36(sp)
 90c1878:	df000904 	addi	fp,sp,36
 90c187c:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 90c1880:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c1884:	d0a0c917 	ldw	r2,-31964(gp)
 90c1888:	e0bff815 	stw	r2,-32(fp)
 90c188c:	00001406 	br	90c18e0 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 90c1890:	e0fff817 	ldw	r3,-32(fp)
 90c1894:	e0bffe17 	ldw	r2,-8(fp)
 90c1898:	18800c1e 	bne	r3,r2,90c18cc <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 90c189c:	d0e0c917 	ldw	r3,-31964(gp)
 90c18a0:	e0bff817 	ldw	r2,-32(fp)
 90c18a4:	10c0041e 	bne	r2,r3,90c18b8 <ip_reasm_delete_ire+0x4c>
 90c18a8:	e0bffe17 	ldw	r2,-8(fp)
 90c18ac:	10800017 	ldw	r2,0(r2)
 90c18b0:	d0a0c915 	stw	r2,-31964(gp)
 90c18b4:	00000d06 	br	90c18ec <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 90c18b8:	e0bffe17 	ldw	r2,-8(fp)
 90c18bc:	10c00017 	ldw	r3,0(r2)
 90c18c0:	e0bff717 	ldw	r2,-36(fp)
 90c18c4:	10c00015 	stw	r3,0(r2)
         break;
 90c18c8:	00000806 	br	90c18ec <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 90c18cc:	e0bff817 	ldw	r2,-32(fp)
 90c18d0:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c18d4:	e0bff817 	ldw	r2,-32(fp)
 90c18d8:	10800017 	ldw	r2,0(r2)
 90c18dc:	e0bff815 	stw	r2,-32(fp)
 90c18e0:	e0bff817 	ldw	r2,-32(fp)
 90c18e4:	1004c03a 	cmpne	r2,r2,zero
 90c18e8:	103fe91e 	bne	r2,zero,90c1890 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 90c18ec:	e0bff817 	ldw	r2,-32(fp)
 90c18f0:	1004c03a 	cmpne	r2,r2,zero
 90c18f4:	10000a1e 	bne	r2,zero,90c1920 <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 90c18f8:	008243b4 	movhi	r2,2318
 90c18fc:	10b84004 	addi	r2,r2,-7936
 90c1900:	10800017 	ldw	r2,0(r2)
 90c1904:	10c00044 	addi	r3,r2,1
 90c1908:	008243b4 	movhi	r2,2318
 90c190c:	10b84004 	addi	r2,r2,-7936
 90c1910:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 90c1914:	00bffd84 	movi	r2,-10
 90c1918:	e0bfff15 	stw	r2,-4(fp)
 90c191c:	00003f06 	br	90c1a1c <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 90c1920:	e0bffe17 	ldw	r2,-8(fp)
 90c1924:	10800604 	addi	r2,r2,24
 90c1928:	e0bffc15 	stw	r2,-16(fp)
 90c192c:	e0bffc17 	ldw	r2,-16(fp)
 90c1930:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 90c1934:	00003106 	br	90c19fc <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1938:	e03ffa0d 	sth	zero,-24(fp)
 90c193c:	00002006 	br	90c19c0 <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 90c1940:	e0bffa0b 	ldhu	r2,-24(fp)
 90c1944:	e0fffd17 	ldw	r3,-12(fp)
 90c1948:	1085883a 	add	r2,r2,r2
 90c194c:	1085883a 	add	r2,r2,r2
 90c1950:	10c5883a 	add	r2,r2,r3
 90c1954:	10800104 	addi	r2,r2,4
 90c1958:	10800017 	ldw	r2,0(r2)
 90c195c:	e0bff915 	stw	r2,-28(fp)
 90c1960:	e0bff917 	ldw	r2,-28(fp)
 90c1964:	1005003a 	cmpeq	r2,r2,zero
 90c1968:	10000b1e 	bne	r2,zero,90c1998 <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 90c196c:	e0bff917 	ldw	r2,-28(fp)
 90c1970:	10800217 	ldw	r2,8(r2)
 90c1974:	113fffcc 	andi	r4,r2,65535
 90c1978:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 90c197c:	01000084 	movi	r4,2
 90c1980:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free (p);
 90c1984:	e13ff917 	ldw	r4,-28(fp)
 90c1988:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 90c198c:	01000084 	movi	r4,2
 90c1990:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
 90c1994:	00000706 	br	90c19b4 <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 90c1998:	e0bffe17 	ldw	r2,-8(fp)
 90c199c:	10802103 	ldbu	r2,132(r2)
 90c19a0:	10803fcc 	andi	r2,r2,255
 90c19a4:	1080004c 	andi	r2,r2,1
 90c19a8:	10803fcc 	andi	r2,r2,255
 90c19ac:	1004c03a 	cmpne	r2,r2,zero
 90c19b0:	1000061e 	bne	r2,zero,90c19cc <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c19b4:	e0bffa0b 	ldhu	r2,-24(fp)
 90c19b8:	10800044 	addi	r2,r2,1
 90c19bc:	e0bffa0d 	sth	r2,-24(fp)
 90c19c0:	e0bffa0b 	ldhu	r2,-24(fp)
 90c19c4:	10800430 	cmpltui	r2,r2,16
 90c19c8:	103fdd1e 	bne	r2,zero,90c1940 <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 90c19cc:	e0bffd17 	ldw	r2,-12(fp)
 90c19d0:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 90c19d4:	e0bffd17 	ldw	r2,-12(fp)
 90c19d8:	10800017 	ldw	r2,0(r2)
 90c19dc:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 90c19e0:	e0fffb17 	ldw	r3,-20(fp)
 90c19e4:	e0bffc17 	ldw	r2,-16(fp)
 90c19e8:	18800426 	beq	r3,r2,90c19fc <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 90c19ec:	01001904 	movi	r4,100
 90c19f0:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 90c19f4:	e13ffb17 	ldw	r4,-20(fp)
 90c19f8:	90aaff00 	call	90aaff0 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 90c19fc:	e0bffd17 	ldw	r2,-12(fp)
 90c1a00:	1004c03a 	cmpne	r2,r2,zero
 90c1a04:	103fcc1e 	bne	r2,zero,90c1938 <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 90c1a08:	01002204 	movi	r4,136
 90c1a0c:	90c044c0 	call	90c044c <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 90c1a10:	e13ffe17 	ldw	r4,-8(fp)
 90c1a14:	90aaff00 	call	90aaff0 <npfree>

   return IPREASM_OK;
 90c1a18:	e03fff15 	stw	zero,-4(fp)
 90c1a1c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1a20:	e037883a 	mov	sp,fp
 90c1a24:	dfc00117 	ldw	ra,4(sp)
 90c1a28:	df000017 	ldw	fp,0(sp)
 90c1a2c:	dec00204 	addi	sp,sp,8
 90c1a30:	f800283a 	ret

090c1a34 <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 90c1a34:	defffa04 	addi	sp,sp,-24
 90c1a38:	dfc00515 	stw	ra,20(sp)
 90c1a3c:	df000415 	stw	fp,16(sp)
 90c1a40:	df000404 	addi	fp,sp,16
 90c1a44:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 90c1a48:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 90c1a4c:	00800044 	movi	r2,1
 90c1a50:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 90c1a54:	e13ffe17 	ldw	r4,-8(fp)
 90c1a58:	90c13900 	call	90c1390 <ip_reasm_find_ire>
 90c1a5c:	10803fcc 	andi	r2,r2,255
 90c1a60:	10800060 	cmpeqi	r2,r2,1
 90c1a64:	10000a1e 	bne	r2,zero,90c1a90 <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 90c1a68:	008243b4 	movhi	r2,2318
 90c1a6c:	10b84004 	addi	r2,r2,-7936
 90c1a70:	10800017 	ldw	r2,0(r2)
 90c1a74:	10c00044 	addi	r3,r2,1
 90c1a78:	008243b4 	movhi	r2,2318
 90c1a7c:	10b84004 	addi	r2,r2,-7936
 90c1a80:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 90c1a84:	00bffd84 	movi	r2,-10
 90c1a88:	e0bfff15 	stw	r2,-4(fp)
 90c1a8c:	00003506 	br	90c1b64 <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 90c1a90:	e0bffe17 	ldw	r2,-8(fp)
 90c1a94:	10800604 	addi	r2,r2,24
 90c1a98:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 90c1a9c:	00001c06 	br	90c1b10 <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1aa0:	e03ffc8d 	sth	zero,-14(fp)
 90c1aa4:	00001406 	br	90c1af8 <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 90c1aa8:	e0bffc8b 	ldhu	r2,-14(fp)
 90c1aac:	e0fffd17 	ldw	r3,-12(fp)
 90c1ab0:	1085883a 	add	r2,r2,r2
 90c1ab4:	1085883a 	add	r2,r2,r2
 90c1ab8:	10c5883a 	add	r2,r2,r3
 90c1abc:	10800104 	addi	r2,r2,4
 90c1ac0:	10800017 	ldw	r2,0(r2)
 90c1ac4:	1004c03a 	cmpne	r2,r2,zero
 90c1ac8:	1000031e 	bne	r2,zero,90c1ad8 <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 90c1acc:	00800044 	movi	r2,1
 90c1ad0:	e0bffc45 	stb	r2,-15(fp)
 90c1ad4:	00000506 	br	90c1aec <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 90c1ad8:	e0bffc43 	ldbu	r2,-15(fp)
 90c1adc:	1005003a 	cmpeq	r2,r2,zero
 90c1ae0:	1000021e 	bne	r2,zero,90c1aec <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 90c1ae4:	e03ffc05 	stb	zero,-16(fp)
               break;
 90c1ae8:	00000606 	br	90c1b04 <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1aec:	e0bffc8b 	ldhu	r2,-14(fp)
 90c1af0:	10800044 	addi	r2,r2,1
 90c1af4:	e0bffc8d 	sth	r2,-14(fp)
 90c1af8:	e0bffc8b 	ldhu	r2,-14(fp)
 90c1afc:	10800430 	cmpltui	r2,r2,16
 90c1b00:	103fe91e 	bne	r2,zero,90c1aa8 <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 90c1b04:	e0bffd17 	ldw	r2,-12(fp)
 90c1b08:	10800017 	ldw	r2,0(r2)
 90c1b0c:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 90c1b10:	e0bffd17 	ldw	r2,-12(fp)
 90c1b14:	1004c03a 	cmpne	r2,r2,zero
 90c1b18:	103fe11e 	bne	r2,zero,90c1aa0 <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 90c1b1c:	e0bffc03 	ldbu	r2,-16(fp)
 90c1b20:	1005003a 	cmpeq	r2,r2,zero
 90c1b24:	1000071e 	bne	r2,zero,90c1b44 <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 90c1b28:	e0bffe17 	ldw	r2,-8(fp)
 90c1b2c:	10802103 	ldbu	r2,132(r2)
 90c1b30:	10800054 	ori	r2,r2,1
 90c1b34:	1007883a 	mov	r3,r2
 90c1b38:	e0bffe17 	ldw	r2,-8(fp)
 90c1b3c:	10c02105 	stb	r3,132(r2)
 90c1b40:	00000706 	br	90c1b60 <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 90c1b44:	e0bffe17 	ldw	r2,-8(fp)
 90c1b48:	10c02103 	ldbu	r3,132(r2)
 90c1b4c:	00bfff84 	movi	r2,-2
 90c1b50:	1884703a 	and	r2,r3,r2
 90c1b54:	1007883a 	mov	r3,r2
 90c1b58:	e0bffe17 	ldw	r2,-8(fp)
 90c1b5c:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 90c1b60:	e03fff15 	stw	zero,-4(fp)
 90c1b64:	e0bfff17 	ldw	r2,-4(fp)
}
 90c1b68:	e037883a 	mov	sp,fp
 90c1b6c:	dfc00117 	ldw	ra,4(sp)
 90c1b70:	df000017 	ldw	fp,0(sp)
 90c1b74:	dec00204 	addi	sp,sp,8
 90c1b78:	f800283a 	ret

090c1b7c <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 90c1b7c:	deffec04 	addi	sp,sp,-80
 90c1b80:	dfc01315 	stw	ra,76(sp)
 90c1b84:	df001215 	stw	fp,72(sp)
 90c1b88:	dc001115 	stw	r16,68(sp)
 90c1b8c:	df001104 	addi	fp,sp,68
 90c1b90:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 90c1b94:	00824374 	movhi	r2,2317
 90c1b98:	108f2e04 	addi	r2,r2,15544
 90c1b9c:	10800017 	ldw	r2,0(r2)
 90c1ba0:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 90c1ba4:	00802204 	movi	r2,136
 90c1ba8:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 90c1bac:	00801904 	movi	r2,100
 90c1bb0:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 90c1bb4:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 90c1bb8:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 90c1bbc:	e13fff17 	ldw	r4,-4(fp)
 90c1bc0:	01424374 	movhi	r5,2317
 90c1bc4:	29439e04 	addi	r5,r5,3704
 90c1bc8:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 90c1bcc:	d420c817 	ldw	r16,-31968(gp)
 90c1bd0:	e13ffe17 	ldw	r4,-8(fp)
 90c1bd4:	908d0380 	call	908d038 <__floatunsidf>
 90c1bd8:	100b883a 	mov	r5,r2
 90c1bdc:	180d883a 	mov	r6,r3
 90c1be0:	2809883a 	mov	r4,r5
 90c1be4:	300b883a 	mov	r5,r6
 90c1be8:	000d883a 	mov	r6,zero
 90c1bec:	01d01674 	movhi	r7,16473
 90c1bf0:	908c9680 	call	908c968 <__divdf3>
 90c1bf4:	1009883a 	mov	r4,r2
 90c1bf8:	180b883a 	mov	r5,r3
 90c1bfc:	2005883a 	mov	r2,r4
 90c1c00:	2807883a 	mov	r3,r5
 90c1c04:	e13ffd8b 	ldhu	r4,-10(fp)
 90c1c08:	e17ffd0b 	ldhu	r5,-12(fp)
 90c1c0c:	d8800015 	stw	r2,0(sp)
 90c1c10:	d8c00115 	stw	r3,4(sp)
 90c1c14:	d9000215 	stw	r4,8(sp)
 90c1c18:	d9400315 	stw	r5,12(sp)
 90c1c1c:	e13fff17 	ldw	r4,-4(fp)
 90c1c20:	01424374 	movhi	r5,2317
 90c1c24:	2943a504 	addi	r5,r5,3732
 90c1c28:	800d883a 	mov	r6,r16
 90c1c2c:	e1fffe17 	ldw	r7,-8(fp)
 90c1c30:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 90c1c34:	008243b4 	movhi	r2,2318
 90c1c38:	10b84004 	addi	r2,r2,-7936
 90c1c3c:	11800117 	ldw	r6,4(r2)
 90c1c40:	008243b4 	movhi	r2,2318
 90c1c44:	10b84004 	addi	r2,r2,-7936
 90c1c48:	11c00017 	ldw	r7,0(r2)
 90c1c4c:	008243b4 	movhi	r2,2318
 90c1c50:	10b84004 	addi	r2,r2,-7936
 90c1c54:	11000217 	ldw	r4,8(r2)
 90c1c58:	008243b4 	movhi	r2,2318
 90c1c5c:	10b84004 	addi	r2,r2,-7936
 90c1c60:	11400317 	ldw	r5,12(r2)
 90c1c64:	008243b4 	movhi	r2,2318
 90c1c68:	10b84004 	addi	r2,r2,-7936
 90c1c6c:	10c00417 	ldw	r3,16(r2)
 90c1c70:	008243b4 	movhi	r2,2318
 90c1c74:	10b84004 	addi	r2,r2,-7936
 90c1c78:	10800517 	ldw	r2,20(r2)
 90c1c7c:	d9000015 	stw	r4,0(sp)
 90c1c80:	d9400115 	stw	r5,4(sp)
 90c1c84:	d8c00215 	stw	r3,8(sp)
 90c1c88:	d8800315 	stw	r2,12(sp)
 90c1c8c:	e13fff17 	ldw	r4,-4(fp)
 90c1c90:	01424374 	movhi	r5,2317
 90c1c94:	2943b504 	addi	r5,r5,3796
 90c1c98:	90a55a40 	call	90a55a4 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 90c1c9c:	d1a0c917 	ldw	r6,-31964(gp)
 90c1ca0:	e13fff17 	ldw	r4,-4(fp)
 90c1ca4:	01424374 	movhi	r5,2317
 90c1ca8:	2943ca04 	addi	r5,r5,3880
 90c1cac:	90a55a40 	call	90a55a4 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c1cb0:	d0a0c917 	ldw	r2,-31964(gp)
 90c1cb4:	e0bffc15 	stw	r2,-16(fp)
 90c1cb8:	00008106 	br	90c1ec0 <ipr_stats+0x344>
      {
      ++count;
 90c1cbc:	e0bffb0b 	ldhu	r2,-20(fp)
 90c1cc0:	10800044 	addi	r2,r2,1
 90c1cc4:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 90c1cc8:	e0bffc17 	ldw	r2,-16(fp)
 90c1ccc:	10800604 	addi	r2,r2,24
 90c1cd0:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 90c1cd4:	00001f06 	br	90c1d54 <ipr_stats+0x1d8>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1cd8:	e03ff90d 	sth	zero,-28(fp)
 90c1cdc:	00001706 	br	90c1d3c <ipr_stats+0x1c0>
            {
            if (rfqp->bufp [i] != 0)
 90c1ce0:	e0bff90b 	ldhu	r2,-28(fp)
 90c1ce4:	e0fffa17 	ldw	r3,-24(fp)
 90c1ce8:	1085883a 	add	r2,r2,r2
 90c1cec:	1085883a 	add	r2,r2,r2
 90c1cf0:	10c5883a 	add	r2,r2,r3
 90c1cf4:	10800104 	addi	r2,r2,4
 90c1cf8:	10800017 	ldw	r2,0(r2)
 90c1cfc:	1005003a 	cmpeq	r2,r2,zero
 90c1d00:	1000041e 	bne	r2,zero,90c1d14 <ipr_stats+0x198>
               {
               ++frag_count;            
 90c1d04:	e0bff98b 	ldhu	r2,-26(fp)
 90c1d08:	10800044 	addi	r2,r2,1
 90c1d0c:	e0bff98d 	sth	r2,-26(fp)
 90c1d10:	00000706 	br	90c1d30 <ipr_stats+0x1b4>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 90c1d14:	e0bffc17 	ldw	r2,-16(fp)
 90c1d18:	10802103 	ldbu	r2,132(r2)
 90c1d1c:	10803fcc 	andi	r2,r2,255
 90c1d20:	1080004c 	andi	r2,r2,1
 90c1d24:	10803fcc 	andi	r2,r2,255
 90c1d28:	1004c03a 	cmpne	r2,r2,zero
 90c1d2c:	1000061e 	bne	r2,zero,90c1d48 <ipr_stats+0x1cc>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 90c1d30:	e0bff90b 	ldhu	r2,-28(fp)
 90c1d34:	10800044 	addi	r2,r2,1
 90c1d38:	e0bff90d 	sth	r2,-28(fp)
 90c1d3c:	e0bff90b 	ldhu	r2,-28(fp)
 90c1d40:	10800430 	cmpltui	r2,r2,16
 90c1d44:	103fe61e 	bne	r2,zero,90c1ce0 <ipr_stats+0x164>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 90c1d48:	e0bffa17 	ldw	r2,-24(fp)
 90c1d4c:	10800017 	ldw	r2,0(r2)
 90c1d50:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 90c1d54:	e0bffa17 	ldw	r2,-24(fp)
 90c1d58:	1004c03a 	cmpne	r2,r2,zero
 90c1d5c:	103fde1e 	bne	r2,zero,90c1cd8 <ipr_stats+0x15c>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 90c1d60:	e1fff98b 	ldhu	r7,-26(fp)
 90c1d64:	e0bffc17 	ldw	r2,-16(fp)
 90c1d68:	10800117 	ldw	r2,4(r2)
 90c1d6c:	1004d63a 	srli	r2,r2,24
 90c1d70:	10c03fcc 	andi	r3,r2,255
 90c1d74:	e0bffc17 	ldw	r2,-16(fp)
 90c1d78:	10800117 	ldw	r2,4(r2)
 90c1d7c:	1004d23a 	srli	r2,r2,8
 90c1d80:	10bfc00c 	andi	r2,r2,65280
 90c1d84:	1886b03a 	or	r3,r3,r2
 90c1d88:	e0bffc17 	ldw	r2,-16(fp)
 90c1d8c:	10800117 	ldw	r2,4(r2)
 90c1d90:	10bfc00c 	andi	r2,r2,65280
 90c1d94:	1004923a 	slli	r2,r2,8
 90c1d98:	1886b03a 	or	r3,r3,r2
 90c1d9c:	e0bffc17 	ldw	r2,-16(fp)
 90c1da0:	10800117 	ldw	r2,4(r2)
 90c1da4:	10803fcc 	andi	r2,r2,255
 90c1da8:	1004963a 	slli	r2,r2,24
 90c1dac:	1888b03a 	or	r4,r3,r2
 90c1db0:	e0bffc17 	ldw	r2,-16(fp)
 90c1db4:	10800217 	ldw	r2,8(r2)
 90c1db8:	1004d63a 	srli	r2,r2,24
 90c1dbc:	10c03fcc 	andi	r3,r2,255
 90c1dc0:	e0bffc17 	ldw	r2,-16(fp)
 90c1dc4:	10800217 	ldw	r2,8(r2)
 90c1dc8:	1004d23a 	srli	r2,r2,8
 90c1dcc:	10bfc00c 	andi	r2,r2,65280
 90c1dd0:	1886b03a 	or	r3,r3,r2
 90c1dd4:	e0bffc17 	ldw	r2,-16(fp)
 90c1dd8:	10800217 	ldw	r2,8(r2)
 90c1ddc:	10bfc00c 	andi	r2,r2,65280
 90c1de0:	1004923a 	slli	r2,r2,8
 90c1de4:	1886b03a 	or	r3,r3,r2
 90c1de8:	e0bffc17 	ldw	r2,-16(fp)
 90c1dec:	10800217 	ldw	r2,8(r2)
 90c1df0:	10803fcc 	andi	r2,r2,255
 90c1df4:	1004963a 	slli	r2,r2,24
 90c1df8:	188ab03a 	or	r5,r3,r2
 90c1dfc:	e0bffc17 	ldw	r2,-16(fp)
 90c1e00:	10800383 	ldbu	r2,14(r2)
 90c1e04:	11803fcc 	andi	r6,r2,255
 90c1e08:	e0bffc17 	ldw	r2,-16(fp)
 90c1e0c:	1080030b 	ldhu	r2,12(r2)
 90c1e10:	10bfffcc 	andi	r2,r2,65535
 90c1e14:	1004d23a 	srli	r2,r2,8
 90c1e18:	10bfffcc 	andi	r2,r2,65535
 90c1e1c:	10c03fcc 	andi	r3,r2,255
 90c1e20:	e0bffc17 	ldw	r2,-16(fp)
 90c1e24:	1080030b 	ldhu	r2,12(r2)
 90c1e28:	10bfffcc 	andi	r2,r2,65535
 90c1e2c:	1004923a 	slli	r2,r2,8
 90c1e30:	10bfc00c 	andi	r2,r2,65280
 90c1e34:	1886b03a 	or	r3,r3,r2
 90c1e38:	e0bffc17 	ldw	r2,-16(fp)
 90c1e3c:	1080040b 	ldhu	r2,16(r2)
 90c1e40:	123fffcc 	andi	r8,r2,65535
 90c1e44:	e0bffc17 	ldw	r2,-16(fp)
 90c1e48:	1080048b 	ldhu	r2,18(r2)
 90c1e4c:	127fffcc 	andi	r9,r2,65535
 90c1e50:	e0bffc17 	ldw	r2,-16(fp)
 90c1e54:	12800517 	ldw	r10,20(r2)
 90c1e58:	e0bffc17 	ldw	r2,-16(fp)
 90c1e5c:	12c01f17 	ldw	r11,124(r2)
 90c1e60:	e0bffc17 	ldw	r2,-16(fp)
 90c1e64:	13002017 	ldw	r12,128(r2)
 90c1e68:	e0bffc17 	ldw	r2,-16(fp)
 90c1e6c:	10802103 	ldbu	r2,132(r2)
 90c1e70:	10803fcc 	andi	r2,r2,255
 90c1e74:	1080004c 	andi	r2,r2,1
 90c1e78:	d9000015 	stw	r4,0(sp)
 90c1e7c:	d9400115 	stw	r5,4(sp)
 90c1e80:	d9800215 	stw	r6,8(sp)
 90c1e84:	d8c00315 	stw	r3,12(sp)
 90c1e88:	da000415 	stw	r8,16(sp)
 90c1e8c:	da400515 	stw	r9,20(sp)
 90c1e90:	da800615 	stw	r10,24(sp)
 90c1e94:	dac00715 	stw	r11,28(sp)
 90c1e98:	db000815 	stw	r12,32(sp)
 90c1e9c:	d8800915 	stw	r2,36(sp)
 90c1ea0:	e13fff17 	ldw	r4,-4(fp)
 90c1ea4:	01424374 	movhi	r5,2317
 90c1ea8:	2943d004 	addi	r5,r5,3904
 90c1eac:	e1bffc17 	ldw	r6,-16(fp)
 90c1eb0:	90a55a40 	call	90a55a4 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 90c1eb4:	e0bffc17 	ldw	r2,-16(fp)
 90c1eb8:	10800017 	ldw	r2,0(r2)
 90c1ebc:	e0bffc15 	stw	r2,-16(fp)
 90c1ec0:	e0bffc17 	ldw	r2,-16(fp)
 90c1ec4:	1004c03a 	cmpne	r2,r2,zero
 90c1ec8:	103f7c1e 	bne	r2,zero,90c1cbc <ipr_stats+0x140>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 90c1ecc:	e1bffb0b 	ldhu	r6,-20(fp)
 90c1ed0:	e13fff17 	ldw	r4,-4(fp)
 90c1ed4:	01424374 	movhi	r5,2317
 90c1ed8:	2943eb04 	addi	r5,r5,4012
 90c1edc:	90a55a40 	call	90a55a4 <ns_printf>

   return IPREASM_OK;
 90c1ee0:	0005883a 	mov	r2,zero
}
 90c1ee4:	e037883a 	mov	sp,fp
 90c1ee8:	dfc00217 	ldw	ra,8(sp)
 90c1eec:	df000117 	ldw	fp,4(sp)
 90c1ef0:	dc000017 	ldw	r16,0(sp)
 90c1ef4:	dec00304 	addi	sp,sp,12
 90c1ef8:	f800283a 	ret

090c1efc <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 90c1efc:	defffc04 	addi	sp,sp,-16
 90c1f00:	dfc00315 	stw	ra,12(sp)
 90c1f04:	df000215 	stw	fp,8(sp)
 90c1f08:	df000204 	addi	fp,sp,8
 90c1f0c:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 90c1f10:	e0bfff17 	ldw	r2,-4(fp)
 90c1f14:	10801f17 	ldw	r2,124(r2)
 90c1f18:	1005003a 	cmpeq	r2,r2,zero
 90c1f1c:	1000061e 	bne	r2,zero,90c1f38 <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 90c1f20:	e0bfff17 	ldw	r2,-4(fp)
 90c1f24:	10802017 	ldw	r2,128(r2)
 90c1f28:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 90c1f2c:	e13ffe17 	ldw	r4,-8(fp)
 90c1f30:	01400044 	movi	r5,1
 90c1f34:	90cb0380 	call	90cb038 <icmp_timex>
      }

   return IPREASM_OK;
 90c1f38:	0005883a 	mov	r2,zero
}
 90c1f3c:	e037883a 	mov	sp,fp
 90c1f40:	dfc00117 	ldw	ra,4(sp)
 90c1f44:	df000017 	ldw	fp,0(sp)
 90c1f48:	dec00204 	addi	sp,sp,8
 90c1f4c:	f800283a 	ret

090c1f50 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 90c1f50:	defff204 	addi	sp,sp,-56
 90c1f54:	dfc00d15 	stw	ra,52(sp)
 90c1f58:	df000c15 	stw	fp,48(sp)
 90c1f5c:	dc000b15 	stw	r16,44(sp)
 90c1f60:	df000b04 	addi	fp,sp,44
 90c1f64:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 90c1f68:	00bfffc4 	movi	r2,-1
 90c1f6c:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c1f70:	00824374 	movhi	r2,2317
 90c1f74:	108f0904 	addi	r2,r2,15396
 90c1f78:	10800017 	ldw	r2,0(r2)
 90c1f7c:	1081000c 	andi	r2,r2,1024
 90c1f80:	1005003a 	cmpeq	r2,r2,zero
 90c1f84:	1000101e 	bne	r2,zero,90c1fc8 <ip_rcv+0x78>
 90c1f88:	00824374 	movhi	r2,2317
 90c1f8c:	108f0904 	addi	r2,r2,15396
 90c1f90:	10800017 	ldw	r2,0(r2)
 90c1f94:	1080800c 	andi	r2,r2,512
 90c1f98:	1005003a 	cmpeq	r2,r2,zero
 90c1f9c:	10000a1e 	bne	r2,zero,90c1fc8 <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 90c1fa0:	e0bffe17 	ldw	r2,-8(fp)
 90c1fa4:	14000417 	ldw	r16,16(r2)
 90c1fa8:	e0bffe17 	ldw	r2,-8(fp)
 90c1fac:	11000617 	ldw	r4,24(r2)
 90c1fb0:	90a31080 	call	90a3108 <if_netnumber>
 90c1fb4:	100d883a 	mov	r6,r2
 90c1fb8:	01024374 	movhi	r4,2317
 90c1fbc:	2103f404 	addi	r4,r4,4048
 90c1fc0:	800b883a 	mov	r5,r16
 90c1fc4:	90833900 	call	9083390 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 90c1fc8:	e0bffe17 	ldw	r2,-8(fp)
 90c1fcc:	10800617 	ldw	r2,24(r2)
 90c1fd0:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 90c1fd4:	008243b4 	movhi	r2,2318
 90c1fd8:	10b82c04 	addi	r2,r2,-8016
 90c1fdc:	10800217 	ldw	r2,8(r2)
 90c1fe0:	10c00044 	addi	r3,r2,1
 90c1fe4:	008243b4 	movhi	r2,2318
 90c1fe8:	10b82c04 	addi	r2,r2,-8016
 90c1fec:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 90c1ff0:	e0bffe17 	ldw	r2,-8(fp)
 90c1ff4:	10800317 	ldw	r2,12(r2)
 90c1ff8:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 90c1ffc:	e0bffe17 	ldw	r2,-8(fp)
 90c2000:	11000417 	ldw	r4,16(r2)
 90c2004:	e0bffd17 	ldw	r2,-12(fp)
 90c2008:	1080008b 	ldhu	r2,2(r2)
 90c200c:	10bfffcc 	andi	r2,r2,65535
 90c2010:	1004d23a 	srli	r2,r2,8
 90c2014:	10bfffcc 	andi	r2,r2,65535
 90c2018:	10c03fcc 	andi	r3,r2,255
 90c201c:	e0bffd17 	ldw	r2,-12(fp)
 90c2020:	1080008b 	ldhu	r2,2(r2)
 90c2024:	10bfffcc 	andi	r2,r2,65535
 90c2028:	1004923a 	slli	r2,r2,8
 90c202c:	10bfc00c 	andi	r2,r2,65280
 90c2030:	1884b03a 	or	r2,r3,r2
 90c2034:	2080272e 	bgeu	r4,r2,90c20d4 <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c2038:	00824374 	movhi	r2,2317
 90c203c:	108f0904 	addi	r2,r2,15396
 90c2040:	10800017 	ldw	r2,0(r2)
 90c2044:	1081000c 	andi	r2,r2,1024
 90c2048:	1005003a 	cmpeq	r2,r2,zero
 90c204c:	1000111e 	bne	r2,zero,90c2094 <ip_rcv+0x144>
 90c2050:	00824374 	movhi	r2,2317
 90c2054:	108f0904 	addi	r2,r2,15396
 90c2058:	10800017 	ldw	r2,0(r2)
 90c205c:	1080800c 	andi	r2,r2,512
 90c2060:	1005003a 	cmpeq	r2,r2,zero
 90c2064:	10000b1e 	bne	r2,zero,90c2094 <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 90c2068:	01024374 	movhi	r4,2317
 90c206c:	2103fd04 	addi	r4,r4,4084
 90c2070:	90836b80 	call	90836b8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c2074:	00824374 	movhi	r2,2317
 90c2078:	108f0904 	addi	r2,r2,15396
 90c207c:	10800017 	ldw	r2,0(r2)
 90c2080:	1080008c 	andi	r2,r2,2
 90c2084:	1005003a 	cmpeq	r2,r2,zero
 90c2088:	1000021e 	bne	r2,zero,90c2094 <ip_rcv+0x144>
 90c208c:	e13ffe17 	ldw	r4,-8(fp)
 90c2090:	90bfaf40 	call	90bfaf4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c2094:	008243b4 	movhi	r2,2318
 90c2098:	10b82c04 	addi	r2,r2,-8016
 90c209c:	10800317 	ldw	r2,12(r2)
 90c20a0:	10c00044 	addi	r3,r2,1
 90c20a4:	008243b4 	movhi	r2,2318
 90c20a8:	10b82c04 	addi	r2,r2,-8016
 90c20ac:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c20b0:	01000084 	movi	r4,2
 90c20b4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c20b8:	e13ffe17 	ldw	r4,-8(fp)
 90c20bc:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c20c0:	01000084 	movi	r4,2
 90c20c4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c20c8:	00bff804 	movi	r2,-32
 90c20cc:	e0bfff15 	stw	r2,-4(fp)
 90c20d0:	00009806 	br	90c2334 <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 90c20d4:	e0bffd17 	ldw	r2,-12(fp)
 90c20d8:	1080008b 	ldhu	r2,2(r2)
 90c20dc:	10bfffcc 	andi	r2,r2,65535
 90c20e0:	1004d23a 	srli	r2,r2,8
 90c20e4:	10bfffcc 	andi	r2,r2,65535
 90c20e8:	10c03fcc 	andi	r3,r2,255
 90c20ec:	e0bffd17 	ldw	r2,-12(fp)
 90c20f0:	1080008b 	ldhu	r2,2(r2)
 90c20f4:	10bfffcc 	andi	r2,r2,65535
 90c20f8:	1004923a 	slli	r2,r2,8
 90c20fc:	10bfc00c 	andi	r2,r2,65280
 90c2100:	1884b03a 	or	r2,r3,r2
 90c2104:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 90c2108:	e0fffe17 	ldw	r3,-8(fp)
 90c210c:	e0bff917 	ldw	r2,-28(fp)
 90c2110:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 90c2114:	e0bffd17 	ldw	r2,-12(fp)
 90c2118:	10800003 	ldbu	r2,0(r2)
 90c211c:	10803fcc 	andi	r2,r2,255
 90c2120:	10803c0c 	andi	r2,r2,240
 90c2124:	1005d13a 	srai	r2,r2,4
 90c2128:	10800120 	cmpeqi	r2,r2,4
 90c212c:	1000271e 	bne	r2,zero,90c21cc <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c2130:	00824374 	movhi	r2,2317
 90c2134:	108f0904 	addi	r2,r2,15396
 90c2138:	10800017 	ldw	r2,0(r2)
 90c213c:	1081000c 	andi	r2,r2,1024
 90c2140:	1005003a 	cmpeq	r2,r2,zero
 90c2144:	1000111e 	bne	r2,zero,90c218c <ip_rcv+0x23c>
 90c2148:	00824374 	movhi	r2,2317
 90c214c:	108f0904 	addi	r2,r2,15396
 90c2150:	10800017 	ldw	r2,0(r2)
 90c2154:	1080800c 	andi	r2,r2,512
 90c2158:	1005003a 	cmpeq	r2,r2,zero
 90c215c:	10000b1e 	bne	r2,zero,90c218c <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 90c2160:	01024374 	movhi	r4,2317
 90c2164:	21040204 	addi	r4,r4,4104
 90c2168:	90836b80 	call	90836b8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c216c:	00824374 	movhi	r2,2317
 90c2170:	108f0904 	addi	r2,r2,15396
 90c2174:	10800017 	ldw	r2,0(r2)
 90c2178:	1080008c 	andi	r2,r2,2
 90c217c:	1005003a 	cmpeq	r2,r2,zero
 90c2180:	1000021e 	bne	r2,zero,90c218c <ip_rcv+0x23c>
 90c2184:	e13ffe17 	ldw	r4,-8(fp)
 90c2188:	90bfaf40 	call	90bfaf4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c218c:	008243b4 	movhi	r2,2318
 90c2190:	10b82c04 	addi	r2,r2,-8016
 90c2194:	10800317 	ldw	r2,12(r2)
 90c2198:	10c00044 	addi	r3,r2,1
 90c219c:	008243b4 	movhi	r2,2318
 90c21a0:	10b82c04 	addi	r2,r2,-8016
 90c21a4:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c21a8:	01000084 	movi	r4,2
 90c21ac:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c21b0:	e13ffe17 	ldw	r4,-8(fp)
 90c21b4:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c21b8:	01000084 	movi	r4,2
 90c21bc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c21c0:	00bff804 	movi	r2,-32
 90c21c4:	e0bfff15 	stw	r2,-4(fp)
 90c21c8:	00005a06 	br	90c2334 <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 90c21cc:	e0bffd17 	ldw	r2,-12(fp)
 90c21d0:	1080028b 	ldhu	r2,10(r2)
 90c21d4:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 90c21d8:	e0bffd17 	ldw	r2,-12(fp)
 90c21dc:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 90c21e0:	e0bffd17 	ldw	r2,-12(fp)
 90c21e4:	10800003 	ldbu	r2,0(r2)
 90c21e8:	10803fcc 	andi	r2,r2,255
 90c21ec:	108003cc 	andi	r2,r2,15
 90c21f0:	1085883a 	add	r2,r2,r2
 90c21f4:	1085883a 	add	r2,r2,r2
 90c21f8:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 90c21fc:	e0bffa17 	ldw	r2,-24(fp)
 90c2200:	100ad07a 	srli	r5,r2,1
 90c2204:	e13ffd17 	ldw	r4,-12(fp)
 90c2208:	90a4ef40 	call	90a4ef4 <cksum>
 90c220c:	0084303a 	nor	r2,zero,r2
 90c2210:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 90c2214:	e0fffc8b 	ldhu	r3,-14(fp)
 90c2218:	e0bffc0b 	ldhu	r2,-16(fp)
 90c221c:	18802a26 	beq	r3,r2,90c22c8 <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 90c2220:	e0fffd17 	ldw	r3,-12(fp)
 90c2224:	e0bffc8b 	ldhu	r2,-14(fp)
 90c2228:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c222c:	00824374 	movhi	r2,2317
 90c2230:	108f0904 	addi	r2,r2,15396
 90c2234:	10800017 	ldw	r2,0(r2)
 90c2238:	1081000c 	andi	r2,r2,1024
 90c223c:	1005003a 	cmpeq	r2,r2,zero
 90c2240:	1000111e 	bne	r2,zero,90c2288 <ip_rcv+0x338>
 90c2244:	00824374 	movhi	r2,2317
 90c2248:	108f0904 	addi	r2,r2,15396
 90c224c:	10800017 	ldw	r2,0(r2)
 90c2250:	1080800c 	andi	r2,r2,512
 90c2254:	1005003a 	cmpeq	r2,r2,zero
 90c2258:	10000b1e 	bne	r2,zero,90c2288 <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 90c225c:	01024374 	movhi	r4,2317
 90c2260:	21040904 	addi	r4,r4,4132
 90c2264:	90836b80 	call	90836b8 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 90c2268:	00824374 	movhi	r2,2317
 90c226c:	108f0904 	addi	r2,r2,15396
 90c2270:	10800017 	ldw	r2,0(r2)
 90c2274:	1080008c 	andi	r2,r2,2
 90c2278:	1005003a 	cmpeq	r2,r2,zero
 90c227c:	1000021e 	bne	r2,zero,90c2288 <ip_rcv+0x338>
 90c2280:	e13ffe17 	ldw	r4,-8(fp)
 90c2284:	90bfaf40 	call	90bfaf4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 90c2288:	008243b4 	movhi	r2,2318
 90c228c:	10b82c04 	addi	r2,r2,-8016
 90c2290:	10800317 	ldw	r2,12(r2)
 90c2294:	10c00044 	addi	r3,r2,1
 90c2298:	008243b4 	movhi	r2,2318
 90c229c:	10b82c04 	addi	r2,r2,-8016
 90c22a0:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90c22a4:	01000084 	movi	r4,2
 90c22a8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90c22ac:	e13ffe17 	ldw	r4,-8(fp)
 90c22b0:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c22b4:	01000084 	movi	r4,2
 90c22b8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 90c22bc:	00bff804 	movi	r2,-32
 90c22c0:	e0bfff15 	stw	r2,-4(fp)
 90c22c4:	00001b06 	br	90c2334 <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 90c22c8:	e0fffd17 	ldw	r3,-12(fp)
 90c22cc:	e0bffc8b 	ldhu	r2,-14(fp)
 90c22d0:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 90c22d4:	00800044 	movi	r2,1
 90c22d8:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 90c22dc:	e0bffe04 	addi	r2,fp,-8
 90c22e0:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 90c22e4:	e03ff605 	stb	zero,-40(fp)
 90c22e8:	00000c06 	br	90c231c <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 90c22ec:	e0bff603 	ldbu	r2,-40(fp)
 90c22f0:	1085883a 	add	r2,r2,r2
 90c22f4:	1085883a 	add	r2,r2,r2
 90c22f8:	1007883a 	mov	r3,r2
 90c22fc:	e0bff717 	ldw	r2,-36(fp)
 90c2300:	1885883a 	add	r2,r3,r2
 90c2304:	11000017 	ldw	r4,0(r2)
 90c2308:	90c23500 	call	90c2350 <ip_rcv_phase2>
 90c230c:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 90c2310:	e0bff603 	ldbu	r2,-40(fp)
 90c2314:	10800044 	addi	r2,r2,1
 90c2318:	e0bff605 	stb	r2,-40(fp)
 90c231c:	e0bff603 	ldbu	r2,-40(fp)
 90c2320:	10ffffcc 	andi	r3,r2,65535
 90c2324:	e0bff80b 	ldhu	r2,-32(fp)
 90c2328:	18bff036 	bltu	r3,r2,90c22ec <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 90c232c:	e0bff517 	ldw	r2,-44(fp)
 90c2330:	e0bfff15 	stw	r2,-4(fp)
 90c2334:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2338:	e037883a 	mov	sp,fp
 90c233c:	dfc00217 	ldw	ra,8(sp)
 90c2340:	df000117 	ldw	fp,4(sp)
 90c2344:	dc000017 	ldw	r16,0(sp)
 90c2348:	dec00304 	addi	sp,sp,12
 90c234c:	f800283a 	ret

090c2350 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 90c2350:	defff404 	addi	sp,sp,-48
 90c2354:	dfc00b15 	stw	ra,44(sp)
 90c2358:	df000a15 	stw	fp,40(sp)
 90c235c:	df000a04 	addi	fp,sp,40
 90c2360:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 90c2364:	e0bffe17 	ldw	r2,-8(fp)
 90c2368:	10800317 	ldw	r2,12(r2)
 90c236c:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 90c2370:	e0bffe17 	ldw	r2,-8(fp)
 90c2374:	10800617 	ldw	r2,24(r2)
 90c2378:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 90c237c:	e0bffc17 	ldw	r2,-16(fp)
 90c2380:	10800417 	ldw	r2,16(r2)
 90c2384:	1004d63a 	srli	r2,r2,24
 90c2388:	10c03fcc 	andi	r3,r2,255
 90c238c:	e0bffc17 	ldw	r2,-16(fp)
 90c2390:	10800417 	ldw	r2,16(r2)
 90c2394:	1004d23a 	srli	r2,r2,8
 90c2398:	10bfc00c 	andi	r2,r2,65280
 90c239c:	1886b03a 	or	r3,r3,r2
 90c23a0:	e0bffc17 	ldw	r2,-16(fp)
 90c23a4:	10800417 	ldw	r2,16(r2)
 90c23a8:	10bfc00c 	andi	r2,r2,65280
 90c23ac:	1004923a 	slli	r2,r2,8
 90c23b0:	1886b03a 	or	r3,r3,r2
 90c23b4:	e0bffc17 	ldw	r2,-16(fp)
 90c23b8:	10800417 	ldw	r2,16(r2)
 90c23bc:	10803fcc 	andi	r2,r2,255
 90c23c0:	1004963a 	slli	r2,r2,24
 90c23c4:	1884b03a 	or	r2,r3,r2
 90c23c8:	10fc002c 	andhi	r3,r2,61440
 90c23cc:	00b80034 	movhi	r2,57344
 90c23d0:	1880181e 	bne	r3,r2,90c2434 <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 90c23d4:	e0bffc17 	ldw	r2,-16(fp)
 90c23d8:	11000417 	ldw	r4,16(r2)
 90c23dc:	e17ffb17 	ldw	r5,-20(fp)
 90c23e0:	90c300c0 	call	90c300c <lookup_mcast>
 90c23e4:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 90c23e8:	e0bff917 	ldw	r2,-28(fp)
 90c23ec:	1004c03a 	cmpne	r2,r2,zero
 90c23f0:	10010d1e 	bne	r2,zero,90c2828 <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 90c23f4:	008243b4 	movhi	r2,2318
 90c23f8:	10b82c04 	addi	r2,r2,-8016
 90c23fc:	10800b17 	ldw	r2,44(r2)
 90c2400:	10c00044 	addi	r3,r2,1
 90c2404:	008243b4 	movhi	r2,2318
 90c2408:	10b82c04 	addi	r2,r2,-8016
 90c240c:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2410:	01000084 	movi	r4,2
 90c2414:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90c2418:	e13ffe17 	ldw	r4,-8(fp)
 90c241c:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2420:	01000084 	movi	r4,2
 90c2424:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 90c2428:	00800084 	movi	r2,2
 90c242c:	e0bfff15 	stw	r2,-4(fp)
 90c2430:	00014406 	br	90c2944 <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 90c2434:	e0bffc17 	ldw	r2,-16(fp)
 90c2438:	10c00417 	ldw	r3,16(r2)
 90c243c:	e0bffb17 	ldw	r2,-20(fp)
 90c2440:	10800a17 	ldw	r2,40(r2)
 90c2444:	1880f826 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
 90c2448:	e0bffc17 	ldw	r2,-16(fp)
 90c244c:	10800417 	ldw	r2,16(r2)
 90c2450:	10bfffe0 	cmpeqi	r2,r2,-1
 90c2454:	1000f41e 	bne	r2,zero,90c2828 <ip_rcv_phase2+0x4d8>
 90c2458:	e0bffc17 	ldw	r2,-16(fp)
 90c245c:	10c00417 	ldw	r3,16(r2)
 90c2460:	e0bffb17 	ldw	r2,-20(fp)
 90c2464:	10800e17 	ldw	r2,56(r2)
 90c2468:	1880ef26 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
 90c246c:	e0bffc17 	ldw	r2,-16(fp)
 90c2470:	10c00417 	ldw	r3,16(r2)
 90c2474:	e0bffb17 	ldw	r2,-20(fp)
 90c2478:	10800f17 	ldw	r2,60(r2)
 90c247c:	1880ea26 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
 90c2480:	e0bffc17 	ldw	r2,-16(fp)
 90c2484:	10c00417 	ldw	r3,16(r2)
 90c2488:	e0bffb17 	ldw	r2,-20(fp)
 90c248c:	10801017 	ldw	r2,64(r2)
 90c2490:	1880e526 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
 90c2494:	e0bffb17 	ldw	r2,-20(fp)
 90c2498:	10c00a17 	ldw	r3,40(r2)
 90c249c:	e0bffb17 	ldw	r2,-20(fp)
 90c24a0:	10800c17 	ldw	r2,48(r2)
 90c24a4:	0084303a 	nor	r2,zero,r2
 90c24a8:	1884703a 	and	r2,r3,r2
 90c24ac:	1005003a 	cmpeq	r2,r2,zero
 90c24b0:	1000dd1e 	bne	r2,zero,90c2828 <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c24b4:	00824374 	movhi	r2,2317
 90c24b8:	108f0904 	addi	r2,r2,15396
 90c24bc:	10800017 	ldw	r2,0(r2)
 90c24c0:	1081000c 	andi	r2,r2,1024
 90c24c4:	1005003a 	cmpeq	r2,r2,zero
 90c24c8:	1000181e 	bne	r2,zero,90c252c <ip_rcv_phase2+0x1dc>
 90c24cc:	00824374 	movhi	r2,2317
 90c24d0:	108f0904 	addi	r2,r2,15396
 90c24d4:	10800017 	ldw	r2,0(r2)
 90c24d8:	1080800c 	andi	r2,r2,512
 90c24dc:	1005003a 	cmpeq	r2,r2,zero
 90c24e0:	1000121e 	bne	r2,zero,90c252c <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 90c24e4:	e0bffc17 	ldw	r2,-16(fp)
 90c24e8:	10800417 	ldw	r2,16(r2)
 90c24ec:	11403fcc 	andi	r5,r2,255
 90c24f0:	e0bffc17 	ldw	r2,-16(fp)
 90c24f4:	10800417 	ldw	r2,16(r2)
 90c24f8:	1004d23a 	srli	r2,r2,8
 90c24fc:	11803fcc 	andi	r6,r2,255
 90c2500:	e0bffc17 	ldw	r2,-16(fp)
 90c2504:	10800417 	ldw	r2,16(r2)
 90c2508:	1004d43a 	srli	r2,r2,16
 90c250c:	11c03fcc 	andi	r7,r2,255
 90c2510:	e0bffc17 	ldw	r2,-16(fp)
 90c2514:	10800417 	ldw	r2,16(r2)
 90c2518:	1004d63a 	srli	r2,r2,24
 90c251c:	d8800015 	stw	r2,0(sp)
 90c2520:	01024374 	movhi	r4,2317
 90c2524:	21040e04 	addi	r4,r4,4152
 90c2528:	90833900 	call	9083390 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 90c252c:	008243b4 	movhi	r2,2318
 90c2530:	10b82c04 	addi	r2,r2,-8016
 90c2534:	10800017 	ldw	r2,0(r2)
 90c2538:	10800098 	cmpnei	r2,r2,2
 90c253c:	1000101e 	bne	r2,zero,90c2580 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 90c2540:	008243b4 	movhi	r2,2318
 90c2544:	10b82c04 	addi	r2,r2,-8016
 90c2548:	10800a17 	ldw	r2,40(r2)
 90c254c:	10c00044 	addi	r3,r2,1
 90c2550:	008243b4 	movhi	r2,2318
 90c2554:	10b82c04 	addi	r2,r2,-8016
 90c2558:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 90c255c:	01000084 	movi	r4,2
 90c2560:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
         pk_free(p);
 90c2564:	e13ffe17 	ldw	r4,-8(fp)
 90c2568:	90a9bc80 	call	90a9bc8 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c256c:	01000084 	movi	r4,2
 90c2570:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 90c2574:	00bff7c4 	movi	r2,-33
 90c2578:	e0bfff15 	stw	r2,-4(fp)
 90c257c:	0000f106 	br	90c2944 <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 90c2580:	008243b4 	movhi	r2,2318
 90c2584:	10b82c04 	addi	r2,r2,-8016
 90c2588:	10800517 	ldw	r2,20(r2)
 90c258c:	10c00044 	addi	r3,r2,1
 90c2590:	008243b4 	movhi	r2,2318
 90c2594:	10b82c04 	addi	r2,r2,-8016
 90c2598:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 90c259c:	e0bffc17 	ldw	r2,-16(fp)
 90c25a0:	10800203 	ldbu	r2,8(r2)
 90c25a4:	10803fcc 	andi	r2,r2,255
 90c25a8:	108000a8 	cmpgeui	r2,r2,2
 90c25ac:	10001b1e 	bne	r2,zero,90c261c <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 90c25b0:	008243b4 	movhi	r2,2318
 90c25b4:	10b82c04 	addi	r2,r2,-8016
 90c25b8:	10800a17 	ldw	r2,40(r2)
 90c25bc:	10c00044 	addi	r3,r2,1
 90c25c0:	008243b4 	movhi	r2,2318
 90c25c4:	10b82c04 	addi	r2,r2,-8016
 90c25c8:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 90c25cc:	e0bffc17 	ldw	r2,-16(fp)
 90c25d0:	11000317 	ldw	r4,12(r2)
 90c25d4:	e0bffe17 	ldw	r2,-8(fp)
 90c25d8:	10800617 	ldw	r2,24(r2)
 90c25dc:	11400a17 	ldw	r5,40(r2)
 90c25e0:	e0bffe17 	ldw	r2,-8(fp)
 90c25e4:	10800617 	ldw	r2,24(r2)
 90c25e8:	d8800015 	stw	r2,0(sp)
 90c25ec:	e1bffc17 	ldw	r6,-16(fp)
 90c25f0:	01c2c004 	movi	r7,2816
 90c25f4:	90cace80 	call	90cace8 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90c25f8:	01000084 	movi	r4,2
 90c25fc:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90c2600:	e13ffe17 	ldw	r4,-8(fp)
 90c2604:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2608:	01000084 	movi	r4,2
 90c260c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 90c2610:	00bff7c4 	movi	r2,-33
 90c2614:	e0bfff15 	stw	r2,-4(fp)
 90c2618:	0000ca06 	br	90c2944 <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 90c261c:	e0bffc17 	ldw	r2,-16(fp)
 90c2620:	10c00417 	ldw	r3,16(r2)
 90c2624:	e0bffe17 	ldw	r2,-8(fp)
 90c2628:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 90c262c:	e0bffe17 	ldw	r2,-8(fp)
 90c2630:	11000717 	ldw	r4,28(r2)
 90c2634:	e17ffd04 	addi	r5,fp,-12
 90c2638:	90bfdac0 	call	90bfdac <iproute>
 90c263c:	e0bff815 	stw	r2,-32(fp)
 90c2640:	e0bff817 	ldw	r2,-32(fp)
 90c2644:	1004c03a 	cmpne	r2,r2,zero
 90c2648:	1000101e 	bne	r2,zero,90c268c <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 90c264c:	008243b4 	movhi	r2,2318
 90c2650:	10b82c04 	addi	r2,r2,-8016
 90c2654:	10800b17 	ldw	r2,44(r2)
 90c2658:	10c00044 	addi	r3,r2,1
 90c265c:	008243b4 	movhi	r2,2318
 90c2660:	10b82c04 	addi	r2,r2,-8016
 90c2664:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2668:	01000084 	movi	r4,2
 90c266c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
            pk_free(p);
 90c2670:	e13ffe17 	ldw	r4,-8(fp)
 90c2674:	90a9bc80 	call	90a9bc8 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2678:	01000084 	movi	r4,2
 90c267c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 90c2680:	00bff7c4 	movi	r2,-33
 90c2684:	e0bfff15 	stw	r2,-4(fp)
 90c2688:	0000ae06 	br	90c2944 <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 90c268c:	e0bffc17 	ldw	r2,-16(fp)
 90c2690:	10c00417 	ldw	r3,16(r2)
 90c2694:	e0bff817 	ldw	r2,-32(fp)
 90c2698:	10800a17 	ldw	r2,40(r2)
 90c269c:	18806226 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 90c26a0:	e0bffc17 	ldw	r2,-16(fp)
 90c26a4:	10c00417 	ldw	r3,16(r2)
 90c26a8:	e0bff817 	ldw	r2,-32(fp)
 90c26ac:	10800e17 	ldw	r2,56(r2)
 90c26b0:	18805d26 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
 90c26b4:	e0bffc17 	ldw	r2,-16(fp)
 90c26b8:	10c00417 	ldw	r3,16(r2)
 90c26bc:	e0bffe17 	ldw	r2,-8(fp)
 90c26c0:	10800617 	ldw	r2,24(r2)
 90c26c4:	10800e17 	ldw	r2,56(r2)
 90c26c8:	18805726 	beq	r3,r2,90c2828 <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 90c26cc:	e0fffe17 	ldw	r3,-8(fp)
 90c26d0:	e0bff817 	ldw	r2,-32(fp)
 90c26d4:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 90c26d8:	e0bffe17 	ldw	r2,-8(fp)
 90c26dc:	10c00417 	ldw	r3,16(r2)
 90c26e0:	e0bffe17 	ldw	r2,-8(fp)
 90c26e4:	10800617 	ldw	r2,24(r2)
 90c26e8:	10800817 	ldw	r2,32(r2)
 90c26ec:	1887883a 	add	r3,r3,r2
 90c26f0:	e0bff817 	ldw	r2,-32(fp)
 90c26f4:	10800917 	ldw	r2,36(r2)
 90c26f8:	10c0372e 	bgeu	r2,r3,90c27d8 <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 90c26fc:	e0bffc17 	ldw	r2,-16(fp)
 90c2700:	1080018b 	ldhu	r2,6(r2)
 90c2704:	10bfffcc 	andi	r2,r2,65535
 90c2708:	1004d23a 	srli	r2,r2,8
 90c270c:	10bfffcc 	andi	r2,r2,65535
 90c2710:	10c03fcc 	andi	r3,r2,255
 90c2714:	e0bffc17 	ldw	r2,-16(fp)
 90c2718:	1080018b 	ldhu	r2,6(r2)
 90c271c:	10bfffcc 	andi	r2,r2,65535
 90c2720:	1004923a 	slli	r2,r2,8
 90c2724:	10bfc00c 	andi	r2,r2,65280
 90c2728:	1884b03a 	or	r2,r3,r2
 90c272c:	1090000c 	andi	r2,r2,16384
 90c2730:	1005003a 	cmpeq	r2,r2,zero
 90c2734:	10001b1e 	bne	r2,zero,90c27a4 <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 90c2738:	e0bffc17 	ldw	r2,-16(fp)
 90c273c:	11000317 	ldw	r4,12(r2)
 90c2740:	e0bffe17 	ldw	r2,-8(fp)
 90c2744:	10800617 	ldw	r2,24(r2)
 90c2748:	11400a17 	ldw	r5,40(r2)
 90c274c:	e0bffe17 	ldw	r2,-8(fp)
 90c2750:	10800617 	ldw	r2,24(r2)
 90c2754:	d8800015 	stw	r2,0(sp)
 90c2758:	e1bffc17 	ldw	r6,-16(fp)
 90c275c:	01c00104 	movi	r7,4
 90c2760:	90cace80 	call	90cace8 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 90c2764:	008243b4 	movhi	r2,2318
 90c2768:	10b82c04 	addi	r2,r2,-8016
 90c276c:	10801117 	ldw	r2,68(r2)
 90c2770:	10c00044 	addi	r3,r2,1
 90c2774:	008243b4 	movhi	r2,2318
 90c2778:	10b82c04 	addi	r2,r2,-8016
 90c277c:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2780:	01000084 	movi	r4,2
 90c2784:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
               pk_free(p);
 90c2788:	e13ffe17 	ldw	r4,-8(fp)
 90c278c:	90a9bc80 	call	90a9bc8 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2790:	01000084 	movi	r4,2
 90c2794:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 90c2798:	00bffd44 	movi	r2,-11
 90c279c:	e0bfff15 	stw	r2,-4(fp)
 90c27a0:	00006806 	br	90c2944 <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 90c27a4:	e0bffc17 	ldw	r2,-16(fp)
 90c27a8:	10800203 	ldbu	r2,8(r2)
 90c27ac:	10bfffc4 	addi	r2,r2,-1
 90c27b0:	1007883a 	mov	r3,r2
 90c27b4:	e0bffc17 	ldw	r2,-16(fp)
 90c27b8:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 90c27bc:	e17ffd17 	ldw	r5,-12(fp)
 90c27c0:	e13ffe17 	ldw	r4,-8(fp)
 90c27c4:	90bf41c0 	call	90bf41c <ip_fragment>
 90c27c8:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 90c27cc:	e0bff717 	ldw	r2,-36(fp)
 90c27d0:	e0bfff15 	stw	r2,-4(fp)
 90c27d4:	00005b06 	br	90c2944 <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 90c27d8:	e0bffc17 	ldw	r2,-16(fp)
 90c27dc:	10800203 	ldbu	r2,8(r2)
 90c27e0:	10bfffc4 	addi	r2,r2,-1
 90c27e4:	1007883a 	mov	r3,r2
 90c27e8:	e0bffc17 	ldw	r2,-16(fp)
 90c27ec:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 90c27f0:	e0bffc17 	ldw	r2,-16(fp)
 90c27f4:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 90c27f8:	e13ffc17 	ldw	r4,-16(fp)
 90c27fc:	01400284 	movi	r5,10
 90c2800:	90a4ef40 	call	90a4ef4 <cksum>
 90c2804:	0084303a 	nor	r2,zero,r2
 90c2808:	1007883a 	mov	r3,r2
 90c280c:	e0bffc17 	ldw	r2,-16(fp)
 90c2810:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 90c2814:	e17ffd17 	ldw	r5,-12(fp)
 90c2818:	e13ffe17 	ldw	r4,-8(fp)
 90c281c:	90a2b440 	call	90a2b44 <ip2mac>
 90c2820:	e0bfff15 	stw	r2,-4(fp)
 90c2824:	00004706 	br	90c2944 <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 90c2828:	e0bffc17 	ldw	r2,-16(fp)
 90c282c:	1080018b 	ldhu	r2,6(r2)
 90c2830:	10bfffcc 	andi	r2,r2,65535
 90c2834:	1004d23a 	srli	r2,r2,8
 90c2838:	10803fcc 	andi	r2,r2,255
 90c283c:	1009883a 	mov	r4,r2
 90c2840:	e0bffc17 	ldw	r2,-16(fp)
 90c2844:	1080018b 	ldhu	r2,6(r2)
 90c2848:	10bfffcc 	andi	r2,r2,65535
 90c284c:	1004923a 	slli	r2,r2,8
 90c2850:	1007883a 	mov	r3,r2
 90c2854:	00bfc004 	movi	r2,-256
 90c2858:	1884703a 	and	r2,r3,r2
 90c285c:	2084b03a 	or	r2,r4,r2
 90c2860:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 90c2864:	e0bffa0b 	ldhu	r2,-24(fp)
 90c2868:	1088000c 	andi	r2,r2,8192
 90c286c:	1004c03a 	cmpne	r2,r2,zero
 90c2870:	1000061e 	bne	r2,zero,90c288c <ip_rcv_phase2+0x53c>
 90c2874:	e0fffa0b 	ldhu	r3,-24(fp)
 90c2878:	00bffff4 	movhi	r2,65535
 90c287c:	1087ffc4 	addi	r2,r2,8191
 90c2880:	1884703a 	and	r2,r3,r2
 90c2884:	1005003a 	cmpeq	r2,r2,zero
 90c2888:	10002b1e 	bne	r2,zero,90c2938 <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c288c:	00824374 	movhi	r2,2317
 90c2890:	108f0904 	addi	r2,r2,15396
 90c2894:	10800017 	ldw	r2,0(r2)
 90c2898:	1081000c 	andi	r2,r2,1024
 90c289c:	1005003a 	cmpeq	r2,r2,zero
 90c28a0:	10001a1e 	bne	r2,zero,90c290c <ip_rcv_phase2+0x5bc>
 90c28a4:	00824374 	movhi	r2,2317
 90c28a8:	108f0904 	addi	r2,r2,15396
 90c28ac:	10800017 	ldw	r2,0(r2)
 90c28b0:	1080800c 	andi	r2,r2,512
 90c28b4:	1005003a 	cmpeq	r2,r2,zero
 90c28b8:	1000141e 	bne	r2,zero,90c290c <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 90c28bc:	e0bffc17 	ldw	r2,-16(fp)
 90c28c0:	10800317 	ldw	r2,12(r2)
 90c28c4:	11403fcc 	andi	r5,r2,255
 90c28c8:	e0bffc17 	ldw	r2,-16(fp)
 90c28cc:	10800317 	ldw	r2,12(r2)
 90c28d0:	1004d23a 	srli	r2,r2,8
 90c28d4:	11803fcc 	andi	r6,r2,255
 90c28d8:	e0bffc17 	ldw	r2,-16(fp)
 90c28dc:	10800317 	ldw	r2,12(r2)
 90c28e0:	1004d43a 	srli	r2,r2,16
 90c28e4:	11c03fcc 	andi	r7,r2,255
 90c28e8:	e0bffc17 	ldw	r2,-16(fp)
 90c28ec:	10800317 	ldw	r2,12(r2)
 90c28f0:	1004d63a 	srli	r2,r2,24
 90c28f4:	d8800015 	stw	r2,0(sp)
 90c28f8:	01024374 	movhi	r4,2317
 90c28fc:	21041a04 	addi	r4,r4,4200
 90c2900:	90833900 	call	9083390 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 90c2904:	e13ffe17 	ldw	r4,-8(fp)
 90c2908:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 90c290c:	008243b4 	movhi	r2,2318
 90c2910:	10b82c04 	addi	r2,r2,-8016
 90c2914:	10800d17 	ldw	r2,52(r2)
 90c2918:	10c00044 	addi	r3,r2,1
 90c291c:	008243b4 	movhi	r2,2318
 90c2920:	10b82c04 	addi	r2,r2,-8016
 90c2924:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 90c2928:	e13ffe17 	ldw	r4,-8(fp)
 90c292c:	90c07cc0 	call	90c07cc <ip_reassm>
 90c2930:	e0bfff15 	stw	r2,-4(fp)
 90c2934:	00000306 	br	90c2944 <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 90c2938:	e13ffe17 	ldw	r4,-8(fp)
 90c293c:	90c295c0 	call	90c295c <ip_demux>
 90c2940:	e0bfff15 	stw	r2,-4(fp)
 90c2944:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2948:	e037883a 	mov	sp,fp
 90c294c:	dfc00117 	ldw	ra,4(sp)
 90c2950:	df000017 	ldw	fp,0(sp)
 90c2954:	dec00204 	addi	sp,sp,8
 90c2958:	f800283a 	ret

090c295c <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 90c295c:	defff704 	addi	sp,sp,-36
 90c2960:	dfc00815 	stw	ra,32(sp)
 90c2964:	df000715 	stw	fp,28(sp)
 90c2968:	df000704 	addi	fp,sp,28
 90c296c:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 90c2970:	e0bffd17 	ldw	r2,-12(fp)
 90c2974:	10800317 	ldw	r2,12(r2)
 90c2978:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 90c297c:	e0bffc17 	ldw	r2,-16(fp)
 90c2980:	10800003 	ldbu	r2,0(r2)
 90c2984:	10803fcc 	andi	r2,r2,255
 90c2988:	10801160 	cmpeqi	r2,r2,69
 90c298c:	1000131e 	bne	r2,zero,90c29dc <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 90c2990:	e0bffc17 	ldw	r2,-16(fp)
 90c2994:	10800003 	ldbu	r2,0(r2)
 90c2998:	10803fcc 	andi	r2,r2,255
 90c299c:	10801170 	cmpltui	r2,r2,69
 90c29a0:	1000051e 	bne	r2,zero,90c29b8 <ip_demux+0x5c>
 90c29a4:	e0bffc17 	ldw	r2,-16(fp)
 90c29a8:	10800003 	ldbu	r2,0(r2)
 90c29ac:	10803fcc 	andi	r2,r2,255
 90c29b0:	10801230 	cmpltui	r2,r2,72
 90c29b4:	1000091e 	bne	r2,zero,90c29dc <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 90c29b8:	e0bffc17 	ldw	r2,-16(fp)
 90c29bc:	10800003 	ldbu	r2,0(r2)
 90c29c0:	11403fcc 	andi	r5,r2,255
 90c29c4:	01024374 	movhi	r4,2317
 90c29c8:	21042304 	addi	r4,r4,4236
 90c29cc:	90833900 	call	9083390 <printf>
         return ENP_LOGIC;
 90c29d0:	00bffd44 	movi	r2,-11
 90c29d4:	e0bfff15 	stw	r2,-4(fp)
 90c29d8:	0000e606 	br	90c2d74 <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 90c29dc:	e0bffc17 	ldw	r2,-16(fp)
 90c29e0:	10c00317 	ldw	r3,12(r2)
 90c29e4:	e0bffd17 	ldw	r2,-12(fp)
 90c29e8:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c29ec:	00824374 	movhi	r2,2317
 90c29f0:	108f0904 	addi	r2,r2,15396
 90c29f4:	10800017 	ldw	r2,0(r2)
 90c29f8:	1081000c 	andi	r2,r2,1024
 90c29fc:	1005003a 	cmpeq	r2,r2,zero
 90c2a00:	1000241e 	bne	r2,zero,90c2a94 <ip_demux+0x138>
 90c2a04:	00824374 	movhi	r2,2317
 90c2a08:	108f0904 	addi	r2,r2,15396
 90c2a0c:	10800017 	ldw	r2,0(r2)
 90c2a10:	1080800c 	andi	r2,r2,512
 90c2a14:	1005003a 	cmpeq	r2,r2,zero
 90c2a18:	10001e1e 	bne	r2,zero,90c2a94 <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 90c2a1c:	e0bffc17 	ldw	r2,-16(fp)
 90c2a20:	10800243 	ldbu	r2,9(r2)
 90c2a24:	11403fcc 	andi	r5,r2,255
 90c2a28:	e0bffc17 	ldw	r2,-16(fp)
 90c2a2c:	10800317 	ldw	r2,12(r2)
 90c2a30:	11803fcc 	andi	r6,r2,255
 90c2a34:	e0bffc17 	ldw	r2,-16(fp)
 90c2a38:	10800317 	ldw	r2,12(r2)
 90c2a3c:	1004d23a 	srli	r2,r2,8
 90c2a40:	11c03fcc 	andi	r7,r2,255
 90c2a44:	e0bffc17 	ldw	r2,-16(fp)
 90c2a48:	10800317 	ldw	r2,12(r2)
 90c2a4c:	1004d43a 	srli	r2,r2,16
 90c2a50:	10c03fcc 	andi	r3,r2,255
 90c2a54:	e0bffc17 	ldw	r2,-16(fp)
 90c2a58:	10800317 	ldw	r2,12(r2)
 90c2a5c:	1004d63a 	srli	r2,r2,24
 90c2a60:	d8c00015 	stw	r3,0(sp)
 90c2a64:	d8800115 	stw	r2,4(sp)
 90c2a68:	01024374 	movhi	r4,2317
 90c2a6c:	21042a04 	addi	r4,r4,4264
 90c2a70:	90833900 	call	9083390 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 90c2a74:	00824374 	movhi	r2,2317
 90c2a78:	108f0904 	addi	r2,r2,15396
 90c2a7c:	10800017 	ldw	r2,0(r2)
 90c2a80:	1080008c 	andi	r2,r2,2
 90c2a84:	1005003a 	cmpeq	r2,r2,zero
 90c2a88:	1000021e 	bne	r2,zero,90c2a94 <ip_demux+0x138>
 90c2a8c:	e13ffd17 	ldw	r4,-12(fp)
 90c2a90:	90bfaf40 	call	90bfaf4 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 90c2a94:	e0bffc17 	ldw	r2,-16(fp)
 90c2a98:	10800243 	ldbu	r2,9(r2)
 90c2a9c:	10803fcc 	andi	r2,r2,255
 90c2aa0:	e0bffe15 	stw	r2,-8(fp)
 90c2aa4:	e0fffe17 	ldw	r3,-8(fp)
 90c2aa8:	188000a0 	cmpeqi	r2,r3,2
 90c2aac:	1000241e 	bne	r2,zero,90c2b40 <ip_demux+0x1e4>
 90c2ab0:	e0fffe17 	ldw	r3,-8(fp)
 90c2ab4:	188000c8 	cmpgei	r2,r3,3
 90c2ab8:	1000041e 	bne	r2,zero,90c2acc <ip_demux+0x170>
 90c2abc:	e0fffe17 	ldw	r3,-8(fp)
 90c2ac0:	18800060 	cmpeqi	r2,r3,1
 90c2ac4:	1000131e 	bne	r2,zero,90c2b14 <ip_demux+0x1b8>
 90c2ac8:	00003306 	br	90c2b98 <ip_demux+0x23c>
 90c2acc:	e0fffe17 	ldw	r3,-8(fp)
 90c2ad0:	188001a0 	cmpeqi	r2,r3,6
 90c2ad4:	1000251e 	bne	r2,zero,90c2b6c <ip_demux+0x210>
 90c2ad8:	e0fffe17 	ldw	r3,-8(fp)
 90c2adc:	18800460 	cmpeqi	r2,r3,17
 90c2ae0:	1000011e 	bne	r2,zero,90c2ae8 <ip_demux+0x18c>
 90c2ae4:	00002c06 	br	90c2b98 <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 90c2ae8:	008243b4 	movhi	r2,2318
 90c2aec:	10b82c04 	addi	r2,r2,-8016
 90c2af0:	10800817 	ldw	r2,32(r2)
 90c2af4:	10c00044 	addi	r3,r2,1
 90c2af8:	008243b4 	movhi	r2,2318
 90c2afc:	10b82c04 	addi	r2,r2,-8016
 90c2b00:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 90c2b04:	e13ffd17 	ldw	r4,-12(fp)
 90c2b08:	90c3da00 	call	90c3da0 <udpdemux>
 90c2b0c:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c2b10:	00002b06 	br	90c2bc0 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 90c2b14:	008243b4 	movhi	r2,2318
 90c2b18:	10b82c04 	addi	r2,r2,-8016
 90c2b1c:	10800817 	ldw	r2,32(r2)
 90c2b20:	10c00044 	addi	r3,r2,1
 90c2b24:	008243b4 	movhi	r2,2318
 90c2b28:	10b82c04 	addi	r2,r2,-8016
 90c2b2c:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 90c2b30:	e13ffd17 	ldw	r4,-12(fp)
 90c2b34:	90ca0b40 	call	90ca0b4 <icmprcv>
 90c2b38:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c2b3c:	00002006 	br	90c2bc0 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 90c2b40:	008243b4 	movhi	r2,2318
 90c2b44:	10b82c04 	addi	r2,r2,-8016
 90c2b48:	10800817 	ldw	r2,32(r2)
 90c2b4c:	10c00044 	addi	r3,r2,1
 90c2b50:	008243b4 	movhi	r2,2318
 90c2b54:	10b82c04 	addi	r2,r2,-8016
 90c2b58:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 90c2b5c:	e13ffd17 	ldw	r4,-12(fp)
 90c2b60:	90a32880 	call	90a3288 <igmp_input>
 90c2b64:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c2b68:	00001506 	br	90c2bc0 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 90c2b6c:	008243b4 	movhi	r2,2318
 90c2b70:	10b82c04 	addi	r2,r2,-8016
 90c2b74:	10800817 	ldw	r2,32(r2)
 90c2b78:	10c00044 	addi	r3,r2,1
 90c2b7c:	008243b4 	movhi	r2,2318
 90c2b80:	10b82c04 	addi	r2,r2,-8016
 90c2b84:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 90c2b88:	e13ffd17 	ldw	r4,-12(fp)
 90c2b8c:	90abddc0 	call	90abddc <tcp_rcv>
 90c2b90:	e0bffb15 	stw	r2,-20(fp)
      break;
 90c2b94:	00000a06 	br	90c2bc0 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 90c2b98:	008243b4 	movhi	r2,2318
 90c2b9c:	10b82c04 	addi	r2,r2,-8016
 90c2ba0:	10800817 	ldw	r2,32(r2)
 90c2ba4:	10c00044 	addi	r3,r2,1
 90c2ba8:	008243b4 	movhi	r2,2318
 90c2bac:	10b82c04 	addi	r2,r2,-8016
 90c2bb0:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 90c2bb4:	e13ffd17 	ldw	r4,-12(fp)
 90c2bb8:	90c33100 	call	90c3310 <ip_raw_input>
 90c2bbc:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 90c2bc0:	e0bffb17 	ldw	r2,-20(fp)
 90c2bc4:	10bffda0 	cmpeqi	r2,r2,-10
 90c2bc8:	1000031e 	bne	r2,zero,90c2bd8 <ip_demux+0x27c>
   {
      return err;
 90c2bcc:	e0bffb17 	ldw	r2,-20(fp)
 90c2bd0:	e0bfff15 	stw	r2,-4(fp)
 90c2bd4:	00006706 	br	90c2d74 <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 90c2bd8:	e0bffc17 	ldw	r2,-16(fp)
 90c2bdc:	10800417 	ldw	r2,16(r2)
 90c2be0:	10bfffe0 	cmpeqi	r2,r2,-1
 90c2be4:	1000541e 	bne	r2,zero,90c2d38 <ip_demux+0x3dc>
 90c2be8:	e0bffc17 	ldw	r2,-16(fp)
 90c2bec:	10800417 	ldw	r2,16(r2)
 90c2bf0:	1004d63a 	srli	r2,r2,24
 90c2bf4:	10c03fcc 	andi	r3,r2,255
 90c2bf8:	e0bffc17 	ldw	r2,-16(fp)
 90c2bfc:	10800417 	ldw	r2,16(r2)
 90c2c00:	1004d23a 	srli	r2,r2,8
 90c2c04:	10bfc00c 	andi	r2,r2,65280
 90c2c08:	1886b03a 	or	r3,r3,r2
 90c2c0c:	e0bffc17 	ldw	r2,-16(fp)
 90c2c10:	10800417 	ldw	r2,16(r2)
 90c2c14:	10bfc00c 	andi	r2,r2,65280
 90c2c18:	1004923a 	slli	r2,r2,8
 90c2c1c:	1886b03a 	or	r3,r3,r2
 90c2c20:	e0bffc17 	ldw	r2,-16(fp)
 90c2c24:	10800417 	ldw	r2,16(r2)
 90c2c28:	10803fcc 	andi	r2,r2,255
 90c2c2c:	1004963a 	slli	r2,r2,24
 90c2c30:	1884b03a 	or	r2,r3,r2
 90c2c34:	10fc002c 	andhi	r3,r2,61440
 90c2c38:	00b80034 	movhi	r2,57344
 90c2c3c:	18803e26 	beq	r3,r2,90c2d38 <ip_demux+0x3dc>
 90c2c40:	e0bffc17 	ldw	r2,-16(fp)
 90c2c44:	10c00417 	ldw	r3,16(r2)
 90c2c48:	e0bffd17 	ldw	r2,-12(fp)
 90c2c4c:	10800617 	ldw	r2,24(r2)
 90c2c50:	10800e17 	ldw	r2,56(r2)
 90c2c54:	18803826 	beq	r3,r2,90c2d38 <ip_demux+0x3dc>
 90c2c58:	e0bffc17 	ldw	r2,-16(fp)
 90c2c5c:	10c00417 	ldw	r3,16(r2)
 90c2c60:	e0bffd17 	ldw	r2,-12(fp)
 90c2c64:	10800617 	ldw	r2,24(r2)
 90c2c68:	10800f17 	ldw	r2,60(r2)
 90c2c6c:	18803226 	beq	r3,r2,90c2d38 <ip_demux+0x3dc>
 90c2c70:	e0bffc17 	ldw	r2,-16(fp)
 90c2c74:	10c00417 	ldw	r3,16(r2)
 90c2c78:	e0bffd17 	ldw	r2,-12(fp)
 90c2c7c:	10800617 	ldw	r2,24(r2)
 90c2c80:	10801017 	ldw	r2,64(r2)
 90c2c84:	18802c26 	beq	r3,r2,90c2d38 <ip_demux+0x3dc>
 90c2c88:	e0bffd17 	ldw	r2,-12(fp)
 90c2c8c:	10800617 	ldw	r2,24(r2)
 90c2c90:	10c00a17 	ldw	r3,40(r2)
 90c2c94:	e0bffd17 	ldw	r2,-12(fp)
 90c2c98:	10800617 	ldw	r2,24(r2)
 90c2c9c:	10801017 	ldw	r2,64(r2)
 90c2ca0:	18802526 	beq	r3,r2,90c2d38 <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90c2ca4:	00824374 	movhi	r2,2317
 90c2ca8:	108f0904 	addi	r2,r2,15396
 90c2cac:	10800017 	ldw	r2,0(r2)
 90c2cb0:	1081000c 	andi	r2,r2,1024
 90c2cb4:	1005003a 	cmpeq	r2,r2,zero
 90c2cb8:	1000141e 	bne	r2,zero,90c2d0c <ip_demux+0x3b0>
 90c2cbc:	00824374 	movhi	r2,2317
 90c2cc0:	108f0904 	addi	r2,r2,15396
 90c2cc4:	10800017 	ldw	r2,0(r2)
 90c2cc8:	1080800c 	andi	r2,r2,512
 90c2ccc:	1005003a 	cmpeq	r2,r2,zero
 90c2cd0:	10000e1e 	bne	r2,zero,90c2d0c <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 90c2cd4:	e0bffc17 	ldw	r2,-16(fp)
 90c2cd8:	10800243 	ldbu	r2,9(r2)
 90c2cdc:	11403fcc 	andi	r5,r2,255
 90c2ce0:	01024374 	movhi	r4,2317
 90c2ce4:	21043404 	addi	r4,r4,4304
 90c2ce8:	90833900 	call	9083390 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90c2cec:	00824374 	movhi	r2,2317
 90c2cf0:	108f0904 	addi	r2,r2,15396
 90c2cf4:	10800017 	ldw	r2,0(r2)
 90c2cf8:	1080008c 	andi	r2,r2,2
 90c2cfc:	1005003a 	cmpeq	r2,r2,zero
 90c2d00:	1000021e 	bne	r2,zero,90c2d0c <ip_demux+0x3b0>
 90c2d04:	e13ffd17 	ldw	r4,-12(fp)
 90c2d08:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 90c2d0c:	e0bffc17 	ldw	r2,-16(fp)
 90c2d10:	11000317 	ldw	r4,12(r2)
 90c2d14:	e0bffd17 	ldw	r2,-12(fp)
 90c2d18:	10800617 	ldw	r2,24(r2)
 90c2d1c:	11400a17 	ldw	r5,40(r2)
 90c2d20:	e0bffd17 	ldw	r2,-12(fp)
 90c2d24:	10800617 	ldw	r2,24(r2)
 90c2d28:	d8800015 	stw	r2,0(sp)
 90c2d2c:	e1bffc17 	ldw	r6,-16(fp)
 90c2d30:	01c00084 	movi	r7,2
 90c2d34:	90cace80 	call	90cace8 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 90c2d38:	008243b4 	movhi	r2,2318
 90c2d3c:	10b82c04 	addi	r2,r2,-8016
 90c2d40:	10800617 	ldw	r2,24(r2)
 90c2d44:	10c00044 	addi	r3,r2,1
 90c2d48:	008243b4 	movhi	r2,2318
 90c2d4c:	10b82c04 	addi	r2,r2,-8016
 90c2d50:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c2d54:	01000084 	movi	r4,2
 90c2d58:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c2d5c:	e13ffd17 	ldw	r4,-12(fp)
 90c2d60:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c2d64:	01000084 	movi	r4,2
 90c2d68:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 90c2d6c:	00c00084 	movi	r3,2
 90c2d70:	e0ffff15 	stw	r3,-4(fp)
 90c2d74:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2d78:	e037883a 	mov	sp,fp
 90c2d7c:	dfc00117 	ldw	ra,4(sp)
 90c2d80:	df000017 	ldw	fp,0(sp)
 90c2d84:	dec00204 	addi	sp,sp,8
 90c2d88:	f800283a 	ret

090c2d8c <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 90c2d8c:	defff804 	addi	sp,sp,-32
 90c2d90:	dfc00715 	stw	ra,28(sp)
 90c2d94:	df000615 	stw	fp,24(sp)
 90c2d98:	df000604 	addi	fp,sp,24
 90c2d9c:	e13ffc15 	stw	r4,-16(fp)
 90c2da0:	e17ffd15 	stw	r5,-12(fp)
 90c2da4:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 90c2da8:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 90c2dac:	e0bffc17 	ldw	r2,-16(fp)
 90c2db0:	1005003a 	cmpeq	r2,r2,zero
 90c2db4:	1000041e 	bne	r2,zero,90c2dc8 <in_addmulti+0x3c>
 90c2db8:	e0bffc17 	ldw	r2,-16(fp)
 90c2dbc:	10800017 	ldw	r2,0(r2)
 90c2dc0:	1004c03a 	cmpne	r2,r2,zero
 90c2dc4:	1000021e 	bne	r2,zero,90c2dd0 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 90c2dc8:	e03fff15 	stw	zero,-4(fp)
 90c2dcc:	00004306 	br	90c2edc <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 90c2dd0:	90aa6b80 	call	90aa6b8 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 90c2dd4:	e0bffe17 	ldw	r2,-8(fp)
 90c2dd8:	108001a0 	cmpeqi	r2,r2,6
 90c2ddc:	1000051e 	bne	r2,zero,90c2df4 <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 90c2de0:	e0bffc17 	ldw	r2,-16(fp)
 90c2de4:	11000017 	ldw	r4,0(r2)
 90c2de8:	e17ffd17 	ldw	r5,-12(fp)
 90c2dec:	90c300c0 	call	90c300c <lookup_mcast>
 90c2df0:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 90c2df4:	e0bffb17 	ldw	r2,-20(fp)
 90c2df8:	1005003a 	cmpeq	r2,r2,zero
 90c2dfc:	1000061e 	bne	r2,zero,90c2e18 <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 90c2e00:	e0bffb17 	ldw	r2,-20(fp)
 90c2e04:	10800217 	ldw	r2,8(r2)
 90c2e08:	10c00044 	addi	r3,r2,1
 90c2e0c:	e0bffb17 	ldw	r2,-20(fp)
 90c2e10:	10c00215 	stw	r3,8(r2)
 90c2e14:	00002e06 	br	90c2ed0 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 90c2e18:	01000604 	movi	r4,24
 90c2e1c:	90aaefc0 	call	90aaefc <npalloc>
 90c2e20:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 90c2e24:	e0bffb17 	ldw	r2,-20(fp)
 90c2e28:	1004c03a 	cmpne	r2,r2,zero
 90c2e2c:	1000031e 	bne	r2,zero,90c2e3c <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 90c2e30:	90aa7140 	call	90aa714 <irq_Unmask>
         return ((struct in_multi *)NULL);
 90c2e34:	e03fff15 	stw	zero,-4(fp)
 90c2e38:	00002806 	br	90c2edc <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 90c2e3c:	e0bffe17 	ldw	r2,-8(fp)
 90c2e40:	108001a0 	cmpeqi	r2,r2,6
 90c2e44:	1000041e 	bne	r2,zero,90c2e58 <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 90c2e48:	e0bffc17 	ldw	r2,-16(fp)
 90c2e4c:	10c00017 	ldw	r3,0(r2)
 90c2e50:	e0bffb17 	ldw	r2,-20(fp)
 90c2e54:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 90c2e58:	e0fffb17 	ldw	r3,-20(fp)
 90c2e5c:	e0bffd17 	ldw	r2,-12(fp)
 90c2e60:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 90c2e64:	e0fffb17 	ldw	r3,-20(fp)
 90c2e68:	00800044 	movi	r2,1
 90c2e6c:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 90c2e70:	e0bffd17 	ldw	r2,-12(fp)
 90c2e74:	10c02c17 	ldw	r3,176(r2)
 90c2e78:	e0bffb17 	ldw	r2,-20(fp)
 90c2e7c:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 90c2e80:	e0fffd17 	ldw	r3,-12(fp)
 90c2e84:	e0bffb17 	ldw	r2,-20(fp)
 90c2e88:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 90c2e8c:	e0bffd17 	ldw	r2,-12(fp)
 90c2e90:	10802b17 	ldw	r2,172(r2)
 90c2e94:	1005003a 	cmpeq	r2,r2,zero
 90c2e98:	1000061e 	bne	r2,zero,90c2eb4 <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 90c2e9c:	e0bffd17 	ldw	r2,-12(fp)
 90c2ea0:	10802b17 	ldw	r2,172(r2)
 90c2ea4:	e13ffb17 	ldw	r4,-20(fp)
 90c2ea8:	103ee83a 	callr	r2
 90c2eac:	e0bffa15 	stw	r2,-24(fp)
 90c2eb0:	00000106 	br	90c2eb8 <in_addmulti+0x12c>
      else
         error = 0;
 90c2eb4:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 90c2eb8:	e0bffb17 	ldw	r2,-20(fp)
 90c2ebc:	10800017 	ldw	r2,0(r2)
 90c2ec0:	1005003a 	cmpeq	r2,r2,zero
 90c2ec4:	1000021e 	bne	r2,zero,90c2ed0 <in_addmulti+0x144>
 90c2ec8:	e13ffb17 	ldw	r4,-20(fp)
 90c2ecc:	90a385c0 	call	90a385c <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 90c2ed0:	90aa7140 	call	90aa714 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 90c2ed4:	e0bffb17 	ldw	r2,-20(fp)
 90c2ed8:	e0bfff15 	stw	r2,-4(fp)
 90c2edc:	e0bfff17 	ldw	r2,-4(fp)
}
 90c2ee0:	e037883a 	mov	sp,fp
 90c2ee4:	dfc00117 	ldw	ra,4(sp)
 90c2ee8:	df000017 	ldw	fp,0(sp)
 90c2eec:	dec00204 	addi	sp,sp,8
 90c2ef0:	f800283a 	ret

090c2ef4 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 90c2ef4:	defffa04 	addi	sp,sp,-24
 90c2ef8:	dfc00515 	stw	ra,20(sp)
 90c2efc:	df000415 	stw	fp,16(sp)
 90c2f00:	df000404 	addi	fp,sp,16
 90c2f04:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 90c2f08:	e0bfff17 	ldw	r2,-4(fp)
 90c2f0c:	10800117 	ldw	r2,4(r2)
 90c2f10:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 90c2f14:	90aa6b80 	call	90aa6b8 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 90c2f18:	e0bfff17 	ldw	r2,-4(fp)
 90c2f1c:	10800217 	ldw	r2,8(r2)
 90c2f20:	10ffffc4 	addi	r3,r2,-1
 90c2f24:	e0bfff17 	ldw	r2,-4(fp)
 90c2f28:	10c00215 	stw	r3,8(r2)
 90c2f2c:	e0bfff17 	ldw	r2,-4(fp)
 90c2f30:	10800217 	ldw	r2,8(r2)
 90c2f34:	1004c03a 	cmpne	r2,r2,zero
 90c2f38:	10002e1e 	bne	r2,zero,90c2ff4 <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 90c2f3c:	e0bffd17 	ldw	r2,-12(fp)
 90c2f40:	10802c17 	ldw	r2,176(r2)
 90c2f44:	e0bffe15 	stw	r2,-8(fp)
 90c2f48:	00001406 	br	90c2f9c <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 90c2f4c:	e0fffe17 	ldw	r3,-8(fp)
 90c2f50:	e0bfff17 	ldw	r2,-4(fp)
 90c2f54:	1880051e 	bne	r3,r2,90c2f6c <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 90c2f58:	e0bffe17 	ldw	r2,-8(fp)
 90c2f5c:	10c00517 	ldw	r3,20(r2)
 90c2f60:	e0bffd17 	ldw	r2,-12(fp)
 90c2f64:	10c02c15 	stw	r3,176(r2)
            break;
 90c2f68:	00000f06 	br	90c2fa8 <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 90c2f6c:	e0bffe17 	ldw	r2,-8(fp)
 90c2f70:	10c00517 	ldw	r3,20(r2)
 90c2f74:	e0bfff17 	ldw	r2,-4(fp)
 90c2f78:	1880051e 	bne	r3,r2,90c2f90 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 90c2f7c:	e0bfff17 	ldw	r2,-4(fp)
 90c2f80:	10c00517 	ldw	r3,20(r2)
 90c2f84:	e0bffe17 	ldw	r2,-8(fp)
 90c2f88:	10c00515 	stw	r3,20(r2)
            break;
 90c2f8c:	00000606 	br	90c2fa8 <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 90c2f90:	e0bffe17 	ldw	r2,-8(fp)
 90c2f94:	10800517 	ldw	r2,20(r2)
 90c2f98:	e0bffe15 	stw	r2,-8(fp)
 90c2f9c:	e0bffe17 	ldw	r2,-8(fp)
 90c2fa0:	1004c03a 	cmpne	r2,r2,zero
 90c2fa4:	103fe91e 	bne	r2,zero,90c2f4c <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 90c2fa8:	e0bffd17 	ldw	r2,-12(fp)
 90c2fac:	10802b17 	ldw	r2,172(r2)
 90c2fb0:	1005003a 	cmpeq	r2,r2,zero
 90c2fb4:	1000061e 	bne	r2,zero,90c2fd0 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 90c2fb8:	e0bffd17 	ldw	r2,-12(fp)
 90c2fbc:	10802b17 	ldw	r2,172(r2)
 90c2fc0:	e13fff17 	ldw	r4,-4(fp)
 90c2fc4:	103ee83a 	callr	r2
 90c2fc8:	e0bffc15 	stw	r2,-16(fp)
 90c2fcc:	00000106 	br	90c2fd4 <in_delmulti+0xe0>
      else
         error = 0;
 90c2fd0:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 90c2fd4:	e0bfff17 	ldw	r2,-4(fp)
 90c2fd8:	10800017 	ldw	r2,0(r2)
 90c2fdc:	1005003a 	cmpeq	r2,r2,zero
 90c2fe0:	1000021e 	bne	r2,zero,90c2fec <in_delmulti+0xf8>
 90c2fe4:	e13fff17 	ldw	r4,-4(fp)
 90c2fe8:	90a3ad80 	call	90a3ad8 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 90c2fec:	e13fff17 	ldw	r4,-4(fp)
 90c2ff0:	90aaff00 	call	90aaff0 <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 90c2ff4:	90aa7140 	call	90aa714 <irq_Unmask>
}
 90c2ff8:	e037883a 	mov	sp,fp
 90c2ffc:	dfc00117 	ldw	ra,4(sp)
 90c3000:	df000017 	ldw	fp,0(sp)
 90c3004:	dec00204 	addi	sp,sp,8
 90c3008:	f800283a 	ret

090c300c <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 90c300c:	defffb04 	addi	sp,sp,-20
 90c3010:	df000415 	stw	fp,16(sp)
 90c3014:	df000404 	addi	fp,sp,16
 90c3018:	e13ffd15 	stw	r4,-12(fp)
 90c301c:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 90c3020:	e0bffe17 	ldw	r2,-8(fp)
 90c3024:	10802c17 	ldw	r2,176(r2)
 90c3028:	e0bffc15 	stw	r2,-16(fp)
 90c302c:	00000a06 	br	90c3058 <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 90c3030:	e0bffc17 	ldw	r2,-16(fp)
 90c3034:	10c00017 	ldw	r3,0(r2)
 90c3038:	e0bffd17 	ldw	r2,-12(fp)
 90c303c:	1880031e 	bne	r3,r2,90c304c <lookup_mcast+0x40>
         return imp;
 90c3040:	e0bffc17 	ldw	r2,-16(fp)
 90c3044:	e0bfff15 	stw	r2,-4(fp)
 90c3048:	00000706 	br	90c3068 <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 90c304c:	e0bffc17 	ldw	r2,-16(fp)
 90c3050:	10800517 	ldw	r2,20(r2)
 90c3054:	e0bffc15 	stw	r2,-16(fp)
 90c3058:	e0bffc17 	ldw	r2,-16(fp)
 90c305c:	1004c03a 	cmpne	r2,r2,zero
 90c3060:	103ff31e 	bne	r2,zero,90c3030 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 90c3064:	e03fff15 	stw	zero,-4(fp)
 90c3068:	e0bfff17 	ldw	r2,-4(fp)
}
 90c306c:	e037883a 	mov	sp,fp
 90c3070:	df000017 	ldw	fp,0(sp)
 90c3074:	dec00104 	addi	sp,sp,4
 90c3078:	f800283a 	ret

090c307c <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 90c307c:	defffc04 	addi	sp,sp,-16
 90c3080:	dfc00315 	stw	ra,12(sp)
 90c3084:	df000215 	stw	fp,8(sp)
 90c3088:	df000204 	addi	fp,sp,8
 90c308c:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 90c3090:	d0a0cb17 	ldw	r2,-31956(gp)
 90c3094:	1005003a 	cmpeq	r2,r2,zero
 90c3098:	1000041e 	bne	r2,zero,90c30ac <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 90c309c:	d0a0cb17 	ldw	r2,-31956(gp)
 90c30a0:	e13ffe17 	ldw	r4,-8(fp)
 90c30a4:	103ee83a 	callr	r2
 90c30a8:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 90c30ac:	e0fffe17 	ldw	r3,-8(fp)
 90c30b0:	00824374 	movhi	r2,2317
 90c30b4:	108f0a04 	addi	r2,r2,15400
 90c30b8:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 90c30bc:	e0bffe17 	ldw	r2,-8(fp)
 90c30c0:	10800058 	cmpnei	r2,r2,1
 90c30c4:	1000041e 	bne	r2,zero,90c30d8 <prep_ifaces+0x5c>
 90c30c8:	00824374 	movhi	r2,2317
 90c30cc:	10843c04 	addi	r2,r2,4336
 90c30d0:	e0bfff15 	stw	r2,-4(fp)
 90c30d4:	00000306 	br	90c30e4 <prep_ifaces+0x68>
 90c30d8:	00824374 	movhi	r2,2317
 90c30dc:	10843d04 	addi	r2,r2,4340
 90c30e0:	e0bfff15 	stw	r2,-4(fp)
 90c30e4:	01024374 	movhi	r4,2317
 90c30e8:	21043e04 	addi	r4,r4,4344
 90c30ec:	e17ffe17 	ldw	r5,-8(fp)
 90c30f0:	e1bfff17 	ldw	r6,-4(fp)
 90c30f4:	90833900 	call	9083390 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 90c30f8:	e0bffe17 	ldw	r2,-8(fp)
}
 90c30fc:	e037883a 	mov	sp,fp
 90c3100:	dfc00117 	ldw	ra,4(sp)
 90c3104:	df000017 	ldw	fp,0(sp)
 90c3108:	dec00204 	addi	sp,sp,8
 90c310c:	f800283a 	ret

090c3110 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 90c3110:	defffd04 	addi	sp,sp,-12
 90c3114:	dfc00215 	stw	ra,8(sp)
 90c3118:	df000115 	stw	fp,4(sp)
 90c311c:	df000104 	addi	fp,sp,4
 90c3120:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 90c3124:	00800044 	movi	r2,1
 90c3128:	d0a0cc15 	stw	r2,-31952(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 90c312c:	90a30380 	call	90a3038 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 90c3130:	e13fff17 	ldw	r4,-4(fp)
 90c3134:	60200000 	call	6020000 <__reset>

090c3138 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 90c3138:	deffff04 	addi	sp,sp,-4
 90c313c:	df000015 	stw	fp,0(sp)
 90c3140:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 90c3144:	d020cf05 	stb	zero,-31940(gp)
   so_evtmap_create = 0;
 90c3148:	d020cd15 	stw	zero,-31948(gp)
   so_evtmap_delete = 0;
 90c314c:	d020ce15 	stw	zero,-31944(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 90c3150:	e037883a 	mov	sp,fp
 90c3154:	df000017 	ldw	fp,0(sp)
 90c3158:	dec00104 	addi	sp,sp,4
 90c315c:	f800283a 	ret

090c3160 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 90c3160:	defff804 	addi	sp,sp,-32
 90c3164:	dfc00715 	stw	ra,28(sp)
 90c3168:	df000615 	stw	fp,24(sp)
 90c316c:	df000604 	addi	fp,sp,24
 90c3170:	e17ffc15 	stw	r5,-16(fp)
 90c3174:	e1bffd15 	stw	r6,-12(fp)
 90c3178:	e1fffe15 	stw	r7,-8(fp)
 90c317c:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 90c3180:	0009883a 	mov	r4,zero
 90c3184:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 90c3188:	01000604 	movi	r4,24
 90c318c:	90aaefc0 	call	90aaefc <npalloc>
 90c3190:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 90c3194:	e0bffa17 	ldw	r2,-24(fp)
 90c3198:	1004c03a 	cmpne	r2,r2,zero
 90c319c:	10000e1e 	bne	r2,zero,90c31d8 <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 90c31a0:	00824374 	movhi	r2,2317
 90c31a4:	108f0904 	addi	r2,r2,15396
 90c31a8:	10800017 	ldw	r2,0(r2)
 90c31ac:	1080010c 	andi	r2,r2,4
 90c31b0:	1005003a 	cmpeq	r2,r2,zero
 90c31b4:	1000031e 	bne	r2,zero,90c31c4 <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 90c31b8:	01024374 	movhi	r4,2317
 90c31bc:	21044904 	addi	r4,r4,4388
 90c31c0:	90836b80 	call	90836b8 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c31c4:	0009883a 	mov	r4,zero
 90c31c8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ep;
 90c31cc:	e0bffa17 	ldw	r2,-24(fp)
 90c31d0:	e0bfff15 	stw	r2,-4(fp)
 90c31d4:	00001806 	br	90c3238 <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 90c31d8:	e0fffa17 	ldw	r3,-24(fp)
 90c31dc:	e0bffc17 	ldw	r2,-16(fp)
 90c31e0:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 90c31e4:	e0fffa17 	ldw	r3,-24(fp)
 90c31e8:	e0bffd17 	ldw	r2,-12(fp)
 90c31ec:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 90c31f0:	e0fffa17 	ldw	r3,-24(fp)
 90c31f4:	e0bffb03 	ldbu	r2,-20(fp)
 90c31f8:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 90c31fc:	e0fffa17 	ldw	r3,-24(fp)
 90c3200:	e0bffe17 	ldw	r2,-8(fp)
 90c3204:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 90c3208:	e0fffa17 	ldw	r3,-24(fp)
 90c320c:	e0800217 	ldw	r2,8(fp)
 90c3210:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 90c3214:	d0e0d017 	ldw	r3,-31936(gp)
 90c3218:	e0bffa17 	ldw	r2,-24(fp)
 90c321c:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 90c3220:	e0bffa17 	ldw	r2,-24(fp)
 90c3224:	d0a0d015 	stw	r2,-31936(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c3228:	0009883a 	mov	r4,zero
 90c322c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return ep;
 90c3230:	e0bffa17 	ldw	r2,-24(fp)
 90c3234:	e0bfff15 	stw	r2,-4(fp)
 90c3238:	e0bfff17 	ldw	r2,-4(fp)
}
 90c323c:	e037883a 	mov	sp,fp
 90c3240:	dfc00117 	ldw	ra,4(sp)
 90c3244:	df000017 	ldw	fp,0(sp)
 90c3248:	dec00204 	addi	sp,sp,8
 90c324c:	f800283a 	ret

090c3250 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 90c3250:	defffb04 	addi	sp,sp,-20
 90c3254:	dfc00415 	stw	ra,16(sp)
 90c3258:	df000315 	stw	fp,12(sp)
 90c325c:	df000304 	addi	fp,sp,12
 90c3260:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 90c3264:	0009883a 	mov	r4,zero
 90c3268:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 90c326c:	e03ffe15 	stw	zero,-8(fp)
 90c3270:	d0a0d017 	ldw	r2,-31936(gp)
 90c3274:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 90c3278:	00000806 	br	90c329c <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 90c327c:	e0fffd17 	ldw	r3,-12(fp)
 90c3280:	e0bfff17 	ldw	r2,-4(fp)
 90c3284:	18800826 	beq	r3,r2,90c32a8 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 90c3288:	e0bffd17 	ldw	r2,-12(fp)
 90c328c:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 90c3290:	e0bffd17 	ldw	r2,-12(fp)
 90c3294:	10800017 	ldw	r2,0(r2)
 90c3298:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 90c329c:	e0bffd17 	ldw	r2,-12(fp)
 90c32a0:	1004c03a 	cmpne	r2,r2,zero
 90c32a4:	103ff51e 	bne	r2,zero,90c327c <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 90c32a8:	e0bffd17 	ldw	r2,-12(fp)
 90c32ac:	1004c03a 	cmpne	r2,r2,zero
 90c32b0:	1000041e 	bne	r2,zero,90c32c4 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 90c32b4:	90aa4780 	call	90aa478 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c32b8:	0009883a 	mov	r4,zero
 90c32bc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return;
 90c32c0:	00000e06 	br	90c32fc <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 90c32c4:	e0bffe17 	ldw	r2,-8(fp)
 90c32c8:	1005003a 	cmpeq	r2,r2,zero
 90c32cc:	1000041e 	bne	r2,zero,90c32e0 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 90c32d0:	e0bffd17 	ldw	r2,-12(fp)
 90c32d4:	10800017 	ldw	r2,0(r2)
 90c32d8:	e0bffe15 	stw	r2,-8(fp)
 90c32dc:	00000306 	br	90c32ec <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 90c32e0:	e0bffd17 	ldw	r2,-12(fp)
 90c32e4:	10800017 	ldw	r2,0(r2)
 90c32e8:	d0a0d015 	stw	r2,-31936(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 90c32ec:	e13ffd17 	ldw	r4,-12(fp)
 90c32f0:	90aaff00 	call	90aaff0 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c32f4:	0009883a 	mov	r4,zero
 90c32f8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
}
 90c32fc:	e037883a 	mov	sp,fp
 90c3300:	dfc00117 	ldw	ra,4(sp)
 90c3304:	df000017 	ldw	fp,0(sp)
 90c3308:	dec00204 	addi	sp,sp,8
 90c330c:	f800283a 	ret

090c3310 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 90c3310:	defff604 	addi	sp,sp,-40
 90c3314:	dfc00915 	stw	ra,36(sp)
 90c3318:	df000815 	stw	fp,32(sp)
 90c331c:	df000804 	addi	fp,sp,32
 90c3320:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 90c3324:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 90c3328:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 90c332c:	e0bfff17 	ldw	r2,-4(fp)
 90c3330:	10800317 	ldw	r2,12(r2)
 90c3334:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 90c3338:	d0a0d017 	ldw	r2,-31936(gp)
 90c333c:	e0bffd15 	stw	r2,-12(fp)
 90c3340:	00004d06 	br	90c3478 <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 90c3344:	e0bffd17 	ldw	r2,-12(fp)
 90c3348:	10800017 	ldw	r2,0(r2)
 90c334c:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 90c3350:	e0bffd17 	ldw	r2,-12(fp)
 90c3354:	10800503 	ldbu	r2,20(r2)
 90c3358:	10803fcc 	andi	r2,r2,255
 90c335c:	1005003a 	cmpeq	r2,r2,zero
 90c3360:	1000071e 	bne	r2,zero,90c3380 <ip_raw_input+0x70>
 90c3364:	e0bffd17 	ldw	r2,-12(fp)
 90c3368:	10c00503 	ldbu	r3,20(r2)
 90c336c:	e0bffe17 	ldw	r2,-8(fp)
 90c3370:	10800243 	ldbu	r2,9(r2)
 90c3374:	18c03fcc 	andi	r3,r3,255
 90c3378:	10803fcc 	andi	r2,r2,255
 90c337c:	18803c1e 	bne	r3,r2,90c3470 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 90c3380:	e0bffd17 	ldw	r2,-12(fp)
 90c3384:	10800117 	ldw	r2,4(r2)
 90c3388:	1005003a 	cmpeq	r2,r2,zero
 90c338c:	1000051e 	bne	r2,zero,90c33a4 <ip_raw_input+0x94>
 90c3390:	e0bffd17 	ldw	r2,-12(fp)
 90c3394:	10c00117 	ldw	r3,4(r2)
 90c3398:	e0bffe17 	ldw	r2,-8(fp)
 90c339c:	10800417 	ldw	r2,16(r2)
 90c33a0:	1880331e 	bne	r3,r2,90c3470 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 90c33a4:	e0bffd17 	ldw	r2,-12(fp)
 90c33a8:	10800217 	ldw	r2,8(r2)
 90c33ac:	1005003a 	cmpeq	r2,r2,zero
 90c33b0:	1000051e 	bne	r2,zero,90c33c8 <ip_raw_input+0xb8>
 90c33b4:	e0bffd17 	ldw	r2,-12(fp)
 90c33b8:	10c00217 	ldw	r3,8(r2)
 90c33bc:	e0bffe17 	ldw	r2,-8(fp)
 90c33c0:	10800317 	ldw	r2,12(r2)
 90c33c4:	18802a1e 	bne	r3,r2,90c3470 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 90c33c8:	e0bffd17 	ldw	r2,-12(fp)
 90c33cc:	10800317 	ldw	r2,12(r2)
 90c33d0:	1005003a 	cmpeq	r2,r2,zero
 90c33d4:	1000261e 	bne	r2,zero,90c3470 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c33d8:	e0bffb17 	ldw	r2,-20(fp)
 90c33dc:	1005003a 	cmpeq	r2,r2,zero
 90c33e0:	1000211e 	bne	r2,zero,90c3468 <ip_raw_input+0x158>
 90c33e4:	e0bffb17 	ldw	r2,-20(fp)
 90c33e8:	10800317 	ldw	r2,12(r2)
 90c33ec:	1005003a 	cmpeq	r2,r2,zero
 90c33f0:	10001d1e 	bne	r2,zero,90c3468 <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 90c33f4:	e13fff17 	ldw	r4,-4(fp)
 90c33f8:	90c00180 	call	90c0018 <ip_copypkt>
 90c33fc:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 90c3400:	e0bff817 	ldw	r2,-32(fp)
 90c3404:	1005003a 	cmpeq	r2,r2,zero
 90c3408:	1000171e 	bne	r2,zero,90c3468 <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 90c340c:	0009883a 	mov	r4,zero
 90c3410:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 90c3414:	e0bffb17 	ldw	r2,-20(fp)
 90c3418:	10c00317 	ldw	r3,12(r2)
 90c341c:	e0bffb17 	ldw	r2,-20(fp)
 90c3420:	11400417 	ldw	r5,16(r2)
 90c3424:	e13ff817 	ldw	r4,-32(fp)
 90c3428:	183ee83a 	callr	r3
 90c342c:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 90c3430:	0009883a 	mov	r4,zero
 90c3434:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
               if (err)
 90c3438:	e0bffa17 	ldw	r2,-24(fp)
 90c343c:	1005003a 	cmpeq	r2,r2,zero
 90c3440:	1000071e 	bne	r2,zero,90c3460 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 90c3444:	01000084 	movi	r4,2
 90c3448:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 90c344c:	e13ff817 	ldw	r4,-32(fp)
 90c3450:	90a9bc80 	call	90a9bc8 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c3454:	01000084 	movi	r4,2
 90c3458:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
 90c345c:	00000206 	br	90c3468 <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 90c3460:	00800044 	movi	r2,1
 90c3464:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 90c3468:	e0bffd17 	ldw	r2,-12(fp)
 90c346c:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 90c3470:	e0bffc17 	ldw	r2,-16(fp)
 90c3474:	e0bffd15 	stw	r2,-12(fp)
 90c3478:	e0bffd17 	ldw	r2,-12(fp)
 90c347c:	1004c03a 	cmpne	r2,r2,zero
 90c3480:	103fb01e 	bne	r2,zero,90c3344 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c3484:	e0bffb17 	ldw	r2,-20(fp)
 90c3488:	1005003a 	cmpeq	r2,r2,zero
 90c348c:	1000151e 	bne	r2,zero,90c34e4 <ip_raw_input+0x1d4>
 90c3490:	e0bffb17 	ldw	r2,-20(fp)
 90c3494:	10800317 	ldw	r2,12(r2)
 90c3498:	1005003a 	cmpeq	r2,r2,zero
 90c349c:	1000111e 	bne	r2,zero,90c34e4 <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 90c34a0:	0009883a 	mov	r4,zero
 90c34a4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 90c34a8:	e0bffb17 	ldw	r2,-20(fp)
 90c34ac:	10c00317 	ldw	r3,12(r2)
 90c34b0:	e0bffb17 	ldw	r2,-20(fp)
 90c34b4:	11400417 	ldw	r5,16(r2)
 90c34b8:	e13fff17 	ldw	r4,-4(fp)
 90c34bc:	183ee83a 	callr	r3
 90c34c0:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 90c34c4:	0009883a 	mov	r4,zero
 90c34c8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      if (err == 0)
 90c34cc:	e0bffa17 	ldw	r2,-24(fp)
 90c34d0:	1004c03a 	cmpne	r2,r2,zero
 90c34d4:	10000c1e 	bne	r2,zero,90c3508 <ip_raw_input+0x1f8>
         delivered = 1;
 90c34d8:	00800044 	movi	r2,1
 90c34dc:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 90c34e0:	00000906 	br	90c3508 <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 90c34e4:	00bffd84 	movi	r2,-10
 90c34e8:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 90c34ec:	008243b4 	movhi	r2,2318
 90c34f0:	10b82c04 	addi	r2,r2,-8016
 90c34f4:	10800617 	ldw	r2,24(r2)
 90c34f8:	10c00044 	addi	r3,r2,1
 90c34fc:	008243b4 	movhi	r2,2318
 90c3500:	10b82c04 	addi	r2,r2,-8016
 90c3504:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 90c3508:	e0bff917 	ldw	r2,-28(fp)
 90c350c:	1004c03a 	cmpne	r2,r2,zero
 90c3510:	1000071e 	bne	r2,zero,90c3530 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 90c3514:	008243b4 	movhi	r2,2318
 90c3518:	10b82c04 	addi	r2,r2,-8016
 90c351c:	10800817 	ldw	r2,32(r2)
 90c3520:	10ffffc4 	addi	r3,r2,-1
 90c3524:	008243b4 	movhi	r2,2318
 90c3528:	10b82c04 	addi	r2,r2,-8016
 90c352c:	10c00815 	stw	r3,32(r2)

   return err;
 90c3530:	e0bffa17 	ldw	r2,-24(fp)
}
 90c3534:	e037883a 	mov	sp,fp
 90c3538:	dfc00117 	ldw	ra,4(sp)
 90c353c:	df000017 	ldw	fp,0(sp)
 90c3540:	dec00204 	addi	sp,sp,8
 90c3544:	f800283a 	ret

090c3548 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 90c3548:	defffa04 	addi	sp,sp,-24
 90c354c:	dfc00515 	stw	ra,20(sp)
 90c3550:	df000415 	stw	fp,16(sp)
 90c3554:	df000404 	addi	fp,sp,16
 90c3558:	e13ffe15 	stw	r4,-8(fp)
 90c355c:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 90c3560:	e0bffe17 	ldw	r2,-8(fp)
 90c3564:	10c00044 	addi	r3,r2,1
 90c3568:	00bfff84 	movi	r2,-2
 90c356c:	1884703a 	and	r2,r3,r2
 90c3570:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 90c3574:	e0bfff17 	ldw	r2,-4(fp)
 90c3578:	1004c03a 	cmpne	r2,r2,zero
 90c357c:	1000031e 	bne	r2,zero,90c358c <ip_raw_alloc+0x44>
      len += IPHSIZ;
 90c3580:	e0bffd17 	ldw	r2,-12(fp)
 90c3584:	10800504 	addi	r2,r2,20
 90c3588:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c358c:	01000084 	movi	r4,2
 90c3590:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 90c3594:	00824374 	movhi	r2,2317
 90c3598:	108f0704 	addi	r2,r2,15388
 90c359c:	10c00017 	ldw	r3,0(r2)
 90c35a0:	e0bffd17 	ldw	r2,-12(fp)
 90c35a4:	1885883a 	add	r2,r3,r2
 90c35a8:	1009883a 	mov	r4,r2
 90c35ac:	90a98340 	call	90a9834 <pk_alloc>
 90c35b0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c35b4:	01000084 	movi	r4,2
 90c35b8:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   if (p)
 90c35bc:	e0bffc17 	ldw	r2,-16(fp)
 90c35c0:	1005003a 	cmpeq	r2,r2,zero
 90c35c4:	10000d1e 	bne	r2,zero,90c35fc <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 90c35c8:	e0bfff17 	ldw	r2,-4(fp)
 90c35cc:	1004c03a 	cmpne	r2,r2,zero
 90c35d0:	10000a1e 	bne	r2,zero,90c35fc <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 90c35d4:	e0bffc17 	ldw	r2,-16(fp)
 90c35d8:	10800317 	ldw	r2,12(r2)
 90c35dc:	10c00504 	addi	r3,r2,20
 90c35e0:	e0bffc17 	ldw	r2,-16(fp)
 90c35e4:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 90c35e8:	e0bffc17 	ldw	r2,-16(fp)
 90c35ec:	10800417 	ldw	r2,16(r2)
 90c35f0:	10fffb04 	addi	r3,r2,-20
 90c35f4:	e0bffc17 	ldw	r2,-16(fp)
 90c35f8:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 90c35fc:	e0bffc17 	ldw	r2,-16(fp)
}
 90c3600:	e037883a 	mov	sp,fp
 90c3604:	dfc00117 	ldw	ra,4(sp)
 90c3608:	df000017 	ldw	fp,0(sp)
 90c360c:	dec00204 	addi	sp,sp,8
 90c3610:	f800283a 	ret

090c3614 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 90c3614:	defffd04 	addi	sp,sp,-12
 90c3618:	dfc00215 	stw	ra,8(sp)
 90c361c:	df000115 	stw	fp,4(sp)
 90c3620:	df000104 	addi	fp,sp,4
 90c3624:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c3628:	01000084 	movi	r4,2
 90c362c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c3630:	e13fff17 	ldw	r4,-4(fp)
 90c3634:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c3638:	01000084 	movi	r4,2
 90c363c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
}
 90c3640:	e037883a 	mov	sp,fp
 90c3644:	dfc00117 	ldw	ra,4(sp)
 90c3648:	df000017 	ldw	fp,0(sp)
 90c364c:	dec00204 	addi	sp,sp,8
 90c3650:	f800283a 	ret

090c3654 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 90c3654:	defffd04 	addi	sp,sp,-12
 90c3658:	df000215 	stw	fp,8(sp)
 90c365c:	df000204 	addi	fp,sp,8
 90c3660:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 90c3664:	00824374 	movhi	r2,2317
 90c3668:	108ebc04 	addi	r2,r2,15088
 90c366c:	10c00017 	ldw	r3,0(r2)
 90c3670:	00824374 	movhi	r2,2317
 90c3674:	108f0704 	addi	r2,r2,15388
 90c3678:	10800017 	ldw	r2,0(r2)
 90c367c:	1885c83a 	sub	r2,r3,r2
 90c3680:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 90c3684:	e0bfff17 	ldw	r2,-4(fp)
 90c3688:	1004c03a 	cmpne	r2,r2,zero
 90c368c:	1000031e 	bne	r2,zero,90c369c <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 90c3690:	e0bffe17 	ldw	r2,-8(fp)
 90c3694:	10bffb04 	addi	r2,r2,-20
 90c3698:	e0bffe15 	stw	r2,-8(fp)
   return len;
 90c369c:	e0bffe17 	ldw	r2,-8(fp)
}
 90c36a0:	e037883a 	mov	sp,fp
 90c36a4:	df000017 	ldw	fp,0(sp)
 90c36a8:	dec00104 	addi	sp,sp,4
 90c36ac:	f800283a 	ret

090c36b0 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 90c36b0:	defff804 	addi	sp,sp,-32
 90c36b4:	df000715 	stw	fp,28(sp)
 90c36b8:	df000704 	addi	fp,sp,28
 90c36bc:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 90c36c0:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 90c36c4:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c36c8:	00824374 	movhi	r2,2317
 90c36cc:	108f4c04 	addi	r2,r2,15664
 90c36d0:	10800017 	ldw	r2,0(r2)
 90c36d4:	e0bffe15 	stw	r2,-8(fp)
 90c36d8:	00003e06 	br	90c37d4 <rt_lookup+0x124>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 90c36dc:	e0bffe17 	ldw	r2,-8(fp)
 90c36e0:	10800617 	ldw	r2,24(r2)
 90c36e4:	1005003a 	cmpeq	r2,r2,zero
 90c36e8:	1000371e 	bne	r2,zero,90c37c8 <rt_lookup+0x118>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 90c36ec:	e0bffe17 	ldw	r2,-8(fp)
 90c36f0:	10800a17 	ldw	r2,40(r2)
 90c36f4:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 90c36f8:	e0bffe17 	ldw	r2,-8(fp)
 90c36fc:	10c00017 	ldw	r3,0(r2)
 90c3700:	e0bffb17 	ldw	r2,-20(fp)
 90c3704:	1888703a 	and	r4,r3,r2
 90c3708:	e0ffff17 	ldw	r3,-4(fp)
 90c370c:	e0bffb17 	ldw	r2,-20(fp)
 90c3710:	1884703a 	and	r2,r3,r2
 90c3714:	20802c1e 	bne	r4,r2,90c37c8 <rt_lookup+0x118>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 90c3718:	e03ffc05 	stb	zero,-16(fp)
 90c371c:	00a00034 	movhi	r2,32768
 90c3720:	e0bffa15 	stw	r2,-24(fp)
 90c3724:	00001b06 	br	90c3794 <rt_lookup+0xe4>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 90c3728:	e0bffb17 	ldw	r2,-20(fp)
 90c372c:	1004d63a 	srli	r2,r2,24
 90c3730:	10c03fcc 	andi	r3,r2,255
 90c3734:	e0bffb17 	ldw	r2,-20(fp)
 90c3738:	1004d23a 	srli	r2,r2,8
 90c373c:	10bfc00c 	andi	r2,r2,65280
 90c3740:	1886b03a 	or	r3,r3,r2
 90c3744:	e0bffb17 	ldw	r2,-20(fp)
 90c3748:	10bfc00c 	andi	r2,r2,65280
 90c374c:	1004923a 	slli	r2,r2,8
 90c3750:	1886b03a 	or	r3,r3,r2
 90c3754:	e0bffb17 	ldw	r2,-20(fp)
 90c3758:	10803fcc 	andi	r2,r2,255
 90c375c:	1004963a 	slli	r2,r2,24
 90c3760:	1886b03a 	or	r3,r3,r2
 90c3764:	e0bffa17 	ldw	r2,-24(fp)
 90c3768:	1884703a 	and	r2,r3,r2
 90c376c:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 90c3770:	e0bff917 	ldw	r2,-28(fp)
 90c3774:	1005003a 	cmpeq	r2,r2,zero
 90c3778:	1000031e 	bne	r2,zero,90c3788 <rt_lookup+0xd8>
 90c377c:	e0bffc03 	ldbu	r2,-16(fp)
 90c3780:	10800044 	addi	r2,r2,1
 90c3784:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 90c3788:	e0bffa17 	ldw	r2,-24(fp)
 90c378c:	1004d07a 	srli	r2,r2,1
 90c3790:	e0bffa15 	stw	r2,-24(fp)
 90c3794:	e0bffa17 	ldw	r2,-24(fp)
 90c3798:	1004c03a 	cmpne	r2,r2,zero
 90c379c:	103fe21e 	bne	r2,zero,90c3728 <rt_lookup+0x78>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 90c37a0:	e0fffc03 	ldbu	r3,-16(fp)
 90c37a4:	e0bffc43 	ldbu	r2,-15(fp)
 90c37a8:	10c0072e 	bgeu	r2,r3,90c37c8 <rt_lookup+0x118>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 90c37ac:	e0bffc03 	ldbu	r2,-16(fp)
 90c37b0:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 90c37b4:	e0bffe17 	ldw	r2,-8(fp)
 90c37b8:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 90c37bc:	e0bffc43 	ldbu	r2,-15(fp)
 90c37c0:	10800820 	cmpeqi	r2,r2,32
 90c37c4:	10000e1e 	bne	r2,zero,90c3800 <rt_lookup+0x150>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c37c8:	e0bffe17 	ldw	r2,-8(fp)
 90c37cc:	10800f04 	addi	r2,r2,60
 90c37d0:	e0bffe15 	stw	r2,-8(fp)
 90c37d4:	00824374 	movhi	r2,2317
 90c37d8:	108ed604 	addi	r2,r2,15192
 90c37dc:	10800017 	ldw	r2,0(r2)
 90c37e0:	10800f24 	muli	r2,r2,60
 90c37e4:	1007883a 	mov	r3,r2
 90c37e8:	00824374 	movhi	r2,2317
 90c37ec:	108f4c04 	addi	r2,r2,15664
 90c37f0:	10800017 	ldw	r2,0(r2)
 90c37f4:	1887883a 	add	r3,r3,r2
 90c37f8:	e0bffe17 	ldw	r2,-8(fp)
 90c37fc:	10ffb736 	bltu	r2,r3,90c36dc <rt_lookup+0x2c>
               break;
         }
      }
   }

   if (netmatch)
 90c3800:	e0bffd17 	ldw	r2,-12(fp)
 90c3804:	1005003a 	cmpeq	r2,r2,zero
 90c3808:	1000051e 	bne	r2,zero,90c3820 <rt_lookup+0x170>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 90c380c:	00824374 	movhi	r2,2317
 90c3810:	108f2e04 	addi	r2,r2,15544
 90c3814:	10c00017 	ldw	r3,0(r2)
 90c3818:	e0bffd17 	ldw	r2,-12(fp)
 90c381c:	10c00915 	stw	r3,36(r2)

   return netmatch;
 90c3820:	e0bffd17 	ldw	r2,-12(fp)
}
 90c3824:	e037883a 	mov	sp,fp
 90c3828:	df000017 	ldw	fp,0(sp)
 90c382c:	dec00104 	addi	sp,sp,4
 90c3830:	f800283a 	ret

090c3834 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 90c3834:	defff604 	addi	sp,sp,-40
 90c3838:	dfc00915 	stw	ra,36(sp)
 90c383c:	df000815 	stw	fp,32(sp)
 90c3840:	df000804 	addi	fp,sp,32
 90c3844:	e13ffb15 	stw	r4,-20(fp)
 90c3848:	e17ffc15 	stw	r5,-16(fp)
 90c384c:	e1bffd15 	stw	r6,-12(fp)
 90c3850:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 90c3854:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 90c3858:	e13ffe17 	ldw	r4,-8(fp)
 90c385c:	90bdc0c0 	call	90bdc0c <if_getbynum>
 90c3860:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 90c3864:	e0bff817 	ldw	r2,-32(fp)
 90c3868:	1004c03a 	cmpne	r2,r2,zero
 90c386c:	1000021e 	bne	r2,zero,90c3878 <add_route+0x44>
      return NULL;
 90c3870:	e03fff15 	stw	zero,-4(fp)
 90c3874:	0000f306 	br	90c3c44 <add_route+0x410>

   if (rt_mib == NULL)
 90c3878:	00824374 	movhi	r2,2317
 90c387c:	108f4c04 	addi	r2,r2,15664
 90c3880:	10800017 	ldw	r2,0(r2)
 90c3884:	1004c03a 	cmpne	r2,r2,zero
 90c3888:	1000021e 	bne	r2,zero,90c3894 <add_route+0x60>
      return NULL;
 90c388c:	e03fff15 	stw	zero,-4(fp)
 90c3890:	0000ec06 	br	90c3c44 <add_route+0x410>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 90c3894:	e0bffb17 	ldw	r2,-20(fp)
 90c3898:	1005003a 	cmpeq	r2,r2,zero
 90c389c:	1000031e 	bne	r2,zero,90c38ac <add_route+0x78>
 90c38a0:	e0bffc17 	ldw	r2,-16(fp)
 90c38a4:	1004c03a 	cmpne	r2,r2,zero
 90c38a8:	1000241e 	bne	r2,zero,90c393c <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 90c38ac:	90aa4780 	call	90aa478 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 90c38b0:	e0bffb17 	ldw	r2,-20(fp)
 90c38b4:	1004d63a 	srli	r2,r2,24
 90c38b8:	10c03fcc 	andi	r3,r2,255
 90c38bc:	e0bffb17 	ldw	r2,-20(fp)
 90c38c0:	1004d23a 	srli	r2,r2,8
 90c38c4:	10bfc00c 	andi	r2,r2,65280
 90c38c8:	1886b03a 	or	r3,r3,r2
 90c38cc:	e0bffb17 	ldw	r2,-20(fp)
 90c38d0:	10bfc00c 	andi	r2,r2,65280
 90c38d4:	1004923a 	slli	r2,r2,8
 90c38d8:	1886b03a 	or	r3,r3,r2
 90c38dc:	e0bffb17 	ldw	r2,-20(fp)
 90c38e0:	10803fcc 	andi	r2,r2,255
 90c38e4:	1004963a 	slli	r2,r2,24
 90c38e8:	188ab03a 	or	r5,r3,r2
 90c38ec:	e0bffc17 	ldw	r2,-16(fp)
 90c38f0:	1004d63a 	srli	r2,r2,24
 90c38f4:	10c03fcc 	andi	r3,r2,255
 90c38f8:	e0bffc17 	ldw	r2,-16(fp)
 90c38fc:	1004d23a 	srli	r2,r2,8
 90c3900:	10bfc00c 	andi	r2,r2,65280
 90c3904:	1886b03a 	or	r3,r3,r2
 90c3908:	e0bffc17 	ldw	r2,-16(fp)
 90c390c:	10bfc00c 	andi	r2,r2,65280
 90c3910:	1004923a 	slli	r2,r2,8
 90c3914:	1886b03a 	or	r3,r3,r2
 90c3918:	e0bffc17 	ldw	r2,-16(fp)
 90c391c:	10803fcc 	andi	r2,r2,255
 90c3920:	1004963a 	slli	r2,r2,24
 90c3924:	188cb03a 	or	r6,r3,r2
 90c3928:	01024374 	movhi	r4,2317
 90c392c:	21045204 	addi	r4,r4,4424
 90c3930:	90833900 	call	9083390 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 90c3934:	e03fff15 	stw	zero,-4(fp)
 90c3938:	0000c206 	br	90c3c44 <add_route+0x410>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c393c:	00824374 	movhi	r2,2317
 90c3940:	108f4c04 	addi	r2,r2,15664
 90c3944:	10800017 	ldw	r2,0(r2)
 90c3948:	e0bffa15 	stw	r2,-24(fp)
 90c394c:	00006f06 	br	90c3b0c <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 90c3950:	e0bffa17 	ldw	r2,-24(fp)
 90c3954:	10c00017 	ldw	r3,0(r2)
 90c3958:	e0bffb17 	ldw	r2,-20(fp)
 90c395c:	1880181e 	bne	r3,r2,90c39c0 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 90c3960:	e0fffa17 	ldw	r3,-24(fp)
 90c3964:	e0bffd17 	ldw	r2,-12(fp)
 90c3968:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 90c396c:	00824374 	movhi	r2,2317
 90c3970:	108f2e04 	addi	r2,r2,15544
 90c3974:	10c00017 	ldw	r3,0(r2)
 90c3978:	e0bffa17 	ldw	r2,-24(fp)
 90c397c:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 90c3980:	e0bffe17 	ldw	r2,-8(fp)
 90c3984:	10c00044 	addi	r3,r2,1
 90c3988:	e0bffa17 	ldw	r2,-24(fp)
 90c398c:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 90c3990:	e0fffa17 	ldw	r3,-24(fp)
 90c3994:	e0800217 	ldw	r2,8(fp)
 90c3998:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 90c399c:	e0fffa17 	ldw	r3,-24(fp)
 90c39a0:	e0bffc17 	ldw	r2,-16(fp)
 90c39a4:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 90c39a8:	e0fffa17 	ldw	r3,-24(fp)
 90c39ac:	e0bff817 	ldw	r2,-32(fp)
 90c39b0:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 90c39b4:	e0bffa17 	ldw	r2,-24(fp)
 90c39b8:	e0bfff15 	stw	r2,-4(fp)
 90c39bc:	0000a106 	br	90c3c44 <add_route+0x410>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 90c39c0:	e0bff917 	ldw	r2,-28(fp)
 90c39c4:	1005003a 	cmpeq	r2,r2,zero
 90c39c8:	1000041e 	bne	r2,zero,90c39dc <add_route+0x1a8>
 90c39cc:	e0bff917 	ldw	r2,-28(fp)
 90c39d0:	10800817 	ldw	r2,32(r2)
 90c39d4:	1005003a 	cmpeq	r2,r2,zero
 90c39d8:	1000491e 	bne	r2,zero,90c3b00 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 90c39dc:	e0bffa17 	ldw	r2,-24(fp)
 90c39e0:	10800617 	ldw	r2,24(r2)
 90c39e4:	1004c03a 	cmpne	r2,r2,zero
 90c39e8:	1000051e 	bne	r2,zero,90c3a00 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 90c39ec:	e0bffa17 	ldw	r2,-24(fp)
 90c39f0:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 90c39f4:	e0bff917 	ldw	r2,-28(fp)
 90c39f8:	10000815 	stw	zero,32(r2)
            continue;
 90c39fc:	00004006 	br	90c3b00 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 90c3a00:	e0c00217 	ldw	r3,8(fp)
 90c3a04:	00824374 	movhi	r2,2317
 90c3a08:	108e2704 	addi	r2,r2,14492
 90c3a0c:	10c5883a 	add	r2,r2,r3
 90c3a10:	11000003 	ldbu	r4,0(r2)
 90c3a14:	e0bffa17 	ldw	r2,-24(fp)
 90c3a18:	10c00817 	ldw	r3,32(r2)
 90c3a1c:	00824374 	movhi	r2,2317
 90c3a20:	108e2704 	addi	r2,r2,14492
 90c3a24:	10c5883a 	add	r2,r2,r3
 90c3a28:	10800003 	ldbu	r2,0(r2)
 90c3a2c:	20c03fcc 	andi	r3,r4,255
 90c3a30:	10803fcc 	andi	r2,r2,255
 90c3a34:	18803236 	bltu	r3,r2,90c3b00 <add_route+0x2cc>
         {
            if (!newrt)
 90c3a38:	e0bff917 	ldw	r2,-28(fp)
 90c3a3c:	1004c03a 	cmpne	r2,r2,zero
 90c3a40:	1000031e 	bne	r2,zero,90c3a50 <add_route+0x21c>
            {
               newrt = rtp;
 90c3a44:	e0bffa17 	ldw	r2,-24(fp)
 90c3a48:	e0bff915 	stw	r2,-28(fp)
               continue;
 90c3a4c:	00002c06 	br	90c3b00 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 90c3a50:	e0bffa17 	ldw	r2,-24(fp)
 90c3a54:	10c00817 	ldw	r3,32(r2)
 90c3a58:	00824374 	movhi	r2,2317
 90c3a5c:	108e2704 	addi	r2,r2,14492
 90c3a60:	10c5883a 	add	r2,r2,r3
 90c3a64:	11000003 	ldbu	r4,0(r2)
 90c3a68:	e0bff917 	ldw	r2,-28(fp)
 90c3a6c:	10c00817 	ldw	r3,32(r2)
 90c3a70:	00824374 	movhi	r2,2317
 90c3a74:	108e2704 	addi	r2,r2,14492
 90c3a78:	10c5883a 	add	r2,r2,r3
 90c3a7c:	10800003 	ldbu	r2,0(r2)
 90c3a80:	20c03fcc 	andi	r3,r4,255
 90c3a84:	10803fcc 	andi	r2,r2,255
 90c3a88:	1880032e 	bgeu	r3,r2,90c3a98 <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 90c3a8c:	e0bffa17 	ldw	r2,-24(fp)
 90c3a90:	e0bff915 	stw	r2,-28(fp)
 90c3a94:	00001a06 	br	90c3b00 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 90c3a98:	e0bffa17 	ldw	r2,-24(fp)
 90c3a9c:	10c00817 	ldw	r3,32(r2)
 90c3aa0:	00824374 	movhi	r2,2317
 90c3aa4:	108e2704 	addi	r2,r2,14492
 90c3aa8:	10c5883a 	add	r2,r2,r3
 90c3aac:	11000003 	ldbu	r4,0(r2)
 90c3ab0:	e0bff917 	ldw	r2,-28(fp)
 90c3ab4:	10c00817 	ldw	r3,32(r2)
 90c3ab8:	00824374 	movhi	r2,2317
 90c3abc:	108e2704 	addi	r2,r2,14492
 90c3ac0:	10c5883a 	add	r2,r2,r3
 90c3ac4:	10800003 	ldbu	r2,0(r2)
 90c3ac8:	20c03fcc 	andi	r3,r4,255
 90c3acc:	10803fcc 	andi	r2,r2,255
 90c3ad0:	18800b1e 	bne	r3,r2,90c3b00 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 90c3ad4:	e0bffa17 	ldw	r2,-24(fp)
 90c3ad8:	11000917 	ldw	r4,36(r2)
 90c3adc:	e0bff917 	ldw	r2,-28(fp)
 90c3ae0:	11400917 	ldw	r5,36(r2)
 90c3ae4:	90a2a740 	call	90a2a74 <c_older>
 90c3ae8:	1007883a 	mov	r3,r2
 90c3aec:	e0bffa17 	ldw	r2,-24(fp)
 90c3af0:	10800917 	ldw	r2,36(r2)
 90c3af4:	1880021e 	bne	r3,r2,90c3b00 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 90c3af8:	e0bffa17 	ldw	r2,-24(fp)
 90c3afc:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c3b00:	e0bffa17 	ldw	r2,-24(fp)
 90c3b04:	10800f04 	addi	r2,r2,60
 90c3b08:	e0bffa15 	stw	r2,-24(fp)
 90c3b0c:	00824374 	movhi	r2,2317
 90c3b10:	108ed604 	addi	r2,r2,15192
 90c3b14:	10800017 	ldw	r2,0(r2)
 90c3b18:	10800f24 	muli	r2,r2,60
 90c3b1c:	1007883a 	mov	r3,r2
 90c3b20:	00824374 	movhi	r2,2317
 90c3b24:	108f4c04 	addi	r2,r2,15664
 90c3b28:	10800017 	ldw	r2,0(r2)
 90c3b2c:	1887883a 	add	r3,r3,r2
 90c3b30:	e0bffa17 	ldw	r2,-24(fp)
 90c3b34:	10ff8636 	bltu	r2,r3,90c3950 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 90c3b38:	e0bff917 	ldw	r2,-28(fp)
 90c3b3c:	1005003a 	cmpeq	r2,r2,zero
 90c3b40:	10002a1e 	bne	r2,zero,90c3bec <add_route+0x3b8>
      rtp = newrt;   /* create new entry in lowest priority slot */
 90c3b44:	e0bff917 	ldw	r2,-28(fp)
 90c3b48:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 90c3b4c:	e0fffa17 	ldw	r3,-24(fp)
 90c3b50:	e0bff817 	ldw	r2,-32(fp)
 90c3b54:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 90c3b58:	e0fffa17 	ldw	r3,-24(fp)
 90c3b5c:	e0bffb17 	ldw	r2,-20(fp)
 90c3b60:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 90c3b64:	e13ff817 	ldw	r4,-32(fp)
 90c3b68:	90a31080 	call	90a3108 <if_netnumber>
 90c3b6c:	10c00044 	addi	r3,r2,1
 90c3b70:	e0bffa17 	ldw	r2,-24(fp)
 90c3b74:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 90c3b78:	008243b4 	movhi	r2,2318
 90c3b7c:	10b82c04 	addi	r2,r2,-8016
 90c3b80:	10800117 	ldw	r2,4(r2)
 90c3b84:	1007883a 	mov	r3,r2
 90c3b88:	e0bffa17 	ldw	r2,-24(fp)
 90c3b8c:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 90c3b90:	e0fffa17 	ldw	r3,-24(fp)
 90c3b94:	00bfffc4 	movi	r2,-1
 90c3b98:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 90c3b9c:	e0fffa17 	ldw	r3,-24(fp)
 90c3ba0:	00bfffc4 	movi	r2,-1
 90c3ba4:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 90c3ba8:	e0fffa17 	ldw	r3,-24(fp)
 90c3bac:	00bfffc4 	movi	r2,-1
 90c3bb0:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 90c3bb4:	e0fffa17 	ldw	r3,-24(fp)
 90c3bb8:	e0bffd17 	ldw	r2,-12(fp)
 90c3bbc:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 90c3bc0:	e0fffa17 	ldw	r3,-24(fp)
 90c3bc4:	e0800217 	ldw	r2,8(fp)
 90c3bc8:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 90c3bcc:	e0fffb17 	ldw	r3,-20(fp)
 90c3bd0:	e0bffc17 	ldw	r2,-16(fp)
 90c3bd4:	1888703a 	and	r4,r3,r2
 90c3bd8:	e0fffd17 	ldw	r3,-12(fp)
 90c3bdc:	e0bffc17 	ldw	r2,-16(fp)
 90c3be0:	1884703a 	and	r2,r3,r2
 90c3be4:	20800326 	beq	r4,r2,90c3bf4 <add_route+0x3c0>
 90c3be8:	00000606 	br	90c3c04 <add_route+0x3d0>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 90c3bec:	e03fff15 	stw	zero,-4(fp)
 90c3bf0:	00001406 	br	90c3c44 <add_route+0x410>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 90c3bf4:	e0fffa17 	ldw	r3,-24(fp)
 90c3bf8:	008000c4 	movi	r2,3
 90c3bfc:	18800715 	stw	r2,28(r3)
 90c3c00:	00000306 	br	90c3c10 <add_route+0x3dc>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 90c3c04:	e0fffa17 	ldw	r3,-24(fp)
 90c3c08:	00800104 	movi	r2,4
 90c3c0c:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 90c3c10:	00824374 	movhi	r2,2317
 90c3c14:	108f2e04 	addi	r2,r2,15544
 90c3c18:	10c00017 	ldw	r3,0(r2)
 90c3c1c:	e0bffa17 	ldw	r2,-24(fp)
 90c3c20:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 90c3c24:	e0fffa17 	ldw	r3,-24(fp)
 90c3c28:	e0bffc17 	ldw	r2,-16(fp)
 90c3c2c:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 90c3c30:	e0fffa17 	ldw	r3,-24(fp)
 90c3c34:	00bfffc4 	movi	r2,-1
 90c3c38:	18800b15 	stw	r2,44(r3)
   return(rtp);
 90c3c3c:	e0bffa17 	ldw	r2,-24(fp)
 90c3c40:	e0bfff15 	stw	r2,-4(fp)
 90c3c44:	e0bfff17 	ldw	r2,-4(fp)
}
 90c3c48:	e037883a 	mov	sp,fp
 90c3c4c:	dfc00117 	ldw	ra,4(sp)
 90c3c50:	df000017 	ldw	fp,0(sp)
 90c3c54:	dec00204 	addi	sp,sp,8
 90c3c58:	f800283a 	ret

090c3c5c <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 90c3c5c:	defff704 	addi	sp,sp,-36
 90c3c60:	dfc00815 	stw	ra,32(sp)
 90c3c64:	df000715 	stw	fp,28(sp)
 90c3c68:	df000704 	addi	fp,sp,28
 90c3c6c:	e13ffc15 	stw	r4,-16(fp)
 90c3c70:	e17ffd15 	stw	r5,-12(fp)
 90c3c74:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 90c3c78:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 90c3c7c:	e0bffe17 	ldw	r2,-8(fp)
 90c3c80:	10bfffd8 	cmpnei	r2,r2,-1
 90c3c84:	1000021e 	bne	r2,zero,90c3c90 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 90c3c88:	e03ff915 	stw	zero,-28(fp)
 90c3c8c:	00000306 	br	90c3c9c <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 90c3c90:	e13ffe17 	ldw	r4,-8(fp)
 90c3c94:	90bdc0c0 	call	90bdc0c <if_getbynum>
 90c3c98:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 90c3c9c:	00824374 	movhi	r2,2317
 90c3ca0:	108f4c04 	addi	r2,r2,15664
 90c3ca4:	10800017 	ldw	r2,0(r2)
 90c3ca8:	1004c03a 	cmpne	r2,r2,zero
 90c3cac:	1000021e 	bne	r2,zero,90c3cb8 <del_route+0x5c>
      return 0;
 90c3cb0:	e03fff15 	stw	zero,-4(fp)
 90c3cb4:	00003406 	br	90c3d88 <del_route+0x12c>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c3cb8:	00824374 	movhi	r2,2317
 90c3cbc:	108f4c04 	addi	r2,r2,15664
 90c3cc0:	10800017 	ldw	r2,0(r2)
 90c3cc4:	e0bffb15 	stw	r2,-20(fp)
 90c3cc8:	00002206 	br	90c3d54 <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 90c3ccc:	e0bffb17 	ldw	r2,-20(fp)
 90c3cd0:	10800617 	ldw	r2,24(r2)
 90c3cd4:	1005003a 	cmpeq	r2,r2,zero
 90c3cd8:	10001b1e 	bne	r2,zero,90c3d48 <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 90c3cdc:	e0bff917 	ldw	r2,-28(fp)
 90c3ce0:	1005003a 	cmpeq	r2,r2,zero
 90c3ce4:	1000041e 	bne	r2,zero,90c3cf8 <del_route+0x9c>
 90c3ce8:	e0bffb17 	ldw	r2,-20(fp)
 90c3cec:	10c00e17 	ldw	r3,56(r2)
 90c3cf0:	e0bff917 	ldw	r2,-28(fp)
 90c3cf4:	1880141e 	bne	r3,r2,90c3d48 <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 90c3cf8:	e0bffb17 	ldw	r2,-20(fp)
 90c3cfc:	10c00017 	ldw	r3,0(r2)
 90c3d00:	e0bffd17 	ldw	r2,-12(fp)
 90c3d04:	1888703a 	and	r4,r3,r2
 90c3d08:	e0fffc17 	ldw	r3,-16(fp)
 90c3d0c:	e0bffd17 	ldw	r2,-12(fp)
 90c3d10:	1884703a 	and	r2,r3,r2
 90c3d14:	2080081e 	bne	r4,r2,90c3d38 <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 90c3d18:	e0bffb17 	ldw	r2,-20(fp)
 90c3d1c:	1009883a 	mov	r4,r2
 90c3d20:	01800f04 	movi	r6,60
 90c3d24:	000b883a 	mov	r5,zero
 90c3d28:	90832780 	call	9083278 <memset>
         retval++;
 90c3d2c:	e0bffa17 	ldw	r2,-24(fp)
 90c3d30:	10800044 	addi	r2,r2,1
 90c3d34:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 90c3d38:	d0e0d117 	ldw	r3,-31932(gp)
 90c3d3c:	e0bffb17 	ldw	r2,-20(fp)
 90c3d40:	1880011e 	bne	r3,r2,90c3d48 <del_route+0xec>
         cachedRoute = NULL;
 90c3d44:	d020d115 	stw	zero,-31932(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 90c3d48:	e0bffb17 	ldw	r2,-20(fp)
 90c3d4c:	10800f04 	addi	r2,r2,60
 90c3d50:	e0bffb15 	stw	r2,-20(fp)
 90c3d54:	00824374 	movhi	r2,2317
 90c3d58:	108ed604 	addi	r2,r2,15192
 90c3d5c:	10800017 	ldw	r2,0(r2)
 90c3d60:	10800f24 	muli	r2,r2,60
 90c3d64:	1007883a 	mov	r3,r2
 90c3d68:	00824374 	movhi	r2,2317
 90c3d6c:	108f4c04 	addi	r2,r2,15664
 90c3d70:	10800017 	ldw	r2,0(r2)
 90c3d74:	1887883a 	add	r3,r3,r2
 90c3d78:	e0bffb17 	ldw	r2,-20(fp)
 90c3d7c:	10ffd336 	bltu	r2,r3,90c3ccc <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 90c3d80:	e0bffa17 	ldw	r2,-24(fp)
 90c3d84:	e0bfff15 	stw	r2,-4(fp)
 90c3d88:	e0bfff17 	ldw	r2,-4(fp)
}
 90c3d8c:	e037883a 	mov	sp,fp
 90c3d90:	dfc00117 	ldw	ra,4(sp)
 90c3d94:	df000017 	ldw	fp,0(sp)
 90c3d98:	dec00204 	addi	sp,sp,8
 90c3d9c:	f800283a 	ret

090c3da0 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 90c3da0:	deffec04 	addi	sp,sp,-80
 90c3da4:	dfc01315 	stw	ra,76(sp)
 90c3da8:	df001215 	stw	fp,72(sp)
 90c3dac:	df001204 	addi	fp,sp,72
 90c3db0:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 90c3db4:	e0bffe17 	ldw	r2,-8(fp)
 90c3db8:	10800317 	ldw	r2,12(r2)
 90c3dbc:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 90c3dc0:	e0bffa17 	ldw	r2,-24(fp)
 90c3dc4:	10800003 	ldbu	r2,0(r2)
 90c3dc8:	10803fcc 	andi	r2,r2,255
 90c3dcc:	108003cc 	andi	r2,r2,15
 90c3dd0:	1085883a 	add	r2,r2,r2
 90c3dd4:	1085883a 	add	r2,r2,r2
 90c3dd8:	1007883a 	mov	r3,r2
 90c3ddc:	e0bffa17 	ldw	r2,-24(fp)
 90c3de0:	1885883a 	add	r2,r3,r2
 90c3de4:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 90c3de8:	e0bff917 	ldw	r2,-28(fp)
 90c3dec:	1080010b 	ldhu	r2,4(r2)
 90c3df0:	10bfffcc 	andi	r2,r2,65535
 90c3df4:	1004d23a 	srli	r2,r2,8
 90c3df8:	10bfffcc 	andi	r2,r2,65535
 90c3dfc:	10c03fcc 	andi	r3,r2,255
 90c3e00:	e0bff917 	ldw	r2,-28(fp)
 90c3e04:	1080010b 	ldhu	r2,4(r2)
 90c3e08:	10bfffcc 	andi	r2,r2,65535
 90c3e0c:	1004923a 	slli	r2,r2,8
 90c3e10:	10bfc00c 	andi	r2,r2,65280
 90c3e14:	1884b03a 	or	r2,r3,r2
 90c3e18:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 90c3e1c:	e0bffe17 	ldw	r2,-8(fp)
 90c3e20:	10c00417 	ldw	r3,16(r2)
 90c3e24:	e0bff617 	ldw	r2,-40(fp)
 90c3e28:	18802a2e 	bgeu	r3,r2,90c3ed4 <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c3e2c:	00824374 	movhi	r2,2317
 90c3e30:	108f0904 	addi	r2,r2,15396
 90c3e34:	10800017 	ldw	r2,0(r2)
 90c3e38:	1081000c 	andi	r2,r2,1024
 90c3e3c:	1005003a 	cmpeq	r2,r2,zero
 90c3e40:	1000181e 	bne	r2,zero,90c3ea4 <udpdemux+0x104>
 90c3e44:	00824374 	movhi	r2,2317
 90c3e48:	108f0904 	addi	r2,r2,15396
 90c3e4c:	10800017 	ldw	r2,0(r2)
 90c3e50:	1080400c 	andi	r2,r2,256
 90c3e54:	1005003a 	cmpeq	r2,r2,zero
 90c3e58:	1000121e 	bne	r2,zero,90c3ea4 <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 90c3e5c:	e0bffe17 	ldw	r2,-8(fp)
 90c3e60:	11400417 	ldw	r5,16(r2)
 90c3e64:	e0bff917 	ldw	r2,-28(fp)
 90c3e68:	1080010b 	ldhu	r2,4(r2)
 90c3e6c:	10bfffcc 	andi	r2,r2,65535
 90c3e70:	1004d23a 	srli	r2,r2,8
 90c3e74:	10bfffcc 	andi	r2,r2,65535
 90c3e78:	10c03fcc 	andi	r3,r2,255
 90c3e7c:	e0bff917 	ldw	r2,-28(fp)
 90c3e80:	1080010b 	ldhu	r2,4(r2)
 90c3e84:	10bfffcc 	andi	r2,r2,65535
 90c3e88:	1004923a 	slli	r2,r2,8
 90c3e8c:	10bfc00c 	andi	r2,r2,65280
 90c3e90:	1884b03a 	or	r2,r3,r2
 90c3e94:	11800204 	addi	r6,r2,8
 90c3e98:	01024374 	movhi	r4,2317
 90c3e9c:	21046004 	addi	r4,r4,4480
 90c3ea0:	90833900 	call	9083390 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 90c3ea4:	008243b4 	movhi	r2,2318
 90c3ea8:	10b84604 	addi	r2,r2,-7912
 90c3eac:	10800217 	ldw	r2,8(r2)
 90c3eb0:	10c00044 	addi	r3,r2,1
 90c3eb4:	008243b4 	movhi	r2,2318
 90c3eb8:	10b84604 	addi	r2,r2,-7912
 90c3ebc:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 90c3ec0:	e13ffe17 	ldw	r4,-8(fp)
 90c3ec4:	90c4b9c0 	call	90c4b9c <udp_free>
      return ENP_BAD_HEADER;
 90c3ec8:	00bff804 	movi	r2,-32
 90c3ecc:	e0bfff15 	stw	r2,-4(fp)
 90c3ed0:	0001c306 	br	90c45e0 <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 90c3ed4:	e0bff917 	ldw	r2,-28(fp)
 90c3ed8:	1080018b 	ldhu	r2,6(r2)
 90c3edc:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 90c3ee0:	e0bff78b 	ldhu	r2,-34(fp)
 90c3ee4:	1005003a 	cmpeq	r2,r2,zero
 90c3ee8:	1000631e 	bne	r2,zero,90c4078 <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 90c3eec:	e0bff617 	ldw	r2,-40(fp)
 90c3ef0:	1080004c 	andi	r2,r2,1
 90c3ef4:	10803fcc 	andi	r2,r2,255
 90c3ef8:	1005003a 	cmpeq	r2,r2,zero
 90c3efc:	1000041e 	bne	r2,zero,90c3f10 <udpdemux+0x170>
 90c3f00:	e0bff917 	ldw	r2,-28(fp)
 90c3f04:	e0fff617 	ldw	r3,-40(fp)
 90c3f08:	10c5883a 	add	r2,r2,r3
 90c3f0c:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 90c3f10:	e0bffe17 	ldw	r2,-8(fp)
 90c3f14:	10800717 	ldw	r2,28(r2)
 90c3f18:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 90c3f1c:	e0bffa17 	ldw	r2,-24(fp)
 90c3f20:	10800417 	ldw	r2,16(r2)
 90c3f24:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 90c3f28:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 90c3f2c:	00800444 	movi	r2,17
 90c3f30:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 90c3f34:	e0bff917 	ldw	r2,-28(fp)
 90c3f38:	1080010b 	ldhu	r2,4(r2)
 90c3f3c:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 90c3f40:	e13ffb04 	addi	r4,fp,-20
 90c3f44:	01400184 	movi	r5,6
 90c3f48:	90a4ef40 	call	90a4ef4 <cksum>
 90c3f4c:	1007883a 	mov	r3,r2
 90c3f50:	e0bff917 	ldw	r2,-28(fp)
 90c3f54:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 90c3f58:	e0bff617 	ldw	r2,-40(fp)
 90c3f5c:	10800044 	addi	r2,r2,1
 90c3f60:	100ad07a 	srli	r5,r2,1
 90c3f64:	e13ff917 	ldw	r4,-28(fp)
 90c3f68:	90a4ef40 	call	90a4ef4 <cksum>
 90c3f6c:	0084303a 	nor	r2,zero,r2
 90c3f70:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 90c3f74:	e0bff70b 	ldhu	r2,-36(fp)
 90c3f78:	1004c03a 	cmpne	r2,r2,zero
 90c3f7c:	1000021e 	bne	r2,zero,90c3f88 <udpdemux+0x1e8>
         xsum = 0xffff;
 90c3f80:	00bfffc4 	movi	r2,-1
 90c3f84:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 90c3f88:	e0fff917 	ldw	r3,-28(fp)
 90c3f8c:	e0bff78b 	ldhu	r2,-34(fp)
 90c3f90:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 90c3f94:	e0fff70b 	ldhu	r3,-36(fp)
 90c3f98:	e0bff78b 	ldhu	r2,-34(fp)
 90c3f9c:	18803626 	beq	r3,r2,90c4078 <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c3fa0:	00824374 	movhi	r2,2317
 90c3fa4:	108f0904 	addi	r2,r2,15396
 90c3fa8:	10800017 	ldw	r2,0(r2)
 90c3fac:	1081000c 	andi	r2,r2,1024
 90c3fb0:	1005003a 	cmpeq	r2,r2,zero
 90c3fb4:	1000241e 	bne	r2,zero,90c4048 <udpdemux+0x2a8>
 90c3fb8:	00824374 	movhi	r2,2317
 90c3fbc:	108f0904 	addi	r2,r2,15396
 90c3fc0:	10800017 	ldw	r2,0(r2)
 90c3fc4:	1080400c 	andi	r2,r2,256
 90c3fc8:	1005003a 	cmpeq	r2,r2,zero
 90c3fcc:	10001e1e 	bne	r2,zero,90c4048 <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 90c3fd0:	e17ff78b 	ldhu	r5,-34(fp)
 90c3fd4:	e1bff70b 	ldhu	r6,-36(fp)
 90c3fd8:	e0bffe17 	ldw	r2,-8(fp)
 90c3fdc:	10800717 	ldw	r2,28(r2)
 90c3fe0:	11c03fcc 	andi	r7,r2,255
 90c3fe4:	e0bffe17 	ldw	r2,-8(fp)
 90c3fe8:	10800717 	ldw	r2,28(r2)
 90c3fec:	1004d23a 	srli	r2,r2,8
 90c3ff0:	11003fcc 	andi	r4,r2,255
 90c3ff4:	e0bffe17 	ldw	r2,-8(fp)
 90c3ff8:	10800717 	ldw	r2,28(r2)
 90c3ffc:	1004d43a 	srli	r2,r2,16
 90c4000:	10c03fcc 	andi	r3,r2,255
 90c4004:	e0bffe17 	ldw	r2,-8(fp)
 90c4008:	10800717 	ldw	r2,28(r2)
 90c400c:	1004d63a 	srli	r2,r2,24
 90c4010:	d9000015 	stw	r4,0(sp)
 90c4014:	d8c00115 	stw	r3,4(sp)
 90c4018:	d8800215 	stw	r2,8(sp)
 90c401c:	01024374 	movhi	r4,2317
 90c4020:	21046a04 	addi	r4,r4,4520
 90c4024:	90833900 	call	9083390 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 90c4028:	00824374 	movhi	r2,2317
 90c402c:	108f0904 	addi	r2,r2,15396
 90c4030:	10800017 	ldw	r2,0(r2)
 90c4034:	1080008c 	andi	r2,r2,2
 90c4038:	1005003a 	cmpeq	r2,r2,zero
 90c403c:	1000021e 	bne	r2,zero,90c4048 <udpdemux+0x2a8>
               ip_dump(p);
 90c4040:	e13ffe17 	ldw	r4,-8(fp)
 90c4044:	90bfaf40 	call	90bfaf4 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 90c4048:	008243b4 	movhi	r2,2318
 90c404c:	10b84604 	addi	r2,r2,-7912
 90c4050:	10800217 	ldw	r2,8(r2)
 90c4054:	10c00044 	addi	r3,r2,1
 90c4058:	008243b4 	movhi	r2,2318
 90c405c:	10b84604 	addi	r2,r2,-7912
 90c4060:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 90c4064:	e13ffe17 	ldw	r4,-8(fp)
 90c4068:	90c4b9c0 	call	90c4b9c <udp_free>
         return ENP_BAD_HEADER;
 90c406c:	00bff804 	movi	r2,-32
 90c4070:	e0bfff15 	stw	r2,-4(fp)
 90c4074:	00015a06 	br	90c45e0 <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c4078:	e13ff917 	ldw	r4,-28(fp)
 90c407c:	90c48b00 	call	90c48b0 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 90c4080:	e0bffa17 	ldw	r2,-24(fp)
 90c4084:	10800003 	ldbu	r2,0(r2)
 90c4088:	10803fcc 	andi	r2,r2,255
 90c408c:	108003cc 	andi	r2,r2,15
 90c4090:	1085883a 	add	r2,r2,r2
 90c4094:	1085883a 	add	r2,r2,r2
 90c4098:	10800204 	addi	r2,r2,8
 90c409c:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 90c40a0:	e0bffe17 	ldw	r2,-8(fp)
 90c40a4:	10c00417 	ldw	r3,16(r2)
 90c40a8:	e0bff517 	ldw	r2,-44(fp)
 90c40ac:	1887c83a 	sub	r3,r3,r2
 90c40b0:	e0bffe17 	ldw	r2,-8(fp)
 90c40b4:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 90c40b8:	e0bffe17 	ldw	r2,-8(fp)
 90c40bc:	10c00317 	ldw	r3,12(r2)
 90c40c0:	e0bff517 	ldw	r2,-44(fp)
 90c40c4:	1887883a 	add	r3,r3,r2
 90c40c8:	e0bffe17 	ldw	r2,-8(fp)
 90c40cc:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c40d0:	00824374 	movhi	r2,2317
 90c40d4:	108f0904 	addi	r2,r2,15396
 90c40d8:	10800017 	ldw	r2,0(r2)
 90c40dc:	1081000c 	andi	r2,r2,1024
 90c40e0:	1005003a 	cmpeq	r2,r2,zero
 90c40e4:	1000221e 	bne	r2,zero,90c4170 <udpdemux+0x3d0>
 90c40e8:	00824374 	movhi	r2,2317
 90c40ec:	108f0904 	addi	r2,r2,15396
 90c40f0:	10800017 	ldw	r2,0(r2)
 90c40f4:	1080400c 	andi	r2,r2,256
 90c40f8:	1005003a 	cmpeq	r2,r2,zero
 90c40fc:	10001c1e 	bne	r2,zero,90c4170 <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 90c4100:	e0bffe17 	ldw	r2,-8(fp)
 90c4104:	10800717 	ldw	r2,28(r2)
 90c4108:	11803fcc 	andi	r6,r2,255
 90c410c:	e0bffe17 	ldw	r2,-8(fp)
 90c4110:	10800717 	ldw	r2,28(r2)
 90c4114:	1004d23a 	srli	r2,r2,8
 90c4118:	11c03fcc 	andi	r7,r2,255
 90c411c:	e0bffe17 	ldw	r2,-8(fp)
 90c4120:	10800717 	ldw	r2,28(r2)
 90c4124:	1004d43a 	srli	r2,r2,16
 90c4128:	10c03fcc 	andi	r3,r2,255
 90c412c:	e0bffe17 	ldw	r2,-8(fp)
 90c4130:	10800717 	ldw	r2,28(r2)
 90c4134:	1008d63a 	srli	r4,r2,24
 90c4138:	e0bff917 	ldw	r2,-28(fp)
 90c413c:	1080000b 	ldhu	r2,0(r2)
 90c4140:	117fffcc 	andi	r5,r2,65535
 90c4144:	e0bff917 	ldw	r2,-28(fp)
 90c4148:	1080008b 	ldhu	r2,2(r2)
 90c414c:	10bfffcc 	andi	r2,r2,65535
 90c4150:	d8c00015 	stw	r3,0(sp)
 90c4154:	d9000115 	stw	r4,4(sp)
 90c4158:	d9400215 	stw	r5,8(sp)
 90c415c:	d8800315 	stw	r2,12(sp)
 90c4160:	01024374 	movhi	r4,2317
 90c4164:	21047804 	addi	r4,r4,4576
 90c4168:	e17ff617 	ldw	r5,-40(fp)
 90c416c:	90833900 	call	9083390 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 90c4170:	00824374 	movhi	r2,2317
 90c4174:	108f2204 	addi	r2,r2,15496
 90c4178:	10800017 	ldw	r2,0(r2)
 90c417c:	e0bff815 	stw	r2,-32(fp)
 90c4180:	0000b106 	br	90c4448 <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 90c4184:	e0bff817 	ldw	r2,-32(fp)
 90c4188:	1080018b 	ldhu	r2,6(r2)
 90c418c:	10bfffcc 	andi	r2,r2,65535
 90c4190:	1005003a 	cmpeq	r2,r2,zero
 90c4194:	1000071e 	bne	r2,zero,90c41b4 <udpdemux+0x414>
 90c4198:	e0bff817 	ldw	r2,-32(fp)
 90c419c:	10c0018b 	ldhu	r3,6(r2)
 90c41a0:	e0bff917 	ldw	r2,-28(fp)
 90c41a4:	1080008b 	ldhu	r2,2(r2)
 90c41a8:	18ffffcc 	andi	r3,r3,65535
 90c41ac:	10bfffcc 	andi	r2,r2,65535
 90c41b0:	1880a21e 	bne	r3,r2,90c443c <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 90c41b4:	e0bff817 	ldw	r2,-32(fp)
 90c41b8:	1080020b 	ldhu	r2,8(r2)
 90c41bc:	10bfffcc 	andi	r2,r2,65535
 90c41c0:	1005003a 	cmpeq	r2,r2,zero
 90c41c4:	1000071e 	bne	r2,zero,90c41e4 <udpdemux+0x444>
 90c41c8:	e0bff817 	ldw	r2,-32(fp)
 90c41cc:	10c0020b 	ldhu	r3,8(r2)
 90c41d0:	e0bff917 	ldw	r2,-28(fp)
 90c41d4:	1080000b 	ldhu	r2,0(r2)
 90c41d8:	18ffffcc 	andi	r3,r3,65535
 90c41dc:	10bfffcc 	andi	r2,r2,65535
 90c41e0:	1880961e 	bne	r3,r2,90c443c <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 90c41e4:	e0bff817 	ldw	r2,-32(fp)
 90c41e8:	10800417 	ldw	r2,16(r2)
 90c41ec:	1005003a 	cmpeq	r2,r2,zero
 90c41f0:	1000051e 	bne	r2,zero,90c4208 <udpdemux+0x468>
 90c41f4:	e0bff817 	ldw	r2,-32(fp)
 90c41f8:	10c00417 	ldw	r3,16(r2)
 90c41fc:	e0bffe17 	ldw	r2,-8(fp)
 90c4200:	10800717 	ldw	r2,28(r2)
 90c4204:	18808d1e 	bne	r3,r2,90c443c <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 90c4208:	e0bffa17 	ldw	r2,-24(fp)
 90c420c:	10800417 	ldw	r2,16(r2)
 90c4210:	1004d63a 	srli	r2,r2,24
 90c4214:	10c03fcc 	andi	r3,r2,255
 90c4218:	e0bffa17 	ldw	r2,-24(fp)
 90c421c:	10800417 	ldw	r2,16(r2)
 90c4220:	1004d23a 	srli	r2,r2,8
 90c4224:	10bfc00c 	andi	r2,r2,65280
 90c4228:	1886b03a 	or	r3,r3,r2
 90c422c:	e0bffa17 	ldw	r2,-24(fp)
 90c4230:	10800417 	ldw	r2,16(r2)
 90c4234:	10bfc00c 	andi	r2,r2,65280
 90c4238:	1004923a 	slli	r2,r2,8
 90c423c:	1886b03a 	or	r3,r3,r2
 90c4240:	e0bffa17 	ldw	r2,-24(fp)
 90c4244:	10800417 	ldw	r2,16(r2)
 90c4248:	10803fcc 	andi	r2,r2,255
 90c424c:	1004963a 	slli	r2,r2,24
 90c4250:	1884b03a 	or	r2,r3,r2
 90c4254:	10fc002c 	andhi	r3,r2,61440
 90c4258:	00b80034 	movhi	r2,57344
 90c425c:	1880301e 	bne	r3,r2,90c4320 <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 90c4260:	e0bff817 	ldw	r2,-32(fp)
 90c4264:	10800617 	ldw	r2,24(r2)
 90c4268:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 90c426c:	e0bff817 	ldw	r2,-32(fp)
 90c4270:	10c00517 	ldw	r3,20(r2)
 90c4274:	00824334 	movhi	r2,2316
 90c4278:	10a33704 	addi	r2,r2,-29476
 90c427c:	1880281e 	bne	r3,r2,90c4320 <udpdemux+0x580>
 90c4280:	e0bff417 	ldw	r2,-48(fp)
 90c4284:	10800317 	ldw	r2,12(r2)
 90c4288:	1005003a 	cmpeq	r2,r2,zero
 90c428c:	1000241e 	bne	r2,zero,90c4320 <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 90c4290:	e0bff417 	ldw	r2,-48(fp)
 90c4294:	10800317 	ldw	r2,12(r2)
 90c4298:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 90c429c:	e03ff30d 	sth	zero,-52(fp)
 90c42a0:	00001906 	br	90c4308 <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 90c42a4:	e0bff30b 	ldhu	r2,-52(fp)
 90c42a8:	e0fff217 	ldw	r3,-56(fp)
 90c42ac:	1085883a 	add	r2,r2,r2
 90c42b0:	1085883a 	add	r2,r2,r2
 90c42b4:	10c5883a 	add	r2,r2,r3
 90c42b8:	10800204 	addi	r2,r2,8
 90c42bc:	10800017 	ldw	r2,0(r2)
 90c42c0:	10c00117 	ldw	r3,4(r2)
 90c42c4:	e0bffe17 	ldw	r2,-8(fp)
 90c42c8:	10800617 	ldw	r2,24(r2)
 90c42cc:	18800b1e 	bne	r3,r2,90c42fc <udpdemux+0x55c>
 90c42d0:	e0bff30b 	ldhu	r2,-52(fp)
 90c42d4:	e0fff217 	ldw	r3,-56(fp)
 90c42d8:	1085883a 	add	r2,r2,r2
 90c42dc:	1085883a 	add	r2,r2,r2
 90c42e0:	10c5883a 	add	r2,r2,r3
 90c42e4:	10800204 	addi	r2,r2,8
 90c42e8:	10800017 	ldw	r2,0(r2)
 90c42ec:	10c00017 	ldw	r3,0(r2)
 90c42f0:	e0bffa17 	ldw	r2,-24(fp)
 90c42f4:	10800417 	ldw	r2,16(r2)
 90c42f8:	18800926 	beq	r3,r2,90c4320 <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 90c42fc:	e0bff30b 	ldhu	r2,-52(fp)
 90c4300:	10800044 	addi	r2,r2,1
 90c4304:	e0bff30d 	sth	r2,-52(fp)
 90c4308:	e0bff217 	ldw	r2,-56(fp)
 90c430c:	1080018b 	ldhu	r2,6(r2)
 90c4310:	10ffffcc 	andi	r3,r2,65535
 90c4314:	e0bff30b 	ldhu	r2,-52(fp)
 90c4318:	10ffe236 	bltu	r2,r3,90c42a4 <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 90c431c:	00004706 	br	90c443c <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 90c4320:	e0bffa17 	ldw	r2,-24(fp)
 90c4324:	10800417 	ldw	r2,16(r2)
 90c4328:	1004d63a 	srli	r2,r2,24
 90c432c:	10c03fcc 	andi	r3,r2,255
 90c4330:	e0bffa17 	ldw	r2,-24(fp)
 90c4334:	10800417 	ldw	r2,16(r2)
 90c4338:	1004d23a 	srli	r2,r2,8
 90c433c:	10bfc00c 	andi	r2,r2,65280
 90c4340:	1886b03a 	or	r3,r3,r2
 90c4344:	e0bffa17 	ldw	r2,-24(fp)
 90c4348:	10800417 	ldw	r2,16(r2)
 90c434c:	10bfc00c 	andi	r2,r2,65280
 90c4350:	1004923a 	slli	r2,r2,8
 90c4354:	1886b03a 	or	r3,r3,r2
 90c4358:	e0bffa17 	ldw	r2,-24(fp)
 90c435c:	10800417 	ldw	r2,16(r2)
 90c4360:	10803fcc 	andi	r2,r2,255
 90c4364:	1004963a 	slli	r2,r2,24
 90c4368:	1884b03a 	or	r2,r3,r2
 90c436c:	10fc002c 	andhi	r3,r2,61440
 90c4370:	00b80034 	movhi	r2,57344
 90c4374:	18800926 	beq	r3,r2,90c439c <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 90c4378:	e0bff817 	ldw	r2,-32(fp)
 90c437c:	10800317 	ldw	r2,12(r2)
 90c4380:	1005003a 	cmpeq	r2,r2,zero
 90c4384:	1000051e 	bne	r2,zero,90c439c <udpdemux+0x5fc>
 90c4388:	e0bff817 	ldw	r2,-32(fp)
 90c438c:	10c00317 	ldw	r3,12(r2)
 90c4390:	e0bffa17 	ldw	r2,-24(fp)
 90c4394:	10800417 	ldw	r2,16(r2)
 90c4398:	1880281e 	bne	r3,r2,90c443c <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 90c439c:	008243b4 	movhi	r2,2318
 90c43a0:	10b84604 	addi	r2,r2,-7912
 90c43a4:	10800017 	ldw	r2,0(r2)
 90c43a8:	10c00044 	addi	r3,r2,1
 90c43ac:	008243b4 	movhi	r2,2318
 90c43b0:	10b84604 	addi	r2,r2,-7912
 90c43b4:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 90c43b8:	e0bff817 	ldw	r2,-32(fp)
 90c43bc:	10800517 	ldw	r2,20(r2)
 90c43c0:	1005003a 	cmpeq	r2,r2,zero
 90c43c4:	10000c1e 	bne	r2,zero,90c43f8 <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 90c43c8:	0009883a 	mov	r4,zero
 90c43cc:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 90c43d0:	e0bff817 	ldw	r2,-32(fp)
 90c43d4:	10c00517 	ldw	r3,20(r2)
 90c43d8:	e0bff817 	ldw	r2,-32(fp)
 90c43dc:	11400617 	ldw	r5,24(r2)
 90c43e0:	e13ffe17 	ldw	r4,-8(fp)
 90c43e4:	183ee83a 	callr	r3
 90c43e8:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 90c43ec:	0009883a 	mov	r4,zero
 90c43f0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
 90c43f4:	00000206 	br	90c4400 <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 90c43f8:	00bffd44 	movi	r2,-11
 90c43fc:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 90c4400:	e0bff517 	ldw	r2,-44(fp)
 90c4404:	1005003a 	cmpeq	r2,r2,zero
 90c4408:	1000091e 	bne	r2,zero,90c4430 <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 90c440c:	008243b4 	movhi	r2,2318
 90c4410:	10b84604 	addi	r2,r2,-7912
 90c4414:	10800217 	ldw	r2,8(r2)
 90c4418:	10c00044 	addi	r3,r2,1
 90c441c:	008243b4 	movhi	r2,2318
 90c4420:	10b84604 	addi	r2,r2,-7912
 90c4424:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 90c4428:	e13ffe17 	ldw	r4,-8(fp)
 90c442c:	90c4b9c0 	call	90c4b9c <udp_free>
      }

      return(e);
 90c4430:	e0bff517 	ldw	r2,-44(fp)
 90c4434:	e0bfff15 	stw	r2,-4(fp)
 90c4438:	00006906 	br	90c45e0 <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 90c443c:	e0bff817 	ldw	r2,-32(fp)
 90c4440:	10800017 	ldw	r2,0(r2)
 90c4444:	e0bff815 	stw	r2,-32(fp)
 90c4448:	e0bff817 	ldw	r2,-32(fp)
 90c444c:	1004c03a 	cmpne	r2,r2,zero
 90c4450:	103f4c1e 	bne	r2,zero,90c4184 <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 90c4454:	e0bffa17 	ldw	r2,-24(fp)
 90c4458:	10800417 	ldw	r2,16(r2)
 90c445c:	10bfffe0 	cmpeqi	r2,r2,-1
 90c4460:	1000121e 	bne	r2,zero,90c44ac <udpdemux+0x70c>
 90c4464:	e0bffa17 	ldw	r2,-24(fp)
 90c4468:	10c00417 	ldw	r3,16(r2)
 90c446c:	e0bffe17 	ldw	r2,-8(fp)
 90c4470:	10800617 	ldw	r2,24(r2)
 90c4474:	10800e17 	ldw	r2,56(r2)
 90c4478:	18800c26 	beq	r3,r2,90c44ac <udpdemux+0x70c>
 90c447c:	e0bffa17 	ldw	r2,-24(fp)
 90c4480:	10c00417 	ldw	r3,16(r2)
 90c4484:	e0bffe17 	ldw	r2,-8(fp)
 90c4488:	10800617 	ldw	r2,24(r2)
 90c448c:	10800f17 	ldw	r2,60(r2)
 90c4490:	18800626 	beq	r3,r2,90c44ac <udpdemux+0x70c>
 90c4494:	e0bffa17 	ldw	r2,-24(fp)
 90c4498:	10c00417 	ldw	r3,16(r2)
 90c449c:	e0bffe17 	ldw	r2,-8(fp)
 90c44a0:	10800617 	ldw	r2,24(r2)
 90c44a4:	10801017 	ldw	r2,64(r2)
 90c44a8:	18801b1e 	bne	r3,r2,90c4518 <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c44ac:	00824374 	movhi	r2,2317
 90c44b0:	108f0904 	addi	r2,r2,15396
 90c44b4:	10800017 	ldw	r2,0(r2)
 90c44b8:	1081000c 	andi	r2,r2,1024
 90c44bc:	1005003a 	cmpeq	r2,r2,zero
 90c44c0:	1000091e 	bne	r2,zero,90c44e8 <udpdemux+0x748>
 90c44c4:	00824374 	movhi	r2,2317
 90c44c8:	108f0904 	addi	r2,r2,15396
 90c44cc:	10800017 	ldw	r2,0(r2)
 90c44d0:	1080400c 	andi	r2,r2,256
 90c44d4:	1005003a 	cmpeq	r2,r2,zero
 90c44d8:	1000031e 	bne	r2,zero,90c44e8 <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 90c44dc:	01024374 	movhi	r4,2317
 90c44e0:	21048204 	addi	r4,r4,4616
 90c44e4:	90836b80 	call	90836b8 <puts>
#endif
      udp_mib.udpInErrors++;
 90c44e8:	008243b4 	movhi	r2,2318
 90c44ec:	10b84604 	addi	r2,r2,-7912
 90c44f0:	10800217 	ldw	r2,8(r2)
 90c44f4:	10c00044 	addi	r3,r2,1
 90c44f8:	008243b4 	movhi	r2,2318
 90c44fc:	10b84604 	addi	r2,r2,-7912
 90c4500:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 90c4504:	e13ffe17 	ldw	r4,-8(fp)
 90c4508:	90c4b9c0 	call	90c4b9c <udp_free>
      return ENP_NOT_MINE;
 90c450c:	00800084 	movi	r2,2
 90c4510:	e0bfff15 	stw	r2,-4(fp)
 90c4514:	00003206 	br	90c45e0 <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 90c4518:	00824374 	movhi	r2,2317
 90c451c:	108f0904 	addi	r2,r2,15396
 90c4520:	10800017 	ldw	r2,0(r2)
 90c4524:	1081000c 	andi	r2,r2,1024
 90c4528:	1005003a 	cmpeq	r2,r2,zero
 90c452c:	1000141e 	bne	r2,zero,90c4580 <udpdemux+0x7e0>
 90c4530:	00824374 	movhi	r2,2317
 90c4534:	108f0904 	addi	r2,r2,15396
 90c4538:	10800017 	ldw	r2,0(r2)
 90c453c:	1080400c 	andi	r2,r2,256
 90c4540:	1005003a 	cmpeq	r2,r2,zero
 90c4544:	10000e1e 	bne	r2,zero,90c4580 <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 90c4548:	e0bff917 	ldw	r2,-28(fp)
 90c454c:	1080008b 	ldhu	r2,2(r2)
 90c4550:	117fffcc 	andi	r5,r2,65535
 90c4554:	01024374 	movhi	r4,2317
 90c4558:	21048904 	addi	r4,r4,4644
 90c455c:	90833900 	call	9083390 <printf>
      if (NDEBUG & DUMP) 
 90c4560:	00824374 	movhi	r2,2317
 90c4564:	108f0904 	addi	r2,r2,15396
 90c4568:	10800017 	ldw	r2,0(r2)
 90c456c:	1080008c 	andi	r2,r2,2
 90c4570:	1005003a 	cmpeq	r2,r2,zero
 90c4574:	1000021e 	bne	r2,zero,90c4580 <udpdemux+0x7e0>
         ip_dump(p);
 90c4578:	e13ffe17 	ldw	r4,-8(fp)
 90c457c:	90bfaf40 	call	90bfaf4 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c4580:	e13ff917 	ldw	r4,-28(fp)
 90c4584:	90c48b00 	call	90c48b0 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 90c4588:	e0bffe17 	ldw	r2,-8(fp)
 90c458c:	11000717 	ldw	r4,28(r2)
 90c4590:	e0bffe17 	ldw	r2,-8(fp)
 90c4594:	10800617 	ldw	r2,24(r2)
 90c4598:	11400a17 	ldw	r5,40(r2)
 90c459c:	e0bffe17 	ldw	r2,-8(fp)
 90c45a0:	10800617 	ldw	r2,24(r2)
 90c45a4:	d8800015 	stw	r2,0(sp)
 90c45a8:	e1bffa17 	ldw	r6,-24(fp)
 90c45ac:	01c000c4 	movi	r7,3
 90c45b0:	90cace80 	call	90cace8 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 90c45b4:	008243b4 	movhi	r2,2318
 90c45b8:	10b84604 	addi	r2,r2,-7912
 90c45bc:	10800117 	ldw	r2,4(r2)
 90c45c0:	10c00044 	addi	r3,r2,1
 90c45c4:	008243b4 	movhi	r2,2318
 90c45c8:	10b84604 	addi	r2,r2,-7912
 90c45cc:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 90c45d0:	e13ffe17 	ldw	r4,-8(fp)
 90c45d4:	90c4b9c0 	call	90c4b9c <udp_free>
   return ENP_NOT_MINE;
 90c45d8:	00800084 	movi	r2,2
 90c45dc:	e0bfff15 	stw	r2,-4(fp)
 90c45e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90c45e4:	e037883a 	mov	sp,fp
 90c45e8:	dfc00117 	ldw	ra,4(sp)
 90c45ec:	df000017 	ldw	fp,0(sp)
 90c45f0:	dec00204 	addi	sp,sp,8
 90c45f4:	f800283a 	ret

090c45f8 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 90c45f8:	deffee04 	addi	sp,sp,-72
 90c45fc:	dfc01115 	stw	ra,68(sp)
 90c4600:	df001015 	stw	fp,64(sp)
 90c4604:	df001004 	addi	fp,sp,64
 90c4608:	e1bffe15 	stw	r6,-8(fp)
 90c460c:	e13ffc0d 	sth	r4,-16(fp)
 90c4610:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 90c4614:	00824374 	movhi	r2,2317
 90c4618:	108f0904 	addi	r2,r2,15396
 90c461c:	10800017 	ldw	r2,0(r2)
 90c4620:	1080410c 	andi	r2,r2,260
 90c4624:	1005003a 	cmpeq	r2,r2,zero
 90c4628:	10001c1e 	bne	r2,zero,90c469c <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 90c462c:	e0bffe17 	ldw	r2,-8(fp)
 90c4630:	11800417 	ldw	r6,16(r2)
 90c4634:	e1fffd0b 	ldhu	r7,-12(fp)
 90c4638:	e0bffe17 	ldw	r2,-8(fp)
 90c463c:	10800717 	ldw	r2,28(r2)
 90c4640:	12003fcc 	andi	r8,r2,255
 90c4644:	e0bffe17 	ldw	r2,-8(fp)
 90c4648:	10800717 	ldw	r2,28(r2)
 90c464c:	1004d23a 	srli	r2,r2,8
 90c4650:	11003fcc 	andi	r4,r2,255
 90c4654:	e0bffe17 	ldw	r2,-8(fp)
 90c4658:	10800717 	ldw	r2,28(r2)
 90c465c:	1004d43a 	srli	r2,r2,16
 90c4660:	11403fcc 	andi	r5,r2,255
 90c4664:	e0bffe17 	ldw	r2,-8(fp)
 90c4668:	10800717 	ldw	r2,28(r2)
 90c466c:	1004d63a 	srli	r2,r2,24
 90c4670:	e0fffc0b 	ldhu	r3,-16(fp)
 90c4674:	d9000015 	stw	r4,0(sp)
 90c4678:	d9400115 	stw	r5,4(sp)
 90c467c:	d8800215 	stw	r2,8(sp)
 90c4680:	d8c00315 	stw	r3,12(sp)
 90c4684:	01024374 	movhi	r4,2317
 90c4688:	21049004 	addi	r4,r4,4672
 90c468c:	300b883a 	mov	r5,r6
 90c4690:	380d883a 	mov	r6,r7
 90c4694:	400f883a 	mov	r7,r8
 90c4698:	90833900 	call	9083390 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 90c469c:	0009883a 	mov	r4,zero
 90c46a0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 90c46a4:	e0bffe17 	ldw	r2,-8(fp)
 90c46a8:	10800317 	ldw	r2,12(r2)
 90c46ac:	10fffe04 	addi	r3,r2,-8
 90c46b0:	e0bffe17 	ldw	r2,-8(fp)
 90c46b4:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 90c46b8:	e0bffe17 	ldw	r2,-8(fp)
 90c46bc:	10800317 	ldw	r2,12(r2)
 90c46c0:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 90c46c4:	e0bffe17 	ldw	r2,-8(fp)
 90c46c8:	10800417 	ldw	r2,16(r2)
 90c46cc:	10800204 	addi	r2,r2,8
 90c46d0:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 90c46d4:	e0fff617 	ldw	r3,-40(fp)
 90c46d8:	e0bffe17 	ldw	r2,-8(fp)
 90c46dc:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 90c46e0:	e0bff617 	ldw	r2,-40(fp)
 90c46e4:	1080004c 	andi	r2,r2,1
 90c46e8:	10803fcc 	andi	r2,r2,255
 90c46ec:	1005003a 	cmpeq	r2,r2,zero
 90c46f0:	1000041e 	bne	r2,zero,90c4704 <udp_send+0x10c>
 90c46f4:	e0fff817 	ldw	r3,-32(fp)
 90c46f8:	e0bff617 	ldw	r2,-40(fp)
 90c46fc:	1885883a 	add	r2,r3,r2
 90c4700:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 90c4704:	e0bff617 	ldw	r2,-40(fp)
 90c4708:	1007883a 	mov	r3,r2
 90c470c:	e0bff817 	ldw	r2,-32(fp)
 90c4710:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 90c4714:	e0fff817 	ldw	r3,-32(fp)
 90c4718:	e0bffd0b 	ldhu	r2,-12(fp)
 90c471c:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 90c4720:	e0fff817 	ldw	r3,-32(fp)
 90c4724:	e0bffc0b 	ldhu	r2,-16(fp)
 90c4728:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 90c472c:	e13ff817 	ldw	r4,-32(fp)
 90c4730:	90c48b00 	call	90c48b0 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 90c4734:	e0bffe17 	ldw	r2,-8(fp)
 90c4738:	10800717 	ldw	r2,28(r2)
 90c473c:	10bfffd8 	cmpnei	r2,r2,-1
 90c4740:	1000111e 	bne	r2,zero,90c4788 <udp_send+0x190>
   {
      if (!p->net)
 90c4744:	e0bffe17 	ldw	r2,-8(fp)
 90c4748:	10800617 	ldw	r2,24(r2)
 90c474c:	1004c03a 	cmpne	r2,r2,zero
 90c4750:	1000081e 	bne	r2,zero,90c4774 <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 90c4754:	90aa4780 	call	90aa478 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 90c4758:	e13ffe17 	ldw	r4,-8(fp)
 90c475c:	90c4b9c0 	call	90c4b9c <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 90c4760:	0009883a 	mov	r4,zero
 90c4764:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 90c4768:	00bff784 	movi	r2,-34
 90c476c:	e0bfff15 	stw	r2,-4(fp)
 90c4770:	00004906 	br	90c4898 <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 90c4774:	e0bffe17 	ldw	r2,-8(fp)
 90c4778:	10800617 	ldw	r2,24(r2)
 90c477c:	10800a17 	ldw	r2,40(r2)
 90c4780:	e0bff415 	stw	r2,-48(fp)
 90c4784:	00000406 	br	90c4798 <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 90c4788:	e0bffe17 	ldw	r2,-8(fp)
 90c478c:	11000717 	ldw	r4,28(r2)
 90c4790:	90bfa480 	call	90bfa48 <ip_mymach>
 90c4794:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 90c4798:	e0bff417 	ldw	r2,-48(fp)
 90c479c:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 90c47a0:	e0bffe17 	ldw	r2,-8(fp)
 90c47a4:	10800717 	ldw	r2,28(r2)
 90c47a8:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 90c47ac:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 90c47b0:	00800444 	movi	r2,17
 90c47b4:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 90c47b8:	e0bff817 	ldw	r2,-32(fp)
 90c47bc:	1080010b 	ldhu	r2,4(r2)
 90c47c0:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 90c47c4:	e13ff904 	addi	r4,fp,-28
 90c47c8:	01400184 	movi	r5,6
 90c47cc:	90a4ef40 	call	90a4ef4 <cksum>
 90c47d0:	1007883a 	mov	r3,r2
 90c47d4:	e0bff817 	ldw	r2,-32(fp)
 90c47d8:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 90c47dc:	e0bff617 	ldw	r2,-40(fp)
 90c47e0:	10800044 	addi	r2,r2,1
 90c47e4:	1005d07a 	srai	r2,r2,1
 90c47e8:	100b883a 	mov	r5,r2
 90c47ec:	e13ff817 	ldw	r4,-32(fp)
 90c47f0:	90a4ef40 	call	90a4ef4 <cksum>
 90c47f4:	0084303a 	nor	r2,zero,r2
 90c47f8:	1007883a 	mov	r3,r2
 90c47fc:	e0bff817 	ldw	r2,-32(fp)
 90c4800:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 90c4804:	e0bff817 	ldw	r2,-32(fp)
 90c4808:	1080018b 	ldhu	r2,6(r2)
 90c480c:	10bfffcc 	andi	r2,r2,65535
 90c4810:	1004c03a 	cmpne	r2,r2,zero
 90c4814:	1000031e 	bne	r2,zero,90c4824 <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 90c4818:	e0fff817 	ldw	r3,-32(fp)
 90c481c:	00bfffc4 	movi	r2,-1
 90c4820:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 90c4824:	e0bffe17 	ldw	r2,-8(fp)
 90c4828:	10800317 	ldw	r2,12(r2)
 90c482c:	10bffb04 	addi	r2,r2,-20
 90c4830:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 90c4834:	e0fff717 	ldw	r3,-36(fp)
 90c4838:	e0bff417 	ldw	r2,-48(fp)
 90c483c:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 90c4840:	e0bffe17 	ldw	r2,-8(fp)
 90c4844:	10c00717 	ldw	r3,28(r2)
 90c4848:	e0bff717 	ldw	r2,-36(fp)
 90c484c:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 90c4850:	008243b4 	movhi	r2,2318
 90c4854:	10b84604 	addi	r2,r2,-7912
 90c4858:	10800317 	ldw	r2,12(r2)
 90c485c:	10c00044 	addi	r3,r2,1
 90c4860:	008243b4 	movhi	r2,2318
 90c4864:	10b84604 	addi	r2,r2,-7912
 90c4868:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 90c486c:	e0fff617 	ldw	r3,-40(fp)
 90c4870:	e0bffe17 	ldw	r2,-8(fp)
 90c4874:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 90c4878:	01000444 	movi	r4,17
 90c487c:	e17ffe17 	ldw	r5,-8(fp)
 90c4880:	90be8c40 	call	90be8c4 <ip_write>
 90c4884:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 90c4888:	0009883a 	mov	r4,zero
 90c488c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   return e;
 90c4890:	e0bff517 	ldw	r2,-44(fp)
 90c4894:	e0bfff15 	stw	r2,-4(fp)
 90c4898:	e0bfff17 	ldw	r2,-4(fp)
}
 90c489c:	e037883a 	mov	sp,fp
 90c48a0:	dfc00117 	ldw	ra,4(sp)
 90c48a4:	df000017 	ldw	fp,0(sp)
 90c48a8:	dec00204 	addi	sp,sp,8
 90c48ac:	f800283a 	ret

090c48b0 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 90c48b0:	defffe04 	addi	sp,sp,-8
 90c48b4:	df000115 	stw	fp,4(sp)
 90c48b8:	df000104 	addi	fp,sp,4
 90c48bc:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 90c48c0:	e0bfff17 	ldw	r2,-4(fp)
 90c48c4:	1080000b 	ldhu	r2,0(r2)
 90c48c8:	10bfffcc 	andi	r2,r2,65535
 90c48cc:	1004d23a 	srli	r2,r2,8
 90c48d0:	10803fcc 	andi	r2,r2,255
 90c48d4:	1009883a 	mov	r4,r2
 90c48d8:	e0bfff17 	ldw	r2,-4(fp)
 90c48dc:	1080000b 	ldhu	r2,0(r2)
 90c48e0:	10bfffcc 	andi	r2,r2,65535
 90c48e4:	1004923a 	slli	r2,r2,8
 90c48e8:	1007883a 	mov	r3,r2
 90c48ec:	00bfc004 	movi	r2,-256
 90c48f0:	1884703a 	and	r2,r3,r2
 90c48f4:	2084b03a 	or	r2,r4,r2
 90c48f8:	1007883a 	mov	r3,r2
 90c48fc:	e0bfff17 	ldw	r2,-4(fp)
 90c4900:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 90c4904:	e0bfff17 	ldw	r2,-4(fp)
 90c4908:	1080008b 	ldhu	r2,2(r2)
 90c490c:	10bfffcc 	andi	r2,r2,65535
 90c4910:	1004d23a 	srli	r2,r2,8
 90c4914:	10803fcc 	andi	r2,r2,255
 90c4918:	1009883a 	mov	r4,r2
 90c491c:	e0bfff17 	ldw	r2,-4(fp)
 90c4920:	1080008b 	ldhu	r2,2(r2)
 90c4924:	10bfffcc 	andi	r2,r2,65535
 90c4928:	1004923a 	slli	r2,r2,8
 90c492c:	1007883a 	mov	r3,r2
 90c4930:	00bfc004 	movi	r2,-256
 90c4934:	1884703a 	and	r2,r3,r2
 90c4938:	2084b03a 	or	r2,r4,r2
 90c493c:	1007883a 	mov	r3,r2
 90c4940:	e0bfff17 	ldw	r2,-4(fp)
 90c4944:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 90c4948:	e0bfff17 	ldw	r2,-4(fp)
 90c494c:	1080010b 	ldhu	r2,4(r2)
 90c4950:	10bfffcc 	andi	r2,r2,65535
 90c4954:	1004d23a 	srli	r2,r2,8
 90c4958:	10803fcc 	andi	r2,r2,255
 90c495c:	1009883a 	mov	r4,r2
 90c4960:	e0bfff17 	ldw	r2,-4(fp)
 90c4964:	1080010b 	ldhu	r2,4(r2)
 90c4968:	10bfffcc 	andi	r2,r2,65535
 90c496c:	1004923a 	slli	r2,r2,8
 90c4970:	1007883a 	mov	r3,r2
 90c4974:	00bfc004 	movi	r2,-256
 90c4978:	1884703a 	and	r2,r3,r2
 90c497c:	2084b03a 	or	r2,r4,r2
 90c4980:	1007883a 	mov	r3,r2
 90c4984:	e0bfff17 	ldw	r2,-4(fp)
 90c4988:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 90c498c:	e0bfff17 	ldw	r2,-4(fp)
 90c4990:	1080018b 	ldhu	r2,6(r2)
 90c4994:	10bfffcc 	andi	r2,r2,65535
 90c4998:	1004d23a 	srli	r2,r2,8
 90c499c:	10803fcc 	andi	r2,r2,255
 90c49a0:	1009883a 	mov	r4,r2
 90c49a4:	e0bfff17 	ldw	r2,-4(fp)
 90c49a8:	1080018b 	ldhu	r2,6(r2)
 90c49ac:	10bfffcc 	andi	r2,r2,65535
 90c49b0:	1004923a 	slli	r2,r2,8
 90c49b4:	1007883a 	mov	r3,r2
 90c49b8:	00bfc004 	movi	r2,-256
 90c49bc:	1884703a 	and	r2,r3,r2
 90c49c0:	2084b03a 	or	r2,r4,r2
 90c49c4:	1007883a 	mov	r3,r2
 90c49c8:	e0bfff17 	ldw	r2,-4(fp)
 90c49cc:	10c0018d 	sth	r3,6(r2)
}
 90c49d0:	e037883a 	mov	sp,fp
 90c49d4:	df000017 	ldw	fp,0(sp)
 90c49d8:	dec00104 	addi	sp,sp,4
 90c49dc:	f800283a 	ret

090c49e0 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 90c49e0:	defffe04 	addi	sp,sp,-8
 90c49e4:	df000115 	stw	fp,4(sp)
 90c49e8:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 90c49ec:	d0a0d20b 	ldhu	r2,-31928(gp)
 90c49f0:	10bfffcc 	andi	r2,r2,65535
 90c49f4:	10812c28 	cmpgeui	r2,r2,1200
 90c49f8:	10000c1e 	bne	r2,zero,90c4a2c <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 90c49fc:	00824374 	movhi	r2,2317
 90c4a00:	108f2e04 	addi	r2,r2,15544
 90c4a04:	10800017 	ldw	r2,0(r2)
 90c4a08:	109fffcc 	andi	r2,r2,32767
 90c4a0c:	d0a0d20d 	sth	r2,-31928(gp)
      if (usocket < MINSOCKET)
 90c4a10:	d0a0d20b 	ldhu	r2,-31928(gp)
 90c4a14:	10bfffcc 	andi	r2,r2,65535
 90c4a18:	10812c28 	cmpgeui	r2,r2,1200
 90c4a1c:	1000031e 	bne	r2,zero,90c4a2c <udp_socket+0x4c>
         usocket += MINSOCKET;
 90c4a20:	d0a0d20b 	ldhu	r2,-31928(gp)
 90c4a24:	10812c04 	addi	r2,r2,1200
 90c4a28:	d0a0d20d 	sth	r2,-31928(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90c4a2c:	00824374 	movhi	r2,2317
 90c4a30:	108f2204 	addi	r2,r2,15496
 90c4a34:	10800017 	ldw	r2,0(r2)
 90c4a38:	e0bfff15 	stw	r2,-4(fp)
 90c4a3c:	00001006 	br	90c4a80 <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 90c4a40:	e0bfff17 	ldw	r2,-4(fp)
 90c4a44:	1080018b 	ldhu	r2,6(r2)
 90c4a48:	d0e0d20b 	ldhu	r3,-31928(gp)
 90c4a4c:	113fffcc 	andi	r4,r2,65535
 90c4a50:	18bfffcc 	andi	r2,r3,65535
 90c4a54:	2080071e 	bne	r4,r2,90c4a74 <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 90c4a58:	d0a0d20b 	ldhu	r2,-31928(gp)
 90c4a5c:	10800044 	addi	r2,r2,1
 90c4a60:	d0a0d20d 	sth	r2,-31928(gp)
         tmp = firstudp;   /* restart scan */
 90c4a64:	00824374 	movhi	r2,2317
 90c4a68:	108f2204 	addi	r2,r2,15496
 90c4a6c:	10800017 	ldw	r2,0(r2)
 90c4a70:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 90c4a74:	e0bfff17 	ldw	r2,-4(fp)
 90c4a78:	10800017 	ldw	r2,0(r2)
 90c4a7c:	e0bfff15 	stw	r2,-4(fp)
 90c4a80:	e0bfff17 	ldw	r2,-4(fp)
 90c4a84:	1004c03a 	cmpne	r2,r2,zero
 90c4a88:	103fed1e 	bne	r2,zero,90c4a40 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 90c4a8c:	d0a0d20b 	ldhu	r2,-31928(gp)
 90c4a90:	10ffffcc 	andi	r3,r2,65535
 90c4a94:	10800044 	addi	r2,r2,1
 90c4a98:	d0a0d20d 	sth	r2,-31928(gp)
 90c4a9c:	1805883a 	mov	r2,r3
}
 90c4aa0:	e037883a 	mov	sp,fp
 90c4aa4:	df000017 	ldw	fp,0(sp)
 90c4aa8:	dec00104 	addi	sp,sp,4
 90c4aac:	f800283a 	ret

090c4ab0 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 90c4ab0:	defffa04 	addi	sp,sp,-24
 90c4ab4:	dfc00515 	stw	ra,20(sp)
 90c4ab8:	df000415 	stw	fp,16(sp)
 90c4abc:	df000404 	addi	fp,sp,16
 90c4ac0:	e13ffe15 	stw	r4,-8(fp)
 90c4ac4:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 90c4ac8:	e0bffe17 	ldw	r2,-8(fp)
 90c4acc:	10800244 	addi	r2,r2,9
 90c4ad0:	1007883a 	mov	r3,r2
 90c4ad4:	00bfff84 	movi	r2,-2
 90c4ad8:	1884703a 	and	r2,r3,r2
 90c4adc:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c4ae0:	01000084 	movi	r4,2
 90c4ae4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 90c4ae8:	e0fffd17 	ldw	r3,-12(fp)
 90c4aec:	e0bfff17 	ldw	r2,-4(fp)
 90c4af0:	1885883a 	add	r2,r3,r2
 90c4af4:	10800904 	addi	r2,r2,36
 90c4af8:	1009883a 	mov	r4,r2
 90c4afc:	90a98340 	call	90a9834 <pk_alloc>
 90c4b00:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c4b04:	01000084 	movi	r4,2
 90c4b08:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 90c4b0c:	e0bffc17 	ldw	r2,-16(fp)
 90c4b10:	1005003a 	cmpeq	r2,r2,zero
 90c4b14:	1000101e 	bne	r2,zero,90c4b58 <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 90c4b18:	e0bfff17 	ldw	r2,-4(fp)
 90c4b1c:	1005d0ba 	srai	r2,r2,2
 90c4b20:	10800704 	addi	r2,r2,28
 90c4b24:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 90c4b28:	e0bffc17 	ldw	r2,-16(fp)
 90c4b2c:	10c00317 	ldw	r3,12(r2)
 90c4b30:	e0bffd17 	ldw	r2,-12(fp)
 90c4b34:	1887883a 	add	r3,r3,r2
 90c4b38:	e0bffc17 	ldw	r2,-16(fp)
 90c4b3c:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 90c4b40:	e0bffc17 	ldw	r2,-16(fp)
 90c4b44:	10c00417 	ldw	r3,16(r2)
 90c4b48:	e0bffd17 	ldw	r2,-12(fp)
 90c4b4c:	1887c83a 	sub	r3,r3,r2
 90c4b50:	e0bffc17 	ldw	r2,-16(fp)
 90c4b54:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 90c4b58:	e0bffc17 	ldw	r2,-16(fp)
}
 90c4b5c:	e037883a 	mov	sp,fp
 90c4b60:	dfc00117 	ldw	ra,4(sp)
 90c4b64:	df000017 	ldw	fp,0(sp)
 90c4b68:	dec00204 	addi	sp,sp,8
 90c4b6c:	f800283a 	ret

090c4b70 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 90c4b70:	deffff04 	addi	sp,sp,-4
 90c4b74:	df000015 	stw	fp,0(sp)
 90c4b78:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 90c4b7c:	00824374 	movhi	r2,2317
 90c4b80:	108ebc04 	addi	r2,r2,15088
 90c4b84:	10800017 	ldw	r2,0(r2)
 90c4b88:	10bff704 	addi	r2,r2,-36
#endif
}
 90c4b8c:	e037883a 	mov	sp,fp
 90c4b90:	df000017 	ldw	fp,0(sp)
 90c4b94:	dec00104 	addi	sp,sp,4
 90c4b98:	f800283a 	ret

090c4b9c <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 90c4b9c:	defffd04 	addi	sp,sp,-12
 90c4ba0:	dfc00215 	stw	ra,8(sp)
 90c4ba4:	df000115 	stw	fp,4(sp)
 90c4ba8:	df000104 	addi	fp,sp,4
 90c4bac:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c4bb0:	01000084 	movi	r4,2
 90c4bb4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c4bb8:	e13fff17 	ldw	r4,-4(fp)
 90c4bbc:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c4bc0:	01000084 	movi	r4,2
 90c4bc4:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
}
 90c4bc8:	e037883a 	mov	sp,fp
 90c4bcc:	dfc00117 	ldw	ra,4(sp)
 90c4bd0:	df000017 	ldw	fp,0(sp)
 90c4bd4:	dec00204 	addi	sp,sp,8
 90c4bd8:	f800283a 	ret

090c4bdc <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 90c4bdc:	defff704 	addi	sp,sp,-36
 90c4be0:	dfc00815 	stw	ra,32(sp)
 90c4be4:	df000715 	stw	fp,28(sp)
 90c4be8:	df000704 	addi	fp,sp,28
 90c4bec:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 90c4bf0:	e0bffe17 	ldw	r2,-8(fp)
 90c4bf4:	10800617 	ldw	r2,24(r2)
 90c4bf8:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 90c4bfc:	e0bffe17 	ldw	r2,-8(fp)
 90c4c00:	10800317 	ldw	r2,12(r2)
 90c4c04:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 90c4c08:	e0bffc17 	ldw	r2,-16(fp)
 90c4c0c:	10800003 	ldbu	r2,0(r2)
 90c4c10:	10803fcc 	andi	r2,r2,255
 90c4c14:	108003cc 	andi	r2,r2,15
 90c4c18:	1085883a 	add	r2,r2,r2
 90c4c1c:	1085883a 	add	r2,r2,r2
 90c4c20:	1007883a 	mov	r3,r2
 90c4c24:	e0bffc17 	ldw	r2,-16(fp)
 90c4c28:	1885883a 	add	r2,r3,r2
 90c4c2c:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 90c4c30:	e0bffd17 	ldw	r2,-12(fp)
 90c4c34:	10800003 	ldbu	r2,0(r2)
 90c4c38:	10803fcc 	andi	r2,r2,255
 90c4c3c:	e0bfff15 	stw	r2,-4(fp)
 90c4c40:	e0ffff17 	ldw	r3,-4(fp)
 90c4c44:	18800460 	cmpeqi	r2,r3,17
 90c4c48:	1000041e 	bne	r2,zero,90c4c5c <igmpv1_input+0x80>
 90c4c4c:	e0ffff17 	ldw	r3,-4(fp)
 90c4c50:	188004a0 	cmpeqi	r2,r3,18
 90c4c54:	1000631e 	bne	r2,zero,90c4de4 <igmpv1_input+0x208>
 90c4c58:	00008706 	br	90c4e78 <igmpv1_input+0x29c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 90c4c5c:	008243b4 	movhi	r2,2318
 90c4c60:	10b5ea04 	addi	r2,r2,-10328
 90c4c64:	10800117 	ldw	r2,4(r2)
 90c4c68:	10c00044 	addi	r3,r2,1
 90c4c6c:	008243b4 	movhi	r2,2318
 90c4c70:	10b5ea04 	addi	r2,r2,-10328
 90c4c74:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c4c78:	e0bffa17 	ldw	r2,-24(fp)
 90c4c7c:	10802c17 	ldw	r2,176(r2)
 90c4c80:	e0bffb15 	stw	r2,-20(fp)
 90c4c84:	00005206 	br	90c4dd0 <igmpv1_input+0x1f4>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 90c4c88:	e0bffb17 	ldw	r2,-20(fp)
 90c4c8c:	10800017 	ldw	r2,0(r2)
 90c4c90:	1005003a 	cmpeq	r2,r2,zero
 90c4c94:	10004b1e 	bne	r2,zero,90c4dc4 <igmpv1_input+0x1e8>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 90c4c98:	e0bffb17 	ldw	r2,-20(fp)
 90c4c9c:	10c00017 	ldw	r3,0(r2)
 90c4ca0:	00824374 	movhi	r2,2317
 90c4ca4:	108f0e04 	addi	r2,r2,15416
 90c4ca8:	10800017 	ldw	r2,0(r2)
 90c4cac:	18804526 	beq	r3,r2,90c4dc4 <igmpv1_input+0x1e8>
         {
            if (inm->inm_timer == 0)
 90c4cb0:	e0bffb17 	ldw	r2,-20(fp)
 90c4cb4:	10800317 	ldw	r2,12(r2)
 90c4cb8:	1004c03a 	cmpne	r2,r2,zero
 90c4cbc:	1000411e 	bne	r2,zero,90c4dc4 <igmpv1_input+0x1e8>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 90c4cc0:	008243b4 	movhi	r2,2318
 90c4cc4:	10b82c04 	addi	r2,r2,-8016
 90c4cc8:	11000217 	ldw	r4,8(r2)
 90c4ccc:	008243b4 	movhi	r2,2318
 90c4cd0:	10b5e604 	addi	r2,r2,-10344
 90c4cd4:	10800017 	ldw	r2,0(r2)
 90c4cd8:	10800a17 	ldw	r2,40(r2)
 90c4cdc:	1004d63a 	srli	r2,r2,24
 90c4ce0:	10c03fcc 	andi	r3,r2,255
 90c4ce4:	008243b4 	movhi	r2,2318
 90c4ce8:	10b5e604 	addi	r2,r2,-10344
 90c4cec:	10800017 	ldw	r2,0(r2)
 90c4cf0:	10800a17 	ldw	r2,40(r2)
 90c4cf4:	1004d23a 	srli	r2,r2,8
 90c4cf8:	10bfc00c 	andi	r2,r2,65280
 90c4cfc:	1886b03a 	or	r3,r3,r2
 90c4d00:	008243b4 	movhi	r2,2318
 90c4d04:	10b5e604 	addi	r2,r2,-10344
 90c4d08:	10800017 	ldw	r2,0(r2)
 90c4d0c:	10800a17 	ldw	r2,40(r2)
 90c4d10:	10bfc00c 	andi	r2,r2,65280
 90c4d14:	1004923a 	slli	r2,r2,8
 90c4d18:	1886b03a 	or	r3,r3,r2
 90c4d1c:	008243b4 	movhi	r2,2318
 90c4d20:	10b5e604 	addi	r2,r2,-10344
 90c4d24:	10800017 	ldw	r2,0(r2)
 90c4d28:	10800a17 	ldw	r2,40(r2)
 90c4d2c:	10803fcc 	andi	r2,r2,255
 90c4d30:	1004963a 	slli	r2,r2,24
 90c4d34:	1884b03a 	or	r2,r3,r2
 90c4d38:	2089883a 	add	r4,r4,r2
 90c4d3c:	e0bffb17 	ldw	r2,-20(fp)
 90c4d40:	10800017 	ldw	r2,0(r2)
 90c4d44:	1004d63a 	srli	r2,r2,24
 90c4d48:	10c03fcc 	andi	r3,r2,255
 90c4d4c:	e0bffb17 	ldw	r2,-20(fp)
 90c4d50:	10800017 	ldw	r2,0(r2)
 90c4d54:	1004d23a 	srli	r2,r2,8
 90c4d58:	10bfc00c 	andi	r2,r2,65280
 90c4d5c:	1886b03a 	or	r3,r3,r2
 90c4d60:	e0bffb17 	ldw	r2,-20(fp)
 90c4d64:	10800017 	ldw	r2,0(r2)
 90c4d68:	10bfc00c 	andi	r2,r2,65280
 90c4d6c:	1004923a 	slli	r2,r2,8
 90c4d70:	1886b03a 	or	r3,r3,r2
 90c4d74:	e0bffb17 	ldw	r2,-20(fp)
 90c4d78:	10800017 	ldw	r2,0(r2)
 90c4d7c:	10803fcc 	andi	r2,r2,255
 90c4d80:	1004963a 	slli	r2,r2,24
 90c4d84:	1884b03a 	or	r2,r3,r2
 90c4d88:	2087883a 	add	r3,r4,r2
 90c4d8c:	00800c84 	movi	r2,50
 90c4d90:	1885203a 	divu	r2,r3,r2
 90c4d94:	10800ca4 	muli	r2,r2,50
 90c4d98:	1885c83a 	sub	r2,r3,r2
 90c4d9c:	10c00044 	addi	r3,r2,1
 90c4da0:	e0bffb17 	ldw	r2,-20(fp)
 90c4da4:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 90c4da8:	00824374 	movhi	r2,2317
 90c4dac:	108f0c04 	addi	r2,r2,15408
 90c4db0:	10800017 	ldw	r2,0(r2)
 90c4db4:	10c00044 	addi	r3,r2,1
 90c4db8:	00824374 	movhi	r2,2317
 90c4dbc:	108f0c04 	addi	r2,r2,15408
 90c4dc0:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c4dc4:	e0bffb17 	ldw	r2,-20(fp)
 90c4dc8:	10800517 	ldw	r2,20(r2)
 90c4dcc:	e0bffb15 	stw	r2,-20(fp)
 90c4dd0:	e0bffb17 	ldw	r2,-20(fp)
 90c4dd4:	1004c03a 	cmpne	r2,r2,zero
 90c4dd8:	103fab1e 	bne	r2,zero,90c4c88 <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 90c4ddc:	e03ff915 	stw	zero,-28(fp)
      break;
 90c4de0:	00002e06 	br	90c4e9c <igmpv1_input+0x2c0>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 90c4de4:	008243b4 	movhi	r2,2318
 90c4de8:	10b5ea04 	addi	r2,r2,-10328
 90c4dec:	10800217 	ldw	r2,8(r2)
 90c4df0:	10c00044 	addi	r3,r2,1
 90c4df4:	008243b4 	movhi	r2,2318
 90c4df8:	10b5ea04 	addi	r2,r2,-10328
 90c4dfc:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 90c4e00:	e0bffd17 	ldw	r2,-12(fp)
 90c4e04:	11000117 	ldw	r4,4(r2)
 90c4e08:	e17ffa17 	ldw	r5,-24(fp)
 90c4e0c:	90c300c0 	call	90c300c <lookup_mcast>
 90c4e10:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 90c4e14:	e0bffb17 	ldw	r2,-20(fp)
 90c4e18:	1005003a 	cmpeq	r2,r2,zero
 90c4e1c:	1000141e 	bne	r2,zero,90c4e70 <igmpv1_input+0x294>
      {
         if (inm->inm_timer > 0)
 90c4e20:	e0bffb17 	ldw	r2,-20(fp)
 90c4e24:	10800317 	ldw	r2,12(r2)
 90c4e28:	1005003a 	cmpeq	r2,r2,zero
 90c4e2c:	1000101e 	bne	r2,zero,90c4e70 <igmpv1_input+0x294>
         {
            inm->inm_timer = 0;
 90c4e30:	e0bffb17 	ldw	r2,-20(fp)
 90c4e34:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 90c4e38:	00824374 	movhi	r2,2317
 90c4e3c:	108f0c04 	addi	r2,r2,15408
 90c4e40:	10800017 	ldw	r2,0(r2)
 90c4e44:	10ffffc4 	addi	r3,r2,-1
 90c4e48:	00824374 	movhi	r2,2317
 90c4e4c:	108f0c04 	addi	r2,r2,15408
 90c4e50:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 90c4e54:	008243b4 	movhi	r2,2318
 90c4e58:	10b5ea04 	addi	r2,r2,-10328
 90c4e5c:	10800317 	ldw	r2,12(r2)
 90c4e60:	10c00044 	addi	r3,r2,1
 90c4e64:	008243b4 	movhi	r2,2318
 90c4e68:	10b5ea04 	addi	r2,r2,-10328
 90c4e6c:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 90c4e70:	e03ff915 	stw	zero,-28(fp)
      break;
 90c4e74:	00000906 	br	90c4e9c <igmpv1_input+0x2c0>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 90c4e78:	008243b4 	movhi	r2,2318
 90c4e7c:	10b5ea04 	addi	r2,r2,-10328
 90c4e80:	10801017 	ldw	r2,64(r2)
 90c4e84:	10c00044 	addi	r3,r2,1
 90c4e88:	008243b4 	movhi	r2,2318
 90c4e8c:	10b5ea04 	addi	r2,r2,-10328
 90c4e90:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 90c4e94:	00bfffc4 	movi	r2,-1
 90c4e98:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c4e9c:	01000084 	movi	r4,2
 90c4ea0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c4ea4:	e13ffe17 	ldw	r4,-8(fp)
 90c4ea8:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c4eac:	01000084 	movi	r4,2
 90c4eb0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      
   return rc;
 90c4eb4:	e0bff917 	ldw	r2,-28(fp)
}
 90c4eb8:	e037883a 	mov	sp,fp
 90c4ebc:	dfc00117 	ldw	ra,4(sp)
 90c4ec0:	df000017 	ldw	fp,0(sp)
 90c4ec4:	dec00204 	addi	sp,sp,8
 90c4ec8:	f800283a 	ret

090c4ecc <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 90c4ecc:	defff704 	addi	sp,sp,-36
 90c4ed0:	dfc00815 	stw	ra,32(sp)
 90c4ed4:	df000715 	stw	fp,28(sp)
 90c4ed8:	df000704 	addi	fp,sp,28
 90c4edc:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 90c4ee0:	e0bffe17 	ldw	r2,-8(fp)
 90c4ee4:	10800317 	ldw	r2,12(r2)
 90c4ee8:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 90c4eec:	e0bffe17 	ldw	r2,-8(fp)
 90c4ef0:	10c00417 	ldw	r3,16(r2)
 90c4ef4:	e0bffc17 	ldw	r2,-16(fp)
 90c4ef8:	10800003 	ldbu	r2,0(r2)
 90c4efc:	10803fcc 	andi	r2,r2,255
 90c4f00:	108003cc 	andi	r2,r2,15
 90c4f04:	1085883a 	add	r2,r2,r2
 90c4f08:	1085883a 	add	r2,r2,r2
 90c4f0c:	1885c83a 	sub	r2,r3,r2
 90c4f10:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 90c4f14:	e0bffc17 	ldw	r2,-16(fp)
 90c4f18:	10800003 	ldbu	r2,0(r2)
 90c4f1c:	10803fcc 	andi	r2,r2,255
 90c4f20:	108003cc 	andi	r2,r2,15
 90c4f24:	1085883a 	add	r2,r2,r2
 90c4f28:	1085883a 	add	r2,r2,r2
 90c4f2c:	1007883a 	mov	r3,r2
 90c4f30:	e0bffc17 	ldw	r2,-16(fp)
 90c4f34:	1885883a 	add	r2,r3,r2
 90c4f38:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 90c4f3c:	e0bffd17 	ldw	r2,-12(fp)
 90c4f40:	10800003 	ldbu	r2,0(r2)
 90c4f44:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 90c4f48:	e0bffa03 	ldbu	r2,-24(fp)
 90c4f4c:	e0bfff15 	stw	r2,-4(fp)
 90c4f50:	e0ffff17 	ldw	r3,-4(fp)
 90c4f54:	188004a0 	cmpeqi	r2,r3,18
 90c4f58:	1000121e 	bne	r2,zero,90c4fa4 <igmpv2_input+0xd8>
 90c4f5c:	e0ffff17 	ldw	r3,-4(fp)
 90c4f60:	188004c8 	cmpgei	r2,r3,19
 90c4f64:	1000041e 	bne	r2,zero,90c4f78 <igmpv2_input+0xac>
 90c4f68:	e0ffff17 	ldw	r3,-4(fp)
 90c4f6c:	18800460 	cmpeqi	r2,r3,17
 90c4f70:	1000081e 	bne	r2,zero,90c4f94 <igmpv2_input+0xc8>
 90c4f74:	00001806 	br	90c4fd8 <igmpv2_input+0x10c>
 90c4f78:	e0ffff17 	ldw	r3,-4(fp)
 90c4f7c:	188005a0 	cmpeqi	r2,r3,22
 90c4f80:	1000081e 	bne	r2,zero,90c4fa4 <igmpv2_input+0xd8>
 90c4f84:	e0ffff17 	ldw	r3,-4(fp)
 90c4f88:	188005e0 	cmpeqi	r2,r3,23
 90c4f8c:	1000091e 	bne	r2,zero,90c4fb4 <igmpv2_input+0xe8>
 90c4f90:	00001106 	br	90c4fd8 <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 90c4f94:	e13ffe17 	ldw	r4,-8(fp)
 90c4f98:	90c51780 	call	90c5178 <igmpv2_process_query>
 90c4f9c:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4fa0:	00001606 	br	90c4ffc <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 90c4fa4:	e13ffe17 	ldw	r4,-8(fp)
 90c4fa8:	90c502c0 	call	90c502c <igmpv2_process_report>
 90c4fac:	e0bff915 	stw	r2,-28(fp)
         break;
 90c4fb0:	00001206 	br	90c4ffc <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 90c4fb4:	008243b4 	movhi	r2,2318
 90c4fb8:	10b5ea04 	addi	r2,r2,-10328
 90c4fbc:	10800917 	ldw	r2,36(r2)
 90c4fc0:	10c00044 	addi	r3,r2,1
 90c4fc4:	008243b4 	movhi	r2,2318
 90c4fc8:	10b5ea04 	addi	r2,r2,-10328
 90c4fcc:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 90c4fd0:	e03ff915 	stw	zero,-28(fp)
         break;               
 90c4fd4:	00000906 	br	90c4ffc <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 90c4fd8:	008243b4 	movhi	r2,2318
 90c4fdc:	10b5ea04 	addi	r2,r2,-10328
 90c4fe0:	10801517 	ldw	r2,84(r2)
 90c4fe4:	10c00044 	addi	r3,r2,1
 90c4fe8:	008243b4 	movhi	r2,2318
 90c4fec:	10b5ea04 	addi	r2,r2,-10328
 90c4ff0:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 90c4ff4:	00bfffc4 	movi	r2,-1
 90c4ff8:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90c4ffc:	01000084 	movi	r4,2
 90c5000:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   pk_free(p);
 90c5004:	e13ffe17 	ldw	r4,-8(fp)
 90c5008:	90a9bc80 	call	90a9bc8 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90c500c:	01000084 	movi	r4,2
 90c5010:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
   
   return rc;
 90c5014:	e0bff917 	ldw	r2,-28(fp)
}
 90c5018:	e037883a 	mov	sp,fp
 90c501c:	dfc00117 	ldw	ra,4(sp)
 90c5020:	df000017 	ldw	fp,0(sp)
 90c5024:	dec00204 	addi	sp,sp,8
 90c5028:	f800283a 	ret

090c502c <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 90c502c:	defff904 	addi	sp,sp,-28
 90c5030:	dfc00615 	stw	ra,24(sp)
 90c5034:	df000515 	stw	fp,20(sp)
 90c5038:	df000504 	addi	fp,sp,20
 90c503c:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 90c5040:	e0bfff17 	ldw	r2,-4(fp)
 90c5044:	10800617 	ldw	r2,24(r2)
 90c5048:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 90c504c:	e0bfff17 	ldw	r2,-4(fp)
 90c5050:	10800317 	ldw	r2,12(r2)
 90c5054:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 90c5058:	e0bffd17 	ldw	r2,-12(fp)
 90c505c:	10800003 	ldbu	r2,0(r2)
 90c5060:	10803fcc 	andi	r2,r2,255
 90c5064:	108003cc 	andi	r2,r2,15
 90c5068:	1085883a 	add	r2,r2,r2
 90c506c:	1085883a 	add	r2,r2,r2
 90c5070:	1007883a 	mov	r3,r2
 90c5074:	e0bffd17 	ldw	r2,-12(fp)
 90c5078:	1885883a 	add	r2,r3,r2
 90c507c:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 90c5080:	e0bffe17 	ldw	r2,-8(fp)
 90c5084:	11000117 	ldw	r4,4(r2)
 90c5088:	e17ffc17 	ldw	r5,-16(fp)
 90c508c:	90c300c0 	call	90c300c <lookup_mcast>
 90c5090:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 90c5094:	e0bffb17 	ldw	r2,-20(fp)
 90c5098:	1005003a 	cmpeq	r2,r2,zero
 90c509c:	1000291e 	bne	r2,zero,90c5144 <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 90c50a0:	e0bffb17 	ldw	r2,-20(fp)
 90c50a4:	10800317 	ldw	r2,12(r2)
 90c50a8:	1005003a 	cmpeq	r2,r2,zero
 90c50ac:	10001d1e 	bne	r2,zero,90c5124 <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 90c50b0:	e0bffc17 	ldw	r2,-16(fp)
 90c50b4:	10802d03 	ldbu	r2,180(r2)
 90c50b8:	10803fcc 	andi	r2,r2,255
 90c50bc:	1005003a 	cmpeq	r2,r2,zero
 90c50c0:	1000051e 	bne	r2,zero,90c50d8 <igmpv2_process_report+0xac>
 90c50c4:	e0bffe17 	ldw	r2,-8(fp)
 90c50c8:	10800003 	ldbu	r2,0(r2)
 90c50cc:	10803fcc 	andi	r2,r2,255
 90c50d0:	108005a0 	cmpeqi	r2,r2,22
 90c50d4:	1000221e 	bne	r2,zero,90c5160 <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 90c50d8:	e0bffb17 	ldw	r2,-20(fp)
 90c50dc:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 90c50e0:	00824374 	movhi	r2,2317
 90c50e4:	108f0c04 	addi	r2,r2,15408
 90c50e8:	10800017 	ldw	r2,0(r2)
 90c50ec:	10ffffc4 	addi	r3,r2,-1
 90c50f0:	00824374 	movhi	r2,2317
 90c50f4:	108f0c04 	addi	r2,r2,15408
 90c50f8:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 90c50fc:	e0bffb17 	ldw	r2,-20(fp)
 90c5100:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 90c5104:	008243b4 	movhi	r2,2318
 90c5108:	10b5ea04 	addi	r2,r2,-10328
 90c510c:	10800717 	ldw	r2,28(r2)
 90c5110:	10c00044 	addi	r3,r2,1
 90c5114:	008243b4 	movhi	r2,2318
 90c5118:	10b5ea04 	addi	r2,r2,-10328
 90c511c:	10c00715 	stw	r3,28(r2)
 90c5120:	00000f06 	br	90c5160 <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 90c5124:	008243b4 	movhi	r2,2318
 90c5128:	10b5ea04 	addi	r2,r2,-10328
 90c512c:	10800817 	ldw	r2,32(r2)
 90c5130:	10c00044 	addi	r3,r2,1
 90c5134:	008243b4 	movhi	r2,2318
 90c5138:	10b5ea04 	addi	r2,r2,-10328
 90c513c:	10c00815 	stw	r3,32(r2)
 90c5140:	00000706 	br	90c5160 <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 90c5144:	008243b4 	movhi	r2,2318
 90c5148:	10b5ea04 	addi	r2,r2,-10328
 90c514c:	10801317 	ldw	r2,76(r2)
 90c5150:	10c00044 	addi	r3,r2,1
 90c5154:	008243b4 	movhi	r2,2318
 90c5158:	10b5ea04 	addi	r2,r2,-10328
 90c515c:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 90c5160:	0005883a 	mov	r2,zero
}
 90c5164:	e037883a 	mov	sp,fp
 90c5168:	dfc00117 	ldw	ra,4(sp)
 90c516c:	df000017 	ldw	fp,0(sp)
 90c5170:	dec00204 	addi	sp,sp,8
 90c5174:	f800283a 	ret

090c5178 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 90c5178:	defff704 	addi	sp,sp,-36
 90c517c:	dfc00815 	stw	ra,32(sp)
 90c5180:	df000715 	stw	fp,28(sp)
 90c5184:	df000704 	addi	fp,sp,28
 90c5188:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 90c518c:	e0bfff17 	ldw	r2,-4(fp)
 90c5190:	10800617 	ldw	r2,24(r2)
 90c5194:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 90c5198:	e0bfff17 	ldw	r2,-4(fp)
 90c519c:	10800317 	ldw	r2,12(r2)
 90c51a0:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 90c51a4:	e0bffd17 	ldw	r2,-12(fp)
 90c51a8:	10800003 	ldbu	r2,0(r2)
 90c51ac:	10803fcc 	andi	r2,r2,255
 90c51b0:	108003cc 	andi	r2,r2,15
 90c51b4:	1085883a 	add	r2,r2,r2
 90c51b8:	1085883a 	add	r2,r2,r2
 90c51bc:	1007883a 	mov	r3,r2
 90c51c0:	e0bffd17 	ldw	r2,-12(fp)
 90c51c4:	1885883a 	add	r2,r3,r2
 90c51c8:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 90c51cc:	e0bffe17 	ldw	r2,-8(fp)
 90c51d0:	10800117 	ldw	r2,4(r2)
 90c51d4:	1004d63a 	srli	r2,r2,24
 90c51d8:	10c03fcc 	andi	r3,r2,255
 90c51dc:	e0bffe17 	ldw	r2,-8(fp)
 90c51e0:	10800117 	ldw	r2,4(r2)
 90c51e4:	1004d23a 	srli	r2,r2,8
 90c51e8:	10bfc00c 	andi	r2,r2,65280
 90c51ec:	1886b03a 	or	r3,r3,r2
 90c51f0:	e0bffe17 	ldw	r2,-8(fp)
 90c51f4:	10800117 	ldw	r2,4(r2)
 90c51f8:	10bfc00c 	andi	r2,r2,65280
 90c51fc:	1004923a 	slli	r2,r2,8
 90c5200:	1886b03a 	or	r3,r3,r2
 90c5204:	e0bffe17 	ldw	r2,-8(fp)
 90c5208:	10800117 	ldw	r2,4(r2)
 90c520c:	10803fcc 	andi	r2,r2,255
 90c5210:	1004963a 	slli	r2,r2,24
 90c5214:	1884b03a 	or	r2,r3,r2
 90c5218:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 90c521c:	e0bffe17 	ldw	r2,-8(fp)
 90c5220:	10800043 	ldbu	r2,1(r2)
 90c5224:	10803fcc 	andi	r2,r2,255
 90c5228:	1004c03a 	cmpne	r2,r2,zero
 90c522c:	1000141e 	bne	r2,zero,90c5280 <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 90c5230:	e0fffc17 	ldw	r3,-16(fp)
 90c5234:	00800044 	movi	r2,1
 90c5238:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 90c523c:	00824374 	movhi	r2,2317
 90c5240:	108f2e04 	addi	r2,r2,15544
 90c5244:	10c00017 	ldw	r3,0(r2)
 90c5248:	e0bffc17 	ldw	r2,-16(fp)
 90c524c:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 90c5250:	008243b4 	movhi	r2,2318
 90c5254:	10b5ea04 	addi	r2,r2,-10328
 90c5258:	10800417 	ldw	r2,16(r2)
 90c525c:	10c00044 	addi	r3,r2,1
 90c5260:	008243b4 	movhi	r2,2318
 90c5264:	10b5ea04 	addi	r2,r2,-10328
 90c5268:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 90c526c:	00800c84 	movi	r2,50
 90c5270:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 90c5274:	00800044 	movi	r2,1
 90c5278:	e0bffb05 	stb	r2,-20(fp)
 90c527c:	00001d06 	br	90c52f4 <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 90c5280:	e0bffe17 	ldw	r2,-8(fp)
 90c5284:	10800117 	ldw	r2,4(r2)
 90c5288:	1004c03a 	cmpne	r2,r2,zero
 90c528c:	10000a1e 	bne	r2,zero,90c52b8 <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 90c5290:	008243b4 	movhi	r2,2318
 90c5294:	10b5ea04 	addi	r2,r2,-10328
 90c5298:	10800517 	ldw	r2,20(r2)
 90c529c:	10c00044 	addi	r3,r2,1
 90c52a0:	008243b4 	movhi	r2,2318
 90c52a4:	10b5ea04 	addi	r2,r2,-10328
 90c52a8:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 90c52ac:	00800044 	movi	r2,1
 90c52b0:	e0bffb05 	stb	r2,-20(fp)
 90c52b4:	00000806 	br	90c52d8 <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 90c52b8:	008243b4 	movhi	r2,2318
 90c52bc:	10b5ea04 	addi	r2,r2,-10328
 90c52c0:	10800617 	ldw	r2,24(r2)
 90c52c4:	10c00044 	addi	r3,r2,1
 90c52c8:	008243b4 	movhi	r2,2318
 90c52cc:	10b5ea04 	addi	r2,r2,-10328
 90c52d0:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 90c52d4:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 90c52d8:	e0bffe17 	ldw	r2,-8(fp)
 90c52dc:	10800043 	ldbu	r2,1(r2)
 90c52e0:	10c03fcc 	andi	r3,r2,255
 90c52e4:	1804d7fa 	srli	r2,r3,31
 90c52e8:	10c5883a 	add	r2,r2,r3
 90c52ec:	1005d07a 	srai	r2,r2,1
 90c52f0:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 90c52f4:	e0bffb03 	ldbu	r2,-20(fp)
 90c52f8:	1005003a 	cmpeq	r2,r2,zero
 90c52fc:	1000181e 	bne	r2,zero,90c5360 <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c5300:	e0bffc17 	ldw	r2,-16(fp)
 90c5304:	10802c17 	ldw	r2,176(r2)
 90c5308:	e0bffa15 	stw	r2,-24(fp)
 90c530c:	00001006 	br	90c5350 <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 90c5310:	e0bffa17 	ldw	r2,-24(fp)
 90c5314:	10800017 	ldw	r2,0(r2)
 90c5318:	1005003a 	cmpeq	r2,r2,zero
 90c531c:	1000091e 	bne	r2,zero,90c5344 <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 90c5320:	e0bffa17 	ldw	r2,-24(fp)
 90c5324:	10c00017 	ldw	r3,0(r2)
 90c5328:	00824374 	movhi	r2,2317
 90c532c:	108f0e04 	addi	r2,r2,15416
 90c5330:	10800017 	ldw	r2,0(r2)
 90c5334:	18800326 	beq	r3,r2,90c5344 <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 90c5338:	e17ffb8b 	ldhu	r5,-18(fp)
 90c533c:	e13ffa17 	ldw	r4,-24(fp)
 90c5340:	90c53c40 	call	90c53c4 <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 90c5344:	e0bffa17 	ldw	r2,-24(fp)
 90c5348:	10800517 	ldw	r2,20(r2)
 90c534c:	e0bffa15 	stw	r2,-24(fp)
 90c5350:	e0bffa17 	ldw	r2,-24(fp)
 90c5354:	1004c03a 	cmpne	r2,r2,zero
 90c5358:	103fed1e 	bne	r2,zero,90c5310 <igmpv2_process_query+0x198>
 90c535c:	00001306 	br	90c53ac <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 90c5360:	e0bffe17 	ldw	r2,-8(fp)
 90c5364:	11000117 	ldw	r4,4(r2)
 90c5368:	e17ffc17 	ldw	r5,-16(fp)
 90c536c:	90c300c0 	call	90c300c <lookup_mcast>
 90c5370:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 90c5374:	e0bffa17 	ldw	r2,-24(fp)
 90c5378:	1005003a 	cmpeq	r2,r2,zero
 90c537c:	1000041e 	bne	r2,zero,90c5390 <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 90c5380:	e17ffb8b 	ldhu	r5,-18(fp)
 90c5384:	e13ffa17 	ldw	r4,-24(fp)
 90c5388:	90c53c40 	call	90c53c4 <igmpv2_chk_set_timer>
 90c538c:	00000706 	br	90c53ac <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 90c5390:	008243b4 	movhi	r2,2318
 90c5394:	10b5ea04 	addi	r2,r2,-10328
 90c5398:	10801217 	ldw	r2,72(r2)
 90c539c:	10c00044 	addi	r3,r2,1
 90c53a0:	008243b4 	movhi	r2,2318
 90c53a4:	10b5ea04 	addi	r2,r2,-10328
 90c53a8:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 90c53ac:	0005883a 	mov	r2,zero
}
 90c53b0:	e037883a 	mov	sp,fp
 90c53b4:	dfc00117 	ldw	ra,4(sp)
 90c53b8:	df000017 	ldw	fp,0(sp)
 90c53bc:	dec00204 	addi	sp,sp,8
 90c53c0:	f800283a 	ret

090c53c4 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 90c53c4:	defffd04 	addi	sp,sp,-12
 90c53c8:	df000215 	stw	fp,8(sp)
 90c53cc:	df000204 	addi	fp,sp,8
 90c53d0:	e13ffe15 	stw	r4,-8(fp)
 90c53d4:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 90c53d8:	e0bffe17 	ldw	r2,-8(fp)
 90c53dc:	10c00317 	ldw	r3,12(r2)
 90c53e0:	e0bfff0b 	ldhu	r2,-4(fp)
 90c53e4:	10c00436 	bltu	r2,r3,90c53f8 <igmpv2_chk_set_timer+0x34>
 90c53e8:	e0bffe17 	ldw	r2,-8(fp)
 90c53ec:	10800317 	ldw	r2,12(r2)
 90c53f0:	1004c03a 	cmpne	r2,r2,zero
 90c53f4:	1000451e 	bne	r2,zero,90c550c <igmpv2_chk_set_timer+0x148>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 90c53f8:	e0bffe17 	ldw	r2,-8(fp)
 90c53fc:	10800317 	ldw	r2,12(r2)
 90c5400:	1004c03a 	cmpne	r2,r2,zero
 90c5404:	1000071e 	bne	r2,zero,90c5424 <igmpv2_chk_set_timer+0x60>
 90c5408:	00824374 	movhi	r2,2317
 90c540c:	108f0c04 	addi	r2,r2,15408
 90c5410:	10800017 	ldw	r2,0(r2)
 90c5414:	10c00044 	addi	r3,r2,1
 90c5418:	00824374 	movhi	r2,2317
 90c541c:	108f0c04 	addi	r2,r2,15408
 90c5420:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 90c5424:	008243b4 	movhi	r2,2318
 90c5428:	10b82c04 	addi	r2,r2,-8016
 90c542c:	11000217 	ldw	r4,8(r2)
 90c5430:	008243b4 	movhi	r2,2318
 90c5434:	10b5e604 	addi	r2,r2,-10344
 90c5438:	10800017 	ldw	r2,0(r2)
 90c543c:	10800a17 	ldw	r2,40(r2)
 90c5440:	1004d63a 	srli	r2,r2,24
 90c5444:	10c03fcc 	andi	r3,r2,255
 90c5448:	008243b4 	movhi	r2,2318
 90c544c:	10b5e604 	addi	r2,r2,-10344
 90c5450:	10800017 	ldw	r2,0(r2)
 90c5454:	10800a17 	ldw	r2,40(r2)
 90c5458:	1004d23a 	srli	r2,r2,8
 90c545c:	10bfc00c 	andi	r2,r2,65280
 90c5460:	1886b03a 	or	r3,r3,r2
 90c5464:	008243b4 	movhi	r2,2318
 90c5468:	10b5e604 	addi	r2,r2,-10344
 90c546c:	10800017 	ldw	r2,0(r2)
 90c5470:	10800a17 	ldw	r2,40(r2)
 90c5474:	10bfc00c 	andi	r2,r2,65280
 90c5478:	1004923a 	slli	r2,r2,8
 90c547c:	1886b03a 	or	r3,r3,r2
 90c5480:	008243b4 	movhi	r2,2318
 90c5484:	10b5e604 	addi	r2,r2,-10344
 90c5488:	10800017 	ldw	r2,0(r2)
 90c548c:	10800a17 	ldw	r2,40(r2)
 90c5490:	10803fcc 	andi	r2,r2,255
 90c5494:	1004963a 	slli	r2,r2,24
 90c5498:	1884b03a 	or	r2,r3,r2
 90c549c:	2089883a 	add	r4,r4,r2
 90c54a0:	e0bffe17 	ldw	r2,-8(fp)
 90c54a4:	10800017 	ldw	r2,0(r2)
 90c54a8:	1004d63a 	srli	r2,r2,24
 90c54ac:	10c03fcc 	andi	r3,r2,255
 90c54b0:	e0bffe17 	ldw	r2,-8(fp)
 90c54b4:	10800017 	ldw	r2,0(r2)
 90c54b8:	1004d23a 	srli	r2,r2,8
 90c54bc:	10bfc00c 	andi	r2,r2,65280
 90c54c0:	1886b03a 	or	r3,r3,r2
 90c54c4:	e0bffe17 	ldw	r2,-8(fp)
 90c54c8:	10800017 	ldw	r2,0(r2)
 90c54cc:	10bfc00c 	andi	r2,r2,65280
 90c54d0:	1004923a 	slli	r2,r2,8
 90c54d4:	1886b03a 	or	r3,r3,r2
 90c54d8:	e0bffe17 	ldw	r2,-8(fp)
 90c54dc:	10800017 	ldw	r2,0(r2)
 90c54e0:	10803fcc 	andi	r2,r2,255
 90c54e4:	1004963a 	slli	r2,r2,24
 90c54e8:	1884b03a 	or	r2,r3,r2
 90c54ec:	2089883a 	add	r4,r4,r2
 90c54f0:	e0ffff0b 	ldhu	r3,-4(fp)
 90c54f4:	20c5203a 	divu	r2,r4,r3
 90c54f8:	10c5383a 	mul	r2,r2,r3
 90c54fc:	2085c83a 	sub	r2,r4,r2
 90c5500:	10c00044 	addi	r3,r2,1
 90c5504:	e0bffe17 	ldw	r2,-8(fp)
 90c5508:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 90c550c:	e037883a 	mov	sp,fp
 90c5510:	df000017 	ldw	fp,0(sp)
 90c5514:	dec00104 	addi	sp,sp,4
 90c5518:	f800283a 	ret

090c551c <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 90c551c:	defff904 	addi	sp,sp,-28
 90c5520:	df000615 	stw	fp,24(sp)
 90c5524:	df000604 	addi	fp,sp,24
 90c5528:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 90c552c:	e0bffd17 	ldw	r2,-12(fp)
 90c5530:	10800003 	ldbu	r2,0(r2)
 90c5534:	108003cc 	andi	r2,r2,15
 90c5538:	1085883a 	add	r2,r2,r2
 90c553c:	1085883a 	add	r2,r2,r2
 90c5540:	10bffb04 	addi	r2,r2,-20
 90c5544:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 90c5548:	e0bffa83 	ldbu	r2,-22(fp)
 90c554c:	1005003a 	cmpeq	r2,r2,zero
 90c5550:	1000481e 	bne	r2,zero,90c5674 <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 90c5554:	e0bffd17 	ldw	r2,-12(fp)
 90c5558:	10800504 	addi	r2,r2,20
 90c555c:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 90c5560:	00004106 	br	90c5668 <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 90c5564:	e0bffc17 	ldw	r2,-16(fp)
 90c5568:	10800003 	ldbu	r2,0(r2)
 90c556c:	108007cc 	andi	r2,r2,31
 90c5570:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 90c5574:	e0bffa03 	ldbu	r2,-24(fp)
 90c5578:	e0bfff15 	stw	r2,-4(fp)
 90c557c:	e0ffff17 	ldw	r3,-4(fp)
 90c5580:	18800060 	cmpeqi	r2,r3,1
 90c5584:	10000b1e 	bne	r2,zero,90c55b4 <igmpv2_chk4_rtr_alert_opt+0x98>
 90c5588:	e0ffff17 	ldw	r3,-4(fp)
 90c558c:	18800520 	cmpeqi	r2,r3,20
 90c5590:	10000b1e 	bne	r2,zero,90c55c0 <igmpv2_chk4_rtr_alert_opt+0xa4>
 90c5594:	e0ffff17 	ldw	r3,-4(fp)
 90c5598:	1805003a 	cmpeq	r2,r3,zero
 90c559c:	1000011e 	bne	r2,zero,90c55a4 <igmpv2_chk4_rtr_alert_opt+0x88>
 90c55a0:	00002306 	br	90c5630 <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 90c55a4:	00800044 	movi	r2,1
 90c55a8:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 90c55ac:	e03ffe15 	stw	zero,-8(fp)
 90c55b0:	00003106 	br	90c5678 <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 90c55b4:	00800044 	movi	r2,1
 90c55b8:	e0bffa45 	stb	r2,-23(fp)
               break;
 90c55bc:	00002106 	br	90c5644 <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 90c55c0:	e0bffc17 	ldw	r2,-16(fp)
 90c55c4:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 90c55c8:	e0bffb17 	ldw	r2,-20(fp)
 90c55cc:	10800017 	ldw	r2,0(r2)
 90c55d0:	1004d63a 	srli	r2,r2,24
 90c55d4:	10c03fcc 	andi	r3,r2,255
 90c55d8:	e0bffb17 	ldw	r2,-20(fp)
 90c55dc:	10800017 	ldw	r2,0(r2)
 90c55e0:	1004d23a 	srli	r2,r2,8
 90c55e4:	10bfc00c 	andi	r2,r2,65280
 90c55e8:	1886b03a 	or	r3,r3,r2
 90c55ec:	e0bffb17 	ldw	r2,-20(fp)
 90c55f0:	10800017 	ldw	r2,0(r2)
 90c55f4:	10bfc00c 	andi	r2,r2,65280
 90c55f8:	1004923a 	slli	r2,r2,8
 90c55fc:	1886b03a 	or	r3,r3,r2
 90c5600:	e0bffb17 	ldw	r2,-20(fp)
 90c5604:	10800017 	ldw	r2,0(r2)
 90c5608:	10803fcc 	andi	r2,r2,255
 90c560c:	1004963a 	slli	r2,r2,24
 90c5610:	1886b03a 	or	r3,r3,r2
 90c5614:	00a50134 	movhi	r2,37892
 90c5618:	1880031e 	bne	r3,r2,90c5628 <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 90c561c:	00800044 	movi	r2,1
 90c5620:	e0bffe15 	stw	r2,-8(fp)
 90c5624:	00001406 	br	90c5678 <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 90c5628:	e03ffe15 	stw	zero,-8(fp)
 90c562c:	00001206 	br	90c5678 <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 90c5630:	e0bffc17 	ldw	r2,-16(fp)
 90c5634:	10800044 	addi	r2,r2,1
 90c5638:	10800003 	ldbu	r2,0(r2)
 90c563c:	10800084 	addi	r2,r2,2
 90c5640:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 90c5644:	e0bffa43 	ldbu	r2,-23(fp)
 90c5648:	1007883a 	mov	r3,r2
 90c564c:	e0bffc17 	ldw	r2,-16(fp)
 90c5650:	10c5883a 	add	r2,r2,r3
 90c5654:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 90c5658:	e0fffa83 	ldbu	r3,-22(fp)
 90c565c:	e0bffa43 	ldbu	r2,-23(fp)
 90c5660:	1885c83a 	sub	r2,r3,r2
 90c5664:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 90c5668:	e0bffa83 	ldbu	r2,-22(fp)
 90c566c:	1004c03a 	cmpne	r2,r2,zero
 90c5670:	103fbc1e 	bne	r2,zero,90c5564 <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 90c5674:	e03ffe15 	stw	zero,-8(fp)
 90c5678:	e0bffe17 	ldw	r2,-8(fp)
}
 90c567c:	e037883a 	mov	sp,fp
 90c5680:	df000017 	ldw	fp,0(sp)
 90c5684:	dec00104 	addi	sp,sp,4
 90c5688:	f800283a 	ret

090c568c <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 90c568c:	defffc04 	addi	sp,sp,-16
 90c5690:	df000315 	stw	fp,12(sp)
 90c5694:	df000304 	addi	fp,sp,12
 90c5698:	e13ffe15 	stw	r4,-8(fp)
 90c569c:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 90c56a0:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 90c56a4:	e0bffd0b 	ldhu	r2,-12(fp)
 90c56a8:	00c243b4 	movhi	r3,2318
 90c56ac:	18f5e604 	addi	r3,r3,-10344
 90c56b0:	1085883a 	add	r2,r2,r2
 90c56b4:	1085883a 	add	r2,r2,r2
 90c56b8:	10c5883a 	add	r2,r2,r3
 90c56bc:	10c00017 	ldw	r3,0(r2)
 90c56c0:	e0bfff17 	ldw	r2,-4(fp)
 90c56c4:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 90c56c8:	e0bffe17 	ldw	r2,-8(fp)
 90c56cc:	1004c03a 	cmpne	r2,r2,zero
 90c56d0:	1000331e 	bne	r2,zero,90c57a0 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 90c56d4:	e03ffd0d 	sth	zero,-12(fp)
 90c56d8:	00001706 	br	90c5738 <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 90c56dc:	e0bffd0b 	ldhu	r2,-12(fp)
 90c56e0:	00c243b4 	movhi	r3,2318
 90c56e4:	18f5e604 	addi	r3,r3,-10344
 90c56e8:	1085883a 	add	r2,r2,r2
 90c56ec:	1085883a 	add	r2,r2,r2
 90c56f0:	10c5883a 	add	r2,r2,r3
 90c56f4:	10800017 	ldw	r2,0(r2)
 90c56f8:	10802b17 	ldw	r2,172(r2)
 90c56fc:	1005003a 	cmpeq	r2,r2,zero
 90c5700:	10000a1e 	bne	r2,zero,90c572c <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 90c5704:	e0bffd0b 	ldhu	r2,-12(fp)
 90c5708:	00c243b4 	movhi	r3,2318
 90c570c:	18f5e604 	addi	r3,r3,-10344
 90c5710:	1085883a 	add	r2,r2,r2
 90c5714:	1085883a 	add	r2,r2,r2
 90c5718:	10c5883a 	add	r2,r2,r3
 90c571c:	10c00017 	ldw	r3,0(r2)
 90c5720:	e0bfff17 	ldw	r2,-4(fp)
 90c5724:	10c00015 	stw	r3,0(r2)
            break;
 90c5728:	00002606 	br	90c57c4 <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 90c572c:	e0bffd0b 	ldhu	r2,-12(fp)
 90c5730:	10800044 	addi	r2,r2,1
 90c5734:	e0bffd0d 	sth	r2,-12(fp)
 90c5738:	e0bffd0b 	ldhu	r2,-12(fp)
 90c573c:	00c24374 	movhi	r3,2317
 90c5740:	18cf0a04 	addi	r3,r3,15400
 90c5744:	18c00017 	ldw	r3,0(r3)
 90c5748:	10ffe436 	bltu	r2,r3,90c56dc <IPADDR_TO_NETP+0x50>
 90c574c:	00001d06 	br	90c57c4 <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 90c5750:	e0bffd0b 	ldhu	r2,-12(fp)
 90c5754:	10800044 	addi	r2,r2,1
 90c5758:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 90c575c:	e0fffd0b 	ldhu	r3,-12(fp)
 90c5760:	00824374 	movhi	r2,2317
 90c5764:	108f0a04 	addi	r2,r2,15400
 90c5768:	10800017 	ldw	r2,0(r2)
 90c576c:	18800336 	bltu	r3,r2,90c577c <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 90c5770:	e0bfff17 	ldw	r2,-4(fp)
 90c5774:	10000015 	stw	zero,0(r2)
            break;
 90c5778:	00001206 	br	90c57c4 <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 90c577c:	e0bffd0b 	ldhu	r2,-12(fp)
 90c5780:	00c243b4 	movhi	r3,2318
 90c5784:	18f5e604 	addi	r3,r3,-10344
 90c5788:	1085883a 	add	r2,r2,r2
 90c578c:	1085883a 	add	r2,r2,r2
 90c5790:	10c5883a 	add	r2,r2,r3
 90c5794:	10c00017 	ldw	r3,0(r2)
 90c5798:	e0bfff17 	ldw	r2,-4(fp)
 90c579c:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 90c57a0:	e0bfff17 	ldw	r2,-4(fp)
 90c57a4:	10800017 	ldw	r2,0(r2)
 90c57a8:	1005003a 	cmpeq	r2,r2,zero
 90c57ac:	1000051e 	bne	r2,zero,90c57c4 <IPADDR_TO_NETP+0x138>
 90c57b0:	e0bfff17 	ldw	r2,-4(fp)
 90c57b4:	10800017 	ldw	r2,0(r2)
 90c57b8:	10c00a17 	ldw	r3,40(r2)
 90c57bc:	e0bffe17 	ldw	r2,-8(fp)
 90c57c0:	18bfe31e 	bne	r3,r2,90c5750 <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 90c57c4:	e037883a 	mov	sp,fp
 90c57c8:	df000017 	ldw	fp,0(sp)
 90c57cc:	dec00104 	addi	sp,sp,4
 90c57d0:	f800283a 	ret

090c57d4 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 90c57d4:	defff104 	addi	sp,sp,-60
 90c57d8:	dfc00e15 	stw	ra,56(sp)
 90c57dc:	df000d15 	stw	fp,52(sp)
 90c57e0:	dc000c15 	stw	r16,48(sp)
 90c57e4:	df000c04 	addi	fp,sp,48
 90c57e8:	e13ffb15 	stw	r4,-20(fp)
 90c57ec:	e17ffc15 	stw	r5,-16(fp)
 90c57f0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 90c57f4:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 90c57f8:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 90c57fc:	e0bffc17 	ldw	r2,-16(fp)
 90c5800:	10800317 	ldw	r2,12(r2)
 90c5804:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 90c5808:	e0bffc17 	ldw	r2,-16(fp)
 90c580c:	10800304 	addi	r2,r2,12
 90c5810:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 90c5814:	e0bff617 	ldw	r2,-40(fp)
 90c5818:	1004c03a 	cmpne	r2,r2,zero
 90c581c:	1000161e 	bne	r2,zero,90c5878 <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 90c5820:	01001604 	movi	r4,88
 90c5824:	90aaefc0 	call	90aaefc <npalloc>
 90c5828:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 90c582c:	e0bff617 	ldw	r2,-40(fp)
 90c5830:	1004c03a 	cmpne	r2,r2,zero
 90c5834:	1000031e 	bne	r2,zero,90c5844 <ip_setmoptions+0x70>
         return (ENOBUFS);
 90c5838:	00801a44 	movi	r2,105
 90c583c:	e0bffe15 	stw	r2,-8(fp)
 90c5840:	00015906 	br	90c5da8 <ip_setmoptions+0x5d4>
      *imop = imo;
 90c5844:	e0fff517 	ldw	r3,-44(fp)
 90c5848:	e0bff617 	ldw	r2,-40(fp)
 90c584c:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 90c5850:	e0bff617 	ldw	r2,-40(fp)
 90c5854:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 90c5858:	e0fff617 	ldw	r3,-40(fp)
 90c585c:	00800044 	movi	r2,1
 90c5860:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 90c5864:	e0fff617 	ldw	r3,-40(fp)
 90c5868:	00800044 	movi	r2,1
 90c586c:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 90c5870:	e0bff617 	ldw	r2,-40(fp)
 90c5874:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 90c5878:	e0bffb17 	ldw	r2,-20(fp)
 90c587c:	10bffdc4 	addi	r2,r2,-9
 90c5880:	e0bfff15 	stw	r2,-4(fp)
 90c5884:	e0ffff17 	ldw	r3,-4(fp)
 90c5888:	18800168 	cmpgeui	r2,r3,5
 90c588c:	10012a1e 	bne	r2,zero,90c5d38 <ip_setmoptions+0x564>
 90c5890:	e13fff17 	ldw	r4,-4(fp)
 90c5894:	e13fff17 	ldw	r4,-4(fp)
 90c5898:	2105883a 	add	r2,r4,r4
 90c589c:	1087883a 	add	r3,r2,r2
 90c58a0:	00824334 	movhi	r2,2316
 90c58a4:	10962d04 	addi	r2,r2,22708
 90c58a8:	1885883a 	add	r2,r3,r2
 90c58ac:	10800017 	ldw	r2,0(r2)
 90c58b0:	1000683a 	jmp	r2
 90c58b4:	090c58c8 	cmpgei	r4,at,12643
 90c58b8:	090c593c 	xorhi	r4,at,12644
 90c58bc:	090c5950 	cmplti	r4,at,12645
 90c58c0:	090c5984 	addi	r4,at,12646
 90c58c4:	090c5b54 	ori	r4,at,12653

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 90c58c8:	e0bffd17 	ldw	r2,-12(fp)
 90c58cc:	10800017 	ldw	r2,0(r2)
 90c58d0:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 90c58d4:	e0bff417 	ldw	r2,-48(fp)
 90c58d8:	1004c03a 	cmpne	r2,r2,zero
 90c58dc:	1000031e 	bne	r2,zero,90c58ec <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 90c58e0:	e0bff617 	ldw	r2,-40(fp)
 90c58e4:	10000015 	stw	zero,0(r2)
         break;
 90c58e8:	00011506 	br	90c5d40 <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 90c58ec:	e17ffa04 	addi	r5,fp,-24
 90c58f0:	e13ff417 	ldw	r4,-48(fp)
 90c58f4:	90c568c0 	call	90c568c <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 90c58f8:	e0bffa17 	ldw	r2,-24(fp)
 90c58fc:	1005003a 	cmpeq	r2,r2,zero
 90c5900:	1000041e 	bne	r2,zero,90c5914 <ip_setmoptions+0x140>
 90c5904:	e0bffa17 	ldw	r2,-24(fp)
 90c5908:	10802b17 	ldw	r2,172(r2)
 90c590c:	1004c03a 	cmpne	r2,r2,zero
 90c5910:	1000031e 	bne	r2,zero,90c5920 <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 90c5914:	00801f44 	movi	r2,125
 90c5918:	e0bff915 	stw	r2,-28(fp)
         break;
 90c591c:	00010806 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 90c5920:	e0bff417 	ldw	r2,-48(fp)
 90c5924:	1005003a 	cmpeq	r2,r2,zero
 90c5928:	1001051e 	bne	r2,zero,90c5d40 <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 90c592c:	e0fffa17 	ldw	r3,-24(fp)
 90c5930:	e0bff617 	ldw	r2,-40(fp)
 90c5934:	10c00015 	stw	r3,0(r2)
      break;
 90c5938:	00010106 	br	90c5d40 <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 90c593c:	e0bffd17 	ldw	r2,-12(fp)
 90c5940:	10c00003 	ldbu	r3,0(r2)
 90c5944:	e0bff617 	ldw	r2,-40(fp)
 90c5948:	10c00105 	stb	r3,4(r2)
      break;
 90c594c:	0000fc06 	br	90c5d40 <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 90c5950:	e0bffd17 	ldw	r2,-12(fp)
 90c5954:	10800003 	ldbu	r2,0(r2)
 90c5958:	10803fcc 	andi	r2,r2,255
 90c595c:	108000b0 	cmpltui	r2,r2,2
 90c5960:	1000031e 	bne	r2,zero,90c5970 <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 90c5964:	00800584 	movi	r2,22
 90c5968:	e0bff915 	stw	r2,-28(fp)
         break;
 90c596c:	0000f406 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 90c5970:	e0bffd17 	ldw	r2,-12(fp)
 90c5974:	10c00003 	ldbu	r3,0(r2)
 90c5978:	e0bff617 	ldw	r2,-40(fp)
 90c597c:	10c00145 	stb	r3,5(r2)
      break;
 90c5980:	0000ef06 	br	90c5d40 <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 90c5984:	e0bffd17 	ldw	r2,-12(fp)
 90c5988:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 90c598c:	e0bff717 	ldw	r2,-36(fp)
 90c5990:	10800017 	ldw	r2,0(r2)
 90c5994:	1004d63a 	srli	r2,r2,24
 90c5998:	10c03fcc 	andi	r3,r2,255
 90c599c:	e0bff717 	ldw	r2,-36(fp)
 90c59a0:	10800017 	ldw	r2,0(r2)
 90c59a4:	1004d23a 	srli	r2,r2,8
 90c59a8:	10bfc00c 	andi	r2,r2,65280
 90c59ac:	1886b03a 	or	r3,r3,r2
 90c59b0:	e0bff717 	ldw	r2,-36(fp)
 90c59b4:	10800017 	ldw	r2,0(r2)
 90c59b8:	10bfc00c 	andi	r2,r2,65280
 90c59bc:	1004923a 	slli	r2,r2,8
 90c59c0:	1886b03a 	or	r3,r3,r2
 90c59c4:	e0bff717 	ldw	r2,-36(fp)
 90c59c8:	10800017 	ldw	r2,0(r2)
 90c59cc:	10803fcc 	andi	r2,r2,255
 90c59d0:	1004963a 	slli	r2,r2,24
 90c59d4:	1884b03a 	or	r2,r3,r2
 90c59d8:	10fc002c 	andhi	r3,r2,61440
 90c59dc:	00b80034 	movhi	r2,57344
 90c59e0:	18800326 	beq	r3,r2,90c59f0 <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 90c59e4:	00800584 	movi	r2,22
 90c59e8:	e0bff915 	stw	r2,-28(fp)
         break;
 90c59ec:	0000d406 	br	90c5d40 <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 90c59f0:	e0bff717 	ldw	r2,-36(fp)
 90c59f4:	11000117 	ldw	r4,4(r2)
 90c59f8:	e17ffa04 	addi	r5,fp,-24
 90c59fc:	90c568c0 	call	90c568c <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 90c5a00:	e0bffa17 	ldw	r2,-24(fp)
 90c5a04:	1005003a 	cmpeq	r2,r2,zero
 90c5a08:	1000041e 	bne	r2,zero,90c5a1c <ip_setmoptions+0x248>
 90c5a0c:	e0bffa17 	ldw	r2,-24(fp)
 90c5a10:	10802b17 	ldw	r2,172(r2)
 90c5a14:	1004c03a 	cmpne	r2,r2,zero
 90c5a18:	1000031e 	bne	r2,zero,90c5a28 <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 90c5a1c:	00801f44 	movi	r2,125
 90c5a20:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5a24:	0000c606 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c5a28:	e03ff80d 	sth	zero,-32(fp)
 90c5a2c:	00001806 	br	90c5a90 <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 90c5a30:	e0bff80b 	ldhu	r2,-32(fp)
 90c5a34:	e0fff617 	ldw	r3,-40(fp)
 90c5a38:	1085883a 	add	r2,r2,r2
 90c5a3c:	1085883a 	add	r2,r2,r2
 90c5a40:	10c5883a 	add	r2,r2,r3
 90c5a44:	10800204 	addi	r2,r2,8
 90c5a48:	10800017 	ldw	r2,0(r2)
 90c5a4c:	10c00117 	ldw	r3,4(r2)
 90c5a50:	e0bffa17 	ldw	r2,-24(fp)
 90c5a54:	18800b1e 	bne	r3,r2,90c5a84 <ip_setmoptions+0x2b0>
 90c5a58:	e0bff80b 	ldhu	r2,-32(fp)
 90c5a5c:	e0fff617 	ldw	r3,-40(fp)
 90c5a60:	1085883a 	add	r2,r2,r2
 90c5a64:	1085883a 	add	r2,r2,r2
 90c5a68:	10c5883a 	add	r2,r2,r3
 90c5a6c:	10800204 	addi	r2,r2,8
 90c5a70:	10800017 	ldw	r2,0(r2)
 90c5a74:	10c00017 	ldw	r3,0(r2)
 90c5a78:	e0bff717 	ldw	r2,-36(fp)
 90c5a7c:	10800017 	ldw	r2,0(r2)
 90c5a80:	18800826 	beq	r3,r2,90c5aa4 <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c5a84:	e0bff80b 	ldhu	r2,-32(fp)
 90c5a88:	10800044 	addi	r2,r2,1
 90c5a8c:	e0bff80d 	sth	r2,-32(fp)
 90c5a90:	e0bff617 	ldw	r2,-40(fp)
 90c5a94:	1080018b 	ldhu	r2,6(r2)
 90c5a98:	10ffffcc 	andi	r3,r2,65535
 90c5a9c:	e0bff80b 	ldhu	r2,-32(fp)
 90c5aa0:	10ffe336 	bltu	r2,r3,90c5a30 <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 90c5aa4:	e0bff617 	ldw	r2,-40(fp)
 90c5aa8:	1080018b 	ldhu	r2,6(r2)
 90c5aac:	10ffffcc 	andi	r3,r2,65535
 90c5ab0:	e0bff80b 	ldhu	r2,-32(fp)
 90c5ab4:	10c0032e 	bgeu	r2,r3,90c5ac4 <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 90c5ab8:	00801c04 	movi	r2,112
 90c5abc:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5ac0:	00009f06 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 90c5ac4:	e0bff80b 	ldhu	r2,-32(fp)
 90c5ac8:	10800518 	cmpnei	r2,r2,20
 90c5acc:	1000031e 	bne	r2,zero,90c5adc <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 90c5ad0:	00802044 	movi	r2,129
 90c5ad4:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5ad8:	00009906 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 90c5adc:	e43ff80b 	ldhu	r16,-32(fp)
 90c5ae0:	e13ff717 	ldw	r4,-36(fp)
 90c5ae4:	e17ffa17 	ldw	r5,-24(fp)
 90c5ae8:	01800104 	movi	r6,4
 90c5aec:	90c2d8c0 	call	90c2d8c <in_addmulti>
 90c5af0:	1009883a 	mov	r4,r2
 90c5af4:	e0fff617 	ldw	r3,-40(fp)
 90c5af8:	8405883a 	add	r2,r16,r16
 90c5afc:	1085883a 	add	r2,r2,r2
 90c5b00:	10c5883a 	add	r2,r2,r3
 90c5b04:	10800204 	addi	r2,r2,8
 90c5b08:	11000015 	stw	r4,0(r2)
 90c5b0c:	e0fff617 	ldw	r3,-40(fp)
 90c5b10:	8405883a 	add	r2,r16,r16
 90c5b14:	1085883a 	add	r2,r2,r2
 90c5b18:	10c5883a 	add	r2,r2,r3
 90c5b1c:	10800204 	addi	r2,r2,8
 90c5b20:	10800017 	ldw	r2,0(r2)
 90c5b24:	1004c03a 	cmpne	r2,r2,zero
 90c5b28:	1000031e 	bne	r2,zero,90c5b38 <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 90c5b2c:	00801a44 	movi	r2,105
 90c5b30:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5b34:	00008206 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 90c5b38:	e0bff617 	ldw	r2,-40(fp)
 90c5b3c:	1080018b 	ldhu	r2,6(r2)
 90c5b40:	10800044 	addi	r2,r2,1
 90c5b44:	1007883a 	mov	r3,r2
 90c5b48:	e0bff617 	ldw	r2,-40(fp)
 90c5b4c:	10c0018d 	sth	r3,6(r2)
      break;
 90c5b50:	00007b06 	br	90c5d40 <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 90c5b54:	e0bffd17 	ldw	r2,-12(fp)
 90c5b58:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 90c5b5c:	e0bff717 	ldw	r2,-36(fp)
 90c5b60:	10800017 	ldw	r2,0(r2)
 90c5b64:	1004d63a 	srli	r2,r2,24
 90c5b68:	10c03fcc 	andi	r3,r2,255
 90c5b6c:	e0bff717 	ldw	r2,-36(fp)
 90c5b70:	10800017 	ldw	r2,0(r2)
 90c5b74:	1004d23a 	srli	r2,r2,8
 90c5b78:	10bfc00c 	andi	r2,r2,65280
 90c5b7c:	1886b03a 	or	r3,r3,r2
 90c5b80:	e0bff717 	ldw	r2,-36(fp)
 90c5b84:	10800017 	ldw	r2,0(r2)
 90c5b88:	10bfc00c 	andi	r2,r2,65280
 90c5b8c:	1004923a 	slli	r2,r2,8
 90c5b90:	1886b03a 	or	r3,r3,r2
 90c5b94:	e0bff717 	ldw	r2,-36(fp)
 90c5b98:	10800017 	ldw	r2,0(r2)
 90c5b9c:	10803fcc 	andi	r2,r2,255
 90c5ba0:	1004963a 	slli	r2,r2,24
 90c5ba4:	1884b03a 	or	r2,r3,r2
 90c5ba8:	10fc002c 	andhi	r3,r2,61440
 90c5bac:	00b80034 	movhi	r2,57344
 90c5bb0:	18800326 	beq	r3,r2,90c5bc0 <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 90c5bb4:	00800584 	movi	r2,22
 90c5bb8:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5bbc:	00006006 	br	90c5d40 <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 90c5bc0:	e0bff717 	ldw	r2,-36(fp)
 90c5bc4:	11000117 	ldw	r4,4(r2)
 90c5bc8:	e17ffa04 	addi	r5,fp,-24
 90c5bcc:	90c568c0 	call	90c568c <IPADDR_TO_NETP>
      if (netp == NULL) 
 90c5bd0:	e0bffa17 	ldw	r2,-24(fp)
 90c5bd4:	1004c03a 	cmpne	r2,r2,zero
 90c5bd8:	1000031e 	bne	r2,zero,90c5be8 <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 90c5bdc:	00801f44 	movi	r2,125
 90c5be0:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5be4:	00005606 	br	90c5d40 <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c5be8:	e03ff80d 	sth	zero,-32(fp)
 90c5bec:	00001b06 	br	90c5c5c <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 90c5bf0:	e0bffa17 	ldw	r2,-24(fp)
 90c5bf4:	1005003a 	cmpeq	r2,r2,zero
 90c5bf8:	10000a1e 	bne	r2,zero,90c5c24 <ip_setmoptions+0x450>
 90c5bfc:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c00:	e0fff617 	ldw	r3,-40(fp)
 90c5c04:	1085883a 	add	r2,r2,r2
 90c5c08:	1085883a 	add	r2,r2,r2
 90c5c0c:	10c5883a 	add	r2,r2,r3
 90c5c10:	10800204 	addi	r2,r2,8
 90c5c14:	10800017 	ldw	r2,0(r2)
 90c5c18:	10c00117 	ldw	r3,4(r2)
 90c5c1c:	e0bffa17 	ldw	r2,-24(fp)
 90c5c20:	18800b1e 	bne	r3,r2,90c5c50 <ip_setmoptions+0x47c>
 90c5c24:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c28:	e0fff617 	ldw	r3,-40(fp)
 90c5c2c:	1085883a 	add	r2,r2,r2
 90c5c30:	1085883a 	add	r2,r2,r2
 90c5c34:	10c5883a 	add	r2,r2,r3
 90c5c38:	10800204 	addi	r2,r2,8
 90c5c3c:	10800017 	ldw	r2,0(r2)
 90c5c40:	10c00017 	ldw	r3,0(r2)
 90c5c44:	e0bff717 	ldw	r2,-36(fp)
 90c5c48:	10800017 	ldw	r2,0(r2)
 90c5c4c:	18800826 	beq	r3,r2,90c5c70 <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 90c5c50:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c54:	10800044 	addi	r2,r2,1
 90c5c58:	e0bff80d 	sth	r2,-32(fp)
 90c5c5c:	e0bff617 	ldw	r2,-40(fp)
 90c5c60:	1080018b 	ldhu	r2,6(r2)
 90c5c64:	10ffffcc 	andi	r3,r2,65535
 90c5c68:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c6c:	10ffe036 	bltu	r2,r3,90c5bf0 <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 90c5c70:	e0bff617 	ldw	r2,-40(fp)
 90c5c74:	1080018b 	ldhu	r2,6(r2)
 90c5c78:	10ffffcc 	andi	r3,r2,65535
 90c5c7c:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c80:	1880031e 	bne	r3,r2,90c5c90 <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 90c5c84:	00801f44 	movi	r2,125
 90c5c88:	e0bff915 	stw	r2,-28(fp)
         break;
 90c5c8c:	00002c06 	br	90c5d40 <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 90c5c90:	e0bff80b 	ldhu	r2,-32(fp)
 90c5c94:	e0fff617 	ldw	r3,-40(fp)
 90c5c98:	1085883a 	add	r2,r2,r2
 90c5c9c:	1085883a 	add	r2,r2,r2
 90c5ca0:	10c5883a 	add	r2,r2,r3
 90c5ca4:	10800204 	addi	r2,r2,8
 90c5ca8:	11000017 	ldw	r4,0(r2)
 90c5cac:	90c2ef40 	call	90c2ef4 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 90c5cb0:	e0bff80b 	ldhu	r2,-32(fp)
 90c5cb4:	10800044 	addi	r2,r2,1
 90c5cb8:	e0bff80d 	sth	r2,-32(fp)
 90c5cbc:	00001206 	br	90c5d08 <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 90c5cc0:	e0bff80b 	ldhu	r2,-32(fp)
 90c5cc4:	113fffc4 	addi	r4,r2,-1
 90c5cc8:	e0bff80b 	ldhu	r2,-32(fp)
 90c5ccc:	e0fff617 	ldw	r3,-40(fp)
 90c5cd0:	1085883a 	add	r2,r2,r2
 90c5cd4:	1085883a 	add	r2,r2,r2
 90c5cd8:	10c5883a 	add	r2,r2,r3
 90c5cdc:	10800204 	addi	r2,r2,8
 90c5ce0:	11400017 	ldw	r5,0(r2)
 90c5ce4:	e0fff617 	ldw	r3,-40(fp)
 90c5ce8:	2105883a 	add	r2,r4,r4
 90c5cec:	1085883a 	add	r2,r2,r2
 90c5cf0:	10c5883a 	add	r2,r2,r3
 90c5cf4:	10800204 	addi	r2,r2,8
 90c5cf8:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 90c5cfc:	e0bff80b 	ldhu	r2,-32(fp)
 90c5d00:	10800044 	addi	r2,r2,1
 90c5d04:	e0bff80d 	sth	r2,-32(fp)
 90c5d08:	e0bff617 	ldw	r2,-40(fp)
 90c5d0c:	1080018b 	ldhu	r2,6(r2)
 90c5d10:	10ffffcc 	andi	r3,r2,65535
 90c5d14:	e0bff80b 	ldhu	r2,-32(fp)
 90c5d18:	10ffe936 	bltu	r2,r3,90c5cc0 <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 90c5d1c:	e0bff617 	ldw	r2,-40(fp)
 90c5d20:	1080018b 	ldhu	r2,6(r2)
 90c5d24:	10bfffc4 	addi	r2,r2,-1
 90c5d28:	1007883a 	mov	r3,r2
 90c5d2c:	e0bff617 	ldw	r2,-40(fp)
 90c5d30:	10c0018d 	sth	r3,6(r2)
      break;
 90c5d34:	00000206 	br	90c5d40 <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 90c5d38:	008017c4 	movi	r2,95
 90c5d3c:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 90c5d40:	e0bff617 	ldw	r2,-40(fp)
 90c5d44:	10800017 	ldw	r2,0(r2)
 90c5d48:	1004c03a 	cmpne	r2,r2,zero
 90c5d4c:	1000141e 	bne	r2,zero,90c5da0 <ip_setmoptions+0x5cc>
 90c5d50:	e0bff617 	ldw	r2,-40(fp)
 90c5d54:	10800103 	ldbu	r2,4(r2)
 90c5d58:	10803fcc 	andi	r2,r2,255
 90c5d5c:	10800058 	cmpnei	r2,r2,1
 90c5d60:	10000f1e 	bne	r2,zero,90c5da0 <ip_setmoptions+0x5cc>
 90c5d64:	e0bff617 	ldw	r2,-40(fp)
 90c5d68:	10800143 	ldbu	r2,5(r2)
 90c5d6c:	10803fcc 	andi	r2,r2,255
 90c5d70:	10800058 	cmpnei	r2,r2,1
 90c5d74:	10000a1e 	bne	r2,zero,90c5da0 <ip_setmoptions+0x5cc>
 90c5d78:	e0bff617 	ldw	r2,-40(fp)
 90c5d7c:	1080018b 	ldhu	r2,6(r2)
 90c5d80:	10bfffcc 	andi	r2,r2,65535
 90c5d84:	1004c03a 	cmpne	r2,r2,zero
 90c5d88:	1000051e 	bne	r2,zero,90c5da0 <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 90c5d8c:	e0bff517 	ldw	r2,-44(fp)
 90c5d90:	11000017 	ldw	r4,0(r2)
 90c5d94:	90aaff00 	call	90aaff0 <npfree>
      *imop = NULL;
 90c5d98:	e0bff517 	ldw	r2,-44(fp)
 90c5d9c:	10000015 	stw	zero,0(r2)
   }
   return (error);
 90c5da0:	e0bff917 	ldw	r2,-28(fp)
 90c5da4:	e0bffe15 	stw	r2,-8(fp)
 90c5da8:	e0bffe17 	ldw	r2,-8(fp)
}
 90c5dac:	e037883a 	mov	sp,fp
 90c5db0:	dfc00217 	ldw	ra,8(sp)
 90c5db4:	df000117 	ldw	fp,4(sp)
 90c5db8:	dc000017 	ldw	r16,0(sp)
 90c5dbc:	dec00304 	addi	sp,sp,12
 90c5dc0:	f800283a 	ret

090c5dc4 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 90c5dc4:	defff604 	addi	sp,sp,-40
 90c5dc8:	df000915 	stw	fp,36(sp)
 90c5dcc:	df000904 	addi	fp,sp,36
 90c5dd0:	e13ffb15 	stw	r4,-20(fp)
 90c5dd4:	e17ffc15 	stw	r5,-16(fp)
 90c5dd8:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 90c5ddc:	e0bffc17 	ldw	r2,-16(fp)
 90c5de0:	10800317 	ldw	r2,12(r2)
 90c5de4:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 90c5de8:	e0bffb17 	ldw	r2,-20(fp)
 90c5dec:	e0bfff15 	stw	r2,-4(fp)
 90c5df0:	e0ffff17 	ldw	r3,-4(fp)
 90c5df4:	18800260 	cmpeqi	r2,r3,9
 90c5df8:	10000a1e 	bne	r2,zero,90c5e24 <ip_getmoptions+0x60>
 90c5dfc:	e0ffff17 	ldw	r3,-4(fp)
 90c5e00:	18800250 	cmplti	r2,r3,9
 90c5e04:	1000381e 	bne	r2,zero,90c5ee8 <ip_getmoptions+0x124>
 90c5e08:	e0ffff17 	ldw	r3,-4(fp)
 90c5e0c:	188002a0 	cmpeqi	r2,r3,10
 90c5e10:	1000171e 	bne	r2,zero,90c5e70 <ip_getmoptions+0xac>
 90c5e14:	e0ffff17 	ldw	r3,-4(fp)
 90c5e18:	188002e0 	cmpeqi	r2,r3,11
 90c5e1c:	1000231e 	bne	r2,zero,90c5eac <ip_getmoptions+0xe8>
 90c5e20:	00003106 	br	90c5ee8 <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 90c5e24:	e0bffd17 	ldw	r2,-12(fp)
 90c5e28:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 90c5e2c:	e0bff717 	ldw	r2,-36(fp)
 90c5e30:	1005003a 	cmpeq	r2,r2,zero
 90c5e34:	1000041e 	bne	r2,zero,90c5e48 <ip_getmoptions+0x84>
 90c5e38:	e0bff717 	ldw	r2,-36(fp)
 90c5e3c:	10800017 	ldw	r2,0(r2)
 90c5e40:	1004c03a 	cmpne	r2,r2,zero
 90c5e44:	1000031e 	bne	r2,zero,90c5e54 <ip_getmoptions+0x90>
         *addr = AADDR;
 90c5e48:	e0bff817 	ldw	r2,-32(fp)
 90c5e4c:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 90c5e50:	00000506 	br	90c5e68 <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 90c5e54:	e0bff717 	ldw	r2,-36(fp)
 90c5e58:	10800017 	ldw	r2,0(r2)
 90c5e5c:	10c00a17 	ldw	r3,40(r2)
 90c5e60:	e0bff817 	ldw	r2,-32(fp)
 90c5e64:	10c00015 	stw	r3,0(r2)
      return (0);
 90c5e68:	e03ffe15 	stw	zero,-8(fp)
 90c5e6c:	00002006 	br	90c5ef0 <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 90c5e70:	e0bffd17 	ldw	r2,-12(fp)
 90c5e74:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 90c5e78:	e0bff717 	ldw	r2,-36(fp)
 90c5e7c:	1004c03a 	cmpne	r2,r2,zero
 90c5e80:	1000041e 	bne	r2,zero,90c5e94 <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 90c5e84:	e0fffa17 	ldw	r3,-24(fp)
 90c5e88:	00800044 	movi	r2,1
 90c5e8c:	18800005 	stb	r2,0(r3)
 90c5e90:	00000406 	br	90c5ea4 <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 90c5e94:	e0bff717 	ldw	r2,-36(fp)
 90c5e98:	10c00103 	ldbu	r3,4(r2)
 90c5e9c:	e0bffa17 	ldw	r2,-24(fp)
 90c5ea0:	10c00005 	stb	r3,0(r2)
      return (0);
 90c5ea4:	e03ffe15 	stw	zero,-8(fp)
 90c5ea8:	00001106 	br	90c5ef0 <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 90c5eac:	e0bffd17 	ldw	r2,-12(fp)
 90c5eb0:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 90c5eb4:	e0bff717 	ldw	r2,-36(fp)
 90c5eb8:	1004c03a 	cmpne	r2,r2,zero
 90c5ebc:	1000041e 	bne	r2,zero,90c5ed0 <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 90c5ec0:	e0fff917 	ldw	r3,-28(fp)
 90c5ec4:	00800044 	movi	r2,1
 90c5ec8:	18800005 	stb	r2,0(r3)
 90c5ecc:	00000406 	br	90c5ee0 <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 90c5ed0:	e0bff717 	ldw	r2,-36(fp)
 90c5ed4:	10c00143 	ldbu	r3,5(r2)
 90c5ed8:	e0bff917 	ldw	r2,-28(fp)
 90c5edc:	10c00005 	stb	r3,0(r2)
      return (0);
 90c5ee0:	e03ffe15 	stw	zero,-8(fp)
 90c5ee4:	00000206 	br	90c5ef0 <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 90c5ee8:	008017c4 	movi	r2,95
 90c5eec:	e0bffe15 	stw	r2,-8(fp)
 90c5ef0:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 90c5ef4:	e037883a 	mov	sp,fp
 90c5ef8:	df000017 	ldw	fp,0(sp)
 90c5efc:	dec00104 	addi	sp,sp,4
 90c5f00:	f800283a 	ret

090c5f04 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 90c5f04:	defffc04 	addi	sp,sp,-16
 90c5f08:	dfc00315 	stw	ra,12(sp)
 90c5f0c:	df000215 	stw	fp,8(sp)
 90c5f10:	df000204 	addi	fp,sp,8
 90c5f14:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 90c5f18:	e0bfff17 	ldw	r2,-4(fp)
 90c5f1c:	1005003a 	cmpeq	r2,r2,zero
 90c5f20:	1000141e 	bne	r2,zero,90c5f74 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 90c5f24:	e03ffe0d 	sth	zero,-8(fp)
 90c5f28:	00000b06 	br	90c5f58 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 90c5f2c:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5f30:	e0ffff17 	ldw	r3,-4(fp)
 90c5f34:	1085883a 	add	r2,r2,r2
 90c5f38:	1085883a 	add	r2,r2,r2
 90c5f3c:	10c5883a 	add	r2,r2,r3
 90c5f40:	10800204 	addi	r2,r2,8
 90c5f44:	11000017 	ldw	r4,0(r2)
 90c5f48:	90c2ef40 	call	90c2ef4 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 90c5f4c:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5f50:	10800044 	addi	r2,r2,1
 90c5f54:	e0bffe0d 	sth	r2,-8(fp)
 90c5f58:	e0bfff17 	ldw	r2,-4(fp)
 90c5f5c:	1080018b 	ldhu	r2,6(r2)
 90c5f60:	10ffffcc 	andi	r3,r2,65535
 90c5f64:	e0bffe0b 	ldhu	r2,-8(fp)
 90c5f68:	10fff036 	bltu	r2,r3,90c5f2c <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 90c5f6c:	e13fff17 	ldw	r4,-4(fp)
 90c5f70:	90aaff00 	call	90aaff0 <npfree>
   }
}
 90c5f74:	e037883a 	mov	sp,fp
 90c5f78:	dfc00117 	ldw	ra,4(sp)
 90c5f7c:	df000017 	ldw	fp,0(sp)
 90c5f80:	dec00204 	addi	sp,sp,8
 90c5f84:	f800283a 	ret

090c5f88 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 90c5f88:	defffe04 	addi	sp,sp,-8
 90c5f8c:	dfc00115 	stw	ra,4(sp)
 90c5f90:	df000015 	stw	fp,0(sp)
 90c5f94:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 90c5f98:	01024374 	movhi	r4,2317
 90c5f9c:	21049a04 	addi	r4,r4,4712
 90c5fa0:	90836b80 	call	90836b8 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 90c5fa4:	e037883a 	mov	sp,fp
 90c5fa8:	dfc00117 	ldw	ra,4(sp)
 90c5fac:	df000017 	ldw	fp,0(sp)
 90c5fb0:	dec00204 	addi	sp,sp,8
 90c5fb4:	f800283a 	ret

090c5fb8 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 90c5fb8:	defede04 	addi	sp,sp,-1160
 90c5fbc:	dfc12115 	stw	ra,1156(sp)
 90c5fc0:	df012015 	stw	fp,1152(sp)
 90c5fc4:	df012004 	addi	fp,sp,1152
 90c5fc8:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 90c5fcc:	00c24374 	movhi	r3,2317
 90c5fd0:	18c54604 	addi	r3,r3,5400
 90c5fd4:	18800017 	ldw	r2,0(r3)
 90c5fd8:	e0bff215 	stw	r2,-56(fp)
 90c5fdc:	18800117 	ldw	r2,4(r3)
 90c5fe0:	e0bff315 	stw	r2,-52(fp)
 90c5fe4:	18800217 	ldw	r2,8(r3)
 90c5fe8:	e0bff415 	stw	r2,-48(fp)
 90c5fec:	18800317 	ldw	r2,12(r3)
 90c5ff0:	e0bff515 	stw	r2,-44(fp)
 90c5ff4:	18800417 	ldw	r2,16(r3)
 90c5ff8:	e0bff615 	stw	r2,-40(fp)
 90c5ffc:	18800517 	ldw	r2,20(r3)
 90c6000:	e0bff715 	stw	r2,-36(fp)
 90c6004:	18800617 	ldw	r2,24(r3)
 90c6008:	e0bff815 	stw	r2,-32(fp)
 90c600c:	1880070b 	ldhu	r2,28(r3)
 90c6010:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 90c6014:	01000084 	movi	r4,2
 90c6018:	01400084 	movi	r5,2
 90c601c:	000d883a 	mov	r6,zero
 90c6020:	90ad5740 	call	90ad574 <t_socket>
 90c6024:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 90c6028:	e0bee517 	ldw	r2,-1132(fp)
 90c602c:	10bfffd8 	cmpnei	r2,r2,-1
 90c6030:	1000091e 	bne	r2,zero,90c6058 <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 90c6034:	e13ee517 	ldw	r4,-1132(fp)
 90c6038:	90aec880 	call	90aec88 <t_errno>
 90c603c:	100d883a 	mov	r6,r2
 90c6040:	e13fff17 	ldw	r4,-4(fp)
 90c6044:	01424374 	movhi	r5,2317
 90c6048:	29449f04 	addi	r5,r5,4732
 90c604c:	90a55a40 	call	90a55a4 <ns_printf>
      exit(1);
 90c6050:	01000044 	movi	r4,1
 90c6054:	60200000 	call	6020000 <__reset>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 90c6058:	00800044 	movi	r2,1
 90c605c:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 90c6060:	e1fffa04 	addi	r7,fp,-24
 90c6064:	00800104 	movi	r2,4
 90c6068:	d8800015 	stw	r2,0(sp)
 90c606c:	e13ee517 	ldw	r4,-1132(fp)
 90c6070:	017fffc4 	movi	r5,-1
 90c6074:	01800104 	movi	r6,4
 90c6078:	90ae0280 	call	90ae028 <t_setsockopt>
 90c607c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c6080:	e0bee317 	ldw	r2,-1140(fp)
 90c6084:	10bfffd8 	cmpnei	r2,r2,-1
 90c6088:	1000071e 	bne	r2,zero,90c60a8 <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 90c608c:	e13ee517 	ldw	r4,-1132(fp)
 90c6090:	90aec880 	call	90aec88 <t_errno>
 90c6094:	100d883a 	mov	r6,r2
 90c6098:	e13fff17 	ldw	r4,-4(fp)
 90c609c:	01424374 	movhi	r5,2317
 90c60a0:	2944a604 	addi	r5,r5,4760
 90c60a4:	90a55a40 	call	90a55a4 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 90c60a8:	00800084 	movi	r2,2
 90c60ac:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 90c60b0:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 90c60b4:	00a00344 	movi	r2,-32755
 90c60b8:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 90c60bc:	e17ee604 	addi	r5,fp,-1128
 90c60c0:	e13ee517 	ldw	r4,-1132(fp)
 90c60c4:	01800404 	movi	r6,16
 90c60c8:	90ad6040 	call	90ad604 <t_bind>
 90c60cc:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c60d0:	e0bee317 	ldw	r2,-1140(fp)
 90c60d4:	10bfffd8 	cmpnei	r2,r2,-1
 90c60d8:	1000061e 	bne	r2,zero,90c60f4 <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 90c60dc:	e13ee517 	ldw	r4,-1132(fp)
 90c60e0:	90aec880 	call	90aec88 <t_errno>
 90c60e4:	100b883a 	mov	r5,r2
 90c60e8:	01024374 	movhi	r4,2317
 90c60ec:	2104b204 	addi	r4,r4,4808
 90c60f0:	90833900 	call	9083390 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 90c60f4:	e13fff17 	ldw	r4,-4(fp)
 90c60f8:	01424374 	movhi	r5,2317
 90c60fc:	2944b904 	addi	r5,r5,4836
 90c6100:	01824374 	movhi	r6,2317
 90c6104:	3184c104 	addi	r6,r6,4868
 90c6108:	90a55a40 	call	90a55a4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 90c610c:	01024374 	movhi	r4,2317
 90c6110:	2104c104 	addi	r4,r4,4868
 90c6114:	90c71680 	call	90c7168 <inet_addr>
 90c6118:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c611c:	008243b4 	movhi	r2,2318
 90c6120:	10b52604 	addi	r2,r2,-11112
 90c6124:	10800a17 	ldw	r2,40(r2)
 90c6128:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 90c612c:	e1fffb04 	addi	r7,fp,-20
 90c6130:	00800204 	movi	r2,8
 90c6134:	d8800015 	stw	r2,0(sp)
 90c6138:	e13ee517 	ldw	r4,-1132(fp)
 90c613c:	000b883a 	mov	r5,zero
 90c6140:	01800304 	movi	r6,12
 90c6144:	90ae0280 	call	90ae028 <t_setsockopt>
 90c6148:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c614c:	e0bee317 	ldw	r2,-1140(fp)
 90c6150:	10bfffd8 	cmpnei	r2,r2,-1
 90c6154:	1000071e 	bne	r2,zero,90c6174 <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c6158:	e13ee517 	ldw	r4,-1132(fp)
 90c615c:	90aec880 	call	90aec88 <t_errno>
 90c6160:	100d883a 	mov	r6,r2
 90c6164:	e13fff17 	ldw	r4,-4(fp)
 90c6168:	01424374 	movhi	r5,2317
 90c616c:	2944c404 	addi	r5,r5,4880
 90c6170:	90a55a40 	call	90a55a4 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 90c6174:	90a600c0 	call	90a600c <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 90c6178:	e13fff17 	ldw	r4,-4(fp)
 90c617c:	01424374 	movhi	r5,2317
 90c6180:	2944b904 	addi	r5,r5,4836
 90c6184:	01824374 	movhi	r6,2317
 90c6188:	3184d104 	addi	r6,r6,4932
 90c618c:	90a55a40 	call	90a55a4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 90c6190:	01024374 	movhi	r4,2317
 90c6194:	2104d104 	addi	r4,r4,4932
 90c6198:	90c71680 	call	90c7168 <inet_addr>
 90c619c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c61a0:	008243b4 	movhi	r2,2318
 90c61a4:	10b52604 	addi	r2,r2,-11112
 90c61a8:	10800a17 	ldw	r2,40(r2)
 90c61ac:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 90c61b0:	e1fffb04 	addi	r7,fp,-20
 90c61b4:	00800204 	movi	r2,8
 90c61b8:	d8800015 	stw	r2,0(sp)
 90c61bc:	e13ee517 	ldw	r4,-1132(fp)
 90c61c0:	000b883a 	mov	r5,zero
 90c61c4:	01800304 	movi	r6,12
 90c61c8:	90ae0280 	call	90ae028 <t_setsockopt>
 90c61cc:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c61d0:	e0bee317 	ldw	r2,-1140(fp)
 90c61d4:	10bfffd8 	cmpnei	r2,r2,-1
 90c61d8:	1000071e 	bne	r2,zero,90c61f8 <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c61dc:	e13ee517 	ldw	r4,-1132(fp)
 90c61e0:	90aec880 	call	90aec88 <t_errno>
 90c61e4:	100d883a 	mov	r6,r2
 90c61e8:	e13fff17 	ldw	r4,-4(fp)
 90c61ec:	01424374 	movhi	r5,2317
 90c61f0:	2944c404 	addi	r5,r5,4880
 90c61f4:	90a55a40 	call	90a55a4 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 90c61f8:	90a600c0 	call	90a600c <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 90c61fc:	e13fff17 	ldw	r4,-4(fp)
 90c6200:	01424374 	movhi	r5,2317
 90c6204:	2944b904 	addi	r5,r5,4836
 90c6208:	01824374 	movhi	r6,2317
 90c620c:	3184d404 	addi	r6,r6,4944
 90c6210:	90a55a40 	call	90a55a4 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 90c6214:	01024374 	movhi	r4,2317
 90c6218:	2104d404 	addi	r4,r4,4944
 90c621c:	90c71680 	call	90c7168 <inet_addr>
 90c6220:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c6224:	008243b4 	movhi	r2,2318
 90c6228:	10b52604 	addi	r2,r2,-11112
 90c622c:	10800a17 	ldw	r2,40(r2)
 90c6230:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 90c6234:	e1fffb04 	addi	r7,fp,-20
 90c6238:	00800204 	movi	r2,8
 90c623c:	d8800015 	stw	r2,0(sp)
 90c6240:	e13ee517 	ldw	r4,-1132(fp)
 90c6244:	000b883a 	mov	r5,zero
 90c6248:	01800304 	movi	r6,12
 90c624c:	90ae0280 	call	90ae028 <t_setsockopt>
 90c6250:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 90c6254:	e0bee317 	ldw	r2,-1140(fp)
 90c6258:	10bfffd8 	cmpnei	r2,r2,-1
 90c625c:	1000071e 	bne	r2,zero,90c627c <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 90c6260:	e13ee517 	ldw	r4,-1132(fp)
 90c6264:	90aec880 	call	90aec88 <t_errno>
 90c6268:	100d883a 	mov	r6,r2
 90c626c:	e13fff17 	ldw	r4,-4(fp)
 90c6270:	01424374 	movhi	r5,2317
 90c6274:	2944c404 	addi	r5,r5,4880
 90c6278:	90a55a40 	call	90a55a4 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 90c627c:	90a600c0 	call	90a600c <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 90c6280:	00800084 	movi	r2,2
 90c6284:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 90c6288:	e1fffd04 	addi	r7,fp,-12
 90c628c:	00800044 	movi	r2,1
 90c6290:	d8800015 	stw	r2,0(sp)
 90c6294:	e13ee517 	ldw	r4,-1132(fp)
 90c6298:	000b883a 	mov	r5,zero
 90c629c:	01800284 	movi	r6,10
 90c62a0:	90ae0280 	call	90ae028 <t_setsockopt>
 90c62a4:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c62a8:	e0bee317 	ldw	r2,-1140(fp)
 90c62ac:	10bfffd8 	cmpnei	r2,r2,-1
 90c62b0:	1000071e 	bne	r2,zero,90c62d0 <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 90c62b4:	e13ee517 	ldw	r4,-1132(fp)
 90c62b8:	90aec880 	call	90aec88 <t_errno>
 90c62bc:	100d883a 	mov	r6,r2
 90c62c0:	e13fff17 	ldw	r4,-4(fp)
 90c62c4:	01424374 	movhi	r5,2317
 90c62c8:	2944d704 	addi	r5,r5,4956
 90c62cc:	90a55a40 	call	90a55a4 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 90c62d0:	00800044 	movi	r2,1
 90c62d4:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 90c62d8:	e1fffd04 	addi	r7,fp,-12
 90c62dc:	00800044 	movi	r2,1
 90c62e0:	d8800015 	stw	r2,0(sp)
 90c62e4:	e13ee517 	ldw	r4,-1132(fp)
 90c62e8:	000b883a 	mov	r5,zero
 90c62ec:	018002c4 	movi	r6,11
 90c62f0:	90ae0280 	call	90ae028 <t_setsockopt>
 90c62f4:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c62f8:	e0bee317 	ldw	r2,-1140(fp)
 90c62fc:	10bfffd8 	cmpnei	r2,r2,-1
 90c6300:	1000071e 	bne	r2,zero,90c6320 <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 90c6304:	e13ee517 	ldw	r4,-1132(fp)
 90c6308:	90aec880 	call	90aec88 <t_errno>
 90c630c:	100d883a 	mov	r6,r2
 90c6310:	e13fff17 	ldw	r4,-4(fp)
 90c6314:	01424374 	movhi	r5,2317
 90c6318:	2944e404 	addi	r5,r5,5008
 90c631c:	90a55a40 	call	90a55a4 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 90c6320:	00800084 	movi	r2,2
 90c6324:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 90c6328:	01024374 	movhi	r4,2317
 90c632c:	2104d104 	addi	r4,r4,4932
 90c6330:	90c71680 	call	90c7168 <inet_addr>
 90c6334:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 90c6338:	00a00344 	movi	r2,-32755
 90c633c:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 90c6340:	e13fff17 	ldw	r4,-4(fp)
 90c6344:	01424374 	movhi	r5,2317
 90c6348:	2944f104 	addi	r5,r5,5060
 90c634c:	01824374 	movhi	r6,2317
 90c6350:	3184d104 	addi	r6,r6,4932
 90c6354:	90a55a40 	call	90a55a4 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 90c6358:	e03ee415 	stw	zero,-1136(fp)
 90c635c:	00009406 	br	90c65b0 <u_mctest_run+0x5f8>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 90c6360:	e0bff204 	addi	r2,fp,-56
 90c6364:	11000404 	addi	r4,r2,16
 90c6368:	d0a05217 	ldw	r2,-32440(gp)
 90c636c:	100d883a 	mov	r6,r2
 90c6370:	10800044 	addi	r2,r2,1
 90c6374:	d0a05215 	stw	r2,-32440(gp)
 90c6378:	01424374 	movhi	r5,2317
 90c637c:	29450004 	addi	r5,r5,5120
 90c6380:	908372c0 	call	908372c <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 90c6384:	e0beea04 	addi	r2,fp,-1112
 90c6388:	e17ff204 	addi	r5,fp,-56
 90c638c:	d8800015 	stw	r2,0(sp)
 90c6390:	00800404 	movi	r2,16
 90c6394:	d8800115 	stw	r2,4(sp)
 90c6398:	e13ee517 	ldw	r4,-1132(fp)
 90c639c:	01800784 	movi	r6,30
 90c63a0:	000f883a 	mov	r7,zero
 90c63a4:	90ae5e80 	call	90ae5e8 <t_sendto>
 90c63a8:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 90c63ac:	e0bee317 	ldw	r2,-1140(fp)
 90c63b0:	1004403a 	cmpge	r2,r2,zero
 90c63b4:	1000081e 	bne	r2,zero,90c63d8 <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 90c63b8:	e13ee517 	ldw	r4,-1132(fp)
 90c63bc:	90aec880 	call	90aec88 <t_errno>
 90c63c0:	100d883a 	mov	r6,r2
 90c63c4:	e13fff17 	ldw	r4,-4(fp)
 90c63c8:	01424374 	movhi	r5,2317
 90c63cc:	29450104 	addi	r5,r5,5124
 90c63d0:	90a55a40 	call	90a55a4 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 90c63d4:	00007906 	br	90c65bc <u_mctest_run+0x604>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 90c63d8:	00800044 	movi	r2,1
 90c63dc:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 90c63e0:	e1fffa04 	addi	r7,fp,-24
 90c63e4:	00800104 	movi	r2,4
 90c63e8:	d8800015 	stw	r2,0(sp)
 90c63ec:	e13ee517 	ldw	r4,-1132(fp)
 90c63f0:	017fffc4 	movi	r5,-1
 90c63f4:	01840584 	movi	r6,4118
 90c63f8:	90ae0280 	call	90ae028 <t_setsockopt>
 90c63fc:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 90c6400:	e0bee317 	ldw	r2,-1140(fp)
 90c6404:	10bfffd8 	cmpnei	r2,r2,-1
 90c6408:	1000071e 	bne	r2,zero,90c6428 <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 90c640c:	e13ee517 	ldw	r4,-1132(fp)
 90c6410:	90aec880 	call	90aec88 <t_errno>
 90c6414:	100d883a 	mov	r6,r2
 90c6418:	e13fff17 	ldw	r4,-4(fp)
 90c641c:	01424374 	movhi	r5,2317
 90c6420:	29450904 	addi	r5,r5,5156
 90c6424:	90a55a40 	call	90a55a4 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 90c6428:	00824374 	movhi	r2,2317
 90c642c:	108f2e04 	addi	r2,r2,15544
 90c6430:	11000017 	ldw	r4,0(r2)
 90c6434:	908d0380 	call	908d038 <__floatunsidf>
 90c6438:	100b883a 	mov	r5,r2
 90c643c:	180d883a 	mov	r6,r3
 90c6440:	2809883a 	mov	r4,r5
 90c6444:	300b883a 	mov	r5,r6
 90c6448:	000d883a 	mov	r6,zero
 90c644c:	01d01ff4 	movhi	r7,16511
 90c6450:	39d00004 	addi	r7,r7,16384
 90c6454:	908c5400 	call	908c540 <__adddf3>
 90c6458:	1009883a 	mov	r4,r2
 90c645c:	180b883a 	mov	r5,r3
 90c6460:	2005883a 	mov	r2,r4
 90c6464:	2807883a 	mov	r3,r5
 90c6468:	1009883a 	mov	r4,r2
 90c646c:	180b883a 	mov	r5,r3
 90c6470:	90cbbc40 	call	90cbbc4 <__fixunsdfsi>
 90c6474:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 90c6478:	00003206 	br	90c6544 <u_mctest_run+0x58c>
      {
         int sa_size = sizeof(struct sockaddr_in);
 90c647c:	00800404 	movi	r2,16
 90c6480:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 90c6484:	90a600c0 	call	90a600c <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 90c6488:	e0beee04 	addi	r2,fp,-1096
 90c648c:	e17ef204 	addi	r5,fp,-1080
 90c6490:	d8800015 	stw	r2,0(sp)
 90c6494:	e0bffe04 	addi	r2,fp,-8
 90c6498:	d8800115 	stw	r2,4(sp)
 90c649c:	e13ee517 	ldw	r4,-1132(fp)
 90c64a0:	01810004 	movi	r6,1024
 90c64a4:	000f883a 	mov	r7,zero
 90c64a8:	90ae4980 	call	90ae498 <t_recvfrom>
 90c64ac:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 90c64b0:	e0bee317 	ldw	r2,-1140(fp)
 90c64b4:	1004403a 	cmpge	r2,r2,zero
 90c64b8:	10000c1e 	bne	r2,zero,90c64ec <u_mctest_run+0x534>
         {
            if (t_errno(s) != EWOULDBLOCK)
 90c64bc:	e13ee517 	ldw	r4,-1132(fp)
 90c64c0:	90aec880 	call	90aec88 <t_errno>
 90c64c4:	108002e0 	cmpeqi	r2,r2,11
 90c64c8:	1000081e 	bne	r2,zero,90c64ec <u_mctest_run+0x534>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 90c64cc:	e13ee517 	ldw	r4,-1132(fp)
 90c64d0:	90aec880 	call	90aec88 <t_errno>
 90c64d4:	100d883a 	mov	r6,r2
 90c64d8:	e13fff17 	ldw	r4,-4(fp)
 90c64dc:	01424374 	movhi	r5,2317
 90c64e0:	29451504 	addi	r5,r5,5204
 90c64e4:	90a55a40 	call	90a55a4 <ns_printf>
               /*     exit(1); */
               goto exitloop;
 90c64e8:	00003406 	br	90c65bc <u_mctest_run+0x604>
            }
         }
         if (iRet > 0)
 90c64ec:	e0bee317 	ldw	r2,-1140(fp)
 90c64f0:	10800050 	cmplti	r2,r2,1
 90c64f4:	1000131e 	bne	r2,zero,90c6544 <u_mctest_run+0x58c>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 90c64f8:	e13eef17 	ldw	r4,-1092(fp)
 90c64fc:	90a514c0 	call	90a514c <print_ipad>
 90c6500:	100d883a 	mov	r6,r2
 90c6504:	e0beee8b 	ldhu	r2,-1094(fp)
 90c6508:	10bfffcc 	andi	r2,r2,65535
 90c650c:	1004d23a 	srli	r2,r2,8
 90c6510:	10bfffcc 	andi	r2,r2,65535
 90c6514:	10c03fcc 	andi	r3,r2,255
 90c6518:	e0beee8b 	ldhu	r2,-1094(fp)
 90c651c:	10bfffcc 	andi	r2,r2,65535
 90c6520:	1004923a 	slli	r2,r2,8
 90c6524:	10bfc00c 	andi	r2,r2,65280
 90c6528:	188eb03a 	or	r7,r3,r2
 90c652c:	e0bef204 	addi	r2,fp,-1080
 90c6530:	d8800015 	stw	r2,0(sp)
 90c6534:	e13fff17 	ldw	r4,-4(fp)
 90c6538:	01424374 	movhi	r5,2317
 90c653c:	29451d04 	addi	r5,r5,5236
 90c6540:	90a55a40 	call	90a55a4 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 90c6544:	00824374 	movhi	r2,2317
 90c6548:	108f2e04 	addi	r2,r2,15544
 90c654c:	10c00017 	ldw	r3,0(r2)
 90c6550:	e0bee217 	ldw	r2,-1144(fp)
 90c6554:	18bfc936 	bltu	r3,r2,90c647c <u_mctest_run+0x4c4>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 90c6558:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 90c655c:	e1fffd04 	addi	r7,fp,-12
 90c6560:	00800044 	movi	r2,1
 90c6564:	d8800015 	stw	r2,0(sp)
 90c6568:	e13ee517 	ldw	r4,-1132(fp)
 90c656c:	017fffc4 	movi	r5,-1
 90c6570:	01840584 	movi	r6,4118
 90c6574:	90ae0280 	call	90ae028 <t_setsockopt>
 90c6578:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 90c657c:	e0bee317 	ldw	r2,-1140(fp)
 90c6580:	10bfffd8 	cmpnei	r2,r2,-1
 90c6584:	1000071e 	bne	r2,zero,90c65a4 <u_mctest_run+0x5ec>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 90c6588:	e13ee517 	ldw	r4,-1132(fp)
 90c658c:	90aec880 	call	90aec88 <t_errno>
 90c6590:	100d883a 	mov	r6,r2
 90c6594:	e13fff17 	ldw	r4,-4(fp)
 90c6598:	01424374 	movhi	r5,2317
 90c659c:	29452404 	addi	r5,r5,5264
 90c65a0:	90a55a40 	call	90a55a4 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 90c65a4:	e0bee417 	ldw	r2,-1136(fp)
 90c65a8:	10800044 	addi	r2,r2,1
 90c65ac:	e0bee415 	stw	r2,-1136(fp)
 90c65b0:	e0bee417 	ldw	r2,-1136(fp)
 90c65b4:	108000d0 	cmplti	r2,r2,3
 90c65b8:	103f691e 	bne	r2,zero,90c6360 <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 90c65bc:	01024374 	movhi	r4,2317
 90c65c0:	2104c104 	addi	r4,r4,4868
 90c65c4:	90c71680 	call	90c7168 <inet_addr>
 90c65c8:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 90c65cc:	008243b4 	movhi	r2,2318
 90c65d0:	10b52604 	addi	r2,r2,-11112
 90c65d4:	10800a17 	ldw	r2,40(r2)
 90c65d8:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 90c65dc:	e1fffb04 	addi	r7,fp,-20
 90c65e0:	00800204 	movi	r2,8
 90c65e4:	d8800015 	stw	r2,0(sp)
 90c65e8:	e13ee517 	ldw	r4,-1132(fp)
 90c65ec:	000b883a 	mov	r5,zero
 90c65f0:	01800344 	movi	r6,13
 90c65f4:	90ae0280 	call	90ae028 <t_setsockopt>
 90c65f8:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c65fc:	e0bee317 	ldw	r2,-1140(fp)
 90c6600:	10bfffd8 	cmpnei	r2,r2,-1
 90c6604:	1000071e 	bne	r2,zero,90c6624 <u_mctest_run+0x66c>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 90c6608:	e13ee517 	ldw	r4,-1132(fp)
 90c660c:	90aec880 	call	90aec88 <t_errno>
 90c6610:	100d883a 	mov	r6,r2
 90c6614:	e13fff17 	ldw	r4,-4(fp)
 90c6618:	01424374 	movhi	r5,2317
 90c661c:	29453004 	addi	r5,r5,5312
 90c6620:	90a55a40 	call	90a55a4 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 90c6624:	e13ee517 	ldw	r4,-1132(fp)
 90c6628:	90aeb200 	call	90aeb20 <t_socketclose>
 90c662c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 90c6630:	e0bee317 	ldw	r2,-1140(fp)
 90c6634:	10bfffd8 	cmpnei	r2,r2,-1
 90c6638:	1000071e 	bne	r2,zero,90c6658 <u_mctest_run+0x6a0>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 90c663c:	e13ee517 	ldw	r4,-1132(fp)
 90c6640:	90aec880 	call	90aec88 <t_errno>
 90c6644:	100d883a 	mov	r6,r2
 90c6648:	e13fff17 	ldw	r4,-4(fp)
 90c664c:	01424374 	movhi	r5,2317
 90c6650:	29453d04 	addi	r5,r5,5364
 90c6654:	90a55a40 	call	90a55a4 <ns_printf>
   }

   return(0);
 90c6658:	0005883a 	mov	r2,zero
}  /* end main() */  
 90c665c:	e037883a 	mov	sp,fp
 90c6660:	dfc00117 	ldw	ra,4(sp)
 90c6664:	df000017 	ldw	fp,0(sp)
 90c6668:	dec00204 	addi	sp,sp,8
 90c666c:	f800283a 	ret

090c6670 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 90c6670:	defff504 	addi	sp,sp,-44
 90c6674:	dfc00a15 	stw	ra,40(sp)
 90c6678:	df000915 	stw	fp,36(sp)
 90c667c:	df000904 	addi	fp,sp,36
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 90c6680:	e03ff715 	stw	zero,-36(fp)

   e = dhc_init();
 90c6684:	90a62d00 	call	90a62d0 <dhc_init>
 90c6688:	e0bff815 	stw	r2,-32(fp)

   if (e)
 90c668c:	e0bff817 	ldw	r2,-32(fp)
 90c6690:	1005003a 	cmpeq	r2,r2,zero
 90c6694:	1000051e 	bne	r2,zero,90c66ac <dhc_setup+0x3c>
   {
      printf("Error starting DHCP client code.\n");
 90c6698:	01024374 	movhi	r4,2317
 90c669c:	21054e04 	addi	r4,r4,5432
 90c66a0:	90836b80 	call	90836b8 <puts>
      netexit(1);
 90c66a4:	01000044 	movi	r4,1
 90c66a8:	90c31100 	call	90c3110 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 90c66ac:	00824374 	movhi	r2,2317
 90c66b0:	108f2e04 	addi	r2,r2,15544
 90c66b4:	10800017 	ldw	r2,0(r2)
 90c66b8:	e0bff915 	stw	r2,-28(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 90c66bc:	e03ffa15 	stw	zero,-24(fp)
 90c66c0:	00005106 	br	90c6808 <dhc_setup+0x198>
   {
      if (!nets[iface])
 90c66c4:	e0bffa17 	ldw	r2,-24(fp)
 90c66c8:	00c243b4 	movhi	r3,2318
 90c66cc:	18f5e604 	addi	r3,r3,-10344
 90c66d0:	1085883a 	add	r2,r2,r2
 90c66d4:	1085883a 	add	r2,r2,r2
 90c66d8:	10c5883a 	add	r2,r2,r3
 90c66dc:	10800017 	ldw	r2,0(r2)
 90c66e0:	1005003a 	cmpeq	r2,r2,zero
 90c66e4:	1000451e 	bne	r2,zero,90c67fc <dhc_setup+0x18c>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 90c66e8:	e0bffa17 	ldw	r2,-24(fp)
 90c66ec:	00c243b4 	movhi	r3,2318
 90c66f0:	18f5e604 	addi	r3,r3,-10344
 90c66f4:	1085883a 	add	r2,r2,r2
 90c66f8:	1085883a 	add	r2,r2,r2
 90c66fc:	10c5883a 	add	r2,r2,r3
 90c6700:	10800017 	ldw	r2,0(r2)
 90c6704:	10802a17 	ldw	r2,168(r2)
 90c6708:	1080400c 	andi	r2,r2,256
 90c670c:	1005003a 	cmpeq	r2,r2,zero
 90c6710:	10003a1e 	bne	r2,zero,90c67fc <dhc_setup+0x18c>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 90c6714:	e0bffa17 	ldw	r2,-24(fp)
 90c6718:	00c243b4 	movhi	r3,2318
 90c671c:	18f60c04 	addi	r3,r3,-10192
 90c6720:	10800f24 	muli	r2,r2,60
 90c6724:	10c5883a 	add	r2,r2,r3
 90c6728:	10800e04 	addi	r2,r2,56
 90c672c:	10800017 	ldw	r2,0(r2)
 90c6730:	1004c03a 	cmpne	r2,r2,zero
 90c6734:	1000041e 	bne	r2,zero,90c6748 <dhc_setup+0xd8>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 90c6738:	e13ffa17 	ldw	r4,-24(fp)
 90c673c:	01424334 	movhi	r5,2316
 90c6740:	295a4f04 	addi	r5,r5,26940
 90c6744:	90a638c0 	call	90a638c <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 90c6748:	e13ffa17 	ldw	r4,-24(fp)
 90c674c:	e0bffa17 	ldw	r2,-24(fp)
 90c6750:	00c243b4 	movhi	r3,2318
 90c6754:	18f5e604 	addi	r3,r3,-10344
 90c6758:	1085883a 	add	r2,r2,r2
 90c675c:	1085883a 	add	r2,r2,r2
 90c6760:	10c5883a 	add	r2,r2,r3
 90c6764:	10800017 	ldw	r2,0(r2)
 90c6768:	10c00a17 	ldw	r3,40(r2)
 90c676c:	2105883a 	add	r2,r4,r4
 90c6770:	1085883a 	add	r2,r2,r2
 90c6774:	e13ff704 	addi	r4,fp,-36
 90c6778:	1105883a 	add	r2,r2,r4
 90c677c:	10800404 	addi	r2,r2,16
 90c6780:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 90c6784:	e0bffa17 	ldw	r2,-24(fp)
 90c6788:	1085883a 	add	r2,r2,r2
 90c678c:	1085883a 	add	r2,r2,r2
 90c6790:	e0fff704 	addi	r3,fp,-36
 90c6794:	10c5883a 	add	r2,r2,r3
 90c6798:	10800404 	addi	r2,r2,16
 90c679c:	10800017 	ldw	r2,0(r2)
 90c67a0:	1004c03a 	cmpne	r2,r2,zero
 90c67a4:	1000041e 	bne	r2,zero,90c67b8 <dhc_setup+0x148>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 90c67a8:	e13ffa17 	ldw	r4,-24(fp)
 90c67ac:	01400044 	movi	r5,1
 90c67b0:	90a92c40 	call	90a92c4 <dhc_state_init>
 90c67b4:	00000306 	br	90c67c4 <dhc_setup+0x154>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 90c67b8:	e13ffa17 	ldw	r4,-24(fp)
 90c67bc:	000b883a 	mov	r5,zero
 90c67c0:	90a92c40 	call	90a92c4 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 90c67c4:	90a87900 	call	90a8790 <dhc_second>
 90c67c8:	e0bff815 	stw	r2,-32(fp)
      if (e)
 90c67cc:	e0bff817 	ldw	r2,-32(fp)
 90c67d0:	1005003a 	cmpeq	r2,r2,zero
 90c67d4:	1000061e 	bne	r2,zero,90c67f0 <dhc_setup+0x180>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 90c67d8:	01024374 	movhi	r4,2317
 90c67dc:	21055704 	addi	r4,r4,5468
 90c67e0:	e17ffa17 	ldw	r5,-24(fp)
 90c67e4:	90833900 	call	9083390 <printf>
         netexit(1);
 90c67e8:	01000044 	movi	r4,1
 90c67ec:	90c31100 	call	90c3110 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 90c67f0:	e0bff717 	ldw	r2,-36(fp)
 90c67f4:	10800044 	addi	r2,r2,1
 90c67f8:	e0bff715 	stw	r2,-36(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 90c67fc:	e0bffa17 	ldw	r2,-24(fp)
 90c6800:	10800044 	addi	r2,r2,1
 90c6804:	e0bffa15 	stw	r2,-24(fp)
 90c6808:	e0bffa17 	ldw	r2,-24(fp)
 90c680c:	10800110 	cmplti	r2,r2,4
 90c6810:	103fac1e 	bne	r2,zero,90c66c4 <dhc_setup+0x54>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 90c6814:	e0bff717 	ldw	r2,-36(fp)
 90c6818:	1005003a 	cmpeq	r2,r2,zero
 90c681c:	1000421e 	bne	r2,zero,90c6928 <dhc_setup+0x2b8>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 90c6820:	00000206 	br	90c682c <dhc_setup+0x1bc>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 90c6824:	90a600c0 	call	90a600c <tk_yield>
      pktdemux();
 90c6828:	90a26a00 	call	90a26a0 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 90c682c:	00824374 	movhi	r2,2317
 90c6830:	108f2e04 	addi	r2,r2,15544
 90c6834:	10c00017 	ldw	r3,0(r2)
 90c6838:	e0bff917 	ldw	r2,-28(fp)
 90c683c:	1889c83a 	sub	r4,r3,r2
 90c6840:	908d0380 	call	908d038 <__floatunsidf>
 90c6844:	100b883a 	mov	r5,r2
 90c6848:	180d883a 	mov	r6,r3
 90c684c:	e03fff05 	stb	zero,-4(fp)
 90c6850:	2809883a 	mov	r4,r5
 90c6854:	300b883a 	mov	r5,r6
 90c6858:	000d883a 	mov	r6,zero
 90c685c:	01d03274 	movhi	r7,16585
 90c6860:	39d90004 	addi	r7,r7,25600
 90c6864:	908cde00 	call	908cde0 <__ltdf2>
 90c6868:	1004803a 	cmplt	r2,r2,zero
 90c686c:	1000011e 	bne	r2,zero,90c6874 <dhc_setup+0x204>
 90c6870:	00000206 	br	90c687c <dhc_setup+0x20c>
 90c6874:	01000044 	movi	r4,1
 90c6878:	e13fff05 	stb	r4,-4(fp)
 90c687c:	e0ffff03 	ldbu	r3,-4(fp)
 90c6880:	1880005c 	xori	r2,r3,1
 90c6884:	10803fcc 	andi	r2,r2,255
 90c6888:	1004c03a 	cmpne	r2,r2,zero
 90c688c:	1000031e 	bne	r2,zero,90c689c <dhc_setup+0x22c>
 90c6890:	90a93240 	call	90a9324 <dhc_alldone>
 90c6894:	1005003a 	cmpeq	r2,r2,zero
 90c6898:	103fe21e 	bne	r2,zero,90c6824 <dhc_setup+0x1b4>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 90c689c:	90a93240 	call	90a9324 <dhc_alldone>
 90c68a0:	1004c03a 	cmpne	r2,r2,zero
 90c68a4:	1000201e 	bne	r2,zero,90c6928 <dhc_setup+0x2b8>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 90c68a8:	01024374 	movhi	r4,2317
 90c68ac:	21056104 	addi	r4,r4,5508
 90c68b0:	90836b80 	call	90836b8 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 90c68b4:	e03ffa15 	stw	zero,-24(fp)
 90c68b8:	00001806 	br	90c691c <dhc_setup+0x2ac>
      {
         if (dhc_ifacedone(iface) == FALSE)
 90c68bc:	e13ffa17 	ldw	r4,-24(fp)
 90c68c0:	90a93b40 	call	90a93b4 <dhc_ifacedone>
 90c68c4:	1004c03a 	cmpne	r2,r2,zero
 90c68c8:	1000111e 	bne	r2,zero,90c6910 <dhc_setup+0x2a0>
         {
            dhc_halt(iface);
 90c68cc:	e13ffa17 	ldw	r4,-24(fp)
 90c68d0:	90a906c0 	call	90a906c <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 90c68d4:	e0bffa17 	ldw	r2,-24(fp)
 90c68d8:	00c243b4 	movhi	r3,2318
 90c68dc:	18f5e604 	addi	r3,r3,-10344
 90c68e0:	1085883a 	add	r2,r2,r2
 90c68e4:	1085883a 	add	r2,r2,r2
 90c68e8:	10c5883a 	add	r2,r2,r3
 90c68ec:	10c00017 	ldw	r3,0(r2)
 90c68f0:	e0bffa17 	ldw	r2,-24(fp)
 90c68f4:	1085883a 	add	r2,r2,r2
 90c68f8:	1085883a 	add	r2,r2,r2
 90c68fc:	e13ff704 	addi	r4,fp,-36
 90c6900:	1105883a 	add	r2,r2,r4
 90c6904:	10800404 	addi	r2,r2,16
 90c6908:	10800017 	ldw	r2,0(r2)
 90c690c:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 90c6910:	e0bffa17 	ldw	r2,-24(fp)
 90c6914:	10800044 	addi	r2,r2,1
 90c6918:	e0bffa15 	stw	r2,-24(fp)
 90c691c:	e0bffa17 	ldw	r2,-24(fp)
 90c6920:	10800110 	cmplti	r2,r2,4
 90c6924:	103fe51e 	bne	r2,zero,90c68bc <dhc_setup+0x24c>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 90c6928:	e037883a 	mov	sp,fp
 90c692c:	dfc00117 	ldw	ra,4(sp)
 90c6930:	df000017 	ldw	fp,0(sp)
 90c6934:	dec00204 	addi	sp,sp,8
 90c6938:	f800283a 	ret

090c693c <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 90c693c:	defffc04 	addi	sp,sp,-16
 90c6940:	dfc00315 	stw	ra,12(sp)
 90c6944:	df000215 	stw	fp,8(sp)
 90c6948:	df000204 	addi	fp,sp,8
 90c694c:	e13ffe15 	stw	r4,-8(fp)
 90c6950:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 90c6954:	e0bfff17 	ldw	r2,-4(fp)
 90c6958:	10800198 	cmpnei	r2,r2,6
 90c695c:	1000321e 	bne	r2,zero,90c6a28 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 90c6960:	e0bffe17 	ldw	r2,-8(fp)
 90c6964:	00c243b4 	movhi	r3,2318
 90c6968:	18f5e604 	addi	r3,r3,-10344
 90c696c:	1085883a 	add	r2,r2,r2
 90c6970:	1085883a 	add	r2,r2,r2
 90c6974:	10c5883a 	add	r2,r2,r3
 90c6978:	10800017 	ldw	r2,0(r2)
 90c697c:	11400104 	addi	r5,r2,4
 90c6980:	01024374 	movhi	r4,2317
 90c6984:	21056f04 	addi	r4,r4,5564
 90c6988:	90833900 	call	9083390 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 90c698c:	e0bffe17 	ldw	r2,-8(fp)
 90c6990:	00c243b4 	movhi	r3,2318
 90c6994:	18f5e604 	addi	r3,r3,-10344
 90c6998:	1085883a 	add	r2,r2,r2
 90c699c:	1085883a 	add	r2,r2,r2
 90c69a0:	10c5883a 	add	r2,r2,r3
 90c69a4:	10800017 	ldw	r2,0(r2)
 90c69a8:	11000a17 	ldw	r4,40(r2)
 90c69ac:	90a514c0 	call	90a514c <print_ipad>
 90c69b0:	100b883a 	mov	r5,r2
 90c69b4:	01024374 	movhi	r4,2317
 90c69b8:	21057d04 	addi	r4,r4,5620
 90c69bc:	90833900 	call	9083390 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 90c69c0:	e0bffe17 	ldw	r2,-8(fp)
 90c69c4:	00c243b4 	movhi	r3,2318
 90c69c8:	18f5e604 	addi	r3,r3,-10344
 90c69cc:	1085883a 	add	r2,r2,r2
 90c69d0:	1085883a 	add	r2,r2,r2
 90c69d4:	10c5883a 	add	r2,r2,r3
 90c69d8:	10800017 	ldw	r2,0(r2)
 90c69dc:	11000c17 	ldw	r4,48(r2)
 90c69e0:	90a514c0 	call	90a514c <print_ipad>
 90c69e4:	100b883a 	mov	r5,r2
 90c69e8:	01024374 	movhi	r4,2317
 90c69ec:	21058204 	addi	r4,r4,5640
 90c69f0:	90833900 	call	9083390 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 90c69f4:	e0bffe17 	ldw	r2,-8(fp)
 90c69f8:	00c243b4 	movhi	r3,2318
 90c69fc:	18f5e604 	addi	r3,r3,-10344
 90c6a00:	1085883a 	add	r2,r2,r2
 90c6a04:	1085883a 	add	r2,r2,r2
 90c6a08:	10c5883a 	add	r2,r2,r3
 90c6a0c:	10800017 	ldw	r2,0(r2)
 90c6a10:	11000d17 	ldw	r4,52(r2)
 90c6a14:	90a514c0 	call	90a514c <print_ipad>
 90c6a18:	100b883a 	mov	r5,r2
 90c6a1c:	01024374 	movhi	r4,2317
 90c6a20:	21058704 	addi	r4,r4,5660
 90c6a24:	90833900 	call	9083390 <printf>
   }
   return 0;
 90c6a28:	0005883a 	mov	r2,zero
}
 90c6a2c:	e037883a 	mov	sp,fp
 90c6a30:	dfc00117 	ldw	ra,4(sp)
 90c6a34:	df000017 	ldw	fp,0(sp)
 90c6a38:	dec00204 	addi	sp,sp,8
 90c6a3c:	f800283a 	ret

090c6a40 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 90c6a40:	deffff04 	addi	sp,sp,-4
 90c6a44:	df000015 	stw	fp,0(sp)
 90c6a48:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 90c6a4c:	00824374 	movhi	r2,2317
 90c6a50:	108f5a04 	addi	r2,r2,15720
 90c6a54:	10c00017 	ldw	r3,0(r2)
 90c6a58:	00824374 	movhi	r2,2317
 90c6a5c:	108e2a04 	addi	r2,r2,14504
 90c6a60:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 90c6a64:	00c24374 	movhi	r3,2317
 90c6a68:	18cf5a04 	addi	r3,r3,15720
 90c6a6c:	00824374 	movhi	r2,2317
 90c6a70:	108e2a04 	addi	r2,r2,14504
 90c6a74:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 90c6a78:	00824374 	movhi	r2,2317
 90c6a7c:	108f5c04 	addi	r2,r2,15728
 90c6a80:	10c00017 	ldw	r3,0(r2)
 90c6a84:	00824374 	movhi	r2,2317
 90c6a88:	108e3304 	addi	r2,r2,14540
 90c6a8c:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 90c6a90:	00c24374 	movhi	r3,2317
 90c6a94:	18ce5404 	addi	r3,r3,14672
 90c6a98:	00824374 	movhi	r2,2317
 90c6a9c:	108f5c04 	addi	r2,r2,15728
 90c6aa0:	10c00015 	stw	r3,0(r2)

   return 0;
 90c6aa4:	0005883a 	mov	r2,zero
}
 90c6aa8:	e037883a 	mov	sp,fp
 90c6aac:	df000017 	ldw	fp,0(sp)
 90c6ab0:	dec00104 	addi	sp,sp,4
 90c6ab4:	f800283a 	ret

090c6ab8 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 90c6ab8:	defffd04 	addi	sp,sp,-12
 90c6abc:	df000215 	stw	fp,8(sp)
 90c6ac0:	df000204 	addi	fp,sp,8
 90c6ac4:	e13ffe15 	stw	r4,-8(fp)
 90c6ac8:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 90c6acc:	0005883a 	mov	r2,zero
}
 90c6ad0:	e037883a 	mov	sp,fp
 90c6ad4:	df000017 	ldw	fp,0(sp)
 90c6ad8:	dec00104 	addi	sp,sp,4
 90c6adc:	f800283a 	ret

090c6ae0 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 90c6ae0:	defffe04 	addi	sp,sp,-8
 90c6ae4:	df000115 	stw	fp,4(sp)
 90c6ae8:	df000104 	addi	fp,sp,4
 90c6aec:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 90c6af0:	e037883a 	mov	sp,fp
 90c6af4:	df000017 	ldw	fp,0(sp)
 90c6af8:	dec00104 	addi	sp,sp,4
 90c6afc:	f800283a 	ret

090c6b00 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c6b00:	defff604 	addi	sp,sp,-40
 90c6b04:	dfc00915 	stw	ra,36(sp)
 90c6b08:	df000815 	stw	fp,32(sp)
 90c6b0c:	df000804 	addi	fp,sp,32
 90c6b10:	e13ffb15 	stw	r4,-20(fp)
 90c6b14:	e17ffc15 	stw	r5,-16(fp)
 90c6b18:	e1bffd15 	stw	r6,-12(fp)
 90c6b1c:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 90c6b20:	00800834 	movhi	r2,32
 90c6b24:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 90c6b28:	e0bffe17 	ldw	r2,-8(fp)
 90c6b2c:	1005003a 	cmpeq	r2,r2,zero
 90c6b30:	1000081e 	bne	r2,zero,90c6b54 <md_fread+0x54>
 90c6b34:	e0bffe17 	ldw	r2,-8(fp)
 90c6b38:	10800117 	ldw	r2,4(r2)
 90c6b3c:	1005003a 	cmpeq	r2,r2,zero
 90c6b40:	1000041e 	bne	r2,zero,90c6b54 <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 90c6b44:	e0bffe17 	ldw	r2,-8(fp)
 90c6b48:	10800117 	ldw	r2,4(r2)
 90c6b4c:	10800717 	ldw	r2,28(r2)
 90c6b50:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 90c6b54:	e0bffe17 	ldw	r2,-8(fp)
 90c6b58:	10800217 	ldw	r2,8(r2)
 90c6b5c:	1007883a 	mov	r3,r2
 90c6b60:	e0bffe17 	ldw	r2,-8(fp)
 90c6b64:	10800117 	ldw	r2,4(r2)
 90c6b68:	10800617 	ldw	r2,24(r2)
 90c6b6c:	1885c83a 	sub	r2,r3,r2
 90c6b70:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 90c6b74:	e0fffd17 	ldw	r3,-12(fp)
 90c6b78:	e0bffc17 	ldw	r2,-16(fp)
 90c6b7c:	1885383a 	mul	r2,r3,r2
 90c6b80:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 90c6b84:	e0fff917 	ldw	r3,-28(fp)
 90c6b88:	e0bffa17 	ldw	r2,-24(fp)
 90c6b8c:	1887883a 	add	r3,r3,r2
 90c6b90:	e0bff817 	ldw	r2,-32(fp)
 90c6b94:	10c0042e 	bgeu	r2,r3,90c6ba8 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 90c6b98:	e0bff817 	ldw	r2,-32(fp)
 90c6b9c:	e0fff917 	ldw	r3,-28(fp)
 90c6ba0:	10c5c83a 	sub	r2,r2,r3
 90c6ba4:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 90c6ba8:	e0fff917 	ldw	r3,-28(fp)
 90c6bac:	e0bff817 	ldw	r2,-32(fp)
 90c6bb0:	1880072e 	bgeu	r3,r2,90c6bd0 <md_fread+0xd0>
 90c6bb4:	e0bffa17 	ldw	r2,-24(fp)
 90c6bb8:	10bfffec 	andhi	r2,r2,65535
 90c6bbc:	1004c03a 	cmpne	r2,r2,zero
 90c6bc0:	1000031e 	bne	r2,zero,90c6bd0 <md_fread+0xd0>
 90c6bc4:	e0bffa17 	ldw	r2,-24(fp)
 90c6bc8:	1004c03a 	cmpne	r2,r2,zero
 90c6bcc:	1000021e 	bne	r2,zero,90c6bd8 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 90c6bd0:	e03fff15 	stw	zero,-4(fp)
 90c6bd4:	00002406 	br	90c6c68 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 90c6bd8:	e0bffe17 	ldw	r2,-8(fp)
 90c6bdc:	10800117 	ldw	r2,4(r2)
 90c6be0:	1080058b 	ldhu	r2,22(r2)
 90c6be4:	10bfffcc 	andi	r2,r2,65535
 90c6be8:	10a0001c 	xori	r2,r2,32768
 90c6bec:	10a00004 	addi	r2,r2,-32768
 90c6bf0:	1004803a 	cmplt	r2,r2,zero
 90c6bf4:	1000111e 	bne	r2,zero,90c6c3c <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 90c6bf8:	e0bffe17 	ldw	r2,-8(fp)
 90c6bfc:	10800117 	ldw	r2,4(r2)
 90c6c00:	10800103 	ldbu	r2,4(r2)
 90c6c04:	10803fcc 	andi	r2,r2,255
 90c6c08:	1080201c 	xori	r2,r2,128
 90c6c0c:	10bfe004 	addi	r2,r2,-128
 90c6c10:	10801b58 	cmpnei	r2,r2,109
 90c6c14:	1000091e 	bne	r2,zero,90c6c3c <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 90c6c18:	e0bffe17 	ldw	r2,-8(fp)
 90c6c1c:	10c00217 	ldw	r3,8(r2)
 90c6c20:	00800834 	movhi	r2,32
 90c6c24:	1887883a 	add	r3,r3,r2
 90c6c28:	e0bffb17 	ldw	r2,-20(fp)
 90c6c2c:	1009883a 	mov	r4,r2
 90c6c30:	180b883a 	mov	r5,r3
 90c6c34:	e1bffa17 	ldw	r6,-24(fp)
 90c6c38:	90894600 	call	9089460 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 90c6c3c:	e0bffe17 	ldw	r2,-8(fp)
 90c6c40:	10c00217 	ldw	r3,8(r2)
 90c6c44:	e0bffa17 	ldw	r2,-24(fp)
 90c6c48:	1887883a 	add	r3,r3,r2
 90c6c4c:	e0bffe17 	ldw	r2,-8(fp)
 90c6c50:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 90c6c54:	e0bffa17 	ldw	r2,-24(fp)
 90c6c58:	1007883a 	mov	r3,r2
 90c6c5c:	e0bffc17 	ldw	r2,-16(fp)
 90c6c60:	1885203a 	divu	r2,r3,r2
 90c6c64:	e0bfff15 	stw	r2,-4(fp)
 90c6c68:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6c6c:	e037883a 	mov	sp,fp
 90c6c70:	dfc00117 	ldw	ra,4(sp)
 90c6c74:	df000017 	ldw	fp,0(sp)
 90c6c78:	dec00204 	addi	sp,sp,8
 90c6c7c:	f800283a 	ret

090c6c80 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c6c80:	defffa04 	addi	sp,sp,-24
 90c6c84:	df000515 	stw	fp,20(sp)
 90c6c88:	df000504 	addi	fp,sp,20
 90c6c8c:	e13ffb15 	stw	r4,-20(fp)
 90c6c90:	e17ffc15 	stw	r5,-16(fp)
 90c6c94:	e1bffd15 	stw	r6,-12(fp)
 90c6c98:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 90c6c9c:	e0bffe17 	ldw	r2,-8(fp)
 90c6ca0:	10800117 	ldw	r2,4(r2)
 90c6ca4:	10800103 	ldbu	r2,4(r2)
 90c6ca8:	10803fcc 	andi	r2,r2,255
 90c6cac:	1080201c 	xori	r2,r2,128
 90c6cb0:	10bfe004 	addi	r2,r2,-128
 90c6cb4:	10801b58 	cmpnei	r2,r2,109
 90c6cb8:	1000021e 	bne	r2,zero,90c6cc4 <md_fwrite+0x44>
      return 0;   /* not writable device */
 90c6cbc:	e03fff15 	stw	zero,-4(fp)
 90c6cc0:	00000a06 	br	90c6cec <md_fwrite+0x6c>

   vfd->cmploc += (items * size);   /* adjust location */
 90c6cc4:	e0bffe17 	ldw	r2,-8(fp)
 90c6cc8:	11000217 	ldw	r4,8(r2)
 90c6ccc:	e0fffd17 	ldw	r3,-12(fp)
 90c6cd0:	e0bffc17 	ldw	r2,-16(fp)
 90c6cd4:	1885383a 	mul	r2,r3,r2
 90c6cd8:	2087883a 	add	r3,r4,r2
 90c6cdc:	e0bffe17 	ldw	r2,-8(fp)
 90c6ce0:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 90c6ce4:	e0bffd17 	ldw	r2,-12(fp)
 90c6ce8:	e0bfff15 	stw	r2,-4(fp)
 90c6cec:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6cf0:	e037883a 	mov	sp,fp
 90c6cf4:	df000017 	ldw	fp,0(sp)
 90c6cf8:	dec00104 	addi	sp,sp,4
 90c6cfc:	f800283a 	ret

090c6d00 <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 90c6d00:	defffc04 	addi	sp,sp,-16
 90c6d04:	df000315 	stw	fp,12(sp)
 90c6d08:	df000304 	addi	fp,sp,12
 90c6d0c:	e13ffd15 	stw	r4,-12(fp)
 90c6d10:	e17ffe15 	stw	r5,-8(fp)
 90c6d14:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 90c6d18:	0005883a 	mov	r2,zero
}
 90c6d1c:	e037883a 	mov	sp,fp
 90c6d20:	df000017 	ldw	fp,0(sp)
 90c6d24:	dec00104 	addi	sp,sp,4
 90c6d28:	f800283a 	ret

090c6d2c <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 90c6d2c:	defffe04 	addi	sp,sp,-8
 90c6d30:	df000115 	stw	fp,4(sp)
 90c6d34:	df000104 	addi	fp,sp,4
 90c6d38:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 90c6d3c:	00800834 	movhi	r2,32
}
 90c6d40:	e037883a 	mov	sp,fp
 90c6d44:	df000017 	ldw	fp,0(sp)
 90c6d48:	dec00104 	addi	sp,sp,4
 90c6d4c:	f800283a 	ret

090c6d50 <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 90c6d50:	defffb04 	addi	sp,sp,-20
 90c6d54:	df000415 	stw	fp,16(sp)
 90c6d58:	df000404 	addi	fp,sp,16
 90c6d5c:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 90c6d60:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 90c6d64:	e0bffe17 	ldw	r2,-8(fp)
 90c6d68:	10800217 	ldw	r2,8(r2)
 90c6d6c:	1007883a 	mov	r3,r2
 90c6d70:	e0bffe17 	ldw	r2,-8(fp)
 90c6d74:	10800117 	ldw	r2,4(r2)
 90c6d78:	10800617 	ldw	r2,24(r2)
 90c6d7c:	1885c83a 	sub	r2,r3,r2
 90c6d80:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 90c6d84:	e0bffe17 	ldw	r2,-8(fp)
 90c6d88:	10800117 	ldw	r2,4(r2)
 90c6d8c:	10c00717 	ldw	r3,28(r2)
 90c6d90:	e0bffd17 	ldw	r2,-12(fp)
 90c6d94:	10c00336 	bltu	r2,r3,90c6da4 <md_fgetc+0x54>
      return EOF;
 90c6d98:	00bfffc4 	movi	r2,-1
 90c6d9c:	e0bfff15 	stw	r2,-4(fp)
 90c6da0:	00001c06 	br	90c6e14 <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 90c6da4:	e0bffe17 	ldw	r2,-8(fp)
 90c6da8:	10800117 	ldw	r2,4(r2)
 90c6dac:	1080058b 	ldhu	r2,22(r2)
 90c6db0:	10bfffcc 	andi	r2,r2,65535
 90c6db4:	10a0001c 	xori	r2,r2,32768
 90c6db8:	10a00004 	addi	r2,r2,-32768
 90c6dbc:	1004803a 	cmplt	r2,r2,zero
 90c6dc0:	10000d1e 	bne	r2,zero,90c6df8 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 90c6dc4:	e0bffe17 	ldw	r2,-8(fp)
 90c6dc8:	10800117 	ldw	r2,4(r2)
 90c6dcc:	10800103 	ldbu	r2,4(r2)
 90c6dd0:	10803fcc 	andi	r2,r2,255
 90c6dd4:	1080201c 	xori	r2,r2,128
 90c6dd8:	10bfe004 	addi	r2,r2,-128
 90c6ddc:	10801b58 	cmpnei	r2,r2,109
 90c6de0:	1000051e 	bne	r2,zero,90c6df8 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 90c6de4:	e0bffe17 	ldw	r2,-8(fp)
 90c6de8:	10800217 	ldw	r2,8(r2)
 90c6dec:	10800003 	ldbu	r2,0(r2)
 90c6df0:	10803fcc 	andi	r2,r2,255
 90c6df4:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 90c6df8:	e0bffe17 	ldw	r2,-8(fp)
 90c6dfc:	10800217 	ldw	r2,8(r2)
 90c6e00:	10c00044 	addi	r3,r2,1
 90c6e04:	e0bffe17 	ldw	r2,-8(fp)
 90c6e08:	10c00215 	stw	r3,8(r2)
   return retval;
 90c6e0c:	e0bffc17 	ldw	r2,-16(fp)
 90c6e10:	e0bfff15 	stw	r2,-4(fp)
 90c6e14:	e0bfff17 	ldw	r2,-4(fp)
}
 90c6e18:	e037883a 	mov	sp,fp
 90c6e1c:	df000017 	ldw	fp,0(sp)
 90c6e20:	dec00104 	addi	sp,sp,4
 90c6e24:	f800283a 	ret

090c6e28 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 90c6e28:	defffe04 	addi	sp,sp,-8
 90c6e2c:	df000115 	stw	fp,4(sp)
 90c6e30:	df000104 	addi	fp,sp,4
 90c6e34:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 90c6e38:	0005883a 	mov	r2,zero
}
 90c6e3c:	e037883a 	mov	sp,fp
 90c6e40:	df000017 	ldw	fp,0(sp)
 90c6e44:	dec00104 	addi	sp,sp,4
 90c6e48:	f800283a 	ret

090c6e4c <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 90c6e4c:	defff504 	addi	sp,sp,-44
 90c6e50:	dfc00a15 	stw	ra,40(sp)
 90c6e54:	df000915 	stw	fp,36(sp)
 90c6e58:	df000904 	addi	fp,sp,36
 90c6e5c:	e13ffc15 	stw	r4,-16(fp)
 90c6e60:	e17ffd15 	stw	r5,-12(fp)
 90c6e64:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 90c6e68:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 90c6e6c:	00824374 	movhi	r2,2317
 90c6e70:	10858c04 	addi	r2,r2,5680
 90c6e74:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 90c6e78:	e0bffe17 	ldw	r2,-8(fp)
 90c6e7c:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 90c6e80:	00002606 	br	90c6f1c <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 90c6e84:	e0bffa17 	ldw	r2,-24(fp)
 90c6e88:	10800003 	ldbu	r2,0(r2)
 90c6e8c:	10803fcc 	andi	r2,r2,255
 90c6e90:	1080201c 	xori	r2,r2,128
 90c6e94:	10bfe004 	addi	r2,r2,-128
 90c6e98:	10800e88 	cmpgei	r2,r2,58
 90c6e9c:	10000e1e 	bne	r2,zero,90c6ed8 <parse_ipad+0x8c>
 90c6ea0:	e0bffa17 	ldw	r2,-24(fp)
 90c6ea4:	10800003 	ldbu	r2,0(r2)
 90c6ea8:	10803fcc 	andi	r2,r2,255
 90c6eac:	1080201c 	xori	r2,r2,128
 90c6eb0:	10bfe004 	addi	r2,r2,-128
 90c6eb4:	10800b90 	cmplti	r2,r2,46
 90c6eb8:	1000071e 	bne	r2,zero,90c6ed8 <parse_ipad+0x8c>
 90c6ebc:	e0bffa17 	ldw	r2,-24(fp)
 90c6ec0:	10800003 	ldbu	r2,0(r2)
 90c6ec4:	10803fcc 	andi	r2,r2,255
 90c6ec8:	1080201c 	xori	r2,r2,128
 90c6ecc:	10bfe004 	addi	r2,r2,-128
 90c6ed0:	10800bd8 	cmpnei	r2,r2,47
 90c6ed4:	1000041e 	bne	r2,zero,90c6ee8 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 90c6ed8:	00824374 	movhi	r2,2317
 90c6edc:	10859504 	addi	r2,r2,5716
 90c6ee0:	e0bfff15 	stw	r2,-4(fp)
 90c6ee4:	00009a06 	br	90c7150 <parse_ipad+0x304>
      if (*cp == '.')dots++;
 90c6ee8:	e0bffa17 	ldw	r2,-24(fp)
 90c6eec:	10800003 	ldbu	r2,0(r2)
 90c6ef0:	10803fcc 	andi	r2,r2,255
 90c6ef4:	1080201c 	xori	r2,r2,128
 90c6ef8:	10bfe004 	addi	r2,r2,-128
 90c6efc:	10800b98 	cmpnei	r2,r2,46
 90c6f00:	1000031e 	bne	r2,zero,90c6f10 <parse_ipad+0xc4>
 90c6f04:	e0bff917 	ldw	r2,-28(fp)
 90c6f08:	10800044 	addi	r2,r2,1
 90c6f0c:	e0bff915 	stw	r2,-28(fp)
         cp++;
 90c6f10:	e0bffa17 	ldw	r2,-24(fp)
 90c6f14:	10800044 	addi	r2,r2,1
 90c6f18:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 90c6f1c:	e0bffa17 	ldw	r2,-24(fp)
 90c6f20:	10800003 	ldbu	r2,0(r2)
 90c6f24:	10803fcc 	andi	r2,r2,255
 90c6f28:	1080201c 	xori	r2,r2,128
 90c6f2c:	10bfe004 	addi	r2,r2,-128
 90c6f30:	1004c03a 	cmpne	r2,r2,zero
 90c6f34:	103fd31e 	bne	r2,zero,90c6e84 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 90c6f38:	e0bff917 	ldw	r2,-28(fp)
 90c6f3c:	10800050 	cmplti	r2,r2,1
 90c6f40:	1000031e 	bne	r2,zero,90c6f50 <parse_ipad+0x104>
 90c6f44:	e0bff917 	ldw	r2,-28(fp)
 90c6f48:	10800110 	cmplti	r2,r2,4
 90c6f4c:	1000041e 	bne	r2,zero,90c6f60 <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 90c6f50:	00824374 	movhi	r2,2317
 90c6f54:	1085a004 	addi	r2,r2,5760
 90c6f58:	e0bfff15 	stw	r2,-4(fp)
 90c6f5c:	00007c06 	br	90c7150 <parse_ipad+0x304>

   cp = stringin;
 90c6f60:	e0bffe17 	ldw	r2,-8(fp)
 90c6f64:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 90c6f68:	e13ffa17 	ldw	r4,-24(fp)
 90c6f6c:	90cb3cc0 	call	90cb3cc <atoi>
 90c6f70:	e0bff815 	stw	r2,-32(fp)
 90c6f74:	e0bff817 	ldw	r2,-32(fp)
 90c6f78:	10804010 	cmplti	r2,r2,256
 90c6f7c:	1000031e 	bne	r2,zero,90c6f8c <parse_ipad+0x140>
      return(toobig);
 90c6f80:	e0bff717 	ldw	r2,-36(fp)
 90c6f84:	e0bfff15 	stw	r2,-4(fp)
 90c6f88:	00007106 	br	90c7150 <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 90c6f8c:	e0bff817 	ldw	r2,-32(fp)
 90c6f90:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 90c6f94:	00000306 	br	90c6fa4 <parse_ipad+0x158>
 90c6f98:	e0bffa17 	ldw	r2,-24(fp)
 90c6f9c:	10800044 	addi	r2,r2,1
 90c6fa0:	e0bffa15 	stw	r2,-24(fp)
 90c6fa4:	e0bffa17 	ldw	r2,-24(fp)
 90c6fa8:	10800003 	ldbu	r2,0(r2)
 90c6fac:	10803fcc 	andi	r2,r2,255
 90c6fb0:	1080201c 	xori	r2,r2,128
 90c6fb4:	10bfe004 	addi	r2,r2,-128
 90c6fb8:	10800b98 	cmpnei	r2,r2,46
 90c6fbc:	103ff61e 	bne	r2,zero,90c6f98 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 90c6fc0:	e0bffa17 	ldw	r2,-24(fp)
 90c6fc4:	10800044 	addi	r2,r2,1
 90c6fc8:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 90c6fcc:	e0bff917 	ldw	r2,-28(fp)
 90c6fd0:	10800060 	cmpeqi	r2,r2,1
 90c6fd4:	1000031e 	bne	r2,zero,90c6fe4 <parse_ipad+0x198>
 90c6fd8:	e0bff917 	ldw	r2,-28(fp)
 90c6fdc:	10800098 	cmpnei	r2,r2,2
 90c6fe0:	1000021e 	bne	r2,zero,90c6fec <parse_ipad+0x1a0>
 90c6fe4:	e03ffb45 	stb	zero,-19(fp)
 90c6fe8:	00001906 	br	90c7050 <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 90c6fec:	e13ffa17 	ldw	r4,-24(fp)
 90c6ff0:	90cb3cc0 	call	90cb3cc <atoi>
 90c6ff4:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 90c6ff8:	00000306 	br	90c7008 <parse_ipad+0x1bc>
 90c6ffc:	e0bffa17 	ldw	r2,-24(fp)
 90c7000:	10800044 	addi	r2,r2,1
 90c7004:	e0bffa15 	stw	r2,-24(fp)
 90c7008:	e0bffa17 	ldw	r2,-24(fp)
 90c700c:	10800003 	ldbu	r2,0(r2)
 90c7010:	10803fcc 	andi	r2,r2,255
 90c7014:	1080201c 	xori	r2,r2,128
 90c7018:	10bfe004 	addi	r2,r2,-128
 90c701c:	10800b98 	cmpnei	r2,r2,46
 90c7020:	103ff61e 	bne	r2,zero,90c6ffc <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 90c7024:	e0bffa17 	ldw	r2,-24(fp)
 90c7028:	10800044 	addi	r2,r2,1
 90c702c:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 90c7030:	e0bff817 	ldw	r2,-32(fp)
 90c7034:	10804010 	cmplti	r2,r2,256
 90c7038:	1000031e 	bne	r2,zero,90c7048 <parse_ipad+0x1fc>
 90c703c:	e0bff717 	ldw	r2,-36(fp)
 90c7040:	e0bfff15 	stw	r2,-4(fp)
 90c7044:	00004206 	br	90c7150 <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 90c7048:	e0bff817 	ldw	r2,-32(fp)
 90c704c:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 90c7050:	e0bff917 	ldw	r2,-28(fp)
 90c7054:	10800058 	cmpnei	r2,r2,1
 90c7058:	1000021e 	bne	r2,zero,90c7064 <parse_ipad+0x218>
 90c705c:	e03ffb85 	stb	zero,-18(fp)
 90c7060:	00001906 	br	90c70c8 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 90c7064:	e13ffa17 	ldw	r4,-24(fp)
 90c7068:	90cb3cc0 	call	90cb3cc <atoi>
 90c706c:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 90c7070:	00000306 	br	90c7080 <parse_ipad+0x234>
 90c7074:	e0bffa17 	ldw	r2,-24(fp)
 90c7078:	10800044 	addi	r2,r2,1
 90c707c:	e0bffa15 	stw	r2,-24(fp)
 90c7080:	e0bffa17 	ldw	r2,-24(fp)
 90c7084:	10800003 	ldbu	r2,0(r2)
 90c7088:	10803fcc 	andi	r2,r2,255
 90c708c:	1080201c 	xori	r2,r2,128
 90c7090:	10bfe004 	addi	r2,r2,-128
 90c7094:	10800b98 	cmpnei	r2,r2,46
 90c7098:	103ff61e 	bne	r2,zero,90c7074 <parse_ipad+0x228>
         cp++;             /* point past dot */
 90c709c:	e0bffa17 	ldw	r2,-24(fp)
 90c70a0:	10800044 	addi	r2,r2,1
 90c70a4:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 90c70a8:	e0bff817 	ldw	r2,-32(fp)
 90c70ac:	10804010 	cmplti	r2,r2,256
 90c70b0:	1000031e 	bne	r2,zero,90c70c0 <parse_ipad+0x274>
 90c70b4:	e0bff717 	ldw	r2,-36(fp)
 90c70b8:	e0bfff15 	stw	r2,-4(fp)
 90c70bc:	00002406 	br	90c7150 <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 90c70c0:	e0bff817 	ldw	r2,-32(fp)
 90c70c4:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 90c70c8:	e13ffa17 	ldw	r4,-24(fp)
 90c70cc:	90cb3cc0 	call	90cb3cc <atoi>
 90c70d0:	e0bff815 	stw	r2,-32(fp)
 90c70d4:	e0bff817 	ldw	r2,-32(fp)
 90c70d8:	10804010 	cmplti	r2,r2,256
 90c70dc:	1000031e 	bne	r2,zero,90c70ec <parse_ipad+0x2a0>
      return(toobig);
 90c70e0:	e0bff717 	ldw	r2,-36(fp)
 90c70e4:	e0bfff15 	stw	r2,-4(fp)
 90c70e8:	00001906 	br	90c7150 <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 90c70ec:	e0bff817 	ldw	r2,-32(fp)
 90c70f0:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 90c70f4:	e0bffb03 	ldbu	r2,-20(fp)
 90c70f8:	10803fcc 	andi	r2,r2,255
 90c70fc:	10802028 	cmpgeui	r2,r2,128
 90c7100:	1000041e 	bne	r2,zero,90c7114 <parse_ipad+0x2c8>
 90c7104:	e0fffd17 	ldw	r3,-12(fp)
 90c7108:	00800204 	movi	r2,8
 90c710c:	18800015 	stw	r2,0(r3)
 90c7110:	00000b06 	br	90c7140 <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 90c7114:	e0bffb03 	ldbu	r2,-20(fp)
 90c7118:	10803fcc 	andi	r2,r2,255
 90c711c:	10803028 	cmpgeui	r2,r2,192
 90c7120:	1000041e 	bne	r2,zero,90c7134 <parse_ipad+0x2e8>
 90c7124:	e0fffd17 	ldw	r3,-12(fp)
 90c7128:	00800404 	movi	r2,16
 90c712c:	18800015 	stw	r2,0(r3)
 90c7130:	00000306 	br	90c7140 <parse_ipad+0x2f4>
      else *sbits = 24;
 90c7134:	e0fffd17 	ldw	r3,-12(fp)
 90c7138:	00800604 	movi	r2,24
 90c713c:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 90c7140:	e0fffb17 	ldw	r3,-20(fp)
 90c7144:	e0bffc17 	ldw	r2,-16(fp)
 90c7148:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 90c714c:	e03fff15 	stw	zero,-4(fp)
 90c7150:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7154:	e037883a 	mov	sp,fp
 90c7158:	dfc00117 	ldw	ra,4(sp)
 90c715c:	df000017 	ldw	fp,0(sp)
 90c7160:	dec00204 	addi	sp,sp,8
 90c7164:	f800283a 	ret

090c7168 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 90c7168:	defffa04 	addi	sp,sp,-24
 90c716c:	dfc00515 	stw	ra,20(sp)
 90c7170:	df000415 	stw	fp,16(sp)
 90c7174:	df000404 	addi	fp,sp,16
 90c7178:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 90c717c:	01024374 	movhi	r4,2317
 90c7180:	21150604 	addi	r4,r4,21528
 90c7184:	e17ffe17 	ldw	r5,-8(fp)
 90c7188:	90cb4c80 	call	90cb4c8 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 90c718c:	e17ffd04 	addi	r5,fp,-12
 90c7190:	e13ffc04 	addi	r4,fp,-16
 90c7194:	01824374 	movhi	r6,2317
 90c7198:	31950604 	addi	r6,r6,21528
 90c719c:	90c6e4c0 	call	90c6e4c <parse_ipad>
 90c71a0:	1004c03a 	cmpne	r2,r2,zero
 90c71a4:	1000031e 	bne	r2,zero,90c71b4 <inet_addr+0x4c>
   {
      return ipaddr ;
 90c71a8:	e0bffc17 	ldw	r2,-16(fp)
 90c71ac:	e0bfff15 	stw	r2,-4(fp)
 90c71b0:	00000106 	br	90c71b8 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 90c71b4:	e03fff15 	stw	zero,-4(fp)
 90c71b8:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 90c71bc:	e037883a 	mov	sp,fp
 90c71c0:	dfc00117 	ldw	ra,4(sp)
 90c71c4:	df000017 	ldw	fp,0(sp)
 90c71c8:	dec00204 	addi	sp,sp,8
 90c71cc:	f800283a 	ret

090c71d0 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 90c71d0:	defffd04 	addi	sp,sp,-12
 90c71d4:	df000215 	stw	fp,8(sp)
 90c71d8:	df000204 	addi	fp,sp,8
 90c71dc:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 90c71e0:	e0bffe17 	ldw	r2,-8(fp)
 90c71e4:	108003cc 	andi	r2,r2,15
 90c71e8:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 90c71ec:	e0bffe17 	ldw	r2,-8(fp)
 90c71f0:	10800288 	cmpgei	r2,r2,10
 90c71f4:	1000071e 	bne	r2,zero,90c7214 <hextoa+0x44>
      return (char)(val + '0');
 90c71f8:	e0bffe17 	ldw	r2,-8(fp)
 90c71fc:	10800c04 	addi	r2,r2,48
 90c7200:	10803fcc 	andi	r2,r2,255
 90c7204:	1080201c 	xori	r2,r2,128
 90c7208:	10bfe004 	addi	r2,r2,-128
 90c720c:	e0bfff15 	stw	r2,-4(fp)
 90c7210:	00000606 	br	90c722c <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 90c7214:	e0bffe17 	ldw	r2,-8(fp)
 90c7218:	10800dc4 	addi	r2,r2,55
 90c721c:	10803fcc 	andi	r2,r2,255
 90c7220:	1080201c 	xori	r2,r2,128
 90c7224:	10bfe004 	addi	r2,r2,-128
 90c7228:	e0bfff15 	stw	r2,-4(fp)
 90c722c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7230:	e037883a 	mov	sp,fp
 90c7234:	df000017 	ldw	fp,0(sp)
 90c7238:	dec00104 	addi	sp,sp,4
 90c723c:	f800283a 	ret

090c7240 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 90c7240:	defff704 	addi	sp,sp,-36
 90c7244:	dfc00815 	stw	ra,32(sp)
 90c7248:	df000715 	stw	fp,28(sp)
 90c724c:	df000704 	addi	fp,sp,28
 90c7250:	e13ffc15 	stw	r4,-16(fp)
 90c7254:	e17ffd15 	stw	r5,-12(fp)
 90c7258:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 90c725c:	e0bffc17 	ldw	r2,-16(fp)
 90c7260:	10800098 	cmpnei	r2,r2,2
 90c7264:	10001a1e 	bne	r2,zero,90c72d0 <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 90c7268:	e13ffa04 	addi	r4,fp,-24
 90c726c:	e17ffb04 	addi	r5,fp,-20
 90c7270:	e1bffd17 	ldw	r6,-12(fp)
 90c7274:	90c6e4c0 	call	90c6e4c <parse_ipad>
 90c7278:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 90c727c:	e0bff917 	ldw	r2,-28(fp)
 90c7280:	1004c03a 	cmpne	r2,r2,zero
 90c7284:	10000c1e 	bne	r2,zero,90c72b8 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 90c7288:	e13ffe17 	ldw	r4,-8(fp)
 90c728c:	e0fffa04 	addi	r3,fp,-24
 90c7290:	18800003 	ldbu	r2,0(r3)
 90c7294:	20800005 	stb	r2,0(r4)
 90c7298:	18800043 	ldbu	r2,1(r3)
 90c729c:	20800045 	stb	r2,1(r4)
 90c72a0:	18800083 	ldbu	r2,2(r3)
 90c72a4:	20800085 	stb	r2,2(r4)
 90c72a8:	188000c3 	ldbu	r2,3(r3)
 90c72ac:	208000c5 	stb	r2,3(r4)
         return 0;
 90c72b0:	e03fff15 	stw	zero,-4(fp)
 90c72b4:	00000706 	br	90c72d4 <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 90c72b8:	00824374 	movhi	r2,2317
 90c72bc:	1085aa04 	addi	r2,r2,5800
 90c72c0:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 90c72c4:	00800044 	movi	r2,1
 90c72c8:	e0bfff15 	stw	r2,-4(fp)
 90c72cc:	00000106 	br	90c72d4 <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 90c72d0:	e03fff15 	stw	zero,-4(fp)
 90c72d4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c72d8:	e037883a 	mov	sp,fp
 90c72dc:	dfc00117 	ldw	ra,4(sp)
 90c72e0:	df000017 	ldw	fp,0(sp)
 90c72e4:	dec00204 	addi	sp,sp,8
 90c72e8:	f800283a 	ret

090c72ec <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 90c72ec:	defff704 	addi	sp,sp,-36
 90c72f0:	dfc00815 	stw	ra,32(sp)
 90c72f4:	df000715 	stw	fp,28(sp)
 90c72f8:	df000704 	addi	fp,sp,28
 90c72fc:	e13ffb15 	stw	r4,-20(fp)
 90c7300:	e17ffc15 	stw	r5,-16(fp)
 90c7304:	e1bffd15 	stw	r6,-12(fp)
 90c7308:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 90c730c:	e0bffb17 	ldw	r2,-20(fp)
 90c7310:	10800098 	cmpnei	r2,r2,2
 90c7314:	1000111e 	bne	r2,zero,90c735c <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 90c7318:	e0bffc17 	ldw	r2,-16(fp)
 90c731c:	10800017 	ldw	r2,0(r2)
 90c7320:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 90c7324:	e13ff917 	ldw	r4,-28(fp)
 90c7328:	90a514c0 	call	90a514c <print_ipad>
 90c732c:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 90c7330:	e13ffa17 	ldw	r4,-24(fp)
 90c7334:	9083f540 	call	9083f54 <strlen>
 90c7338:	1007883a 	mov	r3,r2
 90c733c:	e0bffe17 	ldw	r2,-8(fp)
 90c7340:	1880062e 	bgeu	r3,r2,90c735c <inet_ntop+0x70>
      {
         strcpy(str, cp);
 90c7344:	e13ffd17 	ldw	r4,-12(fp)
 90c7348:	e17ffa17 	ldw	r5,-24(fp)
 90c734c:	90cb4c80 	call	90cb4c8 <strcpy>
         return (str);
 90c7350:	e0bffd17 	ldw	r2,-12(fp)
 90c7354:	e0bfff15 	stw	r2,-4(fp)
 90c7358:	00000106 	br	90c7360 <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 90c735c:	e03fff15 	stw	zero,-4(fp)
 90c7360:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7364:	e037883a 	mov	sp,fp
 90c7368:	dfc00117 	ldw	ra,4(sp)
 90c736c:	df000017 	ldw	fp,0(sp)
 90c7370:	dec00204 	addi	sp,sp,8
 90c7374:	f800283a 	ret

090c7378 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 90c7378:	defffb04 	addi	sp,sp,-20
 90c737c:	dfc00415 	stw	ra,16(sp)
 90c7380:	df000315 	stw	fp,12(sp)
 90c7384:	df000304 	addi	fp,sp,12
 90c7388:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 90c738c:	e0bffe17 	ldw	r2,-8(fp)
 90c7390:	1080000b 	ldhu	r2,0(r2)
 90c7394:	10bfffcc 	andi	r2,r2,65535
 90c7398:	10800098 	cmpnei	r2,r2,2
 90c739c:	1000071e 	bne	r2,zero,90c73bc <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 90c73a0:	e0bffe17 	ldw	r2,-8(fp)
 90c73a4:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 90c73a8:	e0bffd17 	ldw	r2,-12(fp)
 90c73ac:	11000117 	ldw	r4,4(r2)
 90c73b0:	90a514c0 	call	90a514c <print_ipad>
 90c73b4:	e0bfff15 	stw	r2,-4(fp)
 90c73b8:	00000106 	br	90c73c0 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 90c73bc:	e03fff15 	stw	zero,-4(fp)
 90c73c0:	e0bfff17 	ldw	r2,-4(fp)
}
 90c73c4:	e037883a 	mov	sp,fp
 90c73c8:	dfc00117 	ldw	ra,4(sp)
 90c73cc:	df000017 	ldw	fp,0(sp)
 90c73d0:	dec00204 	addi	sp,sp,8
 90c73d4:	f800283a 	ret

090c73d8 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 90c73d8:	defffb04 	addi	sp,sp,-20
 90c73dc:	dfc00415 	stw	ra,16(sp)
 90c73e0:	df000315 	stw	fp,12(sp)
 90c73e4:	df000304 	addi	fp,sp,12
 90c73e8:	e13ffe15 	stw	r4,-8(fp)
 90c73ec:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 90c73f0:	e0ffff17 	ldw	r3,-4(fp)
 90c73f4:	00800084 	movi	r2,2
 90c73f8:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 90c73fc:	e0bffe17 	ldw	r2,-8(fp)
 90c7400:	10800044 	addi	r2,r2,1
 90c7404:	10800003 	ldbu	r2,0(r2)
 90c7408:	10803fcc 	andi	r2,r2,255
 90c740c:	1080201c 	xori	r2,r2,128
 90c7410:	10bfe004 	addi	r2,r2,-128
 90c7414:	10800ba0 	cmpeqi	r2,r2,46
 90c7418:	1000101e 	bne	r2,zero,90c745c <inet46_addr+0x84>
 90c741c:	e0bffe17 	ldw	r2,-8(fp)
 90c7420:	10800084 	addi	r2,r2,2
 90c7424:	10800003 	ldbu	r2,0(r2)
 90c7428:	10803fcc 	andi	r2,r2,255
 90c742c:	1080201c 	xori	r2,r2,128
 90c7430:	10bfe004 	addi	r2,r2,-128
 90c7434:	10800ba0 	cmpeqi	r2,r2,46
 90c7438:	1000081e 	bne	r2,zero,90c745c <inet46_addr+0x84>
 90c743c:	e0bffe17 	ldw	r2,-8(fp)
 90c7440:	108000c4 	addi	r2,r2,3
 90c7444:	10800003 	ldbu	r2,0(r2)
 90c7448:	10803fcc 	andi	r2,r2,255
 90c744c:	1080201c 	xori	r2,r2,128
 90c7450:	10bfe004 	addi	r2,r2,-128
 90c7454:	10800b98 	cmpnei	r2,r2,46
 90c7458:	10000a1e 	bne	r2,zero,90c7484 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 90c745c:	e0bfff17 	ldw	r2,-4(fp)
 90c7460:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 90c7464:	e13ffe17 	ldw	r4,-8(fp)
 90c7468:	90c71680 	call	90c7168 <inet_addr>
 90c746c:	1007883a 	mov	r3,r2
 90c7470:	e0bffd17 	ldw	r2,-12(fp)
 90c7474:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 90c7478:	e0fffd17 	ldw	r3,-12(fp)
 90c747c:	00800084 	movi	r2,2
 90c7480:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 90c7484:	0005883a 	mov	r2,zero
}
 90c7488:	e037883a 	mov	sp,fp
 90c748c:	dfc00117 	ldw	ra,4(sp)
 90c7490:	df000017 	ldw	fp,0(sp)
 90c7494:	dec00204 	addi	sp,sp,8
 90c7498:	f800283a 	ret

090c749c <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 90c749c:	defffc04 	addi	sp,sp,-16
 90c74a0:	df000315 	stw	fp,12(sp)
 90c74a4:	df000304 	addi	fp,sp,12
 90c74a8:	e13ffe15 	stw	r4,-8(fp)
 90c74ac:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 90c74b0:	e0bffe17 	ldw	r2,-8(fp)
 90c74b4:	1080000b 	ldhu	r2,0(r2)
 90c74b8:	10bfffcc 	andi	r2,r2,65535
 90c74bc:	10800098 	cmpnei	r2,r2,2
 90c74c0:	10000f1e 	bne	r2,zero,90c7500 <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 90c74c4:	e0bffe17 	ldw	r2,-8(fp)
 90c74c8:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 90c74cc:	e0bfff17 	ldw	r2,-4(fp)
 90c74d0:	1005d23a 	srai	r2,r2,8
 90c74d4:	10803fcc 	andi	r2,r2,255
 90c74d8:	1009883a 	mov	r4,r2
 90c74dc:	e0bfff17 	ldw	r2,-4(fp)
 90c74e0:	1004923a 	slli	r2,r2,8
 90c74e4:	1007883a 	mov	r3,r2
 90c74e8:	00bfc004 	movi	r2,-256
 90c74ec:	1884703a 	and	r2,r3,r2
 90c74f0:	2084b03a 	or	r2,r4,r2
 90c74f4:	1007883a 	mov	r3,r2
 90c74f8:	e0bffd17 	ldw	r2,-12(fp)
 90c74fc:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 90c7500:	e037883a 	mov	sp,fp
 90c7504:	df000017 	ldw	fp,0(sp)
 90c7508:	dec00104 	addi	sp,sp,4
 90c750c:	f800283a 	ret

090c7510 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 90c7510:	defff804 	addi	sp,sp,-32
 90c7514:	df000715 	stw	fp,28(sp)
 90c7518:	df000704 	addi	fp,sp,28
 90c751c:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 90c7520:	e0bffe17 	ldw	r2,-8(fp)
 90c7524:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 90c7528:	e0bffd04 	addi	r2,fp,-12
 90c752c:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 90c7530:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 90c7534:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 90c7538:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 90c753c:	00003306 	br	90c760c <convert_ip+0xfc>
   {
      if( *cp == '.')
 90c7540:	e0bffc17 	ldw	r2,-16(fp)
 90c7544:	10800003 	ldbu	r2,0(r2)
 90c7548:	10803fcc 	andi	r2,r2,255
 90c754c:	1080201c 	xori	r2,r2,128
 90c7550:	10bfe004 	addi	r2,r2,-128
 90c7554:	10800b98 	cmpnei	r2,r2,46
 90c7558:	1000101e 	bne	r2,zero,90c759c <convert_ip+0x8c>
      {
         lpb[n] = (unsigned char) v;
 90c755c:	e0bffa17 	ldw	r2,-24(fp)
 90c7560:	1007883a 	mov	r3,r2
 90c7564:	e0bffb17 	ldw	r2,-20(fp)
 90c7568:	1887883a 	add	r3,r3,r2
 90c756c:	e0bff90b 	ldhu	r2,-28(fp)
 90c7570:	18800005 	stb	r2,0(r3)
         v = 0;
 90c7574:	e03ff90d 	sth	zero,-28(fp)
         n++;
 90c7578:	e0bffa17 	ldw	r2,-24(fp)
 90c757c:	10800044 	addi	r2,r2,1
 90c7580:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 90c7584:	e0bffa17 	ldw	r2,-24(fp)
 90c7588:	10800110 	cmplti	r2,r2,4
 90c758c:	10001c1e 	bne	r2,zero,90c7600 <convert_ip+0xf0>
         {
            return dw;
 90c7590:	e0bffd17 	ldw	r2,-12(fp)
 90c7594:	e0bfff15 	stw	r2,-4(fp)
 90c7598:	00002b06 	br	90c7648 <convert_ip+0x138>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 90c759c:	e0bffc17 	ldw	r2,-16(fp)
 90c75a0:	10800003 	ldbu	r2,0(r2)
 90c75a4:	10803fcc 	andi	r2,r2,255
 90c75a8:	1080201c 	xori	r2,r2,128
 90c75ac:	10bfe004 	addi	r2,r2,-128
 90c75b0:	10800c10 	cmplti	r2,r2,48
 90c75b4:	1000121e 	bne	r2,zero,90c7600 <convert_ip+0xf0>
 90c75b8:	e0bffc17 	ldw	r2,-16(fp)
 90c75bc:	10800003 	ldbu	r2,0(r2)
 90c75c0:	10803fcc 	andi	r2,r2,255
 90c75c4:	1080201c 	xori	r2,r2,128
 90c75c8:	10bfe004 	addi	r2,r2,-128
 90c75cc:	10800e88 	cmpgei	r2,r2,58
 90c75d0:	10000b1e 	bne	r2,zero,90c7600 <convert_ip+0xf0>
      {
         v = (v * 10) + (*cp - '0');
 90c75d4:	e0bff90b 	ldhu	r2,-28(fp)
 90c75d8:	108002a4 	muli	r2,r2,10
 90c75dc:	1007883a 	mov	r3,r2
 90c75e0:	e0bffc17 	ldw	r2,-16(fp)
 90c75e4:	10800003 	ldbu	r2,0(r2)
 90c75e8:	10803fcc 	andi	r2,r2,255
 90c75ec:	1080201c 	xori	r2,r2,128
 90c75f0:	10bfe004 	addi	r2,r2,-128
 90c75f4:	1885883a 	add	r2,r3,r2
 90c75f8:	10bff404 	addi	r2,r2,-48
 90c75fc:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 90c7600:	e0bffc17 	ldw	r2,-16(fp)
 90c7604:	10800044 	addi	r2,r2,1
 90c7608:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 90c760c:	e0bffc17 	ldw	r2,-16(fp)
 90c7610:	10800003 	ldbu	r2,0(r2)
 90c7614:	10803fcc 	andi	r2,r2,255
 90c7618:	1080201c 	xori	r2,r2,128
 90c761c:	10bfe004 	addi	r2,r2,-128
 90c7620:	1004c03a 	cmpne	r2,r2,zero
 90c7624:	103fc61e 	bne	r2,zero,90c7540 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 90c7628:	e0bffa17 	ldw	r2,-24(fp)
 90c762c:	1007883a 	mov	r3,r2
 90c7630:	e0bffb17 	ldw	r2,-20(fp)
 90c7634:	1887883a 	add	r3,r3,r2
 90c7638:	e0bff90b 	ldhu	r2,-28(fp)
 90c763c:	18800005 	stb	r2,0(r3)
   return dw;
 90c7640:	e0bffd17 	ldw	r2,-12(fp)
 90c7644:	e0bfff15 	stw	r2,-4(fp)
 90c7648:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 90c764c:	e037883a 	mov	sp,fp
 90c7650:	df000017 	ldw	fp,0(sp)
 90c7654:	dec00104 	addi	sp,sp,4
 90c7658:	f800283a 	ret

090c765c <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 90c765c:	defff804 	addi	sp,sp,-32
 90c7660:	dfc00715 	stw	ra,28(sp)
 90c7664:	df000615 	stw	fp,24(sp)
 90c7668:	df000604 	addi	fp,sp,24
 90c766c:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 90c7670:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 90c7674:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 90c7678:	e0bfff17 	ldw	r2,-4(fp)
 90c767c:	10800003 	ldbu	r2,0(r2)
 90c7680:	10803fcc 	andi	r2,r2,255
 90c7684:	108003cc 	andi	r2,r2,15
 90c7688:	1085883a 	add	r2,r2,r2
 90c768c:	1085883a 	add	r2,r2,r2
 90c7690:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 90c7694:	e0bfff17 	ldw	r2,-4(fp)
 90c7698:	1080008b 	ldhu	r2,2(r2)
 90c769c:	10bfffcc 	andi	r2,r2,65535
 90c76a0:	1004d23a 	srli	r2,r2,8
 90c76a4:	10803fcc 	andi	r2,r2,255
 90c76a8:	1009883a 	mov	r4,r2
 90c76ac:	e0bfff17 	ldw	r2,-4(fp)
 90c76b0:	1080008b 	ldhu	r2,2(r2)
 90c76b4:	10bfffcc 	andi	r2,r2,65535
 90c76b8:	1004923a 	slli	r2,r2,8
 90c76bc:	1007883a 	mov	r3,r2
 90c76c0:	00bfc004 	movi	r2,-256
 90c76c4:	1884703a 	and	r2,r3,r2
 90c76c8:	2084b03a 	or	r2,r4,r2
 90c76cc:	1007883a 	mov	r3,r2
 90c76d0:	e0bffe8b 	ldhu	r2,-6(fp)
 90c76d4:	1885c83a 	sub	r2,r3,r2
 90c76d8:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 90c76dc:	e0bfff17 	ldw	r2,-4(fp)
 90c76e0:	10800003 	ldbu	r2,0(r2)
 90c76e4:	10803fcc 	andi	r2,r2,255
 90c76e8:	108003cc 	andi	r2,r2,15
 90c76ec:	1085883a 	add	r2,r2,r2
 90c76f0:	1085883a 	add	r2,r2,r2
 90c76f4:	1007883a 	mov	r3,r2
 90c76f8:	e0bfff17 	ldw	r2,-4(fp)
 90c76fc:	1885883a 	add	r2,r3,r2
 90c7700:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 90c7704:	e0bffa17 	ldw	r2,-24(fp)
 90c7708:	1080040b 	ldhu	r2,16(r2)
 90c770c:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 90c7710:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7714:	10800184 	addi	r2,r2,6
 90c7718:	1005d23a 	srai	r2,r2,8
 90c771c:	10803fcc 	andi	r2,r2,255
 90c7720:	1009883a 	mov	r4,r2
 90c7724:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7728:	10800184 	addi	r2,r2,6
 90c772c:	1004923a 	slli	r2,r2,8
 90c7730:	1007883a 	mov	r3,r2
 90c7734:	00bfc004 	movi	r2,-256
 90c7738:	1884703a 	and	r2,r3,r2
 90c773c:	2084b03a 	or	r2,r4,r2
 90c7740:	1007883a 	mov	r3,r2
 90c7744:	e0bffa17 	ldw	r2,-24(fp)
 90c7748:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 90c774c:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7750:	1080004c 	andi	r2,r2,1
 90c7754:	10803fcc 	andi	r2,r2,255
 90c7758:	1005003a 	cmpeq	r2,r2,zero
 90c775c:	10000f1e 	bne	r2,zero,90c779c <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 90c7760:	e0bffe8b 	ldhu	r2,-6(fp)
 90c7764:	1007883a 	mov	r3,r2
 90c7768:	e0bfff17 	ldw	r2,-4(fp)
 90c776c:	1887883a 	add	r3,r3,r2
 90c7770:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7774:	1885883a 	add	r2,r3,r2
 90c7778:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 90c777c:	e0bffd17 	ldw	r2,-12(fp)
 90c7780:	10800003 	ldbu	r2,0(r2)
 90c7784:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 90c7788:	e0bffd17 	ldw	r2,-12(fp)
 90c778c:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 90c7790:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7794:	10800044 	addi	r2,r2,1
 90c7798:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 90c779c:	e0bffa17 	ldw	r2,-24(fp)
 90c77a0:	113ffe04 	addi	r4,r2,-8
 90c77a4:	e0bffe0b 	ldhu	r2,-8(fp)
 90c77a8:	10800204 	addi	r2,r2,8
 90c77ac:	1005d07a 	srai	r2,r2,1
 90c77b0:	100b883a 	mov	r5,r2
 90c77b4:	90a4ef40 	call	90a4ef4 <cksum>
 90c77b8:	0084303a 	nor	r2,zero,r2
 90c77bc:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 90c77c0:	e0fffb0b 	ldhu	r3,-20(fp)
 90c77c4:	e0bffb8b 	ldhu	r2,-18(fp)
 90c77c8:	18800826 	beq	r3,r2,90c77ec <tcp_cksum+0x190>
 90c77cc:	e0fffb8b 	ldhu	r3,-18(fp)
 90c77d0:	00bfffd4 	movui	r2,65535
 90c77d4:	1880051e 	bne	r3,r2,90c77ec <tcp_cksum+0x190>
 90c77d8:	e0bffb0b 	ldhu	r2,-20(fp)
 90c77dc:	1004c03a 	cmpne	r2,r2,zero
 90c77e0:	1000021e 	bne	r2,zero,90c77ec <tcp_cksum+0x190>
      newsum = 0xffff;
 90c77e4:	00bfffc4 	movi	r2,-1
 90c77e8:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 90c77ec:	e0fffa17 	ldw	r3,-24(fp)
 90c77f0:	e0bffb8b 	ldhu	r2,-18(fp)
 90c77f4:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 90c77f8:	e0bffc07 	ldb	r2,-16(fp)
 90c77fc:	1005003a 	cmpeq	r2,r2,zero
 90c7800:	1000031e 	bne	r2,zero,90c7810 <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 90c7804:	e0fffd17 	ldw	r3,-12(fp)
 90c7808:	e0bffc03 	ldbu	r2,-16(fp)
 90c780c:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 90c7810:	e0bffb0b 	ldhu	r2,-20(fp)
}
 90c7814:	e037883a 	mov	sp,fp
 90c7818:	dfc00117 	ldw	ra,4(sp)
 90c781c:	df000017 	ldw	fp,0(sp)
 90c7820:	dec00204 	addi	sp,sp,8
 90c7824:	f800283a 	ret

090c7828 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 90c7828:	defffa04 	addi	sp,sp,-24
 90c782c:	dfc00515 	stw	ra,20(sp)
 90c7830:	df000415 	stw	fp,16(sp)
 90c7834:	df000404 	addi	fp,sp,16
 90c7838:	e13ffd15 	stw	r4,-12(fp)
 90c783c:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 90c7840:	01000b04 	movi	r4,44
 90c7844:	90aaefc0 	call	90aaefc <npalloc>
 90c7848:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 90c784c:	e0bffc17 	ldw	r2,-16(fp)
 90c7850:	1004c03a 	cmpne	r2,r2,zero
 90c7854:	1000031e 	bne	r2,zero,90c7864 <in_pcballoc+0x3c>
      return ENOMEM;
 90c7858:	00800304 	movi	r2,12
 90c785c:	e0bfff15 	stw	r2,-4(fp)
 90c7860:	00001006 	br	90c78a4 <in_pcballoc+0x7c>
   inp->inp_head = head;
 90c7864:	e0fffc17 	ldw	r3,-16(fp)
 90c7868:	e0bffe17 	ldw	r2,-8(fp)
 90c786c:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 90c7870:	e0fffc17 	ldw	r3,-16(fp)
 90c7874:	e0bffd17 	ldw	r2,-12(fp)
 90c7878:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 90c787c:	e0fffc17 	ldw	r3,-16(fp)
 90c7880:	00808004 	movi	r2,512
 90c7884:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 90c7888:	e13ffc17 	ldw	r4,-16(fp)
 90c788c:	e17ffe17 	ldw	r5,-8(fp)
 90c7890:	90abc3c0 	call	90abc3c <insque>
   so->so_pcb = inp;
 90c7894:	e0fffd17 	ldw	r3,-12(fp)
 90c7898:	e0bffc17 	ldw	r2,-16(fp)
 90c789c:	18800115 	stw	r2,4(r3)
   return 0;
 90c78a0:	e03fff15 	stw	zero,-4(fp)
 90c78a4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c78a8:	e037883a 	mov	sp,fp
 90c78ac:	dfc00117 	ldw	ra,4(sp)
 90c78b0:	df000017 	ldw	fp,0(sp)
 90c78b4:	dec00204 	addi	sp,sp,8
 90c78b8:	f800283a 	ret

090c78bc <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 90c78bc:	defffc04 	addi	sp,sp,-16
 90c78c0:	dfc00315 	stw	ra,12(sp)
 90c78c4:	df000215 	stw	fp,8(sp)
 90c78c8:	df000204 	addi	fp,sp,8
 90c78cc:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 90c78d0:	e0bfff17 	ldw	r2,-4(fp)
 90c78d4:	10800817 	ldw	r2,32(r2)
 90c78d8:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 90c78dc:	e0bffe17 	ldw	r2,-8(fp)
 90c78e0:	10000115 	stw	zero,4(r2)
   sofree(so);
 90c78e4:	e13ffe17 	ldw	r4,-8(fp)
 90c78e8:	90af03c0 	call	90af03c <sofree>
   remque(inp);
 90c78ec:	e13fff17 	ldw	r4,-4(fp)
 90c78f0:	90abbcc0 	call	90abbcc <remque>
   INP_FREE (inp);
 90c78f4:	e13fff17 	ldw	r4,-4(fp)
 90c78f8:	90aaff00 	call	90aaff0 <npfree>
}
 90c78fc:	e037883a 	mov	sp,fp
 90c7900:	dfc00117 	ldw	ra,4(sp)
 90c7904:	df000017 	ldw	fp,0(sp)
 90c7908:	dec00204 	addi	sp,sp,8
 90c790c:	f800283a 	ret

090c7910 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 90c7910:	defff404 	addi	sp,sp,-48
 90c7914:	dfc00b15 	stw	ra,44(sp)
 90c7918:	df000a15 	stw	fp,40(sp)
 90c791c:	df000a04 	addi	fp,sp,40
 90c7920:	e13ffd15 	stw	r4,-12(fp)
 90c7924:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 90c7928:	e0bffd17 	ldw	r2,-12(fp)
 90c792c:	10800817 	ldw	r2,32(r2)
 90c7930:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 90c7934:	e0bffd17 	ldw	r2,-12(fp)
 90c7938:	10800217 	ldw	r2,8(r2)
 90c793c:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 90c7940:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 90c7944:	e0bffd17 	ldw	r2,-12(fp)
 90c7948:	1080078b 	ldhu	r2,30(r2)
 90c794c:	10bfffcc 	andi	r2,r2,65535
 90c7950:	1004c03a 	cmpne	r2,r2,zero
 90c7954:	1000041e 	bne	r2,zero,90c7968 <in_pcbbind+0x58>
 90c7958:	e0bffd17 	ldw	r2,-12(fp)
 90c795c:	10800417 	ldw	r2,16(r2)
 90c7960:	1005003a 	cmpeq	r2,r2,zero
 90c7964:	1000031e 	bne	r2,zero,90c7974 <in_pcbbind+0x64>
      return (EINVAL);
 90c7968:	00800584 	movi	r2,22
 90c796c:	e0bfff15 	stw	r2,-4(fp)
 90c7970:	00007606 	br	90c7b4c <in_pcbbind+0x23c>
   if (nam == 0)
 90c7974:	e0bffe17 	ldw	r2,-8(fp)
 90c7978:	1005003a 	cmpeq	r2,r2,zero
 90c797c:	10003e1e 	bne	r2,zero,90c7a78 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 90c7980:	e0bffe17 	ldw	r2,-8(fp)
 90c7984:	10800317 	ldw	r2,12(r2)
 90c7988:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 90c798c:	e0bffa17 	ldw	r2,-24(fp)
 90c7990:	10800117 	ldw	r2,4(r2)
 90c7994:	1005003a 	cmpeq	r2,r2,zero
 90c7998:	10000a1e 	bne	r2,zero,90c79c4 <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 90c799c:	e0bffa17 	ldw	r2,-24(fp)
 90c79a0:	11000117 	ldw	r4,4(r2)
 90c79a4:	90bfa480 	call	90bfa48 <ip_mymach>
 90c79a8:	1007883a 	mov	r3,r2
 90c79ac:	e0bffa17 	ldw	r2,-24(fp)
 90c79b0:	10800117 	ldw	r2,4(r2)
 90c79b4:	18800326 	beq	r3,r2,90c79c4 <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 90c79b8:	00801f44 	movi	r2,125
 90c79bc:	e0bfff15 	stw	r2,-4(fp)
 90c79c0:	00006206 	br	90c7b4c <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 90c79c4:	e0bffa17 	ldw	r2,-24(fp)
 90c79c8:	1080008b 	ldhu	r2,2(r2)
 90c79cc:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 90c79d0:	e0bff90b 	ldhu	r2,-28(fp)
 90c79d4:	1005003a 	cmpeq	r2,r2,zero
 90c79d8:	1000231e 	bne	r2,zero,90c7a68 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 90c79dc:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 90c79e0:	e0bffc17 	ldw	r2,-16(fp)
 90c79e4:	10800417 	ldw	r2,16(r2)
 90c79e8:	1080010c 	andi	r2,r2,4
 90c79ec:	1004c03a 	cmpne	r2,r2,zero
 90c79f0:	10000e1e 	bne	r2,zero,90c7a2c <in_pcbbind+0x11c>
 90c79f4:	e0bffc17 	ldw	r2,-16(fp)
 90c79f8:	10800217 	ldw	r2,8(r2)
 90c79fc:	1080010b 	ldhu	r2,4(r2)
 90c7a00:	10bfffcc 	andi	r2,r2,65535
 90c7a04:	1080010c 	andi	r2,r2,4
 90c7a08:	1005003a 	cmpeq	r2,r2,zero
 90c7a0c:	1000051e 	bne	r2,zero,90c7a24 <in_pcbbind+0x114>
 90c7a10:	e0bffc17 	ldw	r2,-16(fp)
 90c7a14:	10800417 	ldw	r2,16(r2)
 90c7a18:	1080008c 	andi	r2,r2,2
 90c7a1c:	1004c03a 	cmpne	r2,r2,zero
 90c7a20:	1000021e 	bne	r2,zero,90c7a2c <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 90c7a24:	00800044 	movi	r2,1
 90c7a28:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 90c7a2c:	e0bffa17 	ldw	r2,-24(fp)
 90c7a30:	11c00117 	ldw	r7,4(r2)
 90c7a34:	e0bff90b 	ldhu	r2,-28(fp)
 90c7a38:	d8800015 	stw	r2,0(sp)
 90c7a3c:	e0bff817 	ldw	r2,-32(fp)
 90c7a40:	d8800115 	stw	r2,4(sp)
 90c7a44:	e13ffb17 	ldw	r4,-20(fp)
 90c7a48:	000b883a 	mov	r5,zero
 90c7a4c:	000d883a 	mov	r6,zero
 90c7a50:	90c7ecc0 	call	90c7ecc <in_pcblookup>
 90c7a54:	1005003a 	cmpeq	r2,r2,zero
 90c7a58:	1000031e 	bne	r2,zero,90c7a68 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 90c7a5c:	00801c04 	movi	r2,112
 90c7a60:	e0bfff15 	stw	r2,-4(fp)
 90c7a64:	00003906 	br	90c7b4c <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 90c7a68:	e0bffa17 	ldw	r2,-24(fp)
 90c7a6c:	10c00117 	ldw	r3,4(r2)
 90c7a70:	e0bffd17 	ldw	r2,-12(fp)
 90c7a74:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 90c7a78:	e0bff90b 	ldhu	r2,-28(fp)
 90c7a7c:	1004c03a 	cmpne	r2,r2,zero
 90c7a80:	10002e1e 	bne	r2,zero,90c7b3c <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 90c7a84:	e0bffb17 	ldw	r2,-20(fp)
 90c7a88:	10c0078b 	ldhu	r3,30(r2)
 90c7a8c:	18bfffcc 	andi	r2,r3,65535
 90c7a90:	10810030 	cmpltui	r2,r2,1024
 90c7a94:	1009883a 	mov	r4,r2
 90c7a98:	18800044 	addi	r2,r3,1
 90c7a9c:	1007883a 	mov	r3,r2
 90c7aa0:	e0bffb17 	ldw	r2,-20(fp)
 90c7aa4:	10c0078d 	sth	r3,30(r2)
 90c7aa8:	20803fcc 	andi	r2,r4,255
 90c7aac:	1004c03a 	cmpne	r2,r2,zero
 90c7ab0:	1000051e 	bne	r2,zero,90c7ac8 <in_pcbbind+0x1b8>
 90c7ab4:	e0bffb17 	ldw	r2,-20(fp)
 90c7ab8:	1080078b 	ldhu	r2,30(r2)
 90c7abc:	10bfffcc 	andi	r2,r2,65535
 90c7ac0:	1084e270 	cmpltui	r2,r2,5001
 90c7ac4:	1000031e 	bne	r2,zero,90c7ad4 <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 90c7ac8:	e0fffb17 	ldw	r3,-20(fp)
 90c7acc:	00810004 	movi	r2,1024
 90c7ad0:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 90c7ad4:	e0bffb17 	ldw	r2,-20(fp)
 90c7ad8:	1080078b 	ldhu	r2,30(r2)
 90c7adc:	10bfffcc 	andi	r2,r2,65535
 90c7ae0:	1004d23a 	srli	r2,r2,8
 90c7ae4:	10803fcc 	andi	r2,r2,255
 90c7ae8:	1009883a 	mov	r4,r2
 90c7aec:	e0bffb17 	ldw	r2,-20(fp)
 90c7af0:	1080078b 	ldhu	r2,30(r2)
 90c7af4:	10bfffcc 	andi	r2,r2,65535
 90c7af8:	1004923a 	slli	r2,r2,8
 90c7afc:	1007883a 	mov	r3,r2
 90c7b00:	00bfc004 	movi	r2,-256
 90c7b04:	1884703a 	and	r2,r3,r2
 90c7b08:	2084b03a 	or	r2,r4,r2
 90c7b0c:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 90c7b10:	e0bffd17 	ldw	r2,-12(fp)
 90c7b14:	11c00417 	ldw	r7,16(r2)
 90c7b18:	e0bff90b 	ldhu	r2,-28(fp)
 90c7b1c:	d8800015 	stw	r2,0(sp)
 90c7b20:	d8000115 	stw	zero,4(sp)
 90c7b24:	e13ffb17 	ldw	r4,-20(fp)
 90c7b28:	000b883a 	mov	r5,zero
 90c7b2c:	000d883a 	mov	r6,zero
 90c7b30:	90c7ecc0 	call	90c7ecc <in_pcblookup>
 90c7b34:	1004c03a 	cmpne	r2,r2,zero
 90c7b38:	103fd21e 	bne	r2,zero,90c7a84 <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 90c7b3c:	e0fffd17 	ldw	r3,-12(fp)
 90c7b40:	e0bff90b 	ldhu	r2,-28(fp)
 90c7b44:	1880078d 	sth	r2,30(r3)
   return (0);
 90c7b48:	e03fff15 	stw	zero,-4(fp)
 90c7b4c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7b50:	e037883a 	mov	sp,fp
 90c7b54:	dfc00117 	ldw	ra,4(sp)
 90c7b58:	df000017 	ldw	fp,0(sp)
 90c7b5c:	dec00204 	addi	sp,sp,8
 90c7b60:	f800283a 	ret

090c7b64 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 90c7b64:	defff504 	addi	sp,sp,-44
 90c7b68:	dfc00a15 	stw	ra,40(sp)
 90c7b6c:	df000915 	stw	fp,36(sp)
 90c7b70:	df000904 	addi	fp,sp,36
 90c7b74:	e13ffd15 	stw	r4,-12(fp)
 90c7b78:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 90c7b7c:	e0bffe17 	ldw	r2,-8(fp)
 90c7b80:	10800317 	ldw	r2,12(r2)
 90c7b84:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 90c7b88:	e0bffe17 	ldw	r2,-8(fp)
 90c7b8c:	10800217 	ldw	r2,8(r2)
 90c7b90:	10800428 	cmpgeui	r2,r2,16
 90c7b94:	1000031e 	bne	r2,zero,90c7ba4 <in_pcbconnect+0x40>
      return (EINVAL);
 90c7b98:	00800584 	movi	r2,22
 90c7b9c:	e0bfff15 	stw	r2,-4(fp)
 90c7ba0:	00006e06 	br	90c7d5c <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 90c7ba4:	e0bffa17 	ldw	r2,-24(fp)
 90c7ba8:	1080000b 	ldhu	r2,0(r2)
 90c7bac:	10bfffcc 	andi	r2,r2,65535
 90c7bb0:	10a0001c 	xori	r2,r2,32768
 90c7bb4:	10a00004 	addi	r2,r2,-32768
 90c7bb8:	108000a0 	cmpeqi	r2,r2,2
 90c7bbc:	1000031e 	bne	r2,zero,90c7bcc <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 90c7bc0:	00801a84 	movi	r2,106
 90c7bc4:	e0bfff15 	stw	r2,-4(fp)
 90c7bc8:	00006406 	br	90c7d5c <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 90c7bcc:	e0bffa17 	ldw	r2,-24(fp)
 90c7bd0:	1080008b 	ldhu	r2,2(r2)
 90c7bd4:	10bfffcc 	andi	r2,r2,65535
 90c7bd8:	1004c03a 	cmpne	r2,r2,zero
 90c7bdc:	1000031e 	bne	r2,zero,90c7bec <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 90c7be0:	00801f44 	movi	r2,125
 90c7be4:	e0bfff15 	stw	r2,-4(fp)
 90c7be8:	00005c06 	br	90c7d5c <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 90c7bec:	e0bffa17 	ldw	r2,-24(fp)
 90c7bf0:	10800117 	ldw	r2,4(r2)
 90c7bf4:	1004c03a 	cmpne	r2,r2,zero
 90c7bf8:	1000101e 	bne	r2,zero,90c7c3c <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 90c7bfc:	e0bffd17 	ldw	r2,-12(fp)
 90c7c00:	1005003a 	cmpeq	r2,r2,zero
 90c7c04:	10000a1e 	bne	r2,zero,90c7c30 <in_pcbconnect+0xcc>
 90c7c08:	e0bffd17 	ldw	r2,-12(fp)
 90c7c0c:	10800a17 	ldw	r2,40(r2)
 90c7c10:	1005003a 	cmpeq	r2,r2,zero
 90c7c14:	1000061e 	bne	r2,zero,90c7c30 <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 90c7c18:	e0bffd17 	ldw	r2,-12(fp)
 90c7c1c:	10800a17 	ldw	r2,40(r2)
 90c7c20:	10c00a17 	ldw	r3,40(r2)
 90c7c24:	e0bffa17 	ldw	r2,-24(fp)
 90c7c28:	10c00115 	stw	r3,4(r2)
 90c7c2c:	00000a06 	br	90c7c58 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 90c7c30:	00801f44 	movi	r2,125
 90c7c34:	e0bfff15 	stw	r2,-4(fp)
 90c7c38:	00004806 	br	90c7d5c <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 90c7c3c:	e0bffa17 	ldw	r2,-24(fp)
 90c7c40:	10800117 	ldw	r2,4(r2)
 90c7c44:	10bfffd8 	cmpnei	r2,r2,-1
 90c7c48:	1000031e 	bne	r2,zero,90c7c58 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 90c7c4c:	00801f44 	movi	r2,125
 90c7c50:	e0bfff15 	stw	r2,-4(fp)
 90c7c54:	00004106 	br	90c7d5c <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 90c7c58:	e0bffd17 	ldw	r2,-12(fp)
 90c7c5c:	10800417 	ldw	r2,16(r2)
 90c7c60:	1004c03a 	cmpne	r2,r2,zero
 90c7c64:	10000f1e 	bne	r2,zero,90c7ca4 <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 90c7c68:	e0bffa17 	ldw	r2,-24(fp)
 90c7c6c:	11000117 	ldw	r4,4(r2)
 90c7c70:	e17ffc04 	addi	r5,fp,-16
 90c7c74:	90bfdac0 	call	90bfdac <iproute>
 90c7c78:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 90c7c7c:	e0bff917 	ldw	r2,-28(fp)
 90c7c80:	1004c03a 	cmpne	r2,r2,zero
 90c7c84:	1000031e 	bne	r2,zero,90c7c94 <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 90c7c88:	00801f44 	movi	r2,125
 90c7c8c:	e0bfff15 	stw	r2,-4(fp)
 90c7c90:	00003206 	br	90c7d5c <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 90c7c94:	e0bff917 	ldw	r2,-28(fp)
 90c7c98:	10800a17 	ldw	r2,40(r2)
 90c7c9c:	e0bffb15 	stw	r2,-20(fp)
 90c7ca0:	00000306 	br	90c7cb0 <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 90c7ca4:	e0bffd17 	ldw	r2,-12(fp)
 90c7ca8:	10800417 	ldw	r2,16(r2)
 90c7cac:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 90c7cb0:	e0bffd17 	ldw	r2,-12(fp)
 90c7cb4:	11000217 	ldw	r4,8(r2)
 90c7cb8:	e0bffa17 	ldw	r2,-24(fp)
 90c7cbc:	11400117 	ldw	r5,4(r2)
 90c7cc0:	e0bffa17 	ldw	r2,-24(fp)
 90c7cc4:	1080008b 	ldhu	r2,2(r2)
 90c7cc8:	11bfffcc 	andi	r6,r2,65535
 90c7ccc:	e0bffd17 	ldw	r2,-12(fp)
 90c7cd0:	1080078b 	ldhu	r2,30(r2)
 90c7cd4:	10bfffcc 	andi	r2,r2,65535
 90c7cd8:	d8800015 	stw	r2,0(sp)
 90c7cdc:	d8000115 	stw	zero,4(sp)
 90c7ce0:	e1fffb17 	ldw	r7,-20(fp)
 90c7ce4:	90c7ecc0 	call	90c7ecc <in_pcblookup>
 90c7ce8:	1005003a 	cmpeq	r2,r2,zero
 90c7cec:	1000031e 	bne	r2,zero,90c7cfc <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 90c7cf0:	00801c04 	movi	r2,112
 90c7cf4:	e0bfff15 	stw	r2,-4(fp)
 90c7cf8:	00001806 	br	90c7d5c <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 90c7cfc:	e0bffd17 	ldw	r2,-12(fp)
 90c7d00:	10800417 	ldw	r2,16(r2)
 90c7d04:	1004c03a 	cmpne	r2,r2,zero
 90c7d08:	10000b1e 	bne	r2,zero,90c7d38 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 90c7d0c:	e0bffd17 	ldw	r2,-12(fp)
 90c7d10:	1080078b 	ldhu	r2,30(r2)
 90c7d14:	10bfffcc 	andi	r2,r2,65535
 90c7d18:	1004c03a 	cmpne	r2,r2,zero
 90c7d1c:	1000031e 	bne	r2,zero,90c7d2c <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 90c7d20:	e13ffd17 	ldw	r4,-12(fp)
 90c7d24:	000b883a 	mov	r5,zero
 90c7d28:	90c79100 	call	90c7910 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 90c7d2c:	e0fffd17 	ldw	r3,-12(fp)
 90c7d30:	e0bffb17 	ldw	r2,-20(fp)
 90c7d34:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 90c7d38:	e0bffa17 	ldw	r2,-24(fp)
 90c7d3c:	10c00117 	ldw	r3,4(r2)
 90c7d40:	e0bffd17 	ldw	r2,-12(fp)
 90c7d44:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 90c7d48:	e0bffa17 	ldw	r2,-24(fp)
 90c7d4c:	10c0008b 	ldhu	r3,2(r2)
 90c7d50:	e0bffd17 	ldw	r2,-12(fp)
 90c7d54:	10c0070d 	sth	r3,28(r2)
   return 0;
 90c7d58:	e03fff15 	stw	zero,-4(fp)
 90c7d5c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c7d60:	e037883a 	mov	sp,fp
 90c7d64:	dfc00117 	ldw	ra,4(sp)
 90c7d68:	df000017 	ldw	fp,0(sp)
 90c7d6c:	dec00204 	addi	sp,sp,8
 90c7d70:	f800283a 	ret

090c7d74 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 90c7d74:	defffd04 	addi	sp,sp,-12
 90c7d78:	dfc00215 	stw	ra,8(sp)
 90c7d7c:	df000115 	stw	fp,4(sp)
 90c7d80:	df000104 	addi	fp,sp,4
 90c7d84:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 90c7d88:	e0bfff17 	ldw	r2,-4(fp)
 90c7d8c:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 90c7d90:	e0bfff17 	ldw	r2,-4(fp)
 90c7d94:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 90c7d98:	e0bfff17 	ldw	r2,-4(fp)
 90c7d9c:	10800817 	ldw	r2,32(r2)
 90c7da0:	1080088b 	ldhu	r2,34(r2)
 90c7da4:	10bfffcc 	andi	r2,r2,65535
 90c7da8:	1080004c 	andi	r2,r2,1
 90c7dac:	10803fcc 	andi	r2,r2,255
 90c7db0:	1005003a 	cmpeq	r2,r2,zero
 90c7db4:	1000021e 	bne	r2,zero,90c7dc0 <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 90c7db8:	e13fff17 	ldw	r4,-4(fp)
 90c7dbc:	90c78bc0 	call	90c78bc <in_pcbdetach>
}
 90c7dc0:	e037883a 	mov	sp,fp
 90c7dc4:	dfc00117 	ldw	ra,4(sp)
 90c7dc8:	df000017 	ldw	fp,0(sp)
 90c7dcc:	dec00204 	addi	sp,sp,8
 90c7dd0:	f800283a 	ret

090c7dd4 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 90c7dd4:	defffc04 	addi	sp,sp,-16
 90c7dd8:	df000315 	stw	fp,12(sp)
 90c7ddc:	df000304 	addi	fp,sp,12
 90c7de0:	e13ffe15 	stw	r4,-8(fp)
 90c7de4:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 90c7de8:	e0ffff17 	ldw	r3,-4(fp)
 90c7dec:	00800404 	movi	r2,16
 90c7df0:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 90c7df4:	e0bfff17 	ldw	r2,-4(fp)
 90c7df8:	10800317 	ldw	r2,12(r2)
 90c7dfc:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 90c7e00:	e0bffd17 	ldw	r2,-12(fp)
 90c7e04:	10000015 	stw	zero,0(r2)
 90c7e08:	10000115 	stw	zero,4(r2)
 90c7e0c:	10000215 	stw	zero,8(r2)
 90c7e10:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 90c7e14:	e0fffd17 	ldw	r3,-12(fp)
 90c7e18:	00800084 	movi	r2,2
 90c7e1c:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 90c7e20:	e0bffe17 	ldw	r2,-8(fp)
 90c7e24:	10c0078b 	ldhu	r3,30(r2)
 90c7e28:	e0bffd17 	ldw	r2,-12(fp)
 90c7e2c:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 90c7e30:	e0bffe17 	ldw	r2,-8(fp)
 90c7e34:	10c00417 	ldw	r3,16(r2)
 90c7e38:	e0bffd17 	ldw	r2,-12(fp)
 90c7e3c:	10c00115 	stw	r3,4(r2)
}
 90c7e40:	e037883a 	mov	sp,fp
 90c7e44:	df000017 	ldw	fp,0(sp)
 90c7e48:	dec00104 	addi	sp,sp,4
 90c7e4c:	f800283a 	ret

090c7e50 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 90c7e50:	defffc04 	addi	sp,sp,-16
 90c7e54:	df000315 	stw	fp,12(sp)
 90c7e58:	df000304 	addi	fp,sp,12
 90c7e5c:	e13ffe15 	stw	r4,-8(fp)
 90c7e60:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 90c7e64:	e0ffff17 	ldw	r3,-4(fp)
 90c7e68:	00800404 	movi	r2,16
 90c7e6c:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 90c7e70:	e0bfff17 	ldw	r2,-4(fp)
 90c7e74:	10800317 	ldw	r2,12(r2)
 90c7e78:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 90c7e7c:	e0bffd17 	ldw	r2,-12(fp)
 90c7e80:	10000015 	stw	zero,0(r2)
 90c7e84:	10000115 	stw	zero,4(r2)
 90c7e88:	10000215 	stw	zero,8(r2)
 90c7e8c:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 90c7e90:	e0fffd17 	ldw	r3,-12(fp)
 90c7e94:	00800084 	movi	r2,2
 90c7e98:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 90c7e9c:	e0bffe17 	ldw	r2,-8(fp)
 90c7ea0:	10c0070b 	ldhu	r3,28(r2)
 90c7ea4:	e0bffd17 	ldw	r2,-12(fp)
 90c7ea8:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 90c7eac:	e0bffe17 	ldw	r2,-8(fp)
 90c7eb0:	10c00317 	ldw	r3,12(r2)
 90c7eb4:	e0bffd17 	ldw	r2,-12(fp)
 90c7eb8:	10c00115 	stw	r3,4(r2)
}
 90c7ebc:	e037883a 	mov	sp,fp
 90c7ec0:	df000017 	ldw	fp,0(sp)
 90c7ec4:	dec00104 	addi	sp,sp,4
 90c7ec8:	f800283a 	ret

090c7ecc <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 90c7ecc:	defff404 	addi	sp,sp,-48
 90c7ed0:	df000b15 	stw	fp,44(sp)
 90c7ed4:	df000b04 	addi	fp,sp,44
 90c7ed8:	e13ffa15 	stw	r4,-24(fp)
 90c7edc:	e17ffb15 	stw	r5,-20(fp)
 90c7ee0:	e1fffd15 	stw	r7,-12(fp)
 90c7ee4:	e0800117 	ldw	r2,4(fp)
 90c7ee8:	e1bffc0d 	sth	r6,-16(fp)
 90c7eec:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 90c7ef0:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 90c7ef4:	e0bffc0b 	ldhu	r2,-16(fp)
 90c7ef8:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 90c7efc:	e0bffe0b 	ldhu	r2,-8(fp)
 90c7f00:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 90c7f04:	008000c4 	movi	r2,3
 90c7f08:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 90c7f0c:	e0bffa17 	ldw	r2,-24(fp)
 90c7f10:	10800017 	ldw	r2,0(r2)
 90c7f14:	e0bff915 	stw	r2,-28(fp)
 90c7f18:	00005006 	br	90c805c <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 90c7f1c:	e0bff917 	ldw	r2,-28(fp)
 90c7f20:	1080078b 	ldhu	r2,30(r2)
 90c7f24:	10ffffcc 	andi	r3,r2,65535
 90c7f28:	e0bff70b 	ldhu	r2,-36(fp)
 90c7f2c:	1880481e 	bne	r3,r2,90c8050 <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 90c7f30:	e0bff917 	ldw	r2,-28(fp)
 90c7f34:	10800817 	ldw	r2,32(r2)
 90c7f38:	10800517 	ldw	r2,20(r2)
 90c7f3c:	10800098 	cmpnei	r2,r2,2
 90c7f40:	1000431e 	bne	r2,zero,90c8050 <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 90c7f44:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 90c7f48:	e0bff917 	ldw	r2,-28(fp)
 90c7f4c:	10800417 	ldw	r2,16(r2)
 90c7f50:	1005003a 	cmpeq	r2,r2,zero
 90c7f54:	10000c1e 	bne	r2,zero,90c7f88 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 90c7f58:	e0bffd17 	ldw	r2,-12(fp)
 90c7f5c:	1004c03a 	cmpne	r2,r2,zero
 90c7f60:	1000041e 	bne	r2,zero,90c7f74 <in_pcblookup+0xa8>
            wildcard++;
 90c7f64:	e0bff517 	ldw	r2,-44(fp)
 90c7f68:	10800044 	addi	r2,r2,1
 90c7f6c:	e0bff515 	stw	r2,-44(fp)
 90c7f70:	00000b06 	br	90c7fa0 <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 90c7f74:	e0bff917 	ldw	r2,-28(fp)
 90c7f78:	10c00417 	ldw	r3,16(r2)
 90c7f7c:	e0bffd17 	ldw	r2,-12(fp)
 90c7f80:	1880331e 	bne	r3,r2,90c8050 <in_pcblookup+0x184>
            continue;
 90c7f84:	00000606 	br	90c7fa0 <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 90c7f88:	e0bffd17 	ldw	r2,-12(fp)
 90c7f8c:	1005003a 	cmpeq	r2,r2,zero
 90c7f90:	1000031e 	bne	r2,zero,90c7fa0 <in_pcblookup+0xd4>
            wildcard++;
 90c7f94:	e0bff517 	ldw	r2,-44(fp)
 90c7f98:	10800044 	addi	r2,r2,1
 90c7f9c:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 90c7fa0:	e0bff917 	ldw	r2,-28(fp)
 90c7fa4:	10800317 	ldw	r2,12(r2)
 90c7fa8:	1005003a 	cmpeq	r2,r2,zero
 90c7fac:	1000111e 	bne	r2,zero,90c7ff4 <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 90c7fb0:	e0bffb17 	ldw	r2,-20(fp)
 90c7fb4:	1004c03a 	cmpne	r2,r2,zero
 90c7fb8:	1000041e 	bne	r2,zero,90c7fcc <in_pcblookup+0x100>
            wildcard++;
 90c7fbc:	e0bff517 	ldw	r2,-44(fp)
 90c7fc0:	10800044 	addi	r2,r2,1
 90c7fc4:	e0bff515 	stw	r2,-44(fp)
 90c7fc8:	00001006 	br	90c800c <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 90c7fcc:	e0bff917 	ldw	r2,-28(fp)
 90c7fd0:	10c00317 	ldw	r3,12(r2)
 90c7fd4:	e0bffb17 	ldw	r2,-20(fp)
 90c7fd8:	18801d1e 	bne	r3,r2,90c8050 <in_pcblookup+0x184>
 90c7fdc:	e0bff917 	ldw	r2,-28(fp)
 90c7fe0:	1080070b 	ldhu	r2,28(r2)
 90c7fe4:	10ffffcc 	andi	r3,r2,65535
 90c7fe8:	e0bff78b 	ldhu	r2,-34(fp)
 90c7fec:	1880181e 	bne	r3,r2,90c8050 <in_pcblookup+0x184>
 90c7ff0:	00000606 	br	90c800c <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 90c7ff4:	e0bffb17 	ldw	r2,-20(fp)
 90c7ff8:	1005003a 	cmpeq	r2,r2,zero
 90c7ffc:	1000031e 	bne	r2,zero,90c800c <in_pcblookup+0x140>
            wildcard++;
 90c8000:	e0bff517 	ldw	r2,-44(fp)
 90c8004:	10800044 	addi	r2,r2,1
 90c8008:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 90c800c:	e0bff517 	ldw	r2,-44(fp)
 90c8010:	1005003a 	cmpeq	r2,r2,zero
 90c8014:	1000041e 	bne	r2,zero,90c8028 <in_pcblookup+0x15c>
 90c8018:	e0800217 	ldw	r2,8(fp)
 90c801c:	1080004c 	andi	r2,r2,1
 90c8020:	1005003a 	cmpeq	r2,r2,zero
 90c8024:	10000a1e 	bne	r2,zero,90c8050 <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 90c8028:	e0fff517 	ldw	r3,-44(fp)
 90c802c:	e0bff617 	ldw	r2,-40(fp)
 90c8030:	1880070e 	bge	r3,r2,90c8050 <in_pcblookup+0x184>
      {
         match = inp;
 90c8034:	e0bff917 	ldw	r2,-28(fp)
 90c8038:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 90c803c:	e0bff517 	ldw	r2,-44(fp)
 90c8040:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 90c8044:	e0bff617 	ldw	r2,-40(fp)
 90c8048:	1005003a 	cmpeq	r2,r2,zero
 90c804c:	1000061e 	bne	r2,zero,90c8068 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 90c8050:	e0bff917 	ldw	r2,-28(fp)
 90c8054:	10800017 	ldw	r2,0(r2)
 90c8058:	e0bff915 	stw	r2,-28(fp)
 90c805c:	e0fff917 	ldw	r3,-28(fp)
 90c8060:	e0bffa17 	ldw	r2,-24(fp)
 90c8064:	18bfad1e 	bne	r3,r2,90c7f1c <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 90c8068:	e0bff817 	ldw	r2,-32(fp)
 90c806c:	1004c03a 	cmpne	r2,r2,zero
 90c8070:	1000031e 	bne	r2,zero,90c8080 <in_pcblookup+0x1b4>
      return match;
 90c8074:	e0bff817 	ldw	r2,-32(fp)
 90c8078:	e0bfff15 	stw	r2,-4(fp)
 90c807c:	00002506 	br	90c8114 <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 90c8080:	e0bffa17 	ldw	r2,-24(fp)
 90c8084:	10c00017 	ldw	r3,0(r2)
 90c8088:	e0bff817 	ldw	r2,-32(fp)
 90c808c:	1880041e 	bne	r3,r2,90c80a0 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 90c8090:	d0a0d317 	ldw	r2,-31924(gp)
 90c8094:	10800044 	addi	r2,r2,1
 90c8098:	d0a0d315 	stw	r2,-31924(gp)
 90c809c:	00001b06 	br	90c810c <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 90c80a0:	d0a0d417 	ldw	r2,-31920(gp)
 90c80a4:	10800044 	addi	r2,r2,1
 90c80a8:	d0a0d415 	stw	r2,-31920(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 90c80ac:	e0bff817 	ldw	r2,-32(fp)
 90c80b0:	10c00017 	ldw	r3,0(r2)
 90c80b4:	e0bff817 	ldw	r2,-32(fp)
 90c80b8:	10800117 	ldw	r2,4(r2)
 90c80bc:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 90c80c0:	e0bff817 	ldw	r2,-32(fp)
 90c80c4:	10c00117 	ldw	r3,4(r2)
 90c80c8:	e0bff817 	ldw	r2,-32(fp)
 90c80cc:	10800017 	ldw	r2,0(r2)
 90c80d0:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 90c80d4:	e0bffa17 	ldw	r2,-24(fp)
 90c80d8:	10c00017 	ldw	r3,0(r2)
 90c80dc:	e0bff817 	ldw	r2,-32(fp)
 90c80e0:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 90c80e4:	e0fffa17 	ldw	r3,-24(fp)
 90c80e8:	e0bff817 	ldw	r2,-32(fp)
 90c80ec:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 90c80f0:	e0fff817 	ldw	r3,-32(fp)
 90c80f4:	e0bffa17 	ldw	r2,-24(fp)
 90c80f8:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 90c80fc:	e0bff817 	ldw	r2,-32(fp)
 90c8100:	10c00017 	ldw	r3,0(r2)
 90c8104:	e0bff817 	ldw	r2,-32(fp)
 90c8108:	18800115 	stw	r2,4(r3)
   }
   return (match);
 90c810c:	e0bff817 	ldw	r2,-32(fp)
 90c8110:	e0bfff15 	stw	r2,-4(fp)
 90c8114:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8118:	e037883a 	mov	sp,fp
 90c811c:	df000017 	ldw	fp,0(sp)
 90c8120:	dec00104 	addi	sp,sp,4
 90c8124:	f800283a 	ret

090c8128 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 90c8128:	defffe04 	addi	sp,sp,-8
 90c812c:	df000115 	stw	fp,4(sp)
 90c8130:	df000104 	addi	fp,sp,4
 90c8134:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 90c8138:	e0bfff17 	ldw	r2,-4(fp)
 90c813c:	d0a0d815 	stw	r2,-31904(gp)
}
 90c8140:	e037883a 	mov	sp,fp
 90c8144:	df000017 	ldw	fp,0(sp)
 90c8148:	dec00104 	addi	sp,sp,4
 90c814c:	f800283a 	ret

090c8150 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 90c8150:	deffff04 	addi	sp,sp,-4
 90c8154:	df000015 	stw	fp,0(sp)
 90c8158:	d839883a 	mov	fp,sp
   return vfopen_error;
 90c815c:	d0a0d817 	ldw	r2,-31904(gp)
}
 90c8160:	e037883a 	mov	sp,fp
 90c8164:	df000017 	ldw	fp,0(sp)
 90c8168:	dec00104 	addi	sp,sp,4
 90c816c:	f800283a 	ret

090c8170 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 90c8170:	defffc04 	addi	sp,sp,-16
 90c8174:	dfc00315 	stw	ra,12(sp)
 90c8178:	df000215 	stw	fp,8(sp)
 90c817c:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 90c8180:	d0a0da17 	ldw	r2,-31896(gp)
 90c8184:	10803ff0 	cmpltui	r2,r2,255
 90c8188:	1000021e 	bne	r2,zero,90c8194 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 90c818c:	e03fff15 	stw	zero,-4(fp)
 90c8190:	00001006 	br	90c81d4 <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 90c8194:	01000504 	movi	r4,20
 90c8198:	90aaefc0 	call	90aaefc <npalloc>
 90c819c:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 90c81a0:	e0bffe17 	ldw	r2,-8(fp)
 90c81a4:	1005003a 	cmpeq	r2,r2,zero
 90c81a8:	1000081e 	bne	r2,zero,90c81cc <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 90c81ac:	d0e0d617 	ldw	r3,-31912(gp)
 90c81b0:	e0bffe17 	ldw	r2,-8(fp)
 90c81b4:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 90c81b8:	e0bffe17 	ldw	r2,-8(fp)
 90c81bc:	d0a0d615 	stw	r2,-31912(gp)
      /* increment the count of open files */
      vfs_open_files++;
 90c81c0:	d0a0da17 	ldw	r2,-31896(gp)
 90c81c4:	10800044 	addi	r2,r2,1
 90c81c8:	d0a0da15 	stw	r2,-31896(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 90c81cc:	e0bffe17 	ldw	r2,-8(fp)
 90c81d0:	e0bfff15 	stw	r2,-4(fp)
 90c81d4:	e0bfff17 	ldw	r2,-4(fp)
}
 90c81d8:	e037883a 	mov	sp,fp
 90c81dc:	dfc00117 	ldw	ra,4(sp)
 90c81e0:	df000017 	ldw	fp,0(sp)
 90c81e4:	dec00204 	addi	sp,sp,8
 90c81e8:	f800283a 	ret

090c81ec <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 90c81ec:	defff804 	addi	sp,sp,-32
 90c81f0:	dfc00715 	stw	ra,28(sp)
 90c81f4:	df000615 	stw	fp,24(sp)
 90c81f8:	df000604 	addi	fp,sp,24
 90c81fc:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 90c8200:	d0e0db17 	ldw	r3,-31892(gp)
 90c8204:	e0bffe17 	ldw	r2,-8(fp)
 90c8208:	1887883a 	add	r3,r3,r2
 90c820c:	00bfffd4 	movui	r2,65535
 90c8210:	10c0022e 	bgeu	r2,r3,90c821c <vf_alloc_buffer+0x30>
      return NULL;
 90c8214:	e03fff15 	stw	zero,-4(fp)
 90c8218:	00002406 	br	90c82ac <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 90c821c:	00800104 	movi	r2,4
 90c8220:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 90c8224:	00800104 	movi	r2,4
 90c8228:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 90c822c:	e0fffc17 	ldw	r3,-16(fp)
 90c8230:	e0bffb17 	ldw	r2,-20(fp)
 90c8234:	10c0112e 	bgeu	r2,r3,90c827c <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 90c8238:	e0bffb17 	ldw	r2,-20(fp)
 90c823c:	108000a0 	cmpeqi	r2,r2,2
 90c8240:	1000011e 	bne	r2,zero,90c8248 <vf_alloc_buffer+0x5c>
 90c8244:	00000806 	br	90c8268 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 90c8248:	00bffff4 	movhi	r2,65535
 90c824c:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 90c8250:	e0fffe17 	ldw	r3,-8(fp)
 90c8254:	e0bffa17 	ldw	r2,-24(fp)
 90c8258:	1884703a 	and	r2,r3,r2
 90c825c:	1004c03a 	cmpne	r2,r2,zero
 90c8260:	1000041e 	bne	r2,zero,90c8274 <vf_alloc_buffer+0x88>
 90c8264:	00000506 	br	90c827c <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 90c8268:	90aa4780 	call	90aa478 <dtrap>
         return NULL;
 90c826c:	e03fff15 	stw	zero,-4(fp)
 90c8270:	00000e06 	br	90c82ac <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 90c8274:	e03fff15 	stw	zero,-4(fp)
 90c8278:	00000c06 	br	90c82ac <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 90c827c:	e13ffe17 	ldw	r4,-8(fp)
 90c8280:	90aaefc0 	call	90aaefc <npalloc>
 90c8284:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 90c8288:	e0bffd17 	ldw	r2,-12(fp)
 90c828c:	1005003a 	cmpeq	r2,r2,zero
 90c8290:	1000041e 	bne	r2,zero,90c82a4 <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 90c8294:	d0a0db17 	ldw	r2,-31892(gp)
 90c8298:	e0fffe17 	ldw	r3,-8(fp)
 90c829c:	10c5883a 	add	r2,r2,r3
 90c82a0:	d0a0db15 	stw	r2,-31892(gp)
   }

   return buffer;
 90c82a4:	e0bffd17 	ldw	r2,-12(fp)
 90c82a8:	e0bfff15 	stw	r2,-4(fp)
 90c82ac:	e0bfff17 	ldw	r2,-4(fp)
}
 90c82b0:	e037883a 	mov	sp,fp
 90c82b4:	dfc00117 	ldw	ra,4(sp)
 90c82b8:	df000017 	ldw	fp,0(sp)
 90c82bc:	dec00204 	addi	sp,sp,8
 90c82c0:	f800283a 	ret

090c82c4 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 90c82c4:	defffc04 	addi	sp,sp,-16
 90c82c8:	dfc00315 	stw	ra,12(sp)
 90c82cc:	df000215 	stw	fp,8(sp)
 90c82d0:	df000204 	addi	fp,sp,8
 90c82d4:	e13ffe15 	stw	r4,-8(fp)
 90c82d8:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 90c82dc:	e0bffe17 	ldw	r2,-8(fp)
 90c82e0:	1005003a 	cmpeq	r2,r2,zero
 90c82e4:	1000021e 	bne	r2,zero,90c82f0 <vf_free_buffer+0x2c>
      npfree(buffer);
 90c82e8:	e13ffe17 	ldw	r4,-8(fp)
 90c82ec:	90aaff00 	call	90aaff0 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 90c82f0:	d0a0db17 	ldw	r2,-31892(gp)
 90c82f4:	e0ffff17 	ldw	r3,-4(fp)
 90c82f8:	10c5c83a 	sub	r2,r2,r3
 90c82fc:	d0a0db15 	stw	r2,-31892(gp)
}
 90c8300:	e037883a 	mov	sp,fp
 90c8304:	dfc00117 	ldw	ra,4(sp)
 90c8308:	df000017 	ldw	fp,0(sp)
 90c830c:	dec00204 	addi	sp,sp,8
 90c8310:	f800283a 	ret

090c8314 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 90c8314:	defff804 	addi	sp,sp,-32
 90c8318:	dfc00715 	stw	ra,28(sp)
 90c831c:	df000615 	stw	fp,24(sp)
 90c8320:	df000604 	addi	fp,sp,24
 90c8324:	e13ffd15 	stw	r4,-12(fp)
 90c8328:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 90c832c:	0009883a 	mov	r4,zero
 90c8330:	90c81280 	call	90c8128 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 90c8334:	e13ffd17 	ldw	r4,-12(fp)
 90c8338:	01400fc4 	movi	r5,63
 90c833c:	90838000 	call	9083800 <strchr>
 90c8340:	1005003a 	cmpeq	r2,r2,zero
 90c8344:	1000031e 	bne	r2,zero,90c8354 <vfopen_locked+0x40>
   {
      dtrap();
 90c8348:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90c834c:	e03fff15 	stw	zero,-4(fp)
 90c8350:	0000c406 	br	90c8664 <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 90c8354:	e13ffd17 	ldw	r4,-12(fp)
 90c8358:	90c96c00 	call	90c96c0 <vfslookup_locked>
 90c835c:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 90c8360:	e0bffc17 	ldw	r2,-16(fp)
 90c8364:	1005003a 	cmpeq	r2,r2,zero
 90c8368:	10004e1e 	bne	r2,zero,90c84a4 <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 90c836c:	e0bffe17 	ldw	r2,-8(fp)
 90c8370:	10800003 	ldbu	r2,0(r2)
 90c8374:	10803fcc 	andi	r2,r2,255
 90c8378:	1080201c 	xori	r2,r2,128
 90c837c:	10bfe004 	addi	r2,r2,-128
 90c8380:	10801dd8 	cmpnei	r2,r2,119
 90c8384:	10000a1e 	bne	r2,zero,90c83b0 <vfopen_locked+0x9c>
 90c8388:	e0bffc17 	ldw	r2,-16(fp)
 90c838c:	1080058b 	ldhu	r2,22(r2)
 90c8390:	10bfffcc 	andi	r2,r2,65535
 90c8394:	1080080c 	andi	r2,r2,32
 90c8398:	1004c03a 	cmpne	r2,r2,zero
 90c839c:	1000041e 	bne	r2,zero,90c83b0 <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 90c83a0:	013ff984 	movi	r4,-26
 90c83a4:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c83a8:	e03fff15 	stw	zero,-4(fp)
 90c83ac:	0000ad06 	br	90c8664 <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 90c83b0:	90c81700 	call	90c8170 <vf_alloc_and_link_vop>
 90c83b4:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 90c83b8:	e0bffb17 	ldw	r2,-20(fp)
 90c83bc:	1004c03a 	cmpne	r2,r2,zero
 90c83c0:	1000041e 	bne	r2,zero,90c83d4 <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 90c83c4:	013ffb04 	movi	r4,-20
 90c83c8:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c83cc:	e03fff15 	stw	zero,-4(fp)
 90c83d0:	0000a406 	br	90c8664 <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 90c83d4:	e0fffb17 	ldw	r3,-20(fp)
 90c83d8:	e0bffc17 	ldw	r2,-16(fp)
 90c83dc:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 90c83e0:	e0bffc17 	ldw	r2,-16(fp)
 90c83e4:	10c00617 	ldw	r3,24(r2)
 90c83e8:	e0bffb17 	ldw	r2,-20(fp)
 90c83ec:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 90c83f0:	e0bffe17 	ldw	r2,-8(fp)
 90c83f4:	10800003 	ldbu	r2,0(r2)
 90c83f8:	10803fcc 	andi	r2,r2,255
 90c83fc:	1080201c 	xori	r2,r2,128
 90c8400:	10bfe004 	addi	r2,r2,-128
 90c8404:	10801858 	cmpnei	r2,r2,97
 90c8408:	10000b1e 	bne	r2,zero,90c8438 <vfopen_locked+0x124>
      {
         if (vfp->data)
 90c840c:	e0bffc17 	ldw	r2,-16(fp)
 90c8410:	10800617 	ldw	r2,24(r2)
 90c8414:	1005003a 	cmpeq	r2,r2,zero
 90c8418:	1000071e 	bne	r2,zero,90c8438 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 90c841c:	e0bffc17 	ldw	r2,-16(fp)
 90c8420:	10c00617 	ldw	r3,24(r2)
 90c8424:	e0bffc17 	ldw	r2,-16(fp)
 90c8428:	10800817 	ldw	r2,32(r2)
 90c842c:	1887883a 	add	r3,r3,r2
 90c8430:	e0bffb17 	ldw	r2,-20(fp)
 90c8434:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 90c8438:	e0bffe17 	ldw	r2,-8(fp)
 90c843c:	10800003 	ldbu	r2,0(r2)
 90c8440:	10803fcc 	andi	r2,r2,255
 90c8444:	1080201c 	xori	r2,r2,128
 90c8448:	10bfe004 	addi	r2,r2,-128
 90c844c:	10801dd8 	cmpnei	r2,r2,119
 90c8450:	1000111e 	bne	r2,zero,90c8498 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 90c8454:	e0bffc17 	ldw	r2,-16(fp)
 90c8458:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 90c845c:	e0bffc17 	ldw	r2,-16(fp)
 90c8460:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 90c8464:	e0bffc17 	ldw	r2,-16(fp)
 90c8468:	1080058b 	ldhu	r2,22(r2)
 90c846c:	10808014 	ori	r2,r2,512
 90c8470:	1007883a 	mov	r3,r2
 90c8474:	e0bffc17 	ldw	r2,-16(fp)
 90c8478:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c847c:	e0bffc17 	ldw	r2,-16(fp)
 90c8480:	10c0058b 	ldhu	r3,22(r2)
 90c8484:	00bfff84 	movi	r2,-2
 90c8488:	1884703a 	and	r2,r3,r2
 90c848c:	1007883a 	mov	r3,r2
 90c8490:	e0bffc17 	ldw	r2,-16(fp)
 90c8494:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 90c8498:	e0bffb17 	ldw	r2,-20(fp)
 90c849c:	e0bfff15 	stw	r2,-4(fp)
 90c84a0:	00007006 	br	90c8664 <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 90c84a4:	e0bffe17 	ldw	r2,-8(fp)
 90c84a8:	10800003 	ldbu	r2,0(r2)
 90c84ac:	10803fcc 	andi	r2,r2,255
 90c84b0:	1080201c 	xori	r2,r2,128
 90c84b4:	10bfe004 	addi	r2,r2,-128
 90c84b8:	10801ca0 	cmpeqi	r2,r2,114
 90c84bc:	1000151e 	bne	r2,zero,90c8514 <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 90c84c0:	d0a0d517 	ldw	r2,-31916(gp)
 90c84c4:	e0bffa15 	stw	r2,-24(fp)
 90c84c8:	00000f06 	br	90c8508 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 90c84cc:	e0bffa17 	ldw	r2,-24(fp)
 90c84d0:	10800117 	ldw	r2,4(r2)
 90c84d4:	e13ffd17 	ldw	r4,-12(fp)
 90c84d8:	e17ffe17 	ldw	r5,-8(fp)
 90c84dc:	103ee83a 	callr	r2
 90c84e0:	e0bffb15 	stw	r2,-20(fp)
 90c84e4:	e0bffb17 	ldw	r2,-20(fp)
 90c84e8:	1005003a 	cmpeq	r2,r2,zero
 90c84ec:	1000031e 	bne	r2,zero,90c84fc <vfopen_locked+0x1e8>
         {
            return vop;
 90c84f0:	e0bffb17 	ldw	r2,-20(fp)
 90c84f4:	e0bfff15 	stw	r2,-4(fp)
 90c84f8:	00005a06 	br	90c8664 <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 90c84fc:	e0bffa17 	ldw	r2,-24(fp)
 90c8500:	10800017 	ldw	r2,0(r2)
 90c8504:	e0bffa15 	stw	r2,-24(fp)
 90c8508:	e0bffa17 	ldw	r2,-24(fp)
 90c850c:	1004c03a 	cmpne	r2,r2,zero
 90c8510:	103fee1e 	bne	r2,zero,90c84cc <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 90c8514:	e0bffe17 	ldw	r2,-8(fp)
 90c8518:	10800003 	ldbu	r2,0(r2)
 90c851c:	10803fcc 	andi	r2,r2,255
 90c8520:	1080201c 	xori	r2,r2,128
 90c8524:	10bfe004 	addi	r2,r2,-128
 90c8528:	10801ca0 	cmpeqi	r2,r2,114
 90c852c:	10004a1e 	bne	r2,zero,90c8658 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 90c8530:	d0a0dc17 	ldw	r2,-31888(gp)
 90c8534:	10803ff0 	cmpltui	r2,r2,255
 90c8538:	1000041e 	bne	r2,zero,90c854c <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 90c853c:	013ffb04 	movi	r4,-20
 90c8540:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c8544:	e03fff15 	stw	zero,-4(fp)
 90c8548:	00004606 	br	90c8664 <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 90c854c:	e13ffd17 	ldw	r4,-12(fp)
 90c8550:	9083f540 	call	9083f54 <strlen>
 90c8554:	10800470 	cmpltui	r2,r2,17
 90c8558:	1000041e 	bne	r2,zero,90c856c <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 90c855c:	013ffd84 	movi	r4,-10
 90c8560:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c8564:	e03fff15 	stw	zero,-4(fp)
 90c8568:	00003e06 	br	90c8664 <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 90c856c:	01000b04 	movi	r4,44
 90c8570:	90aaefc0 	call	90aaefc <npalloc>
 90c8574:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 90c8578:	e0bffc17 	ldw	r2,-16(fp)
 90c857c:	1004c03a 	cmpne	r2,r2,zero
 90c8580:	1000041e 	bne	r2,zero,90c8594 <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 90c8584:	013ffb04 	movi	r4,-20
 90c8588:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c858c:	e03fff15 	stw	zero,-4(fp)
 90c8590:	00003406 	br	90c8664 <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 90c8594:	90c81700 	call	90c8170 <vf_alloc_and_link_vop>
 90c8598:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 90c859c:	e0bffb17 	ldw	r2,-20(fp)
 90c85a0:	1004c03a 	cmpne	r2,r2,zero
 90c85a4:	1000061e 	bne	r2,zero,90c85c0 <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 90c85a8:	e13ffc17 	ldw	r4,-16(fp)
 90c85ac:	90aaff00 	call	90aaff0 <npfree>
         set_vfopen_error(ENP_NOMEM);
 90c85b0:	013ffb04 	movi	r4,-20
 90c85b4:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 90c85b8:	e03fff15 	stw	zero,-4(fp)
 90c85bc:	00002906 	br	90c8664 <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 90c85c0:	d0e0d717 	ldw	r3,-31908(gp)
 90c85c4:	e0bffc17 	ldw	r2,-16(fp)
 90c85c8:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 90c85cc:	e0bffc17 	ldw	r2,-16(fp)
 90c85d0:	d0a0d715 	stw	r2,-31908(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 90c85d4:	d0a0dc17 	ldw	r2,-31888(gp)
 90c85d8:	10800044 	addi	r2,r2,1
 90c85dc:	d0a0dc15 	stw	r2,-31888(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 90c85e0:	e0bffd17 	ldw	r2,-12(fp)
 90c85e4:	10800003 	ldbu	r2,0(r2)
 90c85e8:	10803fcc 	andi	r2,r2,255
 90c85ec:	1080201c 	xori	r2,r2,128
 90c85f0:	10bfe004 	addi	r2,r2,-128
 90c85f4:	10800be0 	cmpeqi	r2,r2,47
 90c85f8:	1000071e 	bne	r2,zero,90c8618 <vfopen_locked+0x304>
 90c85fc:	e0bffd17 	ldw	r2,-12(fp)
 90c8600:	10800003 	ldbu	r2,0(r2)
 90c8604:	10803fcc 	andi	r2,r2,255
 90c8608:	1080201c 	xori	r2,r2,128
 90c860c:	10bfe004 	addi	r2,r2,-128
 90c8610:	10801718 	cmpnei	r2,r2,92
 90c8614:	1000031e 	bne	r2,zero,90c8624 <vfopen_locked+0x310>
         name++;
 90c8618:	e0bffd17 	ldw	r2,-12(fp)
 90c861c:	10800044 	addi	r2,r2,1
 90c8620:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 90c8624:	e0bffc17 	ldw	r2,-16(fp)
 90c8628:	11000104 	addi	r4,r2,4
 90c862c:	e17ffd17 	ldw	r5,-12(fp)
 90c8630:	90cb4c80 	call	90cb4c8 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 90c8634:	e0fffc17 	ldw	r3,-16(fp)
 90c8638:	0080d804 	movi	r2,864
 90c863c:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 90c8640:	e0fffb17 	ldw	r3,-20(fp)
 90c8644:	e0bffc17 	ldw	r2,-16(fp)
 90c8648:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 90c864c:	e0bffb17 	ldw	r2,-20(fp)
 90c8650:	e0bfff15 	stw	r2,-4(fp)
 90c8654:	00000306 	br	90c8664 <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 90c8658:	013ff9c4 	movi	r4,-25
 90c865c:	90c81280 	call	90c8128 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 90c8660:	e03fff15 	stw	zero,-4(fp)
 90c8664:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 90c8668:	e037883a 	mov	sp,fp
 90c866c:	dfc00117 	ldw	ra,4(sp)
 90c8670:	df000017 	ldw	fp,0(sp)
 90c8674:	dec00204 	addi	sp,sp,8
 90c8678:	f800283a 	ret

090c867c <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 90c867c:	defffb04 	addi	sp,sp,-20
 90c8680:	dfc00415 	stw	ra,16(sp)
 90c8684:	df000315 	stw	fp,12(sp)
 90c8688:	df000304 	addi	fp,sp,12
 90c868c:	e13ffe15 	stw	r4,-8(fp)
 90c8690:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c8694:	01000144 	movi	r4,5
 90c8698:	90aaab40 	call	90aaab4 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 90c869c:	e13ffe17 	ldw	r4,-8(fp)
 90c86a0:	e17fff17 	ldw	r5,-4(fp)
 90c86a4:	90c83140 	call	90c8314 <vfopen_locked>
 90c86a8:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 90c86ac:	01000144 	movi	r4,5
 90c86b0:	90aab680 	call	90aab68 <post_app_sem>

   return vfd;
 90c86b4:	e0bffd17 	ldw	r2,-12(fp)
}
 90c86b8:	e037883a 	mov	sp,fp
 90c86bc:	dfc00117 	ldw	ra,4(sp)
 90c86c0:	df000017 	ldw	fp,0(sp)
 90c86c4:	dec00204 	addi	sp,sp,8
 90c86c8:	f800283a 	ret

090c86cc <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 90c86cc:	defff804 	addi	sp,sp,-32
 90c86d0:	dfc00715 	stw	ra,28(sp)
 90c86d4:	df000615 	stw	fp,24(sp)
 90c86d8:	df000604 	addi	fp,sp,24
 90c86dc:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 90c86e0:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 90c86e4:	d0a0d617 	ldw	r2,-31912(gp)
 90c86e8:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 90c86ec:	00000806 	br	90c8710 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 90c86f0:	e0ffff17 	ldw	r3,-4(fp)
 90c86f4:	e0bffe17 	ldw	r2,-8(fp)
 90c86f8:	18800826 	beq	r3,r2,90c871c <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 90c86fc:	e0bffe17 	ldw	r2,-8(fp)
 90c8700:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 90c8704:	e0bffe17 	ldw	r2,-8(fp)
 90c8708:	10800017 	ldw	r2,0(r2)
 90c870c:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 90c8710:	e0bffe17 	ldw	r2,-8(fp)
 90c8714:	1004c03a 	cmpne	r2,r2,zero
 90c8718:	103ff51e 	bne	r2,zero,90c86f0 <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 90c871c:	e0ffff17 	ldw	r3,-4(fp)
 90c8720:	e0bffe17 	ldw	r2,-8(fp)
 90c8724:	18804e1e 	bne	r3,r2,90c8860 <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 90c8728:	e0bfff17 	ldw	r2,-4(fp)
 90c872c:	10800117 	ldw	r2,4(r2)
 90c8730:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 90c8734:	e0bffc17 	ldw	r2,-16(fp)
 90c8738:	1005003a 	cmpeq	r2,r2,zero
 90c873c:	1000381e 	bne	r2,zero,90c8820 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 90c8740:	e0bffc17 	ldw	r2,-16(fp)
 90c8744:	10800a17 	ldw	r2,40(r2)
 90c8748:	1005003a 	cmpeq	r2,r2,zero
 90c874c:	1000081e 	bne	r2,zero,90c8770 <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 90c8750:	e0bffc17 	ldw	r2,-16(fp)
 90c8754:	10800a17 	ldw	r2,40(r2)
 90c8758:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 90c875c:	e0bffa17 	ldw	r2,-24(fp)
 90c8760:	10800217 	ldw	r2,8(r2)
 90c8764:	e13fff17 	ldw	r4,-4(fp)
 90c8768:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 90c876c:	00002c06 	br	90c8820 <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 90c8770:	e0bffc17 	ldw	r2,-16(fp)
 90c8774:	1080058b 	ldhu	r2,22(r2)
 90c8778:	10bfffcc 	andi	r2,r2,65535
 90c877c:	1080200c 	andi	r2,r2,128
 90c8780:	1005003a 	cmpeq	r2,r2,zero
 90c8784:	1000261e 	bne	r2,zero,90c8820 <vfclose_locked+0x154>
 90c8788:	e0bffc17 	ldw	r2,-16(fp)
 90c878c:	10c00917 	ldw	r3,36(r2)
 90c8790:	e0bffc17 	ldw	r2,-16(fp)
 90c8794:	10800817 	ldw	r2,32(r2)
 90c8798:	1885c83a 	sub	r2,r3,r2
 90c879c:	10804030 	cmpltui	r2,r2,256
 90c87a0:	10001f1e 	bne	r2,zero,90c8820 <vfclose_locked+0x154>
 90c87a4:	e0bffc17 	ldw	r2,-16(fp)
 90c87a8:	10800617 	ldw	r2,24(r2)
 90c87ac:	1005003a 	cmpeq	r2,r2,zero
 90c87b0:	10001b1e 	bne	r2,zero,90c8820 <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 90c87b4:	e0bffc17 	ldw	r2,-16(fp)
 90c87b8:	11000817 	ldw	r4,32(r2)
 90c87bc:	90c81ec0 	call	90c81ec <vf_alloc_buffer>
 90c87c0:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 90c87c4:	e0bffb17 	ldw	r2,-20(fp)
 90c87c8:	1005003a 	cmpeq	r2,r2,zero
 90c87cc:	1000141e 	bne	r2,zero,90c8820 <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 90c87d0:	e0bffc17 	ldw	r2,-16(fp)
 90c87d4:	10c00617 	ldw	r3,24(r2)
 90c87d8:	e0bffc17 	ldw	r2,-16(fp)
 90c87dc:	11800817 	ldw	r6,32(r2)
 90c87e0:	e0bffb17 	ldw	r2,-20(fp)
 90c87e4:	1009883a 	mov	r4,r2
 90c87e8:	180b883a 	mov	r5,r3
 90c87ec:	90894600 	call	9089460 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 90c87f0:	e0bffc17 	ldw	r2,-16(fp)
 90c87f4:	11000617 	ldw	r4,24(r2)
 90c87f8:	e0bffc17 	ldw	r2,-16(fp)
 90c87fc:	11400917 	ldw	r5,36(r2)
 90c8800:	90c82c40 	call	90c82c4 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 90c8804:	e0fffc17 	ldw	r3,-16(fp)
 90c8808:	e0bffb17 	ldw	r2,-20(fp)
 90c880c:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 90c8810:	e0bffc17 	ldw	r2,-16(fp)
 90c8814:	10c00817 	ldw	r3,32(r2)
 90c8818:	e0bffc17 	ldw	r2,-16(fp)
 90c881c:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 90c8820:	e0bffd17 	ldw	r2,-12(fp)
 90c8824:	1005003a 	cmpeq	r2,r2,zero
 90c8828:	1000051e 	bne	r2,zero,90c8840 <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 90c882c:	e0bffe17 	ldw	r2,-8(fp)
 90c8830:	10c00017 	ldw	r3,0(r2)
 90c8834:	e0bffd17 	ldw	r2,-12(fp)
 90c8838:	10c00015 	stw	r3,0(r2)
 90c883c:	00000306 	br	90c884c <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 90c8840:	e0bffe17 	ldw	r2,-8(fp)
 90c8844:	10800017 	ldw	r2,0(r2)
 90c8848:	d0a0d615 	stw	r2,-31912(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 90c884c:	e13ffe17 	ldw	r4,-8(fp)
 90c8850:	90aaff00 	call	90aaff0 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 90c8854:	d0a0da17 	ldw	r2,-31896(gp)
 90c8858:	10bfffc4 	addi	r2,r2,-1
 90c885c:	d0a0da15 	stw	r2,-31896(gp)
   return;
}
 90c8860:	e037883a 	mov	sp,fp
 90c8864:	dfc00117 	ldw	ra,4(sp)
 90c8868:	df000017 	ldw	fp,0(sp)
 90c886c:	dec00204 	addi	sp,sp,8
 90c8870:	f800283a 	ret

090c8874 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 90c8874:	defffd04 	addi	sp,sp,-12
 90c8878:	dfc00215 	stw	ra,8(sp)
 90c887c:	df000115 	stw	fp,4(sp)
 90c8880:	df000104 	addi	fp,sp,4
 90c8884:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 90c8888:	01000144 	movi	r4,5
 90c888c:	90aaab40 	call	90aaab4 <wait_app_sem>

   vfclose_locked(vfd);
 90c8890:	e13fff17 	ldw	r4,-4(fp)
 90c8894:	90c86cc0 	call	90c86cc <vfclose_locked>

   vfs_unlock();
 90c8898:	01000144 	movi	r4,5
 90c889c:	90aab680 	call	90aab68 <post_app_sem>
}
 90c88a0:	e037883a 	mov	sp,fp
 90c88a4:	dfc00117 	ldw	ra,4(sp)
 90c88a8:	df000017 	ldw	fp,0(sp)
 90c88ac:	dec00204 	addi	sp,sp,8
 90c88b0:	f800283a 	ret

090c88b4 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 90c88b4:	defffd04 	addi	sp,sp,-12
 90c88b8:	dfc00215 	stw	ra,8(sp)
 90c88bc:	df000115 	stw	fp,4(sp)
 90c88c0:	df000104 	addi	fp,sp,4
 90c88c4:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 90c88c8:	01000144 	movi	r4,5
 90c88cc:	90aaab40 	call	90aaab4 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 90c88d0:	01024374 	movhi	r4,2317
 90c88d4:	2105b104 	addi	r4,r4,5828
 90c88d8:	90836b80 	call	90836b8 <puts>

   vfs_unlock();
 90c88dc:	01000144 	movi	r4,5
 90c88e0:	90aab680 	call	90aab68 <post_app_sem>
   return(0);
 90c88e4:	0005883a 	mov	r2,zero
}
 90c88e8:	e037883a 	mov	sp,fp
 90c88ec:	dfc00117 	ldw	ra,4(sp)
 90c88f0:	df000017 	ldw	fp,0(sp)
 90c88f4:	dec00204 	addi	sp,sp,8
 90c88f8:	f800283a 	ret

090c88fc <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 90c88fc:	defff804 	addi	sp,sp,-32
 90c8900:	dfc00715 	stw	ra,28(sp)
 90c8904:	df000615 	stw	fp,24(sp)
 90c8908:	df000604 	addi	fp,sp,24
 90c890c:	e13ffc15 	stw	r4,-16(fp)
 90c8910:	e17ffd15 	stw	r5,-12(fp)
 90c8914:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 90c8918:	e0bffc17 	ldw	r2,-16(fp)
 90c891c:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 90c8920:	00001106 	br	90c8968 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 90c8924:	e0bffb17 	ldw	r2,-20(fp)
 90c8928:	1007883a 	mov	r3,r2
 90c892c:	e0bffa17 	ldw	r2,-24(fp)
 90c8930:	10c00005 	stb	r3,0(r2)
 90c8934:	e0bffa17 	ldw	r2,-24(fp)
 90c8938:	10800003 	ldbu	r2,0(r2)
 90c893c:	10803fcc 	andi	r2,r2,255
 90c8940:	1080201c 	xori	r2,r2,128
 90c8944:	10bfe004 	addi	r2,r2,-128
 90c8948:	108002a0 	cmpeqi	r2,r2,10
 90c894c:	1007883a 	mov	r3,r2
 90c8950:	e0bffa17 	ldw	r2,-24(fp)
 90c8954:	10800044 	addi	r2,r2,1
 90c8958:	e0bffa15 	stw	r2,-24(fp)
 90c895c:	18803fcc 	andi	r2,r3,255
 90c8960:	1004c03a 	cmpne	r2,r2,zero
 90c8964:	10000c1e 	bne	r2,zero,90c8998 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 90c8968:	e0bffd17 	ldw	r2,-12(fp)
 90c896c:	10bfffc4 	addi	r2,r2,-1
 90c8970:	e0bffd15 	stw	r2,-12(fp)
 90c8974:	e0bffd17 	ldw	r2,-12(fp)
 90c8978:	10800050 	cmplti	r2,r2,1
 90c897c:	1000061e 	bne	r2,zero,90c8998 <vfgets+0x9c>
 90c8980:	e13ffe17 	ldw	r4,-8(fp)
 90c8984:	90c96780 	call	90c9678 <vgetc>
 90c8988:	e0bffb15 	stw	r2,-20(fp)
 90c898c:	e0bffb17 	ldw	r2,-20(fp)
 90c8990:	10bfffd8 	cmpnei	r2,r2,-1
 90c8994:	103fe31e 	bne	r2,zero,90c8924 <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 90c8998:	e0bffa17 	ldw	r2,-24(fp)
 90c899c:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 90c89a0:	e0bffb17 	ldw	r2,-20(fp)
 90c89a4:	10bfffd8 	cmpnei	r2,r2,-1
 90c89a8:	1000031e 	bne	r2,zero,90c89b8 <vfgets+0xbc>
 90c89ac:	e0fffa17 	ldw	r3,-24(fp)
 90c89b0:	e0bffc17 	ldw	r2,-16(fp)
 90c89b4:	18800326 	beq	r3,r2,90c89c4 <vfgets+0xc8>
 90c89b8:	e0bffc17 	ldw	r2,-16(fp)
 90c89bc:	e0bfff15 	stw	r2,-4(fp)
 90c89c0:	00000106 	br	90c89c8 <vfgets+0xcc>
 90c89c4:	e03fff15 	stw	zero,-4(fp)
 90c89c8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c89cc:	e037883a 	mov	sp,fp
 90c89d0:	dfc00117 	ldw	ra,4(sp)
 90c89d4:	df000017 	ldw	fp,0(sp)
 90c89d8:	dec00204 	addi	sp,sp,8
 90c89dc:	f800283a 	ret

090c89e0 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 90c89e0:	defffb04 	addi	sp,sp,-20
 90c89e4:	dfc00415 	stw	ra,16(sp)
 90c89e8:	df000315 	stw	fp,12(sp)
 90c89ec:	df000304 	addi	fp,sp,12
 90c89f0:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 90c89f4:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 90c89f8:	e13ffe17 	ldw	r4,-8(fp)
 90c89fc:	90c96780 	call	90c9678 <vgetc>
 90c8a00:	e0bffd15 	stw	r2,-12(fp)
 90c8a04:	e0bffd17 	ldw	r2,-12(fp)
 90c8a08:	10bfffd8 	cmpnei	r2,r2,-1
 90c8a0c:	1000031e 	bne	r2,zero,90c8a1c <vfeof+0x3c>
   {
      return 1;
 90c8a10:	00800044 	movi	r2,1
 90c8a14:	e0bfff15 	stw	r2,-4(fp)
 90c8a18:	00000106 	br	90c8a20 <vfeof+0x40>
   }   
   return 0;
 90c8a1c:	e03fff15 	stw	zero,-4(fp)
 90c8a20:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8a24:	e037883a 	mov	sp,fp
 90c8a28:	dfc00117 	ldw	ra,4(sp)
 90c8a2c:	df000017 	ldw	fp,0(sp)
 90c8a30:	dec00204 	addi	sp,sp,8
 90c8a34:	f800283a 	ret

090c8a38 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 90c8a38:	defffd04 	addi	sp,sp,-12
 90c8a3c:	df000215 	stw	fp,8(sp)
 90c8a40:	df000204 	addi	fp,sp,8
 90c8a44:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c8a48:	d0a0d617 	ldw	r2,-31912(gp)
 90c8a4c:	e0bffe15 	stw	r2,-8(fp)
 90c8a50:	00000906 	br	90c8a78 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 90c8a54:	e0bffe17 	ldw	r2,-8(fp)
 90c8a58:	10c00117 	ldw	r3,4(r2)
 90c8a5c:	e0bfff17 	ldw	r2,-4(fp)
 90c8a60:	1880021e 	bne	r3,r2,90c8a6c <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 90c8a64:	e0bffe17 	ldw	r2,-8(fp)
 90c8a68:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c8a6c:	e0bffe17 	ldw	r2,-8(fp)
 90c8a70:	10800017 	ldw	r2,0(r2)
 90c8a74:	e0bffe15 	stw	r2,-8(fp)
 90c8a78:	e0bffe17 	ldw	r2,-8(fp)
 90c8a7c:	1004c03a 	cmpne	r2,r2,zero
 90c8a80:	103ff41e 	bne	r2,zero,90c8a54 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 90c8a84:	e037883a 	mov	sp,fp
 90c8a88:	df000017 	ldw	fp,0(sp)
 90c8a8c:	dec00104 	addi	sp,sp,4
 90c8a90:	f800283a 	ret

090c8a94 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 90c8a94:	defff504 	addi	sp,sp,-44
 90c8a98:	dfc00a15 	stw	ra,40(sp)
 90c8a9c:	df000915 	stw	fp,36(sp)
 90c8aa0:	df000904 	addi	fp,sp,36
 90c8aa4:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 90c8aa8:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 90c8aac:	e13ffe17 	ldw	r4,-8(fp)
 90c8ab0:	9083f540 	call	9083f54 <strlen>
 90c8ab4:	11000044 	addi	r4,r2,1
 90c8ab8:	90cb4400 	call	90cb440 <malloc>
 90c8abc:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 90c8ac0:	e13ff817 	ldw	r4,-32(fp)
 90c8ac4:	e17ffe17 	ldw	r5,-8(fp)
 90c8ac8:	90cb4c80 	call	90cb4c8 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c8acc:	01000144 	movi	r4,5
 90c8ad0:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 90c8ad4:	e13ff817 	ldw	r4,-32(fp)
 90c8ad8:	90c96c00 	call	90c96c0 <vfslookup_locked>
 90c8adc:	e0bffd15 	stw	r2,-12(fp)
 90c8ae0:	e0bffd17 	ldw	r2,-12(fp)
 90c8ae4:	1004c03a 	cmpne	r2,r2,zero
 90c8ae8:	1000071e 	bne	r2,zero,90c8b08 <vunlink+0x74>
   {
      vfs_unlock();
 90c8aec:	01000144 	movi	r4,5
 90c8af0:	90aab680 	call	90aab68 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 90c8af4:	e13ff817 	ldw	r4,-32(fp)
 90c8af8:	90cb42c0 	call	90cb42c <free>
      return -1;
 90c8afc:	00bfffc4 	movi	r2,-1
 90c8b00:	e0bfff15 	stw	r2,-4(fp)
 90c8b04:	00006506 	br	90c8c9c <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 90c8b08:	e0bffd17 	ldw	r2,-12(fp)
 90c8b0c:	10800017 	ldw	r2,0(r2)
 90c8b10:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 90c8b14:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 90c8b18:	d0a0d717 	ldw	r2,-31908(gp)
 90c8b1c:	e0bffb15 	stw	r2,-20(fp)
 90c8b20:	00000806 	br	90c8b44 <vunlink+0xb0>
   {
      if (vtmp == vfp)
 90c8b24:	e0fffb17 	ldw	r3,-20(fp)
 90c8b28:	e0bffd17 	ldw	r2,-12(fp)
 90c8b2c:	18800826 	beq	r3,r2,90c8b50 <vunlink+0xbc>
         break;
      vflast = vtmp;
 90c8b30:	e0bffb17 	ldw	r2,-20(fp)
 90c8b34:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 90c8b38:	e0bffb17 	ldw	r2,-20(fp)
 90c8b3c:	10800017 	ldw	r2,0(r2)
 90c8b40:	e0bffb15 	stw	r2,-20(fp)
 90c8b44:	e0bffb17 	ldw	r2,-20(fp)
 90c8b48:	1004c03a 	cmpne	r2,r2,zero
 90c8b4c:	103ff51e 	bne	r2,zero,90c8b24 <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 90c8b50:	e0bffb17 	ldw	r2,-20(fp)
 90c8b54:	1004c03a 	cmpne	r2,r2,zero
 90c8b58:	1000081e 	bne	r2,zero,90c8b7c <vunlink+0xe8>
   {
      dtrap();
 90c8b5c:	90aa4780 	call	90aa478 <dtrap>
      vfs_unlock();
 90c8b60:	01000144 	movi	r4,5
 90c8b64:	90aab680 	call	90aab68 <post_app_sem>
      free(name);
 90c8b68:	e13ff817 	ldw	r4,-32(fp)
 90c8b6c:	90cb42c0 	call	90cb42c <free>
      return -1;
 90c8b70:	00bfffc4 	movi	r2,-1
 90c8b74:	e0bfff15 	stw	r2,-4(fp)
 90c8b78:	00004806 	br	90c8c9c <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 90c8b7c:	e0bffd17 	ldw	r2,-12(fp)
 90c8b80:	10800a17 	ldw	r2,40(r2)
 90c8b84:	1005003a 	cmpeq	r2,r2,zero
 90c8b88:	1000091e 	bne	r2,zero,90c8bb0 <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 90c8b8c:	e0bffd17 	ldw	r2,-12(fp)
 90c8b90:	10800a17 	ldw	r2,40(r2)
 90c8b94:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 90c8b98:	e0bff717 	ldw	r2,-36(fp)
 90c8b9c:	10800817 	ldw	r2,32(r2)
 90c8ba0:	e13ff817 	ldw	r4,-32(fp)
 90c8ba4:	103ee83a 	callr	r2
 90c8ba8:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 90c8bac:	00002806 	br	90c8c50 <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 90c8bb0:	e0bffd17 	ldw	r2,-12(fp)
 90c8bb4:	1080058b 	ldhu	r2,22(r2)
 90c8bb8:	10bfffcc 	andi	r2,r2,65535
 90c8bbc:	1080080c 	andi	r2,r2,32
 90c8bc0:	1004c03a 	cmpne	r2,r2,zero
 90c8bc4:	1000071e 	bne	r2,zero,90c8be4 <vunlink+0x150>
      {
         vfs_unlock();
 90c8bc8:	01000144 	movi	r4,5
 90c8bcc:	90aab680 	call	90aab68 <post_app_sem>
         free(name);
 90c8bd0:	e13ff817 	ldw	r4,-32(fp)
 90c8bd4:	90cb42c0 	call	90cb42c <free>
         return -1;
 90c8bd8:	00bfffc4 	movi	r2,-1
 90c8bdc:	e0bfff15 	stw	r2,-4(fp)
 90c8be0:	00002e06 	br	90c8c9c <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 90c8be4:	e0bffd17 	ldw	r2,-12(fp)
 90c8be8:	1080058b 	ldhu	r2,22(r2)
 90c8bec:	10bfffcc 	andi	r2,r2,65535
 90c8bf0:	1080200c 	andi	r2,r2,128
 90c8bf4:	1005003a 	cmpeq	r2,r2,zero
 90c8bf8:	1000091e 	bne	r2,zero,90c8c20 <vunlink+0x18c>
 90c8bfc:	e0bffd17 	ldw	r2,-12(fp)
 90c8c00:	10800617 	ldw	r2,24(r2)
 90c8c04:	1005003a 	cmpeq	r2,r2,zero
 90c8c08:	1000051e 	bne	r2,zero,90c8c20 <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 90c8c0c:	e0bffd17 	ldw	r2,-12(fp)
 90c8c10:	11000617 	ldw	r4,24(r2)
 90c8c14:	e0bffd17 	ldw	r2,-12(fp)
 90c8c18:	11400917 	ldw	r5,36(r2)
 90c8c1c:	90c82c40 	call	90c82c4 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 90c8c20:	e0bffd17 	ldw	r2,-12(fp)
 90c8c24:	1080058b 	ldhu	r2,22(r2)
 90c8c28:	10bfffcc 	andi	r2,r2,65535
 90c8c2c:	1080100c 	andi	r2,r2,64
 90c8c30:	1005003a 	cmpeq	r2,r2,zero
 90c8c34:	1000051e 	bne	r2,zero,90c8c4c <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 90c8c38:	d0a0dc17 	ldw	r2,-31888(gp)
 90c8c3c:	10bfffc4 	addi	r2,r2,-1
 90c8c40:	d0a0dc15 	stw	r2,-31888(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 90c8c44:	e13ffd17 	ldw	r4,-12(fp)
 90c8c48:	90aaff00 	call	90aaff0 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 90c8c4c:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 90c8c50:	e0bffa17 	ldw	r2,-24(fp)
 90c8c54:	1005003a 	cmpeq	r2,r2,zero
 90c8c58:	1000041e 	bne	r2,zero,90c8c6c <vunlink+0x1d8>
      vflast->next = vfnext;
 90c8c5c:	e0fffa17 	ldw	r3,-24(fp)
 90c8c60:	e0bff917 	ldw	r2,-28(fp)
 90c8c64:	18800015 	stw	r2,0(r3)
 90c8c68:	00000206 	br	90c8c74 <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 90c8c6c:	e0bff917 	ldw	r2,-28(fp)
 90c8c70:	d0a0d715 	stw	r2,-31908(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 90c8c74:	e13ffd17 	ldw	r4,-12(fp)
 90c8c78:	90c8a380 	call	90c8a38 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 90c8c7c:	00800044 	movi	r2,1
 90c8c80:	d0a0d915 	stw	r2,-31900(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 90c8c84:	01000144 	movi	r4,5
 90c8c88:	90aab680 	call	90aab68 <post_app_sem>
   free(name);
 90c8c8c:	e13ff817 	ldw	r4,-32(fp)
 90c8c90:	90cb42c0 	call	90cb42c <free>
   return rc;
 90c8c94:	e0bffc17 	ldw	r2,-16(fp)
 90c8c98:	e0bfff15 	stw	r2,-4(fp)
 90c8c9c:	e0bfff17 	ldw	r2,-4(fp)
}
 90c8ca0:	e037883a 	mov	sp,fp
 90c8ca4:	dfc00117 	ldw	ra,4(sp)
 90c8ca8:	df000017 	ldw	fp,0(sp)
 90c8cac:	dec00204 	addi	sp,sp,8
 90c8cb0:	f800283a 	ret

090c8cb4 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c8cb4:	defff504 	addi	sp,sp,-44
 90c8cb8:	dfc00a15 	stw	ra,40(sp)
 90c8cbc:	df000915 	stw	fp,36(sp)
 90c8cc0:	df000904 	addi	fp,sp,36
 90c8cc4:	e13ffb15 	stw	r4,-20(fp)
 90c8cc8:	e17ffc15 	stw	r5,-16(fp)
 90c8ccc:	e1bffd15 	stw	r6,-12(fp)
 90c8cd0:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 90c8cd4:	01000144 	movi	r4,5
 90c8cd8:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 90c8cdc:	e13ffe17 	ldw	r4,-8(fp)
 90c8ce0:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c8ce4:	1005003a 	cmpeq	r2,r2,zero
 90c8ce8:	1000541e 	bne	r2,zero,90c8e3c <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 90c8cec:	e0bffe17 	ldw	r2,-8(fp)
 90c8cf0:	10800117 	ldw	r2,4(r2)
 90c8cf4:	1004c03a 	cmpne	r2,r2,zero
 90c8cf8:	1000041e 	bne	r2,zero,90c8d0c <vfread+0x58>
      {
         vfs_unlock();
 90c8cfc:	01000144 	movi	r4,5
 90c8d00:	90aab680 	call	90aab68 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 90c8d04:	e03fff15 	stw	zero,-4(fp)
 90c8d08:	00004f06 	br	90c8e48 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 90c8d0c:	e0bffe17 	ldw	r2,-8(fp)
 90c8d10:	10800117 	ldw	r2,4(r2)
 90c8d14:	10800a17 	ldw	r2,40(r2)
 90c8d18:	1005003a 	cmpeq	r2,r2,zero
 90c8d1c:	1000111e 	bne	r2,zero,90c8d64 <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 90c8d20:	e0bffe17 	ldw	r2,-8(fp)
 90c8d24:	10800117 	ldw	r2,4(r2)
 90c8d28:	10800a17 	ldw	r2,40(r2)
 90c8d2c:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 90c8d30:	e0bff917 	ldw	r2,-28(fp)
 90c8d34:	10800317 	ldw	r2,12(r2)
 90c8d38:	e13ffb17 	ldw	r4,-20(fp)
 90c8d3c:	e17ffc17 	ldw	r5,-16(fp)
 90c8d40:	e1bffd17 	ldw	r6,-12(fp)
 90c8d44:	e1fffe17 	ldw	r7,-8(fp)
 90c8d48:	103ee83a 	callr	r2
 90c8d4c:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 90c8d50:	01000144 	movi	r4,5
 90c8d54:	90aab680 	call	90aab68 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 90c8d58:	e0bff817 	ldw	r2,-32(fp)
 90c8d5c:	e0bfff15 	stw	r2,-4(fp)
 90c8d60:	00003906 	br	90c8e48 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 90c8d64:	e0bffe17 	ldw	r2,-8(fp)
 90c8d68:	10800117 	ldw	r2,4(r2)
 90c8d6c:	10800617 	ldw	r2,24(r2)
 90c8d70:	1004c03a 	cmpne	r2,r2,zero
 90c8d74:	1000041e 	bne	r2,zero,90c8d88 <vfread+0xd4>
      {
         vfs_unlock();
 90c8d78:	01000144 	movi	r4,5
 90c8d7c:	90aab680 	call	90aab68 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 90c8d80:	e03fff15 	stw	zero,-4(fp)
 90c8d84:	00003006 	br	90c8e48 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 90c8d88:	e0fffd17 	ldw	r3,-12(fp)
 90c8d8c:	e0bffc17 	ldw	r2,-16(fp)
 90c8d90:	1885383a 	mul	r2,r3,r2
 90c8d94:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 90c8d98:	e0bffe17 	ldw	r2,-8(fp)
 90c8d9c:	10800217 	ldw	r2,8(r2)
 90c8da0:	1007883a 	mov	r3,r2
 90c8da4:	e0bffe17 	ldw	r2,-8(fp)
 90c8da8:	10800117 	ldw	r2,4(r2)
 90c8dac:	10800617 	ldw	r2,24(r2)
 90c8db0:	1885c83a 	sub	r2,r3,r2
 90c8db4:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 90c8db8:	e0fff717 	ldw	r3,-36(fp)
 90c8dbc:	e0bffa17 	ldw	r2,-24(fp)
 90c8dc0:	1887883a 	add	r3,r3,r2
 90c8dc4:	e0bffe17 	ldw	r2,-8(fp)
 90c8dc8:	10800117 	ldw	r2,4(r2)
 90c8dcc:	10800817 	ldw	r2,32(r2)
 90c8dd0:	10c0062e 	bgeu	r2,r3,90c8dec <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 90c8dd4:	e0bffe17 	ldw	r2,-8(fp)
 90c8dd8:	10800117 	ldw	r2,4(r2)
 90c8ddc:	10c00817 	ldw	r3,32(r2)
 90c8de0:	e0bff717 	ldw	r2,-36(fp)
 90c8de4:	1885c83a 	sub	r2,r3,r2
 90c8de8:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 90c8dec:	e0bffe17 	ldw	r2,-8(fp)
 90c8df0:	10c00217 	ldw	r3,8(r2)
 90c8df4:	e0bffb17 	ldw	r2,-20(fp)
 90c8df8:	1009883a 	mov	r4,r2
 90c8dfc:	180b883a 	mov	r5,r3
 90c8e00:	e1bffa17 	ldw	r6,-24(fp)
 90c8e04:	90894600 	call	9089460 <memcpy>
         vfd->cmploc += bcount;
 90c8e08:	e0bffe17 	ldw	r2,-8(fp)
 90c8e0c:	10c00217 	ldw	r3,8(r2)
 90c8e10:	e0bffa17 	ldw	r2,-24(fp)
 90c8e14:	1887883a 	add	r3,r3,r2
 90c8e18:	e0bffe17 	ldw	r2,-8(fp)
 90c8e1c:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 90c8e20:	01000144 	movi	r4,5
 90c8e24:	90aab680 	call	90aab68 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 90c8e28:	e0fffa17 	ldw	r3,-24(fp)
 90c8e2c:	e0bffc17 	ldw	r2,-16(fp)
 90c8e30:	1885203a 	divu	r2,r3,r2
 90c8e34:	e0bfff15 	stw	r2,-4(fp)
 90c8e38:	00000306 	br	90c8e48 <vfread+0x194>
   }

   vfs_unlock();
 90c8e3c:	01000144 	movi	r4,5
 90c8e40:	90aab680 	call	90aab68 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 90c8e44:	e03fff15 	stw	zero,-4(fp)
 90c8e48:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c8e4c:	e037883a 	mov	sp,fp
 90c8e50:	dfc00117 	ldw	ra,4(sp)
 90c8e54:	df000017 	ldw	fp,0(sp)
 90c8e58:	dec00204 	addi	sp,sp,8
 90c8e5c:	f800283a 	ret

090c8e60 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c8e60:	defff104 	addi	sp,sp,-60
 90c8e64:	dfc00e15 	stw	ra,56(sp)
 90c8e68:	df000d15 	stw	fp,52(sp)
 90c8e6c:	df000d04 	addi	fp,sp,52
 90c8e70:	e13ffb15 	stw	r4,-20(fp)
 90c8e74:	e17ffc15 	stw	r5,-16(fp)
 90c8e78:	e1bffd15 	stw	r6,-12(fp)
 90c8e7c:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 90c8e80:	e13ffe17 	ldw	r4,-8(fp)
 90c8e84:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c8e88:	1004c03a 	cmpne	r2,r2,zero
 90c8e8c:	1000031e 	bne	r2,zero,90c8e9c <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 90c8e90:	00800244 	movi	r2,9
 90c8e94:	e0bfff15 	stw	r2,-4(fp)
 90c8e98:	0000e506 	br	90c9230 <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 90c8e9c:	e0bffe17 	ldw	r2,-8(fp)
 90c8ea0:	10800117 	ldw	r2,4(r2)
 90c8ea4:	10800a17 	ldw	r2,40(r2)
 90c8ea8:	1005003a 	cmpeq	r2,r2,zero
 90c8eac:	10000f1e 	bne	r2,zero,90c8eec <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 90c8eb0:	e0bffe17 	ldw	r2,-8(fp)
 90c8eb4:	10800117 	ldw	r2,4(r2)
 90c8eb8:	10800a17 	ldw	r2,40(r2)
 90c8ebc:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 90c8ec0:	e0bff717 	ldw	r2,-36(fp)
 90c8ec4:	10800417 	ldw	r2,16(r2)
 90c8ec8:	e13ffb17 	ldw	r4,-20(fp)
 90c8ecc:	e17ffc17 	ldw	r5,-16(fp)
 90c8ed0:	e1bffd17 	ldw	r6,-12(fp)
 90c8ed4:	e1fffe17 	ldw	r7,-8(fp)
 90c8ed8:	103ee83a 	callr	r2
 90c8edc:	e0bff615 	stw	r2,-40(fp)
      return rc;
 90c8ee0:	e0bff617 	ldw	r2,-40(fp)
 90c8ee4:	e0bfff15 	stw	r2,-4(fp)
 90c8ee8:	0000d106 	br	90c9230 <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 90c8eec:	e0bffe17 	ldw	r2,-8(fp)
 90c8ef0:	10800117 	ldw	r2,4(r2)
 90c8ef4:	1004c03a 	cmpne	r2,r2,zero
 90c8ef8:	1000021e 	bne	r2,zero,90c8f04 <vfwrite_locked+0xa4>
   {
      return 0;
 90c8efc:	e03fff15 	stw	zero,-4(fp)
 90c8f00:	0000cb06 	br	90c9230 <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 90c8f04:	e0bffe17 	ldw	r2,-8(fp)
 90c8f08:	10800117 	ldw	r2,4(r2)
 90c8f0c:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 90c8f10:	e0bff817 	ldw	r2,-32(fp)
 90c8f14:	1080058b 	ldhu	r2,22(r2)
 90c8f18:	10bfffcc 	andi	r2,r2,65535
 90c8f1c:	1080080c 	andi	r2,r2,32
 90c8f20:	1004c03a 	cmpne	r2,r2,zero
 90c8f24:	1000051e 	bne	r2,zero,90c8f3c <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 90c8f28:	e0fffe17 	ldw	r3,-8(fp)
 90c8f2c:	00bff984 	movi	r2,-26
 90c8f30:	18800415 	stw	r2,16(r3)
      return 0;
 90c8f34:	e03fff15 	stw	zero,-4(fp)
 90c8f38:	0000bd06 	br	90c9230 <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 90c8f3c:	e0fffc17 	ldw	r3,-16(fp)
 90c8f40:	e0bffd17 	ldw	r2,-12(fp)
 90c8f44:	1885383a 	mul	r2,r3,r2
 90c8f48:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 90c8f4c:	e0bffa17 	ldw	r2,-24(fp)
 90c8f50:	1004c03a 	cmpne	r2,r2,zero
 90c8f54:	1000021e 	bne	r2,zero,90c8f60 <vfwrite_locked+0x100>
   {
      return 0;
 90c8f58:	e03fff15 	stw	zero,-4(fp)
 90c8f5c:	0000b406 	br	90c9230 <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 90c8f60:	e0bff817 	ldw	r2,-32(fp)
 90c8f64:	10800617 	ldw	r2,24(r2)
 90c8f68:	1004c03a 	cmpne	r2,r2,zero
 90c8f6c:	1000401e 	bne	r2,zero,90c9070 <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 90c8f70:	e0bffa17 	ldw	r2,-24(fp)
 90c8f74:	10bfffc4 	addi	r2,r2,-1
 90c8f78:	1004d37a 	srli	r2,r2,13
 90c8f7c:	1004937a 	slli	r2,r2,13
 90c8f80:	10880004 	addi	r2,r2,8192
 90c8f84:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 90c8f88:	e13ff517 	ldw	r4,-44(fp)
 90c8f8c:	90c81ec0 	call	90c81ec <vf_alloc_buffer>
 90c8f90:	1007883a 	mov	r3,r2
 90c8f94:	e0bff817 	ldw	r2,-32(fp)
 90c8f98:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 90c8f9c:	e0bff817 	ldw	r2,-32(fp)
 90c8fa0:	10800617 	ldw	r2,24(r2)
 90c8fa4:	1004c03a 	cmpne	r2,r2,zero
 90c8fa8:	1000051e 	bne	r2,zero,90c8fc0 <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 90c8fac:	e0fffe17 	ldw	r3,-8(fp)
 90c8fb0:	00bffb04 	movi	r2,-20
 90c8fb4:	18800415 	stw	r2,16(r3)
         return 0;
 90c8fb8:	e03fff15 	stw	zero,-4(fp)
 90c8fbc:	00009c06 	br	90c9230 <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 90c8fc0:	e0fff817 	ldw	r3,-32(fp)
 90c8fc4:	e0bff517 	ldw	r2,-44(fp)
 90c8fc8:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 90c8fcc:	e0fff817 	ldw	r3,-32(fp)
 90c8fd0:	e0bffa17 	ldw	r2,-24(fp)
 90c8fd4:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 90c8fd8:	e0fff817 	ldw	r3,-32(fp)
 90c8fdc:	e0bffa17 	ldw	r2,-24(fp)
 90c8fe0:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 90c8fe4:	e0bff817 	ldw	r2,-32(fp)
 90c8fe8:	10c00617 	ldw	r3,24(r2)
 90c8fec:	e0bffa17 	ldw	r2,-24(fp)
 90c8ff0:	1887883a 	add	r3,r3,r2
 90c8ff4:	e0bffe17 	ldw	r2,-8(fp)
 90c8ff8:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c8ffc:	e0bff817 	ldw	r2,-32(fp)
 90c9000:	10c0058b 	ldhu	r3,22(r2)
 90c9004:	00bfff84 	movi	r2,-2
 90c9008:	1884703a 	and	r2,r3,r2
 90c900c:	1007883a 	mov	r3,r2
 90c9010:	e0bff817 	ldw	r2,-32(fp)
 90c9014:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 90c9018:	e0bff817 	ldw	r2,-32(fp)
 90c901c:	1080058b 	ldhu	r2,22(r2)
 90c9020:	10808014 	ori	r2,r2,512
 90c9024:	1007883a 	mov	r3,r2
 90c9028:	e0bff817 	ldw	r2,-32(fp)
 90c902c:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 90c9030:	e0bff817 	ldw	r2,-32(fp)
 90c9034:	1080058b 	ldhu	r2,22(r2)
 90c9038:	10802014 	ori	r2,r2,128
 90c903c:	1007883a 	mov	r3,r2
 90c9040:	e0bff817 	ldw	r2,-32(fp)
 90c9044:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 90c9048:	e0bff817 	ldw	r2,-32(fp)
 90c904c:	10800617 	ldw	r2,24(r2)
 90c9050:	e0fffb17 	ldw	r3,-20(fp)
 90c9054:	1009883a 	mov	r4,r2
 90c9058:	180b883a 	mov	r5,r3
 90c905c:	e1bffa17 	ldw	r6,-24(fp)
 90c9060:	90894600 	call	9089460 <memcpy>

      /* return the number of "items" written */
      return items;
 90c9064:	e0bffd17 	ldw	r2,-12(fp)
 90c9068:	e0bfff15 	stw	r2,-4(fp)
 90c906c:	00007006 	br	90c9230 <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 90c9070:	e0bffe17 	ldw	r2,-8(fp)
 90c9074:	10800217 	ldw	r2,8(r2)
 90c9078:	1007883a 	mov	r3,r2
 90c907c:	e0bff817 	ldw	r2,-32(fp)
 90c9080:	10800617 	ldw	r2,24(r2)
 90c9084:	1885c83a 	sub	r2,r3,r2
 90c9088:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 90c908c:	e0fff917 	ldw	r3,-28(fp)
 90c9090:	e0bffa17 	ldw	r2,-24(fp)
 90c9094:	1887883a 	add	r3,r3,r2
 90c9098:	e0bff817 	ldw	r2,-32(fp)
 90c909c:	10800917 	ldw	r2,36(r2)
 90c90a0:	10c0382e 	bgeu	r2,r3,90c9184 <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 90c90a4:	e0fff917 	ldw	r3,-28(fp)
 90c90a8:	e0bffa17 	ldw	r2,-24(fp)
 90c90ac:	1885883a 	add	r2,r3,r2
 90c90b0:	10bfffc4 	addi	r2,r2,-1
 90c90b4:	1004d37a 	srli	r2,r2,13
 90c90b8:	1004937a 	slli	r2,r2,13
 90c90bc:	10880004 	addi	r2,r2,8192
 90c90c0:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 90c90c4:	e13ff417 	ldw	r4,-48(fp)
 90c90c8:	90c81ec0 	call	90c81ec <vf_alloc_buffer>
 90c90cc:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 90c90d0:	e0bff317 	ldw	r2,-52(fp)
 90c90d4:	1004c03a 	cmpne	r2,r2,zero
 90c90d8:	1000051e 	bne	r2,zero,90c90f0 <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 90c90dc:	e0fffe17 	ldw	r3,-8(fp)
 90c90e0:	00bffb04 	movi	r2,-20
 90c90e4:	18800415 	stw	r2,16(r3)
         return 0;
 90c90e8:	e03fff15 	stw	zero,-4(fp)
 90c90ec:	00005006 	br	90c9230 <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 90c90f0:	e0bff817 	ldw	r2,-32(fp)
 90c90f4:	10c00617 	ldw	r3,24(r2)
 90c90f8:	e0bff817 	ldw	r2,-32(fp)
 90c90fc:	11800817 	ldw	r6,32(r2)
 90c9100:	e0bff317 	ldw	r2,-52(fp)
 90c9104:	1009883a 	mov	r4,r2
 90c9108:	180b883a 	mov	r5,r3
 90c910c:	90894600 	call	9089460 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 90c9110:	e0bff817 	ldw	r2,-32(fp)
 90c9114:	1080058b 	ldhu	r2,22(r2)
 90c9118:	10bfffcc 	andi	r2,r2,65535
 90c911c:	1080200c 	andi	r2,r2,128
 90c9120:	1005003a 	cmpeq	r2,r2,zero
 90c9124:	1000051e 	bne	r2,zero,90c913c <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 90c9128:	e0bff817 	ldw	r2,-32(fp)
 90c912c:	11000617 	ldw	r4,24(r2)
 90c9130:	e0bff817 	ldw	r2,-32(fp)
 90c9134:	11400917 	ldw	r5,36(r2)
 90c9138:	90c82c40 	call	90c82c4 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 90c913c:	e0fff817 	ldw	r3,-32(fp)
 90c9140:	e0bff317 	ldw	r2,-52(fp)
 90c9144:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 90c9148:	e0fff817 	ldw	r3,-32(fp)
 90c914c:	e0bff417 	ldw	r2,-48(fp)
 90c9150:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 90c9154:	e0bff817 	ldw	r2,-32(fp)
 90c9158:	1080058b 	ldhu	r2,22(r2)
 90c915c:	10802014 	ori	r2,r2,128
 90c9160:	1007883a 	mov	r3,r2
 90c9164:	e0bff817 	ldw	r2,-32(fp)
 90c9168:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 90c916c:	e0bff817 	ldw	r2,-32(fp)
 90c9170:	10c00617 	ldw	r3,24(r2)
 90c9174:	e0bff917 	ldw	r2,-28(fp)
 90c9178:	1887883a 	add	r3,r3,r2
 90c917c:	e0bffe17 	ldw	r2,-8(fp)
 90c9180:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 90c9184:	e0bffe17 	ldw	r2,-8(fp)
 90c9188:	10800217 	ldw	r2,8(r2)
 90c918c:	e0fffb17 	ldw	r3,-20(fp)
 90c9190:	1009883a 	mov	r4,r2
 90c9194:	180b883a 	mov	r5,r3
 90c9198:	e1bffa17 	ldw	r6,-24(fp)
 90c919c:	90894600 	call	9089460 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 90c91a0:	e0bffe17 	ldw	r2,-8(fp)
 90c91a4:	10c00217 	ldw	r3,8(r2)
 90c91a8:	e0bffa17 	ldw	r2,-24(fp)
 90c91ac:	1887883a 	add	r3,r3,r2
 90c91b0:	e0bffe17 	ldw	r2,-8(fp)
 90c91b4:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 90c91b8:	e0fff917 	ldw	r3,-28(fp)
 90c91bc:	e0bffa17 	ldw	r2,-24(fp)
 90c91c0:	1887883a 	add	r3,r3,r2
 90c91c4:	e0bff817 	ldw	r2,-32(fp)
 90c91c8:	10800817 	ldw	r2,32(r2)
 90c91cc:	10c0052e 	bgeu	r2,r3,90c91e4 <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 90c91d0:	e0fff917 	ldw	r3,-28(fp)
 90c91d4:	e0bffa17 	ldw	r2,-24(fp)
 90c91d8:	1887883a 	add	r3,r3,r2
 90c91dc:	e0bff817 	ldw	r2,-32(fp)
 90c91e0:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 90c91e4:	e0bff817 	ldw	r2,-32(fp)
 90c91e8:	10c00817 	ldw	r3,32(r2)
 90c91ec:	e0bff817 	ldw	r2,-32(fp)
 90c91f0:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 90c91f4:	e0bff817 	ldw	r2,-32(fp)
 90c91f8:	10c0058b 	ldhu	r3,22(r2)
 90c91fc:	00bfff84 	movi	r2,-2
 90c9200:	1884703a 	and	r2,r3,r2
 90c9204:	1007883a 	mov	r3,r2
 90c9208:	e0bff817 	ldw	r2,-32(fp)
 90c920c:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 90c9210:	e0bff817 	ldw	r2,-32(fp)
 90c9214:	1080058b 	ldhu	r2,22(r2)
 90c9218:	10808014 	ori	r2,r2,512
 90c921c:	1007883a 	mov	r3,r2
 90c9220:	e0bff817 	ldw	r2,-32(fp)
 90c9224:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 90c9228:	e0bffd17 	ldw	r2,-12(fp)
 90c922c:	e0bfff15 	stw	r2,-4(fp)
 90c9230:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 90c9234:	e037883a 	mov	sp,fp
 90c9238:	dfc00117 	ldw	ra,4(sp)
 90c923c:	df000017 	ldw	fp,0(sp)
 90c9240:	dec00204 	addi	sp,sp,8
 90c9244:	f800283a 	ret

090c9248 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 90c9248:	defff904 	addi	sp,sp,-28
 90c924c:	dfc00615 	stw	ra,24(sp)
 90c9250:	df000515 	stw	fp,20(sp)
 90c9254:	df000504 	addi	fp,sp,20
 90c9258:	e13ffc15 	stw	r4,-16(fp)
 90c925c:	e17ffd15 	stw	r5,-12(fp)
 90c9260:	e1bffe15 	stw	r6,-8(fp)
 90c9264:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 90c9268:	01000144 	movi	r4,5
 90c926c:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 90c9270:	e13ffc17 	ldw	r4,-16(fp)
 90c9274:	e17ffd17 	ldw	r5,-12(fp)
 90c9278:	e1bffe17 	ldw	r6,-8(fp)
 90c927c:	e1ffff17 	ldw	r7,-4(fp)
 90c9280:	90c8e600 	call	90c8e60 <vfwrite_locked>
 90c9284:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c9288:	01000144 	movi	r4,5
 90c928c:	90aab680 	call	90aab68 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 90c9290:	e0bffb17 	ldw	r2,-20(fp)
}
 90c9294:	e037883a 	mov	sp,fp
 90c9298:	dfc00117 	ldw	ra,4(sp)
 90c929c:	df000017 	ldw	fp,0(sp)
 90c92a0:	dec00204 	addi	sp,sp,8
 90c92a4:	f800283a 	ret

090c92a8 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 90c92a8:	defff704 	addi	sp,sp,-36
 90c92ac:	dfc00815 	stw	ra,32(sp)
 90c92b0:	df000715 	stw	fp,28(sp)
 90c92b4:	df000704 	addi	fp,sp,28
 90c92b8:	e13ffb15 	stw	r4,-20(fp)
 90c92bc:	e17ffc15 	stw	r5,-16(fp)
 90c92c0:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 90c92c4:	01000144 	movi	r4,5
 90c92c8:	90aaab40 	call	90aaab4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c92cc:	e13ffb17 	ldw	r4,-20(fp)
 90c92d0:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c92d4:	1005003a 	cmpeq	r2,r2,zero
 90c92d8:	1000481e 	bne	r2,zero,90c93fc <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 90c92dc:	e0bffb17 	ldw	r2,-20(fp)
 90c92e0:	10800117 	ldw	r2,4(r2)
 90c92e4:	1004c03a 	cmpne	r2,r2,zero
 90c92e8:	1000051e 	bne	r2,zero,90c9300 <vfseek+0x58>
      {
         vfs_unlock();
 90c92ec:	01000144 	movi	r4,5
 90c92f0:	90aab680 	call	90aab68 <post_app_sem>
         return -1;
 90c92f4:	00bfffc4 	movi	r2,-1
 90c92f8:	e0bffe15 	stw	r2,-8(fp)
 90c92fc:	00004306 	br	90c940c <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c9300:	e0bffb17 	ldw	r2,-20(fp)
 90c9304:	10800117 	ldw	r2,4(r2)
 90c9308:	10800a17 	ldw	r2,40(r2)
 90c930c:	1005003a 	cmpeq	r2,r2,zero
 90c9310:	1000101e 	bne	r2,zero,90c9354 <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 90c9314:	e0bffb17 	ldw	r2,-20(fp)
 90c9318:	10800117 	ldw	r2,4(r2)
 90c931c:	10800a17 	ldw	r2,40(r2)
 90c9320:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 90c9324:	e0bffa17 	ldw	r2,-24(fp)
 90c9328:	10800517 	ldw	r2,20(r2)
 90c932c:	e13ffb17 	ldw	r4,-20(fp)
 90c9330:	e17ffc17 	ldw	r5,-16(fp)
 90c9334:	e1bffd17 	ldw	r6,-12(fp)
 90c9338:	103ee83a 	callr	r2
 90c933c:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 90c9340:	01000144 	movi	r4,5
 90c9344:	90aab680 	call	90aab68 <post_app_sem>
         return rc;
 90c9348:	e0fff917 	ldw	r3,-28(fp)
 90c934c:	e0fffe15 	stw	r3,-8(fp)
 90c9350:	00002e06 	br	90c940c <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 90c9354:	e0bffd17 	ldw	r2,-12(fp)
 90c9358:	e0bfff15 	stw	r2,-4(fp)
 90c935c:	e0ffff17 	ldw	r3,-4(fp)
 90c9360:	18800060 	cmpeqi	r2,r3,1
 90c9364:	10000f1e 	bne	r2,zero,90c93a4 <vfseek+0xfc>
 90c9368:	e0ffff17 	ldw	r3,-4(fp)
 90c936c:	188000a0 	cmpeqi	r2,r3,2
 90c9370:	1000131e 	bne	r2,zero,90c93c0 <vfseek+0x118>
 90c9374:	e0ffff17 	ldw	r3,-4(fp)
 90c9378:	1805003a 	cmpeq	r2,r3,zero
 90c937c:	1000011e 	bne	r2,zero,90c9384 <vfseek+0xdc>
 90c9380:	00001a06 	br	90c93ec <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 90c9384:	e0bffb17 	ldw	r2,-20(fp)
 90c9388:	10800117 	ldw	r2,4(r2)
 90c938c:	10c00617 	ldw	r3,24(r2)
 90c9390:	e0bffc17 	ldw	r2,-16(fp)
 90c9394:	1887883a 	add	r3,r3,r2
 90c9398:	e0bffb17 	ldw	r2,-20(fp)
 90c939c:	10c00215 	stw	r3,8(r2)
         break;
 90c93a0:	00001206 	br	90c93ec <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 90c93a4:	e0bffb17 	ldw	r2,-20(fp)
 90c93a8:	10c00217 	ldw	r3,8(r2)
 90c93ac:	e0bffc17 	ldw	r2,-16(fp)
 90c93b0:	1887883a 	add	r3,r3,r2
 90c93b4:	e0bffb17 	ldw	r2,-20(fp)
 90c93b8:	10c00215 	stw	r3,8(r2)
         break;
 90c93bc:	00000b06 	br	90c93ec <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 90c93c0:	e0bffb17 	ldw	r2,-20(fp)
 90c93c4:	10800117 	ldw	r2,4(r2)
 90c93c8:	10c00617 	ldw	r3,24(r2)
 90c93cc:	e0bffb17 	ldw	r2,-20(fp)
 90c93d0:	10800117 	ldw	r2,4(r2)
 90c93d4:	10800817 	ldw	r2,32(r2)
 90c93d8:	1887883a 	add	r3,r3,r2
 90c93dc:	e0bffc17 	ldw	r2,-16(fp)
 90c93e0:	1887883a 	add	r3,r3,r2
 90c93e4:	e0bffb17 	ldw	r2,-20(fp)
 90c93e8:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 90c93ec:	01000144 	movi	r4,5
 90c93f0:	90aab680 	call	90aab68 <post_app_sem>
      return(0);
 90c93f4:	e03ffe15 	stw	zero,-8(fp)
 90c93f8:	00000406 	br	90c940c <vfseek+0x164>
   }

   vfs_unlock();
 90c93fc:	01000144 	movi	r4,5
 90c9400:	90aab680 	call	90aab68 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 90c9404:	00bfffc4 	movi	r2,-1
 90c9408:	e0bffe15 	stw	r2,-8(fp)
 90c940c:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 90c9410:	e037883a 	mov	sp,fp
 90c9414:	dfc00117 	ldw	ra,4(sp)
 90c9418:	df000017 	ldw	fp,0(sp)
 90c941c:	dec00204 	addi	sp,sp,8
 90c9420:	f800283a 	ret

090c9424 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 90c9424:	defffa04 	addi	sp,sp,-24
 90c9428:	dfc00515 	stw	ra,20(sp)
 90c942c:	df000415 	stw	fp,16(sp)
 90c9430:	df000404 	addi	fp,sp,16
 90c9434:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 90c9438:	01000144 	movi	r4,5
 90c943c:	90aaab40 	call	90aaab4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c9440:	e13ffe17 	ldw	r4,-8(fp)
 90c9444:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c9448:	1005003a 	cmpeq	r2,r2,zero
 90c944c:	1000381e 	bne	r2,zero,90c9530 <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 90c9450:	e0bffe17 	ldw	r2,-8(fp)
 90c9454:	10800117 	ldw	r2,4(r2)
 90c9458:	1004c03a 	cmpne	r2,r2,zero
 90c945c:	1000051e 	bne	r2,zero,90c9474 <vftell+0x50>
      {
         vfs_unlock();
 90c9460:	01000144 	movi	r4,5
 90c9464:	90aab680 	call	90aab68 <post_app_sem>
         return -1;
 90c9468:	00bfffc4 	movi	r2,-1
 90c946c:	e0bfff15 	stw	r2,-4(fp)
 90c9470:	00003306 	br	90c9540 <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c9474:	e0bffe17 	ldw	r2,-8(fp)
 90c9478:	10800117 	ldw	r2,4(r2)
 90c947c:	10800a17 	ldw	r2,40(r2)
 90c9480:	1005003a 	cmpeq	r2,r2,zero
 90c9484:	10000e1e 	bne	r2,zero,90c94c0 <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 90c9488:	e0bffe17 	ldw	r2,-8(fp)
 90c948c:	10800117 	ldw	r2,4(r2)
 90c9490:	10800a17 	ldw	r2,40(r2)
 90c9494:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 90c9498:	e0bffd17 	ldw	r2,-12(fp)
 90c949c:	10800617 	ldw	r2,24(r2)
 90c94a0:	e13ffe17 	ldw	r4,-8(fp)
 90c94a4:	103ee83a 	callr	r2
 90c94a8:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 90c94ac:	01000144 	movi	r4,5
 90c94b0:	90aab680 	call	90aab68 <post_app_sem>
         return rc;
 90c94b4:	e0bffc17 	ldw	r2,-16(fp)
 90c94b8:	e0bfff15 	stw	r2,-4(fp)
 90c94bc:	00002006 	br	90c9540 <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 90c94c0:	e0bffe17 	ldw	r2,-8(fp)
 90c94c4:	11000217 	ldw	r4,8(r2)
 90c94c8:	e0bffe17 	ldw	r2,-8(fp)
 90c94cc:	10800117 	ldw	r2,4(r2)
 90c94d0:	10c00617 	ldw	r3,24(r2)
 90c94d4:	e0bffe17 	ldw	r2,-8(fp)
 90c94d8:	10800117 	ldw	r2,4(r2)
 90c94dc:	10800817 	ldw	r2,32(r2)
 90c94e0:	1885883a 	add	r2,r3,r2
 90c94e4:	2080071e 	bne	r4,r2,90c9504 <vftell+0xe0>
      {
         vfs_unlock();
 90c94e8:	01000144 	movi	r4,5
 90c94ec:	90aab680 	call	90aab68 <post_app_sem>

         return vfd->file->comp_size;
 90c94f0:	e0bffe17 	ldw	r2,-8(fp)
 90c94f4:	10800117 	ldw	r2,4(r2)
 90c94f8:	10800817 	ldw	r2,32(r2)
 90c94fc:	e0bfff15 	stw	r2,-4(fp)
 90c9500:	00000f06 	br	90c9540 <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 90c9504:	01000144 	movi	r4,5
 90c9508:	90aab680 	call	90aab68 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 90c950c:	e0bffe17 	ldw	r2,-8(fp)
 90c9510:	10800217 	ldw	r2,8(r2)
 90c9514:	1007883a 	mov	r3,r2
 90c9518:	e0bffe17 	ldw	r2,-8(fp)
 90c951c:	10800117 	ldw	r2,4(r2)
 90c9520:	10800617 	ldw	r2,24(r2)
 90c9524:	1887c83a 	sub	r3,r3,r2
 90c9528:	e0ffff15 	stw	r3,-4(fp)
 90c952c:	00000406 	br	90c9540 <vftell+0x11c>
      }
   }

   vfs_unlock();
 90c9530:	01000144 	movi	r4,5
 90c9534:	90aab680 	call	90aab68 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 90c9538:	00800244 	movi	r2,9
 90c953c:	e0bfff15 	stw	r2,-4(fp)
 90c9540:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c9544:	e037883a 	mov	sp,fp
 90c9548:	dfc00117 	ldw	ra,4(sp)
 90c954c:	df000017 	ldw	fp,0(sp)
 90c9550:	dec00204 	addi	sp,sp,8
 90c9554:	f800283a 	ret

090c9558 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 90c9558:	defffa04 	addi	sp,sp,-24
 90c955c:	dfc00515 	stw	ra,20(sp)
 90c9560:	df000415 	stw	fp,16(sp)
 90c9564:	df000404 	addi	fp,sp,16
 90c9568:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 90c956c:	e13ffe17 	ldw	r4,-8(fp)
 90c9570:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c9574:	1005003a 	cmpeq	r2,r2,zero
 90c9578:	1000361e 	bne	r2,zero,90c9654 <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 90c957c:	e0bffe17 	ldw	r2,-8(fp)
 90c9580:	10800117 	ldw	r2,4(r2)
 90c9584:	1004c03a 	cmpne	r2,r2,zero
 90c9588:	1000031e 	bne	r2,zero,90c9598 <vgetc_locked+0x40>
      {
         return EOF;
 90c958c:	00bfffc4 	movi	r2,-1
 90c9590:	e0bfff15 	stw	r2,-4(fp)
 90c9594:	00003206 	br	90c9660 <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 90c9598:	e0bffe17 	ldw	r2,-8(fp)
 90c959c:	10800117 	ldw	r2,4(r2)
 90c95a0:	10800a17 	ldw	r2,40(r2)
 90c95a4:	1005003a 	cmpeq	r2,r2,zero
 90c95a8:	10000a1e 	bne	r2,zero,90c95d4 <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 90c95ac:	e0bffe17 	ldw	r2,-8(fp)
 90c95b0:	10800117 	ldw	r2,4(r2)
 90c95b4:	10800a17 	ldw	r2,40(r2)
 90c95b8:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 90c95bc:	e0bffc17 	ldw	r2,-16(fp)
 90c95c0:	10800717 	ldw	r2,28(r2)
 90c95c4:	e13ffe17 	ldw	r4,-8(fp)
 90c95c8:	103ee83a 	callr	r2
 90c95cc:	e0bfff15 	stw	r2,-4(fp)
 90c95d0:	00002306 	br	90c9660 <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 90c95d4:	e0bffe17 	ldw	r2,-8(fp)
 90c95d8:	10800117 	ldw	r2,4(r2)
 90c95dc:	10800617 	ldw	r2,24(r2)
 90c95e0:	1004c03a 	cmpne	r2,r2,zero
 90c95e4:	1000031e 	bne	r2,zero,90c95f4 <vgetc_locked+0x9c>
         return EOF;
 90c95e8:	00bfffc4 	movi	r2,-1
 90c95ec:	e0bfff15 	stw	r2,-4(fp)
 90c95f0:	00001b06 	br	90c9660 <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 90c95f4:	e0bffe17 	ldw	r2,-8(fp)
 90c95f8:	11000217 	ldw	r4,8(r2)
 90c95fc:	e0bffe17 	ldw	r2,-8(fp)
 90c9600:	10800117 	ldw	r2,4(r2)
 90c9604:	10c00617 	ldw	r3,24(r2)
 90c9608:	e0bffe17 	ldw	r2,-8(fp)
 90c960c:	10800117 	ldw	r2,4(r2)
 90c9610:	10800817 	ldw	r2,32(r2)
 90c9614:	1885883a 	add	r2,r3,r2
 90c9618:	20800336 	bltu	r4,r2,90c9628 <vgetc_locked+0xd0>
            chr = EOF;
 90c961c:	00bfffc4 	movi	r2,-1
 90c9620:	e0bffd15 	stw	r2,-12(fp)
 90c9624:	00000806 	br	90c9648 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 90c9628:	e0bffe17 	ldw	r2,-8(fp)
 90c962c:	10c00217 	ldw	r3,8(r2)
 90c9630:	18800003 	ldbu	r2,0(r3)
 90c9634:	10803fcc 	andi	r2,r2,255
 90c9638:	e0bffd15 	stw	r2,-12(fp)
 90c963c:	18c00044 	addi	r3,r3,1
 90c9640:	e0bffe17 	ldw	r2,-8(fp)
 90c9644:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 90c9648:	e0bffd17 	ldw	r2,-12(fp)
 90c964c:	e0bfff15 	stw	r2,-4(fp)
 90c9650:	00000306 	br	90c9660 <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 90c9654:	90aa4780 	call	90aa478 <dtrap>
   return EOF;
 90c9658:	00bfffc4 	movi	r2,-1
 90c965c:	e0bfff15 	stw	r2,-4(fp)
 90c9660:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c9664:	e037883a 	mov	sp,fp
 90c9668:	dfc00117 	ldw	ra,4(sp)
 90c966c:	df000017 	ldw	fp,0(sp)
 90c9670:	dec00204 	addi	sp,sp,8
 90c9674:	f800283a 	ret

090c9678 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 90c9678:	defffc04 	addi	sp,sp,-16
 90c967c:	dfc00315 	stw	ra,12(sp)
 90c9680:	df000215 	stw	fp,8(sp)
 90c9684:	df000204 	addi	fp,sp,8
 90c9688:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 90c968c:	01000144 	movi	r4,5
 90c9690:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 90c9694:	e13fff17 	ldw	r4,-4(fp)
 90c9698:	90c95580 	call	90c9558 <vgetc_locked>
 90c969c:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c96a0:	01000144 	movi	r4,5
 90c96a4:	90aab680 	call	90aab68 <post_app_sem>
   return rc;
 90c96a8:	e0bffe17 	ldw	r2,-8(fp)
}
 90c96ac:	e037883a 	mov	sp,fp
 90c96b0:	dfc00117 	ldw	ra,4(sp)
 90c96b4:	df000017 	ldw	fp,0(sp)
 90c96b8:	dec00204 	addi	sp,sp,8
 90c96bc:	f800283a 	ret

090c96c0 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 90c96c0:	defffa04 	addi	sp,sp,-24
 90c96c4:	dfc00515 	stw	ra,20(sp)
 90c96c8:	df000415 	stw	fp,16(sp)
 90c96cc:	df000404 	addi	fp,sp,16
 90c96d0:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 90c96d4:	e0bffe17 	ldw	r2,-8(fp)
 90c96d8:	10800003 	ldbu	r2,0(r2)
 90c96dc:	10803fcc 	andi	r2,r2,255
 90c96e0:	1080201c 	xori	r2,r2,128
 90c96e4:	10bfe004 	addi	r2,r2,-128
 90c96e8:	10800be0 	cmpeqi	r2,r2,47
 90c96ec:	1000071e 	bne	r2,zero,90c970c <vfslookup_locked+0x4c>
 90c96f0:	e0bffe17 	ldw	r2,-8(fp)
 90c96f4:	10800003 	ldbu	r2,0(r2)
 90c96f8:	10803fcc 	andi	r2,r2,255
 90c96fc:	1080201c 	xori	r2,r2,128
 90c9700:	10bfe004 	addi	r2,r2,-128
 90c9704:	10801718 	cmpnei	r2,r2,92
 90c9708:	10001a1e 	bne	r2,zero,90c9774 <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 90c970c:	e13ffe17 	ldw	r4,-8(fp)
 90c9710:	90c98400 	call	90c9840 <strippath>
 90c9714:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 90c9718:	e0bffc17 	ldw	r2,-16(fp)
 90c971c:	1004c03a 	cmpne	r2,r2,zero
 90c9720:	1000121e 	bne	r2,zero,90c976c <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 90c9724:	e0bffe17 	ldw	r2,-8(fp)
 90c9728:	10800003 	ldbu	r2,0(r2)
 90c972c:	10803fcc 	andi	r2,r2,255
 90c9730:	1080201c 	xori	r2,r2,128
 90c9734:	10bfe004 	addi	r2,r2,-128
 90c9738:	10800be0 	cmpeqi	r2,r2,47
 90c973c:	1000071e 	bne	r2,zero,90c975c <vfslookup_locked+0x9c>
 90c9740:	e0bffe17 	ldw	r2,-8(fp)
 90c9744:	10800003 	ldbu	r2,0(r2)
 90c9748:	10803fcc 	andi	r2,r2,255
 90c974c:	1080201c 	xori	r2,r2,128
 90c9750:	10bfe004 	addi	r2,r2,-128
 90c9754:	10801718 	cmpnei	r2,r2,92
 90c9758:	1000061e 	bne	r2,zero,90c9774 <vfslookup_locked+0xb4>
            name++;
 90c975c:	e0bffe17 	ldw	r2,-8(fp)
 90c9760:	10800044 	addi	r2,r2,1
 90c9764:	e0bffe15 	stw	r2,-8(fp)
 90c9768:	00000206 	br	90c9774 <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 90c976c:	e0bffc17 	ldw	r2,-16(fp)
 90c9770:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 90c9774:	e13ffe17 	ldw	r4,-8(fp)
 90c9778:	01400fc4 	movi	r5,63
 90c977c:	90838000 	call	9083800 <strchr>
 90c9780:	1005003a 	cmpeq	r2,r2,zero
 90c9784:	1000031e 	bne	r2,zero,90c9794 <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 90c9788:	90aa4780 	call	90aa478 <dtrap>
      return NULL;
 90c978c:	e03fff15 	stw	zero,-4(fp)
 90c9790:	00001306 	br	90c97e0 <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 90c9794:	d0a0d717 	ldw	r2,-31908(gp)
 90c9798:	e0bffd15 	stw	r2,-12(fp)
 90c979c:	00000c06 	br	90c97d0 <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 90c97a0:	e0bffd17 	ldw	r2,-12(fp)
 90c97a4:	11400104 	addi	r5,r2,4
 90c97a8:	e13ffe17 	ldw	r4,-8(fp)
 90c97ac:	908afd40 	call	908afd4 <strcmp>
 90c97b0:	1004c03a 	cmpne	r2,r2,zero
 90c97b4:	1000031e 	bne	r2,zero,90c97c4 <vfslookup_locked+0x104>
         return vp;
 90c97b8:	e0bffd17 	ldw	r2,-12(fp)
 90c97bc:	e0bfff15 	stw	r2,-4(fp)
 90c97c0:	00000706 	br	90c97e0 <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 90c97c4:	e0bffd17 	ldw	r2,-12(fp)
 90c97c8:	10800017 	ldw	r2,0(r2)
 90c97cc:	e0bffd15 	stw	r2,-12(fp)
 90c97d0:	e0bffd17 	ldw	r2,-12(fp)
 90c97d4:	1004c03a 	cmpne	r2,r2,zero
 90c97d8:	103ff11e 	bne	r2,zero,90c97a0 <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 90c97dc:	e03fff15 	stw	zero,-4(fp)
 90c97e0:	e0bfff17 	ldw	r2,-4(fp)
}
 90c97e4:	e037883a 	mov	sp,fp
 90c97e8:	dfc00117 	ldw	ra,4(sp)
 90c97ec:	df000017 	ldw	fp,0(sp)
 90c97f0:	dec00204 	addi	sp,sp,8
 90c97f4:	f800283a 	ret

090c97f8 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 90c97f8:	defffc04 	addi	sp,sp,-16
 90c97fc:	dfc00315 	stw	ra,12(sp)
 90c9800:	df000215 	stw	fp,8(sp)
 90c9804:	df000204 	addi	fp,sp,8
 90c9808:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 90c980c:	01000144 	movi	r4,5
 90c9810:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 90c9814:	e13fff17 	ldw	r4,-4(fp)
 90c9818:	90c96c00 	call	90c96c0 <vfslookup_locked>
 90c981c:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c9820:	01000144 	movi	r4,5
 90c9824:	90aab680 	call	90aab68 <post_app_sem>
   return vp;
 90c9828:	e0bffe17 	ldw	r2,-8(fp)
}
 90c982c:	e037883a 	mov	sp,fp
 90c9830:	dfc00117 	ldw	ra,4(sp)
 90c9834:	df000017 	ldw	fp,0(sp)
 90c9838:	dec00204 	addi	sp,sp,8
 90c983c:	f800283a 	ret

090c9840 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 90c9840:	defff804 	addi	sp,sp,-32
 90c9844:	dfc00715 	stw	ra,28(sp)
 90c9848:	df000615 	stw	fp,24(sp)
 90c984c:	df000604 	addi	fp,sp,24
 90c9850:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 90c9854:	e13ffe17 	ldw	r4,-8(fp)
 90c9858:	90a55240 	call	90a5524 <uslash>
 90c985c:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 90c9860:	d0a05517 	ldw	r2,-32428(gp)
 90c9864:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 90c9868:	00003e06 	br	90c9964 <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 90c986c:	e0bffd17 	ldw	r2,-12(fp)
 90c9870:	10800044 	addi	r2,r2,1
 90c9874:	e0bffd15 	stw	r2,-12(fp)
 90c9878:	e0bffd17 	ldw	r2,-12(fp)
 90c987c:	10800003 	ldbu	r2,0(r2)
 90c9880:	10803fcc 	andi	r2,r2,255
 90c9884:	1080201c 	xori	r2,r2,128
 90c9888:	10bfe004 	addi	r2,r2,-128
 90c988c:	10800be0 	cmpeqi	r2,r2,47
 90c9890:	103ff61e 	bne	r2,zero,90c986c <strippath+0x2c>
         if (*path == 0)
 90c9894:	e0bffd17 	ldw	r2,-12(fp)
 90c9898:	10800003 	ldbu	r2,0(r2)
 90c989c:	10803fcc 	andi	r2,r2,255
 90c98a0:	1080201c 	xori	r2,r2,128
 90c98a4:	10bfe004 	addi	r2,r2,-128
 90c98a8:	1005003a 	cmpeq	r2,r2,zero
 90c98ac:	10003b1e 	bne	r2,zero,90c999c <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 90c98b0:	e13ffd17 	ldw	r4,-12(fp)
 90c98b4:	01400bc4 	movi	r5,47
 90c98b8:	90838000 	call	9083800 <strchr>
 90c98bc:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 90c98c0:	e0bffc17 	ldw	r2,-16(fp)
 90c98c4:	1005003a 	cmpeq	r2,r2,zero
 90c98c8:	1000051e 	bne	r2,zero,90c98e0 <strippath+0xa0>
         dirlen = ptmp - path;
 90c98cc:	e0bffc17 	ldw	r2,-16(fp)
 90c98d0:	e0fffd17 	ldw	r3,-12(fp)
 90c98d4:	10c5c83a 	sub	r2,r2,r3
 90c98d8:	e0bffa15 	stw	r2,-24(fp)
 90c98dc:	00000706 	br	90c98fc <strippath+0xbc>
      else
         dirlen = strlen(path);
 90c98e0:	e13ffd17 	ldw	r4,-12(fp)
 90c98e4:	9083f540 	call	9083f54 <strlen>
 90c98e8:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 90c98ec:	00000306 	br	90c98fc <strippath+0xbc>
 90c98f0:	e0bffb17 	ldw	r2,-20(fp)
 90c98f4:	10800044 	addi	r2,r2,1
 90c98f8:	e0bffb15 	stw	r2,-20(fp)
 90c98fc:	e0bffb17 	ldw	r2,-20(fp)
 90c9900:	10800003 	ldbu	r2,0(r2)
 90c9904:	10803fcc 	andi	r2,r2,255
 90c9908:	1080201c 	xori	r2,r2,128
 90c990c:	10bfe004 	addi	r2,r2,-128
 90c9910:	10800be0 	cmpeqi	r2,r2,47
 90c9914:	103ff61e 	bne	r2,zero,90c98f0 <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 90c9918:	e1bffa17 	ldw	r6,-24(fp)
 90c991c:	e13ffb17 	ldw	r4,-20(fp)
 90c9920:	e17ffd17 	ldw	r5,-12(fp)
 90c9924:	90cb5540 	call	90cb554 <strncmp>
 90c9928:	1004c03a 	cmpne	r2,r2,zero
 90c992c:	10000b1e 	bne	r2,zero,90c995c <strippath+0x11c>
      {
         path += dirlen;
 90c9930:	e0bffa17 	ldw	r2,-24(fp)
 90c9934:	1007883a 	mov	r3,r2
 90c9938:	e0bffd17 	ldw	r2,-12(fp)
 90c993c:	10c5883a 	add	r2,r2,r3
 90c9940:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 90c9944:	e0bffa17 	ldw	r2,-24(fp)
 90c9948:	1007883a 	mov	r3,r2
 90c994c:	e0bffb17 	ldw	r2,-20(fp)
 90c9950:	10c5883a 	add	r2,r2,r3
 90c9954:	e0bffb15 	stw	r2,-20(fp)
 90c9958:	00000206 	br	90c9964 <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 90c995c:	e03fff15 	stw	zero,-4(fp)
 90c9960:	00002b06 	br	90c9a10 <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 90c9964:	e0bffd17 	ldw	r2,-12(fp)
 90c9968:	10800003 	ldbu	r2,0(r2)
 90c996c:	10803fcc 	andi	r2,r2,255
 90c9970:	1080201c 	xori	r2,r2,128
 90c9974:	10bfe004 	addi	r2,r2,-128
 90c9978:	1005003a 	cmpeq	r2,r2,zero
 90c997c:	1000071e 	bne	r2,zero,90c999c <strippath+0x15c>
 90c9980:	e0bffb17 	ldw	r2,-20(fp)
 90c9984:	10800003 	ldbu	r2,0(r2)
 90c9988:	10803fcc 	andi	r2,r2,255
 90c998c:	1080201c 	xori	r2,r2,128
 90c9990:	10bfe004 	addi	r2,r2,-128
 90c9994:	1004c03a 	cmpne	r2,r2,zero
 90c9998:	103fb71e 	bne	r2,zero,90c9878 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 90c999c:	e0bffd17 	ldw	r2,-12(fp)
 90c99a0:	10800003 	ldbu	r2,0(r2)
 90c99a4:	10803fcc 	andi	r2,r2,255
 90c99a8:	1080201c 	xori	r2,r2,128
 90c99ac:	10bfe004 	addi	r2,r2,-128
 90c99b0:	1004c03a 	cmpne	r2,r2,zero
 90c99b4:	1000151e 	bne	r2,zero,90c9a0c <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 90c99b8:	00000306 	br	90c99c8 <strippath+0x188>
         ntmp++;
 90c99bc:	e0bffb17 	ldw	r2,-20(fp)
 90c99c0:	10800044 	addi	r2,r2,1
 90c99c4:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 90c99c8:	e0bffb17 	ldw	r2,-20(fp)
 90c99cc:	10800003 	ldbu	r2,0(r2)
 90c99d0:	10803fcc 	andi	r2,r2,255
 90c99d4:	1080201c 	xori	r2,r2,128
 90c99d8:	10bfe004 	addi	r2,r2,-128
 90c99dc:	10801720 	cmpeqi	r2,r2,92
 90c99e0:	103ff61e 	bne	r2,zero,90c99bc <strippath+0x17c>
 90c99e4:	e0bffb17 	ldw	r2,-20(fp)
 90c99e8:	10800003 	ldbu	r2,0(r2)
 90c99ec:	10803fcc 	andi	r2,r2,255
 90c99f0:	1080201c 	xori	r2,r2,128
 90c99f4:	10bfe004 	addi	r2,r2,-128
 90c99f8:	10800be0 	cmpeqi	r2,r2,47
 90c99fc:	103fef1e 	bne	r2,zero,90c99bc <strippath+0x17c>
         ntmp++;
      return ntmp;
 90c9a00:	e0bffb17 	ldw	r2,-20(fp)
 90c9a04:	e0bfff15 	stw	r2,-4(fp)
 90c9a08:	00000106 	br	90c9a10 <strippath+0x1d0>
   }
   else
      return NULL;
 90c9a0c:	e03fff15 	stw	zero,-4(fp)
 90c9a10:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9a14:	e037883a 	mov	sp,fp
 90c9a18:	dfc00117 	ldw	ra,4(sp)
 90c9a1c:	df000017 	ldw	fp,0(sp)
 90c9a20:	dec00204 	addi	sp,sp,8
 90c9a24:	f800283a 	ret

090c9a28 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 90c9a28:	defffc04 	addi	sp,sp,-16
 90c9a2c:	df000315 	stw	fp,12(sp)
 90c9a30:	df000304 	addi	fp,sp,12
 90c9a34:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c9a38:	d0a0d617 	ldw	r2,-31912(gp)
 90c9a3c:	e0bffd15 	stw	r2,-12(fp)
 90c9a40:	00000906 	br	90c9a68 <isvfile_locked+0x40>
      if (vtmp == vfp)
 90c9a44:	e0fffd17 	ldw	r3,-12(fp)
 90c9a48:	e0bffe17 	ldw	r2,-8(fp)
 90c9a4c:	1880031e 	bne	r3,r2,90c9a5c <isvfile_locked+0x34>
      return TRUE;
 90c9a50:	00800044 	movi	r2,1
 90c9a54:	e0bfff15 	stw	r2,-4(fp)
 90c9a58:	00000706 	br	90c9a78 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 90c9a5c:	e0bffd17 	ldw	r2,-12(fp)
 90c9a60:	10800017 	ldw	r2,0(r2)
 90c9a64:	e0bffd15 	stw	r2,-12(fp)
 90c9a68:	e0bffd17 	ldw	r2,-12(fp)
 90c9a6c:	1004c03a 	cmpne	r2,r2,zero
 90c9a70:	103ff41e 	bne	r2,zero,90c9a44 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 90c9a74:	e03fff15 	stw	zero,-4(fp)
 90c9a78:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9a7c:	e037883a 	mov	sp,fp
 90c9a80:	df000017 	ldw	fp,0(sp)
 90c9a84:	dec00104 	addi	sp,sp,4
 90c9a88:	f800283a 	ret

090c9a8c <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 90c9a8c:	defffc04 	addi	sp,sp,-16
 90c9a90:	dfc00315 	stw	ra,12(sp)
 90c9a94:	df000215 	stw	fp,8(sp)
 90c9a98:	df000204 	addi	fp,sp,8
 90c9a9c:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 90c9aa0:	01000144 	movi	r4,5
 90c9aa4:	90aaab40 	call	90aaab4 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 90c9aa8:	e13fff17 	ldw	r4,-4(fp)
 90c9aac:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c9ab0:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 90c9ab4:	01000144 	movi	r4,5
 90c9ab8:	90aab680 	call	90aab68 <post_app_sem>
   return rc;
 90c9abc:	e0bffe17 	ldw	r2,-8(fp)
}
 90c9ac0:	e037883a 	mov	sp,fp
 90c9ac4:	dfc00117 	ldw	ra,4(sp)
 90c9ac8:	df000017 	ldw	fp,0(sp)
 90c9acc:	dec00204 	addi	sp,sp,8
 90c9ad0:	f800283a 	ret

090c9ad4 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 90c9ad4:	defffc04 	addi	sp,sp,-16
 90c9ad8:	dfc00315 	stw	ra,12(sp)
 90c9adc:	df000215 	stw	fp,8(sp)
 90c9ae0:	df000204 	addi	fp,sp,8
 90c9ae4:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 90c9ae8:	01000144 	movi	r4,5
 90c9aec:	90aaab40 	call	90aaab4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c9af0:	e13ffe17 	ldw	r4,-8(fp)
 90c9af4:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c9af8:	1005003a 	cmpeq	r2,r2,zero
 90c9afc:	1000061e 	bne	r2,zero,90c9b18 <vferror+0x44>
   {
      vfs_unlock();
 90c9b00:	01000144 	movi	r4,5
 90c9b04:	90aab680 	call	90aab68 <post_app_sem>

      return vfd->error;
 90c9b08:	e0bffe17 	ldw	r2,-8(fp)
 90c9b0c:	10800417 	ldw	r2,16(r2)
 90c9b10:	e0bfff15 	stw	r2,-4(fp)
 90c9b14:	00000406 	br	90c9b28 <vferror+0x54>
   }

   vfs_unlock();
 90c9b18:	01000144 	movi	r4,5
 90c9b1c:	90aab680 	call	90aab68 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 90c9b20:	00bfffc4 	movi	r2,-1
 90c9b24:	e0bfff15 	stw	r2,-4(fp)
 90c9b28:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 90c9b2c:	e037883a 	mov	sp,fp
 90c9b30:	dfc00117 	ldw	ra,4(sp)
 90c9b34:	df000017 	ldw	fp,0(sp)
 90c9b38:	dec00204 	addi	sp,sp,8
 90c9b3c:	f800283a 	ret

090c9b40 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 90c9b40:	defffd04 	addi	sp,sp,-12
 90c9b44:	dfc00215 	stw	ra,8(sp)
 90c9b48:	df000115 	stw	fp,4(sp)
 90c9b4c:	df000104 	addi	fp,sp,4
 90c9b50:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 90c9b54:	01000144 	movi	r4,5
 90c9b58:	90aaab40 	call	90aaab4 <wait_app_sem>

   if (isvfile_locked(vfd))
 90c9b5c:	e13fff17 	ldw	r4,-4(fp)
 90c9b60:	90c9a280 	call	90c9a28 <isvfile_locked>
 90c9b64:	1005003a 	cmpeq	r2,r2,zero
 90c9b68:	1000051e 	bne	r2,zero,90c9b80 <vclearerr+0x40>
   {
      vfs_unlock();
 90c9b6c:	01000144 	movi	r4,5
 90c9b70:	90aab680 	call	90aab68 <post_app_sem>

      vfd->error = 0;
 90c9b74:	e0bfff17 	ldw	r2,-4(fp)
 90c9b78:	10000415 	stw	zero,16(r2)
      return;
 90c9b7c:	00000206 	br	90c9b88 <vclearerr+0x48>
   }

   vfs_unlock();
 90c9b80:	01000144 	movi	r4,5
 90c9b84:	90aab680 	call	90aab68 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 90c9b88:	e037883a 	mov	sp,fp
 90c9b8c:	dfc00117 	ldw	ra,4(sp)
 90c9b90:	df000017 	ldw	fp,0(sp)
 90c9b94:	dec00204 	addi	sp,sp,8
 90c9b98:	f800283a 	ret

090c9b9c <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 90c9b9c:	defffe04 	addi	sp,sp,-8
 90c9ba0:	df000115 	stw	fp,4(sp)
 90c9ba4:	df000104 	addi	fp,sp,4
int e = 0;
 90c9ba8:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 90c9bac:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9bb0:	e037883a 	mov	sp,fp
 90c9bb4:	df000017 	ldw	fp,0(sp)
 90c9bb8:	dec00104 	addi	sp,sp,4
 90c9bbc:	f800283a 	ret

090c9bc0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 90c9bc0:	defffb04 	addi	sp,sp,-20
 90c9bc4:	df000415 	stw	fp,16(sp)
 90c9bc8:	df000404 	addi	fp,sp,16
 90c9bcc:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 90c9bd0:	008000c4 	movi	r2,3
 90c9bd4:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 90c9bd8:	e0fffc17 	ldw	r3,-16(fp)
 90c9bdc:	008003f4 	movhi	r2,15
 90c9be0:	10909004 	addi	r2,r2,16960
 90c9be4:	1887383a 	mul	r3,r3,r2
 90c9be8:	00817db4 	movhi	r2,1526
 90c9bec:	10b84004 	addi	r2,r2,-7936
 90c9bf0:	10c7203a 	divu	r3,r2,r3
 90c9bf4:	00a00034 	movhi	r2,32768
 90c9bf8:	10bfffc4 	addi	r2,r2,-1
 90c9bfc:	10c7203a 	divu	r3,r2,r3
 90c9c00:	e0bfff17 	ldw	r2,-4(fp)
 90c9c04:	10c5203a 	divu	r2,r2,r3
 90c9c08:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 90c9c0c:	e0bffd17 	ldw	r2,-12(fp)
 90c9c10:	1005003a 	cmpeq	r2,r2,zero
 90c9c14:	1000251e 	bne	r2,zero,90c9cac <alt_busy_sleep+0xec>
  {
    for(i=0;i<big_loops;i++)
 90c9c18:	e03ffe15 	stw	zero,-8(fp)
 90c9c1c:	00001406 	br	90c9c70 <alt_busy_sleep+0xb0>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 90c9c20:	00a00034 	movhi	r2,32768
 90c9c24:	10bfffc4 	addi	r2,r2,-1
 90c9c28:	10bfffc4 	addi	r2,r2,-1
 90c9c2c:	103ffe1e 	bne	r2,zero,90c9c28 <alt_busy_sleep+0x68>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 90c9c30:	e0fffc17 	ldw	r3,-16(fp)
 90c9c34:	008003f4 	movhi	r2,15
 90c9c38:	10909004 	addi	r2,r2,16960
 90c9c3c:	1887383a 	mul	r3,r3,r2
 90c9c40:	00817db4 	movhi	r2,1526
 90c9c44:	10b84004 	addi	r2,r2,-7936
 90c9c48:	10c7203a 	divu	r3,r2,r3
 90c9c4c:	00a00034 	movhi	r2,32768
 90c9c50:	10bfffc4 	addi	r2,r2,-1
 90c9c54:	10c7203a 	divu	r3,r2,r3
 90c9c58:	e0bfff17 	ldw	r2,-4(fp)
 90c9c5c:	10c5c83a 	sub	r2,r2,r3
 90c9c60:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 90c9c64:	e0bffe17 	ldw	r2,-8(fp)
 90c9c68:	10800044 	addi	r2,r2,1
 90c9c6c:	e0bffe15 	stw	r2,-8(fp)
 90c9c70:	e0fffe17 	ldw	r3,-8(fp)
 90c9c74:	e0bffd17 	ldw	r2,-12(fp)
 90c9c78:	18bfe916 	blt	r3,r2,90c9c20 <alt_busy_sleep+0x60>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 90c9c7c:	e0fffc17 	ldw	r3,-16(fp)
 90c9c80:	008003f4 	movhi	r2,15
 90c9c84:	10909004 	addi	r2,r2,16960
 90c9c88:	1887383a 	mul	r3,r3,r2
 90c9c8c:	00817db4 	movhi	r2,1526
 90c9c90:	10b84004 	addi	r2,r2,-7936
 90c9c94:	10c7203a 	divu	r3,r2,r3
 90c9c98:	e0bfff17 	ldw	r2,-4(fp)
 90c9c9c:	1885383a 	mul	r2,r3,r2
 90c9ca0:	10bfffc4 	addi	r2,r2,-1
 90c9ca4:	103ffe1e 	bne	r2,zero,90c9ca0 <alt_busy_sleep+0xe0>
 90c9ca8:	00000b06 	br	90c9cd8 <alt_busy_sleep+0x118>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 90c9cac:	e0fffc17 	ldw	r3,-16(fp)
 90c9cb0:	008003f4 	movhi	r2,15
 90c9cb4:	10909004 	addi	r2,r2,16960
 90c9cb8:	1887383a 	mul	r3,r3,r2
 90c9cbc:	00817db4 	movhi	r2,1526
 90c9cc0:	10b84004 	addi	r2,r2,-7936
 90c9cc4:	10c7203a 	divu	r3,r2,r3
 90c9cc8:	e0bfff17 	ldw	r2,-4(fp)
 90c9ccc:	1885383a 	mul	r2,r3,r2
 90c9cd0:	10bfffc4 	addi	r2,r2,-1
 90c9cd4:	00bffe16 	blt	zero,r2,90c9cd0 <alt_busy_sleep+0x110>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 90c9cd8:	0005883a 	mov	r2,zero
}
 90c9cdc:	e037883a 	mov	sp,fp
 90c9ce0:	df000017 	ldw	fp,0(sp)
 90c9ce4:	dec00104 	addi	sp,sp,4
 90c9ce8:	f800283a 	ret

090c9cec <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 90c9cec:	defff404 	addi	sp,sp,-48
 90c9cf0:	dfc00915 	stw	ra,36(sp)
 90c9cf4:	df000815 	stw	fp,32(sp)
 90c9cf8:	df000804 	addi	fp,sp,32
 90c9cfc:	e13ffb15 	stw	r4,-20(fp)
 90c9d00:	e1800215 	stw	r6,8(fp)
 90c9d04:	e1c00315 	stw	r7,12(fp)
 90c9d08:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 90c9d0c:	e0bffb17 	ldw	r2,-20(fp)
 90c9d10:	1004803a 	cmplt	r2,r2,zero
 90c9d14:	1000081e 	bne	r2,zero,90c9d38 <alt_fcntl+0x4c>
 90c9d18:	e0bffb17 	ldw	r2,-20(fp)
 90c9d1c:	10800324 	muli	r2,r2,12
 90c9d20:	1007883a 	mov	r3,r2
 90c9d24:	00824374 	movhi	r2,2317
 90c9d28:	108dc104 	addi	r2,r2,14084
 90c9d2c:	1887883a 	add	r3,r3,r2
 90c9d30:	e0fffe15 	stw	r3,-8(fp)
 90c9d34:	00000106 	br	90c9d3c <alt_fcntl+0x50>
 90c9d38:	e03ffe15 	stw	zero,-8(fp)
 90c9d3c:	e0bffe17 	ldw	r2,-8(fp)
 90c9d40:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 90c9d44:	e0bff917 	ldw	r2,-28(fp)
 90c9d48:	1005003a 	cmpeq	r2,r2,zero
 90c9d4c:	1000301e 	bne	r2,zero,90c9e10 <alt_fcntl+0x124>
  {
    switch (cmd)
 90c9d50:	e0fffc17 	ldw	r3,-16(fp)
 90c9d54:	e0ffff15 	stw	r3,-4(fp)
 90c9d58:	e0ffff17 	ldw	r3,-4(fp)
 90c9d5c:	188000e0 	cmpeqi	r2,r3,3
 90c9d60:	1000041e 	bne	r2,zero,90c9d74 <alt_fcntl+0x88>
 90c9d64:	e0ffff17 	ldw	r3,-4(fp)
 90c9d68:	18800120 	cmpeqi	r2,r3,4
 90c9d6c:	1000081e 	bne	r2,zero,90c9d90 <alt_fcntl+0xa4>
 90c9d70:	00002006 	br	90c9df4 <alt_fcntl+0x108>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 90c9d74:	e0bff917 	ldw	r2,-28(fp)
 90c9d78:	10c00217 	ldw	r3,8(r2)
 90c9d7c:	00900034 	movhi	r2,16384
 90c9d80:	10bfffc4 	addi	r2,r2,-1
 90c9d84:	1886703a 	and	r3,r3,r2
 90c9d88:	e0fffd15 	stw	r3,-12(fp)
 90c9d8c:	00002606 	br	90c9e28 <alt_fcntl+0x13c>
    case F_SETFL:
      va_start(argp, cmd);
 90c9d90:	e0800204 	addi	r2,fp,8
 90c9d94:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 90c9d98:	e0fffa17 	ldw	r3,-24(fp)
 90c9d9c:	18800104 	addi	r2,r3,4
 90c9da0:	e0bffa15 	stw	r2,-24(fp)
 90c9da4:	1805883a 	mov	r2,r3
 90c9da8:	10800017 	ldw	r2,0(r2)
 90c9dac:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 90c9db0:	e0bff917 	ldw	r2,-28(fp)
 90c9db4:	10c00217 	ldw	r3,8(r2)
 90c9db8:	00affdc4 	movi	r2,-16393
 90c9dbc:	1886703a 	and	r3,r3,r2
 90c9dc0:	e0bff917 	ldw	r2,-28(fp)
 90c9dc4:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 90c9dc8:	e0bff917 	ldw	r2,-28(fp)
 90c9dcc:	10800217 	ldw	r2,8(r2)
 90c9dd0:	1007883a 	mov	r3,r2
 90c9dd4:	e0bff817 	ldw	r2,-32(fp)
 90c9dd8:	1090020c 	andi	r2,r2,16392
 90c9ddc:	1884b03a 	or	r2,r3,r2
 90c9de0:	1007883a 	mov	r3,r2
 90c9de4:	e0bff917 	ldw	r2,-28(fp)
 90c9de8:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 90c9dec:	e03ffd15 	stw	zero,-12(fp)
 90c9df0:	00000d06 	br	90c9e28 <alt_fcntl+0x13c>
    default:
      ALT_ERRNO = EINVAL;
 90c9df4:	90c9e400 	call	90c9e40 <alt_get_errno>
 90c9df8:	1007883a 	mov	r3,r2
 90c9dfc:	00800584 	movi	r2,22
 90c9e00:	18800015 	stw	r2,0(r3)
      return -1;
 90c9e04:	00bfffc4 	movi	r2,-1
 90c9e08:	e0bffd15 	stw	r2,-12(fp)
 90c9e0c:	00000606 	br	90c9e28 <alt_fcntl+0x13c>
    }
  }

  ALT_ERRNO = EBADFD;
 90c9e10:	90c9e400 	call	90c9e40 <alt_get_errno>
 90c9e14:	1007883a 	mov	r3,r2
 90c9e18:	00801444 	movi	r2,81
 90c9e1c:	18800015 	stw	r2,0(r3)
  return -1;
 90c9e20:	00ffffc4 	movi	r3,-1
 90c9e24:	e0fffd15 	stw	r3,-12(fp)
 90c9e28:	e0bffd17 	ldw	r2,-12(fp)
}
 90c9e2c:	e037883a 	mov	sp,fp
 90c9e30:	dfc00117 	ldw	ra,4(sp)
 90c9e34:	df000017 	ldw	fp,0(sp)
 90c9e38:	dec00404 	addi	sp,sp,16
 90c9e3c:	f800283a 	ret

090c9e40 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 90c9e40:	defffd04 	addi	sp,sp,-12
 90c9e44:	dfc00215 	stw	ra,8(sp)
 90c9e48:	df000115 	stw	fp,4(sp)
 90c9e4c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 90c9e50:	00824374 	movhi	r2,2317
 90c9e54:	108eca04 	addi	r2,r2,15144
 90c9e58:	10800017 	ldw	r2,0(r2)
 90c9e5c:	1005003a 	cmpeq	r2,r2,zero
 90c9e60:	1000061e 	bne	r2,zero,90c9e7c <alt_get_errno+0x3c>
 90c9e64:	00824374 	movhi	r2,2317
 90c9e68:	108eca04 	addi	r2,r2,15144
 90c9e6c:	10800017 	ldw	r2,0(r2)
 90c9e70:	103ee83a 	callr	r2
 90c9e74:	e0bfff15 	stw	r2,-4(fp)
 90c9e78:	00000306 	br	90c9e88 <alt_get_errno+0x48>
 90c9e7c:	00824374 	movhi	r2,2317
 90c9e80:	108ee904 	addi	r2,r2,15268
 90c9e84:	e0bfff15 	stw	r2,-4(fp)
 90c9e88:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9e8c:	e037883a 	mov	sp,fp
 90c9e90:	dfc00117 	ldw	ra,4(sp)
 90c9e94:	df000017 	ldw	fp,0(sp)
 90c9e98:	dec00204 	addi	sp,sp,8
 90c9e9c:	f800283a 	ret

090c9ea0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 90c9ea0:	defffa04 	addi	sp,sp,-24
 90c9ea4:	dfc00515 	stw	ra,20(sp)
 90c9ea8:	df000415 	stw	fp,16(sp)
 90c9eac:	df000404 	addi	fp,sp,16
 90c9eb0:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 90c9eb4:	00824374 	movhi	r2,2317
 90c9eb8:	108ec504 	addi	r2,r2,15124
 90c9ebc:	10800017 	ldw	r2,0(r2)
 90c9ec0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 90c9ec4:	00003306 	br	90c9f94 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 90c9ec8:	e0bffd17 	ldw	r2,-12(fp)
 90c9ecc:	11000217 	ldw	r4,8(r2)
 90c9ed0:	9083f540 	call	9083f54 <strlen>
 90c9ed4:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 90c9ed8:	e0bffd17 	ldw	r2,-12(fp)
 90c9edc:	10c00217 	ldw	r3,8(r2)
 90c9ee0:	e0bffc17 	ldw	r2,-16(fp)
 90c9ee4:	1885883a 	add	r2,r3,r2
 90c9ee8:	10bfffc4 	addi	r2,r2,-1
 90c9eec:	10800003 	ldbu	r2,0(r2)
 90c9ef0:	10803fcc 	andi	r2,r2,255
 90c9ef4:	1080201c 	xori	r2,r2,128
 90c9ef8:	10bfe004 	addi	r2,r2,-128
 90c9efc:	10800bd8 	cmpnei	r2,r2,47
 90c9f00:	1000031e 	bne	r2,zero,90c9f10 <alt_find_file+0x70>
    {
      len -= 1;
 90c9f04:	e0bffc17 	ldw	r2,-16(fp)
 90c9f08:	10bfffc4 	addi	r2,r2,-1
 90c9f0c:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 90c9f10:	e0bffc17 	ldw	r2,-16(fp)
 90c9f14:	1007883a 	mov	r3,r2
 90c9f18:	e0bffe17 	ldw	r2,-8(fp)
 90c9f1c:	1885883a 	add	r2,r3,r2
 90c9f20:	10800003 	ldbu	r2,0(r2)
 90c9f24:	10803fcc 	andi	r2,r2,255
 90c9f28:	1080201c 	xori	r2,r2,128
 90c9f2c:	10bfe004 	addi	r2,r2,-128
 90c9f30:	10800be0 	cmpeqi	r2,r2,47
 90c9f34:	10000a1e 	bne	r2,zero,90c9f60 <alt_find_file+0xc0>
 90c9f38:	e0bffc17 	ldw	r2,-16(fp)
 90c9f3c:	1007883a 	mov	r3,r2
 90c9f40:	e0bffe17 	ldw	r2,-8(fp)
 90c9f44:	1885883a 	add	r2,r3,r2
 90c9f48:	10800003 	ldbu	r2,0(r2)
 90c9f4c:	10803fcc 	andi	r2,r2,255
 90c9f50:	1080201c 	xori	r2,r2,128
 90c9f54:	10bfe004 	addi	r2,r2,-128
 90c9f58:	1004c03a 	cmpne	r2,r2,zero
 90c9f5c:	10000a1e 	bne	r2,zero,90c9f88 <alt_find_file+0xe8>
 90c9f60:	e0bffd17 	ldw	r2,-12(fp)
 90c9f64:	11000217 	ldw	r4,8(r2)
 90c9f68:	e1bffc17 	ldw	r6,-16(fp)
 90c9f6c:	e17ffe17 	ldw	r5,-8(fp)
 90c9f70:	90cb4540 	call	90cb454 <memcmp>
 90c9f74:	1004c03a 	cmpne	r2,r2,zero
 90c9f78:	1000031e 	bne	r2,zero,90c9f88 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 90c9f7c:	e0bffd17 	ldw	r2,-12(fp)
 90c9f80:	e0bfff15 	stw	r2,-4(fp)
 90c9f84:	00000806 	br	90c9fa8 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 90c9f88:	e0bffd17 	ldw	r2,-12(fp)
 90c9f8c:	10800017 	ldw	r2,0(r2)
 90c9f90:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 90c9f94:	00c24374 	movhi	r3,2317
 90c9f98:	18cec504 	addi	r3,r3,15124
 90c9f9c:	e0bffd17 	ldw	r2,-12(fp)
 90c9fa0:	10ffc91e 	bne	r2,r3,90c9ec8 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 90c9fa4:	e03fff15 	stw	zero,-4(fp)
 90c9fa8:	e0bfff17 	ldw	r2,-4(fp)
}
 90c9fac:	e037883a 	mov	sp,fp
 90c9fb0:	dfc00117 	ldw	ra,4(sp)
 90c9fb4:	df000017 	ldw	fp,0(sp)
 90c9fb8:	dec00204 	addi	sp,sp,8
 90c9fbc:	f800283a 	ret

090c9fc0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 90c9fc0:	defff804 	addi	sp,sp,-32
 90c9fc4:	dfc00715 	stw	ra,28(sp)
 90c9fc8:	df000615 	stw	fp,24(sp)
 90c9fcc:	df000604 	addi	fp,sp,24
 90c9fd0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 90c9fd4:	00bffa04 	movi	r2,-24
 90c9fd8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 90c9fdc:	00824374 	movhi	r2,2317
 90c9fe0:	108f3c04 	addi	r2,r2,15600
 90c9fe4:	10800017 	ldw	r2,0(r2)
 90c9fe8:	e0bffa15 	stw	r2,-24(fp)
 90c9fec:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 90c9ff0:	e17ffb0b 	ldhu	r5,-20(fp)
 90c9ff4:	e1bffe04 	addi	r6,fp,-8
 90c9ff8:	e13ffa17 	ldw	r4,-24(fp)
 90c9ffc:	9093c5c0 	call	9093c5c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 90ca000:	e03ffd15 	stw	zero,-12(fp)
 90ca004:	00001e06 	br	90ca080 <alt_get_fd+0xc0>
  {
    if (!alt_fd_list[i].dev)
 90ca008:	e0bffd17 	ldw	r2,-12(fp)
 90ca00c:	00c24374 	movhi	r3,2317
 90ca010:	18cdc104 	addi	r3,r3,14084
 90ca014:	10800324 	muli	r2,r2,12
 90ca018:	10c5883a 	add	r2,r2,r3
 90ca01c:	10800017 	ldw	r2,0(r2)
 90ca020:	1004c03a 	cmpne	r2,r2,zero
 90ca024:	1000131e 	bne	r2,zero,90ca074 <alt_get_fd+0xb4>
    {
      alt_fd_list[i].dev = dev;
 90ca028:	e0bffd17 	ldw	r2,-12(fp)
 90ca02c:	00c24374 	movhi	r3,2317
 90ca030:	18cdc104 	addi	r3,r3,14084
 90ca034:	10800324 	muli	r2,r2,12
 90ca038:	10c7883a 	add	r3,r2,r3
 90ca03c:	e0bfff17 	ldw	r2,-4(fp)
 90ca040:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 90ca044:	00824374 	movhi	r2,2317
 90ca048:	108ec904 	addi	r2,r2,15140
 90ca04c:	10c00017 	ldw	r3,0(r2)
 90ca050:	e0bffd17 	ldw	r2,-12(fp)
 90ca054:	1880040e 	bge	r3,r2,90ca068 <alt_get_fd+0xa8>
      {
        alt_max_fd = i;
 90ca058:	00c24374 	movhi	r3,2317
 90ca05c:	18cec904 	addi	r3,r3,15140
 90ca060:	e0bffd17 	ldw	r2,-12(fp)
 90ca064:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 90ca068:	e0bffd17 	ldw	r2,-12(fp)
 90ca06c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 90ca070:	00000606 	br	90ca08c <alt_get_fd+0xcc>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 90ca074:	e0bffd17 	ldw	r2,-12(fp)
 90ca078:	10800044 	addi	r2,r2,1
 90ca07c:	e0bffd15 	stw	r2,-12(fp)
 90ca080:	e0bffd17 	ldw	r2,-12(fp)
 90ca084:	10800810 	cmplti	r2,r2,32
 90ca088:	103fdf1e 	bne	r2,zero,90ca008 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 90ca08c:	00824374 	movhi	r2,2317
 90ca090:	108f3c04 	addi	r2,r2,15600
 90ca094:	11000017 	ldw	r4,0(r2)
 90ca098:	90940540 	call	9094054 <OSSemPost>

  return rc;
 90ca09c:	e0bffc17 	ldw	r2,-16(fp)
}
 90ca0a0:	e037883a 	mov	sp,fp
 90ca0a4:	dfc00117 	ldw	ra,4(sp)
 90ca0a8:	df000017 	ldw	fp,0(sp)
 90ca0ac:	dec00204 	addi	sp,sp,8
 90ca0b0:	f800283a 	ret

090ca0b4 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 90ca0b4:	deffed04 	addi	sp,sp,-76
 90ca0b8:	dfc01215 	stw	ra,72(sp)
 90ca0bc:	df001115 	stw	fp,68(sp)
 90ca0c0:	dc401015 	stw	r17,64(sp)
 90ca0c4:	dc000f15 	stw	r16,60(sp)
 90ca0c8:	df000f04 	addi	fp,sp,60
 90ca0cc:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 90ca0d0:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 90ca0d4:	008243b4 	movhi	r2,2318
 90ca0d8:	10b84a04 	addi	r2,r2,-7896
 90ca0dc:	10800017 	ldw	r2,0(r2)
 90ca0e0:	10c00044 	addi	r3,r2,1
 90ca0e4:	008243b4 	movhi	r2,2318
 90ca0e8:	10b84a04 	addi	r2,r2,-7896
 90ca0ec:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 90ca0f0:	e0bffd17 	ldw	r2,-12(fp)
 90ca0f4:	10800317 	ldw	r2,12(r2)
 90ca0f8:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 90ca0fc:	e0bffd17 	ldw	r2,-12(fp)
 90ca100:	10c00417 	ldw	r3,16(r2)
 90ca104:	e0bffa17 	ldw	r2,-24(fp)
 90ca108:	10800003 	ldbu	r2,0(r2)
 90ca10c:	10803fcc 	andi	r2,r2,255
 90ca110:	108003cc 	andi	r2,r2,15
 90ca114:	1085883a 	add	r2,r2,r2
 90ca118:	1085883a 	add	r2,r2,r2
 90ca11c:	1885c83a 	sub	r2,r3,r2
 90ca120:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 90ca124:	e0bffd17 	ldw	r2,-12(fp)
 90ca128:	10800717 	ldw	r2,28(r2)
 90ca12c:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90ca130:	00824374 	movhi	r2,2317
 90ca134:	108f0904 	addi	r2,r2,15396
 90ca138:	10800017 	ldw	r2,0(r2)
 90ca13c:	1081000c 	andi	r2,r2,1024
 90ca140:	1005003a 	cmpeq	r2,r2,zero
 90ca144:	1000161e 	bne	r2,zero,90ca1a0 <icmprcv+0xec>
 90ca148:	00824374 	movhi	r2,2317
 90ca14c:	108f0904 	addi	r2,r2,15396
 90ca150:	10800017 	ldw	r2,0(r2)
 90ca154:	1080800c 	andi	r2,r2,512
 90ca158:	1005003a 	cmpeq	r2,r2,zero
 90ca15c:	1000101e 	bne	r2,zero,90ca1a0 <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 90ca160:	e0bffb17 	ldw	r2,-20(fp)
 90ca164:	11803fcc 	andi	r6,r2,255
 90ca168:	e0bffb17 	ldw	r2,-20(fp)
 90ca16c:	1004d23a 	srli	r2,r2,8
 90ca170:	11c03fcc 	andi	r7,r2,255
 90ca174:	e0bffb17 	ldw	r2,-20(fp)
 90ca178:	1004d43a 	srli	r2,r2,16
 90ca17c:	10c03fcc 	andi	r3,r2,255
 90ca180:	e0bffb17 	ldw	r2,-20(fp)
 90ca184:	1004d63a 	srli	r2,r2,24
 90ca188:	d8c00015 	stw	r3,0(sp)
 90ca18c:	d8800115 	stw	r2,4(sp)
 90ca190:	01024374 	movhi	r4,2317
 90ca194:	2105be04 	addi	r4,r4,5880
 90ca198:	e17ffc17 	ldw	r5,-16(fp)
 90ca19c:	90833900 	call	9083390 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 90ca1a0:	e0bffa17 	ldw	r2,-24(fp)
 90ca1a4:	10800003 	ldbu	r2,0(r2)
 90ca1a8:	10803fcc 	andi	r2,r2,255
 90ca1ac:	108003cc 	andi	r2,r2,15
 90ca1b0:	1085883a 	add	r2,r2,r2
 90ca1b4:	1085883a 	add	r2,r2,r2
 90ca1b8:	1007883a 	mov	r3,r2
 90ca1bc:	e0bffa17 	ldw	r2,-24(fp)
 90ca1c0:	1885883a 	add	r2,r3,r2
 90ca1c4:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 90ca1c8:	e0bff917 	ldw	r2,-28(fp)
 90ca1cc:	1080008b 	ldhu	r2,2(r2)
 90ca1d0:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 90ca1d4:	e0bff917 	ldw	r2,-28(fp)
 90ca1d8:	1000008d 	sth	zero,2(r2)

   if (len&1)
 90ca1dc:	e0bffc17 	ldw	r2,-16(fp)
 90ca1e0:	1080004c 	andi	r2,r2,1
 90ca1e4:	10803fcc 	andi	r2,r2,255
 90ca1e8:	1005003a 	cmpeq	r2,r2,zero
 90ca1ec:	1000091e 	bne	r2,zero,90ca214 <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 90ca1f0:	e0fff917 	ldw	r3,-28(fp)
 90ca1f4:	e0bffc17 	ldw	r2,-16(fp)
 90ca1f8:	1885883a 	add	r2,r3,r2
 90ca1fc:	10800003 	ldbu	r2,0(r2)
 90ca200:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 90ca204:	e0fff917 	ldw	r3,-28(fp)
 90ca208:	e0bffc17 	ldw	r2,-16(fp)
 90ca20c:	1885883a 	add	r2,r3,r2
 90ca210:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 90ca214:	e0bffc17 	ldw	r2,-16(fp)
 90ca218:	10800044 	addi	r2,r2,1
 90ca21c:	100ad07a 	srli	r5,r2,1
 90ca220:	e13ff917 	ldw	r4,-28(fp)
 90ca224:	90a4ef40 	call	90a4ef4 <cksum>
 90ca228:	0084303a 	nor	r2,zero,r2
 90ca22c:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 90ca230:	e0bffc17 	ldw	r2,-16(fp)
 90ca234:	1080004c 	andi	r2,r2,1
 90ca238:	10803fcc 	andi	r2,r2,255
 90ca23c:	1005003a 	cmpeq	r2,r2,zero
 90ca240:	1000051e 	bne	r2,zero,90ca258 <icmprcv+0x1a4>
 90ca244:	e0fff917 	ldw	r3,-28(fp)
 90ca248:	e0bffc17 	ldw	r2,-16(fp)
 90ca24c:	1887883a 	add	r3,r3,r2
 90ca250:	e0bff503 	ldbu	r2,-44(fp)
 90ca254:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 90ca258:	e0fff80b 	ldhu	r3,-32(fp)
 90ca25c:	e0bff88b 	ldhu	r2,-30(fp)
 90ca260:	18802c26 	beq	r3,r2,90ca314 <icmprcv+0x260>
   {
      e->pchksum = osum;
 90ca264:	e0fff917 	ldw	r3,-28(fp)
 90ca268:	e0bff88b 	ldhu	r2,-30(fp)
 90ca26c:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90ca270:	00824374 	movhi	r2,2317
 90ca274:	108f0904 	addi	r2,r2,15396
 90ca278:	10800017 	ldw	r2,0(r2)
 90ca27c:	1081000c 	andi	r2,r2,1024
 90ca280:	1005003a 	cmpeq	r2,r2,zero
 90ca284:	1000131e 	bne	r2,zero,90ca2d4 <icmprcv+0x220>
 90ca288:	00824374 	movhi	r2,2317
 90ca28c:	108f0904 	addi	r2,r2,15396
 90ca290:	10800017 	ldw	r2,0(r2)
 90ca294:	1080800c 	andi	r2,r2,512
 90ca298:	1005003a 	cmpeq	r2,r2,zero
 90ca29c:	10000d1e 	bne	r2,zero,90ca2d4 <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 90ca2a0:	e17ff88b 	ldhu	r5,-30(fp)
 90ca2a4:	e1bff80b 	ldhu	r6,-32(fp)
 90ca2a8:	01024374 	movhi	r4,2317
 90ca2ac:	2105c604 	addi	r4,r4,5912
 90ca2b0:	90833900 	call	9083390 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 90ca2b4:	00824374 	movhi	r2,2317
 90ca2b8:	108f0904 	addi	r2,r2,15396
 90ca2bc:	10800017 	ldw	r2,0(r2)
 90ca2c0:	1080008c 	andi	r2,r2,2
 90ca2c4:	1005003a 	cmpeq	r2,r2,zero
 90ca2c8:	1000021e 	bne	r2,zero,90ca2d4 <icmprcv+0x220>
 90ca2cc:	e13ffd17 	ldw	r4,-12(fp)
 90ca2d0:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 90ca2d4:	008243b4 	movhi	r2,2318
 90ca2d8:	10b84a04 	addi	r2,r2,-7896
 90ca2dc:	10800117 	ldw	r2,4(r2)
 90ca2e0:	10c00044 	addi	r3,r2,1
 90ca2e4:	008243b4 	movhi	r2,2318
 90ca2e8:	10b84a04 	addi	r2,r2,-7896
 90ca2ec:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90ca2f0:	01000084 	movi	r4,2
 90ca2f4:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90ca2f8:	e13ffd17 	ldw	r4,-12(fp)
 90ca2fc:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ca300:	01000084 	movi	r4,2
 90ca304:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 90ca308:	00bff804 	movi	r2,-32
 90ca30c:	e0bfff15 	stw	r2,-4(fp)
 90ca310:	00026d06 	br	90cacc8 <icmprcv+0xc14>
   }

   e->pchksum = osum;
 90ca314:	e0fff917 	ldw	r3,-28(fp)
 90ca318:	e0bff88b 	ldhu	r2,-30(fp)
 90ca31c:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 90ca320:	e0bff917 	ldw	r2,-28(fp)
 90ca324:	10800003 	ldbu	r2,0(r2)
 90ca328:	10803fcc 	andi	r2,r2,255
 90ca32c:	1080201c 	xori	r2,r2,128
 90ca330:	10bfe004 	addi	r2,r2,-128
 90ca334:	e0bffe15 	stw	r2,-8(fp)
 90ca338:	e0fffe17 	ldw	r3,-8(fp)
 90ca33c:	18800428 	cmpgeui	r2,r3,16
 90ca340:	1002401e 	bne	r2,zero,90cac44 <icmprcv+0xb90>
 90ca344:	e13ffe17 	ldw	r4,-8(fp)
 90ca348:	e13ffe17 	ldw	r4,-8(fp)
 90ca34c:	2105883a 	add	r2,r4,r4
 90ca350:	1087883a 	add	r3,r2,r2
 90ca354:	00824374 	movhi	r2,2317
 90ca358:	10a8da04 	addi	r2,r2,-23704
 90ca35c:	1885883a 	add	r2,r3,r2
 90ca360:	10800017 	ldw	r2,0(r2)
 90ca364:	1000683a 	jmp	r2
 90ca368:	090ca64c 	andi	r4,at,12953
 90ca36c:	090cac44 	addi	r4,at,12977
 90ca370:	090cac44 	addi	r4,at,12977
 90ca374:	090ca678 	rdprs	r4,at,12953
 90ca378:	090ca768 	cmpgeui	r4,at,12957
 90ca37c:	090ca810 	cmplti	r4,at,12960
 90ca380:	090cac44 	addi	r4,at,12977
 90ca384:	090cac44 	addi	r4,at,12977
 90ca388:	090ca3a8 	cmpgeui	r4,at,12942
 90ca38c:	090cac44 	addi	r4,at,12977
 90ca390:	090cac44 	addi	r4,at,12977
 90ca394:	090ca930 	cmpltui	r4,at,12964
 90ca398:	090caa38 	rdprs	r4,at,12968
 90ca39c:	090caab4 	orhi	r4,at,12970
 90ca3a0:	090cac44 	addi	r4,at,12977
 90ca3a4:	090cac04 	addi	r4,at,12976
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 90ca3a8:	008243b4 	movhi	r2,2318
 90ca3ac:	10b84a04 	addi	r2,r2,-7896
 90ca3b0:	10800717 	ldw	r2,28(r2)
 90ca3b4:	10c00044 	addi	r3,r2,1
 90ca3b8:	008243b4 	movhi	r2,2318
 90ca3bc:	10b84a04 	addi	r2,r2,-7896
 90ca3c0:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 90ca3c4:	00824374 	movhi	r2,2317
 90ca3c8:	108f0904 	addi	r2,r2,15396
 90ca3cc:	10800017 	ldw	r2,0(r2)
 90ca3d0:	1081000c 	andi	r2,r2,1024
 90ca3d4:	1005003a 	cmpeq	r2,r2,zero
 90ca3d8:	1000141e 	bne	r2,zero,90ca42c <icmprcv+0x378>
 90ca3dc:	00824374 	movhi	r2,2317
 90ca3e0:	108f0904 	addi	r2,r2,15396
 90ca3e4:	10800017 	ldw	r2,0(r2)
 90ca3e8:	1080800c 	andi	r2,r2,512
 90ca3ec:	1005003a 	cmpeq	r2,r2,zero
 90ca3f0:	10000e1e 	bne	r2,zero,90ca42c <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90ca3f4:	e0bffb17 	ldw	r2,-20(fp)
 90ca3f8:	11403fcc 	andi	r5,r2,255
 90ca3fc:	e0bffb17 	ldw	r2,-20(fp)
 90ca400:	1004d23a 	srli	r2,r2,8
 90ca404:	11803fcc 	andi	r6,r2,255
 90ca408:	e0bffb17 	ldw	r2,-20(fp)
 90ca40c:	1004d43a 	srli	r2,r2,16
 90ca410:	11c03fcc 	andi	r7,r2,255
 90ca414:	e0bffb17 	ldw	r2,-20(fp)
 90ca418:	1004d63a 	srli	r2,r2,24
 90ca41c:	d8800015 	stw	r2,0(sp)
 90ca420:	01024374 	movhi	r4,2317
 90ca424:	2105d104 	addi	r4,r4,5956
 90ca428:	90833900 	call	9083390 <printf>
#endif
      e->ptype = ECHOREP;
 90ca42c:	e0bff917 	ldw	r2,-28(fp)
 90ca430:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 90ca434:	e0bff917 	ldw	r2,-28(fp)
 90ca438:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 90ca43c:	e0bffc17 	ldw	r2,-16(fp)
 90ca440:	1080004c 	andi	r2,r2,1
 90ca444:	10803fcc 	andi	r2,r2,255
 90ca448:	1005003a 	cmpeq	r2,r2,zero
 90ca44c:	1000091e 	bne	r2,zero,90ca474 <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 90ca450:	e0fff917 	ldw	r3,-28(fp)
 90ca454:	e0bffc17 	ldw	r2,-16(fp)
 90ca458:	1885883a 	add	r2,r3,r2
 90ca45c:	10800003 	ldbu	r2,0(r2)
 90ca460:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 90ca464:	e0fff917 	ldw	r3,-28(fp)
 90ca468:	e0bffc17 	ldw	r2,-16(fp)
 90ca46c:	1885883a 	add	r2,r3,r2
 90ca470:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 90ca474:	e0bffc17 	ldw	r2,-16(fp)
 90ca478:	10800044 	addi	r2,r2,1
 90ca47c:	100ad07a 	srli	r5,r2,1
 90ca480:	e13ff917 	ldw	r4,-28(fp)
 90ca484:	90a4ef40 	call	90a4ef4 <cksum>
 90ca488:	0084303a 	nor	r2,zero,r2
 90ca48c:	1007883a 	mov	r3,r2
 90ca490:	e0bff917 	ldw	r2,-28(fp)
 90ca494:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 90ca498:	e0bffc17 	ldw	r2,-16(fp)
 90ca49c:	1080004c 	andi	r2,r2,1
 90ca4a0:	10803fcc 	andi	r2,r2,255
 90ca4a4:	1005003a 	cmpeq	r2,r2,zero
 90ca4a8:	1000051e 	bne	r2,zero,90ca4c0 <icmprcv+0x40c>
 90ca4ac:	e0fff917 	ldw	r3,-28(fp)
 90ca4b0:	e0bffc17 	ldw	r2,-16(fp)
 90ca4b4:	1887883a 	add	r3,r3,r2
 90ca4b8:	e0bff503 	ldbu	r2,-44(fp)
 90ca4bc:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 90ca4c0:	e0bffa17 	ldw	r2,-24(fp)
 90ca4c4:	10800417 	ldw	r2,16(r2)
 90ca4c8:	10bfffe0 	cmpeqi	r2,r2,-1
 90ca4cc:	1000211e 	bne	r2,zero,90ca554 <icmprcv+0x4a0>
 90ca4d0:	e0bffa17 	ldw	r2,-24(fp)
 90ca4d4:	10800417 	ldw	r2,16(r2)
 90ca4d8:	1004d63a 	srli	r2,r2,24
 90ca4dc:	10c03fcc 	andi	r3,r2,255
 90ca4e0:	e0bffa17 	ldw	r2,-24(fp)
 90ca4e4:	10800417 	ldw	r2,16(r2)
 90ca4e8:	1004d23a 	srli	r2,r2,8
 90ca4ec:	10bfc00c 	andi	r2,r2,65280
 90ca4f0:	1886b03a 	or	r3,r3,r2
 90ca4f4:	e0bffa17 	ldw	r2,-24(fp)
 90ca4f8:	10800417 	ldw	r2,16(r2)
 90ca4fc:	10bfc00c 	andi	r2,r2,65280
 90ca500:	1004923a 	slli	r2,r2,8
 90ca504:	1886b03a 	or	r3,r3,r2
 90ca508:	e0bffa17 	ldw	r2,-24(fp)
 90ca50c:	10800417 	ldw	r2,16(r2)
 90ca510:	10803fcc 	andi	r2,r2,255
 90ca514:	1004963a 	slli	r2,r2,24
 90ca518:	1884b03a 	or	r2,r3,r2
 90ca51c:	10fc002c 	andhi	r3,r2,61440
 90ca520:	00b80034 	movhi	r2,57344
 90ca524:	18800b26 	beq	r3,r2,90ca554 <icmprcv+0x4a0>
 90ca528:	e0bffa17 	ldw	r2,-24(fp)
 90ca52c:	11000417 	ldw	r4,16(r2)
 90ca530:	e0bffd17 	ldw	r2,-12(fp)
 90ca534:	10800617 	ldw	r2,24(r2)
 90ca538:	10c00a17 	ldw	r3,40(r2)
 90ca53c:	e0bffd17 	ldw	r2,-12(fp)
 90ca540:	10800617 	ldw	r2,24(r2)
 90ca544:	10800c17 	ldw	r2,48(r2)
 90ca548:	0084303a 	nor	r2,zero,r2
 90ca54c:	1884b03a 	or	r2,r3,r2
 90ca550:	2080061e 	bne	r4,r2,90ca56c <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 90ca554:	e0bffd17 	ldw	r2,-12(fp)
 90ca558:	10800617 	ldw	r2,24(r2)
 90ca55c:	10c00a17 	ldw	r3,40(r2)
 90ca560:	e0bffa17 	ldw	r2,-24(fp)
 90ca564:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 90ca568:	00000406 	br	90ca57c <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 90ca56c:	e0bffa17 	ldw	r2,-24(fp)
 90ca570:	10c00417 	ldw	r3,16(r2)
 90ca574:	e0bffa17 	ldw	r2,-24(fp)
 90ca578:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 90ca57c:	e0fffa17 	ldw	r3,-24(fp)
 90ca580:	e0bffb17 	ldw	r2,-20(fp)
 90ca584:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 90ca588:	008243b4 	movhi	r2,2318
 90ca58c:	10b84a04 	addi	r2,r2,-7896
 90ca590:	10801517 	ldw	r2,84(r2)
 90ca594:	10c00044 	addi	r3,r2,1
 90ca598:	008243b4 	movhi	r2,2318
 90ca59c:	10b84a04 	addi	r2,r2,-7896
 90ca5a0:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 90ca5a4:	008243b4 	movhi	r2,2318
 90ca5a8:	10b84a04 	addi	r2,r2,-7896
 90ca5ac:	10800d17 	ldw	r2,52(r2)
 90ca5b0:	10c00044 	addi	r3,r2,1
 90ca5b4:	008243b4 	movhi	r2,2318
 90ca5b8:	10b84a04 	addi	r2,r2,-7896
 90ca5bc:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 90ca5c0:	e0fffd17 	ldw	r3,-12(fp)
 90ca5c4:	e0bffb17 	ldw	r2,-20(fp)
 90ca5c8:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 90ca5cc:	e0bffd17 	ldw	r2,-12(fp)
 90ca5d0:	10c00317 	ldw	r3,12(r2)
 90ca5d4:	e0bffa17 	ldw	r2,-24(fp)
 90ca5d8:	10800003 	ldbu	r2,0(r2)
 90ca5dc:	10803fcc 	andi	r2,r2,255
 90ca5e0:	108003cc 	andi	r2,r2,15
 90ca5e4:	1085883a 	add	r2,r2,r2
 90ca5e8:	1085883a 	add	r2,r2,r2
 90ca5ec:	1887883a 	add	r3,r3,r2
 90ca5f0:	e0bffd17 	ldw	r2,-12(fp)
 90ca5f4:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 90ca5f8:	e0fffd17 	ldw	r3,-12(fp)
 90ca5fc:	e0bffc17 	ldw	r2,-16(fp)
 90ca600:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 90ca604:	01000044 	movi	r4,1
 90ca608:	e17ffd17 	ldw	r5,-12(fp)
 90ca60c:	90be8c40 	call	90be8c4 <ip_write>
 90ca610:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 90ca614:	e0bff417 	ldw	r2,-48(fp)
 90ca618:	1004403a 	cmpge	r2,r2,zero
 90ca61c:	1000091e 	bne	r2,zero,90ca644 <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 90ca620:	00824374 	movhi	r2,2317
 90ca624:	108f0904 	addi	r2,r2,15396
 90ca628:	10800017 	ldw	r2,0(r2)
 90ca62c:	1081000c 	andi	r2,r2,1024
 90ca630:	1005003a 	cmpeq	r2,r2,zero
 90ca634:	1000031e 	bne	r2,zero,90ca644 <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 90ca638:	01024374 	movhi	r4,2317
 90ca63c:	2105da04 	addi	r4,r4,5992
 90ca640:	90836b80 	call	90836b8 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 90ca644:	e03fff15 	stw	zero,-4(fp)
 90ca648:	00019f06 	br	90cacc8 <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 90ca64c:	008243b4 	movhi	r2,2318
 90ca650:	10b84a04 	addi	r2,r2,-7896
 90ca654:	10800817 	ldw	r2,32(r2)
 90ca658:	10c00044 	addi	r3,r2,1
 90ca65c:	008243b4 	movhi	r2,2318
 90ca660:	10b84a04 	addi	r2,r2,-7896
 90ca664:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 90ca668:	e13ffd17 	ldw	r4,-12(fp)
 90ca66c:	90c33100 	call	90c3310 <ip_raw_input>
 90ca670:	e0bfff15 	stw	r2,-4(fp)
 90ca674:	00019406 	br	90cacc8 <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 90ca678:	008243b4 	movhi	r2,2318
 90ca67c:	10b84a04 	addi	r2,r2,-7896
 90ca680:	10800217 	ldw	r2,8(r2)
 90ca684:	10c00044 	addi	r3,r2,1
 90ca688:	008243b4 	movhi	r2,2318
 90ca68c:	10b84a04 	addi	r2,r2,-7896
 90ca690:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 90ca694:	e0bff917 	ldw	r2,-28(fp)
 90ca698:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90ca69c:	00824374 	movhi	r2,2317
 90ca6a0:	108f0904 	addi	r2,r2,15396
 90ca6a4:	10800017 	ldw	r2,0(r2)
 90ca6a8:	1081000c 	andi	r2,r2,1024
 90ca6ac:	1005003a 	cmpeq	r2,r2,zero
 90ca6b0:	1000291e 	bne	r2,zero,90ca758 <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 90ca6b4:	01024374 	movhi	r4,2317
 90ca6b8:	2105df04 	addi	r4,r4,6012
 90ca6bc:	90833900 	call	9083390 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 90ca6c0:	e0bff617 	ldw	r2,-40(fp)
 90ca6c4:	10800043 	ldbu	r2,1(r2)
 90ca6c8:	11403fcc 	andi	r5,r2,255
 90ca6cc:	2940201c 	xori	r5,r5,128
 90ca6d0:	297fe004 	addi	r5,r5,-128
 90ca6d4:	e0bff617 	ldw	r2,-40(fp)
 90ca6d8:	10800617 	ldw	r2,24(r2)
 90ca6dc:	11803fcc 	andi	r6,r2,255
 90ca6e0:	e0bff617 	ldw	r2,-40(fp)
 90ca6e4:	10800617 	ldw	r2,24(r2)
 90ca6e8:	1004d23a 	srli	r2,r2,8
 90ca6ec:	11c03fcc 	andi	r7,r2,255
 90ca6f0:	e0bff617 	ldw	r2,-40(fp)
 90ca6f4:	10800617 	ldw	r2,24(r2)
 90ca6f8:	1004d43a 	srli	r2,r2,16
 90ca6fc:	10c03fcc 	andi	r3,r2,255
 90ca700:	e0bff617 	ldw	r2,-40(fp)
 90ca704:	10800617 	ldw	r2,24(r2)
 90ca708:	1004d63a 	srli	r2,r2,24
 90ca70c:	d8c00015 	stw	r3,0(sp)
 90ca710:	d8800115 	stw	r2,4(sp)
 90ca714:	01024374 	movhi	r4,2317
 90ca718:	2105e804 	addi	r4,r4,6048
 90ca71c:	90833900 	call	9083390 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90ca720:	e0bffb17 	ldw	r2,-20(fp)
 90ca724:	11403fcc 	andi	r5,r2,255
 90ca728:	e0bffb17 	ldw	r2,-20(fp)
 90ca72c:	1004d23a 	srli	r2,r2,8
 90ca730:	11803fcc 	andi	r6,r2,255
 90ca734:	e0bffb17 	ldw	r2,-20(fp)
 90ca738:	1004d43a 	srli	r2,r2,16
 90ca73c:	11c03fcc 	andi	r7,r2,255
 90ca740:	e0bffb17 	ldw	r2,-20(fp)
 90ca744:	1004d63a 	srli	r2,r2,24
 90ca748:	d8800015 	stw	r2,0(sp)
 90ca74c:	01024374 	movhi	r4,2317
 90ca750:	2105ed04 	addi	r4,r4,6068
 90ca754:	90833900 	call	9083390 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 90ca758:	e13ffd17 	ldw	r4,-12(fp)
 90ca75c:	e17ff617 	ldw	r5,-40(fp)
 90ca760:	90cb36c0 	call	90cb36c <icmp_du>
      break;
 90ca764:	00015606 	br	90cacc0 <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 90ca768:	008243b4 	movhi	r2,2318
 90ca76c:	10b84a04 	addi	r2,r2,-7896
 90ca770:	10800517 	ldw	r2,20(r2)
 90ca774:	10c00044 	addi	r3,r2,1
 90ca778:	008243b4 	movhi	r2,2318
 90ca77c:	10b84a04 	addi	r2,r2,-7896
 90ca780:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90ca784:	00824374 	movhi	r2,2317
 90ca788:	108f0904 	addi	r2,r2,15396
 90ca78c:	10800017 	ldw	r2,0(r2)
 90ca790:	1081000c 	andi	r2,r2,1024
 90ca794:	1005003a 	cmpeq	r2,r2,zero
 90ca798:	1000161e 	bne	r2,zero,90ca7f4 <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 90ca79c:	e0bffb17 	ldw	r2,-20(fp)
 90ca7a0:	11403fcc 	andi	r5,r2,255
 90ca7a4:	e0bffb17 	ldw	r2,-20(fp)
 90ca7a8:	1004d23a 	srli	r2,r2,8
 90ca7ac:	11803fcc 	andi	r6,r2,255
 90ca7b0:	e0bffb17 	ldw	r2,-20(fp)
 90ca7b4:	1004d43a 	srli	r2,r2,16
 90ca7b8:	11c03fcc 	andi	r7,r2,255
 90ca7bc:	e0bffb17 	ldw	r2,-20(fp)
 90ca7c0:	1004d63a 	srli	r2,r2,24
 90ca7c4:	d8800015 	stw	r2,0(sp)
 90ca7c8:	01024374 	movhi	r4,2317
 90ca7cc:	2105f204 	addi	r4,r4,6088
 90ca7d0:	90833900 	call	9083390 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90ca7d4:	00824374 	movhi	r2,2317
 90ca7d8:	108f0904 	addi	r2,r2,15396
 90ca7dc:	10800017 	ldw	r2,0(r2)
 90ca7e0:	1080008c 	andi	r2,r2,2
 90ca7e4:	1005003a 	cmpeq	r2,r2,zero
 90ca7e8:	1000021e 	bne	r2,zero,90ca7f4 <icmprcv+0x740>
 90ca7ec:	e13ffd17 	ldw	r4,-12(fp)
 90ca7f0:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90ca7f4:	01000084 	movi	r4,2
 90ca7f8:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90ca7fc:	e13ffd17 	ldw	r4,-12(fp)
 90ca800:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ca804:	01000084 	movi	r4,2
 90ca808:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      break;
 90ca80c:	00012c06 	br	90cacc0 <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 90ca810:	008243b4 	movhi	r2,2318
 90ca814:	10b84a04 	addi	r2,r2,-7896
 90ca818:	10800617 	ldw	r2,24(r2)
 90ca81c:	10c00044 	addi	r3,r2,1
 90ca820:	008243b4 	movhi	r2,2318
 90ca824:	10b84a04 	addi	r2,r2,-7896
 90ca828:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 90ca82c:	e0bff917 	ldw	r2,-28(fp)
 90ca830:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90ca834:	00824374 	movhi	r2,2317
 90ca838:	108f0904 	addi	r2,r2,15396
 90ca83c:	10800017 	ldw	r2,0(r2)
 90ca840:	1081000c 	andi	r2,r2,1024
 90ca844:	1005003a 	cmpeq	r2,r2,zero
 90ca848:	1000241e 	bne	r2,zero,90ca8dc <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 90ca84c:	e0bff717 	ldw	r2,-36(fp)
 90ca850:	10800617 	ldw	r2,24(r2)
 90ca854:	11403fcc 	andi	r5,r2,255
 90ca858:	e0bff717 	ldw	r2,-36(fp)
 90ca85c:	10800617 	ldw	r2,24(r2)
 90ca860:	1004d23a 	srli	r2,r2,8
 90ca864:	11803fcc 	andi	r6,r2,255
 90ca868:	e0bff717 	ldw	r2,-36(fp)
 90ca86c:	10800617 	ldw	r2,24(r2)
 90ca870:	1004d43a 	srli	r2,r2,16
 90ca874:	11c03fcc 	andi	r7,r2,255
 90ca878:	e0bff717 	ldw	r2,-36(fp)
 90ca87c:	10800617 	ldw	r2,24(r2)
 90ca880:	1004d63a 	srli	r2,r2,24
 90ca884:	d8800015 	stw	r2,0(sp)
 90ca888:	01024374 	movhi	r4,2317
 90ca88c:	2105fc04 	addi	r4,r4,6128
 90ca890:	90833900 	call	9083390 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 90ca894:	e0bff717 	ldw	r2,-36(fp)
 90ca898:	10800117 	ldw	r2,4(r2)
 90ca89c:	11403fcc 	andi	r5,r2,255
 90ca8a0:	e0bff717 	ldw	r2,-36(fp)
 90ca8a4:	10800117 	ldw	r2,4(r2)
 90ca8a8:	1004d23a 	srli	r2,r2,8
 90ca8ac:	11803fcc 	andi	r6,r2,255
 90ca8b0:	e0bff717 	ldw	r2,-36(fp)
 90ca8b4:	10800117 	ldw	r2,4(r2)
 90ca8b8:	1004d43a 	srli	r2,r2,16
 90ca8bc:	11c03fcc 	andi	r7,r2,255
 90ca8c0:	e0bff717 	ldw	r2,-36(fp)
 90ca8c4:	10800117 	ldw	r2,4(r2)
 90ca8c8:	1004d63a 	srli	r2,r2,24
 90ca8cc:	d8800015 	stw	r2,0(sp)
 90ca8d0:	01024374 	movhi	r4,2317
 90ca8d4:	21060604 	addi	r4,r4,6168
 90ca8d8:	90833900 	call	9083390 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 90ca8dc:	e0bff717 	ldw	r2,-36(fp)
 90ca8e0:	14000617 	ldw	r16,24(r2)
 90ca8e4:	e0bff717 	ldw	r2,-36(fp)
 90ca8e8:	14400117 	ldw	r17,4(r2)
 90ca8ec:	e0bffd17 	ldw	r2,-12(fp)
 90ca8f0:	11000617 	ldw	r4,24(r2)
 90ca8f4:	90a31080 	call	90a3108 <if_netnumber>
 90ca8f8:	100f883a 	mov	r7,r2
 90ca8fc:	00800104 	movi	r2,4
 90ca900:	d8800015 	stw	r2,0(sp)
 90ca904:	8009883a 	mov	r4,r16
 90ca908:	017fffc4 	movi	r5,-1
 90ca90c:	880d883a 	mov	r6,r17
 90ca910:	90c38340 	call	90c3834 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90ca914:	01000084 	movi	r4,2
 90ca918:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90ca91c:	e13ffd17 	ldw	r4,-12(fp)
 90ca920:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90ca924:	01000084 	movi	r4,2
 90ca928:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      break;
 90ca92c:	0000e406 	br	90cacc0 <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 90ca930:	008243b4 	movhi	r2,2318
 90ca934:	10b84a04 	addi	r2,r2,-7896
 90ca938:	10800317 	ldw	r2,12(r2)
 90ca93c:	10c00044 	addi	r3,r2,1
 90ca940:	008243b4 	movhi	r2,2318
 90ca944:	10b84a04 	addi	r2,r2,-7896
 90ca948:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90ca94c:	00824374 	movhi	r2,2317
 90ca950:	108f0904 	addi	r2,r2,15396
 90ca954:	10800017 	ldw	r2,0(r2)
 90ca958:	1081000c 	andi	r2,r2,1024
 90ca95c:	1005003a 	cmpeq	r2,r2,zero
 90ca960:	10002e1e 	bne	r2,zero,90caa1c <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 90ca964:	e0bff917 	ldw	r2,-28(fp)
 90ca968:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 90ca96c:	e0bffd17 	ldw	r2,-12(fp)
 90ca970:	10800717 	ldw	r2,28(r2)
 90ca974:	11403fcc 	andi	r5,r2,255
 90ca978:	e0bffd17 	ldw	r2,-12(fp)
 90ca97c:	10800717 	ldw	r2,28(r2)
 90ca980:	1004d23a 	srli	r2,r2,8
 90ca984:	11803fcc 	andi	r6,r2,255
 90ca988:	e0bffd17 	ldw	r2,-12(fp)
 90ca98c:	10800717 	ldw	r2,28(r2)
 90ca990:	1004d43a 	srli	r2,r2,16
 90ca994:	11c03fcc 	andi	r7,r2,255
 90ca998:	e0bffd17 	ldw	r2,-12(fp)
 90ca99c:	10800717 	ldw	r2,28(r2)
 90ca9a0:	1004d63a 	srli	r2,r2,24
 90ca9a4:	d8800015 	stw	r2,0(sp)
 90ca9a8:	01024374 	movhi	r4,2317
 90ca9ac:	21060a04 	addi	r4,r4,6184
 90ca9b0:	90833900 	call	9083390 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 90ca9b4:	e0bff317 	ldw	r2,-52(fp)
 90ca9b8:	10800617 	ldw	r2,24(r2)
 90ca9bc:	11403fcc 	andi	r5,r2,255
 90ca9c0:	e0bff317 	ldw	r2,-52(fp)
 90ca9c4:	10800617 	ldw	r2,24(r2)
 90ca9c8:	1004d23a 	srli	r2,r2,8
 90ca9cc:	11803fcc 	andi	r6,r2,255
 90ca9d0:	e0bff317 	ldw	r2,-52(fp)
 90ca9d4:	10800617 	ldw	r2,24(r2)
 90ca9d8:	1004d43a 	srli	r2,r2,16
 90ca9dc:	11c03fcc 	andi	r7,r2,255
 90ca9e0:	e0bff317 	ldw	r2,-52(fp)
 90ca9e4:	10800617 	ldw	r2,24(r2)
 90ca9e8:	1004d63a 	srli	r2,r2,24
 90ca9ec:	d8800015 	stw	r2,0(sp)
 90ca9f0:	01024374 	movhi	r4,2317
 90ca9f4:	21061304 	addi	r4,r4,6220
 90ca9f8:	90833900 	call	9083390 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90ca9fc:	00824374 	movhi	r2,2317
 90caa00:	108f0904 	addi	r2,r2,15396
 90caa04:	10800017 	ldw	r2,0(r2)
 90caa08:	1080008c 	andi	r2,r2,2
 90caa0c:	1005003a 	cmpeq	r2,r2,zero
 90caa10:	1000021e 	bne	r2,zero,90caa1c <icmprcv+0x968>
 90caa14:	e13ffd17 	ldw	r4,-12(fp)
 90caa18:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90caa1c:	01000084 	movi	r4,2
 90caa20:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90caa24:	e13ffd17 	ldw	r4,-12(fp)
 90caa28:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90caa2c:	01000084 	movi	r4,2
 90caa30:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      break;
 90caa34:	0000a206 	br	90cacc0 <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 90caa38:	008243b4 	movhi	r2,2318
 90caa3c:	10b84a04 	addi	r2,r2,-7896
 90caa40:	10800417 	ldw	r2,16(r2)
 90caa44:	10c00044 	addi	r3,r2,1
 90caa48:	008243b4 	movhi	r2,2318
 90caa4c:	10b84a04 	addi	r2,r2,-7896
 90caa50:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90caa54:	00824374 	movhi	r2,2317
 90caa58:	108f0904 	addi	r2,r2,15396
 90caa5c:	10800017 	ldw	r2,0(r2)
 90caa60:	1081000c 	andi	r2,r2,1024
 90caa64:	1005003a 	cmpeq	r2,r2,zero
 90caa68:	1000031e 	bne	r2,zero,90caa78 <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 90caa6c:	01024374 	movhi	r4,2317
 90caa70:	21061804 	addi	r4,r4,6240
 90caa74:	90836b80 	call	90836b8 <puts>
      if (NDEBUG & DUMP)
 90caa78:	00824374 	movhi	r2,2317
 90caa7c:	108f0904 	addi	r2,r2,15396
 90caa80:	10800017 	ldw	r2,0(r2)
 90caa84:	1080008c 	andi	r2,r2,2
 90caa88:	1005003a 	cmpeq	r2,r2,zero
 90caa8c:	1000021e 	bne	r2,zero,90caa98 <icmprcv+0x9e4>
      {
         ip_dump(p);
 90caa90:	e13ffd17 	ldw	r4,-12(fp)
 90caa94:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90caa98:	01000084 	movi	r4,2
 90caa9c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90caaa0:	e13ffd17 	ldw	r4,-12(fp)
 90caaa4:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90caaa8:	01000084 	movi	r4,2
 90caaac:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      break;
 90caab0:	00008306 	br	90cacc0 <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 90caab4:	008243b4 	movhi	r2,2318
 90caab8:	10b84a04 	addi	r2,r2,-7896
 90caabc:	10800917 	ldw	r2,36(r2)
 90caac0:	10c00044 	addi	r3,r2,1
 90caac4:	008243b4 	movhi	r2,2318
 90caac8:	10b84a04 	addi	r2,r2,-7896
 90caacc:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90caad0:	00824374 	movhi	r2,2317
 90caad4:	108f0904 	addi	r2,r2,15396
 90caad8:	10800017 	ldw	r2,0(r2)
 90caadc:	1081000c 	andi	r2,r2,1024
 90caae0:	1005003a 	cmpeq	r2,r2,zero
 90caae4:	1000031e 	bne	r2,zero,90caaf4 <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 90caae8:	01024374 	movhi	r4,2317
 90caaec:	21062004 	addi	r4,r4,6272
 90caaf0:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 90caaf4:	e0fff917 	ldw	r3,-28(fp)
 90caaf8:	00800384 	movi	r2,14
 90caafc:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 90cab00:	e0bff917 	ldw	r2,-28(fp)
 90cab04:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 90cab08:	e13ff917 	ldw	r4,-28(fp)
 90cab0c:	01400284 	movi	r5,10
 90cab10:	90a4ef40 	call	90a4ef4 <cksum>
 90cab14:	0084303a 	nor	r2,zero,r2
 90cab18:	1007883a 	mov	r3,r2
 90cab1c:	e0bff917 	ldw	r2,-28(fp)
 90cab20:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 90cab24:	e0bffa17 	ldw	r2,-24(fp)
 90cab28:	10c00417 	ldw	r3,16(r2)
 90cab2c:	e0bffa17 	ldw	r2,-24(fp)
 90cab30:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 90cab34:	e0fffa17 	ldw	r3,-24(fp)
 90cab38:	e0bffb17 	ldw	r2,-20(fp)
 90cab3c:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 90cab40:	008243b4 	movhi	r2,2318
 90cab44:	10b84a04 	addi	r2,r2,-7896
 90cab48:	10800d17 	ldw	r2,52(r2)
 90cab4c:	10c00044 	addi	r3,r2,1
 90cab50:	008243b4 	movhi	r2,2318
 90cab54:	10b84a04 	addi	r2,r2,-7896
 90cab58:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 90cab5c:	008243b4 	movhi	r2,2318
 90cab60:	10b84a04 	addi	r2,r2,-7896
 90cab64:	10801717 	ldw	r2,92(r2)
 90cab68:	10c00044 	addi	r3,r2,1
 90cab6c:	008243b4 	movhi	r2,2318
 90cab70:	10b84a04 	addi	r2,r2,-7896
 90cab74:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 90cab78:	e0bffd17 	ldw	r2,-12(fp)
 90cab7c:	10c00317 	ldw	r3,12(r2)
 90cab80:	e0bffa17 	ldw	r2,-24(fp)
 90cab84:	10800003 	ldbu	r2,0(r2)
 90cab88:	10803fcc 	andi	r2,r2,255
 90cab8c:	108003cc 	andi	r2,r2,15
 90cab90:	1085883a 	add	r2,r2,r2
 90cab94:	1085883a 	add	r2,r2,r2
 90cab98:	1887883a 	add	r3,r3,r2
 90cab9c:	e0bffd17 	ldw	r2,-12(fp)
 90caba0:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 90caba4:	e0fffd17 	ldw	r3,-12(fp)
 90caba8:	00800504 	movi	r2,20
 90cabac:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 90cabb0:	e0fffd17 	ldw	r3,-12(fp)
 90cabb4:	e0bffb17 	ldw	r2,-20(fp)
 90cabb8:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 90cabbc:	01000044 	movi	r4,1
 90cabc0:	e17ffd17 	ldw	r5,-12(fp)
 90cabc4:	90be8c40 	call	90be8c4 <ip_write>
 90cabc8:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 90cabcc:	e0bff417 	ldw	r2,-48(fp)
 90cabd0:	1004403a 	cmpge	r2,r2,zero
 90cabd4:	1000091e 	bne	r2,zero,90cabfc <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 90cabd8:	00824374 	movhi	r2,2317
 90cabdc:	108f0904 	addi	r2,r2,15396
 90cabe0:	10800017 	ldw	r2,0(r2)
 90cabe4:	1081000c 	andi	r2,r2,1024
 90cabe8:	1005003a 	cmpeq	r2,r2,zero
 90cabec:	1000031e 	bne	r2,zero,90cabfc <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 90cabf0:	01024374 	movhi	r4,2317
 90cabf4:	21062704 	addi	r4,r4,6300
 90cabf8:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 90cabfc:	e03fff15 	stw	zero,-4(fp)
 90cac00:	00003106 	br	90cacc8 <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90cac04:	00824374 	movhi	r2,2317
 90cac08:	108f0904 	addi	r2,r2,15396
 90cac0c:	10800017 	ldw	r2,0(r2)
 90cac10:	1081000c 	andi	r2,r2,1024
 90cac14:	1005003a 	cmpeq	r2,r2,zero
 90cac18:	1000031e 	bne	r2,zero,90cac28 <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 90cac1c:	01024374 	movhi	r4,2317
 90cac20:	21063004 	addi	r4,r4,6336
 90cac24:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90cac28:	01000084 	movi	r4,2
 90cac2c:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90cac30:	e13ffd17 	ldw	r4,-12(fp)
 90cac34:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90cac38:	01000084 	movi	r4,2
 90cac3c:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      break;
 90cac40:	00001f06 	br	90cacc0 <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 90cac44:	00824374 	movhi	r2,2317
 90cac48:	108f0904 	addi	r2,r2,15396
 90cac4c:	10800017 	ldw	r2,0(r2)
 90cac50:	1081000c 	andi	r2,r2,1024
 90cac54:	1005003a 	cmpeq	r2,r2,zero
 90cac58:	1000101e 	bne	r2,zero,90cac9c <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 90cac5c:	e0bff917 	ldw	r2,-28(fp)
 90cac60:	10800003 	ldbu	r2,0(r2)
 90cac64:	11403fcc 	andi	r5,r2,255
 90cac68:	2940201c 	xori	r5,r5,128
 90cac6c:	297fe004 	addi	r5,r5,-128
 90cac70:	01024374 	movhi	r4,2317
 90cac74:	21063604 	addi	r4,r4,6360
 90cac78:	90833900 	call	9083390 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 90cac7c:	00824374 	movhi	r2,2317
 90cac80:	108f0904 	addi	r2,r2,15396
 90cac84:	10800017 	ldw	r2,0(r2)
 90cac88:	1080008c 	andi	r2,r2,2
 90cac8c:	1005003a 	cmpeq	r2,r2,zero
 90cac90:	1000021e 	bne	r2,zero,90cac9c <icmprcv+0xbe8>
 90cac94:	e13ffd17 	ldw	r4,-12(fp)
 90cac98:	90bfaf40 	call	90bfaf4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 90cac9c:	01000084 	movi	r4,2
 90caca0:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
      pk_free(p);
 90caca4:	e13ffd17 	ldw	r4,-12(fp)
 90caca8:	90a9bc80 	call	90a9bc8 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90cacac:	01000084 	movi	r4,2
 90cacb0:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 90cacb4:	00800084 	movi	r2,2
 90cacb8:	e0bfff15 	stw	r2,-4(fp)
 90cacbc:	00000206 	br	90cacc8 <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 90cacc0:	00c00084 	movi	r3,2
 90cacc4:	e0ffff15 	stw	r3,-4(fp)
 90cacc8:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 90caccc:	e037883a 	mov	sp,fp
 90cacd0:	dfc00317 	ldw	ra,12(sp)
 90cacd4:	df000217 	ldw	fp,8(sp)
 90cacd8:	dc400117 	ldw	r17,4(sp)
 90cacdc:	dc000017 	ldw	r16,0(sp)
 90cace0:	dec00404 	addi	sp,sp,16
 90cace4:	f800283a 	ret

090cace8 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 90cace8:	defff404 	addi	sp,sp,-48
 90cacec:	dfc00b15 	stw	ra,44(sp)
 90cacf0:	df000a15 	stw	fp,40(sp)
 90cacf4:	df000a04 	addi	fp,sp,40
 90cacf8:	e13ffc15 	stw	r4,-16(fp)
 90cacfc:	e17ffd15 	stw	r5,-12(fp)
 90cad00:	e1bffe15 	stw	r6,-8(fp)
 90cad04:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 90cad08:	00824374 	movhi	r2,2317
 90cad0c:	108f0904 	addi	r2,r2,15396
 90cad10:	10800017 	ldw	r2,0(r2)
 90cad14:	1080040c 	andi	r2,r2,16
 90cad18:	1005003a 	cmpeq	r2,r2,zero
 90cad1c:	1000171e 	bne	r2,zero,90cad7c <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 90cad20:	e0bfff17 	ldw	r2,-4(fp)
 90cad24:	10803fcc 	andi	r2,r2,255
 90cad28:	00c24374 	movhi	r3,2317
 90cad2c:	18ce7f04 	addi	r3,r3,14844
 90cad30:	1085883a 	add	r2,r2,r2
 90cad34:	1085883a 	add	r2,r2,r2
 90cad38:	10c5883a 	add	r2,r2,r3
 90cad3c:	11400017 	ldw	r5,0(r2)
 90cad40:	e0bffc17 	ldw	r2,-16(fp)
 90cad44:	11803fcc 	andi	r6,r2,255
 90cad48:	e0bffc17 	ldw	r2,-16(fp)
 90cad4c:	1004d23a 	srli	r2,r2,8
 90cad50:	11c03fcc 	andi	r7,r2,255
 90cad54:	e0bffc17 	ldw	r2,-16(fp)
 90cad58:	1004d43a 	srli	r2,r2,16
 90cad5c:	10c03fcc 	andi	r3,r2,255
 90cad60:	e0bffc17 	ldw	r2,-16(fp)
 90cad64:	1004d63a 	srli	r2,r2,24
 90cad68:	d8c00015 	stw	r3,0(sp)
 90cad6c:	d8800115 	stw	r2,4(sp)
 90cad70:	01024374 	movhi	r4,2317
 90cad74:	21065004 	addi	r4,r4,6464
 90cad78:	90833900 	call	9083390 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 90cad7c:	01000084 	movi	r4,2
 90cad80:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 90cad84:	01008504 	movi	r4,532
 90cad88:	90a98340 	call	90a9834 <pk_alloc>
 90cad8c:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90cad90:	01000084 	movi	r4,2
 90cad94:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 90cad98:	e0bffb17 	ldw	r2,-20(fp)
 90cad9c:	1004c03a 	cmpne	r2,r2,zero
 90cada0:	1000111e 	bne	r2,zero,90cade8 <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 90cada4:	00824374 	movhi	r2,2317
 90cada8:	108f0904 	addi	r2,r2,15396
 90cadac:	10800017 	ldw	r2,0(r2)
 90cadb0:	1080800c 	andi	r2,r2,512
 90cadb4:	1005003a 	cmpeq	r2,r2,zero
 90cadb8:	1000031e 	bne	r2,zero,90cadc8 <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 90cadbc:	01024374 	movhi	r4,2317
 90cadc0:	21065d04 	addi	r4,r4,6516
 90cadc4:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 90cadc8:	008243b4 	movhi	r2,2318
 90cadcc:	10b84a04 	addi	r2,r2,-7896
 90cadd0:	10800e17 	ldw	r2,56(r2)
 90cadd4:	10c00044 	addi	r3,r2,1
 90cadd8:	008243b4 	movhi	r2,2318
 90caddc:	10b84a04 	addi	r2,r2,-7896
 90cade0:	10c00e15 	stw	r3,56(r2)
      return;
 90cade4:	00008f06 	br	90cb024 <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 90cade8:	e0bffb17 	ldw	r2,-20(fp)
 90cadec:	10800317 	ldw	r2,12(r2)
 90cadf0:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 90cadf4:	e0fff917 	ldw	r3,-28(fp)
 90cadf8:	e0bffd17 	ldw	r2,-12(fp)
 90cadfc:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 90cae00:	e0fff917 	ldw	r3,-28(fp)
 90cae04:	e0bffc17 	ldw	r2,-16(fp)
 90cae08:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 90cae0c:	e0bffb17 	ldw	r2,-20(fp)
 90cae10:	10800317 	ldw	r2,12(r2)
 90cae14:	10c00504 	addi	r3,r2,20
 90cae18:	e0bffb17 	ldw	r2,-20(fp)
 90cae1c:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 90cae20:	e0bffb17 	ldw	r2,-20(fp)
 90cae24:	10800417 	ldw	r2,16(r2)
 90cae28:	10fffb04 	addi	r3,r2,-20
 90cae2c:	e0bffb17 	ldw	r2,-20(fp)
 90cae30:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 90cae34:	e0fffb17 	ldw	r3,-20(fp)
 90cae38:	e0800217 	ldw	r2,8(fp)
 90cae3c:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 90cae40:	e0bffb17 	ldw	r2,-20(fp)
 90cae44:	10800317 	ldw	r2,12(r2)
 90cae48:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 90cae4c:	e0bfff17 	ldw	r2,-4(fp)
 90cae50:	10bfc00c 	andi	r2,r2,65280
 90cae54:	1005003a 	cmpeq	r2,r2,zero
 90cae58:	1000061e 	bne	r2,zero,90cae74 <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 90cae5c:	e0bfff17 	ldw	r2,-4(fp)
 90cae60:	1004d23a 	srli	r2,r2,8
 90cae64:	1007883a 	mov	r3,r2
 90cae68:	e0bffa17 	ldw	r2,-24(fp)
 90cae6c:	10c00005 	stb	r3,0(r2)
 90cae70:	00000306 	br	90cae80 <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 90cae74:	e0fffa17 	ldw	r3,-24(fp)
 90cae78:	008000c4 	movi	r2,3
 90cae7c:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 90cae80:	e0bfff17 	ldw	r2,-4(fp)
 90cae84:	1007883a 	mov	r3,r2
 90cae88:	e0bffa17 	ldw	r2,-24(fp)
 90cae8c:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 90cae90:	e0bffa17 	ldw	r2,-24(fp)
 90cae94:	1000018d 	sth	zero,6(r2)
 90cae98:	e0bffa17 	ldw	r2,-24(fp)
 90cae9c:	10c0018b 	ldhu	r3,6(r2)
 90caea0:	e0bffa17 	ldw	r2,-24(fp)
 90caea4:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 90caea8:	e0bfff17 	ldw	r2,-4(fp)
 90caeac:	10803fcc 	andi	r2,r2,255
 90caeb0:	10800118 	cmpnei	r2,r2,4
 90caeb4:	1000151e 	bne	r2,zero,90caf0c <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 90caeb8:	e0800217 	ldw	r2,8(fp)
 90caebc:	10c00917 	ldw	r3,36(r2)
 90caec0:	e0800217 	ldw	r2,8(fp)
 90caec4:	10800817 	ldw	r2,32(r2)
 90caec8:	1885c83a 	sub	r2,r3,r2
 90caecc:	1005d23a 	srai	r2,r2,8
 90caed0:	10803fcc 	andi	r2,r2,255
 90caed4:	1009883a 	mov	r4,r2
 90caed8:	e0800217 	ldw	r2,8(fp)
 90caedc:	10c00917 	ldw	r3,36(r2)
 90caee0:	e0800217 	ldw	r2,8(fp)
 90caee4:	10800817 	ldw	r2,32(r2)
 90caee8:	1885c83a 	sub	r2,r3,r2
 90caeec:	1004923a 	slli	r2,r2,8
 90caef0:	1007883a 	mov	r3,r2
 90caef4:	00bfc004 	movi	r2,-256
 90caef8:	1884703a 	and	r2,r3,r2
 90caefc:	2084b03a 	or	r2,r4,r2
 90caf00:	1007883a 	mov	r3,r2
 90caf04:	e0bffa17 	ldw	r2,-24(fp)
 90caf08:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 90caf0c:	e0bffa17 	ldw	r2,-24(fp)
 90caf10:	11000204 	addi	r4,r2,8
 90caf14:	e0fffe17 	ldw	r3,-8(fp)
 90caf18:	18800017 	ldw	r2,0(r3)
 90caf1c:	20800015 	stw	r2,0(r4)
 90caf20:	18800117 	ldw	r2,4(r3)
 90caf24:	20800115 	stw	r2,4(r4)
 90caf28:	18800217 	ldw	r2,8(r3)
 90caf2c:	20800215 	stw	r2,8(r4)
 90caf30:	18800317 	ldw	r2,12(r3)
 90caf34:	20800315 	stw	r2,12(r4)
 90caf38:	18800417 	ldw	r2,16(r3)
 90caf3c:	20800415 	stw	r2,16(r4)
 90caf40:	18800517 	ldw	r2,20(r3)
 90caf44:	20800515 	stw	r2,20(r4)
 90caf48:	18800617 	ldw	r2,24(r3)
 90caf4c:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 90caf50:	e0bffa17 	ldw	r2,-24(fp)
 90caf54:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 90caf58:	e13ffa17 	ldw	r4,-24(fp)
 90caf5c:	01400484 	movi	r5,18
 90caf60:	90a4ef40 	call	90a4ef4 <cksum>
 90caf64:	0084303a 	nor	r2,zero,r2
 90caf68:	1007883a 	mov	r3,r2
 90caf6c:	e0bffa17 	ldw	r2,-24(fp)
 90caf70:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 90caf74:	e0fffb17 	ldw	r3,-20(fp)
 90caf78:	00800904 	movi	r2,36
 90caf7c:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 90caf80:	e0fffb17 	ldw	r3,-20(fp)
 90caf84:	e0bffc17 	ldw	r2,-16(fp)
 90caf88:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 90caf8c:	01000044 	movi	r4,1
 90caf90:	e17ffb17 	ldw	r5,-20(fp)
 90caf94:	90be8c40 	call	90be8c4 <ip_write>
 90caf98:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 90caf9c:	e0bff817 	ldw	r2,-32(fp)
 90cafa0:	1004403a 	cmpge	r2,r2,zero
 90cafa4:	1000111e 	bne	r2,zero,90cafec <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 90cafa8:	008243b4 	movhi	r2,2318
 90cafac:	10b84a04 	addi	r2,r2,-7896
 90cafb0:	10800e17 	ldw	r2,56(r2)
 90cafb4:	10c00044 	addi	r3,r2,1
 90cafb8:	008243b4 	movhi	r2,2318
 90cafbc:	10b84a04 	addi	r2,r2,-7896
 90cafc0:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 90cafc4:	00824374 	movhi	r2,2317
 90cafc8:	108f0904 	addi	r2,r2,15396
 90cafcc:	10800017 	ldw	r2,0(r2)
 90cafd0:	1080860c 	andi	r2,r2,536
 90cafd4:	1005003a 	cmpeq	r2,r2,zero
 90cafd8:	1000121e 	bne	r2,zero,90cb024 <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 90cafdc:	01024374 	movhi	r4,2317
 90cafe0:	21066304 	addi	r4,r4,6540
 90cafe4:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG  */
      return;
 90cafe8:	00000e06 	br	90cb024 <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 90cafec:	008243b4 	movhi	r2,2318
 90caff0:	10b84a04 	addi	r2,r2,-7896
 90caff4:	10800d17 	ldw	r2,52(r2)
 90caff8:	10c00044 	addi	r3,r2,1
 90caffc:	008243b4 	movhi	r2,2318
 90cb000:	10b84a04 	addi	r2,r2,-7896
 90cb004:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 90cb008:	008243b4 	movhi	r2,2318
 90cb00c:	10b84a04 	addi	r2,r2,-7896
 90cb010:	10800f17 	ldw	r2,60(r2)
 90cb014:	10c00044 	addi	r3,r2,1
 90cb018:	008243b4 	movhi	r2,2318
 90cb01c:	10b84a04 	addi	r2,r2,-7896
 90cb020:	10c00f15 	stw	r3,60(r2)
   return;
}
 90cb024:	e037883a 	mov	sp,fp
 90cb028:	dfc00117 	ldw	ra,4(sp)
 90cb02c:	df000017 	ldw	fp,0(sp)
 90cb030:	dec00204 	addi	sp,sp,8
 90cb034:	f800283a 	ret

090cb038 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 90cb038:	defff504 	addi	sp,sp,-44
 90cb03c:	dfc00a15 	stw	ra,40(sp)
 90cb040:	df000915 	stw	fp,36(sp)
 90cb044:	df000904 	addi	fp,sp,36
 90cb048:	e13ffe15 	stw	r4,-8(fp)
 90cb04c:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 90cb050:	00824374 	movhi	r2,2317
 90cb054:	108f0904 	addi	r2,r2,15396
 90cb058:	10800017 	ldw	r2,0(r2)
 90cb05c:	1080040c 	andi	r2,r2,16
 90cb060:	1005003a 	cmpeq	r2,r2,zero
 90cb064:	1000301e 	bne	r2,zero,90cb128 <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 90cb068:	e17fff07 	ldb	r5,-4(fp)
 90cb06c:	e0bffe17 	ldw	r2,-8(fp)
 90cb070:	10800317 	ldw	r2,12(r2)
 90cb074:	1004d23a 	srli	r2,r2,8
 90cb078:	10c03fcc 	andi	r3,r2,255
 90cb07c:	e0bffe17 	ldw	r2,-8(fp)
 90cb080:	10800317 	ldw	r2,12(r2)
 90cb084:	1004923a 	slli	r2,r2,8
 90cb088:	10bfc00c 	andi	r2,r2,65280
 90cb08c:	1884b03a 	or	r2,r3,r2
 90cb090:	11803fcc 	andi	r6,r2,255
 90cb094:	e0bffe17 	ldw	r2,-8(fp)
 90cb098:	10800317 	ldw	r2,12(r2)
 90cb09c:	1004d23a 	srli	r2,r2,8
 90cb0a0:	10c03fcc 	andi	r3,r2,255
 90cb0a4:	e0bffe17 	ldw	r2,-8(fp)
 90cb0a8:	10800317 	ldw	r2,12(r2)
 90cb0ac:	1004923a 	slli	r2,r2,8
 90cb0b0:	10bfc00c 	andi	r2,r2,65280
 90cb0b4:	1884b03a 	or	r2,r3,r2
 90cb0b8:	1004d23a 	srli	r2,r2,8
 90cb0bc:	11c03fcc 	andi	r7,r2,255
 90cb0c0:	e0bffe17 	ldw	r2,-8(fp)
 90cb0c4:	10800317 	ldw	r2,12(r2)
 90cb0c8:	1004d23a 	srli	r2,r2,8
 90cb0cc:	10c03fcc 	andi	r3,r2,255
 90cb0d0:	e0bffe17 	ldw	r2,-8(fp)
 90cb0d4:	10800317 	ldw	r2,12(r2)
 90cb0d8:	1004923a 	slli	r2,r2,8
 90cb0dc:	10bfc00c 	andi	r2,r2,65280
 90cb0e0:	1884b03a 	or	r2,r3,r2
 90cb0e4:	1004d43a 	srli	r2,r2,16
 90cb0e8:	11003fcc 	andi	r4,r2,255
 90cb0ec:	e0bffe17 	ldw	r2,-8(fp)
 90cb0f0:	10800317 	ldw	r2,12(r2)
 90cb0f4:	1004d23a 	srli	r2,r2,8
 90cb0f8:	10c03fcc 	andi	r3,r2,255
 90cb0fc:	e0bffe17 	ldw	r2,-8(fp)
 90cb100:	10800317 	ldw	r2,12(r2)
 90cb104:	1004923a 	slli	r2,r2,8
 90cb108:	10bfc00c 	andi	r2,r2,65280
 90cb10c:	1884b03a 	or	r2,r3,r2
 90cb110:	1004d63a 	srli	r2,r2,24
 90cb114:	d9000015 	stw	r4,0(sp)
 90cb118:	d8800115 	stw	r2,4(sp)
 90cb11c:	01024374 	movhi	r4,2317
 90cb120:	21066c04 	addi	r4,r4,6576
 90cb124:	90833900 	call	9083390 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 90cb128:	e0bffe17 	ldw	r2,-8(fp)
 90cb12c:	10800003 	ldbu	r2,0(r2)
 90cb130:	108003cc 	andi	r2,r2,15
 90cb134:	1085883a 	add	r2,r2,r2
 90cb138:	1085883a 	add	r2,r2,r2
 90cb13c:	10800404 	addi	r2,r2,16
 90cb140:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 90cb144:	01000084 	movi	r4,2
 90cb148:	90aa7580 	call	90aa758 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 90cb14c:	e0fff903 	ldbu	r3,-28(fp)
 90cb150:	00824374 	movhi	r2,2317
 90cb154:	108f0704 	addi	r2,r2,15388
 90cb158:	10800017 	ldw	r2,0(r2)
 90cb15c:	1885883a 	add	r2,r3,r2
 90cb160:	11000504 	addi	r4,r2,20
 90cb164:	90a98340 	call	90a9834 <pk_alloc>
 90cb168:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 90cb16c:	01000084 	movi	r4,2
 90cb170:	90aa8180 	call	90aa818 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 90cb174:	e0bffd17 	ldw	r2,-12(fp)
 90cb178:	1004c03a 	cmpne	r2,r2,zero
 90cb17c:	1000111e 	bne	r2,zero,90cb1c4 <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 90cb180:	00824374 	movhi	r2,2317
 90cb184:	108f0904 	addi	r2,r2,15396
 90cb188:	10800017 	ldw	r2,0(r2)
 90cb18c:	1080800c 	andi	r2,r2,512
 90cb190:	1005003a 	cmpeq	r2,r2,zero
 90cb194:	1000031e 	bne	r2,zero,90cb1a4 <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 90cb198:	01024374 	movhi	r4,2317
 90cb19c:	21065d04 	addi	r4,r4,6516
 90cb1a0:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 90cb1a4:	008243b4 	movhi	r2,2318
 90cb1a8:	10b84a04 	addi	r2,r2,-7896
 90cb1ac:	10800e17 	ldw	r2,56(r2)
 90cb1b0:	10c00044 	addi	r3,r2,1
 90cb1b4:	008243b4 	movhi	r2,2318
 90cb1b8:	10b84a04 	addi	r2,r2,-7896
 90cb1bc:	10c00e15 	stw	r3,56(r2)
      return;
 90cb1c0:	00006506 	br	90cb358 <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 90cb1c4:	e0bffd17 	ldw	r2,-12(fp)
 90cb1c8:	10800317 	ldw	r2,12(r2)
 90cb1cc:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 90cb1d0:	e0bffe17 	ldw	r2,-8(fp)
 90cb1d4:	10c00417 	ldw	r3,16(r2)
 90cb1d8:	e0bffb17 	ldw	r2,-20(fp)
 90cb1dc:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 90cb1e0:	e0bffe17 	ldw	r2,-8(fp)
 90cb1e4:	10c00317 	ldw	r3,12(r2)
 90cb1e8:	e0bffb17 	ldw	r2,-20(fp)
 90cb1ec:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 90cb1f0:	e0bffd17 	ldw	r2,-12(fp)
 90cb1f4:	10800317 	ldw	r2,12(r2)
 90cb1f8:	10c00504 	addi	r3,r2,20
 90cb1fc:	e0bffd17 	ldw	r2,-12(fp)
 90cb200:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 90cb204:	e0bffd17 	ldw	r2,-12(fp)
 90cb208:	10800317 	ldw	r2,12(r2)
 90cb20c:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 90cb210:	e0fffc17 	ldw	r3,-16(fp)
 90cb214:	008002c4 	movi	r2,11
 90cb218:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 90cb21c:	e0fffc17 	ldw	r3,-16(fp)
 90cb220:	e0bfff03 	ldbu	r2,-4(fp)
 90cb224:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 90cb228:	e0bffc17 	ldw	r2,-16(fp)
 90cb22c:	1000018d 	sth	zero,6(r2)
 90cb230:	e0bffc17 	ldw	r2,-16(fp)
 90cb234:	10c0018b 	ldhu	r3,6(r2)
 90cb238:	e0bffc17 	ldw	r2,-16(fp)
 90cb23c:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 90cb240:	e0bffc17 	ldw	r2,-16(fp)
 90cb244:	11000204 	addi	r4,r2,8
 90cb248:	e0bffe17 	ldw	r2,-8(fp)
 90cb24c:	10800003 	ldbu	r2,0(r2)
 90cb250:	10803fcc 	andi	r2,r2,255
 90cb254:	108003cc 	andi	r2,r2,15
 90cb258:	1085883a 	add	r2,r2,r2
 90cb25c:	1085883a 	add	r2,r2,r2
 90cb260:	10800204 	addi	r2,r2,8
 90cb264:	1007883a 	mov	r3,r2
 90cb268:	e0bffe17 	ldw	r2,-8(fp)
 90cb26c:	100b883a 	mov	r5,r2
 90cb270:	180d883a 	mov	r6,r3
 90cb274:	90894600 	call	9089460 <memcpy>

   tx->tchksum = 0;
 90cb278:	e0bffc17 	ldw	r2,-16(fp)
 90cb27c:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 90cb280:	e0bff903 	ldbu	r2,-28(fp)
 90cb284:	1004d07a 	srli	r2,r2,1
 90cb288:	11403fcc 	andi	r5,r2,255
 90cb28c:	e13ffc17 	ldw	r4,-16(fp)
 90cb290:	90a4ef40 	call	90a4ef4 <cksum>
 90cb294:	0084303a 	nor	r2,zero,r2
 90cb298:	1007883a 	mov	r3,r2
 90cb29c:	e0bffc17 	ldw	r2,-16(fp)
 90cb2a0:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 90cb2a4:	e0fff903 	ldbu	r3,-28(fp)
 90cb2a8:	e0bffd17 	ldw	r2,-12(fp)
 90cb2ac:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 90cb2b0:	e0bffb17 	ldw	r2,-20(fp)
 90cb2b4:	10c00417 	ldw	r3,16(r2)
 90cb2b8:	e0bffd17 	ldw	r2,-12(fp)
 90cb2bc:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 90cb2c0:	01000044 	movi	r4,1
 90cb2c4:	e17ffd17 	ldw	r5,-12(fp)
 90cb2c8:	90be8c40 	call	90be8c4 <ip_write>
 90cb2cc:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 90cb2d0:	e0bffa17 	ldw	r2,-24(fp)
 90cb2d4:	1004403a 	cmpge	r2,r2,zero
 90cb2d8:	1000111e 	bne	r2,zero,90cb320 <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 90cb2dc:	008243b4 	movhi	r2,2318
 90cb2e0:	10b84a04 	addi	r2,r2,-7896
 90cb2e4:	10800e17 	ldw	r2,56(r2)
 90cb2e8:	10c00044 	addi	r3,r2,1
 90cb2ec:	008243b4 	movhi	r2,2318
 90cb2f0:	10b84a04 	addi	r2,r2,-7896
 90cb2f4:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 90cb2f8:	00824374 	movhi	r2,2317
 90cb2fc:	108f0904 	addi	r2,r2,15396
 90cb300:	10800017 	ldw	r2,0(r2)
 90cb304:	1080860c 	andi	r2,r2,536
 90cb308:	1005003a 	cmpeq	r2,r2,zero
 90cb30c:	1000121e 	bne	r2,zero,90cb358 <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 90cb310:	01024374 	movhi	r4,2317
 90cb314:	21067c04 	addi	r4,r4,6640
 90cb318:	90836b80 	call	90836b8 <puts>
#endif   /* NPDEBUG  */
      return;
 90cb31c:	00000e06 	br	90cb358 <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 90cb320:	008243b4 	movhi	r2,2318
 90cb324:	10b84a04 	addi	r2,r2,-7896
 90cb328:	10800d17 	ldw	r2,52(r2)
 90cb32c:	10c00044 	addi	r3,r2,1
 90cb330:	008243b4 	movhi	r2,2318
 90cb334:	10b84a04 	addi	r2,r2,-7896
 90cb338:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 90cb33c:	008243b4 	movhi	r2,2318
 90cb340:	10b84a04 	addi	r2,r2,-7896
 90cb344:	10801017 	ldw	r2,64(r2)
 90cb348:	10c00044 	addi	r3,r2,1
 90cb34c:	008243b4 	movhi	r2,2318
 90cb350:	10b84a04 	addi	r2,r2,-7896
 90cb354:	10c01015 	stw	r3,64(r2)
   return;
}
 90cb358:	e037883a 	mov	sp,fp
 90cb35c:	dfc00117 	ldw	ra,4(sp)
 90cb360:	df000017 	ldw	fp,0(sp)
 90cb364:	dec00204 	addi	sp,sp,8
 90cb368:	f800283a 	ret

090cb36c <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 90cb36c:	defffc04 	addi	sp,sp,-16
 90cb370:	dfc00315 	stw	ra,12(sp)
 90cb374:	df000215 	stw	fp,8(sp)
 90cb378:	df000204 	addi	fp,sp,8
 90cb37c:	e13ffe15 	stw	r4,-8(fp)
 90cb380:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 90cb384:	d0a0dd17 	ldw	r2,-31884(gp)
 90cb388:	1005003a 	cmpeq	r2,r2,zero
 90cb38c:	1000041e 	bne	r2,zero,90cb3a0 <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 90cb390:	d0a0dd17 	ldw	r2,-31884(gp)
 90cb394:	e13ffe17 	ldw	r4,-8(fp)
 90cb398:	e17fff17 	ldw	r5,-4(fp)
 90cb39c:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 90cb3a0:	e13ffe17 	ldw	r4,-8(fp)
 90cb3a4:	e17fff17 	ldw	r5,-4(fp)
 90cb3a8:	90ac6e80 	call	90ac6e8 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 90cb3ac:	e037883a 	mov	sp,fp
 90cb3b0:	dfc00117 	ldw	ra,4(sp)
 90cb3b4:	df000017 	ldw	fp,0(sp)
 90cb3b8:	dec00204 	addi	sp,sp,8
 90cb3bc:	f800283a 	ret

090cb3c0 <_atoi_r>:
 90cb3c0:	000d883a 	mov	r6,zero
 90cb3c4:	01c00284 	movi	r7,10
 90cb3c8:	90cb7001 	jmpi	90cb700 <_strtol_r>

090cb3cc <atoi>:
 90cb3cc:	000b883a 	mov	r5,zero
 90cb3d0:	01800284 	movi	r6,10
 90cb3d4:	90cb9441 	jmpi	90cb944 <strtol>

090cb3d8 <calloc>:
 90cb3d8:	01824374 	movhi	r6,2317
 90cb3dc:	318e8604 	addi	r6,r6,14872
 90cb3e0:	2007883a 	mov	r3,r4
 90cb3e4:	31000017 	ldw	r4,0(r6)
 90cb3e8:	280d883a 	mov	r6,r5
 90cb3ec:	180b883a 	mov	r5,r3
 90cb3f0:	908b1081 	jmpi	908b108 <_calloc_r>
 90cb3f4:	defffe04 	addi	sp,sp,-8
 90cb3f8:	000b883a 	mov	r5,zero
 90cb3fc:	dc000015 	stw	r16,0(sp)
 90cb400:	dfc00115 	stw	ra,4(sp)
 90cb404:	2021883a 	mov	r16,r4
 90cb408:	90cba140 	call	90cba14 <__call_exitprocs>
 90cb40c:	00824374 	movhi	r2,2317
 90cb410:	108e8704 	addi	r2,r2,14876
 90cb414:	11000017 	ldw	r4,0(r2)
 90cb418:	20800f17 	ldw	r2,60(r4)
 90cb41c:	10000126 	beq	r2,zero,90cb424 <calloc+0x4c>
 90cb420:	103ee83a 	callr	r2
 90cb424:	8009883a 	mov	r4,r16
 90cb428:	60200000 	call	6020000 <__reset>

090cb42c <free>:
 90cb42c:	00824374 	movhi	r2,2317
 90cb430:	108e8604 	addi	r2,r2,14872
 90cb434:	200b883a 	mov	r5,r4
 90cb438:	11000017 	ldw	r4,0(r2)
 90cb43c:	90880b41 	jmpi	90880b4 <_free_r>

090cb440 <malloc>:
 90cb440:	00824374 	movhi	r2,2317
 90cb444:	108e8604 	addi	r2,r2,14872
 90cb448:	200b883a 	mov	r5,r4
 90cb44c:	11000017 	ldw	r4,0(r2)
 90cb450:	9088c3c1 	jmpi	9088c3c <_malloc_r>

090cb454 <memcmp>:
 90cb454:	00c000c4 	movi	r3,3
 90cb458:	1980032e 	bgeu	r3,r6,90cb468 <memcmp+0x14>
 90cb45c:	2144b03a 	or	r2,r4,r5
 90cb460:	10c4703a 	and	r2,r2,r3
 90cb464:	10000f26 	beq	r2,zero,90cb4a4 <memcmp+0x50>
 90cb468:	31ffffc4 	addi	r7,r6,-1
 90cb46c:	3000061e 	bne	r6,zero,90cb488 <memcmp+0x34>
 90cb470:	00000a06 	br	90cb49c <memcmp+0x48>
 90cb474:	39ffffc4 	addi	r7,r7,-1
 90cb478:	00bfffc4 	movi	r2,-1
 90cb47c:	21000044 	addi	r4,r4,1
 90cb480:	29400044 	addi	r5,r5,1
 90cb484:	38800526 	beq	r7,r2,90cb49c <memcmp+0x48>
 90cb488:	20c00003 	ldbu	r3,0(r4)
 90cb48c:	28800003 	ldbu	r2,0(r5)
 90cb490:	18bff826 	beq	r3,r2,90cb474 <memcmp+0x20>
 90cb494:	1885c83a 	sub	r2,r3,r2
 90cb498:	f800283a 	ret
 90cb49c:	0005883a 	mov	r2,zero
 90cb4a0:	f800283a 	ret
 90cb4a4:	180f883a 	mov	r7,r3
 90cb4a8:	20c00017 	ldw	r3,0(r4)
 90cb4ac:	28800017 	ldw	r2,0(r5)
 90cb4b0:	18bfed1e 	bne	r3,r2,90cb468 <memcmp+0x14>
 90cb4b4:	31bfff04 	addi	r6,r6,-4
 90cb4b8:	21000104 	addi	r4,r4,4
 90cb4bc:	29400104 	addi	r5,r5,4
 90cb4c0:	39bff936 	bltu	r7,r6,90cb4a8 <memcmp+0x54>
 90cb4c4:	003fe806 	br	90cb468 <memcmp+0x14>

090cb4c8 <strcpy>:
 90cb4c8:	2904b03a 	or	r2,r5,r4
 90cb4cc:	108000cc 	andi	r2,r2,3
 90cb4d0:	10000826 	beq	r2,zero,90cb4f4 <strcpy+0x2c>
 90cb4d4:	2007883a 	mov	r3,r4
 90cb4d8:	28800003 	ldbu	r2,0(r5)
 90cb4dc:	29400044 	addi	r5,r5,1
 90cb4e0:	18800005 	stb	r2,0(r3)
 90cb4e4:	18c00044 	addi	r3,r3,1
 90cb4e8:	103ffb1e 	bne	r2,zero,90cb4d8 <strcpy+0x10>
 90cb4ec:	2005883a 	mov	r2,r4
 90cb4f0:	f800283a 	ret
 90cb4f4:	29800017 	ldw	r6,0(r5)
 90cb4f8:	023fbff4 	movhi	r8,65279
 90cb4fc:	423fbfc4 	addi	r8,r8,-257
 90cb500:	02a02074 	movhi	r10,32897
 90cb504:	52a02004 	addi	r10,r10,-32640
 90cb508:	3205883a 	add	r2,r6,r8
 90cb50c:	0186303a 	nor	r3,zero,r6
 90cb510:	10c4703a 	and	r2,r2,r3
 90cb514:	1284703a 	and	r2,r2,r10
 90cb518:	200f883a 	mov	r7,r4
 90cb51c:	10000b1e 	bne	r2,zero,90cb54c <strcpy+0x84>
 90cb520:	4013883a 	mov	r9,r8
 90cb524:	5011883a 	mov	r8,r10
 90cb528:	39800015 	stw	r6,0(r7)
 90cb52c:	29400104 	addi	r5,r5,4
 90cb530:	29800017 	ldw	r6,0(r5)
 90cb534:	39c00104 	addi	r7,r7,4
 90cb538:	3245883a 	add	r2,r6,r9
 90cb53c:	0186303a 	nor	r3,zero,r6
 90cb540:	10c4703a 	and	r2,r2,r3
 90cb544:	1204703a 	and	r2,r2,r8
 90cb548:	103ff726 	beq	r2,zero,90cb528 <strcpy+0x60>
 90cb54c:	3807883a 	mov	r3,r7
 90cb550:	003fe106 	br	90cb4d8 <strcpy+0x10>

090cb554 <strncmp>:
 90cb554:	30003926 	beq	r6,zero,90cb63c <strncmp+0xe8>
 90cb558:	2144b03a 	or	r2,r4,r5
 90cb55c:	108000cc 	andi	r2,r2,3
 90cb560:	028000c4 	movi	r10,3
 90cb564:	1000241e 	bne	r2,zero,90cb5f8 <strncmp+0xa4>
 90cb568:	2011883a 	mov	r8,r4
 90cb56c:	280f883a 	mov	r7,r5
 90cb570:	51801f2e 	bgeu	r10,r6,90cb5f0 <strncmp+0x9c>
 90cb574:	21000017 	ldw	r4,0(r4)
 90cb578:	28800017 	ldw	r2,0(r5)
 90cb57c:	20801c1e 	bne	r4,r2,90cb5f0 <strncmp+0x9c>
 90cb580:	31bfff04 	addi	r6,r6,-4
 90cb584:	30002d26 	beq	r6,zero,90cb63c <strncmp+0xe8>
 90cb588:	027fbff4 	movhi	r9,65279
 90cb58c:	4a7fbfc4 	addi	r9,r9,-257
 90cb590:	2247883a 	add	r3,r4,r9
 90cb594:	01602074 	movhi	r5,32897
 90cb598:	29602004 	addi	r5,r5,-32640
 90cb59c:	1946703a 	and	r3,r3,r5
 90cb5a0:	0104303a 	nor	r2,zero,r4
 90cb5a4:	10c4703a 	and	r2,r2,r3
 90cb5a8:	1000241e 	bne	r2,zero,90cb63c <strncmp+0xe8>
 90cb5ac:	5017883a 	mov	r11,r10
 90cb5b0:	4815883a 	mov	r10,r9
 90cb5b4:	2813883a 	mov	r9,r5
 90cb5b8:	00000a06 	br	90cb5e4 <strncmp+0x90>
 90cb5bc:	41000017 	ldw	r4,0(r8)
 90cb5c0:	39400017 	ldw	r5,0(r7)
 90cb5c4:	2285883a 	add	r2,r4,r10
 90cb5c8:	1244703a 	and	r2,r2,r9
 90cb5cc:	0106303a 	nor	r3,zero,r4
 90cb5d0:	1886703a 	and	r3,r3,r2
 90cb5d4:	2140061e 	bne	r4,r5,90cb5f0 <strncmp+0x9c>
 90cb5d8:	31bfff04 	addi	r6,r6,-4
 90cb5dc:	30001726 	beq	r6,zero,90cb63c <strncmp+0xe8>
 90cb5e0:	1800161e 	bne	r3,zero,90cb63c <strncmp+0xe8>
 90cb5e4:	42000104 	addi	r8,r8,4
 90cb5e8:	39c00104 	addi	r7,r7,4
 90cb5ec:	59bff336 	bltu	r11,r6,90cb5bc <strncmp+0x68>
 90cb5f0:	4009883a 	mov	r4,r8
 90cb5f4:	380b883a 	mov	r5,r7
 90cb5f8:	31bfffc4 	addi	r6,r6,-1
 90cb5fc:	01ffffc4 	movi	r7,-1
 90cb600:	31c00a1e 	bne	r6,r7,90cb62c <strncmp+0xd8>
 90cb604:	20c00003 	ldbu	r3,0(r4)
 90cb608:	28800003 	ldbu	r2,0(r5)
 90cb60c:	1885c83a 	sub	r2,r3,r2
 90cb610:	f800283a 	ret
 90cb614:	30000926 	beq	r6,zero,90cb63c <strncmp+0xe8>
 90cb618:	18000826 	beq	r3,zero,90cb63c <strncmp+0xe8>
 90cb61c:	31bfffc4 	addi	r6,r6,-1
 90cb620:	21000044 	addi	r4,r4,1
 90cb624:	29400044 	addi	r5,r5,1
 90cb628:	31fff626 	beq	r6,r7,90cb604 <strncmp+0xb0>
 90cb62c:	20c00007 	ldb	r3,0(r4)
 90cb630:	28800007 	ldb	r2,0(r5)
 90cb634:	18bff726 	beq	r3,r2,90cb614 <strncmp+0xc0>
 90cb638:	003ff206 	br	90cb604 <strncmp+0xb0>
 90cb63c:	0005883a 	mov	r2,zero
 90cb640:	f800283a 	ret

090cb644 <strncpy>:
 90cb644:	2904b03a 	or	r2,r5,r4
 90cb648:	108000cc 	andi	r2,r2,3
 90cb64c:	00c000c4 	movi	r3,3
 90cb650:	1000291e 	bne	r2,zero,90cb6f8 <strncpy+0xb4>
 90cb654:	1980282e 	bgeu	r3,r6,90cb6f8 <strncpy+0xb4>
 90cb658:	1817883a 	mov	r11,r3
 90cb65c:	2011883a 	mov	r8,r4
 90cb660:	02bfbff4 	movhi	r10,65279
 90cb664:	52bfbfc4 	addi	r10,r10,-257
 90cb668:	02602074 	movhi	r9,32897
 90cb66c:	4a602004 	addi	r9,r9,-32640
 90cb670:	29c00017 	ldw	r7,0(r5)
 90cb674:	3a85883a 	add	r2,r7,r10
 90cb678:	01c6303a 	nor	r3,zero,r7
 90cb67c:	10c4703a 	and	r2,r2,r3
 90cb680:	1244703a 	and	r2,r2,r9
 90cb684:	1000051e 	bne	r2,zero,90cb69c <strncpy+0x58>
 90cb688:	31bfff04 	addi	r6,r6,-4
 90cb68c:	41c00015 	stw	r7,0(r8)
 90cb690:	29400104 	addi	r5,r5,4
 90cb694:	42000104 	addi	r8,r8,4
 90cb698:	59bff536 	bltu	r11,r6,90cb670 <strncpy+0x2c>
 90cb69c:	400f883a 	mov	r7,r8
 90cb6a0:	30001326 	beq	r6,zero,90cb6f0 <strncpy+0xac>
 90cb6a4:	28800003 	ldbu	r2,0(r5)
 90cb6a8:	31bfffc4 	addi	r6,r6,-1
 90cb6ac:	38c00044 	addi	r3,r7,1
 90cb6b0:	38800005 	stb	r2,0(r7)
 90cb6b4:	10000826 	beq	r2,zero,90cb6d8 <strncpy+0x94>
 90cb6b8:	29400044 	addi	r5,r5,1
 90cb6bc:	30000c26 	beq	r6,zero,90cb6f0 <strncpy+0xac>
 90cb6c0:	28800003 	ldbu	r2,0(r5)
 90cb6c4:	31bfffc4 	addi	r6,r6,-1
 90cb6c8:	29400044 	addi	r5,r5,1
 90cb6cc:	18800005 	stb	r2,0(r3)
 90cb6d0:	18c00044 	addi	r3,r3,1
 90cb6d4:	103ff91e 	bne	r2,zero,90cb6bc <strncpy+0x78>
 90cb6d8:	30000526 	beq	r6,zero,90cb6f0 <strncpy+0xac>
 90cb6dc:	1805883a 	mov	r2,r3
 90cb6e0:	30cd883a 	add	r6,r6,r3
 90cb6e4:	10000005 	stb	zero,0(r2)
 90cb6e8:	10800044 	addi	r2,r2,1
 90cb6ec:	30bffd1e 	bne	r6,r2,90cb6e4 <strncpy+0xa0>
 90cb6f0:	2005883a 	mov	r2,r4
 90cb6f4:	f800283a 	ret
 90cb6f8:	200f883a 	mov	r7,r4
 90cb6fc:	003fe806 	br	90cb6a0 <strncpy+0x5c>

090cb700 <_strtol_r>:
 90cb700:	defff304 	addi	sp,sp,-52
 90cb704:	00824374 	movhi	r2,2317
 90cb708:	108e8504 	addi	r2,r2,14868
 90cb70c:	dcc00615 	stw	r19,24(sp)
 90cb710:	14c00017 	ldw	r19,0(r2)
 90cb714:	ddc00a15 	stw	r23,40(sp)
 90cb718:	dc000315 	stw	r16,12(sp)
 90cb71c:	dfc00c15 	stw	ra,48(sp)
 90cb720:	df000b15 	stw	fp,44(sp)
 90cb724:	dd800915 	stw	r22,36(sp)
 90cb728:	dd400815 	stw	r21,32(sp)
 90cb72c:	dd000715 	stw	r20,28(sp)
 90cb730:	dc800515 	stw	r18,20(sp)
 90cb734:	dc400415 	stw	r17,16(sp)
 90cb738:	282f883a 	mov	r23,r5
 90cb73c:	d9000015 	stw	r4,0(sp)
 90cb740:	d9800115 	stw	r6,4(sp)
 90cb744:	2821883a 	mov	r16,r5
 90cb748:	84400007 	ldb	r17,0(r16)
 90cb74c:	84000044 	addi	r16,r16,1
 90cb750:	9c47883a 	add	r3,r19,r17
 90cb754:	18800003 	ldbu	r2,0(r3)
 90cb758:	1080020c 	andi	r2,r2,8
 90cb75c:	103ffa1e 	bne	r2,zero,90cb748 <_strtol_r+0x48>
 90cb760:	00800b44 	movi	r2,45
 90cb764:	88805c26 	beq	r17,r2,90cb8d8 <_strtol_r+0x1d8>
 90cb768:	00800ac4 	movi	r2,43
 90cb76c:	88805726 	beq	r17,r2,90cb8cc <_strtol_r+0x1cc>
 90cb770:	0039883a 	mov	fp,zero
 90cb774:	3807003a 	cmpeq	r3,r7,zero
 90cb778:	1800431e 	bne	r3,zero,90cb888 <_strtol_r+0x188>
 90cb77c:	00800404 	movi	r2,16
 90cb780:	38804126 	beq	r7,r2,90cb888 <_strtol_r+0x188>
 90cb784:	3829883a 	mov	r20,r7
 90cb788:	e02cc03a 	cmpne	r22,fp,zero
 90cb78c:	b0004b1e 	bne	r22,zero,90cb8bc <_strtol_r+0x1bc>
 90cb790:	04a00034 	movhi	r18,32768
 90cb794:	94bfffc4 	addi	r18,r18,-1
 90cb798:	9009883a 	mov	r4,r18
 90cb79c:	a00b883a 	mov	r5,r20
 90cb7a0:	d9c00215 	stw	r7,8(sp)
 90cb7a4:	908d3100 	call	908d310 <__umodsi3>
 90cb7a8:	9009883a 	mov	r4,r18
 90cb7ac:	a00b883a 	mov	r5,r20
 90cb7b0:	102b883a 	mov	r21,r2
 90cb7b4:	908d3080 	call	908d308 <__udivsi3>
 90cb7b8:	1011883a 	mov	r8,r2
 90cb7bc:	9c45883a 	add	r2,r19,r17
 90cb7c0:	11000003 	ldbu	r4,0(r2)
 90cb7c4:	000b883a 	mov	r5,zero
 90cb7c8:	000d883a 	mov	r6,zero
 90cb7cc:	20c0010c 	andi	r3,r4,4
 90cb7d0:	d9c00217 	ldw	r7,8(sp)
 90cb7d4:	18000e26 	beq	r3,zero,90cb810 <_strtol_r+0x110>
 90cb7d8:	88fff404 	addi	r3,r17,-48
 90cb7dc:	19c0140e 	bge	r3,r7,90cb830 <_strtol_r+0x130>
 90cb7e0:	30003116 	blt	r6,zero,90cb8a8 <_strtol_r+0x1a8>
 90cb7e4:	41403036 	bltu	r8,r5,90cb8a8 <_strtol_r+0x1a8>
 90cb7e8:	2a002e26 	beq	r5,r8,90cb8a4 <_strtol_r+0x1a4>
 90cb7ec:	2d05383a 	mul	r2,r5,r20
 90cb7f0:	01800044 	movi	r6,1
 90cb7f4:	10cb883a 	add	r5,r2,r3
 90cb7f8:	84400007 	ldb	r17,0(r16)
 90cb7fc:	84000044 	addi	r16,r16,1
 90cb800:	9c45883a 	add	r2,r19,r17
 90cb804:	11000003 	ldbu	r4,0(r2)
 90cb808:	20c0010c 	andi	r3,r4,4
 90cb80c:	183ff21e 	bne	r3,zero,90cb7d8 <_strtol_r+0xd8>
 90cb810:	208000cc 	andi	r2,r4,3
 90cb814:	10000626 	beq	r2,zero,90cb830 <_strtol_r+0x130>
 90cb818:	2080004c 	andi	r2,r4,1
 90cb81c:	1005003a 	cmpeq	r2,r2,zero
 90cb820:	1000231e 	bne	r2,zero,90cb8b0 <_strtol_r+0x1b0>
 90cb824:	00800dc4 	movi	r2,55
 90cb828:	8887c83a 	sub	r3,r17,r2
 90cb82c:	19ffec16 	blt	r3,r7,90cb7e0 <_strtol_r+0xe0>
 90cb830:	30002d16 	blt	r6,zero,90cb8e8 <_strtol_r+0x1e8>
 90cb834:	b000231e 	bne	r22,zero,90cb8c4 <_strtol_r+0x1c4>
 90cb838:	2807883a 	mov	r3,r5
 90cb83c:	d8800117 	ldw	r2,4(sp)
 90cb840:	10000426 	beq	r2,zero,90cb854 <_strtol_r+0x154>
 90cb844:	30000126 	beq	r6,zero,90cb84c <_strtol_r+0x14c>
 90cb848:	85ffffc4 	addi	r23,r16,-1
 90cb84c:	d9000117 	ldw	r4,4(sp)
 90cb850:	25c00015 	stw	r23,0(r4)
 90cb854:	1805883a 	mov	r2,r3
 90cb858:	dfc00c17 	ldw	ra,48(sp)
 90cb85c:	df000b17 	ldw	fp,44(sp)
 90cb860:	ddc00a17 	ldw	r23,40(sp)
 90cb864:	dd800917 	ldw	r22,36(sp)
 90cb868:	dd400817 	ldw	r21,32(sp)
 90cb86c:	dd000717 	ldw	r20,28(sp)
 90cb870:	dcc00617 	ldw	r19,24(sp)
 90cb874:	dc800517 	ldw	r18,20(sp)
 90cb878:	dc400417 	ldw	r17,16(sp)
 90cb87c:	dc000317 	ldw	r16,12(sp)
 90cb880:	dec00d04 	addi	sp,sp,52
 90cb884:	f800283a 	ret
 90cb888:	00800c04 	movi	r2,48
 90cb88c:	88801d26 	beq	r17,r2,90cb904 <_strtol_r+0x204>
 90cb890:	183fbc26 	beq	r3,zero,90cb784 <_strtol_r+0x84>
 90cb894:	00800c04 	movi	r2,48
 90cb898:	88802726 	beq	r17,r2,90cb938 <_strtol_r+0x238>
 90cb89c:	01c00284 	movi	r7,10
 90cb8a0:	003fb806 	br	90cb784 <_strtol_r+0x84>
 90cb8a4:	a8ffd10e 	bge	r21,r3,90cb7ec <_strtol_r+0xec>
 90cb8a8:	01bfffc4 	movi	r6,-1
 90cb8ac:	003fd206 	br	90cb7f8 <_strtol_r+0xf8>
 90cb8b0:	008015c4 	movi	r2,87
 90cb8b4:	8887c83a 	sub	r3,r17,r2
 90cb8b8:	003fdc06 	br	90cb82c <_strtol_r+0x12c>
 90cb8bc:	04a00034 	movhi	r18,32768
 90cb8c0:	003fb506 	br	90cb798 <_strtol_r+0x98>
 90cb8c4:	0147c83a 	sub	r3,zero,r5
 90cb8c8:	003fdc06 	br	90cb83c <_strtol_r+0x13c>
 90cb8cc:	84400007 	ldb	r17,0(r16)
 90cb8d0:	84000044 	addi	r16,r16,1
 90cb8d4:	003fa606 	br	90cb770 <_strtol_r+0x70>
 90cb8d8:	84400007 	ldb	r17,0(r16)
 90cb8dc:	07000044 	movi	fp,1
 90cb8e0:	84000044 	addi	r16,r16,1
 90cb8e4:	003fa306 	br	90cb774 <_strtol_r+0x74>
 90cb8e8:	e005003a 	cmpeq	r2,fp,zero
 90cb8ec:	10000f1e 	bne	r2,zero,90cb92c <_strtol_r+0x22c>
 90cb8f0:	00e00034 	movhi	r3,32768
 90cb8f4:	d9000017 	ldw	r4,0(sp)
 90cb8f8:	00800884 	movi	r2,34
 90cb8fc:	20800015 	stw	r2,0(r4)
 90cb900:	003fce06 	br	90cb83c <_strtol_r+0x13c>
 90cb904:	81000007 	ldb	r4,0(r16)
 90cb908:	00801e04 	movi	r2,120
 90cb90c:	20800226 	beq	r4,r2,90cb918 <_strtol_r+0x218>
 90cb910:	00801604 	movi	r2,88
 90cb914:	20bfde1e 	bne	r4,r2,90cb890 <_strtol_r+0x190>
 90cb918:	84400047 	ldb	r17,1(r16)
 90cb91c:	01c00404 	movi	r7,16
 90cb920:	84000084 	addi	r16,r16,2
 90cb924:	3829883a 	mov	r20,r7
 90cb928:	003f9706 	br	90cb788 <_strtol_r+0x88>
 90cb92c:	00e00034 	movhi	r3,32768
 90cb930:	18ffffc4 	addi	r3,r3,-1
 90cb934:	003fef06 	br	90cb8f4 <_strtol_r+0x1f4>
 90cb938:	01c00204 	movi	r7,8
 90cb93c:	3829883a 	mov	r20,r7
 90cb940:	003f9106 	br	90cb788 <_strtol_r+0x88>

090cb944 <strtol>:
 90cb944:	00824374 	movhi	r2,2317
 90cb948:	108e8604 	addi	r2,r2,14872
 90cb94c:	2013883a 	mov	r9,r4
 90cb950:	11000017 	ldw	r4,0(r2)
 90cb954:	2805883a 	mov	r2,r5
 90cb958:	300f883a 	mov	r7,r6
 90cb95c:	480b883a 	mov	r5,r9
 90cb960:	100d883a 	mov	r6,r2
 90cb964:	90cb7001 	jmpi	90cb700 <_strtol_r>

090cb968 <_vprintf_r>:
 90cb968:	2807883a 	mov	r3,r5
 90cb96c:	21400217 	ldw	r5,8(r4)
 90cb970:	300f883a 	mov	r7,r6
 90cb974:	180d883a 	mov	r6,r3
 90cb978:	90840281 	jmpi	9084028 <___vfprintf_internal_r>

090cb97c <vprintf>:
 90cb97c:	00824374 	movhi	r2,2317
 90cb980:	108e8604 	addi	r2,r2,14872
 90cb984:	12000017 	ldw	r8,0(r2)
 90cb988:	280f883a 	mov	r7,r5
 90cb98c:	200d883a 	mov	r6,r4
 90cb990:	41400217 	ldw	r5,8(r8)
 90cb994:	4009883a 	mov	r4,r8
 90cb998:	90840281 	jmpi	9084028 <___vfprintf_internal_r>

090cb99c <_vsprintf_r>:
 90cb99c:	deffe804 	addi	sp,sp,-96
 90cb9a0:	00808204 	movi	r2,520
 90cb9a4:	2811883a 	mov	r8,r5
 90cb9a8:	02600034 	movhi	r9,32768
 90cb9ac:	4a7fffc4 	addi	r9,r9,-1
 90cb9b0:	d880030d 	sth	r2,12(sp)
 90cb9b4:	d80b883a 	mov	r5,sp
 90cb9b8:	00bfffc4 	movi	r2,-1
 90cb9bc:	dfc01715 	stw	ra,92(sp)
 90cb9c0:	da000415 	stw	r8,16(sp)
 90cb9c4:	da400515 	stw	r9,20(sp)
 90cb9c8:	d880038d 	sth	r2,14(sp)
 90cb9cc:	da000015 	stw	r8,0(sp)
 90cb9d0:	da400215 	stw	r9,8(sp)
 90cb9d4:	90840280 	call	9084028 <___vfprintf_internal_r>
 90cb9d8:	d8c00017 	ldw	r3,0(sp)
 90cb9dc:	18000005 	stb	zero,0(r3)
 90cb9e0:	dfc01717 	ldw	ra,92(sp)
 90cb9e4:	dec01804 	addi	sp,sp,96
 90cb9e8:	f800283a 	ret

090cb9ec <vsprintf>:
 90cb9ec:	00824374 	movhi	r2,2317
 90cb9f0:	108e8604 	addi	r2,r2,14872
 90cb9f4:	2013883a 	mov	r9,r4
 90cb9f8:	11000017 	ldw	r4,0(r2)
 90cb9fc:	2805883a 	mov	r2,r5
 90cba00:	300f883a 	mov	r7,r6
 90cba04:	480b883a 	mov	r5,r9
 90cba08:	100d883a 	mov	r6,r2
 90cba0c:	90cb99c1 	jmpi	90cb99c <_vsprintf_r>

090cba10 <register_fini>:
 90cba10:	f800283a 	ret

090cba14 <__call_exitprocs>:
 90cba14:	00824374 	movhi	r2,2317
 90cba18:	108e8704 	addi	r2,r2,14876
 90cba1c:	10800017 	ldw	r2,0(r2)
 90cba20:	defff304 	addi	sp,sp,-52
 90cba24:	df000b15 	stw	fp,44(sp)
 90cba28:	d8800115 	stw	r2,4(sp)
 90cba2c:	00824374 	movhi	r2,2317
 90cba30:	10ad0b04 	addi	r2,r2,-19412
 90cba34:	1005003a 	cmpeq	r2,r2,zero
 90cba38:	d8800215 	stw	r2,8(sp)
 90cba3c:	d8800117 	ldw	r2,4(sp)
 90cba40:	dd400815 	stw	r21,32(sp)
 90cba44:	dd000715 	stw	r20,28(sp)
 90cba48:	10805204 	addi	r2,r2,328
 90cba4c:	dfc00c15 	stw	ra,48(sp)
 90cba50:	ddc00a15 	stw	r23,40(sp)
 90cba54:	dd800915 	stw	r22,36(sp)
 90cba58:	dcc00615 	stw	r19,24(sp)
 90cba5c:	dc800515 	stw	r18,20(sp)
 90cba60:	dc400415 	stw	r17,16(sp)
 90cba64:	dc000315 	stw	r16,12(sp)
 90cba68:	282b883a 	mov	r21,r5
 90cba6c:	2039883a 	mov	fp,r4
 90cba70:	d8800015 	stw	r2,0(sp)
 90cba74:	2829003a 	cmpeq	r20,r5,zero
 90cba78:	d8800117 	ldw	r2,4(sp)
 90cba7c:	14405217 	ldw	r17,328(r2)
 90cba80:	88001026 	beq	r17,zero,90cbac4 <__call_exitprocs+0xb0>
 90cba84:	ddc00017 	ldw	r23,0(sp)
 90cba88:	88800117 	ldw	r2,4(r17)
 90cba8c:	8c802204 	addi	r18,r17,136
 90cba90:	143fffc4 	addi	r16,r2,-1
 90cba94:	80000916 	blt	r16,zero,90cbabc <__call_exitprocs+0xa8>
 90cba98:	05bfffc4 	movi	r22,-1
 90cba9c:	a000151e 	bne	r20,zero,90cbaf4 <__call_exitprocs+0xe0>
 90cbaa0:	8409883a 	add	r4,r16,r16
 90cbaa4:	2105883a 	add	r2,r4,r4
 90cbaa8:	1485883a 	add	r2,r2,r18
 90cbaac:	10c02017 	ldw	r3,128(r2)
 90cbab0:	a8c01126 	beq	r21,r3,90cbaf8 <__call_exitprocs+0xe4>
 90cbab4:	843fffc4 	addi	r16,r16,-1
 90cbab8:	85bff81e 	bne	r16,r22,90cba9c <__call_exitprocs+0x88>
 90cbabc:	d8800217 	ldw	r2,8(sp)
 90cbac0:	10003126 	beq	r2,zero,90cbb88 <__call_exitprocs+0x174>
 90cbac4:	dfc00c17 	ldw	ra,48(sp)
 90cbac8:	df000b17 	ldw	fp,44(sp)
 90cbacc:	ddc00a17 	ldw	r23,40(sp)
 90cbad0:	dd800917 	ldw	r22,36(sp)
 90cbad4:	dd400817 	ldw	r21,32(sp)
 90cbad8:	dd000717 	ldw	r20,28(sp)
 90cbadc:	dcc00617 	ldw	r19,24(sp)
 90cbae0:	dc800517 	ldw	r18,20(sp)
 90cbae4:	dc400417 	ldw	r17,16(sp)
 90cbae8:	dc000317 	ldw	r16,12(sp)
 90cbaec:	dec00d04 	addi	sp,sp,52
 90cbaf0:	f800283a 	ret
 90cbaf4:	8409883a 	add	r4,r16,r16
 90cbaf8:	88c00117 	ldw	r3,4(r17)
 90cbafc:	2105883a 	add	r2,r4,r4
 90cbb00:	1445883a 	add	r2,r2,r17
 90cbb04:	18ffffc4 	addi	r3,r3,-1
 90cbb08:	11800217 	ldw	r6,8(r2)
 90cbb0c:	1c001526 	beq	r3,r16,90cbb64 <__call_exitprocs+0x150>
 90cbb10:	10000215 	stw	zero,8(r2)
 90cbb14:	303fe726 	beq	r6,zero,90cbab4 <__call_exitprocs+0xa0>
 90cbb18:	00c00044 	movi	r3,1
 90cbb1c:	1c06983a 	sll	r3,r3,r16
 90cbb20:	90804017 	ldw	r2,256(r18)
 90cbb24:	8cc00117 	ldw	r19,4(r17)
 90cbb28:	1884703a 	and	r2,r3,r2
 90cbb2c:	10001426 	beq	r2,zero,90cbb80 <__call_exitprocs+0x16c>
 90cbb30:	90804117 	ldw	r2,260(r18)
 90cbb34:	1884703a 	and	r2,r3,r2
 90cbb38:	10000c1e 	bne	r2,zero,90cbb6c <__call_exitprocs+0x158>
 90cbb3c:	2105883a 	add	r2,r4,r4
 90cbb40:	1485883a 	add	r2,r2,r18
 90cbb44:	11400017 	ldw	r5,0(r2)
 90cbb48:	e009883a 	mov	r4,fp
 90cbb4c:	303ee83a 	callr	r6
 90cbb50:	88800117 	ldw	r2,4(r17)
 90cbb54:	98bfc81e 	bne	r19,r2,90cba78 <__call_exitprocs+0x64>
 90cbb58:	b8800017 	ldw	r2,0(r23)
 90cbb5c:	147fd526 	beq	r2,r17,90cbab4 <__call_exitprocs+0xa0>
 90cbb60:	003fc506 	br	90cba78 <__call_exitprocs+0x64>
 90cbb64:	8c000115 	stw	r16,4(r17)
 90cbb68:	003fea06 	br	90cbb14 <__call_exitprocs+0x100>
 90cbb6c:	2105883a 	add	r2,r4,r4
 90cbb70:	1485883a 	add	r2,r2,r18
 90cbb74:	11000017 	ldw	r4,0(r2)
 90cbb78:	303ee83a 	callr	r6
 90cbb7c:	003ff406 	br	90cbb50 <__call_exitprocs+0x13c>
 90cbb80:	303ee83a 	callr	r6
 90cbb84:	003ff206 	br	90cbb50 <__call_exitprocs+0x13c>
 90cbb88:	88800117 	ldw	r2,4(r17)
 90cbb8c:	1000081e 	bne	r2,zero,90cbbb0 <__call_exitprocs+0x19c>
 90cbb90:	89000017 	ldw	r4,0(r17)
 90cbb94:	20000726 	beq	r4,zero,90cbbb4 <__call_exitprocs+0x1a0>
 90cbb98:	b9000015 	stw	r4,0(r23)
 90cbb9c:	8809883a 	mov	r4,r17
 90cbba0:	90cb42c0 	call	90cb42c <free>
 90cbba4:	bc400017 	ldw	r17,0(r23)
 90cbba8:	883fb71e 	bne	r17,zero,90cba88 <__call_exitprocs+0x74>
 90cbbac:	003fc506 	br	90cbac4 <__call_exitprocs+0xb0>
 90cbbb0:	89000017 	ldw	r4,0(r17)
 90cbbb4:	882f883a 	mov	r23,r17
 90cbbb8:	2023883a 	mov	r17,r4
 90cbbbc:	883fb21e 	bne	r17,zero,90cba88 <__call_exitprocs+0x74>
 90cbbc0:	003fc006 	br	90cbac4 <__call_exitprocs+0xb0>

090cbbc4 <__fixunsdfsi>:
 90cbbc4:	defffb04 	addi	sp,sp,-20
 90cbbc8:	dc400115 	stw	r17,4(sp)
 90cbbcc:	dc000015 	stw	r16,0(sp)
 90cbbd0:	04507834 	movhi	r17,16864
 90cbbd4:	0021883a 	mov	r16,zero
 90cbbd8:	800d883a 	mov	r6,r16
 90cbbdc:	880f883a 	mov	r7,r17
 90cbbe0:	dcc00315 	stw	r19,12(sp)
 90cbbe4:	dc800215 	stw	r18,8(sp)
 90cbbe8:	2827883a 	mov	r19,r5
 90cbbec:	2025883a 	mov	r18,r4
 90cbbf0:	dfc00415 	stw	ra,16(sp)
 90cbbf4:	908cd580 	call	908cd58 <__gedf2>
 90cbbf8:	000d883a 	mov	r6,zero
 90cbbfc:	880f883a 	mov	r7,r17
 90cbc00:	980b883a 	mov	r5,r19
 90cbc04:	9009883a 	mov	r4,r18
 90cbc08:	10000d16 	blt	r2,zero,90cbc40 <__fixunsdfsi+0x7c>
 90cbc0c:	908c4c00 	call	908c4c0 <__subdf3>
 90cbc10:	180b883a 	mov	r5,r3
 90cbc14:	1009883a 	mov	r4,r2
 90cbc18:	908cf600 	call	908cf60 <__fixdfsi>
 90cbc1c:	00e00034 	movhi	r3,32768
 90cbc20:	10c5883a 	add	r2,r2,r3
 90cbc24:	dfc00417 	ldw	ra,16(sp)
 90cbc28:	dcc00317 	ldw	r19,12(sp)
 90cbc2c:	dc800217 	ldw	r18,8(sp)
 90cbc30:	dc400117 	ldw	r17,4(sp)
 90cbc34:	dc000017 	ldw	r16,0(sp)
 90cbc38:	dec00504 	addi	sp,sp,20
 90cbc3c:	f800283a 	ret
 90cbc40:	980b883a 	mov	r5,r19
 90cbc44:	9009883a 	mov	r4,r18
 90cbc48:	908cf600 	call	908cf60 <__fixdfsi>
 90cbc4c:	dfc00417 	ldw	ra,16(sp)
 90cbc50:	dcc00317 	ldw	r19,12(sp)
 90cbc54:	dc800217 	ldw	r18,8(sp)
 90cbc58:	dc400117 	ldw	r17,4(sp)
 90cbc5c:	dc000017 	ldw	r16,0(sp)
 90cbc60:	dec00504 	addi	sp,sp,20
 90cbc64:	f800283a 	ret
 90cbc68:	090cba10 	cmplti	r4,at,13032
